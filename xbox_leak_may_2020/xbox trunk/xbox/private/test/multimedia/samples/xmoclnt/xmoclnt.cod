; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\xmoclnt.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BF@NHIFGCCK@t?3?2media?2xmoclnt?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Direct3D_AddRef@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Direct3D_Release@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Direct3D_GetAdapterCount@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_BeginScene@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_EndScene@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_GetRenderState@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_GetTextureStageState@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_SetRenderState@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_SetTextureStageState@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DResource_MoveResourceMemory@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DTexture_UnlockRect@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DVolumeTexture_UnlockBox@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DCubeTexture_UnlockRect@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DVertexBuffer_Unlock@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DIndexBuffer_Lock@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DIndexBuffer_Unlock@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DPalette_Unlock@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DSurface_UnlockRect@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DVolume_UnlockBox@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXPLANE@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _main
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pszFileName@?1??main@@9@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?dwPacketCount@?1??main@@9@4KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?dwPlaybackFrequency@?1??main@@9@4KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?dwPacketSize@?1??main@@9@4KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_D3DPRIMITIVETOVERTEXCOUNT
PUBLIC	_D3DSIMPLERENDERSTATEENCODE
PUBLIC	_D3DTEXTUREDIRECTENCODE
PUBLIC	_D3DDIRTYFROMRENDERSTATE
PUBLIC	_D3DDIRTYFROMTEXTURESTATE
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
CONST	SEGMENT
_D3DPRIMITIVETOVERTEXCOUNT DD 00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
CONST	SEGMENT
_D3DSIMPLERENDERSTATEENCODE DD 040260H
	DD	040264H
	DD	040268H
	DD	04026cH
	DD	040270H
	DD	040274H
	DD	040278H
	DD	04027cH
	DD	040288H
	DD	04028cH
	DD	040a60H
	DD	040a64H
	DD	040a68H
	DD	040a6cH
	DD	040a70H
	DD	040a74H
	DD	040a78H
	DD	040a7cH
	DD	040a80H
	DD	040a84H
	DD	040a88H
	DD	040a8cH
	DD	040a90H
	DD	040a94H
	DD	040a98H
	DD	040a9cH
	DD	040aa0H
	DD	040aa4H
	DD	040aa8H
	DD	040aacH
	DD	040ab0H
	DD	040ab4H
	DD	040ab8H
	DD	040abcH
	DD	040ac0H
	DD	040ac4H
	DD	040ac8H
	DD	040accH
	DD	040ad0H
	DD	040ad4H
	DD	040ad8H
	DD	040adcH
	DD	0417f8H
	DD	041e20H
	DD	041e24H
	DD	041e40H
	DD	041e44H
	DD	041e48H
	DD	041e4cH
	DD	041e50H
	DD	041e54H
	DD	041e58H
	DD	041e5cH
	DD	041e60H
	DD	041d90H
	DD	041e74H
	DD	041e78H
	DD	040354H
	DD	04033cH
	DD	040304H
	DD	040300H
	DD	040340H
	DD	040344H
	DD	040348H
	DD	04035cH
	DD	040310H
	DD	04037cH
	DD	040358H
	DD	040374H
	DD	040378H
	DD	040364H
	DD	040368H
	DD	04036cH
	DD	040360H
	DD	040350H
	DD	04034cH
	DD	0409f8H
	DD	040384H
	DD	040388H
	DD	040330H
	DD	040334H
	DD	040338H
CONST	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
CONST	SEGMENT
_D3DTEXTUREDIRECTENCODE DD 081b00H
	DD	081b40H
	DD	081b80H
	DD	081bc0H
CONST	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
CONST	SEGMENT
_D3DDIRTYFROMRENDERSTATE DD 02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	01200H
	DD	03000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	0100H
	DD	0100H
	DD	0900H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
CONST	SEGMENT
_D3DDIRTYFROMTEXTURESTATE DD 0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0480fH
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0400H
CONST	ENDS
PUBLIC	_main
PUBLIC	??_C@_0BF@NHIFGCCK@t?3?2media?2xmoclnt?4wav?$AA@ ; `string'
EXTRN	??0CSrcMediaObject@@QAE@KKK@Z:NEAR		; CSrcMediaObject::CSrcMediaObject
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_LocalAlloc@8:NEAR
EXTRN	_LocalFree@4:NEAR
EXTRN	_ResetEvent@4:NEAR
EXTRN	_WaitForMultipleObjects@16:NEAR
EXTRN	_DirectSoundCreateStream@8:NEAR
EXTRN	_CloseHandle@4:NEAR
EXTRN	_XWaveFileCreateMediaObject@12:NEAR
EXTRN	_memset:NEAR
EXTRN	_CreateEventA@16:NEAR
;	COMDAT ?pszFileName@?1??main@@9@4QBDB
; File c:\xbox\private\test\multimedia\samples\xmoclnt\xmoclnt.cpp
CONST	SEGMENT
?pszFileName@?1??main@@9@4QBDB DD FLAT:??_C@_0BF@NHIFGCCK@t?3?2media?2xmoclnt?4wav?$AA@ ; `main'::`2'::pszFileName
CONST	ENDS
;	COMDAT ??_C@_0BF@NHIFGCCK@t?3?2media?2xmoclnt?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@NHIFGCCK@t?3?2media?2xmoclnt?4wav?$AA@ DB 't:\media\xmoclnt.wav'
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _main
_TEXT	SEGMENT
tv80 = -156
$T18668 = -152
_dwDestinationCompletedSize$ = -148
_dssd$ = -144
_dwPacketIndex$ = -120
_dwSourceCompletedSize$ = -116
_hr$ = -112
_pRenderFilter$ = -108
_pvDestinationBuffer$ = -104
_xmpDestination$ = -100
_pSourceFilter$ = -76
_pIntermediateFilter$ = -72
_ahPacketEvents$ = -68
_xmpSource$ = -52
_pwfxFile$ = -28
_pvSourceBuffer$ = -24
_wfxStream$ = -20
_main	PROC NEAR					; COMDAT

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH

; 33   :     static const LPCSTR     pszFileName                         = "t:\\media\\xmoclnt.wav";
; 34   :     static const DWORD      dwPlaybackFrequency                 = 48000;
; 35   :     static const DWORD      dwPacketCount                       = 4;
; 36   :     static const DWORD      dwPacketSize                        = 0x4000;
; 37   :     LPXFILEMEDIAOBJECT      pSourceFilter                       = NULL;

  00009	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _pSourceFilter$[ebp], 0

; 38   :     LPXMEDIAOBJECT          pIntermediateFilter                 = NULL;

  00010	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _pIntermediateFilter$[ebp], 0

; 39   :     LPDIRECTSOUNDSTREAM     pRenderFilter                       = NULL;

  00017	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _pRenderFilter$[ebp], 0

; 40   :     LPVOID                  pvSourceBuffer                      = NULL;

  0001e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pvSourceBuffer$[ebp], 0

; 41   :     LPVOID                  pvDestinationBuffer                 = NULL;

  00025	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _pvDestinationBuffer$[ebp], 0

; 42   :     HANDLE                  ahPacketEvents[dwPacketCount];
; 43   :     XMEDIAPACKET            xmpSource;
; 44   :     XMEDIAPACKET            xmpDestination;
; 45   :     DWORD                   dwSourceCompletedSize;
; 46   :     DWORD                   dwDestinationCompletedSize;
; 47   :     DWORD                   dwPacketIndex;
; 48   :     LPCWAVEFORMATEX         pwfxFile;
; 49   :     WAVEFORMATEX            wfxStream;
; 50   :     DSSTREAMDESC            dssd;
; 51   :     HRESULT                 hr;
; 52   : 
; 53   :     //
; 54   :     // We'll use a hard-coded packet size, because... well... I'm lazy.
; 55   :     // In a shipping application, you'd want to calculate the optimal packet
; 56   :     // size based on alignment restrictions and the MaxLookahead of any
; 57   :     // asynchronous filters.  I'm going to make up a constant value.  If
; 58   :     // the SRC has to do a significant downsample before sending to the
; 59   :     // renderer, it's possible the stream will starve.
; 60   :     //
; 61   : 
; 62   :     //
; 63   :     // Create the source (wave file) filter.  We'll assume the source file
; 64   :     // is 16-bit PCM.  Other than that, we don't really care what the format
; 65   :     // is.
; 66   :     //
; 67   : 
; 68   :     hr = XWaveFileCreateMediaObject(pszFileName, &pwfxFile, &pSourceFilter);

  0002c	8d 45 b4	 lea	 eax, DWORD PTR _pSourceFilter$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d e4	 lea	 ecx, DWORD PTR _pwfxFile$[ebp]
  00033	51		 push	 ecx
  00034	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pszFileName@?1??main@@9@4QBDB
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 _XWaveFileCreateMediaObject@12
  00040	89 45 90	 mov	 DWORD PTR _hr$[ebp], eax

; 69   : 
; 70   :     //
; 71   :     // Create the intermediate (SRC) filter
; 72   :     //
; 73   : 
; 74   :     if(SUCCEEDED(hr))

  00043	83 7d 90 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00047	7c 60		 jl	 SHORT $L18572

; 75   :     {
; 76   :         if(!(pIntermediateFilter = new CSrcMediaObject(pwfxFile->nChannels, pwfxFile->nSamplesPerSec, dwPlaybackFrequency)))

  00049	6a 20		 push	 32			; 00000020H
  0004b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00050	83 c4 04	 add	 esp, 4
  00053	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T18668[ebp], eax
  00059	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR $T18668[ebp], 0
  00060	74 27		 je	 SHORT $L18669
  00062	68 80 bb 00 00	 push	 48000			; 0000bb80H
  00067	8b 45 e4	 mov	 eax, DWORD PTR _pwfxFile$[ebp]
  0006a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006d	51		 push	 ecx
  0006e	8b 55 e4	 mov	 edx, DWORD PTR _pwfxFile$[ebp]
  00071	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00075	50		 push	 eax
  00076	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR $T18668[ebp]
  0007c	e8 00 00 00 00	 call	 ??0CSrcMediaObject@@QAE@KKK@Z ; CSrcMediaObject::CSrcMediaObject
  00081	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv80[ebp], eax
  00087	eb 0a		 jmp	 SHORT $L18670
$L18669:
  00089	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv80[ebp], 0
$L18670:
  00093	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR tv80[ebp]
  00099	89 4d b8	 mov	 DWORD PTR _pIntermediateFilter$[ebp], ecx
  0009c	83 7d b8 00	 cmp	 DWORD PTR _pIntermediateFilter$[ebp], 0
  000a0	75 07		 jne	 SHORT $L18572

; 77   :         {
; 78   :             hr = E_OUTOFMEMORY;

  000a2	c7 45 90 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L18572:

; 79   :         }
; 80   :     }
; 81   : 
; 82   :     //
; 83   :     // Create the render (DirectSound stream) filter
; 84   :     //
; 85   : 
; 86   :     if(SUCCEEDED(hr))

  000a9	83 7d 90 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ad	0f 8c 81 00 00
	00		 jl	 $L18578

; 87   :     {
; 88   :         wfxStream.wFormatTag = WAVE_FORMAT_PCM;

  000b3	66 c7 45 ec 01
	00		 mov	 WORD PTR _wfxStream$[ebp], 1

; 89   :         wfxStream.nChannels = pwfxFile->nChannels;

  000b9	8b 55 e4	 mov	 edx, DWORD PTR _pwfxFile$[ebp]
  000bc	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  000c0	66 89 45 ee	 mov	 WORD PTR _wfxStream$[ebp+2], ax

; 90   :         wfxStream.nSamplesPerSec = dwPlaybackFrequency;

  000c4	c7 45 f0 80 bb
	00 00		 mov	 DWORD PTR _wfxStream$[ebp+4], 48000 ; 0000bb80H

; 91   :         wfxStream.wBitsPerSample = pwfxFile->wBitsPerSample;

  000cb	8b 4d e4	 mov	 ecx, DWORD PTR _pwfxFile$[ebp]
  000ce	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  000d2	66 89 55 fa	 mov	 WORD PTR _wfxStream$[ebp+14], dx

; 92   :         wfxStream.nBlockAlign = wfxStream.nChannels * wfxStream.wBitsPerSample / 8;

  000d6	0f b7 45 ee	 movzx	 eax, WORD PTR _wfxStream$[ebp+2]
  000da	0f b7 4d fa	 movzx	 ecx, WORD PTR _wfxStream$[ebp+14]
  000de	0f af c1	 imul	 eax, ecx
  000e1	99		 cdq
  000e2	83 e2 07	 and	 edx, 7
  000e5	03 c2		 add	 eax, edx
  000e7	c1 f8 03	 sar	 eax, 3
  000ea	66 89 45 f8	 mov	 WORD PTR _wfxStream$[ebp+12], ax

; 93   :         wfxStream.nAvgBytesPerSec = wfxStream.nSamplesPerSec * wfxStream.nBlockAlign;

  000ee	0f b7 55 f8	 movzx	 edx, WORD PTR _wfxStream$[ebp+12]
  000f2	8b 45 f0	 mov	 eax, DWORD PTR _wfxStream$[ebp+4]
  000f5	0f af c2	 imul	 eax, edx
  000f8	89 45 f4	 mov	 DWORD PTR _wfxStream$[ebp+8], eax

; 94   :         
; 95   :         ZeroMemory(&dssd, sizeof(dssd));

  000fb	6a 18		 push	 24			; 00000018H
  000fd	6a 00		 push	 0
  000ff	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _dssd$[ebp]
  00105	51		 push	 ecx
  00106	e8 00 00 00 00	 call	 _memset
  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 96   : 
; 97   : #ifdef SILVER
; 98   :         dssd.dwSize = sizeof(dssd);
; 99   : #endif // SILVER
; 100  :         dssd.dwMaxAttachedPackets = dwPacketCount;

  0010e	c7 85 74 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR _dssd$[ebp+4], 4

; 101  :         dssd.lpwfxFormat = &wfxStream;

  00118	8d 55 ec	 lea	 edx, DWORD PTR _wfxStream$[ebp]
  0011b	89 95 78 ff ff
	ff		 mov	 DWORD PTR _dssd$[ebp+8], edx

; 102  : 
; 103  : #ifdef SILVER
; 104  :         hr = DirectSoundCreateStream(DSDEVID_MCPX, &dssd, &pRenderFilter, NULL);
; 105  : #else // SILVER
; 106  : 		hr = DirectSoundCreateStream( &dssd, &pRenderFilter );

  00121	8d 45 94	 lea	 eax, DWORD PTR _pRenderFilter$[ebp]
  00124	50		 push	 eax
  00125	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _dssd$[ebp]
  0012b	51		 push	 ecx
  0012c	e8 00 00 00 00	 call	 _DirectSoundCreateStream@8
  00131	89 45 90	 mov	 DWORD PTR _hr$[ebp], eax
$L18578:

; 107  : #endif // SILVER
; 108  :     }
; 109  : 
; 110  :     //
; 111  :     // Allocate the source data buffer.  Because the source filter is 
; 112  :     // synchronous, we can just use a single buffer and packet description.  
; 113  :     // Because the amount of data we read from the source may be a different 
; 114  :     // size than the amount we send to the renderer, using a single packet 
; 115  :     // size is really sub-optimal.  We may end up re-reading data from the 
; 116  :     // source because the renderer couldn't accept it all.  Oh well.  Sample 
; 117  :     // code isn't supposed to be great.
; 118  :     //
; 119  : 
; 120  :     if(SUCCEEDED(hr))

  00134	83 7d 90 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00138	7c 1c		 jl	 SHORT $L18580

; 121  :     {
; 122  :         if(!(pvSourceBuffer = LocalAlloc(LPTR, dwPacketSize)))

  0013a	68 00 40 00 00	 push	 16384			; 00004000H
  0013f	6a 40		 push	 64			; 00000040H
  00141	e8 00 00 00 00	 call	 _LocalAlloc@8
  00146	89 45 e8	 mov	 DWORD PTR _pvSourceBuffer$[ebp], eax
  00149	83 7d e8 00	 cmp	 DWORD PTR _pvSourceBuffer$[ebp], 0
  0014d	75 07		 jne	 SHORT $L18580

; 123  :         {
; 124  :             hr = E_OUTOFMEMORY;

  0014f	c7 45 90 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L18580:

; 125  :         }
; 126  :     }
; 127  : 
; 128  :     //
; 129  :     // Allocate a buffer large enough to store packet data for all the 
; 130  :     // renderer's packets.  Because he's asynchronous, we have to keep the
; 131  :     // data around until he's done processing it.
; 132  :     //
; 133  : 
; 134  :     if(SUCCEEDED(hr))

  00156	83 7d 90 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0015a	7c 1c		 jl	 SHORT $L18584

; 135  :     {
; 136  :         if(!(pvDestinationBuffer = LocalAlloc(LPTR, dwPacketSize * dwPacketCount)))

  0015c	68 00 00 01 00	 push	 65536			; 00010000H
  00161	6a 40		 push	 64			; 00000040H
  00163	e8 00 00 00 00	 call	 _LocalAlloc@8
  00168	89 45 98	 mov	 DWORD PTR _pvDestinationBuffer$[ebp], eax
  0016b	83 7d 98 00	 cmp	 DWORD PTR _pvDestinationBuffer$[ebp], 0
  0016f	75 07		 jne	 SHORT $L18584

; 137  :         {
; 138  :             hr = E_OUTOFMEMORY;

  00171	c7 45 90 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L18584:

; 139  :         }
; 140  :     }
; 141  : 
; 142  :     //
; 143  :     // Create render packet completion events
; 144  :     //
; 145  : 
; 146  :     if(SUCCEEDED(hr))

  00178	83 7d 90 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0017c	7c 41		 jl	 SHORT $L18595

; 147  :     {
; 148  :         for(dwPacketIndex = 0; dwPacketIndex < dwPacketCount; dwPacketIndex++)

  0017e	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _dwPacketIndex$[ebp], 0
  00185	eb 09		 jmp	 SHORT $L18589
$L18590:
  00187	8b 55 88	 mov	 edx, DWORD PTR _dwPacketIndex$[ebp]
  0018a	83 c2 01	 add	 edx, 1
  0018d	89 55 88	 mov	 DWORD PTR _dwPacketIndex$[ebp], edx
$L18589:
  00190	83 7d 88 04	 cmp	 DWORD PTR _dwPacketIndex$[ebp], 4
  00194	73 29		 jae	 SHORT $L18595

; 149  :         {
; 150  :             if(!(ahPacketEvents[dwPacketIndex] = CreateEvent(NULL, TRUE, TRUE, NULL)))

  00196	6a 00		 push	 0
  00198	6a 01		 push	 1
  0019a	6a 01		 push	 1
  0019c	6a 00		 push	 0
  0019e	e8 00 00 00 00	 call	 _CreateEventA@16
  001a3	8b 4d 88	 mov	 ecx, DWORD PTR _dwPacketIndex$[ebp]
  001a6	89 44 8d bc	 mov	 DWORD PTR _ahPacketEvents$[ebp+ecx*4], eax
  001aa	8b 55 88	 mov	 edx, DWORD PTR _dwPacketIndex$[ebp]
  001ad	83 7c 95 bc 00	 cmp	 DWORD PTR _ahPacketEvents$[ebp+edx*4], 0
  001b2	75 09		 jne	 SHORT $L18592

; 151  :             {
; 152  :                 hr = E_OUTOFMEMORY;

  001b4	c7 45 90 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 153  :                 break;

  001bb	eb 02		 jmp	 SHORT $L18595
$L18592:

; 154  :             }
; 155  :         }

  001bd	eb c8		 jmp	 SHORT $L18590
$L18595:

; 156  :     }
; 157  : 
; 158  :     //
; 159  :     // Enter the main loop
; 160  :     //
; 161  : 
; 162  :     while(SUCCEEDED(hr))

  001bf	83 7d 90 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001c3	0f 8c 2a 01 00
	00		 jl	 $L18596

; 163  :     {
; 164  :         //
; 165  :         // Wait for a packet completion event to be signalled.  If this is our
; 166  :         // first time through the loop, all the packets are free, so all the
; 167  :         // events are signalled.
; 168  :         //
; 169  : 
; 170  :         dwPacketIndex = WaitForMultipleObjects(dwPacketCount, ahPacketEvents, FALSE, INFINITE) - WAIT_OBJECT_0;

  001c9	6a ff		 push	 -1
  001cb	6a 00		 push	 0
  001cd	8d 45 bc	 lea	 eax, DWORD PTR _ahPacketEvents$[ebp]
  001d0	50		 push	 eax
  001d1	6a 04		 push	 4
  001d3	e8 00 00 00 00	 call	 _WaitForMultipleObjects@16
  001d8	89 45 88	 mov	 DWORD PTR _dwPacketIndex$[ebp], eax

; 171  :         
; 172  :         //
; 173  :         // Read some data
; 174  :         //
; 175  : 
; 176  :         ZeroMemory(&xmpSource, sizeof(xmpSource));

  001db	6a 18		 push	 24			; 00000018H
  001dd	6a 00		 push	 0
  001df	8d 4d cc	 lea	 ecx, DWORD PTR _xmpSource$[ebp]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 _memset
  001e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 177  :         
; 178  :         xmpSource.pvBuffer = pvSourceBuffer;

  001eb	8b 55 e8	 mov	 edx, DWORD PTR _pvSourceBuffer$[ebp]
  001ee	89 55 cc	 mov	 DWORD PTR _xmpSource$[ebp], edx

; 179  :         xmpSource.dwMaxSize = dwPacketSize;

  001f1	c7 45 d0 00 40
	00 00		 mov	 DWORD PTR _xmpSource$[ebp+4], 16384 ; 00004000H

; 180  :         xmpSource.pdwCompletedSize = &dwSourceCompletedSize;

  001f8	8d 45 8c	 lea	 eax, DWORD PTR _dwSourceCompletedSize$[ebp]
  001fb	89 45 d4	 mov	 DWORD PTR _xmpSource$[ebp+8], eax

; 181  :         
; 182  :         hr = pSourceFilter->Process(NULL, &xmpSource);

  001fe	8d 4d cc	 lea	 ecx, DWORD PTR _xmpSource$[ebp]
  00201	51		 push	 ecx
  00202	6a 00		 push	 0
  00204	8b 55 b4	 mov	 edx, DWORD PTR _pSourceFilter$[ebp]
  00207	8b 02		 mov	 eax, DWORD PTR [edx]
  00209	8b 4d b4	 mov	 ecx, DWORD PTR _pSourceFilter$[ebp]
  0020c	51		 push	 ecx
  0020d	ff 50 10	 call	 DWORD PTR [eax+16]
  00210	89 45 90	 mov	 DWORD PTR _hr$[ebp], eax

; 183  : 
; 184  :         //
; 185  :         // If there's no more data to read, go ahead and break out of the loop
; 186  :         //
; 187  : 
; 188  :         if(SUCCEEDED(hr) && !dwSourceCompletedSize)

  00213	83 7d 90 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00217	7c 0b		 jl	 SHORT $L18600
  00219	83 7d 8c 00	 cmp	 DWORD PTR _dwSourceCompletedSize$[ebp], 0
  0021d	75 05		 jne	 SHORT $L18600

; 189  :         {
; 190  :             break;

  0021f	e9 cf 00 00 00	 jmp	 $L18596
$L18600:

; 191  :         }
; 192  : 
; 193  :         //
; 194  :         // Send it through the SRC.  Be sure to fix up the packet size to
; 195  :         // correspond to the completed size from the source filter.
; 196  :         //
; 197  : 
; 198  :         if(SUCCEEDED(hr))

  00224	83 7d 90 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00228	7c 4b		 jl	 SHORT $L18602

; 199  :         {
; 200  :             xmpSource.dwMaxSize = dwSourceCompletedSize;

  0022a	8b 55 8c	 mov	 edx, DWORD PTR _dwSourceCompletedSize$[ebp]
  0022d	89 55 d0	 mov	 DWORD PTR _xmpSource$[ebp+4], edx

; 201  : 
; 202  :             ZeroMemory(&xmpDestination, sizeof(xmpDestination));

  00230	6a 18		 push	 24			; 00000018H
  00232	6a 00		 push	 0
  00234	8d 45 9c	 lea	 eax, DWORD PTR _xmpDestination$[ebp]
  00237	50		 push	 eax
  00238	e8 00 00 00 00	 call	 _memset
  0023d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 203  : 
; 204  :             xmpDestination.pvBuffer = (LPBYTE)pvDestinationBuffer + (dwPacketIndex * dwPacketSize);

  00240	8b 4d 88	 mov	 ecx, DWORD PTR _dwPacketIndex$[ebp]
  00243	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
  00246	8b 55 98	 mov	 edx, DWORD PTR _pvDestinationBuffer$[ebp]
  00249	03 d1		 add	 edx, ecx
  0024b	89 55 9c	 mov	 DWORD PTR _xmpDestination$[ebp], edx

; 205  :             xmpDestination.dwMaxSize = dwPacketSize;

  0024e	c7 45 a0 00 40
	00 00		 mov	 DWORD PTR _xmpDestination$[ebp+4], 16384 ; 00004000H

; 206  :             xmpDestination.pdwCompletedSize = &dwDestinationCompletedSize;

  00255	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _dwDestinationCompletedSize$[ebp]
  0025b	89 45 a4	 mov	 DWORD PTR _xmpDestination$[ebp+8], eax

; 207  : 
; 208  :             hr = pIntermediateFilter->Process(&xmpSource, &xmpDestination);

  0025e	8d 4d 9c	 lea	 ecx, DWORD PTR _xmpDestination$[ebp]
  00261	51		 push	 ecx
  00262	8d 55 cc	 lea	 edx, DWORD PTR _xmpSource$[ebp]
  00265	52		 push	 edx
  00266	8b 45 b8	 mov	 eax, DWORD PTR _pIntermediateFilter$[ebp]
  00269	8b 08		 mov	 ecx, DWORD PTR [eax]
  0026b	8b 55 b8	 mov	 edx, DWORD PTR _pIntermediateFilter$[ebp]
  0026e	52		 push	 edx
  0026f	ff 51 10	 call	 DWORD PTR [ecx+16]
  00272	89 45 90	 mov	 DWORD PTR _hr$[ebp], eax
$L18602:

; 209  :         }
; 210  : 
; 211  :         //
; 212  :         // It's possible that we read some data, but it's not enough to pass
; 213  :         // through the intermediate filter.  If that's true, go ahead and
; 214  :         // break out of the loop.
; 215  :         //
; 216  :         
; 217  :         if(SUCCEEDED(hr) && !dwDestinationCompletedSize)

  00275	83 7d 90 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00279	7c 0b		 jl	 SHORT $L18605
  0027b	83 bd 6c ff ff
	ff 00		 cmp	 DWORD PTR _dwDestinationCompletedSize$[ebp], 0
  00282	75 02		 jne	 SHORT $L18605

; 218  :         {
; 219  :             break;

  00284	eb 6d		 jmp	 SHORT $L18596
$L18605:

; 220  :         }
; 221  : 
; 222  :         //
; 223  :         // Send the packet to the renderer.  Again, be sure to fix up the 
; 224  :         // packet size.  We don't care how much data actually gets played,
; 225  :         // so we'll reset pdwCompletedSize to NULL.  If we did care how
; 226  :         // much was played (or how much was processed by any asynchronous
; 227  :         // XMO), we'd need to be sure that the variable pointed to by
; 228  :         // pdwCompletedSize was not 
; 229  :         //
; 230  : 
; 231  :         if(SUCCEEDED(hr))

  00286	83 7d 90 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0028a	7c 38		 jl	 SHORT $L18607

; 232  :         {
; 233  :             xmpDestination.dwMaxSize = dwDestinationCompletedSize;

  0028c	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _dwDestinationCompletedSize$[ebp]
  00292	89 45 a0	 mov	 DWORD PTR _xmpDestination$[ebp+4], eax

; 234  :             xmpDestination.pdwCompletedSize = NULL;

  00295	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _xmpDestination$[ebp+8], 0

; 235  :             xmpDestination.hCompletionEvent = ahPacketEvents[dwPacketIndex];

  0029c	8b 4d 88	 mov	 ecx, DWORD PTR _dwPacketIndex$[ebp]
  0029f	8b 54 8d bc	 mov	 edx, DWORD PTR _ahPacketEvents$[ebp+ecx*4]
  002a3	89 55 ac	 mov	 DWORD PTR _xmpDestination$[ebp+16], edx

; 236  : 
; 237  :             ResetEvent(xmpDestination.hCompletionEvent);

  002a6	8b 45 ac	 mov	 eax, DWORD PTR _xmpDestination$[ebp+16]
  002a9	50		 push	 eax
  002aa	e8 00 00 00 00	 call	 _ResetEvent@4

; 238  : 
; 239  :             hr = pRenderFilter->Process(&xmpDestination, NULL);

  002af	6a 00		 push	 0
  002b1	8d 4d 9c	 lea	 ecx, DWORD PTR _xmpDestination$[ebp]
  002b4	51		 push	 ecx
  002b5	8b 55 94	 mov	 edx, DWORD PTR _pRenderFilter$[ebp]
  002b8	8b 02		 mov	 eax, DWORD PTR [edx]
  002ba	8b 4d 94	 mov	 ecx, DWORD PTR _pRenderFilter$[ebp]
  002bd	51		 push	 ecx
  002be	ff 50 10	 call	 DWORD PTR [eax+16]
  002c1	89 45 90	 mov	 DWORD PTR _hr$[ebp], eax
$L18607:

; 240  :         }
; 241  : 
; 242  :         //
; 243  :         // If the intermediate XMO processed less data than we supplied to
; 244  :         // it, seek backwards in the source XMO.  I outlined why this is lame
; 245  :         // above, but oh well...
; 246  :         //
; 247  : 
; 248  :         if(SUCCEEDED(hr) && (dwSourceCompletedSize < xmpSource.dwMaxSize))

  002c4	83 7d 90 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002c8	7c 24		 jl	 SHORT $L18609
  002ca	8b 55 8c	 mov	 edx, DWORD PTR _dwSourceCompletedSize$[ebp]
  002cd	3b 55 d0	 cmp	 edx, DWORD PTR _xmpSource$[ebp+4]
  002d0	73 1c		 jae	 SHORT $L18609

; 249  :         {
; 250  :             hr = pSourceFilter->Seek(-(LONG)(xmpSource.dwMaxSize - dwSourceCompletedSize), FILE_CURRENT, NULL);

  002d2	6a 00		 push	 0
  002d4	6a 01		 push	 1
  002d6	8b 45 d0	 mov	 eax, DWORD PTR _xmpSource$[ebp+4]
  002d9	2b 45 8c	 sub	 eax, DWORD PTR _dwSourceCompletedSize$[ebp]
  002dc	f7 d8		 neg	 eax
  002de	50		 push	 eax
  002df	8b 4d b4	 mov	 ecx, DWORD PTR _pSourceFilter$[ebp]
  002e2	8b 11		 mov	 edx, DWORD PTR [ecx]
  002e4	8b 45 b4	 mov	 eax, DWORD PTR _pSourceFilter$[ebp]
  002e7	50		 push	 eax
  002e8	ff 52 1c	 call	 DWORD PTR [edx+28]
  002eb	89 45 90	 mov	 DWORD PTR _hr$[ebp], eax
$L18609:

; 251  :         }
; 252  :     }

  002ee	e9 cc fe ff ff	 jmp	 $L18595
$L18596:

; 253  : 
; 254  :     //
; 255  :     // Wait for all packets to be completed
; 256  :     //
; 257  : 
; 258  :     WaitForMultipleObjects(dwPacketCount, ahPacketEvents, TRUE, INFINITE);

  002f3	6a ff		 push	 -1
  002f5	6a 01		 push	 1
  002f7	8d 4d bc	 lea	 ecx, DWORD PTR _ahPacketEvents$[ebp]
  002fa	51		 push	 ecx
  002fb	6a 04		 push	 4
  002fd	e8 00 00 00 00	 call	 _WaitForMultipleObjects@16

; 259  : 
; 260  :     //
; 261  :     // Free events
; 262  :     //
; 263  : 
; 264  :     for(dwPacketIndex = 0; dwPacketIndex < dwPacketCount; dwPacketIndex++)

  00302	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _dwPacketIndex$[ebp], 0
  00309	eb 09		 jmp	 SHORT $L18611
$L18612:
  0030b	8b 55 88	 mov	 edx, DWORD PTR _dwPacketIndex$[ebp]
  0030e	83 c2 01	 add	 edx, 1
  00311	89 55 88	 mov	 DWORD PTR _dwPacketIndex$[ebp], edx
$L18611:
  00314	83 7d 88 04	 cmp	 DWORD PTR _dwPacketIndex$[ebp], 4
  00318	73 19		 jae	 SHORT $L18613

; 265  :     {
; 266  :         if(ahPacketEvents[dwPacketIndex])

  0031a	8b 45 88	 mov	 eax, DWORD PTR _dwPacketIndex$[ebp]
  0031d	83 7c 85 bc 00	 cmp	 DWORD PTR _ahPacketEvents$[ebp+eax*4], 0
  00322	74 0d		 je	 SHORT $L18614

; 267  :         {
; 268  :             CloseHandle(ahPacketEvents[dwPacketIndex]);

  00324	8b 4d 88	 mov	 ecx, DWORD PTR _dwPacketIndex$[ebp]
  00327	8b 54 8d bc	 mov	 edx, DWORD PTR _ahPacketEvents$[ebp+ecx*4]
  0032b	52		 push	 edx
  0032c	e8 00 00 00 00	 call	 _CloseHandle@4
$L18614:

; 269  :         }
; 270  :     }

  00331	eb d8		 jmp	 SHORT $L18612
$L18613:

; 271  :     
; 272  :     //
; 273  :     // Free memory
; 274  :     //
; 275  : 
; 276  :     if(pvSourceBuffer)

  00333	83 7d e8 00	 cmp	 DWORD PTR _pvSourceBuffer$[ebp], 0
  00337	74 09		 je	 SHORT $L18615

; 277  :     {
; 278  :         LocalFree(pvSourceBuffer);

  00339	8b 45 e8	 mov	 eax, DWORD PTR _pvSourceBuffer$[ebp]
  0033c	50		 push	 eax
  0033d	e8 00 00 00 00	 call	 _LocalFree@4
$L18615:

; 279  :     }
; 280  : 
; 281  :     if(pvDestinationBuffer)

  00342	83 7d 98 00	 cmp	 DWORD PTR _pvDestinationBuffer$[ebp], 0
  00346	74 09		 je	 SHORT $L18616

; 282  :     {
; 283  :         LocalFree(pvDestinationBuffer);

  00348	8b 4d 98	 mov	 ecx, DWORD PTR _pvDestinationBuffer$[ebp]
  0034b	51		 push	 ecx
  0034c	e8 00 00 00 00	 call	 _LocalFree@4
$L18616:

; 284  :     }
; 285  : 
; 286  :     //
; 287  :     // Free objects
; 288  :     //
; 289  : 
; 290  :     if(pSourceFilter)

  00351	83 7d b4 00	 cmp	 DWORD PTR _pSourceFilter$[ebp], 0
  00355	74 0c		 je	 SHORT $L18617

; 291  :     {
; 292  :         pSourceFilter->Release();

  00357	8b 55 b4	 mov	 edx, DWORD PTR _pSourceFilter$[ebp]
  0035a	8b 02		 mov	 eax, DWORD PTR [edx]
  0035c	8b 4d b4	 mov	 ecx, DWORD PTR _pSourceFilter$[ebp]
  0035f	51		 push	 ecx
  00360	ff 50 04	 call	 DWORD PTR [eax+4]
$L18617:

; 293  :     }
; 294  : 
; 295  :     if(pIntermediateFilter)

  00363	83 7d b8 00	 cmp	 DWORD PTR _pIntermediateFilter$[ebp], 0
  00367	74 0c		 je	 SHORT $L18618

; 296  :     {
; 297  :         pIntermediateFilter->Release();

  00369	8b 55 b8	 mov	 edx, DWORD PTR _pIntermediateFilter$[ebp]
  0036c	8b 02		 mov	 eax, DWORD PTR [edx]
  0036e	8b 4d b8	 mov	 ecx, DWORD PTR _pIntermediateFilter$[ebp]
  00371	51		 push	 ecx
  00372	ff 50 04	 call	 DWORD PTR [eax+4]
$L18618:

; 298  :     }
; 299  : 
; 300  :     if(pRenderFilter)

  00375	83 7d 94 00	 cmp	 DWORD PTR _pRenderFilter$[ebp], 0
  00379	74 0c		 je	 SHORT $L18546

; 301  :     {
; 302  :         pRenderFilter->Release();

  0037b	8b 55 94	 mov	 edx, DWORD PTR _pRenderFilter$[ebp]
  0037e	8b 02		 mov	 eax, DWORD PTR [edx]
  00380	8b 4d 94	 mov	 ecx, DWORD PTR _pRenderFilter$[ebp]
  00383	51		 push	 ecx
  00384	ff 50 04	 call	 DWORD PTR [eax+4]
$L18546:

; 303  :     }
; 304  : }

  00387	33 c0		 xor	 eax, eax
  00389	8b e5		 mov	 esp, ebp
  0038b	5d		 pop	 ebp
  0038c	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
END
