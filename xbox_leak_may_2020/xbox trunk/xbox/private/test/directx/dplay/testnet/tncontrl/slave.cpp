//==================================================================================
// Includes
//==================================================================================
#define _WIN32_DCOM // so we can use CoInitializeEx.  requires DCOM95 on Win95
#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock2 fn proto's, for getprocaddress
#ifndef _XBOX
#include <winsock2.h>
#else // ! XBOX
#include <winsockx.h>		// Needed for XnetInitialize
#endif // XBOX
#include <windows.h>

#ifdef _XBOX // Damn ANSI conversion
#include <stdio.h>
#include <stdlib.h>
#endif

#include <mmsystem.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\strutils.h"
#include "..\tncommon\sprintf.h"
#include "..\tncommon\stack.h"

#include "tncontrl.h"
#include "main.h"
#include "resource.h"

#include "sendq.h"
#include "comm.h"
#include "commtcp.h"

#include "slave.h"





//==================================================================================
// Defines
//==================================================================================
#define DBUNVAILABLE_DIALOG_TIMEOUT				15 // in seconds

#define PERIODICSENDTHREAD_STARTUP_TIMEOUT		10000 // in milliseconds
#define TIMEOUT_DIE_PERIODICSENDTHREAD			10000 // in milliseconds

#define CONTROL_ENUM_INTERVAL					3000 // in milliseconds
#define CONTROL_ENUM_TIMEOUT					60000 // in milliseconds
#define CONTROL_DIRECTJOIN_TIMEOUT				20000 // in milliseconds
#define CONTROL_QUERYMETAMASTER_TIMEOUT			20000 // in milliseconds

#define NO_MASTER_TRAFFIC_TIME_WARNING			(IDLE_INTERVAL * 3)

#define DEADLOCK_WARNING_TIME					60000 // in ticks
#define DEADLOCK_BREAK_TIME						30000 // after WARNING time, in ticks

#define TAKINGTOOLONG_NUMINTERVALS_PRINT		3 // after 3 intervals, start noting the problem in the log
#define TAKINGTOOLONG_NUMINTERVALS_TIMEOUT		7 // after 7 intervals, stop waiting and fail


#define TN_DATABASE_APPID						1 // ID to use when logging to the database

#define TNSLAVE_MULTIINSTANCEDETECT_MUTEX		"TestNet Slave multi-instance detection mutex"
#define TNSLAVE_MULTIINSTANCEDETECT_MMFILE		"TestNet Slave multi-instance detection memory mapped file"
#define MAX_NUM_LOCAL_INSTANCES					16





//==================================================================================
// DCOM function type definitions
//==================================================================================
typedef HRESULT	(WINAPI *LPCOINITIALIZEEXPROC)	(LPVOID, DWORD);





//==================================================================================
// Periodic send context structures
//==================================================================================
#define PSCT_QUERYMETAMASTER	1
#define PSCT_JOINDIRECT			2
#define PSCT_ENUM				3
#define PSCT_REACHCHECK			4


typedef struct tagPERIODICSENDCONTEXT
{
	// This must be in every structure.
	DWORD				dwType; // type of context this actually is
} PERIODICSENDCONTEXT, * PPERIODICSENDCONTEXT;

typedef struct tagQUERYMETAMASTERCONTEXT
{
	// This must be in every structure
	DWORD				dwType; // type of context this actually is

	// This is unique to this structure.
} QUERYMETAMASTERCONTEXT, * PQUERYMETAMASTERCONTEXT;

typedef struct tagJOINDIRECTCONTEXT
{
	// This must be in every structure
	DWORD				dwType; // type of context this actually is

	// This is unique to this structure.
} JOINDIRECTCONTEXT, * PJOINDIRECTCONTEXT;

typedef struct tagENUMCONTEXT
{
	// This must be in every structure
	DWORD				dwType; // type of context this actually is

	// This is unique to this structure.
} ENUMCONTEXT, * PENUMCONTEXT;

typedef struct tagREACHCHECKCONTEXT
{
	// This must be in every structure
	DWORD				dwType; // type of context this actually is

	// This is unique to this structure.
	PTNREACHCHECK		pReachCheck; // reach check object this send was for
	char*				pszAddressStrings; // pointer to buffer with multiple address strings to use.
	DWORD				dwTotalAddressStrings; // how many strings in previous buffer
	DWORD				dwCurrentAddressString; // which string is the next one to use
} REACHCHECKCONTEXT, * PREACHCHECKCONTEXT;



//==================================================================================
// Other structures
//==================================================================================
typedef struct tagMULTIINSTANCEITEM
{
	BOOL					fInUse; // is this slot in use yet?
	DWORD					dwSessionID; // session this instance is in, or 0 if this slot is open
	TNCTRLMACHINEID			id; // ID of this instance
} MULTIINSTANCEITEM, * PMULTIINSTANCEITEM;

typedef struct tagMULTIINSTANCEMMFILE
{
	DWORD					dwKey; // special key generated by first instance that helps identify multiple instances
	int						iNumInstances; // how many instances there are currently
	MULTIINSTANCEITEM		aInstances[MAX_NUM_LOCAL_INSTANCES]; // array of instances
} MULTIINSTANCEMMFILE, * PMULTIINSTANCEMMFILE;





//==================================================================================
// Local Prototypes
//==================================================================================
INT_PTR CALLBACK DBUnavailableDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

HRESULT SlaveReadNetStatTempFileCB(char* szLine, PFILELINEINFO pInfo, PVOID pvContext,
								BOOL* pfStopReading);





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::CTNSlave()"
//==================================================================================
// CTNSlave constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNSlave object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNSlave::CTNSlave(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNSlave));


	// Any changes here should go in LeaveControlSession as well.

	this->m_dwCurrentUniqueID = 1;

	this->m_dwTimelimit = 0;
	this->m_pszSessionFilter = NULL;
	this->m_pfnDoStartup = NULL;
	this->m_pfnChangeBinarySet = NULL;
	this->m_pszSavedBinsDirPath = NULL;
	this->m_pFailureBreakRules = NULL;
	this->m_pszFailureMemDumpDirPath = NULL;
	this->m_fGetNetStatInfoOnFailure = FALSE;

	this->m_dwSessionID = 0;
	this->m_hPeriodicSendThread = NULL;
	this->m_fReadyToConnect = FALSE;
	this->m_fInSession = FALSE;
	this->m_fTestingComplete = FALSE;
	this->m_pvMetaMasterAddress = NULL;
	this->m_dwMetaMasterAddressSize = 0;
	this->m_pvTestmasterCommData = LocalAlloc(LPTR, sizeof (COMMDATA));
	this->m_dwLastMasterReceive = 0;
	this->m_pBinMgr = NULL;
	this->m_pSessionPeriodicSend = NULL;
	this->m_hMultiInstanceMutex = NULL;
	this->m_hMultiInstanceMMFile = NULL;
	this->m_iInstanceIndex = -1;

	this->m_hKillPeriodicSendThreadEvent = NULL;
	this->m_fQueryingMetaMaster = FALSE;
	this->m_fShakingHands = FALSE;

#ifndef _XBOX // no DB logging supported
	this->m_lpTMAgent = NULL;
#endif // ! XBOX

} // CTNSlave::CTNSlave
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::~CTNSlave()"
//==================================================================================
// CTNSlave destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNSlave object and any memory it may have allocated
//				during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNSlave::~CTNSlave(void)
{
	HRESULT		hr;


	//DPL(0, "this = %x", 1, this);

	hr = this->LeaveControlSession();
	if (hr != S_OK)
	{
		DPL(0, "Closing control layer session failed!  %e", 1, hr);
	} // end if (closing control layer failed)

	if (this->m_pvTestmasterCommData != NULL)
	{
		LocalFree(this->m_pvTestmasterCommData);
		this->m_pvTestmasterCommData = NULL;
	} // end if (allocated memory)
} // CTNSlave::~CTNSlave
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::StartJoiningControlSession()"
//==================================================================================
// CTNSlave::StartJoiningControlSession
//----------------------------------------------------------------------------------
//
// Description: Starts looking for a control session to join.  This is an
//				asynchronous call, so this function returns E_PENDING if successful,
//				and the caller should wait until the hCompletionOrUpdateEvent
//				(if specified) is set, then call IsInSession() to check whether this
//				succeeded or not.
//
// Arguments:
//	PTNJOINCONTROLSESSIONDATA pTNjcsd	Parameter block.  See header file for
//										information.
//
// Returns: E_PENDING if search successfully started, or error code otherwise.
//==================================================================================
HRESULT CTNSlave::StartJoiningControlSession(PTNJOINCONTROLSESSIONDATA pTNjcsd)
{
	HRESULT						hr;
	CONTROLCOMMINITPBLOCK		ctrlcomminitparams;
	TNEXECUTORINITBYSLAVEDATA	tneibsd;
	PVOID						pvBroadcastAddress = NULL;
	DWORD						dwBroadcastAddressSize = 0;
	PVOID						pvMsg = NULL;
	DWORD						dwMsgSize = 0;
	PPERIODICSENDCONTEXT		pContext = NULL;



	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto ERROR_EXIT;
	} // end if (we got passed a bad pointer)

	if (pTNjcsd == NULL)
	{
		DPL(0, "Must pass a valid structure pointer!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if (pTNjcsd->dwSize != sizeof (TNJOINCONTROLSESSIONDATA))
	{
		DPL(0, "Must pass a structure of correct size (%u != %u)!",
			2, pTNjcsd->dwSize, sizeof (TNJOINCONTROLSESSIONDATA));
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if (pTNjcsd->dwAPIVersion != CURRENT_TNCONTROL_API_VERSION)
	{
		DPL(0, "WARNING: Caller requesting different API version (%u != %u), problems may occur.",
			2, pTNjcsd->dwAPIVersion, CURRENT_TNCONTROL_API_VERSION);
	} // end if (got passed an invalid parameter)

	if ((pTNjcsd->dwMode != TNMODE_API) &&
		(pTNjcsd->dwMode != TNMODE_STRESS) &&
		(pTNjcsd->dwMode != TNMODE_POKE) &&
		(pTNjcsd->dwMode != TNMODE_PICKY) &&
		(pTNjcsd->dwMode != TNMODE_DOCUMENTATION))
	{
		DPL(0, "Must pass a valid mode (%u is invalid)!", 1, pTNjcsd->dwMode);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if (pTNjcsd->hUserCancelEvent == NULL)
	{
		DPL(0, "Must pass a valid user cancel event!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if ((pTNjcsd->dwControlMethodID != TN_CTRLMETHOD_TCPIP_OPTIMAL) &&
		(pTNjcsd->dwControlMethodID != TN_CTRLMETHOD_TCPIP_WINSOCK1))
	{
		DPL(0, "Must pass a control method ID (%u is invalid)!",
			1, pTNjcsd->dwControlMethodID);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if ((pTNjcsd->pModuleID == NULL) ||
		(pTNjcsd->apfnLoadTestTable == NULL) ||
			(pTNjcsd->dwNumLoadTestTables < 1) ||
			(pTNjcsd->apfnLoadTestTable[0] == NULL))
	{
		DPL(0, "Must pass a valid module ID and LoadTestTable callbacks array!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if ((pTNjcsd->pszMetaMasterAddress != NULL) &&
		(pTNjcsd->pszMasterAddress != NULL))
	{
		DPL(0, "Either the meta-master address or the master address can be specified, but not both!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (got passed an invalid parameter)

	if (pTNjcsd->pszErrToSrcFilepath != NULL)
	{
		if (((pTNjcsd->pszErrToSrcPathSearch != NULL) &&
			(pTNjcsd->pszErrToSrcPathReplace == NULL)) ||
			((pTNjcsd->pszErrToSrcPathSearch == NULL) &&
			(pTNjcsd->pszErrToSrcPathReplace != NULL)))
		{
			DPL(0, "Must specify both ErrToSrc search and replace path or neither!", 0);
			hr = ERROR_INVALID_PARAMETER;
			goto ERROR_EXIT;
		} // end if (got passed an invalid parameter)
	} // end if (errtosrc path specified)
	else
	{
		if ((pTNjcsd->pszErrToSrcPathSearch != NULL) ||
			(pTNjcsd->pszErrToSrcPathReplace != NULL))
		{
			DPL(0, "Can't specify ErrToSrc search or replace path without specifying an errtosrc filepath!", 0);
			hr = ERROR_INVALID_PARAMETER;
			goto ERROR_EXIT;
		} // end if (got passed an invalid parameter)
	} // end else (errtosrc path not specified)

	this->m_pfnLogString = pTNjcsd->pfnLogString;



	// Check to see how many other slaves are running on this machine.
	hr = this->RegisterWithOtherLocalSlaves();
	if (hr != S_OK)
	{
		DPL(0, "Failed while registering other slaves running on this machine!", 0);
		this->Log(TNLST_CRITICAL, "Failed while registering other slaves running on this machine!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't detect multiple instances)


	ZeroMemory(&tneibsd, sizeof (TNEXECUTORINITBYSLAVEDATA));
	tneibsd.pOwningSlave = this;
	tneibsd.dwMode = pTNjcsd->dwMode;
	tneibsd.pModuleID = pTNjcsd->pModuleID;
	tneibsd.pszTestNetRootPath = pTNjcsd->pszTestNetRootPath;
	tneibsd.apfnLoadTestTable = pTNjcsd->apfnLoadTestTable;
	tneibsd.dwNumLoadTestTables = pTNjcsd->dwNumLoadTestTables;
	tneibsd.pfnInitializeTesting = pTNjcsd->pfnInitializeTesting;
	tneibsd.pfnCleanupTesting = pTNjcsd->pfnCleanupTesting;
	tneibsd.pfnAddImportantBinaries = pTNjcsd->pfnAddImportantBinaries;
	tneibsd.pfnGetTestingWindow = pTNjcsd->pfnGetTestingWindow;
	tneibsd.fInitializeCOMInTestThread = pTNjcsd->fInitializeCOMInTestThread;
	tneibsd.fPromptTestThreadDieTimeout = pTNjcsd->fPromptTestThreadDieTimeout;
	tneibsd.hUserCancelEvent = pTNjcsd->hUserCancelEvent;
	tneibsd.pszErrToSrcFilepath = pTNjcsd->pszErrToSrcFilepath;
	tneibsd.pszErrToSrcPathSearch = pTNjcsd->pszErrToSrcPathSearch;
	tneibsd.pszErrToSrcPathReplace = pTNjcsd->pszErrToSrcPathReplace;
	tneibsd.pszDocFilepath = pTNjcsd->pszDocFilepath;
	tneibsd.iMultiInstanceNum = this->m_iInstanceIndex;

	hr = this->m_executor.InitializeBySlave(&tneibsd);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't initialize executor!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't initialize executor)


	if (pTNjcsd->hCompletionOrUpdateEvent != NULL)
	{
		if (! DuplicateHandle(GetCurrentProcess(), pTNjcsd->hCompletionOrUpdateEvent,
								GetCurrentProcess(), &(this->m_hCompletionOrUpdateEvent),
								0, FALSE, DUPLICATE_SAME_ACCESS))
		{
			hr = GetLastError();
			DPL(0, "Couldn't duplicate user's completion or update event handle (%x)!",
				2, pTNjcsd->hCompletionOrUpdateEvent);
			goto ERROR_EXIT;
		} // end if (couldn't duplicate handle)
	} // end if (there's an event)

	this->m_pfnDoStartup = pTNjcsd->pfnDoStartup;
	this->m_pfnChangeBinarySet = pTNjcsd->pfnChangeBinarySet;


	// If we're in documentation mode, we can skip the rest of this startup code.
	if (pTNjcsd->dwMode == TNMODE_DOCUMENTATION)
		return (E_PENDING);


	// Create the event to artificially kill the send thread.
	this->m_hKillPeriodicSendThreadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (this->m_hKillPeriodicSendThreadEvent == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create kill thread event!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't create event)


	if (pTNjcsd->pszSessionFilter != NULL)
	{
		this->m_pszSessionFilter = (char*) LocalAlloc(LPTR, (strlen(pTNjcsd->pszSessionFilter) + 1));
		if (this->m_pszSessionFilter == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		strcpy(this->m_pszSessionFilter, pTNjcsd->pszSessionFilter);
	} // end if (theres a user session ID)

	this->m_dwTimelimit = pTNjcsd->dwTimelimit;
	if (pTNjcsd->pszSavedBinsDirPath != NULL)
	{
		this->m_pszSavedBinsDirPath = (char*) LocalAlloc(LPTR, (strlen(pTNjcsd->pszSavedBinsDirPath) + 1));
		if (this->m_pszSavedBinsDirPath == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		strcpy(this->m_pszSavedBinsDirPath, pTNjcsd->pszSavedBinsDirPath);
	} // end if (there's a saved bins path)

	this->m_pFailureBreakRules = pTNjcsd->pFailureBreakRules;

	if (pTNjcsd->pszFailureMemDumpDirPath != NULL)
	{
		this->m_pszFailureMemDumpDirPath = (char*) LocalAlloc(LPTR, (strlen(pTNjcsd->pszFailureMemDumpDirPath) + 1));
		if (this->m_pszFailureMemDumpDirPath == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		strcpy(this->m_pszFailureMemDumpDirPath, pTNjcsd->pszFailureMemDumpDirPath);
	} // end if (there's a saved bins path)

	this->m_fGetNetStatInfoOnFailure = pTNjcsd->fGetNetStatInfoOnFailure;


#ifndef _XBOX // no DB logging supported

	// Setup TMAgent for database logging, if we're doing that.
	if (pTNjcsd->fLogToDB)
	{
		hr = this->InitializeDBLogging();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't initialize database logging!", 0);
			this->Log(TNLST_CRITICAL, "Couldn't initialize database logging!", 0);
			goto ERROR_EXIT;
		} // end if (couldn't initialize DB logging)
	} // end if (logging to database)

#endif // ! XBOX

	ZeroMemory(&ctrlcomminitparams, sizeof (CONTROLCOMMINITPBLOCK));
	ctrlcomminitparams.dwSize = sizeof (CONTROLCOMMINITPBLOCK);
	ctrlcomminitparams.dwControlMethodID = pTNjcsd->dwControlMethodID;
	ctrlcomminitparams.pControlLayerObj = this;
	ctrlcomminitparams.fMaster = FALSE;
	ctrlcomminitparams.dwFlags = pTNjcsd->dwMethodFlags;
	ctrlcomminitparams.pvData = pTNjcsd->pvMethodData;
	ctrlcomminitparams.dwDataSize = pTNjcsd->dwMethodDataSize;

	// Initialize desired control method
	switch (pTNjcsd->dwControlMethodID)
	{
		case TN_CTRLMETHOD_TCPIP_OPTIMAL:
			hr = CtrlCommTCPLoadOptimal(&ctrlcomminitparams, &(this->m_pCtrlComm));
			if (hr != S_OK)
			{
				DPL(0, "Initializing TCP/IP optimal control method failed!", 0);
				goto ERROR_EXIT;
			} // end if (initting TCP/IP optimal control method failed)
		  break;
		case TN_CTRLMETHOD_TCPIP_WINSOCK1:
			hr = CtrlCommTCPLoadWinSock1(&ctrlcomminitparams, &(this->m_pCtrlComm));
			if (hr != S_OK)
			{
				DPL(0, "Initializing TCP/IP WinSock1 control method failed!", 0);
				goto ERROR_EXIT;
			} // end if (initting TCP/IP WinSock1 control method failed)
		  break;
	} // end switch (on control method ID)



	// Initialize control communication method
	hr = this->m_pCtrlComm->Initialize();
	if (hr != S_OK)
	{
		DPL(0, "Initializing control communications method failed!", 0);
		goto ERROR_EXIT;
	} // end if (initting ctrl comm failed)


	if (pTNjcsd->pszMetaMasterAddress != NULL)
	{
		PCTRLMSG_QUERYMETAMASTER	pQueryMetaMasterMsg;


		// Ignore error, assume BUFFER_TOO_SMALL
		this->m_pCtrlComm->ConvertStringToAddress(pTNjcsd->pszMetaMasterAddress,
													NULL,
													0,
													NULL,
													&(this->m_dwMetaMasterAddressSize));
		this->m_pvMetaMasterAddress = LocalAlloc(LPTR, this->m_dwMetaMasterAddressSize);
		if (this->m_pvMetaMasterAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		hr = this->m_pCtrlComm->ConvertStringToAddress(pTNjcsd->pszMetaMasterAddress,
														NULL,
														0,
														this->m_pvMetaMasterAddress,
														&(this->m_dwMetaMasterAddressSize));
		if (hr != S_OK)
		{
			DPL(0, "Converting \"%s\" into meta-master address failed!",
				1, pTNjcsd->pszMetaMasterAddress);
			goto ERROR_EXIT;
		} // end if (initting ctrl comm failed)


		dwMsgSize = sizeof (CTRLMSG_QUERYMETAMASTER);
		if (this->m_pszSessionFilter != NULL)
			dwMsgSize += strlen(this->m_pszSessionFilter) + 1;
		else
			dwMsgSize++; // just NULL terminator (for empty string)

		pvMsg = LocalAlloc(LPTR, dwMsgSize);
		if (pvMsg == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		pQueryMetaMasterMsg = (PCTRLMSG_QUERYMETAMASTER) pvMsg;

		pQueryMetaMasterMsg->dwSize = dwMsgSize;
		pQueryMetaMasterMsg->dwType = CTRLMSGID_QUERYMETAMASTER;
		pQueryMetaMasterMsg->dwMetaVersion = CURRENT_METAMASTER_API_VERSION;
		pQueryMetaMasterMsg->dwControlVersion = CURRENT_TNCONTROL_API_VERSION;
		CopyMemory(&(pQueryMetaMasterMsg->moduleID), &(this->m_executor.m_moduleID),
					sizeof (TNMODULEID));
		pQueryMetaMasterMsg->dwMode = this->m_executor.m_dwMode;

		if (this->m_pszSessionFilter != NULL)
			strcpy((char*) (pQueryMetaMasterMsg + 1), this->m_pszSessionFilter);
		else
			(*((char*) (pQueryMetaMasterMsg + 1))) = '\0'; // empty string


		pContext = (PPERIODICSENDCONTEXT) LocalAlloc(LPTR, sizeof (QUERYMETAMASTERCONTEXT));
		if (pContext == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		((PQUERYMETAMASTERCONTEXT) pContext)->dwType = PSCT_QUERYMETAMASTER;


		// Note that we're querying the meta-master right now.
		this->m_fQueryingMetaMaster = TRUE;


		// Start trying to connect to the meta-master.
		hr = this->StartPeriodicSend(this->m_pCtrlComm,
									TRUE,
									this->m_pvMetaMasterAddress,
									this->m_dwMetaMasterAddressSize,
									pvMsg,
									dwMsgSize,
									0,
									CONTROL_QUERYMETAMASTER_TIMEOUT,
									pContext,
									&(this->m_pSessionPeriodicSend));

		LocalFree(pvMsg);
		pvMsg = NULL;
	} // end if (a meta master was specified)
	else if (pTNjcsd->pszMasterAddress != NULL)
	{
		PCTRLMSG_HANDSHAKE	pHandshakeMsg;


		// Ignore error, assume BUFFER_TOO_SMALL
		this->m_pCtrlComm->ConvertStringToAddress(pTNjcsd->pszMasterAddress,
													NULL,
													0,
													NULL,
													&(((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize));
		((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress = LocalAlloc(LPTR, ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize);
		if (((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		hr = this->m_pCtrlComm->ConvertStringToAddress(pTNjcsd->pszMasterAddress,
														NULL,
														0,
														((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
														&(((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize));
		if (hr != S_OK)
		{
			DPL(0, "Converting \"%s\" into master address failed!",
				1, pTNjcsd->pszMasterAddress);
			goto ERROR_EXIT;
		} // end if (initting ctrl comm failed)


		dwMsgSize = sizeof (CTRLMSG_HANDSHAKE);
		if (this->m_pszSessionFilter != NULL)
			dwMsgSize += strlen(this->m_pszSessionFilter) + 1;
		else
			dwMsgSize++; // just NULL terminator (for empty string)

		pvMsg = LocalAlloc(LPTR, dwMsgSize);
		if (pvMsg == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		pHandshakeMsg = (PCTRLMSG_HANDSHAKE) pvMsg;

		pHandshakeMsg->dwSize = dwMsgSize;
		pHandshakeMsg->dwType = CTRLMSGID_HANDSHAKE;
		pHandshakeMsg->dwVersion = CURRENT_TNCONTROL_API_VERSION;
		CopyMemory(&(pHandshakeMsg->moduleID), &(this->m_executor.m_moduleID),
					sizeof (TNMODULEID));
		pHandshakeMsg->dwMode = this->m_executor.m_dwMode;

		if (this->m_pszSessionFilter != NULL)
			strcpy((char*) (pHandshakeMsg + 1), this->m_pszSessionFilter);
		else
			(*((char*) (pHandshakeMsg + 1))) = '\0'; // empty string


		pContext = (PPERIODICSENDCONTEXT) LocalAlloc(LPTR, sizeof (JOINDIRECTCONTEXT));
		if (pContext == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		((PJOINDIRECTCONTEXT) pContext)->dwType = PSCT_JOINDIRECT;


		// Note that we're trying to connect.
		this->m_fShakingHands = TRUE;
			

		// Start trying to directly connect to the session.
		hr = this->StartPeriodicSend(this->m_pCtrlComm,
									TRUE,
									((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
									((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize,
									pvMsg,
									dwMsgSize,
									0,
									CONTROL_DIRECTJOIN_TIMEOUT,
									pContext,
									&(this->m_pSessionPeriodicSend));

		LocalFree(pvMsg);
		pvMsg = NULL;
	} // end else if (a specific master was specified)
	else
	{
		PCTRLMSG_ENUM	pEnumMsg;


		// Ignore error, assume BUFFER_TOO_SMALL
		this->m_pCtrlComm->GetBroadcastAddress(NULL,
												0, 
												NULL,
												&dwBroadcastAddressSize);

		pvBroadcastAddress = LocalAlloc(LPTR, dwBroadcastAddressSize);
		if (pvBroadcastAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		hr = this->m_pCtrlComm->GetBroadcastAddress(NULL,
													0,
													pvBroadcastAddress,
													&dwBroadcastAddressSize);
		if (hr != S_OK)
		{
			DPL(0, "Getting broadcast address failed!", 0);
			goto ERROR_EXIT;
		} // end if (initting ctrl comm failed)

		dwMsgSize = sizeof (CTRLMSG_ENUM);
		if (this->m_pszSessionFilter != NULL)
			dwMsgSize += strlen(this->m_pszSessionFilter) + 1;
		else
			dwMsgSize++; // just NULL terminator (for empty string)

		pvMsg = LocalAlloc(LPTR, dwMsgSize);
		if (pvMsg == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		pEnumMsg = (PCTRLMSG_ENUM) pvMsg;

		pEnumMsg->dwSize = dwMsgSize;
		pEnumMsg->dwType = CTRLMSGID_ENUM;
		pEnumMsg->dwVersion = CURRENT_TNCONTROL_API_VERSION;
		CopyMemory(&(pEnumMsg->moduleID), &(this->m_executor.m_moduleID),
					sizeof (TNMODULEID));
		pEnumMsg->dwMode = this->m_executor.m_dwMode;

		if (this->m_pszSessionFilter != NULL)
			strcpy((char*) (pEnumMsg + 1), this->m_pszSessionFilter);
		else
			(*((char*) (pEnumMsg + 1))) = '\0'; // empty string
		

		pContext = (PPERIODICSENDCONTEXT) LocalAlloc(LPTR, sizeof (ENUMCONTEXT));
		if (pContext == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)

		((PENUMCONTEXT) pContext)->dwType = PSCT_ENUM;


		// Note that we should handle EnumReplies now.
		this->m_fReadyToConnect = TRUE;


		// Start enuming sessions via broadcast.
		hr = this->StartPeriodicSend(this->m_pCtrlComm,
									FALSE,
									pvBroadcastAddress,
									dwBroadcastAddressSize,
									pvMsg,
									dwMsgSize,
									CONTROL_ENUM_INTERVAL,
									CONTROL_ENUM_TIMEOUT,
									pContext,
									&(this->m_pSessionPeriodicSend));

		LocalFree(pvMsg);
		pvMsg = NULL;

		LocalFree(pvBroadcastAddress);
		pvBroadcastAddress = NULL;
	} // end if (there isn't any special join data)

	if (hr != S_OK)
	{
		DPL(0, "Starting to enum sessions/join failed!", 0);
		goto ERROR_EXIT;
	} // end if (starting to enum sessions/join failed)

	
	return (E_PENDING);


ERROR_EXIT:

#pragma BUGBUG(vanceo, "Cleanup, return to original state")

	if (this->m_pSessionPeriodicSend != NULL)
	{
		hr = this->StopPeriodicSend(this->m_pSessionPeriodicSend);
		if (hr != S_OK)
		{
			DPL(0, "Stopping periodic send %x failed!  %e",
				2, this->m_pSessionPeriodicSend, hr);
		} // end if (there's an active send)

		this->m_pSessionPeriodicSend->m_dwRefCount--;
		if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
		{
			DPL(7, "Deleting session periodic send %x.",
				1, this->m_pSessionPeriodicSend);
			delete (this->m_pSessionPeriodicSend);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting session periodic send %x, its refcount is %u.",
				2, this->m_pSessionPeriodicSend,
				this->m_pSessionPeriodicSend->m_dwRefCount);
		} // end else (not last reference)
		this->m_pSessionPeriodicSend = NULL;
	} // end if (have active send)

	if (pContext != NULL)
	{
		LocalFree(pContext);
		pContext = NULL;
	} // end if (have context)

	if (pvMsg != NULL)
	{
		LocalFree(pvMsg);
		pvMsg = NULL;
	} // end if (allocated memory)

	if (pvBroadcastAddress != NULL)
	{
		LocalFree(pvBroadcastAddress);
		pvBroadcastAddress = NULL;
	} // end if (allocated memory)

	return (hr);
} // CTNSlave::StartJoiningControlSession
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::LeaveControlSession()"
//==================================================================================
// CTNSlave::LeaveControlSession
//----------------------------------------------------------------------------------
//
// Description: Leaves the control session if in one, stops the enumeration and
//				test threads if running, and releases the ctrl comm object if it
//				existed.
//				Note that errors will probably be masked.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::LeaveControlSession(void)
{
	HRESULT		hr = S_OK;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (we got passed a bad pointer)


	DPL(9, "==>", 0);


	if (this->m_pSessionPeriodicSend != NULL)
	{
		hr = this->StopPeriodicSend(this->m_pSessionPeriodicSend);
		if (hr != S_OK)
		{
			DPL(0, "Stopping periodic send %x failed!  %e",
				2, this->m_pSessionPeriodicSend, hr);
		} // end if (there's an active send)

		this->m_pSessionPeriodicSend->m_dwRefCount--;
		if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
		{
			DPL(7, "Deleting session periodic send %x.",
				1, this->m_pSessionPeriodicSend);
			delete (this->m_pSessionPeriodicSend);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting session periodic send %x, its refcount is %u.",
				2, this->m_pSessionPeriodicSend,
				this->m_pSessionPeriodicSend->m_dwRefCount);
		} // end else (not last reference)
		this->m_pSessionPeriodicSend = NULL;
	} // end if (have active send)


	this->m_fInSession = FALSE;
	this->m_fTestingComplete = FALSE;

	hr = this->KillPeriodicSendThread(FALSE);
	if (hr != S_OK)
	{
		DPL(0, "Stopping periodic send thread failed!  %e", 1, hr);
	} // end if (stopping thread failed)

	hr = this->m_executor.Cleanup();
	if (hr != S_OK)
	{
		DPL(0, "Cleaning up executor failed!  %e", 1, hr);
	} // end if (killing test thread failed)

	if (this->m_pCtrlComm != NULL)
	{
		this->m_pCtrlComm->m_dwRefCount--;
		if (this->m_pCtrlComm->m_dwRefCount == 0)
		{
			DPL(7, "Releasing and deleting control comm object %x.",
				1, this->m_pCtrlComm);

			hr = this->m_pCtrlComm->Release();
			if (hr != S_OK)
			{
				DPL(0, "Releasing control communication method failed!  %e", 1, hr);
			} // end if (releasing control method failed)

			delete (this->m_pCtrlComm);
		} // end if (last reference)
		else
		{
			DPL(0, "WARNING: Not releasing and deleting control comm object %x, its refcount is %u!",
				2, this->m_pCtrlComm, this->m_pCtrlComm->m_dwRefCount);
		} // end else (not last reference)

		this->m_pCtrlComm = NULL;
	} // end if (we're still validly connected to the control method)


	// Reset the members, just like in the constructor

	if (this->m_pszSessionFilter != NULL)
	{
		LocalFree(this->m_pszSessionFilter);
		this->m_pszSessionFilter = NULL;
	} // end if (session ID exists)

	this->m_pszSessionFilter = NULL;
	this->m_pFailureBreakRules = NULL;

	if (this->m_pszFailureMemDumpDirPath != NULL)
	{
		LocalFree(this->m_pszFailureMemDumpDirPath);
		this->m_pszFailureMemDumpDirPath = NULL;
	} // end if (dump dir path exists)

	this->m_fReadyToConnect = FALSE;
	this->m_fQueryingMetaMaster = FALSE;
	this->m_fShakingHands = FALSE;
	this->m_fInSession = FALSE;
	this->m_dwLastMasterReceive = 0;
	this->m_pfnDoStartup = NULL;
	this->m_pfnChangeBinarySet = NULL;

	if (this->m_pvMetaMasterAddress != NULL)
	{
		LocalFree(this->m_pvMetaMasterAddress);
		this->m_pvMetaMasterAddress = NULL;
	} // end if (meta master address exists)

	// BUGBUG The control object technically owns this item
	if (((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress != NULL)
	{
		LocalFree(((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress);
		((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress = NULL;
	} // end if (we have a control comm address)

	if (this->m_pszSavedBinsDirPath != NULL)
	{
		LocalFree(this->m_pszSavedBinsDirPath);
		this->m_pszSavedBinsDirPath = NULL;
	} // end if (saved bins dir exists)

	if (this->m_pBinMgr != NULL)
	{
		delete (this->m_pBinMgr);
		this->m_pBinMgr = NULL;
	} // end if (bin manager exists)

	if (this->m_hCompletionOrUpdateEvent != NULL)
	{
		CloseHandle(this->m_hCompletionOrUpdateEvent);
		this->m_hCompletionOrUpdateEvent = NULL;
	} // end if (have event)


	// Remove all info objects for other machines.
	hr = this->m_otherinfos.RemoveAll();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't remove all info objects for other machines!  %e",
			1, hr);
	} // end if (couldn't remove all info objects)


	// Clean up info shared with other slaves that are running on this machine.
	hr = this->UnregisterWithOtherLocalSlaves();
	if (hr != S_OK)
	{
		DPL(0, "Failed while unregistering other slaves running on this machine!  %e",
			1, hr);
	} // end if (couldn't unregister multi-instance detection)

#ifndef _XBOX // no database logging supported

	// Shutdown database logging.
	if (this->m_lpTMAgent != NULL)
	{
		// Ignoring error
		this->m_lpTMAgent->EndTest();
		this->m_lpTMAgent->Uninitialize();
		this->m_lpTMAgent->Release();
		this->m_lpTMAgent = NULL;

		DPL(8, "Uninitializing COM.", 0);
		CoUninitialize();
	} // end if (we were logging to a database)

#endif // ! XBOX

	DPL(9, "<== %e", 1, hr);

	return (hr);
} // CTNSlave::LeaveControlSession
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::IsInSession()"
//==================================================================================
// CTNSlave::IsInSession
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if this object is in a control session, FALSE if not.
//
// Arguments: None.
//
// Returns: TRUE if in session, FALSE otherwise.
//==================================================================================
BOOL CTNSlave::IsInSession(void)
{
	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (FALSE);
	} // end if (slave object is invalid)

	return (this->m_fInSession);
} // CTNSlave::IsInSession
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetSessionID()"
//==================================================================================
// CTNSlave::GetSessionID
//----------------------------------------------------------------------------------
//
// Description: Returns the identifier of the current session.
//
// Arguments: None.
//
// Returns: ID of current session.
//==================================================================================
DWORD CTNSlave::GetSessionID(void)
{
	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (0);
	} // end if (slave object is invalid)

	if (! this->m_fInSession)
	{
		DPL(0, "Not in session yet, can't determine session ID!", 0);
		return (0);
	} // end if (not in a session)
	
	return (this->m_dwSessionID);
} // CTNSlave::GetSessionID
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::IsTestingComplete()"
//==================================================================================
// CTNSlave::IsTestingComplete
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if all tests intended to be run have actually been.
//
// Arguments: None.
//
// Returns: TRUE if all tests are run, FALSE otherwise.
//==================================================================================
BOOL CTNSlave::IsTestingComplete(void)
{
	return (this->m_fTestingComplete);
} // CTNSlave::IsTestingComplete
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetModuleString()"
//==================================================================================
// CTNSlave::GetModuleString
//----------------------------------------------------------------------------------
//
// Description: Returns a string describing the currently loaded module.
//
// Arguments:
//	char* szString	String buffer to copy results in.  Should be able to hold 64
//					characters.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::GetModuleString(char* szString)
{
#ifdef _XBOX // Damn ANSI conversion
	WCHAR	szWideString[256];
#endif // ! XBOX

	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (slave object is invalid)

	// Prevent the user from retrieving the module string before we're fully in the
	// session, unless we're in documentation mode.
	if ((! this->m_fInSession) && (this->m_executor.m_dwMode != TNMODE_DOCUMENTATION))
	{
		DPL(0, "Not in session yet, can't determine module ID!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (not in a session)
	
#ifndef _XBOX // Damn ANSI conversion
	wsprintf(szString, "%s v%02u.%02u.%02u.%04u", this->m_executor.m_moduleID.szBriefName,
			this->m_executor.m_moduleID.dwMajorVersion,
			this->m_executor.m_moduleID.dwMinorVersion1,
			this->m_executor.m_moduleID.dwMinorVersion2,
			this->m_executor.m_moduleID.dwBuildVersion);
#else // ! XBOX
	ZeroMemory(szWideString, sizeof(WCHAR) * 256);
	swprintf(szWideString, L"%hs v%02u.%02u.%02u.%04u", this->m_executor.m_moduleID.szBriefName,
			this->m_executor.m_moduleID.dwMajorVersion,
			this->m_executor.m_moduleID.dwMinorVersion1,
			this->m_executor.m_moduleID.dwMinorVersion2,
			this->m_executor.m_moduleID.dwBuildVersion);
	wcstombs(szString, szWideString, wcslen(szWideString));
	szString[wcslen(szWideString)] = 0;
#endif // XBOX
	
	return (S_OK);
} // CTNSlave::GetModuleString
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetTotalStats()"
//==================================================================================
// CTNSlave::GetTotalStats
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the total test table stats object.
//
// Arguments: None.
//
// Returns: Pointer to stats object, or NULL if an error occurred.
//==================================================================================
PTNTESTSTATS CTNSlave::GetTotalStats(void)
{
	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (NULL);
	} // end if (slave object is invalid)

	return (&(this->m_totalstats));
} // CTNSlave::GetTotalStats
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetNumberOfCases()"
//==================================================================================
// CTNSlave::GetNumberOfCases
//----------------------------------------------------------------------------------
//
// Description: Returns the number of test cases loaded.
//
// Arguments: None.
//
// Returns: The number of test cases loaded, or -1 if an error occurred.
//==================================================================================
int CTNSlave::GetNumberOfCases(void)
{
	HRESULT		hr;
	int			iNumCases = 0;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (-1);
	} // end if (slave object is invalid)

	hr = this->m_executor.m_testtable.GetNumberOfCases(&iNumCases);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get number of cases!  %e", 1, hr);
		return (-1);
	} // end if (couldn't get number of cases in the testtable)

	return (iNumCases);
} // CTNSlave::GetNumberOfCases
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetCaseIndex()"
//==================================================================================
// CTNSlave::GetCaseIndex
//----------------------------------------------------------------------------------
//
// Description: Returns pointers to the ID, name, and stats for the case at the
//				given index.  If NULL is passed in for an argument, then that
//				item is not returned.
//
// Arguments:
//	int iIndex				Zero based index of case to retrieve.
//	char** ppszID,			Pointer to place to store pointer to the case ID string,
//							or NULL if not wanted.
//	char** ppszName			Pointer to place to store pointer to the case name
//							string, or NULL if not wanted.
//	PTNTESTSTATS* ppStats	Pointer to place to store pointer to the case stats, or
//							NULL if not wanted.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::GetCaseIndex(int iIndex, char** ppszID, char** ppszName,
								PTNTESTSTATS* ppStats)
{
	HRESULT				hr;
	int					iNumItemsLeft = iIndex;
	PTNTESTTABLECASE	pItem = NULL;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (slave object is invalid)

	hr = this->m_executor.m_testtable.GetCaseIndex(&iNumItemsLeft, &pItem);
	if (hr != S_OK)
	{
		DPL(0, "Failed getting case index %i!", 1, iIndex);
		return (hr);
	} // end if (couldn't get that item)

	if (pItem == NULL)
	{
		DPL(0, "Couldn't find case index %i!", 1, iIndex);
		return (ERROR_INVALID_PARAMETER);
	} // end if (couldn't get that item)


	// Otherwise, we found it so return what we need to.

	if (ppszID != NULL)
		(*ppszID) = pItem->m_pszID;

	if (ppszName != NULL)
		(*ppszName) = pItem->m_pszName;

	if (ppStats != NULL)
		(*ppStats) = &(pItem->m_stats);

	return (S_OK);
} // CTNSlave::GetCaseIndex
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetMachineInfo()"
//==================================================================================
// CTNSlave::GetMachineInfo
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the local machine information, or NULL if an
//				error occurred.
//
// Arguments: None.
//
// Returns: Pointer to info.
//==================================================================================
PTNMACHINEINFO CTNSlave::GetMachineInfo(void)
{
	if (this == NULL)
	{
		DPL(0, "Pointer to object is NULL!", 0);
		return (NULL);
	} // end if (invalid slave object)

	// Prevent the user from retrieving machine information before we're fully in
	// the session, unless we're in documentation mode.
	if ((! this->m_fInSession) && (this->m_executor.m_dwMode != TNMODE_DOCUMENTATION))
	{
		DPL(0, "Not in session yet, can't retrieve accurate machine information!", 0);
		return (NULL);
	} // end if (not in session yet)

	return (&(this->m_executor.m_info));
} // CTNSlave::GetMachineInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::PrintTestTableToFile()"
//==================================================================================
// CTNSlave::PrintTestTableToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the table of all tests loaded to the specified file path.
//
// Arguments:
//	char* szFilepath	Filepath to print to.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::PrintTestTableToFile(char* szFilepath)
{
#ifndef _XBOX // no files
	HRESULT		hr;
	HANDLE		hFile = INVALID_HANDLE_VALUE;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (slave object is invalid)

	hr = FileCreateAndOpenFile(szFilepath, FALSE, FALSE, FALSE, &hFile);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't open file \"%s\"!", 1, szFilepath);
		goto DONE;
	} // end if (couldn't open file)

	this->Log(TNLST_CONTROLLAYER_INFO, "Printing test table to file %s",
			1, szFilepath);

	// Ignoring error
	FileWriteLine(hFile, "ID\tName");
	FileWriteLine(hFile, "--\t----");

	hr = this->m_executor.m_testtable.PrintToFile(hFile, TNTTPO_BUILTIN | TNTTPO_GROUPS);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't print test table to file \"%s\"!", 1, szFilepath);
	} // end if (couldn't open file)


DONE:

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	} // end if (opened file)

	return (hr);
#else // ! XBOX
	return S_OK;
#endif // XBOX

} // CTNSlave::PrintTestTableToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::PrintResultsToFile()"
//==================================================================================
// CTNSlave::PrintResultsToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the current success/failure results for all tests loaded to
//				the specified file.
//
// Arguments:
//	char* szFilepath	Filepath to print to.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::PrintResultsToFile(char* szFilepath)
{
#ifndef _XBOX // no files
	HRESULT		hr;
	HANDLE		hFile = INVALID_HANDLE_VALUE;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (slave object is invalid)


	hr = FileCreateAndOpenFile(szFilepath, FALSE, FALSE, FALSE, &hFile);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't open file \"%s\"!", 1, szFilepath);
		goto DONE;
	} // end if (couldn't open file)

	this->Log(TNLST_CONTROLLAYER_INFO, "Printing test results to file %s",
			1, szFilepath);

	// Ignoring error
	FileWriteLine(hFile, " ID \t Name \t Successes \t Failures \t Total Run \t Warnings ");
	FileWriteLine(hFile, "----\t------\t-----------\t----------\t-----------\t----------");

	hr = this->m_executor.m_testtable.PrintToFile(hFile, TNTTPO_SUCCESSES | TNTTPO_FAILURES | TNTTPO_TOTAL | TNTTPO_WARNINGS);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't print test results to file \"%s\"!", 1, szFilepath);
	} // end if (couldn't open file)


DONE:

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	} // end if (opened file)

	return (hr);
#else // ! XBOX
	return S_OK;
#endif // XBOX
} // CTNSlave::PrintResultsToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::UserQuery()"
//==================================================================================
// CTNSlave::UserQuery
//----------------------------------------------------------------------------------
//
//BUGBUG sync or async?
// Description: Issues a query to the testmaster with the given query ID and
//				data passed in.  The pointers to values will be set to the master's
//				response.
//				The extra response data buffer is allocated here, so it is up to
//				the caller to free it when done.
//
// Arguments:
//	DWORD dwQuery			User defined ID of the query command or type.
//	PVOID pvQueryData		Pointer to data to send with the query.
//	DWORD dwQueryDataSize	Size of the data buffer to send with the query command.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::UserQuery(DWORD dwQuery, PVOID pvQueryData, DWORD dwQueryDataSize)
{
	HRESULT					hr = S_OK;
	PTNSENDDATA				pSendData = NULL;
	PCTRLMSG_USERQUERY		pUserQueryMsg = NULL;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (slave object is invalid)

	if (! this->m_fInSession)
	{
		DPL(0, "Not sending a user request because not in a session!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we're not in a session right now)

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_USERQUERY)
							+ dwQueryDataSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pUserQueryMsg = (PCTRLMSG_USERQUERY) pSendData->m_pvData;
	pUserQueryMsg->dwSize = pSendData->m_dwDataSize;
	pUserQueryMsg->dwType = CTRLMSGID_USERQUERY;

	pUserQueryMsg->dwQuery = dwQuery;
	pUserQueryMsg->dwDataSize = dwQueryDataSize;
	if (pvQueryData != NULL)
		CopyMemory((pUserQueryMsg + 1), pvQueryData, dwQueryDataSize);

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated object)

	return (hr);
} // CTNSlave::UserQuery
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::ExecPokeTest()"
//==================================================================================
// CTNSlave::ExecPokeTest
//----------------------------------------------------------------------------------
//
// Description: Initiates asynchronous execution of the specified test case with the
//				given input data.
//
// Arguments:
//	char* szCaseID									Case to execute.
//	PVOID pvInputData								Pointer to input data for case.
//	DWORD dwInputDataSize							Size of input data buffer for case.
//	PTNPOKETESTCOMPLETEDPROC pfnPokeTestCompleted	Optional function to call when
//													test completes.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::ExecPokeTest(char* szCaseID, PVOID pvInputData, DWORD dwInputDataSize,
								PTNPOKETESTCOMPLETEDPROC pfnPokeTestCompleted,
								PVOID pvUserContext)
{
	HRESULT						hr;
	PTNTESTTABLECASE			pCase = NULL;
	PTNTESTINSTANCES			pTest = NULL;
	int							iNumMachines = 1;
	TNCTRLMACHINEID				aTesterArray[1];
	PTNSENDDATA					pSendData = NULL;
	DWORD						dwModuleIDSize;
	PCTRLMSG_REQUESTPOKETEST	pRequestPokeTestMsg = NULL;
	LPBYTE						lpCurrent = NULL;


	if (! this->m_fInSession)
	{
		DPL(0, "Can't execute poke test (case ID \"%s\") because not in a session!",
			1, szCaseID);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (not in a session)

	if (this->m_executor.m_dwMode != TNMODE_POKE)
	{
		DPL(0, "Can't execute poke test (case ID \"%s\") because not in a poke mode session (it's type %u)!",
			2, szCaseID, this->m_executor.m_dwMode);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (not in a session)

	pCase = this->m_executor.m_testtable.GetTest(szCaseID);
	if (pCase == NULL)
	{
		DPL(0, "Can't find test with case ID \"%s\"!", 1, szCaseID);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (couldn't find case ID)

	if (! (pCase->m_dwOptionFlags & TNTCO_POKE))
	{
		DPL(0, "Test case \"%s\" didn't specify it could be run in poke mode!",
			1, szCaseID);
		hr = E_FAIL;
		goto DONE;
	} // end if (not a poke mode capable test)


#pragma BUGBUG(vanceo, "Implement something for multiple testers")
	CopyMemory(&(aTesterArray[0]), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));


	pTest = new (CTNTestInstanceS)(0xFFFFFFFF,
								pCase,
								NULL,
								iNumMachines,
								aTesterArray,
								//0,
								NULL);
	if (pTest == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pTest->m_dwRefCount++; // we're using it

	pTest->m_iNumMachines = iNumMachines;

	pTest->SetInputData(pvInputData, dwInputDataSize);
	pTest->m_dwRequestID = this->m_dwCurrentUniqueID++;
	pTest->m_pfnPokeTestCompleted = pfnPokeTestCompleted;
	pTest->m_pvUserContext = pvUserContext;


	// Add it to the queue so when we get an ID for it, it can be run.
	hr = this->m_executor.m_queuedtests.Add(pTest);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add new test %x to list!", 1, pTest);
		goto DONE;
	} // end if (couldn't add test to list)




	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	dwModuleIDSize = strlen(szCaseID) + 1;

	pSendData->m_dwDataSize = sizeof (CTRLMSG_REQUESTPOKETEST)
							+ dwModuleIDSize
							+ (iNumMachines * sizeof (TNCTRLMACHINEID))
							+ dwInputDataSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pRequestPokeTestMsg = (PCTRLMSG_REQUESTPOKETEST) pSendData->m_pvData;
	pRequestPokeTestMsg->dwSize = pSendData->m_dwDataSize;
	pRequestPokeTestMsg->dwType = CTRLMSGID_REQUESTPOKETEST;

	CopyMemory(&(pRequestPokeTestMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pRequestPokeTestMsg->dwRequestID = pTest->m_dwRequestID;
	pRequestPokeTestMsg->iNumMachines = iNumMachines;
	pRequestPokeTestMsg->dwInputDataSize = dwInputDataSize;

	lpCurrent = (LPBYTE) (pRequestPokeTestMsg + 1);
	CopyAndMoveDestPointer(lpCurrent, szCaseID, dwModuleIDSize);
	CopyAndMoveDestPointer(lpCurrent, aTesterArray, (iNumMachines * (sizeof (TNCTRLMACHINEID))));

	if (dwInputDataSize > 0)
	{
		//CopyAndMoveDestPointer(lpCurrent, pvInputData, dwInputDataSize);
		CopyMemory(lpCurrent, pvInputData, dwInputDataSize);
	} // end if (there's input data)

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below



DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have send object)

	if (pTest != NULL)
	{
		pTest->m_dwRefCount--;
		if (pTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting test %x.", 1, pTest);
			delete (pTest);
		} // end if (we were the last ones to use the test)
		else
		{
			DPL(7, "Not deleting test %x.", 1, pTest);
		} // end else (we weren't the last ones to use the test)
		pTest = NULL;
	} // end if (have test)

	return (hr);
} // CTNSlave::ExecPokeTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#ifndef _XBOX // no swapping supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::TakeSnapshot()"
//==================================================================================
// CTNSlave::TakeSnapshot
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::TakeSnapshot(void)
{
	HRESULT		hr;


	if (this->m_pBinMgr != NULL)
	{
		DPL(0, "Binary manager already in use!  Can't use again until previous test is complete!", 0);
		return (E_FAIL);
	} // end if (binary manager already in use)

	this->m_pBinMgr = new (CTNBinaryManager);
	if (this->m_pBinMgr == NULL)
	{
		return (E_OUTOFMEMORY);
	} // end if (couldn't allocate object)

	hr = this->m_pBinMgr->SaveSnapshot(&(this->m_executor.m_info.m_binaries),
										this->m_pszSavedBinsDirPath);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't save snapshot of binaries!", 0);
		return (hr);
	} // end if (couldn't allocate object)

	return (S_OK);
} // CTNSlave::TakeSnapshot
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX



#ifndef _XBOX // no swapping supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::RestoreSnapshot()"
//==================================================================================
// CTNSlave::RestoreSnapshot
//----------------------------------------------------------------------------------
//
// Description: ?
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::RestoreSnapshot(void)
{
	HRESULT		hr;


	if (this->m_pBinMgr == NULL)
	{
		DPL(0, "Binary manager not in use!  Can't restore snapshot!", 0);
		return (E_FAIL);
	} // end if (binary manager already in use)

	hr = this->m_pBinMgr->RestoreSnapshot();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't restore snapshot of binaries!", 0);
		return (hr);
	} // end if (couldn't allocate object)

	delete (this->m_pBinMgr);
	this->m_pBinMgr = NULL;

	return (S_OK);
} // CTNSlave::RestoreSnapshot
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleEnumReplyMsg()"
//==================================================================================
// CTNSlave::HandleEnumReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session enum reply message.
//
// Arguments:
//	PVOID* ppvFromAddress				Pointer to pointer to data describing ctrl
//										comm from address.
//	DWORD dwFromAddressSize				Size of from address data.
//	PCTRLMSG_ENUMREPLY pEnumReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleEnumReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_ENUMREPLY pEnumReplyMsg)
{
	HRESULT					hr = S_OK;
	PTNSENDDATA				pSendData = NULL;
	DWORD					dwSessionUserIDSize = 0;
	PCTRLMSG_HANDSHAKE		pHandshakeMsg = NULL;


	//DPL(1, "Got EnumReply message.", 0);

	if (! this->m_fReadyToConnect)
	{
		DPL(0, "Not listening for EnumReplies, ignoring.", 0);
		goto DONE;
	} // end if (we're not listening for these messages)

	if (this->m_fShakingHands)
	{
		DPL(0, "Got EnumReply even though we're in the process of handshaking.  Ignoring.", 0);
		goto DONE;
	} // end if (we're handshaking already)

	if (this->m_fInSession)
	{
		DPL(0, "Got EnumReply even though already in session.  Ignoring.", 0);
		goto DONE;
	} // end if (we're in a session already)

	// BUGBUG compare lpEnumReplyMsg->moduleID or something similar


	if (this->m_pSessionPeriodicSend == NULL)
	{
		DPL(0, "WARNING: Already stopped periodic send, assuming already trying to join but ran into non-thread-safe issue with boolean checks above.  Ignoring.", 0);
		goto DONE;
	} // end if (stopped session already)

	// Since this appears to be a valid enum reply message, we're going
	// to stop enumerating sessions and assume we'll connect.
	hr = this->StopPeriodicSend(this->m_pSessionPeriodicSend);
	if (hr != S_OK)
	{
		DPL(0, "Stopping periodic send %x failed!  %e",
			2, this->m_pSessionPeriodicSend, hr);
	} // end if (there's an active send)

	this->m_pSessionPeriodicSend->m_dwRefCount--;
	if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
	{
		DPL(7, "Deleting session periodic send %x.",
			1, this->m_pSessionPeriodicSend);
		delete (this->m_pSessionPeriodicSend);
	} // end if (last reference)
	else
	{
		DPL(7, "Not deleting session periodic send %x, its refcount is %u.",
			2, this->m_pSessionPeriodicSend,
			this->m_pSessionPeriodicSend->m_dwRefCount);
	} // end else (not last reference)
	this->m_pSessionPeriodicSend = NULL;

	this->m_fShakingHands = TRUE;


	dwSessionUserIDSize = 1; // empty string
	if (this->m_pszSessionFilter != NULL)
		dwSessionUserIDSize += strlen(this->m_pszSessionFilter);


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = dwFromAddressSize;
	pSendData->m_pvAddress = (*ppvFromAddress);

	(*ppvFromAddress) = NULL; // forget about it so it doesn't get freed

	pSendData->m_dwDataSize = sizeof (CTRLMSG_HANDSHAKE)
							+ dwSessionUserIDSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pHandshakeMsg = (PCTRLMSG_HANDSHAKE) pSendData->m_pvData;
	pHandshakeMsg->dwSize = pSendData->m_dwDataSize;
	pHandshakeMsg->dwType = CTRLMSGID_HANDSHAKE;
	pHandshakeMsg->dwVersion = CURRENT_TNCONTROL_API_VERSION;
	CopyMemory(&(pHandshakeMsg->moduleID), &(this->m_executor.m_moduleID),
				sizeof (TNMODULEID));
	pHandshakeMsg->dwMode = this->m_executor.m_dwMode;


	if (this->m_pszSessionFilter != NULL)
		strcpy((char*) (pHandshakeMsg + 1), this->m_pszSessionFilter);
	else
		(*((char*) (pHandshakeMsg + 1))) = '\0'; // empty string


	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have leftover object)

	return (hr);
} // CTNSlave::HandleEnumReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleHandshakeReplyMsg()"
//==================================================================================
// CTNSlave::HandleHandshakeReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session handshake reply message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	PCTRLMSG_HANDSHAKEREPLY pHandshakeReplyMsg		The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleHandshakeReplyMsg(PVOID* ppvFromAddress,
											DWORD dwFromAddressSize,
											PCTRLMSG_HANDSHAKEREPLY pHandshakeReplyMsg)
{
	HRESULT				hr = S_OK;
	PTNSENDDATA			pSendData = NULL;
	PCTRLMSG_JOIN		pJoinMsg = NULL;
	DWORD				dwInfoBufferSize = 0;
	PVOID				pvMasterIPAddr = NULL;
	DWORD				dwMasterIPAddrSize = 0;
	BOOL				fStopJoining = FALSE;


	//DPL(1, "Got HandshakeReply message.", 0);

	if (! this->m_fShakingHands)
	{
		DPL(0, "Not listening for HandshakeReplies, ignoring.", 0);
		goto DONE;
	} // end if (we're not listening for these messages)

	if (this->m_fInSession)
	{
		DPL(0, "Got HandshakeReply even though already in session.  Ignoring.", 0);
		goto DONE;
	} // end if (we're in a session already)

	// BUGBUG compare lpHandshakeReplyMsg->moduleID or something similar

	this->m_fShakingHands = FALSE;


	// If this is the result of a direct join attempt, we should cancel the
	// timer for it.
	if (this->m_pSessionPeriodicSend != NULL)
	{
		hr = this->StopPeriodicSend(this->m_pSessionPeriodicSend);
		if (hr != S_OK)
		{
			DPL(0, "Stopping periodic send %x failed!  %e",
				2, this->m_pSessionPeriodicSend, hr);
		} // end if (there's an active send)

		this->m_pSessionPeriodicSend->m_dwRefCount--;
		if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
		{
			DPL(7, "Deleting session periodic send %x.",
				1, this->m_pSessionPeriodicSend);
			delete (this->m_pSessionPeriodicSend);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting session periodic send %x, its refcount is %u.",
				2, this->m_pSessionPeriodicSend,
				this->m_pSessionPeriodicSend->m_dwRefCount);
		} // end else (not last reference)
		this->m_pSessionPeriodicSend = NULL;
	} // end if (this is a direct join)


	if (pHandshakeReplyMsg->dwStartupDataSize > 0)
	{
		hr = this->m_pfnDoStartup(&(this->m_executor.m_info),
								(pHandshakeReplyMsg + 1),
								pHandshakeReplyMsg->dwStartupDataSize,
								&fStopJoining);
		if (hr != S_OK)
		{
			DPL(0, "Module's DoStartup proc failed!", 0);
			goto DONE;
		} // end if (failed module's proc)

		if (fStopJoining)
		{
			DPL(0, "App specified that we should not join this session.", 0);

			///BUGBUG are we sure we want to reset this?
			this->m_fShakingHands = TRUE;

			// Stop trying to join.  hr == S_OK at this point, so skip to DONE

			goto DONE;
		} // end if (app wants us to stop joining)
	} // end if (there's startup data to perform)


	// Store the session ID
	this->m_dwSessionID = pHandshakeReplyMsg->dwSessionID;

	// Ignore error, assume BUFFER_TOO_SMALL
	this->m_executor.m_info.PackIntoBuffer(NULL, &dwInfoBufferSize);

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = dwFromAddressSize;
	pSendData->m_pvAddress = (*ppvFromAddress);

	// We can't forget the address just yet because we need it again below
	//(*ppvFromAddress) = NULL;

	pSendData->m_dwDataSize = sizeof (CTRLMSG_JOIN)
							+ dwInfoBufferSize
							+ dwFromAddressSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pJoinMsg = (PCTRLMSG_JOIN) pSendData->m_pvData;
	pJoinMsg->dwSize = pSendData->m_dwDataSize;
	pJoinMsg->dwType = CTRLMSGID_JOIN;

	hr = this->m_executor.m_testtable.CalculateChecksum(&(pJoinMsg->testChecksum));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't calculate test table checksum!", 0);
		goto DONE;
	} // end if (couldn't calculate checksum)

	hr = this->GetMultiInstanceKey(&(pJoinMsg->dwMultiInstanceKey));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get multi-instance key!", 0);
		goto DONE;
	} // end if (couldn't get key)

	pJoinMsg->dwTimelimit = this->m_dwTimelimit;
	pJoinMsg->dwInfoSize = dwInfoBufferSize;
	pJoinMsg->dwMasterAddrSize = dwFromAddressSize;

	hr = this->m_executor.m_info.PackIntoBuffer((pJoinMsg + 1), &dwInfoBufferSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't pack machine info into buffer!", 0);
		goto DONE;
	} // end if (failed PackIntoBuffer)

	// Spit the master's address right back to him.  It may be used for some
	// NAT stuff on TCP/IP, see the master object for details.
	CopyMemory((((LPBYTE) (pJoinMsg + 1)) + dwInfoBufferSize), (*ppvFromAddress),
			dwFromAddressSize);

	// Forget about return address so it doesn't get freed (we used it for the send
	// data object above)
	(*ppvFromAddress) = NULL;

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have leftover object)

	return (hr);
} // CTNSlave::HandleHandshakeReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleJoinReplyMsg()"
//==================================================================================
// CTNSlave::HandleJoinReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session join reply message.
//
// Arguments:
//	PVOID* ppvFromAddress				Pointer to pointer to data describing ctrl
//										comm from address.
//	DWORD dwFromAddressSize				Size of from address data.
//	PCTRLMSG_JOINREPLY pJoinReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleJoinReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_JOINREPLY pJoinReplyMsg)
{
	HRESULT					hr;
	PMULTIINSTANCEMMFILE	pMultiInstanceInfo = NULL;
#ifndef _XBOX // multiple local slaves not supported
	int						i;
#endif // ! XBOX

	//DPL(1, "Got JoinReply message.", 0);

	if (this->m_fInSession)
	{
		DPL(0, "Already in session.  Ignoring.", 0);
		return (S_OK);
	} // end if (we're in a session already)

	// BUGBUG compare lpJoinReplyMsg->moduleID or something similar

	CopyMemory(&(this->m_executor.m_id), &(pJoinReplyMsg->id),
				sizeof (TNCTRLMACHINEID));

	((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress = (*ppvFromAddress);
	(*ppvFromAddress) = NULL; // forget about it so it doesn't get freed

	((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize = dwFromAddressSize;

	hr = this->m_pCtrlComm->BindDataToAddress((PCOMMDATA) this->m_pvTestmasterCommData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't bind new machine's control comm data!", 0);
		return (hr);
	} // end if (couldn't bind ctrl comm address)

	// We've got our first real, in-session message from the master, update the time
	this->m_dwLastMasterReceive = GetTickCount();


#ifndef _XBOX // multiple local slaves not supported

	// Save the session and slave IDs into the instance info area, too.  Print a note
	// if we notice there is another instance already in the same session.

	// Grab the lock
	WaitForSingleObject(this->m_hMultiInstanceMutex, INFINITE);

	// Map the file
	pMultiInstanceInfo = (PMULTIINSTANCEMMFILE) MapViewOfFile(this->m_hMultiInstanceMMFile,
															FILE_MAP_ALL_ACCESS,
															0, 0, 0);
	if (pMultiInstanceInfo == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't map view of file!", 0);
		ReleaseMutex(this->m_hMultiInstanceMutex);
		return (hr);
	} // end if (couldn't map view of file)

	pMultiInstanceInfo->aInstances[this->m_iInstanceIndex].dwSessionID = this->m_dwSessionID;
	CopyMemory(&(pMultiInstanceInfo->aInstances[this->m_iInstanceIndex].id),
				&(pJoinReplyMsg->id), sizeof (TNCTRLMACHINEID));

	// Loop through all the slots to determine if there's another instance already
	// running on this machine that's in the session we just joined.
	for(i = 0; i < MAX_NUM_LOCAL_INSTANCES; i++)
	{
		// Skip our slot.
		if (i == this->m_iInstanceIndex)
			continue;

		if ((pMultiInstanceInfo->aInstances[i].fInUse) &&
			(pMultiInstanceInfo->aInstances[i].dwSessionID == this->m_dwSessionID))
		{
			DPL(0, "WARNING: Another TestNet slave instance on this machine is already in the same session we're joining!", 0);
			this->Log(TNLST_CRITICAL,
					"WARNING: Another TestNet slave instance on this machine is already in the same session we're joining!",
					0);
			break; // don't bother looking for more
		} // end if (slot is in use and in same session)
	} // end for (each existing slot)

	ReleaseMutex(this->m_hMultiInstanceMutex);

#endif // ! XBOX

	// Start up testing thread
	hr = this->m_executor.StartTestThread();
	if (hr != S_OK)
	{
		DPL(0, "Starting test thread failed!", 0);
		return (hr);
	} // end if (starting test thread failed)


	// Okeydokey
	this->m_fInSession = TRUE;

	DPL(1, "Joined session ID %u.", 1, this->m_dwSessionID);


	// Ping the event to let the app know we're in a session and the control
	// layer is ready.
	if ((this->m_hCompletionOrUpdateEvent != NULL) &&
		(! SetEvent(this->m_hCompletionOrUpdateEvent)))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set the user's update event (%x)!",
			1, this->m_hCompletionOrUpdateEvent);
		return (hr);
	} // end if (couldn't set the user's update event)


#pragma TODO(vanceo, "Start timer if user wants us to close session after x amount of time")


	hr = this->SendReadyForFirstTest();
	if (hr != S_OK)
	{
		DPL(0, "Notify master of readiness failed!", 0);
	} // end if (sending ready failed)

	return (hr);
} // CTNSlave::HandleJoinReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleTestingStatusMsg()"
//==================================================================================
// CTNSlave::HandleTestingStatusMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session testing status message.
//
// Arguments:
//	PVOID* ppvFromAddress						Pointer to pointer to data
//												describing ctrl comm from address.
//	DWORD dwFromAddressSize						Size of from address data.
//	PCTRLMSG_TESTINGSTATUS pTestingStatusMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleTestingStatusMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_TESTINGSTATUS pTestingStatusMsg)
{
	HRESULT		hr;


	//DPL(1, "Got TestStatus message.", 0);

	if (! this->m_fInSession)
	{
		DPL(0, "Not in session.  Ignoring.", 0);
		return (S_OK);
	} // end if (we're not in a session already)

	// BUGBUG compare lpJoinReplyMsg->moduleID or something similar


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();

	switch (pTestingStatusMsg->dwStatus)
	{
		case CTRLTS_ALLCOMPLETE:
			// All testing is completely finished, you are all done.

			// BUGBUG toss out if we are currently running a test

			this->m_fTestingComplete = TRUE;


			hr = this->m_executor.KillTestThread(FALSE);
			if (hr != S_OK)
			{
				DPL(0, "Failed killing test thread because of testing completion!  %e", 1, hr);
			} // end if (couldn't kill test thread)
			else
			{
				DPL(1, "Disconnecting from master.", 0);

				hr = this->m_pCtrlComm->UnbindDataFromAddress((PCOMMDATA) this->m_pvTestmasterCommData);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't disconnect from master!  %e", 1, hr);
				} // end if (couldn't disconnect from master)
				else
				{
					LocalFree(((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress);
					((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress = NULL;
					((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize = 0;


					// Empty out the results list.
					hr = this->m_executor.FreeResultsInternal(NULL, NULL, FALSE);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't free all results!", 0);
					} // end if (couldn't free all results)
					else
					{
						DPL(0, "All testing complete.", 0);
						// Ignore error
						this->Log(TNLST_CONTROLLAYER_INFO, "All testing complete!", 0);

						if (this->m_totalstats.GetFailures() > 0)
						{
							DPL(0, "NOTE: %u failure%soccurred (not including subtests).",
								2, this->m_totalstats.GetFailures(),
								((this->m_totalstats.GetFailures() == 1) ? " " : "s "));
							// Ignore error
							this->Log(TNLST_CONTROLLAYER_TESTFAILURE, "NOTE: %u failure%soccurred (not including subtests).",
									2, this->m_totalstats.GetFailures(),
									((this->m_totalstats.GetFailures() == 1) ? " " : "s "));
						} // end if (there were failures)

						if (this->m_totalstats.GetWarnings() > 0)
						{
							DPL(0, "NOTE: %u warning%soccurred.",
								2, this->m_totalstats.GetWarnings(),
								((this->m_totalstats.GetWarnings() == 1) ? " " : "s "));
							// Ignore error
							this->Log(TNLST_CONTROLLAYER_TESTWARNING, "NOTE: %u warning%soccurred.",
									2, this->m_totalstats.GetWarnings(),
									((this->m_totalstats.GetWarnings() == 1) ? " " : "s "));
						} // end if (there were warnings)

						// Fire the event to let the app know we're done.
						if ((this->m_hCompletionOrUpdateEvent != NULL) &&
							(! SetEvent(this->m_hCompletionOrUpdateEvent)))
						{
							hr = GetLastError();
								
							DPL(0, "Couldn't set the user's update event (%x)!",
								1, this->m_hCompletionOrUpdateEvent);
						} // end if (couldn't set the user's update event)
					} // end else (successfully freed all results)
				} // end else (didn't fail to disconnect)
			} // end else (didn't fail to kill the test thread)
		  break;

		case CTRLTS_REPETITIONCOMPLETE:
			// The current pass is finished, reset yourself for the next pass.


			DPL(0, "Repetition has completed.", 0);
			// Ignore error
			this->Log(TNLST_CONTROLLAYER_INFO, "Repetition has completed.", 0);
			
#pragma TODO(vanceo, "Make sure no leeches exist, here and in CTRLTS_ALLCOMPLETE")

#pragma BUGBUG(vanceo, "Make it an option to free all results?")
			hr = this->m_executor.FreeResultsInternal(NULL, NULL, FALSE);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't free all results!", 0);
				//goto DONE;
			} // end if (couldn't free all results)
		  break;

		default:
			DPL(0, "Received unknown testing status (%u)!",
				1, pTestingStatusMsg->dwStatus);

			hr = E_NOTIMPL;
		  break;
	} // end switch (on the type of status)

	return (hr);
} // CTNSlave::HandleTestingStatusMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleNewTestMsg()"
//==================================================================================
// CTNSlave::HandleNewTestMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session new test message.
//
// Arguments:
//	PVOID* ppvFromAddress			Pointer to pointer to data describing ctrl comm
//									from address.
//	DWORD dwFromAddressSize			Size of from address data.
//	PCTRLMSG_NEWTEST pNewTestMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleNewTestMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_NEWTEST pNewTestMsg)
{
	HRESULT				hr;
	char*				pszCaseString;
	char*				pszInstanceString;
	PTNCTRLMACHINEID	paTesters;
	PVOID				pvInputData;


	DPL(6, "Got NewTest message (ID %u).",
		1, pNewTestMsg->dwUniqueTestID);

	if (! this->m_fInSession)
	{
		DPL(0, "Not in session.  Ignoring.", 0);
		return (S_OK);
	} // end if (we're not in a session already)

	// BUGBUG compare lpJoinReplyMsg->moduleID or something similar


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();


	pszCaseString = (char*) (pNewTestMsg + 1);

	pszInstanceString = pszCaseString + strlen(pszCaseString) + 1;

	paTesters = (PTNCTRLMACHINEID) (pszInstanceString + strlen(pszInstanceString) + 1);

	if (pNewTestMsg->dwInputDataSize == 0)
		pvInputData = NULL;
	else
		pvInputData = paTesters + pNewTestMsg->iNumMachines;


	hr = this->m_executor.HandleNewTest(pNewTestMsg->dwUniqueTestID,
										pszCaseString,
										pszInstanceString,
										pNewTestMsg->iNumMachines,
										paTesters,
										pvInputData,
										pNewTestMsg->dwInputDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't handle new test!", 0);
		// return (hr);
	} // end if (couldn't have executor handle new test)

	return (hr);
} // CTNSlave::HandleNewTestMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleAnnounceTestReplyMsg()"
//==================================================================================
// CTNSlave::HandleAnnounceTestReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session announce test reply message.
//
// Arguments:
//	PVOID* ppvFromAddress								Pointer to pointer to data
//														describing ctrl comm from
//														address.
//	DWORD dwFromAddressSize								Size of from address data.
//	PCTRLMSG_ANNOUNCETESTREPLY pAnnounceTestReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleAnnounceTestReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_ANNOUNCETESTREPLY pAnnounceTestReplyMsg)
{
	HRESULT		hr;


	//DPL(1, "Got AnnounceTestReply message.", 0);

	if (! this->m_fInSession)
	{
		DPL(0, "Not in session.  Ignoring.", 0);
		return (S_OK);
	} // end if (we're not in a session already)

	// BUGBUG compare lpJoinReplyMsg->moduleID or something similar


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();


	hr = this->m_executor.HandleAnnounceResponse(pAnnounceTestReplyMsg->dwResponseID,
												pAnnounceTestReplyMsg->dwUniqueTestID);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't handle announce test response!", 0);
		// return (hr);
	} // end if (couldn't have executor handle response)

	return (hr);
} // CTNSlave::HandleAnnounceTestReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleSyncReplyMsg()"
//==================================================================================
// CTNSlave::HandleSyncReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session sync reply message.
//
// Arguments:
//	PVOID* ppvFromAddress				Pointer to pointer to data describing ctrl
//										comm from address.
//	DWORD dwFromAddressSize				Size of from address data.
//	PCTRLMSG_SYNCREPLY pSyncReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleSyncReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_SYNCREPLY pSyncReplyMsg)
{
	HRESULT		hr;


	//DPL(1, "Got SyncReply message.", 0);

	if (! this->m_fInSession)
	{
		DPL(0, "Not in session.  Ignoring.", 0);
		return (S_OK);
	} // end if (we're not in a session already)

	// BUGBUG compare lpJoinReplyMsg->moduleID or something similar


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();


	hr = this->m_executor.HandleSyncResponse(pSyncReplyMsg->dwResponseID,
											((pSyncReplyMsg->dwDataSize > 0) ? (pSyncReplyMsg + 1) : NULL),
											pSyncReplyMsg->dwDataSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't handle sync response!", 0);
		// return (hr);
	} // end if (couldn't have executor handle response)

	return (hr);
} // CTNSlave::HandleSyncReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleUserResponseMsg()"
//==================================================================================
// CTNSlave::HandleUserResponseMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session user response message.
//
// Arguments:
//	PVOID* ppvFromAddress					Pointer to pointer to data describing
//											ctrl comm from address.
//	DWORD dwFromAddressSize					Size of from address data.
//	PCTRLMSG_USERRESPONSE pUserResponseMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleUserResponseMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_USERRESPONSE pUserResponseMsg)
{
	PUSERRESPONSEDATA	purData = NULL;
	DWORD				dwURDataSize = 0;


	//DPL(1, "Got UserResponse message.", 0);

	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();

	dwURDataSize = sizeof (DWORD) * 3 // dwSize, dwResponse & dwResponseDataSize
					+ pUserResponseMsg->dwDataSize;

	purData = (PUSERRESPONSEDATA) LocalAlloc(LPTR, dwURDataSize);
	if (purData == NULL)
		return (E_OUTOFMEMORY);

	purData->dwSize = dwURDataSize;
	purData->dwResponse = pUserResponseMsg->dwResponse;
	purData->dwResponseDataSize = pUserResponseMsg->dwDataSize;
	CopyMemory((purData + 1), (pUserResponseMsg + 1),
			pUserResponseMsg->dwDataSize);

	//BUGBUG this is leaking right now, either do async or sync
	//PostMessage(this->m_hWnd, WM_TN_USERRESPONSE, (WPARAM) purData, 0);

	return (S_OK);
} // CTNSlave::HandleUserResponseMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleIdleReplyMsg()"
//==================================================================================
// CTNSlave::HandleIdleReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session idle reply message.
//
// Arguments:
//	PVOID* ppvFromAddress				Pointer to pointer to data describing ctrl
//										comm from address.
//	DWORD dwFromAddressSize				Size of from address data.
//	PCTRLMSG_IDLEREPLY pIdleReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleIdleReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_IDLEREPLY pIdleReplyMsg)
{
	DPL(1, "Got IdleReply message.", 0);


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();

	switch (pIdleReplyMsg->dwStatus)
	{
		case CTRLIDLEREPLY_WAITINGFOROTHERTESTERS:
			// The master knows we're waiting, he's just not letting us go yet
			// because of someone else.
#pragma BUGBUG(vanceo, "Implement!")
			//this->m_dwAnnounceTimeouts = 0;
		  break;

		default:
			DPL(0, "Unknown IdleReply status %u!  Ignoring.", 1, pIdleReplyMsg->dwStatus);
		  break;
	} // end switch (on master's status)

	return (S_OK);
} // CTNSlave::HandleIdleReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleDumpLogMsg()"
//==================================================================================
// CTNSlave::HandleDumpLogMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session break message.
//
// Arguments:
//	PVOID* ppvFromAddress			Pointer to pointer to data describing ctrl comm
//									from address.
//	DWORD dwFromAddressSize			Size of from address data.
//	PCTRLMSG_DUMPLOG pDumpLogMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleDumpLogMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								PCTRLMSG_DUMPLOG pDumpLogMsg)
{
	HRESULT		hr = S_OK;
	char*		pszFile = NULL;
	DWORD		dwSize;
	char		szNumber[32];
	char		szTemp[1024];
#ifdef _XBOX // Damn ANSI conversion
	WCHAR		szWideNumber[32];
#endif

	//DPL(1, "Got DumpLog message.", 0);


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();


#ifndef _XBOX // no other processes supported, so can't call netstat
	// If we should grab the net stat info, do so.
	if (this->m_fGetNetStatInfoOnFailure)
	{
		this->GetNetStatInfo();
	} // end if (failed and should grab net stat info)
#else // ! XBOX
#pragma TODO(tristanj, "No longer able to call netstat on a failure")
#endif // XBOX


#ifndef _XBOX // Damn ANSI conversion
	wsprintf(szNumber, "%u", pDumpLogMsg->dwUniqueTestID);
#else // ! XBOX
	wsprintf(szWideNumber, L"%u", pDumpLogMsg->dwUniqueTestID);
	wcstombs(szNumber, szWideNumber, wcslen(szWideNumber));
	szNumber[wcslen(szWideNumber)] = 0;
#endif // XBOX

	// If the master specified a location use it.  Otherwise, use our default
	// location.  If we don't have that either, than just ignore the message
	if (pDumpLogMsg->dwPathSize > 0)
	{
		pszFile = (char*) LocalAlloc(LPTR, (pDumpLogMsg->dwPathSize + 1));
		if (pszFile == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		CopyMemory(pszFile, (pDumpLogMsg + 1), pDumpLogMsg->dwPathSize);
	} // end if (the master is specifying a path to dump)
	else if (this->m_pszFailureMemDumpDirPath != NULL)
	{
		dwSize = strlen(this->m_pszFailureMemDumpDirPath)
				+ strlen(szNumber)
				+ 16; // "req_memlog_" + ".txt" + NULL termination

		if (! StringEndsWith(this->m_pszFailureMemDumpDirPath, "\\", TRUE))
			dwSize++; // add backslash
		
		pszFile = (char*) LocalAlloc(LPTR, dwSize);
		if (pszFile == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		strcpy(pszFile, this->m_pszFailureMemDumpDirPath);
		if (! StringEndsWith(this->m_pszFailureMemDumpDirPath, "\\", TRUE))
			strcat(pszFile, "\\"); // add backslash
		strcat(pszFile, "req_memlog_");
		strcat(pszFile, szNumber);
		strcat(pszFile, ".txt");
	} // end else if (we have a local path)
	else
	{
		DPL(0, "Master told us to dump the memory log, but didn't specify where and we don't have a default location!  Ignoring.", 0);
		goto DONE;
	} // end else (we don't have any idea where to put it)


	// If we got here, we have location to use from somewhere.

#ifndef _XBOX // No dumping files supported
	//Ignoring error
	this->Log(TNLST_CONTROLLAYER_INFO,
				"Master requested memory log dump to file \"%s\" because of test ID %u.",
				2, pszFile, pDumpLogMsg->dwUniqueTestID);
	DPL(0, "Master requested memory log dump to file \"%s\" because of test ID %u.",
		2, pszFile, pDumpLogMsg->dwUniqueTestID);

	StringGetCurrentDateStr(szTemp);
	StringPrepend(szTemp, ")");
	StringPrepend(szTemp, szNumber);
	StringPrepend(szTemp, "Master requested mem log dump (for test ID ");

	TNDebugDumpMemoryLogToFile(pszFile, szTemp, TRUE);
#endif // ! XBOX
	


DONE:

	if (pszFile != NULL)
	{
		LocalFree(pszFile);
		pszFile = NULL;
	} // end if (allocated string)

	return (hr);
} // CTNSlave::HandleDumpLogMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleBreakMsg()"
//==================================================================================
// CTNSlave::HandleBreakMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session break message.
//
// Arguments:
//	PVOID* ppvFromAddress		Pointer to pointer to data describing ctrl comm from
//								address.
//	DWORD dwFromAddressSize		Size of from address data.
//	PCTRLMSG_BREAK pBreakMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleBreakMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								PCTRLMSG_BREAK pBreakMsg)
{
	HRESULT		hr;


	//DPL(1, "Got Break message.", 0);


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();
	

	// Make sure all outgoing messages are actually on their way.
	hr = this->m_pCtrlComm->FlushSendQueue();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't flush send queue!", 0);
		goto DONE;
	} // end if (couldn't flush queue)


	//Ignoring error
	this->Log(TNLST_CRITICAL,
			"Master requested we DebugBreak because of test unique ID %u!",
			1, pBreakMsg->dwUniqueTestID);

	DPL(0, "Master requested we DebugBreak because of test unique ID %u!",
		1, pBreakMsg->dwUniqueTestID);

	DEBUGBREAK();


DONE:

	return (hr);
} // CTNSlave::HandleBreakMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleMetaMasterReplyMsg()"
//==================================================================================
// CTNSlave::HandleMetaMasterReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session meta-master reply message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	PCTRLMSG_METAMASTERREPLY pMetaMasterReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleMetaMasterReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_METAMASTERREPLY pMetaMasterReplyMsg)
{
	HRESULT					hr = S_OK;
	COMMDATA				cd;
	PTNSENDDATA				pSendData = NULL;
	PCTRLMSG_HANDSHAKE		pHandshakeMsg = NULL;


	//DPL(1, "Got MetaMasterReply message.", 0);

	if (! this->m_fQueryingMetaMaster)
	{
		DPL(0, "Not listening for MetaMasterReplies, ignoring.", 0);
		goto DONE;
	} // end if (we're not listening for these messages)

	if (this->m_fShakingHands)
	{
		DPL(0, "Got MetaMasterReply even though we're in the process of handshaking.  Ignoring.", 0);
		goto DONE;
	} // end if (we're handshaking already)

	if (this->m_fInSession)
	{
		DPL(0, "Got MetaMasterReply even though we're already in session.  Ignoring.", 0);
		goto DONE;
	} // end if (we're in a session already)

	// BUGBUG compare lpMetaMasterReplyMsg->moduleID or something similar

	// Since this appears to be a valid meta-master reply message, we're going to
	// try to join the specified master.  Stop trying to talk to the meta-master
	hr = this->StopPeriodicSend(this->m_pSessionPeriodicSend);
	if (hr != S_OK)
	{
		DPL(0, "Stopping periodic send %x failed!  %e",
			2, this->m_pSessionPeriodicSend, hr);
	} // end if (there's an active send)

	this->m_pSessionPeriodicSend->m_dwRefCount--;
	if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
	{
		DPL(7, "Deleting session periodic send %x.",
			1, this->m_pSessionPeriodicSend);
		delete (this->m_pSessionPeriodicSend);
	} // end if (last reference)
	else
	{
		DPL(7, "Not deleting session periodic send %x, its refcount is %u.",
			2, this->m_pSessionPeriodicSend,
			this->m_pSessionPeriodicSend->m_dwRefCount);
	} // end else (not last reference)
	this->m_pSessionPeriodicSend = NULL;


	// Disconnect from the meta master.  Control comm objects are spec'ed to treat
	// an Unbind call on an address that isn't bound yet as a disconnect.
	ZeroMemory(&cd, sizeof (COMMDATA));
	cd.pvAddress = (*ppvFromAddress);
	cd.dwAddressSize = dwFromAddressSize;
	hr = this->m_pCtrlComm->UnbindDataFromAddress(&cd);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't disconnect from meta-master!", 0);
		goto DONE;
	} // end if (couldn't disconnect meta-master)


	if (pMetaMasterReplyMsg->dwStatus == CTRLMETAMASTERREPLY_FOUNDMASTER)
	{
		DPL(0, "Meta-master found a suitable master, attempting to connect to \"%s\".",
			1, (pMetaMasterReplyMsg + 1));
		this->Log(TNLST_CONTROLLAYER_INFO,
					"Meta-master found a suitable master, attempting to connect to \"%s\".",
					1, (pMetaMasterReplyMsg + 1));


		this->m_fShakingHands = TRUE;

		pSendData = new (CTNSendData);
		if (pSendData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (out of memory)

		pSendData->m_fGuaranteed = TRUE;

		// Ignore error, assume ERROR_BUFFER_TOO_SMALL
		this->m_pCtrlComm->ConvertStringToAddress((char*) (pMetaMasterReplyMsg + 1),
													NULL,
													0,
													NULL,
													&(pSendData->m_dwAddressSize));
		pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
		if (pSendData->m_pvAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)
		hr = this->m_pCtrlComm->ConvertStringToAddress((char*) (pMetaMasterReplyMsg + 1),
														NULL,
														0,
														pSendData->m_pvAddress,
														&(pSendData->m_dwAddressSize));
		if (hr != S_OK)
		{
			DPL(0, "Control method couldn't convert \"%s\" to address!",
				1, (char*) (pMetaMasterReplyMsg + 1));
			goto DONE;
		} // end if (failed converting string to address)

		pSendData->m_dwDataSize = sizeof (CTRLMSG_HANDSHAKE);
		if (this->m_pszSessionFilter != NULL)
			pSendData->m_dwDataSize += strlen(this->m_pszSessionFilter) + 1;
		else
			pSendData->m_dwDataSize++; // empty string


		pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
		if (pSendData->m_pvData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		pHandshakeMsg = (PCTRLMSG_HANDSHAKE) pSendData->m_pvData;
		pHandshakeMsg->dwSize = pSendData->m_dwDataSize;
		pHandshakeMsg->dwType = CTRLMSGID_HANDSHAKE;
		pHandshakeMsg->dwVersion = CURRENT_TNCONTROL_API_VERSION;
		CopyMemory(&(pHandshakeMsg->moduleID), &(this->m_executor.m_moduleID),
					sizeof (TNMODULEID));
		pHandshakeMsg->dwMode = this->m_executor.m_dwMode;


		if (this->m_pszSessionFilter != NULL)
			strcpy((char*) (pHandshakeMsg + 1), this->m_pszSessionFilter);
		else
			(*((char*) (pHandshakeMsg + 1))) = '\0'; // empty string


		hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add send item to queue!", 0);
			goto DONE;
		} // end if (failed to add item to queue)

		pSendData = NULL; // forget about it so it doesn't get freed below
	} // end if (found a master to try to join)
	else
	{
		DPL(0, "Meta-master did not successfully find a master for us!", 0);
		this->Log(TNLST_CRITICAL,
				"Meta-master did not successfully find a master for us!", 0);

		// Ping the event to let the app know we failed to get a session.
		if ((this->m_hCompletionOrUpdateEvent != NULL) &&
			(! SetEvent(this->m_hCompletionOrUpdateEvent)))
		{
			if (hr == S_OK)
				hr = GetLastError();
				
			DPL(0, "Couldn't set the user's update event (%x)!",
				1, this->m_hCompletionOrUpdateEvent);
		} // end if (couldn't set the user's update event)
	} // end else (not okay to join)


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have leftover object)

	return (hr);
} // CTNSlave::HandleMetaMasterReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleMasterPingSlaveMsg()"
//==================================================================================
// CTNSlave::HandleMasterPingSlaveMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a master ping slave reply message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	LPCTRLMSG_MASTERPINGSLAVE lpMasterPingMsg		Master ping message.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleMasterPingSlaveMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
										PCTRLMSG_MASTERPINGSLAVE pMasterPingMsg)
{
	HRESULT							hr = S_OK;
	DWORD							dwTickCount;
	PTNSENDDATA						pSendData = NULL;
	PCTRLMSG_MASTERPINGSLAVEREPLY	pMasterPingReply = NULL;
	

	DPL(8, "Got MasterPingSlave message.", 0);

	// If our test thread isn't cooking, ignore the message
	if (this->m_executor.m_hTestThread == NULL)
	{
		//BUGBUG disconnect from session gracefully
		DPL(0, "Ignoring ping message because test thread is gone.", 0);
		return (S_OK);
	} // end if (we don't have a test thread)


	// Only run the deadlock check if the module hasn't disabled it.
	if (this->m_executor.m_fDeadlockCheck)
	{
#pragma BUGBUG(vanceo, "This won't detect deadlocks in leeches.")
		dwTickCount = GetTickCount();
		if (this->m_executor.m_dwLastTestthreadPing + DEADLOCK_WARNING_TIME < dwTickCount)
		{
			if (this->m_executor.m_dwLastTestthreadPing + DEADLOCK_WARNING_TIME + DEADLOCK_BREAK_TIME < dwTickCount)
			{
				BOOL	fGotThreadBlockNote;
				char	szModule[256];
				char	szSection[256];
				char	szFile[256];
				int		iLineNum = 0;
				char	szInfoString[256];
				DWORD	dwNoteAge = 0;


				DPL(0, "Test thread appears to be deadlocked, haven't heard from it in %u ticks!",
					1, dwTickCount - this->m_executor.m_dwLastTestthreadPing);
#ifndef _XBOX // no GetCurrentProcessId
				DPL(0, "Current process ID = %x/%u, test thread ID = %x/%u, DEBUGBREAK()ing",
					4, GetCurrentProcessId(), GetCurrentProcessId(),
					this->m_executor.m_dwTestThreadID, this->m_executor.m_dwTestThreadID);
#endif // ! XBOX

				fGotThreadBlockNote = TNDebugGetThreadBlockNote(this->m_executor.m_dwTestThreadID,
																szModule, szSection,
																szFile, &iLineNum,
																szInfoString, &dwNoteAge);
				if (fGotThreadBlockNote)
				{
					DPL(0, "Last known position (%u ms ago) = %s:%s (%s line %i) \"%s\".",
						6, dwNoteAge, szModule, szSection, szFile, iLineNum, szInfoString);
				} // end if (failed getting last known thread position)

				this->Log(TNLST_CRITICAL,
						"Test thread appears to be deadlocked, haven't heard from it in %u ticks!",
						1, dwTickCount - this->m_executor.m_dwLastTestthreadPing);
#ifndef _XBOX // No GetCurrentProcessId
				this->Log(TNLST_CRITICAL,
						"Current process ID = %x/%u, test thread ID = %x/%u, DEBUGBREAK()ing",
						4, GetCurrentProcessId(), GetCurrentProcessId(),
						this->m_executor.m_dwTestThreadID, this->m_executor.m_dwTestThreadID);
#endif // ! XBOX

				if (fGotThreadBlockNote)
				{
					this->Log(TNLST_CRITICAL,
							"Last known position (%u ms ago) = %s:%s (%s line %i) \"%s\".",
							6, dwNoteAge, szModule, szSection, szFile, iLineNum, szInfoString);
				} // end if (failed getting last known thread position)

				// Make sure all the messages are out of the queue.
				this->m_pCtrlComm->FlushSendQueue();

				DEBUGBREAK();

				return (E_FAIL);
			} // end if (should break)
			else
			{
				DPL(0, "WARNING: Deadlock/hang may be occurring, haven't heard from test thread in %u ticks.",
					1, dwTickCount - this->m_executor.m_dwLastTestthreadPing);

				this->Log(TNLST_CRITICAL,
						"Deadlock/hang may be occurring, haven't heard from test thread in %u ticks.",
						1, dwTickCount - this->m_executor.m_dwLastTestthreadPing);
			} // end else (should just be a deadlock warning)
		} // end if (deadlock may be occurring)
	} // end if (should check for deadlocks)


	// Send a reply back to the master

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = dwFromAddressSize;

	// Use the address supplied
	pSendData->m_pvAddress = *ppvFromAddress;

	*ppvFromAddress = NULL;

	pSendData->m_dwDataSize = sizeof(CTRLMSG_MASTERPINGSLAVEREPLY);
	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	
	if (!pSendData->m_pvData)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	// Copy the master ping slave data back
	// This consists mainly of the slave ID so that the master can use
	// it for reference
	
	ZeroMemory(pSendData->m_pvData, pSendData->m_dwDataSize);

	pMasterPingReply = (PCTRLMSG_MASTERPINGSLAVEREPLY)pSendData->m_pvData;
	pMasterPingReply->dwSize = pSendData->m_dwDataSize;
	pMasterPingReply->dwType = CTRLMSGID_MASTERPINGSLAVEREPLY;

	CopyMemory(&pMasterPingReply->id, &this->m_executor.m_id, 
				sizeof (TNCTRLMACHINEID));

	// Queue the send
	
	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed sending data)

	pSendData = NULL; // forget about it so we don't free it below
	


DONE:

	// Delete any allocated memory
	
	if (pSendData != NULL)
	{
		delete pSendData;
		pSendData = NULL;
	} // end if (have object)

	return (hr);
} // CTNSlave::HandleMasterPingSlaveMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleLostTesterMsg()"
//==================================================================================
// CTNSlave::HandleLostTesterMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session get LostTester message.
//
// Arguments:
//	PVOID* ppvFromAddress				Pointer to pointer to data describing ctrl
//										comm from address.
//	DWORD dwFromAddressSize				Size of from address data.
//	PCTRLMSG_LOSTTESTER pLostTesterMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleLostTesterMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
									PCTRLMSG_LOSTTESTER pLostTesterMsg)
{
	HRESULT			hr = S_OK;


	//DPL(1, "Got LostTester message.", 0);

	if (! this->m_fInSession)
	{
		DPL(0, "Not in session.  Ignoring.", 0);
		goto DONE;
	} // end if (we're not in a session already)

	// BUGBUG compare lpJoinReplyMsg->moduleID or something similar


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();



	hr = this->m_executor.HandleLostTester(pLostTesterMsg->dwTopLevelUniqueID,
											pLostTesterMsg->dwTestUniqueID,
											pLostTesterMsg->iTesterNum);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't handle LostTester message!", 0);
		//goto DONE;
	} // end if (couldn't have executor handle message)

DONE:

	return (hr);
} // CTNSlave::HandleLostTesterMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleAcceptReachCheckMsg()"
//==================================================================================
// CTNSlave::HandleAcceptReachCheckMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session accept reach check message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	PCTRLMSG_ACCEPTREACHCHECK pAcceptReachCheckMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleAcceptReachCheckMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_ACCEPTREACHCHECK pAcceptReachCheckMsg)
{
	HRESULT								hr = S_OK;
	PTNREACHCHECK						pReachCheck = NULL;
	PTNREACHCHECKTARGET					pReachCheckTarget = NULL;
	BOOL								fReplySuccess = FALSE;
	HRESULT								hrReplyResult = E_FAIL;
	PTNSENDDATA							pSendData = NULL;
	PCTRLMSG_ACCEPTREACHCHECKREPLY		pReplyMsg;



	DPL(1, "Got AcceptReachCheck message (method %u, ID %u).",
		2, pAcceptReachCheckMsg->dwMethod,
		pAcceptReachCheckMsg->dwID);


	// Get our self-target list if it exists, or create one otherwise.
	pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(this->m_executor.m_id));
	if (pReachCheckTarget == NULL)
	{
		pReachCheckTarget = new (CTNReachCheckTarget)(&(this->m_executor.m_id));
		if (pReachCheckTarget == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		hr = this->m_reachchecktargets.Add(pReachCheckTarget);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add reach check target %x to list!",
				1, pReachCheckTarget);

			delete (pReachCheckTarget);
			pReachCheckTarget = NULL;

			goto DONE;
		} // end if (couldn't add target)
	} // end if (couldn't find target)


	// If it's actually a cancel for a previous accept, look for the ID and stop
	// accepting with that ID.
	if (pAcceptReachCheckMsg->dwMethod == TNRCM_CANCEL)
	{
		pReachCheck = pReachCheckTarget->m_checks.GetCheck(pAcceptReachCheckMsg->dwID);
		if (pReachCheck == NULL)
		{
			DPL(0, "Couldn't find reach check with ID %u!",
				1, pAcceptReachCheckMsg->dwID);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't find reach check)

		pReachCheck->m_dwRefCount++; // we've got it

		hr = pReachCheckTarget->m_checks.RemoveFirstReference(pReachCheck);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't remove check %x from list!", 1, pReachCheck);
			goto DONE;
		} // end if (couldn't remove check from list)

		switch (pReachCheck->m_dwMethod)
		{
			case TNRCM_UDPBROADCAST:
			case TNRCM_UDP:
			case TNRCM_TCP:
				hr = pReachCheck->m_pCtrlComm->StopAcceptingReachCheck(pReachCheck);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't stop accepting TCP/IP reach check %u!",
						1, pReachCheck->m_dwID);
					goto DONE;
				} // end if (couldn't start accepting reach check)
			  break;

			case TNRCM_IPX:
			case TNRCM_MODEM:
			case TNRCM_SERIAL:
#pragma TODO(vanceo, "Implement checking for these 3 SPs")
			  break;

			default:
				DPL(0, "Unrecognized reach check method %u!",
					1, pReachCheck->m_dwMethod);
				hr = E_FAIL;
				goto DONE;
			  break;
		} // end switch (on the type of method)

		goto DONE;
	} // end if (cancelling an accept)


	// Otherwise, it's a new accept.  Create a corresponding reach check
	// object.

	pReachCheck = new (CTNReachCheck)(pAcceptReachCheckMsg->dwID,
									pAcceptReachCheckMsg->dwMethod,
									((pAcceptReachCheckMsg->dwMethodDataSize > 0) ? (pAcceptReachCheckMsg + 1) : NULL),
									pAcceptReachCheckMsg->dwMethodDataSize);
	if (pReachCheck == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	pReachCheck->m_dwRefCount++; // we've got it


	switch (pAcceptReachCheckMsg->dwMethod)
	{
		case TNRCM_UDPBROADCAST:
		case TNRCM_UDP:
		case TNRCM_TCP:
			if ((this->m_pCtrlComm->m_dwMethodID == TN_CTRLMETHOD_TCPIP_OPTIMAL) ||
				(this->m_pCtrlComm->m_dwMethodID == TN_CTRLMETHOD_TCPIP_WINSOCK1) ||
				(this->m_pCtrlComm->m_dwMethodID == TN_CTRLMETHOD_TCPIP_WINSOCK2_ONETOONE))
			{
				this->m_pCtrlComm->m_dwRefCount++;
				pReachCheck->m_pCtrlComm = this->m_pCtrlComm;
			} // end if (using TCP/IP control comm method)
			else
			{
				DPL(0, "Using control comm methods other than TCP/IP is not implemented!  DEBUGBREAK()-ing.", 0);

				DEBUGBREAK();

				hr = E_NOTIMPL;
			} // end else (not using TCP/IP control comm method)

			hr = pReachCheck->m_pCtrlComm->StartAcceptingReachCheck(pReachCheck);
			if (hr != S_OK)
			{
				DPL(0, "WARNING: Couldn't start accepting TCP/IP reach check ID %u!",
					1, pReachCheck->m_dwID);

				this->Log(TNLST_CRITICAL,
						"WARNING: Couldn't start accepting TCP/IP reach check!", 0);

				hrReplyResult = hr;
				hr = S_OK;
			} // end if (couldn't start accepting reach check)
			else
			{
				fReplySuccess = TRUE;
				hrReplyResult = S_OK;

				// Add the check to our self-target list.
				hr = pReachCheckTarget->m_checks.Add(pReachCheck);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't add reach check %x to self-target list (%x)!",
						2, pReachCheck, pReachCheckTarget);
					goto DONE;
				} // end if (couldn't add check to list)
			} // end else (did start accepting reach check)
		  break;

		case TNRCM_IPX:
		case TNRCM_MODEM:
		case TNRCM_SERIAL:
#pragma TODO(vanceo, "Implement checking for these 3 SPs")

			fReplySuccess = TRUE;
			hrReplyResult = S_OK;

			// Add the check to our self-target list.
			hr = pReachCheckTarget->m_checks.Add(pReachCheck);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add reach check %x to self-target list (%x)!",
					2, pReachCheck, pReachCheckTarget);
				goto DONE;
			} // end if (couldn't add check to list)
		  break;

		default:
			DPL(0, "Unrecognized reach check method %u!",
				1, pAcceptReachCheckMsg->dwMethod);
			hr = E_FAIL;
			goto DONE;
		  break;
	} // end switch (on the type of method)



	// Send the ready response.

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_ACCEPTREACHCHECKREPLY);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pReplyMsg = (PCTRLMSG_ACCEPTREACHCHECKREPLY) pSendData->m_pvData;
	pReplyMsg->dwSize = pSendData->m_dwDataSize;
	pReplyMsg->dwType = CTRLMSGID_ACCEPTREACHCHECKREPLY;

	CopyMemory(&(pReplyMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pReplyMsg->dwID = pReachCheck->m_dwID;
	pReplyMsg->fReady = fReplySuccess;
	pReplyMsg->hresult = hrReplyResult;


	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send object)

	if (pReachCheck != NULL)
	{
		pReachCheck->m_dwRefCount--;
		if (pReachCheck->m_dwRefCount == 0)
		{
			DPL(7, "Deleting reach check %x.", 1, pReachCheck);
			delete (pReachCheck);
		} // end if (can delete item)
		else
		{
			DPL(7, "Not deleting reach check %x, it's refcount is %u.",
				2, pReachCheck, pReachCheck->m_dwRefCount);
		} // end else (can't delete item)
		pReachCheck = NULL;
	} // end if (have object)

	return (hr);
} // CTNSlave::HandleAcceptReachCheckMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleConnectReachCheckMsg()"
//==================================================================================
// CTNSlave::HandleConnectReachCheckMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session accept reach check message.
//
// Arguments:
//	PVOID* ppvFromAddress								Pointer to pointer to data
//														describing ctrl comm from
//														address.
//	DWORD dwFromAddressSize								Size of from address data.
//	PCTRLMSG_CONNECTREACHCHECK pConnectReachCheckMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleConnectReachCheckMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_CONNECTREACHCHECK pConnectReachCheckMsg)
{
	HRESULT					hr = S_OK;
	PREACHCHECKCONTEXT		pRCContext = NULL;
	PTNREACHCHECKTARGET		pReachCheckTarget = NULL;
	PTNREACHCHECK			pPreviousReachCheck = NULL;
	BOOL					fStartSending = FALSE;
	LPBYTE					lpCurrent;
	PVOID					pvMethodData = NULL;
	PVOID					pvAddresses = NULL;
	BOOL					fGuaranteed = FALSE;
	PVOID					pvFirstAddressToUse = NULL;
	DWORD					dwFirstAddressToUseSize = 0;
	DWORD					dwTimeout = 0;
	DWORD					dwInterval = 0;
	BOOL					fReplySuccess = FALSE;
	HRESULT					hrReplyResult = E_FAIL;
	DWORD					dwTemp;
	int						i;

	

	DPL(1, "Got ConnectReachCheck message (method %u, ID %u).",
		2, pConnectReachCheckMsg->dwMethod, pConnectReachCheckMsg->dwID);

	pRCContext = (PREACHCHECKCONTEXT) LocalAlloc(LPTR, sizeof (REACHCHECKCONTEXT));
	if (pRCContext == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pRCContext->dwType = PSCT_REACHCHECK;



	lpCurrent = (LPBYTE) (pConnectReachCheckMsg + 1);

	if (pConnectReachCheckMsg->dwMethodDataSize != 0)
	{
		pvMethodData = lpCurrent;
		lpCurrent += pConnectReachCheckMsg->dwMethodDataSize;
	} // end if (there's method data)

	if (pConnectReachCheckMsg->dwAddressesSize != 0)
	{
		pvAddresses = lpCurrent;
		//lpCurrent += pConnectReachCheckMsg->dwAddressesSize;
	} // end if (there's method data)


	// Create a new corresponding reach check object.

	pRCContext->pReachCheck = new (CTNReachCheck)(pConnectReachCheckMsg->dwID,
												pConnectReachCheckMsg->dwMethod,
												pvMethodData,
												pConnectReachCheckMsg->dwMethodDataSize);
	if (pRCContext->pReachCheck == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	// We're using it (may become the context's reference)
	pRCContext->pReachCheck->m_dwRefCount++;


	// Get the target for that slave if it exists, or create one otherwise.
	pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(pConnectReachCheckMsg->idTarget));
	if (pReachCheckTarget == NULL)
	{
		pReachCheckTarget = new (CTNReachCheckTarget)(&(pConnectReachCheckMsg->idTarget));
		if (pReachCheckTarget == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		hr = this->m_reachchecktargets.Add(pReachCheckTarget);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't add reach check target %x to list!",
				1, pReachCheckTarget);

			delete (pReachCheckTarget);
			pReachCheckTarget = NULL;

			goto DONE;
		} // end if (couldn't add target)
	} // end if (couldn't find target)


	// Add the check to the target's list.
	hr = pReachCheckTarget->m_checks.Add(pRCContext->pReachCheck);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add reach check %x to target %x's list!",
			2, pRCContext->pReachCheck, pReachCheckTarget);
		goto DONE;
	} // end if (couldn't add check to list)


	// If the target is actually on a machine which has multiple slave instances in
	// the same session, and we've already tried this reach check on another
	// instance, the master will send the ID of the machine so we can just copy the
	// result from the earlier attempt.
	// Otherwise, prepare to connect.
	if (IsZero(&(pConnectReachCheckMsg->idPreviousTarget), sizeof (TNCTRLMACHINEID)))
	{
		switch (pConnectReachCheckMsg->dwMethod)
		{
			case TNRCM_UDPBROADCAST:
			case TNRCM_UDP:
			case TNRCM_TCP:
				if ((this->m_pCtrlComm->m_dwMethodID == TN_CTRLMETHOD_TCPIP_OPTIMAL) ||
					(this->m_pCtrlComm->m_dwMethodID == TN_CTRLMETHOD_TCPIP_WINSOCK1) ||
					(this->m_pCtrlComm->m_dwMethodID == TN_CTRLMETHOD_TCPIP_WINSOCK2_ONETOONE))
				{
					this->m_pCtrlComm->m_dwRefCount++;
					pRCContext->pReachCheck->m_pCtrlComm = this->m_pCtrlComm;
				} // end if (using TCP/IP control comm method)
				else
				{
					DPL(0, "Using control comm methods other than TCP/IP is not implemented!  DEBUGBREAK()-ing.", 0);

					DEBUGBREAK();

					hr = E_NOTIMPL;
				} // end else (not using TCP/IP control comm method)


				if (pConnectReachCheckMsg->dwMethod == TNRCM_TCP)
				{
					fGuaranteed = TRUE;
					dwInterval = 0; // don't retry
					dwTimeout = 45000; // 45 second timeout
				} // end if (TCP)
				else
				{
					dwInterval = 4000; // send every 4 seconds
					dwTimeout = 24000; // 24 second timeout total (~ 6 attempts)
				} // end else (not TCP)

				if (pConnectReachCheckMsg->dwMethod == TNRCM_UDPBROADCAST)
				{
#ifdef DEBUG
				if (pvAddresses != NULL)
				{
					DPL(0, "Address exist for UDP broadcast?!?  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
				} // end if (there are addresses)
#endif // DEBUG


					// Ignore error, assume BUFFER_TOO_SMALL
					pRCContext->pReachCheck->m_pCtrlComm->GetBroadcastAddress(pvMethodData,
																			pConnectReachCheckMsg->dwMethodDataSize,
																			NULL,
																			&dwFirstAddressToUseSize);

					pvFirstAddressToUse = LocalAlloc(LPTR, dwFirstAddressToUseSize);
					if (pvFirstAddressToUse == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto DONE;
					} // end if (couldn't allocate memory)

					hr = pRCContext->pReachCheck->m_pCtrlComm->GetBroadcastAddress(pvMethodData,
																					pConnectReachCheckMsg->dwMethodDataSize,
																					pvFirstAddressToUse,
																					&dwFirstAddressToUseSize);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't get broadcast address!", 0);
						goto DONE;
					} // end if (couldn't add check to list)
				} // end if (UDP broadcast)
				else
				{
					CTNIPAddressesList		ipaddrs;



					// Convert the list of IP addresses the master gave us into
					// IP strings.

					hr = ipaddrs.UnpackFromBuffer(pvAddresses,
												pConnectReachCheckMsg->dwAddressesSize);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't unpack IP addresses list from buffer!", 0);
						goto DONE;
					} // end if (couldn't unpack list)


					pRCContext->dwTotalAddressStrings = ipaddrs.Count();

					// Allocate a buffer large enough to hold that many 15 character
					// (+ NULL termination) IP strings.
					pRCContext->pszAddressStrings = (char*) LocalAlloc(LPTR, (pRCContext->dwTotalAddressStrings * 16));
					if (pRCContext->pszAddressStrings == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto DONE;
					} // end if (couldn't allocate memory)


					for(dwTemp = 0; dwTemp < pRCContext->dwTotalAddressStrings; dwTemp++)
					{
						// Convert the first remaining IP address into a string in
						// that buffer.
						hr = ipaddrs.GetIPString(0, pRCContext->pszAddressStrings + (dwTemp * 16));
						if (hr != S_OK)
						{
							DPL(0, "Couldn't get string for first remaining IP address from list!", 0);
							goto DONE;
						} // end if (couldn't get IP string)

						// Remove the IP address object
						hr = ipaddrs.Remove(0);
						if (hr != S_OK)
						{
							DPL(0, "Couldn't remove first remaining IP address from list!", 0);
							goto DONE;
						} // end if (couldn't remove item)
					} // end for (each IP address)


					// Now convert the first address in the buffer for use in
					// kicking off the periodic sends.
					
					// Ignore error, assume BUFFER_TOO_SMALL
					pRCContext->pReachCheck->m_pCtrlComm->ConvertStringToAddress(pRCContext->pszAddressStrings,
																				pvMethodData,
																				pConnectReachCheckMsg->dwMethodDataSize,
																				NULL,
																				&dwFirstAddressToUseSize);

					pvFirstAddressToUse = LocalAlloc(LPTR, dwFirstAddressToUseSize);
					if (pvFirstAddressToUse == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto DONE;
					} // end if (couldn't allocate memory)

					hr = pRCContext->pReachCheck->m_pCtrlComm->ConvertStringToAddress(pRCContext->pszAddressStrings,
																					pvMethodData,
																					pConnectReachCheckMsg->dwMethodDataSize,
																					pvFirstAddressToUse,
																					&dwFirstAddressToUseSize);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't convert IP string \"%s\" to address!",
							1, pRCContext->pszAddressStrings);
						goto DONE;
					} // end if (couldn't add check to list)

					// We've used one address, so note that.
					pRCContext->dwCurrentAddressString++;


					DPL(1, "Trying address string 1 of %u (\"%s\").",
						2, pRCContext->dwTotalAddressStrings,
						pRCContext->pszAddressStrings);
				} // end else (not UDP broadcast)


				// Let the control comm object prepare.
				hr = pRCContext->pReachCheck->m_pCtrlComm->PrepareToReachCheck(pRCContext->pReachCheck);
				if (hr != S_OK)
				{
					DPL(0, "WARNING: Couldn't have control comm object prepare to reach check (ID %u)!",
						1, pRCContext->pReachCheck->m_dwID);

					this->Log(TNLST_CRITICAL,
							"WARNING: Couldn't have control comm object prepare to reach check!", 0);

					fReplySuccess = FALSE;
					hrReplyResult = hr;
					hr = S_OK;


					// Since we couldn't have the control comm object start the reach
					// check, no point in keeping the object around.  Plus, if it still
					// exists when we go to complete this reach check below, the code
					// assumes that if it exists it was started up successfully.
					pRCContext->pReachCheck->m_pCtrlComm->m_dwRefCount--;
					if (pRCContext->pReachCheck->m_pCtrlComm->m_dwRefCount == 0)
					{
						DPL(7, "Deleting control comm object %x.",
							1, pRCContext->pReachCheck->m_pCtrlComm);
						delete (pRCContext->pReachCheck->m_pCtrlComm);
					} // end if (last reference)
					else
					{
						DPL(7, "Not deleting control comm object %x, its refcount is %u.",
							2, pRCContext->pReachCheck->m_pCtrlComm,
							pRCContext->pReachCheck->m_pCtrlComm->m_dwRefCount);
					} // end else (not last reference)

					pRCContext->pReachCheck->m_pCtrlComm = NULL;
				} // end if (couldn't prepare)
				else
				{
					fStartSending = TRUE;
				} // end else (could prepare)
			  break;

			case TNRCM_IPX:
#pragma TODO(vanceo, "Implement checking for these 3 SPs")

				// IPX doesn't need an address. We're good.

				fReplySuccess = TRUE;
				hrReplyResult = E_NOTIMPL;

				// pvFirstAddressToUse == NULL
			  break;

			case TNRCM_MODEM:
				// There should be a phone number as the only address.  Copy it and
				// use it without question.

				fReplySuccess = TRUE;
				hrReplyResult = E_NOTIMPL;


				dwFirstAddressToUseSize = pConnectReachCheckMsg->dwAddressesSize;

				pvFirstAddressToUse = LocalAlloc(LPTR, dwFirstAddressToUseSize);
				if (pvFirstAddressToUse == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				CopyMemory(pvFirstAddressToUse, pvAddresses, dwFirstAddressToUseSize);
			  break;

			case TNRCM_SERIAL:
				// There should be a COM port as the only address.  Copy it and
				// use it without question.

				fReplySuccess = TRUE;
				hrReplyResult = E_NOTIMPL;


				dwFirstAddressToUseSize = pConnectReachCheckMsg->dwAddressesSize;

				pvFirstAddressToUse = LocalAlloc(LPTR, dwFirstAddressToUseSize);
				if (pvFirstAddressToUse == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				CopyMemory(pvFirstAddressToUse, pvAddresses, dwFirstAddressToUseSize);
			  break;

			default:
				DPL(0, "Unrecognized reach check method %u!",
					1, pConnectReachCheckMsg->dwMethod);
				hr = E_FAIL;
				goto DONE;
			  break;
		} // end switch (on the type of method)
	} // end if (didn't already check machine)
	else
	{
		// Find the result the master referred to.
		pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(pConnectReachCheckMsg->idPreviousTarget));
		if (pReachCheckTarget == NULL)
		{
			DPL(0, "Couldn't find reach check target master said we previously contacted (%u)!",
				1, pConnectReachCheckMsg->idPreviousTarget.dwTime);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't find target)


		// Set these in case we don't find the right info.  They'll get overwritten
		// if we get what we need.
		fReplySuccess = FALSE;
		hrReplyResult = E_FAIL;


		for(i = 0; i < pReachCheckTarget->m_checks.Count(); i++)
		{
			pPreviousReachCheck = (PTNREACHCHECK) pReachCheckTarget->m_checks.GetItem(i);
			if (pPreviousReachCheck == NULL)
			{
				DPL(0, "Couldn't get reach check %i!", 1, i);
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get item)


			if ((pPreviousReachCheck->m_dwMethod == pConnectReachCheckMsg->dwMethod) &&
				(pPreviousReachCheck->m_dwMethodDataSize == pConnectReachCheckMsg->dwMethodDataSize) &&
				((pPreviousReachCheck->m_dwMethodDataSize == 0) || (memcmp(pPreviousReachCheck->m_pvMethodData, pvMethodData, pConnectReachCheckMsg->dwMethodDataSize) == 0)))
			{
				if (pPreviousReachCheck->m_fResult)
				{
					DPL(3, "Found a successful reach check to another slave instance (target ID = %u, previous target ID = %u).",
						2, pConnectReachCheckMsg->idTarget.dwTime,
						pConnectReachCheckMsg->idPreviousTarget.dwTime);
				} // end if (check succeeded)
				else
				{
					DPL(3, "Found an unsuccessful reach check to another slave instance (target ID = %u, previous target ID = %u).",
						2, pConnectReachCheckMsg->idTarget.dwTime,
						pConnectReachCheckMsg->idPreviousTarget.dwTime);
				} // end else (check failed)


				// Alright, we're good to go.
				fReplySuccess = pPreviousReachCheck->m_fResult;
				hrReplyResult = ERROR_ALREADY_EXISTS;


				// Copy the info.
				dwFirstAddressToUseSize = pPreviousReachCheck->m_dwAddressSize;

				pvFirstAddressToUse = LocalAlloc(LPTR, dwFirstAddressToUseSize);
				if (pvFirstAddressToUse == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				CopyMemory(pvFirstAddressToUse, pPreviousReachCheck->m_pvAddress,
							dwFirstAddressToUseSize);

				// Stop searching.
				break;
			} // end if (found reach check)
		} // end for (each reach check)
	} // end else (already checked another instance)


	// If we should kick off the reach checking, do it, otherwise send the
	// reply.
	if (fStartSending)
	{
		PCTRLMSG_INTERSLAVEREACHCHECK	pInterSlaveReachCheckMsg;
		DWORD							dwMsgSize;



		dwMsgSize = sizeof (CTRLMSG_INTERSLAVEREACHCHECK)
					+ dwFirstAddressToUseSize;

		pInterSlaveReachCheckMsg = (PCTRLMSG_INTERSLAVEREACHCHECK) LocalAlloc(LPTR, dwMsgSize);
		if (pInterSlaveReachCheckMsg == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		pInterSlaveReachCheckMsg->dwSize = dwMsgSize;
		pInterSlaveReachCheckMsg->dwType = CTRLMSGID_INTERSLAVEREACHCHECK;
		CopyMemory(&(pInterSlaveReachCheckMsg->id),
					&(this->m_executor.m_id),
					sizeof (TNCTRLMACHINEID));
		pInterSlaveReachCheckMsg->dwID = pConnectReachCheckMsg->dwID;
		pInterSlaveReachCheckMsg->fGuaranteed = fGuaranteed;
		pInterSlaveReachCheckMsg->dwUsedAddressSize = dwFirstAddressToUseSize;

		CopyMemory((pInterSlaveReachCheckMsg + 1), pvFirstAddressToUse,
					dwFirstAddressToUseSize);


		hr = this->StartPeriodicSend(pRCContext->pReachCheck->m_pCtrlComm,
									fGuaranteed,
									pvFirstAddressToUse,
									dwFirstAddressToUseSize,
									pInterSlaveReachCheckMsg,
									dwMsgSize,
									dwInterval,
									dwTimeout,
									pRCContext,
									&(pRCContext->pReachCheck->m_pPeriodicSend));

		LocalFree(pInterSlaveReachCheckMsg);
		pInterSlaveReachCheckMsg = NULL;

		if (hr != S_OK)
		{
			DPL(0, "Couldn't start periodic send!", 0);
			goto DONE;
		} // end if (couldn't start send)

		pRCContext = NULL; // forget about it so we don't free it below
	} // end if (ctrl comm object to use)
	else
	{
		hr = this->DoConnectReachCheckResult(pRCContext->pReachCheck,
											fReplySuccess,
											hrReplyResult,
											pvFirstAddressToUse,
											dwFirstAddressToUseSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't do connect reach check result!", 0);
			goto DONE;
		} // end if (couldn't handle result)
	} // end else (no ctrl comm object to use)
	

DONE:

	if (pvFirstAddressToUse != NULL)
	{
		LocalFree(pvFirstAddressToUse);
		pvFirstAddressToUse = NULL;
	} // end if (have address)

	if (pRCContext != NULL)
	{
		if (pRCContext->pszAddressStrings != NULL)
		{
			LocalFree(pRCContext->pszAddressStrings);
			pRCContext->pszAddressStrings = NULL;
		} // end if (have string)

		if (pRCContext->pReachCheck != NULL)
		{
			pRCContext->pReachCheck->m_dwRefCount--;
			if (pRCContext->pReachCheck->m_dwRefCount == 0)
			{
				DPL(7, "Deleting reach check %x.", 1, pRCContext->pReachCheck);
				delete (pRCContext->pReachCheck);
			} // end if (can delete item)
			else
			{
				DPL(7, "Not deleting reach check %x, it's refcount is %u.",
					2, pRCContext->pReachCheck,
					pRCContext->pReachCheck->m_dwRefCount);
			} // end else (can't delete item)
			pRCContext->pReachCheck = NULL;
		} // end if (have object)

		LocalFree(pRCContext);
		pRCContext = NULL;
	} // end if (still have context)

	return (hr);
} // CTNSlave::HandleConnectReachCheckMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleInterSlaveReachCheckMsg()"
//==================================================================================
// CTNSlave::HandleInterSlaveReachCheckMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session inter-slave reach check message.
//
// Arguments:
//	PVOID* ppvFromAddress									Pointer to pointer to
//															data describing ctrl
//															comm from address.
//	DWORD dwFromAddressSize									Size of from address
//															data.
//	PCTRLMSG_INTERSLAVEREACHCHECK pInterSlaveReachCheckMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleInterSlaveReachCheckMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
												PCTRLMSG_INTERSLAVEREACHCHECK pInterSlaveReachCheckMsg)
{
	HRESULT								hr;
	PTNREACHCHECKTARGET					pReachCheckTarget;
	PTNREACHCHECK						pReachCheck = NULL;
	PTNSENDDATA							pSendData = NULL;
	PCTRLMSG_INTERSLAVEREACHCHECKREPLY	pReplyMsg;


	if (memcmp(&(pInterSlaveReachCheckMsg->id), &(this->m_executor.m_id), sizeof (TNCTRLMACHINEID)) == 0)
	{
		DPL(1, "Ignoring InterSlaveReachCheck message from ourselves (must be a broadcast).", 0);
		hr = S_OK;
		goto DONE;
	} // end if (it's our own ID)


	DPL(1, "Got InterSlaveReachCheck message from slave ID %u, reach check %u.",
		2, pInterSlaveReachCheckMsg->id.dwTime, pInterSlaveReachCheckMsg->dwID);


	pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(this->m_executor.m_id));
	if (pReachCheckTarget == NULL)
	{
		DPL(0, "Couldn't find self target reach checks list!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't find reach check)

	pReachCheck = pReachCheckTarget->m_checks.GetCheck(pInterSlaveReachCheckMsg->dwID);
	if (pReachCheck == NULL)
	{
		DPL(0, "Couldn't find self target reach check with ID %u!  Ignoring.",
			1, pInterSlaveReachCheckMsg->dwID);
		hr = S_OK;
		goto DONE;
	} // end if (couldn't find reach check)

	pReachCheck->m_dwRefCount++; // we've got it




	// Send the response.

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	// Send it back the way it came in.
	pSendData->m_fGuaranteed = pInterSlaveReachCheckMsg->fGuaranteed;
	pSendData->m_dwAddressSize = dwFromAddressSize;

	// We can't just use it directly because we use the pointer later.  We have
	// to make a copy.
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	CopyMemory(pSendData->m_pvAddress, (*ppvFromAddress), pSendData->m_dwAddressSize);


	pSendData->m_dwDataSize = sizeof (CTRLMSG_INTERSLAVEREACHCHECKREPLY)
							+ pInterSlaveReachCheckMsg->dwUsedAddressSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pReplyMsg = (PCTRLMSG_INTERSLAVEREACHCHECKREPLY) pSendData->m_pvData;
	pReplyMsg->dwSize = pSendData->m_dwDataSize;
	pReplyMsg->dwType = CTRLMSGID_INTERSLAVEREACHCHECKREPLY;

	CopyMemory(&(pReplyMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pReplyMsg->dwID = pReachCheck->m_dwID;
	pReplyMsg->dwUsedAddressSize = pInterSlaveReachCheckMsg->dwUsedAddressSize;

	if (pInterSlaveReachCheckMsg->dwUsedAddressSize > 0)
	{
		CopyMemory((pReplyMsg + 1), (pInterSlaveReachCheckMsg + 1),
					pInterSlaveReachCheckMsg->dwUsedAddressSize);
	} // end if (there's a used address)


	hr = pReachCheck->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to reach check's send queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below



	// Make sure that message has gotten out.
	hr = pReachCheck->m_pCtrlComm->FlushSendQueue();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't flush the reach check's control comm object's send queue!", 0);
		goto DONE;
	} // end if (failed to flush send queue)


	// If it's a guaranteed message, disconnect from the sender, because we don't
	// need this connection anymore.  Control comm objects are spec'ed to treat an
	// Unbind call on an address that isn't bound yet as a disconnect.
	if (pInterSlaveReachCheckMsg->fGuaranteed)
	{
		COMMDATA	cd;


		ZeroMemory(&cd, sizeof (COMMDATA));
		// We don't NULL it out, because it's not saved anywhere by this function
		// or UnbindDataFromAddress.  We'll let our caller free it.
		cd.pvAddress = (*ppvFromAddress);
		cd.dwAddressSize = dwFromAddressSize;


		hr = pReachCheck->m_pCtrlComm->UnbindDataFromAddress(&cd);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't disconnect from slave!", 0);
			goto DONE;
		} // end if (couldn't disconnect slave)
	} // end if (it's a guaranteed message)


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send object)

	if (pReachCheck != NULL)
	{
		pReachCheck->m_dwRefCount--;
		if (pReachCheck->m_dwRefCount == 0)
		{
			DPL(7, "Deleting reach check %x.", 1, pReachCheck);
			delete (pReachCheck);
		} // end if (can delete item)
		else
		{
			DPL(7, "Not deleting reach check %x, it's refcount is %u.",
				2, pReachCheck, pReachCheck->m_dwRefCount);
		} // end else (can't delete item)
		pReachCheck = NULL;
	} // end if (have object)

	return (hr);
} // CTNSlave::HandleInterSlaveReachCheckMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleInterSlaveReachCheckReplyMsg()"
//==================================================================================
// CTNSlave::HandleInterSlaveReachCheckReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session inter-slave reach check reply message.
//
// Arguments:
//	PVOID* ppvFromAddress							Pointer to pointer to data
//													describing ctrl comm from
//													address.
//	DWORD dwFromAddressSize							Size of from address data.
//	PCTRLMSG_INTERSLAVEREACHCHECKREPLY pReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleInterSlaveReachCheckReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
													PCTRLMSG_INTERSLAVEREACHCHECKREPLY pReplyMsg)
{
	HRESULT					hr;
	PTNREACHCHECKTARGET		pReachCheckTarget;
	PTNREACHCHECK			pReachCheck = NULL;
	PREACHCHECKCONTEXT		pRCContext;



	DPL(1, "Got InterSlaveReachCheckReply message from slave ID %u, reach check %u.",
		2, pReplyMsg->id.dwTime, pReplyMsg->dwID);


	pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(pReplyMsg->id));
	if (pReachCheckTarget == NULL)
	{
		DPL(0, "Couldn't find target's reach checks list!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't find reach check)

	pReachCheck = pReachCheckTarget->m_checks.GetCheck(pReplyMsg->dwID);
	if (pReachCheck == NULL)
	{
		DPL(0, "Couldn't find target's reach check with ID %u!",
			1, pReplyMsg->dwID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't find reach check)

	pReachCheck->m_dwRefCount++; // we've got it
	

	// If we've already received a reply (or timed out), who cares.
	if (pReachCheck->m_pPeriodicSend == NULL)
	{
		DPL(1, "Already completed reach check %u, ignoring response.",
			1, pReplyMsg->dwID);
		hr = S_OK;
		goto DONE;
	} // end if (already stopped send)


	switch (pReachCheck->m_dwMethod)
	{
		case TNRCM_UDPBROADCAST:
		case TNRCM_UDP:
		case TNRCM_TCP:
			// The address we sent to should have been of type SOCKADDR_IN.

#ifdef DEBUG
			if (pReplyMsg->dwUsedAddressSize != sizeof (SOCKADDR_IN))
			{
				DPL(0, "Reply message used address is not expected size (%u != %u)!",
					2, pReplyMsg->dwUsedAddressSize, sizeof (SOCKADDR_IN));
				hr = E_FAIL;
				goto DONE;
			} // end if (invalid reply)
#endif // DEBUG


			DPL(1, "Got a response for reach check %u after sending to %o.",
				2, pReachCheck->m_dwID, (SOCKADDR_IN*) (pReplyMsg + 1));
			

#pragma BUGBUG(vanceo, "Need locking mechanism, not thread safe")

			// Stop the periodic send that was going.
			hr = this->StopPeriodicSend(pReachCheck->m_pPeriodicSend);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't stop periodic send %x!",
					1, pReachCheck->m_pPeriodicSend);
				goto DONE;
			} // end if (couldn't stop periodic send)


			// Clean up the periodic send context.

			pRCContext = (PREACHCHECKCONTEXT) pReachCheck->m_pPeriodicSend->m_pvUserContext;
			pReachCheck->m_pPeriodicSend->m_pvUserContext = NULL;


			pRCContext->pReachCheck->m_dwRefCount--;
			if (pRCContext->pReachCheck->m_dwRefCount == 0)
			{
				DPL(0, "Deleting reach check %x!?  DEBUGBREAK()-ing.",
					1, pRCContext->pReachCheck);

				DEBUGBREAK();

				delete (pRCContext->pReachCheck);
			} // end if (can delete item)
			pRCContext->pReachCheck = NULL;

			LocalFree(pRCContext->pszAddressStrings);
			pRCContext->pszAddressStrings = NULL;

			LocalFree(pRCContext);
			pRCContext = NULL;


			// Complete the result.
			hr = this->DoConnectReachCheckResult(pReachCheck,
												TRUE,
												S_OK,
												&(((SOCKADDR_IN*) (pReplyMsg + 1))->sin_addr),
												sizeof (IN_ADDR));
			if (hr != S_OK)
			{
				DPL(0, "Couldn't send ConnectReachCheckReply message!", 0);
				//goto DONE;
			} // end if (couldn't send message)
		  break;

		case TNRCM_IPX:
		case TNRCM_MODEM:
		case TNRCM_SERIAL:
		default:
			DPL(0, "Unhandled reach check mode (%u)!  DEBUGBREAK()-ing.",
				1, pReachCheck->m_dwMethod);

			DEBUGBREAK();

			hr = E_FAIL;
			goto DONE;
		  break;
	} // end switch (on method)


DONE:

	if (pReachCheck != NULL)
	{
		pReachCheck->m_dwRefCount--;
		if (pReachCheck->m_dwRefCount == 0)
		{
			DPL(7, "Deleting reach check %x.", 1, pReachCheck);
			delete (pReachCheck);
		} // end if (can delete item)
		else
		{
			DPL(7, "Not deleting reach check %x, it's refcount is %u.",
				2, pReachCheck, pReachCheck->m_dwRefCount);
		} // end else (can't delete item)
		pReachCheck = NULL;
	} // end if (have object)

	
	
	return (hr);
} // CTNSlave::HandleInterSlaveReachCheckReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleGetMachineInfoReplyMsg()"
//==================================================================================
// CTNSlave::HandleGetMachineInfoReplyMsg
//----------------------------------------------------------------------------------
//
// Description: Handles a control session GetMachineInfo reply message.
//
// Arguments:
//	PVOID* ppvFromAddress					Pointer to pointer to data describing
//											ctrl comm from address.
//	DWORD dwFromAddressSize					Size of from address data.
//	PCTRLMSG_GETMACHINEINFOREPLY pReplyMsg	The message received.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleGetMachineInfoReplyMsg(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
											PCTRLMSG_GETMACHINEINFOREPLY pReplyMsg)
{
	HRESULT		hr;


	//DPL(1, "Got GetMachineInfo message.", 0);

	if (! this->m_fInSession)
	{
		DPL(0, "Not in session.  Ignoring.", 0);
		return (S_OK);
	} // end if (we're not in a session already)

	// BUGBUG compare lpJoinReplyMsg->moduleID or something similar


	// We've gotten something from the master, update our time.
	this->m_dwLastMasterReceive = GetTickCount();


	hr = this->m_executor.HandleGetMachineInfoResponse(pReplyMsg->dwResponseID,
													((pReplyMsg->dwMachineInfoSize > 0) ? (pReplyMsg + 1) : NULL),
													pReplyMsg->dwMachineInfoSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't handle GetMachineInfo response!", 0);
		// return (hr);
	} // end if (couldn't have executor handle response)

	return (hr);
} // CTNSlave::HandleGetMachineInfoReplyMsg
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::RegisterWithOtherLocalSlaves()"
//==================================================================================
// CTNSlave::RegisterWithOtherLocalSlaves
//----------------------------------------------------------------------------------
//
// Description: Uses a shared memory space to notify any other slaves already
//				running on this machine.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::RegisterWithOtherLocalSlaves(void)
{
#ifndef _XBOX // only one local slave allowed

	HRESULT					hr;
	int						i;
	PMULTIINSTANCEMMFILE	pMultiInstanceInfo = NULL;


	// Create the mutex, or open it if it already exists.
	this->m_hMultiInstanceMutex = CreateMutex(NULL, FALSE, TNSLAVE_MULTIINSTANCEDETECT_MUTEX);
	if (this->m_hMultiInstanceMutex == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create mutex \"%s\"!", 1, TNSLAVE_MULTIINSTANCEDETECT_MUTEX);
		goto ERROR_EXIT;
	} // end if (couldn't create mutex)

	// Grab the lock
	WaitForSingleObject(this->m_hMultiInstanceMutex, INFINITE);


	// Grab and map the actual file.

	this->m_hMultiInstanceMMFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,
													PAGE_READWRITE, 0,
													sizeof (MULTIINSTANCEMMFILE),
													TNSLAVE_MULTIINSTANCEDETECT_MMFILE);
	if (this->m_hMultiInstanceMMFile == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't create file mapping \"%s\"!",
			1, TNSLAVE_MULTIINSTANCEDETECT_MMFILE);
		goto ERROR_EXIT;
	} // end if (couldn't create file mapping)


	pMultiInstanceInfo = (PMULTIINSTANCEMMFILE) MapViewOfFile(this->m_hMultiInstanceMMFile,
															FILE_MAP_ALL_ACCESS,
															0, 0, 0);
	if (pMultiInstanceInfo == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't map view of file!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't map view of file)


	if (pMultiInstanceInfo->iNumInstances >= MAX_NUM_LOCAL_INSTANCES)
	{
		DPL(0, "Can't start another TestNet slave on this machine, there are already %i existing instances!",
			1, pMultiInstanceInfo->iNumInstances);

		hr = ERROR_TOO_MANY_OPEN_FILES;

		goto ERROR_EXIT;
	} // end if (too many instances)


	pMultiInstanceInfo->iNumInstances++;

	// Search through all the available slots to find the first one open.
	for(i = 0; i < MAX_NUM_LOCAL_INSTANCES; i++)
	{
		if (! pMultiInstanceInfo->aInstances[i].fInUse)
		{
			pMultiInstanceInfo->aInstances[i].fInUse = TRUE; // it's in use now
			this->m_iInstanceIndex = i;
			break;
		} // end if (this slot is open)
	} // end for (each instance slot)

#ifdef DEBUG
	if (this->m_iInstanceIndex < 0)
	{
		DPL(0, "No slot found in multiinstanceinfo (%x), but there are now %i instances!?  DEBUGBREAK()-ing.",
			2, pMultiInstanceInfo, pMultiInstanceInfo->iNumInstances);

		DEBUGBREAK();
	} // end if (no slot found)
#endif // DEBUG


	// If we're the first instance, we get to decide the special uniqueness key for
	// this file.  It will be used by the master to help correlate which slaves are
	// on the same machine.

	if (pMultiInstanceInfo->iNumInstances == 1)
	{
#ifdef DEBUG
		if (this->m_iInstanceIndex != 0)
		{
			DPL(0, "Only current instance, but slot found for multiinstanceinfo (%x) is not the first one!?  DEBUGBREAK()-ing.",
				1, pMultiInstanceInfo);

			DEBUGBREAK();
		} // end if (no slot found)

		if (pMultiInstanceInfo->dwKey != 0)
		{
			DPL(0, "Only current instance, but key is already defined as %u (info = %x)!?  DEBUGBREAK()-ing.",
				2, pMultiInstanceInfo->dwKey, pMultiInstanceInfo);

			DEBUGBREAK();
		} // end if (key already used)
#endif // DEBUG

#ifndef _XBOX // timeGetTime not supported
		pMultiInstanceInfo->dwKey = timeGetTime();
#else // ! XBOX
		pMultiInstanceInfo->dwKey = GetTickCount();
#endif // XBOX

		//HACKHACK Make sure no 2 tries can get the same key (by sleeping for well over
		//		   the timeGetTime resolution).  We need a real uniqueness ID though.
		Sleep(100);
	} // end if (first instance)



	// Unmap our view.
	UnmapViewOfFile(pMultiInstanceInfo);
	pMultiInstanceInfo = NULL;

	// Drop the lock we took.
	ReleaseMutex(this->m_hMultiInstanceMutex);

	return (S_OK);


ERROR_EXIT:

	if (pMultiInstanceInfo != NULL)
	{
		UnmapViewOfFile(pMultiInstanceInfo);
		pMultiInstanceInfo = NULL;
	} // end if (mapped a view)

	if (this->m_hMultiInstanceMMFile != NULL)
	{
		CloseHandle(this->m_hMultiInstanceMMFile);
		this->m_hMultiInstanceMMFile = NULL;
	} // end if (have the file)

	if (this->m_hMultiInstanceMutex != NULL)
	{
		ReleaseMutex(this->m_hMultiInstanceMutex);
		this->m_hMultiInstanceMutex = NULL;
	} // end if (have the mutex)

	return (hr);

#else // ! XBOX
#pragma TODO(tristanj, "Only one local slave allowed, fake the multi-instance key")
	m_dwMultiInstanceKey = GetTickCount();
	return (S_OK);
#endif // XBOX

} // CTNSlave::RegisterWithOtherLocalSlaves
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetMultiInstanceKey()"
//==================================================================================
// CTNSlave::GetMultiInstanceKey
//----------------------------------------------------------------------------------
//
// Description: Retrieves the uniqueness key used for detecting multiple instances
//				of slaves on a single machine.
//
// Arguments:
//	DWORD* pdwKey	Pointer to place to store key being used.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::GetMultiInstanceKey(DWORD* pdwKey)
{
#ifndef _XBOX // only one local slave allowed
	HRESULT					hr = S_OK;
	PMULTIINSTANCEMMFILE	pMultiInstanceInfo = NULL;


	if (this->m_hMultiInstanceMutex == NULL)
	{
		DPL(0, "No mutex!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (no mutex)

	if (this->m_hMultiInstanceMMFile == NULL)
	{
		DPL(0, "No memory mapped file!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (no mm file)


	// Grab the lock
	WaitForSingleObject(this->m_hMultiInstanceMutex, INFINITE);

	// Map the file
	pMultiInstanceInfo = (PMULTIINSTANCEMMFILE) MapViewOfFile(this->m_hMultiInstanceMMFile,
															FILE_MAP_ALL_ACCESS,
															0, 0, 0);
	if (pMultiInstanceInfo == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't map view of file!", 0);
		goto DONE;
	} // end if (couldn't map view of file)

	// Grab the value we want.
	(*pdwKey) = pMultiInstanceInfo->dwKey;


	// Unmap our view.
	UnmapViewOfFile(pMultiInstanceInfo);
	pMultiInstanceInfo = NULL;

	// Drop the lock we took.
	ReleaseMutex(this->m_hMultiInstanceMutex);


DONE:

	return (hr);
#else // ! XBOX
#pragma TODO(tristanj, "Only one local slave allowed, fake the multi-instance key")
	(*pdwKey) = m_dwMultiInstanceKey;
	return (S_OK);
#endif // XBOX
} // CTNSlave::GetMultiInstanceKey
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::UnregisterWithOtherLocalSlaves()"
//==================================================================================
// CTNSlave::UnregisterWithOtherLocalSlaves
//----------------------------------------------------------------------------------
//
// Description: Cleans up the shared memory space used for detecting multiple
//				instances of slaves on a single machine.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::UnregisterWithOtherLocalSlaves(void)
{
#ifndef _XBOX // only one local slave allowed
	HRESULT					hr = S_OK;
	PMULTIINSTANCEMMFILE	pMultiInstanceInfo = NULL;


	if (this->m_hMultiInstanceMutex != NULL)
	{
		if (this->m_hMultiInstanceMMFile != NULL)
		{
			// Grab the lock
			WaitForSingleObject(this->m_hMultiInstanceMutex, INFINITE);


			if (this->m_iInstanceIndex > 0)
			{
				pMultiInstanceInfo = (PMULTIINSTANCEMMFILE) MapViewOfFile(this->m_hMultiInstanceMMFile,
																		FILE_MAP_ALL_ACCESS,
																		0, 0, 0);
				if (pMultiInstanceInfo == NULL)
				{
					hr = GetLastError();
					DPL(0, "Couldn't map view of file!", 0);
				} // end if (couldn't map view of file)
				else
				{
#ifdef DEBUG
					if (! pMultiInstanceInfo->aInstances[this->m_iInstanceIndex].fInUse)
					{
						DPL(0, "Our multiinstanceinfo slot (%i, info = %x) isn't in use!?  DEBUGBREAK()-ing.",
							2, this->m_iInstanceIndex, pMultiInstanceInfo);

						DEBUGBREAK();
					} // end if (no slot found)
#endif // DEBUG

					ZeroMemory(&(pMultiInstanceInfo->aInstances[this->m_iInstanceIndex]),
								sizeof (MULTIINSTANCEITEM));
					/*
					pMultiInstanceInfo->aInstances[this->m_iInstanceIndex].fInUse = FALSE;
					pMultiInstanceInfo->aInstances[this->m_iInstanceIndex].dwSessionID = 0;
					ZeroMemory(&(pMultiInstanceInfo->aInstances[this->m_iInstanceIndex].id),
								sizeof (TNCTRLMACHINEID));
					*/

					this->m_iInstanceIndex = -1;

					pMultiInstanceInfo->iNumInstances--;

					UnmapViewOfFile(pMultiInstanceInfo);
					pMultiInstanceInfo = NULL;
				} // end else (mapped view of file)
			} // end if (we actually registered already)


			CloseHandle(this->m_hMultiInstanceMMFile);
			this->m_hMultiInstanceMMFile = NULL;


			ReleaseMutex(this->m_hMultiInstanceMutex);
		} // end if (have file)

		CloseHandle(this->m_hMultiInstanceMMFile);
		this->m_hMultiInstanceMMFile = NULL;
	} // end if (have mutex)

	return (hr);

#else // ! XBOX
#pragma TODO(tristanj, "Only one local slave allowed")
	return (S_OK);
#endif // XBOX

} // CTNSlave::UnregisterWithOtherLocalSlaves
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no DB logging supported

#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::InitializeDBLogging()"
//==================================================================================
// CTNSlave::InitializeDBLogging
//----------------------------------------------------------------------------------
//
// Description: Starts looking for a control session to join.  This is an
//				asynchronous call, so this function returns E_PENDING if successful,
//				and the caller should wait until the hCompletionOrUpdateEvent
//				(if specified) is set, then call IsInSession() to check whether this
//				succeeded or not.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::InitializeDBLogging(void)
{
	HRESULT					hr;
	HMODULE					hOle32 = NULL;
	LPCOINITIALIZEEXPROC	pfnCoInitializeEx = NULL;
	BOOL					fCOMInitialized = FALSE;
	LPTMSETUP				lpTMSetup = NULL;
	INT_PTR					iMsgBoxResult;


	DPL(0, "Attempting to initialize database logging.", 0);


	// Use CoInitializeEx if available, otherwise CoInitialize.

#pragma BUGBUG(vanceo, "CoInitializeEx is crashing my Win9x machines when CoCreating DNWSOCK")
	//hOle32 = LoadLibrary("ole32.dll");
	if (hOle32 != NULL)
		pfnCoInitializeEx = (LPCOINITIALIZEEXPROC) GetProcAddress(hOle32, "CoInitializeEx");

	// If we couldn't get it, assume it's because we're on a Win95 Gold machine
	if (pfnCoInitializeEx == NULL)
	{
		DPL(8, "Initializing COM with single thread apartment concurrency model.", 0);

		// Just use the regular CoInitialize.  S_FALSE is okay, it just means it was
		// already called.
		hr = CoInitialize(NULL);
		if ((hr != S_OK) && (hr != S_FALSE))
		{
			DPL(0, "Couldn't initialize COM!", 0);
			goto ERROR_EXIT;
		} // end if (couldn't initialize COM)
	}
	else
	{
		DPL(8, "Initializing COM with multithread apartment concurrency model.", 0);

		// Note: this function call requires DCOM95 to be installed on Win95 machines and
		// it returns S_FALSE if it was already called (which is documented as being okay,
		// as long as we balance the calls).
		hr = pfnCoInitializeEx(NULL, COINIT_MULTITHREADED);
		if ((hr != S_OK) && (hr != S_FALSE))
		{
			DPL(0, "Couldn't initialize COM using Ex interface!", 0);
			goto ERROR_EXIT;
		} // end if (couldn't initialize COM ex)
	} // end if (got CoInitializeEx)

	fCOMInitialized = TRUE;

	if (hOle32 != NULL)
	{
		FreeLibrary(hOle32); // ignore error
		hOle32 = NULL;
	} // end if (have OLE library)


	hr = CoCreateInstance(CLSID_tmAgent, NULL, CLSCTX_ALL, IID_ItmAgent,
						(void**) &(this->m_lpTMAgent));
	if (hr != S_OK)
	{
		DPL(0, "Creating TMAgent object failed!  Check that TMAgent.dll is registered.", 0);
		goto ERROR_EXIT;
	} // end if (creating TMAgent object failed)

	hr = this->m_lpTMAgent->QueryInterface(IID_ItmSetup, (void**) &lpTMSetup);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get TMSetup interface from TMAgent object!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't get a setup interface)


	// Since the database logging is wierd like that, we need to generate a new
	// system ID every time we want to run the same test, which for us is essentially
	// every time.  So get a TMSetup interface, and generate an ID.
	hr = lpTMSetup->NewSysID();
	if (hr != S_OK)
	{
		/*
		DPL(0, "Creating a new system ID failed!  Ignoring.  %e", 1, hr);
		hr = S_OK;
		*/
		DPL(0, "Creating a new system ID failed!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't create new system ID)

	lpTMSetup->Release();
	lpTMSetup = NULL;


	hr = this->m_lpTMAgent->Initialize();
	if (hr != S_OK)
	{
		DPL(0, "Initializing TMAgent object failed!", 0);
		goto ERROR_EXIT;
	} // end if (initting TMAgent object failed)
	
	hr = this->m_lpTMAgent->StartTest(TN_DATABASE_APPID);
	if (hr != S_OK)
	{
		DPL(0, "Notifying database of test pass start failed!", 0);
		goto ERROR_EXIT;
	} // end if (starting test pass failed)

	// Hey, everything's cool, so we're done

	return (S_OK);


ERROR_EXIT:

	if (lpTMSetup != NULL)
	{
		lpTMSetup->Release();
		lpTMSetup = NULL;
	} // end if (we have a TMSetup interface)

	if (this->m_lpTMAgent != NULL)
	{
		this->m_lpTMAgent->Release();
		this->m_lpTMAgent = NULL;
	} // end if (we have a TMAgent interface)

	if (hOle32 != NULL)
	{
		FreeLibrary(hOle32); // ignore error
		hOle32 = NULL;
	} // end if (have OLE library)

	if (fCOMInitialized)
	{
		CoUninitialize();
		fCOMInitialized = FALSE;
	} // end if (we initialized COM)

	iMsgBoxResult = IDYES;
	//if (! this->m_fQuiet) // BUGBUG implement something like this
	{
		iMsgBoxResult = DialogBoxParam(s_hInstance, MAKEINTRESOURCE(IDD_DBUNAVAILABLE), NULL,
										DBUnavailableDlgProc, 0);
	} // end if (can display dialog box)

	if (iMsgBoxResult == IDYES)
	{
		DPL(0, "WARNING: Couldn't initialize database logging, but user chose to continue testing!", 0);
		this->Log(TNLST_CRITICAL,
				"WARNING: Couldn't initialize database logging, but user chose to continue testing!", 0);
		hr = S_OK;
	} // end if (continue)

	return (hr);
} // CTNSlave::InitializeDBLogging
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#endif // ! XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::ReportInternal()"
//==================================================================================
// CTNSlave::ReportInternal
//----------------------------------------------------------------------------------
//
// Description: Internal version of test result reporting.
//
// Arguments:
//	PTNTESTINSTANCES pTest			Pointer to test instance this report pertains
//									to.
//	HRESULT hresult					Success or error code.
//	BOOL fTestComplete				Does this report mean that no more execution
//									will be performed on the test (either because it
//									completed or it encountered a fatal error)?
//	BOOL fSuccess					Is this report a success (note this does not
//									necessarily mean hresult is 0)?
//	PVOID pvOutputData				Optional pointer to output data to send with
//									report.
//	DWORD dwOutputDataSize			Size of output data to send with report.
//	PTNOUTPUTVARSLIST pOutputVars	Optional pointer to list of output variables
//									associated with result.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::ReportInternal(PTNTESTINSTANCES pTest, HRESULT hresult,
								BOOL fTestComplete, BOOL fSuccess,
								PVOID pvOutputData, DWORD dwOutputDataSize,
								PTNOUTPUTVARSLIST pOutputVars)
{
	HRESULT				hr;
	PTNTESTINSTANCES	pTopLevelTest = NULL;
	PTNSENDDATA			pSendData = NULL;
	PCTRLMSG_REPORT		pReportMsg = NULL;
	DWORD				dwVarsSize = 0;
	BOOL				fDebugBreak = FALSE;


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test %u!", 1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get top level test)

	DPL(1, "Sending %s %s report for test ID %u:%u, hresult = %x",
		5, ((fTestComplete) ? "complete" : "during-test"),
		((fSuccess) ? "success" : "failure"),
		pTopLevelTest->m_dwUniqueID, pTest->m_dwUniqueID, hresult);

	if (fTestComplete)
	{
		this->Log(((fSuccess) ? TNLST_CONTROLLAYER_TESTSUCCESS : TNLST_CONTROLLAYER_TESTFAILURE),
				"Test %u was %s, %e",
				3, pTest->m_dwUniqueID,
				((fSuccess) ? "successful" : "a failure"),
				hresult);
	} // end if (test is complete)
	else
	{
		this->Log(((fSuccess) ? TNLST_CONTROLLAYER_TESTSUCCESS : TNLST_CONTROLLAYER_TESTFAILURE),
				"Test %u is continuing %s, %e",
				3, pTest->m_dwUniqueID,
				((fSuccess) ? "successfully" : "despite a failure"),
				hresult);
	} // end if (test is complete)


	// Ignore error, assume BUFFER_TOO_SMALL
	if (pOutputVars != NULL)
		pOutputVars->PackIntoBuffer(NULL, &dwVarsSize);


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_REPORT)
								+ dwOutputDataSize
								+ dwVarsSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pReportMsg = (PCTRLMSG_REPORT) pSendData->m_pvData;
	pReportMsg->dwSize = pSendData->m_dwDataSize;
	pReportMsg->dwType = CTRLMSGID_REPORT;

	CopyMemory(&(pReportMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pReportMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pReportMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pReportMsg->hresult = hresult;
	pReportMsg->fTestComplete = fTestComplete;
	pReportMsg->fSuccess = fSuccess;
	//pReportMsg->dwOutputDataSize = 0;
	//pReportMsg->dwVarsSize = 0;
	if ((pvOutputData != NULL) && (dwOutputDataSize > 0))
	{
		pReportMsg->dwOutputDataSize = dwOutputDataSize;
		CopyMemory((pReportMsg + 1), pvOutputData, dwOutputDataSize);
	} // end if (there's actually output data)
	if (pOutputVars != NULL)
	{
		pReportMsg->dwVarsSize = dwVarsSize;
		hr = pOutputVars->PackIntoBuffer(((LPBYTE) (pReportMsg + 1)) + dwOutputDataSize,
										&dwVarsSize);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't pack output variables into buffer!", 0);
			goto DONE;
		} // end if (failed to add item to queue)
	} // end if (there are output variables)

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


	if ((! fSuccess) && (this->m_pFailureBreakRules != NULL))
	{
		char		szNumber[32];
		int			i;
		PLSTRING	pBreakRule;
		char*		pszTemp;
		DWORD		dwNumFields;
#ifdef _XBOX // Damn ANSI conversion
	WCHAR				szWideNumber[32];
#endif // XBOX
		

#ifndef _XBOX // Damn ANSI conversion
		wsprintf(szNumber, "0x%08x", hresult);
#else // ! XBOX
		swprintf(szWideNumber, L"0x%08x", hresult);
		wcstombs(szNumber, szWideNumber, wcslen(szWideNumber));
		szNumber[wcslen(szWideNumber)] = 0;
#endif // XBOX

		this->m_pFailureBreakRules->EnterCritSection();
		for(i = 0; i < this->m_pFailureBreakRules->Count(); i++)
		{
			pBreakRule = (PLSTRING) this->m_pFailureBreakRules->GetItem(i);
			if (pBreakRule == NULL)
			{
				DPL(0, "Couldn't get failure break rule %i!", 1, i);
				this->m_pFailureBreakRules->LeaveCritSection();
				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't get break rule)

			pszTemp = (char*) LocalAlloc(LPTR, strlen(pBreakRule->GetString()) + 1);
			if (pszTemp == NULL)
			{
				this->m_pFailureBreakRules->LeaveCritSection();
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't get break rule)

			// Ignoring possible return of 0.
			dwNumFields = StringSplitIntoFields(pBreakRule->GetString(), " ",
												pszTemp, NULL);

			fDebugBreak = StringMatchesWithWildcard(StringGetFieldPtr(pszTemp, 0),
													pTest->m_pCase->m_pszID,
													TRUE);
			if ((fDebugBreak) && (dwNumFields >= 2))
			{
				fDebugBreak = StringMatchesWithWildcard(StringGetFieldPtr(pszTemp, 1),
														szNumber,
														TRUE);
			} // end if (only one field)

			LocalFree(pszTemp);
			pszTemp = NULL;

			// If we matched, stop searching.
			if (fDebugBreak)
			{
				DPL(5, "\"%s %x\" matched \"%s\"", 3, pTest->m_pCase->m_pszID, hresult,
					pBreakRule->GetString());
				break;
			} // end if (matched)
		} // end for (each failure break rule)
		this->m_pFailureBreakRules->LeaveCritSection();
	} // end if (we may want to break on this failure)


	// If this doesn't complete the test, then we're done.
	if (! fTestComplete)
		goto SKIP;


	// If we should grab the net stat info, do so.
	if ((! fSuccess) && (this->m_fGetNetStatInfoOnFailure))
	{
		this->GetNetStatInfo();
	} // end if (failed and should grab net stat info)


#ifndef _XBOX // no dumping files supported
	if ((! fSuccess) && (this->m_pszFailureMemDumpDirPath != NULL))
	{
		char*	pszFile;
		DWORD	dwSize;
		char	szNumber[32];
		char	szDate[256];
		char	szTemp[1024];
#ifdef _XBOX // Damn ANSI conversion
		WCHAR	szWideNumber[32];
		WCHAR	szWideTemp[1024];
#endif // XBOX
		

		dwSize = strlen(this->m_pszFailureMemDumpDirPath) + 1; // + NULL termination

		if (! StringEndsWith(this->m_pszFailureMemDumpDirPath, "\\", TRUE))
			dwSize++; // add backslash
		
		dwSize += 16; // "memlog_test_" + ".txt"
		if (pTest->m_pParentTest != NULL) // if a subtest
			dwSize += 3; // "sub"

#ifndef _XBOX // Damn ANSI conversion
		wsprintf(szNumber, "%u", pTest->m_dwUniqueID);
#else // ! XBOX
		swprintf(szWideNumber, L"%u", pTest->m_dwUniqueID);
		wcstombs(szNumber, szWideNumber, wcslen(szWideNumber));
		szNumber[wcslen(szWideNumber)] = 0;
#endif // XBOX

		dwSize += strlen(szNumber);

		pszFile = (char*) LocalAlloc(LPTR, dwSize);
		if (pszFile == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		strcpy(pszFile, this->m_pszFailureMemDumpDirPath);
		if (! StringEndsWith(this->m_pszFailureMemDumpDirPath, "\\", TRUE))
			strcat(pszFile, "\\"); // add backslash

		if (pTest->m_pParentTest == NULL)
			strcat(pszFile, "memlog_test_");
		else
			strcat(pszFile, "memlog_subtest_");

		strcat(pszFile, szNumber);
		strcat(pszFile, ".txt");

		StringGetCurrentDateStr(szDate);
		
		if (pTest->m_pParentTest == NULL)
		{
#ifndef _XBOX // Damn ANSI conversion
			wsprintf(szTemp, "Test %u (case \"%s-%s\", \"%s\") failure mem log dump %s",
				pTest->m_dwUniqueID,
				pTest->m_pCase->m_pszID,
				pTest->m_pszInstanceID,
				pTest->m_pCase->m_pszName,
				szDate);
#else // ! XBOX
			swprintf(szWideTemp, L"Test %u (case \"%s-%s\", \"%s\") failure mem log dump %s",
				pTest->m_dwUniqueID,
				pTest->m_pCase->m_pszID,
				pTest->m_pszInstanceID,
				pTest->m_pCase->m_pszName,
				szDate);
			wcstombs(szTemp, szWideTemp, wcslen(szWideTemp));
			szTemp[wcslen(szWideTemp)] = 0;
#endif // XBOX
		} // end if (there's no test instance ID)
		else
		{
#ifndef _XBOX // Damn ANSI conversion
			wsprintf(szTemp, "Subtest %u (case \"%s\", \"%s\", parent ID is %u) failure mem log dump %s",
					pTest->m_dwUniqueID,
					pTest->m_pCase->m_pszID,
					pTest->m_pCase->m_pszName,
					pTest->m_pParentTest->m_dwUniqueID,
					szDate);
#else // ! XBOX
			swprintf(szWideTemp, L"Subtest %u (case \"%s\", \"%s\", parent ID is %u) failure mem log dump %s",
					pTest->m_dwUniqueID,
					pTest->m_pCase->m_pszID,
					pTest->m_pCase->m_pszName,
					pTest->m_pParentTest->m_dwUniqueID,
					szDate);
			wcstombs(szTemp, szWideTemp, wcslen(szWideTemp));
			szTemp[wcslen(szWideTemp)] = 0;
#endif // XBOX
		} // end if (there is a test instance ID)

		TNDebugDumpMemoryLogToFile(pszFile, szTemp, TRUE);

		LocalFree(pszFile);
		pszFile = NULL;
	} // end if (we should dump the log on failures)
#endif // !	XBOX

	// Update statistics for the test, and the global statistics if it's
	// not a subtest.
	if (fSuccess)
	{
		if (pTest->m_pParentTest == NULL)
			this->m_totalstats.IncrementSuccesses();

		pTest->m_pCase->m_stats.IncrementSuccesses();
	} // end if (its a success report)
	else
	{
		if (pTest->m_pParentTest == NULL)
			this->m_totalstats.IncrementFailures();

		pTest->m_pCase->m_stats.IncrementFailures();
	} // end else (its a failure report)


	if ((this->m_hCompletionOrUpdateEvent != NULL) &&
		(! SetEvent(this->m_hCompletionOrUpdateEvent)))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set the user's update stats event (%x)!",
			1, this->m_hCompletionOrUpdateEvent);
		goto DONE;
	} // end if (couldn't set the user's update stats event)

#ifndef _XBOX

#pragma BUGBUG(vanceo, "What about ongoing tests?  They'll be top level")
	// Only logged if it was a top level test.
	if (pTest->m_pParentTest == NULL)
	{
		hr = this->EndDBCase(pTest, fSuccess);
		if (hr != S_OK)
		{
			DPL(0, "Failed notify database of test case end!", 0);
			goto DONE;
		} // end if (couldn't end case in DB)
	} // end if (it's a top level slave test)

#endif // ! XBOX

SKIP:

	if (fDebugBreak)
	{
		// Flush the queue, to make sure all outgoing messages are sent before we die.
		hr = this->m_pCtrlComm->FlushSendQueue();
		if (hr != S_OK)
		{
			DPL(0, "Couldn't flush send queue!", 0);
			goto DONE;
		} // end if (failed to flush queue)

		//Ignoring error
		this->Log(TNLST_CRITICAL,
				"Failure for test %u (case %s, \"%s\", result = %x) fits break rules, DEBUGBREAK()-ing.",
				4, pTest->m_dwUniqueID, pTest->m_pCase->m_pszID,
				pTest->m_pCase->m_pszName, hresult);

		DPL(0, "Failure for test %u (case %s: \"%s\", result = %x) fits break rules, DEBUGBREAK()-ing.",
			4, pTest->m_dwUniqueID, pTest->m_pCase->m_pszID,
			pTest->m_pCase->m_pszName, hresult);

		DEBUGBREAK();
	} // end if (we should break on this failure)


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send object)

	return (hr);
} // CTNSlave::ReportInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::WarnInternal()"
//==================================================================================
// CTNSlave::WarnInternal
//----------------------------------------------------------------------------------
//
// Description: Reports a non-fatal warning for a test.
//
// Arguments:
//	PTNTESTINSTANCES pTest		Pointer to test warning is for.
//	HRESULT hresult				Warning hresult code.
//	PVOID pvUserData			Pointer to optional user data to associate with
//								warning.
//	DWORD dwUserDataSize		Size of user data for warning.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::WarnInternal(PTNTESTINSTANCES pTest, HRESULT hresult,
						PVOID pvUserData, DWORD dwUserDataSize)
{
	HRESULT				hr;
	PTNTESTINSTANCES	pTopLevelTest = NULL;
	PTNSENDDATA			pSendData = NULL;
	PCTRLMSG_WARNING	pWarningMsg = NULL;


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test %u!", 1, pTest->m_dwUniqueID);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't get top level test)


	DPL(0, "Sending warning for test ID %u:%u, hr = %x",
		3, pTopLevelTest->m_dwUniqueID, pTest->m_dwUniqueID, hresult);

	this->Log(TNLST_CONTROLLAYER_TESTWARNING,
			"Sending warning, %e",
			1, hresult);


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_WARNING)
								+ dwUserDataSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pWarningMsg = (PCTRLMSG_WARNING) pSendData->m_pvData;
	pWarningMsg->dwSize = pSendData->m_dwDataSize;
	pWarningMsg->dwType = CTRLMSGID_WARNING;

	CopyMemory(&(pWarningMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pWarningMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pWarningMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pWarningMsg->hresult = hresult;
	//pWarningMsg->dwUserDataSize = 0;

	if ((pvUserData != NULL) && (dwUserDataSize > 0))
	{
		pWarningMsg->dwUserDataSize = dwUserDataSize;
		CopyMemory((pWarningMsg + 1), pvUserData, dwUserDataSize);
	} // end if (there's user data)


	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below





	this->m_totalstats.IncrementWarnings();
	if (pTest != NULL)
		pTest->m_pCase->m_stats.IncrementWarnings();


	if ((this->m_hCompletionOrUpdateEvent != NULL) &&
		(! SetEvent(this->m_hCompletionOrUpdateEvent)))
	{
		hr = GetLastError();
		DPL(0, "Couldn't set the user's update stats event (%x)!",
			1, this->m_hCompletionOrUpdateEvent);
		goto DONE;
	} // end if (couldn't set the user's update stats event)



DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have leftover object)

	return (hr);
} // CTNSlave::WarnInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::AnnounceSubTest()"
//==================================================================================
// CTNSlave::AnnounceSubTest
//----------------------------------------------------------------------------------
//
// Description: Notifies the master that testing is about to begin on the indicated
//				test (subtest if dwTopLevelUniqueID and dwParentUniqueID are not 0).
//				The master will then reply with a unique ID to assign to the test.
//				This function will block until the response comes in.
//
// Arguments:
//	PTNTESTINSTANCES pTest		Pointer to test to announce.
//	int iNumMachines			Number of testers in the following array.
//	PTNCTRLMACHINEID aTesters	Array of IDs indicating the testers in their
//								respective testing positions for the new test.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::AnnounceSubTest(PTNTESTINSTANCES pTest, int iNumMachines,
								PTNCTRLMACHINEID aTesters)
{
#pragma BUGBUG(vanceo, "All of this functionality is duplicated in request poke test now")
	HRESULT						hr = S_OK;
	PTNTESTINSTANCES			pTopLevelTest = NULL;
	PTNTESTINSTANCES			pParentTest = NULL;
	DWORD						dwModuleIDSize = 0;
	PTNSENDDATA					pSendData = NULL;
	PCTRLMSG_ANNOUNCESUBTEST	pAnnounceSubTestMsg = NULL;
	LPBYTE						lpCurrent = NULL;
	HANDLE						ahWaitObjects[3];
	DWORD						dwNumWaitObjects = 0;
	DWORD						dwTimeouts = 0;
	int							i;
	int							j;


	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test ID %u!", 1, pTest->m_dwUniqueID);
		return (E_FAIL);
	} // end if (couldn't get top level test)

	//BUGBUG what about poke mode?  will they have parent tests?
	pParentTest = (PTNTESTINSTANCES) pTest->m_pParentTest;
	if (pParentTest == NULL)
	{
		DPL(0, "No parent test for test ID %u!", 1, pTest->m_dwUniqueID);
		return (E_FAIL);
	} // end if (no parent test)


	// We're using them
	pParentTest->m_dwRefCount++;
	pTest->m_dwRefCount++;

	EnterCriticalSection(&(pParentTest->m_csMasterOp));

	pParentTest->m_dwRequestID = this->m_dwCurrentUniqueID++;

	if (pParentTest->m_hResponseEvent != NULL)
	{
		DPL(0, "Get response event already in use!?", 0);
		hr = ERROR_ALREADY_EXISTS;
		goto DONE;
	} // end if (response event already exists)

	pParentTest->m_hResponseEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (pParentTest->m_hResponseEvent == NULL)
	{
		hr = GetLastError();
		if (hr == S_OK)
			hr = E_FAIL;

		DPL(0, "Couldn't create get response event!", 0);
		goto DONE;
	} // end if (couldn't create event)


	// Make sure all the specified testers are still alive.
	for(i = 0; i < iNumMachines; i++)
	{
		for(j = 0; j < pParentTest->m_iNumMachines; j++)
		{
			if ((memcmp(&(aTesters[i]), &(pParentTest->m_paTesterSlots[j].id), sizeof (TNCTRLMACHINEID)) == 0) &&
				(pParentTest->m_paTesterSlots[j].fGone))
			{
				DPL(0, "Tester %i of parent test %u has already gone, can't announce sub test!",
					2, j, pParentTest->m_dwUniqueID);
				hr = TNERR_LOSTTESTER;
				goto DONE;
			} // end if (syncing with dead guy)
		} // end for (each parent tester)
	} // end for (each tester)


	DPL(6, "Announcing subtest %u:%u:%s with request ID %u.",
		4, pTopLevelTest->m_dwUniqueID, pParentTest->m_dwUniqueID,
		pTest->m_pCase->m_pszID, pParentTest->m_dwRequestID);


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	dwModuleIDSize = strlen(pTest->m_pCase->m_pszID) + 1;

	pSendData->m_dwDataSize = sizeof (CTRLMSG_ANNOUNCESUBTEST)
							+ dwModuleIDSize
							+ (iNumMachines * sizeof (TNCTRLMACHINEID));

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pAnnounceSubTestMsg = (PCTRLMSG_ANNOUNCESUBTEST) pSendData->m_pvData;
	pAnnounceSubTestMsg->dwSize = pSendData->m_dwDataSize;
	pAnnounceSubTestMsg->dwType = CTRLMSGID_ANNOUNCESUBTEST;

	CopyMemory(&(pAnnounceSubTestMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pAnnounceSubTestMsg->dwRequestID = pParentTest->m_dwRequestID;
	pAnnounceSubTestMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pAnnounceSubTestMsg->dwParentUniqueID = pParentTest->m_dwUniqueID;
	pAnnounceSubTestMsg->iNumMachines = iNumMachines;

	lpCurrent = (LPBYTE) (pAnnounceSubTestMsg + 1);
	CopyAndMoveDestPointer(lpCurrent, pTest->m_pCase->m_pszID, dwModuleIDSize);
	CopyAndMoveDestPointer(lpCurrent, aTesters, (iNumMachines * (sizeof (TNCTRLMACHINEID))));

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below

	ahWaitObjects[dwNumWaitObjects++] = pParentTest->m_hResponseEvent;

	if (this->m_executor.m_hUserCancelEvent != NULL)
		ahWaitObjects[dwNumWaitObjects++] = this->m_executor.m_hUserCancelEvent;

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array

	dwTimeouts = 0;


REWAIT:

	//BUGBUG need a real timeout?
	hr = WaitForMultipleObjects(dwNumWaitObjects, ahWaitObjects, FALSE,
								IDLE_INTERVAL);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			DPL(7, "Received announcement response event (for %u:%u:%s, it's %u).",
				4, pTopLevelTest->m_dwUniqueID, pParentTest->m_dwUniqueID,
				pTest->m_pCase->m_pszID, pTest->m_dwUniqueID);

			if (pParentTest->m_hrResponseResult == TNERR_LOSTTESTER)
			{
				// See if any of the testers we're trying to work with died.
				for(i = 0; i < iNumMachines; i++)
				{
					for(j = 0; j < pParentTest->m_iNumMachines; j++)
					{
						if ((memcmp(&(aTesters[i]), &(pParentTest->m_paTesterSlots[j].id), sizeof (TNCTRLMACHINEID)) == 0) &&
							(pParentTest->m_paTesterSlots[j].fGone))
						{
							DPL(0, "Tester %i of parent test %u left, can't announce sub test!",
								2, j, pParentTest->m_dwUniqueID);
							hr = TNERR_LOSTTESTER;
							goto DONE;
						} // end if (syncing with dead guy)
					} // end for (each parent tester)
				} // end for (each tester)

				// If we're here, none of the testers we care about
				// died, so just go back to waiting.

#pragma BUGBUG(vanceo, "Timer sort of reset")
				goto REWAIT;
			} // end if (lost a tester)

			hr = pParentTest->m_hrResponseResult;
		  break;

		case WAIT_OBJECT_0 + 1:
			DPL(0, "Announce wait (for %u:%u:%s) aborted!",
				3, pTopLevelTest->m_dwUniqueID, pParentTest->m_dwUniqueID,
				pTest->m_pCase->m_pszID);

			hr = TNWR_USERCANCEL;
		  break;

		case WAIT_TIMEOUT:
			dwTimeouts++;


			// Twiddle our thumbs while we're waiting.
			hr = this->DoIdle(CTRLIDLE_ANNOUNCESUBTEST);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't perform the idle activities!", 0);
				goto DONE;
			} // end if (failed idling)


			if (dwTimeouts < TAKINGTOOLONG_NUMINTERVALS_TIMEOUT)
			{
				// If we've been sitting here for a while, print a warning
				if (dwTimeouts > TAKINGTOOLONG_NUMINTERVALS_PRINT)
				{
					DPL(0, "Boy, announce test (for %u:%u:%s) sure is taking an awfully long time...",
						3, pTopLevelTest->m_dwUniqueID, pParentTest->m_dwUniqueID,
						pTest->m_pCase->m_pszID);

					this->Log(TNLST_CONTROLLAYER_INFO,
							"Boy, announcing the subtest sure is taking an awfully long time...", 0);
				} // end if (time to print)
				else
				{
					DPL(0, "Still waiting for announce test (for %u:%u:%s) response.",
						3, pTopLevelTest->m_dwUniqueID, pParentTest->m_dwUniqueID,
						pTest->m_pCase->m_pszID);
				} // end else (shouldn't print yet)

				goto REWAIT; // go back to waiting
			} // end if (not time to fail yet)

			DPL(0, "Waiting for announcement response (for %u:%u:%s) timed out!",
				3, pTopLevelTest->m_dwUniqueID, pParentTest->m_dwUniqueID,
				pTest->m_pCase->m_pszID);

			hr = TNWR_TIMEOUT;
		  break;

		default:
			DPL(0, "Received unexpected return from WaitForMultipleObjects!", 0);

			if (hr == S_OK)
				hr = E_FAIL;
		  break;
	} // end switch (on wait result)


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have send object)

	if (pParentTest->m_hResponseEvent)
	{
		CloseHandle(pParentTest->m_hResponseEvent);
		pParentTest->m_hResponseEvent = NULL;
	} // end if (have response event)

	pParentTest->m_dwRequestID = 0;
	pParentTest->m_hrResponseResult = E_FAIL;


	LeaveCriticalSection(&(pParentTest->m_csMasterOp));


	pTest->m_dwRefCount--;
	if (pTest->m_dwRefCount == 0)
	{
		DPL(0, "Deleting new sub test %x!?  DEBUGBREAK()-ing.", 1, pTest);
		DEBUGBREAK();
	} // end if (we were the last ones to use the test)
	else
	{
		DPL(7, "Not deleting new sub test %x, refcount is %u.",
			2, pTest, pTest->m_dwRefCount);
	} // end else (not last ones to use test)
	pTest = NULL;


	pParentTest->m_dwRefCount--;
	if (pParentTest->m_dwRefCount == 0)
	{
		DPL(0, "Deleting parent test %x!?", 1, pParentTest);
		DEBUGBREAK();
	} // end if (we were the last ones to use the test)
	else
	{
		DPL(7, "Not deleting parent test %x, refcount is %u.",
			2, pParentTest, pParentTest->m_dwRefCount);
	} // end else (not last ones to use test)
	pParentTest = NULL;

	return (hr);
} // CTNSlave::AnnounceSubTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::SyncInternal()"
//==================================================================================
// CTNSlave::SyncInternal
//----------------------------------------------------------------------------------
//
// Description:    Issues a request to the testmaster to synchronize with specific
//				other machines working on the test (designated in the passed in
//				array).  Data can also be sent to these machines at this time.
//				   A slave is determined to be in-sync when the master has also
//				received sync requests from each of the other testers in the array
//				with the slave specified as a tester to sync with.
//				   This has a domino effect, so that each tester in a slave's sync
//				list must also have heard from all the tester's in its own sync
//				list before marking the first slave as ready.  At that point, the
//				master will fill the return data buffer with the data given by all
//				parties and return with TNSR_INSYNC.
//				   Only one sync attempt is allowed to be outstanding at a time, per
//				unique test ID.  Syncing with your own tester number has no effect.
//				   If this function doesn't return TNSR_INSYNC, it is expected that
//				the test case will end as soon as possible.  Specifically, if
//				TNSR_LOSTTESTER is returned, the test case must not call any Sync
//				or Exec function that requires multiple machines.
//
// Arguments:
//	PTNTESTINSTANCES pTest			Pointer to test to sync under.
//	char* szSyncName				User defined unique name for this sync
//									operation.  Must match on all machines involved.
//	PVOID pvSendData				Pointer to data to send to people to sync with.
//	DWORD dwSendDataSize			Size of data to send to people to sync with.
//	PTNSYNCDATALIST pReceiveData	Pointer to list that will hold the data received
//									from the other synchronizing testers.
//	int iNumMachines				How many testers we're syncing with (i.e. how
//									many integers there are in following array).
//	int* aiTesters					Array of integers indicating the testers to sync
//									with.
//
// Returns: TNSR_INSYNC if successful, or TNSR_xxx error code otherwise.
//==================================================================================
HRESULT CTNSlave::SyncInternal(PTNTESTINSTANCES pTest,
								char* szSyncName,
								PVOID pvSendData,
								DWORD dwSendDataSize,
								PTNSYNCDATALIST pReceiveData,
								int iNumMachines,
								int* aiTesters)
{
	HRESULT					hr = S_OK;
	PTNTESTINSTANCES		pTopLevelTest = NULL;
	PTNSENDDATA				pSendData = NULL;
	PCTRLMSG_REQUESTSYNC	pRequestSyncMsg = NULL;
	LPBYTE					lpCurrent;
#ifndef _XBOX // no messaging supported
	MSG						msg;
#endif // ! XBOX
	HANDLE					ahWaitObjects[3];
	DWORD					dwNumWaitObjects = 0;
	int						i;
	DWORD					dwLastIdleTime = 0;



	pTopLevelTest = (PTNTESTINSTANCES) pTest->GetTopLevelTest();
	if (pTopLevelTest == NULL)
	{
		DPL(0, "Couldn't get top level test for test %u!", 1, pTest->m_dwUniqueID);
		return (E_FAIL);
	} // end if (couldn't get top level test)


	pTest->m_dwRefCount++; // we're using it

	EnterCriticalSection(&(pTest->m_csMasterOp));

	pTest->m_dwRequestID = this->m_dwCurrentUniqueID++;

	if (pTest->m_hResponseEvent != NULL)
	{
		DPL(0, "Test ID %u's response event already in use?!",
			1, pTest->m_dwUniqueID);
		hr = ERROR_ALREADY_EXISTS;
		goto DONE;
	} // end if (we're already syncing)

	pTest->m_hResponseEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (pTest->m_hResponseEvent == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't create sync event for test ID %u!",
			1, pTest->m_dwUniqueID);

		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't create event)

	// Assume that this will not exist if the event didn't already exist either.
	pTest->m_pSyncDataList = pReceiveData;


	// Make sure all the specified testers are still alive.
	for(i = 0; i < iNumMachines; i++)
	{
		if (pTest->m_paTesterSlots[aiTesters[i]].fGone)
		{
			DPL(0, "Tester %i has already gone, can't sync!",
				1, aiTesters[i]);
			hr = TNSR_LOSTTESTER;
			goto DONE;
		} // end if (syncing with dead guy)
	} // end for (each tester)


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_REQUESTSYNC)
							+ strlen(szSyncName) + 1
							+ (iNumMachines * sizeof (int))
							+ dwSendDataSize;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pRequestSyncMsg = (PCTRLMSG_REQUESTSYNC) pSendData->m_pvData;
	pRequestSyncMsg->dwSize = pSendData->m_dwDataSize;
	pRequestSyncMsg->dwType = CTRLMSGID_REQUESTSYNC;

	CopyMemory(&(pRequestSyncMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pRequestSyncMsg->dwRequestID = pTest->m_dwRequestID;
	pRequestSyncMsg->dwTopLevelUniqueID = pTopLevelTest->m_dwUniqueID;
	pRequestSyncMsg->dwTestUniqueID = pTest->m_dwUniqueID;
	pRequestSyncMsg->dwNameSize = strlen(szSyncName) + 1;
	pRequestSyncMsg->iNumMachines = iNumMachines;
	pRequestSyncMsg->dwDataSize = dwSendDataSize;

	lpCurrent = (LPBYTE) (pRequestSyncMsg + 1);

	CopyAndMoveDestPointer(lpCurrent, szSyncName, strlen(szSyncName) + 1);
	CopyAndMoveDestPointer(lpCurrent, aiTesters, iNumMachines * (sizeof (int)));


	if (pvSendData != NULL)
	{
		CopyAndMoveDestPointer(lpCurrent, pvSendData, dwSendDataSize);
	} // end if (there's data to send)

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below

	ahWaitObjects[dwNumWaitObjects++] = pTest->m_hResponseEvent;

	if (this->m_executor.m_hUserCancelEvent != NULL)
		ahWaitObjects[dwNumWaitObjects++] = this->m_executor.m_hUserCancelEvent;

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array


	dwLastIdleTime = GetTickCount();


REWAIT:
	// Make sure the test thread still looks alive
	this->m_executor.m_dwLastTestthreadPing = GetTickCount();


#ifndef _XBOX // no message functions supported
	// Since TAPI requires a message pump, I've built a simple (hacky) one into
	// this Wait in case the user was expecting a message to arrive...
	if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		DPL(1, "Got Windows message.", 0);

		TranslateMessage(&msg);
		DispatchMessage(&msg);
	} // end if (there's a Windows message)
#else // !XBOX
#pragma TODO(tristanj, "Removing message pump may affect things if TAPI isn't removed")
#endif // XBOX



	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, ahWaitObjects, FALSE,
								MESSAGE_PUMP_CHECK_INTERVAL, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			DPL(2, "Test ID %u:%u \"%s\" received sync response (result = %x).",
				4, pTopLevelTest->m_dwUniqueID, pTest->m_dwUniqueID,
				szSyncName, pTest->m_hrResponseResult);

			if (pTest->m_hrResponseResult == S_OK)
			{
				hr = TNSR_INSYNC;
				goto DONE;
			} // end if (successful)

			if (pTest->m_hrResponseResult == TNERR_LOSTTESTER)
			{
				for(i = 0; i < iNumMachines; i++)
				{
					if (pTest->m_paTesterSlots[aiTesters[i]].fGone)
					{
						DPL(0, "Lost a tester we're syncing with (%i)!",
							1, aiTesters[i]);
						hr = TNSR_LOSTTESTER;
						goto DONE;
					} // end if (syncing with dead guy)
				} // end for (each tester)

				// If we got here, it means we aren't doing anything with
				// that guy, so who cares?
				goto REWAIT;
			} // end if (lost a tester)
			

			// Some generic failure
			hr = pTest->m_hrResponseResult;
			DPL(0, "Failed synchronizing \"%s\" under test ID %u!  %E",
				3, szSyncName, pTest->m_dwUniqueID, hr);
		  break;

		case WAIT_OBJECT_0 + 1:
			DPL(0, "Test ID %u \"%s\" sync wait aborted.", 2, pTest->m_dwUniqueID,
				szSyncName);

			hr = TNSR_USERCANCEL;
		  break;

		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT;
		  break;

		case WAIT_TIMEOUT:
			if (GetTickCount() > (dwLastIdleTime + IDLE_INTERVAL))
			{
				// Twiddle our thumbs while we're waiting.
				hr = this->DoIdle(CTRLIDLE_SYNC);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't perform the idle activities!", 0);
					goto DONE;
				} // end if (failed idling)

				dwLastIdleTime = GetTickCount();
			} // end if (time to idle again)

			goto REWAIT;
		  break;

		default:
			DPL(0, "Sync wait for test ID %u \"%s\" received unexpected return from WaitForMultipleObjects!",
				2, pTest->m_dwUniqueID, szSyncName);
		  break;
	} // end switch (on wait result)


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have leftover object)

	if (pTest->m_hResponseEvent != NULL)
	{
		CloseHandle(pTest->m_hResponseEvent);
		pTest->m_hResponseEvent = NULL;
	} // end if (we have response event)

	pTest->m_dwRequestID = 0;
	pTest->m_hrResponseResult = E_FAIL;

	pTest->m_pSyncDataList = NULL; // forget about the list

	LeaveCriticalSection(&pTest->m_csMasterOp);

		
	pTest->m_dwRefCount--;
	if (pTest->m_dwRefCount == 0)
	{
		DPL(0, "Deleting test %x!?", 1, pTest);
		delete (pTest);
	} // end if (we were the last ones to use the test)
	pTest = NULL;

	return (hr);
} // CTNSlave::SyncInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::IsTesterOnSameMachineInternal()"
//==================================================================================
// CTNSlave::IsTesterOnSameMachineInternal
//----------------------------------------------------------------------------------
//
// Description: Returns TRUE if the given tester is located on this same machine,
//				FALSE if not.
//
// Arguments:
//	int iTesterNum		Tester number to check.
//
// Returns: TRUE if tester is on same machine, FALSE otherwise.
//==================================================================================
BOOL CTNSlave::IsTesterOnSameMachineInternal(PTNTESTINSTANCES pTest,
											int iTesterNum)
{
#ifndef _XBOX // no multiple local slaves, so no tester can be on the same machine...
	BOOL					fResult = FALSE;
	HRESULT					hr;
	int						i;
	PMULTIINSTANCEMMFILE	pMultiInstanceInfo = NULL;


	if (this->m_hMultiInstanceMutex == NULL)
	{
		DPL(0, "No mutex!", 0);
		goto DONE;
	} // end if (no mutex)

	if (this->m_hMultiInstanceMMFile == NULL)
	{
		DPL(0, "No memory mapped file!", 0);
		goto DONE;
	} // end if (no mm file)

	if (pTest->m_paTesterSlots[iTesterNum].fGone)
	{
		DPL(0, "Not checking if tester %i of test %u is on same machine because he has already left the test!",
			3, iTesterNum, pTest->m_dwUniqueID);
		goto DONE;
	} // end if (the tester is already gone)


	// Grab the lock
	WaitForSingleObject(this->m_hMultiInstanceMutex, INFINITE);

	// Map the file
	pMultiInstanceInfo = (PMULTIINSTANCEMMFILE) MapViewOfFile(this->m_hMultiInstanceMMFile,
															FILE_MAP_ALL_ACCESS,
															0, 0, 0);
	if (pMultiInstanceInfo == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't map view of file!", 0);
		goto DONE;
	} // end if (couldn't map view of file)


	// Loop through each instance slot looking for one with the right IDs.
	for(i = 0; i < MAX_NUM_LOCAL_INSTANCES; i++)
	{
		// Skip our index.
		if (i == this->m_iInstanceIndex)
			continue;

		// Skip empty indices.
		if (! pMultiInstanceInfo->aInstances[i].fInUse)
			continue;

		// If the session and slave IDs match, we found the guy.
		if ((pMultiInstanceInfo->aInstances[i].dwSessionID == this->m_dwSessionID) &&
			(memcmp(&(pMultiInstanceInfo->aInstances[i].id), &(pTest->m_paTesterSlots[iTesterNum].id), sizeof (TNCTRLMACHINEID)) == 0))
		{
			fResult = TRUE;
			break;
		} // end if (found the ID)
	} // end for (each instance slot)


	// Unmap our view.
	UnmapViewOfFile(pMultiInstanceInfo);
	pMultiInstanceInfo = NULL;

	// Drop the lock we took.
	ReleaseMutex(this->m_hMultiInstanceMutex);


DONE:

	return (fResult);
#else // ! XBOX
	return FALSE;
#endif // XBOX
} // CTNSlave::IsTesterOnSameMachineInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetTestersIPForPortInternal()"
//==================================================================================
// CTNSlave::GetTestersIPForPortInternal
//----------------------------------------------------------------------------------
//
// Description: Retrieves the IP address of the specified tester and places it in
//				the passed in string buffer.  The buffer must be at least 15
//				characters + NULL termination long.
//				The reachability test must already have been run (and passed) for
//				the specified machine.  See the master object for more details.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test requesting info.
//	int iTesterNum			Tester number for which to retrieve IP address.
//	WORD wPort				IP port used to verify reachability.
//	char* szIPString		String to store results in (must be 16 chars).
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::GetTestersIPForPortInternal(PTNTESTINSTANCES pTest,
											int iTesterNum, WORD wPort,
											char* szIPString)
{
	HRESULT					hr = S_OK;
	PTNREACHCHECKTARGET		pReachCheckTarget = NULL;
	int						i;
	PTNREACHCHECK			pReachCheck = NULL;


#pragma BUGBUG(vanceo, "Do we want this here or at every level maybe?")
	if (pTest->m_paTesterSlots[iTesterNum].fGone)
	{
		DPL(0, "Not getting IP for tester %i of test %u on port %u because he has already left the test!",
			3, iTesterNum, pTest->m_dwUniqueID, wPort);
		hr = TNERR_LOSTTESTER;
		goto DONE;
	} // end if (the tester is already gone)


	pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(pTest->m_paTesterSlots[iTesterNum].id));
	if (pReachCheckTarget == NULL)
	{
		DPL(0, "Couldn't find any reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
			2, iTesterNum, pTest->m_dwUniqueID);
		this->Log(TNLST_CRITICAL,
					"Couldn't find any reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
					2, iTesterNum, pTest->m_dwUniqueID);
		hr = ERROR_NOT_FOUND;
		goto DONE;
	} // end if (couldn't get reach check target)


	// Loop through all the reach checks performed on the tester til we find the
	// right kind.
	for(i = 0; i < pReachCheckTarget->m_checks.Count(); i++)
	{
		pReachCheck = (PTNREACHCHECK) pReachCheckTarget->m_checks.GetItem(i);
		if (pReachCheck == NULL)
		{
			DPL(0, "Couldn't get reach check %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get reach check target)

#pragma BUGBUG(vanceo, "Check for specific IP method?")
		if ((pReachCheck->m_dwMethod == TNRCM_UDPBROADCAST) ||
			(pReachCheck->m_dwMethod == TNRCM_UDP) ||
			(pReachCheck->m_dwMethod == TNRCM_UDP))
		{
#ifdef DEBUG
			if (pReachCheck->m_dwMethodDataSize != sizeof (WORD))
			{
				DPL(0, "IP reach check method data size is not correct (%u != %u)!  DEBUGBREAK()-ing.",
					2, pReachCheck->m_dwMethodDataSize, sizeof (WORD));

				DEBUGBREAK();

				hr = E_FAIL;
				goto DONE;
			} // end if (not a valid item)

			// If this is triggered, it's almost certainly because the user's CanRun
			// function is not correctly rejecting permutations which failed the IP
			// reach check.
			if (pReachCheck->m_dwAddressSize != sizeof (IN_ADDR))
			{
				DPL(0, "IP reach check address size is not correct (%u != %u)!  Are you sure the CanRun function is correctly rejecting invalid permutations?  DEBUGBREAK()-ing.",
					2, pReachCheck->m_dwAddressSize, sizeof (IN_ADDR));

				DEBUGBREAK();

				hr = E_FAIL;
				goto DONE;
			} // end if (not a valid item)
#endif // DEBUG

			// If it's on the same port and it's successful, we got the result
			// we want.
			if (*((WORD*) pReachCheck->m_pvMethodData) == wPort)
			{
				if (pReachCheck->m_fResult)
				{
					strcpy(szIPString,
							inet_ntoa(*((IN_ADDR*) pReachCheck->m_pvAddress)));

					DPL(2, "Tester %i (test %u)'s IP address (reachable on port %u) is \"%s\".",
						4, iTesterNum, pTest->m_dwUniqueID, wPort, szIPString);
				} // end if (succeeded)
				else
				{
					DPL(0, "Tester %i (test %u) was found to be unreachable on port %u!",
						3, iTesterNum, pTest->m_dwUniqueID, wPort);
				} // end else (failed)

				// We found the item we want, we're done.
				goto DONE;
			} // end if (matched port)
			else
			{
				DPL(7, "Tester %i (test %u) was %seachable on port %u, but we're looking for port %u.",
					5, iTesterNum,
					pTest->m_dwUniqueID,
					((pReachCheck->m_fResult) ? "r" : "unr"),
					*((WORD*) pReachCheck->m_pvMethodData),
					wPort);
			} // end else (didn't match port)
		} // end if (found IP method)
	} // end for (each reach check)


	// If we got here, it means we couldn't find any pertinent reach checks.

	DPL(0, "Couldn't find any IP reach checks for tester %i of test %u on port %u!  Are you sure the master verified reachability?",
		3, iTesterNum, pTest->m_dwUniqueID, wPort);
	this->Log(TNLST_CRITICAL,
				"Couldn't find any IP reach checks for tester %i of test %u on port %u!  Are you sure the master verified reachability?",
				3, iTesterNum, pTest->m_dwUniqueID, wPort);
	hr = ERROR_NOT_FOUND;

DONE:

	return (hr);
} // CTNSlave::GetTestersIPForPortInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetTestersPhoneNumInternal()"
//==================================================================================
// CTNSlave::GetTestersPhoneNumInternal
//----------------------------------------------------------------------------------
//
// Description: Returns the phone number of the specified tester number in the given
//				string buffer.  It is assumed to be large enough.
//				The reachability test must already have been run (and passed) for
//				the specified machine.  See the master object for more details.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test requesting info.
//	int iTesterNum			Tester number for which to retrieve phone number.
//	char* szPhoneNumber		String to store result in.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::GetTestersPhoneNumInternal(PTNTESTINSTANCES pTest,
											int iTesterNum, char* szPhoneNumber)
{
	HRESULT					hr = S_OK;
	PTNREACHCHECKTARGET		pReachCheckTarget = NULL;
	int						i;
	PTNREACHCHECK			pReachCheck = NULL;


#pragma BUGBUG(vanceo, "Do we want this here or at every level maybe?")
	if (pTest->m_paTesterSlots[iTesterNum].fGone)
	{
		DPL(0, "Not getting phone number for tester %i of test %u because he has already left the test!",
			2, iTesterNum, pTest->m_dwUniqueID);
		hr = TNERR_LOSTTESTER;
		goto DONE;
	} // end if (the tester is already gone)


	pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(pTest->m_paTesterSlots[iTesterNum].id));
	if (pReachCheckTarget == NULL)
	{
		DPL(0, "Couldn't find any reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
			2, iTesterNum, pTest->m_dwUniqueID);
		this->Log(TNLST_CRITICAL,
					"Couldn't find any reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
					2, iTesterNum, pTest->m_dwUniqueID);
		hr = ERROR_NOT_FOUND;
		goto DONE;
	} // end if (couldn't get reach check target)


	// Loop through all the reach checks performed on the tester til we find
	// the right kind.
	for(i = 0; i < pReachCheckTarget->m_checks.Count(); i++)
	{
		pReachCheck = (PTNREACHCHECK) pReachCheckTarget->m_checks.GetItem(i);
		if (pReachCheck == NULL)
		{
			DPL(0, "Couldn't get reach check %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get reach check target)

		if (pReachCheck->m_dwMethod == TNRCM_MODEM)
		{
			// This is the result we want, success or failure.
			if (pReachCheck->m_fResult)
			{
#pragma BUGBUG(vanceo, "Don't assume buffer is large enough, improve behavior")
				strcpy(szPhoneNumber, (char*) pReachCheck->m_pvAddress);

				DPL(2, "Tester %i (test %u)'s reachable phone number is \"%s\".",
					3, iTesterNum, pTest->m_dwUniqueID, szPhoneNumber);
			} // end if (succeeded)
			else
			{
				DPL(0, "Tester %i (test %u) was found to be unreachable via modem!",
					2, iTesterNum, pTest->m_dwUniqueID);
			} // end else (failed)

			// We found the item we want, we're done.
			goto DONE;
		} // end if (found modem method)
	} // end for (each reach check)


	// If we got here, it means we couldn't find any pertinent reach checks.

	DPL(0, "Couldn't find any modem reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
		2, iTesterNum, pTest->m_dwUniqueID);
	this->Log(TNLST_CRITICAL,
				"Couldn't find any modem reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
				2, iTesterNum, pTest->m_dwUniqueID);
	hr = ERROR_NOT_FOUND;


DONE:

	return (hr);
} // CTNSlave::GetTestersPhoneNumInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetTestersCOMPortInternal()"
//==================================================================================
// CTNSlave::GetTestersCOMPortInternal
//----------------------------------------------------------------------------------
//
// Description: Returns the COM port connected to the specified tester in the DWORD
//				pointer given.
//				The reachability test must already have been run (and passed) for
//				the specified machine.  See the master object for more details.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test requesting info.
//	int iTesterNum			Tester number for which to retrieve COM port.
//	DWORD* pdwCOMPort		Place to store result.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::GetTestersCOMPortInternal(PTNTESTINSTANCES pTest,
											int iTesterNum, DWORD* pdwCOMPort)
{
	HRESULT					hr = S_OK;
	PTNREACHCHECKTARGET		pReachCheckTarget = NULL;
	int						i;
	PTNREACHCHECK			pReachCheck = NULL;


#pragma BUGBUG(vanceo, "Do we want this here or at every level maybe?")
	if (pTest->m_paTesterSlots[iTesterNum].fGone)
	{
		DPL(0, "Not getting COM port for tester %i of test %u because he has already left the test!",
			2, iTesterNum, pTest->m_dwUniqueID);
		hr = TNERR_LOSTTESTER;
		goto DONE;
	} // end if (the tester is already gone)


	pReachCheckTarget = this->m_reachchecktargets.GetTarget(&(pTest->m_paTesterSlots[iTesterNum].id));
	if (pReachCheckTarget == NULL)
	{
		DPL(0, "Couldn't find any reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
			2, iTesterNum, pTest->m_dwUniqueID);
		this->Log(TNLST_CRITICAL,
					"Couldn't find any reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
					2, iTesterNum, pTest->m_dwUniqueID);
		hr = ERROR_NOT_FOUND;
		goto DONE;
	} // end if (couldn't get reach check target)


	// Loop through all the reach checks performed on the tester til we find
	// the right kind.
	for(i = 0; i < pReachCheckTarget->m_checks.Count(); i++)
	{
		pReachCheck = (PTNREACHCHECK) pReachCheckTarget->m_checks.GetItem(i);
		if (pReachCheck == NULL)
		{
			DPL(0, "Couldn't get reach check %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get reach check target)

		if (pReachCheck->m_dwMethod == TNRCM_SERIAL)
		{
			// This is the result we want, success or failure.
			if (pReachCheck->m_fResult)
			{
				(*pdwCOMPort) = *((DWORD*) pReachCheck->m_pvAddress);

				DPL(2, "Tester %i (test %u)'s is reachable via COM port %u.",
					3, iTesterNum, pTest->m_dwUniqueID, (*pdwCOMPort));
			} // end if (succeeded)
			else
			{
				DPL(0, "Tester %i (test %u) was found to be unreachable via serial!",
					2, iTesterNum, pTest->m_dwUniqueID);
			} // end else (failed)

			// We found the item we want, we're done.
			goto DONE;
		} // end if (found serial method)
	} // end for (each reach check)


	// If we got here, it means we couldn't find any pertinent reach checks.

	DPL(0, "Couldn't find any serial reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
		2, iTesterNum, pTest->m_dwUniqueID);
	this->Log(TNLST_CRITICAL,
				"Couldn't find any serial reach checks for tester %i of test %u!  Are you sure the master verified reachability?",
				2, iTesterNum, pTest->m_dwUniqueID);
	hr = ERROR_NOT_FOUND;


DONE:

	return (hr);
} // CTNSlave::GetTestersCOMPortInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::SendFreeOutputVars()"
//==================================================================================
// CTNSlave::SendFreeOutputVars
//----------------------------------------------------------------------------------
//
// Description: Tells the master to free the output variables identified so it will
//				have the same list as the slave.
//
// Arguments:
//	char* pszCaseID			Case ID to match, if any.
//	char* pszInstanceID		Instance ID to match, if any.
//	char* pszName			Variable name to match, if any.
//	char* pszType			Variable type to match, if any.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::SendFreeOutputVars(char* pszCaseID, char* pszInstanceID,
									char* pszName, char* pszType)
{
	HRESULT						hr;
	PTNSENDDATA					pSendData = NULL;
	PCTRLMSG_FREEOUTPUTVARS		pFreeOutputVarsMsg = NULL;
	LPBYTE						lpCurrent;



	if (((PCOMMDATA) this->m_pvTestmasterCommData)->fDropped)
	{
		DPL(0, "Can't send ready of first test message to master because the connection went down!", 0);
		hr = TNERR_CONNECTIONDROPPED;
		goto DONE;
	} // end if (connection to master went down)


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_FREEOUTPUTVARS);
	if (pszCaseID != NULL)
		pSendData->m_dwDataSize += strlen(pszCaseID) + 1;
	if (pszInstanceID != NULL)
		pSendData->m_dwDataSize += strlen(pszInstanceID) + 1;
	if (pszName != NULL)
		pSendData->m_dwDataSize += strlen(pszName) + 1;
	if (pszType != NULL)
		pSendData->m_dwDataSize += strlen(pszType) + 1;

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pFreeOutputVarsMsg = (PCTRLMSG_FREEOUTPUTVARS) pSendData->m_pvData;
	pFreeOutputVarsMsg->dwSize = pSendData->m_dwDataSize;
	pFreeOutputVarsMsg->dwType = CTRLMSGID_FREEOUTPUTVARS;

	CopyMemory(&(pFreeOutputVarsMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));

	lpCurrent = (LPBYTE) (pFreeOutputVarsMsg + 1);

	if (pszCaseID != NULL)
	{
		pFreeOutputVarsMsg->dwCaseIDSize = strlen(pszCaseID) + 1;

		CopyAndMoveDestPointer(lpCurrent, pszCaseID,
								pFreeOutputVarsMsg->dwCaseIDSize);
	} // end if (there's a case ID)

	if (pszInstanceID != NULL)
	{
		pFreeOutputVarsMsg->dwInstanceIDSize = strlen(pszInstanceID) + 1;

		CopyAndMoveDestPointer(lpCurrent, pszInstanceID,
								pFreeOutputVarsMsg->dwInstanceIDSize);
	} // end if (there's an instance ID)

	if (pszName != NULL)
	{
		pFreeOutputVarsMsg->dwNameSize = strlen(pszName) + 1;

		CopyAndMoveDestPointer(lpCurrent, pszName,
								pFreeOutputVarsMsg->dwNameSize);
	} // end if (there's a name)

	if (pszType != NULL)
	{
		pFreeOutputVarsMsg->dwTypeSize = strlen(pszType) + 1;

		CopyAndMoveDestPointer(lpCurrent, pszType,
								pFreeOutputVarsMsg->dwTypeSize);
	} // end if (there's a type)

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated object)

	return (hr);
} // CTNSlave::SendFreeOutputVars
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetTestersMachineInfoInternal()"
//==================================================================================
// CTNSlave::GetTestersMachineInfoInternal
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the machine info for the specified tester.
//				NOTE: The caller must release a reference to the object when done
//				with it.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test requesting info.
//	int iTesterNum			Tester number for which to retrieve COM port.
//	PTNMACHINEINFO* ppInfo	Place to store result.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::GetTestersMachineInfoInternal(PTNTESTINSTANCES pTest,
												int iTesterNum,
												PTNMACHINEINFO* ppInfo)
{
	HRESULT						hr = S_OK;
	PTNOTHERMACHINEINFO			pOtherInfo = NULL;
	BOOL						fTookMasterOpLock = FALSE;
	PTNSENDDATA					pSendData = NULL;
	PCTRLMSG_GETMACHINEINFO		pGetMachineInfoMsg = NULL;
	HANDLE						ahWaitObjects[3];
	DWORD						dwNumWaitObjects = 0;
#ifndef _XBOX // no messaging supported
	MSG							msg;
#endif // ! XBOX

#pragma BUGBUG(vanceo, "Do we want this here or at every level maybe?")
	if (pTest->m_paTesterSlots[iTesterNum].fGone)
	{
		DPL(0, "Not getting machine info for tester %i of test %u because he has already left the test!",
			2, iTesterNum, pTest->m_dwUniqueID);
		hr = TNERR_LOSTTESTER;
		goto DONE;
	} // end if (the tester is already gone)


	pOtherInfo = this->m_otherinfos.GetInfoForMachine(&(pTest->m_paTesterSlots[iTesterNum].id));
	if (pOtherInfo != NULL)
	{
		DPL(9, "Already retrieved tester %i's info, returning object %x.",
			2, iTesterNum, pOtherInfo);

		// Increment a ref for the user.
		pOtherInfo->m_dwRefCount++;

		(*ppInfo) = pOtherInfo;
		pOtherInfo = NULL;

		goto DONE;
	} // end if (found info)


	// If we got here, it means we couldn't find the machine info in our
	// previously retrieved list.  We have to ask the master for it now.

	DPL(0, "Couldn't find machine info for tester %i of test %u, requesting from master.",
		2, iTesterNum, pTest->m_dwUniqueID);

	EnterCriticalSection(&(pTest->m_csMasterOp));
	fTookMasterOpLock = TRUE;

	pTest->m_dwRequestID = this->m_dwCurrentUniqueID++;

	if (pTest->m_hResponseEvent != NULL)
	{
		DPL(0, "Test ID %u's response event already in use?!",
			1, pTest->m_dwUniqueID);
		hr = ERROR_ALREADY_EXISTS;
		goto DONE;
	} // end if (we're already syncing)

	pTest->m_hResponseEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (pTest->m_hResponseEvent == NULL)
	{
		hr = GetLastError();

		DPL(0, "Couldn't create response event for test ID %u!",
			1, pTest->m_dwUniqueID);

		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't create event)

	pOtherInfo = new (CTNOtherMachineInfo)(&(pTest->m_paTesterSlots[iTesterNum].id));

	pOtherInfo->m_dwRefCount += 2; // 1 for pOtherInfo, 1 for pTest->m_pReturnedInfo
	pTest->m_pReturnedInfo = pOtherInfo;



	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_GETMACHINEINFO);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pGetMachineInfoMsg = (PCTRLMSG_GETMACHINEINFO) pSendData->m_pvData;
	pGetMachineInfoMsg->dwSize = pSendData->m_dwDataSize;
	pGetMachineInfoMsg->dwType = CTRLMSGID_GETMACHINEINFO;

	CopyMemory(&(pGetMachineInfoMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pGetMachineInfoMsg->dwRequestID = pTest->m_dwRequestID;
	CopyMemory(&(pGetMachineInfoMsg->idMachineForInfo),
				&(pTest->m_paTesterSlots[iTesterNum].id),
				sizeof (TNCTRLMACHINEID));

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below

	ahWaitObjects[dwNumWaitObjects++] = pTest->m_hResponseEvent;

	if (this->m_executor.m_hUserCancelEvent != NULL)
		ahWaitObjects[dwNumWaitObjects++] = this->m_executor.m_hUserCancelEvent;

	ahWaitObjects[dwNumWaitObjects] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array


REWAIT:
	// Make sure the test thread still looks alive
	this->m_executor.m_dwLastTestthreadPing = GetTickCount();


#ifndef _XBOX // no message functions supported
	// Since TAPI requires a message pump, I've built a simple (hacky) one into
	// this Wait in case the user was expecting a message to arrive...
	if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		DPL(1, "Got Windows message.", 0);

		TranslateMessage(&msg);
		DispatchMessage(&msg);
	} // end if (there's a Windows message)
#else // !XBOX
#pragma TODO(tristanj, "Removing message pump may affect things if TAPI isn't removed")
#endif // XBOX


	hr = WaitForMultipleObjectsEx(dwNumWaitObjects, ahWaitObjects, FALSE,
								MESSAGE_PUMP_CHECK_INTERVAL, TRUE);
	switch (hr)
	{
		case WAIT_OBJECT_0:
			DPL(2, "Test ID %u received GetMachineInfo response (%x).",
				2, pTest->m_dwUniqueID, pTest->m_hrResponseResult);

			hr = pTest->m_hrResponseResult;
			if (hr == S_OK)
			{
				// Add it to the cache, and return.
				hr = this->m_otherinfos.Add(pOtherInfo);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't add other info %x to list!", 1, pOtherInfo);
					goto DONE;
				} // end if (failed adding item to list)

				(*ppInfo) = pOtherInfo;
				pOtherInfo = NULL;

				goto DONE;
			} // end if (successful)

			if (hr != TNERR_LOSTTESTER)
			{
				// Some generic failure
				DPL(0, "Got unexpected error while retrieving machine info for %i under test ID %u!  %E",
					3, iTesterNum, pTest->m_dwUniqueID, hr);
				goto DONE;
			} // end if (not lost a tester error)

			if (pTest->m_paTesterSlots[iTesterNum].fGone)
			{
				DPL(0, "Lost the tester we're retrieving info for (%i)!",
					1, iTesterNum);
				hr = TNWR_LOSTTESTER;
				goto DONE;
			} // end if (syncing with dead guy)

			// If we got here, it means we aren't doing anything with
			// that guy, so who cares?
			goto REWAIT;
		  break;

		case WAIT_OBJECT_0 + 1:
			DPL(0, "Test ID %u GetMachineInfo wait aborted.", 1, pTest->m_dwUniqueID);

			hr = TNWR_USERCANCEL;
		  break;

		case WAIT_IO_COMPLETION:
			DPL(1, "I/O Completion.", 0);
			goto REWAIT;
		  break;

		case WAIT_TIMEOUT:
			goto REWAIT;
		  break;

		default:
			DPL(0, "Machine info (tester %i) wait for test ID %u received unexpected return from WaitForMultipleObjects!",
				2, iTesterNum, pTest->m_dwUniqueID);
		  break;
	} // end switch (on wait result)


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have leftover object)

	if (pTest->m_hResponseEvent != NULL)
	{
		CloseHandle(pTest->m_hResponseEvent);
		pTest->m_hResponseEvent = NULL;
	} // end if (we have response event)

	pTest->m_dwRequestID = 0;
	pTest->m_hrResponseResult = E_FAIL;

	if (pTest->m_pReturnedInfo != NULL)
	{
		pTest->m_pReturnedInfo->m_dwRefCount--;
		if (pTest->m_pReturnedInfo->m_dwRefCount == 0)
		{
			DPL(7, "Deleting other machine info %x (test's returned info).", 1, pTest->m_pReturnedInfo);
			delete (pTest->m_pReturnedInfo);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting other machine info %x (test's returned info), its refcount is %u.",
				2, pTest->m_pReturnedInfo, pTest->m_pReturnedInfo->m_dwRefCount);
		} // end else (not last reference)
		pTest->m_pReturnedInfo = NULL;
	} // end if (still have info object)

	if (pOtherInfo != NULL)
	{
		pOtherInfo->m_dwRefCount--;
		if (pOtherInfo->m_dwRefCount == 0)
		{
			DPL(7, "Deleting other machine info %x (pOtherInfo).", 1, pOtherInfo);
			delete (pOtherInfo);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting other machine info %x (pOtherInfo), its refcount is %u.",
				2, pOtherInfo, pOtherInfo->m_dwRefCount);
		} // end else (not last reference)
		pOtherInfo = NULL;
	} // end if (still have info object)

	if (fTookMasterOpLock)
	{
		fTookMasterOpLock = FALSE;
		LeaveCriticalSection(&pTest->m_csMasterOp);
	} // end if (took lock)

	return (hr);
} // CTNSlave::GetTestersMachineInfoInternal
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::PeriodicSendExpired()"
//==================================================================================
// CTNSlave::PeriodicSendExpired
//----------------------------------------------------------------------------------
//
// Description: Function that gets called whenever a periodic send expires.  It
//				does whatever processing is appropriate and removes the send from
//				the list.
//
// Arguments:
//	PTNPERIODICSEND pPeriodicSend	Pointer to send that expired.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::PeriodicSendExpired(PTNPERIODICSEND pPeriodicSend)
{
	HRESULT					hr;
	PVOID					pvAddress = NULL;
	DWORD					dwAddressSize = 0;
	BOOL					fFreeContext = TRUE;
	PREACHCHECKCONTEXT		pRCContext = NULL;


	switch (((PPERIODICSENDCONTEXT) pPeriodicSend->m_pvUserContext)->dwType)
	{
		case PSCT_QUERYMETAMASTER:
			DPL(0, "Failed to query meta-master for sessions!", 0);
			this->Log(TNLST_CRITICAL, "Failed to query meta-master for sessions!", 0);

			this->m_fQueryingMetaMaster = FALSE;

			// Ping the UI to let it know
			if (! SetEvent(this->m_hCompletionOrUpdateEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't set event %x!", 1, this->m_hCompletionOrUpdateEvent);
				goto DONE;
			} // end if (couldn't set event)

			this->m_pSessionPeriodicSend->m_dwRefCount--;
			// This should never hit 0, because it should be the same as the passed
			// in pPeriodicSend, and our caller has a reference to that.
			if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
			{
				DPL(0, "Deleting session periodic send (%x)!?  DEBUGBREAK()-ing.",
					1, this->m_pSessionPeriodicSend->m_dwRefCount);

				DEBUGBREAK();

				delete (this->m_pSessionPeriodicSend);
			} // end if (last reference)

			this->m_pSessionPeriodicSend = NULL;
		  break;

		case PSCT_JOINDIRECT:
			DPL(0, "Failed to join the specified master!", 0);
			this->Log(TNLST_CRITICAL, "Failed to join the specified master!", 0);

			this->m_fShakingHands = FALSE;

			// Ping the UI to let it know
			if (! SetEvent(this->m_hCompletionOrUpdateEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't set event %x!", 1, this->m_hCompletionOrUpdateEvent);
				goto DONE;
			} // end if (couldn't set event)

			this->m_pSessionPeriodicSend->m_dwRefCount--;
			// This should never hit 0, because it should be the same as the passed
			// in pPeriodicSend, and our caller has a reference to that.
			if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
			{
				DPL(0, "Deleting session periodic send (%x)!?  DEBUGBREAK()-ing.",
					1, this->m_pSessionPeriodicSend->m_dwRefCount);

				DEBUGBREAK();

				delete (this->m_pSessionPeriodicSend);
			} // end if (last reference)

			this->m_pSessionPeriodicSend = NULL;
		  break;

		case PSCT_ENUM:
			DPL(0, "Failed to find any sessions by broadcasting!", 0);
			this->Log(TNLST_CRITICAL, "Failed to find any sessions by broadcasting!", 0);

			this->m_fReadyToConnect = FALSE;

			// Ping the UI to let it know
			if (! SetEvent(this->m_hCompletionOrUpdateEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't set event %x!", 1, this->m_hCompletionOrUpdateEvent);
				goto DONE;
			} // end if (couldn't set event)


			this->m_pSessionPeriodicSend->m_dwRefCount--;
			// This should never hit 0, because it should be the same as the passed
			// in pPeriodicSend, and our caller has a reference to that.
			if (this->m_pSessionPeriodicSend->m_dwRefCount == 0)
			{
				DPL(0, "Deleting session periodic send (%x)!?  DEBUGBREAK()-ing.",
					1, this->m_pSessionPeriodicSend->m_dwRefCount);

				DEBUGBREAK();

				delete (this->m_pSessionPeriodicSend);
			} // end if (last reference)

			this->m_pSessionPeriodicSend = NULL;
		  break;

		case PSCT_REACHCHECK:
			pRCContext = (PREACHCHECKCONTEXT) pPeriodicSend->m_pvUserContext;

			if (pRCContext->dwCurrentAddressString == pRCContext->dwTotalAddressStrings)
			{
				DPL(0, "WARNING: All %u reach check address strings have been tried with no response!",
					1, pRCContext->dwTotalAddressStrings);

				this->Log(TNLST_CRITICAL,
						"WARNING: All reach check address strings have been tried with no response!", 0);


				// Complete the result.
				hr = this->DoConnectReachCheckResult(pRCContext->pReachCheck,
													FALSE,
													WAIT_TIMEOUT,
													NULL, 0);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't send ConnectReachCheckReply message!", 0);
					//goto DONE;
				} // end if (couldn't send message)

				// Context will get cleaned up below.

			} // end if (no more address strings)
			else
			{
				char*							pszTemp;
				PCTRLMSG_INTERSLAVEREACHCHECK	pInterSlaveReachCheckMsg;
				DWORD							dwMsgSize;



				// Remove the reach check's reference to the periodic send.  It
				// should not be being deleted right now (because it's also
				// being passed in, so our caller must have a ref).
#ifdef DEBUG
				// Make sure it's the expected periodic send.
				if (pRCContext->pReachCheck->m_pPeriodicSend != pPeriodicSend)
				{
					DPL(0, "Reach check's periodic send (%x) is not the same as one passed in (%x)!  DEBUGBREAK()-ing.",
						2, pRCContext->pReachCheck->m_pPeriodicSend,
						pPeriodicSend);
					DEBUGBREAK();
				} // end if (reach checks differ)
#endif // DEBUG

				pRCContext->pReachCheck->m_pPeriodicSend->m_dwRefCount--;
				if (pRCContext->pReachCheck->m_pPeriodicSend->m_dwRefCount == 0)
				{
					DPL(0, "Deleting periodic send %x!?  DEBUGBREAK()-ing",
						1, pRCContext->pReachCheck->m_pPeriodicSend);
					DEBUGBREAK();
					//delete (pReachCheck->m_pPeriodicSend);
				} // end if (can delete item)
				else
				{
					DPL(7, "Not deleting periodic send %x, it's refcount is %u.",
						2, pRCContext->pReachCheck->m_pPeriodicSend,
						pRCContext->pReachCheck->m_pPeriodicSend->m_dwRefCount);
				} // end else (can't delete item)
				pRCContext->pReachCheck->m_pPeriodicSend = NULL;



				// Increment counter after get field pointer cause offset is
				// zero-based.  16 is the size of each entry.
				pszTemp = pRCContext->pszAddressStrings
						+ (pRCContext->dwCurrentAddressString * 16);

				pRCContext->dwCurrentAddressString++;

				DPL(1, "Trying address string %u of %u (\"%s\").",
					3, pRCContext->dwCurrentAddressString,
					pRCContext->dwTotalAddressStrings,
					pszTemp);


				// Ignore error, assume BUFFER_TOO_SMALL
				pPeriodicSend->m_pCtrlComm->ConvertStringToAddress(pszTemp,
																	pRCContext->pReachCheck->m_pvMethodData,
																	pRCContext->pReachCheck->m_dwMethodDataSize,
																	pvAddress,
																	&dwAddressSize);

				pvAddress = LocalAlloc(LPTR, dwAddressSize);
				if (pvAddress == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				hr = pPeriodicSend->m_pCtrlComm->ConvertStringToAddress(pszTemp,
																		pRCContext->pReachCheck->m_pvMethodData,
																		pRCContext->pReachCheck->m_dwMethodDataSize,
																		pvAddress,
																		&dwAddressSize);
				if (hr != S_OK)
				{
					DPL(0, "Couldn't convert IP string \"%s\" to address!",
						1, pszTemp);
					goto DONE;
				} // end if (couldn't add check to list)


				dwMsgSize = sizeof (CTRLMSG_INTERSLAVEREACHCHECK)
							+ dwAddressSize;

				pInterSlaveReachCheckMsg = (PCTRLMSG_INTERSLAVEREACHCHECK) LocalAlloc(LPTR, dwMsgSize);
				if (pInterSlaveReachCheckMsg == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				pInterSlaveReachCheckMsg->dwSize = dwMsgSize;
				pInterSlaveReachCheckMsg->dwType = CTRLMSGID_INTERSLAVEREACHCHECK;
				CopyMemory(&(pInterSlaveReachCheckMsg->id),
							&(this->m_executor.m_id),
							sizeof (TNCTRLMACHINEID));
				pInterSlaveReachCheckMsg->dwID = pRCContext->pReachCheck->m_dwID;
				pInterSlaveReachCheckMsg->fGuaranteed = pPeriodicSend->m_fGuaranteed;
				pInterSlaveReachCheckMsg->dwUsedAddressSize = dwAddressSize;

				CopyMemory((pInterSlaveReachCheckMsg + 1), pvAddress,
							dwAddressSize);


				// Start a new send, using the new address and message,
				// but same of everything else.
				hr = this->StartPeriodicSend(pPeriodicSend->m_pCtrlComm,
											pPeriodicSend->m_fGuaranteed,
											pvAddress,
											dwAddressSize,
											pInterSlaveReachCheckMsg,
											dwMsgSize,
											pPeriodicSend->m_dwInterval,
											pPeriodicSend->m_dwTimeout,
											pRCContext,
											&(pRCContext->pReachCheck->m_pPeriodicSend));

				LocalFree(pInterSlaveReachCheckMsg);
				pInterSlaveReachCheckMsg = NULL;

				if (hr != S_OK)
				{
					DPL(0, "Couldn't start periodic send!", 0);
					goto DONE;
				} // end if (couldn't start send)


				// We reused the context in the next periodic send, so don't
				// free it.
				fFreeContext = FALSE;
				pPeriodicSend->m_pvUserContext = NULL;
			} // end if (more address strings to try)
		  break;

		default:
			DPL(0, "What kind of periodic send context is type %u!?",
				1, ((PPERIODICSENDCONTEXT) pPeriodicSend->m_pvUserContext)->dwType);

			// It probably means the memory is deallocated, so don't bother freeing
			// it (it'll crash).
			fFreeContext = FALSE;

			hr = E_FAIL;
			goto DONE;
		  break;
	} // end switch (on send type)


DONE:

	// In almost all cases, we're done with the context, so free it.
	if (fFreeContext)
	{
		DPL(5, "Freeing context %x, reachcheck = %s.",
			2, pPeriodicSend->m_pvUserContext,
			((pRCContext != NULL) ? "TRUE" : "FALSE"));

		// ReachCheck contexts have other items in them that need to be freed.
		if (pRCContext != NULL)
		{
			if (pRCContext->pReachCheck != NULL)
			{
				pRCContext->pReachCheck->m_dwRefCount--;
				if (pRCContext->pReachCheck->m_dwRefCount == 0)
				{
					DPL(7, "Deleting reach check %x.",
						1, pRCContext->pReachCheck);
					delete (pRCContext->pReachCheck);
				} // end if (last reference)
				else
				{
					DPL(7, "Not deleting reach check %x, its refcount is %u.",
						2, pRCContext->pReachCheck,
						pRCContext->pReachCheck->m_dwRefCount);
				} // end else (not last reference)
				pRCContext->pReachCheck = NULL;
			} // end if (still have reach check)

			LocalFree(pRCContext->pszAddressStrings);
			pRCContext->pszAddressStrings = NULL;
		} // end if (still have reach check context)

		LocalFree(pPeriodicSend->m_pvUserContext);
		pPeriodicSend->m_pvUserContext = NULL;
	} // end if (should free context)

	if (pvAddress != NULL)
	{
		LocalFree(pvAddress);
		pvAddress = NULL;
	} // end if (allocated memory)

	return (hr);
} // CTNSlave::PeriodicSendExpired
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::HandleMessage()"
//==================================================================================
// CTNSlave::HandleMessage
//----------------------------------------------------------------------------------
//
// Description: Handles an incoming control session message.
//
// Arguments:
//	PVOID* ppvFromAddress		Pointer to pointer to data describing ctrl comm
//								from address.
//	DWORD dwFromAddressSize		Size of from address data.
//	PVOID pvData				Pointer to data received by ctrl comm.
//	DWORD dwDataSize			Size of data.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::HandleMessage(PVOID* ppvFromAddress, DWORD dwFromAddressSize,
								  PVOID pvData, DWORD dwDataSize)
{
	PCTRLMSG_GENERIC	pGenericMsg = NULL;


	if (this == NULL)
	{
		DPL(0, "Slave object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (slave object is invalid)

	if ((*ppvFromAddress) == NULL)
	{
		DPL(0, "WARNING!  No from address!", 0);
	} // end if (no from address info)

	if (dwDataSize < sizeof (CTRLMSG_GENERIC))
	{
		DPL(0, "Data too small to be valid message!  Ignoring.", 0);
		return (S_OK);
	} // end if (smaller than the smallest valid message)

	pGenericMsg = (PCTRLMSG_GENERIC) pvData;
	
	if (pGenericMsg->dwSize != dwDataSize)
	{
		DPL(0, "Incomplete or invalid message (expected size %i bytes differs from actual size %i bytes)!  Ignoring.",
			2, pGenericMsg->dwSize, dwDataSize);
		return (S_OK);
	} // end if (didn't get complete/valid message)
	
	switch(pGenericMsg->dwType)
	{
		case CTRLMSGID_ENUM:
			// Ignore these broadcasts.
		  break;

		case CTRLMSGID_ENUMREPLY:
			if (dwDataSize < sizeof (CTRLMSG_ENUMREPLY))
			{
				DPL(0, "Data too small to be valid EnumReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid enumreply message)

			return (this->HandleEnumReplyMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_ENUMREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_HANDSHAKEREPLY:
			if (dwDataSize < sizeof (CTRLMSG_HANDSHAKEREPLY))
			{
				DPL(0, "Data too small to be valid HandshakeReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid handshakereply message)

			return (this->HandleHandshakeReplyMsg(ppvFromAddress, dwFromAddressSize,
												(PCTRLMSG_HANDSHAKEREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_JOINREPLY:
			if (dwDataSize < sizeof (CTRLMSG_JOINREPLY))
			{
				DPL(0, "Data too small to be valid JoinReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid joinreply message)

			return (this->HandleJoinReplyMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_JOINREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_TESTINGSTATUS:
			if (dwDataSize < sizeof (CTRLMSG_TESTINGSTATUS))
			{
				DPL(0, "Data too small to be valid TestingStatus message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid testingstatus message)

			return (this->HandleTestingStatusMsg(ppvFromAddress, dwFromAddressSize,
												(PCTRLMSG_TESTINGSTATUS) pGenericMsg));
		  break;

		case CTRLMSGID_NEWTEST:
			if (dwDataSize < sizeof (CTRLMSG_NEWTEST))
			{
				DPL(0, "Data too small to be valid NewTest message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid newtest message)

			return (this->HandleNewTestMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_NEWTEST) pGenericMsg));
		  break;

		case CTRLMSGID_ANNOUNCETESTREPLY:
			if (dwDataSize < sizeof (CTRLMSG_ANNOUNCETESTREPLY))
			{
				DPL(0, "Data too small to be valid AnnounceTestReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid announcetestreply message)

			return (this->HandleAnnounceTestReplyMsg(ppvFromAddress, dwFromAddressSize,
													(PCTRLMSG_ANNOUNCETESTREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_SYNCREPLY:
			if (dwDataSize < sizeof (CTRLMSG_SYNCREPLY))
			{
				DPL(0, "Data too small to be valid SyncReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid syncreply message)

			return (this->HandleSyncReplyMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_SYNCREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_USERRESPONSE:
			if (dwDataSize < sizeof (CTRLMSG_USERRESPONSE))
			{
				DPL(0, "Data too small to be valid UserResponse message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid syncreply message)

			return (this->HandleUserResponseMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_USERRESPONSE) pGenericMsg));
		  break;

		case CTRLMSGID_IDLEREPLY:
			if (dwDataSize < sizeof (CTRLMSG_IDLEREPLY))
			{
				DPL(0, "Data too small to be valid IdleReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid idlereply message)

			return (this->HandleIdleReplyMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_IDLEREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_DUMPLOG:
			if (dwDataSize < sizeof (CTRLMSG_DUMPLOG))
			{
				DPL(0, "Data too small to be valid DumpLog message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid dumplog message)

			return (this->HandleDumpLogMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_DUMPLOG) pGenericMsg));
		  break;

		case CTRLMSGID_BREAK:
			if (dwDataSize < sizeof (CTRLMSG_BREAK))
			{
				DPL(0, "Data too small to be valid Break message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid break message)

			return (this->HandleBreakMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_BREAK) pGenericMsg));
		  break;

		case CTRLMSGID_METAMASTERREPLY:
			if (dwDataSize < sizeof (CTRLMSG_METAMASTERREPLY))
			{
				DPL(0, "Data too small to be valid MetaMasterReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid metamasterreply message)

			return (this->HandleMetaMasterReplyMsg(ppvFromAddress, dwFromAddressSize,
													(PCTRLMSG_METAMASTERREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_MASTERPINGSLAVE:
			if (dwDataSize < sizeof (CTRLMSG_MASTERPINGSLAVE))
			{
				DPL(0, "Data too small to be valid MasterPingSlave message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid metamasterreply message)

			return (this->HandleMasterPingSlaveMsg(ppvFromAddress, dwFromAddressSize,
													(PCTRLMSG_MASTERPINGSLAVE) pGenericMsg));
		  break;

		case CTRLMSGID_LOSTTESTER:
			if (dwDataSize < sizeof (CTRLMSG_LOSTTESTER))
			{
				DPL(0, "Data too small to be valid LostTester message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid losttester message)

			return (this->HandleLostTesterMsg(ppvFromAddress, dwFromAddressSize,
											(PCTRLMSG_LOSTTESTER) pGenericMsg));
		  break;

		case CTRLMSGID_ACCEPTREACHCHECK:
			if (dwDataSize < (sizeof (CTRLMSG_ACCEPTREACHCHECK)))
			{
				DPL(0, "Data too small to be valid AcceptReachCheck message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid acceptreachcheck message)

			return (this->HandleAcceptReachCheckMsg(ppvFromAddress, dwFromAddressSize,
													(PCTRLMSG_ACCEPTREACHCHECK) pGenericMsg));
		  break;

		case CTRLMSGID_CONNECTREACHCHECK:
			if (dwDataSize < (sizeof (CTRLMSG_CONNECTREACHCHECK)))
			{
				DPL(0, "Data too small to be valid ConnectReachCheck message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid connectreachcheck message)

			return (this->HandleConnectReachCheckMsg(ppvFromAddress, dwFromAddressSize,
													(PCTRLMSG_CONNECTREACHCHECK) pGenericMsg));
		  break;

		case CTRLMSGID_INTERSLAVEREACHCHECK:
			if (dwDataSize < sizeof (CTRLMSG_INTERSLAVEREACHCHECK))
			{
				DPL(0, "Data too small to be valid InterSlaveReachCheck message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid interslavereachcheck message)

			return (this->HandleInterSlaveReachCheckMsg(ppvFromAddress, dwFromAddressSize,
														(PCTRLMSG_INTERSLAVEREACHCHECK) pGenericMsg));
		  break;

		case CTRLMSGID_INTERSLAVEREACHCHECKREPLY:
			if (dwDataSize < sizeof (CTRLMSG_INTERSLAVEREACHCHECKREPLY))
			{
				DPL(0, "Data too small to be valid InterSlaveReachCheckReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid interslavereachcheckreply message)

			return (this->HandleInterSlaveReachCheckReplyMsg(ppvFromAddress, dwFromAddressSize,
															(PCTRLMSG_INTERSLAVEREACHCHECKREPLY) pGenericMsg));
		  break;

		case CTRLMSGID_GETMACHINEINFOREPLY:
			if (dwDataSize < sizeof (CTRLMSG_GETMACHINEINFOREPLY))
			{
				DPL(0, "Data too small to be valid GetMachineInfoReply message!  Ignoring.", 0);
				break;
			} // end if (smaller than the smallest valid getmachineinforeply message)

			return (this->HandleGetMachineInfoReplyMsg(ppvFromAddress, dwFromAddressSize,
													(PCTRLMSG_GETMACHINEINFOREPLY) pGenericMsg));
		  break;

		default:
			DPL(0, "Message of invalid/unknown type (%i)!  Ignoring.", 1, pGenericMsg->dwType);
		  break;
	} // end switch (on message type)

	return (S_OK);
} // CTNSlave::HandleMessage
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::SendReadyForFirstTest()"
//==================================================================================
// CTNSlave::SendReadyForFirstTest
//----------------------------------------------------------------------------------
//
// Description: Lets the testmaster know we're ready to test, and gets the first
//				test to run.
//
// Arguments: None.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::SendReadyForFirstTest(void)
{
	HRESULT					hr;
	PTNSENDDATA				pSendData = NULL;
	PCTRLMSG_READYTOTEST	pReadyToTestMsg = NULL;



	if (((PCOMMDATA) this->m_pvTestmasterCommData)->fDropped)
	{
#pragma BUGBUG(vanceo, "Add TNERR_CONNECTIONDROPPED check to all sendings")
		DPL(0, "Can't send ready of first test message to master because the connection went down!", 0);
		hr = TNERR_CONNECTIONDROPPED;
		goto DONE;
	} // end if (connection to master went down)



	// If we're not in poke mode, request our first test.
	if (this->m_executor.m_dwMode == TNMODE_POKE)
	{
		DPL(3, "Notifying master that we're ready to test.", 0);
	} // end if (we're in poke mode)
	else
	{
		DPL(3, "Notifying master of readiness and requesting first test.", 0);
	} // end else (we're not in poke mode)

	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_READYTOTEST);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pReadyToTestMsg = (PCTRLMSG_READYTOTEST) pSendData->m_pvData;
	pReadyToTestMsg->dwSize = pSendData->m_dwDataSize;
	pReadyToTestMsg->dwType = CTRLMSGID_READYTOTEST;

	CopyMemory(&(pReadyToTestMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated object)

	return (hr);
} // CTNSlave::SendReadyForFirstTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::DoIdle()"
//==================================================================================
// CTNSlave::DoIdle
//----------------------------------------------------------------------------------
//
// Description: Does some housekeeping since we've got nothing to do.  Pings the
//				master to make sure he still knows we're waiting on him, if that's
//				the case.
//
// Arguments:
//	DWORD dwCurrentOp	Current operation (see CTRLIDLE_xxx) for values.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::DoIdle(DWORD dwCurrentOp)
{
	HRESULT				hr = S_OK;
	PTNSENDDATA			pSendData = NULL;
	PCTRLMSG_IDLE		pIdleMsg = NULL;


	/*
	if (! this->m_bInSession)
	{
		DPL(0, "Not sending message because not in a session!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we're not in a session right now)
	*/

	if (((PCOMMDATA) this->m_pvTestmasterCommData)->fDropped)
	{
#pragma BUGBUG(vanceo, "Add this everywhere (and have better logic?)")
		DPL(0, "Can't idle (op %u) because connection to master dropped!",
			1, dwCurrentOp);


		// Disconnect from the master so the receive thread doesn't go nuts.
		hr = this->m_pCtrlComm->UnbindDataFromAddress((PCOMMDATA) this->m_pvTestmasterCommData);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't unbind master connection!  %e", 1, hr);
		} // end if (couldn't unbind data)


		hr = TNERR_CONNECTIONDROPPED;
		goto DONE;
	} // end if (the connection to the master dropped)


	DPL(1, "Idling (current op = %u).", 1, dwCurrentOp);



	// If we've been sitting here without any data from the master for a while,
	// something's up.
	if (GetTickCount() > this->m_dwLastMasterReceive + NO_MASTER_TRAFFIC_TIME_WARNING)
	{
#pragma TODO(vanceo, "Improve")
		DPL(0, "WARNING: Haven't heard from master in a while!", 0);
		this->Log(TNLST_CONTROLLAYER_INFO, "WARNING: haven't heard from master in a while!", 0);
	} // end if (haven't heard from master in a while)


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_IDLE);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pIdleMsg = (PCTRLMSG_IDLE) pSendData->m_pvData;
	pIdleMsg->dwSize = pSendData->m_dwDataSize;
	pIdleMsg->dwType = CTRLMSGID_IDLE;

	CopyMemory(&(pIdleMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pIdleMsg->dwWaitingOp = dwCurrentOp;

	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send object)

	return (hr);
} // CTNSlave::DoIdle
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::StartPeriodicSend()"
//==================================================================================
// CTNSlave::StartPeriodicSend
//----------------------------------------------------------------------------------
//
// Description: Keeps trying to send a piece of data until the timeout expires or
//				it is stopped using the returned object.
//
// Arguments:
//	PTNCTRLCOMM pCtrlComm				Pointer to control comm object to use when
//										sending.
//	BOOL fGuaranteed					Whether to send guaranteed or not.
//	PVOID pvAddress						Pointer to address to send to.
//	DWORD dwAddressSize					Size of address to send to.
//	PVOID pvData						Pointer to data to send.
//	DWORD dwDataSize					Size of data to send.
//	DWORD dwInterval					How often to retry sending in ticks, or 0
//										to send only once.
//	DWORD dwTimeout						How long to keep retrying in ticks (or wait,
//										if dwInterval is 0) before stopping.
//	PVOID pvUserContext					Context to use in the callback if the send
//										times out.
//	PTNPERIODICSEND* ppPeriodicSend		Place to store pointer to resulting
//										CTNPeriodicSend object (used for cancelling
//										the send).  This object will have a refcount
//										for the caller already upon return.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::StartPeriodicSend(PTNCTRLCOMM pCtrlComm, BOOL fGuaranteed,
									PVOID pvAddress, DWORD dwAddressSize,
									PVOID pvData, DWORD dwDataSize,
									DWORD dwInterval, DWORD dwTimeout,
									PVOID pvUserContext,
									PTNPERIODICSEND* ppPeriodicSend)
{
	HRESULT					hr;
	PVOID					pvCallersCaller = NULL;
	DWORD					dwThreadID;


	DPL(9, "==> (%x, %B, %x, %u, %x, %u, %u, %u, %x, %x)",
		10, pCtrlComm,
		fGuaranteed,
		pvAddress, dwAddressSize,
		pvData, dwDataSize,
		dwInterval, dwTimeout,
		pvUserContext,
		ppPeriodicSend);


#ifdef DEBUG
	if ((*ppPeriodicSend) != NULL)
	{
		DPL(0, "About to overwrite periodic send %x!  DEBUGBREAK()-ing.", 1, (*ppPeriodicSend));
		DEBUGBREAK();
	} // end if (may be overwriting periodic send)
#endif // DEBUG

	(*ppPeriodicSend) = new (CTNPeriodicSend);
	if ((*ppPeriodicSend) == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate object)

	(*ppPeriodicSend)->m_dwRefCount++; // its in use

	(*ppPeriodicSend)->m_fGuaranteed = fGuaranteed;

	(*ppPeriodicSend)->m_dwAddressSize = dwAddressSize;
	(*ppPeriodicSend)->m_pvAddress = LocalAlloc(LPTR, (*ppPeriodicSend)->m_dwAddressSize);
	if ((*ppPeriodicSend)->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)

	CopyMemory((*ppPeriodicSend)->m_pvAddress, pvAddress,
				(*ppPeriodicSend)->m_dwAddressSize);


	(*ppPeriodicSend)->m_dwDataSize = dwDataSize;
	(*ppPeriodicSend)->m_pvData = LocalAlloc(LPTR, (*ppPeriodicSend)->m_dwDataSize);
	if ((*ppPeriodicSend)->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)

	CopyMemory((*ppPeriodicSend)->m_pvData, pvData,
				(*ppPeriodicSend)->m_dwDataSize);


	TNStackGetCallersAddress(&((*ppPeriodicSend)->m_pvSubmittersAddress),
							&pvCallersCaller);

	pCtrlComm->m_dwRefCount++; // send is using it
	(*ppPeriodicSend)->m_pCtrlComm = pCtrlComm;
	(*ppPeriodicSend)->m_dwInterval = dwInterval;
	(*ppPeriodicSend)->m_dwLastSent = 0;
	(*ppPeriodicSend)->m_dwTimeout = dwTimeout;
	(*ppPeriodicSend)->m_pvUserContext = pvUserContext;


	hr = this->m_periodicsends.Add((*ppPeriodicSend));
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add periodic send %x to queue!", 1, (*ppPeriodicSend));
		goto ERROR_EXIT;
	} // end if (couldn't add periodic send)


	// If the thread isn't running, start it.
	if (this->m_hPeriodicSendThread == NULL)
	{
		this->m_hPeriodicSendThread = CreateThread(NULL, 0, SlavePeriodicSendThreadProc,
													this, 0, &dwThreadID);
		if (this->m_hPeriodicSendThread == NULL)
		{
			hr = GetLastError();

			if (hr == S_OK)
				hr = E_FAIL;

			DPL(0, "Couldn't create thread!", 0);
			goto ERROR_EXIT;
		} // end if (couldn't create thread)
	} // end if (thread isn't running)


	// Kick it to let it know it has something to check right away.
	if (! SetEvent(this->m_periodicsends.m_hSendDataEvent))
	{
		hr = GetLastError();

		if (hr == S_OK)
			hr = E_FAIL;

		DPL(0, "Couldn't set periodic send event %x!",
			1, this->m_periodicsends.m_hSendDataEvent);

		goto ERROR_EXIT;
	} // end if (couldn't set event)


	DPL(9, "<== S_OK", 0);

	return (S_OK);
	

ERROR_EXIT:

	DPL(9, "<== %e", 1, hr);

	if ((*ppPeriodicSend) != NULL)
	{
		(*ppPeriodicSend)->m_dwRefCount--;
		if ((*ppPeriodicSend)->m_dwRefCount == 0)
		{
			DPL(7, "Deleting periodic send %x.", 1, (*ppPeriodicSend));
			delete ((*ppPeriodicSend));
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting periodic send %x, its refcount is %u.",
				2, (*ppPeriodicSend), (*ppPeriodicSend)->m_dwRefCount);
		} // end else (not last reference)
		(*ppPeriodicSend) = NULL;
	} // end if (have object)

	return (hr);
} // CTNSlave::StartPeriodicSend
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::StopPeriodicSend()"
//==================================================================================
// CTNSlave::StopPeriodicSend
//----------------------------------------------------------------------------------
//
// Description: Stops the passed in periodic send, if it exists.
//
// Arguments:
//	PTNPERIODICSEND pPeriodicSend	Send to cancel.
//
// Returns: S_OK if successful or error code otherwise.
//==================================================================================
HRESULT CTNSlave::StopPeriodicSend(PTNPERIODICSEND pPeriodicSend)
{
	HRESULT		hr;


	DPL(9, "==>(%x)", 1, pPeriodicSend);

	this->m_periodicsends.EnterCritSection();

	hr = this->m_periodicsends.RemoveFirstReference(pPeriodicSend);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't remove periodic send %x from list!", 1, pPeriodicSend);
		//goto DONE;
	} // end if (couldn't remove item)


	/*
	// Notify the thread that the list changed.
	if(! SetEvent(this->m_periodicsends.m_hSendDataEvent))
	{
		hr = GetLastError();

		DPL(0, "Couldn't set periodic send list event %x!",
			1, this->m_periodicsends.m_hSendDataEvent);

		if (hr == S_OK)
			hr = E_FAIL;

		goto DONE;
	} // end if (couldn't set event)
	*/

	this->m_periodicsends.LeaveCritSection();

	// Not checking refcount because it is assumed the caller will have one
	DPL(9, "<== (%x refcount %u) %e",
		3, pPeriodicSend, pPeriodicSend->m_dwRefCount, hr);

	return (hr);
} // CTNSlave::StopPeriodicSend
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::KillPeriodicSendThread()"
//==================================================================================
// CTNSlave::KillPeriodicSendThread
//----------------------------------------------------------------------------------
//
// Description: Shuts down the thread that enumerates/joins/etc. and releases the
//				events used.
//				The boolean passed in should only be set to TRUE if the caller is
//				the PeriodicSendThread, FALSE in all other cases.
//
// Arguments:
//	BOOL fKillingSelf	TRUE if being called from within the PeriodicSendThread
//						itself, FALSE otherwise.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::KillPeriodicSendThread(BOOL fKillingSelf)
{
	DPL(9, "==> (%B)", 1, fKillingSelf);

	if (this->m_hPeriodicSendThread != NULL)
	{
		if (! fKillingSelf)
		{
			if (this->m_hKillPeriodicSendThreadEvent == NULL) // ack, we won't be able to tell it to die
				return (E_FAIL);

			if (! SetEvent(this->m_hKillPeriodicSendThreadEvent))
				return (E_FAIL);

			switch (WaitForSingleObject(this->m_hPeriodicSendThread, TIMEOUT_DIE_PERIODICSENDTHREAD))
			{
				case WAIT_OBJECT_0:
					// what we want
				  break;

				case WAIT_TIMEOUT:
					DPL(0, "Waited %i ms for periodic send thread to die but it didn't!",
						1, TIMEOUT_DIE_PERIODICSENDTHREAD);


#ifndef DONT_BREAK_ON_KILLTHREAD_TIMEOUT
					DEBUGBREAK();
#endif // DONT_BREAK_ON_KILLTHREAD_TIMEOUT

				  break;

				default:
					DPL(0, "Got unexpected return code from WaitForSingleObject on the periodic send thread!", 0);
				  break;
			} // end switch (on result of waiting for thread to die)
		} // end if (the thread isn't calling us)

		CloseHandle(this->m_hPeriodicSendThread);
		this->m_hPeriodicSendThread = NULL;
	} // end if (the send thread exists)

	if (this->m_hKillPeriodicSendThreadEvent != NULL)
	{
		CloseHandle(this->m_hKillPeriodicSendThreadEvent);
		this->m_hKillPeriodicSendThreadEvent = NULL;
	} // end if (have event)

	DPL(9, "<== S_OK", 0);

	return (S_OK);
} // CTNSlave::KillPeriodicSendThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



#ifndef _XBOX // no DB logging supported

#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::StartDBCase()"
//==================================================================================
// CTNSlave::StartDBCase
//----------------------------------------------------------------------------------
//
// Description: If this object is logging to the database, it is notified of the
//				start of the test case.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test to notify database of.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::StartDBCase(PTNTESTINSTANCES pTest)
{
	HRESULT		hr = S_OK;
	char*		pszTemp = NULL;

	// If we're not connected to the database, we're done.
	if (this->m_lpTMAgent == NULL)
		goto DONE;


	TNsprintf(&pszTemp, "%s-%s#%i", 3, pTest->m_pCase->m_pszID,
				pTest->m_pszInstanceID, pTest->GetSlavesTesterNum(&(this->m_executor.m_id)));

	// Ignore the error because AddNewCase fails if the case already exists.
	hr = this->m_lpTMAgent->AddNewCase(TN_DATABASE_APPID,
										pszTemp, pTest->m_pCase->m_pszName);
	/*
	if (hr != S_OK)
	{
		DPL(0, "Failed to add test case \"%s\" to database!", 1, pszTemp);
		TNsprintf_free(&pszTemp);
		goto DONE;
	} // end if (failed adding test case)
	*/


	hr = this->m_lpTMAgent->StartTestCase(pszTemp, pTest->m_pCase->m_pszName);
	if (hr != S_OK)
	{
		DPL(0, "Failed to notify database of test case \"%s\" start!", 1, pszTemp);
		TNsprintf_free(&pszTemp);
		goto DONE;
	} // end if (failed starting test case)

	TNsprintf_free(&pszTemp);


DONE:

	if (pszTemp != NULL)
		TNsprintf_free(&pszTemp);

	return (hr);
} // CTNSlave::StartDBCase
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#endif // ! XBOX


#ifndef _XBOX // no DB logging supported

#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::EndDBCase()"
//==================================================================================
// CTNSlave::EndDBCase
//----------------------------------------------------------------------------------
//
// Description: If this object is logging to the database, it is notified of the
//				end of the test case.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test to notify database of.
//	BOOL fSuccess			Whether the test was a success or not.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::EndDBCase(PTNTESTINSTANCES pTest, BOOL fSuccess)
{
	HRESULT		hr = S_OK;
	char*		pszTemp = NULL;
	char*		pszMemLog = NULL;



	// If we're not connected to the database, we're done.
	if (this->m_lpTMAgent == NULL)
		goto DONE;


	TNsprintf(&pszTemp, "UniqueID=%i\n", 1, pTest->m_dwUniqueID);
	hr = this->m_lpTMAgent->CaseLog(pszTemp);
	TNsprintf_free(&pszTemp);
	if (hr != S_OK)
	{
		DPL(0, "Failed logging unique ID to database!", 0);
		goto DONE;
	} // end if (failed logging to database)
	
	/*
	if (pTest->m_pszFriendlyName != NULL)
	{
		TNsprintf(&pszTemp, "FriendlyName=%s\n", 1, pTest->m_pszFriendlyName);
		hr = this->m_lpTMAgent->CaseLog(pszTemp);
		TNsprintf_free(&pszTemp);
		if (hr != S_OK)
		{
			DPL(0, "Failed logging test friendly name to database!", 0);
			goto DONE;
		} // end if (failed logging to database)
	} // end if (there's a friendly name)
	*/


	// If this wasn't a success, dump the last 5K of memory log to the
	// database.
	if (! fSuccess)
	{
		this->m_lpTMAgent->CaseLog("\n//------------------------------\n\n"); // ignore error

		pszMemLog = (char*) LocalAlloc(LPTR, 5120);
		if (pszMemLog == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)

		TNDebugDumpMemoryLogToString(pszMemLog, 5120);

		hr = this->m_lpTMAgent->CaseLog(pszMemLog);

		LocalFree(pszMemLog);
		pszMemLog = NULL;

		if (hr != S_OK)
		{
			DPL(0, "Failed dumping memory log to database!", 0);
			goto DONE;
		} // end if (failed logging to database)

		this->m_lpTMAgent->CaseLog("\n"); // ignore error
	} // end if (test failed)


	//BUGBUG using "PASS_SAVELOG" because using "PASS" causes it to erase the
	//		 CaseLog stuff
	hr = this->m_lpTMAgent->EndTestCase((fSuccess) ? "PASS_SAVELOG" : "FAIL");
	if (hr != S_OK)
	{
		DPL(0, "Failed notifying database of test case end!", 0);
		goto DONE;
	} // end if (failed ending test case)


DONE:

	if (pszMemLog != NULL)
	{
		LocalFree(pszMemLog);
		pszMemLog = NULL;
	} // end if (allocated string)

	if (pszTemp != NULL)
		TNsprintf_free(&pszTemp);

	return (hr);
} // CTNSlave::EndDBCase
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#endif // ! XBOX



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::DoConnectReachCheckResult()"
//==================================================================================
// CTNSlave::DoConnectReachCheckResult
//----------------------------------------------------------------------------------
//
// Description: Records the results of the reach check, and sends a reply to the
//				master.
//
// Arguments:
//	PTNREACHCHECK pReachCheck	Reach check which has a result.
//	BOOL fSuccess				Whether the connect was a success or not.
//	HRESULT hresult				Error code for connect, if any.
//	PVOID pvAddress				Pointer to address buffer that worked, if any.
//	DWORD dwAddressSize			Size of address buffer.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNSlave::DoConnectReachCheckResult(PTNREACHCHECK pReachCheck, BOOL fSuccess,
											HRESULT hresult, PVOID pvAddress,
											DWORD dwAddressSize)
{
	HRESULT								hr = S_OK;
	PTNSENDDATA							pSendData = NULL;
	PCTRLMSG_CONNECTREACHCHECKREPLY		pReplyMsg = NULL;


	/*
	if (! this->m_bInSession)
	{
		DPL(0, "Not sending message because not in a session!", 0);
		hr = ERROR_BAD_ENVIRONMENT;
		goto DONE;
	} // end if (we're not in a session right now)
	*/


	// Let the control comm object clean up, if it exists.
	if (pReachCheck->m_pCtrlComm != NULL)
	{
		// Stop the control layer.
		hr = pReachCheck->m_pCtrlComm->CleanupReachCheck(pReachCheck);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't cleanup TCP/IP reach check %u!",
				1, pReachCheck->m_dwID);
			goto DONE;
		} // end if (couldn't cleanup reach check)


		// Free up the control comm reference.

		pReachCheck->m_pCtrlComm->m_dwRefCount--;
		if (pReachCheck->m_pCtrlComm->m_dwRefCount == 0)
		{
			DPL(7, "Releasing and deleting control comm object %x.",
				1, pReachCheck->m_pCtrlComm);

			hr = pReachCheck->m_pCtrlComm->Release();
			if (hr != S_OK)
			{
				DPL(0, "Couldn't release control comm object %x!",
					1, pReachCheck->m_pCtrlComm);
				goto DONE;
			} // end if (couldn't release control comm)

			delete (pReachCheck->m_pCtrlComm);
		} // end if (last use of control comm)
		else
		{
			DPL(7, "Not releasing and deleting control comm object %x, its refcount is %u.",
				2, pReachCheck->m_pCtrlComm, pReachCheck->m_pCtrlComm->m_dwRefCount);
		} // end else (not last use of control comm)

		pReachCheck->m_pCtrlComm = NULL;
	} // end if (there's a control comm reference)


	// If there's a periodic send object still, clean it up.
	if (pReachCheck->m_pPeriodicSend != NULL)
	{
		pReachCheck->m_pPeriodicSend->m_dwRefCount--;
		if (pReachCheck->m_pPeriodicSend->m_dwRefCount == 0)
		{
			DPL(7, "Deleting periodic send %x.", 1, pReachCheck->m_pPeriodicSend);

			// If there's a context, we know it's allocated memory.  Free it.
			if (pReachCheck->m_pPeriodicSend->m_pvUserContext != NULL)
			{
				LocalFree(pReachCheck->m_pPeriodicSend->m_pvUserContext);
				pReachCheck->m_pPeriodicSend->m_pvUserContext = NULL;
			} // end if (there's a user context)

			delete (pReachCheck->m_pPeriodicSend);
		} // end if (can delete item)
		else
		{
			DPL(7, "Not deleting periodic send %x, it's refcount is %u.",
				2, pReachCheck->m_pPeriodicSend,
				pReachCheck->m_pPeriodicSend->m_dwRefCount);
		} // end else (can't delete item)
		pReachCheck->m_pPeriodicSend = NULL;
	} // end if (there's a control comm reference)



	pReachCheck->m_fResult = fSuccess;
	pReachCheck->m_hresult = hresult;
	if (pvAddress != NULL)
	{
		pReachCheck->m_pvAddress = LocalAlloc(LPTR, dwAddressSize);
		if (pReachCheck->m_pvAddress == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (out of memory)

		pReachCheck->m_dwAddressSize = dwAddressSize;

		CopyMemory(pReachCheck->m_pvAddress, pvAddress, dwAddressSize);
	} // end if (there's an address)


	pSendData = new (CTNSendData);
	if (pSendData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	pSendData->m_fGuaranteed = TRUE;
	pSendData->m_dwAddressSize = ((PCOMMDATA) this->m_pvTestmasterCommData)->dwAddressSize;
	pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
	if (pSendData->m_pvAddress == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (out of memory)

	CopyMemory(pSendData->m_pvAddress,
			((PCOMMDATA) this->m_pvTestmasterCommData)->pvAddress,
			pSendData->m_dwAddressSize);

	pSendData->m_dwDataSize = sizeof (CTRLMSG_CONNECTREACHCHECKREPLY);

	pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
	if (pSendData->m_pvData == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	pReplyMsg = (PCTRLMSG_CONNECTREACHCHECKREPLY) pSendData->m_pvData;
	pReplyMsg->dwSize = pSendData->m_dwDataSize;
	pReplyMsg->dwType = CTRLMSGID_CONNECTREACHCHECKREPLY;

	CopyMemory(&(pReplyMsg->id), &(this->m_executor.m_id),
				sizeof (TNCTRLMACHINEID));
	pReplyMsg->dwID = pReachCheck->m_dwID;
	pReplyMsg->fReachable = fSuccess;
	pReplyMsg->hresult = hresult;


	hr = this->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't add send item to queue!", 0);
		goto DONE;
	} // end if (failed to add item to queue)

	pSendData = NULL; // forget about it so it doesn't get freed below


DONE:

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (allocated a send object)

	return (hr);
} // CTNSlave::DoConnectReachCheckResult
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNSlave::GetNetStatInfo()"
//==================================================================================
// CTNSlave::GetNetStatInfo
//----------------------------------------------------------------------------------
//
// Description: Retrieves the current net stat info to the memory log.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void CTNSlave::GetNetStatInfo(void)
{
#ifndef _XBOX // no other processes supported, so can't call netstat
	HRESULT					hr;
	STARTUPINFO				si;
	PROCESS_INFORMATION		pi;
	char					szOutputFile[256];



	ZeroMemory(&si, sizeof (STARTUPINFO));
	si.cb = sizeof (STARTUPINFO);
	si.dwFlags = STARTF_USESTDHANDLES;
	si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
	si.hStdOutput = INVALID_HANDLE_VALUE;
	si.hStdError = GetStdHandle(STD_ERROR_HANDLE);

	ZeroMemory(&pi, sizeof (PROCESS_INFORMATION));



	wsprintf(szOutputFile, "netstatinfo_%u.txt", GetTickCount());

	DPL(1, "Retrieving net stat info to \"%s\".", 1, szOutputFile);


	// Create the batch file used to redirect netstat output.
	hr = FileCreateAndOpenFile(szOutputFile, FALSE, FALSE, TRUE, &(si.hStdOutput));
	if (hr != S_OK)
	{
		DPL(0, "Creating batch file \"%s\" failed!  Ignoring.  %e", 2, szOutputFile, hr);
		goto DONE;
	} // end if (failed creating file)


	// Launch the redirector batch file.
	if (! CreateProcess(NULL, "netstat -na", NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
	{
		hr = GetLastError();
		DPL(0, "Failed dumping net stat to \"%s\"!  Ignoring.  %e",
			2, szOutputFile, hr);
		goto DONE;
	} // end if (failed creating process)



	// Wait for netstat to finish.
	WaitForSingleObject(pi.hProcess, INFINITE);


	// Close the file before trying to read from it.
	CloseHandle(si.hStdOutput);
	si.hStdOutput = INVALID_HANDLE_VALUE;


	// Read the file generated
	hr = FileReadTextFile(szOutputFile, FILERTFO_SKIP_EMPTY_LINES,
						SlaveReadNetStatTempFileCB, NULL);
	if (hr != S_OK)
	{
		DPL(0, "Reading text file \"%s\" failed!  Ignoring.  %e",
			2, szOutputFile, hr);

		// Continue...
	} // end if (failed reading file)


	// There's an output file, so try to delete it.
	if (! DeleteFile(szOutputFile))
	{
		hr = GetLastError();
		DPL(0, "Couldn't delete temp net stat file \"%s\"!  Ignoring.  %e",
			2, szOutputFile, hr);
		// Continue...
	} // end if (couldn't delete file)


DONE:

	if (pi.hThread != NULL)
	{
		CloseHandle(pi.hThread);
		pi.hThread = NULL;
	} // end if (have thread handle)

	if (pi.hProcess != NULL)
	{
		CloseHandle(pi.hProcess);
		pi.hProcess = NULL;
	} // end if (have process handle)

	if (si.hStdOutput != INVALID_HANDLE_VALUE)
	{
		CloseHandle(si.hStdOutput);
		si.hStdOutput = NULL;
	} // end if (have output file handle)

#else // ! XBOX
#pragma TODO(tristanj, "No longer able to call netstat on a failure")
#endif // XBOX

} // CTNSlave::GetNetStatInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no DB logging supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"DBUnavailableDlgProc()"
//==================================================================================
// DBUnavailableDlgProc
//----------------------------------------------------------------------------------
//
// Description: DB logging unavailable choice dialog window procedure.
//
// Arguments:
//	HWND hWnd		Window handle.
//	UINT uMsg		Message identifier.
//	WPARAM wParam	Depends on message.
//	LPARAM lParam	Depends on message.
//
// Returns: Depends on message.
//==================================================================================
INT_PTR CALLBACK DBUnavailableDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static DWORD	dwSecs = 0;

	char			szTemp[64];


	switch (uMsg)
	{
		case WM_INITDIALOG:
			dwSecs = DBUNVAILABLE_DIALOG_TIMEOUT;

			if (dwSecs != 1)
				wsprintf(szTemp, "%i seconds.", dwSecs);
			else
				strcpy(szTemp, "1 second.");


			SetWindowText(GetDlgItem(hWnd, IDT_TIMER), szTemp);

			SetTimer(hWnd, 1, 1000, NULL);
		  break;

		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
				case IDYES:
					DPL(0, "User pressed 'Yes'.", 0);

					KillTimer(hWnd, 1);
					EndDialog(hWnd, IDYES);
				  break;

				case IDNO:
					DPL(0, "User pressed 'No'.", 0);

					KillTimer(hWnd, 1);
					EndDialog(hWnd, IDNO);
				  break;
			} // end switch (on the button pressed/control changed)
		  break;

		case WM_TIMER:
			dwSecs--;

			if (dwSecs > 0)
			{
				if (dwSecs != 1)
					wsprintf(szTemp, "%i seconds.", dwSecs);
				else
					strcpy(szTemp, "1 second.");

				SetWindowText(GetDlgItem(hWnd, IDT_TIMER), szTemp);

				SetTimer(hWnd, 1, 1000, NULL);
			} // end if (time limit has not been reached)
			else
			{
				KillTimer(hWnd, 1);
				EndDialog(hWnd, IDNO); // hit the NO button
			} // end else  (time limit has been reached)

			return (TRUE);
		  break;
	} // end switch (on the type of window message)

	return (DefWindowProc(hWnd, uMsg, wParam, lParam));
} // DBUnavailableDlgProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX





#undef DEBUG_SECTION
#define DEBUG_SECTION	"SlaveReadNetStatTempFileCB()"
//==================================================================================
// SlaveReadNetStatTempFileCB
//----------------------------------------------------------------------------------
//
// Description: Callback that handles a line read from a text file.
//
// Arguments:
//	char* szLine			Line that was read.
//	PFILELINEINFO pInfo		Line that was read.
//	PVOID pvContext			Pointer to context.  Cast as a READSCRIPTFILECONTEXT
//							pointer.
//	BOOL* pfStopReading		Pointer to boolean to set to TRUE to discontinue reading
//							from the file.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT SlaveReadNetStatTempFileCB(char* szLine, PFILELINEINFO pInfo, PVOID pvContext,
								BOOL* pfStopReading)
{
	DPL(1, "NETSTAT: %u: %s", 2, pInfo->dwLineNumber, szLine);

	return (S_OK);
} // SlaveReadNetStatTempFileCB
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"SlavePeriodicSendThreadProc()"
//==================================================================================
// SlavePeriodicSendThreadProc
//----------------------------------------------------------------------------------
//
// Description: This thread periodically wakes up and performs periodic sends.
//
// Arguments:
//	LPVOID lpvParameter		Thread startup parameter.  Cast to a pointer to a slave
//							object.
//
// Returns: 0 if all goes well.
//==================================================================================
DWORD WINAPI SlavePeriodicSendThreadProc(LPVOID lpvParameter)
{
	HRESULT				hr = S_OK;
	PTNSLAVE			pSlave = (PTNSLAVE) lpvParameter;
	HANDLE				ahWaitArray[3];
	DWORD				dwInterval;
	BOOL				fHaveSendLock = FALSE;
	int					i;
	PTNPERIODICSEND		pPeriodicSend = NULL;
	BOOL				fSend;
	PTNSENDDATA			pSendData = NULL;
	DWORD				dwCurrentTime;



	DPL(8, "Starting up.", 0);


	ahWaitArray[0] = pSlave->m_hKillPeriodicSendThreadEvent;
	ahWaitArray[1] = pSlave->m_periodicsends.m_hSendDataEvent;
	ahWaitArray[2] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array

	dwInterval = INFINITE; // wait for an item to kick us

	while (TRUE)
	{
		hr = WaitForMultipleObjects(2, ahWaitArray, FALSE, dwInterval);
		switch (hr)
		{
			case WAIT_OBJECT_0:
				// Time for the thread to die.
				hr = S_OK;
				goto DONE;
			  break;

			case WAIT_OBJECT_0 + 1:
				// There's a new item in the list, we'll just drop through...

			case WAIT_TIMEOUT:
				dwInterval = INFINITE; // items will override

				pSlave->m_periodicsends.EnterCritSection();
				fHaveSendLock = TRUE;

				// Loop through all the slaves in the list
				for(i = 0; i < pSlave->m_periodicsends.Count(); i++)
				{
					pPeriodicSend = (PTNPERIODICSEND) pSlave->m_periodicsends.GetItem(i);
					if (pPeriodicSend == NULL)
					{
						DPL(0, "Couldn't get periodic send %i!", 1, i);
						hr = E_FAIL;
						goto DONE;
					} // end if (couldn't get item)

					pPeriodicSend->m_dwRefCount++; // we're using it

					fSend = FALSE;
					dwCurrentTime = GetTickCount();


					// Check if it's the first time its being sent
					if (pPeriodicSend->m_dwFirstSent == 0)
					{
						pPeriodicSend->m_dwFirstSent = dwCurrentTime;
						fSend = TRUE;
					} // end if (this is the first time the item has been sent)
					else
					{
						// Only resend things that should be sent more than once.
						if (pPeriodicSend->m_dwInterval != 0)
						{
							// If it's past time to resend the item, do it.
							if ((GetTickCount() - pPeriodicSend->m_dwLastSent) >= pPeriodicSend->m_dwInterval)
								fSend = TRUE;
						} // end if (should resend)
					} // end else (not first time being sent)

					if (fSend)
					{
						// Copy the item and put it on the send queue.

						pSendData = new (CTNSendData);
						if (pSendData == NULL)
						{
							hr = E_OUTOFMEMORY;
							goto DONE;
						} // end if (out of memory)

						pSendData->m_fGuaranteed = pPeriodicSend->m_fGuaranteed;
						pSendData->m_dwAddressSize = pPeriodicSend->m_dwAddressSize;
						pSendData->m_pvAddress = LocalAlloc(LPTR, pSendData->m_dwAddressSize);
						if (pSendData->m_pvAddress == NULL)
						{
							hr = E_OUTOFMEMORY;
							goto DONE;
						} // end if (out of memory)

						CopyMemory(pSendData->m_pvAddress, pPeriodicSend->m_pvAddress,
								pSendData->m_dwAddressSize);

						pSendData->m_dwDataSize = pPeriodicSend->m_dwDataSize;

						pSendData->m_pvData = LocalAlloc(LPTR, pSendData->m_dwDataSize);
						if (pSendData->m_pvData == NULL)
						{
							hr = E_OUTOFMEMORY;
							goto DONE;
						} // end if (couldn't allocate memory)

						CopyMemory(pSendData->m_pvData, pPeriodicSend->m_pvData,
									pSendData->m_dwDataSize);


						hr = pPeriodicSend->m_pCtrlComm->m_sendqueue.AddSendData(pSendData);
						if (hr != S_OK)
						{
							DPL(0, "Couldn't add send item to queue!", 0);
							goto DONE;
						} // end if (failed to add item to queue)

						pSendData = NULL; // forget about it so it doesn't get freed below


						pPeriodicSend->m_dwLastSent = dwCurrentTime;
					} // end else if (should be sent)


					// If it's past the expire time, do it.
					if ((dwCurrentTime - pPeriodicSend->m_dwFirstSent) >= pPeriodicSend->m_dwTimeout)
					{
						// Pull the item from the list
						hr = pSlave->m_periodicsends.Remove(i);
						if (hr != S_OK)
						{
							DPL(0, "Couldn't remove periodic send %i from list!",
								1, i);
							goto DONE;
						} // end if (couldn't remove item)

						// We pulled it off the list, so don't screw up our index.
						i--;


						// Call the slave's callback.  It may add the send back to
						// the list.  That's cool, cause it will be added to the
						// end and the 'for' statement at the top will note that
						// the list grew again.
						hr = pSlave->PeriodicSendExpired(pPeriodicSend);
						if (hr != S_OK)
						{
							DPL(0, "Slave's periodic send expiration callback failed!", 0);
							goto DONE;
						} // end if (couldn't use slave callback)
					} // end if (the item expired)
					else
					{
						// It's not expired, so when should it be looked at again?

						// If there's an interval, calculate if it's going to be
						// the next thing to fire.
						if (pPeriodicSend->m_dwInterval != 0)
						{
							// If this needs to be sent before the currently
							// calculated interval, shorten it to fire in time for
							// this one.
							if ((pPeriodicSend->m_dwInterval - (dwCurrentTime - pPeriodicSend->m_dwLastSent)) < dwInterval)
								dwInterval = pPeriodicSend->m_dwInterval - (dwCurrentTime - pPeriodicSend->m_dwLastSent);
						} // end if (there's an interval)

						// If this needs to expire before the currently
						// calculated interval, shorten it to fire in time for
						// that.
						if ((pPeriodicSend->m_dwTimeout - (dwCurrentTime - pPeriodicSend->m_dwFirstSent)) < dwInterval)
							dwInterval = pPeriodicSend->m_dwTimeout - (dwCurrentTime - pPeriodicSend->m_dwFirstSent);
					} // end else (didn't expire)
					

					pPeriodicSend->m_dwRefCount--;
					if (pPeriodicSend->m_dwRefCount == 0)
					{
						DPL(7, "Deleting periodic send %x.", 1, pPeriodicSend);

						// If there's a context, we know it's allocated memory.  Free it.
						if (pPeriodicSend->m_pvUserContext != NULL)
						{
							LocalFree(pPeriodicSend->m_pvUserContext);
							pPeriodicSend->m_pvUserContext = NULL;
						} // end if (there's a user context)

						delete (pPeriodicSend);
					} // end if (last reference)
					else
					{
						DPL(7, "Not deleting periodic send %x, its refcount is %u.",
							2, pPeriodicSend, pPeriodicSend->m_dwRefCount);
					} // end else (not last reference)
					pPeriodicSend = NULL;
				} // end for (each send)

				fHaveSendLock = FALSE;
				pSlave->m_periodicsends.LeaveCritSection();
			  break;

			default:
				DPL(0, "Got unexpected result from WaitForMultipleObjects!", 0);
				goto DONE;
			  break;
		} // end switch (on wait result)
	} // end while (not done)


DONE:

	if (fHaveSendLock)
	{
		pSlave->m_periodicsends.LeaveCritSection();
		fHaveSendLock = FALSE;
	} // end if (have lock)

	if (pPeriodicSend != NULL)
	{
		pPeriodicSend->m_dwRefCount--;
		if (pPeriodicSend->m_dwRefCount == 0)
		{
			DPL(7, "Deleting periodic send %x.", 1, pPeriodicSend);

			// If there's a context, we know it's allocated memory.  Free it.
			if (pPeriodicSend->m_pvUserContext != NULL)
			{
				LocalFree(pPeriodicSend->m_pvUserContext);
				pPeriodicSend->m_pvUserContext = NULL;
			} // end if (there's a user context)

			delete (pPeriodicSend);
		} // end if (last reference)
		else
		{
			DPL(7, "Not deleting periodic send %x, its refcount is %u.",
				2, pPeriodicSend, pPeriodicSend->m_dwRefCount);
		} // end else (not last reference)
		pPeriodicSend = NULL;
	} // end if (have object)

	if (pSendData != NULL)
	{
		delete (pSendData);
		pSendData = NULL;
	} // end if (have object)

	if (hr != S_OK)
	{
		DPL(0, "%e", 1, hr);

		// Ignoring error
		pSlave->Log(TNLST_CRITICAL,
					"PeriodicSend thread exiting with failure!  %e",
					1, hr);
	} // end if (quitting with a failure)

	DPL(8, "Exiting.", 0);

	return (hr);
} // SlavePeriodicSendThreadProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
