; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\islixd.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_07EDDFIMDA@SlixD?3?5?$AA@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0CE@NOFOGAEA@Attempting?5to?5open?5isoch?5endpoin@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0BA@LIGGHOEI@returned?50x?$CF8x?6?$AA@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0BO@DJDHHGCC@StartTransfer?5returned?50x?$CF8x?6?$AA@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0CG@IMFPEJBO@SlixdIn?3?5Port?5?$CFd?0?5Slot?5?$CFd?0?5pud?$DN?$DN@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0CI@HEKMLLFL@SlixdIn?3?5de?9?$DODeviceFlags?5?$CG?5DF_CO@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0DA@OIAGLEAI@ERROR?$CB?5Can?8t?5send?5additional?5INs@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0CG@CDALMCND@ourendpoint?5?$DN?$DN?5NULL?5?$CG?$CG?5Endpoint?5@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0O@HFGOLHIC@?$CKlen?5?$DN?$DN?50?$CB?$CB?$CB?6?$AA@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0FE@IMMOFDKE@request?5completed?0?5with?5error?3?5?$CF@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0DB@IGCMIKNF@ERROR?$CB?5Can?8t?5send?5additional?5OUT@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0CD@DDCPLDCC@request?5completed?0?5with?5error?3?5?$CF@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0DC@PIBIDPPL@returned?5data?5size?3?5?$CFd?0?5first?58?5@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0N@JBJFAPFD@data?5?$DN?$DN?5NULL?$AA@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0EG@KOJHEOLC@Setup?5packets?5should?5be?58?5bytes?$CB@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0BN@PKENIJJB@Setup?3?5len2?5is?5NOT?5optional?$CB?$AA@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0EB@FDNEOLJJ@sending?5data?5without?5enough?5buff@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
;	COMDAT ??_C@_0O@NODNEMBJ@data2?5?$DN?$DN?5NULL?$AA@
XPPRDATA	SEGMENT DWORD USE32 PUBLIC ''
XPPRDATA	ENDS
XPP$Data	SEGMENT DWORD USE32 PUBLIC ''
XPP$Data	ENDS
XPPCODE	SEGMENT PARA USE32 PUBLIC ''
XPPCODE	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Direct3D_AddRef@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Direct3D_Release@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Direct3D_GetAdapterCount@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_BeginScene@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_EndScene@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_GetRenderState@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_GetTextureStageState@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_SetRenderState@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_SetTextureStageState@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DResource_MoveResourceMemory@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DTexture_UnlockRect@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DVolumeTexture_UnlockBox@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DCubeTexture_UnlockRect@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DVertexBuffer_Unlock@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DIndexBuffer_Lock@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DIndexBuffer_Unlock@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DPalette_Unlock@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DSurface_UnlockRect@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DVolume_UnlockBox@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXPLANE@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gettsc@@YG_JXZ
XPPCODE	SEGMENT PARA USE32 PUBLIC ''
XPPCODE	ENDS
;	COMDAT ?CompleteProc@@YGXPAT_URB@@PAX@Z
XPPCODE	SEGMENT PARA USE32 PUBLIC ''
XPPCODE	ENDS
;	COMDAT ?IsochCompleteProc@@YGXPAU_USBD_ISOCH_TRANSFER_STATUS@@PAX@Z
XPPCODE	SEGMENT PARA USE32 PUBLIC ''
XPPCODE	ENDS
;	COMDAT ?GetEndpoint@@YGPAXPAVIUsbDevice@@E@Z
XPPCODE	SEGMENT PARA USE32 PUBLIC ''
XPPCODE	ENDS
;	COMDAT ?CloseEndpoint@@YGXPAVIUsbDevice@@EPAX@Z
XPPCODE	SEGMENT PARA USE32 PUBLIC ''
XPPCODE	ENDS
;	COMDAT _SlixdIn@16
XPPCODE	SEGMENT PARA USE32 PUBLIC ''
XPPCODE	ENDS
;	COMDAT _SlixdOut@16
XPPCODE	SEGMENT PARA USE32 PUBLIC ''
XPPCODE	ENDS
;	COMDAT _SlixdSetup@24
XPPCODE	SEGMENT PARA USE32 PUBLIC ''
XPPCODE	ENDS
;	COMDAT _SlixdData0@4
XPPCODE	SEGMENT PARA USE32 PUBLIC ''
XPPCODE	ENDS
;	COMDAT _SlixdData1@4
XPPCODE	SEGMENT PARA USE32 PUBLIC ''
XPPCODE	ENDS
;	COMDAT _SlixdReset@0
XPPCODE	SEGMENT PARA USE32 PUBLIC ''
XPPCODE	ENDS
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XPP$Data
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?gYouMayPass@@3HC				; gYouMayPass
PUBLIC	_D3DPRIMITIVETOVERTEXCOUNT
PUBLIC	_D3DSIMPLERENDERSTATEENCODE
PUBLIC	_D3DTEXTUREDIRECTENCODE
PUBLIC	_D3DDIRTYFROMRENDERSTATE
PUBLIC	_D3DDIRTYFROMTEXTURESTATE
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
CONST	SEGMENT
_D3DPRIMITIVETOVERTEXCOUNT DD 00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
CONST	SEGMENT
_D3DSIMPLERENDERSTATEENCODE DD 040260H
	DD	040264H
	DD	040268H
	DD	04026cH
	DD	040270H
	DD	040274H
	DD	040278H
	DD	04027cH
	DD	040288H
	DD	04028cH
	DD	040a60H
	DD	040a64H
	DD	040a68H
	DD	040a6cH
	DD	040a70H
	DD	040a74H
	DD	040a78H
	DD	040a7cH
	DD	040a80H
	DD	040a84H
	DD	040a88H
	DD	040a8cH
	DD	040a90H
	DD	040a94H
	DD	040a98H
	DD	040a9cH
	DD	040aa0H
	DD	040aa4H
	DD	040aa8H
	DD	040aacH
	DD	040ab0H
	DD	040ab4H
	DD	040ab8H
	DD	040abcH
	DD	040ac0H
	DD	040ac4H
	DD	040ac8H
	DD	040accH
	DD	040ad0H
	DD	040ad4H
	DD	040ad8H
	DD	040adcH
	DD	0417f8H
	DD	041e20H
	DD	041e24H
	DD	041e40H
	DD	041e44H
	DD	041e48H
	DD	041e4cH
	DD	041e50H
	DD	041e54H
	DD	041e58H
	DD	041e5cH
	DD	041e60H
	DD	041d90H
	DD	041e74H
	DD	041e78H
	DD	040354H
	DD	04033cH
	DD	040304H
	DD	040300H
	DD	040340H
	DD	040344H
	DD	040348H
	DD	04035cH
	DD	040310H
	DD	04037cH
	DD	040358H
	DD	040374H
	DD	040378H
	DD	040364H
	DD	040368H
	DD	04036cH
	DD	040360H
	DD	040350H
	DD	04034cH
	DD	0409f8H
	DD	040384H
	DD	040388H
	DD	040330H
	DD	040334H
	DD	040338H
CONST	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
CONST	SEGMENT
_D3DTEXTUREDIRECTENCODE DD 081b00H
	DD	081b40H
	DD	081b80H
	DD	081bc0H
CONST	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
CONST	SEGMENT
_D3DDIRTYFROMRENDERSTATE DD 02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	01200H
	DD	03000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	0100H
	DD	0100H
	DD	0900H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
CONST	SEGMENT
_D3DDIRTYFROMTEXTURESTATE DD 0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0480fH
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0400H
CONST	ENDS
XPP$Data	SEGMENT
?gYouMayPass@@3HC DD 00H				; gYouMayPass
XPP$Data	ENDS
PUBLIC	?gettsc@@YG_JXZ					; gettsc
; Function compile flags: /Ogs
; File c:\xbox\private\test\tools\slixbox\slixd\islixd.cpp
;	COMDAT ?gettsc@@YG_JXZ
XPPCODE	SEGMENT
?gettsc@@YG_JXZ PROC NEAR				; gettsc, COMDAT

; 59   : __int64 __inline gettsc() {_asm {rdtsc} }	

  00000	0f 31		 rdtsc
  00002	c3		 ret	 0
?gettsc@@YG_JXZ ENDP					; gettsc
XPPCODE	ENDS
PUBLIC	?CompleteProc@@YGXPAT_URB@@PAX@Z		; CompleteProc
; Function compile flags: /Ogs
;	COMDAT ?CompleteProc@@YGXPAT_URB@@PAX@Z
XPPCODE	SEGMENT
_urb$ = 8
_con$ = 12
?CompleteProc@@YGXPAT_URB@@PAX@Z PROC NEAR		; CompleteProc, COMDAT

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   :  	gYouMayPass = ~urb->Header.Status;	//encoding it for the moment...

  00003	8b 45 08	 mov	 eax, DWORD PTR _urb$[ebp]
  00006	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00009	f7 d0		 not	 eax
  0000b	a3 00 00 00 00	 mov	 DWORD PTR ?gYouMayPass@@3HC, eax ; gYouMayPass

; 68   : }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?CompleteProc@@YGXPAT_URB@@PAX@Z ENDP			; CompleteProc
XPPCODE	ENDS
PUBLIC	?IsochCompleteProc@@YGXPAU_USBD_ISOCH_TRANSFER_STATUS@@PAX@Z ; IsochCompleteProc
; Function compile flags: /Ogs
;	COMDAT ?IsochCompleteProc@@YGXPAU_USBD_ISOCH_TRANSFER_STATUS@@PAX@Z
XPPCODE	SEGMENT
_puits$ = 8
_con$ = 12
?IsochCompleteProc@@YGXPAU_USBD_ISOCH_TRANSFER_STATUS@@PAX@Z PROC NEAR ; IsochCompleteProc, COMDAT

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :  	gYouMayPass = ~puits->Status;	//encoding it for the moment...

  00003	8b 45 08	 mov	 eax, DWORD PTR _puits$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	f7 d0		 not	 eax
  0000a	a3 00 00 00 00	 mov	 DWORD PTR ?gYouMayPass@@3HC, eax ; gYouMayPass

; 73   : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?IsochCompleteProc@@YGXPAU_USBD_ISOCH_TRANSFER_STATUS@@PAX@Z ENDP ; IsochCompleteProc
XPPCODE	ENDS
PUBLIC	?GetEndpoint@@YGPAXPAVIUsbDevice@@E@Z		; GetEndpoint
PUBLIC	??_C@_07EDDFIMDA@SlixD?3?5?$AA@			; `string'
PUBLIC	??_C@_0CE@NOFOGAEA@Attempting?5to?5open?5isoch?5endpoin@ ; `string'
PUBLIC	??_C@_0BA@LIGGHOEI@returned?50x?$CF8x?6?$AA@	; `string'
PUBLIC	??_C@_0BO@DJDHHGCC@StartTransfer?5returned?50x?$CF8x?6?$AA@ ; `string'
EXTRN	?DebugLevel@@3KA:DWORD				; DebugLevel
EXTRN	_DbgPrint:NEAR
EXTRN	?SubmitRequest@IUsbDevice@@QAEJPAT_URB@@@Z:NEAR	; IUsbDevice::SubmitRequest
EXTRN	?GetExtension@IUsbDevice@@QBEPAXXZ:NEAR		; IUsbDevice::GetExtension
;	COMDAT ??_C@_07EDDFIMDA@SlixD?3?5?$AA@
XPPRDATA	SEGMENT
??_C@_07EDDFIMDA@SlixD?3?5?$AA@ DB 'SlixD: ', 00H	; `string'
XPPRDATA	ENDS
;	COMDAT ??_C@_0CE@NOFOGAEA@Attempting?5to?5open?5isoch?5endpoin@
XPPRDATA	SEGMENT
??_C@_0CE@NOFOGAEA@Attempting?5to?5open?5isoch?5endpoin@ DB 'Attempting t'
	DB	'o open isoch endpoint: ', 00H		; `string'
XPPRDATA	ENDS
;	COMDAT ??_C@_0BA@LIGGHOEI@returned?50x?$CF8x?6?$AA@
XPPRDATA	SEGMENT
??_C@_0BA@LIGGHOEI@returned?50x?$CF8x?6?$AA@ DB 'returned 0x%8x', 0aH, 00H ; `string'
XPPRDATA	ENDS
;	COMDAT ??_C@_0BO@DJDHHGCC@StartTransfer?5returned?50x?$CF8x?6?$AA@
XPPRDATA	SEGMENT
??_C@_0BO@DJDHHGCC@StartTransfer?5returned?50x?$CF8x?6?$AA@ DB 'StartTran'
	DB	'sfer returned 0x%8x', 0aH, 00H		; `string'
; Function compile flags: /Ogs
XPPRDATA	ENDS
;	COMDAT ?GetEndpoint@@YGPAXPAVIUsbDevice@@E@Z
XPPCODE	SEGMENT
_urb2$36916 = -104
_urb$ = -56
tv515 = -8
_Endpoints$ = -4
_pud$ = 8
_endpoint$ = 12
tv513 = 15
?GetEndpoint@@YGPAXPAVIUsbDevice@@E@Z PROC NEAR		; GetEndpoint, COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H

; 82   : 	URB urb;
; 83   : 	int temp;
; 84   : 	void** Endpoints = ((PDEVICE_EXTENSION)pud->GetExtension())->Endpoints;

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _pud$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 ?GetExtension@IUsbDevice@@QBEPAXXZ ; IUsbDevice::GetExtension

; 85   : 
; 86   : 	if((0 == ENDPOINT_NUM(endpoint)) || (16==ENDPOINT_NUM(endpoint)) ) {	//default (control) endpoint

  00011	8a 5d 0c	 mov	 bl, BYTE PTR _endpoint$[ebp]
  00014	8b f8		 mov	 edi, eax
  00016	83 c7 04	 add	 edi, 4
  00019	8a cb		 mov	 cl, bl
  0001b	0f b6 f3	 movzx	 esi, bl
  0001e	80 e1 80	 and	 cl, 128			; 00000080H
  00021	89 7d fc	 mov	 DWORD PTR _Endpoints$[ebp], edi
  00024	88 4d 0f	 mov	 BYTE PTR tv513[ebp], cl
  00027	89 75 f8	 mov	 DWORD PTR tv515[ebp], esi
  0002a	74 07		 je	 SHORT $L37243
  0002c	83 e6 0f	 and	 esi, 15			; 0000000fH
  0002f	8b c6		 mov	 eax, esi
  00031	eb 06		 jmp	 SHORT $L37244
$L37243:
  00033	83 e6 0f	 and	 esi, 15			; 0000000fH
  00036	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
$L37244:
  00039	85 c0		 test	 eax, eax
  0003b	0f 84 cd 01 00
	00		 je	 $L36898
  00041	84 c9		 test	 cl, cl
  00043	8b c6		 mov	 eax, esi
  00045	75 03		 jne	 SHORT $L37246
  00047	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
$L37246:
  0004a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0004d	0f 84 bb 01 00
	00		 je	 $L36898

; 96   : 
; 97   : 	} else {	//normal endpoint
; 98   : 
; 99   : 		if(ENDPOINT_TYPE(endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) { //isoch

  00053	8a d3		 mov	 dl, bl
  00055	c0 ea 04	 shr	 dl, 4
  00058	80 e2 03	 and	 dl, 3
  0005b	80 fa 01	 cmp	 dl, 1

; 100  : 
; 101  : 			//if it's not already opened...
; 102  : 			if(Endpoints[ENDPOINT_NUM(endpoint)] == (void*) -1 || Endpoints[ENDPOINT_NUM(endpoint)] == NULL) {

  0005e	8b c6		 mov	 eax, esi
  00060	0f 85 3d 01 00
	00		 jne	 $L36904
  00066	84 c9		 test	 cl, cl
  00068	75 03		 jne	 SHORT $L37248
  0006a	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
$L37248:
  0006d	83 3c 87 ff	 cmp	 DWORD PTR [edi+eax*4], -1
  00071	74 13		 je	 SHORT $L36907
  00073	84 c9		 test	 cl, cl
  00075	8b c6		 mov	 eax, esi
  00077	75 03		 jne	 SHORT $L37250
  00079	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
$L37250:
  0007c	83 3c 87 00	 cmp	 DWORD PTR [edi+eax*4], 0
  00080	0f 85 0c 01 00
	00		 jne	 $L36919
$L36907:

; 103  : 				DBGPRINT(3, ("Attempting to open isoch endpoint: "));

  00086	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?DebugLevel@@3KA, 3 ; DebugLevel
  0008d	72 17		 jb	 SHORT $L36908
  0008f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  00094	e8 00 00 00 00	 call	 _DbgPrint
  00099	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET FLAT:??_C@_0CE@NOFOGAEA@Attempting?5to?5open?5isoch?5endpoin@
  000a0	e8 00 00 00 00	 call	 _DbgPrint
  000a5	59		 pop	 ecx
$L36908:

; 104  : 				((DEVICE_EXTENSION*)pud->GetExtension())->EndpointType[ENDPOINT_NUM(endpoint)] 
; 105  : 					= USB_ENDPOINT_TYPE_ISOCHRONOUS; //so we can close it properly

  000a6	80 7d 0f 00	 cmp	 BYTE PTR tv513[ebp], 0
  000aa	8b fe		 mov	 edi, esi
  000ac	75 03		 jne	 SHORT $L37252
  000ae	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
$L37252:
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _pud$[ebp]
  000b4	e8 00 00 00 00	 call	 ?GetExtension@IUsbDevice@@QBEPAXXZ ; IUsbDevice::GetExtension
  000b9	c6 84 38 84 00
	00 00 01	 mov	 BYTE PTR [eax+edi+132], 1

; 106  : 
; 107  : 				RtlZeroMemory(&urb,sizeof(URB));

  000c1	33 c0		 xor	 eax, eax
  000c3	6a 0c		 push	 12			; 0000000cH
  000c5	59		 pop	 ecx
  000c6	8d 7d c8	 lea	 edi, DWORD PTR _urb$[ebp]
  000c9	f3 ab		 rep stosd

; 108  :                 USB_BUILD_ISOCH_OPEN_ENDPOINT((&urb.IsochOpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), 256, 0);
; 109  : 				temp = pud->SubmitRequest(&urb);

  000cb	8b 4d 08	 mov	 ecx, DWORD PTR _pud$[ebp]
  000ce	89 45 d0	 mov	 DWORD PTR _urb$[ebp+8], eax
  000d1	89 45 d4	 mov	 DWORD PTR _urb$[ebp+12], eax
  000d4	66 89 45 e0	 mov	 WORD PTR _urb$[ebp+24], ax
  000d8	8d 45 c8	 lea	 eax, DWORD PTR _urb$[ebp]
  000db	80 e3 8f	 and	 bl, 143			; 0000008fH
  000de	50		 push	 eax
  000df	c6 45 c8 1c	 mov	 BYTE PTR _urb$[ebp], 28	; 0000001cH
  000e3	c6 45 c9 09	 mov	 BYTE PTR _urb$[ebp+1], 9
  000e7	88 5d dd	 mov	 BYTE PTR _urb$[ebp+21], bl
  000ea	66 c7 45 de 00
	01		 mov	 WORD PTR _urb$[ebp+22], 256 ; 00000100H
  000f0	e8 00 00 00 00	 call	 ?SubmitRequest@IUsbDevice@@QAEJPAT_URB@@@Z ; IUsbDevice::SubmitRequest

; 110  : 				DBGPRINT(3, ("returned 0x%8x\n", temp));

  000f5	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?DebugLevel@@3KA, 3 ; DebugLevel
  000fc	8b f8		 mov	 edi, eax
  000fe	72 18		 jb	 SHORT $L37268
  00100	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  00105	e8 00 00 00 00	 call	 _DbgPrint
  0010a	57		 push	 edi
  0010b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@LIGGHOEI@returned?50x?$CF8x?6?$AA@
  00110	e8 00 00 00 00	 call	 _DbgPrint
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH
$L37268:

; 111  : 				Endpoints[ENDPOINT_NUM(endpoint)] = urb.IsochOpenEndpoint.EndpointHandle;

  00118	80 7d 0f 00	 cmp	 BYTE PTR tv513[ebp], 0
  0011c	8b c6		 mov	 eax, esi
  0011e	75 03		 jne	 SHORT $L37254
  00120	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
$L37254:
  00123	8b 4d d8	 mov	 ecx, DWORD PTR _urb$[ebp+16]
  00126	8b 55 fc	 mov	 edx, DWORD PTR _Endpoints$[ebp]
  00129	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx

; 112  : 
; 113  : 				URB urb2;
; 114  : 				RtlZeroMemory(&urb2,sizeof(URB));

  0012c	6a 0c		 push	 12			; 0000000cH
  0012e	33 c0		 xor	 eax, eax
  00130	59		 pop	 ecx
  00131	8d 7d 98	 lea	 edi, DWORD PTR _urb2$36916[ebp]
  00134	f3 ab		 rep stosd

; 115  : 				USB_BUILD_ISOCH_START_TRANSFER((&urb2.IsochStartTransfer), Endpoints[ENDPOINT_NUM(endpoint)], 
; 116  : 					0, URB_FLAG_ISOCH_START_ASAP);

  00136	33 c9		 xor	 ecx, ecx
  00138	38 4d 0f	 cmp	 BYTE PTR tv513[ebp], cl
  0013b	c6 45 98 1c	 mov	 BYTE PTR _urb2$36916[ebp], 28 ; 0000001cH
  0013f	c6 45 99 0c	 mov	 BYTE PTR _urb2$36916[ebp+1], 12 ; 0000000cH
  00143	89 4d a0	 mov	 DWORD PTR _urb2$36916[ebp+8], ecx
  00146	89 4d a4	 mov	 DWORD PTR _urb2$36916[ebp+12], ecx
  00149	8b c6		 mov	 eax, esi
  0014b	75 03		 jne	 SHORT $L37256
  0014d	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
$L37256:
  00150	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00153	89 45 a8	 mov	 DWORD PTR _urb2$36916[ebp+16], eax

; 117  : 				temp = pud->SubmitRequest(&urb2);

  00156	8d 45 98	 lea	 eax, DWORD PTR _urb2$36916[ebp]
  00159	89 4d ac	 mov	 DWORD PTR _urb2$36916[ebp+20], ecx
  0015c	8b 4d 08	 mov	 ecx, DWORD PTR _pud$[ebp]
  0015f	50		 push	 eax
  00160	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _urb2$36916[ebp+24], 1
  00167	e8 00 00 00 00	 call	 ?SubmitRequest@IUsbDevice@@QAEJPAT_URB@@@Z ; IUsbDevice::SubmitRequest

; 118  : 				DBGPRINT(3, ("StartTransfer returned 0x%8x\n", temp));

  0016c	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?DebugLevel@@3KA, 3 ; DebugLevel
  00173	8b f8		 mov	 edi, eax
  00175	72 18		 jb	 SHORT $L37267
  00177	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  0017c	e8 00 00 00 00	 call	 _DbgPrint
  00181	57		 push	 edi
  00182	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@DJDHHGCC@StartTransfer?5returned?50x?$CF8x?6?$AA@
  00187	e8 00 00 00 00	 call	 _DbgPrint
  0018c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L37267:
  0018f	8b 7d fc	 mov	 edi, DWORD PTR _Endpoints$[ebp]
$L36919:

; 119  : 
; 120  : 			}
; 121  : 
; 122  : 			return Endpoints[ENDPOINT_NUM(endpoint)];

  00192	80 7d 0f 00	 cmp	 BYTE PTR tv513[ebp], 0
$L37269:
  00196	75 03		 jne	 SHORT $L37258
  00198	83 c6 10	 add	 esi, 16			; 00000010H
$L37258:
  0019b	8b 04 b7	 mov	 eax, DWORD PTR [edi+esi*4]
  0019e	e9 9f 00 00 00	 jmp	 $L36921
$L36904:

; 123  : 
; 124  : 		} else { //not isoch
; 125  : 			if(Endpoints[ENDPOINT_NUM(endpoint)] != (void*) -1 && Endpoints[ENDPOINT_NUM(endpoint)] != NULL) {

  001a3	84 c9		 test	 cl, cl
  001a5	75 03		 jne	 SHORT $L37260
  001a7	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
$L37260:
  001aa	83 3c 87 ff	 cmp	 DWORD PTR [edi+eax*4], -1
  001ae	74 13		 je	 SHORT $L36923
  001b0	84 c9		 test	 cl, cl
  001b2	8b c6		 mov	 eax, esi
  001b4	75 03		 jne	 SHORT $L37262
  001b6	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
$L37262:
  001b9	83 3c 87 00	 cmp	 DWORD PTR [edi+eax*4], 0
  001bd	74 04		 je	 SHORT $L36923

; 126  : 				return Endpoints[ENDPOINT_NUM(endpoint)];

  001bf	84 c9		 test	 cl, cl
  001c1	eb d3		 jmp	 SHORT $L37269
$L36923:

; 127  : 			}
; 128  : 
; 129  : 			RtlZeroMemory(&urb,sizeof(URB));

  001c3	6a 0c		 push	 12			; 0000000cH
  001c5	33 c0		 xor	 eax, eax
  001c7	59		 pop	 ecx
  001c8	8d 7d c8	 lea	 edi, DWORD PTR _urb$[ebp]
  001cb	f3 ab		 rep stosd

; 130  : 
; 131  : 			USB_BUILD_OPEN_ENDPOINT((&urb.OpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), ENDPOINT_TYPE(endpoint), SLIX_MAX_BULK_PACKET_SIZE, 1);

  001cd	21 45 d0	 and	 DWORD PTR _urb$[ebp+8], eax

; 132  : 			pud->SubmitRequest(&urb);

  001d0	8b 4d 08	 mov	 ecx, DWORD PTR _pud$[ebp]
  001d3	8d 45 c8	 lea	 eax, DWORD PTR _urb$[ebp]
  001d6	80 e3 8f	 and	 bl, 143			; 0000008fH
  001d9	50		 push	 eax
  001da	c6 45 c8 20	 mov	 BYTE PTR _urb$[ebp], 32	; 00000020H
  001de	c6 45 c9 02	 mov	 BYTE PTR _urb$[ebp+1], 2
  001e2	88 5d dd	 mov	 BYTE PTR _urb$[ebp+21], bl
  001e5	88 55 de	 mov	 BYTE PTR _urb$[ebp+22], dl
  001e8	c6 45 df 01	 mov	 BYTE PTR _urb$[ebp+23], 1
  001ec	66 c7 45 e4 40
	00		 mov	 WORD PTR _urb$[ebp+28], 64 ; 00000040H
  001f2	e8 00 00 00 00	 call	 ?SubmitRequest@IUsbDevice@@QAEJPAT_URB@@@Z ; IUsbDevice::SubmitRequest

; 133  : 			Endpoints[ENDPOINT_NUM(endpoint)] = urb.OpenEndpoint.EndpointHandle;

  001f7	80 7d 0f 00	 cmp	 BYTE PTR tv513[ebp], 0
  001fb	75 03		 jne	 SHORT $L37266
  001fd	83 c6 10	 add	 esi, 16			; 00000010H
$L37266:
  00200	8b 45 d8	 mov	 eax, DWORD PTR _urb$[ebp+16]
  00203	8b 4d fc	 mov	 ecx, DWORD PTR _Endpoints$[ebp]
  00206	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax

; 134  : 			return urb.OpenEndpoint.EndpointHandle;

  00209	8b 45 d8	 mov	 eax, DWORD PTR _urb$[ebp+16]
  0020c	eb 34		 jmp	 SHORT $L36921
$L36898:

; 87   : 		if(Endpoints[0] != (void*)-1) {	//if it's been opened already

  0020e	8b 07		 mov	 eax, DWORD PTR [edi]
  00210	83 f8 ff	 cmp	 eax, -1

; 88   : 			return Endpoints[0];		//return it...

  00213	75 2d		 jne	 SHORT $L36921

; 89   : 		}
; 90   : 
; 91   : 		RtlZeroMemory(&urb,sizeof(URB));

  00215	6a 0c		 push	 12			; 0000000cH
  00217	33 c0		 xor	 eax, eax
  00219	59		 pop	 ecx
  0021a	8d 7d c8	 lea	 edi, DWORD PTR _urb$[ebp]
  0021d	f3 ab		 rep stosd

; 92   : 		USB_BUILD_OPEN_DEFAULT_ENDPOINT((&urb.OpenEndpoint));

  0021f	21 45 d0	 and	 DWORD PTR _urb$[ebp+8], eax

; 93   : 		pud->SubmitRequest(&urb);

  00222	8b 4d 08	 mov	 ecx, DWORD PTR _pud$[ebp]
  00225	8d 45 c8	 lea	 eax, DWORD PTR _urb$[ebp]
  00228	50		 push	 eax
  00229	c6 45 c8 20	 mov	 BYTE PTR _urb$[ebp], 32	; 00000020H
  0022d	c6 45 c9 82	 mov	 BYTE PTR _urb$[ebp+1], 130 ; 00000082H
  00231	e8 00 00 00 00	 call	 ?SubmitRequest@IUsbDevice@@QAEJPAT_URB@@@Z ; IUsbDevice::SubmitRequest

; 94   : 		Endpoints[endpoint] = NULL;		//NULL is always returned for the default endpoint handle

  00236	8b 45 fc	 mov	 eax, DWORD PTR _Endpoints$[ebp]
  00239	8b 4d f8	 mov	 ecx, DWORD PTR tv515[ebp]
  0023c	83 24 88 00	 and	 DWORD PTR [eax+ecx*4], 0

; 95   : 		return NULL;

  00240	33 c0		 xor	 eax, eax
$L36921:
  00242	5f		 pop	 edi
  00243	5e		 pop	 esi
  00244	5b		 pop	 ebx

; 135  : 		}
; 136  : 
; 137  : 	}
; 138  : }

  00245	c9		 leave
  00246	c2 08 00	 ret	 8
?GetEndpoint@@YGPAXPAVIUsbDevice@@E@Z ENDP		; GetEndpoint
XPPCODE	ENDS
PUBLIC	?CloseEndpoint@@YGXPAVIUsbDevice@@EPAX@Z	; CloseEndpoint
; Function compile flags: /Ogs
;	COMDAT ?CloseEndpoint@@YGXPAVIUsbDevice@@EPAX@Z
XPPCODE	SEGMENT
_pud$ = 8
_endpoint$ = 12
_eh$ = 16
?CloseEndpoint@@YGXPAVIUsbDevice@@EPAX@Z PROC NEAR	; CloseEndpoint, COMDAT

; 156  : //	URB urb;
; 157  : //	int temp;
; 158  : //	void** Endpoints = ((PDEVICE_EXTENSION)pud->GetExtension())->Endpoints;
; 159  : 
; 160  : //
; 161  : //	if(0 == ENDPOINT_NUM(endpoint)) {	//default (control) endpoint
; 162  : //		if(Endpoints[0] == (void*)-1) {	//if it's been closed already
; 163  : //			return; //Endpoints[0];		//return it...
; 164  : //		} else {
; 165  : 
; 166  : 		//RtlZeroMemory(&urb,sizeof(URB));
; 167  : //		USB_BUILD_CLOSE_DEFAULT_ENDPOINT(&urb.CloseEndpoint, arf,0);
; 168  : 
; 169  : 		//USB_BUILD_OPEN_DEFAULT_ENDPOINT((&urb.OpenEndpoint));
; 170  : //		pud->SubmitRequest(&urb);
; 171  : 		//Endpoints[endpoint] = NULL;		//NULL is always returned for the default endpoint handle
; 172  : //		return;// NULL;
; 173  : //		}
; 174  : 
; 175  : //	} else {//normal endpoint
; 176  : //		if(ENDPOINT_TYPE(endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) { //isoch
; 177  : 
; 178  : 			//if it's not already opened...
; 179  : 
; 180  : 			/* we will consider this later on
; 181  : 			if(Endpoints[ENDPOINT_NUM(endpoint)] == (void*) -1 || Endpoints[ENDPOINT_NUM(endpoint)] == NULL) {
; 182  : 				DBGPRINT(3, ("Attempting to open isoch endpoint: "));
; 183  : 				((DEVICE_EXTENSION*)pud->GetExtension())->EndpointType[ENDPOINT_NUM(endpoint)] 
; 184  : 					= USB_ENDPOINT_TYPE_ISOCHRONOUS; //so we can close it properly
; 185  : 
; 186  : 				RtlZeroMemory(&urb,sizeof(URB));
; 187  :                 USB_BUILD_ISOCH_OPEN_ENDPOINT((&urb.IsochOpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), 256, 0);
; 188  : 				temp = pud->SubmitRequest(&urb);
; 189  : 				DBGPRINT(3, ("returned 0x%8x\n", temp));
; 190  : 				Endpoints[ENDPOINT_NUM(endpoint)] = urb.IsochOpenEndpoint.EndpointHandle;
; 191  : 
; 192  : 				URB urb2;
; 193  : 				RtlZeroMemory(&urb2,sizeof(URB));
; 194  : 				USB_BUILD_ISOCH_START_TRANSFER((&urb2.IsochStartTransfer), Endpoints[ENDPOINT_NUM(endpoint)], 
; 195  : 					0, URB_FLAG_ISOCH_START_ASAP);
; 196  : 				temp = pud->SubmitRequest(&urb2);
; 197  : 				DBGPRINT(3, ("StartTransfer returned 0x%8x\n", temp));
; 198  :             
; 199  : 			}
; 200  : 			*/
; 201  : 
; 202  : //			return; //Endpoints[ENDPOINT_NUM(endpoint)];
; 203  : 
; 204  : //		} else { //not isoch
; 205  : //			if(Endpoints[ENDPOINT_NUM(endpoint)] == (void*) -1 || Endpoints[ENDPOINT_NUM(endpoint)] == NULL) {
; 206  : 				//already closed
; 207  : //				return; //Endpoints[ENDPOINT_NUM(endpoint)];
; 208  : //			} else {
; 209  : 			//RtlZeroMemory(&urb,sizeof(URB));
; 210  : 
; 211  : 			//USB_BUILD_OPEN_ENDPOINT((&urb.OpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), ENDPOINT_TYPE(endpoint), SLIX_MAX_BULK_PACKET_SIZE, 1);
; 212  : 			
; 213  : 			
; 214  : //            USB_BUILD_CLOSE_ENDPOINT(&urb.CloseEndpoint,Endpoints[ENDPOINT_NUM(endpoint)] , arf,0);
; 215  : //			pud->SubmitRequest(&urb);
; 216  : 			//Endpoints[ENDPOINT_NUM(endpoint)] = urb.OpenEndpoint.EndpointHandle;
; 217  : //			return; // urb.OpenEndpoint.EndpointHandle;
; 218  : //			}
; 219  : //		}
; 220  : 
; 221  : //	}
; 222  : 
; 223  : 	//intiliaze it again
; 224  :   // Endpoints[ENDPOINT_NUM(endpoint)]=(void *) -1;
; 225  :   //((PDEVICE_EXTENSION)pud->GetExtension())->EndpointType[ENDPOINT_NUM(endpoint)] = 0;
; 226  : 
; 227  : 
; 228  : 
; 229  : }

  00000	c2 0c 00	 ret	 12			; 0000000cH
?CloseEndpoint@@YGXPAVIUsbDevice@@EPAX@Z ENDP		; CloseEndpoint
XPPCODE	ENDS
PUBLIC	??_C@_0CG@IMFPEJBO@SlixdIn?3?5Port?5?$CFd?0?5Slot?5?$CFd?0?5pud?$DN?$DN@ ; `string'
PUBLIC	??_C@_0CI@HEKMLLFL@SlixdIn?3?5de?9?$DODeviceFlags?5?$CG?5DF_CO@ ; `string'
PUBLIC	??_C@_0DA@OIAGLEAI@ERROR?$CB?5Can?8t?5send?5additional?5INs@ ; `string'
PUBLIC	??_C@_0CG@CDALMCND@ourendpoint?5?$DN?$DN?5NULL?5?$CG?$CG?5Endpoint?5@ ; `string'
PUBLIC	??_C@_0O@HFGOLHIC@?$CKlen?5?$DN?$DN?50?$CB?$CB?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0FE@IMMOFDKE@request?5completed?0?5with?5error?3?5?$CF@ ; `string'
PUBLIC	_SlixdIn@16
EXTRN	?gDriverExtension@@3PAUSLIX_DRIVER_EXTENSION@@A:DWORD ; gDriverExtension
EXTRN	?CancelRequest@IUsbDevice@@QAEJPAT_URB@@@Z:NEAR	; IUsbDevice::CancelRequest
;	COMDAT ??_C@_0CG@IMFPEJBO@SlixdIn?3?5Port?5?$CFd?0?5Slot?5?$CFd?0?5pud?$DN?$DN@
XPPRDATA	SEGMENT
??_C@_0CG@IMFPEJBO@SlixdIn?3?5Port?5?$CFd?0?5Slot?5?$CFd?0?5pud?$DN?$DN@ DB 'S'
	DB	'lixdIn: Port %d, Slot %d, pud==NULL', 0aH, 00H ; `string'
XPPRDATA	ENDS
;	COMDAT ??_C@_0CI@HEKMLLFL@SlixdIn?3?5de?9?$DODeviceFlags?5?$CG?5DF_CO@
XPPRDATA	SEGMENT
??_C@_0CI@HEKMLLFL@SlixdIn?3?5de?9?$DODeviceFlags?5?$CG?5DF_CO@ DB 'Slixd'
	DB	'In: de->DeviceFlags & DF_CONNECTED', 00H	; `string'
XPPRDATA	ENDS
;	COMDAT ??_C@_0DA@OIAGLEAI@ERROR?$CB?5Can?8t?5send?5additional?5INs@
XPPRDATA	SEGMENT
??_C@_0DA@OIAGLEAI@ERROR?$CB?5Can?8t?5send?5additional?5INs@ DB 'ERROR! C'
	DB	'an''t send additional INs to endpoint 0', 0aH, 00H ; `string'
XPPRDATA	ENDS
;	COMDAT ??_C@_0CG@CDALMCND@ourendpoint?5?$DN?$DN?5NULL?5?$CG?$CG?5Endpoint?5@
XPPRDATA	SEGMENT
??_C@_0CG@CDALMCND@ourendpoint?5?$DN?$DN?5NULL?5?$CG?$CG?5Endpoint?5@ DB 'o'
	DB	'urendpoint == NULL && Endpoint != 0', 0aH, 00H ; `string'
XPPRDATA	ENDS
;	COMDAT ??_C@_0O@HFGOLHIC@?$CKlen?5?$DN?$DN?50?$CB?$CB?$CB?6?$AA@
XPPRDATA	SEGMENT
??_C@_0O@HFGOLHIC@?$CKlen?5?$DN?$DN?50?$CB?$CB?$CB?6?$AA@ DB '*len == 0!!'
	DB	'!', 0aH, 00H				; `string'
XPPRDATA	ENDS
;	COMDAT ??_C@_0FE@IMMOFDKE@request?5completed?0?5with?5error?3?5?$CF@
XPPRDATA	SEGMENT
??_C@_0FE@IMMOFDKE@request?5completed?0?5with?5error?3?5?$CF@ DB 'request'
	DB	' completed, with error: %x', 0aH, 'returned data size: %d, fi'
	DB	'rst 8 bytes = %016I64x', 0aH, 00H		; `string'
; Function compile flags: /Ogs
XPPRDATA	ENDS
;	COMDAT _SlixdIn@16
XPPCODE	SEGMENT
_urb$ = -52
_bufd$36969 = -36
_pud$ = -4
_Address$ = 8
tv321 = 11
_Endpoint$ = 12
_retcode$ = 12
_data$ = 16
_len$ = 20
_SlixdIn@16 PROC NEAR					; COMDAT

; 242  : {	DEVICE_EXTENSION * de;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 243  : 	URB urb;
; 244  : 	IUsbDevice * pud;
; 245  : 	LONG templen = 8;
; 246  : 	USBD_STATUS retcode = USBD_STATUS_ERROR;
; 247  : 	HANDLE ourendpoint;
; 248  : 	BYTE closeendpoint = Endpoint;
; 249  : 	int port, slot;
; 250  : 	__int64 maxwaittime;
; 251  : 
; 252  : 	port = PORT_FROM_ADDRESS(Address);

  00006	8a 4d 08	 mov	 cl, BYTE PTR _Address$[ebp]
  00009	0f b6 c1	 movzx	 eax, cl
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b f0		 mov	 esi, eax

; 253  : 	slot = SLOT_FROM_ADDRESS(Address);

  00010	c1 e8 04	 shr	 eax, 4
  00013	83 e0 07	 and	 eax, 7
  00016	8b d8		 mov	 ebx, eax

; 254  : 
; 255  : 	gDriverExtension->LastAddress = Address;	//so that we don't have to guess when we do SetDataToggles

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gDriverExtension@@3PAUSLIX_DRIVER_EXTENSION@@A ; gDriverExtension
  0001d	88 88 00 15 00
	00		 mov	 BYTE PTR [eax+5376], cl
  00023	83 e6 0f	 and	 esi, 15			; 0000000fH

; 256  : 	de = &gDriverExtension->Nodes[port][slot];

  00026	8d 04 b3	 lea	 eax, DWORD PTR [ebx+esi*4]
  00029	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  0002f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gDriverExtension@@3PAUSLIX_DRIVER_EXTENSION@@A ; gDriverExtension
  00035	57		 push	 edi

; 257  : 	pud = de->Device;

  00036	8b 08		 mov	 ecx, DWORD PTR [eax]

; 258  : 
; 259  : 	if (pud == NULL) {

  00038	33 ff		 xor	 edi, edi
  0003a	3b cf		 cmp	 ecx, edi
  0003c	89 4d fc	 mov	 DWORD PTR _pud$[ebp], ecx
  0003f	75 2a		 jne	 SHORT $L36948

; 260  : 		//the device isn't connected
; 261  : 		DBGPRINT(2,("SlixdIn: Port %d, Slot %d, pud==NULL\n", port, slot));

  00041	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?DebugLevel@@3KA, 2 ; DebugLevel
  00048	72 19		 jb	 SHORT $L36949
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  0004f	e8 00 00 00 00	 call	 _DbgPrint
  00054	53		 push	 ebx
  00055	56		 push	 esi
  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@IMFPEJBO@SlixdIn?3?5Port?5?$CFd?0?5Slot?5?$CFd?0?5pud?$DN?$DN@
  0005b	e8 00 00 00 00	 call	 _DbgPrint
  00060	83 c4 10	 add	 esp, 16			; 00000010H
$L36949:

; 262  : 		*len = 0;

  00063	8b 45 14	 mov	 eax, DWORD PTR _len$[ebp]

; 263  : 		return USBD_STATUS_ERROR;

  00066	e9 a1 00 00 00	 jmp	 $L37298
$L36948:

; 264  : 	}
; 265  : 
; 266  : 	if(!(de->flags & DF_CONNECTED)){

  0006b	f6 80 a4 00 00
	00 01		 test	 BYTE PTR [eax+164], 1
  00072	75 1c		 jne	 SHORT $L36952

; 267  : 		DBGPRINT(2,("SlixdIn: de->DeviceFlags & DF_CONNECTED"));

  00074	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?DebugLevel@@3KA, 2 ; DebugLevel
  0007b	72 e6		 jb	 SHORT $L36949
  0007d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  00082	e8 00 00 00 00	 call	 _DbgPrint
  00087	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET FLAT:??_C@_0CI@HEKMLLFL@SlixdIn?3?5de?9?$DODeviceFlags?5?$CG?5DF_CO@

; 268  : 		*len = 0;
; 269  : 		return USBD_STATUS_ERROR;

  0008e	eb 26		 jmp	 SHORT $L37299
$L36952:

; 270  : 	}
; 271  : 	
; 272  : 	if(data == NULL) {

  00090	39 7d 10	 cmp	 DWORD PTR _data$[ebp], edi

; 273  : 		if(len != NULL) *len = 0;
; 274  : 		return USBD_STATUS_ERROR;

  00093	74 70		 je	 SHORT $L36964

; 275  : 	}
; 276  : 
; 277  : 	if(Endpoint == 0) {

  00095	8a 5d 0c	 mov	 bl, BYTE PTR _Endpoint$[ebp]
  00098	84 db		 test	 bl, bl
  0009a	75 22		 jne	 SHORT $L36959

; 278  : 		DBGPRINT(3, ("ERROR! Can't send additional INs to endpoint 0\n"));

  0009c	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?DebugLevel@@3KA, 3 ; DebugLevel
  000a3	72 be		 jb	 SHORT $L36949
  000a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  000aa	e8 00 00 00 00	 call	 _DbgPrint
  000af	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET FLAT:??_C@_0DA@OIAGLEAI@ERROR?$CB?5Can?8t?5send?5additional?5INs@
$L37299:
  000b6	e8 00 00 00 00	 call	 _DbgPrint
  000bb	59		 pop	 ecx

; 279  : 		*len = 0;
; 280  : 		return USBD_STATUS_ERROR;

  000bc	eb a5		 jmp	 SHORT $L36949
$L36959:

; 281  : 	}
; 282  : 
; 283  : 	Endpoint |= 0x80;

  000be	80 cb 80	 or	 bl, 128			; 00000080H
  000c1	88 5d 0c	 mov	 BYTE PTR _Endpoint$[ebp], bl

; 284  : 
; 285  : 	ourendpoint = GetEndpoint(pud, Endpoint);

  000c4	ff 75 0c	 push	 DWORD PTR _Endpoint$[ebp]
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 ?GetEndpoint@@YGPAXPAVIUsbDevice@@E@Z ; GetEndpoint
  000cd	8b f0		 mov	 esi, eax

; 286  : 
; 287  : 	if(ourendpoint == NULL && (ENDPOINT_NUM(Endpoint) != 0)) {

  000cf	3b f7		 cmp	 esi, edi
  000d1	75 45		 jne	 SHORT $L36963
  000d3	33 c0		 xor	 eax, eax
  000d5	8a c3		 mov	 al, bl
  000d7	83 e0 0f	 and	 eax, 15			; 0000000fH
  000da	84 db		 test	 bl, bl
  000dc	78 03		 js	 SHORT $L37277
  000de	83 c0 10	 add	 eax, 16			; 00000010H
$L37277:
  000e1	3b c7		 cmp	 eax, edi
  000e3	74 33		 je	 SHORT $L36963

; 288  : 		//the endpoint couldn't be opened... if Endpoint == 0, the endpoint handle is always NULL.
; 289  : 		DBGPRINT(3, ("ourendpoint == NULL && Endpoint != 0\n"));

  000e5	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?DebugLevel@@3KA, 3 ; DebugLevel
  000ec	72 17		 jb	 SHORT $L36964
  000ee	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  000f3	e8 00 00 00 00	 call	 _DbgPrint
  000f8	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET FLAT:??_C@_0CG@CDALMCND@ourendpoint?5?$DN?$DN?5NULL?5?$CG?$CG?5Endpoint?5@
  000ff	e8 00 00 00 00	 call	 _DbgPrint
  00104	59		 pop	 ecx
$L36964:

; 290  : 		if(len) *len = 0;

  00105	8b 45 14	 mov	 eax, DWORD PTR _len$[ebp]
  00108	3b c7		 cmp	 eax, edi
  0010a	74 02		 je	 SHORT $L36966
$L37298:
  0010c	89 38		 mov	 DWORD PTR [eax], edi
$L36966:

; 291  : 		return USBD_STATUS_ERROR;

  0010e	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00113	e9 5f 01 00 00	 jmp	 $L36936
$L36963:

; 292  : 	} 
; 293  : 
; 294  : 	if(ENDPOINT_TYPE(Endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) {		//isoch

  00118	c0 eb 04	 shr	 bl, 4
  0011b	80 e3 03	 and	 bl, 3
  0011e	80 fb 01	 cmp	 bl, 1
  00121	88 5d 0b	 mov	 BYTE PTR tv321[ebp], bl
  00124	75 26		 jne	 SHORT $L36968

; 295  : 		USBD_ISOCH_BUFFER_DESCRIPTOR bufd;
; 296  : 
; 297  : 		bufd.Context = (void*)pud;
; 298  : 		bufd.FrameCount = 1;
; 299  : 		bufd.Pattern[0] = (USHORT)*len;
; 300  : 		bufd.Pattern[1] = 0;
; 301  : 		bufd.TransferBuffer = data;
; 302  : 		bufd.TransferComplete = IsochCompleteProc; 
; 303  : 		RtlZeroMemory(&urb, sizeof(URB));
; 304  : 		USB_BUILD_ISOCH_ATTACH_BUFFER((&urb.IsochAttachBuffer), ourendpoint, USBD_DELAY_INTERRUPT_0_MS, &bufd);
; 305  : 		maxwaittime = _WAIT;	//3.1 milliseconds
; 306  : 
; 307  : 	} else {	//non-isoch

  00126	8b 5d 10	 mov	 ebx, DWORD PTR _data$[ebp]
  00129	33 c0		 xor	 eax, eax
  0012b	6a 0c		 push	 12			; 0000000cH
  0012d	59		 pop	 ecx
  0012e	8d 7d cc	 lea	 edi, DWORD PTR _urb$[ebp]
  00131	f3 ab		 rep stosd
  00133	21 45 d4	 and	 DWORD PTR _urb$[ebp+8], eax
  00136	21 45 d8	 and	 DWORD PTR _urb$[ebp+12], eax
  00139	20 45 e0	 and	 BYTE PTR _urb$[ebp+20], al
  0013c	8d 45 dc	 lea	 eax, DWORD PTR _bufd$36969[ebp]
  0013f	c6 45 cc 1c	 mov	 BYTE PTR _urb$[ebp], 28	; 0000001cH
  00143	c6 45 cd 0b	 mov	 BYTE PTR _urb$[ebp+1], 11 ; 0000000bH
  00147	89 45 e4	 mov	 DWORD PTR _urb$[ebp+24], eax
  0014a	eb 6b		 jmp	 SHORT $L37297
$L36968:

; 308  : 		*len = (*len + 63) & ~63;	//round up to the nearest 64 bytes so we don't get buffer overflows

  0014c	8b 7d 14	 mov	 edi, DWORD PTR _len$[ebp]
  0014f	8b 07		 mov	 eax, DWORD PTR [edi]
  00151	83 c0 3f	 add	 eax, 63			; 0000003fH
  00154	83 e0 c0	 and	 eax, -64		; ffffffc0H
  00157	89 07		 mov	 DWORD PTR [edi], eax

; 309  : 	
; 310  : 		if(!*len) {	//len == 0

  00159	75 26		 jne	 SHORT $L36975

; 311  : 			DBGPRINT(3, ("*len == 0!!!\n"));

  0015b	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?DebugLevel@@3KA, 3 ; DebugLevel
  00162	72 17		 jb	 SHORT $L36976
  00164	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  00169	e8 00 00 00 00	 call	 _DbgPrint
  0016e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET FLAT:??_C@_0O@HFGOLHIC@?$CKlen?5?$DN?$DN?50?$CB?$CB?$CB?6?$AA@
  00175	e8 00 00 00 00	 call	 _DbgPrint
  0017a	59		 pop	 ecx
$L36976:

; 312  : 			*len = 64;

  0017b	c7 07 40 00 00
	00		 mov	 DWORD PTR [edi], 64	; 00000040H
$L36975:

; 313  : 		}
; 314  : 	
; 315  : 		templen = *len;

  00181	8b 17		 mov	 edx, DWORD PTR [edi]

; 316  : 	
; 317  : 		RtlZeroMemory(&urb,sizeof(URB));
; 318  : 		USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(&urb.BulkOrInterruptTransfer,
; 319  : 			ourendpoint, data, templen, USB_TRANSFER_DIRECTION_IN, 
; 320  : 			CompleteProc, (void*)pud, TRUE);

  00183	8b 5d 10	 mov	 ebx, DWORD PTR _data$[ebp]
  00186	6a 0c		 push	 12			; 0000000cH
  00188	33 c0		 xor	 eax, eax
  0018a	59		 pop	 ecx
  0018b	8d 7d cc	 lea	 edi, DWORD PTR _urb$[ebp]
  0018e	f3 ab		 rep stosd
  00190	8b 45 fc	 mov	 eax, DWORD PTR _pud$[ebp]
  00193	80 65 ea 00	 and	 BYTE PTR _urb$[ebp+30], 0
  00197	c6 45 cc 28	 mov	 BYTE PTR _urb$[ebp], 40	; 00000028H
  0019b	c6 45 cd 41	 mov	 BYTE PTR _urb$[ebp+1], 65 ; 00000041H
  0019f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _urb$[ebp+8], OFFSET FLAT:?CompleteProc@@YGXPAT_URB@@PAX@Z ; CompleteProc
  001a6	89 45 d8	 mov	 DWORD PTR _urb$[ebp+12], eax
  001a9	89 5d e4	 mov	 DWORD PTR _urb$[ebp+24], ebx
  001ac	89 55 e0	 mov	 DWORD PTR _urb$[ebp+20], edx
  001af	c6 45 e8 02	 mov	 BYTE PTR _urb$[ebp+28], 2
  001b3	c6 45 e9 01	 mov	 BYTE PTR _urb$[ebp+29], 1
$L37297:
  001b7	89 75 dc	 mov	 DWORD PTR _urb$[ebp+16], esi

; 321  : 		maxwaittime = _WAIT;	//roughly 3 milliseconds
; 322  : 		//(if a 64-byte packet comes back, ohci requests another one until our buffer is full)
; 323  : 	}
; 324  : 	gYouMayPass = 0;

  001ba	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gYouMayPass@@3HC, 0 ; gYouMayPass

; 325  : 
; 326  : 	__int64 tim = gettsc();

  001c4	0f 31		 rdtsc

; 327  : 	retcode = pud->SubmitRequest(&urb);

  001c6	8b 4d fc	 mov	 ecx, DWORD PTR _pud$[ebp]
  001c9	8b f8		 mov	 edi, eax
  001cb	8d 45 cc	 lea	 eax, DWORD PTR _urb$[ebp]
  001ce	50		 push	 eax
  001cf	8b f2		 mov	 esi, edx
  001d1	e8 00 00 00 00	 call	 ?SubmitRequest@IUsbDevice@@QAEJPAT_URB@@@Z ; IUsbDevice::SubmitRequest
  001d6	89 45 0c	 mov	 DWORD PTR _retcode$[ebp], eax
  001d9	b9 00 b2 9b d3	 mov	 ecx, -744771072		; d39bb200H
$L36983:

; 328  : 
; 329  : 	while(!gYouMayPass && (gettsc() - tim) < maxwaittime) { }	//wait to time out, or for request to come back

  001de	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gYouMayPass@@3HC, 0 ; gYouMayPass
  001e5	75 11		 jne	 SHORT $L37294
  001e7	0f 31		 rdtsc
  001e9	2b c7		 sub	 eax, edi
  001eb	1b d6		 sbb	 edx, esi
  001ed	83 fa 06	 cmp	 edx, 6
  001f0	7c ec		 jl	 SHORT $L36983
  001f2	7f 04		 jg	 SHORT $L37294
  001f4	3b c1		 cmp	 eax, ecx
  001f6	72 e6		 jb	 SHORT $L36983
$L37294:

; 330  : 
; 331  : 	if((gettsc() - tim) > maxwaittime) {	//if we timed out

  001f8	0f 31		 rdtsc
  001fa	2b c7		 sub	 eax, edi
  001fc	1b d6		 sbb	 edx, esi
  001fe	83 fa 06	 cmp	 edx, 6
  00201	7c 1b		 jl	 SHORT $L36988
  00203	7f 04		 jg	 SHORT $L37295
  00205	3b c1		 cmp	 eax, ecx
  00207	76 15		 jbe	 SHORT $L36988
$L37295:

; 332  : 		pud->CancelRequest(&urb);			//cancel request

  00209	8b 4d fc	 mov	 ecx, DWORD PTR _pud$[ebp]
  0020c	8d 45 cc	 lea	 eax, DWORD PTR _urb$[ebp]
  0020f	50		 push	 eax
  00210	e8 00 00 00 00	 call	 ?CancelRequest@IUsbDevice@@QAEJPAT_URB@@@Z ; IUsbDevice::CancelRequest
$L36987:

; 333  : 		while(!gYouMayPass) { }				//and wait for the thing to cancel

  00215	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gYouMayPass@@3HC, 0 ; gYouMayPass
  0021c	74 f7		 je	 SHORT $L36987
$L36988:

; 334  : 	}
; 335  : 
; 336  : 	//we got a response!
; 337  : 	if(~gYouMayPass != USBD_STATUS_CANCELED) {

  0021e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gYouMayPass@@3HC ; gYouMayPass
  00223	f7 d0		 not	 eax
  00225	3d 0f 00 00 c0	 cmp	 eax, -1073741809	; c000000fH
  0022a	74 39		 je	 SHORT $L37296

; 338  : 		retcode = ~gYouMayPass;

  0022c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gYouMayPass@@3HC ; gYouMayPass
  00231	f7 d0		 not	 eax

; 339  : 		if(retcode != USBD_STATUS_SUCCESS) {

  00233	85 c0		 test	 eax, eax
  00235	89 45 0c	 mov	 DWORD PTR _retcode$[ebp], eax
  00238	74 2b		 je	 SHORT $L37296

; 340  : 			DBGPRINT(3, ("request completed, with error: %x\n"
; 341  : 				"returned data size: %d, first 8 bytes = %016I64x\n", 
; 342  : 				retcode, urb.BulkOrInterruptTransfer.TransferBufferLength, *(INT64*)data));

  0023a	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?DebugLevel@@3KA, 3 ; DebugLevel
  00241	72 22		 jb	 SHORT $L37296
  00243	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  00248	e8 00 00 00 00	 call	 _DbgPrint
  0024d	ff 73 04	 push	 DWORD PTR [ebx+4]
  00250	ff 33		 push	 DWORD PTR [ebx]
  00252	ff 75 e0	 push	 DWORD PTR _urb$[ebp+20]
  00255	ff 75 0c	 push	 DWORD PTR _retcode$[ebp]
  00258	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FE@IMMOFDKE@request?5completed?0?5with?5error?3?5?$CF@
  0025d	e8 00 00 00 00	 call	 _DbgPrint
  00262	83 c4 18	 add	 esp, 24			; 00000018H
$L37296:

; 343  : 		}
; 344  : 	}
; 345  : 
; 346  : 	if(ENDPOINT_TYPE(Endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) { 

  00265	80 7d 0b 01	 cmp	 BYTE PTR tv321[ebp], 1
  00269	74 09		 je	 SHORT $L36997

; 347  : 		//*len = *len //hope that we really got that much data back
; 348  : 	} else {
; 349  : 		*len = (USHORT)urb.BulkOrInterruptTransfer.TransferBufferLength;

  0026b	0f b7 45 e0	 movzx	 eax, WORD PTR _urb$[ebp+20]
  0026f	8b 4d 14	 mov	 ecx, DWORD PTR _len$[ebp]
  00272	89 01		 mov	 DWORD PTR [ecx], eax
$L36997:

; 350  : 	}
; 351  : 
; 352  : 	//CloseEndpoint(pud, Endpoint, ourendpoint);
; 353  : 	CloseEndpoint(pud, closeendpoint, ourendpoint);
; 354  : 
; 355  : 	return retcode;

  00274	8b 45 0c	 mov	 eax, DWORD PTR _retcode$[ebp]
$L36936:
  00277	5f		 pop	 edi
  00278	5e		 pop	 esi
  00279	5b		 pop	 ebx

; 356  : }

  0027a	c9		 leave
  0027b	c2 10 00	 ret	 16			; 00000010H
_SlixdIn@16 ENDP
XPPCODE	ENDS
PUBLIC	??_C@_0DB@IGCMIKNF@ERROR?$CB?5Can?8t?5send?5additional?5OUT@ ; `string'
PUBLIC	??_C@_0CD@DDCPLDCC@request?5completed?0?5with?5error?3?5?$CF@ ; `string'
PUBLIC	??_C@_0DC@PIBIDPPL@returned?5data?5size?3?5?$CFd?0?5first?58?5@ ; `string'
PUBLIC	_SlixdOut@16
;	COMDAT ??_C@_0DB@IGCMIKNF@ERROR?$CB?5Can?8t?5send?5additional?5OUT@
XPPRDATA	SEGMENT
??_C@_0DB@IGCMIKNF@ERROR?$CB?5Can?8t?5send?5additional?5OUT@ DB 'ERROR! C'
	DB	'an''t send additional OUTs to endpoint 0', 0aH, 00H ; `string'
XPPRDATA	ENDS
;	COMDAT ??_C@_0CD@DDCPLDCC@request?5completed?0?5with?5error?3?5?$CF@
XPPRDATA	SEGMENT
??_C@_0CD@DDCPLDCC@request?5completed?0?5with?5error?3?5?$CF@ DB 'request'
	DB	' completed, with error: %x', 0aH, 00H	; `string'
XPPRDATA	ENDS
;	COMDAT ??_C@_0DC@PIBIDPPL@returned?5data?5size?3?5?$CFd?0?5first?58?5@
XPPRDATA	SEGMENT
??_C@_0DC@PIBIDPPL@returned?5data?5size?3?5?$CFd?0?5first?58?5@ DB 'retur'
	DB	'ned data size: %d, first 8 bytes = %016I64x', 0aH, 00H ; `string'
; Function compile flags: /Ogs
XPPRDATA	ENDS
;	COMDAT _SlixdOut@16
XPPCODE	SEGMENT
_urb$ = -48
_bufd$37027 = -32
_pud$ = 8
_Address$ = 8
_Endpoint$ = 12
_data$ = 16
_len$ = 20
_SlixdOut@16 PROC NEAR					; COMDAT

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 369  : 	DEVICE_EXTENSION * de;
; 370  : 	URB urb;
; 371  : 	IUsbDevice * pud;
; 372  : 	LONG temp;
; 373  : 	USBD_STATUS retcode = USBD_STATUS_ERROR;
; 374  : 	HANDLE ourendpoint;
; 375  : 	int port, slot;
; 376  : 	__int64 maxwaittime;
; 377  : 
; 378  : 	port = PORT_FROM_ADDRESS(Address);

  00006	8a 55 08	 mov	 dl, BYTE PTR _Address$[ebp]
  00009	0f b6 c2	 movzx	 eax, dl
  0000c	8b c8		 mov	 ecx, eax

; 379  : 	slot = SLOT_FROM_ADDRESS(Address);

  0000e	c1 e8 04	 shr	 eax, 4
  00011	83 e0 07	 and	 eax, 7
  00014	83 e1 0f	 and	 ecx, 15			; 0000000fH

; 380  : 
; 381  : 	gDriverExtension->LastAddress = Address;	//so that we don't have to guess when we do SetDataToggles
; 382  : 	de = &gDriverExtension->Nodes[port][slot];

  00017	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0001a	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00020	56		 push	 esi
  00021	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gDriverExtension@@3PAUSLIX_DRIVER_EXTENSION@@A ; gDriverExtension
  00027	88 96 00 15 00
	00		 mov	 BYTE PTR [esi+5376], dl
  0002d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gDriverExtension@@3PAUSLIX_DRIVER_EXTENSION@@A ; gDriverExtension

; 383  : 	pud = de->Device;

  00033	8b 30		 mov	 esi, DWORD PTR [eax]

; 384  : 
; 385  : 	if (pud == NULL) {

  00035	85 f6		 test	 esi, esi
  00037	89 75 08	 mov	 DWORD PTR _pud$[ebp], esi
  0003a	75 0a		 jne	 SHORT $L37015

; 386  : 		//the device isn't connected
; 387  : 		return USBD_STATUS_ERROR;

  0003c	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00041	e9 80 01 00 00	 jmp	 $L37004
$L37015:
  00046	53		 push	 ebx

; 388  : 	}
; 389  : 
; 390  : 	if(Endpoint == 0) {

  00047	8b 5d 0c	 mov	 ebx, DWORD PTR _Endpoint$[ebp]
  0004a	84 db		 test	 bl, bl
  0004c	75 2a		 jne	 SHORT $L37017

; 391  : 		DBGPRINT(3,("ERROR! Can't send additional OUTs to endpoint 0\n"));

  0004e	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?DebugLevel@@3KA, 3 ; DebugLevel
  00055	72 17		 jb	 SHORT $L37018
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  0005c	e8 00 00 00 00	 call	 _DbgPrint
  00061	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET FLAT:??_C@_0DB@IGCMIKNF@ERROR?$CB?5Can?8t?5send?5additional?5OUT@
  00068	e8 00 00 00 00	 call	 _DbgPrint
  0006d	59		 pop	 ecx
$L37018:

; 392  : //		*len = 0;
; 393  : 		return USBD_STATUS_ERROR;

  0006e	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00073	e9 4d 01 00 00	 jmp	 $L37323
$L37017:

; 394  : 	}
; 395  : 
; 396  : 	ourendpoint = GetEndpoint(pud, Endpoint);

  00078	53		 push	 ebx
  00079	56		 push	 esi
  0007a	e8 00 00 00 00	 call	 ?GetEndpoint@@YGPAXPAVIUsbDevice@@E@Z ; GetEndpoint

; 397  : 	
; 398  : 	if(data == NULL) {

  0007f	83 7d 10 00	 cmp	 DWORD PTR _data$[ebp], 0
  00083	8b d0		 mov	 edx, eax
  00085	75 06		 jne	 SHORT $L37022

; 399  : 		if(len != 0) {

  00087	83 7d 14 00	 cmp	 DWORD PTR _len$[ebp], 0

; 400  : 			return USBD_STATUS_ERROR;	//trying to send data that doesn't exist??

  0008b	75 e1		 jne	 SHORT $L37018
$L37022:

; 401  : 		}
; 402  : 	}
; 403  : 
; 404  : 	//if(ourendpoint == NULL && Endpoint != 0) {
; 405  : 	if(ourendpoint == NULL && (ENDPOINT_NUM(Endpoint) != 0)) {                                           //changed by Bing from above line to this, this should be the same as SlixDIN().

  0008d	85 d2		 test	 edx, edx
  0008f	75 12		 jne	 SHORT $L37024
  00091	33 c0		 xor	 eax, eax
  00093	8a c3		 mov	 al, bl
  00095	83 e0 0f	 and	 eax, 15			; 0000000fH
  00098	84 db		 test	 bl, bl
  0009a	78 03		 js	 SHORT $L37304
  0009c	83 c0 10	 add	 eax, 16			; 00000010H
$L37304:
  0009f	85 c0		 test	 eax, eax

; 406  : 		//the endpoint couldn't be opened... if Endpoint == 0, the endpoint handle is always NULL.
; 407  : 		return USBD_STATUS_ERROR;

  000a1	75 cb		 jne	 SHORT $L37018
$L37024:
  000a3	57		 push	 edi

; 408  : 	}
; 409  : 
; 410  : 
; 411  : 	if(ENDPOINT_TYPE(Endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) {		//isoch
; 412  : 		USBD_ISOCH_BUFFER_DESCRIPTOR bufd;
; 413  : 
; 414  : 		bufd.Context = (void*)pud;
; 415  : 		bufd.FrameCount = 1;
; 416  : 		bufd.Pattern[0] = (USHORT)len;
; 417  : 		bufd.Pattern[1] = 0;
; 418  : 		bufd.TransferBuffer = data;
; 419  : 		bufd.TransferComplete = IsochCompleteProc; 
; 420  : 		RtlZeroMemory(&urb, sizeof(URB));

  000a4	6a 0c		 push	 12			; 0000000cH
  000a6	33 c0		 xor	 eax, eax
  000a8	80 e3 30	 and	 bl, 48			; 00000030H
  000ab	80 fb 10	 cmp	 bl, 16			; 00000010H
  000ae	8d 7d d0	 lea	 edi, DWORD PTR _urb$[ebp]
  000b1	59		 pop	 ecx
  000b2	f3 ab		 rep stosd

; 421  : 		USB_BUILD_ISOCH_ATTACH_BUFFER((&urb.IsochAttachBuffer), ourendpoint, USBD_DELAY_INTERRUPT_0_MS, &bufd);

  000b4	89 55 e0	 mov	 DWORD PTR _urb$[ebp+16], edx
  000b7	75 19		 jne	 SHORT $L37026
  000b9	21 45 d8	 and	 DWORD PTR _urb$[ebp+8], eax
  000bc	21 45 dc	 and	 DWORD PTR _urb$[ebp+12], eax
  000bf	20 45 e4	 and	 BYTE PTR _urb$[ebp+20], al
  000c2	8d 45 e0	 lea	 eax, DWORD PTR _bufd$37027[ebp]
  000c5	c6 45 d0 1c	 mov	 BYTE PTR _urb$[ebp], 28	; 0000001cH
  000c9	c6 45 d1 0b	 mov	 BYTE PTR _urb$[ebp+1], 11 ; 0000000bH
  000cd	89 45 e8	 mov	 DWORD PTR _urb$[ebp+24], eax

; 422  : 		maxwaittime = _WAIT;	//3.1 milliseconds
; 423  : 
; 424  : 	} else {	//non-isoch

  000d0	eb 2a		 jmp	 SHORT $L37032
$L37026:

; 425  : 
; 426  : 		RtlZeroMemory(&urb,sizeof(URB));
; 427  : 		USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(&urb.BulkOrInterruptTransfer,
; 428  : 			ourendpoint, data, len, USB_TRANSFER_DIRECTION_OUT, 
; 429  : 			CompleteProc, (void*)pud, TRUE);

  000d2	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  000d5	80 65 ee 00	 and	 BYTE PTR _urb$[ebp+30], 0
  000d9	89 45 e8	 mov	 DWORD PTR _urb$[ebp+24], eax
  000dc	8b 45 14	 mov	 eax, DWORD PTR _len$[ebp]
  000df	c6 45 d0 28	 mov	 BYTE PTR _urb$[ebp], 40	; 00000028H
  000e3	c6 45 d1 41	 mov	 BYTE PTR _urb$[ebp+1], 65 ; 00000041H
  000e7	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _urb$[ebp+8], OFFSET FLAT:?CompleteProc@@YGXPAT_URB@@PAX@Z ; CompleteProc
  000ee	89 75 dc	 mov	 DWORD PTR _urb$[ebp+12], esi
  000f1	89 45 e4	 mov	 DWORD PTR _urb$[ebp+20], eax
  000f4	c6 45 ec 01	 mov	 BYTE PTR _urb$[ebp+28], 1
  000f8	c6 45 ed 01	 mov	 BYTE PTR _urb$[ebp+29], 1
$L37032:

; 430  : 		maxwaittime = _WAIT;		//wait 3 milliseconds
; 431  : 
; 432  : 	}
; 433  : 	gYouMayPass = 0;

  000fc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gYouMayPass@@3HC, 0 ; gYouMayPass

; 434  : 
; 435  : 
; 436  : 
; 437  : 	__int64 tim = gettsc();

  00106	0f 31		 rdtsc

; 438  : 	retcode = pud->SubmitRequest(&urb);

  00108	8b 4d 08	 mov	 ecx, DWORD PTR _pud$[ebp]
  0010b	8b f0		 mov	 esi, eax
  0010d	8d 45 d0	 lea	 eax, DWORD PTR _urb$[ebp]
  00110	50		 push	 eax
  00111	8b fa		 mov	 edi, edx
  00113	e8 00 00 00 00	 call	 ?SubmitRequest@IUsbDevice@@QAEJPAT_URB@@@Z ; IUsbDevice::SubmitRequest
  00118	8b d8		 mov	 ebx, eax
  0011a	b9 00 b2 9b d3	 mov	 ecx, -744771072		; d39bb200H
$L37038:

; 439  : 
; 440  : 	while(!gYouMayPass && (gettsc() - tim) < maxwaittime) { }	//wait to time out, or for response

  0011f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gYouMayPass@@3HC, 0 ; gYouMayPass
  00126	75 11		 jne	 SHORT $L37321
  00128	0f 31		 rdtsc
  0012a	2b c6		 sub	 eax, esi
  0012c	1b d7		 sbb	 edx, edi
  0012e	83 fa 06	 cmp	 edx, 6
  00131	7c ec		 jl	 SHORT $L37038
  00133	7f 04		 jg	 SHORT $L37321
  00135	3b c1		 cmp	 eax, ecx
  00137	72 e6		 jb	 SHORT $L37038
$L37321:

; 441  : 
; 442  : 	if((gettsc() - tim) > maxwaittime) {

  00139	0f 31		 rdtsc
  0013b	2b c6		 sub	 eax, esi
  0013d	1b d7		 sbb	 edx, edi
  0013f	83 fa 06	 cmp	 edx, 6
  00142	5f		 pop	 edi
  00143	7c 1b		 jl	 SHORT $L37043
  00145	7f 04		 jg	 SHORT $L37322
  00147	3b c1		 cmp	 eax, ecx
  00149	76 15		 jbe	 SHORT $L37043
$L37322:

; 443  : 		pud->CancelRequest(&urb);

  0014b	8b 4d 08	 mov	 ecx, DWORD PTR _pud$[ebp]
  0014e	8d 45 d0	 lea	 eax, DWORD PTR _urb$[ebp]
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 ?CancelRequest@IUsbDevice@@QAEJPAT_URB@@@Z ; IUsbDevice::CancelRequest
$L37042:

; 444  : 		while(!gYouMayPass) { }

  00157	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gYouMayPass@@3HC, 0 ; gYouMayPass
  0015e	74 f7		 je	 SHORT $L37042
$L37043:

; 445  : 	}
; 446  : 
; 447  : 	if(~gYouMayPass != USBD_STATUS_CANCELED) {

  00160	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gYouMayPass@@3HC ; gYouMayPass
  00165	f7 d0		 not	 eax
  00167	3d 0f 00 00 c0	 cmp	 eax, -1073741809	; c000000fH
  0016c	74 55		 je	 SHORT $L37050

; 448  : 		retcode = ~gYouMayPass;

  0016e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gYouMayPass@@3HC ; gYouMayPass
  00174	f7 d3		 not	 ebx

; 449  : 		if(retcode != USBD_STATUS_SUCCESS) {

  00176	85 db		 test	 ebx, ebx
  00178	74 49		 je	 SHORT $L37050

; 450  : 			DBGPRINT(3, ("request completed, with error: %x\n", retcode));

  0017a	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?DebugLevel@@3KA, 3 ; DebugLevel
  00181	72 40		 jb	 SHORT $L37050
  00183	be 00 00 00 00	 mov	 esi, OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  00188	56		 push	 esi
  00189	e8 00 00 00 00	 call	 _DbgPrint
  0018e	53		 push	 ebx
  0018f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@DDCPLDCC@request?5completed?0?5with?5error?3?5?$CF@
  00194	e8 00 00 00 00	 call	 _DbgPrint
  00199	83 c4 0c	 add	 esp, 12			; 0000000cH

; 451  : 			DBGPRINT(3, ("returned data size: %d, first 8 bytes = %016I64x\n", 
; 452  : 				urb.BulkOrInterruptTransfer.TransferBufferLength, *(INT64*)data));

  0019c	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?DebugLevel@@3KA, 3 ; DebugLevel
  001a3	72 1e		 jb	 SHORT $L37050
  001a5	56		 push	 esi
  001a6	e8 00 00 00 00	 call	 _DbgPrint
  001ab	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  001ae	ff 70 04	 push	 DWORD PTR [eax+4]
  001b1	ff 30		 push	 DWORD PTR [eax]
  001b3	ff 75 e4	 push	 DWORD PTR _urb$[ebp+20]
  001b6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DC@PIBIDPPL@returned?5data?5size?3?5?$CFd?0?5first?58?5@
  001bb	e8 00 00 00 00	 call	 _DbgPrint
  001c0	83 c4 14	 add	 esp, 20			; 00000014H
$L37050:

; 453  : 		}
; 454  : 	}
; 455  : 
; 456  : 	CloseEndpoint(pud, Endpoint, ourendpoint);
; 457  : 
; 458  : 	return retcode;

  001c3	8b c3		 mov	 eax, ebx
$L37323:
  001c5	5b		 pop	 ebx
$L37004:
  001c6	5e		 pop	 esi

; 459  : }

  001c7	c9		 leave
  001c8	c2 10 00	 ret	 16			; 00000010H
_SlixdOut@16 ENDP
XPPCODE	ENDS
PUBLIC	??_C@_0N@JBJFAPFD@data?5?$DN?$DN?5NULL?$AA@	; `string'
PUBLIC	??_C@_0EG@KOJHEOLC@Setup?5packets?5should?5be?58?5bytes?$CB@ ; `string'
PUBLIC	??_C@_0BN@PKENIJJB@Setup?3?5len2?5is?5NOT?5optional?$CB?$AA@ ; `string'
PUBLIC	??_C@_0EB@FDNEOLJJ@sending?5data?5without?5enough?5buff@ ; `string'
PUBLIC	??_C@_0O@NODNEMBJ@data2?5?$DN?$DN?5NULL?$AA@	; `string'
PUBLIC	_SlixdSetup@24
;	COMDAT ??_C@_0N@JBJFAPFD@data?5?$DN?$DN?5NULL?$AA@
XPPRDATA	SEGMENT
??_C@_0N@JBJFAPFD@data?5?$DN?$DN?5NULL?$AA@ DB 'data == NULL', 00H ; `string'
XPPRDATA	ENDS
;	COMDAT ??_C@_0EG@KOJHEOLC@Setup?5packets?5should?5be?58?5bytes?$CB@
XPPRDATA	SEGMENT
??_C@_0EG@KOJHEOLC@Setup?5packets?5should?5be?58?5bytes?$CB@ DB 'Setup pa'
	DB	'ckets should be 8 bytes! len = %d, data = %016I64x, len2 = %d'
	DB	00H						; `string'
XPPRDATA	ENDS
;	COMDAT ??_C@_0BN@PKENIJJB@Setup?3?5len2?5is?5NOT?5optional?$CB?$AA@
XPPRDATA	SEGMENT
??_C@_0BN@PKENIJJB@Setup?3?5len2?5is?5NOT?5optional?$CB?$AA@ DB 'Setup: l'
	DB	'en2 is NOT optional!', 00H			; `string'
XPPRDATA	ENDS
;	COMDAT ??_C@_0EB@FDNEOLJJ@sending?5data?5without?5enough?5buff@
XPPRDATA	SEGMENT
??_C@_0EB@FDNEOLJJ@sending?5data?5without?5enough?5buff@ DB 'sending data'
	DB	' without enough buffer length?? len2: %d, extlen: %d', 00H ; `string'
XPPRDATA	ENDS
;	COMDAT ??_C@_0O@NODNEMBJ@data2?5?$DN?$DN?5NULL?$AA@
XPPRDATA	SEGMENT
??_C@_0O@NODNEMBJ@data2?5?$DN?$DN?5NULL?$AA@ DB 'data2 == NULL', 00H ; `string'
; Function compile flags: /Ogs
XPPRDATA	ENDS
;	COMDAT _SlixdSetup@24
XPPCODE	SEGMENT
_urb$ = -52
_pud$ = -4
_retcode$ = 8
_Address$ = 8
_Endpoint$ = 12
_data$ = 16
_len$ = 20
_data2$ = 24
_len2$ = 28
_SlixdSetup@24 PROC NEAR				; COMDAT

; 476  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 477  : 	DEVICE_EXTENSION * de;
; 478  : 	URB urb;
; 479  : 	IUsbDevice * pud;
; 480  : 	LONG temp;
; 481  : 	USBD_STATUS retcode = USBD_STATUS_ERROR;
; 482  : 	HANDLE ourendpoint;
; 483  : 	USHORT extlen;
; 484  : 	BYTE direction;
; 485  : 	int port, slot;
; 486  : 	__int64 maxwaittime;
; 487  : 
; 488  : 	port = PORT_FROM_ADDRESS(Address);

  00006	8a 55 08	 mov	 dl, BYTE PTR _Address$[ebp]
  00009	0f b6 c2	 movzx	 eax, dl
  0000c	8b c8		 mov	 ecx, eax

; 489  : 	slot = SLOT_FROM_ADDRESS(Address);

  0000e	c1 e8 04	 shr	 eax, 4
  00011	83 e0 07	 and	 eax, 7
  00014	83 e1 0f	 and	 ecx, 15			; 0000000fH

; 490  : 
; 491  : 	gDriverExtension->LastAddress = Address;	//so that we don't have to guess when we do SetDataToggles
; 492  : 	de = &gDriverExtension->Nodes[port][slot];

  00017	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0001a	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00020	56		 push	 esi
  00021	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gDriverExtension@@3PAUSLIX_DRIVER_EXTENSION@@A ; gDriverExtension
  00027	88 96 00 15 00
	00		 mov	 BYTE PTR [esi+5376], dl
  0002d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gDriverExtension@@3PAUSLIX_DRIVER_EXTENSION@@A ; gDriverExtension

; 493  : 	pud = de->Device;

  00033	8b 00		 mov	 eax, DWORD PTR [eax]

; 494  : 
; 495  : 	if (pud == NULL) {

  00035	85 c0		 test	 eax, eax
  00037	89 45 fc	 mov	 DWORD PTR _pud$[ebp], eax

; 496  : 		//the device isn't connected
; 497  : 		return USBD_STATUS_ERROR;

  0003a	74 5e		 je	 SHORT $L37081

; 498  : 	}
; 499  : 
; 500  : 	if(data == NULL) {

  0003c	8b 75 10	 mov	 esi, DWORD PTR _data$[ebp]
  0003f	85 f6		 test	 esi, esi
  00041	75 22		 jne	 SHORT $L37075

; 501  : 		DBGPRINT(1, ("data == NULL"));

  00043	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?DebugLevel@@3KA, 1 ; DebugLevel
  0004a	72 4e		 jb	 SHORT $L37081
  0004c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  00051	e8 00 00 00 00	 call	 _DbgPrint
  00056	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET FLAT:??_C@_0N@JBJFAPFD@data?5?$DN?$DN?5NULL?$AA@
  0005d	e8 00 00 00 00	 call	 _DbgPrint
  00062	59		 pop	 ecx

; 502  : 		return USBD_STATUS_ERROR;

  00063	eb 35		 jmp	 SHORT $L37081
$L37075:

; 503  : 	} else if(len != 8) {

  00065	83 7d 14 08	 cmp	 DWORD PTR _len$[ebp], 8
  00069	74 39		 je	 SHORT $L37080

; 504  : 		DBGPRINT(1, ("Setup packets should be 8 bytes! len = %d, data = %016I64x, len2 = %d", len, *(INT64*)data, *len2));

  0006b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?DebugLevel@@3KA, 1 ; DebugLevel
  00072	72 26		 jb	 SHORT $L37081
  00074	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  00079	e8 00 00 00 00	 call	 _DbgPrint
  0007e	8b 45 1c	 mov	 eax, DWORD PTR _len2$[ebp]
  00081	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00084	50		 push	 eax
  00085	ff 76 04	 push	 DWORD PTR [esi+4]
  00088	ff 36		 push	 DWORD PTR [esi]
  0008a	ff 75 14	 push	 DWORD PTR _len$[ebp]
  0008d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EG@KOJHEOLC@Setup?5packets?5should?5be?58?5bytes?$CB@
  00092	e8 00 00 00 00	 call	 _DbgPrint
  00097	83 c4 18	 add	 esp, 24			; 00000018H
$L37081:

; 505  : 		return USBD_STATUS_ERROR;

  0009a	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0009f	e9 f4 01 00 00	 jmp	 $L37060
$L37080:
  000a4	53		 push	 ebx

; 506  : 	} 
; 507  : 
; 508  : 	extlen = (*(USHORT*)&data[6]); //get the length of the data to send/recv

  000a5	66 8b 5e 06	 mov	 bx, WORD PTR [esi+6]
  000a9	57		 push	 edi

; 509  : 	if(!len2) {

  000aa	8b 7d 1c	 mov	 edi, DWORD PTR _len2$[ebp]
  000ad	85 ff		 test	 edi, edi
  000af	75 2a		 jne	 SHORT $L37086

; 510  : 		DBGPRINT(1, ("Setup: len2 is NOT optional!"));

  000b1	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?DebugLevel@@3KA, 1 ; DebugLevel
  000b8	72 17		 jb	 SHORT $L37087
  000ba	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  000bf	e8 00 00 00 00	 call	 _DbgPrint
  000c4	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET FLAT:??_C@_0BN@PKENIJJB@Setup?3?5len2?5is?5NOT?5optional?$CB?$AA@
$L37347:
  000cb	e8 00 00 00 00	 call	 _DbgPrint
  000d0	59		 pop	 ecx
$L37087:

; 511  : 		return USBD_STATUS_ERROR;

  000d1	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  000d6	e9 bb 01 00 00	 jmp	 $L37346
$L37086:

; 512  : 	} else if(*len2 < extlen) {

  000db	66 8b 0f	 mov	 cx, WORD PTR [edi]
  000de	66 3b cb	 cmp	 cx, bx
  000e1	73 2a		 jae	 SHORT $L37091

; 513  : 		DBGPRINT(1, ("sending data without enough buffer length?? len2: %d, extlen: %d", *len2, extlen));

  000e3	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?DebugLevel@@3KA, 1 ; DebugLevel
  000ea	72 e5		 jb	 SHORT $L37087
  000ec	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  000f1	e8 00 00 00 00	 call	 _DbgPrint
  000f6	0f b7 c3	 movzx	 eax, bx
  000f9	50		 push	 eax
  000fa	0f b7 07	 movzx	 eax, WORD PTR [edi]
  000fd	50		 push	 eax
  000fe	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@FDNEOLJJ@sending?5data?5without?5enough?5buff@
  00103	e8 00 00 00 00	 call	 _DbgPrint
  00108	83 c4 10	 add	 esp, 16			; 00000010H

; 514  : 		return USBD_STATUS_ERROR;

  0010b	eb c4		 jmp	 SHORT $L37087
$L37091:

; 515  : 	}
; 516  : 
; 517  : 	if(*len2 > 2048) *len2 = 2048;	//can't send or expect too much data, due to ohci requrements

  0010d	66 81 f9 00 08	 cmp	 cx, 2048		; 00000800H
  00112	76 05		 jbe	 SHORT $L37095
  00114	66 c7 07 00 08	 mov	 WORD PTR [edi], 2048	; 00000800H
$L37095:

; 518  : 
; 519  : 	if(*len2 > 0) {

  00119	66 83 3f 00	 cmp	 WORD PTR [edi], 0
  0011d	76 2c		 jbe	 SHORT $L37096

; 520  : 		if(data2 == NULL) {

  0011f	83 7d 18 00	 cmp	 DWORD PTR _data2$[ebp], 0
  00123	75 1c		 jne	 SHORT $L37097

; 521  : 			DBGPRINT(1, ("data2 == NULL"));

  00125	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?DebugLevel@@3KA, 1 ; DebugLevel
  0012c	72 a3		 jb	 SHORT $L37087
  0012e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  00133	e8 00 00 00 00	 call	 _DbgPrint
  00138	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET FLAT:??_C@_0O@NODNEMBJ@data2?5?$DN?$DN?5NULL?$AA@

; 522  : 			return USBD_STATUS_ERROR;

  0013f	eb 8a		 jmp	 SHORT $L37347
$L37097:

; 523  : 		}
; 524  : 
; 525  : 		direction = (data[0] & 128) ? USB_TRANSFER_DIRECTION_IN : USB_TRANSFER_DIRECTION_OUT;

  00141	f6 06 80	 test	 BYTE PTR [esi], 128	; 00000080H
  00144	0f 95 c3	 setne	 bl
  00147	fe c3		 inc	 bl

; 526  : 	} else {

  00149	eb 02		 jmp	 SHORT $L37101
$L37096:

; 527  : 		direction = 0;

  0014b	32 db		 xor	 bl, bl
$L37101:

; 528  : 	}
; 529  : 
; 530  : 	ourendpoint = GetEndpoint(pud, Endpoint);

  0014d	ff 75 0c	 push	 DWORD PTR _Endpoint$[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 ?GetEndpoint@@YGPAXPAVIUsbDevice@@E@Z ; GetEndpoint
  00156	8b d0		 mov	 edx, eax

; 531  : 
; 532  : 	if(ourendpoint == NULL && Endpoint != 0) {

  00158	85 d2		 test	 edx, edx
  0015a	75 09		 jne	 SHORT $L37102
  0015c	38 45 0c	 cmp	 BYTE PTR _Endpoint$[ebp], al

; 533  : 		//the endpoint couldn't be opened... if Endpoint == 0, the endpoint handle is always NULL.
; 534  : 		return USBD_STATUS_ERROR;

  0015f	0f 85 6c ff ff
	ff		 jne	 $L37087
$L37102:

; 535  : 	}
; 536  : 	
; 537  : 	RtlZeroMemory(&urb,sizeof(URB));

  00165	33 c0		 xor	 eax, eax
  00167	6a 0c		 push	 12			; 0000000cH
  00169	59		 pop	 ecx
  0016a	8d 7d cc	 lea	 edi, DWORD PTR _urb$[ebp]
  0016d	f3 ab		 rep stosd

; 538  : 	USB_BUILD_CONTROL_TRANSFER(&urb.ControlTransfer,
; 539  : 		ourendpoint, data2, *len2, direction,		////////////////////data2
; 540  : 		CompleteProc, (void*)pud, TRUE,
; 541  : 		data[0], data[1], (*(USHORT*)&data[2]), (*(USHORT*)&data[4]), (*(USHORT*)&data[6]) );

  0016f	8b 45 18	 mov	 eax, DWORD PTR _data2$[ebp]
  00172	8b 4d fc	 mov	 ecx, DWORD PTR _pud$[ebp]
  00175	80 65 ea 00	 and	 BYTE PTR _urb$[ebp+30], 0
  00179	89 45 e4	 mov	 DWORD PTR _urb$[ebp+24], eax
  0017c	8b 45 1c	 mov	 eax, DWORD PTR _len2$[ebp]
  0017f	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00182	89 45 e0	 mov	 DWORD PTR _urb$[ebp+20], eax
  00185	8a 06		 mov	 al, BYTE PTR [esi]
  00187	88 45 f4	 mov	 BYTE PTR _urb$[ebp+40], al
  0018a	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  0018d	88 45 f5	 mov	 BYTE PTR _urb$[ebp+41], al
  00190	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]
  00194	66 89 45 f6	 mov	 WORD PTR _urb$[ebp+42], ax
  00198	66 8b 46 04	 mov	 ax, WORD PTR [esi+4]
  0019c	66 89 45 f8	 mov	 WORD PTR _urb$[ebp+44], ax
  001a0	66 8b 46 06	 mov	 ax, WORD PTR [esi+6]
  001a4	c6 45 cc 30	 mov	 BYTE PTR _urb$[ebp], 48	; 00000030H
  001a8	c6 45 cd 40	 mov	 BYTE PTR _urb$[ebp+1], 64 ; 00000040H
  001ac	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _urb$[ebp+8], OFFSET FLAT:?CompleteProc@@YGXPAT_URB@@PAX@Z ; CompleteProc
  001b3	89 4d d8	 mov	 DWORD PTR _urb$[ebp+12], ecx
  001b6	89 55 dc	 mov	 DWORD PTR _urb$[ebp+16], edx
  001b9	88 5d e8	 mov	 BYTE PTR _urb$[ebp+28], bl
  001bc	c6 45 e9 01	 mov	 BYTE PTR _urb$[ebp+29], 1
  001c0	66 89 45 fa	 mov	 WORD PTR _urb$[ebp+46], ax

; 542  : 
; 543  : 
; 544  : 	gYouMayPass = 0;

  001c4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gYouMayPass@@3HC, 0 ; gYouMayPass

; 545  : 	__int64 tim = gettsc();

  001ce	0f 31		 rdtsc
  001d0	8b f8		 mov	 edi, eax

; 546  : 	retcode = pud->SubmitRequest(&urb);

  001d2	8d 45 cc	 lea	 eax, DWORD PTR _urb$[ebp]
  001d5	50		 push	 eax
  001d6	8b da		 mov	 ebx, edx
  001d8	e8 00 00 00 00	 call	 ?SubmitRequest@IUsbDevice@@QAEJPAT_URB@@@Z ; IUsbDevice::SubmitRequest
  001dd	89 45 08	 mov	 DWORD PTR _retcode$[ebp], eax
  001e0	b9 00 b2 9b d3	 mov	 ecx, -744771072		; d39bb200H
$L37112:

; 547  : 
; 548  :     maxwaittime = _WAIT;        //wait 3 milliseconds
; 549  : 	
; 550  :     while(!gYouMayPass && (gettsc() - tim) < maxwaittime) { }               //wait for 3 milliseconds, or for the response.

  001e5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gYouMayPass@@3HC, 0 ; gYouMayPass
  001ec	75 11		 jne	 SHORT $L37343
  001ee	0f 31		 rdtsc
  001f0	2b c7		 sub	 eax, edi
  001f2	1b d3		 sbb	 edx, ebx
  001f4	83 fa 06	 cmp	 edx, 6
  001f7	7c ec		 jl	 SHORT $L37112
  001f9	7f 04		 jg	 SHORT $L37343
  001fb	3b c1		 cmp	 eax, ecx
  001fd	72 e6		 jb	 SHORT $L37112
$L37343:

; 551  : 
; 552  : 	if((gettsc() - tim) > maxwaittime) {

  001ff	0f 31		 rdtsc
  00201	2b c7		 sub	 eax, edi
  00203	1b d3		 sbb	 edx, ebx
  00205	83 fa 06	 cmp	 edx, 6
  00208	7c 1b		 jl	 SHORT $L37117
  0020a	7f 04		 jg	 SHORT $L37344
  0020c	3b c1		 cmp	 eax, ecx
  0020e	76 15		 jbe	 SHORT $L37117
$L37344:

; 553  : 		pud->CancelRequest(&urb);

  00210	8b 4d fc	 mov	 ecx, DWORD PTR _pud$[ebp]
  00213	8d 45 cc	 lea	 eax, DWORD PTR _urb$[ebp]
  00216	50		 push	 eax
  00217	e8 00 00 00 00	 call	 ?CancelRequest@IUsbDevice@@QAEJPAT_URB@@@Z ; IUsbDevice::CancelRequest
$L37116:

; 554  : 		while(!gYouMayPass) { }

  0021c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gYouMayPass@@3HC, 0 ; gYouMayPass
  00223	74 f7		 je	 SHORT $L37116
$L37117:

; 555  : 	}
; 556  : 
; 557  : 	if(~gYouMayPass != USBD_STATUS_CANCELED) {

  00225	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gYouMayPass@@3HC ; gYouMayPass
  0022a	f7 d0		 not	 eax
  0022c	3d 0f 00 00 c0	 cmp	 eax, -1073741809	; c000000fH
  00231	74 56		 je	 SHORT $L37345

; 558  : 		retcode = ~gYouMayPass;

  00233	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gYouMayPass@@3HC ; gYouMayPass
  00238	f7 d0		 not	 eax

; 559  : 		if(retcode != USBD_STATUS_SUCCESS) {

  0023a	85 c0		 test	 eax, eax
  0023c	89 45 08	 mov	 DWORD PTR _retcode$[ebp], eax
  0023f	74 48		 je	 SHORT $L37345

; 560  : 			DBGPRINT(3, ("request completed, with error: %x\n", retcode));

  00241	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?DebugLevel@@3KA, 3 ; DebugLevel
  00248	72 3f		 jb	 SHORT $L37345
  0024a	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:??_C@_07EDDFIMDA@SlixD?3?5?$AA@
  0024f	57		 push	 edi
  00250	e8 00 00 00 00	 call	 _DbgPrint
  00255	ff 75 08	 push	 DWORD PTR _retcode$[ebp]
  00258	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@DDCPLDCC@request?5completed?0?5with?5error?3?5?$CF@
  0025d	e8 00 00 00 00	 call	 _DbgPrint
  00262	83 c4 0c	 add	 esp, 12			; 0000000cH

; 561  : 			DBGPRINT(3, ("returned data size: %d, first 8 bytes = %016I64x\n", 
; 562  : 				urb.BulkOrInterruptTransfer.TransferBufferLength, *(INT64*)data));

  00265	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?DebugLevel@@3KA, 3 ; DebugLevel
  0026c	72 1b		 jb	 SHORT $L37345
  0026e	57		 push	 edi
  0026f	e8 00 00 00 00	 call	 _DbgPrint
  00274	ff 76 04	 push	 DWORD PTR [esi+4]
  00277	ff 36		 push	 DWORD PTR [esi]
  00279	ff 75 e0	 push	 DWORD PTR _urb$[ebp+20]
  0027c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DC@PIBIDPPL@returned?5data?5size?3?5?$CFd?0?5first?58?5@
  00281	e8 00 00 00 00	 call	 _DbgPrint
  00286	83 c4 14	 add	 esp, 20			; 00000014H
$L37345:

; 563  : 		}
; 564  : 	}
; 565  : 
; 566  : 
; 567  : 	*len2 = (USHORT)urb.ControlTransfer.TransferBufferLength;

  00289	66 8b 45 e0	 mov	 ax, WORD PTR _urb$[ebp+20]
  0028d	8b 4d 1c	 mov	 ecx, DWORD PTR _len2$[ebp]
  00290	66 89 01	 mov	 WORD PTR [ecx], ax

; 568  : 
; 569  : 	CloseEndpoint(pud, Endpoint, ourendpoint);
; 570  : 	return retcode;

  00293	8b 45 08	 mov	 eax, DWORD PTR _retcode$[ebp]
$L37346:
  00296	5f		 pop	 edi
  00297	5b		 pop	 ebx
$L37060:
  00298	5e		 pop	 esi

; 571  : }

  00299	c9		 leave
  0029a	c2 18 00	 ret	 24			; 00000018H
_SlixdSetup@24 ENDP
XPPCODE	ENDS
PUBLIC	_SlixdData0@4
; Function compile flags: /Ogs
;	COMDAT _SlixdData0@4
XPPCODE	SEGMENT
_urb$ = -48
_Endpoint$ = 8
_SlixdData0@4 PROC NEAR					; COMDAT

; 580  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 581  : 	DEVICE_EXTENSION * de;
; 582  : 	URB urb;
; 583  : 	IUsbDevice * pud;
; 584  : 	BYTE Address;
; 585  : 	HANDLE ourendpoint;
; 586  : 
; 587  : 	Address = gDriverExtension->LastAddress;

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gDriverExtension@@3PAUSLIX_DRIVER_EXTENSION@@A ; gDriverExtension
  0000c	8a 81 00 15 00
	00		 mov	 al, BYTE PTR [ecx+5376]

; 588  : 	if(SLOT_FROM_ADDRESS(Address) > 0x7) Address = 0;

  00012	8a d0		 mov	 dl, al
  00014	80 e2 70	 and	 dl, 112			; 00000070H
  00017	80 fa 70	 cmp	 dl, 112			; 00000070H
  0001a	76 02		 jbe	 SHORT $L37134
  0001c	32 c0		 xor	 al, al
$L37134:

; 605  : 	pud->SubmitRequest(&urb);

  0001e	0f b6 c0	 movzx	 eax, al
  00021	8b d0		 mov	 edx, eax
  00023	c1 ea 04	 shr	 edx, 4
  00026	83 e0 0f	 and	 eax, 15			; 0000000fH
  00029	83 e2 07	 and	 edx, 7
  0002c	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  0002f	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00035	56		 push	 esi
  00036	8b 34 08	 mov	 esi, DWORD PTR [eax+ecx]
  00039	85 f6		 test	 esi, esi
  0003b	74 33		 je	 SHORT $L37352
  0003d	ff 75 08	 push	 DWORD PTR _Endpoint$[ebp]
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?GetEndpoint@@YGPAXPAVIUsbDevice@@E@Z ; GetEndpoint
  00046	85 c0		 test	 eax, eax
  00048	75 05		 jne	 SHORT $L37136

; 589  : 	de = &gDriverExtension->Nodes[PORT_FROM_ADDRESS(Address)][SLOT_FROM_ADDRESS(Address)];
; 590  : 	pud = de->Device;
; 591  : 
; 592  : 	if (pud == NULL) {
; 593  : 		//the device isn't connected
; 594  : 		return;
; 595  : 	}
; 596  : 
; 597  : 	ourendpoint = GetEndpoint(pud, Endpoint);//de->endpoint[Endpoint];
; 598  : 	if(ourendpoint == NULL && Endpoint != 0) {

  0004a	38 45 08	 cmp	 BYTE PTR _Endpoint$[ebp], al
  0004d	75 21		 jne	 SHORT $L37352
$L37136:

; 599  : 		//the endpoint couldn't be opened... if Endpoint == 0, the endpoint handle is always NULL.
; 600  : 		return;
; 601  : 	}
; 602  : 
; 603  : 	USB_BUILD_SET_ENDPOINT_STATE((&urb.GetSetEndpointState), 
; 604  : 		ourendpoint, USB_ENDPOINT_STATE_DATA_TOGGLE_RESET);

  0004f	83 65 d8 00	 and	 DWORD PTR _urb$[ebp+8], 0
  00053	89 45 e0	 mov	 DWORD PTR _urb$[ebp+16], eax

; 605  : 	pud->SubmitRequest(&urb);

  00056	8d 45 d0	 lea	 eax, DWORD PTR _urb$[ebp]
  00059	50		 push	 eax
  0005a	8b ce		 mov	 ecx, esi
  0005c	c6 45 d0 18	 mov	 BYTE PTR _urb$[ebp], 24	; 00000018H
  00060	c6 45 d1 05	 mov	 BYTE PTR _urb$[ebp+1], 5
  00064	c7 45 e4 04 00
	00 00		 mov	 DWORD PTR _urb$[ebp+20], 4
  0006b	e8 00 00 00 00	 call	 ?SubmitRequest@IUsbDevice@@QAEJPAT_URB@@@Z ; IUsbDevice::SubmitRequest

; 606  : 	CloseEndpoint(pud, Endpoint, ourendpoint);

$L37352:
  00070	5e		 pop	 esi

; 607  : }

  00071	c9		 leave
  00072	c2 04 00	 ret	 4
_SlixdData0@4 ENDP
XPPCODE	ENDS
PUBLIC	_SlixdData1@4
; Function compile flags: /Ogs
;	COMDAT _SlixdData1@4
XPPCODE	SEGMENT
_urb$ = -48
_Endpoint$ = 8
_SlixdData1@4 PROC NEAR					; COMDAT

; 616  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 617  : 	DEVICE_EXTENSION * de;
; 618  : 	URB urb;
; 619  : 	IUsbDevice * pud;
; 620  : 	BYTE Address;
; 621  : 	HANDLE ourendpoint;
; 622  : 
; 623  : 	Address = gDriverExtension->LastAddress;

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gDriverExtension@@3PAUSLIX_DRIVER_EXTENSION@@A ; gDriverExtension
  0000c	8a 81 00 15 00
	00		 mov	 al, BYTE PTR [ecx+5376]

; 624  : 	if(SLOT_FROM_ADDRESS(Address) > 0x7) Address = 0;

  00012	8a d0		 mov	 dl, al
  00014	80 e2 70	 and	 dl, 112			; 00000070H
  00017	80 fa 70	 cmp	 dl, 112			; 00000070H
  0001a	76 02		 jbe	 SHORT $L37146
  0001c	32 c0		 xor	 al, al
$L37146:

; 625  : 	de = &gDriverExtension->Nodes[PORT_FROM_ADDRESS(Address)][SLOT_FROM_ADDRESS(Address)];
; 626  : 	pud = de->Device;
; 627  : 
; 628  : 	if (pud == NULL) {
; 629  : 		//the device isn't connected
; 630  : 		return;
; 631  : 	}
; 632  : 
; 633  : 	ourendpoint = GetEndpoint(pud, Endpoint);//de->endpoint[Endpoint];
; 634  : 
; 635  : 	USB_BUILD_SET_ENDPOINT_STATE((&urb.GetSetEndpointState), 
; 636  : 		ourendpoint, USB_ENDPOINT_STATE_DATA_TOGGLE_SET);
; 637  : 	pud->SubmitRequest(&urb);

  0001e	0f b6 c0	 movzx	 eax, al
  00021	8b d0		 mov	 edx, eax
  00023	c1 ea 04	 shr	 edx, 4
  00026	83 e0 0f	 and	 eax, 15			; 0000000fH
  00029	83 e2 07	 and	 edx, 7
  0002c	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  0002f	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  00035	56		 push	 esi
  00036	8b 34 08	 mov	 esi, DWORD PTR [eax+ecx]
  00039	85 f6		 test	 esi, esi
  0003b	74 2a		 je	 SHORT $L37358
  0003d	ff 75 08	 push	 DWORD PTR _Endpoint$[ebp]
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?GetEndpoint@@YGPAXPAVIUsbDevice@@E@Z ; GetEndpoint
  00046	83 65 d8 00	 and	 DWORD PTR _urb$[ebp+8], 0
  0004a	89 45 e0	 mov	 DWORD PTR _urb$[ebp+16], eax
  0004d	8d 45 d0	 lea	 eax, DWORD PTR _urb$[ebp]
  00050	50		 push	 eax
  00051	8b ce		 mov	 ecx, esi
  00053	c6 45 d0 18	 mov	 BYTE PTR _urb$[ebp], 24	; 00000018H
  00057	c6 45 d1 05	 mov	 BYTE PTR _urb$[ebp+1], 5
  0005b	c7 45 e4 08 00
	00 00		 mov	 DWORD PTR _urb$[ebp+20], 8
  00062	e8 00 00 00 00	 call	 ?SubmitRequest@IUsbDevice@@QAEJPAT_URB@@@Z ; IUsbDevice::SubmitRequest

; 638  : 	CloseEndpoint(pud, Endpoint, ourendpoint);

$L37358:
  00067	5e		 pop	 esi

; 639  : }

  00068	c9		 leave
  00069	c2 04 00	 ret	 4
_SlixdData1@4 ENDP
XPPCODE	ENDS
PUBLIC	_SlixdReset@0
EXTRN	__imp_@KfLowerIrql@4:NEAR
EXTRN	__imp__KeRaiseIrqlToDpcLevel@0:NEAR
EXTRN	?DeviceNotResponding@IUsbDevice@@QAEXXZ:NEAR	; IUsbDevice::DeviceNotResponding
; Function compile flags: /Ogs
;	COMDAT _SlixdReset@0
XPPCODE	SEGMENT
_SlixdReset@0 PROC NEAR					; COMDAT

; 649  : 	DEVICE_EXTENSION * de;
; 650  : 	IUsbDevice * pud;
; 651  : 	BYTE Address;
; 652  : 	KIRQL kirql;
; 653  : 
; 654  : 	Address = gDriverExtension->LastAddress;

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gDriverExtension@@3PAUSLIX_DRIVER_EXTENSION@@A ; gDriverExtension
  00006	8a 81 00 15 00
	00		 mov	 al, BYTE PTR [ecx+5376]

; 655  : 	if(SLOT_FROM_ADDRESS(Address) > 0x7) Address = 0;

  0000c	8a d0		 mov	 dl, al
  0000e	80 e2 70	 and	 dl, 112			; 00000070H
  00011	80 fa 70	 cmp	 dl, 112			; 00000070H
  00014	76 02		 jbe	 SHORT $L37155
  00016	32 c0		 xor	 al, al
$L37155:

; 666  : 	
; 667  : 	return USBD_STATUS_SUCCESS;

  00018	0f b6 c0	 movzx	 eax, al
  0001b	8b d0		 mov	 edx, eax
  0001d	c1 ea 04	 shr	 edx, 4
  00020	83 e0 0f	 and	 eax, 15			; 0000000fH
  00023	83 e2 07	 and	 edx, 7
  00026	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  00029	69 c0 a8 00 00
	00		 imul	 eax, 168		; 000000a8H
  0002f	56		 push	 esi
  00030	8b 34 08	 mov	 esi, DWORD PTR [eax+ecx]
  00033	85 f6		 test	 esi, esi
  00035	75 07		 jne	 SHORT $L37156

; 656  : 	de = &gDriverExtension->Nodes[PORT_FROM_ADDRESS(Address)][SLOT_FROM_ADDRESS(Address)];
; 657  : 	pud = de->Device;
; 658  : 
; 659  : 	if (pud == NULL) { //device isn't connected
; 660  : 		return USBD_STATUS_ERROR;

  00037	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0003c	5e		 pop	 esi

; 668  : }

  0003d	c3		 ret	 0
$L37156:
  0003e	53		 push	 ebx

; 661  : 	}
; 662  : 
; 663  :     kirql = KeRaiseIrqlToDpcLevel();

  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeRaiseIrqlToDpcLevel@0

; 664  : 		pud->DeviceNotResponding();

  00045	8b ce		 mov	 ecx, esi
  00047	8a d8		 mov	 bl, al
  00049	e8 00 00 00 00	 call	 ?DeviceNotResponding@IUsbDevice@@QAEXXZ ; IUsbDevice::DeviceNotResponding

; 665  :     KeLowerIrql(kirql);

  0004e	8a cb		 mov	 cl, bl
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfLowerIrql@4
  00056	5b		 pop	 ebx

; 666  : 	
; 667  : 	return USBD_STATUS_SUCCESS;

  00057	33 c0		 xor	 eax, eax
  00059	5e		 pop	 esi

; 668  : }

  0005a	c3		 ret	 0
_SlixdReset@0 ENDP
XPPCODE	ENDS
END
