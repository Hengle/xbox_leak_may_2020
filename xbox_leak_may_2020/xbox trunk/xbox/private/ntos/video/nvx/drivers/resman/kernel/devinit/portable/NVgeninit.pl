#!/usr//bin/perl
eval "exec /usr/bin/perl -S $0 $*"
    if $running_under_some_shell;

require 'getopts.pl';
&Getopts("vh");		# help, verbose,

if ($opt_h) {
    print STDERR <<NO_MORE_HELP;
NVgeninit

   Convert asm src (eg: nvinit.inc) init table into a C array
   for inclusion into devinit type code.

   Writes output to 'file'.fixed.

Usage: $0       [-v] files-to-parse

    -v          -- possibly more verbose
    -h          -- help

    anything else == this help message
NO_MORE_HELP
    exit 0;
}

$verbose = $opt_v;

# the easy patterns; rest are special cased

$patterns{";"} = "//";		# comments
$patterns{"\\bdb\\b"} = "";		# get rid of these guys
$patterns{"\\bdd\\b"} = "";
$patterns{"\\bdw\\b"} = "";
$patterns{"\\bIFDEF\\b"}  = "#ifdef";	# convert to C form
$patterns{"\\bIFNDEF\\b"} = "#ifndef";
$patterns{"\\bELSE\\b"}   = "#else";
$patterns{"\\bENDIF\\b"}  = "#endif";
$patterns{"\\bOR\\b"} =     "|";

$now_string = localtime;

# walk thru each line in each file; really expect just one
foreach $file (@ARGV)
{
    open (INFILE, "<$file") ||
        die "could not open input file $file: $!";

    $outfile = $file . ".h";;
    open (OUTFILE, ">$outfile") ||
        die "could not open output file $outfile: $!";

    # write out prologue to outfile
    print OUTFILE <<__PROLOGUE;
//
// This file is automatically generated; DO NOT EDIT.
//
// Built $now_string; from $file
//

{

__PROLOGUE

 INPUT:
    while (<INFILE>)
    {
        # do all the simple replacements
        study;                  # maybe make s/// faster
        foreach $key (keys %patterns)
        {
            s/$key/$patterns{$key}/ge;
        }

        #
        # now the trickier ones.
        #

        # rip off "comment"; will put it back later
        # comment also means trailing white space on lines w/ no comment
        # suck up as much whitespace as possible before // into $comment
        $comment = "";
        if ( /(.*?) (\s* \/\/ .*)/x )		# line end w/ comment?
        {
            $comment = $2;
            $_ = $1;
        } elsif ( /(.*?) (\s+$)/x )		# line end w/ whitespace?
        {
            $comment = $2;
            $_ = $1;
            chop $comment;
        }
        else { chop; }			# no comment, just toss the newline

        #
        # Lines to delete from output all 'public's and ':' label lines
        #
        next if (/^public\s+ (\w+)/x);
        next if (/^\w+:$/);

        # put in commas
        # if non-empty line does not end w/ backslash and
        # it does not begin w/ preprocessor directive, then
        # slap on a comma
        if (/\S/	# non-empty and not all white?
            && ! /^#/   # not preprocessor
            && ! /\\$/  # not continued
           )
        {
            $_ .= ",";
        }

        # fixup 123h to 0x123
        s/([0-9a-fA-F]+)h\b/0x$1/g;

        # replace comment back
        $_ .= $comment . "\n";

        print OUTFILE $_;

        #
        # Watch for end of table as uncommented INIT_DONE
        #
        if (/\bINIT_DONE\b/)
        {
            print OUTFILE "};";
            last INPUT;
        }
    }

    close INFILE;
    close OUTFILE;
}
