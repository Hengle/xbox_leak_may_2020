Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 1 - 1


				;++
				;
				;  Copyright (c) Microsoft Corporation. All rights reserved
				;
				;  Module Name:
				;
				;    inittbl.asm
				;
				;  Abstract:
				;
				;    This module contains table of commands used by South Bridge to initialize
				;    hardware and test memory during boot startup.  For definition of each
				;    command, please see initcode.inc and command.inc
				;
				;--
				        INCLUDE chipset.inc
			      C ;++
			      C ;
			      C ; Copyright (c) Microsoft Corporation
			      C ;
			      C ; Module Name:
			      C ;
			      C ;    chipset.inc
			      C ;
			      C ; Abstract:
			      C ;
			      C ;    This file contains defines that control which chipset romdec and
			      C ;    init table are built for
			      C ;
			      C ;--
			      C 
			      C IFNDEF RETAILXM3
			      C ;
			      C ; We want MCP_XMODE2 unless retail XM3 is being built
			      C ;
 = 0001			      C MCP_XMODE2 = 1
			      C 
			      C ENDIF
			      C 
			      C ;
			      C ; Define the following, when building for MCP Rev B01 in XMODE3
			      C ; Otherwise, this should undefined
			      C ;
			      C ;MCP_REV_B01 = 1
			      C 
			      C 
			      C IFDEF SYS_QT
			      C ENDIF
			      C 
			      C ;
			      C ; If we are building retail, set the local retail define
			      C ;
			      C IFDEF RETAILXM3
			      C ENDIF
			      C 
			      C 

				;
				; To build the init table for old A02 (without M7, fansink) DVT3s, DVT2s and 
				; DVT1, define INITTABLE_OLDA02.  To build the init table for fullspeed systems, 
				; this should undefined.  We are currently building two init tables:
				;
				;
				;   Init Table            Ver    Defines
				;   --------------------- ------ ----------------------------------------------------------
				;   DVT4/5                0x46   SYS_DVT4  
				;
				;   DVT6                  0x60   SYS_DVT6 (SYS_DVT4 undefined)
				;
				;   QT                    0x70   SYS_QT (automatically defines SYS_DVT6)
				;

				        INCLUDE nv2ainit.inc
			      C ;++
			      C ;
			      C ;  Copyright (c) Microsoft Corporation. All rights reserved
			      C ;
			      C ;  Module Name:
			      C ;
			      C ;    nv2ainit.inc
			      C ;
			      C ;  Abstract:
			      C ;
			      C ;    NV2A initialization table
			      C ;
			      C ;    This module contains table of commands used by South Bridge to initialize
			      C ;    hardware and test memory during boot startup.  For definition of each
			      C ;    command, please see initcode.inc and command.inc
			      C ;--
			      C 
			      C page    84,132
			      C .MODEL compact
			      C .486p
			      C 
			      C INCLUDE COMMAND.INC
			      C IFDEF MCP_XMODE2
			      C 
			      C ;
			      C ; Opcodes for devkits (XMODE2)
			      C 
 = 00E7			      C COMMAND_RESERVED             EQU 0E7h
 = 009A			      C COMMAND_READ_MEM             EQU 09Ah
 = 005B			      C COMMAND_WRITE_MEM            EQU 05Bh
 = 00F9			      C COMMAND_PCI_CFG_WRITE        EQU 0F9h
 = 00F5			      C COMMAND_PCI_CFG_READ         EQU 0F5h
 = 00ED			      C COMMAND_RMW_RESULT           EQU 0EDh
 = 0068			      C COMMAND_USE_RESULT_AS_DATA   EQU 068h
 = 0004			      C COMMAND_COMPARE_RESULT_JNE   EQU 004h
 = 0025			      C COMMAND_JMP                  EQU 025h
 = 006C			      C COMMAND_RMW_ACCUM            EQU 06Ch
 = 003C			      C COMMAND_OUT_BYTE             EQU 03Ch
 = 00C8			      C COMMAND_IN_BYTE              EQU 0C8h
 = 00BF			      C COMMAND_QUIT                 EQU 0BFh
			      C 
			      C ELSE
			      C ENDIF
			      C 
			      C 
 = 0000			      C DONT_CARE                    EQU 0
			      C 
 0009			      C nv_command_struct struct
 0000  00		      C         nv_command db 0
 0001  00000000		      C         nv_address dd 0
 0005  00000000		      C         nv_data    dd 0
			      C nv_command_struct ends
			      C 
			      C 
			      C 
			      C INCLUDE NV2A.INC
			      C ;
			      C ; NV2A ROM table ptr (NV20 Register Base/Limit (BAR0)
			      C ;
 = FF000008		      C NV2A_XBOX_ROM_TABLE_PTR          EQU 0FF000008h
			      C 
			      C ;
			      C ; Datatbl starts at this offset
			      C ;
			      C ; IMPORTANT: This must be adjusted if the size of the init table
			      C ; code has changed
			      C ;
			      C IFDEF SYS_RETAIL
			      C ELSE
 = 0BF0			      C DATATBL_BASE_OFFSET              EQU 0BF0h
			      C ENDIF
			      C 
			      C ;
			      C ; Integrated NV20 Register Base (BAR0)
			      C ;
 = 0F000000		      C NV20_REG_BASE                    EQU 00F000000h    ; only during the init tbl
 = FD000000		      C NV20_REG_BASE_KERNEL             EQU 0FD000000h    ; reloaded to agree with kernel code
 = F0000000		      C NV20_FB_BASE                     EQU 0F0000000h
 = 40000000		      C APERTURE_BASE                    EQU 040000000h
			      C 
 = C000			      C SMB_CONTROL_BASE                 EQU 00000C000h
 = C200			      C SMB_DDC_SPIO_BASE                EQU 00000C200h
			      C 
			      C ;
			      C ; NV2A config equates
			      C ;
 = 80000084		      C CR_CPU_MEMTOP                    EQU 080000084h
 = 03FFFFFF		      C CR_CPU_MEMTOP_LIMIT_64MB         EQU 003FFFFFFh
 = 07FFFFFF		      C CR_CPU_MEMTOP_LIMIT_128MB        EQU 007FFFFFFh
			      C 
 = 80000340		      C CR_CPU_CST_0                     EQU 080000340h
 = 80000344		      C CR_CPU_CST_1                     EQU 080000344h
 = 8000035C		      C CR_CPU_CST_7                     EQU 08000035Ch
			      C 
 = 8000036C		      C CR_CPU_MPLL_COEFF                EQU 08000036Ch
			      C 
 = 8000F004		      C CR_APC_P2P_1                     EQU 08000F004h
 = 0007			      C CR_APC_P2P_1_BUS_MSTR_MEM_IO     EQU 000000007h    ; should be RMW, still ok?
			      C 
 = 8000F018		      C CR_APC_P2P_6                     EQU 08000F018h
 = 00010100		      C CR_APC_P2P_6_SUB_SEC_PRI_BUS     EQU 000010100h    ; change CR_NV20, if bus changes
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 2 - 1


			      C 
 = 8000F020		      C CR_APC_P2P_8                     EQU 08000F020h
 = 0FF00F00		      C CR_APC_P2P_8_MLIMIT_MBASE_INIT   EQU (NV20_REG_BASE + 0F00000h) OR (NV20_REG_BASE SHR 16)
 = FDF0FD00		      C CR_APC_P2P_8_MLIMIT_MBASE_KERNEL EQU (NV20_REG_BASE_KERNEL + 0F00000h) OR (NV20_REG_BASE_KERNEL SHR 
			      C 16)
 = 8000F024		      C CR_APC_P2P_9                     EQU 08000F024h
 = F7F0F000		      C CR_APC_P2P_9_PREF_MLIMIT_MBASE   EQU (NV20_FB_BASE +  7F00000h) OR (NV20_FB_BASE SHR 16)
			      C 
 = 8000F04C		      C CR_APC_P2P_19                    EQU 08000F04Ch
 = 0001			      C CR_APC_P2P_19_NV20_ENABLE        EQU 000000001h    ; enables internal graphics
			      C 
			      C ;
			      C ; MCP config equates
			      C ;
 = 80000804		      C MCP_LEG_CFG_1                    EQU 080000804h    ; enable IO space
 = 80000808		      C MCP_LEG_CFG_2                    EQU 080000808h    ; holds MCP revision ID
			      C 
			      C IFDEF MCP_REV_C03
			      C ELSE
 = 80000810		      C MCP_LEG_CFG_4                    EQU 080000810h    ; IO BAR for revs < C03
			      C ENDIF
			      C 
 = 8000084C		      C MCP_LEG_CFG_19                   EQU 08000084Ch
 = 80000860		      C MCP_LEG_CFG_24                   EQU 080000860h
 = 8000089C		      C MCP_LEG_CFG_39                   EQU 08000089Ch
 = 800008B4		      C MCP_LEG_CFG_45                   EQU 0800008B4h
			      C 
 = 80000904		      C MCP_SMB_CFG_1                    EQU 080000904h
 = 0001			      C MCP_SMB_CFG_1_IO_SPACE           EQU 000000001h    ; should be RMW, still ok?
			      C 
 = 80000914		      C MCP_SMB_CFG_5                    EQU 080000914h
 = C001			      C MCP_SMB_CFG_5_IO_BASE            EQU SMB_CONTROL_BASE + 1
			      C 
 = 80000918		      C MCP_SMB_CFG_6                    EQU 080000918h
 = C201			      C MCP_SMB_CFG_6_IO_BASE            EQU SMB_DDC_SPIO_BASE + 1
			      C 
 = 8000103C		      C MCP_USBA_CFG_15                  EQU 08000103Ch    ; scratch pad for meminit
 = 8000183C		      C MCP_USBB_CFG_15                  EQU 08000183Ch    ; scratch pad for meminit
			      C 
			      C ;
			      C ; MCP registers used as scratchpad for memory test
			      C ;
 = 8000103C		      C MEMTEST_TYPE                     EQU 08000103Ch    ; MCP_USBA_CFG_15 
 = 8000183C		      C MEMTEST_RESULT                   EQU 08000183Ch    ; MCP_USBB_CFG_15 
			      C 
			      C ;
			      C ; Memory test patterns
			      C ;
 = AAAAAAAA		      C MEMTEST_PATTERN1                 EQU 0AAAAAAAAh
 = 5A5A5A5A		      C MEMTEST_PATTERN2                 EQU 05A5A5A5Ah
 = 55555555		      C MEMTEST_PATTERN3                 EQU 055555555h
 = CCCCCCCC		      C MEMTEST_PATTERN4                 EQU 0CCCCCCCCh
			      C 
			      C 
			      C ; Internal NV20 config equates (assumes bus 1)
			      C ;
 = 80010004		      C CR_NV20_PCI_1                    EQU 080010004h
 = 0007			      C CR_NV20_PCI_1_BUS_MSTR_MEM_IO    EQU 000000007h    ; should be RMW, still ok?
			      C 
 = 80010010		      C CR_NV20_PCI_4                    EQU 080010010h
 = 80010014		      C CR_NV20_PCI_5                    EQU 080010014h
			      C 
			      C ;
			      C ; NV20 register offsets and init values (from nv2a\manuals\rom_table.txt)
			      C ;
 = 10B0			      C NV_PBUS_DEBUG_CTRIM_0            EQU 0000010B0h
 = 10B4			      C NV_PBUS_DEBUG_CTRIM_1            EQU 0000010B4h
 = 10B8			      C NV_PBUS_DEBUG_CTRIM_2            EQU 0000010B8h
 = 10BC			      C NV_PBUS_DEBUG_CTRIM_3            EQU 0000010BCh
 = 10C4			      C NV_PBUS_DEBUG_CTRIM_4            EQU 0000010C4h
 = 10C8			      C NV_PBUS_DEBUG_CTRIM_5            EQU 0000010C8h
 = 10CC			      C NV_PBUS_DEBUG_CTRIM_6            EQU 0000010CCh
 = 10D4			      C NV_PBUS_DEBUG_CTRIM_7            EQU 0000010D4h
 = 10D8			      C NV_PBUS_DEBUG_CTRIM_8            EQU 0000010D8h
 = 10DC			      C NV_PBUS_DEBUG_CTRIM_9            EQU 0000010DCh
 = 10E8			      C NV_PBUS_DEBUG_CTRIM_10           EQU 0000010E8h
			      C 
 = 1210			      C NV_PBUS_FBIO_CFG                 EQU 000001210h
			      C 
 = 1220			      C NV_PBUS_FBIO_CALEN               EQU 000001220h
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 3 - 1


 = 0000			      C NV_PBUS_FBIO_CALEN_OFF           EQU 000000000h
			      C 
 = 1228			      C NV_PBUS_FBIO_CALSEL              EQU 000001228h
 = 0000			      C NV_PBUS_FBIO_CALSEL_VALUE        EQU 000000000h
			      C 
 = 1214			      C NV_PBUS_FBIO_DLY                 EQU 000001214h
			      C 
 = 122C			      C NV_PBUS_FBIO_ADRDRV              EQU 00000122Ch
 = 1230			      C NV_PBUS_FBIO_CLKDRV              EQU 000001230h
 = 1234			      C NV_PBUS_FBIO_DATDRV              EQU 000001234h
 = AAAAAAAA		      C NV_PBUS_FBIO_DATDRV_INIT         EQU 0AAAAAAAAh
 = 1238			      C NV_PBUS_FBIO_DQSDRV              EQU 000001238h
 = AAAAAAAA		      C NV_PBUS_FBIO_DQSDRV_INIT         EQU 0AAAAAAAAh
 = 123C			      C NV_PBUS_FBIO_ADRSLW              EQU 00000123Ch
 = 8B8B8B8B		      C NV_PBUS_FBIO_ADRSLW_INIT         EQU 08B8B8B8Bh
 = 1240			      C NV_PBUS_FBIO_CLKSLW              EQU 000001240h
 = 1244			      C NV_PBUS_FBIO_DATSLW              EQU 000001244h
 = 8B8B8B8B		      C NV_PBUS_FBIO_DATSLW_INIT         EQU 08B8B8B8Bh
 = 1248			      C NV_PBUS_FBIO_DQSSLW              EQU 000001248h
 = 8B8B8B8B		      C NV_PBUS_FBIO_DQSSLW_INIT         EQU 08B8B8B8Bh
 = 124C			      C NV_PBUS_DISPIO_PADCTL            EQU 00000124Ch
 = AA8BAA8B		      C NV_PBUS_DISPIO_PADCTL_INIT       EQU 0AA8BAA8Bh
 = 1250			      C NV_PBUS_TVDIO_PADCTL             EQU 000001250h
 = AA8B			      C NV_PBUS_TVDIO_PADCTL_INIT        EQU 00000AA8Bh
			      C 
 = 1264			      C NV_PBUS_TVDIO_CALEN              EQU 000001264h
 = 0000			      C NV_PBUS_TVDIO_CALEN_OFF          EQU 000000000h
			      C 
 = 00101000		      C NV_PEXTDEV_BOOT_0                EQU 000101000h
			      C 
 = 001002D0		      C NV_PFB_REF                       EQU 0001002D0h
 = 001002D4		      C NV_PFB_PRE                       EQU 0001002D4h
 = 0001			      C NV_PFB_PRE_CMD_PRECHARGE_1       EQU 000000001h
 = 001002C4		      C NV_PFB_EMRS                      EQU 0001002C4h
 = 001002CC		      C NV_PFB_EMRS_EXT                  EQU 0001002CCh
 = 001002C0		      C NV_PFB_MRS                       EQU 0001002C0h
 = 0132			      C NV_PFB_MRS_DLL_RESET             EQU 000000132h
 = 001002C8		      C NV_PFB_MRS_EXT                   EQU 0001002C8h
 = 0132			      C NV_PFB_MRS_EXT_DLL_RESET         EQU 000000132h
 = 00100210		      C NV_PFB_REFCTRL                   EQU 000100210h
 = 80000000		      C NV_PFB_REFCTRL_VALID_1           EQU 080000000h
 = 00100410		      C NV_PFB_WBC                       EQU 000100410h
 = 00100420		      C NV_PFB_CPU_RRQ                   EQU 000100420h
 = 0401			      C NV_PFB_CPU_RRQ_FWP_LAT_ENABLE    EQU 000000401h
 = 00100424		      C NV_PFB_BYPASS                    EQU 000100424h
 = F1780031		      C NV_PFB_BYPASS_VALUE              EQU 0F1780031h
			      C 
 = 0000			      C NV_PMC_BOOT_0                    EQU 000000000h
			      C 
 = 0068050C		      C NV_PRAMDAC_PLL_COEFF_SELECT      EQU 00068050Ch
 = 00100200		      C NV_PFB_CFG0                      EQU 000100200h
 = 00100204		      C NV_PFB_CFG1                      EQU 000100204h
			      C 
 = 00100228		      C NV_PFB_TIMING2                   EQU 000100228h
			      C 
 = 00100330		      C NV_PFB_ARB_XFER_SZ               EQU 000100330h
 = 0010032C		      C NV_PFB_ARB_TIMEOUT               EQU 00010032Ch
 = 00100328		      C NV_PFB_ARB_PREDIVIDER            EQU 000100328h
 = 00100338		      C NV_PFB_ARB_DIFF_BANK             EQU 000100338h
			      C 
 = 1218			      C NV_PBUS_FBIO_RAM                 EQU 000001218h
			      C 
 = 00680500		      C NV_PRAMDAC_NVPLL_COEFF           EQU 000680500h
			      C 
 = 00400880		      C NV_PGRAPH_DEBUG_2                EQU 000400880h
 = 002EC3FF		      C NV_PGRAPH_DEBUG_2_VALUE          EQU 0002EC3FFh
 = 00400B88		      C NV_PGRAPH_DEBUG_10               EQU 000400b88h
 = 0003			      C NV_PGRAPH_DEBUG_10_ROP_BLEND     EQU 000000003h
			      C 
			      C ;
			      C ; Equates used for the memory detect/test
			      C ;
 = 0000			      C MEM_PART_0                       EQU 000000000h
 = 0010			      C MEM_PART_1                       EQU 000000010h
 = 0020			      C MEM_PART_2                       EQU 000000020h
 = 0030			      C MEM_PART_3                       EQU 000000030h
 = 04000000		      C MEM_PART_4                       EQU 004000000h
 = 04000010		      C MEM_PART_5                       EQU 004000010h
 = 04000020		      C MEM_PART_6                       EQU 004000020h
 = 04000030		      C MEM_PART_7                       EQU 004000030h
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 4 - 1


			      C 
			      C 
			      C ;
			      C ; First byte of the desired SMC revision
			      C ;
 = 0050			      C DESIRED_SMC_VER                  EQU 050h
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
 0000			      C CODE SEGMENT PARA PUBLIC 'code'
			      C   assume  ds:code,es:nothing,ss:nothing
			      C org 0000h
			      C 
			      C ;
			      C ; NB data for NV2A on the DVT boards
			      C ;
			      C 
			      C ;
			      C ; Not currently documented, NV2A expects table ptrs to exist in the first
			      C ; 2 DWORDS of the ROM image, which point to the beginning of the ROM table.
			      C ; The MCPX still expects to find it's init values starting at 0x70.
			      C ;
 0000  FF000009		      C dd NV2A_XBOX_ROM_TABLE_PTR + 1        ; LSB needs to be 1 to appear valid
 0004  FF000008		      C dd NV2A_XBOX_ROM_TABLE_PTR
			      C 
			      C ; CR_ROM_NB_BOOT_HEADER                    (0*32+31):(0*32+0) /* R--VF */
			      C ;
 0008  2B16D065		      C dd 2B16D065h
			      C 
			      C ; CR_ROM_NB_BOOT_PROC                       (1*32+0):(1*32+0) /* R--VF */
			      C ; CR_ROM_NB_BOOT_PROC_INTEL                        0x00000001 /* R---V */
			      C ; CR_ROM_NB_BOOT_RAMTYPE                    (1*32+2):(1*32+2) /* R--VF */
			      C ; CR_ROM_NB_BOOT_RAMTYPE_DDR                       0x00000001 /* R---V */
			      C ; CR_ROM_NB_BOOT_RAMWIDTH                   (1*32+3):(1*32+3) /* R--VF */
			      C ; CR_ROM_NB_BOOT_RAMWIDTH_128                      0x00000001 /* R---V */
			      C ; CR_ROM_NB_BOOT_MEM_POSTDIV                (1*32+7):(1*32+4) /* R--VF */
			      C ; CR_ROM_NB_BOOT_AGP_POSTDIV               (1*32+11):(1*32+8) /* R--VF */
			      C ; CR_ROM_NB_BOOT_FSB_ROM                  (1*32+15):(1*32+12) /* R--VF */
			      C ; CR_ROM_NB_BOOT_FSB_66                   (1*32+19):(1*32+16) /* R--VF */
			      C ; CR_ROM_NB_BOOT_FSB_100                  (1*32+23):(1*32+20) /* R--VF */
			      C ; CR_ROM_NB_BOOT_FSB_TUALATIN             (1*32+27):(1*32+24) /* R--VF */
			      C ; CR_ROM_NB_BOOT_FSB_133                  (1*32+31):(1*32+28) /* R--VF */
			      C ;
			      C ; dd 4444444dh    ; (100MHz FSB hardcoded)
			      C ; dd 3346323Dh      ; (AGP_PDIV = 2, MEM_PDIV = 3), start at 133MHz
 000C  3346322D		      C dd 3346322Dh    ; (AGP_PDIV = 2, MEM_PDIV = 2)
			      C 
			      C ;    These COREPLL values are based on using a 13.5MHz xtal.
			      C ;
			      C ;    NOTE: If you change the MDIV, NDIV, FSB POSTDIV or MEM_POSTDIV you'll
			      C ;    need to sync the change with the  CR_CPU_MPLL_COEFF write in the inittbl
			      C ;    below.
			      C ;
			      C ; CR_ROM_NB_BOOT_COREPLL_MDIV_66            (2*32+7):(2*32+0) /* R--VF */
			      C ; CR_ROM_NB_BOOT_COREPLL_MDIV_66_VALUE             0x00000007 /* R---V */ 
			      C ; CR_ROM_NB_BOOT_COREPLL_MDIV_100          (2*32+15):(2*32+8) /* R--VF */
			      C ; CR_ROM_NB_BOOT_COREPLL_MDIV_100_VALUE            0x00000007 /* R---V */ 
			      C ; CR_ROM_NB_BOOT_COREPLL_MDIV_TUALATIN    (2*32+23):(2*32+16) /* R--VF */
			      C ; CR_ROM_NB_BOOT_COREPLL_MDIV_TUALATIN_VALUE       0x00000007 /* R---V */ 
			      C ; CR_ROM_NB_BOOT_COREPLL_MDIV_133         (2*32+31):(2*32+24) /* R--VF */
			      C ; CR_ROM_NB_BOOT_COREPLL_MDIV_133_VALUE            0x00000007 /* R---V */ 
			      C ;
			      C ; dd 07070707h
			      C ; dd 01010101h
 0010  01010101		      C dd 01010101h
			      C 
			      C ; CR_ROM_NB_BOOT_COREPLL_NDIV_66            (3*32+7):(3*32+0) /* R--VF */
			      C ; CR_ROM_NB_BOOT_COREPLL_NDIV_66_VALUE             0x00000022 /* R---V */
			      C ; CR_ROM_NB_BOOT_COREPLL_NDIV_100          (3*32+15):(3*32+8) /* R--VF */
			      C ; CR_ROM_NB_BOOT_COREPLL_NDIV_100_VALUE            0x00000034 /* R---V */
			      C ; CR_ROM_NB_BOOT_COREPLL_NDIV_TUALATIN    (3*32+23):(3*32+16) /* R--VF */
			      C ; CR_ROM_NB_BOOT_COREPLL_NDIV_TUALATIN_VALUE       0x00000045 /* R---V */
			      C ; CR_ROM_NB_BOOT_COREPLL_NDIV_133         (3*32+31):(3*32+24) /* R--VF */
			      C ; CR_ROM_NB_BOOT_COREPLL_NDIV_133_VALUE            0x00000045 /* R---V */
			      C ;
			      C ; dd 45453422h
			      C ; dd 07070707h        ; (100MHz FSB)
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 5 - 1


			      C ; dd 08080808h        ; (106MHz FSB)
			      C ; dd 0A0A0A0Ah        ; (135MHz FSB)
			      C ; dd 09090909h        ; (133MHz FSB)
 0014  08080808		      C dd 08080808h          ; (133MHz FSB 16.66MHz input clock)
			      C 
			      C ; CR_ROM_NB_BOOT_COREPLL_MDIV_ROM           (4*32+7):(4*32+0) /* R--VF */
			      C ; CR_ROM_NB_BOOT_COREPLL_MDIV_ROM_VALUE            0x00000007 /* R---V */
			      C ; CR_ROM_NB_BOOT_COREPLL_NDIV_ROM          (4*32+15):(4*32+8) /* R--VF */
			      C ; CR_ROM_NB_BOOT_COREPLL_NDIV_ROM_VALUE            0x00000045 /* R---V */
			      C ; CR_ROM_NB_BOOT_ASRC_CPU                 (4*32+23):(4*32+16) /* R--VF */
			      C ; CR_ROM_NB_BOOT_ASRC_LDT                 (4*32+31):(4*32+24) /* R--VF */
			      C ;
			      C ; dd 4507h
			      C ; dd 0801h          ; (106MHz FSB)
			      C ; dd 0701h          ; (100MHz FSB)
			      C ; dd 0A01h          ; (135MHz FSB)
			      C ; dd 1D03h          ; (133MHz FSB)
 0018  00000801		      C dd 0801h            ; (133MHz FSB w/ 16.66MHz input clock)
			      C 
			      C ; CR_ROM_NB_BOOT_SADDOUTCLK_DLY             (5*32+3):(5*32+0) /* R--VF */
			      C ; CR_ROM_NB_BOOT_SDATAOUTCLK_DLY            (5*32+7):(5*32+4) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CPU_VREF_EN_               (5*32+8):(5*32+8) /* R--VF */
			      C ; CR_ROM_NB_BOOT_APIC_33                    (5*32+9):(5*32+9) /* R--VF */
			      C ; CR_ROM_NB_BOOT_COREPLL_SETUP            (5*32+18):(5*32+10) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CPUPLL_SETUP             (5*32+27):(5*32+19) /* R--VF */
			      C ; CR_ROM_NB_BOOT_COREPLL_DLY              (5*32+31):(5*32+28) /* R--VF */
			      C ;
 001C  C8FC7C8A		      C dd 0C8FC7C8Ah
			      C 
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUCLKFB             (6*32+3):(6*32+0) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUCLKFB_VALUE              0x00000003 /* R---V */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUCLK2X_BL          (6*32+7):(6*32+4) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUCLK2X_BL_VALUE           0x00000001 /* R---V */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUCLK2X_BR         (6*32+11):(6*32+8) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUCLK2X_BR_VALUE           0x00000002 /* R---V */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUCLK_NW          (6*32+15):(6*32+12) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUCLK_NW_VALUE_DONTCARE    0x00000000 /* R---V */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUCLK_SW          (6*32+19):(6*32+16) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUCLK_SW_VALUE             0x00000009 /* R---V */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUCLK_SE          (6*32+23):(6*32+20) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUCLK_SE_VALUE             0x00000002 /* R---V */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUOCLK_BL         (6*32+27):(6*32+24) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUOCLK_BL_VALUE            0x00000002 /* R---V */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUOCLK_BR         (6*32+31):(6*32+28) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUOCLK_BR_VALUE            0x00000002 /* R---V */
			      C ;
 0020  44290213		      C dd 44290213h        ; A03
			      C 
			      C 
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUCLKOUT            (7*32+3):(7*32+0) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUCLKOUT_VALUE             0x00000008 /* R---V */
			      C ; CR_ROM_NB_BOOT_CTRIM_APICCLK_MCP          (7*32+7):(7*32+4) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_APICCLK_MCP_VALUE           0x00000009 /* R---V */
			      C ; CR_ROM_NB_BOOT_CTRIM_APICCLK_CPU         (7*32+11):(7*32+8) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_APICCLK_CPU_VALUE           0x00000009 /* R---V */
			      C ; CR_ROM_NB_BOOT_CTRIM_COREPLLFB          (7*32+15):(7*32+12) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_COREPLLFB_VALUE             0X00000004 /* R---V */
			      C ; CR_ROM_NB_BOOT_CTRIM_CPUPLLFB           (7*32+19):(7*32+16) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_SPARE1             (7*32+23):(7*32+20) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_SPARE1_VALUE_DONTCARE       0x00000000 /* R---V */
			      C ; CR_ROM_NB_BOOT_CTRIM_SPARE2             (7*32+27):(7*32+24) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CTRIM_SPARE2_VALUE_DONTCARE       0x00000000 /* R---V */
			      C ; CR_ROM_NB_BOOT_CTRIM_SPARE3             (7*32+31):(7*32+28) /* R--VF */
			      C ;
			      C IFDEF SYS_DVT6
			      C ELSE
 0024  00064998		      C dd 00064998h
			      C ENDIF
			      C 
			      C ; CR_ROM_NB_BOOT_CSHAPE_CPUCLKFB            (8*32+3):(8*32+0) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CSHAPE_CPUCLKFB_VALUE             0x00000000 /* R---V */
			      C ; CR_ROM_NB_BOOT_CSHAPE_CPUCLK2X            (8*32+7):(8*32+4) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CSHAPE_CPUCLK2X_VALUE             0x00000000 /* R---V */
			      C ; CR_ROM_NB_BOOT_CSHAPE_CPUCLK             (8*32+11):(8*32+8) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CSHAPE_CPUCLK_VALUE               0x00000000 /* R---V */
			      C ; CR_ROM_NB_BOOT_CSHAPE_CPUCLKOUT         (8*32+15):(8*32+12) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CSHAPE_CPUCLKOUT_VALUE            0x00000000 /* R---V */
			      C ; CR_ROM_NB_BOOT_CSHAPE_APICCLK_CPU       (8*32+19):(8*32+16) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CSHAPE_APICCLK_CPU_VALUE          0x00000000 /* R---V */
			      C ; CR_ROM_NB_BOOT_CSHAPE_APICCLK_MCP       (8*32+23):(8*32+20) /* R--VF */
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 6 - 1


			      C ; CR_ROM_NB_BOOT_CSHAPE_APICCLK_MCP_VALUE          0x00000000 /* R---V */
			      C ; CR_ROM_NB_BOOT_CSHAPE_SPARE1            (8*32+27):(8*32+24) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CSHAPE_SPARE1_VALUE_DONTCARE      0x00000000 /* R---V */
			      C ; CR_ROM_NB_BOOT_CSHAPE_SPARE2            (8*32+31):(8*32+28) /* R--VF */
			      C ; CR_ROM_NB_BOOT_CSHAPE_SPARE2_VALUE               0x00000000 /* R---V */
			      C ;
 0028  00000000		      C dd 000000000h
			      C 
			      C ; CR_ROM_NB_BOOT_INTEL_BPRI_                (9*32+0):(9*32+0) /* R--VF */    
			      C ; CR_ROM_NB_BOOT_INTEL_BNR_                 (9*32+1):(9*32+1) /* R--VF */    
			      C ; CR_ROM_NB_BOOT_INTEL_ADS_                 (9*32+2):(9*32+2) /* R--VF */    
			      C ; CR_ROM_NB_BOOT_INTEL_ADDR_               (9*32+31):(9*32+3) /* R--VF */    
			      C ;
 002C  FFFFFFFF		      C dd 0FFFFFFFFh
			      C 
			      C ; CR_ROM_NB_BOOT_INTEL_TRDY_              (10*32+0):(10*32+0) /* R--VF */
			      C ; CR_ROM_NB_BOOT_INTEL_RS_                (10*32+3):(10*32+1) /* R--VF */
			      C ; CR_ROM_NB_BOOT_INTEL_REQ_               (10*32+8):(10*32+4) /* R--VF */
			      C ; CR_ROM_NB_BOOT_INTEL_HITM_              (10*32+9):(10*32+9) /* R--VF */
			      C ; CR_ROM_NB_BOOT_INTEL_HIT_             (10*32+10):(10*32+10) /* R--VF */
			      C ; CR_ROM_NB_BOOT_INTEL_DRDY_            (10*32+11):(10*32+11) /* R--VF */
			      C ; CR_ROM_NB_BOOT_INTEL_DEFER_           (10*32+12):(10*32+12) /* R--VF */
			      C ; CR_ROM_NB_BOOT_INTEL_DBSY_            (10*32+13):(10*32+13) /* R--VF */
			      C ; CR_ROM_NB_BOOT_INTEL_AGTL_PLUS        (10*32+14):(10*32+14) /* R--VF */
			      C ; CR_ROM_NB_BOOT_INTEL_SPARE1           (10*32+31):(10*32+15) /* R--VF */
			      C ;
 0030  FFFFFFFF		      C dd 0FFFFFFFFh
			      C 
			      C ;
			      C ; 14 DWORDS used (11 for CR_ROM_BOOT, 2 table ptrs, 1 DWORD ROM rev)
			      C ;
 0034  000E [		      C dd (28-14) dup (0h)
        00000000
       ]
			      C 
			      C ; ROM/Trims Revision number
			      C ;
			      C ; To keep track of TRIM changes and other inittbl/datatbl changes, we'll
			      C ; use this DWORD as the revision ID. We'll also keep the history here, so
			      C ; clear what's been changed.
			      C ;
			      C ; rev1.00 - 
			      C ;    . set QUSE_NORMAL in NV_PBUS_FBIO_CFG
			      C ;    . set NB_BOOT_CPUPLL_SETUP[3:0] and NB_BOOT_COREPLL_SETUP[3:0] to 0xF
			      C ;    . set NB_BOOT_CTRIM_CPUPLLFB to 0x6
			      C ;    . set NV_PBUS_DEBUG_CTRIM_6 to 0x66660000 and
			      C ;          NV_PBUS_DEBUG_CTRIM_2 to 0x11110000, in that order
			      C ;    . clear most significant nibble from NV_PBUS_DEBUG_CTRIM_4
			      C ;    . add SYS_DVT3 ifdef for (DVT3) 13.5 vs. (DVT4) 16.6 input clocks,
			      C ;      with changes to:
			      C ;          NB_BOOT_COREPLL_NDIV and MDIV
			      C ;          NV_PRAMDAC_NVPLL_COEFF
			      C ;          CR_CPU_MPLL_COEFF
			      C ;    . add NV2A_REV_A03 ifdef for A03 related trims:
			      C ;          CTRIM_CPUOCLK_BL = 0x4
			      C ;          CTRIM_CPUOCLK_BR = 0x4
			      C ;          CR_CPU_CST_0     = 0xF0F0C0C0
			      C ;    . update 13.5 and 16.6 calibration speedometer settings
			      C ;          (previous VCC values were incorrect for both input clocks)
			      C ;
			      C ; rev1.01 - 
			      C ;    . set WBC from 0x11000001 (which is no buffering) to 0x11000016
			      C ;    . reset PFB_ARB_XFER_SZ_ZW from 0xF (unlimited burst) to 0x8
			      C ;          since NV2A doesn't need the zcull workaround like NV20.
			      C ;    . set DQS/DQ inbound delay to 0x1/0x0 in the Samsung calibration table
			      C ;    . set the MCLK drive/slew parameters to their max (helps clock jitter).
			      C ;
			      C ; rev1.02 -
			      C ;    . change NV_PBUS_FBIO_CFG (from 0x1 to 0x10) for 1/4 clock delay
			      C ;    . change NV_PBUS_DEBUG_CTRIM_2 (from 0x11110000 to 0x0)
			      C ;
			      C ; rev1.03 - 
			      C ;    . max MCP_LEG_CFG_45_PCICLKO5_TRIM to better line up the PCI clk
			      C ;           for the LPC card 
			      C ;    . DVT6 trims (tested with the Cypress zero delay buffer):
			      C ;           PBUS_DEBUG_CTRIM_2 = 0xFFFF0000
			      C ;           CR_ROM_NB_BOOT_CTRIM_CPUPLLFB = 0x0
			      C ;           CR_ROM_NB_BOOT_CTRIM_SPARE3   = 0x9
			      C ;           change calibration inbound delay values (DQS = 0, DATA = 1)
			      C ;
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 7 - 1


			      C ; rev1.04 - 
			      C ;    . Add support for MCP C03's different base address
			      C ;
			      C ; rev1.05 - 
			      C ;    . update Micron FBIO_DLY and ADDRESS_DRIVE settings during init and
			      C ;        in the calibration table.
			      C ;    . PBUS_DEBUG_CTRIM_2 is now different between Samsung/Micron.
			      C ;
			      C ; rev1.06 - 
			      C ;    . Changed pre-calibration defaults for Samsung memory.
			      C ;    . FBIO_DLY default was 012121212 is now 009090909
			      C ;    . CLKDRV/CLKSLW value is now 0FFFFFFFF
			      C ;
			      C 
			      C ;
 006C  00000106		      C dd 00000106h        ; bits 31:8 = major rev, 7:0 = minor rev
			      C 
			      C ;
			      C ; SB data for MCPX on the DVT boards (starts at offset 0x70)
			      C ;
			      C 
			      C ; MCP_ROM_BOOT_FREQ_STRAP                 (28*32+3):(28*32+0) /* R--VF */
			      C ; MCP_ROM_BOOT_FREQ_STRAP_SAFE                     0x0000000f /* R---V */
			      C ;
			      C ;dd 00000000h
 0070  0000000F		      C dd 0Fh
			      C 
			      C ; MCP_ROM_BOOT_PIC_DIS                    (29*32+0):(29*32+0) /* RWIVF */
			      C ; MCP_ROM_BOOT_PIT_DIS                    (29*32+1):(29*32+1) /* RW-VF */
			      C ; MCP_ROM_BOOT_DMA_DIS                    (29*32+2):(29*32+2) /* RW-VF */
			      C ; MCP_ROM_BOOT_P92_DIS                    (29*32+3):(29*32+3) /* RW-VF */
			      C ; MCP_ROM_BOOT_FERR_DIS                   (29*32+4):(29*32+4) /* RW-VF */
			      C ; MCP_ROM_BOOT_RTC_NMI_DIS                (29*32+5):(29*32+5) /* RW-VF */
			      C ; MCP_ROM_BOOT_USB0_DIS                   (29*32+8):(29*32+8) /* RW-VF */
			      C ; MCP_ROM_BOOT_USB1_DIS                   (29*32+9):(29*32+9) /* RW-VF */
			      C ; MCP_ROM_BOOT_MAC0_DIS                 (29*32+10):(29*32+10) /* RW-VF */
			      C ; MCP_ROM_BOOT_MAC1_DIS                 (29*32+11):(29*32+11) /* RW-VF */
			      C ; MCP_ROM_BOOT_ACI_DIS                  (29*32+12):(29*32+12) /* RW-VF */
			      C ; MCP_ROM_BOOT_MCI_DIS                  (29*32+13):(29*32+13) /* RW-VF */
			      C ; MCP_ROM_BOOT_IDE_DIS                  (29*32+14):(29*32+14) /* RW-VF */
			      C ; MCP_ROM_BOOT_P2P_DIS                  (29*32+15):(29*32+15) /* RW-VF */
			      C ; MCP_ROM_BOOT_SMB_DIS                  (29*32+16):(29*32+16) /* RW-VF */
			      C ; MCP_ROM_BOOT_FST_RST                  (29*32+24):(29*32+24) /* R--VF */
			      C ; MCP_ROM_BOOT_FST_RST_NO                          0x00000000 /* R---V */
			      C ; MCP_ROM_BOOT_REBOOT                   (29*32+25):(29*32+25) /* RW-VF */
			      C ; MCP_ROM_BOOT_REBOOT_NO                           0x00000000 /* RW--V */
			      C ; MCP_ROM_BOOT_LDT_FRQ                  (29*32+26):(29*32+26) /* RW-VF */
			      C ; MCP_ROM_BOOT_LDT_FRQ_400MHz                      0x00000000 /* RW--V */
			      C ; MCP_ROM_BOOT_LDT_FRQ_200MHz                      0x00000001 /* RW--V */
			      C ; MCP_ROM_BOOT_PROC                     (29*32+27):(29*32+27) /* RW-VF */
			      C ; MCP_ROM_BOOT_PROC_INTEL                          0x00000000 /* RWI-V */
			      C ; MCP_ROM_BOOT_APU_TYP                  (29*32+28):(29*32+28) /* RW-VF */
			      C ; MCP_ROM_BOOT_APU_TYP_256V                        0x00000000 /* RW--V */
			      C ; MCP_ROM_BOOT_IDE_SEC                  (29*32+29):(29*32+29) /* RW-VF */
			      C ; MCP_ROM_BOOT_IDE_SEC_IDE                         0x00000000 /* RWI-V */
			      C ; MCP_ROM_BOOT_XBOX_ROM_SPEED           (29*32+30):(29*32+30) /* RWIVF */
			      C ; MCP_ROM_BOOT_XBOX_ROM_SPEED_SLOW                 0x00000000 /* RWI-V */
			      C ; MCP_ROM_BOOT_XBOX_ROM_SPEED_FAST                 0x00000001 /* RW--V */
			      C ;
			      C IFDEF SYS_RETAIL
			      C ELSE
 0074  40000000		      C dd 40000000h
			      C ENDIF
			      C ;
			      C ; Init table identifier number 
			      C ;
			      C IFDEF SYS_DVT4
 0078  00000046		      C dd 000000046h            
			      C ELSE
			      C ENDIF
			      C ;
			      C ; offset from ROM base to the datatbl
			      C ;
			      C ; IMPORTANT: If size of the init table code below changes, this offset must be adjusted
			      C ;
 007C  00000BF0		      C dd DATATBL_BASE_OFFSET   
			      C 
			      C ;
			      C ; Force 128 byte alignment MCPX in XBox mode.
			      C ;
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 8 - 1


			      C org 0080h
			      C 
			      C ;//////////////////////////////////////////
			      C ;
			      C ; NV2A init sequence.
			      C ;
			      C ;//////////////////////////////////////////
			      C 
			      C IFDEF SYS_RETAIL
			      C ENDIF
			      C 
			      C         
			      C ;
			      C ; Setup the IO BAR in MCP.  MCP_LEG_CFG_4 below evaluates to different
			      C ; values based on MCP rev we are building for. 
			      C ;
 0080  F9 80000810	      C nv_command_struct<COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_4, 8001h>  
       00008001
			      C 
			      C ;
			      C ; Enable the IO space
			      C ;
 0089  F9 80000804	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_1, 3h>          
       00000003
			      C 
			      C ;
			      C ; Disable the TCO timer
			      C ;
 0092  3C 00008049	      C nv_command_struct <COMMAND_OUT_BYTE,      08049h,     8h> 
       00000008
			      C 
			      C ;
			      C ; Also, the KBDRSTIN# signal should've been pulled low on XBox. It wasn't and
			      C ; was left floating. As a workaround, will change the mode to be a GPIO.
			      C ;
 009B  3C 000080D9	      C nv_command_struct <COMMAND_OUT_BYTE,      080D9h,     0h>       ; KBDRSTIN# in GPIO mode
       00000000
 00A4  3C 00008026	      C nv_command_struct <COMMAND_OUT_BYTE,      08026h,     1h>       ; disable PWRBTN# in PM26
       00000001
			      C 
			      C ;
			      C ; First, we have to gain access to the integrated NV20. This involves
			      C ; enabling intergrated graphics and setting up the NB P2P to configure
			      C ; Bus2.
			      C ;
 00AD  F9 8000F04C	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_19, CR_APC_P2P_19_NV20_ENABLE>    ; internal gr
       00000001		      C aphics enabled
 00B6  F9 8000F018	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_6,  CR_APC_P2P_6_SUB_SEC_PRI_BUS> ; setup secon
       00010100		      C dary bus 1
			      C 
			      C ;
			      C ; Now, config cycles to graphics should work. Setup the memory base/limit
			      C ; on the P2P and the BAR0 of the integrated graphics, so we can access priv
			      C ; regs. Enable BUS_MASTER and MEM/IO space accesses for NV20 and P2P.
			      C ;
			      C ; Note, because of a limitation in COMMAND_READ_MEM, we can't read from an
			      C ; address larger than 28bits, so we need to make our register base mapping
			      C ; under this (0x0D000000), but there's likely kernel code that assumes we're
			      C ; at 0xFD000000, so we'll reload to this address at the end of the inittbl.
			      C ;
 00BF  F9 80000084	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MEMTOP, CR_CPU_MEMTOP_LIMIT_128MB>    ; for proper 
       07FFFFFF		      C P2P addr decode
			      C 
 00C8  F9 8000F020	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_8,  CR_APC_P2P_8_MLIMIT_MBASE_INIT>
       0FF00F00
 00D1  F9 8000F024	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_9,  CR_APC_P2P_9_PREF_MLIMIT_MBASE>
       F7F0F000
 00DA  F9 80010010	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_NV20_PCI_4, NV20_REG_BASE>    ; set register BAR0
       0F000000
 00E3  F9 80010014	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_NV20_PCI_5, NV20_FB_BASE>     ; set framebuffer BAR1
       F0000000
 00EC  F9 80010004	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_NV20_PCI_1, CR_NV20_PCI_1_BUS_MSTR_MEM_IO>
       00000007
 00F5  F9 8000F004	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_1,  CR_APC_P2P_1_BUS_MSTR_MEM_IO>  ; enable spa
       00000007		      C ces
			      C 
			      C ;
			      C ; Also, setup the PBUS_DEBUG_CTRIM values
			      C ;
 00FE  9A 0F000000	      C nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PMC_BOOT_0), DONT_CARE>
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 9 - 1


       00000000
 0107  ED 000000FF	      C nv_command_struct<COMMAND_RMW_RESULT, 0000000FFh, 000000000h>
       00000000
 0110  04 000000A1	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0A1h, (pbus_ctrim_A2-$-4)>    ; (rev >= A2)
       0000002D
			      C ;
 0119			      C pbus_ctrim_A1:
 0119  5B 0F0010B0	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_0),    007633451h>
       07633451
 0122  5B 0F0010CC	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_6),    000000000h>
       00000000
 012B  5B 0F0010B8	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_2),    0FFFF0000h>
       FFFF0000
 0134  5B 0F0010D4	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_7),    000000005h>
       00000005
 013D  25 00000000	      C nv_command_struct<COMMAND_JMP, DONT_CARE, (pbus_ctrim_common-$-4)>
       00000024
			      C 
 0146			      C pbus_ctrim_A2:
 0146  5B 0F0010B0	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_0),    007633461h>
       07633461
 014F  5B 0F0010CC	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_6),    066660000h>
       66660000
			      C 
			      C IFDEF SYS_DVT6
			      C ELSE
 0158  5B 0F0010B8	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_2),    000000000h>
       00000000
			      C ENDIF
 0161  5B 0F0010D4	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_7),    000000009h>
       00000009
			      C 
 016A			      C pbus_ctrim_common:
 016A  5B 0F0010B4	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_1),    000000000h>
       00000000
 0173  5B 0F0010BC	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_3),    000005866h>
       00005866
 017C  5B 0F0010C4	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_4),    00351C858h>
       0351C858
 0185  5B 0F0010C8	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_5),    030007D67h>
       30007D67
 018E  5B 0F0010D8	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_8),    000000000h>
       00000000
 0197  5B 0F0010DC	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_9),    0A0423635h>
       A0423635
 01A0  5B 0F0010E8	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_10),   00C6558C6h>
       0C6558C6
			      C 
			      C ;
			      C ; Before we do MRS_EXT/EMRS_EXT cycles, make sure we've enabled the external bank
			      C ;
 01A9  5B 0F100200	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),              003070103h>
       03070103
			      C 
			      C ;
			      C ; Setup WBC High water mark 
			      C ; The NV_PFB_WBC_HWM field should always be set no greater than 0x17
			      C ;
 01B2  5B 0F100410	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_WBC),               011000016h>
       11000016
			      C 
			      C ;
			      C ; FB Arbitration settings 
			      C ;
 01BB  5B 0F100330	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_ARB_XFER_SZ),       084848888h>
       84848888
 01C4  5B 0F10032C	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_ARB_TIMEOUT),       0FFFFCFFFh>
       FFFFCFFF
 01CD  5B 0F100328	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_ARB_PREDIVIDER),    01h>
       00000001
 01D6  5B 0F100338	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_ARB_DIFF_BANK),     0DFh>
       000000DF
			      C 
			      C 
			      C ;
			      C ; Update PEXTDEV_BOOT_0 (if A01)
			      C ;
			      C ;    0x80354C01 = turn on the override, disables AGP SBA/FW
			      C ;    0x803D4C01 = also sets EMRS_MATCHED
			      C ;    0x803D4C01 = no fast writes
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 10 - 1


			      C ;
 01DF  9A 0F000000	      C nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PMC_BOOT_0), DONT_CARE>
       00000000
 01E8  ED 000000FF	      C nv_command_struct<COMMAND_RMW_RESULT, 0000000FFh, 000000000h>
       00000000
 01F1  04 000000A1	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0A1h, (skip_strap_override-$-4)>    ; (rev >= A2)
       00000009
			      C 
 01FA  5B 0F101000	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PEXTDEV_BOOT_0),        0803D4401h>
       803D4401
 0203			      C skip_strap_override:
			      C 
			      C ;
			      C ; Setup the SMBus for talking to the encoder.
			      C ;
			      C ; On the DVT boards controller 0 isn't used, so only setup controller 1. Besides
			      C ; enabling IO's, we'll also convert the pins from GPIOs to SMBus clk/data. This
			      C ; need to be done early during boot, so there's a pixclk before setting NVCLK.
			      C ;
 0203  F9 80000904	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_SMB_CFG_1,     MCP_SMB_CFG_1_IO_SPACE>
       00000001
 020C  F9 80000914	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_SMB_CFG_5,     MCP_SMB_CFG_5_IO_BASE>
       0000C001
 0215  F9 80000918	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_SMB_CFG_6,     MCP_SMB_CFG_6_IO_BASE>
       0000C201
 021E  3C 0000C200	      C nv_command_struct <COMMAND_OUT_BYTE,      SMB_DDC_SPIO_BASE, 70h>    ; converts from GPIO
       00000070
			      C 
			      C IFNDEF FOCUS                                                                          
			      C ;
			      C ; Now, make sure the TV encoder is driving a pixclk.
			      C ;
 0227  3C 0000C004	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+4, 08Ah>    ; CX871 slave addr
       0000008A
			      C 
			      C ; CX871 offset 0xBA = 0x3F
 0230  3C 0000C008	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0BAh>
       000000BA
 0239  3C 0000C006	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 03Fh>    ; turn on slave bit
       0000003F
 0242  3C 0000C002	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff
       0000000A
			      C 
 024B  C8 0000C000	      C nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
       00000000
 0254  04 00000010	      C nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
       FFFFFFEE
 025D  3C 0000C000	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status
       00000010
			      C 
			      C ; CX871 offset 0x6C = 0x46
 0266  3C 0000C008	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 06Ch>
       0000006C
 026F  3C 0000C006	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 046h>
       00000046
 0278  3C 0000C002	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; write byte kickoff
       0000000A
			      C 
 0281  C8 0000C000	      C nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
       00000000
 028A  04 00000010	      C nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
       FFFFFFEE
 0293  3C 0000C000	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status
       00000010
			      C 
			      C ; CX871 offset 0xB8 = 0x0
 029C  3C 0000C008	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0B8h>
       000000B8
 02A5  3C 0000C006	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 000h>    ; autoconfig
       00000000
 02AE  3C 0000C002	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff
       0000000A
			      C 
 02B7  C8 0000C000	      C nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
       00000000
 02C0  04 00000010	      C nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
       FFFFFFEE
 02C9  3C 0000C000	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status
       00000010
			      C 
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 11 - 1


			      C ; CX871 offset 0xCE = 0x19
 02D2  3C 0000C008	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0CEh>
       000000CE
 02DB  3C 0000C006	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 019h>
       00000019
 02E4  3C 0000C002	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff
       0000000A
			      C 
 02ED  C8 0000C000	      C nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
       00000000
 02F6  04 00000010	      C nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
       FFFFFFEE
 02FF  3C 0000C000	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status
       00000010
			      C 
			      C ; CX871 offset 0xC6 = 0x9C
 0308  3C 0000C008	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0C6h>
       000000C6
 0311  3C 0000C006	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 09Ch>
       0000009C
 031A  3C 0000C002	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff
       0000000A
			      C 
 0323  C8 0000C000	      C nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
       00000000
 032C  04 00000010	      C nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
       FFFFFFEE
 0335  3C 0000C000	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status
       00000010
			      C 
			      C ; CX871 offset 0x32 = 0x08
 033E  3C 0000C008	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 032h>
       00000032
 0347  3C 0000C006	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 008h>
       00000008
 0350  3C 0000C002	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff
       0000000A
			      C 
 0359  C8 0000C000	      C nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
       00000000
 0362  04 00000010	      C nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
       FFFFFFEE
 036B  3C 0000C000	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status
       00000010
			      C 
			      C ; CX871 offset 0xC4 = 0x01
 0374  3C 0000C008	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0C4h>
       000000C4
 037D  3C 0000C006	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 001h>    ; enable clk output
       00000001
 0386  3C 0000C002	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff
       0000000A
			      C 
 038F  C8 0000C000	      C nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
       00000000
 0398  04 00000010	      C nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
       FFFFFFEE
 03A1  3C 0000C000	      C nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status
       00000010
			      C 
			      C ENDIF
			      C 
			      C 
			      C IFDEF SYS_RETAIL
			      C ENDIF
			      C 
			      C ;
			      C ; Set NVCLK (M, N, P may need adjusting if integrated NV20 VCOs are different)
			      C ;    0x0001ED08 = 200MHz
			      C ;    0x00011701 = 155MHz    (rev == 0xA01)
			      C ;    0x00011C01 = 189MHz
			      C ;    0x00011E01 = 202.5MHz   (rev >= 0xA02)
			      C ;    0x00011F01 = 209.25MHz  (rev >= 0xA02)
			      C ;    0x00014502 = 229.5MHz   (rev >= 0xA02 and 1.7V w/ fansink DVT3)
			      C ;
			      C ;nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PRAMDAC_NVPLL_COEFF),      00001ED08h>
			      C ;
 03AA  9A 0F000000	      C nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PMC_BOOT_0), DONT_CARE>
       00000000
 03B3  ED 000000FF	      C nv_command_struct<COMMAND_RMW_RESULT, 0000000FFh, 000000000h>
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 12 - 1


       00000000
 03BC  04 000000A1	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0A1h, (nvclk_200-$-4)>    ; (rev >= A2)
       00000012
			      C 
 03C5			      C nvclk_155:
 03C5  5B 0F680500	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PRAMDAC_NVPLL_COEFF),      000011701h>
       00011701
 03CE  25 00000000	      C nv_command_struct<COMMAND_JMP, DONT_CARE, (pll_select-$-4)>
       00000009
			      C 
 03D7			      C nvclk_200:
			      C 
 03D7  5B 0F680500	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PRAMDAC_NVPLL_COEFF),      000011C01h>
       00011C01
			      C 
 03E0			      C pll_select:
 03E0  5B 0F68050C	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PRAMDAC_PLL_COEFF_SELECT), 0000A0400h>
       000A0400
			      C 
			      C ;
			      C ; Disable FBIO/TVD calibration
			      C ;
 03E9  5B 0F001220	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CALEN),  NV_PBUS_FBIO_CALEN_OFF>
       00000000
 03F2  5B 0F001228	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CALSEL), NV_PBUS_FBIO_CALSEL_VALU
       00000000		      C E>
 03FB  5B 0F001264	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_TVDIO_CALEN), NV_PBUS_TVDIO_CALEN_OFF>
       00000000
			      C 
			      C ;
			      C ; Set the ADR_EDGE_HALF bit in FBIO_CFG
			      C ;
 0404  5B 0F001210	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CFG), 000000010h>
       00000010
			      C 
			      C ;
			      C ; DRAM configuration
			      C ;
			      C ; Determine Samsung vs Micron by checking NV_PEXTDEV_BOOT_0_STRAP_EMRS (19:18)
			      C ; 0=Micron, 3=Samsung
			      C ;
 040D  9A 0F101000	      C nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PEXTDEV_BOOT_0), DONT_CARE>
       00000000
 0416  ED 000C0000	      C nv_command_struct<COMMAND_RMW_RESULT, 0000C0000h, 000000000h>
       00000000
 041F  04 00000000	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0h, (samsung_memory-$-4)> 
       0000001B
			      C 
			      C ;
			      C ; Configure for Micron
			      C ;
 0428  5B 0F001214	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DLY),    028282828h>
       28282828
 0431  5B 0F00122C	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_ADRDRV), 088888888h>
       88888888
 043A  25 00000000	      C nv_command_struct<COMMAND_JMP, DONT_CARE, (memory_pad_config-$-4)>
       00000012
			      C 
 0443			      C samsung_memory:
			      C ;
			      C ; Configure for Samsung
			      C ;
 0443  5B 0F001214	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DLY),    009090909h>
       09090909
 044C  5B 0F00122C	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_ADRDRV), 0AAAAAAAAh> 
       AAAAAAAA
			      C 
 0455			      C memory_pad_config:
			      C 
			      C ;
			      C ; Memory PAD configuration
			      C ;
 0455  5B 0F001230	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CLKDRV), 0FFFFFFFFh>
       FFFFFFFF
 045E  5B 0F001234	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DATDRV), NV_PBUS_FBIO_DATDRV_INIT
       AAAAAAAA		      C >
 0467  5B 0F001238	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DQSDRV), NV_PBUS_FBIO_DQSDRV_INIT
       AAAAAAAA		      C >
 0470  5B 0F00123C	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_ADRSLW), NV_PBUS_FBIO_ADRSLW_INIT
       8B8B8B8B		      C >
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 13 - 1


 0479  5B 0F001240	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CLKSLW), 0FFFFFFFFh>
       FFFFFFFF
 0482  5B 0F001244	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DATSLW), NV_PBUS_FBIO_DATSLW_INIT
       8B8B8B8B		      C >
 048B  5B 0F001248	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DQSSLW), NV_PBUS_FBIO_DQSSLW_INIT
       8B8B8B8B		      C >
			      C 
			      C ;
			      C ; RAM Initialization (XXX should we be waiting for cmds to complete?)
			      C ;
 0494  5B 0F1002D4	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_PRE),      NV_PFB_PRE_CMD_PRECHARGE_1>
       00000001
 049D  5B 0F1002C4	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_EMRS),     000100042h>
       00100042
 04A6  5B 0F1002CC	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_EMRS_EXT), 000100042h>
       00100042
 04AF  5B 0F1002C0	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS),      000000011h>
       00000011
 04B8  5B 0F1002C8	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS_EXT),  000000011h>
       00000011
 04C1  5B 0F1002C0	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS),      000000032h>
       00000032
 04CA  5B 0F1002C8	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS_EXT),  000000032h>
       00000032
 04D3  5B 0F1002C0	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS),      NV_PFB_MRS_DLL_RESET>
       00000132
 04DC  5B 0F1002C8	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS_EXT),  NV_PFB_MRS_EXT_DLL_RESET>
       00000132
 04E5  5B 0F1002D0	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_REF),      000000001h>
       00000001
 04EE  5B 0F1002D0	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_REF),      000000001h>
       00000001
 04F7  5B 0F100210	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_REFCTRL),  NV_PFB_REFCTRL_VALID_1>
       80000000
			      C 
			      C ;
			      C ; Display PAD configuration
			      C ;
 0500  5B 0F00124C	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DISPIO_PADCTL), NV_PBUS_DISPIO_PADCTL_
       AA8BAA8B		      C INIT>
			      C 
			      C ;
			      C ; TVD PAD configuration
			      C ;
 0509  5B 0F001250	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_TVDIO_PADCTL), NV_PBUS_TVDIO_PADCTL_IN
       0000AA8B		      C IT>
			      C 
			      C ;
			      C ; Change PFB_TIMING2 and PBUS_FBIO_RAM
			      C ;
			      C ; NV_PFB_TIMING2 = 0x081202FF
			      C ;                = 0x081205FF    (increase REFRESH count with M=1, N=9, MEMPDIV=2)
			      C ;
 0512  5B 0F100228	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_TIMING2),   0081205FFh>
       081205FF
 051B  5B 0F001218	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_RAM), 000010000h>
       00010000
			      C 
			      C ;
			      C ; Tell MCP not to generate INIT# in response to the shutdown cycle 
			      C ;
 0524  F5 80000860	      C nv_command_struct<COMMAND_PCI_CFG_READ, MCP_LEG_CFG_24, DONT_CARE>
       00000000
 052D  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT, 0FFFFFFFFh, 000000400h>
       00000400
 0536  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_24>
       80000860
			      C 
			      C ;
			      C ; Init ISO/non-ISO bits for the various MCP unit IDs
			      C ;
 053F  F9 8000084C	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_19, 00000FDDEh>
       0000FDDE
			      C 
			      C ;
			      C ; Make sure the USB PLL has the correct value (not the POR value).
			      C ;
			      C ; nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_39, 0851CAA0Ch>
 0548  F9 8000089C	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_39, 0871CC707h>
       871CC707
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 14 - 1


			      C 
			      C ;
			      C ; Set the maximum PCICLK_OUT5 trim (bits 11:8 = 0xF).
			      C ;
 0551  F5 800008B4	      C nv_command_struct<COMMAND_PCI_CFG_READ, MCP_LEG_CFG_45, DONT_CARE>
       00000000
 055A  ED FFFFF0FF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFF0FFh, 000000F00h>
       00000F00
 0563  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_45>
       800008B4
			      C 
			      C ;
			      C ; Set cshape/ctrim for clocks in CR_top.
			      C ;
 056C  F9 80000340	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_CST_0, 0F0F0C0C0h>    ; A03
       F0F0C0C0
 0575  F9 80000344	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_CST_1, 000C00000h>
       00C00000
 057E  F9 8000035C	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_CST_7, 004070000h>
       04070000
			      C 
			      C ;
			      C ; These values have been set by the straps, but we'll write them into the
			      C ; CR_CPU_MPLL_COEFF register, so the values are knowable outside the ROM.
			      C ;
			      C ; Currently, we have MEM_PDIV of 3, which is 133MHz and will be left that
			      C ; way for A01. For A02, we set the MEM_PDIV to 2, which sets a 200MHz mclk.
			      C ;
			      C ;    (0x230901: MEM_PDIV = 2, FSB_PDIV = 3; NDIV = 9;  MDIV = 1)
			      C ;    (0x230A01: MEM_PDIV = 2, FSB_PDIV = 3; NDIV = A;  MDIV = 1)
			      C ;    (0x231D03: MEM_PDIV = 2, FSB_PDIV = 3; NDIV = 1D; MDIV = 3)
			      C ;
			      C ; nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000230901h>
			      C ; nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000230901h>    ; 182MHz
			      C ; nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000231D03h>    ; 200MHz
			      C ; nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000230A01h>    ; 202MHz
			      C ;
 0587  9A 0F000000	      C nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PMC_BOOT_0), DONT_CARE>
       00000000
 0590  ED 000000FF	      C nv_command_struct<COMMAND_RMW_RESULT, 0000000FFh, 000000000h>
       00000000
 0599  04 000000A1	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0A1h, (mclk_200-$-4)>    ; (rev >= A2)
       00000009
 05A2  25 00000000	      C nv_command_struct<COMMAND_JMP, DONT_CARE, (mclk_133-$-4)>              ; (rev == A1)
       00000000
			      C 
 05AB			      C mclk_133:
 05AB			      C mclk_200:
			      C ;
			      C ; Set the clocks and override. CR_CPU_MPLL_COEFF must be set once without override
			      C ; and then again with override. 
			      C ;
 05AB  F9 8000036C	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000230801h>
       00230801
 05B4  F9 8000036C	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 001230801h>  
       01230801
			      C 
			      C ;
			      C ; Delay ~15 nano seconds by performing jmps
			      C ; 
 05BD  25 00000000	      C nv_command_struct< COMMAND_JMP, DONT_CARE, (DelayJump1-$-4) >
       00000000
 05C6			      C DelayJump1:
 05C6  25 00000000	      C nv_command_struct< COMMAND_JMP, DONT_CARE, (DelayJump2-$-4) >
       00000000
 05CF			      C DelayJump2:
			      C 
			      C ; MEMORY TEST
			      C ; 
			      C ; This section does memory detection and test, and then updates
			      C ; the memory config registers and reports this config (and memory errors) back
			      C ; to the SMC.
			      C ;
			      C ; First, this is how the addressing works, with 12 row bits and an
			      C ; external bank:
			      C ;
			      C ;    E[0:0],R[11:10] | R[9:6] | R[5:2] | R[1:0],B[1:0] | C[7:4] | C[3:2],P[1:0] | C[1:0],00
			      C ;
			      C ; We determine a particular DRAMs number of row bits (11 or 12) by toggling
			      C ; the R11 bit and looking for an alias within the DRAM (row address bit doesn't
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 15 - 1


			      C ; exist with the 2Mx32 parts).
			      C ;
			      C ; For row detection with the first 4 DRAM partitions (MEM_PART_0 -> MEM_PART_3),
			      C ; we'll address at 0x2500000 (R11 = 1, ext_bank = 0) and cycle the partition bits.
			      C ; For the second set of DRAMS (MEM_PART_4 -> MEM_PART_7), we'll address at
			      C ; 0x6500000 (R11 = 1, ext_bank = 1).
			      C ;
			      C ; In addition to row detection, we'll update the SMC controller with the number
			      C ; of 2Mx32 and 4Mx32 DRAMS and any memory errors we've found. We use the 2 USB
			      C ; registers as scratchpad (reset to 0 and later overwritten by the kernel).
			      C ;
			      C ;    rows = 2^12, cols = 2^8, banks = 2^2, external bank
			      C ;
			      C 
			      C 
 05CF  5B 0F100200	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),  003070103h>
       03070103
 05D8  5B 0F100204	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG1),  011448000h>
       11448000
			      C 
			      C ;
			      C ; Clear the scratchpad registers used in memory test
			      C ;
 05E1  F9 8000103C	      C nv_command_struct<COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE, 0>
       00000000
 05EA  F9 8000183C	      C nv_command_struct<COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT, 0>
       00000000
			      C 
			      C ;-------------------------------------------------------------------------------
 05F3			      C dram0:
 05F3  5B 00555548	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_0 + 000555548h), MEMTEST_PATTERN1>
       AAAAAAAA
 05FC  5B 02555548	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_0 + 002555548h), MEMTEST_PATTERN2>
       5A5A5A5A
			      C 
			      C ; does the DRAM exist?
 0605  9A 02555548	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_0 + 002555548h), DONT_CARE>
       00000000
 060E  04 5A5A5A5A	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram0_err-$-4)>
       00000051
			      C 
			      C ; did we alias in the DRAM?
 0617  9A 00555548	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_0 + 000555548h), DONT_CARE>
       00000000
 0620  04 AAAAAAAA	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram0_alt_write-$-4)>
       0000001B
			      C 
 0629			      C dram0_4mb:
 0629  F5 8000103C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
       00000000
 0632  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000001h>
       00000001
 063B  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>
       8000103C
			      C 
 0644			      C dram0_alt_write:
 0644  5B 00555548	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_0 + 000555548h), MEMTEST_PATTERN3>
       55555555
 064D  9A 00555548	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_0 + 000555548h), DONT_CARE>
       00000000
 0656  04 55555555	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram0_err-$-4)>
       00000009
 065F  25 00000000	      C nv_command_struct<COMMAND_JMP, DONT_CARE, (dram1-$-4)>
       0000001B
			      C 
 0668			      C dram0_err:
 0668  F5 8000183C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
       00000000
 0671  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000001h>
       00000001
 067A  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>
       8000183C
			      C 
			      C 
			      C ;-------------------------------------------------------------------------------
 0683			      C dram1:
 0683  5B 00555558	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_1 + 000555548h), MEMTEST_PATTERN1>
       AAAAAAAA
 068C  5B 02555558	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_1 + 002555548h), MEMTEST_PATTERN2>
       5A5A5A5A
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 16 - 1


			      C 
			      C ; does the DRAM exist?
 0695  9A 02555558	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_1 + 002555548h), DONT_CARE>
       00000000
 069E  04 5A5A5A5A	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram1_err-$-4)>
       00000051
			      C 
			      C ; did we alias in the DRAM?
 06A7  9A 00555558	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_1 + 000555548h), DONT_CARE>
       00000000
 06B0  04 AAAAAAAA	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram1_alt_write-$-4)>
       0000001B
			      C 
 06B9			      C dram1_4mb:
 06B9  F5 8000103C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
       00000000
 06C2  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000002h>
       00000002
 06CB  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>
       8000103C
			      C 
 06D4			      C dram1_alt_write:
 06D4  5B 00555558	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_1 + 000555548h), MEMTEST_PATTERN3>
       55555555
 06DD  9A 00555558	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_1 + 000555548h), DONT_CARE>
       00000000
 06E6  04 55555555	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram1_err-$-4)>
       00000009
 06EF  25 00000000	      C nv_command_struct<COMMAND_JMP, DONT_CARE, (dram2-$-4)>
       0000001B
			      C 
 06F8			      C dram1_err:
 06F8  F5 8000183C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
       00000000
 0701  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000002h>
       00000002
 070A  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>
       8000183C
			      C 
			      C 
			      C ;-------------------------------------------------------------------------------
 0713			      C dram2:
 0713  5B 00555568	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_2 + 000555548h), MEMTEST_PATTERN1>
       AAAAAAAA
 071C  5B 02555568	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_2 + 002555548h), MEMTEST_PATTERN2>
       5A5A5A5A
			      C 
			      C ; does the DRAM exist?
 0725  9A 02555568	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_2 + 002555548h), DONT_CARE>
       00000000
 072E  04 5A5A5A5A	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram2_err-$-4)>
       00000051
			      C 
			      C ; did we alias in the DRAM?
 0737  9A 00555568	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_2 + 000555548h), DONT_CARE>
       00000000
 0740  04 AAAAAAAA	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram2_alt_write-$-4)>
       0000001B
			      C 
 0749			      C dram2_4mb:
 0749  F5 8000103C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
       00000000
 0752  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000004h>
       00000004
 075B  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>
       8000103C
			      C 
 0764			      C dram2_alt_write:
 0764  5B 00555568	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_2 + 000555548h), MEMTEST_PATTERN3>
       55555555
 076D  9A 00555568	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_2 + 000555548h), DONT_CARE>
       00000000
 0776  04 55555555	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram2_err-$-4)>
       00000009
 077F  25 00000000	      C nv_command_struct<COMMAND_JMP, DONT_CARE, (dram3-$-4)>
       0000001B
			      C 
 0788			      C dram2_err:
 0788  F5 8000183C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
       00000000
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 17 - 1


 0791  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000004h>
       00000004
 079A  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>
       8000183C
			      C 
			      C 
			      C ;-------------------------------------------------------------------------------
 07A3			      C dram3:
 07A3  5B 00555578	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_3 + 000555548h), MEMTEST_PATTERN1>
       AAAAAAAA
 07AC  5B 02555578	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_3 + 002555548h), MEMTEST_PATTERN2>
       5A5A5A5A
			      C 
			      C ; does the DRAM exist?
 07B5  9A 02555578	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_3 + 002555548h), DONT_CARE>
       00000000
 07BE  04 5A5A5A5A	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram3_err-$-4)>
       00000051
			      C 
			      C ; did we alias in the DRAM?
 07C7  9A 00555578	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_3 + 000555548h), DONT_CARE>
       00000000
 07D0  04 AAAAAAAA	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram3_alt_write-$-4)>
       0000001B
			      C 
 07D9			      C dram3_4mb:
 07D9  F5 8000103C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
       00000000
 07E2  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000008h>
       00000008
 07EB  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>
       8000103C
			      C 
 07F4			      C dram3_alt_write:
 07F4  5B 00555578	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_3 + 000555548h), MEMTEST_PATTERN3>
       55555555
 07FD  9A 00555578	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_3 + 000555548h), DONT_CARE>
       00000000
 0806  04 55555555	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram3_err-$-4)>
       00000009
 080F  25 00000000	      C nv_command_struct<COMMAND_JMP, DONT_CARE, (dram4-$-4)>
       0000001B
			      C 
 0818			      C dram3_err:
 0818  F5 8000183C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
       00000000
 0821  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000008h>
       00000008
 082A  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>
       8000183C
			      C 
			      C 
			      C ;-------------------------------------------------------------------------------
 0833			      C dram4:
 0833  5B 04555548	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_4 + 000555548h), MEMTEST_PATTERN1>
       AAAAAAAA
 083C  5B 06555548	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_4 + 002555548h), MEMTEST_PATTERN2>
       5A5A5A5A
			      C 
			      C ; does the DRAM exist?
 0845  9A 06555548	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_4 + 002555548h), DONT_CARE>
       00000000
 084E  04 5A5A5A5A	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram4_err-$-4)>
       00000051
			      C 
			      C ; did we alias in the DRAM?
 0857  9A 04555548	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_4 + 000555548h), DONT_CARE>
       00000000
 0860  04 AAAAAAAA	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram4_alt_write-$-4)>
       0000001B
			      C 
 0869			      C dram4_4mb:
 0869  F5 8000103C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
       00000000
 0872  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000010h>
       00000010
 087B  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>
       8000103C
			      C 
 0884			      C dram4_alt_write:
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 18 - 1


 0884  5B 04555548	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_4 + 000555548h), MEMTEST_PATTERN3>
       55555555
 088D  9A 04555548	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_4 + 000555548h), DONT_CARE>
       00000000
 0896  04 55555555	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram4_err-$-4)>
       00000009
 089F  25 00000000	      C nv_command_struct<COMMAND_JMP, DONT_CARE, (dram5-$-4)>
       0000001B
			      C 
 08A8			      C dram4_err:
 08A8  F5 8000183C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
       00000000
 08B1  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000010h>
       00000010
 08BA  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>
       8000183C
			      C 
			      C 
			      C ;-------------------------------------------------------------------------------
 08C3			      C dram5:
 08C3  5B 04555558	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_5 + 000555548h), MEMTEST_PATTERN1>
       AAAAAAAA
 08CC  5B 06555558	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_5 + 002555548h), MEMTEST_PATTERN2>
       5A5A5A5A
			      C 
			      C ; does the DRAM exist?
 08D5  9A 06555558	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_5 + 002555548h), DONT_CARE>
       00000000
 08DE  04 5A5A5A5A	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram5_err-$-4)>
       00000051
			      C 
			      C ; did we alias in the DRAM?
 08E7  9A 04555558	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_5 + 000555548h), DONT_CARE>
       00000000
 08F0  04 AAAAAAAA	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram5_alt_write-$-4)>
       0000001B
			      C 
 08F9			      C dram5_4mb:
 08F9  F5 8000103C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
       00000000
 0902  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000020h>
       00000020
 090B  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>
       8000103C
			      C 
 0914			      C dram5_alt_write:
 0914  5B 04555558	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_5 + 000555548h), MEMTEST_PATTERN3>
       55555555
 091D  9A 04555558	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_5 + 000555548h), DONT_CARE>
       00000000
 0926  04 55555555	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram5_err-$-4)>
       00000009
 092F  25 00000000	      C nv_command_struct<COMMAND_JMP, DONT_CARE, (dram6-$-4)>
       0000001B
			      C 
 0938			      C dram5_err:
 0938  F5 8000183C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
       00000000
 0941  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000020h>
       00000020
 094A  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>
       8000183C
			      C 
			      C 
			      C ;-------------------------------------------------------------------------------
 0953			      C dram6:
 0953  5B 04555568	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_6 + 000555548h), MEMTEST_PATTERN1>
       AAAAAAAA
 095C  5B 06555568	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_6 + 002555548h), MEMTEST_PATTERN2>
       5A5A5A5A
			      C 
			      C ; does the DRAM exist?
 0965  9A 06555568	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_6 + 002555548h), DONT_CARE>
       00000000
 096E  04 5A5A5A5A	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram6_err-$-4)>
       00000051
			      C 
			      C ; did we alias in the DRAM?
 0977  9A 04555568	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_6 + 000555548h), DONT_CARE>
       00000000
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 19 - 1


 0980  04 AAAAAAAA	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram6_alt_write-$-4)>
       0000001B
			      C 
 0989			      C dram6_4mb:
 0989  F5 8000103C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
       00000000
 0992  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000040h>
       00000040
 099B  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>
       8000103C
			      C 
 09A4			      C dram6_alt_write:
 09A4  5B 04555568	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_6 + 000555548h), MEMTEST_PATTERN3>
       55555555
 09AD  9A 04555568	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_6 + 000555548h), DONT_CARE>
       00000000
 09B6  04 55555555	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram6_err-$-4)>
       00000009
 09BF  25 00000000	      C nv_command_struct<COMMAND_JMP, DONT_CARE, (dram7-$-4)>
       0000001B
			      C 
 09C8			      C dram6_err:
 09C8  F5 8000183C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
       00000000
 09D1  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000040h>
       00000040
 09DA  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>
       8000183C
			      C 
			      C 
			      C ;-------------------------------------------------------------------------------
 09E3			      C dram7:
 09E3  5B 04555578	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_7 + 000555548h), MEMTEST_PATTERN1>
       AAAAAAAA
 09EC  5B 06555578	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_7 + 002555548h), MEMTEST_PATTERN2>
       5A5A5A5A
			      C 
			      C ; does the DRAM exist?
 09F5  9A 06555578	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_7 + 002555548h), DONT_CARE>
       00000000
 09FE  04 5A5A5A5A	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram7_err-$-4)>
       00000051
			      C 
			      C ; did we alias in the DRAM?
 0A07  9A 04555578	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_7 + 000555548h), DONT_CARE>
       00000000
 0A10  04 AAAAAAAA	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram7_alt_write-$-4)>
       0000001B
			      C 
 0A19			      C dram7_4mb:
 0A19  F5 8000103C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
       00000000
 0A22  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000080h>
       00000080
 0A2B  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>
       8000103C
			      C 
 0A34			      C dram7_alt_write:
 0A34  5B 04555578	      C nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_7 + 000555548h), MEMTEST_PATTERN3>
       55555555
 0A3D  9A 04555578	      C nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_7 + 000555548h), DONT_CARE>
       00000000
 0A46  04 55555555	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram7_err-$-4)>
       00000009
 0A4F  25 00000000	      C nv_command_struct<COMMAND_JMP, DONT_CARE, (memtest_done-$-4)>
       0000001B
			      C 
 0A58			      C dram7_err:
 0A58  F5 8000183C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
       00000000
 0A61  ED FFFFFFFF	      C nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000080h>
       00000080
 0A6A  68 000000F9	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>
       8000183C
			      C 
			      C 
 0A73			      C memtest_done:
			      C ;
			      C ; Start by assuming we're using a 4Mx32, 64MB config (no external bank).
			      C ; We've already set rows = 2^12, so clear the external bank bit.
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 20 - 1


			      C ;
 0A73  5B 0F100200	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),  003070003h>
       03070003
 0A7C  F9 80000084	      C nv_command_struct<COMMAND_PCI_CFG_WRITE, CR_CPU_MEMTOP, CR_CPU_MEMTOP_LIMIT_64MB>
       03FFFFFF
			      C 
			      C ;
			      C ; Read out our bitmask of 4Mx32 parts into the SMBus register and update our
			      C ; memory config, if necessary.
			      C ; 
 0A85  F5 8000103C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
       00000000
 0A8E  ED 000000FF	      C nv_command_struct<COMMAND_RMW_RESULT,   0000000FFh, 000000000h>
       00000000
 0A97  68 0000003C	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6>
       0000C006
			      C 
 0AA0  C8 0000C006	      C nv_command_struct<COMMAND_IN_BYTE,  SMB_CONTROL_BASE+6, DONT_CARE>
       00000000
 0AA9  04 00000000	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 000000000h, (dram_4M-$-4)>
       0000001B
			      C 
			      C ; Reset back to 11 row bits and add back the external bank bit
 0AB2  5B 0F100200	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),  003070103h>    ; extbank bit
       03070103
 0ABB  5B 0F100204	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG1),  011338000h>    ; 11 row bits
       11338000
 0AC4  25 00000000	      C nv_command_struct<COMMAND_JMP, DONT_CARE, (mem_report-$-4)>
       00000024
			      C 
 0ACD			      C dram_4M:
			      C ; We've got some 4Mx32 parts, check if we're a 128MB config?
 0ACD  C8 0000C006	      C nv_command_struct<COMMAND_IN_BYTE,  SMB_CONTROL_BASE+6, DONT_CARE>
       00000000
 0AD6  04 000000FF	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0000000FFh, (mem_report-$-4)>
       00000012
			      C 
			      C ; Add back the external bank bit and update MEMTOP
 0ADF  5B 0F100200	      C nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),  003070103h>    ; extback bit
       03070103
 0AE8  F9 80000084	      C nv_command_struct<COMMAND_PCI_CFG_WRITE, CR_CPU_MEMTOP, CR_CPU_MEMTOP_LIMIT_128MB>
       07FFFFFF
			      C 
			      C 
 0AF1			      C mem_report:
			      C 
			      C ;
			      C ; Report the results to the SMC
			      C ;
 0AF1  3C 0000C004	      C nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+4, 020h>     ; SMC slave addr
       00000020
			      C 
			      C ;
			      C ; Send Memory Type (already in SMB_CONTROL_BASE+6) to SMC
			      C ;
 0AFA  3C 0000C008	      C nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 013h>     ; SMC Register
       00000013
 0B03  3C 0000C002	      C nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>     ; kickoff
       0000000A
			      C 
 0B0C  C8 0000C000	      C nv_command_struct<COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE>  ; read back status
       00000000
 0B15  04 00000010	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 010h,     -18>      ; spin if not idle
       FFFFFFEE
 0B1E  3C 0000C000	      C nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>       ; clear status
       00000010
			      C 
			      C ;
			      C ; Send Memory test results to SMC
			      C ;
 0B27  F5 8000183C	      C nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
       00000000
 0B30  ED 000000FF	      C nv_command_struct<COMMAND_RMW_RESULT,   0000000FFh, 000000000h>
       00000000
 0B39  68 0000003C	      C nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6>
       0000C006
			      C 
 0B42  3C 0000C008	      C nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 012h>     ; SMC Register
       00000012
 0B4B  3C 0000C002	      C nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>     ; kickoff
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 21 - 1


       0000000A
			      C 
 0B54  C8 0000C000	      C nv_command_struct<COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE>  ; read back status
       00000000
 0B5D  04 00000010	      C nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 010h,     -18>      ; spin if not idle
       FFFFFFEE
 0B66  3C 0000C000	      C nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>       ; clear status
       00000010
			      C 
 0B6F			      C mem_report_end:
			      C 
			      C 
			      C ;
			      C ; Reload the NV20 register base (should be just prior to COMMAND_QUIT)
			      C ; to what the kernel expects.
			      C ;
 0B6F  F9 8000F020	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_8,  CR_APC_P2P_8_MLIMIT_MBASE_KERNEL>
       FDF0FD00
 0B78  F9 80010010	      C nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_NV20_PCI_4, NV20_REG_BASE_KERNEL>
       FD000000
			      C 
			      C ; End of table.  First argument is used as the value for the default MTRR register
			      C ;
 0B81  BF 00000806	      C nv_command_struct <COMMAND_QUIT, 0806h, DONT_CARE>
       00000000
			      C 
			      C ;
			      C ; Drive/Slew Parameter Offset and Data.  Boot loader needs to access this data
			      C ; 
			      C 
			      C org DATATBL_BASE_OFFSET  
			      C 
			      C ;DATATBL_DRVSLWPARAM_OFFSET   EQU DATATBL_BASE_OFFSET+0
			      C 
			      C ;-----------------------------------------------------------------------------
			      C 
 0BF0			      C DrvSlwParamBegin:
			      C ;
			      C ; Common calibration data
			      C ;
 0BF0  4E20		      C dw    20000    ; MaxMClk (230Mhz)
			      C ;
			      C ; Operating condition based on speedometer
			      C ;     (Count is from VCCQ; CountB is from VCC)
			      C ;
			      C 
			      C ;
			      C ; 16.6 clock
			      C ;
			      C 
 0BF2  4E		      C db    4Eh      ; SlowCountExt
 0BF3  3E		      C db    3Eh      ; SlowCountBExt
			      C 
 0BF4  56		      C db    56h      ; SlowCountAvg
 0BF5  43		      C db    43h      ; SlowCountBAvg
			      C 
 0BF6  5D		      C db    5Dh      ; TypiCount
 0BF7  4A		      C db    4Ah      ; TypiCountB
			      C 
 0BF8  64		      C db    64h      ; FastCountAvg
 0BF9  50		      C db    50h      ; FastCountBAvg
			      C 
 0BFA  6A		      C db    6Ah      ; FastCountExt
 0BFB  55		      C db    55h      ; FastCountBExt
			      C 
			      C ;-----------------------------------------------------------------------------
			      C ;
			      C ; Samsung Extreme FAST values 
			      C ;
 0BFC  09		      C db    09h      ; AdrDrvFallFastExt
 0BFD  09		      C db    09h      ; AdrDrvRiseFastExt
 0BFE  0E		      C db    0Eh      ; AdrSlwFallFastExt
 0BFF  08		      C db    08h      ; AdrSlwRiseFastExt
			      C 
 0C00  0F		      C db    0Fh      ; ClkDrvFallFastExt
 0C01  0F		      C db    0Fh      ; ClkDrvRiseFastExt
 0C02  0F		      C db    0Fh      ; ClkSlwFallFastExt
 0C03  0F		      C db    0Fh      ; ClkSlwRiseFastExt
			      C 
 0C04  09		      C db    09h      ; DatDrvFallFastExt
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 22 - 1


 0C05  09		      C db    09h      ; DatDrvRiseFastExt
 0C06  0E		      C db    0Eh      ; DatSlwFallFastExt
 0C07  08		      C db    08h      ; DatSlwRiseFastExt
			      C 
 0C08  09		      C db    09h      ; DqsDrvFallFastExt
 0C09  09		      C db    09h      ; DqsDrvRiseFastExt
 0C0A  0E		      C db    0Eh      ; DqsSlwFallFastExt
 0C0B  08		      C db    08h      ; DqsSlwRiseFastExt
			      C 
			      C IFDEF SYS_DVT6
			      C ELSE
 0C0C  00		      C db    00h      ; DataInbDelyFastExt
 0C0D  00		      C db    00h      ; ClkIcDelyFastExt
 0C0E  01		      C db    01h      ; DqsInbDelyFastExt
			      C ENDIF
			      C ;
			      C ; Samsung Average FAST values
			      C ;
 0C0F  09		      C db    09h      ; AdrDrvFallFastAvg
 0C10  09		      C db    09h      ; AdrDrvRiseFastAvg
 0C11  0E		      C db    0Eh      ; AdrSlwFallFastAvg
 0C12  08		      C db    08h      ; AdrSlwRiseFastAvg
			      C 
 0C13  0F		      C db    0Fh      ; ClkDrvFallFastAvg
 0C14  0F		      C db    0Fh      ; ClkDrvRiseFastAvg
 0C15  0F		      C db    0Fh      ; ClkSlwFallFastAvg
 0C16  0F		      C db    0Fh      ; ClkSlwRiseFastAvg
			      C 
 0C17  09		      C db    09h      ; DatDrvFallFastAvg
 0C18  09		      C db    09h      ; DatDrvRiseFastAvg
 0C19  0E		      C db    0Eh      ; DatSlwFallFastAvg
 0C1A  08		      C db    08h      ; DatSlwRiseFastAvg
			      C 
 0C1B  09		      C db    09h      ; DqsDrvFallFastAvg
 0C1C  09		      C db    09h      ; DqsDrvRiseFastAvg
 0C1D  0E		      C db    0Eh      ; DqsSlwFallFastAvg
 0C1E  08		      C db    08h      ; DqsSlwRiseFastAvg
			      C 
			      C IFDEF SYS_DVT6
			      C ELSE
 0C1F  00		      C db    00h      ; DataInbDelyFastAvg
 0C20  01		      C db    01h      ; ClkIcDelyFastAvg
 0C21  01		      C db    01h      ; DqsInbDelyFastAvg 
			      C ENDIF
			      C ;
			      C ; Samsung Typical values
			      C ;
 0C22  09		      C db    09h      ; AdrDrvFallTypi
 0C23  09		      C db    09h      ; AdrDrvRiseTypi
 0C24  0E		      C db    0Eh      ; AdrSlwFallTypi
 0C25  08		      C db    08h      ; AdrSlwRiseTypi
			      C 
 0C26  0F		      C db    0Fh      ; ClkDrvFallTypi
 0C27  0F		      C db    0Fh      ; ClkDrvRiseTypi
 0C28  0F		      C db    0Fh      ; ClkSlwFallTypi
 0C29  0F		      C db    0Fh      ; ClkSlwRiseTypi
			      C 
 0C2A  09		      C db    09h      ; DatDrvFallTypi
 0C2B  09		      C db    09h      ; DatDrvRiseTypi
 0C2C  0E		      C db    0Eh      ; DatSlwFallTypi
 0C2D  08		      C db    08h      ; DatSlwRiseTypi
			      C 
 0C2E  09		      C db    09h      ; DqsDrvFallTypi
 0C2F  09		      C db    09h      ; DqsDrvRiseTypi
 0C30  0E		      C db    0Eh      ; DqsSlwFallTypi
 0C31  08		      C db    08h      ; DqsSlwRiseTypi
			      C 
			      C IFDEF SYS_DVT6
			      C ELSE
 0C32  00		      C db    00h      ; DataInbDelyTypi
 0C33  02		      C db    02h      ; ClkIcDelyTypi
 0C34  01		      C db    01h      ; DqsInbDelyTypi
			      C ENDIF
			      C ;
			      C ; Samsung Average SLOW values
			      C ;
 0C35  0A		      C db    0Ah      ; AdrDrvFallSlowAvg
 0C36  0B		      C db    0Bh      ; AdrDrvRiseSlowAvg
 0C37  0E		      C db    0Eh      ; AdrSlwFallSlowAvg
 0C38  08		      C db    08h      ; AdrSlwRiseSlowAvg
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 23 - 1


			      C 
 0C39  0F		      C db    0Fh      ; ClkDrvFallSlowAvg
 0C3A  0F		      C db    0Fh      ; ClkDrvRiseSlowAvg
 0C3B  0F		      C db    0Fh      ; ClkSlwFallSlowAvg
 0C3C  0F		      C db    0Fh      ; ClkSlwRiseSlowAvg
			      C 
 0C3D  0A		      C db    0Ah      ; DatDrvFallSlowAvg
 0C3E  0B		      C db    0Bh      ; DatDrvRiseSlowAvg
 0C3F  0E		      C db    0Eh      ; DatSlwFallSlowAvg
 0C40  08		      C db    08h      ; DatSlwRiseSlowAvg
			      C 
 0C41  0A		      C db    0Ah      ; DqsDrvFallSlowAvg
 0C42  0B		      C db    0Bh      ; DqsDrvRiseSlowAvg
 0C43  0E		      C db    0Eh      ; DqsSlwFallSlowAvg
 0C44  08		      C db    08h      ; DqsSlwRiseSlowAvg
			      C 
			      C IFDEF SYS_DVT6
			      C ELSE
 0C45  00		      C db    00h      ; DataInbDelySlowAvg
 0C46  02		      C db    02h      ; ClkIcDelySlowAvg
 0C47  01		      C db    01h      ; DqsInbDelySlowAvg
			      C ENDIF
			      C ;
			      C ; Samsung Extreme SLOW values
			      C ;
 0C48  0B		      C db    0Bh      ; AdrDrvFallSlowExt
 0C49  0E		      C db    0Eh      ; AdrDrvRiseSlowExt
 0C4A  0E		      C db    0Eh      ; AdrSlwFallSlowExt
 0C4B  08		      C db    08h      ; AdrSlwRiseSlowExt
			      C 
 0C4C  0F		      C db    0Fh      ; ClkDrvFallSlowExt
 0C4D  0F		      C db    0Fh      ; ClkDrvRiseSlowExt
 0C4E  0F		      C db    0Fh      ; ClkSlwFallSlowExt
 0C4F  0F		      C db    0Fh      ; ClkSlwRiseSlowExt
			      C 
 0C50  0B		      C db    0Bh      ; DatDrvFallSlowExt
 0C51  0E		      C db    0Eh      ; DatDrvRiseSlowExt
 0C52  0E		      C db    0Eh      ; DatSlwFallSlowExt
 0C53  08		      C db    08h      ; DatSlwRiseSlowExt
			      C 
 0C54  0B		      C db    0Bh      ; DqsDrvFallSlowExt
 0C55  0E		      C db    0Eh      ; DqsDrvRiseSlowExt
 0C56  0E		      C db    0Eh      ; DqsSlwFallSlowExt
 0C57  08		      C db    08h      ; DqsSlwRiseSlowExt
			      C 
			      C IFDEF SYS_DVT6
			      C ELSE
 0C58  00		      C db    00h      ; DataInbDelySlowExt
 0C59  03		      C db    03h      ; ClkIcDelySlowExt
 0C5A  01		      C db    01h      ; DqsInbDelySlowExt
			      C ENDIF
			      C ;-----------------------------------------------------------------------------
			      C ;
			      C ; Micron Extreme FAST values
			      C ;
 0C5B  08		      C db    08h      ; AdrDrvFallFastExt
 0C5C  08		      C db    08h      ; AdrDrvRiseFastExt
 0C5D  0E		      C db    0Eh      ; AdrSlwFallFastExt
 0C5E  08		      C db    08h      ; AdrSlwRiseFastExt
			      C 
 0C5F  0F		      C db    0Fh      ; ClkDrvFallFastExt
 0C60  0F		      C db    0Fh      ; ClkDrvRiseFastExt
 0C61  0F		      C db    0Fh      ; ClkSlwFallFastExt
 0C62  0F		      C db    0Fh      ; ClkSlwRiseFastExt
			      C 
 0C63  09		      C db    09h      ; DatDrvFallFastExt
 0C64  09		      C db    09h      ; DatDrvRiseFastExt
 0C65  0E		      C db    0Eh      ; DatSlwFallFastExt
 0C66  08		      C db    08h      ; DatSlwRiseFastExt
			      C 
 0C67  09		      C db    09h      ; DqsDrvFallFastExt
 0C68  09		      C db    09h      ; DqsDrvRiseFastExt
 0C69  0E		      C db    0Eh      ; DqsSlwFallFastExt
 0C6A  08		      C db    08h      ; DqsSlwRiseFastExt
			      C 
 0C6B  00		      C db    00h      ; DataInbDelyFastExt
 0C6C  01		      C db    01h      ; ClkIcDelyFastExt
 0C6D  01		      C db    01h      ; DqsInbDelyFastExt
			      C ;
			      C ; Micron Average FAST values
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 24 - 1


			      C ;
 0C6E  08		      C db    08h      ; AdrDrvFallFastAvg
 0C6F  08		      C db    08h      ; AdrDrvRiseFastAvg
 0C70  0E		      C db    0Eh      ; AdrSlwFallFastAvg
 0C71  08		      C db    08h      ; AdrSlwRiseFastAvg
			      C 
 0C72  0F		      C db    0Fh      ; ClkDrvFallFastAvg
 0C73  0F		      C db    0Fh      ; ClkDrvRiseFastAvg
 0C74  0F		      C db    0Fh      ; ClkSlwFallFastAvg
 0C75  0F		      C db    0Fh      ; ClkSlwRiseFastAvg
			      C 
 0C76  09		      C db    09h      ; DatDrvFallFastAvg
 0C77  09		      C db    09h      ; DatDrvRiseFastAvg
 0C78  0E		      C db    0Eh      ; DatSlwFallFastAvg
 0C79  08		      C db    08h      ; DatSlwRiseFastAvg
			      C 
 0C7A  09		      C db    09h      ; DqsDrvFallFastAvg
 0C7B  09		      C db    09h      ; DqsDrvRiseFastAvg
 0C7C  0E		      C db    0Eh      ; DqsSlwFallFastAvg
 0C7D  08		      C db    08h      ; DqsSlwRiseFastAvg
			      C 
 0C7E  00		      C db    00h      ; DataInbDelyFastAvg
 0C7F  01		      C db    01h      ; ClkIcDelyFastAvg
 0C80  01		      C db    01h      ; DqsInbDelyFastAvg 
			      C ;
			      C ; Micron Typical values
			      C ;
 0C81  08		      C db    08h      ; AdrDrvFallTypi
 0C82  08		      C db    08h      ; AdrDrvRiseTypi
 0C83  0E		      C db    0Eh      ; AdrSlwFallTypi
 0C84  08		      C db    08h      ; AdrSlwRiseTypi
			      C 
 0C85  0F		      C db    0Fh      ; ClkDrvFallTypi
 0C86  0F		      C db    0Fh      ; ClkDrvRiseTypi
 0C87  0F		      C db    0Fh      ; ClkSlwFallTypi
 0C88  0F		      C db    0Fh      ; ClkSlwRiseTypi
			      C 
 0C89  09		      C db    09h      ; DatDrvFallTypi
 0C8A  09		      C db    09h      ; DatDrvRiseTypi
 0C8B  0E		      C db    0Eh      ; DatSlwFallTypi
 0C8C  08		      C db    08h      ; DatSlwRiseTypi
			      C 
 0C8D  09		      C db    09h      ; DqsDrvFallTypi
 0C8E  09		      C db    09h      ; DqsDrvRiseTypi
 0C8F  0E		      C db    0Eh      ; DqsSlwFallTypi
 0C90  08		      C db    08h      ; DqsSlwRiseTypi
			      C 
 0C91  00		      C db    00h      ; DataInbDelyTypi
 0C92  01		      C db    01h      ; ClkIcDelyTypi
 0C93  01		      C db    01h      ; DqsInbDelyTypi
			      C ;
			      C ; Micron Average SLOW values
			      C ;
 0C94  08		      C db    08h      ; AdrDrvFallSlowAvg
 0C95  08		      C db    08h      ; AdrDrvRiseSlowAvg
 0C96  0E		      C db    0Eh      ; AdrSlwFallSlowAvg
 0C97  08		      C db    08h      ; AdrSlwRiseSlowAvg
			      C 
 0C98  0F		      C db    0Fh      ; ClkDrvFallSlowAvg
 0C99  0F		      C db    0Fh      ; ClkDrvRiseSlowAvg
 0C9A  0F		      C db    0Fh      ; ClkSlwFallSlowAvg
 0C9B  0F		      C db    0Fh      ; ClkSlwRiseSlowAvg
			      C 
 0C9C  0A		      C db    0Ah      ; DatDrvFallSlowAvg
 0C9D  0B		      C db    0Bh      ; DatDrvRiseSlowAvg
 0C9E  0E		      C db    0Eh      ; DatSlwFallSlowAvg
 0C9F  08		      C db    08h      ; DatSlwRiseSlowAvg
			      C 
 0CA0  0A		      C db    0Ah      ; DqsDrvFallSlowAvg
 0CA1  0B		      C db    0Bh      ; DqsDrvRiseSlowAvg
 0CA2  0E		      C db    0Eh      ; DqsSlwFallSlowAvg
 0CA3  08		      C db    08h      ; DqsSlwRiseSlowAvg
			      C 
 0CA4  00		      C db    00h      ; DataInbDelySlowAvg
 0CA5  01		      C db    01h      ; ClkIcDelySlowAvg
 0CA6  01		      C db    01h      ; DqsInbDelySlowAvg
			      C ;
			      C ; Micron Extreme SLOW values
			      C ;
 0CA7  08		      C db    08h      ; AdrDrvFallSlowExt
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Page 25 - 1


 0CA8  08		      C db    08h      ; AdrDrvRiseSlowExt
 0CA9  0E		      C db    0Eh      ; AdrSlwFallSlowExt
 0CAA  08		      C db    08h      ; AdrSlwRiseSlowExt
			      C 
 0CAB  0F		      C db    0Fh      ; ClkDrvFallSlowExt
 0CAC  0F		      C db    0Fh      ; ClkDrvRiseSlowExt
 0CAD  0F		      C db    0Fh      ; ClkSlwFallSlowExt
 0CAE  0F		      C db    0Fh      ; ClkSlwRiseSlowExt
			      C 
 0CAF  0B		      C db    0Bh      ; DatDrvFallSlowExt
 0CB0  0E		      C db    0Eh      ; DatDrvRiseSlowExt
 0CB1  0E		      C db    0Eh      ; DatSlwFallSlowExt
 0CB2  08		      C db    08h      ; DatSlwRiseSlowExt
			      C 
 0CB3  0B		      C db    0Bh      ; DqsDrvFallSlowExt
 0CB4  0E		      C db    0Eh      ; DqsDrvRiseSlowExt
 0CB5  0E		      C db    0Eh      ; DqsSlwFallSlowExt
 0CB6  08		      C db    08h      ; DqsSlwRiseSlowExt
			      C 
 0CB7  00		      C db    00h      ; DataInbDelySlowExt
 0CB8  01		      C db    01h      ; ClkIcDelySlowExt
 0CB9  01		      C db    01h      ; DqsInbDelySlowExt
			      C 
 0CBA			      C DrvSlwParamEnd:
			      C 
 0CBA  43 6F 70 79 72 69      C DB   'Copyright (c) Microsoft Corporation. All rights reserved.'
       67 68 74 20 28 63
       29 20 4D 69 63 72
       6F 73 6F 66 74 20
       43 6F 72 70 6F 72
       61 74 69 6F 6E 2E
       20 41 6C 6C 20 72
       69 67 68 74 73 20
       72 65 73 65 72 76
       65 64 2E
			      C 
			      C 
 0CF3			      C CODE ENDS
			      C 
			      C 

				        END

Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Symbols 26 - 1




Structures and Unions:

                N a m e                  Size
                                         Offset      Type

nv_command_struct  . . . . . . .	 0009
  nv_command . . . . . . . . . .	 0000	     Byte
  nv_address . . . . . . . . . .	 0001	     DWord
  nv_data  . . . . . . . . . . .	 0005	     DWord
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Symbols 27 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

CODE . . . . . . . . . . . . . .	16 Bit	 0CF3	  Para	  Public  'CODE'	
DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'CODE'	
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Symbols 28 - 1




Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0001h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0003h	 
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
APERTURE_BASE  . . . . . . . . .	Number	 40000000h   
COMMAND_COMPARE_RESULT_JNE . . .	Number	 0004h	 
COMMAND_IN_BYTE  . . . . . . . .	Number	 00C8h	 
COMMAND_JMP  . . . . . . . . . .	Number	 0025h	 
COMMAND_OUT_BYTE . . . . . . . .	Number	 003Ch	 
COMMAND_PCI_CFG_READ . . . . . .	Number	 00F5h	 
COMMAND_PCI_CFG_WRITE  . . . . .	Number	 00F9h	 
COMMAND_QUIT . . . . . . . . . .	Number	 00BFh	 
COMMAND_READ_MEM . . . . . . . .	Number	 009Ah	 
COMMAND_RESERVED . . . . . . . .	Number	 00E7h	 
COMMAND_RMW_ACCUM  . . . . . . .	Number	 006Ch	 
COMMAND_RMW_RESULT . . . . . . .	Number	 00EDh	 
COMMAND_USE_RESULT_AS_DATA . . .	Number	 0068h	 
COMMAND_WRITE_MEM  . . . . . . .	Number	 005Bh	 
CR_APC_P2P_19_NV20_ENABLE  . . .	Number	 0001h	 
CR_APC_P2P_19  . . . . . . . . .	Number	 8000F04Ch   
CR_APC_P2P_1_BUS_MSTR_MEM_IO . .	Number	 0007h	 
CR_APC_P2P_1 . . . . . . . . . .	Number	 8000F004h   
CR_APC_P2P_6_SUB_SEC_PRI_BUS . .	Number	 00010100h   
CR_APC_P2P_6 . . . . . . . . . .	Number	 8000F018h   
CR_APC_P2P_8_MLIMIT_MBASE_INIT .	Number	 0FF00F00h   
CR_APC_P2P_8_MLIMIT_MBASE_KERNEL .	Number	 FDF0FD00h   
CR_APC_P2P_8 . . . . . . . . . .	Number	 8000F020h   
CR_APC_P2P_9_PREF_MLIMIT_MBASE .	Number	 F7F0F000h   
CR_APC_P2P_9 . . . . . . . . . .	Number	 8000F024h   
CR_CPU_CST_0 . . . . . . . . . .	Number	 80000340h   
CR_CPU_CST_1 . . . . . . . . . .	Number	 80000344h   
CR_CPU_CST_7 . . . . . . . . . .	Number	 8000035Ch   
CR_CPU_MEMTOP_LIMIT_128MB  . . .	Number	 07FFFFFFh   
CR_CPU_MEMTOP_LIMIT_64MB . . . .	Number	 03FFFFFFh   
CR_CPU_MEMTOP  . . . . . . . . .	Number	 80000084h   
CR_CPU_MPLL_COEFF  . . . . . . .	Number	 8000036Ch   
CR_NV20_PCI_1_BUS_MSTR_MEM_IO  .	Number	 0007h	 
CR_NV20_PCI_1  . . . . . . . . .	Number	 80010004h   
CR_NV20_PCI_4  . . . . . . . . .	Number	 80010010h   
CR_NV20_PCI_5  . . . . . . . . .	Number	 80010014h   
DATATBL_BASE_OFFSET  . . . . . .	Number	 0BF0h	 
DESIRED_SMC_VER  . . . . . . . .	Number	 0050h	 
DEVKIT . . . . . . . . . . . . .	Text   	 
DONT_CARE  . . . . . . . . . . .	Number	 0000h	 
DelayJump1 . . . . . . . . . . .	L Near	 05C6	  CODE	
DelayJump2 . . . . . . . . . . .	L Near	 05CF	  CODE	
DrvSlwParamBegin . . . . . . . .	L Near	 0BF0	  CODE	
DrvSlwParamEnd . . . . . . . . .	L Near	 0CBA	  CODE	
MCP_LEG_CFG_19 . . . . . . . . .	Number	 8000084Ch   
MCP_LEG_CFG_1  . . . . . . . . .	Number	 80000804h   
MCP_LEG_CFG_24 . . . . . . . . .	Number	 80000860h   
MCP_LEG_CFG_2  . . . . . . . . .	Number	 80000808h   
MCP_LEG_CFG_39 . . . . . . . . .	Number	 8000089Ch   
MCP_LEG_CFG_45 . . . . . . . . .	Number	 800008B4h   
MCP_LEG_CFG_4  . . . . . . . . .	Number	 80000810h   
MCP_SMB_CFG_1_IO_SPACE . . . . .	Number	 0001h	 
MCP_SMB_CFG_1  . . . . . . . . .	Number	 80000904h   
MCP_SMB_CFG_5_IO_BASE  . . . . .	Number	 C001h	 
MCP_SMB_CFG_5  . . . . . . . . .	Number	 80000914h   
MCP_SMB_CFG_6_IO_BASE  . . . . .	Number	 C201h	 
MCP_SMB_CFG_6  . . . . . . . . .	Number	 80000918h   
MCP_USBA_CFG_15  . . . . . . . .	Number	 8000103Ch   
MCP_USBB_CFG_15  . . . . . . . .	Number	 8000183Ch   
MCP_XMODE2 . . . . . . . . . . .	Number	 0001h	 
MEMTEST_PATTERN1 . . . . . . . .	Number	 AAAAAAAAh   
MEMTEST_PATTERN2 . . . . . . . .	Number	 5A5A5A5Ah   
MEMTEST_PATTERN3 . . . . . . . .	Number	 55555555h   
MEMTEST_PATTERN4 . . . . . . . .	Number	 CCCCCCCCh   
MEMTEST_RESULT . . . . . . . . .	Number	 8000183Ch   
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Symbols 29 - 1




Symbols:

                N a m e                 Type     Value    Attr

MEMTEST_TYPE . . . . . . . . . .	Number	 8000103Ch   
MEM_PART_0 . . . . . . . . . . .	Number	 0000h	 
MEM_PART_1 . . . . . . . . . . .	Number	 0010h	 
MEM_PART_2 . . . . . . . . . . .	Number	 0020h	 
MEM_PART_3 . . . . . . . . . . .	Number	 0030h	 
MEM_PART_4 . . . . . . . . . . .	Number	 04000000h   
MEM_PART_5 . . . . . . . . . . .	Number	 04000010h   
MEM_PART_6 . . . . . . . . . . .	Number	 04000020h   
MEM_PART_7 . . . . . . . . . . .	Number	 04000030h   
NV20_FB_BASE . . . . . . . . . .	Number	 F0000000h   
NV20_REG_BASE_KERNEL . . . . . .	Number	 FD000000h   
NV20_REG_BASE  . . . . . . . . .	Number	 0F000000h   
NV2A_XBOX_ROM_TABLE_PTR  . . . .	Number	 FF000008h   
NV_PBUS_DEBUG_CTRIM_0  . . . . .	Number	 10B0h	 
NV_PBUS_DEBUG_CTRIM_10 . . . . .	Number	 10E8h	 
NV_PBUS_DEBUG_CTRIM_1  . . . . .	Number	 10B4h	 
NV_PBUS_DEBUG_CTRIM_2  . . . . .	Number	 10B8h	 
NV_PBUS_DEBUG_CTRIM_3  . . . . .	Number	 10BCh	 
NV_PBUS_DEBUG_CTRIM_4  . . . . .	Number	 10C4h	 
NV_PBUS_DEBUG_CTRIM_5  . . . . .	Number	 10C8h	 
NV_PBUS_DEBUG_CTRIM_6  . . . . .	Number	 10CCh	 
NV_PBUS_DEBUG_CTRIM_7  . . . . .	Number	 10D4h	 
NV_PBUS_DEBUG_CTRIM_8  . . . . .	Number	 10D8h	 
NV_PBUS_DEBUG_CTRIM_9  . . . . .	Number	 10DCh	 
NV_PBUS_DISPIO_PADCTL_INIT . . .	Number	 AA8BAA8Bh   
NV_PBUS_DISPIO_PADCTL  . . . . .	Number	 124Ch	 
NV_PBUS_FBIO_ADRDRV  . . . . . .	Number	 122Ch	 
NV_PBUS_FBIO_ADRSLW_INIT . . . .	Number	 8B8B8B8Bh   
NV_PBUS_FBIO_ADRSLW  . . . . . .	Number	 123Ch	 
NV_PBUS_FBIO_CALEN_OFF . . . . .	Number	 0000h	 
NV_PBUS_FBIO_CALEN . . . . . . .	Number	 1220h	 
NV_PBUS_FBIO_CALSEL_VALUE  . . .	Number	 0000h	 
NV_PBUS_FBIO_CALSEL  . . . . . .	Number	 1228h	 
NV_PBUS_FBIO_CFG . . . . . . . .	Number	 1210h	 
NV_PBUS_FBIO_CLKDRV  . . . . . .	Number	 1230h	 
NV_PBUS_FBIO_CLKSLW  . . . . . .	Number	 1240h	 
NV_PBUS_FBIO_DATDRV_INIT . . . .	Number	 AAAAAAAAh   
NV_PBUS_FBIO_DATDRV  . . . . . .	Number	 1234h	 
NV_PBUS_FBIO_DATSLW_INIT . . . .	Number	 8B8B8B8Bh   
NV_PBUS_FBIO_DATSLW  . . . . . .	Number	 1244h	 
NV_PBUS_FBIO_DLY . . . . . . . .	Number	 1214h	 
NV_PBUS_FBIO_DQSDRV_INIT . . . .	Number	 AAAAAAAAh   
NV_PBUS_FBIO_DQSDRV  . . . . . .	Number	 1238h	 
NV_PBUS_FBIO_DQSSLW_INIT . . . .	Number	 8B8B8B8Bh   
NV_PBUS_FBIO_DQSSLW  . . . . . .	Number	 1248h	 
NV_PBUS_FBIO_RAM . . . . . . . .	Number	 1218h	 
NV_PBUS_TVDIO_CALEN_OFF  . . . .	Number	 0000h	 
NV_PBUS_TVDIO_CALEN  . . . . . .	Number	 1264h	 
NV_PBUS_TVDIO_PADCTL_INIT  . . .	Number	 AA8Bh	 
NV_PBUS_TVDIO_PADCTL . . . . . .	Number	 1250h	 
NV_PEXTDEV_BOOT_0  . . . . . . .	Number	 00101000h   
NV_PFB_ARB_DIFF_BANK . . . . . .	Number	 00100338h   
NV_PFB_ARB_PREDIVIDER  . . . . .	Number	 00100328h   
NV_PFB_ARB_TIMEOUT . . . . . . .	Number	 0010032Ch   
NV_PFB_ARB_XFER_SZ . . . . . . .	Number	 00100330h   
NV_PFB_BYPASS_VALUE  . . . . . .	Number	 F1780031h   
NV_PFB_BYPASS  . . . . . . . . .	Number	 00100424h   
NV_PFB_CFG0  . . . . . . . . . .	Number	 00100200h   
NV_PFB_CFG1  . . . . . . . . . .	Number	 00100204h   
NV_PFB_CPU_RRQ_FWP_LAT_ENABLE  .	Number	 0401h	 
NV_PFB_CPU_RRQ . . . . . . . . .	Number	 00100420h   
NV_PFB_EMRS_EXT  . . . . . . . .	Number	 001002CCh   
NV_PFB_EMRS  . . . . . . . . . .	Number	 001002C4h   
NV_PFB_MRS_DLL_RESET . . . . . .	Number	 0132h	 
NV_PFB_MRS_EXT_DLL_RESET . . . .	Number	 0132h	 
NV_PFB_MRS_EXT . . . . . . . . .	Number	 001002C8h   
NV_PFB_MRS . . . . . . . . . . .	Number	 001002C0h   
NV_PFB_PRE_CMD_PRECHARGE_1 . . .	Number	 0001h	 
NV_PFB_PRE . . . . . . . . . . .	Number	 001002D4h   
NV_PFB_REFCTRL_VALID_1 . . . . .	Number	 -80000000h   
NV_PFB_REFCTRL . . . . . . . . .	Number	 00100210h   
NV_PFB_REF . . . . . . . . . . .	Number	 001002D0h   
NV_PFB_TIMING2 . . . . . . . . .	Number	 00100228h   
NV_PFB_WBC . . . . . . . . . . .	Number	 00100410h   
Microsoft (R) Macro Assembler Version 6.15.8803		    05/05/02 19:28:46
..\i386\inittbl.asm					     Symbols 30 - 1




Symbols:

                N a m e                 Type     Value    Attr

NV_PGRAPH_DEBUG_10_ROP_BLEND . .	Number	 0003h	 
NV_PGRAPH_DEBUG_10 . . . . . . .	Number	 00400B88h   
NV_PGRAPH_DEBUG_2_VALUE  . . . .	Number	 002EC3FFh   
NV_PGRAPH_DEBUG_2  . . . . . . .	Number	 00400880h   
NV_PMC_BOOT_0  . . . . . . . . .	Number	 0000h	 
NV_PRAMDAC_NVPLL_COEFF . . . . .	Number	 00680500h   
NV_PRAMDAC_PLL_COEFF_SELECT  . .	Number	 0068050Ch   
SMB_CONTROL_BASE . . . . . . . .	Number	 C000h	 
SMB_DDC_SPIO_BASE  . . . . . . .	Number	 C200h	 
SYS_DVT4 . . . . . . . . . . . .	Text   	 1
dram0_4mb  . . . . . . . . . . .	L Near	 0629	  CODE	
dram0_alt_write  . . . . . . . .	L Near	 0644	  CODE	
dram0_err  . . . . . . . . . . .	L Near	 0668	  CODE	
dram0  . . . . . . . . . . . . .	L Near	 05F3	  CODE	
dram1_4mb  . . . . . . . . . . .	L Near	 06B9	  CODE	
dram1_alt_write  . . . . . . . .	L Near	 06D4	  CODE	
dram1_err  . . . . . . . . . . .	L Near	 06F8	  CODE	
dram1  . . . . . . . . . . . . .	L Near	 0683	  CODE	
dram2_4mb  . . . . . . . . . . .	L Near	 0749	  CODE	
dram2_alt_write  . . . . . . . .	L Near	 0764	  CODE	
dram2_err  . . . . . . . . . . .	L Near	 0788	  CODE	
dram2  . . . . . . . . . . . . .	L Near	 0713	  CODE	
dram3_4mb  . . . . . . . . . . .	L Near	 07D9	  CODE	
dram3_alt_write  . . . . . . . .	L Near	 07F4	  CODE	
dram3_err  . . . . . . . . . . .	L Near	 0818	  CODE	
dram3  . . . . . . . . . . . . .	L Near	 07A3	  CODE	
dram4_4mb  . . . . . . . . . . .	L Near	 0869	  CODE	
dram4_alt_write  . . . . . . . .	L Near	 0884	  CODE	
dram4_err  . . . . . . . . . . .	L Near	 08A8	  CODE	
dram4  . . . . . . . . . . . . .	L Near	 0833	  CODE	
dram5_4mb  . . . . . . . . . . .	L Near	 08F9	  CODE	
dram5_alt_write  . . . . . . . .	L Near	 0914	  CODE	
dram5_err  . . . . . . . . . . .	L Near	 0938	  CODE	
dram5  . . . . . . . . . . . . .	L Near	 08C3	  CODE	
dram6_4mb  . . . . . . . . . . .	L Near	 0989	  CODE	
dram6_alt_write  . . . . . . . .	L Near	 09A4	  CODE	
dram6_err  . . . . . . . . . . .	L Near	 09C8	  CODE	
dram6  . . . . . . . . . . . . .	L Near	 0953	  CODE	
dram7_4mb  . . . . . . . . . . .	L Near	 0A19	  CODE	
dram7_alt_write  . . . . . . . .	L Near	 0A34	  CODE	
dram7_err  . . . . . . . . . . .	L Near	 0A58	  CODE	
dram7  . . . . . . . . . . . . .	L Near	 09E3	  CODE	
dram_4M  . . . . . . . . . . . .	L Near	 0ACD	  CODE	
mclk_133 . . . . . . . . . . . .	L Near	 05AB	  CODE	
mclk_200 . . . . . . . . . . . .	L Near	 05AB	  CODE	
mem_report_end . . . . . . . . .	L Near	 0B6F	  CODE	
mem_report . . . . . . . . . . .	L Near	 0AF1	  CODE	
memory_pad_config  . . . . . . .	L Near	 0455	  CODE	
memtest_done . . . . . . . . . .	L Near	 0A73	  CODE	
nvclk_155  . . . . . . . . . . .	L Near	 03C5	  CODE	
nvclk_200  . . . . . . . . . . .	L Near	 03D7	  CODE	
pbus_ctrim_A1  . . . . . . . . .	L Near	 0119	  CODE	
pbus_ctrim_A2  . . . . . . . . .	L Near	 0146	  CODE	
pbus_ctrim_common  . . . . . . .	L Near	 016A	  CODE	
pll_select . . . . . . . . . . .	L Near	 03E0	  CODE	
samsung_memory . . . . . . . . .	L Near	 0443	  CODE	
skip_strap_override  . . . . . .	L Near	 0203	  CODE	

	   0 Warnings
	   0 Errors
