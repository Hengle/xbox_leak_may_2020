//
// Common Linker Tool
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "toollink.h"	// our local header file
#include "toollib.h"

IMPLEMENT_DYNAMIC(CLinkerTool, CSchmoozeTool)
IMPLEMENT_DYNAMIC(CLinkerNTTool, CLinkerTool)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern BOOL g_bSlowLinks;

///////////////////////////////////////////////////////////////////////////////
// Return the list of files generated by the linker tool
BOOL CLinkerTool::GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC)
{
	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
		CProjItem * pItem = pAction->m_pItem;

		// this is kinda gross but we need to know what props to use
		// and I don't want to duplicate this code in the derived CLibTool
		// [matthewt]
		BOOL fIsLibTool = IsKindOf(RUNTIME_CLASS(CLibTool));

		// Remember that for a newly created project, the file path is
		// suposed to be NULL:
		CPath pathName;
		CString strName;
		int bPropSet;
		
		CDir * pDir = &pItem->GetProject()->GetWorkspaceDir();


		// do we want the primary output?
		if (type & AOGO_Primary)
		{
			// name of .exe/.dll/.lib
			if (pItem->GetStrProp(MapLogical(fIsLibTool ? P_OutNameLib : P_OutName), strName) != valid)
				strName = "";	// failed to get prop, no output name

			if (!pathName.CreateFromDirAndFilename(*pDir, strName) ||
				!pAction->AddOutput((const CPath *)&pathName))
				return FALSE; // failure
		}

		// do we want other outputs as well?
		if (type & AOGO_Other)
		{
			// linker output paths
			if (!fIsLibTool)
			{
				// warning: this logic depends of pathName from .exe step
				if (pItem->GetIntProp(MapLogical(P_IncrementalLink), bPropSet) == valid && bPropSet)
				{
					pathName.ChangeExtension(_T("ILK")); // generate .ilk name from .EXE name & path
				    if (!pAction->AddOutput((const CPath *)&pathName, FALSE))	// no action (2ndary file)
						return FALSE; // failure
				}

				// warning: this logic depends of pathName from .exe/.dll step
				int fDll;	// is this generating a dynamic link library?
				if (pItem->GetIntProp(MapLogical(P_GenDll), fDll) == valid && fDll)
				{
					if (pItem->GetStrProp(MapLogical(P_ImpLibName), strName) == valid && (strName.TrimLeft(), !strName.IsEmpty()))
					{
						if (!pathName.CreateFromDirAndFilename(*pDir, strName))
							return FALSE; // failure
					}
					else
					{
						// default is just .dll name
						pathName.ChangeExtension(_T("LIB")); // generate .LIB name from .DLL name
					}

					int fLib;	// does this dll have an export lib ?
					if( pItem->GetIntProp(MapLogical(P_IgnoreExportLib), fLib) == valid && !fLib ){
						if (!pAction->AddOutput((const CPath *)&pathName, FALSE))	// no action (2ndary file)
							return FALSE; // failure
					}

					// also generate .exp name with same name as .lib
					pathName.ChangeExtension(_T("EXP"));

				    if (!pAction->AddOutput((const CPath *)&pathName, FALSE))	// no action (2ndary file)
						return FALSE; // failure
				}

				// name of .pdb file is only an output if /debug
				if (pItem->GetIntProp(MapLogical(P_GenDebug), bPropSet) == valid && bPropSet)
				{
					if (pItem->GetIntProp(MapLogical(P_UsePDB), bPropSet) == valid && bPropSet)
					{
						VERIFY(pItem->GetStrProp(MapLogical(P_UsePDBName), strName));
						if (!pathName.CreateFromDirAndFilename(*pDir, strName) ||
							!pAction->AddOutput((const CPath *)&pathName, FALSE))	// no action (2ndary file)
							return FALSE; // failure
					}
				}

				// name of .map file
				if (pItem->GetIntProp(MapLogical(P_GenMap), bPropSet) == valid && bPropSet)
				{
					if ((pItem->GetStrProp(MapLogical(P_MapName), strName) != valid) || (strName.TrimLeft(), strName.IsEmpty())) 
					{
						pathName.ChangeExtension(_T("MAP")); // default
						strName = "";	// failed to get map name, use default
					}
					else if (!pathName.CreateFromDirAndFilename(*pDir, strName))
					{
						return FALSE; // failure
					}

					if (!pAction->AddOutput((const CPath *)&pathName, FALSE))	// no action (2ndary file)
						return FALSE; // failure
				}
			}
		}
	}

	return TRUE; // success
}

///////////////////////////////////////////////////////////////////////////////
// Affects our output?
BOOL CLinkerTool::AffectsOutput(UINT idPropL)
{
	// change our outputs?
	if (
		idPropL == P_GenDll ||			// enables *.dll
		idPropL == P_IncrementalLink ||	// enables *.ilk
		idPropL == P_UsePDB ||			// enables *.pdb
		idPropL == P_GenMap ||			// enables *.map
		idPropL == P_OutName ||			// *.exe, *.dll etc.
		idPropL == P_UsePDBName ||		// *.pdb
		idPropL == P_MapName ||			// *.map
		idPropL == P_DefName ||			// *.def
		idPropL == P_OutNameLib ||		// *.lib
		idPropL == P_DefNameLib	||		// *.def
		idPropL == P_Proj_TargDefExt ||	// target extension
		idPropL == P_IgnoreExportLib 	// enable *.lib if *.dll is enabled
	   )
	{
	   return TRUE;
	}

	return FALSE;
}

CSchmoozeTool::SchmoozeData g_schdataLinker =
{
		    _TEXT ("LINK32"),		 		//pszExeMacro;
		    _TEXT ("LINK32_FLAGS"),  		//pszFlagsMacro;
			_TEXT (""),						//pszSpecialFlags;
		    _TEXT ("LINK32_OBJS"),			//pszConsumeMacro;
			_TEXT ("DEF_FILE"),				//pszSpecialConsume;
		    _TEXT (" $(LINK32)"),			//pszExeMacroEx;
		    _TEXT (" $(LINK32_FLAGS)"),   	//pszFlagsMacroEx;
			_TEXT (""),						//pszSpecialFlagsEx;
		    _TEXT (" $(LINK32_OBJS)"), 		//pszConsumeMacroEx;
			_TEXT (" $(DEF_FILE)"),			//pszSpecialConsumeEx;
		    _TEXT("exe;dll;map"),		//pszProductExtensions;
		    _TEXT("exe;dll;exp;map;lib;ilk;pdb;ocx;pkg"), //pszDelOnRebuildExtensions;
 };

CLinkerTool::CLinkerTool() : CSchmoozeTool()
{
	m_strToolExeName = _TEXT("link.exe");
	m_strToolInput = _TEXT("*.obj;*.res;*.lib;*.def;*.rsc");
	m_strToolPrefix = _TEXT("LINK32");
	m_nOrder = 1;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerTool::IsConsumableFile ( const CPath *pPath )
{
	return FileNameMatchesExtension (pPath, m_strToolInput);
}
///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerTool::IsSpecialConsumable(const CPath * pPath)
{
	return FileNameMatchesExtension (pPath, "def");
}
///////////////////////////////////////////////////////////////////////////////
UINT CLinkerTool::PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
									  DWORD attrib, CErrorContext & EC)
{
	UINT act = ACT_Complete;

	CActionSlob * pAction;
	POSITION pos = lstActions.GetHeadPosition();
	while (pos != (POSITION)NULL && (act == ACT_Complete) /* failure */)
	{
		pAction = (CActionSlob *)lstActions.GetNext(pos);

		// what stage is this?
		switch (stage)
		{
			// pre?
			case TOB_Pre:
			{
				// list of items in project
			   	CObList lstItems;
				pAction->m_pItem->FlattenSubtree(lstItems, 
												 CProjItem::flt_Normal |
				                                 CProjItem::flt_RespectItemExclude |
												 CProjItem::flt_ExcludeGroups |
				                           		 CProjItem::flt_ExcludeDependencies);

				CPath * pPath;
				for (POSITION pos = lstItems.GetHeadPosition(); pos != NULL;)
				{
					pPath = (CPath *)((CProjItem *)lstItems.GetNext(pos))->GetFilePath();
					if (pPath == (CPath *)NULL)	continue;

					// if we are doing this before a build report a warning
					// to the user if we can see that we are overriding
					// the current /DEF: option with a different .DEF file
					if (FileNameMatchesExtension (pPath, "def"))
					{
						CString strDefName;
						if (pAction->m_pItem->GetStrProp(MapLogical(P_DefName), strDefName) == valid &&
							(strDefName.TrimLeft(), !strDefName.IsEmpty()))
						{
							CProject * pProject = pAction->m_pItem->GetProject();
							CPath pathDef;
							if (pProject != (CProject *)NULL &&
								pathDef.CreateFromDirAndFilename(pProject->GetWorkspaceDir(), strDefName) &&
								pathDef != *pPath)
							{
								// ignore problems with .DEF and just show error message?
								if (attrib & AOB_IgnoreErrors)
								{
									// FUTURE: error message in output window
								}
								else
								{
									int iReply = QuestionBox(IDS_MULTIPLE_DEFS, MB_YESNO,
															 (const TCHAR *)*pPath, (const TCHAR *)strDefName);
									if (iReply == IDNO)
										act = ACT_Canceled;	// don't continue with build
								}
							}
						}

						// we can break out of the check
						// only one .DEF in project and no other checks need to be made
						break;
					}
				}

				break;
			}

			// post?
			case TOB_Post:
				break;

			// action?
			case TOB_Stage:
				break;

			default:
				break;
		}
	}

	if (act != ACT_Complete)
		return act;

	return CBuildTool::PerformBuildActions(type, stage, lstActions, attrib, EC);
}

BOOL CLinkerTool::GetCommandLines
(
	CActionSlobList & lstActions,
	CPtrList & plCommandLines,
	DWORD attrib,
	CErrorContext & EC
)
{
	CString strDescription;
	// this is kinda gross but we need to know what props to use
	// and I don't want to duplicate this code in the derived CLibTool
	// [matthewt]
	BOOL fIsLibTool = IsKindOf(RUNTIME_CLASS(CLibTool));
	if (fIsLibTool)
	{
		VERIFY(strDescription.LoadString(IDS_DESC_LIBING));
	}
	else
	{
		if (IsIncrementalLink())
			VERIFY(strDescription.LoadString(IDS_DESC_INCR_LINKING));
		else
			VERIFY(strDescription.LoadString(IDS_DESC_LINKING));
	}

	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
 		CProjItem * pItem = pAction->Item();

		// project directory of this item
		CDir * pProjDir = &pItem->GetProject()->GetWorkspaceDir();

		// generate tool options
		CString strCmdLine;
		if (!pAction->GetCommandOptions(strCmdLine))
			return FALSE;

		ReplaceEnvVars(strCmdLine);

		// add our inputs to the command-line
		CFileRegSet * pset = (CFileRegSet *)pAction->GetInput();
		ASSERT(pset->IsKindOf(RUNTIME_CLASS(CFileRegSet)));

		FileRegHandle frhInput;
		pset->InitFrhEnum();
		CString strInput;
		while ((frhInput = pset->NextFrh()) != (FileRegHandle)NULL)
		{
			const CPath * pPath = pAction->m_pregistry->GetRegEntry(frhInput)->GetFilePath();

			// ignore .def file, this is placed as /DEF: on the cmdline
			if (_tcsicmp(pPath->GetExtension(), _TEXT(".def")) == 0)
#ifndef REFCOUNT_WORK
				continue;
#else
			{
				frhInput->ReleaseFRHRef();
				continue;
			}
#endif

			// quote this input and make relative to project directory?
			pPath->GetRelativeName(*pProjDir, strInput, TRUE, FALSE);
			// If GetRelativeName failed, it's probably because the two
			// paths are on different drives, so we just can't make a 
			// relative path.  In this case, however, pPath must contain
			// at least a drive letter (and will probably be a full path)
			// Even if relativization fails, the string will still be quoted

			strCmdLine += _T('\n');
			strCmdLine += strInput;
#ifdef REFCOUNT_WORK
			frhInput->ReleaseFRHRef();
#endif
		}
		strCmdLine += _T('\n');

		// may create a tmp. file if cmdline too long
		if (!g_buildengine.FormCmdLine(m_strToolExeName, strCmdLine, EC))
			return FALSE;	// error

		CCmdLine *pCmdLine = new CCmdLine;
		pCmdLine->slCommandLines.AddHead(strCmdLine);

		// our description
		pCmdLine->slDescriptions.AddHead(strDescription);
		pCmdLine->nProcessor = 1;
		if( (g_bSlowLinks && fIsLibTool) || (g_bSlowLinks==2)  )
			pCmdLine->bDelay = TRUE;

		plCommandLines.AddTail(pCmdLine);
	}

	return TRUE;	// success
}

void CLinkerTool::GetGenericDescription(CString & strDescription)
{
	if (IsIncrementalLink())
		VERIFY(strDescription.LoadString(IDS_DESC_INCR_LINKING));
	else
		VERIFY(strDescription.LoadString(IDS_DESC_LINKING));
}

///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerTool::IsIncrementalLink()
{
	BOOL nVal;

	CPlatform * pPlatform = g_pActiveProject->GetCurrentPlatform();

	// just return false if platform doesn't support incremental link
	if (!(pPlatform->GetAttributes() & PIA_Supports_IncLink))
		return FALSE;

	if (g_pActiveProject->GetIntProp (MapLogical(P_IncrementalLink), nVal) == valid)
		return nVal;

	//FUTURE:
	// there may be a better way to check if we are incrementally linking
	// or not. Right now, we are doing something similar to the one in
	// OPTION_HANDLER(LinkerCommon)::CheckDepOK()
	if ((g_pActiveProject->GetIntProp (MapLogical(P_GenMap), nVal) == valid && nVal) ||
		(g_pActiveProject->GetIntProp (MapLogical(P_UsePDB), nVal) == valid && !nVal)||
		(g_pActiveProject->GetIntProp (MapLogical(P_Profile), nVal) == valid && nVal))
	{
		nVal = FALSE;
	}
	else
	{
		// it's not set so need to use to fake prop:
		if (g_pActiveProject->GetIntProp(MapLogical(P_UseDebugLibs), nVal) != valid)
			nVal = FALSE;
	}

	return nVal;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerTool::IsProductFile(const CPath *pPath)
{
	if (FileNameMatchesExtension (pPath, g_schdataLinker.pszProductExtensions))
		return TRUE;

	CString strName;

	if (g_pActiveProject->GetStrProp(MapLogical(P_OutName), strName) == valid)
	{
		CPath OutPath;
		const TCHAR * pExtension;

		if (OutPath.Create(strName))
		{
			pExtension = OutPath.GetExtension();
			if (*pExtension)
			{
				pExtension = _tcsinc ( (TCHAR *) pExtension);
				return FileNameMatchesExtension (pPath, pExtension);
			}
		}
	}

	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerTool::IsDelOnRebuildFile ( const CPath *pPath )
{
	return FileNameMatchesExtension(pPath, g_schdataLinker.pszDelOnRebuildExtensions);
}

///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerNTTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	COptionHandler * pOptionHandler = GetOptionHandler();
	ASSERT(pOptionHandler != (COptionHandler *)NULL);

	CString strLibs; COptionList optlstLibs(_T(' '), FALSE);

	// libraries that are C++ and FORTRAN
	// make sure we add/remove those Core Windows .libs the MFC headers auto-include
	VERIFY(strLibs.LoadString(IDS_WIN32_LIBS_CORE));
	optlstLibs.SetString(strLibs);
	POSITION pos = optlstLibs.GetHeadPosition();
	while (pos != (POSITION)NULL)
		// add these libs if we are not using MFC
 		pOptionHandler->MungeListStrProp(MapLogical(P_LinkUnknownString), optlstLibs.GetNext(pos), iUseMFC == NoUseMFC);	// these libraries are C++ only

	// libraries that are C++ only
	if (g_BldSysIFace.LanguageSupported(CPlusPlus))
	{
		// make sure we add/remove those Windows .libs the MFC headers auto-include
		VERIFY(strLibs.LoadString(IDS_WIN32_LIBS));
		optlstLibs.SetString(strLibs);
		POSITION pos = optlstLibs.GetHeadPosition();
		while (pos != (POSITION)NULL)
			// add these libs if we are not using MFC
 			pOptionHandler->MungeListStrProp(MapLogical(P_LinkUnknownString), optlstLibs.GetNext(pos), iUseMFC == NoUseMFC);

		// make sure we add/remove those Windows OLE2 .libs the MFC headers auto-include
		VERIFY(strLibs.LoadString(IDS_OLE2_LIBS));
		optlstLibs.SetString(strLibs);
		pos = optlstLibs.GetHeadPosition();
		while (pos != (POSITION)NULL)
			// add these libs if we are not using MFC
 			pOptionHandler->MungeListStrProp(MapLogical(P_LinkUnknownString), optlstLibs.GetNext(pos), iUseMFC == NoUseMFC);
 
		// does this target's platform support ODBC?
		CProjType * pProjType = pProjItem->GetProject()->GetProjType();
		ASSERT(pProjType != (CProjType *)NULL);
		BOOL fSupportsODBC = pProjType->GetPlatform()->SupportsODBC();

		// make sure we add/remove those Windows ODBC .libs the MFC headers auto-include
		VERIFY(strLibs.LoadString(IDS_ODBC_LIBS));
		optlstLibs.SetString(strLibs);
		pos = optlstLibs.GetHeadPosition();
		while (pos != (POSITION)NULL)
			// add these libs if we are not using MFC
 			pOptionHandler->MungeListStrProp(MapLogical(P_LinkUnknownString), optlstLibs.GetNext(pos),
 											 iUseMFC == NoUseMFC && fSupportsODBC);
	}

	return CLinkerTool::PerformSettingsWizard(pProjItem, fDebug, iUseMFC);
}
