// DIRSDLG.CPP
// -----------
// Implements the Directories dialog.
//
// History
// =======
// 26-Aug-93	mattg		Created
// 30-Sep-93	marklam		Disabled toolbox opts, changed directory options to a combo.
// 25-Oct-93	marklam		Changed Add edit box to use a dir picker
// 30-Nov-93	karlsi		ADD at the current selection, "undo", and other enhancements
// 14-Jan-94	colint		Added Platform combo-box and reenabled toolsets.

////////////////////////////////////////////////////////////
// Include files

#include "stdafx.h"
#pragma hdrstop
#include "dirsdlg.h"
#include "dirmgr.h"
#include "resource.h"
#include "projcomp.h"
#include <dlgbase.h>
#include <ids.h>

// Convenient way of identifying the directory options selection
#define DIRS_OPTIONS_EXECUTABLE	(0)
#define DIRS_OPTIONS_INCLUDE	(1)
#define DIRS_OPTIONS_LIB		(2)
#define DIRS_OPTIONS_SOURCE     (3)

// the resource string IDs for the directory sets
// N.B. this should match the above order
static UINT rguDirSetText[] = 
{
	IDS_DIRS_EXECUTABLE,
	IDS_DIRS_INCLUDE,
	IDS_DIRS_LIB,
	IDS_DIRS_SOURCE,
};

static UINT rguDirTypes [] =
{
	DIRLIST_PATH,
	DIRLIST_INC,
	DIRLIST_LIB,
	DIRLIST_SOURCE
};

// the resource string IDs for the directory sets for Java
// N.B. this should match the above order
static UINT rguJavaDirSetText[] = 
{
	IDS_DIRS_EXECUTABLE,
	IDS_DIRS_CLASSES,
	IDS_DIRS_SOURCE
};

static UINT rguJavaDirTypes [] =
{
	DIRLIST_PATH,
	DIRLIST_INC,	// CLASSPATH replaces INCLUDE
	DIRLIST_SOURCE
};
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

////////////////////////////////////////////////////////////
// CDirsGrid
CDirsGrid::CDirsGrid()
	: CStringListGridWnd(GRIDLIST_ELLIPSE)
{
}

////////////////////////////////////////////////////////////
// Constructors, destructors

CDirsOptDlg::CDirsOptDlg()
	: CDlgTab(IDDP_OPTIONS_DIRECTORIES, IDS_DIRECTORIES)
{
	m_DirGrid.m_pDlg = this;
	m_pDirs = NULL;
	m_bDeleteDirs = FALSE;
	m_bAlreadyWarnedOfBuild = FALSE;	
	m_nJavaPlatform = -1;

#ifdef _DEBUG
	// shouldn't invoke this dialog with no platform toolsets
	// the dialog is not operational without *at least one* platform
	CDirMgr * pDirMgr = GetDirMgr();
	ASSERT(pDirMgr != (CDirMgr *)NULL);
	ASSERT(pDirMgr->GetNumberOfToolsets() > 0);
#endif
}

CDirsOptDlg::~CDirsOptDlg
(
)
{
	INT			nToolSet, type, nMaxToolsets;
	CObList *	pList;

	CDirMgr * pDirMgr = GetDirMgr();

	if (m_bDeleteDirs)
	{
		nMaxToolsets = pDirMgr->GetNumberOfToolsets();

		for (type=0 ; type<C_DIRLIST_TYPES ; ++type)
		{
			for (nToolSet=0 ; nToolSet<nMaxToolsets; ++nToolSet)
			{
				if ((pList = m_pDirs[nToolSet][(DIRLIST_TYPE)type]) != NULL)
				{
					POSITION	pos = pList->GetHeadPosition();

					while (pos != NULL)
						delete pList->GetNext(pos);

					delete pList;
				}
			}
		}
	}

	delete [] m_pDirs;
}

////////////////////////////////////////////////////////////
// CDirsOptDlg::Activate

BOOL CDirsOptDlg::Activate
(
	CTabbedDialog *	ptd,
	CPoint			cp
)
{
	INT		nToolset, type;
	INT		nMaxToolsets;

	// Set up the arrays of dirlists and clone the existing
	// ones from the CDirMgr object.

	CDirMgr * pDirMgr = GetDirMgr();
	nMaxToolsets = pDirMgr->GetNumberOfToolsets();

	if (!m_bDeleteDirs)		// ignore extra call generated by BrowseDirectories()
	{
		m_pDirs = new CObList* [nMaxToolsets][(int)C_DIRLIST_TYPES];
		
		for (type=0 ; type<C_DIRLIST_TYPES ; ++type)
			for (nToolset=0 ; nToolset<nMaxToolsets ; ++nToolset)
				m_pDirs[nToolset][type] =
				  pDirMgr->CloneDirList((DIRLIST_TYPE)type, nToolset);

		m_bDeleteDirs = TRUE;
	}

	// Make sure that the actual activation occurs!
	return CDlgTab::Activate( ptd, cp );
}


BOOL CDirsOptDlg::ValidateTab()
{
	if (!m_DirGrid.AcceptControl())
	{
 		return FALSE;
	}

	return TRUE;
}

////////////////////////////////////////////////////////////
// CDirsOptDlg::PosFromListboxIndex

POSITION CDirsOptDlg::PosFromListboxIndex
(
	INT	nIndex
)
{
	CObList *	pList;

	pList = m_pDirs[m_nToolset][m_type];

	return pList->FindIndex(nIndex);
}

////////////////////////////////////////////////////////////
// CDirsOptDlg::SetListboxSel

VOID CDirsOptDlg::SetListboxSel
(
	INT		nSel
)
{
	m_DirGrid.SetCurSel(nSel);
}

////////////////////////////////////////////////////////////
// CDirsOptDlg::OnInitDialog

BOOL CDirsOptDlg::OnInitDialog
(
)
{
	INT nSel, nToolset;
	CString strDirsOpt, strToolsetName;
	CComboBox *pDirsOptCombo = (CComboBox *)GetDlgItem(IDC_DIRS_OPTIONS);
	CComboBox *pDirsToolsetCombo = (CComboBox *)GetDlgItem(IDC_DIRS_TOOLSETS);
	CDirMgr * pDirMgr = GetDirMgr();

	m_nToolset = pDirMgr->GetCurrentToolset();

	// Set the platform list type combo.
	INT nMaxToolsets = pDirMgr->GetNumberOfToolsets();
	for (nToolset = 0; nToolset < nMaxToolsets; nToolset++)
	{
		strToolsetName = pDirMgr->GetToolsetName(nToolset);

		// Convert the "Official" platform name to the
		// UI description.
		CPlatform * pPlatform;
		CString strUIName;

		g_prjcompmgr.LookupPlatformByOfficialName(strToolsetName, pPlatform);
		if (pPlatform)
		{
			strUIName = *(pPlatform->GetUIDescription());
			nSel = pDirsToolsetCombo->AddString(strUIName);
			if (pPlatform->GetUniqueId () == java)
				m_nJavaPlatform = nToolset;
		}
	}
	pDirsToolsetCombo->SetCurSel(m_nToolset);

	// Set the directory list type combo.
	m_type = DIRLIST_INC;

	// And the list itself.
	FillOptionsList ();
	pDirsOptCombo->SetCurSel (DIRS_OPTIONS_INCLUDE); // HACK this works because both Java and normal index 2 is include/classes

	// Create the dir grid
	VERIFY(m_DirGrid.ReplaceControl(this,
									IDC_PLACEHOLDER2, IDC_DIRS_LIST,
									WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_TABSTOP,
									WS_EX_CLIENTEDGE, GRIDWND_TB_ALL));

	// Establish the listbox contents.  This will also disable
	// any buttons which depend on a selection in the listbox.
	ResetListbox();

	// Nothing has changed (yet)
	m_bModified = FALSE;
    
    return(TRUE);
}

////////////////////////////////////////////////////////////
// CDirsOptDlg::CheckForBuildAndWarn
void CDirsOptDlg::CheckForBuildAndWarn ()
{
	if (m_bAlreadyWarnedOfBuild) return;
	m_bAlreadyWarnedOfBuild = TRUE;
	// If there is a build in process, then warn the user that changes
	// to the directories will not take effect until the next build:

	if (g_Spawner.SpawnActive ())
	{
		MsgBox ( Information, IDS_DIR_CHANGE_IN_BUILD );
	}
}

////////////////////////////////////////////////////////////
// CDirsOptDlg::FillOptionsList
void CDirsOptDlg::FillOptionsList ()
{
	UINT		iCurSel, iDirOptCounter, iDirOptMax, *pStrId, *pDirListTypes;
	CComboBox	*pDirsOptCombo = (CComboBox *)GetDlgItem(IDC_DIRS_OPTIONS);
	CComboBox	*pDirsToolsetCombo = (CComboBox *)GetDlgItem(IDC_DIRS_TOOLSETS);
	CString		strDirsOpt;

	iCurSel = pDirsOptCombo->GetCurSel ();
	pDirsOptCombo->SetRedraw (FALSE);
	pDirsOptCombo->ResetContent();

	if ((m_nJavaPlatform != -1) && (pDirsToolsetCombo->GetCurSel () == m_nJavaPlatform))
	{
		pStrId = rguJavaDirSetText;
		pDirListTypes = rguJavaDirTypes;
		iDirOptMax = sizeof (rguJavaDirSetText) / sizeof (rguJavaDirSetText [0]);
	}
	else
	{
		pStrId = rguDirSetText;
		pDirListTypes = rguDirTypes;
		iDirOptMax = sizeof (rguDirSetText) / sizeof (rguDirSetText [0]);
	}

	for (iDirOptCounter = 0; iDirOptCounter < iDirOptMax ; iDirOptCounter++)
	{
		strDirsOpt.LoadString(pStrId[iDirOptCounter]);
		INT i = pDirsOptCombo->AddString(strDirsOpt);
		pDirsOptCombo->SetItemData (i, pDirListTypes [iDirOptCounter]);
	}

	pDirsOptCombo->SetRedraw (TRUE);
	
	if (iCurSel == CB_ERR)
		return;

	if (iCurSel < iDirOptMax)
		pDirsOptCombo->SetCurSel (iCurSel);
	else
		pDirsOptCombo->SetCurSel (iDirOptMax - 1);

	OnSelChangeDirOptions ();
}





////////////////////////////////////////////////////////////
// CDirsOptDlg::ResetListbox
void CDirsOptDlg::ResetListbox
(
	BOOL bSetSelection /* = TRUE */
)
{
	POSITION	pos;
	CObList *	pList;

	m_DirGrid.SetRedraw(FALSE);
	m_DirGrid.ResetContent();

	pList = m_pDirs[m_nToolset][m_type];
	pos = pList->GetHeadPosition();

	while (pos != NULL)
		m_DirGrid.AddString((const TCHAR *)*(CDir *)pList->GetNext(pos));

	// Set the current selection in the directories list to
	// be the first one.
	if (bSetSelection)
		m_DirGrid.SetCurSel(0);

	m_DirGrid.SetRedraw(TRUE);
	m_DirGrid.Invalidate(FALSE);
}

////////////////////////////////////////////////////////////
// CDirsOptDlg::CommitTab

void CDirsOptDlg::CommitTab()
{
	if (GetSafeHwnd() == NULL)
		return;

	m_DirGrid.AcceptControl();

	INT		nToolset, type;
	INT		nMaxToolsets;

	// Set up the arrays of dirlists and clone the existing
	// ones from the CDirMgr object.

	CDirMgr * pDirMgr = GetDirMgr();
	nMaxToolsets = pDirMgr->GetNumberOfToolsets();

	for (type=0 ; type<C_DIRLIST_TYPES ; ++type)
		for (nToolset=0 ; nToolset<nMaxToolsets ; ++nToolset)
			pDirMgr->SetDirList((DIRLIST_TYPE)type, nToolset, m_pDirs[nToolset][type]);

	pDirMgr->SetCurrentToolset(m_nToolset);

	m_bDeleteDirs = FALSE;

  	// Send the package notification only if something was tweaked
	if (m_bModified)
		theApp.NotifyPackages (PN_DIRECTORIES_CHANGED);

}

////////////////////////////////////////////////////////////
// Button-clicked handlers

BEGIN_MESSAGE_MAP(CDirsOptDlg, CDlgTab)
	//{{AFX_MSG_MAP(CDirsOptDlg)
	ON_CBN_SELCHANGE(IDC_DIRS_OPTIONS,OnSelChangeDirOptions)
	ON_CBN_SELCHANGE(IDC_DIRS_TOOLSETS, OnSelChangeDirToolset)

	ON_ELLIPSE(IDC_DIRS_LIST, OnBrowse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static BOOL fIgnoreChange = FALSE;

VOID CDirsOptDlg::OnSelChangeDirOptions()
{
	if (!m_DirGrid.AcceptControl())
	{
		// Set focus to the grid		
		m_DirGrid.SetFocus();
		// Restore previous selection 
		
		// jimsc 10-02-96 Removed the following for java classes support
		/*
		UINT nID;
		switch (m_type)
		{
			case DIRLIST_PATH:
				nID = DIRS_OPTIONS_EXECUTABLE;
 				break;

			case DIRLIST_INC:
				nID = DIRS_OPTIONS_INCLUDE;
 				break;

			case DIRLIST_LIB:
				nID = DIRS_OPTIONS_LIB;
 				break;

			case DIRLIST_SOURCE:
				nID = DIRS_OPTIONS_SOURCE;
 				break;

			default:
				ASSERT(FALSE);
		}
		*/
		((CComboBox*)GetDlgItem(IDC_DIRS_OPTIONS))->SetCurSel(m_nCurTypeSel);
        return;
	}
	CComboBox *pCombo = (CComboBox*)GetDlgItem(IDC_DIRS_OPTIONS);
	m_nCurTypeSel = pCombo->GetCurSel ();
	m_type = (DIRLIST_TYPE) pCombo->GetItemData (m_nCurTypeSel);

	// jimsc  10-02-96 Removed the following for java classes support
	/*
	switch ( ((CComboBox*)GetDlgItem(IDC_DIRS_OPTIONS))->GetCurSel() )
	{
		case DIRS_OPTIONS_EXECUTABLE:
			m_type = DIRLIST_PATH;
			break;
		case DIRS_OPTIONS_INCLUDE:
			m_type = DIRLIST_INC;
			break;
		case DIRS_OPTIONS_LIB:
			m_type = DIRLIST_LIB;
			break;
		case DIRS_OPTIONS_SOURCE:
			m_type = DIRLIST_SOURCE;
			break;
		default:
			ASSERT(FALSE);
	}
	*/							  	

 	ResetListbox();
	SetListboxSel(0);

}

VOID CDirsOptDlg::OnSelChangeDirToolset()
{
	CComboBox *	pComboBox;
	pComboBox = (CComboBox *)GetDlgItem(IDC_DIRS_TOOLSETS);

	if (!m_DirGrid.AcceptControl())
	{
		// Set focus to the grid
		m_DirGrid.SetFocus();

		// Restore previous selection
		pComboBox->SetCurSel(m_nToolset);

        return;
	}

	INT		nSel;

	nSel = pComboBox->GetCurSel();
	m_nToolset = nSel;

	FillOptionsList ();
	ResetListbox();
	SetListboxSel(0);
}

BOOL CDirsOptDlg::OnAddDir(int nIndex)
{
	CString strNewEntry;
	CDir dir;

	VERIFY(m_DirGrid.GetText(nIndex, strNewEntry));

	strNewEntry.TrimLeft();
	if (strNewEntry.IsEmpty())
	{
		m_DirGrid.DoDelete();
		return FALSE;
	}

	if (dir.CreateFromString(strNewEntry))
	{
		CString strMsg;
		if (!dir.ExistsOnDisk() && (MsgBox(Question, MsgText(strMsg,
				IDS_DIR_NOT_EXIST,  (const TCHAR *)dir), 
				MB_YESNO | MB_DEFBUTTON2) != IDYES))
		{
			return FALSE;
		}
	}
	else
	{
		MsgBox(Information, IDS_BAD_DIR_SPEC);

		return FALSE;
	}

	// Get the correct list
	CObList* pList = m_pDirs[m_nToolset][m_type];

	// Check that the directory is not already in the list
	BOOL bAlreadyExists = FALSE;
	POSITION pos = pList->GetHeadPosition();
	while (pos != NULL && !bAlreadyExists)
	{
		CDir* pOldDir = (CDir *)pList->GetNext(pos);
		if (*pOldDir == dir)
			bAlreadyExists = TRUE;
	}

	if (!bAlreadyExists)
	{
		// Create an instance of CDir to store in the list
		CDir *pDir = new CDir;
		*pDir = dir;

		// Add it to the tail
		ASSERT(nIndex == (m_DirGrid.GetCount()));
		pList->AddTail(pDir); // Insert at Current Position

		// make sure that absolute path is displayed
		fIgnoreChange = TRUE;
		m_DirGrid.SetRedraw(FALSE);
		m_DirGrid.SetText(nIndex, (const TCHAR *)*pDir);
		m_DirGrid.SetRedraw(TRUE);
		m_DirGrid.Invalidate(FALSE);
		CheckForBuildAndWarn();
        m_bModified = TRUE;
		return TRUE;
	}
	else
	{
		MsgBox(Information, IDS_DUPE_DIR_SPEC);
		return FALSE;
	}
}

BOOL CDirsOptDlg::OnDelDir(int nIndex)
{
	// Get the list of CDirs
	CObList* pList;
	pList = m_pDirs[m_nToolset][m_type];

	// Get the position of this entry
	POSITION pos = PosFromListboxIndex(nIndex);

	// Delete this entry
	ASSERT(pos != NULL);
	delete pList->GetAt(pos);
	pList->RemoveAt(pos);

 	CheckForBuildAndWarn();
    m_bModified = TRUE;
	return TRUE;
}

BOOL CDirsOptDlg::OnMoveDir(int nSrcIndex, int nDestIndex)
{
	// Get the list of CDirs
	CObList* pList;
	pList = m_pDirs[m_nToolset][m_type];

	// Get the current position of this entry
	POSITION pos = PosFromListboxIndex(nSrcIndex);
	ASSERT(pos != NULL);

	// Remove it
	CObject* pOb = pList->GetAt(pos);
	pList->RemoveAt(pos);

	// Get the target position
	pos = PosFromListboxIndex(nDestIndex);

	// and Insert it or Append if last item
	if (pos == (POSITION)NULL)
		pList->AddTail(pOb);
	else
		pList->InsertBefore(pos, pOb);

	CheckForBuildAndWarn();
   	m_bModified = TRUE;
	return TRUE;
}

BOOL CDirsOptDlg::OnChangeDir(int nIndex)
{
	if (fIgnoreChange)
	{
		fIgnoreChange = FALSE;
		return FALSE;
	}

	CString strNewEntry;
	CDir dir;

	VERIFY(m_DirGrid.GetText(nIndex, strNewEntry));

	strNewEntry.TrimLeft();
	if (strNewEntry.IsEmpty())
	{
		m_DirGrid.DoDelete();
       	m_bModified = TRUE;
		return TRUE;
	}

	if (dir.CreateFromString(strNewEntry))
	{
		CString strMsg;
		if (!dir.ExistsOnDisk() && (MsgBox(Question, MsgText(strMsg,
				IDS_DIR_NOT_EXIST,  (const TCHAR *)dir), 
				MB_YESNO | MB_DEFBUTTON2) != IDYES))
		{
			return FALSE;
		}
	}
	else
	{
		MsgBox(Information, IDS_BAD_DIR_SPEC);

		return FALSE;
	}

	// Get the current position of this entry
	POSITION posCurrent = PosFromListboxIndex(nIndex);
	ASSERT(posCurrent != NULL);

	// Get the correct list
	CObList* pList = m_pDirs[m_nToolset][m_type];

	// Check that the directory is not already in the list
	BOOL bAlreadyExists = FALSE;
	POSITION pos = pList->GetHeadPosition();
	while (pos != NULL && !bAlreadyExists)
	{
		// Ignore the current entry during the check
		if (pos == posCurrent)
		{
			pList->GetNext(pos);
			continue;
		}

		CDir* pOldDir = (CDir *)pList->GetNext(pos);

		if (*pOldDir == dir)
			bAlreadyExists = TRUE;
	}

	if (bAlreadyExists)
	{
		MsgBox(Information, IDS_DUPE_DIR_SPEC);
		return FALSE;
	}

	// Get a pointer to the current CDir object
	pos = PosFromListboxIndex(nIndex);
	ASSERT(pos != NULL);
	CDir* pDir = (CDir*) pList->GetAt(pos);

	// And set it to the new text
	*pDir = dir;

	// make sure that absolute path is displayed
	m_DirGrid.SetRedraw(FALSE);
	m_DirGrid.SetText(nIndex, (const TCHAR *)*pDir);
	m_DirGrid.SetRedraw(TRUE);
	m_DirGrid.Invalidate(FALSE);
	CheckForBuildAndWarn();
   	m_bModified = TRUE;
	return TRUE;
}

VOID CDirsOptDlg::OnBrowse()
{
	CDirChooser chooser;
	if (chooser.DoModal() == IDOK)
	{
		CString strDirectory = chooser.GetPathName();
		CEdit* pEdit = (CEdit*)m_DirGrid.GetDlgItem(1);

		ASSERT(pEdit != NULL);
		pEdit->SetWindowText(strDirectory);
		pEdit->SetSel(0, -1);
		pEdit->SetFocus();
	}
}

