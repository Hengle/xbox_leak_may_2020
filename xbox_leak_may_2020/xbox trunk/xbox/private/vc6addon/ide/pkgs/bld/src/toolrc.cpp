//
// Common Resource Compiler Tool
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "toolrc.h"	// our local header file

IMPLEMENT_DYNAMIC(CRCCompilerTool, CBuildTool)
IMPLEMENT_DYNAMIC(CRCCompilerNTTool, CRCCompilerTool)


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static int g_Line;

///////////////////////////////////////////////////////////////////////////////
//
// ----------------------------- CRCCompilerTool ------------------------------
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
CRCCompilerTool::CRCCompilerTool() : CBuildTool()
{
	bForceNoInferenceRule = TRUE;
	
	// tool name
	m_nIDName = IDS_RESCOMPILER32_TOOL;
	m_nIDUIName = IDS_RESCOMPILER32_TOOL_UI;

	// tool exe name and input file set
	m_strToolExeName = _TEXT("rc.exe");
	m_strToolInput = _TEXT("*.rc");
	m_strToolPrefix = _TEXT("RSC");
	m_nOrder = 4;
}	

///////////////////////////////////////////////////////////////////////////////
// Perform build action(s)
UINT CRCCompilerTool::PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
									  DWORD aob, CErrorContext & EC)
{
	UINT act = ACT_Complete;

	// what stage is this?
	switch (stage)
	{
		// pre?
		case TOB_Pre:
			break;

		// post?
		case TOB_Post:
			break;

		// action?
		case TOB_Stage:
			break;

		default:
			break;
	}

	if (act != ACT_Complete)
		return act;

	return CBuildTool::PerformBuildActions(type, stage, lstActions, aob, EC);
}
///////////////////////////////////////////////////////////////////////////////
// Return the list of files generated by the compiler tool
BOOL CRCCompilerTool::GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC)
{
	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
		CProjItem * pItem = pAction->m_pItem;

		CProject *pProject = pItem->GetProject();
		ASSERT (pProject);

		CDir * pDir = &pProject->GetWorkspaceDir();

		COptionHandler * popthdlr = GetOptionHandler();
		ASSERT (popthdlr != (COptionHandler *)NULL);

		popthdlr->SetSlob(pItem);

		const TCHAR * pchExt = *((OPTION_HANDLER(ResCompiler)*)popthdlr)->GetOutputExtension();

	    if (!pAction->AddOutput(MapLogical(P_OutNameRes), pchExt, pDir))
			ASSERT(FALSE);

		popthdlr->ResetSlob();
	}

	return TRUE; // success
}
///////////////////////////////////////////////////////////////////////////////
// Affects our output?
BOOL CRCCompilerTool::AffectsOutput(UINT idPropL)
{
	// change our outputs?
	if (
		idPropL == P_OutNameRes		// *.res
	   )
	{
	   return TRUE;
	}

	return FALSE;
}
///////////////////////////////////////////////////////////////////////////
void CRCCompilerTool::WriteInferenceRuleMacro (CActionSlob * pAction)
{
	ASSERT(g_bExportMakefile);

	TRY
	{
		// get out filelist of .RC files (may be empty)
		CObList filelist;
		pAction->m_pItem->GetProject()->GetResourceFileList(filelist, TRUE);	// only those buildable

		if (filelist.GetCount() >= 1)	// one or more buildable .RC files exist
		{
			g_prjoptengine.SetOptionHandler (GetOptionHandler());
			g_prjoptengine.SetPropertyBag (pAction->m_pItem);

			CString strBuildLine;
			g_prjoptengine.GenerateString (strBuildLine, (OBShowMacro | OBShowDefault | OBShowFake | OBInherit));
			m_pMakWriter->WriteMacro ("RSC_PROJ", strBuildLine);
		}
	}
	CATCH (CException, e)
	{
		return;	// error
	}	
	END_CATCH
}
///////////////////////////////////////////////////////////////////////////////
BOOL CRCCompilerTool::GetCommandLines
(
	CActionSlobList & lstActions,
	CPtrList & plCommandLines,
	DWORD attrib,
	CErrorContext & EC
)
{
	CString strDescription;
	VERIFY(strDescription.LoadString(IDS_DESC_RC_COMPILING));

	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);

		CProjItem * pItem = pAction->m_pItem;
		ActionState as = pAction->m_state;

		CString str;
		if (!pAction->GetCommandOptions(str))
			return FALSE;

		ReplaceEnvVars(str);

		// append the quoted path
		str += _T('\"');
		str += (const TCHAR *)*pItem->GetFilePath();
		str += _T('\"');

		// NO response file support for RC!
		str = m_strToolExeName + _T(' ') + str;
		#ifdef PROJ_LOG
		PBUILD_TRACE ("Creating command line \"%s\" \n",(const TCHAR *)	str );
		#endif


		CCmdLine *pCmdLine = new CCmdLine;

		pCmdLine->nProcessor = 1;
		pCmdLine->slCommandLines.AddHead(str);
		pCmdLine->slDescriptions.AddHead(strDescription);

		if (as == _SrcOutOfDate)
		{
			plCommandLines.AddHead(pCmdLine);
		}
		else
		{
			plCommandLines.AddTail(pCmdLine);
		}

		break;
	}

	return TRUE;
}

BOOL CRCCompilerTool::m_bTokenMapIsInit = FALSE;
CMapStringToPtr CRCCompilerTool::m_mapResTokens(22);

void CRCCompilerTool::InitTokenMap()
{
	if (m_bTokenMapIsInit)
		return;

	ASSERT(m_mapResTokens.IsEmpty());
	m_mapResTokens.InitHashTable(31);	// use prime # about 20% > than size

	m_mapResTokens.SetAt( _T("include"),		(void*) TOKEN_INCLUDE );
	m_mapResTokens.SetAt( _T("bitmap"),			(void*) TOKEN_BITMAP );
	m_mapResTokens.SetAt( _T("cursor"),			(void*) TOKEN_CURSOR );
	m_mapResTokens.SetAt( _T("icon"),			(void*) TOKEN_ICON );
	m_mapResTokens.SetAt( _T("typelib"),		(void*) TOKEN_TYPELIB );
	m_mapResTokens.SetAt( _T("loadoncall"),		(void*) TOKEN_LOADONCALL );
	m_mapResTokens.SetAt( _T("preload"),		(void*) TOKEN_PRELOAD );
	m_mapResTokens.SetAt( _T("fixed"),			(void*) TOKEN_FIXED );
	m_mapResTokens.SetAt( _T("moveable"),		(void*) TOKEN_MOVEABLE );
	m_mapResTokens.SetAt( _T("discardable"),	(void*) TOKEN_DISCARDABLE );
	m_mapResTokens.SetAt( _T("font"),			(void*) TOKEN_FONT );
	m_mapResTokens.SetAt( _T("rcinclude"),		(void*) TOKEN_RCINCLUDE );
	m_mapResTokens.SetAt( _T("pure"),			(void*) TOKEN_PURE );
	m_mapResTokens.SetAt( _T("impure"),			(void*) TOKEN_IMPURE );
	m_mapResTokens.SetAt( _T("accelerators"),	(void*) TOKEN_ACCELERATORS );
	m_mapResTokens.SetAt( _T("dialog"),			(void*) TOKEN_DIALOG );
	m_mapResTokens.SetAt( _T("dlginit"),		(void*) TOKEN_DLGINIT );
	m_mapResTokens.SetAt( _T("menu"),			(void*) TOKEN_MENU );
	m_mapResTokens.SetAt( _T("rcdata"),			(void*) TOKEN_RCDATA );
	m_mapResTokens.SetAt( _T("stringtable"),	(void*) TOKEN_STRINGTABLE );
	m_mapResTokens.SetAt( _T("begin"),			(void*) TOKEN_BEGIN );
	m_mapResTokens.SetAt( _T("end"),			(void*) TOKEN_END );
	m_mapResTokens.SetAt( _T("versioninfo"),	(void*) TOKEN_VERSIONINFO );
	m_mapResTokens.SetAt( _T("error"),			(void*) TOKEN_ERROR );
	m_mapResTokens.SetAt( _T("language"),		(void*) TOKEN_LANGUAGE );
	m_mapResTokens.SetAt( _T("guidelines"),		(void*) TOKEN_GUIDELINES );
	m_mapResTokens.SetAt( _T("define"),			(void*) TOKEN_DEFINE );
	m_mapResTokens.SetAt( _T("undef"),			(void*) TOKEN_UNDEF );
	m_mapResTokens.SetAt( _T("toolbar"),		(void*) TOKEN_TOOLBAR );
	m_mapResTokens.SetAt( _T("dialogex"),		(void*) TOKEN_DIALOGEX );
	m_mapResTokens.SetAt( _T("menuex"),			(void*) TOKEN_MENUEX );

	m_bTokenMapIsInit = TRUE;	// flag as init so we do this only once

// length of longest token in table
#define MAX_RCTOKEN_LEN		12
}

CRCCompilerTool::ResTokens CRCCompilerTool::GetNextToken
(
	const TCHAR	*	pMax,
	const TCHAR * &	pCurrent,
	const TCHAR * &	pTokenStart
)
{
//
//	Goes through map of an RC file looking for tokens.  pCurrent
//	if the 'file pointer" for the map and returns pointing to the
//	first charcter after the token.  pTokenStart returns pointing 
//	to the start of the token.
//
	ResTokens RetToken;
	int i;

	if (pCurrent >= pMax )   return TOKEN_EOF;

	// Skip white space:
	while (_istspace(*pCurrent))
	{
		BOOL bIsNewLine = (*pCurrent == _T('\r'));
		pCurrent++;

		if (pCurrent >= pMax)
			return TOKEN_EOF;

		if (bIsNewLine)
 		{
 			g_Line++;
 			return TOKEN_NEWLINE;
		}
  	}

	pTokenStart = pCurrent;

	// See what first not white-sapce character is
	int nRemLen;
	if (*pCurrent == _T('#'))
	{
		pCurrent++;
		return TOKEN_HASHSIGN;
	}
	else if (*pCurrent == _T('/'))
	{
		// Treat anything with this preceding char. as a comment token!
		RetToken = TOKEN_COMMENT;

		// See if we have special start or stop scan delimiters
		nRemLen = pMax - pCurrent;
		if (nRemLen > 16 &&
			(_tcsnicmp (pCurrent, _TEXT("//}}START_DEPSCAN"), 17) == 0))
			RetToken = TOKEN_START_SCAN;

		else
		if (nRemLen > 15 &&
		    (_tcsnicmp (pCurrent, _TEXT("//{{STOP_DEPSCAN"), 16) == 0))
			RetToken = TOKEN_STOP_SCAN;

		// Do we need to skip a comment block?
		BOOL fInCommentBlock = (nRemLen > 1) && (*(pCurrent + 1) == _T('*'));

		// Skip up to and including new line, this will be after a comment
		// block if we have one.
		// This means no TOKEN_NEWLINE follows a comment.
		while (pCurrent < pMax)
		{
			if (*pCurrent == _T('\r'))
			{
				g_Line++;
				if (!fInCommentBlock)
					break;
			}
			// End of the comment block?
			else if (fInCommentBlock && (pCurrent < (pMax - 1)) &&
					 *pCurrent == _T('*') && *(pCurrent + 1) == _T('/'))
			{
				fInCommentBlock = FALSE;
			}

			pCurrent = _tcsinc ((TCHAR *)pCurrent);
		}
		pCurrent++;
		return RetToken;
	}

	//  If the token begins with a quote, then go till the next quote:
	else if (*pTokenStart== _T('"'))
	{
		pCurrent++;
		while (pCurrent < pMax && *pCurrent != '"' )
								pCurrent = _tcsinc ((TCHAR *) pCurrent);
		pCurrent++;
		return (pCurrent >= pMax) ? TOKEN_EOF : TOKEN_WORD;
	}
		
	//	Some kind of a word.  Skip to the end:
	while (pCurrent < pMax && !_istspace (*pCurrent))
								pCurrent = _tcsinc ((TCHAR *) pCurrent);
	if (pCurrent >= pMax + 1)   return TOKEN_EOF;

	//  Examine the token.

	i = pCurrent - pTokenStart;	// Length of token in bytes.

	if ((i > MAX_RCTOKEN_LEN) || (!_istalpha(*pTokenStart)))
		return TOKEN_WORD;		
		
	// look up in map for speed
	TCHAR szToken[MAX_RCTOKEN_LEN+1];
	_tcsncpy(szToken, pTokenStart, i);
	szToken[i] = 0;						// nul-terminate
	_tcslwr(szToken);					// FUTURE: combine with copy operation

	if (!m_bTokenMapIsInit)	// should do this up front
		InitTokenMap();

	ASSERT(!m_mapResTokens.IsEmpty());

	if (m_mapResTokens.Lookup(szToken, (void * &) RetToken))
		return RetToken;

	return TOKEN_WORD;
}

//	Copy an .rc #include from psrcbuf to pdestbuf.  If the fisrt
//	character is a ", then double back slashes in the src
//	are replaced with a single \.
//
//	nchar chars are copied (nchar - 2 of there are quotes),
//	and a terminating null is put on.
//
void CopyAndSuppressBackslashes
(
	TCHAR * pdestbuf,
	const TCHAR * psrcbuf,
	int nchar
)
{
	const TCHAR *pMax;

	if (*psrcbuf != _T('"') && *psrcbuf != _T('<'))
	{
		_tcsncpy (pdestbuf, psrcbuf, nchar);
		pdestbuf[nchar] = _T('\0');
		return;
	}

	BOOL	fSawBackWhack = FALSE;

	psrcbuf++;
	pMax = psrcbuf + nchar -2;	// subtract 2 for leading trailing quotes.

	while (psrcbuf < pMax)
	{
		if (fSawBackWhack ||
			!(*psrcbuf == _T('\\') && *(psrcbuf+1) == _T('\\')))
		{
			// copy one (possibly multibyte) character
			if (IsDBCSLeadByte (*pdestbuf++ = *psrcbuf++))
				*pdestbuf++ = *psrcbuf++;

			fSawBackWhack = FALSE;
		}
		else 	
		{
			psrcbuf++;
			fSawBackWhack = TRUE;
		}
	}			

	// get trailing slash?
	if (fSawBackWhack)
		*pdestbuf++ = *--psrcbuf;

	*pdestbuf = _T('\0');
}

///////////////////////////////////////////////////////////////////////////////					
//
//	Scans .RC files for includes.
//
// states
//	0:  initial state
//	1:  '#' received, waiting for 'include', 'define', 'undef' or 'error'
//	2:	'#' and 'include' received, waiting for filename
//	3:	ICON, BITMAP, CURSOR, FONT received, waiting binary filename
//	4:	waiting for newline
//  5:	'rcinclude' received, waiting for filename
//	6:	got newline word, ie. resource identifier
BOOL CRCCompilerTool::GenerateDependencies(CActionSlob * pAction, FileRegHandle frhFile, CErrorContext & EC)
{
	const TCHAR *pTokenStart, *pLine;

	CString		strFile;
	BOOL		bSkipping = FALSE;
	int			iEntryType = 0, iState, nNameLength = 0;
	ResTokens	rToken;
	BOOL		bInsideMultiLine;
	TCHAR 		cDelim;

	HANDLE hMem;
	DWORD dwFileSize;

	const TCHAR * pcFileMap;

	if (!g_buildengine.OpenMemFile(frhFile, hMem, pcFileMap, dwFileSize, EC))
	{
		const CPath * pPath = g_FileRegistry.GetRegEntry(frhFile)->GetFilePath();
		g_buildengine.LogBuildError(BldError_ScanError, (void *)pPath);
		return FALSE;	// couldn't open
	}

	const TCHAR * pMax;
	int iBegin = 0;
	BOOL fScanNative;

	if (pcFileMap == (const TCHAR *)NULL)
		goto CloseMemFile;	// no need to open

	pMax = pcFileMap + dwFileSize;

	// are we scanning a native resource file?
	// if not then don't attempt to scan using resource script syntax...
	// ie. this might happen if we #include "header.h" in the resource file
	// fScanNative = AttachToFile(frhFile);
	fScanNative = FileNameMatchesExtension(g_FileRegistry.GetRegEntry(frhFile)->GetFilePath(), "*.rc;*.rc2");

	// Check for afx hack.  If the file begins with "//{{NO_DEP", don't scan:
	if (dwFileSize < 10 || _tcsnicmp (pcFileMap, _TEXT("//{{NO_DEP"), 10) == 0)
	{
		pAction->SetDepState(DEP_None);
		goto CloseMemFile;
	}

	g_Line = 1; iState = 0;
	bInsideMultiLine = FALSE;

	for (;;)
	{
		if ((rToken = GetNextToken (pMax, pcFileMap, pTokenStart)) == TOKEN_EOF)
			break;

		if (rToken == TOKEN_STOP_SCAN)
		{
			for (;rToken = GetNextToken (pMax, pcFileMap, pTokenStart),
				   rToken != TOKEN_START_SCAN && rToken != TOKEN_EOF;);

			if (rToken == TOKEN_EOF) break;
			else continue;
		}

		switch (rToken)
		{
			case TOKEN_NEWLINE:
				if (iState == 4) iState = 0;
				break;

			case TOKEN_HASHSIGN:
				if (iState != 0) iState = 4;
				else iState = 1;
				break;

			case TOKEN_INCLUDE:
				if (iState != 1) iState = 4;
				else iState = 2;
				break;

			case TOKEN_RCINCLUDE:
				if (iState != 0) iState = 4;
				else iState = 5;
				break;

			case TOKEN_DEFINE:
			case TOKEN_UNDEF:
			case TOKEN_ERROR:
				iState = 4;
				break;

			case TOKEN_COMMENT:
				iState = 0;
				break;

			case TOKEN_WORD:
			{
				// Waiting for a newline...
				if (iState == 4 || iState == 1)
					break;

				// only do this if we *know* we are a resource script
				if (fScanNative)
				{
					// 1st non-quoted word on a line?
					if (iState == 0 && *pTokenStart != _T('"'))
					{
						// wait for 2nd word, could be ICON or 'custom resource' name
						iState = 6;
						break; 
					}
					
					// Is this a 'custom resource' identifier (2nd non-quoted word on a line)?
	   				if (iState == 6 && *pTokenStart != _T('"'))
					{
	   					iState = !bInsideMultiLine ? 3 : 4;	// next token is include : ignore, wait for newline
						break;
					}
				}

				// Waiting for a file name?
				if (iState == 3)
				{
					// Check for a comma on the same line, before any
					// comments. this is to catch the case 'FONT 8, "Helv"'
					for ( pLine = pTokenStart; pLine < pMax && *pLine !=_T('/')
							&& *pLine != _T('\r'); pLine = _tcsinc ((TCHAR *) pLine) )
					{
						if (*pLine == _T(','))
						{
							iState = 4;
							break;
						}
					}
				}

				BOOL fScan = FALSE;		// by default, don't scan the include
				BOOL fGotDep = FALSE;;	// by default, this state is not a got dep.
				
				if (iState	== 3 || iState	== 5)
				{
					iEntryType = IncTypeCheckParentDir | IncTypeCheckIncludePath |
								 IncTypeCheckOriginalDir;

					// check for included 'generated' outputs in intermediate dir.
					if (iState == 3)
						iEntryType |= IncTypeCheckIntDir;

					nNameLength = pcFileMap - pTokenStart;
					fScan = (iState	!= 3);
					fGotDep = TRUE;
				}
				else if (iState	== 2)
				{
					// include file name in the form "xxxxxx.yyy"
					if (*pTokenStart == _T('"'))
					{
						iEntryType = IncTypeCheckParentDir | IncTypeCheckIncludePath |
									 IncTypeCheckOriginalDir;

						cDelim =  _T('"');
					}
					else if (*pTokenStart == _T('<'))
					{
						iEntryType = IncTypeCheckIncludePath;

						cDelim =  _T('>');
					}
					else
					{
						break;
					}
				
				   	nNameLength =  pcFileMap - pTokenStart;
					
					// must have "foo.h" or <foo.h> with at least 
					// a 1 char. name
					if (nNameLength > 2 && *(pcFileMap-1) == cDelim)
					{
						fScan = TRUE;
						fGotDep = TRUE;
					}

					//	else syntax error
				}

				if (fGotDep)	// deal with this dependency
				{
					TCHAR * pbuf = strFile.GetBuffer(nNameLength + 1);
  					CopyAndSuppressBackslashes(pbuf, pTokenStart, nNameLength);
					strFile.ReleaseBuffer();

  					CString strExt = GetExtension(strFile);
	
					VERIFY(pAction->AddScannedDep(iEntryType, strFile, g_Line, fScan));

					iState = 4;
				}
				else
				{
					iState = 0;
				}
				break;
			}

			// These tokens are all just noise, so eat them:
			case TOKEN_LOADONCALL:
			case TOKEN_PRELOAD:
			case TOKEN_PURE:
			case TOKEN_IMPURE:
			case TOKEN_FIXED:
			case TOKEN_MOVEABLE:
			case TOKEN_DISCARDABLE:
				if (iState != 3) iState = 4;
				break;

			case TOKEN_ICON:
			case TOKEN_TYPELIB:
			case TOKEN_FONT:
			case TOKEN_BITMAP:
			case TOKEN_CURSOR:
				if (iState == 6 && !bInsideMultiLine) iState = 3;
				else  iState = 4;
				break;

			// ignore all info after these tokens
			case TOKEN_LANGUAGE:
				iState = 4;
				break;
			// These tokens are all multiline statements
			// so we expect to have a BEGIN - END pair
			// and we should ignore anything inside the multiline
			// statement (including the ones before BEGIN-END block)
			case TOKEN_ACCELERATORS:
			case TOKEN_DIALOG:
			case TOKEN_DLGINIT:
			case TOKEN_MENU:
			case TOKEN_TOOLBAR:
			case TOKEN_RCDATA:
			case TOKEN_STRINGTABLE:
			case TOKEN_VERSIONINFO:
			case TOKEN_GUIDELINES:
			case TOKEN_DIALOGEX:
			case TOKEN_MENUEX:
				bInsideMultiLine = TRUE;
				iState = 4;
				break;
		
			// make sure that the number of begin - end matches
			case TOKEN_BEGIN:
				if (bInsideMultiLine)
					iBegin++;
				iState = 4;
				break;

			case TOKEN_END:
				if (bInsideMultiLine)
				{
					iBegin--;
					if (iBegin == 0)
						bInsideMultiLine = FALSE;
				}
				iState = 4;
				break;
			}
	}

	CloseMemFile:

	g_buildengine.CloseMemFile(hMem, EC);

	return TRUE;
}

void CRCCompilerTool::GetIncludePaths(CProjItem * pItem, CString & str)
{
	// RC uses current directory.
	str = ".\\;";

	CString strFileIncs;

	// -I should be in front of INCLUDE path
	if (pItem->GetStrProp(MapLogical(P_ResIncludes), strFileIncs) && !strFileIncs.IsEmpty())
		str += (strFileIncs + _TEXT (";"));

	ReplaceEnvVars(str);

	// do we want to ignore the INCLUDE?
	int fIgnoreInclude;
	if (pItem->GetIntProp(MapLogical(P_ResIgnIncPath), fIgnoreInclude) == invalid)
		fIgnoreInclude = FALSE;

	if (fIgnoreInclude)
		strFileIncs = ".";	// ignore the INCLUDE path! N.B. we use . for curreent
							// 'cos the resource compiler code will treat
							// an empty string as no include path and use INCLUDE!
	else
		GetDirMgr()->GetDirListString(strFileIncs, DIRLIST_INC);

	str += strFileIncs;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CRCCompilerNTTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	COptionHandler * popthdlr = GetOptionHandler();
	CString strDefine;

	// our AFX '_AFXDLL' define
	strDefine.LoadString(IDS_MFCDLL_DEFINE);

	// add or remove all occurances of our /D"_AFXDLL" from resource compiler defines
  	popthdlr->MungeListStrProp(MapLogical(P_ResMacroNames), strDefine, iUseMFC == UseMFCInDll, _T(','));

	return CRCCompilerTool::PerformSettingsWizard(pProjItem, fDebug, iUseMFC);
}
