//
// Common Browser Database Make Tool
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "optncplr.h"	// for the pch compiler options
#include "toolbsc.h"	// our local header file

IMPLEMENT_DYNAMIC ( CBscmakeTool, CSchmoozeTool )

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CBscmakeTool::CBscmakeTool() : CSchmoozeTool()
{
	// tool name
	m_nIDName = IDS_BSCMAKE_TOOL;
	m_nIDUIName = IDS_BSCMAKE_TOOL_UI;

	// tool exe name and input file set
	m_strToolExeName = _TEXT("bscmake.exe");
	m_strToolInput = _TEXT("*.sbr");
	m_strToolPrefix = _TEXT("BSC32");

	// deferred tool
	m_fDeferredTool = TRUE;

	// perform action if able
	m_fPerformIfAble = TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// Return the list of files generated by the bscmake tool
BOOL CBscmakeTool::GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC)
{
	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
		CProjItem * pItem = pAction->m_pItem;

		CString strName;

		if (pItem->GetStrProp(MapLogical(P_BscMakeOutputFilename), strName) != valid)
			strName = "";	// failed to get prop, no output name

		CPath pathName;

		if (!pathName.CreateFromDirAndFilename(pItem->GetProject()->GetWorkspaceDir(), strName) ||
			!pAction->AddOutput((const CPath *)&pathName))
			return FALSE; // failure to create output name
	}

	return TRUE; // success
}

///////////////////////////////////////////////////////////////////////////////
// Affects our output?
BOOL CBscmakeTool::AffectsOutput(UINT idPropL)
{
	// change our outputs?
	if (
		idPropL == P_BscMakeOutputFilename	// *.bsc
	   )
	{
	   return TRUE;
	}

	return FALSE;
}

UINT CBscmakeTool::PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
									  DWORD aob, CErrorContext & EC)
{
	UINT act = ACT_Complete;

	// starting to build browser database
	if (stage == TOB_Stage)
		theApp.NotifyPackages(PN_START_BSCMAKE);

	act = CBuildTool::PerformBuildActions(type, stage, lstActions, aob, EC);

	// finished building browser database
	if (stage == TOB_Stage)
		theApp.NotifyPackages(PN_END_BSCMAKE);

	return act;
}

BOOL CBscmakeTool::GetCommandLines
(
	CActionSlobList & lstActions,
	CPtrList & plCommandLines,
	DWORD attrib,
	CErrorContext & EC
)
{
	CString strDescription;
	VERIFY(strDescription.LoadString(IDS_DESC_BSCMAKING));

	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
 		CProjItem * pItem = pAction->Item();

		// project directory of this item
		CDir * pProjDir = &pItem->GetProject()->GetWorkspaceDir();

		// generate tool options
		CString strCmdLine;
		if (!pAction->GetCommandOptions(strCmdLine))
			return FALSE;

		// add our inputs to the command-line
		CFileRegSet * pset = (CFileRegSet *)pAction->GetInput();
		ASSERT(pset->IsKindOf(RUNTIME_CLASS(CFileRegSet)));

		// our actions that contribute to the inputs
		CActionSlobList lstOutActions;

		// id of the compiler option handler
		DWORD bsc_idCplrOptHdlr = GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Compiler);

		FileRegHandle frhInput;
		pset->InitFrhEnum();

		// input name and ordered .sbr file list
		CString strInput, strSbrs;

		while ((frhInput = pset->NextFrh()) != (FileRegHandle)NULL)
		{
			BOOL fFront = FALSE;	// add the .sbr to the front?

			// was this generated along with the .pch?
			if (pAction->m_pdepgraph->RetrieveOutputActions(lstOutActions, EC, frhInput) == CMD_Complete)
			{
				POSITION pos = lstOutActions.GetHeadPosition();
				while (pos != (POSITION)NULL)
				{
					CActionSlob * pAction = (CActionSlob *)lstOutActions.GetNext(pos);
					COptionHandler * pOptHdlr = pAction->BuildTool()->GetOptionHandler();

					// is this the compiler option handler?
					if (pOptHdlr != (COptionHandler *)NULL &&
						pOptHdlr->GetBaseOptionHandler()->CompId() == bsc_idCplrOptHdlr)
					{
						// using /Yc?
						int bVal;
						if (pAction->Item()->GetIntProp(pOptHdlr->GetBaseOptionHandler()->MapLogical(P_PchCreate), bVal) == valid &&
							bVal)	// /Yc is on
						{
							fFront = TRUE;
							break;	// we're done here
						}
					}
				}
			}

			const CPath * pPath = pAction->m_pregistry->GetRegEntry(frhInput)->GetFilePath();

			// quote this input and make relative to project directory?
			if (!pPath->GetRelativeName(*pProjDir, strInput, TRUE, FALSE))
			{
				// If GetRelativeName failed, it's probably because the two
				// paths are on different drives, so we just can't make a 
				// relative path.  In this case, however, pPath must contain
				// at least a drive letter (and will probably be a full path)
				strInput = *pPath;
			}

			// add the .sbr to the front?
			if (fFront)
			{
				// front
				strInput += strSbrs;
				strSbrs = _T('\n');
				strSbrs += strInput;
			}
			else
			{
				// back
				strSbrs += _T('\n');
				strSbrs += strInput;
			}
#ifdef REFCOUNT_WORK
			frhInput->ReleaseFRHRef();
#endif
		}

		// may create a tmp. file if cmdline too long
		strCmdLine += strSbrs;

		if (!g_buildengine.FormCmdLine(m_strToolExeName, strCmdLine, EC))
			return FALSE;	// error

		// add this to our list of command-lines
		CCmdLine *pCmdLine = new CCmdLine;
		pCmdLine->slCommandLines.AddTail(strCmdLine);
		pCmdLine->slDescriptions.AddTail(strDescription);
		pCmdLine->nProcessor = 1;
		plCommandLines.AddTail(pCmdLine);
	}

	return TRUE;	// success
}

DAB CBscmakeTool::DeferredAction(CActionSlob * pAction, CString * pstrAction)
{
	int iNoDefer;
	if (pAction->m_pItem->GetProject()->GetIntProp(P_NoDeferredBscmake, iNoDefer) != valid)
	{
		ASSERT(FALSE);	// shouldn't happen
		iNoDefer = 0;
	}

#if 0	// The "Build Browse Info" menu item is out for V4.
	if (pstrAction != (CString *)NULL)
		VERIFY(pstrAction->LoadString(IDS_DEFFERED_BSCMAKE));
#endif

	switch (iNoDefer)
	{
		case 0:	return dabDeferred;
		case 1:	return dabNotDeferred;
		default: ASSERT(FALSE); return dabNotDeferred;
	}
}

BOOL CBscmakeTool::SetDeferredAction(CActionSlob * pAction, DAB dab)
{
	int iNoDefer;
	switch (dab)
	{
		case dabNotDeferred:
			iNoDefer = 1; break;

		case dabDeferred:
			iNoDefer = 0; break;

		default:
			ASSERT(FALSE); iNoDefer = 0; break;
	}

	return pAction->m_pItem->GetProject()->SetIntProp(P_NoDeferredBscmake, iNoDefer);
}
  
CSchmoozeTool::SchmoozeData g_schdataBscmake =
{
		    _TEXT ("BSC32"),		 		//pszExeMacro;
		    _TEXT ("BSC32_FLAGS"),  		//pszFlagsMacro;
			_TEXT (""),						//pszSpecialFlags;
		    _TEXT ("BSC32_SBRS"),			//pszConsumeMacro;
			_TEXT (""),						//pszSpecialConsume;
		    _TEXT (" $(BSC32)"),			//pszExeMacroEx;
		    _TEXT (" $(BSC32_FLAGS)"),   	//pszFlagsMacroEx;
			_TEXT (""),						//pszSpecialFlagsEx;
		    _TEXT (" $(BSC32_SBRS)"), 		//pszConsumeMacroEx;
			_TEXT (""),						//pszSpecialConsumeEx;
		    _TEXT("bsc"),					//pszProductExtensions;
		    _TEXT(""),						//pszDelOnRebuildExtensions;
};

BOOL CBscmakeTool::IsConsumableFile(const CPath * pPath)
{
	return FileNameMatchesExtension (pPath, m_strToolInput);
}

BOOL CBscmakeTool::IsProductFile(const CPath * pPath)
{
	return FileNameMatchesExtension (pPath, g_schdataBscmake.pszProductExtensions);
}
