//
// Xbox Compiler Tool
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "xbxtoolc.h"	// our local header file

IMPLEMENT_DYNAMIC ( CCCompilerXboxTool, CCCompilerNTTool )

static char rgchVc70[] = "vc70";

CCCompilerXboxTool::CCCompilerXboxTool() : CCCompilerNTTool()
{
	m_strToolExeName = _TEXT("cl.exe");
	m_nIDName = IDS_XBOXCOMPILER32_TOOL;
	m_nIDUIName = IDS_XBOXCOMPILER32_TOOL_UI;
	m_MrSupportLevel = Full;
}

//////////////////////////////////////////////////////////////////////////////
// Default tool options for the Xbox compiler tool
BOOL CCCompilerXboxTool::GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption)
{
	// are we a mode we can handle?
	ASSERT(mode == MOB_Debug || mode == MOB_Release);
	
	CString strPart; 

	// Our common tool options
	VERIFY(strOption.LoadString(IDS_XBOX_CPLR_COMMON));

	// Our mode tool options
 	VERIFY(strPart.LoadString(mode == MOB_Debug ? IDS_XBOX_CPLR_DBG : IDS_XBOX_CPLR_REL));
	strOption += _T(' '); strOption += strPart;

	// Return appropriate tool options according to the attributes
	// of the target type
	UINT nIDAttrib = (UINT)-1;

    // EXE options get added for all projects
#if 0
	if (attrib & ImageExe)
	{
		nIDAttrib = mode == MOB_Debug ? IDS_XBOXEXE_CPLR_DBG : IDS_XBOXEXE_CPLR_REL;
	}
#endif
    nIDAttrib = mode == MOB_Debug ? IDS_XBOXEXE_CPLR_DBG : IDS_XBOXEXE_CPLR_REL;

	// Our attribute tool options
	if (nIDAttrib != (UINT)-1)
	{
		VERIFY(strPart.LoadString(nIDAttrib));
		strOption += _T(' '); strOption += strPart;
	}

	return TRUE;	// success
}

///////////////////////////////////////////////////////////////////////////////
// Return the list of files generated by the compiler tool
BOOL CCCompilerXboxTool::GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC)
{
	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
		CProjItem * pItem = pAction->Item();

		CProject *pProject = pItem->GetProject();
		ASSERT (pProject);
		CDir * pDir = &pProject->GetWorkspaceDir();

		// object files
		if (!pAction->AddOutput(MapLogical(P_OutputDir_Obj), _TEXT(".obj"), pDir)){
			ASSERT(FALSE);
			return( FALSE );
		}

		// source browser files
		if (!pAction->AddOutput(MapLogical(P_OutputDir_Sbr), _TEXT(".sbr"), pDir, (TCHAR *)NULL, MapLogical(P_GenBrowserInfo))){
			ASSERT(FALSE);
			return( FALSE );
		}
				
		// pdb files (both .pdb and .idb)
		// P_DebugInfo == 3 is /Zi
		//
		int iDebugInfo;
		if ((pItem->GetIntProp (MapLogical(P_DebugInfo), iDebugInfo) == valid) && iDebugInfo >= DebugInfoPdb)
		{
			if (!pAction->AddOutput(MapLogical(P_OutputDir_Pdb), _TEXT(".pdb"), pDir, rgchVc70, (UINT)-1 /* no enable id */, FALSE /* 2ndary output */)){
				ASSERT(FALSE);
				return( FALSE );
			}
		}
		
		// Add idb for /Gm.
		int iMr,iFd;
		if ((pItem->GetIntProp( MapLogical(P_Enable_MR), iMr) == valid) && iMr ){
			if (!pAction->AddOutput(MapLogical(P_OutputDir_Pdb), _TEXT(".idb"), pDir, rgchVc70,  MapLogical(P_Enable_MR), FALSE /* 2ndary output */)){
				ASSERT(FALSE);
				return FALSE;
			}
		}
		else if ((pItem->GetIntProp( MapLogical(P_Enable_FD), iFd) == valid) && iFd )
		{
			// Add idb for /FD.
			if (!pAction->AddOutput(MapLogical(P_OutputDir_Pdb), _TEXT(".idb"), pDir, rgchVc70,  MapLogical(P_Enable_FD), FALSE /* 2ndary output */)){
				ASSERT(FALSE);
				return FALSE;
			}
		}

		// check to see if this file produces or uses a PCH file....
		// get the location of of the /Fp setting
		CPath pathPch;
		BOOL bval;

		// clear the .pch file dep. from the source deps...
		CFileRegSet * pfrs = pAction->GetSourceDep();
		FileRegHandle frh;

		pfrs->InitFrhEnum();
		while ((frh = pfrs->NextFrh()) != (FileRegHandle)NULL)
		{
			const CPath * pPath = pAction->m_pregistry->GetRegEntry(frh)->GetFilePath();
			if (_tcsicmp(pPath->GetExtension(), _TEXT(".pch")) == 0)
			{
				// remove the .pch as a source dep.
				if (!pAction->RemoveSourceDep(frh))
					ASSERT(FALSE);
#ifdef REFCOUNT_WORK
				frh->ReleaseFRHRef();
#endif
				break;	// done!
			}
#ifdef REFCOUNT_WORK
			frh->ReleaseFRHRef();
#endif
		}

		CString strPch;
		if ((pItem->GetStrProp(MapLogical(P_PchDefaultName), strPch) != valid) || strPch.IsEmpty())
			continue;	// no pch name....
			
		// add a possible .pch file dep.
		if ((pItem->GetIntProp(MapLogical(P_PchCreate), bval) == valid) && bval)
		{
			if (pathPch.CreateFromDirAndFilename(*pDir, strPch))
				if (!pAction->AddOutput(&pathPch))
					ASSERT(FALSE);
		}
		else if ((pItem->GetIntProp(MapLogical(P_PchUse), bval) == valid) && bval)
		{
			// add the .pch as a source dep.
			if (pathPch.CreateFromDirAndFilename(*pDir, strPch))
			{
				CString strPch = (const TCHAR *)pathPch;
				if (!pAction->AddSourceDep(strPch))
					ASSERT(FALSE);
			}
		}
	}

	return TRUE; // success
}

#if 0
///////////////////////////////////////////////////////////////////////////////
// Ensure that this project compiler Xbox options are ok to use/not use MFC
BOOL CCCompilerXboxTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	// Set the thread type usage
	pProjItem->SetIntProp(MapLogical(P_Thread), ThreadForUsingMFC(pProjItem, iUseMFC));

	return CCCompilerNTTool::PerformSettingsWizard(pProjItem, fDebug, iUseMFC);
}
#endif

#if 0
// This is our first OLE compiler tool.
COLECompilerTool::COLECompilerTool( void ){
};


BEGIN_INTERFACE_MAP(COLECompilerTool,CCmdTarget)
    INTERFACE_PART(COLECompilerTool, IID_IBuildTool, Compiler)
END_INTERFACE_MAP()

////////////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP_(ULONG) COLECompilerTool::XCompiler::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COLECompilerTool::XCompiler::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COLECompilerTool::XCompiler::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}
/////////////////////////////////////////////////////////////////////////
// IBuildTool

STDMETHODIMP COLECompilerTool::XCompiler::IsCollectorTool(void)
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	return NOERROR;
}

STDMETHODIMP COLECompilerTool::XCompiler::GetID(UINT *pId)
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	*pId = NULL;
	return NOERROR;
}

STDMETHODIMP COLECompilerTool::XCompiler::Filter(LPBUILDFILE pFile)
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);

	const CPath *pPath = pFile->GetFilePath();
	if( FileNameMatchesExtension( pPath, "*.cpp;*.c" ) )
		return S_OK;

	return S_FALSE;
}

STDMETHODIMP COLECompilerTool::XCompiler::PerformBuild( int type, int stage,LPENUMBSACTIONS pActions, int *result )
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);

	UINT act = ACT_Complete;

	// what stage is this?
	switch (stage)
	{
		// pre?
		case TOB_Pre:
		{
			// need to rebuild?

			if (type == TOB_Clean)
			{
				// delete our .pch on re-build
				// Only deletes if AutoPch. In that case, we need to walk all the files to be compiled,
				// possibly deleting a different header for each file. In the standard case where you have
				// one file that creates the pch and others use it, we don;t need to delete; compiling the
				// file that creates it will rebuild the pch file. bobz 9/5/95

				LPBSACTION pAction[10];
				ULONG nGot = 10;
				while( nGot == 10 ){
					pActions->Next( 10, pAction, &nGot );
					ULONG i=0;
					while ( i < nGot ){
						// deal with pAction[i]
						pAction[i]->Release();
						i++;
					}
				}
			}
			else if( type == TOB_Build )
			{
				// delete the .obj file if we think we should have a .pdb and we don't
				LPBSACTION pAction[10];
				ULONG nGot = 10;
				while( nGot == 10 ){
					pActions->Next( 10, pAction, &nGot );
					ULONG i=0;
					while ( i < nGot ){
						LPBUILDFILE    frh;
						LPBUILDFILESET pfrs;
						pAction[i]->GetOutputs( &pfrs );
/*
						pfrs->InitEnum();
						while ( frh = pfrs->Next() )
						{
							LPCOLESTR pPath = frh->GetFilePath();
							if (_tcsicmp(pPath->GetExtension(), _TEXT(".pdb")) == 0)
							{
								if (!pPath->ExistsOnDisk())
								{
									CProject *pProject = pAction->Item()->GetProject();
									ASSERT(pProject != (CProject *)NULL);
	
									if (GetItemOutputFile(pAction->Item(), MapLogical(P_OutputDir_Obj), frh, _TEXT(".obj"), &pProject->GetWorkspaceDir()))
										if (!g_buildengine.DeleteFile(frh, EC) && !(aob & AOB_IgnoreErrors))
											act = ACT_Error;	// failure
								}
								break;	// done!
							}
						}
*/
						pAction[i]->Release();
						i++;
					}
				}
			}
			break;
		}

		// post?
		case TOB_Post:
			break;

		// action?
		case TOB_Stage:
			break;

		default:
			break;
	}

	return NOERROR;
}

STDMETHODIMP COLECompilerTool::XCompiler::GenerateCommandLines( LPENUMBSACTIONS pActions, CStringList &slCommandLines, CStringList &slDescriptions )
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);

	CString strDescription;
	VERIFY(strDescription.LoadString(IDS_DESC_COMPILING));

	CString strCmdLine;

	LPBSACTION pAction[10];
	ULONG nGot = 10;
	while( nGot == 10 ){
		pActions->Next( 10, pAction, &nGot );
		ULONG i=0;
		while ( i < nGot ){

			LPBUILDFILE pFile;
			pAction[i]->GetFile(&pFile);
			// ActionState as = pAction[i]->m_state;
	
			// strFilePath = pFile->GetFilePath();
			CString strFilePath = (const TCHAR *)*(pFile->GetFilePath());
	
			//if (!pAction->GetCommandOptions(str))
			//	return FALSE;
			CString strOptions = "/c";
	
			// our command-line of form,
			// '<exe> <options> "<input-file>"'
			strCmdLine = "cl.exe";
			strCmdLine += _TEXT(" ");
			strCmdLine += strOptions;
			strCmdLine += _TEXT(" \"");
			strCmdLine += strFilePath;
			strCmdLine += _TEXT("\"");
	
			slCommandLines.AddHead(strCmdLine);
	
			// our description
			slDescriptions.AddHead(strDescription);
			pAction[i]->Release();
			i++;
		}
	}

	return NOERROR;
}

STDMETHODIMP COLECompilerTool::XCompiler::GenerateOutputs( LPENUMBSACTIONS pActions )
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);

	LPBSACTION pAction[10];
	ULONG nGot = 10;
	while( nGot == 10 ){
		pActions->Next( 10, pAction, &nGot );
		ULONG i=0;
		while ( i < nGot ){
			LPBUILDFILE pFile;
			pAction[i]->GetFile( &pFile );
	
			// object files
			CPath path = *(pFile->GetFilePath());
			path.ChangeExtension(_TEXT(".obj"));
			// pAction[i]->SetOutput( &path );
			pAction[i]->Release();
			i++;
		}
	}

	return NOERROR;
}

STDMETHODIMP COLECompilerTool::XCompiler::GetDependencies( LPENUMBSACTIONS )
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	return NOERROR;
}

STDMETHODIMP COLECompilerTool::XCompiler::EnumOptionStrings( LPENUMOPTIONSTRINGS * )
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	return NOERROR;
}

STDMETHODIMP COLECompilerTool::XCompiler::EnumOptionTypes( LPENUMOPTIONTYPES * )
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	return NOERROR;
}
#endif
