extern "C" {
    #include <ntos.h>
    #include <init.h>
    #include <hal.h>
    #include <nturtl.h>
    #include <xtl.h>
    #include <xboxp.h>
    #include <xdbg.h>
    #include <phy.h>
    #include <xbeimage.h>
    #include <ldr.h>
};
#include <sha.h>
#include <rc4.h>
#include <rsa.h>
#include <des.h>
#include <tripldes.h>
#include <modes.h>
#include "xcrypt.h"
#include <malloc.h>

#if DBG
extern "C" ULONG XDebugOutLevel;
#endif

//#define AESTEST 1

#ifdef AESTEST
#include "aes.h"
#endif

#define SHA_TEST_LENGTH 64
#define SHA_KA_LENGTH1 3
#define SHA_KA_LENGTH2 56
// #define SHA_KA_LENGTH3 1000000
#define SHA_KA_DIG_LEN 20
#define SHA_REPEAT_LOOP 50000

BOOL shatest()
{
	BYTE text[SHA_TEST_LENGTH];
	BYTE digest[A_SHA_DIGEST_LEN];
	BYTE shaDigest[XC_SERVICE_DIGEST_SIZE];
	A_SHA_CTX ctxt;
	BYTE shaCtxt[XC_SERVICE_SHA_CONTEXT_SIZE];
	DWORD dwStart,dwEnd,i;

	UCHAR ka_txt1[SHA_KA_LENGTH1] = {'a', 'b', 'c'};
	BYTE ka_digest1[SHA_KA_DIG_LEN] = {0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E, 0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D};
	UCHAR ka_txt2[SHA_KA_LENGTH2] = {'a', 'b', 'c', 'd', 'b', 'c', 'd', 'e', 'c', 'd', 'e', 'f', 'd', 'e', 'f', 'g', 'e', 'f', 'g', 'h', 
	    'f', 'g', 'h', 'i', 'g', 'h', 'i', 'j', 'h', 'i', 'j', 'k', 'i', 'j', 'k', 'l', 'j', 'k', 'l', 'm', 'k', 'l', 'm', 'n', 'l', 'm', 'n', 'o', 'm', 'n', 'o', 'p', 'n', 'o', 'p', 'q'};
	BYTE ka_digest2[SHA_KA_DIG_LEN] = {0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E, 0xBA, 0xAE, 0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5, 0xE5, 0x46, 0x70, 0xF1};
//	UCHAR ka_txt3[SHA_KA_LENGTH3];
//	BYTE ka_digest3[SHA_KA_DIG_LEN] = {0x34, 0xAA, 0x97, 0x3C, 0xD4, 0xC4, 0xDA, 0xA4, 0xF6, 0x1E, 0xEB, 0x2B, 0xDB, 0xAD, 0x27, 0x31, 0x65, 0x34, 0x01, 0x6F};
    
    ASSERT( sizeof(ctxt) == XC_SERVICE_SHA_CONTEXT_SIZE );
    
    ASSERT( A_SHA_DIGEST_LEN == XC_SERVICE_DIGEST_SIZE );
    ASSERT( SHA_KA_DIG_LEN == XC_SERVICE_DIGEST_SIZE );

/*    for (i=0; i<SHA_KA_LENGTH3; i++)
        ka_txt3[i] = 'a'; */
    
	XNetRandom( text, SHA_TEST_LENGTH );
	RtlZeroMemory( &ctxt, XC_SERVICE_SHA_CONTEXT_SIZE );
	RtlZeroMemory( shaCtxt, XC_SERVICE_SHA_CONTEXT_SIZE );

    dwStart = GetTickCount();
    for(i=0; i<SHA_REPEAT_LOOP; ++i)
    {
        A_SHAInit( &ctxt );
        XcSHAInit( shaCtxt );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcSHAInit", "%d times took %d ms", SHA_REPEAT_LOOP * 2, dwEnd );
    
    if (memcmp( shaCtxt, &ctxt, XC_SERVICE_SHA_CONTEXT_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcSHAInit result compare failed!");
        return FALSE;
    }
    
    dwStart = GetTickCount();
    for(i=0; i<SHA_REPEAT_LOOP; ++i)
    {
        XcSHAUpdate( shaCtxt, text, SHA_TEST_LENGTH );
        A_SHAUpdate( &ctxt, text, SHA_TEST_LENGTH );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcSHAUpdate", "%d bytes took %d ms", SHA_REPEAT_LOOP * 2 * SHA_TEST_LENGTH, dwEnd );
    
    if (memcmp( shaCtxt, &ctxt, XC_SERVICE_SHA_CONTEXT_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcSHAUpdate result compare failed!");
        return FALSE;
    }
    
    dwStart = GetTickCount();
    for(i=0; i<SHA_REPEAT_LOOP; ++i)
    {
        XcSHAFinal( shaCtxt, shaDigest );
        A_SHAFinal( &ctxt, digest );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcSHAFinal", "%d times took %d ms", SHA_REPEAT_LOOP * 2, dwEnd );
    
    if (memcmp( shaDigest, digest, XC_SERVICE_DIGEST_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcSHAFinal result compare failed!");
        return FALSE;
    }

    XcSHAInit( shaCtxt );
    XcSHAUpdate( shaCtxt, ka_txt1, SHA_KA_LENGTH1 );
    XcSHAFinal( shaCtxt, shaDigest );
    if (memcmp( shaDigest, ka_digest1, XC_SERVICE_DIGEST_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " SHA known answer test 1 compare failed!");
        return FALSE;
    }

    XcSHAInit( shaCtxt );
    XcSHAUpdate( shaCtxt, ka_txt2, SHA_KA_LENGTH2 );
    XcSHAFinal( shaCtxt, shaDigest );
    if (memcmp( shaDigest, ka_digest2, XC_SERVICE_DIGEST_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " SHA known answer test 2 compare failed!");
        return FALSE;
    }

/*    XcSHAInit( shaCtxt );
    XcSHAUpdate( shaCtxt, ka_txt3, SHA_KA_LENGTH3 );
    XcSHAFinal( shaCtxt, shaDigest );
    if (memcmp( shaDigest, ka_digest3, XC_SERVICE_DIGEST_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " SHA known answer test 3 compare failed!");
        return FALSE;
    } */
    
    return TRUE;
}

#define RC4_KEY_TEST_LENGTH 16

#define RC4_TEST_LENGTH 64

#define RC4_REPEAT_LOOP 50000

BOOL rc4test()
{
	BYTE key[RC4_KEY_TEST_LENGTH];
	BYTE text[RC4_TEST_LENGTH];
	BYTE text2[RC4_TEST_LENGTH];
	RC4_KEYSTRUCT keyStruct;
	BYTE pbkeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
	DWORD dwStart,dwEnd,i;
    
    ASSERT( sizeof(keyStruct) == XC_SERVICE_RC4_KEYSTRUCT_SIZE );
    
	XNetRandom( key, RC4_KEY_TEST_LENGTH );
	XNetRandom( text, RC4_TEST_LENGTH );
    memcpy( text2, text, RC4_TEST_LENGTH );
    
    dwStart = GetTickCount();
    for(i=0; i<RC4_REPEAT_LOOP; ++i)
    {
        rc4_key( &keyStruct, RC4_KEY_TEST_LENGTH, key );
        XcRC4Key( pbkeyStruct, RC4_KEY_TEST_LENGTH, key );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcRC4Key", "%d times for %d byte key took %d ms", RC4_REPEAT_LOOP * 2, RC4_KEY_TEST_LENGTH, dwEnd );
    
    if (memcmp( pbkeyStruct, &keyStruct, XC_SERVICE_RC4_KEYSTRUCT_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcRC4Key result compare failed!");
        return FALSE;
    }
    
    dwStart = GetTickCount();
    for(i=0; i<RC4_REPEAT_LOOP; ++i)
    {
        XcRC4Crypt( pbkeyStruct, RC4_TEST_LENGTH, text );
        rc4( &keyStruct, RC4_TEST_LENGTH, text2 );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcRC4Crypt", "%d bytes took %d ms", RC4_REPEAT_LOOP * 2 * RC4_TEST_LENGTH, dwEnd );
    
    if (memcmp( text, text2, RC4_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " XcRC4Crypt result compare failed!");
        return FALSE;
    }
    
    if (memcmp( pbkeyStruct, &keyStruct, XC_SERVICE_RC4_KEYSTRUCT_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcRC4Crypt key struct result compare failed!");
        return FALSE;
    }
    
    return TRUE;
}

BYTE PrivateKeyData[] = 
    {
           0x52,0x53,0x41,0x32,0x08,0x01,0x00,0x00,
           0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
           0x01,0x00,0x01,0x00,0xA7,0xC1,0xB4,0xFE,
           0x8C,0x26,0x9A,0xCF,0xEC,0xDB,0x9F,0xAA,
           0xF0,0xCF,0x82,0xB8,0xCE,0x0E,0xD8,0x22,
           0x6D,0xDA,0x49,0xD6,0x8A,0x1C,0xFD,0x5E,
           0xAD,0xB4,0xA0,0x3E,0xA6,0xEA,0xB6,0x20,
           0xF0,0xB9,0x2C,0xC3,0x48,0x48,0x1E,0xD2,
           0x2B,0x22,0xA0,0xAF,0xA8,0x3E,0x41,0x95,
           0xB8,0x3D,0x04,0xBF,0x9E,0x58,0x3D,0x7C,
           0xF5,0x92,0x2E,0x0C,0xFD,0x85,0x67,0xC3,
           0xB2,0xE7,0x33,0x7F,0x7E,0x46,0xFC,0x2A,
           0x10,0x77,0xB4,0xB6,0x7B,0x2B,0x7C,0x70,
           0x70,0x33,0x94,0x51,0x0F,0x64,0x9E,0x1A,
           0x37,0x4D,0x5C,0x49,0xB9,0x7E,0xCE,0x1D,
           0x47,0xC7,0x72,0x90,0x61,0xC4,0xEE,0xEF,
           0xF6,0x2C,0x47,0x36,0xCD,0x4B,0x23,0x96,
           0xB2,0x24,0x2C,0xC5,0x6D,0x62,0x08,0x43,
           0x3E,0x16,0xB8,0x86,0x32,0xF3,0x12,0x91,
           0xA2,0xF4,0x42,0x19,0xCC,0xC5,0x5E,0x9C,
           0x75,0x25,0x9C,0x84,0x5A,0xBC,0xE0,0xCE,
           0x15,0x62,0xD5,0xCE,0x3E,0x30,0x1C,0x48,
           0xFA,0x1E,0x67,0xE9,0x06,0xA5,0x9E,0x9C,
           0xAB,0xEE,0x16,0xAA,0x44,0x9D,0x56,0x35,
           0xCA,0xD9,0x5A,0xC4,0xFB,0xA4,0x9A,0x39,
           0xE4,0xFD,0x8B,0x58,0xF1,0xE8,0x0C,0x45,
           0x76,0x80,0x7E,0xBB,0x57,0x68,0x32,0xC9,
           0x9C,0x3E,0x67,0x55,0x28,0xBD,0xB9,0xB4,
           0x6D,0x64,0xF1,0xB6,0x11,0x6B,0x0D,0xE9,
           0xF2,0x04,0x08,0xDB,0x2B,0x42,0x9C,0xC5,
           0x17,0x0D,0x86,0xE9,0x40,0x32,0x75,0x6E,
           0x51,0x7D,0xF6,0x4C,0x7E,0xA8,0x97,0x3A,
           0x95,0x31,0x20,0x7A,0x66,0xBF,0xE2,0x79,
           0xCF,0xC5,0x4A,0xA1,0xDF,0x9A,0x1E,0x52,
           0x8C,0x2B,0xF9,0xAB,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x49,0xFB,0xD0,0x56,
           0x36,0x69,0xEF,0x00,0x98,0x35,0x83,0x42,
           0x42,0xF9,0x14,0x52,0x81,0xF7,0xA9,0x8E,
           0x57,0x95,0xE9,0xA8,0xD6,0x01,0x8B,0x84,
           0x55,0xE9,0xEF,0x2E,0xCC,0x94,0x50,0x11,
           0x97,0x10,0x9E,0xF3,0x18,0xC3,0xAB,0x6E,
           0x04,0x08,0x90,0xD8,0x9D,0x97,0x04,0x37,
           0xB3,0x7E,0x57,0x1C,0xA3,0x97,0xE5,0x5B,
           0x85,0x18,0x8C,0xD2,0xAC,0xE8,0x97,0xF3,
           0x7A,0x19,0xCC,0x93,0xC1,0xCC,0xAE,0x53,
           0x6E,0xCE,0xFC,0x18,0xE3,0xAA,0xB3,0x26,
           0x72,0xA2,0x48,0x52,0xD0,0xCE,0xB2,0xC9,
           0x61,0x8D,0x15,0xB3,0xF7,0xF4,0x9A,0x7B,
           0xF6,0x85,0x93,0xF6,0xCF,0xDD,0x04,0xCA,
           0xC8,0x9A,0xCA,0x40,0xDA,0x9F,0x5D,0x9C,
           0x49,0x43,0x41,0x89,0xB8,0x4C,0xB6,0x0C,
           0x3D,0xE3,0x8F,0xDA,0x00,0x00,0x00,0x00,
           0x6F,0x65,0x54,0xDB,0x9B,0x37,0x53,0xF2,
           0x5C,0xEF,0x3F,0x49,0x5F,0xAC,0x41,0xA9,
           0xAB,0xE4,0x9F,0x49,0xA3,0x1E,0x84,0xEB,
           0x4A,0x8D,0xED,0xBB,0x12,0x0D,0xA4,0xF9,
           0x72,0x3E,0xE3,0x28,0x92,0x44,0xE4,0x1C,
           0x18,0xFF,0xC3,0xCB,0xCE,0xBD,0x78,0x96,
           0x54,0x0B,0x93,0xCF,0x52,0x47,0x0A,0x5C,
           0xD6,0xC6,0x38,0xA1,0xBE,0x22,0x48,0x8A,
           0x36,0xCD,0x79,0x1B,0x4C,0xB2,0xB2,0x84,
           0x7E,0x35,0x22,0x2D,0x3C,0xB6,0xF1,0x10,
           0x73,0x06,0x72,0x0C,0xD8,0x40,0xC6,0xE2,
           0x82,0xD5,0x47,0xF8,0x45,0x02,0xC9,0xA0,
           0x91,0xF6,0x21,0x34,0x52,0x6B,0xEB,0x73,
           0x42,0x11,0xA4,0x1E,0x08,0x6B,0xD2,0x8A,
           0x76,0xE3,0xFA,0x85,0xA8,0x7F,0x89,0xDF,
           0xEB,0xE8,0x4F,0x51,0xB0,0x54,0x6E,0xC9,
           0x00,0x00,0x00,0x00,0xF1,0x60,0x2C,0x21,
           0xB9,0xEE,0x5A,0x12,0x18,0xED,0x07,0x9E,
           0x0D,0x10,0xFC,0x3C,0x72,0xCD,0x5B,0x10,
           0xE2,0xC2,0x11,0x94,0x94,0x3C,0x6A,0xCE,
           0x7C,0xD0,0x52,0x07,0x32,0x6B,0xEF,0xAA,
           0x7A,0x4B,0xD6,0x3A,0x18,0x35,0xE8,0x2B,
           0xFE,0xE9,0x0D,0xF5,0x11,0x01,0xD1,0x4C,
           0x24,0x0B,0xC4,0xC7,0x6A,0xF3,0x26,0xB8,
           0x6E,0x17,0x4F,0xA0,0x61,0x54,0x85,0x4B,
           0x84,0x6C,0xDD,0x94,0xAC,0x60,0x07,0xD8,
           0x78,0xCD,0xFD,0x78,0x33,0xC7,0xB2,0xD1,
           0xF1,0x7A,0xBE,0x5F,0xA9,0x99,0x0F,0xE9,
           0x1B,0xF9,0x95,0x17,0xBB,0xF7,0x41,0x8A,
           0x84,0xA5,0x3B,0xA0,0xC3,0xBD,0x62,0xC4,
           0x16,0xC3,0x56,0x5C,0xCE,0xDE,0x86,0xD9,
           0xB3,0xB3,0x10,0xB5,0x10,0xEE,0x5A,0xE1,
           0xB6,0x95,0xF4,0x1F,0x00,0x00,0x00,0x00,
           0xF9,0x91,0xAE,0xCD,0x61,0xA5,0x8B,0xD4,
           0xDA,0x1F,0xC2,0x97,0x91,0x72,0x22,0x55,
           0xF7,0x4F,0xAF,0x79,0x53,0x1D,0x28,0xF6,
           0x01,0xE0,0xD1,0x96,0x0F,0x0E,0x3C,0xD4,
           0x20,0x9E,0x43,0x96,0x01,0x4D,0x42,0x8C,
           0x78,0x5E,0xCC,0xE3,0xA5,0x65,0xAF,0x4A,
           0xD9,0xE4,0xBD,0x13,0x80,0xF8,0x7F,0x4B,
           0xE5,0x74,0x5C,0x51,0x0F,0xB0,0x50,0x93,
           0x8D,0xA9,0xA8,0xD2,0xEC,0x59,0x56,0x12,
           0xD9,0x18,0xC1,0x0E,0x4C,0x85,0x59,0xFE,
           0x8E,0x9B,0x0F,0x00,0x58,0xF4,0xFE,0x84,
           0x36,0x90,0x27,0x92,0xB0,0xDD,0x0F,0xB8,
           0x23,0x87,0x16,0xC8,0xD2,0x21,0x39,0x84,
           0x17,0x24,0x8F,0xB3,0x7C,0x39,0x33,0xD0,
           0xD7,0xBD,0x76,0xF2,0x8A,0xBA,0xCE,0x66,
           0xDE,0x98,0xE8,0x6A,0x2B,0x7C,0x38,0x41,
           0x00,0x00,0x00,0x00,0xE1,0x34,0x07,0x45,
           0x19,0x30,0xC0,0xC3,0xEC,0x82,0x88,0x6E,
           0x8C,0x39,0xC0,0xBA,0xAC,0x0B,0x34,0x2A,
           0x00,0xB5,0x32,0xED,0xAE,0xA0,0xAB,0x79,
           0x92,0xE7,0x61,0x67,0xA3,0xC4,0x35,0x3A,
           0x55,0x38,0x0C,0x37,0x06,0xE9,0xE1,0x34,
           0x12,0x41,0xEA,0xB2,0x62,0x31,0xA5,0x26,
           0x8A,0x04,0xB2,0x46,0x95,0xCB,0x48,0xCC,
           0xE4,0x81,0x7C,0x15,0x66,0x23,0x2D,0x30,
           0xD5,0xA0,0xEE,0x6D,0x2F,0x0B,0x18,0x9B,
           0xBE,0x98,0xC5,0x2A,0xDA,0x24,0x5F,0xF8,
           0xA5,0xEC,0xFB,0x83,0x76,0x2F,0x8C,0x16,
           0x21,0x4E,0xEA,0x72,0xED,0x81,0xBA,0xC0,
           0x7D,0x19,0x22,0x9A,0x01,0xF3,0x67,0x3B,
           0x01,0xB3,0x2F,0xE1,0xDB,0x4F,0xCA,0xC7,
           0x14,0x8C,0x55,0x3C,0x0B,0x0C,0xB0,0x7C,
           0x97,0xC5,0x02,0x8E,0x00,0x00,0x00,0x00,
           0x91,0x24,0x79,0x59,0x78,0x0B,0x98,0x3B,
           0x2C,0xC3,0xA5,0x1F,0x1D,0x07,0xC7,0xD6,
           0x03,0xF4,0xC6,0x2B,0x2A,0x27,0xB2,0xCB,
           0xB9,0xE8,0xDB,0xE8,0x36,0x04,0x67,0x6A,
           0xCF,0x46,0x50,0x50,0xD7,0xD3,0x24,0x98,
           0x9C,0x20,0xE1,0x26,0xE7,0x22,0x2A,0xD6,
           0x61,0xBD,0xA9,0xD2,0x86,0x81,0x44,0xAE,
           0x12,0x31,0xDB,0xEF,0xC3,0x02,0xCA,0xC1,
           0xB0,0x2F,0x8E,0x2E,0x4B,0x66,0x9A,0x8E,
           0xD9,0x93,0x43,0xF7,0x51,0x69,0x5A,0x5E,
           0x74,0x22,0xEE,0x6B,0x20,0x03,0x61,0xDD,
           0xDE,0xFD,0x72,0x8C,0xA1,0xA4,0xDC,0xAD,
           0x6F,0x99,0x62,0x8B,0xD4,0x4E,0x4C,0xAD,
           0xD8,0x89,0x72,0xD9,0xCF,0x3C,0xC4,0x19,
           0x05,0xBC,0x6A,0x8B,0x15,0x10,0x56,0x6B,
           0x5D,0x5D,0x4F,0x8F,0x26,0xDC,0x1C,0x42,
           0x62,0x16,0x66,0x0B,0x81,0xB2,0x47,0x0F,
           0xDA,0x56,0xD9,0xA5,0x96,0x1B,0x0D,0x82,
           0xEF,0x52,0x10,0x4B,0xD9,0x0A,0x67,0x28,
           0xBC,0x1F,0x8D,0x4B,0xF1,0xB2,0x87,0x00,
           0xC1,0x6E,0x0F,0x08,0xB9,0x1C,0x83,0xBA,
           0x01,0xF4,0x22,0x73,0x16,0x18,0x8B,0x1D,
           0x63,0x00,0xCC,0x78,0x6C,0xF8,0xE5,0x3B,
           0x11,0x45,0xE9,0x66,0x03,0x88,0x7A,0x51,
           0x3D,0x63,0x2A,0x49,0x9A,0xF8,0xF6,0x3D,
           0xE1,0xCB,0x8F,0x40,0x47,0x54,0x5B,0x94,
           0x86,0x2C,0x8B,0xB9,0x86,0xCA,0x0D,0x66,
           0x02,0x95,0x54,0xFD,0x76,0x55,0x32,0x20,
           0xFB,0x76,0xD2,0x36,0x39,0xAF,0x0C,0x82,
           0xDE,0x59,0x88,0xD9,0x1F,0xD2,0x68,0x20,
           0x67,0xDE,0x5A,0xC2,0x56,0x40,0x52,0xF4,
           0x9C,0x36,0xDB,0xE1,0xA7,0x9F,0x0E,0x52,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00
    };

BYTE PublicKeyData[] = 
    {
           0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
           0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
           0x01,0x00,0x01,0x00,0xA7,0xC1,0xB4,0xFE,
           0x8C,0x26,0x9A,0xCF,0xEC,0xDB,0x9F,0xAA,
           0xF0,0xCF,0x82,0xB8,0xCE,0x0E,0xD8,0x22,
           0x6D,0xDA,0x49,0xD6,0x8A,0x1C,0xFD,0x5E,
           0xAD,0xB4,0xA0,0x3E,0xA6,0xEA,0xB6,0x20,
           0xF0,0xB9,0x2C,0xC3,0x48,0x48,0x1E,0xD2,
           0x2B,0x22,0xA0,0xAF,0xA8,0x3E,0x41,0x95,
           0xB8,0x3D,0x04,0xBF,0x9E,0x58,0x3D,0x7C,
           0xF5,0x92,0x2E,0x0C,0xFD,0x85,0x67,0xC3,
           0xB2,0xE7,0x33,0x7F,0x7E,0x46,0xFC,0x2A,
           0x10,0x77,0xB4,0xB6,0x7B,0x2B,0x7C,0x70,
           0x70,0x33,0x94,0x51,0x0F,0x64,0x9E,0x1A,
           0x37,0x4D,0x5C,0x49,0xB9,0x7E,0xCE,0x1D,
           0x47,0xC7,0x72,0x90,0x61,0xC4,0xEE,0xEF,
           0xF6,0x2C,0x47,0x36,0xCD,0x4B,0x23,0x96,
           0xB2,0x24,0x2C,0xC5,0x6D,0x62,0x08,0x43,
           0x3E,0x16,0xB8,0x86,0x32,0xF3,0x12,0x91,
           0xA2,0xF4,0x42,0x19,0xCC,0xC5,0x5E,0x9C,
           0x75,0x25,0x9C,0x84,0x5A,0xBC,0xE0,0xCE,
           0x15,0x62,0xD5,0xCE,0x3E,0x30,0x1C,0x48,
           0xFA,0x1E,0x67,0xE9,0x06,0xA5,0x9E,0x9C,
           0xAB,0xEE,0x16,0xAA,0x44,0x9D,0x56,0x35,
           0xCA,0xD9,0x5A,0xC4,0xFB,0xA4,0x9A,0x39,
           0xE4,0xFD,0x8B,0x58,0xF1,0xE8,0x0C,0x45,
           0x76,0x80,0x7E,0xBB,0x57,0x68,0x32,0xC9,
           0x9C,0x3E,0x67,0x55,0x28,0xBD,0xB9,0xB4,
           0x6D,0x64,0xF1,0xB6,0x11,0x6B,0x0D,0xE9,
           0xF2,0x04,0x08,0xDB,0x2B,0x42,0x9C,0xC5,
           0x17,0x0D,0x86,0xE9,0x40,0x32,0x75,0x6E,
           0x51,0x7D,0xF6,0x4C,0x7E,0xA8,0x97,0x3A,
           0x95,0x31,0x20,0x7A,0x66,0xBF,0xE2,0x79,
           0xCF,0xC5,0x4A,0xA1,0xDF,0x9A,0x1E,0x52,
           0x8C,0x2B,0xF9,0xAB,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00
    };

#define PK_KEY_TEST_BIT_LENGTH 2048

#define PK_REPEAT_LOOP 5

BOOL pktest()
{
	BYTE* text1;
	BYTE* text2;
	BYTE* text3;
	BYTE* temp1;
	BYTE* temp2;
	BYTE* prvKey;
	BYTE* pubKey;
	DWORD pubKeySize, prvKeySize;
	DWORD bits;
	DWORD dwStart,dwEnd,i;
	DWORD keyLength,dataLength;
	DWORD result1,result2;
    LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY)PublicKeyData;
    
    bits = PK_KEY_TEST_BIT_LENGTH;
	result1 = BSafeComputeKeySizes( &pubKeySize, &prvKeySize, &bits );
    ASSERT( result1 );

    ASSERT( pubKeySize == sizeof(PublicKeyData) );
    ASSERT( prvKeySize == sizeof(PrivateKeyData) );

    keyLength = XcPKGetKeyLen( PublicKeyData );
    if (keyLength != pPubKey->keylen)
    {
        XDBGWRN("Crypto Test", " XcPKGetKeyLen return bad length %d!", keyLength);
        return FALSE;
    }

    dataLength = pPubKey->datalen;
    
    XDBGTRC("Crypto Test", "XcPKEncPublic Keylen = %d, datalen = %d", keyLength, dataLength);
    
	text1 = (BYTE*)_alloca( keyLength );
	text2 = (BYTE*)_alloca( keyLength );
	text3 = (BYTE*)_alloca( keyLength );
	temp1 = (BYTE*)_alloca( keyLength );
	temp2 = (BYTE*)_alloca( keyLength );

    RtlZeroMemory( text1, keyLength );
	XNetRandom( text1, dataLength );
	memcpy( text2, text1, keyLength );
	memcpy( text3, text1, keyLength );

    dwStart = GetTickCount();
    for(i=0; i<PK_REPEAT_LOOP; ++i)
    {
        result1 = XcPKEncPublic( PublicKeyData, text1, temp1 );
        result2 = BSafeEncPublic((LPBSAFE_PUB_KEY)PublicKeyData, text2, temp2);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcPKEncPublic", "%d times for %d byte key took %d ms", PK_REPEAT_LOOP * 2, dataLength, dwEnd );
    
    if (!result1 || !result2)
    {
        XDBGWRN("Crypto Test", " XcPKEncPublic failed %d %d!", result1, result2);
        return FALSE;
    }
    
    if (memcmp( temp1, temp2, keyLength ) != 0)
    {
        XDBGWRN("Crypto Test", " XcPKEncPublic result compare failed!");
        return FALSE;
    }
    
    dwStart = GetTickCount();
    for(i=0; i<PK_REPEAT_LOOP; ++i)
    {
        result1 = XcPKDecPrivate( PrivateKeyData, temp1, text1 );
        result2 = BSafeDecPrivate((LPBSAFE_PRV_KEY)PrivateKeyData, temp2, text2 );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcPKDecPrivate", "%d times for %d byte key took %d ms", PK_REPEAT_LOOP * 2, dataLength, dwEnd );
    
    if (!result1 || !result2)
    {
        XDBGWRN("Crypto Test", " XcPKDecPrivate failed %d %d!", result1, result2);
        return FALSE;
    }
    
    if (memcmp( text1, text2, keyLength ) != 0)
    {
        XDBGWRN("Crypto Test", " XcPKDecPrivate result compare failed!");
        return FALSE;
    }
    
    if (memcmp( text1, text3, keyLength ) != 0)
    {
        XDBGWRN("Crypto Test", " XcPKDecPrivate result compare failed!");
        return FALSE;
    }
    
    return TRUE;
}

#define DES_TEST_LENGTH 512

#define DES_REPEAT_LOOP 1000

#define DES_NUM_KA_VECTORS 19

BOOL destest()
{
	BYTE text[DES_TEST_LENGTH];
	BYTE saveText[DES_TEST_LENGTH];
	BYTE saveCText[DES_TEST_LENGTH];
	BYTE key[XC_SERVICE_DES_KEYSIZE];
	BYTE saveKey[XC_SERVICE_DES_KEYSIZE];
	BYTE iv[XC_SERVICE_DES_BLOCKLEN];
	BYTE fb[XC_SERVICE_DES_BLOCKLEN];
	DESTable desTable;
	BYTE XCDESTable[XC_SERVICE_DES_TABLESIZE];
	DWORD dwStart,dwEnd,i,j;

	BYTE ka_keys[DES_NUM_KA_VECTORS][XC_SERVICE_DES_KEYSIZE] = 
		{{0x7C, 0xA1, 0x10, 0x45, 0x4A, 0x1A, 0x6E, 0x57}, 
		 {0x01, 0x31, 0xD9, 0x61, 0x9D, 0xC1, 0x37, 0x6E}, 
		 {0x07, 0xA1, 0x13, 0x3E, 0x4A, 0x0B, 0x26, 0x86}, 
		 {0x38, 0x49, 0x67, 0x4C, 0x26, 0x02, 0x31, 0x9E}, 
		 {0x04, 0xB9, 0x15, 0xBA, 0x43, 0xFE, 0xB5, 0xB6}, 
		 {0x01, 0x13, 0xB9, 0x70, 0xFD, 0x34, 0xF2, 0xCE}, 
		 {0x01, 0x70, 0xF1, 0x75, 0x46, 0x8F, 0xB5, 0xE6}, 
		 {0x43, 0x29, 0x7F, 0xAD, 0x38, 0xE3, 0x73, 0xFE}, 
		 {0x07, 0xA7, 0x13, 0x70, 0x45, 0xDA, 0x2A, 0x16}, 
		 {0x04, 0x68, 0x91, 0x04, 0xC2, 0xFD, 0x3B, 0x2F}, 
		 {0x37, 0xD0, 0x6B, 0xB5, 0x16, 0xCB, 0x75, 0x46}, 
		 {0x1F, 0x08, 0x26, 0x0D, 0x1A, 0xC2, 0x46, 0x5E}, 
		 {0x58, 0x40, 0x23, 0x64, 0x1A, 0xBA, 0x61, 0x76}, 
		 {0x02, 0x58, 0x16, 0x16, 0x46, 0x29, 0xB0, 0x07}, 
		 {0x49, 0x79, 0x3E, 0xBC, 0x79, 0xB3, 0x25, 0x8F}, 
		 {0x4F, 0xB0, 0x5E, 0x15, 0x15, 0xAB, 0x73, 0xA7}, 
		 {0x49, 0xE9, 0x5D, 0x6D, 0x4C, 0xA2, 0x29, 0xBF}, 
		 {0x01, 0x83, 0x10, 0xDC, 0x40, 0x9B, 0x26, 0xD6}, 
		 {0x1C, 0x58, 0x7F, 0x1C, 0x13, 0x92, 0x4F, 0xEF}} ;

	BYTE ka_pts[DES_NUM_KA_VECTORS][8] = 
		{{0x01, 0xA1, 0xD6, 0xD0, 0x39, 0x77, 0x67, 0x42}, 
		 {0x5C, 0xD5, 0x4C, 0xA8, 0x3D, 0xEF, 0x57, 0xDA}, 
		 {0x02, 0x48, 0xD4, 0x38, 0x06, 0xF6, 0x71, 0x72}, 
		 {0x51, 0x45, 0x4B, 0x58, 0x2D, 0xDF, 0x44, 0x0A}, 
		 {0x42, 0xFD, 0x44, 0x30, 0x59, 0x57, 0x7F, 0xA2}, 
		 {0x05, 0x9B, 0x5E, 0x08, 0x51, 0xCF, 0x14, 0x3A}, 
		 {0x07, 0x56, 0xD8, 0xE0, 0x77, 0x47, 0x61, 0xD2}, 
		 {0x76, 0x25, 0x14, 0xB8, 0x29, 0xBF, 0x48, 0x6A}, 
		 {0x3B, 0xDD, 0x11, 0x90, 0x49, 0x37, 0x28, 0x02}, 
		 {0x26, 0x95, 0x5F, 0x68, 0x35, 0xAF, 0x60, 0x9A}, 
		 {0x16, 0x4D, 0x5E, 0x40, 0x4F, 0x27, 0x52, 0x32}, 
		 {0x6B, 0x05, 0x6E, 0x18, 0x75, 0x9F, 0x5C, 0xCA}, 
		 {0x00, 0x4B, 0xD6, 0xEF, 0x09, 0x17, 0x60, 0x62}, 
		 {0x48, 0x0D, 0x39, 0x00, 0x6E, 0xE7, 0x62, 0xF2}, 
		 {0x43, 0x75, 0x40, 0xC8, 0x69, 0x8F, 0x3C, 0xFA}, 
		 {0x07, 0x2D, 0x43, 0xA0, 0x77, 0x07, 0x52, 0x92}, 
		 {0x02, 0xFE, 0x55, 0x77, 0x81, 0x17, 0xF1, 0x2A}, 
		 {0x1D, 0x9D, 0x5C, 0x50, 0x18, 0xF7, 0x28, 0xC2}, 
		 {0x30, 0x55, 0x32, 0x28, 0x6D, 0x6F, 0x29, 0x5A}} ;

	BYTE ka_cts[DES_NUM_KA_VECTORS][8] = 
		{{0x69, 0x0F, 0x5B, 0x0D, 0x9A, 0x26, 0x93, 0x9B},
		 {0x7A, 0x38, 0x9D, 0x10, 0x35, 0x4B, 0xD2, 0x71},
		 {0x86, 0x8E, 0xBB, 0x51, 0xCA, 0xB4, 0x59, 0x9A},
		 {0x71, 0x78, 0x87, 0x6E, 0x01, 0xF1, 0x9B, 0x2A},
		 {0xAF, 0x37, 0xFB, 0x42, 0x1F, 0x8C, 0x40, 0x95},
		 {0x86, 0xA5, 0x60, 0xF1, 0x0E, 0xC6, 0xD8, 0x5B},
		 {0x0C, 0xD3, 0xDA, 0x02, 0x00, 0x21, 0xDC, 0x09},
		 {0xEA, 0x67, 0x6B, 0x2C, 0xB7, 0xDB, 0x2B, 0x7A},
		 {0xDF, 0xD6, 0x4A, 0x81, 0x5C, 0xAF, 0x1A, 0x0F},
		 {0x5C, 0x51, 0x3C, 0x9C, 0x48, 0x86, 0xC0, 0x88},
		 {0x0A, 0x2A, 0xEE, 0xAE, 0x3F, 0xF4, 0xAB, 0x77},
		 {0xEF, 0x1B, 0xF0, 0x3E, 0x5D, 0xFA, 0x57, 0x5A},
		 {0x88, 0xBF, 0x0D, 0xB6, 0xD7, 0x0D, 0xEE, 0x56},
		 {0xA1, 0xF9, 0x91, 0x55, 0x41, 0x02, 0x0B, 0x56},
		 {0x6F, 0xBF, 0x1C, 0xAF, 0xCF, 0xFD, 0x05, 0x56},
		 {0x2F, 0x22, 0xE4, 0x9B, 0xAB, 0x7C, 0xA1, 0xAC},
		 {0x5A, 0x6B, 0x61, 0x2C, 0xC2, 0x6C, 0xCE, 0x4A},
		 {0x5F, 0x4C, 0x03, 0x8E, 0xD1, 0x2B, 0x2E, 0x41},
		 {0x63, 0xFA, 0xC0, 0xD0, 0x34, 0xD9, 0xF7, 0x93}} ;

	BYTE zeroes[] = {0, 0, 0, 0, 0, 0, 0, 0};

    
    ASSERT( sizeof(desTable) == XC_SERVICE_DES_TABLESIZE );
    
	XNetRandom( text, DES_TEST_LENGTH );
	XNetRandom( key, XC_SERVICE_DES_KEYSIZE );
	XNetRandom( iv, XC_SERVICE_DES_BLOCKLEN );

	memcpy(saveKey, key, XC_SERVICE_DES_KEYSIZE);
    XcDESKeyParity(key, XC_SERVICE_DES_KEYSIZE);

    desparityonkey(saveKey, XC_SERVICE_DES_KEYSIZE);
    if (memcmp( key, saveKey, XC_SERVICE_DES_KEYSIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " desparityonkey result compare failed!");
        return FALSE;
    }

    XcKeyTable(XC_SERVICE_DES_CIPHER, XCDESTable, key);

    deskey(&desTable, saveKey);
    if (memcmp( (BYTE*)&desTable, XCDESTable, XC_SERVICE_DES_TABLESIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " deskey result compare failed!");
        return FALSE;
    }

	memcpy(saveText, text, DES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveText, DES_TEST_LENGTH);
    	XcBlockCryptCBC(XC_SERVICE_DES_CIPHER, DES_TEST_LENGTH, text, text, XCDESTable, XC_SERVICE_ENCRYPT, fb);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("ROM DES Enc", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

	memcpy(saveCText, text, DES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveCText, DES_TEST_LENGTH);
        for (j=0; j<DES_TEST_LENGTH; j+= 8)
        {
        	CBC(des, 8, text+j, text+j, &desTable, DECRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("RSA DES Dec", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveText, DES_TEST_LENGTH);
        for (j=0; j<DES_TEST_LENGTH; j+= 8)
        {
        	CBC(des, 8, text+j, text+j, &desTable, ENCRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
    XDBGENT("RSA DES Enc", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveCText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveCText, DES_TEST_LENGTH);
    	XcBlockCryptCBC(XC_SERVICE_DES_CIPHER, DES_TEST_LENGTH, text, text, XCDESTable, XC_SERVICE_DECRYPT, fb);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("ROM DES Dec", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    for (i=0; i<DES_NUM_KA_VECTORS; i++) {
        memcpy (key, ka_keys[i], XC_SERVICE_DES_KEYSIZE);
        memcpy(fb,zeroes,8);
    	memcpy(text, ka_pts[i], 8);

        XcDESKeyParity(key, XC_SERVICE_DES_KEYSIZE);
        XcKeyTable(XC_SERVICE_DES_CIPHER, XCDESTable, key);

    	XcBlockCryptCBC(XC_SERVICE_DES_CIPHER, 8, text, text, XCDESTable, XC_SERVICE_ENCRYPT, fb);
        if (memcmp( ka_cts[i], text, 8 ) != 0)
        {
            XDBGWRN("Crypto Test", " Known Answer DES encryption compare failed!");
            return FALSE;
        };

        memcpy(fb,zeroes,8);
    	XcBlockCryptCBC(XC_SERVICE_DES_CIPHER, 8, text, text, XCDESTable, XC_SERVICE_DECRYPT, fb);
        if (memcmp( ka_pts[i], text, 8 ) != 0)
        {
            XDBGWRN("Crypto Test", " Known Answer DES decryption compare failed!");
            return FALSE;
        };
    };

    return TRUE;
}

#define DES3_NUM_KA_VECTORS 19
#define DES3_NUM_KA_IVS 3

BOOL des3test()
{
	BYTE text[DES_TEST_LENGTH];
	BYTE saveText[DES_TEST_LENGTH];
	BYTE saveCText[DES_TEST_LENGTH];
	BYTE key[XC_SERVICE_DES3_KEYSIZE];
	BYTE saveKey[XC_SERVICE_DES3_KEYSIZE];
	BYTE iv[XC_SERVICE_DES_BLOCKLEN];
	BYTE fb[XC_SERVICE_DES_BLOCKLEN];
	DES3TABLE desTable;
	BYTE XCDES3Table[XC_SERVICE_DES3_TABLESIZE];
	DWORD dwStart,dwEnd,i,j;

	BYTE ka_keys[DES3_NUM_KA_VECTORS][XC_SERVICE_DES3_KEYSIZE] = 
		{{0x7c, 0xa1, 0x10, 0x45, 0x4a, 0x1a, 0x6e, 0x57},
		 {0x01, 0x31, 0xd9, 0x61, 0x9d, 0xc1, 0x37, 0x6e},
		 {0x07, 0xa1, 0x13, 0x3e, 0x4a, 0x0b, 0x26, 0x86},
		 {0x38, 0x49, 0x67, 0x4c, 0x26, 0x02, 0x31, 0x9e},
		 {0x04, 0xb9, 0x15, 0xba, 0x43, 0xfe, 0xb5, 0xb6},
		 {0x01, 0x13, 0xb9, 0x70, 0xfd, 0x34, 0xf2, 0xce},
		 {0x01, 0x70, 0xf1, 0x75, 0x46, 0x8f, 0xb5, 0xe6},
		 {0x43, 0x29, 0x7f, 0xad, 0x38, 0xe3, 0x73, 0xfe},
		 {0x07, 0xa7, 0x13, 0x70, 0x45, 0xda, 0x2a, 0x16},
		 {0x04, 0x68, 0x91, 0x04, 0xc2, 0xfd, 0x3b, 0x2f},
		 {0x37, 0xd0, 0x6b, 0xb5, 0x16, 0xcb, 0x75, 0x46},
		 {0x1f, 0x08, 0x26, 0x0d, 0x1a, 0xc2, 0x46, 0x5e},
		 {0x58, 0x40, 0x23, 0x64, 0x1a, 0xba, 0x61, 0x76},
		 {0x02, 0x58, 0x16, 0x16, 0x46, 0x29, 0xb0, 0x07},
		 {0x49, 0x79, 0x3e, 0xbc, 0x79, 0xb3, 0x25, 0x8f},
		 {0x4f, 0xb0, 0x5e, 0x15, 0x15, 0xab, 0x73, 0xa7},
		 {0x49, 0xe9, 0x5d, 0x6d, 0x4c, 0xa2, 0x29, 0xbf},
		 {0x01, 0x83, 0x10, 0xdc, 0x40, 0x9b, 0x26, 0xd6},
		 {0x1c, 0x58, 0x7f, 0x1c, 0x13, 0x92, 0x4f, 0xef}};

	BYTE ka_pts[DES3_NUM_KA_VECTORS][8] = 
		{{0x01, 0xa1, 0xd6, 0xd0, 0x39, 0x77, 0x67, 0x42}, 
		 {0x5c, 0xd5, 0x4c, 0xa8, 0x3d, 0xef, 0x57, 0xda}, 
		 {0x02, 0x48, 0xd4, 0x38, 0x06, 0xf6, 0x71, 0x72}, 
		 {0x51, 0x45, 0x4b, 0x58, 0x2d, 0xdf, 0x44, 0x0a}, 
		 {0x42, 0xfd, 0x44, 0x30, 0x59, 0x57, 0x7f, 0xa2}, 
		 {0x05, 0x9b, 0x5e, 0x08, 0x51, 0xcf, 0x14, 0x3a}, 
		 {0x07, 0x56, 0xd8, 0xe0, 0x77, 0x47, 0x61, 0xd2}, 
		 {0x76, 0x25, 0x14, 0xb8, 0x29, 0xbf, 0x48, 0x6a}, 
		 {0x3b, 0xdd, 0x11, 0x90, 0x49, 0x37, 0x28, 0x02}, 
		 {0x26, 0x95, 0x5f, 0x68, 0x35, 0xaf, 0x60, 0x9a}, 
		 {0x16, 0x4d, 0x5e, 0x40, 0x4f, 0x27, 0x52, 0x32}, 
		 {0x6b, 0x05, 0x6e, 0x18, 0x75, 0x9f, 0x5c, 0xca}, 
		 {0x00, 0x4b, 0xd6, 0xef, 0x09, 0x17, 0x60, 0x62}, 
		 {0x48, 0x0d, 0x39, 0x00, 0x6e, 0xe7, 0x62, 0xf2}, 
		 {0x43, 0x75, 0x40, 0xc8, 0x69, 0x8f, 0x3c, 0xfa}, 
		 {0x07, 0x2d, 0x43, 0xa0, 0x77, 0x07, 0x52, 0x92}, 
		 {0x02, 0xfe, 0x55, 0x77, 0x81, 0x17, 0xf1, 0x2a}, 
		 {0x1d, 0x9d, 0x5c, 0x50, 0x18, 0xf7, 0x28, 0xc2}, 
		 {0x30, 0x55, 0x32, 0x28, 0x6d, 0x6f, 0x29, 0x5a}};

	BYTE ka_cts[DES3_NUM_KA_IVS][DES3_NUM_KA_VECTORS][8] = 
		{
		{{0x69, 0x0f, 0x5b, 0x0d, 0x9a, 0x26, 0x93, 0x9b}, 
		 {0x7a, 0x38, 0x9d, 0x10, 0x35, 0x4b, 0xd2, 0x71}, 
		 {0x86, 0x8e, 0xbb, 0x51, 0xca, 0xb4, 0x59, 0x9a}, 
		 {0x71, 0x78, 0x87, 0x6e, 0x01, 0xf1, 0x9b, 0x2a}, 
		 {0xaf, 0x37, 0xfb, 0x42, 0x1f, 0x8c, 0x40, 0x95}, 
		 {0x86, 0xa5, 0x60, 0xf1, 0x0e, 0xc6, 0xd8, 0x5b}, 
		 {0x0c, 0xd3, 0xda, 0x02, 0x00, 0x21, 0xdc, 0x09}, 
		 {0xea, 0x67, 0x6b, 0x2c, 0xb7, 0xdb, 0x2b, 0x7a}, 
		 {0xdf, 0xd6, 0x4a, 0x81, 0x5c, 0xaf, 0x1a, 0x0f}, 
		 {0x5c, 0x51, 0x3c, 0x9c, 0x48, 0x86, 0xc0, 0x88}, 
		 {0x0a, 0x2a, 0xee, 0xae, 0x3f, 0xf4, 0xab, 0x77}, 
		 {0xef, 0x1b, 0xf0, 0x3e, 0x5d, 0xfa, 0x57, 0x5a}, 
		 {0x88, 0xbf, 0x0d, 0xb6, 0xd7, 0x0d, 0xee, 0x56}, 
		 {0xa1, 0xf9, 0x91, 0x55, 0x41, 0x02, 0x0b, 0x56}, 
		 {0x6f, 0xbf, 0x1c, 0xaf, 0xcf, 0xfd, 0x05, 0x56}, 
		 {0x2f, 0x22, 0xe4, 0x9b, 0xab, 0x7c, 0xa1, 0xac}, 
		 {0x5a, 0x6b, 0x61, 0x2c, 0xc2, 0x6c, 0xce, 0x4a}, 
		 {0x5f, 0x4c, 0x03, 0x8e, 0xd1, 0x2b, 0x2e, 0x41}, 
		 {0x63, 0xfa, 0xc0, 0xd0, 0x34, 0xd9, 0xf7, 0x93}},

		{{0x89, 0x20, 0x2f, 0x22, 0x4f, 0x1f, 0x22, 0x61}, 
		 {0x6d, 0xda, 0x0d, 0xe9, 0x9d, 0x3c, 0x86, 0xb9}, 
		 {0x82, 0x00, 0x61, 0x6c, 0x58, 0x9b, 0xc7, 0xaa}, 
		 {0x64, 0x75, 0x72, 0x92, 0xfe, 0xbc, 0xca, 0xd1}, 
		 {0x20, 0x4f, 0xc6, 0x12, 0x39, 0x92, 0xd4, 0xe9}, 
		 {0x1f, 0xa8, 0x6f, 0x6f, 0x73, 0x56, 0x03, 0xa3}, 
		 {0x65, 0xe0, 0x5d, 0x62, 0xb3, 0x5a, 0xa3, 0x65}, 
		 {0x95, 0xc0, 0xf9, 0xe5, 0x95, 0xae, 0xc2, 0xff}, 
		 {0x12, 0x73, 0x59, 0xc2, 0x0e, 0x10, 0xe2, 0x5a}, 
		 {0xb0, 0x89, 0xd9, 0x0f, 0x84, 0xef, 0x0c, 0x4c}, 
		 {0x32, 0xbb, 0xdd, 0x67, 0xd4, 0xe6, 0x6d, 0xd6}, 
		 {0xb4, 0x87, 0x30, 0x81, 0xfd, 0xeb, 0xc8, 0x1d}, 
		 {0x98, 0x8f, 0xe2, 0xe8, 0xe1, 0x75, 0x5e, 0x78}, 
		 {0xee, 0x6c, 0x0f, 0xeb, 0xb2, 0x12, 0xb2, 0x18}, 
		 {0xc0, 0x3a, 0xdc, 0x2b, 0x6a, 0xa8, 0x5b, 0x5b}, 
		 {0x09, 0x6a, 0x41, 0x36, 0xe0, 0xf6, 0x5f, 0x76}, 
		 {0xbf, 0x4d, 0xa6, 0xaa, 0x59, 0xed, 0x57, 0x51}, 
		 {0xaa, 0xb9, 0x33, 0x90, 0xe1, 0x3d, 0x3b, 0xb3}, 
		 {0xdb, 0x3c, 0x41, 0x06, 0xc5, 0xdb, 0x56, 0x48}},

		{{0x58, 0x5a, 0x1e, 0x8d, 0x89, 0x70, 0x5d, 0x10},
		 {0x99, 0x98, 0x5b, 0x67, 0xb5, 0x98, 0xbd, 0x25},
		 {0xd2, 0xff, 0x67, 0x46, 0x13, 0x77, 0xfb, 0xb5},
		 {0x93, 0xbd, 0x8b, 0xee, 0xea, 0x23, 0x10, 0xfc},
		 {0x6b, 0xfb, 0x4d, 0xf0, 0x56, 0x9c, 0xeb, 0xce},
		 {0x0b, 0xe3, 0x55, 0x87, 0x38, 0xc6, 0xd7, 0xc3},
		 {0x3b, 0xfc, 0x9a, 0x3f, 0x03, 0x4d, 0xa2, 0x92},
		 {0xea, 0x9a, 0xb3, 0x58, 0x5f, 0x16, 0x65, 0x86},
		 {0x95, 0x3a, 0x36, 0xff, 0x13, 0xa0, 0x89, 0x06},
		 {0x08, 0xbd, 0x60, 0xf6, 0xf8, 0x0d, 0x6f, 0xad},
		 {0x83, 0xa3, 0x06, 0x06, 0xfc, 0x78, 0xd7, 0x40},
		 {0x64, 0x45, 0x79, 0x9c, 0x9b, 0x70, 0x16, 0x94},
		 {0x1e, 0x1f, 0xdd, 0x86, 0x60, 0xa7, 0x5b, 0xb5},
		 {0x60, 0xba, 0xe5, 0x9c, 0x51, 0x76, 0x73, 0x94},
		 {0x82, 0x6e, 0xc7, 0xe0, 0x2f, 0x48, 0x68, 0x85},
		 {0x9e, 0x30, 0x37, 0x7b, 0x7a, 0x39, 0xd5, 0xd3},
		 {0x64, 0xb7, 0x73, 0x06, 0x32, 0x1a, 0x93, 0x2c},
		 {0x3b, 0x17, 0xda, 0xff, 0x73, 0x3f, 0xcf, 0xb0},
		 {0x7f, 0x38, 0x21, 0x5d, 0x73, 0xb0, 0xee, 0x62}}};

	BYTE ka_ivs[DES3_NUM_KA_IVS][8] = 
		{{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		 {0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55},
		 {0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa}};

    
    ASSERT( sizeof(desTable) == XC_SERVICE_DES3_TABLESIZE );
    
	XNetRandom( text, DES_TEST_LENGTH );
	XNetRandom( key, XC_SERVICE_DES3_KEYSIZE );
	XNetRandom( iv, XC_SERVICE_DES_BLOCKLEN );

	memcpy(saveKey, key, XC_SERVICE_DES3_KEYSIZE);
    XcDESKeyParity(key, XC_SERVICE_DES3_KEYSIZE);

    desparityonkey(saveKey, XC_SERVICE_DES3_KEYSIZE);
    if (memcmp( key, saveKey, XC_SERVICE_DES3_KEYSIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " desparityonkey result compare failed!");
        return FALSE;
    }

    XcKeyTable(XC_SERVICE_DES3_CIPHER, XCDES3Table, key);

    tripledes3key(&desTable, saveKey);
    if (memcmp( (BYTE*)&desTable, XCDES3Table, XC_SERVICE_DES3_TABLESIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " tripledes3key result compare failed!");
        return FALSE;
    }

	memcpy(saveText, text, DES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveText, DES_TEST_LENGTH);
    	XcBlockCryptCBC(XC_SERVICE_DES3_CIPHER, DES_TEST_LENGTH, text, text, XCDES3Table, XC_SERVICE_ENCRYPT, fb);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("ROM 3DES Enc", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

	memcpy(saveCText, text, DES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveCText, DES_TEST_LENGTH);
        for (j=0; j<DES_TEST_LENGTH; j+= 8)
        {
        	CBC(tripledes, 8, text+j, text+j, &desTable, DECRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("RSA 3DES Dec", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveText, DES_TEST_LENGTH);
        for (j=0; j<DES_TEST_LENGTH; j+= 8)
        {
        	CBC(tripledes, 8, text+j, text+j, &desTable, ENCRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
    XDBGENT("RSA 3DES Enc", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveCText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveCText, DES_TEST_LENGTH);
    	XcBlockCryptCBC(XC_SERVICE_DES3_CIPHER, DES_TEST_LENGTH, text, text, XCDES3Table, XC_SERVICE_DECRYPT, fb);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("ROM 3DES Dec", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    for (i=0; i<DES3_NUM_KA_VECTORS; i++) {
        for (j=0; j<DES3_NUM_KA_IVS; j++) {
            memcpy (key, ka_keys[i], XC_SERVICE_DES_KEYSIZE);
            memcpy (key + XC_SERVICE_DES_KEYSIZE, ka_keys[i], XC_SERVICE_DES_KEYSIZE);
            memcpy (key + 2 * XC_SERVICE_DES_KEYSIZE, ka_keys[i], XC_SERVICE_DES_KEYSIZE);
            memcpy(fb,ka_ivs[j],8);
            memcpy(text, ka_pts[i], 8);

            XcDESKeyParity(key, XC_SERVICE_DES3_KEYSIZE);
            XcKeyTable(XC_SERVICE_DES3_CIPHER, XCDES3Table, key);

            XcBlockCryptCBC(XC_SERVICE_DES3_CIPHER, 8, text, text, XCDES3Table, XC_SERVICE_ENCRYPT, fb);
            if (memcmp( ka_cts[j][i], text, 8 ) != 0)
            {
                XDBGWRN("Crypto Test", " Known Answer tripleDES encryption compare failed!");
                return FALSE;
            };

            memcpy(fb,ka_ivs[j],8);
            XcBlockCryptCBC(XC_SERVICE_DES3_CIPHER, 8, text, text, XCDES3Table, XC_SERVICE_DECRYPT, fb);
            if (memcmp( ka_pts[i], text, 8 ) != 0)
            {
                XDBGWRN("Crypto Test", " Known Answer tripleDES decryption compare failed!");
                return FALSE;
            };
        };
    };


    return TRUE;
}

#define USE_GROUP1 1

#ifdef USE_GROUP0

#define DH_KEY_LENGTH 64

static unsigned char g_def_p[DH_KEY_LENGTH] =
    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34,
      0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1,
      0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
      0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51, 0xc2, 0x45,
      0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
      0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x3a, 0x36, 0x20,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    };

static unsigned char g_def_g[DH_KEY_LENGTH] =
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
    };

#else

#ifdef USE_GROUP1

#define DH_KEY_LENGTH 96

static unsigned char g_def_p[DH_KEY_LENGTH] =
    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34,
      0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1,
      0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
      0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
      0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd,
      0xef, 0x95, 0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b,
      0x30, 0x2b, 0x0a, 0x6d, 0xf2, 0x5f, 0x14, 0x37,
      0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51, 0xc2, 0x45,
      0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
      0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x3a, 0x36, 0x20,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    };

static unsigned char g_def_g[DH_KEY_LENGTH] =
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
    };

#else

#define DH_KEY_LENGTH 128

static unsigned char g_def_p[DH_KEY_LENGTH] =
     { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
       0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34,
       0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1,
       0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
       0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
       0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd,
       0xef, 0x95, 0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b,
       0x30, 0x2b, 0x0a, 0x6d, 0xf2, 0x5f, 0x14, 0x37,
       0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51, 0xc2, 0x45,
       0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
       0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x37, 0xed, 0x6b,
       0x0b, 0xff, 0x5c, 0xb6, 0xf4, 0x06, 0xb7, 0xed,
       0xee, 0x38, 0x6b, 0xfb, 0x5a, 0x89, 0x9f, 0xa5,
       0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b, 0x1f, 0xe6,
       0x49, 0x28, 0x66, 0x51, 0xec, 0xe6, 0x53, 0x81,
       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
     };

static unsigned char g_def_g[DH_KEY_LENGTH] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
     };

#endif

#endif

#define DH_REPEAT_LOOP 10

BOOL dhtest()
{
	DWORD dwStart,dwEnd,i,j;
	BYTE x[DH_KEY_LENGTH];
	BYTE gx[DH_KEY_LENGTH];
	BYTE y[DH_KEY_LENGTH];
	BYTE gy[DH_KEY_LENGTH];
	BYTE gxy[DH_KEY_LENGTH];
	BYTE gyx[DH_KEY_LENGTH];
	BYTE *p;
	BOOL fOK;
	
    XNetRandom( x, DH_KEY_LENGTH );
    XNetRandom( y, DH_KEY_LENGTH );    
    
    dwStart = GetTickCount();
    for(i=0; i<DH_REPEAT_LOOP; ++i)
    {
        RtlZeroMemory( gx, DH_KEY_LENGTH );
        RtlZeroMemory( gy, DH_KEY_LENGTH );
        RtlZeroMemory( gxy, DH_KEY_LENGTH );
        RtlZeroMemory( gyx, DH_KEY_LENGTH );
        
        fOK = XcModExp( (DWORD*)gx, (DWORD*)g_def_g, (DWORD*)x, (DWORD*)g_def_p, DH_KEY_LENGTH / sizeof(DWORD) );
        if (!fOK)
        {
            XDBGWRN("Crypto Test", "XcModExp failed!");
            return FALSE;
        }
        
        fOK = XcModExp( (DWORD*)gy, (DWORD*)g_def_g, (DWORD*)y, (DWORD*)g_def_p, DH_KEY_LENGTH / sizeof(DWORD) );
        if (!fOK)
        {
            XDBGWRN("Crypto Test", "XcModExp failed!");
            return FALSE;
        }
        
        fOK = XcModExp( (DWORD*)gxy, (DWORD*)gx, (DWORD*)y, (DWORD*)g_def_p, DH_KEY_LENGTH / sizeof(DWORD) );
        if (!fOK)
        {
            XDBGWRN("Crypto Test", "XcModExp failed!");
            return FALSE;
        }
        
        fOK = XcModExp( (DWORD*)gyx, (DWORD*)gy, (DWORD*)x, (DWORD*)g_def_p, DH_KEY_LENGTH / sizeof(DWORD) );
        if (!fOK)
        {
            XDBGWRN("Crypto Test", "XcModExp failed!");
            return FALSE;
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcModExp", "%d times took %d ms", DH_REPEAT_LOOP*4, dwEnd );

    for (i=0,p = x; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("x  ", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }
    for (i=0,p = y; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("y  ", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }
    for (i=0,p = gx; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("gx ", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }
    for (i=0,p = gy; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("gy ", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }
    for (i=0,p = gxy; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("gxy", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }

    return (RtlEqualMemory(gxy, gyx, DH_KEY_LENGTH));
}

#ifdef AESTEST

#define AES_TEST_LENGTH 512

#define AES_KEY_LENGTH 16

#define AES_REPEAT_LOOP 1000

BOOL aestest()
{
	BYTE text[AES_TEST_LENGTH];
	BYTE saveText[AES_TEST_LENGTH];
	BYTE saveCText[AES_TEST_LENGTH];
	BYTE key[AES_KEY_LENGTH];
	BYTE iv[AES_KEY_LENGTH];
	BYTE fb[AES_KEY_LENGTH];
	AESTable aesTable;
	DWORD dwStart,dwEnd,i,j;
    
	XNetRandom( text, AES_TEST_LENGTH );
	XNetRandom( key, AES_KEY_LENGTH );
	XNetRandom( iv, AES_KEY_LENGTH );

    dwStart = GetTickCount();
    for(i=0; i<AES_REPEAT_LOOP; ++i)
    {
        aeskey(&aesTable, key, CRYPT_AES128_ROUNDS);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("aes key", "%d times took %d ms", AES_REPEAT_LOOP, dwEnd );

	memcpy(saveText, text, AES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<AES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,AES_KEY_LENGTH);
    	memcpy(text, saveText, AES_TEST_LENGTH);
        for (j=0; j<AES_TEST_LENGTH; j+= AES_KEY_LENGTH)
        {
        	CBC(aes, AES_KEY_LENGTH, text+j, text+j, &aesTable, ENCRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("aes Enc", "%d bytes took %d ms", AES_REPEAT_LOOP * AES_TEST_LENGTH, dwEnd );

	memcpy(saveCText, text, AES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<AES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,AES_KEY_LENGTH);
    	memcpy(text, saveCText, AES_TEST_LENGTH);
        for (j=0; j<AES_TEST_LENGTH; j+= AES_KEY_LENGTH)
        {
        	CBC(aes, AES_KEY_LENGTH, text+j, text+j, &aesTable, DECRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("aes Dec", "%d bytes took %d ms", AES_REPEAT_LOOP * AES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, AES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " AES result compare failed!");
        return FALSE;
    }

    return TRUE;
}

#endif //AESTEST


//
// Crypto updata test
//

DWORD g_updateTestResult;

void
TestXcSHAInit(
    IN PUCHAR pbSHAContext
    )
{
    g_updateTestResult = *pbSHAContext;
}
   
void
TestXcSHAUpdate(
    IN PUCHAR pbSHAContext,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength
    )
{
    g_updateTestResult = *pbSHAContext * (*pbInput << 1) * (dwInputLength << 2);
}
   
void
TestXcSHAFinal(
    IN PUCHAR pbSHAContext,
    IN PUCHAR pbDigest
    )
{
    g_updateTestResult = *pbSHAContext * (*pbDigest << 1);
}
   
void
TestXcRC4Key(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwKeyLength,
    IN PUCHAR pbKey
    )
{
    g_updateTestResult = *pbKeyStruct * (dwKeyLength << 1) * (*pbKey << 2);
}
   
void
TestXcRC4Crypt(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwInputLength,
    IN PUCHAR pbInput
    )
{
    g_updateTestResult = *pbKeyStruct * (dwInputLength << 1) * (*pbInput << 2);
}
   
void
TestXcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE pbDigest
    )
{
    g_updateTestResult = *pbKeyMaterial * (cbKeyMaterial << 1) * (*pbData << 2) * (cbData << 3) * (*pbData2 << 4) * (cbData2 << 5) * (*pbDigest << 6);
}

ULONG
TestXcPKEncPublic(
    IN PUCHAR pbPubKey,
    IN PUCHAR pbInput,
    IN PUCHAR pbOutput
    )
{
    return *pbPubKey * (*pbInput << 1) * (*pbOutput << 2);
}
   
ULONG
TestXcPKDecPrivate(
    IN PUCHAR pbPrvKey,
    IN PUCHAR pbInput,
    IN PUCHAR pbOutput
    )
{
    return *pbPrvKey * (*pbInput << 1) * (*pbOutput << 2);
}

ULONG
TestXcPKGetKeyLen(
    IN PUCHAR pbPubKey
    )
{
    return *pbPubKey;
}

BOOLEAN
TestXcVerifyPKCS1Signature(
    IN PUCHAR pbSig,
    IN PUCHAR pbPubKey,
    IN PUCHAR pbDigest
    )
{
    return (BOOLEAN) ((g_updateTestResult = *pbSig * (*pbPubKey << 1) * (*pbDigest << 2)) & 1) != 0;
}
   
ULONG
TestXcModExp(
    IN LPDWORD pA,
    IN LPDWORD pB,
    IN LPDWORD pC,
    IN LPDWORD pD,
    IN ULONG dwN
    )
{
    return *(BYTE*)pA * (*(BYTE*)pB << 1) * (*(BYTE*)pC << 2) * (*(BYTE*)pD << 3) * (dwN << 4);
}
   
void
TestXcDESKeyParity(
    IN PUCHAR pbKey,
    IN ULONG dwKeyLength
    )
{
    g_updateTestResult = *pbKey * (dwKeyLength << 1);
}
   
void
TestXcKeyTable(
    IN ULONG dwCipher,
    OUT PUCHAR pbKeyTable,
    IN PUCHAR pbKey
    )
{
    g_updateTestResult = dwCipher * (*pbKeyTable << 1) * (*pbKey << 2);
}
   
void
TestXcBlockCrypt(
    IN ULONG dwCipher,
    IN PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp
    )
{
    g_updateTestResult = dwCipher * (*pbOutput << 1) * (*pbInput << 2) * (*pbKeyTable << 3) * (dwOp << 4);
}
   
void
TestXcBlockCryptCBC(
    IN ULONG dwCipher,
    IN ULONG dwInputLength,
    IN PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp,
    IN PUCHAR pbFeedback
    )
{
    g_updateTestResult = dwCipher * (dwInputLength << 1) * (*pbOutput << 2) * (*pbInput << 3) * (*pbKeyTable << 4) * (dwOp << 5) * (*pbFeedback << 6);
}

ULONG
TestXcCryptService(
    IN ULONG dwOp,
    IN void* pArgs
    )
{
    return dwOp * (*((BYTE*)pArgs) << 1);
}

CRYPTO_VECTOR newCryptoVector =
{
    TestXcSHAInit,
    TestXcSHAUpdate,
    TestXcSHAFinal,
    TestXcRC4Key,
    TestXcRC4Crypt,
    TestXcHMAC,
    TestXcPKEncPublic,
    TestXcPKDecPrivate,
    TestXcPKGetKeyLen,
    TestXcVerifyPKCS1Signature,
    TestXcModExp,
    TestXcDESKeyParity,
    TestXcKeyTable,
    TestXcBlockCrypt,
    TestXcBlockCryptCBC,
    TestXcCryptService
};

CRYPTO_VECTOR oldCryptoVector;

#define UPDATE_REPEAT_LOOP 1

BOOL updatetest()
{
    BYTE buf[1024], *p1, *p2;
    int i;
    DWORD result;

    KIRQL _irql;

    XNetRandom( buf, sizeof(buf) );
    p1 = p2 = buf;
        
    _irql = KeRaiseIrqlToDpcLevel();

    XcUpdateCrypto( &newCryptoVector, &oldCryptoVector );

    for (i = 0; i < UPDATE_REPEAT_LOOP; ++i)
    {
        XcSHAInit( p1++ );
        if ( g_updateTestResult != *p2++ ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcSHAUpdate( p1++, p1++, *p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcSHAFinal( p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcRC4Key( p1++, *p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcRC4Crypt( p1++, *p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcHMAC( p1++, *p1++, p1++, *p1++, p1++, *p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) * (*p2++ << 3) * (*p2++ << 4) * (*p2++ << 5) * (*p2++ << 6) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcPKEncPublic( p1++, p1++, p1++ );
        if ( result != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcPKDecPrivate( p1++, p1++, p1++ );
        if ( result != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcPKGetKeyLen( p1++ );
        if ( result != *p2++ ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcVerifyPKCS1Signature( p1++, p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        if ( result != ((g_updateTestResult & 1) != 0) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcModExp( (DWORD*)p1++, (DWORD*)p1++, (DWORD*)p1++ , (DWORD*)p1++, *p1++ );
        if ( result != *p2++ * (*p2++ << 1) * (*p2++ << 2) * (*p2++ << 3) * (*p2++ << 4) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcDESKeyParity( p1++, *p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcKeyTable( *p1++, p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );
        
        XcBlockCrypt( *p1++, p1++, p1++, p1++, *p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) * (*p2++ << 3) * (*p2++ << 4) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcBlockCryptCBC( *p1++, *p1++, p1++, p1++, p1++, *p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) * (*p2++ << 3) * (*p2++ << 4) * (*p2++ << 5) * (*p2++ << 6) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );
        
        result = XcCryptService( *p1++, p1++ );
        if ( result != *p2++ * (*p2++ << 1) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );
    }
    
    XcUpdateCrypto( &oldCryptoVector, &newCryptoVector );

    KeLowerIrql(_irql);

    if (i < UPDATE_REPEAT_LOOP)
    {
        return FALSE;
    }
    
    if (shatest())
    {
        XDBGTRC("Crypto Test", "SHA1 succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "SHA1 failed!");
    }

    if (rc4test())
    {
        XDBGTRC("Crypto Test", "RC4 succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "RC4 failed!");
    }

    if (destest())
    {
        XDBGTRC("Crypto Test", "DES succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "DES failed!");
    }

    if (des3test())
    {
        XDBGTRC("Crypto Test", "Triple DES succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "Triple DES failed!");
    }

    if (dhtest())
    {
        XDBGTRC("Crypto Test", "Diffie Hellman succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "Diffie Hellman failed!");
    }

    if (pktest())
    {
        XDBGTRC("Crypto Test", "PK succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "PK failed!");
    }

    return TRUE;
}



//======================== The main function
void __cdecl main()
{

#if DBG
    XDebugOutLevel = XDBG_ENTRY;
    //XDebugOutLevel = XDBG_TRACE;
#endif

    //_asm int 3;

    XNetStartup(NULL);
    
    if (shatest())
    {
        XDBGTRC("Crypto Test", "SHA1 succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "SHA1 failed!");
    }

    if (rc4test())
    {
        XDBGTRC("Crypto Test", "RC4 succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "RC4 failed!");
    }

    if (destest())
    {
        XDBGTRC("Crypto Test", "DES succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "DES failed!");
    }

    if (des3test())
    {
        XDBGTRC("Crypto Test", "Triple DES succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "Triple DES failed!");
    }

    if (dhtest())
    {
        XDBGTRC("Crypto Test", "Diffie Hellman succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "Diffie Hellman failed!");
    }

    if (pktest())
    {
        XDBGTRC("Crypto Test", "PK succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "PK failed!");
    }

#ifdef AESTEST
    aestest();
#endif

    if (updatetest())
    {
        XDBGTRC("Crypto Test", "Crypto Update succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "Crypto Update failed!");
    }
    
    XNetCleanup();
    
    return;
}

