/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 ****************************************************************************/

#include <xtl.h>
#include <xdbg.h>
#include <stdio.h>

typedef struct
{
    BYTE  bUnicodeStr[128];
    DWORD cbUnicodeStr;
    BYTE  bUTF8Str[128];
    DWORD cbUTF8Str;
} STRINGS;

#define DW_NUM_STRINGS 4

STRINGS g_Strings[DW_NUM_STRINGS] = {
    {// Japanese
        { 0xb8,0x82,0x53,0x88,0x68,0x30,0xba,0x4e,0x87,0x65,0x20,0x00,0x99,0x51,0x1f,0x77,0x2c,0x00,0x20,0x00,0xfa,0x5e,0xc9,0x7b,0x2c,0x00,0x20,0x00,0x8e,0x7f,0x53,0x88,0x28,0x99,0x2c,0x00,0x20,0x00,0x74,0x6b,0xf2,0x53,0x2c,0x00,0x20,0x00,0x87,0x65,0x66,0x5b,0x00,0x00 },
        26,
        { 0xe8,0x8a,0xb8,0xe8,0xa1,0x93,0xe3,0x81,0xa8,0xe4,0xba,0xba,0xe6,0x96,0x87,0x20,0xe5,0x86,0x99,0xe7,0x9c,0x9f,0x2c,0x20,0xe5,0xbb,0xba,0xe7,0xaf,0x89,0x2c,0x20,0xe7,0xbe,0x8e,0xe8,0xa1,0x93,0xe9,0xa4,0xa8,0x2c,0x20,0xe6,0xad,0xb4,0xe5,0x8f,0xb2,0x2c,0x20,0xe6,0x96,0x87,0xe5,0xad,0xa6,0x00 },
        58
    },
    {// Hebrew
        { 0xd3,0x05,0xd3,0x05,0xd5,0x05,0xd1,0x05,0x20,0x00,0xd9,0x05,0xd0,0x05,0xdc,0x05,0x20,0x00,0xd2,0x05,0xd5,0x05,0xd6,0x05,0x20,0x00,0xd7,0x05,0xdc,0x05,0xd5,0x05,0xe9,0x05,0x20,0x00,0xe8,0x05,0xd7,0x05,0xd0,0x05,0x20,0x00,0xe2,0x05,0xe1,0x05,0xde,0x05,0x00,0x00 },
        26,
        { 0xd7,0x93,0xd7,0x93,0xd7,0x95,0xd7,0x91,0x20,0xd7,0x99,0xd7,0x90,0xd7,0x9c,0x20,0xd7,0x92,0xd7,0x95,0xd7,0x96,0x20,0xd7,0x97,0xd7,0x9c,0xd7,0x95,0xd7,0xa9,0x20,0xd7,0xa8,0xd7,0x97,0xd7,0x90,0x20,0xd7,0xa2,0xd7,0xa1,0xd7,0x9e,0x00 },
        46
    },
    {// Russian
        { 0x1f,0x04,0x30,0x04,0x48,0x04,0x30,0x04,0x20,0x00,0x32,0x04,0x41,0x04,0x35,0x04,0x33,0x04,0x34,0x04,0x30,0x04,0x20,0x00,0x31,0x04,0x4b,0x04,0x3b,0x04,0x20,0x00,0x3e,0x04,0x47,0x04,0x35,0x04,0x3d,0x04,0x4c,0x04,0x20,0x00,0x3d,0x04,0x30,0x04,0x31,0x04,0x3e,0x04,0x36,0x04,0x3d,0x04,0x4b,0x04,0x3c,0x04,0x00,0x00 },
        31,
        { 0xd0,0x9f,0xd0,0xb0,0xd1,0x88,0xd0,0xb0,0x20,0xd0,0xb2,0xd1,0x81,0xd0,0xb5,0xd0,0xb3,0xd0,0xb4,0xd0,0xb0,0x20,0xd0,0xb1,0xd1,0x8b,0xd0,0xbb,0x20,0xd0,0xbe,0xd1,0x87,0xd0,0xb5,0xd0,0xbd,0xd1,0x8c,0x20,0xd0,0xbd,0xd0,0xb0,0xd0,0xb1,0xd0,0xbe,0xd0,0xb6,0xd0,0xbd,0xd1,0x8b,0xd0,0xbc,0x00 },
        57
    },
    {// Chinese
        { 0x2d,0x4e,0xfd,0x56,0x8c,0x5b,0x10,0x62,0xba,0x4e,0x7b,0x7c,0xfa,0x57,0xe0,0x56,0xc4,0x7e,0xfe,0x56,0x00,0x00 },
        11,
        { 0xe4,0xb8,0xad,0xe5,0x9b,0xbd,0xe5,0xae,0x8c,0xe6,0x88,0x90,0xe4,0xba,0xba,0xe7,0xb1,0xbb,0xe5,0x9f,0xba,0xe5,0x9b,0xa0,0xe7,0xbb,0x84,0xe5,0x9b,0xbe,0x00 },
        31
    }
};

void __cdecl main()
{
    DWORD i;
    CHAR chUTF8[1024];
    TCHAR chUnicode[1024];
    CHAR chSmallUTF8[2];
    TCHAR chSmallUnicode[2];
    DWORD dwSize = 0;
    DWORD dwResult = 0;

    __asm int 3;

    for ( i = 0; i < DW_NUM_STRINGS; i += 1 )
    {
        // *********************************************************************
        // Unicode To UTF8
        //

        // Test to see if correct size is returned
        //
        dwSize = WideCharToMultiByte(CP_UTF8, 0, (LPWSTR)g_Strings[i].bUnicodeStr, g_Strings[i].cbUnicodeStr, NULL, 0, NULL, NULL);
        if (dwSize != g_Strings[i].cbUTF8Str)
            __asm int 3;

        // Test to see if conversion is correct
        //
        dwSize = WideCharToMultiByte(CP_UTF8, 0, (LPWSTR)g_Strings[i].bUnicodeStr, g_Strings[i].cbUnicodeStr, chUTF8, sizeof(chUTF8), NULL, NULL );
        if (dwSize != g_Strings[i].cbUTF8Str)
            __asm int 3;

        dwResult = memcmp(g_Strings[i].bUTF8Str, chUTF8, dwSize);
        if (dwResult != 0)
            __asm int 3;

        // Test to see if conversion when specifying -1 for length is correct
        //
        dwSize = WideCharToMultiByte(CP_UTF8, 0, (LPWSTR)g_Strings[i].bUnicodeStr, -1, chUTF8, sizeof(chUTF8), NULL, NULL );
        if (dwSize != g_Strings[i].cbUTF8Str)
            __asm int 3;

        dwResult = memcmp(g_Strings[i].bUTF8Str, chUTF8, dwSize);
        if (dwResult != 0)
            __asm int 3;

        // Test error condition: insufficient buffer
        //
        dwSize = WideCharToMultiByte(CP_UTF8, 0, (LPWSTR)g_Strings[i].bUnicodeStr, -1, chSmallUTF8, sizeof(chSmallUTF8), NULL, NULL );
        if (dwSize != 0 || GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            __asm int 3;

        // *********************************************************************
        // UTF8 To Unicode
        //

        // Test to see if correct size is returned
        //
        dwSize = MultiByteToWideChar(CP_UTF8, 0, (CHAR *)g_Strings[i].bUTF8Str, g_Strings[i].cbUTF8Str, NULL, 0);
        if (dwSize != g_Strings[i].cbUnicodeStr)
            __asm int 3;

        // Test to see if conversion is correct
        //
        dwSize = MultiByteToWideChar(CP_UTF8, 0, (CHAR *)g_Strings[i].bUTF8Str, g_Strings[i].cbUTF8Str, chUnicode, sizeof(chUnicode));
        if (dwSize != g_Strings[i].cbUnicodeStr)
            __asm int 3;

        dwResult = memcmp(g_Strings[i].bUnicodeStr, chUnicode, dwSize * sizeof(TCHAR));
        if (dwResult != 0)
            __asm int 3;

        // Test to see if conversion when specifying -1 for length is correct
        //
        dwSize = MultiByteToWideChar(CP_UTF8, 0, (CHAR *)g_Strings[i].bUTF8Str, -1, chUnicode, sizeof(chUnicode));
        if (dwSize != g_Strings[i].cbUnicodeStr)
            __asm int 3;

        dwResult = memcmp(g_Strings[i].bUnicodeStr, chUnicode, dwSize * sizeof(TCHAR));
        if (dwResult != 0)
            __asm int 3;

        // Test error condition: insufficient buffer
        //
        dwSize = MultiByteToWideChar(CP_UTF8, 0, (CHAR *)g_Strings[i].bUTF8Str, -1, chSmallUnicode, sizeof(chSmallUnicode));
        if (dwSize != 0 || GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            __asm int 3;
    }

    __asm int 3;
}


