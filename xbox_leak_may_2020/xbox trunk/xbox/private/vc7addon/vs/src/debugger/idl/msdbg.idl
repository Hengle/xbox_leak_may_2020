// msdbg.idl : Microsoft Debug API

import "ocidl.idl";
import "oleidl.idl";

// magic to stop the generated header containing platform- and compiler- specific types such as INT_PTR
cpp_quote("#ifndef _BASETSD_H_")
#include "basetsd.h"
cpp_quote("#endif // _BASETSD_H_")

#ifdef VS_IDL_BUILD
// Just to get rup
#include "version.h"
#endif

const DWORD MSDBG_VERSION = 7126;

// Use uuid_constant to keep the specified guid constant. This is a note that this guid must be kept constant.
#define uuid_constant uuid

// Use uuid_jdate to embed the jdate in the GUID
#define uuid_jdate(first, jdate, last) uuid_constant(first-jdate-last)

// HRESULTs

// HRESULTs returned by IDebugProcess2::Attach and IDebugProgram2::Attach
cpp_quote("#define E_ATTACH_DEBUGGER_ALREADY_ATTACHED						MAKE_HRESULT(1, FACILITY_ITF, 0x0001)")
cpp_quote("#define E_ATTACH_DEBUGGEE_PROCESS_SECURITY_VIOLATION				MAKE_HRESULT(1, FACILITY_ITF, 0x0002)")
cpp_quote("#define E_ATTACH_CANNOT_ATTACH_TO_DESKTOP						MAKE_HRESULT(1, FACILITY_ITF, 0x0003)")
cpp_quote("#define S_ATTACH_DEFERRED										MAKE_HRESULT(0, FACILITY_ITF, 0x0004)")
cpp_quote("#define E_LAUNCH_NO_INTEROP                                      MAKE_HRESULT(1, FACILITY_ITF, 0x0005)")
cpp_quote("#define E_LAUNCH_DEBUGGING_NOT_POSSIBLE                          MAKE_HRESULT(1, FACILITY_ITF, 0x0006)")
cpp_quote("#define E_LAUNCH_KERNEL_DEBUGGER_ENABLED                         MAKE_HRESULT(1, FACILITY_ITF, 0x0007)")
cpp_quote("#define E_LAUNCH_KERNEL_DEBUGGER_PRESENT                         MAKE_HRESULT(1, FACILITY_ITF, 0x0008)")
cpp_quote("#define E_INTEROP_NOT_SUPPORTED                                  MAKE_HRESULT(1, FACILITY_ITF, 0x0009)")
cpp_quote("#define E_TOO_MANY_PROCESSES                                     MAKE_HRESULT(1, FACILITY_ITF, 0x000A)")

// HRESULTs returned by IDebugMachine2::*
cpp_quote("#define E_MACHINE_NOT_AVAILABLE									MAKE_HRESULT(1, FACILITY_ITF, 0x0010)")
// HRESULTs returned by IDebugSession2::AddMachine
cpp_quote("#define E_MACHINE_DOES_NOT_EXIST									MAKE_HRESULT(1, FACILITY_ITF, 0x0020)")
cpp_quote("#define E_MACHINE_ACCESS_DENIED									MAKE_HRESULT(1, FACILITY_ITF, 0x0021)")
cpp_quote("#define E_MACHINE_MDM_EXEC_FAILURE								MAKE_HRESULT(1, FACILITY_ITF, 0x0022)")
cpp_quote("#define E_MACHINE_DEBUGGER_NOT_REGISTERED_PROPERLY				MAKE_HRESULT(1, FACILITY_ITF, 0x0023)")
// HRESULTs returned by IDebugExpression2::EvaluateAsync and EvaluateSync
cpp_quote("#define E_EVALUATE_BUSY_WITH_EVALUATION							MAKE_HRESULT(1, FACILITY_ITF, 0x0030)")
cpp_quote("#define E_EVALUATE_TIMEOUT										MAKE_HRESULT(1, FACILITY_ITF, 0x0031)")
// HRESULTs returned by IDebugProgram::GetMemoryBytes
cpp_quote("#define E_MEMORY_NOTSUPPORTED									MAKE_HRESULT(1, FACILITY_ITF, 0x0040)")
// HRESULTs returned by IDebugProgram::GetDisassemblyStream
cpp_quote("#define E_DISASM_NOTSUPPORTED									MAKE_HRESULT(1, FACILITY_ITF, 0x0041)")
cpp_quote("#define E_DISASM_BADADDRESS                                      MAKE_HRESULT(1, FACILITY_ITF, 0x0042)")
cpp_quote("#define E_DISASM_NOTAVAILABLE                                    MAKE_HRESULT(1, FACILITY_ITF, 0x0043)")
// HRESULTs returned by IDebugPendingBreakpoint::* and IDebugBoundBreakpoint::*
cpp_quote("#define E_BP_DELETED												MAKE_HRESULT(1, FACILITY_ITF, 0x0060)")
// HRESULTs returned by IDebugProcess2::*
cpp_quote("#define E_PROCESS_DESTROYED										MAKE_HRESULT(1, FACILITY_ITF, 0x0070)")
cpp_quote("#define E_PROCESS_DEBUGGER_IS_DEBUGGEE							MAKE_HRESULT(1, FACILITY_ITF, 0x0071)")
// HRESULTs returned by IDebugPortSupplier2::*
cpp_quote("#define E_PORTSUPPLIER_NO_PORT									MAKE_HRESULT(1, FACILITY_ITF, 0x0080)")
// HRESULTs returned by IDebugPort2::*
cpp_quote("#define E_PORT_NO_REQUEST										MAKE_HRESULT(1, FACILITY_ITF, 0x0090)")
// HRESULTs returned by *::Compare
cpp_quote("#define E_COMPARE_CANNOT_COMPARE									MAKE_HRESULT(1, FACILITY_ITF, 0x00a0)")
// HRESULTs returned by IDebugPortNotify2::JITDebug
cpp_quote("#define S_JIT_USERCANCELLED										MAKE_HRESULT(0, FACILITY_ITF, 0x00b0)")
cpp_quote("#define E_JIT_INVALID_PID										MAKE_HRESULT(1, FACILITY_ITF, 0x00b1)")
cpp_quote("#define E_JIT_REMOTE_FAILED										MAKE_HRESULT(0, FACILITY_ITF, 0x00b2)")
// HRESULTs returned by IDebugSession2::Terminate
cpp_quote("#define S_TERMINATE_PROCESSES_STILL_DETACHING					MAKE_HRESULT(0, FACILITY_ITF, 0x00c0)")
// HRESULTs returned by IDebugSession2::CanDetach
cpp_quote("#define E_DETACH_NO_PROXY								        MAKE_HRESULT(1, FACILITY_ITF, 0x00d0)")
cpp_quote("#define E_DETACH_TS_UNSUPPORTED						            MAKE_HRESULT(1, FACILITY_ITF, 0x00e0)")
cpp_quote("#define E_DETACH_IMPERSONATE_FAILURE						        MAKE_HRESULT(1, FACILITY_ITF, 0x00f0)")

// HRESULT returned by IDebugThread2::SetNextStatment
cpp_quote("#define E_CANNOT_SET_NEXT_STATEMENT_ON_NONLEAF_FRAME				MAKE_HRESULT(1, FACILITY_ITF, 0x0100)")
cpp_quote("#define E_CANNOT_SETIP_TO_DIFFERENT_FUNCTION                     MAKE_HRESULT(1, FACILITY_ITF, 0x0104)")
cpp_quote("#define E_CANNOT_SET_NEXT_STATEMENT_ON_EXCEPTION                 MAKE_HRESULT(1, FACILITY_ITF, 0x0105)")

// HRESULTs returned by IDebugPortNotify2::AddProgramNode
cpp_quote("#define E_CANNOT_DEBUG_MDM										MAKE_HRESULT(1, FACILITY_ITF, 0x0110)")

// HRESULTs returned by IEditableProgram::*
cpp_quote("#define E_TARGET_FILE_MISSING									MAKE_HRESULT(1, FACILITY_ITF, 0x0100)")
cpp_quote("#define E_TARGET_FILE_MISMATCH									MAKE_HRESULT(1, FACILITY_ITF, 0x0101)")
cpp_quote("#define E_IMAGE_NOT_LOADED										MAKE_HRESULT(1, FACILITY_ITF, 0x0102)")
cpp_quote("#define E_FIBER_NOT_SUPPORTED									MAKE_HRESULT(1, FACILITY_ITF, 0x0103)")

// HRESULTs returned by *::CauseBreak and *::Stop
cpp_quote("#define E_ASYNCBREAK_NO_PROGRAMS									MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0110)")
cpp_quote("#define E_ASYNCBREAK_DEBUGGEE_NOT_INITIALIZED					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0111)")

// HRESULTs returned by Managed EEs
cpp_quote("#define E_CANNOT_GET_UNMANAGED_MEMORY_CONTEXT					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0561)")

// HRESULTs returned by Native engine
cpp_quote("#define E_DESTROYED												MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 1)")
cpp_quote("#define E_REMOTE_NOMSVCMON										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 2)")
cpp_quote("#define E_REMOTE_BADIPADDRESS									MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 3)")
cpp_quote("#define E_REMOTE_MACHINEDOWN										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 4)")
cpp_quote("#define E_REMOTE_MACHINEUNSPECIFIED								MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 5)")
cpp_quote("#define E_CRASHDUMP_ACTIVE										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 6)")
cpp_quote("#define E_ALL_THREADS_SUSPENDED									MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 7)")
cpp_quote("#define E_LOAD_DLL_TL											MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 8)")
cpp_quote("#define E_LOAD_DLL_SH											MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 9)")
cpp_quote("#define E_LOAD_DLL_EM											MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 10)")
cpp_quote("#define E_LOAD_DLL_EE											MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 11)")
cpp_quote("#define E_LOAD_DLL_DM											MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 12)")
cpp_quote("#define E_LOAD_DLL_MD											MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 13)")
cpp_quote("#define E_IOREDIR_BADFILE										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 14)")
cpp_quote("#define E_IOREDIR_BADSYNTAX										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 15)")
cpp_quote("#define E_REMOTE_BADVERSION										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 16)")
cpp_quote("#define E_CRASHDUMP_UNSUPPORTED									MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 17)")
cpp_quote("#define E_UNSUPPORTED_BINARY										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 21)")
cpp_quote("#define E_DEBUGGEE_BLOCKED										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 22)")
cpp_quote("#define E_REMOTE_NOUSERMSVCMON									MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 23)")
cpp_quote("#define E_STEP_WIN9xSYSCODE                                      MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 24)")
cpp_quote("#define E_INTEROP_ORPC_INIT 										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 25)")
cpp_quote("#define E_CANNOT_DEBUG_WIN32										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 27)")
cpp_quote("#define E_CANNOT_DEBUG_WIN64										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 28)")
cpp_quote("#define E_MINIDUMP_READ_WIN9X                                    MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 29)")
cpp_quote("#define E_CROSS_TSSESSION_ATTACH 								MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 30)")
cpp_quote("#define E_STEP_BP_SET_FAILED										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 31)")

// HRESULTs for IDebugProperty2 and IDebugReference2

// HRESULTs returned by IDebugReference2::*
cpp_quote("#define E_REFERENCE_NOT_VALID									MAKE_HRESULT(1, FACILITY_ITF, 0x0501)")
// HRESULTs returned by IDebugProperty2::*
cpp_quote("#define E_PROPERTY_NOT_VALID										MAKE_HRESULT(1, FACILITY_ITF, 0x0511)")
// HRESULTs returned by IDebugReference2::SetValue and IDebugProperty2::SetValue
cpp_quote("#define E_SETVALUE_VALUE_CANNOT_BE_SET							MAKE_HRESULT(1, FACILITY_ITF, 0x0521)")
cpp_quote("#define E_SETVALUE_VALUE_IS_READONLY								MAKE_HRESULT(1, FACILITY_ITF, 0x0522)")
cpp_quote("#define E_SETVALUEASREFERENCE_NOTSUPPORTED						MAKE_HRESULT(1, FACILITY_ITF, 0x0523)")
// HRESULTs returned by IDebugReference2::GetParent and IDebugProperty2::GetParent
cpp_quote("#define S_GETPARENT_NO_PARENT									MAKE_HRESULT(0, FACILITY_ITF, 0x0531)")
// HRESULTs returned by IDebugReference2::GetDerivedMostReference and IDebugProperty2::GetDerivedMostProperty
cpp_quote("#define S_GETDERIVEDMOST_NO_DERIVED_MOST							MAKE_HRESULT(0, FACILITY_ITF, 0x0541)")
// HRESULTs returned by IDebugReference2::GetMemoryBytes and IDebugProperty2::GetMemoryBytes
cpp_quote("#define S_GETMEMORYBYTES_NO_MEMORY_BYTES							MAKE_HRESULT(0, FACILITY_ITF, 0x0551)")
// HRESULTs returned by IDebugReference2::GetMemoryContext and IDebugProperty2::GetMemoryContext
cpp_quote("#define S_GETMEMORYCONTEXT_NO_MEMORY_CONTEXT						MAKE_HRESULT(0, FACILITY_ITF, 0x0561)")
// HRESULTs returned by IDebugReference2::GetSize and IDebugProperty2::GetSize
cpp_quote("#define S_GETSIZE_NO_SIZE										MAKE_HRESULT(0, FACILITY_ITF, 0x0571)")
// HRESULTs returned by IDebugProperty2::GetReference
cpp_quote("#define E_GETREFERENCE_NO_REFERENCE								MAKE_HRESULT(1, FACILITY_ITF, 0x0581)")
// HRESULTs returned by IDebugProperty2::GetExtendedInfo
cpp_quote("#define S_GETEXTENDEDINFO_NO_EXTENDEDINFO						MAKE_HRESULT(0, FACILITY_ITF, 0x0591)")
// HRESULTs returned by IDebugDisassemblyStream2::GetCodeLocationId
cpp_quote("#define E_CODE_CONTEXT_OUT_OF_SCOPE								MAKE_HRESULT(1, FACILITY_ITF, 0x05A1)")
// HRESULTs returned by MapSessionIdToSession and MDM::AutoAttach
cpp_quote("#define E_INVALID_SESSIONID										MAKE_HRESULT(1, FACILITY_ITF, 0x05A2)")
// HRESULTs returned when we can't callback from the MDM to devenv
cpp_quote("#define E_SERVER_UNAVAILABLE_ON_CALLBACK							MAKE_HRESULT(1, FACILITY_ITF, 0x05A3)")
cpp_quote("#define E_ACCESS_DENIED_ON_CALLBACK								MAKE_HRESULT(1, FACILITY_ITF, 0x05A4)")
cpp_quote("#define E_UNKNOWN_AUTHN_SERVICE_ON_CALLBACK						MAKE_HRESULT(1, FACILITY_ITF, 0x05A5)")
cpp_quote("#define E_NO_SESSION_AVAILABLE									MAKE_HRESULT(1, FACILITY_ITF, 0x05A6)")
// HRESULT returned from MDM::CreateClassEx
cpp_quote("#define E_CLIENT_NOT_LOGGED_ON                                   MAKE_HRESULT(1, FACILITY_ITF, 0x05A7)")
cpp_quote("#define E_OTHER_USERS_SESSION                                    MAKE_HRESULT(1, FACILITY_ITF, 0x05A8)")
cpp_quote("#define E_USER_LEVEL_ACCESS_CONTROL_REQUIRED                     MAKE_HRESULT(1, FACILITY_ITF, 0x05A9)")
// HRESULTs returned by the pdm
cpp_quote("#define E_SCRIPT_CLR_EE_DISABLED                                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x5B0)")

// HRESULTs returned for Auto Attach of XSP & ATLServer
cpp_quote("#define E_HTTP_SERVERERROR										MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x700)")
cpp_quote("#define E_HTTP_PERMISSION_DENIED									MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x701)")
cpp_quote("#define E_HTTP_SENDREQUEST_FAILED								MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x702)")
cpp_quote("#define E_HTTP_FORBIDDEN											MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x703)")
cpp_quote("#define E_HTTP_NOT_SUPPORTED										MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x704)")
cpp_quote("#define E_HTTP_NO_CONTENT										MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x705)")

// HRESULTs returned by the cpde.
cpp_quote("#define E_FUNCTION_NOT_JITTED                                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x800)")
cpp_quote("#define E_NO_CODE_CONTEXT                                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x801)")

// HRESULTs returned by SDM for Auto-Attach
cpp_quote("#define E_AUTOATTACH_ACCESS_DENIED                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x900)")
cpp_quote("#define E_AUTOATTACH_WEBSERVER_NOT_FOUND                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x901)")

interface IDebugMachine2;
interface IDebugPortSupplier2;
interface IDebugPort2;
interface IDebugPortRequest2;
interface IDebugSession2;
interface IDebugEngine2;
interface IDebugEventCallback2;
interface IDebugEvent2;
interface IDebugProcess2;
interface IDebugProgram2;
interface IDebugProgramNode2;
interface IDebugThread2;
interface IDebugLogicalThread2;
interface IDebugStackFrame2;
interface IDebugMemoryContext2;
interface IDebugCodeContext2;
interface IDebugMemoryBytes2;
interface IDebugDisassemblyStream2;
interface IDebugDocumentContext2;
interface IDebugExpressionContext2;
interface IDebugBreakpointRequest2;
interface IDebugBreakpointResolution2;
interface IDebugBoundBreakpoint2;
interface IDebugPendingBreakpoint2;
interface IDebugErrorBreakpoint2;
interface IDebugExpression2;
interface IDebugModule2;
interface IDebugDocument2;
interface IDebugDocumentText2;
interface IDebugDocumentPosition2;
interface IDebugFunctionPosition2;
interface IDebugDocumentTextEvents2;
interface IDebugSimpleProperty2;
interface IDebugMDMUtil2;
interface IDebugReference2;
interface IDebugProperty2;
interface IEnumDebugProcesses2;
interface IEnumDebugPrograms2;
interface IEnumDebugThreads2;
interface IEnumDebugStackFrames2;
interface IEnumDebugCodeContexts2;
interface IEnumDebugBoundBreakpoints2;
interface IEnumDebugPendingBreakpoints2;
interface IEnumDebugErrorBreakpoints2;
interface IEnumDebugExceptionInfo2;
interface IEnumDebugFrameInfo2;
interface IEnumDebugMachines2;
interface IEnumCodePaths2;
interface IEnumDebugModules2;
interface IEnumDebugPortSuppliers2;
interface IEnumDebugPorts2;
interface IEnumDebugReferenceInfo2;
interface IEnumDebugPropertyInfo2;

import "enc.idl";

cpp_quote("extern GUID guidVBLang;")
cpp_quote("extern GUID guidVBScriptLang;")
cpp_quote("extern GUID guidJScriptLang;")
cpp_quote("extern GUID guidCLang;")
cpp_quote("extern GUID guidCPPLang;")
cpp_quote("extern GUID guidSQLLang;")
cpp_quote("extern GUID guidScriptLang;")
cpp_quote("extern GUID guidSafeCLang;")
cpp_quote("extern GUID guidManagedCLang;")
cpp_quote("extern GUID guidManagedCPPLang;")

cpp_quote("extern GUID guidScriptEng;")
cpp_quote("extern GUID guidSQLEng;")
cpp_quote("extern GUID guidCOMPlusNativeEng;")
cpp_quote("extern GUID guidCOMPlusOnlyEng;")
cpp_quote("extern GUID guidNativeOnlyEng;")
cpp_quote("extern GUID guidMsOrclEng;")
cpp_quote("extern GUID guidEmbeddedCLREng;")

cpp_quote("extern GUID guidMicrosoftVendor;")

// Port suppliers
cpp_quote("extern GUID guidLocalPortSupplier;")
cpp_quote("extern GUID guidNativePortSupplier;")
cpp_quote("extern GUID guidEmbeddedCLRPortSupplier;")

// IDebugProperty2 GUID filters
cpp_quote("extern GUID guidFilterLocals;")
cpp_quote("extern GUID guidFilterAllLocals;")
cpp_quote("extern GUID guidFilterArgs;")
cpp_quote("extern GUID guidFilterLocalsPlusArgs;")
cpp_quote("extern GUID guidFilterAllLocalsPlusArgs;")
cpp_quote("extern GUID guidFilterRegisters;")
cpp_quote("extern GUID guidFilterThis;")

// GUIDs for GetExtendedInfo
cpp_quote("// GUIDs for GetExtendedInfo")
cpp_quote("extern GUID guidDocument;")
// TODO: remove this one once everyone implements IDebugProperty2::GetMemoryContext
cpp_quote("extern GUID guidCodeContext;")

cpp_quote("extern GUID guidExtendedInfoSlot;")
cpp_quote("extern GUID guidExtendedInfoSignature;")

enum
{
	GN_NAME,				// Gets the (as friendly as possible) name of the document or context
	GN_FILENAME,			// Gets the full path file name (drive+path+filename+ext or as much as possible) of the document or context
	GN_BASENAME,			// Gets the basename+ext part of the file name
	GN_MONIKERNAME,			// Gets the unique, monikerized name of the document or context
	GN_URL,					// Gets the URL name of the document or context
	GN_TITLE,				// Gets the title of the document if possible.
	GN_STARTPAGEURL,		// Gets the start page URL for processes -- used for XSP/ATL Server debugging
};
typedef DWORD GETNAME_TYPE;

enum
{
	TEXT_POSITION_MAX_LINE		= 0xffffffff,
	TEXT_POSITION_MAX_COLUMN	= 0xffffffff,
};

typedef struct _tagTEXT_POSITION
{
	DWORD dwLine;
	DWORD dwColumn;
} TEXT_POSITION;

// ------------------------------------------------------------------
// IDebugMachine2
[
	object,
	uuid(17bf8fa3-4c5a-49a3-b2f8-5942e1ea287e),
	pointer_default(unique)
]
interface IDebugMachine2: IUnknown
{
	enum
	{
		MCIFLAG_TERMINAL_SERVICES_AVAILABLE	= 0x00000001,
	};
	typedef DWORD MACHINE_INFO_FLAGS;

	enum
	{
		MCIF_NAME			= 0x00000001,
		MCIF_FLAGS			= 0x00000002,

		MCIF_ALL			= 0x00000003,
	};
	typedef DWORD MACHINE_INFO_FIELDS;

	typedef struct tagMACHINE_INFO
	{
		// Valid fields
		MACHINE_INFO_FIELDS	Fields;
		// Machine name
		BSTR				bstrName;
		// Flags
		MACHINE_INFO_FLAGS	Flags;
	} MACHINE_INFO;

	HRESULT GetInfo(
		[in] MACHINE_INFO_FIELDS Fields,
		[out] MACHINE_INFO* pMachineInfo);

	HRESULT GetName(
		[out] BSTR* pbstrName);

	// Get a port supplier that exists on this machine
	HRESULT GetPortSupplier(
		[in] REFGUID guidPortSupplier,
		[out] IDebugPortSupplier2** ppPortSupplier);

	// Get a port that already exists on this machine
	HRESULT GetPort(
		[in] REFGUID guidPort,
		[out] IDebugPort2** ppPort);

	// Enum all the ports on this machine
	HRESULT EnumPorts(
		[out] IEnumDebugPorts2** ppEnum);

	// Enum all the port suppliers on this machine
	HRESULT EnumPortSuppliers(
		[out] IEnumDebugPortSuppliers2** ppEnum);

	HRESULT GetMachineUtilities(
		[out] IDebugMDMUtil2** ppUtil);
};


// ------------------------------------------------------------------
// IDebugMachineEx2
// This interface was added after the Office 10 Fork
[
	object,
	uuid(ae27b230-a0bf-47ff-a2d1-22c29a178eac),
	pointer_default(unique)
]
interface IDebugMachineEx2: IUnknown
{
	HRESULT EnableAutoAttachOnProgramCreate(
		[in] LPCWSTR pszProcessNames,   // process names seperated by semicolons ex: "foo.exe;bar.exe;bigname.exe"
		[in] REFGUID guidEngine,        // auto attach when 'guidEngine' is added to the process, use GUID_NULL for 'any engine'
		[in] LPCWSTR pszSessionId,      // session id to attach to
		[out] DWORD* pdwCookie);        // cookie returned that is used to call 'DisableAutoAttachOnEvent'

	HRESULT DisableAutoAttachOnEvent(
		[in] DWORD dwCookie);

	// Get a port supplier that exists on this machine
	HRESULT GetPortSupplierEx(
		[in] LPCOLESTR wstrRegistryRoot,
		[in] REFGUID guidPortSupplier,
		[out] IDebugPortSupplier2** ppPortSupplier);

	// Get a port that already exists on this machine
	HRESULT GetPortEx(
		[in] LPCOLESTR wstrRegistryRoot,
		[in] REFGUID guidPort,
		[out] IDebugPort2** ppPort);

	// Enum all the ports on this machine
	HRESULT EnumPortsEx(
		[in] LPCOLESTR wstrRegistryRoot,
		[out] IEnumDebugPorts2** ppEnum);

	// Enum all the port suppliers on this machine
	HRESULT EnumPortSuppliersEx(
		[in] LPCOLESTR wstrRegistryRoot,
		[out] IEnumDebugPortSuppliers2** ppEnum);
};

// --------------------------------------------------------
// IDebugPortSupplier2

[
	object,
	uuid(53f68191-7b2f-4f14-8e55-40b1b6e5df66),
	pointer_default(unique)
]
interface IDebugPortSupplier2: IUnknown
{
	HRESULT GetPortSupplierName(
		[out] BSTR* pbstrName);

	HRESULT GetPortSupplierId(
		[out] GUID* pguidPortSupplier);

	// Get a port from this port supplier
	HRESULT GetPort(
		[in] REFGUID guidPort,
		[out] IDebugPort2** ppPort);

	// Enum the ports that already exist
	HRESULT EnumPorts(
		[out] IEnumDebugPorts2** ppEnum);

	// Does this port supplier support adding new ports? S_OK == yes; S_FALSE == no
	HRESULT CanAddPort(void);

	// Add a port
	HRESULT AddPort(
		[in] IDebugPortRequest2* pRequest,
		[out] IDebugPort2** ppPort);

	// Remove a port
	HRESULT RemovePort(
		[in] IDebugPort2* pPort);
};

// --------------------------------------------------------
// IDebugPort2

[
	object,
	uuid(79293cc8-d9d9-43f5-97ad-0bcc5a688776),
	pointer_default(unique)
]
interface IDebugPort2: IUnknown
{
	enum
	{
		AD_PROCESS_ID_SYSTEM,
		AD_PROCESS_ID_GUID
	};
	typedef DWORD AD_PROCESS_ID_TYPE;
	typedef union _AD_PROCESS_ID switch (AD_PROCESS_ID_TYPE ProcessIdType) ProcessId
	{
		case AD_PROCESS_ID_SYSTEM:
			DWORD dwProcessId;
		case AD_PROCESS_ID_GUID:
			GUID guidProcessId;
		default:
			DWORD dwUnused;
	} AD_PROCESS_ID;

	HRESULT GetPortName(
		[out] BSTR* pbstrName);

	HRESULT GetPortId(
		[out] GUID* pguidPort);

	// Get the request used to create this port (if available)
	HRESULT GetPortRequest(
		[out] IDebugPortRequest2** ppRequest);

	// Get the port supplier that supplied this port
	HRESULT GetPortSupplier(
		[out] IDebugPortSupplier2** ppSupplier);

	// Get an IDebugProcess2 for a PID running on this port
	HRESULT GetProcess(
		[in] AD_PROCESS_ID ProcessId,
		[out] IDebugProcess2** ppProcess);

	// Enum all the processes running on this port
	HRESULT EnumProcesses(
		[out] IEnumDebugProcesses2** ppEnum);
};

// --------------------------------------------------------
// IDebugPortRequest2
[
	object,
	uuid(8d36beb8-9bfe-47dd-a11b-7ba1de18e449),
	pointer_default(unique)
]
interface IDebugPortRequest2: IUnknown
{
	HRESULT GetPortName(
		[out] BSTR* pbstrPortName);
};

// ------------------------------------------------------------------
// IDebugPortNotify2
[
	object,
	uuid(fb8d2032-2858-414c-83d9-f732664e0c7a),
	pointer_default(unique)
]
interface IDebugPortNotify2: IUnknown
{
	HRESULT AddProgramNode(
		[in] IDebugProgramNode2* pProgramNode);

	HRESULT RemoveProgramNode(
		[in] IDebugProgramNode2* pProgramNode);
};

// ------------------------------------------------------------------
// IDebugPortEvents2
[
	object,
	uuid(564fa275-12e1-4b5f-8316-4d79bcef7246),
	pointer_default(unique)
]
interface IDebugPortEvents2: IUnknown
{
	HRESULT Event(
		[in] IDebugMachine2* pMachine,
		[in] IDebugPort2* pPort,
		[in] IDebugProcess2* pProcess,
		[in] IDebugProgram2* pProgram,
		[in] IDebugEvent2* pEvent,
		[in] REFIID riidEvent);
};

// ------------------------------------------------------------------
// IDebugMDMUtil2
[
    object,
    uuid(f3062547-43d8-4dc2-b18e-e1460ff2c422),
    pointer_default(unique)
]
interface IDebugMDMUtil2 : IUnknown
{
	// For the following methods guidEngine specifies the debug engine the
	// call applies to. Use GUID_NULL to specify all engines.

	// Add or remove a process that the VM should NOT ever debug
	// (i.e. DON'T use the debugger interpreter loop for a specified process).
	HRESULT AddPIDToIgnore(
		[in] REFGUID guidEngine,
		[in] DWORD dwPid);
	HRESULT RemovePIDToIgnore(
		[in] REFGUID guidEngine,
		[in] DWORD dwPid);

	// Add or remove a process that the VM should debug
	// (i.e. DO use the debugger interpreter loop for a specified process).
	HRESULT AddPIDToDebug(
		[in] REFGUID guidEngine,
		[in] DWORD dwPid);
	HRESULT RemovePIDToDebug(
		[in] REFGUID guidEngine,
		[in] DWORD dwPid);

    typedef DWORD DYNDEBUGFLAGS;
	enum
	{
		DYNDEBUG_ATTACH	   = 1,
		DYNDEBUG_JIT	   = 2,
        DYNDEBUG_REMOTEJIT = 4
	};

    // Access to dynamic debugging flags (JIT, attach, ...).
    // Settings are  on a per Engine basis for the entire machine.
	// Users of these two APIs should always call GetDynamicDebuggingFlags,
	//   set or clear specific bits, then call SetDynamicDebuggingFlags
    HRESULT SetDynamicDebuggingFlags(
        [in] REFGUID guidEngine,
        [in] DYNDEBUGFLAGS dwFlags);
    HRESULT GetDynamicDebuggingFlags(
        [in] REFGUID guidEngine,
        [out] DYNDEBUGFLAGS *pdwFlags);

	// Set the clsid as the default JIT Server
    HRESULT SetDefaultJITServer(
        [in] REFCLSID clsidJITServer);
    // Retrieve the default JIT Server (CLSID_NULL if there isn't one)
    HRESULT GetDefaultJITServer(
        [out] CLSID *pClsidJITServer);
    // Register debug engines for a JIT debugger.
    // arrRemoteFlags may be NULL if remote JIT is not supported for any engine.
    // arrguidEngines and arrRemoteFlags are ignored if fRegister is FALSE.
    HRESULT RegisterJITDebugEngines(
        [in] REFCLSID clsidJITServer,
        [in,size_is(celtEngs)] GUID *arrguidEngines,
        [in,ptr,size_is(celtEngs)] BOOL *arrRemoteFlags,
        [in] DWORD celtEngs,
        [in] BOOL fRegister);

    const DWORD S_UNKNOWN = 0x3;

	// Should the VM use the debugger loop for this pid?
	HRESULT CanDebugPID(
		[in] REFGUID guidEngine,
		[in] DWORD pid);
}

// ------------------------------------------------------------------
// IDebugSession2
[
	object,
	uuid(8948300f-8bd5-4728-a1d8-83d172295a9d),
	pointer_default(unique)
]
interface IDebugSession2: IUnknown
{
	enum
	{
		// Launch the process for debugging
		LAUNCH_DEBUG			= 0x0000,
		// Launch the process without debugging it
		LAUNCH_NODEBUG			= 0x0001,
        // Launch the process with EnC enabled.
        LAUNCH_ENABLE_ENC       = 0x0002
	};
	typedef DWORD LAUNCH_FLAGS;

	enum
	{
		EXCEPTION_NONE								= 0x0000,
		EXCEPTION_STOP_FIRST_CHANCE					= 0x0001,
		EXCEPTION_STOP_SECOND_CHANCE				= 0x0002,
		// Use the setting of the parent exception for first-chance exceptions;
		// EXCEPTION_STOP_FIRST_CHANCE is ignored if this bit is set
		EXCEPTION_STOP_FIRST_CHANCE_USE_PARENT		= 0x0004,
		// Use the setting of the parent exception for second-chance exceptions;
		// EXCEPTION_STOP_SECOND_CHANCE is ignored if this bit is set
		EXCEPTION_STOP_SECOND_CHANCE_USE_PARENT		= 0x0008,
	};
	typedef DWORD EXCEPTION_STATE;

	typedef struct tagEXCEPTION_INFO
	{
		IDebugProgram2* pProgram;
		BSTR bstrProgramName;
		BSTR bstrExceptionName;
		DWORD dwCode;
		EXCEPTION_STATE dwState;
		// Either guidLang or guidEng
		GUID guidType;
	} EXCEPTION_INFO;

	HRESULT GetName(
		[out] BSTR* pbstrName);

	HRESULT SetName(
		[in] LPOLESTR pszName);

	HRESULT EnumProcesses(
		[out] IEnumDebugProcesses2** ppEnum);

	HRESULT Launch(
		[in, ptr] LPCOLESTR pszMachine,
		[in] IDebugPort2* pPort,
		[in, ptr] LPCOLESTR pszExe,
		[in, ptr] LPCOLESTR pszArgs,
		[in, ptr] LPCOLESTR pszDir,
		[in, ptr] BSTR bstrEnv,
		[in, ptr] LPCOLESTR pszOptions,
		[in] LAUNCH_FLAGS dwLaunchFlags,
		[in] DWORD hStdInput,
		[in] DWORD hStdOutput,
		[in] DWORD hStdError,
		[in] REFGUID guidLaunchingEngine,
		[in] IDebugEventCallback2* pCallback,
		[in, size_is(celtSpecificEngines)] GUID* rgguidSpecificEngines,
		[in] DWORD celtSpecificEngines,
		[out] IDebugProcess2** ppProcess);

	HRESULT RegisterJITServer(
		[in] REFCLSID clsidJITServer);

	HRESULT Terminate(
		[in] BOOL fForce);

	HRESULT Detach(void);

	HRESULT CauseBreak(void);

	HRESULT CreatePendingBreakpoint(
		[in] IDebugBreakpointRequest2* pBPRequest,
		[out] IDebugPendingBreakpoint2** ppPendingBP);

	HRESULT EnumPendingBreakpoints(
		[in] IDebugProgram2* pProgram,
		[in, ptr] LPCOLESTR pszProgram,
		[out] IEnumDebugPendingBreakpoints2** ppEnumBPs);

	HRESULT EnumMachines(
		[out] IEnumDebugMachines2** ppEnum);

	HRESULT AddMachine(
		[in, ptr] LPCOLESTR pszMachine,
		[out] IDebugMachine2** ppMachine);

	HRESULT RemoveMachine(
		[in] IDebugMachine2* pMachine);

	HRESULT ShutdownSession(void);

    HRESULT EnumCodeContexts(
		[in] IDebugProgram2* pProgram,
        [in] IDebugDocumentPosition2* pDocPos,
        [out] IEnumDebugCodeContexts2 **ppEnum);

	HRESULT SetException(
		[in] EXCEPTION_INFO* pException);

    HRESULT EnumSetExceptions(
		[in] IDebugProgram2* pProgram,
		[in, ptr] LPCOLESTR pszProgram,
		// Either guidLang or guidEng
		[in] REFGUID guidType,
        [out] IEnumDebugExceptionInfo2** ppEnum);

	HRESULT RemoveSetException(
		[in] EXCEPTION_INFO* pException);

	HRESULT RemoveAllSetExceptions(
		// Either guidLang or guidEng
		[in] REFGUID guidType);

	// The top-level default exceptions are pseudo-exceptions that describe the
	// default exception handling behavior for a given language or runtime architecture.
	// Example: "C++": EXCEPTION_STOP_SECOND_CHANCE
	// EXCEPTION_STOP_FIRST_CHANCE_USE_PARENT and EXCEPTION_STOP_SECOND_CHANCE_USE_PARENT
	// are invalid for these top-level pseudo-exceptions.
	HRESULT EnumDefaultExceptions(
		[in, ptr] EXCEPTION_INFO* pParentException,
		[out] IEnumDebugExceptionInfo2** ppEnum);

	HRESULT GetENCUpdate(
		[in] IDebugProgram2* pProgram,
		[out] IDebugENCUpdate** ppUpdate);

    HRESULT SetLocale(
        [in] WORD wLangID);

	HRESULT SetRegistryRoot(
		[in, ptr] LPCOLESTR pszRegistryRoot);

	HRESULT IsAlive(void);

    HRESULT ClearAllSessionThreadStackFrames(void);

	HRESULT GetSessionId(
		[in] IDebugEventCallback2* pCallback,
		[in, size_is(celtSpecificEngines), ptr] GUID* rgguidSpecificEngines,
		[in] DWORD celtSpecificEngines,
		[in, ptr] LPCOLESTR pszStartPageUrl,
		[out] BSTR* pbstrSessionId);

	HRESULT SetEngineMetric(
		[in] REFGUID guidEngine,
		[in] LPCOLESTR pszMetric,
		[in] VARIANT varValue);

	enum
	{
		STOPPING_MODEL_STOP_ALL	= 0x0001,
		STOPPING_MODEL_STOP_ONE	= 0x0002,
	};
	typedef DWORD STOPPING_MODEL;

	HRESULT SetStoppingModel(
		[in] STOPPING_MODEL dwStoppingModel);

	HRESULT GetStoppingModel(
		[out] STOPPING_MODEL* pdwStoppingModel);

	HRESULT RegisterSessionWithServer(
		[in] LPCOLESTR pwszServerName);
};

// ------------------------------------------------------------------
// IDebugEngine2
[
	object,
	uuid(ba105b52-12f1-4038-ae64-d95785874c47),
	pointer_default(unique)
]
interface IDebugEngine2: IUnknown
{
	enum
	{
		// Attaching because we launched the process
		// (prog create and thread create can be stopping events; send entry point, not attach complete)
		ATTACH_REASON_LAUNCH	= 0x0001,
		// Attaching because the user requested an attach
		// (prog create and thread create cannot be stopping events; send attach complete)
		ATTACH_REASON_USER		= 0x0002,
		// Attaching because we're already debugging the process
		// (prog create and thread create can be stopping events; send attach complete)
		ATTACH_REASON_AUTO		= 0x0003,
	};
	typedef DWORD ATTACH_REASON;

	HRESULT EnumPrograms(
		[out] IEnumDebugPrograms2** ppEnum);

	HRESULT Attach(
		[in, size_is(celtPrograms), length_is(celtPrograms)] IDebugProgram2** rgpPrograms,
		[in, size_is(celtPrograms), length_is(celtPrograms)] IDebugProgramNode2** rgpProgramNodes,
		[in] DWORD celtPrograms,
		[in] IDebugEventCallback2* pCallback,
		[in] ATTACH_REASON dwReason);

	HRESULT CreatePendingBreakpoint(
		[in] IDebugBreakpointRequest2* pBPRequest,
		[out] IDebugPendingBreakpoint2** ppPendingBP);

	HRESULT SetException(
		[in] EXCEPTION_INFO* pException);

	HRESULT RemoveSetException(
		[in] EXCEPTION_INFO* pException);

	HRESULT RemoveAllSetExceptions(
		// Either guidlang or guidEng
		[in] REFGUID guidType);

    HRESULT GetEngineId(
        [out] GUID *pguidEngine);

	HRESULT DestroyProgram(
		[in] IDebugProgram2* pProgram);

	HRESULT ContinueFromSynchronousEvent(
		[in] IDebugEvent2* pEvent);

    HRESULT SetLocale(
        [in] WORD wLangID);

	HRESULT SetRegistryRoot(
		[in, ptr] LPCOLESTR pszRegistryRoot);

	HRESULT SetMetric(
		[in] LPCOLESTR pszMetric,
		[in] VARIANT varValue);

	// These methods were added after the Office fork
	HRESULT CauseBreak(void);
};

// ------------------------------------------------------------------
// ILaunchableDebugEngine
[
    object,
	uuid(c7c1462f-9736-466c-b2c1-b6b2dedbf4a7),
	pointer_default(unique)
]
interface IDebugEngineLaunch2: IUnknown
{
	HRESULT LaunchSuspended(
		[in, ptr] LPCOLESTR pszMachine,
		[in] IDebugPort2* pPort,
		[in, ptr] LPCOLESTR pszExe,
		[in, ptr] LPCOLESTR pszArgs,
		[in, ptr] LPCOLESTR pszDir,
		[in, ptr] BSTR bstrEnv,
		[in, ptr] LPCOLESTR pszOptions,
		[in] LAUNCH_FLAGS dwLaunchFlags,
		[in] DWORD hStdInput,
		[in] DWORD hStdOutput,
		[in] DWORD hStdError,
		[in] IDebugEventCallback2* pCallback,
        [out] IDebugProcess2 **ppProcess);

    HRESULT ResumeProcess(
        [in] IDebugProcess2* pProcess);

	HRESULT CanTerminateProcess(
		[in] IDebugProcess2* pProcess);

	HRESULT TerminateProcess(
		[in] IDebugProcess2* pProcess);
};

// ------------------------------------------------------------------
// IDebugEventCallback2
[
	object,
	uuid(ade2eeb9-fc85-4f5b-b5d9-d431b4aac31a),
	pointer_default(unique)
]
interface IDebugEventCallback2: IUnknown
{
    enum
    {
		// The event is asynchronous; no reply is necessary
		EVENT_ASYNCHRONOUS	= 0x0000,
		// The event is synchronous; reply via IDebugEngine2::ContinueFromSynchronousEvent
		EVENT_SYNCHRONOUS	= 0x0001,
		// The event is stopping; reply via IDebugThread2::ContinueFromStoppingEvent
		EVENT_STOPPING		= 0x0002,
		EVENT_ASYNC_STOP	= 0x0002,		// (not currently supported)
        EVENT_SYNC_STOP		= 0x0003,
		// The event is sent immediately and synchronously to the IDE
		// (even if the IDE is currently handling an event)
		EVENT_IMMEDIATE		= 0x0004,
    };
	typedef DWORD EVENTATTRIBUTES;

	HRESULT Event(
		[in] IDebugEngine2* pEngine,
		[in] IDebugProcess2* pProcess,
		[in] IDebugProgram2* pProgram,
		[in] IDebugThread2* pThread,
		[in] IDebugEvent2* pEvent,
		[in] REFIID riidEvent,
		[in] DWORD dwAttrib);
};

// ------------------------------------------------------------------
// IDebugEvent2
[
	object,
	uuid(423238d6-da42-4989-96fb-6bba26e72e09),
	pointer_default(unique)
]
interface IDebugEvent2: IUnknown
{
	HRESULT GetAttributes(
		[out] DWORD* pdwAttrib);
};

// ------------------------------------------------------------------
// IDebugSessionCreateEvent2
[
	object,
	uuid(2c2b15b7-fc6d-45b3-9622-29665d964a76),
	pointer_default(unique)
]
interface IDebugSessionCreateEvent2: IUnknown
{
};

// ------------------------------------------------------------------
// IDebugSessionDestroyEvent2
[
	object,
	uuid(f199b2c2-88fe-4c5d-a0fd-aa046b0dc0dc),
	pointer_default(unique)
]
interface IDebugSessionDestroyEvent2: IUnknown
{
};

// ------------------------------------------------------------------
// IDebugEngineCreateEvent2
[
	object,
	uuid(fe5b734c-759d-4e59-ab04-f103343bdd06),
	pointer_default(unique)
]
interface IDebugEngineCreateEvent2: IUnknown
{
	HRESULT GetEngine(
		[out] IDebugEngine2 **pEngine);
};

// ------------------------------------------------------------------
// IDebugProcessCreateEvent2
[
	object,
	uuid(bac3780f-04da-4726-901c-ba6a4633e1ca),
	pointer_default(unique)
]
interface IDebugProcessCreateEvent2: IUnknown
{
};

// ------------------------------------------------------------------
// IDebugProcessDestroyEvent2
[
	object,
	uuid(3e2a0832-17e1-4886-8c0e-204da242995f),
	pointer_default(unique)
]
interface IDebugProcessDestroyEvent2: IUnknown
{
};

// ------------------------------------------------------------------
// IDebugProgramCreateEvent2
[
	object,
	uuid(96cd11ee-ecd4-4e89-957e-b5d496fc4139),
	pointer_default(unique)
]
interface IDebugProgramCreateEvent2: IUnknown
{
};

// ------------------------------------------------------------------
// IDebugProgramDestroyEvent2
[
	object,
	uuid(e147e9e3-6440-4073-a7b7-a65592c714b5),
	pointer_default(unique)
]
interface IDebugProgramDestroyEvent2: IUnknown
{
	HRESULT GetExitCode(
		[out] DWORD* pdwExit);
};

// ------------------------------------------------------------------
// IDebugThreadCreateEvent2
[
	object,
	uuid(2090ccfc-70c5-491d-a5e8-bad2dd9ee3ea),
	pointer_default(unique)
]
interface IDebugThreadCreateEvent2: IUnknown
{
};

// ------------------------------------------------------------------
// IDebugThreadDestroyEvent2
[
	object,
	uuid(2c3b7532-a36f-4a6e-9072-49be649b8541),
	pointer_default(unique)
]
interface IDebugThreadDestroyEvent2: IUnknown
{
	HRESULT GetExitCode(
		[out] DWORD* pdwExit);
};

// ------------------------------------------------------------------
// IDebugLoadCompleteEvent2
[
    object,
    uuid(b1844850-1349-45d4-9f12-495212f5eb0b),
    pointer_default(unique)
]
interface IDebugLoadCompleteEvent2: IUnknown
{
};

// ------------------------------------------------------------------
// IDebugEntryPointEvent2
[
	object,
	uuid(e8414a3e-1642-48ec-829e-5f4040e16da9),
	pointer_default(unique)
]
interface IDebugEntryPointEvent2: IUnknown
{
};

// ------------------------------------------------------------------
// IDebugStepCompleteEvent2
[
	object,
	uuid(0f7f24c1-74d9-4ea6-a3ea-7edb2d81441d),
	pointer_default(unique)
]
interface IDebugStepCompleteEvent2: IUnknown
{
};

// ------------------------------------------------------------------
// IDebugCanStopEvent2
[
	object,
	uuid(b5b0d747-d4d2-4e2d-872d-74da22037826),
	pointer_default(unique)
]
interface IDebugCanStopEvent2: IUnknown
{
	enum
	{
		CANSTOP_ENTRYPOINT  = 0x0000,
		CANSTOP_STEPIN      = 0x0001
	};
	typedef DWORD CANSTOP_REASON;

    HRESULT GetReason(
        [out] CANSTOP_REASON *pcr);

	HRESULT CanStop(
		[in] BOOL fCanStop);

	HRESULT GetDocumentContext(
		[out] IDebugDocumentContext2 **ppDocCxt);

	HRESULT GetCodeContext(
		[out] IDebugCodeContext2** ppCodeContext);
};

// ------------------------------------------------------------------
// IDebugBreakEvent2
[
	object,
	uuid(c7405d1d-e24b-44e0-b707-d8a5a4e1641b),
	pointer_default(unique)
]
interface IDebugBreakEvent2: IUnknown
{
};

// ------------------------------------------------------------------
// IDebugBreakpointEvent2
[
	object,
	uuid(501c1e21-c557-48b8-ba30-a1eab0bc4a74),
	pointer_default(unique)
]
interface IDebugBreakpointEvent2: IUnknown
{
	HRESULT EnumBreakpoints(
		[out] IEnumDebugBoundBreakpoints2** ppEnum);
};

// ------------------------------------------------------------------
// IDebugExceptionEvent2
[
	object,
	uuid(51a94113-8788-4a54-ae15-08b74ff922d0),
	pointer_default(unique)
]
interface IDebugExceptionEvent2: IUnknown
{
	HRESULT GetException(
		[out] EXCEPTION_INFO* pExceptionInfo);

	HRESULT GetExceptionDescription(
		[out] BSTR* pbstrDescription);

	HRESULT CanPassToDebuggee(void);

	HRESULT PassToDebuggee(
		[in] BOOL fPass);
};

// ------------------------------------------------------------------
// IDebugOutputStringEvent2
[
	object,
	uuid(569c4bb1-7b82-46fc-ae28-4536ddad753e),
	pointer_default(unique)
]
interface IDebugOutputStringEvent2: IUnknown
{
	HRESULT GetString(
		[out] BSTR* pbstrString);
};

// ------------------------------------------------------------------
// IDebugModuleLoadEvent2
[
	object,
	uuid(989db083-0d7c-40d1-a9d9-921bf611a4b2),
	pointer_default(unique)
]
interface IDebugModuleLoadEvent2: IUnknown
{
	HRESULT GetModule(
		[out] IDebugModule2** pModule,
		// Optional message that describes the event
		[in, out] BSTR* pbstrDebugMessage,
		// Set to TRUE if the module's loading; FALSE if unloading
		[in, out] BOOL* pbLoad);
};

// ------------------------------------------------------------------
// IDebugPropertyCreateEvent2
[
	object,
	uuid(ded6d613-a3db-4e35-bb5b-a92391133f03),
	pointer_default(unique)
]
interface IDebugPropertyCreateEvent2: IUnknown
{
	HRESULT GetDebugProperty(
		[out] IDebugProperty2** ppProperty);
};

// ------------------------------------------------------------------
// IDebugPropertyDestroyEvent2
[
	object,
	uuid(f3765f18-f395-4b8c-8e95-dcb3fe8e7ec8),
	pointer_default(unique)
]
interface IDebugPropertyDestroyEvent2: IUnknown
{
	HRESULT GetDebugProperty(
		[out] IDebugProperty2** ppProperty);
};

// ------------------------------------------------------------------
// IDebugBreakpointBoundEvent2

[
	object,
	uuid(1dddb704-cf99-4b8a-b746-dabb01dd13a0),
	pointer_default(unique)
]
interface IDebugBreakpointBoundEvent2: IUnknown
{
	HRESULT GetPendingBreakpoint(
		[out] IDebugPendingBreakpoint2** ppPendingBP);

	HRESULT EnumBoundBreakpoints(
		[out] IEnumDebugBoundBreakpoints2** ppEnum);
};

// ------------------------------------------------------------------
// IDebugBreakpointUnboundEvent2

[
	object,
	uuid(78d1db4f-c557-4dc5-a2dd-5369d21b1c8c),
	pointer_default(unique)
]
interface IDebugBreakpointUnboundEvent2: IUnknown
{
	HRESULT GetBreakpoint(
		[out] IDebugBoundBreakpoint2** ppBP);

	enum
	{
		BPUR_UNKNOWN			= 0x0001,
		BPUR_CODE_UNLOADED		= 0x0002,
		// BPUR_BREAKPOINT_REBIND means the breakpoint is being unbound
		// because it is being rebound to a different location. (For example,
		// this can happen after an ENC when the breakpoint moves, or if this
		// breakpoint was originally bound with a less than perfect file
		// name match.) Generally, the IDE will discard any persisted information
		// about this breakpoint.
		BPUR_BREAKPOINT_REBIND	= 0x0003,
        // BPUR_BREAKPOINT_ERROR means that the breakpoint was deemed to be in error
        // after it was bound.  This will happen for managed bps whose condition is
        // not valid.
        BPUR_BREAKPOINT_ERROR   = 0x0004
	};
	typedef DWORD BP_UNBOUND_REASON;

	HRESULT GetReason(
		[out] BP_UNBOUND_REASON* pdwUnboundReason);
};

// ------------------------------------------------------------------
// IDebugBreakpointErrorEvent2

[
	object,
	uuid(abb0ca42-f82b-4622-84e4-6903ae90f210),
	pointer_default(unique)
]
interface IDebugBreakpointErrorEvent2: IUnknown
{
	HRESULT GetErrorBreakpoint(
		[out] IDebugErrorBreakpoint2** ppErrorBP);
};

// ------------------------------------------------------------------
// IDebugExpressionEvaluationCompleteEvent2
[
	object,
	uuid(c0e13a85-238a-4800-8315-d947c960a843),
	pointer_default(unique)
]
interface IDebugExpressionEvaluationCompleteEvent2 : IUnknown
{
	HRESULT GetExpression(
		[out] IDebugExpression2** ppExpr);

	HRESULT GetResult(
		[out] IDebugProperty2** ppResult);
};

// ------------------------------------------------------------------
// IDebugReturnValueEvent2
[
	object,
	uuid(0da4d4cc-2d0b-410f-8d5d-b6b73a5d35d8),
	pointer_default(unique)
]
interface IDebugReturnValueEvent2: IUnknown
{
	HRESULT	GetReturnValue(
		[out] IDebugProperty2** ppReturnValue);
};

// ------------------------------------------------------------------
// IDebugFindSymbolEvent2
[
	object,
	uuid(4072ae37-3739-43c9-ac88-ca2ea79ed32b),
	pointer_default(unique)
]
interface IDebugFindSymbolEvent2 : IUnknown
{
	HRESULT SearchWithPath(
		[in] LPCOLESTR pszSymbolSearchURL);
};

// ------------------------------------------------------------------
// IDebugNoSymbolsEvent2
[
	object,
	uuid(3ad4fb48-647e-4b03-9c1e-52754e80c880),
	pointer_default(unique)
]
interface IDebugNoSymbolsEvent2: IUnknown
{
};

// ------------------------------------------------------------------
// IDebugProgramNameChangedEvent2
[
	object,
	uuid(e05c2dfd-59d5-46d3-a71c-5d07665d85af),
	pointer_default(unique)
]
interface IDebugProgramNameChangedEvent2: IUnknown
{
};

// ------------------------------------------------------------------
// IDebugThreadNameChangedEvent2
[
	object,
	uuid(1ef4ef78-2c44-4b7a-8473-8f4357611729),
	pointer_default(unique)
]
interface IDebugThreadNameChangedEvent2: IUnknown
{
};

// ------------------------------------------------------------------
// IDebugMessageEvent2
[
	object,
	uuid(3bdb28cf-dbd2-4d24-af03-01072b67eb9e),
	pointer_default(unique)
]
interface IDebugMessageEvent2: IUnknown
{
	enum
	{
		MT_OUTPUTSTRING		= 0x0001,
		MT_MESSAGEBOX		= 0x0002,
	};
	typedef DWORD MESSAGETYPE;

	HRESULT GetMessage(
		[out] MESSAGETYPE* pMessageType,
		[out] BSTR* pbstrMessage,
		// Use the MB_* constants
		[out] DWORD* pdwType,
		[out] BSTR* pbstrHelpFileName,
		[out] DWORD* pdwHelpId);

	HRESULT SetResponse(
		[in] DWORD dwResponse);

};

// ------------------------------------------------------------------
// IDebugActivateDocumentEvent2
[
	object,
	uuid(58f36c3d-7d07-4eba-a041-62f63e188037),
	pointer_default(unique)
]
interface IDebugActivateDocumentEvent2: IUnknown
{
	HRESULT GetDocument(
		[out] IDebugDocument2** ppDoc);

	HRESULT GetDocumentContext(
		[out] IDebugDocumentContext2** ppDocContext);
};

// ------------------------------------------------------------------
// IDebugProcess2
[
	object,
	uuid(43286fea-6997-4543-803e-60a20c473de5),
	pointer_default(unique)
]
interface IDebugProcess2: IUnknown
{
	enum
	{
		PIFLAG_SYSTEM_PROCESS		= 0x00000001,
		PIFLAG_DEBUGGER_ATTACHED	= 0x00000002,
	};
	typedef DWORD PROCESS_INFO_FLAGS;

	enum
	{
		PIF_FILE_NAME				= 0x00000001,
		PIF_BASE_NAME				= 0x00000002,
		PIF_TITLE					= 0x00000004,
		PIF_PROCESS_ID				= 0x00000008,
		PIF_SESSION_ID				= 0x00000010,
		PIF_ATTACHED_SESSION_NAME	= 0x00000020,
		PIF_CREATION_TIME			= 0x00000040,
		PIF_FLAGS					= 0x00000080,

		PIF_ALL						= 0x000000ff,
	};
	typedef DWORD PROCESS_INFO_FIELDS;

	typedef struct tagPROCESS_INFO
	{
		// Valid fields
		PROCESS_INFO_FIELDS	Fields;
		// Full path+file name+extension; equivalent to calling GetName(GN_FILENAME, ...)
		BSTR				bstrFileName;
		// File name+extension; equivalent to calling GetName(GN_BASENAME, ...)
		BSTR				bstrBaseName;
		// Title (if one exists); equivalent to calling GetName(GN_TITLE, ...)
		BSTR				bstrTitle;
		// Process id; equivalent to calling GetPhysicalProcessId
		AD_PROCESS_ID		ProcessId;
		// Session id: the system session that this process is running in
		DWORD				dwSessionId;
		// Attached session name (if one exists); equivalent to calling GetAttachedSessionName
		BSTR				bstrAttachedSessionName;
		// Time the process was created
		FILETIME			CreationTime;
		// Flags
		PROCESS_INFO_FLAGS	Flags;
	} PROCESS_INFO;

	HRESULT GetInfo(
		[in] PROCESS_INFO_FIELDS Fields,
		[out] PROCESS_INFO* pProcessInfo);

	HRESULT EnumPrograms(
		[out] IEnumDebugPrograms2** ppEnum);

	HRESULT GetName(
		[in] GETNAME_TYPE gnType,
		[out] BSTR* pbstrName);

	HRESULT GetMachine(
		[out] IDebugMachine2** ppMachine);

	HRESULT Terminate(void);

	HRESULT Attach(
		[in] IDebugEventCallback2* pCallback,
		[in, size_is(celtSpecificEngines)] GUID* rgguidSpecificEngines,
		[in] DWORD celtSpecificEngines,
		[out, size_is(celtSpecificEngines), length_is(celtSpecificEngines)] HRESULT* rghrEngineAttach);

	HRESULT CanDetach(void);

	HRESULT Detach(void);

	HRESULT GetPhysicalProcessId(
		[out] AD_PROCESS_ID* pProcessId);

	HRESULT GetProcessId(
		[out] GUID* pguidProcessId);

	HRESULT GetAttachedSessionName(
		[out] BSTR* pbstrSessionName);

	// Get a list of threads in this process (no duplicates)
	HRESULT EnumThreads(
		[out] IEnumDebugThreads2** ppEnum);

	HRESULT CauseBreak(void);

	HRESULT GetPort(
		[out] IDebugPort2** ppPort);
};

// ------------------------------------------------------------------
// IDebugProgram2
[
	object,
	uuid(69d172ef-f2c4-44e1-89f7-c86231e706e9),
	pointer_default(unique)
]
interface IDebugProgram2: IUnknown
{
	enum
	{
		STEP_INTO,
		STEP_OVER,
		STEP_OUT,
		STEP_BACKWARDS
	};
	typedef DWORD STEPKIND;

	enum
	{
		STEP_STATEMENT,
		STEP_LINE,
		STEP_INSTRUCTION,
	};
	typedef DWORD STEPUNIT;

	enum
	{
		DSS_HUGE		= 0x10000000,
		// Get the disasm for the function contained by the code context
		DSS_FUNCTION	= 0x0001,		
		// Get the disasm for the module contained by the code context
		DSS_MODULE		= (DSS_HUGE) | 0x0002,
		// Get the disasm for the entire address space
		DSS_ALL			= (DSS_HUGE) | 0x0003
	};
	typedef DWORD DISASSEMBLY_STREAM_SCOPE;

	HRESULT EnumThreads(
		[out] IEnumDebugThreads2** ppEnum);

	HRESULT GetName(
		[out] BSTR* pbstrName);

	HRESULT GetProcess(
		[out] IDebugProcess2** ppProcess);

	HRESULT Terminate(void);

	HRESULT Attach(
		[in] IDebugEventCallback2* pCallback);

	HRESULT CanDetach(void);

	HRESULT Detach(void);

	HRESULT GetProgramId(
		[out] GUID* pguidProgramId);

	HRESULT GetDebugProperty(
		[out] IDebugProperty2** ppProperty);

	HRESULT Execute(void);

    // Continue, preserving state
    HRESULT Continue(
        [in] IDebugThread2* pThread);

	HRESULT Step(
		[in] IDebugThread2* pThread,
		[in] STEPKIND sk,
		[in] STEPUNIT step);

	HRESULT CauseBreak(void);

	HRESULT GetEngineInfo(
		[out] BSTR* pbstrEngine,
		[out] GUID* pguidEngine);

	HRESULT EnumCodeContexts(
        [in] IDebugDocumentPosition2* pDocPos,
		[out] IEnumDebugCodeContexts2** ppEnum);

	HRESULT GetMemoryBytes(
		[out] IDebugMemoryBytes2** ppMemoryBytes);

	HRESULT GetDisassemblyStream(
		[in] DISASSEMBLY_STREAM_SCOPE dwScope,
		[in] IDebugCodeContext2* pCodeContext,
		[out] IDebugDisassemblyStream2** ppDisassemblyStream);

	HRESULT EnumModules(
		[out] IEnumDebugModules2** ppEnum);

	HRESULT GetENCUpdate(
		[out] IDebugENCUpdate** ppUpdate);

	typedef struct tagCODE_PATH
	{
		BSTR bstrName;
		IDebugCodeContext2* pCode;
	} CODE_PATH;

	HRESULT EnumCodePaths(
		[in, ptr] LPCOLESTR pszHint,
		[in] IDebugCodeContext2* pStart,
		[in] IDebugStackFrame2* pFrame,
		[in] BOOL fSource,
		[out] IEnumCodePaths2** ppEnum,
		[out] IDebugCodeContext2** ppSafety);

	enum
	{
		// "mini" dump of the program state
		DUMP_MINIDUMP,
		// full dump of the program state
		DUMP_FULLDUMP,
	};
	typedef DWORD DUMPTYPE;

	HRESULT WriteDump(
		[in] DUMPTYPE DumpType,
		[in] LPCOLESTR pszDumpUrl
		);

};

// ------------------------------------------------------------------
// IDebugEngineProgram2
[
	object,
	uuid(7ce3e768-654d-4ba7-8d95-cdaac642b141),
	pointer_default(unique)
]
interface IDebugEngineProgram2: IUnknown
{
	enum
	{
		// the program being notified is the leaf program (it owns the leaf frame)
		WATCHFOREVAL_LEAF_PROGRAM = 0x10000000
	};

	// Stop all threads running in this program
	HRESULT Stop(void);

    HRESULT WatchForThreadStep(
		[in] IDebugProgram2* pOriginatingProgram,
        [in] DWORD dwTid,
        [in] BOOL fWatch,
        [in] DWORD dwFrame);

	HRESULT WatchForExpressionEvaluationOnThread(
		[in] IDebugProgram2* pOriginatingProgram,
		[in] DWORD dwTid,
		[in] DWORD dwEvalFlags,
		[in] IDebugEventCallback2* pExprCallback,
		[in] BOOL fWatch);
};

// ------------------------------------------------------------------
// IDebugProgramHost2
[
	object,
	uuid(c99d588f-778c-44fe-8b2e-40124a738891),
	pointer_default(unique)
]
interface IDebugProgramHost2: IUnknown
{
	HRESULT GetHostName(
        [in] DWORD dwType,
		[out] BSTR* pbstrHostName);

	HRESULT GetHostId(
		[out] AD_PROCESS_ID* pProcessId);

	HRESULT GetHostMachineName(
		[out] BSTR* pbstrHostMachineName);
};

// ------------------------------------------------------------------
// IDebugProgramNode2
[
	object,
	uuid(426e255c-f1ce-4d02-a931-f9a254bf7f0f),
	pointer_default(unique)
]
interface IDebugProgramNode2: IUnknown
{
	enum
	{
		GHN_FRIENDLY_NAME,	// Gets friendly name of the host
		GHN_FILE_NAME,		// Gets the file name of the host
	};
	typedef DWORD GETHOSTNAME_TYPE;

	HRESULT GetProgramName(
		[out] BSTR* pbstrProgramName);

	HRESULT GetHostName(
		[in] GETHOSTNAME_TYPE dwHostNameType,
		[out] BSTR* pbstrHostName);

	HRESULT GetHostPid(
		[out] AD_PROCESS_ID* pHostProcessId);

	HRESULT GetHostMachineName(
		[out] BSTR* pbstrHostMachineName);

	HRESULT Attach(
		[in] IDebugProgram2* pMDMProgram,
		[in] IDebugEventCallback2* pCallback,
		[in] DWORD dwReason);

	HRESULT GetEngineInfo(
		[out] BSTR* pbstrEngine,
		[out] GUID* pguidEngine);

	HRESULT DetachDebugger(void);
};

// ------------------------------------------------------------------
// IDebugProgramEngines2
//
// IDebugProgramEngines2 is implemented by program nodes to indicate
// all the possible DEs that can debug this program. Once a DE is
// chosen (via some UI) that choice is registered by calling SetEngine.
// This engine will then be the engine returned by
// IDebugProgramNode::GetEngineInfo.
[
	object,
	uuid(fda24a6b-b142-447d-bbbc-8654a3d84f80),
	pointer_default(unique)
]
interface IDebugProgramEngines2: IUnknown
{
	// In order to determine how many engines there are, call once
	// with celtBuffer set to 0 and rgguidEngines set to NULL. This
	// function will return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
	// anytime the buffer is too small and *pceltEngines will contain
	// the necessary size of the buffer.
	HRESULT EnumPossibleEngines(
		[in] DWORD celtBuffer,
		[in, out, ptr, size_is(celtBuffer), length_is(*pceltEngines)] GUID* rgguidEngines,
		[in, out] DWORD* pceltEngines);

	// Tell the program/program node which engine to use for debugging this program
	HRESULT SetEngine(
		[in] REFGUID guidEngine);
};

// ------------------------------------------------------------------
// IDebugThread2
[
	object,
	uuid(d5168050-a57a-465c-bea9-974f405eba13),
	pointer_default(unique)
]
interface IDebugThread2: IUnknown
{
	enum
	{
		// The thread is running
		THREADSTATE_RUNNING		= 0x0001,
		// The thread is stopped because of a breakpoint
		THREADSTATE_STOPPED		= 0x0002,
		// The thread has been created, but is not yet running code
		THREADSTATE_FRESH		= 0x0003,
		// The thread is dead
		THREADSTATE_DEAD		= 0x0004,
		// The thread is frozen (no execution can be performed)
		THREADSTATE_FROZEN		= 0x0005,
	};
	typedef DWORD THREADSTATE;

	enum
	{
		TPF_ID				= 0x0001,
		TPF_SUSPENDCOUNT	= 0x0002,
		TPF_STATE			= 0x0004,
		TPF_PRIORITY		= 0x0008,
		TPF_NAME			= 0x0010,
		TPF_LOCATION		= 0x0020,

		TPF_ALLFIELDS		= 0xffffffff,
	};
	typedef DWORD THREADPROPERTY_FIELDS;

    typedef struct _tagTHREADPROPERTIES
    {
		THREADPROPERTY_FIELDS dwFields;
        DWORD dwThreadId;
        DWORD dwSuspendCount;
		DWORD dwThreadState;
        BSTR bstrPriority;
        BSTR bstrName;
		BSTR bstrLocation;
    } THREADPROPERTIES;

	enum
	{
		// FRAMEINFO fields
		FIF_FUNCNAME	        	= 0x00000001,
		FIF_RETURNTYPE	        	= 0x00000002,
		FIF_ARGS		        	= 0x00000004,
		FIF_LANGUAGE	        	= 0x00000008,
		FIF_MODULE		        	= 0x00000010, // The name of the module (m_bstrModule)
		FIF_STACKRANGE	         	= 0x00000020,
		FIF_FRAME		        	= 0x00000040,
		FIF_DEBUGINFO	        	= 0x00000080,
		FIF_STALECODE	        	= 0x00000100,
		FIF_ANNOTATEDFRAME			= 0x00000200,
		FIF_DEBUG_MODULEP           = 0x00000400, // the IDebugModule2* for this frame. (m_pModule)

		// Function name formatting

		// Fill in the m_bstrFuncName field as a single string using all the flags specified below
        // Specifying FIF_FUNCNAME | FIF_FUNCNAME_FORMAT | FIF_FUNCNAME_RETURNTYPE | FIF_FUNCNAME_ARGS | FIF_FUNCNAME_ARGS_TYPE | FIF_FUNCNAME_ARGS_NAMES | FIF_FUNCNAME_ARGS_VALUES
        // Results in: int CFoo::foo(int x = 1, int y = 2)

		FIF_FUNCNAME_FORMAT         = 0x00001000,
        // Add the return type to the formatted function name
		FIF_FUNCNAME_RETURNTYPE     = 0x00002000,
        // Add the args to the formatted function name
		FIF_FUNCNAME_ARGS           = 0x00004000,
        // Add the language to the formatted function name
		FIF_FUNCNAME_LANGUAGE       = 0x00008000,
		// Add the module name to the formatted function name
		FIF_FUNCNAME_MODULE         = 0x00010000,
		// Add the number of lines to the end of the function name
		FIF_FUNCNAME_LINES          = 0x00020000,
		// Add the bytes offset to the end of the function name
		FIF_FUNCNAME_OFFSET         = 0x00040000,

        // Function name argument formatting

		// Format the args in the formatted function name (example: (x = 3, y = 4))
		FIF_FUNCNAME_ARGS_TYPES		= 0x00100000,
		FIF_FUNCNAME_ARGS_NAMES		= 0x00200000,
		FIF_FUNCNAME_ARGS_VALUES	= 0x00400000,

        FIF_FUNCNAME_ARGS_ALL       = 0x00700000,

        // Argument formatting (in m_bstrArgs)
        FIF_ARGS_TYPES              = 0x01000000,
        FIF_ARGS_NAMES              = 0x02000000,
        FIF_ARGS_VALUES             = 0x04000000,

        FIF_ARGS_ALL                = 0x07000000,

		// If a client wants to be able to manipulate each arg separately,
		// set the FIF_ARGS_NOFORMAT and each FIF_ARGS_* flag will cause a
		// null-termianted string to be added to m_bstrArgs.
		// m_bstrArgs will then contain a series of null-terminated strings--
		// one string per flag per arg. For example, if the name and value
		// flag are set and there are two args x and y, the string would be
		// "x<null char>3<null char>y<null char>4<null char>".
		FIF_ARGS_NOFORMAT       	= 0x08000000,
	};
	typedef DWORD FRAMEINFO_FLAGS;

	typedef struct tagFRAMEINFO
	{
		FRAMEINFO_FLAGS			m_dwValidFields;	// which FRAMEINFO fields were successfully initialized
		BSTR					m_bstrFuncName;		// function name
		BSTR					m_bstrReturnType;	// function return type
		BSTR					m_bstrArgs;			// function arguments (
		BSTR					m_bstrLanguage;		// language name
		BSTR					m_bstrModule;		// module name (i.e. "msvcrt.dll" or "Test.class")
		UINT64					m_addrMin;			// minimum physical stack address
		UINT64					m_addrMax;			// maximum physical stack address
		IDebugStackFrame2*		m_pFrame;			// IDebugStackFrame2 object corresponding to this stack frame
		IDebugModule2*			m_pModule;			// Module this frame is in.
		BOOL                    m_fHasDebugInfo;    // TRUE if there is debug information in that frame.
		BOOL					m_fStaleCode;		// TRUE if frame corresponds to stale code
		BOOL					m_fAnnotatedFrame;	// TRUE if frame is a faked [a.k.a. annotated] frame by SDM
	} FRAMEINFO;

	HRESULT EnumFrameInfo(
		[in]  FRAMEINFO_FLAGS dwFieldSpec,
		[in]  UINT nRadix,
		[out] IEnumDebugFrameInfo2** ppEnum);

	HRESULT GetName(
		[out] BSTR* pbstrName);

	HRESULT SetThreadName(
		[in] LPCOLESTR pszName);

	HRESULT GetProgram(
		[out] IDebugProgram2** ppProgram);

    HRESULT CanSetNextStatement(
		[in] IDebugStackFrame2* pStackFrame,
		[in] IDebugCodeContext2* pCodeContext);

	HRESULT SetNextStatement (
		[in] IDebugStackFrame2* pStackFrame,
		[in] IDebugCodeContext2* pCodeContext);

	HRESULT GetThreadId(
		[out] DWORD* pdwThreadId);

    HRESULT Suspend(
        [out] DWORD *pdwSuspendCount);

    HRESULT Resume(
        [out] DWORD *pdwSuspendCount);

    HRESULT GetThreadProperties(
		[in] THREADPROPERTY_FIELDS dwFields,
        [out] THREADPROPERTIES *ptp);

	HRESULT GetLogicalThread(
		[in] IDebugStackFrame2* pStackFrame,
		[out] IDebugLogicalThread2 **ppLogicalThread);
};

// ------------------------------------------------------------------
// IDebugLogicalThread2
// {95E4AC61-D37E-4fce-B6C6-C05A80AB946A}
// DEFINE_GUID(<<name>>,
// 0x95e4ac61, 0xd37e, 0x4fce, 0xb6, 0xc6, 0xc0, 0x5a, 0x80, 0xab, 0x94, 0x6a);
[
	object,
	uuid(88d2f75b-d329-4e03-9b75-201f7782d8bd),
	pointer_default(unique)
]
interface IDebugLogicalThread2 : IUnknown
{
	HRESULT EnumFrameInfo
	(
		[in]  FRAMEINFO_FLAGS dwFieldSpec,
		[in]  UINT nRadix,
		[out] IEnumDebugFrameInfo2** ppEnum
	);
};

// Place holder for when we add execution control methods to the thread
#if 0
// ------------------------------------------------------------------
// IDebugEngineThread2
[
	object,
	uuid(2c2c9a62-96cd-4d5f-839e-7002dc55504b),
	pointer_default(unique)
]
interface IDebugEngineThread2: IUnknown
{
};
#endif

// -----------------------------------------------------------------------
// IDebugProperty2 and IDebugReference2 attributes

cpp_quote("#define DBG_ATTRIB_NONE					0x0000000000000000")
cpp_quote("#define DBG_ATTRIB_ALL					0xffffffffffffffff")

// Attributes about the object itself

// The reference/property is expandable
cpp_quote("#define DBG_ATTRIB_OBJ_IS_EXPANDABLE		0x0000000000000001")

// Attributes about the value of the object

// The value of this reference/property is read only
cpp_quote("#define DBG_ATTRIB_VALUE_READONLY		0x0000000000000010")
// The value is an error
cpp_quote("#define DBG_ATTRIB_VALUE_ERROR			0x0000000000000020")
// The evaluation caused a side effect
cpp_quote("#define DBG_ATTRIB_VALUE_SIDE_EFFECT		0x0000000000000040")
// This property is really a container of overloads
cpp_quote("#define DBG_ATTRIB_OVERLOADED_CONTAINER	0x0000000000000080")
// This property is a boolean value
cpp_quote("#define DBG_ATTRIB_VALUE_BOOLEAN			0x0000000000000100")
// If DBG_ATTRIB_VALUE_BOOLEAN is set,
// then this flag indicates whether the boolean value is true or false
cpp_quote("#define DBG_ATTRIB_VALUE_BOOLEAN_TRUE	0x0000000000000200")
// The value for this property is invalid (i.e. has no value)
cpp_quote("#define DBG_ATTRIB_VALUE_INVALID			0x0000000000000400")
// The value for this property is NAT (not a thing)
cpp_quote("#define DBG_ATTRIB_VALUE_NAT				0x0000000000000800")
// The value for this property has possibly been autoexpanded
cpp_quote("#define DBG_ATTRIB_VALUE_AUTOEXPANDED	0x0000000000001000")

// Attributes that describe field access control
cpp_quote("#define DBG_ATTRIB_ACCESS_NONE			0x0000000000010000")
cpp_quote("#define DBG_ATTRIB_ACCESS_PUBLIC			0x0000000000020000")
cpp_quote("#define DBG_ATTRIB_ACCESS_PRIVATE		0x0000000000040000")
cpp_quote("#define DBG_ATTRIB_ACCESS_PROTECTED		0x0000000000080000")
cpp_quote("#define DBG_ATTRIB_ACCESS_FINAL			0x0000000000100000")

cpp_quote("#define DBG_ATTRIB_ACCESS_ALL			0x00000000001f0000")

// Attributes that describe storage types
cpp_quote("#define DBG_ATTRIB_STORAGE_NONE			0x0000000001000000")
cpp_quote("#define DBG_ATTRIB_STORAGE_GLOBAL		0x0000000002000000")
cpp_quote("#define DBG_ATTRIB_STORAGE_STATIC		0x0000000004000000")
cpp_quote("#define DBG_ATTRIB_STORAGE_REGISTER		0x0000000008000000")

cpp_quote("#define DBG_ATTRIB_STORAGE_ALL			0x000000000f000000")

// Attributes that describe type modifiers
cpp_quote("#define DBG_ATTRIB_TYPE_NONE				0x0000000100000000")
cpp_quote("#define DBG_ATTRIB_TYPE_VIRTUAL			0x0000000200000000")
cpp_quote("#define DBG_ATTRIB_TYPE_CONSTANT			0x0000000400000000")
cpp_quote("#define DBG_ATTRIB_TYPE_SYNCHRONIZED		0x0000000800000000")
cpp_quote("#define DBG_ATTRIB_TYPE_VOLATILE			0x0000001000000000")

cpp_quote("#define DBG_ATTRIB_TYPE_ALL				0x0000001f00000000")

// Attributes that describe the IDebugProperty2 type
cpp_quote("#define DBG_ATTRIB_DATA					0x0000010000000000")
cpp_quote("#define DBG_ATTRIB_METHOD				0x0000020000000000")
cpp_quote("#define DBG_ATTRIB_PROPERTY				0x0000040000000000")
cpp_quote("#define DBG_ATTRIB_CLASS					0x0000080000000000")
cpp_quote("#define DBG_ATTRIB_BASECLASS				0x0000100000000000")
cpp_quote("#define DBG_ATTRIB_INTERFACE				0x0000200000000000")
cpp_quote("#define DBG_ATTRIB_INNERCLASS			0x0000400000000000")
cpp_quote("#define DBG_ATTRIB_MOSTDERIVEDCLASS		0x0000800000000000")

cpp_quote("#define DBG_ATTRIB_CHILD_ALL				0x0000ff0000000000")

typedef UINT64 DBG_ATTRIB_FLAGS;

// -----------------------------------------------------------------------
// IDebugProperty2

enum
{
	DEBUGPROP_INFO_FULLNAME				= 0x00000001,
	DEBUGPROP_INFO_NAME					= 0x00000002,
	DEBUGPROP_INFO_TYPE					= 0x00000004,
	DEBUGPROP_INFO_VALUE				= 0x00000008,
	DEBUGPROP_INFO_ATTRIB				= 0x00000010,
	DEBUGPROP_INFO_PROP					= 0x00000020,

	DEBUGPROP_INFO_VALUE_AUTOEXPAND		= 0x00010000,
	DEBUGPROP_INFO_NOFUNCEVAL			= 0x00020000, // hack for VS7.0 for locals window scenario

	DEBUGPROP_INFO_NONE					= 0x00000000,
	DEBUGPROP_INFO_STANDARD				= DEBUGPROP_INFO_ATTRIB | DEBUGPROP_INFO_NAME | DEBUGPROP_INFO_TYPE | DEBUGPROP_INFO_VALUE,
	DEBUGPROP_INFO_ALL					= 0xffffffff
};
typedef DWORD DEBUGPROP_INFO_FLAGS;

typedef struct tagDEBUG_PROPERTY_INFO
{
	DEBUGPROP_INFO_FLAGS	dwFields;
	BSTR					bstrFullName;
	BSTR					bstrName;
	BSTR					bstrType;
	BSTR					bstrValue;
	IDebugProperty2*		pProperty;
	DBG_ATTRIB_FLAGS		dwAttrib;
} DEBUG_PROPERTY_INFO;

[
	object,
	uuid(a7ee3e7e-2dd2-4ad7-9697-f4aae3427762),
	pointer_default(unique)
]
interface IDebugProperty2: IUnknown
{
	// Get the DEBUG_PROPERTY_INFO that describes this property
	HRESULT GetPropertyInfo(
		[in] DEBUGPROP_INFO_FLAGS dwFields,
		[in] DWORD dwRadix,
		[in] DWORD dwTimeout,
		[in, ptr, size_is(dwArgCount), length_is(dwArgCount)] IDebugReference2** rgpArgs,
		[in] DWORD dwArgCount,
		[out] DEBUG_PROPERTY_INFO* pPropertyInfo);

	// Set the value of this property
	HRESULT SetValueAsString(
		[in] LPCOLESTR pszValue,
		[in] DWORD dwRadix,
		[in] DWORD dwTimeout);

	// Set the value of this property
	HRESULT SetValueAsReference(
		[in, ptr, size_is(dwArgCount), length_is(dwArgCount)] IDebugReference2** rgpArgs,
		[in] DWORD dwArgCount,
		[in] IDebugReference2* pValue,
		[in] DWORD dwTimeout);

	// Enum the children of this property
	HRESULT EnumChildren(
		[in] DEBUGPROP_INFO_FLAGS dwFields,
		[in] DWORD dwRadix,
		[in] REFGUID guidFilter,
		[in] DBG_ATTRIB_FLAGS dwAttribFilter,
		[in, ptr] LPCOLESTR pszNameFilter,
		[in] DWORD dwTimeout,
		[out] IEnumDebugPropertyInfo2** ppEnum);

	// Get the parent of this property
	HRESULT GetParent(
		[out] IDebugProperty2** ppParent);

	// Get the property that describes the derived most property of this property
	HRESULT GetDerivedMostProperty(
		[out] IDebugProperty2** ppDerivedMost);

	// Get the memory bytes that contains this property
	HRESULT GetMemoryBytes(
		[out] IDebugMemoryBytes2** ppMemoryBytes);

	// Get a memory context for this property within the memory bytes returned by GetMemoryBytes
	HRESULT GetMemoryContext(
		[out] IDebugMemoryContext2** ppMemory);

	// Get the size (in bytes) of this property
	HRESULT GetSize(
		[out] DWORD* pdwSize);

	// Get a reference for this property
	HRESULT GetReference(
		[out] IDebugReference2** ppReference);

	// Get extended info for this property
	HRESULT GetExtendedInfo(
		[in] REFGUID guidExtendedInfo,
		[out] VARIANT* pExtendedInfo);
};

// -----------------------------------------------------------------------
// IDebugReference2

enum
{
	// Weak reference
	REF_TYPE_WEAK						= 0x0001,
	// Strong reference
	REF_TYPE_STRONG						= 0x0002,
};
typedef DWORD REFERENCE_TYPE;

enum
{
	DEBUGREF_INFO_NAME					= 0x00000001,
	DEBUGREF_INFO_TYPE					= 0x00000002,
	DEBUGREF_INFO_VALUE					= 0x00000004,
	DEBUGREF_INFO_ATTRIB				= 0x00000008,
	DEBUGREF_INFO_REFTYPE				= 0x00000010,
	DEBUGREF_INFO_REF					= 0x00000020,

	DEBUGREF_INFO_VALUE_AUTOEXPAND		= 0x00010000,

	DEBUGREF_INFO_NONE					= 0x00000000,
	DEBUGREF_INFO_ALL					= 0xffffffff
};
typedef DWORD DEBUGREF_INFO_FLAGS;

typedef struct tagDEBUG_REFERENCE_INFO
{
	DEBUGREF_INFO_FLAGS		dwFields;
	BSTR					bstrName;
	BSTR					bstrType;
	BSTR					bstrValue;
	DBG_ATTRIB_FLAGS		dwAttrib;
	REFERENCE_TYPE			dwRefType;
	IDebugReference2*		pReference;
} DEBUG_REFERENCE_INFO;

[
	object,
	uuid(10b793ac-0c47-4679-8454-adb36f29f802),
	pointer_default(unique)
]
interface IDebugReference2: IUnknown
{
	// Get the DEBUG_REFERENCE_INFO that describes this reference
	HRESULT GetReferenceInfo(
		[in] DEBUGREF_INFO_FLAGS dwFields,
		[in] DWORD dwRadix,
		[in] DWORD dwTimeout,
		[in, size_is(dwArgCount), length_is(dwArgCount)] IDebugReference2** rgpArgs,
		[in] DWORD dwArgCount,
		[out] DEBUG_REFERENCE_INFO* pReferenceInfo);

	// Set the value of this reference
	HRESULT SetValueAsString(
		[in] LPCOLESTR pszValue,
		[in] DWORD dwRadix,
		[in] DWORD dwTimeout);

	// Set the value of this reference
	HRESULT SetValueAsReference(
		[in, size_is(dwArgCount), length_is(dwArgCount)] IDebugReference2** rgpArgs,
		[in] DWORD dwArgCount,
		[in] IDebugReference2* pValue,
		[in] DWORD dwTimeout);

	// Enum the children of this reference
	HRESULT EnumChildren(
		[in] DEBUGREF_INFO_FLAGS dwFields,
		[in] DWORD dwRadix,
		[in] DBG_ATTRIB_FLAGS dwAttribFilter,
		[in, ptr] LPCOLESTR pszNameFilter,
		[in] DWORD dwTimeout,
		[out] IEnumDebugReferenceInfo2** ppEnum);

	// Get the parent of this reference
	HRESULT GetParent(
		[out] IDebugReference2** ppParent);

	// Get the reference that describes the derived most reference of this reference
	HRESULT GetDerivedMostReference(
		[out] IDebugReference2** ppDerivedMost);

	// Get the memory bytes that contains this reference
	HRESULT GetMemoryBytes(
		[out] IDebugMemoryBytes2** ppMemoryBytes);

	// Get a memory context for this reference within the memory bytes returned by GetMemoryBytes
	HRESULT GetMemoryContext(
		[out] IDebugMemoryContext2** ppMemory);

	// Get the size (in bytes) of this reference
	HRESULT GetSize(
		[out] DWORD* pdwSize);

	// Set the reference type (weak or strong)
	HRESULT SetReferenceType(
		[in] REFERENCE_TYPE dwRefType);

	enum
	{
		REF_COMPARE_EQUAL				= 0x0001,
		REF_COMPARE_LESS_THAN			= 0x0002,
		REF_COMPARE_GREATER_THAN		= 0x0003,
	};
	typedef DWORD REFERENCE_COMPARE;

	// Compare this reference with the one given in the matter given
	// result = this cwCompare pReference
	HRESULT Compare(
		[in] REFERENCE_COMPARE dwCompare,
		[in] IDebugReference2* pReference);
};

// ------------------------------------------------------------------
// IDebugStackFrame2
[
	object,
	uuid(1412926f-5dd6-4e58-b648-e1c63e013d51),
	pointer_default(unique)
]
interface IDebugStackFrame2: IUnknown
{
	HRESULT GetCodeContext(
		[out] IDebugCodeContext2** ppCodeCxt);

	HRESULT GetDocumentContext(
		[out] IDebugDocumentContext2** ppCxt);

	HRESULT GetName(
		[out] BSTR* pbstrName);

	HRESULT GetInfo(
		[in]  FRAMEINFO_FLAGS dwFieldSpec,
		[in]  UINT nRadix,
		[out] FRAMEINFO* pFrameInfo);

	// Returns a machine dependent representation of the range of physical addresses
	// associated with this stack frame. This is used by the process debug manager to sort
	// the stack frames from multiple script engines. By convention, stacks grow down and,
	// as such, on architectures where stacks grow up the addresses should be
	// twos-complemented.
	// NOTE: This implementation will not work for cross-process or cross-machine stacks
	HRESULT GetPhysicalStackRange(
		[out] UINT64* paddrMin,
		[out] UINT64* paddrMax);

	HRESULT GetExpressionContext(
		[out] IDebugExpressionContext2** ppExprCxt);

	HRESULT GetLanguageInfo(
		[in, out, ptr] BSTR* pbstrLanguage,
		[in, out, ptr] GUID* pguidLanguage);

	HRESULT GetDebugProperty(
		[out] IDebugProperty2** ppProperty);

	// PERF API - Get the count of locals as well as the enumerator
	// This API may not be supported by all LEs, so if it fails, use the generic
	// approach through GetDebugProperty.  However, if this API is supported it
	// may save a few cross-process calls
	HRESULT EnumProperties(
		[in] DEBUGPROP_INFO_FLAGS dwFields,
		[in] UINT nRadix,
		[in] REFGUID guidFilter,
		[in] DWORD dwTimeout,
		[out] ULONG* pcelt,
		[out] IEnumDebugPropertyInfo2** ppEnum);

	HRESULT GetThread(
		[out] IDebugThread2** ppThread);
};

// ------------------------------------------------------------------
// IDebugMemoryContext2

[
	object,
	uuid(1ab276dd-f27b-4445-825d-5df0b4a04a3a),
	pointer_default(unique)
]
interface IDebugMemoryContext2: IUnknown
{
	enum
	{
		CONTEXT_EQUAL					= 0x0001,
		CONTEXT_LESS_THAN				= 0x0002,
		CONTEXT_GREATER_THAN			= 0x0003,
		CONTEXT_LESS_THAN_OR_EQUAL		= 0x0004,
		CONTEXT_GREATER_THAN_OR_EQUAL	= 0x0005,
		CONTEXT_SAME_SCOPE				= 0x0006,
		CONTEXT_SAME_FUNCTION			= 0x0007,
		CONTEXT_SAME_MODULE				= 0x0008,
		CONTEXT_SAME_PROCESS			= 0x0009,
	};
	typedef DWORD CONTEXT_COMPARE;

	enum
	{
		CIF_MODULEURL		= 0x00000001,
		CIF_FUNCTION		= 0x00000002,
		CIF_FUNCTIONOFFSET	= 0x00000004,
		CIF_ADDRESS			= 0x00000008,
		CIF_ADDRESSOFFSET	= 0x00000010,
        CIF_ADDRESSABSOLUTE = 0x00000020,
		
		CIF_ALLFIELDS		= 0x0000003f,
	};
	typedef DWORD CONTEXT_INFO_FIELDS;

	typedef struct _tagCONTEXT_INFO
	{
		CONTEXT_INFO_FIELDS dwFields;
		BSTR bstrModuleUrl;
		BSTR bstrFunction;
		TEXT_POSITION posFunctionOffset;
		BSTR bstrAddress;
		BSTR bstrAddressOffset;
        BSTR bstrAddressAbsolute;
	} CONTEXT_INFO;

	HRESULT GetName(
		[out] BSTR* pbstrName);

	HRESULT GetInfo(
		[in] CONTEXT_INFO_FIELDS dwFields,
		[out] CONTEXT_INFO* pInfo);

	HRESULT Add(
		[in] UINT64 dwCount,
		[out] IDebugMemoryContext2** ppMemCxt);

	HRESULT Subtract(
		[in] UINT64 dwCount,
		[out] IDebugMemoryContext2** ppMemCxt);

	HRESULT Compare(
		[in] CONTEXT_COMPARE compare,
		[in, size_is(dwMemoryContextSetLen), length_is(dwMemoryContextSetLen)] IDebugMemoryContext2** rgpMemoryContextSet,
		[in] DWORD dwMemoryContextSetLen,
		[out] DWORD* pdwMemoryContext);
};

// ------------------------------------------------------------------
// IDebugCodeContext2
[
	object,
	uuid(ac17b76b-2b09-419a-ad5f-7d7402da8875),
	pointer_default(unique)
]
interface IDebugCodeContext2: IDebugMemoryContext2
{
	HRESULT GetDocumentContext(
		[out] IDebugDocumentContext2 **ppSrcCxt);

	HRESULT GetLanguageInfo(
		[in, out, ptr] BSTR* pbstrLanguage,
		[in, out, ptr] GUID* pguidLanguage);
};

// ------------------------------------------------------------------
// IDebugMemoryBytes2

[
	object,
	uuid(925837d1-3aa1-451a-b7fe-cc04bb42cfb8),
	pointer_default(unique)
]
interface IDebugMemoryBytes2: IUnknown
{
	HRESULT ReadAt(
		[in] IDebugMemoryContext2* pStartContext,
		[in] DWORD dwCount,
		[out, size_is(dwCount), length_is(*pdwRead)] BYTE* rgbMemory,
		[out] DWORD* pdwRead,
		[in, out, ptr] DWORD* pdwUnreadable);

	HRESULT WriteAt(
		[in] IDebugMemoryContext2* pStartContext,
		[in] DWORD dwCount,
		[in, size_is(dwCount), length_is(dwCount)] BYTE* rgbMemory);

	HRESULT GetSize(
		[out] UINT64* pqwSize);
};

// ------------------------------------------------------------------
// IDebugDisassemblyStream2

[
	object,
	uuid(e5b017fe-dfb0-411c-8266-7c64d6f519f8),
	pointer_default(unique)
]
interface IDebugDisassemblyStream2: IUnknown
{
	enum
	{
		DSF_ADDRESS             = 0x00000001,
		DSF_ADDRESSOFFSET       = 0x00000002,
		DSF_CODEBYTES           = 0x00000004,
		DSF_OPCODE              = 0x00000008,
		DSF_OPERANDS            = 0x00000010,
		DSF_SYMBOL              = 0x00000020,
		DSF_CODELOCATIONID      = 0x00000040,
		DSF_POSITION            = 0x00000080,
		DSF_DOCUMENTURL         = 0x00000100,
		DSF_BYTEOFFSET          = 0x00000200,
		DSF_FLAGS               = 0x00000400,

		// Use DSF_OPERANDS_SYMBOLS to include symbol names in the bstrOperands field
		DSF_OPERANDS_SYMBOLS    = 0x00010000,

		DSF_ALL                 = 0x000107ff,
	};
	typedef DWORD DISASSEMBLY_STREAM_FIELDS;

	enum
	{
		// Indicates this instruction is in a different document than the previous one
		DF_DOCUMENTCHANGE               = 0x00000001,
		// Indicates this instruction will not be exuecuted
		DF_DISABLED                     = 0x00000002,
		// Indicates this instruction is one of the next instructions to be executed
		// (there may be more than one)
		DF_INSTRUCTION_ACTIVE           = 0x00000004,
		// Indicates this instruction is really data (not code)
		DF_DATA                         = 0x00000008,
		// Indicates this instruction has source
		DF_HASSOURCE                    = 0x00000010
	};
	typedef DWORD DISASSEMBLY_FLAGS;

	typedef struct tagDisassemblyData
	{
		// Indicates which fields are valid
		DISASSEMBLY_STREAM_FIELDS dwFields;
		// The address for this instruction
		BSTR bstrAddress;
		// The address as an offset from some starting point (usually function)
		BSTR bstrAddressOffset;
		// The code bytes for this instruction
		BSTR bstrCodeBytes;
		// The opcode for this instruction
		BSTR bstrOpcode;
		// The operands for this instruction
		BSTR bstrOperands;
		// The symbol name, if any, associated with this address (public symbol, label, etc.)
		BSTR bstrSymbol;
		// Code location identifier (uCodeLocationId) for this line of disasm.
		// They have these properties.
		// 1. Unique within the disasm stream
		// 2. Ordered in the same way as addresses (iff DisasmLine1.CodeContext.Address >
		//    DisasmLine2.CodeContext.Address then DisasmLine1.uCodeLocationId >
		//    DisasmLine2.uCodeLocationId)
		// 3. As a consequense of #2, IDs should always increase as one go down the DisasmData array
		UINT64 uCodeLocationId;
		// For text documents that can be repesented as filenames:
		//    bstrDocumentUrl is filled in with the file://filename where the source can be found.
		// For text documents that cannot be repesented as filenames:
		//    bstrDocumentUrl is a unique identifier for the document. The debug engine
		//    must implement 'IDebugDisassemblyStream2::GetDocument'
		// For non-text documents:
		//    bstrDocumentUrl should be left as NULL. A doc context can be obtained from the code
		//    context
		// For Both:
		//    Note that if bstrDocumentUrl is the same as the bstrDocumentUrl in the previous
		//    DisassemblyData array element, then bstrDocumentUrl should be NULL, otherwise,
		//    bstrDocumentUrl should not be NULL (if it is requested) and DF_DOCUMENTCHANGE should be set
		TEXT_POSITION posBeg;
		TEXT_POSITION posEnd;
		BSTR bstrDocumentUrl;
		// The number of bytes this instruction is from the beginning of the line
		DWORD dwByteOffset;
		// Flags
		DISASSEMBLY_FLAGS dwFlags;
	} DisassemblyData;

	enum
	{
		SEEK_START_BEGIN        = 0x0001,
		SEEK_START_END          = 0x0002,
		SEEK_START_CURRENT      = 0x0003,
		SEEK_START_CODECONTEXT  = 0x0004,
                SEEK_START_CODELOCID    = 0x0005
	};
	typedef DWORD SEEK_START;

	HRESULT Read(
		// Set dwInstruction to 0 for !DSS_HUGE address spaces to read the entire address space
		[in] DWORD dwInstructions,
		[in] DISASSEMBLY_STREAM_FIELDS dwFields,
		[out] DWORD* pdwInstructionsRead,
		[out, size_is(dwInstructions), length_is(*pdwInstructionsRead)] DisassemblyData* prgDisassembly);

	HRESULT Seek(
		[in] SEEK_START dwSeekStart,
		[in] IDebugCodeContext2* pCodeContext,
		[in] UINT64 uCodeLocationId,
		[in] INT64 iInstructions);

	// If the code context is outside the scope of code contexts which can be
	// disassembled by this stream, but is still a valid code context. then
	// *puCodeLocationId should be zero, and the return value is E_CODE_CONTEXT_OUT_OF_SCOPE
	HRESULT GetCodeLocationId(
		[in] IDebugCodeContext2* pCodeContext,
		[out] UINT64* puCodeLocationId);

	HRESULT GetCodeContext(
		[in] UINT64 uCodeLocationId,
		[out] IDebugCodeContext2** ppCodeContext);

	HRESULT GetCurrentLocation(
		[out] UINT64* puCodeLocationId);		

	// implemented by engines that have text documents, but where bstrDocumentUrl
	// can not be passed as a filename
	HRESULT GetDocument(
		[in] BSTR bstrDocumentUrl,
		[out] IDebugDocument2** ppDocument);

	HRESULT GetScope(
		[out] DISASSEMBLY_STREAM_SCOPE* pdwScope);

	HRESULT GetSize(
		[out] UINT64 *pnSize);
};


// ------------------------------------------------------------------
// IDebugDocumentContext2
[
	object,
	uuid(931516ad-b600-419c-88fc-dcf5183b5fa9),
	pointer_default(unique)
]
interface IDebugDocumentContext2: IUnknown
{
	HRESULT GetDocument(
		[out] IDebugDocument2 **ppDocument);

	HRESULT GetName(
		[in] GETNAME_TYPE gnType,
		[out] BSTR *pbstrFileName);

	HRESULT EnumCodeContexts(
		[out] IEnumDebugCodeContexts2 **ppEnumCodeCxts);

	HRESULT GetLanguageInfo(
		[in, out, ptr] BSTR* pbstrLanguage,
		[in, out, ptr] GUID* pguidLanguage);

	HRESULT GetStatementRange(
		[in, out, ptr] TEXT_POSITION* pBegPosition,
		[in, out, ptr] TEXT_POSITION* pEndPosition);

	HRESULT GetSourceRange(
		[in, out, ptr] TEXT_POSITION* pBegPosition,
		[in, out, ptr] TEXT_POSITION* pEndPosition);

	enum
	{
		DOCCONTEXT_EQUAL			= 0x0001,
		DOCCONTEXT_LESS_THAN		= 0x0002,
		DOCCONTEXT_GREATER_THAN		= 0x0003,
		DOCCONTEXT_SAME_DOCUMENT	= 0x0004,
	};
	typedef DWORD DOCCONTEXT_COMPARE;

	HRESULT Compare(
		[in] DOCCONTEXT_COMPARE compare,
		[in, size_is(dwDocContextSetLen), length_is(dwDocContextSetLen)] IDebugDocumentContext2** rgpDocContextSet,
		[in] DWORD dwDocContextSetLen,
		[out] DWORD* pdwDocContext);

	HRESULT Seek(
		[in] int nCount,
		[out] IDebugDocumentContext2** ppDocContext);
};

// ------------------------------------------------------------------
// IDebugExpressionContext2
[
	object,
	uuid(37a44580-d5fc-473e-a048-21702ebfc466),
	pointer_default(unique)
]
interface IDebugExpressionContext2: IUnknown
{
	enum
	{
		// the expression is an expression (not a statement)
		PARSE_EXPRESSION		= 0x0001,
		// the expression might contain function name/parameter signatures, and
		// the expression is to be parsed [and later evaluated] as an address
		PARSE_FUNCTION_AS_ADDRESS = 0x0002
	};
	typedef DWORD PARSEFLAGS;

	// Get the name of the expression context. The name is the description
	// of this expression context. It is usually something that can be parsed
	// by an expression evaluator that refers to this exact expression context.
	// For C++, the name is "{ function-name, source-file-name, module-file-name }"
	HRESULT GetName(
		[out] BSTR* pbstrName);

	HRESULT ParseText(
		[in] LPCOLESTR pszCode,
		[in] PARSEFLAGS dwFlags,
		[in] UINT nRadix,
		[out] IDebugExpression2** ppExpr,
		[out] BSTR* pbstrError,
		[out] UINT* pichError);
};

// ------------------------------------------------------------------
// Breakpoint types

enum
{
	BPT_NONE				= 0x0000,
	BPT_CODE				= 0x0001,
	BPT_DATA				= 0x0002,
	BPT_SPECIAL				= 0x0003,
};
typedef DWORD BP_TYPE;

// ------------------------------------------------------------------
// Breakpoint request stuff

enum
{
	BPLT_NONE				= 0x00000000,
	BPLT_FILE_LINE			= 0x00010000,
	BPLT_FUNC_OFFSET		= 0x00020000,
	BPLT_CONTEXT			= 0x00030000,
	BPLT_STRING				= 0x00040000,
	BPLT_ADDRESS			= 0x00050000,
	BPLT_RESOLUTION			= 0x00060000,

	BPLT_CODE_FILE_LINE		= BPT_CODE | BPLT_FILE_LINE,
	BPLT_CODE_FUNC_OFFSET	= BPT_CODE | BPLT_FUNC_OFFSET,
	BPLT_CODE_CONTEXT		= BPT_CODE | BPLT_CONTEXT,
	BPLT_CODE_STRING		= BPT_CODE | BPLT_STRING,
	BPLT_CODE_ADDRESS		= BPT_CODE | BPLT_ADDRESS,
	BPLT_DATA_STRING		= BPT_DATA | BPLT_STRING,

	BPLT_TYPE_MASK			= 0x0000FFFF,
	BPLT_LOCATION_TYPE_MASK	= 0xFFFF0000
};
typedef DWORD BP_LOCATION_TYPE;

typedef struct _BP_LOCATION_CODE_FILE_LINE
{
	BSTR bstrContext;
	IDebugDocumentPosition2* pDocPos;
} BP_LOCATION_CODE_FILE_LINE;

typedef struct _BP_LOCATION_CODE_FUNC_OFFSET
{
	BSTR bstrContext;
	IDebugFunctionPosition2* pFuncPos;
} BP_LOCATION_CODE_FUNC_OFFSET;

typedef struct _BP_LOCATION_CODE_CONTEXT
{
	IDebugCodeContext2*	pCodeContext;
} BP_LOCATION_CODE_CONTEXT;

typedef struct _BP_LOCATION_CODE_STRING
{
	BSTR bstrContext;
	BSTR bstrCodeExpr;
} BP_LOCATION_CODE_STRING;

typedef struct _BP_LOCATION_CODE_ADDRESS
{
	BSTR bstrContext;
	BSTR bstrModuleUrl;
	BSTR bstrFunction;
	BSTR bstrAddress;
} BP_LOCATION_CODE_ADDRESS;

typedef struct _BP_LOCATION_DATA_STRING
{
	IDebugThread2* pThread;
	BSTR bstrContext;
	BSTR bstrDataExpr;
	DWORD dwNumElements;
} BP_LOCATION_DATA_STRING;

typedef struct _BP_LOCATION_RESOLUTION
{
	IDebugBreakpointResolution2 *pResolution;
} BP_LOCATION_RESOLUTION;

typedef union _BP_LOCATION switch (BP_LOCATION_TYPE bpLocationType) bpLocation
{
	case BPLT_CODE_FILE_LINE:
		BP_LOCATION_CODE_FILE_LINE bplocCodeFileLine;

	case BPLT_CODE_FUNC_OFFSET:
		BP_LOCATION_CODE_FUNC_OFFSET bplocCodeFuncOffset;

	case BPLT_CODE_CONTEXT:
		BP_LOCATION_CODE_CONTEXT bplocCodeContext;

	case BPLT_CODE_STRING:
		BP_LOCATION_CODE_STRING bplocCodeString;

	case BPLT_CODE_ADDRESS:
		BP_LOCATION_CODE_ADDRESS bplocCodeAddress;

	case BPLT_DATA_STRING:
		BP_LOCATION_DATA_STRING bplocDataString;

	case BPLT_RESOLUTION:
		BP_LOCATION_RESOLUTION bplocResolution;

	default:
		DWORD unused;
} BP_LOCATION;

enum
{
	BP_PASSCOUNT_NONE				= 0x0000,
	BP_PASSCOUNT_EQUAL				= 0x0001,
	BP_PASSCOUNT_EQUAL_OR_GREATER	= 0x0002,
	BP_PASSCOUNT_MOD				= 0x0003,
};
typedef DWORD BP_PASSCOUNT_STYLE;

typedef struct _BP_PASSCOUNT
{
	DWORD dwPassCount;
	BP_PASSCOUNT_STYLE stylePassCount;
} BP_PASSCOUNT;

enum
{
	BP_COND_NONE					= 0x0000,
	BP_COND_WHEN_TRUE				= 0x0001,
	BP_COND_WHEN_CHANGED			= 0x0002,
};
typedef DWORD BP_COND_STYLE;

typedef struct _BP_CONDITION
{
	IDebugThread2* pThread;
	BP_COND_STYLE styleCondition;
	BSTR bstrContext;
	BSTR bstrCondition;
	UINT nRadix;
} BP_CONDITION;

enum
{
	BP_FLAG_NONE					= 0x0000,
	BP_FLAG_MAP_DOCPOSITION			= 0x0001,
};
typedef DWORD BP_FLAGS;

enum
{
	BPREQI_BPLOCATION				= 0x0001,
	BPREQI_LANGUAGE					= 0x0002,
	BPREQI_PROGRAM					= 0x0004,
	BPREQI_PROGRAMNAME				= 0x0008,
	BPREQI_THREAD					= 0x0010,
	BPREQI_THREADNAME				= 0x0020,
	BPREQI_PASSCOUNT				= 0x0040,
	BPREQI_CONDITION				= 0x0080,
	BPREQI_FLAGS					= 0x0100,

	BPREQI_ALLFIELDS				= 0xffffffff,
};
typedef DWORD BPREQI_FIELDS;

typedef struct _BP_REQUEST_INFO
{
	BPREQI_FIELDS dwFields;
	GUID guidLanguage;
	BP_LOCATION bpLocation;
	IDebugProgram2* pProgram;
	BSTR bstrProgramName;
	IDebugThread2* pThread;
	BSTR bstrThreadName;
	BP_CONDITION bpCondition;
	BP_PASSCOUNT bpPassCount;
	BP_FLAGS dwFlags;
} BP_REQUEST_INFO;

// ------------------------------------------------------------------
// IDebugBreakpointRequest2

[
	object,
	uuid(6015fd18-8257-4df3-ac42-f074dedd4cbd),
	pointer_default(unique)
]
interface IDebugBreakpointRequest2 : IUnknown
{
	HRESULT GetLocationType(
		[out] BP_LOCATION_TYPE* pBPLocationType);

	HRESULT GetRequestInfo(
		[in] BPREQI_FIELDS dwFields,
		[out] BP_REQUEST_INFO* pBPRequestInfo);
};

// ------------------------------------------------------------------
// Breakpoint resolution stuff

typedef struct _BP_RESOLUTION_CODE
{
	IDebugCodeContext2*	pCodeContext;
} BP_RESOLUTION_CODE;

enum
{
	// The data breakpoint is being emulated
	// (rather than done via hardware)
	BP_RES_DATA_EMULATED		= 0x0001,
};
typedef DWORD BP_RES_DATA_FLAGS;

typedef struct _BP_RESOLUTION_DATA
{
	BSTR bstrDataExpr;
	BSTR bstrFunc;
	BSTR bstrImage;
	BP_RES_DATA_FLAGS dwFlags;
} BP_RESOLUTION_DATA;
	
typedef union _BP_RESOLUTION_LOCATION switch (BP_TYPE bpType) bpResLocation
{
	case BPT_CODE:
		BP_RESOLUTION_CODE bpresCode;

	case BPT_DATA:
		BP_RESOLUTION_DATA bpresData;

	default:
		int	unused;
} BP_RESOLUTION_LOCATION;

enum
{
	BPRESI_BPRESLOCATION	= 0x0001,
	BPRESI_PROGRAM			= 0x0002,
	BPRESI_THREAD			= 0x0004,

	BPRESI_ALLFIELDS		= 0xffffffff,
};
typedef DWORD BPRESI_FIELDS;

typedef struct _BP_RESOLUTION_INFO
{
	BPRESI_FIELDS dwFields;
	BP_RESOLUTION_LOCATION bpResLocation;
	IDebugProgram2* pProgram;
	IDebugThread2* pThread;
} BP_RESOLUTION_INFO;

// ------------------------------------------------------------------
// IDebugBreakpointResolution2

[
	object,
	uuid(b7e66f28-035a-401a-afc7-2e300bd29711),
	pointer_default(unique)
]
interface IDebugBreakpointResolution2 : IUnknown
{
	HRESULT GetBreakpointType(
		[out] BP_TYPE* pBPType);
		
	HRESULT GetResolutionInfo(
		[in] BPRESI_FIELDS dwFields,
		[out] BP_RESOLUTION_INFO* pBPResolutionInfo);
};

// ------------------------------------------------------------------
// Error breakpoint stuff

enum
{
    BPET_NONE               = 0x00000000,

    BPET_TYPE_WARNING       = 0x00000001,
    BPET_TYPE_ERROR         = 0x00000002,

    BPET_SEV_HIGH           = 0x0F000000,
    BPET_SEV_GENERAL        = 0x07000000,
    BPET_SEV_LOW            = 0x01000000,

    BPET_TYPE_MASK          = 0x0000ffff,
    BPET_SEV_MASK           = 0xffff0000,

    // Use these contants for describing general warnings and errors
    BPET_GENERAL_WARNING    = BPET_SEV_GENERAL | BPET_TYPE_WARNING,
    BPET_GENERAL_ERROR      = BPET_SEV_GENERAL | BPET_TYPE_ERROR,

    BPET_ALL				= 0xffffffff,
};
typedef DWORD BP_ERROR_TYPE;

enum
{
    BPERESI_BPRESLOCATION   = 0x0001,
    BPERESI_PROGRAM         = 0x0002,
    BPERESI_THREAD          = 0x0004,
    BPERESI_MESSAGE         = 0x0008,
    BPERESI_TYPE            = 0x0010,

    BPERESI_ALLFIELDS       = 0xffffffff,
};
typedef DWORD BPERESI_FIELDS;

typedef struct _BP_ERROR_RESOLUTION_INFO
{
	BPERESI_FIELDS dwFields;
	BP_RESOLUTION_LOCATION bpResLocation;
	IDebugProgram2* pProgram;
	IDebugThread2* pThread;
	BSTR bstrMessage;
	BP_ERROR_TYPE dwType;
} BP_ERROR_RESOLUTION_INFO;

// ------------------------------------------------------------------
// IDebugErrorBreakpointResolution2

[
	object,
	uuid(603aedf8-9575-4d30-b8ca-124d1c98ebd8),
	pointer_default(unique)
]
interface IDebugErrorBreakpointResolution2: IUnknown
{
	HRESULT GetBreakpointType(
		[out] BP_TYPE* pBPType);
		
	HRESULT GetResolutionInfo(
		[in] BPERESI_FIELDS dwFields,
		[out] BP_ERROR_RESOLUTION_INFO* pErrorResolutionInfo);
};

// ------------------------------------------------------------------
// IDebugBoundBreakpoint2

[
	object,
	uuid(d533d975-3f32-4876-abd0-6d37fda563e7),
	pointer_default(unique)
]
interface IDebugBoundBreakpoint2: IUnknown
{
	enum
	{
		BPS_NONE		= 0x0000,
		BPS_DELETED		= 0x0001,
		BPS_DISABLED	= 0x0002,
		BPS_ENABLED		= 0x0003,
	};
	typedef DWORD BP_STATE;

	HRESULT GetPendingBreakpoint(
		[out] IDebugPendingBreakpoint2** ppPendingBreakpoint);

	HRESULT GetState(
		[out] BP_STATE* pState);

	HRESULT GetHitCount(
		[out] DWORD* pdwHitCount);

	HRESULT GetBreakpointResolution(
		[out] IDebugBreakpointResolution2** ppBPResolution);

	HRESULT Enable(
		[in] BOOL fEnable);

	HRESULT SetHitCount(
		[in] DWORD dwHitCount);

	HRESULT SetCondition(
		[in] BP_CONDITION bpCondition);

	HRESULT SetPassCount(
		[in] BP_PASSCOUNT bpPassCount);

	HRESULT Delete(void);
};

// ------------------------------------------------------------------
// IDebugPendingBreakpoint2

[
	object,
	uuid(6e215ef3-e44c-44d1-b7ba-b2401f7dc23d),
	pointer_default(unique)
]
interface IDebugPendingBreakpoint2: IUnknown
{
	enum
	{
		PBPS_NONE			= 0x0000,
		PBPS_DELETED		= 0x0001,
		PBPS_DISABLED		= 0x0002,
		PBPS_ENABLED		= 0x0003,
	};
	typedef DWORD PENDING_BP_STATE;
	enum
	{
		PBPSF_NONE			= 0x0000,
		PBPSF_VIRTUALIZED	= 0x0001,
	};
	typedef DWORD PENDING_BP_STATE_FLAGS;

	typedef struct _tagPENDING_BP_STATE_INFO
	{
		PENDING_BP_STATE state;
		PENDING_BP_STATE_FLAGS flags;
	} PENDING_BP_STATE_INFO;

	HRESULT CanBind(
		[out] IEnumDebugErrorBreakpoints2** ppErrorEnum);

	HRESULT Bind(void);

	HRESULT GetState(
		[out] PENDING_BP_STATE_INFO* pState);

	HRESULT GetBreakpointRequest(
		[out] IDebugBreakpointRequest2** ppBPRequest);

	HRESULT Virtualize(
		[in] BOOL fVirtualize);

	HRESULT Enable(
		[in] BOOL fEnable);

	HRESULT SetCondition(
		[in] BP_CONDITION bpCondition);

	HRESULT SetPassCount(
		[in] BP_PASSCOUNT bpPassCount);

	HRESULT EnumBoundBreakpoints(
		[out] IEnumDebugBoundBreakpoints2** ppEnum);

	HRESULT EnumErrorBreakpoints(
		[in] BP_ERROR_TYPE bpErrorType,
		[out] IEnumDebugErrorBreakpoints2** ppEnum);

	HRESULT Delete(void);
};

// ------------------------------------------------------------------
// IDebugErrorBreakpoint2

[
	object,
	uuid(74570ef7-2486-4089-800c-56e3829b5ca4),
	pointer_default(unique)
]
interface IDebugErrorBreakpoint2: IUnknown
{
	HRESULT GetPendingBreakpoint(
		[out] IDebugPendingBreakpoint2** ppPendingBreakpoint);

	HRESULT GetBreakpointResolution(
		[out] IDebugErrorBreakpointResolution2** ppErrorResolution);
};

// ------------------------------------------------------------------
// IDebugExpression2
[
	object,
	uuid(f7473fd0-7f75-478d-8d85-a485204e7a2d),
	pointer_default(unique)
]
interface IDebugExpression2: IUnknown
{
	enum
	{
		// the return value is interesting
		EVAL_RETURNVALUE			= 0x0002,
		// don't allow side effects
		EVAL_NOSIDEEFFECTS			= 0x0004,
		// stop on breakpoints
		EVAL_ALLOWBPS				= 0x0008,
		// allow error reporting to the host
		EVAL_ALLOWERRORREPORT		= 0x0010,
		// evaluate any functions as address (instead of invoking the function)
		EVAL_FUNCTION_AS_ADDRESS	= 0x0040,
		// don't allow function/property evaluation
		EVAL_NOFUNCEVAL				= 0x0080,
		// don't allow events
		EVAL_NOEVENTS				= 0x1000,
	};
	typedef DWORD EVALFLAGS;

	HRESULT EvaluateAsync(
		[in] EVALFLAGS dwFlags,
		[in] IDebugEventCallback2* pExprCallback);

	HRESULT Abort(void);

	HRESULT EvaluateSync(
		[in] EVALFLAGS dwFlags,
		[in] DWORD dwTimeout,
		[in] IDebugEventCallback2* pExprCallback,
		[out] IDebugProperty2** ppResult);
};

// ------------------------------------------------------------------
// IDebugModule2
[
	object,
	uuid(0fc1cd9a-b912-405c-a04c-43ce02cd7df2),
	pointer_default(unique)
]
interface IDebugModule2: IUnknown
{
	enum
	{
		MODULE_FLAG_NONE		= 0x0000,
		MODULE_FLAG_SYSTEM		= 0x0001,
		MODULE_FLAG_SYMBOLS		= 0x0002,
		MODULE_FLAG_64BIT		= 0x0004,
	};
	typedef DWORD MODULE_FLAGS;

	enum
	{
		MIF_NONE				= 0x0000,
		MIF_NAME				= 0x0001,
		MIF_URL					= 0x0002,
		MIF_VERSION				= 0x0004,
		MIF_DEBUGMESSAGE		= 0x0008,
		MIF_LOADADDRESS			= 0x0010,
		MIF_PREFFEREDADDRESS	= 0x0020,
		MIF_SIZE				= 0x0040,
		MIF_LOADORDER			= 0x0080,
		MIF_TIMESTAMP			= 0x0100,
		MIF_URLSYMBOLLOCATION	= 0x0200,
		MIF_FLAGS				= 0x0400,

		MIF_ALLFIELDS			= 0x07ff,
	};
	typedef DWORD MODULE_INFO_FIELDS;

	typedef struct _tagMODULE_INFO
	{
		MODULE_INFO_FIELDS dwValidFields;
		BSTR m_bstrName;
		BSTR m_bstrUrl;
		BSTR m_bstrVersion;
		BSTR m_bstrDebugMessage;
		UINT64 m_addrLoadAddress;
		UINT64 m_addrPreferredLoadAddress;
		DWORD m_dwSize;
		DWORD m_dwLoadOrder;
		FILETIME m_TimeStamp;
		BSTR m_bstrUrlSymbolLocation;
		MODULE_FLAGS m_dwModuleFlags;
	} MODULE_INFO;

	HRESULT GetInfo(
		[in] MODULE_INFO_FIELDS dwFields,
		[out] MODULE_INFO* pInfo);
	
	HRESULT ReloadSymbols(
		[in, ptr] LPCOLESTR pszUrlToSymbols,
		[out] BSTR* pbstrDebugMessage);
};

// ------------------------------------------------------------------
// IDebugModuleManaged
[
	object,
	uuid(232397F8-B232-479d-B1BB-2F044C70A0F9),
	pointer_default(unique)
]
interface IDebugModuleManaged: IUnknown
{
	HRESULT GetMvid(
		[out] GUID* mvid);
};

// ------------------------------------------------------------------
// IDebugDocument2
[
	object,
	uuid(1606dd73-5d5f-405c-b4f4-ce32baba2501),
	pointer_default(unique)
]
interface IDebugDocument2: IUnknown
{
	HRESULT GetName(
		[in] GETNAME_TYPE gnType,
		[out] BSTR* pbstrFileName);

	HRESULT GetDocumentClassId(
		[out] CLSID* pclsid);
};

// ------------------------------------------------------------------
// IDebugDocumentText2
[
	object,
	uuid(4b0645aa-08ef-4cb9-adb9-0395d6edad35),
	pointer_default(unique)
]
interface IDebugDocumentText2: IDebugDocument2
{
	HRESULT GetSize(
		[in, out, ptr] ULONG* pcNumLines,
		[in, out, ptr] ULONG* pcNumChars);

	HRESULT GetText(
		[in] TEXT_POSITION pos,
		[in] ULONG cMaxChars,
		[out, length_is(*pcNumChars), size_is(cMaxChars)] WCHAR* pText,
		[out] ULONG* pcNumChars);
};

// ------------------------------------------------------------------
// IDebugDocumentPosition2
[
	object,
	uuid(bdde0eee-3b8d-4c82-b529-33f16b42832e),
	pointer_default(unique)
]
interface IDebugDocumentPosition2: IUnknown
{
	HRESULT GetFileName(
		[out] BSTR* pbstrFileName);

	HRESULT GetDocument(
		[out] IDebugDocument2** ppDoc);

	HRESULT IsPositionInDocument(
		[in] IDebugDocument2* pDoc);

	HRESULT GetRange(
		[in, out, ptr] TEXT_POSITION* pBegPosition,
		[in, out, ptr] TEXT_POSITION* pEndPosition);
};

// ------------------------------------------------------------------
// IDebugDocumentPositionOffset2
[
	object,
	uuid(037edd0f-8551-4f7f-8ca0-04d9e29f532d),
	pointer_default(unique)
]
interface IDebugDocumentPositionOffset2: IUnknown
{
	HRESULT GetRange(
		[in, out, ptr] DWORD* pdwBegOffset,
		[in, out, ptr] DWORD* pdwEndOffset);
};

// ------------------------------------------------------------------
// IDebugFunctionPosition2

[
	object,
	uuid(1ede3b4b-35e7-4b97-8133-02845d600174),
	pointer_default(unique)
]
interface IDebugFunctionPosition2: IUnknown
{
	HRESULT GetFunctionName(
		[out] BSTR* pbstrFunctionName);

	HRESULT GetOffset(
		[in, out, ptr] TEXT_POSITION* pPosition);
};

// ------------------------------------------------------------------
// IDebugDocumentTextEvents2
[
	object,
	uuid(33ec72e3-002f-4966-b91c-5ce2f7ba5124),
	pointer_default(unique)
]
interface IDebugDocumentTextEvents2: IUnknown
{
	// TEXT_DOC_ATTR
	//
	// Describes the attributes of the document
	typedef DWORD TEXT_DOC_ATTR_2;
	// Indicates that the document is read-only.
	const TEXT_DOC_ATTR_2 TEXT_DOC_ATTR_READONLY_2 = 0x00000001;

	HRESULT onDestroy(void);

	HRESULT onInsertText(
		[in] TEXT_POSITION pos,
		[in] DWORD dwNumToInsert);

	HRESULT onRemoveText(
		[in] TEXT_POSITION pos,
		[in] DWORD dwNumToRemove);

	HRESULT onReplaceText(
		[in] TEXT_POSITION pos,
		[in] DWORD dwNumToReplace);

	HRESULT onUpdateTextAttributes(
		[in] TEXT_POSITION pos,
		[in] DWORD dwNumToUpdate);

	HRESULT onUpdateDocumentAttributes(
		[in] TEXT_DOC_ATTR_2 textdocattr);
};

// ------------------------------------------------------------------
// IDebugQueryEngine2

[
	object,
	uuid(c989adc9-f305-4ef5-8ca2-20898e8d0e28),
	pointer_default(unique)
]
interface IDebugQueryEngine2: IUnknown
{
	HRESULT GetEngineInterface(
		[out] IUnknown** ppUnk);
};

// ------------------------------------------------------------------
// IEnumDebugProcesses2
[
	object,
	uuid(96c74ef4-185d-4f9a-8a43-4d2723758e0a),
	pointer_default(unique)
]
interface IEnumDebugProcesses2: IUnknown
{
	HRESULT Next(
		[in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] IDebugProcess2** rgelt,
		[in, out] ULONG* pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugProcesses2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugPrograms2
[
	object,
	uuid(8d14bca6-34ce-4efe-ac7e-0abc61dadb20),
	pointer_default(unique)
]
interface IEnumDebugPrograms2: IUnknown
{
	HRESULT Next(
		[in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] IDebugProgram2** rgelt,
		[in, out] ULONG* pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugPrograms2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugThreads2
[
	object,
	uuid(0d30dc12-c4f8-433d-9fcc-9ff117e5e5f4),
	pointer_default(unique)
]
interface IEnumDebugThreads2: IUnknown
{
	HRESULT Next(
		[in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] IDebugThread2** rgelt,
		[in, out] ULONG* pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugThreads2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugStackFrames2
[
	object,
	uuid(cd39102b-4b69-4495-8f29-e0b25c4a8855),
	pointer_default(unique)
]
interface IEnumDebugStackFrames2: IUnknown
{
	HRESULT Next(
		[in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] IDebugStackFrame2** rgelt,
		[in, out] ULONG* pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugStackFrames2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);

	HRESULT GetIndex(
		[in] IDebugStackFrame2* pStackFrame,
		[in, out] ULONG* pIndex);
};

// ------------------------------------------------------------------
// IEnumDebugCodeContexts2
[
	object,
	uuid(ad47a80b-eda7-459e-af82-647cc9fbaa50),
	pointer_default(unique)
]
interface IEnumDebugCodeContexts2: IUnknown
{
	HRESULT Next(
		[in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] IDebugCodeContext2** rgelt,
		[in, out] ULONG* pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugCodeContexts2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugBoundBreakpoints2

[
	object,
	uuid(0f6b37e0-fcfe-44d9-9112-394ca9b92114),
	pointer_default(unique)
]
interface IEnumDebugBoundBreakpoints2: IUnknown
{
	HRESULT Next(
		[in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] IDebugBoundBreakpoint2** rgelt,
		[in, out] ULONG* pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugBoundBreakpoints2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugPendingBreakpoints2

[
	object,
	uuid(70d2dc1e-4dcc-4786-a072-9a3b600c216b),
	pointer_default(unique)
]
interface IEnumDebugPendingBreakpoints2: IUnknown
{
	HRESULT Next(
		[in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] IDebugPendingBreakpoint2** rgelt,
		[in, out] ULONG* pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugPendingBreakpoints2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugErrorBreakpoints2

[
	object,
	uuid(e158f5aa-31fe-491b-a9f6-cff934b03a01),
	pointer_default(unique)
]
interface IEnumDebugErrorBreakpoints2: IUnknown
{
	HRESULT Next(
		[in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] IDebugErrorBreakpoint2** rgelt,
		[in, out] ULONG* pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugErrorBreakpoints2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugMachines2
[
	object,
	uuid(61d986ec-1eac-46b6-90ff-402a008f15d1),
	pointer_default(unique)
]
interface IEnumDebugMachines2 : IUnknown
{
	HRESULT Next(
		[in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] IDebugMachine2** rgelt,
		[in, out] ULONG *pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugMachines2 **ppEnum);

	HRESULT GetCount(
		[out] ULONG *pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugExceptionInfo2
[
	object,
	uuid(8e4bbd34-a2f4-41ef-87b5-c563b4ad6ee7),
	pointer_default(unique)
]
interface IEnumDebugExceptionInfo2 : IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] EXCEPTION_INFO* rgelt,
		[in, out] ULONG *pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugExceptionInfo2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugFrameInfo2
[
	object,
	uuid(98bbba48-4c4d-4fff-8340-6097bec9c894),
	pointer_default(unique)
]
interface IEnumDebugFrameInfo2 : IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] FRAMEINFO* rgelt,
		[in, out] ULONG *pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugFrameInfo2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumCodePaths2
[
	object,
	uuid(9b13f80d-cfc6-4b78-81ef-1f7cc33f7639),
	pointer_default(unique)
]
interface IEnumCodePaths2: IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] CODE_PATH* rgelt,
		[in, out] ULONG *pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumCodePaths2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugModules2
[
	object,
	uuid(4c4a2835-682e-4ce1-aebc-1e6b3a165b44),
	pointer_default(unique)
]
interface IEnumDebugModules2: IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] IDebugModule2** rgelt,
		[in, out] ULONG* pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugModules2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugPortSuppliers2
[
	object,
	uuid(59c9dc99-3eff-4ff3-b201-98acd01b0d87),
	pointer_default(unique)
]
interface IEnumDebugPortSuppliers2 : IUnknown
{
	HRESULT Next(
		[in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] IDebugPortSupplier2** rgelt,
		[in, out] ULONG* pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugPortSuppliers2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugPorts2
[
	object,
	uuid(bc827c5e-99ae-4ac8-83ad-2ea5c2034333),
	pointer_default(unique)
]
interface IEnumDebugPorts2 : IUnknown
{
	HRESULT Next(
		[in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] IDebugPort2** rgelt,
		[in, out] ULONG* pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugPorts2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugPropertyInfo2
[
	object,
	uuid(6c7072c3-3ac4-408f-a680-fc5a2f96903e),
	pointer_default(unique)
]
interface IEnumDebugPropertyInfo2: IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] DEBUG_PROPERTY_INFO* rgelt,
		[out] ULONG* pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugPropertyInfo2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugReferenceInfo2
[
	object,
	uuid(e459dd12-864f-4aaa-abc1-dcecbc267f04),
	pointer_default(unique)
]
interface IEnumDebugReferenceInfo2: IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
		[out, size_is(celt), length_is(*pceltFetched)] DEBUG_REFERENCE_INFO* rgelt,
		[out] ULONG* pceltFetched);

	HRESULT Skip(
		[in] ULONG celt);

	HRESULT Reset(void);

	HRESULT Clone(
		[out] IEnumDebugReferenceInfo2** ppEnum);

	HRESULT GetCount(
		[out] ULONG* pcelt);
};

// ------------------------------------------------------------------

[
	uuid(d191c0d7-4c8b-4a15-a7b3-862dcd8daefb)
]
library AD2Lib
{
	importlib("stdole2.tlb");

	[ uuid(5eb7d9f7-af21-400e-a2c4-7fd6396f8641) ]
	coclass SDMServer
	{
		[default] interface IDebugSession2;
	};

	[
#ifdef DEBUG
		uuid(05e1b201-493d-4678-bbcb-18d9caf5c0a9)
#else
		uuid(73b25ffd-f501-437b-8b11-7f0de383964f)
#endif
	]
	coclass MsMachineDebugManager
	{
		[default] interface IDebugMachine2;
	};

	[
#ifdef DEBUG
        uuid(89370a13-3977-4e7d-aea0-0a9751ae596b)
#else
        uuid(b20e899d-b079-479d-a4dc-10f758d9cd9a)
#endif
    ]
	coclass MDMUtilServer
	{
		[default] interface IDebugMDMUtil2;
	};
};
