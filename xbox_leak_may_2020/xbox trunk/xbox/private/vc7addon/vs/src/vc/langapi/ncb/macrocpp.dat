#if CC_COR
coclass                 class
implements              : public
cointerface             struct
#endif	// CC_COR
// CRT/Win32 Headers
__RPC_API               __stdcall
__RPC_CALLEE            __stdcall
__RPC_FAR
__RPC_STUB              __stdcall
__RPC_USER              __stdcall
_COM_SMARTPTR_TYPEDEF(Interface, IID) typedef _com_ptr_t< _com_IIID< Interface, &IID> > Interface##Ptr
_CRTAPI1                __cdecl
_CRTIMP
_STD                    std::
_STD_BEGIN              namespace std {
_STD_END                };
_STD_USING
APIPRIVATE              __stdcall
CALLBACK
cdecl                   __cdecl
CDECL                   __cdecl
D3DRMAPI                __stdcall
DECLARE_HANDLE(name)    struct name##__ { int unused; }; typedef struct name##__ *name
DECLARE_HANDLE32(x)     struct name##__ { int unused; };typedef const struct name##__ FAR* name
DECLARE_MAPI_INTERFACE(iface) typedef struct ifaceVtbl ifaceVtbl, FAR * iface; struct ifaceVtbl
DECLARE_MAPI_INTERFACE_PTR(iface, piface) typedef struct ifaceVtbl ifaceVtbl, FAR * iface, FAR * FAR * piface;
DECLSPEC_UUID(x)        __declspec(uuid(x))
DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) EXTERN_C const GUID FAR name
DEFINE_GUIDNAMED(n) __uuidof(struct n)
DEFINE_GUIDSTRUCT(g, n) struct __declspec(uuid(g)) n
DEFINE_OLEGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)
EXPORT
EXTERN_C				extern "C"
FAR
far
FASTCALL                __fastcall
IMAGEAPI                __stdcall
INSTAPI                 __stdcall
//interface               struct
MIDL_INTERFACE(x)       struct __declspec(uuid(x)) __declspec(novtable)
NEAR
NET_API_FUNCTION        __stdcall
NTAPI                   __stdcall
pascal                  __stdcall
PASCAL                  __stdcall
RPC_ENTRY               __stdcall
RPC_VAR_ENTRY           __cdecl
SIZE_T_MAX              UINT_MAX
SQL_API                 __stdcall
SRVAPI
STDAPI                  HRESULT STDAPICALLTYPE
STDAPI_(type)           type STDAPICALLTYPE
STDAPICALLTYPE          __stdcall
STDAPIV                 HRESULT STDAPIVCALLTYPE
STDAPIV_(type)          type STDAPIVCALLTYPE
STDAPIVCALLTYPE         __cdecl
STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
STDMETHODCALLTYPE       __stdcall
STDMETHODIMP            HRESULT STDMETHODCALLTYPE
STDMETHODIMP_(type)     type STDMETHODCALLTYPE
STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE
STDMETHODVCALLTYPE      __cdecl
STDMAPIINITCALLTYPE     __cdecl
THROW0()		throw()
UNALIGNED
VFWAPIV
WDBGAPI                 __stdcall
WINAPI                  __stdcall
WINAPIV                 __cdecl
WINOLEAPI               HRESULT STDAPICALLTYPE
WINOLEAPI_(type)        type STDAPICALLTYPE
// ATL/MFC headers
// next line removed to try get better MFC stores
//afx_msg
ATL_NO_VTABLE           __declspec(novtable)
ATLAPI                  HRESULT
ATLAPI_(x)              x
AFX_CDECL               __cdecl
AFX_CLASS_EXPORT        __declspec(dllexport)
AFX_CLASS_IMPORT        __declspec(dllimport)
AFX_MSG_CALL            __thiscall
AFX_NOVTABLE
AFXAPI                  __stdcall
AFXISAPI                __stdcall
AFXISAPI_CDECL          __cdecl
AFXOLEAPI               __stdcall
BASED_CODE
BASED_DEBUG
BASED_STACK
BEGIN_DUAL_INTERFACE_PART(localClass, baseClass) class X##localClass : public baseClass { public: BEGIN_COM_MAP(X##localClass, localClass) COM_INTERFACE_ENTRY (baseClass) END_COM_MAP()
BEGIN_INTERFACE_PART(localClass, baseClass) class X##localClass : public baseClass 	{ public: BEGIN_COM_MAP(X##localClass, localClass) COM_INTERFACE_ENTRY (baseClass) END_COM_MAP() public: virtual ULONG STDMETHODCALLTYPE AddRef(); virtual ULONG STDMETHODCALLTYPE Release(); virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void * * ppvObj);
BEGIN_CONNECTION_PART(theClass, localClass) class X##localClass : public CConnectionPoint { public: X##localClass();
BEGIN_OLEFACTORY(class_name) protected: class class_name##Factory : public COleObjectFactoryEx {public:class_name##Factory(REFCLSID clsid, CRuntimeClass* pRuntimeClass,BOOL bMultiInstance, LPCTSTR lpszProgID);virtual BOOL UpdateRegistry(BOOL);
CONNECTION_IID(iid)     REFIID GetIID();
_DECLARE_DYNAMIC(class_name) public:static CRuntimeClass class##class_name; static CRuntimeClass* PASCAL GetThisClass();virtual CRuntimeClass* GetRuntimeClass() const; _DECLARE_DYNCREATE(class_name) _DECLARE_DYNAMIC(class_name) static CObject* PASCAL CreateObject();
DECLARE_AGGREGATABLE(x) public: typedef CComCreator2< CComCreator< CComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;
DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectCached< cf > > _ClassFactoryCreatorClass;
DECLARE_CLASSFACTORY() DECLARE_CLASSFACTORY_EX(CComClassFactory)
DECLARE_CLASSFACTORY2(lic) DECLARE_CLASSFACTORY_EX(CComClassFactory2<lic>)
DECLARE_CLASSFACTORY_AUTO_THREAD() DECLARE_CLASSFACTORY_EX(CComClassFactoryAutoThread)
DECLARE_CLASSFACTORY_SINGLETON(obj)  DECLARE_CLASSFACTORY_EX(CComClassFactorySingleton<obj>)
DECLARE_CONNECTION_MAP() private:static const AFX_CONNECTIONMAP_ENTRY _connectionEntries[];protected:static const AFX_CONNECTIONMAP connectionMap;static const AFX_CONNECTIONMAP* PASCAL GetThisConnectionMap();virtual const AFX_CONNECTIONMAP* GetConnectionMap() const;
DECLARE_DISPATCH_MAP()  private:static const AFX_DISPMAP_ENTRY _dispatchEntries[];static UINT _dispatchEntryCount;static DWORD _dwStockPropMask;protected:static const AFX_DISPMAP dispatchMap;static const AFX_DISPMAP* PASCAL GetThisDispatchMap();virtual const AFX_DISPMAP* GetDispatchMap() const;
DECLARE_DUAL_ERRORINFO()
DECLARE_DYNAMIC(class_name) public: static const CRuntimeClass class##class_name;static CRuntimeClass* PASCAL GetThisClass();virtual CRuntimeClass* GetRuntimeClass() const;
DECLARE_DYNCREATE(class_name) DECLARE_DYNAMIC(class_name) static CObject* PASCAL CreateObject();
DECLARE_EMPTY_MSG_MAP() public: BOOL ProcessWindowMessage(HWND, UINT, WPARAM, LPARAM, LRESULT&, DWORD);
DECLARE_EVENT_MAP()     private:static const AFX_EVENTMAP_ENTRY _eventEntries[];static DWORD _dwStockEventMask;protected:static const AFX_EVENTMAP eventMap;static const AFX_EVENTMAP* PASCAL GetThisEventMap();virtual const AFX_EVENTMAP* GetEventMap() const;
DECLARE_EVENTSINK_MAP() private:static const AFX_EVENTSINKMAP_ENTRY _eventsinkEntries[];static UINT _eventsinkEntryCount;protected:static const AFX_EVENTSINKMAP eventsinkMap;static const AFX_EVENTSINKMAP* PASCAL GetThisEventSinkMap();virtual const AFX_EVENTSINKMAP* GetEventSinkMap() const;
DECLARE_GET_CONTROLLING_UNKNOWN() public: virtual IUnknown* GetControllingUnknown();
DECLARE_INTERFACE(iface) interface iface
DECLARE_INTERFACE_(iface, baseiface) interface iface : public baseiface
DECLARE_INTERFACE_MAP() private:static const AFX_INTERFACEMAP_ENTRY _interfaceEntries[];protected:static const AFX_INTERFACEMAP interfaceMap;static const AFX_INTERFACEMAP* PASCAL GetThisInterfaceMap();virtual const AFX_INTERFACEMAP* GetInterfaceMap() const;
DECLARE_MESSAGE_MAP()   private:static const AFX_MSGMAP_ENTRY _messageEntries[];protected:static const AFX_MSGMAP messageMap;static const AFX_MSGMAP* PASCAL GetThisMessageMap();virtual const AFX_MSGMAP* GetMessageMap()const;
DECLARE_NO_REGISTRY()   static HRESULT WINAPI UpdateRegistry(BOOL);
DECLARE_NOT_AGGREGATABLE(x) typedef CComCreator2< CComCreator< CComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
DECLARE_OBJECT_DESCRIPTION(x) static LPCTSTR WINAPI GetObjectDescription();
DECLARE_OLECMD_MAP()    private:static const AFX_OLECMDMAP_ENTRY _commandEntries[];protected:static const AFX_OLECMDMAP commandMap;static const AFX_OLECMDMAP* PASCAL GetThisCommandMap();virtual const AFX_OLECMDMAP* GetCommandMap() const;
DECLARE_OLECREATE(class_name) public:static const UINT GetMenuID();
DECLARE_OLECREATE_EX(class_name) BEGIN_OLEFACTORY(class_name) END_OLEFACTORY(class_name)
DECLARE_OLECTLTYPE(class_name) virtual UINT GetUserTypeNameID(); virtual DWORD GetMiscStatus();
DECLARE_OLETYPELIB(class_name) 	protected: virtual UINT GetTypeInfoCount();virtual HRESULT GetTypeLib(LCID, LPTYPELIB*);virtual CTypeLibCache* GetTypeLibCache();
DECLARE_ONLY_AGGREGATABLE(x) 	typedef CComCreator2< CComFailCreator<E_FAIL>, CComCreator< CComAggObject< x > > > _CreatorClass;
DECLARE_OPAQUE32(x)     struct name##__ { int unused; }; typedef const struct name##__ FAR* name
DECLARE_PARSE_MAP()     private: static AFX_PARSEMAP_ENTRY _parseEntries[];public: static const AFX_PARSEMAP parseMap;static const AFX_PARSEMAP* PASCAL GetThisParseMap();static UINT PASCAL GetNumMapEntries();virtual const AFX_PARSEMAP* GetParseMap() const;
DECLARE_POLY_AGGREGATABLE(x) typedef CComCreator< CComPolyObject< x > > _CreatorClass;
DECLARE_PROPERTY_SUPPORT(class)
DECLARE_PROPPAGEIDS(class_name) protected: virtual LPCLSID GetPropPageIDs(ULONG& cPropPages);
DECLARE_PROTECT_FINAL_CONSTRUCT() void InternalFinalConstructAddRef();void InternalFinalConstructRelease();
DECLARE_REGISTRY(class, pid, vpid, nid, flags) 	static HRESULT WINAPI UpdateRegistry(BOOL bRegister);
DECLARE_REGISTRY_RESOURCE(x) 	static HRESULT WINAPI UpdateRegistry(BOOL bRegister);
DECLARE_REGISTRY_RESOURCEID(x) 	static HRESULT WINAPI UpdateRegistry(BOOL bRegister);
DECLARE_SERIAL(class_name) _DECLARE_DYNCREATE(class_name) AFX_API friend CArchive& AFXAPI operator>>(CArchive& ar, class_name* &pOb);
DECLARE_STATIC_REGISTRY_RESOURCE(x) DECLARE_REGISTRY_RESOURCE(x)
DECLARE_STATIC_REGISTRY_RESOURCEID(x) DECLARE_REGISTRY_RESOURCEID(x)
DECLARE_VIEW_STATUS(statusFlags) DWORD _GetViewStatus();
DECLARE_WND_CLASS(WndClassName) static CWndClassInfo& GetWndClassInfo();
DECLARE_WND_SUPERCLASS(WndClassName, OrigWndClassName) static CWndClassInfo& GetWndClassInfo();
DEFINE_COMMAND(x, szCommand) typedef x _CommandClass;static HRESULT GetDefaultCommand(LPCTSTR* ppszCommand)
DELEGATE_DUAL_INTERFACE(objectClass, dualClass)
END_CONNECTION_PART(localClass) } m_x##localClass; friend class X##localClass;
END_DUAL_INTERFACE_PART(localClass) } m_x##localClass; friend class X##localClass;
END_INTERFACE_PART(localClass) 	} m_x##localClass; friend class X##localClass;
END_OLEFACTORY(class_name) };friend class class_name##Factory;static class_name##Factory factory;public:static const GUID guid;virtual HRESULT GetClassID(LPCLSID pclsid);
EXTERN_PROCESS_LOCAL(class_name, ident_name) extern AFX_DATA PROCESS_LOCAL(class_name, ident_name)
EXT_SNAPINMENUID(id)    public:static const UINT GetMenuID();
IMPLEMENT_DUAL_ERRORINFO(objectClass, riidSource)
IMPLEMENT_DYNAMIC(class_name, base_class_name) IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, NULL, NULL)
IMPLEMENT_DYNCREATE(class_name, base_class_name) CObject* PASCAL class_name::CreateObject() { return new class_name; } IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, class_name::CreateObject, NULL)
IMPLEMENT_OLECREATE(class_name, external_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) AFX_COMDAT COleObjectFactory class_name::factory(class_name::guid, RUNTIME_CLASS(class_name), FALSE, _T(external_name)); AFX_COMDAT const GUID class_name::guid = { l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } };
IMPLEMENT_OLECREATE_EX(class_name, external_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) const TCHAR _szProgID_##class_name[] = _T(external_name);AFX_COMDAT class_name::class_name##Factory class_name::factory(class_name::guid, RUNTIME_CLASS(class_name), FALSE,_szProgID_##class_name);AFX_COMDAT const GUID class_name::guid = { l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } };HRESULT class_name::GetClassID(LPCLSID pclsid){ *pclsid = guid; return NOERROR; }
IMPLEMENT_OLECTLTYPE(class_name, idsUserTypeName, dwOleMisc) UINT class_name::GetUserTypeNameID() { return idsUserTypeName; } DWORD class_name::GetMiscStatus() { return dwOleMisc; }
IMPLEMENT_OLETYPELIB(class_name, tlid, wVerMajor, wVerMinor) UINT class_name::GetTypeInfoCount() { return 1; }HRESULT class_name::GetTypeLib(LCID lcid, LPTYPELIB* ppTypeLib){ return ::LoadRegTypeLib(tlid, wVerMajor, wVerMinor, lcid, ppTypeLib); }CTypeLibCache* class_name::GetTypeLibCache(){ AFX_MANAGE_STATE(m_pModuleState); return AfxGetTypeLibCache(&tlid); }
IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew, class_init) AFX_COMDAT const CRuntimeClass class_name::class##class_name = {#class_name, sizeof(class class_name), wSchema, pfnNew,&base_class_name::GetThisClass, NULL, class_init };CRuntimeClass* PASCAL class_name::GetThisClass(){ return _RUNTIME_CLASS(class_name); }CRuntimeClass* class_name::GetRuntimeClass() const{ return _RUNTIME_CLASS(class_name); }
IMPLEMENT_SERIAL(class_name, base_class_name, wSchema) CObject* PASCAL class_name::CreateObject(){ return new class_name; }AFX_COMDAT AFX_CLASSINIT _init_##class_name(RUNTIME_CLASS(class_name));_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, class_name::CreateObject, &_init_##class_name)CArchive& AFXAPI operator>>(CArchive& ar, class_name* &pOb){ pOb = (class_name*) ar.ReadObject(RUNTIME_CLASS(class_name));return ar; }
INIT_INTERFACE_PART(theClass, localClass)
PROCESS_LOCAL(class_name, ident_name) AFX_DATADEF CProcessLocal<class_name> ident_name;
PURE                    = 0
RUNTIME_CLASS(class_name) (class_name::GetThisClass())
_RUNTIME_CLASS(class_name) ((CRuntimeClass*)(&class_name::class##class_name))
SNAPINMENUID(id)	    public: static const UINT GetMenuID() { static const UINT IDMENU = id; return id; }
THIS                    void
THIS_
// MFC try/catch wrappers
TRY                     try {
CATCH(class_name, e)    } catch (class_name * e) {
AND_CATCH(class_name, e) } catch (class_name * e) {
END_CATCH               }
CATCH_ALL(e)            } catch (CException* e) {
AND_CATCH_ALL(e)        } catch (CException* e) {
END_CATCH_ALL           }
#if __FE_PARSER__
// Note: Make sure the __NCB__NAME_ parts are unique across ATL and MFC (NAME shouldn't contain a '_') and
//       the parameters are all added as base classes (so far all params can be base classes)
// Hack a rama for ATL
BEGIN_COLUMN_MAP(x)     class __NCB__COLUMN_##x : public COLUMN {
END_COLUMN_MAP()        };
BEGIN_CONTROL_MAP(x)    class __NCB__CONTROL_##x : public CONTROL {
END_CONTROL_MAP()       };
BEGIN_COM_MAP(x)        class __NCB__COM_##x : public COM {
END_COM_MAP()           };
BEGIN_CONNECTION_POINT_MAP(x) class __NCB__CONNECTIONPOINT_##x : public CONNECTION_POINT {
END_CONNECTION_POINT_MAP() };
BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(x) class __NCB__EXTENSIONSNAPINNODEINFO_##x : public EXTENSION_SNAPIN_NODEINFO {
END_EXTENSION_SNAPIN_NODEINFO_MAP() };
BEGIN_FILTER_MAP(x)     class __NCB__FILTER_##x : public FILTER {
END_FILTER_MAP()        };
BEGIN_MSG_MAP(x)        class __NCB__MSG_##x : public MSG {
END_MSG_MAP()           };
BEGIN_OBJECT_MAP(x)     class __NCB__OBJECT_##x : public OBJECT {
END_OBJECT_MAP()        };
BEGIN_PARAM_MAP(x)      class __NCB__PARAM_##x : public PARAM {
END_PARAM_MAP()         };
BEGIN_PROP_MAP(x)       class __NCB__PROP_##x : public PROP {
END_PROP_MAP()          };
BEGIN_PROPERTY_MAP(x)   class __NCB__PROPERTY_##x : public PROPERTY {
END_PROPERTY_MAP()      };
BEGIN_PROPPAGE_MAP(x)   class __NCB___PROPPAGE_##x : public PROPPAGE {
END_PROPPAGE_MAP()      };
BEGIN_SERVICE_MAP(x)    class __NCB__SERVICE_##x : public SERVICE {
END_SERVICE_MAP()       };
BEGIN_SINK_MAP(x)       class __NCB__SINK_##x : public SINK {
END_SINK_MAP()          };
BEGIN_SNAPINTOOLBARID_MAP(x) class __NCB__SNAPINTOOLBARID_##x : public SNAPINTOOLBARID {
END_SNAPINTOOLBARID_MAP() };
BEGIN_UPDATE_UI_MAP(x)  class __NCB__UPDATEUI_##x : public UPDATE_UI {
END_UPDATE_UI_MAP()     };
//The next few are problematic ... to be done ...
BEGIN_ACCESSOR_MAP(x, num) class __NCB__ACCESSOR_##x : public ACCESSOR {
END_ACCESSOR_MAP()      };
BEGIN_CATEGORY_MAP()    class __NCB__CATEGORY_ /* : public CATEGORY */ {
END_CATEGORY_MAP()      };
BEGIN_PROPSET_MAP(x)    class __NCB__PROPSET_##x : public PROPSET {
END_PROPSET_MAP( )      };
BEGIN_PROVIDER_COLUMN_MAP(x) class __NCB__PROVIDERCOLUMN_##x : public PROVIDER_COLUMN {
END_PROVIDER_COLUMN_MAP() };
BEGIN_SNAPINCOMMAND_MAP(x, bIsExtension) class __NCB__SNAPINCOMMAND_##x : public SNAPINCOMMAND {
END_SNAPINCOMMAND_MAP() };
// Hack a rama for MFC
BEGIN_CONNECTION_MAP(x,y) class __NCB__CONNECTION_##x : public CONNECTION, public y {
END_CONNECTION_MAP()    };
BEGIN_DISPATCH_MAP(x,y) class __NCB__DISPATCH_##x : public DISPATCH, public y {
END_DISPATCH_MAP()      };
BEGIN_EVENT_MAP(x,y)    class __NCB__EVENT_##x : public EVENT, public y {
END_EVENT_MAP()         };
BEGIN_EVENTSINK_MAP(x,y) class __NCB__EVENTSINK_##x : public EVENTSINK, public y {
END_EVENTSINK_MAP()     };
BEGIN_INTERFACE_MAP(x,y) class __NCB__INTERFACE_##x : public INTERFACE, public y {
END_INTERFACE_MAP()     };
BEGIN_MESSAGE_MAP(x,y)  class __NCB__MESSAGE_##x : public MESSAGE, public y {
END_MESSAGE_MAP()       };
BEGIN_OLECMD_MAP(x,y)   class __NCB__OLECMD_##x : public OLECMD, public y {
END_OLECMD_MAP()        };
BEGIN_PARSE_MAP(x,y)    class __NCB__PARSE_##x : public PARSE, public y {
END_PARSE_MAP()         };
#endif	// __FE_PARSER__
