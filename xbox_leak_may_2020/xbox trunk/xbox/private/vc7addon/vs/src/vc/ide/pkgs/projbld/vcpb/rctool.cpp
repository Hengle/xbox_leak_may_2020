// RCTool.cpp : Implementation of Resource Compiler Tool

#include "stdafx.h"
#include "RCTool.h"
#include "BuildEngine.h"
#include "scanner.h"

// constants
const wchar_t* const wszRCDefaultExtensions = L"*.rc";	// remember to update vcpb.rgs if you change this...
const wchar_t* const wszRCDefaultResFile = L"$(IntDir)/$(InputName).res";
const enumResourceLangID lnCulture = rcEnglishUS;

// length of longest token in table
#define MAX_RCTOKEN_LEN		12

// static initializers
CComBSTR CVCResourceCompilerTool::s_bstrBuildDescription = L"";
CComBSTR CVCResourceCompilerTool::s_bstrToolName = L"";
CComBSTR CVCResourceCompilerTool::s_bstrExtensions = L"";
GUID CVCResourceCompilerTool::s_pPages[2];
BOOL CVCResourceCompilerTool::s_bPagesInit = FALSE;
CResourceCompilerToolOptionHandler CVCResourceCompilerTool::s_optHandler;

BOOL TokenLookup(const char *str, ResTokens *pTok);

// dependency generation helper
static int g_Line;

////////////////////////////////////////////////////////////////////////////////
// Option Table for the ResourceCompiler Tool switches

// NOTE: we're using macros for enum value ranges to help in keeping enum range checks as low maintenance as possible.
// If you add an enum to this table, make sure you use macros to define the upper and lower bounds and use CHECK_BOUNDS
// on the get/put methods associated with that property (both object model and property page).
// WARNING: if you change ANYTHING about a multi-prop here (including add/remove), be sure to update how the property
// is obtained on both the tool and page objects.
BEGIN_OPTION_TABLE(CResourceCompilerToolOptionHandler, L"VCResourceCompilerTool", IDS_RC, TRUE /* pre & post */, FALSE /* case sensitive */)
	OPT_BSTR(PreprocessorDefinitions,	L"d %s",		L"PreprocessorDefinitions", multiple,	IDS_RCGeneral, VCRCID)
	OPT_INT_NOZERO(Culture,				L"l 0x%x",		L"Culture",						IDS_RCGeneral, VCRCID)
	OPT_BSTR(AdditionalIncludeDirectories, L"I %s",		L"AdditionalIncludeDirectories",	multipleNoCase, IDS_RCGeneral, VCRCID)
	OPT_BOOL(IgnoreStandardIncludePath, L"|X",			L"IgnoreStandardIncludePath",	IDS_RCGeneral, VCRCID)
	OPT_BOOL(ShowProgress,				L"|v",			L"ShowProgress",				IDS_RCGeneral, VCRCID)
	OPT_BSTR(ResourceOutputFileName,	L"fo%s",		L"ResourceOutputFileName",	single, IDS_RCGeneral, VCRCID)
END_OPTION_TABLE()

// default value handlers
// string props
void CResourceCompilerToolOptionHandler::GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt )
{
	switch( id )
	{
	case VCRCID_ResourceOutputFileName:
		*pVal = SysAllocString( wszRCDefaultResFile );
		break;
//	case VCRCID_AdditionalOptions:
//	case VCRCID_PreprocessorDefinitions:
//	case VCRCID_AdditionalIncludeDirectories:
	default:
		GetDefaultString( pVal );
		break;
	}
}

// integer props
void CResourceCompilerToolOptionHandler::GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt )
{
	switch( id )
	{
	case VCRCID_Culture:
		*pVal = lnCulture;
	default:
		*pVal = 0;
		break;
	}
}

// boolean props
void CResourceCompilerToolOptionHandler::GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt )
{
//	switch( id )
//	{
//	case VCRCID_IgnoreStandardIncludePath:
//	case VCRCID_ShowProgress:
//	default:
		GetValueFalse( pVal );
//		break;
//	}
}


BOOL CResourceCompilerToolOptionHandler::SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption)
{
	switch (idOption)
	{
	case VCRCID_ResourceOutputFileName:
		return TRUE;
	default:
		return FALSE;
	}
}

BOOL CResourceCompilerToolOptionHandler::SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, 
	CComVariant& rvar)
{
	switch (idOption)
	{
	case VCRCID_ResourceOutputFileName:
		{
			VSASSERT(pPropContainer != NULL, "Property container required");
			RETURN_ON_NULL2(pPropContainer, FALSE);
			CComBSTR bstrOutFile;
			GetDefaultValue( idOption, &bstrOutFile );
			rvar = bstrOutFile;
			return TRUE;
		}
	default:
		VSASSERT(FALSE, "Case statement mismatch between SynthesizeOptionIfNeeded and SynthesizeOption");	// shouldn't be able to get here!!
		return FALSE;
	}
}

///////////////////////////////////////////////////////////////////////////////
// Resource Compiler Tool
HRESULT CVCResourceCompilerTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppRCTool)
{
	CHECK_POINTER_NULL(ppRCTool);
	*ppRCTool = NULL;

	CComObject<CVCResourceCompilerTool> *pObj;
	HRESULT hr = CComObject<CVCResourceCompilerTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CVCResourceCompilerTool *pVar = pObj;
		pVar->AddRef();
		*ppRCTool = pVar;
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Return the list of files generated by the resource compiler tool
STDMETHODIMP CVCResourceCompilerTool::GenerateOutput(long type, IVCBuildActionList* plstActions, 
	IVCBuildErrorContext* pEC)
{
	RETURN_ON_NULL2(plstActions, S_FALSE);
	plstActions->Reset(NULL);

	BOOL bFirst = TRUE;
	CComBSTR bstrProjectDirectory;
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = plstActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);

		CComPtr<IVCPropertyContainer> spPropContainer;
		spAction->get_PropertyContainer(&spPropContainer);
		VSASSERT(spPropContainer != NULL, "Property container required");
		if (spPropContainer == NULL)
			continue;

		if (IsExcludedFromBuild(spPropContainer))
			continue;	// nothing to do for things excluded from build...

		if (bFirst)
		{
			bFirst = FALSE;
			spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjectDirectory);	// should never have macros in it
		}

		// DIANEME_TODO: .res extension is apparently platform-specific, get it for CVCResourceCompilerTool::GenerateOutput
		CComBSTR bstrResFileName, bstrTemp;
		if (spPropContainer->GetStrProperty(VCRCID_ResourceOutputFileName, &bstrTemp) == S_FALSE)
			s_optHandler.GetDefaultValue(VCRCID_ResourceOutputFileName, &bstrTemp);
		spPropContainer->Evaluate(bstrTemp, &bstrResFileName);
		if (spAction->AddOutputFromFileName(bstrResFileName, pEC, L"res", bstrProjectDirectory, VARIANT_TRUE, 
			VCRCID_ResourceOutputFileName, this) != S_OK)
			VSASSERT(FALSE, "Failed to add output dependency .res file");
	}

	return S_OK; // success
}

///////////////////////////////////////////////////////////////////////////////
// Affects our output?
STDMETHODIMP CVCResourceCompilerTool::AffectsOutput(long nPropID, VARIANT_BOOL* pbAffectsOutput)
{
	CHECK_POINTER_NULL(pbAffectsOutput);
	*pbAffectsOutput = VARIANT_FALSE;

	// change our outputs?
	switch (nPropID)
	{
	case VCRCID_ResourceOutputFileName:
	case VCRCID_OutputsDirty:
	case VCFCFGID_ExcludedFromBuild:
		*pbAffectsOutput = VARIANT_TRUE;
		break;
	}

	return S_OK;
}

STDMETHODIMP CVCResourceCompilerTool::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	// Get the list of pages
	if( CLSID_RCGeneral == *pCLSID )
	{
		CPageObjectImpl<CVCResourceCompilerPage,VCRCTOOL_MIN_DISPID,VCRCTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else
	{
		return S_FALSE;
	}
		
	return S_OK;
}


GUID* CVCResourceCompilerTool::GetPageIDs()
{ 
	if (s_bPagesInit == FALSE)
	{
		s_pPages[0] = __uuidof(RCGeneral);
		s_pPages[1] = __uuidof(RCAdditionalOptions);
		s_bPagesInit = TRUE;
	}
	return s_pPages; 
}

STDMETHODIMP CVCResourceCompilerTool::CanScanForDependencies(VARIANT_BOOL* pbIsScannable)
{
	return s_optHandler.GetValueTrue(pbIsScannable);
}

///////////////////////////////////////////////////////////////////////////////					
//
//	Scans .RC files for includes.
//
// states
//	0:	initial state
//	1:	'#' received, waiting for 'include', 'define', 'undef' or 'error'
//	2:	'#' and 'include' received, waiting for filename
//	3:	ICON, BITMAP, CURSOR, FONT received, waiting binary filename
//	4:	waiting for newline
//	5:	'rcinclude' received, waiting for filename
//	6:	got newline word, ie. resource identifier
STDMETHODIMP CVCResourceCompilerTool::GenerateDependencies(IVCBuildAction* pAction, void* pfrhFileCookie, IVCBuildErrorContext* pEC)
{
	// WARNING (KiP) - GenerateDependencies works on ANSI Files
	// Many of the calls n this function will need to be _mbs calls instead of unicode
	// TCHAR characters and _tcs funtions should not be used because when UNICODE is defined,
	// TCHAR becomes UNICODE and we explicitly want _mbs no matter what.
	// Yes, ANSI
	
	BldFileRegHandle frhFile = (BldFileRegHandle)pfrhFileCookie;

	const char *pTokenStart, *pLine;

	int			iEntryType = 0, iState;
	int			nNameLength = 0;
	ResTokens	rToken;
	BOOL		bInsideMultiLine;
	char	cDelim;

	HANDLE hMem;
	DWORD dwFileSize;

	const char *pcFileMap;

	const CPathW* pPath = NULL;
	pPath = g_FileRegistry.GetRegEntry(frhFile)->GetFilePath();
	if (!g_StaticBuildEngine.OpenMemFile(frhFile, hMem, pcFileMap, dwFileSize, pEC, pAction))
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NOT_FOUND, IDS_ERR_FILE_NOT_FOUND, pPath->GetFullPath());	// couldn't open, continue with next

	const char * pMax;
	int iBegin = 0;
	BOOL fScanNative;

	if (pcFileMap == (const char *)NULL)
		goto CloseMemFile;	// no need to open

	pMax = pcFileMap + dwFileSize;

	// are we scanning a native resource file?
	// if not then don't attempt to scan using resource script syntax...
	// ie. this might happen if we #include "header.h" in the resource file
	fScanNative = FileNameMatchesExtension(pPath, L"*.rc;*.rc2");

	// Check for afx hack.	If the file begins with "//{{NO_DEP", don't scan:
	if (dwFileSize < 10 || _mbsnicmp ((const unsigned char *)pcFileMap, (const unsigned char *)"//{{NO_DEP", 10) == 0)
	{
		pAction->SetDependencyState(depNone);
		goto CloseMemFile;
	}

	g_Line = 1; iState = 0;
	bInsideMultiLine = FALSE;

	for (;;)
	{
		if ((rToken = GetNextToken (pMax, pcFileMap, pTokenStart)) == TOKEN_EOF)
			break;

		if (rToken == TOKEN_STOP_SCAN)
		{
			for (;rToken = GetNextToken (pMax, pcFileMap, pTokenStart),
				rToken != TOKEN_START_SCAN && rToken != TOKEN_EOF;)
			{}

			if (rToken == TOKEN_EOF) 
				break;
			else 
				continue;
		}

		switch (rToken)
		{
			case TOKEN_NEWLINE:
				if (iState == 4 || iState == 1) 
					iState = 0;
				break;

			case TOKEN_HASHSIGN:
				if (iState != 0) 
					iState = 4;
				else 
					iState = 1;
				break;

			case TOKEN_INCLUDE:
				if (iState != 1) 
					iState = 4;
				else 
					iState = 2;
				break;

			case TOKEN_RCINCLUDE:
				if (iState != 0) 
					iState = 4;
				else 
					iState = 5;
				break;

			case TOKEN_DEFINE:
			case TOKEN_UNDEF:
			case TOKEN_ERROR:
				iState = 4;
				break;

			case TOKEN_COMMENT:
				iState = 0;
				break;

			case TOKEN_WORD:
			{
				// Waiting for a newline...
				if (iState == 4 || iState == 1)
					break;

				// only do this if we *know* we are a resource script
				if (fScanNative)
				{
					// 1st non-quoted word on a line?
					if (iState == 0 && *pTokenStart != '"')
					{
						// wait for 2nd word, could be ICON or 'custom resource' name
						iState = 6;
						break; 
					}
					
					// Is this a 'custom resource' identifier (2nd non-quoted word on a line)?
					if (iState == 6 && *pTokenStart != '"')
					{
						iState = !bInsideMultiLine ? 3 : 4; // next token is include : ignore, wait for newline
						break;
					}
				}

				// Waiting for a file name?
				if (iState == 3)
				{
					// Check for a comma on the same line, before any
					// comments. this is to catch the case 'FONT 8, "Helv"'
					for (pLine = pTokenStart; pLine < pMax && *pLine != '/' && *pLine != '\r'; pLine = (const char *)_mbsinc((const unsigned char *)pLine))
					{
						if (*pLine == ',')
						{
							iState = 4;
							break;
						}
					}
				}

				BOOL fScan = FALSE;		// by default, don't scan the include
				BOOL fGotDep = FALSE;;	// by default, this state is not a got dep.
				
				if (iState	== 3 || iState	== 5)
				{
					iEntryType = IncTypeCheckParentDir | IncTypeCheckIncludePath | IncTypeCheckOriginalDir;

					// check for included 'generated' outputs in intermediate dir.
					if (iState == 3)
						iEntryType |= IncTypeCheckIntDir;

					nNameLength = (int)(pcFileMap - pTokenStart);
					fScan = (iState != 3);
					fGotDep = TRUE;
				}
				else if (iState == 2)
				{
					// include file name in the form "xxxxxx.yyy"
					if (*pTokenStart == '"')
					{
						iEntryType = IncTypeCheckParentDir | IncTypeCheckIncludePath | IncTypeCheckOriginalDir;
						cDelim =  '"';
					}
					else if (*pTokenStart == '<')
					{
						iEntryType = IncTypeCheckIncludePath;
						cDelim =  '>';
					}
					else
					{
						break;
					}
				
					nNameLength =  (int)(pcFileMap - pTokenStart);
					
					// must have "foo.h" or <foo.h> with at least a 1 char. name
					if (nNameLength > 2 && *(pcFileMap-1) == cDelim)
					{
						fScan = TRUE;
						fGotDep = TRUE;
					}

					//	else syntax error
				}

				if (fGotDep)	// deal with this dependency
				{
					CStringW	strFile;
					CStringA	strFileA;	// yes, ANSI -- 'cause we're working with RC files which are ANSI
					char *pbuf = strFileA.GetBuffer((nNameLength + 1)*2);
					CopyAndSuppressBackslashes(pbuf, pTokenStart, nNameLength);
					strFileA.ReleaseBuffer();
					strFile = strFileA;		// Finally convert to unicode and go

					CVCStringWList strlstIncs;
					strlstIncs.AddHead( L"\"" + strFile + L"\"" );
					CVCStringWList strlstPaths;
					if (!ResolveIncludeDirectivesToPath(*pPath, pAction, strlstIncs, strlstPaths))
					{
						pAction->MarkMissingDependencies(TRUE /* missing dep */);
						goto CloseMemFile;
					}
					if(strlstPaths.GetCount())
					{
						CStringW strInc = strlstPaths.GetHead();
						CComBSTR bstrInc = strInc;
						HRESULT hr = pAction->AddScannedDependencyOfType(iEntryType, bstrInc, g_Line, fScan, pEC);
						VSASSERT(hr == S_OK, "Unexpected return value from pAction->AddScannedDependencyOfType");
					}
					iState = 4;
				}
				else
				{
					iState = 0;
				}
				break;
			}

			// These tokens are all just noise, so eat them:
			case TOKEN_LOADONCALL:
			case TOKEN_PRELOAD:
			case TOKEN_PURE:
			case TOKEN_IMPURE:
			case TOKEN_FIXED:
			case TOKEN_MOVEABLE:
			case TOKEN_DISCARDABLE:
				if (iState != 3) 
					iState = 4;
				break;

			case TOKEN_ICON:
			case TOKEN_TYPELIB:
			case TOKEN_FONT:
			case TOKEN_BITMAP:
			case TOKEN_CURSOR:
				if (iState == 6 && !bInsideMultiLine) 
					iState = 3;
				else  
					iState = 4;
				break;

			// ignore all info after these tokens
			case TOKEN_LANGUAGE:
				iState = 4;
				break;
			// These tokens are all multiline statements so we expect to have a BEGIN - END pair
			// and we should ignore anything inside the multiline statement (including the ones 
			// before BEGIN-END block)
			case TOKEN_ACCELERATORS:
			case TOKEN_DIALOG:
			case TOKEN_DLGINIT:
			case TOKEN_MENU:
			case TOKEN_TOOLBAR:
			case TOKEN_RCDATA:
			case TOKEN_STRINGTABLE:
			case TOKEN_VERSIONINFO:
			case TOKEN_GUIDELINES:
			case TOKEN_DIALOGEX:
			case TOKEN_MENUEX:
				bInsideMultiLine = TRUE;
				iState = 4;
				break;
		
			// make sure that the number of begin - end matches
			case TOKEN_BEGIN:
				if (bInsideMultiLine)
					iBegin++;
				iState = 4;
				break;

			case TOKEN_END:
				if (bInsideMultiLine)
				{
					iBegin--;
					if (iBegin == 0)
						bInsideMultiLine = FALSE;
				}
				iState = 4;
				break;
			}
	}

CloseMemFile:

	g_StaticBuildEngine.CloseMemFile(hMem, pEC);

	return S_OK;
}

ResTokens CVCResourceCompilerTool::GetNextToken(const char* pMax, const char*& pCurrent,
	const char*& pTokenStart)
{
	// WARNING (KiP) - GetNextToken works on ANSI Files
	// Many of the calls n this function will need to be _mbs calls instead of unicode
	// TCHAR characters and _tcs funtions should not be used because when UNICODE is defined,
	// TCHAR becomes UNICODE and we explicitly want _mbs no matter what.
	// Yes, ANSI

	//
	//	Goes through map of an RC file looking for tokens.	pCurrent
	//	if the 'file pointer" for the map and returns pointing to the
	//	first charcter after the token.	 pTokenStart returns pointing 
	//	to the start of the token.
	//
	ResTokens RetToken;
	int i;

	if (pCurrent >= pMax) 
		return TOKEN_EOF;

	// Skip white space:
	while (_ismbcspace(*pCurrent))
	{
		BOOL bIsNewLine = (*pCurrent == '\r');
		pCurrent++;

		if (pCurrent >= pMax)
			return TOKEN_EOF;

		if (bIsNewLine)
		{
			g_Line++;
			return TOKEN_NEWLINE;
		}
	}

	pTokenStart = pCurrent;

	// See what first not white-sapce character is
	int nRemLen;
	if (*pCurrent == '#')
	{
		pCurrent++;
		return TOKEN_HASHSIGN;
	}
	else if (*pCurrent == '/')
	{
		// Treat anything with this preceding char. as a comment token!
		RetToken = TOKEN_COMMENT;

		// See if we have special start or stop scan delimiters
		nRemLen = (int)(pMax - pCurrent);
		if (nRemLen > 16 &&
			(_mbsnicmp ((const unsigned char *)pCurrent, (const unsigned char *)"//}}START_DEPSCAN", 17) == 0))
			RetToken = TOKEN_START_SCAN;

		else
		if (nRemLen > 15 &&
			(_mbsnicmp ((const unsigned char *)pCurrent, (const unsigned char *)"//{{STOP_DEPSCAN", 16) == 0))
			RetToken = TOKEN_STOP_SCAN;

		// Do we need to skip a comment block?
		BOOL fInCommentBlock = (nRemLen > 1) && (*(pCurrent + 1) == '*');

		// Skip up to and including new line, this will be after a comment
		// block if we have one.
		// This means no TOKEN_NEWLINE follows a comment.
		while (pCurrent < pMax)
		{
			if (*pCurrent == '\r')
			{
				g_Line++;
				if (!fInCommentBlock)
					break;
			}
			// End of the comment block?
			else if (fInCommentBlock && (pCurrent < (pMax - 1)) &&
					 *pCurrent == '*' && *(pCurrent + 1) == '/')
			{
				fInCommentBlock = FALSE;
			}

			pCurrent = (const char *)_mbsinc((const unsigned char *)pCurrent);
		}
		pCurrent = (const char *)_mbsinc((const unsigned char *)pCurrent);
		return RetToken;
	}

	//	If the token begins with a quote, then go till the next quote:
	else if (*pTokenStart== '"')
	{
		pCurrent = (const char *)_mbsinc((const unsigned char *)pCurrent);
		while (pCurrent < pMax && *pCurrent != '"')
			pCurrent = (const char *)_mbsinc((const unsigned char *)pCurrent);
		pCurrent = (const char *)_mbsinc((const unsigned char *)pCurrent);
		return (pCurrent >= pMax) ? TOKEN_EOF : TOKEN_WORD;
	}
		
	//	Some kind of a word.  Skip to the end:
	while (pCurrent < pMax && !_ismbcspace(*pCurrent))
		pCurrent = (const char *)_mbsinc((const unsigned char *)pCurrent);
	if (pCurrent >= pMax + 1)	
		return TOKEN_EOF;

	//	Examine the token.

	i = (int)(pCurrent - pTokenStart);	// Length of token in bytes.

	if ((i > MAX_RCTOKEN_LEN) || (!_ismbcalpha(*pTokenStart))) // REVIEW(KiP): Does this work, what about MBC alpha characters?
		return TOKEN_WORD;		
		
	// look up in map for speed
	char szToken[MAX_RCTOKEN_LEN+1];
	_mbsncpy((unsigned char *)szToken, (unsigned char *)pTokenStart, i);
	szToken[i] = 0;						// nul-terminate
	_mbslwr((unsigned char *)szToken);			// FUTURE: combine with copy operation

	if (TokenLookup((const char *)szToken,	&RetToken))
		return RetToken;

	return TOKEN_WORD;
}


//	Copy an .rc #include from psrcbuf to pdestbuf.	If the fisrt
//	character is a ", then double back slashes in the src
//	are replaced with a single \.
//
//	nchar chars are copied (nchar - 2 of there are quotes),
//	and a terminating null is put on.
//
void CVCResourceCompilerTool::CopyAndSuppressBackslashes(char *pdestbuf, const char * psrcbuf, int nchar)
{
	// WARNING (KiP) - CopyAndSurpressBackslashes works on ANSI Files
	// Many of the calls n this function will need to be _mbs calls instead of unicode
	// TCHAR characters and _tcs funtions should not be used because when UNICODE is defined,
	// TCHAR becomes UNICODE and we explicitly want _mbs no matter what.
	// Yes, ANSI

	const char *pMax;

	if (*psrcbuf != '"' && *psrcbuf != '<')
	{
		_mbsncpy ((unsigned char *)pdestbuf, (unsigned char *)psrcbuf, nchar);
		pdestbuf[nchar] = '\0';
		return;
	}

	BOOL	fSawBackWhack = FALSE;

	psrcbuf++;
	pMax = psrcbuf + nchar -2;	// subtract 2 for leading trailing quotes.

	while (psrcbuf < pMax)
	{
		if (fSawBackWhack ||
			!(*psrcbuf == '\\' && *(psrcbuf+1) == '\\'))
		{
			// copy one (possibly multibyte) character
			if (IsDBCSLeadByte(*pdestbuf++ = *psrcbuf++))
				*pdestbuf++ = *psrcbuf++;
			fSawBackWhack = FALSE;
		}
		else	
		{
			psrcbuf++;
			fSawBackWhack = TRUE;
		}
	}			

	// get trailing slash?
	if (fSawBackWhack)
		*pdestbuf++ = *--psrcbuf;

	*pdestbuf = '\0';
}

struct RCToken
{
	const char *strName;
	ResTokens	tok;

};

// WARNING: Keep this in alphabetical order or the bsearch will fail !
RCToken s_TokenList[31] =
{
	{ "accelerators",TOKEN_ACCELERATORS },
	{ "begin",      TOKEN_BEGIN },
	{ "bitmap",     TOKEN_BITMAP },
	{ "cursor",     TOKEN_CURSOR },
	{ "define", 	TOKEN_DEFINE },
	{ "dialog", 	TOKEN_DIALOG },
	{ "dialogex",	TOKEN_DIALOGEX },
	{ "discardable",TOKEN_DISCARDABLE },
	{ "dlginit",	TOKEN_DLGINIT },
	{ "end",        TOKEN_END },
	{ "error",      TOKEN_ERROR },
	{ "fixed",      TOKEN_FIXED },
	{ "font",       TOKEN_FONT },
	{ "guidelines", TOKEN_GUIDELINES },
	{ "icon",       TOKEN_ICON },
	{ "impure",     TOKEN_IMPURE },
	{ "include",	TOKEN_INCLUDE },
	{ "language",	TOKEN_LANGUAGE },
	{ "loadoncall", TOKEN_LOADONCALL },
	{ "menu",       TOKEN_MENU },
	{ "menuex", 	TOKEN_MENUEX },
	{ "moveable",	TOKEN_MOVEABLE },
	{ "preload",	TOKEN_PRELOAD },
	{ "pure",       TOKEN_PURE },
	{ "rcdata", 	TOKEN_RCDATA },
	{ "rcinclude",	TOKEN_RCINCLUDE },
	{ "stringtable",TOKEN_STRINGTABLE },
	{ "toolbar",	TOKEN_TOOLBAR },
	{ "typelib",	TOKEN_TYPELIB },
	{ "undef",      TOKEN_UNDEF },
	{ "versioninfo",TOKEN_VERSIONINFO }
};

int TokenCompare( char **pKey, RCToken *s2 )
{
	const char *key = *pKey;
	return strcmp( key, s2->strName );
}

BOOL TokenLookup(const char *str, ResTokens *pTok)
{
	RCToken *pRCTok = (RCToken *)bsearch( &str, &s_TokenList,31,sizeof(RCToken), (int(*)(const void *, const void *))TokenCompare);
	if( pRCTok )
	{
		*pTok = pRCTok->tok;
		return TRUE;
	}
	else
		return FALSE;
}


///////////////////////////////////////////////////////////////////////////////////////
// CVCResourceCompilerTool::VCResourceCompilerTool -- switches are not case sensitive
///////////////////////////////////////////////////////////////////////////////////////

LPCOLESTR CVCResourceCompilerTool::GetToolFriendlyName()
{
	InitToolName();
	return s_bstrToolName;
}

void CVCResourceCompilerTool::InitToolName()
{
	if (s_bstrToolName.Length() == 0)
	{
		if (!s_bstrToolName.LoadString(IDS_RC_TOOLNAME))
			s_bstrToolName = szResourceCompilerToolType;
	}
}

STDMETHODIMP CVCResourceCompilerTool::get_ToolName(BSTR* pbstrToolName) // friendly name of tool, e.g., "C/C++ Compiler Tool"
{
	CHECK_POINTER_VALID( pbstrToolName );
	InitToolName();
	s_bstrToolName.CopyTo(pbstrToolName);
	return S_OK;
}

STDMETHODIMP CVCResourceCompilerTool::get_AdditionalOptions(BSTR* pbstrAdditionalOptions)
{	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other switches
	return ToolGetStrProperty(VCRCID_AdditionalOptions, pbstrAdditionalOptions);
}

STDMETHODIMP CVCResourceCompilerTool::put_AdditionalOptions(BSTR bstrAdditionalOptions)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCRCID_AdditionalOptions, bstrAdditionalOptions);
}

STDMETHODIMP CVCResourceCompilerTool::get_PreprocessorDefinitions(BSTR* pbstrDefines)
{	// (/d) define symbol can have multiple
	return ToolGetStrProperty(VCRCID_PreprocessorDefinitions, pbstrDefines);
}

STDMETHODIMP CVCResourceCompilerTool::put_PreprocessorDefinitions(BSTR bstrDefines)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCRCID_PreprocessorDefinitions, bstrDefines);
}

STDMETHODIMP CVCResourceCompilerTool::get_Culture(enumResourceLangID* pnLangID)
{	// (/l [num]) resource language ID
	return ToolGetIntProperty(VCRCID_Culture, (long *)pnLangID);
}

STDMETHODIMP CVCResourceCompilerTool::put_Culture(enumResourceLangID nLangID)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POSITIVE(nLangID);
	return m_spPropertyContainer->SetIntProperty(VCRCID_Culture, nLangID);
}

STDMETHODIMP CVCResourceCompilerTool::get_AdditionalIncludeDirectories(BSTR* pbstrIncludePath)
{	// (/I![path]) directory to add to include path, may have multiple
	return ToolGetStrProperty(VCRCID_AdditionalIncludeDirectories, pbstrIncludePath);
}

STDMETHODIMP CVCResourceCompilerTool::put_AdditionalIncludeDirectories(BSTR bstrIncludePath)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCRCID_AdditionalIncludeDirectories, bstrIncludePath);
}

STDMETHODIMP CVCResourceCompilerTool::get_IgnoreStandardIncludePath(VARIANT_BOOL* pbIgnoreInclPath)
{	// (/X) ignore standard include path
	return ToolGetBoolProperty(VCRCID_IgnoreStandardIncludePath, pbIgnoreInclPath);
}

STDMETHODIMP CVCResourceCompilerTool::put_IgnoreStandardIncludePath(VARIANT_BOOL bIgnoreInclPath)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bIgnoreInclPath );
	return m_spPropertyContainer->SetBoolProperty(VCRCID_IgnoreStandardIncludePath, bIgnoreInclPath);
}

STDMETHODIMP CVCResourceCompilerTool::get_ShowProgress(VARIANT_BOOL* pbShowProgress)
{	// (/v) verbose (print progress messages)
	return ToolGetBoolProperty(VCRCID_ShowProgress, pbShowProgress);
}

STDMETHODIMP CVCResourceCompilerTool::put_ShowProgress(VARIANT_BOOL bShowProgress)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bShowProgress );
	return m_spPropertyContainer->SetBoolProperty(VCRCID_ShowProgress, bShowProgress);
}

STDMETHODIMP CVCResourceCompilerTool::get_ResourceOutputFileName(BSTR* pbstrResFile)
{	// (/fo[file]) name .RES file default: <rcfile>.res
	return ToolGetStrProperty(VCRCID_ResourceOutputFileName, pbstrResFile);
}

STDMETHODIMP CVCResourceCompilerTool::put_ResourceOutputFileName(BSTR bstrResFile)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCRCID_ResourceOutputFileName, bstrResFile);
}

// Automation properties
STDMETHODIMP CVCResourceCompilerTool::get_ToolPath(BSTR *pVal)
{
	CHECK_POINTER_VALID(pVal);
	*pVal = SysAllocString( szResourceCompilerToolPath );
	return S_OK;
}

STDMETHODIMP CVCResourceCompilerTool::get_PropertyOption(BSTR bstrProp, long dispidProp, BSTR *pVal)
{ 
	return DoGetPropertyOption(bstrProp, dispidProp, pVal); 
}

STDMETHODIMP CVCResourceCompilerTool::get_FullIncludePath(BSTR* fullIncludePath)
{	// include path, including all inherited values, plus platform includes
	return get_FullIncludePathInternal(fullIncludePath);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CVCResourceCompilerTool::IVCToolImpl
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CVCResourceCompilerTool::get_DefaultExtensions(BSTR* pVal)
{
	return DoGetDefaultExtensions(s_bstrExtensions, wszRCDefaultExtensions, pVal);
}

STDMETHODIMP CVCResourceCompilerTool::put_DefaultExtensions(BSTR newVal)
{
	s_bstrExtensions = newVal;
	return S_OK;
}

STDMETHODIMP CVCResourceCompilerTool::GetAdditionalOptionsInternal(IUnknown* pItem, VARIANT_BOOL bForBuild, 
	VARIANT_BOOL bSkipLocal, BSTR* pbstrAdditionalOptions)
{ 
	return GetProcessedAdditionalOptions(pItem, VCRCID_AdditionalOptions, bForBuild, bSkipLocal, pbstrAdditionalOptions);
}

STDMETHODIMP CVCResourceCompilerTool::GetBuildDescription(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
{
	if (s_bstrBuildDescription.Length() == 0)
		s_bstrBuildDescription.LoadString(IDS_DESC_RC_COMPILING);
	return s_bstrBuildDescription.CopyTo(pbstrBuildDescription);
}

STDMETHODIMP CVCResourceCompilerTool::get_ToolPathInternal(BSTR* pbstrToolPath)
{ 
	return get_ToolPath(pbstrToolPath);
}

STDMETHODIMP CVCResourceCompilerTool::get_Bucket(long *pVal)
{
	CHECK_POINTER_NULL( pVal );
	*pVal = BUCKET_RC;
	return S_OK;
}

STDMETHODIMP CVCResourceCompilerTool::CreateToolObject(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
{ 
	return CreateInstance(pPropContainer, ppToolObject); 
}

STDMETHODIMP CVCResourceCompilerTool::GetAdditionalIncludeDirectoriesInternal(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs)
{
	CHECK_POINTER_NULL( pbstrIncDirs );
	CHECK_READ_POINTER_NULL(pPropContainer);

	CComBSTR bstrTmp;
	HRESULT hr = pPropContainer->GetMultiProp(VCRCID_AdditionalIncludeDirectories, L";", VARIANT_FALSE, &bstrTmp);
	if (SUCCEEDED(hr))
		pPropContainer->Evaluate(bstrTmp, pbstrIncDirs);
	else
		*pbstrIncDirs = bstrTmp.Detach();
	return hr;
}

STDMETHODIMP CVCResourceCompilerTool::get_IncludePathID(long* pnIncludeID)
{
	CHECK_POINTER_NULL(pnIncludeID);
	*pnIncludeID = VCRCID_AdditionalIncludeDirectories;
	return S_OK;
}

STDMETHODIMP CVCResourceCompilerTool::get_ToolShortName(BSTR* pbstrToolName)
{
	*pbstrToolName = SysAllocString( szResourceCompilerToolShortName );
	return S_OK;
}

STDMETHODIMP CVCResourceCompilerTool::MatchName(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
{
	return DoMatchName(bstrName, szResourceCompilerToolType, szResourceCompilerToolShortName, pbMatches);
}


STDMETHODIMP CVCResourceCompilerPage::get_AdditionalOptions(BSTR* pbstrAdditionalOptions)
{	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	return ToolGetStrProperty(VCRCID_AdditionalOptions, &(CVCResourceCompilerTool::s_optHandler), pbstrAdditionalOptions);
}

STDMETHODIMP CVCResourceCompilerPage::put_AdditionalOptions(BSTR bstrAdditionalOptions)
{
	return SetStrProperty(VCRCID_AdditionalOptions, bstrAdditionalOptions);
}

STDMETHODIMP CVCResourceCompilerPage::get_PreprocessorDefinitions(BSTR* pbstrDefines)
{	// (/d) define symbol can have multiple
	return ToolGetStrProperty(VCRCID_PreprocessorDefinitions, &(CVCResourceCompilerTool::s_optHandler), pbstrDefines);
}

STDMETHODIMP CVCResourceCompilerPage::put_PreprocessorDefinitions(BSTR bstrDefines)
{
	return SetStrProperty(VCRCID_PreprocessorDefinitions, bstrDefines);
}

STDMETHODIMP CVCResourceCompilerPage::get_Culture(enumResourceLangID* pnLangID)
{	// (/l [num]) resource language ID
	return ToolGetIntProperty(VCRCID_Culture, &(CVCResourceCompilerTool::s_optHandler), (long *)pnLangID);
}

STDMETHODIMP CVCResourceCompilerPage::put_Culture(enumResourceLangID nLangID)
{
	CHECK_POSITIVE_FOR_PROP_PAGES(nLangID);
	return SetIntProperty(VCRCID_Culture, nLangID);
}

STDMETHODIMP CVCResourceCompilerPage::get_AdditionalIncludeDirectories(BSTR* pbstrIncludePath)
{	// (/I![path]) directory to add to include path, may have multiple
	return ToolGetStrProperty(VCRCID_AdditionalIncludeDirectories, &(CVCResourceCompilerTool::s_optHandler), pbstrIncludePath);
}

STDMETHODIMP CVCResourceCompilerPage::put_AdditionalIncludeDirectories(BSTR bstrIncludePath)
{
	return SetStrProperty(VCRCID_AdditionalIncludeDirectories, bstrIncludePath);
}

STDMETHODIMP CVCResourceCompilerPage::get_IgnoreStandardIncludePath(enumIgnoreStandardIncludePathBOOL* pbIgnoreInclPath)
{	// (/X) ignore standard include path
	return GetEnumBoolProperty2(VCRCID_IgnoreStandardIncludePath, (long *)pbIgnoreInclPath);
}

STDMETHODIMP CVCResourceCompilerPage::put_IgnoreStandardIncludePath(enumIgnoreStandardIncludePathBOOL bIgnoreInclPath)
{
	return SetBoolProperty(VCRCID_IgnoreStandardIncludePath, bIgnoreInclPath);
}

STDMETHODIMP CVCResourceCompilerPage::get_ShowProgress(enumShowProgressBOOL* pbShowProgress)
{	// (/v) verbose (print progress messages)
	return GetEnumBoolProperty2(VCRCID_ShowProgress, (long *)pbShowProgress);
}

STDMETHODIMP CVCResourceCompilerPage::put_ShowProgress(enumShowProgressBOOL bShowProgress)
{
	return SetBoolProperty(VCRCID_ShowProgress, bShowProgress);
}

STDMETHODIMP CVCResourceCompilerPage::get_ResourceOutputFileName(BSTR* pbstrResFile)
{	// (/fo[file]) name .RES file default: <rcfile>.res
	return ToolGetStrProperty(VCRCID_ResourceOutputFileName, &(CVCResourceCompilerTool::s_optHandler), pbstrResFile);
}

STDMETHODIMP CVCResourceCompilerPage::put_ResourceOutputFileName(BSTR bstrResFile)
{
	return SetStrProperty(VCRCID_ResourceOutputFileName, bstrResFile);
}

void CVCResourceCompilerPage::GetBaseDefault(long id, CComVariant& varValue)
{
	if (id == VCRCID_ResourceOutputFileName)
	{
		CComBSTR bstrVal;
		CVCResourceCompilerTool::s_optHandler.GetDefaultValue( id, &bstrVal );
		varValue = bstrVal;
	}
	else
		CBase::GetBaseDefault(id, varValue);
}

// helper function for the two member functions below
static void FormatLanguageString(long lcid, CStringW& strLang)
{
	wchar_t sz[4096];	
	int dRet = GetLocaleInfoW(lcid, LOCALE_SLANGUAGE, sz, 4095);
	if (dRet > 4095 || dRet == 0)
		strLang.Format(L"0x%x", lcid);
	else
		strLang.Format(L"%s (0x%x)", sz, lcid);
}

STDMETHODIMP CVCResourceCompilerPage::GetDisplayString( DISPID dispID, BSTR *pBstr )
{
	if (dispID != VCRCID_Culture)
		return CBase::GetDisplayString(dispID, pBstr);

	CHECK_POINTER_NULL(pBstr);

	// what type is this?
	CComVariant var;
	HRESULT hr = CComDispatchDriver::GetProperty( this, dispID, &var );
	if( FAILED( hr ) )
		return S_FALSE;
	else if ((var.vt != VT_I2 && var.vt != VT_I4) || var.lVal == INHERIT_PROP_VALUE)
		return CBase::GetDisplayString(dispID, pBstr);

	CStringW strLang;
	if (var.lVal)
		FormatLanguageString(var.lVal, strLang);
	else
		strLang.LoadString(VCTDENUM_Default);
	*pBstr = strLang.AllocSysString();
	return S_OK;
}

void CVCResourceCompilerPage::GetLocalizedName(DISPID dispID, MEMBERID memid, ITypeInfo2* pTypeInfo2Enum, long lVal, CComBSTR& bstrDoc)
{
	if (dispID != VCRCID_Culture || lVal == INHERIT_PROP_VALUE)
		return CBase::GetLocalizedName(dispID, memid, pTypeInfo2Enum, lVal, bstrDoc);

	// try to get the localized name if possible.
	CStringW strLang;
	if (lVal)
		FormatLanguageString(lVal, strLang);
	else
		strLang.LoadString(VCTDENUM_Default);
	bstrDoc = strLang;
}