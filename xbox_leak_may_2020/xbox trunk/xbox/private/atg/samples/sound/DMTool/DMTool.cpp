//-----------------------------------------------------------------------------
// File: DMTool.cpp
//
// Desc: Demonstrates how to use Direct Music tools to synchronize
//       audio and video
//
// Hist: 3.13.01 - New for April XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include <dmusici.h>
#include "tool.h"
#include "dsstdfx.h"
#include "myfactory.h"

typedef struct
{
    D3DXVECTOR4 p;
    D3DCOLOR    c;
} CUSTOMVERTEX;
#define FVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Start/stop" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Change segment" },
};

#define NUM_HELP_CALLOUTS 3

char * g_szSegments[] =
{
    "ClaireDeLune.sgt", 
    "Bach Invention.sgt", 
    "BrassAction.sgt",  
    "FurElise.sgt",
};

#define NUM_SEGMENTS 4

// Since most of the time is taken modifying vertices and rendering them,
// we need to double buffer to avoid blocking
#define NUM_BUFFERS 2

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;

    BOOL            m_bDrawHelp;    // Show Help?
    BOOL            m_bPlaying;     // Is music playing?
    DWORD           m_dwCurrent;    // Current segment

    // VB to show notes being played
    LPDIRECT3DVERTEXBUFFER8        m_pVB;

    // How many quads we filled in the VB
    DWORD                          m_dwNumQuads;

    IDirectMusicPerformance8 *     m_pDMPerformance;
    IDirectMusicLoader8 *          m_pDMLoader;
    IDirectMusicSegment8 *         m_apMusic[NUM_SEGMENTS];
    IDirectMusicAudioPath8 *       m_pMusicAudioPath;
    IDirectMusicGraph8 *           m_pDMGraph;
    CDisplayTool *                 m_pDisplayTool;
    LPDIRECTSOUND8                 m_pDSound;

    // Array of last playing of each note by each channel
    DMUS_NOTE_PMSG *               m_aNotes;

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP
};


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}


//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
    m_dwCurrent = 0;
    m_aNotes = new DMUS_NOTE_PMSG[ NUM_CHANNELS * NUM_NOTES ];
}



//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }

    return hr;
}




#define COL_WIDTH 4
#define COL_HEIGHT 4
//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    // Initialize DMusic
    IDirectMusicHeap* pNormalHeap;
    DirectMusicCreateDefaultHeap( &pNormalHeap );

    IDirectMusicHeap* pPhysicalHeap;
    DirectMusicCreateDefaultPhysicalHeap( &pPhysicalHeap );

    DirectMusicInitializeEx( pNormalHeap, pPhysicalHeap, MyFactory );

    pNormalHeap->Release();
    pPhysicalHeap->Release();

    // Create loader object
    DirectMusicCreateInstance( CLSID_DirectMusicLoader, NULL, 
                               IID_IDirectMusicLoader8, (VOID**)&m_pDMLoader );

    // Create performance object
    DirectMusicCreateInstance( CLSID_DirectMusicPerformance, NULL,
                               IID_IDirectMusicPerformance8, (VOID**)&m_pDMPerformance );

    // Initialize the performance with the standard audio path.
    // The flags (final) argument allows us to specify whether or not we want
    // DirectMusic to create a thread on our behalf to process music, using 
    // DMUS_INITAUDIO_NOTHREADS.  The default is for DirectMusic to create its
    // own thread; DMUS_INITAUDIO_NOTHREADS tells DirectMusic not to do this, 
    // and the app will periodically call DirectMusicDoWork().  For software 
    // emulation on alpha hardware, it's generally better to have DirectMusic
    // create its own thread. On real hardware, periodically calling 
    // DirectMusicDoWork may provide a better option.
    m_pDMPerformance->InitAudioX( DMUS_APATH_SHARED_STEREOPLUSREVERB, 96, 128, 0 );

    // Tell DirectMusic where the default search path is
    m_pDMLoader->SetSearchDirectory( GUID_DirectMusicAllTypes, 
                                   "D:\\Media\\Sounds", FALSE );
    
    // Load segments 
    // We load all segments up front so there isn't a delay when switching 
    // between segments later on
    for( int i = 0; i < NUM_SEGMENTS; i++ )
    {
        m_pDMLoader->LoadObjectFromFile( CLSID_DirectMusicSegment, IID_IDirectMusicSegment8, 
                                       g_szSegments[i], (VOID**)&m_apMusic[i] );

        m_apMusic[i]->SetRepeats( DMUS_SEG_REPEAT_INFINITE );
    }
    
    // Get default (music) audiopath.
    m_pDMPerformance->GetDefaultAudioPath( &m_pMusicAudioPath );

    // Max volume for music
    m_pMusicAudioPath->SetVolume( (100*100)-10000, 0 );

    // Create a DirectMusicGraph, and tell the preformance about it
    m_pMusicAudioPath->GetObjectInPath( 0, DMUS_PATH_PERFORMANCE_GRAPH, 0,
                                           GUID_NULL, 0, IID_IDirectMusicGraph, 
                                           (LPVOID*) &m_pDMGraph );

    // Create and insert the DirectMusic Tool
    m_pDisplayTool = new CDisplayTool( m_aNotes );
    m_pDMGraph->InsertTool( m_pDisplayTool, NULL, 0, 0 );

    // Play segment on the default audio path
    m_pDMPerformance->PlaySegmentEx( m_apMusic[0], NULL, NULL, 0, 
                                   0, NULL, NULL, NULL );
    m_bPlaying = TRUE;

    // Create vertex buffer to display notes
    m_pd3dDevice->CreateVertexBuffer( NUM_CHANNELS * NUM_NOTES * 4 * sizeof( CUSTOMVERTEX ), 0, 0, D3DPOOL_MANAGED, &m_pVB );

    ZeroMemory( m_aNotes, NUM_CHANNELS * NUM_NOTES * sizeof( DMUS_NOTE_PMSG ) );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    REFERENCE_TIME rt;
    MUSIC_TIME mt;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Toggle playback
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( m_bPlaying )
            m_pDMPerformance->StopEx( m_apMusic[m_dwCurrent], 0, 0 );
        else
            m_pDMPerformance->PlaySegmentEx( m_apMusic[m_dwCurrent], NULL, NULL, 0, 0, NULL, NULL, NULL );

        m_bPlaying = !m_bPlaying;
    }

    // Change to a different segment
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        ZeroMemory( m_aNotes, NUM_CHANNELS * NUM_NOTES * sizeof( DMUS_NOTE_PMSG ) );

        // If we were playing before, stop the segment
        if( m_bPlaying )
            m_pDMPerformance->StopEx( m_apMusic[m_dwCurrent], 0, 0 );

        // Switch to next segment
        m_dwCurrent = ( m_dwCurrent + 1 ) % ( sizeof( g_szSegments ) / sizeof( g_szSegments[0] ) );
    
        // Play new segment on the default audio path
        if( m_bPlaying )
            m_pDMPerformance->PlaySegmentEx( m_apMusic[m_dwCurrent], NULL, NULL, 0, 
                                             0, NULL, NULL, NULL );
    }

    // Update our vertex buffer with current state of notes.
    m_pDMPerformance->GetTime( &rt, &mt );

    //
    // Now, loop over each note of each channel.  If it's
    // being played, add it to our vertex buffer
    //
    m_dwNumQuads = 0;
    CUSTOMVERTEX * pVertices;
    m_pVB->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    for( int channel = 0; channel < NUM_CHANNELS; channel++ )
    {
        // Spread the colors out over the channel range
        DWORD dwChannelColor = 0xFF000000 | DWORD( channel / (float)NUM_CHANNELS * 0xFFFFFF );

        for( int note = 0; note < NUM_NOTES; note++ )
        {
            BYTE bVel;
            MUSIC_TIME mtNoteEnd = m_aNotes[ channel * NUM_NOTES + note ].mtTime + m_aNotes[ channel * NUM_NOTES + note ].mtDuration;
            REFERENCE_TIME rtNoteEnd;
            
            m_pDMPerformance->MusicToReferenceTime( mtNoteEnd, &rtNoteEnd );

            if( rtNoteEnd + 2500000 < rt )
            {
                // Note ended > .25 seconds ago
                bVel = 0;
                continue;
            }
            else if( rtNoteEnd > rt )
            {
                // Note still playing
                bVel = m_aNotes[ channel * NUM_NOTES + note ].bVelocity;
            }
            else
            {
                // Within .25 seconds of note end
                bVel = BYTE( ( 1.0f - ( rt - rtNoteEnd ) / 2500000.0f ) * m_aNotes[ channel * NUM_NOTES + note ].bVelocity );
            }

            // Calculate height of note
            FLOAT fHeight = 480 - ( ( 480 - 48 ) * bVel / 127.0f );

            // Add a quad to the vertex buffer
            pVertices[m_dwNumQuads * 4 + 0].p = D3DXVECTOR4( (note+0)*COL_WIDTH + 64 - 0.5f, fHeight+COL_HEIGHT - 0.5f, 1.0f, 1.0f );
            pVertices[m_dwNumQuads * 4 + 0].c = dwChannelColor;
            pVertices[m_dwNumQuads * 4 + 1].p = D3DXVECTOR4( (note+0)*COL_WIDTH + 64 - 0.5f, fHeight            - 0.5f, 1.0f, 1.0f );
            pVertices[m_dwNumQuads * 4 + 1].c = dwChannelColor;
            pVertices[m_dwNumQuads * 4 + 2].p = D3DXVECTOR4( (note+1)*COL_WIDTH + 64 - 0.5f, fHeight            - 0.5f, 1.0f, 1.0f );
            pVertices[m_dwNumQuads * 4 + 2].c = dwChannelColor;
            pVertices[m_dwNumQuads * 4 + 3].p = D3DXVECTOR4( (note+1)*COL_WIDTH + 64 - 0.5f, fHeight+COL_HEIGHT - 0.5f, 1.0f, 1.0f );
            pVertices[m_dwNumQuads * 4 + 3].c = dwChannelColor;
            m_dwNumQuads++;
        }
    }
    m_pVB->Unlock();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetVertexShader( FVF_CUSTOMVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof( CUSTOMVERTEX ) );

    // Draw the quads from our vertex buffer
    if( m_dwNumQuads > 0 )
        m_pd3dDevice->DrawVertices( D3DPT_QUADLIST, 0, m_dwNumQuads * 4 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR szTemp[256];

		m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"DMTool" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        swprintf( szTemp, L"Playing: %S", g_szSegments[ m_dwCurrent ] );
        m_Font.DrawText(  64, 80, m_bPlaying ? 0xFFFFFFFF : 0xFF808080, szTemp );
		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}

