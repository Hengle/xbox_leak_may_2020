//-----------------------------------------------------------------------------
// File: WaveBank.cpp
//
// Desc: This sample demonstrates how to use the new SetPlayRegion and 
//       SetFormat APIs to implement a wave bank of wav files
//
// Hist: 11.13.01 - New for December XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include <wavbndlr.h>
#include <assert.h>
#include <dsstdfx.h>

// This header file is generated by the wav bundler tool
#include "sounds.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_1, L"Select sound" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Play sound" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_1, L"Loop sound" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_1, L"Stop buffer" },
};

#define NUM_HELP_CALLOUTS ( sizeof( g_HelpCallouts ) / sizeof( g_HelpCallouts[0] ) )




#define DISPLAY_LENGTH 8




//-----------------------------------------------------------------------------
// Name: BufferQueueNode
// Desc: Node in our queue of buffers
//-----------------------------------------------------------------------------
struct BufferQueueNode
{
    BufferQueueNode*            pNext;
    LPDIRECTSOUNDBUFFER         pBuffer;
    LONG                        lPlayingSound;
};



// Helper function for converting wave formats
VOID CreateWaveFormatEx( WAVEBANKMINIWAVEFORMAT* pmini, XBOXADPCMWAVEFORMAT* pwfx );





//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);     // downloads a default DSP image to the GP
    HRESULT LoadWaveBank( LPCSTR strFilename );             // Load a wave bank
    HRESULT InitializeBufferPool( DWORD dwNumberOfBuffers,  // Initialize our buffer pool
                                  VOID* pbSampleData, 
                                  DWORD dwDataLength );
    HRESULT PlaySound( DWORD dwIndex, BOOL fLooping );      // Play the specified sound

    BufferQueueNode*    Dequeue();                          // Dequeue from buffer pool
    void                Enqueue( BufferQueueNode* pNode );  // Enqueue to buffer pool

    CXBFont     m_Font;                                     // Font object
    CXBHelp     m_Help;                                     // Help object
    BOOL        m_bDrawHelp;                                // TRUE to draw help screen

    LPDIRECTSOUND       m_pDSound;                          // DirectSound object

    DWORD               m_dwDisplayStart;                   // Display management
    DWORD               m_dwSelection;                      // ...
    DWORD               m_dwCurrent;                        // ...

    // Wave bank entries and sample data
    WAVEBANKENTRY       m_aWaveBankEntries[WAVEBANK_SOUNDS_ENTRY_COUNT];
    BYTE*               m_pbSampleData;

    BufferQueueNode*    m_pNodes;                           // Buffer Queue allocation
    DWORD               m_dwNumberOfBuffers;                // Total # of buffers
    DWORD               m_dwAvailableBuffers;               // # of available buffers
    DWORD               m_dwPlayingBuffers;                 // # of playing buffers
    BufferQueueNode*    m_pBufferPoolHead;                  // Queue of ready buffers
    BufferQueueNode*    m_pBufferPoolTail;                  // ...

    BufferQueueNode*    m_pBusyBuffersHead;                 // List of busy buffers
};




//-----------------------------------------------------------------------------
// Name: Dequeue
// Desc: Dequeues from the head of the buffer queue, returning NULL if empty
//-----------------------------------------------------------------------------
BufferQueueNode* CXBoxSample::Dequeue()
{
    BufferQueueNode* pNode = m_pBufferPoolHead;

    if( m_pBufferPoolHead )
    {
        m_pBufferPoolHead = m_pBufferPoolHead->pNext;
        if( m_pBufferPoolTail == pNode )
            m_pBufferPoolTail = NULL;
    }

    return pNode;
}




//-----------------------------------------------------------------------------
// Name: Enqueue
// Desc: Adds to the tail of the queue
//-----------------------------------------------------------------------------
void CXBoxSample::Enqueue( BufferQueueNode* pNode )
{
    if( m_pBufferPoolTail )
    {
        m_pBufferPoolTail->pNext = pNode;
        m_pBufferPoolTail = pNode;
    }
    else
    {
        m_pBufferPoolHead =
        m_pBufferPoolTail = pNode;
    }
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp         = FALSE;
    m_pbSampleData      = NULL;
    m_pDSound           = NULL;

    m_pNodes            = NULL;
    m_pBufferPoolHead   = NULL;
    m_pBufferPoolTail   = NULL;
    m_pBusyBuffersHead  = NULL;

    m_dwCurrent         = 0;
    m_dwDisplayStart    = 0;
    m_dwSelection       = 0;
}




//-----------------------------------------------------------------------------
// Name: InitializeBufferPool
// Desc: Initializes the buffer pool by creating the specified number of 
//       buffers, inserting them into a queue, and mapping the wave bank
//       data
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitializeBufferPool( DWORD dwNumberOfBuffers, VOID* pbSampleData, DWORD dwDataLength )
{
    // Set up a default wave format
    WAVEFORMATEX wfx    = {0};
    wfx.wFormatTag      = WAVE_FORMAT_PCM;
    wfx.nChannels       = 1;
    wfx.nSamplesPerSec  = 44100;
    wfx.wBitsPerSample  = 16;
    wfx.nBlockAlign     = wfx.nChannels * wfx.wBitsPerSample / 8 ;
    wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;

    // And a default buffer description
    DSBUFFERDESC dsbd   = {0};
    dsbd.dwBufferBytes  = 0;
    dsbd.lpwfxFormat    = &wfx;

    // Allocate a block of Buffer Queue nodes
    m_pNodes = new BufferQueueNode[ dwNumberOfBuffers ];
    if( !m_pNodes )
    {
        return E_OUTOFMEMORY;
    }
    m_dwNumberOfBuffers = dwNumberOfBuffers;
    ZeroMemory( m_pNodes, m_dwNumberOfBuffers * sizeof( BufferQueueNode ) );

    // Set up the initial queue
    for( DWORD i = 0; i < m_dwNumberOfBuffers; i++ )
    {
        if( FAILED( DirectSoundCreateBuffer( &dsbd, &m_pNodes[ i ].pBuffer ) ) )
        {
            // TODO: Should clean up already-created buffers
            return E_OUTOFMEMORY;
        }
        m_pNodes[ i ].pBuffer->SetBufferData( pbSampleData, dwDataLength );
        m_pNodes[ i ].pNext = &m_pNodes[ i + 1 ];
    }

    // Set up our pointers
    m_pBufferPoolHead           = &m_pNodes[ 0 ];
    m_pBufferPoolTail           = &m_pNodes[ m_dwNumberOfBuffers - 1 ];
    m_pBufferPoolTail->pNext    = NULL;


    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: LoadWaveBank
// Desc: Loads a wave bank
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::LoadWaveBank( LPCSTR strFilename )
{
    // First, open the file
    HANDLE hWaveBank;
    hWaveBank = CreateFile( strFilename, 
                            GENERIC_READ, 
                            FILE_SHARE_READ, 
                            NULL, 
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );
    if( hWaveBank == INVALID_HANDLE_VALUE )
    {
        OUTPUT_DEBUG_STRING( "Sound bank not found!\n" );
        return XBAPPERR_MEDIANOTFOUND;
    }

    // Read the header
    WAVEBANKHEADER  header;
    DWORD           dwRead;
    if( !ReadFile( hWaveBank, &header, sizeof( WAVEBANKHEADER ), &dwRead, NULL ) )
    {
        CloseHandle( hWaveBank );
        return E_FAIL;
    }

    // Validate the signature
    if( header.dwSignature  != WAVEBANKHEADER_SIGNATURE ||
        header.dwVersion    != WAVEBANKHEADER_VERSION ||
        header.dwEntryCount != WAVEBANK_SOUNDS_ENTRY_COUNT )
    {
        CloseHandle( hWaveBank );
        return E_UNEXPECTED;
    }

    // Read the entries
    if( !ReadFile( hWaveBank, 
                   m_aWaveBankEntries, 
                   WAVEBANK_SOUNDS_ENTRY_COUNT * sizeof( WAVEBANKENTRY ),
                   &dwRead,
                   NULL ) )
    {
        CloseHandle( hWaveBank );
        return E_UNEXPECTED;
    }

    // Calculate amount of data
    DWORD dwDataBegin = SetFilePointer( hWaveBank, 0, NULL, FILE_CURRENT );
    DWORD dwTotalSize = SetFilePointer( hWaveBank, 0, NULL, FILE_END );
    DWORD dwDataLength = dwTotalSize - dwDataBegin;
    SetFilePointer( hWaveBank, dwDataBegin, NULL, FILE_BEGIN );

    // Allocate memory for the sound data
    m_pbSampleData = new BYTE[ dwDataLength ];
    if( !m_pbSampleData )
    {
        CloseHandle( hWaveBank );
        return E_OUTOFMEMORY;
    }

    // Read the sound data
    if( !ReadFile( hWaveBank, m_pbSampleData, dwDataLength, &dwRead, NULL ) )
    {
        CloseHandle( hWaveBank );
        return E_UNEXPECTED;
    }

    // Initialize a buffer pool on this wave bank
    if( FAILED( InitializeBufferPool( 64, m_pbSampleData, dwDataLength ) ) )
    {
        CloseHandle( hWaveBank );
        return E_OUTOFMEMORY;
    }

    CloseHandle( hWaveBank );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: PlaySound
// Desc: Grabs the first available buffer and plays the specified sound from
//       the wave bank on that buffer
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::PlaySound( DWORD dwIndex, BOOL fLooping )
{
    // Grab the node off the head of the queue
    BufferQueueNode* pNode = Dequeue();
    if( !pNode )
    {
        return E_PENDING;
    }

    // Add this node to the busy list
    pNode->pNext = m_pBusyBuffersHead;
    m_pBusyBuffersHead = pNode;

#if _DEBUG
    // Make sure this buffer is really available
    DWORD dwStatus;
    HRESULT hr = pNode->pBuffer->GetStatus( &dwStatus );
    assert( SUCCEEDED( hr ) && !( dwStatus & DSBSTATUS_PLAYING ) );
#endif // _DEBUG

    // We're using a XBOXADPCMWAVEFORMAT structure to guarantee we have enough
    // space for a PCM or ADPCM WAVEFORMATEX struct.  This way, we don't have
    // to make another call to find the size, allocate memory on the heap, and
    // then free it later,
    XBOXADPCMWAVEFORMAT wfx;
    CreateWaveFormatEx( &m_aWaveBankEntries[ dwIndex ].Format,
                        &wfx );
    pNode->pBuffer->SetFormat( (WAVEFORMATEX *)&wfx );

    // Set loop and play regions...
    pNode->pBuffer->SetPlayRegion( m_aWaveBankEntries[ dwIndex ].PlayRegion.dwStart,
                                   m_aWaveBankEntries[ dwIndex ].PlayRegion.dwLength );
    pNode->pBuffer->SetLoopRegion( m_aWaveBankEntries[ dwIndex ].LoopRegion.dwStart, 
                                   m_aWaveBankEntries[ dwIndex ].LoopRegion.dwLength );

    // Play the sound
    pNode->lPlayingSound = dwIndex;
    if( FAILED( pNode->pBuffer->PlayEx( 0, DSBPLAY_FROMSTART | ( fLooping ? DSBPLAY_LOOPING : 0 ) ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set up direct sound
    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    DirectSoundUseFullHRTF();

    DownloadEffectsImage( "d:\\media\\dsstdfx.bin" );

    // Load our wave bank
    if( FAILED( LoadWaveBank( "d:\\media\\sounds\\sounds.xwb" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    
    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // A to trigger the sound as a one-shot
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        PlaySound( m_dwCurrent, FALSE );
    }

    // X to loop the sound
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        PlaySound( m_dwCurrent, TRUE );
    }

    // B to stop the selected playing sound
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] &&
        m_dwSelection < m_dwPlayingBuffers )
    {
        BufferQueueNode* pNode = m_pBusyBuffersHead;
        for( DWORD i = 0; i < m_dwSelection; i++ )
            pNode = pNode->pNext;

        pNode->pBuffer->Stop();
    }

    // Walk the busy buffers list, and remove any buffer that is done
    // playing
    BufferQueueNode** ppNode;
    m_dwPlayingBuffers = 0;
    for( ppNode = &m_pBusyBuffersHead; *ppNode; )
    {
        DWORD dwStatus;
        (*ppNode)->pBuffer->GetStatus( &dwStatus );

        // If the buffer is no longer playing
        if( !( dwStatus & DSBSTATUS_PLAYING ) )
        {
            // Remove it from the list and add to the queue
            BufferQueueNode* pRemove = *ppNode;
            *ppNode = (*ppNode)->pNext;
            Enqueue( pRemove );
        }
        else
        {
            ++m_dwPlayingBuffers;
            ppNode = &(*ppNode)->pNext;
        }
    }

    m_dwAvailableBuffers = m_dwNumberOfBuffers - m_dwPlayingBuffers;

    // If our selection is off the end of the list, correct that
    if( m_dwSelection > m_dwPlayingBuffers - 1 )
        m_dwSelection = m_dwPlayingBuffers - 1;

    // Select sound
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT )
    {
        m_dwCurrent = ( m_dwCurrent + WAVEBANK_SOUNDS_ENTRY_COUNT - 1 ) % WAVEBANK_SOUNDS_ENTRY_COUNT;
    }
    else if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
    {
        m_dwCurrent = ( m_dwCurrent + 1 ) % WAVEBANK_SOUNDS_ENTRY_COUNT;
    }
    else if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
    {
        if( m_dwSelection < m_dwPlayingBuffers - 1 )
            m_dwSelection += 1;
    }
    else if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
    {
        if( m_dwSelection > 0 )
            m_dwSelection -= 1;
    }

    // If we've got a list of playing sounds, we want to manage it so that
    // we're always showing a full screen that includes our selection
    if( m_dwPlayingBuffers )
    {
        if( m_dwPlayingBuffers < DISPLAY_LENGTH )
            m_dwDisplayStart = 0;
        else if( m_dwPlayingBuffers - m_dwDisplayStart < DISPLAY_LENGTH  )
            m_dwDisplayStart = m_dwPlayingBuffers - ( DISPLAY_LENGTH  );

        // make sure the selection is always on screen
        if( m_dwSelection < m_dwDisplayStart )
            m_dwDisplayStart = m_dwSelection;
        if( m_dwSelection - m_dwDisplayStart > DISPLAY_LENGTH - 1 )
            m_dwDisplayStart = m_dwSelection - ( DISPLAY_LENGTH - 1 );
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff606060 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"WaveBank" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        WCHAR str[100];
        swprintf( str, L"%d sounds in wave bank", WAVEBANK_SOUNDS_ENTRY_COUNT );
        m_Font.DrawText( 64, 80, 0xffffff00, str );
        swprintf( str, L"%d buffers in pool (%d available)", m_dwNumberOfBuffers, m_dwAvailableBuffers );
        m_Font.DrawText( 64, 110, 0xffffff00, str );
        swprintf( str, L"Press `A' to play sound %d", m_dwCurrent );
        m_Font.DrawText( 64, 140, 0xffffffff, str );
        if( m_aWaveBankEntries[m_dwCurrent].Format.wFormatTag == WAVEBANKMINIFORMAT_TAG_PCM )
        {
            swprintf( str, L"%dkHz %dbit %s PCM",
                      m_aWaveBankEntries[m_dwCurrent].Format.nSamplesPerSec / 1000,
                      m_aWaveBankEntries[m_dwCurrent].Format.wBitsPerSample == WAVEBANKMINIFORMAT_BITDEPTH_8 ? 8: 16,
                      m_aWaveBankEntries[m_dwCurrent].Format.nChannels == 1 ? L"Mono" : L"Stereo" );
        }
        else
        {
            swprintf( str, L"%dkHz %s ADPCM",
                      m_aWaveBankEntries[m_dwCurrent].Format.nSamplesPerSec / 1000,
                      m_aWaveBankEntries[m_dwCurrent].Format.nChannels == 1 ? L"Mono" : L"Stereo" );
        }
        m_Font.DrawText( 64, 170, 0xc0c0c0c0, str );


        m_Font.End();

        // Find the first buffer to display
        BufferQueueNode* pNode = m_pBusyBuffersHead;
        for( DWORD i = 0; i < m_dwDisplayStart; i++ )
        {
            pNode = pNode->pNext;
        }

        for( DWORD i = 0; i < DISPLAY_LENGTH && m_dwDisplayStart + i < m_dwPlayingBuffers; i++ )
        {
            assert( pNode );
            DWORD dwStatus;
            pNode->pBuffer->GetStatus( &dwStatus );

            swprintf( str, L"Sound %d buffer %lx (%s)", pNode->lPlayingSound,
                                                        pNode->pBuffer,
                                                        ( dwStatus & DSBSTATUS_LOOPING ) ? 
                                                            L"Looping" : 
                                                            (dwStatus & DSBSTATUS_PLAYING ) ? L"Playing" : L"Stopped" );
            m_Font.DrawText( 64, 200.0f + 30 * i, m_dwDisplayStart + i == m_dwSelection ? 0xffffffff : 0xffffff00, str );
            pNode = pNode->pNext;
        }
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateWaveFormatEx
// Desc: Helper function to populate an XBOXADPCMWAVEFORMAT struct, based off
//       the packed wave format struct in the wave bank
//-----------------------------------------------------------------------------
VOID CreateWaveFormatEx( WAVEBANKMINIWAVEFORMAT* pmini, XBOXADPCMWAVEFORMAT* pwfx )
{
    assert( pmini && pwfx );
    ZeroMemory( pwfx, sizeof( XBOXADPCMWAVEFORMAT ) );

    // Common to both PCM and ADPCM
    pwfx->wfx.nChannels = pmini->nChannels;
    pwfx->wfx.nSamplesPerSec = pmini->nSamplesPerSec;

    // Deal with PCM/ADPCM-specific fields
    if( pmini->wFormatTag == WAVEBANKMINIFORMAT_TAG_ADPCM )
    {
        assert( pmini->wBitsPerSample == WAVEBANKMINIFORMAT_BITDEPTH_4 );

        pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;
        pwfx->wSamplesPerBlock = 64;
        pwfx->wfx.cbSize = sizeof( XBOXADPCMWAVEFORMAT ) - sizeof( WAVEFORMATEX );

        pwfx->wfx.wBitsPerSample = 4;
        pwfx->wfx.nBlockAlign = pwfx->wfx.nChannels * 36;
        pwfx->wfx.nAvgBytesPerSec = pwfx->wfx.nSamplesPerSec / pwfx->wSamplesPerBlock * pwfx->wfx.nBlockAlign;

    }
    else
    {
        pwfx->wfx.wFormatTag = WAVE_FORMAT_PCM;
        pwfx->wfx.wBitsPerSample = ( pmini->wBitsPerSample == WAVEBANKMINIFORMAT_BITDEPTH_8 ) ? 8 : 16;
        pwfx->wfx.nBlockAlign = pwfx->wfx.nChannels * pwfx->wfx.wBitsPerSample / 8;
        pwfx->wfx.nAvgBytesPerSec = pwfx->wfx.nSamplesPerSec * pwfx->wfx.nBlockAlign;
    }
}

