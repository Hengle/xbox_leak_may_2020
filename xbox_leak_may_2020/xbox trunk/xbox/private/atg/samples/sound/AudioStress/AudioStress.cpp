//-----------------------------------------------------------------------------
// File: AudioStress.cpp
//
// Desc: Demonstrates the effects of CPU and GPU load on audio playback using
//       asynchronous streaming
//
// Hist: 3.20.01 - New for April XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include "dsstdfx.h"




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Adjust CPU Load" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Adjust GPU Load" },
};

#define NUM_HELP_CALLOUTS 3

#define PACKET_CNT      3
#define PACKET_SIZE     0x2000*2
#define MAXBUFSIZE      (PACKET_SIZE*PACKET_CNT)

// This structure keeps track of our packet status, buffer data, etc.
struct MEDIA_PACKET_CTX
{
    BOOL        bDecoded;
    DWORD       dwStatus;
    DWORD       dwCompletedSize;
    BYTE*       pBuffer;
};


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    HRESULT AttachPacketToXMO( BOOL bSource, MEDIA_PACKET_CTX * pPacket );
    HRESULT ProcessPackets();
    MEDIA_PACKET_CTX * FindFreePacket();

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;

    // Load to put on CPU and GPU
    FLOAT       m_fCPUUsage;
    FLOAT       m_fGPUUsage;

    // Draw help?
    BOOL        m_bDrawHelp;

    // Vertex shader for using GPU
    DWORD       m_dwVertexShader;

    HRESULT     m_hOpenResult;

    XFileMediaObject* m_pSourceXMO;         // Source XMO - the WMA file
    XMediaObject*     m_pTargetXMO;         // Target XMO - DSound
    LPDIRECTSOUND8    m_pDSound;            // DirectSound object

    // Buffers for audio processing
    MEDIA_PACKET_CTX    m_aPacketContexts[ PACKET_CNT ];
    BYTE *              m_abBuffer;

    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP
};


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}


//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;

    m_fCPUUsage =
    m_fGPUUsage = 0.0f;
}



//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              &EffectLoc,
                                              &pDesc );
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    WAVEFORMATEX wf;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return E_FAIL;

    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;

    // Create the state shader for consuming GPU time
    if(FAILED(XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\MatInv.xvu", 
									     NULL, &m_dwVertexShader)))
	return E_FAIL;

    // Create src media object
    m_hOpenResult = WmaCreateDecoder("D:\\MEDIA\\sounds\\becky.wma",
                                     NULL,
                                     TRUE,
                                     4096*16,
                                     PACKET_CNT,
                                     0,
                                     &wf,
                                     (XFileMediaObject **)&m_pSourceXMO );

    if( FAILED(m_hOpenResult) ) 
        return S_OK;

    // Now create the target XMO, the end part of the streaming chain
    DSSTREAMDESC   dssd;
    ZeroMemory( &dssd, sizeof(dssd) );
    dssd.dwFlags              = 0;
    dssd.dwMaxAttachedPackets = PACKET_CNT;
    dssd.lpwfxFormat          = &wf;

    if( FAILED( DirectSoundCreateStream( &dssd, 
                                         (LPDIRECTSOUNDSTREAM*)&m_pTargetXMO ) ) )
        return E_FAIL;

    m_abBuffer = new BYTE[ MAXBUFSIZE ];
    ZeroMemory( m_aPacketContexts, sizeof( m_aPacketContexts ) );

    for( int i = 0; i < PACKET_CNT; i++ )
    {
        m_aPacketContexts[ i ].dwCompletedSize = PACKET_SIZE;
        m_aPacketContexts[ i ].pBuffer = &m_abBuffer[ i * PACKET_SIZE ];
        AttachPacketToXMO( TRUE, &m_aPacketContexts[ i ] );
    }

    return S_OK;
}

#define USAGE_SCALE 20.0f
// CPU_MAXTIME is 100% CPU utilization in seconds
#define CPU_MAXTIME 0.016667f * 6
// GPU_MAXTIME is 100% GPU utilization in seconds
#define GPU_MAXTIME 0.016667f * 6
//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    LARGE_INTEGER liFreq;
    FLOAT         fSecondsPerTick;
    LARGE_INTEGER liStart;
    LARGE_INTEGER liCurrent;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Update CPU and GPU usage
    m_fCPUUsage += m_DefaultGamepad.fY1 * m_fElapsedTime * USAGE_SCALE;
    if( m_fCPUUsage < 1.0f )
        m_fCPUUsage = 1.0f;
    else if( m_fCPUUsage > 100.0f )
        m_fCPUUsage = 100.0f;

    m_fGPUUsage += m_DefaultGamepad.fY2 * m_fElapsedTime * USAGE_SCALE;
    if( m_fGPUUsage < 1.0f )
        m_fGPUUsage = 1.0f;
    else if( m_fGPUUsage > 100.0f )
        m_fGPUUsage = 100.0f;

    // Set up for timing measurements
    QueryPerformanceFrequency( &liFreq );
    fSecondsPerTick = 1.0f / liFreq.QuadPart;

    m_pd3dDevice->SetVertexShader( m_dwVertexShader );

    ProcessPackets();

    // Here's where we keep the machine busy
    QueryPerformanceCounter( &liStart );
    for( ; ; )
    {
        QueryPerformanceCounter( &liCurrent );
        BOOL bUseCPU = ( liCurrent.QuadPart - liStart.QuadPart ) * fSecondsPerTick < CPU_MAXTIME * m_fCPUUsage / 100.0f;
        BOOL bUseGPU = ( liCurrent.QuadPart - liStart.QuadPart ) * fSecondsPerTick < GPU_MAXTIME * m_fGPUUsage / 100.0f;

        // If we don't need to use either CPU or GPU, break out
        if( !bUseCPU && !bUseGPU )
            break;

        // If we should be using the GPU and we're not already running the shader, do so
        if( bUseGPU && !m_pd3dDevice->IsBusy() )
            m_pd3dDevice->RunVertexStateShader( 0, NULL );

        // If we should NOT be using the CPU, yield.  Otherwise, we'll
        // continue in a tight loop, which will burn the CPU
        if( !bUseCPU )
            Sleep( 5 );
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    DirectSoundDoWork();

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    m_Font.DrawText( 100, 150, 0xFFFF0000, L"CPU:");
    m_Font.DrawText( 100, 250, 0xFF0000FF, L"GPU:");

    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );

    // Draw the CPU Usage bar
    {
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX v[4];
        FLOAT x1 = 200, x2 = x1 + (340*m_fCPUUsage)/100;
        FLOAT y1 = 150, y2 = y1 + 20;
        v[0].p = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = 0xffffffff;
        v[1].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = 0xffffffff;
        v[2].p = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = 0xffff0000;
        v[3].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = 0xffff0000;

        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
    }

    // Draw the GPU Usage bar
    {
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX v[4];
        FLOAT x1 = 200, x2 = x1 + (340*m_fGPUUsage)/100;
        FLOAT y1 = 250, y2 = y1 + 20;
        v[0].p = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = 0xffffffff;
        v[1].p = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = 0xffffffff;
        v[2].p = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = 0xff0000ff;
        v[3].p = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = 0xff0000ff;

        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
    }


    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
		m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"AudioStress" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: AttachPacketToXMO
// Desc: Attaches the packet to either the source or target XMO.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::AttachPacketToXMO( BOOL bSource, MEDIA_PACKET_CTX * pPacket )
{
    XMEDIAPACKET xmb;

    pPacket->dwStatus = XMEDIAPACKET_STATUS_PENDING;

    ZeroMemory( &xmb, sizeof( XMEDIAPACKET ) );
    xmb.pvBuffer            = pPacket->pBuffer;
    xmb.dwMaxSize           = pPacket->dwCompletedSize;
    xmb.pdwCompletedSize    = &pPacket->dwCompletedSize;
    xmb.pdwStatus           = &pPacket->dwStatus;

    if( bSource )
    {
        if( FAILED( m_pSourceXMO->Process( NULL, &xmb ) ) )
            return E_FAIL;
    }
    else
    {
        if( FAILED( m_pTargetXMO->Process( &xmb, NULL ) ) )
            return E_FAIL;
    }        

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FindFreePacket
// Desc: Finds the first free packet and returns it
//-----------------------------------------------------------------------------
MEDIA_PACKET_CTX * CXBoxSample::FindFreePacket()
{
    for( int i = 0; i < PACKET_CNT; i++ )
    {
        if( m_aPacketContexts[ i ].dwStatus == XMEDIAPACKET_STATUS_SUCCESS )
            return &m_aPacketContexts[ i ];
    }

    return NULL;
}



//-----------------------------------------------------------------------------
// Name: ProcessPackets
// Desc: Grabs all available packets and sends them to the appropriate
//       XMO - Source if they haven't been decoded yet, Target if they have.
//       Also checks for end of source buffer and resets the source XMO
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::ProcessPackets()
{
    MEDIA_PACKET_CTX * pPacket;

    while( pPacket = FindFreePacket() )
    {
        // If we didn't get enough from the source, adjust size and flush
        if( !pPacket->bDecoded && pPacket->dwCompletedSize < PACKET_SIZE )
        {
            m_pSourceXMO->Flush();
            if( pPacket->dwCompletedSize < 4 )
                pPacket->dwCompletedSize = 4;
        }

        pPacket->dwStatus = XMEDIAPACKET_STATUS_PENDING;
        pPacket->dwCompletedSize = PACKET_SIZE;
        pPacket->bDecoded = !pPacket->bDecoded;

        if( FAILED( AttachPacketToXMO( !pPacket->bDecoded, pPacket ) ) )
            return E_FAIL;
    }

    return S_OK;
}
