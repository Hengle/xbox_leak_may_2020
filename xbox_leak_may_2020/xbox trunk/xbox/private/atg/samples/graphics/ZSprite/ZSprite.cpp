//-----------------------------------------------------------------------------
// File: ZSprite.cpp
//
// Desc: Demonstrates how to create and render a ZSprite.  The ZSprite is 
//       generated by rendering a model into 2 textures.  The first texture
//       contains the color data, and the second contains the depth information
//       It is then rendered with a pixel shader using the Dot_ZW texture 
//       address mode to recreate the z values.
//
// Hist: 2.28.01 - New for April XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>
#include <xgraphics.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Dump depth buffer" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move camera" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 4




//-----------------------------------------------------------------------------
// Externals and globals
//-----------------------------------------------------------------------------
#define ZTEX_WIDTH  1024
#define ZTEX_HEIGHT  512


struct CUSTOMVERTEX
{
    D3DXVECTOR4 p;
    FLOAT       tu, tv;       // Texture 0 - this is the actual texture
};

#define FVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_TEX1)


struct PLANEVERTEX
{
    D3DXVECTOR3 p;
    D3DCOLOR    c;
};

#define FVF_PLANEVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)


// List of positions for our models
D3DXVECTOR3 g_vTeapotPositions[] = 
{
    D3DXVECTOR3( 1.0f, 0.0f,-2.0f ),
    D3DXVECTOR3(-1.0f, 0.0f, 0.0f ),
    D3DXVECTOR3(-2.0f, 0.0f,-1.5f ),
    D3DXVECTOR3( 3.0f, 0.0f, 2.0f ),
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont     m_Font;                 // Font for text display
    CXBHelp     m_Help;                 // Help object
    BOOL        m_bDrawHelp;            // Should we draw help?

    CXBMesh     m_Mesh;                 // Mesh for teapot model

    BOOL        m_bDrawPlane;           // Draw an intersection plane to show z
    D3DXVECTOR3 m_vViewAngle;           // View angle of camera

    DWORD       m_dwPixelShader;        // Pixel shader handle
    DWORD       m_dwVertexShader;       // Vertex shader handle

    LPDIRECT3DVERTEXBUFFER8 m_pZSpriteVB; // Vertex buffer for ZSprite quad
    LPDIRECT3DTEXTURE8 m_pImageTexture;   // Texture for image data
    LPDIRECT3DTEXTURE8 m_pZTexture;       // Texture for depth data
    LPDIRECT3DSURFACE8 m_pZSpriteRenderTarget;
    LPDIRECT3DSURFACE8 m_pZSpriteDepthBuffer;

    LPDIRECT3DVERTEXBUFFER8 m_pPlaneVB;   // Plane to show z values

    VOID    SetViewTransform();         // Sets the view transform
    HRESULT InitPixelShader();          // Initialize and create pixel shader
    HRESULT InitVertexShader();         // Initialize and create vertex shader
    HRESULT RenderToZTexture();         // Render a scene into the ZSprite
    HRESULT RenderZSprite();            // Renders the ZSprite on a quad
    HRESULT DumpDepthBuffer( const CHAR* strFileName ); // Dump depth buffer to TGA

public:
    HRESULT Initialize();       // Initialize the sample
    HRESULT Render();           // Render the scene
    HRESULT FrameMove();        // Perform per-frame updates

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp  = FALSE;
    m_bDrawPlane = TRUE;
}




//-----------------------------------------------------------------------------
// Name: InitPixelShader
// Desc: Sets up our hard-coded pixel shader
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitPixelShader()
{
    D3DPIXELSHADERDEF psd;

    ZeroMemory( &psd, sizeof( D3DPIXELSHADERDEF ) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 1, 0 );
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D,  // Real texture
                                           PS_TEXTUREMODES_PROJECT2D,  // ZW texture
                                           PS_TEXTUREMODES_DOTPRODUCT, // (s0, t0, r0).(z, w, 1)
                                           PS_TEXTUREMODES_DOT_ZW );   // (s1, t1, r1).(z, w, 1)
    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 1, 1 );
    psd.PSDotMapping    = PS_DOTMAPPING( 0,
                                         0,
                                         PS_DOTMAPPING_HILO_1,
                                         PS_DOTMAPPING_HILO_1 );
    psd.PSCompareMode   = PS_COMPAREMODE( 
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT );

    //--------------------------
    // Stage 0 
    //--------------------------

    // A=T0.rgb, B=V0, C=0, D=0 (so that AB.rgb = T0*V0 and CD = 0 )
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS(
        PS_REGISTER_T0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_V0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );
    
    // A=T0.a, B=1, C=0, D=0 (so that AB.a = T0.a and CD = 0 )
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS(
        PS_REGISTER_T0   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY );
    
    // R0.rgb = AB
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    
    // R0.a = AB
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    
    psd.PSConstant0[0]    = 0x00000000;
    psd.PSConstant1[0]    = 0x00000000;

    //--------------------------
    // Final combiner
    //--------------------------
    psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

    // E = 0, F = 0, G = 1. (From above, EF is not used. G is alpha and is set to R0.a.)
    psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        0 | 0 | 0 );
    psd.PSC0Mapping = 0x00000000;
    psd.PSC1Mapping = 0x00000000;

    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwPixelShader ) ) )
    {
        OUTPUT_DEBUG_STRING( "Couldn't create pixel shader.\n" );
        return E_FAIL;
    }

    return S_OK;
}





//-----------------------------------------------------------------------------
// Name: InitVertexShader
// Desc: Initializes and creates our vertex shader.  Also sets up vertex
//       shader constants that don't change:
//       * texture coordinates for stages 2 and 3
//       * diffuse color
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitVertexShader()
{
    // Setup the vertex declaration
    DWORD dwDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT4 ), // v0 = Position
        D3DVSD_REG( 7, D3DVSDT_FLOAT2 ), // v7 = Texcoords
        D3DVSD_END()
    };

    // Create the vertex shader
    XBUtil_CreateVertexShader( m_pd3dDevice, "shaders\\zsprite.xvu", dwDecl, &m_dwVertexShader );
    
    // Set vertex shader constants
    D3DXVECTOR3 v4( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 v5( 0.0f, 0.0f, 1.0f/FLOAT(D3DZ_MAX_D24S8) );
    D3DXVECTOR3 v6( 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetVertexShaderConstant( 4, &v4, 1 );
    m_pd3dDevice->SetVertexShaderConstant( 5, &v5, 1 );
    m_pd3dDevice->SetVertexShaderConstant( 6, &v6, 1 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load our geometry
    if( FAILED( m_Mesh.Create( m_pd3dDevice, "Models\\Teapot.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a quad for our ZSprite
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof(CUSTOMVERTEX), D3DUSAGE_WRITEONLY, 
                                      FVF_CUSTOMVERTEX, D3DPOOL_MANAGED, &m_pZSpriteVB );
    CUSTOMVERTEX* pVertices;
    m_pZSpriteVB->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR4( -1.0f,  -1.0f, 0.5f, 1.0f ); 
    pVertices[0].tu = 0.0f; pVertices[0].tv = 1.0f;
    pVertices[1].p = D3DXVECTOR4( -1.0f,   1.0f, 0.5f, 1.0f ); 
    pVertices[1].tu = 0.0f; pVertices[1].tv = 0.0f;
    pVertices[2].p = D3DXVECTOR4(  1.0f,  -1.0f, 0.5f, 1.0f ); 
    pVertices[2].tu = 1.0f; pVertices[2].tv = 1.0f;
    pVertices[3].p = D3DXVECTOR4(  1.0f,   1.0f, 0.5f, 1.0f ); 
    pVertices[3].tu = 1.0f; pVertices[3].tv = 0.0f;
    m_pZSpriteVB->Unlock();

    // Create a quad for our intersecting plane
    m_pd3dDevice->CreateVertexBuffer( 4*sizeof(PLANEVERTEX), D3DUSAGE_WRITEONLY, 
                                      FVF_PLANEVERTEX, D3DPOOL_MANAGED, &m_pPlaneVB );
    PLANEVERTEX* pPV;
    m_pPlaneVB->Lock( 0, 0, (BYTE **)&pPV, 0 );
    pPV[0].p = D3DXVECTOR3( -5.0f,  -1.0f, 0.0f );  pPV[0].c = 0xFFFFFFFF;
    pPV[1].p = D3DXVECTOR3( -5.0f,   1.0f, 0.0f );  pPV[1].c = 0xFFFFFFFF;
    pPV[2].p = D3DXVECTOR3(  5.0f,  -1.0f, 0.0f );  pPV[2].c = 0xFFFFFFFF;
    pPV[3].p = D3DXVECTOR3(  5.0f,   1.0f, 0.0f );  pPV[3].c = 0xFFFFFFFF;
    m_pPlaneVB->Unlock();

    // Create a texture to render into
    if( FAILED( m_pd3dDevice->CreateTexture( ZTEX_WIDTH, ZTEX_HEIGHT, 1, 
                                             D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, 
                                             D3DPOOL_MANAGED, &m_pImageTexture ) ) )
        return E_FAIL;

    // Create our depth map
    if( FAILED( m_pd3dDevice->CreateTexture( ZTEX_WIDTH, ZTEX_HEIGHT, 1, 
                                             D3DUSAGE_DEPTHSTENCIL, D3DFMT_A8R8G8B8, 
                                             D3DPOOL_MANAGED, &m_pZTexture ) ) )
        return E_FAIL;

    // Get the surfaces to render into the above textures
    m_pImageTexture->GetSurfaceLevel( 0, &m_pZSpriteRenderTarget );
    m_pZTexture->GetSurfaceLevel( 0, &m_pZSpriteDepthBuffer );

    // Pretend our depth map is actually a Depth/Stencil surface
    m_pZSpriteDepthBuffer->Format &= ~D3DFORMAT_FORMAT_MASK;
    m_pZSpriteDepthBuffer->Format |= (D3DFMT_LIN_D24S8 << D3DFORMAT_FORMAT_SHIFT);

    // Set up our Shaders
    if( FAILED( InitVertexShader() ) )
        return E_FAIL;
    if( FAILED( InitPixelShader() ) )
        return E_FAIL;

    m_vViewAngle = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );

    // World transform is just identity
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set the view transform based on view angle
    SetViewTransform();

    // Projection transform
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/3, 4.0f/3.0f, 2.0f, 15.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Create a light for rendering to the texture and depth map
    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof( D3DLIGHT8 ) );
    light.Type = D3DLIGHT_DIRECTIONAL;
    light.Diffuse.r = light.Diffuse.g = light.Diffuse.b = light.Diffuse.a = 0.9f;
    light.Direction = D3DXVECTOR3( -0.5f, -1.0f, 1.0f );
    m_pd3dDevice->SetLight( 0, &light );

    if( FAILED( RenderToZTexture() ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderToZTexture
// Desc: Renders some stuff for our Z Texture.  Actually renders the object
//       into a depth/stencil surface and a texture.  Texture becomes the image
//       and the depth/stencil surface will get converted to a Z texture
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderToZTexture()
{
    // Save old state
    D3DXMATRIX matWorldSave;
    m_pd3dDevice->GetTransform( D3DTS_WORLD, &matWorldSave );

    // Render the scene into our depth and image surfaces
    m_pd3dDevice->SetRenderTarget( m_pZSpriteRenderTarget, m_pZSpriteDepthBuffer );
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L );

    // Set up our render state
    m_pd3dDevice->LightEnable( 0, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );

    // Render each teapot
    for( DWORD i = 0; i < 4; i++ )
    {
        D3DXMATRIX matWorld;
        D3DXMatrixTranslation( &matWorld, g_vTeapotPositions[i].x, 
                                          g_vTeapotPositions[i].y, 
                                          g_vTeapotPositions[i].z );
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );
        m_Mesh.Render( m_pd3dDevice );
    }

    // Restore state
    m_pd3dDevice->SetRenderTarget( m_pBackBuffer, m_pDepthBuffer );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorldSave );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetViewTransform
// Desc: Sets the view transform based on the view angle
//-----------------------------------------------------------------------------
VOID CXBoxSample::SetViewTransform()
{
    D3DXMATRIX matView;
    D3DXMATRIX m;
    D3DXVECTOR3 vEyePos;
    D3DXVECTOR3 vCameraPos( 0.0f, 0.0f, -8.0f );
    D3DXVECTOR3 vLookAt( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f);

    // Create a rotation matrix for our view angle
    D3DXMatrixRotationYawPitchRoll(&m, m_vViewAngle.y, m_vViewAngle.x, m_vViewAngle.z);

    // Transform our camera position (on the Z axis)
    D3DXVec3TransformCoord(&vEyePos, &vCameraPos, &m);
    
    // Use that eye position and look at the origin
    D3DXMatrixLookAtLH(&matView, &vEyePos, &vLookAt, &vUp);

    m_pd3dDevice->SetTransform(D3DTS_VIEW, &matView);
}




//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DXVECTOR3 vViewAngleOld = m_vViewAngle;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
        m_bDrawHelp = !m_bDrawHelp;

    // Dump the zbuffer surface to a .tga image file
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
        DumpDepthBuffer( "d:\\ZBuffer.tga" );

    // Move the camera based off the gamepad
    m_vViewAngle.y -= m_DefaultGamepad.fX1*1.0f*m_fElapsedTime;
    if( m_vViewAngle.y > D3DX_PI*2 )
        m_vViewAngle.y -= D3DX_PI*2;
    if( m_vViewAngle.y < 0.0f)
        m_vViewAngle.y += D3DX_PI*2;

    m_vViewAngle.x += m_DefaultGamepad.fY1*1.0f*m_fElapsedTime;
    if( m_vViewAngle.x > 1.0f )
        m_vViewAngle.x = 1.0f;
    if( m_vViewAngle.x < -1.0f )
        m_vViewAngle.x = -1.0f;

    // If the view changed, re-render the scene into the zsprite
    if( vViewAngleOld != m_vViewAngle )
    {
        SetViewTransform();

        if( FAILED( RenderToZTexture() ) )
            return E_FAIL;
    }

    // Move the plane back and forth
    PLANEVERTEX* pPV;
    FLOAT fZ      = FLOAT( cosf( m_fAppTime ) ) * 3.0f;
    FLOAT fColor  = fZ / 6.0f + 0.5f;
    DWORD dwColor = DWORD(fColor * 255);
    m_pPlaneVB->Lock( 0, 0, (BYTE **)&pPV, 0 );
    pPV[0].p.z = fZ; pPV[0].c = D3DCOLOR_ARGB( 255, dwColor, dwColor, dwColor );
    pPV[1].p.z = fZ; pPV[1].c = D3DCOLOR_ARGB( 255, dwColor, dwColor, dwColor );
    pPV[2].p.z = fZ; pPV[2].c = D3DCOLOR_ARGB( 255, dwColor, dwColor, dwColor );
    pPV[3].p.z = fZ; pPV[3].c = D3DCOLOR_ARGB( 255, dwColor, dwColor, dwColor );
    m_pPlaneVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderZSprite
// Desc: Handles the rendering of the ZSprite
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderZSprite()
{
    // Set up our source & textures for the ZSprite
    // Note that which textures we specify for stages
    // 2 and 3 doesn't matter - but our texture coordinates
    // won't make it through to the pixel shader unless
    // there's SOMETHING specified.

    m_pd3dDevice->SetTexture( 0, m_pImageTexture );
    m_pd3dDevice->SetTexture( 1, m_pZTexture );
    m_pd3dDevice->SetTexture( 2, NULL );
    m_pd3dDevice->SetTexture( 3, m_pImageTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pZSpriteVB, sizeof( CUSTOMVERTEX ) );

    m_pd3dDevice->SetVertexShader( m_dwVertexShader );
    m_pd3dDevice->SetPixelShader( m_dwPixelShader );

    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );

    // Draw the ZSprite
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    m_pd3dDevice->SetPixelShader( NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Set our render state
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );

    RenderZSprite();
    
    if( m_bDrawPlane )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE );
        m_pd3dDevice->SetVertexShader( FVF_PLANEVERTEX );
        m_pd3dDevice->SetStreamSource( 0, m_pPlaneVB, sizeof( PLANEVERTEX ) );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"ZSprite" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DumpZSurface
// Desc: Grabs the depth/stencil surface, and dumps the depth values to a 
//       targa file.  Only the most significant 8 bits of depth are used, and
//       are replicated to the RGB channels.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DumpDepthBuffer( const CHAR* strFileName )
{
    // Get the surface description. Make sure it's linear D24S8
    D3DSURFACE_DESC desc;
    m_pDepthBuffer->GetDesc( &desc );
    if( desc.Format != D3DFMT_LIN_D24S8 )
    {
        OUTPUT_DEBUG_STRING( "Can only dump linear D24S8\n" );
        return E_NOTIMPL;
    }

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
        return E_FAIL;

    // Write the Targa header to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );

    // Lock the surface
    D3DLOCKED_RECT lock;
    m_pDepthBuffer->LockRect( &lock, 0, 0 );

    // Copy the entire depth buffer at once, so we don't have to 
    // read individual DWORDS, which would be very slow.
    DWORD* pBits = new DWORD[ desc.Width * desc.Height ];
    memcpy( pBits, lock.pBits, desc.Width * desc.Height * sizeof( DWORD ) );

    for( UINT j = 0; j < desc.Height; j++ )
    {
        for( UINT i = 0; i < desc.Width; i++ )
        {
            // Take the most significant byte of depth, and replicate it to 
            // the RGB channels.  As Z goes from 0.0 to 1.0, the color will
            // go from black to white
            DWORD dwVal = pBits[ j * desc.Width + i ] >> 24;

            // Grab the most significant BYTE and propagate to RGB
            pBits[ j * desc.Width + i ] = dwVal | ( dwVal << 8 ) | ( dwVal << 16 );
        }
    }

    fwrite( pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );
    delete[] pBits;

    // Cleanup and return
    m_pDepthBuffer->UnlockRect();

    return S_OK;
}



