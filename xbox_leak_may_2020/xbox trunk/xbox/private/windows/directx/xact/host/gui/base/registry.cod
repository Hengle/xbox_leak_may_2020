; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	c:\xbox\private\windows\directx\xact\host\gui\base\registry.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DPKL@?$CIunknown?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06NPGC@?$CInone?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MKNO@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@GKFF@?$CBm_dwRefCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GLPL@m_dwRefCount?5?$DM?5?$HO0UL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BGIF@m_dwRefCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@CGCA@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BEIE@this?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@GMNP@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EA@GLLN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@KBLK@REG_DWORD?5?$DN?$DN?5dwType?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@JLII@sizeof?$CI?$CKpnValue?$CJ?5?$DN?$DN?5dwSize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FFPH@REG_SZ?5?$DN?$DN?5dwType?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@EPOG@nLength?5?$DO?$DN?5dwSize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@CLMH@REG_BINARY?5?$DN?$DN?5dwType?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@OAKL@nSize?5?$DN?$DN?5dwSize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02MHMJ@?$CFu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07CPEI@?$CG?$CFlu?7?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@BLHJ@?91?5?$CB?$DN?5m_nCommandId?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05EAGJ@TCHAR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertHeadList@@YGXPAU_LIST_ENTRY@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCRefCount@DirectSound@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRefCount@DirectSound@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CRefCount@DirectSound@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CRefCount@DirectSound@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataOffset@CRiffChunk@WaveLoader@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCRegistryKey@@UAEPAUHKEY__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCRegistry@@UAEPAUHKEY__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRegistryKey@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCRegistryKey@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRegistryKey@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Open@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Close@CRegistryKey@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNumericValue@CRegistryKey@@UAEHPBDPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNumericValue@CRegistryKey@@UAEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringValue@CRegistryKey@@UAEHPBDPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStringValue@CRegistryKey@@UAEHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBinaryValue@CRegistryKey@@UAEHPBDPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBinaryValue@CRegistryKey@@UAEHPBDPBXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRegistry@@QAE@PAUHKEY__@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCRegistry@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRegistry@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNumericValue@CRegistry@@UAEHPBD0PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNumericValue@CRegistry@@UAEHPBD0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringValue@CRegistry@@UAEHPBD0PADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStringValue@CRegistry@@UAEHPBD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBinaryValue@CRegistry@@UAEHPBD0PAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBinaryValue@CRegistry@@UAEHPBD0PBXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMRU@@QAE@PAUHKEY__@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMRU@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMRU@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@CMRU@@MAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Save@CMRU@@MAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddItem@CMRU@@UAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateMenu@CMRU@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TranslateCommand@CMRU@@UAEPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AttachMenu@CMRU@@UAEXPAUHMENU__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItems@CMRU@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CRegistry@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CRegistryKey@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CRefCount@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMRU@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	??0CRegistryKey@@QAE@XZ				; CRegistryKey::CRegistryKey
PUBLIC	?Create@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z	; CRegistryKey::Create
PUBLIC	?Open@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z	; CRegistryKey::Open
PUBLIC	?Close@CRegistryKey@@UAEXXZ			; CRegistryKey::Close
PUBLIC	?GetNumericValue@CRegistryKey@@UAEHPBDPAH@Z	; CRegistryKey::GetNumericValue
PUBLIC	?SetNumericValue@CRegistryKey@@UAEHPBDH@Z	; CRegistryKey::SetNumericValue
PUBLIC	?GetStringValue@CRegistryKey@@UAEHPBDPADI@Z	; CRegistryKey::GetStringValue
PUBLIC	?SetStringValue@CRegistryKey@@UAEHPBD0@Z	; CRegistryKey::SetStringValue
PUBLIC	?GetBinaryValue@CRegistryKey@@UAEHPBDPAXI@Z	; CRegistryKey::GetBinaryValue
PUBLIC	?SetBinaryValue@CRegistryKey@@UAEHPBDPBXI@Z	; CRegistryKey::SetBinaryValue
PUBLIC	??BCRegistryKey@@UAEPAUHKEY__@@XZ		; CRegistryKey::operator HKEY__ *
PUBLIC	??_7CRegistryKey@@6B@				; CRegistryKey::`vftable'
PUBLIC	??_GCRegistryKey@@UAEPAXI@Z			; CRegistryKey::`scalar deleting destructor'
PUBLIC	??_ECRegistryKey@@UAEPAXI@Z			; CRegistryKey::`vector deleting destructor'
;	COMDAT ??_7CRegistryKey@@6B@
; File c:\xbox\private\windows\directx\xact\host\gui\base\registry.cpp
CONST	SEGMENT
??_7CRegistryKey@@6B@ DD FLAT:??_ECRegistryKey@@UAEPAXI@Z ; CRegistryKey::`vftable'
	DD	FLAT:?Create@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z
	DD	FLAT:?Open@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z
	DD	FLAT:?Close@CRegistryKey@@UAEXXZ
	DD	FLAT:?GetNumericValue@CRegistryKey@@UAEHPBDPAH@Z
	DD	FLAT:?SetNumericValue@CRegistryKey@@UAEHPBDH@Z
	DD	FLAT:?GetStringValue@CRegistryKey@@UAEHPBDPADI@Z
	DD	FLAT:?SetStringValue@CRegistryKey@@UAEHPBD0@Z
	DD	FLAT:?GetBinaryValue@CRegistryKey@@UAEHPBDPAXI@Z
	DD	FLAT:?SetBinaryValue@CRegistryKey@@UAEHPBDPBXI@Z
	DD	FLAT:??BCRegistryKey@@UAEPAUHKEY__@@XZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CRegistryKey@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CRegistryKey@@QAE@XZ PROC NEAR			; CRegistryKey::CRegistryKey, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CRegistryKey@@6B@ ; CRegistryKey::`vftable'

; 40   :     m_hKey = NULL;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 41   : }

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0CRegistryKey@@QAE@XZ ENDP				; CRegistryKey::CRegistryKey
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\xact\host\gui\base\registry.h
_TEXT	ENDS
;	COMDAT ??BCRegistryKey@@UAEPAUHKEY__@@XZ
_TEXT	SEGMENT
_this$ = -4
??BCRegistryKey@@UAEPAUHKEY__@@XZ PROC NEAR		; CRegistryKey::operator HKEY__ *, COMDAT
; _this$ = ecx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 55   :     return m_hKey;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 56   : }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??BCRegistryKey@@UAEPAUHKEY__@@XZ ENDP			; CRegistryKey::operator HKEY__ *
_TEXT	ENDS
PUBLIC	??1CRegistryKey@@UAE@XZ				; CRegistryKey::~CRegistryKey
; Function compile flags: /Odt
;	COMDAT ??_GCRegistryKey@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCRegistryKey@@UAEPAXI@Z PROC NEAR			; CRegistryKey::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L49638
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L49638:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCRegistryKey@@UAEPAXI@Z ENDP			; CRegistryKey::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z:NEAR ; DirectSound::CMemoryManager::TrackingPoolFree
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\memmgr.h
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 244  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  :     DirectSound::CMemoryManager::TrackingMemFree(pvBuffer); 

  00003	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPoolFree

; 246  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\xact\host\gui\base\registry.cpp
_TEXT	ENDS
;	COMDAT ??1CRegistryKey@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CRegistryKey@@UAE@XZ PROC NEAR			; CRegistryKey::~CRegistryKey, COMDAT
; _this$ = ecx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CRegistryKey@@6B@ ; CRegistryKey::`vftable'

; 64   :     Close();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?Close@CRegistryKey@@UAEXXZ ; CRegistryKey::Close

; 65   : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CRegistryKey@@UAE@XZ ENDP				; CRegistryKey::~CRegistryKey
_TEXT	ENDS
EXTRN	__imp__RegCreateKeyA@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?Create@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z
_TEXT	SEGMENT
_hParentKey$ = 8
_pszKeyName$ = 12
_this$ = -4
?Create@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z PROC NEAR	; CRegistryKey::Create, COMDAT
; _this$ = ecx

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :     Close();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 10		 mov	 edx, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 52 0c	 call	 DWORD PTR [edx+12]

; 95   :     
; 96   :     return !RegCreateKey(hParentKey, pszKeyName, &m_hKey);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _pszKeyName$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR _hParentKey$[ebp]
  00020	52		 push	 edx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyA@12
  00027	f7 d8		 neg	 eax
  00029	1b c0		 sbb	 eax, eax
  0002b	40		 inc	 eax

; 97   : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
?Create@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z ENDP		; CRegistryKey::Create
_TEXT	ENDS
EXTRN	__imp__RegOpenKeyA@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?Open@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z
_TEXT	SEGMENT
_hParentKey$ = 8
_pszKeyName$ = 12
_this$ = -4
?Open@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z PROC NEAR	; CRegistryKey::Open, COMDAT
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 126  :     Close();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 10		 mov	 edx, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 52 0c	 call	 DWORD PTR [edx+12]

; 127  :     
; 128  :     return !RegOpenKey(hParentKey, pszKeyName, &m_hKey);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _pszKeyName$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR _hParentKey$[ebp]
  00020	52		 push	 edx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyA@12
  00027	f7 d8		 neg	 eax
  00029	1b c0		 sbb	 eax, eax
  0002b	40		 inc	 eax

; 129  : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
?Open@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z ENDP		; CRegistryKey::Open
_TEXT	ENDS
EXTRN	__imp__RegCloseKey@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Close@CRegistryKey@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Close@CRegistryKey@@UAEXXZ PROC NEAR			; CRegistryKey::Close, COMDAT
; _this$ = ecx

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 156  :     if(m_hKey)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 17		 je	 SHORT $L49657

; 157  :     {
; 158  :         RegCloseKey(m_hKey);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 159  :         m_hKey = NULL;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L49657:

; 160  :     }
; 161  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?Close@CRegistryKey@@UAEXXZ ENDP			; CRegistryKey::Close
_TEXT	ENDS
PUBLIC	??_C@_0EA@GLLN@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BE@KBLK@REG_DWORD?5?$DN?$DN?5dwType?$AA@	; `string'
PUBLIC	??_C@_0BL@JLII@sizeof?$CI?$CKpnValue?$CJ?5?$DN?$DN?5dwSize?$AA@ ; `string'
EXTRN	__imp__RegQueryValueExA@24:NEAR
EXTRN	?Assert@CDebug@DirectSound@@SAXHPBD0I@Z:NEAR	; DirectSound::CDebug::Assert
;	COMDAT ??_C@_0EA@GLLN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0EA@GLLN@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\privat'
	DB	'e\windows\directx\xact\host\gui\base\registry.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KBLK@REG_DWORD?5?$DN?$DN?5dwType?$AA@
CONST	SEGMENT
??_C@_0BE@KBLK@REG_DWORD?5?$DN?$DN?5dwType?$AA@ DB 'REG_DWORD == dwType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JLII@sizeof?$CI?$CKpnValue?$CJ?5?$DN?$DN?5dwSize?$AA@
CONST	SEGMENT
??_C@_0BL@JLII@sizeof?$CI?$CKpnValue?$CJ?5?$DN?$DN?5dwSize?$AA@ DB 'sizeo'
	DB	'f(*pnValue) == dwSize', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetNumericValue@CRegistryKey@@UAEHPBDPAH@Z
_TEXT	SEGMENT
_pszValueName$ = 8
_pnValue$ = 12
_this$ = -12
_dwType$ = -4
_dwSize$ = -8
?GetNumericValue@CRegistryKey@@UAEHPBDPAH@Z PROC NEAR	; CRegistryKey::GetNumericValue, COMDAT
; _this$ = ecx

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 190  :     DWORD                   dwType  = REG_DWORD;

  00009	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR _dwType$[ebp], 4

; 191  :     DWORD                   dwSize  = sizeof(*pnValue);

  00010	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _dwSize$[ebp], 4

; 192  :     
; 193  :     if(RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, (LPBYTE)pnValue, &dwSize))

  00017	8d 45 f8	 lea	 eax, DWORD PTR _dwSize$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _pnValue$[ebp]
  0001e	51		 push	 ecx
  0001f	8d 55 fc	 lea	 edx, DWORD PTR _dwType$[ebp]
  00022	52		 push	 edx
  00023	6a 00		 push	 0
  00025	8b 45 08	 mov	 eax, DWORD PTR _pszValueName$[ebp]
  00028	50		 push	 eax
  00029	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002f	52		 push	 edx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00036	85 c0		 test	 eax, eax
  00038	74 04		 je	 SHORT $L49666

; 194  :     {
; 195  :         return FALSE;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 47		 jmp	 SHORT $L49662
$L49666:

; 196  :     }
; 197  : 
; 198  :     ASSERT(REG_DWORD == dwType);

  0003e	68 c6 00 00 00	 push	 198			; 000000c6H
  00043	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@GLLN@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00048	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@KBLK@REG_DWORD?5?$DN?$DN?5dwType?$AA@ ; `string'
  0004d	33 c0		 xor	 eax, eax
  0004f	83 7d fc 04	 cmp	 DWORD PTR _dwType$[ebp], 4
  00053	0f 95 c0	 setne	 al
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0005c	83 c4 10	 add	 esp, 16			; 00000010H

; 199  :     ASSERT(sizeof(*pnValue) == dwSize);

  0005f	68 c7 00 00 00	 push	 199			; 000000c7H
  00064	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@GLLN@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00069	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@JLII@sizeof?$CI?$CKpnValue?$CJ?5?$DN?$DN?5dwSize?$AA@ ; `string'
  0006e	33 c9		 xor	 ecx, ecx
  00070	83 7d f8 04	 cmp	 DWORD PTR _dwSize$[ebp], 4
  00074	0f 95 c1	 setne	 cl
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0007d	83 c4 10	 add	 esp, 16			; 00000010H

; 200  : 
; 201  :     return TRUE;

  00080	b8 01 00 00 00	 mov	 eax, 1
$L49662:

; 202  : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
?GetNumericValue@CRegistryKey@@UAEHPBDPAH@Z ENDP	; CRegistryKey::GetNumericValue
_TEXT	ENDS
EXTRN	__imp__RegSetValueExA@24:NEAR
; Function compile flags: /Odt
;	COMDAT ?SetNumericValue@CRegistryKey@@UAEHPBDH@Z
_TEXT	SEGMENT
_pszValueName$ = 8
_nValue$ = 12
_this$ = -4
?SetNumericValue@CRegistryKey@@UAEHPBDH@Z PROC NEAR	; CRegistryKey::SetNumericValue, COMDAT
; _this$ = ecx

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 231  :     return !RegSetValueEx(m_hKey, pszValueName, NULL, REG_DWORD, (const BYTE *)&nValue, sizeof(nValue));

  00007	6a 04		 push	 4
  00009	8d 45 0c	 lea	 eax, DWORD PTR _nValue$[ebp]
  0000c	50		 push	 eax
  0000d	6a 04		 push	 4
  0000f	6a 00		 push	 0
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _pszValueName$[ebp]
  00014	51		 push	 ecx
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00022	f7 d8		 neg	 eax
  00024	1b c0		 sbb	 eax, eax
  00026	40		 inc	 eax

; 232  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
?SetNumericValue@CRegistryKey@@UAEHPBDH@Z ENDP		; CRegistryKey::SetNumericValue
_TEXT	ENDS
PUBLIC	??_C@_0BB@FFPH@REG_SZ?5?$DN?$DN?5dwType?$AA@	; `string'
PUBLIC	??_C@_0BC@EPOG@nLength?5?$DO?$DN?5dwSize?$AA@	; `string'
;	COMDAT ??_C@_0BB@FFPH@REG_SZ?5?$DN?$DN?5dwType?$AA@
CONST	SEGMENT
??_C@_0BB@FFPH@REG_SZ?5?$DN?$DN?5dwType?$AA@ DB 'REG_SZ == dwType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EPOG@nLength?5?$DO?$DN?5dwSize?$AA@
CONST	SEGMENT
??_C@_0BC@EPOG@nLength?5?$DO?$DN?5dwSize?$AA@ DB 'nLength >= dwSize', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetStringValue@CRegistryKey@@UAEHPBDPADI@Z
_TEXT	SEGMENT
_pszValueName$ = 8
_pszValue$ = 12
_nLength$ = 16
_this$ = -12
_dwType$ = -4
_dwSize$ = -8
?GetStringValue@CRegistryKey@@UAEHPBDPADI@Z PROC NEAR	; CRegistryKey::GetStringValue, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 263  :     DWORD                   dwType  = REG_SZ;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _dwType$[ebp], 1

; 264  :     DWORD                   dwSize  = nLength * sizeof(TCHAR);

  00010	8b 45 10	 mov	 eax, DWORD PTR _nLength$[ebp]
  00013	89 45 f8	 mov	 DWORD PTR _dwSize$[ebp], eax

; 265  :     
; 266  :     if(RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, (LPBYTE)pszValue, &dwSize))

  00016	8d 4d f8	 lea	 ecx, DWORD PTR _dwSize$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 0c	 mov	 edx, DWORD PTR _pszValue$[ebp]
  0001d	52		 push	 edx
  0001e	8d 45 fc	 lea	 eax, DWORD PTR _dwType$[ebp]
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _pszValueName$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002e	50		 push	 eax
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00035	85 c0		 test	 eax, eax
  00037	74 04		 je	 SHORT $L49686

; 267  :     {
; 268  :         return FALSE;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 52		 jmp	 SHORT $L49681
$L49686:

; 269  :     }
; 270  : 
; 271  :     ASSERT(REG_SZ == dwType);

  0003d	68 0f 01 00 00	 push	 271			; 0000010fH
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@GLLN@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@FFPH@REG_SZ?5?$DN?$DN?5dwType?$AA@ ; `string'
  0004c	33 c9		 xor	 ecx, ecx
  0004e	83 7d fc 01	 cmp	 DWORD PTR _dwType$[ebp], 1
  00052	0f 95 c1	 setne	 cl
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0005b	83 c4 10	 add	 esp, 16			; 00000010H

; 272  :     ASSERT(nLength >= dwSize);

  0005e	68 10 01 00 00	 push	 272			; 00000110H
  00063	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@GLLN@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00068	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@EPOG@nLength?5?$DO?$DN?5dwSize?$AA@ ; `string'
  0006d	8b 55 10	 mov	 edx, DWORD PTR _nLength$[ebp]
  00070	3b 55 f8	 cmp	 edx, DWORD PTR _dwSize$[ebp]
  00073	1b c0		 sbb	 eax, eax
  00075	f7 d8		 neg	 eax
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0007d	83 c4 10	 add	 esp, 16			; 00000010H

; 273  : 
; 274  :     pszValue[nLength - 1] = 0;

  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _pszValue$[ebp]
  00083	03 4d 10	 add	 ecx, DWORD PTR _nLength$[ebp]
  00086	c6 41 ff 00	 mov	 BYTE PTR [ecx-1], 0

; 275  : 
; 276  :     return TRUE;

  0008a	b8 01 00 00 00	 mov	 eax, 1
$L49681:

; 277  : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 0c 00	 ret	 12			; 0000000cH
?GetStringValue@CRegistryKey@@UAEHPBDPADI@Z ENDP	; CRegistryKey::GetStringValue
_TEXT	ENDS
EXTRN	_strlen:NEAR
; Function compile flags: /Odt
;	COMDAT ?SetStringValue@CRegistryKey@@UAEHPBD0@Z
_TEXT	SEGMENT
_pszValueName$ = 8
_pszValue$ = 12
_this$ = -8
_nLength$ = -4
?SetStringValue@CRegistryKey@@UAEHPBD0@Z PROC NEAR	; CRegistryKey::SetStringValue, COMDAT
; _this$ = ecx

; 305  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 306  :     const int               nLength = _tcslen(pszValue) + 1;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _pszValue$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	83 c4 04	 add	 esp, 4
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _nLength$[ebp], eax

; 307  :     
; 308  :     return !RegSetValueEx(m_hKey, pszValueName, NULL, REG_SZ, (const BYTE *)pszValue, nLength * sizeof(TCHAR));

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _nLength$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 0c	 mov	 edx, DWORD PTR _pszValue$[ebp]
  00022	52		 push	 edx
  00023	6a 01		 push	 1
  00025	6a 00		 push	 0
  00027	8b 45 08	 mov	 eax, DWORD PTR _pszValueName$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00031	52		 push	 edx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00038	f7 d8		 neg	 eax
  0003a	1b c0		 sbb	 eax, eax
  0003c	40		 inc	 eax

; 309  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?SetStringValue@CRegistryKey@@UAEHPBD0@Z ENDP		; CRegistryKey::SetStringValue
_TEXT	ENDS
PUBLIC	??_C@_0BF@CLMH@REG_BINARY?5?$DN?$DN?5dwType?$AA@ ; `string'
PUBLIC	??_C@_0BA@OAKL@nSize?5?$DN?$DN?5dwSize?$AA@	; `string'
;	COMDAT ??_C@_0BF@CLMH@REG_BINARY?5?$DN?$DN?5dwType?$AA@
CONST	SEGMENT
??_C@_0BF@CLMH@REG_BINARY?5?$DN?$DN?5dwType?$AA@ DB 'REG_BINARY == dwType'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OAKL@nSize?5?$DN?$DN?5dwSize?$AA@
CONST	SEGMENT
??_C@_0BA@OAKL@nSize?5?$DN?$DN?5dwSize?$AA@ DB 'nSize == dwSize', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetBinaryValue@CRegistryKey@@UAEHPBDPAXI@Z
_TEXT	SEGMENT
_pszValueName$ = 8
_pvValue$ = 12
_nSize$ = 16
_this$ = -12
_dwType$ = -4
_dwSize$ = -8
?GetBinaryValue@CRegistryKey@@UAEHPBDPAXI@Z PROC NEAR	; CRegistryKey::GetBinaryValue, COMDAT
; _this$ = ecx

; 339  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 340  :     DWORD                   dwType  = REG_BINARY;

  00009	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _dwType$[ebp], 3

; 341  :     DWORD                   dwSize  = nSize;

  00010	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  00013	89 45 f8	 mov	 DWORD PTR _dwSize$[ebp], eax

; 342  :     
; 343  :     if(RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, (BYTE *)pvValue, &dwSize))

  00016	8d 4d f8	 lea	 ecx, DWORD PTR _dwSize$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 0c	 mov	 edx, DWORD PTR _pvValue$[ebp]
  0001d	52		 push	 edx
  0001e	8d 45 fc	 lea	 eax, DWORD PTR _dwType$[ebp]
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _pszValueName$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002e	50		 push	 eax
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00035	85 c0		 test	 eax, eax
  00037	74 04		 je	 SHORT $L49706

; 344  :     {
; 345  :         return FALSE;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 49		 jmp	 SHORT $L49702
$L49706:

; 346  :     }
; 347  : 
; 348  :     ASSERT(REG_BINARY == dwType);

  0003d	68 5c 01 00 00	 push	 348			; 0000015cH
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@GLLN@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@CLMH@REG_BINARY?5?$DN?$DN?5dwType?$AA@ ; `string'
  0004c	33 c9		 xor	 ecx, ecx
  0004e	83 7d fc 03	 cmp	 DWORD PTR _dwType$[ebp], 3
  00052	0f 95 c1	 setne	 cl
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0005b	83 c4 10	 add	 esp, 16			; 00000010H

; 349  :     ASSERT(nSize == dwSize);

  0005e	68 5d 01 00 00	 push	 349			; 0000015dH
  00063	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@GLLN@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00068	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@OAKL@nSize?5?$DN?$DN?5dwSize?$AA@ ; `string'
  0006d	8b 55 10	 mov	 edx, DWORD PTR _nSize$[ebp]
  00070	33 c0		 xor	 eax, eax
  00072	3b 55 f8	 cmp	 edx, DWORD PTR _dwSize$[ebp]
  00075	0f 95 c0	 setne	 al
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0007e	83 c4 10	 add	 esp, 16			; 00000010H

; 350  : 
; 351  :     return TRUE;

  00081	b8 01 00 00 00	 mov	 eax, 1
$L49702:

; 352  : }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 0c 00	 ret	 12			; 0000000cH
?GetBinaryValue@CRegistryKey@@UAEHPBDPAXI@Z ENDP	; CRegistryKey::GetBinaryValue
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetBinaryValue@CRegistryKey@@UAEHPBDPBXI@Z
_TEXT	SEGMENT
_pszValueName$ = 8
_pvValue$ = 12
_nSize$ = 16
_this$ = -4
?SetBinaryValue@CRegistryKey@@UAEHPBDPBXI@Z PROC NEAR	; CRegistryKey::SetBinaryValue, COMDAT
; _this$ = ecx

; 382  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 383  :     return !RegSetValueEx(m_hKey, pszValueName, NULL, REG_BINARY, (const BYTE *)pvValue, nSize);

  00007	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _pvValue$[ebp]
  0000e	51		 push	 ecx
  0000f	6a 03		 push	 3
  00011	6a 00		 push	 0
  00013	8b 55 08	 mov	 edx, DWORD PTR _pszValueName$[ebp]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	51		 push	 ecx
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00024	f7 d8		 neg	 eax
  00026	1b c0		 sbb	 eax, eax
  00028	40		 inc	 eax

; 384  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 0c 00	 ret	 12			; 0000000cH
?SetBinaryValue@CRegistryKey@@UAEHPBDPBXI@Z ENDP	; CRegistryKey::SetBinaryValue
_TEXT	ENDS
PUBLIC	??0CRegistry@@QAE@PAUHKEY__@@PBD@Z		; CRegistry::CRegistry
PUBLIC	?GetNumericValue@CRegistry@@UAEHPBD0PAH@Z	; CRegistry::GetNumericValue
PUBLIC	?SetNumericValue@CRegistry@@UAEHPBD0H@Z		; CRegistry::SetNumericValue
PUBLIC	?GetStringValue@CRegistry@@UAEHPBD0PADI@Z	; CRegistry::GetStringValue
PUBLIC	?SetStringValue@CRegistry@@UAEHPBD00@Z		; CRegistry::SetStringValue
PUBLIC	?GetBinaryValue@CRegistry@@UAEHPBD0PAXI@Z	; CRegistry::GetBinaryValue
PUBLIC	?SetBinaryValue@CRegistry@@UAEHPBD0PBXI@Z	; CRegistry::SetBinaryValue
PUBLIC	??BCRegistry@@UAEPAUHKEY__@@XZ			; CRegistry::operator HKEY__ *
PUBLIC	??_7CRegistry@@6B@				; CRegistry::`vftable'
PUBLIC	??_GCRegistry@@UAEPAXI@Z			; CRegistry::`scalar deleting destructor'
PUBLIC	??_ECRegistry@@UAEPAXI@Z			; CRegistry::`vector deleting destructor'
;	COMDAT ??_7CRegistry@@6B@
CONST	SEGMENT
??_7CRegistry@@6B@ DD FLAT:??_ECRegistry@@UAEPAXI@Z	; CRegistry::`vftable'
	DD	FLAT:?GetNumericValue@CRegistry@@UAEHPBD0PAH@Z
	DD	FLAT:?SetNumericValue@CRegistry@@UAEHPBD0H@Z
	DD	FLAT:?GetStringValue@CRegistry@@UAEHPBD0PADI@Z
	DD	FLAT:?SetStringValue@CRegistry@@UAEHPBD00@Z
	DD	FLAT:?GetBinaryValue@CRegistry@@UAEHPBD0PAXI@Z
	DD	FLAT:?SetBinaryValue@CRegistry@@UAEHPBD0PBXI@Z
	DD	FLAT:??BCRegistry@@UAEPAUHKEY__@@XZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CRegistry@@QAE@PAUHKEY__@@PBD@Z
_TEXT	SEGMENT
_hRootKey$ = 8
_pszAppPath$ = 12
_this$ = -4
??0CRegistry@@QAE@PAUHKEY__@@PBD@Z PROC NEAR		; CRegistry::CRegistry, COMDAT
; _this$ = ecx

; 411  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ??0CRegistryKey@@QAE@XZ	; CRegistryKey::CRegistryKey
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CRegistry@@6B@ ; CRegistry::`vftable'

; 412  :     m_AppKey.Create(hRootKey, pszAppPath);

  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _pszAppPath$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR _hRootKey$[ebp]
  00022	52		 push	 edx
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 04	 add	 ecx, 4
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002f	ff 52 04	 call	 DWORD PTR [edx+4]

; 413  : }    

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??0CRegistry@@QAE@PAUHKEY__@@PBD@Z ENDP			; CRegistry::CRegistry
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\xact\host\gui\base\registry.h
_TEXT	ENDS
;	COMDAT ??BCRegistry@@UAEPAUHKEY__@@XZ
_TEXT	SEGMENT
_this$ = -4
??BCRegistry@@UAEPAUHKEY__@@XZ PROC NEAR		; CRegistry::operator HKEY__ *, COMDAT
; _this$ = ecx

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 88   :     return m_AppKey;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00013	ff 52 28	 call	 DWORD PTR [edx+40]

; 89   : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??BCRegistry@@UAEPAUHKEY__@@XZ ENDP			; CRegistry::operator HKEY__ *
_TEXT	ENDS
PUBLIC	??1CRegistry@@UAE@XZ				; CRegistry::~CRegistry
; Function compile flags: /Odt
;	COMDAT ??_GCRegistry@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCRegistry@@UAEPAXI@Z PROC NEAR			; CRegistry::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CRegistry@@UAE@XZ	; CRegistry::~CRegistry
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L49724
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L49724:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCRegistry@@UAEPAXI@Z ENDP				; CRegistry::`scalar deleting destructor'
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\xact\host\gui\base\registry.cpp
_TEXT	ENDS
;	COMDAT ??1CRegistry@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CRegistry@@UAE@XZ PROC NEAR				; CRegistry::~CRegistry, COMDAT
; _this$ = ecx

; 438  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CRegistry@@6B@ ; CRegistry::`vftable'

; 439  : }

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 04	 add	 ecx, 4
  00016	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??1CRegistry@@UAE@XZ ENDP				; CRegistry::~CRegistry
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetNumericValue@CRegistry@@UAEHPBD0PAH@Z
_TEXT	SEGMENT
$T50107 = -12
$T50108 = -16
_pszKeyName$ = 8
_pszValueName$ = 12
_pnValue$ = 16
_this$ = -20
_Key$49736 = -8
?GetNumericValue@CRegistry@@UAEHPBD0PAH@Z PROC NEAR	; CRegistry::GetNumericValue, COMDAT
; _this$ = ecx

; 469  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 470  :     if(pszKeyName)

  00009	83 7d 08 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  0000d	74 5c		 je	 SHORT $L49735

; 471  :     {
; 472  :         CRegistryKey Key;

  0000f	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49736[ebp]
  00012	e8 00 00 00 00	 call	 ??0CRegistryKey@@QAE@XZ	; CRegistryKey::CRegistryKey

; 473  : 
; 474  :         if(!Key.Open(m_AppKey, pszKeyName))

  00017	8b 45 08	 mov	 eax, DWORD PTR _pszKeyName$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
  00021	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	ff 50 28	 call	 DWORD PTR [eax+40]
  0002a	50		 push	 eax
  0002b	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49736[ebp]
  0002e	e8 00 00 00 00	 call	 ?Open@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z ; CRegistryKey::Open
  00033	85 c0		 test	 eax, eax
  00035	75 14		 jne	 SHORT $L49737

; 475  :         {
; 476  :             return FALSE;

  00037	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T50107[ebp], 0
  0003e	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49736[ebp]
  00041	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  00046	8b 45 f4	 mov	 eax, DWORD PTR $T50107[ebp]
  00049	eb 37		 jmp	 SHORT $L49734
$L49737:

; 477  :         }
; 478  : 
; 479  :         return Key.GetNumericValue(pszValueName, pnValue);

  0004b	8b 4d 10	 mov	 ecx, DWORD PTR _pnValue$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 55 0c	 mov	 edx, DWORD PTR _pszValueName$[ebp]
  00052	52		 push	 edx
  00053	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49736[ebp]
  00056	e8 00 00 00 00	 call	 ?GetNumericValue@CRegistryKey@@UAEHPBDPAH@Z ; CRegistryKey::GetNumericValue
  0005b	89 45 f0	 mov	 DWORD PTR $T50108[ebp], eax
  0005e	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49736[ebp]
  00061	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  00066	8b 45 f0	 mov	 eax, DWORD PTR $T50108[ebp]
  00069	eb 17		 jmp	 SHORT $L49734
$L49735:

; 480  :     }
; 481  :     else
; 482  :     {
; 483  :         return m_AppKey.GetNumericValue(pszValueName, pnValue);

  0006b	8b 45 10	 mov	 eax, DWORD PTR _pnValue$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d 0c	 mov	 ecx, DWORD PTR _pszValueName$[ebp]
  00072	51		 push	 ecx
  00073	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	83 c1 04	 add	 ecx, 4
  00079	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007f	ff 50 10	 call	 DWORD PTR [eax+16]
$L49734:

; 484  :     }
; 485  : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 0c 00	 ret	 12			; 0000000cH
?GetNumericValue@CRegistry@@UAEHPBD0PAH@Z ENDP		; CRegistry::GetNumericValue
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetNumericValue@CRegistry@@UAEHPBD0H@Z
_TEXT	SEGMENT
$T50112 = -12
$T50113 = -16
_pszKeyName$ = 8
_pszValueName$ = 12
_nValue$ = 16
_this$ = -20
_Key$49748 = -8
?SetNumericValue@CRegistry@@UAEHPBD0H@Z PROC NEAR	; CRegistry::SetNumericValue, COMDAT
; _this$ = ecx

; 515  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 516  :     if(pszKeyName)

  00009	83 7d 08 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  0000d	74 5c		 je	 SHORT $L49747

; 517  :     {
; 518  :         CRegistryKey Key;

  0000f	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49748[ebp]
  00012	e8 00 00 00 00	 call	 ??0CRegistryKey@@QAE@XZ	; CRegistryKey::CRegistryKey

; 519  : 
; 520  :         if(!Key.Create(m_AppKey, pszKeyName))

  00017	8b 45 08	 mov	 eax, DWORD PTR _pszKeyName$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
  00021	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	ff 50 28	 call	 DWORD PTR [eax+40]
  0002a	50		 push	 eax
  0002b	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49748[ebp]
  0002e	e8 00 00 00 00	 call	 ?Create@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z ; CRegistryKey::Create
  00033	85 c0		 test	 eax, eax
  00035	75 14		 jne	 SHORT $L49749

; 521  :         {
; 522  :             return FALSE;

  00037	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T50112[ebp], 0
  0003e	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49748[ebp]
  00041	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  00046	8b 45 f4	 mov	 eax, DWORD PTR $T50112[ebp]
  00049	eb 37		 jmp	 SHORT $L49746
$L49749:

; 523  :         }
; 524  : 
; 525  :         return Key.SetNumericValue(pszValueName, nValue);

  0004b	8b 4d 10	 mov	 ecx, DWORD PTR _nValue$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 55 0c	 mov	 edx, DWORD PTR _pszValueName$[ebp]
  00052	52		 push	 edx
  00053	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49748[ebp]
  00056	e8 00 00 00 00	 call	 ?SetNumericValue@CRegistryKey@@UAEHPBDH@Z ; CRegistryKey::SetNumericValue
  0005b	89 45 f0	 mov	 DWORD PTR $T50113[ebp], eax
  0005e	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49748[ebp]
  00061	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  00066	8b 45 f0	 mov	 eax, DWORD PTR $T50113[ebp]
  00069	eb 17		 jmp	 SHORT $L49746
$L49747:

; 526  :     }
; 527  :     else
; 528  :     {
; 529  :         return m_AppKey.SetNumericValue(pszValueName, nValue);

  0006b	8b 45 10	 mov	 eax, DWORD PTR _nValue$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d 0c	 mov	 ecx, DWORD PTR _pszValueName$[ebp]
  00072	51		 push	 ecx
  00073	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	83 c1 04	 add	 ecx, 4
  00079	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007f	ff 50 14	 call	 DWORD PTR [eax+20]
$L49746:

; 530  :     }
; 531  : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 0c 00	 ret	 12			; 0000000cH
?SetNumericValue@CRegistry@@UAEHPBD0H@Z ENDP		; CRegistry::SetNumericValue
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetStringValue@CRegistry@@UAEHPBD0PADI@Z
_TEXT	SEGMENT
$T50117 = -12
$T50118 = -16
_pszKeyName$ = 8
_pszValueName$ = 12
_pszValue$ = 16
_nLength$ = 20
_this$ = -20
_Key$49761 = -8
?GetStringValue@CRegistry@@UAEHPBD0PADI@Z PROC NEAR	; CRegistry::GetStringValue, COMDAT
; _this$ = ecx

; 563  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 564  :     if(pszKeyName)

  00009	83 7d 08 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  0000d	74 60		 je	 SHORT $L49760

; 565  :     {
; 566  :         CRegistryKey Key;

  0000f	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49761[ebp]
  00012	e8 00 00 00 00	 call	 ??0CRegistryKey@@QAE@XZ	; CRegistryKey::CRegistryKey

; 567  : 
; 568  :         if(!Key.Open(m_AppKey, pszKeyName))

  00017	8b 45 08	 mov	 eax, DWORD PTR _pszKeyName$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
  00021	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	ff 50 28	 call	 DWORD PTR [eax+40]
  0002a	50		 push	 eax
  0002b	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49761[ebp]
  0002e	e8 00 00 00 00	 call	 ?Open@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z ; CRegistryKey::Open
  00033	85 c0		 test	 eax, eax
  00035	75 14		 jne	 SHORT $L49762

; 569  :         {
; 570  :             return FALSE;

  00037	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T50117[ebp], 0
  0003e	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49761[ebp]
  00041	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  00046	8b 45 f4	 mov	 eax, DWORD PTR $T50117[ebp]
  00049	eb 3f		 jmp	 SHORT $L49759
$L49762:

; 571  :         }
; 572  : 
; 573  :         return Key.GetStringValue(pszValueName, pszValue, nLength);

  0004b	8b 4d 14	 mov	 ecx, DWORD PTR _nLength$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 55 10	 mov	 edx, DWORD PTR _pszValue$[ebp]
  00052	52		 push	 edx
  00053	8b 45 0c	 mov	 eax, DWORD PTR _pszValueName$[ebp]
  00056	50		 push	 eax
  00057	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49761[ebp]
  0005a	e8 00 00 00 00	 call	 ?GetStringValue@CRegistryKey@@UAEHPBDPADI@Z ; CRegistryKey::GetStringValue
  0005f	89 45 f0	 mov	 DWORD PTR $T50118[ebp], eax
  00062	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49761[ebp]
  00065	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  0006a	8b 45 f0	 mov	 eax, DWORD PTR $T50118[ebp]
  0006d	eb 1b		 jmp	 SHORT $L49759
$L49760:

; 574  :     }
; 575  :     else
; 576  :     {
; 577  :         return m_AppKey.GetStringValue(pszValueName, pszValue, nLength);

  0006f	8b 4d 14	 mov	 ecx, DWORD PTR _nLength$[ebp]
  00072	51		 push	 ecx
  00073	8b 55 10	 mov	 edx, DWORD PTR _pszValue$[ebp]
  00076	52		 push	 edx
  00077	8b 45 0c	 mov	 eax, DWORD PTR _pszValueName$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	83 c1 04	 add	 ecx, 4
  00081	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00084	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00087	ff 50 18	 call	 DWORD PTR [eax+24]
$L49759:

; 578  :     }
; 579  : }

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 10 00	 ret	 16			; 00000010H
?GetStringValue@CRegistry@@UAEHPBD0PADI@Z ENDP		; CRegistry::GetStringValue
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetStringValue@CRegistry@@UAEHPBD00@Z
_TEXT	SEGMENT
$T50122 = -12
$T50123 = -16
_pszKeyName$ = 8
_pszValueName$ = 12
_pszValue$ = 16
_this$ = -20
_Key$49773 = -8
?SetStringValue@CRegistry@@UAEHPBD00@Z PROC NEAR	; CRegistry::SetStringValue, COMDAT
; _this$ = ecx

; 609  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 610  :     if(pszKeyName)

  00009	83 7d 08 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  0000d	74 5c		 je	 SHORT $L49772

; 611  :     {
; 612  :         CRegistryKey Key;

  0000f	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49773[ebp]
  00012	e8 00 00 00 00	 call	 ??0CRegistryKey@@QAE@XZ	; CRegistryKey::CRegistryKey

; 613  : 
; 614  :         if(!Key.Create(m_AppKey, pszKeyName))

  00017	8b 45 08	 mov	 eax, DWORD PTR _pszKeyName$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
  00021	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	ff 50 28	 call	 DWORD PTR [eax+40]
  0002a	50		 push	 eax
  0002b	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49773[ebp]
  0002e	e8 00 00 00 00	 call	 ?Create@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z ; CRegistryKey::Create
  00033	85 c0		 test	 eax, eax
  00035	75 14		 jne	 SHORT $L49774

; 615  :         {
; 616  :             return FALSE;

  00037	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T50122[ebp], 0
  0003e	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49773[ebp]
  00041	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  00046	8b 45 f4	 mov	 eax, DWORD PTR $T50122[ebp]
  00049	eb 37		 jmp	 SHORT $L49771
$L49774:

; 617  :         }
; 618  : 
; 619  :         return Key.SetStringValue(pszValueName, pszValue);

  0004b	8b 4d 10	 mov	 ecx, DWORD PTR _pszValue$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 55 0c	 mov	 edx, DWORD PTR _pszValueName$[ebp]
  00052	52		 push	 edx
  00053	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49773[ebp]
  00056	e8 00 00 00 00	 call	 ?SetStringValue@CRegistryKey@@UAEHPBD0@Z ; CRegistryKey::SetStringValue
  0005b	89 45 f0	 mov	 DWORD PTR $T50123[ebp], eax
  0005e	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49773[ebp]
  00061	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  00066	8b 45 f0	 mov	 eax, DWORD PTR $T50123[ebp]
  00069	eb 17		 jmp	 SHORT $L49771
$L49772:

; 620  :     }
; 621  :     else
; 622  :     {
; 623  :         return m_AppKey.SetStringValue(pszValueName, pszValue);

  0006b	8b 45 10	 mov	 eax, DWORD PTR _pszValue$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d 0c	 mov	 ecx, DWORD PTR _pszValueName$[ebp]
  00072	51		 push	 ecx
  00073	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	83 c1 04	 add	 ecx, 4
  00079	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007f	ff 50 1c	 call	 DWORD PTR [eax+28]
$L49771:

; 624  :     }
; 625  : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 0c 00	 ret	 12			; 0000000cH
?SetStringValue@CRegistry@@UAEHPBD00@Z ENDP		; CRegistry::SetStringValue
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetBinaryValue@CRegistry@@UAEHPBD0PAXI@Z
_TEXT	SEGMENT
_Key$49786 = -8
$T50127 = -12
$T50128 = -16
_pszKeyName$ = 8
_pszValueName$ = 12
_pvValue$ = 16
_nSize$ = 20
_this$ = -20
?GetBinaryValue@CRegistry@@UAEHPBD0PAXI@Z PROC NEAR	; CRegistry::GetBinaryValue, COMDAT
; _this$ = ecx

; 657  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 658  :     if(pszKeyName)

  00009	83 7d 08 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  0000d	74 60		 je	 SHORT $L49785

; 659  :     {
; 660  :         CRegistryKey Key;

  0000f	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49786[ebp]
  00012	e8 00 00 00 00	 call	 ??0CRegistryKey@@QAE@XZ	; CRegistryKey::CRegistryKey

; 661  : 
; 662  :         if(!Key.Open(m_AppKey, pszKeyName))

  00017	8b 45 08	 mov	 eax, DWORD PTR _pszKeyName$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
  00021	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	ff 50 28	 call	 DWORD PTR [eax+40]
  0002a	50		 push	 eax
  0002b	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49786[ebp]
  0002e	e8 00 00 00 00	 call	 ?Open@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z ; CRegistryKey::Open
  00033	85 c0		 test	 eax, eax
  00035	75 14		 jne	 SHORT $L49787

; 663  :         {
; 664  :             return FALSE;

  00037	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T50127[ebp], 0
  0003e	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49786[ebp]
  00041	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  00046	8b 45 f4	 mov	 eax, DWORD PTR $T50127[ebp]
  00049	eb 3f		 jmp	 SHORT $L49784
$L49787:

; 665  :         }
; 666  : 
; 667  :         return Key.GetBinaryValue(pszValueName, pvValue, nSize);

  0004b	8b 4d 14	 mov	 ecx, DWORD PTR _nSize$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 55 10	 mov	 edx, DWORD PTR _pvValue$[ebp]
  00052	52		 push	 edx
  00053	8b 45 0c	 mov	 eax, DWORD PTR _pszValueName$[ebp]
  00056	50		 push	 eax
  00057	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49786[ebp]
  0005a	e8 00 00 00 00	 call	 ?GetBinaryValue@CRegistryKey@@UAEHPBDPAXI@Z ; CRegistryKey::GetBinaryValue
  0005f	89 45 f0	 mov	 DWORD PTR $T50128[ebp], eax
  00062	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49786[ebp]
  00065	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  0006a	8b 45 f0	 mov	 eax, DWORD PTR $T50128[ebp]
  0006d	eb 1b		 jmp	 SHORT $L49784
$L49785:

; 668  :     }
; 669  :     else
; 670  :     {
; 671  :         return m_AppKey.GetBinaryValue(pszValueName, pvValue, nSize);

  0006f	8b 4d 14	 mov	 ecx, DWORD PTR _nSize$[ebp]
  00072	51		 push	 ecx
  00073	8b 55 10	 mov	 edx, DWORD PTR _pvValue$[ebp]
  00076	52		 push	 edx
  00077	8b 45 0c	 mov	 eax, DWORD PTR _pszValueName$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	83 c1 04	 add	 ecx, 4
  00081	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00084	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00087	ff 50 20	 call	 DWORD PTR [eax+32]
$L49784:

; 672  :     }
; 673  : }

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 10 00	 ret	 16			; 00000010H
?GetBinaryValue@CRegistry@@UAEHPBD0PAXI@Z ENDP		; CRegistry::GetBinaryValue
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetBinaryValue@CRegistry@@UAEHPBD0PBXI@Z
_TEXT	SEGMENT
_pszKeyName$ = 8
_pszValueName$ = 12
_pvValue$ = 16
_nSize$ = 20
_this$ = -20
_Key$49799 = -8
$T50132 = -12
$T50133 = -16
?SetBinaryValue@CRegistry@@UAEHPBD0PBXI@Z PROC NEAR	; CRegistry::SetBinaryValue, COMDAT
; _this$ = ecx

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 706  :     if(pszKeyName)

  00009	83 7d 08 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  0000d	74 60		 je	 SHORT $L49798

; 707  :     {
; 708  :         CRegistryKey Key;

  0000f	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49799[ebp]
  00012	e8 00 00 00 00	 call	 ??0CRegistryKey@@QAE@XZ	; CRegistryKey::CRegistryKey

; 709  : 
; 710  :         if(!Key.Create(m_AppKey, pszKeyName))

  00017	8b 45 08	 mov	 eax, DWORD PTR _pszKeyName$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
  00021	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	ff 50 28	 call	 DWORD PTR [eax+40]
  0002a	50		 push	 eax
  0002b	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49799[ebp]
  0002e	e8 00 00 00 00	 call	 ?Create@CRegistryKey@@UAEHPAUHKEY__@@PBD@Z ; CRegistryKey::Create
  00033	85 c0		 test	 eax, eax
  00035	75 14		 jne	 SHORT $L49800

; 711  :         {
; 712  :             return FALSE;

  00037	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T50132[ebp], 0
  0003e	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49799[ebp]
  00041	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  00046	8b 45 f4	 mov	 eax, DWORD PTR $T50132[ebp]
  00049	eb 3f		 jmp	 SHORT $L49797
$L49800:

; 713  :         }
; 714  : 
; 715  :         return Key.SetBinaryValue(pszValueName, pvValue, nSize);

  0004b	8b 4d 14	 mov	 ecx, DWORD PTR _nSize$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 55 10	 mov	 edx, DWORD PTR _pvValue$[ebp]
  00052	52		 push	 edx
  00053	8b 45 0c	 mov	 eax, DWORD PTR _pszValueName$[ebp]
  00056	50		 push	 eax
  00057	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49799[ebp]
  0005a	e8 00 00 00 00	 call	 ?SetBinaryValue@CRegistryKey@@UAEHPBDPBXI@Z ; CRegistryKey::SetBinaryValue
  0005f	89 45 f0	 mov	 DWORD PTR $T50133[ebp], eax
  00062	8d 4d f8	 lea	 ecx, DWORD PTR _Key$49799[ebp]
  00065	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  0006a	8b 45 f0	 mov	 eax, DWORD PTR $T50133[ebp]
  0006d	eb 1b		 jmp	 SHORT $L49797
$L49798:

; 716  :     }
; 717  :     else
; 718  :     {
; 719  :         return m_AppKey.SetBinaryValue(pszValueName, pvValue, nSize);

  0006f	8b 4d 14	 mov	 ecx, DWORD PTR _nSize$[ebp]
  00072	51		 push	 ecx
  00073	8b 55 10	 mov	 edx, DWORD PTR _pvValue$[ebp]
  00076	52		 push	 edx
  00077	8b 45 0c	 mov	 eax, DWORD PTR _pszValueName$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	83 c1 04	 add	 ecx, 4
  00081	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00084	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00087	ff 50 24	 call	 DWORD PTR [eax+36]
$L49797:

; 720  :     }
; 721  : }

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 10 00	 ret	 16			; 00000010H
?SetBinaryValue@CRegistry@@UAEHPBD0PBXI@Z ENDP		; CRegistry::SetBinaryValue
_TEXT	ENDS
PUBLIC	??0CMRU@@QAE@PAUHKEY__@@PBD@Z			; CMRU::CMRU
PUBLIC	?AttachMenu@CMRU@@UAEXPAUHMENU__@@@Z		; CMRU::AttachMenu
PUBLIC	?UpdateMenu@CMRU@@UAEXXZ			; CMRU::UpdateMenu
PUBLIC	?AddItem@CMRU@@UAEXPBDH@Z			; CMRU::AddItem
PUBLIC	?GetItems@CMRU@@UAEPADXZ			; CMRU::GetItems
PUBLIC	?TranslateCommand@CMRU@@UAEPBDI@Z		; CMRU::TranslateCommand
PUBLIC	?Load@CMRU@@MAEXXZ				; CMRU::Load
PUBLIC	?Save@CMRU@@MAEXXZ				; CMRU::Save
PUBLIC	??_7CMRU@@6B@					; CMRU::`vftable'
PUBLIC	??_GCMRU@@UAEPAXI@Z				; CMRU::`scalar deleting destructor'
PUBLIC	??_ECMRU@@UAEPAXI@Z				; CMRU::`vector deleting destructor'
;	COMDAT ??_7CMRU@@6B@
CONST	SEGMENT
??_7CMRU@@6B@ DD FLAT:??_ECMRU@@UAEPAXI@Z		; CMRU::`vftable'
	DD	FLAT:?AttachMenu@CMRU@@UAEXPAUHMENU__@@@Z
	DD	FLAT:?UpdateMenu@CMRU@@UAEXXZ
	DD	FLAT:?AddItem@CMRU@@UAEXPBDH@Z
	DD	FLAT:?GetItems@CMRU@@UAEPADXZ
	DD	FLAT:?TranslateCommand@CMRU@@UAEPBDI@Z
	DD	FLAT:?Load@CMRU@@MAEXXZ
	DD	FLAT:?Save@CMRU@@MAEXXZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CMRU@@QAE@PAUHKEY__@@PBD@Z
_TEXT	SEGMENT
_hParentKey$ = 8
_pszKeyName$ = 12
_this$ = -4
??0CMRU@@QAE@PAUHKEY__@@PBD@Z PROC NEAR			; CMRU::CMRU, COMDAT
; _this$ = ecx

; 747  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ??0CRegistryKey@@QAE@XZ	; CRegistryKey::CRegistryKey
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMRU@@6B@ ; CMRU::`vftable'

; 748  :     m_Key.Create(hParentKey, pszKeyName);

  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _pszKeyName$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR _hParentKey$[ebp]
  00022	52		 push	 edx
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 04	 add	 ecx, 4
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002f	ff 52 04	 call	 DWORD PTR [edx+4]

; 749  : 
; 750  :     Load();

  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?Load@CMRU@@MAEXXZ	; CMRU::Load

; 751  : }

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
??0CMRU@@QAE@PAUHKEY__@@PBD@Z ENDP			; CMRU::CMRU
_TEXT	ENDS
PUBLIC	??1CMRU@@UAE@XZ					; CMRU::~CMRU
; Function compile flags: /Odt
;	COMDAT ??_GCMRU@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCMRU@@UAEPAXI@Z PROC NEAR				; CMRU::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMRU@@UAE@XZ		; CMRU::~CMRU
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L49812
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L49812:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCMRU@@UAEPAXI@Z ENDP				; CMRU::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CMRU@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CMRU@@UAE@XZ PROC NEAR				; CMRU::~CMRU, COMDAT
; _this$ = ecx

; 776  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMRU@@6B@ ; CMRU::`vftable'

; 777  :     Save();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?Save@CMRU@@MAEXXZ	; CMRU::Save

; 778  : }

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 04	 add	 ecx, 4
  0001e	e8 00 00 00 00	 call	 ??1CRegistryKey@@UAE@XZ	; CRegistryKey::~CRegistryKey
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1CMRU@@UAE@XZ ENDP					; CMRU::~CMRU
_TEXT	ENDS
PUBLIC	??_C@_02MHMJ@?$CFu?$AA@				; `string'
PUBLIC	?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z	; InsertTailListUninit
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_02MHMJ@?$CFu?$AA@
CONST	SEGMENT
??_C@_02MHMJ@?$CFu?$AA@ DB '%u', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Load@CMRU@@MAEXXZ
_TEXT	SEGMENT
_this$ = -264
_szValueName$ = -256
_i$ = -260
?Load@CMRU@@MAEXXZ PROC NEAR				; CMRU::Load, COMDAT
; _this$ = ecx

; 804  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 805  :     TCHAR                   szValueName[0x100];
; 806  :     UINT                    i;
; 807  :     
; 808  :     //
; 809  :     // Reinitialize list data
; 810  :     //
; 811  : 
; 812  :     InitializeListHead(&m_lstItems);

  0000f	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00015	05 3c 04 00 00	 add	 eax, 1084		; 0000043cH
  0001a	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00020	89 81 3c 04 00
	00		 mov	 DWORD PTR [ecx+1084], eax
  00026	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 88 3c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1084]
  00038	89 8a 40 04 00
	00		 mov	 DWORD PTR [edx+1088], ecx

; 813  :     InitializeListHead(&m_lstFree);

  0003e	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00044	81 c2 44 04 00
	00		 add	 edx, 1092		; 00000444H
  0004a	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00050	89 90 44 04 00
	00		 mov	 DWORD PTR [eax+1092], edx
  00056	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00062	8b 82 44 04 00
	00		 mov	 eax, DWORD PTR [edx+1092]
  00068	89 81 48 04 00
	00		 mov	 DWORD PTR [ecx+1096], eax

; 814  : 
; 815  :     //
; 816  :     // Read each item from the registry
; 817  :     //
; 818  : 
; 819  :     for(i = 0; i < NUMELMS(m_aItems); i++)

  0006e	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00078	eb 0f		 jmp	 SHORT $L49823
$L49824:
  0007a	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00080	83 c1 01	 add	 ecx, 1
  00083	89 8d fc fe ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
$L49823:
  00089	83 bd fc fe ff
	ff 04		 cmp	 DWORD PTR _i$[ebp], 4
  00090	0f 83 87 00 00
	00		 jae	 $L49825

; 820  :     {
; 821  :         _stprintf(szValueName, TEXT("%u"), i);

  00096	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0009c	52		 push	 edx
  0009d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02MHMJ@?$CFu?$AA@ ; `string'
  000a2	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _szValueName$[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _sprintf
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 822  :         
; 823  :         if(!m_Key.GetStringValue(szValueName, m_aItems[i].szPath, NUMELMS(m_aItems[i].szPath)))

  000b1	68 04 01 00 00	 push	 260			; 00000104H
  000b6	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000bc	69 c9 0c 01 00
	00		 imul	 ecx, 268		; 0000010cH
  000c2	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000c8	8d 44 0a 14	 lea	 eax, DWORD PTR [edx+ecx+20]
  000cc	50		 push	 eax
  000cd	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _szValueName$[ebp]
  000d3	51		 push	 ecx
  000d4	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000da	83 c1 04	 add	 ecx, 4
  000dd	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000e3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000e6	ff 50 18	 call	 DWORD PTR [eax+24]
  000e9	85 c0		 test	 eax, eax
  000eb	75 02		 jne	 SHORT $L49827

; 824  :         {
; 825  :             break;

  000ed	eb 2e		 jmp	 SHORT $L49825
$L49827:

; 826  :         }
; 827  : 
; 828  :         InsertTailListUninit(&m_lstItems, &m_aItems[i].leItems);

  000ef	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000f5	69 c9 0c 01 00
	00		 imul	 ecx, 268		; 0000010cH
  000fb	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00101	8d 44 0a 0c	 lea	 eax, DWORD PTR [edx+ecx+12]
  00105	50		 push	 eax
  00106	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	81 c1 3c 04 00
	00		 add	 ecx, 1084		; 0000043cH
  00112	51		 push	 ecx
  00113	e8 00 00 00 00	 call	 ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailListUninit

; 829  :     }

  00118	e9 5d ff ff ff	 jmp	 $L49824
$L49825:

; 830  : 
; 831  :     //
; 832  :     // Move the remaining items into the free list
; 833  :     //
; 834  : 
; 835  :     for(; i < NUMELMS(m_aItems); i++)

  0011d	eb 0f		 jmp	 SHORT $L49828
$L49829:
  0011f	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00125	83 c2 01	 add	 edx, 1
  00128	89 95 fc fe ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$L49828:
  0012e	83 bd fc fe ff
	ff 04		 cmp	 DWORD PTR _i$[ebp], 4
  00135	73 2a		 jae	 SHORT $L49830

; 836  :     {
; 837  :         InsertTailListUninit(&m_lstFree, &m_aItems[i].leItems);

  00137	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0013d	69 c0 0c 01 00
	00		 imul	 eax, 268		; 0000010cH
  00143	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00149	8d 54 01 0c	 lea	 edx, DWORD PTR [ecx+eax+12]
  0014d	52		 push	 edx
  0014e	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00154	05 44 04 00 00	 add	 eax, 1092		; 00000444H
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailListUninit

; 838  :     }

  0015f	eb be		 jmp	 SHORT $L49829
$L49830:

; 839  : 
; 840  :     //
; 841  :     // Update the menu
; 842  :     //
; 843  : 
; 844  :     UpdateMenu();

  00161	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00167	8b 11		 mov	 edx, DWORD PTR [ecx]
  00169	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0016f	ff 52 08	 call	 DWORD PTR [edx+8]

; 845  : }

  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
?Load@CMRU@@MAEXXZ ENDP					; CMRU::Load
_TEXT	ENDS
PUBLIC	?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList
PUBLIC	??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
;	COMDAT ??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\common\ntlist.h
CONST	SEGMENT
??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\privat'
	DB	'e\windows\directx\dsound\common\ntlist.h', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z
_TEXT	SEGMENT
_ListHead$ = 8
_Entry$ = 12
?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z PROC NEAR	; InsertTailListUninit, COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 136  :     AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

  00003	68 88 00 00 00	 push	 136			; 00000088H
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000d	6a 00		 push	 0
  0000f	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 137  : 
; 138  :     Entry->Flink = ListHead;

  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR _ListHead$[ebp]
  0001e	89 11		 mov	 DWORD PTR [ecx], edx

; 139  :     Entry->Blink = ListHead->Blink;

  00020	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  00026	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00029	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 140  :     
; 141  :     Entry->Flink->Blink = Entry;

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00034	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 142  :     Entry->Blink->Flink = Entry;

  00037	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0003a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003d	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00040	89 11		 mov	 DWORD PTR [ecx], edx

; 143  : 
; 144  :     AssertValidEntryList(Entry, ASSERT_IN_LIST);

  00042	68 90 00 00 00	 push	 144			; 00000090H
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004c	6a 01		 push	 1
  0004e	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 145  : }    

  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ENDP	; InsertTailListUninit
_TEXT	ENDS
PUBLIC	??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@	; `string'
PUBLIC	??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@ ; `string'
PUBLIC	??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@ ; `string'
PUBLIC	??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@	; `string'
PUBLIC	??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@	; `string'
;	COMDAT ??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@
CONST	SEGMENT
??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@ DB 'NULL list entry pointe'
	DB	'r', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@
CONST	SEGMENT
??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@ DB 'List entry conta'
	DB	'ins NULL pointer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@
CONST	SEGMENT
??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@ DB 'List entry part'
	DB	'ially points to itself', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@
CONST	SEGMENT
??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@ DB 'List entry not in list'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@
CONST	SEGMENT
??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@ DB 'List entry in list', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
_TEXT	SEGMENT
_Entry$ = 8
_nFlags$ = 12
_pszFile$ = 16
_nLine$ = 20
?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z PROC NEAR ; __AssertValidEntryList, COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   :     if(!Entry)

  00003	83 7d 08 00	 cmp	 DWORD PTR _Entry$[ebp], 0
  00007	75 1c		 jne	 SHORT $L47475

; 57   :     {
; 58   :         DirectSound::CDebug::Assert(TRUE, "NULL list entry pointer", pszFile, nLine);

  00009	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  00010	51		 push	 ecx
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@ ; `string'
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0001d	83 c4 10	 add	 esp, 16			; 00000010H

; 59   :     }
; 60   :     else if(!Entry->Flink || !Entry->Blink)

  00020	e9 c0 00 00 00	 jmp	 $L47477
$L47475:
  00025	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  00028	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0002b	74 09		 je	 SHORT $L47479
  0002d	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	75 1c		 jne	 SHORT $L47478
$L47479:

; 61   :     {
; 62   :         DirectSound::CDebug::Assert(TRUE, "List entry contains NULL pointer", pszFile, nLine);

  00036	8b 4d 14	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  0003d	52		 push	 edx
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@ ; `string'
  00043	6a 01		 push	 1
  00045	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0004a	83 c4 10	 add	 esp, 16			; 00000010H

; 63   :     }
; 64   :     else if((Entry == Entry->Flink) || (Entry == Entry->Blink))

  0004d	e9 93 00 00 00	 jmp	 $L47481
$L47478:
  00052	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00058	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0005a	74 0b		 je	 SHORT $L47483
  0005c	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0005f	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00062	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00065	75 2e		 jne	 SHORT $L47482
$L47483:

; 65   :     {
; 66   :         if((Entry != Entry->Flink) || (Entry != Entry->Blink))

  00067	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0006a	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0006d	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0006f	75 0b		 jne	 SHORT $L47485
  00071	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00077	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0007a	74 17		 je	 SHORT $L47484
$L47485:

; 67   :         {
; 68   :             DirectSound::CDebug::Assert(TRUE, "List entry partially points to itself", pszFile, nLine);

  0007c	8b 55 14	 mov	 edx, DWORD PTR _nLine$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 10	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00083	50		 push	 eax
  00084	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@ ; `string'
  00089	6a 01		 push	 1
  0008b	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00090	83 c4 10	 add	 esp, 16			; 00000010H
$L47484:

; 69   :         }
; 70   :     }
; 71   :     else if(ASSERT_IN_LIST == nFlags)

  00093	eb 50		 jmp	 SHORT $L47487
$L47482:
  00095	83 7d 0c 01	 cmp	 DWORD PTR _nFlags$[ebp], 1
  00099	75 23		 jne	 SHORT $L47488

; 72   :     {
; 73   :         if(!IsEntryInList(Entry))

  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0009e	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  000a1	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000a3	75 17		 jne	 SHORT $L47489

; 74   :         {
; 75   :             DirectSound::CDebug::Assert(TRUE, "List entry not in list", pszFile, nLine);

  000a5	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  000ac	51		 push	 ecx
  000ad	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@ ; `string'
  000b2	6a 01		 push	 1
  000b4	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000b9	83 c4 10	 add	 esp, 16			; 00000010H
$L47489:

; 76   :         }
; 77   :     }
; 78   :     else if(ASSERT_NOT_IN_LIST == nFlags)

  000bc	eb 27		 jmp	 SHORT $L47491
$L47488:
  000be	83 7d 0c 02	 cmp	 DWORD PTR _nFlags$[ebp], 2
  000c2	75 21		 jne	 SHORT $L47492

; 79   :     {
; 80   :         if(IsEntryInList(Entry))

  000c4	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  000c7	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  000ca	3b 02		 cmp	 eax, DWORD PTR [edx]
  000cc	74 17		 je	 SHORT $L47493

; 81   :         {
; 82   :             DirectSound::CDebug::Assert(TRUE, "List entry in list", pszFile, nLine);

  000ce	8b 4d 14	 mov	 ecx, DWORD PTR _nLine$[ebp]
  000d1	51		 push	 ecx
  000d2	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  000d5	52		 push	 edx
  000d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@ ; `string'
  000db	6a 01		 push	 1
  000dd	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000e2	83 c4 10	 add	 esp, 16			; 00000010H
$L47493:
$L47492:
$L47491:
$L47487:
$L47481:
$L47477:

; 83   :         }
; 84   :     }
; 85   : }

  000e5	5d		 pop	 ebp
  000e6	c2 10 00	 ret	 16			; 00000010H
?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ENDP ; __AssertValidEntryList
_TEXT	ENDS
EXTRN	__imp__RegEnumValueA@32:NEAR
EXTRN	__imp__RegDeleteValueA@8:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\xact\host\gui\base\registry.cpp
;	COMDAT ?Save@CMRU@@MAEXXZ
_TEXT	SEGMENT
_this$ = -276
_szValueName$ = -256
_dwLength$ = -260
_pleEntry$ = -272
_pItem$ = -268
_i$ = -264
?Save@CMRU@@MAEXXZ PROC NEAR				; CMRU::Save, COMDAT
; _this$ = ecx

; 871  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	89 8d ec fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
$L49841:

; 872  :     TCHAR                   szValueName[0x100];
; 873  :     DWORD                   dwLength;
; 874  :     PLIST_ENTRY             pleEntry;
; 875  :     LPMRUITEM               pItem;
; 876  :     UINT                    i;
; 877  :     
; 878  :     //
; 879  :     // Delete all values from the registry key
; 880  :     //
; 881  : 
; 882  :     while(TRUE)

  0000f	b8 01 00 00 00	 mov	 eax, 1
  00014	85 c0		 test	 eax, eax
  00016	74 6f		 je	 SHORT $L49842

; 883  :     {
; 884  :         dwLength = NUMELMS(szValueName);

  00018	c7 85 fc fe ff
	ff 00 01 00 00	 mov	 DWORD PTR _dwLength$[ebp], 256 ; 00000100H

; 885  :         
; 886  :         if(RegEnumValue(m_Key, 0, szValueName, &dwLength, NULL, NULL, NULL, NULL))

  00022	6a 00		 push	 0
  00024	6a 00		 push	 0
  00026	6a 00		 push	 0
  00028	6a 00		 push	 0
  0002a	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _dwLength$[ebp]
  00030	51		 push	 ecx
  00031	8d 95 00 ff ff
	ff		 lea	 edx, DWORD PTR _szValueName$[ebp]
  00037	52		 push	 edx
  00038	6a 00		 push	 0
  0003a	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00040	83 c1 04	 add	 ecx, 4
  00043	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004c	ff 52 28	 call	 DWORD PTR [edx+40]
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegEnumValueA@32
  00056	85 c0		 test	 eax, eax
  00058	74 02		 je	 SHORT $L49843

; 887  :         {
; 888  :             break;

  0005a	eb 2b		 jmp	 SHORT $L49842
$L49843:

; 889  :         }
; 890  : 
; 891  :         if(!RegDeleteValue(m_Key, szValueName))

  0005c	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _szValueName$[ebp]
  00062	50		 push	 eax
  00063	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00069	83 c1 04	 add	 ecx, 4
  0006c	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00072	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00075	ff 50 28	 call	 DWORD PTR [eax+40]
  00078	50		 push	 eax
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteValueA@8
  0007f	85 c0		 test	 eax, eax
  00081	75 02		 jne	 SHORT $L49844

; 892  :         {
; 893  :             break;

  00083	eb 02		 jmp	 SHORT $L49842
$L49844:

; 894  :         }
; 895  :     }

  00085	eb 88		 jmp	 SHORT $L49841
$L49842:

; 896  : 
; 897  :     //
; 898  :     // Write all entries from the list
; 899  :     //
; 900  : 
; 901  :     for(pleEntry = m_lstItems.Flink, i = 0; pleEntry != &m_lstItems; pleEntry = pleEntry->Flink, i++)

  00087	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	8b 91 3c 04 00
	00		 mov	 edx, DWORD PTR [ecx+1084]
  00093	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _pleEntry$[ebp], edx
  00099	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  000a3	eb 1d		 jmp	 SHORT $L49845
$L49846:
  000a5	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _pleEntry$[ebp]
  000ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ad	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _pleEntry$[ebp], ecx
  000b3	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  000b9	83 c2 01	 add	 edx, 1
  000bc	89 95 f8 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$L49845:
  000c2	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000c8	05 3c 04 00 00	 add	 eax, 1084		; 0000043cH
  000cd	39 85 f0 fe ff
	ff		 cmp	 DWORD PTR _pleEntry$[ebp], eax
  000d3	74 4f		 je	 SHORT $L49847

; 902  :     {
; 903  :         pItem = CONTAINING_RECORD(pleEntry, MRUITEM, leItems);

  000d5	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  000db	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _pItem$[ebp], ecx

; 904  :         
; 905  :         _stprintf(szValueName, TEXT("%u"), i);

  000e1	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  000e7	52		 push	 edx
  000e8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02MHMJ@?$CFu?$AA@ ; `string'
  000ed	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _szValueName$[ebp]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 _sprintf
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 906  : 
; 907  :         m_Key.SetStringValue(szValueName, pItem->szPath);

  000fc	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _pItem$[ebp]
  00102	83 c1 08	 add	 ecx, 8
  00105	51		 push	 ecx
  00106	8d 95 00 ff ff
	ff		 lea	 edx, DWORD PTR _szValueName$[ebp]
  0010c	52		 push	 edx
  0010d	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00113	83 c1 04	 add	 ecx, 4
  00116	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0011c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0011f	ff 52 1c	 call	 DWORD PTR [edx+28]

; 908  :     }

  00122	eb 81		 jmp	 SHORT $L49846
$L49847:

; 909  : }

  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c3		 ret	 0
?Save@CMRU@@MAEXXZ ENDP					; CMRU::Save
_TEXT	ENDS
PUBLIC	?InsertHeadList@@YGXPAU_LIST_ENTRY@@0@Z		; InsertHeadList
PUBLIC	?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z	; RemoveEntryList
EXTRN	_strcpy:NEAR
EXTRN	__stricmp:NEAR
; Function compile flags: /Odt
;	COMDAT ?AddItem@CMRU@@UAEXPBDH@Z
_TEXT	SEGMENT
_pszPath$ = 8
_fUpdateMenu$ = 12
_this$ = -12
_pleEntry$ = -8
_pItem$ = -4
?AddItem@CMRU@@UAEXPBDH@Z PROC NEAR			; CMRU::AddItem, COMDAT
; _this$ = ecx

; 937  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 938  :     PLIST_ENTRY             pleEntry;
; 939  :     LPMRUITEM               pItem;
; 940  : 
; 941  :     //
; 942  :     // Look for the item in the current list
; 943  :     //
; 944  : 
; 945  :     for(pleEntry = m_lstItems.Flink; pleEntry != &m_lstItems; pleEntry = pleEntry->Flink)

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 88 3c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1084]
  00012	89 4d f8	 mov	 DWORD PTR _pleEntry$[ebp], ecx
  00015	eb 08		 jmp	 SHORT $L49859
$L49860:
  00017	8b 55 f8	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	89 45 f8	 mov	 DWORD PTR _pleEntry$[ebp], eax
$L49859:
  0001f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	81 c1 3c 04 00
	00		 add	 ecx, 1084		; 0000043cH
  00028	39 4d f8	 cmp	 DWORD PTR _pleEntry$[ebp], ecx
  0002b	74 21		 je	 SHORT $L49861

; 946  :     {
; 947  :         pItem = CONTAINING_RECORD(pleEntry, MRUITEM, leItems);

  0002d	8b 55 f8	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  00030	89 55 fc	 mov	 DWORD PTR _pItem$[ebp], edx

; 948  : 
; 949  :         if(!_tcsicmp(pszPath, pItem->szPath))

  00033	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  00036	83 c0 08	 add	 eax, 8
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _pszPath$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 __stricmp
  00043	83 c4 08	 add	 esp, 8
  00046	85 c0		 test	 eax, eax
  00048	75 02		 jne	 SHORT $L49866

; 950  :         {
; 951  :             break;

  0004a	eb 02		 jmp	 SHORT $L49861
$L49866:

; 952  :         }
; 953  :     }

  0004c	eb c9		 jmp	 SHORT $L49860
$L49861:

; 954  : 
; 955  :     //
; 956  :     // If the item's already in the list, just move it to the head.  If not,
; 957  :     // add it to the tail.  If we're out of free items, use the last one in
; 958  :     // the current list.
; 959  :     //
; 960  : 
; 961  :     if(pleEntry != &m_lstItems)

  0004e	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00051	81 c2 3c 04 00
	00		 add	 edx, 1084		; 0000043cH
  00057	39 55 f8	 cmp	 DWORD PTR _pleEntry$[ebp], edx
  0005a	74 0b		 je	 SHORT $L49867

; 962  :     {
; 963  :         RemoveEntryList(pleEntry);

  0005c	8b 45 f8	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 964  :     }
; 965  :     else if(!IsListEmpty(&m_lstFree))

  00065	eb 3a		 jmp	 SHORT $L49868
$L49867:
  00067	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	81 c1 44 04 00
	00		 add	 ecx, 1092		; 00000444H
  00070	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00073	3b 8a 44 04 00
	00		 cmp	 ecx, DWORD PTR [edx+1092]
  00079	74 14		 je	 SHORT $L49869

; 966  :     {
; 967  :         pleEntry = RemoveHeadList(&m_lstFree);

  0007b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 88 44 04 00
	00		 mov	 ecx, DWORD PTR [eax+1092]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList
  0008a	89 45 f8	 mov	 DWORD PTR _pleEntry$[ebp], eax

; 968  :     }
; 969  :     else

  0008d	eb 12		 jmp	 SHORT $L49870
$L49869:

; 970  :     {
; 971  :         pleEntry = RemoveTailList(&m_lstItems);

  0008f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00092	8b 82 40 04 00
	00		 mov	 eax, DWORD PTR [edx+1088]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList
  0009e	89 45 f8	 mov	 DWORD PTR _pleEntry$[ebp], eax
$L49870:
$L49868:

; 972  :     }
; 973  : 
; 974  :     pItem = CONTAINING_RECORD(pleEntry, MRUITEM, leItems);

  000a1	8b 4d f8	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  000a4	89 4d fc	 mov	 DWORD PTR _pItem$[ebp], ecx

; 975  : 
; 976  :     _tcscpy(pItem->szPath, pszPath);

  000a7	8b 55 08	 mov	 edx, DWORD PTR _pszPath$[ebp]
  000aa	52		 push	 edx
  000ab	8b 45 fc	 mov	 eax, DWORD PTR _pItem$[ebp]
  000ae	83 c0 08	 add	 eax, 8
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _strcpy
  000b7	83 c4 08	 add	 esp, 8

; 977  :     
; 978  :     InsertHeadList(&m_lstItems, pleEntry);

  000ba	8b 4d f8	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  000bd	51		 push	 ecx
  000be	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000c1	81 c2 3c 04 00
	00		 add	 edx, 1084		; 0000043cH
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ?InsertHeadList@@YGXPAU_LIST_ENTRY@@0@Z ; InsertHeadList

; 979  : 
; 980  :     //
; 981  :     // Update the menu
; 982  :     //
; 983  : 
; 984  :     if(fUpdateMenu)

  000cd	83 7d 0c 00	 cmp	 DWORD PTR _fUpdateMenu$[ebp], 0
  000d1	74 0b		 je	 SHORT $L49875

; 985  :     {
; 986  :         UpdateMenu();

  000d3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	8b 10		 mov	 edx, DWORD PTR [eax]
  000d8	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	ff 52 08	 call	 DWORD PTR [edx+8]
$L49875:

; 987  :     }
; 988  : }

  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 08 00	 ret	 8
?AddItem@CMRU@@UAEXPBDH@Z ENDP				; CMRU::AddItem
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\ntlist.h
_TEXT	ENDS
;	COMDAT ?InsertHeadList@@YGXPAU_LIST_ENTRY@@0@Z
_TEXT	SEGMENT
_ListHead$ = 8
_Entry$ = 12
?InsertHeadList@@YGXPAU_LIST_ENTRY@@0@Z PROC NEAR	; InsertHeadList, COMDAT

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 168  :     AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

  00003	68 a8 00 00 00	 push	 168			; 000000a8H
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000d	6a 00		 push	 0
  0000f	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 169  :     AssertValidEntryList(Entry, ASSERT_NOT_IN_LIST);

  00018	68 a9 00 00 00	 push	 169			; 000000a9H
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00022	6a 02		 push	 2
  00024	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 170  : 
; 171  :     Entry->Flink = ListHead->Flink;

  0002d	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00030	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 0a		 mov	 DWORD PTR [edx], ecx

; 172  :     Entry->Blink = ListHead;

  00037	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  0003a	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  0003d	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 173  :     
; 174  :     Entry->Flink->Blink = Entry;

  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00043	8b 11		 mov	 edx, DWORD PTR [ecx]
  00045	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00048	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 175  :     Entry->Blink->Flink = Entry;

  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0004e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00051	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00054	89 02		 mov	 DWORD PTR [edx], eax

; 176  : 
; 177  :     AssertValidEntryList(Entry, ASSERT_IN_LIST);

  00056	68 b1 00 00 00	 push	 177			; 000000b1H
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00060	6a 01		 push	 1
  00062	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 178  : }

  0006b	5d		 pop	 ebp
  0006c	c2 08 00	 ret	 8
?InsertHeadList@@YGXPAU_LIST_ENTRY@@0@Z ENDP		; InsertHeadList
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z
_TEXT	SEGMENT
_Entry$ = 8
?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z PROC NEAR	; RemoveEntryList, COMDAT

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 216  :     AssertValidEntryList(Entry, ASSERT_VALID_ONLY);

  00003	68 d8 00 00 00	 push	 216			; 000000d8H
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000d	6a 00		 push	 0
  0000f	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 217  : 
; 218  :     if(IsEntryInList(Entry))

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0001e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00020	74 2c		 je	 SHORT $L47515

; 219  :     {
; 220  :         Entry->Flink->Blink = Entry->Blink;

  00022	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0002a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 221  :         Entry->Blink->Flink = Entry->Flink;

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00033	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00036	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 0a		 mov	 DWORD PTR [edx], ecx

; 222  : 
; 223  :         Entry->Flink = Entry->Blink = Entry;

  0003d	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  00040	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00043	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00049	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0004c	89 11		 mov	 DWORD PTR [ecx], edx
$L47515:

; 224  :     }
; 225  : 
; 226  :     return Entry;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]

; 227  : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ENDP	; RemoveEntryList
_TEXT	ENDS
PUBLIC	??_C@_07CPEI@?$CG?$CFlu?7?$CFs?$AA@		; `string'
EXTRN	__imp__GetMenuStringA@20:NEAR
EXTRN	__imp__EnableMenuItem@12:NEAR
EXTRN	__imp__AppendMenuA@16:NEAR
EXTRN	__imp__DeleteMenu@12:NEAR
;	COMDAT ??_C@_07CPEI@?$CG?$CFlu?7?$CFs?$AA@
; File c:\xbox\private\windows\directx\xact\host\gui\base\registry.cpp
CONST	SEGMENT
??_C@_07CPEI@?$CG?$CFlu?7?$CFs?$AA@ DB '&%lu', 09H, '%s', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?UpdateMenu@CMRU@@UAEXXZ
_TEXT	SEGMENT
_this$ = -536
_szString$ = -520
_pleEntry$ = -532
_pItem$ = -528
_i$ = -524
?UpdateMenu@CMRU@@UAEXXZ PROC NEAR			; CMRU::UpdateMenu, COMDAT
; _this$ = ecx

; 1014 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H
  00009	89 8d e8 fd ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 1015 :     TCHAR                   szString[MAX_PATH + 0x100];
; 1016 :     PLIST_ENTRY             pleEntry;
; 1017 :     LPMRUITEM               pItem;
; 1018 :     UINT                    i;
; 1019 :     
; 1020 :     if(!m_hMenu)

  0000f	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 b8 4c 04 00
	00 00		 cmp	 DWORD PTR [eax+1100], 0
  0001c	75 05		 jne	 SHORT $L49884

; 1021 :     {
; 1022 :         return;

  0001e	e9 76 01 00 00	 jmp	 $L49879
$L49884:

; 1023 :     }
; 1024 : 
; 1025 :     //
; 1026 :     // Save the first item that already exists in the menu.  If there's
; 1027 :     // nothing in the MRU, we'll use this as a placeholder.
; 1028 :     //
; 1029 : 
; 1030 :     if(!m_szPlaceholder[0])

  00023	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00029	0f be 91 54 04
	00 00		 movsx	 edx, BYTE PTR [ecx+1108]
  00030	85 d2		 test	 edx, edx
  00032	75 2b		 jne	 SHORT $L49885

; 1031 :     {
; 1032 :         GetMenuString(m_hMenu, 0, m_szPlaceholder, NUMELMS(m_szPlaceholder), MF_BYPOSITION);

  00034	68 00 04 00 00	 push	 1024			; 00000400H
  00039	68 00 01 00 00	 push	 256			; 00000100H
  0003e	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00044	05 54 04 00 00	 add	 eax, 1108		; 00000454H
  00049	50		 push	 eax
  0004a	6a 00		 push	 0
  0004c	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00052	8b 91 4c 04 00
	00		 mov	 edx, DWORD PTR [ecx+1100]
  00058	52		 push	 edx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMenuStringA@20
$L49885:
$L49887:

; 1033 :     }
; 1034 : 
; 1035 :     //
; 1036 :     // Remove existing menu items
; 1037 :     //
; 1038 :     
; 1039 :     while(DeleteMenu(m_hMenu, 0, MF_BYPOSITION));

  0005f	68 00 04 00 00	 push	 1024			; 00000400H
  00064	6a 00		 push	 0
  00066	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 88 4c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1100]
  00072	51		 push	 ecx
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteMenu@12
  00079	85 c0		 test	 eax, eax
  0007b	74 02		 je	 SHORT $L49888
  0007d	eb e0		 jmp	 SHORT $L49887
$L49888:

; 1040 : 
; 1041 :     //
; 1042 :     // Add MRU data
; 1043 :     //
; 1044 : 
; 1045 :     for(pleEntry = m_lstItems.Flink, i = 0; pleEntry != &m_lstItems; pleEntry = pleEntry->Flink, i++)

  0007f	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00085	8b 82 3c 04 00
	00		 mov	 eax, DWORD PTR [edx+1084]
  0008b	89 85 ec fd ff
	ff		 mov	 DWORD PTR _pleEntry$[ebp], eax
  00091	c7 85 f4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0009b	eb 1d		 jmp	 SHORT $L49889
$L49890:
  0009d	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  000a3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a5	89 95 ec fd ff
	ff		 mov	 DWORD PTR _pleEntry$[ebp], edx
  000ab	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000b1	83 c0 01	 add	 eax, 1
  000b4	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L49889:
  000ba	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	81 c1 3c 04 00
	00		 add	 ecx, 1084		; 0000043cH
  000c6	39 8d ec fd ff
	ff		 cmp	 DWORD PTR _pleEntry$[ebp], ecx
  000cc	74 68		 je	 SHORT $L49891

; 1046 :     {
; 1047 :         pItem = CONTAINING_RECORD(pleEntry, MRUITEM, leItems);

  000ce	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _pleEntry$[ebp]
  000d4	89 95 f0 fd ff
	ff		 mov	 DWORD PTR _pItem$[ebp], edx

; 1048 : 
; 1049 :         _stprintf(szString, TEXT("&%lu\t%s"), i + 1, pItem->szPath);

  000da	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _pItem$[ebp]
  000e0	83 c0 08	 add	 eax, 8
  000e3	50		 push	 eax
  000e4	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000ea	83 c1 01	 add	 ecx, 1
  000ed	51		 push	 ecx
  000ee	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CPEI@?$CG?$CFlu?7?$CFs?$AA@ ; `string'
  000f3	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _szString$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 _sprintf
  000ff	83 c4 10	 add	 esp, 16			; 00000010H

; 1050 : 
; 1051 :         AppendMenu(m_hMenu, MF_STRING, m_nCommandId + i, szString);

  00102	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _szString$[ebp]
  00108	50		 push	 eax
  00109	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	8b 91 50 04 00
	00		 mov	 edx, DWORD PTR [ecx+1104]
  00115	03 95 f4 fd ff
	ff		 add	 edx, DWORD PTR _i$[ebp]
  0011b	52		 push	 edx
  0011c	6a 00		 push	 0
  0011e	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00124	8b 88 4c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1100]
  0012a	51		 push	 ecx
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AppendMenuA@16

; 1052 :     }

  00131	e9 67 ff ff ff	 jmp	 $L49890
$L49891:

; 1053 : 
; 1054 :     //
; 1055 :     // If we didn't add anything, add a placeholder
; 1056 :     //
; 1057 : 
; 1058 :     if(!i && m_szPlaceholder[0])

  00136	83 bd f4 fd ff
	ff 00		 cmp	 DWORD PTR _i$[ebp], 0
  0013d	75 5a		 jne	 SHORT $L49897
  0013f	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00145	0f be 82 54 04
	00 00		 movsx	 eax, BYTE PTR [edx+1108]
  0014c	85 c0		 test	 eax, eax
  0014e	74 49		 je	 SHORT $L49897

; 1059 :     {
; 1060 :         AppendMenu(m_hMenu, MF_STRING, m_nCommandId, m_szPlaceholder);

  00150	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00156	81 c1 54 04 00
	00		 add	 ecx, 1108		; 00000454H
  0015c	51		 push	 ecx
  0015d	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00163	8b 82 50 04 00
	00		 mov	 eax, DWORD PTR [edx+1104]
  00169	50		 push	 eax
  0016a	6a 00		 push	 0
  0016c	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00172	8b 91 4c 04 00
	00		 mov	 edx, DWORD PTR [ecx+1100]
  00178	52		 push	 edx
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AppendMenuA@16

; 1061 :         EnableMenuItem(m_hMenu, 0, MF_BYPOSITION | MF_GRAYED);

  0017f	68 01 04 00 00	 push	 1025			; 00000401H
  00184	6a 00		 push	 0
  00186	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0018c	8b 88 4c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1100]
  00192	51		 push	 ecx
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableMenuItem@12
$L49897:
$L49879:

; 1062 :     }
; 1063 : }

  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
?UpdateMenu@CMRU@@UAEXXZ ENDP				; CMRU::UpdateMenu
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?TranslateCommand@CMRU@@UAEPBDI@Z
_TEXT	SEGMENT
_nCommandId$ = 8
_this$ = -16
_pleEntry$ = -12
_pItem$ = -8
_i$ = -4
?TranslateCommand@CMRU@@UAEPBDI@Z PROC NEAR		; CMRU::TranslateCommand, COMDAT
; _this$ = ecx

; 1089 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1090 :     PLIST_ENTRY             pleEntry;
; 1091 :     LPMRUITEM               pItem;
; 1092 :     UINT                    i;
; 1093 : 
; 1094 :     if((nCommandId < m_nCommandId) || (nCommandId >= m_nCommandId + NUMELMS(m_aItems)))

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _nCommandId$[ebp]
  0000f	3b 88 50 04 00
	00		 cmp	 ecx, DWORD PTR [eax+1104]
  00015	72 11		 jb	 SHORT $L49906
  00017	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 82 50 04 00
	00		 mov	 eax, DWORD PTR [edx+1104]
  00020	83 c0 04	 add	 eax, 4
  00023	39 45 08	 cmp	 DWORD PTR _nCommandId$[ebp], eax
  00026	72 04		 jb	 SHORT $L49905
$L49906:

; 1095 :     {
; 1096 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 59		 jmp	 SHORT $L49901
$L49905:

; 1097 :     }
; 1098 : 
; 1099 :     pleEntry = m_lstItems.Flink;

  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 91 3c 04 00
	00		 mov	 edx, DWORD PTR [ecx+1084]
  00035	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx

; 1100 :     i = m_nCommandId;

  00038	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 88 50 04 00
	00		 mov	 ecx, DWORD PTR [eax+1104]
  00041	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L49908:

; 1101 : 
; 1102 :     while((pleEntry != &m_lstItems) && (i != nCommandId))

  00044	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00047	81 c2 3c 04 00
	00		 add	 edx, 1084		; 0000043cH
  0004d	39 55 f4	 cmp	 DWORD PTR _pleEntry$[ebp], edx
  00050	74 1b		 je	 SHORT $L49909
  00052	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00055	3b 45 08	 cmp	 eax, DWORD PTR _nCommandId$[ebp]
  00058	74 13		 je	 SHORT $L49909

; 1103 :     {
; 1104 :         pleEntry = pleEntry->Flink;

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx

; 1105 :         i++;

  00062	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00065	83 c0 01	 add	 eax, 1
  00068	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 1106 :     }

  0006b	eb d7		 jmp	 SHORT $L49908
$L49909:

; 1107 : 
; 1108 :     if(i != nCommandId)

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00070	3b 4d 08	 cmp	 ecx, DWORD PTR _nCommandId$[ebp]
  00073	74 04		 je	 SHORT $L49910

; 1109 :     {
; 1110 :         return NULL;

  00075	33 c0		 xor	 eax, eax
  00077	eb 0c		 jmp	 SHORT $L49901
$L49910:

; 1111 :     }
; 1112 : 
; 1113 :     pItem = CONTAINING_RECORD(pleEntry, MRUITEM, leItems);

  00079	8b 55 f4	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  0007c	89 55 f8	 mov	 DWORD PTR _pItem$[ebp], edx

; 1114 : 
; 1115 :     return pItem->szPath;

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _pItem$[ebp]
  00082	83 c0 08	 add	 eax, 8
$L49901:

; 1116 : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?TranslateCommand@CMRU@@UAEPBDI@Z ENDP			; CMRU::TranslateCommand
_TEXT	ENDS
PUBLIC	??_C@_0BD@BLHJ@?91?5?$CB?$DN?5m_nCommandId?$AA@	; `string'
EXTRN	__imp__GetMenuItemID@8:NEAR
;	COMDAT ??_C@_0BD@BLHJ@?91?5?$CB?$DN?5m_nCommandId?$AA@
CONST	SEGMENT
??_C@_0BD@BLHJ@?91?5?$CB?$DN?5m_nCommandId?$AA@ DB '-1 != m_nCommandId', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?AttachMenu@CMRU@@UAEXPAUHMENU__@@@Z
_TEXT	SEGMENT
_hMenu$ = 8
_this$ = -4
?AttachMenu@CMRU@@UAEXPAUHMENU__@@@Z PROC NEAR		; CMRU::AttachMenu, COMDAT
; _this$ = ecx

; 1142 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1143 :     m_hMenu = hMenu;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _hMenu$[ebp]
  0000d	89 88 4c 04 00
	00		 mov	 DWORD PTR [eax+1100], ecx

; 1144 : 
; 1145 :     //
; 1146 :     // Get the identifier of the first item in the menu.  All MRU items will
; 1147 :     // increment from this base command identifier.
; 1148 :     //
; 1149 : 
; 1150 :     m_nCommandId = GetMenuItemID(m_hMenu, 0);

  00013	6a 00		 push	 0
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 82 4c 04 00
	00		 mov	 eax, DWORD PTR [edx+1100]
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMenuItemID@8
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	89 81 50 04 00
	00		 mov	 DWORD PTR [ecx+1104], eax

; 1151 :     ASSERT(-1 != m_nCommandId);

  0002e	68 7f 04 00 00	 push	 1151			; 0000047fH
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@GLLN@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@BLHJ@?91?5?$CB?$DN?5m_nCommandId?$AA@ ; `string'
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00040	33 c0		 xor	 eax, eax
  00042	83 ba 50 04 00
	00 ff		 cmp	 DWORD PTR [edx+1104], -1
  00049	0f 94 c0	 sete	 al
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00052	83 c4 10	 add	 esp, 16			; 00000010H

; 1152 : 
; 1153 :     //
; 1154 :     // Reset the menu
; 1155 :     //
; 1156 : 
; 1157 :     UpdateMenu();

  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	ff 52 08	 call	 DWORD PTR [edx+8]

; 1158 : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?AttachMenu@CMRU@@UAEXPAUHMENU__@@@Z ENDP		; CMRU::AttachMenu
_TEXT	ENDS
PUBLIC	??_C@_05EAGJ@TCHAR?$AA@				; `string'
EXTRN	?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z:NEAR ; DirectSound::CMemoryManager::TrackingPoolAlloc
;	COMDAT ??_C@_05EAGJ@TCHAR?$AA@
CONST	SEGMENT
??_C@_05EAGJ@TCHAR?$AA@ DB 'TCHAR', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetItems@CMRU@@UAEPADXZ
_TEXT	SEGMENT
_this$ = -20
_pszBuffer$ = -16
_pleEntry$ = -12
_pItem$ = -8
_psz$ = -4
?GetItems@CMRU@@UAEPADXZ PROC NEAR			; CMRU::GetItems, COMDAT
; _this$ = ecx

; 1185 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1186 :     LPTSTR                  pszBuffer;
; 1187 :     PLIST_ENTRY             pleEntry;
; 1188 :     LPMRUITEM               pItem;
; 1189 :     LPTSTR                  psz;
; 1190 : 
; 1191 :     //
; 1192 :     // Allocate a buffer large enough to hold the maximum number of items
; 1193 :     // possible
; 1194 :     //
; 1195 : 
; 1196 :     if(!(pszBuffer = MEMALLOC(TCHAR, MAX_PATH * MAX_ITEMS + 1)))

  00009	6a 01		 push	 1
  0000b	68 11 04 00 00	 push	 1041			; 00000411H
  00010	68 44 53 64 61	 push	 1633964868		; 61645344H
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05EAGJ@TCHAR?$AA@ ; `string'
  0001a	68 ac 04 00 00	 push	 1196			; 000004acH
  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@GLLN@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00024	e8 00 00 00 00	 call	 ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingPoolAlloc
  00029	89 45 f0	 mov	 DWORD PTR _pszBuffer$[ebp], eax
  0002c	83 7d f0 00	 cmp	 DWORD PTR _pszBuffer$[ebp], 0
  00030	75 04		 jne	 SHORT $L49930

; 1197 :     {
; 1198 :         return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	eb 5e		 jmp	 SHORT $L49923
$L49930:

; 1199 :     }
; 1200 : 
; 1201 :     //
; 1202 :     // Start copying the items
; 1203 :     //
; 1204 : 
; 1205 :     psz = pszBuffer;

  00036	8b 45 f0	 mov	 eax, DWORD PTR _pszBuffer$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR _psz$[ebp], eax

; 1206 :     
; 1207 :     for(pleEntry = m_lstItems.Flink; pleEntry != &m_lstItems; pleEntry = pleEntry->Flink)

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 91 3c 04 00
	00		 mov	 edx, DWORD PTR [ecx+1084]
  00045	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx
  00048	eb 08		 jmp	 SHORT $L49932
$L49933:
  0004a	8b 45 f4	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	89 4d f4	 mov	 DWORD PTR _pleEntry$[ebp], ecx
$L49932:
  00052	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00055	81 c2 3c 04 00
	00		 add	 edx, 1084		; 0000043cH
  0005b	39 55 f4	 cmp	 DWORD PTR _pleEntry$[ebp], edx
  0005e	74 31		 je	 SHORT $L49934

; 1208 :     {
; 1209 :         pItem = CONTAINING_RECORD(pleEntry, MRUITEM, leItems);

  00060	8b 45 f4	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  00063	89 45 f8	 mov	 DWORD PTR _pItem$[ebp], eax

; 1210 : 
; 1211 :         _tcscpy(psz, pItem->szPath);

  00066	8b 4d f8	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00069	83 c1 08	 add	 ecx, 8
  0006c	51		 push	 ecx
  0006d	8b 55 fc	 mov	 edx, DWORD PTR _psz$[ebp]
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 _strcpy
  00076	83 c4 08	 add	 esp, 8

; 1212 : 
; 1213 :         psz += _tcslen(psz) + 1;

  00079	8b 45 fc	 mov	 eax, DWORD PTR _psz$[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _strlen
  00082	83 c4 04	 add	 esp, 4
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _psz$[ebp]
  00088	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0008c	89 55 fc	 mov	 DWORD PTR _psz$[ebp], edx

; 1214 :     }

  0008f	eb b9		 jmp	 SHORT $L49933
$L49934:

; 1215 : 
; 1216 :     return pszBuffer;

  00091	8b 45 f0	 mov	 eax, DWORD PTR _pszBuffer$[ebp]
$L49923:

; 1217 : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
?GetItems@CMRU@@UAEPADXZ ENDP				; CMRU::GetItems
_TEXT	ENDS
END
