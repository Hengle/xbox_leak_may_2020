; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	c:\xbox\private\windows\directx\xact\host\gui\base\strhlp.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DPKL@?$CIunknown?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06NPGC@?$CInone?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MKNO@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@GKFF@?$CBm_dwRefCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GLPL@m_dwRefCount?5?$DM?5?$HO0UL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BGIF@m_dwRefCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@CGCA@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BEIE@this?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@GMNP@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07FEMJ@XACTGUI?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@ONNK@FormatStringResource?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@HIPI@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@FFOO@String?5?$CFlu?5not?5found?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@KCCG@FormatStringResourceStatic?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05EAGJ@TCHAR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BPPI@?$CFlu?4?$CFlu?4?$CFlu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCRefCount@DirectSound@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRefCount@DirectSound@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CRefCount@DirectSound@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CRefCount@DirectSound@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataOffset@CRiffChunk@WaveLoader@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _FormatStringResource
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _FormatStringResourceStatic
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ParseCommandLine@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GetXDKVersion@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _FormatNumber@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _MsgBoxV@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _MsgBox
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _MsgBoxResource
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CRefCount@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

CONST	SEGMENT
?dwMajor@?1??GetXDKVersion@@9@4@4KB DD 01H		; `GetXDKVersion'::`2'::dwMajor
?dwMinor@?1??GetXDKVersion@@9@4@4KB DD 00H		; `GetXDKVersion'::`2'::dwMinor
?dwBuild@?1??GetXDKVersion@@9@4@4KB DD 01130H		; `GetXDKVersion'::`2'::dwBuild
CONST	ENDS
PUBLIC	_FormatStringResource
PUBLIC	??_C@_07FEMJ@XACTGUI?$AA@			; `string'
PUBLIC	??_C@_0BF@ONNK@FormatStringResource?$AA@	; `string'
PUBLIC	??_C@_0DO@HIPI@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BF@FFOO@String?5?$CFlu?5not?5found?$AA@	; `string'
EXTRN	_g_hInstance:DWORD
EXTRN	__vsnprintf:NEAR
EXTRN	?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z:NEAR ; DirectSound::CDebug::SetContext
EXTRN	?Print@CDebug@DirectSound@@SAXPBDZZ:NEAR	; DirectSound::CDebug::Print
EXTRN	__imp__LoadStringA@16:NEAR
;	COMDAT ??_C@_07FEMJ@XACTGUI?$AA@
; File c:\xbox\private\windows\directx\xact\host\gui\base\strhlp.cpp
CONST	SEGMENT
??_C@_07FEMJ@XACTGUI?$AA@ DB 'XACTGUI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ONNK@FormatStringResource?$AA@
CONST	SEGMENT
??_C@_0BF@ONNK@FormatStringResource?$AA@ DB 'FormatStringResource', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@HIPI@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DO@HIPI@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\privat'
	DB	'e\windows\directx\xact\host\gui\base\strhlp.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FFOO@String?5?$CFlu?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BF@FFOO@String?5?$CFlu?5not?5found?$AA@ DB 'String %lu not found', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _FormatStringResource
_TEXT	SEGMENT
_pszText$ = 8
_nLength$ = 12
_nResourceId$ = 16
_szFormat$ = -264
_va$ = -4
_FormatStringResource PROC NEAR				; COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H

; 45   :     TCHAR                   szFormat[0x100];
; 46   :     va_list                 va;
; 47   : 
; 48   :     if(LoadString(g_hInstance, nResourceId, szFormat, NUMELMS(szFormat)))

  00009	68 00 01 00 00	 push	 256			; 00000100H
  0000e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szFormat$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 10	 mov	 ecx, DWORD PTR _nResourceId$[ebp]
  00018	51		 push	 ecx
  00019	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_hInstance
  0001f	52		 push	 edx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadStringA@16
  00026	85 c0		 test	 eax, eax
  00028	74 2a		 je	 SHORT $L49638

; 49   :     {
; 50   :         va_start(va, nResourceId);

  0002a	8d 45 14	 lea	 eax, DWORD PTR _nResourceId$[ebp+4]
  0002d	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 51   :         _vsntprintf(pszText, nLength, szFormat, va);

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  00033	51		 push	 ecx
  00034	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szFormat$[ebp]
  0003a	52		 push	 edx
  0003b	8b 45 0c	 mov	 eax, DWORD PTR _nLength$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _pszText$[ebp]
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 __vsnprintf
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 52   :         va_end(va);

  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 53   :     }
; 54   :     else

  00052	eb 34		 jmp	 SHORT $L49643
$L49638:

; 55   :     {
; 56   :         DPF_ERROR("String %lu not found", nResourceId);

  00054	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  00059	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@ONNK@FormatStringResource?$AA@ ; `string'
  0005e	6a 38		 push	 56			; 00000038H
  00060	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@HIPI@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00065	6a 01		 push	 1
  00067	6a 09		 push	 9
  00069	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0006e	83 c4 18	 add	 esp, 24			; 00000018H
  00071	8b 55 10	 mov	 edx, DWORD PTR _nResourceId$[ebp]
  00074	52		 push	 edx
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@FFOO@String?5?$CFlu?5not?5found?$AA@ ; `string'
  0007a	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0007f	83 c4 08	 add	 esp, 8

; 57   :         *pszText = 0;

  00082	8b 45 08	 mov	 eax, DWORD PTR _pszText$[ebp]
  00085	c6 00 00	 mov	 BYTE PTR [eax], 0
$L49643:

; 58   :     }
; 59   : }

  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
_FormatStringResource ENDP
_TEXT	ENDS
PUBLIC	_FormatStringResourceStatic
PUBLIC	??_C@_0BL@KCCG@FormatStringResourceStatic?$AA@	; `string'
_BSS	SEGMENT
?szFinal@?1??FormatStringResourceStatic@@9@4PADA DB 0400H DUP (?) ; `FormatStringResourceStatic'::`2'::szFinal
_BSS	ENDS
;	COMDAT ??_C@_0BL@KCCG@FormatStringResourceStatic?$AA@
CONST	SEGMENT
??_C@_0BL@KCCG@FormatStringResourceStatic?$AA@ DB 'FormatStringResourceSt'
	DB	'atic', 00H					; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _FormatStringResourceStatic
_TEXT	SEGMENT
_nResourceId$ = 8
_szFormat$ = -264
_va$ = -4
_FormatStringResourceStatic PROC NEAR			; COMDAT

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H

; 88   :     static TCHAR            szFinal[0x400];
; 89   :     TCHAR                   szFormat[0x100];
; 90   :     va_list                 va;
; 91   : 
; 92   :     if(LoadString(g_hInstance, nResourceId, szFormat, NUMELMS(szFormat)))

  00009	68 00 01 00 00	 push	 256			; 00000100H
  0000e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szFormat$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _nResourceId$[ebp]
  00018	51		 push	 ecx
  00019	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_hInstance
  0001f	52		 push	 edx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadStringA@16
  00026	85 c0		 test	 eax, eax
  00028	74 2c		 je	 SHORT $L49655

; 93   :     {
; 94   :         va_start(va, nResourceId);

  0002a	8d 45 0c	 lea	 eax, DWORD PTR _nResourceId$[ebp+4]
  0002d	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 95   :         _vsntprintf(szFinal, NUMELMS(szFinal), szFormat, va);

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  00033	51		 push	 ecx
  00034	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szFormat$[ebp]
  0003a	52		 push	 edx
  0003b	68 00 04 00 00	 push	 1024			; 00000400H
  00040	68 00 00 00 00	 push	 OFFSET FLAT:?szFinal@?1??FormatStringResourceStatic@@9@4PADA
  00045	e8 00 00 00 00	 call	 __vsnprintf
  0004a	83 c4 10	 add	 esp, 16			; 00000010H

; 96   :         va_end(va);

  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 97   :     }
; 98   :     else

  00054	eb 35		 jmp	 SHORT $L49660
$L49655:

; 99   :     {
; 100  :         DPF_ERROR("String %lu not found", nResourceId);

  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@KCCG@FormatStringResourceStatic?$AA@ ; `string'
  00060	6a 64		 push	 100			; 00000064H
  00062	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@HIPI@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00067	6a 01		 push	 1
  00069	6a 09		 push	 9
  0006b	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00070	83 c4 18	 add	 esp, 24			; 00000018H
  00073	8b 45 08	 mov	 eax, DWORD PTR _nResourceId$[ebp]
  00076	50		 push	 eax
  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@FFOO@String?5?$CFlu?5not?5found?$AA@ ; `string'
  0007c	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00081	83 c4 08	 add	 esp, 8

; 101  :         szFormat[0] = 0;

  00084	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR _szFormat$[ebp], 0
$L49660:

; 102  :     }
; 103  :     
; 104  :     return szFinal;

  0008b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?szFinal@?1??FormatStringResourceStatic@@9@4PADA

; 105  : }

  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
_FormatStringResourceStatic ENDP
_TEXT	ENDS
PUBLIC	_ParseCommandLine@12
PUBLIC	??_C@_05EAGJ@TCHAR?$AA@				; `string'
EXTRN	_strlen:NEAR
EXTRN	?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z:NEAR ; DirectSound::CMemoryManager::TrackingPoolAlloc
EXTRN	?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z:NEAR ; DirectSound::CMemoryManager::TrackingPoolFree
;	COMDAT ??_C@_05EAGJ@TCHAR?$AA@
CONST	SEGMENT
??_C@_05EAGJ@TCHAR?$AA@ DB 'TCHAR', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _ParseCommandLine@12
_TEXT	SEGMENT
_pszCmdLine$ = 8
_ppszParsed$ = 12
_pnArgCount$ = 16
_fOpenQuote$ = -4
_nArgCount$ = -16
_pszParsed$ = -12
_pszDest$ = -8
_ParseCommandLine@12 PROC NEAR				; COMDAT

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 137  :     BOOL                    fOpenQuote  = FALSE;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fOpenQuote$[ebp], 0

; 138  :     UINT                    nArgCount   = 1;

  0000d	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _nArgCount$[ebp], 1

; 139  :     LPTSTR                  pszParsed;
; 140  :     LPTSTR                  pszDest;
; 141  : 
; 142  :     //
; 143  :     // Allocate a string large enough to hold the double-NULL terminated
; 144  :     // version of the arguments
; 145  :     //
; 146  : 
; 147  :     if(!(pszDest = pszParsed = MEMALLOC(TCHAR, _tcslen(pszCmdLine) + 2)))

  00014	6a 01		 push	 1
  00016	8b 45 08	 mov	 eax, DWORD PTR _pszCmdLine$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _strlen
  0001f	83 c4 04	 add	 esp, 4
  00022	83 c0 02	 add	 eax, 2
  00025	50		 push	 eax
  00026	68 44 53 64 61	 push	 1633964868		; 61645344H
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05EAGJ@TCHAR?$AA@ ; `string'
  00030	68 93 00 00 00	 push	 147			; 00000093H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@HIPI@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0003a	e8 00 00 00 00	 call	 ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingPoolAlloc
  0003f	89 45 f4	 mov	 DWORD PTR _pszParsed$[ebp], eax
  00042	8b 4d f4	 mov	 ecx, DWORD PTR _pszParsed$[ebp]
  00045	89 4d f8	 mov	 DWORD PTR _pszDest$[ebp], ecx
  00048	83 7d f8 00	 cmp	 DWORD PTR _pszDest$[ebp], 0
  0004c	75 07		 jne	 SHORT $L49673

; 148  :     {
; 149  :         return FALSE;

  0004e	33 c0		 xor	 eax, eax
  00050	e9 f5 00 00 00	 jmp	 $L49666
$L49673:
$L49676:

; 150  :     }
; 151  : 
; 152  :     //
; 153  :     // Start coopying parameters
; 154  :     //
; 155  : 
; 156  :     while(*pszCmdLine)

  00055	8b 55 08	 mov	 edx, DWORD PTR _pszCmdLine$[ebp]
  00058	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0005b	85 c0		 test	 eax, eax
  0005d	0f 84 a8 00 00
	00		 je	 $L49677
$L49679:

; 157  :     {
; 158  :         //
; 159  :         // Skip leading whitespace
; 160  :         //
; 161  : 
; 162  :         while(TEXT(' ') == *pszCmdLine)

  00063	8b 4d 08	 mov	 ecx, DWORD PTR _pszCmdLine$[ebp]
  00066	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00069	83 fa 20	 cmp	 edx, 32			; 00000020H
  0006c	75 0b		 jne	 SHORT $L49680

; 163  :         {
; 164  :             pszCmdLine++;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _pszCmdLine$[ebp]
  00071	83 c0 01	 add	 eax, 1
  00074	89 45 08	 mov	 DWORD PTR _pszCmdLine$[ebp], eax

; 165  :         }

  00077	eb ea		 jmp	 SHORT $L49679
$L49680:
$L49682:

; 166  : 
; 167  :         //
; 168  :         // Copy characters up to the next unquoted space
; 169  :         //
; 170  : 
; 171  :         while(TRUE)

  00079	b9 01 00 00 00	 mov	 ecx, 1
  0007e	85 c9		 test	 ecx, ecx
  00080	0f 84 80 00 00
	00		 je	 $L49683

; 172  :         {
; 173  :             if(!*pszCmdLine)

  00086	8b 55 08	 mov	 edx, DWORD PTR _pszCmdLine$[ebp]
  00089	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0008c	85 c0		 test	 eax, eax
  0008e	75 11		 jne	 SHORT $L49684

; 174  :             {
; 175  :                 *pszDest++ = 0;

  00090	8b 4d f8	 mov	 ecx, DWORD PTR _pszDest$[ebp]
  00093	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00096	8b 55 f8	 mov	 edx, DWORD PTR _pszDest$[ebp]
  00099	83 c2 01	 add	 edx, 1
  0009c	89 55 f8	 mov	 DWORD PTR _pszDest$[ebp], edx

; 176  :                 break;

  0009f	eb 65		 jmp	 SHORT $L49683
$L49684:

; 177  :             }
; 178  :             else if(TEXT('\"') == *pszCmdLine)

  000a1	8b 45 08	 mov	 eax, DWORD PTR _pszCmdLine$[ebp]
  000a4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000a7	83 f9 22	 cmp	 ecx, 34			; 00000022H
  000aa	75 0e		 jne	 SHORT $L49686

; 179  :             {
; 180  :                 fOpenQuote = !fOpenQuote;

  000ac	33 d2		 xor	 edx, edx
  000ae	83 7d fc 00	 cmp	 DWORD PTR _fOpenQuote$[ebp], 0
  000b2	0f 94 c2	 sete	 dl
  000b5	89 55 fc	 mov	 DWORD PTR _fOpenQuote$[ebp], edx

; 181  :             }
; 182  :             else if((TEXT(' ') == *pszCmdLine) && !fOpenQuote)

  000b8	eb 3e		 jmp	 SHORT $L49687
$L49686:
  000ba	8b 45 08	 mov	 eax, DWORD PTR _pszCmdLine$[ebp]
  000bd	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000c0	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000c3	75 20		 jne	 SHORT $L49688
  000c5	83 7d fc 00	 cmp	 DWORD PTR _fOpenQuote$[ebp], 0
  000c9	75 1a		 jne	 SHORT $L49688

; 183  :             {
; 184  :                 nArgCount++;

  000cb	8b 55 f0	 mov	 edx, DWORD PTR _nArgCount$[ebp]
  000ce	83 c2 01	 add	 edx, 1
  000d1	89 55 f0	 mov	 DWORD PTR _nArgCount$[ebp], edx

; 185  :                 *pszDest++ = 0;

  000d4	8b 45 f8	 mov	 eax, DWORD PTR _pszDest$[ebp]
  000d7	c6 00 00	 mov	 BYTE PTR [eax], 0
  000da	8b 4d f8	 mov	 ecx, DWORD PTR _pszDest$[ebp]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	89 4d f8	 mov	 DWORD PTR _pszDest$[ebp], ecx

; 186  :                 break;

  000e3	eb 21		 jmp	 SHORT $L49683
$L49688:

; 187  :             }
; 188  :             else
; 189  :             {
; 190  :                 *pszDest++ = *pszCmdLine;

  000e5	8b 55 f8	 mov	 edx, DWORD PTR _pszDest$[ebp]
  000e8	8b 45 08	 mov	 eax, DWORD PTR _pszCmdLine$[ebp]
  000eb	8a 08		 mov	 cl, BYTE PTR [eax]
  000ed	88 0a		 mov	 BYTE PTR [edx], cl
  000ef	8b 55 f8	 mov	 edx, DWORD PTR _pszDest$[ebp]
  000f2	83 c2 01	 add	 edx, 1
  000f5	89 55 f8	 mov	 DWORD PTR _pszDest$[ebp], edx
$L49687:

; 191  :             }
; 192  : 
; 193  :             pszCmdLine++;

  000f8	8b 45 08	 mov	 eax, DWORD PTR _pszCmdLine$[ebp]
  000fb	83 c0 01	 add	 eax, 1
  000fe	89 45 08	 mov	 DWORD PTR _pszCmdLine$[ebp], eax

; 194  :         }

  00101	e9 73 ff ff ff	 jmp	 $L49682
$L49683:

; 195  :     }

  00106	e9 4a ff ff ff	 jmp	 $L49676
$L49677:

; 196  : 
; 197  :     *pszDest = 0;

  0010b	8b 4d f8	 mov	 ecx, DWORD PTR _pszDest$[ebp]
  0010e	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 198  : 
; 199  :     //
; 200  :     // Fill out parameters
; 201  :     //
; 202  : 
; 203  :     if(ppszParsed)

  00111	83 7d 0c 00	 cmp	 DWORD PTR _ppszParsed$[ebp], 0
  00115	74 0a		 je	 SHORT $L49690

; 204  :     {
; 205  :         *ppszParsed = pszParsed;

  00117	8b 55 0c	 mov	 edx, DWORD PTR _ppszParsed$[ebp]
  0011a	8b 45 f4	 mov	 eax, DWORD PTR _pszParsed$[ebp]
  0011d	89 02		 mov	 DWORD PTR [edx], eax

; 206  :     }
; 207  :     else

  0011f	eb 16		 jmp	 SHORT $L49691
$L49690:

; 208  :     {
; 209  :         MEMFREE(pszParsed);

  00121	83 7d f4 00	 cmp	 DWORD PTR _pszParsed$[ebp], 0
  00125	74 10		 je	 SHORT $L49692
  00127	8b 4d f4	 mov	 ecx, DWORD PTR _pszParsed$[ebp]
  0012a	51		 push	 ecx
  0012b	e8 00 00 00 00	 call	 ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPoolFree
  00130	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pszParsed$[ebp], 0
$L49692:
$L49691:

; 210  :     }
; 211  : 
; 212  :     if(pnArgCount)

  00137	83 7d 10 00	 cmp	 DWORD PTR _pnArgCount$[ebp], 0
  0013b	74 08		 je	 SHORT $L49693

; 213  :     {
; 214  :         *pnArgCount = nArgCount;

  0013d	8b 55 10	 mov	 edx, DWORD PTR _pnArgCount$[ebp]
  00140	8b 45 f0	 mov	 eax, DWORD PTR _nArgCount$[ebp]
  00143	89 02		 mov	 DWORD PTR [edx], eax
$L49693:

; 215  :     }
; 216  : 
; 217  :     return TRUE;

  00145	b8 01 00 00 00	 mov	 eax, 1
$L49666:

; 218  : }

  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c2 0c 00	 ret	 12			; 0000000cH
_ParseCommandLine@12 ENDP
_TEXT	ENDS
PUBLIC	_GetXDKVersion@4
PUBLIC	??_C@_0M@BPPI@?$CFlu?4?$CFlu?4?$CFlu?$AA@	; `string'
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_0M@BPPI@?$CFlu?4?$CFlu?4?$CFlu?$AA@
CONST	SEGMENT
??_C@_0M@BPPI@?$CFlu?4?$CFlu?4?$CFlu?$AA@ DB '%lu.%lu.%lu', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _GetXDKVersion@4
_TEXT	SEGMENT
_pszString$ = 8
_GetXDKVersion@4 PROC NEAR				; COMDAT

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  :     static const DWORD      dwMajor = (VER_PRODUCTVERSION_DW >> 24) & 0xFF;
; 246  :     static const DWORD      dwMinor = (VER_PRODUCTVERSION_DW >> 16) & 0xFF;
; 247  :     static const DWORD      dwBuild = VER_PRODUCTVERSION_DW & 0xFFFF;
; 248  :     
; 249  :     _stprintf(pszString, TEXT("%lu.%lu.%lu"), dwMajor, dwMinor, dwBuild);

  00003	68 30 11 00 00	 push	 4400			; 00001130H
  00008	6a 00		 push	 0
  0000a	6a 01		 push	 1
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@BPPI@?$CFlu?4?$CFlu?4?$CFlu?$AA@ ; `string'
  00011	8b 45 08	 mov	 eax, DWORD PTR _pszString$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _sprintf
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 250  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
_GetXDKVersion@4 ENDP
_TEXT	ENDS
PUBLIC	_FormatNumber@16
EXTRN	_abs:NEAR
EXTRN	__strrev:NEAR
; Function compile flags: /Odt
;	COMDAT _FormatNumber@16
_TEXT	SEGMENT
_nValue$ = 8
_fSigned$ = 12
_fThousands$ = 16
_pszString$ = 20
_psz$ = -12
_nDigits$ = -8
_uValue$ = -4
_FormatNumber@16 PROC NEAR				; COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 283  :     LPSTR                   psz     = pszString;

  00006	8b 45 14	 mov	 eax, DWORD PTR _pszString$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR _psz$[ebp], eax

; 284  :     UINT                    nDigits = 0;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nDigits$[ebp], 0

; 285  :     UINT                    uValue;
; 286  :     
; 287  :     if(nValue)

  00013	83 7d 08 00	 cmp	 DWORD PTR _nValue$[ebp], 0
  00017	0f 84 09 01 00
	00		 je	 $L49713

; 288  :     {
; 289  :         if(!fSigned || (nValue > 0))

  0001d	83 7d 0c 00	 cmp	 DWORD PTR _fSigned$[ebp], 0
  00021	74 06		 je	 SHORT $L49715
  00023	83 7d 08 00	 cmp	 DWORD PTR _nValue$[ebp], 0
  00027	7e 74		 jle	 SHORT $L49714
$L49715:

; 290  :         {
; 291  :             uValue = (UINT)nValue;

  00029	8b 4d 08	 mov	 ecx, DWORD PTR _nValue$[ebp]
  0002c	89 4d fc	 mov	 DWORD PTR _uValue$[ebp], ecx
$L49718:

; 292  :             
; 293  :             while(uValue)

  0002f	83 7d fc 00	 cmp	 DWORD PTR _uValue$[ebp], 0
  00033	74 63		 je	 SHORT $L49719

; 294  :             {
; 295  :                 *psz++ = TEXT('0') + (uValue % 10);

  00035	8b 45 fc	 mov	 eax, DWORD PTR _uValue$[ebp]
  00038	33 d2		 xor	 edx, edx
  0003a	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0003f	f7 f1		 div	 ecx
  00041	83 c2 30	 add	 edx, 48			; 00000030H
  00044	8b 45 f4	 mov	 eax, DWORD PTR _psz$[ebp]
  00047	88 10		 mov	 BYTE PTR [eax], dl
  00049	8b 4d f4	 mov	 ecx, DWORD PTR _psz$[ebp]
  0004c	83 c1 01	 add	 ecx, 1
  0004f	89 4d f4	 mov	 DWORD PTR _psz$[ebp], ecx

; 296  : 
; 297  :                 uValue /= 10;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _uValue$[ebp]
  00055	33 d2		 xor	 edx, edx
  00057	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0005c	f7 f1		 div	 ecx
  0005e	89 45 fc	 mov	 DWORD PTR _uValue$[ebp], eax

; 298  : 
; 299  :                 if(uValue && fThousands)

  00061	83 7d fc 00	 cmp	 DWORD PTR _uValue$[ebp], 0
  00065	74 26		 je	 SHORT $L49720
  00067	83 7d 10 00	 cmp	 DWORD PTR _fThousands$[ebp], 0
  0006b	74 20		 je	 SHORT $L49720

; 300  :                 {
; 301  :                     if(2 == (nDigits % 3))

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _nDigits$[ebp]
  00070	33 d2		 xor	 edx, edx
  00072	b9 03 00 00 00	 mov	 ecx, 3
  00077	f7 f1		 div	 ecx
  00079	83 fa 02	 cmp	 edx, 2
  0007c	75 0f		 jne	 SHORT $L49721

; 302  :                     {
; 303  :                         *psz++ = TEXT(',');

  0007e	8b 55 f4	 mov	 edx, DWORD PTR _psz$[ebp]
  00081	c6 02 2c	 mov	 BYTE PTR [edx], 44	; 0000002cH
  00084	8b 45 f4	 mov	 eax, DWORD PTR _psz$[ebp]
  00087	83 c0 01	 add	 eax, 1
  0008a	89 45 f4	 mov	 DWORD PTR _psz$[ebp], eax
$L49721:
$L49720:

; 304  :                     }
; 305  :                 }
; 306  : 
; 307  :                 nDigits++;

  0008d	8b 4d f8	 mov	 ecx, DWORD PTR _nDigits$[ebp]
  00090	83 c1 01	 add	 ecx, 1
  00093	89 4d f8	 mov	 DWORD PTR _nDigits$[ebp], ecx

; 308  :             }

  00096	eb 97		 jmp	 SHORT $L49718
$L49719:

; 309  :         }
; 310  :         else

  00098	e9 87 00 00 00	 jmp	 $L49722
$L49714:

; 311  :         {
; 312  :             uValue = abs(nValue);

  0009d	8b 55 08	 mov	 edx, DWORD PTR _nValue$[ebp]
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 _abs
  000a6	83 c4 04	 add	 esp, 4
  000a9	89 45 fc	 mov	 DWORD PTR _uValue$[ebp], eax
$L49724:

; 313  :             
; 314  :             while(uValue)

  000ac	83 7d fc 00	 cmp	 DWORD PTR _uValue$[ebp], 0
  000b0	74 63		 je	 SHORT $L49725

; 315  :             {
; 316  :                 *psz++ = TEXT('0') + (uValue % 10);

  000b2	8b 45 fc	 mov	 eax, DWORD PTR _uValue$[ebp]
  000b5	33 d2		 xor	 edx, edx
  000b7	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000bc	f7 f1		 div	 ecx
  000be	83 c2 30	 add	 edx, 48			; 00000030H
  000c1	8b 45 f4	 mov	 eax, DWORD PTR _psz$[ebp]
  000c4	88 10		 mov	 BYTE PTR [eax], dl
  000c6	8b 4d f4	 mov	 ecx, DWORD PTR _psz$[ebp]
  000c9	83 c1 01	 add	 ecx, 1
  000cc	89 4d f4	 mov	 DWORD PTR _psz$[ebp], ecx

; 317  : 
; 318  :                 uValue /= 10;

  000cf	8b 45 fc	 mov	 eax, DWORD PTR _uValue$[ebp]
  000d2	33 d2		 xor	 edx, edx
  000d4	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000d9	f7 f1		 div	 ecx
  000db	89 45 fc	 mov	 DWORD PTR _uValue$[ebp], eax

; 319  : 
; 320  :                 if(uValue && fThousands)

  000de	83 7d fc 00	 cmp	 DWORD PTR _uValue$[ebp], 0
  000e2	74 26		 je	 SHORT $L49726
  000e4	83 7d 10 00	 cmp	 DWORD PTR _fThousands$[ebp], 0
  000e8	74 20		 je	 SHORT $L49726

; 321  :                 {
; 322  :                     if(2 == (nDigits % 3))

  000ea	8b 45 f8	 mov	 eax, DWORD PTR _nDigits$[ebp]
  000ed	33 d2		 xor	 edx, edx
  000ef	b9 03 00 00 00	 mov	 ecx, 3
  000f4	f7 f1		 div	 ecx
  000f6	83 fa 02	 cmp	 edx, 2
  000f9	75 0f		 jne	 SHORT $L49727

; 323  :                     {
; 324  :                         *psz++ = TEXT(',');

  000fb	8b 55 f4	 mov	 edx, DWORD PTR _psz$[ebp]
  000fe	c6 02 2c	 mov	 BYTE PTR [edx], 44	; 0000002cH
  00101	8b 45 f4	 mov	 eax, DWORD PTR _psz$[ebp]
  00104	83 c0 01	 add	 eax, 1
  00107	89 45 f4	 mov	 DWORD PTR _psz$[ebp], eax
$L49727:
$L49726:

; 325  :                     }
; 326  :                 }
; 327  : 
; 328  :                 nDigits++;

  0010a	8b 4d f8	 mov	 ecx, DWORD PTR _nDigits$[ebp]
  0010d	83 c1 01	 add	 ecx, 1
  00110	89 4d f8	 mov	 DWORD PTR _nDigits$[ebp], ecx

; 329  :             }

  00113	eb 97		 jmp	 SHORT $L49724
$L49725:

; 330  : 
; 331  :             *psz++ = TEXT('-');

  00115	8b 55 f4	 mov	 edx, DWORD PTR _psz$[ebp]
  00118	c6 02 2d	 mov	 BYTE PTR [edx], 45	; 0000002dH
  0011b	8b 45 f4	 mov	 eax, DWORD PTR _psz$[ebp]
  0011e	83 c0 01	 add	 eax, 1
  00121	89 45 f4	 mov	 DWORD PTR _psz$[ebp], eax
$L49722:

; 332  :         }
; 333  :     }
; 334  :     else

  00124	eb 0f		 jmp	 SHORT $L49728
$L49713:

; 335  :     {
; 336  :         *psz++ = TEXT('0');

  00126	8b 4d f4	 mov	 ecx, DWORD PTR _psz$[ebp]
  00129	c6 01 30	 mov	 BYTE PTR [ecx], 48	; 00000030H
  0012c	8b 55 f4	 mov	 edx, DWORD PTR _psz$[ebp]
  0012f	83 c2 01	 add	 edx, 1
  00132	89 55 f4	 mov	 DWORD PTR _psz$[ebp], edx
$L49728:

; 337  :     }
; 338  : 
; 339  :     *psz = 0;

  00135	8b 45 f4	 mov	 eax, DWORD PTR _psz$[ebp]
  00138	c6 00 00	 mov	 BYTE PTR [eax], 0

; 340  : 
; 341  :     _tcsrev(pszString);

  0013b	8b 4d 14	 mov	 ecx, DWORD PTR _pszString$[ebp]
  0013e	51		 push	 ecx
  0013f	e8 00 00 00 00	 call	 __strrev
  00144	83 c4 04	 add	 esp, 4

; 342  : }

  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 10 00	 ret	 16			; 00000010H
_FormatNumber@16 ENDP
_TEXT	ENDS
PUBLIC	_MsgBoxV@16
EXTRN	_g_szAppTitle:BYTE
EXTRN	__imp__MessageBoxA@16:NEAR
EXTRN	__imp__SetFocus@4:NEAR
EXTRN	__imp__GetFocus@0:NEAR
; Function compile flags: /Odt
;	COMDAT _MsgBoxV@16
_TEXT	SEGMENT
_hWnd$ = 8
_dwFlags$ = 12
_pszText$ = 16
_va$ = 20
_szText$ = -1032
_nResult$ = -1036
_hWndFocus$ = -4
_MsgBoxV@16 PROC NEAR					; COMDAT

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 04 00
	00		 sub	 esp, 1036		; 0000040cH

; 375  :     TCHAR                   szText[0x400];
; 376  :     UINT                    nResult;
; 377  :     HWND                    hWndFocus;
; 378  : 
; 379  :     //
; 380  :     // Save the current keyboard focus
; 381  :     //
; 382  : 
; 383  :     hWndFocus = GetFocus();

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFocus@0
  0000f	89 45 fc	 mov	 DWORD PTR _hWndFocus$[ebp], eax

; 384  : 
; 385  :     //
; 386  :     // Create the text string
; 387  :     //
; 388  : 
; 389  :     _vsntprintf(szText, NUMELMS(szText), pszText, va);

  00012	8b 45 14	 mov	 eax, DWORD PTR _va$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 10	 mov	 ecx, DWORD PTR _pszText$[ebp]
  00019	51		 push	 ecx
  0001a	68 00 04 00 00	 push	 1024			; 00000400H
  0001f	8d 95 f8 fb ff
	ff		 lea	 edx, DWORD PTR _szText$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 __vsnprintf
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 390  : 
; 391  :     //
; 392  :     // Display the message
; 393  :     //
; 394  : 
; 395  :     nResult = MessageBox(hWnd, szText, g_szAppTitle, dwFlags);

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00031	50		 push	 eax
  00032	68 00 00 00 00	 push	 OFFSET FLAT:_g_szAppTitle
  00037	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _szText$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 55 08	 mov	 edx, DWORD PTR _hWnd$[ebp]
  00041	52		 push	 edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00048	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _nResult$[ebp], eax

; 396  : 
; 397  :     //
; 398  :     // Restore focus
; 399  :     //
; 400  : 
; 401  :     SetFocus(hWndFocus);

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _hWndFocus$[ebp]
  00051	50		 push	 eax
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 402  : 
; 403  :     return nResult;

  00058	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _nResult$[ebp]

; 404  : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 10 00	 ret	 16			; 00000010H
_MsgBoxV@16 ENDP
_TEXT	ENDS
PUBLIC	_MsgBox
; Function compile flags: /Odt
;	COMDAT _MsgBox
_TEXT	SEGMENT
_hWnd$ = 8
_dwFlags$ = 12
_pszText$ = 16
_va$ = -4
_nResult$ = -8
_MsgBox	PROC NEAR					; COMDAT

; 436  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 437  :     va_list                 va;
; 438  :     UINT                    nResult;
; 439  : 
; 440  :     va_start(va, pszText);

  00006	8d 45 14	 lea	 eax, DWORD PTR _pszText$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 441  : 
; 442  :     nResult = MsgBoxV(hWnd, dwFlags, pszText, va);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 10	 mov	 edx, DWORD PTR _pszText$[ebp]
  00013	52		 push	 edx
  00014	8b 45 0c	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 _MsgBoxV@16
  00021	89 45 f8	 mov	 DWORD PTR _nResult$[ebp], eax

; 443  : 
; 444  :     va_end(va);

  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 445  : 
; 446  :     return nResult;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _nResult$[ebp]

; 447  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_MsgBox	ENDP
_TEXT	ENDS
PUBLIC	_MsgBoxResource
; Function compile flags: /Odt
;	COMDAT _MsgBoxResource
_TEXT	SEGMENT
_hWnd$ = 8
_dwFlags$ = 12
_nStringResourceId$ = 16
_szFormat$ = -264
_va$ = -4
_nResult$ = -268
_MsgBoxResource PROC NEAR				; COMDAT

; 479  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH

; 480  :     TCHAR                   szFormat[0x100];
; 481  :     va_list                 va;
; 482  :     UINT                    nResult;
; 483  : 
; 484  :     LoadString(g_hInstance, nStringResourceId, szFormat, NUMELMS(szFormat));

  00009	68 00 01 00 00	 push	 256			; 00000100H
  0000e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szFormat$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 10	 mov	 ecx, DWORD PTR _nStringResourceId$[ebp]
  00018	51		 push	 ecx
  00019	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_hInstance
  0001f	52		 push	 edx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadStringA@16

; 485  :     
; 486  :     va_start(va, nStringResourceId);

  00026	8d 45 14	 lea	 eax, DWORD PTR _nStringResourceId$[ebp+4]
  00029	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 487  :     
; 488  :     nResult = MsgBoxV(hWnd, dwFlags, szFormat, va);

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  0002f	51		 push	 ecx
  00030	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szFormat$[ebp]
  00036	52		 push	 edx
  00037	8b 45 0c	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 _MsgBoxV@16
  00044	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _nResult$[ebp], eax

; 489  :     
; 490  :     va_end(va);

  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 491  : 
; 492  :     return nResult;

  00051	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _nResult$[ebp]

; 493  : }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_MsgBoxResource ENDP
_TEXT	ENDS
END
