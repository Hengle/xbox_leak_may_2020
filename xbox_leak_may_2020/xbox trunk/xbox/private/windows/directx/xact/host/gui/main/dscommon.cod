; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	c:\xbox\private\windows\directx\xact\host\gui\main\dscommon.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DPKL@?$CIunknown?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06NPGC@?$CInone?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MKNO@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@GKFF@?$CBm_dwRefCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GLPL@m_dwRefCount?5?$DM?5?$HO0UL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BGIF@m_dwRefCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@CGCA@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BEIE@this?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@GMNP@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EC@CLP@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GHLG@hdc?5?$DN?$DN?5m_hdc?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KMJF@ADPCM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HMEK@8?9bit?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KCDF@CWaveBankEntry?$CIthis?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@EKAA@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDJN@CWaveBank?$CIthis?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@PLCC@CGuiWaveBankEntry?$CIthis?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@OJDF@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@HCEK@CGuiWaveBank?$CIthis?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HPGM@?$CFs?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GGMM@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JFHJ@?$CFhs?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07GHMC@?$CF?48lx?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07MKMO@Error?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@IMNF@Resource?5failure?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NLAH@Warning?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@HJBP@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@OGHG@Assertion?5failed?5in?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07PKF@?0?5line?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02CGGM@?3?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08KCAL@cbBuffer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07FEMJ@XACTGUI?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@BHJJ@CMemoryManager?3?3PoolAlloc?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@LFMI@Out?5of?5pool?5memory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08KLJN@pvBuffer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@JMGJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BFD@dwFlags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@LELL@CMemoryManager?3?3PhysicalAlloc?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MFKD@Out?5of?5contiguous?5memory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@EFP@pvBaseAddress?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@NOEM@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06DOGD@cbSize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@EOH@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@EGEG@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@CNJN@Begin?5memory?5usage?5dump?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@HDD@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@PGGD@Pool?5memory?5used?3?5?5?$CFlu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@MNK@Physical?5memory?5used?3?5?5?$CFlu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@LFMD@End?5memory?5usage?5dump?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@GIH@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@JMDO@IsListEmpty?$CI?$CGm_lstMemoryTracking@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04PBHC@pwfx?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MJPI@pDest?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07JEGE@pSource?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@MOEB@Unexpected?5format?5tag?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@NKLB@WaveFormat?3?3IsValidFormat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@MKMD@Unsupported?5format?5tag?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@OKFK@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@GBOE@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@GMMP@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@IKOG@Format?5tag?5not?5PCM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@DNIK@Invalid?5channel?5count?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@NALA@Invalid?5sample?5bit?5resolution?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@PDOD@Invalid?5sampling?5rate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@CHML@Bad?5block?5alignment?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@ILPH@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@HOLG@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@CADJ@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@OFFM@Format?5tag?5not?5XBOX_ADPCM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@DKJO@cbSize?5not?5?$CFlu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@GLJN@Invalid?5samples?5per?5block?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@OJBC@Bad?5block?9alignment?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@LGGN@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@EAAG@CStdFileStream?3?3Open?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@CAJD@Error?5?$CFlu?5occurred?5trying?5to?5ope@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@OPLH@CStdFileStream?3?3Read?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DHDM@Error?5?$CFlu?5occurred?5reading?5from?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@ONHL@Not?5enough?5data?5was?5read?5from?5th@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBDH@CStdFileStream?3?3Write?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@MCKM@Error?5?$CFlu?5occurred?5writing?5to?5th@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@MMCK@Not?5enough?5data?5was?5written?5from@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@JBBC@CStdFileStream?3?3Seek?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@PFDI@Error?5?$CFlu?5occurred?5seeking?5the?5f@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@LINH@CStdFileStream?3?3GetLength?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@CIMA@Error?5?$CFlu?5attempting?5to?5get?5the?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@EPJI@CRiffChunk?3?3Read?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@LIHM@Attempted?5to?5read?5past?5the?5end?5o@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@DPCC@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPN@CWaveFile?3?3Open?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@LAOA@The?5file?5type?5is?5not?5WAVE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@CCLG@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@MPHA@The?5file?8s?5AIFF?9C?5version?5is?5not@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04EHOP@BYTE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@OAHJ@m_pwfxFormat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@DJPM@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@DNJG@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KIEA@CWaveFile?3?3GetAiffFormat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@IGMG@Unsupported?5AIFF?5compression?5typ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@FFJO@CStdFileStream?3?3GetWaveLoopRegio@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@EIKN@No?5FORWARD?5loop?5regions?5found?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@ENEM@Only?5the?5first?5FORWARD?5loop?5will@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@EGGG@Neither?5loop?5is?5FORWARD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DF@PJLL@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@INFE@Can?8t?5find?5loop?5start?5marker?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@DPMK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKN@Can?8t?5find?5loop?5end?5marker?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@DCLE@Loop?5end?5point?5less?9than?9or?9equa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@CGPO@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GOLD@8?5?$DN?$DN?5dwBitDepth?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPBDK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCRefCount@DirectSound@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRefCount@DirectSound@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CRefCount@DirectSound@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CRefCount@DirectSound@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataOffset@CRiffChunk@WaveLoader@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnCommand@CWindow@@UAEHIIPAUHWND__@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RestoreObject@CTempSelectObject@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetResolution@CWaveformRenderer@@UAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSourceAlignment@CXboxAdpcmFilter@@SGKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDestinationAlignment@CXboxAdpcmFilter@@SGKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@CXboxAdpcmFilter@@SGKKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBankHeaderSize@CWaveBank@@KGKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dstrcpy@@YGPADPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Print@CDebug@DirectSound@@SAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Break@CDebug@DirectSound@@SAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndianSwapWord@@YIGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndianSwapDword@@YIKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CStdFileStream@WaveLoader@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CStdFileStream@WaveLoader@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Close@CStdFileStream@WaveLoader@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRiffChunk@WaveLoader@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRiffChunk@WaveLoader@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWaveFile@WaveLoader@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWaveFile@WaveLoader@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Close@CWaveFile@WaveLoader@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CImaAdpcmCodec@DirectSound@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CImaAdpcmCodec@DirectSound@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CImaAdpcmCodec@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CRefCount@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?m_asNextStep@CImaAdpcmCodec@DirectSound@@0QBFB	; DirectSound::CImaAdpcmCodec::m_asNextStep
PUBLIC	?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB	; DirectSound::CImaAdpcmCodec::m_asStep
PUBLIC	?m_dwDpfLevel@CDebug@DirectSound@@2KA		; DirectSound::CDebug::m_dwDpfLevel
PUBLIC	?m_dwDpfBreakLevel@CDebug@DirectSound@@2KA	; DirectSound::CDebug::m_dwDpfBreakLevel
PUBLIC	?m_fDebugBreak@CDebug@DirectSound@@2HA		; DirectSound::CDebug::m_fDebugBreak
PUBLIC	?m_pfnDpfCallback@CDebug@DirectSound@@2P6GXKPBD@ZA ; DirectSound::CDebug::m_pfnDpfCallback
PUBLIC	?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A ; DirectSound::CDebug::m_aContext
PUBLIC	?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
PUBLIC	?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
PUBLIC	?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
PUBLIC	??_C@_0EP@HJBP@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ ; `string'
PUBLIC	??_C@_0EP@EGEG@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
_BSS	SEGMENT
?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA DD 04H DUP (?) ; `DirectSound::CImaAdpcmCodec::Initialize'::`2'::apfnConvert
?m_fDebugBreak@CDebug@DirectSound@@2HA DD 01H DUP (?)	; DirectSound::CDebug::m_fDebugBreak
?m_pfnDpfCallback@CDebug@DirectSound@@2P6GXKPBD@ZA DD 01H DUP (?) ; DirectSound::CDebug::m_pfnDpfCallback
?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A DB 018H DUP (?) ; DirectSound::CDebug::m_aContext
?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA DD 01H DUP (?) ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2KA DD 01H DUP (?) ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A DQ 01H DUP (?) ; DirectSound::CMemoryManager::m_lstMemoryTracking
_BSS	ENDS
_DATA	SEGMENT
?m_dwDpfLevel@CDebug@DirectSound@@2KA DD 03H		; DirectSound::CDebug::m_dwDpfLevel
?m_dwDpfBreakLevel@CDebug@DirectSound@@2KA DD 02H	; DirectSound::CDebug::m_dwDpfBreakLevel
_DATA	ENDS
CONST	SEGMENT
?irql@?1??SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z@4IB DD 00H ; `DirectSound::CDebug::SetContext'::`2'::irql
?irql@?1??Print@CDebug@DirectSound@@SAXPBDZZ@4IB DD 00H	; `DirectSound::CDebug::Print'::`2'::irql
CONST	ENDS
;	COMDAT ??_C@_0EP@HJBP@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
CONST	SEGMENT
??_C@_0EP@HJBP@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ DB '*'
	DB	'*************************************************************'
	DB	'****************', 00H			; `string'
CONST	ENDS
CONST	SEGMENT
?pszBanner@?1??Assert@CDebug@DirectSound@@SAXHPBD0I@Z@4QBDB DD FLAT:??_C@_0EP@HJBP@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ ; `DirectSound::CDebug::Assert'::`2'::pszBanner
?cbLowerThreshold@?1??PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z@4KB DD 020H ; `DirectSound::CMemoryManager::PoolAlloc'::`2'::cbLowerThreshold
?cbUpperThreshold@?1??PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z@4KB DD 0fd8H ; `DirectSound::CMemoryManager::PoolAlloc'::`2'::cbUpperThreshold
?cbTracking@?1??TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z@4KB DD 020H ; `DirectSound::CMemoryManager::TrackingPoolAlloc'::`2'::cbTracking
CONST	ENDS
;	COMDAT ??_C@_0EP@EGEG@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0EP@EGEG@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'-------------------------------------------------------------'
	DB	'----------------', 00H			; `string'
CONST	ENDS
CONST	SEGMENT
?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB DD FLAT:??_C@_0EP@EGEG@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `DirectSound::CMemoryManager::DumpMemoryUsage'::`2'::pszBanner
?wBitsPerSample@?1??AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUima_adpcmwaveformat_tag@@@Z@4EB DB 04H ; `DirectSound::WaveFormat::AdpcmToInternalFormat'::`2'::wBitsPerSample
	ORG $+1
?wSamplesPerBlock@?1??IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z@4GB DW 040H ; `DirectSound::WaveFormat::IsValidAdpcmFormat'::`2'::wSamplesPerBlock
?wBitsPerSample@?1??IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z@4GB DW 04H ; `DirectSound::WaveFormat::IsValidAdpcmFormat'::`2'::wBitsPerSample
?wBytesPerBlock@?1??IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z@4GB DW 024H ; `DirectSound::WaveFormat::IsValidAdpcmFormat'::`2'::wBytesPerBlock
?m_asNextStep@CImaAdpcmCodec@DirectSound@@0QBFB DW 0ffffH ; DirectSound::CImaAdpcmCodec::m_asNextStep
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	02H
	DW	04H
	DW	06H
	DW	08H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	02H
	DW	04H
	DW	06H
	DW	08H
	ORG $+4
?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB DW 07H	; DirectSound::CImaAdpcmCodec::m_asStep
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	010H
	DW	011H
	DW	013H
	DW	015H
	DW	017H
	DW	019H
	DW	01cH
	DW	01fH
	DW	022H
	DW	025H
	DW	029H
	DW	02dH
	DW	032H
	DW	037H
	DW	03cH
	DW	042H
	DW	049H
	DW	050H
	DW	058H
	DW	061H
	DW	06bH
	DW	076H
	DW	082H
	DW	08fH
	DW	09dH
	DW	0adH
	DW	0beH
	DW	0d1H
	DW	0e6H
	DW	0fdH
	DW	0117H
	DW	0133H
	DW	0151H
	DW	0173H
	DW	0198H
	DW	01c1H
	DW	01eeH
	DW	0220H
	DW	0256H
	DW	0292H
	DW	02d4H
	DW	031cH
	DW	036cH
	DW	03c3H
	DW	0424H
	DW	048eH
	DW	0502H
	DW	0583H
	DW	0610H
	DW	06abH
	DW	0756H
	DW	0812H
	DW	08e0H
	DW	09c3H
	DW	0abdH
	DW	0bd0H
	DW	0cffH
	DW	0e4cH
	DW	0fbaH
	DW	0114cH
	DW	01307H
	DW	014eeH
	DW	01706H
	DW	01954H
	DW	01bdcH
	DW	01ea5H
	DW	021b6H
	DW	02515H
	DW	028caH
	DW	02cdfH
	DW	0315bH
	DW	0364bH
	DW	03bb9H
	DW	041b2H
	DW	04844H
	DW	04f7eH
	DW	05771H
	DW	0602fH
	DW	069ceH
	DW	07462H
	DW	07fffH
CONST	ENDS
PUBLIC	?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z ; DirectSound::CDebug::PrintStaticV
PUBLIC	?Break@CDebug@DirectSound@@SAXXZ		; DirectSound::CDebug::Break
PUBLIC	?dstrcpy@@YGPADPADPBD@Z				; dstrcpy
PUBLIC	??_C@_04HPGM@?$CFs?3?5?$AA@			; `string'
PUBLIC	??_C@_0L@GGMM@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@	; `string'
PUBLIC	??_C@_05JFHJ@?$CFhs?3?5?$AA@			; `string'
PUBLIC	??_C@_07GHMC@?$CF?48lx?3?5?$AA@			; `string'
PUBLIC	??_C@_07MKMO@Error?3?5?$AA@			; `string'
PUBLIC	??_C@_0BD@IMNF@Resource?5failure?3?5?$AA@	; `string'
PUBLIC	??_C@_09NLAH@Warning?3?5?$AA@			; `string'
PUBLIC	??_C@_01BJG@?6?$AA@				; `string'
EXTRN	_sprintf:NEAR
EXTRN	_vsprintf:NEAR
EXTRN	__imp__GetCurrentThreadId@0:NEAR
EXTRN	__imp__OutputDebugStringA@4:NEAR
;	COMDAT ??_C@_04HPGM@?$CFs?3?5?$AA@
; File c:\xbox\private\windows\directx\dsound\common\debug.cpp
CONST	SEGMENT
??_C@_04HPGM@?$CFs?3?5?$AA@ DB '%s: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GGMM@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@
CONST	SEGMENT
??_C@_0L@GGMM@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@ DB '%hs(%lu): ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JFHJ@?$CFhs?3?5?$AA@
CONST	SEGMENT
??_C@_05JFHJ@?$CFhs?3?5?$AA@ DB '%hs: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GHMC@?$CF?48lx?3?5?$AA@
CONST	SEGMENT
??_C@_07GHMC@?$CF?48lx?3?5?$AA@ DB '%.8lx: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MKMO@Error?3?5?$AA@
CONST	SEGMENT
??_C@_07MKMO@Error?3?5?$AA@ DB 'Error: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IMNF@Resource?5failure?3?5?$AA@
CONST	SEGMENT
??_C@_0BD@IMNF@Resource?5failure?3?5?$AA@ DB 'Resource failure: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NLAH@Warning?3?5?$AA@
CONST	SEGMENT
??_C@_09NLAH@Warning?3?5?$AA@ DB 'Warning: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT
??_C@_01BJG@?6?$AA@ DB 0aH, 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z
_TEXT	SEGMENT
_dwFlags$ = 8
_dwLevel$ = 12
_pszFile$ = 16
_nLine$ = 20
_pszFunction$ = 24
_pszLibrary$ = 28
_pszFormat$ = 32
_va$ = 36
_szDebug$ = -1032
_szText$ = -2064
_pszWorking$ = -4
?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z PROC NEAR ; DirectSound::CDebug::PrintStaticV, COMDAT

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 08 00
	00		 sub	 esp, 2068		; 00000814H

; 114  :     CHAR                    szDebug[0x400];
; 115  :     CHAR                    szText[0x400];
; 116  :     LPSTR                   pszWorking;
; 117  :     DWORD                   dwWritten;
; 118  : 
; 119  :     if(dwLevel <= m_dwDpfLevel)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _dwLevel$[ebp]
  0000c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?m_dwDpfLevel@CDebug@DirectSound@@2KA ; DirectSound::CDebug::m_dwDpfLevel
  00012	0f 87 b1 01 00
	00		 ja	 $L52595

; 120  :     {
; 121  :         pszWorking = szDebug;

  00018	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _szDebug$[ebp]
  0001e	89 4d fc	 mov	 DWORD PTR _pszWorking$[ebp], ecx

; 122  : 
; 123  : #ifdef DEBUG
; 124  : 
; 125  :         //
; 126  :         // Add the library name
; 127  :         //
; 128  : 
; 129  :         if((dwFlags & DPF_FLAGS_LIBRARY) && pszLibrary && *pszLibrary)

  00021	8b 55 08	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00024	83 e2 01	 and	 edx, 1
  00027	85 d2		 test	 edx, edx
  00029	74 2d		 je	 SHORT $L52596
  0002b	83 7d 1c 00	 cmp	 DWORD PTR _pszLibrary$[ebp], 0
  0002f	74 27		 je	 SHORT $L52596
  00031	8b 45 1c	 mov	 eax, DWORD PTR _pszLibrary$[ebp]
  00034	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00037	85 c9		 test	 ecx, ecx
  00039	74 1d		 je	 SHORT $L52596

; 130  :         {
; 131  :             pszWorking += sprintf(pszWorking, "%s: ", pszLibrary);

  0003b	8b 55 1c	 mov	 edx, DWORD PTR _pszLibrary$[ebp]
  0003e	52		 push	 edx
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04HPGM@?$CFs?3?5?$AA@ ; `string'
  00044	8b 45 fc	 mov	 eax, DWORD PTR _pszWorking$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _sprintf
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  00053	03 c8		 add	 ecx, eax
  00055	89 4d fc	 mov	 DWORD PTR _pszWorking$[ebp], ecx
$L52596:

; 132  :         }
; 133  : 
; 134  :         //
; 135  :         // Add the source file and line number
; 136  :         //
; 137  : 
; 138  :         if((dwFlags & DPF_FLAGS_FILELINE) && pszFile && *pszFile)

  00058	8b 55 08	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0005b	83 e2 02	 and	 edx, 2
  0005e	85 d2		 test	 edx, edx
  00060	74 31		 je	 SHORT $L52598
  00062	83 7d 10 00	 cmp	 DWORD PTR _pszFile$[ebp], 0
  00066	74 2b		 je	 SHORT $L52598
  00068	8b 45 10	 mov	 eax, DWORD PTR _pszFile$[ebp]
  0006b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0006e	85 c9		 test	 ecx, ecx
  00070	74 21		 je	 SHORT $L52598

; 139  :         {
; 140  :             pszWorking += sprintf(pszWorking, "%hs(%lu): ", pszFile, nLine);

  00072	8b 55 14	 mov	 edx, DWORD PTR _nLine$[ebp]
  00075	52		 push	 edx
  00076	8b 45 10	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@GGMM@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@ ; `string'
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _sprintf
  00088	83 c4 10	 add	 esp, 16			; 00000010H
  0008b	8b 55 fc	 mov	 edx, DWORD PTR _pszWorking$[ebp]
  0008e	03 d0		 add	 edx, eax
  00090	89 55 fc	 mov	 DWORD PTR _pszWorking$[ebp], edx
$L52598:

; 141  :         }
; 142  : 
; 143  :         //
; 144  :         // Add the function name
; 145  :         //
; 146  : 
; 147  :         if((dwFlags & DPF_FLAGS_FUNCTIONNAME) && pszFunction && *pszFunction)

  00093	8b 45 08	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00096	83 e0 08	 and	 eax, 8
  00099	85 c0		 test	 eax, eax
  0009b	74 2d		 je	 SHORT $L52600
  0009d	83 7d 18 00	 cmp	 DWORD PTR _pszFunction$[ebp], 0
  000a1	74 27		 je	 SHORT $L52600
  000a3	8b 4d 18	 mov	 ecx, DWORD PTR _pszFunction$[ebp]
  000a6	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000a9	85 d2		 test	 edx, edx
  000ab	74 1d		 je	 SHORT $L52600

; 148  :         {
; 149  :             pszWorking += sprintf(pszWorking, "%hs: ", pszFunction);

  000ad	8b 45 18	 mov	 eax, DWORD PTR _pszFunction$[ebp]
  000b0	50		 push	 eax
  000b1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05JFHJ@?$CFhs?3?5?$AA@ ; `string'
  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  000b9	51		 push	 ecx
  000ba	e8 00 00 00 00	 call	 _sprintf
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c2	8b 55 fc	 mov	 edx, DWORD PTR _pszWorking$[ebp]
  000c5	03 d0		 add	 edx, eax
  000c7	89 55 fc	 mov	 DWORD PTR _pszWorking$[ebp], edx
$L52600:

; 150  :         }
; 151  : 
; 152  :         //
; 153  :         // Add process and thread id
; 154  :         //
; 155  : 
; 156  :         if(dwFlags & DPF_FLAGS_PROCESSTHREADID)

  000ca	8b 45 08	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  000cd	83 e0 04	 and	 eax, 4
  000d0	85 c0		 test	 eax, eax
  000d2	74 20		 je	 SHORT $L52602

; 157  :         {
; 158  :             pszWorking += sprintf(pszWorking, "%.8lx: ", GetCurrentThreadId());

  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  000da	50		 push	 eax
  000db	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07GHMC@?$CF?48lx?3?5?$AA@ ; `string'
  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  000e3	51		 push	 ecx
  000e4	e8 00 00 00 00	 call	 _sprintf
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ec	8b 55 fc	 mov	 edx, DWORD PTR _pszWorking$[ebp]
  000ef	03 d0		 add	 edx, eax
  000f1	89 55 fc	 mov	 DWORD PTR _pszWorking$[ebp], edx
$L52602:

; 159  :         }
; 160  : 
; 161  :         //
; 162  :         // Add the type of message it is (i.e. error or warning)
; 163  :         //
; 164  : 
; 165  :         switch(dwLevel)
; 166  :         {

  000f4	8b 45 0c	 mov	 eax, DWORD PTR _dwLevel$[ebp]
  000f7	89 85 ec f7 ff
	ff		 mov	 DWORD PTR -2068+[ebp], eax
  000fd	83 bd ec f7 ff
	ff 01		 cmp	 DWORD PTR -2068+[ebp], 1
  00104	74 14		 je	 SHORT $L52608
  00106	83 bd ec f7 ff
	ff 02		 cmp	 DWORD PTR -2068+[ebp], 2
  0010d	74 1e		 je	 SHORT $L52610
  0010f	83 bd ec f7 ff
	ff 03		 cmp	 DWORD PTR -2068+[ebp], 3
  00116	74 28		 je	 SHORT $L52612
  00118	eb 37		 jmp	 SHORT $L52605
$L52608:

; 167  :             case DPFLVL_ERROR:
; 168  :                 pszWorking = dstrcpy(pszWorking, "Error: ");

  0011a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07MKMO@Error?3?5?$AA@ ; `string'
  0011f	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  00128	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax

; 169  :                 break;

  0012b	eb 24		 jmp	 SHORT $L52605
$L52610:

; 170  : 
; 171  :             case DPFLVL_RESOURCE:
; 172  :                 pszWorking = dstrcpy(pszWorking, "Resource failure: ");

  0012d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@IMNF@Resource?5failure?3?5?$AA@ ; `string'
  00132	8b 55 fc	 mov	 edx, DWORD PTR _pszWorking$[ebp]
  00135	52		 push	 edx
  00136	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0013b	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax

; 173  :                 break;

  0013e	eb 11		 jmp	 SHORT $L52605
$L52612:

; 174  : 
; 175  :             case DPFLVL_WARNING:
; 176  :                 pszWorking = dstrcpy(pszWorking, "Warning: ");

  00140	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09NLAH@Warning?3?5?$AA@ ; `string'
  00145	8b 45 fc	 mov	 eax, DWORD PTR _pszWorking$[ebp]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0014e	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax
$L52605:

; 177  :                 break;
; 178  :         }
; 179  : 
; 180  : #endif // DEBUG
; 181  : 
; 182  :         //
; 183  :         // Add the debug string
; 184  :         //
; 185  : 
; 186  :         vsprintf(szText, pszFormat, va);

  00151	8b 4d 24	 mov	 ecx, DWORD PTR _va$[ebp]
  00154	51		 push	 ecx
  00155	8b 55 20	 mov	 edx, DWORD PTR _pszFormat$[ebp]
  00158	52		 push	 edx
  00159	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 _vsprintf
  00165	83 c4 0c	 add	 esp, 12			; 0000000cH

; 187  : 
; 188  : #ifdef DEBUG
; 189  : 
; 190  :         pszWorking = dstrcpy(pszWorking, szText);

  00168	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR _szText$[ebp]
  0016e	51		 push	 ecx
  0016f	8b 55 fc	 mov	 edx, DWORD PTR _pszWorking$[ebp]
  00172	52		 push	 edx
  00173	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  00178	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax

; 191  : 
; 192  :         //
; 193  :         // Add a carriage-return since OutputDebugString doesn't
; 194  :         //
; 195  : 
; 196  :         pszWorking = dstrcpy(pszWorking, "\n");

  0017b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01BJG@?6?$AA@ ; `string'
  00180	8b 45 fc	 mov	 eax, DWORD PTR _pszWorking$[ebp]
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  00189	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax

; 197  : 
; 198  :         //
; 199  :         // Output to the debugger
; 200  :         //
; 201  : 
; 202  :         OutputDebugStringA(szDebug);

  0018c	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _szDebug$[ebp]
  00192	51		 push	 ecx
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 203  : 
; 204  :         //
; 205  :         // Break into the debugger
; 206  :         //
; 207  : 
; 208  :         if(dwLevel && (dwLevel <= m_dwDpfBreakLevel))

  00199	83 7d 0c 00	 cmp	 DWORD PTR _dwLevel$[ebp], 0
  0019d	74 10		 je	 SHORT $L52615
  0019f	8b 55 0c	 mov	 edx, DWORD PTR _dwLevel$[ebp]
  001a2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?m_dwDpfBreakLevel@CDebug@DirectSound@@2KA ; DirectSound::CDebug::m_dwDpfBreakLevel
  001a8	77 05		 ja	 SHORT $L52615

; 209  :         {
; 210  :             Break();

  001aa	e8 00 00 00 00	 call	 ?Break@CDebug@DirectSound@@SAXXZ ; DirectSound::CDebug::Break
$L52615:

; 211  :         }
; 212  : 
; 213  : #endif // DEBUG
; 214  : 
; 215  :         //
; 216  :         // Hand off to the callback routine
; 217  :         //
; 218  : 
; 219  :         if(m_pfnDpfCallback)

  001af	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pfnDpfCallback@CDebug@DirectSound@@2P6GXKPBD@ZA, 0 ; DirectSound::CDebug::m_pfnDpfCallback
  001b6	74 11		 je	 SHORT $L52616

; 220  :         {
; 221  :             m_pfnDpfCallback(dwLevel, szText);

  001b8	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  001be	50		 push	 eax
  001bf	8b 4d 0c	 mov	 ecx, DWORD PTR _dwLevel$[ebp]
  001c2	51		 push	 ecx
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR ?m_pfnDpfCallback@CDebug@DirectSound@@2P6GXKPBD@ZA ; DirectSound::CDebug::m_pfnDpfCallback
$L52616:
$L52595:

; 222  :         }
; 223  :     }
; 224  : }

  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c3		 ret	 0
?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z ENDP ; DirectSound::CDebug::PrintStaticV
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?dstrcpy@@YGPADPADPBD@Z
_TEXT	SEGMENT
_dst$ = 8
_src$ = 12
?dstrcpy@@YGPADPADPBD@Z PROC NEAR			; dstrcpy, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L52579:

; 68   :     while(*dst = *src)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00009	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000b	88 10		 mov	 BYTE PTR [eax], dl
  0000d	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00010	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00013	85 c9		 test	 ecx, ecx
  00015	74 14		 je	 SHORT $L52580

; 69   :     {
; 70   :         dst++;

  00017	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0001a	83 c2 01	 add	 edx, 1
  0001d	89 55 08	 mov	 DWORD PTR _dst$[ebp], edx

; 71   :         src++;

  00020	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00023	83 c0 01	 add	 eax, 1
  00026	89 45 0c	 mov	 DWORD PTR _src$[ebp], eax

; 72   :     }

  00029	eb d8		 jmp	 SHORT $L52579
$L52580:

; 73   :     
; 74   :     return dst;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]

; 75   : }

  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
?dstrcpy@@YGPADPADPBD@Z ENDP				; dstrcpy
_TEXT	ENDS
PUBLIC	?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ	; DirectSound::CDebug::PrintStatic
; Function compile flags: /Odt
;	COMDAT ?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ
_TEXT	SEGMENT
_dwFlags$ = 8
_dwLevel$ = 12
_pszFile$ = 16
_nLine$ = 20
_pszFunction$ = 24
_pszLibrary$ = 28
_pszFormat$ = 32
_va$ = -4
?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ PROC NEAR ; DirectSound::CDebug::PrintStatic, COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 265  :     va_list                 va;
; 266  : 
; 267  :     va_start(va, pszFormat);

  00004	8d 45 24	 lea	 eax, DWORD PTR _pszFormat$[ebp+4]
  00007	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 268  :     PrintStaticV(dwFlags, dwLevel, pszFile, nLine, pszFunction, pszLibrary, pszFormat, va);

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 20	 mov	 edx, DWORD PTR _pszFormat$[ebp]
  00011	52		 push	 edx
  00012	8b 45 1c	 mov	 eax, DWORD PTR _pszLibrary$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 18	 mov	 ecx, DWORD PTR _pszFunction$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 14	 mov	 edx, DWORD PTR _nLine$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 10	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _dwLevel$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 08	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z ; DirectSound::CDebug::PrintStaticV
  0002f	83 c4 20	 add	 esp, 32			; 00000020H

; 269  :     va_end(va);

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 270  : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ ENDP	; DirectSound::CDebug::PrintStatic
_TEXT	ENDS
PUBLIC	?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z	; DirectSound::CDebug::SetContext
; Function compile flags: /Odt
;	COMDAT ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z
_TEXT	SEGMENT
_dwFlags$ = 8
_dwLevel$ = 12
_pszFile$ = 16
_nLine$ = 20
_pszFunction$ = 24
_pszLibrary$ = 28
?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z PROC NEAR	; DirectSound::CDebug::SetContext, COMDAT

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 307  : 
; 308  : #ifdef _XBOX
; 309  : 
; 310  :     const KIRQL             irql    = KeGetCurrentIrql();
; 311  : 
; 312  : #else // _XBOX
; 313  : 
; 314  :     static const UINT       irql    = 0;
; 315  : 
; 316  : #endif // _XBOX
; 317  : 
; 318  :     m_aContext[irql].dwFlags = dwFlags;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00006	a3 00 00 00 00	 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A, eax

; 319  :     m_aContext[irql].dwLevel = dwLevel;

  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _dwLevel$[ebp]
  0000e	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+4, ecx

; 320  :     m_aContext[irql].pszFile = pszFile;

  00014	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  00017	89 15 08 00 00
	00		 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+8, edx

; 321  :     m_aContext[irql].nLine = nLine;

  0001d	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  00020	a3 0c 00 00 00	 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+12, eax

; 322  :     m_aContext[irql].pszFunction = pszFunction;

  00025	8b 4d 18	 mov	 ecx, DWORD PTR _pszFunction$[ebp]
  00028	89 0d 10 00 00
	00		 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+16, ecx

; 323  :     m_aContext[irql].pszLibrary = pszLibrary;

  0002e	8b 55 1c	 mov	 edx, DWORD PTR _pszLibrary$[ebp]
  00031	89 15 14 00 00
	00		 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+20, edx

; 324  : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ENDP	; DirectSound::CDebug::SetContext
_TEXT	ENDS
PUBLIC	?Print@CDebug@DirectSound@@SAXPBDZZ		; DirectSound::CDebug::Print
; Function compile flags: /Odt
;	COMDAT ?Print@CDebug@DirectSound@@SAXPBDZZ
_TEXT	SEGMENT
_pszFormat$ = 8
_va$ = -4
?Print@CDebug@DirectSound@@SAXPBDZZ PROC NEAR		; DirectSound::CDebug::Print, COMDAT

; 353  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 354  : 
; 355  : #ifdef _XBOX
; 356  : 
; 357  :     const KIRQL             irql    = KeGetCurrentIrql();
; 358  : 
; 359  : #else // _XBOX
; 360  : 
; 361  :     static const UINT       irql    = 0;
; 362  : 
; 363  : #endif // _XBOX
; 364  : 
; 365  :     va_list                 va;
; 366  : 
; 367  :     va_start(va, pszFormat);

  00004	8d 45 0c	 lea	 eax, DWORD PTR _pszFormat$[ebp+4]
  00007	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 368  :     PrintStaticV(m_aContext[irql].dwFlags, m_aContext[irql].dwLevel, m_aContext[irql].pszFile, m_aContext[irql].nLine, m_aContext[irql].pszFunction, m_aContext[irql].pszLibrary, pszFormat, va);

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR _pszFormat$[ebp]
  00011	52		 push	 edx
  00012	a1 14 00 00 00	 mov	 eax, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+20
  00017	50		 push	 eax
  00018	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+16
  0001e	51		 push	 ecx
  0001f	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+12
  00025	52		 push	 edx
  00026	a1 08 00 00 00	 mov	 eax, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+8
  0002b	50		 push	 eax
  0002c	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+4
  00032	51		 push	 ecx
  00033	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z ; DirectSound::CDebug::PrintStaticV
  0003f	83 c4 20	 add	 esp, 32			; 00000020H

; 369  :     va_end(va);

  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 370  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?Print@CDebug@DirectSound@@SAXPBDZZ ENDP		; DirectSound::CDebug::Print
_TEXT	ENDS
PUBLIC	?Assert@CDebug@DirectSound@@SAXHPBD0I@Z		; DirectSound::CDebug::Assert
PUBLIC	??_C@_0BF@OGHG@Assertion?5failed?5in?5?$AA@	; `string'
PUBLIC	??_C@_07PKF@?0?5line?5?$AA@			; `string'
PUBLIC	??_C@_02CGGM@?3?6?$AA@				; `string'
EXTRN	_strlen:NEAR
EXTRN	__itoa:NEAR
;	COMDAT ??_C@_0BF@OGHG@Assertion?5failed?5in?5?$AA@
CONST	SEGMENT
??_C@_0BF@OGHG@Assertion?5failed?5in?5?$AA@ DB 'Assertion failed in ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PKF@?0?5line?5?$AA@
CONST	SEGMENT
??_C@_07PKF@?0?5line?5?$AA@ DB ', line ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02CGGM@?3?6?$AA@
CONST	SEGMENT
??_C@_02CGGM@?3?6?$AA@ DB ':', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z
_TEXT	SEGMENT
_fAssert$ = 8
_pszExpression$ = 12
_pszFile$ = 16
_nLine$ = 20
_szMessage$ = -1032
_pszMessage$ = -4
?Assert@CDebug@DirectSound@@SAXHPBD0I@Z PROC NEAR	; DirectSound::CDebug::Assert, COMDAT

; 403  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H

; 404  :     static const LPCSTR     pszBanner           = "******************************************************************************";
; 405  :     CHAR                    szMessage[0x400];
; 406  :     LPSTR                   pszMessage;
; 407  : 
; 408  :     if(fAssert)

  00009	83 7d 08 00	 cmp	 DWORD PTR _fAssert$[ebp], 0
  0000d	0f 84 ed 00 00
	00		 je	 $L52662

; 409  :     {
; 410  :         pszMessage = szMessage;

  00013	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _szMessage$[ebp]
  00019	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 411  : 
; 412  :         pszMessage = dstrcpy(pszMessage, pszBanner);

  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??Assert@CDebug@DirectSound@@SAXHPBD0I@Z@4QBDB
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0002c	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 413  :         pszMessage = dstrcpy(pszMessage, "\n");

  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01BJG@?6?$AA@ ; `string'
  00034	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0003d	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 414  :         pszMessage = dstrcpy(pszMessage, "Assertion failed in ");

  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@OGHG@Assertion?5failed?5in?5?$AA@ ; `string'
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _pszMessage$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0004e	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 415  :         pszMessage = dstrcpy(pszMessage, pszFile);

  00051	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  00054	52		 push	 edx
  00055	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0005e	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 416  :         pszMessage = dstrcpy(pszMessage, ", line ");

  00061	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07PKF@?0?5line?5?$AA@ ; `string'
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _pszMessage$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0006f	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 417  :     
; 418  :         _itoa(nLine, pszMessage, 10);

  00072	6a 0a		 push	 10			; 0000000aH
  00074	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  00077	52		 push	 edx
  00078	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 __itoa
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 419  :         pszMessage += strlen(pszMessage);

  00084	8b 4d fc	 mov	 ecx, DWORD PTR _pszMessage$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _strlen
  0008d	83 c4 04	 add	 esp, 4
  00090	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  00093	03 d0		 add	 edx, eax
  00095	89 55 fc	 mov	 DWORD PTR _pszMessage$[ebp], edx

; 420  : 
; 421  :         pszMessage = dstrcpy(pszMessage, ":\n");

  00098	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02CGGM@?3?6?$AA@ ; `string'
  0009d	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000a6	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 422  :         pszMessage = dstrcpy(pszMessage, pszExpression);

  000a9	8b 4d 0c	 mov	 ecx, DWORD PTR _pszExpression$[ebp]
  000ac	51		 push	 ecx
  000ad	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  000b0	52		 push	 edx
  000b1	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000b6	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 423  :         pszMessage = dstrcpy(pszMessage, "\n");

  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01BJG@?6?$AA@ ; `string'
  000be	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000c7	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 424  :         pszMessage = dstrcpy(pszMessage, pszBanner);

  000ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??Assert@CDebug@DirectSound@@SAXHPBD0I@Z@4QBDB
  000d0	51		 push	 ecx
  000d1	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000da	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 425  :         pszMessage = dstrcpy(pszMessage, "\n");

  000dd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01BJG@?6?$AA@ ; `string'
  000e2	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000eb	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 426  : 
; 427  :         OutputDebugStringA(szMessage);

  000ee	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _szMessage$[ebp]
  000f4	51		 push	 ecx
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 428  :         Break();

  000fb	e8 00 00 00 00	 call	 ?Break@CDebug@DirectSound@@SAXXZ ; DirectSound::CDebug::Break
$L52662:

; 429  :     }
; 430  : }

  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ENDP		; DirectSound::CDebug::Assert
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Break@CDebug@DirectSound@@SAXXZ
_TEXT	SEGMENT
?Break@CDebug@DirectSound@@SAXXZ PROC NEAR		; DirectSound::CDebug::Break, COMDAT

; 457  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 458  :     //
; 459  :     // Break in the debugger
; 460  :     //
; 461  :     
; 462  :     __asm int 3;

  00003	cc		 int	 3

; 463  : 
; 464  : #ifdef _XBOX
; 465  : 
; 466  :     //
; 467  :     // If we're at DISPATCH_LEVEL or higher, the VC debugger won't catch
; 468  :     // the break.
; 469  :     //
; 470  :     
; 471  :     if(KeGetCurrentIrql() >= DISPATCH_LEVEL)
; 472  :     {
; 473  :         m_fDebugBreak = TRUE;
; 474  :     }
; 475  : 
; 476  : #endif // _XBOX
; 477  : 
; 478  : }

  00004	5d		 pop	 ebp
  00005	c3		 ret	 0
?Break@CDebug@DirectSound@@SAXXZ ENDP			; DirectSound::CDebug::Break
_TEXT	ENDS
PUBLIC	?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::PoolAlloc
PUBLIC	??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_08KCAL@cbBuffer?$AA@			; `string'
PUBLIC	??_C@_07FEMJ@XACTGUI?$AA@			; `string'
PUBLIC	??_C@_0BK@BHJJ@CMemoryManager?3?3PoolAlloc?$AA@	; `string'
PUBLIC	??_C@_0BD@LFMI@Out?5of?5pool?5memory?$AA@	; `string'
EXTRN	__imp__LocalAlloc@8:NEAR
EXTRN	__imp__LocalSize@4:NEAR
;	COMDAT ??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\common\memmgr.cpp
CONST	SEGMENT
??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\privat'
	DB	'e\windows\directx\dsound\common\memmgr.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KCAL@cbBuffer?$AA@
CONST	SEGMENT
??_C@_08KCAL@cbBuffer?$AA@ DB 'cbBuffer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FEMJ@XACTGUI?$AA@
CONST	SEGMENT
??_C@_07FEMJ@XACTGUI?$AA@ DB 'XACTGUI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BHJJ@CMemoryManager?3?3PoolAlloc?$AA@
CONST	SEGMENT
??_C@_0BK@BHJJ@CMemoryManager?3?3PoolAlloc?$AA@ DB 'CMemoryManager::PoolA'
	DB	'lloc', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LFMI@Out?5of?5pool?5memory?$AA@
CONST	SEGMENT
??_C@_0BD@LFMI@Out?5of?5pool?5memory?$AA@ DB 'Out of pool memory', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z
_TEXT	SEGMENT
_cbBuffer$ = 12
_fZeroInit$ = 16
_pvBuffer$ = -4
?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z PROC NEAR ; DirectSound::CMemoryManager::PoolAlloc, COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 65   :     static const ULONG      cbLowerThreshold    = 0x20;
; 66   :     static const DWORD      cbUpperThreshold    = 0xFD8;
; 67   :     LPVOID                  pvBuffer;
; 68   : 
; 69   :     ASSERT(cbBuffer);

  00004	6a 45		 push	 69			; 00000045H
  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08KCAL@cbBuffer?$AA@ ; `string'
  00010	33 c0		 xor	 eax, eax
  00012	83 7d 0c 00	 cmp	 DWORD PTR _cbBuffer$[ebp], 0
  00016	0f 94 c0	 sete	 al
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0001f	83 c4 10	 add	 esp, 16			; 00000010H

; 70   : 
; 71   : #ifdef _XBOX
; 72   : 
; 73   : #ifdef MEM_SIZE_CHECK
; 74   : 
; 75   : #pragma TODO("Don't ship with this check turned on")
; 76   :     
; 77   :     if((DSOUND_OBJECT_POOL_TAG == nPoolTag) && (cbBuffer >= cbUpperThreshold))
; 78   :     {
; 79   :         ASSERTMSG("Allocating an object larger than the pool threshold");
; 80   :     }
; 81   :     else if((DSOUND_DATA_POOL_TAG == nPoolTag) && (cbBuffer < cbLowerThreshold))
; 82   :     {
; 83   :         ASSERTMSG("Allocating a buffer smaller than 32 bytes");
; 84   :     }
; 85   : 
; 86   : #endif // _MEM_SIZE_CHECK
; 87   : 
; 88   :     if(pvBuffer = ExAllocatePoolWithTag(cbBuffer, nPoolTag))
; 89   :     {
; 90   :         cbBuffer = ExQueryPoolBlockSize(pvBuffer);
; 91   :         m_dwPoolMemoryUsage += cbBuffer;
; 92   : 
; 93   :         if(fZeroInit)
; 94   :         {
; 95   :             ZeroMemory(pvBuffer, cbBuffer);
; 96   :         }
; 97   :     }
; 98   : 
; 99   : #else // _XBOX
; 100  : 
; 101  :     if(pvBuffer = LocalAlloc(fZeroInit ? LPTR : LMEM_FIXED, cbBuffer))

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 10	 mov	 edx, DWORD PTR _fZeroInit$[ebp]
  00029	f7 da		 neg	 edx
  0002b	1b d2		 sbb	 edx, edx
  0002d	83 e2 40	 and	 edx, 64			; 00000040H
  00030	52		 push	 edx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalAlloc@8
  00037	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  0003e	74 1e		 je	 SHORT $L52682

; 102  :     {
; 103  :         cbBuffer = LocalSize(pvBuffer);

  00040	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalSize@4
  0004a	89 45 0c	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 104  :         m_dwPoolMemoryUsage += cbBuffer;

  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  00053	03 4d 0c	 add	 ecx, DWORD PTR _cbBuffer$[ebp]
  00056	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA, ecx ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage

; 105  :     }
; 106  : 
; 107  : #endif // _XBOX
; 108  : 
; 109  :     else

  0005c	eb 2a		 jmp	 SHORT $L52683
$L52682:

; 110  :     {
; 111  :         DPF_RESOURCE("Out of pool memory");

  0005e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  00063	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@BHJJ@CMemoryManager?3?3PoolAlloc?$AA@ ; `string'
  00068	6a 6f		 push	 111			; 0000006fH
  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0006f	6a 02		 push	 2
  00071	6a 09		 push	 9
  00073	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00078	83 c4 18	 add	 esp, 24			; 00000018H
  0007b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@LFMI@Out?5of?5pool?5memory?$AA@ ; `string'
  00080	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00085	83 c4 04	 add	 esp, 4
$L52683:

; 112  :     }
; 113  : 
; 114  :     return pvBuffer;

  00088	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 115  : }

  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 0c 00	 ret	 12			; 0000000cH
?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ENDP ; DirectSound::CMemoryManager::PoolAlloc
_TEXT	ENDS
PUBLIC	?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z	; DirectSound::CMemoryManager::PoolFree
PUBLIC	??_C@_08KLJN@pvBuffer?$AA@			; `string'
PUBLIC	??_C@_0CA@JMGJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@ ; `string'
EXTRN	__imp__LocalFree@4:NEAR
;	COMDAT ??_C@_08KLJN@pvBuffer?$AA@
CONST	SEGMENT
??_C@_08KLJN@pvBuffer?$AA@ DB 'pvBuffer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JMGJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@
CONST	SEGMENT
??_C@_0CA@JMGJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@ DB 'm_dwPoolM'
	DB	'emoryUsage >= cbBuffer', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
_cbBuffer$ = -4
?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::PoolFree, COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 142  :     DWORD                   cbBuffer;
; 143  : 
; 144  :     ASSERT(pvBuffer);

  00004	68 90 00 00 00	 push	 144			; 00000090H
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08KLJN@pvBuffer?$AA@ ; `string'
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 08 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 145  : 
; 146  : #ifdef _XBOX
; 147  : 
; 148  :     cbBuffer = ExQueryPoolBlockSize(pvBuffer);
; 149  : 
; 150  :     ASSERT(m_dwPoolMemoryUsage >= cbBuffer);
; 151  :     m_dwPoolMemoryUsage -= cbBuffer;
; 152  : 
; 153  :     ExFreePool(pvBuffer);
; 154  : 
; 155  : #else // _XBOX
; 156  : 
; 157  :     cbBuffer = LocalSize(pvBuffer);

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00028	51		 push	 ecx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalSize@4
  0002f	89 45 fc	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 158  : 
; 159  :     ASSERT(m_dwPoolMemoryUsage >= cbBuffer);

  00032	68 9f 00 00 00	 push	 159			; 0000009fH
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@JMGJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@ ; `string'
  00041	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  00047	3b 55 fc	 cmp	 edx, DWORD PTR _cbBuffer$[ebp]
  0004a	1b c0		 sbb	 eax, eax
  0004c	f7 d8		 neg	 eax
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00054	83 c4 10	 add	 esp, 16			; 00000010H

; 160  :     m_dwPoolMemoryUsage -= cbBuffer;

  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  0005d	2b 4d fc	 sub	 ecx, DWORD PTR _cbBuffer$[ebp]
  00060	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA, ecx ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage

; 161  : 
; 162  :     LocalFree(pvBuffer);

  00066	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00069	52		 push	 edx
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4

; 163  : 
; 164  : #endif // _XBOX
; 165  : 
; 166  : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP	; DirectSound::CMemoryManager::PoolFree
_TEXT	ENDS
PUBLIC	?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z ; DirectSound::CMemoryManager::PhysicalAlloc
PUBLIC	??_C@_07BFD@dwFlags?$AA@			; `string'
PUBLIC	??_C@_0BO@LELL@CMemoryManager?3?3PhysicalAlloc?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MFKD@Out?5of?5contiguous?5memory?$AA@	; `string'
EXTRN	__imp__VirtualAlloc@16:NEAR
EXTRN	_memset:NEAR
;	COMDAT ??_C@_07BFD@dwFlags?$AA@
CONST	SEGMENT
??_C@_07BFD@dwFlags?$AA@ DB 'dwFlags', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LELL@CMemoryManager?3?3PhysicalAlloc?$AA@
CONST	SEGMENT
??_C@_0BO@LELL@CMemoryManager?3?3PhysicalAlloc?$AA@ DB 'CMemoryManager::P'
	DB	'hysicalAlloc', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MFKD@Out?5of?5contiguous?5memory?$AA@
CONST	SEGMENT
??_C@_0BJ@MFKD@Out?5of?5contiguous?5memory?$AA@ DB 'Out of contiguous mem'
	DB	'ory', 00H					; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z
_TEXT	SEGMENT
_cbBuffer$ = 8
_dwFlags$ = 16
_fZeroInit$ = 20
_pvBuffer$ = -4
?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z PROC NEAR ; DirectSound::CMemoryManager::PhysicalAlloc, COMDAT

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 199  :     LPVOID                  pvBuffer;
; 200  : 
; 201  :     ASSERT(cbBuffer);

  00004	68 c9 00 00 00	 push	 201			; 000000c9H
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08KCAL@cbBuffer?$AA@ ; `string'
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 08 00	 cmp	 DWORD PTR _cbBuffer$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 202  :     ASSERT(dwFlags);

  00025	68 ca 00 00 00	 push	 202			; 000000caH
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07BFD@dwFlags?$AA@ ; `string'
  00034	33 c9		 xor	 ecx, ecx
  00036	83 7d 10 00	 cmp	 DWORD PTR _dwFlags$[ebp], 0
  0003a	0f 94 c1	 sete	 cl
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00043	83 c4 10	 add	 esp, 16			; 00000010H

; 203  :     
; 204  : #ifdef _XBOX
; 205  : 
; 206  :     if(pvBuffer = MmAllocateContiguousMemoryEx(cbBuffer, 0, 0xFFFFFFFF, cbAlignment, dwFlags))
; 207  :     {
; 208  :         cbBuffer = MmQueryAllocationSize(pvBuffer);
; 209  :         m_dwPhysicalMemoryUsage += cbBuffer;
; 210  : 
; 211  :         if(fZeroInit)
; 212  :         {
; 213  :             ZeroMemory(pvBuffer, cbBuffer);
; 214  :         }
; 215  :     }
; 216  : 
; 217  : #else // _XBOX
; 218  : 
; 219  :     if(pvBuffer = VirtualAlloc(NULL, cbBuffer, MEM_COMMIT, dwFlags))

  00046	8b 55 10	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00049	52		 push	 edx
  0004a	68 00 10 00 00	 push	 4096			; 00001000H
  0004f	8b 45 08	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  00052	50		 push	 eax
  00053	6a 00		 push	 0
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16
  0005b	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  0005e	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00062	74 1a		 je	 SHORT $L52701

; 220  :     {
; 221  : 
; 222  : #pragma TODO("Not able to query for size of VirtualAlloc'd buffer")
; 223  : 
; 224  :         if(fZeroInit)

  00064	83 7d 14 00	 cmp	 DWORD PTR _fZeroInit$[ebp], 0
  00068	74 12		 je	 SHORT $L52702

; 225  :         {
; 226  :             ZeroMemory(pvBuffer, cbBuffer);

  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  0006d	51		 push	 ecx
  0006e	6a 00		 push	 0
  00070	8b 55 fc	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00073	52		 push	 edx
  00074	e8 00 00 00 00	 call	 _memset
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
$L52702:

; 227  :         }
; 228  :     }
; 229  : 
; 230  : #endif // _XBOX
; 231  : 
; 232  :     else

  0007c	eb 2d		 jmp	 SHORT $L52703
$L52701:

; 233  :     {
; 234  :         DPF_RESOURCE("Out of contiguous memory");

  0007e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  00083	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@LELL@CMemoryManager?3?3PhysicalAlloc?$AA@ ; `string'
  00088	68 ea 00 00 00	 push	 234			; 000000eaH
  0008d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00092	6a 02		 push	 2
  00094	6a 09		 push	 9
  00096	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0009b	83 c4 18	 add	 esp, 24			; 00000018H
  0009e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@MFKD@Out?5of?5contiguous?5memory?$AA@ ; `string'
  000a3	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000a8	83 c4 04	 add	 esp, 4
$L52703:

; 235  :     }
; 236  : 
; 237  :     return pvBuffer;

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 238  : }

  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c2 10 00	 ret	 16			; 00000010H
?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z ENDP ; DirectSound::CMemoryManager::PhysicalAlloc
_TEXT	ENDS
PUBLIC	?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PhysicalFree
EXTRN	__imp__VirtualFree@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::PhysicalFree, COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 265  :     DWORD                   cbBuffer;
; 266  : 
; 267  :     ASSERT(pvBuffer);

  00004	68 0b 01 00 00	 push	 267			; 0000010bH
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08KLJN@pvBuffer?$AA@ ; `string'
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 08 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 268  : 
; 269  : #ifdef _XBOX
; 270  : 
; 271  :     cbBuffer = MmQueryAllocationSize(pvBuffer);
; 272  : 
; 273  :     ASSERT(m_dwPhysicalMemoryUsage >= cbBuffer);
; 274  :     m_dwPhysicalMemoryUsage -= cbBuffer;
; 275  : 
; 276  :     MmFreeContiguousMemory(pvBuffer);
; 277  : 
; 278  : #else // _XBOX
; 279  : 
; 280  : #pragma TODO("Not able to query for size of VirtualAlloc'd buffer")
; 281  : 
; 282  :     VirtualFree(pvBuffer, 0, MEM_RELEASE);

  00025	68 00 80 00 00	 push	 32768			; 00008000H
  0002a	6a 00		 push	 0
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  0002f	51		 push	 ecx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualFree@12

; 283  : 
; 284  : #endif // _XBOX
; 285  : 
; 286  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP	; DirectSound::CMemoryManager::PhysicalFree
_TEXT	ENDS
PUBLIC	?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z	; InsertTailListUninit
PUBLIC	?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ; DirectSound::CMemoryManager::TrackAlloc
PUBLIC	??_C@_0O@EFP@pvBaseAddress?$AA@			; `string'
PUBLIC	??_C@_0CB@NOEM@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@ ; `string'
PUBLIC	??_C@_06DOGD@cbSize?$AA@			; `string'
;	COMDAT ??_C@_0O@EFP@pvBaseAddress?$AA@
CONST	SEGMENT
??_C@_0O@EFP@pvBaseAddress?$AA@ DB 'pvBaseAddress', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NOEM@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@
CONST	SEGMENT
??_C@_0CB@NOEM@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@ DB 'cbT'
	DB	'racking >= sizeof(*pTracking)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DOGD@cbSize?$AA@
CONST	SEGMENT
??_C@_06DOGD@cbSize?$AA@ DB 'cbSize', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z
_TEXT	SEGMENT
_pvBaseAddress$ = 8
_cbTracking$ = 12
_pszFile$ = 16
_nLine$ = 20
_pszClass$ = 24
_nAllocatorTag$ = 28
_cbSize$ = 32
_pTracking$ = -4
?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z PROC NEAR ; DirectSound::CMemoryManager::TrackAlloc, COMDAT

; 466  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 467  :     LPDSMEMTRACK            pTracking;
; 468  :     
; 469  :     ASSERT(pvBaseAddress);

  00004	68 d5 01 00 00	 push	 469			; 000001d5H
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EFP@pvBaseAddress?$AA@ ; `string'
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 08 00	 cmp	 DWORD PTR _pvBaseAddress$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 470  :     ASSERT(cbTracking >= sizeof(*pTracking));

  00025	68 d6 01 00 00	 push	 470			; 000001d6H
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@NOEM@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@ ; `string'
  00034	83 7d 0c 20	 cmp	 DWORD PTR _cbTracking$[ebp], 32 ; 00000020H
  00038	1b c9		 sbb	 ecx, ecx
  0003a	f7 d9		 neg	 ecx
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00042	83 c4 10	 add	 esp, 16			; 00000010H

; 471  :     ASSERT(cbSize);

  00045	68 d7 01 00 00	 push	 471			; 000001d7H
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06DOGD@cbSize?$AA@ ; `string'
  00054	33 d2		 xor	 edx, edx
  00056	83 7d 20 00	 cmp	 DWORD PTR _cbSize$[ebp], 0
  0005a	0f 94 c2	 sete	 dl
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00063	83 c4 10	 add	 esp, 16			; 00000010H

; 472  :     
; 473  :     //
; 474  :     // Because of alignment issues, the base address may be incremented more
; 475  :     // than sizeof(DSMEMTRACK).  For this reason, we store the tracking data
; 476  :     // directly behind the allocation, but allocate more than cbSize +
; 477  :     // sizeof(DSMEMTRACK).
; 478  :     //
; 479  : 
; 480  :     pTracking = (LPDSMEMTRACK)((LPBYTE)pvBaseAddress + cbTracking - sizeof(*pTracking));

  00066	8b 45 0c	 mov	 eax, DWORD PTR _cbTracking$[ebp]
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  0006c	8d 54 01 e0	 lea	 edx, DWORD PTR [ecx+eax-32]
  00070	89 55 fc	 mov	 DWORD PTR _pTracking$[ebp], edx

; 481  : 
; 482  :     //
; 483  :     // Create the tracking info
; 484  :     //
; 485  : 
; 486  :     pTracking->pszFile = pszFile;

  00073	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  00076	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  00079	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 487  :     pTracking->nLine = nLine;

  0007c	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  0007f	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  00082	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 488  :     pTracking->pszClass = pszClass;

  00085	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  00088	8b 55 18	 mov	 edx, DWORD PTR _pszClass$[ebp]
  0008b	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 489  :     pTracking->nAllocatorTag = nAllocatorTag;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  00091	8b 4d 1c	 mov	 ecx, DWORD PTR _nAllocatorTag$[ebp]
  00094	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 490  :     pTracking->cbSize = cbSize;

  00097	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  0009a	8b 45 20	 mov	 eax, DWORD PTR _cbSize$[ebp]
  0009d	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 491  :     pTracking->pvBaseAddress = pvBaseAddress;

  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000a3	8b 55 08	 mov	 edx, DWORD PTR _pvBaseAddress$[ebp]
  000a6	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 492  : 
; 493  : #ifdef _XBOX
; 494  : 
; 495  :     //
; 496  :     // Raise IRQL for synchronization
; 497  :     //
; 498  : 
; 499  :     AutoIrql();
; 500  : 
; 501  : #endif // _XBOX
; 502  : 
; 503  :     //
; 504  :     // Add the allocation to the list
; 505  :     //
; 506  : 
; 507  :     if(!m_lstMemoryTracking.Flink && !m_lstMemoryTracking.Blink)

  000a9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, 0
  000b0	75 1d		 jne	 SHORT $L52725
  000b2	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A+4, 0
  000b9	75 14		 jne	 SHORT $L52725

; 508  :     {
; 509  :         InitializeListHead(&m_lstMemoryTracking);

  000bb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A
  000ca	a3 04 00 00 00	 mov	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A+4, eax
$L52725:

; 510  :     }
; 511  :     
; 512  :     InsertTailListUninit(&m_lstMemoryTracking, &pTracking->leListEntry);

  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000d2	51		 push	 ecx
  000d3	68 00 00 00 00	 push	 OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  000d8	e8 00 00 00 00	 call	 ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailListUninit

; 513  : 
; 514  :     //
; 515  :     // Fix up the base address
; 516  :     //
; 517  : 
; 518  :     return pTracking + 1;

  000dd	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  000e0	83 c0 20	 add	 eax, 32			; 00000020H

; 519  : }

  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 1c 00	 ret	 28			; 0000001cH
?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ENDP ; DirectSound::CMemoryManager::TrackAlloc
_TEXT	ENDS
PUBLIC	?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList
PUBLIC	??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
;	COMDAT ??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\common\ntlist.h
CONST	SEGMENT
??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\privat'
	DB	'e\windows\directx\dsound\common\ntlist.h', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z
_TEXT	SEGMENT
_ListHead$ = 8
_Entry$ = 12
?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z PROC NEAR	; InsertTailListUninit, COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 136  :     AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

  00003	68 88 00 00 00	 push	 136			; 00000088H
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000d	6a 00		 push	 0
  0000f	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 137  : 
; 138  :     Entry->Flink = ListHead;

  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR _ListHead$[ebp]
  0001e	89 11		 mov	 DWORD PTR [ecx], edx

; 139  :     Entry->Blink = ListHead->Blink;

  00020	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  00026	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00029	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 140  :     
; 141  :     Entry->Flink->Blink = Entry;

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00034	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 142  :     Entry->Blink->Flink = Entry;

  00037	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0003a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003d	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00040	89 11		 mov	 DWORD PTR [ecx], edx

; 143  : 
; 144  :     AssertValidEntryList(Entry, ASSERT_IN_LIST);

  00042	68 90 00 00 00	 push	 144			; 00000090H
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004c	6a 01		 push	 1
  0004e	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 145  : }    

  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ENDP	; InsertTailListUninit
_TEXT	ENDS
PUBLIC	??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@	; `string'
PUBLIC	??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@ ; `string'
PUBLIC	??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@ ; `string'
PUBLIC	??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@	; `string'
PUBLIC	??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@	; `string'
;	COMDAT ??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@
CONST	SEGMENT
??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@ DB 'NULL list entry pointe'
	DB	'r', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@
CONST	SEGMENT
??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@ DB 'List entry conta'
	DB	'ins NULL pointer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@
CONST	SEGMENT
??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@ DB 'List entry part'
	DB	'ially points to itself', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@
CONST	SEGMENT
??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@ DB 'List entry not in list'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@
CONST	SEGMENT
??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@ DB 'List entry in list', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
_TEXT	SEGMENT
_Entry$ = 8
_nFlags$ = 12
_pszFile$ = 16
_nLine$ = 20
?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z PROC NEAR ; __AssertValidEntryList, COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   :     if(!Entry)

  00003	83 7d 08 00	 cmp	 DWORD PTR _Entry$[ebp], 0
  00007	75 1c		 jne	 SHORT $L47476

; 57   :     {
; 58   :         DirectSound::CDebug::Assert(TRUE, "NULL list entry pointer", pszFile, nLine);

  00009	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  00010	51		 push	 ecx
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@ ; `string'
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0001d	83 c4 10	 add	 esp, 16			; 00000010H

; 59   :     }
; 60   :     else if(!Entry->Flink || !Entry->Blink)

  00020	e9 c0 00 00 00	 jmp	 $L47478
$L47476:
  00025	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  00028	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0002b	74 09		 je	 SHORT $L47480
  0002d	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	75 1c		 jne	 SHORT $L47479
$L47480:

; 61   :     {
; 62   :         DirectSound::CDebug::Assert(TRUE, "List entry contains NULL pointer", pszFile, nLine);

  00036	8b 4d 14	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  0003d	52		 push	 edx
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@ ; `string'
  00043	6a 01		 push	 1
  00045	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0004a	83 c4 10	 add	 esp, 16			; 00000010H

; 63   :     }
; 64   :     else if((Entry == Entry->Flink) || (Entry == Entry->Blink))

  0004d	e9 93 00 00 00	 jmp	 $L47482
$L47479:
  00052	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00058	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0005a	74 0b		 je	 SHORT $L47484
  0005c	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0005f	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00062	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00065	75 2e		 jne	 SHORT $L47483
$L47484:

; 65   :     {
; 66   :         if((Entry != Entry->Flink) || (Entry != Entry->Blink))

  00067	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0006a	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0006d	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0006f	75 0b		 jne	 SHORT $L47486
  00071	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00077	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0007a	74 17		 je	 SHORT $L47485
$L47486:

; 67   :         {
; 68   :             DirectSound::CDebug::Assert(TRUE, "List entry partially points to itself", pszFile, nLine);

  0007c	8b 55 14	 mov	 edx, DWORD PTR _nLine$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 10	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00083	50		 push	 eax
  00084	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@ ; `string'
  00089	6a 01		 push	 1
  0008b	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00090	83 c4 10	 add	 esp, 16			; 00000010H
$L47485:

; 69   :         }
; 70   :     }
; 71   :     else if(ASSERT_IN_LIST == nFlags)

  00093	eb 50		 jmp	 SHORT $L47488
$L47483:
  00095	83 7d 0c 01	 cmp	 DWORD PTR _nFlags$[ebp], 1
  00099	75 23		 jne	 SHORT $L47489

; 72   :     {
; 73   :         if(!IsEntryInList(Entry))

  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0009e	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  000a1	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000a3	75 17		 jne	 SHORT $L47490

; 74   :         {
; 75   :             DirectSound::CDebug::Assert(TRUE, "List entry not in list", pszFile, nLine);

  000a5	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  000ac	51		 push	 ecx
  000ad	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@ ; `string'
  000b2	6a 01		 push	 1
  000b4	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000b9	83 c4 10	 add	 esp, 16			; 00000010H
$L47490:

; 76   :         }
; 77   :     }
; 78   :     else if(ASSERT_NOT_IN_LIST == nFlags)

  000bc	eb 27		 jmp	 SHORT $L47492
$L47489:
  000be	83 7d 0c 02	 cmp	 DWORD PTR _nFlags$[ebp], 2
  000c2	75 21		 jne	 SHORT $L47493

; 79   :     {
; 80   :         if(IsEntryInList(Entry))

  000c4	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  000c7	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  000ca	3b 02		 cmp	 eax, DWORD PTR [edx]
  000cc	74 17		 je	 SHORT $L47494

; 81   :         {
; 82   :             DirectSound::CDebug::Assert(TRUE, "List entry in list", pszFile, nLine);

  000ce	8b 4d 14	 mov	 ecx, DWORD PTR _nLine$[ebp]
  000d1	51		 push	 ecx
  000d2	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  000d5	52		 push	 edx
  000d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@ ; `string'
  000db	6a 01		 push	 1
  000dd	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000e2	83 c4 10	 add	 esp, 16			; 00000010H
$L47494:
$L47493:
$L47492:
$L47488:
$L47482:
$L47478:

; 83   :         }
; 84   :     }
; 85   : }

  000e5	5d		 pop	 ebp
  000e6	c2 10 00	 ret	 16			; 00000010H
?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ENDP ; __AssertValidEntryList
_TEXT	ENDS
PUBLIC	?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z	; RemoveEntryList
PUBLIC	?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ; DirectSound::CMemoryManager::ForgetAlloc
PUBLIC	??_C@_0CK@EOH@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@ ; `string'
;	COMDAT ??_C@_0CK@EOH@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@
; File c:\xbox\private\windows\directx\dsound\common\memmgr.cpp
CONST	SEGMENT
??_C@_0CK@EOH@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@ DB 'nAllocato'
	DB	'rTag == pTracking->nAllocatorTag', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z
_TEXT	SEGMENT
_pvBaseAddress$ = 8
_nAllocatorTag$ = 12
_pTracking$ = -4
?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z PROC NEAR ; DirectSound::CMemoryManager::ForgetAlloc, COMDAT

; 551  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 552  :     LPDSMEMTRACK            pTracking   = (LPDSMEMTRACK)pvBaseAddress - 1;

  00004	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  00007	83 e8 20	 sub	 eax, 32			; 00000020H
  0000a	89 45 fc	 mov	 DWORD PTR _pTracking$[ebp], eax

; 553  : 
; 554  :     ASSERT(pvBaseAddress);

  0000d	68 2a 02 00 00	 push	 554			; 0000022aH
  00012	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EFP@pvBaseAddress?$AA@ ; `string'
  0001c	33 c9		 xor	 ecx, ecx
  0001e	83 7d 08 00	 cmp	 DWORD PTR _pvBaseAddress$[ebp], 0
  00022	0f 94 c1	 sete	 cl
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 555  : 
; 556  :     //
; 557  :     // Assert that the tag matches what we expect
; 558  :     //
; 559  : 
; 560  :     ASSERT(nAllocatorTag == pTracking->nAllocatorTag);

  0002e	68 30 02 00 00	 push	 560			; 00000230H
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@EOH@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@ ; `string'
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  00040	8b 45 0c	 mov	 eax, DWORD PTR _nAllocatorTag$[ebp]
  00043	33 c9		 xor	 ecx, ecx
  00045	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  00048	0f 95 c1	 setne	 cl
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00051	83 c4 10	 add	 esp, 16			; 00000010H

; 561  :     
; 562  : #ifdef _XBOX
; 563  : 
; 564  :     //
; 565  :     // Raise IRQL for synchronization
; 566  :     //
; 567  : 
; 568  :     AutoIrql();
; 569  : 
; 570  : #endif // _XBOX
; 571  : 
; 572  :     //
; 573  :     // Remove the allocation from the list
; 574  :     //
; 575  : 
; 576  :     RemoveEntryList(&pTracking->leListEntry);

  00054	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 577  : 
; 578  :     //
; 579  :     // Return the proper base address
; 580  :     //
; 581  : 
; 582  :     return pTracking->pvBaseAddress;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  00060	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]

; 583  : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ENDP ; DirectSound::CMemoryManager::ForgetAlloc
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\ntlist.h
_TEXT	ENDS
;	COMDAT ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z
_TEXT	SEGMENT
_Entry$ = 8
?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z PROC NEAR	; RemoveEntryList, COMDAT

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 216  :     AssertValidEntryList(Entry, ASSERT_VALID_ONLY);

  00003	68 d8 00 00 00	 push	 216			; 000000d8H
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000d	6a 00		 push	 0
  0000f	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 217  : 
; 218  :     if(IsEntryInList(Entry))

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0001e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00020	74 2c		 je	 SHORT $L47516

; 219  :     {
; 220  :         Entry->Flink->Blink = Entry->Blink;

  00022	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0002a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 221  :         Entry->Blink->Flink = Entry->Flink;

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00033	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00036	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 0a		 mov	 DWORD PTR [edx], ecx

; 222  : 
; 223  :         Entry->Flink = Entry->Blink = Entry;

  0003d	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  00040	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00043	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00049	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0004c	89 11		 mov	 DWORD PTR [ecx], edx
$L47516:

; 224  :     }
; 225  : 
; 226  :     return Entry;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]

; 227  : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ENDP	; RemoveEntryList
_TEXT	ENDS
PUBLIC	?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingPoolAlloc
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\memmgr.cpp
;	COMDAT ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z
_TEXT	SEGMENT
_pszFile$ = 8
_nLine$ = 12
_pszClass$ = 16
_nPoolTag$ = 20
_cbBuffer$ = 24
_fZeroInit$ = 28
_pvBuffer$ = -4
?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z PROC NEAR ; DirectSound::CMemoryManager::TrackingPoolAlloc, COMDAT

; 623  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 624  : 
; 625  : #ifdef _XBOX
; 626  : 
; 627  :     static const ULONG      cbTracking  = PAGE_SIZE;
; 628  : 
; 629  : #else // _XBOX
; 630  : 
; 631  :     static const ULONG      cbTracking  = sizeof(DSMEMTRACK);
; 632  : 
; 633  : #endif // _XBOX
; 634  : 
; 635  :     LPVOID                  pvBuffer;
; 636  :     
; 637  :     //
; 638  :     // Do the actual allocation
; 639  :     //
; 640  :     
; 641  :     if(pvBuffer = PoolAlloc(nPoolTag, cbBuffer + cbTracking, fZeroInit))

  00004	8b 45 1c	 mov	 eax, DWORD PTR _fZeroInit$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 18	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  0000b	83 c1 20	 add	 ecx, 32			; 00000020H
  0000e	51		 push	 ecx
  0000f	8b 55 14	 mov	 edx, DWORD PTR _nPoolTag$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::PoolAlloc
  00018	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  0001b	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  0001f	74 23		 je	 SHORT $L52745

; 642  :     {
; 643  :         //
; 644  :         // Complete the tracking
; 645  :         //
; 646  : 
; 647  :         pvBuffer = TrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_POOL, cbBuffer);

  00021	8b 45 18	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  00024	50		 push	 eax
  00025	68 70 6f 6f 6c	 push	 1819242352		; 6c6f6f70H
  0002a	8b 4d 10	 mov	 ecx, DWORD PTR _pszClass$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 0c	 mov	 edx, DWORD PTR _nLine$[ebp]
  00031	52		 push	 edx
  00032	8b 45 08	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00035	50		 push	 eax
  00036	6a 20		 push	 32			; 00000020H
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ; DirectSound::CMemoryManager::TrackAlloc
  00041	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
$L52745:

; 648  :     }
; 649  : 
; 650  :     return pvBuffer;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 651  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 18 00	 ret	 24			; 00000018H
?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ENDP ; DirectSound::CMemoryManager::TrackingPoolAlloc
_TEXT	ENDS
PUBLIC	?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPoolFree
; Function compile flags: /Odt
;	COMDAT ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::TrackingPoolFree, COMDAT

; 681  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 682  :     //
; 683  :     // Free tracking information
; 684  :     //
; 685  : 
; 686  :     pvBuffer = ForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_POOL);

  00003	68 70 6f 6f 6c	 push	 1819242352		; 6c6f6f70H
  00008	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ; DirectSound::CMemoryManager::ForgetAlloc
  00011	89 45 08	 mov	 DWORD PTR _pvBuffer$[ebp], eax

; 687  : 
; 688  :     //
; 689  :     // Free memory
; 690  :     //
; 691  : 
; 692  :     PoolFree(pvBuffer);

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PoolFree

; 693  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP ; DirectSound::CMemoryManager::TrackingPoolFree
_TEXT	ENDS
PUBLIC	?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z ; DirectSound::CMemoryManager::TrackingPhysicalAlloc
; Function compile flags: /Odt
;	COMDAT ?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z
_TEXT	SEGMENT
_pszFile$ = 8
_nLine$ = 12
_pszClass$ = 16
_cbBuffer$ = 20
_cbAlignment$ = 24
_dwFlags$ = 28
_fZeroInit$ = 32
_cbTracking$ = -4
_pvBuffer$ = -8
?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z PROC NEAR ; DirectSound::CMemoryManager::TrackingPhysicalAlloc, COMDAT

; 732  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 733  :     ULONG                   cbTracking;
; 734  :     LPVOID                  pvBuffer;
; 735  : 
; 736  :     //
; 737  :     // Make sure we allocate enough information for the tracking data
; 738  :     //
; 739  : 
; 740  :     if(cbAlignment >= sizeof(DSMEMTRACK))

  00006	83 7d 18 20	 cmp	 DWORD PTR _cbAlignment$[ebp], 32 ; 00000020H
  0000a	72 08		 jb	 SHORT $L52761

; 741  :     {
; 742  :         cbTracking = cbAlignment;

  0000c	8b 45 18	 mov	 eax, DWORD PTR _cbAlignment$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _cbTracking$[ebp], eax

; 743  :     }
; 744  :     else

  00012	eb 12		 jmp	 SHORT $L52762
$L52761:

; 745  :     {
; 746  :         cbTracking = BLOCKALIGNPAD(sizeof(DSMEMTRACK), cbAlignment);

  00014	8b 45 18	 mov	 eax, DWORD PTR _cbAlignment$[ebp]
  00017	83 c0 1f	 add	 eax, 31			; 0000001fH
  0001a	33 d2		 xor	 edx, edx
  0001c	f7 75 18	 div	 DWORD PTR _cbAlignment$[ebp]
  0001f	0f af 45 18	 imul	 eax, DWORD PTR _cbAlignment$[ebp]
  00023	89 45 fc	 mov	 DWORD PTR _cbTracking$[ebp], eax
$L52762:

; 747  :     }
; 748  :     
; 749  :     //
; 750  :     // Do the actual allocation
; 751  :     //
; 752  :     
; 753  :     if(pvBuffer = PhysicalAlloc(cbBuffer + cbTracking, cbAlignment, dwFlags, fZeroInit))

  00026	8b 4d 20	 mov	 ecx, DWORD PTR _fZeroInit$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 1c	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 18	 mov	 eax, DWORD PTR _cbAlignment$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 14	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00035	03 4d fc	 add	 ecx, DWORD PTR _cbTracking$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z ; DirectSound::CMemoryManager::PhysicalAlloc
  0003e	89 45 f8	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  00041	83 7d f8 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00045	74 25		 je	 SHORT $L52764

; 754  :     {
; 755  :         //
; 756  :         // Complete the tracking
; 757  :         //
; 758  : 
; 759  :         pvBuffer = TrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_PHYS, cbBuffer);

  00047	8b 55 14	 mov	 edx, DWORD PTR _cbBuffer$[ebp]
  0004a	52		 push	 edx
  0004b	68 70 68 79 73	 push	 1937336432		; 73796870H
  00050	8b 45 10	 mov	 eax, DWORD PTR _pszClass$[ebp]
  00053	50		 push	 eax
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00057	51		 push	 ecx
  00058	8b 55 08	 mov	 edx, DWORD PTR _pszFile$[ebp]
  0005b	52		 push	 edx
  0005c	8b 45 fc	 mov	 eax, DWORD PTR _cbTracking$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d f8	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ; DirectSound::CMemoryManager::TrackAlloc
  00069	89 45 f8	 mov	 DWORD PTR _pvBuffer$[ebp], eax
$L52764:

; 760  :     }
; 761  : 
; 762  :     return pvBuffer;

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 763  : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 1c 00	 ret	 28			; 0000001cH
?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z ENDP ; DirectSound::CMemoryManager::TrackingPhysicalAlloc
_TEXT	ENDS
PUBLIC	?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPhysicalFree
; Function compile flags: /Odt
;	COMDAT ?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::TrackingPhysicalFree, COMDAT

; 793  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 794  :     //
; 795  :     // Free tracking information
; 796  :     //
; 797  : 
; 798  :     pvBuffer = ForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_PHYS);

  00003	68 70 68 79 73	 push	 1937336432		; 73796870H
  00008	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ; DirectSound::CMemoryManager::ForgetAlloc
  00011	89 45 08	 mov	 DWORD PTR _pvBuffer$[ebp], eax

; 799  : 
; 800  :     //
; 801  :     // Free memory
; 802  :     //
; 803  : 
; 804  :     PhysicalFree(pvBuffer);

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PhysicalFree

; 805  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP ; DirectSound::CMemoryManager::TrackingPhysicalFree
_TEXT	ENDS
PUBLIC	?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z ; DirectSound::CMemoryManager::DumpMemoryUsage
PUBLIC	??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@ ; `string'
PUBLIC	??_C@_0BI@CNJN@Begin?5memory?5usage?5dump?$AA@	; `string'
PUBLIC	??_C@_0BI@HDD@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BH@PGGD@Pool?5memory?5used?3?5?5?$CFlu?$AA@ ; `string'
PUBLIC	??_C@_0BL@MNK@Physical?5memory?5used?3?5?5?$CFlu?$AA@ ; `string'
PUBLIC	??_C@_0BG@LFMD@End?5memory?5usage?5dump?$AA@	; `string'
PUBLIC	??_C@_0CD@GIH@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@ ; `string'
PUBLIC	??_C@_0CC@JMDO@IsListEmpty?$CI?$CGm_lstMemoryTracking@ ; `string'
;	COMDAT ??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@
CONST	SEGMENT
??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@ DB 'CMemoryManager:'
	DB	':DumpMemoryUsage', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CNJN@Begin?5memory?5usage?5dump?$AA@
CONST	SEGMENT
??_C@_0BI@CNJN@Begin?5memory?5usage?5dump?$AA@ DB 'Begin memory usage dum'
	DB	'p', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HDD@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@
CONST	SEGMENT
??_C@_0BI@HDD@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@ DB '%x (%l'
	DB	'u bytes, type %s)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PGGD@Pool?5memory?5used?3?5?5?$CFlu?$AA@
CONST	SEGMENT
??_C@_0BH@PGGD@Pool?5memory?5used?3?5?5?$CFlu?$AA@ DB 'Pool memory used: '
	DB	' %lu', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MNK@Physical?5memory?5used?3?5?5?$CFlu?$AA@
CONST	SEGMENT
??_C@_0BL@MNK@Physical?5memory?5used?3?5?5?$CFlu?$AA@ DB 'Physical memory'
	DB	' used:  %lu', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LFMD@End?5memory?5usage?5dump?$AA@
CONST	SEGMENT
??_C@_0BG@LFMD@End?5memory?5usage?5dump?$AA@ DB 'End memory usage dump', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GIH@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@
CONST	SEGMENT
??_C@_0CD@GIH@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@ DB '!IsListEmpty'
	DB	'(&m_lstMemoryTracking)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JMDO@IsListEmpty?$CI?$CGm_lstMemoryTracking@
CONST	SEGMENT
??_C@_0CC@JMDO@IsListEmpty?$CI?$CGm_lstMemoryTracking@ DB 'IsListEmpty(&m'
	DB	'_lstMemoryTracking)', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z
_TEXT	SEGMENT
_fAssertNone$ = 8
_pleEntry$ = -8
_pTracking$ = -4
?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z PROC NEAR ; DirectSound::CMemoryManager::DumpMemoryUsage, COMDAT

; 930  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 931  : 
; 932  : #ifdef DEBUG
; 933  : 
; 934  :     static const LPCSTR     pszBanner           = "------------------------------------------------------------------------------";
; 935  : 
; 936  : #ifdef TRACK_MEMORY_USAGE
; 937  : 
; 938  :     PLIST_ENTRY             pleEntry;
; 939  :     LPDSMEMTRACK            pTracking;
; 940  : 
; 941  : #endif // TRACK_MEMORY_USAGE
; 942  : 
; 943  :     CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);

  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@ ; `string'
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0001d	83 c4 18	 add	 esp, 24			; 00000018H

; 944  :     CDebug::Print(pszBanner);

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0002b	83 c4 04	 add	 esp, 4

; 945  :     CDebug::Print("Begin memory usage dump");

  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@CNJN@Begin?5memory?5usage?5dump?$AA@ ; `string'
  00033	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00038	83 c4 04	 add	 esp, 4

; 946  :     CDebug::Print(pszBanner);

  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00047	83 c4 04	 add	 esp, 4

; 947  :     
; 948  : #ifdef TRACK_MEMORY_USAGE
; 949  : 
; 950  : #ifdef _XBOX
; 951  : 
; 952  :     //
; 953  :     // Raise IRQL for synchronization
; 954  :     //
; 955  : 
; 956  :     AutoIrql();
; 957  : 
; 958  : #endif // _XBOX
; 959  :    
; 960  :     //
; 961  :     // Show specifically what allocations are remaining
; 962  :     //
; 963  :     
; 964  :     if(m_lstMemoryTracking.Flink)

  0004a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, 0
  00051	0f 84 b8 00 00
	00		 je	 $L52778

; 965  :     {
; 966  :         if(!IsListEmpty(&m_lstMemoryTracking))

  00057	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  00061	0f 84 a8 00 00
	00		 je	 $L52779

; 967  :         {
; 968  :             for(pleEntry = m_lstMemoryTracking.Flink; pleEntry != &m_lstMemoryTracking; pleEntry = pleEntry->Flink)

  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A
  0006d	89 55 f8	 mov	 DWORD PTR _pleEntry$[ebp], edx
  00070	eb 08		 jmp	 SHORT $L52780
$L52781:
  00072	8b 45 f8	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  00075	8b 08		 mov	 ecx, DWORD PTR [eax]
  00077	89 4d f8	 mov	 DWORD PTR _pleEntry$[ebp], ecx
$L52780:
  0007a	81 7d f8 00 00
	00 00		 cmp	 DWORD PTR _pleEntry$[ebp], OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  00081	74 63		 je	 SHORT $L52782

; 969  :             {
; 970  :                 AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

  00083	68 ca 03 00 00	 push	 970			; 000003caH
  00088	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0008d	6a 01		 push	 1
  0008f	8b 55 f8	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  00092	52		 push	 edx
  00093	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 971  :             
; 972  :                 pTracking = CONTAINING_RECORD(pleEntry, DSMEMTRACK, leListEntry);

  00098	8b 45 f8	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  0009b	89 45 fc	 mov	 DWORD PTR _pTracking$[ebp], eax

; 973  : 
; 974  :                 CDebug::SetContext(DPF_FLAGS_FILELINE, DPFLVL_ABSOLUTE, pTracking->pszFile, pTracking->nLine, DPF_FNAME, DPF_LIBRARY);

  0009e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  000a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@ ; `string'
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000ab	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000ae	52		 push	 edx
  000af	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  000b2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b5	51		 push	 ecx
  000b6	6a 00		 push	 0
  000b8	6a 02		 push	 2
  000ba	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000bf	83 c4 18	 add	 esp, 24			; 00000018H

; 975  :                 CDebug::Print("%x (%lu bytes, type %s)", pTracking + 1, pTracking->cbSize, pTracking->pszClass);

  000c2	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  000c5	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000c8	50		 push	 eax
  000c9	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000cc	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000cf	52		 push	 edx
  000d0	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  000d3	83 c0 20	 add	 eax, 32			; 00000020H
  000d6	50		 push	 eax
  000d7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@HDD@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@ ; `string'
  000dc	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000e1	83 c4 10	 add	 esp, 16			; 00000010H

; 976  :             }

  000e4	eb 8c		 jmp	 SHORT $L52781
$L52782:

; 977  : 
; 978  :             CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);

  000e6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  000eb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@ ; `string'
  000f0	6a 00		 push	 0
  000f2	6a 00		 push	 0
  000f4	6a 00		 push	 0
  000f6	6a 01		 push	 1
  000f8	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000fd	83 c4 18	 add	 esp, 24			; 00000018H

; 979  :             CDebug::Print(pszBanner);

  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  00106	51		 push	 ecx
  00107	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0010c	83 c4 04	 add	 esp, 4
$L52779:
$L52778:

; 980  :         }
; 981  :     }
; 982  : 
; 983  : #endif // TRACK_MEMORY_USAGE
; 984  : 
; 985  :     CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);

  0010f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  00114	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@ ; `string'
  00119	6a 00		 push	 0
  0011b	6a 00		 push	 0
  0011d	6a 00		 push	 0
  0011f	6a 01		 push	 1
  00121	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00126	83 c4 18	 add	 esp, 24			; 00000018H

; 986  :     CDebug::Print("Pool memory used:  %lu", m_dwPoolMemoryUsage);

  00129	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  0012f	52		 push	 edx
  00130	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@PGGD@Pool?5memory?5used?3?5?5?$CFlu?$AA@ ; `string'
  00135	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0013a	83 c4 08	 add	 esp, 8

; 987  :     CDebug::Print("Physical memory used:  %lu", m_dwPhysicalMemoryUsage);

  0013d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
  00142	50		 push	 eax
  00143	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@MNK@Physical?5memory?5used?3?5?5?$CFlu?$AA@ ; `string'
  00148	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0014d	83 c4 08	 add	 esp, 8

; 988  : 
; 989  : #ifdef ENABLE_SLOP_MEMORY_RECOVERY
; 990  : 
; 991  :     CDebug::Print("Physical memory available for recovery:  %lu", CMcpxSlopMemoryHeap::m_dwAvailable);
; 992  :     CDebug::Print("Physical memory recovered:  %lu", CMcpxSlopMemoryHeap::m_dwUsed);
; 993  : 
; 994  : #endif // ENABLE_SLOP_MEMORY_RECOVERY
; 995  : 
; 996  :     CDebug::Print(pszBanner);

  00150	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  00156	51		 push	 ecx
  00157	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0015c	83 c4 04	 add	 esp, 4

; 997  :     CDebug::Print("End memory usage dump");

  0015f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@LFMD@End?5memory?5usage?5dump?$AA@ ; `string'
  00164	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00169	83 c4 04	 add	 esp, 4

; 998  :     CDebug::Print(pszBanner);

  0016c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  00172	52		 push	 edx
  00173	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00178	83 c4 04	 add	 esp, 4

; 999  : 
; 1000 : #ifdef ENABLE_SLOP_MEMORY_RECOVERY
; 1001 : 
; 1002 :     if(m_dwPoolMemoryUsage || m_dwPhysicalMemoryUsage || CMcpxSlopMemoryHeap::m_dwAvailable || CMcpxSlopMemoryHeap::m_dwUsed)
; 1003 : 
; 1004 : #else // ENABLE_SLOP_MEMORY_RECOVERY
; 1005 : 
; 1006 :     if(m_dwPoolMemoryUsage || m_dwPhysicalMemoryUsage)

  0017b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA, 0 ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  00182	75 09		 jne	 SHORT $L52792
  00184	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2KA, 0 ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
  0018b	74 30		 je	 SHORT $L52791
$L52792:

; 1007 : 
; 1008 : #endif // ENABLE_SLOP_MEMORY_RECOVERY
; 1009 : 
; 1010 :     {
; 1011 :         if(fAssertNone)

  0018d	83 7d 08 00	 cmp	 DWORD PTR _fAssertNone$[ebp], 0
  00191	74 01		 je	 SHORT $L52793

; 1012 :         {
; 1013 :             __asm int 3

  00193	cc		 int	 3
$L52793:

; 1014 :         }
; 1015 : 
; 1016 : #ifdef TRACK_MEMORY_USAGE
; 1017 : 
; 1018 :         ASSERT(!IsListEmpty(&m_lstMemoryTracking));

  00194	68 fa 03 00 00	 push	 1018			; 000003faH
  00199	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0019e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@GIH@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@ ; `string'
  001a3	33 c0		 xor	 eax, eax
  001a5	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  001af	0f 94 c0	 sete	 al
  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  001b8	83 c4 10	 add	 esp, 16			; 00000010H

; 1019 : 
; 1020 : #endif // TRACK_MEMORY_USAGE
; 1021 : 
; 1022 :     }
; 1023 : 
; 1024 : #ifdef TRACK_MEMORY_USAGE
; 1025 : 
; 1026 :     else

  001bb	eb 27		 jmp	 SHORT $L52795
$L52791:

; 1027 :     {
; 1028 :         ASSERT(IsListEmpty(&m_lstMemoryTracking));

  001bd	68 04 04 00 00	 push	 1028			; 00000404H
  001c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  001c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@JMDO@IsListEmpty?$CI?$CGm_lstMemoryTracking@ ; `string'
  001cc	33 c9		 xor	 ecx, ecx
  001ce	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  001d8	0f 95 c1	 setne	 cl
  001db	51		 push	 ecx
  001dc	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  001e1	83 c4 10	 add	 esp, 16			; 00000010H
$L52795:

; 1029 :     }
; 1030 : 
; 1031 : #endif // TRACK_MEMORY_USAGE
; 1032 : 
; 1033 : #endif // DEBUG
; 1034 : 
; 1035 : }

  001e4	8b e5		 mov	 esp, ebp
  001e6	5d		 pop	 ebp
  001e7	c2 04 00	 ret	 4
?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z ENDP ; DirectSound::CMemoryManager::DumpMemoryUsage
_TEXT	ENDS
PUBLIC	?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::CreatePcmFormat
PUBLIC	??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_04PBHC@pwfx?$AA@				; `string'
;	COMDAT ??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\common\format.cpp
CONST	SEGMENT
??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\privat'
	DB	'e\windows\directx\dsound\common\format.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PBHC@pwfx?$AA@
CONST	SEGMENT
??_C@_04PBHC@pwfx?$AA@ DB 'pwfx', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_wBitsPerSample$ = 16
_pwfx$ = 20
?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::CreatePcmFormat, COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 54   :     DPF_ENTER();
; 55   :     
; 56   :     ASSERT(pwfx);

  00003	6a 38		 push	 56			; 00000038H
  00005	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PBHC@pwfx?$AA@ ; `string'
  0000f	33 c0		 xor	 eax, eax
  00011	83 7d 14 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  00015	0f 94 c0	 sete	 al
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0001e	83 c4 10	 add	 esp, 16			; 00000010H

; 57   : 
; 58   :     pwfx->wFormatTag = WAVE_FORMAT_PCM;

  00021	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00024	66 c7 01 01 00	 mov	 WORD PTR [ecx], 1

; 59   :     pwfx->nChannels = nChannels;

  00029	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0002c	66 8b 45 08	 mov	 ax, WORD PTR _nChannels$[ebp]
  00030	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 60   :     pwfx->nSamplesPerSec = nSamplesPerSec;

  00034	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00037	8b 55 0c	 mov	 edx, DWORD PTR _nSamplesPerSec$[ebp]
  0003a	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 61   :     pwfx->wBitsPerSample = wBitsPerSample;

  0003d	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00040	66 8b 4d 10	 mov	 cx, WORD PTR _wBitsPerSample$[ebp]
  00044	66 89 48 0e	 mov	 WORD PTR [eax+14], cx

; 62   :     pwfx->nBlockAlign = nChannels * wBitsPerSample / 8;

  00048	8b 45 08	 mov	 eax, DWORD PTR _nChannels$[ebp]
  0004b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00050	8b 55 10	 mov	 edx, DWORD PTR _wBitsPerSample$[ebp]
  00053	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00059	0f af c2	 imul	 eax, edx
  0005c	99		 cdq
  0005d	83 e2 07	 and	 edx, 7
  00060	03 c2		 add	 eax, edx
  00062	c1 f8 03	 sar	 eax, 3
  00065	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00068	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 63   :     pwfx->nAvgBytesPerSec = nSamplesPerSec * pwfx->nBlockAlign;

  0006c	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0006f	33 c0		 xor	 eax, eax
  00071	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  00075	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  00078	0f af c8	 imul	 ecx, eax
  0007b	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0007e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 64   :     pwfx->cbSize = 0;

  00081	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00084	66 c7 40 10 00
	00		 mov	 WORD PTR [eax+16], 0

; 65   : 
; 66   :     DPF_LEAVE_VOID();
; 67   : }

  0008a	5d		 pop	 ebp
  0008b	c2 10 00	 ret	 16			; 00000010H
?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::CreatePcmFormat
_TEXT	ENDS
PUBLIC	?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUima_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::CreateXboxAdpcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_pwfx$ = 16
?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUima_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::WaveFormat::CreateXboxAdpcmFormat, COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 98   :     DPF_ENTER();
; 99   :     
; 100  :     ASSERT(pwfx);

  00003	6a 64		 push	 100			; 00000064H
  00005	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PBHC@pwfx?$AA@ ; `string'
  0000f	33 c0		 xor	 eax, eax
  00011	83 7d 10 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  00015	0f 94 c0	 sete	 al
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0001e	83 c4 10	 add	 esp, 16			; 00000010H

; 101  : 
; 102  :     pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  00021	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00024	66 c7 01 69 00	 mov	 WORD PTR [ecx], 105	; 00000069H

; 103  :     pwfx->wfx.nChannels = nChannels;

  00029	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0002c	66 8b 45 08	 mov	 ax, WORD PTR _nChannels$[ebp]
  00030	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 104  :     pwfx->wfx.nSamplesPerSec = nSamplesPerSec;

  00034	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00037	8b 55 0c	 mov	 edx, DWORD PTR _nSamplesPerSec$[ebp]
  0003a	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 105  :     pwfx->wfx.wBitsPerSample = XBOX_ADPCM_BITS_PER_SAMPLE;

  0003d	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00040	66 c7 40 0e 04
	00		 mov	 WORD PTR [eax+14], 4

; 106  :     pwfx->wfx.nBlockAlign = nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  00046	8b 4d 08	 mov	 ecx, DWORD PTR _nChannels$[ebp]
  00049	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0004f	6b c9 24	 imul	 ecx, 36			; 00000024H
  00052	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00055	66 89 4a 0c	 mov	 WORD PTR [edx+12], cx

; 107  :     pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec / XBOX_ADPCM_SAMPLES_PER_BLOCK * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  00059	8b 45 0c	 mov	 eax, DWORD PTR _nSamplesPerSec$[ebp]
  0005c	c1 e8 06	 shr	 eax, 6
  0005f	6b c0 24	 imul	 eax, 36			; 00000024H
  00062	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00065	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 108  :     pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);

  00068	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0006b	66 c7 42 10 02
	00		 mov	 WORD PTR [edx+16], 2

; 109  :     pwfx->wSamplesPerBlock = XBOX_ADPCM_SAMPLES_PER_BLOCK;

  00071	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00074	66 c7 40 12 40
	00		 mov	 WORD PTR [eax+18], 64	; 00000040H

; 110  : 
; 111  :     DPF_LEAVE_VOID();
; 112  : }

  0007a	5d		 pop	 ebp
  0007b	c2 0c 00	 ret	 12			; 0000000cH
?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUima_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::WaveFormat::CreateXboxAdpcmFormat
_TEXT	ENDS
PUBLIC	?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::CreateInternalFormat
PUBLIC	?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::PcmToInternalFormat
PUBLIC	?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUima_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::AdpcmToInternalFormat
PUBLIC	??_C@_05MJPI@pDest?$AA@				; `string'
PUBLIC	??_C@_07JEGE@pSource?$AA@			; `string'
PUBLIC	??_C@_0BG@MOEB@Unexpected?5format?5tag?$AA@	; `string'
;	COMDAT ??_C@_05MJPI@pDest?$AA@
CONST	SEGMENT
??_C@_05MJPI@pDest?$AA@ DB 'pDest', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07JEGE@pSource?$AA@
CONST	SEGMENT
??_C@_07JEGE@pSource?$AA@ DB 'pSource', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MOEB@Unexpected?5format?5tag?$AA@
CONST	SEGMENT
??_C@_0BG@MOEB@Unexpected?5format?5tag?$AA@ DB 'Unexpected format tag', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_pDest$ = 8
_pSource$ = 12
_dwChannelMask$ = -4
?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::CreateInternalFormat, COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 142  :     DWORD                   dwChannelMask   = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwChannelMask$[ebp], 0

; 143  :     
; 144  :     DPF_ENTER();
; 145  : 
; 146  :     ASSERT(pDest);

  0000d	68 92 00 00 00	 push	 146			; 00000092H
  00012	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05MJPI@pDest?$AA@ ; `string'
  0001c	33 c0		 xor	 eax, eax
  0001e	83 7d 08 00	 cmp	 DWORD PTR _pDest$[ebp], 0
  00022	0f 94 c0	 sete	 al
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 147  :     ASSERT(pSource);

  0002e	68 93 00 00 00	 push	 147			; 00000093H
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07JEGE@pSource?$AA@ ; `string'
  0003d	33 c9		 xor	 ecx, ecx
  0003f	83 7d 0c 00	 cmp	 DWORD PTR _pSource$[ebp], 0
  00043	0f 94 c1	 sete	 cl
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0004c	83 c4 10	 add	 esp, 16			; 00000010H

; 148  : 
; 149  :     switch(pSource->wFormatTag)
; 150  :     {

  0004f	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00052	33 c0		 xor	 eax, eax
  00054	66 8b 02	 mov	 ax, WORD PTR [edx]
  00057	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  0005a	83 7d f8 01	 cmp	 DWORD PTR -8+[ebp], 1
  0005e	74 08		 je	 SHORT $L52822
  00060	83 7d f8 69	 cmp	 DWORD PTR -8+[ebp], 105	; 00000069H
  00064	74 11		 je	 SHORT $L52823
  00066	eb 1e		 jmp	 SHORT $L52825
$L52822:

; 151  :         case WAVE_FORMAT_PCM:
; 152  :             PcmToInternalFormat(pDest, pSource);

  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  0006b	51		 push	 ecx
  0006c	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 ?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::PcmToInternalFormat

; 153  :             break;

  00075	eb 28		 jmp	 SHORT $L52819
$L52823:

; 154  : 
; 155  :         case WAVE_FORMAT_XBOX_ADPCM:
; 156  :             AdpcmToInternalFormat(pDest, (LPCXBOXADPCMWAVEFORMAT)pSource);

  00077	8b 45 0c	 mov	 eax, DWORD PTR _pSource$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUima_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::AdpcmToInternalFormat

; 157  :             break;

  00084	eb 19		 jmp	 SHORT $L52819
$L52825:

; 158  : 
; 159  : #if defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 160  : 
; 161  :         case WAVE_FORMAT_EXTENSIBLE:
; 162  :             dwChannelMask = ExtensibleToInternalFormat(pDest, (LPCWAVEFORMATEXTENSIBLE)pSource);
; 163  :             break;
; 164  : 
; 165  : #endif // defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 166  : 
; 167  :         default:
; 168  :             ASSERTMSG("Unexpected format tag");

  00086	68 a8 00 00 00	 push	 168			; 000000a8H
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@MOEB@Unexpected?5format?5tag?$AA@ ; `string'
  00095	6a 01		 push	 1
  00097	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0009c	83 c4 10	 add	 esp, 16			; 00000010H
$L52819:

; 169  :             break;
; 170  :     }
; 171  : 
; 172  :     DPF_LEAVE(dwChannelMask);
; 173  : 
; 174  :     return dwChannelMask;

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _dwChannelMask$[ebp]

; 175  : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 08 00	 ret	 8
?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::CreateInternalFormat
_TEXT	ENDS
PUBLIC	??_C@_0BK@NKLB@WaveFormat?3?3IsValidFormat?$AA@	; `string'
PUBLIC	??_C@_0BH@MKMD@Unsupported?5format?5tag?$AA@	; `string'
PUBLIC	?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::IsValidFormat
PUBLIC	?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::IsValidPcmFormat
PUBLIC	?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::IsValidAdpcmFormat
;	COMDAT ??_C@_0BK@NKLB@WaveFormat?3?3IsValidFormat?$AA@
CONST	SEGMENT
??_C@_0BK@NKLB@WaveFormat?3?3IsValidFormat?$AA@ DB 'WaveFormat::IsValidFo'
	DB	'rmat', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MKMD@Unsupported?5format?5tag?$AA@
CONST	SEGMENT
??_C@_0BH@MKMD@Unsupported?5format?5tag?$AA@ DB 'Unsupported format tag', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_pwfx$ = 8
_fSuccess$ = -4
?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::IsValidFormat, COMDAT

; 201  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 202  :     BOOL                    fSuccess;
; 203  :     
; 204  :     DPF_ENTER();
; 205  : 
; 206  :     ASSERT(pwfx);

  00006	68 ce 00 00 00	 push	 206			; 000000ceH
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PBHC@pwfx?$AA@ ; `string'
  00015	33 c0		 xor	 eax, eax
  00017	83 7d 08 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  0001b	0f 94 c0	 sete	 al
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 207  : 
; 208  :     switch(pwfx->wFormatTag)
; 209  :     {

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0002a	33 d2		 xor	 edx, edx
  0002c	66 8b 11	 mov	 dx, WORD PTR [ecx]
  0002f	89 55 f8	 mov	 DWORD PTR -8+[ebp], edx
  00032	83 7d f8 01	 cmp	 DWORD PTR -8+[ebp], 1
  00036	74 08		 je	 SHORT $L52835
  00038	83 7d f8 69	 cmp	 DWORD PTR -8+[ebp], 105	; 00000069H
  0003c	74 10		 je	 SHORT $L52836
  0003e	eb 1c		 jmp	 SHORT $L52838
$L52835:

; 210  :         case WAVE_FORMAT_PCM:
; 211  :             fSuccess = IsValidPcmFormat(pwfx);

  00040	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::IsValidPcmFormat
  00049	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 212  :             break;

  0004c	eb 42		 jmp	 SHORT $L52832
$L52836:

; 213  : 
; 214  :         case WAVE_FORMAT_XBOX_ADPCM:
; 215  :             fSuccess = IsValidAdpcmFormat((LPCXBOXADPCMWAVEFORMAT)pwfx);

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::IsValidAdpcmFormat
  00057	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 216  :             break;

  0005a	eb 34		 jmp	 SHORT $L52832
$L52838:

; 217  : 
; 218  : #if defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 219  : 
; 220  :         case WAVE_FORMAT_EXTENSIBLE:
; 221  :             fSuccess = IsValidExtensibleFormat((LPCWAVEFORMATEXTENSIBLE)pwfx);
; 222  :             break;
; 223  : 
; 224  : #endif // defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 225  : 
; 226  :         default:
; 227  :             DPF_ERROR("Unsupported format tag");

  0005c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  00061	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@NKLB@WaveFormat?3?3IsValidFormat?$AA@ ; `string'
  00066	68 e3 00 00 00	 push	 227			; 000000e3H
  0006b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00070	6a 01		 push	 1
  00072	6a 09		 push	 9
  00074	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00079	83 c4 18	 add	 esp, 24			; 00000018H
  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@MKMD@Unsupported?5format?5tag?$AA@ ; `string'
  00081	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00086	83 c4 04	 add	 esp, 4

; 228  :             fSuccess = FALSE;

  00089	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0
$L52832:

; 229  :             break;
; 230  :     }
; 231  : 
; 232  :     DPF_LEAVE(fSuccess);
; 233  : 
; 234  :     return fSuccess;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 235  : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::IsValidFormat
_TEXT	ENDS
PUBLIC	??_C@_0BL@OKFK@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@ ; `string'
PUBLIC	??_C@_0CA@GBOE@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@ ; `string'
PUBLIC	??_C@_0BN@GMMP@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@ ; `string'
;	COMDAT ??_C@_0BL@OKFK@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT
??_C@_0BL@OKFK@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@ DB 'pSource->n'
	DB	'Channels <= 0xFF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GBOE@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT
??_C@_0CA@GBOE@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@ DB 'pSour'
	DB	'ce->wBitsPerSample <= 0xFF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GMMP@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT
??_C@_0BN@GMMP@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@ DB 'pSource-'
	DB	'>nBlockAlign <= 0xFF', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_pDest$ = 8
_pSource$ = 12
?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::PcmToInternalFormat, COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 265  :     DPF_ENTER();
; 266  : 
; 267  :     ASSERT(pDest);

  00003	68 0b 01 00 00	 push	 267			; 0000010bH
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05MJPI@pDest?$AA@ ; `string'
  00012	33 c0		 xor	 eax, eax
  00014	83 7d 08 00	 cmp	 DWORD PTR _pDest$[ebp], 0
  00018	0f 94 c0	 sete	 al
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 268  :     ASSERT(pSource);

  00024	68 0c 01 00 00	 push	 268			; 0000010cH
  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07JEGE@pSource?$AA@ ; `string'
  00033	33 c9		 xor	 ecx, ecx
  00035	83 7d 0c 00	 cmp	 DWORD PTR _pSource$[ebp], 0
  00039	0f 94 c1	 sete	 cl
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00042	83 c4 10	 add	 esp, 16			; 00000010H

; 269  : 
; 270  :     ASSERT(pSource->nChannels <= 0xFF);

  00045	68 0e 01 00 00	 push	 270			; 0000010eH
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@OKFK@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@ ; `string'
  00054	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00057	33 c0		 xor	 eax, eax
  00059	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  0005d	33 c9		 xor	 ecx, ecx
  0005f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00064	0f 9f c1	 setg	 cl
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0006d	83 c4 10	 add	 esp, 16			; 00000010H

; 271  :     ASSERT(pSource->wBitsPerSample <= 0xFF);

  00070	68 0f 01 00 00	 push	 271			; 0000010fH
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@GBOE@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@ ; `string'
  0007f	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00082	33 c0		 xor	 eax, eax
  00084	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  00088	33 c9		 xor	 ecx, ecx
  0008a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0008f	0f 9f c1	 setg	 cl
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00098	83 c4 10	 add	 esp, 16			; 00000010H

; 272  :     ASSERT(pSource->nBlockAlign <= 0xFF);

  0009b	68 10 01 00 00	 push	 272			; 00000110H
  000a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@GMMP@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@ ; `string'
  000aa	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  000ad	33 c0		 xor	 eax, eax
  000af	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  000b3	33 c9		 xor	 ecx, ecx
  000b5	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000ba	0f 9f c1	 setg	 cl
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000c3	83 c4 10	 add	 esp, 16			; 00000010H

; 273  : 
; 274  :     pDest->wFormatTag = WAVE_FORMAT_PCM;

  000c6	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  000c9	66 c7 02 01 00	 mov	 WORD PTR [edx], 1

; 275  :     pDest->nChannels = (BYTE)pSource->nChannels;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000d4	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  000d7	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 276  :     pDest->wBitsPerSample = (BYTE)pSource->wBitsPerSample;

  000da	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000e0	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  000e3	88 50 03	 mov	 BYTE PTR [eax+3], dl

; 277  :     pDest->nSamplesPerSec = pSource->nSamplesPerSec;

  000e6	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000e9	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000ec	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ef	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 278  :     pDest->nBlockAlign = (BYTE)pSource->nBlockAlign;

  000f2	8b 45 0c	 mov	 eax, DWORD PTR _pSource$[ebp]
  000f5	33 c9		 xor	 ecx, ecx
  000f7	8a 48 0c	 mov	 cl, BYTE PTR [eax+12]
  000fa	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  000fd	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 279  : 
; 280  :     DPF_LEAVE_VOID();
; 281  : }

  00100	5d		 pop	 ebp
  00101	c2 08 00	 ret	 8
?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::PcmToInternalFormat
_TEXT	ENDS
PUBLIC	??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@ ; `string'
PUBLIC	??_C@_0BD@IKOG@Format?5tag?5not?5PCM?$AA@	; `string'
PUBLIC	??_C@_0BG@DNIK@Invalid?5channel?5count?$AA@	; `string'
PUBLIC	??_C@_0BO@NALA@Invalid?5sample?5bit?5resolution?$AA@ ; `string'
PUBLIC	??_C@_0BG@PDOD@Invalid?5sampling?5rate?$AA@	; `string'
PUBLIC	??_C@_0BE@CHML@Bad?5block?5alignment?$AA@	; `string'
;	COMDAT ??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@
CONST	SEGMENT
??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@ DB 'WaveFormat::IsVali'
	DB	'dPcmFormat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IKOG@Format?5tag?5not?5PCM?$AA@
CONST	SEGMENT
??_C@_0BD@IKOG@Format?5tag?5not?5PCM?$AA@ DB 'Format tag not PCM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DNIK@Invalid?5channel?5count?$AA@
CONST	SEGMENT
??_C@_0BG@DNIK@Invalid?5channel?5count?$AA@ DB 'Invalid channel count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NALA@Invalid?5sample?5bit?5resolution?$AA@
CONST	SEGMENT
??_C@_0BO@NALA@Invalid?5sample?5bit?5resolution?$AA@ DB 'Invalid sample b'
	DB	'it resolution', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PDOD@Invalid?5sampling?5rate?$AA@
CONST	SEGMENT
??_C@_0BG@PDOD@Invalid?5sampling?5rate?$AA@ DB 'Invalid sampling rate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CHML@Bad?5block?5alignment?$AA@
CONST	SEGMENT
??_C@_0BE@CHML@Bad?5block?5alignment?$AA@ DB 'Bad block alignment', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_pwfx$ = 8
_fValid$ = -4
?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::IsValidPcmFormat, COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 308  :     BOOL                    fValid  = TRUE;

  00004	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 1

; 309  : 
; 310  :     DPF_ENTER();
; 311  : 
; 312  :     ASSERT(pwfx);

  0000b	68 38 01 00 00	 push	 312			; 00000138H
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PBHC@pwfx?$AA@ ; `string'
  0001a	33 c0		 xor	 eax, eax
  0001c	83 7d 08 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  00020	0f 94 c0	 sete	 al
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00029	83 c4 10	 add	 esp, 16			; 00000010H

; 313  : 
; 314  :     if(WAVE_FORMAT_PCM != pwfx->wFormatTag)

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0002f	33 d2		 xor	 edx, edx
  00031	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00034	83 fa 01	 cmp	 edx, 1
  00037	74 34		 je	 SHORT $L52855

; 315  :     {
; 316  :         DPF_ERROR("Format tag not PCM");

  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@ ; `string'
  00043	68 3c 01 00 00	 push	 316			; 0000013cH
  00048	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004d	6a 01		 push	 1
  0004f	6a 09		 push	 9
  00051	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00056	83 c4 18	 add	 esp, 24			; 00000018H
  00059	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@IKOG@Format?5tag?5not?5PCM?$AA@ ; `string'
  0005e	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00063	83 c4 04	 add	 esp, 4

; 317  :         fValid = FALSE;

  00066	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L52855:

; 318  :     }
; 319  :     
; 320  :     if((1 != pwfx->nChannels) && (2 != pwfx->nChannels) && (4 != pwfx->nChannels) && (6 != pwfx->nChannels))

  0006d	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00070	33 c9		 xor	 ecx, ecx
  00072	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00076	83 f9 01	 cmp	 ecx, 1
  00079	74 5e		 je	 SHORT $L52858
  0007b	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0007e	33 c0		 xor	 eax, eax
  00080	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00084	83 f8 02	 cmp	 eax, 2
  00087	74 50		 je	 SHORT $L52858
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0008c	33 d2		 xor	 edx, edx
  0008e	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  00092	83 fa 04	 cmp	 edx, 4
  00095	74 42		 je	 SHORT $L52858
  00097	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0009a	33 c9		 xor	 ecx, ecx
  0009c	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  000a0	83 f9 06	 cmp	 ecx, 6
  000a3	74 34		 je	 SHORT $L52858

; 321  :     {
; 322  :         DPF_ERROR("Invalid channel count");

  000a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  000aa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@ ; `string'
  000af	68 42 01 00 00	 push	 322			; 00000142H
  000b4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000b9	6a 01		 push	 1
  000bb	6a 09		 push	 9
  000bd	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000c2	83 c4 18	 add	 esp, 24			; 00000018H
  000c5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@DNIK@Invalid?5channel?5count?$AA@ ; `string'
  000ca	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000cf	83 c4 04	 add	 esp, 4

; 323  :         fValid = FALSE;

  000d2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L52858:

; 324  :     }
; 325  : 
; 326  :     if((8 != pwfx->wBitsPerSample) && (16 != pwfx->wBitsPerSample))

  000d9	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  000dc	33 c0		 xor	 eax, eax
  000de	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  000e2	83 f8 08	 cmp	 eax, 8
  000e5	74 42		 je	 SHORT $L52860
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  000ea	33 d2		 xor	 edx, edx
  000ec	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  000f0	83 fa 10	 cmp	 edx, 16			; 00000010H
  000f3	74 34		 je	 SHORT $L52860

; 327  :     {
; 328  :         DPF_ERROR("Invalid sample bit resolution");

  000f5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  000fa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@ ; `string'
  000ff	68 48 01 00 00	 push	 328			; 00000148H
  00104	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00109	6a 01		 push	 1
  0010b	6a 09		 push	 9
  0010d	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00112	83 c4 18	 add	 esp, 24			; 00000018H
  00115	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@NALA@Invalid?5sample?5bit?5resolution?$AA@ ; `string'
  0011a	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0011f	83 c4 04	 add	 esp, 4

; 329  :         fValid = FALSE;

  00122	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L52860:

; 330  :     }
; 331  : 
; 332  :     if((pwfx->nSamplesPerSec < DSBFREQUENCY_MIN) || (pwfx->nSamplesPerSec > DSBFREQUENCY_MAX))

  00129	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0012c	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  00130	72 0c		 jb	 SHORT $L52863
  00132	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00135	81 79 04 ff ff
	ff 7f		 cmp	 DWORD PTR [ecx+4], 2147483647 ; 7fffffffH
  0013c	76 34		 jbe	 SHORT $L52862
$L52863:

; 333  :     {
; 334  :         DPF_ERROR("Invalid sampling rate");

  0013e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  00143	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@ ; `string'
  00148	68 4e 01 00 00	 push	 334			; 0000014eH
  0014d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00152	6a 01		 push	 1
  00154	6a 09		 push	 9
  00156	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0015b	83 c4 18	 add	 esp, 24			; 00000018H
  0015e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@PDOD@Invalid?5sampling?5rate?$AA@ ; `string'
  00163	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00168	83 c4 04	 add	 esp, 4

; 335  :         fValid = FALSE;

  0016b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L52862:

; 336  :     }
; 337  : 
; 338  :     if(pwfx->nChannels * pwfx->wBitsPerSample / 8 != pwfx->nBlockAlign)

  00172	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00175	33 c0		 xor	 eax, eax
  00177	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  0017b	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0017e	33 d2		 xor	 edx, edx
  00180	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  00184	0f af c2	 imul	 eax, edx
  00187	99		 cdq
  00188	83 e2 07	 and	 edx, 7
  0018b	03 c2		 add	 eax, edx
  0018d	c1 f8 03	 sar	 eax, 3
  00190	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00193	33 d2		 xor	 edx, edx
  00195	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  00199	3b c2		 cmp	 eax, edx
  0019b	74 34		 je	 SHORT $L52865

; 339  :     {
; 340  :         DPF_ERROR("Bad block alignment");

  0019d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  001a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@ ; `string'
  001a7	68 54 01 00 00	 push	 340			; 00000154H
  001ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  001b1	6a 01		 push	 1
  001b3	6a 09		 push	 9
  001b5	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  001ba	83 c4 18	 add	 esp, 24			; 00000018H
  001bd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@CHML@Bad?5block?5alignment?$AA@ ; `string'
  001c2	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001c7	83 c4 04	 add	 esp, 4

; 341  :         fValid = FALSE;

  001ca	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L52865:

; 342  :     }
; 343  : 
; 344  :     DPF_LEAVE(fValid);
; 345  : 
; 346  :     return fValid;

  001d1	8b 45 fc	 mov	 eax, DWORD PTR _fValid$[ebp]

; 347  : }

  001d4	8b e5		 mov	 esp, ebp
  001d6	5d		 pop	 ebp
  001d7	c2 04 00	 ret	 4
?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::IsValidPcmFormat
_TEXT	ENDS
PUBLIC	??_C@_0BP@ILPH@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@ ; `string'
PUBLIC	??_C@_0CE@HOLG@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@ ; `string'
PUBLIC	??_C@_0CB@CADJ@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@ ; `string'
;	COMDAT ??_C@_0BP@ILPH@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT
??_C@_0BP@ILPH@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@ DB 'pSour'
	DB	'ce->wfx.nChannels <= 0xFF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HOLG@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@
CONST	SEGMENT
??_C@_0CE@HOLG@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@ DB 'pSource'
	DB	'->wfx.wBitsPerSample <= 0xFF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CADJ@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@
CONST	SEGMENT
??_C@_0CB@CADJ@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@ DB 'pSource'
	DB	'->wfx.nBlockAlign <= 0xFF', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT
_pDest$ = 8
_pSource$ = 12
?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUima_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::WaveFormat::AdpcmToInternalFormat, COMDAT

; 376  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 377  :     static const BYTE       wBitsPerSample      = 4;
; 378  : 
; 379  :     DPF_ENTER();
; 380  : 
; 381  :     ASSERT(pDest);

  00003	68 7d 01 00 00	 push	 381			; 0000017dH
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05MJPI@pDest?$AA@ ; `string'
  00012	33 c0		 xor	 eax, eax
  00014	83 7d 08 00	 cmp	 DWORD PTR _pDest$[ebp], 0
  00018	0f 94 c0	 sete	 al
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 382  :     ASSERT(pSource);

  00024	68 7e 01 00 00	 push	 382			; 0000017eH
  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07JEGE@pSource?$AA@ ; `string'
  00033	33 c9		 xor	 ecx, ecx
  00035	83 7d 0c 00	 cmp	 DWORD PTR _pSource$[ebp], 0
  00039	0f 94 c1	 sete	 cl
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00042	83 c4 10	 add	 esp, 16			; 00000010H

; 383  : 
; 384  :     ASSERT(pSource->wfx.nChannels <= 0xFF);

  00045	68 80 01 00 00	 push	 384			; 00000180H
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@ILPH@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@ ; `string'
  00054	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00057	33 c0		 xor	 eax, eax
  00059	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  0005d	33 c9		 xor	 ecx, ecx
  0005f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00064	0f 9f c1	 setg	 cl
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0006d	83 c4 10	 add	 esp, 16			; 00000010H

; 385  :     ASSERT(pSource->wfx.wBitsPerSample <= 0xFF);

  00070	68 81 01 00 00	 push	 385			; 00000181H
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@HOLG@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@ ; `string'
  0007f	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00082	33 c0		 xor	 eax, eax
  00084	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  00088	33 c9		 xor	 ecx, ecx
  0008a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0008f	0f 9f c1	 setg	 cl
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00098	83 c4 10	 add	 esp, 16			; 00000010H

; 386  :     ASSERT(pSource->wfx.nBlockAlign <= 0xFF);

  0009b	68 82 01 00 00	 push	 386			; 00000182H
  000a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@CADJ@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@ ; `string'
  000aa	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  000ad	33 c0		 xor	 eax, eax
  000af	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  000b3	33 c9		 xor	 ecx, ecx
  000b5	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000ba	0f 9f c1	 setg	 cl
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000c3	83 c4 10	 add	 esp, 16			; 00000010H

; 387  : 
; 388  :     pDest->wFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  000c6	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  000c9	66 c7 02 69 00	 mov	 WORD PTR [edx], 105	; 00000069H

; 389  :     pDest->nChannels = (BYTE)pSource->wfx.nChannels;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000d4	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  000d7	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 390  :     pDest->wBitsPerSample = (BYTE)wBitsPerSample;

  000da	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000dd	c6 40 03 04	 mov	 BYTE PTR [eax+3], 4

; 391  :     pDest->nSamplesPerSec = pSource->wfx.nSamplesPerSec;

  000e1	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  000e4	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  000e7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ea	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 392  :     pDest->nBlockAlign = (BYTE)pSource->wfx.nBlockAlign;

  000ed	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000f0	33 d2		 xor	 edx, edx
  000f2	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  000f5	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000f8	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 393  : 
; 394  :     DPF_LEAVE_VOID();
; 395  : }

  000fb	5d		 pop	 ebp
  000fc	c2 08 00	 ret	 8
?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUima_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::WaveFormat::AdpcmToInternalFormat
_TEXT	ENDS
PUBLIC	??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
PUBLIC	??_C@_0BK@OFFM@Format?5tag?5not?5XBOX_ADPCM?$AA@ ; `string'
PUBLIC	??_C@_0P@DKJO@cbSize?5not?5?$CFlu?$AA@		; `string'
PUBLIC	??_C@_0BK@GLJN@Invalid?5samples?5per?5block?$AA@ ; `string'
PUBLIC	??_C@_0BE@OJBC@Bad?5block?9alignment?$AA@	; `string'
;	COMDAT ??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@
CONST	SEGMENT
??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ DB 'WaveFormat::IsVa'
	DB	'lidAdpcmFormat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OFFM@Format?5tag?5not?5XBOX_ADPCM?$AA@
CONST	SEGMENT
??_C@_0BK@OFFM@Format?5tag?5not?5XBOX_ADPCM?$AA@ DB 'Format tag not XBOX_'
	DB	'ADPCM', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DKJO@cbSize?5not?5?$CFlu?$AA@
CONST	SEGMENT
??_C@_0P@DKJO@cbSize?5not?5?$CFlu?$AA@ DB 'cbSize not %lu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GLJN@Invalid?5samples?5per?5block?$AA@
CONST	SEGMENT
??_C@_0BK@GLJN@Invalid?5samples?5per?5block?$AA@ DB 'Invalid samples per '
	DB	'block', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OJBC@Bad?5block?9alignment?$AA@
CONST	SEGMENT
??_C@_0BE@OJBC@Bad?5block?9alignment?$AA@ DB 'Bad block-alignment', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT
_pwfx$ = 8
_fValid$ = -4
?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::WaveFormat::IsValidAdpcmFormat, COMDAT

; 421  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 422  :     static const WORD       wSamplesPerBlock    = 64;
; 423  :     static const WORD       wBitsPerSample      = 4;
; 424  :     static const WORD       wBytesPerBlock      = 36;
; 425  :     BOOL                    fValid              = TRUE;

  00004	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 1

; 426  : 
; 427  :     DPF_ENTER();
; 428  : 
; 429  :     ASSERT(pwfx);

  0000b	68 ad 01 00 00	 push	 429			; 000001adH
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PBHC@pwfx?$AA@ ; `string'
  0001a	33 c0		 xor	 eax, eax
  0001c	83 7d 08 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  00020	0f 94 c0	 sete	 al
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00029	83 c4 10	 add	 esp, 16			; 00000010H

; 430  : 
; 431  :     if(WAVE_FORMAT_XBOX_ADPCM != pwfx->wfx.wFormatTag)

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0002f	33 d2		 xor	 edx, edx
  00031	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00034	83 fa 69	 cmp	 edx, 105		; 00000069H
  00037	74 34		 je	 SHORT $L52889

; 432  :     {
; 433  :         DPF_ERROR("Format tag not XBOX_ADPCM");

  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
  00043	68 b1 01 00 00	 push	 433			; 000001b1H
  00048	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004d	6a 01		 push	 1
  0004f	6a 09		 push	 9
  00051	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00056	83 c4 18	 add	 esp, 24			; 00000018H
  00059	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@OFFM@Format?5tag?5not?5XBOX_ADPCM?$AA@ ; `string'
  0005e	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00063	83 c4 04	 add	 esp, 4

; 434  :         fValid = FALSE;

  00066	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L52889:

; 435  :     }
; 436  :     
; 437  :     if(sizeof(*pwfx) - sizeof(pwfx->wfx) != pwfx->wfx.cbSize)

  0006d	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00070	33 c9		 xor	 ecx, ecx
  00072	66 8b 48 10	 mov	 cx, WORD PTR [eax+16]
  00076	83 f9 02	 cmp	 ecx, 2
  00079	74 36		 je	 SHORT $L52892

; 438  :     {
; 439  :         DPF_ERROR("cbSize not %lu", sizeof(*pwfx) - sizeof(pwfx->wfx));

  0007b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  00080	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
  00085	68 b7 01 00 00	 push	 439			; 000001b7H
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0008f	6a 01		 push	 1
  00091	6a 09		 push	 9
  00093	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00098	83 c4 18	 add	 esp, 24			; 00000018H
  0009b	6a 02		 push	 2
  0009d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@DKJO@cbSize?5not?5?$CFlu?$AA@ ; `string'
  000a2	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000a7	83 c4 08	 add	 esp, 8

; 440  :         fValid = FALSE;

  000aa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L52892:

; 441  :     }
; 442  :     
; 443  :     if((pwfx->wfx.nChannels < 1) || (pwfx->wfx.nChannels > 2))

  000b1	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  000b4	33 c0		 xor	 eax, eax
  000b6	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  000ba	83 f8 01	 cmp	 eax, 1
  000bd	7c 0e		 jl	 SHORT $L52895
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  000c2	33 d2		 xor	 edx, edx
  000c4	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  000c8	83 fa 02	 cmp	 edx, 2
  000cb	7e 34		 jle	 SHORT $L52894
$L52895:

; 444  :     {
; 445  :         DPF_ERROR("Invalid channel count");

  000cd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  000d2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
  000d7	68 bd 01 00 00	 push	 445			; 000001bdH
  000dc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000e1	6a 01		 push	 1
  000e3	6a 09		 push	 9
  000e5	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000ea	83 c4 18	 add	 esp, 24			; 00000018H
  000ed	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@DNIK@Invalid?5channel?5count?$AA@ ; `string'
  000f2	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000f7	83 c4 04	 add	 esp, 4

; 446  :         fValid = FALSE;

  000fa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L52894:

; 447  :     }
; 448  : 
; 449  :     if((pwfx->wfx.nSamplesPerSec < DSBFREQUENCY_MIN) || (pwfx->wfx.nSamplesPerSec > DSBFREQUENCY_MAX))

  00101	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00104	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  00108	72 0c		 jb	 SHORT $L52897
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0010d	81 79 04 ff ff
	ff 7f		 cmp	 DWORD PTR [ecx+4], 2147483647 ; 7fffffffH
  00114	76 34		 jbe	 SHORT $L52896
$L52897:

; 450  :     {
; 451  :         DPF_ERROR("Invalid sampling rate");

  00116	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  0011b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
  00120	68 c3 01 00 00	 push	 451			; 000001c3H
  00125	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0012a	6a 01		 push	 1
  0012c	6a 09		 push	 9
  0012e	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00133	83 c4 18	 add	 esp, 24			; 00000018H
  00136	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@PDOD@Invalid?5sampling?5rate?$AA@ ; `string'
  0013b	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00140	83 c4 04	 add	 esp, 4

; 452  :         fValid = FALSE;

  00143	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L52896:

; 453  :     }
; 454  : 
; 455  :     if(wBitsPerSample != pwfx->wfx.wBitsPerSample)

  0014a	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0014d	33 c0		 xor	 eax, eax
  0014f	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  00153	83 f8 04	 cmp	 eax, 4
  00156	74 34		 je	 SHORT $L52898

; 456  :     {
; 457  :         DPF_ERROR("Invalid sample bit resolution");

  00158	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  0015d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
  00162	68 c9 01 00 00	 push	 457			; 000001c9H
  00167	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0016c	6a 01		 push	 1
  0016e	6a 09		 push	 9
  00170	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00175	83 c4 18	 add	 esp, 24			; 00000018H
  00178	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@NALA@Invalid?5sample?5bit?5resolution?$AA@ ; `string'
  0017d	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00182	83 c4 04	 add	 esp, 4

; 458  :         fValid = FALSE;

  00185	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L52898:

; 459  :     }
; 460  : 
; 461  :     if(wSamplesPerBlock != pwfx->wSamplesPerBlock)

  0018c	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0018f	33 d2		 xor	 edx, edx
  00191	66 8b 51 12	 mov	 dx, WORD PTR [ecx+18]
  00195	83 fa 40	 cmp	 edx, 64			; 00000040H
  00198	74 34		 je	 SHORT $L52899

; 462  :     {
; 463  :         DPF_ERROR("Invalid samples per block");

  0019a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  0019f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
  001a4	68 cf 01 00 00	 push	 463			; 000001cfH
  001a9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  001ae	6a 01		 push	 1
  001b0	6a 09		 push	 9
  001b2	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  001b7	83 c4 18	 add	 esp, 24			; 00000018H
  001ba	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@GLJN@Invalid?5samples?5per?5block?$AA@ ; `string'
  001bf	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001c4	83 c4 04	 add	 esp, 4

; 464  :         fValid = FALSE;

  001c7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L52899:

; 465  :     }
; 466  : 
; 467  :     if(wBytesPerBlock * pwfx->wfx.nChannels != pwfx->wfx.nBlockAlign)

  001ce	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  001d1	33 c9		 xor	 ecx, ecx
  001d3	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  001d7	6b c9 24	 imul	 ecx, 36			; 00000024H
  001da	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  001dd	33 c0		 xor	 eax, eax
  001df	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  001e3	3b c8		 cmp	 ecx, eax
  001e5	74 34		 je	 SHORT $L52901

; 468  :     {
; 469  :         DPF_ERROR("Bad block-alignment");

  001e7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  001ec	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
  001f1	68 d5 01 00 00	 push	 469			; 000001d5H
  001f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  001fb	6a 01		 push	 1
  001fd	6a 09		 push	 9
  001ff	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00204	83 c4 18	 add	 esp, 24			; 00000018H
  00207	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OJBC@Bad?5block?9alignment?$AA@ ; `string'
  0020c	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00211	83 c4 04	 add	 esp, 4

; 470  :         fValid = FALSE;

  00214	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L52901:

; 471  :     }
; 472  : 
; 473  :     DPF_LEAVE(fValid);
; 474  : 
; 475  :     return fValid;

  0021b	8b 45 fc	 mov	 eax, DWORD PTR _fValid$[ebp]

; 476  : }

  0021e	8b e5		 mov	 esp, ebp
  00220	5d		 pop	 ebp
  00221	c2 04 00	 ret	 4
?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::WaveFormat::IsValidAdpcmFormat
_TEXT	ENDS
PUBLIC	??0CStdFileStream@WaveLoader@@QAE@XZ		; WaveLoader::CStdFileStream::CStdFileStream
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\waveldr.cpp
;	COMDAT ??0CStdFileStream@WaveLoader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CStdFileStream@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CStdFileStream::CStdFileStream, COMDAT
; _this$ = ecx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 102  :     DPF_ENTER();
; 103  : 
; 104  :     //
; 105  :     // Initialize defaults
; 106  :     //
; 107  : 
; 108  :     m_hFile = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 109  :     m_dwFlags = 0;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 110  : 
; 111  :     DPF_LEAVE_VOID();
; 112  : }

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0CStdFileStream@WaveLoader@@QAE@XZ ENDP		; WaveLoader::CStdFileStream::CStdFileStream
_TEXT	ENDS
PUBLIC	??1CStdFileStream@WaveLoader@@QAE@XZ		; WaveLoader::CStdFileStream::~CStdFileStream
PUBLIC	?Close@CStdFileStream@WaveLoader@@QAEXXZ	; WaveLoader::CStdFileStream::Close
; Function compile flags: /Odt
;	COMDAT ??1CStdFileStream@WaveLoader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CStdFileStream@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CStdFileStream::~CStdFileStream, COMDAT
; _this$ = ecx

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 138  :     DPF_ENTER();
; 139  : 
; 140  :     Close();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Close@CStdFileStream@WaveLoader@@QAEXXZ ; WaveLoader::CStdFileStream::Close

; 141  : 
; 142  :     DPF_LEAVE_VOID();
; 143  : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CStdFileStream@WaveLoader@@QAE@XZ ENDP		; WaveLoader::CStdFileStream::~CStdFileStream
_TEXT	ENDS
PUBLIC	??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CA@LGGN@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BF@EAAG@CStdFileStream?3?3Open?$AA@	; `string'
PUBLIC	??_C@_0CF@CAJD@Error?5?$CFlu?5occurred?5trying?5to?5ope@ ; `string'
PUBLIC	?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z	; WaveLoader::CStdFileStream::Open
EXTRN	__imp__CreateFileA@28:NEAR
EXTRN	__imp__GetLastError@0:NEAR
;	COMDAT ??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\privat'
	DB	'e\windows\directx\dsound\common\waveldr.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LGGN@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
CONST	SEGMENT
??_C@_0CA@LGGN@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ DB '!IS_VALI'
	DB	'D_HANDLE_VALUE(m_hFile)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EAAG@CStdFileStream?3?3Open?$AA@
CONST	SEGMENT
??_C@_0BF@EAAG@CStdFileStream?3?3Open?$AA@ DB 'CStdFileStream::Open', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CAJD@Error?5?$CFlu?5occurred?5trying?5to?5ope@
CONST	SEGMENT
??_C@_0CF@CAJD@Error?5?$CFlu?5occurred?5trying?5to?5ope@ DB 'Error %lu oc'
	DB	'curred trying to open %s', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z
_TEXT	SEGMENT
_pszFileName$ = 8
_dwDesiredAccess$ = 12
_dwShareMode$ = 16
_dwCreationDisposition$ = 20
_dwFlagsAndAttributes$ = 24
_this$ = -8
_hr$ = -4
?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z PROC NEAR ; WaveLoader::CStdFileStream::Open, COMDAT
; _this$ = ecx

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 178  :     HRESULT                 hr  = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 179  : 
; 180  :     DPF_ENTER();
; 181  : 
; 182  :     ASSERT(!IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L54088
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L54088
  00020	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
  00027	eb 07		 jmp	 SHORT $L54089
$L54088:
  00029	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L54089:
  00030	68 b6 00 00 00	 push	 182			; 000000b6H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@LGGN@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
  0003f	8b 55 f4	 mov	 edx, DWORD PTR -12+[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 183  :     
; 184  :     m_hFile = CreateFile(pszFileName, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);

  0004b	6a 00		 push	 0
  0004d	8b 45 18	 mov	 eax, DWORD PTR _dwFlagsAndAttributes$[ebp]
  00050	50		 push	 eax
  00051	8b 4d 14	 mov	 ecx, DWORD PTR _dwCreationDisposition$[ebp]
  00054	51		 push	 ecx
  00055	6a 00		 push	 0
  00057	8b 55 10	 mov	 edx, DWORD PTR _dwShareMode$[ebp]
  0005a	52		 push	 edx
  0005b	8b 45 0c	 mov	 eax, DWORD PTR _dwDesiredAccess$[ebp]
  0005e	50		 push	 eax
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _pszFileName$[ebp]
  00062	51		 push	 ecx
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00069	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	89 02		 mov	 DWORD PTR [edx], eax

; 185  : 
; 186  :     if(INVALID_HANDLE_VALUE == m_hFile)

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00071	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00074	75 09		 jne	 SHORT $L52932

; 187  :     {
; 188  :         m_hFile = NULL;

  00076	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L52932:

; 189  :     }
; 190  : 
; 191  :     if(!m_hFile)

  0007f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00082	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00085	75 3f		 jne	 SHORT $L52933

; 192  :     {
; 193  :         DPF_ERROR("Error %lu occurred trying to open %s", GetLastError(), pszFileName);

  00087	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  0008c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@EAAG@CStdFileStream?3?3Open?$AA@ ; `string'
  00091	68 c1 00 00 00	 push	 193			; 000000c1H
  00096	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0009b	6a 04		 push	 4
  0009d	6a 09		 push	 9
  0009f	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000a4	83 c4 18	 add	 esp, 24			; 00000018H
  000a7	8b 45 08	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  000aa	50		 push	 eax
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000b1	50		 push	 eax
  000b2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@CAJD@Error?5?$CFlu?5occurred?5trying?5to?5ope@ ; `string'
  000b7	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 194  :         hr = E_FAIL;

  000bf	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L52933:

; 195  :     }
; 196  : 
; 197  :     DPF_LEAVE_HRESULT(hr);
; 198  : 
; 199  :     return hr;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 200  : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 14 00	 ret	 20			; 00000014H
?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z ENDP	; WaveLoader::CStdFileStream::Open
_TEXT	ENDS
PUBLIC	?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z	; WaveLoader::CStdFileStream::Attach
; Function compile flags: /Odt
;	COMDAT ?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z
_TEXT	SEGMENT
_hFile$ = 8
_this$ = -4
?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z PROC NEAR	; WaveLoader::CStdFileStream::Attach, COMDAT
; _this$ = ecx

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 227  :     DPF_ENTER();
; 228  : 
; 229  :     ASSERT(!IS_VALID_HANDLE_VALUE(m_hFile));

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 11		 je	 SHORT $L54093
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  00017	74 09		 je	 SHORT $L54093
  00019	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00020	eb 07		 jmp	 SHORT $L54094
$L54093:
  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L54094:
  00029	68 e5 00 00 00	 push	 229			; 000000e5H
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@LGGN@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
  00038	8b 55 f8	 mov	 edx, DWORD PTR -8+[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00041	83 c4 10	 add	 esp, 16			; 00000010H

; 230  :     
; 231  :     m_hFile = hFile;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _hFile$[ebp]
  0004a	89 08		 mov	 DWORD PTR [eax], ecx

; 232  :     m_dwFlags |= FILESTREAM_FLAGS_ATTACHED;

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00052	0c 01		 or	 al, 1
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 233  : 
; 234  :     DPF_LEAVE_VOID();
; 235  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z ENDP	; WaveLoader::CStdFileStream::Attach
_TEXT	ENDS
EXTRN	__imp__CloseHandle@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Close@CStdFileStream@WaveLoader@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Close@CStdFileStream@WaveLoader@@QAEXXZ PROC NEAR	; WaveLoader::CStdFileStream::Close, COMDAT
; _this$ = ecx

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 262  :     DPF_ENTER();
; 263  :     
; 264  :     if(m_dwFlags & FILESTREAM_FLAGS_ATTACHED)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	83 e1 01	 and	 ecx, 1
  00010	85 c9		 test	 ecx, ecx
  00012	74 1a		 je	 SHORT $L52946

; 265  :     {
; 266  :         m_hFile = NULL;

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 267  :         m_dwFlags &= ~FILESTREAM_FLAGS_ATTACHED;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00023	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 268  :     }
; 269  :     else

  0002c	eb 25		 jmp	 SHORT $L52947
$L52946:

; 270  :     {
; 271  :         CLOSE_HANDLE(m_hFile);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 38 00	 cmp	 DWORD PTR [eax], 0
  00034	74 1d		 je	 SHORT $L52949
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0003c	74 15		 je	 SHORT $L52949
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 02		 mov	 eax, DWORD PTR [edx]
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L52949:
$L52947:

; 272  :     }
; 273  : 
; 274  :     DPF_LEAVE_VOID();
; 275  : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?Close@CStdFileStream@WaveLoader@@QAEXXZ ENDP		; WaveLoader::CStdFileStream::Close
_TEXT	ENDS
PUBLIC	??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BF@OPLH@CStdFileStream?3?3Read?$AA@	; `string'
PUBLIC	??_C@_0CJ@DHDM@Error?5?$CFlu?5occurred?5reading?5from?5@ ; `string'
PUBLIC	??_C@_0CH@ONHL@Not?5enough?5data?5was?5read?5from?5th@ ; `string'
PUBLIC	?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z	; WaveLoader::CStdFileStream::Read
EXTRN	__imp__ReadFile@20:NEAR
;	COMDAT ??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ DB 'IS_VALID_HAN'
	DB	'DLE_VALUE(m_hFile)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OPLH@CStdFileStream?3?3Read?$AA@
CONST	SEGMENT
??_C@_0BF@OPLH@CStdFileStream?3?3Read?$AA@ DB 'CStdFileStream::Read', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DHDM@Error?5?$CFlu?5occurred?5reading?5from?5@
CONST	SEGMENT
??_C@_0CJ@DHDM@Error?5?$CFlu?5occurred?5reading?5from?5@ DB 'Error %lu oc'
	DB	'curred reading from the file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@ONHL@Not?5enough?5data?5was?5read?5from?5th@
CONST	SEGMENT
??_C@_0CH@ONHL@Not?5enough?5data?5was?5read?5from?5th@ DB 'Not enough dat'
	DB	'a was read from the file', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
_dwBufferSize$ = 12
_pdwRead$ = 16
_this$ = -12
_hr$ = -8
_dwRead$ = -4
?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z PROC NEAR ; WaveLoader::CStdFileStream::Read, COMDAT
; _this$ = ecx

; 305  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 306  :     HRESULT                 hr      = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 307  :     DWORD                   dwRead;
; 308  : 
; 309  :     DPF_ENTER();
; 310  :     
; 311  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L54101
  00018	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L54101
  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], 0
  00027	eb 07		 jmp	 SHORT $L54102
$L54101:
  00029	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR -16+[ebp], 1
$L54102:
  00030	68 37 01 00 00	 push	 311			; 00000137H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
  0003f	8b 55 f0	 mov	 edx, DWORD PTR -16+[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 312  :     
; 313  :     if(!ReadFile(m_hFile, pvBuffer, dwBufferSize, &dwRead, NULL))

  0004b	6a 00		 push	 0
  0004d	8d 45 fc	 lea	 eax, DWORD PTR _dwRead$[ebp]
  00050	50		 push	 eax
  00051	8b 4d 0c	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00058	52		 push	 edx
  00059	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	51		 push	 ecx
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  00065	85 c0		 test	 eax, eax
  00067	75 3b		 jne	 SHORT $L52961

; 314  :     {
; 315  :         DPF_ERROR("Error %lu occurred reading from the file", GetLastError());

  00069	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@OPLH@CStdFileStream?3?3Read?$AA@ ; `string'
  00073	68 3b 01 00 00	 push	 315			; 0000013bH
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0007d	6a 04		 push	 4
  0007f	6a 09		 push	 9
  00081	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00086	83 c4 18	 add	 esp, 24			; 00000018H
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0008f	50		 push	 eax
  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@DHDM@Error?5?$CFlu?5occurred?5reading?5from?5@ ; `string'
  00095	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0009a	83 c4 08	 add	 esp, 8

; 316  :         hr = E_FAIL;

  0009d	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L52961:

; 317  :     }
; 318  : 
; 319  :     if(SUCCEEDED(hr))

  000a4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a8	7c 4c		 jl	 SHORT $L52966

; 320  :     {
; 321  :         if(pdwRead)

  000aa	83 7d 10 00	 cmp	 DWORD PTR _pdwRead$[ebp], 0
  000ae	74 0a		 je	 SHORT $L52967

; 322  :         {
; 323  :             *pdwRead = dwRead;

  000b0	8b 55 10	 mov	 edx, DWORD PTR _pdwRead$[ebp]
  000b3	8b 45 fc	 mov	 eax, DWORD PTR _dwRead$[ebp]
  000b6	89 02		 mov	 DWORD PTR [edx], eax

; 324  :         }
; 325  :         else if(dwRead != dwBufferSize)

  000b8	eb 3c		 jmp	 SHORT $L52968
$L52967:
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _dwRead$[ebp]
  000bd	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwBufferSize$[ebp]
  000c0	74 34		 je	 SHORT $L52969

; 326  :         {
; 327  :             DPF_ERROR("Not enough data was read from the file");

  000c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@OPLH@CStdFileStream?3?3Read?$AA@ ; `string'
  000cc	68 47 01 00 00	 push	 327			; 00000147H
  000d1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000d6	6a 04		 push	 4
  000d8	6a 09		 push	 9
  000da	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000df	83 c4 18	 add	 esp, 24			; 00000018H
  000e2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@ONHL@Not?5enough?5data?5was?5read?5from?5th@ ; `string'
  000e7	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000ec	83 c4 04	 add	 esp, 4

; 328  :             hr = E_FAIL;

  000ef	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L52969:
$L52968:
$L52966:

; 329  :         }
; 330  :     }
; 331  : 
; 332  :     DPF_LEAVE_HRESULT(hr);
; 333  : 
; 334  :     return hr;

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 335  : }

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 0c 00	 ret	 12			; 0000000cH
?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z ENDP	; WaveLoader::CStdFileStream::Read
_TEXT	ENDS
PUBLIC	??_C@_0BG@LBDH@CStdFileStream?3?3Write?$AA@	; `string'
PUBLIC	??_C@_0CH@MCKM@Error?5?$CFlu?5occurred?5writing?5to?5th@ ; `string'
PUBLIC	??_C@_0CK@MMCK@Not?5enough?5data?5was?5written?5from@ ; `string'
PUBLIC	?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z	; WaveLoader::CStdFileStream::Write
EXTRN	__imp__WriteFile@20:NEAR
;	COMDAT ??_C@_0BG@LBDH@CStdFileStream?3?3Write?$AA@
CONST	SEGMENT
??_C@_0BG@LBDH@CStdFileStream?3?3Write?$AA@ DB 'CStdFileStream::Write', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MCKM@Error?5?$CFlu?5occurred?5writing?5to?5th@
CONST	SEGMENT
??_C@_0CH@MCKM@Error?5?$CFlu?5occurred?5writing?5to?5th@ DB 'Error %lu oc'
	DB	'curred writing to the file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MMCK@Not?5enough?5data?5was?5written?5from@
CONST	SEGMENT
??_C@_0CK@MMCK@Not?5enough?5data?5was?5written?5from@ DB 'Not enough data'
	DB	' was written from the file', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
_dwBufferSize$ = 12
_pdwWritten$ = 16
_this$ = -12
_hr$ = -8
_dwWritten$ = -4
?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z PROC NEAR ; WaveLoader::CStdFileStream::Write, COMDAT
; _this$ = ecx

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 366  :     HRESULT                 hr          = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 367  :     DWORD                   dwWritten;
; 368  : 
; 369  :     DPF_ENTER();
; 370  :     
; 371  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L54106
  00018	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L54106
  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], 0
  00027	eb 07		 jmp	 SHORT $L54107
$L54106:
  00029	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR -16+[ebp], 1
$L54107:
  00030	68 73 01 00 00	 push	 371			; 00000173H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
  0003f	8b 55 f0	 mov	 edx, DWORD PTR -16+[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 372  :     
; 373  :     if(!WriteFile(m_hFile, pvBuffer, dwBufferSize, &dwWritten, NULL))

  0004b	6a 00		 push	 0
  0004d	8d 45 fc	 lea	 eax, DWORD PTR _dwWritten$[ebp]
  00050	50		 push	 eax
  00051	8b 4d 0c	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00058	52		 push	 edx
  00059	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	51		 push	 ecx
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00065	85 c0		 test	 eax, eax
  00067	75 3b		 jne	 SHORT $L52982

; 374  :     {
; 375  :         DPF_ERROR("Error %lu occurred writing to the file", GetLastError());

  00069	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@LBDH@CStdFileStream?3?3Write?$AA@ ; `string'
  00073	68 77 01 00 00	 push	 375			; 00000177H
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0007d	6a 04		 push	 4
  0007f	6a 09		 push	 9
  00081	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00086	83 c4 18	 add	 esp, 24			; 00000018H
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0008f	50		 push	 eax
  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@MCKM@Error?5?$CFlu?5occurred?5writing?5to?5th@ ; `string'
  00095	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0009a	83 c4 08	 add	 esp, 8

; 376  :         hr = E_FAIL;

  0009d	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L52982:

; 377  :     }
; 378  : 
; 379  :     if(SUCCEEDED(hr))

  000a4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a8	7c 4c		 jl	 SHORT $L52987

; 380  :     {
; 381  :         if(pdwWritten)

  000aa	83 7d 10 00	 cmp	 DWORD PTR _pdwWritten$[ebp], 0
  000ae	74 0a		 je	 SHORT $L52988

; 382  :         {
; 383  :             *pdwWritten = dwWritten;

  000b0	8b 55 10	 mov	 edx, DWORD PTR _pdwWritten$[ebp]
  000b3	8b 45 fc	 mov	 eax, DWORD PTR _dwWritten$[ebp]
  000b6	89 02		 mov	 DWORD PTR [edx], eax

; 384  :         }
; 385  :         else if(dwWritten != dwBufferSize)

  000b8	eb 3c		 jmp	 SHORT $L52989
$L52988:
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _dwWritten$[ebp]
  000bd	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwBufferSize$[ebp]
  000c0	74 34		 je	 SHORT $L52990

; 386  :         {
; 387  :             DPF_ERROR("Not enough data was written from the file");

  000c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@LBDH@CStdFileStream?3?3Write?$AA@ ; `string'
  000cc	68 83 01 00 00	 push	 387			; 00000183H
  000d1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000d6	6a 04		 push	 4
  000d8	6a 09		 push	 9
  000da	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000df	83 c4 18	 add	 esp, 24			; 00000018H
  000e2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@MMCK@Not?5enough?5data?5was?5written?5from@ ; `string'
  000e7	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000ec	83 c4 04	 add	 esp, 4

; 388  :             hr = E_FAIL;

  000ef	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L52990:
$L52989:
$L52987:

; 389  :         }
; 390  :     }
; 391  : 
; 392  :     DPF_LEAVE_HRESULT(hr);
; 393  : 
; 394  :     return hr;

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 395  : }

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 0c 00	 ret	 12			; 0000000cH
?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z ENDP	; WaveLoader::CStdFileStream::Write
_TEXT	ENDS
PUBLIC	??_C@_0BF@JBBC@CStdFileStream?3?3Seek?$AA@	; `string'
PUBLIC	??_C@_0CE@PFDI@Error?5?$CFlu?5occurred?5seeking?5the?5f@ ; `string'
PUBLIC	?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z	; WaveLoader::CStdFileStream::Seek
EXTRN	__imp__SetFilePointer@16:NEAR
;	COMDAT ??_C@_0BF@JBBC@CStdFileStream?3?3Seek?$AA@
CONST	SEGMENT
??_C@_0BF@JBBC@CStdFileStream?3?3Seek?$AA@ DB 'CStdFileStream::Seek', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PFDI@Error?5?$CFlu?5occurred?5seeking?5the?5f@
CONST	SEGMENT
??_C@_0CE@PFDI@Error?5?$CFlu?5occurred?5seeking?5the?5f@ DB 'Error %lu oc'
	DB	'curred seeking the file', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z
_TEXT	SEGMENT
_lOffset$ = 8
_dwOrigin$ = 12
_pdwAbsolute$ = 16
_this$ = -12
_hr$ = -8
_dwAbsolute$ = -4
?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z PROC NEAR	; WaveLoader::CStdFileStream::Seek, COMDAT
; _this$ = ecx

; 425  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 426  :     HRESULT                 hr          = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 427  :     DWORD                   dwAbsolute;
; 428  :     
; 429  :     DPF_ENTER();
; 430  : 
; 431  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L54111
  00018	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L54111
  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], 0
  00027	eb 07		 jmp	 SHORT $L54112
$L54111:
  00029	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR -16+[ebp], 1
$L54112:
  00030	68 af 01 00 00	 push	 431			; 000001afH
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
  0003f	8b 55 f0	 mov	 edx, DWORD PTR -16+[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 432  :     
; 433  :     if((dwAbsolute = SetFilePointer(m_hFile, lOffset, NULL, dwOrigin)) == INVALID_SET_FILE_POINTER)

  0004b	8b 45 0c	 mov	 eax, DWORD PTR _dwOrigin$[ebp]
  0004e	50		 push	 eax
  0004f	6a 00		 push	 0
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _lOffset$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00058	8b 02		 mov	 eax, DWORD PTR [edx]
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16
  00061	89 45 fc	 mov	 DWORD PTR _dwAbsolute$[ebp], eax
  00064	83 7d fc ff	 cmp	 DWORD PTR _dwAbsolute$[ebp], -1
  00068	75 3b		 jne	 SHORT $L53004

; 434  :     {
; 435  :         DPF_ERROR("Error %lu occurred seeking the file", GetLastError());

  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  0006f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@JBBC@CStdFileStream?3?3Seek?$AA@ ; `string'
  00074	68 b3 01 00 00	 push	 435			; 000001b3H
  00079	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0007e	6a 04		 push	 4
  00080	6a 09		 push	 9
  00082	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00087	83 c4 18	 add	 esp, 24			; 00000018H
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00090	50		 push	 eax
  00091	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@PFDI@Error?5?$CFlu?5occurred?5seeking?5the?5f@ ; `string'
  00096	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0009b	83 c4 08	 add	 esp, 8

; 436  :         hr = E_FAIL;

  0009e	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L53004:

; 437  :     }
; 438  : 
; 439  :     if(SUCCEEDED(hr) && pdwAbsolute)

  000a5	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a9	7c 0e		 jl	 SHORT $L53009
  000ab	83 7d 10 00	 cmp	 DWORD PTR _pdwAbsolute$[ebp], 0
  000af	74 08		 je	 SHORT $L53009

; 440  :     {
; 441  :         *pdwAbsolute = dwAbsolute;

  000b1	8b 4d 10	 mov	 ecx, DWORD PTR _pdwAbsolute$[ebp]
  000b4	8b 55 fc	 mov	 edx, DWORD PTR _dwAbsolute$[ebp]
  000b7	89 11		 mov	 DWORD PTR [ecx], edx
$L53009:

; 442  :     }
; 443  : 
; 444  :     DPF_LEAVE_HRESULT(hr);
; 445  : 
; 446  :     return hr;

  000b9	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 447  : }

  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 0c 00	 ret	 12			; 0000000cH
?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z ENDP	; WaveLoader::CStdFileStream::Seek
_TEXT	ENDS
PUBLIC	??_C@_0BK@LINH@CStdFileStream?3?3GetLength?$AA@	; `string'
PUBLIC	??_C@_0CK@CIMA@Error?5?$CFlu?5attempting?5to?5get?5the?5@ ; `string'
PUBLIC	?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z	; WaveLoader::CStdFileStream::GetLength
EXTRN	__imp__GetFileSize@8:NEAR
;	COMDAT ??_C@_0BK@LINH@CStdFileStream?3?3GetLength?$AA@
CONST	SEGMENT
??_C@_0BK@LINH@CStdFileStream?3?3GetLength?$AA@ DB 'CStdFileStream::GetLe'
	DB	'ngth', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CIMA@Error?5?$CFlu?5attempting?5to?5get?5the?5@
CONST	SEGMENT
??_C@_0CK@CIMA@Error?5?$CFlu?5attempting?5to?5get?5the?5@ DB 'Error %lu a'
	DB	'ttempting to get the file size', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z
_TEXT	SEGMENT
_pdwLength$ = 8
_this$ = -8
_hr$ = -4
?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z PROC NEAR ; WaveLoader::CStdFileStream::GetLength, COMDAT
; _this$ = ecx

; 473  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 474  :     HRESULT                 hr  = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 475  :     
; 476  :     DPF_ENTER();
; 477  : 
; 478  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L54116
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L54116
  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
  00027	eb 07		 jmp	 SHORT $L54117
$L54116:
  00029	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
$L54117:
  00030	68 de 01 00 00	 push	 478			; 000001deH
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
  0003f	8b 55 f4	 mov	 edx, DWORD PTR -12+[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 479  :     
; 480  :     if((*pdwLength = GetFileSize(m_hFile, NULL)) == -1)

  0004b	6a 00		 push	 0
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	51		 push	 ecx
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSize@8
  00059	8b 55 08	 mov	 edx, DWORD PTR _pdwLength$[ebp]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 45 08	 mov	 eax, DWORD PTR _pdwLength$[ebp]
  00061	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00064	75 3b		 jne	 SHORT $L53017

; 481  :     {
; 482  :         DPF_ERROR("Error %lu attempting to get the file size", GetLastError());

  00066	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  0006b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@LINH@CStdFileStream?3?3GetLength?$AA@ ; `string'
  00070	68 e2 01 00 00	 push	 482			; 000001e2H
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0007a	6a 04		 push	 4
  0007c	6a 09		 push	 9
  0007e	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00083	83 c4 18	 add	 esp, 24			; 00000018H
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0008c	50		 push	 eax
  0008d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@CIMA@Error?5?$CFlu?5attempting?5to?5get?5the?5@ ; `string'
  00092	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00097	83 c4 08	 add	 esp, 8

; 483  :         hr = E_FAIL;

  0009a	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L53017:

; 484  :     }
; 485  : 
; 486  :     DPF_LEAVE_HRESULT(hr);
; 487  : 
; 488  :     return hr;

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 489  : }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z ENDP	; WaveLoader::CStdFileStream::GetLength
_TEXT	ENDS
PUBLIC	??0CRiffChunk@WaveLoader@@QAE@XZ		; WaveLoader::CRiffChunk::CRiffChunk
; Function compile flags: /Odt
;	COMDAT ??0CRiffChunk@WaveLoader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CRiffChunk@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CRiffChunk::CRiffChunk, COMDAT
; _this$ = ecx

; 514  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 515  :     DPF_ENTER();
; 516  : 
; 517  :     //
; 518  :     // Initialize defaults
; 519  :     //
; 520  : 
; 521  :     m_pParentChunk = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 522  :     m_pStream = NULL;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 523  :     m_dwChunkId = 0;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 524  :     m_dwDataOffset = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 525  :     m_dwDataSize = 0;

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 526  :     m_dwFlags = 0;

  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 527  : 
; 528  :     DPF_LEAVE_VOID();
; 529  : }

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??0CRiffChunk@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CRiffChunk::CRiffChunk
_TEXT	ENDS
PUBLIC	??1CRiffChunk@WaveLoader@@QAE@XZ		; WaveLoader::CRiffChunk::~CRiffChunk
; Function compile flags: /Odt
;	COMDAT ??1CRiffChunk@WaveLoader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CRiffChunk@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CRiffChunk::~CRiffChunk, COMDAT
; _this$ = ecx

; 554  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  :     DPF_ENTER();
; 556  :     DPF_LEAVE_VOID();
; 557  : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1CRiffChunk@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CRiffChunk::~CRiffChunk
_TEXT	ENDS
PUBLIC	?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
; Function compile flags: /Odt
;	COMDAT ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z
_TEXT	SEGMENT
_pParentChunk$ = 8
_pStream$ = 12
_dwChunkId$ = 16
_this$ = -20
_lOffset$ = -4
_rhRiffHeader$ = -16
_hr$ = -8
?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z PROC NEAR ; WaveLoader::CRiffChunk::Open, COMDAT
; _this$ = ecx

; 587  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 588  :     LONG                    lOffset;
; 589  :     RIFFHEADER              rhRiffHeader;
; 590  :     HRESULT                 hr;
; 591  : 
; 592  :     DPF_ENTER();
; 593  :     
; 594  :     m_pParentChunk = pParentChunk;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pParentChunk$[ebp]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx

; 595  :     m_pStream = pStream;

  00011	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  00017	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 596  : 
; 597  :     //
; 598  :     // Seek to the first byte of the parent chunk's data section
; 599  :     //
; 600  : 
; 601  :     if(m_pParentChunk)

  0001a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00020	74 32		 je	 SHORT $L53038

; 602  :     {
; 603  :         lOffset = m_pParentChunk->m_dwDataOffset;

  00022	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002a	89 4d fc	 mov	 DWORD PTR _lOffset$[ebp], ecx

; 604  : 
; 605  :         //
; 606  :         // Special case the RIFF chunk
; 607  :         //
; 608  : 
; 609  :         if((WAVELDR_FOURCC_RIFF == m_pParentChunk->m_dwChunkId) || (WAVELDR_FOURCC_FORM == m_pParentChunk->m_dwChunkId))

  0002d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	81 78 08 52 49
	46 46		 cmp	 DWORD PTR [eax+8], 1179011410 ; 46464952H
  00039	74 0e		 je	 SHORT $L53040
  0003b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	81 7a 08 46 4f
	52 4d		 cmp	 DWORD PTR [edx+8], 1297239878 ; 4d524f46H
  00047	75 09		 jne	 SHORT $L53039
$L53040:

; 610  :         {
; 611  :             lOffset += sizeof(DWORD);

  00049	8b 45 fc	 mov	 eax, DWORD PTR _lOffset$[ebp]
  0004c	83 c0 04	 add	 eax, 4
  0004f	89 45 fc	 mov	 DWORD PTR _lOffset$[ebp], eax
$L53039:

; 612  :         }
; 613  :     }
; 614  :     else

  00052	eb 07		 jmp	 SHORT $L53042
$L53038:

; 615  :     {
; 616  :         lOffset = 0;

  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lOffset$[ebp], 0
$L53042:
$L53043:

; 617  :     }
; 618  : 
; 619  :     //
; 620  :     // If this is the top level chunk, just read the first 8 bytes.  If not,
; 621  :     // search the parent chunk until we find the one we're looking for.
; 622  :     //
; 623  : 
; 624  :     do
; 625  :     {
; 626  :         hr = m_pStream->Seek(lOffset, FILE_BEGIN, NULL);

  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _lOffset$[ebp]
  00062	51		 push	 ecx
  00063	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00069	e8 00 00 00 00	 call	 ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z ; WaveLoader::CStdFileStream::Seek
  0006e	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 627  : 
; 628  :         if(SUCCEEDED(hr))

  00071	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00075	7c 16		 jl	 SHORT $L53047

; 629  :         {
; 630  :             hr = m_pStream->Read(&rhRiffHeader, sizeof(rhRiffHeader), NULL);

  00077	6a 00		 push	 0
  00079	6a 08		 push	 8
  0007b	8d 45 f0	 lea	 eax, DWORD PTR _rhRiffHeader$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00085	e8 00 00 00 00	 call	 ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z ; WaveLoader::CStdFileStream::Read
  0008a	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L53047:

; 631  :         }
; 632  : 
; 633  :         if(SUCCEEDED(hr) && m_pParentChunk)

  0008d	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00091	7c 21		 jl	 SHORT $L53049
  00093	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00096	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00099	74 19		 je	 SHORT $L53049

; 634  :         {
; 635  :             if(WAVELDR_FOURCC_FORM == m_pParentChunk->m_dwChunkId)

  0009b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	81 79 08 46 4f
	52 4d		 cmp	 DWORD PTR [ecx+8], 1297239878 ; 4d524f46H
  000a7	75 0b		 jne	 SHORT $L53050

; 636  :             {
; 637  :                 rhRiffHeader.dwDataSize = EndianSwapDword(rhRiffHeader.dwDataSize);

  000a9	8b 4d f4	 mov	 ecx, DWORD PTR _rhRiffHeader$[ebp+4]
  000ac	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  000b1	89 45 f4	 mov	 DWORD PTR _rhRiffHeader$[ebp+4], eax
$L53050:
$L53049:

; 638  :             }
; 639  :         }
; 640  : 
; 641  :         if(SUCCEEDED(hr) && (dwChunkId == rhRiffHeader.dwChunkId))

  000b4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b8	7c 0a		 jl	 SHORT $L53052
  000ba	8b 55 10	 mov	 edx, DWORD PTR _dwChunkId$[ebp]
  000bd	3b 55 f0	 cmp	 edx, DWORD PTR _rhRiffHeader$[ebp]
  000c0	75 02		 jne	 SHORT $L53052

; 642  :         {
; 643  :             break;

  000c2	eb 32		 jmp	 SHORT $L53045
$L53052:

; 644  :         }
; 645  : 
; 646  :         if(SUCCEEDED(hr) && !m_pParentChunk)

  000c4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000c8	7c 0f		 jl	 SHORT $L53054
  000ca	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	83 38 00	 cmp	 DWORD PTR [eax], 0
  000d0	75 07		 jne	 SHORT $L53054

; 647  :         {
; 648  :             hr = E_FAIL;

  000d2	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L53054:

; 649  :         }
; 650  : 
; 651  :         if(SUCCEEDED(hr))

  000d9	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000dd	7c 0d		 jl	 SHORT $L53057

; 652  :         {
; 653  :             lOffset += sizeof(rhRiffHeader) + rhRiffHeader.dwDataSize;

  000df	8b 4d f4	 mov	 ecx, DWORD PTR _rhRiffHeader$[ebp+4]
  000e2	8b 55 fc	 mov	 edx, DWORD PTR _lOffset$[ebp]
  000e5	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  000e9	89 45 fc	 mov	 DWORD PTR _lOffset$[ebp], eax
$L53057:

; 654  :         }
; 655  :     }
; 656  :     while(SUCCEEDED(hr));

  000ec	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000f0	0f 8d 65 ff ff
	ff		 jge	 $L53043
$L53045:

; 657  : 
; 658  :     //
; 659  :     // Success
; 660  :     //
; 661  : 
; 662  :     if(SUCCEEDED(hr))

  000f6	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000fa	7c 2d		 jl	 SHORT $L53060

; 663  :     {
; 664  :         m_dwChunkId = dwChunkId;

  000fc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	8b 55 10	 mov	 edx, DWORD PTR _dwChunkId$[ebp]
  00102	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 665  :         m_dwDataOffset = lOffset + sizeof(rhRiffHeader);

  00105	8b 45 fc	 mov	 eax, DWORD PTR _lOffset$[ebp]
  00108	83 c0 08	 add	 eax, 8
  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 666  :         m_dwDataSize = rhRiffHeader.dwDataSize;

  00111	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00114	8b 45 f4	 mov	 eax, DWORD PTR _rhRiffHeader$[ebp+4]
  00117	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 667  :         m_dwFlags |= RIFFCHUNK_FLAGS_VALID;

  0011a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00120	83 ca 01	 or	 edx, 1
  00123	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00126	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L53060:

; 668  :     }
; 669  : 
; 670  :     DPF_LEAVE_HRESULT(hr);
; 671  : 
; 672  :     return hr;

  00129	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 673  : }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 0c 00	 ret	 12			; 0000000cH
?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ENDP ; WaveLoader::CRiffChunk::Open
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?EndianSwapDword@@YIKK@Z
_TEXT	SEGMENT
_n$ = -4
?EndianSwapDword@@YIKK@Z PROC NEAR			; EndianSwapDword, COMDAT
; _n$ = ecx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx

; 55   :     __asm
; 56   :     {
; 57   :         mov     eax, ecx

  00008	8b c1		 mov	 eax, ecx

; 58   :         sar     eax, 24

  0000a	c1 f8 18	 sar	 eax, 24			; 00000018H

; 59   :         and     eax, 0ffh

  0000d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 60   : 
; 61   :         mov     ebx, ecx

  00012	8b d9		 mov	 ebx, ecx

; 62   :         sar     ebx, 8

  00014	c1 fb 08	 sar	 ebx, 8

; 63   :         and     ebx, 0ff00h

  00017	81 e3 00 ff 00
	00		 and	 ebx, 65280		; 0000ff00H

; 64   :         or      eax, ebx

  0001d	0b c3		 or	 eax, ebx

; 65   : 
; 66   :         mov     ebx, ecx

  0001f	8b d9		 mov	 ebx, ecx

; 67   :         shl     ebx, 8

  00021	c1 e3 08	 shl	 ebx, 8

; 68   :         and     ebx, 0ff0000h

  00024	81 e3 00 00 ff
	00		 and	 ebx, 16711680		; 00ff0000H

; 69   :         or      eax, ebx

  0002a	0b c3		 or	 eax, ebx

; 70   : 
; 71   :         mov     ebx, ecx

  0002c	8b d9		 mov	 ebx, ecx

; 72   :         shl     ebx, 24

  0002e	c1 e3 18	 shl	 ebx, 24			; 00000018H

; 73   :         and     ebx, 0ff000000h

  00031	81 e3 00 00 00
	ff		 and	 ebx, -16777216		; ff000000H

; 74   :         or      eax, ebx

  00037	0b c3		 or	 eax, ebx

; 75   :     }
; 76   : }

  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?EndianSwapDword@@YIKK@Z ENDP				; EndianSwapDword
_TEXT	ENDS
PUBLIC	??_C@_0BB@EPJI@CRiffChunk?3?3Read?$AA@		; `string'
PUBLIC	??_C@_0CM@LIHM@Attempted?5to?5read?5past?5the?5end?5o@ ; `string'
PUBLIC	?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z	; WaveLoader::CRiffChunk::Read
;	COMDAT ??_C@_0BB@EPJI@CRiffChunk?3?3Read?$AA@
CONST	SEGMENT
??_C@_0BB@EPJI@CRiffChunk?3?3Read?$AA@ DB 'CRiffChunk::Read', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LIHM@Attempted?5to?5read?5past?5the?5end?5o@
CONST	SEGMENT
??_C@_0CM@LIHM@Attempted?5to?5read?5past?5the?5end?5o@ DB 'Attempted to r'
	DB	'ead past the end of the chunk', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z
_TEXT	SEGMENT
_dwOffset$ = 8
_pvBuffer$ = 12
_dwBufferSize$ = 16
_pdwRead$ = 20
_this$ = -8
_hr$ = -4
?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z PROC NEAR	; WaveLoader::CRiffChunk::Read, COMDAT
; _this$ = ecx

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 706  :     HRESULT                 hr  = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 707  : 
; 708  :     DPF_ENTER();
; 709  : 
; 710  :     if(dwOffset + dwBufferSize > m_dwDataSize)

  00010	8b 45 08	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  00013	03 45 10	 add	 eax, DWORD PTR _dwBufferSize$[ebp]
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0001c	76 64		 jbe	 SHORT $L53070

; 711  :     {
; 712  :         if(dwOffset >= m_dwDataSize)

  0001e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 45 08	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  00024	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  00027	72 09		 jb	 SHORT $L53071

; 713  :         {
; 714  :             dwBufferSize = 0;

  00029	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _dwBufferSize$[ebp], 0

; 715  :         }
; 716  :         else

  00030	eb 0c		 jmp	 SHORT $L53072
$L53071:

; 717  :         {
; 718  :             dwBufferSize = m_dwDataSize - dwOffset;

  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00038	2b 55 08	 sub	 edx, DWORD PTR _dwOffset$[ebp]
  0003b	89 55 10	 mov	 DWORD PTR _dwBufferSize$[ebp], edx
$L53072:

; 719  :         }
; 720  : 
; 721  :         if(pdwRead)

  0003e	83 7d 14 00	 cmp	 DWORD PTR _pdwRead$[ebp], 0
  00042	74 0a		 je	 SHORT $L53073

; 722  :         {
; 723  :             *pdwRead = dwBufferSize;

  00044	8b 45 14	 mov	 eax, DWORD PTR _pdwRead$[ebp]
  00047	8b 4d 10	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  0004a	89 08		 mov	 DWORD PTR [eax], ecx

; 724  :         }
; 725  :         else

  0004c	eb 34		 jmp	 SHORT $L53074
$L53073:

; 726  :         {
; 727  :             DPF_ERROR("Attempted to read past the end of the chunk");

  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@EPJI@CRiffChunk?3?3Read?$AA@ ; `string'
  00058	68 d7 02 00 00	 push	 727			; 000002d7H
  0005d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00062	6a 04		 push	 4
  00064	6a 09		 push	 9
  00066	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0006b	83 c4 18	 add	 esp, 24			; 00000018H
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@LIHM@Attempted?5to?5read?5past?5the?5end?5o@ ; `string'
  00073	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00078	83 c4 04	 add	 esp, 4

; 728  :             hr = E_FAIL;

  0007b	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L53074:
$L53070:

; 729  :         }
; 730  :     }
; 731  : 
; 732  :     if(SUCCEEDED(hr))

  00082	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00086	7c 1c		 jl	 SHORT $L53079

; 733  :     {
; 734  :         hr = m_pStream->Seek(m_dwDataOffset + dwOffset, FILE_BEGIN, NULL);

  00088	6a 00		 push	 0
  0008a	6a 00		 push	 0
  0008c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0008f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00092	03 45 08	 add	 eax, DWORD PTR _dwOffset$[ebp]
  00095	50		 push	 eax
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009c	e8 00 00 00 00	 call	 ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z ; WaveLoader::CStdFileStream::Seek
  000a1	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L53079:

; 735  :     }
; 736  : 
; 737  :     if(SUCCEEDED(hr))

  000a4	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a8	7c 18		 jl	 SHORT $L53081

; 738  :     {
; 739  :         hr = m_pStream->Read(pvBuffer, dwBufferSize, NULL);

  000aa	6a 00		 push	 0
  000ac	8b 55 10	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  000af	52		 push	 edx
  000b0	8b 45 0c	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000ba	e8 00 00 00 00	 call	 ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z ; WaveLoader::CStdFileStream::Read
  000bf	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L53081:

; 740  :     }
; 741  : 
; 742  :     DPF_LEAVE_HRESULT(hr);
; 743  : 
; 744  :     return hr;

  000c2	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 745  : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 10 00	 ret	 16			; 00000010H
?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ENDP	; WaveLoader::CRiffChunk::Read
_TEXT	ENDS
PUBLIC	??0CWaveFile@WaveLoader@@QAE@XZ			; WaveLoader::CWaveFile::CWaveFile
; Function compile flags: /Odt
;	COMDAT ??0CWaveFile@WaveLoader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CWaveFile@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CWaveFile::CWaveFile, COMDAT
; _this$ = ecx

; 770  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::CStdFileStream
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 20	 add	 ecx, 32			; 00000020H
  00020	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 771  :     DPF_ENTER();
; 772  : 
; 773  :     m_dwFileType = -1;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c7 40 38 ff ff
	ff ff		 mov	 DWORD PTR [eax+56], -1

; 774  :     m_pwfxFormat = NULL;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 775  : 
; 776  :     DPF_LEAVE_VOID();
; 777  : }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??0CWaveFile@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CWaveFile::CWaveFile
_TEXT	ENDS
PUBLIC	??1CWaveFile@WaveLoader@@QAE@XZ			; WaveLoader::CWaveFile::~CWaveFile
PUBLIC	?Close@CWaveFile@WaveLoader@@QAEXXZ		; WaveLoader::CWaveFile::Close
; Function compile flags: /Odt
;	COMDAT ??1CWaveFile@WaveLoader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CWaveFile@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CWaveFile::~CWaveFile, COMDAT
; _this$ = ecx

; 802  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 803  :     DPF_ENTER();
; 804  : 
; 805  :     Close();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Close@CWaveFile@WaveLoader@@QAEXXZ ; WaveLoader::CWaveFile::Close

; 806  : 
; 807  :     DPF_LEAVE_VOID();
; 808  : }

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 20	 add	 ecx, 32			; 00000020H
  00015	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ??1CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::~CStdFileStream
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??1CWaveFile@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CWaveFile::~CWaveFile
_TEXT	ENDS
PUBLIC	??_C@_0DC@DPCC@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@ ; `string'
PUBLIC	??_C@_0BA@KPN@CWaveFile?3?3Open?$AA@		; `string'
PUBLIC	??_C@_0BK@LAOA@The?5file?5type?5is?5not?5WAVE?$AA@ ; `string'
PUBLIC	??_C@_0CB@CCLG@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@ ; `string'
PUBLIC	??_C@_0CL@MPHA@The?5file?8s?5AIFF?9C?5version?5is?5not@ ; `string'
PUBLIC	??_C@_04EHOP@BYTE?$AA@				; `string'
PUBLIC	?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z	; WaveLoader::CWaveFile::Open
PUBLIC	?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetWaveFormat
PUBLIC	?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetAiffFormat
;	COMDAT ??_C@_0DC@DPCC@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@
CONST	SEGMENT
??_C@_0DC@DPCC@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@ DB '('
	DB	'pszFileName || hFile) && !(pszFileName && hFile)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPN@CWaveFile?3?3Open?$AA@
CONST	SEGMENT
??_C@_0BA@KPN@CWaveFile?3?3Open?$AA@ DB 'CWaveFile::Open', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LAOA@The?5file?5type?5is?5not?5WAVE?$AA@
CONST	SEGMENT
??_C@_0BK@LAOA@The?5file?5type?5is?5not?5WAVE?$AA@ DB 'The file type is n'
	DB	'ot WAVE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CCLG@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@
CONST	SEGMENT
??_C@_0CB@CCLG@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@ DB 'The file type'
	DB	' is not AIFF/AIFF-C', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MPHA@The?5file?8s?5AIFF?9C?5version?5is?5not@
CONST	SEGMENT
??_C@_0CL@MPHA@The?5file?8s?5AIFF?9C?5version?5is?5not@ DB 'The file''s A'
	DB	'IFF-C version is not supported', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EHOP@BYTE?$AA@
CONST	SEGMENT
??_C@_04EHOP@BYTE?$AA@ DB 'BYTE', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z
_TEXT	SEGMENT
_pszFileName$ = 8
_hFile$ = 12
_this$ = -56
_hr$ = -12
_dwType$ = -8
_VersionChunk$ = -48
_dwVersion$ = -4
_dwFormatSize$ = -24
_AiffSoundHeader$ = -20
$T54146 = -52
?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z PROC NEAR	; WaveLoader::CWaveFile::Open, COMDAT
; _this$ = ecx

; 836  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 837  :     HRESULT                 hr              = S_OK;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 838  :     DWORD                   dwType;
; 839  :     CRiffChunk              VersionChunk;

  00010	8d 4d d0	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 840  :     DWORD                   dwVersion;
; 841  :     DWORD                   dwFormatSize;
; 842  :     AIFFSOUNDHDR            AiffSoundHeader;
; 843  : 
; 844  :     DPF_ENTER();
; 845  : 
; 846  :     ASSERT((pszFileName || hFile) && !(pszFileName && hFile));

  00018	83 7d 08 00	 cmp	 DWORD PTR _pszFileName$[ebp], 0
  0001c	75 06		 jne	 SHORT $L54142
  0001e	83 7d 0c 00	 cmp	 DWORD PTR _hFile$[ebp], 0
  00022	74 15		 je	 SHORT $L54144
$L54142:
  00024	83 7d 08 00	 cmp	 DWORD PTR _pszFileName$[ebp], 0
  00028	74 06		 je	 SHORT $L54143
  0002a	83 7d 0c 00	 cmp	 DWORD PTR _hFile$[ebp], 0
  0002e	75 09		 jne	 SHORT $L54144
$L54143:
  00030	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR -60+[ebp], 0
  00037	eb 07		 jmp	 SHORT $L54145
$L54144:
  00039	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR -60+[ebp], 1
$L54145:
  00040	68 4e 03 00 00	 push	 846			; 0000034eH
  00045	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DC@DPCC@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@ ; `string'
  0004f	8b 45 c4	 mov	 eax, DWORD PTR -60+[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00058	83 c4 10	 add	 esp, 16			; 00000010H

; 847  :     
; 848  :     //
; 849  :     // If we're already open, close
; 850  :     //
; 851  : 
; 852  :     Close();

  0005b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?Close@CWaveFile@WaveLoader@@QAEXXZ ; WaveLoader::CWaveFile::Close

; 853  : 
; 854  :     //
; 855  :     // Open the file
; 856  :     //
; 857  : 
; 858  :     if(pszFileName)

  00063	83 7d 08 00	 cmp	 DWORD PTR _pszFileName$[ebp], 0
  00067	74 1c		 je	 SHORT $L53103

; 859  :     {
; 860  :         hr = m_Stream.Open(pszFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, 0);

  00069	6a 00		 push	 0
  0006b	6a 03		 push	 3
  0006d	6a 01		 push	 1
  0006f	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _pszFileName$[ebp]
  00077	51		 push	 ecx
  00078	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z ; WaveLoader::CStdFileStream::Open
  00080	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 861  :     }
; 862  :     else

  00083	eb 0c		 jmp	 SHORT $L53104
$L53103:

; 863  :     {
; 864  :         m_Stream.Attach(hFile);

  00085	8b 55 0c	 mov	 edx, DWORD PTR _hFile$[ebp]
  00088	52		 push	 edx
  00089	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	e8 00 00 00 00	 call	 ?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z ; WaveLoader::CStdFileStream::Attach
$L53104:

; 865  :     }
; 866  : 
; 867  :     //
; 868  :     // Determine the file type by opening the top-level chunk
; 869  :     //
; 870  : 
; 871  :     if(SUCCEEDED(hr))

  00091	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00095	7c 54		 jl	 SHORT $L53106

; 872  :     {
; 873  :         hr = m_ParentChunk.Open(NULL, &m_Stream, WAVELDR_FOURCC_RIFF);

  00097	68 52 49 46 46	 push	 1179011410		; 46464952H
  0009c	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	50		 push	 eax
  000a0	6a 00		 push	 0
  000a2	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	83 c1 08	 add	 ecx, 8
  000a8	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  000ad	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 874  : 
; 875  :         if(SUCCEEDED(hr))

  000b0	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b4	7c 0c		 jl	 SHORT $L53108

; 876  :         {
; 877  :             m_dwFileType = WAVELDR_FILETYPE_WAVE;

  000b6	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 878  :         }
; 879  :         else

  000c0	eb 29		 jmp	 SHORT $L53109
$L53108:

; 880  :         {
; 881  :             hr = m_ParentChunk.Open(NULL, &m_Stream, WAVELDR_FOURCC_FORM);

  000c2	68 46 4f 52 4d	 push	 1297239878		; 4d524f46H
  000c7	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  000ca	52		 push	 edx
  000cb	6a 00		 push	 0
  000cd	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	83 c1 08	 add	 ecx, 8
  000d3	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  000d8	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 882  : 
; 883  :             if(SUCCEEDED(hr))

  000db	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000df	7c 0a		 jl	 SHORT $L53111

; 884  :             {
; 885  :                 m_dwFileType = WAVELDR_FILETYPE_AIFF;

  000e1	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	c7 40 38 01 00
	00 00		 mov	 DWORD PTR [eax+56], 1
$L53111:
$L53109:
$L53106:

; 886  :             }
; 887  :         }
; 888  :     }
; 889  : 
; 890  :     if(SUCCEEDED(hr))

  000eb	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ef	0f 8c b0 00 00
	00		 jl	 $L53113

; 891  :     {
; 892  :         hr = m_ParentChunk.Read(0, &dwType, sizeof(dwType));

  000f5	6a 00		 push	 0
  000f7	6a 04		 push	 4
  000f9	8d 4d f8	 lea	 ecx, DWORD PTR _dwType$[ebp]
  000fc	51		 push	 ecx
  000fd	6a 00		 push	 0
  000ff	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	83 c1 08	 add	 ecx, 8
  00105	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  0010a	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 893  : 
; 894  :         if(SUCCEEDED(hr))

  0010d	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00111	0f 8c 8e 00 00
	00		 jl	 $L53115

; 895  :         {
; 896  :             if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  00117	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0011a	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0011e	75 3f		 jne	 SHORT $L53116

; 897  :             {
; 898  :                 if(WAVELDR_FOURCC_WAVE != dwType)

  00120	81 7d f8 57 41
	56 45		 cmp	 DWORD PTR _dwType$[ebp], 1163280727 ; 45564157H
  00127	74 34		 je	 SHORT $L53117

; 899  :                 {
; 900  :                     DPF_ERROR("The file type is not WAVE");

  00129	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  0012e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@KPN@CWaveFile?3?3Open?$AA@ ; `string'
  00133	68 84 03 00 00	 push	 900			; 00000384H
  00138	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0013d	6a 04		 push	 4
  0013f	6a 09		 push	 9
  00141	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00146	83 c4 18	 add	 esp, 24			; 00000018H
  00149	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@LAOA@The?5file?5type?5is?5not?5WAVE?$AA@ ; `string'
  0014e	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00153	83 c4 04	 add	 esp, 4

; 901  :                     hr = E_FAIL;

  00156	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L53117:

; 902  :                 }
; 903  :             }
; 904  :             else

  0015d	eb 46		 jmp	 SHORT $L53121
$L53116:

; 905  :             {
; 906  :                 if((WAVELDR_FOURCC_AIFF != dwType) && (WAVELDR_FOURCC_AIFFC != dwType))

  0015f	81 7d f8 41 49
	46 46		 cmp	 DWORD PTR _dwType$[ebp], 1179011393 ; 46464941H
  00166	74 3d		 je	 SHORT $L53122
  00168	81 7d f8 41 49
	46 43		 cmp	 DWORD PTR _dwType$[ebp], 1128679745 ; 43464941H
  0016f	74 34		 je	 SHORT $L53122

; 907  :                 {
; 908  :                     DPF_ERROR("The file type is not AIFF/AIFF-C");

  00171	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  00176	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@KPN@CWaveFile?3?3Open?$AA@ ; `string'
  0017b	68 8c 03 00 00	 push	 908			; 0000038cH
  00180	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00185	6a 04		 push	 4
  00187	6a 09		 push	 9
  00189	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0018e	83 c4 18	 add	 esp, 24			; 00000018H
  00191	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@CCLG@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@ ; `string'
  00196	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0019b	83 c4 04	 add	 esp, 4

; 909  :                     hr = E_FAIL;

  0019e	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L53122:
$L53121:
$L53115:
$L53113:

; 910  :                 }
; 911  :             }
; 912  :         }
; 913  :     }
; 914  : 
; 915  :     if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType) && (WAVELDR_FOURCC_AIFFC == dwType))

  001a5	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001a9	0f 8c 8f 00 00
	00		 jl	 $L53126
  001af	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  001b2	83 78 38 01	 cmp	 DWORD PTR [eax+56], 1
  001b6	0f 85 82 00 00
	00		 jne	 $L53126
  001bc	81 7d f8 41 49
	46 43		 cmp	 DWORD PTR _dwType$[ebp], 1128679745 ; 43464941H
  001c3	75 79		 jne	 SHORT $L53126

; 916  :     {
; 917  :         hr = VersionChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_AIFF_VERSION);

  001c5	68 52 56 45 52	 push	 1380275794		; 52455652H
  001ca	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001cd	51		 push	 ecx
  001ce	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  001d1	83 c2 08	 add	 edx, 8
  001d4	52		 push	 edx
  001d5	8d 4d d0	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  001d8	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  001dd	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 918  : 
; 919  :         if(SUCCEEDED(hr))

  001e0	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001e4	7c 15		 jl	 SHORT $L53128

; 920  :         {
; 921  :             hr = VersionChunk.Read(0, &dwVersion, sizeof(dwVersion));

  001e6	6a 00		 push	 0
  001e8	6a 04		 push	 4
  001ea	8d 45 fc	 lea	 eax, DWORD PTR _dwVersion$[ebp]
  001ed	50		 push	 eax
  001ee	6a 00		 push	 0
  001f0	8d 4d d0	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  001f3	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  001f8	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
$L53128:

; 922  :         }
; 923  : 
; 924  :         if(SUCCEEDED(hr) && (WAVELDR_AIFFC_VERSION != dwVersion))

  001fb	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001ff	7c 3d		 jl	 SHORT $L53130
  00201	81 7d fc 40 51
	80 a2		 cmp	 DWORD PTR _dwVersion$[ebp], -1568648896 ; a2805140H
  00208	74 34		 je	 SHORT $L53130

; 925  :         {
; 926  :             DPF_ERROR("The file's AIFF-C version is not supported");

  0020a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  0020f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@KPN@CWaveFile?3?3Open?$AA@ ; `string'
  00214	68 9e 03 00 00	 push	 926			; 0000039eH
  00219	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0021e	6a 04		 push	 4
  00220	6a 09		 push	 9
  00222	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00227	83 c4 18	 add	 esp, 24			; 00000018H
  0022a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CL@MPHA@The?5file?8s?5AIFF?9C?5version?5is?5not@ ; `string'
  0022f	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00234	83 c4 04	 add	 esp, 4

; 927  :             hr = E_FAIL;

  00237	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L53130:
$L53126:

; 928  :         }
; 929  :     }
; 930  : 
; 931  :     //
; 932  :     // Initialize the required chunk objects
; 933  :     //
; 934  : 
; 935  :     if(SUCCEEDED(hr))

  0023e	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00242	7c 30		 jl	 SHORT $L53134

; 936  :     {
; 937  :         hr = m_DataChunk.Open(&m_ParentChunk, &m_Stream, (WAVELDR_FILETYPE_WAVE == m_dwFileType) ? WAVELDR_FOURCC_DATA : WAVELDR_FOURCC_SOUND);

  00244	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00247	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0024a	f7 da		 neg	 edx
  0024c	1b d2		 sbb	 edx, edx
  0024e	81 e2 ef f1 d9
	e2		 and	 edx, -489033233		; e2d9f1efH
  00254	81 c2 64 61 74
	61		 add	 edx, 1635017060		; 61746164H
  0025a	52		 push	 edx
  0025b	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0025e	50		 push	 eax
  0025f	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00262	83 c1 08	 add	 ecx, 8
  00265	51		 push	 ecx
  00266	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00269	83 c1 20	 add	 ecx, 32			; 00000020H
  0026c	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00271	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
$L53134:

; 938  :     }
; 939  : 
; 940  :     //
; 941  :     // Load the file format
; 942  :     //
; 943  : 
; 944  :     if(SUCCEEDED(hr))

  00274	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00278	7c 31		 jl	 SHORT $L53136

; 945  :     {
; 946  :         if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  0027a	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0027d	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00281	75 15		 jne	 SHORT $L53137

; 947  :         {
; 948  :             hr = GetWaveFormat(NULL, 0, &dwFormatSize);

  00283	8d 45 e8	 lea	 eax, DWORD PTR _dwFormatSize$[ebp]
  00286	50		 push	 eax
  00287	6a 00		 push	 0
  00289	6a 00		 push	 0
  0028b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0028e	e8 00 00 00 00	 call	 ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetWaveFormat
  00293	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 949  :         }
; 950  :         else

  00296	eb 13		 jmp	 SHORT $L53138
$L53137:

; 951  :         {
; 952  :             hr = GetAiffFormat(NULL, 0, &dwFormatSize);

  00298	8d 4d e8	 lea	 ecx, DWORD PTR _dwFormatSize$[ebp]
  0029b	51		 push	 ecx
  0029c	6a 00		 push	 0
  0029e	6a 00		 push	 0
  002a0	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002a3	e8 00 00 00 00	 call	 ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetAiffFormat
  002a8	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
$L53138:
$L53136:

; 953  :         }
; 954  :     }
; 955  : 
; 956  :     if(SUCCEEDED(hr))

  002ab	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002af	7c 3c		 jl	 SHORT $L53140

; 957  :     {
; 958  :         hr = HRFROMP(m_pwfxFormat = (LPWAVEFORMATEX)MEMALLOC(BYTE, dwFormatSize));

  002b1	6a 01		 push	 1
  002b3	8b 55 e8	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  002b6	52		 push	 edx
  002b7	68 44 53 64 61	 push	 1633964868		; 61645344H
  002bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04EHOP@BYTE?$AA@ ; `string'
  002c1	68 be 03 00 00	 push	 958			; 000003beH
  002c6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  002cb	e8 00 00 00 00	 call	 ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingPoolAlloc
  002d0	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002d3	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
  002d6	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  002d9	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  002dc	f7 d8		 neg	 eax
  002de	1b c0		 sbb	 eax, eax
  002e0	25 f2 ff f8 7f	 and	 eax, 2147024882		; 7ff8fff2H
  002e5	05 0e 00 07 80	 add	 eax, -2147024882	; 8007000eH
  002ea	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
$L53140:

; 959  :     }
; 960  : 
; 961  :     if(SUCCEEDED(hr))

  002ed	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002f1	7c 3b		 jl	 SHORT $L53148

; 962  :     {
; 963  :         if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  002f3	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002f6	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  002fa	75 1a		 jne	 SHORT $L53149

; 964  :         {
; 965  :             hr = GetWaveFormat(m_pwfxFormat, dwFormatSize, NULL);

  002fc	6a 00		 push	 0
  002fe	8b 55 e8	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  00301	52		 push	 edx
  00302	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00305	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00308	51		 push	 ecx
  00309	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0030c	e8 00 00 00 00	 call	 ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetWaveFormat
  00311	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 966  :         }
; 967  :         else

  00314	eb 18		 jmp	 SHORT $L53150
$L53149:

; 968  :         {
; 969  :             hr = GetAiffFormat(m_pwfxFormat, dwFormatSize, NULL);

  00316	6a 00		 push	 0
  00318	8b 55 e8	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  0031b	52		 push	 edx
  0031c	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0031f	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00322	51		 push	 ecx
  00323	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00326	e8 00 00 00 00	 call	 ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetAiffFormat
  0032b	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
$L53150:
$L53148:

; 970  :         }
; 971  :     }
; 972  : 
; 973  :     //
; 974  :     // If this is an AIFF file, offset the start of the wave data
; 975  :     //
; 976  : 
; 977  :     if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType))

  0032e	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00332	7c 4e		 jl	 SHORT $L53152
  00334	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00337	83 7a 38 01	 cmp	 DWORD PTR [edx+56], 1
  0033b	75 45		 jne	 SHORT $L53152

; 978  :     {
; 979  :         hr = m_DataChunk.Read(0, &AiffSoundHeader, sizeof(AiffSoundHeader));

  0033d	6a 00		 push	 0
  0033f	6a 08		 push	 8
  00341	8d 45 ec	 lea	 eax, DWORD PTR _AiffSoundHeader$[ebp]
  00344	50		 push	 eax
  00345	6a 00		 push	 0
  00347	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0034a	83 c1 20	 add	 ecx, 32			; 00000020H
  0034d	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00352	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 980  : 
; 981  :         if(SUCCEEDED(hr))

  00355	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00359	7c 27		 jl	 SHORT $L53154

; 982  :         {
; 983  :             m_DataChunk.m_dwDataOffset += sizeof(AiffSoundHeader) + AiffSoundHeader.dwOffset;

  0035b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0035e	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00361	8b 45 ec	 mov	 eax, DWORD PTR _AiffSoundHeader$[ebp]
  00364	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  00368	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0036b	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 984  :             m_DataChunk.m_dwDataSize -= sizeof(AiffSoundHeader) + AiffSoundHeader.dwOffset;

  0036e	8b 45 ec	 mov	 eax, DWORD PTR _AiffSoundHeader$[ebp]
  00371	83 c0 08	 add	 eax, 8
  00374	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00377	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0037a	2b d0		 sub	 edx, eax
  0037c	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0037f	89 50 30	 mov	 DWORD PTR [eax+48], edx
$L53154:
$L53152:

; 985  :         }
; 986  :     }
; 987  : 
; 988  :     DPF_LEAVE_HRESULT(hr);
; 989  : 
; 990  :     return hr;

  00382	8b 4d f4	 mov	 ecx, DWORD PTR _hr$[ebp]
  00385	89 4d cc	 mov	 DWORD PTR $T54146[ebp], ecx
  00388	8d 4d d0	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  0038b	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  00390	8b 45 cc	 mov	 eax, DWORD PTR $T54146[ebp]

; 991  : }

  00393	8b e5		 mov	 esp, ebp
  00395	5d		 pop	 ebp
  00396	c2 08 00	 ret	 8
?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z ENDP		; WaveLoader::CWaveFile::Open
_TEXT	ENDS
PUBLIC	?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetFormat
PUBLIC	??_C@_0N@OAHJ@m_pwfxFormat?$AA@			; `string'
EXTRN	_memcpy:NEAR
;	COMDAT ??_C@_0N@OAHJ@m_pwfxFormat?$AA@
CONST	SEGMENT
??_C@_0N@OAHJ@m_pwfxFormat?$AA@ DB 'm_pwfxFormat', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z
_TEXT	SEGMENT
_pwfxFormat$ = 8
_dwFormatSize$ = 12
_pdwRequiredSize$ = 16
_this$ = -12
_dwValidSize$ = -8
?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z PROC NEAR ; WaveLoader::CWaveFile::GetFormat, COMDAT
; _this$ = ecx

; 1021 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1022 :     DWORD                   dwValidSize;
; 1023 :     HRESULT                 hr;
; 1024 : 
; 1025 :     DPF_ENTER();
; 1026 : 
; 1027 :     ASSERT(m_pwfxFormat);

  00009	68 03 04 00 00	 push	 1027			; 00000403H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@OAHJ@m_pwfxFormat?$AA@ ; `string'
  00018	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	33 c9		 xor	 ecx, ecx
  0001d	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00021	0f 94 c1	 sete	 cl
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 1028 :     
; 1029 :     dwValidSize = sizeof(*m_pwfxFormat) + m_pwfxFormat->cbSize;

  0002d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00033	33 c9		 xor	 ecx, ecx
  00035	66 8b 48 10	 mov	 cx, WORD PTR [eax+16]
  00039	83 c1 12	 add	 ecx, 18			; 00000012H
  0003c	89 4d f8	 mov	 DWORD PTR _dwValidSize$[ebp], ecx

; 1030 : 
; 1031 :     if(pwfxFormat && dwFormatSize)

  0003f	83 7d 08 00	 cmp	 DWORD PTR _pwfxFormat$[ebp], 0
  00043	74 53		 je	 SHORT $L53165
  00045	83 7d 0c 00	 cmp	 DWORD PTR _dwFormatSize$[ebp], 0
  00049	74 4d		 je	 SHORT $L53165

; 1032 :     {
; 1033 :         CopyMemory(pwfxFormat, m_pwfxFormat, min(dwFormatSize, dwValidSize));

  0004b	8b 55 0c	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  0004e	3b 55 f8	 cmp	 edx, DWORD PTR _dwValidSize$[ebp]
  00051	73 08		 jae	 SHORT $L54150
  00053	8b 45 0c	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  00056	89 45 f0	 mov	 DWORD PTR -16+[ebp], eax
  00059	eb 06		 jmp	 SHORT $L54151
$L54150:
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _dwValidSize$[ebp]
  0005e	89 4d f0	 mov	 DWORD PTR -16+[ebp], ecx
$L54151:
  00061	8b 55 f0	 mov	 edx, DWORD PTR -16+[ebp]
  00064	52		 push	 edx
  00065	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0006b	51		 push	 ecx
  0006c	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _memcpy
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1034 : 
; 1035 :         if(dwFormatSize > dwValidSize)

  00078	8b 45 0c	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  0007b	3b 45 f8	 cmp	 eax, DWORD PTR _dwValidSize$[ebp]
  0007e	76 18		 jbe	 SHORT $L53166

; 1036 :         {
; 1037 :             ZeroMemory((LPBYTE)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize);

  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFormatSize$[ebp]
  00083	2b 4d f8	 sub	 ecx, DWORD PTR _dwValidSize$[ebp]
  00086	51		 push	 ecx
  00087	6a 00		 push	 0
  00089	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  0008c	03 55 f8	 add	 edx, DWORD PTR _dwValidSize$[ebp]
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 _memset
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH
$L53166:
$L53165:

; 1038 :         }
; 1039 :     }
; 1040 : 
; 1041 :     if(pdwRequiredSize)

  00098	83 7d 10 00	 cmp	 DWORD PTR _pdwRequiredSize$[ebp], 0
  0009c	74 08		 je	 SHORT $L53168

; 1042 :     {
; 1043 :         *pdwRequiredSize = dwValidSize;

  0009e	8b 45 10	 mov	 eax, DWORD PTR _pdwRequiredSize$[ebp]
  000a1	8b 4d f8	 mov	 ecx, DWORD PTR _dwValidSize$[ebp]
  000a4	89 08		 mov	 DWORD PTR [eax], ecx
$L53168:

; 1044 :     }
; 1045 : 
; 1046 :     DPF_LEAVE_HRESULT(S_OK);
; 1047 : 
; 1048 :     return S_OK;

  000a6	33 c0		 xor	 eax, eax

; 1049 : }

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 0c 00	 ret	 12			; 0000000cH
?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z ENDP ; WaveLoader::CWaveFile::GetFormat
_TEXT	ENDS
PUBLIC	?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ	; WaveLoader::CRiffChunk::GetDataSize
PUBLIC	??_C@_0CG@DJPM@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@ ; `string'
;	COMDAT ??_C@_0CG@DJPM@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@
CONST	SEGMENT
??_C@_0CG@DJPM@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@ DB 'WAVELDR_FILE'
	DB	'TYPE_WAVE == m_dwFileType', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
_TEXT	SEGMENT
$T54159 = -36
_pwfxFormat$ = 8
_dwFormatSize$ = 12
_pdwRequiredSize$ = 16
_this$ = -40
_FormatChunk$ = -32
_dwValidSize$ = -8
_hr$ = -4
?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z PROC NEAR ; WaveLoader::CWaveFile::GetWaveFormat, COMDAT
; _this$ = ecx

; 1079 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 1080 :     CRiffChunk              FormatChunk;

  00009	8d 4d e0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1081 :     DWORD                   dwValidSize;
; 1082 :     HRESULT                 hr;
; 1083 : 
; 1084 :     DPF_ENTER();
; 1085 : 
; 1086 :     ASSERT(WAVELDR_FILETYPE_WAVE == m_dwFileType);

  00011	68 3e 04 00 00	 push	 1086			; 0000043eH
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@DJPM@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@ ; `string'
  00020	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00023	33 c9		 xor	 ecx, ecx
  00025	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00029	0f 95 c1	 setne	 cl
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 1087 : 
; 1088 :     //
; 1089 :     // Read the format chunk into the buffer.  Make sure to fill in the full
; 1090 :     // WAVEFORMATEX structure, even if the data in the file isn't enough.
; 1091 :     //
; 1092 : 
; 1093 :     hr = FormatChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_FORMAT);

  00035	68 66 6d 74 20	 push	 544501094		; 20746d66H
  0003a	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	52		 push	 edx
  0003e	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 c0 08	 add	 eax, 8
  00044	50		 push	 eax
  00045	8d 4d e0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00048	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  0004d	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1094 : 
; 1095 :     if(SUCCEEDED(hr))

  00050	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00054	7c 38		 jl	 SHORT $L53181

; 1096 :     {
; 1097 :         dwValidSize = FormatChunk.GetDataSize();

  00056	8d 4d e0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00059	e8 00 00 00 00	 call	 ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ; WaveLoader::CRiffChunk::GetDataSize
  0005e	89 45 f8	 mov	 DWORD PTR _dwValidSize$[ebp], eax

; 1098 : 
; 1099 :         hr = FormatChunk.Read(0, pwfxFormat, min(dwValidSize, dwFormatSize));

  00061	8b 4d f8	 mov	 ecx, DWORD PTR _dwValidSize$[ebp]
  00064	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwFormatSize$[ebp]
  00067	73 08		 jae	 SHORT $L54155
  00069	8b 55 f8	 mov	 edx, DWORD PTR _dwValidSize$[ebp]
  0006c	89 55 d4	 mov	 DWORD PTR -44+[ebp], edx
  0006f	eb 06		 jmp	 SHORT $L54156
$L54155:
  00071	8b 45 0c	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  00074	89 45 d4	 mov	 DWORD PTR -44+[ebp], eax
$L54156:
  00077	6a 00		 push	 0
  00079	8b 4d d4	 mov	 ecx, DWORD PTR -44+[ebp]
  0007c	51		 push	 ecx
  0007d	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  00080	52		 push	 edx
  00081	6a 00		 push	 0
  00083	8d 4d e0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00086	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  0008b	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L53181:

; 1100 :     }
; 1101 : 
; 1102 :     if(SUCCEEDED(hr) && (dwFormatSize > dwValidSize))

  0008e	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00092	7c 20		 jl	 SHORT $L53183
  00094	8b 45 0c	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  00097	3b 45 f8	 cmp	 eax, DWORD PTR _dwValidSize$[ebp]
  0009a	76 18		 jbe	 SHORT $L53183

; 1103 :     {
; 1104 :         ZeroMemory((LPBYTE)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize);

  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFormatSize$[ebp]
  0009f	2b 4d f8	 sub	 ecx, DWORD PTR _dwValidSize$[ebp]
  000a2	51		 push	 ecx
  000a3	6a 00		 push	 0
  000a5	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  000a8	03 55 f8	 add	 edx, DWORD PTR _dwValidSize$[ebp]
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 _memset
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
$L53183:

; 1105 :     }
; 1106 : 
; 1107 :     if(SUCCEEDED(hr) && pdwRequiredSize)

  000b4	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b8	7c 23		 jl	 SHORT $L53186
  000ba	83 7d 10 00	 cmp	 DWORD PTR _pdwRequiredSize$[ebp], 0
  000be	74 1d		 je	 SHORT $L53186

; 1108 :     {
; 1109 :         *pdwRequiredSize = max(dwValidSize, sizeof(*pwfxFormat));

  000c0	83 7d f8 12	 cmp	 DWORD PTR _dwValidSize$[ebp], 18 ; 00000012H
  000c4	76 08		 jbe	 SHORT $L54157
  000c6	8b 45 f8	 mov	 eax, DWORD PTR _dwValidSize$[ebp]
  000c9	89 45 d0	 mov	 DWORD PTR -48+[ebp], eax
  000cc	eb 07		 jmp	 SHORT $L54158
$L54157:
  000ce	c7 45 d0 12 00
	00 00		 mov	 DWORD PTR -48+[ebp], 18	; 00000012H
$L54158:
  000d5	8b 4d 10	 mov	 ecx, DWORD PTR _pdwRequiredSize$[ebp]
  000d8	8b 55 d0	 mov	 edx, DWORD PTR -48+[ebp]
  000db	89 11		 mov	 DWORD PTR [ecx], edx
$L53186:

; 1110 :     }
; 1111 : 
; 1112 :     DPF_LEAVE_HRESULT(hr);
; 1113 : 
; 1114 :     return hr;

  000dd	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  000e0	89 45 dc	 mov	 DWORD PTR $T54159[ebp], eax
  000e3	8d 4d e0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  000e6	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  000eb	8b 45 dc	 mov	 eax, DWORD PTR $T54159[ebp]

; 1115 : }

  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 0c 00	 ret	 12			; 0000000cH
?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ENDP ; WaveLoader::CWaveFile::GetWaveFormat
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\waveldr.h
_TEXT	ENDS
;	COMDAT ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4
?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ PROC NEAR	; WaveLoader::CRiffChunk::GetDataSize, COMDAT
; _this$ = ecx

; 276  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 277  :         return m_dwDataSize;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 278  :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ENDP		; WaveLoader::CRiffChunk::GetDataSize
_TEXT	ENDS
PUBLIC	??_C@_0CG@DNJG@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@ ; `string'
PUBLIC	??_C@_0BJ@KIEA@CWaveFile?3?3GetAiffFormat?$AA@	; `string'
PUBLIC	??_C@_0CC@IGMG@Unsupported?5AIFF?5compression?5typ@ ; `string'
;	COMDAT ??_C@_0CG@DNJG@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@
; File c:\xbox\private\windows\directx\dsound\common\waveldr.cpp
CONST	SEGMENT
??_C@_0CG@DNJG@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@ DB 'WAVELDR_FILE'
	DB	'TYPE_AIFF == m_dwFileType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KIEA@CWaveFile?3?3GetAiffFormat?$AA@
CONST	SEGMENT
??_C@_0BJ@KIEA@CWaveFile?3?3GetAiffFormat?$AA@ DB 'CWaveFile::GetAiffForm'
	DB	'at', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IGMG@Unsupported?5AIFF?5compression?5typ@
CONST	SEGMENT
??_C@_0CC@IGMG@Unsupported?5AIFF?5compression?5typ@ DB 'Unsupported AIFF '
	DB	'compression type', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
_TEXT	SEGMENT
$T54170 = -76
_pwfxFormat$ = 8
_dwFormatSize$ = 12
_pdwRequiredSize$ = 16
_this$ = -80
_hr$ = -4
_FormatChunk$ = -72
_dwValidSize$ = -8
_AiffFormat$ = -48
_WaveFormat$ = -28
?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z PROC NEAR ; WaveLoader::CWaveFile::GetAiffFormat, COMDAT
; _this$ = ecx

; 1145 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 1146 :     HRESULT                 hr          = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1147 :     CRiffChunk              FormatChunk;

  00010	8d 4d b8	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1148 :     DWORD                   dwValidSize;
; 1149 :     AIFFFORMAT              AiffFormat;
; 1150 :     WAVEFORMATEX            WaveFormat;
; 1151 : 
; 1152 :     DPF_ENTER();
; 1153 : 
; 1154 :     ASSERT(WAVELDR_FILETYPE_AIFF == m_dwFileType);

  00018	68 82 04 00 00	 push	 1154			; 00000482H
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00022	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@DNJG@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@ ; `string'
  00027	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	33 c9		 xor	 ecx, ecx
  0002c	83 78 38 01	 cmp	 DWORD PTR [eax+56], 1
  00030	0f 95 c1	 setne	 cl
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00039	83 c4 10	 add	 esp, 16			; 00000010H

; 1155 : 
; 1156 :     if(pwfxFormat && dwFormatSize)

  0003c	83 7d 08 00	 cmp	 DWORD PTR _pwfxFormat$[ebp], 0
  00040	0f 84 94 01 00
	00		 je	 $L53201
  00046	83 7d 0c 00	 cmp	 DWORD PTR _dwFormatSize$[ebp], 0
  0004a	0f 84 8a 01 00
	00		 je	 $L53201

; 1157 :     {
; 1158 :         //
; 1159 :         // Open the format chunk
; 1160 :         //
; 1161 : 
; 1162 :         hr = FormatChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_COMM);

  00050	68 43 4f 4d 4d	 push	 1296912195		; 4d4d4f43H
  00055	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00058	52		 push	 edx
  00059	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 c0 08	 add	 eax, 8
  0005f	50		 push	 eax
  00060	8d 4d b8	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00063	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00068	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1163 :         
; 1164 :         //
; 1165 :         // Read the base format data
; 1166 :         //
; 1167 : 
; 1168 :         if(SUCCEEDED(hr))

  0006b	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006f	7c 37		 jl	 SHORT $L53203

; 1169 :         {
; 1170 :             dwValidSize = FormatChunk.GetDataSize();

  00071	8d 4d b8	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00074	e8 00 00 00 00	 call	 ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ; WaveLoader::CRiffChunk::GetDataSize
  00079	89 45 f8	 mov	 DWORD PTR _dwValidSize$[ebp], eax

; 1171 : 
; 1172 :             hr = FormatChunk.Read(0, &AiffFormat, min(sizeof(AiffFormat), dwValidSize));

  0007c	83 7d f8 14	 cmp	 DWORD PTR _dwValidSize$[ebp], 20 ; 00000014H
  00080	76 09		 jbe	 SHORT $L54166
  00082	c7 45 ac 14 00
	00 00		 mov	 DWORD PTR -84+[ebp], 20	; 00000014H
  00089	eb 06		 jmp	 SHORT $L54167
$L54166:
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _dwValidSize$[ebp]
  0008e	89 4d ac	 mov	 DWORD PTR -84+[ebp], ecx
$L54167:
  00091	6a 00		 push	 0
  00093	8b 55 ac	 mov	 edx, DWORD PTR -84+[ebp]
  00096	52		 push	 edx
  00097	8d 45 d0	 lea	 eax, DWORD PTR _AiffFormat$[ebp]
  0009a	50		 push	 eax
  0009b	6a 00		 push	 0
  0009d	8d 4d b8	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  000a0	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  000a5	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L53203:

; 1173 :         }
; 1174 : 
; 1175 :         if(SUCCEEDED(hr) && (sizeof(AiffFormat) > dwValidSize))

  000a8	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ac	7c 21		 jl	 SHORT $L53205
  000ae	83 7d f8 14	 cmp	 DWORD PTR _dwValidSize$[ebp], 20 ; 00000014H
  000b2	73 1b		 jae	 SHORT $L53205

; 1176 :         {
; 1177 :             ZeroMemory((LPBYTE)&AiffFormat + dwValidSize, sizeof(AiffFormat) - dwValidSize);

  000b4	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  000b9	2b 4d f8	 sub	 ecx, DWORD PTR _dwValidSize$[ebp]
  000bc	51		 push	 ecx
  000bd	6a 00		 push	 0
  000bf	8b 55 f8	 mov	 edx, DWORD PTR _dwValidSize$[ebp]
  000c2	8d 44 15 d0	 lea	 eax, DWORD PTR _AiffFormat$[ebp+edx]
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _memset
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH
$L53205:

; 1178 :         }
; 1179 : 
; 1180 :         //
; 1181 :         // If no compression type is specified, assume PCM
; 1182 :         //
; 1183 : 
; 1184 :         if(SUCCEEDED(hr) && !AiffFormat.dwCompression)

  000cf	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000d3	7c 0d		 jl	 SHORT $L53208
  000d5	83 7d e0 00	 cmp	 DWORD PTR _AiffFormat$[ebp+16], 0
  000d9	75 07		 jne	 SHORT $L53208

; 1185 :         {
; 1186 :             AiffFormat.dwCompression = WAVELDR_FOURCC_NONE;

  000db	c7 45 e0 4e 4f
	4e 45		 mov	 DWORD PTR _AiffFormat$[ebp+16], 1162760014 ; 454e4f4eH
$L53208:

; 1187 :         }
; 1188 : 
; 1189 :         //
; 1190 :         // Currently, only PCM is supported
; 1191 :         //
; 1192 : 
; 1193 :         if(SUCCEEDED(hr) && (WAVELDR_FOURCC_NONE != AiffFormat.dwCompression))

  000e2	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000e6	7c 3d		 jl	 SHORT $L53210
  000e8	81 7d e0 4e 4f
	4e 45		 cmp	 DWORD PTR _AiffFormat$[ebp+16], 1162760014 ; 454e4f4eH
  000ef	74 34		 je	 SHORT $L53210

; 1194 :         {
; 1195 :             DPF_ERROR("Unsupported AIFF compression type");

  000f1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  000f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@KIEA@CWaveFile?3?3GetAiffFormat?$AA@ ; `string'
  000fb	68 ab 04 00 00	 push	 1195			; 000004abH
  00100	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00105	6a 04		 push	 4
  00107	6a 09		 push	 9
  00109	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0010e	83 c4 18	 add	 esp, 24			; 00000018H
  00111	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@IGMG@Unsupported?5AIFF?5compression?5typ@ ; `string'
  00116	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0011b	83 c4 04	 add	 esp, 4

; 1196 :             hr = E_FAIL;

  0011e	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L53210:

; 1197 :         }
; 1198 : 
; 1199 :         //
; 1200 :         // Convert AIFF format to WAVE format
; 1201 :         //
; 1202 : 
; 1203 :         if(SUCCEEDED(hr))

  00125	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00129	7c 5c		 jl	 SHORT $L53215

; 1204 :         {
; 1205 :             AiffFormat.nChannels = EndianSwapWord(AiffFormat.nChannels);

  0012b	8b 4d d0	 mov	 ecx, DWORD PTR _AiffFormat$[ebp]
  0012e	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  00133	66 89 45 d0	 mov	 WORD PTR _AiffFormat$[ebp], ax

; 1206 :             AiffFormat.wBitsPerSample = EndianSwapWord(AiffFormat.wBitsPerSample);

  00137	8b 4d d6	 mov	 ecx, DWORD PTR _AiffFormat$[ebp+6]
  0013a	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0013f	66 89 45 d6	 mov	 WORD PTR _AiffFormat$[ebp+6], ax

; 1207 :             AiffFormat.wFrequencyExponent = EndianSwapWord(AiffFormat.wFrequencyExponent);

  00143	8b 4d d8	 mov	 ecx, DWORD PTR _AiffFormat$[ebp+8]
  00146	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0014b	66 89 45 d8	 mov	 WORD PTR _AiffFormat$[ebp+8], ax

; 1208 :             AiffFormat.dwFrequencyMantissa = EndianSwapDword(AiffFormat.dwFrequencyMantissa);

  0014f	8b 4d da	 mov	 ecx, DWORD PTR _AiffFormat$[ebp+10]
  00152	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  00157	89 45 da	 mov	 DWORD PTR _AiffFormat$[ebp+10], eax

; 1209 : 
; 1210 :             XAudioCreatePcmFormat(AiffFormat.nChannels, AiffFormat.dwFrequencyMantissa >> (16414 - (AiffFormat.wFrequencyExponent & 0x7FFF)), AiffFormat.wBitsPerSample, &WaveFormat);

  0015a	8d 4d e4	 lea	 ecx, DWORD PTR _WaveFormat$[ebp]
  0015d	51		 push	 ecx
  0015e	66 8b 55 d6	 mov	 dx, WORD PTR _AiffFormat$[ebp+6]
  00162	52		 push	 edx
  00163	8b 45 d8	 mov	 eax, DWORD PTR _AiffFormat$[ebp+8]
  00166	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0016b	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  00170	b9 1e 40 00 00	 mov	 ecx, 16414		; 0000401eH
  00175	2b c8		 sub	 ecx, eax
  00177	8b 55 da	 mov	 edx, DWORD PTR _AiffFormat$[ebp+10]
  0017a	d3 ea		 shr	 edx, cl
  0017c	52		 push	 edx
  0017d	66 8b 45 d0	 mov	 ax, WORD PTR _AiffFormat$[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 ?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::CreatePcmFormat
$L53215:

; 1211 :         }
; 1212 : 
; 1213 :         if(SUCCEEDED(hr))

  00187	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0018b	7c 29		 jl	 SHORT $L53217

; 1214 :         {
; 1215 :             CopyMemory(pwfxFormat, &WaveFormat, min(sizeof(WaveFormat), dwFormatSize));

  0018d	83 7d 0c 12	 cmp	 DWORD PTR _dwFormatSize$[ebp], 18 ; 00000012H
  00191	76 09		 jbe	 SHORT $L54168
  00193	c7 45 a8 12 00
	00 00		 mov	 DWORD PTR -88+[ebp], 18	; 00000012H
  0019a	eb 06		 jmp	 SHORT $L54169
$L54168:
  0019c	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFormatSize$[ebp]
  0019f	89 4d a8	 mov	 DWORD PTR -88+[ebp], ecx
$L54169:
  001a2	8b 55 a8	 mov	 edx, DWORD PTR -88+[ebp]
  001a5	52		 push	 edx
  001a6	8d 45 e4	 lea	 eax, DWORD PTR _WaveFormat$[ebp]
  001a9	50		 push	 eax
  001aa	8b 4d 08	 mov	 ecx, DWORD PTR _pwfxFormat$[ebp]
  001ad	51		 push	 ecx
  001ae	e8 00 00 00 00	 call	 _memcpy
  001b3	83 c4 0c	 add	 esp, 12			; 0000000cH
$L53217:

; 1216 :         }
; 1217 : 
; 1218 :         if(SUCCEEDED(hr) && (dwFormatSize > sizeof(WaveFormat)))

  001b6	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001ba	7c 1e		 jl	 SHORT $L53219
  001bc	83 7d 0c 12	 cmp	 DWORD PTR _dwFormatSize$[ebp], 18 ; 00000012H
  001c0	76 18		 jbe	 SHORT $L53219

; 1219 :         {
; 1220 :             ZeroMemory((LPBYTE)pwfxFormat + sizeof(WaveFormat), dwFormatSize - sizeof(WaveFormat));

  001c2	8b 55 0c	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  001c5	83 ea 12	 sub	 edx, 18			; 00000012H
  001c8	52		 push	 edx
  001c9	6a 00		 push	 0
  001cb	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  001ce	83 c0 12	 add	 eax, 18			; 00000012H
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 _memset
  001d7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L53219:
$L53201:

; 1221 :         }
; 1222 :     }
; 1223 :     
; 1224 :     if(SUCCEEDED(hr) && pdwRequiredSize)

  001da	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001de	7c 0f		 jl	 SHORT $L53222
  001e0	83 7d 10 00	 cmp	 DWORD PTR _pdwRequiredSize$[ebp], 0
  001e4	74 09		 je	 SHORT $L53222

; 1225 :     {
; 1226 :         *pdwRequiredSize = sizeof(WaveFormat);

  001e6	8b 4d 10	 mov	 ecx, DWORD PTR _pdwRequiredSize$[ebp]
  001e9	c7 01 12 00 00
	00		 mov	 DWORD PTR [ecx], 18	; 00000012H
$L53222:

; 1227 :     }
; 1228 : 
; 1229 :     DPF_LEAVE_HRESULT(hr);
; 1230 : 
; 1231 :     return hr;

  001ef	8b 55 fc	 mov	 edx, DWORD PTR _hr$[ebp]
  001f2	89 55 b4	 mov	 DWORD PTR $T54170[ebp], edx
  001f5	8d 4d b8	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  001f8	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  001fd	8b 45 b4	 mov	 eax, DWORD PTR $T54170[ebp]

; 1232 : }

  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c2 0c 00	 ret	 12			; 0000000cH
?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ENDP ; WaveLoader::CWaveFile::GetAiffFormat
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?EndianSwapWord@@YIGG@Z
_TEXT	SEGMENT
_n$ = -4
?EndianSwapWord@@YIGG@Z PROC NEAR			; EndianSwapWord, COMDAT
; _n$ = cx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	66 89 4d fc	 mov	 WORD PTR _n$[ebp], cx

; 40   :     __asm
; 41   :     {
; 42   :         mov     eax, ecx

  00009	8b c1		 mov	 eax, ecx

; 43   :         sar     eax, 8

  0000b	c1 f8 08	 sar	 eax, 8

; 44   :         and     eax, 0ffh

  0000e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 45   : 
; 46   :         mov     ebx, ecx

  00013	8b d9		 mov	 ebx, ecx

; 47   :         shl     ebx, 8

  00015	c1 e3 08	 shl	 ebx, 8

; 48   :         and     ebx, 0ff00h

  00018	81 e3 00 ff 00
	00		 and	 ebx, 65280		; 0000ff00H

; 49   :         or      eax, ebx

  0001e	0b c3		 or	 eax, ebx

; 50   :     }
; 51   : }

  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?EndianSwapWord@@YIGG@Z ENDP				; EndianSwapWord
_TEXT	ENDS
PUBLIC	?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z	; WaveLoader::CWaveFile::GetLoopRegion
PUBLIC	?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetWaveLoopRegion
PUBLIC	?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetAiffLoopRegion
; Function compile flags: /Odt
;	COMDAT ?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z
_TEXT	SEGMENT
_pdwLoopStart$ = 8
_pdwLoopLength$ = 12
_this$ = -8
_hr$ = -4
?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z PROC NEAR ; WaveLoader::CWaveFile::GetLoopRegion, COMDAT
; _this$ = ecx

; 1260 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1261 :     HRESULT                 hr;
; 1262 : 
; 1263 :     DPF_ENTER();
; 1264 : 
; 1265 :     ASSERT(m_pwfxFormat);

  00009	68 f1 04 00 00	 push	 1265			; 000004f1H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@OAHJ@m_pwfxFormat?$AA@ ; `string'
  00018	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	33 c9		 xor	 ecx, ecx
  0001d	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00021	0f 94 c1	 sete	 cl
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 1266 : 
; 1267 :     //
; 1268 :     // Read loop region data in samples
; 1269 :     //
; 1270 : 
; 1271 :     if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  0002d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00030	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00034	75 15		 jne	 SHORT $L53230

; 1272 :     {
; 1273 :         hr = GetWaveLoopRegion(pdwLoopStart, pdwLoopLength);

  00036	8b 45 0c	 mov	 eax, DWORD PTR _pdwLoopLength$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetWaveLoopRegion
  00046	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1274 :     }
; 1275 :     else

  00049	eb 13		 jmp	 SHORT $L53231
$L53230:

; 1276 :     {
; 1277 :         hr = GetAiffLoopRegion(pdwLoopStart, pdwLoopLength);

  0004b	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  0004e	52		 push	 edx
  0004f	8b 45 08	 mov	 eax, DWORD PTR _pdwLoopStart$[ebp]
  00052	50		 push	 eax
  00053	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetAiffLoopRegion
  0005b	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L53231:

; 1278 :     }
; 1279 : 
; 1280 :     //
; 1281 :     // Convert to bytes
; 1282 :     //
; 1283 : 
; 1284 :     if(SUCCEEDED(hr))

  0005e	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00062	0f 8c b8 00 00
	00		 jl	 $L53233

; 1285 :     {
; 1286 :         if(WAVE_FORMAT_XBOX_ADPCM == m_pwfxFormat->wFormatTag)

  00068	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0006e	33 c0		 xor	 eax, eax
  00070	66 8b 02	 mov	 ax, WORD PTR [edx]
  00073	83 f8 69	 cmp	 eax, 105		; 00000069H
  00076	75 76		 jne	 SHORT $L53234

; 1287 :         {
; 1288 :             *pdwLoopStart /= m_pwfxFormat->nChannels * XBOX_ADPCM_SAMPLES_PER_BLOCK;

  00078	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0007e	33 c0		 xor	 eax, eax
  00080	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00084	8b c8		 mov	 ecx, eax
  00086	c1 e1 06	 shl	 ecx, 6
  00089	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  0008c	8b 02		 mov	 eax, DWORD PTR [edx]
  0008e	33 d2		 xor	 edx, edx
  00090	f7 f1		 div	 ecx
  00092	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  00095	89 01		 mov	 DWORD PTR [ecx], eax

; 1289 :             *pdwLoopStart *= m_pwfxFormat->nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  00097	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0009a	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0009d	33 c9		 xor	 ecx, ecx
  0009f	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  000a3	6b c9 24	 imul	 ecx, 36			; 00000024H
  000a6	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  000a9	8b 02		 mov	 eax, DWORD PTR [edx]
  000ab	0f af c1	 imul	 eax, ecx
  000ae	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax

; 1290 : 
; 1291 :             *pdwLoopLength /= m_pwfxFormat->nChannels * XBOX_ADPCM_SAMPLES_PER_BLOCK;

  000b3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000b6	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000b9	33 c9		 xor	 ecx, ecx
  000bb	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  000bf	c1 e1 06	 shl	 ecx, 6
  000c2	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  000c5	8b 02		 mov	 eax, DWORD PTR [edx]
  000c7	33 d2		 xor	 edx, edx
  000c9	f7 f1		 div	 ecx
  000cb	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwLoopLength$[ebp]
  000ce	89 01		 mov	 DWORD PTR [ecx], eax

; 1292 :             *pdwLoopLength *= m_pwfxFormat->nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  000d0	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000d3	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000d6	33 c9		 xor	 ecx, ecx
  000d8	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  000dc	6b c9 24	 imul	 ecx, 36			; 00000024H
  000df	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  000e2	8b 02		 mov	 eax, DWORD PTR [edx]
  000e4	0f af c1	 imul	 eax, ecx
  000e7	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwLoopLength$[ebp]
  000ea	89 01		 mov	 DWORD PTR [ecx], eax

; 1293 :         }
; 1294 :         else

  000ec	eb 32		 jmp	 SHORT $L53235
$L53234:

; 1295 :         {
; 1296 :             *pdwLoopStart *= m_pwfxFormat->nBlockAlign;

  000ee	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000f1	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000f4	33 c9		 xor	 ecx, ecx
  000f6	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  000fa	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	0f af c1	 imul	 eax, ecx
  00102	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  00105	89 01		 mov	 DWORD PTR [ecx], eax

; 1297 :             *pdwLoopLength *= m_pwfxFormat->nBlockAlign;

  00107	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0010a	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0010d	33 c9		 xor	 ecx, ecx
  0010f	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  00113	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  00116	8b 02		 mov	 eax, DWORD PTR [edx]
  00118	0f af c1	 imul	 eax, ecx
  0011b	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwLoopLength$[ebp]
  0011e	89 01		 mov	 DWORD PTR [ecx], eax
$L53235:
$L53233:

; 1298 :         }
; 1299 :     }
; 1300 : 
; 1301 :     DPF_LEAVE_HRESULT(hr);
; 1302 : 
; 1303 :     return hr;

  00120	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1304 : }

  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c2 08 00	 ret	 8
?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z ENDP	; WaveLoader::CWaveFile::GetLoopRegion
_TEXT	ENDS
PUBLIC	??_C@_0CC@FFJO@CStdFileStream?3?3GetWaveLoopRegio@ ; `string'
PUBLIC	??_C@_0BO@EIKN@No?5FORWARD?5loop?5regions?5found?$AA@ ; `string'
PUBLIC	??_C@_0CJ@ENEM@Only?5the?5first?5FORWARD?5loop?5will@ ; `string'
;	COMDAT ??_C@_0CC@FFJO@CStdFileStream?3?3GetWaveLoopRegio@
CONST	SEGMENT
??_C@_0CC@FFJO@CStdFileStream?3?3GetWaveLoopRegio@ DB 'CStdFileStream::Ge'
	DB	'tWaveLoopRegion', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EIKN@No?5FORWARD?5loop?5regions?5found?$AA@
CONST	SEGMENT
??_C@_0BO@EIKN@No?5FORWARD?5loop?5regions?5found?$AA@ DB 'No FORWARD loop'
	DB	' regions found', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@ENEM@Only?5the?5first?5FORWARD?5loop?5will@
CONST	SEGMENT
??_C@_0CJ@ENEM@Only?5the?5first?5FORWARD?5loop?5will@ DB 'Only the first '
	DB	'FORWARD loop will be used', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
_TEXT	SEGMENT
$T54180 = -72
_pdwLoopStart$ = 8
_pdwLoopLength$ = 12
_this$ = -76
_InstrumentChunk$ = -68
_wsamp$ = -20
_loop$ = -36
_dwOffset$ = -44
_hr$ = -40
?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z PROC NEAR ; WaveLoader::CWaveFile::GetWaveLoopRegion, COMDAT
; _this$ = ecx

; 1332 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 1333 :     CRiffChunk              InstrumentChunk;

  00009	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1334 :     WAVESAMPLE              wsamp;
; 1335 :     WAVESAMPLE_LOOP         loop;
; 1336 :     DWORD                   dwOffset;
; 1337 :     HRESULT                 hr;
; 1338 : 
; 1339 :     DPF_ENTER();
; 1340 : 
; 1341 :     ASSERT(m_pwfxFormat);

  00011	68 3d 05 00 00	 push	 1341			; 0000053dH
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@OAHJ@m_pwfxFormat?$AA@ ; `string'
  00020	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00023	33 c9		 xor	 ecx, ecx
  00025	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00029	0f 94 c1	 sete	 cl
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 1342 : 
; 1343 :     //
; 1344 :     // Open the instrument chunk
; 1345 :     //
; 1346 : 
; 1347 :     hr = InstrumentChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_WAVE_SAMPLE);

  00035	68 77 73 6d 70	 push	 1886221175		; 706d7377H
  0003a	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	52		 push	 edx
  0003e	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 c0 08	 add	 eax, 8
  00044	50		 push	 eax
  00045	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00048	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  0004d	89 45 d8	 mov	 DWORD PTR _hr$[ebp], eax

; 1348 : 
; 1349 :     //
; 1350 :     // Read the WAVESAMPLE header and first loop region
; 1351 :     //
; 1352 : 
; 1353 :     if(SUCCEEDED(hr))

  00050	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00054	7c 15		 jl	 SHORT $L53247

; 1354 :     {
; 1355 :         hr = InstrumentChunk.Read(0, &wsamp, sizeof(wsamp));

  00056	6a 00		 push	 0
  00058	6a 14		 push	 20			; 00000014H
  0005a	8d 4d ec	 lea	 ecx, DWORD PTR _wsamp$[ebp]
  0005d	51		 push	 ecx
  0005e	6a 00		 push	 0
  00060	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00063	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00068	89 45 d8	 mov	 DWORD PTR _hr$[ebp], eax
$L53247:

; 1356 :     }
; 1357 : 
; 1358 :     //
; 1359 :     // Scan loop regions until we find one that's FORWARD or RELEASE
; 1360 :     //
; 1361 : 
; 1362 :     if(SUCCEEDED(hr))

  0006b	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006f	7c 52		 jl	 SHORT $L53249

; 1363 :     {
; 1364 :         dwOffset = sizeof(wsamp);

  00071	c7 45 d4 14 00
	00 00		 mov	 DWORD PTR _dwOffset$[ebp], 20 ; 00000014H
$L53251:

; 1365 :     
; 1366 :         while(SUCCEEDED(hr) && wsamp.dwSampleLoops)

  00078	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0007c	7c 45		 jl	 SHORT $L53252
  0007e	83 7d fc 00	 cmp	 DWORD PTR _wsamp$[ebp+16], 0
  00082	74 3f		 je	 SHORT $L53252

; 1367 :         {
; 1368 :             hr = InstrumentChunk.Read(dwOffset, &loop, sizeof(loop));

  00084	6a 00		 push	 0
  00086	6a 10		 push	 16			; 00000010H
  00088	8d 55 dc	 lea	 edx, DWORD PTR _loop$[ebp]
  0008b	52		 push	 edx
  0008c	8b 45 d4	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  0008f	50		 push	 eax
  00090	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00093	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00098	89 45 d8	 mov	 DWORD PTR _hr$[ebp], eax

; 1369 : 
; 1370 :             if(SUCCEEDED(hr))

  0009b	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0009f	7c 0e		 jl	 SHORT $L53255

; 1371 :             {
; 1372 :                 if((WAVESAMPLE_LOOPTYPE_FORWARD == loop.dwLoopType) || (WAVESAMPLE_LOOPTYPE_RELEASE == loop.dwLoopType))

  000a1	83 7d e0 00	 cmp	 DWORD PTR _loop$[ebp+4], 0
  000a5	74 06		 je	 SHORT $L53257
  000a7	83 7d e0 01	 cmp	 DWORD PTR _loop$[ebp+4], 1
  000ab	75 02		 jne	 SHORT $L53256
$L53257:

; 1373 :                 {
; 1374 :                     break;

  000ad	eb 14		 jmp	 SHORT $L53252
$L53256:
$L53255:

; 1375 :                 }
; 1376 :             }
; 1377 :         
; 1378 :             dwOffset += sizeof(loop);

  000af	8b 4d d4	 mov	 ecx, DWORD PTR _dwOffset$[ebp]
  000b2	83 c1 10	 add	 ecx, 16			; 00000010H
  000b5	89 4d d4	 mov	 DWORD PTR _dwOffset$[ebp], ecx

; 1379 : 
; 1380 :             wsamp.dwSampleLoops--;

  000b8	8b 55 fc	 mov	 edx, DWORD PTR _wsamp$[ebp+16]
  000bb	83 ea 01	 sub	 edx, 1
  000be	89 55 fc	 mov	 DWORD PTR _wsamp$[ebp+16], edx

; 1381 :         }

  000c1	eb b5		 jmp	 SHORT $L53251
$L53252:
$L53249:

; 1382 :     }
; 1383 : 
; 1384 :     if(SUCCEEDED(hr))

  000c3	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000c7	7c 6f		 jl	 SHORT $L53259

; 1385 :     {
; 1386 :         if(!wsamp.dwSampleLoops)

  000c9	83 7d fc 00	 cmp	 DWORD PTR _wsamp$[ebp+16], 0
  000cd	75 36		 jne	 SHORT $L53260

; 1387 :         {
; 1388 :             DPF_ERROR("No FORWARD loop regions found");

  000cf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  000d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@FFJO@CStdFileStream?3?3GetWaveLoopRegio@ ; `string'
  000d9	68 6c 05 00 00	 push	 1388			; 0000056cH
  000de	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000e3	6a 04		 push	 4
  000e5	6a 09		 push	 9
  000e7	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000ec	83 c4 18	 add	 esp, 24			; 00000018H
  000ef	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@EIKN@No?5FORWARD?5loop?5regions?5found?$AA@ ; `string'
  000f4	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000f9	83 c4 04	 add	 esp, 4

; 1389 :             hr = E_FAIL;

  000fc	c7 45 d8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1390 :         }
; 1391 :         else if(wsamp.dwSampleLoops > 1)

  00103	eb 33		 jmp	 SHORT $L53264
$L53260:
  00105	83 7d fc 01	 cmp	 DWORD PTR _wsamp$[ebp+16], 1
  00109	76 2d		 jbe	 SHORT $L53265

; 1392 :         {
; 1393 :             DPF_WARNING("Only the first FORWARD loop will be used");

  0010b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  00110	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@FFJO@CStdFileStream?3?3GetWaveLoopRegio@ ; `string'
  00115	68 71 05 00 00	 push	 1393			; 00000571H
  0011a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0011f	6a 04		 push	 4
  00121	6a 09		 push	 9
  00123	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00128	83 c4 18	 add	 esp, 24			; 00000018H
  0012b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@ENEM@Only?5the?5first?5FORWARD?5loop?5will@ ; `string'
  00130	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00135	83 c4 04	 add	 esp, 4
$L53265:
$L53264:
$L53259:

; 1394 :         }
; 1395 :     }
; 1396 : 
; 1397 :     //
; 1398 :     // Success
; 1399 :     //
; 1400 : 
; 1401 :     if(SUCCEEDED(hr))

  00138	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0013c	7c 10		 jl	 SHORT $L53268

; 1402 :     {
; 1403 :         *pdwLoopStart = loop.dwLoopStart;

  0013e	8b 45 08	 mov	 eax, DWORD PTR _pdwLoopStart$[ebp]
  00141	8b 4d e4	 mov	 ecx, DWORD PTR _loop$[ebp+8]
  00144	89 08		 mov	 DWORD PTR [eax], ecx

; 1404 :         *pdwLoopLength = loop.dwLoopLength;

  00146	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  00149	8b 45 e8	 mov	 eax, DWORD PTR _loop$[ebp+12]
  0014c	89 02		 mov	 DWORD PTR [edx], eax
$L53268:

; 1405 :     }
; 1406 : 
; 1407 :     DPF_LEAVE_HRESULT(hr);
; 1408 : 
; 1409 :     return hr;

  0014e	8b 4d d8	 mov	 ecx, DWORD PTR _hr$[ebp]
  00151	89 4d b8	 mov	 DWORD PTR $T54180[ebp], ecx
  00154	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00157	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  0015c	8b 45 b8	 mov	 eax, DWORD PTR $T54180[ebp]

; 1410 : }

  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c2 08 00	 ret	 8
?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ENDP ; WaveLoader::CWaveFile::GetWaveLoopRegion
_TEXT	ENDS
PUBLIC	??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@ ; `string'
PUBLIC	??_C@_0BI@EGGG@Neither?5loop?5is?5FORWARD?$AA@	; `string'
PUBLIC	??_C@_0DF@PJLL@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@ ; `string'
PUBLIC	??_C@_0BN@INFE@Can?8t?5find?5loop?5start?5marker?$AA@ ; `string'
PUBLIC	??_C@_0DD@DPMK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@ ; `string'
PUBLIC	??_C@_0BL@IHKN@Can?8t?5find?5loop?5end?5marker?$AA@ ; `string'
PUBLIC	??_C@_0DB@DCLE@Loop?5end?5point?5less?9than?9or?9equa@ ; `string'
;	COMDAT ??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@
CONST	SEGMENT
??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@ DB 'CStdFileStream::Ge'
	DB	'tAiffLoopRegion', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EGGG@Neither?5loop?5is?5FORWARD?$AA@
CONST	SEGMENT
??_C@_0BI@EGGG@Neither?5loop?5is?5FORWARD?$AA@ DB 'Neither loop is FORWAR'
	DB	'D', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PJLL@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@
CONST	SEGMENT
??_C@_0DF@PJLL@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@ DB '(DW'
	DB	'ORD)pStartMarker < (DWORD)pMarkers + dwMarkerSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@INFE@Can?8t?5find?5loop?5start?5marker?$AA@
CONST	SEGMENT
??_C@_0BN@INFE@Can?8t?5find?5loop?5start?5marker?$AA@ DB 'Can''t find loo'
	DB	'p start marker', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@DPMK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@
CONST	SEGMENT
??_C@_0DD@DPMK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@ DB '(DW'
	DB	'ORD)pEndMarker < (DWORD)pMarkers + dwMarkerSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKN@Can?8t?5find?5loop?5end?5marker?$AA@
CONST	SEGMENT
??_C@_0BL@IHKN@Can?8t?5find?5loop?5end?5marker?$AA@ DB 'Can''t find loop '
	DB	'end marker', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@DCLE@Loop?5end?5point?5less?9than?9or?9equa@
CONST	SEGMENT
??_C@_0DB@DCLE@Loop?5end?5point?5less?9than?9or?9equa@ DB 'Loop end point'
	DB	' less-than-or-equal-to start point', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
_TEXT	SEGMENT
$T54184 = -104
_pdwLoopStart$ = 8
_pdwLoopLength$ = 12
_this$ = -108
_pMarkers$ = -92
_InstrumentChunk$ = -88
_inst$ = -24
_pLoop$ = -60
_MarkerChunk$ = -48
_dwMarkerSize$ = -56
_pStartMarker$ = -100
_pEndMarker$ = -52
_hr$ = -64
_i$ = -94
?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z PROC NEAR ; WaveLoader::CWaveFile::GetAiffLoopRegion, COMDAT
; _this$ = ecx

; 1438 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	89 4d 94	 mov	 DWORD PTR _this$[ebp], ecx

; 1439 :     LPAIFFMARKERHDR         pMarkers            = NULL;

  00009	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _pMarkers$[ebp], 0

; 1440 :     CRiffChunk              InstrumentChunk;

  00010	8d 4d a8	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1441 :     AIFFINSTRUMENT          inst;
; 1442 :     LPAIFFLOOP              pLoop;
; 1443 :     CRiffChunk              MarkerChunk;

  00018	8d 4d d0	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1444 :     DWORD                   dwMarkerSize;
; 1445 :     AIFFMARKERHDR           MarkerHeader;
; 1446 :     LPAIFFMARKER            pStartMarker;
; 1447 :     LPAIFFMARKER            pEndMarker;
; 1448 :     HRESULT                 hr;
; 1449 :     WORD                    i;
; 1450 : 
; 1451 :     DPF_ENTER();
; 1452 : 
; 1453 :     //
; 1454 :     // Open the instrument chunk
; 1455 :     //
; 1456 : 
; 1457 :     hr = InstrumentChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_INSTRUMENT);

  00020	68 49 4e 53 54	 push	 1414745673		; 54534e49H
  00025	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 08	 add	 ecx, 8
  0002f	51		 push	 ecx
  00030	8d 4d a8	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00033	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00038	89 45 c0	 mov	 DWORD PTR _hr$[ebp], eax

; 1458 : 
; 1459 :     //
; 1460 :     // Read the instrument data
; 1461 :     //
; 1462 : 
; 1463 :     if(SUCCEEDED(hr))

  0003b	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0003f	7c 15		 jl	 SHORT $L53287

; 1464 :     {
; 1465 :         hr = InstrumentChunk.Read(0, &inst, sizeof(inst));

  00041	6a 00		 push	 0
  00043	6a 14		 push	 20			; 00000014H
  00045	8d 55 e8	 lea	 edx, DWORD PTR _inst$[ebp]
  00048	52		 push	 edx
  00049	6a 00		 push	 0
  0004b	8d 4d a8	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  0004e	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00053	89 45 c0	 mov	 DWORD PTR _hr$[ebp], eax
$L53287:

; 1466 :     }
; 1467 : 
; 1468 :     //
; 1469 :     // Use the first loop that's FORWARD
; 1470 :     //
; 1471 : 
; 1472 :     if(SUCCEEDED(hr))

  00056	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0005a	7c 68		 jl	 SHORT $L53289

; 1473 :     {
; 1474 :         if(AIFFLOOP_MODE_FORWARD == EndianSwapWord(inst.SustainLoop.wPlayMode))

  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _inst$[ebp+8]
  0005f	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  00064	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00069	83 f8 01	 cmp	 eax, 1
  0006c	75 08		 jne	 SHORT $L53290

; 1475 :         {
; 1476 :             pLoop = &inst.SustainLoop;

  0006e	8d 45 f0	 lea	 eax, DWORD PTR _inst$[ebp+8]
  00071	89 45 c4	 mov	 DWORD PTR _pLoop$[ebp], eax

; 1477 :         }
; 1478 :         else if(AIFFLOOP_MODE_FORWARD == EndianSwapWord(inst.ReleaseLoop.wPlayMode))

  00074	eb 4e		 jmp	 SHORT $L53291
$L53290:
  00076	8b 4d f6	 mov	 ecx, DWORD PTR _inst$[ebp+14]
  00079	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0007e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00083	83 f8 01	 cmp	 eax, 1
  00086	75 08		 jne	 SHORT $L53292

; 1479 :         {
; 1480 :             pLoop = &inst.ReleaseLoop;

  00088	8d 4d f6	 lea	 ecx, DWORD PTR _inst$[ebp+14]
  0008b	89 4d c4	 mov	 DWORD PTR _pLoop$[ebp], ecx

; 1481 :         }
; 1482 :         else

  0008e	eb 34		 jmp	 SHORT $L53293
$L53292:

; 1483 :         {
; 1484 :             DPF_ERROR("Neither loop is FORWARD");

  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  00095	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@ ; `string'
  0009a	68 cc 05 00 00	 push	 1484			; 000005ccH
  0009f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000a4	6a 04		 push	 4
  000a6	6a 09		 push	 9
  000a8	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000ad	83 c4 18	 add	 esp, 24			; 00000018H
  000b0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@EGGG@Neither?5loop?5is?5FORWARD?$AA@ ; `string'
  000b5	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000ba	83 c4 04	 add	 esp, 4

; 1485 :             hr = E_FAIL;

  000bd	c7 45 c0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L53293:
$L53291:
$L53289:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     //
; 1490 :     // Open the marker chunk
; 1491 :     //
; 1492 : 
; 1493 :     if(SUCCEEDED(hr))

  000c4	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000c8	7c 1b		 jl	 SHORT $L53298

; 1494 :     {
; 1495 :         hr = MarkerChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_MARKER);

  000ca	68 4d 41 52 4b	 push	 1263681869		; 4b52414dH
  000cf	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  000d2	52		 push	 edx
  000d3	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	83 c0 08	 add	 eax, 8
  000d9	50		 push	 eax
  000da	8d 4d d0	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  000dd	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  000e2	89 45 c0	 mov	 DWORD PTR _hr$[ebp], eax
$L53298:

; 1496 :     }
; 1497 : 
; 1498 :     // 
; 1499 :     // Read marker data
; 1500 :     //
; 1501 : 
; 1502 :     if(SUCCEEDED(hr))

  000e5	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000e9	7c 43		 jl	 SHORT $L53300

; 1503 :     {
; 1504 :         dwMarkerSize = MarkerChunk.GetDataSize();

  000eb	8d 4d d0	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  000ee	e8 00 00 00 00	 call	 ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ; WaveLoader::CRiffChunk::GetDataSize
  000f3	89 45 c8	 mov	 DWORD PTR _dwMarkerSize$[ebp], eax

; 1505 :         
; 1506 :         hr = HRFROMP(pMarkers = (LPAIFFMARKERHDR)MEMALLOC(BYTE, dwMarkerSize));

  000f6	6a 01		 push	 1
  000f8	8b 4d c8	 mov	 ecx, DWORD PTR _dwMarkerSize$[ebp]
  000fb	51		 push	 ecx
  000fc	68 44 53 64 61	 push	 1633964868		; 61645344H
  00101	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04EHOP@BYTE?$AA@ ; `string'
  00106	68 e2 05 00 00	 push	 1506			; 000005e2H
  0010b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00110	e8 00 00 00 00	 call	 ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingPoolAlloc
  00115	89 45 a4	 mov	 DWORD PTR _pMarkers$[ebp], eax
  00118	8b 55 a4	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  0011b	f7 da		 neg	 edx
  0011d	1b d2		 sbb	 edx, edx
  0011f	81 e2 f2 ff f8
	7f		 and	 edx, 2147024882		; 7ff8fff2H
  00125	81 c2 0e 00 07
	80		 add	 edx, -2147024882	; 8007000eH
  0012b	89 55 c0	 mov	 DWORD PTR _hr$[ebp], edx
$L53300:

; 1507 :     }
; 1508 : 
; 1509 :     if(SUCCEEDED(hr))

  0012e	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00132	7c 17		 jl	 SHORT $L53307

; 1510 :     {
; 1511 :         hr = MarkerChunk.Read(0, pMarkers, dwMarkerSize);

  00134	6a 00		 push	 0
  00136	8b 45 c8	 mov	 eax, DWORD PTR _dwMarkerSize$[ebp]
  00139	50		 push	 eax
  0013a	8b 4d a4	 mov	 ecx, DWORD PTR _pMarkers$[ebp]
  0013d	51		 push	 ecx
  0013e	6a 00		 push	 0
  00140	8d 4d d0	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  00143	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00148	89 45 c0	 mov	 DWORD PTR _hr$[ebp], eax
$L53307:

; 1512 :     }
; 1513 : 
; 1514 :     if(SUCCEEDED(hr))

  0014b	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0014f	7c 11		 jl	 SHORT $L53309

; 1515 :     {
; 1516 :         pMarkers->wMarkerCount = EndianSwapWord(pMarkers->wMarkerCount);

  00151	8b 55 a4	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  00154	66 8b 0a	 mov	 cx, WORD PTR [edx]
  00157	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0015c	8b 4d a4	 mov	 ecx, DWORD PTR _pMarkers$[ebp]
  0015f	66 89 01	 mov	 WORD PTR [ecx], ax
$L53309:

; 1517 :     }
; 1518 : 
; 1519 :     //
; 1520 :     // Find the loop markers
; 1521 :     //
; 1522 : 
; 1523 :     if(SUCCEEDED(hr))

  00162	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00166	0f 8c ca 00 00
	00		 jl	 $L53311

; 1524 :     {
; 1525 :         pStartMarker = (LPAIFFMARKER)(pMarkers + 1);

  0016c	8b 55 a4	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  0016f	83 c2 02	 add	 edx, 2
  00172	89 55 9c	 mov	 DWORD PTR _pStartMarker$[ebp], edx

; 1526 :         
; 1527 :         for(i = 0; i < pMarkers->wMarkerCount; i++)

  00175	66 c7 45 a2 00
	00		 mov	 WORD PTR _i$[ebp], 0
  0017b	eb 0c		 jmp	 SHORT $L53313
$L53314:
  0017d	66 8b 45 a2	 mov	 ax, WORD PTR _i$[ebp]
  00181	66 05 01 00	 add	 ax, 1
  00185	66 89 45 a2	 mov	 WORD PTR _i$[ebp], ax
$L53313:
  00189	8b 4d a2	 mov	 ecx, DWORD PTR _i$[ebp]
  0018c	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00192	8b 55 a4	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  00195	33 c0		 xor	 eax, eax
  00197	66 8b 02	 mov	 ax, WORD PTR [edx]
  0019a	3b c8		 cmp	 ecx, eax
  0019c	7d 4f		 jge	 SHORT $L53315

; 1528 :         {
; 1529 :             ASSERT((DWORD)pStartMarker < (DWORD)pMarkers + dwMarkerSize);

  0019e	68 f9 05 00 00	 push	 1529			; 000005f9H
  001a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  001a8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DF@PJLL@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@ ; `string'
  001ad	8b 4d a4	 mov	 ecx, DWORD PTR _pMarkers$[ebp]
  001b0	03 4d c8	 add	 ecx, DWORD PTR _dwMarkerSize$[ebp]
  001b3	39 4d 9c	 cmp	 DWORD PTR _pStartMarker$[ebp], ecx
  001b6	1b d2		 sbb	 edx, edx
  001b8	42		 inc	 edx
  001b9	52		 push	 edx
  001ba	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  001bf	83 c4 10	 add	 esp, 16			; 00000010H

; 1530 :             
; 1531 :             if(pStartMarker->wMarkerId == pLoop->wStartMarker)

  001c2	8b 45 9c	 mov	 eax, DWORD PTR _pStartMarker$[ebp]
  001c5	33 c9		 xor	 ecx, ecx
  001c7	66 8b 08	 mov	 cx, WORD PTR [eax]
  001ca	8b 55 c4	 mov	 edx, DWORD PTR _pLoop$[ebp]
  001cd	33 c0		 xor	 eax, eax
  001cf	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  001d3	3b c8		 cmp	 ecx, eax
  001d5	75 02		 jne	 SHORT $L53319

; 1532 :             {
; 1533 :                 break;

  001d7	eb 14		 jmp	 SHORT $L53315
$L53319:

; 1534 :             }
; 1535 : 
; 1536 :             pStartMarker = (LPAIFFMARKER)((LPBYTE)pStartMarker + sizeof(*pStartMarker) + pStartMarker->bNameLength);

  001d9	8b 4d 9c	 mov	 ecx, DWORD PTR _pStartMarker$[ebp]
  001dc	33 d2		 xor	 edx, edx
  001de	8a 51 06	 mov	 dl, BYTE PTR [ecx+6]
  001e1	8b 45 9c	 mov	 eax, DWORD PTR _pStartMarker$[ebp]
  001e4	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  001e8	89 4d 9c	 mov	 DWORD PTR _pStartMarker$[ebp], ecx

; 1537 :         }

  001eb	eb 90		 jmp	 SHORT $L53314
$L53315:

; 1538 : 
; 1539 :         if(i >= pMarkers->wMarkerCount)

  001ed	8b 55 a2	 mov	 edx, DWORD PTR _i$[ebp]
  001f0	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  001f6	8b 45 a4	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  001f9	33 c9		 xor	 ecx, ecx
  001fb	66 8b 08	 mov	 cx, WORD PTR [eax]
  001fe	3b d1		 cmp	 edx, ecx
  00200	7c 34		 jl	 SHORT $L53322

; 1540 :         {
; 1541 :             DPF_ERROR("Can't find loop start marker");

  00202	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  00207	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@ ; `string'
  0020c	68 05 06 00 00	 push	 1541			; 00000605H
  00211	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00216	6a 04		 push	 4
  00218	6a 09		 push	 9
  0021a	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0021f	83 c4 18	 add	 esp, 24			; 00000018H
  00222	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@INFE@Can?8t?5find?5loop?5start?5marker?$AA@ ; `string'
  00227	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0022c	83 c4 04	 add	 esp, 4

; 1542 :             hr = E_FAIL;

  0022f	c7 45 c0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L53322:
$L53311:

; 1543 :         }
; 1544 :     }
; 1545 : 
; 1546 :     if(SUCCEEDED(hr))

  00236	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0023a	0f 8c ca 00 00
	00		 jl	 $L53326

; 1547 :     {
; 1548 :         pEndMarker = (LPAIFFMARKER)(pMarkers + 1);

  00240	8b 55 a4	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  00243	83 c2 02	 add	 edx, 2
  00246	89 55 cc	 mov	 DWORD PTR _pEndMarker$[ebp], edx

; 1549 :         
; 1550 :         for(i = 0; i < pMarkers->wMarkerCount; i++)

  00249	66 c7 45 a2 00
	00		 mov	 WORD PTR _i$[ebp], 0
  0024f	eb 0c		 jmp	 SHORT $L53328
$L53329:
  00251	66 8b 45 a2	 mov	 ax, WORD PTR _i$[ebp]
  00255	66 05 01 00	 add	 ax, 1
  00259	66 89 45 a2	 mov	 WORD PTR _i$[ebp], ax
$L53328:
  0025d	8b 4d a2	 mov	 ecx, DWORD PTR _i$[ebp]
  00260	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00266	8b 55 a4	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  00269	33 c0		 xor	 eax, eax
  0026b	66 8b 02	 mov	 ax, WORD PTR [edx]
  0026e	3b c8		 cmp	 ecx, eax
  00270	7d 4f		 jge	 SHORT $L53330

; 1551 :         {
; 1552 :             ASSERT((DWORD)pEndMarker < (DWORD)pMarkers + dwMarkerSize);

  00272	68 10 06 00 00	 push	 1552			; 00000610H
  00277	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0027c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@DPMK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@ ; `string'
  00281	8b 4d a4	 mov	 ecx, DWORD PTR _pMarkers$[ebp]
  00284	03 4d c8	 add	 ecx, DWORD PTR _dwMarkerSize$[ebp]
  00287	39 4d cc	 cmp	 DWORD PTR _pEndMarker$[ebp], ecx
  0028a	1b d2		 sbb	 edx, edx
  0028c	42		 inc	 edx
  0028d	52		 push	 edx
  0028e	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00293	83 c4 10	 add	 esp, 16			; 00000010H

; 1553 :             
; 1554 :             if(pEndMarker->wMarkerId == pLoop->wEndMarker)

  00296	8b 45 cc	 mov	 eax, DWORD PTR _pEndMarker$[ebp]
  00299	33 c9		 xor	 ecx, ecx
  0029b	66 8b 08	 mov	 cx, WORD PTR [eax]
  0029e	8b 55 c4	 mov	 edx, DWORD PTR _pLoop$[ebp]
  002a1	33 c0		 xor	 eax, eax
  002a3	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  002a7	3b c8		 cmp	 ecx, eax
  002a9	75 02		 jne	 SHORT $L53334

; 1555 :             {
; 1556 :                 break;

  002ab	eb 14		 jmp	 SHORT $L53330
$L53334:

; 1557 :             }
; 1558 : 
; 1559 :             pEndMarker = (LPAIFFMARKER)((LPBYTE)pEndMarker + sizeof(*pEndMarker) + pEndMarker->bNameLength);

  002ad	8b 4d cc	 mov	 ecx, DWORD PTR _pEndMarker$[ebp]
  002b0	33 d2		 xor	 edx, edx
  002b2	8a 51 06	 mov	 dl, BYTE PTR [ecx+6]
  002b5	8b 45 cc	 mov	 eax, DWORD PTR _pEndMarker$[ebp]
  002b8	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  002bc	89 4d cc	 mov	 DWORD PTR _pEndMarker$[ebp], ecx

; 1560 :         }

  002bf	eb 90		 jmp	 SHORT $L53329
$L53330:

; 1561 : 
; 1562 :         if(i >= pMarkers->wMarkerCount)

  002c1	8b 55 a2	 mov	 edx, DWORD PTR _i$[ebp]
  002c4	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  002ca	8b 45 a4	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  002cd	33 c9		 xor	 ecx, ecx
  002cf	66 8b 08	 mov	 cx, WORD PTR [eax]
  002d2	3b d1		 cmp	 edx, ecx
  002d4	7c 34		 jl	 SHORT $L53337

; 1563 :         {
; 1564 :             DPF_ERROR("Can't find loop end marker");

  002d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  002db	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@ ; `string'
  002e0	68 1c 06 00 00	 push	 1564			; 0000061cH
  002e5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  002ea	6a 04		 push	 4
  002ec	6a 09		 push	 9
  002ee	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  002f3	83 c4 18	 add	 esp, 24			; 00000018H
  002f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@IHKN@Can?8t?5find?5loop?5end?5marker?$AA@ ; `string'
  002fb	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00300	83 c4 04	 add	 esp, 4

; 1565 :             hr = E_FAIL;

  00303	c7 45 c0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L53337:
$L53326:

; 1566 :         }
; 1567 :     }
; 1568 : 
; 1569 :     //
; 1570 :     // Double-check the marker validity
; 1571 :     //
; 1572 : 
; 1573 :     if(SUCCEEDED(hr))

  0030a	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0030e	7c 64		 jl	 SHORT $L53341

; 1574 :     {
; 1575 :         pStartMarker->dwPosition = EndianSwapDword(pStartMarker->dwPosition);

  00310	8b 55 9c	 mov	 edx, DWORD PTR _pStartMarker$[ebp]
  00313	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  00316	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  0031b	8b 4d 9c	 mov	 ecx, DWORD PTR _pStartMarker$[ebp]
  0031e	89 41 02	 mov	 DWORD PTR [ecx+2], eax

; 1576 :         pEndMarker->dwPosition = EndianSwapDword(pEndMarker->dwPosition);

  00321	8b 55 cc	 mov	 edx, DWORD PTR _pEndMarker$[ebp]
  00324	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  00327	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  0032c	8b 4d cc	 mov	 ecx, DWORD PTR _pEndMarker$[ebp]
  0032f	89 41 02	 mov	 DWORD PTR [ecx+2], eax

; 1577 : 
; 1578 :         if(pStartMarker->dwPosition >= pEndMarker->dwPosition)

  00332	8b 55 9c	 mov	 edx, DWORD PTR _pStartMarker$[ebp]
  00335	8b 45 cc	 mov	 eax, DWORD PTR _pEndMarker$[ebp]
  00338	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  0033b	3b 48 02	 cmp	 ecx, DWORD PTR [eax+2]
  0033e	72 34		 jb	 SHORT $L53342

; 1579 :         {
; 1580 :             DPF_ERROR("Loop end point less-than-or-equal-to start point");

  00340	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FEMJ@XACTGUI?$AA@ ; `string'
  00345	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@ ; `string'
  0034a	68 2c 06 00 00	 push	 1580			; 0000062cH
  0034f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00354	6a 04		 push	 4
  00356	6a 09		 push	 9
  00358	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0035d	83 c4 18	 add	 esp, 24			; 00000018H
  00360	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@DCLE@Loop?5end?5point?5less?9than?9or?9equa@ ; `string'
  00365	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0036a	83 c4 04	 add	 esp, 4

; 1581 :             hr = E_FAIL;

  0036d	c7 45 c0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L53342:
$L53341:

; 1582 :         }
; 1583 :     }
; 1584 : 
; 1585 :     //
; 1586 :     // Success
; 1587 :     //
; 1588 : 
; 1589 :     if(SUCCEEDED(hr))

  00374	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00378	7c 1c		 jl	 SHORT $L53346

; 1590 :     {
; 1591 :         *pdwLoopStart = pStartMarker->dwPosition;

  0037a	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  0037d	8b 45 9c	 mov	 eax, DWORD PTR _pStartMarker$[ebp]
  00380	8b 48 02	 mov	 ecx, DWORD PTR [eax+2]
  00383	89 0a		 mov	 DWORD PTR [edx], ecx

; 1592 :         *pdwLoopLength = pEndMarker->dwPosition - pStartMarker->dwPosition;

  00385	8b 55 cc	 mov	 edx, DWORD PTR _pEndMarker$[ebp]
  00388	8b 45 9c	 mov	 eax, DWORD PTR _pStartMarker$[ebp]
  0038b	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  0038e	2b 48 02	 sub	 ecx, DWORD PTR [eax+2]
  00391	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  00394	89 0a		 mov	 DWORD PTR [edx], ecx
$L53346:

; 1593 :     }
; 1594 : 
; 1595 :     //
; 1596 :     // Clean up
; 1597 :     //
; 1598 :     
; 1599 :     MEMFREE(pMarkers);

  00396	83 7d a4 00	 cmp	 DWORD PTR _pMarkers$[ebp], 0
  0039a	74 10		 je	 SHORT $L53347
  0039c	8b 45 a4	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  0039f	50		 push	 eax
  003a0	e8 00 00 00 00	 call	 ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPoolFree
  003a5	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _pMarkers$[ebp], 0
$L53347:

; 1600 : 
; 1601 :     DPF_LEAVE_HRESULT(hr);
; 1602 : 
; 1603 :     return hr;

  003ac	8b 4d c0	 mov	 ecx, DWORD PTR _hr$[ebp]
  003af	89 4d 98	 mov	 DWORD PTR $T54184[ebp], ecx
  003b2	8d 4d d0	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  003b5	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  003ba	8d 4d a8	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  003bd	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  003c2	8b 45 98	 mov	 eax, DWORD PTR $T54184[ebp]

; 1604 : }

  003c5	8b e5		 mov	 esp, ebp
  003c7	5d		 pop	 ebp
  003c8	c2 08 00	 ret	 8
?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ENDP ; WaveLoader::CWaveFile::GetAiffLoopRegion
_TEXT	ENDS
PUBLIC	?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CWaveFile::ReadSample
PUBLIC	?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm
; Function compile flags: /Odt
;	COMDAT ?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z
_TEXT	SEGMENT
_dwPosition$ = 8
_pvBuffer$ = 12
_dwBufferSize$ = 16
_pdwRead$ = 20
_this$ = -8
_hr$ = -4
?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z PROC NEAR ; WaveLoader::CWaveFile::ReadSample, COMDAT
; _this$ = ecx

; 1636 : {                                   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1637 :     HRESULT                 hr;
; 1638 : 
; 1639 :     DPF_ENTER();
; 1640 : 
; 1641 :     hr = m_DataChunk.Read(dwPosition, pvBuffer, dwBufferSize, &dwBufferSize);

  00009	8d 45 10	 lea	 eax, DWORD PTR _dwBufferSize$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _dwPosition$[ebp]
  00018	50		 push	 eax
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	83 c1 20	 add	 ecx, 32			; 00000020H
  0001f	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00024	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1642 : 
; 1643 :     if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType))

  00027	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0002b	7c 19		 jl	 SHORT $L53358
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 79 38 01	 cmp	 DWORD PTR [ecx+56], 1
  00034	75 10		 jne	 SHORT $L53358

; 1644 :     {
; 1645 :         ConvertAiffPcm(pvBuffer, dwBufferSize);

  00036	8b 55 10	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  00039	52		 push	 edx
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm
$L53358:

; 1646 :     }
; 1647 : 
; 1648 :     if(SUCCEEDED(hr) && pdwRead)

  00046	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004a	7c 0e		 jl	 SHORT $L53360
  0004c	83 7d 14 00	 cmp	 DWORD PTR _pdwRead$[ebp], 0
  00050	74 08		 je	 SHORT $L53360

; 1649 :     {
; 1650 :         *pdwRead = dwBufferSize;

  00052	8b 4d 14	 mov	 ecx, DWORD PTR _pdwRead$[ebp]
  00055	8b 55 10	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  00058	89 11		 mov	 DWORD PTR [ecx], edx
$L53360:

; 1651 :     }
; 1652 : 
; 1653 :     DPF_LEAVE_HRESULT(hr);
; 1654 : 
; 1655 :     return hr;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1656 : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 10 00	 ret	 16			; 00000010H
?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z ENDP	; WaveLoader::CWaveFile::ReadSample
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Close@CWaveFile@WaveLoader@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Close@CWaveFile@WaveLoader@@QAEXXZ PROC NEAR		; WaveLoader::CWaveFile::Close, COMDAT
; _this$ = ecx

; 1682 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1683 :     DPF_ENTER();
; 1684 : 
; 1685 :     m_Stream.Close();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Close@CStdFileStream@WaveLoader@@QAEXXZ ; WaveLoader::CStdFileStream::Close

; 1686 : 
; 1687 :     MEMFREE(m_pwfxFormat);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00016	74 16		 je	 SHORT $L53365
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPoolFree
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
$L53365:

; 1688 : 
; 1689 :     DPF_LEAVE_VOID();
; 1690 : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?Close@CWaveFile@WaveLoader@@QAEXXZ ENDP		; WaveLoader::CWaveFile::Close
_TEXT	ENDS
PUBLIC	?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm
PUBLIC	??_C@_0CM@CGPO@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@ ; `string'
;	COMDAT ??_C@_0CM@CGPO@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@
CONST	SEGMENT
??_C@_0CM@CGPO@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@ DB 'WAVE_FORMAT'
	DB	'_PCM == m_pwfxFormat->wFormatTag', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z
_TEXT	SEGMENT
_pvSource$ = 8
_cbSource$ = 12
_this$ = -12
?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z PROC NEAR ; WaveLoader::CWaveFile::ConvertAiffPcm, COMDAT
; _this$ = ecx

; 1718 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1719 :     BYTE *                  pbSource;
; 1720 :     BYTE                    bTemp;
; 1721 : 
; 1722 :     DPF_ENTER();
; 1723 : 
; 1724 :     ASSERT(m_pwfxFormat);

  00009	68 bc 06 00 00	 push	 1724			; 000006bcH
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@OAHJ@m_pwfxFormat?$AA@ ; `string'
  00018	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	33 c9		 xor	 ecx, ecx
  0001d	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00021	0f 94 c1	 sete	 cl
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 1725 :     ASSERT(WAVE_FORMAT_PCM == m_pwfxFormat->wFormatTag);

  0002d	68 bd 06 00 00	 push	 1725			; 000006bdH
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@CGPO@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@ ; `string'
  0003c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00042	33 c9		 xor	 ecx, ecx
  00044	66 8b 08	 mov	 cx, WORD PTR [eax]
  00047	83 e9 01	 sub	 ecx, 1
  0004a	f7 d9		 neg	 ecx
  0004c	1b c9		 sbb	 ecx, ecx
  0004e	f7 d9		 neg	 ecx
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00056	83 c4 10	 add	 esp, 16			; 00000010H

; 1726 : 
; 1727 :     ConvertAiffPcm(pvSource, cbSource, m_pwfxFormat->wBitsPerSample);

  00059	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0005f	33 c9		 xor	 ecx, ecx
  00061	66 8b 48 0e	 mov	 cx, WORD PTR [eax+14]
  00065	51		 push	 ecx
  00066	8b 55 0c	 mov	 edx, DWORD PTR _cbSource$[ebp]
  00069	52		 push	 edx
  0006a	8b 45 08	 mov	 eax, DWORD PTR _pvSource$[ebp]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm

; 1728 : 
; 1729 :     DPF_LEAVE_VOID();
; 1730 : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 08 00	 ret	 8
?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z ENDP	; WaveLoader::CWaveFile::ConvertAiffPcm
_TEXT	ENDS
PUBLIC	??_C@_0BA@GOLD@8?5?$DN?$DN?5dwBitDepth?$AA@	; `string'
;	COMDAT ??_C@_0BA@GOLD@8?5?$DN?$DN?5dwBitDepth?$AA@
CONST	SEGMENT
??_C@_0BA@GOLD@8?5?$DN?$DN?5dwBitDepth?$AA@ DB '8 == dwBitDepth', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z
_TEXT	SEGMENT
_pvSource$ = 8
_cbSource$ = 12
_dwBitDepth$ = 16
_pbSource$ = -4
_pwSource$ = -12
?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z PROC NEAR ; WaveLoader::CWaveFile::ConvertAiffPcm, COMDAT

; 1760 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1761 :     BYTE *                  pbSource;
; 1762 :     WORD *                  pwSource;
; 1763 :     BYTE                    bTemp;
; 1764 : 
; 1765 :     DPF_ENTER();
; 1766 : 
; 1767 :     if(16 == dwBitDepth)

  00006	83 7d 10 10	 cmp	 DWORD PTR _dwBitDepth$[ebp], 16 ; 00000010H
  0000a	75 3d		 jne	 SHORT $L53382

; 1768 :     {
; 1769 :         cbSource /= 2;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _cbSource$[ebp]
  0000f	d1 e8		 shr	 eax, 1
  00011	89 45 0c	 mov	 DWORD PTR _cbSource$[ebp], eax

; 1770 :         
; 1771 :         for(pwSource = (WORD *)pvSource; cbSource; cbSource--, pwSource++)

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pvSource$[ebp]
  00017	89 4d f4	 mov	 DWORD PTR _pwSource$[ebp], ecx
  0001a	eb 12		 jmp	 SHORT $L53384
$L53385:
  0001c	8b 55 0c	 mov	 edx, DWORD PTR _cbSource$[ebp]
  0001f	83 ea 01	 sub	 edx, 1
  00022	89 55 0c	 mov	 DWORD PTR _cbSource$[ebp], edx
  00025	8b 45 f4	 mov	 eax, DWORD PTR _pwSource$[ebp]
  00028	83 c0 02	 add	 eax, 2
  0002b	89 45 f4	 mov	 DWORD PTR _pwSource$[ebp], eax
$L53384:
  0002e	83 7d 0c 00	 cmp	 DWORD PTR _cbSource$[ebp], 0
  00032	74 13		 je	 SHORT $L53386

; 1772 :         {
; 1773 :             *pwSource = EndianSwapWord(*pwSource);

  00034	8b 4d f4	 mov	 ecx, DWORD PTR _pwSource$[ebp]
  00037	66 8b 09	 mov	 cx, WORD PTR [ecx]
  0003a	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0003f	8b 55 f4	 mov	 edx, DWORD PTR _pwSource$[ebp]
  00042	66 89 02	 mov	 WORD PTR [edx], ax

; 1774 :         }

  00045	eb d5		 jmp	 SHORT $L53385
$L53386:

; 1775 :     }
; 1776 :     else

  00047	eb 55		 jmp	 SHORT $L53387
$L53382:

; 1777 :     {
; 1778 :         ASSERT(8 == dwBitDepth);

  00049	68 f2 06 00 00	 push	 1778			; 000006f2H
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@GOLD@8?5?$DN?$DN?5dwBitDepth?$AA@ ; `string'
  00058	33 c0		 xor	 eax, eax
  0005a	83 7d 10 08	 cmp	 DWORD PTR _dwBitDepth$[ebp], 8
  0005e	0f 95 c0	 setne	 al
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00067	83 c4 10	 add	 esp, 16			; 00000010H

; 1779 :         
; 1780 :         for(pbSource = (BYTE *)pvSource; cbSource; cbSource--, pbSource++)

  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _pvSource$[ebp]
  0006d	89 4d fc	 mov	 DWORD PTR _pbSource$[ebp], ecx
  00070	eb 12		 jmp	 SHORT $L53390
$L53391:
  00072	8b 55 0c	 mov	 edx, DWORD PTR _cbSource$[ebp]
  00075	83 ea 01	 sub	 edx, 1
  00078	89 55 0c	 mov	 DWORD PTR _cbSource$[ebp], edx
  0007b	8b 45 fc	 mov	 eax, DWORD PTR _pbSource$[ebp]
  0007e	83 c0 01	 add	 eax, 1
  00081	89 45 fc	 mov	 DWORD PTR _pbSource$[ebp], eax
$L53390:
  00084	83 7d 0c 00	 cmp	 DWORD PTR _cbSource$[ebp], 0
  00088	74 14		 je	 SHORT $L53392

; 1781 :         {
; 1782 :             *pbSource = *pbSource + 0x80;

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _pbSource$[ebp]
  0008d	33 d2		 xor	 edx, edx
  0008f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00091	81 c2 80 00 00
	00		 add	 edx, 128		; 00000080H
  00097	8b 45 fc	 mov	 eax, DWORD PTR _pbSource$[ebp]
  0009a	88 10		 mov	 BYTE PTR [eax], dl

; 1783 :         }

  0009c	eb d4		 jmp	 SHORT $L53391
$L53392:
$L53387:

; 1784 :     }
; 1785 : 
; 1786 :     DPF_LEAVE_VOID();
; 1787 : }

  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 0c 00	 ret	 12			; 0000000cH
?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z ENDP	; WaveLoader::CWaveFile::ConvertAiffPcm
_TEXT	ENDS
PUBLIC	??0CImaAdpcmCodec@DirectSound@@QAE@XZ		; DirectSound::CImaAdpcmCodec::CImaAdpcmCodec
PUBLIC	??_7CImaAdpcmCodec@DirectSound@@6B@		; DirectSound::CImaAdpcmCodec::`vftable'
PUBLIC	??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z	; DirectSound::CImaAdpcmCodec::`scalar deleting destructor'
PUBLIC	??_ECImaAdpcmCodec@DirectSound@@UAEPAXI@Z	; DirectSound::CImaAdpcmCodec::`vector deleting destructor'
;	COMDAT ??_7CImaAdpcmCodec@DirectSound@@6B@
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
CONST	SEGMENT
??_7CImaAdpcmCodec@DirectSound@@6B@ DD FLAT:??_ECImaAdpcmCodec@DirectSound@@UAEPAXI@Z ; DirectSound::CImaAdpcmCodec::`vftable'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CImaAdpcmCodec@DirectSound@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CImaAdpcmCodec@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CImaAdpcmCodec::CImaAdpcmCodec, COMDAT
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CImaAdpcmCodec@DirectSound@@6B@ ; DirectSound::CImaAdpcmCodec::`vftable'

; 70   : }

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0CImaAdpcmCodec@DirectSound@@QAE@XZ ENDP		; DirectSound::CImaAdpcmCodec::CImaAdpcmCodec
_TEXT	ENDS
PUBLIC	??1CImaAdpcmCodec@DirectSound@@UAE@XZ		; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec
; Function compile flags: /Odt
;	COMDAT ??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z PROC NEAR	; DirectSound::CImaAdpcmCodec::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CImaAdpcmCodec@DirectSound@@UAE@XZ ; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L53402
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L53402:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z ENDP		; DirectSound::CImaAdpcmCodec::`scalar deleting destructor'
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\memmgr.h
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 244  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  :     DirectSound::CMemoryManager::TrackingMemFree(pvBuffer); 

  00003	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPoolFree

; 246  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
_TEXT	ENDS
;	COMDAT ??1CImaAdpcmCodec@DirectSound@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CImaAdpcmCodec@DirectSound@@UAE@XZ PROC NEAR		; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec, COMDAT
; _this$ = ecx

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CImaAdpcmCodec@DirectSound@@6B@ ; DirectSound::CImaAdpcmCodec::`vftable'

; 93   : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1CImaAdpcmCodec@DirectSound@@UAE@XZ ENDP		; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec
_TEXT	ENDS
PUBLIC	?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z ; DirectSound::CImaAdpcmCodec::Initialize
PUBLIC	?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUima_adpcmwaveformat_tag@@@Z ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat
PUBLIC	?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::EncodeM16
PUBLIC	?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::EncodeS16
PUBLIC	?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::DecodeM16
PUBLIC	?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::DecodeS16
_BSS	SEGMENT
?$S26@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4EA DB 01H DUP (?) ; `DirectSound::CImaAdpcmCodec::Initialize'::`2'::$S26
; Function compile flags: /Odt
_BSS	ENDS
;	COMDAT ?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z
_TEXT	SEGMENT
_pwfxEncode$ = 8
_fEncoder$ = 12
_this$ = -4
?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::Initialize, COMDAT
; _this$ = ecx

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  :     static const LPFNIMAADPCMCONVERT    apfnConvert[2][2] = 
; 120  :     { 
; 121  :         {
; 122  :             DecodeM16,

  00009	33 c0		 xor	 eax, eax
  0000b	a0 00 00 00 00	 mov	 al, BYTE PTR ?$S26@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4EA
  00010	83 e0 01	 and	 eax, 1
  00013	85 c0		 test	 eax, eax
  00015	75 67		 jne	 SHORT $L53416
  00017	33 c9		 xor	 ecx, ecx
  00019	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?$S26@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4EA
  0001f	83 c9 01	 or	 ecx, 1
  00022	88 0d 00 00 00
	00		 mov	 BYTE PTR ?$S26@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4EA, cl
  00028	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA, OFFSET FLAT:?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::DecodeM16
  00032	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA
  00038	89 15 00 00 00
	00		 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA, edx

; 123  :             DecodeS16 
; 124  :         },

  0003e	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+4, OFFSET FLAT:?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::DecodeS16
  00048	a1 04 00 00 00	 mov	 eax, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+4
  0004d	a3 04 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+4, eax

; 125  :         {
; 126  :             EncodeM16,

  00052	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+8, OFFSET FLAT:?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::EncodeM16
  0005c	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+8
  00062	89 0d 08 00 00
	00		 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+8, ecx

; 127  :             EncodeS16 
; 128  :         }

  00068	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+12, OFFSET FLAT:?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::EncodeS16
  00072	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+12
  00078	89 15 0c 00 00
	00		 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+12, edx
$L53416:

; 129  :     };
; 130  :     
; 131  :     if(!IsValidImaAdpcmFormat(pwfxEncode))

  0007e	8b 45 08	 mov	 eax, DWORD PTR _pwfxEncode$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUima_adpcmwaveformat_tag@@@Z ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat
  00087	85 c0		 test	 eax, eax
  00089	75 04		 jne	 SHORT $L53417

; 132  :     {
; 133  :         return FALSE;

  0008b	33 c0		 xor	 eax, eax
  0008d	eb 5b		 jmp	 SHORT $L53411
$L53417:

; 134  :     }
; 135  : 
; 136  :     //
; 137  :     // Save the format data
; 138  :     //
; 139  : 
; 140  :     m_wfxEncode = *pwfxEncode;

  0008f	8b 75 08	 mov	 esi, DWORD PTR _pwfxEncode$[ebp]
  00092	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  00095	83 c7 04	 add	 edi, 4
  00098	b9 05 00 00 00	 mov	 ecx, 5
  0009d	f3 a5		 rep movsd

; 141  :     m_fEncoder = !!fEncoder;

  0009f	33 c9		 xor	 ecx, ecx
  000a1	83 7d 0c 00	 cmp	 DWORD PTR _fEncoder$[ebp], 0
  000a5	0f 95 c1	 setne	 cl
  000a8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ab	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 142  : 
; 143  :     //
; 144  :     // Set up the conversion function
; 145  :     //
; 146  : 
; 147  :     m_pfnConvert = apfnConvert[m_fEncoder][m_wfxEncode.wfx.nChannels - 1];

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000b4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b7	33 c0		 xor	 eax, eax
  000b9	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  000bd	8d 14 85 fc ff
	ff ff		 lea	 edx, DWORD PTR [eax*4-4]
  000c4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	8b 8c ca 00 00
	00 00		 mov	 ecx, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA[edx+ecx*8]
  000ce	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 148  : 
; 149  :     //
; 150  :     // Initialize the stepping indeces
; 151  :     //
; 152  : 
; 153  :     m_nStepIndexL = m_nStepIndexR = 0;

  000d1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d4	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
  000db	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000de	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 154  : 
; 155  :     return TRUE;

  000e5	b8 01 00 00 00	 mov	 eax, 1
$L53411:

; 156  : }

  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c2 08 00	 ret	 8
?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z ENDP ; DirectSound::CImaAdpcmCodec::Initialize
_TEXT	ENDS
PUBLIC	?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z ; DirectSound::CImaAdpcmCodec::Convert
; Function compile flags: /Odt
;	COMDAT ?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z
_TEXT	SEGMENT
_pvSrc$ = 8
_pvDst$ = 12
_cBlocks$ = 16
_this$ = -4
?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::Convert, COMDAT
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  :     return m_pfnConvert((LPBYTE)pvSrc, (LPBYTE)pvDst, cBlocks, m_wfxEncode.wfx.nBlockAlign, m_wfxEncode.wSamplesPerBlock, &m_nStepIndexL, &m_nStepIndexR);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 20	 add	 eax, 32			; 00000020H
  0000d	50		 push	 eax
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00014	51		 push	 ecx
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	33 c0		 xor	 eax, eax
  0001a	66 8b 42 16	 mov	 ax, WORD PTR [edx+22]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	33 d2		 xor	 edx, edx
  00024	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  00028	52		 push	 edx
  00029	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _pvDst$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR _pvSrc$[ebp]
  00034	52		 push	 edx
  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	ff 50 24	 call	 DWORD PTR [eax+36]

; 185  : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z ENDP	; DirectSound::CImaAdpcmCodec::Convert
_TEXT	ENDS
PUBLIC	?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ	; DirectSound::CImaAdpcmCodec::Reset
; Function compile flags: /Odt
;	COMDAT ?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ PROC NEAR	; DirectSound::CImaAdpcmCodec::Reset, COMDAT
; _this$ = ecx

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 209  :     //
; 210  :     // Reset the stepping indeces
; 211  :     //
; 212  : 
; 213  :     m_nStepIndexL = m_nStepIndexR = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 214  : }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ ENDP		; DirectSound::CImaAdpcmCodec::Reset
_TEXT	ENDS
PUBLIC	?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ; DirectSound::CImaAdpcmCodec::GetEncodeAlignment
; Function compile flags: /Odt
;	COMDAT ?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4
?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ PROC NEAR ; DirectSound::CImaAdpcmCodec::GetEncodeAlignment, COMDAT
; _this$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 238  :     return m_wfxEncode.wfx.nBlockAlign;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 40 10	 mov	 ax, WORD PTR [eax+16]

; 239  : }

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ENDP ; DirectSound::CImaAdpcmCodec::GetEncodeAlignment
_TEXT	ENDS
PUBLIC	?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ; DirectSound::CImaAdpcmCodec::GetDecodeAlignment
; Function compile flags: /Odt
;	COMDAT ?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4
?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ PROC NEAR ; DirectSound::CImaAdpcmCodec::GetDecodeAlignment, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 263  :     return m_wfxEncode.wSamplesPerBlock * m_wfxEncode.wfx.nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 48 16	 mov	 cx, WORD PTR [eax+22]
  00010	8b c1		 mov	 eax, ecx
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	33 c9		 xor	 ecx, ecx
  00017	66 8b 4a 06	 mov	 cx, WORD PTR [edx+6]
  0001b	0f af c1	 imul	 eax, ecx
  0001e	c1 e0 04	 shl	 eax, 4
  00021	99		 cdq
  00022	83 e2 07	 and	 edx, 7
  00025	03 c2		 add	 eax, edx
  00027	c1 f8 03	 sar	 eax, 3

; 264  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ENDP ; DirectSound::CImaAdpcmCodec::GetDecodeAlignment
_TEXT	ENDS
PUBLIC	?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
; Function compile flags: /Odt
;	COMDAT ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerBlock$ = 12
_nEncodedSampleBits$ = -2
_nHeaderBytes$ = -4
_nBlockAlign$ = -6
?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment, COMDAT

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 291  :     const WORD              nEncodedSampleBits  = nChannels * IMAADPCM_BITS_PER_SAMPLE;

  00006	8b 45 08	 mov	 eax, DWORD PTR _nChannels$[ebp]
  00009	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000e	c1 e0 02	 shl	 eax, 2
  00011	66 89 45 fe	 mov	 WORD PTR _nEncodedSampleBits$[ebp], ax

; 292  :     const WORD              nHeaderBytes        = nChannels * IMAADPCM_HEADER_LENGTH;

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _nChannels$[ebp]
  00018	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001e	c1 e1 02	 shl	 ecx, 2
  00021	66 89 4d fc	 mov	 WORD PTR _nHeaderBytes$[ebp], cx

; 293  :     WORD                    nBlockAlign;
; 294  : 
; 295  :     //
; 296  :     // Calculate the raw block alignment that nSamplesPerBlock dictates.  This
; 297  :     // value may include a partial encoded sample, so be sure to round up.
; 298  :     //
; 299  :     // Start with the samples-per-block, minus 1.  The first sample is actually
; 300  :     // stored in the header.
; 301  :     //
; 302  : 
; 303  :     nBlockAlign = nSamplesPerBlock - 1;

  00025	8b 55 0c	 mov	 edx, DWORD PTR _nSamplesPerBlock$[ebp]
  00028	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0002e	83 ea 01	 sub	 edx, 1
  00031	66 89 55 fa	 mov	 WORD PTR _nBlockAlign$[ebp], dx

; 304  : 
; 305  :     //
; 306  :     // Convert to encoded sample size
; 307  :     //
; 308  : 
; 309  :     nBlockAlign *= nEncodedSampleBits;

  00035	8b 45 fe	 mov	 eax, DWORD PTR _nEncodedSampleBits$[ebp]
  00038	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003d	8b 4d fa	 mov	 ecx, DWORD PTR _nBlockAlign$[ebp]
  00040	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00046	0f af c8	 imul	 ecx, eax
  00049	66 89 4d fa	 mov	 WORD PTR _nBlockAlign$[ebp], cx

; 310  :     nBlockAlign += 7;

  0004d	8b 55 fa	 mov	 edx, DWORD PTR _nBlockAlign$[ebp]
  00050	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00056	83 c2 07	 add	 edx, 7
  00059	66 89 55 fa	 mov	 WORD PTR _nBlockAlign$[ebp], dx

; 311  :     nBlockAlign /= 8;

  0005d	8b 45 fa	 mov	 eax, DWORD PTR _nBlockAlign$[ebp]
  00060	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00065	99		 cdq
  00066	83 e2 07	 and	 edx, 7
  00069	03 c2		 add	 eax, edx
  0006b	c1 f8 03	 sar	 eax, 3
  0006e	66 89 45 fa	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 312  : 
; 313  :     //
; 314  :     // The stereo encoder requires that there be at least two DWORDs to process
; 315  :     //
; 316  : 
; 317  :     nBlockAlign += 7;

  00072	8b 45 fa	 mov	 eax, DWORD PTR _nBlockAlign$[ebp]
  00075	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0007a	83 c0 07	 add	 eax, 7
  0007d	66 89 45 fa	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 318  :     nBlockAlign /= 8;

  00081	8b 45 fa	 mov	 eax, DWORD PTR _nBlockAlign$[ebp]
  00084	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00089	99		 cdq
  0008a	83 e2 07	 and	 edx, 7
  0008d	03 c2		 add	 eax, edx
  0008f	c1 f8 03	 sar	 eax, 3
  00092	66 89 45 fa	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 319  :     nBlockAlign *= 8;

  00096	8b 4d fa	 mov	 ecx, DWORD PTR _nBlockAlign$[ebp]
  00099	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0009f	c1 e1 03	 shl	 ecx, 3
  000a2	66 89 4d fa	 mov	 WORD PTR _nBlockAlign$[ebp], cx

; 320  : 
; 321  :     //
; 322  :     // Add the header
; 323  :     //
; 324  : 
; 325  :     nBlockAlign += nHeaderBytes;

  000a6	8b 55 fc	 mov	 edx, DWORD PTR _nHeaderBytes$[ebp]
  000a9	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000af	8b 45 fa	 mov	 eax, DWORD PTR _nBlockAlign$[ebp]
  000b2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000b7	03 c2		 add	 eax, edx
  000b9	66 89 45 fa	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 326  : 
; 327  :     return nBlockAlign;

  000bd	66 8b 45 fa	 mov	 ax, WORD PTR _nBlockAlign$[ebp]

; 328  : }

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 08 00	 ret	 8
?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ENDP ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
_TEXT	ENDS
PUBLIC	?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z ; DirectSound::CImaAdpcmCodec::CreatePcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_pwfx$ = 16
?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::CreatePcmFormat, COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  :     pwfx->wFormatTag = WAVE_FORMAT_PCM;

  00003	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	66 c7 00 01 00	 mov	 WORD PTR [eax], 1

; 357  :     pwfx->nChannels = nChannels;

  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0000e	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  00012	66 89 51 02	 mov	 WORD PTR [ecx+2], dx

; 358  :     pwfx->nSamplesPerSec = nSamplesPerSec;

  00016	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0001c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 359  :     pwfx->nBlockAlign = nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _nChannels$[ebp]
  00022	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00027	c1 e0 04	 shl	 eax, 4
  0002a	99		 cdq
  0002b	83 e2 07	 and	 edx, 7
  0002e	03 c2		 add	 eax, edx
  00030	c1 f8 03	 sar	 eax, 3
  00033	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00036	66 89 42 0c	 mov	 WORD PTR [edx+12], ax

; 360  :     pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;

  0003a	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0003d	33 c9		 xor	 ecx, ecx
  0003f	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  00043	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00046	0f af 4a 04	 imul	 ecx, DWORD PTR [edx+4]
  0004a	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0004d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 361  :     pwfx->wBitsPerSample = IMAADPCM_PCM_BITS_PER_SAMPLE;

  00050	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00053	66 c7 41 0e 10
	00		 mov	 WORD PTR [ecx+14], 16	; 00000010H

; 362  : }

  00059	5d		 pop	 ebp
  0005a	c2 0c 00	 ret	 12			; 0000000cH
?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z ENDP ; DirectSound::CImaAdpcmCodec::CreatePcmFormat
_TEXT	ENDS
PUBLIC	?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z ; DirectSound::CImaAdpcmCodec::CreateImaAdpcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_nSamplesPerBlock$ = 16
_pwfx$ = 20
?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::CreateImaAdpcmFormat, COMDAT

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 391  :     pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  00004	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00007	66 c7 00 69 00	 mov	 WORD PTR [eax], 105	; 00000069H

; 392  :     pwfx->wfx.nChannels = nChannels;

  0000c	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0000f	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  00013	66 89 51 02	 mov	 WORD PTR [ecx+2], dx

; 393  :     pwfx->wfx.nSamplesPerSec = nSamplesPerSec;

  00017	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0001d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 394  :     pwfx->wfx.nBlockAlign = CalculateEncodeAlignment(nChannels, nSamplesPerBlock);

  00020	66 8b 55 10	 mov	 dx, WORD PTR _nSamplesPerBlock$[ebp]
  00024	52		 push	 edx
  00025	66 8b 45 08	 mov	 ax, WORD PTR _nChannels$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
  0002f	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00032	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 395  :     pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec * pwfx->wfx.nBlockAlign / nSamplesPerBlock;

  00036	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00039	33 c0		 xor	 eax, eax
  0003b	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  00042	0f af c8	 imul	 ecx, eax
  00045	8b 75 10	 mov	 esi, DWORD PTR _nSamplesPerBlock$[ebp]
  00048	81 e6 ff ff 00
	00		 and	 esi, 65535		; 0000ffffH
  0004e	8b c1		 mov	 eax, ecx
  00050	33 d2		 xor	 edx, edx
  00052	f7 f6		 div	 esi
  00054	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00057	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 396  :     pwfx->wfx.wBitsPerSample = IMAADPCM_BITS_PER_SAMPLE;

  0005a	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0005d	66 c7 40 0e 04
	00		 mov	 WORD PTR [eax+14], 4

; 397  :     pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);

  00063	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00066	66 c7 41 10 02
	00		 mov	 WORD PTR [ecx+16], 2

; 398  :     pwfx->wSamplesPerBlock = nSamplesPerBlock;

  0006c	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0006f	66 8b 45 10	 mov	 ax, WORD PTR _nSamplesPerBlock$[ebp]
  00073	66 89 42 12	 mov	 WORD PTR [edx+18], ax

; 399  : }

  00077	5e		 pop	 esi
  00078	5d		 pop	 ebp
  00079	c2 10 00	 ret	 16			; 00000010H
?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::CImaAdpcmCodec::CreateImaAdpcmFormat
_TEXT	ENDS
PUBLIC	?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z ; DirectSound::CImaAdpcmCodec::IsValidPcmFormat
; Function compile flags: /Odt
;	COMDAT ?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_pwfx$ = 8
?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::IsValidPcmFormat, COMDAT

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 423  :     if(WAVE_FORMAT_PCM != pwfx->wFormatTag)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000b	83 f9 01	 cmp	 ecx, 1
  0000e	74 07		 je	 SHORT $L53459

; 424  :     {
; 425  :         return FALSE;

  00010	33 c0		 xor	 eax, eax
  00012	e9 82 00 00 00	 jmp	 $L53458
$L53459:

; 426  :     }
; 427  :     
; 428  :     if((pwfx->nChannels < 1) || (pwfx->nChannels > IMAADPCM_MAX_CHANNELS))

  00017	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0001a	33 c0		 xor	 eax, eax
  0001c	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00020	83 f8 01	 cmp	 eax, 1
  00023	7c 0e		 jl	 SHORT $L53461
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00028	33 d2		 xor	 edx, edx
  0002a	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  0002e	83 fa 02	 cmp	 edx, 2
  00031	7e 04		 jle	 SHORT $L53460
$L53461:

; 429  :     {
; 430  :         return FALSE;

  00033	33 c0		 xor	 eax, eax
  00035	eb 62		 jmp	 SHORT $L53458
$L53460:

; 431  :     }
; 432  : 
; 433  :     if(IMAADPCM_PCM_BITS_PER_SAMPLE != pwfx->wBitsPerSample)

  00037	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0003a	33 c9		 xor	 ecx, ecx
  0003c	66 8b 48 0e	 mov	 cx, WORD PTR [eax+14]
  00040	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00043	74 04		 je	 SHORT $L53462

; 434  :     {
; 435  :         return FALSE;

  00045	33 c0		 xor	 eax, eax
  00047	eb 50		 jmp	 SHORT $L53458
$L53462:

; 436  :     }
; 437  : 
; 438  :     if(pwfx->nChannels * pwfx->wBitsPerSample / 8 != pwfx->nBlockAlign)

  00049	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0004c	33 c0		 xor	 eax, eax
  0004e	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00055	33 d2		 xor	 edx, edx
  00057	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  0005b	0f af c2	 imul	 eax, edx
  0005e	99		 cdq
  0005f	83 e2 07	 and	 edx, 7
  00062	03 c2		 add	 eax, edx
  00064	c1 f8 03	 sar	 eax, 3
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0006a	33 d2		 xor	 edx, edx
  0006c	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  00070	3b c2		 cmp	 eax, edx
  00072	74 04		 je	 SHORT $L53463

; 439  :     {
; 440  :         return FALSE;

  00074	33 c0		 xor	 eax, eax
  00076	eb 21		 jmp	 SHORT $L53458
$L53463:

; 441  :     }
; 442  : 
; 443  :     if(pwfx->nBlockAlign * pwfx->nSamplesPerSec != pwfx->nAvgBytesPerSec)

  00078	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0007b	33 c9		 xor	 ecx, ecx
  0007d	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  00081	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00084	0f af 4a 04	 imul	 ecx, DWORD PTR [edx+4]
  00088	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0008b	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0008e	74 04		 je	 SHORT $L53464

; 444  :     {
; 445  :         return FALSE;

  00090	33 c0		 xor	 eax, eax
  00092	eb 05		 jmp	 SHORT $L53458
$L53464:

; 446  :     }
; 447  : 
; 448  :     return TRUE;

  00094	b8 01 00 00 00	 mov	 eax, 1
$L53458:

; 449  : }

  00099	5d		 pop	 ebp
  0009a	c2 04 00	 ret	 4
?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::CImaAdpcmCodec::IsValidPcmFormat
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT
_pwfx$ = 8
?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUima_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat, COMDAT

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 473  :     if(WAVE_FORMAT_XBOX_ADPCM != pwfx->wfx.wFormatTag)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000b	83 f9 69	 cmp	 ecx, 105		; 00000069H
  0000e	74 04		 je	 SHORT $L53468

; 474  :     {
; 475  :         return FALSE;

  00010	33 c0		 xor	 eax, eax
  00012	eb 74		 jmp	 SHORT $L53467
$L53468:

; 476  :     }
; 477  : 
; 478  :     if(sizeof(*pwfx) - sizeof(pwfx->wfx) != pwfx->wfx.cbSize)

  00014	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00017	33 c0		 xor	 eax, eax
  00019	66 8b 42 10	 mov	 ax, WORD PTR [edx+16]
  0001d	83 f8 02	 cmp	 eax, 2
  00020	74 04		 je	 SHORT $L53469

; 479  :     {
; 480  :         return FALSE;

  00022	33 c0		 xor	 eax, eax
  00024	eb 62		 jmp	 SHORT $L53467
$L53469:

; 481  :     }
; 482  :     
; 483  :     if((pwfx->wfx.nChannels < 1) || (pwfx->wfx.nChannels > IMAADPCM_MAX_CHANNELS))

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00029	33 d2		 xor	 edx, edx
  0002b	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  0002f	83 fa 01	 cmp	 edx, 1
  00032	7c 0e		 jl	 SHORT $L53471
  00034	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00037	33 c9		 xor	 ecx, ecx
  00039	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0003d	83 f9 02	 cmp	 ecx, 2
  00040	7e 04		 jle	 SHORT $L53470
$L53471:

; 484  :     {
; 485  :         return FALSE;

  00042	33 c0		 xor	 eax, eax
  00044	eb 42		 jmp	 SHORT $L53467
$L53470:

; 486  :     }
; 487  : 
; 488  :     if(IMAADPCM_BITS_PER_SAMPLE != pwfx->wfx.wBitsPerSample)

  00046	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00049	33 c0		 xor	 eax, eax
  0004b	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  0004f	83 f8 04	 cmp	 eax, 4
  00052	74 04		 je	 SHORT $L53472

; 489  :     {
; 490  :         return FALSE;

  00054	33 c0		 xor	 eax, eax
  00056	eb 30		 jmp	 SHORT $L53467
$L53472:

; 491  :     }
; 492  : 
; 493  :     if(CalculateEncodeAlignment(pwfx->wfx.nChannels, pwfx->wSamplesPerBlock) != pwfx->wfx.nBlockAlign)

  00058	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0005b	66 8b 51 12	 mov	 dx, WORD PTR [ecx+18]
  0005f	52		 push	 edx
  00060	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00063	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
  0006d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00072	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00075	33 c9		 xor	 ecx, ecx
  00077	66 8b 4a 0c	 mov	 cx, WORD PTR [edx+12]
  0007b	3b c1		 cmp	 eax, ecx
  0007d	74 04		 je	 SHORT $L53473

; 494  :     {
; 495  :         return FALSE;

  0007f	33 c0		 xor	 eax, eax
  00081	eb 05		 jmp	 SHORT $L53467
$L53473:

; 496  :     }
; 497  : 
; 498  :     return TRUE;

  00083	b8 01 00 00 00	 mov	 eax, 1
$L53467:

; 499  : }

  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUima_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat
_TEXT	ENDS
PUBLIC	?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
; Function compile flags: /Odt
;	COMDAT ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z
_TEXT	SEGMENT
_nInputSample$ = 8
_pnPredictedSample$ = 12
_nStepSize$ = 16
_nPredictedSample$ = -12
_lDifference$ = -8
_nEncodedSample$ = -4
?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::EncodeSample, COMDAT

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 527  :     int                 nPredictedSample;
; 528  :     LONG                lDifference;
; 529  :     int                 nEncodedSample;
; 530  :     
; 531  :     nPredictedSample = *pnPredictedSample;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _pnPredictedSample$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d f4	 mov	 DWORD PTR _nPredictedSample$[ebp], ecx

; 532  : 
; 533  :     lDifference = nInputSample - nPredictedSample;

  0000e	8b 55 08	 mov	 edx, DWORD PTR _nInputSample$[ebp]
  00011	2b 55 f4	 sub	 edx, DWORD PTR _nPredictedSample$[ebp]
  00014	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx

; 534  :     nEncodedSample = 0;

  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nEncodedSample$[ebp], 0

; 535  : 
; 536  :     if(lDifference < 0) 

  0001e	83 7d f8 00	 cmp	 DWORD PTR _lDifference$[ebp], 0
  00022	7d 0f		 jge	 SHORT $L53482

; 537  :     {
; 538  :         nEncodedSample = 8;

  00024	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR _nEncodedSample$[ebp], 8

; 539  :         lDifference = -lDifference;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _lDifference$[ebp]
  0002e	f7 d8		 neg	 eax
  00030	89 45 f8	 mov	 DWORD PTR _lDifference$[ebp], eax
$L53482:

; 540  :     }
; 541  : 
; 542  :     if(lDifference >= nStepSize)

  00033	8b 4d f8	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  00036	3b 4d 10	 cmp	 ecx, DWORD PTR _nStepSize$[ebp]
  00039	7c 12		 jl	 SHORT $L53483

; 543  :     {
; 544  :         nEncodedSample |= 4;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _nEncodedSample$[ebp]
  0003e	83 ca 04	 or	 edx, 4
  00041	89 55 fc	 mov	 DWORD PTR _nEncodedSample$[ebp], edx

; 545  :         lDifference -= nStepSize;

  00044	8b 45 f8	 mov	 eax, DWORD PTR _lDifference$[ebp]
  00047	2b 45 10	 sub	 eax, DWORD PTR _nStepSize$[ebp]
  0004a	89 45 f8	 mov	 DWORD PTR _lDifference$[ebp], eax
$L53483:

; 546  :     }
; 547  : 
; 548  :     nStepSize >>= 1;

  0004d	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00050	d1 f9		 sar	 ecx, 1
  00052	89 4d 10	 mov	 DWORD PTR _nStepSize$[ebp], ecx

; 549  : 
; 550  :     if(lDifference >= nStepSize)

  00055	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  00058	3b 55 10	 cmp	 edx, DWORD PTR _nStepSize$[ebp]
  0005b	7c 11		 jl	 SHORT $L53484

; 551  :     {
; 552  :         nEncodedSample |= 2;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00060	0c 02		 or	 al, 2
  00062	89 45 fc	 mov	 DWORD PTR _nEncodedSample$[ebp], eax

; 553  :         lDifference -= nStepSize;

  00065	8b 4d f8	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  00068	2b 4d 10	 sub	 ecx, DWORD PTR _nStepSize$[ebp]
  0006b	89 4d f8	 mov	 DWORD PTR _lDifference$[ebp], ecx
$L53484:

; 554  :     }
; 555  : 
; 556  :     nStepSize >>= 1;

  0006e	8b 55 10	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  00071	d1 fa		 sar	 edx, 1
  00073	89 55 10	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 557  : 
; 558  :     if(lDifference >= nStepSize)

  00076	8b 45 f8	 mov	 eax, DWORD PTR _lDifference$[ebp]
  00079	3b 45 10	 cmp	 eax, DWORD PTR _nStepSize$[ebp]
  0007c	7c 12		 jl	 SHORT $L53485

; 559  :     {
; 560  :         nEncodedSample |= 1;

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _nEncodedSample$[ebp]
  00081	83 c9 01	 or	 ecx, 1
  00084	89 4d fc	 mov	 DWORD PTR _nEncodedSample$[ebp], ecx

; 561  :         lDifference -= nStepSize;

  00087	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0008a	2b 55 10	 sub	 edx, DWORD PTR _nStepSize$[ebp]
  0008d	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L53485:

; 562  :     }
; 563  : 
; 564  :     if(nEncodedSample & 8)

  00090	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00093	83 e0 08	 and	 eax, 8
  00096	85 c0		 test	 eax, eax
  00098	74 12		 je	 SHORT $L53486

; 565  :     {
; 566  :         nPredictedSample = nInputSample + lDifference - (nStepSize >> 1);

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _nInputSample$[ebp]
  0009d	03 4d f8	 add	 ecx, DWORD PTR _lDifference$[ebp]
  000a0	8b 55 10	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  000a3	d1 fa		 sar	 edx, 1
  000a5	2b ca		 sub	 ecx, edx
  000a7	89 4d f4	 mov	 DWORD PTR _nPredictedSample$[ebp], ecx

; 567  :     }
; 568  :     else

  000aa	eb 10		 jmp	 SHORT $L53487
$L53486:

; 569  :     {
; 570  :         nPredictedSample = nInputSample - lDifference + (nStepSize >> 1);

  000ac	8b 45 08	 mov	 eax, DWORD PTR _nInputSample$[ebp]
  000af	2b 45 f8	 sub	 eax, DWORD PTR _lDifference$[ebp]
  000b2	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  000b5	d1 f9		 sar	 ecx, 1
  000b7	03 c1		 add	 eax, ecx
  000b9	89 45 f4	 mov	 DWORD PTR _nPredictedSample$[ebp], eax
$L53487:

; 571  :     }
; 572  : 
; 573  :     if(nPredictedSample > 32767)

  000bc	81 7d f4 ff 7f
	00 00		 cmp	 DWORD PTR _nPredictedSample$[ebp], 32767 ; 00007fffH
  000c3	7e 09		 jle	 SHORT $L53488

; 574  :     {
; 575  :         nPredictedSample = 32767;

  000c5	c7 45 f4 ff 7f
	00 00		 mov	 DWORD PTR _nPredictedSample$[ebp], 32767 ; 00007fffH

; 576  :     }
; 577  :     else if(nPredictedSample < -32768)

  000cc	eb 10		 jmp	 SHORT $L53489
$L53488:
  000ce	81 7d f4 00 80
	ff ff		 cmp	 DWORD PTR _nPredictedSample$[ebp], -32768 ; ffff8000H
  000d5	7d 07		 jge	 SHORT $L53490

; 578  :     {
; 579  :         nPredictedSample = -32768;

  000d7	c7 45 f4 00 80
	ff ff		 mov	 DWORD PTR _nPredictedSample$[ebp], -32768 ; ffff8000H
$L53490:
$L53489:

; 580  :     }
; 581  : 
; 582  :     *pnPredictedSample = nPredictedSample;

  000de	8b 55 0c	 mov	 edx, DWORD PTR _pnPredictedSample$[ebp]
  000e1	8b 45 f4	 mov	 eax, DWORD PTR _nPredictedSample$[ebp]
  000e4	89 02		 mov	 DWORD PTR [edx], eax

; 583  :     
; 584  :     return nEncodedSample;

  000e6	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]

; 585  : }

  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 0c 00	 ret	 12			; 0000000cH
?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ENDP ; DirectSound::CImaAdpcmCodec::EncodeSample
_TEXT	ENDS
PUBLIC	?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
; Function compile flags: /Odt
;	COMDAT ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z
_TEXT	SEGMENT
_nEncodedSample$ = 8
_nPredictedSample$ = 12
_nStepSize$ = 16
_lDifference$ = -8
_lNewSample$ = -4
?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::DecodeSample, COMDAT

; 612  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 613  :     LONG                lDifference;
; 614  :     LONG                lNewSample;
; 615  : 
; 616  :     lDifference = nStepSize >> 3;

  00006	8b 45 10	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  00009	c1 f8 03	 sar	 eax, 3
  0000c	89 45 f8	 mov	 DWORD PTR _lDifference$[ebp], eax

; 617  : 
; 618  :     if(nEncodedSample & 4) 

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _nEncodedSample$[ebp]
  00012	83 e1 04	 and	 ecx, 4
  00015	85 c9		 test	 ecx, ecx
  00017	74 09		 je	 SHORT $L53498

; 619  :     {
; 620  :         lDifference += nStepSize;

  00019	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0001c	03 55 10	 add	 edx, DWORD PTR _nStepSize$[ebp]
  0001f	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L53498:

; 621  :     }
; 622  : 
; 623  :     if(nEncodedSample & 2) 

  00022	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00025	83 e0 02	 and	 eax, 2
  00028	85 c0		 test	 eax, eax
  0002a	74 0d		 je	 SHORT $L53499

; 624  :     {
; 625  :         lDifference += nStepSize >> 1;

  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  0002f	d1 f9		 sar	 ecx, 1
  00031	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  00034	03 d1		 add	 edx, ecx
  00036	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L53499:

; 626  :     }
; 627  : 
; 628  :     if(nEncodedSample & 1) 

  00039	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  0003c	83 e0 01	 and	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	74 0e		 je	 SHORT $L53500

; 629  :     {
; 630  :         lDifference += nStepSize >> 2;

  00043	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00046	c1 f9 02	 sar	 ecx, 2
  00049	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0004c	03 d1		 add	 edx, ecx
  0004e	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L53500:

; 631  :     }
; 632  : 
; 633  :     if(nEncodedSample & 8)

  00051	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00054	83 e0 08	 and	 eax, 8
  00057	85 c0		 test	 eax, eax
  00059	74 08		 je	 SHORT $L53501

; 634  :     {
; 635  :         lDifference = -lDifference;

  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  0005e	f7 d9		 neg	 ecx
  00060	89 4d f8	 mov	 DWORD PTR _lDifference$[ebp], ecx
$L53501:

; 636  :     }
; 637  : 
; 638  :     lNewSample = nPredictedSample + lDifference;

  00063	8b 55 0c	 mov	 edx, DWORD PTR _nPredictedSample$[ebp]
  00066	03 55 f8	 add	 edx, DWORD PTR _lDifference$[ebp]
  00069	89 55 fc	 mov	 DWORD PTR _lNewSample$[ebp], edx

; 639  : 
; 640  :     if((LONG)(short)lNewSample != lNewSample)

  0006c	0f bf 45 fc	 movsx	 eax, WORD PTR _lNewSample$[ebp]
  00070	3b 45 fc	 cmp	 eax, DWORD PTR _lNewSample$[ebp]
  00073	74 19		 je	 SHORT $L53504

; 641  :     {
; 642  :         if(lNewSample < -32768)

  00075	81 7d fc 00 80
	ff ff		 cmp	 DWORD PTR _lNewSample$[ebp], -32768 ; ffff8000H
  0007c	7d 09		 jge	 SHORT $L53505

; 643  :         {
; 644  :             lNewSample = -32768;

  0007e	c7 45 fc 00 80
	ff ff		 mov	 DWORD PTR _lNewSample$[ebp], -32768 ; ffff8000H

; 645  :         }
; 646  :         else

  00085	eb 07		 jmp	 SHORT $L53506
$L53505:

; 647  :         {
; 648  :             lNewSample = 32767;

  00087	c7 45 fc ff 7f
	00 00		 mov	 DWORD PTR _lNewSample$[ebp], 32767 ; 00007fffH
$L53506:
$L53504:

; 649  :         }
; 650  :     }
; 651  : 
; 652  :     return (int)lNewSample;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _lNewSample$[ebp]

; 653  : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ENDP	; DirectSound::CImaAdpcmCodec::DecodeSample
_TEXT	ENDS
PUBLIC	?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
; Function compile flags: /Odt
;	COMDAT ?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_pnStepIndexL$ = 28
_pbBlock$ = -20
_cSamples$ = -16
_nSample$ = -28
_nStepSize$ = -32
_nEncSample1$ = -8
_nEncSample2$ = -12
_nPredSample$ = -24
_nStepIndex$ = -4
?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::EncodeM16, COMDAT

; 689  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 690  :     LPBYTE                  pbBlock;
; 691  :     UINT                    cSamples;
; 692  :     int                     nSample;
; 693  :     int                     nStepSize;
; 694  :     int                     nEncSample1;
; 695  :     int                     nEncSample2;
; 696  :     int                     nPredSample;
; 697  :     int                     nStepIndex;
; 698  : 
; 699  :     //
; 700  :     // Save a local copy of the step index so we're not constantly 
; 701  :     // dereferencing a pointer.
; 702  :     //
; 703  :     
; 704  :     nStepIndex = *pnStepIndexL;

  00006	8b 45 1c	 mov	 eax, DWORD PTR _pnStepIndexL$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d fc	 mov	 DWORD PTR _nStepIndex$[ebp], ecx
$L53526:

; 705  : 
; 706  :     //
; 707  :     // Enter the main loop
; 708  :     //
; 709  :     
; 710  :     while(cBlocks--)

  0000e	8b 55 10	 mov	 edx, DWORD PTR _cBlocks$[ebp]
  00011	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00014	83 e8 01	 sub	 eax, 1
  00017	89 45 10	 mov	 DWORD PTR _cBlocks$[ebp], eax
  0001a	85 d2		 test	 edx, edx
  0001c	0f 84 2f 01 00
	00		 je	 $L53527

; 711  :     {
; 712  :         pbBlock = pbDst;

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  00025	89 4d ec	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 713  :         cSamples = cSamplesPerBlock - 1;

  00028	8b 55 18	 mov	 edx, DWORD PTR _cSamplesPerBlock$[ebp]
  0002b	83 ea 01	 sub	 edx, 1
  0002e	89 55 f0	 mov	 DWORD PTR _cSamples$[ebp], edx

; 714  : 
; 715  :         //
; 716  :         // Block header
; 717  :         //
; 718  : 
; 719  :         nPredSample = *(short *)pbSrc;

  00031	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00034	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00037	89 4d e8	 mov	 DWORD PTR _nPredSample$[ebp], ecx

; 720  :         pbSrc += sizeof(short);

  0003a	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0003d	83 c2 02	 add	 edx, 2
  00040	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 721  : 
; 722  :         *(LONG *)pbBlock = MAKELONG(nPredSample, nStepIndex);

  00043	8b 45 e8	 mov	 eax, DWORD PTR _nPredSample$[ebp]
  00046	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  00053	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00059	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0005f	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00062	0b c1		 or	 eax, ecx
  00064	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00067	89 02		 mov	 DWORD PTR [edx], eax

; 723  :         pbBlock += sizeof(LONG);

  00069	8b 45 ec	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  0006c	83 c0 04	 add	 eax, 4
  0006f	89 45 ec	 mov	 DWORD PTR _pbBlock$[ebp], eax
$L53539:

; 724  : 
; 725  :         //
; 726  :         // We have written the header for this block--now write the data
; 727  :         // chunk (which consists of a bunch of encoded nibbles).  Note
; 728  :         // that if we don't have enough data to fill a complete byte, then
; 729  :         // we add a 0 nibble on the end.
; 730  :         //
; 731  : 
; 732  :         while(cSamples)

  00072	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  00076	0f 84 c7 00 00
	00		 je	 $L53540

; 733  :         {
; 734  :             //
; 735  :             // Sample 1
; 736  :             //
; 737  : 
; 738  :             nSample = *(short *)pbSrc;

  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  0007f	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00082	89 55 e4	 mov	 DWORD PTR _nSample$[ebp], edx

; 739  :             pbSrc += sizeof(short);

  00085	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00088	83 c0 02	 add	 eax, 2
  0008b	89 45 08	 mov	 DWORD PTR _pbSrc$[ebp], eax

; 740  :             cSamples--;

  0008e	8b 4d f0	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  00091	83 e9 01	 sub	 ecx, 1
  00094	89 4d f0	 mov	 DWORD PTR _cSamples$[ebp], ecx

; 741  : 
; 742  :             nStepSize = m_asStep[nStepIndex];

  00097	8b 55 fc	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  0009a	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  000a2	89 45 e0	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 743  :             nEncSample1 = EncodeSample(nSample, &nPredSample, nStepSize);

  000a5	8b 4d e0	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  000a8	51		 push	 ecx
  000a9	8d 55 e8	 lea	 edx, DWORD PTR _nPredSample$[ebp]
  000ac	52		 push	 edx
  000ad	8b 45 e4	 mov	 eax, DWORD PTR _nSample$[ebp]
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  000b6	89 45 f8	 mov	 DWORD PTR _nEncSample1$[ebp], eax

; 744  :             nStepIndex = NextStepIndex(nEncSample1, nStepIndex);

  000b9	8b 4d fc	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  000bc	51		 push	 ecx
  000bd	8b 55 f8	 mov	 edx, DWORD PTR _nEncSample1$[ebp]
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  000c6	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 745  : 
; 746  :             //
; 747  :             // Sample 2
; 748  :             //
; 749  : 
; 750  :             if(cSamples)

  000c9	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000cd	74 4f		 je	 SHORT $L53543

; 751  :             {
; 752  :                 nSample = *(short *)pbSrc;

  000cf	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  000d2	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000d5	89 4d e4	 mov	 DWORD PTR _nSample$[ebp], ecx

; 753  :                 pbSrc += sizeof(short);

  000d8	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  000db	83 c2 02	 add	 edx, 2
  000de	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 754  :                 cSamples--;

  000e1	8b 45 f0	 mov	 eax, DWORD PTR _cSamples$[ebp]
  000e4	83 e8 01	 sub	 eax, 1
  000e7	89 45 f0	 mov	 DWORD PTR _cSamples$[ebp], eax

; 755  : 
; 756  :                 nStepSize = m_asStep[nStepIndex];

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  000ed	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[ecx*2]
  000f5	89 55 e0	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 757  :                 nEncSample2 = EncodeSample(nSample, &nPredSample, nStepSize);

  000f8	8b 45 e0	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  000fb	50		 push	 eax
  000fc	8d 4d e8	 lea	 ecx, DWORD PTR _nPredSample$[ebp]
  000ff	51		 push	 ecx
  00100	8b 55 e4	 mov	 edx, DWORD PTR _nSample$[ebp]
  00103	52		 push	 edx
  00104	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  00109	89 45 f4	 mov	 DWORD PTR _nEncSample2$[ebp], eax

; 758  :                 nStepIndex = NextStepIndex(nEncSample2, nStepIndex);

  0010c	8b 45 fc	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  0010f	50		 push	 eax
  00110	8b 4d f4	 mov	 ecx, DWORD PTR _nEncSample2$[ebp]
  00113	51		 push	 ecx
  00114	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  00119	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 759  :             }
; 760  :             else

  0011c	eb 07		 jmp	 SHORT $L53546
$L53543:

; 761  :             {
; 762  :                 nEncSample2 = 0;

  0011e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nEncSample2$[ebp], 0
$L53546:

; 763  :             }
; 764  : 
; 765  :             //
; 766  :             // Write out encoded byte.
; 767  :             //
; 768  : 
; 769  :             *pbBlock++ = (BYTE)(nEncSample1 | (nEncSample2 << 4));

  00125	8b 55 f4	 mov	 edx, DWORD PTR _nEncSample2$[ebp]
  00128	c1 e2 04	 shl	 edx, 4
  0012b	8b 45 f8	 mov	 eax, DWORD PTR _nEncSample1$[ebp]
  0012e	0b c2		 or	 eax, edx
  00130	8b 4d ec	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00133	88 01		 mov	 BYTE PTR [ecx], al
  00135	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00138	83 c2 01	 add	 edx, 1
  0013b	89 55 ec	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 770  :         }

  0013e	e9 2f ff ff ff	 jmp	 $L53539
$L53540:

; 771  : 
; 772  :         //
; 773  :         // Skip padding
; 774  :         //
; 775  : 
; 776  :         pbDst += nBlockAlignment;

  00143	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  00146	03 45 14	 add	 eax, DWORD PTR _nBlockAlignment$[ebp]
  00149	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 777  :     }

  0014c	e9 bd fe ff ff	 jmp	 $L53526
$L53527:

; 778  : 
; 779  :     //
; 780  :     // Restore the value of the step index to be used on the next buffer.
; 781  :     //
; 782  : 
; 783  :     *pnStepIndexL = nStepIndex;

  00151	8b 4d 1c	 mov	 ecx, DWORD PTR _pnStepIndexL$[ebp]
  00154	8b 55 fc	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  00157	89 11		 mov	 DWORD PTR [ecx], edx

; 784  : 
; 785  :     return TRUE;

  00159	b8 01 00 00 00	 mov	 eax, 1

; 786  : }

  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 1c 00	 ret	 28			; 0000001cH
?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::EncodeM16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.h
_TEXT	ENDS
;	COMDAT ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z
_TEXT	SEGMENT
_nEncodedSample$ = 8
_nStepIndex$ = 12
?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::NextStepIndex, COMDAT

; 115  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 116  :         nStepIndex += m_asNextStep[nEncodedSample];

  00003	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00006	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_asNextStep@CImaAdpcmCodec@DirectSound@@0QBFB[eax*2]
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  00011	03 d1		 add	 edx, ecx
  00013	89 55 0c	 mov	 DWORD PTR _nStepIndex$[ebp], edx

; 117  : 
; 118  :         if(nStepIndex < 0)

  00016	83 7d 0c 00	 cmp	 DWORD PTR _nStepIndex$[ebp], 0
  0001a	7d 09		 jge	 SHORT $L48277

; 119  :         {
; 120  :             nStepIndex = 0;

  0001c	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _nStepIndex$[ebp], 0

; 121  :         }
; 122  :         else if(nStepIndex >= NUMELMS(m_asStep))

  00023	eb 0d		 jmp	 SHORT $L48278
$L48277:
  00025	83 7d 0c 59	 cmp	 DWORD PTR _nStepIndex$[ebp], 89 ; 00000059H
  00029	72 07		 jb	 SHORT $L48279

; 123  :         {
; 124  :             nStepIndex = NUMELMS(m_asStep) - 1;

  0002b	c7 45 0c 58 00
	00 00		 mov	 DWORD PTR _nStepIndex$[ebp], 88 ; 00000058H
$L48279:
$L48278:

; 125  :         }
; 126  : 
; 127  :         return nStepIndex;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _nStepIndex$[ebp]

; 128  :     }

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ENDP	; DirectSound::CImaAdpcmCodec::NextStepIndex
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
_TEXT	ENDS
;	COMDAT ?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_pnStepIndexL$ = 28
_pnStepIndexR$ = 32
_pbBlock$ = -20
_cSamples$ = -16
_cSubSamples$ = -4
_nSample$ = -52
_nStepSize$ = -56
_dwLeft$ = -36
_dwRight$ = -28
_nEncSampleL$ = -48
_nPredSampleL$ = -40
_nStepIndexL$ = -24
_nEncSampleR$ = -12
_nPredSampleR$ = -8
_nStepIndexR$ = -44
_i$ = -32
?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::EncodeS16, COMDAT

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 801  :     LPBYTE                  pbBlock;
; 802  :     UINT                    cSamples;
; 803  :     UINT                    cSubSamples;
; 804  :     int                     nSample;
; 805  :     int                     nStepSize;
; 806  :     DWORD                   dwLeft;
; 807  :     DWORD                   dwRight;
; 808  :     int                     nEncSampleL;
; 809  :     int                     nPredSampleL;
; 810  :     int                     nStepIndexL;
; 811  :     int                     nEncSampleR;
; 812  :     int                     nPredSampleR;
; 813  :     int                     nStepIndexR;
; 814  :     UINT                    i;
; 815  : 
; 816  :     //
; 817  :     // Save a local copy of the step indeces so we're not constantly 
; 818  :     // dereferencing a pointer.
; 819  :     //
; 820  :     
; 821  :     nStepIndexL = *pnStepIndexL;

  00006	8b 45 1c	 mov	 eax, DWORD PTR _pnStepIndexL$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d e8	 mov	 DWORD PTR _nStepIndexL$[ebp], ecx

; 822  :     nStepIndexR = *pnStepIndexR;

  0000e	8b 55 20	 mov	 edx, DWORD PTR _pnStepIndexR$[ebp]
  00011	8b 02		 mov	 eax, DWORD PTR [edx]
  00013	89 45 d4	 mov	 DWORD PTR _nStepIndexR$[ebp], eax
$L53572:

; 823  : 
; 824  :     //
; 825  :     // Enter the main loop
; 826  :     //
; 827  :     
; 828  :     while(cBlocks--)

  00016	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00019	8b 55 10	 mov	 edx, DWORD PTR _cBlocks$[ebp]
  0001c	83 ea 01	 sub	 edx, 1
  0001f	89 55 10	 mov	 DWORD PTR _cBlocks$[ebp], edx
  00022	85 c9		 test	 ecx, ecx
  00024	0f 84 d3 01 00
	00		 je	 $L53573

; 829  :     {
; 830  :         pbBlock = pbDst;

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  0002d	89 45 ec	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 831  :         cSamples = cSamplesPerBlock - 1;

  00030	8b 4d 18	 mov	 ecx, DWORD PTR _cSamplesPerBlock$[ebp]
  00033	83 e9 01	 sub	 ecx, 1
  00036	89 4d f0	 mov	 DWORD PTR _cSamples$[ebp], ecx

; 832  : 
; 833  :         //
; 834  :         // LEFT channel block header
; 835  :         //
; 836  : 
; 837  :         nPredSampleL = *(short *)pbSrc;

  00039	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0003c	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0003f	89 45 d8	 mov	 DWORD PTR _nPredSampleL$[ebp], eax

; 838  :         pbSrc += sizeof(short);

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  00045	83 c1 02	 add	 ecx, 2
  00048	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 839  : 
; 840  :         *(LONG *)pbBlock = MAKELONG(nPredSampleL, nStepIndexL);

  0004b	8b 55 d8	 mov	 edx, DWORD PTR _nPredSampleL$[ebp]
  0004e	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00054	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0005a	8b 45 e8	 mov	 eax, DWORD PTR _nStepIndexL$[ebp]
  0005d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00062	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00067	c1 e0 10	 shl	 eax, 16			; 00000010H
  0006a	0b d0		 or	 edx, eax
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  0006f	89 11		 mov	 DWORD PTR [ecx], edx

; 841  :         pbBlock += sizeof(LONG);

  00071	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00074	83 c2 04	 add	 edx, 4
  00077	89 55 ec	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 842  : 
; 843  :         //
; 844  :         // RIGHT channel block header
; 845  :         //
; 846  : 
; 847  :         nPredSampleR = *(short *)pbSrc;

  0007a	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  0007d	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00080	89 4d f8	 mov	 DWORD PTR _nPredSampleR$[ebp], ecx

; 848  :         pbSrc += sizeof(short);

  00083	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00086	83 c2 02	 add	 edx, 2
  00089	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 849  : 
; 850  :         *(LONG *)pbBlock = MAKELONG(nPredSampleR, nStepIndexR);

  0008c	8b 45 f8	 mov	 eax, DWORD PTR _nPredSampleR$[ebp]
  0008f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00094	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00099	8b 4d d4	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  0009c	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000a2	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000a8	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000ab	0b c1		 or	 eax, ecx
  000ad	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  000b0	89 02		 mov	 DWORD PTR [edx], eax

; 851  :         pbBlock += sizeof(LONG);

  000b2	8b 45 ec	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  000b5	83 c0 04	 add	 eax, 4
  000b8	89 45 ec	 mov	 DWORD PTR _pbBlock$[ebp], eax
$L53595:

; 852  : 
; 853  :         //
; 854  :         // We have written the header for this block--now write the data
; 855  :         // chunk.  This consists of 8 left samples (one DWORD of output)
; 856  :         // followed by 8 right samples (also one DWORD).  Since the input
; 857  :         // samples are interleaved, we create the left and right DWORDs
; 858  :         // sample by sample, and then write them both out.
; 859  :         //
; 860  : 
; 861  :         while(cSamples)

  000bb	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000bf	0f 84 2a 01 00
	00		 je	 $L53596

; 862  :         {
; 863  :             dwLeft = 0;

  000c5	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _dwLeft$[ebp], 0

; 864  :             dwRight = 0;

  000cc	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _dwRight$[ebp], 0

; 865  : 
; 866  :             cSubSamples = min(cSamples, 8);

  000d3	83 7d f0 08	 cmp	 DWORD PTR _cSamples$[ebp], 8
  000d7	73 08		 jae	 SHORT $L54254
  000d9	8b 4d f0	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  000dc	89 4d c4	 mov	 DWORD PTR -60+[ebp], ecx
  000df	eb 07		 jmp	 SHORT $L54255
$L54254:
  000e1	c7 45 c4 08 00
	00 00		 mov	 DWORD PTR -60+[ebp], 8
$L54255:
  000e8	8b 55 c4	 mov	 edx, DWORD PTR -60+[ebp]
  000eb	89 55 fc	 mov	 DWORD PTR _cSubSamples$[ebp], edx

; 867  : 
; 868  :             for(i = 0; i < cSubSamples; i++)

  000ee	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000f5	eb 09		 jmp	 SHORT $L53597
$L53598:
  000f7	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  000fa	83 c0 01	 add	 eax, 1
  000fd	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$L53597:
  00100	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  00103	3b 4d fc	 cmp	 ecx, DWORD PTR _cSubSamples$[ebp]
  00106	0f 83 b3 00 00
	00		 jae	 $L53599

; 869  :             {
; 870  :                 //
; 871  :                 // LEFT channel
; 872  :                 //
; 873  : 
; 874  :                 nSample = *(short *)pbSrc;

  0010c	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0010f	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00112	89 45 cc	 mov	 DWORD PTR _nSample$[ebp], eax

; 875  :                 pbSrc += sizeof(short);

  00115	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  00118	83 c1 02	 add	 ecx, 2
  0011b	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 876  : 
; 877  :                 nStepSize = m_asStep[nStepIndexL];

  0011e	8b 55 e8	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  00121	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  00129	89 45 c8	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 878  :                 
; 879  :                 nEncSampleL = EncodeSample(nSample, &nPredSampleL, nStepSize);

  0012c	8b 4d c8	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  0012f	51		 push	 ecx
  00130	8d 55 d8	 lea	 edx, DWORD PTR _nPredSampleL$[ebp]
  00133	52		 push	 edx
  00134	8b 45 cc	 mov	 eax, DWORD PTR _nSample$[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  0013d	89 45 d0	 mov	 DWORD PTR _nEncSampleL$[ebp], eax

; 880  : 
; 881  :                 nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);

  00140	8b 4d e8	 mov	 ecx, DWORD PTR _nStepIndexL$[ebp]
  00143	51		 push	 ecx
  00144	8b 55 d0	 mov	 edx, DWORD PTR _nEncSampleL$[ebp]
  00147	52		 push	 edx
  00148	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  0014d	89 45 e8	 mov	 DWORD PTR _nStepIndexL$[ebp], eax

; 882  :                 dwLeft |= (DWORD)nEncSampleL << (4 * i);

  00150	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  00153	c1 e1 02	 shl	 ecx, 2
  00156	8b 45 d0	 mov	 eax, DWORD PTR _nEncSampleL$[ebp]
  00159	d3 e0		 shl	 eax, cl
  0015b	8b 4d dc	 mov	 ecx, DWORD PTR _dwLeft$[ebp]
  0015e	0b c8		 or	 ecx, eax
  00160	89 4d dc	 mov	 DWORD PTR _dwLeft$[ebp], ecx

; 883  : 
; 884  :                 //
; 885  :                 // RIGHT channel
; 886  :                 //
; 887  : 
; 888  :                 nSample = *(short *)pbSrc;

  00163	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00166	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00169	89 45 cc	 mov	 DWORD PTR _nSample$[ebp], eax

; 889  :                 pbSrc += sizeof(short);

  0016c	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  0016f	83 c1 02	 add	 ecx, 2
  00172	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 890  : 
; 891  :                 nStepSize = m_asStep[nStepIndexR];

  00175	8b 55 d4	 mov	 edx, DWORD PTR _nStepIndexR$[ebp]
  00178	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  00180	89 45 c8	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 892  :                 
; 893  :                 nEncSampleR = EncodeSample(nSample, &nPredSampleR, nStepSize);

  00183	8b 4d c8	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00186	51		 push	 ecx
  00187	8d 55 f8	 lea	 edx, DWORD PTR _nPredSampleR$[ebp]
  0018a	52		 push	 edx
  0018b	8b 45 cc	 mov	 eax, DWORD PTR _nSample$[ebp]
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  00194	89 45 f4	 mov	 DWORD PTR _nEncSampleR$[ebp], eax

; 894  : 
; 895  :                 nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);

  00197	8b 4d d4	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  0019a	51		 push	 ecx
  0019b	8b 55 f4	 mov	 edx, DWORD PTR _nEncSampleR$[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  001a4	89 45 d4	 mov	 DWORD PTR _nStepIndexR$[ebp], eax

; 896  :                 dwRight |= (DWORD)nEncSampleR << (4 * i);

  001a7	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  001aa	c1 e1 02	 shl	 ecx, 2
  001ad	8b 45 f4	 mov	 eax, DWORD PTR _nEncSampleR$[ebp]
  001b0	d3 e0		 shl	 eax, cl
  001b2	8b 4d e4	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  001b5	0b c8		 or	 ecx, eax
  001b7	89 4d e4	 mov	 DWORD PTR _dwRight$[ebp], ecx

; 897  :             }

  001ba	e9 38 ff ff ff	 jmp	 $L53598
$L53599:

; 898  : 
; 899  :             //
; 900  :             // Write out encoded DWORDs.
; 901  :             //
; 902  : 
; 903  :             *(LPDWORD)pbBlock = dwLeft;

  001bf	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  001c2	8b 45 dc	 mov	 eax, DWORD PTR _dwLeft$[ebp]
  001c5	89 02		 mov	 DWORD PTR [edx], eax

; 904  :             pbBlock += sizeof(DWORD);

  001c7	8b 4d ec	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  001ca	83 c1 04	 add	 ecx, 4
  001cd	89 4d ec	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 905  : 
; 906  :             *(LPDWORD)pbBlock = dwRight;

  001d0	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  001d3	8b 45 e4	 mov	 eax, DWORD PTR _dwRight$[ebp]
  001d6	89 02		 mov	 DWORD PTR [edx], eax

; 907  :             pbBlock += sizeof(DWORD);

  001d8	8b 4d ec	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  001db	83 c1 04	 add	 ecx, 4
  001de	89 4d ec	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 908  : 
; 909  :             cSamples -= cSubSamples;

  001e1	8b 55 f0	 mov	 edx, DWORD PTR _cSamples$[ebp]
  001e4	2b 55 fc	 sub	 edx, DWORD PTR _cSubSamples$[ebp]
  001e7	89 55 f0	 mov	 DWORD PTR _cSamples$[ebp], edx

; 910  :         }

  001ea	e9 cc fe ff ff	 jmp	 $L53595
$L53596:

; 911  : 
; 912  :         //
; 913  :         // Skip padding
; 914  :         //
; 915  : 
; 916  :         pbDst += nBlockAlignment;

  001ef	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  001f2	03 45 14	 add	 eax, DWORD PTR _nBlockAlignment$[ebp]
  001f5	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 917  :     }

  001f8	e9 19 fe ff ff	 jmp	 $L53572
$L53573:

; 918  : 
; 919  :     //
; 920  :     // Restore the value of the step index to be used on the next buffer.
; 921  :     //
; 922  :     
; 923  :     *pnStepIndexL = nStepIndexL;

  001fd	8b 4d 1c	 mov	 ecx, DWORD PTR _pnStepIndexL$[ebp]
  00200	8b 55 e8	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  00203	89 11		 mov	 DWORD PTR [ecx], edx

; 924  :     *pnStepIndexR = nStepIndexR;

  00205	8b 45 20	 mov	 eax, DWORD PTR _pnStepIndexR$[ebp]
  00208	8b 4d d4	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  0020b	89 08		 mov	 DWORD PTR [eax], ecx

; 925  : 
; 926  :     return TRUE;

  0020d	b8 01 00 00 00	 mov	 eax, 1

; 927  : 
; 928  : }

  00212	8b e5		 mov	 esp, ebp
  00214	5d		 pop	 ebp
  00215	c2 1c 00	 ret	 28			; 0000001cH
?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::EncodeS16
_TEXT	ENDS
PUBLIC	?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
; Function compile flags: /Odt
;	COMDAT ?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_fSuccess$ = -32
_pbBlock$ = -16
_cSamples$ = -8
_bSample$ = -21
_nStepSize$ = -36
_nEncSample$ = -20
_nPredSample$ = -28
_nStepIndex$ = -4
_dwHeader$ = -12
?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::DecodeM16, COMDAT

; 942  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 943  :     BOOL                    fSuccess    = TRUE;

  00006	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 1
$L53629:

; 944  :     LPBYTE                  pbBlock;
; 945  :     UINT                    cSamples;
; 946  :     BYTE                    bSample;
; 947  :     int                     nStepSize;
; 948  :     int                     nEncSample;
; 949  :     int                     nPredSample;
; 950  :     int                     nStepIndex;
; 951  :     DWORD                   dwHeader;
; 952  : 
; 953  :     //
; 954  :     // Enter the main loop
; 955  :     //
; 956  :     
; 957  :     while(cBlocks--)

  0000d	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00013	83 e9 01	 sub	 ecx, 1
  00016	89 4d 10	 mov	 DWORD PTR _cBlocks$[ebp], ecx
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 57 01 00
	00		 je	 $L53630

; 958  :     {
; 959  :         pbBlock = pbSrc;

  00021	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00024	89 55 f0	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 960  :         cSamples = cSamplesPerBlock - 1;

  00027	8b 45 18	 mov	 eax, DWORD PTR _cSamplesPerBlock$[ebp]
  0002a	83 e8 01	 sub	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _cSamples$[ebp], eax

; 961  :         
; 962  :         //
; 963  :         // Block header
; 964  :         //
; 965  : 
; 966  :         dwHeader = *(LPDWORD)pbBlock;

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	89 55 f4	 mov	 DWORD PTR _dwHeader$[ebp], edx

; 967  :         pbBlock += sizeof(DWORD);

  00038	8b 45 f0	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 f0	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 968  : 
; 969  :         nPredSample = (int)(short)LOWORD(dwHeader);

  00041	8b 4d f4	 mov	 ecx, DWORD PTR _dwHeader$[ebp]
  00044	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0004a	0f bf d1	 movsx	 edx, cx
  0004d	89 55 e4	 mov	 DWORD PTR _nPredSample$[ebp], edx

; 970  :         nStepIndex = (int)(BYTE)HIWORD(dwHeader);

  00050	8b 45 f4	 mov	 eax, DWORD PTR _dwHeader$[ebp]
  00053	c1 e8 10	 shr	 eax, 16			; 00000010H
  00056	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005b	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 971  : 
; 972  :         if(!ValidStepIndex(nStepIndex))

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
  00067	85 c0		 test	 eax, eax
  00069	75 0c		 jne	 SHORT $L53641

; 973  :         {
; 974  :             //
; 975  :             // The step index is out of range - this is considered a fatal
; 976  :             // error as the input stream is corrupted.  We fail by returning
; 977  :             // zero bytes converted.
; 978  :             //
; 979  : 
; 980  :             fSuccess = FALSE;

  0006b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 981  :             break;

  00072	e9 01 01 00 00	 jmp	 $L53630
$L53641:

; 982  :         }
; 983  :         
; 984  :         //
; 985  :         // Write out first sample
; 986  :         //
; 987  : 
; 988  :         *(short *)pbDst = (short)nPredSample;

  00077	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  0007a	66 8b 45 e4	 mov	 ax, WORD PTR _nPredSample$[ebp]
  0007e	66 89 02	 mov	 WORD PTR [edx], ax

; 989  :         pbDst += sizeof(short);

  00081	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  00084	83 c1 02	 add	 ecx, 2
  00087	89 4d 0c	 mov	 DWORD PTR _pbDst$[ebp], ecx
$L53646:

; 990  : 
; 991  :         //
; 992  :         // Enter the block loop
; 993  :         //
; 994  : 
; 995  :         while(cSamples)

  0008a	83 7d f8 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  0008e	0f 84 d6 00 00
	00		 je	 $L53647

; 996  :         {
; 997  :             bSample = *pbBlock++;

  00094	8b 55 f0	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00097	8a 02		 mov	 al, BYTE PTR [edx]
  00099	88 45 eb	 mov	 BYTE PTR _bSample$[ebp], al
  0009c	8b 4d f0	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  0009f	83 c1 01	 add	 ecx, 1
  000a2	89 4d f0	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 998  : 
; 999  :             //
; 1000 :             // Sample 1
; 1001 :             //
; 1002 : 
; 1003 :             nEncSample = (bSample & (BYTE)0x0F);

  000a5	8b 55 eb	 mov	 edx, DWORD PTR _bSample$[ebp]
  000a8	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000ae	83 e2 0f	 and	 edx, 15			; 0000000fH
  000b1	89 55 ec	 mov	 DWORD PTR _nEncSample$[ebp], edx

; 1004 :             nStepSize = m_asStep[nStepIndex];

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  000b7	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[eax*2]
  000bf	89 4d dc	 mov	 DWORD PTR _nStepSize$[ebp], ecx

; 1005 :             nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);

  000c2	8b 55 dc	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  000c5	52		 push	 edx
  000c6	8b 45 e4	 mov	 eax, DWORD PTR _nPredSample$[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d ec	 mov	 ecx, DWORD PTR _nEncSample$[ebp]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  000d3	89 45 e4	 mov	 DWORD PTR _nPredSample$[ebp], eax

; 1006 :             nStepIndex = NextStepIndex(nEncSample, nStepIndex);

  000d6	8b 55 fc	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  000d9	52		 push	 edx
  000da	8b 45 ec	 mov	 eax, DWORD PTR _nEncSample$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  000e3	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 1007 : 
; 1008 :             *(short *)pbDst = (short)nPredSample;

  000e6	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  000e9	66 8b 55 e4	 mov	 dx, WORD PTR _nPredSample$[ebp]
  000ed	66 89 11	 mov	 WORD PTR [ecx], dx

; 1009 :             pbDst += sizeof(short);

  000f0	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  000f3	83 c0 02	 add	 eax, 2
  000f6	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 1010 : 
; 1011 :             cSamples--;

  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  000fc	83 e9 01	 sub	 ecx, 1
  000ff	89 4d f8	 mov	 DWORD PTR _cSamples$[ebp], ecx

; 1012 : 
; 1013 :             //
; 1014 :             // Sample 2
; 1015 :             //
; 1016 : 
; 1017 :             if(cSamples)

  00102	83 7d f8 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  00106	74 5d		 je	 SHORT $L53652

; 1018 :             {
; 1019 :                 nEncSample = (bSample >> 4);

  00108	8b 55 eb	 mov	 edx, DWORD PTR _bSample$[ebp]
  0010b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00111	c1 fa 04	 sar	 edx, 4
  00114	89 55 ec	 mov	 DWORD PTR _nEncSample$[ebp], edx

; 1020 :                 nStepSize = m_asStep[nStepIndex];

  00117	8b 45 fc	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  0011a	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[eax*2]
  00122	89 4d dc	 mov	 DWORD PTR _nStepSize$[ebp], ecx

; 1021 :                 nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);

  00125	8b 55 dc	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  00128	52		 push	 edx
  00129	8b 45 e4	 mov	 eax, DWORD PTR _nPredSample$[ebp]
  0012c	50		 push	 eax
  0012d	8b 4d ec	 mov	 ecx, DWORD PTR _nEncSample$[ebp]
  00130	51		 push	 ecx
  00131	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  00136	89 45 e4	 mov	 DWORD PTR _nPredSample$[ebp], eax

; 1022 :                 nStepIndex = NextStepIndex(nEncSample, nStepIndex);

  00139	8b 55 fc	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  0013c	52		 push	 edx
  0013d	8b 45 ec	 mov	 eax, DWORD PTR _nEncSample$[ebp]
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  00146	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 1023 : 
; 1024 :                 *(short *)pbDst = (short)nPredSample;

  00149	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  0014c	66 8b 55 e4	 mov	 dx, WORD PTR _nPredSample$[ebp]
  00150	66 89 11	 mov	 WORD PTR [ecx], dx

; 1025 :                 pbDst += sizeof(short);

  00153	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  00156	83 c0 02	 add	 eax, 2
  00159	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 1026 : 
; 1027 :                 cSamples--;

  0015c	8b 4d f8	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  0015f	83 e9 01	 sub	 ecx, 1
  00162	89 4d f8	 mov	 DWORD PTR _cSamples$[ebp], ecx
$L53652:

; 1028 :             }
; 1029 :         }

  00165	e9 20 ff ff ff	 jmp	 $L53646
$L53647:

; 1030 : 
; 1031 :         //
; 1032 :         // Skip padding
; 1033 :         //
; 1034 : 
; 1035 :         pbSrc += nBlockAlignment;

  0016a	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0016d	03 55 14	 add	 edx, DWORD PTR _nBlockAlignment$[ebp]
  00170	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 1036 :     }

  00173	e9 95 fe ff ff	 jmp	 $L53629
$L53630:

; 1037 : 
; 1038 :     return fSuccess;

  00178	8b 45 e0	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 1039 : }

  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c2 1c 00	 ret	 28			; 0000001cH
?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::DecodeM16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.h
_TEXT	ENDS
;	COMDAT ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z
_TEXT	SEGMENT
_nStepIndex$ = 8
?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::ValidStepIndex, COMDAT

; 131  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 132  :         return (nStepIndex >= 0) && (nStepIndex < NUMELMS(m_asStep));

  00004	83 7d 08 00	 cmp	 DWORD PTR _nStepIndex$[ebp], 0
  00008	7c 0f		 jl	 SHORT $L54262
  0000a	83 7d 08 59	 cmp	 DWORD PTR _nStepIndex$[ebp], 89 ; 00000059H
  0000e	73 09		 jae	 SHORT $L54262
  00010	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR -4+[ebp], 1
  00017	eb 07		 jmp	 SHORT $L54263
$L54262:
  00019	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR -4+[ebp], 0
$L54263:
  00020	8b 45 fc	 mov	 eax, DWORD PTR -4+[ebp]

; 133  :     }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ENDP	; DirectSound::CImaAdpcmCodec::ValidStepIndex
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
_TEXT	ENDS
;	COMDAT ?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_fSuccess$ = -48
_pbBlock$ = -24
_cSamples$ = -16
_cSubSamples$ = -4
_nStepSize$ = -60
_dwHeader$ = -20
_dwLeft$ = -40
_dwRight$ = -32
_nEncSampleL$ = -56
_nPredSampleL$ = -44
_nStepIndexL$ = -28
_nEncSampleR$ = -12
_nPredSampleR$ = -8
_nStepIndexR$ = -52
_i$ = -36
?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::DecodeS16, COMDAT

; 1053 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 1054 :     BOOL                    fSuccess    = TRUE;

  00006	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 1
$L53681:

; 1055 :     LPBYTE                  pbBlock;
; 1056 :     UINT                    cSamples;
; 1057 :     UINT                    cSubSamples;
; 1058 :     int                     nStepSize;
; 1059 :     DWORD                   dwHeader;
; 1060 :     DWORD                   dwLeft;
; 1061 :     DWORD                   dwRight;
; 1062 :     int                     nEncSampleL;
; 1063 :     int                     nPredSampleL;
; 1064 :     int                     nStepIndexL;
; 1065 :     int                     nEncSampleR;
; 1066 :     int                     nPredSampleR;
; 1067 :     int                     nStepIndexR;
; 1068 :     UINT                    i;
; 1069 : 
; 1070 :     //
; 1071 :     // Enter the main loop
; 1072 :     //
; 1073 :     
; 1074 :     while(cBlocks--)

  0000d	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00013	83 e9 01	 sub	 ecx, 1
  00016	89 4d 10	 mov	 DWORD PTR _cBlocks$[ebp], ecx
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 0a 02 00
	00		 je	 $L53682

; 1075 :     {
; 1076 :         pbBlock = pbSrc;

  00021	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00024	89 55 e8	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 1077 :         cSamples = cSamplesPerBlock - 1;

  00027	8b 45 18	 mov	 eax, DWORD PTR _cSamplesPerBlock$[ebp]
  0002a	83 e8 01	 sub	 eax, 1
  0002d	89 45 f0	 mov	 DWORD PTR _cSamples$[ebp], eax

; 1078 : 
; 1079 :         //
; 1080 :         // LEFT channel header
; 1081 :         //
; 1082 : 
; 1083 :         dwHeader = *(LPDWORD)pbBlock;

  00030	8b 4d e8	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	89 55 ec	 mov	 DWORD PTR _dwHeader$[ebp], edx

; 1084 :         pbBlock += sizeof(DWORD);

  00038	8b 45 e8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 e8	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 1085 :         
; 1086 :         nPredSampleL = (int)(short)LOWORD(dwHeader);

  00041	8b 4d ec	 mov	 ecx, DWORD PTR _dwHeader$[ebp]
  00044	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0004a	0f bf d1	 movsx	 edx, cx
  0004d	89 55 d4	 mov	 DWORD PTR _nPredSampleL$[ebp], edx

; 1087 :         nStepIndexL = (int)(BYTE)HIWORD(dwHeader);

  00050	8b 45 ec	 mov	 eax, DWORD PTR _dwHeader$[ebp]
  00053	c1 e8 10	 shr	 eax, 16			; 00000010H
  00056	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005b	89 45 e4	 mov	 DWORD PTR _nStepIndexL$[ebp], eax

; 1088 : 
; 1089 :         if(!ValidStepIndex(nStepIndexL)) 

  0005e	8b 4d e4	 mov	 ecx, DWORD PTR _nStepIndexL$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
  00067	85 c0		 test	 eax, eax
  00069	75 0c		 jne	 SHORT $L53693

; 1090 :         {
; 1091 :             //
; 1092 :             // The step index is out of range - this is considered a fatal
; 1093 :             // error as the input stream is corrupted.  We fail by returning
; 1094 :             // zero bytes converted.
; 1095 :             //
; 1096 : 
; 1097 :             fSuccess = FALSE;

  0006b	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 1098 :             break;

  00072	e9 b4 01 00 00	 jmp	 $L53682
$L53693:

; 1099 :         }
; 1100 :         
; 1101 :         //
; 1102 :         // RIGHT channel header
; 1103 :         //
; 1104 : 
; 1105 :         dwHeader = *(LPDWORD)pbBlock;

  00077	8b 55 e8	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  0007a	8b 02		 mov	 eax, DWORD PTR [edx]
  0007c	89 45 ec	 mov	 DWORD PTR _dwHeader$[ebp], eax

; 1106 :         pbBlock += sizeof(DWORD);

  0007f	8b 4d e8	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00082	83 c1 04	 add	 ecx, 4
  00085	89 4d e8	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 1107 :         
; 1108 :         nPredSampleR = (int)(short)LOWORD(dwHeader);

  00088	8b 55 ec	 mov	 edx, DWORD PTR _dwHeader$[ebp]
  0008b	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00091	0f bf c2	 movsx	 eax, dx
  00094	89 45 f8	 mov	 DWORD PTR _nPredSampleR$[ebp], eax

; 1109 :         nStepIndexR = (int)(BYTE)HIWORD(dwHeader);

  00097	8b 4d ec	 mov	 ecx, DWORD PTR _dwHeader$[ebp]
  0009a	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0009d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000a3	89 4d cc	 mov	 DWORD PTR _nStepIndexR$[ebp], ecx

; 1110 : 
; 1111 :         if(!ValidStepIndex(nStepIndexR))

  000a6	8b 55 cc	 mov	 edx, DWORD PTR _nStepIndexR$[ebp]
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
  000af	85 c0		 test	 eax, eax
  000b1	75 0c		 jne	 SHORT $L53704

; 1112 :         {
; 1113 :             //
; 1114 :             // The step index is out of range - this is considered a fatal
; 1115 :             // error as the input stream is corrupted.  We fail by returning
; 1116 :             // zero bytes converted.
; 1117 :             //
; 1118 : 
; 1119 :             fSuccess = FALSE;

  000b3	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 1120 :             break;

  000ba	e9 6c 01 00 00	 jmp	 $L53682
$L53704:

; 1121 :         }
; 1122 : 
; 1123 :         //
; 1124 :         // Write out first sample
; 1125 :         //
; 1126 : 
; 1127 :         *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);

  000bf	8b 45 d4	 mov	 eax, DWORD PTR _nPredSampleL$[ebp]
  000c2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000c7	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _nPredSampleR$[ebp]
  000cf	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000d5	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000db	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000de	0b c1		 or	 eax, ecx
  000e0	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  000e3	89 02		 mov	 DWORD PTR [edx], eax

; 1128 :         pbDst += sizeof(DWORD);

  000e5	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  000e8	83 c0 04	 add	 eax, 4
  000eb	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax
$L53714:

; 1129 : 
; 1130 :         //
; 1131 :         // The first DWORD contains 4 left samples, the second DWORD
; 1132 :         // contains 4 right samples.  We process the source in 8-byte
; 1133 :         // chunks to make it easy to interleave the output correctly.
; 1134 :         //
; 1135 : 
; 1136 :         while(cSamples)

  000ee	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000f2	0f 84 25 01 00
	00		 je	 $L53715

; 1137 :         {
; 1138 :             dwLeft = *(LPDWORD)pbBlock;

  000f8	8b 4d e8	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  000fb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fd	89 55 d8	 mov	 DWORD PTR _dwLeft$[ebp], edx

; 1139 :             pbBlock += sizeof(DWORD);

  00100	8b 45 e8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  00103	83 c0 04	 add	 eax, 4
  00106	89 45 e8	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 1140 :             dwRight = *(LPDWORD)pbBlock;

  00109	8b 4d e8	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  0010c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010e	89 55 e0	 mov	 DWORD PTR _dwRight$[ebp], edx

; 1141 :             pbBlock += sizeof(DWORD);

  00111	8b 45 e8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  00114	83 c0 04	 add	 eax, 4
  00117	89 45 e8	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 1142 : 
; 1143 :             cSubSamples = min(cSamples, 8);

  0011a	83 7d f0 08	 cmp	 DWORD PTR _cSamples$[ebp], 8
  0011e	73 08		 jae	 SHORT $L54267
  00120	8b 4d f0	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  00123	89 4d c0	 mov	 DWORD PTR -64+[ebp], ecx
  00126	eb 07		 jmp	 SHORT $L54268
$L54267:
  00128	c7 45 c0 08 00
	00 00		 mov	 DWORD PTR -64+[ebp], 8
$L54268:
  0012f	8b 55 c0	 mov	 edx, DWORD PTR -64+[ebp]
  00132	89 55 fc	 mov	 DWORD PTR _cSubSamples$[ebp], edx

; 1144 :             
; 1145 :             for(i = 0; i < cSubSamples; i++)

  00135	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0013c	eb 09		 jmp	 SHORT $L53720
$L53721:
  0013e	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  00141	83 c0 01	 add	 eax, 1
  00144	89 45 dc	 mov	 DWORD PTR _i$[ebp], eax
$L53720:
  00147	8b 4d dc	 mov	 ecx, DWORD PTR _i$[ebp]
  0014a	3b 4d fc	 cmp	 ecx, DWORD PTR _cSubSamples$[ebp]
  0014d	0f 83 bc 00 00
	00		 jae	 $L53722

; 1146 :             {
; 1147 :                 //
; 1148 :                 // LEFT channel
; 1149 :                 //
; 1150 : 
; 1151 :                 nEncSampleL = (dwLeft & 0x0F);

  00153	8b 55 d8	 mov	 edx, DWORD PTR _dwLeft$[ebp]
  00156	83 e2 0f	 and	 edx, 15			; 0000000fH
  00159	89 55 c8	 mov	 DWORD PTR _nEncSampleL$[ebp], edx

; 1152 :                 nStepSize = m_asStep[nStepIndexL];

  0015c	8b 45 e4	 mov	 eax, DWORD PTR _nStepIndexL$[ebp]
  0015f	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[eax*2]
  00167	89 4d c4	 mov	 DWORD PTR _nStepSize$[ebp], ecx

; 1153 :                 nPredSampleL = DecodeSample(nEncSampleL, nPredSampleL, nStepSize);

  0016a	8b 55 c4	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  0016d	52		 push	 edx
  0016e	8b 45 d4	 mov	 eax, DWORD PTR _nPredSampleL$[ebp]
  00171	50		 push	 eax
  00172	8b 4d c8	 mov	 ecx, DWORD PTR _nEncSampleL$[ebp]
  00175	51		 push	 ecx
  00176	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  0017b	89 45 d4	 mov	 DWORD PTR _nPredSampleL$[ebp], eax

; 1154 :                 nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);

  0017e	8b 55 e4	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  00181	52		 push	 edx
  00182	8b 45 c8	 mov	 eax, DWORD PTR _nEncSampleL$[ebp]
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  0018b	89 45 e4	 mov	 DWORD PTR _nStepIndexL$[ebp], eax

; 1155 : 
; 1156 :                 //
; 1157 :                 // RIGHT channel
; 1158 :                 //
; 1159 : 
; 1160 :                 nEncSampleR = (dwRight & 0x0F);

  0018e	8b 4d e0	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  00191	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00194	89 4d f4	 mov	 DWORD PTR _nEncSampleR$[ebp], ecx

; 1161 :                 nStepSize = m_asStep[nStepIndexR];

  00197	8b 55 cc	 mov	 edx, DWORD PTR _nStepIndexR$[ebp]
  0019a	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  001a2	89 45 c4	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 1162 :                 nPredSampleR = DecodeSample(nEncSampleR, nPredSampleR, nStepSize);

  001a5	8b 4d c4	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  001a8	51		 push	 ecx
  001a9	8b 55 f8	 mov	 edx, DWORD PTR _nPredSampleR$[ebp]
  001ac	52		 push	 edx
  001ad	8b 45 f4	 mov	 eax, DWORD PTR _nEncSampleR$[ebp]
  001b0	50		 push	 eax
  001b1	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  001b6	89 45 f8	 mov	 DWORD PTR _nPredSampleR$[ebp], eax

; 1163 :                 nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);

  001b9	8b 4d cc	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  001bc	51		 push	 ecx
  001bd	8b 55 f4	 mov	 edx, DWORD PTR _nEncSampleR$[ebp]
  001c0	52		 push	 edx
  001c1	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  001c6	89 45 cc	 mov	 DWORD PTR _nStepIndexR$[ebp], eax

; 1164 : 
; 1165 :                 //
; 1166 :                 // Write out sample
; 1167 :                 //
; 1168 : 
; 1169 :                 *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);

  001c9	8b 45 d4	 mov	 eax, DWORD PTR _nPredSampleL$[ebp]
  001cc	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001d1	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001d6	8b 4d f8	 mov	 ecx, DWORD PTR _nPredSampleR$[ebp]
  001d9	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  001df	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  001e5	c1 e1 10	 shl	 ecx, 16			; 00000010H
  001e8	0b c1		 or	 eax, ecx
  001ea	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  001ed	89 02		 mov	 DWORD PTR [edx], eax

; 1170 :                 pbDst += sizeof(DWORD);

  001ef	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  001f2	83 c0 04	 add	 eax, 4
  001f5	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 1171 : 
; 1172 :                 //
; 1173 :                 // Shift the next input sample into the low-order 4 bits.
; 1174 :                 //
; 1175 : 
; 1176 :                 dwLeft >>= 4;

  001f8	8b 4d d8	 mov	 ecx, DWORD PTR _dwLeft$[ebp]
  001fb	c1 e9 04	 shr	 ecx, 4
  001fe	89 4d d8	 mov	 DWORD PTR _dwLeft$[ebp], ecx

; 1177 :                 dwRight >>= 4;

  00201	8b 55 e0	 mov	 edx, DWORD PTR _dwRight$[ebp]
  00204	c1 ea 04	 shr	 edx, 4
  00207	89 55 e0	 mov	 DWORD PTR _dwRight$[ebp], edx

; 1178 :             }

  0020a	e9 2f ff ff ff	 jmp	 $L53721
$L53722:

; 1179 : 
; 1180 :             cSamples -= cSubSamples;

  0020f	8b 45 f0	 mov	 eax, DWORD PTR _cSamples$[ebp]
  00212	2b 45 fc	 sub	 eax, DWORD PTR _cSubSamples$[ebp]
  00215	89 45 f0	 mov	 DWORD PTR _cSamples$[ebp], eax

; 1181 :         }

  00218	e9 d1 fe ff ff	 jmp	 $L53714
$L53715:

; 1182 : 
; 1183 :         //
; 1184 :         // Skip padding
; 1185 :         //
; 1186 : 
; 1187 :         pbSrc += nBlockAlignment;

  0021d	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  00220	03 4d 14	 add	 ecx, DWORD PTR _nBlockAlignment$[ebp]
  00223	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 1188 :     }

  00226	e9 e2 fd ff ff	 jmp	 $L53681
$L53682:

; 1189 : 
; 1190 :     return fSuccess;

  0022b	8b 45 d0	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 1191 : }

  0022e	8b e5		 mov	 esp, ebp
  00230	5d		 pop	 ebp
  00231	c2 1c 00	 ret	 28			; 0000001cH
?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::DecodeS16
_TEXT	ENDS
END
