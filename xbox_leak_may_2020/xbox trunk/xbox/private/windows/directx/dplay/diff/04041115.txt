-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpsvr8.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dnet.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 46 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dplay.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lastsync.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\search.out	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\bilink.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\common.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\dndbg.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\dneterrors.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\fpm.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\guidutil.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\map.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\osind.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\packbuff.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\queue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\rcbuffer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\appdesc.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\async.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\caps.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\client.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\common.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\connect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\connection.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\disconnect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dnet.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\enum_sp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\groupcon.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\groupmem.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\handles.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\memoryfpm.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\message.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\migration.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\msghandler.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\nametable.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\ntentry.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\ntoplist.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\paramval.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\peer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\pools.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\protocol.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\receive.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\request.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\server.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\servprov.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\spmessages.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\user.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\voice.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\worker.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addbase.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addcore.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addint.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addparse.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addtcp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dnadd.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dplegacy.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\strcache.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\strutils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvlib.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvlib.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvrq.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpsvr8.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\proctbl.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplapp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplclient.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplcommon.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplconnect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplmsgq.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplobby.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplproc.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplreg.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\handles.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\backend.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\command.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\connect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\endpt.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\enum.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\initialize.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\lower_mn.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\protocol.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\receive.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\send.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\stub_mn.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\timer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\cmddata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\debugutils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dnwsock.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dwinsock.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\endpoint.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\iodata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipaddress.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipendpt.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipui.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\jobqueue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\locals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\pools.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\rsip.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\sendqueue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\socketport.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\spaddress.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\spdata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\threadpool.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\unk.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\utils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\wsocksp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 233 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,104
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
133a138
> 	OSVERSIONINFO	OSVersionInfo;
134a140
> 
142a149,159
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
155a173,176
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
255a277,278
> 		switch ( DNGetOSType() )
> 		{
258a282,283
> 			case VER_PLATFORM_WIN32_NT:
> 			{
282a308,318
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
309a346,361
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90,97
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
68a69
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
223a224,243
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38c38
< //#include "CReg.h"
---
> #include "CReg.h"
73,77d72
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate service providers
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
238d232
< */	return(E_FAIL);
252,256d245
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
405d393
< */	return(E_FAIL);
623d610
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
375a376,379
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpsvr8.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
300d299
<     DWORD dwProvider = 0;
342c341
<     for( dwProvider = 0; dwProvider < dwSPCount; dwProvider++ )
---
>     for( DWORD dwProvider = 0; dwProvider < dwSPCount; dwProvider++ )
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62,65
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
77a82
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
156c161
<     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;    
---
>     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;
242c247
< #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)              
---
> #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)
388,389c393,395
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
447a454
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
76,77d75
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
111a110,112
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
244c245
<     DWORD   dwMaxDatagramLength;
---
>     DWORD	dwMaxDatagramLength;
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
187a188,206
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
36c36
< //#include "CReg.h"
---
> #include "CReg.h"
92,97c92
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
<     HRESULT			hResultCode;
---
> 	HRESULT			hResultCode;
381d375
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
25c25
< //#include "CReg.h"
---
> #include "CReg.h"
67,71d66
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
254d248
< */ return(E_FAIL);
275,279d268
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
567d555
< */	return(E_FAIL);
1303d1290
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
14a15
> #include <wsipx.h>
18a20,23
> //
> // comment out the follwing #define to prevent loading Winsock2
> //
> #define	LOAD_WINSOCK2
30c35,41
< static BOOL MapFunctionPointers(HINSTANCE hndlWinSock);
---
> static BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2);
> static int  FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 							  LPDWORD pdwBufLen);
> static int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
34c45
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock)
---
> int DWSInitWinSock(LPDWSSTATE lpState)
36a48
> 	BOOL f2Loaded = TRUE;
39a52,53
> 	if (lpState == NULL)
> 		return 0;
43,44c57,59
< 	*lphndlWinSock = LoadLibrary("WS2_32.DLL");
< 	if (*lphndlWinSock == NULL)
---
> #ifdef	LOAD_WINSOCK2
> 	lpState->hndlWinSock = LoadLibrary("WS2_32.DLL");
> 	if (lpState->hndlWinSock == NULL)
45a61
> #endif	// LOAD_WINSOCK2
47c63
< 		// Couldn't load WinSock 2
---
> 		// Couldn't load WinSock 2, try 1.1
49c65,69
< 			return FALSE;
---
> 		f2Loaded = FALSE;
> 		lpState->hndlWinSock = LoadLibrary("WSOCK32.DLL");
> 		if (lpState->hndlWinSock == NULL)
> 			return 0;
> #ifdef	LOAD_WINSOCK2
50a71
> #endif	// LOAD_WINSOCK2
56,57c77,78
< 	if (!MapFunctionPointers(*lphndlWinSock))
< 		return FALSE;
---
> 	if (!MapFunctionPointers(lpState, f2Loaded))
> 		return 0;
60c81
< 	// Ask for 2.2
---
> 	// If WinSock 2 was loaded, ask for 2.2 otherwise 1.1
61a83
> 	if (f2Loaded)
62a85,86
> 	else
> 		wVersionRequested = MAKEWORD(1,1);
70,71c94,95
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
76,77c100,101
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
80c104,111
< 	return(TRUE);
---
> 	// Save Max UDP for use with 1.1
> 	lpState->nMaxUdp = wsaData.iMaxUdpDg;
> 
> 	//
> 	// Return 1 or 2
> 	//
> 	lpState->nVersion = f2Loaded ? 2 : 1;
> 	return(lpState->nVersion);
85c116
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock)
---
> BOOL DWSFreeWinSock(LPDWSSTATE lpState)
86a118,120
> 	if (lpState == NULL)
> 		return FALSE;
> 
89c123,124
< 	return(FreeLibrary(hndlWinSock));
---
> 	lpState->nVersion = 0;
> 	return(FreeLibrary(lpState->hndlWinSock));
94c129
< BOOL MapFunctionPointers(HINSTANCE hndlWinSock)
---
> BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2)
95a131,133
> 	// we set the local lib handle for use with the
> 	//	macros
> 	HINSTANCE	hndlWinSock = lpState->hndlWinSock;
115c153
< 	if (fOK)
---
> 	if (fOK && fMapVersion2)
121a160,710
> ////////////////////////////////////////////////////////////
> 
> int DWSVersion(LPDWSSTATE lpState)
> {
> 	return lpState->nVersion;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket)
> {
> 	int nOptVal;
> 	int nOptLen;
> 	int nRet;
> 
> 	//
> 	// If WinSock isn't loaded
> 	// return 0
> 	//
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// If we're using WinSock 1.1
> 	// return the previously saved
> 	// info from WSADATA
> 	//
> 	if (lpState->nVersion == 1)
> 		return lpState->nMaxUdp;
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 
> 	//
> 	// Use getsockopt() to find
> 	// the max message size for
> 	// this socket
> 	//
> 	nOptLen = sizeof(int);
> 	nRet = p_getsockopt(socket,
> 					  SOL_SOCKET,
> 					  SO_MAX_MSG_SIZE,
> 					  (char *)&nOptVal,
> 					  &nOptLen);
> 	if (nRet == SOCKET_ERROR)
> 		return SOCKET_ERROR;
> 	return nOptVal;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr, LPDWORD pdwStrLen)
> {
> 	LPTSTR			lpStr;
> 	LPSOCKADDR_IN	pInAddr;
> 	int				nRet = 0;
> 
> 	lpAddrStr[0] = '\0';
> 
> 	//
> 	// If WinSock isn't loaded, return 1
> 	//
> 	if (lpState->nVersion == 0)
> 		return 1;
> 
> 	//
> 	// If using WinSock 1.1 then assume IP
> 	//
> 	if (lpState->nVersion == 1)
> 	{
> 		//
> 		// Convert address with inet_ntoa
> 		//
> 		pInAddr = (LPSOCKADDR_IN)pAddr;
> 		lpStr = p_inet_ntoa(pInAddr->sin_addr);
> 		if (lpStr == NULL)
> 		{
> 			p_WSASetLastError(WSAEINVAL);
> 			*pdwStrLen = 0;
> 			return SOCKET_ERROR;	
> 		}
> 		#ifdef UNICODE
> 			//
> 			// Convert inet_ntoa string to wide char
> 			//
> 			nRet = MultiByteToWideChar(CP_ACP,
> 										0,
> 										lpStr,
> 										-1,
> 										lpAddrStr,
> 										*pdwStrLen);
> 			if (nRet == 0)
> 			{
> 				if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
> 					p_WSASetLastError(WSAEFAULT);
> 				else
> 					p_WSASetLastError(WSAEINVALID);
> 				return SOCKET_ERROR;
> 			}
> 		#else
> 			//
> 			// ANSI -- Check the string length
> 			//
> 			if (strlen(lpStr) > *pdwStrLen)
> 			{
> 				p_WSASetLastError(WSAEFAULT);
> 				*pdwStrLen = strlen(lpStr);
> 				return SOCKET_ERROR;
> 			}
> 			strcpy(lpAddrStr, lpStr);
> 			*pdwStrLen = strlen(lpStr);
> 			return 0;
> 		#endif
> 	}
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 	nRet = p_WSAAddressToString(pAddr,
> 							    dwAddrLen,
> 							    NULL,
> 							    lpAddrStr,
> 							    pdwStrLen);
> 	//
> 	// Check for "unsupported" families
> 	//
> 	if (nRet == SOCKET_ERROR && p_WSAGetLastError() == WSAEOPNOTSUPP)
> 	{
> 		if (pAddr->sa_family == AF_IPX)
> 		{
> 			nRet = IPXAddressToString((LPSOCKADDR_IPX) pAddr,
> 									  dwAddrLen,
> 									  lpAddrStr,
> 									  pdwStrLen);
> 		}
> 	}
> 	return nRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					 LPDWORD pdwBufLen)
> {
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	if (lpState->nVersion == 1)
> 		return(FakeEnumProtocols(lpState, lpProtocolBuffer,
> 								 pdwBufLen));
> 	//
> 	// Must be WinSock 2
> 	//
> 	return(p_WSAEnumProtocols(NULL,
> 							 lpProtocolBuffer,
> 							 pdwBufLen));
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					  LPDWORD pdwBufLen)
> {
> 	WSAPROTOCOL_INFO FakeTcp;
> 	WSAPROTOCOL_INFO FakeUdp;
> 	LPWSAPROTOCOL_INFO lpInfo;
> 
> 	//
> 	// Assume WinSock 1.1, we're returning
> 	// 2 WSAPROTOCOL_INFO structures.
> 	// 1 for TCP, 1 for UDP
> 	//
> 
> 	//
> 	// Check the buffer size
> 	//
> 	if (*pdwBufLen < (sizeof(WSAPROTOCOL_INFO)*2))
> 	{
> 		*pdwBufLen = (sizeof(WSAPROTOCOL_INFO)*2);
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Build fake TCP entry
> 	//
> 	memset(&FakeTcp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeTcp.dwServiceFlags1 = XP1_GUARANTEED_DELIVERY	|
> 							  XP1_GUARANTEED_ORDER		|
> 							  XP1_GRACEFUL_CLOSE		|
> 							  XP1_EXPEDITED_DATA;
> 	FakeTcp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeTcp.dwCatalogEntryId= 1;;
> 	FakeTcp.iVersion		= 1;
> 	FakeTcp.iAddressFamily  = AF_INET;
> 	FakeTcp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iSocketType		= SOCK_STREAM;
> 	FakeTcp.iProtocol		= IPPROTO_TCP;
> 	FakeTcp.iNetworkByteOrder = BIGENDIAN;
> 	FakeTcp.dwMessageSize	= 0;
> 	_tcscpy(FakeTcp.szProtocol, _TEXT("tcp"));
> 
> 	//
> 	// Build fake UDP entry
> 	//
> 	memset(&FakeUdp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeUdp.dwServiceFlags1 = XP1_CONNECTIONLESS		|
> 							  XP1_MESSAGE_ORIENTED		|
> 							  XP1_SUPPORT_BROADCAST;		
> 							  // Might want to add multipoint
> 	FakeUdp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeUdp.dwCatalogEntryId= 2;;
> 	FakeUdp.iVersion		= 1;
> 	FakeUdp.iAddressFamily  = AF_INET;
> 	FakeUdp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iSocketType		= SOCK_DGRAM;
> 	FakeUdp.iProtocol		= IPPROTO_UDP;
> 	FakeUdp.iNetworkByteOrder = BIGENDIAN;
> 	FakeUdp.dwMessageSize	= lpState->nMaxUdp;	// The reason this can't be static
> 	_tcscpy(FakeUdp.szProtocol, _TEXT("udp"));
> 
> 	//
> 	// Copy the fake entries to the supplied buffer
> 	lpInfo = lpProtocolBuffer;
> 	memcpy(lpInfo, &FakeTcp, sizeof(WSAPROTOCOL_INFO));
> 	lpInfo++;
> 	memcpy(lpInfo, &FakeUdp, sizeof(WSAPROTOCOL_INFO));
> 
> 	//
> 	// Returning 2 protocols
> 	//	
> 	return 2;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSSelectProtocols( LPDWSSTATE lpState,
> 					DWORD dwSetFlags,
> 					DWORD dwNotSetFlags,
> 					LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					LPDWORD lpdwBufferLength
> 					)
> {
> 	LPBYTE				pBuf;
> 	LPWSAPROTOCOL_INFO	pInfo;
> 	DWORD				dwNeededLen;
> 	LPWSAPROTOCOL_INFO	pRetInfo;
> 	DWORD				dwRetLen;
> 	int					nCount;
> 	int					nMatchCount;
> 	int					nRet;
> 
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// Determine needed buffer size
> 	//
> 	dwNeededLen = 0;
> 	nRet = DWSEnumProtocols(lpState, NULL, &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAENOBUFS)
> 			return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Allocate the buffer
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwNeededLen) );
> 	if (pBuf == NULL)
> 	{
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Make the "real" call
> 	//
> 	nRet = DWSEnumProtocols(lpState, (LPWSAPROTOCOL_INFO)pBuf,
> 							 &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Helper macros for selecting protocols
> 	//
> 	#define REJECTSET(f) \
> 	    ((dwSetFlags & f) && !(pInfo->dwServiceFlags1 & f))
> 	#define REJECTNOTSET(f) \
> 	    ((dwNotSetFlags &f) && (pInfo->dwServiceFlags1 & f))
> 	#define REJECTEDBY(f) (REJECTSET(f) || REJECTNOTSET(f))
> 
> 	//
> 	// Loop through the protocols making selections
> 	//
> 	pInfo = (LPWSAPROTOCOL_INFO)pBuf;	
> 	pRetInfo = lpProtocolBuffer;
> 	dwRetLen = 0;
> 	nMatchCount = 0;
> 	for(nCount = 0; nCount < nRet; nCount++)
> 	{
> 		//
> 		// Check all of the requested flags
> 		//
> 		while(1)
> 		{
> 			if (REJECTEDBY(XP1_CONNECTIONLESS))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_DELIVERY))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_ORDER))
> 				break;
> 			if (REJECTEDBY(XP1_MESSAGE_ORIENTED))
> 				break;
> 			if (REJECTEDBY(XP1_PSEUDO_STREAM))
> 				break;
> 			if (REJECTEDBY(XP1_GRACEFUL_CLOSE))
> 				break;
> 			if (REJECTEDBY(XP1_EXPEDITED_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_CONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_DISCONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_BROADCAST))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_MULTIPOINT))
> 				break;
> 			if (REJECTEDBY(XP1_MULTIPOINT_DATA_PLANE))
> 				break;
> 			if (REJECTEDBY(XP1_QOS_SUPPORTED))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_SEND))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_RECV))
> 				break;
> 			if (REJECTEDBY(XP1_IFS_HANDLES))
> 				break;
> 			if (REJECTEDBY(XP1_PARTIAL_MESSAGE))
> 				break;
> 			//
> 			// If we made it here,
> 			//the protocol meets all requirements
> 			//
> 			dwRetLen += sizeof(WSAPROTOCOL_INFO);
> 			if (dwRetLen > *lpdwBufferLength)
> 			{
> 				// The supplied buffer is too small
> 				p_WSASetLastError(WSAENOBUFS);
> 				*lpdwBufferLength = dwNeededLen;
> 				DNFree(pBuf);
> 				return SOCKET_ERROR;
> 			}
> 			nMatchCount++;
> 			// Copy this protocol to the caller's buffer
> 			memcpy(pRetInfo, pInfo, sizeof(WSAPROTOCOL_INFO));
> 			pRetInfo++;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	*lpdwBufferLength = dwRetLen;
> 	return(nMatchCount);
> }
> 
> ////////////////////////////////////////////////////////////
> 
> BOOL DWSDnsOnly(LPDWSSTATE lpState)
> {
> 	//
> 	// Return TRUE if DNS is the only name space provider
> 	//
> 
> 	LPWSANAMESPACE_INFO pInfo;
> 	DWORD				dwBufLen;
> 	PBYTE				pBuf;
> 	int					nCount;
> 	BOOL				fRet = TRUE;
> 	int					nRet;
> 
> 	//
> 	// If we're running on WinSock 1.1 return TRUE
> 	//
> 	if (lpState->nVersion == 1)
> 		return fRet;
> 
> 	// WinSock 2
> 
> 	//
> 	// Intentionally generate an error
> 	// to get the required buffer size
> 	//
> 	dwBufLen = 0;
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen, NULL);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAEFAULT)
> 			return fRet;
> 	}
> 
> 	//
> 	// dwBufLen now equals needed size
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwBufLen+1) );
> 	if (pBuf == NULL)
> 		return fRet;
> 
> 	//
> 	// Now, make the "real" call
> 	//
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen,
> 									   (LPWSANAMESPACE_INFO)pBuf);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return fRet;
> 	}
> 
> 	pInfo = (LPWSANAMESPACE_INFO)pBuf;
> 	for (nCount = 0; nCount < nRet; nCount++)
> 	{
> 		if (pInfo->dwNameSpace != NS_DNS)
> 		{
> 			fRet = FALSE;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	return fRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> char NibbleToHex(BYTE b)
> {
>     if (b < 10)
> 		return (b + '0');
> 
>     return (b - 10 + 'A');
> }
> 
> void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr)
> {
> 	BYTE b;
>     while(nNbrBytes--)
>     {
> 		// High order nibble first
> 		b = (*pBytes >> 4);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		// Then low order nibble
> 		b = (*pBytes & 0x0F);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		pBytes++;
>     }
>     *lpStr = '\0';
> }
> 
> ////////////////////////////////////////////////////////////
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
>     strcat(szAddr, ":");
> 
> 	// IPX Address Socket number
>     BinToHex((PBYTE)&pAddr->sa_socket, 2, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
> 
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	LPSOCKADDR_IPX pAddr = (LPSOCKADDR_IPX) pSAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17,18c17,42
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock);
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock);
---
> // added to support multiple instantiation/initialization
> typedef struct _DWSSTATE
> {
> 	HINSTANCE	hndlWinSock;
> 	int			nVersion;
> 	int			nMaxUdp	;
> } DWSSTATE, *LPDWSSTATE;
> 
> 
> int  DWSInitWinSock(LPDWSSTATE lpState);
> BOOL DWSFreeWinSock(LPDWSSTATE lpState);
> int  DWSVersion(LPDWSSTATE lpState);
> int  DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket);
> int  DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 						LPSTR lpAddrStr, LPDWORD pdwStrLen);
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
> int  DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 		   			  LPDWORD pdwBufLen);
> int  DWSSelectProtocols(LPDWSSTATE lpState, DWORD dwSetFlags,
> 					    DWORD dwNotSetFlags,
> 					    LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					    LPDWORD lpdwBufferLength);
> BOOL DWSDnsOnly(LPDWSSTATE lpState);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
41a43
> #include	"IPXAddress.h"
76c78,79
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
94a98,99
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
110c115,117
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
176a184,189
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
197a211,217
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
200a221,266
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown state
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.x, or higher
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
223a290,291
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
242a311,312
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
269a340,345
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
387a464,470
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
390a474,518
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.X or greater
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
422a551,552
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
442a573,574
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
115a116,118
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
145a149
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
146a151
> 
166a172,174
> 
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1372a1374,1379
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1373a1381,1399
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1376a1403,1405
> 		case 2:
> 		default:
> 		{
1377a1407,1409
> 			break;
> 		}
> 	}
1451a1484,1489
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1452a1491,1509
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1455a1513,1515
> 		case 2:
> 		default:
> 		{
1456a1517,1519
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
59a61
> #include	"IPXAddress.h"
63a66
> #include	"IPXEndpt.h"
93a97
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
94a99
> static	CFixedPool< CIPXEndpoint >	*g_pIPXEndpointPool = NULL;
185a191,197
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
195a208,214
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CFixedPool< CIPXEndpoint >;
> 	if ( g_pIPXEndpointPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
314a334,339
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
323a349,354
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
431a463,476
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
432a478
> 
434a481,497
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
464a528,559
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( void )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXEndpoint - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint )
> {
> 	DNASSERT( pIPXEndpoint != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXEndpointPool->Release( pIPXEndpoint );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
57a60,62
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
59a65,67
> 
> CIPXEndpoint	*CreateIPXEndpoint( void );
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
248a250,251
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
249a253,270
> 		// something's not right!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// winsock 1.x
> 		//
> 		case 1:
> 		{
> 			m_pSendFunction = Winsock1Send;
> 			break;
> 		}
> 
> 		//
251a273,275
> 		case 2:
> 		default:
> 		{
252a277,279
> 			break;
> 		}
> 	}
382a410,432
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( LOWORD( GetWinsockVersion() ) == 1 )
> 		{
> //			HRESULT	hTempResult;
> 			THREAD_POOL_JOB	*pTemp;
> 
> 
> 			pTemp = m_pRemoveSocketPortData;
> 			m_pRemoveSocketPortData = NULL;
> 			INT3;
> //			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> //			if ( hTempResult != DPN_OK )
> //			{
> //				DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> //				DisplayDNError( 0, hTempResult );
> //			}
> 		}
> 
739a790,802
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
741a805,911
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			ReturnReceiveBuffer( pReadData->m_pReceiveBuffer );
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
742a913,915
> 
> 
> //**********************************************************************
743a917,1065
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
771,772c1093,1094
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
783a1106,1108
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
836a1162,1164
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
914c1242,1243
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
928a1258,1260
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
993a1326,1327
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1041a1376,1377
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1297a1634,1640
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1331a1675,1676
> 			break;
> 		}
1332a1678,1757
> 		//
> 		// we're on Win9x, ask work thread to submit a read
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// invalid version
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// Winsock 1.x
> 				//
> 				case 1:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					DNASSERT( m_pRemoveSocketPortData == NULL );
> 					INT3;
> //					hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> //					if ( hr != DPN_OK )
> //					{
> //						DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> //						DisplayDNError( 0, hr );
> //						goto Failure;
> //					}
> 					DNASSERT( m_pRemoveSocketPortData != NULL );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2.x or greater
> 				//
> 				case 2:
> 				default:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					hr = m_pThreadPool->SubmitDelayedCommand( InitialWin9xWinsock2Read, CancelInitialWin9xWinsock2Read, this );
> 					if ( hr != DPN_OK )
> 					{
> 						DPF( 0, "Failed to submit initial Win9x Winsock2 read for SocketPort!" );
> 						DisplayDNError( 0, hr );
> 						goto Failure;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
1829a2255,2266
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
1830a2268,2271
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
1831a2273,2417
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			ReturnReceiveBuffer( pReadData->m_pReceiveBuffer );
> 			DEBUG_ONLY( pReadData->m_pReceiveBuffer = NULL );
> 
> 			goto Exit;
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// One of our previous sends blew chunks for some unknown reason,
> 				// and Winsock is being a pain and telling us on our completely
> 				// unreleated receive thread.  Ignore this and continue  because
> 				// another read was submitted.
> 				//
> 				case WSAECONNRESET:
> 				{
> 					DPF( 8, "Winsock indicated an earlier send failed....." );
> 					break;
> 				}
> 
> 				//
> 				// other error, report it (we've already submitted another read)
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock2 Win9x read: " );
> 					DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			ReturnReceiveBuffer( pReadData->m_pReceiveBuffer );
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
1832a2419,2421
> 
> 
> //**********************************************************************
2098a2688,2746
> //**********************************************************************
> // ------------------------------
> // CSocketPort::InitialWin9xWinsock2Read - perform initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	HRESULT			hr;
> 	CSocketPort		*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	hr = pThisSocketPort->Winsock2Receive();
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Problem with initial read on socket port!" );
> 		DisplayDNError( 0, hr );
> 	}
> 
> 	//
> 	// release the reference for the pending command
> 	//
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::CancelInitialWin9xWinsock2Read - cancel initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	CSocketPort	*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 
> 	INT3;
> 	//
> 	// Since this command was for the worker thread and won't be processed,
> 	// remove the socket port reference created for this action.
> 	//
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
225a226
> 
270a272,273
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
274a278,280
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
308a315
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
313a321,322
> 		static	void	InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
> 		static	void	CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
92a93,94
> 	 IPXAddress.cpp \
> 	 IPXEndpt.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100c100
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
118c118,119
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
153c154,155
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
238a241
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
239a243
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
242c246
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
249c253
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
268a273
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
46a48
> #include	"IPXAddress.h"
52a55
> #include	"IPXEndpt.h"
182a186,251
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
285d353
< 
488a557,562
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint();
>     		break;
>     	}
> 
541a616,621
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXEndpoint( static_cast<CIPXEndpoint*>( pEndpoint ) );
>     		break;
>     	}
> 
678a759,764
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
711a798,803
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
89c91
< 		void		SetThreadPool( CThreadPool *const pThreadPool )
---
> 		void	SetThreadPool( CThreadPool *const pThreadPool )
93a96
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
132a134,157
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwWaitHandleCount;					// count of handles to wait on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
169a195
> 		m_iWinsockVersion( 0 ),
198a225
> 	DNASSERT( m_iWinsockVersion == 0 );
223c250
< HRESULT	CThreadPool::Initialize( void )
---
> HRESULT	CThreadPool::Initialize( const INT_PTR iWinsockVersion )
235a263
> 	m_iWinsockVersion = iWinsockVersion;
254c282,292
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
255a294,301
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
262c308,318
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
263a320,325
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
264a327
> 
362a426,432
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
368a439,465
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
464a562,721
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
> 		//
> 		// Winsock2, use events to signal I/O completion
> 		//
> 		case 2:
> 		{
> 			DNASSERT( m_hWinsock2SendComplete == NULL );
> 			m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 												   TRUE,	// manual reset
> 												   FALSE,	// start unsignalled
> 												   NULL		// pointer to name (none)
> 												   );
> 			if ( m_hWinsock2SendComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Send!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 			m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 													  TRUE,		// manual reset
> 													  FALSE,	// start unsignalled
> 													  NULL		// pointer to name (none)
> 													  );
> 			if ( m_hWinsock2ReceiveComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Receive!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, nothing special to do
> 		//
> 		case 1:
> 		{
> 			break;
> 		}
> 
> 		default:
> 		{
> 			INT3;
> 		}
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	//
> 	// note that we've started a thread
> 	//
> 	m_iTotalThreadCount++;
> 	DNASSERT( m_iNTCompletionThreadCount == 0 );
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
563a821,822
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
584a844
> 	}
662a923,928
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
678a945,946
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
839a1108,1109
> 
> 	m_iWinsockVersion = 0;
1272a1543,1549
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, submit new I/O completion item
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1289a1567,1600
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				hr = DPNERR_GENERIC;
> 				dwError = GetLastError();
> 				DPF( 0, "Cannot set event for pending job!" );
> 				DisplayErrorCode( 0, dwError );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1385a1697,1698
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1392a1706
> 	}
1645a1960,1976
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
> 		// WinNT has many potential threads
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1647a1979,1980
> 			break;
> 		}
1648a1982,1991
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1677a2021,2022
> 	switch ( DNGetOSType() )
> 	{
1678a2024,2031
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1681a2035,2036
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1691a2047,2059
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
2132a2501,2513
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
2134a2516,2517
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
2135a2519,2528
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
2137a2531,2535
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
2138a2537,2614
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
2139a2616,2618
> 
> 
> //**********************************************************************
2140a2620,3298
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 	TIMEVAL				SelectTimeout = { 0 };
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			DPF( 0, "Failed to initialize COM!" );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> 	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> 	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	CoreData.dwWaitHandleCount = 2;
> 
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) &&
> 		 ( LOWORD( GetWinsockVersion() ) >= 2 ) )
> 	{
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.dwWaitHandleCount >= ( EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE + 1 ) );
> 	}
> 
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		//
> 		// Since only this thread can modify m_SocketSet.fd_count, there's no
> 		// need to take a critical section to read it!
> 		//
> 		if ( pSocketSet->fd_count == 0 )
> 		{
> 			DWORD	dwWaitReturn;
> 
> 
> 			//
> 			// There are no sockets active.  Wait for the SP to close, a job
> 			// to be submitted, or a timeout for enumeration.
> 			//
> 			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> //			dwElapsedTime = GetTickCount();
> 
> 			DNTimeGet( &CurrentTime );
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active enums left when enuming with no Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> 
> #pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> 			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> 
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,		// count of handles
> 													 CoreData.hWaitHandles,				// handles to wait on
> 													 FALSE,								// don't wait for all to be signalled
> 													 dwMaxWaitTime,						// wait timeout
> 													 TRUE								// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// timeout, don't do anything, we'll probably process enums on the next loop
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// New job.  Account for the time spent in the wait.  Don't
> 				// account for time after the job is complete because it's
> 				// possible that the job was an enum submission which will want
> 				// to reset the wait time.
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 send complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending write list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 send event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingSends();
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 receive complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending read list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 receive event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingReceives();
> 					break;
> 				}
> 
> 				//
> 				// There are I/O completion routines scheduled on this thread,
> 				// no problem.
> 				//
> 				case WAIT_IO_COMPLETION:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// wait failed
> 				//
> 				case WAIT_FAILED:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> 					DisplayDNError( 0, dwError );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> 					DisplayDNError( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		} // if ( CoreData.dwActiveSocketCount == 0 )
> 		else
> 		{
> 			INT				iSelectReturn;
> 			DWORD			dwWaitReturn;
> 			FD_SET			ReadSocketSet;
> 			FD_SET			WriteSocketSet;
> 			FD_SET			ErrorSocketSet;
> 
> 
> 			//
> 			// Update the enum time so we know how long to wait.  We can
> 			// only get here if a socket was just added to the socket list, or
> 			// we've been servicing sockets.
> 			//
> 
> 			DNTimeGet( &CurrentTime );
> 
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active enums left when enuming with Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 			//
> 			// Wait for something to happen on a socket or wait for next enum
> 			// service.  We're supposed to pass select times in microseconds,
> 			// but multiplying by 1000 is slower than letting the compiler
> 			// get fancy with multiplying by 1024, and the relative error
> 			// is negligible.
> 			//
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> 			}
> 			else
> 			{
> 				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> 			}
> 
> 			//
> 			// Make a local copy of all of the sockets.  This isn't totally
> 			// efficient, but it works.  Multiplying by active socket count will
> 			// spend half the time in the integer multiply.
> 			//
> 			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> 			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> 			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> 
> 			DNASSERT( SelectTimeout.tv_sec == 0 );
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  &ReadSocketSet,	// sockets to check for read
> 									  NULL,				// sockets to check for write (don't check writes)
> 									  &ErrorSocketSet,	// sockets to check for error
> 									  &SelectTimeout	// wait timeout
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// This socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting all sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing read service and error service.
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// check for writes only
> 			//
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  NULL,				// sockets to check for read (don't check reads)
> 									  &WriteSocketSet,	// sockets to check for write
> 									  NULL,				// sockets to check for error (don't check errors)
> 									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					INT3;
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// this socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting write sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing write service
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// since we just serviced sockets, make a quick check for pending
> 			// events
> 			//
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,	// count of handles
> 													 CoreData.hWaitHandles,			// handles to wait on
> 													 FALSE,							// don't wait for all to be signalled
> 													 0,								// make a quick check
> 													 TRUE							// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// nothing was signalled, keep looping
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// pending job
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock 2 I/O complete, we should not be getting this if
> 				// we're using Winsock1 support!!!
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Win9x wait for events with sockets active failed!" );
> 					DisplayErrorCode( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2491a3650,3660
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
2492a3662,3788
> 
> 	//
> 	// remove and process a single job from the list
> 	//
> 	pJobInfo = GetWorkItem();
> 	DNASSERT( pJobInfo != NULL );
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshEnum.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// start monitoring a port for I/O
> 		//
> 		case JOB_ADD_WIN9X_SOCKET:
> 		{
> 			DPF( 8, "WorkThread job ADD_SOCKET" );
> 
> 			//
> 			// add this port to the ends of the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> 			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> 			m_SocketSet.fd_count++;
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// stop monitoring a port for I/O
> 		//
> 		case JOB_REMOVE_WIN9X_SOCKET:
> 		{
> 			UINT_PTR	uIdx;
> 
> 
> 			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> 
> 			//
> 			// remove this port from the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_uReservedSocketCount != 0 );
> 			uIdx = m_SocketSet.fd_count;
> 			DNASSERT( uIdx != 0 );
> 			do
> 			{
> 				uIdx--;
> 
> 				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> 				{
> 					m_uReservedSocketCount--;
> 					m_SocketSet.fd_count--;
> 
> 					//
> 					// release our I/O reference to this item and shift all other entries down in
> 					// the socket array
> 					//
> 					m_pSocketPorts[ uIdx ]->DecRef();
> 					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 
> 					//
> 					// clear last entry (which is now unused) in the debug build
> 					//
> 					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> 					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> 
> 					//
> 					// end the loop.
> 					//
> 					uIdx = 0;
> 				}
> 			} while ( uIdx != 0 );
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> }
2493a3790,3792
> 
> 
> //**********************************************************************
2738a4038,4039
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
101c102
< 		HRESULT	Initialize( void );
---
> 		HRESULT	Initialize( const INT_PTR iWinsockVersion );
106c107,108
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
152a155
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
157a161
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
189a194
> 		INT_PTR	m_iWinsockVersion;				// version of available Winsock
229,231c234,236
< 		UINT_PTR	m_uReservedSocketCount;			// count of sockets that are 'reserved' for use
< 		FD_SET		m_SocketSet;					// set of all sockets in use
< 		CSocketPort	*m_pSocketPorts[ FD_SETSIZE ];	// set of corresponding socket ports
---
> 		UINT_PTR			m_uReservedSocketCount;			// count of sockets that are 'reserved' for use
> 		FD_SET				m_SocketSet;					// set of all sockets in use
> 		CSocketPort 		*m_pSocketPorts[ FD_SETSIZE ];	// set of corresponding socket ports
273a279
> 		HRESULT	Win9xInit( void );
290a297,298
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
291a300
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
298a308
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
65c65,94
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
126a156,245
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
228a348
> //	we can either create an IPX instance or an IP instance
234a355,358
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
265c389,390
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
69a71
> 
71a74
> 
73c76
< static	CRsip		*g_pRsipObject = NULL;
---
> static	CRsip			*g_pRsipObject = NULL;
74a78
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
76,77d79
< static	HINSTANCE g_hndlWinSock;		// state info for the WS1/2 glue lib
< 
102a105
> 	INT		iVersion;
130c133,134
< 	if ( FALSE == DWSInitWinSock( &g_hndlWinSock ) )	// failure
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
137a142,143
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
150,151c156
< 		fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 		g_hndlWinSock = NULL;
---
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
192,193c197
< 	fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 	g_hndlWinSock = NULL;
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
204a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
205a223
> 
303a322
> 	INT_PTR iWinsockVersion;
330c349
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize( iWinsockVersion );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
245a247
> 		case TYPE_IPX:
479,480c481,483
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
2660a2664,2675
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2873a2889,2900
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
3036d3062
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.  
