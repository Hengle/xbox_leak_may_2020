-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\search.out	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dnet.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 46 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\build.err	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dplay.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\bilink.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\common.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\dndbg.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\dneterrors.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\fpm.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\guidutil.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\map.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\osind.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\packbuff.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\queue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\rcbuffer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\appdesc.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\cancel.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\caps.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\client.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\connect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\connection.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\disconnect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dnet.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\enum_sp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\groupcon.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\groupmem.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\handles.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\memoryfpm.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\message.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\migration.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\msghandler.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\nametable.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\ntentry.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\ntoplist.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\peer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\pools.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\protocol.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\receive.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\request.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\server.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\servprov.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\spmessages.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\worker.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addbase.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addcore.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addint.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addparse.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addtcp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dnadd.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dplegacy.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\strcache.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\strutils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvlib.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvlib.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvrq.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpsvr8.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\proctbl.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplapp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplclient.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplcommon.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplconnect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplmsgq.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplobby.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplproc.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplreg.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\handles.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\backend.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\command.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\connect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\endpt.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\enum.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\initialize.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\lower_mn.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\protocol.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\receive.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\send.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\stub_mn.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\timer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\build.err	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\directx.ico	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\dxutil.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\dxutil.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\resource.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\simplepeer.rc	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\cmddata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\debugutils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dnwsock.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dwinsock.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\endpoint.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\iodata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipaddress.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipendpt.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipui.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\jobqueue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\locals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\pools.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\registry.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\rsip.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\sendqueue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\socketport.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\spaddress.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\spdata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\threadpool.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\unk.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\utils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\wsocksp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\build.err	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\search.out	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.bsc	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.ilk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.sbr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\vc60.idb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\vc60.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\i386\simplepeer.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\i386\simplepeer.map	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\i386\simplepeer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\i386\simplepeer.sym	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.bsc	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.ilk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.sbr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\vc60.idb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\vc60.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 277 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\search.out)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,151c1,16
< ---- Registry Matches (150) ----
< Dneterrors.cpp (common):		case ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND:
< Dneterrors.cpp (common):			pString = "ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND";
< Dneterrors.cpp (common):		case ERROR_INTERNET_BAD_REGISTRY_PARAMETER:
< Dneterrors.cpp (common):			pString = "ERROR_INTERNET_BAD_REGISTRY_PARAMETER";
< Dneterrors.cpp (common):		// The permanent card identifier specified in dwCard could not be found in any entry in the [Cards] section in the registry.
< Dneterrors.cpp (common):		// The permanent location identifier specified in dwLocation could not be found in any entry in the [Locations] section in the registry.
< Dneterrors.cpp (common):		// A telephony service provider which does not support multiple instances is listed more than once in the [Providers] section in the registry. The application should advise the user to use the Telephony Control Panel to remove the duplicated driver.
< Dneterrors.cpp (common):			// 1009 The configuration registry database is corrupt.  ERROR_BADDB
< Dneterrors.cpp (common):			// 1010 The configuration registry key is invalid.  ERROR_BADKEY
< Dneterrors.cpp (common):			// 1011 The configuration registry key could not be opened.  ERROR_CANTOPEN
< Dneterrors.cpp (common):			// 1012 The configuration registry key could not be read.  ERROR_CANTREAD
< Dneterrors.cpp (common):			// 1013 The configuration registry key could not be written.  ERROR_CANTWRITE
< Dneterrors.cpp (common):		case ERROR_REGISTRY_RECOVERED:
< Dneterrors.cpp (common):			// 1014 One of the files in the registry database had to be recovered by use of a log or alternate copy. The recovery was successful.  ERROR_REGISTRY_RECOVERED
< Dneterrors.cpp (common):			pString = "ERROR_REGISTRY_RECOVERED";
< Dneterrors.cpp (common):		case ERROR_REGISTRY_CORRUPT:
< Dneterrors.cpp (common):			// 1015 The registry is corrupted. The structure of one of the files that contains registry data is corrupted, or the system's image of the file in memory is corrupted, or the file could not be recovered because the alternate copy or log was absent or corrupted.  ERROR_REGISTRY_CORRUPT
< Dneterrors.cpp (common):			pString = "ERROR_REGISTRY_CORRUPT";
< Dneterrors.cpp (common):		case ERROR_REGISTRY_IO_FAILED:
< Dneterrors.cpp (common):			// 1016 An I/O operation initiated by the registry failed unrecoverably. The registry could not read in, or write out, or flush, one of the files that contain the system's image of the registry.  ERROR_REGISTRY_IO_FAILED
< Dneterrors.cpp (common):			pString = "ERROR_REGISTRY_IO_FAILED";
< Dneterrors.cpp (common):		case ERROR_NOT_REGISTRY_FILE:
< Dneterrors.cpp (common):			// 1017 The system has attempted to load or restore a file into the registry, but the specified file is not in a registry file format.  ERROR_NOT_REGISTRY_FILE
< Dneterrors.cpp (common):			pString = "ERROR_NOT_REGISTRY_FILE";
< Dneterrors.cpp (common):			// 1018 Illegal operation attempted on a registry key that has been marked for deletion.  ERROR_KEY_DELETED
< Dneterrors.cpp (common):			// 1019 System could not allocate the required space in a registry log.  ERROR_NO_LOG_SPACE
< Dneterrors.cpp (common):			// 1020 Cannot create a symbolic link in a registry key that already has subkeys or values.  ERROR_KEY_HAS_CHILDREN
< Dneterrors.cpp (common):			// 1369 The transaction state of a registry subtree is incompatible with the requested operation.  ERROR_RXACT_INVALID_STATE
< Dplapp.cpp (lobby)://		Register program creates and fills in a registry entry for the program
< Dplapp.cpp (lobby)://		described in lpProgramDesc.  If the registry key already exists, it updates the
< Dplapp.cpp (lobby)://		TODO - maybe this should be kept as Unicode (binary in registry) ?
< Dplclient.cpp (lobby):// MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< Dplclient.cpp (lobby)://         and XBox doesn't have a registry.  Need to figure out some other way to
< Dplclient.cpp (lobby):	CRegistry		RegistryEntry;
< Dplclient.cpp (lobby):	CRegistry		SubEntry;
< Dplclient.cpp (lobby):	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DPL_REG_LOCAL_APPL_SUBKEY,FALSE))
< Dplclient.cpp (lobby):		DPFERR("RegistryEntry.Open() failed");
< Dplclient.cpp (lobby):	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
< Dplclient.cpp (lobby):		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
< Dplclient.cpp (lobby):	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
< Dplclient.cpp (lobby):		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
< Dplclient.cpp (lobby):				RegistryEntry.Close();
< Dplclient.cpp (lobby):				// grow buffer (noting that all strings from the registry are WCHAR) and try again
< Dplclient.cpp (lobby):					RegistryEntry.Close();
< Dplclient.cpp (lobby):					RegistryEntry.Close();
< Dplclient.cpp (lobby):				RegistryEntry.Close();
< Dplclient.cpp (lobby):	RegistryEntry.Close();
< Dplclient.cpp (lobby)://		DPNERR_DOESNOTEXIST		If there was a problem opening reading a registry key
< Dplclient.cpp (lobby)://		WinNT registry is kept in Unicode, whereas Win9x is in ANSI.  Application root key
< Dplclient.cpp (lobby):	//	Get program description from registry
< Dplreg.cpp (lobby): *  Content:    DirectPlay Lobby Registry Functions
< Dplreg.cpp (lobby):// MGERE:  Removed this whole function.  It uses registry to write app description
< Dplreg.cpp (lobby)://         and XBox doesn't have a registry.  Need to figure out some other way to
< Dplreg.cpp (lobby):	CRegistry	RegistryEntry;
< Dplreg.cpp (lobby):	CRegistry	SubEntry;
< Dplreg.cpp (lobby):	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DPL_REG_LOCAL_APPL_SUBKEY,FALSE))
< Dplreg.cpp (lobby):		DPFERR("RegistryEntry.Open() failed");
< Dplreg.cpp (lobby):	if (!SubEntry.Open(RegistryEntry,pdplProgramDesc->pwszApplicationName,TRUE))
< Dplreg.cpp (lobby):		DPFERR("Could not create new registry entry");
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):	RegistryEntry.Close();
< Dplreg.cpp (lobby):// MGERE:  Removed this whole function.  It uses registry to read app description
< Dplreg.cpp (lobby)://         and XBox doesn't have a registry.  Need to figure out some other way to
< Dplreg.cpp (lobby):	CRegistry		RegistryEntry;
< Dplreg.cpp (lobby):	CRegistry		SubEntry;
< Dplreg.cpp (lobby):	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DPL_REG_LOCAL_APPL_SUBKEY,FALSE))
< Dplreg.cpp (lobby):		DPFERR("RegistryEntry.Open() failed");
< Dplreg.cpp (lobby):	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
< Dplreg.cpp (lobby):		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
< Dplreg.cpp (lobby):	while (!bFound && RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
< Dplreg.cpp (lobby):		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
< Dplreg.cpp (lobby):	RegistryEntry.Close();
< Dplreg.cpp (lobby)://		registry tree staring from the open key, hBase, creating keys as required.
< Dplreg.cpp (lobby)://		This function reads the program description entry from the registry at hKey into the
< Dplreg.cpp (lobby)://		This function deletes a GUID specified application registry entry.
< Dplreg.cpp (lobby)://		function will search for the program description entry in the registry, and the
< Dplreg.h (lobby): *  Content:    DirectPlay Lobby Registry Header File
< Enum_sp.cpp (core): *	01/18/00	mjn		Converted EnumAdapters registry interface to use CRegistry
< Enum_sp.cpp (core): *	01/24/00	mjn		Converted EnumSP registry interface to use CRegistry
< Enum_sp.cpp (core)://	Examine the "All Applications" value of the SP's registry key.  Only if this value exists and is 'N'
< Enum_sp.cpp (core)://		hSPKey				- handle to SP's registry key
< Enum_sp.cpp (core):// MGERE:  Removed this whole function.  It uses registry to enumerate service providers
< Enum_sp.cpp (core)://         and XBox doesn't have a registry.  Need to figure out some other way to
< Enum_sp.cpp (core):	CRegistry	RegistryEntry;
< Enum_sp.cpp (core):	CRegistry	SubEntry;
< Enum_sp.cpp (core):	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
< Enum_sp.cpp (core):		DPFERR("RegistryEntry.Open() failed");
< Enum_sp.cpp (core):	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
< Enum_sp.cpp (core):		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
< Enum_sp.cpp (core):	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
< Enum_sp.cpp (core):		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
< Enum_sp.cpp (core):			// grow buffer (noting that the registry functions always return WCHAR) and try again
< Enum_sp.cpp (core):	RegistryEntry.Close();
< Enum_sp.cpp (core):	if (RegistryEntry.IsOpen())
< Enum_sp.cpp (core):		RegistryEntry.Close();
< Enum_sp.cpp (core):// MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< Enum_sp.cpp (core)://         and XBox doesn't have a registry.  Need to figure out some other way to
< Enum_sp.cpp (core):	CRegistry	RegistryEntry;
< Enum_sp.cpp (core):	CRegistry	SubEntry;
< Enum_sp.cpp (core):	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
< Enum_sp.cpp (core):	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
< Enum_sp.cpp (core):	while (RegistryEntry.EnumKeys(lpwszKeyName,&dwKeyLen,dwEnumIndex))
< Enum_sp.cpp (core):		if (!SubEntry.Open(RegistryEntry,lpwszKeyName,FALSE))
< Registry.cpp (sp\wsock): *  File:       Registry.cpp
< Registry.cpp (sp\wsock):#define	DPF_MODNAME	"Registry"
< Registry.cpp (sp\wsock):#include	"Registry.h"
< Registry.cpp (sp\wsock):static const DWORD	g_dwRegistryNameLength = 512;
< Registry.cpp (sp\wsock):// registry key strings
< Registry.cpp (sp\wsock):BOOL FindSPInRegistry( const GUID *const lpguid, char *const lpszSPName, const DWORD dwNameSize, HKEY *const lphkey )
< Registry.cpp (sp\wsock):	DPF(7, "Entering FindSPInRegistry");
< Registry.cpp (sp\wsock):		DPF( 0, "Unable to open DPlay service provider registry key!" );
< Registry.cpp (sp\wsock):	// Walk the list of sps in the registry, looking for
< Registry.cpp (sp\wsock):} // FindSPInRegistry
< Registry.cpp (sp\wsock):HRESULT GetFlagsFromRegistry( const GUID *const lpguidSP, DWORD *const lpdwFlags )
< Registry.cpp (sp\wsock):	DPF(7, "Entering GetFlagsFromRegistry");
< Registry.cpp (sp\wsock):	lpszSPName = static_cast<char*>( DNMalloc( g_dwRegistryNameLength ) );
< Registry.cpp (sp\wsock):	// Open the registry key for the App
< Registry.cpp (sp\wsock):	if(!FindSPInRegistry(lpguidSP, lpszSPName, g_dwRegistryNameLength, &hkeySP))
< Registry.cpp (sp\wsock):		DPF(0,"Unable to find sp in registry!");
< Registry.cpp (sp\wsock):		DPF(0,"Unable to get flags value from registry!");
< Registry.cpp (sp\wsock):} // GetFlagsFromRegistry
< Registry.cpp (sp\wsock):HRESULT GetGatewayFromRegistry( BYTE *const lpszGateway, const DWORD cbszGateway )
< Registry.cpp (sp\wsock):	DPF(7, "Entering GetGatewayFromRegistry");
< Registry.cpp (sp\wsock):	lpszSPName = static_cast<char*>( DNMalloc( g_dwRegistryNameLength ) );
< Registry.cpp (sp\wsock):	// Open the registry key for the SP
< Registry.cpp (sp\wsock):	if(!FindSPInRegistry( &OldDPlayTCPGuid, lpszSPName, g_dwRegistryNameLength, &hkeySP ) )
< Registry.cpp (sp\wsock):		DPF(0,"Unable to find sp in registry!");
< Registry.cpp (sp\wsock):		DPF(0,"Unable to get flags value from registry, using default ICS gateway!");
< Registry.cpp (sp\wsock):} // GetGatewayFromRegistry
< Registry.h (sp\wsock): *  File:       Registry.h
< Registry.h (sp\wsock):#ifndef	__REGISTRY_H__
< Registry.h (sp\wsock):#define	__REGISTRY_H__
< Registry.h (sp\wsock):BOOL	FindSPInRegistry( const GUID *const lpguid, char *const lpszSPName, const DWORD dwNameSize, HKEY *const lphkey );
< Registry.h (sp\wsock):HRESULT	GetFlagsFromRegistry( const GUID *const lpguidSP, DWORD *const lpdwFlags);
< Registry.h (sp\wsock):HRESULT	GetGatewayFromRegistry( BYTE *const lpszGateway, const DWORD cbszGateway );
< Registry.h (sp\wsock):#endif	// __REGISTRY_H__
< Rfc1738.txt (doc):   registry of URL schemes. Any submission of a new URL scheme must
< Rsip.cpp (sp\wsock):#include	"Registry.h"
< Rsip.cpp (sp\wsock):		hr = GetGatewayFromRegistry( reinterpret_cast<BYTE*>( gwipaddr ), sizeof( gwipaddr ) );
< Rsip.cpp (sp\wsock):		DPF(0,"Found suggested RSIP gateway in registry %s, running on Win95?\n",gwipaddr);
< Simplepeer.cpp (test\simplepeer):            // Write information to the registry
---
> ---- 03/24 Matches (15) ----
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9413 edit on 2000/03/24 18:03:53 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Added items to the PREPEND_BUFF'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #4 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #4 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #4 change 9414 edit on 2000/03/24 18:05:07 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Added code to handle proxied en'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9399 edit on 2000/03/24 15:25:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Added stubs for SPGetCaps() and'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9399 edit on 2000/03/24 15:25:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Added stubs for SPGetCaps() and'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #4 change 9416 edit on 2000/03/24 18:08:19 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified code to have proper so'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9399 edit on 2000/03/24 15:25:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Added stubs for SPGetCaps() and'
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,104
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
133a138
> 	OSVERSIONINFO	OSVersionInfo;
134a140
> 
142a149,159
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
155a173,176
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
255a277,278
> 		switch ( DNGetOSType() )
> 		{
258a282,283
> 			case VER_PLATFORM_WIN32_NT:
> 			{
282a308,318
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
309a346,361
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90,97
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
71a72
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
226a227,246
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40c40
< //#include "CReg.h"
---
> #include "CReg.h"
75,79d74
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate service providers
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
266d260
< */	return(E_FAIL);
280,284d273
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
433d421
< */	return(E_FAIL);
728d715
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
375a376,379
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62,65
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
77a82
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
156c161
<     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;    
---
>     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;
242c247
< #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)              
---
> #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)
388,389c393,395
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
447a454
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
85,86d84
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
119a118,120
> 
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
187a188,206
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37c37
< //#include "CReg.h"
---
> #include "CReg.h"
93,97d92
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
389d383
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
25c25
< //#include "CReg.h"
---
> #include "CReg.h"
67,71d66
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
254d248
< */ return(E_FAIL);
275,279d268
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
573d561
< */	return(E_FAIL);
1309d1296
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
14a15
> #include <wsipx.h>
18a20,23
> //
> // comment out the follwing #define to prevent loading Winsock2
> //
> #define	LOAD_WINSOCK2
30c35,41
< static BOOL MapFunctionPointers(HINSTANCE hndlWinSock);
---
> static BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2);
> static int  FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 							  LPDWORD pdwBufLen);
> static int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
34c45
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock)
---
> int DWSInitWinSock(LPDWSSTATE lpState)
36a48
> 	BOOL f2Loaded = TRUE;
39a52,53
> 	if (lpState == NULL)
> 		return 0;
43,44c57,59
< 	*lphndlWinSock = LoadLibrary("WS2_32.DLL");
< 	if (*lphndlWinSock == NULL)
---
> #ifdef	LOAD_WINSOCK2
> 	lpState->hndlWinSock = LoadLibrary("WS2_32.DLL");
> 	if (lpState->hndlWinSock == NULL)
45a61
> #endif	// LOAD_WINSOCK2
47c63
< 		// Couldn't load WinSock 2
---
> 		// Couldn't load WinSock 2, try 1.1
49c65,69
< 			return FALSE;
---
> 		f2Loaded = FALSE;
> 		lpState->hndlWinSock = LoadLibrary("WSOCK32.DLL");
> 		if (lpState->hndlWinSock == NULL)
> 			return 0;
> #ifdef	LOAD_WINSOCK2
50a71
> #endif	// LOAD_WINSOCK2
56,57c77,78
< 	if (!MapFunctionPointers(*lphndlWinSock))
< 		return FALSE;
---
> 	if (!MapFunctionPointers(lpState, f2Loaded))
> 		return 0;
60c81
< 	// Ask for 2.2
---
> 	// If WinSock 2 was loaded, ask for 2.2 otherwise 1.1
61a83
> 	if (f2Loaded)
62a85,86
> 	else
> 		wVersionRequested = MAKEWORD(1,1);
70,71c94,95
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
76,77c100,101
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
80c104,111
< 	return(TRUE);
---
> 	// Save Max UDP for use with 1.1
> 	lpState->nMaxUdp = wsaData.iMaxUdpDg;
> 
> 	//
> 	// Return 1 or 2
> 	//
> 	lpState->nVersion = f2Loaded ? 2 : 1;
> 	return(lpState->nVersion);
85c116
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock)
---
> BOOL DWSFreeWinSock(LPDWSSTATE lpState)
86a118,120
> 	if (lpState == NULL)
> 		return FALSE;
> 
89c123,124
< 	return(FreeLibrary(hndlWinSock));
---
> 	lpState->nVersion = 0;
> 	return(FreeLibrary(lpState->hndlWinSock));
94c129
< BOOL MapFunctionPointers(HINSTANCE hndlWinSock)
---
> BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2)
95a131,133
> 	// we set the local lib handle for use with the
> 	//	macros
> 	HINSTANCE	hndlWinSock = lpState->hndlWinSock;
115c153
< 	if (fOK)
---
> 	if (fOK && fMapVersion2)
121a160,710
> ////////////////////////////////////////////////////////////
> 
> int DWSVersion(LPDWSSTATE lpState)
> {
> 	return lpState->nVersion;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket)
> {
> 	int nOptVal;
> 	int nOptLen;
> 	int nRet;
> 
> 	//
> 	// If WinSock isn't loaded
> 	// return 0
> 	//
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// If we're using WinSock 1.1
> 	// return the previously saved
> 	// info from WSADATA
> 	//
> 	if (lpState->nVersion == 1)
> 		return lpState->nMaxUdp;
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 
> 	//
> 	// Use getsockopt() to find
> 	// the max message size for
> 	// this socket
> 	//
> 	nOptLen = sizeof(int);
> 	nRet = p_getsockopt(socket,
> 					  SOL_SOCKET,
> 					  SO_MAX_MSG_SIZE,
> 					  (char *)&nOptVal,
> 					  &nOptLen);
> 	if (nRet == SOCKET_ERROR)
> 		return SOCKET_ERROR;
> 	return nOptVal;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr, LPDWORD pdwStrLen)
> {
> 	LPTSTR			lpStr;
> 	LPSOCKADDR_IN	pInAddr;
> 	int				nRet = 0;
> 
> 	lpAddrStr[0] = '\0';
> 
> 	//
> 	// If WinSock isn't loaded, return 1
> 	//
> 	if (lpState->nVersion == 0)
> 		return 1;
> 
> 	//
> 	// If using WinSock 1.1 then assume IP
> 	//
> 	if (lpState->nVersion == 1)
> 	{
> 		//
> 		// Convert address with inet_ntoa
> 		//
> 		pInAddr = (LPSOCKADDR_IN)pAddr;
> 		lpStr = p_inet_ntoa(pInAddr->sin_addr);
> 		if (lpStr == NULL)
> 		{
> 			p_WSASetLastError(WSAEINVAL);
> 			*pdwStrLen = 0;
> 			return SOCKET_ERROR;	
> 		}
> 		#ifdef UNICODE
> 			//
> 			// Convert inet_ntoa string to wide char
> 			//
> 			nRet = MultiByteToWideChar(CP_ACP,
> 										0,
> 										lpStr,
> 										-1,
> 										lpAddrStr,
> 										*pdwStrLen);
> 			if (nRet == 0)
> 			{
> 				if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
> 					p_WSASetLastError(WSAEFAULT);
> 				else
> 					p_WSASetLastError(WSAEINVALID);
> 				return SOCKET_ERROR;
> 			}
> 		#else
> 			//
> 			// ANSI -- Check the string length
> 			//
> 			if (strlen(lpStr) > *pdwStrLen)
> 			{
> 				p_WSASetLastError(WSAEFAULT);
> 				*pdwStrLen = strlen(lpStr);
> 				return SOCKET_ERROR;
> 			}
> 			strcpy(lpAddrStr, lpStr);
> 			*pdwStrLen = strlen(lpStr);
> 			return 0;
> 		#endif
> 	}
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 	nRet = p_WSAAddressToString(pAddr,
> 							    dwAddrLen,
> 							    NULL,
> 							    lpAddrStr,
> 							    pdwStrLen);
> 	//
> 	// Check for "unsupported" families
> 	//
> 	if (nRet == SOCKET_ERROR && p_WSAGetLastError() == WSAEOPNOTSUPP)
> 	{
> 		if (pAddr->sa_family == AF_IPX)
> 		{
> 			nRet = IPXAddressToString((LPSOCKADDR_IPX) pAddr,
> 									  dwAddrLen,
> 									  lpAddrStr,
> 									  pdwStrLen);
> 		}
> 	}
> 	return nRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					 LPDWORD pdwBufLen)
> {
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	if (lpState->nVersion == 1)
> 		return(FakeEnumProtocols(lpState, lpProtocolBuffer,
> 								 pdwBufLen));
> 	//
> 	// Must be WinSock 2
> 	//
> 	return(p_WSAEnumProtocols(NULL,
> 							 lpProtocolBuffer,
> 							 pdwBufLen));
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					  LPDWORD pdwBufLen)
> {
> 	WSAPROTOCOL_INFO FakeTcp;
> 	WSAPROTOCOL_INFO FakeUdp;
> 	LPWSAPROTOCOL_INFO lpInfo;
> 
> 	//
> 	// Assume WinSock 1.1, we're returning
> 	// 2 WSAPROTOCOL_INFO structures.
> 	// 1 for TCP, 1 for UDP
> 	//
> 
> 	//
> 	// Check the buffer size
> 	//
> 	if (*pdwBufLen < (sizeof(WSAPROTOCOL_INFO)*2))
> 	{
> 		*pdwBufLen = (sizeof(WSAPROTOCOL_INFO)*2);
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Build fake TCP entry
> 	//
> 	memset(&FakeTcp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeTcp.dwServiceFlags1 = XP1_GUARANTEED_DELIVERY	|
> 							  XP1_GUARANTEED_ORDER		|
> 							  XP1_GRACEFUL_CLOSE		|
> 							  XP1_EXPEDITED_DATA;
> 	FakeTcp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeTcp.dwCatalogEntryId= 1;;
> 	FakeTcp.iVersion		= 1;
> 	FakeTcp.iAddressFamily  = AF_INET;
> 	FakeTcp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iSocketType		= SOCK_STREAM;
> 	FakeTcp.iProtocol		= IPPROTO_TCP;
> 	FakeTcp.iNetworkByteOrder = BIGENDIAN;
> 	FakeTcp.dwMessageSize	= 0;
> 	_tcscpy(FakeTcp.szProtocol, _TEXT("tcp"));
> 
> 	//
> 	// Build fake UDP entry
> 	//
> 	memset(&FakeUdp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeUdp.dwServiceFlags1 = XP1_CONNECTIONLESS		|
> 							  XP1_MESSAGE_ORIENTED		|
> 							  XP1_SUPPORT_BROADCAST;		
> 							  // Might want to add multipoint
> 	FakeUdp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeUdp.dwCatalogEntryId= 2;;
> 	FakeUdp.iVersion		= 1;
> 	FakeUdp.iAddressFamily  = AF_INET;
> 	FakeUdp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iSocketType		= SOCK_DGRAM;
> 	FakeUdp.iProtocol		= IPPROTO_UDP;
> 	FakeUdp.iNetworkByteOrder = BIGENDIAN;
> 	FakeUdp.dwMessageSize	= lpState->nMaxUdp;	// The reason this can't be static
> 	_tcscpy(FakeUdp.szProtocol, _TEXT("udp"));
> 
> 	//
> 	// Copy the fake entries to the supplied buffer
> 	lpInfo = lpProtocolBuffer;
> 	memcpy(lpInfo, &FakeTcp, sizeof(WSAPROTOCOL_INFO));
> 	lpInfo++;
> 	memcpy(lpInfo, &FakeUdp, sizeof(WSAPROTOCOL_INFO));
> 
> 	//
> 	// Returning 2 protocols
> 	//	
> 	return 2;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSSelectProtocols( LPDWSSTATE lpState,
> 					DWORD dwSetFlags,
> 					DWORD dwNotSetFlags,
> 					LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					LPDWORD lpdwBufferLength
> 					)
> {
> 	LPBYTE				pBuf;
> 	LPWSAPROTOCOL_INFO	pInfo;
> 	DWORD				dwNeededLen;
> 	LPWSAPROTOCOL_INFO	pRetInfo;
> 	DWORD				dwRetLen;
> 	int					nCount;
> 	int					nMatchCount;
> 	int					nRet;
> 
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// Determine needed buffer size
> 	//
> 	dwNeededLen = 0;
> 	nRet = DWSEnumProtocols(lpState, NULL, &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAENOBUFS)
> 			return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Allocate the buffer
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwNeededLen) );
> 	if (pBuf == NULL)
> 	{
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Make the "real" call
> 	//
> 	nRet = DWSEnumProtocols(lpState, (LPWSAPROTOCOL_INFO)pBuf,
> 							 &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Helper macros for selecting protocols
> 	//
> 	#define REJECTSET(f) \
> 	    ((dwSetFlags & f) && !(pInfo->dwServiceFlags1 & f))
> 	#define REJECTNOTSET(f) \
> 	    ((dwNotSetFlags &f) && (pInfo->dwServiceFlags1 & f))
> 	#define REJECTEDBY(f) (REJECTSET(f) || REJECTNOTSET(f))
> 
> 	//
> 	// Loop through the protocols making selections
> 	//
> 	pInfo = (LPWSAPROTOCOL_INFO)pBuf;	
> 	pRetInfo = lpProtocolBuffer;
> 	dwRetLen = 0;
> 	nMatchCount = 0;
> 	for(nCount = 0; nCount < nRet; nCount++)
> 	{
> 		//
> 		// Check all of the requested flags
> 		//
> 		while(1)
> 		{
> 			if (REJECTEDBY(XP1_CONNECTIONLESS))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_DELIVERY))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_ORDER))
> 				break;
> 			if (REJECTEDBY(XP1_MESSAGE_ORIENTED))
> 				break;
> 			if (REJECTEDBY(XP1_PSEUDO_STREAM))
> 				break;
> 			if (REJECTEDBY(XP1_GRACEFUL_CLOSE))
> 				break;
> 			if (REJECTEDBY(XP1_EXPEDITED_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_CONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_DISCONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_BROADCAST))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_MULTIPOINT))
> 				break;
> 			if (REJECTEDBY(XP1_MULTIPOINT_DATA_PLANE))
> 				break;
> 			if (REJECTEDBY(XP1_QOS_SUPPORTED))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_SEND))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_RECV))
> 				break;
> 			if (REJECTEDBY(XP1_IFS_HANDLES))
> 				break;
> 			if (REJECTEDBY(XP1_PARTIAL_MESSAGE))
> 				break;
> 			//
> 			// If we made it here,
> 			//the protocol meets all requirements
> 			//
> 			dwRetLen += sizeof(WSAPROTOCOL_INFO);
> 			if (dwRetLen > *lpdwBufferLength)
> 			{
> 				// The supplied buffer is too small
> 				p_WSASetLastError(WSAENOBUFS);
> 				*lpdwBufferLength = dwNeededLen;
> 				DNFree(pBuf);
> 				return SOCKET_ERROR;
> 			}
> 			nMatchCount++;
> 			// Copy this protocol to the caller's buffer
> 			memcpy(pRetInfo, pInfo, sizeof(WSAPROTOCOL_INFO));
> 			pRetInfo++;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	*lpdwBufferLength = dwRetLen;
> 	return(nMatchCount);
> }
> 
> ////////////////////////////////////////////////////////////
> 
> BOOL DWSDnsOnly(LPDWSSTATE lpState)
> {
> 	//
> 	// Return TRUE if DNS is the only name space provider
> 	//
> 
> 	LPWSANAMESPACE_INFO pInfo;
> 	DWORD				dwBufLen;
> 	PBYTE				pBuf;
> 	int					nCount;
> 	BOOL				fRet = TRUE;
> 	int					nRet;
> 
> 	//
> 	// If we're running on WinSock 1.1 return TRUE
> 	//
> 	if (lpState->nVersion == 1)
> 		return fRet;
> 
> 	// WinSock 2
> 
> 	//
> 	// Intentionally generate an error
> 	// to get the required buffer size
> 	//
> 	dwBufLen = 0;
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen, NULL);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAEFAULT)
> 			return fRet;
> 	}
> 
> 	//
> 	// dwBufLen now equals needed size
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwBufLen+1) );
> 	if (pBuf == NULL)
> 		return fRet;
> 
> 	//
> 	// Now, make the "real" call
> 	//
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen,
> 									   (LPWSANAMESPACE_INFO)pBuf);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return fRet;
> 	}
> 
> 	pInfo = (LPWSANAMESPACE_INFO)pBuf;
> 	for (nCount = 0; nCount < nRet; nCount++)
> 	{
> 		if (pInfo->dwNameSpace != NS_DNS)
> 		{
> 			fRet = FALSE;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	return fRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> char NibbleToHex(BYTE b)
> {
>     if (b < 10)
> 		return (b + '0');
> 
>     return (b - 10 + 'A');
> }
> 
> void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr)
> {
> 	BYTE b;
>     while(nNbrBytes--)
>     {
> 		// High order nibble first
> 		b = (*pBytes >> 4);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		// Then low order nibble
> 		b = (*pBytes & 0x0F);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		pBytes++;
>     }
>     *lpStr = '\0';
> }
> 
> ////////////////////////////////////////////////////////////
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
>     strcat(szAddr, ":");
> 
> 	// IPX Address Socket number
>     BinToHex((PBYTE)&pAddr->sa_socket, 2, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
> 
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	LPSOCKADDR_IPX pAddr = (LPSOCKADDR_IPX) pSAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17,18c17,42
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock);
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock);
---
> // added to support multiple instantiation/initialization
> typedef struct _DWSSTATE
> {
> 	HINSTANCE	hndlWinSock;
> 	int			nVersion;
> 	int			nMaxUdp	;
> } DWSSTATE, *LPDWSSTATE;
> 
> 
> int  DWSInitWinSock(LPDWSSTATE lpState);
> BOOL DWSFreeWinSock(LPDWSSTATE lpState);
> int  DWSVersion(LPDWSSTATE lpState);
> int  DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket);
> int  DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 						LPSTR lpAddrStr, LPDWORD pdwStrLen);
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
> int  DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 		   			  LPDWORD pdwBufLen);
> int  DWSSelectProtocols(LPDWSSTATE lpState, DWORD dwSetFlags,
> 					    DWORD dwNotSetFlags,
> 					    LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					    LPDWORD lpdwBufferLength);
> BOOL DWSDnsOnly(LPDWSSTATE lpState);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
42a44
> #include	"IPXAddress.h"
77c79,80
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
95a99,100
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
111c116,118
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
177a185,190
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
198a212,218
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
201a222,267
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown state
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.x, or higher
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
224a291,292
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
243a312,313
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
270a341,346
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
388a465,471
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
391a475,519
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.X or greater
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
423a552,553
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
443a574,575
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
116a117,119
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
146a150
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
147a152
> 
167a173,175
> 
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1433a1435,1440
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1434a1442,1460
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1437a1464,1466
> 		case 2:
> 		default:
> 		{
1438a1468,1470
> 			break;
> 		}
> 	}
1512a1545,1550
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1513a1552,1570
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1516a1574,1576
> 		case 2:
> 		default:
> 		{
1517a1578,1580
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
48a50
> #include	"IPXAddress.h"
52a55
> #include	"IPXEndpt.h"
80a84
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
81a86
> static	CFixedPool< CIPXEndpoint >	*g_pIPXEndpointPool = NULL;
172a178,184
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
182a195,201
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CFixedPool< CIPXEndpoint >;
> 	if ( g_pIPXEndpointPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
307a327,332
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
316a342,347
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
424a456,469
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
425a471
> 
427a474,490
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
457a521,552
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( void )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXEndpoint - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint )
> {
> 	DNASSERT( pIPXEndpoint != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXEndpointPool->Release( pIPXEndpoint );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
57a60,62
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
59a65,67
> 
> CIPXEndpoint	*CreateIPXEndpoint( void );
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
263a265,266
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
264a268,285
> 		// something's not right!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// winsock 1.x
> 		//
> 		case 1:
> 		{
> 			m_pSendFunction = Winsock1Send;
> 			break;
> 		}
> 
> 		//
266a288,290
> 		case 2:
> 		default:
> 		{
267a292,294
> 			break;
> 		}
> 	}
411a439,461
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( LOWORD( GetWinsockVersion() ) == 1 )
> 		{
> //			HRESULT	hTempResult;
> 			THREAD_POOL_JOB	*pTemp;
> 
> 
> 			pTemp = m_pRemoveSocketPortData;
> 			m_pRemoveSocketPortData = NULL;
> 			INT3;
> //			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> //			if ( hTempResult != DPN_OK )
> //			{
> //				DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> //				DisplayDNError( 0, hTempResult );
> //			}
> 		}
> 
768a819,831
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
770a834,940
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
771a942,944
> 
> 
> //**********************************************************************
772a946,1094
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
800,801c1122,1123
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
812a1135,1137
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
865a1191,1193
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
943c1271,1272
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
957a1287,1289
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1022a1355,1356
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1070a1405,1406
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1590a1927,1933
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1624a1968,1969
> 			break;
> 		}
1625a1971,2050
> 		//
> 		// we're on Win9x, ask work thread to submit a read
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// invalid version
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// Winsock 1.x
> 				//
> 				case 1:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					DNASSERT( m_pRemoveSocketPortData == NULL );
> 					INT3;
> //					hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> //					if ( hr != DPN_OK )
> //					{
> //						DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> //						DisplayDNError( 0, hr );
> //						goto Failure;
> //					}
> 					DNASSERT( m_pRemoveSocketPortData != NULL );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2.x or greater
> 				//
> 				case 2:
> 				default:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					hr = m_pThreadPool->SubmitDelayedCommand( InitialWin9xWinsock2Read, CancelInitialWin9xWinsock2Read, this );
> 					if ( hr != DPN_OK )
> 					{
> 						DPF( 0, "Failed to submit initial Win9x Winsock2 read for SocketPort!" );
> 						DisplayDNError( 0, hr );
> 						goto Failure;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2198a2624,2635
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
2199a2637,2640
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
2200a2642,2794
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			goto Exit;
> 			
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
2201a2796,2798
> 
> 
> //**********************************************************************
2474a3072,3132
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::InitialWin9xWinsock2Read - perform initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	HRESULT			hr;
> 	CSocketPort		*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	hr = pThisSocketPort->Winsock2Receive();
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Problem with initial read on socket port!" );
> 		DisplayDNError( 0, hr );
> 	}
> 
> 	//
> 	// release the reference for the pending command
> 	//
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::CancelInitialWin9xWinsock2Read - cancel initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	CSocketPort	*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 
> 	INT3;
> 	//
> 	// Since this command was for the worker thread and won't be processed,
> 	// remove the socket port reference created for this action.
> 	//
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	pThisSocketPort->DecRef();
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
287a288,289
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
291a294,296
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
335a341
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
340a347,348
> 		static	void	InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
> 		static	void	CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
97a98,99
> 	 IPXAddress.cpp \
> 	 IPXEndpt.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
103c103
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
121c121,122
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
156c157,158
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
241a244
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
242a246
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
245c249
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
252c256
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
274a279
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
47a49
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
183a187,252
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
491a561,566
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint();
>     		break;
>     	}
> 
544a620,625
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXEndpoint( static_cast<CIPXEndpoint*>( pEndpoint ) );
>     		break;
>     	}
> 
681a763,768
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
714a802,807
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
133a135,158
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwWaitHandleCount;					// count of handles to wait on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
170a196
> 		m_iWinsockVersion( 0 ),
199a226
> 	DNASSERT( m_iWinsockVersion == 0 );
224c251
< HRESULT	CThreadPool::Initialize( void )
---
> HRESULT	CThreadPool::Initialize( const INT_PTR iWinsockVersion )
236a264
> 	m_iWinsockVersion = iWinsockVersion;
255c283,293
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
256a295,302
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
263c309,319
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
264a321,326
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
265a328
> 
306a370,376
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
363a434,440
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
369a447,473
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
465a570,729
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
> 		//
> 		// Winsock2, use events to signal I/O completion
> 		//
> 		case 2:
> 		{
> 			DNASSERT( m_hWinsock2SendComplete == NULL );
> 			m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 												   TRUE,	// manual reset
> 												   FALSE,	// start unsignalled
> 												   NULL		// pointer to name (none)
> 												   );
> 			if ( m_hWinsock2SendComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Send!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 			m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 													  TRUE,		// manual reset
> 													  FALSE,	// start unsignalled
> 													  NULL		// pointer to name (none)
> 													  );
> 			if ( m_hWinsock2ReceiveComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Receive!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, nothing special to do
> 		//
> 		case 1:
> 		{
> 			break;
> 		}
> 
> 		default:
> 		{
> 			INT3;
> 		}
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	//
> 	// note that we've started a thread
> 	//
> 	m_iTotalThreadCount++;
> 	DNASSERT( m_iNTCompletionThreadCount == 0 );
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
564a829,830
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
585a852
> 	}
663a931,936
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
679a953,954
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
828a1104
> 	m_IPXReadIODataPool.Deinitialize();
840a1117,1118
> 
> 	m_iWinsockVersion = 0;
888a1167,1181
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			if ( pTempReadData == NULL )
> 			{
> 				DPF( 0, "Failed to get new IPX ReadIOData from pool!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
983a1277,1285
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1316a1619,1625
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, submit new I/O completion item
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1333a1643,1676
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				hr = DPNERR_GENERIC;
> 				dwError = GetLastError();
> 				DPF( 0, "Cannot set event for pending job!" );
> 				DisplayErrorCode( 0, dwError );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1429a1773,1774
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1436a1782
> 	}
1689a2036,2052
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
> 		// WinNT has many potential threads
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1691a2055,2056
> 			break;
> 		}
1692a2058,2067
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1721a2097,2098
> 	switch ( DNGetOSType() )
> 	{
1722a2100,2107
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1725a2111,2112
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1735a2123,2135
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
2176a2577,2589
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
2178a2592,2593
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
2179a2595,2604
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
2181a2607,2611
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
2182a2613,2690
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
2183a2692,2694
> 
> 
> //**********************************************************************
2184a2696,3374
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 	TIMEVAL				SelectTimeout = { 0 };
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			DPF( 0, "Failed to initialize COM!" );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> 	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> 	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	CoreData.dwWaitHandleCount = 2;
> 
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) &&
> 		 ( LOWORD( GetWinsockVersion() ) >= 2 ) )
> 	{
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.dwWaitHandleCount >= ( EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE + 1 ) );
> 	}
> 
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		//
> 		// Since only this thread can modify m_SocketSet.fd_count, there's no
> 		// need to take a critical section to read it!
> 		//
> 		if ( pSocketSet->fd_count == 0 )
> 		{
> 			DWORD	dwWaitReturn;
> 
> 
> 			//
> 			// There are no sockets active.  Wait for the SP to close, a job
> 			// to be submitted, or a timeout for enumeration.
> 			//
> 			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> //			dwElapsedTime = GetTickCount();
> 
> 			DNTimeGet( &CurrentTime );
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active enums left when enuming with no Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> 
> #pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> 			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> 
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,		// count of handles
> 													 CoreData.hWaitHandles,				// handles to wait on
> 													 FALSE,								// don't wait for all to be signalled
> 													 dwMaxWaitTime,						// wait timeout
> 													 TRUE								// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// timeout, don't do anything, we'll probably process enums on the next loop
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// New job.  Account for the time spent in the wait.  Don't
> 				// account for time after the job is complete because it's
> 				// possible that the job was an enum submission which will want
> 				// to reset the wait time.
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 send complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending write list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 send event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingSends();
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 receive complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending read list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 receive event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingReceives();
> 					break;
> 				}
> 
> 				//
> 				// There are I/O completion routines scheduled on this thread,
> 				// no problem.
> 				//
> 				case WAIT_IO_COMPLETION:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// wait failed
> 				//
> 				case WAIT_FAILED:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> 					DisplayDNError( 0, dwError );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> 					DisplayDNError( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		} // if ( CoreData.dwActiveSocketCount == 0 )
> 		else
> 		{
> 			INT				iSelectReturn;
> 			DWORD			dwWaitReturn;
> 			FD_SET			ReadSocketSet;
> 			FD_SET			WriteSocketSet;
> 			FD_SET			ErrorSocketSet;
> 
> 
> 			//
> 			// Update the enum time so we know how long to wait.  We can
> 			// only get here if a socket was just added to the socket list, or
> 			// we've been servicing sockets.
> 			//
> 
> 			DNTimeGet( &CurrentTime );
> 
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active enums left when enuming with Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 			//
> 			// Wait for something to happen on a socket or wait for next enum
> 			// service.  We're supposed to pass select times in microseconds,
> 			// but multiplying by 1000 is slower than letting the compiler
> 			// get fancy with multiplying by 1024, and the relative error
> 			// is negligible.
> 			//
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> 			}
> 			else
> 			{
> 				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> 			}
> 
> 			//
> 			// Make a local copy of all of the sockets.  This isn't totally
> 			// efficient, but it works.  Multiplying by active socket count will
> 			// spend half the time in the integer multiply.
> 			//
> 			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> 			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> 			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> 
> 			DNASSERT( SelectTimeout.tv_sec == 0 );
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  &ReadSocketSet,	// sockets to check for read
> 									  NULL,				// sockets to check for write (don't check writes)
> 									  &ErrorSocketSet,	// sockets to check for error
> 									  &SelectTimeout	// wait timeout
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// This socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting all sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing read service and error service.
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// check for writes only
> 			//
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  NULL,				// sockets to check for read (don't check reads)
> 									  &WriteSocketSet,	// sockets to check for write
> 									  NULL,				// sockets to check for error (don't check errors)
> 									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					INT3;
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// this socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting write sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing write service
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// since we just serviced sockets, make a quick check for pending
> 			// events
> 			//
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,	// count of handles
> 													 CoreData.hWaitHandles,			// handles to wait on
> 													 FALSE,							// don't wait for all to be signalled
> 													 0,								// make a quick check
> 													 TRUE							// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// nothing was signalled, keep looping
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// pending job
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock 2 I/O complete, we should not be getting this if
> 				// we're using Winsock1 support!!!
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Win9x wait for events with sockets active failed!" );
> 					DisplayErrorCode( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2535a3726,3736
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
2536a3738,3864
> 
> 	//
> 	// remove and process a single job from the list
> 	//
> 	pJobInfo = GetWorkItem();
> 	DNASSERT( pJobInfo != NULL );
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshEnum.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// start monitoring a port for I/O
> 		//
> 		case JOB_ADD_WIN9X_SOCKET:
> 		{
> 			DPF( 8, "WorkThread job ADD_SOCKET" );
> 
> 			//
> 			// add this port to the ends of the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> 			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> 			m_SocketSet.fd_count++;
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// stop monitoring a port for I/O
> 		//
> 		case JOB_REMOVE_WIN9X_SOCKET:
> 		{
> 			UINT_PTR	uIdx;
> 
> 
> 			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> 
> 			//
> 			// remove this port from the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_uReservedSocketCount != 0 );
> 			uIdx = m_SocketSet.fd_count;
> 			DNASSERT( uIdx != 0 );
> 			do
> 			{
> 				uIdx--;
> 
> 				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> 				{
> 					m_uReservedSocketCount--;
> 					m_SocketSet.fd_count--;
> 
> 					//
> 					// release our I/O reference to this item and shift all other entries down in
> 					// the socket array
> 					//
> 					m_pSocketPorts[ uIdx ]->DecRef();
> 					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 
> 					//
> 					// clear last entry (which is now unused) in the debug build
> 					//
> 					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> 					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> 
> 					//
> 					// end the loop.
> 					//
> 					uIdx = 0;
> 				}
> 			} while ( uIdx != 0 );
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> }
2537a3866,3868
> 
> 
> //**********************************************************************
2782a4114,4115
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
101c102
< 		HRESULT	Initialize( void );
---
> 		HRESULT	Initialize( const INT_PTR iWinsockVersion );
106c107,108
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
152a155
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
157a161
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
189a194
> 		INT_PTR	m_iWinsockVersion;				// version of available Winsock
201a207
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
273a280
> 		HRESULT	Win9xInit( void );
290a298,299
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
291a301
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
298a309
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
65c65,94
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
126a156,245
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
228a348
> //	we can either create an IPX instance or an IP instance
234a355,358
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
265c389,390
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
77c78
< static	HINSTANCE g_hndlWinSock;		// state info for the WS1/2 glue lib
---
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
103a105
> 	INT		iVersion;
131c133,134
< 	if ( FALSE == DWSInitWinSock( &g_hndlWinSock ) )	// failure
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
138a142,143
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
151,152c156
< 		fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 		g_hndlWinSock = NULL;
---
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
193,194c197
< 	fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 	g_hndlWinSock = NULL;
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
205a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
206a223
> 
304a322
> 	INT_PTR iWinsockVersion;
314a333
> 	iWinsockVersion = GetWinsockVersion();
330c349
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize( iWinsockVersion );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
245a247
> 		case TYPE_IPX:
479,480c481,483
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
2661a2665,2676
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2873a2889,2900
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.  
