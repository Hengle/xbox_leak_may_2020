-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dnet.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock1.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwnsock2.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
-- 57 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04241015.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04261045.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05010945.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05021600.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05031030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\lastsync.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\contextfixedpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\temp.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.dif\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 160 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
107a108,111
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
140a145
> 	OSVERSIONINFO	OSVersionInfo;
141a147
> 
149a156,166
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
162a180,183
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
262a284,285
> 		switch ( DNGetOSType() )
> 		{
265a289,290
> 			case VER_PLATFORM_WIN32_NT:
> 			{
289a315,325
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
316a353,368
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
92a93,100
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
71a72
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
68a69
> #include "DVoice.h"
99a101
> #include "Voice.h"
104d105
< #include <mmsystem.h>
1462a1464,1472
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
39a40
> #include "DVoice.h"
68a70,71
> #include "dvoice.h"
> #include "voice.h"
116a120
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
222a227,231
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
223a233,247
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
255a280,283
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
> 
284a313,319
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
578a614,616
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
841a880,884
> 	}
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(7,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
101a102
> #include "DVoice.h"
134a136
> #include "Voice.h"
141d142
< #include <mmsystem.h>
1418a1420,1424
> 
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
140a141
> #define	DN_MSG_INTERNAL_VOICE_SEND						(0x1e | DN_MSG_INTERNAL)
159a161
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
199a202,207
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> #define MAX_VOICE_CLIENTS	32	
> 
267a276,280
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
43c43
< //#include "CReg.h"
---
> #include "CReg.h"
79,80c79
< // BUGBUG:  [mgere] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
82c81,91
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
84,87c93,95
< 	DWORD dwStrLen;
< 	TCHAR szFriendlyName[] = "DirectPlay8 TCP/IP Service Provider";
< 	LPWSTR pwszFriendlyName = NULL;
<     GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
97,99c105,106
< 	pwszFriendlyName = static_cast<WCHAR*>(DNMalloc((strlen(szFriendlyName)+1)*sizeof(WCHAR)));
< 	dwStrLen = MultiByteToWideChar(CP_ACP,0,szFriendlyName,-1,pwszFriendlyName,strlen(szFriendlyName)+1);
< 
---
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
105,106c112,117
< 	hResultCode = packedBuffer.AddToBack(pwszFriendlyName,(strlen(szFriendlyName)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
108,109c119,146
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
---
> 	//
> 	//	Set up to enumerate
> 	//
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(5,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
111,112c148,161
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	//
> 	//	Enumerate SP's !
> 	//
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(5,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
> 		{
> 			DPF(0,"Couldn't open subentry.  Skipping [%S]", pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
113a163,254
> 		//
> 		//	GUID
> 		//
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPF(0,"SubEntry.ReadGUID failed.  Skipping [%S]", pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		//
> 		//	Attempt to instantiate SP and initialize it, to ensure that it is in fact usable.
> 		//
> 		if (!(dwFlags & DPNENUMSERVICEPROVIDERS_ALL))
> 		{
> 			hResultCode = DN_SPEnsureLoaded(pdnObject,&guid,NULL);
> 			if (hResultCode != DPN_OK)
> 			{
> 				DPF(0,"Could not load SP.  Skipping [%S]", pwszKeyName);
> 				SubEntry.Close();
> 				dwEnumIndex++;
> 				dwKeyLen = dwMaxKeyLen;
> 				hResultCode = DPN_OK; // override return code
> 				continue;
> 			}
> 			else
> 			{
> 				DN_SPRelease(pdnObject,&guid);
> 			}
> 		}
> 
> 		//
> 		//	Friendly Name
> 		//
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(5,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		DPF(5,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
> 	//
> 	//	Success ?
> 	//
117c258
< 		DPF(7,"Buffer too small");
---
> 		DPF(5,"Buffer too small");
120c261
< 		goto Exit;
---
> 		goto Failure;
124c265,266
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
> 		hResultCode = DPN_OK;
129c271,272
< Exit:
---
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
132c275,277
< 	DPF(3,"Returning: [0x%lx]",hResultCode);
---
> 
> Exit:
> 	DPF(4,"Returning: [0x%lx]",hResultCode);
133a279,300
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
147,151d313
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
301d462
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
26a27
> #include "DVoice.h"
49a51
> #include "voice.h"
52a55
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
2189a2193
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
108a109
>          ..\voice.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "DVoice.h"
47a49
> #include "voice.h"
164a167,168
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
198a203,204
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
230a237,238
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
265a274,275
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
299a310,311
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
335a348,349
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
603a618,619
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
396a397,400
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
31c31
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62a63,66
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
78a83
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
389,390c394,396
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
452a459
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
96,97d95
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
130a129,131
> 
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
188a189,207
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
42c42
< //#include "CReg.h"
---
> #include "CReg.h"
101,105d100
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
408d402
< */	return(E_FAIL);
791a786,787
> 	if( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
809a806,845
> 	}
> 	else
> 	{
>     	// More setup
>     	siA.cb = sizeof(STARTUPINFO);
>     	siA.lpReserved = NULL;
>     	siA.lpDesktop = NULL;
>     	siA.lpTitle = NULL;
>     	siA.dwFlags = 0;
>     	siA.cbReserved2 = 0;
>     	siA.lpReserved2 = NULL;	    
>     	
> 	    DPF( 1, "Detected 9x, Doing Unicode launch" );
> 	    
>     	if( FAILED( hResultCode = DPL_AllocAndConvertToAnsi( &pszUnExpanded, pwszUnexpanded ) ) )
>     	{
>     	    dwError = GetLastError();
>     	    DPF( 0, "String conversion failed dwError = [0x%lx]", dwError );
>     	    hResultCode = DPNERR_CONVERSION;
>     	    goto CLEANUP_DPLLaunch;
>     	}
> 
>     	if( FAILED( hResultCode = DPL_AllocAndConvertToAnsi( &pszDefaultDir, pdplProgramDesc->pwszCurrentDirectory ) ) )
>     	{
>     	    dwError = GetLastError();
>     	    DPF( 0, "String conversion failed dwError = [0x%lx]", dwError );
>     	    hResultCode = DPNERR_CONVERSION;
>     	    goto CLEANUP_DPLLaunch;
>     	}
> 
>     	// Launch !
>     	if (CreateProcessA(NULL,pszUnExpanded,NULL,NULL,FALSE,NORMAL_PRIORITY_CLASS,NULL,
>     			pszDefaultDir,&siA,&pi) == 0)
>     	{
>     		dwError = GetLastError();
>     		DPF( 0, "CreateProcess Failed dwLastError [0x%lx]", dwError );
>     		hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
>     		goto CLEANUP_DPLLaunch;
>     	}	    
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
27c27
< //#include "CReg.h"
---
> #include "CReg.h"
58,62d57
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
154d148
< */ return(E_FAIL);
171,175d164
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
344d332
< */ return(E_FAIL);
365,369d352
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
659d641
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock1.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,42c1,67
< #define p_accept accept
< #define p_bind bind
< #define p_closesocket closesocket
< #define p_connect connect
< #define p_gethostbyaddr gethostbyaddr
< #define p_gethostbyname gethostbyname
< #define p_gethostname gethostname
< #define p_getpeername getpeername
< #define p_getprotobyname getprotobyname
< #define p_getprotobynumber getprotobynumber
< #define p_getservbyname getservbyname
< #define p_getservbyport getservbyport
< #define p_getsockname getsockname
< #define p_getsockopt getsockopt
< #define p_htonl htonl
< #define p_htons htons
< #define p_inet_addr inet_addr
< #define p_inet_ntoa inet_ntoa
< #define p_ioctlsocket ioctlsocket
< #define p_listen listen
< #define p_ntohl ntohl
< #define p_ntohs ntohs
< #define p_recv recv
< #define p_recvfrom recvfrom
< #define p_select select
< #define p_send send
< #define p_sendto sendto
< #define p_setsockopt setsockopt
< #define p_shutdown shutdown
< #define p_socket socket
< //#define p_WSAAsyncGetHostByAddr WSAAsyncGetHostByAddr
< //#define p_WSAAsyncGetHostByName WSAAsyncGetHostByName
< //#define p_WSAAsyncGetProtoByName WSAAsyncGetProtoByName
< //#define p_WSAAsyncGetProtoByNumber WSAAsyncGetProtoByNumber
< //#define p_WSAAsyncGetServByName WSAAsyncGetServByName
< //#define p_WSAAsyncGetServByPort WSAAsyncGetServByPort
< //#define p_WSAAsyncSelect WSAAsyncSelect
< //#define p_WSACancelAsyncRequest WSACancelAsyncRequest
< #define p_WSACleanup WSACleanup
< #define p_WSAGetLastError WSAGetLastError
< #define p_WSASetLastError WSASetLastError
< #define p_WSAStartup WSAStartup
---
> //
> // DWNSOCK1.INC	Macros for dynamically linking to WinSock 1.1
> //
> 
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	//
> 	// Function available in both versions
> 	//
> 	DYNAMICWINSOCK(accept, LPFN_ACCEPT);
> 	DYNAMICWINSOCK(bind, LPFN_BIND);
> 	DYNAMICWINSOCK(closesocket, LPFN_CLOSESOCKET);
> 	DYNAMICWINSOCK(connect, LPFN_CONNECT);
> 	DYNAMICWINSOCK(gethostbyaddr, LPFN_GETHOSTBYADDR);
> 	DYNAMICWINSOCK(gethostbyname, LPFN_GETHOSTBYNAME);
> 	DYNAMICWINSOCK(gethostname, LPFN_GETHOSTNAME);
> 	DYNAMICWINSOCK(getpeername, LPFN_GETPEERNAME);
> 	DYNAMICWINSOCK(getprotobyname, LPFN_GETPROTOBYNAME);
> 	DYNAMICWINSOCK(getprotobynumber, LPFN_GETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(getservbyname, LPFN_GETSERVBYNAME);
> 	DYNAMICWINSOCK(getservbyport, LPFN_GETSERVBYPORT);
> 	DYNAMICWINSOCK(getsockname, LPFN_GETSOCKNAME);
> 	DYNAMICWINSOCK(getsockopt, LPFN_GETSOCKOPT);
> 	DYNAMICWINSOCK(htonl, LPFN_HTONL);
> 	DYNAMICWINSOCK(htons, LPFN_HTONS);
> 	DYNAMICWINSOCK(inet_addr, LPFN_INET_ADDR);
> 	DYNAMICWINSOCK(inet_ntoa, LPFN_INET_NTOA);
> 	DYNAMICWINSOCK(ioctlsocket, LPFN_IOCTLSOCKET);
> 	DYNAMICWINSOCK(listen, LPFN_LISTEN);
> 	DYNAMICWINSOCK(ntohl, LPFN_NTOHL);
> 	DYNAMICWINSOCK(ntohs, LPFN_NTOHS);
> 	DYNAMICWINSOCK(recv, LPFN_RECV);
> 	DYNAMICWINSOCK(recvfrom, LPFN_RECVFROM);
> 	DYNAMICWINSOCK(select, LPFN_SELECT);
> 	DYNAMICWINSOCK(send, LPFN_SEND);
> 	DYNAMICWINSOCK(sendto, LPFN_SENDTO);
> 	DYNAMICWINSOCK(setsockopt, LPFN_SETSOCKOPT);
> 	DYNAMICWINSOCK(shutdown, LPFN_SHUTDOWN);
> 	DYNAMICWINSOCK(socket, LPFN_SOCKET);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByAddr, LPFN_WSAASYNCGETHOSTBYADDR);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByName, LPFN_WSAASYNCGETHOSTBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByName, LPFN_WSAASYNCGETPROTOBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByNumber, LPFN_WSAASYNCGETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(WSAAsyncGetServByName, LPFN_WSAASYNCGETSERVBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetServByPort, LPFN_WSAASYNCGETSERVBYPORT);
> 	DYNAMICWINSOCK(WSAAsyncSelect, LPFN_WSAASYNCSELECT);
> 	DYNAMICWINSOCK(WSACancelAsyncRequest, LPFN_WSACANCELASYNCREQUEST);
> 	DYNAMICWINSOCK(WSACleanup, LPFN_WSACLEANUP);
> 	DYNAMICWINSOCK(WSAGetLastError, LPFN_WSAGETLASTERROR);
> 	DYNAMICWINSOCK(WSASetLastError, LPFN_WSASETLASTERROR);
> 	DYNAMICWINSOCK(WSAStartup, LPFN_WSASTARTUP);
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock2.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,27c1,3
< #ifdef UNICODE
< //	#define p_WSAAddressToString				WSAAddressToStringW
< //	#define p_WSADuplicateSocket				WSADuplicateSocketW
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersW
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsW
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoW
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdW
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassW
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginW
< //	#define p_WSALookupServiceNext				WSALookupServiceNextW
< //	#define p_WSASetService						WSASetServiceW
< //	#define p_WSASocket							WSASocketW
< //	#define p_WSAStringToAddress				WSAStringToAddressW
< #else
< //	#define p_WSAAddressToString				WSAAddressToStringA
< //	#define p_WSADuplicateSocket				WSADuplicateSocketA
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersA
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsA
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoA
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdA
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassA
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginA
< //	#define p_WSALookupServiceNext				WSALookupServiceNextA
< //	#define p_WSASetService						WSASetServiceA
< //	#define p_WSASocket							WSASocketA
< //	#define p_WSAStringToAddress				WSAStringToAddressA
< #endif // UNICODE
---
> //
> // DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
> //
29,53c5,70
< //#define p_WSAAccept WSAAccept
< #define p_WSACloseEvent WSACloseEvent
< //#define p_WSAConnect WSAConnect
< #define p_WSACreateEvent WSACreateEvent
< #define p_WSAEnumNetworkEvents WSAEnumNetworkEvents
< #define p_WSAEventSelect WSAEventSelect
< #define p_WSAGetOverlappedResult WSAGetOverlappedResult
< //#define p_WSAGetQOSByName WSAGetQOSByName
< //#define p_WSAHtonl WSAHtonl
< //#define p_WSAHtons WSAHtons
< #define p_WSAIoctl WSAIoctl
< //#define p_WSAJoinLeaf WSAJoinLeaf
< //#define p_WSALookupServiceEnd WSALookupServiceEnd
< //#define p_WSANtohl WSANtohl
< //#define p_WSANtohs WSANtohs
< #define p_WSARecv WSARecv
< //#define p_WSARecvDisconnect WSARecvDisconnect
< #define p_WSARecvFrom WSARecvFrom
< //#define p_WSARemoveServiceClass WSARemoveServiceClass
< #define p_WSAResetEvent WSAResetEvent
< #define p_WSASend WSASend
< //#define p_WSASendDisconnect WSASendDisconnect
< #define p_WSASendTo WSASendTo
< #define p_WSASetEvent WSASetEvent
< #define p_WSAWaitForMultipleEvents WSAWaitForMultipleEvents
---
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	DYNAMICWINSOCK(WSAAccept, LPFN_WSAACCEPT);
> 	DYNAMICWINSOCK(WSAAddressToStringA, LPFN_WSAADDRESSTOSTRINGA);
> 	DYNAMICWINSOCK(WSAAddressToStringW, LPFN_WSAADDRESSTOSTRINGW);
> 	DYNAMICWINSOCK(WSACloseEvent, LPFN_WSACLOSEEVENT);
> 	DYNAMICWINSOCK(WSAConnect, LPFN_WSACONNECT);
> 	DYNAMICWINSOCK(WSACreateEvent, LPFN_WSACREATEEVENT);
> 	DYNAMICWINSOCK(WSADuplicateSocketA, LPFN_WSADUPLICATESOCKETA);
> 	DYNAMICWINSOCK(WSADuplicateSocketW, LPFN_WSADUPLICATESOCKETW);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersA, LPFN_WSAENUMNAMESPACEPROVIDERSA);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersW, LPFN_WSAENUMNAMESPACEPROVIDERSW);
> 	DYNAMICWINSOCK(WSAEnumNetworkEvents, LPFN_WSAENUMNETWORKEVENTS);
> 	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
> 	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
> 	DYNAMICWINSOCK(WSAEventSelect, LPFN_WSAEVENTSELECT);
> 	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
> 	DYNAMICWINSOCK(WSAGetQOSByName, LPFN_WSAGETQOSBYNAME);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoA, LPFN_WSAGETSERVICECLASSINFOA);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoW, LPFN_WSAGETSERVICECLASSINFOW);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdA, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdW, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW);
> 	DYNAMICWINSOCK(WSAHtonl, LPFN_WSAHTONL);
> 	DYNAMICWINSOCK(WSAHtons, LPFN_WSAHTONS);
> 	DYNAMICWINSOCK(WSAInstallServiceClassA, LPFN_WSAINSTALLSERVICECLASSA);
> 	DYNAMICWINSOCK(WSAInstallServiceClassW, LPFN_WSAINSTALLSERVICECLASSW);
> 	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
> 	DYNAMICWINSOCK(WSAJoinLeaf, LPFN_WSAJOINLEAF);
> 	DYNAMICWINSOCK(WSALookupServiceBeginA, LPFN_WSALOOKUPSERVICEBEGINA);
> 	DYNAMICWINSOCK(WSALookupServiceBeginW, LPFN_WSALOOKUPSERVICEBEGINW);
> 	DYNAMICWINSOCK(WSALookupServiceEnd, LPFN_WSALOOKUPSERVICEEND);
> 	DYNAMICWINSOCK(WSALookupServiceNextA, LPFN_WSALOOKUPSERVICENEXTA);
> 	DYNAMICWINSOCK(WSALookupServiceNextW, LPFN_WSALOOKUPSERVICENEXTW);
> 	DYNAMICWINSOCK(WSANtohl, LPFN_WSANTOHL);
> 	DYNAMICWINSOCK(WSANtohs, LPFN_WSANTOHS);
> 	DYNAMICWINSOCK(WSARecv, LPFN_WSARECV);
> 	DYNAMICWINSOCK(WSARecvDisconnect, LPFN_WSARECVDISCONNECT);
> 	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
> 	DYNAMICWINSOCK(WSARemoveServiceClass, LPFN_WSAREMOVESERVICECLASS);
> 	DYNAMICWINSOCK(WSAResetEvent, LPFN_WSARESETEVENT);
> 	DYNAMICWINSOCK(WSASend, LPFN_WSASEND);
> 	DYNAMICWINSOCK(WSASendDisconnect, LPFN_WSASENDDISCONNECT);
> 	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
> 	DYNAMICWINSOCK(WSASetEvent, LPFN_WSASETEVENT);
> 	DYNAMICWINSOCK(WSASetServiceA, LPFN_WSASETSERVICEA);
> 	DYNAMICWINSOCK(WSASetServiceW, LPFN_WSASETSERVICEW);
> 	DYNAMICWINSOCK(WSASocketA, LPFN_WSASOCKETA);
> 	DYNAMICWINSOCK(WSASocketW, LPFN_WSASOCKETW);
> 	DYNAMICWINSOCK(WSAStringToAddressA, LPFN_WSASTRINGTOADDRESSA);
> 	DYNAMICWINSOCK(WSAStringToAddressW, LPFN_WSASTRINGTOADDRESSW);
> 	DYNAMICWINSOCK(WSAWaitForMultipleEvents, LPFN_WSAWAITFORMULTIPLEEVENTS);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
42a44
> #include	"IPXAddress.h"
77c79,80
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
95a99,100
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
111c116,118
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
177a185,190
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
198a212,218
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
201a222,245
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
224a269,270
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
243a290,291
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
270a319,324
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
390a445,451
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
393a455,478
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
425a511,512
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
445a533,534
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
127a128,130
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
157a161
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
180a185,186
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1451a1453,1458
> 	//
> 	// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1452a1460,1478
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1455a1482,1484
> 		case 2:
> 		default:
> 		{
1456a1486,1488
> 			break;
> 		}
> 	}
1530a1563,1568
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1531a1570,1588
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1534a1592,1594
> 		case 2:
> 		default:
> 		{
1535a1596,1598
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
136,138d136
< 
< /* BUGBUG: [mgere] Removed UI.  Find cleaner way of doing this.
< 
146,150d143
< */
< 
< 	SetTempHostName( "", 0 );
<         SettingsDialogComplete( hr );
< 	hr = S_OK;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
49a51
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
81a85
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
83a88
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
178a184,190
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
197a210,225
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
342a371,377
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
352a388,393
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
442a484,497
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
443a499
> 
445a502,518
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
458a532,546
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
60a63,65
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
61a67
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
263a265,272
> 	
> 	//
> 	// Winsock 2 functionality always exists on WinNT.  If we're on Win9x, we can
> 	// only use Winsock2 interfaces for TCP.
> 	//
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) ||
> 		 ( ( LOWORD( GetWinsockVersion() ) >= 2 ) && ( m_pSPData->GetType() == TYPE_IP ) ) )
> 	{
264a274,278
> 	}
> 	else
> 	{
> 		m_pSendFunction = Winsock1Send;
> 	}
408a423,448
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( ( LOWORD( GetWinsockVersion() ) == 1 ) ||
> 			 ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_pSPData->GetType() == TYPE_IPX ) ) )
> 		{
> ////			HRESULT	hTempResult;
> //			THREAD_POOL_JOB	*pTemp;
> //
> //
> //			pTemp = m_pRemoveSocketPortData;
> //			m_pRemoveSocketPortData = NULL;
> //			INT3;
> ////			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> ////			if ( hTempResult != DPN_OK )
> ////			{
> ////			    DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> ////			    DisplayDNError( 0, hTempResult );
> ////			}
> 			m_pSPData->GetThreadPool()->RemoveSocketPort( this );
> 
> 		}
> 
837a878,890
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
839a893,999
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
840a1001,1003
> 
> 
> //**********************************************************************
841a1005,1155
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> //	TempBuffer = static_cast<char*>( DNMalloc( MAX_MESSAGE_SIZE ) );
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
869,870c1183,1184
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
881a1196,1198
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
934a1252,1254
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1012c1332,1333
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1026a1348,1350
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1091a1416,1417
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1139a1466,1467
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1707a2036,2042
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1741a2077,2078
> 			break;
> 		}
1742a2080,2152
> 		//
> 		// Win9x.
> 		// If this is not an IPX socket and Winsock 2 (or greater) is available,
> 		// call the Winsock 2 read function.  If this is IPX or we're stuck with
> 		// Winsock 1, inform the thread pool as such.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 
> 			if ( ( LOWORD( GetWinsockVersion() ) >= 2 ) &&
> 				 ( m_pSPData->GetType() == TYPE_IP ) )
> 			{
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 					DPF( 0, "Problem issuing initial read in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 			}
> 			else
> 			{
> 				DNASSERT( m_pSPData != NULL );
> 				hr = m_pSPData->GetThreadPool()->AddSocketPort( this );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Failed to add to active socket list!" );
> 					DisplayDNError( 0, hr );
> 					goto Failure;
> 				}
> 			}
> 
> //				//
> //				// Winsock 1.x
> //				//
> //				case 1:
> //				{
> //				    //
> //				    // we're handing this I/O request off to another thread, up reference count
> //				    //
> //				    AddRef();
> //				    fReferenceAdded = TRUE;
> //				    DNASSERT( m_pRemoveSocketPortData == NULL );
> //				    INT3;
> ////				    hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> ////				    if ( hr != DPN_OK )
> ////				    {
> ////				    	DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> ////				    	DisplayDNError( 0, hr );
> ////				    	goto Failure;
> ////				    }
> //				    DNASSERT( m_pRemoveSocketPortData != NULL );
> //
> //				    break;
> //				}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2382a2793,2964
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
> 
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			goto Exit;
> 			
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
238a239,240
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
242a245,247
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
286a292
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
51,52c51
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\ws2_32.lib
---
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
61a61,71
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
82a93
> 	 ..\DWinsock.cpp \
87a99,100
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
107,108d119
< MSC_OPTIMIZATION=/Odi /Zi
< NTDEBUGTYPE=both
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
104c104
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
122c122,123
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
158c159,160
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
243a246
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
244a248
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
247c251
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
254c258
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
281a286
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
47a49
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
183a187,252
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
496a566,571
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint( &EndpointPoolContext );
>     		break;
>     	}
> 
635a711,716
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
668a750,755
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
114a116,138
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
235c259,266
< 	DEBUG_ONLY( 
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
237c268,269
< 	)
---
> 						break;
> 					}
238a271,278
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
245c285,292
< 	DEBUG_ONLY(
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
247c294,295
< 	)
---
> 						break;
> 					}
248a297,304
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
282a339,345
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
336a400,404
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( DNGetOSType() )
> 	{
339a408,409
> 		case VER_PLATFORM_WIN32_NT:
> 		{
345a416,442
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
441a539,708
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> //	switch ( LOWORD( GetWinsockVersion() ) )
> //	{
> //		//
> //		// Winsock2, use events to signal I/O completion
> //		//
> //		case 2:
> //		{
> 	//
> 	// Win9x requires completion events for Winsock2.  Always allocate the events
> 	// even though the they might not be used because the network layer might
> 	// only support Winsock1.
> 	//
> 	DNASSERT( m_hWinsock2SendComplete == NULL );
> 	m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 										   TRUE,	// manual reset
> 										   FALSE,	// start unsignalled
> 										   NULL		// pointer to name (none)
> 										   );
> 	if ( m_hWinsock2SendComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Send!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 	m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 											  TRUE,		// manual reset
> 											  FALSE,	// start unsignalled
> 											  NULL		// pointer to name (none)
> 											  );
> 	if ( m_hWinsock2ReceiveComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Receive!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> //		    break;
> //		}
> //
> //		//
> //		// Winsock1, nothing special to do
> //		//
> //		case 1:
> //		{
> //		    break;
> //		}
> //
> //		default:
> //		{
> //		    INT3;
> //		}
> //	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	m_iTotalThreadCount++;
> 	
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		m_iTotalThreadCount--;
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
550a818,819
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
571a841
> 	}
649a920,925
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
665a942,943
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
814a1093
> 	m_IPXReadIODataPool.Deinitialize();
873a1153,1167
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			if ( pTempReadData == NULL )
> 			{
> 				DPF( 0, "Failed to get new IPX ReadIOData from pool!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
968a1263,1271
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1223a1527,1528
> 	switch ( DNGetOSType() )
> 	{
1226a1532,1533
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1243a1551,1579
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( m_JobQueue.SignalPendingJob() == FALSE )
> 			{
> 				hr = DPNERR_OUTOFMEMORY;
> 				DPF( 0, "Failed to signal pending job!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1354a1691,1692
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1361a1700
> 	}
1682a2022,2023
> 	switch ( DNGetOSType() )
> 	{
1683a2025,2034
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
1685a2037,2038
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1687a2041,2042
> 			break;
> 		}
1688a2044,2053
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1717a2083,2084
> 	switch ( DNGetOSType() )
> 	{
1718a2086,2093
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1721a2097,2098
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1731a2109,2121
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1975a2366
> 
1977a2369,2625
> // CThreadPool::AddSocketPort - add a socket to the Win9x watch list
> //
> // Entry:		Pointer to SocketPort
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::AddSocketPort( CSocketPort *const pSocketPort )
> {
> 	HRESULT	hr;
> 	BOOL	fSocketAdded;
> 
> 	
> 	DNASSERT( pSocketPort != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	fSocketAdded = FALSE;
> 
> 	Lock();
> 
> 	//
> 	// We're capped by the number of sockets we can use for Winsock1.  Make
> 	// sure we don't allocate too many sockets.
> 	//
> 	if ( m_uReservedSocketCount == FD_SETSIZE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "There are too many sockets allocated on Winsock1!" );
> 		goto Failure;
> 	}
> 
> 	m_uReservedSocketCount++;
> 	
> 	DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 	m_pSocketPorts[ m_SocketSet.fd_count ] = pSocketPort;
> 	m_SocketSet.fd_array[ m_SocketSet.fd_count ] = pSocketPort->GetSocket();
> 	m_SocketSet.fd_count++;
> 	fSocketAdded = TRUE;
> 
> 	//
> 	// add a reference to note that this socket port is being used by the thread
> 	// pool
> 	//
> 	pSocketPort->AddRef();
> 
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when adding socket port to active list!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	
> 
> //	DNASSERT( pSocketPort != NULL );
> //	DNASSERT( pCancelFunction != NULL );
> //	DNASSERT( ppRemoveSocketPortData != NULL );
> //	DNASSERT( *ppRemoveSocketPortData == NULL );
> //
> //	//
> //	// initialize
> //	//
> //	hr = DPN_OK;
> //	pJobData = NULL;
> //	pRemoveSocketPortData = NULL;
> //
> //	LockJobData();
> //
> //	//
> //	// always reserve a space for this socket and clean it up on a failure
> //	//
> //	m_uReservedSocketCount++;
> //
> //	//
> //	// We're capped by the number of sockets we can use for Winsock1.  Make
> //	// sure we don't allocate too many sockets.
> //	//
> //	if ( m_uReservedSocketCount == ( FD_SETSIZE + 1 ) )
> //	{
> //		hr = DPNERR_OUTOFMEMORY;
> //		DPF( 0, "There are too many sockets allocated on Winsock1!" );
> //		goto Failure;
> //	}
> //
> //	//
> //	// Allocate memory for job data.  Preallocate the remove socket port job so
> //	// we don't need to worry about being out of memory when we want to remove
> //	// the socket port.
> //	//
> //	pJobData = static_cast<WORK_THREAD_JOB*>( m_JobPool.Get( &m_JobPool ) );
> //	if ( pJobData == NULL )
> //	{
> //		hr = DPNERR_OUTOFMEMORY;
> //		DPF( 0, "Cannot allocate memory for SubmitAddSocketPort job!" );
> //		goto Failure;
> //	}
> //
> //	pRemoveSocketPortData = static_cast<WORK_THREAD_JOB*>( m_JobPool.Get( &m_JobPool ) );
> //	if ( pRemoveSocketPortData == NULL )
> //	{
> //		hr = DPNERR_OUTOFMEMORY;
> //		DPF( 0, "Cannot allocate memory for SubmitRemoveSocketPort job!" );
> //	}
> //
> //	//
> //	// set information
> //	//
> //	pJobData->JobType = JOB_ADD_WIN9X_SOCKET;
> //	pJobData->JobData.JobAddSocket.pSocketPort = pSocketPort;
> //	pJobData->pCancelFunction = pCancelFunction;
> //
> //	pRemoveSocketPortData->JobType = JOB_REMOVE_WIN9X_SOCKET;
> //	pRemoveSocketPortData->JobData.JobRemoveSocket.pSocketPort = pSocketPort;
> //
> //	hr = SubmitWorkItem( pJobData );
> //	if ( hr != DPN_OK )
> //	{
> //		DPF( 0, "Problem submitting AddSocketPort job!" );
> //		DisplayDNError( 0, hr );
> //		goto Failure;
> //	}
> //
> Exit:
> 	Unlock();
> //	*ppRemoveSocketPortData = pRemoveSocketPortData;
> //	UnlockJobData();
> //
> 	return	hr;
> 
> Failure:
> 	if ( fSocketAdded != FALSE )
> 	{
> 		AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
> 		m_SocketSet.fd_count--;
> 		m_pSocketPorts[ m_SocketSet.fd_count ] = NULL;
> 		m_SocketSet.fd_array[ m_SocketSet.fd_count ] = NULL;
> 		fSocketAdded = FALSE;
> 	}
> //	if ( pJobData != NULL )
> //	{
> //		m_JobPool.Release( &m_JobPool, pJobData );
> //		pJobData = NULL;
> //	}
> //
> //	if ( pRemoveSocketPortData != NULL )
> //	{
> //		m_JobPool.Release( &m_JobPool, pRemoveSocketPortData );
> //		pRemoveSocketPortData = NULL;
> //	}
> //
> //	m_uReservedSocketCount--;
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::RemoveSocketPort - remove a socket from the Win9x watch list
> //
> // Entry:		Pointer to socket port to remove
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::RemoveSocketPort( CSocketPort *const pSocketPort )
> {
> 	UINT_PTR	uIndex;
> 
> 
> 	DNASSERT( pSocketPort != NULL );
> 	
> 	Lock();
> 
> 	uIndex = m_SocketSet.fd_count;
> 	DNASSERT( uIndex != 0 );
> 	while ( uIndex != 0 )
> 	{
> 		uIndex--;
> 
> 		if ( m_pSocketPorts[ uIndex ] == pSocketPort )
> 		{
> 			m_uReservedSocketCount--;
> 			m_SocketSet.fd_count--;
> 
> 			memmove( &m_pSocketPorts[ uIndex ],
> 					 &m_pSocketPorts[ uIndex + 1 ],
> 					 ( sizeof( m_pSocketPorts[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			memmove( &m_SocketSet.fd_array[ uIndex ],
> 					 &m_SocketSet.fd_array[ uIndex + 1 ],
> 					 ( sizeof( m_SocketSet.fd_array[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			//
> 			// clear last entry which is now unused
> 			//
> 			memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) );
> 			memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) );
> 
> 			//
> 			// end the loop
> 			//
> 			uIndex = 0;
> 		}
> 	}
> 
> 	Unlock();
> 	
> 	pSocketPort->DecRef();
> 
> 	//
> 	// It's really not necessary to signal a new job here because there were
> 	// active sockets on the last iteration of the Win9x thread.  That means the
> 	// Win9x thread was in a polling mode to check for sockets and the next time
> 	// through it will notice that there is a missing socket.  By signalling the
> 	// job event we reduce the time needed for the thread to figure out that the
> 	// socket is gone.
> 	//
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when removeing socket port to active list!" );
> 	}
> 
> //	//
> //	// set information
> //	//
> //	DNASSERT( pRemoveSocketPortData->JobType == JOB_REMOVE_WIN9X_SOCKET );
> //	DNASSERT( pRemoveSocketPortData->JobData.JobRemoveSocket.pSocketPort == pSocketPort );
> //	pRemoveSocketPortData->pCancelFunction = pCancelFunction;
> //
> //	hr = SubmitWorkItem( pRemoveSocketPortData );
> //	if ( hr != DPN_OK )
> //	{
> //		DPF( 0, "Problem submitting RemoveSocketPort job!" );
> //		DisplayDNError( 0, hr );
> //		goto Failure;
> //	}
> //
> //Exit:
> //	UnlockJobData();
> //
> //	return	hr;
> //
> //Failure:
> //	DNASSERT( pRemoveSocketPortData != NULL );
> //	m_JobPool.Release( &m_JobPool, pRemoveSocketPortData );
> //
> //	goto Exit;
> }
> //**********************************************************************
> 
> 
> 
> //**********************************************************************
> // ------------------------------
2124a2773,3749
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 	
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> //	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> //	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 	
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 	
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		DWORD	dwWaitReturn;
> 
> 		
> 		//
> 		// Update the job time so we know how long to wait.  We can
> 		// only get here if a socket was just added to the socket list, or
> 		// we've been servicing sockets.
> 		//
> 		DNTimeGet( &CurrentTime );
> 		if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 		{
> 			pThisThreadPool->LockTimerData();
> 			CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																		   &CoreData.NextTimerJobTime );
> 			if ( CoreData.fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 			}
> 			pThisThreadPool->UnlockTimerData();
> 		}
> 
> 		DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 		dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 
> 		//
> 		// Check for Winsock1 sockets.  If there are some around, do a quick poll
> 		// of them to check of I/O before entering the main Winsock2 loop for
> 		// the real timing.
> 		//
> 		pThisThreadPool->Lock();
> 		if ( pSocketSet->fd_count != 0 )
> 		{
> 			pThisThreadPool->Unlock();
> 
> 			pThisThreadPool->CheckWinsock1IO( pSocketSet );
> 			
> 			//
> 			// since there are Winsock1 sockets active, don't spend a lot of
> 			// time waiting for something to happen for Winsock2
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				dwMaxWaitTime = SelectTimeslice;
> 			}
> 		}
> 		else
> 		{
> 			pThisThreadPool->Unlock();
> 		}
> 
> 
> 		//
> 		// Check Winsock2 sockets.
> 		//
> 		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> 												 CoreData.hWaitHandles,					// handles to wait on
> 												 FALSE,									// don't wait for all to be signalled
> 												 dwMaxWaitTime,							// wait timeout
> 												 TRUE									// we're alertable for APCs
> 												 );
> 		switch ( dwWaitReturn )
> 		{
> 			//
> 			// timeout, don't do anything, we'll probably process timer jobs on
> 			// the next loop
> 			//
> 			case WAIT_TIMEOUT:
> 			{
> 				break;
> 			}
> 
> 			//
> 			// New job.  Account for the time spent in the wait.  Don't
> 			// account for time after the job is complete because it's
> 			// possible that the job was an job submission which will want
> 			// to reset the wait time.
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 			{
> 				DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 				pThisThreadPool->ProcessWin9xJob( &CoreData );
> 				break;
> 			}
> 
> 			//
> 			// SP closing
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 			{
> 				DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 				fLooping = FALSE;
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 send complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending write list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Failed to reset Winsock2 send event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> 				pThisThreadPool->CompleteOutstandingSends();
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 receive complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending read list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Failed to reset Winsock2 receive event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> 				pThisThreadPool->CompleteOutstandingReceives();
> 				break;
> 			}
> 
> 			//
> 			// There are I/O completion routines scheduled on this thread.
> 			// This is not a good thing!
> 			//
> 			case WAIT_IO_COMPLETION:
> 			{
> 				DPF( 1, "WARNING: APC was serviced on the Win9x IO service thread!  What is the application doing??" );
> 				break;
> 			}
> 
> 			//
> 			// wait failed
> 			//
> 			case WAIT_FAILED:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Wait failed!" );
> 				DisplayDNError( 0, dwError );
> 				break;
> 			}
> 
> 			//
> 			// problem
> 			//
> 			default:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Unknown problem in wait!" );
> 				DisplayDNError( 0, dwError );
> 				DNASSERT( FALSE );
> 				break;
> 			}
> 		}
> 	}
> 
> //	while ( fLooping != FALSE )
> //	{
> 		//
> 		// check for Winsock1 sockets.  If there are some around, we need to
> 		// use the 'select' call to perform the timing
> 		//
> //
> //		pThisThreadPool->Lock();
> //		if ( pSocketSet->fd_count == 0 )
> //		{
> //			DWORD	dwWaitReturn;
> //
> //
> //			pThisThreadPool->Unlock();
> //			//
> //			// There are no sockets active.  Wait for the SP to close, a job
> //			// to be submitted, or a timeout for enumeration.
> //			//
> //			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> ////			dwElapsedTime = GetTickCount();
> //
> //			DNTimeGet( &CurrentTime );
> //			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> //			{
> //				pThisThreadPool->LockTimerData();
> //				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> //																			   &CoreData.NextTimerJobTime );
> //				if ( CoreData.fTimerJobsActive != FALSE )
> //				{
> //					DPF( 8, "There are active jobs left on timer with no Winsock1 sockets active!" );
> //				}
> //				pThisThreadPool->UnlockTimerData();
> //			}
> //
> //			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> //			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> //
> //#pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> //			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> //
> //			dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> //													 CoreData.hWaitHandles,					// handles to wait on
> //													 FALSE,									// don't wait for all to be signalled
> //													 dwMaxWaitTime,							// wait timeout
> //													 TRUE									// we're alertable for APCs
> //													 );
> //			switch ( dwWaitReturn )
> //			{
> //				//
> //				// timeout, don't do anything, we'll probably process jobs on the next loop
> //				//
> //				case WAIT_TIMEOUT:
> //				{
> //					break;
> //				}
> //
> //				//
> //				// New job.  Account for the time spent in the wait.  Don't
> //				// account for time after the job is complete because it's
> //				// possible that the job was an job submission which will want
> //				// to reset the wait time.
> //				//
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> //				{
> //					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> //
> //					pThisThreadPool->ProcessWin9xJob( &CoreData );
> //
> //					break;
> //				}
> //
> //				//
> //				// SP closing
> //				//
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> //				{
> //					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> //					fLooping = FALSE;
> //
> //					break;
> //				}
> //
> //				//
> //				// Winsock2 send complete
> //				//
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> //				{
> //					//
> //					// reset the event so it will be signalled again if anything
> //					// completes while we're scanning the pending write list
> //					//
> //					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> //					{
> //						DWORD	dwError;
> //
> //
> //						dwError = GetLastError();
> //						DPF( 0, "Failed to reset Winsock2 send event!" );
> //						DisplayErrorCode( 0, dwError );
> //					}
> //
> //					pThisThreadPool->CompleteOutstandingSends();
> //					break;
> //				}
> //
> //				//
> //				// Winsock2 receive complete
> //				//
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> //				{
> //					//
> //					// reset the event so it will be signalled again if anything
> //					// completes while we're scanning the pending read list
> //					//
> //					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> //					{
> //						DWORD	dwError;
> //
> //
> //						dwError = GetLastError();
> //						DPF( 0, "Failed to reset Winsock2 receive event!" );
> //						DisplayErrorCode( 0, dwError );
> //					}
> //
> //					pThisThreadPool->CompleteOutstandingReceives();
> //					break;
> //				}
> //
> //				//
> //				// There are I/O completion routines scheduled on this thread,
> //				// no problem.
> //				//
> //				case WAIT_IO_COMPLETION:
> //				{
> //					break;
> //				}
> //
> //				//
> //				// wait failed
> //				//
> //				case WAIT_FAILED:
> //				{
> //					DWORD	dwError;
> //
> //
> //					dwError = GetLastError();
> //					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> //					DisplayDNError( 0, dwError );
> //					break;
> //				}
> //
> //				//
> //				// problem
> //				//
> //				default:
> //				{
> //					DWORD	dwError;
> //
> //
> //					dwError = GetLastError();
> //					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> //					DisplayDNError( 0, dwError );
> //					DNASSERT( FALSE );
> //					break;
> //				}
> //			}
> //		} // if ( CoreData.dwActiveSocketCount == 0 )
> //		else
> //		{
> //			INT				iSelectReturn;
> //			DWORD			dwWaitReturn;
> //			FD_SET			ReadSocketSet;
> //			FD_SET			WriteSocketSet;
> //			FD_SET			ErrorSocketSet;
> //
> //
> //			pThisThreadPool->Unlock();
> //
> //			//
> //			// Update the job time so we know how long to wait.  We can
> //			// only get here if a socket was just added to the socket list, or
> //			// we've been servicing sockets.
> //			//
> //
> //			DNTimeGet( &CurrentTime );
> //
> //			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> //			{
> //				pThisThreadPool->LockTimerData();
> //				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> //																			   &CoreData.NextTimerJobTime );
> //				if ( CoreData.fTimerJobsActive != FALSE )
> //				{
> //					DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> //				}
> //				pThisThreadPool->UnlockTimerData();
> //			}
> //
> //			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> //#pragma	BUGBUG( johnkan, "Busted Win64!" )
> //			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> //
> //			//
> //			// Wait for something to happen on a socket or wait for next enum
> //			// service.  We're supposed to pass select times in microseconds,
> //			// but multiplying by 1000 is slower than letting the compiler
> //			// get fancy with multiplying by 1024, and the relative error
> //			// is negligible.
> //			//
> //			//
> //			if ( SelectTimeslice < dwMaxWaitTime )
> //			{
> //				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> //			}
> //			else
> //			{
> //				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> //			}
> //
> //			//
> //			// Make a local copy of all of the sockets.  This isn't totally
> //			// efficient, but it works.  Multiplying by active socket count will
> //			// spend half the time in the integer multiply.
> //			//
> //			pThisThreadPool->Lock();
> //			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> //			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> //			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> //			pThisThreadPool->Unlock();
> //
> //			DNASSERT( SelectTimeout.tv_sec == 0 );
> //			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> //									  &ReadSocketSet,	// sockets to check for read
> //									  NULL,				// sockets to check for write (don't check writes)
> //									  &ErrorSocketSet,	// sockets to check for error
> //									  &SelectTimeout	// wait timeout
> //									  );
> //			switch ( iSelectReturn )
> //			{
> //				//
> //				// timeout
> //				//
> //				case 0:
> //				{
> //					break;
> //				}
> //
> //				//
> //				// select got pissed
> //				//
> //				case SOCKET_ERROR:
> //				{
> //					DWORD	dwWSAError;
> //
> //
> //					dwWSAError = p_WSAGetLastError();
> //					switch ( dwWSAError )
> //					{
> //						//
> //						// This socket was probably closed
> //						//
> //						case WSAENOTSOCK:
> //						{
> //							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> //							break;
> //						}
> //
> //						//
> //						// other
> //						//
> //						default:
> //						{
> //							DPF( 0, "Problem selecting all sockets for service!" );
> //							DisplayWinsockError( 0, dwWSAError );
> //							INT3;
> //							break;
> //						}
> //					}
> //
> //					break;
> //				}
> //
> //				//
> //				// Check for sockets needing read service and error service.
> //				//
> //				default:
> //				{
> //					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> //					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> //
> //					break;
> //				}
> //			}
> //
> //			//
> //			// check for writes only
> //			//
> //			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> //									  NULL,				// sockets to check for read (don't check reads)
> //									  &WriteSocketSet,	// sockets to check for write
> //									  NULL,				// sockets to check for error (don't check errors)
> //									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> //									  );
> //			switch ( iSelectReturn )
> //			{
> //				//
> //				// timeout
> //				//
> //				case 0:
> //				{
> //					INT3;
> //					break;
> //				}
> //
> //				//
> //				// select got pissed
> //				//
> //				case SOCKET_ERROR:
> //				{
> //					DWORD	dwWSAError;
> //
> //
> //					dwWSAError = p_WSAGetLastError();
> //					switch ( dwWSAError )
> //					{
> //						//
> //						// this socket was probably closed
> //						//
> //						case WSAENOTSOCK:
> //						{
> //							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> //							break;
> //						}
> //
> //						//
> //						// other
> //						//
> //						default:
> //						{
> //							DPF( 0, "Problem selecting write sockets for service!" );
> //							DisplayWinsockError( 0, dwWSAError );
> //							INT3;
> //
> //							break;
> //						}
> //					}
> //
> //					break;
> //				}
> //
> //				//
> //				// Check for sockets needing write service
> //				//
> //				default:
> //				{
> //					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> //
> //					break;
> //				}
> //			}
> //
> //			//
> //			// since we just serviced sockets, make a quick check for pending
> //			// events
> //			//
> //			dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),	// count of handles
> //													 CoreData.hWaitHandles,				// handles to wait on
> //													 FALSE,								// don't wait for all to be signalled
> //													 0,									// make a quick check
> //													 TRUE								// we're alertable for APCs
> //													 );
> //			switch ( dwWaitReturn )
> //			{
> //				//
> //				// nothing was signalled, keep looping
> //				//
> //				case WAIT_TIMEOUT:
> //				{
> //					break;
> //				}
> //
> //				//
> //				// SP closing
> //				//
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> //				{
> //					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> //					fLooping = FALSE;
> //
> //					break;
> //				}
> //
> //				//
> //				// pending job
> //				//
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> //				{
> //					pThisThreadPool->ProcessWin9xJob( &CoreData );
> //
> //					break;
> //				}
> //
> //				//
> //				// Winsock 2 I/O complete, we should not be getting this if
> //				// we're using Winsock1 support!!!
> //				//
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> //				{
> //					DNASSERT( FALSE );
> //					break;
> //				}
> //
> //				//
> //				// problem
> //				//
> //				default:
> //				{
> //					DWORD	dwError;
> //
> //
> //					dwError = GetLastError();
> //					DPF( 0, "Win9x wait for events with sockets active failed!" );
> //					DisplayErrorCode( 0, dwError );
> //					DNASSERT( FALSE );
> //					break;
> //				}
> //			}
> //		}
> //	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2521a4147,4501
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// Remove and process a single job from the list.  If there is no job, skip
> 	// to the end of the function.
> 	//
> 	pJobInfo = GetWorkItem();
> 
> 	if ( pJobInfo == NULL )
> 	{
> 		goto Exit;
> 	}
> 
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> //		//
> //		// start monitoring a port for I/O
> //		//
> //		case JOB_ADD_WIN9X_SOCKET:
> //		{
> //			DPF( 8, "WorkThread job ADD_SOCKET" );
> //
> //			//
> //			// add this port to the ends of the lists
> //			//
> //			LockJobData();
> //
> //			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> //			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> //			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> //			m_SocketSet.fd_count++;
> //
> //			UnlockJobData();
> //
> //			break;
> //		}
> //
> //		//
> //		// stop monitoring a port for I/O
> //		//
> //		case JOB_REMOVE_WIN9X_SOCKET:
> //		{
> //			UINT_PTR	uIdx;
> //
> //
> //			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> //
> //			//
> //			// remove this port from the lists
> //			//
> //			LockJobData();
> //
> //			DNASSERT( m_uReservedSocketCount != 0 );
> //			uIdx = m_SocketSet.fd_count;
> //			DNASSERT( uIdx != 0 );
> //			do
> //			{
> //				uIdx--;
> //
> //				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> //				{
> //					m_uReservedSocketCount--;
> //					m_SocketSet.fd_count--;
> //
> //					//
> //					// release our I/O reference to this item and shift all other entries down in
> //					// the socket array
> //					//
> //					m_pSocketPorts[ uIdx ]->DecRef();
> //					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> //					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> //
> //					//
> //					// clear last entry (which is now unused) in the debug build
> //					//
> //					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> //					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> //
> //					//
> //					// end the loop.
> //					//
> //					uIdx = 0;
> //				}
> //			} while ( uIdx != 0 );
> //
> //			UnlockJobData();
> //
> //			break;
> //		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> 
> Exit:
> 	return;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CheckWinsock1IO - check the IO status for Winsock1 sockets
> //
> // Entry:		Pointer to sockets to watch
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CheckWinsock1IO( const FD_SET *const pWinsock1Sockets )
> {
> static	const TIMEVAL	SelectNoTime = { 0 };
> 	INT			iSelectReturn;
> 	FD_SET		ReadSocketSet;
> 	FD_SET		WriteSocketSet;
> 	FD_SET		ErrorSocketSet;
> 
> 
> 	//
> 	// Make a local copy of all of the sockets.  This isn't totally
> 	// efficient, but it works.  Multiplying by active socket count will
> 	// spend half the time in the integer multiply.
> 	//
> 	Lock();
> 	memcpy( &ReadSocketSet, pWinsock1Sockets, sizeof( ReadSocketSet ) );
> 	memcpy( &WriteSocketSet, pWinsock1Sockets, sizeof( WriteSocketSet ) );
> 	memcpy( &ErrorSocketSet, pWinsock1Sockets, sizeof( ErrorSocketSet ) );
> 	Unlock();
> 
> 	//
> 	// Don't check write sockets here because it's very likely that they're ready
> 	// for service but have no outgoing data and will thrash
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  &ReadSocketSet,	// sockets to check for read
> 							  NULL,				// sockets to check for write (none)
> 							  &ErrorSocketSet,	// sockets to check for error
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// select got pissed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// WSAENOTSOCK = This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting all sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing read service and error service.
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 			ServiceWinsock1Sockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Since writes are likely to be ready, check for them separately
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  NULL,				// sockets to check for read (don't check reads)
> 							  &WriteSocketSet,	// sockets to check for write
> 							  NULL,				// sockets to check for error (don't check errors)
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// select got pissed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// this socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting write sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing write service
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 			break;
> 		}
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ServiceWinsock1Sockets - service requests on Winsock1 sockets ports
> //
> // Entry:		Pointer to set of sockets
> //				Pointer to service function
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction )
> {
> 	UINT_PTR	uSocketCount;
> 
> 
> 	uSocketCount = pSocketSet->fd_count;
> 	while ( uSocketCount > 0 )
> 	{
> 		UINT_PTR	uIdx;
> 
> 
> 		uSocketCount--;
> 		uIdx = m_SocketSet.fd_count;
> 		DNASSERT( uIdx != 0 );
> 		do
> 		{
> 			uIdx--;
> 			if ( pSocketSet->fd_array[ uSocketCount ] == m_SocketSet.fd_array[ uIdx ] )
> 			{
> 				//
> 				// call the service function and stop the loop
> 				//
> 				(m_pSocketPorts[ uIdx ]->*pServiceFunction)();
> 				uIdx = 0;
> 			}
> 
> 		} while ( uIdx > 0 );
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
98c99,100
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
144a147
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
149a153
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
156a161,163
> 		HRESULT	AddSocketPort( CSocketPort *const pSocketPort );
> 		void	RemoveSocketPort( CSocketPort *const pSocketPort );
> 
203a211
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
268a277
> 		HRESULT	Win9xInit( void );
278a288,289
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
279a291
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
288c300,303
< 		void	ServiceSockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );
---
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
> 
> 		void	CheckWinsock1IO( const FD_SET *const pWinsock1Sockets );
> 		void	ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
67c67,96
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
128a158,247
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
230a350
> //	we can either create an IPX instance or an IP instance
236a357,360
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
267c391,392
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
22a24
> #include	"DWinsock.h"
48,51d49
< // provides us winsock1/2 support
< #include "dwnsock1.inc"
< #include "dwnsock2.inc"
< 
78a77,78
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
> 
103a104
> 	INT		iVersion;
129c130
< 	// initialize Winsock
---
> 	// initialize the bindings to Winsock
131,137c132,133
< 	WORD wVersionRequested;
< 	WSADATA wsaData;
< 	int nRet;
< 
< 	wVersionRequested = MAKEWORD(2,2);
< 	nRet = p_WSAStartup(wVersionRequested, &wsaData);
< 	if (nRet || wVersionRequested != wsaData.wVersion)
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
139,141c135,137
< 		DPF( 0, "Problem starting winsock!" );
< 	    fReturn = FALSE;
< 	    goto Failure;
---
> 		DPF( 0, "Problem binding dynamic winsock functions!" );
> 		fReturn = FALSE;
> 		goto Failure;
143d138
< 
145a141,142
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
155c152,160
< 		p_WSACleanup();
---
> 		BOOL	fFreeReturn;
> 
> 
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 		if ( fFreeReturn == FALSE )
> 		{
> 			DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 		}
> 
185a191,193
> 	BOOL	fFreeReturn;
> 
> 
189c197,201
< 	p_WSACleanup();
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 	if ( fFreeReturn == FALSE )
> 	{
> 		DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 	}
196a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
197a223
> 
295a322
> 	INT_PTR iWinsockVersion;
305a333
> 	iWinsockVersion = GetWinsockVersion();
318c346
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize();
549a578,579
> 	WCHAR	cMillenniumHack;
> 	WCHAR*	pMillenniumHack = pWCHARString;
555a586,589
> 
> 	if ( pMillenniumHack < (WCHAR*) 0x0000FFFF )
> 		pMillenniumHack = &cMillenniumHack;
> 
561c595
< 								   pWCHARString,			// pointer to destination wide-char string
---
> 								   pMillenniumHack,			// pointer to destination wide-char string
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22
> #include	<WSIPX.h>
177a179,182
>  	switch ( DNSPInterface.pDataInterface->SPType )
> 	{
> 		case TYPE_IP:
> 		{
179a185,200
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			DPF( 9, "Attempting to create IPX datagram socket." );
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
274a296
> 		case TYPE_IPX:
508,509c530,532
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
693c716,717
< 			if ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) != 0 )
---
> 			if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) != 0 ) &&
> 				 ( IsEqualCLSID( DNSPInterface.pDataInterface->ClassID, CLSID_DP8SP_IPX ) == FALSE ) )
2677a2702,2713
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2889a2926,2937
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.  
