; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	c:\xbox\private\windows\directx\dsound\tools\acm\driver.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_09MAHP@XBADPCM?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@DLKE@ACM?5message?5?$CFlu?3?5?5?$CFx?5?$CFx?5?$CFx?5?$CFx?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@OOGL@System?5message?5?$CFlu?3?5?5?$CFx?5?$CFx?5?$CFx?5?$CFx@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@CHE@Driver?5?$CFlu?5open?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@ICOM@CloseDriver?5?$CFlu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@EDKA@Invalid?5driver?5identifier?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@BDBH@GetDriverDetails?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@KEJF@GetFormatTagDetails?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@LHIA@Details?5structure?5too?5small?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@ECFK@Bad?5format?5tag?5index?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@FLAG@Bad?5tag?5details?5request?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@EMFF@Returning?5PCM?5tag?5details?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@HLF@Returning?5ADPCM?5tag?5details?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@HOGF@Bad?5format?5tag?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@LCNF@GetFormatDetails?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@FOJI@Format?5buffer?5too?5small?5for?5PCM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@MAHP@Returning?5PCM?5details?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@DKMD@Format?5buffer?5too?5small?5for?5ADPC@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@BOJG@Returning?5ADPCM?5details?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@IGBB@Bad?5PCM?5format?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HFHJ@Bad?5ADPCM?5format?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@FLCN@Bad?5details?5request?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@JFBC@SuggestFormat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@HMHO@Destination?5format?5tag?5not?5ADPCM@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@GGPK@Destination?5channel?5count?5not?5?$CFl@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@JBNC@Destination?5sampling?5rate?5not?5?$CFl@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@DHFJ@Destination?5bit?5resolution?5not?5?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@MGDG@Suggesting?5ADPCM?5format?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@KNCF@Destination?5format?5tag?5not?5PCM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@OHLO@Suggesting?5PCM?5format?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KJAG@OpenStream?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@DGII@Bad?5destination?5format?5tag?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@CDBG@Bad?5source?5format?5tag?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@HAIG@Channel?9count?5mismatch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@ICMN@Sampling?9rate?5mismatch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@KDFD@Failed?5to?5initialize?5CODEC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BBEP@CloseStream?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@OBHB@GetStreamSize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GDN@No?5CODEC?5pointer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@LDDA@Bad?5size?5request?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@NBAE@ConvertStream?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@CDGC@CODEC?5failure?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSourceAlignment@CImaAdpcmCodec@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDestinationAlignment@CImaAdpcmCodec@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidPcmFormat@CXboxAdpcmDriver@@SGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidAdpcmFormat@CXboxAdpcmDriver@@SGHPBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreatePcmFormat@CXboxAdpcmDriver@@SGXGKPAUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateAdpcmFormat@CXboxAdpcmDriver@@SGXGKPAUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DbgPrint@@YAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyLoadStringW@@YGHPAUHINSTANCE__@@IPAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DriverProc@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OpenDriver@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVOPENDESCW@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloseDriver@CXboxAdpcmDriver@@SGJPAUHDRVR__@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDriverDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRIVERDETAILSW@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFormatTagDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMFORMATTAGDETAILSW@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFormatDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMFORMATDETAILSW@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SuggestFormat@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVFORMATSUGGEST@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OpenStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCImaAdpcmCodec@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloseStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStreamSize@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@PAUtACMDRVSTREAMSIZE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@PAUtACMDRVSTREAMHEADER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?m_adwStdSamplingRates@CXboxAdpcmDriver@@2QBKB	; CXboxAdpcmDriver::m_adwStdSamplingRates
PUBLIC	?m_dwOpenDriverCount@CXboxAdpcmDriver@@2KA	; CXboxAdpcmDriver::m_dwOpenDriverCount
_BSS	SEGMENT
?m_dwOpenDriverCount@CXboxAdpcmDriver@@2KA DD 01H DUP (?) ; CXboxAdpcmDriver::m_dwOpenDriverCount
_BSS	ENDS
CONST	SEGMENT
?m_adwStdSamplingRates@CXboxAdpcmDriver@@2QBKB DD 01f40H ; CXboxAdpcmDriver::m_adwStdSamplingRates
	DD	02b11H
	DD	03e80H
	DD	05622H
	DD	07d00H
	DD	0ac44H
	DD	0bb80H
?dwSupportMask@?1??SuggestFormat@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVFORMATSUGGEST@@@Z@4KB DD 0f0000H ; `CXboxAdpcmDriver::SuggestFormat'::`2'::dwSupportMask
CONST	ENDS
PUBLIC	?DbgPrint@@YAXPBDZZ				; DbgPrint
PUBLIC	??_C@_09MAHP@XBADPCM?3?5?$AA@			; `string'
PUBLIC	??_C@_01BJG@?6?$AA@				; `string'
EXTRN	_vsprintf:NEAR
EXTRN	__imp__OutputDebugStringA@4:NEAR
EXTRN	_strcat:NEAR
;	COMDAT ??_C@_09MAHP@XBADPCM?3?5?$AA@
; File c:\xbox\private\windows\directx\dsound\tools\acm\driver.cpp
CONST	SEGMENT
??_C@_09MAHP@XBADPCM?3?5?$AA@ DB 'XBADPCM: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT
??_C@_01BJG@?6?$AA@ DB 0aH, 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?DbgPrint@@YAXPBDZZ
_TEXT	SEGMENT
_pszFormat$ = 8
_szFinal$ = -1032
_va$ = -4
?DbgPrint@@YAXPBDZZ PROC NEAR				; DbgPrint, COMDAT

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H

; 135  :     CHAR                    szFinal[0x400];
; 136  :     va_list                 va;
; 137  : 
; 138  :     OutputDebugString("XBADPCM: ");

  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09MAHP@XBADPCM?3?5?$AA@ ; `string'
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 139  :     
; 140  :     va_start(va, pszFormat);

  00014	8d 45 0c	 lea	 eax, DWORD PTR _pszFormat$[ebp+4]
  00017	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 141  :     vsprintf(szFinal, pszFormat, va);

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 08	 mov	 edx, DWORD PTR _pszFormat$[ebp]
  00021	52		 push	 edx
  00022	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _szFinal$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _vsprintf
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 142  :     va_end(va);

  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 143  : 
; 144  :     strcat(szFinal, "\n");

  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01BJG@?6?$AA@ ; `string'
  0003d	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _szFinal$[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _strcat
  00049	83 c4 08	 add	 esp, 8

; 145  : 
; 146  :     OutputDebugStringA(szFinal);

  0004c	8d 95 f8 fb ff
	ff		 lea	 edx, DWORD PTR _szFinal$[ebp]
  00052	52		 push	 edx
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 147  : 
; 148  : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?DbgPrint@@YAXPBDZZ ENDP				; DbgPrint
_TEXT	ENDS
PUBLIC	?MyLoadStringW@@YGHPAUHINSTANCE__@@IPAGH@Z	; MyLoadStringW
EXTRN	__imp__MultiByteToWideChar@24:NEAR
EXTRN	__imp__LoadStringA@16:NEAR
; Function compile flags: /Odt
;	COMDAT ?MyLoadStringW@@YGHPAUHINSTANCE__@@IPAGH@Z
_TEXT	SEGMENT
_hInst$ = 8
_nResourceId$ = 12
_pszString$ = 16
_nStringLength$ = 20
_szAnsi$ = -256
?MyLoadStringW@@YGHPAUHINSTANCE__@@IPAGH@Z PROC NEAR	; MyLoadStringW, COMDAT

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H

; 180  :     CHAR                    szAnsi[0x100];
; 181  : 
; 182  :     //
; 183  :     // Load the ANSI version
; 184  :     //
; 185  : 
; 186  :     if(!LoadStringA(hInst, nResourceId, szAnsi, NUMELMS(szAnsi)))

  00009	68 00 01 00 00	 push	 256			; 00000100H
  0000e	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _szAnsi$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _nResourceId$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR _hInst$[ebp]
  0001c	52		 push	 edx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadStringA@16
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $L23624

; 187  :     {
; 188  :         return 0;

  00027	33 c0		 xor	 eax, eax
  00029	eb 1b		 jmp	 SHORT $L23622
$L23624:

; 189  :     }
; 190  : 
; 191  :     //
; 192  :     // Convert to UNICODE
; 193  :     //
; 194  : 
; 195  :     return MultiByteToWideChar(CP_ACP, 0, szAnsi, -1, pszString, nStringLength);

  0002b	8b 45 14	 mov	 eax, DWORD PTR _nStringLength$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR _pszString$[ebp]
  00032	51		 push	 ecx
  00033	6a ff		 push	 -1
  00035	8d 95 00 ff ff
	ff		 lea	 edx, DWORD PTR _szAnsi$[ebp]
  0003b	52		 push	 edx
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
$L23622:

; 196  : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 10 00	 ret	 16			; 00000010H
?MyLoadStringW@@YGHPAUHINSTANCE__@@IPAGH@Z ENDP		; MyLoadStringW
_TEXT	ENDS
PUBLIC	?OpenDriver@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVOPENDESCW@@@Z ; CXboxAdpcmDriver::OpenDriver
PUBLIC	?CloseDriver@CXboxAdpcmDriver@@SGJPAUHDRVR__@@K@Z ; CXboxAdpcmDriver::CloseDriver
PUBLIC	?GetDriverDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRIVERDETAILSW@@@Z ; CXboxAdpcmDriver::GetDriverDetails
PUBLIC	?GetFormatTagDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMFORMATTAGDETAILSW@@K@Z ; CXboxAdpcmDriver::GetFormatTagDetails
PUBLIC	?GetFormatDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMFORMATDETAILSW@@K@Z ; CXboxAdpcmDriver::GetFormatDetails
PUBLIC	?SuggestFormat@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVFORMATSUGGEST@@@Z ; CXboxAdpcmDriver::SuggestFormat
PUBLIC	?OpenStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@@Z ; CXboxAdpcmDriver::OpenStream
PUBLIC	?CloseStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@@Z ; CXboxAdpcmDriver::CloseStream
PUBLIC	?GetStreamSize@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@PAUtACMDRVSTREAMSIZE@@@Z ; CXboxAdpcmDriver::GetStreamSize
PUBLIC	?ConvertStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@PAUtACMDRVSTREAMHEADER@@@Z ; CXboxAdpcmDriver::ConvertStream
PUBLIC	_DriverProc@20
PUBLIC	??_C@_0BO@DLKE@ACM?5message?5?$CFlu?3?5?5?$CFx?5?$CFx?5?$CFx?5?$CFx?$AA@ ; `string'
PUBLIC	??_C@_0CB@OOGL@System?5message?5?$CFlu?3?5?5?$CFx?5?$CFx?5?$CFx?5?$CFx@ ; `string'
EXTRN	__imp__DefDriverProc@20:NEAR
;	COMDAT ??_C@_0BO@DLKE@ACM?5message?5?$CFlu?3?5?5?$CFx?5?$CFx?5?$CFx?5?$CFx?$AA@
CONST	SEGMENT
??_C@_0BO@DLKE@ACM?5message?5?$CFlu?3?5?5?$CFx?5?$CFx?5?$CFx?5?$CFx?$AA@ DB 'A'
	DB	'CM message %lu:  %x %x %x %x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OOGL@System?5message?5?$CFlu?3?5?5?$CFx?5?$CFx?5?$CFx?5?$CFx@
CONST	SEGMENT
??_C@_0CB@OOGL@System?5message?5?$CFlu?3?5?5?$CFx?5?$CFx?5?$CFx?5?$CFx@ DB 'S'
	DB	'ystem message %lu:  %x %x %x %x', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _DriverProc@20
_TEXT	SEGMENT
_dwDriverId$ = 8
_hdrvr$ = 12
_uMsg$ = 16
_lParam1$ = 20
_lParam2$ = 24
_DriverProc@20 PROC NEAR				; COMDAT

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 234  :     if(uMsg >= ACMDM_BASE)

  00006	81 7d 10 00 60
	00 00		 cmp	 DWORD PTR _uMsg$[ebp], 24576 ; 00006000H
  0000d	72 29		 jb	 SHORT $L23632

; 235  :     {
; 236  :         DPF("ACM message %lu:  %x %x %x %x", uMsg - ACMDM_BASE, dwDriverId, hdrvr, lParam1, lParam2);

  0000f	8b 45 18	 mov	 eax, DWORD PTR _lParam2$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 14	 mov	 ecx, DWORD PTR _lParam1$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR _hdrvr$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _dwDriverId$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _uMsg$[ebp]
  00022	81 e9 00 60 00
	00		 sub	 ecx, 24576		; 00006000H
  00028	51		 push	 ecx
  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@DLKE@ACM?5message?5?$CFlu?3?5?5?$CFx?5?$CFx?5?$CFx?5?$CFx?$AA@ ; `string'
  0002e	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00033	83 c4 18	 add	 esp, 24			; 00000018H

; 237  :     }
; 238  :     else

  00036	eb 21		 jmp	 SHORT $L23634
$L23632:

; 239  :     {
; 240  :         DPF("System message %lu:  %x %x %x %x", uMsg, dwDriverId, hdrvr, lParam1, lParam2);

  00038	8b 55 18	 mov	 edx, DWORD PTR _lParam2$[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 14	 mov	 eax, DWORD PTR _lParam1$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _hdrvr$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 08	 mov	 edx, DWORD PTR _dwDriverId$[ebp]
  00047	52		 push	 edx
  00048	8b 45 10	 mov	 eax, DWORD PTR _uMsg$[ebp]
  0004b	50		 push	 eax
  0004c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@OOGL@System?5message?5?$CFlu?3?5?5?$CFx?5?$CFx?5?$CFx?5?$CFx@ ; `string'
  00051	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00056	83 c4 18	 add	 esp, 24			; 00000018H
$L23634:

; 241  :     }
; 242  : 
; 243  :     //
; 244  :     // Handle generic driver messages
; 245  :     //
; 246  : 
; 247  :     switch(uMsg)
; 248  :     {

  00059	8b 4d 10	 mov	 ecx, DWORD PTR _uMsg$[ebp]
  0005c	89 4d fc	 mov	 DWORD PTR -4+[ebp], ecx
  0005f	83 7d fc 0f	 cmp	 DWORD PTR -4+[ebp], 15	; 0000000fH
  00063	77 27		 ja	 SHORT $L24031
  00065	83 7d fc 0f	 cmp	 DWORD PTR -4+[ebp], 15	; 0000000fH
  00069	74 3d		 je	 SHORT $L23642
  0006b	8b 55 fc	 mov	 edx, DWORD PTR -4+[ebp]
  0006e	83 ea 01	 sub	 edx, 1
  00071	89 55 fc	 mov	 DWORD PTR -4+[ebp], edx
  00074	83 7d fc 09	 cmp	 DWORD PTR -4+[ebp], 9
  00078	77 49		 ja	 SHORT $L23637
  0007a	8b 45 fc	 mov	 eax, DWORD PTR -4+[ebp]
  0007d	33 c9		 xor	 ecx, ecx
  0007f	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR $L24034[eax]
  00085	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L24035[ecx*4]
$L24031:
  0008c	81 7d fc 0b 60
	00 00		 cmp	 DWORD PTR -4+[ebp], 24587 ; 0000600bH
  00093	74 24		 je	 SHORT $L23644
  00095	eb 2c		 jmp	 SHORT $L23637
$L23640:

; 249  :         case DRV_CONFIGURE:
; 250  :         case DRV_QUERYCONFIGURE:
; 251  :             
; 252  :             //
; 253  :             // We're not supporting configuration
; 254  :             //
; 255  : 
; 256  :             return 0;

  00097	33 c0		 xor	 eax, eax
  00099	e9 66 01 00 00	 jmp	 $L23631
$L23641:

; 257  : 
; 258  :         case DRV_LOAD:
; 259  :         case DRV_FREE:
; 260  :             
; 261  :             //
; 262  :             // Ok, thanks.  We're ready to go
; 263  :             //
; 264  : 
; 265  :             return 1;

  0009e	b8 01 00 00 00	 mov	 eax, 1
  000a3	e9 5c 01 00 00	 jmp	 $L23631
$L23642:

; 266  : 
; 267  :         case DRV_DISABLE:
; 268  :         case DRV_ENABLE:
; 269  :         case DRV_POWER:
; 270  :             
; 271  :             //
; 272  :             // Ignored
; 273  :             //
; 274  : 
; 275  :             return 0;

  000a8	33 c0		 xor	 eax, eax
  000aa	e9 55 01 00 00	 jmp	 $L23631
$L23643:

; 276  : 
; 277  :         case DRV_INSTALL:
; 278  :         case DRV_REMOVE:
; 279  : 
; 280  :             //
; 281  :             // No extra install necessary
; 282  :             //
; 283  : 
; 284  :             return DRVCNF_OK;

  000af	b8 01 00 00 00	 mov	 eax, 1
  000b4	e9 4b 01 00 00	 jmp	 $L23631
$L23644:

; 285  : 
; 286  :         case ACMDM_DRIVER_ABOUT:
; 287  : 
; 288  :             //
; 289  :             // Not supporting an about box
; 290  :             //
; 291  : 
; 292  :             return MMSYSERR_NOTSUPPORTED;

  000b9	b8 08 00 00 00	 mov	 eax, 8
  000be	e9 41 01 00 00	 jmp	 $L23631
$L23637:

; 293  :     }
; 294  : 
; 295  :     //
; 296  :     // Handle the specific message
; 297  :     //
; 298  : 
; 299  :     switch(uMsg)
; 300  :     {

  000c3	8b 55 10	 mov	 edx, DWORD PTR _uMsg$[ebp]
  000c6	89 55 f8	 mov	 DWORD PTR -8+[ebp], edx
  000c9	81 7d f8 1b 60
	00 00		 cmp	 DWORD PTR -8+[ebp], 24603 ; 0000601bH
  000d0	77 47		 ja	 SHORT $L24032
  000d2	81 7d f8 1b 60
	00 00		 cmp	 DWORD PTR -8+[ebp], 24603 ; 0000601bH
  000d9	0f 84 8f 00 00
	00		 je	 $L23654
  000df	81 7d f8 0a 60
	00 00		 cmp	 DWORD PTR -8+[ebp], 24586 ; 0000600aH
  000e6	77 1a		 ja	 SHORT $L24033
  000e8	81 7d f8 0a 60
	00 00		 cmp	 DWORD PTR -8+[ebp], 24586 ; 0000600aH
  000ef	74 6b		 je	 SHORT $L23652
  000f1	83 7d f8 03	 cmp	 DWORD PTR -8+[ebp], 3
  000f5	74 41		 je	 SHORT $L23649
  000f7	83 7d f8 04	 cmp	 DWORD PTR -8+[ebp], 4
  000fb	74 4d		 je	 SHORT $L23651
  000fd	e9 e8 00 00 00	 jmp	 $L23646
$L24033:
  00102	81 7d f8 19 60
	00 00		 cmp	 DWORD PTR -8+[ebp], 24601 ; 00006019H
  00109	74 75		 je	 SHORT $L23656
  0010b	81 7d f8 1a 60
	00 00		 cmp	 DWORD PTR -8+[ebp], 24602 ; 0000601aH
  00112	74 7f		 je	 SHORT $L23659
  00114	e9 d1 00 00 00	 jmp	 $L23646
$L24032:
  00119	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]
  0011c	2d 4c 60 00 00	 sub	 eax, 24652		; 0000604cH
  00121	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00124	83 7d f8 03	 cmp	 DWORD PTR -8+[ebp], 3
  00128	0f 87 bc 00 00
	00		 ja	 $L23646
  0012e	8b 4d f8	 mov	 ecx, DWORD PTR -8+[ebp]
  00131	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L24036[ecx*4]
$L23649:

; 301  :         case DRV_OPEN:
; 302  :             
; 303  :             //
; 304  :             // Handle the open operation
; 305  :             //
; 306  : 
; 307  :             return CXboxAdpcmDriver::OpenDriver(hdrvr, (LPACMDRVOPENDESC)lParam2);

  00138	8b 55 18	 mov	 edx, DWORD PTR _lParam2$[ebp]
  0013b	52		 push	 edx
  0013c	8b 45 0c	 mov	 eax, DWORD PTR _hdrvr$[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 ?OpenDriver@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVOPENDESCW@@@Z ; CXboxAdpcmDriver::OpenDriver
  00145	e9 ba 00 00 00	 jmp	 $L23631
$L23651:

; 308  : 
; 309  :         case DRV_CLOSE:
; 310  :             
; 311  :             //
; 312  :             // Close the driver instance
; 313  :             //
; 314  :             
; 315  :             return CXboxAdpcmDriver::CloseDriver(hdrvr, dwDriverId);

  0014a	8b 4d 08	 mov	 ecx, DWORD PTR _dwDriverId$[ebp]
  0014d	51		 push	 ecx
  0014e	8b 55 0c	 mov	 edx, DWORD PTR _hdrvr$[ebp]
  00151	52		 push	 edx
  00152	e8 00 00 00 00	 call	 ?CloseDriver@CXboxAdpcmDriver@@SGJPAUHDRVR__@@K@Z ; CXboxAdpcmDriver::CloseDriver
  00157	e9 a8 00 00 00	 jmp	 $L23631
$L23652:

; 316  : 
; 317  :         case ACMDM_DRIVER_DETAILS:
; 318  :             
; 319  :             //
; 320  :             // Get driver details
; 321  :             //
; 322  : 
; 323  :             return CXboxAdpcmDriver::GetDriverDetails(hdrvr, (LPACMDRIVERDETAILS)lParam1);

  0015c	8b 45 14	 mov	 eax, DWORD PTR _lParam1$[ebp]
  0015f	50		 push	 eax
  00160	8b 4d 0c	 mov	 ecx, DWORD PTR _hdrvr$[ebp]
  00163	51		 push	 ecx
  00164	e8 00 00 00 00	 call	 ?GetDriverDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRIVERDETAILSW@@@Z ; CXboxAdpcmDriver::GetDriverDetails
  00169	e9 96 00 00 00	 jmp	 $L23631
$L23654:

; 324  : 
; 325  :         case ACMDM_FORMAT_SUGGEST:
; 326  : 
; 327  :             //
; 328  :             // Suggest a format
; 329  :             //
; 330  : 
; 331  :             return CXboxAdpcmDriver::SuggestFormat(hdrvr, (LPACMDRVFORMATSUGGEST)lParam1);

  0016e	8b 55 14	 mov	 edx, DWORD PTR _lParam1$[ebp]
  00171	52		 push	 edx
  00172	8b 45 0c	 mov	 eax, DWORD PTR _hdrvr$[ebp]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 ?SuggestFormat@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVFORMATSUGGEST@@@Z ; CXboxAdpcmDriver::SuggestFormat
  0017b	e9 84 00 00 00	 jmp	 $L23631
$L23656:

; 332  : 
; 333  :         case ACMDM_FORMATTAG_DETAILS:
; 334  : 
; 335  :             //
; 336  :             // Get format tag details
; 337  :             //
; 338  : 
; 339  :             return CXboxAdpcmDriver::GetFormatTagDetails(hdrvr, (LPACMFORMATTAGDETAILS)lParam1, (DWORD)lParam2);

  00180	8b 4d 18	 mov	 ecx, DWORD PTR _lParam2$[ebp]
  00183	51		 push	 ecx
  00184	8b 55 14	 mov	 edx, DWORD PTR _lParam1$[ebp]
  00187	52		 push	 edx
  00188	8b 45 0c	 mov	 eax, DWORD PTR _hdrvr$[ebp]
  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 ?GetFormatTagDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMFORMATTAGDETAILSW@@K@Z ; CXboxAdpcmDriver::GetFormatTagDetails
  00191	eb 71		 jmp	 SHORT $L23631
$L23659:

; 340  : 
; 341  :         case ACMDM_FORMAT_DETAILS:
; 342  :             
; 343  :             //
; 344  :             // Get format details
; 345  :             //
; 346  : 
; 347  :             return CXboxAdpcmDriver::GetFormatDetails(hdrvr, (LPACMFORMATDETAILS)lParam1, (DWORD)lParam2);

  00193	8b 4d 18	 mov	 ecx, DWORD PTR _lParam2$[ebp]
  00196	51		 push	 ecx
  00197	8b 55 14	 mov	 edx, DWORD PTR _lParam1$[ebp]
  0019a	52		 push	 edx
  0019b	8b 45 0c	 mov	 eax, DWORD PTR _hdrvr$[ebp]
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 ?GetFormatDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMFORMATDETAILSW@@K@Z ; CXboxAdpcmDriver::GetFormatDetails
  001a4	eb 5e		 jmp	 SHORT $L23631
$L23662:

; 348  : 
; 349  :         case ACMDM_STREAM_OPEN:
; 350  :             
; 351  :             //
; 352  :             // Open a new stream
; 353  :             //
; 354  : 
; 355  :             return CXboxAdpcmDriver::OpenStream(hdrvr, (LPACMDRVSTREAMINSTANCE)lParam1);

  001a6	8b 4d 14	 mov	 ecx, DWORD PTR _lParam1$[ebp]
  001a9	51		 push	 ecx
  001aa	8b 55 0c	 mov	 edx, DWORD PTR _hdrvr$[ebp]
  001ad	52		 push	 edx
  001ae	e8 00 00 00 00	 call	 ?OpenStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@@Z ; CXboxAdpcmDriver::OpenStream
  001b3	eb 4f		 jmp	 SHORT $L23631
$L23664:

; 356  : 
; 357  :         case ACMDM_STREAM_CLOSE:
; 358  :             
; 359  :             //
; 360  :             // Close an open stream
; 361  :             //
; 362  : 
; 363  :             return CXboxAdpcmDriver::CloseStream(hdrvr, (LPACMDRVSTREAMINSTANCE)lParam1);

  001b5	8b 45 14	 mov	 eax, DWORD PTR _lParam1$[ebp]
  001b8	50		 push	 eax
  001b9	8b 4d 0c	 mov	 ecx, DWORD PTR _hdrvr$[ebp]
  001bc	51		 push	 ecx
  001bd	e8 00 00 00 00	 call	 ?CloseStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@@Z ; CXboxAdpcmDriver::CloseStream
  001c2	eb 40		 jmp	 SHORT $L23631
$L23666:

; 364  : 
; 365  :         case ACMDM_STREAM_SIZE:
; 366  :             
; 367  :             //
; 368  :             // Get the size of converted data
; 369  :             //
; 370  : 
; 371  :             return CXboxAdpcmDriver::GetStreamSize(hdrvr, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);

  001c4	8b 55 18	 mov	 edx, DWORD PTR _lParam2$[ebp]
  001c7	52		 push	 edx
  001c8	8b 45 14	 mov	 eax, DWORD PTR _lParam1$[ebp]
  001cb	50		 push	 eax
  001cc	8b 4d 0c	 mov	 ecx, DWORD PTR _hdrvr$[ebp]
  001cf	51		 push	 ecx
  001d0	e8 00 00 00 00	 call	 ?GetStreamSize@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@PAUtACMDRVSTREAMSIZE@@@Z ; CXboxAdpcmDriver::GetStreamSize
  001d5	eb 2d		 jmp	 SHORT $L23631
$L23669:

; 372  : 
; 373  :         case ACMDM_STREAM_CONVERT:
; 374  : 
; 375  :             //
; 376  :             // Convert a stream of data
; 377  :             //
; 378  : 
; 379  :             return CXboxAdpcmDriver::ConvertStream(hdrvr, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMHEADER)lParam2);

  001d7	8b 55 18	 mov	 edx, DWORD PTR _lParam2$[ebp]
  001da	52		 push	 edx
  001db	8b 45 14	 mov	 eax, DWORD PTR _lParam1$[ebp]
  001de	50		 push	 eax
  001df	8b 4d 0c	 mov	 ecx, DWORD PTR _hdrvr$[ebp]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 ?ConvertStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@PAUtACMDRVSTREAMHEADER@@@Z ; CXboxAdpcmDriver::ConvertStream
  001e8	eb 1a		 jmp	 SHORT $L23631
$L23646:

; 380  :     }
; 381  : 
; 382  :     return DefDriverProc(dwDriverId, hdrvr, uMsg, lParam1, lParam2);

  001ea	8b 55 18	 mov	 edx, DWORD PTR _lParam2$[ebp]
  001ed	52		 push	 edx
  001ee	8b 45 14	 mov	 eax, DWORD PTR _lParam1$[ebp]
  001f1	50		 push	 eax
  001f2	8b 4d 10	 mov	 ecx, DWORD PTR _uMsg$[ebp]
  001f5	51		 push	 ecx
  001f6	8b 55 0c	 mov	 edx, DWORD PTR _hdrvr$[ebp]
  001f9	52		 push	 edx
  001fa	8b 45 08	 mov	 eax, DWORD PTR _dwDriverId$[ebp]
  001fd	50		 push	 eax
  001fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefDriverProc@20
$L23631:

; 383  : }

  00204	8b e5		 mov	 esp, ebp
  00206	5d		 pop	 ebp
  00207	c2 14 00	 ret	 20			; 00000014H
$L24035:
  0020a	00 00 00 00	 DD	 $L23641
  0020e	00 00 00 00	 DD	 $L23642
  00212	00 00 00 00	 DD	 $L23640
  00216	00 00 00 00	 DD	 $L23643
  0021a	00 00 00 00	 DD	 $L23637
$L24034:
  0021e	00		 DB	 0
  0021f	01		 DB	 1
  00220	04		 DB	 4
  00221	04		 DB	 4
  00222	01		 DB	 1
  00223	00		 DB	 0
  00224	02		 DB	 2
  00225	02		 DB	 2
  00226	03		 DB	 3
  00227	03		 DB	 3
$L24036:
  00228	00 00 00 00	 DD	 $L23662
  0022c	00 00 00 00	 DD	 $L23664
  00230	00 00 00 00	 DD	 $L23666
  00234	00 00 00 00	 DD	 $L23669
_DriverProc@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@CHE@Driver?5?$CFlu?5open?$AA@		; `string'
;	COMDAT ??_C@_0BA@CHE@Driver?5?$CFlu?5open?$AA@
CONST	SEGMENT
??_C@_0BA@CHE@Driver?5?$CFlu?5open?$AA@ DB 'Driver %lu open', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?OpenDriver@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVOPENDESCW@@@Z
_TEXT	SEGMENT
_pOpen$ = 12
?OpenDriver@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVOPENDESCW@@@Z PROC NEAR ; CXboxAdpcmDriver::OpenDriver, COMDAT

; 407  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 408  :     HINSTANCE               hInst;
; 409  : 
; 410  :     //
; 411  :     // Refuse to open if we're being called from anyone but ACM
; 412  :     //
; 413  : 
; 414  :     if(pOpen)

  00004	83 7d 0c 00	 cmp	 DWORD PTR _pOpen$[ebp], 0
  00008	74 10		 je	 SHORT $L23677

; 415  :     {
; 416  :         if(ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != pOpen->fccType)

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _pOpen$[ebp]
  0000d	81 78 04 61 75
	64 63		 cmp	 DWORD PTR [eax+4], 1667528033 ; 63647561H
  00014	74 04		 je	 SHORT $L23686

; 417  :         {
; 418  :             return 0;

  00016	33 c0		 xor	 eax, eax
  00018	eb 37		 jmp	 SHORT $L23675
$L23686:
$L23677:

; 419  :         }
; 420  :     }
; 421  : 
; 422  :     //
; 423  :     // Tell ACM that we loaded successfully
; 424  :     //
; 425  : 
; 426  :     if(pOpen)

  0001a	83 7d 0c 00	 cmp	 DWORD PTR _pOpen$[ebp], 0
  0001e	74 0a		 je	 SHORT $L23687

; 427  :     {
; 428  :         pOpen->dwError = MMSYSERR_NOERROR;

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _pOpen$[ebp]
  00023	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
$L23687:

; 429  :     }
; 430  : 
; 431  :     //
; 432  :     // Increment the count of open driver instances
; 433  :     //
; 434  :     
; 435  :     m_dwOpenDriverCount++;

  0002a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwOpenDriverCount@CXboxAdpcmDriver@@2KA ; CXboxAdpcmDriver::m_dwOpenDriverCount
  00030	83 c2 01	 add	 edx, 1
  00033	89 15 00 00 00
	00		 mov	 DWORD PTR ?m_dwOpenDriverCount@CXboxAdpcmDriver@@2KA, edx ; CXboxAdpcmDriver::m_dwOpenDriverCount

; 436  : 
; 437  :     DPF("Driver %lu open", m_dwOpenDriverCount);

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwOpenDriverCount@CXboxAdpcmDriver@@2KA ; CXboxAdpcmDriver::m_dwOpenDriverCount
  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@CHE@Driver?5?$CFlu?5open?$AA@ ; `string'
  00044	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00049	83 c4 08	 add	 esp, 8

; 438  : 
; 439  :     return m_dwOpenDriverCount;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwOpenDriverCount@CXboxAdpcmDriver@@2KA ; CXboxAdpcmDriver::m_dwOpenDriverCount
$L23675:

; 440  : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
?OpenDriver@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVOPENDESCW@@@Z ENDP ; CXboxAdpcmDriver::OpenDriver
_TEXT	ENDS
PUBLIC	??_C@_0BA@ICOM@CloseDriver?5?$CFlu?$AA@		; `string'
PUBLIC	??_C@_0BK@EDKA@Invalid?5driver?5identifier?$AA@	; `string'
;	COMDAT ??_C@_0BA@ICOM@CloseDriver?5?$CFlu?$AA@
CONST	SEGMENT
??_C@_0BA@ICOM@CloseDriver?5?$CFlu?$AA@ DB 'CloseDriver %lu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EDKA@Invalid?5driver?5identifier?$AA@
CONST	SEGMENT
??_C@_0BK@EDKA@Invalid?5driver?5identifier?$AA@ DB 'Invalid driver identi'
	DB	'fier', 00H					; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CloseDriver@CXboxAdpcmDriver@@SGJPAUHDRVR__@@K@Z
_TEXT	SEGMENT
_dwDriverId$ = 12
?CloseDriver@CXboxAdpcmDriver@@SGJPAUHDRVR__@@K@Z PROC NEAR ; CXboxAdpcmDriver::CloseDriver, COMDAT

; 464  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 465  :     DPF("CloseDriver %lu", dwDriverId);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _dwDriverId$[ebp]
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@ICOM@CloseDriver?5?$CFlu?$AA@ ; `string'
  0000c	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00011	83 c4 08	 add	 esp, 8

; 466  : 
; 467  :     if(dwDriverId > m_dwOpenDriverCount)

  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _dwDriverId$[ebp]
  00017	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?m_dwOpenDriverCount@CXboxAdpcmDriver@@2KA ; CXboxAdpcmDriver::m_dwOpenDriverCount
  0001d	76 11		 jbe	 SHORT $L23694

; 468  :     {
; 469  :         DPF("Invalid driver identifier");

  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@EDKA@Invalid?5driver?5identifier?$AA@ ; `string'
  00024	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00029	83 c4 04	 add	 esp, 4

; 470  :         return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	eb 14		 jmp	 SHORT $L23692
$L23694:

; 471  :     }
; 472  : 
; 473  :     m_dwOpenDriverCount--;

  00030	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwOpenDriverCount@CXboxAdpcmDriver@@2KA ; CXboxAdpcmDriver::m_dwOpenDriverCount
  00036	83 ea 01	 sub	 edx, 1
  00039	89 15 00 00 00
	00		 mov	 DWORD PTR ?m_dwOpenDriverCount@CXboxAdpcmDriver@@2KA, edx ; CXboxAdpcmDriver::m_dwOpenDriverCount

; 474  : 
; 475  :     return 1;

  0003f	b8 01 00 00 00	 mov	 eax, 1
$L23692:

; 476  : }

  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
?CloseDriver@CXboxAdpcmDriver@@SGJPAUHDRVR__@@K@Z ENDP	; CXboxAdpcmDriver::CloseDriver
_TEXT	ENDS
PUBLIC	??_C@_0BB@BDBH@GetDriverDetails?$AA@		; `string'
EXTRN	_memcpy:NEAR
EXTRN	_memset:NEAR
EXTRN	__imp__GetDriverModuleHandle@4:NEAR
;	COMDAT ??_C@_0BB@BDBH@GetDriverDetails?$AA@
CONST	SEGMENT
??_C@_0BB@BDBH@GetDriverDetails?$AA@ DB 'GetDriverDetails', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetDriverDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRIVERDETAILSW@@@Z
_TEXT	SEGMENT
_hdrvr$ = 8
_pDetails$ = 12
_hInst$ = -4
_add$ = -1808
?GetDriverDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRIVERDETAILSW@@@Z PROC NEAR ; CXboxAdpcmDriver::GetDriverDetails, COMDAT

; 501  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 07 00
	00		 sub	 esp, 1812		; 00000714H

; 502  :     HINSTANCE               hInst;
; 503  :     ACMDRIVERDETAILS        add;
; 504  : 
; 505  :     DPF("GetDriverDetails");

  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@BDBH@GetDriverDetails?$AA@ ; `string'
  0000e	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00013	83 c4 04	 add	 esp, 4

; 506  : 
; 507  :     hInst = GetDriverModuleHandle(hdrvr);

  00016	8b 45 08	 mov	 eax, DWORD PTR _hdrvr$[ebp]
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDriverModuleHandle@4
  00020	89 45 fc	 mov	 DWORD PTR _hInst$[ebp], eax

; 508  : 
; 509  :     ZeroMemory(&add, sizeof(add));

  00023	68 08 07 00 00	 push	 1800			; 00000708H
  00028	6a 00		 push	 0
  0002a	8d 8d f0 f8 ff
	ff		 lea	 ecx, DWORD PTR _add$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _memset
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 510  :     
; 511  :     add.cbStruct = sizeof(add);

  00039	c7 85 f0 f8 ff
	ff 08 07 00 00	 mov	 DWORD PTR _add$[ebp], 1800 ; 00000708H

; 512  :     add.fccType = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;

  00043	c7 85 f4 f8 ff
	ff 61 75 64 63	 mov	 DWORD PTR _add$[ebp+4], 1667528033 ; 63647561H

; 513  :     add.fccComp = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;

  0004d	c7 85 f8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _add$[ebp+8], 0

; 514  :     add.wMid = MM_MICROSOFT;

  00057	66 c7 85 fc f8
	ff ff 01 00	 mov	 WORD PTR _add$[ebp+12], 1

; 515  :     add.wPid = WAVE_FORMAT_XBOX_ADPCM; // BUGBUG

  00060	66 c7 85 fe f8
	ff ff 69 00	 mov	 WORD PTR _add$[ebp+14], 105 ; 00000069H

; 516  :     add.vdwACM = VERSION_MSACM;

  00069	c7 85 00 f9 ff
	ff 00 00 32 03	 mov	 DWORD PTR _add$[ebp+16], 53608448 ; 03320000H

; 517  :     add.vdwDriver = VERSION_ACM_DRIVER;

  00073	c7 85 04 f9 ff
	ff 00 00 00 04	 mov	 DWORD PTR _add$[ebp+20], 67108864 ; 04000000H

; 518  :     add.fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CODEC;

  0007d	c7 85 08 f9 ff
	ff 01 00 00 00	 mov	 DWORD PTR _add$[ebp+24], 1

; 519  :     add.cFormatTags = XBOX_ADPCM_FORMAT_INDEX_COUNT;

  00087	c7 85 0c f9 ff
	ff 02 00 00 00	 mov	 DWORD PTR _add$[ebp+28], 2

; 520  : 
; 521  :     LoadStringW(hInst, IDS_ACM_DRIVER_SHORTNAME, add.szShortName, NUMELMS(add.szShortName));

  00091	6a 20		 push	 32			; 00000020H
  00093	8d 95 18 f9 ff
	ff		 lea	 edx, DWORD PTR _add$[ebp+40]
  00099	52		 push	 edx
  0009a	6a 01		 push	 1
  0009c	8b 45 fc	 mov	 eax, DWORD PTR _hInst$[ebp]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ?MyLoadStringW@@YGHPAUHINSTANCE__@@IPAGH@Z ; MyLoadStringW

; 522  :     LoadStringW(hInst, IDS_ACM_DRIVER_LONGNAME,  add.szLongName,  NUMELMS(add.szLongName));

  000a5	68 80 00 00 00	 push	 128			; 00000080H
  000aa	8d 8d 58 f9 ff
	ff		 lea	 ecx, DWORD PTR _add$[ebp+104]
  000b0	51		 push	 ecx
  000b1	6a 02		 push	 2
  000b3	8b 55 fc	 mov	 edx, DWORD PTR _hInst$[ebp]
  000b6	52		 push	 edx
  000b7	e8 00 00 00 00	 call	 ?MyLoadStringW@@YGHPAUHINSTANCE__@@IPAGH@Z ; MyLoadStringW

; 523  :     LoadStringW(hInst, IDS_ACM_DRIVER_COPYRIGHT, add.szCopyright, NUMELMS(add.szCopyright));

  000bc	6a 50		 push	 80			; 00000050H
  000be	8d 85 58 fa ff
	ff		 lea	 eax, DWORD PTR _add$[ebp+360]
  000c4	50		 push	 eax
  000c5	6a 03		 push	 3
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _hInst$[ebp]
  000ca	51		 push	 ecx
  000cb	e8 00 00 00 00	 call	 ?MyLoadStringW@@YGHPAUHINSTANCE__@@IPAGH@Z ; MyLoadStringW

; 524  :     LoadStringW(hInst, IDS_ACM_DRIVER_LICENSING, add.szLicensing, NUMELMS(add.szLicensing));

  000d0	68 80 00 00 00	 push	 128			; 00000080H
  000d5	8d 95 f8 fa ff
	ff		 lea	 edx, DWORD PTR _add$[ebp+520]
  000db	52		 push	 edx
  000dc	6a 04		 push	 4
  000de	8b 45 fc	 mov	 eax, DWORD PTR _hInst$[ebp]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 ?MyLoadStringW@@YGHPAUHINSTANCE__@@IPAGH@Z ; MyLoadStringW

; 525  :     LoadStringW(hInst, IDS_ACM_DRIVER_FEATURES,  add.szFeatures,  NUMELMS(add.szFeatures));

  000e7	68 00 02 00 00	 push	 512			; 00000200H
  000ec	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _add$[ebp+776]
  000f2	51		 push	 ecx
  000f3	6a 05		 push	 5
  000f5	8b 55 fc	 mov	 edx, DWORD PTR _hInst$[ebp]
  000f8	52		 push	 edx
  000f9	e8 00 00 00 00	 call	 ?MyLoadStringW@@YGHPAUHINSTANCE__@@IPAGH@Z ; MyLoadStringW

; 526  : 
; 527  :     CopyMemory(pDetails, &add, min(pDetails->cbStruct, add.cbStruct));

  000fe	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  00101	8b 08		 mov	 ecx, DWORD PTR [eax]
  00103	3b 8d f0 f8 ff
	ff		 cmp	 ecx, DWORD PTR _add$[ebp]
  00109	73 0d		 jae	 SHORT $L24046
  0010b	8b 55 0c	 mov	 edx, DWORD PTR _pDetails$[ebp]
  0010e	8b 02		 mov	 eax, DWORD PTR [edx]
  00110	89 85 ec f8 ff
	ff		 mov	 DWORD PTR -1812+[ebp], eax
  00116	eb 0c		 jmp	 SHORT $L24047
$L24046:
  00118	8b 8d f0 f8 ff
	ff		 mov	 ecx, DWORD PTR _add$[ebp]
  0011e	89 8d ec f8 ff
	ff		 mov	 DWORD PTR -1812+[ebp], ecx
$L24047:
  00124	8b 95 ec f8 ff
	ff		 mov	 edx, DWORD PTR -1812+[ebp]
  0012a	52		 push	 edx
  0012b	8d 85 f0 f8 ff
	ff		 lea	 eax, DWORD PTR _add$[ebp]
  00131	50		 push	 eax
  00132	8b 4d 0c	 mov	 ecx, DWORD PTR _pDetails$[ebp]
  00135	51		 push	 ecx
  00136	e8 00 00 00 00	 call	 _memcpy
  0013b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 528  : 
; 529  :     return MMSYSERR_NOERROR;

  0013e	33 c0		 xor	 eax, eax

; 530  : }

  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c2 08 00	 ret	 8
?GetDriverDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRIVERDETAILSW@@@Z ENDP ; CXboxAdpcmDriver::GetDriverDetails
_TEXT	ENDS
PUBLIC	??_C@_0BE@KEJF@GetFormatTagDetails?$AA@		; `string'
PUBLIC	??_C@_0BM@LHIA@Details?5structure?5too?5small?$AA@ ; `string'
PUBLIC	??_C@_0BF@ECFK@Bad?5format?5tag?5index?$AA@	; `string'
PUBLIC	??_C@_0BI@FLAG@Bad?5tag?5details?5request?$AA@	; `string'
PUBLIC	??_C@_0BK@EMFF@Returning?5PCM?5tag?5details?$AA@ ; `string'
PUBLIC	??_C@_0BM@HLF@Returning?5ADPCM?5tag?5details?$AA@ ; `string'
PUBLIC	??_C@_0P@HOGF@Bad?5format?5tag?$AA@		; `string'
;	COMDAT ??_C@_0BE@KEJF@GetFormatTagDetails?$AA@
CONST	SEGMENT
??_C@_0BE@KEJF@GetFormatTagDetails?$AA@ DB 'GetFormatTagDetails', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LHIA@Details?5structure?5too?5small?$AA@
CONST	SEGMENT
??_C@_0BM@LHIA@Details?5structure?5too?5small?$AA@ DB 'Details structure '
	DB	'too small', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ECFK@Bad?5format?5tag?5index?$AA@
CONST	SEGMENT
??_C@_0BF@ECFK@Bad?5format?5tag?5index?$AA@ DB 'Bad format tag index', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FLAG@Bad?5tag?5details?5request?$AA@
CONST	SEGMENT
??_C@_0BI@FLAG@Bad?5tag?5details?5request?$AA@ DB 'Bad tag details reques'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EMFF@Returning?5PCM?5tag?5details?$AA@
CONST	SEGMENT
??_C@_0BK@EMFF@Returning?5PCM?5tag?5details?$AA@ DB 'Returning PCM tag de'
	DB	'tails', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HLF@Returning?5ADPCM?5tag?5details?$AA@
CONST	SEGMENT
??_C@_0BM@HLF@Returning?5ADPCM?5tag?5details?$AA@ DB 'Returning ADPCM tag'
	DB	' details', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HOGF@Bad?5format?5tag?$AA@
CONST	SEGMENT
??_C@_0P@HOGF@Bad?5format?5tag?$AA@ DB 'Bad format tag', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetFormatTagDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMFORMATTAGDETAILSW@@K@Z
_TEXT	SEGMENT
_hdrvr$ = 8
_pDetails$ = 12
_dwFlags$ = 16
_hInst$ = -4
_dwFormatTag$ = -8
?GetFormatTagDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMFORMATTAGDETAILSW@@K@Z PROC NEAR ; CXboxAdpcmDriver::GetFormatTagDetails, COMDAT

; 556  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 557  :     HINSTANCE               hInst;
; 558  :     DWORD                   dwFormatTag;
; 559  :     
; 560  :     DPF("GetFormatTagDetails");

  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@KEJF@GetFormatTagDetails?$AA@ ; `string'
  0000b	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00010	83 c4 04	 add	 esp, 4

; 561  : 
; 562  :     if(pDetails->cbStruct < sizeof(*pDetails))

  00013	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  00016	83 38 78	 cmp	 DWORD PTR [eax], 120	; 00000078H
  00019	73 17		 jae	 SHORT $L23733

; 563  :     {
; 564  :         DPF("Details structure too small");

  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@LHIA@Details?5structure?5too?5small?$AA@ ; `string'
  00020	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00025	83 c4 04	 add	 esp, 4

; 565  :         return ACMERR_NOTPOSSIBLE;

  00028	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0002d	e9 66 01 00 00	 jmp	 $L23729
$L23733:

; 566  :     }
; 567  : 
; 568  :     hInst = GetDriverModuleHandle(hdrvr);

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _hdrvr$[ebp]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDriverModuleHandle@4
  0003c	89 45 fc	 mov	 DWORD PTR _hInst$[ebp], eax

; 569  : 
; 570  :     switch(dwFlags)
; 571  :     {

  0003f	8b 55 10	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00042	89 55 f4	 mov	 DWORD PTR -12+[ebp], edx
  00045	83 7d f4 00	 cmp	 DWORD PTR -12+[ebp], 0
  00049	74 0e		 je	 SHORT $L23739
  0004b	83 7d f4 01	 cmp	 DWORD PTR -12+[ebp], 1
  0004f	74 67		 je	 SHORT $L23751
  00051	83 7d f4 02	 cmp	 DWORD PTR -12+[ebp], 2
  00055	74 44		 je	 SHORT $L23748
  00057	eb 6a		 jmp	 SHORT $L23752
$L23739:

; 572  :         case ACM_FORMATTAGDETAILSF_INDEX:
; 573  :             
; 574  :             switch(pDetails->dwFormatTagIndex)
; 575  :             {

  00059	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	89 4d f0	 mov	 DWORD PTR -16+[ebp], ecx
  00062	83 7d f0 00	 cmp	 DWORD PTR -16+[ebp], 0
  00066	74 08		 je	 SHORT $L23744
  00068	83 7d f0 01	 cmp	 DWORD PTR -16+[ebp], 1
  0006c	74 0b		 je	 SHORT $L23745
  0006e	eb 12		 jmp	 SHORT $L23746
$L23744:

; 576  :                 case XBOX_ADPCM_FORMAT_INDEX_PCM:
; 577  :                     dwFormatTag = WAVE_FORMAT_PCM;

  00070	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _dwFormatTag$[ebp], 1

; 578  :                     break;

  00077	eb 20		 jmp	 SHORT $L23741
$L23745:

; 579  : 
; 580  :                 case XBOX_ADPCM_FORMAT_INDEX_ADPCM:
; 581  :                     dwFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  00079	c7 45 f8 69 00
	00 00		 mov	 DWORD PTR _dwFormatTag$[ebp], 105 ; 00000069H

; 582  :                     break;

  00080	eb 17		 jmp	 SHORT $L23741
$L23746:

; 583  : 
; 584  :                 default:
; 585  :                     DPF("Bad format tag index");

  00082	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@ECFK@Bad?5format?5tag?5index?$AA@ ; `string'
  00087	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0008c	83 c4 04	 add	 esp, 4

; 586  :                     return ACMERR_NOTPOSSIBLE;

  0008f	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00094	e9 ff 00 00 00	 jmp	 $L23729
$L23741:

; 587  :             }
; 588  :             
; 589  :             break;

  00099	eb 3f		 jmp	 SHORT $L23736
$L23748:

; 590  : 
; 591  :         case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
; 592  : 
; 593  :             if(WAVE_FORMAT_UNKNOWN == pDetails->dwFormatTag)

  0009b	8b 55 0c	 mov	 edx, DWORD PTR _pDetails$[ebp]
  0009e	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  000a2	75 09		 jne	 SHORT $L23749

; 594  :             {
; 595  :                 dwFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  000a4	c7 45 f8 69 00
	00 00		 mov	 DWORD PTR _dwFormatTag$[ebp], 105 ; 00000069H

; 596  :             }
; 597  :             else

  000ab	eb 09		 jmp	 SHORT $L23750
$L23749:

; 598  :             {
; 599  :                 dwFormatTag = pDetails->dwFormatTag;

  000ad	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  000b0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b3	89 4d f8	 mov	 DWORD PTR _dwFormatTag$[ebp], ecx
$L23750:

; 600  :             }
; 601  : 
; 602  :             break;

  000b6	eb 22		 jmp	 SHORT $L23736
$L23751:

; 603  : 
; 604  :         case ACM_FORMATTAGDETAILSF_FORMATTAG:
; 605  :             dwFormatTag = pDetails->dwFormatTag;

  000b8	8b 55 0c	 mov	 edx, DWORD PTR _pDetails$[ebp]
  000bb	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000be	89 45 f8	 mov	 DWORD PTR _dwFormatTag$[ebp], eax

; 606  :             break;

  000c1	eb 17		 jmp	 SHORT $L23736
$L23752:

; 607  : 
; 608  :         default:
; 609  :             DPF("Bad tag details request");

  000c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@FLAG@Bad?5tag?5details?5request?$AA@ ; `string'
  000c8	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  000cd	83 c4 04	 add	 esp, 4

; 610  :             return MMSYSERR_NOTSUPPORTED;

  000d0	b8 08 00 00 00	 mov	 eax, 8
  000d5	e9 be 00 00 00	 jmp	 $L23729
$L23736:

; 611  :     }
; 612  : 
; 613  :     switch(dwFormatTag)
; 614  :     {

  000da	8b 4d f8	 mov	 ecx, DWORD PTR _dwFormatTag$[ebp]
  000dd	89 4d ec	 mov	 DWORD PTR -20+[ebp], ecx
  000e0	83 7d ec 01	 cmp	 DWORD PTR -20+[ebp], 1
  000e4	74 08		 je	 SHORT $L23758
  000e6	83 7d ec 69	 cmp	 DWORD PTR -20+[ebp], 105 ; 00000069H
  000ea	74 38		 je	 SHORT $L23761
  000ec	eb 77		 jmp	 SHORT $L23764
$L23758:

; 615  :         case WAVE_FORMAT_PCM:
; 616  :             DPF("Returning PCM tag details");

  000ee	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@EMFF@Returning?5PCM?5tag?5details?$AA@ ; `string'
  000f3	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  000f8	83 c4 04	 add	 esp, 4

; 617  :             
; 618  :             pDetails->dwFormatTagIndex = XBOX_ADPCM_FORMAT_INDEX_PCM;

  000fb	8b 55 0c	 mov	 edx, DWORD PTR _pDetails$[ebp]
  000fe	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 619  :             pDetails->dwFormatTag = WAVE_FORMAT_PCM;

  00105	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  00108	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [eax+8], 1

; 620  :             pDetails->cbFormatSize = sizeof(PCMWAVEFORMAT);

  0010f	8b 4d 0c	 mov	 ecx, DWORD PTR _pDetails$[ebp]
  00112	c7 41 0c 10 00
	00 00		 mov	 DWORD PTR [ecx+12], 16	; 00000010H

; 621  :             
; 622  :             pDetails->szFormatTag[0] = 0;

  00119	8b 55 0c	 mov	 edx, DWORD PTR _pDetails$[ebp]
  0011c	66 c7 42 18 00
	00		 mov	 WORD PTR [edx+24], 0

; 623  : 
; 624  :             break;

  00122	eb 55		 jmp	 SHORT $L23755
$L23761:

; 625  : 
; 626  :         case WAVE_FORMAT_XBOX_ADPCM:
; 627  :             DPF("Returning ADPCM tag details");

  00124	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HLF@Returning?5ADPCM?5tag?5details?$AA@ ; `string'
  00129	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0012e	83 c4 04	 add	 esp, 4

; 628  :             
; 629  :             pDetails->dwFormatTagIndex = XBOX_ADPCM_FORMAT_INDEX_ADPCM;

  00131	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  00134	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 630  :             pDetails->dwFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  0013b	8b 4d 0c	 mov	 ecx, DWORD PTR _pDetails$[ebp]
  0013e	c7 41 08 69 00
	00 00		 mov	 DWORD PTR [ecx+8], 105	; 00000069H

; 631  :             pDetails->cbFormatSize = sizeof(IMAADPCMWAVEFORMAT);

  00145	8b 55 0c	 mov	 edx, DWORD PTR _pDetails$[ebp]
  00148	c7 42 0c 14 00
	00 00		 mov	 DWORD PTR [edx+12], 20	; 00000014H

; 632  : 
; 633  :             LoadStringW(hInst, IDS_ACM_DRIVER_TAG_NAME, pDetails->szFormatTag, NUMELMS(pDetails->szFormatTag));

  0014f	6a 30		 push	 48			; 00000030H
  00151	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  00154	83 c0 18	 add	 eax, 24			; 00000018H
  00157	50		 push	 eax
  00158	6a 06		 push	 6
  0015a	8b 4d fc	 mov	 ecx, DWORD PTR _hInst$[ebp]
  0015d	51		 push	 ecx
  0015e	e8 00 00 00 00	 call	 ?MyLoadStringW@@YGHPAUHINSTANCE__@@IPAGH@Z ; MyLoadStringW

; 634  : 
; 635  :             break;

  00163	eb 14		 jmp	 SHORT $L23755
$L23764:

; 636  : 
; 637  :         default:
; 638  :             DPF("Bad format tag");

  00165	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@HOGF@Bad?5format?5tag?$AA@ ; `string'
  0016a	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0016f	83 c4 04	 add	 esp, 4

; 639  :             return ACMERR_NOTPOSSIBLE;

  00172	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00177	eb 1f		 jmp	 SHORT $L23729
$L23755:

; 640  :     }
; 641  : 
; 642  :     pDetails->cbStruct = sizeof(*pDetails);

  00179	8b 55 0c	 mov	 edx, DWORD PTR _pDetails$[ebp]
  0017c	c7 02 78 00 00
	00		 mov	 DWORD PTR [edx], 120	; 00000078H

; 643  :     pDetails->fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CODEC;

  00182	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  00185	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 644  :     pDetails->cStandardFormats = IMAADPCM_MAX_CHANNELS * NUMELMS(m_adwStdSamplingRates);

  0018c	8b 4d 0c	 mov	 ecx, DWORD PTR _pDetails$[ebp]
  0018f	c7 41 14 0e 00
	00 00		 mov	 DWORD PTR [ecx+20], 14	; 0000000eH

; 645  : 
; 646  :     return MMSYSERR_NOERROR;

  00196	33 c0		 xor	 eax, eax
$L23729:

; 647  : }

  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c2 0c 00	 ret	 12			; 0000000cH
?GetFormatTagDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMFORMATTAGDETAILSW@@K@Z ENDP ; CXboxAdpcmDriver::GetFormatTagDetails
_TEXT	ENDS
PUBLIC	?IsValidPcmFormat@CXboxAdpcmDriver@@SGHPBUtWAVEFORMATEX@@@Z ; CXboxAdpcmDriver::IsValidPcmFormat
PUBLIC	?IsValidAdpcmFormat@CXboxAdpcmDriver@@SGHPBUima_adpcmwaveformat_tag@@@Z ; CXboxAdpcmDriver::IsValidAdpcmFormat
PUBLIC	?CreatePcmFormat@CXboxAdpcmDriver@@SGXGKPAUtWAVEFORMATEX@@@Z ; CXboxAdpcmDriver::CreatePcmFormat
PUBLIC	?CreateAdpcmFormat@CXboxAdpcmDriver@@SGXGKPAUima_adpcmwaveformat_tag@@@Z ; CXboxAdpcmDriver::CreateAdpcmFormat
PUBLIC	??_C@_0BB@LCNF@GetFormatDetails?$AA@		; `string'
PUBLIC	??_C@_0CA@FOJI@Format?5buffer?5too?5small?5for?5PCM?$AA@ ; `string'
PUBLIC	??_C@_0BG@MAHP@Returning?5PCM?5details?$AA@	; `string'
PUBLIC	??_C@_0CC@DKMD@Format?5buffer?5too?5small?5for?5ADPC@ ; `string'
PUBLIC	??_C@_0BI@BOJG@Returning?5ADPCM?5details?$AA@	; `string'
PUBLIC	??_C@_0P@IGBB@Bad?5PCM?5format?$AA@		; `string'
PUBLIC	??_C@_0BB@HFHJ@Bad?5ADPCM?5format?$AA@		; `string'
PUBLIC	??_C@_0BE@FLCN@Bad?5details?5request?$AA@	; `string'
;	COMDAT ??_C@_0BB@LCNF@GetFormatDetails?$AA@
CONST	SEGMENT
??_C@_0BB@LCNF@GetFormatDetails?$AA@ DB 'GetFormatDetails', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FOJI@Format?5buffer?5too?5small?5for?5PCM?$AA@
CONST	SEGMENT
??_C@_0CA@FOJI@Format?5buffer?5too?5small?5for?5PCM?$AA@ DB 'Format buffe'
	DB	'r too small for PCM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MAHP@Returning?5PCM?5details?$AA@
CONST	SEGMENT
??_C@_0BG@MAHP@Returning?5PCM?5details?$AA@ DB 'Returning PCM details', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DKMD@Format?5buffer?5too?5small?5for?5ADPC@
CONST	SEGMENT
??_C@_0CC@DKMD@Format?5buffer?5too?5small?5for?5ADPC@ DB 'Format buffer t'
	DB	'oo small for ADPCM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BOJG@Returning?5ADPCM?5details?$AA@
CONST	SEGMENT
??_C@_0BI@BOJG@Returning?5ADPCM?5details?$AA@ DB 'Returning ADPCM details'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IGBB@Bad?5PCM?5format?$AA@
CONST	SEGMENT
??_C@_0P@IGBB@Bad?5PCM?5format?$AA@ DB 'Bad PCM format', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HFHJ@Bad?5ADPCM?5format?$AA@
CONST	SEGMENT
??_C@_0BB@HFHJ@Bad?5ADPCM?5format?$AA@ DB 'Bad ADPCM format', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FLCN@Bad?5details?5request?$AA@
CONST	SEGMENT
??_C@_0BE@FLCN@Bad?5details?5request?$AA@ DB 'Bad details request', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetFormatDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMFORMATDETAILSW@@K@Z
_TEXT	SEGMENT
_hdrvr$ = 8
_pDetails$ = 12
_dwFlags$ = 16
_hInst$ = -4
_dwSamplingRateIndex$ = -8
_dwSamplingRate$ = -12
_dwChannelCount$ = -16
?GetFormatDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMFORMATDETAILSW@@K@Z PROC NEAR ; CXboxAdpcmDriver::GetFormatDetails, COMDAT

; 673  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 674  :     HINSTANCE               hInst;
; 675  :     DWORD                   dwSamplingRateIndex;
; 676  :     DWORD                   dwSamplingRate;
; 677  :     DWORD                   dwChannelCount;
; 678  :     
; 679  :     DPF("GetFormatDetails");

  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@LCNF@GetFormatDetails?$AA@ ; `string'
  0000b	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00010	83 c4 04	 add	 esp, 4

; 680  : 
; 681  :     if(pDetails->cbStruct < sizeof(*pDetails))

  00013	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  00016	81 38 18 01 00
	00		 cmp	 DWORD PTR [eax], 280	; 00000118H
  0001c	73 17		 jae	 SHORT $L23776

; 682  :     {
; 683  :         DPF("Details structure too small");

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@LHIA@Details?5structure?5too?5small?$AA@ ; `string'
  00023	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00028	83 c4 04	 add	 esp, 4

; 684  :         return ACMERR_NOTPOSSIBLE;

  0002b	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00030	e9 11 02 00 00	 jmp	 $L23770
$L23776:

; 685  :     }
; 686  : 
; 687  :     hInst = GetDriverModuleHandle(hdrvr);

  00035	8b 4d 08	 mov	 ecx, DWORD PTR _hdrvr$[ebp]
  00038	51		 push	 ecx
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDriverModuleHandle@4
  0003f	89 45 fc	 mov	 DWORD PTR _hInst$[ebp], eax

; 688  : 
; 689  :     switch(dwFlags)
; 690  :     {

  00042	8b 55 10	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00045	89 55 ec	 mov	 DWORD PTR -20+[ebp], edx
  00048	83 7d ec 00	 cmp	 DWORD PTR -20+[ebp], 0
  0004c	74 0f		 je	 SHORT $L23781
  0004e	83 7d ec 01	 cmp	 DWORD PTR -20+[ebp], 1
  00052	0f 84 00 01 00
	00		 je	 $L23801
  00058	e9 b7 01 00 00	 jmp	 $L23818
$L23781:

; 691  :         case ACM_FORMATDETAILSF_INDEX:
; 692  :             
; 693  :             //
; 694  :             // Fill in format by index
; 695  :             //
; 696  : 
; 697  :             dwSamplingRateIndex = pDetails->dwFormatIndex / IMAADPCM_MAX_CHANNELS;

  0005d	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  00060	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00063	d1 e9		 shr	 ecx, 1
  00065	89 4d f8	 mov	 DWORD PTR _dwSamplingRateIndex$[ebp], ecx

; 698  : 
; 699  :             if(dwSamplingRateIndex >= NUMELMS(m_adwStdSamplingRates))

  00068	83 7d f8 07	 cmp	 DWORD PTR _dwSamplingRateIndex$[ebp], 7
  0006c	72 0a		 jb	 SHORT $L23782

; 700  :             {
; 701  :                 return ACMERR_NOTPOSSIBLE;

  0006e	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00073	e9 ce 01 00 00	 jmp	 $L23770
$L23782:

; 702  :             }
; 703  : 
; 704  :             dwChannelCount = (pDetails->dwFormatIndex % IMAADPCM_MAX_CHANNELS) + 1;

  00078	8b 55 0c	 mov	 edx, DWORD PTR _pDetails$[ebp]
  0007b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007e	33 d2		 xor	 edx, edx
  00080	b9 02 00 00 00	 mov	 ecx, 2
  00085	f7 f1		 div	 ecx
  00087	83 c2 01	 add	 edx, 1
  0008a	89 55 f0	 mov	 DWORD PTR _dwChannelCount$[ebp], edx

; 705  :             dwSamplingRate = m_adwStdSamplingRates[dwSamplingRateIndex];

  0008d	8b 55 f8	 mov	 edx, DWORD PTR _dwSamplingRateIndex$[ebp]
  00090	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?m_adwStdSamplingRates@CXboxAdpcmDriver@@2QBKB[edx*4]
  00097	89 45 f4	 mov	 DWORD PTR _dwSamplingRate$[ebp], eax

; 706  : 
; 707  :             switch(pDetails->dwFormatTag)
; 708  :             {

  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR _pDetails$[ebp]
  0009d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000a0	89 55 e8	 mov	 DWORD PTR -24+[ebp], edx
  000a3	83 7d e8 01	 cmp	 DWORD PTR -24+[ebp], 1
  000a7	74 0b		 je	 SHORT $L23787
  000a9	83 7d e8 69	 cmp	 DWORD PTR -24+[ebp], 105 ; 00000069H
  000ad	74 49		 je	 SHORT $L23793
  000af	e9 88 00 00 00	 jmp	 $L23800
$L23787:

; 709  :                 case WAVE_FORMAT_PCM:
; 710  :                     
; 711  :                     if(pDetails->cbwfx < sizeof(PCMWAVEFORMAT))

  000b4	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  000b7	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  000bb	73 17		 jae	 SHORT $L23789

; 712  :                     {
; 713  :                         DPF("Format buffer too small for PCM");

  000bd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@FOJI@Format?5buffer?5too?5small?5for?5PCM?$AA@ ; `string'
  000c2	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  000c7	83 c4 04	 add	 esp, 4

; 714  :                         return ACMERR_NOTPOSSIBLE;

  000ca	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  000cf	e9 72 01 00 00	 jmp	 $L23770
$L23789:

; 715  :                     }
; 716  : 
; 717  :                     DPF("Returning PCM details");

  000d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@MAHP@Returning?5PCM?5details?$AA@ ; `string'
  000d9	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  000de	83 c4 04	 add	 esp, 4

; 718  : 
; 719  :                     CreatePcmFormat((WORD)dwChannelCount, dwSamplingRate, pDetails->pwfx);

  000e1	8b 4d 0c	 mov	 ecx, DWORD PTR _pDetails$[ebp]
  000e4	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000e7	52		 push	 edx
  000e8	8b 45 f4	 mov	 eax, DWORD PTR _dwSamplingRate$[ebp]
  000eb	50		 push	 eax
  000ec	66 8b 4d f0	 mov	 cx, WORD PTR _dwChannelCount$[ebp]
  000f0	51		 push	 ecx
  000f1	e8 00 00 00 00	 call	 ?CreatePcmFormat@CXboxAdpcmDriver@@SGXGKPAUtWAVEFORMATEX@@@Z ; CXboxAdpcmDriver::CreatePcmFormat

; 720  : 
; 721  :                     break;

  000f6	eb 5b		 jmp	 SHORT $L23784
$L23793:

; 722  : 
; 723  :                 case WAVE_FORMAT_XBOX_ADPCM:
; 724  : 
; 725  :                     if(pDetails->cbwfx < sizeof(IMAADPCMWAVEFORMAT))

  000f8	8b 55 0c	 mov	 edx, DWORD PTR _pDetails$[ebp]
  000fb	83 7a 14 14	 cmp	 DWORD PTR [edx+20], 20	; 00000014H
  000ff	73 17		 jae	 SHORT $L23795

; 726  :                     {
; 727  :                         DPF("Format buffer too small for ADPCM");

  00101	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@DKMD@Format?5buffer?5too?5small?5for?5ADPC@ ; `string'
  00106	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0010b	83 c4 04	 add	 esp, 4

; 728  :                         return ACMERR_NOTPOSSIBLE;

  0010e	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00113	e9 2e 01 00 00	 jmp	 $L23770
$L23795:

; 729  :                     }
; 730  : 
; 731  :                     DPF("Returning ADPCM details");

  00118	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BOJG@Returning?5ADPCM?5details?$AA@ ; `string'
  0011d	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00122	83 c4 04	 add	 esp, 4

; 732  : 
; 733  :                     CreateAdpcmFormat((WORD)dwChannelCount, dwSamplingRate, (LPIMAADPCMWAVEFORMAT)pDetails->pwfx);

  00125	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  00128	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0012b	51		 push	 ecx
  0012c	8b 55 f4	 mov	 edx, DWORD PTR _dwSamplingRate$[ebp]
  0012f	52		 push	 edx
  00130	66 8b 45 f0	 mov	 ax, WORD PTR _dwChannelCount$[ebp]
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 ?CreateAdpcmFormat@CXboxAdpcmDriver@@SGXGKPAUima_adpcmwaveformat_tag@@@Z ; CXboxAdpcmDriver::CreateAdpcmFormat

; 734  : 
; 735  :                     break;

  0013a	eb 17		 jmp	 SHORT $L23784
$L23800:

; 736  : 
; 737  :                 default:
; 738  :                     DPF("Bad format tag");

  0013c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@HOGF@Bad?5format?5tag?$AA@ ; `string'
  00141	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00146	83 c4 04	 add	 esp, 4

; 739  :                     return ACMERR_NOTPOSSIBLE;

  00149	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0014e	e9 f3 00 00 00	 jmp	 $L23770
$L23784:

; 740  :             }
; 741  : 
; 742  :             break;

  00153	e9 d0 00 00 00	 jmp	 $L23778
$L23801:

; 743  : 
; 744  :         case ACM_FORMATDETAILSF_FORMAT:
; 745  : 
; 746  :             //
; 747  :             // Just validate the format
; 748  :             //
; 749  : 
; 750  :             switch(pDetails->dwFormatTag)
; 751  :             {

  00158	8b 4d 0c	 mov	 ecx, DWORD PTR _pDetails$[ebp]
  0015b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0015e	89 55 e4	 mov	 DWORD PTR -28+[ebp], edx
  00161	83 7d e4 01	 cmp	 DWORD PTR -28+[ebp], 1
  00165	74 0b		 je	 SHORT $L23806
  00167	83 7d e4 69	 cmp	 DWORD PTR -28+[ebp], 105 ; 00000069H
  0016b	74 4e		 je	 SHORT $L23811
  0016d	e9 8c 00 00 00	 jmp	 $L23817
$L23806:

; 752  :                 case WAVE_FORMAT_PCM:
; 753  : 
; 754  :                     if(pDetails->cbwfx < sizeof(PCMWAVEFORMAT))

  00172	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  00175	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00179	73 17		 jae	 SHORT $L23808

; 755  :                     {
; 756  :                         DPF("Format buffer too small for PCM");

  0017b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@FOJI@Format?5buffer?5too?5small?5for?5PCM?$AA@ ; `string'
  00180	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00185	83 c4 04	 add	 esp, 4

; 757  :                         return ACMERR_NOTPOSSIBLE;

  00188	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0018d	e9 b4 00 00 00	 jmp	 $L23770
$L23808:

; 758  :                     }
; 759  : 
; 760  :                     if(!IsValidPcmFormat(pDetails->pwfx))

  00192	8b 4d 0c	 mov	 ecx, DWORD PTR _pDetails$[ebp]
  00195	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00198	52		 push	 edx
  00199	e8 00 00 00 00	 call	 ?IsValidPcmFormat@CXboxAdpcmDriver@@SGHPBUtWAVEFORMATEX@@@Z ; CXboxAdpcmDriver::IsValidPcmFormat
  0019e	85 c0		 test	 eax, eax
  001a0	75 17		 jne	 SHORT $L23809

; 761  :                     {
; 762  :                         DPF("Bad PCM format");

  001a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@IGBB@Bad?5PCM?5format?$AA@ ; `string'
  001a7	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  001ac	83 c4 04	 add	 esp, 4

; 763  :                         return ACMERR_NOTPOSSIBLE;

  001af	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  001b4	e9 8d 00 00 00	 jmp	 $L23770
$L23809:

; 764  :                     }
; 765  : 
; 766  :                     break;

  001b9	eb 57		 jmp	 SHORT $L23803
$L23811:

; 767  : 
; 768  :                 case WAVE_FORMAT_XBOX_ADPCM:
; 769  : 
; 770  :                     if(pDetails->cbwfx < sizeof(IMAADPCMWAVEFORMAT))

  001bb	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  001be	83 78 14 14	 cmp	 DWORD PTR [eax+20], 20	; 00000014H
  001c2	73 14		 jae	 SHORT $L23813

; 771  :                     {
; 772  :                         DPF("Format buffer too small for ADPCM");

  001c4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@DKMD@Format?5buffer?5too?5small?5for?5ADPC@ ; `string'
  001c9	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  001ce	83 c4 04	 add	 esp, 4

; 773  :                         return ACMERR_NOTPOSSIBLE;

  001d1	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  001d6	eb 6e		 jmp	 SHORT $L23770
$L23813:

; 774  :                     }
; 775  : 
; 776  :                     if(!IsValidAdpcmFormat((LPCIMAADPCMWAVEFORMAT)pDetails->pwfx))

  001d8	8b 4d 0c	 mov	 ecx, DWORD PTR _pDetails$[ebp]
  001db	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  001de	52		 push	 edx
  001df	e8 00 00 00 00	 call	 ?IsValidAdpcmFormat@CXboxAdpcmDriver@@SGHPBUima_adpcmwaveformat_tag@@@Z ; CXboxAdpcmDriver::IsValidAdpcmFormat
  001e4	85 c0		 test	 eax, eax
  001e6	75 14		 jne	 SHORT $L23815

; 777  :                     {
; 778  :                         DPF("Bad ADPCM format");

  001e8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@HFHJ@Bad?5ADPCM?5format?$AA@ ; `string'
  001ed	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  001f2	83 c4 04	 add	 esp, 4

; 779  :                         return ACMERR_NOTPOSSIBLE;

  001f5	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  001fa	eb 4a		 jmp	 SHORT $L23770
$L23815:

; 780  :                     }
; 781  : 
; 782  :                     break;

  001fc	eb 14		 jmp	 SHORT $L23803
$L23817:

; 783  : 
; 784  :                 default:
; 785  :                     DPF("Bad format tag");

  001fe	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@HOGF@Bad?5format?5tag?$AA@ ; `string'
  00203	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00208	83 c4 04	 add	 esp, 4

; 786  :                     return ACMERR_NOTPOSSIBLE;

  0020b	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00210	eb 34		 jmp	 SHORT $L23770
$L23803:

; 787  :             }
; 788  : 
; 789  :             break;

  00212	eb 14		 jmp	 SHORT $L23778
$L23818:

; 790  : 
; 791  :         default:
; 792  :             DPF("Bad details request");

  00214	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@FLCN@Bad?5details?5request?$AA@ ; `string'
  00219	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0021e	83 c4 04	 add	 esp, 4

; 793  :             return MMSYSERR_NOTSUPPORTED;

  00221	b8 08 00 00 00	 mov	 eax, 8
  00226	eb 1e		 jmp	 SHORT $L23770
$L23778:

; 794  :     }
; 795  : 
; 796  :     pDetails->cbStruct = sizeof(*pDetails);

  00228	8b 45 0c	 mov	 eax, DWORD PTR _pDetails$[ebp]
  0022b	c7 00 18 01 00
	00		 mov	 DWORD PTR [eax], 280	; 00000118H

; 797  :     pDetails->fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CODEC;

  00231	8b 4d 0c	 mov	 ecx, DWORD PTR _pDetails$[ebp]
  00234	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [ecx+12], 1

; 798  :     pDetails->szFormat[0] = 0;

  0023b	8b 55 0c	 mov	 edx, DWORD PTR _pDetails$[ebp]
  0023e	66 c7 42 18 00
	00		 mov	 WORD PTR [edx+24], 0

; 799  : 
; 800  :     return MMSYSERR_NOERROR;

  00244	33 c0		 xor	 eax, eax
$L23770:

; 801  : }

  00246	8b e5		 mov	 esp, ebp
  00248	5d		 pop	 ebp
  00249	c2 0c 00	 ret	 12			; 0000000cH
?GetFormatDetails@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMFORMATDETAILSW@@K@Z ENDP ; CXboxAdpcmDriver::GetFormatDetails
_TEXT	ENDS
EXTRN	?IsValidPcmFormat@CImaAdpcmCodec@@SGHPBUtWAVEFORMATEX@@@Z:NEAR ; CImaAdpcmCodec::IsValidPcmFormat
; Function compile flags: /Odt
;	COMDAT ?IsValidPcmFormat@CXboxAdpcmDriver@@SGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_pwfx$ = 8
?IsValidPcmFormat@CXboxAdpcmDriver@@SGHPBUtWAVEFORMATEX@@@Z PROC NEAR ; CXboxAdpcmDriver::IsValidPcmFormat, COMDAT

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 83   :     return CImaAdpcmCodec::IsValidPcmFormat(pwfx);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?IsValidPcmFormat@CImaAdpcmCodec@@SGHPBUtWAVEFORMATEX@@@Z ; CImaAdpcmCodec::IsValidPcmFormat

; 84   : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?IsValidPcmFormat@CXboxAdpcmDriver@@SGHPBUtWAVEFORMATEX@@@Z ENDP ; CXboxAdpcmDriver::IsValidPcmFormat
_TEXT	ENDS
EXTRN	?IsValidImaAdpcmFormat@CImaAdpcmCodec@@SGHPBUima_adpcmwaveformat_tag@@@Z:NEAR ; CImaAdpcmCodec::IsValidImaAdpcmFormat
; Function compile flags: /Odt
;	COMDAT ?IsValidAdpcmFormat@CXboxAdpcmDriver@@SGHPBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT
_pwfx$ = 8
?IsValidAdpcmFormat@CXboxAdpcmDriver@@SGHPBUima_adpcmwaveformat_tag@@@Z PROC NEAR ; CXboxAdpcmDriver::IsValidAdpcmFormat, COMDAT

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :     if(!CImaAdpcmCodec::IsValidImaAdpcmFormat(pwfx))

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?IsValidImaAdpcmFormat@CImaAdpcmCodec@@SGHPBUima_adpcmwaveformat_tag@@@Z ; CImaAdpcmCodec::IsValidImaAdpcmFormat
  0000c	85 c0		 test	 eax, eax
  0000e	75 04		 jne	 SHORT $L23594

; 89   :     {
; 90   :         return FALSE;

  00010	33 c0		 xor	 eax, eax
  00012	eb 17		 jmp	 SHORT $L23593
$L23594:

; 91   :     }
; 92   : 
; 93   :     if(XBOX_ADPCM_SAMPLES_PER_BLOCK != pwfx->wSamplesPerBlock)

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00017	33 d2		 xor	 edx, edx
  00019	66 8b 51 12	 mov	 dx, WORD PTR [ecx+18]
  0001d	83 fa 40	 cmp	 edx, 64			; 00000040H
  00020	74 04		 je	 SHORT $L23595

; 94   :     {
; 95   :         return FALSE;

  00022	33 c0		 xor	 eax, eax
  00024	eb 05		 jmp	 SHORT $L23593
$L23595:

; 96   :     }
; 97   : 
; 98   :     return TRUE;

  00026	b8 01 00 00 00	 mov	 eax, 1
$L23593:

; 99   : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?IsValidAdpcmFormat@CXboxAdpcmDriver@@SGHPBUima_adpcmwaveformat_tag@@@Z ENDP ; CXboxAdpcmDriver::IsValidAdpcmFormat
_TEXT	ENDS
EXTRN	?CreatePcmFormat@CImaAdpcmCodec@@SGXGKPAUtWAVEFORMATEX@@@Z:NEAR ; CImaAdpcmCodec::CreatePcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreatePcmFormat@CXboxAdpcmDriver@@SGXGKPAUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_pwfx$ = 16
?CreatePcmFormat@CXboxAdpcmDriver@@SGXGKPAUtWAVEFORMATEX@@@Z PROC NEAR ; CXboxAdpcmDriver::CreatePcmFormat, COMDAT

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 103  :     CImaAdpcmCodec::CreatePcmFormat(nChannels, nSamplesPerSec, pwfx);

  00003	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0000a	51		 push	 ecx
  0000b	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  0000f	52		 push	 edx
  00010	e8 00 00 00 00	 call	 ?CreatePcmFormat@CImaAdpcmCodec@@SGXGKPAUtWAVEFORMATEX@@@Z ; CImaAdpcmCodec::CreatePcmFormat

; 104  : }

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
?CreatePcmFormat@CXboxAdpcmDriver@@SGXGKPAUtWAVEFORMATEX@@@Z ENDP ; CXboxAdpcmDriver::CreatePcmFormat
_TEXT	ENDS
EXTRN	?CreateImaAdpcmFormat@CImaAdpcmCodec@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z:NEAR ; CImaAdpcmCodec::CreateImaAdpcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreateAdpcmFormat@CXboxAdpcmDriver@@SGXGKPAUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_pwfx$ = 16
?CreateAdpcmFormat@CXboxAdpcmDriver@@SGXGKPAUima_adpcmwaveformat_tag@@@Z PROC NEAR ; CXboxAdpcmDriver::CreateAdpcmFormat, COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 108  :     CImaAdpcmCodec::CreateImaAdpcmFormat(nChannels, nSamplesPerSec, XBOX_ADPCM_SAMPLES_PER_BLOCK, pwfx);

  00003	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	50		 push	 eax
  00007	6a 40		 push	 64			; 00000040H
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0000c	51		 push	 ecx
  0000d	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  00011	52		 push	 edx
  00012	e8 00 00 00 00	 call	 ?CreateImaAdpcmFormat@CImaAdpcmCodec@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z ; CImaAdpcmCodec::CreateImaAdpcmFormat

; 109  : }

  00017	5d		 pop	 ebp
  00018	c2 0c 00	 ret	 12			; 0000000cH
?CreateAdpcmFormat@CXboxAdpcmDriver@@SGXGKPAUima_adpcmwaveformat_tag@@@Z ENDP ; CXboxAdpcmDriver::CreateAdpcmFormat
_TEXT	ENDS
PUBLIC	??_C@_0O@JFBC@SuggestFormat?$AA@		; `string'
PUBLIC	??_C@_0CB@HMHO@Destination?5format?5tag?5not?5ADPCM@ ; `string'
PUBLIC	??_C@_0CC@GGPK@Destination?5channel?5count?5not?5?$CFl@ ; `string'
PUBLIC	??_C@_0CC@JBNC@Destination?5sampling?5rate?5not?5?$CFl@ ; `string'
PUBLIC	??_C@_0CD@DHFJ@Destination?5bit?5resolution?5not?5?$CF@ ; `string'
PUBLIC	??_C@_0BI@MGDG@Suggesting?5ADPCM?5format?$AA@	; `string'
PUBLIC	??_C@_0BP@KNCF@Destination?5format?5tag?5not?5PCM?$AA@ ; `string'
PUBLIC	??_C@_0BG@OHLO@Suggesting?5PCM?5format?$AA@	; `string'
;	COMDAT ??_C@_0O@JFBC@SuggestFormat?$AA@
CONST	SEGMENT
??_C@_0O@JFBC@SuggestFormat?$AA@ DB 'SuggestFormat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HMHO@Destination?5format?5tag?5not?5ADPCM@
CONST	SEGMENT
??_C@_0CB@HMHO@Destination?5format?5tag?5not?5ADPCM@ DB 'Destination form'
	DB	'at tag not ADPCM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GGPK@Destination?5channel?5count?5not?5?$CFl@
CONST	SEGMENT
??_C@_0CC@GGPK@Destination?5channel?5count?5not?5?$CFl@ DB 'Destination c'
	DB	'hannel count not %lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JBNC@Destination?5sampling?5rate?5not?5?$CFl@
CONST	SEGMENT
??_C@_0CC@JBNC@Destination?5sampling?5rate?5not?5?$CFl@ DB 'Destination s'
	DB	'ampling rate not %lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DHFJ@Destination?5bit?5resolution?5not?5?$CF@
CONST	SEGMENT
??_C@_0CD@DHFJ@Destination?5bit?5resolution?5not?5?$CF@ DB 'Destination b'
	DB	'it resolution not %lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MGDG@Suggesting?5ADPCM?5format?$AA@
CONST	SEGMENT
??_C@_0BI@MGDG@Suggesting?5ADPCM?5format?$AA@ DB 'Suggesting ADPCM format'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KNCF@Destination?5format?5tag?5not?5PCM?$AA@
CONST	SEGMENT
??_C@_0BP@KNCF@Destination?5format?5tag?5not?5PCM?$AA@ DB 'Destination fo'
	DB	'rmat tag not PCM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OHLO@Suggesting?5PCM?5format?$AA@
CONST	SEGMENT
??_C@_0BG@OHLO@Suggesting?5PCM?5format?$AA@ DB 'Suggesting PCM format', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SuggestFormat@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVFORMATSUGGEST@@@Z
_TEXT	SEGMENT
_pSuggest$ = 12
_wfxAdpcm$ = -20
?SuggestFormat@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVFORMATSUGGEST@@@Z PROC NEAR ; CXboxAdpcmDriver::SuggestFormat, COMDAT

; 825  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 826  :     static const DWORD      dwSupportMask   = ACM_FORMATSUGGESTF_WFORMATTAG | ACM_FORMATSUGGESTF_NCHANNELS | ACM_FORMATSUGGESTF_NSAMPLESPERSEC | ACM_FORMATSUGGESTF_WBITSPERSAMPLE;
; 827  :     IMAADPCMWAVEFORMAT      wfxAdpcm;
; 828  : 
; 829  :     DPF("SuggestFormat");

  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@JFBC@SuggestFormat?$AA@ ; `string'
  0000b	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00010	83 c4 04	 add	 esp, 4

; 830  : 
; 831  :     //
; 832  :     // Make sure we support the requested fields
; 833  :     //
; 834  : 
; 835  :     if(pSuggest->fdwSuggest & ~dwSupportMask)

  00013	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  00016	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00019	81 e1 ff ff f0
	ff		 and	 ecx, -983041		; fff0ffffH
  0001f	85 c9		 test	 ecx, ecx
  00021	74 0a		 je	 SHORT $L23828

; 836  :     {
; 837  :         return MMSYSERR_NOTSUPPORTED;

  00023	b8 08 00 00 00	 mov	 eax, 8
  00028	e9 a0 03 00 00	 jmp	 $L23823
$L23828:

; 838  :     }
; 839  : 
; 840  :     if(WAVE_FORMAT_PCM == pSuggest->pwfxSrc->wFormatTag)

  0002d	8b 55 0c	 mov	 edx, DWORD PTR _pSuggest$[ebp]
  00030	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00033	33 c9		 xor	 ecx, ecx
  00035	66 8b 08	 mov	 cx, WORD PTR [eax]
  00038	83 f9 01	 cmp	 ecx, 1
  0003b	0f 85 cd 01 00
	00		 jne	 $L23829

; 841  :     {
; 842  :         //
; 843  :         // Verify that the format is valid for our purposes
; 844  :         //
; 845  : 
; 846  :         if(pSuggest->cbwfxSrc < sizeof(PCMWAVEFORMAT))

  00041	8b 55 0c	 mov	 edx, DWORD PTR _pSuggest$[ebp]
  00044	83 7a 0c 10	 cmp	 DWORD PTR [edx+12], 16	; 00000010H
  00048	73 17		 jae	 SHORT $L23831

; 847  :         {
; 848  :             DPF("Format buffer too small for PCM");

  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@FOJI@Format?5buffer?5too?5small?5for?5PCM?$AA@ ; `string'
  0004f	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00054	83 c4 04	 add	 esp, 4

; 849  :             return ACMERR_NOTPOSSIBLE;

  00057	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0005c	e9 6c 03 00 00	 jmp	 $L23823
$L23831:

; 850  :         }
; 851  : 
; 852  :         if(pSuggest->cbwfxDst < sizeof(WAVEFORMATEX))

  00061	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  00064	83 78 14 12	 cmp	 DWORD PTR [eax+20], 18	; 00000012H
  00068	73 17		 jae	 SHORT $L23833

; 853  :         {
; 854  :             DPF("Format buffer too small for ADPCM");

  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@DKMD@Format?5buffer?5too?5small?5for?5ADPC@ ; `string'
  0006f	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00074	83 c4 04	 add	 esp, 4

; 855  :             return ACMERR_NOTPOSSIBLE;

  00077	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0007c	e9 4c 03 00 00	 jmp	 $L23823
$L23833:

; 856  :         }
; 857  : 
; 858  :         if(!IsValidPcmFormat(pSuggest->pwfxSrc))

  00081	8b 4d 0c	 mov	 ecx, DWORD PTR _pSuggest$[ebp]
  00084	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00087	52		 push	 edx
  00088	e8 00 00 00 00	 call	 ?IsValidPcmFormat@CXboxAdpcmDriver@@SGHPBUtWAVEFORMATEX@@@Z ; CXboxAdpcmDriver::IsValidPcmFormat
  0008d	85 c0		 test	 eax, eax
  0008f	75 17		 jne	 SHORT $L23834

; 859  :         {
; 860  :             DPF("Bad PCM format");

  00091	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@IGBB@Bad?5PCM?5format?$AA@ ; `string'
  00096	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0009b	83 c4 04	 add	 esp, 4

; 861  :             return ACMERR_NOTPOSSIBLE;

  0009e	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  000a3	e9 25 03 00 00	 jmp	 $L23823
$L23834:

; 862  :         }
; 863  : 
; 864  :         //
; 865  :         // If the destination format tag is specified, make sure it's
; 866  :         // ADPCM.
; 867  :         //
; 868  : 
; 869  :         if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_WFORMATTAG)

  000a8	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	81 e1 00 00 01
	00		 and	 ecx, 65536		; 00010000H
  000b4	85 c9		 test	 ecx, ecx
  000b6	74 27		 je	 SHORT $L23835

; 870  :         {
; 871  :             if(WAVE_FORMAT_XBOX_ADPCM != pSuggest->pwfxDst->wFormatTag)

  000b8	8b 55 0c	 mov	 edx, DWORD PTR _pSuggest$[ebp]
  000bb	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000be	33 c9		 xor	 ecx, ecx
  000c0	66 8b 08	 mov	 cx, WORD PTR [eax]
  000c3	83 f9 69	 cmp	 ecx, 105		; 00000069H
  000c6	74 17		 je	 SHORT $L23836

; 872  :             {
; 873  :                 DPF("Destination format tag not ADPCM");

  000c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@HMHO@Destination?5format?5tag?5not?5ADPCM@ ; `string'
  000cd	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  000d2	83 c4 04	 add	 esp, 4

; 874  :                 return ACMERR_NOTPOSSIBLE;

  000d5	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  000da	e9 ee 02 00 00	 jmp	 $L23823
$L23836:
$L23835:

; 875  :             }
; 876  :         }
; 877  : 
; 878  :         //
; 879  :         // If the destination channel count was specified, make sure
; 880  :         // it's the same as the source.
; 881  :         //
; 882  : 
; 883  :         if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_NCHANNELS)

  000df	8b 55 0c	 mov	 edx, DWORD PTR _pSuggest$[ebp]
  000e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000e5	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  000ea	85 c0		 test	 eax, eax
  000ec	74 40		 je	 SHORT $L23838

; 884  :         {
; 885  :             if(pSuggest->pwfxSrc->nChannels != pSuggest->pwfxDst->nChannels)

  000ee	8b 4d 0c	 mov	 ecx, DWORD PTR _pSuggest$[ebp]
  000f1	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000f4	33 c0		 xor	 eax, eax
  000f6	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  000fa	8b 4d 0c	 mov	 ecx, DWORD PTR _pSuggest$[ebp]
  000fd	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00100	33 c9		 xor	 ecx, ecx
  00102	66 8b 4a 02	 mov	 cx, WORD PTR [edx+2]
  00106	3b c1		 cmp	 eax, ecx
  00108	74 24		 je	 SHORT $L23839

; 886  :             {
; 887  :                 DPF("Destination channel count not %lu", pSuggest->pwfxSrc->nChannels);

  0010a	8b 55 0c	 mov	 edx, DWORD PTR _pSuggest$[ebp]
  0010d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00110	33 c9		 xor	 ecx, ecx
  00112	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00116	51		 push	 ecx
  00117	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@GGPK@Destination?5channel?5count?5not?5?$CFl@ ; `string'
  0011c	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00121	83 c4 08	 add	 esp, 8

; 888  :                 return ACMERR_NOTPOSSIBLE;

  00124	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00129	e9 9f 02 00 00	 jmp	 $L23823
$L23839:
$L23838:

; 889  :             }
; 890  :         }
; 891  : 
; 892  :         //
; 893  :         // If the destination sampling rate was specified, make sure
; 894  :         // it's the same as the source.
; 895  :         //
; 896  : 
; 897  :         if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_NSAMPLESPERSEC)

  0012e	8b 55 0c	 mov	 edx, DWORD PTR _pSuggest$[ebp]
  00131	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00134	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00139	85 c0		 test	 eax, eax
  0013b	74 35		 je	 SHORT $L23841

; 898  :         {
; 899  :             if(pSuggest->pwfxSrc->nSamplesPerSec != pSuggest->pwfxDst->nSamplesPerSec)

  0013d	8b 4d 0c	 mov	 ecx, DWORD PTR _pSuggest$[ebp]
  00140	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00143	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  00146	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00149	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0014c	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0014f	74 21		 je	 SHORT $L23842

; 900  :             {
; 901  :                 DPF("Destination sampling rate not %lu", pSuggest->pwfxSrc->nSamplesPerSec);

  00151	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  00154	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00157	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0015a	52		 push	 edx
  0015b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@JBNC@Destination?5sampling?5rate?5not?5?$CFl@ ; `string'
  00160	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00165	83 c4 08	 add	 esp, 8

; 902  :                 return ACMERR_NOTPOSSIBLE;

  00168	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0016d	e9 5b 02 00 00	 jmp	 $L23823
$L23842:
$L23841:

; 903  :             }
; 904  :         }
; 905  : 
; 906  :         //
; 907  :         // If the destination bit resolution was specified, make sure it's
; 908  :         // correct.
; 909  :         //
; 910  : 
; 911  :         if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_WBITSPERSAMPLE)

  00172	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  00175	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00178	81 e1 00 00 08
	00		 and	 ecx, 524288		; 00080000H
  0017e	85 c9		 test	 ecx, ecx
  00180	74 2a		 je	 SHORT $L23844

; 912  :         {
; 913  :             if(IMAADPCM_BITS_PER_SAMPLE != pSuggest->pwfxDst->wBitsPerSample)

  00182	8b 55 0c	 mov	 edx, DWORD PTR _pSuggest$[ebp]
  00185	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00188	33 c9		 xor	 ecx, ecx
  0018a	66 8b 48 0e	 mov	 cx, WORD PTR [eax+14]
  0018e	83 f9 04	 cmp	 ecx, 4
  00191	74 19		 je	 SHORT $L23845

; 914  :             {
; 915  :                 DPF("Destination bit resolution not %lu", IMAADPCM_BITS_PER_SAMPLE);

  00193	6a 04		 push	 4
  00195	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@DHFJ@Destination?5bit?5resolution?5not?5?$CF@ ; `string'
  0019a	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0019f	83 c4 08	 add	 esp, 8

; 916  :                 return ACMERR_NOTPOSSIBLE;

  001a2	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  001a7	e9 21 02 00 00	 jmp	 $L23823
$L23845:
$L23844:

; 917  :             }
; 918  :         }
; 919  : 
; 920  :         //
; 921  :         // Fill in the format
; 922  :         //
; 923  : 
; 924  :         DPF("Suggesting ADPCM format");

  001ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@MGDG@Suggesting?5ADPCM?5format?$AA@ ; `string'
  001b1	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  001b6	83 c4 04	 add	 esp, 4

; 925  : 
; 926  :         CreateAdpcmFormat(pSuggest->pwfxSrc->nChannels, pSuggest->pwfxSrc->nSamplesPerSec, &wfxAdpcm);

  001b9	8d 55 ec	 lea	 edx, DWORD PTR _wfxAdpcm$[ebp]
  001bc	52		 push	 edx
  001bd	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  001c0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001c3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001c6	52		 push	 edx
  001c7	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  001ca	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001cd	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  001d1	52		 push	 edx
  001d2	e8 00 00 00 00	 call	 ?CreateAdpcmFormat@CXboxAdpcmDriver@@SGXGKPAUima_adpcmwaveformat_tag@@@Z ; CXboxAdpcmDriver::CreateAdpcmFormat

; 927  :         CopyMemory(pSuggest->pwfxDst, &wfxAdpcm, min(pSuggest->cbwfxDst, sizeof(wfxAdpcm)));

  001d7	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  001da	83 78 14 14	 cmp	 DWORD PTR [eax+20], 20	; 00000014H
  001de	73 0b		 jae	 SHORT $L24069
  001e0	8b 4d 0c	 mov	 ecx, DWORD PTR _pSuggest$[ebp]
  001e3	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001e6	89 55 e8	 mov	 DWORD PTR -24+[ebp], edx
  001e9	eb 07		 jmp	 SHORT $L24070
$L24069:
  001eb	c7 45 e8 14 00
	00 00		 mov	 DWORD PTR -24+[ebp], 20	; 00000014H
$L24070:
  001f2	8b 45 e8	 mov	 eax, DWORD PTR -24+[ebp]
  001f5	50		 push	 eax
  001f6	8d 4d ec	 lea	 ecx, DWORD PTR _wfxAdpcm$[ebp]
  001f9	51		 push	 ecx
  001fa	8b 55 0c	 mov	 edx, DWORD PTR _pSuggest$[ebp]
  001fd	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00200	50		 push	 eax
  00201	e8 00 00 00 00	 call	 _memcpy
  00206	83 c4 0c	 add	 esp, 12			; 0000000cH

; 928  : 
; 929  :     }
; 930  :     else if(WAVE_FORMAT_XBOX_ADPCM == pSuggest->pwfxSrc->wFormatTag)

  00209	e9 bd 01 00 00	 jmp	 $L23848
$L23829:
  0020e	8b 4d 0c	 mov	 ecx, DWORD PTR _pSuggest$[ebp]
  00211	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00214	33 c0		 xor	 eax, eax
  00216	66 8b 02	 mov	 ax, WORD PTR [edx]
  00219	83 f8 69	 cmp	 eax, 105		; 00000069H
  0021c	0f 85 95 01 00
	00		 jne	 $L23849

; 931  :     {
; 932  :         if(pSuggest->cbwfxSrc < sizeof(IMAADPCMWAVEFORMAT))

  00222	8b 4d 0c	 mov	 ecx, DWORD PTR _pSuggest$[ebp]
  00225	83 79 0c 14	 cmp	 DWORD PTR [ecx+12], 20	; 00000014H
  00229	73 17		 jae	 SHORT $L23851

; 933  :         {
; 934  :             DPF("Format buffer too small for ADPCM");

  0022b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@DKMD@Format?5buffer?5too?5small?5for?5ADPC@ ; `string'
  00230	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00235	83 c4 04	 add	 esp, 4

; 935  :             return ACMERR_NOTPOSSIBLE;

  00238	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0023d	e9 8b 01 00 00	 jmp	 $L23823
$L23851:

; 936  :         }
; 937  : 
; 938  :         if(pSuggest->cbwfxDst < sizeof(PCMWAVEFORMAT))

  00242	8b 55 0c	 mov	 edx, DWORD PTR _pSuggest$[ebp]
  00245	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00249	73 17		 jae	 SHORT $L23853

; 939  :         {
; 940  :             DPF("Format buffer too small for PCM");

  0024b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@FOJI@Format?5buffer?5too?5small?5for?5PCM?$AA@ ; `string'
  00250	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00255	83 c4 04	 add	 esp, 4

; 941  :             return ACMERR_NOTPOSSIBLE;

  00258	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0025d	e9 6b 01 00 00	 jmp	 $L23823
$L23853:

; 942  :         }
; 943  : 
; 944  :         //
; 945  :         // Verify that the format is valid for our purposes
; 946  :         //
; 947  : 
; 948  :         if(!IsValidAdpcmFormat((LPCIMAADPCMWAVEFORMAT)pSuggest->pwfxSrc))

  00262	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  00265	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00268	51		 push	 ecx
  00269	e8 00 00 00 00	 call	 ?IsValidAdpcmFormat@CXboxAdpcmDriver@@SGHPBUima_adpcmwaveformat_tag@@@Z ; CXboxAdpcmDriver::IsValidAdpcmFormat
  0026e	85 c0		 test	 eax, eax
  00270	75 17		 jne	 SHORT $L23855

; 949  :         {
; 950  :             DPF("Bad ADPCM format");

  00272	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@HFHJ@Bad?5ADPCM?5format?$AA@ ; `string'
  00277	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0027c	83 c4 04	 add	 esp, 4

; 951  :             return ACMERR_NOTPOSSIBLE;

  0027f	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00284	e9 44 01 00 00	 jmp	 $L23823
$L23855:

; 952  :         }
; 953  : 
; 954  :         //
; 955  :         // If the destination format tag is specified, make sure it's
; 956  :         // PCM.
; 957  :         //
; 958  : 
; 959  :         if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_WFORMATTAG)

  00289	8b 55 0c	 mov	 edx, DWORD PTR _pSuggest$[ebp]
  0028c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0028f	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00294	85 c0		 test	 eax, eax
  00296	74 27		 je	 SHORT $L23856

; 960  :         {
; 961  :             if(WAVE_FORMAT_PCM != pSuggest->pwfxDst->wFormatTag)

  00298	8b 4d 0c	 mov	 ecx, DWORD PTR _pSuggest$[ebp]
  0029b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0029e	33 c0		 xor	 eax, eax
  002a0	66 8b 02	 mov	 ax, WORD PTR [edx]
  002a3	83 f8 01	 cmp	 eax, 1
  002a6	74 17		 je	 SHORT $L23857

; 962  :             {
; 963  :                 DPF("Destination format tag not PCM");

  002a8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@KNCF@Destination?5format?5tag?5not?5PCM?$AA@ ; `string'
  002ad	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  002b2	83 c4 04	 add	 esp, 4

; 964  :                 return ACMERR_NOTPOSSIBLE;

  002b5	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  002ba	e9 0e 01 00 00	 jmp	 $L23823
$L23857:
$L23856:

; 965  :             }
; 966  :         }
; 967  : 
; 968  :         //
; 969  :         // If the destination channel count was specified, make sure
; 970  :         // it's the same as the source.
; 971  :         //
; 972  : 
; 973  :         if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_NCHANNELS)

  002bf	8b 4d 0c	 mov	 ecx, DWORD PTR _pSuggest$[ebp]
  002c2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002c5	81 e2 00 00 02
	00		 and	 edx, 131072		; 00020000H
  002cb	85 d2		 test	 edx, edx
  002cd	74 40		 je	 SHORT $L23859

; 974  :         {
; 975  :             if(pSuggest->pwfxSrc->nChannels != pSuggest->pwfxDst->nChannels)

  002cf	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  002d2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002d5	33 d2		 xor	 edx, edx
  002d7	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  002db	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  002de	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  002e1	33 c0		 xor	 eax, eax
  002e3	66 8b 41 02	 mov	 ax, WORD PTR [ecx+2]
  002e7	3b d0		 cmp	 edx, eax
  002e9	74 24		 je	 SHORT $L23860

; 976  :             {
; 977  :                 DPF("Destination channel count not %lu", pSuggest->pwfxSrc->nChannels);

  002eb	8b 4d 0c	 mov	 ecx, DWORD PTR _pSuggest$[ebp]
  002ee	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002f1	33 c0		 xor	 eax, eax
  002f3	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  002f7	50		 push	 eax
  002f8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@GGPK@Destination?5channel?5count?5not?5?$CFl@ ; `string'
  002fd	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00302	83 c4 08	 add	 esp, 8

; 978  :                 return ACMERR_NOTPOSSIBLE;

  00305	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0030a	e9 be 00 00 00	 jmp	 $L23823
$L23860:
$L23859:

; 979  :             }
; 980  :         }
; 981  : 
; 982  :         //
; 983  :         // If the destination sampling rate was specified, make sure
; 984  :         // it's the same as the source.
; 985  :         //
; 986  : 
; 987  :         if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_NSAMPLESPERSEC)

  0030f	8b 4d 0c	 mov	 ecx, DWORD PTR _pSuggest$[ebp]
  00312	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00315	81 e2 00 00 04
	00		 and	 edx, 262144		; 00040000H
  0031b	85 d2		 test	 edx, edx
  0031d	74 32		 je	 SHORT $L23861

; 988  :         {
; 989  :             if(pSuggest->pwfxSrc->nSamplesPerSec != pSuggest->pwfxDst->nSamplesPerSec)

  0031f	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  00322	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00325	8b 55 0c	 mov	 edx, DWORD PTR _pSuggest$[ebp]
  00328	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0032b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0032e	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00331	74 1e		 je	 SHORT $L23862

; 990  :             {
; 991  :                 DPF("Destination sampling rate not %lu", pSuggest->pwfxSrc->nSamplesPerSec);

  00333	8b 55 0c	 mov	 edx, DWORD PTR _pSuggest$[ebp]
  00336	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00339	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0033c	51		 push	 ecx
  0033d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@JBNC@Destination?5sampling?5rate?5not?5?$CFl@ ; `string'
  00342	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00347	83 c4 08	 add	 esp, 8

; 992  :                 return ACMERR_NOTPOSSIBLE;

  0034a	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0034f	eb 7c		 jmp	 SHORT $L23823
$L23862:
$L23861:

; 993  :             }
; 994  :         }
; 995  : 
; 996  :         //
; 997  :         // If the destination bit resolution was specified, make sure it's
; 998  :         // correct.
; 999  :         //
; 1000 : 
; 1001 :         if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_WBITSPERSAMPLE)

  00351	8b 55 0c	 mov	 edx, DWORD PTR _pSuggest$[ebp]
  00354	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00357	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0035c	85 c0		 test	 eax, eax
  0035e	74 27		 je	 SHORT $L23863

; 1002 :         {
; 1003 :             if(IMAADPCM_PCM_BITS_PER_SAMPLE != pSuggest->pwfxDst->wBitsPerSample)

  00360	8b 4d 0c	 mov	 ecx, DWORD PTR _pSuggest$[ebp]
  00363	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00366	33 c0		 xor	 eax, eax
  00368	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  0036c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0036f	74 16		 je	 SHORT $L23864

; 1004 :             {
; 1005 :                 DPF("Destination bit resolution not %lu", IMAADPCM_PCM_BITS_PER_SAMPLE);

  00371	6a 10		 push	 16			; 00000010H
  00373	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@DHFJ@Destination?5bit?5resolution?5not?5?$CF@ ; `string'
  00378	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0037d	83 c4 08	 add	 esp, 8

; 1006 :                 return ACMERR_NOTPOSSIBLE;

  00380	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00385	eb 46		 jmp	 SHORT $L23823
$L23864:
$L23863:

; 1007 :             }
; 1008 :         }
; 1009 : 
; 1010 :         //
; 1011 :         // Fill in the format
; 1012 :         //
; 1013 : 
; 1014 :         DPF("Suggesting PCM format");

  00387	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@OHLO@Suggesting?5PCM?5format?$AA@ ; `string'
  0038c	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00391	83 c4 04	 add	 esp, 4

; 1015 : 
; 1016 :         CreatePcmFormat(pSuggest->pwfxSrc->nChannels, pSuggest->pwfxSrc->nSamplesPerSec, pSuggest->pwfxDst);

  00394	8b 4d 0c	 mov	 ecx, DWORD PTR _pSuggest$[ebp]
  00397	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0039a	52		 push	 edx
  0039b	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  0039e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003a1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003a4	52		 push	 edx
  003a5	8b 45 0c	 mov	 eax, DWORD PTR _pSuggest$[ebp]
  003a8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003ab	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  003af	52		 push	 edx
  003b0	e8 00 00 00 00	 call	 ?CreatePcmFormat@CXboxAdpcmDriver@@SGXGKPAUtWAVEFORMATEX@@@Z ; CXboxAdpcmDriver::CreatePcmFormat

; 1017 :     }
; 1018 :     else

  003b5	eb 14		 jmp	 SHORT $L23866
$L23849:

; 1019 :     {
; 1020 :         // 
; 1021 :         // Bad format
; 1022 :         //
; 1023 : 
; 1024 :         DPF("Bad format tag");

  003b7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@HOGF@Bad?5format?5tag?$AA@ ; `string'
  003bc	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  003c1	83 c4 04	 add	 esp, 4

; 1025 :         return ACMERR_NOTPOSSIBLE;

  003c4	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  003c9	eb 02		 jmp	 SHORT $L23823
$L23866:
$L23848:

; 1026 :     }
; 1027 : 
; 1028 :     return MMSYSERR_NOERROR;

  003cb	33 c0		 xor	 eax, eax
$L23823:

; 1029 : }

  003cd	8b e5		 mov	 esp, ebp
  003cf	5d		 pop	 ebp
  003d0	c2 08 00	 ret	 8
?SuggestFormat@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVFORMATSUGGEST@@@Z ENDP ; CXboxAdpcmDriver::SuggestFormat
_TEXT	ENDS
PUBLIC	??_C@_0L@KJAG@OpenStream?$AA@			; `string'
PUBLIC	??_C@_0BL@DGII@Bad?5destination?5format?5tag?$AA@ ; `string'
PUBLIC	??_C@_0BG@CDBG@Bad?5source?5format?5tag?$AA@	; `string'
PUBLIC	??_C@_0BH@HAIG@Channel?9count?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BH@ICMN@Sampling?9rate?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BL@KDFD@Failed?5to?5initialize?5CODEC?$AA@ ; `string'
PUBLIC	??_GCImaAdpcmCodec@@QAEPAXI@Z			; CImaAdpcmCodec::`scalar deleting destructor'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??0CImaAdpcmCodec@@QAE@XZ:NEAR			; CImaAdpcmCodec::CImaAdpcmCodec
EXTRN	?Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z:NEAR ; CImaAdpcmCodec::Initialize
;	COMDAT ??_C@_0L@KJAG@OpenStream?$AA@
CONST	SEGMENT
??_C@_0L@KJAG@OpenStream?$AA@ DB 'OpenStream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DGII@Bad?5destination?5format?5tag?$AA@
CONST	SEGMENT
??_C@_0BL@DGII@Bad?5destination?5format?5tag?$AA@ DB 'Bad destination for'
	DB	'mat tag', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CDBG@Bad?5source?5format?5tag?$AA@
CONST	SEGMENT
??_C@_0BG@CDBG@Bad?5source?5format?5tag?$AA@ DB 'Bad source format tag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HAIG@Channel?9count?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BH@HAIG@Channel?9count?5mismatch?$AA@ DB 'Channel-count mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ICMN@Sampling?9rate?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BH@ICMN@Sampling?9rate?5mismatch?$AA@ DB 'Sampling-rate mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KDFD@Failed?5to?5initialize?5CODEC?$AA@
CONST	SEGMENT
??_C@_0BL@KDFD@Failed?5to?5initialize?5CODEC?$AA@ DB 'Failed to initializ'
	DB	'e CODEC', 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?OpenStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@@Z
_TEXT	SEGMENT
_pStream$ = 12
_pwfxEncode$ = -12
_pwfxDecode$ = -8
_fEncoder$ = -16
_pCodec$ = -4
$T24074 = -20
$T24077 = -24
$T24078 = -28
?OpenStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@@Z PROC NEAR ; CXboxAdpcmDriver::OpenStream, COMDAT

; 1053 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 1054 :     LPCIMAADPCMWAVEFORMAT   pwfxEncode;
; 1055 :     LPCWAVEFORMATEX         pwfxDecode;
; 1056 :     BOOL                    fEncoder;
; 1057 :     CImaAdpcmCodec *        pCodec;
; 1058 : 
; 1059 :     DPF("OpenStream");

  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@KJAG@OpenStream?$AA@ ; `string'
  0000b	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00010	83 c4 04	 add	 esp, 4

; 1060 : 
; 1061 :     //
; 1062 :     // Save pointers to the conversion formats
; 1063 :     //
; 1064 : 
; 1065 :     if(WAVE_FORMAT_PCM == pStream->pwfxSrc->wFormatTag)

  00013	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  00016	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00019	33 d2		 xor	 edx, edx
  0001b	66 8b 11	 mov	 dx, WORD PTR [ecx]
  0001e	83 fa 01	 cmp	 edx, 1
  00021	75 44		 jne	 SHORT $L23876

; 1066 :     {
; 1067 :         if(WAVE_FORMAT_XBOX_ADPCM == pStream->pwfxDst->wFormatTag)

  00023	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  00026	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00029	33 d2		 xor	 edx, edx
  0002b	66 8b 11	 mov	 dx, WORD PTR [ecx]
  0002e	83 fa 69	 cmp	 edx, 105		; 00000069H
  00031	75 14		 jne	 SHORT $L23877

; 1068 :         {
; 1069 :             pwfxEncode = (LPCIMAADPCMWAVEFORMAT)pStream->pwfxDst;

  00033	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  00036	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00039	89 4d f4	 mov	 DWORD PTR _pwfxEncode$[ebp], ecx

; 1070 :             pwfxDecode = pStream->pwfxSrc;

  0003c	8b 55 0c	 mov	 edx, DWORD PTR _pStream$[ebp]
  0003f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00042	89 45 f8	 mov	 DWORD PTR _pwfxDecode$[ebp], eax

; 1071 :         }
; 1072 :         else

  00045	eb 17		 jmp	 SHORT $L23879
$L23877:

; 1073 :         {
; 1074 :             DPF("Bad destination format tag");

  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@DGII@Bad?5destination?5format?5tag?$AA@ ; `string'
  0004c	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00051	83 c4 04	 add	 esp, 4

; 1075 :             return ACMERR_NOTPOSSIBLE;

  00054	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00059	e9 c1 01 00 00	 jmp	 $L23870
$L23879:

; 1076 :         }
; 1077 : 
; 1078 :         fEncoder = TRUE;

  0005e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _fEncoder$[ebp], 1

; 1079 :     }
; 1080 :     else if(WAVE_FORMAT_XBOX_ADPCM == pStream->pwfxSrc->wFormatTag)

  00065	eb 6b		 jmp	 SHORT $L23881
$L23876:
  00067	8b 4d 0c	 mov	 ecx, DWORD PTR _pStream$[ebp]
  0006a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0006d	33 c0		 xor	 eax, eax
  0006f	66 8b 02	 mov	 ax, WORD PTR [edx]
  00072	83 f8 69	 cmp	 eax, 105		; 00000069H
  00075	75 44		 jne	 SHORT $L23882

; 1081 :     {
; 1082 :         if(WAVE_FORMAT_PCM == pStream->pwfxDst->wFormatTag)

  00077	8b 4d 0c	 mov	 ecx, DWORD PTR _pStream$[ebp]
  0007a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007d	33 c0		 xor	 eax, eax
  0007f	66 8b 02	 mov	 ax, WORD PTR [edx]
  00082	83 f8 01	 cmp	 eax, 1
  00085	75 14		 jne	 SHORT $L23883

; 1083 :         {
; 1084 :             pwfxEncode = (LPCIMAADPCMWAVEFORMAT)pStream->pwfxSrc;

  00087	8b 4d 0c	 mov	 ecx, DWORD PTR _pStream$[ebp]
  0008a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0008d	89 55 f4	 mov	 DWORD PTR _pwfxEncode$[ebp], edx

; 1085 :             pwfxDecode = pStream->pwfxDst;

  00090	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  00093	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00096	89 4d f8	 mov	 DWORD PTR _pwfxDecode$[ebp], ecx

; 1086 :         }
; 1087 :         else

  00099	eb 17		 jmp	 SHORT $L23885
$L23883:

; 1088 :         {
; 1089 :             DPF("Bad destination format tag");

  0009b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@DGII@Bad?5destination?5format?5tag?$AA@ ; `string'
  000a0	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  000a5	83 c4 04	 add	 esp, 4

; 1090 :             return ACMERR_NOTPOSSIBLE;

  000a8	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  000ad	e9 6d 01 00 00	 jmp	 $L23870
$L23885:

; 1091 :         }
; 1092 : 
; 1093 :         fEncoder = FALSE;

  000b2	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _fEncoder$[ebp], 0

; 1094 :     }
; 1095 :     else

  000b9	eb 17		 jmp	 SHORT $L23886
$L23882:

; 1096 :     {
; 1097 :         DPF("Bad source format tag");

  000bb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@CDBG@Bad?5source?5format?5tag?$AA@ ; `string'
  000c0	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  000c5	83 c4 04	 add	 esp, 4

; 1098 :         return ACMERR_NOTPOSSIBLE;

  000c8	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  000cd	e9 4d 01 00 00	 jmp	 $L23870
$L23886:
$L23881:

; 1099 :     }
; 1100 :     
; 1101 :     if(!IsValidAdpcmFormat(pwfxEncode))

  000d2	8b 55 f4	 mov	 edx, DWORD PTR _pwfxEncode$[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ?IsValidAdpcmFormat@CXboxAdpcmDriver@@SGHPBUima_adpcmwaveformat_tag@@@Z ; CXboxAdpcmDriver::IsValidAdpcmFormat
  000db	85 c0		 test	 eax, eax
  000dd	75 17		 jne	 SHORT $L23888

; 1102 :     {
; 1103 :         DPF("Bad ADPCM format");

  000df	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@HFHJ@Bad?5ADPCM?5format?$AA@ ; `string'
  000e4	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  000e9	83 c4 04	 add	 esp, 4

; 1104 :         return ACMERR_NOTPOSSIBLE;

  000ec	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  000f1	e9 29 01 00 00	 jmp	 $L23870
$L23888:

; 1105 :     }
; 1106 : 
; 1107 :     if(!IsValidPcmFormat(pwfxDecode))

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _pwfxDecode$[ebp]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?IsValidPcmFormat@CXboxAdpcmDriver@@SGHPBUtWAVEFORMATEX@@@Z ; CXboxAdpcmDriver::IsValidPcmFormat
  000ff	85 c0		 test	 eax, eax
  00101	75 17		 jne	 SHORT $L23889

; 1108 :     {
; 1109 :         DPF("Bad PCM format");

  00103	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@IGBB@Bad?5PCM?5format?$AA@ ; `string'
  00108	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0010d	83 c4 04	 add	 esp, 4

; 1110 :         return ACMERR_NOTPOSSIBLE;

  00110	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00115	e9 05 01 00 00	 jmp	 $L23870
$L23889:

; 1111 :     }
; 1112 : 
; 1113 :     if(pwfxEncode->wfx.nChannels != pwfxDecode->nChannels)

  0011a	8b 4d f4	 mov	 ecx, DWORD PTR _pwfxEncode$[ebp]
  0011d	33 d2		 xor	 edx, edx
  0011f	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  00123	8b 45 f8	 mov	 eax, DWORD PTR _pwfxDecode$[ebp]
  00126	33 c9		 xor	 ecx, ecx
  00128	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0012c	3b d1		 cmp	 edx, ecx
  0012e	74 17		 je	 SHORT $L23890

; 1114 :     {
; 1115 :         DPF("Channel-count mismatch");

  00130	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@HAIG@Channel?9count?5mismatch?$AA@ ; `string'
  00135	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0013a	83 c4 04	 add	 esp, 4

; 1116 :         return ACMERR_NOTPOSSIBLE;

  0013d	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00142	e9 d8 00 00 00	 jmp	 $L23870
$L23890:

; 1117 :     }
; 1118 : 
; 1119 :     if(pwfxEncode->wfx.nSamplesPerSec != pwfxDecode->nSamplesPerSec)

  00147	8b 55 f4	 mov	 edx, DWORD PTR _pwfxEncode$[ebp]
  0014a	8b 45 f8	 mov	 eax, DWORD PTR _pwfxDecode$[ebp]
  0014d	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00150	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00153	74 17		 je	 SHORT $L23892

; 1120 :     {
; 1121 :         DPF("Sampling-rate mismatch");

  00155	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@ICMN@Sampling?9rate?5mismatch?$AA@ ; `string'
  0015a	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0015f	83 c4 04	 add	 esp, 4

; 1122 :         return ACMERR_NOTPOSSIBLE;

  00162	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00167	e9 b3 00 00 00	 jmp	 $L23870
$L23892:

; 1123 :     }
; 1124 : 
; 1125 :     //
; 1126 :     // Check for an open query as opposed to a full-on open operation
; 1127 :     //
; 1128 : 
; 1129 :     if(pStream->fdwOpen & ACM_STREAMOPENF_QUERY)

  0016c	8b 55 0c	 mov	 edx, DWORD PTR _pStream$[ebp]
  0016f	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 07		 je	 SHORT $L23894

; 1130 :     {
; 1131 :         return MMSYSERR_NOERROR;

  00179	33 c0		 xor	 eax, eax
  0017b	e9 9f 00 00 00	 jmp	 $L23870
$L23894:

; 1132 :     }
; 1133 : 
; 1134 :     //
; 1135 :     // Create the CODEC object
; 1136 :     //
; 1137 : 
; 1138 :     if(!(pCodec = new CImaAdpcmCodec))

  00180	6a 24		 push	 36			; 00000024H
  00182	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00187	83 c4 04	 add	 esp, 4
  0018a	89 45 ec	 mov	 DWORD PTR $T24074[ebp], eax
  0018d	83 7d ec 00	 cmp	 DWORD PTR $T24074[ebp], 0
  00191	74 0d		 je	 SHORT $L24075
  00193	8b 4d ec	 mov	 ecx, DWORD PTR $T24074[ebp]
  00196	e8 00 00 00 00	 call	 ??0CImaAdpcmCodec@@QAE@XZ ; CImaAdpcmCodec::CImaAdpcmCodec
  0019b	89 45 e0	 mov	 DWORD PTR -32+[ebp], eax
  0019e	eb 07		 jmp	 SHORT $L24076
$L24075:
  001a0	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR -32+[ebp], 0
$L24076:
  001a7	8b 4d e0	 mov	 ecx, DWORD PTR -32+[ebp]
  001aa	89 4d fc	 mov	 DWORD PTR _pCodec$[ebp], ecx
  001ad	83 7d fc 00	 cmp	 DWORD PTR _pCodec$[ebp], 0
  001b1	75 07		 jne	 SHORT $L23897

; 1139 :     {
; 1140 :         return MMSYSERR_NOMEM;

  001b3	b8 07 00 00 00	 mov	 eax, 7
  001b8	eb 65		 jmp	 SHORT $L23870
$L23897:

; 1141 :     }
; 1142 : 
; 1143 :     if(!pCodec->Initialize(pwfxEncode, fEncoder))

  001ba	8b 55 f0	 mov	 edx, DWORD PTR _fEncoder$[ebp]
  001bd	52		 push	 edx
  001be	8b 45 f4	 mov	 eax, DWORD PTR _pwfxEncode$[ebp]
  001c1	50		 push	 eax
  001c2	8b 4d fc	 mov	 ecx, DWORD PTR _pCodec$[ebp]
  001c5	e8 00 00 00 00	 call	 ?Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z ; CImaAdpcmCodec::Initialize
  001ca	85 c0		 test	 eax, eax
  001cc	75 3c		 jne	 SHORT $L23898

; 1144 :     {
; 1145 :         DPF("Failed to initialize CODEC");

  001ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@KDFD@Failed?5to?5initialize?5CODEC?$AA@ ; `string'
  001d3	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  001d8	83 c4 04	 add	 esp, 4

; 1146 :         delete pCodec;

  001db	8b 4d fc	 mov	 ecx, DWORD PTR _pCodec$[ebp]
  001de	89 4d e4	 mov	 DWORD PTR $T24078[ebp], ecx
  001e1	8b 55 e4	 mov	 edx, DWORD PTR $T24078[ebp]
  001e4	89 55 e8	 mov	 DWORD PTR $T24077[ebp], edx
  001e7	83 7d e8 00	 cmp	 DWORD PTR $T24077[ebp], 0
  001eb	74 0f		 je	 SHORT $L24079
  001ed	6a 01		 push	 1
  001ef	8b 4d e8	 mov	 ecx, DWORD PTR $T24077[ebp]
  001f2	e8 00 00 00 00	 call	 ??_GCImaAdpcmCodec@@QAEPAXI@Z ; CImaAdpcmCodec::`scalar deleting destructor'
  001f7	89 45 dc	 mov	 DWORD PTR -36+[ebp], eax
  001fa	eb 07		 jmp	 SHORT $L24080
$L24079:
  001fc	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR -36+[ebp], 0
$L24080:

; 1147 :         return ACMERR_NOTPOSSIBLE;

  00203	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00208	eb 15		 jmp	 SHORT $L23870
$L23898:

; 1148 :     }
; 1149 : 
; 1150 :     //
; 1151 :     // Fill in stream instance data
; 1152 :     //
; 1153 : 
; 1154 :     pStream->fdwDriver = 0;

  0020a	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  0020d	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 1155 :     pStream->dwDriver = (DWORD)pCodec;

  00214	8b 4d 0c	 mov	 ecx, DWORD PTR _pStream$[ebp]
  00217	8b 55 fc	 mov	 edx, DWORD PTR _pCodec$[ebp]
  0021a	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 1156 : 
; 1157 :     return MMSYSERR_NOERROR;

  0021d	33 c0		 xor	 eax, eax
$L23870:

; 1158 : }

  0021f	8b e5		 mov	 esp, ebp
  00221	5d		 pop	 ebp
  00222	c2 08 00	 ret	 8
?OpenStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@@Z ENDP ; CXboxAdpcmDriver::OpenStream
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	??1CImaAdpcmCodec@@QAE@XZ:NEAR			; CImaAdpcmCodec::~CImaAdpcmCodec
; Function compile flags: /Odt
;	COMDAT ??_GCImaAdpcmCodec@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCImaAdpcmCodec@@QAEPAXI@Z PROC NEAR			; CImaAdpcmCodec::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CImaAdpcmCodec@@QAE@XZ ; CImaAdpcmCodec::~CImaAdpcmCodec
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L23906
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L23906:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCImaAdpcmCodec@@QAEPAXI@Z ENDP			; CImaAdpcmCodec::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0M@BBEP@CloseStream?$AA@			; `string'
;	COMDAT ??_C@_0M@BBEP@CloseStream?$AA@
CONST	SEGMENT
??_C@_0M@BBEP@CloseStream?$AA@ DB 'CloseStream', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CloseStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@@Z
_TEXT	SEGMENT
_pStream$ = 12
_pCodec$ = -4
$T24087 = -8
$T24088 = -12
?CloseStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@@Z PROC NEAR ; CXboxAdpcmDriver::CloseStream, COMDAT

; 1182 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1183 :     CImaAdpcmCodec *        pCodec  = (CImaAdpcmCodec *)pStream->dwDriver;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  00009	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000c	89 4d fc	 mov	 DWORD PTR _pCodec$[ebp], ecx

; 1184 : 
; 1185 :     DPF("CloseStream");

  0000f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@BBEP@CloseStream?$AA@ ; `string'
  00014	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00019	83 c4 04	 add	 esp, 4

; 1186 : 
; 1187 :     if(pCodec)

  0001c	83 7d fc 00	 cmp	 DWORD PTR _pCodec$[ebp], 0
  00020	74 28		 je	 SHORT $L23914

; 1188 :     {
; 1189 :         delete pCodec;

  00022	8b 55 fc	 mov	 edx, DWORD PTR _pCodec$[ebp]
  00025	89 55 f4	 mov	 DWORD PTR $T24088[ebp], edx
  00028	8b 45 f4	 mov	 eax, DWORD PTR $T24088[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR $T24087[ebp], eax
  0002e	83 7d f8 00	 cmp	 DWORD PTR $T24087[ebp], 0
  00032	74 0f		 je	 SHORT $L24089
  00034	6a 01		 push	 1
  00036	8b 4d f8	 mov	 ecx, DWORD PTR $T24087[ebp]
  00039	e8 00 00 00 00	 call	 ??_GCImaAdpcmCodec@@QAEPAXI@Z ; CImaAdpcmCodec::`scalar deleting destructor'
  0003e	89 45 f0	 mov	 DWORD PTR -16+[ebp], eax
  00041	eb 07		 jmp	 SHORT $L24090
$L24089:
  00043	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], 0
$L24090:
$L23914:

; 1190 :     }
; 1191 : 
; 1192 :     return MMSYSERR_NOERROR;

  0004a	33 c0		 xor	 eax, eax

; 1193 : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
?CloseStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@@Z ENDP ; CXboxAdpcmDriver::CloseStream
_TEXT	ENDS
PUBLIC	??_C@_0O@OBHB@GetStreamSize?$AA@		; `string'
PUBLIC	??_C@_0BB@GDN@No?5CODEC?5pointer?$AA@		; `string'
PUBLIC	??_C@_0BB@LDDA@Bad?5size?5request?$AA@		; `string'
PUBLIC	?GetSourceAlignment@CImaAdpcmCodec@@QAEGXZ	; CImaAdpcmCodec::GetSourceAlignment
PUBLIC	?GetDestinationAlignment@CImaAdpcmCodec@@QAEGXZ	; CImaAdpcmCodec::GetDestinationAlignment
;	COMDAT ??_C@_0O@OBHB@GetStreamSize?$AA@
CONST	SEGMENT
??_C@_0O@OBHB@GetStreamSize?$AA@ DB 'GetStreamSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GDN@No?5CODEC?5pointer?$AA@
CONST	SEGMENT
??_C@_0BB@GDN@No?5CODEC?5pointer?$AA@ DB 'No CODEC pointer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LDDA@Bad?5size?5request?$AA@
CONST	SEGMENT
??_C@_0BB@LDDA@Bad?5size?5request?$AA@ DB 'Bad size request', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetStreamSize@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@PAUtACMDRVSTREAMSIZE@@@Z
_TEXT	SEGMENT
_pStream$ = 12
_pSize$ = 16
_pCodec$ = -4
?GetStreamSize@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@PAUtACMDRVSTREAMSIZE@@@Z PROC NEAR ; CXboxAdpcmDriver::GetStreamSize, COMDAT

; 1219 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 1220 :     CImaAdpcmCodec *        pCodec  = (CImaAdpcmCodec *)pStream->dwDriver;

  00007	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  0000a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000d	89 4d fc	 mov	 DWORD PTR _pCodec$[ebp], ecx

; 1221 : 
; 1222 :     DPF("GetStreamSize");

  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@OBHB@GetStreamSize?$AA@ ; `string'
  00015	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0001a	83 c4 04	 add	 esp, 4

; 1223 : 
; 1224 :     if(!pCodec)

  0001d	83 7d fc 00	 cmp	 DWORD PTR _pCodec$[ebp], 0
  00021	75 17		 jne	 SHORT $L23925

; 1225 :     {
; 1226 :         DPF("No CODEC pointer");

  00023	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@GDN@No?5CODEC?5pointer?$AA@ ; `string'
  00028	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0002d	83 c4 04	 add	 esp, 4

; 1227 :         return ACMERR_NOTPOSSIBLE;

  00030	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00035	e9 97 00 00 00	 jmp	 $L23921
$L23925:

; 1228 :     }
; 1229 : 
; 1230 :     switch(pSize->fdwSize)
; 1231 :     {

  0003a	8b 55 10	 mov	 edx, DWORD PTR _pSize$[ebp]
  0003d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00040	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00043	83 7d f8 00	 cmp	 DWORD PTR -8+[ebp], 0
  00047	74 08		 je	 SHORT $L23931
  00049	83 7d f8 01	 cmp	 DWORD PTR -8+[ebp], 1
  0004d	74 37		 je	 SHORT $L23932
  0004f	eb 6a		 jmp	 SHORT $L23933
$L23931:

; 1232 :         case ACM_STREAMSIZEF_SOURCE:
; 1233 :             
; 1234 :             //
; 1235 :             // How many bytes are needed to hold the converted data?
; 1236 :             //
; 1237 : 
; 1238 :             pSize->cbDstLength = pSize->cbSrcLength / pCodec->GetSourceAlignment() * pCodec->GetDestinationAlignment();

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _pCodec$[ebp]
  00054	e8 00 00 00 00	 call	 ?GetSourceAlignment@CImaAdpcmCodec@@QAEGXZ ; CImaAdpcmCodec::GetSourceAlignment
  00059	66 8b c8	 mov	 cx, ax
  0005c	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00062	8b 55 10	 mov	 edx, DWORD PTR _pSize$[ebp]
  00065	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00068	33 d2		 xor	 edx, edx
  0006a	f7 f1		 div	 ecx
  0006c	8b f0		 mov	 esi, eax
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _pCodec$[ebp]
  00071	e8 00 00 00 00	 call	 ?GetDestinationAlignment@CImaAdpcmCodec@@QAEGXZ ; CImaAdpcmCodec::GetDestinationAlignment
  00076	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0007b	0f af f0	 imul	 esi, eax
  0007e	8b 45 10	 mov	 eax, DWORD PTR _pSize$[ebp]
  00081	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 1239 : 
; 1240 :             break;

  00084	eb 49		 jmp	 SHORT $L23928
$L23932:

; 1241 : 
; 1242 :         case ACM_STREAMSIZEF_DESTINATION:
; 1243 :             
; 1244 :             //
; 1245 :             // How many bytes can be converted into the given buffer?
; 1246 :             //
; 1247 : 
; 1248 :             pSize->cbSrcLength = pSize->cbDstLength / pCodec->GetDestinationAlignment() * pCodec->GetSourceAlignment();

  00086	8b 4d fc	 mov	 ecx, DWORD PTR _pCodec$[ebp]
  00089	e8 00 00 00 00	 call	 ?GetDestinationAlignment@CImaAdpcmCodec@@QAEGXZ ; CImaAdpcmCodec::GetDestinationAlignment
  0008e	66 8b c8	 mov	 cx, ax
  00091	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00097	8b 55 10	 mov	 edx, DWORD PTR _pSize$[ebp]
  0009a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0009d	33 d2		 xor	 edx, edx
  0009f	f7 f1		 div	 ecx
  000a1	8b f0		 mov	 esi, eax
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _pCodec$[ebp]
  000a6	e8 00 00 00 00	 call	 ?GetSourceAlignment@CImaAdpcmCodec@@QAEGXZ ; CImaAdpcmCodec::GetSourceAlignment
  000ab	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000b0	0f af f0	 imul	 esi, eax
  000b3	8b 45 10	 mov	 eax, DWORD PTR _pSize$[ebp]
  000b6	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 1249 : 
; 1250 :             break;

  000b9	eb 14		 jmp	 SHORT $L23928
$L23933:

; 1251 : 
; 1252 :         default:
; 1253 :             DPF("Bad size request");

  000bb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@LDDA@Bad?5size?5request?$AA@ ; `string'
  000c0	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  000c5	83 c4 04	 add	 esp, 4

; 1254 :             return MMSYSERR_NOTSUPPORTED;

  000c8	b8 08 00 00 00	 mov	 eax, 8
  000cd	eb 02		 jmp	 SHORT $L23921
$L23928:

; 1255 :     }
; 1256 : 
; 1257 :     return MMSYSERR_NOERROR;

  000cf	33 c0		 xor	 eax, eax
$L23921:

; 1258 : }

  000d1	5e		 pop	 esi
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c2 0c 00	 ret	 12			; 0000000cH
?GetStreamSize@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@PAUtACMDRVSTREAMSIZE@@@Z ENDP ; CXboxAdpcmDriver::GetStreamSize
_TEXT	ENDS
EXTRN	?GetEncodeAlignment@CImaAdpcmCodec@@QAEGXZ:NEAR	; CImaAdpcmCodec::GetEncodeAlignment
EXTRN	?GetDecodeAlignment@CImaAdpcmCodec@@QAEGXZ:NEAR	; CImaAdpcmCodec::GetDecodeAlignment
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\acm\imaadpcm.h
;	COMDAT ?GetSourceAlignment@CImaAdpcmCodec@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4
?GetSourceAlignment@CImaAdpcmCodec@@QAEGXZ PROC NEAR	; CImaAdpcmCodec::GetSourceAlignment, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 106  :     return m_fEncoder ? GetDecodeAlignment() : GetEncodeAlignment();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00010	74 0e		 je	 SHORT $L24097
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?GetDecodeAlignment@CImaAdpcmCodec@@QAEGXZ ; CImaAdpcmCodec::GetDecodeAlignment
  0001a	66 89 45 fa	 mov	 WORD PTR -6+[ebp], ax
  0001e	eb 0c		 jmp	 SHORT $L24098
$L24097:
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?GetEncodeAlignment@CImaAdpcmCodec@@QAEGXZ ; CImaAdpcmCodec::GetEncodeAlignment
  00028	66 89 45 fa	 mov	 WORD PTR -6+[ebp], ax
$L24098:
  0002c	66 8b 45 fa	 mov	 ax, WORD PTR -6+[ebp]

; 107  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?GetSourceAlignment@CImaAdpcmCodec@@QAEGXZ ENDP		; CImaAdpcmCodec::GetSourceAlignment
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetDestinationAlignment@CImaAdpcmCodec@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4
?GetDestinationAlignment@CImaAdpcmCodec@@QAEGXZ PROC NEAR ; CImaAdpcmCodec::GetDestinationAlignment, COMDAT
; _this$ = ecx

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 111  :     return m_fEncoder ? GetEncodeAlignment() : GetDecodeAlignment();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00010	74 0e		 je	 SHORT $L24102
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?GetEncodeAlignment@CImaAdpcmCodec@@QAEGXZ ; CImaAdpcmCodec::GetEncodeAlignment
  0001a	66 89 45 fa	 mov	 WORD PTR -6+[ebp], ax
  0001e	eb 0c		 jmp	 SHORT $L24103
$L24102:
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?GetDecodeAlignment@CImaAdpcmCodec@@QAEGXZ ; CImaAdpcmCodec::GetDecodeAlignment
  00028	66 89 45 fa	 mov	 WORD PTR -6+[ebp], ax
$L24103:
  0002c	66 8b 45 fa	 mov	 ax, WORD PTR -6+[ebp]

; 112  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?GetDestinationAlignment@CImaAdpcmCodec@@QAEGXZ ENDP	; CImaAdpcmCodec::GetDestinationAlignment
_TEXT	ENDS
PUBLIC	??_C@_0O@NBAE@ConvertStream?$AA@		; `string'
PUBLIC	??_C@_0O@CDGC@CODEC?5failure?$AA@		; `string'
EXTRN	?Convert@CImaAdpcmCodec@@QAEHPBXPAXI@Z:NEAR	; CImaAdpcmCodec::Convert
EXTRN	?Reset@CImaAdpcmCodec@@QAEXXZ:NEAR		; CImaAdpcmCodec::Reset
;	COMDAT ??_C@_0O@NBAE@ConvertStream?$AA@
; File c:\xbox\private\windows\directx\dsound\tools\acm\driver.cpp
CONST	SEGMENT
??_C@_0O@NBAE@ConvertStream?$AA@ DB 'ConvertStream', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CDGC@CODEC?5failure?$AA@
CONST	SEGMENT
??_C@_0O@CDGC@CODEC?5failure?$AA@ DB 'CODEC failure', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ConvertStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@PAUtACMDRVSTREAMHEADER@@@Z
_TEXT	SEGMENT
_pStream$ = 12
_pConvert$ = 16
_pCodec$ = -8
_dwSrcBlocks$ = -4
_dwDstBlocks$ = -12
_dwBlocks$ = -16
?ConvertStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@PAUtACMDRVSTREAMHEADER@@@Z PROC NEAR ; CXboxAdpcmDriver::ConvertStream, COMDAT

; 1284 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1285 :     CImaAdpcmCodec *        pCodec      = (CImaAdpcmCodec *)pStream->dwDriver;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  00009	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000c	89 4d f8	 mov	 DWORD PTR _pCodec$[ebp], ecx

; 1286 :     DWORD                   dwSrcBlocks;
; 1287 :     DWORD                   dwDstBlocks;
; 1288 :     DWORD                   dwBlocks;
; 1289 : 
; 1290 :     DPF("ConvertStream");

  0000f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@NBAE@ConvertStream?$AA@ ; `string'
  00014	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  00019	83 c4 04	 add	 esp, 4

; 1291 : 
; 1292 :     if(!pCodec)

  0001c	83 7d f8 00	 cmp	 DWORD PTR _pCodec$[ebp], 0
  00020	75 17		 jne	 SHORT $L23946

; 1293 :     {
; 1294 :         DPF("No CODEC pointer");

  00022	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@GDN@No?5CODEC?5pointer?$AA@ ; `string'
  00027	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  0002c	83 c4 04	 add	 esp, 4

; 1295 :         return ACMERR_NOTPOSSIBLE;

  0002f	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00034	e9 ec 00 00 00	 jmp	 $L23939
$L23946:

; 1296 :     }
; 1297 : 
; 1298 :     //
; 1299 :     // Reset the CODEC if necessary
; 1300 :     //
; 1301 : 
; 1302 :     if(pConvert->fdwConvert & ACM_STREAMCONVERTF_START)

  00039	8b 55 10	 mov	 edx, DWORD PTR _pConvert$[ebp]
  0003c	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0003f	83 e0 10	 and	 eax, 16			; 00000010H
  00042	85 c0		 test	 eax, eax
  00044	74 08		 je	 SHORT $L23947

; 1303 :     {
; 1304 :         pCodec->Reset();

  00046	8b 4d f8	 mov	 ecx, DWORD PTR _pCodec$[ebp]
  00049	e8 00 00 00 00	 call	 ?Reset@CImaAdpcmCodec@@QAEXXZ ; CImaAdpcmCodec::Reset
$L23947:

; 1305 :     }
; 1306 : 
; 1307 :     //
; 1308 :     // Calculate the number of blocks to convert
; 1309 :     //
; 1310 : 
; 1311 :     dwSrcBlocks = pConvert->cbSrcLength / pCodec->GetSourceAlignment();

  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _pCodec$[ebp]
  00051	e8 00 00 00 00	 call	 ?GetSourceAlignment@CImaAdpcmCodec@@QAEGXZ ; CImaAdpcmCodec::GetSourceAlignment
  00056	66 8b c8	 mov	 cx, ax
  00059	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0005f	8b 55 10	 mov	 edx, DWORD PTR _pConvert$[ebp]
  00062	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00065	33 d2		 xor	 edx, edx
  00067	f7 f1		 div	 ecx
  00069	89 45 fc	 mov	 DWORD PTR _dwSrcBlocks$[ebp], eax

; 1312 :     dwDstBlocks = pConvert->cbDstLength / pCodec->GetDestinationAlignment();

  0006c	8b 4d f8	 mov	 ecx, DWORD PTR _pCodec$[ebp]
  0006f	e8 00 00 00 00	 call	 ?GetDestinationAlignment@CImaAdpcmCodec@@QAEGXZ ; CImaAdpcmCodec::GetDestinationAlignment
  00074	66 8b c8	 mov	 cx, ax
  00077	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0007d	8b 55 10	 mov	 edx, DWORD PTR _pConvert$[ebp]
  00080	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00083	33 d2		 xor	 edx, edx
  00085	f7 f1		 div	 ecx
  00087	89 45 f4	 mov	 DWORD PTR _dwDstBlocks$[ebp], eax

; 1313 : 
; 1314 :     dwBlocks = min(dwSrcBlocks, dwDstBlocks);

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _dwSrcBlocks$[ebp]
  0008d	3b 45 f4	 cmp	 eax, DWORD PTR _dwDstBlocks$[ebp]
  00090	73 08		 jae	 SHORT $L24107
  00092	8b 4d fc	 mov	 ecx, DWORD PTR _dwSrcBlocks$[ebp]
  00095	89 4d ec	 mov	 DWORD PTR -20+[ebp], ecx
  00098	eb 06		 jmp	 SHORT $L24108
$L24107:
  0009a	8b 55 f4	 mov	 edx, DWORD PTR _dwDstBlocks$[ebp]
  0009d	89 55 ec	 mov	 DWORD PTR -20+[ebp], edx
$L24108:
  000a0	8b 45 ec	 mov	 eax, DWORD PTR -20+[ebp]
  000a3	89 45 f0	 mov	 DWORD PTR _dwBlocks$[ebp], eax

; 1315 : 
; 1316 :     //
; 1317 :     // Convert data
; 1318 :     //
; 1319 : 
; 1320 :     if(!pCodec->Convert(pConvert->pbSrc, pConvert->pbDst, dwBlocks))

  000a6	8b 4d f0	 mov	 ecx, DWORD PTR _dwBlocks$[ebp]
  000a9	51		 push	 ecx
  000aa	8b 55 10	 mov	 edx, DWORD PTR _pConvert$[ebp]
  000ad	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000b0	50		 push	 eax
  000b1	8b 4d 10	 mov	 ecx, DWORD PTR _pConvert$[ebp]
  000b4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000b7	52		 push	 edx
  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _pCodec$[ebp]
  000bb	e8 00 00 00 00	 call	 ?Convert@CImaAdpcmCodec@@QAEHPBXPAXI@Z ; CImaAdpcmCodec::Convert
  000c0	85 c0		 test	 eax, eax
  000c2	75 14		 jne	 SHORT $L23948

; 1321 :     {
; 1322 :         DPF("CODEC failure");

  000c4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@CDGC@CODEC?5failure?$AA@ ; `string'
  000c9	e8 00 00 00 00	 call	 ?DbgPrint@@YAXPBDZZ	; DbgPrint
  000ce	83 c4 04	 add	 esp, 4

; 1323 :         return ACMERR_NOTPOSSIBLE;

  000d1	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  000d6	eb 4d		 jmp	 SHORT $L23939
$L23948:

; 1324 :     }
; 1325 : 
; 1326 :     //
; 1327 :     // Return the amount of data converted
; 1328 :     //
; 1329 : 
; 1330 :     pConvert->cbSrcLengthUsed = dwBlocks * pCodec->GetSourceAlignment();

  000d8	8b 4d f8	 mov	 ecx, DWORD PTR _pCodec$[ebp]
  000db	e8 00 00 00 00	 call	 ?GetSourceAlignment@CImaAdpcmCodec@@QAEGXZ ; CImaAdpcmCodec::GetSourceAlignment
  000e0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000e5	8b 4d f0	 mov	 ecx, DWORD PTR _dwBlocks$[ebp]
  000e8	0f af c8	 imul	 ecx, eax
  000eb	8b 55 10	 mov	 edx, DWORD PTR _pConvert$[ebp]
  000ee	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 1331 :     pConvert->cbDstLengthUsed = dwBlocks * pCodec->GetDestinationAlignment();

  000f1	8b 4d f8	 mov	 ecx, DWORD PTR _pCodec$[ebp]
  000f4	e8 00 00 00 00	 call	 ?GetDestinationAlignment@CImaAdpcmCodec@@QAEGXZ ; CImaAdpcmCodec::GetDestinationAlignment
  000f9	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000fe	8b 4d f0	 mov	 ecx, DWORD PTR _dwBlocks$[ebp]
  00101	0f af c8	 imul	 ecx, eax
  00104	8b 55 10	 mov	 edx, DWORD PTR _pConvert$[ebp]
  00107	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 1332 : 
; 1333 :     //
; 1334 :     // If the caller knew the source size wasn't block-aligned, we'll be nice
; 1335 :     // and tell them we used the little bit of crap at the end.
; 1336 :     //
; 1337 : 
; 1338 :     if(!(pConvert->fdwConvert & ACM_STREAMCONVERTF_BLOCKALIGN))

  0010a	8b 45 10	 mov	 eax, DWORD PTR _pConvert$[ebp]
  0010d	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00110	83 e1 04	 and	 ecx, 4
  00113	85 c9		 test	 ecx, ecx
  00115	75 0c		 jne	 SHORT $L23950

; 1339 :     {
; 1340 :         pConvert->cbSrcLengthUsed = pConvert->cbSrcLength;

  00117	8b 55 10	 mov	 edx, DWORD PTR _pConvert$[ebp]
  0011a	8b 45 10	 mov	 eax, DWORD PTR _pConvert$[ebp]
  0011d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00120	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
$L23950:

; 1341 :     }
; 1342 : 
; 1343 :     return MMSYSERR_NOERROR;

  00123	33 c0		 xor	 eax, eax
$L23939:

; 1344 : }

  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c2 0c 00	 ret	 12			; 0000000cH
?ConvertStream@CXboxAdpcmDriver@@SGJPAUHDRVR__@@PAUtACMDRVSTREAMINSTANCE@@PAUtACMDRVSTREAMHEADER@@@Z ENDP ; CXboxAdpcmDriver::ConvertStream
_TEXT	ENDS
END
