; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	c:\xbox\private\windows\directx\dsound\tools\wavbndlr\gui\mru.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DPKL@?$CIunknown?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06NPGC@?$CInone?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MKNO@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@GKFF@?$CBm_dwRefCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GLPL@m_dwRefCount?5?$DM?5?$HO0UL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BGIF@m_dwRefCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KMJF@ADPCM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HMEK@8?9bit?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KCDF@CWaveBankEntry?$CIthis?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EG@ELIP@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDJN@CWaveBank?$CIthis?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BPPI@?$CFlu?4?$CFlu?4?$CFlu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@PLCC@CGuiWaveBankEntry?$CIthis?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EC@COGP@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@HCEK@CGuiWaveBank?$CIthis?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01FNLH@a?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03OOHB@MRU?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07CPEI@?$CG?$CFlu?7?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@EEEI@Recent?5File?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPBDK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCRefCount@DirectSound@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRefCount@DirectSound@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CRefCount@DirectSound@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CRefCount@DirectSound@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataOffset@CRiffChunk@WaveLoader@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSourceAlignment@CXboxAdpcmFilter@@SGKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDestinationAlignment@CXboxAdpcmFilter@@SGKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@CXboxAdpcmFilter@@SGKKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMRU@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMRU@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMRU@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Initialize@CMRU@@UAEXPBDPAUHMENU__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@CMRU@@UAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Save@CMRU@@UAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Apply@CMRU@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddItem@CMRU@@UAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CRefCount@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMRU@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

CONST	SEGMENT
?dwMajor@?1??GetWaveBundlerVersion@@YGXPAD@Z@4KB DD 01H	; `GetWaveBundlerVersion'::`2'::dwMajor
?dwMinor@?1??GetWaveBundlerVersion@@YGXPAD@Z@4KB DD 00H	; `GetWaveBundlerVersion'::`2'::dwMinor
?dwBuild@?1??GetWaveBundlerVersion@@YGXPAD@Z@4KB DD 01130H ; `GetWaveBundlerVersion'::`2'::dwBuild
CONST	ENDS
PUBLIC	??0CMRU@@QAE@XZ					; CMRU::CMRU
PUBLIC	?Initialize@CMRU@@UAEXPBDPAUHMENU__@@I@Z	; CMRU::Initialize
PUBLIC	?Load@CMRU@@UAEXPBD@Z				; CMRU::Load
PUBLIC	?Save@CMRU@@UAEXPBD@Z				; CMRU::Save
PUBLIC	?AddItem@CMRU@@UAEXPBD@Z			; CMRU::AddItem
PUBLIC	?Apply@CMRU@@UAEXXZ				; CMRU::Apply
PUBLIC	??_7CMRU@@6B@					; CMRU::`vftable'
PUBLIC	??_GCMRU@@UAEPAXI@Z				; CMRU::`scalar deleting destructor'
PUBLIC	??_ECMRU@@UAEPAXI@Z				; CMRU::`vector deleting destructor'
;	COMDAT ??_7CMRU@@6B@
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\gui\mru.cpp
CONST	SEGMENT
??_7CMRU@@6B@ DD FLAT:??_ECMRU@@UAEPAXI@Z		; CMRU::`vftable'
	DD	FLAT:?Initialize@CMRU@@UAEXPBDPAUHMENU__@@I@Z
	DD	FLAT:?Load@CMRU@@UAEXPBD@Z
	DD	FLAT:?Save@CMRU@@UAEXPBD@Z
	DD	FLAT:?AddItem@CMRU@@UAEXPBD@Z
	DD	FLAT:?Apply@CMRU@@UAEXXZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CMRU@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8
_i$ = -4
??0CMRU@@QAE@XZ PROC NEAR				; CMRU::CMRU, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMRU@@6B@ ; CMRU::`vftable'

; 40   :     UINT                    i;
; 41   :     
; 42   :     m_hmenu = NULL;

  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	c7 81 18 04 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1048], 0

; 43   : 
; 44   :     for(i = 0; i < NUMELMS(m_aszPaths); i++)

  0001f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00026	eb 09		 jmp	 SHORT $L51309
$L51310:
  00028	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002b	83 c2 01	 add	 edx, 1
  0002e	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L51309:
  00031	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  00035	73 13		 jae	 SHORT $L51311

; 45   :     {
; 46   :         m_aszPaths[i][0] = 0;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003a	69 c0 04 01 00
	00		 imul	 eax, 260		; 00000104H
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c6 44 01 08 00	 mov	 BYTE PTR [ecx+eax+8], 0

; 47   :     }

  00048	eb de		 jmp	 SHORT $L51310
$L51311:

; 48   : }

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
??0CMRU@@QAE@XZ ENDP					; CMRU::CMRU
_TEXT	ENDS
PUBLIC	??1CMRU@@UAE@XZ					; CMRU::~CMRU
; Function compile flags: /Odt
;	COMDAT ??_GCMRU@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCMRU@@UAEPAXI@Z PROC NEAR				; CMRU::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMRU@@UAE@XZ		; CMRU::~CMRU
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L51315
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L51315:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCMRU@@UAEPAXI@Z ENDP				; CMRU::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z:NEAR ; DirectSound::CMemoryManager::TrackingPoolFree
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\memmgr.h
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 244  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  :     DirectSound::CMemoryManager::TrackingMemFree(pvBuffer); 

  00003	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPoolFree

; 246  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\gui\mru.cpp
_TEXT	ENDS
;	COMDAT ??1CMRU@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CMRU@@UAE@XZ PROC NEAR				; CMRU::~CMRU, COMDAT
; _this$ = ecx

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMRU@@6B@ ; CMRU::`vftable'

; 74   :     Save();

  00010	6a 00		 push	 0
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?Save@CMRU@@UAEXPBD@Z	; CMRU::Save

; 75   : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??1CMRU@@UAE@XZ ENDP					; CMRU::~CMRU
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Initialize@CMRU@@UAEXPBDPAUHMENU__@@I@Z
_TEXT	SEGMENT
_pszParentKey$ = 8
_hmenu$ = 12
_nCommandId$ = 16
_this$ = -4
?Initialize@CMRU@@UAEXPBDPAUHMENU__@@I@Z PROC NEAR	; CMRU::Initialize, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 106  :     m_hmenu = hmenu;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _hmenu$[ebp]
  0000d	89 88 18 04 00
	00		 mov	 DWORD PTR [eax+1048], ecx

; 107  :     m_nCommandId = nCommandId;

  00013	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00016	8b 45 10	 mov	 eax, DWORD PTR _nCommandId$[ebp]
  00019	89 82 1c 04 00
	00		 mov	 DWORD PTR [edx+1052], eax

; 108  : 
; 109  :     Load(pszParentKey);

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _pszParentKey$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	ff 50 08	 call	 DWORD PTR [eax+8]

; 110  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
?Initialize@CMRU@@UAEXPBDPAUHMENU__@@I@Z ENDP		; CMRU::Initialize
_TEXT	ENDS
PUBLIC	??_C@_01FNLH@a?$AA@				; `string'
PUBLIC	??_C@_03OOHB@MRU?$AA@				; `string'
EXTRN	__imp__RegQueryValueExA@24:NEAR
EXTRN	__imp__RegCloseKey@4:NEAR
EXTRN	__imp__RegCreateKeyA@12:NEAR
;	COMDAT ??_C@_01FNLH@a?$AA@
CONST	SEGMENT
??_C@_01FNLH@a?$AA@ DB 'a', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03OOHB@MRU?$AA@
CONST	SEGMENT
??_C@_03OOHB@MRU?$AA@ DB 'MRU', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Load@CMRU@@UAEXPBD@Z
_TEXT	SEGMENT
_pszParentKey$ = 8
_this$ = -28
_szValue$ = -2
_hkeyParent$ = -16
_hkey$ = -24
_dwSize$ = -12
_lResult$ = -20
_i$ = -8
?Load@CMRU@@UAEXPBD@Z PROC NEAR				; CMRU::Load, COMDAT
; _this$ = ecx

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 137  :     CHAR                    szValue[]   = "a";

  00009	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01FNLH@a?$AA@ ; `string'
  0000f	66 89 45 fe	 mov	 WORD PTR _szValue$[ebp], ax

; 138  :     HKEY                    hkeyParent  = NULL;

  00013	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hkeyParent$[ebp], 0

; 139  :     HKEY                    hkey        = NULL;

  0001a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hkey$[ebp], 0

; 140  :     DWORD                   dwSize;
; 141  :     LONG                    lResult;
; 142  :     UINT                    i;
; 143  : 
; 144  :     if(pszParentKey)

  00021	83 7d 08 00	 cmp	 DWORD PTR _pszParentKey$[ebp], 0
  00025	74 0b		 je	 SHORT $L51337

; 145  :     {
; 146  :         m_pszParentKey = pszParentKey;

  00027	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 55 08	 mov	 edx, DWORD PTR _pszParentKey$[ebp]
  0002d	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 147  :     }
; 148  :     else

  00030	eb 09		 jmp	 SHORT $L51338
$L51337:

; 149  :     {
; 150  :         pszParentKey = m_pszParentKey;

  00032	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	89 4d 08	 mov	 DWORD PTR _pszParentKey$[ebp], ecx
$L51338:

; 151  :     }
; 152  : 
; 153  :     for(i = 0; i < NUMELMS(m_aszPaths); i++)

  0003b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00042	eb 09		 jmp	 SHORT $L51339
$L51340:
  00044	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00047	83 c2 01	 add	 edx, 1
  0004a	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L51339:
  0004d	83 7d f8 04	 cmp	 DWORD PTR _i$[ebp], 4
  00051	73 13		 jae	 SHORT $L51341

; 154  :     {
; 155  :         m_aszPaths[i][0] = 0;

  00053	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00056	69 c0 04 01 00
	00		 imul	 eax, 260		; 00000104H
  0005c	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	c6 44 01 08 00	 mov	 BYTE PTR [ecx+eax+8], 0

; 156  :     }

  00064	eb de		 jmp	 SHORT $L51340
$L51341:

; 157  :     
; 158  :     if(pszParentKey)

  00066	83 7d 08 00	 cmp	 DWORD PTR _pszParentKey$[ebp], 0
  0006a	0f 84 8c 00 00
	00		 je	 $L51342

; 159  :     {
; 160  :         lResult = RegCreateKey(HKEY_CURRENT_USER, pszParentKey, &hkeyParent);

  00070	8d 55 f0	 lea	 edx, DWORD PTR _hkeyParent$[ebp]
  00073	52		 push	 edx
  00074	8b 45 08	 mov	 eax, DWORD PTR _pszParentKey$[ebp]
  00077	50		 push	 eax
  00078	68 01 00 00 80	 push	 -2147483647		; 80000001H
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyA@12
  00083	89 45 ec	 mov	 DWORD PTR _lResult$[ebp], eax

; 161  : 
; 162  :         if(ERROR_SUCCESS == lResult)

  00086	83 7d ec 00	 cmp	 DWORD PTR _lResult$[ebp], 0
  0008a	75 16		 jne	 SHORT $L51346

; 163  :         {
; 164  :             lResult = RegCreateKey(hkeyParent, MRU_KEY, &hkey);

  0008c	8d 4d e8	 lea	 ecx, DWORD PTR _hkey$[ebp]
  0008f	51		 push	 ecx
  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03OOHB@MRU?$AA@ ; `string'
  00095	8b 55 f0	 mov	 edx, DWORD PTR _hkeyParent$[ebp]
  00098	52		 push	 edx
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyA@12
  0009f	89 45 ec	 mov	 DWORD PTR _lResult$[ebp], eax
$L51346:

; 165  :         }
; 166  : 
; 167  :         for(i = 0; (ERROR_SUCCESS == lResult) && (i < NUMELMS(m_aszPaths)); i++)

  000a2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000a9	eb 09		 jmp	 SHORT $L51348
$L51349:
  000ab	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ae	83 c0 01	 add	 eax, 1
  000b1	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L51348:
  000b4	83 7d ec 00	 cmp	 DWORD PTR _lResult$[ebp], 0
  000b8	75 42		 jne	 SHORT $L51350
  000ba	83 7d f8 04	 cmp	 DWORD PTR _i$[ebp], 4
  000be	73 3c		 jae	 SHORT $L51350

; 168  :         {
; 169  :             dwSize = sizeof(m_aszPaths[i]);

  000c0	c7 45 f4 04 01
	00 00		 mov	 DWORD PTR _dwSize$[ebp], 260 ; 00000104H

; 170  :             lResult = RegQueryValueEx(hkey, szValue, NULL, NULL, (LPBYTE)m_aszPaths[i], &dwSize);

  000c7	8d 4d f4	 lea	 ecx, DWORD PTR _dwSize$[ebp]
  000ca	51		 push	 ecx
  000cb	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000ce	69 d2 04 01 00
	00		 imul	 edx, 260		; 00000104H
  000d4	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  000db	51		 push	 ecx
  000dc	6a 00		 push	 0
  000de	6a 00		 push	 0
  000e0	8d 55 fe	 lea	 edx, DWORD PTR _szValue$[ebp]
  000e3	52		 push	 edx
  000e4	8b 45 e8	 mov	 eax, DWORD PTR _hkey$[ebp]
  000e7	50		 push	 eax
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  000ee	89 45 ec	 mov	 DWORD PTR _lResult$[ebp], eax

; 171  : 
; 172  :             szValue[0]++;

  000f1	8a 4d fe	 mov	 cl, BYTE PTR _szValue$[ebp]
  000f4	80 c1 01	 add	 cl, 1
  000f7	88 4d fe	 mov	 BYTE PTR _szValue$[ebp], cl

; 173  :         }

  000fa	eb af		 jmp	 SHORT $L51349
$L51350:
$L51342:

; 174  :     }
; 175  : 
; 176  :     Apply();

  000fc	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  000ff	8b 02		 mov	 eax, DWORD PTR [edx]
  00101	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	ff 50 14	 call	 DWORD PTR [eax+20]

; 177  : 
; 178  :     if(hkey)

  00107	83 7d e8 00	 cmp	 DWORD PTR _hkey$[ebp], 0
  0010b	74 0a		 je	 SHORT $L51352

; 179  :     {
; 180  :         RegCloseKey(hkey);

  0010d	8b 4d e8	 mov	 ecx, DWORD PTR _hkey$[ebp]
  00110	51		 push	 ecx
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$L51352:

; 181  :     }
; 182  : 
; 183  :     if(hkeyParent)

  00117	83 7d f0 00	 cmp	 DWORD PTR _hkeyParent$[ebp], 0
  0011b	74 0a		 je	 SHORT $L51353

; 184  :     {
; 185  :         RegCloseKey(hkeyParent);

  0011d	8b 55 f0	 mov	 edx, DWORD PTR _hkeyParent$[ebp]
  00120	52		 push	 edx
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$L51353:

; 186  :     }
; 187  : }

  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c2 04 00	 ret	 4
?Load@CMRU@@UAEXPBD@Z ENDP				; CMRU::Load
_TEXT	ENDS
EXTRN	__imp__RegSetValueExA@24:NEAR
EXTRN	_strlen:NEAR
; Function compile flags: /Odt
;	COMDAT ?Save@CMRU@@UAEXPBD@Z
_TEXT	SEGMENT
_pszParentKey$ = 8
_this$ = -28
_szValue$ = -2
_hkeyParent$ = -16
_hkey$ = -24
_lResult$ = -20
_i$ = -8
?Save@CMRU@@UAEXPBD@Z PROC NEAR				; CMRU::Save, COMDAT
; _this$ = ecx

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 214  :     CHAR                    szValue[]   = "a";

  00009	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01FNLH@a?$AA@ ; `string'
  0000f	66 89 45 fe	 mov	 WORD PTR _szValue$[ebp], ax

; 215  :     HKEY                    hkeyParent  = NULL;

  00013	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hkeyParent$[ebp], 0

; 216  :     HKEY                    hkey        = NULL;

  0001a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hkey$[ebp], 0

; 217  :     DWORD                   dwSize;
; 218  :     LONG                    lResult;
; 219  :     UINT                    i;
; 220  : 
; 221  :     if(!pszParentKey)

  00021	83 7d 08 00	 cmp	 DWORD PTR _pszParentKey$[ebp], 0
  00025	75 09		 jne	 SHORT $L51364

; 222  :     {
; 223  :         pszParentKey = m_pszParentKey;

  00027	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	89 55 08	 mov	 DWORD PTR _pszParentKey$[ebp], edx
$L51364:

; 224  :     }
; 225  : 
; 226  :     if(pszParentKey)

  00030	83 7d 08 00	 cmp	 DWORD PTR _pszParentKey$[ebp], 0
  00034	0f 84 b5 00 00
	00		 je	 $L51365

; 227  :     {
; 228  :         lResult = RegCreateKey(HKEY_CURRENT_USER, pszParentKey, &hkeyParent);

  0003a	8d 45 f0	 lea	 eax, DWORD PTR _hkeyParent$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _pszParentKey$[ebp]
  00041	51		 push	 ecx
  00042	68 01 00 00 80	 push	 -2147483647		; 80000001H
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyA@12
  0004d	89 45 ec	 mov	 DWORD PTR _lResult$[ebp], eax

; 229  : 
; 230  :         if(ERROR_SUCCESS == lResult)

  00050	83 7d ec 00	 cmp	 DWORD PTR _lResult$[ebp], 0
  00054	75 16		 jne	 SHORT $L51369

; 231  :         {
; 232  :             lResult = RegCreateKey(hkeyParent, MRU_KEY, &hkey);

  00056	8d 55 e8	 lea	 edx, DWORD PTR _hkey$[ebp]
  00059	52		 push	 edx
  0005a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03OOHB@MRU?$AA@ ; `string'
  0005f	8b 45 f0	 mov	 eax, DWORD PTR _hkeyParent$[ebp]
  00062	50		 push	 eax
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyA@12
  00069	89 45 ec	 mov	 DWORD PTR _lResult$[ebp], eax
$L51369:

; 233  :         }
; 234  : 
; 235  :         for(i = 0; (ERROR_SUCCESS == lResult) && (i < NUMELMS(m_aszPaths)); i++)

  0006c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00073	eb 09		 jmp	 SHORT $L51370
$L51371:
  00075	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00078	83 c1 01	 add	 ecx, 1
  0007b	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$L51370:
  0007e	83 7d ec 00	 cmp	 DWORD PTR _lResult$[ebp], 0
  00082	75 6b		 jne	 SHORT $L51372
  00084	83 7d f8 04	 cmp	 DWORD PTR _i$[ebp], 4
  00088	73 65		 jae	 SHORT $L51372

; 236  :         {
; 237  :             if(!m_aszPaths[i][0])

  0008a	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0008d	69 d2 04 01 00
	00		 imul	 edx, 260		; 00000104H
  00093	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00096	0f be 4c 10 08	 movsx	 ecx, BYTE PTR [eax+edx+8]
  0009b	85 c9		 test	 ecx, ecx
  0009d	75 02		 jne	 SHORT $L51373

; 238  :             {
; 239  :                 break;

  0009f	eb 4e		 jmp	 SHORT $L51372
$L51373:

; 240  :             }
; 241  : 
; 242  :             lResult = RegSetValueEx(hkey, szValue, 0, REG_SZ, (LPBYTE)m_aszPaths[i], strlen(m_aszPaths[i]) + 1);

  000a1	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000a4	69 d2 04 01 00
	00		 imul	 edx, 260		; 00000104H
  000aa	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  000b1	51		 push	 ecx
  000b2	e8 00 00 00 00	 call	 _strlen
  000b7	83 c4 04	 add	 esp, 4
  000ba	83 c0 01	 add	 eax, 1
  000bd	50		 push	 eax
  000be	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000c1	69 d2 04 01 00
	00		 imul	 edx, 260		; 00000104H
  000c7	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  000ce	51		 push	 ecx
  000cf	6a 01		 push	 1
  000d1	6a 00		 push	 0
  000d3	8d 55 fe	 lea	 edx, DWORD PTR _szValue$[ebp]
  000d6	52		 push	 edx
  000d7	8b 45 e8	 mov	 eax, DWORD PTR _hkey$[ebp]
  000da	50		 push	 eax
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  000e1	89 45 ec	 mov	 DWORD PTR _lResult$[ebp], eax

; 243  : 
; 244  :             szValue[0]++;

  000e4	8a 4d fe	 mov	 cl, BYTE PTR _szValue$[ebp]
  000e7	80 c1 01	 add	 cl, 1
  000ea	88 4d fe	 mov	 BYTE PTR _szValue$[ebp], cl

; 245  :         }

  000ed	eb 86		 jmp	 SHORT $L51371
$L51372:
$L51365:

; 246  :     }
; 247  : 
; 248  :     if(hkey)

  000ef	83 7d e8 00	 cmp	 DWORD PTR _hkey$[ebp], 0
  000f3	74 0a		 je	 SHORT $L51375

; 249  :     {
; 250  :         RegCloseKey(hkey);

  000f5	8b 55 e8	 mov	 edx, DWORD PTR _hkey$[ebp]
  000f8	52		 push	 edx
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$L51375:

; 251  :     }
; 252  : 
; 253  :     if(hkeyParent)

  000ff	83 7d f0 00	 cmp	 DWORD PTR _hkeyParent$[ebp], 0
  00103	74 0a		 je	 SHORT $L51376

; 254  :     {
; 255  :         RegCloseKey(hkeyParent);

  00105	8b 45 f0	 mov	 eax, DWORD PTR _hkeyParent$[ebp]
  00108	50		 push	 eax
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$L51376:

; 256  :     }
; 257  : }

  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c2 04 00	 ret	 4
?Save@CMRU@@UAEXPBD@Z ENDP				; CMRU::Save
_TEXT	ENDS
PUBLIC	??_C@_07CPEI@?$CG?$CFlu?7?$CFs?$AA@		; `string'
PUBLIC	??_C@_0M@EEEI@Recent?5File?$AA@			; `string'
EXTRN	_sprintf:NEAR
EXTRN	__imp__AppendMenuA@16:NEAR
EXTRN	__imp__DeleteMenu@12:NEAR
;	COMDAT ??_C@_07CPEI@?$CG?$CFlu?7?$CFs?$AA@
CONST	SEGMENT
??_C@_07CPEI@?$CG?$CFlu?7?$CFs?$AA@ DB '&%lu', 09H, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EEEI@Recent?5File?$AA@
CONST	SEGMENT
??_C@_0M@EEEI@Recent?5File?$AA@ DB 'Recent File', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Apply@CMRU@@UAEXXZ
_TEXT	SEGMENT
_this$ = -528
_szString$ = -520
_i$ = -524
?Apply@CMRU@@UAEXXZ PROC NEAR				; CMRU::Apply, COMDAT
; _this$ = ecx

; 283  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  00009	89 8d f0 fd ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 284  :     CHAR                    szString[MAX_PATH + 0x100];
; 285  :     UINT                    i;
; 286  :     
; 287  :     if(!m_hmenu)

  0000f	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 b8 18 04 00
	00 00		 cmp	 DWORD PTR [eax+1048], 0
  0001c	75 05		 jne	 SHORT $L51383

; 288  :     {
; 289  :         return;

  0001e	e9 09 01 00 00	 jmp	 $L51380
$L51383:
$L51385:

; 290  :     }
; 291  : 
; 292  :     //
; 293  :     // Remove existing menu items
; 294  :     //
; 295  :     
; 296  :     while(DeleteMenu(m_hmenu, 0, MF_BYPOSITION));

  00023	68 00 04 00 00	 push	 1024			; 00000400H
  00028	6a 00		 push	 0
  0002a	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00030	8b 91 18 04 00
	00		 mov	 edx, DWORD PTR [ecx+1048]
  00036	52		 push	 edx
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteMenu@12
  0003d	85 c0		 test	 eax, eax
  0003f	74 02		 je	 SHORT $L51386
  00041	eb e0		 jmp	 SHORT $L51385
$L51386:

; 297  : 
; 298  :     //
; 299  :     // Add MRU data
; 300  :     //
; 301  : 
; 302  :     if(m_aszPaths[0][0])

  00043	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00049	0f be 48 08	 movsx	 ecx, BYTE PTR [eax+8]
  0004d	85 c9		 test	 ecx, ecx
  0004f	0f 84 b0 00 00
	00		 je	 $L51387

; 303  :     {
; 304  :         for(i = 0; i < NUMELMS(m_aszPaths); i++)

  00055	c7 85 f4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0005f	eb 0f		 jmp	 SHORT $L51388
$L51389:
  00061	8b 95 f4 fd ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00067	83 c2 01	 add	 edx, 1
  0006a	89 95 f4 fd ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$L51388:
  00070	83 bd f4 fd ff
	ff 04		 cmp	 DWORD PTR _i$[ebp], 4
  00077	0f 83 86 00 00
	00		 jae	 $L51390

; 305  :         {
; 306  :             if(!m_aszPaths[i][0])

  0007d	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00083	69 c0 04 01 00
	00		 imul	 eax, 260		; 00000104H
  00089	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	0f be 54 01 08	 movsx	 edx, BYTE PTR [ecx+eax+8]
  00094	85 d2		 test	 edx, edx
  00096	75 02		 jne	 SHORT $L51391

; 307  :             {
; 308  :                 break;

  00098	eb 69		 jmp	 SHORT $L51390
$L51391:

; 309  :             }
; 310  : 
; 311  :             sprintf(szString, "&%lu\t%s", i + 1, m_aszPaths[i]);

  0009a	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000a0	69 c0 04 01 00
	00		 imul	 eax, 260		; 00000104H
  000a6	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  000b0	52		 push	 edx
  000b1	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000b7	83 c0 01	 add	 eax, 1
  000ba	50		 push	 eax
  000bb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CPEI@?$CG?$CFlu?7?$CFs?$AA@ ; `string'
  000c0	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _szString$[ebp]
  000c6	51		 push	 ecx
  000c7	e8 00 00 00 00	 call	 _sprintf
  000cc	83 c4 10	 add	 esp, 16			; 00000010H

; 312  : 
; 313  :             AppendMenu(m_hmenu, MF_STRING, m_nCommandId + i, szString);

  000cf	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _szString$[ebp]
  000d5	52		 push	 edx
  000d6	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000dc	8b 88 1c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1052]
  000e2	03 8d f4 fd ff
	ff		 add	 ecx, DWORD PTR _i$[ebp]
  000e8	51		 push	 ecx
  000e9	6a 00		 push	 0
  000eb	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000f1	8b 82 18 04 00
	00		 mov	 eax, DWORD PTR [edx+1048]
  000f7	50		 push	 eax
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AppendMenuA@16

; 314  :         }

  000fe	e9 5e ff ff ff	 jmp	 $L51389
$L51390:

; 315  :     }
; 316  :     else

  00103	eb 27		 jmp	 SHORT $L51393
$L51387:

; 317  :     {
; 318  :         AppendMenu(m_hmenu, MF_STRING | MF_GRAYED, m_nCommandId, "Recent File");

  00105	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@EEEI@Recent?5File?$AA@ ; `string'
  0010a	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00110	8b 91 1c 04 00
	00		 mov	 edx, DWORD PTR [ecx+1052]
  00116	52		 push	 edx
  00117	6a 01		 push	 1
  00119	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0011f	8b 88 18 04 00
	00		 mov	 ecx, DWORD PTR [eax+1048]
  00125	51		 push	 ecx
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AppendMenuA@16
$L51393:
$L51380:

; 319  :     }
; 320  : }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c3		 ret	 0
?Apply@CMRU@@UAEXXZ ENDP				; CMRU::Apply
_TEXT	ENDS
EXTRN	_strcpy:NEAR
EXTRN	__strcmpi:NEAR
; Function compile flags: /Odt
;	COMDAT ?AddItem@CMRU@@UAEXPBD@Z
_TEXT	SEGMENT
_pszPath$ = 8
_this$ = -276
_nItemIndex$ = -272
_i$ = -268
?AddItem@CMRU@@UAEXPBD@Z PROC NEAR			; CMRU::AddItem, COMDAT
; _this$ = ecx

; 346  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	89 8d ec fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 347  :     UINT                    nItemIndex          = -1;

  0000f	c7 85 f0 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _nItemIndex$[ebp], -1

; 348  :     CHAR                    szTemp[MAX_PATH];
; 349  :     UINT                    i;
; 350  :     
; 351  :     //
; 352  :     // See if the item already appears in the list
; 353  :     //
; 354  : 
; 355  :     for(i = 0; i < NUMELMS(m_aszPaths); i++)

  00019	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00023	eb 0f		 jmp	 SHORT $L51402
$L51403:
  00025	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0002b	83 c0 01	 add	 eax, 1
  0002e	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L51402:
  00034	83 bd f4 fe ff
	ff 04		 cmp	 DWORD PTR _i$[ebp], 4
  0003b	73 54		 jae	 SHORT $L51404

; 356  :     {
; 357  :         if(!m_aszPaths[i][0])

  0003d	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00043	69 c9 04 01 00
	00		 imul	 ecx, 260		; 00000104H
  00049	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0004f	0f be 44 0a 08	 movsx	 eax, BYTE PTR [edx+ecx+8]
  00054	85 c0		 test	 eax, eax
  00056	75 02		 jne	 SHORT $L51405

; 358  :         {
; 359  :             break;

  00058	eb 37		 jmp	 SHORT $L51404
$L51405:

; 360  :         }
; 361  : 
; 362  :         if(!_strcmpi(pszPath, m_aszPaths[i]))

  0005a	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00060	69 c9 04 01 00
	00		 imul	 ecx, 260		; 00000104H
  00066	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0006c	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  00070	50		 push	 eax
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _pszPath$[ebp]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 __strcmpi
  0007a	83 c4 08	 add	 esp, 8
  0007d	85 c0		 test	 eax, eax
  0007f	75 0e		 jne	 SHORT $L51406

; 363  :         {
; 364  :             nItemIndex = i;

  00081	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00087	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _nItemIndex$[ebp], edx

; 365  :             break;

  0008d	eb 02		 jmp	 SHORT $L51404
$L51406:

; 366  :         }
; 367  :     }

  0008f	eb 94		 jmp	 SHORT $L51403
$L51404:

; 368  : 
; 369  :     //
; 370  :     // If the item's already in the list, just reorder so it's at the top.  If
; 371  :     // not, add the item to the top of the list.
; 372  :     //
; 373  : 
; 374  :     if(nItemIndex >= NUMELMS(m_aszPaths))

  00091	83 bd f0 fe ff
	ff 04		 cmp	 DWORD PTR _nItemIndex$[ebp], 4
  00098	72 0a		 jb	 SHORT $L51407

; 375  :     {
; 376  :         nItemIndex = NUMELMS(m_aszPaths) - 1;

  0009a	c7 85 f0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR _nItemIndex$[ebp], 3
$L51407:

; 377  :     }
; 378  : 
; 379  :     for(i = nItemIndex; i > 0; i--)

  000a4	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _nItemIndex$[ebp]
  000aa	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
  000b0	eb 0f		 jmp	 SHORT $L51408
$L51409:
  000b2	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000b8	83 e9 01	 sub	 ecx, 1
  000bb	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
$L51408:
  000c1	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR _i$[ebp], 0
  000c8	76 3b		 jbe	 SHORT $L51410

; 380  :     {
; 381  :         strcpy(m_aszPaths[i], m_aszPaths[i - 1]);

  000ca	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  000d0	83 ea 01	 sub	 edx, 1
  000d3	69 d2 04 01 00
	00		 imul	 edx, 260		; 00000104H
  000d9	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000df	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  000e3	51		 push	 ecx
  000e4	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  000ea	69 d2 04 01 00
	00		 imul	 edx, 260		; 00000104H
  000f0	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000f6	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  000fa	51		 push	 ecx
  000fb	e8 00 00 00 00	 call	 _strcpy
  00100	83 c4 08	 add	 esp, 8

; 382  :     }

  00103	eb ad		 jmp	 SHORT $L51409
$L51410:

; 383  : 
; 384  :     strcpy(m_aszPaths[0], pszPath);

  00105	8b 55 08	 mov	 edx, DWORD PTR _pszPath$[ebp]
  00108	52		 push	 edx
  00109	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0010f	83 c0 08	 add	 eax, 8
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 _strcpy
  00118	83 c4 08	 add	 esp, 8

; 385  : 
; 386  :     //
; 387  :     // Update UI
; 388  :     //
; 389  : 
; 390  :     Apply();

  0011b	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00121	8b 11		 mov	 edx, DWORD PTR [ecx]
  00123	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00129	ff 52 14	 call	 DWORD PTR [edx+20]

; 391  : }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 04 00	 ret	 4
?AddItem@CMRU@@UAEXPBD@Z ENDP				; CMRU::AddItem
_TEXT	ENDS
END
