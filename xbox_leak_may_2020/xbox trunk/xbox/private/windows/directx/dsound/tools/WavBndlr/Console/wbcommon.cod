; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	c:\xbox\private\windows\directx\dsound\tools\wavbndlr\console\wbcommon.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DPKL@?$CIunknown?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06NPGC@?$CInone?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MKNO@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@GKFF@?$CBm_dwRefCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GLPL@m_dwRefCount?5?$DM?5?$HO0UL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BGIF@m_dwRefCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KMJF@ADPCM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HMEK@8?9bit?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KCDF@CWaveBankEntry?$CIthis?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EG@ELIP@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDJN@CWaveBank?$CIthis?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BPPI@?$CFlu?4?$CFlu?4?$CFlu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IMGB@WAVBNDLR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@GJLP@WaveBankCompressFormat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EJ@DEIM@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@MKMD@Unsupported?5format?5tag?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03NLLK@?4?4?2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@DIHO@m_pParent?9?$DOm_dwEntryCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@IOKM@pszFileName?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@LDEE@CWaveBankEntry?3?3Initialize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FD@FKMK@An?5entry?5with?5that?5name?5already?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@JGFL@An?5entry?5using?5that?5filename?5alr@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@LKKO@pszName?5?$HM?$HM?5pszPath?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@JHGL@ENTRY_COUNT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07OKEH@SetName?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@EPOG@That?5name?5is?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@BLDB@CWaveBankEntry?3?3LoadWaveFile?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@EFJM@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@CLEF@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DP@DBDA@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EE@FGDJ@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EE@GAIB@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IMJJ@CWaveBankEntry?3?3SetFlags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@PLDD@ADPCM?5and?58BIT?5filtering?5are?5mut@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DP@EKHO@?$CB?$CI?$CIm_dwFlags?5?$CG?5WBFILTER_ADPCM?$CJ?5?$CG@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@LCBB@dwCopyBufferSize?5?$DO?$DN?5pMetaData?9?$DOP@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@KNFK@CWaveBankEntry?3?3CommitWaveData?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@FDBK@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@PBMG@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@ECLE@Failed?5to?5initialize?5the?5ADPCM?5f@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@OCPI@Failed?5to?5initialize?5the?58BIT?5fi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@FLDH@dwCopyBufferSize?5?$DO?$DN?5dwAlignment?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@NPAA@dwFilterRead?5?$DN?$DN?5dwAlignedRead?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@EGPJ@An?5error?5occurred?5while?5compress@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@HPGN@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@NCIG@dwTotalRead?5?$DN?$DN?5m_PlayRegion?4dwLe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@BIEL@dwTotalWritten?5?$DN?$DN?5pMetaData?9?$DOPla@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08OCCE@ENTRY?$CFlu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@JMEF@CWaveBankEntry?3?3ReadProjectData?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@FBL@Unrecognized?5flag?5character?5in?5p@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KMAE@?0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01IJJ@c?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KPCI@8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@EEJD@CWaveBankEntry?3?3WriteProjectData@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@KNEC@Error?5?$CFlu?5occurred?5writing?5to?5th@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CNLP@m_pParent?9?$DOm_dwBankCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@DKKB@CWaveBank?3?3Initialize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@GOPH@A?5bank?5with?5that?5name?5?$CIor?5a?5simi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@FGEE@A?5bank?5using?5that?5filename?5alrea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EA@FPCK@A?5bank?5using?5that?5header?5filenam@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@NHHK@pszName?5?$HM?$HM?5pszBankFile?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@CEMK@CWaveBank?3?3GenerateBank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04EHOP@BYTE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MNOP@Out?5of?5memory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@LLJI@WAVEBANKENTRY?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@CNBO@dwEntryIndex?5?$DM?5m_dwEntryCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@DLDC@No?5entries?5added?5yet?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FEGI@?$CDpragma?5once?$AN?6?$AN?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@LJBE@typedef?5enum?$AN?6?$HL?$AN?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@PGJH@?$HN?5WAVEBANK_?$CFs?$DL?$AN?6?$AN?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@FMCD@?5?5?5?5WAVEBANK_?$CFs_?$CFs?5?$DN?5?$CFlu?0?$AN?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@PPJD@?$CDdefine?5WAVEBANK_?$CFs_ENTRY_COUNT?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@DFCH@CWaveBank?3?3GenerateHeader?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DP@PPNC@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@OAEM@dwEntry?5?$DN?$DN?5m_dwEntryCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07EKKD@BANK?$CFlu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MAGD@BANKNAME?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GMOM@BANKFILE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EHAE@HEADERFILE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OCBI@ENTRYCOUNT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@LOJ@CWaveBank?3?3WriteProjectData?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EA@BMIG@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03JGAL@?$CFlu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@FBPA@i?5?$DM?5m_dwEntryCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@DJKC@i?5?$DN?$DN?5m_dwEntryCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@LLIE@CWaveBankProject?3?3Generate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@FGNA@No?5banks?5in?5the?5project?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@KDBM@No?5entries?5in?5the?5project?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@BCKI@CWaveBankProject?3?3ReadProjectDat@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@BNOK@Unable?5to?5change?5to?5project?5file@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09FLO@BANKCOUNT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07KBBM@PROJECT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@OGBN@CWaveBankProject?3?3WriteProjectDa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@KDFE@i?5?$DM?5m_dwBankCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@PBIF@i?5?$DN?$DN?5m_dwBankCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HPGM@?$CFs?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GGMM@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JFHJ@?$CFhs?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07GHMC@?$CF?48lx?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07MKMO@Error?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@IMNF@Resource?5failure?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NLAH@Warning?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@HJBP@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@OGHG@Assertion?5failed?5in?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07PKF@?0?5line?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02CGGM@?3?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08KCAL@cbBuffer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@BHJJ@CMemoryManager?3?3PoolAlloc?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@LFMI@Out?5of?5pool?5memory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08KLJN@pvBuffer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@JMGJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BFD@dwFlags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@LELL@CMemoryManager?3?3PhysicalAlloc?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MFKD@Out?5of?5contiguous?5memory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@EFP@pvBaseAddress?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@NOEM@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06DOGD@cbSize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@EOH@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@EGEG@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@CNJN@Begin?5memory?5usage?5dump?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@HDD@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@PGGD@Pool?5memory?5used?3?5?5?$CFlu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@MNK@Physical?5memory?5used?3?5?5?$CFlu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@LFMD@End?5memory?5usage?5dump?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@GIH@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@JMDO@IsListEmpty?$CI?$CGm_lstMemoryTracking@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04PBHC@pwfx?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MJPI@pDest?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07JEGE@pSource?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@MOEB@Unexpected?5format?5tag?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@NKLB@WaveFormat?3?3IsValidFormat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@OKFK@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@GBOE@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@GMMP@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@IKOG@Format?5tag?5not?5PCM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@DNIK@Invalid?5channel?5count?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@NALA@Invalid?5sample?5bit?5resolution?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@PDOD@Invalid?5sampling?5rate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@CHML@Bad?5block?5alignment?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@ILPH@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@HOLG@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@CADJ@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@OFFM@Format?5tag?5not?5XBOX_ADPCM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@DKJO@cbSize?5not?5?$CFlu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@GLJN@Invalid?5samples?5per?5block?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@OJBC@Bad?5block?9alignment?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@LGGN@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@EAAG@CStdFileStream?3?3Open?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@CAJD@Error?5?$CFlu?5occurred?5trying?5to?5ope@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@OPLH@CStdFileStream?3?3Read?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DHDM@Error?5?$CFlu?5occurred?5reading?5from?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@ONHL@Not?5enough?5data?5was?5read?5from?5th@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBDH@CStdFileStream?3?3Write?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@MCKM@Error?5?$CFlu?5occurred?5writing?5to?5th@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@MMCK@Not?5enough?5data?5was?5written?5from@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@JBBC@CStdFileStream?3?3Seek?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@PFDI@Error?5?$CFlu?5occurred?5seeking?5the?5f@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@LINH@CStdFileStream?3?3GetLength?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@CIMA@Error?5?$CFlu?5attempting?5to?5get?5the?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@EPJI@CRiffChunk?3?3Read?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@LIHM@Attempted?5to?5read?5past?5the?5end?5o@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@DPCC@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPN@CWaveFile?3?3Open?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@LAOA@The?5file?5type?5is?5not?5WAVE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@CCLG@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@MPHA@The?5file?8s?5AIFF?9C?5version?5is?5not@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@OAHJ@m_pwfxFormat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@DJPM@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@DNJG@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KIEA@CWaveFile?3?3GetAiffFormat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@IGMG@Unsupported?5AIFF?5compression?5typ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@FFJO@CStdFileStream?3?3GetWaveLoopRegio@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@EIKN@No?5FORWARD?5loop?5regions?5found?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@ENEM@Only?5the?5first?5FORWARD?5loop?5will@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@EGGG@Neither?5loop?5is?5FORWARD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DF@PJLL@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@INFE@Can?8t?5find?5loop?5start?5marker?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@DPMK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKN@Can?8t?5find?5loop?5end?5marker?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@DCLE@Loop?5end?5point?5less?9than?9or?9equa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@CGPO@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GOLD@8?5?$DN?$DN?5dwBitDepth?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPBDK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCRefCount@DirectSound@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRefCount@DirectSound@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CRefCount@DirectSound@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CRefCount@DirectSound@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataOffset@CRiffChunk@WaveLoader@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Open@CWaveFile@WaveLoader@@QAEJPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@CWaveFile@WaveLoader@@QAEJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataOffset@CWaveFile@WaveLoader@@QAEJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDuration@CWaveFile@WaveLoader@@QAEJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSourceAlignment@CXboxAdpcmFilter@@SGKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSourceAlignment@CXboxAdpcmFilter@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDestinationAlignment@CXboxAdpcmFilter@@SGKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDestinationAlignment@CXboxAdpcmFilter@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@CXboxAdpcmFilter@@SGKKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@CXboxAdpcmFilter@@UAEKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSourceAlignment@C8BitFilter@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDestinationAlignment@C8BitFilter@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@C8BitFilter@@SGKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@C8BitFilter@@UAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveEntry@CWaveBank@@UAEXPAVCWaveBankEntry@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateEntry@CWaveBank@@MAEPAVCWaveBankEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveBank@CWaveBankProject@@UAEXPAVCWaveBank@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateBank@CWaveBankProject@@MAEPAVCWaveBank@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WaveBankExpandFormat@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WaveBankCompressFormat@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CXboxAdpcmFilter@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCXboxAdpcmFilter@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CXboxAdpcmFilter@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Initialize@CXboxAdpcmFilter@@UAEHPBU_WAVEBANKMINIWAVEFORMAT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidFormat@CXboxAdpcmFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertFormat@CXboxAdpcmFilter@@SGHPAU_WAVEBANKMINIWAVEFORMAT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Convert@CXboxAdpcmFilter@@UAEHPBXPAKPAX1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0C8BitFilter@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GC8BitFilter@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1C8BitFilter@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Initialize@C8BitFilter@@UAEHPBU_WAVEBANKMINIWAVEFORMAT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidFormat@C8BitFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertFormat@C8BitFilter@@SGHPAU_WAVEBANKMINIWAVEFORMAT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Convert@C8BitFilter@@UAEHPBXPAKPAX1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeHeaderString@@YGXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractDirectory@@YGPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRelativePath@@YGXPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWaveBankEntry@@QAE@PAVCWaveBank@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCWaveBankEntry@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWaveBankEntry@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Initialize@CWaveBankEntry@@UAEJPBD0K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindDuplicateEntry@CWaveBankEntry@@MAEJPBDPAI01@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetName@CWaveBankEntry@@UAEJPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadWaveFile@CWaveBankEntry@@MAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetValidFlags@CWaveBankEntry@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFlags@CWaveBankEntry@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMetaData@CWaveBankEntry@@UAEJPAU_WAVEBANKENTRY@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CommitWaveData@CWaveBankEntry@@UAEJPAVCStdFileStream@WaveLoader@@KPBU_WAVEBANKENTRY@@PAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadProjectData@CWaveBankEntry@@UAEJPBD0K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteProjectData@CWaveBankEntry@@UAEJPBD0K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWaveBank@@QAE@PAVCWaveBankProject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCWaveBank@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWaveBank@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Initialize@CWaveBank@@UAEJPBD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindDuplicateBank@CWaveBank@@MAEJPBDPAI0101@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetName@CWaveBank@@UAEJPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddEntry@CWaveBank@@UAEJPBD0KPAPAVCWaveBankEntry@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateBank@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadProjectData@CWaveBank@@UAEJPBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteProjectData@CWaveBank@@UAEJPBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBankDataSize@CWaveBank@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWaveBankProject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCWaveBankProject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWaveBankProject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddBank@CWaveBankProject@@UAEJPBD00PAPAVCWaveBank@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Generate@CWaveBankProject@@UAEJPAVCWaveBankCallback@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadProjectData@CWaveBankProject@@UAEJPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteProjectData@CWaveBankProject@@UAEJPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dstrcpy@@YGPADPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Print@CDebug@DirectSound@@SAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Break@CDebug@DirectSound@@SAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndianSwapWord@@YIGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndianSwapDword@@YIKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CStdFileStream@WaveLoader@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CStdFileStream@WaveLoader@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Close@CStdFileStream@WaveLoader@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRiffChunk@WaveLoader@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRiffChunk@WaveLoader@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWaveFile@WaveLoader@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWaveFile@WaveLoader@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Close@CWaveFile@WaveLoader@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CImaAdpcmCodec@DirectSound@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CImaAdpcmCodec@DirectSound@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CWaveBank@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CXboxAdpcmFilter@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CWaveBankEntry@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CImaAdpcmCodec@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CRefCount@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7C8BitFilter@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CWaveBankProject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0EP@HJBP@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ ; `string'
PUBLIC	??_C@_0EP@EGEG@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	?m_asNextStep@CImaAdpcmCodec@DirectSound@@0QBFB	; DirectSound::CImaAdpcmCodec::m_asNextStep
PUBLIC	?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB	; DirectSound::CImaAdpcmCodec::m_asStep
PUBLIC	?m_dwDpfLevel@CDebug@DirectSound@@2KA		; DirectSound::CDebug::m_dwDpfLevel
PUBLIC	?m_dwDpfBreakLevel@CDebug@DirectSound@@2KA	; DirectSound::CDebug::m_dwDpfBreakLevel
PUBLIC	?m_fDebugBreak@CDebug@DirectSound@@2HA		; DirectSound::CDebug::m_fDebugBreak
PUBLIC	?m_pfnDpfCallback@CDebug@DirectSound@@2P6GXKPBD@ZA ; DirectSound::CDebug::m_pfnDpfCallback
PUBLIC	?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A ; DirectSound::CDebug::m_aContext
PUBLIC	??_C@_0BB@FEGI@?$CDpragma?5once?$AN?6?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@LJBE@typedef?5enum?$AN?6?$HL?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@PGJH@?$HN?5WAVEBANK_?$CFs?$DL?$AN?6?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@FMCD@?5?5?5?5WAVEBANK_?$CFs_?$CFs?5?$DN?5?$CFlu?0?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CG@PPJD@?$CDdefine?5WAVEBANK_?$CFs_ENTRY_COUNT?5@ ; `string'
PUBLIC	?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
PUBLIC	?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
PUBLIC	?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
_BSS	SEGMENT
?m_fDebugBreak@CDebug@DirectSound@@2HA DD 01H DUP (?)	; DirectSound::CDebug::m_fDebugBreak
?m_pfnDpfCallback@CDebug@DirectSound@@2P6GXKPBD@ZA DD 01H DUP (?) ; DirectSound::CDebug::m_pfnDpfCallback
?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A DB 018H DUP (?) ; DirectSound::CDebug::m_aContext
?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA DD 01H DUP (?) ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2KA DD 01H DUP (?) ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A DQ 01H DUP (?) ; DirectSound::CMemoryManager::m_lstMemoryTracking
?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA DD 04H DUP (?) ; `DirectSound::CImaAdpcmCodec::Initialize'::`2'::apfnConvert
_BSS	ENDS
CONST	SEGMENT
?dwMajor@?1??GetWaveBundlerVersion@@YGXPAD@Z@4KB DD 01H	; `GetWaveBundlerVersion'::`2'::dwMajor
?dwMinor@?1??GetWaveBundlerVersion@@YGXPAD@Z@4KB DD 00H	; `GetWaveBundlerVersion'::`2'::dwMinor
?dwBuild@?1??GetWaveBundlerVersion@@YGXPAD@Z@4KB DD 01130H ; `GetWaveBundlerVersion'::`2'::dwBuild
?dwAlignment@?1??GetMetaData@CWaveBankEntry@@UAEJPAU_WAVEBANKENTRY@@PAK@Z@4KB DD 04H ; `CWaveBankEntry::GetMetaData'::`2'::dwAlignment
?dwCopyBufferSize@?1??GenerateBank@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z@4KB DD 040000H ; `CWaveBank::GenerateBank'::`2'::dwCopyBufferSize
CONST	ENDS
;	COMDAT ??_C@_0BB@FEGI@?$CDpragma?5once?$AN?6?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BB@FEGI@?$CDpragma?5once?$AN?6?$AN?6?$AA@ DB '#pragma once', 0dH, 0aH
	DB	0dH, 0aH, 00H				; `string'
CONST	ENDS
CONST	SEGMENT
?pszFileBegin@?1??GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z@4QBDB DD FLAT:??_C@_0BB@FEGI@?$CDpragma?5once?$AN?6?$AN?6?$AA@ ; `CWaveBank::GenerateHeader'::`2'::pszFileBegin
CONST	ENDS
;	COMDAT ??_C@_0BC@LJBE@typedef?5enum?$AN?6?$HL?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BC@LJBE@typedef?5enum?$AN?6?$HL?$AN?6?$AA@ DB 'typedef enum', 0dH, 0aH
	DB	'{', 0dH, 0aH, 00H				; `string'
CONST	ENDS
CONST	SEGMENT
?pszEnumBegin@?1??GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z@4QBDB DD FLAT:??_C@_0BC@LJBE@typedef?5enum?$AN?6?$HL?$AN?6?$AA@ ; `CWaveBank::GenerateHeader'::`2'::pszEnumBegin
CONST	ENDS
;	COMDAT ??_C@_0BD@PGJH@?$HN?5WAVEBANK_?$CFs?$DL?$AN?6?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@PGJH@?$HN?5WAVEBANK_?$CFs?$DL?$AN?6?$AN?6?$AA@ DB '} WAVEBANK_%'
	DB	's;', 0dH, 0aH, 0dH, 0aH, 00H		; `string'
CONST	ENDS
CONST	SEGMENT
?pszEnumEnd@?1??GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z@4QBDB DD FLAT:??_C@_0BD@PGJH@?$HN?5WAVEBANK_?$CFs?$DL?$AN?6?$AN?6?$AA@ ; `CWaveBank::GenerateHeader'::`2'::pszEnumEnd
CONST	ENDS
;	COMDAT ??_C@_0BM@FMCD@?5?5?5?5WAVEBANK_?$CFs_?$CFs?5?$DN?5?$CFlu?0?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BM@FMCD@?5?5?5?5WAVEBANK_?$CFs_?$CFs?5?$DN?5?$CFlu?0?$AN?6?$AA@ DB ' '
	DB	'   WAVEBANK_%s_%s = %lu,', 0dH, 0aH, 00H	; `string'
CONST	ENDS
CONST	SEGMENT
?pszEnumEntry@?1??GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z@4QBDB DD FLAT:??_C@_0BM@FMCD@?5?5?5?5WAVEBANK_?$CFs_?$CFs?5?$DN?5?$CFlu?0?$AN?6?$AA@ ; `CWaveBank::GenerateHeader'::`2'::pszEnumEntry
CONST	ENDS
;	COMDAT ??_C@_0CG@PPJD@?$CDdefine?5WAVEBANK_?$CFs_ENTRY_COUNT?5@
CONST	SEGMENT
??_C@_0CG@PPJD@?$CDdefine?5WAVEBANK_?$CFs_ENTRY_COUNT?5@ DB '#define WAVE'
	DB	'BANK_%s_ENTRY_COUNT %lu', 0dH, 0aH, 00H	; `string'
CONST	ENDS
CONST	SEGMENT
?pszEnumCount@?1??GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z@4QBDB DD FLAT:??_C@_0CG@PPJD@?$CDdefine?5WAVEBANK_?$CFs_ENTRY_COUNT?5@ ; `CWaveBank::GenerateHeader'::`2'::pszEnumCount
CONST	ENDS
_DATA	SEGMENT
?m_dwDpfLevel@CDebug@DirectSound@@2KA DD 04H		; DirectSound::CDebug::m_dwDpfLevel
?m_dwDpfBreakLevel@CDebug@DirectSound@@2KA DD 02H	; DirectSound::CDebug::m_dwDpfBreakLevel
_DATA	ENDS
CONST	SEGMENT
?irql@?1??SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z@4IB DD 00H ; `DirectSound::CDebug::SetContext'::`2'::irql
?irql@?1??Print@CDebug@DirectSound@@SAXPBDZZ@4IB DD 00H	; `DirectSound::CDebug::Print'::`2'::irql
CONST	ENDS
;	COMDAT ??_C@_0EP@HJBP@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
CONST	SEGMENT
??_C@_0EP@HJBP@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ DB '*'
	DB	'*************************************************************'
	DB	'****************', 00H			; `string'
CONST	ENDS
CONST	SEGMENT
?pszBanner@?1??Assert@CDebug@DirectSound@@SAXHPBD0I@Z@4QBDB DD FLAT:??_C@_0EP@HJBP@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ ; `DirectSound::CDebug::Assert'::`2'::pszBanner
?cbLowerThreshold@?1??PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z@4KB DD 020H ; `DirectSound::CMemoryManager::PoolAlloc'::`2'::cbLowerThreshold
?cbUpperThreshold@?1??PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z@4KB DD 0fd8H ; `DirectSound::CMemoryManager::PoolAlloc'::`2'::cbUpperThreshold
?cbTracking@?1??TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z@4KB DD 020H ; `DirectSound::CMemoryManager::TrackingPoolAlloc'::`2'::cbTracking
CONST	ENDS
;	COMDAT ??_C@_0EP@EGEG@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0EP@EGEG@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'-------------------------------------------------------------'
	DB	'----------------', 00H			; `string'
CONST	ENDS
CONST	SEGMENT
?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB DD FLAT:??_C@_0EP@EGEG@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `DirectSound::CMemoryManager::DumpMemoryUsage'::`2'::pszBanner
?wBitsPerSample@?1??AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUima_adpcmwaveformat_tag@@@Z@4EB DB 04H ; `DirectSound::WaveFormat::AdpcmToInternalFormat'::`2'::wBitsPerSample
	ORG $+1
?wSamplesPerBlock@?1??IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z@4GB DW 040H ; `DirectSound::WaveFormat::IsValidAdpcmFormat'::`2'::wSamplesPerBlock
?wBitsPerSample@?1??IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z@4GB DW 04H ; `DirectSound::WaveFormat::IsValidAdpcmFormat'::`2'::wBitsPerSample
?wBytesPerBlock@?1??IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z@4GB DW 024H ; `DirectSound::WaveFormat::IsValidAdpcmFormat'::`2'::wBytesPerBlock
?m_asNextStep@CImaAdpcmCodec@DirectSound@@0QBFB DW 0ffffH ; DirectSound::CImaAdpcmCodec::m_asNextStep
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	02H
	DW	04H
	DW	06H
	DW	08H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	02H
	DW	04H
	DW	06H
	DW	08H
	ORG $+4
?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB DW 07H	; DirectSound::CImaAdpcmCodec::m_asStep
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	010H
	DW	011H
	DW	013H
	DW	015H
	DW	017H
	DW	019H
	DW	01cH
	DW	01fH
	DW	022H
	DW	025H
	DW	029H
	DW	02dH
	DW	032H
	DW	037H
	DW	03cH
	DW	042H
	DW	049H
	DW	050H
	DW	058H
	DW	061H
	DW	06bH
	DW	076H
	DW	082H
	DW	08fH
	DW	09dH
	DW	0adH
	DW	0beH
	DW	0d1H
	DW	0e6H
	DW	0fdH
	DW	0117H
	DW	0133H
	DW	0151H
	DW	0173H
	DW	0198H
	DW	01c1H
	DW	01eeH
	DW	0220H
	DW	0256H
	DW	0292H
	DW	02d4H
	DW	031cH
	DW	036cH
	DW	03c3H
	DW	0424H
	DW	048eH
	DW	0502H
	DW	0583H
	DW	0610H
	DW	06abH
	DW	0756H
	DW	0812H
	DW	08e0H
	DW	09c3H
	DW	0abdH
	DW	0bd0H
	DW	0cffH
	DW	0e4cH
	DW	0fbaH
	DW	0114cH
	DW	01307H
	DW	014eeH
	DW	01706H
	DW	01954H
	DW	01bdcH
	DW	01ea5H
	DW	021b6H
	DW	02515H
	DW	028caH
	DW	02cdfH
	DW	0315bH
	DW	0364bH
	DW	03bb9H
	DW	041b2H
	DW	04844H
	DW	04f7eH
	DW	05771H
	DW	0602fH
	DW	069ceH
	DW	07462H
	DW	07fffH
CONST	ENDS
PUBLIC	_WaveBankExpandFormat@8
PUBLIC	?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::CreatePcmFormat
PUBLIC	?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUima_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::CreateXboxAdpcmFormat
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\format2.cpp
;	COMDAT _WaveBankExpandFormat@8
_TEXT	SEGMENT
_pwfxCompressed$ = 8
_pwfxExpanded$ = 12
_WaveBankExpandFormat@8 PROC NEAR			; COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   :     DPF_ENTER();
; 46   : 
; 47   :     if(WAVEBANKMINIFORMAT_TAG_ADPCM == pwfxCompressed->wFormatTag)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfxCompressed$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	83 e1 01	 and	 ecx, 1
  0000b	83 f9 01	 cmp	 ecx, 1
  0000e	75 25		 jne	 SHORT $L48831

; 48   :     {
; 49   :         XAudioCreateAdpcmFormat((WORD)pwfxCompressed->nChannels, pwfxCompressed->nSamplesPerSec, &pwfxExpanded->AdpcmWaveFormat);

  00010	8b 55 0c	 mov	 edx, DWORD PTR _pwfxExpanded$[ebp]
  00013	52		 push	 edx
  00014	8b 45 08	 mov	 eax, DWORD PTR _pwfxCompressed$[ebp]
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	c1 e9 04	 shr	 ecx, 4
  0001c	81 e1 ff ff ff
	07		 and	 ecx, 134217727		; 07ffffffH
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR _pwfxCompressed$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	d1 e8		 shr	 eax, 1
  0002a	83 e0 07	 and	 eax, 7
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUima_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::CreateXboxAdpcmFormat

; 50   :     }
; 51   :     else

  00033	eb 3b		 jmp	 SHORT $L48833
$L48831:

; 52   :     {
; 53   :         XAudioCreatePcmFormat((WORD)pwfxCompressed->nChannels, pwfxCompressed->nSamplesPerSec, (WAVEBANKMINIFORMAT_BITDEPTH_16 == pwfxCompressed->wBitsPerSample) ? 16 : 8, &pwfxExpanded->WaveFormatEx);

  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _pwfxExpanded$[ebp]
  00038	51		 push	 ecx
  00039	8b 55 08	 mov	 edx, DWORD PTR _pwfxCompressed$[ebp]
  0003c	8b 02		 mov	 eax, DWORD PTR [edx]
  0003e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00041	83 e0 01	 and	 eax, 1
  00044	83 e8 01	 sub	 eax, 1
  00047	f7 d8		 neg	 eax
  00049	1b c0		 sbb	 eax, eax
  0004b	24 f8		 and	 al, -8			; fffffff8H
  0004d	83 c0 10	 add	 eax, 16			; 00000010H
  00050	50		 push	 eax
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _pwfxCompressed$[ebp]
  00054	8b 11		 mov	 edx, DWORD PTR [ecx]
  00056	c1 ea 04	 shr	 edx, 4
  00059	81 e2 ff ff ff
	07		 and	 edx, 134217727		; 07ffffffH
  0005f	52		 push	 edx
  00060	8b 45 08	 mov	 eax, DWORD PTR _pwfxCompressed$[ebp]
  00063	8b 08		 mov	 ecx, DWORD PTR [eax]
  00065	d1 e9		 shr	 ecx, 1
  00067	83 e1 07	 and	 ecx, 7
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::CreatePcmFormat
$L48833:

; 54   :     }
; 55   : 
; 56   :     DPF_LEAVE(TRUE);
; 57   : 
; 58   :     return TRUE;

  00070	b8 01 00 00 00	 mov	 eax, 1

; 59   : }

  00075	5d		 pop	 ebp
  00076	c2 08 00	 ret	 8
_WaveBankExpandFormat@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_08IMGB@WAVBNDLR?$AA@			; `string'
PUBLIC	??_C@_0BH@GJLP@WaveBankCompressFormat?$AA@	; `string'
PUBLIC	??_C@_0EJ@DEIM@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BH@MKMD@Unsupported?5format?5tag?$AA@	; `string'
PUBLIC	_WaveBankCompressFormat@8
PUBLIC	?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z	; DirectSound::CDebug::SetContext
PUBLIC	?Print@CDebug@DirectSound@@SAXPBDZZ		; DirectSound::CDebug::Print
PUBLIC	?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::IsValidPcmFormat
PUBLIC	?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::IsValidAdpcmFormat
;	COMDAT ??_C@_08IMGB@WAVBNDLR?$AA@
CONST	SEGMENT
??_C@_08IMGB@WAVBNDLR?$AA@ DB 'WAVBNDLR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GJLP@WaveBankCompressFormat?$AA@
CONST	SEGMENT
??_C@_0BH@GJLP@WaveBankCompressFormat?$AA@ DB 'WaveBankCompressFormat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@DEIM@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0EJ@DEIM@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\privat'
	DB	'e\windows\directx\dsound\tools\wavbndlr\common\format2.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MKMD@Unsupported?5format?5tag?$AA@
CONST	SEGMENT
??_C@_0BH@MKMD@Unsupported?5format?5tag?$AA@ DB 'Unsupported format tag', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _WaveBankCompressFormat@8
_TEXT	SEGMENT
_pwfxExpanded$ = 8
_pwfxCompressed$ = 12
_fValid$ = -4
_WaveBankCompressFormat@8 PROC NEAR			; COMDAT

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 88   :     BOOL                        fValid;
; 89   : 
; 90   :     DPF_ENTER();
; 91   : 
; 92   :     if(WAVE_FORMAT_PCM == pwfxExpanded->WaveFormatEx.wFormatTag)

  00004	8b 45 08	 mov	 eax, DWORD PTR _pwfxExpanded$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000c	83 f9 01	 cmp	 ecx, 1
  0000f	0f 85 89 00 00
	00		 jne	 $L48840

; 93   :     {
; 94   :         if(fValid = IsValidPcmFormat(&pwfxExpanded->WaveFormatEx))

  00015	8b 55 08	 mov	 edx, DWORD PTR _pwfxExpanded$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 ?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::IsValidPcmFormat
  0001e	89 45 fc	 mov	 DWORD PTR _fValid$[ebp], eax
  00021	83 7d fc 00	 cmp	 DWORD PTR _fValid$[ebp], 0
  00025	74 72		 je	 SHORT $L48841

; 95   :         {
; 96   :             pwfxCompressed->wFormatTag = WAVEBANKMINIFORMAT_TAG_PCM;

  00027	8b 45 0c	 mov	 eax, DWORD PTR _pwfxCompressed$[ebp]
  0002a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002c	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0002f	8b 55 0c	 mov	 edx, DWORD PTR _pwfxCompressed$[ebp]
  00032	89 0a		 mov	 DWORD PTR [edx], ecx

; 97   :             pwfxCompressed->nChannels = pwfxExpanded->WaveFormatEx.nChannels;

  00034	8b 45 08	 mov	 eax, DWORD PTR _pwfxExpanded$[ebp]
  00037	33 c9		 xor	 ecx, ecx
  00039	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0003d	83 e1 07	 and	 ecx, 7
  00040	d1 e1		 shl	 ecx, 1
  00042	8b 55 0c	 mov	 edx, DWORD PTR _pwfxCompressed$[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	24 f1		 and	 al, -15			; fffffff1H
  00049	0b c1		 or	 eax, ecx
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR _pwfxCompressed$[ebp]
  0004e	89 01		 mov	 DWORD PTR [ecx], eax

; 98   :             pwfxCompressed->nSamplesPerSec = pwfxExpanded->WaveFormatEx.nSamplesPerSec;

  00050	8b 55 08	 mov	 edx, DWORD PTR _pwfxExpanded$[ebp]
  00053	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00056	25 ff ff ff 07	 and	 eax, 134217727		; 07ffffffH
  0005b	c1 e0 04	 shl	 eax, 4
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR _pwfxCompressed$[ebp]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  00069	0b d0		 or	 edx, eax
  0006b	8b 45 0c	 mov	 eax, DWORD PTR _pwfxCompressed$[ebp]
  0006e	89 10		 mov	 DWORD PTR [eax], edx

; 99   :             pwfxCompressed->wBitsPerSample = (16 == pwfxExpanded->WaveFormatEx.wBitsPerSample) ? WAVEBANKMINIFORMAT_BITDEPTH_16 : WAVEBANKMINIFORMAT_BITDEPTH_8;

  00070	8b 4d 08	 mov	 ecx, DWORD PTR _pwfxExpanded$[ebp]
  00073	33 d2		 xor	 edx, edx
  00075	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  00079	33 c0		 xor	 eax, eax
  0007b	83 fa 10	 cmp	 edx, 16			; 00000010H
  0007e	0f 94 c0	 sete	 al
  00081	83 e0 01	 and	 eax, 1
  00084	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  00087	8b 4d 0c	 mov	 ecx, DWORD PTR _pwfxCompressed$[ebp]
  0008a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008c	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  00092	0b d0		 or	 edx, eax
  00094	8b 45 0c	 mov	 eax, DWORD PTR _pwfxCompressed$[ebp]
  00097	89 10		 mov	 DWORD PTR [eax], edx
$L48841:

; 100  :         }
; 101  :     }
; 102  :     else if(WAVE_FORMAT_XBOX_ADPCM == pwfxExpanded->WaveFormatEx.wFormatTag)

  00099	e9 ab 00 00 00	 jmp	 $L48842
$L48840:
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _pwfxExpanded$[ebp]
  000a1	33 d2		 xor	 edx, edx
  000a3	66 8b 11	 mov	 dx, WORD PTR [ecx]
  000a6	83 fa 69	 cmp	 edx, 105		; 00000069H
  000a9	75 6d		 jne	 SHORT $L48843

; 103  :     {
; 104  :         if(fValid = IsValidAdpcmFormat(&pwfxExpanded->AdpcmWaveFormat))

  000ab	8b 45 08	 mov	 eax, DWORD PTR _pwfxExpanded$[ebp]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::IsValidAdpcmFormat
  000b4	89 45 fc	 mov	 DWORD PTR _fValid$[ebp], eax
  000b7	83 7d fc 00	 cmp	 DWORD PTR _fValid$[ebp], 0
  000bb	74 59		 je	 SHORT $L48844

; 105  :         {
; 106  :             pwfxCompressed->wFormatTag = WAVEBANKMINIFORMAT_TAG_ADPCM;

  000bd	8b 4d 0c	 mov	 ecx, DWORD PTR _pwfxCompressed$[ebp]
  000c0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c2	83 ca 01	 or	 edx, 1
  000c5	8b 45 0c	 mov	 eax, DWORD PTR _pwfxCompressed$[ebp]
  000c8	89 10		 mov	 DWORD PTR [eax], edx

; 107  :             pwfxCompressed->nChannels = pwfxExpanded->WaveFormatEx.nChannels;

  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _pwfxExpanded$[ebp]
  000cd	33 d2		 xor	 edx, edx
  000cf	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  000d3	83 e2 07	 and	 edx, 7
  000d6	d1 e2		 shl	 edx, 1
  000d8	8b 45 0c	 mov	 eax, DWORD PTR _pwfxCompressed$[ebp]
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	83 e1 f1	 and	 ecx, -15		; fffffff1H
  000e0	0b ca		 or	 ecx, edx
  000e2	8b 55 0c	 mov	 edx, DWORD PTR _pwfxCompressed$[ebp]
  000e5	89 0a		 mov	 DWORD PTR [edx], ecx

; 108  :             pwfxCompressed->nSamplesPerSec = pwfxExpanded->WaveFormatEx.nSamplesPerSec;

  000e7	8b 45 08	 mov	 eax, DWORD PTR _pwfxExpanded$[ebp]
  000ea	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ed	81 e1 ff ff ff
	07		 and	 ecx, 134217727		; 07ffffffH
  000f3	c1 e1 04	 shl	 ecx, 4
  000f6	8b 55 0c	 mov	 edx, DWORD PTR _pwfxCompressed$[ebp]
  000f9	8b 02		 mov	 eax, DWORD PTR [edx]
  000fb	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  00100	0b c1		 or	 eax, ecx
  00102	8b 4d 0c	 mov	 ecx, DWORD PTR _pwfxCompressed$[ebp]
  00105	89 01		 mov	 DWORD PTR [ecx], eax

; 109  :             pwfxCompressed->wBitsPerSample = WAVEBANKMINIFORMAT_BITDEPTH_4;

  00107	8b 55 0c	 mov	 edx, DWORD PTR _pwfxCompressed$[ebp]
  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  00111	8b 4d 0c	 mov	 ecx, DWORD PTR _pwfxCompressed$[ebp]
  00114	89 01		 mov	 DWORD PTR [ecx], eax
$L48844:

; 110  :         }
; 111  :     }
; 112  :     else

  00116	eb 31		 jmp	 SHORT $L48845
$L48843:

; 113  :     {
; 114  :         DPF_ERROR("Unsupported format tag");

  00118	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0011d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@GJLP@WaveBankCompressFormat?$AA@ ; `string'
  00122	6a 72		 push	 114			; 00000072H
  00124	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EJ@DEIM@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00129	6a 01		 push	 1
  0012b	6a 09		 push	 9
  0012d	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00132	83 c4 18	 add	 esp, 24			; 00000018H
  00135	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@MKMD@Unsupported?5format?5tag?$AA@ ; `string'
  0013a	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0013f	83 c4 04	 add	 esp, 4

; 115  :         fValid = FALSE;

  00142	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L48845:
$L48842:

; 116  :     }   
; 117  : 
; 118  :     DPF_LEAVE(fValid);
; 119  : 
; 120  :     return fValid;

  00149	8b 45 fc	 mov	 eax, DWORD PTR _fValid$[ebp]

; 121  : }

  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c2 08 00	 ret	 8
_WaveBankCompressFormat@8 ENDP
_TEXT	ENDS
PUBLIC	??0CImaAdpcmCodec@DirectSound@@QAE@XZ		; DirectSound::CImaAdpcmCodec::CImaAdpcmCodec
PUBLIC	??0CXboxAdpcmFilter@@QAE@XZ			; CXboxAdpcmFilter::CXboxAdpcmFilter
PUBLIC	?Initialize@CXboxAdpcmFilter@@UAEHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ; CXboxAdpcmFilter::Initialize
PUBLIC	?GetSourceAlignment@CXboxAdpcmFilter@@UAEKXZ	; CXboxAdpcmFilter::GetSourceAlignment
PUBLIC	?GetDestinationAlignment@CXboxAdpcmFilter@@UAEKXZ ; CXboxAdpcmFilter::GetDestinationAlignment
PUBLIC	?GetSize@CXboxAdpcmFilter@@UAEKKH@Z		; CXboxAdpcmFilter::GetSize
PUBLIC	?Convert@CXboxAdpcmFilter@@UAEHPBXPAKPAX1@Z	; CXboxAdpcmFilter::Convert
PUBLIC	??_7CXboxAdpcmFilter@@6B@			; CXboxAdpcmFilter::`vftable'
PUBLIC	??_GCXboxAdpcmFilter@@UAEPAXI@Z			; CXboxAdpcmFilter::`scalar deleting destructor'
PUBLIC	??_ECXboxAdpcmFilter@@UAEPAXI@Z			; CXboxAdpcmFilter::`vector deleting destructor'
;	COMDAT ??_7CXboxAdpcmFilter@@6B@
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\filter.cpp
CONST	SEGMENT
??_7CXboxAdpcmFilter@@6B@ DD FLAT:??_ECXboxAdpcmFilter@@UAEPAXI@Z ; CXboxAdpcmFilter::`vftable'
	DD	FLAT:?Initialize@CXboxAdpcmFilter@@UAEHPBU_WAVEBANKMINIWAVEFORMAT@@@Z
	DD	FLAT:?GetSourceAlignment@CXboxAdpcmFilter@@UAEKXZ
	DD	FLAT:?GetDestinationAlignment@CXboxAdpcmFilter@@UAEKXZ
	DD	FLAT:?GetSize@CXboxAdpcmFilter@@UAEKKH@Z
	DD	FLAT:?Convert@CXboxAdpcmFilter@@UAEHPBXPAKPAX1@Z
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CXboxAdpcmFilter@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CXboxAdpcmFilter@@QAE@XZ PROC NEAR			; CXboxAdpcmFilter::CXboxAdpcmFilter, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CImaAdpcmCodec@DirectSound@@QAE@XZ ; DirectSound::CImaAdpcmCodec::CImaAdpcmCodec
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CXboxAdpcmFilter@@6B@ ; CXboxAdpcmFilter::`vftable'

; 40   : }

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CXboxAdpcmFilter@@QAE@XZ ENDP			; CXboxAdpcmFilter::CXboxAdpcmFilter
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\filter.h
_TEXT	ENDS
;	COMDAT ?GetSourceAlignment@CXboxAdpcmFilter@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4
?GetSourceAlignment@CXboxAdpcmFilter@@UAEKXZ PROC NEAR	; CXboxAdpcmFilter::GetSourceAlignment, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 73   :     return m_wfxEncode.wfx.nChannels * 2 * XBOX_ADPCM_SAMPLES_PER_BLOCK;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  00010	8b c1		 mov	 eax, ecx
  00012	d1 e0		 shl	 eax, 1
  00014	c1 e0 06	 shl	 eax, 6

; 74   : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?GetSourceAlignment@CXboxAdpcmFilter@@UAEKXZ ENDP	; CXboxAdpcmFilter::GetSourceAlignment
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetDestinationAlignment@CXboxAdpcmFilter@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4
?GetDestinationAlignment@CXboxAdpcmFilter@@UAEKXZ PROC NEAR ; CXboxAdpcmFilter::GetDestinationAlignment, COMDAT
; _this$ = ecx

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 83   :     return m_wfxEncode.wfx.nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  00010	8b c1		 mov	 eax, ecx
  00012	6b c0 24	 imul	 eax, 36			; 00000024H

; 84   : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetDestinationAlignment@CXboxAdpcmFilter@@UAEKXZ ENDP	; CXboxAdpcmFilter::GetDestinationAlignment
_TEXT	ENDS
PUBLIC	?GetSize@CXboxAdpcmFilter@@SGKKKH@Z		; CXboxAdpcmFilter::GetSize
; Function compile flags: /Odt
;	COMDAT ?GetSize@CXboxAdpcmFilter@@UAEKKH@Z
_TEXT	SEGMENT
_cbSource$ = 8
_fRoundUp$ = 12
_this$ = -4
?GetSize@CXboxAdpcmFilter@@UAEKKH@Z PROC NEAR		; CXboxAdpcmFilter::GetSize, COMDAT
; _this$ = ecx

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 104  :     return GetSize(cbSource, m_wfxEncode.wfx.nChannels, fRoundUp);

  00007	8b 45 0c	 mov	 eax, DWORD PTR _fRoundUp$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	33 d2		 xor	 edx, edx
  00010	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _cbSource$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?GetSize@CXboxAdpcmFilter@@SGKKKH@Z ; CXboxAdpcmFilter::GetSize

; 105  : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?GetSize@CXboxAdpcmFilter@@UAEKKH@Z ENDP		; CXboxAdpcmFilter::GetSize
_TEXT	ENDS
PUBLIC	?GetSourceAlignment@CXboxAdpcmFilter@@SGKK@Z	; CXboxAdpcmFilter::GetSourceAlignment
PUBLIC	?GetDestinationAlignment@CXboxAdpcmFilter@@SGKK@Z ; CXboxAdpcmFilter::GetDestinationAlignment
; Function compile flags: /Odt
;	COMDAT ?GetSize@CXboxAdpcmFilter@@SGKKKH@Z
_TEXT	SEGMENT
_cbSource$ = 8
_nChannels$ = 12
_fRoundUp$ = 16
_cbSrcAlign$ = -8
_cbDstAlign$ = -4
?GetSize@CXboxAdpcmFilter@@SGKKKH@Z PROC NEAR		; CXboxAdpcmFilter::GetSize, COMDAT

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 88   :     const DWORD             cbSrcAlign  = GetSourceAlignment(nChannels);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _nChannels$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?GetSourceAlignment@CXboxAdpcmFilter@@SGKK@Z ; CXboxAdpcmFilter::GetSourceAlignment
  0000f	89 45 f8	 mov	 DWORD PTR _cbSrcAlign$[ebp], eax

; 89   :     const DWORD             cbDstAlign  = GetDestinationAlignment(nChannels);

  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _nChannels$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ?GetDestinationAlignment@CXboxAdpcmFilter@@SGKK@Z ; CXboxAdpcmFilter::GetDestinationAlignment
  0001b	89 45 fc	 mov	 DWORD PTR _cbDstAlign$[ebp], eax

; 90   :     
; 91   :     if(fRoundUp)

  0001e	83 7d 10 00	 cmp	 DWORD PTR _fRoundUp$[ebp], 0
  00022	74 0d		 je	 SHORT $L48477

; 92   :     {
; 93   :         cbSource += cbSrcAlign - 1;

  00024	8b 55 f8	 mov	 edx, DWORD PTR _cbSrcAlign$[ebp]
  00027	8b 45 08	 mov	 eax, DWORD PTR _cbSource$[ebp]
  0002a	8d 4c 10 ff	 lea	 ecx, DWORD PTR [eax+edx-1]
  0002e	89 4d 08	 mov	 DWORD PTR _cbSource$[ebp], ecx
$L48477:

; 94   :     }
; 95   : 
; 96   :     cbSource /= cbSrcAlign;

  00031	8b 45 08	 mov	 eax, DWORD PTR _cbSource$[ebp]
  00034	33 d2		 xor	 edx, edx
  00036	f7 75 f8	 div	 DWORD PTR _cbSrcAlign$[ebp]
  00039	89 45 08	 mov	 DWORD PTR _cbSource$[ebp], eax

; 97   :     cbSource *= cbDstAlign;

  0003c	8b 55 08	 mov	 edx, DWORD PTR _cbSource$[ebp]
  0003f	0f af 55 fc	 imul	 edx, DWORD PTR _cbDstAlign$[ebp]
  00043	89 55 08	 mov	 DWORD PTR _cbSource$[ebp], edx

; 98   :     
; 99   :     return cbSource;

  00046	8b 45 08	 mov	 eax, DWORD PTR _cbSource$[ebp]

; 100  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 0c 00	 ret	 12			; 0000000cH
?GetSize@CXboxAdpcmFilter@@SGKKKH@Z ENDP		; CXboxAdpcmFilter::GetSize
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetSourceAlignment@CXboxAdpcmFilter@@SGKK@Z
_TEXT	SEGMENT
_nChannels$ = 8
?GetSourceAlignment@CXboxAdpcmFilter@@SGKK@Z PROC NEAR	; CXboxAdpcmFilter::GetSourceAlignment, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   :     return nChannels * 2 * XBOX_ADPCM_SAMPLES_PER_BLOCK;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nChannels$[ebp]
  00006	d1 e0		 shl	 eax, 1
  00008	c1 e0 06	 shl	 eax, 6

; 69   : }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?GetSourceAlignment@CXboxAdpcmFilter@@SGKK@Z ENDP	; CXboxAdpcmFilter::GetSourceAlignment
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetDestinationAlignment@CXboxAdpcmFilter@@SGKK@Z
_TEXT	SEGMENT
_nChannels$ = 8
?GetDestinationAlignment@CXboxAdpcmFilter@@SGKK@Z PROC NEAR ; CXboxAdpcmFilter::GetDestinationAlignment, COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   :     return nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nChannels$[ebp]
  00006	6b c0 24	 imul	 eax, 36			; 00000024H

; 79   : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?GetDestinationAlignment@CXboxAdpcmFilter@@SGKK@Z ENDP	; CXboxAdpcmFilter::GetDestinationAlignment
_TEXT	ENDS
PUBLIC	??1CXboxAdpcmFilter@@UAE@XZ			; CXboxAdpcmFilter::~CXboxAdpcmFilter
; Function compile flags: /Odt
;	COMDAT ??_GCXboxAdpcmFilter@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCXboxAdpcmFilter@@UAEPAXI@Z PROC NEAR		; CXboxAdpcmFilter::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CXboxAdpcmFilter@@UAE@XZ ; CXboxAdpcmFilter::~CXboxAdpcmFilter
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L48858
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L48858:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCXboxAdpcmFilter@@UAEPAXI@Z ENDP			; CXboxAdpcmFilter::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPoolFree
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\memmgr.h
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 244  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  :     DirectSound::CMemoryManager::TrackingMemFree(pvBuffer); 

  00003	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPoolFree

; 246  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??1CImaAdpcmCodec@DirectSound@@UAE@XZ		; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\filter.cpp
;	COMDAT ??1CXboxAdpcmFilter@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CXboxAdpcmFilter@@UAE@XZ PROC NEAR			; CXboxAdpcmFilter::~CXboxAdpcmFilter, COMDAT
; _this$ = ecx

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CXboxAdpcmFilter@@6B@ ; CXboxAdpcmFilter::`vftable'

; 66   : }

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CImaAdpcmCodec@DirectSound@@UAE@XZ ; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CXboxAdpcmFilter@@UAE@XZ ENDP			; CXboxAdpcmFilter::~CXboxAdpcmFilter
_TEXT	ENDS
PUBLIC	?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z ; DirectSound::CImaAdpcmCodec::Initialize
PUBLIC	?ConvertFormat@CXboxAdpcmFilter@@SGHPAU_WAVEBANKMINIWAVEFORMAT@@@Z ; CXboxAdpcmFilter::ConvertFormat
; Function compile flags: /Odt
;	COMDAT ?Initialize@CXboxAdpcmFilter@@UAEHPBU_WAVEBANKMINIWAVEFORMAT@@@Z
_TEXT	SEGMENT
_pwfxSource$ = 8
_this$ = -28
_wfxDest$ = -4
_wfxExpanded$ = -24
?Initialize@CXboxAdpcmFilter@@UAEHPBU_WAVEBANKMINIWAVEFORMAT@@@Z PROC NEAR ; CXboxAdpcmFilter::Initialize, COMDAT
; _this$ = ecx

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 93   :     WAVEBANKMINIWAVEFORMAT      wfxDest     = *pwfxSource;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pwfxSource$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _wfxDest$[ebp], ecx

; 94   :     WAVEBANKUNIWAVEFORMAT       wfxExpanded;
; 95   : 
; 96   :     if(!ConvertFormat(&wfxDest))

  00011	8d 55 fc	 lea	 edx, DWORD PTR _wfxDest$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?ConvertFormat@CXboxAdpcmFilter@@SGHPAU_WAVEBANKMINIWAVEFORMAT@@@Z ; CXboxAdpcmFilter::ConvertFormat
  0001a	85 c0		 test	 eax, eax
  0001c	75 04		 jne	 SHORT $L48869

; 97   :     {
; 98   :         return FALSE;

  0001e	33 c0		 xor	 eax, eax
  00020	eb 23		 jmp	 SHORT $L48866
$L48869:

; 99   :     }
; 100  : 
; 101  :     if(!WaveBankExpandFormat(&wfxDest, &wfxExpanded))

  00022	8d 45 e8	 lea	 eax, DWORD PTR _wfxExpanded$[ebp]
  00025	50		 push	 eax
  00026	8d 4d fc	 lea	 ecx, DWORD PTR _wfxDest$[ebp]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 _WaveBankExpandFormat@8
  0002f	85 c0		 test	 eax, eax
  00031	75 04		 jne	 SHORT $L48870

; 102  :     {
; 103  :         return FALSE;

  00033	33 c0		 xor	 eax, eax
  00035	eb 0e		 jmp	 SHORT $L48866
$L48870:

; 104  :     }
; 105  : 
; 106  :     return CImaAdpcmCodec::Initialize(&wfxExpanded.AdpcmWaveFormat, TRUE);

  00037	6a 01		 push	 1
  00039	8d 55 e8	 lea	 edx, DWORD PTR _wfxExpanded$[ebp]
  0003c	52		 push	 edx
  0003d	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z ; DirectSound::CImaAdpcmCodec::Initialize
$L48866:

; 107  : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?Initialize@CXboxAdpcmFilter@@UAEHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ENDP ; CXboxAdpcmFilter::Initialize
_TEXT	ENDS
PUBLIC	?IsValidFormat@CXboxAdpcmFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ; CXboxAdpcmFilter::IsValidFormat
; Function compile flags: /Odt
;	COMDAT ?IsValidFormat@CXboxAdpcmFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z
_TEXT	SEGMENT
_pwfxFormat$ = 8
?IsValidFormat@CXboxAdpcmFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z PROC NEAR ; CXboxAdpcmFilter::IsValidFormat, COMDAT

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 134  :     if(WAVEBANKMINIFORMAT_TAG_PCM != pwfxFormat->wFormatTag)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	83 e1 01	 and	 ecx, 1
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 04		 je	 SHORT $L48874

; 135  :     {
; 136  :         return FALSE;

  0000f	33 c0		 xor	 eax, eax
  00011	eb 3b		 jmp	 SHORT $L48873
$L48874:

; 137  :     }
; 138  : 
; 139  :     if((pwfxFormat->nChannels < 1) || (pwfxFormat->nChannels > 2))

  00013	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  00016	8b 02		 mov	 eax, DWORD PTR [edx]
  00018	d1 e8		 shr	 eax, 1
  0001a	83 e0 07	 and	 eax, 7
  0001d	83 f8 01	 cmp	 eax, 1
  00020	72 0f		 jb	 SHORT $L48876
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _pwfxFormat$[ebp]
  00025	8b 11		 mov	 edx, DWORD PTR [ecx]
  00027	d1 ea		 shr	 edx, 1
  00029	83 e2 07	 and	 edx, 7
  0002c	83 fa 02	 cmp	 edx, 2
  0002f	76 04		 jbe	 SHORT $L48875
$L48876:

; 140  :     {
; 141  :         return FALSE;

  00031	33 c0		 xor	 eax, eax
  00033	eb 19		 jmp	 SHORT $L48873
$L48875:

; 142  :     }
; 143  : 
; 144  :     if(WAVEBANKMINIFORMAT_BITDEPTH_16 != pwfxFormat->wBitsPerSample)

  00035	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0003d	83 e1 01	 and	 ecx, 1
  00040	83 f9 01	 cmp	 ecx, 1
  00043	74 04		 je	 SHORT $L48877

; 145  :     {
; 146  :         return FALSE;

  00045	33 c0		 xor	 eax, eax
  00047	eb 05		 jmp	 SHORT $L48873
$L48877:

; 147  :     }
; 148  : 
; 149  :     return TRUE;

  00049	b8 01 00 00 00	 mov	 eax, 1
$L48873:

; 150  : }

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
?IsValidFormat@CXboxAdpcmFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ENDP ; CXboxAdpcmFilter::IsValidFormat
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?ConvertFormat@CXboxAdpcmFilter@@SGHPAU_WAVEBANKMINIWAVEFORMAT@@@Z
_TEXT	SEGMENT
_pwfxFormat$ = 8
?ConvertFormat@CXboxAdpcmFilter@@SGHPAU_WAVEBANKMINIWAVEFORMAT@@@Z PROC NEAR ; CXboxAdpcmFilter::ConvertFormat, COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 177  :     if(!IsValidFormat(pwfxFormat))

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?IsValidFormat@CXboxAdpcmFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ; CXboxAdpcmFilter::IsValidFormat
  0000c	85 c0		 test	 eax, eax
  0000e	75 04		 jne	 SHORT $L48881

; 178  :     {
; 179  :         return FALSE;

  00010	33 c0		 xor	 eax, eax
  00012	eb 22		 jmp	 SHORT $L48880
$L48881:

; 180  :     }
; 181  : 
; 182  :     pwfxFormat->wFormatTag = WAVEBANKMINIFORMAT_TAG_ADPCM;

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pwfxFormat$[ebp]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	83 ca 01	 or	 edx, 1
  0001c	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  0001f	89 10		 mov	 DWORD PTR [eax], edx

; 183  :     pwfxFormat->wBitsPerSample = WAVEBANKMINIFORMAT_BITDEPTH_4;

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _pwfxFormat$[ebp]
  00024	8b 11		 mov	 edx, DWORD PTR [ecx]
  00026	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  0002c	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  0002f	89 10		 mov	 DWORD PTR [eax], edx

; 184  : 
; 185  :     return TRUE;

  00031	b8 01 00 00 00	 mov	 eax, 1
$L48880:

; 186  : }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?ConvertFormat@CXboxAdpcmFilter@@SGHPAU_WAVEBANKMINIWAVEFORMAT@@@Z ENDP ; CXboxAdpcmFilter::ConvertFormat
_TEXT	ENDS
PUBLIC	?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z ; DirectSound::CImaAdpcmCodec::Convert
; Function compile flags: /Odt
;	COMDAT ?Convert@CXboxAdpcmFilter@@UAEHPBXPAKPAX1@Z
_TEXT	SEGMENT
_pvSource$ = 8
_pcbSource$ = 12
_pvDest$ = 16
_pcbDest$ = 20
_this$ = -8
_cBlocks$ = -4
?Convert@CXboxAdpcmFilter@@UAEHPBXPAKPAX1@Z PROC NEAR	; CXboxAdpcmFilter::Convert, COMDAT
; _this$ = ecx

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 219  :     DWORD                   cBlocks;
; 220  : 
; 221  :     //
; 222  :     // Convert byte sizes to blocks
; 223  :     //
; 224  : 
; 225  :     *pcbSource /= m_wfxEncode.wfx.nChannels * 2 * XBOX_ADPCM_SAMPLES_PER_BLOCK;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	33 c9		 xor	 ecx, ecx
  0000e	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  00012	d1 e1		 shl	 ecx, 1
  00014	c1 e1 06	 shl	 ecx, 6
  00017	8b 55 0c	 mov	 edx, DWORD PTR _pcbSource$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	33 d2		 xor	 edx, edx
  0001e	f7 f1		 div	 ecx
  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _pcbSource$[ebp]
  00023	89 01		 mov	 DWORD PTR [ecx], eax

; 226  :     *pcbDest /= m_wfxEncode.wfx.nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  00025	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00028	33 c0		 xor	 eax, eax
  0002a	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  0002e	8b c8		 mov	 ecx, eax
  00030	6b c9 24	 imul	 ecx, 36			; 00000024H
  00033	8b 55 14	 mov	 edx, DWORD PTR _pcbDest$[ebp]
  00036	8b 02		 mov	 eax, DWORD PTR [edx]
  00038	33 d2		 xor	 edx, edx
  0003a	f7 f1		 div	 ecx
  0003c	8b 4d 14	 mov	 ecx, DWORD PTR _pcbDest$[ebp]
  0003f	89 01		 mov	 DWORD PTR [ecx], eax

; 227  :     
; 228  :     cBlocks = min(*pcbSource, *pcbDest);

  00041	8b 55 0c	 mov	 edx, DWORD PTR _pcbSource$[ebp]
  00044	8b 45 14	 mov	 eax, DWORD PTR _pcbDest$[ebp]
  00047	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00049	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0004b	73 0a		 jae	 SHORT $L51433
  0004d	8b 55 0c	 mov	 edx, DWORD PTR _pcbSource$[ebp]
  00050	8b 02		 mov	 eax, DWORD PTR [edx]
  00052	89 45 f4	 mov	 DWORD PTR -12+[ebp], eax
  00055	eb 08		 jmp	 SHORT $L51434
$L51433:
  00057	8b 4d 14	 mov	 ecx, DWORD PTR _pcbDest$[ebp]
  0005a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005c	89 55 f4	 mov	 DWORD PTR -12+[ebp], edx
$L51434:
  0005f	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]
  00062	89 45 fc	 mov	 DWORD PTR _cBlocks$[ebp], eax

; 229  : 
; 230  :     *pcbSource = cBlocks * m_wfxEncode.wfx.nChannels * 2 * XBOX_ADPCM_SAMPLES_PER_BLOCK;

  00065	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	33 d2		 xor	 edx, edx
  0006a	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  0006e	8b 45 fc	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00071	0f af c2	 imul	 eax, edx
  00074	d1 e0		 shl	 eax, 1
  00076	c1 e0 06	 shl	 eax, 6
  00079	8b 4d 0c	 mov	 ecx, DWORD PTR _pcbSource$[ebp]
  0007c	89 01		 mov	 DWORD PTR [ecx], eax

; 231  :     *pcbDest = cBlocks * m_wfxEncode.wfx.nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  0007e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00081	33 c0		 xor	 eax, eax
  00083	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  0008a	0f af c8	 imul	 ecx, eax
  0008d	6b c9 24	 imul	 ecx, 36			; 00000024H
  00090	8b 55 14	 mov	 edx, DWORD PTR _pcbDest$[ebp]
  00093	89 0a		 mov	 DWORD PTR [edx], ecx

; 232  : 
; 233  :     //
; 234  :     // Convert data
; 235  :     //
; 236  : 
; 237  :     return CImaAdpcmCodec::Convert(pvSource, pvDest, cBlocks);

  00095	8b 45 fc	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00098	50		 push	 eax
  00099	8b 4d 10	 mov	 ecx, DWORD PTR _pvDest$[ebp]
  0009c	51		 push	 ecx
  0009d	8b 55 08	 mov	 edx, DWORD PTR _pvSource$[ebp]
  000a0	52		 push	 edx
  000a1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	e8 00 00 00 00	 call	 ?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z ; DirectSound::CImaAdpcmCodec::Convert

; 238  : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 10 00	 ret	 16			; 00000010H
?Convert@CXboxAdpcmFilter@@UAEHPBXPAKPAX1@Z ENDP	; CXboxAdpcmFilter::Convert
_TEXT	ENDS
PUBLIC	??0C8BitFilter@@QAE@XZ				; C8BitFilter::C8BitFilter
PUBLIC	?Initialize@C8BitFilter@@UAEHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ; C8BitFilter::Initialize
PUBLIC	?GetSourceAlignment@C8BitFilter@@UAEKXZ		; C8BitFilter::GetSourceAlignment
PUBLIC	?GetDestinationAlignment@C8BitFilter@@UAEKXZ	; C8BitFilter::GetDestinationAlignment
PUBLIC	?GetSize@C8BitFilter@@UAEKK@Z			; C8BitFilter::GetSize
PUBLIC	?Convert@C8BitFilter@@UAEHPBXPAKPAX1@Z		; C8BitFilter::Convert
PUBLIC	??_7C8BitFilter@@6B@				; C8BitFilter::`vftable'
PUBLIC	??_GC8BitFilter@@UAEPAXI@Z			; C8BitFilter::`scalar deleting destructor'
PUBLIC	??_EC8BitFilter@@UAEPAXI@Z			; C8BitFilter::`vector deleting destructor'
;	COMDAT ??_7C8BitFilter@@6B@
CONST	SEGMENT
??_7C8BitFilter@@6B@ DD FLAT:??_EC8BitFilter@@UAEPAXI@Z	; C8BitFilter::`vftable'
	DD	FLAT:?Initialize@C8BitFilter@@UAEHPBU_WAVEBANKMINIWAVEFORMAT@@@Z
	DD	FLAT:?GetSourceAlignment@C8BitFilter@@UAEKXZ
	DD	FLAT:?GetDestinationAlignment@C8BitFilter@@UAEKXZ
	DD	FLAT:?GetSize@C8BitFilter@@UAEKK@Z
	DD	FLAT:?Convert@C8BitFilter@@UAEHPBXPAKPAX1@Z
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0C8BitFilter@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0C8BitFilter@@QAE@XZ PROC NEAR			; C8BitFilter::C8BitFilter, COMDAT
; _this$ = ecx

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7C8BitFilter@@6B@ ; C8BitFilter::`vftable'

; 264  : }

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0C8BitFilter@@QAE@XZ ENDP				; C8BitFilter::C8BitFilter
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\filter.h
_TEXT	ENDS
;	COMDAT ?GetSourceAlignment@C8BitFilter@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4
?GetSourceAlignment@C8BitFilter@@UAEKXZ PROC NEAR	; C8BitFilter::GetSourceAlignment, COMDAT
; _this$ = ecx

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 155  :     return m_nChannels * 2;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	d1 e0		 shl	 eax, 1

; 156  : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetSourceAlignment@C8BitFilter@@UAEKXZ ENDP		; C8BitFilter::GetSourceAlignment
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetDestinationAlignment@C8BitFilter@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4
?GetDestinationAlignment@C8BitFilter@@UAEKXZ PROC NEAR	; C8BitFilter::GetDestinationAlignment, COMDAT
; _this$ = ecx

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 165  :     return m_nChannels;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 166  : }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetDestinationAlignment@C8BitFilter@@UAEKXZ ENDP	; C8BitFilter::GetDestinationAlignment
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetSize@C8BitFilter@@UAEKK@Z
_TEXT	SEGMENT
_cbSource$ = 8
_this$ = -4
?GetSize@C8BitFilter@@UAEKK@Z PROC NEAR			; C8BitFilter::GetSize, COMDAT
; _this$ = ecx

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 175  :     return cbSource / (m_nChannels * 2) * m_nChannels;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	d1 e1		 shl	 ecx, 1
  0000f	8b 45 08	 mov	 eax, DWORD PTR _cbSource$[ebp]
  00012	33 d2		 xor	 edx, edx
  00014	f7 f1		 div	 ecx
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	0f af 42 04	 imul	 eax, DWORD PTR [edx+4]

; 176  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?GetSize@C8BitFilter@@UAEKK@Z ENDP			; C8BitFilter::GetSize
_TEXT	ENDS
PUBLIC	??1C8BitFilter@@UAE@XZ				; C8BitFilter::~C8BitFilter
; Function compile flags: /Odt
;	COMDAT ??_GC8BitFilter@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GC8BitFilter@@UAEPAXI@Z PROC NEAR			; C8BitFilter::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1C8BitFilter@@UAE@XZ	; C8BitFilter::~C8BitFilter
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L48897
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L48897:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GC8BitFilter@@UAEPAXI@Z ENDP				; C8BitFilter::`scalar deleting destructor'
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\filter.cpp
_TEXT	ENDS
;	COMDAT ??1C8BitFilter@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1C8BitFilter@@UAE@XZ PROC NEAR			; C8BitFilter::~C8BitFilter, COMDAT
; _this$ = ecx

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7C8BitFilter@@6B@ ; C8BitFilter::`vftable'

; 290  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1C8BitFilter@@UAE@XZ ENDP				; C8BitFilter::~C8BitFilter
_TEXT	ENDS
PUBLIC	?IsValidFormat@C8BitFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ; C8BitFilter::IsValidFormat
; Function compile flags: /Odt
;	COMDAT ?Initialize@C8BitFilter@@UAEHPBU_WAVEBANKMINIWAVEFORMAT@@@Z
_TEXT	SEGMENT
_pwfxSource$ = 8
_this$ = -4
?Initialize@C8BitFilter@@UAEHPBU_WAVEBANKMINIWAVEFORMAT@@@Z PROC NEAR ; C8BitFilter::Initialize, COMDAT
; _this$ = ecx

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 317  :     if(!IsValidFormat(pwfxSource))

  00007	8b 45 08	 mov	 eax, DWORD PTR _pwfxSource$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?IsValidFormat@C8BitFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ; C8BitFilter::IsValidFormat
  00010	85 c0		 test	 eax, eax
  00012	75 04		 jne	 SHORT $L48906

; 318  :     {
; 319  :         return FALSE;

  00014	33 c0		 xor	 eax, eax
  00016	eb 15		 jmp	 SHORT $L48905
$L48906:

; 320  :     }
; 321  :     
; 322  :     m_nChannels = pwfxSource->nChannels;

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _pwfxSource$[ebp]
  0001b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001d	d1 ea		 shr	 edx, 1
  0001f	83 e2 07	 and	 edx, 7
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 323  :     
; 324  :     return TRUE;

  00028	b8 01 00 00 00	 mov	 eax, 1
$L48905:

; 325  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?Initialize@C8BitFilter@@UAEHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ENDP ; C8BitFilter::Initialize
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsValidFormat@C8BitFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z
_TEXT	SEGMENT
_pwfxFormat$ = 8
?IsValidFormat@C8BitFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z PROC NEAR ; C8BitFilter::IsValidFormat, COMDAT

; 351  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 352  :     if(WAVEBANKMINIFORMAT_TAG_PCM != pwfxFormat->wFormatTag)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	83 e1 01	 and	 ecx, 1
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 04		 je	 SHORT $L48910

; 353  :     {
; 354  :         return FALSE;

  0000f	33 c0		 xor	 eax, eax
  00011	eb 19		 jmp	 SHORT $L48909
$L48910:

; 355  :     }
; 356  : 
; 357  :     if(WAVEBANKMINIFORMAT_BITDEPTH_16 != pwfxFormat->wBitsPerSample)

  00013	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  00016	8b 02		 mov	 eax, DWORD PTR [edx]
  00018	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001b	83 e0 01	 and	 eax, 1
  0001e	83 f8 01	 cmp	 eax, 1
  00021	74 04		 je	 SHORT $L48911

; 358  :     {
; 359  :         return FALSE;

  00023	33 c0		 xor	 eax, eax
  00025	eb 05		 jmp	 SHORT $L48909
$L48911:

; 360  :     }
; 361  : 
; 362  :     return TRUE;

  00027	b8 01 00 00 00	 mov	 eax, 1
$L48909:

; 363  : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?IsValidFormat@C8BitFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ENDP ; C8BitFilter::IsValidFormat
_TEXT	ENDS
PUBLIC	?ConvertFormat@C8BitFilter@@SGHPAU_WAVEBANKMINIWAVEFORMAT@@@Z ; C8BitFilter::ConvertFormat
; Function compile flags: /Odt
;	COMDAT ?ConvertFormat@C8BitFilter@@SGHPAU_WAVEBANKMINIWAVEFORMAT@@@Z
_TEXT	SEGMENT
_pwfxFormat$ = 8
?ConvertFormat@C8BitFilter@@SGHPAU_WAVEBANKMINIWAVEFORMAT@@@Z PROC NEAR ; C8BitFilter::ConvertFormat, COMDAT

; 389  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 390  :     if(!IsValidFormat(pwfxFormat))

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?IsValidFormat@C8BitFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ; C8BitFilter::IsValidFormat
  0000c	85 c0		 test	 eax, eax
  0000e	75 04		 jne	 SHORT $L48915

; 391  :     {
; 392  :         return FALSE;

  00010	33 c0		 xor	 eax, eax
  00012	eb 15		 jmp	 SHORT $L48914
$L48915:

; 393  :     }
; 394  : 
; 395  :     pwfxFormat->wBitsPerSample = WAVEBANKMINIFORMAT_BITDEPTH_8;

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pwfxFormat$[ebp]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  0001f	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  00022	89 10		 mov	 DWORD PTR [eax], edx

; 396  : 
; 397  :     return TRUE;

  00024	b8 01 00 00 00	 mov	 eax, 1
$L48914:

; 398  : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?ConvertFormat@C8BitFilter@@SGHPAU_WAVEBANKMINIWAVEFORMAT@@@Z ENDP ; C8BitFilter::ConvertFormat
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Convert@C8BitFilter@@UAEHPBXPAKPAX1@Z
_TEXT	SEGMENT
_pvSource$ = 8
_pcbSource$ = 12
_pvDest$ = 16
_pcbDest$ = 20
_this$ = -20
_psSource$ = -4
_pbDest$ = -12
_cSamples$ = -8
_dwSample$ = -16
?Convert@C8BitFilter@@UAEHPBXPAKPAX1@Z PROC NEAR	; C8BitFilter::Convert, COMDAT
; _this$ = ecx

; 430  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 431  :     const short *           psSource    = (const short *)pvSource;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pvSource$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _psSource$[ebp], eax

; 432  :     unsigned char *         pbDest      = (unsigned char *)pvDest;

  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _pvDest$[ebp]
  00012	89 4d f4	 mov	 DWORD PTR _pbDest$[ebp], ecx

; 433  :     DWORD                   cSamples;
; 434  :     DWORD                   dwSample;
; 435  : 
; 436  :     //
; 437  :     // Convert byte sizes to samples
; 438  :     //
; 439  : 
; 440  :     *pcbSource /= m_nChannels * 2;

  00015	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0001b	d1 e1		 shl	 ecx, 1
  0001d	8b 55 0c	 mov	 edx, DWORD PTR _pcbSource$[ebp]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	33 d2		 xor	 edx, edx
  00024	f7 f1		 div	 ecx
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _pcbSource$[ebp]
  00029	89 01		 mov	 DWORD PTR [ecx], eax

; 441  :     *pcbDest /= m_nChannels;

  0002b	8b 55 14	 mov	 edx, DWORD PTR _pcbDest$[ebp]
  0002e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	8b 02		 mov	 eax, DWORD PTR [edx]
  00033	33 d2		 xor	 edx, edx
  00035	f7 71 04	 div	 DWORD PTR [ecx+4]
  00038	8b 55 14	 mov	 edx, DWORD PTR _pcbDest$[ebp]
  0003b	89 02		 mov	 DWORD PTR [edx], eax

; 442  :     
; 443  :     cSamples = min(*pcbSource, *pcbDest);

  0003d	8b 45 0c	 mov	 eax, DWORD PTR _pcbSource$[ebp]
  00040	8b 4d 14	 mov	 ecx, DWORD PTR _pcbDest$[ebp]
  00043	8b 10		 mov	 edx, DWORD PTR [eax]
  00045	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00047	73 0a		 jae	 SHORT $L51465
  00049	8b 45 0c	 mov	 eax, DWORD PTR _pcbSource$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	89 4d e8	 mov	 DWORD PTR -24+[ebp], ecx
  00051	eb 08		 jmp	 SHORT $L51466
$L51465:
  00053	8b 55 14	 mov	 edx, DWORD PTR _pcbDest$[ebp]
  00056	8b 02		 mov	 eax, DWORD PTR [edx]
  00058	89 45 e8	 mov	 DWORD PTR -24+[ebp], eax
$L51466:
  0005b	8b 4d e8	 mov	 ecx, DWORD PTR -24+[ebp]
  0005e	89 4d f8	 mov	 DWORD PTR _cSamples$[ebp], ecx

; 444  : 
; 445  :     *pcbSource = cSamples * m_nChannels * 2;

  00061	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00064	8b 45 f8	 mov	 eax, DWORD PTR _cSamples$[ebp]
  00067	0f af 42 04	 imul	 eax, DWORD PTR [edx+4]
  0006b	d1 e0		 shl	 eax, 1
  0006d	8b 4d 0c	 mov	 ecx, DWORD PTR _pcbSource$[ebp]
  00070	89 01		 mov	 DWORD PTR [ecx], eax

; 446  :     *pcbDest = cSamples * m_nChannels;

  00072	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00075	8b 45 f8	 mov	 eax, DWORD PTR _cSamples$[ebp]
  00078	0f af 42 04	 imul	 eax, DWORD PTR [edx+4]
  0007c	8b 4d 14	 mov	 ecx, DWORD PTR _pcbDest$[ebp]
  0007f	89 01		 mov	 DWORD PTR [ecx], eax

; 447  : 
; 448  :     //
; 449  :     // Convert data
; 450  :     //
; 451  : 
; 452  :     cSamples *= m_nChannels;

  00081	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00084	8b 45 f8	 mov	 eax, DWORD PTR _cSamples$[ebp]
  00087	0f af 42 04	 imul	 eax, DWORD PTR [edx+4]
  0008b	89 45 f8	 mov	 DWORD PTR _cSamples$[ebp], eax
$L48930:

; 453  :     
; 454  :     while(cSamples--)

  0008e	8b 4d f8	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  00091	8b 55 f8	 mov	 edx, DWORD PTR _cSamples$[ebp]
  00094	83 ea 01	 sub	 edx, 1
  00097	89 55 f8	 mov	 DWORD PTR _cSamples$[ebp], edx
  0009a	85 c9		 test	 ecx, ecx
  0009c	74 2e		 je	 SHORT $L48931

; 455  :     {
; 456  :         dwSample = *psSource + 32768;

  0009e	8b 45 fc	 mov	 eax, DWORD PTR _psSource$[ebp]
  000a1	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000a4	81 c1 00 80 00
	00		 add	 ecx, 32768		; 00008000H
  000aa	89 4d f0	 mov	 DWORD PTR _dwSample$[ebp], ecx

; 457  :         *pbDest = (BYTE)(dwSample >> 8);

  000ad	8b 55 f0	 mov	 edx, DWORD PTR _dwSample$[ebp]
  000b0	c1 ea 08	 shr	 edx, 8
  000b3	8b 45 f4	 mov	 eax, DWORD PTR _pbDest$[ebp]
  000b6	88 10		 mov	 BYTE PTR [eax], dl

; 458  : 
; 459  :         pbDest++;

  000b8	8b 4d f4	 mov	 ecx, DWORD PTR _pbDest$[ebp]
  000bb	83 c1 01	 add	 ecx, 1
  000be	89 4d f4	 mov	 DWORD PTR _pbDest$[ebp], ecx

; 460  :         psSource++;

  000c1	8b 55 fc	 mov	 edx, DWORD PTR _psSource$[ebp]
  000c4	83 c2 02	 add	 edx, 2
  000c7	89 55 fc	 mov	 DWORD PTR _psSource$[ebp], edx

; 461  :     }

  000ca	eb c2		 jmp	 SHORT $L48930
$L48931:

; 462  : 
; 463  :     return TRUE;

  000cc	b8 01 00 00 00	 mov	 eax, 1

; 464  : }

  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c2 10 00	 ret	 16			; 00000010H
?Convert@C8BitFilter@@UAEHPBXPAKPAX1@Z ENDP		; C8BitFilter::Convert
_TEXT	ENDS
PUBLIC	?MakeHeaderString@@YGXPAD@Z			; MakeHeaderString
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\writer.cpp
;	COMDAT ?MakeHeaderString@@YGXPAD@Z
_TEXT	SEGMENT
_pszString$ = 8
?MakeHeaderString@@YGXPAD@Z PROC NEAR			; MakeHeaderString, COMDAT

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L48938:

; 41   :     while(*pszString)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pszString$[ebp]
  00006	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00009	85 c9		 test	 ecx, ecx
  0000b	74 67		 je	 SHORT $L48939

; 42   :     {
; 43   :         if((*pszString >= 'a') && (*pszString <= 'z'))

  0000d	8b 55 08	 mov	 edx, DWORD PTR _pszString$[ebp]
  00010	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00013	83 f8 61	 cmp	 eax, 97			; 00000061H
  00016	7c 1b		 jl	 SHORT $L48940
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _pszString$[ebp]
  0001b	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0001e	83 fa 7a	 cmp	 edx, 122		; 0000007aH
  00021	7f 10		 jg	 SHORT $L48940

; 44   :         {
; 45   :             *pszString = 'A' + *pszString - 'a';

  00023	8b 45 08	 mov	 eax, DWORD PTR _pszString$[ebp]
  00026	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00029	83 e9 20	 sub	 ecx, 32			; 00000020H
  0002c	8b 55 08	 mov	 edx, DWORD PTR _pszString$[ebp]
  0002f	88 0a		 mov	 BYTE PTR [edx], cl

; 46   :         }
; 47   :         else if((*pszString >= 'A') && (*pszString <= 'Z'))

  00031	eb 36		 jmp	 SHORT $L48941
$L48940:
  00033	8b 45 08	 mov	 eax, DWORD PTR _pszString$[ebp]
  00036	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00039	83 f9 41	 cmp	 ecx, 65			; 00000041H
  0003c	7c 0d		 jl	 SHORT $L48942
  0003e	8b 55 08	 mov	 edx, DWORD PTR _pszString$[ebp]
  00041	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00044	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  00047	7f 02		 jg	 SHORT $L48942

; 48   :         {
; 49   :         }
; 50   :         else if((*pszString >= '0') && (*pszString <= '9'))

  00049	eb 1e		 jmp	 SHORT $L48943
$L48942:
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _pszString$[ebp]
  0004e	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00051	83 fa 30	 cmp	 edx, 48			; 00000030H
  00054	7c 0d		 jl	 SHORT $L48944
  00056	8b 45 08	 mov	 eax, DWORD PTR _pszString$[ebp]
  00059	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0005c	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0005f	7f 02		 jg	 SHORT $L48944

; 51   :         {
; 52   :         }
; 53   :         else

  00061	eb 06		 jmp	 SHORT $L48945
$L48944:

; 54   :         {
; 55   :             *pszString = '_';

  00063	8b 55 08	 mov	 edx, DWORD PTR _pszString$[ebp]
  00066	c6 02 5f	 mov	 BYTE PTR [edx], 95	; 0000005fH
$L48945:
$L48943:
$L48941:

; 56   :         }
; 57   : 
; 58   :         pszString++;

  00069	8b 45 08	 mov	 eax, DWORD PTR _pszString$[ebp]
  0006c	83 c0 01	 add	 eax, 1
  0006f	89 45 08	 mov	 DWORD PTR _pszString$[ebp], eax

; 59   :     }

  00072	eb 8f		 jmp	 SHORT $L48938
$L48939:

; 60   : }

  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
?MakeHeaderString@@YGXPAD@Z ENDP			; MakeHeaderString
_TEXT	ENDS
PUBLIC	?ExtractDirectory@@YGPADPAD0@Z			; ExtractDirectory
; Function compile flags: /Odt
;	COMDAT ?ExtractDirectory@@YGPADPAD0@Z
_TEXT	SEGMENT
_pszSrc$ = 8
_pszDst$ = 12
?ExtractDirectory@@YGPADPAD0@Z PROC NEAR		; ExtractDirectory, COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     if('\\' == *pszSrc)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00006	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00009	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  0000c	75 09		 jne	 SHORT $L48950

; 90   :     {
; 91   :         pszSrc++;

  0000e	8b 55 08	 mov	 edx, DWORD PTR _pszSrc$[ebp]
  00011	83 c2 01	 add	 edx, 1
  00014	89 55 08	 mov	 DWORD PTR _pszSrc$[ebp], edx
$L48950:
$L48952:

; 92   :     }
; 93   : 
; 94   :     while(TRUE)

  00017	b8 01 00 00 00	 mov	 eax, 1
  0001c	85 c0		 test	 eax, eax
  0001e	74 46		 je	 SHORT $L48953

; 95   :     {
; 96   :         if('\\' == *pszSrc)

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _pszSrc$[ebp]
  00023	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00026	83 fa 5c	 cmp	 edx, 92			; 0000005cH
  00029	75 11		 jne	 SHORT $L48954

; 97   :         {
; 98   :             *pszDst = 0;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _pszDst$[ebp]
  0002e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 99   :             pszSrc++;

  00031	8b 4d 08	 mov	 ecx, DWORD PTR _pszSrc$[ebp]
  00034	83 c1 01	 add	 ecx, 1
  00037	89 4d 08	 mov	 DWORD PTR _pszSrc$[ebp], ecx

; 100  :             break;

  0003a	eb 2a		 jmp	 SHORT $L48953
$L48954:

; 101  :         }
; 102  :         
; 103  :         *pszDst = *pszSrc;

  0003c	8b 55 0c	 mov	 edx, DWORD PTR _pszDst$[ebp]
  0003f	8b 45 08	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00042	8a 08		 mov	 cl, BYTE PTR [eax]
  00044	88 0a		 mov	 BYTE PTR [edx], cl

; 104  : 
; 105  :         if(!*pszDst)

  00046	8b 55 0c	 mov	 edx, DWORD PTR _pszDst$[ebp]
  00049	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0004c	85 c0		 test	 eax, eax
  0004e	75 02		 jne	 SHORT $L48955

; 106  :         {
; 107  :             break;

  00050	eb 14		 jmp	 SHORT $L48953
$L48955:

; 108  :         }
; 109  : 
; 110  :         pszDst++;

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _pszDst$[ebp]
  00055	83 c1 01	 add	 ecx, 1
  00058	89 4d 0c	 mov	 DWORD PTR _pszDst$[ebp], ecx

; 111  :         pszSrc++;

  0005b	8b 55 08	 mov	 edx, DWORD PTR _pszSrc$[ebp]
  0005e	83 c2 01	 add	 edx, 1
  00061	89 55 08	 mov	 DWORD PTR _pszSrc$[ebp], edx

; 112  :     }

  00064	eb b1		 jmp	 SHORT $L48952
$L48953:

; 113  : 
; 114  :     return pszSrc;

  00066	8b 45 08	 mov	 eax, DWORD PTR _pszSrc$[ebp]

; 115  : }

  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
?ExtractDirectory@@YGPADPAD0@Z ENDP			; ExtractDirectory
_TEXT	ENDS
PUBLIC	?GetRelativePath@@YGXPBD0PAD@Z			; GetRelativePath
PUBLIC	??_C@_03NLLK@?4?4?2?$AA@			; `string'
EXTRN	__imp__GetFullPathNameA@16:NEAR
EXTRN	_strcpy:NEAR
EXTRN	_strcat:NEAR
EXTRN	__stricmp:NEAR
;	COMDAT ??_C@_03NLLK@?4?4?2?$AA@
CONST	SEGMENT
??_C@_03NLLK@?4?4?2?$AA@ DB '..\', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetRelativePath@@YGXPBD0PAD@Z
_TEXT	SEGMENT
_pszInputParentPath$ = 8
_pszInputChildPath$ = 12
_pszRelativePath$ = 16
_fSuccess$ = -812
_szParentPath$ = -800
_szChildPath$ = -264
_szParentPart$ = -528
_szChildPart$ = -1080
_pszParentPath$ = -804
_pszChildPath$ = -532
_pszParentTemp$ = -536
_pszChildTemp$ = -808
?GetRelativePath@@YGXPBD0PAD@Z PROC NEAR		; GetRelativePath, COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 04 00
	00		 sub	 esp, 1084		; 0000043cH

; 146  :     BOOL                    fSuccess                = TRUE;

  00009	c7 85 d4 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _fSuccess$[ebp], 1

; 147  :     CHAR                    szParentPath[MAX_PATH];
; 148  :     CHAR                    szChildPath[MAX_PATH];
; 149  :     CHAR                    szParentPart[MAX_PATH];
; 150  :     CHAR                    szChildPart[MAX_PATH];
; 151  :     LPSTR                   pszParentPath;
; 152  :     LPSTR                   pszChildPath;
; 153  :     LPSTR                   pszParentTemp;
; 154  :     LPSTR                   pszChildTemp;
; 155  : 
; 156  :     *pszRelativePath = 0;

  00013	8b 45 10	 mov	 eax, DWORD PTR _pszRelativePath$[ebp]
  00016	c6 00 00	 mov	 BYTE PTR [eax], 0

; 157  : 
; 158  :     GetFullPathName(pszInputParentPath, NUMELMS(szParentPath), szParentPath, NULL);

  00019	6a 00		 push	 0
  0001b	8d 8d e0 fc ff
	ff		 lea	 ecx, DWORD PTR _szParentPath$[ebp]
  00021	51		 push	 ecx
  00022	68 04 01 00 00	 push	 260			; 00000104H
  00027	8b 55 08	 mov	 edx, DWORD PTR _pszInputParentPath$[ebp]
  0002a	52		 push	 edx
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFullPathNameA@16

; 159  :     GetFullPathName(pszInputChildPath, NUMELMS(szChildPath), szChildPath, NULL);

  00031	6a 00		 push	 0
  00033	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szChildPath$[ebp]
  00039	50		 push	 eax
  0003a	68 04 01 00 00	 push	 260			; 00000104H
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _pszInputChildPath$[ebp]
  00042	51		 push	 ecx
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFullPathNameA@16

; 160  : 
; 161  :     if((szParentPath[0] >= 'a') && (szParentPath[0] <= 'z'))

  00049	0f be 95 e0 fc
	ff ff		 movsx	 edx, BYTE PTR _szParentPath$[ebp]
  00050	83 fa 61	 cmp	 edx, 97			; 00000061H
  00053	7c 1c		 jl	 SHORT $L48970
  00055	0f be 85 e0 fc
	ff ff		 movsx	 eax, BYTE PTR _szParentPath$[ebp]
  0005c	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  0005f	7f 10		 jg	 SHORT $L48970

; 162  :     {
; 163  :         szParentPath[0] = 'A' + (szParentPath[0] - 'a');

  00061	0f be 8d e0 fc
	ff ff		 movsx	 ecx, BYTE PTR _szParentPath$[ebp]
  00068	83 e9 20	 sub	 ecx, 32			; 00000020H
  0006b	88 8d e0 fc ff
	ff		 mov	 BYTE PTR _szParentPath$[ebp], cl
$L48970:

; 164  :     }
; 165  : 
; 166  :     if((szChildPath[0] >= 'a') && (szChildPath[0] <= 'z'))

  00071	0f be 95 f8 fe
	ff ff		 movsx	 edx, BYTE PTR _szChildPath$[ebp]
  00078	83 fa 61	 cmp	 edx, 97			; 00000061H
  0007b	7c 1c		 jl	 SHORT $L48971
  0007d	0f be 85 f8 fe
	ff ff		 movsx	 eax, BYTE PTR _szChildPath$[ebp]
  00084	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00087	7f 10		 jg	 SHORT $L48971

; 167  :     {
; 168  :         szChildPath[0] = 'A' + (szChildPath[0] - 'a');

  00089	0f be 8d f8 fe
	ff ff		 movsx	 ecx, BYTE PTR _szChildPath$[ebp]
  00090	83 e9 20	 sub	 ecx, 32			; 00000020H
  00093	88 8d f8 fe ff
	ff		 mov	 BYTE PTR _szChildPath$[ebp], cl
$L48971:

; 169  :     }
; 170  : 
; 171  :     pszParentPath = szParentPath;

  00099	8d 95 e0 fc ff
	ff		 lea	 edx, DWORD PTR _szParentPath$[ebp]
  0009f	89 95 dc fc ff
	ff		 mov	 DWORD PTR _pszParentPath$[ebp], edx

; 172  :     pszChildPath = szChildPath;

  000a5	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szChildPath$[ebp]
  000ab	89 85 ec fd ff
	ff		 mov	 DWORD PTR _pszChildPath$[ebp], eax

; 173  : 
; 174  :     //
; 175  :     // If the paths aren't on the same drive, bail
; 176  :     //
; 177  : 
; 178  :     if((szParentPath[0] >= 'A') && (szParentPath[0] <= 'Z') && (':' == szParentPath[1]))

  000b1	0f be 8d e0 fc
	ff ff		 movsx	 ecx, BYTE PTR _szParentPath$[ebp]
  000b8	83 f9 41	 cmp	 ecx, 65			; 00000041H
  000bb	7c 7f		 jl	 SHORT $L48972
  000bd	0f be 95 e0 fc
	ff ff		 movsx	 edx, BYTE PTR _szParentPath$[ebp]
  000c4	83 fa 5a	 cmp	 edx, 90			; 0000005aH
  000c7	7f 73		 jg	 SHORT $L48972
  000c9	0f be 85 e1 fc
	ff ff		 movsx	 eax, BYTE PTR _szParentPath$[ebp+1]
  000d0	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  000d3	75 67		 jne	 SHORT $L48972

; 179  :     {
; 180  :         fSuccess = ((szParentPath[0] == szChildPath[0]) && (szParentPath[1] == szChildPath[1]));

  000d5	0f be 8d e0 fc
	ff ff		 movsx	 ecx, BYTE PTR _szParentPath$[ebp]
  000dc	0f be 95 f8 fe
	ff ff		 movsx	 edx, BYTE PTR _szChildPath$[ebp]
  000e3	3b ca		 cmp	 ecx, edx
  000e5	75 1e		 jne	 SHORT $L51476
  000e7	0f be 85 e1 fc
	ff ff		 movsx	 eax, BYTE PTR _szParentPath$[ebp+1]
  000ee	0f be 8d f9 fe
	ff ff		 movsx	 ecx, BYTE PTR _szChildPath$[ebp+1]
  000f5	3b c1		 cmp	 eax, ecx
  000f7	75 0c		 jne	 SHORT $L51476
  000f9	c7 85 c4 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR -1084+[ebp], 1
  00103	eb 0a		 jmp	 SHORT $L51477
$L51476:
  00105	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR -1084+[ebp], 0
$L51477:
  0010f	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR -1084+[ebp]
  00115	89 95 d4 fc ff
	ff		 mov	 DWORD PTR _fSuccess$[ebp], edx

; 181  : 
; 182  :         if(fSuccess)

  0011b	83 bd d4 fc ff
	ff 00		 cmp	 DWORD PTR _fSuccess$[ebp], 0
  00122	74 18		 je	 SHORT $L48973

; 183  :         {
; 184  :             pszParentPath = &szParentPath[2];

  00124	8d 85 e2 fc ff
	ff		 lea	 eax, DWORD PTR _szParentPath$[ebp+2]
  0012a	89 85 dc fc ff
	ff		 mov	 DWORD PTR _pszParentPath$[ebp], eax

; 185  :             pszChildPath = &szChildPath[2];

  00130	8d 8d fa fe ff
	ff		 lea	 ecx, DWORD PTR _szChildPath$[ebp+2]
  00136	89 8d ec fd ff
	ff		 mov	 DWORD PTR _pszChildPath$[ebp], ecx
$L48973:
$L48972:

; 186  :         }
; 187  :     }
; 188  : 
; 189  :     //
; 190  :     // Skip over any matching directories
; 191  :     //
; 192  : 
; 193  :     if(fSuccess)

  0013c	83 bd d4 fc ff
	ff 00		 cmp	 DWORD PTR _fSuccess$[ebp], 0
  00143	0f 84 96 00 00
	00		 je	 $L48974
$L48976:

; 194  :     {
; 195  :         while(TRUE)

  00149	ba 01 00 00 00	 mov	 edx, 1
  0014e	85 d2		 test	 edx, edx
  00150	0f 84 89 00 00
	00		 je	 $L48977

; 196  :         {
; 197  :             pszParentTemp = ExtractDirectory(pszParentPath, szParentPart);

  00156	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _szParentPart$[ebp]
  0015c	50		 push	 eax
  0015d	8b 8d dc fc ff
	ff		 mov	 ecx, DWORD PTR _pszParentPath$[ebp]
  00163	51		 push	 ecx
  00164	e8 00 00 00 00	 call	 ?ExtractDirectory@@YGPADPAD0@Z ; ExtractDirectory
  00169	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _pszParentTemp$[ebp], eax

; 198  : 
; 199  :             if(!*pszParentTemp)

  0016f	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _pszParentTemp$[ebp]
  00175	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00178	85 c0		 test	 eax, eax
  0017a	75 02		 jne	 SHORT $L48978

; 200  :             {
; 201  :                 break;

  0017c	eb 61		 jmp	 SHORT $L48977
$L48978:

; 202  :             }
; 203  : 
; 204  :             pszChildTemp = ExtractDirectory(pszChildPath, szChildPart);

  0017e	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR _szChildPart$[ebp]
  00184	51		 push	 ecx
  00185	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _pszChildPath$[ebp]
  0018b	52		 push	 edx
  0018c	e8 00 00 00 00	 call	 ?ExtractDirectory@@YGPADPAD0@Z ; ExtractDirectory
  00191	89 85 d8 fc ff
	ff		 mov	 DWORD PTR _pszChildTemp$[ebp], eax

; 205  : 
; 206  :             if(!*pszChildTemp)

  00197	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _pszChildTemp$[ebp]
  0019d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001a0	85 c9		 test	 ecx, ecx
  001a2	75 02		 jne	 SHORT $L48979

; 207  :             {
; 208  :                 break;

  001a4	eb 39		 jmp	 SHORT $L48977
$L48979:

; 209  :             }
; 210  : 
; 211  :             if(_stricmp(szParentPart, szChildPart))

  001a6	8d 95 c8 fb ff
	ff		 lea	 edx, DWORD PTR _szChildPart$[ebp]
  001ac	52		 push	 edx
  001ad	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _szParentPart$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 __stricmp
  001b9	83 c4 08	 add	 esp, 8
  001bc	85 c0		 test	 eax, eax
  001be	74 02		 je	 SHORT $L48980

; 212  :             {
; 213  :                 break;

  001c0	eb 1d		 jmp	 SHORT $L48977
$L48980:

; 214  :             }
; 215  : 
; 216  :             pszParentPath = pszParentTemp;

  001c2	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _pszParentTemp$[ebp]
  001c8	89 8d dc fc ff
	ff		 mov	 DWORD PTR _pszParentPath$[ebp], ecx

; 217  :             pszChildPath = pszChildTemp;

  001ce	8b 95 d8 fc ff
	ff		 mov	 edx, DWORD PTR _pszChildTemp$[ebp]
  001d4	89 95 ec fd ff
	ff		 mov	 DWORD PTR _pszChildPath$[ebp], edx

; 218  :         }

  001da	e9 6a ff ff ff	 jmp	 $L48976
$L48977:
$L48974:

; 219  :     }
; 220  : 
; 221  :     //
; 222  :     // For every directory that appears in the parent but not the child, add
; 223  :     // a "..\"
; 224  :     //
; 225  : 
; 226  :     if(fSuccess)

  001df	83 bd d4 fc ff
	ff 00		 cmp	 DWORD PTR _fSuccess$[ebp], 0
  001e6	0f 84 99 00 00
	00		 je	 $L48981
$L48983:

; 227  :     {
; 228  :         while(TRUE)

  001ec	b8 01 00 00 00	 mov	 eax, 1
  001f1	85 c0		 test	 eax, eax
  001f3	0f 84 8c 00 00
	00		 je	 $L48984

; 229  :         {
; 230  :             pszParentTemp = ExtractDirectory(pszParentPath, szParentPart);

  001f9	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _szParentPart$[ebp]
  001ff	51		 push	 ecx
  00200	8b 95 dc fc ff
	ff		 mov	 edx, DWORD PTR _pszParentPath$[ebp]
  00206	52		 push	 edx
  00207	e8 00 00 00 00	 call	 ?ExtractDirectory@@YGPADPAD0@Z ; ExtractDirectory
  0020c	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _pszParentTemp$[ebp], eax

; 231  : 
; 232  :             if(!*pszParentTemp)

  00212	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _pszParentTemp$[ebp]
  00218	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0021b	85 c9		 test	 ecx, ecx
  0021d	75 02		 jne	 SHORT $L48985

; 233  :             {
; 234  :                 break;

  0021f	eb 64		 jmp	 SHORT $L48984
$L48985:

; 235  :             }
; 236  : 
; 237  :             pszChildTemp = ExtractDirectory(pszChildPath, szChildPart);

  00221	8d 95 c8 fb ff
	ff		 lea	 edx, DWORD PTR _szChildPart$[ebp]
  00227	52		 push	 edx
  00228	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _pszChildPath$[ebp]
  0022e	50		 push	 eax
  0022f	e8 00 00 00 00	 call	 ?ExtractDirectory@@YGPADPAD0@Z ; ExtractDirectory
  00234	89 85 d8 fc ff
	ff		 mov	 DWORD PTR _pszChildTemp$[ebp], eax

; 238  : 
; 239  :             if(*pszChildTemp)

  0023a	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _pszChildTemp$[ebp]
  00240	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00243	85 d2		 test	 edx, edx
  00245	74 1c		 je	 SHORT $L48986

; 240  :             {
; 241  :                 if(!_stricmp(szParentPart, szChildPart))

  00247	8d 85 c8 fb ff
	ff		 lea	 eax, DWORD PTR _szChildPart$[ebp]
  0024d	50		 push	 eax
  0024e	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _szParentPart$[ebp]
  00254	51		 push	 ecx
  00255	e8 00 00 00 00	 call	 __stricmp
  0025a	83 c4 08	 add	 esp, 8
  0025d	85 c0		 test	 eax, eax
  0025f	75 02		 jne	 SHORT $L48987

; 242  :                 {
; 243  :                     break;

  00261	eb 22		 jmp	 SHORT $L48984
$L48987:
$L48986:

; 244  :                 }
; 245  :             }
; 246  : 
; 247  :             strcat(pszRelativePath, "..\\");

  00263	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03NLLK@?4?4?2?$AA@ ; `string'
  00268	8b 55 10	 mov	 edx, DWORD PTR _pszRelativePath$[ebp]
  0026b	52		 push	 edx
  0026c	e8 00 00 00 00	 call	 _strcat
  00271	83 c4 08	 add	 esp, 8

; 248  : 
; 249  :             pszParentPath = pszParentTemp;

  00274	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _pszParentTemp$[ebp]
  0027a	89 85 dc fc ff
	ff		 mov	 DWORD PTR _pszParentPath$[ebp], eax

; 250  :         }

  00280	e9 67 ff ff ff	 jmp	 $L48983
$L48984:
$L48981:

; 251  :     }
; 252  : 
; 253  :     //
; 254  :     // If anything went wrong, just copy the full child path.  If all is good,
; 255  :     // build the relative path.
; 256  :     //
; 257  :     
; 258  :     if(fSuccess)

  00285	83 bd d4 fc ff
	ff 00		 cmp	 DWORD PTR _fSuccess$[ebp], 0
  0028c	74 15		 je	 SHORT $L48989

; 259  :     {
; 260  :         strcat(pszRelativePath, pszChildPath);

  0028e	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _pszChildPath$[ebp]
  00294	51		 push	 ecx
  00295	8b 55 10	 mov	 edx, DWORD PTR _pszRelativePath$[ebp]
  00298	52		 push	 edx
  00299	e8 00 00 00 00	 call	 _strcat
  0029e	83 c4 08	 add	 esp, 8

; 261  :     }
; 262  :     else

  002a1	eb 13		 jmp	 SHORT $L48990
$L48989:

; 263  :     {
; 264  :         strcpy(pszRelativePath, szChildPath);

  002a3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szChildPath$[ebp]
  002a9	50		 push	 eax
  002aa	8b 4d 10	 mov	 ecx, DWORD PTR _pszRelativePath$[ebp]
  002ad	51		 push	 ecx
  002ae	e8 00 00 00 00	 call	 _strcpy
  002b3	83 c4 08	 add	 esp, 8
$L48990:

; 265  :     }
; 266  : }

  002b6	8b e5		 mov	 esp, ebp
  002b8	5d		 pop	 ebp
  002b9	c2 0c 00	 ret	 12			; 0000000cH
?GetRelativePath@@YGXPBD0PAD@Z ENDP			; GetRelativePath
_TEXT	ENDS
PUBLIC	?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z	; InsertTailListUninit
PUBLIC	??0CWaveBankEntry@@QAE@PAVCWaveBank@@@Z		; CWaveBankEntry::CWaveBankEntry
PUBLIC	?Initialize@CWaveBankEntry@@UAEJPBD0K@Z		; CWaveBankEntry::Initialize
PUBLIC	?SetName@CWaveBankEntry@@UAEJPBD@Z		; CWaveBankEntry::SetName
PUBLIC	?GetValidFlags@CWaveBankEntry@@UAEKXZ		; CWaveBankEntry::GetValidFlags
PUBLIC	?SetFlags@CWaveBankEntry@@UAEKKK@Z		; CWaveBankEntry::SetFlags
PUBLIC	?GetMetaData@CWaveBankEntry@@UAEJPAU_WAVEBANKENTRY@@PAK@Z ; CWaveBankEntry::GetMetaData
PUBLIC	?CommitWaveData@CWaveBankEntry@@UAEJPAVCStdFileStream@WaveLoader@@KPBU_WAVEBANKENTRY@@PAXK@Z ; CWaveBankEntry::CommitWaveData
PUBLIC	?ReadProjectData@CWaveBankEntry@@UAEJPBD0K@Z	; CWaveBankEntry::ReadProjectData
PUBLIC	?WriteProjectData@CWaveBankEntry@@UAEJPBD0K@Z	; CWaveBankEntry::WriteProjectData
PUBLIC	?LoadWaveFile@CWaveBankEntry@@MAEJXZ		; CWaveBankEntry::LoadWaveFile
PUBLIC	?FindDuplicateEntry@CWaveBankEntry@@MAEJPBDPAI01@Z ; CWaveBankEntry::FindDuplicateEntry
PUBLIC	??_7CWaveBankEntry@@6B@				; CWaveBankEntry::`vftable'
PUBLIC	??_GCWaveBankEntry@@UAEPAXI@Z			; CWaveBankEntry::`scalar deleting destructor'
PUBLIC	??_ECWaveBankEntry@@UAEPAXI@Z			; CWaveBankEntry::`vector deleting destructor'
;	COMDAT ??_7CWaveBankEntry@@6B@
CONST	SEGMENT
??_7CWaveBankEntry@@6B@ DD FLAT:??_ECWaveBankEntry@@UAEPAXI@Z ; CWaveBankEntry::`vftable'
	DD	FLAT:?Initialize@CWaveBankEntry@@UAEJPBD0K@Z
	DD	FLAT:?SetName@CWaveBankEntry@@UAEJPBD@Z
	DD	FLAT:?GetValidFlags@CWaveBankEntry@@UAEKXZ
	DD	FLAT:?SetFlags@CWaveBankEntry@@UAEKKK@Z
	DD	FLAT:?GetMetaData@CWaveBankEntry@@UAEJPAU_WAVEBANKENTRY@@PAK@Z
	DD	FLAT:?CommitWaveData@CWaveBankEntry@@UAEJPAVCStdFileStream@WaveLoader@@KPBU_WAVEBANKENTRY@@PAXK@Z
	DD	FLAT:?ReadProjectData@CWaveBankEntry@@UAEJPBD0K@Z
	DD	FLAT:?WriteProjectData@CWaveBankEntry@@UAEJPBD0K@Z
	DD	FLAT:?LoadWaveFile@CWaveBankEntry@@MAEJXZ
	DD	FLAT:?FindDuplicateEntry@CWaveBankEntry@@MAEJPBDPAI01@Z
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CWaveBankEntry@@QAE@PAVCWaveBank@@@Z
_TEXT	SEGMENT
_pParent$ = 8
_this$ = -4
??0CWaveBankEntry@@QAE@PAVCWaveBank@@@Z PROC NEAR	; CWaveBankEntry::CWaveBankEntry, COMDAT
; _this$ = ecx

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CWaveBankEntry@@6B@ ; CWaveBankEntry::`vftable'

; 292  :     DPF_ENTER();
; 293  : 
; 294  :     m_pParent = pParent;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _pParent$[ebp]
  00016	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 295  : 
; 296  :     InsertTailListUninit(&m_pParent->m_lstEntries, &m_leEntry);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00026	81 c2 38 02 00
	00		 add	 edx, 568		; 00000238H
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailListUninit

; 297  : 
; 298  :     m_pParent->m_dwEntryCount++;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8b 91 40 02 00
	00		 mov	 edx, DWORD PTR [ecx+576]
  0003e	83 c2 01	 add	 edx, 1
  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00047	89 91 40 02 00
	00		 mov	 DWORD PTR [ecx+576], edx

; 299  : 
; 300  :     DPF_LEAVE_VOID();
; 301  : }

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
??0CWaveBankEntry@@QAE@PAVCWaveBank@@@Z ENDP		; CWaveBankEntry::CWaveBankEntry
_TEXT	ENDS
PUBLIC	?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList
PUBLIC	??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
;	COMDAT ??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\common\ntlist.h
CONST	SEGMENT
??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\privat'
	DB	'e\windows\directx\dsound\common\ntlist.h', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z
_TEXT	SEGMENT
_ListHead$ = 8
_Entry$ = 12
?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z PROC NEAR	; InsertTailListUninit, COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 136  :     AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

  00003	68 88 00 00 00	 push	 136			; 00000088H
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000d	6a 00		 push	 0
  0000f	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 137  : 
; 138  :     Entry->Flink = ListHead;

  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR _ListHead$[ebp]
  0001e	89 11		 mov	 DWORD PTR [ecx], edx

; 139  :     Entry->Blink = ListHead->Blink;

  00020	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  00026	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00029	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 140  :     
; 141  :     Entry->Flink->Blink = Entry;

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00034	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 142  :     Entry->Blink->Flink = Entry;

  00037	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0003a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003d	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00040	89 11		 mov	 DWORD PTR [ecx], edx

; 143  : 
; 144  :     AssertValidEntryList(Entry, ASSERT_IN_LIST);

  00042	68 90 00 00 00	 push	 144			; 00000090H
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004c	6a 01		 push	 1
  0004e	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 145  : }    

  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ENDP	; InsertTailListUninit
_TEXT	ENDS
PUBLIC	?Assert@CDebug@DirectSound@@SAXHPBD0I@Z		; DirectSound::CDebug::Assert
PUBLIC	??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@	; `string'
PUBLIC	??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@ ; `string'
PUBLIC	??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@ ; `string'
PUBLIC	??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@	; `string'
PUBLIC	??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@	; `string'
;	COMDAT ??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@
CONST	SEGMENT
??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@ DB 'NULL list entry pointe'
	DB	'r', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@
CONST	SEGMENT
??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@ DB 'List entry conta'
	DB	'ins NULL pointer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@
CONST	SEGMENT
??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@ DB 'List entry part'
	DB	'ially points to itself', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@
CONST	SEGMENT
??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@ DB 'List entry not in list'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@
CONST	SEGMENT
??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@ DB 'List entry in list', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
_TEXT	SEGMENT
_Entry$ = 8
_nFlags$ = 12
_pszFile$ = 16
_nLine$ = 20
?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z PROC NEAR ; __AssertValidEntryList, COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   :     if(!Entry)

  00003	83 7d 08 00	 cmp	 DWORD PTR _Entry$[ebp], 0
  00007	75 1c		 jne	 SHORT $L47476

; 57   :     {
; 58   :         DirectSound::CDebug::Assert(TRUE, "NULL list entry pointer", pszFile, nLine);

  00009	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  00010	51		 push	 ecx
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@EAEP@NULL?5list?5entry?5pointer?$AA@ ; `string'
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0001d	83 c4 10	 add	 esp, 16			; 00000010H

; 59   :     }
; 60   :     else if(!Entry->Flink || !Entry->Blink)

  00020	e9 c0 00 00 00	 jmp	 $L47478
$L47476:
  00025	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  00028	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0002b	74 09		 je	 SHORT $L47480
  0002d	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	75 1c		 jne	 SHORT $L47479
$L47480:

; 61   :     {
; 62   :         DirectSound::CDebug::Assert(TRUE, "List entry contains NULL pointer", pszFile, nLine);

  00036	8b 4d 14	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  0003d	52		 push	 edx
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@DLOI@List?5entry?5contains?5NULL?5pointer@ ; `string'
  00043	6a 01		 push	 1
  00045	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0004a	83 c4 10	 add	 esp, 16			; 00000010H

; 63   :     }
; 64   :     else if((Entry == Entry->Flink) || (Entry == Entry->Blink))

  0004d	e9 93 00 00 00	 jmp	 $L47482
$L47479:
  00052	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00058	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0005a	74 0b		 je	 SHORT $L47484
  0005c	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0005f	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00062	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00065	75 2e		 jne	 SHORT $L47483
$L47484:

; 65   :     {
; 66   :         if((Entry != Entry->Flink) || (Entry != Entry->Blink))

  00067	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0006a	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0006d	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0006f	75 0b		 jne	 SHORT $L47486
  00071	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00077	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0007a	74 17		 je	 SHORT $L47485
$L47486:

; 67   :         {
; 68   :             DirectSound::CDebug::Assert(TRUE, "List entry partially points to itself", pszFile, nLine);

  0007c	8b 55 14	 mov	 edx, DWORD PTR _nLine$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 10	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00083	50		 push	 eax
  00084	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@BJAJ@List?5entry?5partially?5points?5to?5i@ ; `string'
  00089	6a 01		 push	 1
  0008b	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00090	83 c4 10	 add	 esp, 16			; 00000010H
$L47485:

; 69   :         }
; 70   :     }
; 71   :     else if(ASSERT_IN_LIST == nFlags)

  00093	eb 50		 jmp	 SHORT $L47488
$L47483:
  00095	83 7d 0c 01	 cmp	 DWORD PTR _nFlags$[ebp], 1
  00099	75 23		 jne	 SHORT $L47489

; 72   :     {
; 73   :         if(!IsEntryInList(Entry))

  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0009e	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  000a1	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000a3	75 17		 jne	 SHORT $L47490

; 74   :         {
; 75   :             DirectSound::CDebug::Assert(TRUE, "List entry not in list", pszFile, nLine);

  000a5	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  000ac	51		 push	 ecx
  000ad	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@GJDM@List?5entry?5not?5in?5list?$AA@ ; `string'
  000b2	6a 01		 push	 1
  000b4	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000b9	83 c4 10	 add	 esp, 16			; 00000010H
$L47490:

; 76   :         }
; 77   :     }
; 78   :     else if(ASSERT_NOT_IN_LIST == nFlags)

  000bc	eb 27		 jmp	 SHORT $L47492
$L47489:
  000be	83 7d 0c 02	 cmp	 DWORD PTR _nFlags$[ebp], 2
  000c2	75 21		 jne	 SHORT $L47493

; 79   :     {
; 80   :         if(IsEntryInList(Entry))

  000c4	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  000c7	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  000ca	3b 02		 cmp	 eax, DWORD PTR [edx]
  000cc	74 17		 je	 SHORT $L47494

; 81   :         {
; 82   :             DirectSound::CDebug::Assert(TRUE, "List entry in list", pszFile, nLine);

  000ce	8b 4d 14	 mov	 ecx, DWORD PTR _nLine$[ebp]
  000d1	51		 push	 ecx
  000d2	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  000d5	52		 push	 edx
  000d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@JAPH@List?5entry?5in?5list?$AA@ ; `string'
  000db	6a 01		 push	 1
  000dd	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000e2	83 c4 10	 add	 esp, 16			; 00000010H
$L47494:
$L47493:
$L47492:
$L47488:
$L47482:
$L47478:

; 83   :         }
; 84   :     }
; 85   : }

  000e5	5d		 pop	 ebp
  000e6	c2 10 00	 ret	 16			; 00000010H
?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ENDP ; __AssertValidEntryList
_TEXT	ENDS
PUBLIC	??1CWaveBankEntry@@UAE@XZ			; CWaveBankEntry::~CWaveBankEntry
; Function compile flags: /Odt
;	COMDAT ??_GCWaveBankEntry@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCWaveBankEntry@@UAEPAXI@Z PROC NEAR			; CWaveBankEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CWaveBankEntry@@UAE@XZ ; CWaveBankEntry::~CWaveBankEntry
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L48998
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L48998:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCWaveBankEntry@@UAEPAXI@Z ENDP			; CWaveBankEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BK@DIHO@m_pParent?9?$DOm_dwEntryCount?$AA@ ; `string'
PUBLIC	?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z	; RemoveEntryList
;	COMDAT ??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\writer.cpp
CONST	SEGMENT
??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\privat'
	DB	'e\windows\directx\dsound\tools\wavbndlr\common\writer.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DIHO@m_pParent?9?$DOm_dwEntryCount?$AA@
CONST	SEGMENT
??_C@_0BK@DIHO@m_pParent?9?$DOm_dwEntryCount?$AA@ DB 'm_pParent->m_dwEntr'
	DB	'yCount', 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??1CWaveBankEntry@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CWaveBankEntry@@UAE@XZ PROC NEAR			; CWaveBankEntry::~CWaveBankEntry, COMDAT
; _this$ = ecx

; 326  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CWaveBankEntry@@6B@ ; CWaveBankEntry::`vftable'

; 327  :     DPF_ENTER();
; 328  : 
; 329  :     RemoveEntryList(&m_leEntry);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 08	 add	 ecx, 8
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 330  : 
; 331  :     ASSERT(m_pParent->m_dwEntryCount);

  0001c	68 4b 01 00 00	 push	 331			; 0000014bH
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00026	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@DIHO@m_pParent?9?$DOm_dwEntryCount?$AA@ ; `string'
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	33 c9		 xor	 ecx, ecx
  00033	83 b8 40 02 00
	00 00		 cmp	 DWORD PTR [eax+576], 0
  0003a	0f 94 c1	 sete	 cl
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00043	83 c4 10	 add	 esp, 16			; 00000010H

; 332  :     m_pParent->m_dwEntryCount--;

  00046	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00049	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004c	8b 88 40 02 00
	00		 mov	 ecx, DWORD PTR [eax+576]
  00052	83 e9 01	 sub	 ecx, 1
  00055	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00058	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005b	89 88 40 02 00
	00		 mov	 DWORD PTR [eax+576], ecx

; 333  : 
; 334  :     DPF_LEAVE_VOID();
; 335  : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
??1CWaveBankEntry@@UAE@XZ ENDP				; CWaveBankEntry::~CWaveBankEntry
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\ntlist.h
_TEXT	ENDS
;	COMDAT ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z
_TEXT	SEGMENT
_Entry$ = 8
?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z PROC NEAR	; RemoveEntryList, COMDAT

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 216  :     AssertValidEntryList(Entry, ASSERT_VALID_ONLY);

  00003	68 d8 00 00 00	 push	 216			; 000000d8H
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@MICE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000d	6a 00		 push	 0
  0000f	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 217  : 
; 218  :     if(IsEntryInList(Entry))

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0001e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00020	74 2c		 je	 SHORT $L47516

; 219  :     {
; 220  :         Entry->Flink->Blink = Entry->Blink;

  00022	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0002a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 221  :         Entry->Blink->Flink = Entry->Flink;

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00033	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00036	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 0a		 mov	 DWORD PTR [edx], ecx

; 222  : 
; 223  :         Entry->Flink = Entry->Blink = Entry;

  0003d	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  00040	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00043	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00049	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0004c	89 11		 mov	 DWORD PTR [ecx], edx
$L47516:

; 224  :     }
; 225  : 
; 226  :     return Entry;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]

; 227  : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ENDP	; RemoveEntryList
_TEXT	ENDS
PUBLIC	??_C@_0M@IOKM@pszFileName?$AA@			; `string'
PUBLIC	??_C@_0BL@LDEE@CWaveBankEntry?3?3Initialize?$AA@ ; `string'
PUBLIC	??_C@_0FD@FKMK@An?5entry?5with?5that?5name?5already?5@ ; `string'
PUBLIC	??_C@_0DI@JGFL@An?5entry?5using?5that?5filename?5alr@ ; `string'
EXTRN	_strncpy:NEAR
EXTRN	__splitpath:NEAR
;	COMDAT ??_C@_0M@IOKM@pszFileName?$AA@
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\writer.cpp
CONST	SEGMENT
??_C@_0M@IOKM@pszFileName?$AA@ DB 'pszFileName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LDEE@CWaveBankEntry?3?3Initialize?$AA@
CONST	SEGMENT
??_C@_0BL@LDEE@CWaveBankEntry?3?3Initialize?$AA@ DB 'CWaveBankEntry::Init'
	DB	'ialize', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@FKMK@An?5entry?5with?5that?5name?5already?5@
CONST	SEGMENT
??_C@_0FD@FKMK@An?5entry?5with?5that?5name?5already?5@ DB 'An entry with '
	DB	'that name already exists in the bank, or that name has been r'
	DB	'eserved', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@JGFL@An?5entry?5using?5that?5filename?5alr@
CONST	SEGMENT
??_C@_0DI@JGFL@An?5entry?5using?5that?5filename?5alr@ DB 'An entry using '
	DB	'that filename already exists in the bank', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Initialize@CWaveBankEntry@@UAEJPBD0K@Z
_TEXT	SEGMENT
_pszEntryName$ = 8
_pszFileName$ = 12
_dwFlags$ = 16
_this$ = -16
_hr$ = -12
_nNameCount$ = -8
_nFileCount$ = -4
?Initialize@CWaveBankEntry@@UAEJPBD0K@Z PROC NEAR	; CWaveBankEntry::Initialize, COMDAT
; _this$ = ecx

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 366  :     HRESULT                 hr          = S_OK;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 367  :     UINT                    nNameCount;
; 368  :     UINT                    nFileCount;
; 369  :     
; 370  :     DPF_ENTER();
; 371  : 
; 372  :     ASSERT(pszFileName);

  00010	68 74 01 00 00	 push	 372			; 00000174H
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@IOKM@pszFileName?$AA@ ; `string'
  0001f	33 c0		 xor	 eax, eax
  00021	83 7d 0c 00	 cmp	 DWORD PTR _pszFileName$[ebp], 0
  00025	0f 94 c0	 sete	 al
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002e	83 c4 10	 add	 esp, 16			; 00000010H

; 373  : 
; 374  :     //
; 375  :     // Save the file path
; 376  :     //
; 377  : 
; 378  :     GetFullPathName(pszFileName, NUMELMS(m_szFileName), m_szFileName, NULL);

  00031	6a 00		 push	 0
  00033	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	81 c1 10 02 00
	00		 add	 ecx, 528		; 00000210H
  0003c	51		 push	 ecx
  0003d	68 04 01 00 00	 push	 260			; 00000104H
  00042	8b 55 0c	 mov	 edx, DWORD PTR _pszFileName$[ebp]
  00045	52		 push	 edx
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFullPathNameA@16

; 379  : 
; 380  :     //
; 381  :     // Save the flags
; 382  :     //
; 383  : 
; 384  :     m_dwFlags = dwFlags;

  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d 10	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00052	89 88 28 03 00
	00		 mov	 DWORD PTR [eax+808], ecx

; 385  : 
; 386  :     //
; 387  :     // If no entry name was specified, generate one from the file name
; 388  :     //
; 389  : 
; 390  :     if(pszEntryName)

  00058	83 7d 08 00	 cmp	 DWORD PTR _pszEntryName$[ebp], 0
  0005c	74 1a		 je	 SHORT $L49016

; 391  :     {
; 392  :         strncpy(m_szEntryName, pszEntryName, NUMELMS(m_szEntryName));

  0005e	68 00 01 00 00	 push	 256			; 00000100H
  00063	8b 55 08	 mov	 edx, DWORD PTR _pszEntryName$[ebp]
  00066	52		 push	 edx
  00067	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	83 c0 10	 add	 eax, 16			; 00000010H
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 _strncpy
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 393  :     }
; 394  :     else

  00076	eb 1f		 jmp	 SHORT $L49017
$L49016:

; 395  :     {
; 396  :         _splitpath(m_szFileName, NULL, NULL, m_szEntryName, NULL);

  00078	6a 00		 push	 0
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	83 c1 10	 add	 ecx, 16			; 00000010H
  00080	51		 push	 ecx
  00081	6a 00		 push	 0
  00083	6a 00		 push	 0
  00085	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00088	81 c2 10 02 00
	00		 add	 edx, 528		; 00000210H
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 __splitpath
  00094	83 c4 14	 add	 esp, 20			; 00000014H
$L49017:

; 397  :     }
; 398  : 
; 399  :     strncpy(m_szHeaderName, m_szEntryName, NUMELMS(m_szHeaderName));

  00097	68 00 01 00 00	 push	 256			; 00000100H
  0009c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	83 c0 10	 add	 eax, 16			; 00000010H
  000a2	50		 push	 eax
  000a3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  000ac	51		 push	 ecx
  000ad	e8 00 00 00 00	 call	 _strncpy
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 400  :     MakeHeaderString(m_szHeaderName);

  000b5	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000b8	81 c2 10 01 00
	00		 add	 edx, 272		; 00000110H
  000be	52		 push	 edx
  000bf	e8 00 00 00 00	 call	 ?MakeHeaderString@@YGXPAD@Z ; MakeHeaderString

; 401  : 
; 402  :     FindDuplicateEntry(m_szHeaderName, &nNameCount, m_szFileName, &nFileCount);

  000c4	8d 45 fc	 lea	 eax, DWORD PTR _nFileCount$[ebp]
  000c7	50		 push	 eax
  000c8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	81 c1 10 02 00
	00		 add	 ecx, 528		; 00000210H
  000d1	51		 push	 ecx
  000d2	8d 55 f8	 lea	 edx, DWORD PTR _nNameCount$[ebp]
  000d5	52		 push	 edx
  000d6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d9	05 10 01 00 00	 add	 eax, 272		; 00000110H
  000de	50		 push	 eax
  000df	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e7	ff 52 28	 call	 DWORD PTR [edx+40]

; 403  : 
; 404  :     if(nNameCount)

  000ea	83 7d f8 00	 cmp	 DWORD PTR _nNameCount$[ebp], 0
  000ee	74 36		 je	 SHORT $L49018

; 405  :     {
; 406  :         DPF_ERROR("An entry with that name already exists in the bank, or that name has been reserved");

  000f0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000f5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@LDEE@CWaveBankEntry?3?3Initialize?$AA@ ; `string'
  000fa	68 96 01 00 00	 push	 406			; 00000196H
  000ff	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00104	6a 01		 push	 1
  00106	6a 09		 push	 9
  00108	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0010d	83 c4 18	 add	 esp, 24			; 00000018H
  00110	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FD@FKMK@An?5entry?5with?5that?5name?5already?5@ ; `string'
  00115	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0011a	83 c4 04	 add	 esp, 4

; 407  :         hr = E_FAIL;

  0011d	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 408  :     }
; 409  :     else if(nFileCount)

  00124	eb 33		 jmp	 SHORT $L49022
$L49018:
  00126	83 7d fc 00	 cmp	 DWORD PTR _nFileCount$[ebp], 0
  0012a	74 2d		 je	 SHORT $L49023

; 410  :     {
; 411  :         DPF_WARNING("An entry using that filename already exists in the bank");

  0012c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00131	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@LDEE@CWaveBankEntry?3?3Initialize?$AA@ ; `string'
  00136	68 9b 01 00 00	 push	 411			; 0000019bH
  0013b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00140	6a 03		 push	 3
  00142	6a 09		 push	 9
  00144	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00149	83 c4 18	 add	 esp, 24			; 00000018H
  0014c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@JGFL@An?5entry?5using?5that?5filename?5alr@ ; `string'
  00151	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00156	83 c4 04	 add	 esp, 4
$L49023:
$L49022:

; 412  :     }
; 413  : 
; 414  :     //
; 415  :     // Open the file
; 416  :     //
; 417  : 
; 418  :     if(SUCCEEDED(hr))

  00159	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0015d	7c 0e		 jl	 SHORT $L49026

; 419  :     {
; 420  :         hr = LoadWaveFile();

  0015f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00162	8b 10		 mov	 edx, DWORD PTR [eax]
  00164	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00167	ff 52 24	 call	 DWORD PTR [edx+36]
  0016a	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
$L49026:

; 421  :     }
; 422  :     
; 423  :     DPF_LEAVE_HRESULT(hr);
; 424  : 
; 425  :     return hr;

  0016d	8b 45 f4	 mov	 eax, DWORD PTR _hr$[ebp]

; 426  : }

  00170	8b e5		 mov	 esp, ebp
  00172	5d		 pop	 ebp
  00173	c2 0c 00	 ret	 12			; 0000000cH
?Initialize@CWaveBankEntry@@UAEJPBD0K@Z ENDP		; CWaveBankEntry::Initialize
_TEXT	ENDS
PUBLIC	??_C@_0BD@LKKO@pszName?5?$HM?$HM?5pszPath?$AA@	; `string'
PUBLIC	??_C@_0M@JHGL@ENTRY_COUNT?$AA@			; `string'
EXTRN	__strcmpi:NEAR
;	COMDAT ??_C@_0BD@LKKO@pszName?5?$HM?$HM?5pszPath?$AA@
CONST	SEGMENT
??_C@_0BD@LKKO@pszName?5?$HM?$HM?5pszPath?$AA@ DB 'pszName || pszPath', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JHGL@ENTRY_COUNT?$AA@
CONST	SEGMENT
??_C@_0M@JHGL@ENTRY_COUNT?$AA@ DB 'ENTRY_COUNT', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?FindDuplicateEntry@CWaveBankEntry@@MAEJPBDPAI01@Z
_TEXT	SEGMENT
_pszName$ = 8
_pnNameCount$ = 12
_pszPath$ = 16
_pnPathCount$ = 20
_this$ = -16
_hr$ = -8
_pleEntry$ = -12
_pEntry$ = -4
?FindDuplicateEntry@CWaveBankEntry@@MAEJPBDPAI01@Z PROC NEAR ; CWaveBankEntry::FindDuplicateEntry, COMDAT
; _this$ = ecx

; 458  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 459  :     HRESULT                 hr          = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 460  :     PLIST_ENTRY             pleEntry;
; 461  :     CWaveBankEntry *        pEntry;
; 462  :     
; 463  :     DPF_ENTER();
; 464  : 
; 465  :     ASSERT(pszName || pszPath);

  00010	83 7d 08 00	 cmp	 DWORD PTR _pszName$[ebp], 0
  00014	75 0f		 jne	 SHORT $L51502
  00016	83 7d 10 00	 cmp	 DWORD PTR _pszPath$[ebp], 0
  0001a	75 09		 jne	 SHORT $L51502
  0001c	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR -20+[ebp], 1
  00023	eb 07		 jmp	 SHORT $L51503
$L51502:
  00025	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR -20+[ebp], 0
$L51503:
  0002c	68 d1 01 00 00	 push	 465			; 000001d1H
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00036	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@LKKO@pszName?5?$HM?$HM?5pszPath?$AA@ ; `string'
  0003b	8b 45 ec	 mov	 eax, DWORD PTR -20+[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00044	83 c4 10	 add	 esp, 16			; 00000010H

; 466  : 
; 467  :     if(pnNameCount)

  00047	83 7d 0c 00	 cmp	 DWORD PTR _pnNameCount$[ebp], 0
  0004b	74 09		 je	 SHORT $L49039

; 468  :     {
; 469  :         *pnNameCount = 0;

  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _pnNameCount$[ebp]
  00050	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L49039:

; 470  :     }
; 471  : 
; 472  :     if(pnPathCount)

  00056	83 7d 14 00	 cmp	 DWORD PTR _pnPathCount$[ebp], 0
  0005a	74 09		 je	 SHORT $L49040

; 473  :     {
; 474  :         *pnPathCount = 0;

  0005c	8b 55 14	 mov	 edx, DWORD PTR _pnPathCount$[ebp]
  0005f	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L49040:

; 475  :     }
; 476  : 
; 477  :     if(pszName)

  00065	83 7d 08 00	 cmp	 DWORD PTR _pszName$[ebp], 0
  00069	74 2f		 je	 SHORT $L49041

; 478  :     {
; 479  :         if(!_strcmpi(pszName, WBCHEADER_ENTRYCOUNTSHORTNAME))

  0006b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@JHGL@ENTRY_COUNT?$AA@ ; `string'
  00070	8b 45 08	 mov	 eax, DWORD PTR _pszName$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 __strcmpi
  00079	83 c4 08	 add	 esp, 8
  0007c	85 c0		 test	 eax, eax
  0007e	75 1a		 jne	 SHORT $L49042

; 480  :         {
; 481  :             hr = E_FAIL;

  00080	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 482  :             
; 483  :             if(pnNameCount)

  00087	83 7d 0c 00	 cmp	 DWORD PTR _pnNameCount$[ebp], 0
  0008b	74 0d		 je	 SHORT $L49045

; 484  :             {
; 485  :                 *pnNameCount += 1;

  0008d	8b 4d 0c	 mov	 ecx, DWORD PTR _pnNameCount$[ebp]
  00090	8b 11		 mov	 edx, DWORD PTR [ecx]
  00092	83 c2 01	 add	 edx, 1
  00095	8b 45 0c	 mov	 eax, DWORD PTR _pnNameCount$[ebp]
  00098	89 10		 mov	 DWORD PTR [eax], edx
$L49045:
$L49042:
$L49041:

; 486  :             }
; 487  :         }
; 488  :     }
; 489  : 
; 490  :     for(pleEntry = m_pParent->m_lstEntries.Flink; pleEntry != &m_pParent->m_lstEntries; pleEntry = pleEntry->Flink)

  0009a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a0	8b 82 38 02 00
	00		 mov	 eax, DWORD PTR [edx+568]
  000a6	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax
  000a9	eb 08		 jmp	 SHORT $L49046
$L49047:
  000ab	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  000ae	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b0	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx
$L49046:
  000b3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b9	81 c1 38 02 00
	00		 add	 ecx, 568		; 00000238H
  000bf	39 4d f4	 cmp	 DWORD PTR _pleEntry$[ebp], ecx
  000c2	0f 84 a2 00 00
	00		 je	 $L49048

; 491  :     {
; 492  :         if(FAILED(hr) && !pnNameCount && !pnPathCount)

  000c8	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000cc	7d 11		 jge	 SHORT $L49050
  000ce	83 7d 0c 00	 cmp	 DWORD PTR _pnNameCount$[ebp], 0
  000d2	75 0b		 jne	 SHORT $L49050
  000d4	83 7d 14 00	 cmp	 DWORD PTR _pnPathCount$[ebp], 0
  000d8	75 05		 jne	 SHORT $L49050

; 493  :         {
; 494  :             break;

  000da	e9 8b 00 00 00	 jmp	 $L49048
$L49050:

; 495  :         }
; 496  :         
; 497  :         if(this == (pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry)))

  000df	8b 55 f4	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  000e2	83 ea 08	 sub	 edx, 8
  000e5	89 55 fc	 mov	 DWORD PTR _pEntry$[ebp], edx
  000e8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	3b 45 fc	 cmp	 eax, DWORD PTR _pEntry$[ebp]
  000ee	75 02		 jne	 SHORT $L49055

; 498  :         {
; 499  :             continue;

  000f0	eb b9		 jmp	 SHORT $L49047
$L49055:

; 500  :         }
; 501  : 
; 502  :         if(pszName)

  000f2	83 7d 08 00	 cmp	 DWORD PTR _pszName$[ebp], 0
  000f6	74 34		 je	 SHORT $L49056

; 503  :         {
; 504  :             if(!_strcmpi(pszName, pEntry->m_szHeaderName))

  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _pEntry$[ebp]
  000fb	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  00101	51		 push	 ecx
  00102	8b 55 08	 mov	 edx, DWORD PTR _pszName$[ebp]
  00105	52		 push	 edx
  00106	e8 00 00 00 00	 call	 __strcmpi
  0010b	83 c4 08	 add	 esp, 8
  0010e	85 c0		 test	 eax, eax
  00110	75 1a		 jne	 SHORT $L49057

; 505  :             {
; 506  :                 hr = E_FAIL;

  00112	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 507  :                 
; 508  :                 if(pnNameCount)

  00119	83 7d 0c 00	 cmp	 DWORD PTR _pnNameCount$[ebp], 0
  0011d	74 0d		 je	 SHORT $L49059

; 509  :                 {
; 510  :                     *pnNameCount += 1;

  0011f	8b 45 0c	 mov	 eax, DWORD PTR _pnNameCount$[ebp]
  00122	8b 08		 mov	 ecx, DWORD PTR [eax]
  00124	83 c1 01	 add	 ecx, 1
  00127	8b 55 0c	 mov	 edx, DWORD PTR _pnNameCount$[ebp]
  0012a	89 0a		 mov	 DWORD PTR [edx], ecx
$L49059:
$L49057:
$L49056:

; 511  :                 }
; 512  :             }
; 513  :         }
; 514  : 
; 515  :         if(pszPath)

  0012c	83 7d 10 00	 cmp	 DWORD PTR _pszPath$[ebp], 0
  00130	74 33		 je	 SHORT $L49060

; 516  :         {
; 517  :             if(!_strcmpi(pszPath, pEntry->m_szFileName))

  00132	8b 45 fc	 mov	 eax, DWORD PTR _pEntry$[ebp]
  00135	05 10 02 00 00	 add	 eax, 528		; 00000210H
  0013a	50		 push	 eax
  0013b	8b 4d 10	 mov	 ecx, DWORD PTR _pszPath$[ebp]
  0013e	51		 push	 ecx
  0013f	e8 00 00 00 00	 call	 __strcmpi
  00144	83 c4 08	 add	 esp, 8
  00147	85 c0		 test	 eax, eax
  00149	75 1a		 jne	 SHORT $L49061

; 518  :             {
; 519  :                 hr = E_FAIL;

  0014b	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 520  :                 
; 521  :                 if(pnPathCount)

  00152	83 7d 14 00	 cmp	 DWORD PTR _pnPathCount$[ebp], 0
  00156	74 0d		 je	 SHORT $L49063

; 522  :                 {
; 523  :                     *pnPathCount += 1;

  00158	8b 55 14	 mov	 edx, DWORD PTR _pnPathCount$[ebp]
  0015b	8b 02		 mov	 eax, DWORD PTR [edx]
  0015d	83 c0 01	 add	 eax, 1
  00160	8b 4d 14	 mov	 ecx, DWORD PTR _pnPathCount$[ebp]
  00163	89 01		 mov	 DWORD PTR [ecx], eax
$L49063:
$L49061:
$L49060:

; 524  :                 }
; 525  :             }
; 526  :         }
; 527  :     }

  00165	e9 41 ff ff ff	 jmp	 $L49047
$L49048:

; 528  :     
; 529  :     DPF_LEAVE_HRESULT(hr);
; 530  : 
; 531  :     return hr;

  0016a	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 532  : }

  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c2 10 00	 ret	 16			; 00000010H
?FindDuplicateEntry@CWaveBankEntry@@MAEJPBDPAI01@Z ENDP	; CWaveBankEntry::FindDuplicateEntry
_TEXT	ENDS
PUBLIC	??_C@_07OKEH@SetName?$AA@			; `string'
PUBLIC	??_C@_0BG@EPOG@That?5name?5is?5too?5long?$AA@	; `string'
EXTRN	_strlen:NEAR
;	COMDAT ??_C@_07OKEH@SetName?$AA@
CONST	SEGMENT
??_C@_07OKEH@SetName?$AA@ DB 'SetName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EPOG@That?5name?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BG@EPOG@That?5name?5is?5too?5long?$AA@ DB 'That name is too long', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetName@CWaveBankEntry@@UAEJPBD@Z
_TEXT	SEGMENT
_pszName$ = 8
_this$ = -264
_hr$ = -260
_szHeaderName$ = -256
?SetName@CWaveBankEntry@@UAEJPBD@Z PROC NEAR		; CWaveBankEntry::SetName, COMDAT
; _this$ = ecx

; 558  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 559  :     HRESULT                 hr                                      = S_OK;

  0000f	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _hr$[ebp], 0

; 560  :     CHAR                    szHeaderName[NUMELMS(m_szHeaderName)];
; 561  : 
; 562  :     if(strlen(pszName) >= NUMELMS(m_szEntryName))

  00019	8b 45 08	 mov	 eax, DWORD PTR _pszName$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _strlen
  00022	83 c4 04	 add	 esp, 4
  00025	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0002a	72 37		 jb	 SHORT $L49071

; 563  :     {
; 564  :         DPF_ERROR("That name is too long");

  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07OKEH@SetName?$AA@ ; `string'
  00036	68 34 02 00 00	 push	 564			; 00000234H
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00040	6a 01		 push	 1
  00042	6a 09		 push	 9
  00044	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00049	83 c4 18	 add	 esp, 24			; 00000018H
  0004c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@EPOG@That?5name?5is?5too?5long?$AA@ ; `string'
  00051	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00056	83 c4 04	 add	 esp, 4

; 565  :         hr = E_FAIL;

  00059	c7 85 fc fe ff
	ff 05 40 00 80	 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49071:

; 566  :     }
; 567  : 
; 568  :     if(SUCCEEDED(hr))

  00063	83 bd fc fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  0006a	0f 8c bc 00 00
	00		 jl	 $L49076

; 569  :     {
; 570  :         strncpy(szHeaderName, pszName, NUMELMS(szHeaderName));

  00070	68 00 01 00 00	 push	 256			; 00000100H
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _pszName$[ebp]
  00078	51		 push	 ecx
  00079	8d 95 00 ff ff
	ff		 lea	 edx, DWORD PTR _szHeaderName$[ebp]
  0007f	52		 push	 edx
  00080	e8 00 00 00 00	 call	 _strncpy
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH

; 571  :         MakeHeaderString(szHeaderName);

  00088	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _szHeaderName$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?MakeHeaderString@@YGXPAD@Z ; MakeHeaderString

; 572  : 
; 573  :         hr = FindDuplicateEntry(szHeaderName, NULL, NULL, NULL);

  00094	6a 00		 push	 0
  00096	6a 00		 push	 0
  00098	6a 00		 push	 0
  0009a	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _szHeaderName$[ebp]
  000a0	51		 push	 ecx
  000a1	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000a7	8b 02		 mov	 eax, DWORD PTR [edx]
  000a9	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000af	ff 50 28	 call	 DWORD PTR [eax+40]
  000b2	89 85 fc fe ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 574  : 
; 575  :         if(SUCCEEDED(hr))

  000b8	83 bd fc fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  000bf	7c 3e		 jl	 SHORT $L49078

; 576  :         {
; 577  :             strncpy(m_szEntryName, pszName, NUMELMS(m_szEntryName));

  000c1	68 00 01 00 00	 push	 256			; 00000100H
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _pszName$[ebp]
  000c9	51		 push	 ecx
  000ca	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000d0	83 c2 10	 add	 edx, 16			; 00000010H
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 _strncpy
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 578  :             strncpy(m_szHeaderName, szHeaderName, NUMELMS(m_szHeaderName));

  000dc	68 00 01 00 00	 push	 256			; 00000100H
  000e1	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _szHeaderName$[ebp]
  000e7	50		 push	 eax
  000e8	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  000f4	51		 push	 ecx
  000f5	e8 00 00 00 00	 call	 _strncpy
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 579  :         }
; 580  :         else

  000fd	eb 2d		 jmp	 SHORT $L49079
$L49078:

; 581  :         {
; 582  :             DPF_ERROR("An entry with that name already exists in the bank, or that name has been reserved");

  000ff	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00104	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07OKEH@SetName?$AA@ ; `string'
  00109	68 46 02 00 00	 push	 582			; 00000246H
  0010e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00113	6a 01		 push	 1
  00115	6a 09		 push	 9
  00117	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0011c	83 c4 18	 add	 esp, 24			; 00000018H
  0011f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FD@FKMK@An?5entry?5with?5that?5name?5already?5@ ; `string'
  00124	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00129	83 c4 04	 add	 esp, 4
$L49079:
$L49076:

; 583  :         }
; 584  :     }
; 585  : 
; 586  :     return hr;

  0012c	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _hr$[ebp]

; 587  : }

  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c2 04 00	 ret	 4
?SetName@CWaveBankEntry@@UAEJPBD@Z ENDP			; CWaveBankEntry::SetName
_TEXT	ENDS
PUBLIC	??0CWaveFile@WaveLoader@@QAE@XZ			; WaveLoader::CWaveFile::CWaveFile
PUBLIC	??1CWaveFile@WaveLoader@@QAE@XZ			; WaveLoader::CWaveFile::~CWaveFile
PUBLIC	?Open@CWaveFile@WaveLoader@@QAEJPBD@Z		; WaveLoader::CWaveFile::Open
PUBLIC	?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetFormat
PUBLIC	??_C@_0BN@BLDB@CWaveBankEntry?3?3LoadWaveFile?$AA@ ; `string'
PUBLIC	??_C@_0CO@EFJM@An?5error?5occurred?5while?5attempti@ ; `string'
PUBLIC	??_C@_0DN@CLEF@An?5error?5occurred?5while?5attempti@ ; `string'
PUBLIC	??_C@_0DP@DBDA@An?5error?5occurred?5while?5attempti@ ; `string'
PUBLIC	?GetFileType@CWaveFile@WaveLoader@@QAEJPAK@Z	; WaveLoader::CWaveFile::GetFileType
PUBLIC	?GetDataOffset@CWaveFile@WaveLoader@@QAEJPAK@Z	; WaveLoader::CWaveFile::GetDataOffset
PUBLIC	?GetDuration@CWaveFile@WaveLoader@@QAEJPAK@Z	; WaveLoader::CWaveFile::GetDuration
PUBLIC	??_C@_0EE@FGDJ@An?5error?5occurred?5while?5attempti@ ; `string'
PUBLIC	?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z	; WaveLoader::CWaveFile::GetLoopRegion
PUBLIC	??_C@_0EE@GAIB@An?5error?5occurred?5while?5attempti@ ; `string'
;	COMDAT ??_C@_0BN@BLDB@CWaveBankEntry?3?3LoadWaveFile?$AA@
CONST	SEGMENT
??_C@_0BN@BLDB@CWaveBankEntry?3?3LoadWaveFile?$AA@ DB 'CWaveBankEntry::Lo'
	DB	'adWaveFile', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@EFJM@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT
??_C@_0CO@EFJM@An?5error?5occurred?5while?5attempti@ DB 'An error occurre'
	DB	'd while attempting to open %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@CLEF@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT
??_C@_0DN@CLEF@An?5error?5occurred?5while?5attempti@ DB 'An error occurre'
	DB	'd while attempting to retrieve the file type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@DBDA@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT
??_C@_0DP@DBDA@An?5error?5occurred?5while?5attempti@ DB 'An error occurre'
	DB	'd while attempting to retrieve the file format', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@FGDJ@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT
??_C@_0EE@FGDJ@An?5error?5occurred?5while?5attempti@ DB 'An error occurre'
	DB	'd while attempting to retrieve the wave data offset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@GAIB@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT
??_C@_0EE@GAIB@An?5error?5occurred?5while?5attempti@ DB 'An error occurre'
	DB	'd while attempting to retrieve the wave data length', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?LoadWaveFile@CWaveBankEntry@@MAEJXZ
_TEXT	SEGMENT
_this$ = -100
_WaveFile$ = -88
_Format$ = -20
_hr$ = -92
$T51510 = -96
?LoadWaveFile@CWaveBankEntry@@MAEJXZ PROC NEAR		; CWaveBankEntry::LoadWaveFile, COMDAT
; _this$ = ecx

; 614  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	89 4d 9c	 mov	 DWORD PTR _this$[ebp], ecx

; 615  :     CWaveFile               WaveFile;

  00009	8d 4d a8	 lea	 ecx, DWORD PTR _WaveFile$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CWaveFile@WaveLoader@@QAE@XZ ; WaveLoader::CWaveFile::CWaveFile

; 616  :     WAVEBANKUNIWAVEFORMAT   Format;
; 617  :     HRESULT                 hr;
; 618  :     
; 619  :     DPF_ENTER();
; 620  :     
; 621  :     //
; 622  :     // Open the file
; 623  :     //
; 624  : 
; 625  :     if(FAILED(hr = WaveFile.Open(m_szFileName)))

  00011	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  00014	05 10 02 00 00	 add	 eax, 528		; 00000210H
  00019	50		 push	 eax
  0001a	8d 4d a8	 lea	 ecx, DWORD PTR _WaveFile$[ebp]
  0001d	e8 00 00 00 00	 call	 ?Open@CWaveFile@WaveLoader@@QAEJPBD@Z ; WaveLoader::CWaveFile::Open
  00022	89 45 a4	 mov	 DWORD PTR _hr$[ebp], eax
  00025	83 7d a4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00029	7d 37		 jge	 SHORT $L49088

; 626  :     {
; 627  :         DPF_ERROR("An error occurred while attempting to open %s", m_szFileName);

  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00030	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@BLDB@CWaveBankEntry?3?3LoadWaveFile?$AA@ ; `string'
  00035	68 73 02 00 00	 push	 627			; 00000273H
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0003f	6a 01		 push	 1
  00041	6a 09		 push	 9
  00043	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00048	83 c4 18	 add	 esp, 24			; 00000018H
  0004b	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	81 c1 10 02 00
	00		 add	 ecx, 528		; 00000210H
  00054	51		 push	 ecx
  00055	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CO@EFJM@An?5error?5occurred?5while?5attempti@ ; `string'
  0005a	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0005f	83 c4 08	 add	 esp, 8
$L49088:

; 628  :     }
; 629  : 
; 630  :     //
; 631  :     // Load the file format
; 632  :     //
; 633  : 
; 634  :     if(SUCCEEDED(hr))

  00062	83 7d a4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00066	7c 48		 jl	 SHORT $L49092

; 635  :     {
; 636  :         if(FAILED(hr = WaveFile.GetFileType(&m_dwFileType)))

  00068	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	81 c2 2c 03 00
	00		 add	 edx, 812		; 0000032cH
  00071	52		 push	 edx
  00072	8d 4d a8	 lea	 ecx, DWORD PTR _WaveFile$[ebp]
  00075	e8 00 00 00 00	 call	 ?GetFileType@CWaveFile@WaveLoader@@QAEJPAK@Z ; WaveLoader::CWaveFile::GetFileType
  0007a	89 45 a4	 mov	 DWORD PTR _hr$[ebp], eax
  0007d	83 7d a4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00081	7d 2d		 jge	 SHORT $L49094

; 637  :         {
; 638  :             DPF_ERROR("An error occurred while attempting to retrieve the file type");

  00083	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00088	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@BLDB@CWaveBankEntry?3?3LoadWaveFile?$AA@ ; `string'
  0008d	68 7e 02 00 00	 push	 638			; 0000027eH
  00092	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00097	6a 01		 push	 1
  00099	6a 09		 push	 9
  0009b	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000a0	83 c4 18	 add	 esp, 24			; 00000018H
  000a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DN@CLEF@An?5error?5occurred?5while?5attempti@ ; `string'
  000a8	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000ad	83 c4 04	 add	 esp, 4
$L49094:
$L49092:

; 639  :         }
; 640  :     }
; 641  : 
; 642  :     if(SUCCEEDED(hr))

  000b0	83 7d a4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b4	7c 46		 jl	 SHORT $L49097

; 643  :     {
; 644  :         if(FAILED(hr = WaveFile.GetFormat(&Format.WaveFormatEx, sizeof(Format))))

  000b6	6a 00		 push	 0
  000b8	6a 14		 push	 20			; 00000014H
  000ba	8d 45 ec	 lea	 eax, DWORD PTR _Format$[ebp]
  000bd	50		 push	 eax
  000be	8d 4d a8	 lea	 ecx, DWORD PTR _WaveFile$[ebp]
  000c1	e8 00 00 00 00	 call	 ?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetFormat
  000c6	89 45 a4	 mov	 DWORD PTR _hr$[ebp], eax
  000c9	83 7d a4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000cd	7d 2d		 jge	 SHORT $L49099

; 645  :         {
; 646  :             DPF_ERROR("An error occurred while attempting to retrieve the file format");

  000cf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@BLDB@CWaveBankEntry?3?3LoadWaveFile?$AA@ ; `string'
  000d9	68 86 02 00 00	 push	 646			; 00000286H
  000de	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000e3	6a 01		 push	 1
  000e5	6a 09		 push	 9
  000e7	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000ec	83 c4 18	 add	 esp, 24			; 00000018H
  000ef	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DBDA@An?5error?5occurred?5while?5attempti@ ; `string'
  000f4	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000f9	83 c4 04	 add	 esp, 4
$L49099:
$L49097:

; 647  :         }
; 648  :     }
; 649  : 
; 650  :     if(SUCCEEDED(hr))

  000fc	83 7d a4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00100	7c 1e		 jl	 SHORT $L49102

; 651  :     {
; 652  :         if(!WaveBankCompressFormat(&Format, &m_Format))

  00102	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  0010b	51		 push	 ecx
  0010c	8d 55 ec	 lea	 edx, DWORD PTR _Format$[ebp]
  0010f	52		 push	 edx
  00110	e8 00 00 00 00	 call	 _WaveBankCompressFormat@8
  00115	85 c0		 test	 eax, eax
  00117	75 07		 jne	 SHORT $L49103

; 653  :         {
; 654  :             hr = E_NOTIMPL;

  00119	c7 45 a4 01 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467263 ; 80004001H
$L49103:
$L49102:

; 655  :         }
; 656  :     }
; 657  : 
; 658  :     //
; 659  :     // Save the data chunk offset and length
; 660  :     //
; 661  : 
; 662  :     if(SUCCEEDED(hr))

  00120	83 7d a4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00124	7c 47		 jl	 SHORT $L49106

; 663  :     {
; 664  :         if(FAILED(hr = WaveFile.GetDataOffset(&m_PlayRegion.dwStart)))

  00126	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  00129	05 18 03 00 00	 add	 eax, 792		; 00000318H
  0012e	50		 push	 eax
  0012f	8d 4d a8	 lea	 ecx, DWORD PTR _WaveFile$[ebp]
  00132	e8 00 00 00 00	 call	 ?GetDataOffset@CWaveFile@WaveLoader@@QAEJPAK@Z ; WaveLoader::CWaveFile::GetDataOffset
  00137	89 45 a4	 mov	 DWORD PTR _hr$[ebp], eax
  0013a	83 7d a4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0013e	7d 2d		 jge	 SHORT $L49108

; 665  :         {
; 666  :             DPF_ERROR("An error occurred while attempting to retrieve the wave data offset");

  00140	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00145	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@BLDB@CWaveBankEntry?3?3LoadWaveFile?$AA@ ; `string'
  0014a	68 9a 02 00 00	 push	 666			; 0000029aH
  0014f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00154	6a 01		 push	 1
  00156	6a 09		 push	 9
  00158	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0015d	83 c4 18	 add	 esp, 24			; 00000018H
  00160	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EE@FGDJ@An?5error?5occurred?5while?5attempti@ ; `string'
  00165	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0016a	83 c4 04	 add	 esp, 4
$L49108:
$L49106:

; 667  :         }
; 668  :     }
; 669  :     
; 670  :     if(SUCCEEDED(hr))

  0016d	83 7d a4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00171	7c 48		 jl	 SHORT $L49111

; 671  :     {
; 672  :         if(FAILED(hr = WaveFile.GetDuration(&m_PlayRegion.dwLength)))

  00173	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00176	81 c1 1c 03 00
	00		 add	 ecx, 796		; 0000031cH
  0017c	51		 push	 ecx
  0017d	8d 4d a8	 lea	 ecx, DWORD PTR _WaveFile$[ebp]
  00180	e8 00 00 00 00	 call	 ?GetDuration@CWaveFile@WaveLoader@@QAEJPAK@Z ; WaveLoader::CWaveFile::GetDuration
  00185	89 45 a4	 mov	 DWORD PTR _hr$[ebp], eax
  00188	83 7d a4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0018c	7d 2d		 jge	 SHORT $L49113

; 673  :         {
; 674  :             DPF_ERROR("An error occurred while attempting to retrieve the wave data length");

  0018e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00193	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@BLDB@CWaveBankEntry?3?3LoadWaveFile?$AA@ ; `string'
  00198	68 a2 02 00 00	 push	 674			; 000002a2H
  0019d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  001a2	6a 01		 push	 1
  001a4	6a 09		 push	 9
  001a6	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  001ab	83 c4 18	 add	 esp, 24			; 00000018H
  001ae	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EE@GAIB@An?5error?5occurred?5while?5attempti@ ; `string'
  001b3	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001b8	83 c4 04	 add	 esp, 4
$L49113:
$L49111:

; 675  :         }
; 676  :     }
; 677  : 
; 678  :     //
; 679  :     // Save the loop region
; 680  :     //
; 681  : 
; 682  :     if(SUCCEEDED(hr))

  001bb	83 7d a4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001bf	7c 45		 jl	 SHORT $L49116

; 683  :     {
; 684  :         hr = WaveFile.GetLoopRegion(&m_LoopRegion.dwStart, &m_LoopRegion.dwLength);

  001c1	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  001c4	81 c2 24 03 00
	00		 add	 edx, 804		; 00000324H
  001ca	52		 push	 edx
  001cb	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  001ce	05 20 03 00 00	 add	 eax, 800		; 00000320H
  001d3	50		 push	 eax
  001d4	8d 4d a8	 lea	 ecx, DWORD PTR _WaveFile$[ebp]
  001d7	e8 00 00 00 00	 call	 ?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z ; WaveLoader::CWaveFile::GetLoopRegion
  001dc	89 45 a4	 mov	 DWORD PTR _hr$[ebp], eax

; 685  : 
; 686  :         if(FAILED(hr))

  001df	83 7d a4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001e3	7d 21		 jge	 SHORT $L49118

; 687  :         {
; 688  :             m_LoopRegion.dwStart = 0;

  001e5	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  001e8	c7 81 20 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+800], 0

; 689  :             m_LoopRegion.dwLength = 0;

  001f2	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  001f5	c7 82 24 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+804], 0

; 690  :             
; 691  :             hr = S_OK;

  001ff	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0
$L49118:
$L49116:

; 692  :         }
; 693  :     }
; 694  :     
; 695  :     //
; 696  :     // Update the flags to account for having valid data
; 697  :     //
; 698  :     
; 699  :     if(SUCCEEDED(hr))

  00206	83 7d a4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0020a	7c 17		 jl	 SHORT $L49121

; 700  :     {
; 701  :         SetFlags(~0UL, m_dwFlags);

  0020c	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  0020f	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  00215	51		 push	 ecx
  00216	6a ff		 push	 -1
  00218	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  0021b	8b 02		 mov	 eax, DWORD PTR [edx]
  0021d	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00220	ff 50 10	 call	 DWORD PTR [eax+16]
$L49121:

; 702  :     }
; 703  : 
; 704  :     DPF_LEAVE_HRESULT(hr);
; 705  : 
; 706  :     return hr;

  00223	8b 4d a4	 mov	 ecx, DWORD PTR _hr$[ebp]
  00226	89 4d a0	 mov	 DWORD PTR $T51510[ebp], ecx
  00229	8d 4d a8	 lea	 ecx, DWORD PTR _WaveFile$[ebp]
  0022c	e8 00 00 00 00	 call	 ??1CWaveFile@WaveLoader@@QAE@XZ ; WaveLoader::CWaveFile::~CWaveFile
  00231	8b 45 a0	 mov	 eax, DWORD PTR $T51510[ebp]

; 707  : }

  00234	8b e5		 mov	 esp, ebp
  00236	5d		 pop	 ebp
  00237	c3		 ret	 0
?LoadWaveFile@CWaveBankEntry@@MAEJXZ ENDP		; CWaveBankEntry::LoadWaveFile
_TEXT	ENDS
PUBLIC	?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z	; WaveLoader::CWaveFile::Open
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\waveldr.h
;	COMDAT ?Open@CWaveFile@WaveLoader@@QAEJPBD@Z
_TEXT	SEGMENT
_pszFileName$ = 8
_this$ = -4
?Open@CWaveFile@WaveLoader@@QAEJPBD@Z PROC NEAR		; WaveLoader::CWaveFile::Open, COMDAT
; _this$ = ecx

; 335  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 336  :         return Open(pszFileName, NULL);

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z ; WaveLoader::CWaveFile::Open

; 337  :     }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?Open@CWaveFile@WaveLoader@@QAEJPBD@Z ENDP		; WaveLoader::CWaveFile::Open
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetFileType@CWaveFile@WaveLoader@@QAEJPAK@Z
_TEXT	SEGMENT
_pdwType$ = 8
_this$ = -4
?GetFileType@CWaveFile@WaveLoader@@QAEJPAK@Z PROC NEAR	; WaveLoader::CWaveFile::GetFileType, COMDAT
; _this$ = ecx

; 345  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 346  :         *pdwType = m_dwFileType;

  00007	8b 45 08	 mov	 eax, DWORD PTR _pdwType$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 347  :         return S_OK;

  00012	33 c0		 xor	 eax, eax

; 348  :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?GetFileType@CWaveFile@WaveLoader@@QAEJPAK@Z ENDP	; WaveLoader::CWaveFile::GetFileType
_TEXT	ENDS
PUBLIC	?GetDataOffset@CRiffChunk@WaveLoader@@QAEKXZ	; WaveLoader::CRiffChunk::GetDataOffset
; Function compile flags: /Odt
;	COMDAT ?GetDataOffset@CWaveFile@WaveLoader@@QAEJPAK@Z
_TEXT	SEGMENT
_pdwDataOffset$ = 8
_this$ = -4
?GetDataOffset@CWaveFile@WaveLoader@@QAEJPAK@Z PROC NEAR ; WaveLoader::CWaveFile::GetDataOffset, COMDAT
; _this$ = ecx

; 351  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 352  :         *pdwDataOffset = m_DataChunk.GetDataOffset();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 20	 add	 ecx, 32			; 00000020H
  0000d	e8 00 00 00 00	 call	 ?GetDataOffset@CRiffChunk@WaveLoader@@QAEKXZ ; WaveLoader::CRiffChunk::GetDataOffset
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _pdwDataOffset$[ebp]
  00015	89 01		 mov	 DWORD PTR [ecx], eax

; 353  :         return S_OK;

  00017	33 c0		 xor	 eax, eax

; 354  :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?GetDataOffset@CWaveFile@WaveLoader@@QAEJPAK@Z ENDP	; WaveLoader::CWaveFile::GetDataOffset
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetDataOffset@CRiffChunk@WaveLoader@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4
?GetDataOffset@CRiffChunk@WaveLoader@@QAEKXZ PROC NEAR	; WaveLoader::CRiffChunk::GetDataOffset, COMDAT
; _this$ = ecx

; 271  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 272  :         return m_dwDataOffset;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 273  :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetDataOffset@CRiffChunk@WaveLoader@@QAEKXZ ENDP	; WaveLoader::CRiffChunk::GetDataOffset
_TEXT	ENDS
PUBLIC	?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ	; WaveLoader::CRiffChunk::GetDataSize
; Function compile flags: /Odt
;	COMDAT ?GetDuration@CWaveFile@WaveLoader@@QAEJPAK@Z
_TEXT	SEGMENT
_pdwDuration$ = 8
_this$ = -4
?GetDuration@CWaveFile@WaveLoader@@QAEJPAK@Z PROC NEAR	; WaveLoader::CWaveFile::GetDuration, COMDAT
; _this$ = ecx

; 357  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 358  :         *pdwDuration = m_DataChunk.GetDataSize();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 20	 add	 ecx, 32			; 00000020H
  0000d	e8 00 00 00 00	 call	 ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ; WaveLoader::CRiffChunk::GetDataSize
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _pdwDuration$[ebp]
  00015	89 01		 mov	 DWORD PTR [ecx], eax

; 359  :         return S_OK;

  00017	33 c0		 xor	 eax, eax

; 360  :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?GetDuration@CWaveFile@WaveLoader@@QAEJPAK@Z ENDP	; WaveLoader::CWaveFile::GetDuration
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4
?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ PROC NEAR	; WaveLoader::CRiffChunk::GetDataSize, COMDAT
; _this$ = ecx

; 276  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 277  :         return m_dwDataSize;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 278  :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ENDP		; WaveLoader::CRiffChunk::GetDataSize
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\writer.cpp
_TEXT	ENDS
;	COMDAT ?GetValidFlags@CWaveBankEntry@@UAEKXZ
_TEXT	SEGMENT
_this$ = -8
_dwFlags$ = -4
?GetValidFlags@CWaveBankEntry@@UAEKXZ PROC NEAR		; CWaveBankEntry::GetValidFlags, COMDAT
; _this$ = ecx

; 733  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 734  :     DWORD                   dwFlags = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwFlags$[ebp], 0

; 735  :     
; 736  :     DPF_ENTER();
; 737  :     
; 738  :     if(CXboxAdpcmFilter::IsValidFormat(&m_Format))

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	05 14 03 00 00	 add	 eax, 788		; 00000314H
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?IsValidFormat@CXboxAdpcmFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ; CXboxAdpcmFilter::IsValidFormat
  0001e	85 c0		 test	 eax, eax
  00020	74 09		 je	 SHORT $L49128

; 739  :     {
; 740  :         dwFlags |= WBFILTER_ADPCM;

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00025	83 c9 01	 or	 ecx, 1
  00028	89 4d fc	 mov	 DWORD PTR _dwFlags$[ebp], ecx
$L49128:

; 741  :     }
; 742  : 
; 743  :     if(C8BitFilter::IsValidFormat(&m_Format))

  0002b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	81 c2 14 03 00
	00		 add	 edx, 788		; 00000314H
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ?IsValidFormat@C8BitFilter@@SGHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ; C8BitFilter::IsValidFormat
  0003a	85 c0		 test	 eax, eax
  0003c	74 08		 je	 SHORT $L49129

; 744  :     {
; 745  :         dwFlags |= WBFILTER_8BIT;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00041	0c 02		 or	 al, 2
  00043	89 45 fc	 mov	 DWORD PTR _dwFlags$[ebp], eax
$L49129:

; 746  :     }
; 747  : 
; 748  :     DPF_LEAVE(dwFlags);
; 749  : 
; 750  :     return dwFlags;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _dwFlags$[ebp]

; 751  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?GetValidFlags@CWaveBankEntry@@UAEKXZ ENDP		; CWaveBankEntry::GetValidFlags
_TEXT	ENDS
PUBLIC	??_C@_0BJ@IMJJ@CWaveBankEntry?3?3SetFlags?$AA@	; `string'
PUBLIC	??_C@_0DA@PLDD@ADPCM?5and?58BIT?5filtering?5are?5mut@ ; `string'
;	COMDAT ??_C@_0BJ@IMJJ@CWaveBankEntry?3?3SetFlags?$AA@
CONST	SEGMENT
??_C@_0BJ@IMJJ@CWaveBankEntry?3?3SetFlags?$AA@ DB 'CWaveBankEntry::SetFla'
	DB	'gs', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PLDD@ADPCM?5and?58BIT?5filtering?5are?5mut@
CONST	SEGMENT
??_C@_0DA@PLDD@ADPCM?5and?58BIT?5filtering?5are?5mut@ DB 'ADPCM and 8BIT '
	DB	'filtering are mutually exclusive', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetFlags@CWaveBankEntry@@UAEKKK@Z
_TEXT	SEGMENT
_dwMask$ = 8
_dwFlags$ = 12
_this$ = -4
?SetFlags@CWaveBankEntry@@UAEKKK@Z PROC NEAR		; CWaveBankEntry::SetFlags, COMDAT
; _this$ = ecx

; 780  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 781  :     DPF_ENTER();
; 782  : 
; 783  :     //
; 784  :     // Check the mask against what the filters can actually deal with
; 785  :     //
; 786  : 
; 787  :     dwMask &= GetValidFlags();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 10		 mov	 edx, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 52 0c	 call	 DWORD PTR [edx+12]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _dwMask$[ebp]
  00015	23 c8		 and	 ecx, eax
  00017	89 4d 08	 mov	 DWORD PTR _dwMask$[ebp], ecx

; 788  : 
; 789  :     //
; 790  :     // Mask off any unused bits
; 791  :     //
; 792  :     
; 793  :     dwFlags &= dwMask;

  0001a	8b 55 0c	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0001d	23 55 08	 and	 edx, DWORD PTR _dwMask$[ebp]
  00020	89 55 0c	 mov	 DWORD PTR _dwFlags$[ebp], edx

; 794  :     
; 795  :     //
; 796  :     // ADPCM and 8BIT are mutually exclusive
; 797  :     //
; 798  : 
; 799  :     if((dwFlags & WBFILTER_ADPCM) && (dwFlags & WBFILTER_8BIT))

  00023	8b 45 0c	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00026	83 e0 01	 and	 eax, 1
  00029	85 c0		 test	 eax, eax
  0002b	74 40		 je	 SHORT $L49135
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00030	83 e1 02	 and	 ecx, 2
  00033	85 c9		 test	 ecx, ecx
  00035	74 36		 je	 SHORT $L49135

; 800  :     {
; 801  :         DPF_WARNING("ADPCM and 8BIT filtering are mutually exclusive");

  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@IMJJ@CWaveBankEntry?3?3SetFlags?$AA@ ; `string'
  00041	68 21 03 00 00	 push	 801			; 00000321H
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004b	6a 03		 push	 3
  0004d	6a 09		 push	 9
  0004f	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00054	83 c4 18	 add	 esp, 24			; 00000018H
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DA@PLDD@ADPCM?5and?58BIT?5filtering?5are?5mut@ ; `string'
  0005c	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00061	83 c4 04	 add	 esp, 4

; 802  :         dwFlags &= ~WBFILTER_8BIT;

  00064	8b 55 0c	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00067	83 e2 fd	 and	 edx, -3			; fffffffdH
  0006a	89 55 0c	 mov	 DWORD PTR _dwFlags$[ebp], edx
$L49135:

; 803  :     }
; 804  : 
; 805  :     //
; 806  :     // Set the flags
; 807  :     //
; 808  : 
; 809  :     m_dwFlags &= ~dwMask;

  0006d	8b 45 08	 mov	 eax, DWORD PTR _dwMask$[ebp]
  00070	f7 d0		 not	 eax
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	8b 91 28 03 00
	00		 mov	 edx, DWORD PTR [ecx+808]
  0007b	23 d0		 and	 edx, eax
  0007d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00080	89 90 28 03 00
	00		 mov	 DWORD PTR [eax+808], edx

; 810  :     m_dwFlags |= dwFlags;

  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	8b 91 28 03 00
	00		 mov	 edx, DWORD PTR [ecx+808]
  0008f	0b 55 0c	 or	 edx, DWORD PTR _dwFlags$[ebp]
  00092	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00095	89 90 28 03 00
	00		 mov	 DWORD PTR [eax+808], edx

; 811  : 
; 812  :     DPF_LEAVE(dwFlags);
; 813  : 
; 814  :     return dwFlags;

  0009b	8b 45 0c	 mov	 eax, DWORD PTR _dwFlags$[ebp]

; 815  : }

  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 08 00	 ret	 8
?SetFlags@CWaveBankEntry@@UAEKKK@Z ENDP			; CWaveBankEntry::SetFlags
_TEXT	ENDS
PUBLIC	??_C@_0DP@EKHO@?$CB?$CI?$CIm_dwFlags?5?$CG?5WBFILTER_ADPCM?$CJ?5?$CG@ ; `string'
PUBLIC	?GetSize@C8BitFilter@@SGKKK@Z			; C8BitFilter::GetSize
;	COMDAT ??_C@_0DP@EKHO@?$CB?$CI?$CIm_dwFlags?5?$CG?5WBFILTER_ADPCM?$CJ?5?$CG@
CONST	SEGMENT
??_C@_0DP@EKHO@?$CB?$CI?$CIm_dwFlags?5?$CG?5WBFILTER_ADPCM?$CJ?5?$CG@ DB '!'
	DB	'((m_dwFlags & WBFILTER_ADPCM) && (m_dwFlags & WBFILTER_8BIT))'
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetMetaData@CWaveBankEntry@@UAEJPAU_WAVEBANKENTRY@@PAK@Z
_TEXT	SEGMENT
_pMetaData$ = 8
_pdwOffset$ = 12
_this$ = -4
?GetMetaData@CWaveBankEntry@@UAEJPAU_WAVEBANKENTRY@@PAK@Z PROC NEAR ; CWaveBankEntry::GetMetaData, COMDAT
; _this$ = ecx

; 843  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 844  :     static const DWORD      dwAlignment = 4;
; 845  :     
; 846  :     DPF_ENTER();
; 847  : 
; 848  :     ASSERT(!((m_dwFlags & WBFILTER_ADPCM) && (m_dwFlags & WBFILTER_8BIT)));

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  00012	83 e1 01	 and	 ecx, 1
  00015	85 c9		 test	 ecx, ecx
  00017	74 19		 je	 SHORT $L51538
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  00022	83 e0 02	 and	 eax, 2
  00025	85 c0		 test	 eax, eax
  00027	74 09		 je	 SHORT $L51538
  00029	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00030	eb 07		 jmp	 SHORT $L51539
$L51538:
  00032	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L51539:
  00039	68 50 03 00 00	 push	 848			; 00000350H
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00043	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@EKHO@?$CB?$CI?$CIm_dwFlags?5?$CG?5WBFILTER_ADPCM?$CJ?5?$CG@ ; `string'
  00048	8b 4d f8	 mov	 ecx, DWORD PTR -8+[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00051	83 c4 10	 add	 esp, 16			; 00000010H

; 849  : 
; 850  :     //
; 851  :     // If we're compressing, write the compressed format, not the source
; 852  :     //
; 853  : 
; 854  :     pMetaData->Format = m_Format;

  00054	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00057	8b 82 14 03 00
	00		 mov	 eax, DWORD PTR [edx+788]
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _pMetaData$[ebp]
  00060	89 01		 mov	 DWORD PTR [ecx], eax

; 855  :     
; 856  :     if(m_dwFlags & WBFILTER_ADPCM)

  00062	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00065	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  0006b	83 e0 01	 and	 eax, 1
  0006e	85 c0		 test	 eax, eax
  00070	74 21		 je	 SHORT $L49146

; 857  :     {
; 858  :         if(!CXboxAdpcmFilter::ConvertFormat(&pMetaData->Format))

  00072	8b 4d 08	 mov	 ecx, DWORD PTR _pMetaData$[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?ConvertFormat@CXboxAdpcmFilter@@SGHPAU_WAVEBANKMINIWAVEFORMAT@@@Z ; CXboxAdpcmFilter::ConvertFormat
  0007b	85 c0		 test	 eax, eax
  0007d	75 14		 jne	 SHORT $L49147

; 859  :         {
; 860  :             m_dwFlags &= ~WBFILTER_ADPCM;

  0007f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00082	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  00088	24 fe		 and	 al, -2			; fffffffeH
  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	89 81 28 03 00
	00		 mov	 DWORD PTR [ecx+808], eax
$L49147:
$L49146:

; 861  :         }
; 862  :     }
; 863  :     
; 864  :     if(m_dwFlags & WBFILTER_8BIT)

  00093	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00096	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  0009c	83 e0 02	 and	 eax, 2
  0009f	85 c0		 test	 eax, eax
  000a1	74 21		 je	 SHORT $L49148

; 865  :     {
; 866  :         if(!C8BitFilter::ConvertFormat(&pMetaData->Format))

  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _pMetaData$[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ?ConvertFormat@C8BitFilter@@SGHPAU_WAVEBANKMINIWAVEFORMAT@@@Z ; C8BitFilter::ConvertFormat
  000ac	85 c0		 test	 eax, eax
  000ae	75 14		 jne	 SHORT $L49149

; 867  :         {
; 868  :             m_dwFlags &= ~WBFILTER_8BIT;

  000b0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b3	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  000b9	24 fd		 and	 al, -3			; fffffffdH
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	89 81 28 03 00
	00		 mov	 DWORD PTR [ecx+808], eax
$L49149:
$L49148:

; 869  :         }
; 870  :     }
; 871  : 
; 872  :     //
; 873  :     // Block-align the file offset
; 874  :     //
; 875  :         
; 876  :     pMetaData->PlayRegion.dwStart = BLOCKALIGNPAD(*pdwOffset, dwAlignment);

  000c4	8b 55 0c	 mov	 edx, DWORD PTR _pdwOffset$[ebp]
  000c7	8b 02		 mov	 eax, DWORD PTR [edx]
  000c9	83 c0 03	 add	 eax, 3
  000cc	c1 e8 02	 shr	 eax, 2
  000cf	c1 e0 02	 shl	 eax, 2
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR _pMetaData$[ebp]
  000d5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 877  : 
; 878  :     //
; 879  :     // If we're compressing, calculate the compressed data size as well
; 880  :     //
; 881  : 
; 882  :     pMetaData->PlayRegion.dwLength = m_PlayRegion.dwLength;

  000d8	8b 55 08	 mov	 edx, DWORD PTR _pMetaData$[ebp]
  000db	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000de	8b 88 1c 03 00
	00		 mov	 ecx, DWORD PTR [eax+796]
  000e4	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 883  : 
; 884  :     if(m_dwFlags & WBFILTER_ADPCM)

  000e7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ea	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  000f0	83 e0 01	 and	 eax, 1
  000f3	85 c0		 test	 eax, eax
  000f5	74 23		 je	 SHORT $L49150

; 885  :     {
; 886  :         pMetaData->PlayRegion.dwLength = CXboxAdpcmFilter::GetSize(pMetaData->PlayRegion.dwLength, m_Format.nChannels, TRUE);

  000f7	6a 01		 push	 1
  000f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	8b 91 14 03 00
	00		 mov	 edx, DWORD PTR [ecx+788]
  00102	d1 ea		 shr	 edx, 1
  00104	83 e2 07	 and	 edx, 7
  00107	52		 push	 edx
  00108	8b 45 08	 mov	 eax, DWORD PTR _pMetaData$[ebp]
  0010b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0010e	51		 push	 ecx
  0010f	e8 00 00 00 00	 call	 ?GetSize@CXboxAdpcmFilter@@SGKKKH@Z ; CXboxAdpcmFilter::GetSize
  00114	8b 55 08	 mov	 edx, DWORD PTR _pMetaData$[ebp]
  00117	89 42 08	 mov	 DWORD PTR [edx+8], eax
$L49150:

; 887  :     }
; 888  :     
; 889  :     if(m_dwFlags & WBFILTER_8BIT)

  0011a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011d	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  00123	83 e1 02	 and	 ecx, 2
  00126	85 c9		 test	 ecx, ecx
  00128	74 21		 je	 SHORT $L49151

; 890  :     {
; 891  :         pMetaData->PlayRegion.dwLength = C8BitFilter::GetSize(pMetaData->PlayRegion.dwLength, m_Format.nChannels);

  0012a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0012d	8b 82 14 03 00
	00		 mov	 eax, DWORD PTR [edx+788]
  00133	d1 e8		 shr	 eax, 1
  00135	83 e0 07	 and	 eax, 7
  00138	50		 push	 eax
  00139	8b 4d 08	 mov	 ecx, DWORD PTR _pMetaData$[ebp]
  0013c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0013f	52		 push	 edx
  00140	e8 00 00 00 00	 call	 ?GetSize@C8BitFilter@@SGKKK@Z ; C8BitFilter::GetSize
  00145	8b 4d 08	 mov	 ecx, DWORD PTR _pMetaData$[ebp]
  00148	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L49151:

; 892  :     }
; 893  : 
; 894  :     //
; 895  :     // ... and the loop offsets
; 896  :     //
; 897  : 
; 898  :     pMetaData->LoopRegion = m_LoopRegion;

  0014b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0014e	8b 82 20 03 00
	00		 mov	 eax, DWORD PTR [edx+800]
  00154	8b 8a 24 03 00
	00		 mov	 ecx, DWORD PTR [edx+804]
  0015a	8b 55 08	 mov	 edx, DWORD PTR _pMetaData$[ebp]
  0015d	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00160	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 899  : 
; 900  :     if(m_dwFlags & WBFILTER_ADPCM)

  00163	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00166	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  0016c	83 e1 01	 and	 ecx, 1
  0016f	85 c9		 test	 ecx, ecx
  00171	74 46		 je	 SHORT $L49152

; 901  :     {
; 902  :         pMetaData->LoopRegion.dwStart = CXboxAdpcmFilter::GetSize(pMetaData->LoopRegion.dwStart, m_Format.nChannels);

  00173	6a 00		 push	 0
  00175	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00178	8b 82 14 03 00
	00		 mov	 eax, DWORD PTR [edx+788]
  0017e	d1 e8		 shr	 eax, 1
  00180	83 e0 07	 and	 eax, 7
  00183	50		 push	 eax
  00184	8b 4d 08	 mov	 ecx, DWORD PTR _pMetaData$[ebp]
  00187	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 ?GetSize@CXboxAdpcmFilter@@SGKKKH@Z ; CXboxAdpcmFilter::GetSize
  00190	8b 4d 08	 mov	 ecx, DWORD PTR _pMetaData$[ebp]
  00193	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 903  :         pMetaData->LoopRegion.dwLength = CXboxAdpcmFilter::GetSize(pMetaData->LoopRegion.dwLength, m_Format.nChannels);

  00196	6a 00		 push	 0
  00198	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0019b	8b 82 14 03 00
	00		 mov	 eax, DWORD PTR [edx+788]
  001a1	d1 e8		 shr	 eax, 1
  001a3	83 e0 07	 and	 eax, 7
  001a6	50		 push	 eax
  001a7	8b 4d 08	 mov	 ecx, DWORD PTR _pMetaData$[ebp]
  001aa	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  001ad	52		 push	 edx
  001ae	e8 00 00 00 00	 call	 ?GetSize@CXboxAdpcmFilter@@SGKKKH@Z ; CXboxAdpcmFilter::GetSize
  001b3	8b 4d 08	 mov	 ecx, DWORD PTR _pMetaData$[ebp]
  001b6	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$L49152:

; 904  :     }
; 905  :     
; 906  :     if(m_dwFlags & WBFILTER_8BIT)

  001b9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001bc	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  001c2	83 e0 02	 and	 eax, 2
  001c5	85 c0		 test	 eax, eax
  001c7	74 42		 je	 SHORT $L49153

; 907  :     {
; 908  :         pMetaData->LoopRegion.dwStart = C8BitFilter::GetSize(pMetaData->LoopRegion.dwStart, m_Format.nChannels);

  001c9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001cc	8b 91 14 03 00
	00		 mov	 edx, DWORD PTR [ecx+788]
  001d2	d1 ea		 shr	 edx, 1
  001d4	83 e2 07	 and	 edx, 7
  001d7	52		 push	 edx
  001d8	8b 45 08	 mov	 eax, DWORD PTR _pMetaData$[ebp]
  001db	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001de	51		 push	 ecx
  001df	e8 00 00 00 00	 call	 ?GetSize@C8BitFilter@@SGKKK@Z ; C8BitFilter::GetSize
  001e4	8b 55 08	 mov	 edx, DWORD PTR _pMetaData$[ebp]
  001e7	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 909  :         pMetaData->LoopRegion.dwLength = C8BitFilter::GetSize(pMetaData->LoopRegion.dwLength, m_Format.nChannels);

  001ea	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001ed	8b 88 14 03 00
	00		 mov	 ecx, DWORD PTR [eax+788]
  001f3	d1 e9		 shr	 ecx, 1
  001f5	83 e1 07	 and	 ecx, 7
  001f8	51		 push	 ecx
  001f9	8b 55 08	 mov	 edx, DWORD PTR _pMetaData$[ebp]
  001fc	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001ff	50		 push	 eax
  00200	e8 00 00 00 00	 call	 ?GetSize@C8BitFilter@@SGKKK@Z ; C8BitFilter::GetSize
  00205	8b 4d 08	 mov	 ecx, DWORD PTR _pMetaData$[ebp]
  00208	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$L49153:

; 910  :     }
; 911  : 
; 912  :     //
; 913  :     // Update the file offset
; 914  :     //
; 915  : 
; 916  :     *pdwOffset = pMetaData->PlayRegion.dwStart + pMetaData->PlayRegion.dwLength;

  0020b	8b 55 08	 mov	 edx, DWORD PTR _pMetaData$[ebp]
  0020e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00211	8b 4d 08	 mov	 ecx, DWORD PTR _pMetaData$[ebp]
  00214	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00217	8b 55 0c	 mov	 edx, DWORD PTR _pdwOffset$[ebp]
  0021a	89 02		 mov	 DWORD PTR [edx], eax

; 917  : 
; 918  :     DPF_LEAVE_HRESULT(S_OK);
; 919  : 
; 920  :     return S_OK;

  0021c	33 c0		 xor	 eax, eax

; 921  : }

  0021e	8b e5		 mov	 esp, ebp
  00220	5d		 pop	 ebp
  00221	c2 08 00	 ret	 8
?GetMetaData@CWaveBankEntry@@UAEJPAU_WAVEBANKENTRY@@PAK@Z ENDP ; CWaveBankEntry::GetMetaData
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\filter.h
_TEXT	ENDS
;	COMDAT ?GetSize@C8BitFilter@@SGKKK@Z
_TEXT	SEGMENT
_cbSource$ = 8
_nChannels$ = 12
?GetSize@C8BitFilter@@SGKKK@Z PROC NEAR			; C8BitFilter::GetSize, COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  :     return cbSource / (nChannels * 2) * nChannels;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _nChannels$[ebp]
  00006	d1 e1		 shl	 ecx, 1
  00008	8b 45 08	 mov	 eax, DWORD PTR _cbSource$[ebp]
  0000b	33 d2		 xor	 edx, edx
  0000d	f7 f1		 div	 ecx
  0000f	0f af 45 0c	 imul	 eax, DWORD PTR _nChannels$[ebp]

; 171  : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
?GetSize@C8BitFilter@@SGKKK@Z ENDP			; C8BitFilter::GetSize
_TEXT	ENDS
PUBLIC	??0CStdFileStream@WaveLoader@@QAE@XZ		; WaveLoader::CStdFileStream::CStdFileStream
PUBLIC	??1CStdFileStream@WaveLoader@@QAE@XZ		; WaveLoader::CStdFileStream::~CStdFileStream
PUBLIC	?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z	; WaveLoader::CStdFileStream::Open
PUBLIC	?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z	; WaveLoader::CStdFileStream::Read
PUBLIC	?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z	; WaveLoader::CStdFileStream::Write
PUBLIC	?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z	; WaveLoader::CStdFileStream::Seek
PUBLIC	?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm
PUBLIC	??_C@_0DD@LCBB@dwCopyBufferSize?5?$DO?$DN?5pMetaData?9?$DOP@ ; `string'
PUBLIC	??_C@_0BP@KNFK@CWaveBankEntry?3?3CommitWaveData?$AA@ ; `string'
PUBLIC	??_C@_0DO@FDBK@An?5error?5occurred?5while?5attempti@ ; `string'
PUBLIC	??_C@_0DO@PBMG@An?5error?5occurred?5while?5attempti@ ; `string'
PUBLIC	??_C@_0CG@ECLE@Failed?5to?5initialize?5the?5ADPCM?5f@ ; `string'
PUBLIC	??_C@_0CF@OCPI@Failed?5to?5initialize?5the?58BIT?5fi@ ; `string'
PUBLIC	??_C@_0CA@FLDH@dwCopyBufferSize?5?$DO?$DN?5dwAlignment?$AA@ ; `string'
PUBLIC	??_C@_0BO@NPAA@dwFilterRead?5?$DN?$DN?5dwAlignedRead?$AA@ ; `string'
PUBLIC	??_C@_0CN@EGPJ@An?5error?5occurred?5while?5compress@ ; `string'
PUBLIC	??_C@_0DN@HPGN@An?5error?5occurred?5while?5attempti@ ; `string'
PUBLIC	??_C@_0CF@NCIG@dwTotalRead?5?$DN?$DN?5m_PlayRegion?4dwLe@ ; `string'
PUBLIC	??_C@_0DB@BIEL@dwTotalWritten?5?$DN?$DN?5pMetaData?9?$DOPla@ ; `string'
EXTRN	_memset:NEAR
;	COMDAT ??_C@_0DD@LCBB@dwCopyBufferSize?5?$DO?$DN?5pMetaData?9?$DOP@
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\writer.cpp
CONST	SEGMENT
??_C@_0DD@LCBB@dwCopyBufferSize?5?$DO?$DN?5pMetaData?9?$DOP@ DB 'dwCopyBu'
	DB	'fferSize >= pMetaData->PlayRegion.dwLength', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KNFK@CWaveBankEntry?3?3CommitWaveData?$AA@
CONST	SEGMENT
??_C@_0BP@KNFK@CWaveBankEntry?3?3CommitWaveData?$AA@ DB 'CWaveBankEntry::'
	DB	'CommitWaveData', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@FDBK@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT
??_C@_0DO@FDBK@An?5error?5occurred?5while?5attempti@ DB 'An error occurre'
	DB	'd while attempting to read from the wave file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@PBMG@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT
??_C@_0DO@PBMG@An?5error?5occurred?5while?5attempti@ DB 'An error occurre'
	DB	'd while attempting to read from the bank file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@ECLE@Failed?5to?5initialize?5the?5ADPCM?5f@
CONST	SEGMENT
??_C@_0CG@ECLE@Failed?5to?5initialize?5the?5ADPCM?5f@ DB 'Failed to initi'
	DB	'alize the ADPCM filter', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OCPI@Failed?5to?5initialize?5the?58BIT?5fi@
CONST	SEGMENT
??_C@_0CF@OCPI@Failed?5to?5initialize?5the?58BIT?5fi@ DB 'Failed to initi'
	DB	'alize the 8BIT filter', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FLDH@dwCopyBufferSize?5?$DO?$DN?5dwAlignment?$AA@
CONST	SEGMENT
??_C@_0CA@FLDH@dwCopyBufferSize?5?$DO?$DN?5dwAlignment?$AA@ DB 'dwCopyBuf'
	DB	'ferSize >= dwAlignment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NPAA@dwFilterRead?5?$DN?$DN?5dwAlignedRead?$AA@
CONST	SEGMENT
??_C@_0BO@NPAA@dwFilterRead?5?$DN?$DN?5dwAlignedRead?$AA@ DB 'dwFilterRea'
	DB	'd == dwAlignedRead', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EGPJ@An?5error?5occurred?5while?5compress@
CONST	SEGMENT
??_C@_0CN@EGPJ@An?5error?5occurred?5while?5compress@ DB 'An error occurre'
	DB	'd while compressing PCM data', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HPGN@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT
??_C@_0DN@HPGN@An?5error?5occurred?5while?5attempti@ DB 'An error occurre'
	DB	'd while attempting to write to the bank file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NCIG@dwTotalRead?5?$DN?$DN?5m_PlayRegion?4dwLe@
CONST	SEGMENT
??_C@_0CF@NCIG@dwTotalRead?5?$DN?$DN?5m_PlayRegion?4dwLe@ DB 'dwTotalRead'
	DB	' == m_PlayRegion.dwLength', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BIEL@dwTotalWritten?5?$DN?$DN?5pMetaData?9?$DOPla@
CONST	SEGMENT
??_C@_0DB@BIEL@dwTotalWritten?5?$DN?$DN?5pMetaData?9?$DOPla@ DB 'dwTotalW'
	DB	'ritten == pMetaData->PlayRegion.dwLength', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CommitWaveData@CWaveBankEntry@@UAEJPAVCStdFileStream@WaveLoader@@KPBU_WAVEBANKENTRY@@PAXK@Z
_TEXT	SEGMENT
_pBankFile$ = 8
_dwBaseOffset$ = 12
_pMetaData$ = 16
_pvCopyBuffer$ = 20
_dwCopyBufferSize$ = 24
_this$ = -100
_dwTotalRead$ = -92
_dwTotalWritten$ = -20
_AdpcmFilter$ = -72
_BitFilter$ = -88
_WaveFile$ = -32
_dwAlignment$ = -8
_dwRead$ = -16
_dwWritten$ = -12
_dwAlignedRead$ = -24
_dwFilterRead$ = -76
_hr$ = -80
$T51550 = -96
?CommitWaveData@CWaveBankEntry@@UAEJPAVCStdFileStream@WaveLoader@@KPBU_WAVEBANKENTRY@@PAXK@Z PROC NEAR ; CWaveBankEntry::CommitWaveData, COMDAT
; _this$ = ecx

; 955  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	89 4d 9c	 mov	 DWORD PTR _this$[ebp], ecx

; 956  :     DWORD                   dwTotalRead     = 0;

  00009	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _dwTotalRead$[ebp], 0

; 957  :     DWORD                   dwTotalWritten  = 0;

  00010	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwTotalWritten$[ebp], 0

; 958  :     CXboxAdpcmFilter        AdpcmFilter;

  00017	8d 4d b8	 lea	 ecx, DWORD PTR _AdpcmFilter$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0CXboxAdpcmFilter@@QAE@XZ ; CXboxAdpcmFilter::CXboxAdpcmFilter

; 959  :     C8BitFilter             BitFilter;

  0001f	8d 4d a8	 lea	 ecx, DWORD PTR _BitFilter$[ebp]
  00022	e8 00 00 00 00	 call	 ??0C8BitFilter@@QAE@XZ	; C8BitFilter::C8BitFilter

; 960  :     CStdFileStream          WaveFile;

  00027	8d 4d e0	 lea	 ecx, DWORD PTR _WaveFile$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::CStdFileStream

; 961  :     DWORD                   dwAlignment;
; 962  :     DWORD                   dwRead;
; 963  :     DWORD                   dwWritten;
; 964  :     DWORD                   dwAlignedRead;
; 965  :     DWORD                   dwFilterRead;
; 966  :     DWORD                   dwFileType;
; 967  :     HRESULT                 hr;
; 968  :     
; 969  :     DPF_ENTER();
; 970  : 
; 971  :     ASSERT(!((m_dwFlags & WBFILTER_ADPCM) && (m_dwFlags & WBFILTER_8BIT)));

  0002f	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  00038	83 e1 01	 and	 ecx, 1
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 19		 je	 SHORT $L51546
  0003f	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  00042	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  00048	83 e0 02	 and	 eax, 2
  0004b	85 c0		 test	 eax, eax
  0004d	74 09		 je	 SHORT $L51546
  0004f	c7 45 98 01 00
	00 00		 mov	 DWORD PTR -104+[ebp], 1
  00056	eb 07		 jmp	 SHORT $L51547
$L51546:
  00058	c7 45 98 00 00
	00 00		 mov	 DWORD PTR -104+[ebp], 0
$L51547:
  0005f	68 cb 03 00 00	 push	 971			; 000003cbH
  00064	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00069	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@EKHO@?$CB?$CI?$CIm_dwFlags?5?$CG?5WBFILTER_ADPCM?$CJ?5?$CG@ ; `string'
  0006e	8b 4d 98	 mov	 ecx, DWORD PTR -104+[ebp]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00077	83 c4 10	 add	 esp, 16			; 00000010H

; 972  : 
; 973  :     if(!pBankFile)

  0007a	83 7d 08 00	 cmp	 DWORD PTR _pBankFile$[ebp], 0
  0007e	75 25		 jne	 SHORT $L49175

; 974  :     {
; 975  :         ASSERT(dwCopyBufferSize >= pMetaData->PlayRegion.dwLength);

  00080	68 cf 03 00 00	 push	 975			; 000003cfH
  00085	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@LCBB@dwCopyBufferSize?5?$DO?$DN?5pMetaData?9?$DOP@ ; `string'
  0008f	8b 55 10	 mov	 edx, DWORD PTR _pMetaData$[ebp]
  00092	8b 45 18	 mov	 eax, DWORD PTR _dwCopyBufferSize$[ebp]
  00095	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00098	1b c9		 sbb	 ecx, ecx
  0009a	f7 d9		 neg	 ecx
  0009c	51		 push	 ecx
  0009d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000a2	83 c4 10	 add	 esp, 16			; 00000010H
$L49175:

; 976  :     }
; 977  : 
; 978  :     //
; 979  :     // Open the source file and seek to the start of the data chunk
; 980  :     //
; 981  : 
; 982  :     if(FAILED(hr = WaveFile.Open(m_szFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN)))

  000a5	68 00 00 00 08	 push	 134217728		; 08000000H
  000aa	6a 03		 push	 3
  000ac	6a 01		 push	 1
  000ae	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000b3	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  000b6	81 c2 10 02 00
	00		 add	 edx, 528		; 00000210H
  000bc	52		 push	 edx
  000bd	8d 4d e0	 lea	 ecx, DWORD PTR _WaveFile$[ebp]
  000c0	e8 00 00 00 00	 call	 ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z ; WaveLoader::CStdFileStream::Open
  000c5	89 45 b0	 mov	 DWORD PTR _hr$[ebp], eax
  000c8	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000cc	7d 36		 jge	 SHORT $L49178

; 983  :     {
; 984  :         DPF_ERROR("An error occurred while attempting to open %s", m_szFileName);

  000ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000d3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@KNFK@CWaveBankEntry?3?3CommitWaveData?$AA@ ; `string'
  000d8	68 d8 03 00 00	 push	 984			; 000003d8H
  000dd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000e2	6a 01		 push	 1
  000e4	6a 09		 push	 9
  000e6	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000eb	83 c4 18	 add	 esp, 24			; 00000018H
  000ee	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	05 10 02 00 00	 add	 eax, 528		; 00000210H
  000f6	50		 push	 eax
  000f7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CO@EFJM@An?5error?5occurred?5while?5attempti@ ; `string'
  000fc	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00101	83 c4 08	 add	 esp, 8
$L49178:

; 985  :     }
; 986  : 
; 987  :     if(SUCCEEDED(hr))

  00104	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00108	7c 4c		 jl	 SHORT $L49181

; 988  :     {
; 989  :         if(FAILED(hr = WaveFile.Seek(m_PlayRegion.dwStart, FILE_BEGIN)))

  0010a	6a 00		 push	 0
  0010c	6a 00		 push	 0
  0010e	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00111	8b 91 18 03 00
	00		 mov	 edx, DWORD PTR [ecx+792]
  00117	52		 push	 edx
  00118	8d 4d e0	 lea	 ecx, DWORD PTR _WaveFile$[ebp]
  0011b	e8 00 00 00 00	 call	 ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z ; WaveLoader::CStdFileStream::Seek
  00120	89 45 b0	 mov	 DWORD PTR _hr$[ebp], eax
  00123	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00127	7d 2d		 jge	 SHORT $L49183

; 990  :         {
; 991  :             DPF_ERROR("An error occurred while attempting to read from the wave file");

  00129	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0012e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@KNFK@CWaveBankEntry?3?3CommitWaveData?$AA@ ; `string'
  00133	68 df 03 00 00	 push	 991			; 000003dfH
  00138	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0013d	6a 01		 push	 1
  0013f	6a 09		 push	 9
  00141	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00146	83 c4 18	 add	 esp, 24			; 00000018H
  00149	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@FDBK@An?5error?5occurred?5while?5attempti@ ; `string'
  0014e	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00153	83 c4 04	 add	 esp, 4
$L49183:
$L49181:

; 992  :         }
; 993  :     }
; 994  : 
; 995  :     //
; 996  :     // Seek to the proper location in the destination file
; 997  :     //
; 998  : 
; 999  :     if(SUCCEEDED(hr))

  00156	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0015a	7c 4c		 jl	 SHORT $L49186

; 1000 :     {
; 1001 :         if(FAILED(hr = pBankFile->Seek(dwBaseOffset + pMetaData->PlayRegion.dwStart, FILE_BEGIN)))

  0015c	6a 00		 push	 0
  0015e	6a 00		 push	 0
  00160	8b 45 10	 mov	 eax, DWORD PTR _pMetaData$[ebp]
  00163	8b 4d 0c	 mov	 ecx, DWORD PTR _dwBaseOffset$[ebp]
  00166	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00169	51		 push	 ecx
  0016a	8b 4d 08	 mov	 ecx, DWORD PTR _pBankFile$[ebp]
  0016d	e8 00 00 00 00	 call	 ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z ; WaveLoader::CStdFileStream::Seek
  00172	89 45 b0	 mov	 DWORD PTR _hr$[ebp], eax
  00175	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00179	7d 2d		 jge	 SHORT $L49188

; 1002 :         {
; 1003 :             DPF_ERROR("An error occurred while attempting to read from the bank file");

  0017b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00180	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@KNFK@CWaveBankEntry?3?3CommitWaveData?$AA@ ; `string'
  00185	68 eb 03 00 00	 push	 1003			; 000003ebH
  0018a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0018f	6a 01		 push	 1
  00191	6a 09		 push	 9
  00193	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00198	83 c4 18	 add	 esp, 24			; 00000018H
  0019b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@PBMG@An?5error?5occurred?5while?5attempti@ ; `string'
  001a0	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001a5	83 c4 04	 add	 esp, 4
$L49188:
$L49186:

; 1004 :         }
; 1005 :     }
; 1006 : 
; 1007 :     //
; 1008 :     // Initialize the ADPCM filter
; 1009 :     //
; 1010 : 
; 1011 :     if(SUCCEEDED(hr) && (m_dwFlags & WBFILTER_ADPCM))

  001a8	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001ac	7c 5a		 jl	 SHORT $L49191
  001ae	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  001b1	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  001b7	83 e0 01	 and	 eax, 1
  001ba	85 c0		 test	 eax, eax
  001bc	74 4a		 je	 SHORT $L49191

; 1012 :     {
; 1013 :         if(!AdpcmFilter.Initialize(&m_Format))

  001be	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  001c1	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  001c7	51		 push	 ecx
  001c8	8d 4d b8	 lea	 ecx, DWORD PTR _AdpcmFilter$[ebp]
  001cb	e8 00 00 00 00	 call	 ?Initialize@CXboxAdpcmFilter@@UAEHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ; CXboxAdpcmFilter::Initialize
  001d0	85 c0		 test	 eax, eax
  001d2	75 34		 jne	 SHORT $L49192

; 1014 :         {
; 1015 :             DPF_ERROR("Failed to initialize the ADPCM filter");

  001d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  001d9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@KNFK@CWaveBankEntry?3?3CommitWaveData?$AA@ ; `string'
  001de	68 f7 03 00 00	 push	 1015			; 000003f7H
  001e3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  001e8	6a 01		 push	 1
  001ea	6a 09		 push	 9
  001ec	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  001f1	83 c4 18	 add	 esp, 24			; 00000018H
  001f4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@ECLE@Failed?5to?5initialize?5the?5ADPCM?5f@ ; `string'
  001f9	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001fe	83 c4 04	 add	 esp, 4

; 1016 :             hr = E_FAIL;

  00201	c7 45 b0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49192:
$L49191:

; 1017 :         }
; 1018 :     }
; 1019 : 
; 1020 :     //
; 1021 :     // Initialize the 8BIT filter
; 1022 :     //
; 1023 : 
; 1024 :     if(SUCCEEDED(hr) && (m_dwFlags & WBFILTER_8BIT))

  00208	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0020c	7c 5a		 jl	 SHORT $L49196
  0020e	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  00211	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  00217	83 e0 02	 and	 eax, 2
  0021a	85 c0		 test	 eax, eax
  0021c	74 4a		 je	 SHORT $L49196

; 1025 :     {
; 1026 :         if(!BitFilter.Initialize(&m_Format))

  0021e	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00221	81 c1 14 03 00
	00		 add	 ecx, 788		; 00000314H
  00227	51		 push	 ecx
  00228	8d 4d a8	 lea	 ecx, DWORD PTR _BitFilter$[ebp]
  0022b	e8 00 00 00 00	 call	 ?Initialize@C8BitFilter@@UAEHPBU_WAVEBANKMINIWAVEFORMAT@@@Z ; C8BitFilter::Initialize
  00230	85 c0		 test	 eax, eax
  00232	75 34		 jne	 SHORT $L49197

; 1027 :         {
; 1028 :             DPF_ERROR("Failed to initialize the 8BIT filter");

  00234	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00239	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@KNFK@CWaveBankEntry?3?3CommitWaveData?$AA@ ; `string'
  0023e	68 04 04 00 00	 push	 1028			; 00000404H
  00243	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00248	6a 01		 push	 1
  0024a	6a 09		 push	 9
  0024c	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00251	83 c4 18	 add	 esp, 24			; 00000018H
  00254	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@OCPI@Failed?5to?5initialize?5the?58BIT?5fi@ ; `string'
  00259	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0025e	83 c4 04	 add	 esp, 4

; 1029 :             hr = E_FAIL;

  00261	c7 45 b0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49197:
$L49196:

; 1030 :         }
; 1031 :     }
; 1032 : 
; 1033 :     //
; 1034 :     // Get the filter alignment so we never have to seek backwards in the
; 1035 :     // file due to converting less data than we read.
; 1036 :     //
; 1037 : 
; 1038 :     if(SUCCEEDED(hr))

  00268	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0026c	0f 8c 89 00 00
	00		 jl	 $L49201

; 1039 :     {
; 1040 :         if(m_dwFlags & WBFILTER_ADPCM)

  00272	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  00275	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  0027b	83 e0 01	 and	 eax, 1
  0027e	85 c0		 test	 eax, eax
  00280	74 0d		 je	 SHORT $L49202

; 1041 :         {
; 1042 :             dwAlignment = AdpcmFilter.GetSourceAlignment();

  00282	8d 4d b8	 lea	 ecx, DWORD PTR _AdpcmFilter$[ebp]
  00285	e8 00 00 00 00	 call	 ?GetSourceAlignment@CXboxAdpcmFilter@@UAEKXZ ; CXboxAdpcmFilter::GetSourceAlignment
  0028a	89 45 f8	 mov	 DWORD PTR _dwAlignment$[ebp], eax

; 1043 :         }
; 1044 :         else if(m_dwFlags & WBFILTER_8BIT)

  0028d	eb 4a		 jmp	 SHORT $L49203
$L49202:
  0028f	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00292	8b 91 28 03 00
	00		 mov	 edx, DWORD PTR [ecx+808]
  00298	83 e2 02	 and	 edx, 2
  0029b	85 d2		 test	 edx, edx
  0029d	74 0d		 je	 SHORT $L49204

; 1045 :         {
; 1046 :             dwAlignment = BitFilter.GetSourceAlignment();

  0029f	8d 4d a8	 lea	 ecx, DWORD PTR _BitFilter$[ebp]
  002a2	e8 00 00 00 00	 call	 ?GetSourceAlignment@C8BitFilter@@UAEKXZ ; C8BitFilter::GetSourceAlignment
  002a7	89 45 f8	 mov	 DWORD PTR _dwAlignment$[ebp], eax

; 1047 :         }
; 1048 :         else

  002aa	eb 2d		 jmp	 SHORT $L49205
$L49204:

; 1049 :         {
; 1050 :             dwAlignment = m_Format.nChannels;

  002ac	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  002af	8b 88 14 03 00
	00		 mov	 ecx, DWORD PTR [eax+788]
  002b5	d1 e9		 shr	 ecx, 1
  002b7	83 e1 07	 and	 ecx, 7
  002ba	89 4d f8	 mov	 DWORD PTR _dwAlignment$[ebp], ecx

; 1051 :             
; 1052 :             if(WAVEBANKMINIFORMAT_BITDEPTH_16 == m_Format.wBitsPerSample)

  002bd	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  002c0	8b 82 14 03 00
	00		 mov	 eax, DWORD PTR [edx+788]
  002c6	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002c9	83 e0 01	 and	 eax, 1
  002cc	83 f8 01	 cmp	 eax, 1
  002cf	75 08		 jne	 SHORT $L49206

; 1053 :             {
; 1054 :                 dwAlignment *= 2;

  002d1	8b 4d f8	 mov	 ecx, DWORD PTR _dwAlignment$[ebp]
  002d4	d1 e1		 shl	 ecx, 1
  002d6	89 4d f8	 mov	 DWORD PTR _dwAlignment$[ebp], ecx
$L49206:
$L49205:
$L49203:

; 1055 :             }
; 1056 :         }
; 1057 : 
; 1058 :         ASSERT(dwCopyBufferSize >= dwAlignment);

  002d9	68 22 04 00 00	 push	 1058			; 00000422H
  002de	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  002e3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@FLDH@dwCopyBufferSize?5?$DO?$DN?5dwAlignment?$AA@ ; `string'
  002e8	8b 55 18	 mov	 edx, DWORD PTR _dwCopyBufferSize$[ebp]
  002eb	3b 55 f8	 cmp	 edx, DWORD PTR _dwAlignment$[ebp]
  002ee	1b c0		 sbb	 eax, eax
  002f0	f7 d8		 neg	 eax
  002f2	50		 push	 eax
  002f3	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  002f8	83 c4 10	 add	 esp, 16			; 00000010H
$L49201:
$L49209:

; 1059 :     }
; 1060 : 
; 1061 :     //
; 1062 :     // Start copying data
; 1063 :     //
; 1064 : 
; 1065 :     while(SUCCEEDED(hr) && (dwTotalRead < m_PlayRegion.dwLength))

  002fb	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002ff	0f 8c 8e 02 00
	00		 jl	 $L49210
  00305	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00308	8b 55 a4	 mov	 edx, DWORD PTR _dwTotalRead$[ebp]
  0030b	3b 91 1c 03 00
	00		 cmp	 edx, DWORD PTR [ecx+796]
  00311	0f 83 7c 02 00
	00		 jae	 $L49210

; 1066 :     {
; 1067 :         //
; 1068 :         // Don't read past the end of the file
; 1069 :         //
; 1070 : 
; 1071 :         dwRead = min(dwCopyBufferSize, m_PlayRegion.dwLength - dwTotalRead);

  00317	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  0031a	8b 88 1c 03 00
	00		 mov	 ecx, DWORD PTR [eax+796]
  00320	2b 4d a4	 sub	 ecx, DWORD PTR _dwTotalRead$[ebp]
  00323	39 4d 18	 cmp	 DWORD PTR _dwCopyBufferSize$[ebp], ecx
  00326	73 08		 jae	 SHORT $L51548
  00328	8b 55 18	 mov	 edx, DWORD PTR _dwCopyBufferSize$[ebp]
  0032b	89 55 94	 mov	 DWORD PTR -108+[ebp], edx
  0032e	eb 0f		 jmp	 SHORT $L51549
$L51548:
  00330	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  00333	8b 88 1c 03 00
	00		 mov	 ecx, DWORD PTR [eax+796]
  00339	2b 4d a4	 sub	 ecx, DWORD PTR _dwTotalRead$[ebp]
  0033c	89 4d 94	 mov	 DWORD PTR -108+[ebp], ecx
$L51549:
  0033f	8b 55 94	 mov	 edx, DWORD PTR -108+[ebp]
  00342	89 55 f0	 mov	 DWORD PTR _dwRead$[ebp], edx

; 1072 : 
; 1073 :         //
; 1074 :         // Align the read amount so we never have to seek backwards in the
; 1075 :         // file due to converting less data than we read.  If there isn't
; 1076 :         // enough data left in the file to satisfy the alignment, pad with
; 1077 :         // silence.
; 1078 :         //
; 1079 : 
; 1080 :         if(dwRead >= dwAlignment)

  00345	8b 45 f0	 mov	 eax, DWORD PTR _dwRead$[ebp]
  00348	3b 45 f8	 cmp	 eax, DWORD PTR _dwAlignment$[ebp]
  0034b	72 17		 jb	 SHORT $L49212

; 1081 :         {
; 1082 :             dwRead = dwAlignedRead = BLOCKALIGN(dwRead, dwAlignment);

  0034d	8b 45 f0	 mov	 eax, DWORD PTR _dwRead$[ebp]
  00350	33 d2		 xor	 edx, edx
  00352	f7 75 f8	 div	 DWORD PTR _dwAlignment$[ebp]
  00355	0f af 45 f8	 imul	 eax, DWORD PTR _dwAlignment$[ebp]
  00359	89 45 e8	 mov	 DWORD PTR _dwAlignedRead$[ebp], eax
  0035c	8b 4d e8	 mov	 ecx, DWORD PTR _dwAlignedRead$[ebp]
  0035f	89 4d f0	 mov	 DWORD PTR _dwRead$[ebp], ecx

; 1083 :         }
; 1084 :         else

  00362	eb 16		 jmp	 SHORT $L49213
$L49212:

; 1085 :         {
; 1086 :             dwAlignedRead = BLOCKALIGNPAD(dwRead, dwAlignment);

  00364	8b 55 f8	 mov	 edx, DWORD PTR _dwAlignment$[ebp]
  00367	8b 45 f0	 mov	 eax, DWORD PTR _dwRead$[ebp]
  0036a	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  0036e	33 d2		 xor	 edx, edx
  00370	f7 75 f8	 div	 DWORD PTR _dwAlignment$[ebp]
  00373	0f af 45 f8	 imul	 eax, DWORD PTR _dwAlignment$[ebp]
  00377	89 45 e8	 mov	 DWORD PTR _dwAlignedRead$[ebp], eax
$L49213:

; 1087 :         }
; 1088 : 
; 1089 :         dwWritten = dwAlignedRead;

  0037a	8b 4d e8	 mov	 ecx, DWORD PTR _dwAlignedRead$[ebp]
  0037d	89 4d f4	 mov	 DWORD PTR _dwWritten$[ebp], ecx

; 1090 : 
; 1091 :         //
; 1092 :         // Read source data
; 1093 :         //
; 1094 :         
; 1095 :         hr = WaveFile.Read(pvCopyBuffer, dwRead);

  00380	6a 00		 push	 0
  00382	8b 55 f0	 mov	 edx, DWORD PTR _dwRead$[ebp]
  00385	52		 push	 edx
  00386	8b 45 14	 mov	 eax, DWORD PTR _pvCopyBuffer$[ebp]
  00389	50		 push	 eax
  0038a	8d 4d e0	 lea	 ecx, DWORD PTR _WaveFile$[ebp]
  0038d	e8 00 00 00 00	 call	 ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z ; WaveLoader::CStdFileStream::Read
  00392	89 45 b0	 mov	 DWORD PTR _hr$[ebp], eax

; 1096 : 
; 1097 :         //
; 1098 :         // Convert if AIFF PCM
; 1099 :         //
; 1100 : 
; 1101 :         if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType))

  00395	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00399	7c 35		 jl	 SHORT $L49215
  0039b	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  0039e	83 b9 2c 03 00
	00 01		 cmp	 DWORD PTR [ecx+812], 1
  003a5	75 29		 jne	 SHORT $L49215

; 1102 :         {
; 1103 :             CWaveFile::ConvertAiffPcm(pvCopyBuffer, dwRead, (WAVEBANKMINIFORMAT_BITDEPTH_16 == m_Format.wBitsPerSample) ? 16 : 8);

  003a7	8b 55 9c	 mov	 edx, DWORD PTR _this$[ebp]
  003aa	8b 82 14 03 00
	00		 mov	 eax, DWORD PTR [edx+788]
  003b0	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  003b3	83 e0 01	 and	 eax, 1
  003b6	83 e8 01	 sub	 eax, 1
  003b9	f7 d8		 neg	 eax
  003bb	1b c0		 sbb	 eax, eax
  003bd	24 f8		 and	 al, -8			; fffffff8H
  003bf	83 c0 10	 add	 eax, 16			; 00000010H
  003c2	50		 push	 eax
  003c3	8b 4d f0	 mov	 ecx, DWORD PTR _dwRead$[ebp]
  003c6	51		 push	 ecx
  003c7	8b 55 14	 mov	 edx, DWORD PTR _pvCopyBuffer$[ebp]
  003ca	52		 push	 edx
  003cb	e8 00 00 00 00	 call	 ?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm
$L49215:

; 1104 :         }
; 1105 : 
; 1106 :         //
; 1107 :         // Pad with silence if necessary
; 1108 :         //
; 1109 : 
; 1110 :         if(SUCCEEDED(hr) && (dwAlignedRead > dwRead))

  003d0	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  003d4	7c 20		 jl	 SHORT $L49217
  003d6	8b 45 e8	 mov	 eax, DWORD PTR _dwAlignedRead$[ebp]
  003d9	3b 45 f0	 cmp	 eax, DWORD PTR _dwRead$[ebp]
  003dc	76 18		 jbe	 SHORT $L49217

; 1111 :         {
; 1112 :             ZeroMemory((LPBYTE)pvCopyBuffer + dwRead, dwAlignedRead - dwRead);

  003de	8b 4d e8	 mov	 ecx, DWORD PTR _dwAlignedRead$[ebp]
  003e1	2b 4d f0	 sub	 ecx, DWORD PTR _dwRead$[ebp]
  003e4	51		 push	 ecx
  003e5	6a 00		 push	 0
  003e7	8b 55 14	 mov	 edx, DWORD PTR _pvCopyBuffer$[ebp]
  003ea	03 55 f0	 add	 edx, DWORD PTR _dwRead$[ebp]
  003ed	52		 push	 edx
  003ee	e8 00 00 00 00	 call	 _memset
  003f3	83 c4 0c	 add	 esp, 12			; 0000000cH
$L49217:

; 1113 :         }
; 1114 :         
; 1115 :         //
; 1116 :         // Convert (or not)
; 1117 :         //
; 1118 : 
; 1119 :         if(SUCCEEDED(hr) && (m_dwFlags & WBFILTER_ADPCM))

  003f6	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  003fa	0f 8c 8b 00 00
	00		 jl	 $L49220
  00400	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  00403	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  00409	83 e1 01	 and	 ecx, 1
  0040c	85 c9		 test	 ecx, ecx
  0040e	74 7b		 je	 SHORT $L49220

; 1120 :         {
; 1121 :             dwFilterRead = dwAlignedRead;

  00410	8b 55 e8	 mov	 edx, DWORD PTR _dwAlignedRead$[ebp]
  00413	89 55 b4	 mov	 DWORD PTR _dwFilterRead$[ebp], edx

; 1122 :             
; 1123 :             if(AdpcmFilter.Convert(pvCopyBuffer, &dwFilterRead, pvCopyBuffer, &dwWritten))

  00416	8d 45 f4	 lea	 eax, DWORD PTR _dwWritten$[ebp]
  00419	50		 push	 eax
  0041a	8b 4d 14	 mov	 ecx, DWORD PTR _pvCopyBuffer$[ebp]
  0041d	51		 push	 ecx
  0041e	8d 55 b4	 lea	 edx, DWORD PTR _dwFilterRead$[ebp]
  00421	52		 push	 edx
  00422	8b 45 14	 mov	 eax, DWORD PTR _pvCopyBuffer$[ebp]
  00425	50		 push	 eax
  00426	8d 4d b8	 lea	 ecx, DWORD PTR _AdpcmFilter$[ebp]
  00429	e8 00 00 00 00	 call	 ?Convert@CXboxAdpcmFilter@@UAEHPBXPAKPAX1@Z ; CXboxAdpcmFilter::Convert
  0042e	85 c0		 test	 eax, eax
  00430	74 25		 je	 SHORT $L49221

; 1124 :             {
; 1125 :                 ASSERT(dwFilterRead == dwAlignedRead);

  00432	68 65 04 00 00	 push	 1125			; 00000465H
  00437	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0043c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@NPAA@dwFilterRead?5?$DN?$DN?5dwAlignedRead?$AA@ ; `string'
  00441	8b 4d b4	 mov	 ecx, DWORD PTR _dwFilterRead$[ebp]
  00444	33 d2		 xor	 edx, edx
  00446	3b 4d e8	 cmp	 ecx, DWORD PTR _dwAlignedRead$[ebp]
  00449	0f 95 c2	 setne	 dl
  0044c	52		 push	 edx
  0044d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00452	83 c4 10	 add	 esp, 16			; 00000010H

; 1126 :             }
; 1127 :             else

  00455	eb 34		 jmp	 SHORT $L49223
$L49221:

; 1128 :             {
; 1129 :                 DPF_ERROR("An error occurred while compressing PCM data");

  00457	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0045c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@KNFK@CWaveBankEntry?3?3CommitWaveData?$AA@ ; `string'
  00461	68 69 04 00 00	 push	 1129			; 00000469H
  00466	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0046b	6a 01		 push	 1
  0046d	6a 09		 push	 9
  0046f	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00474	83 c4 18	 add	 esp, 24			; 00000018H
  00477	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@EGPJ@An?5error?5occurred?5while?5compress@ ; `string'
  0047c	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00481	83 c4 04	 add	 esp, 4

; 1130 :                 hr = E_FAIL;

  00484	c7 45 b0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49223:
$L49220:

; 1131 :             }
; 1132 :         }
; 1133 :             
; 1134 :         if(SUCCEEDED(hr) && (m_dwFlags & WBFILTER_8BIT))

  0048b	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0048f	0f 8c 8b 00 00
	00		 jl	 $L49227
  00495	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  00498	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  0049e	83 e1 02	 and	 ecx, 2
  004a1	85 c9		 test	 ecx, ecx
  004a3	74 7b		 je	 SHORT $L49227

; 1135 :         {
; 1136 :             dwFilterRead = dwAlignedRead;

  004a5	8b 55 e8	 mov	 edx, DWORD PTR _dwAlignedRead$[ebp]
  004a8	89 55 b4	 mov	 DWORD PTR _dwFilterRead$[ebp], edx

; 1137 :             
; 1138 :             if(BitFilter.Convert(pvCopyBuffer, &dwFilterRead, pvCopyBuffer, &dwWritten))

  004ab	8d 45 f4	 lea	 eax, DWORD PTR _dwWritten$[ebp]
  004ae	50		 push	 eax
  004af	8b 4d 14	 mov	 ecx, DWORD PTR _pvCopyBuffer$[ebp]
  004b2	51		 push	 ecx
  004b3	8d 55 b4	 lea	 edx, DWORD PTR _dwFilterRead$[ebp]
  004b6	52		 push	 edx
  004b7	8b 45 14	 mov	 eax, DWORD PTR _pvCopyBuffer$[ebp]
  004ba	50		 push	 eax
  004bb	8d 4d a8	 lea	 ecx, DWORD PTR _BitFilter$[ebp]
  004be	e8 00 00 00 00	 call	 ?Convert@C8BitFilter@@UAEHPBXPAKPAX1@Z ; C8BitFilter::Convert
  004c3	85 c0		 test	 eax, eax
  004c5	74 25		 je	 SHORT $L49228

; 1139 :             {
; 1140 :                 ASSERT(dwFilterRead == dwAlignedRead);

  004c7	68 74 04 00 00	 push	 1140			; 00000474H
  004cc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  004d1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@NPAA@dwFilterRead?5?$DN?$DN?5dwAlignedRead?$AA@ ; `string'
  004d6	8b 4d b4	 mov	 ecx, DWORD PTR _dwFilterRead$[ebp]
  004d9	33 d2		 xor	 edx, edx
  004db	3b 4d e8	 cmp	 ecx, DWORD PTR _dwAlignedRead$[ebp]
  004de	0f 95 c2	 setne	 dl
  004e1	52		 push	 edx
  004e2	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  004e7	83 c4 10	 add	 esp, 16			; 00000010H

; 1141 :             }
; 1142 :             else

  004ea	eb 34		 jmp	 SHORT $L49229
$L49228:

; 1143 :             {
; 1144 :                 DPF_ERROR("An error occurred while compressing PCM data");

  004ec	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  004f1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@KNFK@CWaveBankEntry?3?3CommitWaveData?$AA@ ; `string'
  004f6	68 78 04 00 00	 push	 1144			; 00000478H
  004fb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00500	6a 01		 push	 1
  00502	6a 09		 push	 9
  00504	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00509	83 c4 18	 add	 esp, 24			; 00000018H
  0050c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@EGPJ@An?5error?5occurred?5while?5compress@ ; `string'
  00511	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00516	83 c4 04	 add	 esp, 4

; 1145 :                 hr = E_FAIL;

  00519	c7 45 b0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49229:
$L49227:

; 1146 :             }
; 1147 :         }
; 1148 : 
; 1149 :         //
; 1150 :         // Write to the bank file
; 1151 :         //
; 1152 :         
; 1153 :         if(SUCCEEDED(hr))

  00520	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00524	7c 48		 jl	 SHORT $L49232

; 1154 :         {
; 1155 :             if(FAILED(hr = pBankFile->Write(pvCopyBuffer, dwWritten)))

  00526	6a 00		 push	 0
  00528	8b 45 f4	 mov	 eax, DWORD PTR _dwWritten$[ebp]
  0052b	50		 push	 eax
  0052c	8b 4d 14	 mov	 ecx, DWORD PTR _pvCopyBuffer$[ebp]
  0052f	51		 push	 ecx
  00530	8b 4d 08	 mov	 ecx, DWORD PTR _pBankFile$[ebp]
  00533	e8 00 00 00 00	 call	 ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z ; WaveLoader::CStdFileStream::Write
  00538	89 45 b0	 mov	 DWORD PTR _hr$[ebp], eax
  0053b	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0053f	7d 2d		 jge	 SHORT $L49234

; 1156 :             {
; 1157 :                 DPF_ERROR("An error occurred while attempting to write to the bank file");

  00541	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00546	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@KNFK@CWaveBankEntry?3?3CommitWaveData?$AA@ ; `string'
  0054b	68 85 04 00 00	 push	 1157			; 00000485H
  00550	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00555	6a 01		 push	 1
  00557	6a 09		 push	 9
  00559	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0055e	83 c4 18	 add	 esp, 24			; 00000018H
  00561	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DN@HPGN@An?5error?5occurred?5while?5attempti@ ; `string'
  00566	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0056b	83 c4 04	 add	 esp, 4
$L49234:
$L49232:

; 1158 :             }
; 1159 :         }
; 1160 : 
; 1161 :         //
; 1162 :         // Increment counters
; 1163 :         //
; 1164 : 
; 1165 :         if(SUCCEEDED(hr))

  0056e	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00572	7c 12		 jl	 SHORT $L49237

; 1166 :         {
; 1167 :             dwTotalRead += dwRead;

  00574	8b 55 a4	 mov	 edx, DWORD PTR _dwTotalRead$[ebp]
  00577	03 55 f0	 add	 edx, DWORD PTR _dwRead$[ebp]
  0057a	89 55 a4	 mov	 DWORD PTR _dwTotalRead$[ebp], edx

; 1168 :             dwTotalWritten += dwWritten;

  0057d	8b 45 ec	 mov	 eax, DWORD PTR _dwTotalWritten$[ebp]
  00580	03 45 f4	 add	 eax, DWORD PTR _dwWritten$[ebp]
  00583	89 45 ec	 mov	 DWORD PTR _dwTotalWritten$[ebp], eax
$L49237:

; 1169 :         }
; 1170 : 
; 1171 :         //
; 1172 :         // If no file was specified, bail out now
; 1173 :         //
; 1174 : 
; 1175 :         if(!pBankFile)

  00586	83 7d 08 00	 cmp	 DWORD PTR _pBankFile$[ebp], 0
  0058a	75 02		 jne	 SHORT $L49238

; 1176 :         {
; 1177 :             break;

  0058c	eb 05		 jmp	 SHORT $L49210
$L49238:

; 1178 :         }
; 1179 :     }

  0058e	e9 68 fd ff ff	 jmp	 $L49209
$L49210:

; 1180 : 
; 1181 :     if(SUCCEEDED(hr))

  00593	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00597	7c 4f		 jl	 SHORT $L49240

; 1182 :     {
; 1183 :         ASSERT(dwTotalRead == m_PlayRegion.dwLength);

  00599	68 9f 04 00 00	 push	 1183			; 0000049fH
  0059e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  005a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@NCIG@dwTotalRead?5?$DN?$DN?5m_PlayRegion?4dwLe@ ; `string'
  005a8	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  005ab	8b 55 a4	 mov	 edx, DWORD PTR _dwTotalRead$[ebp]
  005ae	33 c0		 xor	 eax, eax
  005b0	3b 91 1c 03 00
	00		 cmp	 edx, DWORD PTR [ecx+796]
  005b6	0f 95 c0	 setne	 al
  005b9	50		 push	 eax
  005ba	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  005bf	83 c4 10	 add	 esp, 16			; 00000010H

; 1184 :         ASSERT(dwTotalWritten == pMetaData->PlayRegion.dwLength);

  005c2	68 a0 04 00 00	 push	 1184			; 000004a0H
  005c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  005cc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@BIEL@dwTotalWritten?5?$DN?$DN?5pMetaData?9?$DOPla@ ; `string'
  005d1	8b 4d 10	 mov	 ecx, DWORD PTR _pMetaData$[ebp]
  005d4	8b 55 ec	 mov	 edx, DWORD PTR _dwTotalWritten$[ebp]
  005d7	33 c0		 xor	 eax, eax
  005d9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  005dc	0f 95 c0	 setne	 al
  005df	50		 push	 eax
  005e0	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  005e5	83 c4 10	 add	 esp, 16			; 00000010H
$L49240:

; 1185 :     }
; 1186 : 
; 1187 :     DPF_LEAVE_HRESULT(hr);
; 1188 : 
; 1189 :     return hr;

  005e8	8b 4d b0	 mov	 ecx, DWORD PTR _hr$[ebp]
  005eb	89 4d a0	 mov	 DWORD PTR $T51550[ebp], ecx
  005ee	8d 4d e0	 lea	 ecx, DWORD PTR _WaveFile$[ebp]
  005f1	e8 00 00 00 00	 call	 ??1CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::~CStdFileStream
  005f6	8d 4d a8	 lea	 ecx, DWORD PTR _BitFilter$[ebp]
  005f9	e8 00 00 00 00	 call	 ??1C8BitFilter@@UAE@XZ	; C8BitFilter::~C8BitFilter
  005fe	8d 4d b8	 lea	 ecx, DWORD PTR _AdpcmFilter$[ebp]
  00601	e8 00 00 00 00	 call	 ??1CXboxAdpcmFilter@@UAE@XZ ; CXboxAdpcmFilter::~CXboxAdpcmFilter
  00606	8b 45 a0	 mov	 eax, DWORD PTR $T51550[ebp]

; 1190 : }

  00609	8b e5		 mov	 esp, ebp
  0060b	5d		 pop	 ebp
  0060c	c2 14 00	 ret	 20			; 00000014H
?CommitWaveData@CWaveBankEntry@@UAEJPAVCStdFileStream@WaveLoader@@KPBU_WAVEBANKENTRY@@PAXK@Z ENDP ; CWaveBankEntry::CommitWaveData
_TEXT	ENDS
PUBLIC	??_C@_08OCCE@ENTRY?$CFlu?$AA@			; `string'
PUBLIC	??_C@_00A@?$AA@					; `string'
PUBLIC	??_C@_0CA@JMEF@CWaveBankEntry?3?3ReadProjectData?$AA@ ; `string'
PUBLIC	??_C@_0CM@FBL@Unrecognized?5flag?5character?5in?5p@ ; `string'
EXTRN	_tolower:NEAR
EXTRN	_sprintf:NEAR
EXTRN	__imp__GetPrivateProfileStringA@24:NEAR
;	COMDAT ??_C@_08OCCE@ENTRY?$CFlu?$AA@
CONST	SEGMENT
??_C@_08OCCE@ENTRY?$CFlu?$AA@ DB 'ENTRY%lu', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JMEF@CWaveBankEntry?3?3ReadProjectData?$AA@
CONST	SEGMENT
??_C@_0CA@JMEF@CWaveBankEntry?3?3ReadProjectData?$AA@ DB 'CWaveBankEntry:'
	DB	':ReadProjectData', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FBL@Unrecognized?5flag?5character?5in?5p@
CONST	SEGMENT
??_C@_0CM@FBL@Unrecognized?5flag?5character?5in?5p@ DB 'Unrecognized flag'
	DB	' character in project file', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ReadProjectData@CWaveBankEntry@@UAEJPBD0K@Z
_TEXT	SEGMENT
_pszProjectFile$ = 8
_pszSectionName$ = 12
_dwEntryIndex$ = 16
_this$ = -1580
_szKeyName$ = -1304
_szEntryData$ = -776
_szEntryName$ = -1576
_szFileName$ = -1040
_dwFlags$ = -1316
_pszSrc$ = -1308
_pszDst$ = -1044
_hr$ = -1312
?ReadProjectData@CWaveBankEntry@@UAEJPBD0K@Z PROC NEAR	; CWaveBankEntry::ReadProjectData, COMDAT
; _this$ = ecx

; 1220 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 06 00
	00		 sub	 esp, 1592		; 00000638H
  00009	89 8d d4 f9 ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 1221 :     CHAR                    szKeyName[0x100];
; 1222 :     CHAR                    szEntryData[MAX_PATH + 0x200];
; 1223 :     CHAR                    szEntryName[0x100];
; 1224 :     CHAR                    szFileName[MAX_PATH];
; 1225 :     DWORD                   dwFlags;
; 1226 :     LPCSTR                  pszSrc;
; 1227 :     LPSTR                   pszDst;
; 1228 :     HRESULT                 hr;
; 1229 :     
; 1230 :     DPF_ENTER();
; 1231 : 
; 1232 :     //
; 1233 :     // Load the whole entry string
; 1234 :     //
; 1235 : 
; 1236 :     sprintf(szKeyName, WBPROJECT_ENTRY_KEY, dwEntryIndex);

  0000f	8b 45 10	 mov	 eax, DWORD PTR _dwEntryIndex$[ebp]
  00012	50		 push	 eax
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08OCCE@ENTRY?$CFlu?$AA@ ; `string'
  00018	8d 8d e8 fa ff
	ff		 lea	 ecx, DWORD PTR _szKeyName$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _sprintf
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1237 : 
; 1238 :     GetPrivateProfileString(pszSectionName, szKeyName, "", szEntryData, NUMELMS(szEntryData), pszProjectFile);

  00027	8b 55 08	 mov	 edx, DWORD PTR _pszProjectFile$[ebp]
  0002a	52		 push	 edx
  0002b	68 04 03 00 00	 push	 772			; 00000304H
  00030	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _szEntryData$[ebp]
  00036	50		 push	 eax
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
  0003c	8d 8d e8 fa ff
	ff		 lea	 ecx, DWORD PTR _szKeyName$[ebp]
  00042	51		 push	 ecx
  00043	8b 55 0c	 mov	 edx, DWORD PTR _pszSectionName$[ebp]
  00046	52		 push	 edx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 1239 : 
; 1240 :     pszSrc = szEntryData;

  0004d	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _szEntryData$[ebp]
  00053	89 85 e4 fa ff
	ff		 mov	 DWORD PTR _pszSrc$[ebp], eax

; 1241 :     
; 1242 :     //
; 1243 :     // Extract the entry name
; 1244 :     //
; 1245 :     
; 1246 :     pszDst = szEntryName;

  00059	8d 8d d8 f9 ff
	ff		 lea	 ecx, DWORD PTR _szEntryName$[ebp]
  0005f	89 8d ec fb ff
	ff		 mov	 DWORD PTR _pszDst$[ebp], ecx
$L49261:

; 1247 : 
; 1248 :     while(TRUE)

  00065	ba 01 00 00 00	 mov	 edx, 1
  0006a	85 d2		 test	 edx, edx
  0006c	74 7f		 je	 SHORT $L49262

; 1249 :     {
; 1250 :         switch(tolower(*pszSrc))
; 1251 :         {

  0006e	8b 85 e4 fa ff
	ff		 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00074	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 _tolower
  0007d	83 c4 04	 add	 esp, 4
  00080	89 85 d0 f9 ff
	ff		 mov	 DWORD PTR -1584+[ebp], eax
  00086	83 bd d0 f9 ff
	ff 2c		 cmp	 DWORD PTR -1584+[ebp], 44 ; 0000002cH
  0008d	74 02		 je	 SHORT $L49267
  0008f	eb 1a		 jmp	 SHORT $L49268
$L49267:

; 1252 :             case WBPROJECT_ENTRYEXT_SEPARATOR_LCHAR:
; 1253 :                 pszSrc++;

  00091	8b 95 e4 fa ff
	ff		 mov	 edx, DWORD PTR _pszSrc$[ebp]
  00097	83 c2 01	 add	 edx, 1
  0009a	89 95 e4 fa ff
	ff		 mov	 DWORD PTR _pszSrc$[ebp], edx

; 1254 :                 *pszDst = 0;

  000a0	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _pszDst$[ebp]
  000a6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1255 :                 break;

  000a9	eb 10		 jmp	 SHORT $L49264
$L49268:

; 1256 : 
; 1257 :             default:
; 1258 :                 *pszDst = *pszSrc;

  000ab	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _pszDst$[ebp]
  000b1	8b 95 e4 fa ff
	ff		 mov	 edx, DWORD PTR _pszSrc$[ebp]
  000b7	8a 02		 mov	 al, BYTE PTR [edx]
  000b9	88 01		 mov	 BYTE PTR [ecx], al
$L49264:

; 1259 :                 break;
; 1260 :         }
; 1261 : 
; 1262 :         if(!*pszDst)

  000bb	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _pszDst$[ebp]
  000c1	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000c4	85 d2		 test	 edx, edx
  000c6	75 02		 jne	 SHORT $L49269

; 1263 :         {
; 1264 :             break;

  000c8	eb 23		 jmp	 SHORT $L49262
$L49269:

; 1265 :         }
; 1266 : 
; 1267 :         pszDst++;

  000ca	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _pszDst$[ebp]
  000d0	83 c0 01	 add	 eax, 1
  000d3	89 85 ec fb ff
	ff		 mov	 DWORD PTR _pszDst$[ebp], eax

; 1268 :         pszSrc++;

  000d9	8b 8d e4 fa ff
	ff		 mov	 ecx, DWORD PTR _pszSrc$[ebp]
  000df	83 c1 01	 add	 ecx, 1
  000e2	89 8d e4 fa ff
	ff		 mov	 DWORD PTR _pszSrc$[ebp], ecx

; 1269 :     }

  000e8	e9 78 ff ff ff	 jmp	 $L49261
$L49262:

; 1270 : 
; 1271 :     //
; 1272 :     // Extract the file name
; 1273 :     //
; 1274 :     
; 1275 :     pszDst = szFileName;

  000ed	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR _szFileName$[ebp]
  000f3	89 95 ec fb ff
	ff		 mov	 DWORD PTR _pszDst$[ebp], edx
$L49271:

; 1276 : 
; 1277 :     while(TRUE)

  000f9	b8 01 00 00 00	 mov	 eax, 1
  000fe	85 c0		 test	 eax, eax
  00100	74 7f		 je	 SHORT $L49272

; 1278 :     {
; 1279 :         switch(tolower(*pszSrc))
; 1280 :         {

  00102	8b 8d e4 fa ff
	ff		 mov	 ecx, DWORD PTR _pszSrc$[ebp]
  00108	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 _tolower
  00111	83 c4 04	 add	 esp, 4
  00114	89 85 cc f9 ff
	ff		 mov	 DWORD PTR -1588+[ebp], eax
  0011a	83 bd cc f9 ff
	ff 2c		 cmp	 DWORD PTR -1588+[ebp], 44 ; 0000002cH
  00121	74 02		 je	 SHORT $L49277
  00123	eb 1a		 jmp	 SHORT $L49278
$L49277:

; 1281 :             case WBPROJECT_ENTRYEXT_SEPARATOR_LCHAR:
; 1282 :                 pszSrc++;

  00125	8b 85 e4 fa ff
	ff		 mov	 eax, DWORD PTR _pszSrc$[ebp]
  0012b	83 c0 01	 add	 eax, 1
  0012e	89 85 e4 fa ff
	ff		 mov	 DWORD PTR _pszSrc$[ebp], eax

; 1283 :                 *pszDst = 0;

  00134	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _pszDst$[ebp]
  0013a	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 1284 :                 break;

  0013d	eb 10		 jmp	 SHORT $L49274
$L49278:

; 1285 : 
; 1286 :             default:
; 1287 :                 *pszDst = *pszSrc;

  0013f	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _pszDst$[ebp]
  00145	8b 85 e4 fa ff
	ff		 mov	 eax, DWORD PTR _pszSrc$[ebp]
  0014b	8a 08		 mov	 cl, BYTE PTR [eax]
  0014d	88 0a		 mov	 BYTE PTR [edx], cl
$L49274:

; 1288 :                 break;
; 1289 :         }
; 1290 : 
; 1291 :         if(!*pszDst)

  0014f	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _pszDst$[ebp]
  00155	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00158	85 c0		 test	 eax, eax
  0015a	75 02		 jne	 SHORT $L49279

; 1292 :         {
; 1293 :             break;

  0015c	eb 23		 jmp	 SHORT $L49272
$L49279:

; 1294 :         }
; 1295 : 
; 1296 :         pszDst++;

  0015e	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _pszDst$[ebp]
  00164	83 c1 01	 add	 ecx, 1
  00167	89 8d ec fb ff
	ff		 mov	 DWORD PTR _pszDst$[ebp], ecx

; 1297 :         pszSrc++;

  0016d	8b 95 e4 fa ff
	ff		 mov	 edx, DWORD PTR _pszSrc$[ebp]
  00173	83 c2 01	 add	 edx, 1
  00176	89 95 e4 fa ff
	ff		 mov	 DWORD PTR _pszSrc$[ebp], edx

; 1298 :     }

  0017c	e9 78 ff ff ff	 jmp	 $L49271
$L49272:

; 1299 : 
; 1300 :     //
; 1301 :     // Extract the flags
; 1302 :     //
; 1303 : 
; 1304 :     dwFlags = 0;

  00181	c7 85 dc fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwFlags$[ebp], 0
$L49281:

; 1305 : 
; 1306 :     while(*pszSrc)

  0018b	8b 85 e4 fa ff
	ff		 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00191	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00194	85 c9		 test	 ecx, ecx
  00196	0f 84 9a 00 00
	00		 je	 $L49282

; 1307 :     {
; 1308 :         switch(tolower(*pszSrc))
; 1309 :         {

  0019c	8b 95 e4 fa ff
	ff		 mov	 edx, DWORD PTR _pszSrc$[ebp]
  001a2	0f be 02	 movsx	 eax, BYTE PTR [edx]
  001a5	50		 push	 eax
  001a6	e8 00 00 00 00	 call	 _tolower
  001ab	83 c4 04	 add	 esp, 4
  001ae	89 85 c8 f9 ff
	ff		 mov	 DWORD PTR -1592+[ebp], eax
  001b4	83 bd c8 f9 ff
	ff 2c		 cmp	 DWORD PTR -1592+[ebp], 44 ; 0000002cH
  001bb	74 14		 je	 SHORT $L49287
  001bd	83 bd c8 f9 ff
	ff 38		 cmp	 DWORD PTR -1592+[ebp], 56 ; 00000038H
  001c4	74 1e		 je	 SHORT $L49289
  001c6	83 bd c8 f9 ff
	ff 63		 cmp	 DWORD PTR -1592+[ebp], 99 ; 00000063H
  001cd	74 04		 je	 SHORT $L49288
  001cf	eb 24		 jmp	 SHORT $L49290
$L49287:

; 1310 :             case WBPROJECT_ENTRYEXT_SEPARATOR_LCHAR:
; 1311 :                 break;

  001d1	eb 4f		 jmp	 SHORT $L49284
$L49288:

; 1312 : 
; 1313 :             case WBPROJECT_ENTRYEXT_ADPCMFILTER_LCHAR:
; 1314 :                 dwFlags |= WBFILTER_ADPCM;

  001d3	8b 8d dc fa ff
	ff		 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  001d9	83 c9 01	 or	 ecx, 1
  001dc	89 8d dc fa ff
	ff		 mov	 DWORD PTR _dwFlags$[ebp], ecx

; 1315 :                 break;

  001e2	eb 3e		 jmp	 SHORT $L49284
$L49289:

; 1316 : 
; 1317 :             case WBPROJECT_ENTRYEXT_8BITFILTER_LCHAR:
; 1318 :                 dwFlags |= WBFILTER_8BIT;

  001e4	8b 95 dc fa ff
	ff		 mov	 edx, DWORD PTR _dwFlags$[ebp]
  001ea	83 ca 02	 or	 edx, 2
  001ed	89 95 dc fa ff
	ff		 mov	 DWORD PTR _dwFlags$[ebp], edx

; 1319 :                 break;

  001f3	eb 2d		 jmp	 SHORT $L49284
$L49290:

; 1320 : 
; 1321 :             default:
; 1322 :                 DPF_WARNING("Unrecognized flag character in project file");

  001f5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  001fa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@JMEF@CWaveBankEntry?3?3ReadProjectData?$AA@ ; `string'
  001ff	68 2a 05 00 00	 push	 1322			; 0000052aH
  00204	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00209	6a 03		 push	 3
  0020b	6a 09		 push	 9
  0020d	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00212	83 c4 18	 add	 esp, 24			; 00000018H
  00215	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@FBL@Unrecognized?5flag?5character?5in?5p@ ; `string'
  0021a	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0021f	83 c4 04	 add	 esp, 4
$L49284:

; 1323 :                 break;
; 1324 :         }
; 1325 : 
; 1326 :         pszSrc++;

  00222	8b 85 e4 fa ff
	ff		 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00228	83 c0 01	 add	 eax, 1
  0022b	89 85 e4 fa ff
	ff		 mov	 DWORD PTR _pszSrc$[ebp], eax

; 1327 :     }

  00231	e9 55 ff ff ff	 jmp	 $L49281
$L49282:

; 1328 : 
; 1329 :     //
; 1330 :     // Initialize the entry
; 1331 :     //
; 1332 : 
; 1333 :     hr = Initialize(szEntryName, szFileName, dwFlags);

  00236	8b 8d dc fa ff
	ff		 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  0023c	51		 push	 ecx
  0023d	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR _szFileName$[ebp]
  00243	52		 push	 edx
  00244	8d 85 d8 f9 ff
	ff		 lea	 eax, DWORD PTR _szEntryName$[ebp]
  0024a	50		 push	 eax
  0024b	8b 8d d4 f9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00251	8b 11		 mov	 edx, DWORD PTR [ecx]
  00253	8b 8d d4 f9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00259	ff 52 04	 call	 DWORD PTR [edx+4]
  0025c	89 85 e0 fa ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 1334 : 
; 1335 :     DPF_LEAVE_HRESULT(hr);
; 1336 : 
; 1337 :     return hr;

  00262	8b 85 e0 fa ff
	ff		 mov	 eax, DWORD PTR _hr$[ebp]

; 1338 : }

  00268	8b e5		 mov	 esp, ebp
  0026a	5d		 pop	 ebp
  0026b	c2 0c 00	 ret	 12			; 0000000cH
?ReadProjectData@CWaveBankEntry@@UAEJPBD0K@Z ENDP	; CWaveBankEntry::ReadProjectData
_TEXT	ENDS
PUBLIC	??_C@_01KMAE@?0?$AA@				; `string'
PUBLIC	??_C@_01IJJ@c?$AA@				; `string'
PUBLIC	??_C@_01KPCI@8?$AA@				; `string'
PUBLIC	??_C@_0CB@EEJD@CWaveBankEntry?3?3WriteProjectData@ ; `string'
PUBLIC	??_C@_0CP@KNEC@Error?5?$CFlu?5occurred?5writing?5to?5th@ ; `string'
EXTRN	__imp__GetLastError@0:NEAR
EXTRN	__imp__WritePrivateProfileStringA@16:NEAR
;	COMDAT ??_C@_01KMAE@?0?$AA@
CONST	SEGMENT
??_C@_01KMAE@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IJJ@c?$AA@
CONST	SEGMENT
??_C@_01IJJ@c?$AA@ DB 'c', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01KPCI@8?$AA@
CONST	SEGMENT
??_C@_01KPCI@8?$AA@ DB '8', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EEJD@CWaveBankEntry?3?3WriteProjectData@
CONST	SEGMENT
??_C@_0CB@EEJD@CWaveBankEntry?3?3WriteProjectData@ DB 'CWaveBankEntry::Wr'
	DB	'iteProjectData', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@KNEC@Error?5?$CFlu?5occurred?5writing?5to?5th@
CONST	SEGMENT
??_C@_0CP@KNEC@Error?5?$CFlu?5occurred?5writing?5to?5th@ DB 'Error %lu oc'
	DB	'curred writing to the project file', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?WriteProjectData@CWaveBankEntry@@UAEJPBD0K@Z
_TEXT	SEGMENT
_pszProjectFile$ = 8
_pszSectionName$ = 12
_dwEntryIndex$ = 16
_this$ = -1040
_hr$ = -1036
_szKeyName$ = -1032
_szEntryData$ = -776
?WriteProjectData@CWaveBankEntry@@UAEJPBD0K@Z PROC NEAR	; CWaveBankEntry::WriteProjectData, COMDAT
; _this$ = ecx

; 1368 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 04 00
	00		 sub	 esp, 1040		; 00000410H
  00009	89 8d f0 fb ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 1369 :     HRESULT                 hr                              = S_OK;

  0000f	c7 85 f4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _hr$[ebp], 0

; 1370 :     CHAR                    szKeyName[0x100];
; 1371 :     CHAR                    szEntryData[MAX_PATH + 0x200];
; 1372 :     
; 1373 :     DPF_ENTER();
; 1374 : 
; 1375 :     sprintf(szKeyName, WBPROJECT_ENTRY_KEY, dwEntryIndex);

  00019	8b 45 10	 mov	 eax, DWORD PTR _dwEntryIndex$[ebp]
  0001c	50		 push	 eax
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08OCCE@ENTRY?$CFlu?$AA@ ; `string'
  00022	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _szKeyName$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _sprintf
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1376 : 
; 1377 :     strcpy(szEntryData, m_szEntryName);

  00031	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00037	83 c2 10	 add	 edx, 16			; 00000010H
  0003a	52		 push	 edx
  0003b	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _szEntryData$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _strcpy
  00047	83 c4 08	 add	 esp, 8

; 1378 :     strcat(szEntryData, WBPROJECT_ENTRYEXT_SEPARATOR_STR);

  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01KMAE@?0?$AA@ ; `string'
  0004f	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR _szEntryData$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 _strcat
  0005b	83 c4 08	 add	 esp, 8

; 1379 : 
; 1380 :     GetRelativePath(pszProjectFile, m_szFileName, &szEntryData[strlen(szEntryData)]);

  0005e	8d 95 f8 fc ff
	ff		 lea	 edx, DWORD PTR _szEntryData$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 _strlen
  0006a	83 c4 04	 add	 esp, 4
  0006d	8d 84 05 f8 fc
	ff ff		 lea	 eax, DWORD PTR _szEntryData$[ebp+eax]
  00074	50		 push	 eax
  00075	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	81 c1 10 02 00
	00		 add	 ecx, 528		; 00000210H
  00081	51		 push	 ecx
  00082	8b 55 08	 mov	 edx, DWORD PTR _pszProjectFile$[ebp]
  00085	52		 push	 edx
  00086	e8 00 00 00 00	 call	 ?GetRelativePath@@YGXPBD0PAD@Z ; GetRelativePath

; 1381 : 
; 1382 :     if(m_dwFlags & WBFILTER_MASK)

  0008b	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00091	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  00097	83 e1 03	 and	 ecx, 3
  0009a	85 c9		 test	 ecx, ecx
  0009c	74 62		 je	 SHORT $L49304

; 1383 :     {
; 1384 :         strcat(szEntryData, WBPROJECT_ENTRYEXT_SEPARATOR_STR);

  0009e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01KMAE@?0?$AA@ ; `string'
  000a3	8d 95 f8 fc ff
	ff		 lea	 edx, DWORD PTR _szEntryData$[ebp]
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 _strcat
  000af	83 c4 08	 add	 esp, 8

; 1385 : 
; 1386 :         if(m_dwFlags & WBFILTER_ADPCM)

  000b2	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000b8	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  000be	83 e1 01	 and	 ecx, 1
  000c1	85 c9		 test	 ecx, ecx
  000c3	74 14		 je	 SHORT $L49305

; 1387 :         {
; 1388 :             strcat(szEntryData, WBPROJECT_ENTRYEXT_ADPCMFILTER_STR);

  000c5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01IJJ@c?$AA@ ; `string'
  000ca	8d 95 f8 fc ff
	ff		 lea	 edx, DWORD PTR _szEntryData$[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 _strcat
  000d6	83 c4 08	 add	 esp, 8
$L49305:

; 1389 :         }
; 1390 : 
; 1391 :         if(m_dwFlags & WBFILTER_8BIT)

  000d9	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000df	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  000e5	83 e1 02	 and	 ecx, 2
  000e8	85 c9		 test	 ecx, ecx
  000ea	74 14		 je	 SHORT $L49307

; 1392 :         {
; 1393 :             strcat(szEntryData, WBPROJECT_ENTRYEXT_8BITFILTER_STR);

  000ec	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01KPCI@8?$AA@ ; `string'
  000f1	8d 95 f8 fc ff
	ff		 lea	 edx, DWORD PTR _szEntryData$[ebp]
  000f7	52		 push	 edx
  000f8	e8 00 00 00 00	 call	 _strcat
  000fd	83 c4 08	 add	 esp, 8
$L49307:
$L49304:

; 1394 :         }
; 1395 :     }
; 1396 : 
; 1397 :     if(!WritePrivateProfileString(pszSectionName, szKeyName, szEntryData, pszProjectFile))

  00100	8b 45 08	 mov	 eax, DWORD PTR _pszProjectFile$[ebp]
  00103	50		 push	 eax
  00104	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR _szEntryData$[ebp]
  0010a	51		 push	 ecx
  0010b	8d 95 f8 fb ff
	ff		 lea	 edx, DWORD PTR _szKeyName$[ebp]
  00111	52		 push	 edx
  00112	8b 45 0c	 mov	 eax, DWORD PTR _pszSectionName$[ebp]
  00115	50		 push	 eax
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16
  0011c	85 c0		 test	 eax, eax
  0011e	75 3e		 jne	 SHORT $L49309

; 1398 :     {
; 1399 :         DPF_ERROR("Error %lu occurred writing to the project file", GetLastError());

  00120	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00125	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@EEJD@CWaveBankEntry?3?3WriteProjectData@ ; `string'
  0012a	68 77 05 00 00	 push	 1399			; 00000577H
  0012f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00134	6a 01		 push	 1
  00136	6a 09		 push	 9
  00138	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0013d	83 c4 18	 add	 esp, 24			; 00000018H
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00146	50		 push	 eax
  00147	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@KNEC@Error?5?$CFlu?5occurred?5writing?5to?5th@ ; `string'
  0014c	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00151	83 c4 08	 add	 esp, 8

; 1400 :         hr = E_FAIL;

  00154	c7 85 f4 fb ff
	ff 05 40 00 80	 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49309:

; 1401 :     }        
; 1402 : 
; 1403 :     DPF_LEAVE_HRESULT(hr);
; 1404 : 
; 1405 :     return hr;

  0015e	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _hr$[ebp]

; 1406 : }

  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c2 0c 00	 ret	 12			; 0000000cH
?WriteProjectData@CWaveBankEntry@@UAEJPBD0K@Z ENDP	; CWaveBankEntry::WriteProjectData
_TEXT	ENDS
PUBLIC	??0CWaveBank@@QAE@PAVCWaveBankProject@@@Z	; CWaveBank::CWaveBank
PUBLIC	?Initialize@CWaveBank@@UAEJPBD00@Z		; CWaveBank::Initialize
PUBLIC	?SetName@CWaveBank@@UAEJPBD@Z			; CWaveBank::SetName
PUBLIC	?GetBankDataSize@CWaveBank@@UAEKXZ		; CWaveBank::GetBankDataSize
PUBLIC	?AddEntry@CWaveBank@@UAEJPBD0KPAPAVCWaveBankEntry@@@Z ; CWaveBank::AddEntry
PUBLIC	?RemoveEntry@CWaveBank@@UAEXPAVCWaveBankEntry@@@Z ; CWaveBank::RemoveEntry
PUBLIC	?GenerateBank@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z ; CWaveBank::GenerateBank
PUBLIC	?GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z ; CWaveBank::GenerateHeader
PUBLIC	?ReadProjectData@CWaveBank@@UAEJPBDK@Z		; CWaveBank::ReadProjectData
PUBLIC	?WriteProjectData@CWaveBank@@UAEJPBDK@Z		; CWaveBank::WriteProjectData
PUBLIC	?CreateEntry@CWaveBank@@MAEPAVCWaveBankEntry@@XZ ; CWaveBank::CreateEntry
PUBLIC	?FindDuplicateBank@CWaveBank@@MAEJPBDPAI0101@Z	; CWaveBank::FindDuplicateBank
PUBLIC	??_7CWaveBank@@6B@				; CWaveBank::`vftable'
PUBLIC	??_GCWaveBank@@UAEPAXI@Z			; CWaveBank::`scalar deleting destructor'
PUBLIC	??_ECWaveBank@@UAEPAXI@Z			; CWaveBank::`vector deleting destructor'
;	COMDAT ??_7CWaveBank@@6B@
CONST	SEGMENT
??_7CWaveBank@@6B@ DD FLAT:??_ECWaveBank@@UAEPAXI@Z	; CWaveBank::`vftable'
	DD	FLAT:?Initialize@CWaveBank@@UAEJPBD00@Z
	DD	FLAT:?SetName@CWaveBank@@UAEJPBD@Z
	DD	FLAT:?GetBankDataSize@CWaveBank@@UAEKXZ
	DD	FLAT:?AddEntry@CWaveBank@@UAEJPBD0KPAPAVCWaveBankEntry@@@Z
	DD	FLAT:?RemoveEntry@CWaveBank@@UAEXPAVCWaveBankEntry@@@Z
	DD	FLAT:?GenerateBank@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z
	DD	FLAT:?GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z
	DD	FLAT:?ReadProjectData@CWaveBank@@UAEJPBDK@Z
	DD	FLAT:?WriteProjectData@CWaveBank@@UAEJPBDK@Z
	DD	FLAT:?CreateEntry@CWaveBank@@MAEPAVCWaveBankEntry@@XZ
	DD	FLAT:?FindDuplicateBank@CWaveBank@@MAEJPBDPAI0101@Z
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CWaveBank@@QAE@PAVCWaveBankProject@@@Z
_TEXT	SEGMENT
_pParent$ = 8
_this$ = -4
??0CWaveBank@@QAE@PAVCWaveBankProject@@@Z PROC NEAR	; CWaveBank::CWaveBank, COMDAT
; _this$ = ecx

; 1431 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CWaveBank@@6B@ ; CWaveBank::`vftable'

; 1432 :     DPF_ENTER();
; 1433 : 
; 1434 :     m_pParent = pParent;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _pParent$[ebp]
  00016	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1435 :     m_dwEntryCount = 0;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 80 40 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+576], 0

; 1436 : 
; 1437 :     InitializeListHead(&m_lstEntries);

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	81 c1 38 02 00
	00		 add	 ecx, 568		; 00000238H
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	89 8a 38 02 00
	00		 mov	 DWORD PTR [edx+568], ecx
  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 91 38 02 00
	00		 mov	 edx, DWORD PTR [ecx+568]
  00044	89 90 3c 02 00
	00		 mov	 DWORD PTR [eax+572], edx

; 1438 : 
; 1439 :     if(m_pParent)

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00051	74 2d		 je	 SHORT $L49317

; 1440 :     {
; 1441 :         InsertTailListUninit(&m_pParent->m_lstBanks, &m_leBank);

  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	83 c1 08	 add	 ecx, 8
  00059	51		 push	 ecx
  0005a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00060	83 c0 04	 add	 eax, 4
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailListUninit

; 1442 : 
; 1443 :         m_pParent->m_dwBankCount++;

  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0006f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00072	83 c0 01	 add	 eax, 1
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007b	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 1444 :     }
; 1445 :     else

  0007e	eb 18		 jmp	 SHORT $L49318
$L49317:

; 1446 :     {
; 1447 :         InitializeListHead(&m_leBank);

  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 08	 add	 eax, 8
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0008c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00095	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$L49318:

; 1448 :     }
; 1449 : 
; 1450 :     DPF_LEAVE_VOID();
; 1451 : }

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
??0CWaveBank@@QAE@PAVCWaveBankProject@@@Z ENDP		; CWaveBank::CWaveBank
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\writer.h
_TEXT	ENDS
;	COMDAT ?RemoveEntry@CWaveBank@@UAEXPAVCWaveBankEntry@@@Z
_TEXT	SEGMENT
$T51563 = -4
$T51564 = -8
_pEntry$ = 8
_this$ = -12
?RemoveEntry@CWaveBank@@UAEXPAVCWaveBankEntry@@@Z PROC NEAR ; CWaveBank::RemoveEntry, COMDAT
; _this$ = ecx

; 168  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 169  :     DELETE(pEntry);

  00009	83 7d 08 00	 cmp	 DWORD PTR _pEntry$[ebp], 0
  0000d	74 31		 je	 SHORT $L48692
  0000f	8b 45 08	 mov	 eax, DWORD PTR _pEntry$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR $T51564[ebp], eax
  00015	8b 4d f8	 mov	 ecx, DWORD PTR $T51564[ebp]
  00018	89 4d fc	 mov	 DWORD PTR $T51563[ebp], ecx
  0001b	83 7d fc 00	 cmp	 DWORD PTR $T51563[ebp], 0
  0001f	74 11		 je	 SHORT $L51565
  00021	6a 01		 push	 1
  00023	8b 55 fc	 mov	 edx, DWORD PTR $T51563[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	8b 4d fc	 mov	 ecx, DWORD PTR $T51563[ebp]
  0002b	ff 10		 call	 DWORD PTR [eax]
  0002d	89 45 f0	 mov	 DWORD PTR -16+[ebp], eax
  00030	eb 07		 jmp	 SHORT $L51566
$L51565:
  00032	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], 0
$L51566:
  00039	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _pEntry$[ebp], 0
$L48692:

; 170  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?RemoveEntry@CWaveBank@@UAEXPAVCWaveBankEntry@@@Z ENDP	; CWaveBank::RemoveEntry
_TEXT	ENDS
PUBLIC	??_C@_0BF@KCDF@CWaveBankEntry?$CIthis?$CJ?$AA@	; `string'
PUBLIC	??_C@_0EG@ELIP@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
;	COMDAT ??_C@_0BF@KCDF@CWaveBankEntry?$CIthis?$CJ?$AA@
CONST	SEGMENT
??_C@_0BF@KCDF@CWaveBankEntry?$CIthis?$CJ?$AA@ DB 'CWaveBankEntry(this)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@ELIP@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0EG@ELIP@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\privat'
	DB	'e\windows\directx\dsound\tools\wavbndlr\common\writer.h', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CreateEntry@CWaveBank@@MAEPAVCWaveBankEntry@@XZ
_TEXT	SEGMENT
$T51570 = -4
_this$ = -8
?CreateEntry@CWaveBank@@MAEPAVCWaveBankEntry@@XZ PROC NEAR ; CWaveBank::CreateEntry, COMDAT
; _this$ = ecx

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 174  :     return NEW(CWaveBankEntry(this));

  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@KCDF@CWaveBankEntry?$CIthis?$CJ?$AA@ ; `string'
  0000e	68 ae 00 00 00	 push	 174			; 000000aeH
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EG@ELIP@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00018	68 30 03 00 00	 push	 816			; 00000330H
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXIPBDK0@Z	; operator new
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR $T51570[ebp], eax
  00028	83 7d fc 00	 cmp	 DWORD PTR $T51570[ebp], 0
  0002c	74 11		 je	 SHORT $L51571
  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00031	50		 push	 eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR $T51570[ebp]
  00035	e8 00 00 00 00	 call	 ??0CWaveBankEntry@@QAE@PAVCWaveBank@@@Z ; CWaveBankEntry::CWaveBankEntry
  0003a	89 45 f4	 mov	 DWORD PTR -12+[ebp], eax
  0003d	eb 07		 jmp	 SHORT $L51572
$L51571:
  0003f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L51572:
  00046	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]

; 175  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?CreateEntry@CWaveBank@@MAEPAVCWaveBankEntry@@XZ ENDP	; CWaveBank::CreateEntry
_TEXT	ENDS
PUBLIC	?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingPoolAlloc
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\memmgr.h
;	COMDAT ??2@YAPAXIPBDK0@Z
_TEXT	SEGMENT
_cbBuffer$ = 8
_pszFile$ = 12
_nLine$ = 16
_pszClass$ = 20
??2@YAPAXIPBDK0@Z PROC NEAR				; operator new, COMDAT

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 233  :     return DirectSound::CMemoryManager::TrackingMemAlloc(pszFile, nLine, pszClass, DSOUND_OBJECT_POOL_TAG, cbBuffer, TRUE); 

  00003	6a 01		 push	 1
  00005	8b 45 08	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  00008	50		 push	 eax
  00009	68 44 53 6f 62	 push	 1651462980		; 626f5344H
  0000e	8b 4d 14	 mov	 ecx, DWORD PTR _pszClass$[ebp]
  00011	51		 push	 ecx
  00012	8b 55 10	 mov	 edx, DWORD PTR _nLine$[ebp]
  00015	52		 push	 edx
  00016	8b 45 0c	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingPoolAlloc

; 234  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??2@YAPAXIPBDK0@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??1CWaveBank@@UAE@XZ				; CWaveBank::~CWaveBank
; Function compile flags: /Odt
;	COMDAT ??_GCWaveBank@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCWaveBank@@UAEPAXI@Z PROC NEAR			; CWaveBank::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CWaveBank@@UAE@XZ	; CWaveBank::~CWaveBank
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L49322
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L49322:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCWaveBank@@UAEPAXI@Z ENDP				; CWaveBank::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0BJ@CNLP@m_pParent?9?$DOm_dwBankCount?$AA@ ; `string'
;	COMDAT ??_C@_0BJ@CNLP@m_pParent?9?$DOm_dwBankCount?$AA@
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\writer.cpp
CONST	SEGMENT
??_C@_0BJ@CNLP@m_pParent?9?$DOm_dwBankCount?$AA@ DB 'm_pParent->m_dwBankC'
	DB	'ount', 00H					; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??1CWaveBank@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20
_pleEntry$ = -8
_pEntry$ = -4
$T51582 = -12
$T51583 = -16
??1CWaveBank@@UAE@XZ PROC NEAR				; CWaveBank::~CWaveBank, COMDAT
; _this$ = ecx

; 1476 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CWaveBank@@6B@ ; CWaveBank::`vftable'
$L49330:

; 1477 :     PLIST_ENTRY             pleEntry;
; 1478 :     CWaveBankEntry *       pEntry;
; 1479 :     
; 1480 :     DPF_ENTER();
; 1481 : 
; 1482 :     //
; 1483 :     // Free all the entries
; 1484 :     //
; 1485 :     
; 1486 :     while((pleEntry = m_lstEntries.Flink) != &m_lstEntries)

  00012	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 91 38 02 00
	00		 mov	 edx, DWORD PTR [ecx+568]
  0001b	89 55 f8	 mov	 DWORD PTR _pleEntry$[ebp], edx
  0001e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00021	05 38 02 00 00	 add	 eax, 568		; 00000238H
  00026	39 45 f8	 cmp	 DWORD PTR _pleEntry$[ebp], eax
  00029	74 42		 je	 SHORT $L49331

; 1487 :     {
; 1488 :         pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  0002e	83 e9 08	 sub	 ecx, 8
  00031	89 4d fc	 mov	 DWORD PTR _pEntry$[ebp], ecx

; 1489 :         
; 1490 :         DELETE(pEntry);

  00034	83 7d fc 00	 cmp	 DWORD PTR _pEntry$[ebp], 0
  00038	74 31		 je	 SHORT $L49336
  0003a	8b 55 fc	 mov	 edx, DWORD PTR _pEntry$[ebp]
  0003d	89 55 f0	 mov	 DWORD PTR $T51583[ebp], edx
  00040	8b 45 f0	 mov	 eax, DWORD PTR $T51583[ebp]
  00043	89 45 f4	 mov	 DWORD PTR $T51582[ebp], eax
  00046	83 7d f4 00	 cmp	 DWORD PTR $T51582[ebp], 0
  0004a	74 11		 je	 SHORT $L51584
  0004c	6a 01		 push	 1
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR $T51582[ebp]
  00051	8b 11		 mov	 edx, DWORD PTR [ecx]
  00053	8b 4d f4	 mov	 ecx, DWORD PTR $T51582[ebp]
  00056	ff 12		 call	 DWORD PTR [edx]
  00058	89 45 e8	 mov	 DWORD PTR -24+[ebp], eax
  0005b	eb 07		 jmp	 SHORT $L51585
$L51584:
  0005d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR -24+[ebp], 0
$L51585:
  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pEntry$[ebp], 0
$L49336:

; 1491 :     }

  0006b	eb a5		 jmp	 SHORT $L49330
$L49331:

; 1492 : 
; 1493 :     //
; 1494 :     // Free ourselves from the parent list
; 1495 :     //
; 1496 : 
; 1497 :     RemoveEntryList(&m_leBank);

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00070	83 c0 08	 add	 eax, 8
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 1498 : 
; 1499 :     if(m_pParent)

  00079	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00080	74 3c		 je	 SHORT $L49339

; 1500 :     {
; 1501 :         ASSERT(m_pParent->m_dwBankCount);

  00082	68 dd 05 00 00	 push	 1501			; 000005ddH
  00087	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0008c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@CNLP@m_pParent?9?$DOm_dwBankCount?$AA@ ; `string'
  00091	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00094	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00097	33 c9		 xor	 ecx, ecx
  00099	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0009d	0f 94 c1	 sete	 cl
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000a6	83 c4 10	 add	 esp, 16			; 00000010H

; 1502 :         m_pParent->m_dwBankCount--;

  000a9	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000af	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000b2	83 e9 01	 sub	 ecx, 1
  000b5	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000b8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000bb	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$L49339:

; 1503 :     }
; 1504 : 
; 1505 :     DPF_LEAVE_VOID();
; 1506 : }

  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
??1CWaveBank@@UAE@XZ ENDP				; CWaveBank::~CWaveBank
_TEXT	ENDS
PUBLIC	??_C@_0BG@DKKB@CWaveBank?3?3Initialize?$AA@	; `string'
PUBLIC	??_C@_0EH@GOPH@A?5bank?5with?5that?5name?5?$CIor?5a?5simi@ ; `string'
PUBLIC	??_C@_0DJ@FGEE@A?5bank?5using?5that?5filename?5alrea@ ; `string'
PUBLIC	??_C@_0EA@FPCK@A?5bank?5using?5that?5header?5filenam@ ; `string'
;	COMDAT ??_C@_0BG@DKKB@CWaveBank?3?3Initialize?$AA@
CONST	SEGMENT
??_C@_0BG@DKKB@CWaveBank?3?3Initialize?$AA@ DB 'CWaveBank::Initialize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@GOPH@A?5bank?5with?5that?5name?5?$CIor?5a?5simi@
CONST	SEGMENT
??_C@_0EH@GOPH@A?5bank?5with?5that?5name?5?$CIor?5a?5simi@ DB 'A bank wit'
	DB	'h that name (or a similar one) already exists in the project', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@FGEE@A?5bank?5using?5that?5filename?5alrea@
CONST	SEGMENT
??_C@_0DJ@FGEE@A?5bank?5using?5that?5filename?5alrea@ DB 'A bank using th'
	DB	'at filename already exists in the project', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@FPCK@A?5bank?5using?5that?5header?5filenam@
CONST	SEGMENT
??_C@_0EA@FPCK@A?5bank?5using?5that?5header?5filenam@ DB 'A bank using th'
	DB	'at header filename already exists in the project', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Initialize@CWaveBank@@UAEJPBD00@Z
_TEXT	SEGMENT
_pszBankName$ = 8
_pszBankFile$ = 12
_pszHeaderFile$ = 16
_this$ = -20
_hr$ = -16
_nNameCount$ = -12
_nBankFileCount$ = -8
_nHeaderFileCount$ = -4
?Initialize@CWaveBank@@UAEJPBD00@Z PROC NEAR		; CWaveBank::Initialize, COMDAT
; _this$ = ecx

; 1536 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1537 :     HRESULT                 hr                  = S_OK;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1538 :     UINT                    nNameCount;
; 1539 :     UINT                    nBankFileCount;
; 1540 :     UINT                    nHeaderFileCount;
; 1541 : 
; 1542 :     DPF_ENTER();
; 1543 : 
; 1544 :     strncpy(m_szBankName, pszBankName, NUMELMS(m_szBankName));

  00010	6a 10		 push	 16			; 00000010H
  00012	8b 45 08	 mov	 eax, DWORD PTR _pszBankName$[ebp]
  00015	50		 push	 eax
  00016	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 10	 add	 ecx, 16			; 00000010H
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 _strncpy
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1545 :     strncpy(m_szHeaderName, pszBankName, NUMELMS(m_szHeaderName));

  00025	6a 10		 push	 16			; 00000010H
  00027	8b 55 08	 mov	 edx, DWORD PTR _pszBankName$[ebp]
  0002a	52		 push	 edx
  0002b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c0 20	 add	 eax, 32			; 00000020H
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _strncpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1546 :     MakeHeaderString(m_szHeaderName);

  0003a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 c1 20	 add	 ecx, 32			; 00000020H
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ?MakeHeaderString@@YGXPAD@Z ; MakeHeaderString

; 1547 : 
; 1548 :     GetFullPathName(pszBankFile, NUMELMS(m_szBankFile), m_szBankFile, NULL);

  00046	6a 00		 push	 0
  00048	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0004b	83 c2 30	 add	 edx, 48			; 00000030H
  0004e	52		 push	 edx
  0004f	68 04 01 00 00	 push	 260			; 00000104H
  00054	8b 45 0c	 mov	 eax, DWORD PTR _pszBankFile$[ebp]
  00057	50		 push	 eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFullPathNameA@16

; 1549 :     GetFullPathName(pszHeaderFile, NUMELMS(m_szHeaderFile), m_szHeaderFile, NULL);

  0005e	6a 00		 push	 0
  00060	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	81 c1 34 01 00
	00		 add	 ecx, 308		; 00000134H
  00069	51		 push	 ecx
  0006a	68 04 01 00 00	 push	 260			; 00000104H
  0006f	8b 55 10	 mov	 edx, DWORD PTR _pszHeaderFile$[ebp]
  00072	52		 push	 edx
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFullPathNameA@16

; 1550 : 
; 1551 :     FindDuplicateBank(m_szHeaderName, &nNameCount, m_szBankFile, &nBankFileCount, m_szHeaderFile, &nHeaderFileCount);

  00079	8d 45 fc	 lea	 eax, DWORD PTR _nHeaderFileCount$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	81 c1 34 01 00
	00		 add	 ecx, 308		; 00000134H
  00086	51		 push	 ecx
  00087	8d 55 f8	 lea	 edx, DWORD PTR _nBankFileCount$[ebp]
  0008a	52		 push	 edx
  0008b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	83 c0 30	 add	 eax, 48			; 00000030H
  00091	50		 push	 eax
  00092	8d 4d f4	 lea	 ecx, DWORD PTR _nNameCount$[ebp]
  00095	51		 push	 ecx
  00096	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00099	83 c2 20	 add	 edx, 32			; 00000020H
  0009c	52		 push	 edx
  0009d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	8b 10		 mov	 edx, DWORD PTR [eax]
  000a2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	ff 52 2c	 call	 DWORD PTR [edx+44]

; 1552 : 
; 1553 :     if(nNameCount)

  000a8	83 7d f4 00	 cmp	 DWORD PTR _nNameCount$[ebp], 0
  000ac	74 36		 je	 SHORT $L49352

; 1554 :     {
; 1555 :         DPF_ERROR("A bank with that name (or a similar one) already exists in the project");

  000ae	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000b3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@DKKB@CWaveBank?3?3Initialize?$AA@ ; `string'
  000b8	68 13 06 00 00	 push	 1555			; 00000613H
  000bd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000c2	6a 01		 push	 1
  000c4	6a 09		 push	 9
  000c6	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000cb	83 c4 18	 add	 esp, 24			; 00000018H
  000ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@GOPH@A?5bank?5with?5that?5name?5?$CIor?5a?5simi@ ; `string'
  000d3	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000d8	83 c4 04	 add	 esp, 4

; 1556 :         hr = E_FAIL;

  000db	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1557 :     }
; 1558 :     else if(nBankFileCount)

  000e2	eb 76		 jmp	 SHORT $L49356
$L49352:
  000e4	83 7d f8 00	 cmp	 DWORD PTR _nBankFileCount$[ebp], 0
  000e8	74 36		 je	 SHORT $L49357

; 1559 :     {
; 1560 :         DPF_ERROR("A bank using that filename already exists in the project");

  000ea	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000ef	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@DKKB@CWaveBank?3?3Initialize?$AA@ ; `string'
  000f4	68 18 06 00 00	 push	 1560			; 00000618H
  000f9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000fe	6a 01		 push	 1
  00100	6a 09		 push	 9
  00102	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00107	83 c4 18	 add	 esp, 24			; 00000018H
  0010a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@FGEE@A?5bank?5using?5that?5filename?5alrea@ ; `string'
  0010f	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00114	83 c4 04	 add	 esp, 4

; 1561 :         hr = E_FAIL;

  00117	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1562 :     }
; 1563 :     else if(nHeaderFileCount)

  0011e	eb 3a		 jmp	 SHORT $L49360
$L49357:
  00120	83 7d fc 00	 cmp	 DWORD PTR _nHeaderFileCount$[ebp], 0
  00124	74 34		 je	 SHORT $L49361

; 1564 :     {
; 1565 :         DPF_ERROR("A bank using that header filename already exists in the project");

  00126	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0012b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@DKKB@CWaveBank?3?3Initialize?$AA@ ; `string'
  00130	68 1d 06 00 00	 push	 1565			; 0000061dH
  00135	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0013a	6a 01		 push	 1
  0013c	6a 09		 push	 9
  0013e	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00143	83 c4 18	 add	 esp, 24			; 00000018H
  00146	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@FPCK@A?5bank?5using?5that?5header?5filenam@ ; `string'
  0014b	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00150	83 c4 04	 add	 esp, 4

; 1566 :         hr = E_FAIL;

  00153	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49361:
$L49360:
$L49356:

; 1567 :     }
; 1568 : 
; 1569 :     DPF_LEAVE_HRESULT(hr);
; 1570 : 
; 1571 :     return hr;

  0015a	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]

; 1572 : }

  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c2 0c 00	 ret	 12			; 0000000cH
?Initialize@CWaveBank@@UAEJPBD00@Z ENDP			; CWaveBank::Initialize
_TEXT	ENDS
PUBLIC	??_C@_0BH@NHHK@pszName?5?$HM?$HM?5pszBankFile?$AA@ ; `string'
;	COMDAT ??_C@_0BH@NHHK@pszName?5?$HM?$HM?5pszBankFile?$AA@
CONST	SEGMENT
??_C@_0BH@NHHK@pszName?5?$HM?$HM?5pszBankFile?$AA@ DB 'pszName || pszBank'
	DB	'File', 00H					; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?FindDuplicateBank@CWaveBank@@MAEJPBDPAI0101@Z
_TEXT	SEGMENT
_pszName$ = 8
_pnNameCount$ = 12
_pszBankFile$ = 16
_pnBankFileCount$ = 20
_pszHeaderFile$ = 24
_pnHeaderFileCount$ = 28
_this$ = -16
_hr$ = -8
_pleBank$ = -12
_pBank$ = -4
?FindDuplicateBank@CWaveBank@@MAEJPBDPAI0101@Z PROC NEAR ; CWaveBank::FindDuplicateBank, COMDAT
; _this$ = ecx

; 1606 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1607 :     HRESULT                 hr          = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1608 :     PLIST_ENTRY             pleBank;
; 1609 :     CWaveBank *            pBank;
; 1610 :     
; 1611 :     DPF_ENTER();
; 1612 : 
; 1613 :     ASSERT(pszName || pszBankFile);

  00010	83 7d 08 00	 cmp	 DWORD PTR _pszName$[ebp], 0
  00014	75 0f		 jne	 SHORT $L51592
  00016	83 7d 10 00	 cmp	 DWORD PTR _pszBankFile$[ebp], 0
  0001a	75 09		 jne	 SHORT $L51592
  0001c	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR -20+[ebp], 1
  00023	eb 07		 jmp	 SHORT $L51593
$L51592:
  00025	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR -20+[ebp], 0
$L51593:
  0002c	68 4d 06 00 00	 push	 1613			; 0000064dH
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00036	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@NHHK@pszName?5?$HM?$HM?5pszBankFile?$AA@ ; `string'
  0003b	8b 45 ec	 mov	 eax, DWORD PTR -20+[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00044	83 c4 10	 add	 esp, 16			; 00000010H

; 1614 : 
; 1615 :     if(pnNameCount)

  00047	83 7d 0c 00	 cmp	 DWORD PTR _pnNameCount$[ebp], 0
  0004b	74 09		 je	 SHORT $L49378

; 1616 :     {
; 1617 :         *pnNameCount = 0;

  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _pnNameCount$[ebp]
  00050	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L49378:

; 1618 :     }
; 1619 : 
; 1620 :     if(pnBankFileCount)

  00056	83 7d 14 00	 cmp	 DWORD PTR _pnBankFileCount$[ebp], 0
  0005a	74 09		 je	 SHORT $L49379

; 1621 :     {
; 1622 :         *pnBankFileCount = 0;

  0005c	8b 55 14	 mov	 edx, DWORD PTR _pnBankFileCount$[ebp]
  0005f	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L49379:

; 1623 :     }
; 1624 : 
; 1625 :     if(pnHeaderFileCount)

  00065	83 7d 1c 00	 cmp	 DWORD PTR _pnHeaderFileCount$[ebp], 0
  00069	74 09		 je	 SHORT $L49380

; 1626 :     {
; 1627 :         *pnHeaderFileCount = 0;

  0006b	8b 45 1c	 mov	 eax, DWORD PTR _pnHeaderFileCount$[ebp]
  0006e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L49380:

; 1628 :     }
; 1629 : 
; 1630 :     for(pleBank = m_pParent->m_lstBanks.Flink; pleBank != &m_pParent->m_lstBanks; pleBank = pleBank->Flink)

  00074	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007d	89 45 f4	 mov	 DWORD PTR _pleBank$[ebp], eax
  00080	eb 08		 jmp	 SHORT $L49381
$L49382:
  00082	8b 4d f4	 mov	 ecx, DWORD PTR _pleBank$[ebp]
  00085	8b 11		 mov	 edx, DWORD PTR [ecx]
  00087	89 55 f4	 mov	 DWORD PTR _pleBank$[ebp], edx
$L49381:
  0008a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00090	83 c1 04	 add	 ecx, 4
  00093	39 4d f4	 cmp	 DWORD PTR _pleBank$[ebp], ecx
  00096	0f 84 e1 00 00
	00		 je	 $L49383

; 1631 :     {
; 1632 :         if(this == (pBank = CONTAINING_RECORD(pleBank, CWaveBank, m_leBank)))

  0009c	8b 55 f4	 mov	 edx, DWORD PTR _pleBank$[ebp]
  0009f	83 ea 08	 sub	 edx, 8
  000a2	89 55 fc	 mov	 DWORD PTR _pBank$[ebp], edx
  000a5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	3b 45 fc	 cmp	 eax, DWORD PTR _pBank$[ebp]
  000ab	75 02		 jne	 SHORT $L49388

; 1633 :         {
; 1634 :             continue;

  000ad	eb d3		 jmp	 SHORT $L49382
$L49388:

; 1635 :         }
; 1636 : 
; 1637 :         if(pszName)

  000af	83 7d 08 00	 cmp	 DWORD PTR _pszName$[ebp], 0
  000b3	74 3e		 je	 SHORT $L49389

; 1638 :         {
; 1639 :             if(!_strcmpi(pszName, pBank->m_szHeaderName))

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _pBank$[ebp]
  000b8	83 c1 20	 add	 ecx, 32			; 00000020H
  000bb	51		 push	 ecx
  000bc	8b 55 08	 mov	 edx, DWORD PTR _pszName$[ebp]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 __strcmpi
  000c5	83 c4 08	 add	 esp, 8
  000c8	85 c0		 test	 eax, eax
  000ca	75 27		 jne	 SHORT $L49390

; 1640 :             {
; 1641 :                 hr = E_FAIL;

  000cc	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1642 :                 
; 1643 :                 if(pnNameCount)

  000d3	83 7d 0c 00	 cmp	 DWORD PTR _pnNameCount$[ebp], 0
  000d7	74 0f		 je	 SHORT $L49392

; 1644 :                 {
; 1645 :                     *pnNameCount = *pnNameCount + 1;

  000d9	8b 45 0c	 mov	 eax, DWORD PTR _pnNameCount$[ebp]
  000dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000de	83 c1 01	 add	 ecx, 1
  000e1	8b 55 0c	 mov	 edx, DWORD PTR _pnNameCount$[ebp]
  000e4	89 0a		 mov	 DWORD PTR [edx], ecx

; 1646 :                 }
; 1647 :                 else if(!pnBankFileCount)

  000e6	eb 0b		 jmp	 SHORT $L49393
$L49392:
  000e8	83 7d 14 00	 cmp	 DWORD PTR _pnBankFileCount$[ebp], 0
  000ec	75 05		 jne	 SHORT $L49394

; 1648 :                 {
; 1649 :                     break;

  000ee	e9 8a 00 00 00	 jmp	 $L49383
$L49394:
$L49393:
$L49390:
$L49389:

; 1650 :                 }
; 1651 :             }
; 1652 :         }
; 1653 : 
; 1654 :         if(pszBankFile)

  000f3	83 7d 10 00	 cmp	 DWORD PTR _pszBankFile$[ebp], 0
  000f7	74 3b		 je	 SHORT $L49395

; 1655 :         {
; 1656 :             if(!_strcmpi(pszBankFile, pBank->m_szBankFile))

  000f9	8b 45 fc	 mov	 eax, DWORD PTR _pBank$[ebp]
  000fc	83 c0 30	 add	 eax, 48			; 00000030H
  000ff	50		 push	 eax
  00100	8b 4d 10	 mov	 ecx, DWORD PTR _pszBankFile$[ebp]
  00103	51		 push	 ecx
  00104	e8 00 00 00 00	 call	 __strcmpi
  00109	83 c4 08	 add	 esp, 8
  0010c	85 c0		 test	 eax, eax
  0010e	75 24		 jne	 SHORT $L49396

; 1657 :             {
; 1658 :                 hr = E_FAIL;

  00110	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1659 :                 
; 1660 :                 if(pnBankFileCount)

  00117	83 7d 14 00	 cmp	 DWORD PTR _pnBankFileCount$[ebp], 0
  0011b	74 0f		 je	 SHORT $L49398

; 1661 :                 {
; 1662 :                     *pnBankFileCount = *pnBankFileCount + 1;

  0011d	8b 55 14	 mov	 edx, DWORD PTR _pnBankFileCount$[ebp]
  00120	8b 02		 mov	 eax, DWORD PTR [edx]
  00122	83 c0 01	 add	 eax, 1
  00125	8b 4d 14	 mov	 ecx, DWORD PTR _pnBankFileCount$[ebp]
  00128	89 01		 mov	 DWORD PTR [ecx], eax

; 1663 :                 }
; 1664 :                 else if(!pnNameCount)

  0012a	eb 08		 jmp	 SHORT $L49399
$L49398:
  0012c	83 7d 0c 00	 cmp	 DWORD PTR _pnNameCount$[ebp], 0
  00130	75 02		 jne	 SHORT $L49400

; 1665 :                 {
; 1666 :                     break;

  00132	eb 49		 jmp	 SHORT $L49383
$L49400:
$L49399:
$L49396:
$L49395:

; 1667 :                 }
; 1668 :             }
; 1669 :         }
; 1670 : 
; 1671 :         if(pszHeaderFile)

  00134	83 7d 18 00	 cmp	 DWORD PTR _pszHeaderFile$[ebp], 0
  00138	74 3e		 je	 SHORT $L49401

; 1672 :         {
; 1673 :             if(!_strcmpi(pszHeaderFile, pBank->m_szHeaderFile))

  0013a	8b 55 fc	 mov	 edx, DWORD PTR _pBank$[ebp]
  0013d	81 c2 34 01 00
	00		 add	 edx, 308		; 00000134H
  00143	52		 push	 edx
  00144	8b 45 18	 mov	 eax, DWORD PTR _pszHeaderFile$[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 __strcmpi
  0014d	83 c4 08	 add	 esp, 8
  00150	85 c0		 test	 eax, eax
  00152	75 24		 jne	 SHORT $L49402

; 1674 :             {
; 1675 :                 hr = E_FAIL;

  00154	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1676 :                 
; 1677 :                 if(pnHeaderFileCount)

  0015b	83 7d 1c 00	 cmp	 DWORD PTR _pnHeaderFileCount$[ebp], 0
  0015f	74 0f		 je	 SHORT $L49404

; 1678 :                 {
; 1679 :                     *pnHeaderFileCount = *pnHeaderFileCount + 1;

  00161	8b 4d 1c	 mov	 ecx, DWORD PTR _pnHeaderFileCount$[ebp]
  00164	8b 11		 mov	 edx, DWORD PTR [ecx]
  00166	83 c2 01	 add	 edx, 1
  00169	8b 45 1c	 mov	 eax, DWORD PTR _pnHeaderFileCount$[ebp]
  0016c	89 10		 mov	 DWORD PTR [eax], edx

; 1680 :                 }
; 1681 :                 else if(!pnNameCount)

  0016e	eb 08		 jmp	 SHORT $L49405
$L49404:
  00170	83 7d 0c 00	 cmp	 DWORD PTR _pnNameCount$[ebp], 0
  00174	75 02		 jne	 SHORT $L49406

; 1682 :                 {
; 1683 :                     break;

  00176	eb 05		 jmp	 SHORT $L49383
$L49406:
$L49405:
$L49402:
$L49401:

; 1684 :                 }
; 1685 :             }
; 1686 :         }
; 1687 :     }

  00178	e9 05 ff ff ff	 jmp	 $L49382
$L49383:

; 1688 :     
; 1689 :     DPF_LEAVE_HRESULT(hr);
; 1690 : 
; 1691 :     return hr;

  0017d	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1692 : }

  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c2 18 00	 ret	 24			; 00000018H
?FindDuplicateBank@CWaveBank@@MAEJPBDPAI0101@Z ENDP	; CWaveBank::FindDuplicateBank
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetName@CWaveBank@@UAEJPBD@Z
_TEXT	SEGMENT
_pszName$ = 8
_this$ = -24
_hr$ = -20
_szHeaderName$ = -16
?SetName@CWaveBank@@UAEJPBD@Z PROC NEAR			; CWaveBank::SetName, COMDAT
; _this$ = ecx

; 1718 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1719 :     HRESULT                 hr                                      = S_OK;

  00009	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1720 :     CHAR                    szHeaderName[NUMELMS(m_szHeaderName)];
; 1721 : 
; 1722 :     if(strlen(pszName) >= NUMELMS(m_szBankName))

  00010	8b 45 08	 mov	 eax, DWORD PTR _pszName$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _strlen
  00019	83 c4 04	 add	 esp, 4
  0001c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0001f	72 34		 jb	 SHORT $L49414

; 1723 :     {
; 1724 :         DPF_ERROR("That name is too long");

  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00026	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07OKEH@SetName?$AA@ ; `string'
  0002b	68 bc 06 00 00	 push	 1724			; 000006bcH
  00030	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00035	6a 01		 push	 1
  00037	6a 09		 push	 9
  00039	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0003e	83 c4 18	 add	 esp, 24			; 00000018H
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@EPOG@That?5name?5is?5too?5long?$AA@ ; `string'
  00046	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0004b	83 c4 04	 add	 esp, 4

; 1725 :         hr = E_FAIL;

  0004e	c7 45 ec 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49414:

; 1726 :     }
; 1727 : 
; 1728 :     if(SUCCEEDED(hr))

  00055	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00059	0f 8c 96 00 00
	00		 jl	 $L49417

; 1729 :     {
; 1730 :         strncpy(szHeaderName, pszName, NUMELMS(szHeaderName));

  0005f	6a 10		 push	 16			; 00000010H
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _pszName$[ebp]
  00064	51		 push	 ecx
  00065	8d 55 f0	 lea	 edx, DWORD PTR _szHeaderName$[ebp]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _strncpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1731 :         MakeHeaderString(szHeaderName);

  00071	8d 45 f0	 lea	 eax, DWORD PTR _szHeaderName$[ebp]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?MakeHeaderString@@YGXPAD@Z ; MakeHeaderString

; 1732 : 
; 1733 :         hr = FindDuplicateBank(szHeaderName, NULL, NULL, NULL, NULL, NULL);

  0007a	6a 00		 push	 0
  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	6a 00		 push	 0
  00084	8d 4d f0	 lea	 ecx, DWORD PTR _szHeaderName$[ebp]
  00087	51		 push	 ecx
  00088	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0008b	8b 02		 mov	 eax, DWORD PTR [edx]
  0008d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	ff 50 2c	 call	 DWORD PTR [eax+44]
  00093	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 1734 : 
; 1735 :         if(SUCCEEDED(hr))

  00096	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0009a	7c 2c		 jl	 SHORT $L49419

; 1736 :         {
; 1737 :             strncpy(m_szBankName, pszName, NUMELMS(m_szBankName));

  0009c	6a 10		 push	 16			; 00000010H
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _pszName$[ebp]
  000a1	51		 push	 ecx
  000a2	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	83 c2 10	 add	 edx, 16			; 00000010H
  000a8	52		 push	 edx
  000a9	e8 00 00 00 00	 call	 _strncpy
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1738 :             strncpy(m_szHeaderName, szHeaderName, NUMELMS(m_szHeaderName));

  000b1	6a 10		 push	 16			; 00000010H
  000b3	8d 45 f0	 lea	 eax, DWORD PTR _szHeaderName$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	83 c1 20	 add	 ecx, 32			; 00000020H
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 _strncpy
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1739 :         }
; 1740 :         else

  000c6	eb 2d		 jmp	 SHORT $L49420
$L49419:

; 1741 :         {
; 1742 :             DPF_ERROR("A bank with that name (or a similar one) already exists in the project");

  000c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000cd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07OKEH@SetName?$AA@ ; `string'
  000d2	68 ce 06 00 00	 push	 1742			; 000006ceH
  000d7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000dc	6a 01		 push	 1
  000de	6a 09		 push	 9
  000e0	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000e5	83 c4 18	 add	 esp, 24			; 00000018H
  000e8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@GOPH@A?5bank?5with?5that?5name?5?$CIor?5a?5simi@ ; `string'
  000ed	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000f2	83 c4 04	 add	 esp, 4
$L49420:
$L49417:

; 1743 :         }
; 1744 :     }
; 1745 : 
; 1746 :     return hr;

  000f5	8b 45 ec	 mov	 eax, DWORD PTR _hr$[ebp]

; 1747 : }

  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c2 04 00	 ret	 4
?SetName@CWaveBank@@UAEJPBD@Z ENDP			; CWaveBank::SetName
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddEntry@CWaveBank@@UAEJPBD0KPAPAVCWaveBankEntry@@@Z
_TEXT	SEGMENT
_pszEntryName$ = 8
_pszFileName$ = 12
_dwFlags$ = 16
_ppEntry$ = 20
_this$ = -20
_pEntry$ = -4
_hr$ = -8
$T51600 = -12
$T51601 = -16
?AddEntry@CWaveBank@@UAEJPBD0KPAPAVCWaveBankEntry@@@Z PROC NEAR ; CWaveBank::AddEntry, COMDAT
; _this$ = ecx

; 1779 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1780 :     CWaveBankEntry *       pEntry;
; 1781 :     HRESULT                 hr;
; 1782 :     
; 1783 :     DPF_ENTER();
; 1784 : 
; 1785 :     hr = HRFROMP(pEntry = CreateEntry());

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 10		 mov	 edx, DWORD PTR [eax]
  0000e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	ff 52 28	 call	 DWORD PTR [edx+40]
  00014	89 45 fc	 mov	 DWORD PTR _pEntry$[ebp], eax
  00017	8b 45 fc	 mov	 eax, DWORD PTR _pEntry$[ebp]
  0001a	f7 d8		 neg	 eax
  0001c	1b c0		 sbb	 eax, eax
  0001e	25 f2 ff f8 7f	 and	 eax, 2147024882		; 7ff8fff2H
  00023	05 0e 00 07 80	 add	 eax, -2147024882	; 8007000eH
  00028	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1786 : 
; 1787 :     if(SUCCEEDED(hr))

  0002b	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0002f	7c 1a		 jl	 SHORT $L49433

; 1788 :     {
; 1789 :         hr = pEntry->Initialize(pszEntryName, pszFileName, dwFlags);

  00031	8b 4d 10	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00034	51		 push	 ecx
  00035	8b 55 0c	 mov	 edx, DWORD PTR _pszFileName$[ebp]
  00038	52		 push	 edx
  00039	8b 45 08	 mov	 eax, DWORD PTR _pszEntryName$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _pEntry$[ebp]
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _pEntry$[ebp]
  00045	ff 52 04	 call	 DWORD PTR [edx+4]
  00048	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L49433:

; 1790 :     }
; 1791 : 
; 1792 :     if(SUCCEEDED(hr))

  0004b	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004f	7c 10		 jl	 SHORT $L49435

; 1793 :     {
; 1794 :         if(ppEntry)

  00051	83 7d 14 00	 cmp	 DWORD PTR _ppEntry$[ebp], 0
  00055	74 08		 je	 SHORT $L49436

; 1795 :         {
; 1796 :             *ppEntry = pEntry;

  00057	8b 45 14	 mov	 eax, DWORD PTR _ppEntry$[ebp]
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _pEntry$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$L49436:

; 1797 :         }
; 1798 :     }
; 1799 :     else

  0005f	eb 37		 jmp	 SHORT $L49437
$L49435:

; 1800 :     {
; 1801 :         DELETE(pEntry);

  00061	83 7d fc 00	 cmp	 DWORD PTR _pEntry$[ebp], 0
  00065	74 31		 je	 SHORT $L49438
  00067	8b 55 fc	 mov	 edx, DWORD PTR _pEntry$[ebp]
  0006a	89 55 f0	 mov	 DWORD PTR $T51601[ebp], edx
  0006d	8b 45 f0	 mov	 eax, DWORD PTR $T51601[ebp]
  00070	89 45 f4	 mov	 DWORD PTR $T51600[ebp], eax
  00073	83 7d f4 00	 cmp	 DWORD PTR $T51600[ebp], 0
  00077	74 11		 je	 SHORT $L51602
  00079	6a 01		 push	 1
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR $T51600[ebp]
  0007e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR $T51600[ebp]
  00083	ff 12		 call	 DWORD PTR [edx]
  00085	89 45 e8	 mov	 DWORD PTR -24+[ebp], eax
  00088	eb 07		 jmp	 SHORT $L51603
$L51602:
  0008a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR -24+[ebp], 0
$L51603:
  00091	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pEntry$[ebp], 0
$L49438:
$L49437:

; 1802 :     }
; 1803 : 
; 1804 :     return hr;

  00098	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1805 : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 10 00	 ret	 16			; 00000010H
?AddEntry@CWaveBank@@UAEJPBD0KPAPAVCWaveBankEntry@@@Z ENDP ; CWaveBank::AddEntry
_TEXT	ENDS
PUBLIC	??_C@_0BI@CEMK@CWaveBank?3?3GenerateBank?$AA@	; `string'
PUBLIC	??_C@_04EHOP@BYTE?$AA@				; `string'
PUBLIC	??_C@_0O@MNOP@Out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_0O@LLJI@WAVEBANKENTRY?$AA@		; `string'
PUBLIC	??_C@_0BO@CNBO@dwEntryIndex?5?$DM?5m_dwEntryCount?$AA@ ; `string'
PUBLIC	??_C@_0BF@DLDC@No?5entries?5added?5yet?$AA@	; `string'
;	COMDAT ??_C@_0BI@CEMK@CWaveBank?3?3GenerateBank?$AA@
CONST	SEGMENT
??_C@_0BI@CEMK@CWaveBank?3?3GenerateBank?$AA@ DB 'CWaveBank::GenerateBank'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04EHOP@BYTE?$AA@
CONST	SEGMENT
??_C@_04EHOP@BYTE?$AA@ DB 'BYTE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MNOP@Out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@MNOP@Out?5of?5memory?$AA@ DB 'Out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LLJI@WAVEBANKENTRY?$AA@
CONST	SEGMENT
??_C@_0O@LLJI@WAVEBANKENTRY?$AA@ DB 'WAVEBANKENTRY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CNBO@dwEntryIndex?5?$DM?5m_dwEntryCount?$AA@
CONST	SEGMENT
??_C@_0BO@CNBO@dwEntryIndex?5?$DM?5m_dwEntryCount?$AA@ DB 'dwEntryIndex <'
	DB	' m_dwEntryCount', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DLDC@No?5entries?5added?5yet?$AA@
CONST	SEGMENT
??_C@_0BF@DLDC@No?5entries?5added?5yet?$AA@ DB 'No entries added yet', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GenerateBank@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z
_TEXT	SEGMENT
_pCallback$ = 8
_fAllowOverwrite$ = 12
_this$ = -80
_pvCopyBuffer$ = -64
_paMetaData$ = -72
_hr$ = -60
_BankFile$ = -48
_Header$ = -40
_pleEntry$ = -68
_pEntry$ = -52
_dwEntryIndex$ = -4
_dwOffset$ = -56
$T51607 = -76
?GenerateBank@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z PROC NEAR ; CWaveBank::GenerateBank, COMDAT
; _this$ = ecx

; 1833 : {                                   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 1834 :     static const DWORD      dwCopyBufferSize    = 256 * 1024;
; 1835 :     LPVOID                  pvCopyBuffer        = NULL;

  00009	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _pvCopyBuffer$[ebp], 0

; 1836 :     LPWAVEBANKENTRY         paMetaData          = NULL;

  00010	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _paMetaData$[ebp], 0

; 1837 :     HRESULT                 hr                  = S_OK;

  00017	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1838 :     CStdFileStream          BankFile;

  0001e	8d 4d d0	 lea	 ecx, DWORD PTR _BankFile$[ebp]
  00021	e8 00 00 00 00	 call	 ??0CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::CStdFileStream

; 1839 :     WAVEBANKHEADER          Header;
; 1840 :     PLIST_ENTRY             pleEntry;
; 1841 :     CWaveBankEntry *        pEntry;
; 1842 :     DWORD                   dwEntryIndex;
; 1843 :     DWORD                   dwOffset;
; 1844 :     
; 1845 :     DPF_ENTER();
; 1846 : 
; 1847 :     if(m_dwEntryCount)

  00026	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 b8 40 02 00
	00 00		 cmp	 DWORD PTR [eax+576], 0
  00030	0f 84 2e 04 00
	00		 je	 $L49458

; 1848 :     {
; 1849 :         //
; 1850 :         // Call the callback
; 1851 :         //
; 1852 : 
; 1853 :         if(pCallback)

  00036	83 7d 08 00	 cmp	 DWORD PTR _pCallback$[ebp], 0
  0003a	74 1d		 je	 SHORT $L49459

; 1854 :         {
; 1855 :             if(!pCallback->OpenBank(m_szBankFile))

  0003c	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	83 c1 30	 add	 ecx, 48			; 00000030H
  00042	51		 push	 ecx
  00043	8b 55 08	 mov	 edx, DWORD PTR _pCallback$[ebp]
  00046	8b 02		 mov	 eax, DWORD PTR [edx]
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _pCallback$[ebp]
  0004b	ff 50 08	 call	 DWORD PTR [eax+8]
  0004e	85 c0		 test	 eax, eax
  00050	75 07		 jne	 SHORT $L49460

; 1856 :             {
; 1857 :                 hr = E_ABORT;

  00052	c7 45 c4 04 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467260 ; 80004004H
$L49460:
$L49459:

; 1858 :             }
; 1859 :         }
; 1860 : 
; 1861 :         //
; 1862 :         // Open the bank file
; 1863 :         //
; 1864 : 
; 1865 :         if(SUCCEEDED(hr))

  00059	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0005d	7c 63		 jl	 SHORT $L49463

; 1866 :         {
; 1867 :             if(FAILED(hr = BankFile.Open(m_szBankFile, GENERIC_READ | GENERIC_WRITE, 0, fAllowOverwrite ? CREATE_ALWAYS : CREATE_NEW, FILE_FLAG_SEQUENTIAL_SCAN)))

  0005f	68 00 00 00 08	 push	 134217728		; 08000000H
  00064	33 c9		 xor	 ecx, ecx
  00066	83 7d 0c 00	 cmp	 DWORD PTR _fAllowOverwrite$[ebp], 0
  0006a	0f 95 c1	 setne	 cl
  0006d	41		 inc	 ecx
  0006e	51		 push	 ecx
  0006f	6a 00		 push	 0
  00071	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00076	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00079	83 c2 30	 add	 edx, 48			; 00000030H
  0007c	52		 push	 edx
  0007d	8d 4d d0	 lea	 ecx, DWORD PTR _BankFile$[ebp]
  00080	e8 00 00 00 00	 call	 ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z ; WaveLoader::CStdFileStream::Open
  00085	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax
  00088	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0008c	7d 34		 jge	 SHORT $L49465

; 1868 :             {
; 1869 :                 DPF_ERROR("An error occurred while attempting to open %s", m_szBankFile);

  0008e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00093	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@CEMK@CWaveBank?3?3GenerateBank?$AA@ ; `string'
  00098	68 4d 07 00 00	 push	 1869			; 0000074dH
  0009d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000a2	6a 01		 push	 1
  000a4	6a 09		 push	 9
  000a6	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000ab	83 c4 18	 add	 esp, 24			; 00000018H
  000ae	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	83 c0 30	 add	 eax, 48			; 00000030H
  000b4	50		 push	 eax
  000b5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CO@EFJM@An?5error?5occurred?5while?5attempti@ ; `string'
  000ba	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000bf	83 c4 08	 add	 esp, 8
$L49465:
$L49463:

; 1870 :             }
; 1871 :         }
; 1872 :         
; 1873 :         //
; 1874 :         // Allocate temporary storage
; 1875 :         //
; 1876 : 
; 1877 :         if(SUCCEEDED(hr))

  000c2	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000c6	7c 6c		 jl	 SHORT $L49468

; 1878 :         {
; 1879 :             if(FAILED(hr = HRFROMP(pvCopyBuffer = MEMALLOC_NOINIT(BYTE, dwCopyBufferSize))))

  000c8	6a 00		 push	 0
  000ca	68 00 00 04 00	 push	 262144			; 00040000H
  000cf	68 44 53 64 61	 push	 1633964868		; 61645344H
  000d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04EHOP@BYTE?$AA@ ; `string'
  000d9	68 57 07 00 00	 push	 1879			; 00000757H
  000de	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000e3	e8 00 00 00 00	 call	 ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingPoolAlloc
  000e8	89 45 c0	 mov	 DWORD PTR _pvCopyBuffer$[ebp], eax
  000eb	8b 4d c0	 mov	 ecx, DWORD PTR _pvCopyBuffer$[ebp]
  000ee	f7 d9		 neg	 ecx
  000f0	1b c9		 sbb	 ecx, ecx
  000f2	81 e1 f2 ff f8
	7f		 and	 ecx, 2147024882		; 7ff8fff2H
  000f8	81 c1 0e 00 07
	80		 add	 ecx, -2147024882	; 8007000eH
  000fe	89 4d c4	 mov	 DWORD PTR _hr$[ebp], ecx
  00101	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00105	7d 2d		 jge	 SHORT $L49474

; 1880 :             {
; 1881 :                 DPF_ERROR("Out of memory");

  00107	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0010c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@CEMK@CWaveBank?3?3GenerateBank?$AA@ ; `string'
  00111	68 59 07 00 00	 push	 1881			; 00000759H
  00116	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0011b	6a 01		 push	 1
  0011d	6a 09		 push	 9
  0011f	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00124	83 c4 18	 add	 esp, 24			; 00000018H
  00127	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@MNOP@Out?5of?5memory?$AA@ ; `string'
  0012c	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00131	83 c4 04	 add	 esp, 4
$L49474:
$L49468:

; 1882 :             }
; 1883 :         }
; 1884 : 
; 1885 :         //
; 1886 :         // Allocate data for the entire metadata section
; 1887 :         //
; 1888 : 
; 1889 :         if(SUCCEEDED(hr))

  00134	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00138	7c 74		 jl	 SHORT $L49478

; 1890 :         {
; 1891 :             if(FAILED(hr = HRFROMP(paMetaData = MEMALLOC(WAVEBANKENTRY, m_dwEntryCount))))

  0013a	6a 01		 push	 1
  0013c	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  0013f	8b 82 40 02 00
	00		 mov	 eax, DWORD PTR [edx+576]
  00145	6b c0 14	 imul	 eax, 20			; 00000014H
  00148	50		 push	 eax
  00149	68 44 53 64 61	 push	 1633964868		; 61645344H
  0014e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@LLJI@WAVEBANKENTRY?$AA@ ; `string'
  00153	68 63 07 00 00	 push	 1891			; 00000763H
  00158	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0015d	e8 00 00 00 00	 call	 ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingPoolAlloc
  00162	89 45 b8	 mov	 DWORD PTR _paMetaData$[ebp], eax
  00165	8b 4d b8	 mov	 ecx, DWORD PTR _paMetaData$[ebp]
  00168	f7 d9		 neg	 ecx
  0016a	1b c9		 sbb	 ecx, ecx
  0016c	81 e1 f2 ff f8
	7f		 and	 ecx, 2147024882		; 7ff8fff2H
  00172	81 c1 0e 00 07
	80		 add	 ecx, -2147024882	; 8007000eH
  00178	89 4d c4	 mov	 DWORD PTR _hr$[ebp], ecx
  0017b	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0017f	7d 2d		 jge	 SHORT $L49484

; 1892 :             {
; 1893 :                 DPF_ERROR("Out of memory");

  00181	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00186	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@CEMK@CWaveBank?3?3GenerateBank?$AA@ ; `string'
  0018b	68 65 07 00 00	 push	 1893			; 00000765H
  00190	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00195	6a 01		 push	 1
  00197	6a 09		 push	 9
  00199	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0019e	83 c4 18	 add	 esp, 24			; 00000018H
  001a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@MNOP@Out?5of?5memory?$AA@ ; `string'
  001a6	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001ab	83 c4 04	 add	 esp, 4
$L49484:
$L49478:

; 1894 :             }
; 1895 :         }
; 1896 : 
; 1897 :         //
; 1898 :         // Write the file header
; 1899 :         //
; 1900 : 
; 1901 :         if(SUCCEEDED(hr))

  001ae	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001b2	0f 8c 88 00 00
	00		 jl	 $L49487

; 1902 :         {
; 1903 :             Header.dwSignature = WAVEBANKHEADER_SIGNATURE;

  001b8	c7 45 d8 57 42
	4e 44		 mov	 DWORD PTR _Header$[ebp], 1145979479 ; 444e4257H

; 1904 :             Header.dwVersion = WAVEBANKHEADER_VERSION;

  001bf	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _Header$[ebp+4], 2

; 1905 :             Header.dwFlags = m_dwFlags;

  001c6	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  001c9	8b 82 44 02 00
	00		 mov	 eax, DWORD PTR [edx+580]
  001cf	89 45 e0	 mov	 DWORD PTR _Header$[ebp+8], eax

; 1906 :             Header.dwEntryCount = m_dwEntryCount;

  001d2	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  001d5	8b 91 40 02 00
	00		 mov	 edx, DWORD PTR [ecx+576]
  001db	89 55 e4	 mov	 DWORD PTR _Header$[ebp+12], edx

; 1907 :             Header.dwAlignment = 4;

  001de	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR _Header$[ebp+16], 4

; 1908 :             
; 1909 :             strncpy(Header.szBankName, m_szBankName, NUMELMS(Header.szBankName));

  001e5	6a 10		 push	 16			; 00000010H
  001e7	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  001ea	83 c0 10	 add	 eax, 16			; 00000010H
  001ed	50		 push	 eax
  001ee	8d 4d ec	 lea	 ecx, DWORD PTR _Header$[ebp+20]
  001f1	51		 push	 ecx
  001f2	e8 00 00 00 00	 call	 _strncpy
  001f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1910 : 
; 1911 :             if(FAILED(hr = BankFile.Write(&Header, sizeof(Header))))

  001fa	6a 00		 push	 0
  001fc	6a 24		 push	 36			; 00000024H
  001fe	8d 55 d8	 lea	 edx, DWORD PTR _Header$[ebp]
  00201	52		 push	 edx
  00202	8d 4d d0	 lea	 ecx, DWORD PTR _BankFile$[ebp]
  00205	e8 00 00 00 00	 call	 ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z ; WaveLoader::CStdFileStream::Write
  0020a	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax
  0020d	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00211	7d 2d		 jge	 SHORT $L49489

; 1912 :             {
; 1913 :                 DPF_ERROR("An error occurred while attempting to write to the bank file");

  00213	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00218	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@CEMK@CWaveBank?3?3GenerateBank?$AA@ ; `string'
  0021d	68 79 07 00 00	 push	 1913			; 00000779H
  00222	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00227	6a 01		 push	 1
  00229	6a 09		 push	 9
  0022b	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00230	83 c4 18	 add	 esp, 24			; 00000018H
  00233	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DN@HPGN@An?5error?5occurred?5while?5attempti@ ; `string'
  00238	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0023d	83 c4 04	 add	 esp, 4
$L49489:
$L49487:

; 1914 :             }
; 1915 :         }
; 1916 : 
; 1917 :         //
; 1918 :         // Generate and write metadata
; 1919 :         //
; 1920 : 
; 1921 :         if(SUCCEEDED(hr))

  00240	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00244	0f 8c 91 00 00
	00		 jl	 $L49491

; 1922 :         {
; 1923 :             for(pleEntry = m_lstEntries.Flink, dwEntryIndex = 0, dwOffset = 0; SUCCEEDED(hr) && (pleEntry != &m_lstEntries); pleEntry = pleEntry->Flink, dwEntryIndex++)

  0024a	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0024d	8b 88 38 02 00
	00		 mov	 ecx, DWORD PTR [eax+568]
  00253	89 4d bc	 mov	 DWORD PTR _pleEntry$[ebp], ecx
  00256	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwEntryIndex$[ebp], 0
  0025d	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _dwOffset$[ebp], 0
  00264	eb 11		 jmp	 SHORT $L49493
$L49494:
  00266	8b 55 bc	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  00269	8b 02		 mov	 eax, DWORD PTR [edx]
  0026b	89 45 bc	 mov	 DWORD PTR _pleEntry$[ebp], eax
  0026e	8b 4d fc	 mov	 ecx, DWORD PTR _dwEntryIndex$[ebp]
  00271	83 c1 01	 add	 ecx, 1
  00274	89 4d fc	 mov	 DWORD PTR _dwEntryIndex$[ebp], ecx
$L49493:
  00277	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0027b	7c 5e		 jl	 SHORT $L49495
  0027d	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00280	81 c2 38 02 00
	00		 add	 edx, 568		; 00000238H
  00286	39 55 bc	 cmp	 DWORD PTR _pleEntry$[ebp], edx
  00289	74 50		 je	 SHORT $L49495

; 1924 :             {
; 1925 :                 ASSERT(dwEntryIndex < m_dwEntryCount);

  0028b	68 85 07 00 00	 push	 1925			; 00000785H
  00290	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00295	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@CNBO@dwEntryIndex?5?$DM?5m_dwEntryCount?$AA@ ; `string'
  0029a	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0029d	8b 4d fc	 mov	 ecx, DWORD PTR _dwEntryIndex$[ebp]
  002a0	3b 88 40 02 00
	00		 cmp	 ecx, DWORD PTR [eax+576]
  002a6	1b d2		 sbb	 edx, edx
  002a8	42		 inc	 edx
  002a9	52		 push	 edx
  002aa	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  002af	83 c4 10	 add	 esp, 16			; 00000010H

; 1926 :                 
; 1927 :                 pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

  002b2	8b 45 bc	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  002b5	83 e8 08	 sub	 eax, 8
  002b8	89 45 cc	 mov	 DWORD PTR _pEntry$[ebp], eax

; 1928 : 
; 1929 :                 hr = pEntry->GetMetaData(&paMetaData[dwEntryIndex], &dwOffset);

  002bb	8d 4d c8	 lea	 ecx, DWORD PTR _dwOffset$[ebp]
  002be	51		 push	 ecx
  002bf	8b 55 fc	 mov	 edx, DWORD PTR _dwEntryIndex$[ebp]
  002c2	6b d2 14	 imul	 edx, 20			; 00000014H
  002c5	8b 45 b8	 mov	 eax, DWORD PTR _paMetaData$[ebp]
  002c8	03 c2		 add	 eax, edx
  002ca	50		 push	 eax
  002cb	8b 4d cc	 mov	 ecx, DWORD PTR _pEntry$[ebp]
  002ce	8b 11		 mov	 edx, DWORD PTR [ecx]
  002d0	8b 4d cc	 mov	 ecx, DWORD PTR _pEntry$[ebp]
  002d3	ff 52 14	 call	 DWORD PTR [edx+20]
  002d6	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax

; 1930 :             }

  002d9	eb 8b		 jmp	 SHORT $L49494
$L49495:
$L49491:

; 1931 :         }
; 1932 :         
; 1933 :         if(SUCCEEDED(hr))

  002db	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002df	7c 51		 jl	 SHORT $L49502

; 1934 :         {
; 1935 :             if(FAILED(hr = BankFile.Write(paMetaData, sizeof(paMetaData[0]) * m_dwEntryCount)))

  002e1	6a 00		 push	 0
  002e3	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  002e6	8b 88 40 02 00
	00		 mov	 ecx, DWORD PTR [eax+576]
  002ec	6b c9 14	 imul	 ecx, 20			; 00000014H
  002ef	51		 push	 ecx
  002f0	8b 55 b8	 mov	 edx, DWORD PTR _paMetaData$[ebp]
  002f3	52		 push	 edx
  002f4	8d 4d d0	 lea	 ecx, DWORD PTR _BankFile$[ebp]
  002f7	e8 00 00 00 00	 call	 ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z ; WaveLoader::CStdFileStream::Write
  002fc	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax
  002ff	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00303	7d 2d		 jge	 SHORT $L49504

; 1936 :             {
; 1937 :                 DPF_ERROR("An error occurred while attempting to write to the bank file");

  00305	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0030a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@CEMK@CWaveBank?3?3GenerateBank?$AA@ ; `string'
  0030f	68 91 07 00 00	 push	 1937			; 00000791H
  00314	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00319	6a 01		 push	 1
  0031b	6a 09		 push	 9
  0031d	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00322	83 c4 18	 add	 esp, 24			; 00000018H
  00325	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DN@HPGN@An?5error?5occurred?5while?5attempti@ ; `string'
  0032a	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0032f	83 c4 04	 add	 esp, 4
$L49504:
$L49502:

; 1938 :             }
; 1939 :         }
; 1940 : 
; 1941 :         //
; 1942 :         // Write the data section
; 1943 :         //
; 1944 : 
; 1945 :         if(SUCCEEDED(hr))

  00332	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00336	0f 8c 0e 01 00
	00		 jl	 $L49506

; 1946 :         {
; 1947 :             for(pleEntry = m_lstEntries.Flink, dwEntryIndex = 0; SUCCEEDED(hr) && (pleEntry != &m_lstEntries); pleEntry = pleEntry->Flink, dwEntryIndex++)

  0033c	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0033f	8b 88 38 02 00
	00		 mov	 ecx, DWORD PTR [eax+568]
  00345	89 4d bc	 mov	 DWORD PTR _pleEntry$[ebp], ecx
  00348	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwEntryIndex$[ebp], 0
  0034f	eb 11		 jmp	 SHORT $L49508
$L49509:
  00351	8b 55 bc	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  00354	8b 02		 mov	 eax, DWORD PTR [edx]
  00356	89 45 bc	 mov	 DWORD PTR _pleEntry$[ebp], eax
  00359	8b 4d fc	 mov	 ecx, DWORD PTR _dwEntryIndex$[ebp]
  0035c	83 c1 01	 add	 ecx, 1
  0035f	89 4d fc	 mov	 DWORD PTR _dwEntryIndex$[ebp], ecx
$L49508:
  00362	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00366	0f 8c de 00 00
	00		 jl	 $L49510
  0036c	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  0036f	81 c2 38 02 00
	00		 add	 edx, 568		; 00000238H
  00375	39 55 bc	 cmp	 DWORD PTR _pleEntry$[ebp], edx
  00378	0f 84 cc 00 00
	00		 je	 $L49510

; 1948 :             {
; 1949 :                 ASSERT(dwEntryIndex < m_dwEntryCount);

  0037e	68 9d 07 00 00	 push	 1949			; 0000079dH
  00383	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00388	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@CNBO@dwEntryIndex?5?$DM?5m_dwEntryCount?$AA@ ; `string'
  0038d	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00390	8b 4d fc	 mov	 ecx, DWORD PTR _dwEntryIndex$[ebp]
  00393	3b 88 40 02 00
	00		 cmp	 ecx, DWORD PTR [eax+576]
  00399	1b d2		 sbb	 edx, edx
  0039b	42		 inc	 edx
  0039c	52		 push	 edx
  0039d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  003a2	83 c4 10	 add	 esp, 16			; 00000010H

; 1950 :                 
; 1951 :                 pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

  003a5	8b 45 bc	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  003a8	83 e8 08	 sub	 eax, 8
  003ab	89 45 cc	 mov	 DWORD PTR _pEntry$[ebp], eax

; 1952 : 
; 1953 :                 if(pCallback)

  003ae	83 7d 08 00	 cmp	 DWORD PTR _pCallback$[ebp], 0
  003b2	74 29		 je	 SHORT $L49515

; 1954 :                 {
; 1955 :                     if(!pCallback->BeginEntry(pEntry->m_szFileName, pEntry->m_dwFlags))

  003b4	8b 4d cc	 mov	 ecx, DWORD PTR _pEntry$[ebp]
  003b7	8b 91 28 03 00
	00		 mov	 edx, DWORD PTR [ecx+808]
  003bd	52		 push	 edx
  003be	8b 45 cc	 mov	 eax, DWORD PTR _pEntry$[ebp]
  003c1	05 10 02 00 00	 add	 eax, 528		; 00000210H
  003c6	50		 push	 eax
  003c7	8b 4d 08	 mov	 ecx, DWORD PTR _pCallback$[ebp]
  003ca	8b 11		 mov	 edx, DWORD PTR [ecx]
  003cc	8b 4d 08	 mov	 ecx, DWORD PTR _pCallback$[ebp]
  003cf	ff 52 18	 call	 DWORD PTR [edx+24]
  003d2	85 c0		 test	 eax, eax
  003d4	75 07		 jne	 SHORT $L49516

; 1956 :                     {
; 1957 :                         hr = E_ABORT;

  003d6	c7 45 c4 04 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467260 ; 80004004H
$L49516:
$L49515:

; 1958 :                     }
; 1959 :                 }
; 1960 :         
; 1961 :                 if(SUCCEEDED(hr))

  003dd	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  003e1	7c 37		 jl	 SHORT $L49519

; 1962 :                 {
; 1963 :                     dwOffset = sizeof(Header) + (sizeof(paMetaData[0]) * Header.dwEntryCount);

  003e3	8b 45 e4	 mov	 eax, DWORD PTR _Header$[ebp+12]
  003e6	6b c0 14	 imul	 eax, 20			; 00000014H
  003e9	83 c0 24	 add	 eax, 36			; 00000024H
  003ec	89 45 c8	 mov	 DWORD PTR _dwOffset$[ebp], eax

; 1964 :                     
; 1965 :                     hr = pEntry->CommitWaveData(&BankFile, dwOffset, &paMetaData[dwEntryIndex], pvCopyBuffer, dwCopyBufferSize);

  003ef	68 00 00 04 00	 push	 262144			; 00040000H
  003f4	8b 4d c0	 mov	 ecx, DWORD PTR _pvCopyBuffer$[ebp]
  003f7	51		 push	 ecx
  003f8	8b 55 fc	 mov	 edx, DWORD PTR _dwEntryIndex$[ebp]
  003fb	6b d2 14	 imul	 edx, 20			; 00000014H
  003fe	8b 45 b8	 mov	 eax, DWORD PTR _paMetaData$[ebp]
  00401	03 c2		 add	 eax, edx
  00403	50		 push	 eax
  00404	8b 4d c8	 mov	 ecx, DWORD PTR _dwOffset$[ebp]
  00407	51		 push	 ecx
  00408	8d 55 d0	 lea	 edx, DWORD PTR _BankFile$[ebp]
  0040b	52		 push	 edx
  0040c	8b 45 cc	 mov	 eax, DWORD PTR _pEntry$[ebp]
  0040f	8b 10		 mov	 edx, DWORD PTR [eax]
  00411	8b 4d cc	 mov	 ecx, DWORD PTR _pEntry$[ebp]
  00414	ff 52 18	 call	 DWORD PTR [edx+24]
  00417	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax
$L49519:

; 1966 :                 }
; 1967 : 
; 1968 :                 if(SUCCEEDED(hr) && pCallback)

  0041a	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0041e	7c 25		 jl	 SHORT $L49521
  00420	83 7d 08 00	 cmp	 DWORD PTR _pCallback$[ebp], 0
  00424	74 1f		 je	 SHORT $L49521

; 1969 :                 {
; 1970 :                     pCallback->EndEntry(pEntry->m_szFileName, pEntry->m_dwFlags);

  00426	8b 45 cc	 mov	 eax, DWORD PTR _pEntry$[ebp]
  00429	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  0042f	51		 push	 ecx
  00430	8b 55 cc	 mov	 edx, DWORD PTR _pEntry$[ebp]
  00433	81 c2 10 02 00
	00		 add	 edx, 528		; 00000210H
  00439	52		 push	 edx
  0043a	8b 45 08	 mov	 eax, DWORD PTR _pCallback$[ebp]
  0043d	8b 10		 mov	 edx, DWORD PTR [eax]
  0043f	8b 4d 08	 mov	 ecx, DWORD PTR _pCallback$[ebp]
  00442	ff 52 1c	 call	 DWORD PTR [edx+28]
$L49521:

; 1971 :                 }
; 1972 :             }

  00445	e9 07 ff ff ff	 jmp	 $L49509
$L49510:
$L49506:

; 1973 :         }
; 1974 : 
; 1975 :         //
; 1976 :         // Call the callback
; 1977 :         //
; 1978 : 
; 1979 :         if(pCallback)

  0044a	83 7d 08 00	 cmp	 DWORD PTR _pCallback$[ebp], 0
  0044e	74 12		 je	 SHORT $L49522

; 1980 :         {
; 1981 :             pCallback->CloseBank(m_szBankFile);

  00450	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00453	83 c0 30	 add	 eax, 48			; 00000030H
  00456	50		 push	 eax
  00457	8b 4d 08	 mov	 ecx, DWORD PTR _pCallback$[ebp]
  0045a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0045c	8b 4d 08	 mov	 ecx, DWORD PTR _pCallback$[ebp]
  0045f	ff 52 0c	 call	 DWORD PTR [edx+12]
$L49522:

; 1982 :         }
; 1983 :     }
; 1984 :     else

  00462	eb 34		 jmp	 SHORT $L49523
$L49458:

; 1985 :     {
; 1986 :         DPF_ERROR("No entries added yet");

  00464	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00469	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@CEMK@CWaveBank?3?3GenerateBank?$AA@ ; `string'
  0046e	68 c2 07 00 00	 push	 1986			; 000007c2H
  00473	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00478	6a 01		 push	 1
  0047a	6a 09		 push	 9
  0047c	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00481	83 c4 18	 add	 esp, 24			; 00000018H
  00484	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@DLDC@No?5entries?5added?5yet?$AA@ ; `string'
  00489	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0048e	83 c4 04	 add	 esp, 4

; 1987 :         hr = E_FAIL;

  00491	c7 45 c4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49523:

; 1988 :     }
; 1989 : 
; 1990 :     //
; 1991 :     // Clean up
; 1992 :     //
; 1993 : 
; 1994 :     MEMFREE(pvCopyBuffer);

  00498	83 7d c0 00	 cmp	 DWORD PTR _pvCopyBuffer$[ebp], 0
  0049c	74 10		 je	 SHORT $L49526
  0049e	8b 45 c0	 mov	 eax, DWORD PTR _pvCopyBuffer$[ebp]
  004a1	50		 push	 eax
  004a2	e8 00 00 00 00	 call	 ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPoolFree
  004a7	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _pvCopyBuffer$[ebp], 0
$L49526:

; 1995 :     MEMFREE(paMetaData);

  004ae	83 7d b8 00	 cmp	 DWORD PTR _paMetaData$[ebp], 0
  004b2	74 10		 je	 SHORT $L49527
  004b4	8b 4d b8	 mov	 ecx, DWORD PTR _paMetaData$[ebp]
  004b7	51		 push	 ecx
  004b8	e8 00 00 00 00	 call	 ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPoolFree
  004bd	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _paMetaData$[ebp], 0
$L49527:

; 1996 : 
; 1997 :     DPF_LEAVE_HRESULT(hr);
; 1998 : 
; 1999 :     return hr;

  004c4	8b 55 c4	 mov	 edx, DWORD PTR _hr$[ebp]
  004c7	89 55 b4	 mov	 DWORD PTR $T51607[ebp], edx
  004ca	8d 4d d0	 lea	 ecx, DWORD PTR _BankFile$[ebp]
  004cd	e8 00 00 00 00	 call	 ??1CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::~CStdFileStream
  004d2	8b 45 b4	 mov	 eax, DWORD PTR $T51607[ebp]

; 2000 : }

  004d5	8b e5		 mov	 esp, ebp
  004d7	5d		 pop	 ebp
  004d8	c2 08 00	 ret	 8
?GenerateBank@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z ENDP ; CWaveBank::GenerateBank
_TEXT	ENDS
PUBLIC	??_C@_0BK@DFCH@CWaveBank?3?3GenerateHeader?$AA@	; `string'
PUBLIC	??_C@_0DP@PPNC@An?5error?5occurred?5while?5attempti@ ; `string'
PUBLIC	??_C@_0BK@OAEM@dwEntry?5?$DN?$DN?5m_dwEntryCount?$AA@ ; `string'
;	COMDAT ??_C@_0BK@DFCH@CWaveBank?3?3GenerateHeader?$AA@
CONST	SEGMENT
??_C@_0BK@DFCH@CWaveBank?3?3GenerateHeader?$AA@ DB 'CWaveBank::GenerateHe'
	DB	'ader', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@PPNC@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT
??_C@_0DP@PPNC@An?5error?5occurred?5while?5attempti@ DB 'An error occurre'
	DB	'd while attempting to write to the header file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OAEM@dwEntry?5?$DN?$DN?5m_dwEntryCount?$AA@
CONST	SEGMENT
??_C@_0BK@OAEM@dwEntry?5?$DN?$DN?5m_dwEntryCount?$AA@ DB 'dwEntry == m_dw'
	DB	'EntryCount', 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z
_TEXT	SEGMENT
_pCallback$ = 8
_fAllowOverwrite$ = 12
_this$ = -296
_hr$ = -276
_HeaderFile$ = -288
_szText$ = -264
_pleEntry$ = -280
_pEntry$ = -268
_dwEntry$ = -272
$T51611 = -292
?GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z PROC NEAR ; CWaveBank::GenerateHeader, COMDAT
; _this$ = ecx

; 2027 : {                                   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  00009	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 2028 :     static const LPCSTR     pszFileBegin            = "#pragma once\r\n\r\n";
; 2029 :     static const LPCSTR     pszEnumBegin            = "typedef enum\r\n{\r\n";
; 2030 :     static const LPCSTR     pszEnumEnd              = "} " WBCHEADER_ENUMNAME ";\r\n\r\n";
; 2031 :     static const LPCSTR     pszEnumEntry            = "    " WBCHEADER_ENUMENTRYNAME " = %lu,\r\n";
; 2032 :     static const LPCSTR     pszEnumCount            = "#define " WBCHEADER_ENTRYCOUNTNAME " %lu\r\n";
; 2033 :     HRESULT                 hr                      = S_OK;

  0000f	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _hr$[ebp], 0

; 2034 :     CStdFileStream          HeaderFile;

  00019	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _HeaderFile$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::CStdFileStream

; 2035 :     CHAR                    szText[MAX_PATH];
; 2036 :     PLIST_ENTRY             pleEntry;
; 2037 :     CWaveBankEntry *        pEntry;
; 2038 :     DWORD                   dwEntry;
; 2039 :     
; 2040 :     DPF_ENTER();
; 2041 : 
; 2042 :     if(m_dwEntryCount)

  00024	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 b8 40 02 00
	00 00		 cmp	 DWORD PTR [eax+576], 0
  00031	0f 84 00 04 00
	00		 je	 $L49556

; 2043 :     {
; 2044 :         //
; 2045 :         // Call the callback
; 2046 :         //
; 2047 : 
; 2048 :         if(pCallback)

  00037	83 7d 08 00	 cmp	 DWORD PTR _pCallback$[ebp], 0
  0003b	74 26		 je	 SHORT $L49557

; 2049 :         {
; 2050 :             if(!pCallback->OpenHeader(m_szHeaderFile))

  0003d	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00043	81 c1 34 01 00
	00		 add	 ecx, 308		; 00000134H
  00049	51		 push	 ecx
  0004a	8b 55 08	 mov	 edx, DWORD PTR _pCallback$[ebp]
  0004d	8b 02		 mov	 eax, DWORD PTR [edx]
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _pCallback$[ebp]
  00052	ff 50 10	 call	 DWORD PTR [eax+16]
  00055	85 c0		 test	 eax, eax
  00057	75 0a		 jne	 SHORT $L49558

; 2051 :             {
; 2052 :                 hr = E_ABORT;

  00059	c7 85 ec fe ff
	ff 04 40 00 80	 mov	 DWORD PTR _hr$[ebp], -2147467260 ; 80004004H
$L49558:
$L49557:

; 2053 :             }
; 2054 :         }
; 2055 : 
; 2056 :         //
; 2057 :         // Open the bank file
; 2058 :         //
; 2059 : 
; 2060 :         if(SUCCEEDED(hr))

  00063	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  0006a	7c 77		 jl	 SHORT $L49561

; 2061 :         {
; 2062 :             if(FAILED(hr = HeaderFile.Open(m_szHeaderFile, GENERIC_READ | GENERIC_WRITE, 0, fAllowOverwrite ? CREATE_ALWAYS : CREATE_NEW, FILE_FLAG_SEQUENTIAL_SCAN)))

  0006c	68 00 00 00 08	 push	 134217728		; 08000000H
  00071	33 c9		 xor	 ecx, ecx
  00073	83 7d 0c 00	 cmp	 DWORD PTR _fAllowOverwrite$[ebp], 0
  00077	0f 95 c1	 setne	 cl
  0007a	41		 inc	 ecx
  0007b	51		 push	 ecx
  0007c	6a 00		 push	 0
  0007e	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00083	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00089	81 c2 34 01 00
	00		 add	 edx, 308		; 00000134H
  0008f	52		 push	 edx
  00090	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _HeaderFile$[ebp]
  00096	e8 00 00 00 00	 call	 ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z ; WaveLoader::CStdFileStream::Open
  0009b	89 85 ec fe ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax
  000a1	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  000a8	7d 39		 jge	 SHORT $L49563

; 2063 :             {
; 2064 :                 DPF_ERROR("An error occurred while attempting to open %s", m_szHeaderFile);

  000aa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000af	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@DFCH@CWaveBank?3?3GenerateHeader?$AA@ ; `string'
  000b4	68 10 08 00 00	 push	 2064			; 00000810H
  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000be	6a 01		 push	 1
  000c0	6a 09		 push	 9
  000c2	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000c7	83 c4 18	 add	 esp, 24			; 00000018H
  000ca	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000d0	05 34 01 00 00	 add	 eax, 308		; 00000134H
  000d5	50		 push	 eax
  000d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CO@EFJM@An?5error?5occurred?5while?5attempti@ ; `string'
  000db	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000e0	83 c4 08	 add	 esp, 8
$L49563:
$L49561:

; 2065 :             }
; 2066 :         }
; 2067 : 
; 2068 :         //
; 2069 :         // Write the file header
; 2070 :         //
; 2071 : 
; 2072 :         if(SUCCEEDED(hr))

  000e3	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  000ea	7c 60		 jl	 SHORT $L49566

; 2073 :         {
; 2074 :             if(FAILED(hr = HeaderFile.Write(pszFileBegin, strlen(pszFileBegin))))

  000ec	6a 00		 push	 0
  000ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszFileBegin@?1??GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z@4QBDB
  000f4	51		 push	 ecx
  000f5	e8 00 00 00 00	 call	 _strlen
  000fa	83 c4 04	 add	 esp, 4
  000fd	50		 push	 eax
  000fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pszFileBegin@?1??GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z@4QBDB
  00104	52		 push	 edx
  00105	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _HeaderFile$[ebp]
  0010b	e8 00 00 00 00	 call	 ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z ; WaveLoader::CStdFileStream::Write
  00110	89 85 ec fe ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax
  00116	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  0011d	7d 2d		 jge	 SHORT $L49568

; 2075 :             {
; 2076 :                 DPF_ERROR("An error occurred while attempting to write to the header file");

  0011f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00124	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@DFCH@CWaveBank?3?3GenerateHeader?$AA@ ; `string'
  00129	68 1c 08 00 00	 push	 2076			; 0000081cH
  0012e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00133	6a 01		 push	 1
  00135	6a 09		 push	 9
  00137	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0013c	83 c4 18	 add	 esp, 24			; 00000018H
  0013f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@PPNC@An?5error?5occurred?5while?5attempti@ ; `string'
  00144	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00149	83 c4 04	 add	 esp, 4
$L49568:
$L49566:

; 2077 :             }
; 2078 :         }
; 2079 : 
; 2080 :         //
; 2081 :         // Write the enumeration header
; 2082 :         //
; 2083 : 
; 2084 :         if(SUCCEEDED(hr))

  0014c	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  00153	7c 5f		 jl	 SHORT $L49571

; 2085 :         {
; 2086 :             if(FAILED(hr = HeaderFile.Write(pszEnumBegin, strlen(pszEnumBegin))))

  00155	6a 00		 push	 0
  00157	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pszEnumBegin@?1??GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z@4QBDB
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _strlen
  00162	83 c4 04	 add	 esp, 4
  00165	50		 push	 eax
  00166	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszEnumBegin@?1??GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z@4QBDB
  0016c	51		 push	 ecx
  0016d	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _HeaderFile$[ebp]
  00173	e8 00 00 00 00	 call	 ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z ; WaveLoader::CStdFileStream::Write
  00178	89 85 ec fe ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax
  0017e	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  00185	7d 2d		 jge	 SHORT $L49573

; 2087 :             {
; 2088 :                 DPF_ERROR("An error occurred while attempting to write to the header file");

  00187	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0018c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@DFCH@CWaveBank?3?3GenerateHeader?$AA@ ; `string'
  00191	68 28 08 00 00	 push	 2088			; 00000828H
  00196	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0019b	6a 01		 push	 1
  0019d	6a 09		 push	 9
  0019f	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  001a4	83 c4 18	 add	 esp, 24			; 00000018H
  001a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@PPNC@An?5error?5occurred?5while?5attempti@ ; `string'
  001ac	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001b1	83 c4 04	 add	 esp, 4
$L49573:
$L49571:

; 2089 :             }
; 2090 :         }
; 2091 : 
; 2092 :         //
; 2093 :         // Begin the entry loop
; 2094 :         //
; 2095 : 
; 2096 :         if(SUCCEEDED(hr))

  001b4	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  001bb	0f 8c 07 01 00
	00		 jl	 $L49575

; 2097 :         {
; 2098 :             for(pleEntry = m_lstEntries.Flink, dwEntry = 0; (pleEntry != &m_lstEntries) && SUCCEEDED(hr); pleEntry = pleEntry->Flink, dwEntry++)

  001c1	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001c7	8b 82 38 02 00
	00		 mov	 eax, DWORD PTR [edx+568]
  001cd	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _pleEntry$[ebp], eax
  001d3	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwEntry$[ebp], 0
  001dd	eb 1d		 jmp	 SHORT $L49577
$L49578:
  001df	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  001e5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001e7	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _pleEntry$[ebp], edx
  001ed	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _dwEntry$[ebp]
  001f3	83 c0 01	 add	 eax, 1
  001f6	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _dwEntry$[ebp], eax
$L49577:
  001fc	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00202	81 c1 38 02 00
	00		 add	 ecx, 568		; 00000238H
  00208	39 8d e8 fe ff
	ff		 cmp	 DWORD PTR _pleEntry$[ebp], ecx
  0020e	0f 84 b4 00 00
	00		 je	 $L49579
  00214	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  0021b	0f 8c a7 00 00
	00		 jl	 $L49579

; 2099 :             {
; 2100 :                 pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

  00221	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _pleEntry$[ebp]
  00227	83 ea 08	 sub	 edx, 8
  0022a	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _pEntry$[ebp], edx

; 2101 : 
; 2102 :                 //
; 2103 :                 // Add the entry to the enumeration
; 2104 :                 //
; 2105 : 
; 2106 :                 sprintf(szText, pszEnumEntry, m_szHeaderName, pEntry->m_szHeaderName, dwEntry);

  00230	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _dwEntry$[ebp]
  00236	50		 push	 eax
  00237	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _pEntry$[ebp]
  0023d	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  00243	51		 push	 ecx
  00244	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0024a	83 c2 20	 add	 edx, 32			; 00000020H
  0024d	52		 push	 edx
  0024e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pszEnumEntry@?1??GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z@4QBDB
  00253	50		 push	 eax
  00254	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szText$[ebp]
  0025a	51		 push	 ecx
  0025b	e8 00 00 00 00	 call	 _sprintf
  00260	83 c4 14	 add	 esp, 20			; 00000014H

; 2107 : 
; 2108 :                 if(FAILED(hr = HeaderFile.Write(szText, strlen(szText))))

  00263	6a 00		 push	 0
  00265	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szText$[ebp]
  0026b	52		 push	 edx
  0026c	e8 00 00 00 00	 call	 _strlen
  00271	83 c4 04	 add	 esp, 4
  00274	50		 push	 eax
  00275	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  0027b	50		 push	 eax
  0027c	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _HeaderFile$[ebp]
  00282	e8 00 00 00 00	 call	 ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z ; WaveLoader::CStdFileStream::Write
  00287	89 85 ec fe ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax
  0028d	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  00294	7d 2d		 jge	 SHORT $L49585

; 2109 :                 {
; 2110 :                     DPF_ERROR("An error occurred while attempting to write to the header file");

  00296	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0029b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@DFCH@CWaveBank?3?3GenerateHeader?$AA@ ; `string'
  002a0	68 3e 08 00 00	 push	 2110			; 0000083eH
  002a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  002aa	6a 01		 push	 1
  002ac	6a 09		 push	 9
  002ae	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  002b3	83 c4 18	 add	 esp, 24			; 00000018H
  002b6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@PPNC@An?5error?5occurred?5while?5attempti@ ; `string'
  002bb	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  002c0	83 c4 04	 add	 esp, 4
$L49585:

; 2111 :                 }
; 2112 :             }

  002c3	e9 17 ff ff ff	 jmp	 $L49578
$L49579:
$L49575:

; 2113 :         }
; 2114 : 
; 2115 :         //
; 2116 :         // End the enumeration
; 2117 :         //
; 2118 : 
; 2119 :         if(SUCCEEDED(hr))

  002c8	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  002cf	0f 8c 80 00 00
	00		 jl	 $L49587

; 2120 :         {
; 2121 :             sprintf(szText, pszEnumEnd, m_szHeaderName);

  002d5	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002db	83 c1 20	 add	 ecx, 32			; 00000020H
  002de	51		 push	 ecx
  002df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pszEnumEnd@?1??GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z@4QBDB
  002e5	52		 push	 edx
  002e6	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  002ec	50		 push	 eax
  002ed	e8 00 00 00 00	 call	 _sprintf
  002f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2122 : 
; 2123 :             if(FAILED(hr = HeaderFile.Write(szText, strlen(szText))))

  002f5	6a 00		 push	 0
  002f7	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szText$[ebp]
  002fd	51		 push	 ecx
  002fe	e8 00 00 00 00	 call	 _strlen
  00303	83 c4 04	 add	 esp, 4
  00306	50		 push	 eax
  00307	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szText$[ebp]
  0030d	52		 push	 edx
  0030e	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _HeaderFile$[ebp]
  00314	e8 00 00 00 00	 call	 ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z ; WaveLoader::CStdFileStream::Write
  00319	89 85 ec fe ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax
  0031f	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  00326	7d 2d		 jge	 SHORT $L49589

; 2124 :             {
; 2125 :                 DPF_ERROR("An error occurred while attempting to write to the header file");

  00328	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0032d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@DFCH@CWaveBank?3?3GenerateHeader?$AA@ ; `string'
  00332	68 4d 08 00 00	 push	 2125			; 0000084dH
  00337	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0033c	6a 01		 push	 1
  0033e	6a 09		 push	 9
  00340	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00345	83 c4 18	 add	 esp, 24			; 00000018H
  00348	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@PPNC@An?5error?5occurred?5while?5attempti@ ; `string'
  0034d	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00352	83 c4 04	 add	 esp, 4
$L49589:
$L49587:

; 2126 :             }
; 2127 :         }
; 2128 : 
; 2129 :         //
; 2130 :         // Add a count
; 2131 :         //
; 2132 : 
; 2133 :         if(SUCCEEDED(hr))

  00355	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  0035c	0f 8c b6 00 00
	00		 jl	 $L49591

; 2134 :         {
; 2135 :             ASSERT(dwEntry == m_dwEntryCount);

  00362	68 57 08 00 00	 push	 2135			; 00000857H
  00367	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0036c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@OAEM@dwEntry?5?$DN?$DN?5m_dwEntryCount?$AA@ ; `string'
  00371	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00377	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _dwEntry$[ebp]
  0037d	33 d2		 xor	 edx, edx
  0037f	3b 88 40 02 00
	00		 cmp	 ecx, DWORD PTR [eax+576]
  00385	0f 95 c2	 setne	 dl
  00388	52		 push	 edx
  00389	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0038e	83 c4 10	 add	 esp, 16			; 00000010H

; 2136 :             
; 2137 :             sprintf(szText, pszEnumCount, m_szHeaderName, dwEntry);

  00391	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _dwEntry$[ebp]
  00397	50		 push	 eax
  00398	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0039e	83 c1 20	 add	 ecx, 32			; 00000020H
  003a1	51		 push	 ecx
  003a2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pszEnumCount@?1??GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z@4QBDB
  003a8	52		 push	 edx
  003a9	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  003af	50		 push	 eax
  003b0	e8 00 00 00 00	 call	 _sprintf
  003b5	83 c4 10	 add	 esp, 16			; 00000010H

; 2138 : 
; 2139 :             if(FAILED(hr = HeaderFile.Write(szText, strlen(szText))))

  003b8	6a 00		 push	 0
  003ba	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szText$[ebp]
  003c0	51		 push	 ecx
  003c1	e8 00 00 00 00	 call	 _strlen
  003c6	83 c4 04	 add	 esp, 4
  003c9	50		 push	 eax
  003ca	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szText$[ebp]
  003d0	52		 push	 edx
  003d1	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _HeaderFile$[ebp]
  003d7	e8 00 00 00 00	 call	 ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z ; WaveLoader::CStdFileStream::Write
  003dc	89 85 ec fe ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax
  003e2	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  003e9	7d 2d		 jge	 SHORT $L49594

; 2140 :             {
; 2141 :                 DPF_ERROR("An error occurred while attempting to write to the header file");

  003eb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  003f0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@DFCH@CWaveBank?3?3GenerateHeader?$AA@ ; `string'
  003f5	68 5d 08 00 00	 push	 2141			; 0000085dH
  003fa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  003ff	6a 01		 push	 1
  00401	6a 09		 push	 9
  00403	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00408	83 c4 18	 add	 esp, 24			; 00000018H
  0040b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@PPNC@An?5error?5occurred?5while?5attempti@ ; `string'
  00410	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00415	83 c4 04	 add	 esp, 4
$L49594:
$L49591:

; 2142 :             }
; 2143 :         }
; 2144 : 
; 2145 :         //
; 2146 :         // Call the callback
; 2147 :         //
; 2148 : 
; 2149 :         if(pCallback)

  00418	83 7d 08 00	 cmp	 DWORD PTR _pCallback$[ebp], 0
  0041c	74 17		 je	 SHORT $L49595

; 2150 :         {
; 2151 :             pCallback->CloseHeader(m_szHeaderFile);

  0041e	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00424	05 34 01 00 00	 add	 eax, 308		; 00000134H
  00429	50		 push	 eax
  0042a	8b 4d 08	 mov	 ecx, DWORD PTR _pCallback$[ebp]
  0042d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0042f	8b 4d 08	 mov	 ecx, DWORD PTR _pCallback$[ebp]
  00432	ff 52 14	 call	 DWORD PTR [edx+20]
$L49595:

; 2152 :         }
; 2153 :     }
; 2154 :     else

  00435	eb 37		 jmp	 SHORT $L49596
$L49556:

; 2155 :     {
; 2156 :         DPF_ERROR("No entries added yet");

  00437	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0043c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@DFCH@CWaveBank?3?3GenerateHeader?$AA@ ; `string'
  00441	68 6c 08 00 00	 push	 2156			; 0000086cH
  00446	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0044b	6a 01		 push	 1
  0044d	6a 09		 push	 9
  0044f	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00454	83 c4 18	 add	 esp, 24			; 00000018H
  00457	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@DLDC@No?5entries?5added?5yet?$AA@ ; `string'
  0045c	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00461	83 c4 04	 add	 esp, 4

; 2157 :         hr = E_FAIL;

  00464	c7 85 ec fe ff
	ff 05 40 00 80	 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49596:

; 2158 :     }
; 2159 : 
; 2160 :     DPF_LEAVE_HRESULT(hr);
; 2161 : 
; 2162 :     return hr;

  0046e	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _hr$[ebp]
  00474	89 85 dc fe ff
	ff		 mov	 DWORD PTR $T51611[ebp], eax
  0047a	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _HeaderFile$[ebp]
  00480	e8 00 00 00 00	 call	 ??1CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::~CStdFileStream
  00485	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR $T51611[ebp]

; 2163 : }

  0048b	8b e5		 mov	 esp, ebp
  0048d	5d		 pop	 ebp
  0048e	c2 08 00	 ret	 8
?GenerateHeader@CWaveBank@@UAEJPAVCWaveBankCallback@@H@Z ENDP ; CWaveBank::GenerateHeader
_TEXT	ENDS
PUBLIC	??_C@_07EKKD@BANK?$CFlu?$AA@			; `string'
PUBLIC	??_C@_08MAGD@BANKNAME?$AA@			; `string'
PUBLIC	??_C@_08GMOM@BANKFILE?$AA@			; `string'
PUBLIC	??_C@_0L@EHAE@HEADERFILE?$AA@			; `string'
PUBLIC	??_C@_0L@OCBI@ENTRYCOUNT?$AA@			; `string'
EXTRN	__imp__GetPrivateProfileIntA@16:NEAR
;	COMDAT ??_C@_07EKKD@BANK?$CFlu?$AA@
CONST	SEGMENT
??_C@_07EKKD@BANK?$CFlu?$AA@ DB 'BANK%lu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MAGD@BANKNAME?$AA@
CONST	SEGMENT
??_C@_08MAGD@BANKNAME?$AA@ DB 'BANKNAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GMOM@BANKFILE?$AA@
CONST	SEGMENT
??_C@_08GMOM@BANKFILE?$AA@ DB 'BANKFILE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EHAE@HEADERFILE?$AA@
CONST	SEGMENT
??_C@_0L@EHAE@HEADERFILE?$AA@ DB 'HEADERFILE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OCBI@ENTRYCOUNT?$AA@
CONST	SEGMENT
??_C@_0L@OCBI@ENTRYCOUNT?$AA@ DB 'ENTRYCOUNT', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ReadProjectData@CWaveBank@@UAEJPBDK@Z
_TEXT	SEGMENT
$T51615 = -1080
$T51616 = -1084
_pszProjectFile$ = 8
_dwBankIndex$ = 12
_this$ = -1088
_hr$ = -272
_szSectionName$ = -808
_szBankName$ = -544
_szBankFile$ = -264
_szHeaderFile$ = -1072
_dwEntryCount$ = -280
_pEntry$ = -268
_hrEntry$ = -1076
_i$ = -276
?ReadProjectData@CWaveBank@@UAEJPBDK@Z PROC NEAR	; CWaveBank::ReadProjectData, COMDAT
; _this$ = ecx

; 2191 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 04 00
	00		 sub	 esp, 1092		; 00000444H
  00009	89 8d c0 fb ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 2192 :     HRESULT                 hr                      = S_OK;

  0000f	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _hr$[ebp], 0

; 2193 :     CHAR                    szSectionName[MAX_PATH];
; 2194 :     CHAR                    szBankName[MAX_PATH];
; 2195 :     CHAR                    szBankFile[MAX_PATH];
; 2196 :     CHAR                    szHeaderFile[MAX_PATH];
; 2197 :     DWORD                   dwEntryCount;
; 2198 :     CWaveBankEntry *        pEntry;
; 2199 :     HRESULT                 hrEntry;
; 2200 :     DWORD                   i;
; 2201 :     
; 2202 :     DPF_ENTER();
; 2203 : 
; 2204 :     sprintf(szSectionName, WBPROJECT_BANK_KEY, dwBankIndex);

  00019	8b 45 0c	 mov	 eax, DWORD PTR _dwBankIndex$[ebp]
  0001c	50		 push	 eax
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EKKD@BANK?$CFlu?$AA@ ; `string'
  00022	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR _szSectionName$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _sprintf
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2205 : 
; 2206 :     GetPrivateProfileString(szSectionName, WBPROJECT_BANK_NAME_KEY, "", szBankName, NUMELMS(szBankName), pszProjectFile);

  00031	8b 55 08	 mov	 edx, DWORD PTR _pszProjectFile$[ebp]
  00034	52		 push	 edx
  00035	68 04 01 00 00	 push	 260			; 00000104H
  0003a	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _szBankName$[ebp]
  00040	50		 push	 eax
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08MAGD@BANKNAME?$AA@ ; `string'
  0004b	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR _szSectionName$[ebp]
  00051	51		 push	 ecx
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 2207 :     GetPrivateProfileString(szSectionName, WBPROJECT_BANK_FILE_KEY, "", szBankFile, NUMELMS(szBankFile), pszProjectFile);

  00058	8b 55 08	 mov	 edx, DWORD PTR _pszProjectFile$[ebp]
  0005b	52		 push	 edx
  0005c	68 04 01 00 00	 push	 260			; 00000104H
  00061	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szBankFile$[ebp]
  00067	50		 push	 eax
  00068	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GMOM@BANKFILE?$AA@ ; `string'
  00072	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR _szSectionName$[ebp]
  00078	51		 push	 ecx
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 2208 :     GetPrivateProfileString(szSectionName, WBPROJECT_BANK_HEADER_KEY, "", szHeaderFile, NUMELMS(szHeaderFile), pszProjectFile);

  0007f	8b 55 08	 mov	 edx, DWORD PTR _pszProjectFile$[ebp]
  00082	52		 push	 edx
  00083	68 04 01 00 00	 push	 260			; 00000104H
  00088	8d 85 d0 fb ff
	ff		 lea	 eax, DWORD PTR _szHeaderFile$[ebp]
  0008e	50		 push	 eax
  0008f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
  00094	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@EHAE@HEADERFILE?$AA@ ; `string'
  00099	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR _szSectionName$[ebp]
  0009f	51		 push	 ecx
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 2209 : 
; 2210 :     hr = Initialize(szBankName, szBankFile, szHeaderFile);

  000a6	8d 95 d0 fb ff
	ff		 lea	 edx, DWORD PTR _szHeaderFile$[ebp]
  000ac	52		 push	 edx
  000ad	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szBankFile$[ebp]
  000b3	50		 push	 eax
  000b4	8d 8d e0 fd ff
	ff		 lea	 ecx, DWORD PTR _szBankName$[ebp]
  000ba	51		 push	 ecx
  000bb	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000c1	8b 02		 mov	 eax, DWORD PTR [edx]
  000c3	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	ff 50 04	 call	 DWORD PTR [eax+4]
  000cc	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 2211 : 
; 2212 :     if(SUCCEEDED(hr))

  000d2	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  000d9	0f 8c 23 01 00
	00		 jl	 $L49619

; 2213 :     {
; 2214 :         dwEntryCount = GetPrivateProfileInt(szSectionName, WBPROJECT_BANK_ENTRYCOUNT_KEY, 0, pszProjectFile);

  000df	8b 4d 08	 mov	 ecx, DWORD PTR _pszProjectFile$[ebp]
  000e2	51		 push	 ecx
  000e3	6a 00		 push	 0
  000e5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@OCBI@ENTRYCOUNT?$AA@ ; `string'
  000ea	8d 95 d8 fc ff
	ff		 lea	 edx, DWORD PTR _szSectionName$[ebp]
  000f0	52		 push	 edx
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000f7	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _dwEntryCount$[ebp], eax

; 2215 : 
; 2216 :         for(i = 0; (i < dwEntryCount) && SUCCEEDED(hr); i++)

  000fd	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00107	eb 0f		 jmp	 SHORT $L49622
$L49623:
  00109	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0010f	83 c0 01	 add	 eax, 1
  00112	89 85 ec fe ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L49622:
  00118	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0011e	3b 8d e8 fe ff
	ff		 cmp	 ecx, DWORD PTR _dwEntryCount$[ebp]
  00124	0f 83 d8 00 00
	00		 jae	 $L49624
  0012a	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  00131	0f 8c cb 00 00
	00		 jl	 $L49624

; 2217 :         {
; 2218 :             hrEntry = HRFROMP(pEntry = CreateEntry());

  00137	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0013d	8b 02		 mov	 eax, DWORD PTR [edx]
  0013f	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00145	ff 50 28	 call	 DWORD PTR [eax+40]
  00148	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _pEntry$[ebp], eax
  0014e	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _pEntry$[ebp]
  00154	f7 d9		 neg	 ecx
  00156	1b c9		 sbb	 ecx, ecx
  00158	81 e1 f2 ff f8
	7f		 and	 ecx, 2147024882		; 7ff8fff2H
  0015e	81 c1 0e 00 07
	80		 add	 ecx, -2147024882	; 8007000eH
  00164	89 8d cc fb ff
	ff		 mov	 DWORD PTR _hrEntry$[ebp], ecx

; 2219 : 
; 2220 :             if(SUCCEEDED(hrEntry))

  0016a	83 bd cc fb ff
	ff 00		 cmp	 DWORD PTR _hrEntry$[ebp], 0
  00171	7c 29		 jl	 SHORT $L49628

; 2221 :             {
; 2222 :                 hrEntry = pEntry->ReadProjectData(pszProjectFile, szSectionName, i);

  00173	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00179	52		 push	 edx
  0017a	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR _szSectionName$[ebp]
  00180	50		 push	 eax
  00181	8b 4d 08	 mov	 ecx, DWORD PTR _pszProjectFile$[ebp]
  00184	51		 push	 ecx
  00185	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _pEntry$[ebp]
  0018b	8b 02		 mov	 eax, DWORD PTR [edx]
  0018d	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _pEntry$[ebp]
  00193	ff 50 1c	 call	 DWORD PTR [eax+28]
  00196	89 85 cc fb ff
	ff		 mov	 DWORD PTR _hrEntry$[ebp], eax
$L49628:

; 2223 :             }
; 2224 : 
; 2225 :             if(FAILED(hrEntry))

  0019c	83 bd cc fb ff
	ff 00		 cmp	 DWORD PTR _hrEntry$[ebp], 0
  001a3	7d 58		 jge	 SHORT $L49630

; 2226 :             {
; 2227 :                 DELETE(pEntry);

  001a5	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR _pEntry$[ebp], 0
  001ac	74 4f		 je	 SHORT $L49631
  001ae	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _pEntry$[ebp]
  001b4	89 8d c4 fb ff
	ff		 mov	 DWORD PTR $T51616[ebp], ecx
  001ba	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR $T51616[ebp]
  001c0	89 95 c8 fb ff
	ff		 mov	 DWORD PTR $T51615[ebp], edx
  001c6	83 bd c8 fb ff
	ff 00		 cmp	 DWORD PTR $T51615[ebp], 0
  001cd	74 1a		 je	 SHORT $L51617
  001cf	6a 01		 push	 1
  001d1	8b 85 c8 fb ff
	ff		 mov	 eax, DWORD PTR $T51615[ebp]
  001d7	8b 10		 mov	 edx, DWORD PTR [eax]
  001d9	8b 8d c8 fb ff
	ff		 mov	 ecx, DWORD PTR $T51615[ebp]
  001df	ff 12		 call	 DWORD PTR [edx]
  001e1	89 85 bc fb ff
	ff		 mov	 DWORD PTR -1092+[ebp], eax
  001e7	eb 0a		 jmp	 SHORT $L51618
$L51617:
  001e9	c7 85 bc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR -1092+[ebp], 0
$L51618:
  001f3	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pEntry$[ebp], 0
$L49631:
$L49630:

; 2228 :             }
; 2229 :         }

  001fd	e9 07 ff ff ff	 jmp	 $L49623
$L49624:
$L49619:

; 2230 :     }
; 2231 : 
; 2232 :     DPF_LEAVE_HRESULT(hr);
; 2233 : 
; 2234 :     return hr;

  00202	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _hr$[ebp]

; 2235 : }

  00208	8b e5		 mov	 esp, ebp
  0020a	5d		 pop	 ebp
  0020b	c2 08 00	 ret	 8
?ReadProjectData@CWaveBank@@UAEJPBDK@Z ENDP		; CWaveBank::ReadProjectData
_TEXT	ENDS
PUBLIC	??_C@_0BM@LOJ@CWaveBank?3?3WriteProjectData?$AA@ ; `string'
PUBLIC	??_C@_0EA@BMIG@An?5error?5occurred?5while?5attempti@ ; `string'
PUBLIC	??_C@_03JGAL@?$CFlu?$AA@			; `string'
PUBLIC	??_C@_0BD@FBPA@i?5?$DM?5m_dwEntryCount?$AA@	; `string'
PUBLIC	??_C@_0BE@DJKC@i?5?$DN?$DN?5m_dwEntryCount?$AA@	; `string'
;	COMDAT ??_C@_0BM@LOJ@CWaveBank?3?3WriteProjectData?$AA@
CONST	SEGMENT
??_C@_0BM@LOJ@CWaveBank?3?3WriteProjectData?$AA@ DB 'CWaveBank::WriteProj'
	DB	'ectData', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@BMIG@An?5error?5occurred?5while?5attempti@
CONST	SEGMENT
??_C@_0EA@BMIG@An?5error?5occurred?5while?5attempti@ DB 'An error occurre'
	DB	'd while attempting to write to the project file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JGAL@?$CFlu?$AA@
CONST	SEGMENT
??_C@_03JGAL@?$CFlu?$AA@ DB '%lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FBPA@i?5?$DM?5m_dwEntryCount?$AA@
CONST	SEGMENT
??_C@_0BD@FBPA@i?5?$DM?5m_dwEntryCount?$AA@ DB 'i < m_dwEntryCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DJKC@i?5?$DN?$DN?5m_dwEntryCount?$AA@
CONST	SEGMENT
??_C@_0BE@DJKC@i?5?$DN?$DN?5m_dwEntryCount?$AA@ DB 'i == m_dwEntryCount', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?WriteProjectData@CWaveBank@@UAEJPBDK@Z
_TEXT	SEGMENT
_pszProjectFile$ = 8
_dwBankIndex$ = 12
_this$ = -548
_hr$ = -272
_szSectionName$ = -544
_szText$ = -264
_pleEntry$ = -280
_pEntry$ = -268
_i$ = -276
?WriteProjectData@CWaveBank@@UAEJPBDK@Z PROC NEAR	; CWaveBank::WriteProjectData, COMDAT
; _this$ = ecx

; 2263 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 02 00
	00		 sub	 esp, 548		; 00000224H
  00009	89 8d dc fd ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 2264 :     HRESULT                 hr                      = S_OK;

  0000f	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _hr$[ebp], 0

; 2265 :     CHAR                    szSectionName[MAX_PATH];
; 2266 :     CHAR                    szText[MAX_PATH];
; 2267 :     PLIST_ENTRY             pleEntry;
; 2268 :     CWaveBankEntry *        pEntry;
; 2269 :     DWORD                   i;
; 2270 :     
; 2271 :     DPF_ENTER();
; 2272 : 
; 2273 :     sprintf(szSectionName, WBPROJECT_BANK_KEY, dwBankIndex);

  00019	8b 45 0c	 mov	 eax, DWORD PTR _dwBankIndex$[ebp]
  0001c	50		 push	 eax
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EKKD@BANK?$CFlu?$AA@ ; `string'
  00022	8d 8d e0 fd ff
	ff		 lea	 ecx, DWORD PTR _szSectionName$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _sprintf
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2274 :     
; 2275 :     if(!WritePrivateProfileString(szSectionName, WBPROJECT_BANK_NAME_KEY, m_szBankName, pszProjectFile))

  00031	8b 55 08	 mov	 edx, DWORD PTR _pszProjectFile$[ebp]
  00034	52		 push	 edx
  00035	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0003b	83 c0 10	 add	 eax, 16			; 00000010H
  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08MAGD@BANKNAME?$AA@ ; `string'
  00044	8d 8d e0 fd ff
	ff		 lea	 ecx, DWORD PTR _szSectionName$[ebp]
  0004a	51		 push	 ecx
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16
  00051	85 c0		 test	 eax, eax
  00053	75 37		 jne	 SHORT $L49646

; 2276 :     {
; 2277 :         DPF_ERROR("An error occurred while attempting to write to the project file");

  00055	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0005a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@LOJ@CWaveBank?3?3WriteProjectData?$AA@ ; `string'
  0005f	68 e5 08 00 00	 push	 2277			; 000008e5H
  00064	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00069	6a 01		 push	 1
  0006b	6a 09		 push	 9
  0006d	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00072	83 c4 18	 add	 esp, 24			; 00000018H
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@BMIG@An?5error?5occurred?5while?5attempti@ ; `string'
  0007a	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0007f	83 c4 04	 add	 esp, 4

; 2278 :         hr = E_FAIL;

  00082	c7 85 f0 fe ff
	ff 05 40 00 80	 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49646:

; 2279 :     }        
; 2280 : 
; 2281 :     if(SUCCEEDED(hr))

  0008c	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  00093	7c 72		 jl	 SHORT $L49651

; 2282 :     {
; 2283 :         GetRelativePath(pszProjectFile, m_szBankFile, szText);

  00095	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szText$[ebp]
  0009b	52		 push	 edx
  0009c	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000a2	83 c0 30	 add	 eax, 48			; 00000030H
  000a5	50		 push	 eax
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _pszProjectFile$[ebp]
  000a9	51		 push	 ecx
  000aa	e8 00 00 00 00	 call	 ?GetRelativePath@@YGXPBD0PAD@Z ; GetRelativePath

; 2284 :         
; 2285 :         if(!WritePrivateProfileString(szSectionName, WBPROJECT_BANK_FILE_KEY, szText, pszProjectFile))

  000af	8b 55 08	 mov	 edx, DWORD PTR _pszProjectFile$[ebp]
  000b2	52		 push	 edx
  000b3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  000b9	50		 push	 eax
  000ba	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GMOM@BANKFILE?$AA@ ; `string'
  000bf	8d 8d e0 fd ff
	ff		 lea	 ecx, DWORD PTR _szSectionName$[ebp]
  000c5	51		 push	 ecx
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16
  000cc	85 c0		 test	 eax, eax
  000ce	75 37		 jne	 SHORT $L49652

; 2286 :         {
; 2287 :             DPF_ERROR("An error occurred while attempting to write to the project file");

  000d0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000d5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@LOJ@CWaveBank?3?3WriteProjectData?$AA@ ; `string'
  000da	68 ef 08 00 00	 push	 2287			; 000008efH
  000df	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000e4	6a 01		 push	 1
  000e6	6a 09		 push	 9
  000e8	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000ed	83 c4 18	 add	 esp, 24			; 00000018H
  000f0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@BMIG@An?5error?5occurred?5while?5attempti@ ; `string'
  000f5	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000fa	83 c4 04	 add	 esp, 4

; 2288 :             hr = E_FAIL;

  000fd	c7 85 f0 fe ff
	ff 05 40 00 80	 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49652:
$L49651:

; 2289 :         }
; 2290 :     }
; 2291 : 
; 2292 :     if(SUCCEEDED(hr))

  00107	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  0010e	7c 74		 jl	 SHORT $L49655

; 2293 :     {
; 2294 :         GetRelativePath(pszProjectFile, m_szHeaderFile, szText);

  00110	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szText$[ebp]
  00116	52		 push	 edx
  00117	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0011d	05 34 01 00 00	 add	 eax, 308		; 00000134H
  00122	50		 push	 eax
  00123	8b 4d 08	 mov	 ecx, DWORD PTR _pszProjectFile$[ebp]
  00126	51		 push	 ecx
  00127	e8 00 00 00 00	 call	 ?GetRelativePath@@YGXPBD0PAD@Z ; GetRelativePath

; 2295 :         
; 2296 :         if(!WritePrivateProfileString(szSectionName, WBPROJECT_BANK_HEADER_KEY, szText, pszProjectFile))

  0012c	8b 55 08	 mov	 edx, DWORD PTR _pszProjectFile$[ebp]
  0012f	52		 push	 edx
  00130	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  00136	50		 push	 eax
  00137	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@EHAE@HEADERFILE?$AA@ ; `string'
  0013c	8d 8d e0 fd ff
	ff		 lea	 ecx, DWORD PTR _szSectionName$[ebp]
  00142	51		 push	 ecx
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16
  00149	85 c0		 test	 eax, eax
  0014b	75 37		 jne	 SHORT $L49656

; 2297 :         {
; 2298 :             DPF_ERROR("An error occurred while attempting to write to the project file");

  0014d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00152	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@LOJ@CWaveBank?3?3WriteProjectData?$AA@ ; `string'
  00157	68 fa 08 00 00	 push	 2298			; 000008faH
  0015c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00161	6a 01		 push	 1
  00163	6a 09		 push	 9
  00165	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0016a	83 c4 18	 add	 esp, 24			; 00000018H
  0016d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@BMIG@An?5error?5occurred?5while?5attempti@ ; `string'
  00172	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00177	83 c4 04	 add	 esp, 4

; 2299 :             hr = E_FAIL;

  0017a	c7 85 f0 fe ff
	ff 05 40 00 80	 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49656:
$L49655:

; 2300 :         }        
; 2301 :     }
; 2302 : 
; 2303 :     if(SUCCEEDED(hr))

  00184	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  0018b	7c 79		 jl	 SHORT $L49659

; 2304 :     {
; 2305 :         sprintf(szText, "%lu", m_dwEntryCount);

  0018d	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00193	8b 82 40 02 00
	00		 mov	 eax, DWORD PTR [edx+576]
  00199	50		 push	 eax
  0019a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03JGAL@?$CFlu?$AA@ ; `string'
  0019f	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szText$[ebp]
  001a5	51		 push	 ecx
  001a6	e8 00 00 00 00	 call	 _sprintf
  001ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2306 : 
; 2307 :         if(!WritePrivateProfileString(szSectionName, WBPROJECT_BANK_ENTRYCOUNT_KEY, szText, pszProjectFile))

  001ae	8b 55 08	 mov	 edx, DWORD PTR _pszProjectFile$[ebp]
  001b1	52		 push	 edx
  001b2	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  001b8	50		 push	 eax
  001b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@OCBI@ENTRYCOUNT?$AA@ ; `string'
  001be	8d 8d e0 fd ff
	ff		 lea	 ecx, DWORD PTR _szSectionName$[ebp]
  001c4	51		 push	 ecx
  001c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16
  001cb	85 c0		 test	 eax, eax
  001cd	75 37		 jne	 SHORT $L49661

; 2308 :         {
; 2309 :             DPF_ERROR("An error occurred while attempting to write to the project file");

  001cf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  001d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@LOJ@CWaveBank?3?3WriteProjectData?$AA@ ; `string'
  001d9	68 05 09 00 00	 push	 2309			; 00000905H
  001de	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  001e3	6a 01		 push	 1
  001e5	6a 09		 push	 9
  001e7	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  001ec	83 c4 18	 add	 esp, 24			; 00000018H
  001ef	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@BMIG@An?5error?5occurred?5while?5attempti@ ; `string'
  001f4	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001f9	83 c4 04	 add	 esp, 4

; 2310 :             hr = E_FAIL;

  001fc	c7 85 f0 fe ff
	ff 05 40 00 80	 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49661:
$L49659:

; 2311 :         }        
; 2312 :     }
; 2313 : 
; 2314 :     if(SUCCEEDED(hr))

  00206	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  0020d	0f 8c c2 00 00
	00		 jl	 $L49664

; 2315 :     {
; 2316 :         for(pleEntry = m_lstEntries.Flink, i = 0; (pleEntry != &m_lstEntries) && SUCCEEDED(hr); pleEntry = pleEntry->Flink, i++)

  00213	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00219	8b 82 38 02 00
	00		 mov	 eax, DWORD PTR [edx+568]
  0021f	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _pleEntry$[ebp], eax
  00225	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0022f	eb 1d		 jmp	 SHORT $L49666
$L49667:
  00231	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  00237	8b 11		 mov	 edx, DWORD PTR [ecx]
  00239	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _pleEntry$[ebp], edx
  0023f	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00245	83 c0 01	 add	 eax, 1
  00248	89 85 ec fe ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L49666:
  0024e	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00254	81 c1 38 02 00
	00		 add	 ecx, 568		; 00000238H
  0025a	39 8d e8 fe ff
	ff		 cmp	 DWORD PTR _pleEntry$[ebp], ecx
  00260	74 73		 je	 SHORT $L49668
  00262	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  00269	7c 6a		 jl	 SHORT $L49668

; 2317 :         {
; 2318 :             ASSERT(i < m_dwEntryCount);

  0026b	68 0e 09 00 00	 push	 2318			; 0000090eH
  00270	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00275	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@FBPA@i?5?$DM?5m_dwEntryCount?$AA@ ; `string'
  0027a	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00280	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00286	3b 82 40 02 00
	00		 cmp	 eax, DWORD PTR [edx+576]
  0028c	1b c9		 sbb	 ecx, ecx
  0028e	41		 inc	 ecx
  0028f	51		 push	 ecx
  00290	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00295	83 c4 10	 add	 esp, 16			; 00000010H

; 2319 :         
; 2320 :             pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

  00298	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _pleEntry$[ebp]
  0029e	83 ea 08	 sub	 edx, 8
  002a1	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _pEntry$[ebp], edx

; 2321 : 
; 2322 :             hr = pEntry->WriteProjectData(pszProjectFile, szSectionName, i);

  002a7	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  002ad	50		 push	 eax
  002ae	8d 8d e0 fd ff
	ff		 lea	 ecx, DWORD PTR _szSectionName$[ebp]
  002b4	51		 push	 ecx
  002b5	8b 55 08	 mov	 edx, DWORD PTR _pszProjectFile$[ebp]
  002b8	52		 push	 edx
  002b9	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _pEntry$[ebp]
  002bf	8b 10		 mov	 edx, DWORD PTR [eax]
  002c1	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _pEntry$[ebp]
  002c7	ff 52 20	 call	 DWORD PTR [edx+32]
  002ca	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 2323 :         }

  002d0	e9 5c ff ff ff	 jmp	 $L49667
$L49668:
$L49664:

; 2324 :     }
; 2325 : 
; 2326 :     if(SUCCEEDED(hr))

  002d5	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  002dc	7c 2f		 jl	 SHORT $L49675

; 2327 :     {
; 2328 :         ASSERT(i == m_dwEntryCount);

  002de	68 18 09 00 00	 push	 2328			; 00000918H
  002e3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  002e8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@DJKC@i?5?$DN?$DN?5m_dwEntryCount?$AA@ ; `string'
  002ed	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002f3	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  002f9	33 d2		 xor	 edx, edx
  002fb	3b 88 40 02 00
	00		 cmp	 ecx, DWORD PTR [eax+576]
  00301	0f 95 c2	 setne	 dl
  00304	52		 push	 edx
  00305	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0030a	83 c4 10	 add	 esp, 16			; 00000010H
$L49675:

; 2329 :     }
; 2330 : 
; 2331 :     DPF_LEAVE_HRESULT(hr);
; 2332 : 
; 2333 :     return hr;

  0030d	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _hr$[ebp]

; 2334 : }

  00313	8b e5		 mov	 esp, ebp
  00315	5d		 pop	 ebp
  00316	c2 08 00	 ret	 8
?WriteProjectData@CWaveBank@@UAEJPBDK@Z ENDP		; CWaveBank::WriteProjectData
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetBankDataSize@CWaveBank@@UAEKXZ
_TEXT	SEGMENT
_this$ = -40
_dwSize$ = -32
_hr$ = -28
_MetaData$ = -20
_pleEntry$ = -36
_pEntry$ = -24
?GetBankDataSize@CWaveBank@@UAEKXZ PROC NEAR		; CWaveBank::GetBankDataSize, COMDAT
; _this$ = ecx

; 2360 : {                                   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 2361 :     DWORD                   dwSize      = 0;

  00009	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _dwSize$[ebp], 0

; 2362 :     HRESULT                 hr          = S_OK;

  00010	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 2363 :     WAVEBANKENTRY           MetaData;
; 2364 :     PLIST_ENTRY             pleEntry;
; 2365 :     CWaveBankEntry *        pEntry;
; 2366 :     
; 2367 :     DPF_ENTER();
; 2368 : 
; 2369 :     //
; 2370 :     // Get entry meta-data and calculate the size based on the final file 
; 2371 :     // offset returned.
; 2372 :     //
; 2373 : 
; 2374 :     for(pleEntry = m_lstEntries.Flink; SUCCEEDED(hr) && (pleEntry != &m_lstEntries); pleEntry = pleEntry->Flink)

  00017	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 88 38 02 00
	00		 mov	 ecx, DWORD PTR [eax+568]
  00020	89 4d dc	 mov	 DWORD PTR _pleEntry$[ebp], ecx
  00023	eb 08		 jmp	 SHORT $L49688
$L49689:
  00025	8b 55 dc	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  00028	8b 02		 mov	 eax, DWORD PTR [edx]
  0002a	89 45 dc	 mov	 DWORD PTR _pleEntry$[ebp], eax
$L49688:
  0002d	83 7d e4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00031	7c 2f		 jl	 SHORT $L49690
  00033	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	81 c1 38 02 00
	00		 add	 ecx, 568		; 00000238H
  0003c	39 4d dc	 cmp	 DWORD PTR _pleEntry$[ebp], ecx
  0003f	74 21		 je	 SHORT $L49690

; 2375 :     {
; 2376 :         pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

  00041	8b 55 dc	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  00044	83 ea 08	 sub	 edx, 8
  00047	89 55 e8	 mov	 DWORD PTR _pEntry$[ebp], edx

; 2377 : 
; 2378 :         hr = pEntry->GetMetaData(&MetaData, &dwSize);

  0004a	8d 45 e0	 lea	 eax, DWORD PTR _dwSize$[ebp]
  0004d	50		 push	 eax
  0004e	8d 4d ec	 lea	 ecx, DWORD PTR _MetaData$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 e8	 mov	 edx, DWORD PTR _pEntry$[ebp]
  00055	8b 02		 mov	 eax, DWORD PTR [edx]
  00057	8b 4d e8	 mov	 ecx, DWORD PTR _pEntry$[ebp]
  0005a	ff 50 14	 call	 DWORD PTR [eax+20]
  0005d	89 45 e4	 mov	 DWORD PTR _hr$[ebp], eax

; 2379 :     }

  00060	eb c3		 jmp	 SHORT $L49689
$L49690:

; 2380 : 
; 2381 :     if(FAILED(hr))

  00062	83 7d e4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00066	7d 07		 jge	 SHORT $L49696

; 2382 :     {
; 2383 :         dwSize = 0;

  00068	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _dwSize$[ebp], 0
$L49696:

; 2384 :     }
; 2385 : 
; 2386 :     DPF_LEAVE(dwSize);
; 2387 : 
; 2388 :     return dwSize;

  0006f	8b 45 e0	 mov	 eax, DWORD PTR _dwSize$[ebp]

; 2389 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?GetBankDataSize@CWaveBank@@UAEKXZ ENDP			; CWaveBank::GetBankDataSize
_TEXT	ENDS
PUBLIC	??0CWaveBankProject@@QAE@XZ			; CWaveBankProject::CWaveBankProject
PUBLIC	?AddBank@CWaveBankProject@@UAEJPBD00PAPAVCWaveBank@@@Z ; CWaveBankProject::AddBank
PUBLIC	?RemoveBank@CWaveBankProject@@UAEXPAVCWaveBank@@@Z ; CWaveBankProject::RemoveBank
PUBLIC	?Generate@CWaveBankProject@@UAEJPAVCWaveBankCallback@@H@Z ; CWaveBankProject::Generate
PUBLIC	?ReadProjectData@CWaveBankProject@@UAEJPBD@Z	; CWaveBankProject::ReadProjectData
PUBLIC	?WriteProjectData@CWaveBankProject@@UAEJPBD@Z	; CWaveBankProject::WriteProjectData
PUBLIC	?CreateBank@CWaveBankProject@@MAEPAVCWaveBank@@XZ ; CWaveBankProject::CreateBank
PUBLIC	??_7CWaveBankProject@@6B@			; CWaveBankProject::`vftable'
PUBLIC	??_GCWaveBankProject@@UAEPAXI@Z			; CWaveBankProject::`scalar deleting destructor'
PUBLIC	??_ECWaveBankProject@@UAEPAXI@Z			; CWaveBankProject::`vector deleting destructor'
;	COMDAT ??_7CWaveBankProject@@6B@
CONST	SEGMENT
??_7CWaveBankProject@@6B@ DD FLAT:??_ECWaveBankProject@@UAEPAXI@Z ; CWaveBankProject::`vftable'
	DD	FLAT:?AddBank@CWaveBankProject@@UAEJPBD00PAPAVCWaveBank@@@Z
	DD	FLAT:?RemoveBank@CWaveBankProject@@UAEXPAVCWaveBank@@@Z
	DD	FLAT:?Generate@CWaveBankProject@@UAEJPAVCWaveBankCallback@@H@Z
	DD	FLAT:?ReadProjectData@CWaveBankProject@@UAEJPBD@Z
	DD	FLAT:?WriteProjectData@CWaveBankProject@@UAEJPBD@Z
	DD	FLAT:?CreateBank@CWaveBankProject@@MAEPAVCWaveBank@@XZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CWaveBankProject@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CWaveBankProject@@QAE@XZ PROC NEAR			; CWaveBankProject::CWaveBankProject, COMDAT
; _this$ = ecx

; 2414 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CWaveBankProject@@6B@ ; CWaveBankProject::`vftable'

; 2415 :     DPF_ENTER();
; 2416 : 
; 2417 :     m_dwBankCount = 0;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 2418 : 
; 2419 :     InitializeListHead(&m_lstBanks);

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	83 c2 04	 add	 edx, 4
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 2420 : 
; 2421 :     DPF_LEAVE_VOID();
; 2422 : }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??0CWaveBankProject@@QAE@XZ ENDP			; CWaveBankProject::CWaveBankProject
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\writer.h
_TEXT	ENDS
;	COMDAT ?RemoveBank@CWaveBankProject@@UAEXPAVCWaveBank@@@Z
_TEXT	SEGMENT
$T51631 = -4
$T51632 = -8
_pBank$ = 8
_this$ = -12
?RemoveBank@CWaveBankProject@@UAEXPAVCWaveBank@@@Z PROC NEAR ; CWaveBankProject::RemoveBank, COMDAT
; _this$ = ecx

; 209  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 210  :     DELETE(pBank);

  00009	83 7d 08 00	 cmp	 DWORD PTR _pBank$[ebp], 0
  0000d	74 31		 je	 SHORT $L48742
  0000f	8b 45 08	 mov	 eax, DWORD PTR _pBank$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR $T51632[ebp], eax
  00015	8b 4d f8	 mov	 ecx, DWORD PTR $T51632[ebp]
  00018	89 4d fc	 mov	 DWORD PTR $T51631[ebp], ecx
  0001b	83 7d fc 00	 cmp	 DWORD PTR $T51631[ebp], 0
  0001f	74 11		 je	 SHORT $L51633
  00021	6a 01		 push	 1
  00023	8b 55 fc	 mov	 edx, DWORD PTR $T51631[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	8b 4d fc	 mov	 ecx, DWORD PTR $T51631[ebp]
  0002b	ff 10		 call	 DWORD PTR [eax]
  0002d	89 45 f0	 mov	 DWORD PTR -16+[ebp], eax
  00030	eb 07		 jmp	 SHORT $L51634
$L51633:
  00032	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], 0
$L51634:
  00039	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _pBank$[ebp], 0
$L48742:

; 211  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?RemoveBank@CWaveBankProject@@UAEXPAVCWaveBank@@@Z ENDP	; CWaveBankProject::RemoveBank
_TEXT	ENDS
PUBLIC	??_C@_0BA@MDJN@CWaveBank?$CIthis?$CJ?$AA@	; `string'
;	COMDAT ??_C@_0BA@MDJN@CWaveBank?$CIthis?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@MDJN@CWaveBank?$CIthis?$CJ?$AA@ DB 'CWaveBank(this)', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CreateBank@CWaveBankProject@@MAEPAVCWaveBank@@XZ
_TEXT	SEGMENT
$T51638 = -4
_this$ = -8
?CreateBank@CWaveBankProject@@MAEPAVCWaveBank@@XZ PROC NEAR ; CWaveBankProject::CreateBank, COMDAT
; _this$ = ecx

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 215  :     return NEW(CWaveBank(this));

  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@MDJN@CWaveBank?$CIthis?$CJ?$AA@ ; `string'
  0000e	68 d7 00 00 00	 push	 215			; 000000d7H
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EG@ELIP@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00018	68 48 02 00 00	 push	 584			; 00000248H
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXIPBDK0@Z	; operator new
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR $T51638[ebp], eax
  00028	83 7d fc 00	 cmp	 DWORD PTR $T51638[ebp], 0
  0002c	74 11		 je	 SHORT $L51639
  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00031	50		 push	 eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR $T51638[ebp]
  00035	e8 00 00 00 00	 call	 ??0CWaveBank@@QAE@PAVCWaveBankProject@@@Z ; CWaveBank::CWaveBank
  0003a	89 45 f4	 mov	 DWORD PTR -12+[ebp], eax
  0003d	eb 07		 jmp	 SHORT $L51640
$L51639:
  0003f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L51640:
  00046	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]

; 216  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?CreateBank@CWaveBankProject@@MAEPAVCWaveBank@@XZ ENDP	; CWaveBankProject::CreateBank
_TEXT	ENDS
PUBLIC	??1CWaveBankProject@@UAE@XZ			; CWaveBankProject::~CWaveBankProject
; Function compile flags: /Odt
;	COMDAT ??_GCWaveBankProject@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCWaveBankProject@@UAEPAXI@Z PROC NEAR		; CWaveBankProject::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CWaveBankProject@@UAE@XZ ; CWaveBankProject::~CWaveBankProject
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L49704
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L49704:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCWaveBankProject@@UAEPAXI@Z ENDP			; CWaveBankProject::`scalar deleting destructor'
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\wavbndlr\common\writer.cpp
_TEXT	ENDS
;	COMDAT ??1CWaveBankProject@@UAE@XZ
_TEXT	SEGMENT
$T51647 = -12
$T51648 = -16
_this$ = -20
_pleBank$ = -8
_pBank$ = -4
??1CWaveBankProject@@UAE@XZ PROC NEAR			; CWaveBankProject::~CWaveBankProject, COMDAT
; _this$ = ecx

; 2447 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CWaveBankProject@@6B@ ; CWaveBankProject::`vftable'
$L49712:

; 2448 :     PLIST_ENTRY             pleBank;
; 2449 :     CWaveBank *             pBank;
; 2450 :     
; 2451 :     DPF_ENTER();
; 2452 : 
; 2453 :     //
; 2454 :     // Free all the entries
; 2455 :     //
; 2456 :     
; 2457 :     while((pleBank = m_lstBanks.Flink) != &m_lstBanks)

  00012	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	89 55 f8	 mov	 DWORD PTR _pleBank$[ebp], edx
  0001b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	39 45 f8	 cmp	 DWORD PTR _pleBank$[ebp], eax
  00024	74 42		 je	 SHORT $L49713

; 2458 :     {
; 2459 :         pBank = CONTAINING_RECORD(pleBank, CWaveBank, m_leBank);

  00026	8b 4d f8	 mov	 ecx, DWORD PTR _pleBank$[ebp]
  00029	83 e9 08	 sub	 ecx, 8
  0002c	89 4d fc	 mov	 DWORD PTR _pBank$[ebp], ecx

; 2460 :         
; 2461 :         DELETE(pBank);

  0002f	83 7d fc 00	 cmp	 DWORD PTR _pBank$[ebp], 0
  00033	74 31		 je	 SHORT $L49718
  00035	8b 55 fc	 mov	 edx, DWORD PTR _pBank$[ebp]
  00038	89 55 f0	 mov	 DWORD PTR $T51648[ebp], edx
  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T51648[ebp]
  0003e	89 45 f4	 mov	 DWORD PTR $T51647[ebp], eax
  00041	83 7d f4 00	 cmp	 DWORD PTR $T51647[ebp], 0
  00045	74 11		 je	 SHORT $L51649
  00047	6a 01		 push	 1
  00049	8b 4d f4	 mov	 ecx, DWORD PTR $T51647[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR $T51647[ebp]
  00051	ff 12		 call	 DWORD PTR [edx]
  00053	89 45 e8	 mov	 DWORD PTR -24+[ebp], eax
  00056	eb 07		 jmp	 SHORT $L51650
$L51649:
  00058	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR -24+[ebp], 0
$L51650:
  0005f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pBank$[ebp], 0
$L49718:

; 2462 :     }

  00066	eb aa		 jmp	 SHORT $L49712
$L49713:

; 2463 : 
; 2464 :     DPF_LEAVE_VOID();
; 2465 : }

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??1CWaveBankProject@@UAE@XZ ENDP			; CWaveBankProject::~CWaveBankProject
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddBank@CWaveBankProject@@UAEJPBD00PAPAVCWaveBank@@@Z
_TEXT	SEGMENT
$T51654 = -12
$T51655 = -16
_pszBankName$ = 8
_pszBankFile$ = 12
_pszHeaderFile$ = 16
_ppBank$ = 20
_this$ = -20
_pBank$ = -4
_hr$ = -8
?AddBank@CWaveBankProject@@UAEJPBD00PAPAVCWaveBank@@@Z PROC NEAR ; CWaveBankProject::AddBank, COMDAT
; _this$ = ecx

; 2497 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2498 :     CWaveBank *             pBank;
; 2499 :     HRESULT                 hr;
; 2500 :     
; 2501 :     DPF_ENTER();
; 2502 : 
; 2503 :     hr = HRFROMP(pBank = CreateBank());

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 10		 mov	 edx, DWORD PTR [eax]
  0000e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	ff 52 18	 call	 DWORD PTR [edx+24]
  00014	89 45 fc	 mov	 DWORD PTR _pBank$[ebp], eax
  00017	8b 45 fc	 mov	 eax, DWORD PTR _pBank$[ebp]
  0001a	f7 d8		 neg	 eax
  0001c	1b c0		 sbb	 eax, eax
  0001e	25 f2 ff f8 7f	 and	 eax, 2147024882		; 7ff8fff2H
  00023	05 0e 00 07 80	 add	 eax, -2147024882	; 8007000eH
  00028	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 2504 : 
; 2505 :     if(SUCCEEDED(hr))

  0002b	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0002f	7c 1a		 jl	 SHORT $L49733

; 2506 :     {
; 2507 :         hr = pBank->Initialize(pszBankName, pszBankFile, pszHeaderFile);

  00031	8b 4d 10	 mov	 ecx, DWORD PTR _pszHeaderFile$[ebp]
  00034	51		 push	 ecx
  00035	8b 55 0c	 mov	 edx, DWORD PTR _pszBankFile$[ebp]
  00038	52		 push	 edx
  00039	8b 45 08	 mov	 eax, DWORD PTR _pszBankName$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _pBank$[ebp]
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _pBank$[ebp]
  00045	ff 52 04	 call	 DWORD PTR [edx+4]
  00048	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L49733:

; 2508 :     }
; 2509 : 
; 2510 :     if(SUCCEEDED(hr))

  0004b	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004f	7c 10		 jl	 SHORT $L49735

; 2511 :     {
; 2512 :         if(ppBank)

  00051	83 7d 14 00	 cmp	 DWORD PTR _ppBank$[ebp], 0
  00055	74 08		 je	 SHORT $L49736

; 2513 :         {
; 2514 :             *ppBank = pBank;

  00057	8b 45 14	 mov	 eax, DWORD PTR _ppBank$[ebp]
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _pBank$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$L49736:

; 2515 :         }
; 2516 :     }
; 2517 :     else

  0005f	eb 37		 jmp	 SHORT $L49737
$L49735:

; 2518 :     {
; 2519 :         DELETE(pBank);

  00061	83 7d fc 00	 cmp	 DWORD PTR _pBank$[ebp], 0
  00065	74 31		 je	 SHORT $L49738
  00067	8b 55 fc	 mov	 edx, DWORD PTR _pBank$[ebp]
  0006a	89 55 f0	 mov	 DWORD PTR $T51655[ebp], edx
  0006d	8b 45 f0	 mov	 eax, DWORD PTR $T51655[ebp]
  00070	89 45 f4	 mov	 DWORD PTR $T51654[ebp], eax
  00073	83 7d f4 00	 cmp	 DWORD PTR $T51654[ebp], 0
  00077	74 11		 je	 SHORT $L51656
  00079	6a 01		 push	 1
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR $T51654[ebp]
  0007e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR $T51654[ebp]
  00083	ff 12		 call	 DWORD PTR [edx]
  00085	89 45 e8	 mov	 DWORD PTR -24+[ebp], eax
  00088	eb 07		 jmp	 SHORT $L51657
$L51656:
  0008a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR -24+[ebp], 0
$L51657:
  00091	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pBank$[ebp], 0
$L49738:
$L49737:

; 2520 :     }
; 2521 : 
; 2522 :     DPF_LEAVE_HRESULT(hr);
; 2523 : 
; 2524 :     return hr;

  00098	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 2525 : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 10 00	 ret	 16			; 00000010H
?AddBank@CWaveBankProject@@UAEJPBD00PAPAVCWaveBank@@@Z ENDP ; CWaveBankProject::AddBank
_TEXT	ENDS
PUBLIC	??_C@_0BL@LLIE@CWaveBankProject?3?3Generate?$AA@ ; `string'
PUBLIC	??_C@_0BI@FGNA@No?5banks?5in?5the?5project?$AA@	; `string'
PUBLIC	??_C@_0BK@KDBM@No?5entries?5in?5the?5project?$AA@ ; `string'
;	COMDAT ??_C@_0BL@LLIE@CWaveBankProject?3?3Generate?$AA@
CONST	SEGMENT
??_C@_0BL@LLIE@CWaveBankProject?3?3Generate?$AA@ DB 'CWaveBankProject::Ge'
	DB	'nerate', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FGNA@No?5banks?5in?5the?5project?$AA@
CONST	SEGMENT
??_C@_0BI@FGNA@No?5banks?5in?5the?5project?$AA@ DB 'No banks in the proje'
	DB	'ct', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KDBM@No?5entries?5in?5the?5project?$AA@
CONST	SEGMENT
??_C@_0BK@KDBM@No?5entries?5in?5the?5project?$AA@ DB 'No entries in the p'
	DB	'roject', 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Generate@CWaveBankProject@@UAEJPAVCWaveBankCallback@@H@Z
_TEXT	SEGMENT
_pCallback$ = 8
_fAllowOverwrite$ = 12
_this$ = -28
_hr$ = -16
_pleBank$ = -24
_pleEntry$ = -20
_pBank$ = -4
_nBankCount$ = -8
_nEntryCount$ = -12
?Generate@CWaveBankProject@@UAEJPAVCWaveBankCallback@@H@Z PROC NEAR ; CWaveBankProject::Generate, COMDAT
; _this$ = ecx

; 2553 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 2554 :     HRESULT                 hr          = S_OK;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 2555 :     PLIST_ENTRY             pleBank;
; 2556 :     PLIST_ENTRY             pleEntry;
; 2557 :     CWaveBank *             pBank;
; 2558 :     UINT                    nBankCount;
; 2559 :     UINT                    nEntryCount;
; 2560 : 
; 2561 :     DPF_ENTER();
; 2562 : 
; 2563 :     nBankCount = 0;

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nBankCount$[ebp], 0

; 2564 :     nEntryCount = 0;

  00017	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nEntryCount$[ebp], 0

; 2565 :     
; 2566 :     for(pleBank = m_lstBanks.Flink; (pleBank != &m_lstBanks) && SUCCEEDED(hr); pleBank = pleBank->Flink)

  0001e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00024	89 4d e8	 mov	 DWORD PTR _pleBank$[ebp], ecx
  00027	eb 08		 jmp	 SHORT $L49754
$L49755:
  00029	8b 55 e8	 mov	 edx, DWORD PTR _pleBank$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	89 45 e8	 mov	 DWORD PTR _pleBank$[ebp], eax
$L49754:
  00031	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 04	 add	 ecx, 4
  00037	39 4d e8	 cmp	 DWORD PTR _pleBank$[ebp], ecx
  0003a	74 4f		 je	 SHORT $L49756
  0003c	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00040	7c 49		 jl	 SHORT $L49756

; 2567 :     {
; 2568 :         pBank = CONTAINING_RECORD(pleBank, CWaveBank, m_leBank);

  00042	8b 55 e8	 mov	 edx, DWORD PTR _pleBank$[ebp]
  00045	83 ea 08	 sub	 edx, 8
  00048	89 55 fc	 mov	 DWORD PTR _pBank$[ebp], edx

; 2569 : 
; 2570 :         for(pleEntry = pBank->m_lstEntries.Flink; (pleEntry != &pBank->m_lstEntries) && SUCCEEDED(hr); pleEntry = pleEntry->Flink)

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _pBank$[ebp]
  0004e	8b 88 38 02 00
	00		 mov	 ecx, DWORD PTR [eax+568]
  00054	89 4d ec	 mov	 DWORD PTR _pleEntry$[ebp], ecx
  00057	eb 08		 jmp	 SHORT $L49762
$L49763:
  00059	8b 55 ec	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  0005c	8b 02		 mov	 eax, DWORD PTR [edx]
  0005e	89 45 ec	 mov	 DWORD PTR _pleEntry$[ebp], eax
$L49762:
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _pBank$[ebp]
  00064	81 c1 38 02 00
	00		 add	 ecx, 568		; 00000238H
  0006a	39 4d ec	 cmp	 DWORD PTR _pleEntry$[ebp], ecx
  0006d	74 11		 je	 SHORT $L49764
  0006f	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00073	7c 0b		 jl	 SHORT $L49764

; 2571 :         {
; 2572 :             nEntryCount++;

  00075	8b 55 f4	 mov	 edx, DWORD PTR _nEntryCount$[ebp]
  00078	83 c2 01	 add	 edx, 1
  0007b	89 55 f4	 mov	 DWORD PTR _nEntryCount$[ebp], edx

; 2573 :         }

  0007e	eb d9		 jmp	 SHORT $L49763
$L49764:

; 2574 : 
; 2575 :         nBankCount++;

  00080	8b 45 f8	 mov	 eax, DWORD PTR _nBankCount$[ebp]
  00083	83 c0 01	 add	 eax, 1
  00086	89 45 f8	 mov	 DWORD PTR _nBankCount$[ebp], eax

; 2576 :     }

  00089	eb 9e		 jmp	 SHORT $L49755
$L49756:

; 2577 : 
; 2578 :     if(pCallback)

  0008b	83 7d 08 00	 cmp	 DWORD PTR _pCallback$[ebp], 0
  0008f	74 1d		 je	 SHORT $L49765

; 2579 :     {
; 2580 :         if(!pCallback->BeginProject(nBankCount, nEntryCount))

  00091	8b 4d f4	 mov	 ecx, DWORD PTR _nEntryCount$[ebp]
  00094	51		 push	 ecx
  00095	8b 55 f8	 mov	 edx, DWORD PTR _nBankCount$[ebp]
  00098	52		 push	 edx
  00099	8b 45 08	 mov	 eax, DWORD PTR _pCallback$[ebp]
  0009c	8b 10		 mov	 edx, DWORD PTR [eax]
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _pCallback$[ebp]
  000a1	ff 12		 call	 DWORD PTR [edx]
  000a3	85 c0		 test	 eax, eax
  000a5	75 07		 jne	 SHORT $L49766

; 2581 :         {
; 2582 :             hr = E_ABORT;

  000a7	c7 45 f0 04 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467260 ; 80004004H
$L49766:
$L49765:

; 2583 :         }
; 2584 :     }
; 2585 : 
; 2586 :     if(!nBankCount)

  000ae	83 7d f8 00	 cmp	 DWORD PTR _nBankCount$[ebp], 0
  000b2	75 36		 jne	 SHORT $L49768

; 2587 :     {
; 2588 :         DPF_ERROR("No banks in the project");

  000b4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@LLIE@CWaveBankProject?3?3Generate?$AA@ ; `string'
  000be	68 1c 0a 00 00	 push	 2588			; 00000a1cH
  000c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000c8	6a 01		 push	 1
  000ca	6a 09		 push	 9
  000cc	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000d1	83 c4 18	 add	 esp, 24			; 00000018H
  000d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@FGNA@No?5banks?5in?5the?5project?$AA@ ; `string'
  000d9	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000de	83 c4 04	 add	 esp, 4

; 2589 :         hr = E_FAIL;

  000e1	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 2590 :     }
; 2591 :     else if(!nEntryCount)

  000e8	eb 3a		 jmp	 SHORT $L49772
$L49768:
  000ea	83 7d f4 00	 cmp	 DWORD PTR _nEntryCount$[ebp], 0
  000ee	75 34		 jne	 SHORT $L49773

; 2592 :     {
; 2593 :         DPF_ERROR("No entries in the project");

  000f0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000f5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@LLIE@CWaveBankProject?3?3Generate?$AA@ ; `string'
  000fa	68 21 0a 00 00	 push	 2593			; 00000a21H
  000ff	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00104	6a 01		 push	 1
  00106	6a 09		 push	 9
  00108	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0010d	83 c4 18	 add	 esp, 24			; 00000018H
  00110	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@KDBM@No?5entries?5in?5the?5project?$AA@ ; `string'
  00115	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0011a	83 c4 04	 add	 esp, 4

; 2594 :         hr = E_FAIL;

  0011d	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49773:
$L49772:

; 2595 :     }
; 2596 : 
; 2597 :     for(pleBank = m_lstBanks.Flink; (pleBank != &m_lstBanks) && SUCCEEDED(hr); pleBank = pleBank->Flink)

  00124	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00127	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012a	89 4d e8	 mov	 DWORD PTR _pleBank$[ebp], ecx
  0012d	eb 08		 jmp	 SHORT $L49777
$L49778:
  0012f	8b 55 e8	 mov	 edx, DWORD PTR _pleBank$[ebp]
  00132	8b 02		 mov	 eax, DWORD PTR [edx]
  00134	89 45 e8	 mov	 DWORD PTR _pleBank$[ebp], eax
$L49777:
  00137	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0013a	83 c1 04	 add	 ecx, 4
  0013d	39 4d e8	 cmp	 DWORD PTR _pleBank$[ebp], ecx
  00140	74 43		 je	 SHORT $L49779
  00142	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00146	7c 3d		 jl	 SHORT $L49779

; 2598 :     {
; 2599 :         pBank = CONTAINING_RECORD(pleBank, CWaveBank, m_leBank);

  00148	8b 55 e8	 mov	 edx, DWORD PTR _pleBank$[ebp]
  0014b	83 ea 08	 sub	 edx, 8
  0014e	89 55 fc	 mov	 DWORD PTR _pBank$[ebp], edx

; 2600 : 
; 2601 :         hr = pBank->GenerateBank(pCallback, fAllowOverwrite);

  00151	8b 45 0c	 mov	 eax, DWORD PTR _fAllowOverwrite$[ebp]
  00154	50		 push	 eax
  00155	8b 4d 08	 mov	 ecx, DWORD PTR _pCallback$[ebp]
  00158	51		 push	 ecx
  00159	8b 55 fc	 mov	 edx, DWORD PTR _pBank$[ebp]
  0015c	8b 02		 mov	 eax, DWORD PTR [edx]
  0015e	8b 4d fc	 mov	 ecx, DWORD PTR _pBank$[ebp]
  00161	ff 50 18	 call	 DWORD PTR [eax+24]
  00164	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 2602 : 
; 2603 :         if(SUCCEEDED(hr))

  00167	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0016b	7c 16		 jl	 SHORT $L49785

; 2604 :         {
; 2605 :             hr = pBank->GenerateHeader(pCallback, fAllowOverwrite);

  0016d	8b 4d 0c	 mov	 ecx, DWORD PTR _fAllowOverwrite$[ebp]
  00170	51		 push	 ecx
  00171	8b 55 08	 mov	 edx, DWORD PTR _pCallback$[ebp]
  00174	52		 push	 edx
  00175	8b 45 fc	 mov	 eax, DWORD PTR _pBank$[ebp]
  00178	8b 10		 mov	 edx, DWORD PTR [eax]
  0017a	8b 4d fc	 mov	 ecx, DWORD PTR _pBank$[ebp]
  0017d	ff 52 1c	 call	 DWORD PTR [edx+28]
  00180	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
$L49785:

; 2606 :         }
; 2607 :     }

  00183	eb aa		 jmp	 SHORT $L49778
$L49779:

; 2608 : 
; 2609 :     if(pCallback)

  00185	83 7d 08 00	 cmp	 DWORD PTR _pCallback$[ebp], 0
  00189	74 0f		 je	 SHORT $L49786

; 2610 :     {
; 2611 :         pCallback->EndProject(hr);

  0018b	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  0018e	50		 push	 eax
  0018f	8b 4d 08	 mov	 ecx, DWORD PTR _pCallback$[ebp]
  00192	8b 11		 mov	 edx, DWORD PTR [ecx]
  00194	8b 4d 08	 mov	 ecx, DWORD PTR _pCallback$[ebp]
  00197	ff 52 04	 call	 DWORD PTR [edx+4]
$L49786:

; 2612 :     }
; 2613 : 
; 2614 :     DPF_LEAVE_HRESULT(hr);
; 2615 : 
; 2616 :     return hr;

  0019a	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]

; 2617 : }

  0019d	8b e5		 mov	 esp, ebp
  0019f	5d		 pop	 ebp
  001a0	c2 08 00	 ret	 8
?Generate@CWaveBankProject@@UAEJPAVCWaveBankCallback@@H@Z ENDP ; CWaveBankProject::Generate
_TEXT	ENDS
PUBLIC	??_C@_0CC@BCKI@CWaveBankProject?3?3ReadProjectDat@ ; `string'
PUBLIC	??_C@_0CL@BNOK@Unable?5to?5change?5to?5project?5file@ ; `string'
PUBLIC	??_C@_09FLO@BANKCOUNT?$AA@			; `string'
PUBLIC	??_C@_07KBBM@PROJECT?$AA@			; `string'
EXTRN	__imp__SetCurrentDirectoryA@4:NEAR
;	COMDAT ??_C@_0CC@BCKI@CWaveBankProject?3?3ReadProjectDat@
CONST	SEGMENT
??_C@_0CC@BCKI@CWaveBankProject?3?3ReadProjectDat@ DB 'CWaveBankProject::'
	DB	'ReadProjectData', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BNOK@Unable?5to?5change?5to?5project?5file@
CONST	SEGMENT
??_C@_0CL@BNOK@Unable?5to?5change?5to?5project?5file@ DB 'Unable to chang'
	DB	'e to project file directory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FLO@BANKCOUNT?$AA@
CONST	SEGMENT
??_C@_09FLO@BANKCOUNT?$AA@ DB 'BANKCOUNT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KBBM@PROJECT?$AA@
CONST	SEGMENT
??_C@_07KBBM@PROJECT?$AA@ DB 'PROJECT', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ReadProjectData@CWaveBankProject@@UAEJPBD@Z
_TEXT	SEGMENT
_pszProjectFile$ = 8
_this$ = -292
_hr$ = -276
_szProjectFile$ = -264
_pszFilePart$ = -288
_dwBankCount$ = -284
_pBank$ = -272
_c$ = -265
_i$ = -280
?ReadProjectData@CWaveBankProject@@UAEJPBD@Z PROC NEAR	; CWaveBankProject::ReadProjectData, COMDAT
; _this$ = ecx

; 2643 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	89 8d dc fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 2644 :     HRESULT                 hr                          = S_OK;

  0000f	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _hr$[ebp], 0

; 2645 :     CHAR                    szProjectFile[MAX_PATH];
; 2646 :     LPSTR                   pszFilePart;
; 2647 :     DWORD                   dwBankCount;
; 2648 :     CWaveBank *             pBank;
; 2649 :     char                    c;
; 2650 :     DWORD                   i;
; 2651 :     
; 2652 :     DPF_ENTER();
; 2653 : 
; 2654 :     //
; 2655 :     // Convert the project file name to a full path.  The INI APIs prefer it
; 2656 :     //
; 2657 : 
; 2658 :     GetFullPathName(pszProjectFile, NUMELMS(szProjectFile), szProjectFile, &pszFilePart);

  00019	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _pszFilePart$[ebp]
  0001f	50		 push	 eax
  00020	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szProjectFile$[ebp]
  00026	51		 push	 ecx
  00027	68 04 01 00 00	 push	 260			; 00000104H
  0002c	8b 55 08	 mov	 edx, DWORD PTR _pszProjectFile$[ebp]
  0002f	52		 push	 edx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFullPathNameA@16

; 2659 : 
; 2660 :     //
; 2661 :     // Set the current directory to the project file's to make sure any 
; 2662 :     // relative paths are expanded properly
; 2663 :     //
; 2664 : 
; 2665 :     c = *pszFilePart;

  00036	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _pszFilePart$[ebp]
  0003c	8a 08		 mov	 cl, BYTE PTR [eax]
  0003e	88 8d f7 fe ff
	ff		 mov	 BYTE PTR _c$[ebp], cl

; 2666 :     *pszFilePart = 0;

  00044	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _pszFilePart$[ebp]
  0004a	c6 02 00	 mov	 BYTE PTR [edx], 0

; 2667 :     
; 2668 :     if(!SetCurrentDirectory(szProjectFile))

  0004d	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szProjectFile$[ebp]
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCurrentDirectoryA@4
  0005a	85 c0		 test	 eax, eax
  0005c	75 37		 jne	 SHORT $L49799

; 2669 :     {
; 2670 :         DPF_ERROR("Unable to change to project file directory");

  0005e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00063	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@BCKI@CWaveBankProject?3?3ReadProjectDat@ ; `string'
  00068	68 6e 0a 00 00	 push	 2670			; 00000a6eH
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00072	6a 01		 push	 1
  00074	6a 09		 push	 9
  00076	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0007b	83 c4 18	 add	 esp, 24			; 00000018H
  0007e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CL@BNOK@Unable?5to?5change?5to?5project?5file@ ; `string'
  00083	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00088	83 c4 04	 add	 esp, 4

; 2671 :         hr = E_FAIL;

  0008b	c7 85 ec fe ff
	ff 05 40 00 80	 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49799:

; 2672 :     }
; 2673 : 
; 2674 :     *pszFilePart = c;

  00095	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _pszFilePart$[ebp]
  0009b	8a 95 f7 fe ff
	ff		 mov	 dl, BYTE PTR _c$[ebp]
  000a1	88 11		 mov	 BYTE PTR [ecx], dl

; 2675 : 
; 2676 :     //
; 2677 :     // Start loading banks
; 2678 :     //
; 2679 : 
; 2680 :     if(SUCCEEDED(hr))

  000a3	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  000aa	0f 8c b5 00 00
	00		 jl	 $L49804

; 2681 :     {
; 2682 :         dwBankCount = GetPrivateProfileInt(WBPROJECT_PROJECT_MAIN_SECTION, WBPROJECT_PROJECT_BANKCOUNT_KEY, 0, szProjectFile);

  000b0	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szProjectFile$[ebp]
  000b6	50		 push	 eax
  000b7	6a 00		 push	 0
  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09FLO@BANKCOUNT?$AA@ ; `string'
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07KBBM@PROJECT?$AA@ ; `string'
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000c9	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _dwBankCount$[ebp], eax

; 2683 : 
; 2684 :         for(i = 0; (i < dwBankCount) && SUCCEEDED(hr); i++)

  000cf	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  000d9	eb 0f		 jmp	 SHORT $L49808
$L49809:
  000db	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000e1	83 c1 01	 add	 ecx, 1
  000e4	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
$L49808:
  000ea	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  000f0	3b 95 e4 fe ff
	ff		 cmp	 edx, DWORD PTR _dwBankCount$[ebp]
  000f6	73 6d		 jae	 SHORT $L49810
  000f8	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  000ff	7c 64		 jl	 SHORT $L49810

; 2685 :         {
; 2686 :             hr = HRFROMP(pBank = CreateBank());

  00101	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00107	8b 10		 mov	 edx, DWORD PTR [eax]
  00109	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	ff 52 18	 call	 DWORD PTR [edx+24]
  00112	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _pBank$[ebp], eax
  00118	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _pBank$[ebp]
  0011e	f7 d8		 neg	 eax
  00120	1b c0		 sbb	 eax, eax
  00122	25 f2 ff f8 7f	 and	 eax, 2147024882		; 7ff8fff2H
  00127	05 0e 00 07 80	 add	 eax, -2147024882	; 8007000eH
  0012c	89 85 ec fe ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 2687 : 
; 2688 :             if(SUCCEEDED(hr))

  00132	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  00139	7c 25		 jl	 SHORT $L49814

; 2689 :             {
; 2690 :                 hr = pBank->ReadProjectData(szProjectFile, i);

  0013b	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00141	51		 push	 ecx
  00142	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szProjectFile$[ebp]
  00148	52		 push	 edx
  00149	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _pBank$[ebp]
  0014f	8b 10		 mov	 edx, DWORD PTR [eax]
  00151	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _pBank$[ebp]
  00157	ff 52 20	 call	 DWORD PTR [edx+32]
  0015a	89 85 ec fe ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax
$L49814:

; 2691 :             }
; 2692 :         }

  00160	e9 76 ff ff ff	 jmp	 $L49809
$L49810:
$L49804:

; 2693 :     }
; 2694 : 
; 2695 :     DPF_LEAVE_HRESULT(hr);
; 2696 : 
; 2697 :     return hr;

  00165	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _hr$[ebp]

; 2698 : }

  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c2 04 00	 ret	 4
?ReadProjectData@CWaveBankProject@@UAEJPBD@Z ENDP	; CWaveBankProject::ReadProjectData
_TEXT	ENDS
PUBLIC	??_C@_0CD@OGBN@CWaveBankProject?3?3WriteProjectDa@ ; `string'
PUBLIC	??_C@_0BC@KDFE@i?5?$DM?5m_dwBankCount?$AA@	; `string'
PUBLIC	??_C@_0BD@PBIF@i?5?$DN?$DN?5m_dwBankCount?$AA@	; `string'
EXTRN	__imp__DeleteFileA@4:NEAR
;	COMDAT ??_C@_0CD@OGBN@CWaveBankProject?3?3WriteProjectDa@
CONST	SEGMENT
??_C@_0CD@OGBN@CWaveBankProject?3?3WriteProjectDa@ DB 'CWaveBankProject::'
	DB	'WriteProjectData', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KDFE@i?5?$DM?5m_dwBankCount?$AA@
CONST	SEGMENT
??_C@_0BC@KDFE@i?5?$DM?5m_dwBankCount?$AA@ DB 'i < m_dwBankCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PBIF@i?5?$DN?$DN?5m_dwBankCount?$AA@
CONST	SEGMENT
??_C@_0BD@PBIF@i?5?$DN?$DN?5m_dwBankCount?$AA@ DB 'i == m_dwBankCount', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?WriteProjectData@CWaveBankProject@@UAEJPBD@Z
_TEXT	SEGMENT
_pszProjectFile$ = 8
_this$ = -300
_hr$ = -276
_ProjectFile$ = -292
_szBankCount$ = -272
_pleEntry$ = -284
_pBank$ = -4
_i$ = -280
$T51667 = -296
?WriteProjectData@CWaveBankProject@@UAEJPBD@Z PROC NEAR	; CWaveBankProject::WriteProjectData, COMDAT
; _this$ = ecx

; 2724 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 2725 :     HRESULT                 hr                      = S_OK;

  0000f	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _hr$[ebp], 0

; 2726 :     CStdFileStream          ProjectFile;

  00019	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _ProjectFile$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::CStdFileStream

; 2727 :     CHAR                    szBankCount[MAX_PATH];
; 2728 :     PLIST_ENTRY             pleEntry;
; 2729 :     CWaveBank *             pBank;
; 2730 :     DWORD                   i;
; 2731 :     
; 2732 :     DPF_ENTER();
; 2733 : 
; 2734 :     //
; 2735 :     // Truncate the existing file
; 2736 :     //
; 2737 : 
; 2738 :     DeleteFile(pszProjectFile);

  00024	8b 45 08	 mov	 eax, DWORD PTR _pszProjectFile$[ebp]
  00027	50		 push	 eax
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4

; 2739 : 
; 2740 :     //
; 2741 :     // Write project data
; 2742 :     //
; 2743 : 
; 2744 :     if(SUCCEEDED(hr))

  0002e	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  00035	7c 74		 jl	 SHORT $L49827

; 2745 :     {
; 2746 :         sprintf(szBankCount, "%lu", m_dwBankCount);

  00037	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00040	52		 push	 edx
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03JGAL@?$CFlu?$AA@ ; `string'
  00046	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szBankCount$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _sprintf
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2747 :         
; 2748 :         if(!WritePrivateProfileString(WBPROJECT_PROJECT_MAIN_SECTION, WBPROJECT_PROJECT_BANKCOUNT_KEY, szBankCount, pszProjectFile))

  00055	8b 4d 08	 mov	 ecx, DWORD PTR _pszProjectFile$[ebp]
  00058	51		 push	 ecx
  00059	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _szBankCount$[ebp]
  0005f	52		 push	 edx
  00060	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09FLO@BANKCOUNT?$AA@ ; `string'
  00065	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07KBBM@PROJECT?$AA@ ; `string'
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16
  00070	85 c0		 test	 eax, eax
  00072	75 37		 jne	 SHORT $L49828

; 2749 :         {
; 2750 :             DPF_ERROR("An error occurred while attempting to write to the project file");

  00074	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00079	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@OGBN@CWaveBankProject?3?3WriteProjectDa@ ; `string'
  0007e	68 be 0a 00 00	 push	 2750			; 00000abeH
  00083	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00088	6a 01		 push	 1
  0008a	6a 09		 push	 9
  0008c	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00091	83 c4 18	 add	 esp, 24			; 00000018H
  00094	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@BMIG@An?5error?5occurred?5while?5attempti@ ; `string'
  00099	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0009e	83 c4 04	 add	 esp, 4

; 2751 :             hr = E_FAIL;

  000a1	c7 85 ec fe ff
	ff 05 40 00 80	 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L49828:
$L49827:

; 2752 :         }
; 2753 :     }
; 2754 : 
; 2755 :     //
; 2756 :     // Write all bank data
; 2757 :     //
; 2758 : 
; 2759 :     for(pleEntry = m_lstBanks.Flink, i = 0; (pleEntry != &m_lstBanks) && SUCCEEDED(hr); pleEntry = pleEntry->Flink, i++)

  000ab	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b4	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _pleEntry$[ebp], ecx
  000ba	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  000c4	eb 1d		 jmp	 SHORT $L49832
$L49833:
  000c6	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _pleEntry$[ebp]
  000cc	8b 02		 mov	 eax, DWORD PTR [edx]
  000ce	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _pleEntry$[ebp], eax
  000d4	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000da	83 c1 01	 add	 ecx, 1
  000dd	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
$L49832:
  000e3	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000e9	83 c2 04	 add	 edx, 4
  000ec	39 95 e4 fe ff
	ff		 cmp	 DWORD PTR _pleEntry$[ebp], edx
  000f2	74 60		 je	 SHORT $L49834
  000f4	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  000fb	7c 57		 jl	 SHORT $L49834

; 2760 :     {
; 2761 :         ASSERT(i < m_dwBankCount);

  000fd	68 c9 0a 00 00	 push	 2761			; 00000ac9H
  00102	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00107	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@KDFE@i?5?$DM?5m_dwBankCount?$AA@ ; `string'
  0010c	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00112	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00118	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0011b	1b d2		 sbb	 edx, edx
  0011d	42		 inc	 edx
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00124	83 c4 10	 add	 esp, 16			; 00000010H

; 2762 :         
; 2763 :         pBank = CONTAINING_RECORD(pleEntry, CWaveBank, m_leBank);

  00127	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _pleEntry$[ebp]
  0012d	83 e8 08	 sub	 eax, 8
  00130	89 45 fc	 mov	 DWORD PTR _pBank$[ebp], eax

; 2764 : 
; 2765 :         hr = pBank->WriteProjectData(pszProjectFile, i);

  00133	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00139	51		 push	 ecx
  0013a	8b 55 08	 mov	 edx, DWORD PTR _pszProjectFile$[ebp]
  0013d	52		 push	 edx
  0013e	8b 45 fc	 mov	 eax, DWORD PTR _pBank$[ebp]
  00141	8b 10		 mov	 edx, DWORD PTR [eax]
  00143	8b 4d fc	 mov	 ecx, DWORD PTR _pBank$[ebp]
  00146	ff 52 24	 call	 DWORD PTR [edx+36]
  00149	89 85 ec fe ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 2766 :     }

  0014f	e9 72 ff ff ff	 jmp	 $L49833
$L49834:

; 2767 : 
; 2768 :     if(SUCCEEDED(hr))

  00154	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  0015b	7c 2c		 jl	 SHORT $L49841

; 2769 :     {
; 2770 :         ASSERT(i == m_dwBankCount);

  0015d	68 d2 0a 00 00	 push	 2770			; 00000ad2H
  00162	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NIPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00167	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@PBIF@i?5?$DN?$DN?5m_dwBankCount?$AA@ ; `string'
  0016c	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00172	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00178	33 d2		 xor	 edx, edx
  0017a	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0017d	0f 95 c2	 setne	 dl
  00180	52		 push	 edx
  00181	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00186	83 c4 10	 add	 esp, 16			; 00000010H
$L49841:

; 2771 :     }
; 2772 : 
; 2773 :     DPF_LEAVE_HRESULT(hr);
; 2774 : 
; 2775 :     return hr;

  00189	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _hr$[ebp]
  0018f	89 85 d8 fe ff
	ff		 mov	 DWORD PTR $T51667[ebp], eax
  00195	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _ProjectFile$[ebp]
  0019b	e8 00 00 00 00	 call	 ??1CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::~CStdFileStream
  001a0	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR $T51667[ebp]

; 2776 : }

  001a6	8b e5		 mov	 esp, ebp
  001a8	5d		 pop	 ebp
  001a9	c2 04 00	 ret	 4
?WriteProjectData@CWaveBankProject@@UAEJPBD@Z ENDP	; CWaveBankProject::WriteProjectData
_TEXT	ENDS
PUBLIC	?dstrcpy@@YGPADPADPBD@Z				; dstrcpy
PUBLIC	??_C@_04HPGM@?$CFs?3?5?$AA@			; `string'
PUBLIC	??_C@_0L@GGMM@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@	; `string'
PUBLIC	??_C@_05JFHJ@?$CFhs?3?5?$AA@			; `string'
PUBLIC	??_C@_07GHMC@?$CF?48lx?3?5?$AA@			; `string'
PUBLIC	??_C@_07MKMO@Error?3?5?$AA@			; `string'
PUBLIC	??_C@_0BD@IMNF@Resource?5failure?3?5?$AA@	; `string'
PUBLIC	??_C@_09NLAH@Warning?3?5?$AA@			; `string'
PUBLIC	??_C@_01BJG@?6?$AA@				; `string'
PUBLIC	?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z ; DirectSound::CDebug::PrintStaticV
PUBLIC	?Break@CDebug@DirectSound@@SAXXZ		; DirectSound::CDebug::Break
EXTRN	_vsprintf:NEAR
EXTRN	__imp__GetCurrentThreadId@0:NEAR
EXTRN	__imp__OutputDebugStringA@4:NEAR
;	COMDAT ??_C@_04HPGM@?$CFs?3?5?$AA@
; File c:\xbox\private\windows\directx\dsound\common\debug.cpp
CONST	SEGMENT
??_C@_04HPGM@?$CFs?3?5?$AA@ DB '%s: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GGMM@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@
CONST	SEGMENT
??_C@_0L@GGMM@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@ DB '%hs(%lu): ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JFHJ@?$CFhs?3?5?$AA@
CONST	SEGMENT
??_C@_05JFHJ@?$CFhs?3?5?$AA@ DB '%hs: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GHMC@?$CF?48lx?3?5?$AA@
CONST	SEGMENT
??_C@_07GHMC@?$CF?48lx?3?5?$AA@ DB '%.8lx: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MKMO@Error?3?5?$AA@
CONST	SEGMENT
??_C@_07MKMO@Error?3?5?$AA@ DB 'Error: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IMNF@Resource?5failure?3?5?$AA@
CONST	SEGMENT
??_C@_0BD@IMNF@Resource?5failure?3?5?$AA@ DB 'Resource failure: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NLAH@Warning?3?5?$AA@
CONST	SEGMENT
??_C@_09NLAH@Warning?3?5?$AA@ DB 'Warning: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT
??_C@_01BJG@?6?$AA@ DB 0aH, 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z
_TEXT	SEGMENT
_dwFlags$ = 8
_dwLevel$ = 12
_pszFile$ = 16
_nLine$ = 20
_pszFunction$ = 24
_pszLibrary$ = 28
_pszFormat$ = 32
_va$ = 36
_szDebug$ = -1032
_szText$ = -2064
_pszWorking$ = -4
?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z PROC NEAR ; DirectSound::CDebug::PrintStaticV, COMDAT

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 08 00
	00		 sub	 esp, 2068		; 00000814H

; 114  :     CHAR                    szDebug[0x400];
; 115  :     CHAR                    szText[0x400];
; 116  :     LPSTR                   pszWorking;
; 117  :     DWORD                   dwWritten;
; 118  : 
; 119  :     if(dwLevel <= m_dwDpfLevel)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _dwLevel$[ebp]
  0000c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?m_dwDpfLevel@CDebug@DirectSound@@2KA ; DirectSound::CDebug::m_dwDpfLevel
  00012	0f 87 b1 01 00
	00		 ja	 $L49867

; 120  :     {
; 121  :         pszWorking = szDebug;

  00018	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _szDebug$[ebp]
  0001e	89 4d fc	 mov	 DWORD PTR _pszWorking$[ebp], ecx

; 122  : 
; 123  : #ifdef DEBUG
; 124  : 
; 125  :         //
; 126  :         // Add the library name
; 127  :         //
; 128  : 
; 129  :         if((dwFlags & DPF_FLAGS_LIBRARY) && pszLibrary && *pszLibrary)

  00021	8b 55 08	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00024	83 e2 01	 and	 edx, 1
  00027	85 d2		 test	 edx, edx
  00029	74 2d		 je	 SHORT $L49868
  0002b	83 7d 1c 00	 cmp	 DWORD PTR _pszLibrary$[ebp], 0
  0002f	74 27		 je	 SHORT $L49868
  00031	8b 45 1c	 mov	 eax, DWORD PTR _pszLibrary$[ebp]
  00034	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00037	85 c9		 test	 ecx, ecx
  00039	74 1d		 je	 SHORT $L49868

; 130  :         {
; 131  :             pszWorking += sprintf(pszWorking, "%s: ", pszLibrary);

  0003b	8b 55 1c	 mov	 edx, DWORD PTR _pszLibrary$[ebp]
  0003e	52		 push	 edx
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04HPGM@?$CFs?3?5?$AA@ ; `string'
  00044	8b 45 fc	 mov	 eax, DWORD PTR _pszWorking$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _sprintf
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  00053	03 c8		 add	 ecx, eax
  00055	89 4d fc	 mov	 DWORD PTR _pszWorking$[ebp], ecx
$L49868:

; 132  :         }
; 133  : 
; 134  :         //
; 135  :         // Add the source file and line number
; 136  :         //
; 137  : 
; 138  :         if((dwFlags & DPF_FLAGS_FILELINE) && pszFile && *pszFile)

  00058	8b 55 08	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0005b	83 e2 02	 and	 edx, 2
  0005e	85 d2		 test	 edx, edx
  00060	74 31		 je	 SHORT $L49870
  00062	83 7d 10 00	 cmp	 DWORD PTR _pszFile$[ebp], 0
  00066	74 2b		 je	 SHORT $L49870
  00068	8b 45 10	 mov	 eax, DWORD PTR _pszFile$[ebp]
  0006b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0006e	85 c9		 test	 ecx, ecx
  00070	74 21		 je	 SHORT $L49870

; 139  :         {
; 140  :             pszWorking += sprintf(pszWorking, "%hs(%lu): ", pszFile, nLine);

  00072	8b 55 14	 mov	 edx, DWORD PTR _nLine$[ebp]
  00075	52		 push	 edx
  00076	8b 45 10	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@GGMM@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@ ; `string'
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _sprintf
  00088	83 c4 10	 add	 esp, 16			; 00000010H
  0008b	8b 55 fc	 mov	 edx, DWORD PTR _pszWorking$[ebp]
  0008e	03 d0		 add	 edx, eax
  00090	89 55 fc	 mov	 DWORD PTR _pszWorking$[ebp], edx
$L49870:

; 141  :         }
; 142  : 
; 143  :         //
; 144  :         // Add the function name
; 145  :         //
; 146  : 
; 147  :         if((dwFlags & DPF_FLAGS_FUNCTIONNAME) && pszFunction && *pszFunction)

  00093	8b 45 08	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00096	83 e0 08	 and	 eax, 8
  00099	85 c0		 test	 eax, eax
  0009b	74 2d		 je	 SHORT $L49872
  0009d	83 7d 18 00	 cmp	 DWORD PTR _pszFunction$[ebp], 0
  000a1	74 27		 je	 SHORT $L49872
  000a3	8b 4d 18	 mov	 ecx, DWORD PTR _pszFunction$[ebp]
  000a6	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000a9	85 d2		 test	 edx, edx
  000ab	74 1d		 je	 SHORT $L49872

; 148  :         {
; 149  :             pszWorking += sprintf(pszWorking, "%hs: ", pszFunction);

  000ad	8b 45 18	 mov	 eax, DWORD PTR _pszFunction$[ebp]
  000b0	50		 push	 eax
  000b1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05JFHJ@?$CFhs?3?5?$AA@ ; `string'
  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  000b9	51		 push	 ecx
  000ba	e8 00 00 00 00	 call	 _sprintf
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c2	8b 55 fc	 mov	 edx, DWORD PTR _pszWorking$[ebp]
  000c5	03 d0		 add	 edx, eax
  000c7	89 55 fc	 mov	 DWORD PTR _pszWorking$[ebp], edx
$L49872:

; 150  :         }
; 151  : 
; 152  :         //
; 153  :         // Add process and thread id
; 154  :         //
; 155  : 
; 156  :         if(dwFlags & DPF_FLAGS_PROCESSTHREADID)

  000ca	8b 45 08	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  000cd	83 e0 04	 and	 eax, 4
  000d0	85 c0		 test	 eax, eax
  000d2	74 20		 je	 SHORT $L49874

; 157  :         {
; 158  :             pszWorking += sprintf(pszWorking, "%.8lx: ", GetCurrentThreadId());

  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  000da	50		 push	 eax
  000db	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07GHMC@?$CF?48lx?3?5?$AA@ ; `string'
  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  000e3	51		 push	 ecx
  000e4	e8 00 00 00 00	 call	 _sprintf
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ec	8b 55 fc	 mov	 edx, DWORD PTR _pszWorking$[ebp]
  000ef	03 d0		 add	 edx, eax
  000f1	89 55 fc	 mov	 DWORD PTR _pszWorking$[ebp], edx
$L49874:

; 159  :         }
; 160  : 
; 161  :         //
; 162  :         // Add the type of message it is (i.e. error or warning)
; 163  :         //
; 164  : 
; 165  :         switch(dwLevel)
; 166  :         {

  000f4	8b 45 0c	 mov	 eax, DWORD PTR _dwLevel$[ebp]
  000f7	89 85 ec f7 ff
	ff		 mov	 DWORD PTR -2068+[ebp], eax
  000fd	83 bd ec f7 ff
	ff 01		 cmp	 DWORD PTR -2068+[ebp], 1
  00104	74 14		 je	 SHORT $L49880
  00106	83 bd ec f7 ff
	ff 02		 cmp	 DWORD PTR -2068+[ebp], 2
  0010d	74 1e		 je	 SHORT $L49882
  0010f	83 bd ec f7 ff
	ff 03		 cmp	 DWORD PTR -2068+[ebp], 3
  00116	74 28		 je	 SHORT $L49884
  00118	eb 37		 jmp	 SHORT $L49877
$L49880:

; 167  :             case DPFLVL_ERROR:
; 168  :                 pszWorking = dstrcpy(pszWorking, "Error: ");

  0011a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07MKMO@Error?3?5?$AA@ ; `string'
  0011f	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  00128	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax

; 169  :                 break;

  0012b	eb 24		 jmp	 SHORT $L49877
$L49882:

; 170  : 
; 171  :             case DPFLVL_RESOURCE:
; 172  :                 pszWorking = dstrcpy(pszWorking, "Resource failure: ");

  0012d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@IMNF@Resource?5failure?3?5?$AA@ ; `string'
  00132	8b 55 fc	 mov	 edx, DWORD PTR _pszWorking$[ebp]
  00135	52		 push	 edx
  00136	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0013b	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax

; 173  :                 break;

  0013e	eb 11		 jmp	 SHORT $L49877
$L49884:

; 174  : 
; 175  :             case DPFLVL_WARNING:
; 176  :                 pszWorking = dstrcpy(pszWorking, "Warning: ");

  00140	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09NLAH@Warning?3?5?$AA@ ; `string'
  00145	8b 45 fc	 mov	 eax, DWORD PTR _pszWorking$[ebp]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0014e	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax
$L49877:

; 177  :                 break;
; 178  :         }
; 179  : 
; 180  : #endif // DEBUG
; 181  : 
; 182  :         //
; 183  :         // Add the debug string
; 184  :         //
; 185  : 
; 186  :         vsprintf(szText, pszFormat, va);

  00151	8b 4d 24	 mov	 ecx, DWORD PTR _va$[ebp]
  00154	51		 push	 ecx
  00155	8b 55 20	 mov	 edx, DWORD PTR _pszFormat$[ebp]
  00158	52		 push	 edx
  00159	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 _vsprintf
  00165	83 c4 0c	 add	 esp, 12			; 0000000cH

; 187  : 
; 188  : #ifdef DEBUG
; 189  : 
; 190  :         pszWorking = dstrcpy(pszWorking, szText);

  00168	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR _szText$[ebp]
  0016e	51		 push	 ecx
  0016f	8b 55 fc	 mov	 edx, DWORD PTR _pszWorking$[ebp]
  00172	52		 push	 edx
  00173	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  00178	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax

; 191  : 
; 192  :         //
; 193  :         // Add a carriage-return since OutputDebugString doesn't
; 194  :         //
; 195  : 
; 196  :         pszWorking = dstrcpy(pszWorking, "\n");

  0017b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01BJG@?6?$AA@ ; `string'
  00180	8b 45 fc	 mov	 eax, DWORD PTR _pszWorking$[ebp]
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  00189	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax

; 197  : 
; 198  :         //
; 199  :         // Output to the debugger
; 200  :         //
; 201  : 
; 202  :         OutputDebugStringA(szDebug);

  0018c	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _szDebug$[ebp]
  00192	51		 push	 ecx
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 203  : 
; 204  :         //
; 205  :         // Break into the debugger
; 206  :         //
; 207  : 
; 208  :         if(dwLevel && (dwLevel <= m_dwDpfBreakLevel))

  00199	83 7d 0c 00	 cmp	 DWORD PTR _dwLevel$[ebp], 0
  0019d	74 10		 je	 SHORT $L49887
  0019f	8b 55 0c	 mov	 edx, DWORD PTR _dwLevel$[ebp]
  001a2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?m_dwDpfBreakLevel@CDebug@DirectSound@@2KA ; DirectSound::CDebug::m_dwDpfBreakLevel
  001a8	77 05		 ja	 SHORT $L49887

; 209  :         {
; 210  :             Break();

  001aa	e8 00 00 00 00	 call	 ?Break@CDebug@DirectSound@@SAXXZ ; DirectSound::CDebug::Break
$L49887:

; 211  :         }
; 212  : 
; 213  : #endif // DEBUG
; 214  : 
; 215  :         //
; 216  :         // Hand off to the callback routine
; 217  :         //
; 218  : 
; 219  :         if(m_pfnDpfCallback)

  001af	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pfnDpfCallback@CDebug@DirectSound@@2P6GXKPBD@ZA, 0 ; DirectSound::CDebug::m_pfnDpfCallback
  001b6	74 11		 je	 SHORT $L49888

; 220  :         {
; 221  :             m_pfnDpfCallback(dwLevel, szText);

  001b8	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  001be	50		 push	 eax
  001bf	8b 4d 0c	 mov	 ecx, DWORD PTR _dwLevel$[ebp]
  001c2	51		 push	 ecx
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR ?m_pfnDpfCallback@CDebug@DirectSound@@2P6GXKPBD@ZA ; DirectSound::CDebug::m_pfnDpfCallback
$L49888:
$L49867:

; 222  :         }
; 223  :     }
; 224  : }

  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c3		 ret	 0
?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z ENDP ; DirectSound::CDebug::PrintStaticV
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?dstrcpy@@YGPADPADPBD@Z
_TEXT	SEGMENT
_dst$ = 8
_src$ = 12
?dstrcpy@@YGPADPADPBD@Z PROC NEAR			; dstrcpy, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L49851:

; 68   :     while(*dst = *src)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00009	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000b	88 10		 mov	 BYTE PTR [eax], dl
  0000d	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00010	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00013	85 c9		 test	 ecx, ecx
  00015	74 14		 je	 SHORT $L49852

; 69   :     {
; 70   :         dst++;

  00017	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0001a	83 c2 01	 add	 edx, 1
  0001d	89 55 08	 mov	 DWORD PTR _dst$[ebp], edx

; 71   :         src++;

  00020	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00023	83 c0 01	 add	 eax, 1
  00026	89 45 0c	 mov	 DWORD PTR _src$[ebp], eax

; 72   :     }

  00029	eb d8		 jmp	 SHORT $L49851
$L49852:

; 73   :     
; 74   :     return dst;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]

; 75   : }

  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
?dstrcpy@@YGPADPADPBD@Z ENDP				; dstrcpy
_TEXT	ENDS
PUBLIC	?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ	; DirectSound::CDebug::PrintStatic
; Function compile flags: /Odt
;	COMDAT ?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ
_TEXT	SEGMENT
_dwFlags$ = 8
_dwLevel$ = 12
_pszFile$ = 16
_nLine$ = 20
_pszFunction$ = 24
_pszLibrary$ = 28
_pszFormat$ = 32
_va$ = -4
?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ PROC NEAR ; DirectSound::CDebug::PrintStatic, COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 265  :     va_list                 va;
; 266  : 
; 267  :     va_start(va, pszFormat);

  00004	8d 45 24	 lea	 eax, DWORD PTR _pszFormat$[ebp+4]
  00007	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 268  :     PrintStaticV(dwFlags, dwLevel, pszFile, nLine, pszFunction, pszLibrary, pszFormat, va);

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 20	 mov	 edx, DWORD PTR _pszFormat$[ebp]
  00011	52		 push	 edx
  00012	8b 45 1c	 mov	 eax, DWORD PTR _pszLibrary$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 18	 mov	 ecx, DWORD PTR _pszFunction$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 14	 mov	 edx, DWORD PTR _nLine$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 10	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _dwLevel$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 08	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z ; DirectSound::CDebug::PrintStaticV
  0002f	83 c4 20	 add	 esp, 32			; 00000020H

; 269  :     va_end(va);

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 270  : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ ENDP	; DirectSound::CDebug::PrintStatic
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z
_TEXT	SEGMENT
_dwFlags$ = 8
_dwLevel$ = 12
_pszFile$ = 16
_nLine$ = 20
_pszFunction$ = 24
_pszLibrary$ = 28
?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z PROC NEAR	; DirectSound::CDebug::SetContext, COMDAT

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 307  : 
; 308  : #ifdef _XBOX
; 309  : 
; 310  :     const KIRQL             irql    = KeGetCurrentIrql();
; 311  : 
; 312  : #else // _XBOX
; 313  : 
; 314  :     static const UINT       irql    = 0;
; 315  : 
; 316  : #endif // _XBOX
; 317  : 
; 318  :     m_aContext[irql].dwFlags = dwFlags;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00006	a3 00 00 00 00	 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A, eax

; 319  :     m_aContext[irql].dwLevel = dwLevel;

  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _dwLevel$[ebp]
  0000e	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+4, ecx

; 320  :     m_aContext[irql].pszFile = pszFile;

  00014	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  00017	89 15 08 00 00
	00		 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+8, edx

; 321  :     m_aContext[irql].nLine = nLine;

  0001d	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  00020	a3 0c 00 00 00	 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+12, eax

; 322  :     m_aContext[irql].pszFunction = pszFunction;

  00025	8b 4d 18	 mov	 ecx, DWORD PTR _pszFunction$[ebp]
  00028	89 0d 10 00 00
	00		 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+16, ecx

; 323  :     m_aContext[irql].pszLibrary = pszLibrary;

  0002e	8b 55 1c	 mov	 edx, DWORD PTR _pszLibrary$[ebp]
  00031	89 15 14 00 00
	00		 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+20, edx

; 324  : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ENDP	; DirectSound::CDebug::SetContext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Print@CDebug@DirectSound@@SAXPBDZZ
_TEXT	SEGMENT
_pszFormat$ = 8
_va$ = -4
?Print@CDebug@DirectSound@@SAXPBDZZ PROC NEAR		; DirectSound::CDebug::Print, COMDAT

; 353  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 354  : 
; 355  : #ifdef _XBOX
; 356  : 
; 357  :     const KIRQL             irql    = KeGetCurrentIrql();
; 358  : 
; 359  : #else // _XBOX
; 360  : 
; 361  :     static const UINT       irql    = 0;
; 362  : 
; 363  : #endif // _XBOX
; 364  : 
; 365  :     va_list                 va;
; 366  : 
; 367  :     va_start(va, pszFormat);

  00004	8d 45 0c	 lea	 eax, DWORD PTR _pszFormat$[ebp+4]
  00007	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 368  :     PrintStaticV(m_aContext[irql].dwFlags, m_aContext[irql].dwLevel, m_aContext[irql].pszFile, m_aContext[irql].nLine, m_aContext[irql].pszFunction, m_aContext[irql].pszLibrary, pszFormat, va);

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR _pszFormat$[ebp]
  00011	52		 push	 edx
  00012	a1 14 00 00 00	 mov	 eax, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+20
  00017	50		 push	 eax
  00018	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+16
  0001e	51		 push	 ecx
  0001f	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+12
  00025	52		 push	 edx
  00026	a1 08 00 00 00	 mov	 eax, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+8
  0002b	50		 push	 eax
  0002c	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A+4
  00032	51		 push	 ecx
  00033	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z ; DirectSound::CDebug::PrintStaticV
  0003f	83 c4 20	 add	 esp, 32			; 00000020H

; 369  :     va_end(va);

  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 370  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?Print@CDebug@DirectSound@@SAXPBDZZ ENDP		; DirectSound::CDebug::Print
_TEXT	ENDS
PUBLIC	??_C@_0BF@OGHG@Assertion?5failed?5in?5?$AA@	; `string'
PUBLIC	??_C@_07PKF@?0?5line?5?$AA@			; `string'
PUBLIC	??_C@_02CGGM@?3?6?$AA@				; `string'
EXTRN	__itoa:NEAR
;	COMDAT ??_C@_0BF@OGHG@Assertion?5failed?5in?5?$AA@
CONST	SEGMENT
??_C@_0BF@OGHG@Assertion?5failed?5in?5?$AA@ DB 'Assertion failed in ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PKF@?0?5line?5?$AA@
CONST	SEGMENT
??_C@_07PKF@?0?5line?5?$AA@ DB ', line ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02CGGM@?3?6?$AA@
CONST	SEGMENT
??_C@_02CGGM@?3?6?$AA@ DB ':', 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z
_TEXT	SEGMENT
_fAssert$ = 8
_pszExpression$ = 12
_pszFile$ = 16
_nLine$ = 20
_szMessage$ = -1032
_pszMessage$ = -4
?Assert@CDebug@DirectSound@@SAXHPBD0I@Z PROC NEAR	; DirectSound::CDebug::Assert, COMDAT

; 403  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H

; 404  :     static const LPCSTR     pszBanner           = "******************************************************************************";
; 405  :     CHAR                    szMessage[0x400];
; 406  :     LPSTR                   pszMessage;
; 407  : 
; 408  :     if(fAssert)

  00009	83 7d 08 00	 cmp	 DWORD PTR _fAssert$[ebp], 0
  0000d	0f 84 ed 00 00
	00		 je	 $L49934

; 409  :     {
; 410  :         pszMessage = szMessage;

  00013	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _szMessage$[ebp]
  00019	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 411  : 
; 412  :         pszMessage = dstrcpy(pszMessage, pszBanner);

  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??Assert@CDebug@DirectSound@@SAXHPBD0I@Z@4QBDB
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0002c	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 413  :         pszMessage = dstrcpy(pszMessage, "\n");

  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01BJG@?6?$AA@ ; `string'
  00034	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0003d	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 414  :         pszMessage = dstrcpy(pszMessage, "Assertion failed in ");

  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@OGHG@Assertion?5failed?5in?5?$AA@ ; `string'
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _pszMessage$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0004e	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 415  :         pszMessage = dstrcpy(pszMessage, pszFile);

  00051	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  00054	52		 push	 edx
  00055	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0005e	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 416  :         pszMessage = dstrcpy(pszMessage, ", line ");

  00061	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07PKF@?0?5line?5?$AA@ ; `string'
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _pszMessage$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0006f	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 417  :     
; 418  :         _itoa(nLine, pszMessage, 10);

  00072	6a 0a		 push	 10			; 0000000aH
  00074	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  00077	52		 push	 edx
  00078	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 __itoa
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 419  :         pszMessage += strlen(pszMessage);

  00084	8b 4d fc	 mov	 ecx, DWORD PTR _pszMessage$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _strlen
  0008d	83 c4 04	 add	 esp, 4
  00090	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  00093	03 d0		 add	 edx, eax
  00095	89 55 fc	 mov	 DWORD PTR _pszMessage$[ebp], edx

; 420  : 
; 421  :         pszMessage = dstrcpy(pszMessage, ":\n");

  00098	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02CGGM@?3?6?$AA@ ; `string'
  0009d	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000a6	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 422  :         pszMessage = dstrcpy(pszMessage, pszExpression);

  000a9	8b 4d 0c	 mov	 ecx, DWORD PTR _pszExpression$[ebp]
  000ac	51		 push	 ecx
  000ad	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  000b0	52		 push	 edx
  000b1	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000b6	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 423  :         pszMessage = dstrcpy(pszMessage, "\n");

  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01BJG@?6?$AA@ ; `string'
  000be	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000c7	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 424  :         pszMessage = dstrcpy(pszMessage, pszBanner);

  000ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??Assert@CDebug@DirectSound@@SAXHPBD0I@Z@4QBDB
  000d0	51		 push	 ecx
  000d1	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000da	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 425  :         pszMessage = dstrcpy(pszMessage, "\n");

  000dd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01BJG@?6?$AA@ ; `string'
  000e2	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000eb	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 426  : 
; 427  :         OutputDebugStringA(szMessage);

  000ee	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _szMessage$[ebp]
  000f4	51		 push	 ecx
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 428  :         Break();

  000fb	e8 00 00 00 00	 call	 ?Break@CDebug@DirectSound@@SAXXZ ; DirectSound::CDebug::Break
$L49934:

; 429  :     }
; 430  : }

  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ENDP		; DirectSound::CDebug::Assert
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Break@CDebug@DirectSound@@SAXXZ
_TEXT	SEGMENT
?Break@CDebug@DirectSound@@SAXXZ PROC NEAR		; DirectSound::CDebug::Break, COMDAT

; 457  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 458  :     //
; 459  :     // Break in the debugger
; 460  :     //
; 461  :     
; 462  :     __asm int 3;

  00003	cc		 int	 3

; 463  : 
; 464  : #ifdef _XBOX
; 465  : 
; 466  :     //
; 467  :     // If we're at DISPATCH_LEVEL or higher, the VC debugger won't catch
; 468  :     // the break.
; 469  :     //
; 470  :     
; 471  :     if(KeGetCurrentIrql() >= DISPATCH_LEVEL)
; 472  :     {
; 473  :         m_fDebugBreak = TRUE;
; 474  :     }
; 475  : 
; 476  : #endif // _XBOX
; 477  : 
; 478  : }

  00004	5d		 pop	 ebp
  00005	c3		 ret	 0
?Break@CDebug@DirectSound@@SAXXZ ENDP			; DirectSound::CDebug::Break
_TEXT	ENDS
PUBLIC	??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_08KCAL@cbBuffer?$AA@			; `string'
PUBLIC	??_C@_0BK@BHJJ@CMemoryManager?3?3PoolAlloc?$AA@	; `string'
PUBLIC	??_C@_0BD@LFMI@Out?5of?5pool?5memory?$AA@	; `string'
PUBLIC	?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::PoolAlloc
EXTRN	__imp__LocalAlloc@8:NEAR
EXTRN	__imp__LocalSize@4:NEAR
;	COMDAT ??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\common\memmgr.cpp
CONST	SEGMENT
??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\privat'
	DB	'e\windows\directx\dsound\common\memmgr.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KCAL@cbBuffer?$AA@
CONST	SEGMENT
??_C@_08KCAL@cbBuffer?$AA@ DB 'cbBuffer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BHJJ@CMemoryManager?3?3PoolAlloc?$AA@
CONST	SEGMENT
??_C@_0BK@BHJJ@CMemoryManager?3?3PoolAlloc?$AA@ DB 'CMemoryManager::PoolA'
	DB	'lloc', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LFMI@Out?5of?5pool?5memory?$AA@
CONST	SEGMENT
??_C@_0BD@LFMI@Out?5of?5pool?5memory?$AA@ DB 'Out of pool memory', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z
_TEXT	SEGMENT
_cbBuffer$ = 12
_fZeroInit$ = 16
_pvBuffer$ = -4
?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z PROC NEAR ; DirectSound::CMemoryManager::PoolAlloc, COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 65   :     static const ULONG      cbLowerThreshold    = 0x20;
; 66   :     static const DWORD      cbUpperThreshold    = 0xFD8;
; 67   :     LPVOID                  pvBuffer;
; 68   : 
; 69   :     ASSERT(cbBuffer);

  00004	6a 45		 push	 69			; 00000045H
  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08KCAL@cbBuffer?$AA@ ; `string'
  00010	33 c0		 xor	 eax, eax
  00012	83 7d 0c 00	 cmp	 DWORD PTR _cbBuffer$[ebp], 0
  00016	0f 94 c0	 sete	 al
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0001f	83 c4 10	 add	 esp, 16			; 00000010H

; 70   : 
; 71   : #ifdef _XBOX
; 72   : 
; 73   : #ifdef MEM_SIZE_CHECK
; 74   : 
; 75   : #pragma TODO("Don't ship with this check turned on")
; 76   :     
; 77   :     if((DSOUND_OBJECT_POOL_TAG == nPoolTag) && (cbBuffer >= cbUpperThreshold))
; 78   :     {
; 79   :         ASSERTMSG("Allocating an object larger than the pool threshold");
; 80   :     }
; 81   :     else if((DSOUND_DATA_POOL_TAG == nPoolTag) && (cbBuffer < cbLowerThreshold))
; 82   :     {
; 83   :         ASSERTMSG("Allocating a buffer smaller than 32 bytes");
; 84   :     }
; 85   : 
; 86   : #endif // _MEM_SIZE_CHECK
; 87   : 
; 88   :     if(pvBuffer = ExAllocatePoolWithTag(cbBuffer, nPoolTag))
; 89   :     {
; 90   :         cbBuffer = ExQueryPoolBlockSize(pvBuffer);
; 91   :         m_dwPoolMemoryUsage += cbBuffer;
; 92   : 
; 93   :         if(fZeroInit)
; 94   :         {
; 95   :             ZeroMemory(pvBuffer, cbBuffer);
; 96   :         }
; 97   :     }
; 98   : 
; 99   : #else // _XBOX
; 100  : 
; 101  :     if(pvBuffer = LocalAlloc(fZeroInit ? LPTR : LMEM_FIXED, cbBuffer))

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 10	 mov	 edx, DWORD PTR _fZeroInit$[ebp]
  00029	f7 da		 neg	 edx
  0002b	1b d2		 sbb	 edx, edx
  0002d	83 e2 40	 and	 edx, 64			; 00000040H
  00030	52		 push	 edx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalAlloc@8
  00037	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  0003e	74 1e		 je	 SHORT $L49954

; 102  :     {
; 103  :         cbBuffer = LocalSize(pvBuffer);

  00040	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalSize@4
  0004a	89 45 0c	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 104  :         m_dwPoolMemoryUsage += cbBuffer;

  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  00053	03 4d 0c	 add	 ecx, DWORD PTR _cbBuffer$[ebp]
  00056	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA, ecx ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage

; 105  :     }
; 106  : 
; 107  : #endif // _XBOX
; 108  : 
; 109  :     else

  0005c	eb 2a		 jmp	 SHORT $L49955
$L49954:

; 110  :     {
; 111  :         DPF_RESOURCE("Out of pool memory");

  0005e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00063	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@BHJJ@CMemoryManager?3?3PoolAlloc?$AA@ ; `string'
  00068	6a 6f		 push	 111			; 0000006fH
  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0006f	6a 02		 push	 2
  00071	6a 09		 push	 9
  00073	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00078	83 c4 18	 add	 esp, 24			; 00000018H
  0007b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@LFMI@Out?5of?5pool?5memory?$AA@ ; `string'
  00080	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00085	83 c4 04	 add	 esp, 4
$L49955:

; 112  :     }
; 113  : 
; 114  :     return pvBuffer;

  00088	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 115  : }

  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 0c 00	 ret	 12			; 0000000cH
?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ENDP ; DirectSound::CMemoryManager::PoolAlloc
_TEXT	ENDS
PUBLIC	??_C@_08KLJN@pvBuffer?$AA@			; `string'
PUBLIC	??_C@_0CA@JMGJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@ ; `string'
PUBLIC	?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z	; DirectSound::CMemoryManager::PoolFree
EXTRN	__imp__LocalFree@4:NEAR
;	COMDAT ??_C@_08KLJN@pvBuffer?$AA@
CONST	SEGMENT
??_C@_08KLJN@pvBuffer?$AA@ DB 'pvBuffer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JMGJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@
CONST	SEGMENT
??_C@_0CA@JMGJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@ DB 'm_dwPoolM'
	DB	'emoryUsage >= cbBuffer', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
_cbBuffer$ = -4
?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::PoolFree, COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 142  :     DWORD                   cbBuffer;
; 143  : 
; 144  :     ASSERT(pvBuffer);

  00004	68 90 00 00 00	 push	 144			; 00000090H
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08KLJN@pvBuffer?$AA@ ; `string'
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 08 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 145  : 
; 146  : #ifdef _XBOX
; 147  : 
; 148  :     cbBuffer = ExQueryPoolBlockSize(pvBuffer);
; 149  : 
; 150  :     ASSERT(m_dwPoolMemoryUsage >= cbBuffer);
; 151  :     m_dwPoolMemoryUsage -= cbBuffer;
; 152  : 
; 153  :     ExFreePool(pvBuffer);
; 154  : 
; 155  : #else // _XBOX
; 156  : 
; 157  :     cbBuffer = LocalSize(pvBuffer);

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00028	51		 push	 ecx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalSize@4
  0002f	89 45 fc	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 158  : 
; 159  :     ASSERT(m_dwPoolMemoryUsage >= cbBuffer);

  00032	68 9f 00 00 00	 push	 159			; 0000009fH
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@JMGJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@ ; `string'
  00041	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  00047	3b 55 fc	 cmp	 edx, DWORD PTR _cbBuffer$[ebp]
  0004a	1b c0		 sbb	 eax, eax
  0004c	f7 d8		 neg	 eax
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00054	83 c4 10	 add	 esp, 16			; 00000010H

; 160  :     m_dwPoolMemoryUsage -= cbBuffer;

  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  0005d	2b 4d fc	 sub	 ecx, DWORD PTR _cbBuffer$[ebp]
  00060	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA, ecx ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage

; 161  : 
; 162  :     LocalFree(pvBuffer);

  00066	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00069	52		 push	 edx
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4

; 163  : 
; 164  : #endif // _XBOX
; 165  : 
; 166  : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP	; DirectSound::CMemoryManager::PoolFree
_TEXT	ENDS
PUBLIC	??_C@_07BFD@dwFlags?$AA@			; `string'
PUBLIC	??_C@_0BO@LELL@CMemoryManager?3?3PhysicalAlloc?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MFKD@Out?5of?5contiguous?5memory?$AA@	; `string'
PUBLIC	?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z ; DirectSound::CMemoryManager::PhysicalAlloc
EXTRN	__imp__VirtualAlloc@16:NEAR
;	COMDAT ??_C@_07BFD@dwFlags?$AA@
CONST	SEGMENT
??_C@_07BFD@dwFlags?$AA@ DB 'dwFlags', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LELL@CMemoryManager?3?3PhysicalAlloc?$AA@
CONST	SEGMENT
??_C@_0BO@LELL@CMemoryManager?3?3PhysicalAlloc?$AA@ DB 'CMemoryManager::P'
	DB	'hysicalAlloc', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MFKD@Out?5of?5contiguous?5memory?$AA@
CONST	SEGMENT
??_C@_0BJ@MFKD@Out?5of?5contiguous?5memory?$AA@ DB 'Out of contiguous mem'
	DB	'ory', 00H					; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z
_TEXT	SEGMENT
_cbBuffer$ = 8
_dwFlags$ = 16
_fZeroInit$ = 20
_pvBuffer$ = -4
?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z PROC NEAR ; DirectSound::CMemoryManager::PhysicalAlloc, COMDAT

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 199  :     LPVOID                  pvBuffer;
; 200  : 
; 201  :     ASSERT(cbBuffer);

  00004	68 c9 00 00 00	 push	 201			; 000000c9H
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08KCAL@cbBuffer?$AA@ ; `string'
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 08 00	 cmp	 DWORD PTR _cbBuffer$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 202  :     ASSERT(dwFlags);

  00025	68 ca 00 00 00	 push	 202			; 000000caH
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07BFD@dwFlags?$AA@ ; `string'
  00034	33 c9		 xor	 ecx, ecx
  00036	83 7d 10 00	 cmp	 DWORD PTR _dwFlags$[ebp], 0
  0003a	0f 94 c1	 sete	 cl
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00043	83 c4 10	 add	 esp, 16			; 00000010H

; 203  :     
; 204  : #ifdef _XBOX
; 205  : 
; 206  :     if(pvBuffer = MmAllocateContiguousMemoryEx(cbBuffer, 0, 0xFFFFFFFF, cbAlignment, dwFlags))
; 207  :     {
; 208  :         cbBuffer = MmQueryAllocationSize(pvBuffer);
; 209  :         m_dwPhysicalMemoryUsage += cbBuffer;
; 210  : 
; 211  :         if(fZeroInit)
; 212  :         {
; 213  :             ZeroMemory(pvBuffer, cbBuffer);
; 214  :         }
; 215  :     }
; 216  : 
; 217  : #else // _XBOX
; 218  : 
; 219  :     if(pvBuffer = VirtualAlloc(NULL, cbBuffer, MEM_COMMIT, dwFlags))

  00046	8b 55 10	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00049	52		 push	 edx
  0004a	68 00 10 00 00	 push	 4096			; 00001000H
  0004f	8b 45 08	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  00052	50		 push	 eax
  00053	6a 00		 push	 0
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16
  0005b	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  0005e	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00062	74 1a		 je	 SHORT $L49972

; 220  :     {
; 221  : 
; 222  : #pragma TODO("Not able to query for size of VirtualAlloc'd buffer")
; 223  : 
; 224  :         if(fZeroInit)

  00064	83 7d 14 00	 cmp	 DWORD PTR _fZeroInit$[ebp], 0
  00068	74 12		 je	 SHORT $L49973

; 225  :         {
; 226  :             ZeroMemory(pvBuffer, cbBuffer);

  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  0006d	51		 push	 ecx
  0006e	6a 00		 push	 0
  00070	8b 55 fc	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00073	52		 push	 edx
  00074	e8 00 00 00 00	 call	 _memset
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
$L49973:

; 227  :         }
; 228  :     }
; 229  : 
; 230  : #endif // _XBOX
; 231  : 
; 232  :     else

  0007c	eb 2d		 jmp	 SHORT $L49974
$L49972:

; 233  :     {
; 234  :         DPF_RESOURCE("Out of contiguous memory");

  0007e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00083	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@LELL@CMemoryManager?3?3PhysicalAlloc?$AA@ ; `string'
  00088	68 ea 00 00 00	 push	 234			; 000000eaH
  0008d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00092	6a 02		 push	 2
  00094	6a 09		 push	 9
  00096	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0009b	83 c4 18	 add	 esp, 24			; 00000018H
  0009e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@MFKD@Out?5of?5contiguous?5memory?$AA@ ; `string'
  000a3	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000a8	83 c4 04	 add	 esp, 4
$L49974:

; 235  :     }
; 236  : 
; 237  :     return pvBuffer;

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 238  : }

  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c2 10 00	 ret	 16			; 00000010H
?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z ENDP ; DirectSound::CMemoryManager::PhysicalAlloc
_TEXT	ENDS
PUBLIC	?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PhysicalFree
EXTRN	__imp__VirtualFree@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::PhysicalFree, COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 265  :     DWORD                   cbBuffer;
; 266  : 
; 267  :     ASSERT(pvBuffer);

  00004	68 0b 01 00 00	 push	 267			; 0000010bH
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08KLJN@pvBuffer?$AA@ ; `string'
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 08 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 268  : 
; 269  : #ifdef _XBOX
; 270  : 
; 271  :     cbBuffer = MmQueryAllocationSize(pvBuffer);
; 272  : 
; 273  :     ASSERT(m_dwPhysicalMemoryUsage >= cbBuffer);
; 274  :     m_dwPhysicalMemoryUsage -= cbBuffer;
; 275  : 
; 276  :     MmFreeContiguousMemory(pvBuffer);
; 277  : 
; 278  : #else // _XBOX
; 279  : 
; 280  : #pragma TODO("Not able to query for size of VirtualAlloc'd buffer")
; 281  : 
; 282  :     VirtualFree(pvBuffer, 0, MEM_RELEASE);

  00025	68 00 80 00 00	 push	 32768			; 00008000H
  0002a	6a 00		 push	 0
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  0002f	51		 push	 ecx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualFree@12

; 283  : 
; 284  : #endif // _XBOX
; 285  : 
; 286  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP	; DirectSound::CMemoryManager::PhysicalFree
_TEXT	ENDS
PUBLIC	??_C@_0O@EFP@pvBaseAddress?$AA@			; `string'
PUBLIC	??_C@_0CB@NOEM@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@ ; `string'
PUBLIC	??_C@_06DOGD@cbSize?$AA@			; `string'
PUBLIC	?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ; DirectSound::CMemoryManager::TrackAlloc
;	COMDAT ??_C@_0O@EFP@pvBaseAddress?$AA@
CONST	SEGMENT
??_C@_0O@EFP@pvBaseAddress?$AA@ DB 'pvBaseAddress', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NOEM@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@
CONST	SEGMENT
??_C@_0CB@NOEM@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@ DB 'cbT'
	DB	'racking >= sizeof(*pTracking)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DOGD@cbSize?$AA@
CONST	SEGMENT
??_C@_06DOGD@cbSize?$AA@ DB 'cbSize', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z
_TEXT	SEGMENT
_pvBaseAddress$ = 8
_cbTracking$ = 12
_pszFile$ = 16
_nLine$ = 20
_pszClass$ = 24
_nAllocatorTag$ = 28
_cbSize$ = 32
_pTracking$ = -4
?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z PROC NEAR ; DirectSound::CMemoryManager::TrackAlloc, COMDAT

; 466  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 467  :     LPDSMEMTRACK            pTracking;
; 468  :     
; 469  :     ASSERT(pvBaseAddress);

  00004	68 d5 01 00 00	 push	 469			; 000001d5H
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EFP@pvBaseAddress?$AA@ ; `string'
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 08 00	 cmp	 DWORD PTR _pvBaseAddress$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 470  :     ASSERT(cbTracking >= sizeof(*pTracking));

  00025	68 d6 01 00 00	 push	 470			; 000001d6H
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@NOEM@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@ ; `string'
  00034	83 7d 0c 20	 cmp	 DWORD PTR _cbTracking$[ebp], 32 ; 00000020H
  00038	1b c9		 sbb	 ecx, ecx
  0003a	f7 d9		 neg	 ecx
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00042	83 c4 10	 add	 esp, 16			; 00000010H

; 471  :     ASSERT(cbSize);

  00045	68 d7 01 00 00	 push	 471			; 000001d7H
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06DOGD@cbSize?$AA@ ; `string'
  00054	33 d2		 xor	 edx, edx
  00056	83 7d 20 00	 cmp	 DWORD PTR _cbSize$[ebp], 0
  0005a	0f 94 c2	 sete	 dl
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00063	83 c4 10	 add	 esp, 16			; 00000010H

; 472  :     
; 473  :     //
; 474  :     // Because of alignment issues, the base address may be incremented more
; 475  :     // than sizeof(DSMEMTRACK).  For this reason, we store the tracking data
; 476  :     // directly behind the allocation, but allocate more than cbSize +
; 477  :     // sizeof(DSMEMTRACK).
; 478  :     //
; 479  : 
; 480  :     pTracking = (LPDSMEMTRACK)((LPBYTE)pvBaseAddress + cbTracking - sizeof(*pTracking));

  00066	8b 45 0c	 mov	 eax, DWORD PTR _cbTracking$[ebp]
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  0006c	8d 54 01 e0	 lea	 edx, DWORD PTR [ecx+eax-32]
  00070	89 55 fc	 mov	 DWORD PTR _pTracking$[ebp], edx

; 481  : 
; 482  :     //
; 483  :     // Create the tracking info
; 484  :     //
; 485  : 
; 486  :     pTracking->pszFile = pszFile;

  00073	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  00076	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  00079	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 487  :     pTracking->nLine = nLine;

  0007c	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  0007f	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  00082	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 488  :     pTracking->pszClass = pszClass;

  00085	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  00088	8b 55 18	 mov	 edx, DWORD PTR _pszClass$[ebp]
  0008b	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 489  :     pTracking->nAllocatorTag = nAllocatorTag;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  00091	8b 4d 1c	 mov	 ecx, DWORD PTR _nAllocatorTag$[ebp]
  00094	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 490  :     pTracking->cbSize = cbSize;

  00097	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  0009a	8b 45 20	 mov	 eax, DWORD PTR _cbSize$[ebp]
  0009d	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 491  :     pTracking->pvBaseAddress = pvBaseAddress;

  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000a3	8b 55 08	 mov	 edx, DWORD PTR _pvBaseAddress$[ebp]
  000a6	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 492  : 
; 493  : #ifdef _XBOX
; 494  : 
; 495  :     //
; 496  :     // Raise IRQL for synchronization
; 497  :     //
; 498  : 
; 499  :     AutoIrql();
; 500  : 
; 501  : #endif // _XBOX
; 502  : 
; 503  :     //
; 504  :     // Add the allocation to the list
; 505  :     //
; 506  : 
; 507  :     if(!m_lstMemoryTracking.Flink && !m_lstMemoryTracking.Blink)

  000a9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, 0
  000b0	75 1d		 jne	 SHORT $L49996
  000b2	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A+4, 0
  000b9	75 14		 jne	 SHORT $L49996

; 508  :     {
; 509  :         InitializeListHead(&m_lstMemoryTracking);

  000bb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A
  000ca	a3 04 00 00 00	 mov	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A+4, eax
$L49996:

; 510  :     }
; 511  :     
; 512  :     InsertTailListUninit(&m_lstMemoryTracking, &pTracking->leListEntry);

  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000d2	51		 push	 ecx
  000d3	68 00 00 00 00	 push	 OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  000d8	e8 00 00 00 00	 call	 ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailListUninit

; 513  : 
; 514  :     //
; 515  :     // Fix up the base address
; 516  :     //
; 517  : 
; 518  :     return pTracking + 1;

  000dd	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  000e0	83 c0 20	 add	 eax, 32			; 00000020H

; 519  : }

  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 1c 00	 ret	 28			; 0000001cH
?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ENDP ; DirectSound::CMemoryManager::TrackAlloc
_TEXT	ENDS
PUBLIC	??_C@_0CK@EOH@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@ ; `string'
PUBLIC	?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ; DirectSound::CMemoryManager::ForgetAlloc
;	COMDAT ??_C@_0CK@EOH@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@
CONST	SEGMENT
??_C@_0CK@EOH@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@ DB 'nAllocato'
	DB	'rTag == pTracking->nAllocatorTag', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z
_TEXT	SEGMENT
_pvBaseAddress$ = 8
_nAllocatorTag$ = 12
_pTracking$ = -4
?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z PROC NEAR ; DirectSound::CMemoryManager::ForgetAlloc, COMDAT

; 551  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 552  :     LPDSMEMTRACK            pTracking   = (LPDSMEMTRACK)pvBaseAddress - 1;

  00004	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  00007	83 e8 20	 sub	 eax, 32			; 00000020H
  0000a	89 45 fc	 mov	 DWORD PTR _pTracking$[ebp], eax

; 553  : 
; 554  :     ASSERT(pvBaseAddress);

  0000d	68 2a 02 00 00	 push	 554			; 0000022aH
  00012	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EFP@pvBaseAddress?$AA@ ; `string'
  0001c	33 c9		 xor	 ecx, ecx
  0001e	83 7d 08 00	 cmp	 DWORD PTR _pvBaseAddress$[ebp], 0
  00022	0f 94 c1	 sete	 cl
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 555  : 
; 556  :     //
; 557  :     // Assert that the tag matches what we expect
; 558  :     //
; 559  : 
; 560  :     ASSERT(nAllocatorTag == pTracking->nAllocatorTag);

  0002e	68 30 02 00 00	 push	 560			; 00000230H
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@EOH@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@ ; `string'
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  00040	8b 45 0c	 mov	 eax, DWORD PTR _nAllocatorTag$[ebp]
  00043	33 c9		 xor	 ecx, ecx
  00045	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  00048	0f 95 c1	 setne	 cl
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00051	83 c4 10	 add	 esp, 16			; 00000010H

; 561  :     
; 562  : #ifdef _XBOX
; 563  : 
; 564  :     //
; 565  :     // Raise IRQL for synchronization
; 566  :     //
; 567  : 
; 568  :     AutoIrql();
; 569  : 
; 570  : #endif // _XBOX
; 571  : 
; 572  :     //
; 573  :     // Remove the allocation from the list
; 574  :     //
; 575  : 
; 576  :     RemoveEntryList(&pTracking->leListEntry);

  00054	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 577  : 
; 578  :     //
; 579  :     // Return the proper base address
; 580  :     //
; 581  : 
; 582  :     return pTracking->pvBaseAddress;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  00060	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]

; 583  : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ENDP ; DirectSound::CMemoryManager::ForgetAlloc
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z
_TEXT	SEGMENT
_pszFile$ = 8
_nLine$ = 12
_pszClass$ = 16
_nPoolTag$ = 20
_cbBuffer$ = 24
_fZeroInit$ = 28
_pvBuffer$ = -4
?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z PROC NEAR ; DirectSound::CMemoryManager::TrackingPoolAlloc, COMDAT

; 623  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 624  : 
; 625  : #ifdef _XBOX
; 626  : 
; 627  :     static const ULONG      cbTracking  = PAGE_SIZE;
; 628  : 
; 629  : #else // _XBOX
; 630  : 
; 631  :     static const ULONG      cbTracking  = sizeof(DSMEMTRACK);
; 632  : 
; 633  : #endif // _XBOX
; 634  : 
; 635  :     LPVOID                  pvBuffer;
; 636  :     
; 637  :     //
; 638  :     // Do the actual allocation
; 639  :     //
; 640  :     
; 641  :     if(pvBuffer = PoolAlloc(nPoolTag, cbBuffer + cbTracking, fZeroInit))

  00004	8b 45 1c	 mov	 eax, DWORD PTR _fZeroInit$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 18	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  0000b	83 c1 20	 add	 ecx, 32			; 00000020H
  0000e	51		 push	 ecx
  0000f	8b 55 14	 mov	 edx, DWORD PTR _nPoolTag$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::PoolAlloc
  00018	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  0001b	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  0001f	74 23		 je	 SHORT $L50016

; 642  :     {
; 643  :         //
; 644  :         // Complete the tracking
; 645  :         //
; 646  : 
; 647  :         pvBuffer = TrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_POOL, cbBuffer);

  00021	8b 45 18	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  00024	50		 push	 eax
  00025	68 70 6f 6f 6c	 push	 1819242352		; 6c6f6f70H
  0002a	8b 4d 10	 mov	 ecx, DWORD PTR _pszClass$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 0c	 mov	 edx, DWORD PTR _nLine$[ebp]
  00031	52		 push	 edx
  00032	8b 45 08	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00035	50		 push	 eax
  00036	6a 20		 push	 32			; 00000020H
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ; DirectSound::CMemoryManager::TrackAlloc
  00041	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
$L50016:

; 648  :     }
; 649  : 
; 650  :     return pvBuffer;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 651  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 18 00	 ret	 24			; 00000018H
?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ENDP ; DirectSound::CMemoryManager::TrackingPoolAlloc
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::TrackingPoolFree, COMDAT

; 681  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 682  :     //
; 683  :     // Free tracking information
; 684  :     //
; 685  : 
; 686  :     pvBuffer = ForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_POOL);

  00003	68 70 6f 6f 6c	 push	 1819242352		; 6c6f6f70H
  00008	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ; DirectSound::CMemoryManager::ForgetAlloc
  00011	89 45 08	 mov	 DWORD PTR _pvBuffer$[ebp], eax

; 687  : 
; 688  :     //
; 689  :     // Free memory
; 690  :     //
; 691  : 
; 692  :     PoolFree(pvBuffer);

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PoolFree

; 693  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP ; DirectSound::CMemoryManager::TrackingPoolFree
_TEXT	ENDS
PUBLIC	?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z ; DirectSound::CMemoryManager::TrackingPhysicalAlloc
; Function compile flags: /Odt
;	COMDAT ?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z
_TEXT	SEGMENT
_pszFile$ = 8
_nLine$ = 12
_pszClass$ = 16
_cbBuffer$ = 20
_cbAlignment$ = 24
_dwFlags$ = 28
_fZeroInit$ = 32
_cbTracking$ = -4
_pvBuffer$ = -8
?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z PROC NEAR ; DirectSound::CMemoryManager::TrackingPhysicalAlloc, COMDAT

; 732  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 733  :     ULONG                   cbTracking;
; 734  :     LPVOID                  pvBuffer;
; 735  : 
; 736  :     //
; 737  :     // Make sure we allocate enough information for the tracking data
; 738  :     //
; 739  : 
; 740  :     if(cbAlignment >= sizeof(DSMEMTRACK))

  00006	83 7d 18 20	 cmp	 DWORD PTR _cbAlignment$[ebp], 32 ; 00000020H
  0000a	72 08		 jb	 SHORT $L50032

; 741  :     {
; 742  :         cbTracking = cbAlignment;

  0000c	8b 45 18	 mov	 eax, DWORD PTR _cbAlignment$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _cbTracking$[ebp], eax

; 743  :     }
; 744  :     else

  00012	eb 12		 jmp	 SHORT $L50033
$L50032:

; 745  :     {
; 746  :         cbTracking = BLOCKALIGNPAD(sizeof(DSMEMTRACK), cbAlignment);

  00014	8b 45 18	 mov	 eax, DWORD PTR _cbAlignment$[ebp]
  00017	83 c0 1f	 add	 eax, 31			; 0000001fH
  0001a	33 d2		 xor	 edx, edx
  0001c	f7 75 18	 div	 DWORD PTR _cbAlignment$[ebp]
  0001f	0f af 45 18	 imul	 eax, DWORD PTR _cbAlignment$[ebp]
  00023	89 45 fc	 mov	 DWORD PTR _cbTracking$[ebp], eax
$L50033:

; 747  :     }
; 748  :     
; 749  :     //
; 750  :     // Do the actual allocation
; 751  :     //
; 752  :     
; 753  :     if(pvBuffer = PhysicalAlloc(cbBuffer + cbTracking, cbAlignment, dwFlags, fZeroInit))

  00026	8b 4d 20	 mov	 ecx, DWORD PTR _fZeroInit$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 1c	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 18	 mov	 eax, DWORD PTR _cbAlignment$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 14	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00035	03 4d fc	 add	 ecx, DWORD PTR _cbTracking$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z ; DirectSound::CMemoryManager::PhysicalAlloc
  0003e	89 45 f8	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  00041	83 7d f8 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00045	74 25		 je	 SHORT $L50035

; 754  :     {
; 755  :         //
; 756  :         // Complete the tracking
; 757  :         //
; 758  : 
; 759  :         pvBuffer = TrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_PHYS, cbBuffer);

  00047	8b 55 14	 mov	 edx, DWORD PTR _cbBuffer$[ebp]
  0004a	52		 push	 edx
  0004b	68 70 68 79 73	 push	 1937336432		; 73796870H
  00050	8b 45 10	 mov	 eax, DWORD PTR _pszClass$[ebp]
  00053	50		 push	 eax
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00057	51		 push	 ecx
  00058	8b 55 08	 mov	 edx, DWORD PTR _pszFile$[ebp]
  0005b	52		 push	 edx
  0005c	8b 45 fc	 mov	 eax, DWORD PTR _cbTracking$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d f8	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ; DirectSound::CMemoryManager::TrackAlloc
  00069	89 45 f8	 mov	 DWORD PTR _pvBuffer$[ebp], eax
$L50035:

; 760  :     }
; 761  : 
; 762  :     return pvBuffer;

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 763  : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 1c 00	 ret	 28			; 0000001cH
?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z ENDP ; DirectSound::CMemoryManager::TrackingPhysicalAlloc
_TEXT	ENDS
PUBLIC	?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPhysicalFree
; Function compile flags: /Odt
;	COMDAT ?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::TrackingPhysicalFree, COMDAT

; 793  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 794  :     //
; 795  :     // Free tracking information
; 796  :     //
; 797  : 
; 798  :     pvBuffer = ForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_PHYS);

  00003	68 70 68 79 73	 push	 1937336432		; 73796870H
  00008	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ; DirectSound::CMemoryManager::ForgetAlloc
  00011	89 45 08	 mov	 DWORD PTR _pvBuffer$[ebp], eax

; 799  : 
; 800  :     //
; 801  :     // Free memory
; 802  :     //
; 803  : 
; 804  :     PhysicalFree(pvBuffer);

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PhysicalFree

; 805  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP ; DirectSound::CMemoryManager::TrackingPhysicalFree
_TEXT	ENDS
PUBLIC	??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@ ; `string'
PUBLIC	??_C@_0BI@CNJN@Begin?5memory?5usage?5dump?$AA@	; `string'
PUBLIC	??_C@_0BI@HDD@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BH@PGGD@Pool?5memory?5used?3?5?5?$CFlu?$AA@ ; `string'
PUBLIC	??_C@_0BL@MNK@Physical?5memory?5used?3?5?5?$CFlu?$AA@ ; `string'
PUBLIC	??_C@_0BG@LFMD@End?5memory?5usage?5dump?$AA@	; `string'
PUBLIC	??_C@_0CD@GIH@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@ ; `string'
PUBLIC	??_C@_0CC@JMDO@IsListEmpty?$CI?$CGm_lstMemoryTracking@ ; `string'
PUBLIC	?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z ; DirectSound::CMemoryManager::DumpMemoryUsage
;	COMDAT ??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@
CONST	SEGMENT
??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@ DB 'CMemoryManager:'
	DB	':DumpMemoryUsage', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CNJN@Begin?5memory?5usage?5dump?$AA@
CONST	SEGMENT
??_C@_0BI@CNJN@Begin?5memory?5usage?5dump?$AA@ DB 'Begin memory usage dum'
	DB	'p', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HDD@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@
CONST	SEGMENT
??_C@_0BI@HDD@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@ DB '%x (%l'
	DB	'u bytes, type %s)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PGGD@Pool?5memory?5used?3?5?5?$CFlu?$AA@
CONST	SEGMENT
??_C@_0BH@PGGD@Pool?5memory?5used?3?5?5?$CFlu?$AA@ DB 'Pool memory used: '
	DB	' %lu', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MNK@Physical?5memory?5used?3?5?5?$CFlu?$AA@
CONST	SEGMENT
??_C@_0BL@MNK@Physical?5memory?5used?3?5?5?$CFlu?$AA@ DB 'Physical memory'
	DB	' used:  %lu', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LFMD@End?5memory?5usage?5dump?$AA@
CONST	SEGMENT
??_C@_0BG@LFMD@End?5memory?5usage?5dump?$AA@ DB 'End memory usage dump', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GIH@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@
CONST	SEGMENT
??_C@_0CD@GIH@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@ DB '!IsListEmpty'
	DB	'(&m_lstMemoryTracking)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JMDO@IsListEmpty?$CI?$CGm_lstMemoryTracking@
CONST	SEGMENT
??_C@_0CC@JMDO@IsListEmpty?$CI?$CGm_lstMemoryTracking@ DB 'IsListEmpty(&m'
	DB	'_lstMemoryTracking)', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z
_TEXT	SEGMENT
_fAssertNone$ = 8
_pleEntry$ = -8
_pTracking$ = -4
?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z PROC NEAR ; DirectSound::CMemoryManager::DumpMemoryUsage, COMDAT

; 930  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 931  : 
; 932  : #ifdef DEBUG
; 933  : 
; 934  :     static const LPCSTR     pszBanner           = "------------------------------------------------------------------------------";
; 935  : 
; 936  : #ifdef TRACK_MEMORY_USAGE
; 937  : 
; 938  :     PLIST_ENTRY             pleEntry;
; 939  :     LPDSMEMTRACK            pTracking;
; 940  : 
; 941  : #endif // TRACK_MEMORY_USAGE
; 942  : 
; 943  :     CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);

  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@ ; `string'
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0001d	83 c4 18	 add	 esp, 24			; 00000018H

; 944  :     CDebug::Print(pszBanner);

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0002b	83 c4 04	 add	 esp, 4

; 945  :     CDebug::Print("Begin memory usage dump");

  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@CNJN@Begin?5memory?5usage?5dump?$AA@ ; `string'
  00033	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00038	83 c4 04	 add	 esp, 4

; 946  :     CDebug::Print(pszBanner);

  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00047	83 c4 04	 add	 esp, 4

; 947  :     
; 948  : #ifdef TRACK_MEMORY_USAGE
; 949  : 
; 950  : #ifdef _XBOX
; 951  : 
; 952  :     //
; 953  :     // Raise IRQL for synchronization
; 954  :     //
; 955  : 
; 956  :     AutoIrql();
; 957  : 
; 958  : #endif // _XBOX
; 959  :    
; 960  :     //
; 961  :     // Show specifically what allocations are remaining
; 962  :     //
; 963  :     
; 964  :     if(m_lstMemoryTracking.Flink)

  0004a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, 0
  00051	0f 84 b8 00 00
	00		 je	 $L50049

; 965  :     {
; 966  :         if(!IsListEmpty(&m_lstMemoryTracking))

  00057	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  00061	0f 84 a8 00 00
	00		 je	 $L50050

; 967  :         {
; 968  :             for(pleEntry = m_lstMemoryTracking.Flink; pleEntry != &m_lstMemoryTracking; pleEntry = pleEntry->Flink)

  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A
  0006d	89 55 f8	 mov	 DWORD PTR _pleEntry$[ebp], edx
  00070	eb 08		 jmp	 SHORT $L50051
$L50052:
  00072	8b 45 f8	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  00075	8b 08		 mov	 ecx, DWORD PTR [eax]
  00077	89 4d f8	 mov	 DWORD PTR _pleEntry$[ebp], ecx
$L50051:
  0007a	81 7d f8 00 00
	00 00		 cmp	 DWORD PTR _pleEntry$[ebp], OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  00081	74 63		 je	 SHORT $L50053

; 969  :             {
; 970  :                 AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

  00083	68 ca 03 00 00	 push	 970			; 000003caH
  00088	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0008d	6a 01		 push	 1
  0008f	8b 55 f8	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  00092	52		 push	 edx
  00093	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 971  :             
; 972  :                 pTracking = CONTAINING_RECORD(pleEntry, DSMEMTRACK, leListEntry);

  00098	8b 45 f8	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  0009b	89 45 fc	 mov	 DWORD PTR _pTracking$[ebp], eax

; 973  : 
; 974  :                 CDebug::SetContext(DPF_FLAGS_FILELINE, DPFLVL_ABSOLUTE, pTracking->pszFile, pTracking->nLine, DPF_FNAME, DPF_LIBRARY);

  0009e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@ ; `string'
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000ab	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000ae	52		 push	 edx
  000af	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  000b2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b5	51		 push	 ecx
  000b6	6a 00		 push	 0
  000b8	6a 02		 push	 2
  000ba	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000bf	83 c4 18	 add	 esp, 24			; 00000018H

; 975  :                 CDebug::Print("%x (%lu bytes, type %s)", pTracking + 1, pTracking->cbSize, pTracking->pszClass);

  000c2	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  000c5	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000c8	50		 push	 eax
  000c9	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000cc	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000cf	52		 push	 edx
  000d0	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  000d3	83 c0 20	 add	 eax, 32			; 00000020H
  000d6	50		 push	 eax
  000d7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@HDD@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@ ; `string'
  000dc	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000e1	83 c4 10	 add	 esp, 16			; 00000010H

; 976  :             }

  000e4	eb 8c		 jmp	 SHORT $L50052
$L50053:

; 977  : 
; 978  :             CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);

  000e6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000eb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@ ; `string'
  000f0	6a 00		 push	 0
  000f2	6a 00		 push	 0
  000f4	6a 00		 push	 0
  000f6	6a 01		 push	 1
  000f8	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000fd	83 c4 18	 add	 esp, 24			; 00000018H

; 979  :             CDebug::Print(pszBanner);

  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  00106	51		 push	 ecx
  00107	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0010c	83 c4 04	 add	 esp, 4
$L50050:
$L50049:

; 980  :         }
; 981  :     }
; 982  : 
; 983  : #endif // TRACK_MEMORY_USAGE
; 984  : 
; 985  :     CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);

  0010f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00114	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DKNF@CMemoryManager?3?3DumpMemoryUsage?$AA@ ; `string'
  00119	6a 00		 push	 0
  0011b	6a 00		 push	 0
  0011d	6a 00		 push	 0
  0011f	6a 01		 push	 1
  00121	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00126	83 c4 18	 add	 esp, 24			; 00000018H

; 986  :     CDebug::Print("Pool memory used:  %lu", m_dwPoolMemoryUsage);

  00129	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  0012f	52		 push	 edx
  00130	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@PGGD@Pool?5memory?5used?3?5?5?$CFlu?$AA@ ; `string'
  00135	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0013a	83 c4 08	 add	 esp, 8

; 987  :     CDebug::Print("Physical memory used:  %lu", m_dwPhysicalMemoryUsage);

  0013d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
  00142	50		 push	 eax
  00143	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@MNK@Physical?5memory?5used?3?5?5?$CFlu?$AA@ ; `string'
  00148	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0014d	83 c4 08	 add	 esp, 8

; 988  : 
; 989  : #ifdef ENABLE_SLOP_MEMORY_RECOVERY
; 990  : 
; 991  :     CDebug::Print("Physical memory available for recovery:  %lu", CMcpxSlopMemoryHeap::m_dwAvailable);
; 992  :     CDebug::Print("Physical memory recovered:  %lu", CMcpxSlopMemoryHeap::m_dwUsed);
; 993  : 
; 994  : #endif // ENABLE_SLOP_MEMORY_RECOVERY
; 995  : 
; 996  :     CDebug::Print(pszBanner);

  00150	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  00156	51		 push	 ecx
  00157	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0015c	83 c4 04	 add	 esp, 4

; 997  :     CDebug::Print("End memory usage dump");

  0015f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@LFMD@End?5memory?5usage?5dump?$AA@ ; `string'
  00164	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00169	83 c4 04	 add	 esp, 4

; 998  :     CDebug::Print(pszBanner);

  0016c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  00172	52		 push	 edx
  00173	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00178	83 c4 04	 add	 esp, 4

; 999  : 
; 1000 : #ifdef ENABLE_SLOP_MEMORY_RECOVERY
; 1001 : 
; 1002 :     if(m_dwPoolMemoryUsage || m_dwPhysicalMemoryUsage || CMcpxSlopMemoryHeap::m_dwAvailable || CMcpxSlopMemoryHeap::m_dwUsed)
; 1003 : 
; 1004 : #else // ENABLE_SLOP_MEMORY_RECOVERY
; 1005 : 
; 1006 :     if(m_dwPoolMemoryUsage || m_dwPhysicalMemoryUsage)

  0017b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA, 0 ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  00182	75 09		 jne	 SHORT $L50063
  00184	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2KA, 0 ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
  0018b	74 30		 je	 SHORT $L50062
$L50063:

; 1007 : 
; 1008 : #endif // ENABLE_SLOP_MEMORY_RECOVERY
; 1009 : 
; 1010 :     {
; 1011 :         if(fAssertNone)

  0018d	83 7d 08 00	 cmp	 DWORD PTR _fAssertNone$[ebp], 0
  00191	74 01		 je	 SHORT $L50064

; 1012 :         {
; 1013 :             __asm int 3

  00193	cc		 int	 3
$L50064:

; 1014 :         }
; 1015 : 
; 1016 : #ifdef TRACK_MEMORY_USAGE
; 1017 : 
; 1018 :         ASSERT(!IsListEmpty(&m_lstMemoryTracking));

  00194	68 fa 03 00 00	 push	 1018			; 000003faH
  00199	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0019e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@GIH@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@ ; `string'
  001a3	33 c0		 xor	 eax, eax
  001a5	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  001af	0f 94 c0	 sete	 al
  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  001b8	83 c4 10	 add	 esp, 16			; 00000010H

; 1019 : 
; 1020 : #endif // TRACK_MEMORY_USAGE
; 1021 : 
; 1022 :     }
; 1023 : 
; 1024 : #ifdef TRACK_MEMORY_USAGE
; 1025 : 
; 1026 :     else

  001bb	eb 27		 jmp	 SHORT $L50066
$L50062:

; 1027 :     {
; 1028 :         ASSERT(IsListEmpty(&m_lstMemoryTracking));

  001bd	68 04 04 00 00	 push	 1028			; 00000404H
  001c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BEGK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  001c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@JMDO@IsListEmpty?$CI?$CGm_lstMemoryTracking@ ; `string'
  001cc	33 c9		 xor	 ecx, ecx
  001ce	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  001d8	0f 95 c1	 setne	 cl
  001db	51		 push	 ecx
  001dc	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  001e1	83 c4 10	 add	 esp, 16			; 00000010H
$L50066:

; 1029 :     }
; 1030 : 
; 1031 : #endif // TRACK_MEMORY_USAGE
; 1032 : 
; 1033 : #endif // DEBUG
; 1034 : 
; 1035 : }

  001e4	8b e5		 mov	 esp, ebp
  001e6	5d		 pop	 ebp
  001e7	c2 04 00	 ret	 4
?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z ENDP ; DirectSound::CMemoryManager::DumpMemoryUsage
_TEXT	ENDS
PUBLIC	??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_04PBHC@pwfx?$AA@				; `string'
;	COMDAT ??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\common\format.cpp
CONST	SEGMENT
??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\privat'
	DB	'e\windows\directx\dsound\common\format.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PBHC@pwfx?$AA@
CONST	SEGMENT
??_C@_04PBHC@pwfx?$AA@ DB 'pwfx', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_wBitsPerSample$ = 16
_pwfx$ = 20
?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::CreatePcmFormat, COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 54   :     DPF_ENTER();
; 55   :     
; 56   :     ASSERT(pwfx);

  00003	6a 38		 push	 56			; 00000038H
  00005	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PBHC@pwfx?$AA@ ; `string'
  0000f	33 c0		 xor	 eax, eax
  00011	83 7d 14 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  00015	0f 94 c0	 sete	 al
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0001e	83 c4 10	 add	 esp, 16			; 00000010H

; 57   : 
; 58   :     pwfx->wFormatTag = WAVE_FORMAT_PCM;

  00021	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00024	66 c7 01 01 00	 mov	 WORD PTR [ecx], 1

; 59   :     pwfx->nChannels = nChannels;

  00029	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0002c	66 8b 45 08	 mov	 ax, WORD PTR _nChannels$[ebp]
  00030	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 60   :     pwfx->nSamplesPerSec = nSamplesPerSec;

  00034	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00037	8b 55 0c	 mov	 edx, DWORD PTR _nSamplesPerSec$[ebp]
  0003a	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 61   :     pwfx->wBitsPerSample = wBitsPerSample;

  0003d	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00040	66 8b 4d 10	 mov	 cx, WORD PTR _wBitsPerSample$[ebp]
  00044	66 89 48 0e	 mov	 WORD PTR [eax+14], cx

; 62   :     pwfx->nBlockAlign = nChannels * wBitsPerSample / 8;

  00048	8b 45 08	 mov	 eax, DWORD PTR _nChannels$[ebp]
  0004b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00050	8b 55 10	 mov	 edx, DWORD PTR _wBitsPerSample$[ebp]
  00053	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00059	0f af c2	 imul	 eax, edx
  0005c	99		 cdq
  0005d	83 e2 07	 and	 edx, 7
  00060	03 c2		 add	 eax, edx
  00062	c1 f8 03	 sar	 eax, 3
  00065	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00068	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 63   :     pwfx->nAvgBytesPerSec = nSamplesPerSec * pwfx->nBlockAlign;

  0006c	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0006f	33 c0		 xor	 eax, eax
  00071	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  00075	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  00078	0f af c8	 imul	 ecx, eax
  0007b	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0007e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 64   :     pwfx->cbSize = 0;

  00081	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00084	66 c7 40 10 00
	00		 mov	 WORD PTR [eax+16], 0

; 65   : 
; 66   :     DPF_LEAVE_VOID();
; 67   : }

  0008a	5d		 pop	 ebp
  0008b	c2 10 00	 ret	 16			; 00000010H
?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::CreatePcmFormat
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_pwfx$ = 16
?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUima_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::WaveFormat::CreateXboxAdpcmFormat, COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 98   :     DPF_ENTER();
; 99   :     
; 100  :     ASSERT(pwfx);

  00003	6a 64		 push	 100			; 00000064H
  00005	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PBHC@pwfx?$AA@ ; `string'
  0000f	33 c0		 xor	 eax, eax
  00011	83 7d 10 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  00015	0f 94 c0	 sete	 al
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0001e	83 c4 10	 add	 esp, 16			; 00000010H

; 101  : 
; 102  :     pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  00021	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00024	66 c7 01 69 00	 mov	 WORD PTR [ecx], 105	; 00000069H

; 103  :     pwfx->wfx.nChannels = nChannels;

  00029	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0002c	66 8b 45 08	 mov	 ax, WORD PTR _nChannels$[ebp]
  00030	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 104  :     pwfx->wfx.nSamplesPerSec = nSamplesPerSec;

  00034	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00037	8b 55 0c	 mov	 edx, DWORD PTR _nSamplesPerSec$[ebp]
  0003a	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 105  :     pwfx->wfx.wBitsPerSample = XBOX_ADPCM_BITS_PER_SAMPLE;

  0003d	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00040	66 c7 40 0e 04
	00		 mov	 WORD PTR [eax+14], 4

; 106  :     pwfx->wfx.nBlockAlign = nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  00046	8b 4d 08	 mov	 ecx, DWORD PTR _nChannels$[ebp]
  00049	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0004f	6b c9 24	 imul	 ecx, 36			; 00000024H
  00052	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00055	66 89 4a 0c	 mov	 WORD PTR [edx+12], cx

; 107  :     pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec / XBOX_ADPCM_SAMPLES_PER_BLOCK * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  00059	8b 45 0c	 mov	 eax, DWORD PTR _nSamplesPerSec$[ebp]
  0005c	c1 e8 06	 shr	 eax, 6
  0005f	6b c0 24	 imul	 eax, 36			; 00000024H
  00062	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00065	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 108  :     pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);

  00068	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0006b	66 c7 42 10 02
	00		 mov	 WORD PTR [edx+16], 2

; 109  :     pwfx->wSamplesPerBlock = XBOX_ADPCM_SAMPLES_PER_BLOCK;

  00071	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00074	66 c7 40 12 40
	00		 mov	 WORD PTR [eax+18], 64	; 00000040H

; 110  : 
; 111  :     DPF_LEAVE_VOID();
; 112  : }

  0007a	5d		 pop	 ebp
  0007b	c2 0c 00	 ret	 12			; 0000000cH
?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUima_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::WaveFormat::CreateXboxAdpcmFormat
_TEXT	ENDS
PUBLIC	??_C@_05MJPI@pDest?$AA@				; `string'
PUBLIC	??_C@_07JEGE@pSource?$AA@			; `string'
PUBLIC	??_C@_0BG@MOEB@Unexpected?5format?5tag?$AA@	; `string'
PUBLIC	?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::CreateInternalFormat
PUBLIC	?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::PcmToInternalFormat
PUBLIC	?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUima_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::AdpcmToInternalFormat
;	COMDAT ??_C@_05MJPI@pDest?$AA@
CONST	SEGMENT
??_C@_05MJPI@pDest?$AA@ DB 'pDest', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07JEGE@pSource?$AA@
CONST	SEGMENT
??_C@_07JEGE@pSource?$AA@ DB 'pSource', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MOEB@Unexpected?5format?5tag?$AA@
CONST	SEGMENT
??_C@_0BG@MOEB@Unexpected?5format?5tag?$AA@ DB 'Unexpected format tag', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_pDest$ = 8
_pSource$ = 12
_dwChannelMask$ = -4
?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::CreateInternalFormat, COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 142  :     DWORD                   dwChannelMask   = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwChannelMask$[ebp], 0

; 143  :     
; 144  :     DPF_ENTER();
; 145  : 
; 146  :     ASSERT(pDest);

  0000d	68 92 00 00 00	 push	 146			; 00000092H
  00012	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05MJPI@pDest?$AA@ ; `string'
  0001c	33 c0		 xor	 eax, eax
  0001e	83 7d 08 00	 cmp	 DWORD PTR _pDest$[ebp], 0
  00022	0f 94 c0	 sete	 al
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 147  :     ASSERT(pSource);

  0002e	68 93 00 00 00	 push	 147			; 00000093H
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07JEGE@pSource?$AA@ ; `string'
  0003d	33 c9		 xor	 ecx, ecx
  0003f	83 7d 0c 00	 cmp	 DWORD PTR _pSource$[ebp], 0
  00043	0f 94 c1	 sete	 cl
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0004c	83 c4 10	 add	 esp, 16			; 00000010H

; 148  : 
; 149  :     switch(pSource->wFormatTag)
; 150  :     {

  0004f	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00052	33 c0		 xor	 eax, eax
  00054	66 8b 02	 mov	 ax, WORD PTR [edx]
  00057	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  0005a	83 7d f8 01	 cmp	 DWORD PTR -8+[ebp], 1
  0005e	74 08		 je	 SHORT $L50093
  00060	83 7d f8 69	 cmp	 DWORD PTR -8+[ebp], 105	; 00000069H
  00064	74 11		 je	 SHORT $L50094
  00066	eb 1e		 jmp	 SHORT $L50096
$L50093:

; 151  :         case WAVE_FORMAT_PCM:
; 152  :             PcmToInternalFormat(pDest, pSource);

  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  0006b	51		 push	 ecx
  0006c	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 ?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::PcmToInternalFormat

; 153  :             break;

  00075	eb 28		 jmp	 SHORT $L50090
$L50094:

; 154  : 
; 155  :         case WAVE_FORMAT_XBOX_ADPCM:
; 156  :             AdpcmToInternalFormat(pDest, (LPCXBOXADPCMWAVEFORMAT)pSource);

  00077	8b 45 0c	 mov	 eax, DWORD PTR _pSource$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUima_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::AdpcmToInternalFormat

; 157  :             break;

  00084	eb 19		 jmp	 SHORT $L50090
$L50096:

; 158  : 
; 159  : #if defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 160  : 
; 161  :         case WAVE_FORMAT_EXTENSIBLE:
; 162  :             dwChannelMask = ExtensibleToInternalFormat(pDest, (LPCWAVEFORMATEXTENSIBLE)pSource);
; 163  :             break;
; 164  : 
; 165  : #endif // defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 166  : 
; 167  :         default:
; 168  :             ASSERTMSG("Unexpected format tag");

  00086	68 a8 00 00 00	 push	 168			; 000000a8H
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@MOEB@Unexpected?5format?5tag?$AA@ ; `string'
  00095	6a 01		 push	 1
  00097	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0009c	83 c4 10	 add	 esp, 16			; 00000010H
$L50090:

; 169  :             break;
; 170  :     }
; 171  : 
; 172  :     DPF_LEAVE(dwChannelMask);
; 173  : 
; 174  :     return dwChannelMask;

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _dwChannelMask$[ebp]

; 175  : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 08 00	 ret	 8
?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::CreateInternalFormat
_TEXT	ENDS
PUBLIC	??_C@_0BK@NKLB@WaveFormat?3?3IsValidFormat?$AA@	; `string'
PUBLIC	?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::IsValidFormat
;	COMDAT ??_C@_0BK@NKLB@WaveFormat?3?3IsValidFormat?$AA@
CONST	SEGMENT
??_C@_0BK@NKLB@WaveFormat?3?3IsValidFormat?$AA@ DB 'WaveFormat::IsValidFo'
	DB	'rmat', 00H					; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_pwfx$ = 8
_fSuccess$ = -4
?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::IsValidFormat, COMDAT

; 201  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 202  :     BOOL                    fSuccess;
; 203  :     
; 204  :     DPF_ENTER();
; 205  : 
; 206  :     ASSERT(pwfx);

  00006	68 ce 00 00 00	 push	 206			; 000000ceH
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PBHC@pwfx?$AA@ ; `string'
  00015	33 c0		 xor	 eax, eax
  00017	83 7d 08 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  0001b	0f 94 c0	 sete	 al
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 207  : 
; 208  :     switch(pwfx->wFormatTag)
; 209  :     {

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0002a	33 d2		 xor	 edx, edx
  0002c	66 8b 11	 mov	 dx, WORD PTR [ecx]
  0002f	89 55 f8	 mov	 DWORD PTR -8+[ebp], edx
  00032	83 7d f8 01	 cmp	 DWORD PTR -8+[ebp], 1
  00036	74 08		 je	 SHORT $L50106
  00038	83 7d f8 69	 cmp	 DWORD PTR -8+[ebp], 105	; 00000069H
  0003c	74 10		 je	 SHORT $L50107
  0003e	eb 1c		 jmp	 SHORT $L50109
$L50106:

; 210  :         case WAVE_FORMAT_PCM:
; 211  :             fSuccess = IsValidPcmFormat(pwfx);

  00040	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::IsValidPcmFormat
  00049	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 212  :             break;

  0004c	eb 42		 jmp	 SHORT $L50103
$L50107:

; 213  : 
; 214  :         case WAVE_FORMAT_XBOX_ADPCM:
; 215  :             fSuccess = IsValidAdpcmFormat((LPCXBOXADPCMWAVEFORMAT)pwfx);

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::IsValidAdpcmFormat
  00057	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 216  :             break;

  0005a	eb 34		 jmp	 SHORT $L50103
$L50109:

; 217  : 
; 218  : #if defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 219  : 
; 220  :         case WAVE_FORMAT_EXTENSIBLE:
; 221  :             fSuccess = IsValidExtensibleFormat((LPCWAVEFORMATEXTENSIBLE)pwfx);
; 222  :             break;
; 223  : 
; 224  : #endif // defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 225  : 
; 226  :         default:
; 227  :             DPF_ERROR("Unsupported format tag");

  0005c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00061	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@NKLB@WaveFormat?3?3IsValidFormat?$AA@ ; `string'
  00066	68 e3 00 00 00	 push	 227			; 000000e3H
  0006b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00070	6a 01		 push	 1
  00072	6a 09		 push	 9
  00074	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00079	83 c4 18	 add	 esp, 24			; 00000018H
  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@MKMD@Unsupported?5format?5tag?$AA@ ; `string'
  00081	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00086	83 c4 04	 add	 esp, 4

; 228  :             fSuccess = FALSE;

  00089	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0
$L50103:

; 229  :             break;
; 230  :     }
; 231  : 
; 232  :     DPF_LEAVE(fSuccess);
; 233  : 
; 234  :     return fSuccess;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 235  : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::IsValidFormat
_TEXT	ENDS
PUBLIC	??_C@_0BL@OKFK@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@ ; `string'
PUBLIC	??_C@_0CA@GBOE@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@ ; `string'
PUBLIC	??_C@_0BN@GMMP@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@ ; `string'
;	COMDAT ??_C@_0BL@OKFK@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT
??_C@_0BL@OKFK@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@ DB 'pSource->n'
	DB	'Channels <= 0xFF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GBOE@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT
??_C@_0CA@GBOE@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@ DB 'pSour'
	DB	'ce->wBitsPerSample <= 0xFF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GMMP@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT
??_C@_0BN@GMMP@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@ DB 'pSource-'
	DB	'>nBlockAlign <= 0xFF', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_pDest$ = 8
_pSource$ = 12
?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::PcmToInternalFormat, COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 265  :     DPF_ENTER();
; 266  : 
; 267  :     ASSERT(pDest);

  00003	68 0b 01 00 00	 push	 267			; 0000010bH
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05MJPI@pDest?$AA@ ; `string'
  00012	33 c0		 xor	 eax, eax
  00014	83 7d 08 00	 cmp	 DWORD PTR _pDest$[ebp], 0
  00018	0f 94 c0	 sete	 al
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 268  :     ASSERT(pSource);

  00024	68 0c 01 00 00	 push	 268			; 0000010cH
  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07JEGE@pSource?$AA@ ; `string'
  00033	33 c9		 xor	 ecx, ecx
  00035	83 7d 0c 00	 cmp	 DWORD PTR _pSource$[ebp], 0
  00039	0f 94 c1	 sete	 cl
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00042	83 c4 10	 add	 esp, 16			; 00000010H

; 269  : 
; 270  :     ASSERT(pSource->nChannels <= 0xFF);

  00045	68 0e 01 00 00	 push	 270			; 0000010eH
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@OKFK@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@ ; `string'
  00054	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00057	33 c0		 xor	 eax, eax
  00059	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  0005d	33 c9		 xor	 ecx, ecx
  0005f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00064	0f 9f c1	 setg	 cl
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0006d	83 c4 10	 add	 esp, 16			; 00000010H

; 271  :     ASSERT(pSource->wBitsPerSample <= 0xFF);

  00070	68 0f 01 00 00	 push	 271			; 0000010fH
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@GBOE@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@ ; `string'
  0007f	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00082	33 c0		 xor	 eax, eax
  00084	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  00088	33 c9		 xor	 ecx, ecx
  0008a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0008f	0f 9f c1	 setg	 cl
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00098	83 c4 10	 add	 esp, 16			; 00000010H

; 272  :     ASSERT(pSource->nBlockAlign <= 0xFF);

  0009b	68 10 01 00 00	 push	 272			; 00000110H
  000a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@GMMP@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@ ; `string'
  000aa	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  000ad	33 c0		 xor	 eax, eax
  000af	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  000b3	33 c9		 xor	 ecx, ecx
  000b5	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000ba	0f 9f c1	 setg	 cl
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000c3	83 c4 10	 add	 esp, 16			; 00000010H

; 273  : 
; 274  :     pDest->wFormatTag = WAVE_FORMAT_PCM;

  000c6	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  000c9	66 c7 02 01 00	 mov	 WORD PTR [edx], 1

; 275  :     pDest->nChannels = (BYTE)pSource->nChannels;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000d4	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  000d7	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 276  :     pDest->wBitsPerSample = (BYTE)pSource->wBitsPerSample;

  000da	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000e0	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  000e3	88 50 03	 mov	 BYTE PTR [eax+3], dl

; 277  :     pDest->nSamplesPerSec = pSource->nSamplesPerSec;

  000e6	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000e9	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000ec	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ef	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 278  :     pDest->nBlockAlign = (BYTE)pSource->nBlockAlign;

  000f2	8b 45 0c	 mov	 eax, DWORD PTR _pSource$[ebp]
  000f5	33 c9		 xor	 ecx, ecx
  000f7	8a 48 0c	 mov	 cl, BYTE PTR [eax+12]
  000fa	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  000fd	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 279  : 
; 280  :     DPF_LEAVE_VOID();
; 281  : }

  00100	5d		 pop	 ebp
  00101	c2 08 00	 ret	 8
?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::PcmToInternalFormat
_TEXT	ENDS
PUBLIC	??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@ ; `string'
PUBLIC	??_C@_0BD@IKOG@Format?5tag?5not?5PCM?$AA@	; `string'
PUBLIC	??_C@_0BG@DNIK@Invalid?5channel?5count?$AA@	; `string'
PUBLIC	??_C@_0BO@NALA@Invalid?5sample?5bit?5resolution?$AA@ ; `string'
PUBLIC	??_C@_0BG@PDOD@Invalid?5sampling?5rate?$AA@	; `string'
PUBLIC	??_C@_0BE@CHML@Bad?5block?5alignment?$AA@	; `string'
;	COMDAT ??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@
CONST	SEGMENT
??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@ DB 'WaveFormat::IsVali'
	DB	'dPcmFormat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IKOG@Format?5tag?5not?5PCM?$AA@
CONST	SEGMENT
??_C@_0BD@IKOG@Format?5tag?5not?5PCM?$AA@ DB 'Format tag not PCM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DNIK@Invalid?5channel?5count?$AA@
CONST	SEGMENT
??_C@_0BG@DNIK@Invalid?5channel?5count?$AA@ DB 'Invalid channel count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NALA@Invalid?5sample?5bit?5resolution?$AA@
CONST	SEGMENT
??_C@_0BO@NALA@Invalid?5sample?5bit?5resolution?$AA@ DB 'Invalid sample b'
	DB	'it resolution', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PDOD@Invalid?5sampling?5rate?$AA@
CONST	SEGMENT
??_C@_0BG@PDOD@Invalid?5sampling?5rate?$AA@ DB 'Invalid sampling rate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CHML@Bad?5block?5alignment?$AA@
CONST	SEGMENT
??_C@_0BE@CHML@Bad?5block?5alignment?$AA@ DB 'Bad block alignment', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_pwfx$ = 8
_fValid$ = -4
?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::IsValidPcmFormat, COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 308  :     BOOL                    fValid  = TRUE;

  00004	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 1

; 309  : 
; 310  :     DPF_ENTER();
; 311  : 
; 312  :     ASSERT(pwfx);

  0000b	68 38 01 00 00	 push	 312			; 00000138H
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PBHC@pwfx?$AA@ ; `string'
  0001a	33 c0		 xor	 eax, eax
  0001c	83 7d 08 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  00020	0f 94 c0	 sete	 al
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00029	83 c4 10	 add	 esp, 16			; 00000010H

; 313  : 
; 314  :     if(WAVE_FORMAT_PCM != pwfx->wFormatTag)

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0002f	33 d2		 xor	 edx, edx
  00031	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00034	83 fa 01	 cmp	 edx, 1
  00037	74 34		 je	 SHORT $L50125

; 315  :     {
; 316  :         DPF_ERROR("Format tag not PCM");

  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@ ; `string'
  00043	68 3c 01 00 00	 push	 316			; 0000013cH
  00048	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004d	6a 01		 push	 1
  0004f	6a 09		 push	 9
  00051	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00056	83 c4 18	 add	 esp, 24			; 00000018H
  00059	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@IKOG@Format?5tag?5not?5PCM?$AA@ ; `string'
  0005e	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00063	83 c4 04	 add	 esp, 4

; 317  :         fValid = FALSE;

  00066	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L50125:

; 318  :     }
; 319  :     
; 320  :     if((1 != pwfx->nChannels) && (2 != pwfx->nChannels) && (4 != pwfx->nChannels) && (6 != pwfx->nChannels))

  0006d	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00070	33 c9		 xor	 ecx, ecx
  00072	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00076	83 f9 01	 cmp	 ecx, 1
  00079	74 5e		 je	 SHORT $L50128
  0007b	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0007e	33 c0		 xor	 eax, eax
  00080	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00084	83 f8 02	 cmp	 eax, 2
  00087	74 50		 je	 SHORT $L50128
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0008c	33 d2		 xor	 edx, edx
  0008e	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  00092	83 fa 04	 cmp	 edx, 4
  00095	74 42		 je	 SHORT $L50128
  00097	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0009a	33 c9		 xor	 ecx, ecx
  0009c	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  000a0	83 f9 06	 cmp	 ecx, 6
  000a3	74 34		 je	 SHORT $L50128

; 321  :     {
; 322  :         DPF_ERROR("Invalid channel count");

  000a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000aa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@ ; `string'
  000af	68 42 01 00 00	 push	 322			; 00000142H
  000b4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000b9	6a 01		 push	 1
  000bb	6a 09		 push	 9
  000bd	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000c2	83 c4 18	 add	 esp, 24			; 00000018H
  000c5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@DNIK@Invalid?5channel?5count?$AA@ ; `string'
  000ca	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000cf	83 c4 04	 add	 esp, 4

; 323  :         fValid = FALSE;

  000d2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L50128:

; 324  :     }
; 325  : 
; 326  :     if((8 != pwfx->wBitsPerSample) && (16 != pwfx->wBitsPerSample))

  000d9	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  000dc	33 c0		 xor	 eax, eax
  000de	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  000e2	83 f8 08	 cmp	 eax, 8
  000e5	74 42		 je	 SHORT $L50130
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  000ea	33 d2		 xor	 edx, edx
  000ec	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  000f0	83 fa 10	 cmp	 edx, 16			; 00000010H
  000f3	74 34		 je	 SHORT $L50130

; 327  :     {
; 328  :         DPF_ERROR("Invalid sample bit resolution");

  000f5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000fa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@ ; `string'
  000ff	68 48 01 00 00	 push	 328			; 00000148H
  00104	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00109	6a 01		 push	 1
  0010b	6a 09		 push	 9
  0010d	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00112	83 c4 18	 add	 esp, 24			; 00000018H
  00115	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@NALA@Invalid?5sample?5bit?5resolution?$AA@ ; `string'
  0011a	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0011f	83 c4 04	 add	 esp, 4

; 329  :         fValid = FALSE;

  00122	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L50130:

; 330  :     }
; 331  : 
; 332  :     if((pwfx->nSamplesPerSec < DSBFREQUENCY_MIN) || (pwfx->nSamplesPerSec > DSBFREQUENCY_MAX))

  00129	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0012c	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  00130	72 0c		 jb	 SHORT $L50133
  00132	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00135	81 79 04 ff ff
	ff 7f		 cmp	 DWORD PTR [ecx+4], 2147483647 ; 7fffffffH
  0013c	76 34		 jbe	 SHORT $L50132
$L50133:

; 333  :     {
; 334  :         DPF_ERROR("Invalid sampling rate");

  0013e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00143	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@ ; `string'
  00148	68 4e 01 00 00	 push	 334			; 0000014eH
  0014d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00152	6a 01		 push	 1
  00154	6a 09		 push	 9
  00156	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0015b	83 c4 18	 add	 esp, 24			; 00000018H
  0015e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@PDOD@Invalid?5sampling?5rate?$AA@ ; `string'
  00163	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00168	83 c4 04	 add	 esp, 4

; 335  :         fValid = FALSE;

  0016b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L50132:

; 336  :     }
; 337  : 
; 338  :     if(pwfx->nChannels * pwfx->wBitsPerSample / 8 != pwfx->nBlockAlign)

  00172	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00175	33 c0		 xor	 eax, eax
  00177	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  0017b	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0017e	33 d2		 xor	 edx, edx
  00180	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  00184	0f af c2	 imul	 eax, edx
  00187	99		 cdq
  00188	83 e2 07	 and	 edx, 7
  0018b	03 c2		 add	 eax, edx
  0018d	c1 f8 03	 sar	 eax, 3
  00190	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00193	33 d2		 xor	 edx, edx
  00195	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  00199	3b c2		 cmp	 eax, edx
  0019b	74 34		 je	 SHORT $L50135

; 339  :     {
; 340  :         DPF_ERROR("Bad block alignment");

  0019d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  001a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@FIKB@WaveFormat?3?3IsValidPcmFormat?$AA@ ; `string'
  001a7	68 54 01 00 00	 push	 340			; 00000154H
  001ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  001b1	6a 01		 push	 1
  001b3	6a 09		 push	 9
  001b5	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  001ba	83 c4 18	 add	 esp, 24			; 00000018H
  001bd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@CHML@Bad?5block?5alignment?$AA@ ; `string'
  001c2	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001c7	83 c4 04	 add	 esp, 4

; 341  :         fValid = FALSE;

  001ca	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L50135:

; 342  :     }
; 343  : 
; 344  :     DPF_LEAVE(fValid);
; 345  : 
; 346  :     return fValid;

  001d1	8b 45 fc	 mov	 eax, DWORD PTR _fValid$[ebp]

; 347  : }

  001d4	8b e5		 mov	 esp, ebp
  001d6	5d		 pop	 ebp
  001d7	c2 04 00	 ret	 4
?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::IsValidPcmFormat
_TEXT	ENDS
PUBLIC	??_C@_0BP@ILPH@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@ ; `string'
PUBLIC	??_C@_0CE@HOLG@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@ ; `string'
PUBLIC	??_C@_0CB@CADJ@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@ ; `string'
;	COMDAT ??_C@_0BP@ILPH@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@
CONST	SEGMENT
??_C@_0BP@ILPH@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@ DB 'pSour'
	DB	'ce->wfx.nChannels <= 0xFF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HOLG@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@
CONST	SEGMENT
??_C@_0CE@HOLG@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@ DB 'pSource'
	DB	'->wfx.wBitsPerSample <= 0xFF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CADJ@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@
CONST	SEGMENT
??_C@_0CB@CADJ@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@ DB 'pSource'
	DB	'->wfx.nBlockAlign <= 0xFF', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT
_pDest$ = 8
_pSource$ = 12
?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUima_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::WaveFormat::AdpcmToInternalFormat, COMDAT

; 376  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 377  :     static const BYTE       wBitsPerSample      = 4;
; 378  : 
; 379  :     DPF_ENTER();
; 380  : 
; 381  :     ASSERT(pDest);

  00003	68 7d 01 00 00	 push	 381			; 0000017dH
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05MJPI@pDest?$AA@ ; `string'
  00012	33 c0		 xor	 eax, eax
  00014	83 7d 08 00	 cmp	 DWORD PTR _pDest$[ebp], 0
  00018	0f 94 c0	 sete	 al
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 382  :     ASSERT(pSource);

  00024	68 7e 01 00 00	 push	 382			; 0000017eH
  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07JEGE@pSource?$AA@ ; `string'
  00033	33 c9		 xor	 ecx, ecx
  00035	83 7d 0c 00	 cmp	 DWORD PTR _pSource$[ebp], 0
  00039	0f 94 c1	 sete	 cl
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00042	83 c4 10	 add	 esp, 16			; 00000010H

; 383  : 
; 384  :     ASSERT(pSource->wfx.nChannels <= 0xFF);

  00045	68 80 01 00 00	 push	 384			; 00000180H
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@ILPH@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@ ; `string'
  00054	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00057	33 c0		 xor	 eax, eax
  00059	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  0005d	33 c9		 xor	 ecx, ecx
  0005f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00064	0f 9f c1	 setg	 cl
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0006d	83 c4 10	 add	 esp, 16			; 00000010H

; 385  :     ASSERT(pSource->wfx.wBitsPerSample <= 0xFF);

  00070	68 81 01 00 00	 push	 385			; 00000181H
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@HOLG@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@ ; `string'
  0007f	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00082	33 c0		 xor	 eax, eax
  00084	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  00088	33 c9		 xor	 ecx, ecx
  0008a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0008f	0f 9f c1	 setg	 cl
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00098	83 c4 10	 add	 esp, 16			; 00000010H

; 386  :     ASSERT(pSource->wfx.nBlockAlign <= 0xFF);

  0009b	68 82 01 00 00	 push	 386			; 00000182H
  000a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@CADJ@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@ ; `string'
  000aa	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  000ad	33 c0		 xor	 eax, eax
  000af	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  000b3	33 c9		 xor	 ecx, ecx
  000b5	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000ba	0f 9f c1	 setg	 cl
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000c3	83 c4 10	 add	 esp, 16			; 00000010H

; 387  : 
; 388  :     pDest->wFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  000c6	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  000c9	66 c7 02 69 00	 mov	 WORD PTR [edx], 105	; 00000069H

; 389  :     pDest->nChannels = (BYTE)pSource->wfx.nChannels;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000d4	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  000d7	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 390  :     pDest->wBitsPerSample = (BYTE)wBitsPerSample;

  000da	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000dd	c6 40 03 04	 mov	 BYTE PTR [eax+3], 4

; 391  :     pDest->nSamplesPerSec = pSource->wfx.nSamplesPerSec;

  000e1	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  000e4	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  000e7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ea	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 392  :     pDest->nBlockAlign = (BYTE)pSource->wfx.nBlockAlign;

  000ed	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000f0	33 d2		 xor	 edx, edx
  000f2	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  000f5	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000f8	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 393  : 
; 394  :     DPF_LEAVE_VOID();
; 395  : }

  000fb	5d		 pop	 ebp
  000fc	c2 08 00	 ret	 8
?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUima_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::WaveFormat::AdpcmToInternalFormat
_TEXT	ENDS
PUBLIC	??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
PUBLIC	??_C@_0BK@OFFM@Format?5tag?5not?5XBOX_ADPCM?$AA@ ; `string'
PUBLIC	??_C@_0P@DKJO@cbSize?5not?5?$CFlu?$AA@		; `string'
PUBLIC	??_C@_0BK@GLJN@Invalid?5samples?5per?5block?$AA@ ; `string'
PUBLIC	??_C@_0BE@OJBC@Bad?5block?9alignment?$AA@	; `string'
;	COMDAT ??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@
CONST	SEGMENT
??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ DB 'WaveFormat::IsVa'
	DB	'lidAdpcmFormat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OFFM@Format?5tag?5not?5XBOX_ADPCM?$AA@
CONST	SEGMENT
??_C@_0BK@OFFM@Format?5tag?5not?5XBOX_ADPCM?$AA@ DB 'Format tag not XBOX_'
	DB	'ADPCM', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DKJO@cbSize?5not?5?$CFlu?$AA@
CONST	SEGMENT
??_C@_0P@DKJO@cbSize?5not?5?$CFlu?$AA@ DB 'cbSize not %lu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GLJN@Invalid?5samples?5per?5block?$AA@
CONST	SEGMENT
??_C@_0BK@GLJN@Invalid?5samples?5per?5block?$AA@ DB 'Invalid samples per '
	DB	'block', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OJBC@Bad?5block?9alignment?$AA@
CONST	SEGMENT
??_C@_0BE@OJBC@Bad?5block?9alignment?$AA@ DB 'Bad block-alignment', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT
_pwfx$ = 8
_fValid$ = -4
?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::WaveFormat::IsValidAdpcmFormat, COMDAT

; 421  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 422  :     static const WORD       wSamplesPerBlock    = 64;
; 423  :     static const WORD       wBitsPerSample      = 4;
; 424  :     static const WORD       wBytesPerBlock      = 36;
; 425  :     BOOL                    fValid              = TRUE;

  00004	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 1

; 426  : 
; 427  :     DPF_ENTER();
; 428  : 
; 429  :     ASSERT(pwfx);

  0000b	68 ad 01 00 00	 push	 429			; 000001adH
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PBHC@pwfx?$AA@ ; `string'
  0001a	33 c0		 xor	 eax, eax
  0001c	83 7d 08 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  00020	0f 94 c0	 sete	 al
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00029	83 c4 10	 add	 esp, 16			; 00000010H

; 430  : 
; 431  :     if(WAVE_FORMAT_XBOX_ADPCM != pwfx->wfx.wFormatTag)

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0002f	33 d2		 xor	 edx, edx
  00031	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00034	83 fa 69	 cmp	 edx, 105		; 00000069H
  00037	74 34		 je	 SHORT $L50159

; 432  :     {
; 433  :         DPF_ERROR("Format tag not XBOX_ADPCM");

  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
  00043	68 b1 01 00 00	 push	 433			; 000001b1H
  00048	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004d	6a 01		 push	 1
  0004f	6a 09		 push	 9
  00051	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00056	83 c4 18	 add	 esp, 24			; 00000018H
  00059	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@OFFM@Format?5tag?5not?5XBOX_ADPCM?$AA@ ; `string'
  0005e	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00063	83 c4 04	 add	 esp, 4

; 434  :         fValid = FALSE;

  00066	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L50159:

; 435  :     }
; 436  :     
; 437  :     if(sizeof(*pwfx) - sizeof(pwfx->wfx) != pwfx->wfx.cbSize)

  0006d	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00070	33 c9		 xor	 ecx, ecx
  00072	66 8b 48 10	 mov	 cx, WORD PTR [eax+16]
  00076	83 f9 02	 cmp	 ecx, 2
  00079	74 36		 je	 SHORT $L50162

; 438  :     {
; 439  :         DPF_ERROR("cbSize not %lu", sizeof(*pwfx) - sizeof(pwfx->wfx));

  0007b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00080	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
  00085	68 b7 01 00 00	 push	 439			; 000001b7H
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0008f	6a 01		 push	 1
  00091	6a 09		 push	 9
  00093	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00098	83 c4 18	 add	 esp, 24			; 00000018H
  0009b	6a 02		 push	 2
  0009d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@DKJO@cbSize?5not?5?$CFlu?$AA@ ; `string'
  000a2	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000a7	83 c4 08	 add	 esp, 8

; 440  :         fValid = FALSE;

  000aa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L50162:

; 441  :     }
; 442  :     
; 443  :     if((pwfx->wfx.nChannels < 1) || (pwfx->wfx.nChannels > 2))

  000b1	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  000b4	33 c0		 xor	 eax, eax
  000b6	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  000ba	83 f8 01	 cmp	 eax, 1
  000bd	7c 0e		 jl	 SHORT $L50165
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  000c2	33 d2		 xor	 edx, edx
  000c4	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  000c8	83 fa 02	 cmp	 edx, 2
  000cb	7e 34		 jle	 SHORT $L50164
$L50165:

; 444  :     {
; 445  :         DPF_ERROR("Invalid channel count");

  000cd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000d2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
  000d7	68 bd 01 00 00	 push	 445			; 000001bdH
  000dc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000e1	6a 01		 push	 1
  000e3	6a 09		 push	 9
  000e5	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000ea	83 c4 18	 add	 esp, 24			; 00000018H
  000ed	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@DNIK@Invalid?5channel?5count?$AA@ ; `string'
  000f2	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000f7	83 c4 04	 add	 esp, 4

; 446  :         fValid = FALSE;

  000fa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L50164:

; 447  :     }
; 448  : 
; 449  :     if((pwfx->wfx.nSamplesPerSec < DSBFREQUENCY_MIN) || (pwfx->wfx.nSamplesPerSec > DSBFREQUENCY_MAX))

  00101	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00104	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  00108	72 0c		 jb	 SHORT $L50167
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0010d	81 79 04 ff ff
	ff 7f		 cmp	 DWORD PTR [ecx+4], 2147483647 ; 7fffffffH
  00114	76 34		 jbe	 SHORT $L50166
$L50167:

; 450  :     {
; 451  :         DPF_ERROR("Invalid sampling rate");

  00116	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0011b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
  00120	68 c3 01 00 00	 push	 451			; 000001c3H
  00125	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0012a	6a 01		 push	 1
  0012c	6a 09		 push	 9
  0012e	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00133	83 c4 18	 add	 esp, 24			; 00000018H
  00136	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@PDOD@Invalid?5sampling?5rate?$AA@ ; `string'
  0013b	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00140	83 c4 04	 add	 esp, 4

; 452  :         fValid = FALSE;

  00143	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L50166:

; 453  :     }
; 454  : 
; 455  :     if(wBitsPerSample != pwfx->wfx.wBitsPerSample)

  0014a	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0014d	33 c0		 xor	 eax, eax
  0014f	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  00153	83 f8 04	 cmp	 eax, 4
  00156	74 34		 je	 SHORT $L50168

; 456  :     {
; 457  :         DPF_ERROR("Invalid sample bit resolution");

  00158	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0015d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
  00162	68 c9 01 00 00	 push	 457			; 000001c9H
  00167	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0016c	6a 01		 push	 1
  0016e	6a 09		 push	 9
  00170	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00175	83 c4 18	 add	 esp, 24			; 00000018H
  00178	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@NALA@Invalid?5sample?5bit?5resolution?$AA@ ; `string'
  0017d	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00182	83 c4 04	 add	 esp, 4

; 458  :         fValid = FALSE;

  00185	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L50168:

; 459  :     }
; 460  : 
; 461  :     if(wSamplesPerBlock != pwfx->wSamplesPerBlock)

  0018c	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0018f	33 d2		 xor	 edx, edx
  00191	66 8b 51 12	 mov	 dx, WORD PTR [ecx+18]
  00195	83 fa 40	 cmp	 edx, 64			; 00000040H
  00198	74 34		 je	 SHORT $L50169

; 462  :     {
; 463  :         DPF_ERROR("Invalid samples per block");

  0019a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0019f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
  001a4	68 cf 01 00 00	 push	 463			; 000001cfH
  001a9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  001ae	6a 01		 push	 1
  001b0	6a 09		 push	 9
  001b2	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  001b7	83 c4 18	 add	 esp, 24			; 00000018H
  001ba	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@GLJN@Invalid?5samples?5per?5block?$AA@ ; `string'
  001bf	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001c4	83 c4 04	 add	 esp, 4

; 464  :         fValid = FALSE;

  001c7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L50169:

; 465  :     }
; 466  : 
; 467  :     if(wBytesPerBlock * pwfx->wfx.nChannels != pwfx->wfx.nBlockAlign)

  001ce	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  001d1	33 c9		 xor	 ecx, ecx
  001d3	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  001d7	6b c9 24	 imul	 ecx, 36			; 00000024H
  001da	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  001dd	33 c0		 xor	 eax, eax
  001df	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  001e3	3b c8		 cmp	 ecx, eax
  001e5	74 34		 je	 SHORT $L50171

; 468  :     {
; 469  :         DPF_ERROR("Bad block-alignment");

  001e7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  001ec	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFDK@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
  001f1	68 d5 01 00 00	 push	 469			; 000001d5H
  001f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@OKKE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  001fb	6a 01		 push	 1
  001fd	6a 09		 push	 9
  001ff	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00204	83 c4 18	 add	 esp, 24			; 00000018H
  00207	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OJBC@Bad?5block?9alignment?$AA@ ; `string'
  0020c	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00211	83 c4 04	 add	 esp, 4

; 470  :         fValid = FALSE;

  00214	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L50171:

; 471  :     }
; 472  : 
; 473  :     DPF_LEAVE(fValid);
; 474  : 
; 475  :     return fValid;

  0021b	8b 45 fc	 mov	 eax, DWORD PTR _fValid$[ebp]

; 476  : }

  0021e	8b e5		 mov	 esp, ebp
  00220	5d		 pop	 ebp
  00221	c2 04 00	 ret	 4
?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUima_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::WaveFormat::IsValidAdpcmFormat
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\waveldr.cpp
_TEXT	ENDS
;	COMDAT ??0CStdFileStream@WaveLoader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CStdFileStream@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CStdFileStream::CStdFileStream, COMDAT
; _this$ = ecx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 102  :     DPF_ENTER();
; 103  : 
; 104  :     //
; 105  :     // Initialize defaults
; 106  :     //
; 107  : 
; 108  :     m_hFile = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 109  :     m_dwFlags = 0;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 110  : 
; 111  :     DPF_LEAVE_VOID();
; 112  : }

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0CStdFileStream@WaveLoader@@QAE@XZ ENDP		; WaveLoader::CStdFileStream::CStdFileStream
_TEXT	ENDS
PUBLIC	?Close@CStdFileStream@WaveLoader@@QAEXXZ	; WaveLoader::CStdFileStream::Close
; Function compile flags: /Odt
;	COMDAT ??1CStdFileStream@WaveLoader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CStdFileStream@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CStdFileStream::~CStdFileStream, COMDAT
; _this$ = ecx

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 138  :     DPF_ENTER();
; 139  : 
; 140  :     Close();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Close@CStdFileStream@WaveLoader@@QAEXXZ ; WaveLoader::CStdFileStream::Close

; 141  : 
; 142  :     DPF_LEAVE_VOID();
; 143  : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CStdFileStream@WaveLoader@@QAE@XZ ENDP		; WaveLoader::CStdFileStream::~CStdFileStream
_TEXT	ENDS
PUBLIC	??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CA@LGGN@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BF@EAAG@CStdFileStream?3?3Open?$AA@	; `string'
PUBLIC	??_C@_0CF@CAJD@Error?5?$CFlu?5occurred?5trying?5to?5ope@ ; `string'
EXTRN	__imp__CreateFileA@28:NEAR
;	COMDAT ??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\privat'
	DB	'e\windows\directx\dsound\common\waveldr.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LGGN@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
CONST	SEGMENT
??_C@_0CA@LGGN@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ DB '!IS_VALI'
	DB	'D_HANDLE_VALUE(m_hFile)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EAAG@CStdFileStream?3?3Open?$AA@
CONST	SEGMENT
??_C@_0BF@EAAG@CStdFileStream?3?3Open?$AA@ DB 'CStdFileStream::Open', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CAJD@Error?5?$CFlu?5occurred?5trying?5to?5ope@
CONST	SEGMENT
??_C@_0CF@CAJD@Error?5?$CFlu?5occurred?5trying?5to?5ope@ DB 'Error %lu oc'
	DB	'curred trying to open %s', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z
_TEXT	SEGMENT
_pszFileName$ = 8
_dwDesiredAccess$ = 12
_dwShareMode$ = 16
_dwCreationDisposition$ = 20
_dwFlagsAndAttributes$ = 24
_this$ = -8
_hr$ = -4
?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z PROC NEAR ; WaveLoader::CStdFileStream::Open, COMDAT
; _this$ = ecx

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 178  :     HRESULT                 hr  = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 179  : 
; 180  :     DPF_ENTER();
; 181  : 
; 182  :     ASSERT(!IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L51755
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L51755
  00020	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
  00027	eb 07		 jmp	 SHORT $L51756
$L51755:
  00029	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L51756:
  00030	68 b6 00 00 00	 push	 182			; 000000b6H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@LGGN@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
  0003f	8b 55 f4	 mov	 edx, DWORD PTR -12+[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 183  :     
; 184  :     m_hFile = CreateFile(pszFileName, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);

  0004b	6a 00		 push	 0
  0004d	8b 45 18	 mov	 eax, DWORD PTR _dwFlagsAndAttributes$[ebp]
  00050	50		 push	 eax
  00051	8b 4d 14	 mov	 ecx, DWORD PTR _dwCreationDisposition$[ebp]
  00054	51		 push	 ecx
  00055	6a 00		 push	 0
  00057	8b 55 10	 mov	 edx, DWORD PTR _dwShareMode$[ebp]
  0005a	52		 push	 edx
  0005b	8b 45 0c	 mov	 eax, DWORD PTR _dwDesiredAccess$[ebp]
  0005e	50		 push	 eax
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _pszFileName$[ebp]
  00062	51		 push	 ecx
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00069	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	89 02		 mov	 DWORD PTR [edx], eax

; 185  : 
; 186  :     if(INVALID_HANDLE_VALUE == m_hFile)

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00071	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00074	75 09		 jne	 SHORT $L50202

; 187  :     {
; 188  :         m_hFile = NULL;

  00076	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L50202:

; 189  :     }
; 190  : 
; 191  :     if(!m_hFile)

  0007f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00082	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00085	75 3f		 jne	 SHORT $L50203

; 192  :     {
; 193  :         DPF_ERROR("Error %lu occurred trying to open %s", GetLastError(), pszFileName);

  00087	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0008c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@EAAG@CStdFileStream?3?3Open?$AA@ ; `string'
  00091	68 c1 00 00 00	 push	 193			; 000000c1H
  00096	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0009b	6a 04		 push	 4
  0009d	6a 09		 push	 9
  0009f	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000a4	83 c4 18	 add	 esp, 24			; 00000018H
  000a7	8b 45 08	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  000aa	50		 push	 eax
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000b1	50		 push	 eax
  000b2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@CAJD@Error?5?$CFlu?5occurred?5trying?5to?5ope@ ; `string'
  000b7	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 194  :         hr = E_FAIL;

  000bf	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50203:

; 195  :     }
; 196  : 
; 197  :     DPF_LEAVE_HRESULT(hr);
; 198  : 
; 199  :     return hr;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 200  : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 14 00	 ret	 20			; 00000014H
?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z ENDP	; WaveLoader::CStdFileStream::Open
_TEXT	ENDS
PUBLIC	?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z	; WaveLoader::CStdFileStream::Attach
; Function compile flags: /Odt
;	COMDAT ?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z
_TEXT	SEGMENT
_hFile$ = 8
_this$ = -4
?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z PROC NEAR	; WaveLoader::CStdFileStream::Attach, COMDAT
; _this$ = ecx

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 227  :     DPF_ENTER();
; 228  : 
; 229  :     ASSERT(!IS_VALID_HANDLE_VALUE(m_hFile));

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 11		 je	 SHORT $L51760
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  00017	74 09		 je	 SHORT $L51760
  00019	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00020	eb 07		 jmp	 SHORT $L51761
$L51760:
  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L51761:
  00029	68 e5 00 00 00	 push	 229			; 000000e5H
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@LGGN@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
  00038	8b 55 f8	 mov	 edx, DWORD PTR -8+[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00041	83 c4 10	 add	 esp, 16			; 00000010H

; 230  :     
; 231  :     m_hFile = hFile;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _hFile$[ebp]
  0004a	89 08		 mov	 DWORD PTR [eax], ecx

; 232  :     m_dwFlags |= FILESTREAM_FLAGS_ATTACHED;

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00052	0c 01		 or	 al, 1
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 233  : 
; 234  :     DPF_LEAVE_VOID();
; 235  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z ENDP	; WaveLoader::CStdFileStream::Attach
_TEXT	ENDS
EXTRN	__imp__CloseHandle@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Close@CStdFileStream@WaveLoader@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Close@CStdFileStream@WaveLoader@@QAEXXZ PROC NEAR	; WaveLoader::CStdFileStream::Close, COMDAT
; _this$ = ecx

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 262  :     DPF_ENTER();
; 263  :     
; 264  :     if(m_dwFlags & FILESTREAM_FLAGS_ATTACHED)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	83 e1 01	 and	 ecx, 1
  00010	85 c9		 test	 ecx, ecx
  00012	74 1a		 je	 SHORT $L50216

; 265  :     {
; 266  :         m_hFile = NULL;

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 267  :         m_dwFlags &= ~FILESTREAM_FLAGS_ATTACHED;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00023	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 268  :     }
; 269  :     else

  0002c	eb 25		 jmp	 SHORT $L50217
$L50216:

; 270  :     {
; 271  :         CLOSE_HANDLE(m_hFile);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 38 00	 cmp	 DWORD PTR [eax], 0
  00034	74 1d		 je	 SHORT $L50219
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0003c	74 15		 je	 SHORT $L50219
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 02		 mov	 eax, DWORD PTR [edx]
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L50219:
$L50217:

; 272  :     }
; 273  : 
; 274  :     DPF_LEAVE_VOID();
; 275  : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?Close@CStdFileStream@WaveLoader@@QAEXXZ ENDP		; WaveLoader::CStdFileStream::Close
_TEXT	ENDS
PUBLIC	??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BF@OPLH@CStdFileStream?3?3Read?$AA@	; `string'
PUBLIC	??_C@_0CJ@DHDM@Error?5?$CFlu?5occurred?5reading?5from?5@ ; `string'
PUBLIC	??_C@_0CH@ONHL@Not?5enough?5data?5was?5read?5from?5th@ ; `string'
EXTRN	__imp__ReadFile@20:NEAR
;	COMDAT ??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ DB 'IS_VALID_HAN'
	DB	'DLE_VALUE(m_hFile)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OPLH@CStdFileStream?3?3Read?$AA@
CONST	SEGMENT
??_C@_0BF@OPLH@CStdFileStream?3?3Read?$AA@ DB 'CStdFileStream::Read', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DHDM@Error?5?$CFlu?5occurred?5reading?5from?5@
CONST	SEGMENT
??_C@_0CJ@DHDM@Error?5?$CFlu?5occurred?5reading?5from?5@ DB 'Error %lu oc'
	DB	'curred reading from the file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@ONHL@Not?5enough?5data?5was?5read?5from?5th@
CONST	SEGMENT
??_C@_0CH@ONHL@Not?5enough?5data?5was?5read?5from?5th@ DB 'Not enough dat'
	DB	'a was read from the file', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
_dwBufferSize$ = 12
_pdwRead$ = 16
_this$ = -12
_hr$ = -8
_dwRead$ = -4
?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z PROC NEAR ; WaveLoader::CStdFileStream::Read, COMDAT
; _this$ = ecx

; 305  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 306  :     HRESULT                 hr      = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 307  :     DWORD                   dwRead;
; 308  : 
; 309  :     DPF_ENTER();
; 310  :     
; 311  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L51768
  00018	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L51768
  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], 0
  00027	eb 07		 jmp	 SHORT $L51769
$L51768:
  00029	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR -16+[ebp], 1
$L51769:
  00030	68 37 01 00 00	 push	 311			; 00000137H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
  0003f	8b 55 f0	 mov	 edx, DWORD PTR -16+[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 312  :     
; 313  :     if(!ReadFile(m_hFile, pvBuffer, dwBufferSize, &dwRead, NULL))

  0004b	6a 00		 push	 0
  0004d	8d 45 fc	 lea	 eax, DWORD PTR _dwRead$[ebp]
  00050	50		 push	 eax
  00051	8b 4d 0c	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00058	52		 push	 edx
  00059	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	51		 push	 ecx
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  00065	85 c0		 test	 eax, eax
  00067	75 3b		 jne	 SHORT $L50231

; 314  :     {
; 315  :         DPF_ERROR("Error %lu occurred reading from the file", GetLastError());

  00069	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@OPLH@CStdFileStream?3?3Read?$AA@ ; `string'
  00073	68 3b 01 00 00	 push	 315			; 0000013bH
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0007d	6a 04		 push	 4
  0007f	6a 09		 push	 9
  00081	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00086	83 c4 18	 add	 esp, 24			; 00000018H
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0008f	50		 push	 eax
  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@DHDM@Error?5?$CFlu?5occurred?5reading?5from?5@ ; `string'
  00095	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0009a	83 c4 08	 add	 esp, 8

; 316  :         hr = E_FAIL;

  0009d	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50231:

; 317  :     }
; 318  : 
; 319  :     if(SUCCEEDED(hr))

  000a4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a8	7c 4c		 jl	 SHORT $L50236

; 320  :     {
; 321  :         if(pdwRead)

  000aa	83 7d 10 00	 cmp	 DWORD PTR _pdwRead$[ebp], 0
  000ae	74 0a		 je	 SHORT $L50237

; 322  :         {
; 323  :             *pdwRead = dwRead;

  000b0	8b 55 10	 mov	 edx, DWORD PTR _pdwRead$[ebp]
  000b3	8b 45 fc	 mov	 eax, DWORD PTR _dwRead$[ebp]
  000b6	89 02		 mov	 DWORD PTR [edx], eax

; 324  :         }
; 325  :         else if(dwRead != dwBufferSize)

  000b8	eb 3c		 jmp	 SHORT $L50238
$L50237:
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _dwRead$[ebp]
  000bd	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwBufferSize$[ebp]
  000c0	74 34		 je	 SHORT $L50239

; 326  :         {
; 327  :             DPF_ERROR("Not enough data was read from the file");

  000c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@OPLH@CStdFileStream?3?3Read?$AA@ ; `string'
  000cc	68 47 01 00 00	 push	 327			; 00000147H
  000d1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000d6	6a 04		 push	 4
  000d8	6a 09		 push	 9
  000da	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000df	83 c4 18	 add	 esp, 24			; 00000018H
  000e2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@ONHL@Not?5enough?5data?5was?5read?5from?5th@ ; `string'
  000e7	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000ec	83 c4 04	 add	 esp, 4

; 328  :             hr = E_FAIL;

  000ef	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50239:
$L50238:
$L50236:

; 329  :         }
; 330  :     }
; 331  : 
; 332  :     DPF_LEAVE_HRESULT(hr);
; 333  : 
; 334  :     return hr;

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 335  : }

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 0c 00	 ret	 12			; 0000000cH
?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z ENDP	; WaveLoader::CStdFileStream::Read
_TEXT	ENDS
PUBLIC	??_C@_0BG@LBDH@CStdFileStream?3?3Write?$AA@	; `string'
PUBLIC	??_C@_0CH@MCKM@Error?5?$CFlu?5occurred?5writing?5to?5th@ ; `string'
PUBLIC	??_C@_0CK@MMCK@Not?5enough?5data?5was?5written?5from@ ; `string'
EXTRN	__imp__WriteFile@20:NEAR
;	COMDAT ??_C@_0BG@LBDH@CStdFileStream?3?3Write?$AA@
CONST	SEGMENT
??_C@_0BG@LBDH@CStdFileStream?3?3Write?$AA@ DB 'CStdFileStream::Write', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MCKM@Error?5?$CFlu?5occurred?5writing?5to?5th@
CONST	SEGMENT
??_C@_0CH@MCKM@Error?5?$CFlu?5occurred?5writing?5to?5th@ DB 'Error %lu oc'
	DB	'curred writing to the file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MMCK@Not?5enough?5data?5was?5written?5from@
CONST	SEGMENT
??_C@_0CK@MMCK@Not?5enough?5data?5was?5written?5from@ DB 'Not enough data'
	DB	' was written from the file', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z
_TEXT	SEGMENT
_pvBuffer$ = 8
_dwBufferSize$ = 12
_pdwWritten$ = 16
_this$ = -12
_hr$ = -8
_dwWritten$ = -4
?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z PROC NEAR ; WaveLoader::CStdFileStream::Write, COMDAT
; _this$ = ecx

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 366  :     HRESULT                 hr          = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 367  :     DWORD                   dwWritten;
; 368  : 
; 369  :     DPF_ENTER();
; 370  :     
; 371  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L51773
  00018	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L51773
  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], 0
  00027	eb 07		 jmp	 SHORT $L51774
$L51773:
  00029	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR -16+[ebp], 1
$L51774:
  00030	68 73 01 00 00	 push	 371			; 00000173H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
  0003f	8b 55 f0	 mov	 edx, DWORD PTR -16+[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 372  :     
; 373  :     if(!WriteFile(m_hFile, pvBuffer, dwBufferSize, &dwWritten, NULL))

  0004b	6a 00		 push	 0
  0004d	8d 45 fc	 lea	 eax, DWORD PTR _dwWritten$[ebp]
  00050	50		 push	 eax
  00051	8b 4d 0c	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00058	52		 push	 edx
  00059	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	51		 push	 ecx
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00065	85 c0		 test	 eax, eax
  00067	75 3b		 jne	 SHORT $L50252

; 374  :     {
; 375  :         DPF_ERROR("Error %lu occurred writing to the file", GetLastError());

  00069	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@LBDH@CStdFileStream?3?3Write?$AA@ ; `string'
  00073	68 77 01 00 00	 push	 375			; 00000177H
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0007d	6a 04		 push	 4
  0007f	6a 09		 push	 9
  00081	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00086	83 c4 18	 add	 esp, 24			; 00000018H
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0008f	50		 push	 eax
  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@MCKM@Error?5?$CFlu?5occurred?5writing?5to?5th@ ; `string'
  00095	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0009a	83 c4 08	 add	 esp, 8

; 376  :         hr = E_FAIL;

  0009d	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50252:

; 377  :     }
; 378  : 
; 379  :     if(SUCCEEDED(hr))

  000a4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a8	7c 4c		 jl	 SHORT $L50257

; 380  :     {
; 381  :         if(pdwWritten)

  000aa	83 7d 10 00	 cmp	 DWORD PTR _pdwWritten$[ebp], 0
  000ae	74 0a		 je	 SHORT $L50258

; 382  :         {
; 383  :             *pdwWritten = dwWritten;

  000b0	8b 55 10	 mov	 edx, DWORD PTR _pdwWritten$[ebp]
  000b3	8b 45 fc	 mov	 eax, DWORD PTR _dwWritten$[ebp]
  000b6	89 02		 mov	 DWORD PTR [edx], eax

; 384  :         }
; 385  :         else if(dwWritten != dwBufferSize)

  000b8	eb 3c		 jmp	 SHORT $L50259
$L50258:
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _dwWritten$[ebp]
  000bd	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwBufferSize$[ebp]
  000c0	74 34		 je	 SHORT $L50260

; 386  :         {
; 387  :             DPF_ERROR("Not enough data was written from the file");

  000c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@LBDH@CStdFileStream?3?3Write?$AA@ ; `string'
  000cc	68 83 01 00 00	 push	 387			; 00000183H
  000d1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000d6	6a 04		 push	 4
  000d8	6a 09		 push	 9
  000da	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000df	83 c4 18	 add	 esp, 24			; 00000018H
  000e2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@MMCK@Not?5enough?5data?5was?5written?5from@ ; `string'
  000e7	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000ec	83 c4 04	 add	 esp, 4

; 388  :             hr = E_FAIL;

  000ef	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50260:
$L50259:
$L50257:

; 389  :         }
; 390  :     }
; 391  : 
; 392  :     DPF_LEAVE_HRESULT(hr);
; 393  : 
; 394  :     return hr;

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 395  : }

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 0c 00	 ret	 12			; 0000000cH
?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z ENDP	; WaveLoader::CStdFileStream::Write
_TEXT	ENDS
PUBLIC	??_C@_0BF@JBBC@CStdFileStream?3?3Seek?$AA@	; `string'
PUBLIC	??_C@_0CE@PFDI@Error?5?$CFlu?5occurred?5seeking?5the?5f@ ; `string'
EXTRN	__imp__SetFilePointer@16:NEAR
;	COMDAT ??_C@_0BF@JBBC@CStdFileStream?3?3Seek?$AA@
CONST	SEGMENT
??_C@_0BF@JBBC@CStdFileStream?3?3Seek?$AA@ DB 'CStdFileStream::Seek', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PFDI@Error?5?$CFlu?5occurred?5seeking?5the?5f@
CONST	SEGMENT
??_C@_0CE@PFDI@Error?5?$CFlu?5occurred?5seeking?5the?5f@ DB 'Error %lu oc'
	DB	'curred seeking the file', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z
_TEXT	SEGMENT
_lOffset$ = 8
_dwOrigin$ = 12
_pdwAbsolute$ = 16
_this$ = -12
_hr$ = -8
_dwAbsolute$ = -4
?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z PROC NEAR	; WaveLoader::CStdFileStream::Seek, COMDAT
; _this$ = ecx

; 425  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 426  :     HRESULT                 hr          = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 427  :     DWORD                   dwAbsolute;
; 428  :     
; 429  :     DPF_ENTER();
; 430  : 
; 431  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L51778
  00018	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L51778
  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], 0
  00027	eb 07		 jmp	 SHORT $L51779
$L51778:
  00029	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR -16+[ebp], 1
$L51779:
  00030	68 af 01 00 00	 push	 431			; 000001afH
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
  0003f	8b 55 f0	 mov	 edx, DWORD PTR -16+[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 432  :     
; 433  :     if((dwAbsolute = SetFilePointer(m_hFile, lOffset, NULL, dwOrigin)) == INVALID_SET_FILE_POINTER)

  0004b	8b 45 0c	 mov	 eax, DWORD PTR _dwOrigin$[ebp]
  0004e	50		 push	 eax
  0004f	6a 00		 push	 0
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _lOffset$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00058	8b 02		 mov	 eax, DWORD PTR [edx]
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16
  00061	89 45 fc	 mov	 DWORD PTR _dwAbsolute$[ebp], eax
  00064	83 7d fc ff	 cmp	 DWORD PTR _dwAbsolute$[ebp], -1
  00068	75 3b		 jne	 SHORT $L50274

; 434  :     {
; 435  :         DPF_ERROR("Error %lu occurred seeking the file", GetLastError());

  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0006f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@JBBC@CStdFileStream?3?3Seek?$AA@ ; `string'
  00074	68 b3 01 00 00	 push	 435			; 000001b3H
  00079	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0007e	6a 04		 push	 4
  00080	6a 09		 push	 9
  00082	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00087	83 c4 18	 add	 esp, 24			; 00000018H
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00090	50		 push	 eax
  00091	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@PFDI@Error?5?$CFlu?5occurred?5seeking?5the?5f@ ; `string'
  00096	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0009b	83 c4 08	 add	 esp, 8

; 436  :         hr = E_FAIL;

  0009e	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50274:

; 437  :     }
; 438  : 
; 439  :     if(SUCCEEDED(hr) && pdwAbsolute)

  000a5	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a9	7c 0e		 jl	 SHORT $L50279
  000ab	83 7d 10 00	 cmp	 DWORD PTR _pdwAbsolute$[ebp], 0
  000af	74 08		 je	 SHORT $L50279

; 440  :     {
; 441  :         *pdwAbsolute = dwAbsolute;

  000b1	8b 4d 10	 mov	 ecx, DWORD PTR _pdwAbsolute$[ebp]
  000b4	8b 55 fc	 mov	 edx, DWORD PTR _dwAbsolute$[ebp]
  000b7	89 11		 mov	 DWORD PTR [ecx], edx
$L50279:

; 442  :     }
; 443  : 
; 444  :     DPF_LEAVE_HRESULT(hr);
; 445  : 
; 446  :     return hr;

  000b9	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 447  : }

  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 0c 00	 ret	 12			; 0000000cH
?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z ENDP	; WaveLoader::CStdFileStream::Seek
_TEXT	ENDS
PUBLIC	?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z	; WaveLoader::CStdFileStream::GetLength
PUBLIC	??_C@_0BK@LINH@CStdFileStream?3?3GetLength?$AA@	; `string'
PUBLIC	??_C@_0CK@CIMA@Error?5?$CFlu?5attempting?5to?5get?5the?5@ ; `string'
EXTRN	__imp__GetFileSize@8:NEAR
;	COMDAT ??_C@_0BK@LINH@CStdFileStream?3?3GetLength?$AA@
CONST	SEGMENT
??_C@_0BK@LINH@CStdFileStream?3?3GetLength?$AA@ DB 'CStdFileStream::GetLe'
	DB	'ngth', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CIMA@Error?5?$CFlu?5attempting?5to?5get?5the?5@
CONST	SEGMENT
??_C@_0CK@CIMA@Error?5?$CFlu?5attempting?5to?5get?5the?5@ DB 'Error %lu a'
	DB	'ttempting to get the file size', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z
_TEXT	SEGMENT
_pdwLength$ = 8
_this$ = -8
_hr$ = -4
?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z PROC NEAR ; WaveLoader::CStdFileStream::GetLength, COMDAT
; _this$ = ecx

; 473  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 474  :     HRESULT                 hr  = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 475  :     
; 476  :     DPF_ENTER();
; 477  : 
; 478  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L51783
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L51783
  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
  00027	eb 07		 jmp	 SHORT $L51784
$L51783:
  00029	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
$L51784:
  00030	68 de 01 00 00	 push	 478			; 000001deH
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@ECMJ@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
  0003f	8b 55 f4	 mov	 edx, DWORD PTR -12+[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 479  :     
; 480  :     if((*pdwLength = GetFileSize(m_hFile, NULL)) == -1)

  0004b	6a 00		 push	 0
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	51		 push	 ecx
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSize@8
  00059	8b 55 08	 mov	 edx, DWORD PTR _pdwLength$[ebp]
  0005c	89 02		 mov	 DWORD PTR [edx], eax
  0005e	8b 45 08	 mov	 eax, DWORD PTR _pdwLength$[ebp]
  00061	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00064	75 3b		 jne	 SHORT $L50287

; 481  :     {
; 482  :         DPF_ERROR("Error %lu attempting to get the file size", GetLastError());

  00066	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0006b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@LINH@CStdFileStream?3?3GetLength?$AA@ ; `string'
  00070	68 e2 01 00 00	 push	 482			; 000001e2H
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0007a	6a 04		 push	 4
  0007c	6a 09		 push	 9
  0007e	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00083	83 c4 18	 add	 esp, 24			; 00000018H
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0008c	50		 push	 eax
  0008d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@CIMA@Error?5?$CFlu?5attempting?5to?5get?5the?5@ ; `string'
  00092	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00097	83 c4 08	 add	 esp, 8

; 483  :         hr = E_FAIL;

  0009a	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50287:

; 484  :     }
; 485  : 
; 486  :     DPF_LEAVE_HRESULT(hr);
; 487  : 
; 488  :     return hr;

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 489  : }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z ENDP	; WaveLoader::CStdFileStream::GetLength
_TEXT	ENDS
PUBLIC	??0CRiffChunk@WaveLoader@@QAE@XZ		; WaveLoader::CRiffChunk::CRiffChunk
; Function compile flags: /Odt
;	COMDAT ??0CRiffChunk@WaveLoader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CRiffChunk@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CRiffChunk::CRiffChunk, COMDAT
; _this$ = ecx

; 514  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 515  :     DPF_ENTER();
; 516  : 
; 517  :     //
; 518  :     // Initialize defaults
; 519  :     //
; 520  : 
; 521  :     m_pParentChunk = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 522  :     m_pStream = NULL;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 523  :     m_dwChunkId = 0;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 524  :     m_dwDataOffset = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 525  :     m_dwDataSize = 0;

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 526  :     m_dwFlags = 0;

  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 527  : 
; 528  :     DPF_LEAVE_VOID();
; 529  : }

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??0CRiffChunk@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CRiffChunk::CRiffChunk
_TEXT	ENDS
PUBLIC	??1CRiffChunk@WaveLoader@@QAE@XZ		; WaveLoader::CRiffChunk::~CRiffChunk
; Function compile flags: /Odt
;	COMDAT ??1CRiffChunk@WaveLoader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CRiffChunk@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CRiffChunk::~CRiffChunk, COMDAT
; _this$ = ecx

; 554  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  :     DPF_ENTER();
; 556  :     DPF_LEAVE_VOID();
; 557  : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1CRiffChunk@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CRiffChunk::~CRiffChunk
_TEXT	ENDS
PUBLIC	?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
; Function compile flags: /Odt
;	COMDAT ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z
_TEXT	SEGMENT
_pParentChunk$ = 8
_pStream$ = 12
_dwChunkId$ = 16
_this$ = -20
_lOffset$ = -4
_rhRiffHeader$ = -16
_hr$ = -8
?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z PROC NEAR ; WaveLoader::CRiffChunk::Open, COMDAT
; _this$ = ecx

; 587  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 588  :     LONG                    lOffset;
; 589  :     RIFFHEADER              rhRiffHeader;
; 590  :     HRESULT                 hr;
; 591  : 
; 592  :     DPF_ENTER();
; 593  :     
; 594  :     m_pParentChunk = pParentChunk;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pParentChunk$[ebp]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx

; 595  :     m_pStream = pStream;

  00011	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  00017	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 596  : 
; 597  :     //
; 598  :     // Seek to the first byte of the parent chunk's data section
; 599  :     //
; 600  : 
; 601  :     if(m_pParentChunk)

  0001a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00020	74 32		 je	 SHORT $L50308

; 602  :     {
; 603  :         lOffset = m_pParentChunk->m_dwDataOffset;

  00022	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002a	89 4d fc	 mov	 DWORD PTR _lOffset$[ebp], ecx

; 604  : 
; 605  :         //
; 606  :         // Special case the RIFF chunk
; 607  :         //
; 608  : 
; 609  :         if((WAVELDR_FOURCC_RIFF == m_pParentChunk->m_dwChunkId) || (WAVELDR_FOURCC_FORM == m_pParentChunk->m_dwChunkId))

  0002d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	81 78 08 52 49
	46 46		 cmp	 DWORD PTR [eax+8], 1179011410 ; 46464952H
  00039	74 0e		 je	 SHORT $L50310
  0003b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	81 7a 08 46 4f
	52 4d		 cmp	 DWORD PTR [edx+8], 1297239878 ; 4d524f46H
  00047	75 09		 jne	 SHORT $L50309
$L50310:

; 610  :         {
; 611  :             lOffset += sizeof(DWORD);

  00049	8b 45 fc	 mov	 eax, DWORD PTR _lOffset$[ebp]
  0004c	83 c0 04	 add	 eax, 4
  0004f	89 45 fc	 mov	 DWORD PTR _lOffset$[ebp], eax
$L50309:

; 612  :         }
; 613  :     }
; 614  :     else

  00052	eb 07		 jmp	 SHORT $L50312
$L50308:

; 615  :     {
; 616  :         lOffset = 0;

  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lOffset$[ebp], 0
$L50312:
$L50313:

; 617  :     }
; 618  : 
; 619  :     //
; 620  :     // If this is the top level chunk, just read the first 8 bytes.  If not,
; 621  :     // search the parent chunk until we find the one we're looking for.
; 622  :     //
; 623  : 
; 624  :     do
; 625  :     {
; 626  :         hr = m_pStream->Seek(lOffset, FILE_BEGIN, NULL);

  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _lOffset$[ebp]
  00062	51		 push	 ecx
  00063	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00069	e8 00 00 00 00	 call	 ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z ; WaveLoader::CStdFileStream::Seek
  0006e	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 627  : 
; 628  :         if(SUCCEEDED(hr))

  00071	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00075	7c 16		 jl	 SHORT $L50317

; 629  :         {
; 630  :             hr = m_pStream->Read(&rhRiffHeader, sizeof(rhRiffHeader), NULL);

  00077	6a 00		 push	 0
  00079	6a 08		 push	 8
  0007b	8d 45 f0	 lea	 eax, DWORD PTR _rhRiffHeader$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00085	e8 00 00 00 00	 call	 ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z ; WaveLoader::CStdFileStream::Read
  0008a	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L50317:

; 631  :         }
; 632  : 
; 633  :         if(SUCCEEDED(hr) && m_pParentChunk)

  0008d	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00091	7c 21		 jl	 SHORT $L50319
  00093	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00096	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00099	74 19		 je	 SHORT $L50319

; 634  :         {
; 635  :             if(WAVELDR_FOURCC_FORM == m_pParentChunk->m_dwChunkId)

  0009b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	81 79 08 46 4f
	52 4d		 cmp	 DWORD PTR [ecx+8], 1297239878 ; 4d524f46H
  000a7	75 0b		 jne	 SHORT $L50320

; 636  :             {
; 637  :                 rhRiffHeader.dwDataSize = EndianSwapDword(rhRiffHeader.dwDataSize);

  000a9	8b 4d f4	 mov	 ecx, DWORD PTR _rhRiffHeader$[ebp+4]
  000ac	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  000b1	89 45 f4	 mov	 DWORD PTR _rhRiffHeader$[ebp+4], eax
$L50320:
$L50319:

; 638  :             }
; 639  :         }
; 640  : 
; 641  :         if(SUCCEEDED(hr) && (dwChunkId == rhRiffHeader.dwChunkId))

  000b4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b8	7c 0a		 jl	 SHORT $L50322
  000ba	8b 55 10	 mov	 edx, DWORD PTR _dwChunkId$[ebp]
  000bd	3b 55 f0	 cmp	 edx, DWORD PTR _rhRiffHeader$[ebp]
  000c0	75 02		 jne	 SHORT $L50322

; 642  :         {
; 643  :             break;

  000c2	eb 32		 jmp	 SHORT $L50315
$L50322:

; 644  :         }
; 645  : 
; 646  :         if(SUCCEEDED(hr) && !m_pParentChunk)

  000c4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000c8	7c 0f		 jl	 SHORT $L50324
  000ca	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	83 38 00	 cmp	 DWORD PTR [eax], 0
  000d0	75 07		 jne	 SHORT $L50324

; 647  :         {
; 648  :             hr = E_FAIL;

  000d2	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50324:

; 649  :         }
; 650  : 
; 651  :         if(SUCCEEDED(hr))

  000d9	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000dd	7c 0d		 jl	 SHORT $L50327

; 652  :         {
; 653  :             lOffset += sizeof(rhRiffHeader) + rhRiffHeader.dwDataSize;

  000df	8b 4d f4	 mov	 ecx, DWORD PTR _rhRiffHeader$[ebp+4]
  000e2	8b 55 fc	 mov	 edx, DWORD PTR _lOffset$[ebp]
  000e5	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  000e9	89 45 fc	 mov	 DWORD PTR _lOffset$[ebp], eax
$L50327:

; 654  :         }
; 655  :     }
; 656  :     while(SUCCEEDED(hr));

  000ec	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000f0	0f 8d 65 ff ff
	ff		 jge	 $L50313
$L50315:

; 657  : 
; 658  :     //
; 659  :     // Success
; 660  :     //
; 661  : 
; 662  :     if(SUCCEEDED(hr))

  000f6	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000fa	7c 2d		 jl	 SHORT $L50330

; 663  :     {
; 664  :         m_dwChunkId = dwChunkId;

  000fc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	8b 55 10	 mov	 edx, DWORD PTR _dwChunkId$[ebp]
  00102	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 665  :         m_dwDataOffset = lOffset + sizeof(rhRiffHeader);

  00105	8b 45 fc	 mov	 eax, DWORD PTR _lOffset$[ebp]
  00108	83 c0 08	 add	 eax, 8
  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 666  :         m_dwDataSize = rhRiffHeader.dwDataSize;

  00111	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00114	8b 45 f4	 mov	 eax, DWORD PTR _rhRiffHeader$[ebp+4]
  00117	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 667  :         m_dwFlags |= RIFFCHUNK_FLAGS_VALID;

  0011a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00120	83 ca 01	 or	 edx, 1
  00123	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00126	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L50330:

; 668  :     }
; 669  : 
; 670  :     DPF_LEAVE_HRESULT(hr);
; 671  : 
; 672  :     return hr;

  00129	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 673  : }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 0c 00	 ret	 12			; 0000000cH
?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ENDP ; WaveLoader::CRiffChunk::Open
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?EndianSwapDword@@YIKK@Z
_TEXT	SEGMENT
_n$ = -4
?EndianSwapDword@@YIKK@Z PROC NEAR			; EndianSwapDword, COMDAT
; _n$ = ecx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx

; 55   :     __asm
; 56   :     {
; 57   :         mov     eax, ecx

  00008	8b c1		 mov	 eax, ecx

; 58   :         sar     eax, 24

  0000a	c1 f8 18	 sar	 eax, 24			; 00000018H

; 59   :         and     eax, 0ffh

  0000d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 60   : 
; 61   :         mov     ebx, ecx

  00012	8b d9		 mov	 ebx, ecx

; 62   :         sar     ebx, 8

  00014	c1 fb 08	 sar	 ebx, 8

; 63   :         and     ebx, 0ff00h

  00017	81 e3 00 ff 00
	00		 and	 ebx, 65280		; 0000ff00H

; 64   :         or      eax, ebx

  0001d	0b c3		 or	 eax, ebx

; 65   : 
; 66   :         mov     ebx, ecx

  0001f	8b d9		 mov	 ebx, ecx

; 67   :         shl     ebx, 8

  00021	c1 e3 08	 shl	 ebx, 8

; 68   :         and     ebx, 0ff0000h

  00024	81 e3 00 00 ff
	00		 and	 ebx, 16711680		; 00ff0000H

; 69   :         or      eax, ebx

  0002a	0b c3		 or	 eax, ebx

; 70   : 
; 71   :         mov     ebx, ecx

  0002c	8b d9		 mov	 ebx, ecx

; 72   :         shl     ebx, 24

  0002e	c1 e3 18	 shl	 ebx, 24			; 00000018H

; 73   :         and     ebx, 0ff000000h

  00031	81 e3 00 00 00
	ff		 and	 ebx, -16777216		; ff000000H

; 74   :         or      eax, ebx

  00037	0b c3		 or	 eax, ebx

; 75   :     }
; 76   : }

  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?EndianSwapDword@@YIKK@Z ENDP				; EndianSwapDword
_TEXT	ENDS
PUBLIC	?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z	; WaveLoader::CRiffChunk::Read
PUBLIC	??_C@_0BB@EPJI@CRiffChunk?3?3Read?$AA@		; `string'
PUBLIC	??_C@_0CM@LIHM@Attempted?5to?5read?5past?5the?5end?5o@ ; `string'
;	COMDAT ??_C@_0BB@EPJI@CRiffChunk?3?3Read?$AA@
CONST	SEGMENT
??_C@_0BB@EPJI@CRiffChunk?3?3Read?$AA@ DB 'CRiffChunk::Read', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LIHM@Attempted?5to?5read?5past?5the?5end?5o@
CONST	SEGMENT
??_C@_0CM@LIHM@Attempted?5to?5read?5past?5the?5end?5o@ DB 'Attempted to r'
	DB	'ead past the end of the chunk', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z
_TEXT	SEGMENT
_dwOffset$ = 8
_pvBuffer$ = 12
_dwBufferSize$ = 16
_pdwRead$ = 20
_this$ = -8
_hr$ = -4
?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z PROC NEAR	; WaveLoader::CRiffChunk::Read, COMDAT
; _this$ = ecx

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 706  :     HRESULT                 hr  = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 707  : 
; 708  :     DPF_ENTER();
; 709  : 
; 710  :     if(dwOffset + dwBufferSize > m_dwDataSize)

  00010	8b 45 08	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  00013	03 45 10	 add	 eax, DWORD PTR _dwBufferSize$[ebp]
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0001c	76 64		 jbe	 SHORT $L50340

; 711  :     {
; 712  :         if(dwOffset >= m_dwDataSize)

  0001e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 45 08	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  00024	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  00027	72 09		 jb	 SHORT $L50341

; 713  :         {
; 714  :             dwBufferSize = 0;

  00029	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _dwBufferSize$[ebp], 0

; 715  :         }
; 716  :         else

  00030	eb 0c		 jmp	 SHORT $L50342
$L50341:

; 717  :         {
; 718  :             dwBufferSize = m_dwDataSize - dwOffset;

  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00038	2b 55 08	 sub	 edx, DWORD PTR _dwOffset$[ebp]
  0003b	89 55 10	 mov	 DWORD PTR _dwBufferSize$[ebp], edx
$L50342:

; 719  :         }
; 720  : 
; 721  :         if(pdwRead)

  0003e	83 7d 14 00	 cmp	 DWORD PTR _pdwRead$[ebp], 0
  00042	74 0a		 je	 SHORT $L50343

; 722  :         {
; 723  :             *pdwRead = dwBufferSize;

  00044	8b 45 14	 mov	 eax, DWORD PTR _pdwRead$[ebp]
  00047	8b 4d 10	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  0004a	89 08		 mov	 DWORD PTR [eax], ecx

; 724  :         }
; 725  :         else

  0004c	eb 34		 jmp	 SHORT $L50344
$L50343:

; 726  :         {
; 727  :             DPF_ERROR("Attempted to read past the end of the chunk");

  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@EPJI@CRiffChunk?3?3Read?$AA@ ; `string'
  00058	68 d7 02 00 00	 push	 727			; 000002d7H
  0005d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00062	6a 04		 push	 4
  00064	6a 09		 push	 9
  00066	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0006b	83 c4 18	 add	 esp, 24			; 00000018H
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@LIHM@Attempted?5to?5read?5past?5the?5end?5o@ ; `string'
  00073	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00078	83 c4 04	 add	 esp, 4

; 728  :             hr = E_FAIL;

  0007b	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50344:
$L50340:

; 729  :         }
; 730  :     }
; 731  : 
; 732  :     if(SUCCEEDED(hr))

  00082	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00086	7c 1c		 jl	 SHORT $L50349

; 733  :     {
; 734  :         hr = m_pStream->Seek(m_dwDataOffset + dwOffset, FILE_BEGIN, NULL);

  00088	6a 00		 push	 0
  0008a	6a 00		 push	 0
  0008c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0008f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00092	03 45 08	 add	 eax, DWORD PTR _dwOffset$[ebp]
  00095	50		 push	 eax
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009c	e8 00 00 00 00	 call	 ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z ; WaveLoader::CStdFileStream::Seek
  000a1	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L50349:

; 735  :     }
; 736  : 
; 737  :     if(SUCCEEDED(hr))

  000a4	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a8	7c 18		 jl	 SHORT $L50351

; 738  :     {
; 739  :         hr = m_pStream->Read(pvBuffer, dwBufferSize, NULL);

  000aa	6a 00		 push	 0
  000ac	8b 55 10	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  000af	52		 push	 edx
  000b0	8b 45 0c	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000ba	e8 00 00 00 00	 call	 ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z ; WaveLoader::CStdFileStream::Read
  000bf	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L50351:

; 740  :     }
; 741  : 
; 742  :     DPF_LEAVE_HRESULT(hr);
; 743  : 
; 744  :     return hr;

  000c2	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 745  : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 10 00	 ret	 16			; 00000010H
?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ENDP	; WaveLoader::CRiffChunk::Read
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CWaveFile@WaveLoader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CWaveFile@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CWaveFile::CWaveFile, COMDAT
; _this$ = ecx

; 770  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::CStdFileStream
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 20	 add	 ecx, 32			; 00000020H
  00020	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 771  :     DPF_ENTER();
; 772  : 
; 773  :     m_dwFileType = -1;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c7 40 38 ff ff
	ff ff		 mov	 DWORD PTR [eax+56], -1

; 774  :     m_pwfxFormat = NULL;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 775  : 
; 776  :     DPF_LEAVE_VOID();
; 777  : }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??0CWaveFile@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CWaveFile::CWaveFile
_TEXT	ENDS
PUBLIC	?Close@CWaveFile@WaveLoader@@QAEXXZ		; WaveLoader::CWaveFile::Close
; Function compile flags: /Odt
;	COMDAT ??1CWaveFile@WaveLoader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CWaveFile@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CWaveFile::~CWaveFile, COMDAT
; _this$ = ecx

; 802  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 803  :     DPF_ENTER();
; 804  : 
; 805  :     Close();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Close@CWaveFile@WaveLoader@@QAEXXZ ; WaveLoader::CWaveFile::Close

; 806  : 
; 807  :     DPF_LEAVE_VOID();
; 808  : }

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 20	 add	 ecx, 32			; 00000020H
  00015	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ??1CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::~CStdFileStream
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??1CWaveFile@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CWaveFile::~CWaveFile
_TEXT	ENDS
PUBLIC	?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetWaveFormat
PUBLIC	?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetAiffFormat
PUBLIC	??_C@_0DC@DPCC@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@ ; `string'
PUBLIC	??_C@_0BA@KPN@CWaveFile?3?3Open?$AA@		; `string'
PUBLIC	??_C@_0BK@LAOA@The?5file?5type?5is?5not?5WAVE?$AA@ ; `string'
PUBLIC	??_C@_0CB@CCLG@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@ ; `string'
PUBLIC	??_C@_0CL@MPHA@The?5file?8s?5AIFF?9C?5version?5is?5not@ ; `string'
;	COMDAT ??_C@_0DC@DPCC@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@
CONST	SEGMENT
??_C@_0DC@DPCC@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@ DB '('
	DB	'pszFileName || hFile) && !(pszFileName && hFile)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPN@CWaveFile?3?3Open?$AA@
CONST	SEGMENT
??_C@_0BA@KPN@CWaveFile?3?3Open?$AA@ DB 'CWaveFile::Open', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LAOA@The?5file?5type?5is?5not?5WAVE?$AA@
CONST	SEGMENT
??_C@_0BK@LAOA@The?5file?5type?5is?5not?5WAVE?$AA@ DB 'The file type is n'
	DB	'ot WAVE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CCLG@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@
CONST	SEGMENT
??_C@_0CB@CCLG@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@ DB 'The file type'
	DB	' is not AIFF/AIFF-C', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MPHA@The?5file?8s?5AIFF?9C?5version?5is?5not@
CONST	SEGMENT
??_C@_0CL@MPHA@The?5file?8s?5AIFF?9C?5version?5is?5not@ DB 'The file''s A'
	DB	'IFF-C version is not supported', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z
_TEXT	SEGMENT
_pszFileName$ = 8
_hFile$ = 12
_this$ = -56
_hr$ = -12
_dwType$ = -8
_VersionChunk$ = -48
_dwVersion$ = -4
_dwFormatSize$ = -24
_AiffSoundHeader$ = -20
$T51813 = -52
?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z PROC NEAR	; WaveLoader::CWaveFile::Open, COMDAT
; _this$ = ecx

; 836  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 837  :     HRESULT                 hr              = S_OK;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 838  :     DWORD                   dwType;
; 839  :     CRiffChunk              VersionChunk;

  00010	8d 4d d0	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 840  :     DWORD                   dwVersion;
; 841  :     DWORD                   dwFormatSize;
; 842  :     AIFFSOUNDHDR            AiffSoundHeader;
; 843  : 
; 844  :     DPF_ENTER();
; 845  : 
; 846  :     ASSERT((pszFileName || hFile) && !(pszFileName && hFile));

  00018	83 7d 08 00	 cmp	 DWORD PTR _pszFileName$[ebp], 0
  0001c	75 06		 jne	 SHORT $L51809
  0001e	83 7d 0c 00	 cmp	 DWORD PTR _hFile$[ebp], 0
  00022	74 15		 je	 SHORT $L51811
$L51809:
  00024	83 7d 08 00	 cmp	 DWORD PTR _pszFileName$[ebp], 0
  00028	74 06		 je	 SHORT $L51810
  0002a	83 7d 0c 00	 cmp	 DWORD PTR _hFile$[ebp], 0
  0002e	75 09		 jne	 SHORT $L51811
$L51810:
  00030	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR -60+[ebp], 0
  00037	eb 07		 jmp	 SHORT $L51812
$L51811:
  00039	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR -60+[ebp], 1
$L51812:
  00040	68 4e 03 00 00	 push	 846			; 0000034eH
  00045	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DC@DPCC@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@ ; `string'
  0004f	8b 45 c4	 mov	 eax, DWORD PTR -60+[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00058	83 c4 10	 add	 esp, 16			; 00000010H

; 847  :     
; 848  :     //
; 849  :     // If we're already open, close
; 850  :     //
; 851  : 
; 852  :     Close();

  0005b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?Close@CWaveFile@WaveLoader@@QAEXXZ ; WaveLoader::CWaveFile::Close

; 853  : 
; 854  :     //
; 855  :     // Open the file
; 856  :     //
; 857  : 
; 858  :     if(pszFileName)

  00063	83 7d 08 00	 cmp	 DWORD PTR _pszFileName$[ebp], 0
  00067	74 1c		 je	 SHORT $L50373

; 859  :     {
; 860  :         hr = m_Stream.Open(pszFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, 0);

  00069	6a 00		 push	 0
  0006b	6a 03		 push	 3
  0006d	6a 01		 push	 1
  0006f	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _pszFileName$[ebp]
  00077	51		 push	 ecx
  00078	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z ; WaveLoader::CStdFileStream::Open
  00080	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 861  :     }
; 862  :     else

  00083	eb 0c		 jmp	 SHORT $L50374
$L50373:

; 863  :     {
; 864  :         m_Stream.Attach(hFile);

  00085	8b 55 0c	 mov	 edx, DWORD PTR _hFile$[ebp]
  00088	52		 push	 edx
  00089	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	e8 00 00 00 00	 call	 ?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z ; WaveLoader::CStdFileStream::Attach
$L50374:

; 865  :     }
; 866  : 
; 867  :     //
; 868  :     // Determine the file type by opening the top-level chunk
; 869  :     //
; 870  : 
; 871  :     if(SUCCEEDED(hr))

  00091	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00095	7c 54		 jl	 SHORT $L50376

; 872  :     {
; 873  :         hr = m_ParentChunk.Open(NULL, &m_Stream, WAVELDR_FOURCC_RIFF);

  00097	68 52 49 46 46	 push	 1179011410		; 46464952H
  0009c	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	50		 push	 eax
  000a0	6a 00		 push	 0
  000a2	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	83 c1 08	 add	 ecx, 8
  000a8	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  000ad	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 874  : 
; 875  :         if(SUCCEEDED(hr))

  000b0	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b4	7c 0c		 jl	 SHORT $L50378

; 876  :         {
; 877  :             m_dwFileType = WAVELDR_FILETYPE_WAVE;

  000b6	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 878  :         }
; 879  :         else

  000c0	eb 29		 jmp	 SHORT $L50379
$L50378:

; 880  :         {
; 881  :             hr = m_ParentChunk.Open(NULL, &m_Stream, WAVELDR_FOURCC_FORM);

  000c2	68 46 4f 52 4d	 push	 1297239878		; 4d524f46H
  000c7	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  000ca	52		 push	 edx
  000cb	6a 00		 push	 0
  000cd	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	83 c1 08	 add	 ecx, 8
  000d3	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  000d8	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 882  : 
; 883  :             if(SUCCEEDED(hr))

  000db	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000df	7c 0a		 jl	 SHORT $L50381

; 884  :             {
; 885  :                 m_dwFileType = WAVELDR_FILETYPE_AIFF;

  000e1	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	c7 40 38 01 00
	00 00		 mov	 DWORD PTR [eax+56], 1
$L50381:
$L50379:
$L50376:

; 886  :             }
; 887  :         }
; 888  :     }
; 889  : 
; 890  :     if(SUCCEEDED(hr))

  000eb	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ef	0f 8c b0 00 00
	00		 jl	 $L50383

; 891  :     {
; 892  :         hr = m_ParentChunk.Read(0, &dwType, sizeof(dwType));

  000f5	6a 00		 push	 0
  000f7	6a 04		 push	 4
  000f9	8d 4d f8	 lea	 ecx, DWORD PTR _dwType$[ebp]
  000fc	51		 push	 ecx
  000fd	6a 00		 push	 0
  000ff	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	83 c1 08	 add	 ecx, 8
  00105	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  0010a	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 893  : 
; 894  :         if(SUCCEEDED(hr))

  0010d	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00111	0f 8c 8e 00 00
	00		 jl	 $L50385

; 895  :         {
; 896  :             if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  00117	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0011a	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0011e	75 3f		 jne	 SHORT $L50386

; 897  :             {
; 898  :                 if(WAVELDR_FOURCC_WAVE != dwType)

  00120	81 7d f8 57 41
	56 45		 cmp	 DWORD PTR _dwType$[ebp], 1163280727 ; 45564157H
  00127	74 34		 je	 SHORT $L50387

; 899  :                 {
; 900  :                     DPF_ERROR("The file type is not WAVE");

  00129	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0012e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@KPN@CWaveFile?3?3Open?$AA@ ; `string'
  00133	68 84 03 00 00	 push	 900			; 00000384H
  00138	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0013d	6a 04		 push	 4
  0013f	6a 09		 push	 9
  00141	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00146	83 c4 18	 add	 esp, 24			; 00000018H
  00149	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@LAOA@The?5file?5type?5is?5not?5WAVE?$AA@ ; `string'
  0014e	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00153	83 c4 04	 add	 esp, 4

; 901  :                     hr = E_FAIL;

  00156	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50387:

; 902  :                 }
; 903  :             }
; 904  :             else

  0015d	eb 46		 jmp	 SHORT $L50391
$L50386:

; 905  :             {
; 906  :                 if((WAVELDR_FOURCC_AIFF != dwType) && (WAVELDR_FOURCC_AIFFC != dwType))

  0015f	81 7d f8 41 49
	46 46		 cmp	 DWORD PTR _dwType$[ebp], 1179011393 ; 46464941H
  00166	74 3d		 je	 SHORT $L50392
  00168	81 7d f8 41 49
	46 43		 cmp	 DWORD PTR _dwType$[ebp], 1128679745 ; 43464941H
  0016f	74 34		 je	 SHORT $L50392

; 907  :                 {
; 908  :                     DPF_ERROR("The file type is not AIFF/AIFF-C");

  00171	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00176	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@KPN@CWaveFile?3?3Open?$AA@ ; `string'
  0017b	68 8c 03 00 00	 push	 908			; 0000038cH
  00180	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00185	6a 04		 push	 4
  00187	6a 09		 push	 9
  00189	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0018e	83 c4 18	 add	 esp, 24			; 00000018H
  00191	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@CCLG@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@ ; `string'
  00196	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0019b	83 c4 04	 add	 esp, 4

; 909  :                     hr = E_FAIL;

  0019e	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50392:
$L50391:
$L50385:
$L50383:

; 910  :                 }
; 911  :             }
; 912  :         }
; 913  :     }
; 914  : 
; 915  :     if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType) && (WAVELDR_FOURCC_AIFFC == dwType))

  001a5	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001a9	0f 8c 8f 00 00
	00		 jl	 $L50396
  001af	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  001b2	83 78 38 01	 cmp	 DWORD PTR [eax+56], 1
  001b6	0f 85 82 00 00
	00		 jne	 $L50396
  001bc	81 7d f8 41 49
	46 43		 cmp	 DWORD PTR _dwType$[ebp], 1128679745 ; 43464941H
  001c3	75 79		 jne	 SHORT $L50396

; 916  :     {
; 917  :         hr = VersionChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_AIFF_VERSION);

  001c5	68 52 56 45 52	 push	 1380275794		; 52455652H
  001ca	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001cd	51		 push	 ecx
  001ce	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  001d1	83 c2 08	 add	 edx, 8
  001d4	52		 push	 edx
  001d5	8d 4d d0	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  001d8	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  001dd	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 918  : 
; 919  :         if(SUCCEEDED(hr))

  001e0	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001e4	7c 15		 jl	 SHORT $L50398

; 920  :         {
; 921  :             hr = VersionChunk.Read(0, &dwVersion, sizeof(dwVersion));

  001e6	6a 00		 push	 0
  001e8	6a 04		 push	 4
  001ea	8d 45 fc	 lea	 eax, DWORD PTR _dwVersion$[ebp]
  001ed	50		 push	 eax
  001ee	6a 00		 push	 0
  001f0	8d 4d d0	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  001f3	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  001f8	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
$L50398:

; 922  :         }
; 923  : 
; 924  :         if(SUCCEEDED(hr) && (WAVELDR_AIFFC_VERSION != dwVersion))

  001fb	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001ff	7c 3d		 jl	 SHORT $L50400
  00201	81 7d fc 40 51
	80 a2		 cmp	 DWORD PTR _dwVersion$[ebp], -1568648896 ; a2805140H
  00208	74 34		 je	 SHORT $L50400

; 925  :         {
; 926  :             DPF_ERROR("The file's AIFF-C version is not supported");

  0020a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  0020f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@KPN@CWaveFile?3?3Open?$AA@ ; `string'
  00214	68 9e 03 00 00	 push	 926			; 0000039eH
  00219	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0021e	6a 04		 push	 4
  00220	6a 09		 push	 9
  00222	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00227	83 c4 18	 add	 esp, 24			; 00000018H
  0022a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CL@MPHA@The?5file?8s?5AIFF?9C?5version?5is?5not@ ; `string'
  0022f	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00234	83 c4 04	 add	 esp, 4

; 927  :             hr = E_FAIL;

  00237	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50400:
$L50396:

; 928  :         }
; 929  :     }
; 930  : 
; 931  :     //
; 932  :     // Initialize the required chunk objects
; 933  :     //
; 934  : 
; 935  :     if(SUCCEEDED(hr))

  0023e	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00242	7c 30		 jl	 SHORT $L50404

; 936  :     {
; 937  :         hr = m_DataChunk.Open(&m_ParentChunk, &m_Stream, (WAVELDR_FILETYPE_WAVE == m_dwFileType) ? WAVELDR_FOURCC_DATA : WAVELDR_FOURCC_SOUND);

  00244	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00247	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0024a	f7 da		 neg	 edx
  0024c	1b d2		 sbb	 edx, edx
  0024e	81 e2 ef f1 d9
	e2		 and	 edx, -489033233		; e2d9f1efH
  00254	81 c2 64 61 74
	61		 add	 edx, 1635017060		; 61746164H
  0025a	52		 push	 edx
  0025b	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0025e	50		 push	 eax
  0025f	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00262	83 c1 08	 add	 ecx, 8
  00265	51		 push	 ecx
  00266	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00269	83 c1 20	 add	 ecx, 32			; 00000020H
  0026c	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00271	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
$L50404:

; 938  :     }
; 939  : 
; 940  :     //
; 941  :     // Load the file format
; 942  :     //
; 943  : 
; 944  :     if(SUCCEEDED(hr))

  00274	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00278	7c 31		 jl	 SHORT $L50406

; 945  :     {
; 946  :         if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  0027a	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0027d	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00281	75 15		 jne	 SHORT $L50407

; 947  :         {
; 948  :             hr = GetWaveFormat(NULL, 0, &dwFormatSize);

  00283	8d 45 e8	 lea	 eax, DWORD PTR _dwFormatSize$[ebp]
  00286	50		 push	 eax
  00287	6a 00		 push	 0
  00289	6a 00		 push	 0
  0028b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0028e	e8 00 00 00 00	 call	 ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetWaveFormat
  00293	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 949  :         }
; 950  :         else

  00296	eb 13		 jmp	 SHORT $L50408
$L50407:

; 951  :         {
; 952  :             hr = GetAiffFormat(NULL, 0, &dwFormatSize);

  00298	8d 4d e8	 lea	 ecx, DWORD PTR _dwFormatSize$[ebp]
  0029b	51		 push	 ecx
  0029c	6a 00		 push	 0
  0029e	6a 00		 push	 0
  002a0	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002a3	e8 00 00 00 00	 call	 ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetAiffFormat
  002a8	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
$L50408:
$L50406:

; 953  :         }
; 954  :     }
; 955  : 
; 956  :     if(SUCCEEDED(hr))

  002ab	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002af	7c 3c		 jl	 SHORT $L50410

; 957  :     {
; 958  :         hr = HRFROMP(m_pwfxFormat = (LPWAVEFORMATEX)MEMALLOC(BYTE, dwFormatSize));

  002b1	6a 01		 push	 1
  002b3	8b 55 e8	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  002b6	52		 push	 edx
  002b7	68 44 53 64 61	 push	 1633964868		; 61645344H
  002bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04EHOP@BYTE?$AA@ ; `string'
  002c1	68 be 03 00 00	 push	 958			; 000003beH
  002c6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  002cb	e8 00 00 00 00	 call	 ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingPoolAlloc
  002d0	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002d3	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
  002d6	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  002d9	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  002dc	f7 d8		 neg	 eax
  002de	1b c0		 sbb	 eax, eax
  002e0	25 f2 ff f8 7f	 and	 eax, 2147024882		; 7ff8fff2H
  002e5	05 0e 00 07 80	 add	 eax, -2147024882	; 8007000eH
  002ea	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
$L50410:

; 959  :     }
; 960  : 
; 961  :     if(SUCCEEDED(hr))

  002ed	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002f1	7c 3b		 jl	 SHORT $L50417

; 962  :     {
; 963  :         if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  002f3	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002f6	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  002fa	75 1a		 jne	 SHORT $L50418

; 964  :         {
; 965  :             hr = GetWaveFormat(m_pwfxFormat, dwFormatSize, NULL);

  002fc	6a 00		 push	 0
  002fe	8b 55 e8	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  00301	52		 push	 edx
  00302	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00305	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00308	51		 push	 ecx
  00309	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0030c	e8 00 00 00 00	 call	 ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetWaveFormat
  00311	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 966  :         }
; 967  :         else

  00314	eb 18		 jmp	 SHORT $L50419
$L50418:

; 968  :         {
; 969  :             hr = GetAiffFormat(m_pwfxFormat, dwFormatSize, NULL);

  00316	6a 00		 push	 0
  00318	8b 55 e8	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  0031b	52		 push	 edx
  0031c	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0031f	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00322	51		 push	 ecx
  00323	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00326	e8 00 00 00 00	 call	 ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetAiffFormat
  0032b	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
$L50419:
$L50417:

; 970  :         }
; 971  :     }
; 972  : 
; 973  :     //
; 974  :     // If this is an AIFF file, offset the start of the wave data
; 975  :     //
; 976  : 
; 977  :     if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType))

  0032e	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00332	7c 4e		 jl	 SHORT $L50421
  00334	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00337	83 7a 38 01	 cmp	 DWORD PTR [edx+56], 1
  0033b	75 45		 jne	 SHORT $L50421

; 978  :     {
; 979  :         hr = m_DataChunk.Read(0, &AiffSoundHeader, sizeof(AiffSoundHeader));

  0033d	6a 00		 push	 0
  0033f	6a 08		 push	 8
  00341	8d 45 ec	 lea	 eax, DWORD PTR _AiffSoundHeader$[ebp]
  00344	50		 push	 eax
  00345	6a 00		 push	 0
  00347	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0034a	83 c1 20	 add	 ecx, 32			; 00000020H
  0034d	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00352	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 980  : 
; 981  :         if(SUCCEEDED(hr))

  00355	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00359	7c 27		 jl	 SHORT $L50423

; 982  :         {
; 983  :             m_DataChunk.m_dwDataOffset += sizeof(AiffSoundHeader) + AiffSoundHeader.dwOffset;

  0035b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0035e	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00361	8b 45 ec	 mov	 eax, DWORD PTR _AiffSoundHeader$[ebp]
  00364	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  00368	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0036b	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 984  :             m_DataChunk.m_dwDataSize -= sizeof(AiffSoundHeader) + AiffSoundHeader.dwOffset;

  0036e	8b 45 ec	 mov	 eax, DWORD PTR _AiffSoundHeader$[ebp]
  00371	83 c0 08	 add	 eax, 8
  00374	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00377	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0037a	2b d0		 sub	 edx, eax
  0037c	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0037f	89 50 30	 mov	 DWORD PTR [eax+48], edx
$L50423:
$L50421:

; 985  :         }
; 986  :     }
; 987  : 
; 988  :     DPF_LEAVE_HRESULT(hr);
; 989  : 
; 990  :     return hr;

  00382	8b 4d f4	 mov	 ecx, DWORD PTR _hr$[ebp]
  00385	89 4d cc	 mov	 DWORD PTR $T51813[ebp], ecx
  00388	8d 4d d0	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  0038b	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  00390	8b 45 cc	 mov	 eax, DWORD PTR $T51813[ebp]

; 991  : }

  00393	8b e5		 mov	 esp, ebp
  00395	5d		 pop	 ebp
  00396	c2 08 00	 ret	 8
?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z ENDP		; WaveLoader::CWaveFile::Open
_TEXT	ENDS
PUBLIC	??_C@_0N@OAHJ@m_pwfxFormat?$AA@			; `string'
EXTRN	_memcpy:NEAR
;	COMDAT ??_C@_0N@OAHJ@m_pwfxFormat?$AA@
CONST	SEGMENT
??_C@_0N@OAHJ@m_pwfxFormat?$AA@ DB 'm_pwfxFormat', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z
_TEXT	SEGMENT
_pwfxFormat$ = 8
_dwFormatSize$ = 12
_pdwRequiredSize$ = 16
_this$ = -12
_dwValidSize$ = -8
?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z PROC NEAR ; WaveLoader::CWaveFile::GetFormat, COMDAT
; _this$ = ecx

; 1021 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1022 :     DWORD                   dwValidSize;
; 1023 :     HRESULT                 hr;
; 1024 : 
; 1025 :     DPF_ENTER();
; 1026 : 
; 1027 :     ASSERT(m_pwfxFormat);

  00009	68 03 04 00 00	 push	 1027			; 00000403H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@OAHJ@m_pwfxFormat?$AA@ ; `string'
  00018	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	33 c9		 xor	 ecx, ecx
  0001d	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00021	0f 94 c1	 sete	 cl
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 1028 :     
; 1029 :     dwValidSize = sizeof(*m_pwfxFormat) + m_pwfxFormat->cbSize;

  0002d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00033	33 c9		 xor	 ecx, ecx
  00035	66 8b 48 10	 mov	 cx, WORD PTR [eax+16]
  00039	83 c1 12	 add	 ecx, 18			; 00000012H
  0003c	89 4d f8	 mov	 DWORD PTR _dwValidSize$[ebp], ecx

; 1030 : 
; 1031 :     if(pwfxFormat && dwFormatSize)

  0003f	83 7d 08 00	 cmp	 DWORD PTR _pwfxFormat$[ebp], 0
  00043	74 53		 je	 SHORT $L50434
  00045	83 7d 0c 00	 cmp	 DWORD PTR _dwFormatSize$[ebp], 0
  00049	74 4d		 je	 SHORT $L50434

; 1032 :     {
; 1033 :         CopyMemory(pwfxFormat, m_pwfxFormat, min(dwFormatSize, dwValidSize));

  0004b	8b 55 0c	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  0004e	3b 55 f8	 cmp	 edx, DWORD PTR _dwValidSize$[ebp]
  00051	73 08		 jae	 SHORT $L51817
  00053	8b 45 0c	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  00056	89 45 f0	 mov	 DWORD PTR -16+[ebp], eax
  00059	eb 06		 jmp	 SHORT $L51818
$L51817:
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _dwValidSize$[ebp]
  0005e	89 4d f0	 mov	 DWORD PTR -16+[ebp], ecx
$L51818:
  00061	8b 55 f0	 mov	 edx, DWORD PTR -16+[ebp]
  00064	52		 push	 edx
  00065	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0006b	51		 push	 ecx
  0006c	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _memcpy
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1034 : 
; 1035 :         if(dwFormatSize > dwValidSize)

  00078	8b 45 0c	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  0007b	3b 45 f8	 cmp	 eax, DWORD PTR _dwValidSize$[ebp]
  0007e	76 18		 jbe	 SHORT $L50435

; 1036 :         {
; 1037 :             ZeroMemory((LPBYTE)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize);

  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFormatSize$[ebp]
  00083	2b 4d f8	 sub	 ecx, DWORD PTR _dwValidSize$[ebp]
  00086	51		 push	 ecx
  00087	6a 00		 push	 0
  00089	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  0008c	03 55 f8	 add	 edx, DWORD PTR _dwValidSize$[ebp]
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 _memset
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH
$L50435:
$L50434:

; 1038 :         }
; 1039 :     }
; 1040 : 
; 1041 :     if(pdwRequiredSize)

  00098	83 7d 10 00	 cmp	 DWORD PTR _pdwRequiredSize$[ebp], 0
  0009c	74 08		 je	 SHORT $L50437

; 1042 :     {
; 1043 :         *pdwRequiredSize = dwValidSize;

  0009e	8b 45 10	 mov	 eax, DWORD PTR _pdwRequiredSize$[ebp]
  000a1	8b 4d f8	 mov	 ecx, DWORD PTR _dwValidSize$[ebp]
  000a4	89 08		 mov	 DWORD PTR [eax], ecx
$L50437:

; 1044 :     }
; 1045 : 
; 1046 :     DPF_LEAVE_HRESULT(S_OK);
; 1047 : 
; 1048 :     return S_OK;

  000a6	33 c0		 xor	 eax, eax

; 1049 : }

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 0c 00	 ret	 12			; 0000000cH
?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z ENDP ; WaveLoader::CWaveFile::GetFormat
_TEXT	ENDS
PUBLIC	??_C@_0CG@DJPM@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@ ; `string'
;	COMDAT ??_C@_0CG@DJPM@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@
CONST	SEGMENT
??_C@_0CG@DJPM@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@ DB 'WAVELDR_FILE'
	DB	'TYPE_WAVE == m_dwFileType', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
_TEXT	SEGMENT
$T51826 = -36
_pwfxFormat$ = 8
_dwFormatSize$ = 12
_pdwRequiredSize$ = 16
_this$ = -40
_FormatChunk$ = -32
_dwValidSize$ = -8
_hr$ = -4
?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z PROC NEAR ; WaveLoader::CWaveFile::GetWaveFormat, COMDAT
; _this$ = ecx

; 1079 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 1080 :     CRiffChunk              FormatChunk;

  00009	8d 4d e0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1081 :     DWORD                   dwValidSize;
; 1082 :     HRESULT                 hr;
; 1083 : 
; 1084 :     DPF_ENTER();
; 1085 : 
; 1086 :     ASSERT(WAVELDR_FILETYPE_WAVE == m_dwFileType);

  00011	68 3e 04 00 00	 push	 1086			; 0000043eH
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@DJPM@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@ ; `string'
  00020	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00023	33 c9		 xor	 ecx, ecx
  00025	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00029	0f 95 c1	 setne	 cl
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 1087 : 
; 1088 :     //
; 1089 :     // Read the format chunk into the buffer.  Make sure to fill in the full
; 1090 :     // WAVEFORMATEX structure, even if the data in the file isn't enough.
; 1091 :     //
; 1092 : 
; 1093 :     hr = FormatChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_FORMAT);

  00035	68 66 6d 74 20	 push	 544501094		; 20746d66H
  0003a	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	52		 push	 edx
  0003e	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 c0 08	 add	 eax, 8
  00044	50		 push	 eax
  00045	8d 4d e0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00048	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  0004d	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1094 : 
; 1095 :     if(SUCCEEDED(hr))

  00050	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00054	7c 38		 jl	 SHORT $L50450

; 1096 :     {
; 1097 :         dwValidSize = FormatChunk.GetDataSize();

  00056	8d 4d e0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00059	e8 00 00 00 00	 call	 ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ; WaveLoader::CRiffChunk::GetDataSize
  0005e	89 45 f8	 mov	 DWORD PTR _dwValidSize$[ebp], eax

; 1098 : 
; 1099 :         hr = FormatChunk.Read(0, pwfxFormat, min(dwValidSize, dwFormatSize));

  00061	8b 4d f8	 mov	 ecx, DWORD PTR _dwValidSize$[ebp]
  00064	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwFormatSize$[ebp]
  00067	73 08		 jae	 SHORT $L51822
  00069	8b 55 f8	 mov	 edx, DWORD PTR _dwValidSize$[ebp]
  0006c	89 55 d4	 mov	 DWORD PTR -44+[ebp], edx
  0006f	eb 06		 jmp	 SHORT $L51823
$L51822:
  00071	8b 45 0c	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  00074	89 45 d4	 mov	 DWORD PTR -44+[ebp], eax
$L51823:
  00077	6a 00		 push	 0
  00079	8b 4d d4	 mov	 ecx, DWORD PTR -44+[ebp]
  0007c	51		 push	 ecx
  0007d	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  00080	52		 push	 edx
  00081	6a 00		 push	 0
  00083	8d 4d e0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00086	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  0008b	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L50450:

; 1100 :     }
; 1101 : 
; 1102 :     if(SUCCEEDED(hr) && (dwFormatSize > dwValidSize))

  0008e	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00092	7c 20		 jl	 SHORT $L50452
  00094	8b 45 0c	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  00097	3b 45 f8	 cmp	 eax, DWORD PTR _dwValidSize$[ebp]
  0009a	76 18		 jbe	 SHORT $L50452

; 1103 :     {
; 1104 :         ZeroMemory((LPBYTE)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize);

  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFormatSize$[ebp]
  0009f	2b 4d f8	 sub	 ecx, DWORD PTR _dwValidSize$[ebp]
  000a2	51		 push	 ecx
  000a3	6a 00		 push	 0
  000a5	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  000a8	03 55 f8	 add	 edx, DWORD PTR _dwValidSize$[ebp]
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 _memset
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
$L50452:

; 1105 :     }
; 1106 : 
; 1107 :     if(SUCCEEDED(hr) && pdwRequiredSize)

  000b4	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b8	7c 23		 jl	 SHORT $L50455
  000ba	83 7d 10 00	 cmp	 DWORD PTR _pdwRequiredSize$[ebp], 0
  000be	74 1d		 je	 SHORT $L50455

; 1108 :     {
; 1109 :         *pdwRequiredSize = max(dwValidSize, sizeof(*pwfxFormat));

  000c0	83 7d f8 12	 cmp	 DWORD PTR _dwValidSize$[ebp], 18 ; 00000012H
  000c4	76 08		 jbe	 SHORT $L51824
  000c6	8b 45 f8	 mov	 eax, DWORD PTR _dwValidSize$[ebp]
  000c9	89 45 d0	 mov	 DWORD PTR -48+[ebp], eax
  000cc	eb 07		 jmp	 SHORT $L51825
$L51824:
  000ce	c7 45 d0 12 00
	00 00		 mov	 DWORD PTR -48+[ebp], 18	; 00000012H
$L51825:
  000d5	8b 4d 10	 mov	 ecx, DWORD PTR _pdwRequiredSize$[ebp]
  000d8	8b 55 d0	 mov	 edx, DWORD PTR -48+[ebp]
  000db	89 11		 mov	 DWORD PTR [ecx], edx
$L50455:

; 1110 :     }
; 1111 : 
; 1112 :     DPF_LEAVE_HRESULT(hr);
; 1113 : 
; 1114 :     return hr;

  000dd	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  000e0	89 45 dc	 mov	 DWORD PTR $T51826[ebp], eax
  000e3	8d 4d e0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  000e6	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  000eb	8b 45 dc	 mov	 eax, DWORD PTR $T51826[ebp]

; 1115 : }

  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 0c 00	 ret	 12			; 0000000cH
?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ENDP ; WaveLoader::CWaveFile::GetWaveFormat
_TEXT	ENDS
PUBLIC	??_C@_0CG@DNJG@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@ ; `string'
PUBLIC	??_C@_0BJ@KIEA@CWaveFile?3?3GetAiffFormat?$AA@	; `string'
PUBLIC	??_C@_0CC@IGMG@Unsupported?5AIFF?5compression?5typ@ ; `string'
;	COMDAT ??_C@_0CG@DNJG@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@
CONST	SEGMENT
??_C@_0CG@DNJG@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@ DB 'WAVELDR_FILE'
	DB	'TYPE_AIFF == m_dwFileType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KIEA@CWaveFile?3?3GetAiffFormat?$AA@
CONST	SEGMENT
??_C@_0BJ@KIEA@CWaveFile?3?3GetAiffFormat?$AA@ DB 'CWaveFile::GetAiffForm'
	DB	'at', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IGMG@Unsupported?5AIFF?5compression?5typ@
CONST	SEGMENT
??_C@_0CC@IGMG@Unsupported?5AIFF?5compression?5typ@ DB 'Unsupported AIFF '
	DB	'compression type', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
_TEXT	SEGMENT
$T51834 = -76
_pwfxFormat$ = 8
_dwFormatSize$ = 12
_pdwRequiredSize$ = 16
_this$ = -80
_hr$ = -4
_FormatChunk$ = -72
_dwValidSize$ = -8
_AiffFormat$ = -48
_WaveFormat$ = -28
?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z PROC NEAR ; WaveLoader::CWaveFile::GetAiffFormat, COMDAT
; _this$ = ecx

; 1145 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 1146 :     HRESULT                 hr          = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1147 :     CRiffChunk              FormatChunk;

  00010	8d 4d b8	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1148 :     DWORD                   dwValidSize;
; 1149 :     AIFFFORMAT              AiffFormat;
; 1150 :     WAVEFORMATEX            WaveFormat;
; 1151 : 
; 1152 :     DPF_ENTER();
; 1153 : 
; 1154 :     ASSERT(WAVELDR_FILETYPE_AIFF == m_dwFileType);

  00018	68 82 04 00 00	 push	 1154			; 00000482H
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00022	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@DNJG@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@ ; `string'
  00027	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	33 c9		 xor	 ecx, ecx
  0002c	83 78 38 01	 cmp	 DWORD PTR [eax+56], 1
  00030	0f 95 c1	 setne	 cl
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00039	83 c4 10	 add	 esp, 16			; 00000010H

; 1155 : 
; 1156 :     if(pwfxFormat && dwFormatSize)

  0003c	83 7d 08 00	 cmp	 DWORD PTR _pwfxFormat$[ebp], 0
  00040	0f 84 94 01 00
	00		 je	 $L50470
  00046	83 7d 0c 00	 cmp	 DWORD PTR _dwFormatSize$[ebp], 0
  0004a	0f 84 8a 01 00
	00		 je	 $L50470

; 1157 :     {
; 1158 :         //
; 1159 :         // Open the format chunk
; 1160 :         //
; 1161 : 
; 1162 :         hr = FormatChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_COMM);

  00050	68 43 4f 4d 4d	 push	 1296912195		; 4d4d4f43H
  00055	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00058	52		 push	 edx
  00059	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 c0 08	 add	 eax, 8
  0005f	50		 push	 eax
  00060	8d 4d b8	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00063	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00068	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1163 :         
; 1164 :         //
; 1165 :         // Read the base format data
; 1166 :         //
; 1167 : 
; 1168 :         if(SUCCEEDED(hr))

  0006b	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006f	7c 37		 jl	 SHORT $L50472

; 1169 :         {
; 1170 :             dwValidSize = FormatChunk.GetDataSize();

  00071	8d 4d b8	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00074	e8 00 00 00 00	 call	 ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ; WaveLoader::CRiffChunk::GetDataSize
  00079	89 45 f8	 mov	 DWORD PTR _dwValidSize$[ebp], eax

; 1171 : 
; 1172 :             hr = FormatChunk.Read(0, &AiffFormat, min(sizeof(AiffFormat), dwValidSize));

  0007c	83 7d f8 14	 cmp	 DWORD PTR _dwValidSize$[ebp], 20 ; 00000014H
  00080	76 09		 jbe	 SHORT $L51830
  00082	c7 45 ac 14 00
	00 00		 mov	 DWORD PTR -84+[ebp], 20	; 00000014H
  00089	eb 06		 jmp	 SHORT $L51831
$L51830:
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _dwValidSize$[ebp]
  0008e	89 4d ac	 mov	 DWORD PTR -84+[ebp], ecx
$L51831:
  00091	6a 00		 push	 0
  00093	8b 55 ac	 mov	 edx, DWORD PTR -84+[ebp]
  00096	52		 push	 edx
  00097	8d 45 d0	 lea	 eax, DWORD PTR _AiffFormat$[ebp]
  0009a	50		 push	 eax
  0009b	6a 00		 push	 0
  0009d	8d 4d b8	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  000a0	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  000a5	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L50472:

; 1173 :         }
; 1174 : 
; 1175 :         if(SUCCEEDED(hr) && (sizeof(AiffFormat) > dwValidSize))

  000a8	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ac	7c 21		 jl	 SHORT $L50474
  000ae	83 7d f8 14	 cmp	 DWORD PTR _dwValidSize$[ebp], 20 ; 00000014H
  000b2	73 1b		 jae	 SHORT $L50474

; 1176 :         {
; 1177 :             ZeroMemory((LPBYTE)&AiffFormat + dwValidSize, sizeof(AiffFormat) - dwValidSize);

  000b4	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  000b9	2b 4d f8	 sub	 ecx, DWORD PTR _dwValidSize$[ebp]
  000bc	51		 push	 ecx
  000bd	6a 00		 push	 0
  000bf	8b 55 f8	 mov	 edx, DWORD PTR _dwValidSize$[ebp]
  000c2	8d 44 15 d0	 lea	 eax, DWORD PTR _AiffFormat$[ebp+edx]
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _memset
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH
$L50474:

; 1178 :         }
; 1179 : 
; 1180 :         //
; 1181 :         // If no compression type is specified, assume PCM
; 1182 :         //
; 1183 : 
; 1184 :         if(SUCCEEDED(hr) && !AiffFormat.dwCompression)

  000cf	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000d3	7c 0d		 jl	 SHORT $L50477
  000d5	83 7d e0 00	 cmp	 DWORD PTR _AiffFormat$[ebp+16], 0
  000d9	75 07		 jne	 SHORT $L50477

; 1185 :         {
; 1186 :             AiffFormat.dwCompression = WAVELDR_FOURCC_NONE;

  000db	c7 45 e0 4e 4f
	4e 45		 mov	 DWORD PTR _AiffFormat$[ebp+16], 1162760014 ; 454e4f4eH
$L50477:

; 1187 :         }
; 1188 : 
; 1189 :         //
; 1190 :         // Currently, only PCM is supported
; 1191 :         //
; 1192 : 
; 1193 :         if(SUCCEEDED(hr) && (WAVELDR_FOURCC_NONE != AiffFormat.dwCompression))

  000e2	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000e6	7c 3d		 jl	 SHORT $L50479
  000e8	81 7d e0 4e 4f
	4e 45		 cmp	 DWORD PTR _AiffFormat$[ebp+16], 1162760014 ; 454e4f4eH
  000ef	74 34		 je	 SHORT $L50479

; 1194 :         {
; 1195 :             DPF_ERROR("Unsupported AIFF compression type");

  000f1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@KIEA@CWaveFile?3?3GetAiffFormat?$AA@ ; `string'
  000fb	68 ab 04 00 00	 push	 1195			; 000004abH
  00100	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00105	6a 04		 push	 4
  00107	6a 09		 push	 9
  00109	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0010e	83 c4 18	 add	 esp, 24			; 00000018H
  00111	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@IGMG@Unsupported?5AIFF?5compression?5typ@ ; `string'
  00116	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0011b	83 c4 04	 add	 esp, 4

; 1196 :             hr = E_FAIL;

  0011e	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50479:

; 1197 :         }
; 1198 : 
; 1199 :         //
; 1200 :         // Convert AIFF format to WAVE format
; 1201 :         //
; 1202 : 
; 1203 :         if(SUCCEEDED(hr))

  00125	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00129	7c 5c		 jl	 SHORT $L50484

; 1204 :         {
; 1205 :             AiffFormat.nChannels = EndianSwapWord(AiffFormat.nChannels);

  0012b	8b 4d d0	 mov	 ecx, DWORD PTR _AiffFormat$[ebp]
  0012e	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  00133	66 89 45 d0	 mov	 WORD PTR _AiffFormat$[ebp], ax

; 1206 :             AiffFormat.wBitsPerSample = EndianSwapWord(AiffFormat.wBitsPerSample);

  00137	8b 4d d6	 mov	 ecx, DWORD PTR _AiffFormat$[ebp+6]
  0013a	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0013f	66 89 45 d6	 mov	 WORD PTR _AiffFormat$[ebp+6], ax

; 1207 :             AiffFormat.wFrequencyExponent = EndianSwapWord(AiffFormat.wFrequencyExponent);

  00143	8b 4d d8	 mov	 ecx, DWORD PTR _AiffFormat$[ebp+8]
  00146	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0014b	66 89 45 d8	 mov	 WORD PTR _AiffFormat$[ebp+8], ax

; 1208 :             AiffFormat.dwFrequencyMantissa = EndianSwapDword(AiffFormat.dwFrequencyMantissa);

  0014f	8b 4d da	 mov	 ecx, DWORD PTR _AiffFormat$[ebp+10]
  00152	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  00157	89 45 da	 mov	 DWORD PTR _AiffFormat$[ebp+10], eax

; 1209 : 
; 1210 :             XAudioCreatePcmFormat(AiffFormat.nChannels, AiffFormat.dwFrequencyMantissa >> (16414 - (AiffFormat.wFrequencyExponent & 0x7FFF)), AiffFormat.wBitsPerSample, &WaveFormat);

  0015a	8d 4d e4	 lea	 ecx, DWORD PTR _WaveFormat$[ebp]
  0015d	51		 push	 ecx
  0015e	66 8b 55 d6	 mov	 dx, WORD PTR _AiffFormat$[ebp+6]
  00162	52		 push	 edx
  00163	8b 45 d8	 mov	 eax, DWORD PTR _AiffFormat$[ebp+8]
  00166	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0016b	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  00170	b9 1e 40 00 00	 mov	 ecx, 16414		; 0000401eH
  00175	2b c8		 sub	 ecx, eax
  00177	8b 55 da	 mov	 edx, DWORD PTR _AiffFormat$[ebp+10]
  0017a	d3 ea		 shr	 edx, cl
  0017c	52		 push	 edx
  0017d	66 8b 45 d0	 mov	 ax, WORD PTR _AiffFormat$[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 ?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::CreatePcmFormat
$L50484:

; 1211 :         }
; 1212 : 
; 1213 :         if(SUCCEEDED(hr))

  00187	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0018b	7c 29		 jl	 SHORT $L50486

; 1214 :         {
; 1215 :             CopyMemory(pwfxFormat, &WaveFormat, min(sizeof(WaveFormat), dwFormatSize));

  0018d	83 7d 0c 12	 cmp	 DWORD PTR _dwFormatSize$[ebp], 18 ; 00000012H
  00191	76 09		 jbe	 SHORT $L51832
  00193	c7 45 a8 12 00
	00 00		 mov	 DWORD PTR -88+[ebp], 18	; 00000012H
  0019a	eb 06		 jmp	 SHORT $L51833
$L51832:
  0019c	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFormatSize$[ebp]
  0019f	89 4d a8	 mov	 DWORD PTR -88+[ebp], ecx
$L51833:
  001a2	8b 55 a8	 mov	 edx, DWORD PTR -88+[ebp]
  001a5	52		 push	 edx
  001a6	8d 45 e4	 lea	 eax, DWORD PTR _WaveFormat$[ebp]
  001a9	50		 push	 eax
  001aa	8b 4d 08	 mov	 ecx, DWORD PTR _pwfxFormat$[ebp]
  001ad	51		 push	 ecx
  001ae	e8 00 00 00 00	 call	 _memcpy
  001b3	83 c4 0c	 add	 esp, 12			; 0000000cH
$L50486:

; 1216 :         }
; 1217 : 
; 1218 :         if(SUCCEEDED(hr) && (dwFormatSize > sizeof(WaveFormat)))

  001b6	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001ba	7c 1e		 jl	 SHORT $L50488
  001bc	83 7d 0c 12	 cmp	 DWORD PTR _dwFormatSize$[ebp], 18 ; 00000012H
  001c0	76 18		 jbe	 SHORT $L50488

; 1219 :         {
; 1220 :             ZeroMemory((LPBYTE)pwfxFormat + sizeof(WaveFormat), dwFormatSize - sizeof(WaveFormat));

  001c2	8b 55 0c	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  001c5	83 ea 12	 sub	 edx, 18			; 00000012H
  001c8	52		 push	 edx
  001c9	6a 00		 push	 0
  001cb	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  001ce	83 c0 12	 add	 eax, 18			; 00000012H
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 _memset
  001d7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L50488:
$L50470:

; 1221 :         }
; 1222 :     }
; 1223 :     
; 1224 :     if(SUCCEEDED(hr) && pdwRequiredSize)

  001da	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001de	7c 0f		 jl	 SHORT $L50491
  001e0	83 7d 10 00	 cmp	 DWORD PTR _pdwRequiredSize$[ebp], 0
  001e4	74 09		 je	 SHORT $L50491

; 1225 :     {
; 1226 :         *pdwRequiredSize = sizeof(WaveFormat);

  001e6	8b 4d 10	 mov	 ecx, DWORD PTR _pdwRequiredSize$[ebp]
  001e9	c7 01 12 00 00
	00		 mov	 DWORD PTR [ecx], 18	; 00000012H
$L50491:

; 1227 :     }
; 1228 : 
; 1229 :     DPF_LEAVE_HRESULT(hr);
; 1230 : 
; 1231 :     return hr;

  001ef	8b 55 fc	 mov	 edx, DWORD PTR _hr$[ebp]
  001f2	89 55 b4	 mov	 DWORD PTR $T51834[ebp], edx
  001f5	8d 4d b8	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  001f8	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  001fd	8b 45 b4	 mov	 eax, DWORD PTR $T51834[ebp]

; 1232 : }

  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c2 0c 00	 ret	 12			; 0000000cH
?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ENDP ; WaveLoader::CWaveFile::GetAiffFormat
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?EndianSwapWord@@YIGG@Z
_TEXT	SEGMENT
_n$ = -4
?EndianSwapWord@@YIGG@Z PROC NEAR			; EndianSwapWord, COMDAT
; _n$ = cx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	66 89 4d fc	 mov	 WORD PTR _n$[ebp], cx

; 40   :     __asm
; 41   :     {
; 42   :         mov     eax, ecx

  00009	8b c1		 mov	 eax, ecx

; 43   :         sar     eax, 8

  0000b	c1 f8 08	 sar	 eax, 8

; 44   :         and     eax, 0ffh

  0000e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 45   : 
; 46   :         mov     ebx, ecx

  00013	8b d9		 mov	 ebx, ecx

; 47   :         shl     ebx, 8

  00015	c1 e3 08	 shl	 ebx, 8

; 48   :         and     ebx, 0ff00h

  00018	81 e3 00 ff 00
	00		 and	 ebx, 65280		; 0000ff00H

; 49   :         or      eax, ebx

  0001e	0b c3		 or	 eax, ebx

; 50   :     }
; 51   : }

  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?EndianSwapWord@@YIGG@Z ENDP				; EndianSwapWord
_TEXT	ENDS
PUBLIC	?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetWaveLoopRegion
PUBLIC	?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetAiffLoopRegion
; Function compile flags: /Odt
;	COMDAT ?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z
_TEXT	SEGMENT
_pdwLoopStart$ = 8
_pdwLoopLength$ = 12
_this$ = -8
_hr$ = -4
?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z PROC NEAR ; WaveLoader::CWaveFile::GetLoopRegion, COMDAT
; _this$ = ecx

; 1260 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1261 :     HRESULT                 hr;
; 1262 : 
; 1263 :     DPF_ENTER();
; 1264 : 
; 1265 :     ASSERT(m_pwfxFormat);

  00009	68 f1 04 00 00	 push	 1265			; 000004f1H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@OAHJ@m_pwfxFormat?$AA@ ; `string'
  00018	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	33 c9		 xor	 ecx, ecx
  0001d	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00021	0f 94 c1	 sete	 cl
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 1266 : 
; 1267 :     //
; 1268 :     // Read loop region data in samples
; 1269 :     //
; 1270 : 
; 1271 :     if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  0002d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00030	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00034	75 15		 jne	 SHORT $L50499

; 1272 :     {
; 1273 :         hr = GetWaveLoopRegion(pdwLoopStart, pdwLoopLength);

  00036	8b 45 0c	 mov	 eax, DWORD PTR _pdwLoopLength$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetWaveLoopRegion
  00046	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1274 :     }
; 1275 :     else

  00049	eb 13		 jmp	 SHORT $L50500
$L50499:

; 1276 :     {
; 1277 :         hr = GetAiffLoopRegion(pdwLoopStart, pdwLoopLength);

  0004b	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  0004e	52		 push	 edx
  0004f	8b 45 08	 mov	 eax, DWORD PTR _pdwLoopStart$[ebp]
  00052	50		 push	 eax
  00053	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetAiffLoopRegion
  0005b	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L50500:

; 1278 :     }
; 1279 : 
; 1280 :     //
; 1281 :     // Convert to bytes
; 1282 :     //
; 1283 : 
; 1284 :     if(SUCCEEDED(hr))

  0005e	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00062	0f 8c b8 00 00
	00		 jl	 $L50502

; 1285 :     {
; 1286 :         if(WAVE_FORMAT_XBOX_ADPCM == m_pwfxFormat->wFormatTag)

  00068	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0006e	33 c0		 xor	 eax, eax
  00070	66 8b 02	 mov	 ax, WORD PTR [edx]
  00073	83 f8 69	 cmp	 eax, 105		; 00000069H
  00076	75 76		 jne	 SHORT $L50503

; 1287 :         {
; 1288 :             *pdwLoopStart /= m_pwfxFormat->nChannels * XBOX_ADPCM_SAMPLES_PER_BLOCK;

  00078	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0007e	33 c0		 xor	 eax, eax
  00080	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00084	8b c8		 mov	 ecx, eax
  00086	c1 e1 06	 shl	 ecx, 6
  00089	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  0008c	8b 02		 mov	 eax, DWORD PTR [edx]
  0008e	33 d2		 xor	 edx, edx
  00090	f7 f1		 div	 ecx
  00092	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  00095	89 01		 mov	 DWORD PTR [ecx], eax

; 1289 :             *pdwLoopStart *= m_pwfxFormat->nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  00097	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0009a	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0009d	33 c9		 xor	 ecx, ecx
  0009f	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  000a3	6b c9 24	 imul	 ecx, 36			; 00000024H
  000a6	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  000a9	8b 02		 mov	 eax, DWORD PTR [edx]
  000ab	0f af c1	 imul	 eax, ecx
  000ae	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax

; 1290 : 
; 1291 :             *pdwLoopLength /= m_pwfxFormat->nChannels * XBOX_ADPCM_SAMPLES_PER_BLOCK;

  000b3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000b6	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000b9	33 c9		 xor	 ecx, ecx
  000bb	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  000bf	c1 e1 06	 shl	 ecx, 6
  000c2	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  000c5	8b 02		 mov	 eax, DWORD PTR [edx]
  000c7	33 d2		 xor	 edx, edx
  000c9	f7 f1		 div	 ecx
  000cb	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwLoopLength$[ebp]
  000ce	89 01		 mov	 DWORD PTR [ecx], eax

; 1292 :             *pdwLoopLength *= m_pwfxFormat->nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  000d0	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000d3	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000d6	33 c9		 xor	 ecx, ecx
  000d8	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  000dc	6b c9 24	 imul	 ecx, 36			; 00000024H
  000df	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  000e2	8b 02		 mov	 eax, DWORD PTR [edx]
  000e4	0f af c1	 imul	 eax, ecx
  000e7	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwLoopLength$[ebp]
  000ea	89 01		 mov	 DWORD PTR [ecx], eax

; 1293 :         }
; 1294 :         else

  000ec	eb 32		 jmp	 SHORT $L50504
$L50503:

; 1295 :         {
; 1296 :             *pdwLoopStart *= m_pwfxFormat->nBlockAlign;

  000ee	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000f1	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000f4	33 c9		 xor	 ecx, ecx
  000f6	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  000fa	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	0f af c1	 imul	 eax, ecx
  00102	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  00105	89 01		 mov	 DWORD PTR [ecx], eax

; 1297 :             *pdwLoopLength *= m_pwfxFormat->nBlockAlign;

  00107	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0010a	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0010d	33 c9		 xor	 ecx, ecx
  0010f	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  00113	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  00116	8b 02		 mov	 eax, DWORD PTR [edx]
  00118	0f af c1	 imul	 eax, ecx
  0011b	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwLoopLength$[ebp]
  0011e	89 01		 mov	 DWORD PTR [ecx], eax
$L50504:
$L50502:

; 1298 :         }
; 1299 :     }
; 1300 : 
; 1301 :     DPF_LEAVE_HRESULT(hr);
; 1302 : 
; 1303 :     return hr;

  00120	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1304 : }

  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c2 08 00	 ret	 8
?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z ENDP	; WaveLoader::CWaveFile::GetLoopRegion
_TEXT	ENDS
PUBLIC	??_C@_0CC@FFJO@CStdFileStream?3?3GetWaveLoopRegio@ ; `string'
PUBLIC	??_C@_0BO@EIKN@No?5FORWARD?5loop?5regions?5found?$AA@ ; `string'
PUBLIC	??_C@_0CJ@ENEM@Only?5the?5first?5FORWARD?5loop?5will@ ; `string'
;	COMDAT ??_C@_0CC@FFJO@CStdFileStream?3?3GetWaveLoopRegio@
CONST	SEGMENT
??_C@_0CC@FFJO@CStdFileStream?3?3GetWaveLoopRegio@ DB 'CStdFileStream::Ge'
	DB	'tWaveLoopRegion', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EIKN@No?5FORWARD?5loop?5regions?5found?$AA@
CONST	SEGMENT
??_C@_0BO@EIKN@No?5FORWARD?5loop?5regions?5found?$AA@ DB 'No FORWARD loop'
	DB	' regions found', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@ENEM@Only?5the?5first?5FORWARD?5loop?5will@
CONST	SEGMENT
??_C@_0CJ@ENEM@Only?5the?5first?5FORWARD?5loop?5will@ DB 'Only the first '
	DB	'FORWARD loop will be used', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
_TEXT	SEGMENT
$T51844 = -72
_pdwLoopStart$ = 8
_pdwLoopLength$ = 12
_this$ = -76
_InstrumentChunk$ = -68
_wsamp$ = -20
_loop$ = -36
_dwOffset$ = -44
_hr$ = -40
?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z PROC NEAR ; WaveLoader::CWaveFile::GetWaveLoopRegion, COMDAT
; _this$ = ecx

; 1332 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 1333 :     CRiffChunk              InstrumentChunk;

  00009	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1334 :     WAVESAMPLE              wsamp;
; 1335 :     WAVESAMPLE_LOOP         loop;
; 1336 :     DWORD                   dwOffset;
; 1337 :     HRESULT                 hr;
; 1338 : 
; 1339 :     DPF_ENTER();
; 1340 : 
; 1341 :     ASSERT(m_pwfxFormat);

  00011	68 3d 05 00 00	 push	 1341			; 0000053dH
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@OAHJ@m_pwfxFormat?$AA@ ; `string'
  00020	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00023	33 c9		 xor	 ecx, ecx
  00025	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00029	0f 94 c1	 sete	 cl
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 1342 : 
; 1343 :     //
; 1344 :     // Open the instrument chunk
; 1345 :     //
; 1346 : 
; 1347 :     hr = InstrumentChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_WAVE_SAMPLE);

  00035	68 77 73 6d 70	 push	 1886221175		; 706d7377H
  0003a	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	52		 push	 edx
  0003e	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 c0 08	 add	 eax, 8
  00044	50		 push	 eax
  00045	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00048	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  0004d	89 45 d8	 mov	 DWORD PTR _hr$[ebp], eax

; 1348 : 
; 1349 :     //
; 1350 :     // Read the WAVESAMPLE header and first loop region
; 1351 :     //
; 1352 : 
; 1353 :     if(SUCCEEDED(hr))

  00050	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00054	7c 15		 jl	 SHORT $L50516

; 1354 :     {
; 1355 :         hr = InstrumentChunk.Read(0, &wsamp, sizeof(wsamp));

  00056	6a 00		 push	 0
  00058	6a 14		 push	 20			; 00000014H
  0005a	8d 4d ec	 lea	 ecx, DWORD PTR _wsamp$[ebp]
  0005d	51		 push	 ecx
  0005e	6a 00		 push	 0
  00060	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00063	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00068	89 45 d8	 mov	 DWORD PTR _hr$[ebp], eax
$L50516:

; 1356 :     }
; 1357 : 
; 1358 :     //
; 1359 :     // Scan loop regions until we find one that's FORWARD or RELEASE
; 1360 :     //
; 1361 : 
; 1362 :     if(SUCCEEDED(hr))

  0006b	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006f	7c 52		 jl	 SHORT $L50518

; 1363 :     {
; 1364 :         dwOffset = sizeof(wsamp);

  00071	c7 45 d4 14 00
	00 00		 mov	 DWORD PTR _dwOffset$[ebp], 20 ; 00000014H
$L50520:

; 1365 :     
; 1366 :         while(SUCCEEDED(hr) && wsamp.dwSampleLoops)

  00078	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0007c	7c 45		 jl	 SHORT $L50521
  0007e	83 7d fc 00	 cmp	 DWORD PTR _wsamp$[ebp+16], 0
  00082	74 3f		 je	 SHORT $L50521

; 1367 :         {
; 1368 :             hr = InstrumentChunk.Read(dwOffset, &loop, sizeof(loop));

  00084	6a 00		 push	 0
  00086	6a 10		 push	 16			; 00000010H
  00088	8d 55 dc	 lea	 edx, DWORD PTR _loop$[ebp]
  0008b	52		 push	 edx
  0008c	8b 45 d4	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  0008f	50		 push	 eax
  00090	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00093	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00098	89 45 d8	 mov	 DWORD PTR _hr$[ebp], eax

; 1369 : 
; 1370 :             if(SUCCEEDED(hr))

  0009b	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0009f	7c 0e		 jl	 SHORT $L50524

; 1371 :             {
; 1372 :                 if((WAVESAMPLE_LOOPTYPE_FORWARD == loop.dwLoopType) || (WAVESAMPLE_LOOPTYPE_RELEASE == loop.dwLoopType))

  000a1	83 7d e0 00	 cmp	 DWORD PTR _loop$[ebp+4], 0
  000a5	74 06		 je	 SHORT $L50526
  000a7	83 7d e0 01	 cmp	 DWORD PTR _loop$[ebp+4], 1
  000ab	75 02		 jne	 SHORT $L50525
$L50526:

; 1373 :                 {
; 1374 :                     break;

  000ad	eb 14		 jmp	 SHORT $L50521
$L50525:
$L50524:

; 1375 :                 }
; 1376 :             }
; 1377 :         
; 1378 :             dwOffset += sizeof(loop);

  000af	8b 4d d4	 mov	 ecx, DWORD PTR _dwOffset$[ebp]
  000b2	83 c1 10	 add	 ecx, 16			; 00000010H
  000b5	89 4d d4	 mov	 DWORD PTR _dwOffset$[ebp], ecx

; 1379 : 
; 1380 :             wsamp.dwSampleLoops--;

  000b8	8b 55 fc	 mov	 edx, DWORD PTR _wsamp$[ebp+16]
  000bb	83 ea 01	 sub	 edx, 1
  000be	89 55 fc	 mov	 DWORD PTR _wsamp$[ebp+16], edx

; 1381 :         }

  000c1	eb b5		 jmp	 SHORT $L50520
$L50521:
$L50518:

; 1382 :     }
; 1383 : 
; 1384 :     if(SUCCEEDED(hr))

  000c3	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000c7	7c 6f		 jl	 SHORT $L50528

; 1385 :     {
; 1386 :         if(!wsamp.dwSampleLoops)

  000c9	83 7d fc 00	 cmp	 DWORD PTR _wsamp$[ebp+16], 0
  000cd	75 36		 jne	 SHORT $L50529

; 1387 :         {
; 1388 :             DPF_ERROR("No FORWARD loop regions found");

  000cf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  000d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@FFJO@CStdFileStream?3?3GetWaveLoopRegio@ ; `string'
  000d9	68 6c 05 00 00	 push	 1388			; 0000056cH
  000de	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000e3	6a 04		 push	 4
  000e5	6a 09		 push	 9
  000e7	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000ec	83 c4 18	 add	 esp, 24			; 00000018H
  000ef	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@EIKN@No?5FORWARD?5loop?5regions?5found?$AA@ ; `string'
  000f4	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000f9	83 c4 04	 add	 esp, 4

; 1389 :             hr = E_FAIL;

  000fc	c7 45 d8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1390 :         }
; 1391 :         else if(wsamp.dwSampleLoops > 1)

  00103	eb 33		 jmp	 SHORT $L50533
$L50529:
  00105	83 7d fc 01	 cmp	 DWORD PTR _wsamp$[ebp+16], 1
  00109	76 2d		 jbe	 SHORT $L50534

; 1392 :         {
; 1393 :             DPF_WARNING("Only the first FORWARD loop will be used");

  0010b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00110	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@FFJO@CStdFileStream?3?3GetWaveLoopRegio@ ; `string'
  00115	68 71 05 00 00	 push	 1393			; 00000571H
  0011a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0011f	6a 04		 push	 4
  00121	6a 09		 push	 9
  00123	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00128	83 c4 18	 add	 esp, 24			; 00000018H
  0012b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@ENEM@Only?5the?5first?5FORWARD?5loop?5will@ ; `string'
  00130	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00135	83 c4 04	 add	 esp, 4
$L50534:
$L50533:
$L50528:

; 1394 :         }
; 1395 :     }
; 1396 : 
; 1397 :     //
; 1398 :     // Success
; 1399 :     //
; 1400 : 
; 1401 :     if(SUCCEEDED(hr))

  00138	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0013c	7c 10		 jl	 SHORT $L50537

; 1402 :     {
; 1403 :         *pdwLoopStart = loop.dwLoopStart;

  0013e	8b 45 08	 mov	 eax, DWORD PTR _pdwLoopStart$[ebp]
  00141	8b 4d e4	 mov	 ecx, DWORD PTR _loop$[ebp+8]
  00144	89 08		 mov	 DWORD PTR [eax], ecx

; 1404 :         *pdwLoopLength = loop.dwLoopLength;

  00146	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  00149	8b 45 e8	 mov	 eax, DWORD PTR _loop$[ebp+12]
  0014c	89 02		 mov	 DWORD PTR [edx], eax
$L50537:

; 1405 :     }
; 1406 : 
; 1407 :     DPF_LEAVE_HRESULT(hr);
; 1408 : 
; 1409 :     return hr;

  0014e	8b 4d d8	 mov	 ecx, DWORD PTR _hr$[ebp]
  00151	89 4d b8	 mov	 DWORD PTR $T51844[ebp], ecx
  00154	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00157	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  0015c	8b 45 b8	 mov	 eax, DWORD PTR $T51844[ebp]

; 1410 : }

  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c2 08 00	 ret	 8
?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ENDP ; WaveLoader::CWaveFile::GetWaveLoopRegion
_TEXT	ENDS
PUBLIC	??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@ ; `string'
PUBLIC	??_C@_0BI@EGGG@Neither?5loop?5is?5FORWARD?$AA@	; `string'
PUBLIC	??_C@_0DF@PJLL@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@ ; `string'
PUBLIC	??_C@_0BN@INFE@Can?8t?5find?5loop?5start?5marker?$AA@ ; `string'
PUBLIC	??_C@_0DD@DPMK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@ ; `string'
PUBLIC	??_C@_0BL@IHKN@Can?8t?5find?5loop?5end?5marker?$AA@ ; `string'
PUBLIC	??_C@_0DB@DCLE@Loop?5end?5point?5less?9than?9or?9equa@ ; `string'
;	COMDAT ??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@
CONST	SEGMENT
??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@ DB 'CStdFileStream::Ge'
	DB	'tAiffLoopRegion', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EGGG@Neither?5loop?5is?5FORWARD?$AA@
CONST	SEGMENT
??_C@_0BI@EGGG@Neither?5loop?5is?5FORWARD?$AA@ DB 'Neither loop is FORWAR'
	DB	'D', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PJLL@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@
CONST	SEGMENT
??_C@_0DF@PJLL@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@ DB '(DW'
	DB	'ORD)pStartMarker < (DWORD)pMarkers + dwMarkerSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@INFE@Can?8t?5find?5loop?5start?5marker?$AA@
CONST	SEGMENT
??_C@_0BN@INFE@Can?8t?5find?5loop?5start?5marker?$AA@ DB 'Can''t find loo'
	DB	'p start marker', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@DPMK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@
CONST	SEGMENT
??_C@_0DD@DPMK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@ DB '(DW'
	DB	'ORD)pEndMarker < (DWORD)pMarkers + dwMarkerSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKN@Can?8t?5find?5loop?5end?5marker?$AA@
CONST	SEGMENT
??_C@_0BL@IHKN@Can?8t?5find?5loop?5end?5marker?$AA@ DB 'Can''t find loop '
	DB	'end marker', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@DCLE@Loop?5end?5point?5less?9than?9or?9equa@
CONST	SEGMENT
??_C@_0DB@DCLE@Loop?5end?5point?5less?9than?9or?9equa@ DB 'Loop end point'
	DB	' less-than-or-equal-to start point', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
_TEXT	SEGMENT
$T51848 = -104
_pdwLoopStart$ = 8
_pdwLoopLength$ = 12
_this$ = -108
_pMarkers$ = -92
_InstrumentChunk$ = -88
_inst$ = -24
_pLoop$ = -60
_MarkerChunk$ = -48
_dwMarkerSize$ = -56
_pStartMarker$ = -100
_pEndMarker$ = -52
_hr$ = -64
_i$ = -94
?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z PROC NEAR ; WaveLoader::CWaveFile::GetAiffLoopRegion, COMDAT
; _this$ = ecx

; 1438 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	89 4d 94	 mov	 DWORD PTR _this$[ebp], ecx

; 1439 :     LPAIFFMARKERHDR         pMarkers            = NULL;

  00009	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _pMarkers$[ebp], 0

; 1440 :     CRiffChunk              InstrumentChunk;

  00010	8d 4d a8	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1441 :     AIFFINSTRUMENT          inst;
; 1442 :     LPAIFFLOOP              pLoop;
; 1443 :     CRiffChunk              MarkerChunk;

  00018	8d 4d d0	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1444 :     DWORD                   dwMarkerSize;
; 1445 :     AIFFMARKERHDR           MarkerHeader;
; 1446 :     LPAIFFMARKER            pStartMarker;
; 1447 :     LPAIFFMARKER            pEndMarker;
; 1448 :     HRESULT                 hr;
; 1449 :     WORD                    i;
; 1450 : 
; 1451 :     DPF_ENTER();
; 1452 : 
; 1453 :     //
; 1454 :     // Open the instrument chunk
; 1455 :     //
; 1456 : 
; 1457 :     hr = InstrumentChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_INSTRUMENT);

  00020	68 49 4e 53 54	 push	 1414745673		; 54534e49H
  00025	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 08	 add	 ecx, 8
  0002f	51		 push	 ecx
  00030	8d 4d a8	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00033	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00038	89 45 c0	 mov	 DWORD PTR _hr$[ebp], eax

; 1458 : 
; 1459 :     //
; 1460 :     // Read the instrument data
; 1461 :     //
; 1462 : 
; 1463 :     if(SUCCEEDED(hr))

  0003b	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0003f	7c 15		 jl	 SHORT $L50556

; 1464 :     {
; 1465 :         hr = InstrumentChunk.Read(0, &inst, sizeof(inst));

  00041	6a 00		 push	 0
  00043	6a 14		 push	 20			; 00000014H
  00045	8d 55 e8	 lea	 edx, DWORD PTR _inst$[ebp]
  00048	52		 push	 edx
  00049	6a 00		 push	 0
  0004b	8d 4d a8	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  0004e	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00053	89 45 c0	 mov	 DWORD PTR _hr$[ebp], eax
$L50556:

; 1466 :     }
; 1467 : 
; 1468 :     //
; 1469 :     // Use the first loop that's FORWARD
; 1470 :     //
; 1471 : 
; 1472 :     if(SUCCEEDED(hr))

  00056	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0005a	7c 68		 jl	 SHORT $L50558

; 1473 :     {
; 1474 :         if(AIFFLOOP_MODE_FORWARD == EndianSwapWord(inst.SustainLoop.wPlayMode))

  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _inst$[ebp+8]
  0005f	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  00064	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00069	83 f8 01	 cmp	 eax, 1
  0006c	75 08		 jne	 SHORT $L50559

; 1475 :         {
; 1476 :             pLoop = &inst.SustainLoop;

  0006e	8d 45 f0	 lea	 eax, DWORD PTR _inst$[ebp+8]
  00071	89 45 c4	 mov	 DWORD PTR _pLoop$[ebp], eax

; 1477 :         }
; 1478 :         else if(AIFFLOOP_MODE_FORWARD == EndianSwapWord(inst.ReleaseLoop.wPlayMode))

  00074	eb 4e		 jmp	 SHORT $L50560
$L50559:
  00076	8b 4d f6	 mov	 ecx, DWORD PTR _inst$[ebp+14]
  00079	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0007e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00083	83 f8 01	 cmp	 eax, 1
  00086	75 08		 jne	 SHORT $L50561

; 1479 :         {
; 1480 :             pLoop = &inst.ReleaseLoop;

  00088	8d 4d f6	 lea	 ecx, DWORD PTR _inst$[ebp+14]
  0008b	89 4d c4	 mov	 DWORD PTR _pLoop$[ebp], ecx

; 1481 :         }
; 1482 :         else

  0008e	eb 34		 jmp	 SHORT $L50562
$L50561:

; 1483 :         {
; 1484 :             DPF_ERROR("Neither loop is FORWARD");

  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00095	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@ ; `string'
  0009a	68 cc 05 00 00	 push	 1484			; 000005ccH
  0009f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  000a4	6a 04		 push	 4
  000a6	6a 09		 push	 9
  000a8	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000ad	83 c4 18	 add	 esp, 24			; 00000018H
  000b0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@EGGG@Neither?5loop?5is?5FORWARD?$AA@ ; `string'
  000b5	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000ba	83 c4 04	 add	 esp, 4

; 1485 :             hr = E_FAIL;

  000bd	c7 45 c0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50562:
$L50560:
$L50558:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     //
; 1490 :     // Open the marker chunk
; 1491 :     //
; 1492 : 
; 1493 :     if(SUCCEEDED(hr))

  000c4	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000c8	7c 1b		 jl	 SHORT $L50567

; 1494 :     {
; 1495 :         hr = MarkerChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_MARKER);

  000ca	68 4d 41 52 4b	 push	 1263681869		; 4b52414dH
  000cf	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  000d2	52		 push	 edx
  000d3	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	83 c0 08	 add	 eax, 8
  000d9	50		 push	 eax
  000da	8d 4d d0	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  000dd	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  000e2	89 45 c0	 mov	 DWORD PTR _hr$[ebp], eax
$L50567:

; 1496 :     }
; 1497 : 
; 1498 :     // 
; 1499 :     // Read marker data
; 1500 :     //
; 1501 : 
; 1502 :     if(SUCCEEDED(hr))

  000e5	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000e9	7c 43		 jl	 SHORT $L50569

; 1503 :     {
; 1504 :         dwMarkerSize = MarkerChunk.GetDataSize();

  000eb	8d 4d d0	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  000ee	e8 00 00 00 00	 call	 ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ; WaveLoader::CRiffChunk::GetDataSize
  000f3	89 45 c8	 mov	 DWORD PTR _dwMarkerSize$[ebp], eax

; 1505 :         
; 1506 :         hr = HRFROMP(pMarkers = (LPAIFFMARKERHDR)MEMALLOC(BYTE, dwMarkerSize));

  000f6	6a 01		 push	 1
  000f8	8b 4d c8	 mov	 ecx, DWORD PTR _dwMarkerSize$[ebp]
  000fb	51		 push	 ecx
  000fc	68 44 53 64 61	 push	 1633964868		; 61645344H
  00101	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04EHOP@BYTE?$AA@ ; `string'
  00106	68 e2 05 00 00	 push	 1506			; 000005e2H
  0010b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00110	e8 00 00 00 00	 call	 ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingPoolAlloc
  00115	89 45 a4	 mov	 DWORD PTR _pMarkers$[ebp], eax
  00118	8b 55 a4	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  0011b	f7 da		 neg	 edx
  0011d	1b d2		 sbb	 edx, edx
  0011f	81 e2 f2 ff f8
	7f		 and	 edx, 2147024882		; 7ff8fff2H
  00125	81 c2 0e 00 07
	80		 add	 edx, -2147024882	; 8007000eH
  0012b	89 55 c0	 mov	 DWORD PTR _hr$[ebp], edx
$L50569:

; 1507 :     }
; 1508 : 
; 1509 :     if(SUCCEEDED(hr))

  0012e	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00132	7c 17		 jl	 SHORT $L50576

; 1510 :     {
; 1511 :         hr = MarkerChunk.Read(0, pMarkers, dwMarkerSize);

  00134	6a 00		 push	 0
  00136	8b 45 c8	 mov	 eax, DWORD PTR _dwMarkerSize$[ebp]
  00139	50		 push	 eax
  0013a	8b 4d a4	 mov	 ecx, DWORD PTR _pMarkers$[ebp]
  0013d	51		 push	 ecx
  0013e	6a 00		 push	 0
  00140	8d 4d d0	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  00143	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00148	89 45 c0	 mov	 DWORD PTR _hr$[ebp], eax
$L50576:

; 1512 :     }
; 1513 : 
; 1514 :     if(SUCCEEDED(hr))

  0014b	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0014f	7c 11		 jl	 SHORT $L50578

; 1515 :     {
; 1516 :         pMarkers->wMarkerCount = EndianSwapWord(pMarkers->wMarkerCount);

  00151	8b 55 a4	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  00154	66 8b 0a	 mov	 cx, WORD PTR [edx]
  00157	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0015c	8b 4d a4	 mov	 ecx, DWORD PTR _pMarkers$[ebp]
  0015f	66 89 01	 mov	 WORD PTR [ecx], ax
$L50578:

; 1517 :     }
; 1518 : 
; 1519 :     //
; 1520 :     // Find the loop markers
; 1521 :     //
; 1522 : 
; 1523 :     if(SUCCEEDED(hr))

  00162	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00166	0f 8c ca 00 00
	00		 jl	 $L50580

; 1524 :     {
; 1525 :         pStartMarker = (LPAIFFMARKER)(pMarkers + 1);

  0016c	8b 55 a4	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  0016f	83 c2 02	 add	 edx, 2
  00172	89 55 9c	 mov	 DWORD PTR _pStartMarker$[ebp], edx

; 1526 :         
; 1527 :         for(i = 0; i < pMarkers->wMarkerCount; i++)

  00175	66 c7 45 a2 00
	00		 mov	 WORD PTR _i$[ebp], 0
  0017b	eb 0c		 jmp	 SHORT $L50582
$L50583:
  0017d	66 8b 45 a2	 mov	 ax, WORD PTR _i$[ebp]
  00181	66 05 01 00	 add	 ax, 1
  00185	66 89 45 a2	 mov	 WORD PTR _i$[ebp], ax
$L50582:
  00189	8b 4d a2	 mov	 ecx, DWORD PTR _i$[ebp]
  0018c	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00192	8b 55 a4	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  00195	33 c0		 xor	 eax, eax
  00197	66 8b 02	 mov	 ax, WORD PTR [edx]
  0019a	3b c8		 cmp	 ecx, eax
  0019c	7d 4f		 jge	 SHORT $L50584

; 1528 :         {
; 1529 :             ASSERT((DWORD)pStartMarker < (DWORD)pMarkers + dwMarkerSize);

  0019e	68 f9 05 00 00	 push	 1529			; 000005f9H
  001a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  001a8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DF@PJLL@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@ ; `string'
  001ad	8b 4d a4	 mov	 ecx, DWORD PTR _pMarkers$[ebp]
  001b0	03 4d c8	 add	 ecx, DWORD PTR _dwMarkerSize$[ebp]
  001b3	39 4d 9c	 cmp	 DWORD PTR _pStartMarker$[ebp], ecx
  001b6	1b d2		 sbb	 edx, edx
  001b8	42		 inc	 edx
  001b9	52		 push	 edx
  001ba	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  001bf	83 c4 10	 add	 esp, 16			; 00000010H

; 1530 :             
; 1531 :             if(pStartMarker->wMarkerId == pLoop->wStartMarker)

  001c2	8b 45 9c	 mov	 eax, DWORD PTR _pStartMarker$[ebp]
  001c5	33 c9		 xor	 ecx, ecx
  001c7	66 8b 08	 mov	 cx, WORD PTR [eax]
  001ca	8b 55 c4	 mov	 edx, DWORD PTR _pLoop$[ebp]
  001cd	33 c0		 xor	 eax, eax
  001cf	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  001d3	3b c8		 cmp	 ecx, eax
  001d5	75 02		 jne	 SHORT $L50588

; 1532 :             {
; 1533 :                 break;

  001d7	eb 14		 jmp	 SHORT $L50584
$L50588:

; 1534 :             }
; 1535 : 
; 1536 :             pStartMarker = (LPAIFFMARKER)((LPBYTE)pStartMarker + sizeof(*pStartMarker) + pStartMarker->bNameLength);

  001d9	8b 4d 9c	 mov	 ecx, DWORD PTR _pStartMarker$[ebp]
  001dc	33 d2		 xor	 edx, edx
  001de	8a 51 06	 mov	 dl, BYTE PTR [ecx+6]
  001e1	8b 45 9c	 mov	 eax, DWORD PTR _pStartMarker$[ebp]
  001e4	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  001e8	89 4d 9c	 mov	 DWORD PTR _pStartMarker$[ebp], ecx

; 1537 :         }

  001eb	eb 90		 jmp	 SHORT $L50583
$L50584:

; 1538 : 
; 1539 :         if(i >= pMarkers->wMarkerCount)

  001ed	8b 55 a2	 mov	 edx, DWORD PTR _i$[ebp]
  001f0	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  001f6	8b 45 a4	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  001f9	33 c9		 xor	 ecx, ecx
  001fb	66 8b 08	 mov	 cx, WORD PTR [eax]
  001fe	3b d1		 cmp	 edx, ecx
  00200	7c 34		 jl	 SHORT $L50591

; 1540 :         {
; 1541 :             DPF_ERROR("Can't find loop start marker");

  00202	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00207	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@ ; `string'
  0020c	68 05 06 00 00	 push	 1541			; 00000605H
  00211	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00216	6a 04		 push	 4
  00218	6a 09		 push	 9
  0021a	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0021f	83 c4 18	 add	 esp, 24			; 00000018H
  00222	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@INFE@Can?8t?5find?5loop?5start?5marker?$AA@ ; `string'
  00227	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0022c	83 c4 04	 add	 esp, 4

; 1542 :             hr = E_FAIL;

  0022f	c7 45 c0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50591:
$L50580:

; 1543 :         }
; 1544 :     }
; 1545 : 
; 1546 :     if(SUCCEEDED(hr))

  00236	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0023a	0f 8c ca 00 00
	00		 jl	 $L50595

; 1547 :     {
; 1548 :         pEndMarker = (LPAIFFMARKER)(pMarkers + 1);

  00240	8b 55 a4	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  00243	83 c2 02	 add	 edx, 2
  00246	89 55 cc	 mov	 DWORD PTR _pEndMarker$[ebp], edx

; 1549 :         
; 1550 :         for(i = 0; i < pMarkers->wMarkerCount; i++)

  00249	66 c7 45 a2 00
	00		 mov	 WORD PTR _i$[ebp], 0
  0024f	eb 0c		 jmp	 SHORT $L50597
$L50598:
  00251	66 8b 45 a2	 mov	 ax, WORD PTR _i$[ebp]
  00255	66 05 01 00	 add	 ax, 1
  00259	66 89 45 a2	 mov	 WORD PTR _i$[ebp], ax
$L50597:
  0025d	8b 4d a2	 mov	 ecx, DWORD PTR _i$[ebp]
  00260	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00266	8b 55 a4	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  00269	33 c0		 xor	 eax, eax
  0026b	66 8b 02	 mov	 ax, WORD PTR [edx]
  0026e	3b c8		 cmp	 ecx, eax
  00270	7d 4f		 jge	 SHORT $L50599

; 1551 :         {
; 1552 :             ASSERT((DWORD)pEndMarker < (DWORD)pMarkers + dwMarkerSize);

  00272	68 10 06 00 00	 push	 1552			; 00000610H
  00277	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  0027c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@DPMK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@ ; `string'
  00281	8b 4d a4	 mov	 ecx, DWORD PTR _pMarkers$[ebp]
  00284	03 4d c8	 add	 ecx, DWORD PTR _dwMarkerSize$[ebp]
  00287	39 4d cc	 cmp	 DWORD PTR _pEndMarker$[ebp], ecx
  0028a	1b d2		 sbb	 edx, edx
  0028c	42		 inc	 edx
  0028d	52		 push	 edx
  0028e	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00293	83 c4 10	 add	 esp, 16			; 00000010H

; 1553 :             
; 1554 :             if(pEndMarker->wMarkerId == pLoop->wEndMarker)

  00296	8b 45 cc	 mov	 eax, DWORD PTR _pEndMarker$[ebp]
  00299	33 c9		 xor	 ecx, ecx
  0029b	66 8b 08	 mov	 cx, WORD PTR [eax]
  0029e	8b 55 c4	 mov	 edx, DWORD PTR _pLoop$[ebp]
  002a1	33 c0		 xor	 eax, eax
  002a3	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  002a7	3b c8		 cmp	 ecx, eax
  002a9	75 02		 jne	 SHORT $L50603

; 1555 :             {
; 1556 :                 break;

  002ab	eb 14		 jmp	 SHORT $L50599
$L50603:

; 1557 :             }
; 1558 : 
; 1559 :             pEndMarker = (LPAIFFMARKER)((LPBYTE)pEndMarker + sizeof(*pEndMarker) + pEndMarker->bNameLength);

  002ad	8b 4d cc	 mov	 ecx, DWORD PTR _pEndMarker$[ebp]
  002b0	33 d2		 xor	 edx, edx
  002b2	8a 51 06	 mov	 dl, BYTE PTR [ecx+6]
  002b5	8b 45 cc	 mov	 eax, DWORD PTR _pEndMarker$[ebp]
  002b8	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  002bc	89 4d cc	 mov	 DWORD PTR _pEndMarker$[ebp], ecx

; 1560 :         }

  002bf	eb 90		 jmp	 SHORT $L50598
$L50599:

; 1561 : 
; 1562 :         if(i >= pMarkers->wMarkerCount)

  002c1	8b 55 a2	 mov	 edx, DWORD PTR _i$[ebp]
  002c4	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  002ca	8b 45 a4	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  002cd	33 c9		 xor	 ecx, ecx
  002cf	66 8b 08	 mov	 cx, WORD PTR [eax]
  002d2	3b d1		 cmp	 edx, ecx
  002d4	7c 34		 jl	 SHORT $L50606

; 1563 :         {
; 1564 :             DPF_ERROR("Can't find loop end marker");

  002d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  002db	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@ ; `string'
  002e0	68 1c 06 00 00	 push	 1564			; 0000061cH
  002e5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  002ea	6a 04		 push	 4
  002ec	6a 09		 push	 9
  002ee	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  002f3	83 c4 18	 add	 esp, 24			; 00000018H
  002f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@IHKN@Can?8t?5find?5loop?5end?5marker?$AA@ ; `string'
  002fb	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00300	83 c4 04	 add	 esp, 4

; 1565 :             hr = E_FAIL;

  00303	c7 45 c0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50606:
$L50595:

; 1566 :         }
; 1567 :     }
; 1568 : 
; 1569 :     //
; 1570 :     // Double-check the marker validity
; 1571 :     //
; 1572 : 
; 1573 :     if(SUCCEEDED(hr))

  0030a	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0030e	7c 64		 jl	 SHORT $L50610

; 1574 :     {
; 1575 :         pStartMarker->dwPosition = EndianSwapDword(pStartMarker->dwPosition);

  00310	8b 55 9c	 mov	 edx, DWORD PTR _pStartMarker$[ebp]
  00313	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  00316	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  0031b	8b 4d 9c	 mov	 ecx, DWORD PTR _pStartMarker$[ebp]
  0031e	89 41 02	 mov	 DWORD PTR [ecx+2], eax

; 1576 :         pEndMarker->dwPosition = EndianSwapDword(pEndMarker->dwPosition);

  00321	8b 55 cc	 mov	 edx, DWORD PTR _pEndMarker$[ebp]
  00324	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  00327	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  0032c	8b 4d cc	 mov	 ecx, DWORD PTR _pEndMarker$[ebp]
  0032f	89 41 02	 mov	 DWORD PTR [ecx+2], eax

; 1577 : 
; 1578 :         if(pStartMarker->dwPosition >= pEndMarker->dwPosition)

  00332	8b 55 9c	 mov	 edx, DWORD PTR _pStartMarker$[ebp]
  00335	8b 45 cc	 mov	 eax, DWORD PTR _pEndMarker$[ebp]
  00338	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  0033b	3b 48 02	 cmp	 ecx, DWORD PTR [eax+2]
  0033e	72 34		 jb	 SHORT $L50611

; 1579 :         {
; 1580 :             DPF_ERROR("Loop end point less-than-or-equal-to start point");

  00340	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMGB@WAVBNDLR?$AA@ ; `string'
  00345	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@PLDI@CStdFileStream?3?3GetAiffLoopRegio@ ; `string'
  0034a	68 2c 06 00 00	 push	 1580			; 0000062cH
  0034f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00354	6a 04		 push	 4
  00356	6a 09		 push	 9
  00358	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0035d	83 c4 18	 add	 esp, 24			; 00000018H
  00360	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@DCLE@Loop?5end?5point?5less?9than?9or?9equa@ ; `string'
  00365	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0036a	83 c4 04	 add	 esp, 4

; 1581 :             hr = E_FAIL;

  0036d	c7 45 c0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L50611:
$L50610:

; 1582 :         }
; 1583 :     }
; 1584 : 
; 1585 :     //
; 1586 :     // Success
; 1587 :     //
; 1588 : 
; 1589 :     if(SUCCEEDED(hr))

  00374	83 7d c0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00378	7c 1c		 jl	 SHORT $L50615

; 1590 :     {
; 1591 :         *pdwLoopStart = pStartMarker->dwPosition;

  0037a	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  0037d	8b 45 9c	 mov	 eax, DWORD PTR _pStartMarker$[ebp]
  00380	8b 48 02	 mov	 ecx, DWORD PTR [eax+2]
  00383	89 0a		 mov	 DWORD PTR [edx], ecx

; 1592 :         *pdwLoopLength = pEndMarker->dwPosition - pStartMarker->dwPosition;

  00385	8b 55 cc	 mov	 edx, DWORD PTR _pEndMarker$[ebp]
  00388	8b 45 9c	 mov	 eax, DWORD PTR _pStartMarker$[ebp]
  0038b	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  0038e	2b 48 02	 sub	 ecx, DWORD PTR [eax+2]
  00391	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  00394	89 0a		 mov	 DWORD PTR [edx], ecx
$L50615:

; 1593 :     }
; 1594 : 
; 1595 :     //
; 1596 :     // Clean up
; 1597 :     //
; 1598 :     
; 1599 :     MEMFREE(pMarkers);

  00396	83 7d a4 00	 cmp	 DWORD PTR _pMarkers$[ebp], 0
  0039a	74 10		 je	 SHORT $L50616
  0039c	8b 45 a4	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  0039f	50		 push	 eax
  003a0	e8 00 00 00 00	 call	 ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPoolFree
  003a5	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _pMarkers$[ebp], 0
$L50616:

; 1600 : 
; 1601 :     DPF_LEAVE_HRESULT(hr);
; 1602 : 
; 1603 :     return hr;

  003ac	8b 4d c0	 mov	 ecx, DWORD PTR _hr$[ebp]
  003af	89 4d 98	 mov	 DWORD PTR $T51848[ebp], ecx
  003b2	8d 4d d0	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  003b5	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  003ba	8d 4d a8	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  003bd	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  003c2	8b 45 98	 mov	 eax, DWORD PTR $T51848[ebp]

; 1604 : }

  003c5	8b e5		 mov	 esp, ebp
  003c7	5d		 pop	 ebp
  003c8	c2 08 00	 ret	 8
?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ENDP ; WaveLoader::CWaveFile::GetAiffLoopRegion
_TEXT	ENDS
PUBLIC	?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CWaveFile::ReadSample
PUBLIC	?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm
; Function compile flags: /Odt
;	COMDAT ?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z
_TEXT	SEGMENT
_dwPosition$ = 8
_pvBuffer$ = 12
_dwBufferSize$ = 16
_pdwRead$ = 20
_this$ = -8
_hr$ = -4
?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z PROC NEAR ; WaveLoader::CWaveFile::ReadSample, COMDAT
; _this$ = ecx

; 1636 : {                                   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1637 :     HRESULT                 hr;
; 1638 : 
; 1639 :     DPF_ENTER();
; 1640 : 
; 1641 :     hr = m_DataChunk.Read(dwPosition, pvBuffer, dwBufferSize, &dwBufferSize);

  00009	8d 45 10	 lea	 eax, DWORD PTR _dwBufferSize$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _dwPosition$[ebp]
  00018	50		 push	 eax
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	83 c1 20	 add	 ecx, 32			; 00000020H
  0001f	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00024	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1642 : 
; 1643 :     if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType))

  00027	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0002b	7c 19		 jl	 SHORT $L50627
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 79 38 01	 cmp	 DWORD PTR [ecx+56], 1
  00034	75 10		 jne	 SHORT $L50627

; 1644 :     {
; 1645 :         ConvertAiffPcm(pvBuffer, dwBufferSize);

  00036	8b 55 10	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  00039	52		 push	 edx
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm
$L50627:

; 1646 :     }
; 1647 : 
; 1648 :     if(SUCCEEDED(hr) && pdwRead)

  00046	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004a	7c 0e		 jl	 SHORT $L50629
  0004c	83 7d 14 00	 cmp	 DWORD PTR _pdwRead$[ebp], 0
  00050	74 08		 je	 SHORT $L50629

; 1649 :     {
; 1650 :         *pdwRead = dwBufferSize;

  00052	8b 4d 14	 mov	 ecx, DWORD PTR _pdwRead$[ebp]
  00055	8b 55 10	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  00058	89 11		 mov	 DWORD PTR [ecx], edx
$L50629:

; 1651 :     }
; 1652 : 
; 1653 :     DPF_LEAVE_HRESULT(hr);
; 1654 : 
; 1655 :     return hr;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1656 : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 10 00	 ret	 16			; 00000010H
?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z ENDP	; WaveLoader::CWaveFile::ReadSample
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Close@CWaveFile@WaveLoader@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Close@CWaveFile@WaveLoader@@QAEXXZ PROC NEAR		; WaveLoader::CWaveFile::Close, COMDAT
; _this$ = ecx

; 1682 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1683 :     DPF_ENTER();
; 1684 : 
; 1685 :     m_Stream.Close();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Close@CStdFileStream@WaveLoader@@QAEXXZ ; WaveLoader::CStdFileStream::Close

; 1686 : 
; 1687 :     MEMFREE(m_pwfxFormat);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00016	74 16		 je	 SHORT $L50634
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPoolFree
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
$L50634:

; 1688 : 
; 1689 :     DPF_LEAVE_VOID();
; 1690 : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?Close@CWaveFile@WaveLoader@@QAEXXZ ENDP		; WaveLoader::CWaveFile::Close
_TEXT	ENDS
PUBLIC	??_C@_0CM@CGPO@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@ ; `string'
;	COMDAT ??_C@_0CM@CGPO@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@
CONST	SEGMENT
??_C@_0CM@CGPO@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@ DB 'WAVE_FORMAT'
	DB	'_PCM == m_pwfxFormat->wFormatTag', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z
_TEXT	SEGMENT
_pvSource$ = 8
_cbSource$ = 12
_this$ = -12
?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z PROC NEAR ; WaveLoader::CWaveFile::ConvertAiffPcm, COMDAT
; _this$ = ecx

; 1718 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1719 :     BYTE *                  pbSource;
; 1720 :     BYTE                    bTemp;
; 1721 : 
; 1722 :     DPF_ENTER();
; 1723 : 
; 1724 :     ASSERT(m_pwfxFormat);

  00009	68 bc 06 00 00	 push	 1724			; 000006bcH
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@OAHJ@m_pwfxFormat?$AA@ ; `string'
  00018	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	33 c9		 xor	 ecx, ecx
  0001d	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00021	0f 94 c1	 sete	 cl
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 1725 :     ASSERT(WAVE_FORMAT_PCM == m_pwfxFormat->wFormatTag);

  0002d	68 bd 06 00 00	 push	 1725			; 000006bdH
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@CGPO@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@ ; `string'
  0003c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00042	33 c9		 xor	 ecx, ecx
  00044	66 8b 08	 mov	 cx, WORD PTR [eax]
  00047	83 e9 01	 sub	 ecx, 1
  0004a	f7 d9		 neg	 ecx
  0004c	1b c9		 sbb	 ecx, ecx
  0004e	f7 d9		 neg	 ecx
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00056	83 c4 10	 add	 esp, 16			; 00000010H

; 1726 : 
; 1727 :     ConvertAiffPcm(pvSource, cbSource, m_pwfxFormat->wBitsPerSample);

  00059	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0005f	33 c9		 xor	 ecx, ecx
  00061	66 8b 48 0e	 mov	 cx, WORD PTR [eax+14]
  00065	51		 push	 ecx
  00066	8b 55 0c	 mov	 edx, DWORD PTR _cbSource$[ebp]
  00069	52		 push	 edx
  0006a	8b 45 08	 mov	 eax, DWORD PTR _pvSource$[ebp]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm

; 1728 : 
; 1729 :     DPF_LEAVE_VOID();
; 1730 : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 08 00	 ret	 8
?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z ENDP	; WaveLoader::CWaveFile::ConvertAiffPcm
_TEXT	ENDS
PUBLIC	??_C@_0BA@GOLD@8?5?$DN?$DN?5dwBitDepth?$AA@	; `string'
;	COMDAT ??_C@_0BA@GOLD@8?5?$DN?$DN?5dwBitDepth?$AA@
CONST	SEGMENT
??_C@_0BA@GOLD@8?5?$DN?$DN?5dwBitDepth?$AA@ DB '8 == dwBitDepth', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z
_TEXT	SEGMENT
_pvSource$ = 8
_cbSource$ = 12
_dwBitDepth$ = 16
_pbSource$ = -4
_pwSource$ = -12
?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z PROC NEAR ; WaveLoader::CWaveFile::ConvertAiffPcm, COMDAT

; 1760 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1761 :     BYTE *                  pbSource;
; 1762 :     WORD *                  pwSource;
; 1763 :     BYTE                    bTemp;
; 1764 : 
; 1765 :     DPF_ENTER();
; 1766 : 
; 1767 :     if(16 == dwBitDepth)

  00006	83 7d 10 10	 cmp	 DWORD PTR _dwBitDepth$[ebp], 16 ; 00000010H
  0000a	75 3d		 jne	 SHORT $L50651

; 1768 :     {
; 1769 :         cbSource /= 2;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _cbSource$[ebp]
  0000f	d1 e8		 shr	 eax, 1
  00011	89 45 0c	 mov	 DWORD PTR _cbSource$[ebp], eax

; 1770 :         
; 1771 :         for(pwSource = (WORD *)pvSource; cbSource; cbSource--, pwSource++)

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pvSource$[ebp]
  00017	89 4d f4	 mov	 DWORD PTR _pwSource$[ebp], ecx
  0001a	eb 12		 jmp	 SHORT $L50653
$L50654:
  0001c	8b 55 0c	 mov	 edx, DWORD PTR _cbSource$[ebp]
  0001f	83 ea 01	 sub	 edx, 1
  00022	89 55 0c	 mov	 DWORD PTR _cbSource$[ebp], edx
  00025	8b 45 f4	 mov	 eax, DWORD PTR _pwSource$[ebp]
  00028	83 c0 02	 add	 eax, 2
  0002b	89 45 f4	 mov	 DWORD PTR _pwSource$[ebp], eax
$L50653:
  0002e	83 7d 0c 00	 cmp	 DWORD PTR _cbSource$[ebp], 0
  00032	74 13		 je	 SHORT $L50655

; 1772 :         {
; 1773 :             *pwSource = EndianSwapWord(*pwSource);

  00034	8b 4d f4	 mov	 ecx, DWORD PTR _pwSource$[ebp]
  00037	66 8b 09	 mov	 cx, WORD PTR [ecx]
  0003a	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0003f	8b 55 f4	 mov	 edx, DWORD PTR _pwSource$[ebp]
  00042	66 89 02	 mov	 WORD PTR [edx], ax

; 1774 :         }

  00045	eb d5		 jmp	 SHORT $L50654
$L50655:

; 1775 :     }
; 1776 :     else

  00047	eb 55		 jmp	 SHORT $L50656
$L50651:

; 1777 :     {
; 1778 :         ASSERT(8 == dwBitDepth);

  00049	68 f2 06 00 00	 push	 1778			; 000006f2H
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NPIO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@GOLD@8?5?$DN?$DN?5dwBitDepth?$AA@ ; `string'
  00058	33 c0		 xor	 eax, eax
  0005a	83 7d 10 08	 cmp	 DWORD PTR _dwBitDepth$[ebp], 8
  0005e	0f 95 c0	 setne	 al
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00067	83 c4 10	 add	 esp, 16			; 00000010H

; 1779 :         
; 1780 :         for(pbSource = (BYTE *)pvSource; cbSource; cbSource--, pbSource++)

  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _pvSource$[ebp]
  0006d	89 4d fc	 mov	 DWORD PTR _pbSource$[ebp], ecx
  00070	eb 12		 jmp	 SHORT $L50659
$L50660:
  00072	8b 55 0c	 mov	 edx, DWORD PTR _cbSource$[ebp]
  00075	83 ea 01	 sub	 edx, 1
  00078	89 55 0c	 mov	 DWORD PTR _cbSource$[ebp], edx
  0007b	8b 45 fc	 mov	 eax, DWORD PTR _pbSource$[ebp]
  0007e	83 c0 01	 add	 eax, 1
  00081	89 45 fc	 mov	 DWORD PTR _pbSource$[ebp], eax
$L50659:
  00084	83 7d 0c 00	 cmp	 DWORD PTR _cbSource$[ebp], 0
  00088	74 14		 je	 SHORT $L50661

; 1781 :         {
; 1782 :             *pbSource = *pbSource + 0x80;

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _pbSource$[ebp]
  0008d	33 d2		 xor	 edx, edx
  0008f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00091	81 c2 80 00 00
	00		 add	 edx, 128		; 00000080H
  00097	8b 45 fc	 mov	 eax, DWORD PTR _pbSource$[ebp]
  0009a	88 10		 mov	 BYTE PTR [eax], dl

; 1783 :         }

  0009c	eb d4		 jmp	 SHORT $L50660
$L50661:
$L50656:

; 1784 :     }
; 1785 : 
; 1786 :     DPF_LEAVE_VOID();
; 1787 : }

  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 0c 00	 ret	 12			; 0000000cH
?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z ENDP	; WaveLoader::CWaveFile::ConvertAiffPcm
_TEXT	ENDS
PUBLIC	??_7CImaAdpcmCodec@DirectSound@@6B@		; DirectSound::CImaAdpcmCodec::`vftable'
PUBLIC	??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z	; DirectSound::CImaAdpcmCodec::`scalar deleting destructor'
PUBLIC	??_ECImaAdpcmCodec@DirectSound@@UAEPAXI@Z	; DirectSound::CImaAdpcmCodec::`vector deleting destructor'
;	COMDAT ??_7CImaAdpcmCodec@DirectSound@@6B@
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
CONST	SEGMENT
??_7CImaAdpcmCodec@DirectSound@@6B@ DD FLAT:??_ECImaAdpcmCodec@DirectSound@@UAEPAXI@Z ; DirectSound::CImaAdpcmCodec::`vftable'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CImaAdpcmCodec@DirectSound@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CImaAdpcmCodec@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CImaAdpcmCodec::CImaAdpcmCodec, COMDAT
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CImaAdpcmCodec@DirectSound@@6B@ ; DirectSound::CImaAdpcmCodec::`vftable'

; 70   : }

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0CImaAdpcmCodec@DirectSound@@QAE@XZ ENDP		; DirectSound::CImaAdpcmCodec::CImaAdpcmCodec
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z PROC NEAR	; DirectSound::CImaAdpcmCodec::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CImaAdpcmCodec@DirectSound@@UAE@XZ ; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L50671
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L50671:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z ENDP		; DirectSound::CImaAdpcmCodec::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CImaAdpcmCodec@DirectSound@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CImaAdpcmCodec@DirectSound@@UAE@XZ PROC NEAR		; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec, COMDAT
; _this$ = ecx

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CImaAdpcmCodec@DirectSound@@6B@ ; DirectSound::CImaAdpcmCodec::`vftable'

; 93   : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1CImaAdpcmCodec@DirectSound@@UAE@XZ ENDP		; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec
_TEXT	ENDS
PUBLIC	?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUima_adpcmwaveformat_tag@@@Z ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat
PUBLIC	?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::EncodeM16
PUBLIC	?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::EncodeS16
PUBLIC	?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::DecodeM16
PUBLIC	?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::DecodeS16
_BSS	SEGMENT
?$S12@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4EA DB 01H DUP (?) ; `DirectSound::CImaAdpcmCodec::Initialize'::`2'::$S12
; Function compile flags: /Odt
_BSS	ENDS
;	COMDAT ?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z
_TEXT	SEGMENT
_pwfxEncode$ = 8
_fEncoder$ = 12
_this$ = -4
?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::Initialize, COMDAT
; _this$ = ecx

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  :     static const LPFNIMAADPCMCONVERT    apfnConvert[2][2] = 
; 120  :     { 
; 121  :         {
; 122  :             DecodeM16,

  00009	33 c0		 xor	 eax, eax
  0000b	a0 00 00 00 00	 mov	 al, BYTE PTR ?$S12@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4EA
  00010	83 e0 01	 and	 eax, 1
  00013	85 c0		 test	 eax, eax
  00015	75 67		 jne	 SHORT $L50685
  00017	33 c9		 xor	 ecx, ecx
  00019	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?$S12@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4EA
  0001f	83 c9 01	 or	 ecx, 1
  00022	88 0d 00 00 00
	00		 mov	 BYTE PTR ?$S12@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4EA, cl
  00028	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA, OFFSET FLAT:?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::DecodeM16
  00032	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA
  00038	89 15 00 00 00
	00		 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA, edx

; 123  :             DecodeS16 
; 124  :         },

  0003e	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+4, OFFSET FLAT:?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::DecodeS16
  00048	a1 04 00 00 00	 mov	 eax, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+4
  0004d	a3 04 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+4, eax

; 125  :         {
; 126  :             EncodeM16,

  00052	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+8, OFFSET FLAT:?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::EncodeM16
  0005c	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+8
  00062	89 0d 08 00 00
	00		 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+8, ecx

; 127  :             EncodeS16 
; 128  :         }

  00068	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+12, OFFSET FLAT:?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::EncodeS16
  00072	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+12
  00078	89 15 0c 00 00
	00		 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+12, edx
$L50685:

; 129  :     };
; 130  :     
; 131  :     if(!IsValidImaAdpcmFormat(pwfxEncode))

  0007e	8b 45 08	 mov	 eax, DWORD PTR _pwfxEncode$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUima_adpcmwaveformat_tag@@@Z ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat
  00087	85 c0		 test	 eax, eax
  00089	75 04		 jne	 SHORT $L50686

; 132  :     {
; 133  :         return FALSE;

  0008b	33 c0		 xor	 eax, eax
  0008d	eb 5b		 jmp	 SHORT $L50680
$L50686:

; 134  :     }
; 135  : 
; 136  :     //
; 137  :     // Save the format data
; 138  :     //
; 139  : 
; 140  :     m_wfxEncode = *pwfxEncode;

  0008f	8b 75 08	 mov	 esi, DWORD PTR _pwfxEncode$[ebp]
  00092	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  00095	83 c7 04	 add	 edi, 4
  00098	b9 05 00 00 00	 mov	 ecx, 5
  0009d	f3 a5		 rep movsd

; 141  :     m_fEncoder = !!fEncoder;

  0009f	33 c9		 xor	 ecx, ecx
  000a1	83 7d 0c 00	 cmp	 DWORD PTR _fEncoder$[ebp], 0
  000a5	0f 95 c1	 setne	 cl
  000a8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ab	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 142  : 
; 143  :     //
; 144  :     // Set up the conversion function
; 145  :     //
; 146  : 
; 147  :     m_pfnConvert = apfnConvert[m_fEncoder][m_wfxEncode.wfx.nChannels - 1];

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000b4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b7	33 c0		 xor	 eax, eax
  000b9	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  000bd	8d 14 85 fc ff
	ff ff		 lea	 edx, DWORD PTR [eax*4-4]
  000c4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	8b 8c ca 00 00
	00 00		 mov	 ecx, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA[edx+ecx*8]
  000ce	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 148  : 
; 149  :     //
; 150  :     // Initialize the stepping indeces
; 151  :     //
; 152  : 
; 153  :     m_nStepIndexL = m_nStepIndexR = 0;

  000d1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d4	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
  000db	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000de	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 154  : 
; 155  :     return TRUE;

  000e5	b8 01 00 00 00	 mov	 eax, 1
$L50680:

; 156  : }

  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c2 08 00	 ret	 8
?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUima_adpcmwaveformat_tag@@H@Z ENDP ; DirectSound::CImaAdpcmCodec::Initialize
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z
_TEXT	SEGMENT
_pvSrc$ = 8
_pvDst$ = 12
_cBlocks$ = 16
_this$ = -4
?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::Convert, COMDAT
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  :     return m_pfnConvert((LPBYTE)pvSrc, (LPBYTE)pvDst, cBlocks, m_wfxEncode.wfx.nBlockAlign, m_wfxEncode.wSamplesPerBlock, &m_nStepIndexL, &m_nStepIndexR);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 20	 add	 eax, 32			; 00000020H
  0000d	50		 push	 eax
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00014	51		 push	 ecx
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	33 c0		 xor	 eax, eax
  0001a	66 8b 42 16	 mov	 ax, WORD PTR [edx+22]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	33 d2		 xor	 edx, edx
  00024	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  00028	52		 push	 edx
  00029	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _pvDst$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR _pvSrc$[ebp]
  00034	52		 push	 edx
  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	ff 50 24	 call	 DWORD PTR [eax+36]

; 185  : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z ENDP	; DirectSound::CImaAdpcmCodec::Convert
_TEXT	ENDS
PUBLIC	?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ	; DirectSound::CImaAdpcmCodec::Reset
; Function compile flags: /Odt
;	COMDAT ?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ PROC NEAR	; DirectSound::CImaAdpcmCodec::Reset, COMDAT
; _this$ = ecx

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 209  :     //
; 210  :     // Reset the stepping indeces
; 211  :     //
; 212  : 
; 213  :     m_nStepIndexL = m_nStepIndexR = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 214  : }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ ENDP		; DirectSound::CImaAdpcmCodec::Reset
_TEXT	ENDS
PUBLIC	?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ; DirectSound::CImaAdpcmCodec::GetEncodeAlignment
; Function compile flags: /Odt
;	COMDAT ?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4
?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ PROC NEAR ; DirectSound::CImaAdpcmCodec::GetEncodeAlignment, COMDAT
; _this$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 238  :     return m_wfxEncode.wfx.nBlockAlign;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 40 10	 mov	 ax, WORD PTR [eax+16]

; 239  : }

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ENDP ; DirectSound::CImaAdpcmCodec::GetEncodeAlignment
_TEXT	ENDS
PUBLIC	?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ; DirectSound::CImaAdpcmCodec::GetDecodeAlignment
; Function compile flags: /Odt
;	COMDAT ?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4
?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ PROC NEAR ; DirectSound::CImaAdpcmCodec::GetDecodeAlignment, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 263  :     return m_wfxEncode.wSamplesPerBlock * m_wfxEncode.wfx.nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 48 16	 mov	 cx, WORD PTR [eax+22]
  00010	8b c1		 mov	 eax, ecx
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	33 c9		 xor	 ecx, ecx
  00017	66 8b 4a 06	 mov	 cx, WORD PTR [edx+6]
  0001b	0f af c1	 imul	 eax, ecx
  0001e	c1 e0 04	 shl	 eax, 4
  00021	99		 cdq
  00022	83 e2 07	 and	 edx, 7
  00025	03 c2		 add	 eax, edx
  00027	c1 f8 03	 sar	 eax, 3

; 264  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ENDP ; DirectSound::CImaAdpcmCodec::GetDecodeAlignment
_TEXT	ENDS
PUBLIC	?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
; Function compile flags: /Odt
;	COMDAT ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerBlock$ = 12
_nEncodedSampleBits$ = -2
_nHeaderBytes$ = -4
_nBlockAlign$ = -6
?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment, COMDAT

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 291  :     const WORD              nEncodedSampleBits  = nChannels * IMAADPCM_BITS_PER_SAMPLE;

  00006	8b 45 08	 mov	 eax, DWORD PTR _nChannels$[ebp]
  00009	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000e	c1 e0 02	 shl	 eax, 2
  00011	66 89 45 fe	 mov	 WORD PTR _nEncodedSampleBits$[ebp], ax

; 292  :     const WORD              nHeaderBytes        = nChannels * IMAADPCM_HEADER_LENGTH;

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _nChannels$[ebp]
  00018	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001e	c1 e1 02	 shl	 ecx, 2
  00021	66 89 4d fc	 mov	 WORD PTR _nHeaderBytes$[ebp], cx

; 293  :     WORD                    nBlockAlign;
; 294  : 
; 295  :     //
; 296  :     // Calculate the raw block alignment that nSamplesPerBlock dictates.  This
; 297  :     // value may include a partial encoded sample, so be sure to round up.
; 298  :     //
; 299  :     // Start with the samples-per-block, minus 1.  The first sample is actually
; 300  :     // stored in the header.
; 301  :     //
; 302  : 
; 303  :     nBlockAlign = nSamplesPerBlock - 1;

  00025	8b 55 0c	 mov	 edx, DWORD PTR _nSamplesPerBlock$[ebp]
  00028	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0002e	83 ea 01	 sub	 edx, 1
  00031	66 89 55 fa	 mov	 WORD PTR _nBlockAlign$[ebp], dx

; 304  : 
; 305  :     //
; 306  :     // Convert to encoded sample size
; 307  :     //
; 308  : 
; 309  :     nBlockAlign *= nEncodedSampleBits;

  00035	8b 45 fe	 mov	 eax, DWORD PTR _nEncodedSampleBits$[ebp]
  00038	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003d	8b 4d fa	 mov	 ecx, DWORD PTR _nBlockAlign$[ebp]
  00040	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00046	0f af c8	 imul	 ecx, eax
  00049	66 89 4d fa	 mov	 WORD PTR _nBlockAlign$[ebp], cx

; 310  :     nBlockAlign += 7;

  0004d	8b 55 fa	 mov	 edx, DWORD PTR _nBlockAlign$[ebp]
  00050	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00056	83 c2 07	 add	 edx, 7
  00059	66 89 55 fa	 mov	 WORD PTR _nBlockAlign$[ebp], dx

; 311  :     nBlockAlign /= 8;

  0005d	8b 45 fa	 mov	 eax, DWORD PTR _nBlockAlign$[ebp]
  00060	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00065	99		 cdq
  00066	83 e2 07	 and	 edx, 7
  00069	03 c2		 add	 eax, edx
  0006b	c1 f8 03	 sar	 eax, 3
  0006e	66 89 45 fa	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 312  : 
; 313  :     //
; 314  :     // The stereo encoder requires that there be at least two DWORDs to process
; 315  :     //
; 316  : 
; 317  :     nBlockAlign += 7;

  00072	8b 45 fa	 mov	 eax, DWORD PTR _nBlockAlign$[ebp]
  00075	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0007a	83 c0 07	 add	 eax, 7
  0007d	66 89 45 fa	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 318  :     nBlockAlign /= 8;

  00081	8b 45 fa	 mov	 eax, DWORD PTR _nBlockAlign$[ebp]
  00084	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00089	99		 cdq
  0008a	83 e2 07	 and	 edx, 7
  0008d	03 c2		 add	 eax, edx
  0008f	c1 f8 03	 sar	 eax, 3
  00092	66 89 45 fa	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 319  :     nBlockAlign *= 8;

  00096	8b 4d fa	 mov	 ecx, DWORD PTR _nBlockAlign$[ebp]
  00099	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0009f	c1 e1 03	 shl	 ecx, 3
  000a2	66 89 4d fa	 mov	 WORD PTR _nBlockAlign$[ebp], cx

; 320  : 
; 321  :     //
; 322  :     // Add the header
; 323  :     //
; 324  : 
; 325  :     nBlockAlign += nHeaderBytes;

  000a6	8b 55 fc	 mov	 edx, DWORD PTR _nHeaderBytes$[ebp]
  000a9	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000af	8b 45 fa	 mov	 eax, DWORD PTR _nBlockAlign$[ebp]
  000b2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000b7	03 c2		 add	 eax, edx
  000b9	66 89 45 fa	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 326  : 
; 327  :     return nBlockAlign;

  000bd	66 8b 45 fa	 mov	 ax, WORD PTR _nBlockAlign$[ebp]

; 328  : }

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 08 00	 ret	 8
?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ENDP ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
_TEXT	ENDS
PUBLIC	?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z ; DirectSound::CImaAdpcmCodec::CreatePcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_pwfx$ = 16
?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::CreatePcmFormat, COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  :     pwfx->wFormatTag = WAVE_FORMAT_PCM;

  00003	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	66 c7 00 01 00	 mov	 WORD PTR [eax], 1

; 357  :     pwfx->nChannels = nChannels;

  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0000e	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  00012	66 89 51 02	 mov	 WORD PTR [ecx+2], dx

; 358  :     pwfx->nSamplesPerSec = nSamplesPerSec;

  00016	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0001c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 359  :     pwfx->nBlockAlign = nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _nChannels$[ebp]
  00022	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00027	c1 e0 04	 shl	 eax, 4
  0002a	99		 cdq
  0002b	83 e2 07	 and	 edx, 7
  0002e	03 c2		 add	 eax, edx
  00030	c1 f8 03	 sar	 eax, 3
  00033	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00036	66 89 42 0c	 mov	 WORD PTR [edx+12], ax

; 360  :     pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;

  0003a	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0003d	33 c9		 xor	 ecx, ecx
  0003f	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  00043	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00046	0f af 4a 04	 imul	 ecx, DWORD PTR [edx+4]
  0004a	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0004d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 361  :     pwfx->wBitsPerSample = IMAADPCM_PCM_BITS_PER_SAMPLE;

  00050	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00053	66 c7 41 0e 10
	00		 mov	 WORD PTR [ecx+14], 16	; 00000010H

; 362  : }

  00059	5d		 pop	 ebp
  0005a	c2 0c 00	 ret	 12			; 0000000cH
?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z ENDP ; DirectSound::CImaAdpcmCodec::CreatePcmFormat
_TEXT	ENDS
PUBLIC	?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z ; DirectSound::CImaAdpcmCodec::CreateImaAdpcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_nSamplesPerBlock$ = 16
_pwfx$ = 20
?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::CreateImaAdpcmFormat, COMDAT

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 391  :     pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  00004	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00007	66 c7 00 69 00	 mov	 WORD PTR [eax], 105	; 00000069H

; 392  :     pwfx->wfx.nChannels = nChannels;

  0000c	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0000f	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  00013	66 89 51 02	 mov	 WORD PTR [ecx+2], dx

; 393  :     pwfx->wfx.nSamplesPerSec = nSamplesPerSec;

  00017	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0001d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 394  :     pwfx->wfx.nBlockAlign = CalculateEncodeAlignment(nChannels, nSamplesPerBlock);

  00020	66 8b 55 10	 mov	 dx, WORD PTR _nSamplesPerBlock$[ebp]
  00024	52		 push	 edx
  00025	66 8b 45 08	 mov	 ax, WORD PTR _nChannels$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
  0002f	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00032	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 395  :     pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec * pwfx->wfx.nBlockAlign / nSamplesPerBlock;

  00036	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00039	33 c0		 xor	 eax, eax
  0003b	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  00042	0f af c8	 imul	 ecx, eax
  00045	8b 75 10	 mov	 esi, DWORD PTR _nSamplesPerBlock$[ebp]
  00048	81 e6 ff ff 00
	00		 and	 esi, 65535		; 0000ffffH
  0004e	8b c1		 mov	 eax, ecx
  00050	33 d2		 xor	 edx, edx
  00052	f7 f6		 div	 esi
  00054	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00057	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 396  :     pwfx->wfx.wBitsPerSample = IMAADPCM_BITS_PER_SAMPLE;

  0005a	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0005d	66 c7 40 0e 04
	00		 mov	 WORD PTR [eax+14], 4

; 397  :     pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);

  00063	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00066	66 c7 41 10 02
	00		 mov	 WORD PTR [ecx+16], 2

; 398  :     pwfx->wSamplesPerBlock = nSamplesPerBlock;

  0006c	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0006f	66 8b 45 10	 mov	 ax, WORD PTR _nSamplesPerBlock$[ebp]
  00073	66 89 42 12	 mov	 WORD PTR [edx+18], ax

; 399  : }

  00077	5e		 pop	 esi
  00078	5d		 pop	 ebp
  00079	c2 10 00	 ret	 16			; 00000010H
?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::CImaAdpcmCodec::CreateImaAdpcmFormat
_TEXT	ENDS
PUBLIC	?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z ; DirectSound::CImaAdpcmCodec::IsValidPcmFormat
; Function compile flags: /Odt
;	COMDAT ?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_pwfx$ = 8
?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::IsValidPcmFormat, COMDAT

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 423  :     if(WAVE_FORMAT_PCM != pwfx->wFormatTag)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000b	83 f9 01	 cmp	 ecx, 1
  0000e	74 07		 je	 SHORT $L50728

; 424  :     {
; 425  :         return FALSE;

  00010	33 c0		 xor	 eax, eax
  00012	e9 82 00 00 00	 jmp	 $L50727
$L50728:

; 426  :     }
; 427  :     
; 428  :     if((pwfx->nChannels < 1) || (pwfx->nChannels > IMAADPCM_MAX_CHANNELS))

  00017	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0001a	33 c0		 xor	 eax, eax
  0001c	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00020	83 f8 01	 cmp	 eax, 1
  00023	7c 0e		 jl	 SHORT $L50730
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00028	33 d2		 xor	 edx, edx
  0002a	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  0002e	83 fa 02	 cmp	 edx, 2
  00031	7e 04		 jle	 SHORT $L50729
$L50730:

; 429  :     {
; 430  :         return FALSE;

  00033	33 c0		 xor	 eax, eax
  00035	eb 62		 jmp	 SHORT $L50727
$L50729:

; 431  :     }
; 432  : 
; 433  :     if(IMAADPCM_PCM_BITS_PER_SAMPLE != pwfx->wBitsPerSample)

  00037	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0003a	33 c9		 xor	 ecx, ecx
  0003c	66 8b 48 0e	 mov	 cx, WORD PTR [eax+14]
  00040	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00043	74 04		 je	 SHORT $L50731

; 434  :     {
; 435  :         return FALSE;

  00045	33 c0		 xor	 eax, eax
  00047	eb 50		 jmp	 SHORT $L50727
$L50731:

; 436  :     }
; 437  : 
; 438  :     if(pwfx->nChannels * pwfx->wBitsPerSample / 8 != pwfx->nBlockAlign)

  00049	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0004c	33 c0		 xor	 eax, eax
  0004e	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00055	33 d2		 xor	 edx, edx
  00057	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  0005b	0f af c2	 imul	 eax, edx
  0005e	99		 cdq
  0005f	83 e2 07	 and	 edx, 7
  00062	03 c2		 add	 eax, edx
  00064	c1 f8 03	 sar	 eax, 3
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0006a	33 d2		 xor	 edx, edx
  0006c	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  00070	3b c2		 cmp	 eax, edx
  00072	74 04		 je	 SHORT $L50732

; 439  :     {
; 440  :         return FALSE;

  00074	33 c0		 xor	 eax, eax
  00076	eb 21		 jmp	 SHORT $L50727
$L50732:

; 441  :     }
; 442  : 
; 443  :     if(pwfx->nBlockAlign * pwfx->nSamplesPerSec != pwfx->nAvgBytesPerSec)

  00078	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0007b	33 c9		 xor	 ecx, ecx
  0007d	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  00081	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00084	0f af 4a 04	 imul	 ecx, DWORD PTR [edx+4]
  00088	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0008b	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0008e	74 04		 je	 SHORT $L50733

; 444  :     {
; 445  :         return FALSE;

  00090	33 c0		 xor	 eax, eax
  00092	eb 05		 jmp	 SHORT $L50727
$L50733:

; 446  :     }
; 447  : 
; 448  :     return TRUE;

  00094	b8 01 00 00 00	 mov	 eax, 1
$L50727:

; 449  : }

  00099	5d		 pop	 ebp
  0009a	c2 04 00	 ret	 4
?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::CImaAdpcmCodec::IsValidPcmFormat
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT
_pwfx$ = 8
?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUima_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat, COMDAT

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 473  :     if(WAVE_FORMAT_XBOX_ADPCM != pwfx->wfx.wFormatTag)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000b	83 f9 69	 cmp	 ecx, 105		; 00000069H
  0000e	74 04		 je	 SHORT $L50737

; 474  :     {
; 475  :         return FALSE;

  00010	33 c0		 xor	 eax, eax
  00012	eb 74		 jmp	 SHORT $L50736
$L50737:

; 476  :     }
; 477  : 
; 478  :     if(sizeof(*pwfx) - sizeof(pwfx->wfx) != pwfx->wfx.cbSize)

  00014	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00017	33 c0		 xor	 eax, eax
  00019	66 8b 42 10	 mov	 ax, WORD PTR [edx+16]
  0001d	83 f8 02	 cmp	 eax, 2
  00020	74 04		 je	 SHORT $L50738

; 479  :     {
; 480  :         return FALSE;

  00022	33 c0		 xor	 eax, eax
  00024	eb 62		 jmp	 SHORT $L50736
$L50738:

; 481  :     }
; 482  :     
; 483  :     if((pwfx->wfx.nChannels < 1) || (pwfx->wfx.nChannels > IMAADPCM_MAX_CHANNELS))

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00029	33 d2		 xor	 edx, edx
  0002b	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  0002f	83 fa 01	 cmp	 edx, 1
  00032	7c 0e		 jl	 SHORT $L50740
  00034	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00037	33 c9		 xor	 ecx, ecx
  00039	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0003d	83 f9 02	 cmp	 ecx, 2
  00040	7e 04		 jle	 SHORT $L50739
$L50740:

; 484  :     {
; 485  :         return FALSE;

  00042	33 c0		 xor	 eax, eax
  00044	eb 42		 jmp	 SHORT $L50736
$L50739:

; 486  :     }
; 487  : 
; 488  :     if(IMAADPCM_BITS_PER_SAMPLE != pwfx->wfx.wBitsPerSample)

  00046	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00049	33 c0		 xor	 eax, eax
  0004b	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  0004f	83 f8 04	 cmp	 eax, 4
  00052	74 04		 je	 SHORT $L50741

; 489  :     {
; 490  :         return FALSE;

  00054	33 c0		 xor	 eax, eax
  00056	eb 30		 jmp	 SHORT $L50736
$L50741:

; 491  :     }
; 492  : 
; 493  :     if(CalculateEncodeAlignment(pwfx->wfx.nChannels, pwfx->wSamplesPerBlock) != pwfx->wfx.nBlockAlign)

  00058	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0005b	66 8b 51 12	 mov	 dx, WORD PTR [ecx+18]
  0005f	52		 push	 edx
  00060	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00063	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
  0006d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00072	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00075	33 c9		 xor	 ecx, ecx
  00077	66 8b 4a 0c	 mov	 cx, WORD PTR [edx+12]
  0007b	3b c1		 cmp	 eax, ecx
  0007d	74 04		 je	 SHORT $L50742

; 494  :     {
; 495  :         return FALSE;

  0007f	33 c0		 xor	 eax, eax
  00081	eb 05		 jmp	 SHORT $L50736
$L50742:

; 496  :     }
; 497  : 
; 498  :     return TRUE;

  00083	b8 01 00 00 00	 mov	 eax, 1
$L50736:

; 499  : }

  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUima_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat
_TEXT	ENDS
PUBLIC	?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
; Function compile flags: /Odt
;	COMDAT ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z
_TEXT	SEGMENT
_nInputSample$ = 8
_pnPredictedSample$ = 12
_nStepSize$ = 16
_nPredictedSample$ = -12
_lDifference$ = -8
_nEncodedSample$ = -4
?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::EncodeSample, COMDAT

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 527  :     int                 nPredictedSample;
; 528  :     LONG                lDifference;
; 529  :     int                 nEncodedSample;
; 530  :     
; 531  :     nPredictedSample = *pnPredictedSample;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _pnPredictedSample$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d f4	 mov	 DWORD PTR _nPredictedSample$[ebp], ecx

; 532  : 
; 533  :     lDifference = nInputSample - nPredictedSample;

  0000e	8b 55 08	 mov	 edx, DWORD PTR _nInputSample$[ebp]
  00011	2b 55 f4	 sub	 edx, DWORD PTR _nPredictedSample$[ebp]
  00014	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx

; 534  :     nEncodedSample = 0;

  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nEncodedSample$[ebp], 0

; 535  : 
; 536  :     if(lDifference < 0) 

  0001e	83 7d f8 00	 cmp	 DWORD PTR _lDifference$[ebp], 0
  00022	7d 0f		 jge	 SHORT $L50751

; 537  :     {
; 538  :         nEncodedSample = 8;

  00024	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR _nEncodedSample$[ebp], 8

; 539  :         lDifference = -lDifference;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _lDifference$[ebp]
  0002e	f7 d8		 neg	 eax
  00030	89 45 f8	 mov	 DWORD PTR _lDifference$[ebp], eax
$L50751:

; 540  :     }
; 541  : 
; 542  :     if(lDifference >= nStepSize)

  00033	8b 4d f8	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  00036	3b 4d 10	 cmp	 ecx, DWORD PTR _nStepSize$[ebp]
  00039	7c 12		 jl	 SHORT $L50752

; 543  :     {
; 544  :         nEncodedSample |= 4;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _nEncodedSample$[ebp]
  0003e	83 ca 04	 or	 edx, 4
  00041	89 55 fc	 mov	 DWORD PTR _nEncodedSample$[ebp], edx

; 545  :         lDifference -= nStepSize;

  00044	8b 45 f8	 mov	 eax, DWORD PTR _lDifference$[ebp]
  00047	2b 45 10	 sub	 eax, DWORD PTR _nStepSize$[ebp]
  0004a	89 45 f8	 mov	 DWORD PTR _lDifference$[ebp], eax
$L50752:

; 546  :     }
; 547  : 
; 548  :     nStepSize >>= 1;

  0004d	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00050	d1 f9		 sar	 ecx, 1
  00052	89 4d 10	 mov	 DWORD PTR _nStepSize$[ebp], ecx

; 549  : 
; 550  :     if(lDifference >= nStepSize)

  00055	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  00058	3b 55 10	 cmp	 edx, DWORD PTR _nStepSize$[ebp]
  0005b	7c 11		 jl	 SHORT $L50753

; 551  :     {
; 552  :         nEncodedSample |= 2;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00060	0c 02		 or	 al, 2
  00062	89 45 fc	 mov	 DWORD PTR _nEncodedSample$[ebp], eax

; 553  :         lDifference -= nStepSize;

  00065	8b 4d f8	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  00068	2b 4d 10	 sub	 ecx, DWORD PTR _nStepSize$[ebp]
  0006b	89 4d f8	 mov	 DWORD PTR _lDifference$[ebp], ecx
$L50753:

; 554  :     }
; 555  : 
; 556  :     nStepSize >>= 1;

  0006e	8b 55 10	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  00071	d1 fa		 sar	 edx, 1
  00073	89 55 10	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 557  : 
; 558  :     if(lDifference >= nStepSize)

  00076	8b 45 f8	 mov	 eax, DWORD PTR _lDifference$[ebp]
  00079	3b 45 10	 cmp	 eax, DWORD PTR _nStepSize$[ebp]
  0007c	7c 12		 jl	 SHORT $L50754

; 559  :     {
; 560  :         nEncodedSample |= 1;

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _nEncodedSample$[ebp]
  00081	83 c9 01	 or	 ecx, 1
  00084	89 4d fc	 mov	 DWORD PTR _nEncodedSample$[ebp], ecx

; 561  :         lDifference -= nStepSize;

  00087	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0008a	2b 55 10	 sub	 edx, DWORD PTR _nStepSize$[ebp]
  0008d	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L50754:

; 562  :     }
; 563  : 
; 564  :     if(nEncodedSample & 8)

  00090	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00093	83 e0 08	 and	 eax, 8
  00096	85 c0		 test	 eax, eax
  00098	74 12		 je	 SHORT $L50755

; 565  :     {
; 566  :         nPredictedSample = nInputSample + lDifference - (nStepSize >> 1);

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _nInputSample$[ebp]
  0009d	03 4d f8	 add	 ecx, DWORD PTR _lDifference$[ebp]
  000a0	8b 55 10	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  000a3	d1 fa		 sar	 edx, 1
  000a5	2b ca		 sub	 ecx, edx
  000a7	89 4d f4	 mov	 DWORD PTR _nPredictedSample$[ebp], ecx

; 567  :     }
; 568  :     else

  000aa	eb 10		 jmp	 SHORT $L50756
$L50755:

; 569  :     {
; 570  :         nPredictedSample = nInputSample - lDifference + (nStepSize >> 1);

  000ac	8b 45 08	 mov	 eax, DWORD PTR _nInputSample$[ebp]
  000af	2b 45 f8	 sub	 eax, DWORD PTR _lDifference$[ebp]
  000b2	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  000b5	d1 f9		 sar	 ecx, 1
  000b7	03 c1		 add	 eax, ecx
  000b9	89 45 f4	 mov	 DWORD PTR _nPredictedSample$[ebp], eax
$L50756:

; 571  :     }
; 572  : 
; 573  :     if(nPredictedSample > 32767)

  000bc	81 7d f4 ff 7f
	00 00		 cmp	 DWORD PTR _nPredictedSample$[ebp], 32767 ; 00007fffH
  000c3	7e 09		 jle	 SHORT $L50757

; 574  :     {
; 575  :         nPredictedSample = 32767;

  000c5	c7 45 f4 ff 7f
	00 00		 mov	 DWORD PTR _nPredictedSample$[ebp], 32767 ; 00007fffH

; 576  :     }
; 577  :     else if(nPredictedSample < -32768)

  000cc	eb 10		 jmp	 SHORT $L50758
$L50757:
  000ce	81 7d f4 00 80
	ff ff		 cmp	 DWORD PTR _nPredictedSample$[ebp], -32768 ; ffff8000H
  000d5	7d 07		 jge	 SHORT $L50759

; 578  :     {
; 579  :         nPredictedSample = -32768;

  000d7	c7 45 f4 00 80
	ff ff		 mov	 DWORD PTR _nPredictedSample$[ebp], -32768 ; ffff8000H
$L50759:
$L50758:

; 580  :     }
; 581  : 
; 582  :     *pnPredictedSample = nPredictedSample;

  000de	8b 55 0c	 mov	 edx, DWORD PTR _pnPredictedSample$[ebp]
  000e1	8b 45 f4	 mov	 eax, DWORD PTR _nPredictedSample$[ebp]
  000e4	89 02		 mov	 DWORD PTR [edx], eax

; 583  :     
; 584  :     return nEncodedSample;

  000e6	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]

; 585  : }

  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 0c 00	 ret	 12			; 0000000cH
?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ENDP ; DirectSound::CImaAdpcmCodec::EncodeSample
_TEXT	ENDS
PUBLIC	?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
; Function compile flags: /Odt
;	COMDAT ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z
_TEXT	SEGMENT
_nEncodedSample$ = 8
_nPredictedSample$ = 12
_nStepSize$ = 16
_lDifference$ = -8
_lNewSample$ = -4
?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::DecodeSample, COMDAT

; 612  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 613  :     LONG                lDifference;
; 614  :     LONG                lNewSample;
; 615  : 
; 616  :     lDifference = nStepSize >> 3;

  00006	8b 45 10	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  00009	c1 f8 03	 sar	 eax, 3
  0000c	89 45 f8	 mov	 DWORD PTR _lDifference$[ebp], eax

; 617  : 
; 618  :     if(nEncodedSample & 4) 

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _nEncodedSample$[ebp]
  00012	83 e1 04	 and	 ecx, 4
  00015	85 c9		 test	 ecx, ecx
  00017	74 09		 je	 SHORT $L50767

; 619  :     {
; 620  :         lDifference += nStepSize;

  00019	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0001c	03 55 10	 add	 edx, DWORD PTR _nStepSize$[ebp]
  0001f	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L50767:

; 621  :     }
; 622  : 
; 623  :     if(nEncodedSample & 2) 

  00022	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00025	83 e0 02	 and	 eax, 2
  00028	85 c0		 test	 eax, eax
  0002a	74 0d		 je	 SHORT $L50768

; 624  :     {
; 625  :         lDifference += nStepSize >> 1;

  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  0002f	d1 f9		 sar	 ecx, 1
  00031	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  00034	03 d1		 add	 edx, ecx
  00036	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L50768:

; 626  :     }
; 627  : 
; 628  :     if(nEncodedSample & 1) 

  00039	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  0003c	83 e0 01	 and	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	74 0e		 je	 SHORT $L50769

; 629  :     {
; 630  :         lDifference += nStepSize >> 2;

  00043	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00046	c1 f9 02	 sar	 ecx, 2
  00049	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0004c	03 d1		 add	 edx, ecx
  0004e	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L50769:

; 631  :     }
; 632  : 
; 633  :     if(nEncodedSample & 8)

  00051	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00054	83 e0 08	 and	 eax, 8
  00057	85 c0		 test	 eax, eax
  00059	74 08		 je	 SHORT $L50770

; 634  :     {
; 635  :         lDifference = -lDifference;

  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  0005e	f7 d9		 neg	 ecx
  00060	89 4d f8	 mov	 DWORD PTR _lDifference$[ebp], ecx
$L50770:

; 636  :     }
; 637  : 
; 638  :     lNewSample = nPredictedSample + lDifference;

  00063	8b 55 0c	 mov	 edx, DWORD PTR _nPredictedSample$[ebp]
  00066	03 55 f8	 add	 edx, DWORD PTR _lDifference$[ebp]
  00069	89 55 fc	 mov	 DWORD PTR _lNewSample$[ebp], edx

; 639  : 
; 640  :     if((LONG)(short)lNewSample != lNewSample)

  0006c	0f bf 45 fc	 movsx	 eax, WORD PTR _lNewSample$[ebp]
  00070	3b 45 fc	 cmp	 eax, DWORD PTR _lNewSample$[ebp]
  00073	74 19		 je	 SHORT $L50773

; 641  :     {
; 642  :         if(lNewSample < -32768)

  00075	81 7d fc 00 80
	ff ff		 cmp	 DWORD PTR _lNewSample$[ebp], -32768 ; ffff8000H
  0007c	7d 09		 jge	 SHORT $L50774

; 643  :         {
; 644  :             lNewSample = -32768;

  0007e	c7 45 fc 00 80
	ff ff		 mov	 DWORD PTR _lNewSample$[ebp], -32768 ; ffff8000H

; 645  :         }
; 646  :         else

  00085	eb 07		 jmp	 SHORT $L50775
$L50774:

; 647  :         {
; 648  :             lNewSample = 32767;

  00087	c7 45 fc ff 7f
	00 00		 mov	 DWORD PTR _lNewSample$[ebp], 32767 ; 00007fffH
$L50775:
$L50773:

; 649  :         }
; 650  :     }
; 651  : 
; 652  :     return (int)lNewSample;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _lNewSample$[ebp]

; 653  : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ENDP	; DirectSound::CImaAdpcmCodec::DecodeSample
_TEXT	ENDS
PUBLIC	?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
; Function compile flags: /Odt
;	COMDAT ?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_pnStepIndexL$ = 28
_pbBlock$ = -20
_cSamples$ = -16
_nSample$ = -28
_nStepSize$ = -32
_nEncSample1$ = -8
_nEncSample2$ = -12
_nPredSample$ = -24
_nStepIndex$ = -4
?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::EncodeM16, COMDAT

; 689  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 690  :     LPBYTE                  pbBlock;
; 691  :     UINT                    cSamples;
; 692  :     int                     nSample;
; 693  :     int                     nStepSize;
; 694  :     int                     nEncSample1;
; 695  :     int                     nEncSample2;
; 696  :     int                     nPredSample;
; 697  :     int                     nStepIndex;
; 698  : 
; 699  :     //
; 700  :     // Save a local copy of the step index so we're not constantly 
; 701  :     // dereferencing a pointer.
; 702  :     //
; 703  :     
; 704  :     nStepIndex = *pnStepIndexL;

  00006	8b 45 1c	 mov	 eax, DWORD PTR _pnStepIndexL$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d fc	 mov	 DWORD PTR _nStepIndex$[ebp], ecx
$L50795:

; 705  : 
; 706  :     //
; 707  :     // Enter the main loop
; 708  :     //
; 709  :     
; 710  :     while(cBlocks--)

  0000e	8b 55 10	 mov	 edx, DWORD PTR _cBlocks$[ebp]
  00011	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00014	83 e8 01	 sub	 eax, 1
  00017	89 45 10	 mov	 DWORD PTR _cBlocks$[ebp], eax
  0001a	85 d2		 test	 edx, edx
  0001c	0f 84 2f 01 00
	00		 je	 $L50796

; 711  :     {
; 712  :         pbBlock = pbDst;

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  00025	89 4d ec	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 713  :         cSamples = cSamplesPerBlock - 1;

  00028	8b 55 18	 mov	 edx, DWORD PTR _cSamplesPerBlock$[ebp]
  0002b	83 ea 01	 sub	 edx, 1
  0002e	89 55 f0	 mov	 DWORD PTR _cSamples$[ebp], edx

; 714  : 
; 715  :         //
; 716  :         // Block header
; 717  :         //
; 718  : 
; 719  :         nPredSample = *(short *)pbSrc;

  00031	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00034	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00037	89 4d e8	 mov	 DWORD PTR _nPredSample$[ebp], ecx

; 720  :         pbSrc += sizeof(short);

  0003a	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0003d	83 c2 02	 add	 edx, 2
  00040	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 721  : 
; 722  :         *(LONG *)pbBlock = MAKELONG(nPredSample, nStepIndex);

  00043	8b 45 e8	 mov	 eax, DWORD PTR _nPredSample$[ebp]
  00046	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  00053	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00059	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0005f	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00062	0b c1		 or	 eax, ecx
  00064	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00067	89 02		 mov	 DWORD PTR [edx], eax

; 723  :         pbBlock += sizeof(LONG);

  00069	8b 45 ec	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  0006c	83 c0 04	 add	 eax, 4
  0006f	89 45 ec	 mov	 DWORD PTR _pbBlock$[ebp], eax
$L50808:

; 724  : 
; 725  :         //
; 726  :         // We have written the header for this block--now write the data
; 727  :         // chunk (which consists of a bunch of encoded nibbles).  Note
; 728  :         // that if we don't have enough data to fill a complete byte, then
; 729  :         // we add a 0 nibble on the end.
; 730  :         //
; 731  : 
; 732  :         while(cSamples)

  00072	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  00076	0f 84 c7 00 00
	00		 je	 $L50809

; 733  :         {
; 734  :             //
; 735  :             // Sample 1
; 736  :             //
; 737  : 
; 738  :             nSample = *(short *)pbSrc;

  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  0007f	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00082	89 55 e4	 mov	 DWORD PTR _nSample$[ebp], edx

; 739  :             pbSrc += sizeof(short);

  00085	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00088	83 c0 02	 add	 eax, 2
  0008b	89 45 08	 mov	 DWORD PTR _pbSrc$[ebp], eax

; 740  :             cSamples--;

  0008e	8b 4d f0	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  00091	83 e9 01	 sub	 ecx, 1
  00094	89 4d f0	 mov	 DWORD PTR _cSamples$[ebp], ecx

; 741  : 
; 742  :             nStepSize = m_asStep[nStepIndex];

  00097	8b 55 fc	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  0009a	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  000a2	89 45 e0	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 743  :             nEncSample1 = EncodeSample(nSample, &nPredSample, nStepSize);

  000a5	8b 4d e0	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  000a8	51		 push	 ecx
  000a9	8d 55 e8	 lea	 edx, DWORD PTR _nPredSample$[ebp]
  000ac	52		 push	 edx
  000ad	8b 45 e4	 mov	 eax, DWORD PTR _nSample$[ebp]
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  000b6	89 45 f8	 mov	 DWORD PTR _nEncSample1$[ebp], eax

; 744  :             nStepIndex = NextStepIndex(nEncSample1, nStepIndex);

  000b9	8b 4d fc	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  000bc	51		 push	 ecx
  000bd	8b 55 f8	 mov	 edx, DWORD PTR _nEncSample1$[ebp]
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  000c6	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 745  : 
; 746  :             //
; 747  :             // Sample 2
; 748  :             //
; 749  : 
; 750  :             if(cSamples)

  000c9	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000cd	74 4f		 je	 SHORT $L50812

; 751  :             {
; 752  :                 nSample = *(short *)pbSrc;

  000cf	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  000d2	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000d5	89 4d e4	 mov	 DWORD PTR _nSample$[ebp], ecx

; 753  :                 pbSrc += sizeof(short);

  000d8	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  000db	83 c2 02	 add	 edx, 2
  000de	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 754  :                 cSamples--;

  000e1	8b 45 f0	 mov	 eax, DWORD PTR _cSamples$[ebp]
  000e4	83 e8 01	 sub	 eax, 1
  000e7	89 45 f0	 mov	 DWORD PTR _cSamples$[ebp], eax

; 755  : 
; 756  :                 nStepSize = m_asStep[nStepIndex];

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  000ed	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[ecx*2]
  000f5	89 55 e0	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 757  :                 nEncSample2 = EncodeSample(nSample, &nPredSample, nStepSize);

  000f8	8b 45 e0	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  000fb	50		 push	 eax
  000fc	8d 4d e8	 lea	 ecx, DWORD PTR _nPredSample$[ebp]
  000ff	51		 push	 ecx
  00100	8b 55 e4	 mov	 edx, DWORD PTR _nSample$[ebp]
  00103	52		 push	 edx
  00104	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  00109	89 45 f4	 mov	 DWORD PTR _nEncSample2$[ebp], eax

; 758  :                 nStepIndex = NextStepIndex(nEncSample2, nStepIndex);

  0010c	8b 45 fc	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  0010f	50		 push	 eax
  00110	8b 4d f4	 mov	 ecx, DWORD PTR _nEncSample2$[ebp]
  00113	51		 push	 ecx
  00114	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  00119	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 759  :             }
; 760  :             else

  0011c	eb 07		 jmp	 SHORT $L50815
$L50812:

; 761  :             {
; 762  :                 nEncSample2 = 0;

  0011e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nEncSample2$[ebp], 0
$L50815:

; 763  :             }
; 764  : 
; 765  :             //
; 766  :             // Write out encoded byte.
; 767  :             //
; 768  : 
; 769  :             *pbBlock++ = (BYTE)(nEncSample1 | (nEncSample2 << 4));

  00125	8b 55 f4	 mov	 edx, DWORD PTR _nEncSample2$[ebp]
  00128	c1 e2 04	 shl	 edx, 4
  0012b	8b 45 f8	 mov	 eax, DWORD PTR _nEncSample1$[ebp]
  0012e	0b c2		 or	 eax, edx
  00130	8b 4d ec	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00133	88 01		 mov	 BYTE PTR [ecx], al
  00135	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00138	83 c2 01	 add	 edx, 1
  0013b	89 55 ec	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 770  :         }

  0013e	e9 2f ff ff ff	 jmp	 $L50808
$L50809:

; 771  : 
; 772  :         //
; 773  :         // Skip padding
; 774  :         //
; 775  : 
; 776  :         pbDst += nBlockAlignment;

  00143	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  00146	03 45 14	 add	 eax, DWORD PTR _nBlockAlignment$[ebp]
  00149	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 777  :     }

  0014c	e9 bd fe ff ff	 jmp	 $L50795
$L50796:

; 778  : 
; 779  :     //
; 780  :     // Restore the value of the step index to be used on the next buffer.
; 781  :     //
; 782  : 
; 783  :     *pnStepIndexL = nStepIndex;

  00151	8b 4d 1c	 mov	 ecx, DWORD PTR _pnStepIndexL$[ebp]
  00154	8b 55 fc	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  00157	89 11		 mov	 DWORD PTR [ecx], edx

; 784  : 
; 785  :     return TRUE;

  00159	b8 01 00 00 00	 mov	 eax, 1

; 786  : }

  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 1c 00	 ret	 28			; 0000001cH
?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::EncodeM16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.h
_TEXT	ENDS
;	COMDAT ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z
_TEXT	SEGMENT
_nEncodedSample$ = 8
_nStepIndex$ = 12
?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::NextStepIndex, COMDAT

; 115  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 116  :         nStepIndex += m_asNextStep[nEncodedSample];

  00003	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00006	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_asNextStep@CImaAdpcmCodec@DirectSound@@0QBFB[eax*2]
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  00011	03 d1		 add	 edx, ecx
  00013	89 55 0c	 mov	 DWORD PTR _nStepIndex$[ebp], edx

; 117  : 
; 118  :         if(nStepIndex < 0)

  00016	83 7d 0c 00	 cmp	 DWORD PTR _nStepIndex$[ebp], 0
  0001a	7d 09		 jge	 SHORT $L48277

; 119  :         {
; 120  :             nStepIndex = 0;

  0001c	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _nStepIndex$[ebp], 0

; 121  :         }
; 122  :         else if(nStepIndex >= NUMELMS(m_asStep))

  00023	eb 0d		 jmp	 SHORT $L48278
$L48277:
  00025	83 7d 0c 59	 cmp	 DWORD PTR _nStepIndex$[ebp], 89 ; 00000059H
  00029	72 07		 jb	 SHORT $L48279

; 123  :         {
; 124  :             nStepIndex = NUMELMS(m_asStep) - 1;

  0002b	c7 45 0c 58 00
	00 00		 mov	 DWORD PTR _nStepIndex$[ebp], 88 ; 00000058H
$L48279:
$L48278:

; 125  :         }
; 126  : 
; 127  :         return nStepIndex;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _nStepIndex$[ebp]

; 128  :     }

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ENDP	; DirectSound::CImaAdpcmCodec::NextStepIndex
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
_TEXT	ENDS
;	COMDAT ?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_pnStepIndexL$ = 28
_pnStepIndexR$ = 32
_pbBlock$ = -20
_cSamples$ = -16
_cSubSamples$ = -4
_nSample$ = -52
_nStepSize$ = -56
_dwLeft$ = -36
_dwRight$ = -28
_nEncSampleL$ = -48
_nPredSampleL$ = -40
_nStepIndexL$ = -24
_nEncSampleR$ = -12
_nPredSampleR$ = -8
_nStepIndexR$ = -44
_i$ = -32
?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::EncodeS16, COMDAT

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 801  :     LPBYTE                  pbBlock;
; 802  :     UINT                    cSamples;
; 803  :     UINT                    cSubSamples;
; 804  :     int                     nSample;
; 805  :     int                     nStepSize;
; 806  :     DWORD                   dwLeft;
; 807  :     DWORD                   dwRight;
; 808  :     int                     nEncSampleL;
; 809  :     int                     nPredSampleL;
; 810  :     int                     nStepIndexL;
; 811  :     int                     nEncSampleR;
; 812  :     int                     nPredSampleR;
; 813  :     int                     nStepIndexR;
; 814  :     UINT                    i;
; 815  : 
; 816  :     //
; 817  :     // Save a local copy of the step indeces so we're not constantly 
; 818  :     // dereferencing a pointer.
; 819  :     //
; 820  :     
; 821  :     nStepIndexL = *pnStepIndexL;

  00006	8b 45 1c	 mov	 eax, DWORD PTR _pnStepIndexL$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d e8	 mov	 DWORD PTR _nStepIndexL$[ebp], ecx

; 822  :     nStepIndexR = *pnStepIndexR;

  0000e	8b 55 20	 mov	 edx, DWORD PTR _pnStepIndexR$[ebp]
  00011	8b 02		 mov	 eax, DWORD PTR [edx]
  00013	89 45 d4	 mov	 DWORD PTR _nStepIndexR$[ebp], eax
$L50841:

; 823  : 
; 824  :     //
; 825  :     // Enter the main loop
; 826  :     //
; 827  :     
; 828  :     while(cBlocks--)

  00016	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00019	8b 55 10	 mov	 edx, DWORD PTR _cBlocks$[ebp]
  0001c	83 ea 01	 sub	 edx, 1
  0001f	89 55 10	 mov	 DWORD PTR _cBlocks$[ebp], edx
  00022	85 c9		 test	 ecx, ecx
  00024	0f 84 d3 01 00
	00		 je	 $L50842

; 829  :     {
; 830  :         pbBlock = pbDst;

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  0002d	89 45 ec	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 831  :         cSamples = cSamplesPerBlock - 1;

  00030	8b 4d 18	 mov	 ecx, DWORD PTR _cSamplesPerBlock$[ebp]
  00033	83 e9 01	 sub	 ecx, 1
  00036	89 4d f0	 mov	 DWORD PTR _cSamples$[ebp], ecx

; 832  : 
; 833  :         //
; 834  :         // LEFT channel block header
; 835  :         //
; 836  : 
; 837  :         nPredSampleL = *(short *)pbSrc;

  00039	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0003c	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0003f	89 45 d8	 mov	 DWORD PTR _nPredSampleL$[ebp], eax

; 838  :         pbSrc += sizeof(short);

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  00045	83 c1 02	 add	 ecx, 2
  00048	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 839  : 
; 840  :         *(LONG *)pbBlock = MAKELONG(nPredSampleL, nStepIndexL);

  0004b	8b 55 d8	 mov	 edx, DWORD PTR _nPredSampleL$[ebp]
  0004e	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00054	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0005a	8b 45 e8	 mov	 eax, DWORD PTR _nStepIndexL$[ebp]
  0005d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00062	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00067	c1 e0 10	 shl	 eax, 16			; 00000010H
  0006a	0b d0		 or	 edx, eax
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  0006f	89 11		 mov	 DWORD PTR [ecx], edx

; 841  :         pbBlock += sizeof(LONG);

  00071	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00074	83 c2 04	 add	 edx, 4
  00077	89 55 ec	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 842  : 
; 843  :         //
; 844  :         // RIGHT channel block header
; 845  :         //
; 846  : 
; 847  :         nPredSampleR = *(short *)pbSrc;

  0007a	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  0007d	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00080	89 4d f8	 mov	 DWORD PTR _nPredSampleR$[ebp], ecx

; 848  :         pbSrc += sizeof(short);

  00083	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00086	83 c2 02	 add	 edx, 2
  00089	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 849  : 
; 850  :         *(LONG *)pbBlock = MAKELONG(nPredSampleR, nStepIndexR);

  0008c	8b 45 f8	 mov	 eax, DWORD PTR _nPredSampleR$[ebp]
  0008f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00094	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00099	8b 4d d4	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  0009c	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000a2	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000a8	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000ab	0b c1		 or	 eax, ecx
  000ad	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  000b0	89 02		 mov	 DWORD PTR [edx], eax

; 851  :         pbBlock += sizeof(LONG);

  000b2	8b 45 ec	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  000b5	83 c0 04	 add	 eax, 4
  000b8	89 45 ec	 mov	 DWORD PTR _pbBlock$[ebp], eax
$L50864:

; 852  : 
; 853  :         //
; 854  :         // We have written the header for this block--now write the data
; 855  :         // chunk.  This consists of 8 left samples (one DWORD of output)
; 856  :         // followed by 8 right samples (also one DWORD).  Since the input
; 857  :         // samples are interleaved, we create the left and right DWORDs
; 858  :         // sample by sample, and then write them both out.
; 859  :         //
; 860  : 
; 861  :         while(cSamples)

  000bb	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000bf	0f 84 2a 01 00
	00		 je	 $L50865

; 862  :         {
; 863  :             dwLeft = 0;

  000c5	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _dwLeft$[ebp], 0

; 864  :             dwRight = 0;

  000cc	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _dwRight$[ebp], 0

; 865  : 
; 866  :             cSubSamples = min(cSamples, 8);

  000d3	83 7d f0 08	 cmp	 DWORD PTR _cSamples$[ebp], 8
  000d7	73 08		 jae	 SHORT $L51915
  000d9	8b 4d f0	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  000dc	89 4d c4	 mov	 DWORD PTR -60+[ebp], ecx
  000df	eb 07		 jmp	 SHORT $L51916
$L51915:
  000e1	c7 45 c4 08 00
	00 00		 mov	 DWORD PTR -60+[ebp], 8
$L51916:
  000e8	8b 55 c4	 mov	 edx, DWORD PTR -60+[ebp]
  000eb	89 55 fc	 mov	 DWORD PTR _cSubSamples$[ebp], edx

; 867  : 
; 868  :             for(i = 0; i < cSubSamples; i++)

  000ee	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000f5	eb 09		 jmp	 SHORT $L50866
$L50867:
  000f7	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  000fa	83 c0 01	 add	 eax, 1
  000fd	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$L50866:
  00100	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  00103	3b 4d fc	 cmp	 ecx, DWORD PTR _cSubSamples$[ebp]
  00106	0f 83 b3 00 00
	00		 jae	 $L50868

; 869  :             {
; 870  :                 //
; 871  :                 // LEFT channel
; 872  :                 //
; 873  : 
; 874  :                 nSample = *(short *)pbSrc;

  0010c	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0010f	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00112	89 45 cc	 mov	 DWORD PTR _nSample$[ebp], eax

; 875  :                 pbSrc += sizeof(short);

  00115	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  00118	83 c1 02	 add	 ecx, 2
  0011b	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 876  : 
; 877  :                 nStepSize = m_asStep[nStepIndexL];

  0011e	8b 55 e8	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  00121	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  00129	89 45 c8	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 878  :                 
; 879  :                 nEncSampleL = EncodeSample(nSample, &nPredSampleL, nStepSize);

  0012c	8b 4d c8	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  0012f	51		 push	 ecx
  00130	8d 55 d8	 lea	 edx, DWORD PTR _nPredSampleL$[ebp]
  00133	52		 push	 edx
  00134	8b 45 cc	 mov	 eax, DWORD PTR _nSample$[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  0013d	89 45 d0	 mov	 DWORD PTR _nEncSampleL$[ebp], eax

; 880  : 
; 881  :                 nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);

  00140	8b 4d e8	 mov	 ecx, DWORD PTR _nStepIndexL$[ebp]
  00143	51		 push	 ecx
  00144	8b 55 d0	 mov	 edx, DWORD PTR _nEncSampleL$[ebp]
  00147	52		 push	 edx
  00148	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  0014d	89 45 e8	 mov	 DWORD PTR _nStepIndexL$[ebp], eax

; 882  :                 dwLeft |= (DWORD)nEncSampleL << (4 * i);

  00150	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  00153	c1 e1 02	 shl	 ecx, 2
  00156	8b 45 d0	 mov	 eax, DWORD PTR _nEncSampleL$[ebp]
  00159	d3 e0		 shl	 eax, cl
  0015b	8b 4d dc	 mov	 ecx, DWORD PTR _dwLeft$[ebp]
  0015e	0b c8		 or	 ecx, eax
  00160	89 4d dc	 mov	 DWORD PTR _dwLeft$[ebp], ecx

; 883  : 
; 884  :                 //
; 885  :                 // RIGHT channel
; 886  :                 //
; 887  : 
; 888  :                 nSample = *(short *)pbSrc;

  00163	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00166	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00169	89 45 cc	 mov	 DWORD PTR _nSample$[ebp], eax

; 889  :                 pbSrc += sizeof(short);

  0016c	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  0016f	83 c1 02	 add	 ecx, 2
  00172	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 890  : 
; 891  :                 nStepSize = m_asStep[nStepIndexR];

  00175	8b 55 d4	 mov	 edx, DWORD PTR _nStepIndexR$[ebp]
  00178	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  00180	89 45 c8	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 892  :                 
; 893  :                 nEncSampleR = EncodeSample(nSample, &nPredSampleR, nStepSize);

  00183	8b 4d c8	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00186	51		 push	 ecx
  00187	8d 55 f8	 lea	 edx, DWORD PTR _nPredSampleR$[ebp]
  0018a	52		 push	 edx
  0018b	8b 45 cc	 mov	 eax, DWORD PTR _nSample$[ebp]
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  00194	89 45 f4	 mov	 DWORD PTR _nEncSampleR$[ebp], eax

; 894  : 
; 895  :                 nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);

  00197	8b 4d d4	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  0019a	51		 push	 ecx
  0019b	8b 55 f4	 mov	 edx, DWORD PTR _nEncSampleR$[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  001a4	89 45 d4	 mov	 DWORD PTR _nStepIndexR$[ebp], eax

; 896  :                 dwRight |= (DWORD)nEncSampleR << (4 * i);

  001a7	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  001aa	c1 e1 02	 shl	 ecx, 2
  001ad	8b 45 f4	 mov	 eax, DWORD PTR _nEncSampleR$[ebp]
  001b0	d3 e0		 shl	 eax, cl
  001b2	8b 4d e4	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  001b5	0b c8		 or	 ecx, eax
  001b7	89 4d e4	 mov	 DWORD PTR _dwRight$[ebp], ecx

; 897  :             }

  001ba	e9 38 ff ff ff	 jmp	 $L50867
$L50868:

; 898  : 
; 899  :             //
; 900  :             // Write out encoded DWORDs.
; 901  :             //
; 902  : 
; 903  :             *(LPDWORD)pbBlock = dwLeft;

  001bf	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  001c2	8b 45 dc	 mov	 eax, DWORD PTR _dwLeft$[ebp]
  001c5	89 02		 mov	 DWORD PTR [edx], eax

; 904  :             pbBlock += sizeof(DWORD);

  001c7	8b 4d ec	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  001ca	83 c1 04	 add	 ecx, 4
  001cd	89 4d ec	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 905  : 
; 906  :             *(LPDWORD)pbBlock = dwRight;

  001d0	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  001d3	8b 45 e4	 mov	 eax, DWORD PTR _dwRight$[ebp]
  001d6	89 02		 mov	 DWORD PTR [edx], eax

; 907  :             pbBlock += sizeof(DWORD);

  001d8	8b 4d ec	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  001db	83 c1 04	 add	 ecx, 4
  001de	89 4d ec	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 908  : 
; 909  :             cSamples -= cSubSamples;

  001e1	8b 55 f0	 mov	 edx, DWORD PTR _cSamples$[ebp]
  001e4	2b 55 fc	 sub	 edx, DWORD PTR _cSubSamples$[ebp]
  001e7	89 55 f0	 mov	 DWORD PTR _cSamples$[ebp], edx

; 910  :         }

  001ea	e9 cc fe ff ff	 jmp	 $L50864
$L50865:

; 911  : 
; 912  :         //
; 913  :         // Skip padding
; 914  :         //
; 915  : 
; 916  :         pbDst += nBlockAlignment;

  001ef	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  001f2	03 45 14	 add	 eax, DWORD PTR _nBlockAlignment$[ebp]
  001f5	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 917  :     }

  001f8	e9 19 fe ff ff	 jmp	 $L50841
$L50842:

; 918  : 
; 919  :     //
; 920  :     // Restore the value of the step index to be used on the next buffer.
; 921  :     //
; 922  :     
; 923  :     *pnStepIndexL = nStepIndexL;

  001fd	8b 4d 1c	 mov	 ecx, DWORD PTR _pnStepIndexL$[ebp]
  00200	8b 55 e8	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  00203	89 11		 mov	 DWORD PTR [ecx], edx

; 924  :     *pnStepIndexR = nStepIndexR;

  00205	8b 45 20	 mov	 eax, DWORD PTR _pnStepIndexR$[ebp]
  00208	8b 4d d4	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  0020b	89 08		 mov	 DWORD PTR [eax], ecx

; 925  : 
; 926  :     return TRUE;

  0020d	b8 01 00 00 00	 mov	 eax, 1

; 927  : 
; 928  : }

  00212	8b e5		 mov	 esp, ebp
  00214	5d		 pop	 ebp
  00215	c2 1c 00	 ret	 28			; 0000001cH
?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::EncodeS16
_TEXT	ENDS
PUBLIC	?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
; Function compile flags: /Odt
;	COMDAT ?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_fSuccess$ = -32
_pbBlock$ = -16
_cSamples$ = -8
_bSample$ = -21
_nStepSize$ = -36
_nEncSample$ = -20
_nPredSample$ = -28
_nStepIndex$ = -4
_dwHeader$ = -12
?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::DecodeM16, COMDAT

; 942  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 943  :     BOOL                    fSuccess    = TRUE;

  00006	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 1
$L50898:

; 944  :     LPBYTE                  pbBlock;
; 945  :     UINT                    cSamples;
; 946  :     BYTE                    bSample;
; 947  :     int                     nStepSize;
; 948  :     int                     nEncSample;
; 949  :     int                     nPredSample;
; 950  :     int                     nStepIndex;
; 951  :     DWORD                   dwHeader;
; 952  : 
; 953  :     //
; 954  :     // Enter the main loop
; 955  :     //
; 956  :     
; 957  :     while(cBlocks--)

  0000d	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00013	83 e9 01	 sub	 ecx, 1
  00016	89 4d 10	 mov	 DWORD PTR _cBlocks$[ebp], ecx
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 57 01 00
	00		 je	 $L50899

; 958  :     {
; 959  :         pbBlock = pbSrc;

  00021	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00024	89 55 f0	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 960  :         cSamples = cSamplesPerBlock - 1;

  00027	8b 45 18	 mov	 eax, DWORD PTR _cSamplesPerBlock$[ebp]
  0002a	83 e8 01	 sub	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _cSamples$[ebp], eax

; 961  :         
; 962  :         //
; 963  :         // Block header
; 964  :         //
; 965  : 
; 966  :         dwHeader = *(LPDWORD)pbBlock;

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	89 55 f4	 mov	 DWORD PTR _dwHeader$[ebp], edx

; 967  :         pbBlock += sizeof(DWORD);

  00038	8b 45 f0	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 f0	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 968  : 
; 969  :         nPredSample = (int)(short)LOWORD(dwHeader);

  00041	8b 4d f4	 mov	 ecx, DWORD PTR _dwHeader$[ebp]
  00044	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0004a	0f bf d1	 movsx	 edx, cx
  0004d	89 55 e4	 mov	 DWORD PTR _nPredSample$[ebp], edx

; 970  :         nStepIndex = (int)(BYTE)HIWORD(dwHeader);

  00050	8b 45 f4	 mov	 eax, DWORD PTR _dwHeader$[ebp]
  00053	c1 e8 10	 shr	 eax, 16			; 00000010H
  00056	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005b	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 971  : 
; 972  :         if(!ValidStepIndex(nStepIndex))

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
  00067	85 c0		 test	 eax, eax
  00069	75 0c		 jne	 SHORT $L50910

; 973  :         {
; 974  :             //
; 975  :             // The step index is out of range - this is considered a fatal
; 976  :             // error as the input stream is corrupted.  We fail by returning
; 977  :             // zero bytes converted.
; 978  :             //
; 979  : 
; 980  :             fSuccess = FALSE;

  0006b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 981  :             break;

  00072	e9 01 01 00 00	 jmp	 $L50899
$L50910:

; 982  :         }
; 983  :         
; 984  :         //
; 985  :         // Write out first sample
; 986  :         //
; 987  : 
; 988  :         *(short *)pbDst = (short)nPredSample;

  00077	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  0007a	66 8b 45 e4	 mov	 ax, WORD PTR _nPredSample$[ebp]
  0007e	66 89 02	 mov	 WORD PTR [edx], ax

; 989  :         pbDst += sizeof(short);

  00081	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  00084	83 c1 02	 add	 ecx, 2
  00087	89 4d 0c	 mov	 DWORD PTR _pbDst$[ebp], ecx
$L50915:

; 990  : 
; 991  :         //
; 992  :         // Enter the block loop
; 993  :         //
; 994  : 
; 995  :         while(cSamples)

  0008a	83 7d f8 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  0008e	0f 84 d6 00 00
	00		 je	 $L50916

; 996  :         {
; 997  :             bSample = *pbBlock++;

  00094	8b 55 f0	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00097	8a 02		 mov	 al, BYTE PTR [edx]
  00099	88 45 eb	 mov	 BYTE PTR _bSample$[ebp], al
  0009c	8b 4d f0	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  0009f	83 c1 01	 add	 ecx, 1
  000a2	89 4d f0	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 998  : 
; 999  :             //
; 1000 :             // Sample 1
; 1001 :             //
; 1002 : 
; 1003 :             nEncSample = (bSample & (BYTE)0x0F);

  000a5	8b 55 eb	 mov	 edx, DWORD PTR _bSample$[ebp]
  000a8	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000ae	83 e2 0f	 and	 edx, 15			; 0000000fH
  000b1	89 55 ec	 mov	 DWORD PTR _nEncSample$[ebp], edx

; 1004 :             nStepSize = m_asStep[nStepIndex];

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  000b7	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[eax*2]
  000bf	89 4d dc	 mov	 DWORD PTR _nStepSize$[ebp], ecx

; 1005 :             nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);

  000c2	8b 55 dc	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  000c5	52		 push	 edx
  000c6	8b 45 e4	 mov	 eax, DWORD PTR _nPredSample$[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d ec	 mov	 ecx, DWORD PTR _nEncSample$[ebp]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  000d3	89 45 e4	 mov	 DWORD PTR _nPredSample$[ebp], eax

; 1006 :             nStepIndex = NextStepIndex(nEncSample, nStepIndex);

  000d6	8b 55 fc	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  000d9	52		 push	 edx
  000da	8b 45 ec	 mov	 eax, DWORD PTR _nEncSample$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  000e3	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 1007 : 
; 1008 :             *(short *)pbDst = (short)nPredSample;

  000e6	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  000e9	66 8b 55 e4	 mov	 dx, WORD PTR _nPredSample$[ebp]
  000ed	66 89 11	 mov	 WORD PTR [ecx], dx

; 1009 :             pbDst += sizeof(short);

  000f0	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  000f3	83 c0 02	 add	 eax, 2
  000f6	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 1010 : 
; 1011 :             cSamples--;

  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  000fc	83 e9 01	 sub	 ecx, 1
  000ff	89 4d f8	 mov	 DWORD PTR _cSamples$[ebp], ecx

; 1012 : 
; 1013 :             //
; 1014 :             // Sample 2
; 1015 :             //
; 1016 : 
; 1017 :             if(cSamples)

  00102	83 7d f8 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  00106	74 5d		 je	 SHORT $L50921

; 1018 :             {
; 1019 :                 nEncSample = (bSample >> 4);

  00108	8b 55 eb	 mov	 edx, DWORD PTR _bSample$[ebp]
  0010b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00111	c1 fa 04	 sar	 edx, 4
  00114	89 55 ec	 mov	 DWORD PTR _nEncSample$[ebp], edx

; 1020 :                 nStepSize = m_asStep[nStepIndex];

  00117	8b 45 fc	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  0011a	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[eax*2]
  00122	89 4d dc	 mov	 DWORD PTR _nStepSize$[ebp], ecx

; 1021 :                 nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);

  00125	8b 55 dc	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  00128	52		 push	 edx
  00129	8b 45 e4	 mov	 eax, DWORD PTR _nPredSample$[ebp]
  0012c	50		 push	 eax
  0012d	8b 4d ec	 mov	 ecx, DWORD PTR _nEncSample$[ebp]
  00130	51		 push	 ecx
  00131	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  00136	89 45 e4	 mov	 DWORD PTR _nPredSample$[ebp], eax

; 1022 :                 nStepIndex = NextStepIndex(nEncSample, nStepIndex);

  00139	8b 55 fc	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  0013c	52		 push	 edx
  0013d	8b 45 ec	 mov	 eax, DWORD PTR _nEncSample$[ebp]
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  00146	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 1023 : 
; 1024 :                 *(short *)pbDst = (short)nPredSample;

  00149	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  0014c	66 8b 55 e4	 mov	 dx, WORD PTR _nPredSample$[ebp]
  00150	66 89 11	 mov	 WORD PTR [ecx], dx

; 1025 :                 pbDst += sizeof(short);

  00153	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  00156	83 c0 02	 add	 eax, 2
  00159	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 1026 : 
; 1027 :                 cSamples--;

  0015c	8b 4d f8	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  0015f	83 e9 01	 sub	 ecx, 1
  00162	89 4d f8	 mov	 DWORD PTR _cSamples$[ebp], ecx
$L50921:

; 1028 :             }
; 1029 :         }

  00165	e9 20 ff ff ff	 jmp	 $L50915
$L50916:

; 1030 : 
; 1031 :         //
; 1032 :         // Skip padding
; 1033 :         //
; 1034 : 
; 1035 :         pbSrc += nBlockAlignment;

  0016a	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0016d	03 55 14	 add	 edx, DWORD PTR _nBlockAlignment$[ebp]
  00170	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 1036 :     }

  00173	e9 95 fe ff ff	 jmp	 $L50898
$L50899:

; 1037 : 
; 1038 :     return fSuccess;

  00178	8b 45 e0	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 1039 : }

  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c2 1c 00	 ret	 28			; 0000001cH
?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::DecodeM16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.h
_TEXT	ENDS
;	COMDAT ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z
_TEXT	SEGMENT
_nStepIndex$ = 8
?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::ValidStepIndex, COMDAT

; 131  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 132  :         return (nStepIndex >= 0) && (nStepIndex < NUMELMS(m_asStep));

  00004	83 7d 08 00	 cmp	 DWORD PTR _nStepIndex$[ebp], 0
  00008	7c 0f		 jl	 SHORT $L51923
  0000a	83 7d 08 59	 cmp	 DWORD PTR _nStepIndex$[ebp], 89 ; 00000059H
  0000e	73 09		 jae	 SHORT $L51923
  00010	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR -4+[ebp], 1
  00017	eb 07		 jmp	 SHORT $L51924
$L51923:
  00019	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR -4+[ebp], 0
$L51924:
  00020	8b 45 fc	 mov	 eax, DWORD PTR -4+[ebp]

; 133  :     }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ENDP	; DirectSound::CImaAdpcmCodec::ValidStepIndex
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
_TEXT	ENDS
;	COMDAT ?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_fSuccess$ = -48
_pbBlock$ = -24
_cSamples$ = -16
_cSubSamples$ = -4
_nStepSize$ = -60
_dwHeader$ = -20
_dwLeft$ = -40
_dwRight$ = -32
_nEncSampleL$ = -56
_nPredSampleL$ = -44
_nStepIndexL$ = -28
_nEncSampleR$ = -12
_nPredSampleR$ = -8
_nStepIndexR$ = -52
_i$ = -36
?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::DecodeS16, COMDAT

; 1053 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 1054 :     BOOL                    fSuccess    = TRUE;

  00006	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 1
$L50950:

; 1055 :     LPBYTE                  pbBlock;
; 1056 :     UINT                    cSamples;
; 1057 :     UINT                    cSubSamples;
; 1058 :     int                     nStepSize;
; 1059 :     DWORD                   dwHeader;
; 1060 :     DWORD                   dwLeft;
; 1061 :     DWORD                   dwRight;
; 1062 :     int                     nEncSampleL;
; 1063 :     int                     nPredSampleL;
; 1064 :     int                     nStepIndexL;
; 1065 :     int                     nEncSampleR;
; 1066 :     int                     nPredSampleR;
; 1067 :     int                     nStepIndexR;
; 1068 :     UINT                    i;
; 1069 : 
; 1070 :     //
; 1071 :     // Enter the main loop
; 1072 :     //
; 1073 :     
; 1074 :     while(cBlocks--)

  0000d	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00013	83 e9 01	 sub	 ecx, 1
  00016	89 4d 10	 mov	 DWORD PTR _cBlocks$[ebp], ecx
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 0a 02 00
	00		 je	 $L50951

; 1075 :     {
; 1076 :         pbBlock = pbSrc;

  00021	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00024	89 55 e8	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 1077 :         cSamples = cSamplesPerBlock - 1;

  00027	8b 45 18	 mov	 eax, DWORD PTR _cSamplesPerBlock$[ebp]
  0002a	83 e8 01	 sub	 eax, 1
  0002d	89 45 f0	 mov	 DWORD PTR _cSamples$[ebp], eax

; 1078 : 
; 1079 :         //
; 1080 :         // LEFT channel header
; 1081 :         //
; 1082 : 
; 1083 :         dwHeader = *(LPDWORD)pbBlock;

  00030	8b 4d e8	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	89 55 ec	 mov	 DWORD PTR _dwHeader$[ebp], edx

; 1084 :         pbBlock += sizeof(DWORD);

  00038	8b 45 e8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 e8	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 1085 :         
; 1086 :         nPredSampleL = (int)(short)LOWORD(dwHeader);

  00041	8b 4d ec	 mov	 ecx, DWORD PTR _dwHeader$[ebp]
  00044	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0004a	0f bf d1	 movsx	 edx, cx
  0004d	89 55 d4	 mov	 DWORD PTR _nPredSampleL$[ebp], edx

; 1087 :         nStepIndexL = (int)(BYTE)HIWORD(dwHeader);

  00050	8b 45 ec	 mov	 eax, DWORD PTR _dwHeader$[ebp]
  00053	c1 e8 10	 shr	 eax, 16			; 00000010H
  00056	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005b	89 45 e4	 mov	 DWORD PTR _nStepIndexL$[ebp], eax

; 1088 : 
; 1089 :         if(!ValidStepIndex(nStepIndexL)) 

  0005e	8b 4d e4	 mov	 ecx, DWORD PTR _nStepIndexL$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
  00067	85 c0		 test	 eax, eax
  00069	75 0c		 jne	 SHORT $L50962

; 1090 :         {
; 1091 :             //
; 1092 :             // The step index is out of range - this is considered a fatal
; 1093 :             // error as the input stream is corrupted.  We fail by returning
; 1094 :             // zero bytes converted.
; 1095 :             //
; 1096 : 
; 1097 :             fSuccess = FALSE;

  0006b	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 1098 :             break;

  00072	e9 b4 01 00 00	 jmp	 $L50951
$L50962:

; 1099 :         }
; 1100 :         
; 1101 :         //
; 1102 :         // RIGHT channel header
; 1103 :         //
; 1104 : 
; 1105 :         dwHeader = *(LPDWORD)pbBlock;

  00077	8b 55 e8	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  0007a	8b 02		 mov	 eax, DWORD PTR [edx]
  0007c	89 45 ec	 mov	 DWORD PTR _dwHeader$[ebp], eax

; 1106 :         pbBlock += sizeof(DWORD);

  0007f	8b 4d e8	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00082	83 c1 04	 add	 ecx, 4
  00085	89 4d e8	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 1107 :         
; 1108 :         nPredSampleR = (int)(short)LOWORD(dwHeader);

  00088	8b 55 ec	 mov	 edx, DWORD PTR _dwHeader$[ebp]
  0008b	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00091	0f bf c2	 movsx	 eax, dx
  00094	89 45 f8	 mov	 DWORD PTR _nPredSampleR$[ebp], eax

; 1109 :         nStepIndexR = (int)(BYTE)HIWORD(dwHeader);

  00097	8b 4d ec	 mov	 ecx, DWORD PTR _dwHeader$[ebp]
  0009a	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0009d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000a3	89 4d cc	 mov	 DWORD PTR _nStepIndexR$[ebp], ecx

; 1110 : 
; 1111 :         if(!ValidStepIndex(nStepIndexR))

  000a6	8b 55 cc	 mov	 edx, DWORD PTR _nStepIndexR$[ebp]
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
  000af	85 c0		 test	 eax, eax
  000b1	75 0c		 jne	 SHORT $L50973

; 1112 :         {
; 1113 :             //
; 1114 :             // The step index is out of range - this is considered a fatal
; 1115 :             // error as the input stream is corrupted.  We fail by returning
; 1116 :             // zero bytes converted.
; 1117 :             //
; 1118 : 
; 1119 :             fSuccess = FALSE;

  000b3	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 1120 :             break;

  000ba	e9 6c 01 00 00	 jmp	 $L50951
$L50973:

; 1121 :         }
; 1122 : 
; 1123 :         //
; 1124 :         // Write out first sample
; 1125 :         //
; 1126 : 
; 1127 :         *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);

  000bf	8b 45 d4	 mov	 eax, DWORD PTR _nPredSampleL$[ebp]
  000c2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000c7	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _nPredSampleR$[ebp]
  000cf	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000d5	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000db	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000de	0b c1		 or	 eax, ecx
  000e0	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  000e3	89 02		 mov	 DWORD PTR [edx], eax

; 1128 :         pbDst += sizeof(DWORD);

  000e5	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  000e8	83 c0 04	 add	 eax, 4
  000eb	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax
$L50983:

; 1129 : 
; 1130 :         //
; 1131 :         // The first DWORD contains 4 left samples, the second DWORD
; 1132 :         // contains 4 right samples.  We process the source in 8-byte
; 1133 :         // chunks to make it easy to interleave the output correctly.
; 1134 :         //
; 1135 : 
; 1136 :         while(cSamples)

  000ee	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000f2	0f 84 25 01 00
	00		 je	 $L50984

; 1137 :         {
; 1138 :             dwLeft = *(LPDWORD)pbBlock;

  000f8	8b 4d e8	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  000fb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fd	89 55 d8	 mov	 DWORD PTR _dwLeft$[ebp], edx

; 1139 :             pbBlock += sizeof(DWORD);

  00100	8b 45 e8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  00103	83 c0 04	 add	 eax, 4
  00106	89 45 e8	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 1140 :             dwRight = *(LPDWORD)pbBlock;

  00109	8b 4d e8	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  0010c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010e	89 55 e0	 mov	 DWORD PTR _dwRight$[ebp], edx

; 1141 :             pbBlock += sizeof(DWORD);

  00111	8b 45 e8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  00114	83 c0 04	 add	 eax, 4
  00117	89 45 e8	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 1142 : 
; 1143 :             cSubSamples = min(cSamples, 8);

  0011a	83 7d f0 08	 cmp	 DWORD PTR _cSamples$[ebp], 8
  0011e	73 08		 jae	 SHORT $L51928
  00120	8b 4d f0	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  00123	89 4d c0	 mov	 DWORD PTR -64+[ebp], ecx
  00126	eb 07		 jmp	 SHORT $L51929
$L51928:
  00128	c7 45 c0 08 00
	00 00		 mov	 DWORD PTR -64+[ebp], 8
$L51929:
  0012f	8b 55 c0	 mov	 edx, DWORD PTR -64+[ebp]
  00132	89 55 fc	 mov	 DWORD PTR _cSubSamples$[ebp], edx

; 1144 :             
; 1145 :             for(i = 0; i < cSubSamples; i++)

  00135	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0013c	eb 09		 jmp	 SHORT $L50989
$L50990:
  0013e	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  00141	83 c0 01	 add	 eax, 1
  00144	89 45 dc	 mov	 DWORD PTR _i$[ebp], eax
$L50989:
  00147	8b 4d dc	 mov	 ecx, DWORD PTR _i$[ebp]
  0014a	3b 4d fc	 cmp	 ecx, DWORD PTR _cSubSamples$[ebp]
  0014d	0f 83 bc 00 00
	00		 jae	 $L50991

; 1146 :             {
; 1147 :                 //
; 1148 :                 // LEFT channel
; 1149 :                 //
; 1150 : 
; 1151 :                 nEncSampleL = (dwLeft & 0x0F);

  00153	8b 55 d8	 mov	 edx, DWORD PTR _dwLeft$[ebp]
  00156	83 e2 0f	 and	 edx, 15			; 0000000fH
  00159	89 55 c8	 mov	 DWORD PTR _nEncSampleL$[ebp], edx

; 1152 :                 nStepSize = m_asStep[nStepIndexL];

  0015c	8b 45 e4	 mov	 eax, DWORD PTR _nStepIndexL$[ebp]
  0015f	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[eax*2]
  00167	89 4d c4	 mov	 DWORD PTR _nStepSize$[ebp], ecx

; 1153 :                 nPredSampleL = DecodeSample(nEncSampleL, nPredSampleL, nStepSize);

  0016a	8b 55 c4	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  0016d	52		 push	 edx
  0016e	8b 45 d4	 mov	 eax, DWORD PTR _nPredSampleL$[ebp]
  00171	50		 push	 eax
  00172	8b 4d c8	 mov	 ecx, DWORD PTR _nEncSampleL$[ebp]
  00175	51		 push	 ecx
  00176	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  0017b	89 45 d4	 mov	 DWORD PTR _nPredSampleL$[ebp], eax

; 1154 :                 nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);

  0017e	8b 55 e4	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  00181	52		 push	 edx
  00182	8b 45 c8	 mov	 eax, DWORD PTR _nEncSampleL$[ebp]
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  0018b	89 45 e4	 mov	 DWORD PTR _nStepIndexL$[ebp], eax

; 1155 : 
; 1156 :                 //
; 1157 :                 // RIGHT channel
; 1158 :                 //
; 1159 : 
; 1160 :                 nEncSampleR = (dwRight & 0x0F);

  0018e	8b 4d e0	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  00191	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00194	89 4d f4	 mov	 DWORD PTR _nEncSampleR$[ebp], ecx

; 1161 :                 nStepSize = m_asStep[nStepIndexR];

  00197	8b 55 cc	 mov	 edx, DWORD PTR _nStepIndexR$[ebp]
  0019a	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  001a2	89 45 c4	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 1162 :                 nPredSampleR = DecodeSample(nEncSampleR, nPredSampleR, nStepSize);

  001a5	8b 4d c4	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  001a8	51		 push	 ecx
  001a9	8b 55 f8	 mov	 edx, DWORD PTR _nPredSampleR$[ebp]
  001ac	52		 push	 edx
  001ad	8b 45 f4	 mov	 eax, DWORD PTR _nEncSampleR$[ebp]
  001b0	50		 push	 eax
  001b1	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  001b6	89 45 f8	 mov	 DWORD PTR _nPredSampleR$[ebp], eax

; 1163 :                 nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);

  001b9	8b 4d cc	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  001bc	51		 push	 ecx
  001bd	8b 55 f4	 mov	 edx, DWORD PTR _nEncSampleR$[ebp]
  001c0	52		 push	 edx
  001c1	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  001c6	89 45 cc	 mov	 DWORD PTR _nStepIndexR$[ebp], eax

; 1164 : 
; 1165 :                 //
; 1166 :                 // Write out sample
; 1167 :                 //
; 1168 : 
; 1169 :                 *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);

  001c9	8b 45 d4	 mov	 eax, DWORD PTR _nPredSampleL$[ebp]
  001cc	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001d1	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001d6	8b 4d f8	 mov	 ecx, DWORD PTR _nPredSampleR$[ebp]
  001d9	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  001df	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  001e5	c1 e1 10	 shl	 ecx, 16			; 00000010H
  001e8	0b c1		 or	 eax, ecx
  001ea	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  001ed	89 02		 mov	 DWORD PTR [edx], eax

; 1170 :                 pbDst += sizeof(DWORD);

  001ef	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  001f2	83 c0 04	 add	 eax, 4
  001f5	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 1171 : 
; 1172 :                 //
; 1173 :                 // Shift the next input sample into the low-order 4 bits.
; 1174 :                 //
; 1175 : 
; 1176 :                 dwLeft >>= 4;

  001f8	8b 4d d8	 mov	 ecx, DWORD PTR _dwLeft$[ebp]
  001fb	c1 e9 04	 shr	 ecx, 4
  001fe	89 4d d8	 mov	 DWORD PTR _dwLeft$[ebp], ecx

; 1177 :                 dwRight >>= 4;

  00201	8b 55 e0	 mov	 edx, DWORD PTR _dwRight$[ebp]
  00204	c1 ea 04	 shr	 edx, 4
  00207	89 55 e0	 mov	 DWORD PTR _dwRight$[ebp], edx

; 1178 :             }

  0020a	e9 2f ff ff ff	 jmp	 $L50990
$L50991:

; 1179 : 
; 1180 :             cSamples -= cSubSamples;

  0020f	8b 45 f0	 mov	 eax, DWORD PTR _cSamples$[ebp]
  00212	2b 45 fc	 sub	 eax, DWORD PTR _cSubSamples$[ebp]
  00215	89 45 f0	 mov	 DWORD PTR _cSamples$[ebp], eax

; 1181 :         }

  00218	e9 d1 fe ff ff	 jmp	 $L50983
$L50984:

; 1182 : 
; 1183 :         //
; 1184 :         // Skip padding
; 1185 :         //
; 1186 : 
; 1187 :         pbSrc += nBlockAlignment;

  0021d	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  00220	03 4d 14	 add	 ecx, DWORD PTR _nBlockAlignment$[ebp]
  00223	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 1188 :     }

  00226	e9 e2 fd ff ff	 jmp	 $L50950
$L50951:

; 1189 : 
; 1190 :     return fSuccess;

  0022b	8b 45 d0	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 1191 : }

  0022e	8b e5		 mov	 esp, ebp
  00230	5d		 pop	 ebp
  00231	c2 1c 00	 ret	 28			; 0000001cH
?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::DecodeS16
_TEXT	ENDS
END
