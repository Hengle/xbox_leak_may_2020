; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	c:\xbox\private\windows\directx\dsound\tools\acm\imaadpcm.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextStepIndex@CImaAdpcmCodec@@CGHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidStepIndex@CImaAdpcmCodec@@CGHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CImaAdpcmCodec@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CImaAdpcmCodec@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Convert@CImaAdpcmCodec@@QAEHPBXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@CImaAdpcmCodec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEncodeAlignment@CImaAdpcmCodec@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDecodeAlignment@CImaAdpcmCodec@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalculateEncodeAlignment@CImaAdpcmCodec@@CGGGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreatePcmFormat@CImaAdpcmCodec@@SGXGKPAUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateImaAdpcmFormat@CImaAdpcmCodec@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidPcmFormat@CImaAdpcmCodec@@SGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidImaAdpcmFormat@CImaAdpcmCodec@@SGHPBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EncodeSample@CImaAdpcmCodec@@CGHHPAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecodeSample@CImaAdpcmCodec@@CGHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EncodeM16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EncodeS16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecodeM16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecodeS16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?m_asNextStep@CImaAdpcmCodec@@0QBFB		; CImaAdpcmCodec::m_asNextStep
PUBLIC	?m_asStep@CImaAdpcmCodec@@0QBFB			; CImaAdpcmCodec::m_asStep
_BSS	SEGMENT
?apfnConvert@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA DD 04H DUP (?) ; `CImaAdpcmCodec::Initialize'::`2'::apfnConvert
_BSS	ENDS
CONST	SEGMENT
?m_asNextStep@CImaAdpcmCodec@@0QBFB DW 0ffffH		; CImaAdpcmCodec::m_asNextStep
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	02H
	DW	04H
	DW	06H
	DW	08H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	02H
	DW	04H
	DW	06H
	DW	08H
?m_asStep@CImaAdpcmCodec@@0QBFB DW 07H			; CImaAdpcmCodec::m_asStep
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	010H
	DW	011H
	DW	013H
	DW	015H
	DW	017H
	DW	019H
	DW	01cH
	DW	01fH
	DW	022H
	DW	025H
	DW	029H
	DW	02dH
	DW	032H
	DW	037H
	DW	03cH
	DW	042H
	DW	049H
	DW	050H
	DW	058H
	DW	061H
	DW	06bH
	DW	076H
	DW	082H
	DW	08fH
	DW	09dH
	DW	0adH
	DW	0beH
	DW	0d1H
	DW	0e6H
	DW	0fdH
	DW	0117H
	DW	0133H
	DW	0151H
	DW	0173H
	DW	0198H
	DW	01c1H
	DW	01eeH
	DW	0220H
	DW	0256H
	DW	0292H
	DW	02d4H
	DW	031cH
	DW	036cH
	DW	03c3H
	DW	0424H
	DW	048eH
	DW	0502H
	DW	0583H
	DW	0610H
	DW	06abH
	DW	0756H
	DW	0812H
	DW	08e0H
	DW	09c3H
	DW	0abdH
	DW	0bd0H
	DW	0cffH
	DW	0e4cH
	DW	0fbaH
	DW	0114cH
	DW	01307H
	DW	014eeH
	DW	01706H
	DW	01954H
	DW	01bdcH
	DW	01ea5H
	DW	021b6H
	DW	02515H
	DW	028caH
	DW	02cdfH
	DW	0315bH
	DW	0364bH
	DW	03bb9H
	DW	041b2H
	DW	04844H
	DW	04f7eH
	DW	05771H
	DW	0602fH
	DW	069ceH
	DW	07462H
	DW	07fffH
CONST	ENDS
PUBLIC	??0CImaAdpcmCodec@@QAE@XZ			; CImaAdpcmCodec::CImaAdpcmCodec
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\acm\imaadpcm.cpp
;	COMDAT ??0CImaAdpcmCodec@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CImaAdpcmCodec@@QAE@XZ PROC NEAR			; CImaAdpcmCodec::CImaAdpcmCodec, COMDAT
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 70   : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0CImaAdpcmCodec@@QAE@XZ ENDP				; CImaAdpcmCodec::CImaAdpcmCodec
_TEXT	ENDS
PUBLIC	??1CImaAdpcmCodec@@QAE@XZ			; CImaAdpcmCodec::~CImaAdpcmCodec
; Function compile flags: /Odt
;	COMDAT ??1CImaAdpcmCodec@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CImaAdpcmCodec@@QAE@XZ PROC NEAR			; CImaAdpcmCodec::~CImaAdpcmCodec, COMDAT
; _this$ = ecx

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 93   : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1CImaAdpcmCodec@@QAE@XZ ENDP				; CImaAdpcmCodec::~CImaAdpcmCodec
_TEXT	ENDS
PUBLIC	?Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z ; CImaAdpcmCodec::Initialize
PUBLIC	?IsValidImaAdpcmFormat@CImaAdpcmCodec@@SGHPBUima_adpcmwaveformat_tag@@@Z ; CImaAdpcmCodec::IsValidImaAdpcmFormat
PUBLIC	?EncodeM16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z	; CImaAdpcmCodec::EncodeM16
PUBLIC	?EncodeS16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z	; CImaAdpcmCodec::EncodeS16
PUBLIC	?DecodeM16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z	; CImaAdpcmCodec::DecodeM16
PUBLIC	?DecodeS16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z	; CImaAdpcmCodec::DecodeS16
_BSS	SEGMENT
?$S3@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4EA DB 01H DUP (?) ; `CImaAdpcmCodec::Initialize'::`2'::$S3
; Function compile flags: /Odt
_BSS	ENDS
;	COMDAT ?Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z
_TEXT	SEGMENT
_pwfxEncode$ = 8
_fEncoder$ = 12
_this$ = -4
?Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z PROC NEAR ; CImaAdpcmCodec::Initialize, COMDAT
; _this$ = ecx

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  :     static const LPFNIMAADPCMCONVERT    apfnConvert[2][2] = 
; 120  :     { 
; 121  :         {
; 122  :             DecodeM16,

  00009	33 c0		 xor	 eax, eax
  0000b	a0 00 00 00 00	 mov	 al, BYTE PTR ?$S3@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4EA
  00010	83 e0 01	 and	 eax, 1
  00013	85 c0		 test	 eax, eax
  00015	75 67		 jne	 SHORT $L23236
  00017	33 c9		 xor	 ecx, ecx
  00019	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?$S3@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4EA
  0001f	83 c9 01	 or	 ecx, 1
  00022	88 0d 00 00 00
	00		 mov	 BYTE PTR ?$S3@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4EA, cl
  00028	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA, OFFSET FLAT:?DecodeM16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z ; CImaAdpcmCodec::DecodeM16
  00032	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA
  00038	89 15 00 00 00
	00		 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA, edx

; 123  :             DecodeS16 
; 124  :         },

  0003e	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+4, OFFSET FLAT:?DecodeS16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z ; CImaAdpcmCodec::DecodeS16
  00048	a1 04 00 00 00	 mov	 eax, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+4
  0004d	a3 04 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+4, eax

; 125  :         {
; 126  :             EncodeM16,

  00052	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+8, OFFSET FLAT:?EncodeM16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z ; CImaAdpcmCodec::EncodeM16
  0005c	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+8
  00062	89 0d 08 00 00
	00		 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+8, ecx

; 127  :             EncodeS16 
; 128  :         }

  00068	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+12, OFFSET FLAT:?EncodeS16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z ; CImaAdpcmCodec::EncodeS16
  00072	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+12
  00078	89 15 0c 00 00
	00		 mov	 DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA+12, edx
$L23236:

; 129  :     };
; 130  :     
; 131  :     if(!IsValidImaAdpcmFormat(pwfxEncode))

  0007e	8b 45 08	 mov	 eax, DWORD PTR _pwfxEncode$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?IsValidImaAdpcmFormat@CImaAdpcmCodec@@SGHPBUima_adpcmwaveformat_tag@@@Z ; CImaAdpcmCodec::IsValidImaAdpcmFormat
  00087	85 c0		 test	 eax, eax
  00089	75 04		 jne	 SHORT $L23237

; 132  :     {
; 133  :         return FALSE;

  0008b	33 c0		 xor	 eax, eax
  0008d	eb 58		 jmp	 SHORT $L23231
$L23237:

; 134  :     }
; 135  : 
; 136  :     //
; 137  :     // Save the format data
; 138  :     //
; 139  : 
; 140  :     m_wfxEncode = *pwfxEncode;

  0008f	8b 75 08	 mov	 esi, DWORD PTR _pwfxEncode$[ebp]
  00092	b9 05 00 00 00	 mov	 ecx, 5
  00097	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  0009a	f3 a5		 rep movsd

; 141  :     m_fEncoder = !!fEncoder;

  0009c	33 c9		 xor	 ecx, ecx
  0009e	83 7d 0c 00	 cmp	 DWORD PTR _fEncoder$[ebp], 0
  000a2	0f 95 c1	 setne	 cl
  000a5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a8	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 142  : 
; 143  :     //
; 144  :     // Set up the conversion function
; 145  :     //
; 146  : 
; 147  :     m_pfnConvert = apfnConvert[m_fEncoder][m_wfxEncode.wfx.nChannels - 1];

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b4	33 c0		 xor	 eax, eax
  000b6	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  000ba	8d 14 85 fc ff
	ff ff		 lea	 edx, DWORD PTR [eax*4-4]
  000c1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	8b 8c ca 00 00
	00 00		 mov	 ecx, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA[edx+ecx*8]
  000cb	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 148  : 
; 149  :     //
; 150  :     // Initialize the stepping indeces
; 151  :     //
; 152  : 
; 153  :     m_nStepIndexL = m_nStepIndexR = 0;

  000ce	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d1	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0
  000d8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000db	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 154  : 
; 155  :     return TRUE;

  000e2	b8 01 00 00 00	 mov	 eax, 1
$L23231:

; 156  : }

  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 08 00	 ret	 8
?Initialize@CImaAdpcmCodec@@QAEHPBUima_adpcmwaveformat_tag@@H@Z ENDP ; CImaAdpcmCodec::Initialize
_TEXT	ENDS
PUBLIC	?Convert@CImaAdpcmCodec@@QAEHPBXPAXI@Z		; CImaAdpcmCodec::Convert
; Function compile flags: /Odt
;	COMDAT ?Convert@CImaAdpcmCodec@@QAEHPBXPAXI@Z
_TEXT	SEGMENT
_pvSrc$ = 8
_pvDst$ = 12
_cBlocks$ = 16
_this$ = -4
?Convert@CImaAdpcmCodec@@QAEHPBXPAXI@Z PROC NEAR	; CImaAdpcmCodec::Convert, COMDAT
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  :     return m_pfnConvert((LPBYTE)pvSrc, (LPBYTE)pvDst, cBlocks, m_wfxEncode.wfx.nBlockAlign, m_wfxEncode.wSamplesPerBlock, &m_nStepIndexL, &m_nStepIndexR);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000d	50		 push	 eax
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 18	 add	 ecx, 24			; 00000018H
  00014	51		 push	 ecx
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	33 c0		 xor	 eax, eax
  0001a	66 8b 42 12	 mov	 ax, WORD PTR [edx+18]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	33 d2		 xor	 edx, edx
  00024	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  00028	52		 push	 edx
  00029	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _pvDst$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR _pvSrc$[ebp]
  00034	52		 push	 edx
  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	ff 50 20	 call	 DWORD PTR [eax+32]

; 185  : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
?Convert@CImaAdpcmCodec@@QAEHPBXPAXI@Z ENDP		; CImaAdpcmCodec::Convert
_TEXT	ENDS
PUBLIC	?Reset@CImaAdpcmCodec@@QAEXXZ			; CImaAdpcmCodec::Reset
; Function compile flags: /Odt
;	COMDAT ?Reset@CImaAdpcmCodec@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Reset@CImaAdpcmCodec@@QAEXXZ PROC NEAR			; CImaAdpcmCodec::Reset, COMDAT
; _this$ = ecx

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 209  :     //
; 210  :     // Reset the stepping indeces
; 211  :     //
; 212  : 
; 213  :     m_nStepIndexL = m_nStepIndexR = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 214  : }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?Reset@CImaAdpcmCodec@@QAEXXZ ENDP			; CImaAdpcmCodec::Reset
_TEXT	ENDS
PUBLIC	?GetEncodeAlignment@CImaAdpcmCodec@@QAEGXZ	; CImaAdpcmCodec::GetEncodeAlignment
; Function compile flags: /Odt
;	COMDAT ?GetEncodeAlignment@CImaAdpcmCodec@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4
?GetEncodeAlignment@CImaAdpcmCodec@@QAEGXZ PROC NEAR	; CImaAdpcmCodec::GetEncodeAlignment, COMDAT
; _this$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 238  :     return m_wfxEncode.wfx.nBlockAlign;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 40 0c	 mov	 ax, WORD PTR [eax+12]

; 239  : }

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?GetEncodeAlignment@CImaAdpcmCodec@@QAEGXZ ENDP		; CImaAdpcmCodec::GetEncodeAlignment
_TEXT	ENDS
PUBLIC	?GetDecodeAlignment@CImaAdpcmCodec@@QAEGXZ	; CImaAdpcmCodec::GetDecodeAlignment
; Function compile flags: /Odt
;	COMDAT ?GetDecodeAlignment@CImaAdpcmCodec@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4
?GetDecodeAlignment@CImaAdpcmCodec@@QAEGXZ PROC NEAR	; CImaAdpcmCodec::GetDecodeAlignment, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 263  :     return m_wfxEncode.wSamplesPerBlock * m_wfxEncode.wfx.nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 48 12	 mov	 cx, WORD PTR [eax+18]
  00010	8b c1		 mov	 eax, ecx
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	33 c9		 xor	 ecx, ecx
  00017	66 8b 4a 02	 mov	 cx, WORD PTR [edx+2]
  0001b	0f af c1	 imul	 eax, ecx
  0001e	c1 e0 04	 shl	 eax, 4
  00021	99		 cdq
  00022	83 e2 07	 and	 edx, 7
  00025	03 c2		 add	 eax, edx
  00027	c1 f8 03	 sar	 eax, 3

; 264  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?GetDecodeAlignment@CImaAdpcmCodec@@QAEGXZ ENDP		; CImaAdpcmCodec::GetDecodeAlignment
_TEXT	ENDS
PUBLIC	?CalculateEncodeAlignment@CImaAdpcmCodec@@CGGGG@Z ; CImaAdpcmCodec::CalculateEncodeAlignment
; Function compile flags: /Odt
;	COMDAT ?CalculateEncodeAlignment@CImaAdpcmCodec@@CGGGG@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerBlock$ = 12
_nEncodedSampleBits$ = -2
_nHeaderBytes$ = -4
_nBlockAlign$ = -6
?CalculateEncodeAlignment@CImaAdpcmCodec@@CGGGG@Z PROC NEAR ; CImaAdpcmCodec::CalculateEncodeAlignment, COMDAT

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 291  :     const WORD              nEncodedSampleBits  = nChannels * IMAADPCM_BITS_PER_SAMPLE;

  00006	8b 45 08	 mov	 eax, DWORD PTR _nChannels$[ebp]
  00009	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000e	c1 e0 02	 shl	 eax, 2
  00011	66 89 45 fe	 mov	 WORD PTR _nEncodedSampleBits$[ebp], ax

; 292  :     const WORD              nHeaderBytes        = nChannels * IMAADPCM_HEADER_LENGTH;

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _nChannels$[ebp]
  00018	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001e	c1 e1 02	 shl	 ecx, 2
  00021	66 89 4d fc	 mov	 WORD PTR _nHeaderBytes$[ebp], cx

; 293  :     WORD                    nBlockAlign;
; 294  : 
; 295  :     //
; 296  :     // Calculate the raw block alignment that nSamplesPerBlock dictates.  This
; 297  :     // value may include a partial encoded sample, so be sure to round up.
; 298  :     //
; 299  :     // Start with the samples-per-block, minus 1.  The first sample is actually
; 300  :     // stored in the header.
; 301  :     //
; 302  : 
; 303  :     nBlockAlign = nSamplesPerBlock - 1;

  00025	8b 55 0c	 mov	 edx, DWORD PTR _nSamplesPerBlock$[ebp]
  00028	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0002e	83 ea 01	 sub	 edx, 1
  00031	66 89 55 fa	 mov	 WORD PTR _nBlockAlign$[ebp], dx

; 304  : 
; 305  :     //
; 306  :     // Convert to encoded sample size
; 307  :     //
; 308  : 
; 309  :     nBlockAlign *= nEncodedSampleBits;

  00035	8b 45 fe	 mov	 eax, DWORD PTR _nEncodedSampleBits$[ebp]
  00038	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003d	8b 4d fa	 mov	 ecx, DWORD PTR _nBlockAlign$[ebp]
  00040	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00046	0f af c8	 imul	 ecx, eax
  00049	66 89 4d fa	 mov	 WORD PTR _nBlockAlign$[ebp], cx

; 310  :     nBlockAlign += 7;

  0004d	8b 55 fa	 mov	 edx, DWORD PTR _nBlockAlign$[ebp]
  00050	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00056	83 c2 07	 add	 edx, 7
  00059	66 89 55 fa	 mov	 WORD PTR _nBlockAlign$[ebp], dx

; 311  :     nBlockAlign /= 8;

  0005d	8b 45 fa	 mov	 eax, DWORD PTR _nBlockAlign$[ebp]
  00060	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00065	99		 cdq
  00066	83 e2 07	 and	 edx, 7
  00069	03 c2		 add	 eax, edx
  0006b	c1 f8 03	 sar	 eax, 3
  0006e	66 89 45 fa	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 312  : 
; 313  :     //
; 314  :     // The stereo encoder requires that there be at least two DWORDs to process
; 315  :     //
; 316  : 
; 317  :     nBlockAlign += 7;

  00072	8b 45 fa	 mov	 eax, DWORD PTR _nBlockAlign$[ebp]
  00075	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0007a	83 c0 07	 add	 eax, 7
  0007d	66 89 45 fa	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 318  :     nBlockAlign /= 8;

  00081	8b 45 fa	 mov	 eax, DWORD PTR _nBlockAlign$[ebp]
  00084	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00089	99		 cdq
  0008a	83 e2 07	 and	 edx, 7
  0008d	03 c2		 add	 eax, edx
  0008f	c1 f8 03	 sar	 eax, 3
  00092	66 89 45 fa	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 319  :     nBlockAlign *= 8;

  00096	8b 4d fa	 mov	 ecx, DWORD PTR _nBlockAlign$[ebp]
  00099	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0009f	c1 e1 03	 shl	 ecx, 3
  000a2	66 89 4d fa	 mov	 WORD PTR _nBlockAlign$[ebp], cx

; 320  : 
; 321  :     //
; 322  :     // Add the header
; 323  :     //
; 324  : 
; 325  :     nBlockAlign += nHeaderBytes;

  000a6	8b 55 fc	 mov	 edx, DWORD PTR _nHeaderBytes$[ebp]
  000a9	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000af	8b 45 fa	 mov	 eax, DWORD PTR _nBlockAlign$[ebp]
  000b2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000b7	03 c2		 add	 eax, edx
  000b9	66 89 45 fa	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 326  : 
; 327  :     return nBlockAlign;

  000bd	66 8b 45 fa	 mov	 ax, WORD PTR _nBlockAlign$[ebp]

; 328  : }

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 08 00	 ret	 8
?CalculateEncodeAlignment@CImaAdpcmCodec@@CGGGG@Z ENDP	; CImaAdpcmCodec::CalculateEncodeAlignment
_TEXT	ENDS
PUBLIC	?CreatePcmFormat@CImaAdpcmCodec@@SGXGKPAUtWAVEFORMATEX@@@Z ; CImaAdpcmCodec::CreatePcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreatePcmFormat@CImaAdpcmCodec@@SGXGKPAUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_pwfx$ = 16
?CreatePcmFormat@CImaAdpcmCodec@@SGXGKPAUtWAVEFORMATEX@@@Z PROC NEAR ; CImaAdpcmCodec::CreatePcmFormat, COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  :     pwfx->wFormatTag = WAVE_FORMAT_PCM;

  00003	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	66 c7 00 01 00	 mov	 WORD PTR [eax], 1

; 357  :     pwfx->nChannels = nChannels;

  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0000e	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  00012	66 89 51 02	 mov	 WORD PTR [ecx+2], dx

; 358  :     pwfx->nSamplesPerSec = nSamplesPerSec;

  00016	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0001c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 359  :     pwfx->nBlockAlign = nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _nChannels$[ebp]
  00022	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00027	c1 e0 04	 shl	 eax, 4
  0002a	99		 cdq
  0002b	83 e2 07	 and	 edx, 7
  0002e	03 c2		 add	 eax, edx
  00030	c1 f8 03	 sar	 eax, 3
  00033	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00036	66 89 42 0c	 mov	 WORD PTR [edx+12], ax

; 360  :     pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;

  0003a	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0003d	33 c9		 xor	 ecx, ecx
  0003f	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  00043	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00046	0f af 4a 04	 imul	 ecx, DWORD PTR [edx+4]
  0004a	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0004d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 361  :     pwfx->wBitsPerSample = IMAADPCM_PCM_BITS_PER_SAMPLE;

  00050	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00053	66 c7 41 0e 10
	00		 mov	 WORD PTR [ecx+14], 16	; 00000010H

; 362  : }

  00059	5d		 pop	 ebp
  0005a	c2 0c 00	 ret	 12			; 0000000cH
?CreatePcmFormat@CImaAdpcmCodec@@SGXGKPAUtWAVEFORMATEX@@@Z ENDP ; CImaAdpcmCodec::CreatePcmFormat
_TEXT	ENDS
PUBLIC	?CreateImaAdpcmFormat@CImaAdpcmCodec@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z ; CImaAdpcmCodec::CreateImaAdpcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreateImaAdpcmFormat@CImaAdpcmCodec@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_nSamplesPerBlock$ = 16
_pwfx$ = 20
?CreateImaAdpcmFormat@CImaAdpcmCodec@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z PROC NEAR ; CImaAdpcmCodec::CreateImaAdpcmFormat, COMDAT

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 391  :     pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  00004	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00007	66 c7 00 69 00	 mov	 WORD PTR [eax], 105	; 00000069H

; 392  :     pwfx->wfx.nChannels = nChannels;

  0000c	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0000f	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  00013	66 89 51 02	 mov	 WORD PTR [ecx+2], dx

; 393  :     pwfx->wfx.nSamplesPerSec = nSamplesPerSec;

  00017	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0001d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 394  :     pwfx->wfx.nBlockAlign = CalculateEncodeAlignment(nChannels, nSamplesPerBlock);

  00020	66 8b 55 10	 mov	 dx, WORD PTR _nSamplesPerBlock$[ebp]
  00024	52		 push	 edx
  00025	66 8b 45 08	 mov	 ax, WORD PTR _nChannels$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?CalculateEncodeAlignment@CImaAdpcmCodec@@CGGGG@Z ; CImaAdpcmCodec::CalculateEncodeAlignment
  0002f	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00032	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 395  :     pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec * pwfx->wfx.nBlockAlign / nSamplesPerBlock;

  00036	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00039	33 c0		 xor	 eax, eax
  0003b	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  00042	0f af c8	 imul	 ecx, eax
  00045	8b 75 10	 mov	 esi, DWORD PTR _nSamplesPerBlock$[ebp]
  00048	81 e6 ff ff 00
	00		 and	 esi, 65535		; 0000ffffH
  0004e	8b c1		 mov	 eax, ecx
  00050	33 d2		 xor	 edx, edx
  00052	f7 f6		 div	 esi
  00054	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00057	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 396  :     pwfx->wfx.wBitsPerSample = IMAADPCM_BITS_PER_SAMPLE;

  0005a	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0005d	66 c7 40 0e 04
	00		 mov	 WORD PTR [eax+14], 4

; 397  :     pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);

  00063	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00066	66 c7 41 10 02
	00		 mov	 WORD PTR [ecx+16], 2

; 398  :     pwfx->wSamplesPerBlock = nSamplesPerBlock;

  0006c	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0006f	66 8b 45 10	 mov	 ax, WORD PTR _nSamplesPerBlock$[ebp]
  00073	66 89 42 12	 mov	 WORD PTR [edx+18], ax

; 399  : }

  00077	5e		 pop	 esi
  00078	5d		 pop	 ebp
  00079	c2 10 00	 ret	 16			; 00000010H
?CreateImaAdpcmFormat@CImaAdpcmCodec@@SGXGKGPAUima_adpcmwaveformat_tag@@@Z ENDP ; CImaAdpcmCodec::CreateImaAdpcmFormat
_TEXT	ENDS
PUBLIC	?IsValidPcmFormat@CImaAdpcmCodec@@SGHPBUtWAVEFORMATEX@@@Z ; CImaAdpcmCodec::IsValidPcmFormat
; Function compile flags: /Odt
;	COMDAT ?IsValidPcmFormat@CImaAdpcmCodec@@SGHPBUtWAVEFORMATEX@@@Z
_TEXT	SEGMENT
_pwfx$ = 8
?IsValidPcmFormat@CImaAdpcmCodec@@SGHPBUtWAVEFORMATEX@@@Z PROC NEAR ; CImaAdpcmCodec::IsValidPcmFormat, COMDAT

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 423  :     if(WAVE_FORMAT_PCM != pwfx->wFormatTag)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000b	83 f9 01	 cmp	 ecx, 1
  0000e	74 07		 je	 SHORT $L23279

; 424  :     {
; 425  :         return FALSE;

  00010	33 c0		 xor	 eax, eax
  00012	e9 82 00 00 00	 jmp	 $L23278
$L23279:

; 426  :     }
; 427  :     
; 428  :     if((pwfx->nChannels < 1) || (pwfx->nChannels > IMAADPCM_MAX_CHANNELS))

  00017	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0001a	33 c0		 xor	 eax, eax
  0001c	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00020	83 f8 01	 cmp	 eax, 1
  00023	7c 0e		 jl	 SHORT $L23281
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00028	33 d2		 xor	 edx, edx
  0002a	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  0002e	83 fa 02	 cmp	 edx, 2
  00031	7e 04		 jle	 SHORT $L23280
$L23281:

; 429  :     {
; 430  :         return FALSE;

  00033	33 c0		 xor	 eax, eax
  00035	eb 62		 jmp	 SHORT $L23278
$L23280:

; 431  :     }
; 432  : 
; 433  :     if(IMAADPCM_PCM_BITS_PER_SAMPLE != pwfx->wBitsPerSample)

  00037	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0003a	33 c9		 xor	 ecx, ecx
  0003c	66 8b 48 0e	 mov	 cx, WORD PTR [eax+14]
  00040	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00043	74 04		 je	 SHORT $L23282

; 434  :     {
; 435  :         return FALSE;

  00045	33 c0		 xor	 eax, eax
  00047	eb 50		 jmp	 SHORT $L23278
$L23282:

; 436  :     }
; 437  : 
; 438  :     if(pwfx->nChannels * pwfx->wBitsPerSample / 8 != pwfx->nBlockAlign)

  00049	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0004c	33 c0		 xor	 eax, eax
  0004e	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00055	33 d2		 xor	 edx, edx
  00057	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  0005b	0f af c2	 imul	 eax, edx
  0005e	99		 cdq
  0005f	83 e2 07	 and	 edx, 7
  00062	03 c2		 add	 eax, edx
  00064	c1 f8 03	 sar	 eax, 3
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0006a	33 d2		 xor	 edx, edx
  0006c	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  00070	3b c2		 cmp	 eax, edx
  00072	74 04		 je	 SHORT $L23283

; 439  :     {
; 440  :         return FALSE;

  00074	33 c0		 xor	 eax, eax
  00076	eb 21		 jmp	 SHORT $L23278
$L23283:

; 441  :     }
; 442  : 
; 443  :     if(pwfx->nBlockAlign * pwfx->nSamplesPerSec != pwfx->nAvgBytesPerSec)

  00078	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0007b	33 c9		 xor	 ecx, ecx
  0007d	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  00081	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00084	0f af 4a 04	 imul	 ecx, DWORD PTR [edx+4]
  00088	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0008b	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0008e	74 04		 je	 SHORT $L23284

; 444  :     {
; 445  :         return FALSE;

  00090	33 c0		 xor	 eax, eax
  00092	eb 05		 jmp	 SHORT $L23278
$L23284:

; 446  :     }
; 447  : 
; 448  :     return TRUE;

  00094	b8 01 00 00 00	 mov	 eax, 1
$L23278:

; 449  : }

  00099	5d		 pop	 ebp
  0009a	c2 04 00	 ret	 4
?IsValidPcmFormat@CImaAdpcmCodec@@SGHPBUtWAVEFORMATEX@@@Z ENDP ; CImaAdpcmCodec::IsValidPcmFormat
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsValidImaAdpcmFormat@CImaAdpcmCodec@@SGHPBUima_adpcmwaveformat_tag@@@Z
_TEXT	SEGMENT
_pwfx$ = 8
?IsValidImaAdpcmFormat@CImaAdpcmCodec@@SGHPBUima_adpcmwaveformat_tag@@@Z PROC NEAR ; CImaAdpcmCodec::IsValidImaAdpcmFormat, COMDAT

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 473  :     if(WAVE_FORMAT_XBOX_ADPCM != pwfx->wfx.wFormatTag)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000b	83 f9 69	 cmp	 ecx, 105		; 00000069H
  0000e	74 04		 je	 SHORT $L23288

; 474  :     {
; 475  :         return FALSE;

  00010	33 c0		 xor	 eax, eax
  00012	eb 74		 jmp	 SHORT $L23287
$L23288:

; 476  :     }
; 477  : 
; 478  :     if(sizeof(*pwfx) - sizeof(pwfx->wfx) != pwfx->wfx.cbSize)

  00014	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00017	33 c0		 xor	 eax, eax
  00019	66 8b 42 10	 mov	 ax, WORD PTR [edx+16]
  0001d	83 f8 02	 cmp	 eax, 2
  00020	74 04		 je	 SHORT $L23289

; 479  :     {
; 480  :         return FALSE;

  00022	33 c0		 xor	 eax, eax
  00024	eb 62		 jmp	 SHORT $L23287
$L23289:

; 481  :     }
; 482  :     
; 483  :     if((pwfx->wfx.nChannels < 1) || (pwfx->wfx.nChannels > IMAADPCM_MAX_CHANNELS))

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00029	33 d2		 xor	 edx, edx
  0002b	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  0002f	83 fa 01	 cmp	 edx, 1
  00032	7c 0e		 jl	 SHORT $L23291
  00034	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00037	33 c9		 xor	 ecx, ecx
  00039	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0003d	83 f9 02	 cmp	 ecx, 2
  00040	7e 04		 jle	 SHORT $L23290
$L23291:

; 484  :     {
; 485  :         return FALSE;

  00042	33 c0		 xor	 eax, eax
  00044	eb 42		 jmp	 SHORT $L23287
$L23290:

; 486  :     }
; 487  : 
; 488  :     if(IMAADPCM_BITS_PER_SAMPLE != pwfx->wfx.wBitsPerSample)

  00046	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00049	33 c0		 xor	 eax, eax
  0004b	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  0004f	83 f8 04	 cmp	 eax, 4
  00052	74 04		 je	 SHORT $L23292

; 489  :     {
; 490  :         return FALSE;

  00054	33 c0		 xor	 eax, eax
  00056	eb 30		 jmp	 SHORT $L23287
$L23292:

; 491  :     }
; 492  : 
; 493  :     if(CalculateEncodeAlignment(pwfx->wfx.nChannels, pwfx->wSamplesPerBlock) != pwfx->wfx.nBlockAlign)

  00058	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0005b	66 8b 51 12	 mov	 dx, WORD PTR [ecx+18]
  0005f	52		 push	 edx
  00060	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00063	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?CalculateEncodeAlignment@CImaAdpcmCodec@@CGGGG@Z ; CImaAdpcmCodec::CalculateEncodeAlignment
  0006d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00072	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00075	33 c9		 xor	 ecx, ecx
  00077	66 8b 4a 0c	 mov	 cx, WORD PTR [edx+12]
  0007b	3b c1		 cmp	 eax, ecx
  0007d	74 04		 je	 SHORT $L23293

; 494  :     {
; 495  :         return FALSE;

  0007f	33 c0		 xor	 eax, eax
  00081	eb 05		 jmp	 SHORT $L23287
$L23293:

; 496  :     }
; 497  : 
; 498  :     return TRUE;

  00083	b8 01 00 00 00	 mov	 eax, 1
$L23287:

; 499  : }

  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
?IsValidImaAdpcmFormat@CImaAdpcmCodec@@SGHPBUima_adpcmwaveformat_tag@@@Z ENDP ; CImaAdpcmCodec::IsValidImaAdpcmFormat
_TEXT	ENDS
PUBLIC	?EncodeSample@CImaAdpcmCodec@@CGHHPAHH@Z	; CImaAdpcmCodec::EncodeSample
; Function compile flags: /Odt
;	COMDAT ?EncodeSample@CImaAdpcmCodec@@CGHHPAHH@Z
_TEXT	SEGMENT
_nInputSample$ = 8
_pnPredictedSample$ = 12
_nStepSize$ = 16
_nPredictedSample$ = -12
_lDifference$ = -8
_nEncodedSample$ = -4
?EncodeSample@CImaAdpcmCodec@@CGHHPAHH@Z PROC NEAR	; CImaAdpcmCodec::EncodeSample, COMDAT

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 527  :     int                 nPredictedSample;
; 528  :     LONG                lDifference;
; 529  :     int                 nEncodedSample;
; 530  :     
; 531  :     nPredictedSample = *pnPredictedSample;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _pnPredictedSample$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d f4	 mov	 DWORD PTR _nPredictedSample$[ebp], ecx

; 532  : 
; 533  :     lDifference = nInputSample - nPredictedSample;

  0000e	8b 55 08	 mov	 edx, DWORD PTR _nInputSample$[ebp]
  00011	2b 55 f4	 sub	 edx, DWORD PTR _nPredictedSample$[ebp]
  00014	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx

; 534  :     nEncodedSample = 0;

  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nEncodedSample$[ebp], 0

; 535  : 
; 536  :     if(lDifference < 0) 

  0001e	83 7d f8 00	 cmp	 DWORD PTR _lDifference$[ebp], 0
  00022	7d 0f		 jge	 SHORT $L23302

; 537  :     {
; 538  :         nEncodedSample = 8;

  00024	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR _nEncodedSample$[ebp], 8

; 539  :         lDifference = -lDifference;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _lDifference$[ebp]
  0002e	f7 d8		 neg	 eax
  00030	89 45 f8	 mov	 DWORD PTR _lDifference$[ebp], eax
$L23302:

; 540  :     }
; 541  : 
; 542  :     if(lDifference >= nStepSize)

  00033	8b 4d f8	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  00036	3b 4d 10	 cmp	 ecx, DWORD PTR _nStepSize$[ebp]
  00039	7c 12		 jl	 SHORT $L23303

; 543  :     {
; 544  :         nEncodedSample |= 4;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _nEncodedSample$[ebp]
  0003e	83 ca 04	 or	 edx, 4
  00041	89 55 fc	 mov	 DWORD PTR _nEncodedSample$[ebp], edx

; 545  :         lDifference -= nStepSize;

  00044	8b 45 f8	 mov	 eax, DWORD PTR _lDifference$[ebp]
  00047	2b 45 10	 sub	 eax, DWORD PTR _nStepSize$[ebp]
  0004a	89 45 f8	 mov	 DWORD PTR _lDifference$[ebp], eax
$L23303:

; 546  :     }
; 547  : 
; 548  :     nStepSize >>= 1;

  0004d	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00050	d1 f9		 sar	 ecx, 1
  00052	89 4d 10	 mov	 DWORD PTR _nStepSize$[ebp], ecx

; 549  : 
; 550  :     if(lDifference >= nStepSize)

  00055	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  00058	3b 55 10	 cmp	 edx, DWORD PTR _nStepSize$[ebp]
  0005b	7c 11		 jl	 SHORT $L23304

; 551  :     {
; 552  :         nEncodedSample |= 2;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00060	0c 02		 or	 al, 2
  00062	89 45 fc	 mov	 DWORD PTR _nEncodedSample$[ebp], eax

; 553  :         lDifference -= nStepSize;

  00065	8b 4d f8	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  00068	2b 4d 10	 sub	 ecx, DWORD PTR _nStepSize$[ebp]
  0006b	89 4d f8	 mov	 DWORD PTR _lDifference$[ebp], ecx
$L23304:

; 554  :     }
; 555  : 
; 556  :     nStepSize >>= 1;

  0006e	8b 55 10	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  00071	d1 fa		 sar	 edx, 1
  00073	89 55 10	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 557  : 
; 558  :     if(lDifference >= nStepSize)

  00076	8b 45 f8	 mov	 eax, DWORD PTR _lDifference$[ebp]
  00079	3b 45 10	 cmp	 eax, DWORD PTR _nStepSize$[ebp]
  0007c	7c 12		 jl	 SHORT $L23305

; 559  :     {
; 560  :         nEncodedSample |= 1;

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _nEncodedSample$[ebp]
  00081	83 c9 01	 or	 ecx, 1
  00084	89 4d fc	 mov	 DWORD PTR _nEncodedSample$[ebp], ecx

; 561  :         lDifference -= nStepSize;

  00087	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0008a	2b 55 10	 sub	 edx, DWORD PTR _nStepSize$[ebp]
  0008d	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L23305:

; 562  :     }
; 563  : 
; 564  :     if(nEncodedSample & 8)

  00090	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00093	83 e0 08	 and	 eax, 8
  00096	85 c0		 test	 eax, eax
  00098	74 12		 je	 SHORT $L23306

; 565  :     {
; 566  :         nPredictedSample = nInputSample + lDifference - (nStepSize >> 1);

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _nInputSample$[ebp]
  0009d	03 4d f8	 add	 ecx, DWORD PTR _lDifference$[ebp]
  000a0	8b 55 10	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  000a3	d1 fa		 sar	 edx, 1
  000a5	2b ca		 sub	 ecx, edx
  000a7	89 4d f4	 mov	 DWORD PTR _nPredictedSample$[ebp], ecx

; 567  :     }
; 568  :     else

  000aa	eb 10		 jmp	 SHORT $L23307
$L23306:

; 569  :     {
; 570  :         nPredictedSample = nInputSample - lDifference + (nStepSize >> 1);

  000ac	8b 45 08	 mov	 eax, DWORD PTR _nInputSample$[ebp]
  000af	2b 45 f8	 sub	 eax, DWORD PTR _lDifference$[ebp]
  000b2	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  000b5	d1 f9		 sar	 ecx, 1
  000b7	03 c1		 add	 eax, ecx
  000b9	89 45 f4	 mov	 DWORD PTR _nPredictedSample$[ebp], eax
$L23307:

; 571  :     }
; 572  : 
; 573  :     if(nPredictedSample > 32767)

  000bc	81 7d f4 ff 7f
	00 00		 cmp	 DWORD PTR _nPredictedSample$[ebp], 32767 ; 00007fffH
  000c3	7e 09		 jle	 SHORT $L23308

; 574  :     {
; 575  :         nPredictedSample = 32767;

  000c5	c7 45 f4 ff 7f
	00 00		 mov	 DWORD PTR _nPredictedSample$[ebp], 32767 ; 00007fffH

; 576  :     }
; 577  :     else if(nPredictedSample < -32768)

  000cc	eb 10		 jmp	 SHORT $L23309
$L23308:
  000ce	81 7d f4 00 80
	ff ff		 cmp	 DWORD PTR _nPredictedSample$[ebp], -32768 ; ffff8000H
  000d5	7d 07		 jge	 SHORT $L23310

; 578  :     {
; 579  :         nPredictedSample = -32768;

  000d7	c7 45 f4 00 80
	ff ff		 mov	 DWORD PTR _nPredictedSample$[ebp], -32768 ; ffff8000H
$L23310:
$L23309:

; 580  :     }
; 581  : 
; 582  :     *pnPredictedSample = nPredictedSample;

  000de	8b 55 0c	 mov	 edx, DWORD PTR _pnPredictedSample$[ebp]
  000e1	8b 45 f4	 mov	 eax, DWORD PTR _nPredictedSample$[ebp]
  000e4	89 02		 mov	 DWORD PTR [edx], eax

; 583  :     
; 584  :     return nEncodedSample;

  000e6	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]

; 585  : }

  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 0c 00	 ret	 12			; 0000000cH
?EncodeSample@CImaAdpcmCodec@@CGHHPAHH@Z ENDP		; CImaAdpcmCodec::EncodeSample
_TEXT	ENDS
PUBLIC	?DecodeSample@CImaAdpcmCodec@@CGHHHH@Z		; CImaAdpcmCodec::DecodeSample
; Function compile flags: /Odt
;	COMDAT ?DecodeSample@CImaAdpcmCodec@@CGHHHH@Z
_TEXT	SEGMENT
_nEncodedSample$ = 8
_nPredictedSample$ = 12
_nStepSize$ = 16
_lDifference$ = -8
_lNewSample$ = -4
?DecodeSample@CImaAdpcmCodec@@CGHHHH@Z PROC NEAR	; CImaAdpcmCodec::DecodeSample, COMDAT

; 612  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 613  :     LONG                lDifference;
; 614  :     LONG                lNewSample;
; 615  : 
; 616  :     lDifference = nStepSize >> 3;

  00006	8b 45 10	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  00009	c1 f8 03	 sar	 eax, 3
  0000c	89 45 f8	 mov	 DWORD PTR _lDifference$[ebp], eax

; 617  : 
; 618  :     if(nEncodedSample & 4) 

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _nEncodedSample$[ebp]
  00012	83 e1 04	 and	 ecx, 4
  00015	85 c9		 test	 ecx, ecx
  00017	74 09		 je	 SHORT $L23318

; 619  :     {
; 620  :         lDifference += nStepSize;

  00019	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0001c	03 55 10	 add	 edx, DWORD PTR _nStepSize$[ebp]
  0001f	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L23318:

; 621  :     }
; 622  : 
; 623  :     if(nEncodedSample & 2) 

  00022	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00025	83 e0 02	 and	 eax, 2
  00028	85 c0		 test	 eax, eax
  0002a	74 0d		 je	 SHORT $L23319

; 624  :     {
; 625  :         lDifference += nStepSize >> 1;

  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  0002f	d1 f9		 sar	 ecx, 1
  00031	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  00034	03 d1		 add	 edx, ecx
  00036	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L23319:

; 626  :     }
; 627  : 
; 628  :     if(nEncodedSample & 1) 

  00039	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  0003c	83 e0 01	 and	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	74 0e		 je	 SHORT $L23320

; 629  :     {
; 630  :         lDifference += nStepSize >> 2;

  00043	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00046	c1 f9 02	 sar	 ecx, 2
  00049	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0004c	03 d1		 add	 edx, ecx
  0004e	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L23320:

; 631  :     }
; 632  : 
; 633  :     if(nEncodedSample & 8)

  00051	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00054	83 e0 08	 and	 eax, 8
  00057	85 c0		 test	 eax, eax
  00059	74 08		 je	 SHORT $L23321

; 634  :     {
; 635  :         lDifference = -lDifference;

  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  0005e	f7 d9		 neg	 ecx
  00060	89 4d f8	 mov	 DWORD PTR _lDifference$[ebp], ecx
$L23321:

; 636  :     }
; 637  : 
; 638  :     lNewSample = nPredictedSample + lDifference;

  00063	8b 55 0c	 mov	 edx, DWORD PTR _nPredictedSample$[ebp]
  00066	03 55 f8	 add	 edx, DWORD PTR _lDifference$[ebp]
  00069	89 55 fc	 mov	 DWORD PTR _lNewSample$[ebp], edx

; 639  : 
; 640  :     if((LONG)(short)lNewSample != lNewSample)

  0006c	0f bf 45 fc	 movsx	 eax, WORD PTR _lNewSample$[ebp]
  00070	3b 45 fc	 cmp	 eax, DWORD PTR _lNewSample$[ebp]
  00073	74 19		 je	 SHORT $L23324

; 641  :     {
; 642  :         if(lNewSample < -32768)

  00075	81 7d fc 00 80
	ff ff		 cmp	 DWORD PTR _lNewSample$[ebp], -32768 ; ffff8000H
  0007c	7d 09		 jge	 SHORT $L23325

; 643  :         {
; 644  :             lNewSample = -32768;

  0007e	c7 45 fc 00 80
	ff ff		 mov	 DWORD PTR _lNewSample$[ebp], -32768 ; ffff8000H

; 645  :         }
; 646  :         else

  00085	eb 07		 jmp	 SHORT $L23326
$L23325:

; 647  :         {
; 648  :             lNewSample = 32767;

  00087	c7 45 fc ff 7f
	00 00		 mov	 DWORD PTR _lNewSample$[ebp], 32767 ; 00007fffH
$L23326:
$L23324:

; 649  :         }
; 650  :     }
; 651  : 
; 652  :     return (int)lNewSample;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _lNewSample$[ebp]

; 653  : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?DecodeSample@CImaAdpcmCodec@@CGHHHH@Z ENDP		; CImaAdpcmCodec::DecodeSample
_TEXT	ENDS
PUBLIC	?NextStepIndex@CImaAdpcmCodec@@CGHHH@Z		; CImaAdpcmCodec::NextStepIndex
; Function compile flags: /Odt
;	COMDAT ?EncodeM16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_pnStepIndexL$ = 28
_pbBlock$ = -20
_cSamples$ = -16
_nSample$ = -28
_nStepSize$ = -32
_nEncSample1$ = -8
_nEncSample2$ = -12
_nPredSample$ = -24
_nStepIndex$ = -4
?EncodeM16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z PROC NEAR	; CImaAdpcmCodec::EncodeM16, COMDAT

; 689  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 690  :     LPBYTE                  pbBlock;
; 691  :     UINT                    cSamples;
; 692  :     int                     nSample;
; 693  :     int                     nStepSize;
; 694  :     int                     nEncSample1;
; 695  :     int                     nEncSample2;
; 696  :     int                     nPredSample;
; 697  :     int                     nStepIndex;
; 698  : 
; 699  :     //
; 700  :     // Save a local copy of the step index so we're not constantly 
; 701  :     // dereferencing a pointer.
; 702  :     //
; 703  :     
; 704  :     nStepIndex = *pnStepIndexL;

  00006	8b 45 1c	 mov	 eax, DWORD PTR _pnStepIndexL$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d fc	 mov	 DWORD PTR _nStepIndex$[ebp], ecx
$L23346:

; 705  : 
; 706  :     //
; 707  :     // Enter the main loop
; 708  :     //
; 709  :     
; 710  :     while(cBlocks--)

  0000e	8b 55 10	 mov	 edx, DWORD PTR _cBlocks$[ebp]
  00011	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00014	83 e8 01	 sub	 eax, 1
  00017	89 45 10	 mov	 DWORD PTR _cBlocks$[ebp], eax
  0001a	85 d2		 test	 edx, edx
  0001c	0f 84 2f 01 00
	00		 je	 $L23347

; 711  :     {
; 712  :         pbBlock = pbDst;

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  00025	89 4d ec	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 713  :         cSamples = cSamplesPerBlock - 1;

  00028	8b 55 18	 mov	 edx, DWORD PTR _cSamplesPerBlock$[ebp]
  0002b	83 ea 01	 sub	 edx, 1
  0002e	89 55 f0	 mov	 DWORD PTR _cSamples$[ebp], edx

; 714  : 
; 715  :         //
; 716  :         // Block header
; 717  :         //
; 718  : 
; 719  :         nPredSample = *(short *)pbSrc;

  00031	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00034	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00037	89 4d e8	 mov	 DWORD PTR _nPredSample$[ebp], ecx

; 720  :         pbSrc += sizeof(short);

  0003a	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0003d	83 c2 02	 add	 edx, 2
  00040	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 721  : 
; 722  :         *(LONG *)pbBlock = MAKELONG(nPredSample, nStepIndex);

  00043	8b 45 e8	 mov	 eax, DWORD PTR _nPredSample$[ebp]
  00046	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  00053	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00059	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0005f	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00062	0b c1		 or	 eax, ecx
  00064	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00067	89 02		 mov	 DWORD PTR [edx], eax

; 723  :         pbBlock += sizeof(LONG);

  00069	8b 45 ec	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  0006c	83 c0 04	 add	 eax, 4
  0006f	89 45 ec	 mov	 DWORD PTR _pbBlock$[ebp], eax
$L23359:

; 724  : 
; 725  :         //
; 726  :         // We have written the header for this block--now write the data
; 727  :         // chunk (which consists of a bunch of encoded nibbles).  Note
; 728  :         // that if we don't have enough data to fill a complete byte, then
; 729  :         // we add a 0 nibble on the end.
; 730  :         //
; 731  : 
; 732  :         while(cSamples)

  00072	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  00076	0f 84 c7 00 00
	00		 je	 $L23360

; 733  :         {
; 734  :             //
; 735  :             // Sample 1
; 736  :             //
; 737  : 
; 738  :             nSample = *(short *)pbSrc;

  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  0007f	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00082	89 55 e4	 mov	 DWORD PTR _nSample$[ebp], edx

; 739  :             pbSrc += sizeof(short);

  00085	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00088	83 c0 02	 add	 eax, 2
  0008b	89 45 08	 mov	 DWORD PTR _pbSrc$[ebp], eax

; 740  :             cSamples--;

  0008e	8b 4d f0	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  00091	83 e9 01	 sub	 ecx, 1
  00094	89 4d f0	 mov	 DWORD PTR _cSamples$[ebp], ecx

; 741  : 
; 742  :             nStepSize = m_asStep[nStepIndex];

  00097	8b 55 fc	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  0009a	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@@0QBFB[edx*2]
  000a2	89 45 e0	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 743  :             nEncSample1 = EncodeSample(nSample, &nPredSample, nStepSize);

  000a5	8b 4d e0	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  000a8	51		 push	 ecx
  000a9	8d 55 e8	 lea	 edx, DWORD PTR _nPredSample$[ebp]
  000ac	52		 push	 edx
  000ad	8b 45 e4	 mov	 eax, DWORD PTR _nSample$[ebp]
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@@CGHHPAHH@Z ; CImaAdpcmCodec::EncodeSample
  000b6	89 45 f8	 mov	 DWORD PTR _nEncSample1$[ebp], eax

; 744  :             nStepIndex = NextStepIndex(nEncSample1, nStepIndex);

  000b9	8b 4d fc	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  000bc	51		 push	 ecx
  000bd	8b 55 f8	 mov	 edx, DWORD PTR _nEncSample1$[ebp]
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@@CGHHH@Z ; CImaAdpcmCodec::NextStepIndex
  000c6	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 745  : 
; 746  :             //
; 747  :             // Sample 2
; 748  :             //
; 749  : 
; 750  :             if(cSamples)

  000c9	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000cd	74 4f		 je	 SHORT $L23363

; 751  :             {
; 752  :                 nSample = *(short *)pbSrc;

  000cf	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  000d2	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000d5	89 4d e4	 mov	 DWORD PTR _nSample$[ebp], ecx

; 753  :                 pbSrc += sizeof(short);

  000d8	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  000db	83 c2 02	 add	 edx, 2
  000de	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 754  :                 cSamples--;

  000e1	8b 45 f0	 mov	 eax, DWORD PTR _cSamples$[ebp]
  000e4	83 e8 01	 sub	 eax, 1
  000e7	89 45 f0	 mov	 DWORD PTR _cSamples$[ebp], eax

; 755  : 
; 756  :                 nStepSize = m_asStep[nStepIndex];

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  000ed	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?m_asStep@CImaAdpcmCodec@@0QBFB[ecx*2]
  000f5	89 55 e0	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 757  :                 nEncSample2 = EncodeSample(nSample, &nPredSample, nStepSize);

  000f8	8b 45 e0	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  000fb	50		 push	 eax
  000fc	8d 4d e8	 lea	 ecx, DWORD PTR _nPredSample$[ebp]
  000ff	51		 push	 ecx
  00100	8b 55 e4	 mov	 edx, DWORD PTR _nSample$[ebp]
  00103	52		 push	 edx
  00104	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@@CGHHPAHH@Z ; CImaAdpcmCodec::EncodeSample
  00109	89 45 f4	 mov	 DWORD PTR _nEncSample2$[ebp], eax

; 758  :                 nStepIndex = NextStepIndex(nEncSample2, nStepIndex);

  0010c	8b 45 fc	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  0010f	50		 push	 eax
  00110	8b 4d f4	 mov	 ecx, DWORD PTR _nEncSample2$[ebp]
  00113	51		 push	 ecx
  00114	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@@CGHHH@Z ; CImaAdpcmCodec::NextStepIndex
  00119	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 759  :             }
; 760  :             else

  0011c	eb 07		 jmp	 SHORT $L23366
$L23363:

; 761  :             {
; 762  :                 nEncSample2 = 0;

  0011e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nEncSample2$[ebp], 0
$L23366:

; 763  :             }
; 764  : 
; 765  :             //
; 766  :             // Write out encoded byte.
; 767  :             //
; 768  : 
; 769  :             *pbBlock++ = (BYTE)(nEncSample1 | (nEncSample2 << 4));

  00125	8b 55 f4	 mov	 edx, DWORD PTR _nEncSample2$[ebp]
  00128	c1 e2 04	 shl	 edx, 4
  0012b	8b 45 f8	 mov	 eax, DWORD PTR _nEncSample1$[ebp]
  0012e	0b c2		 or	 eax, edx
  00130	8b 4d ec	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00133	88 01		 mov	 BYTE PTR [ecx], al
  00135	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00138	83 c2 01	 add	 edx, 1
  0013b	89 55 ec	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 770  :         }

  0013e	e9 2f ff ff ff	 jmp	 $L23359
$L23360:

; 771  : 
; 772  :         //
; 773  :         // Skip padding
; 774  :         //
; 775  : 
; 776  :         pbDst += nBlockAlignment;

  00143	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  00146	03 45 14	 add	 eax, DWORD PTR _nBlockAlignment$[ebp]
  00149	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 777  :     }

  0014c	e9 bd fe ff ff	 jmp	 $L23346
$L23347:

; 778  : 
; 779  :     //
; 780  :     // Restore the value of the step index to be used on the next buffer.
; 781  :     //
; 782  : 
; 783  :     *pnStepIndexL = nStepIndex;

  00151	8b 4d 1c	 mov	 ecx, DWORD PTR _pnStepIndexL$[ebp]
  00154	8b 55 fc	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  00157	89 11		 mov	 DWORD PTR [ecx], edx

; 784  : 
; 785  :     return TRUE;

  00159	b8 01 00 00 00	 mov	 eax, 1

; 786  : }

  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 1c 00	 ret	 28			; 0000001cH
?EncodeM16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z ENDP	; CImaAdpcmCodec::EncodeM16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\acm\imaadpcm.h
_TEXT	ENDS
;	COMDAT ?NextStepIndex@CImaAdpcmCodec@@CGHHH@Z
_TEXT	SEGMENT
_nEncodedSample$ = 8
_nStepIndex$ = 12
?NextStepIndex@CImaAdpcmCodec@@CGHHH@Z PROC NEAR	; CImaAdpcmCodec::NextStepIndex, COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 116  :     nStepIndex += m_asNextStep[nEncodedSample];

  00003	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00006	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_asNextStep@CImaAdpcmCodec@@0QBFB[eax*2]
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  00011	03 d1		 add	 edx, ecx
  00013	89 55 0c	 mov	 DWORD PTR _nStepIndex$[ebp], edx

; 117  : 
; 118  :     if(nStepIndex < 0)

  00016	83 7d 0c 00	 cmp	 DWORD PTR _nStepIndex$[ebp], 0
  0001a	7d 09		 jge	 SHORT $L23213

; 119  :     {
; 120  :         nStepIndex = 0;

  0001c	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _nStepIndex$[ebp], 0

; 121  :     }
; 122  :     else if(nStepIndex >= NUMELMS(m_asStep))

  00023	eb 0d		 jmp	 SHORT $L23214
$L23213:
  00025	83 7d 0c 59	 cmp	 DWORD PTR _nStepIndex$[ebp], 89 ; 00000059H
  00029	72 07		 jb	 SHORT $L23215

; 123  :     {
; 124  :         nStepIndex = NUMELMS(m_asStep) - 1;

  0002b	c7 45 0c 58 00
	00 00		 mov	 DWORD PTR _nStepIndex$[ebp], 88 ; 00000058H
$L23215:
$L23214:

; 125  :     }
; 126  : 
; 127  :     return nStepIndex;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _nStepIndex$[ebp]

; 128  : }

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?NextStepIndex@CImaAdpcmCodec@@CGHHH@Z ENDP		; CImaAdpcmCodec::NextStepIndex
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\acm\imaadpcm.cpp
_TEXT	ENDS
;	COMDAT ?EncodeS16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_pnStepIndexL$ = 28
_pnStepIndexR$ = 32
_pbBlock$ = -20
_cSamples$ = -16
_cSubSamples$ = -4
_nSample$ = -52
_nStepSize$ = -56
_dwLeft$ = -36
_dwRight$ = -28
_nEncSampleL$ = -48
_nPredSampleL$ = -40
_nStepIndexL$ = -24
_nEncSampleR$ = -12
_nPredSampleR$ = -8
_nStepIndexR$ = -44
_i$ = -32
?EncodeS16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z PROC NEAR	; CImaAdpcmCodec::EncodeS16, COMDAT

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 801  :     LPBYTE                  pbBlock;
; 802  :     UINT                    cSamples;
; 803  :     UINT                    cSubSamples;
; 804  :     int                     nSample;
; 805  :     int                     nStepSize;
; 806  :     DWORD                   dwLeft;
; 807  :     DWORD                   dwRight;
; 808  :     int                     nEncSampleL;
; 809  :     int                     nPredSampleL;
; 810  :     int                     nStepIndexL;
; 811  :     int                     nEncSampleR;
; 812  :     int                     nPredSampleR;
; 813  :     int                     nStepIndexR;
; 814  :     UINT                    i;
; 815  : 
; 816  :     //
; 817  :     // Save a local copy of the step indeces so we're not constantly 
; 818  :     // dereferencing a pointer.
; 819  :     //
; 820  :     
; 821  :     nStepIndexL = *pnStepIndexL;

  00006	8b 45 1c	 mov	 eax, DWORD PTR _pnStepIndexL$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d e8	 mov	 DWORD PTR _nStepIndexL$[ebp], ecx

; 822  :     nStepIndexR = *pnStepIndexR;

  0000e	8b 55 20	 mov	 edx, DWORD PTR _pnStepIndexR$[ebp]
  00011	8b 02		 mov	 eax, DWORD PTR [edx]
  00013	89 45 d4	 mov	 DWORD PTR _nStepIndexR$[ebp], eax
$L23392:

; 823  : 
; 824  :     //
; 825  :     // Enter the main loop
; 826  :     //
; 827  :     
; 828  :     while(cBlocks--)

  00016	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00019	8b 55 10	 mov	 edx, DWORD PTR _cBlocks$[ebp]
  0001c	83 ea 01	 sub	 edx, 1
  0001f	89 55 10	 mov	 DWORD PTR _cBlocks$[ebp], edx
  00022	85 c9		 test	 ecx, ecx
  00024	0f 84 d3 01 00
	00		 je	 $L23393

; 829  :     {
; 830  :         pbBlock = pbDst;

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  0002d	89 45 ec	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 831  :         cSamples = cSamplesPerBlock - 1;

  00030	8b 4d 18	 mov	 ecx, DWORD PTR _cSamplesPerBlock$[ebp]
  00033	83 e9 01	 sub	 ecx, 1
  00036	89 4d f0	 mov	 DWORD PTR _cSamples$[ebp], ecx

; 832  : 
; 833  :         //
; 834  :         // LEFT channel block header
; 835  :         //
; 836  : 
; 837  :         nPredSampleL = *(short *)pbSrc;

  00039	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0003c	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0003f	89 45 d8	 mov	 DWORD PTR _nPredSampleL$[ebp], eax

; 838  :         pbSrc += sizeof(short);

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  00045	83 c1 02	 add	 ecx, 2
  00048	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 839  : 
; 840  :         *(LONG *)pbBlock = MAKELONG(nPredSampleL, nStepIndexL);

  0004b	8b 55 d8	 mov	 edx, DWORD PTR _nPredSampleL$[ebp]
  0004e	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00054	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0005a	8b 45 e8	 mov	 eax, DWORD PTR _nStepIndexL$[ebp]
  0005d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00062	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00067	c1 e0 10	 shl	 eax, 16			; 00000010H
  0006a	0b d0		 or	 edx, eax
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  0006f	89 11		 mov	 DWORD PTR [ecx], edx

; 841  :         pbBlock += sizeof(LONG);

  00071	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00074	83 c2 04	 add	 edx, 4
  00077	89 55 ec	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 842  : 
; 843  :         //
; 844  :         // RIGHT channel block header
; 845  :         //
; 846  : 
; 847  :         nPredSampleR = *(short *)pbSrc;

  0007a	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  0007d	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00080	89 4d f8	 mov	 DWORD PTR _nPredSampleR$[ebp], ecx

; 848  :         pbSrc += sizeof(short);

  00083	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00086	83 c2 02	 add	 edx, 2
  00089	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 849  : 
; 850  :         *(LONG *)pbBlock = MAKELONG(nPredSampleR, nStepIndexR);

  0008c	8b 45 f8	 mov	 eax, DWORD PTR _nPredSampleR$[ebp]
  0008f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00094	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00099	8b 4d d4	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  0009c	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000a2	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000a8	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000ab	0b c1		 or	 eax, ecx
  000ad	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  000b0	89 02		 mov	 DWORD PTR [edx], eax

; 851  :         pbBlock += sizeof(LONG);

  000b2	8b 45 ec	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  000b5	83 c0 04	 add	 eax, 4
  000b8	89 45 ec	 mov	 DWORD PTR _pbBlock$[ebp], eax
$L23415:

; 852  : 
; 853  :         //
; 854  :         // We have written the header for this block--now write the data
; 855  :         // chunk.  This consists of 8 left samples (one DWORD of output)
; 856  :         // followed by 8 right samples (also one DWORD).  Since the input
; 857  :         // samples are interleaved, we create the left and right DWORDs
; 858  :         // sample by sample, and then write them both out.
; 859  :         //
; 860  : 
; 861  :         while(cSamples)

  000bb	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000bf	0f 84 2a 01 00
	00		 je	 $L23416

; 862  :         {
; 863  :             dwLeft = 0;

  000c5	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _dwLeft$[ebp], 0

; 864  :             dwRight = 0;

  000cc	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _dwRight$[ebp], 0

; 865  : 
; 866  :             cSubSamples = min(cSamples, 8);

  000d3	83 7d f0 08	 cmp	 DWORD PTR _cSamples$[ebp], 8
  000d7	73 08		 jae	 SHORT $L23625
  000d9	8b 4d f0	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  000dc	89 4d c4	 mov	 DWORD PTR -60+[ebp], ecx
  000df	eb 07		 jmp	 SHORT $L23626
$L23625:
  000e1	c7 45 c4 08 00
	00 00		 mov	 DWORD PTR -60+[ebp], 8
$L23626:
  000e8	8b 55 c4	 mov	 edx, DWORD PTR -60+[ebp]
  000eb	89 55 fc	 mov	 DWORD PTR _cSubSamples$[ebp], edx

; 867  : 
; 868  :             for(i = 0; i < cSubSamples; i++)

  000ee	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000f5	eb 09		 jmp	 SHORT $L23417
$L23418:
  000f7	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  000fa	83 c0 01	 add	 eax, 1
  000fd	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$L23417:
  00100	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  00103	3b 4d fc	 cmp	 ecx, DWORD PTR _cSubSamples$[ebp]
  00106	0f 83 b3 00 00
	00		 jae	 $L23419

; 869  :             {
; 870  :                 //
; 871  :                 // LEFT channel
; 872  :                 //
; 873  : 
; 874  :                 nSample = *(short *)pbSrc;

  0010c	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0010f	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00112	89 45 cc	 mov	 DWORD PTR _nSample$[ebp], eax

; 875  :                 pbSrc += sizeof(short);

  00115	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  00118	83 c1 02	 add	 ecx, 2
  0011b	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 876  : 
; 877  :                 nStepSize = m_asStep[nStepIndexL];

  0011e	8b 55 e8	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  00121	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@@0QBFB[edx*2]
  00129	89 45 c8	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 878  :                 
; 879  :                 nEncSampleL = EncodeSample(nSample, &nPredSampleL, nStepSize);

  0012c	8b 4d c8	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  0012f	51		 push	 ecx
  00130	8d 55 d8	 lea	 edx, DWORD PTR _nPredSampleL$[ebp]
  00133	52		 push	 edx
  00134	8b 45 cc	 mov	 eax, DWORD PTR _nSample$[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@@CGHHPAHH@Z ; CImaAdpcmCodec::EncodeSample
  0013d	89 45 d0	 mov	 DWORD PTR _nEncSampleL$[ebp], eax

; 880  : 
; 881  :                 nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);

  00140	8b 4d e8	 mov	 ecx, DWORD PTR _nStepIndexL$[ebp]
  00143	51		 push	 ecx
  00144	8b 55 d0	 mov	 edx, DWORD PTR _nEncSampleL$[ebp]
  00147	52		 push	 edx
  00148	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@@CGHHH@Z ; CImaAdpcmCodec::NextStepIndex
  0014d	89 45 e8	 mov	 DWORD PTR _nStepIndexL$[ebp], eax

; 882  :                 dwLeft |= (DWORD)nEncSampleL << (4 * i);

  00150	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  00153	c1 e1 02	 shl	 ecx, 2
  00156	8b 45 d0	 mov	 eax, DWORD PTR _nEncSampleL$[ebp]
  00159	d3 e0		 shl	 eax, cl
  0015b	8b 4d dc	 mov	 ecx, DWORD PTR _dwLeft$[ebp]
  0015e	0b c8		 or	 ecx, eax
  00160	89 4d dc	 mov	 DWORD PTR _dwLeft$[ebp], ecx

; 883  : 
; 884  :                 //
; 885  :                 // RIGHT channel
; 886  :                 //
; 887  : 
; 888  :                 nSample = *(short *)pbSrc;

  00163	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00166	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00169	89 45 cc	 mov	 DWORD PTR _nSample$[ebp], eax

; 889  :                 pbSrc += sizeof(short);

  0016c	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  0016f	83 c1 02	 add	 ecx, 2
  00172	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 890  : 
; 891  :                 nStepSize = m_asStep[nStepIndexR];

  00175	8b 55 d4	 mov	 edx, DWORD PTR _nStepIndexR$[ebp]
  00178	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@@0QBFB[edx*2]
  00180	89 45 c8	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 892  :                 
; 893  :                 nEncSampleR = EncodeSample(nSample, &nPredSampleR, nStepSize);

  00183	8b 4d c8	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00186	51		 push	 ecx
  00187	8d 55 f8	 lea	 edx, DWORD PTR _nPredSampleR$[ebp]
  0018a	52		 push	 edx
  0018b	8b 45 cc	 mov	 eax, DWORD PTR _nSample$[ebp]
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@@CGHHPAHH@Z ; CImaAdpcmCodec::EncodeSample
  00194	89 45 f4	 mov	 DWORD PTR _nEncSampleR$[ebp], eax

; 894  : 
; 895  :                 nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);

  00197	8b 4d d4	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  0019a	51		 push	 ecx
  0019b	8b 55 f4	 mov	 edx, DWORD PTR _nEncSampleR$[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@@CGHHH@Z ; CImaAdpcmCodec::NextStepIndex
  001a4	89 45 d4	 mov	 DWORD PTR _nStepIndexR$[ebp], eax

; 896  :                 dwRight |= (DWORD)nEncSampleR << (4 * i);

  001a7	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  001aa	c1 e1 02	 shl	 ecx, 2
  001ad	8b 45 f4	 mov	 eax, DWORD PTR _nEncSampleR$[ebp]
  001b0	d3 e0		 shl	 eax, cl
  001b2	8b 4d e4	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  001b5	0b c8		 or	 ecx, eax
  001b7	89 4d e4	 mov	 DWORD PTR _dwRight$[ebp], ecx

; 897  :             }

  001ba	e9 38 ff ff ff	 jmp	 $L23418
$L23419:

; 898  : 
; 899  :             //
; 900  :             // Write out encoded DWORDs.
; 901  :             //
; 902  : 
; 903  :             *(LPDWORD)pbBlock = dwLeft;

  001bf	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  001c2	8b 45 dc	 mov	 eax, DWORD PTR _dwLeft$[ebp]
  001c5	89 02		 mov	 DWORD PTR [edx], eax

; 904  :             pbBlock += sizeof(DWORD);

  001c7	8b 4d ec	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  001ca	83 c1 04	 add	 ecx, 4
  001cd	89 4d ec	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 905  : 
; 906  :             *(LPDWORD)pbBlock = dwRight;

  001d0	8b 55 ec	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  001d3	8b 45 e4	 mov	 eax, DWORD PTR _dwRight$[ebp]
  001d6	89 02		 mov	 DWORD PTR [edx], eax

; 907  :             pbBlock += sizeof(DWORD);

  001d8	8b 4d ec	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  001db	83 c1 04	 add	 ecx, 4
  001de	89 4d ec	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 908  : 
; 909  :             cSamples -= cSubSamples;

  001e1	8b 55 f0	 mov	 edx, DWORD PTR _cSamples$[ebp]
  001e4	2b 55 fc	 sub	 edx, DWORD PTR _cSubSamples$[ebp]
  001e7	89 55 f0	 mov	 DWORD PTR _cSamples$[ebp], edx

; 910  :         }

  001ea	e9 cc fe ff ff	 jmp	 $L23415
$L23416:

; 911  : 
; 912  :         //
; 913  :         // Skip padding
; 914  :         //
; 915  : 
; 916  :         pbDst += nBlockAlignment;

  001ef	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  001f2	03 45 14	 add	 eax, DWORD PTR _nBlockAlignment$[ebp]
  001f5	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 917  :     }

  001f8	e9 19 fe ff ff	 jmp	 $L23392
$L23393:

; 918  : 
; 919  :     //
; 920  :     // Restore the value of the step index to be used on the next buffer.
; 921  :     //
; 922  :     
; 923  :     *pnStepIndexL = nStepIndexL;

  001fd	8b 4d 1c	 mov	 ecx, DWORD PTR _pnStepIndexL$[ebp]
  00200	8b 55 e8	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  00203	89 11		 mov	 DWORD PTR [ecx], edx

; 924  :     *pnStepIndexR = nStepIndexR;

  00205	8b 45 20	 mov	 eax, DWORD PTR _pnStepIndexR$[ebp]
  00208	8b 4d d4	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  0020b	89 08		 mov	 DWORD PTR [eax], ecx

; 925  : 
; 926  :     return TRUE;

  0020d	b8 01 00 00 00	 mov	 eax, 1

; 927  : 
; 928  : }

  00212	8b e5		 mov	 esp, ebp
  00214	5d		 pop	 ebp
  00215	c2 1c 00	 ret	 28			; 0000001cH
?EncodeS16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z ENDP	; CImaAdpcmCodec::EncodeS16
_TEXT	ENDS
PUBLIC	?ValidStepIndex@CImaAdpcmCodec@@CGHH@Z		; CImaAdpcmCodec::ValidStepIndex
; Function compile flags: /Odt
;	COMDAT ?DecodeM16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_fSuccess$ = -32
_pbBlock$ = -16
_cSamples$ = -8
_bSample$ = -21
_nStepSize$ = -36
_nEncSample$ = -20
_nPredSample$ = -28
_nStepIndex$ = -4
_dwHeader$ = -12
?DecodeM16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z PROC NEAR	; CImaAdpcmCodec::DecodeM16, COMDAT

; 942  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 943  :     BOOL                    fSuccess    = TRUE;

  00006	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 1
$L23449:

; 944  :     LPBYTE                  pbBlock;
; 945  :     UINT                    cSamples;
; 946  :     BYTE                    bSample;
; 947  :     int                     nStepSize;
; 948  :     int                     nEncSample;
; 949  :     int                     nPredSample;
; 950  :     int                     nStepIndex;
; 951  :     DWORD                   dwHeader;
; 952  : 
; 953  :     //
; 954  :     // Enter the main loop
; 955  :     //
; 956  :     
; 957  :     while(cBlocks--)

  0000d	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00013	83 e9 01	 sub	 ecx, 1
  00016	89 4d 10	 mov	 DWORD PTR _cBlocks$[ebp], ecx
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 57 01 00
	00		 je	 $L23450

; 958  :     {
; 959  :         pbBlock = pbSrc;

  00021	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00024	89 55 f0	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 960  :         cSamples = cSamplesPerBlock - 1;

  00027	8b 45 18	 mov	 eax, DWORD PTR _cSamplesPerBlock$[ebp]
  0002a	83 e8 01	 sub	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _cSamples$[ebp], eax

; 961  :         
; 962  :         //
; 963  :         // Block header
; 964  :         //
; 965  : 
; 966  :         dwHeader = *(LPDWORD)pbBlock;

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	89 55 f4	 mov	 DWORD PTR _dwHeader$[ebp], edx

; 967  :         pbBlock += sizeof(DWORD);

  00038	8b 45 f0	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 f0	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 968  : 
; 969  :         nPredSample = (int)(short)LOWORD(dwHeader);

  00041	8b 4d f4	 mov	 ecx, DWORD PTR _dwHeader$[ebp]
  00044	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0004a	0f bf d1	 movsx	 edx, cx
  0004d	89 55 e4	 mov	 DWORD PTR _nPredSample$[ebp], edx

; 970  :         nStepIndex = (int)(BYTE)HIWORD(dwHeader);

  00050	8b 45 f4	 mov	 eax, DWORD PTR _dwHeader$[ebp]
  00053	c1 e8 10	 shr	 eax, 16			; 00000010H
  00056	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005b	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 971  : 
; 972  :         if(!ValidStepIndex(nStepIndex))

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@@CGHH@Z ; CImaAdpcmCodec::ValidStepIndex
  00067	85 c0		 test	 eax, eax
  00069	75 0c		 jne	 SHORT $L23461

; 973  :         {
; 974  :             //
; 975  :             // The step index is out of range - this is considered a fatal
; 976  :             // error as the input stream is corrupted.  We fail by returning
; 977  :             // zero bytes converted.
; 978  :             //
; 979  : 
; 980  :             fSuccess = FALSE;

  0006b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 981  :             break;

  00072	e9 01 01 00 00	 jmp	 $L23450
$L23461:

; 982  :         }
; 983  :         
; 984  :         //
; 985  :         // Write out first sample
; 986  :         //
; 987  : 
; 988  :         *(short *)pbDst = (short)nPredSample;

  00077	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  0007a	66 8b 45 e4	 mov	 ax, WORD PTR _nPredSample$[ebp]
  0007e	66 89 02	 mov	 WORD PTR [edx], ax

; 989  :         pbDst += sizeof(short);

  00081	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  00084	83 c1 02	 add	 ecx, 2
  00087	89 4d 0c	 mov	 DWORD PTR _pbDst$[ebp], ecx
$L23466:

; 990  : 
; 991  :         //
; 992  :         // Enter the block loop
; 993  :         //
; 994  : 
; 995  :         while(cSamples)

  0008a	83 7d f8 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  0008e	0f 84 d6 00 00
	00		 je	 $L23467

; 996  :         {
; 997  :             bSample = *pbBlock++;

  00094	8b 55 f0	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00097	8a 02		 mov	 al, BYTE PTR [edx]
  00099	88 45 eb	 mov	 BYTE PTR _bSample$[ebp], al
  0009c	8b 4d f0	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  0009f	83 c1 01	 add	 ecx, 1
  000a2	89 4d f0	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 998  : 
; 999  :             //
; 1000 :             // Sample 1
; 1001 :             //
; 1002 : 
; 1003 :             nEncSample = (bSample & (BYTE)0x0F);

  000a5	8b 55 eb	 mov	 edx, DWORD PTR _bSample$[ebp]
  000a8	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000ae	83 e2 0f	 and	 edx, 15			; 0000000fH
  000b1	89 55 ec	 mov	 DWORD PTR _nEncSample$[ebp], edx

; 1004 :             nStepSize = m_asStep[nStepIndex];

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  000b7	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_asStep@CImaAdpcmCodec@@0QBFB[eax*2]
  000bf	89 4d dc	 mov	 DWORD PTR _nStepSize$[ebp], ecx

; 1005 :             nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);

  000c2	8b 55 dc	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  000c5	52		 push	 edx
  000c6	8b 45 e4	 mov	 eax, DWORD PTR _nPredSample$[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d ec	 mov	 ecx, DWORD PTR _nEncSample$[ebp]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@@CGHHHH@Z ; CImaAdpcmCodec::DecodeSample
  000d3	89 45 e4	 mov	 DWORD PTR _nPredSample$[ebp], eax

; 1006 :             nStepIndex = NextStepIndex(nEncSample, nStepIndex);

  000d6	8b 55 fc	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  000d9	52		 push	 edx
  000da	8b 45 ec	 mov	 eax, DWORD PTR _nEncSample$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@@CGHHH@Z ; CImaAdpcmCodec::NextStepIndex
  000e3	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 1007 : 
; 1008 :             *(short *)pbDst = (short)nPredSample;

  000e6	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  000e9	66 8b 55 e4	 mov	 dx, WORD PTR _nPredSample$[ebp]
  000ed	66 89 11	 mov	 WORD PTR [ecx], dx

; 1009 :             pbDst += sizeof(short);

  000f0	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  000f3	83 c0 02	 add	 eax, 2
  000f6	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 1010 : 
; 1011 :             cSamples--;

  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  000fc	83 e9 01	 sub	 ecx, 1
  000ff	89 4d f8	 mov	 DWORD PTR _cSamples$[ebp], ecx

; 1012 : 
; 1013 :             //
; 1014 :             // Sample 2
; 1015 :             //
; 1016 : 
; 1017 :             if(cSamples)

  00102	83 7d f8 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  00106	74 5d		 je	 SHORT $L23472

; 1018 :             {
; 1019 :                 nEncSample = (bSample >> 4);

  00108	8b 55 eb	 mov	 edx, DWORD PTR _bSample$[ebp]
  0010b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00111	c1 fa 04	 sar	 edx, 4
  00114	89 55 ec	 mov	 DWORD PTR _nEncSample$[ebp], edx

; 1020 :                 nStepSize = m_asStep[nStepIndex];

  00117	8b 45 fc	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  0011a	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_asStep@CImaAdpcmCodec@@0QBFB[eax*2]
  00122	89 4d dc	 mov	 DWORD PTR _nStepSize$[ebp], ecx

; 1021 :                 nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);

  00125	8b 55 dc	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  00128	52		 push	 edx
  00129	8b 45 e4	 mov	 eax, DWORD PTR _nPredSample$[ebp]
  0012c	50		 push	 eax
  0012d	8b 4d ec	 mov	 ecx, DWORD PTR _nEncSample$[ebp]
  00130	51		 push	 ecx
  00131	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@@CGHHHH@Z ; CImaAdpcmCodec::DecodeSample
  00136	89 45 e4	 mov	 DWORD PTR _nPredSample$[ebp], eax

; 1022 :                 nStepIndex = NextStepIndex(nEncSample, nStepIndex);

  00139	8b 55 fc	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  0013c	52		 push	 edx
  0013d	8b 45 ec	 mov	 eax, DWORD PTR _nEncSample$[ebp]
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@@CGHHH@Z ; CImaAdpcmCodec::NextStepIndex
  00146	89 45 fc	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 1023 : 
; 1024 :                 *(short *)pbDst = (short)nPredSample;

  00149	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  0014c	66 8b 55 e4	 mov	 dx, WORD PTR _nPredSample$[ebp]
  00150	66 89 11	 mov	 WORD PTR [ecx], dx

; 1025 :                 pbDst += sizeof(short);

  00153	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  00156	83 c0 02	 add	 eax, 2
  00159	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 1026 : 
; 1027 :                 cSamples--;

  0015c	8b 4d f8	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  0015f	83 e9 01	 sub	 ecx, 1
  00162	89 4d f8	 mov	 DWORD PTR _cSamples$[ebp], ecx
$L23472:

; 1028 :             }
; 1029 :         }

  00165	e9 20 ff ff ff	 jmp	 $L23466
$L23467:

; 1030 : 
; 1031 :         //
; 1032 :         // Skip padding
; 1033 :         //
; 1034 : 
; 1035 :         pbSrc += nBlockAlignment;

  0016a	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0016d	03 55 14	 add	 edx, DWORD PTR _nBlockAlignment$[ebp]
  00170	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 1036 :     }

  00173	e9 95 fe ff ff	 jmp	 $L23449
$L23450:

; 1037 : 
; 1038 :     return fSuccess;

  00178	8b 45 e0	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 1039 : }

  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c2 1c 00	 ret	 28			; 0000001cH
?DecodeM16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z ENDP	; CImaAdpcmCodec::DecodeM16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\acm\imaadpcm.h
_TEXT	ENDS
;	COMDAT ?ValidStepIndex@CImaAdpcmCodec@@CGHH@Z
_TEXT	SEGMENT
_nStepIndex$ = 8
?ValidStepIndex@CImaAdpcmCodec@@CGHH@Z PROC NEAR	; CImaAdpcmCodec::ValidStepIndex, COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 132  :     return (nStepIndex >= 0) && (nStepIndex < NUMELMS(m_asStep));

  00004	83 7d 08 00	 cmp	 DWORD PTR _nStepIndex$[ebp], 0
  00008	7c 0f		 jl	 SHORT $L23633
  0000a	83 7d 08 59	 cmp	 DWORD PTR _nStepIndex$[ebp], 89 ; 00000059H
  0000e	73 09		 jae	 SHORT $L23633
  00010	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR -4+[ebp], 1
  00017	eb 07		 jmp	 SHORT $L23634
$L23633:
  00019	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR -4+[ebp], 0
$L23634:
  00020	8b 45 fc	 mov	 eax, DWORD PTR -4+[ebp]

; 133  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?ValidStepIndex@CImaAdpcmCodec@@CGHH@Z ENDP		; CImaAdpcmCodec::ValidStepIndex
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\tools\acm\imaadpcm.cpp
_TEXT	ENDS
;	COMDAT ?DecodeS16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z
_TEXT	SEGMENT
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_fSuccess$ = -48
_pbBlock$ = -24
_cSamples$ = -16
_cSubSamples$ = -4
_nStepSize$ = -60
_dwHeader$ = -20
_dwLeft$ = -40
_dwRight$ = -32
_nEncSampleL$ = -56
_nPredSampleL$ = -44
_nStepIndexL$ = -28
_nEncSampleR$ = -12
_nPredSampleR$ = -8
_nStepIndexR$ = -52
_i$ = -36
?DecodeS16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z PROC NEAR	; CImaAdpcmCodec::DecodeS16, COMDAT

; 1053 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 1054 :     BOOL                    fSuccess    = TRUE;

  00006	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 1
$L23501:

; 1055 :     LPBYTE                  pbBlock;
; 1056 :     UINT                    cSamples;
; 1057 :     UINT                    cSubSamples;
; 1058 :     int                     nStepSize;
; 1059 :     DWORD                   dwHeader;
; 1060 :     DWORD                   dwLeft;
; 1061 :     DWORD                   dwRight;
; 1062 :     int                     nEncSampleL;
; 1063 :     int                     nPredSampleL;
; 1064 :     int                     nStepIndexL;
; 1065 :     int                     nEncSampleR;
; 1066 :     int                     nPredSampleR;
; 1067 :     int                     nStepIndexR;
; 1068 :     UINT                    i;
; 1069 : 
; 1070 :     //
; 1071 :     // Enter the main loop
; 1072 :     //
; 1073 :     
; 1074 :     while(cBlocks--)

  0000d	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00013	83 e9 01	 sub	 ecx, 1
  00016	89 4d 10	 mov	 DWORD PTR _cBlocks$[ebp], ecx
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 0a 02 00
	00		 je	 $L23502

; 1075 :     {
; 1076 :         pbBlock = pbSrc;

  00021	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00024	89 55 e8	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 1077 :         cSamples = cSamplesPerBlock - 1;

  00027	8b 45 18	 mov	 eax, DWORD PTR _cSamplesPerBlock$[ebp]
  0002a	83 e8 01	 sub	 eax, 1
  0002d	89 45 f0	 mov	 DWORD PTR _cSamples$[ebp], eax

; 1078 : 
; 1079 :         //
; 1080 :         // LEFT channel header
; 1081 :         //
; 1082 : 
; 1083 :         dwHeader = *(LPDWORD)pbBlock;

  00030	8b 4d e8	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	89 55 ec	 mov	 DWORD PTR _dwHeader$[ebp], edx

; 1084 :         pbBlock += sizeof(DWORD);

  00038	8b 45 e8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 e8	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 1085 :         
; 1086 :         nPredSampleL = (int)(short)LOWORD(dwHeader);

  00041	8b 4d ec	 mov	 ecx, DWORD PTR _dwHeader$[ebp]
  00044	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0004a	0f bf d1	 movsx	 edx, cx
  0004d	89 55 d4	 mov	 DWORD PTR _nPredSampleL$[ebp], edx

; 1087 :         nStepIndexL = (int)(BYTE)HIWORD(dwHeader);

  00050	8b 45 ec	 mov	 eax, DWORD PTR _dwHeader$[ebp]
  00053	c1 e8 10	 shr	 eax, 16			; 00000010H
  00056	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005b	89 45 e4	 mov	 DWORD PTR _nStepIndexL$[ebp], eax

; 1088 : 
; 1089 :         if(!ValidStepIndex(nStepIndexL)) 

  0005e	8b 4d e4	 mov	 ecx, DWORD PTR _nStepIndexL$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@@CGHH@Z ; CImaAdpcmCodec::ValidStepIndex
  00067	85 c0		 test	 eax, eax
  00069	75 0c		 jne	 SHORT $L23513

; 1090 :         {
; 1091 :             //
; 1092 :             // The step index is out of range - this is considered a fatal
; 1093 :             // error as the input stream is corrupted.  We fail by returning
; 1094 :             // zero bytes converted.
; 1095 :             //
; 1096 : 
; 1097 :             fSuccess = FALSE;

  0006b	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 1098 :             break;

  00072	e9 b4 01 00 00	 jmp	 $L23502
$L23513:

; 1099 :         }
; 1100 :         
; 1101 :         //
; 1102 :         // RIGHT channel header
; 1103 :         //
; 1104 : 
; 1105 :         dwHeader = *(LPDWORD)pbBlock;

  00077	8b 55 e8	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  0007a	8b 02		 mov	 eax, DWORD PTR [edx]
  0007c	89 45 ec	 mov	 DWORD PTR _dwHeader$[ebp], eax

; 1106 :         pbBlock += sizeof(DWORD);

  0007f	8b 4d e8	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00082	83 c1 04	 add	 ecx, 4
  00085	89 4d e8	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 1107 :         
; 1108 :         nPredSampleR = (int)(short)LOWORD(dwHeader);

  00088	8b 55 ec	 mov	 edx, DWORD PTR _dwHeader$[ebp]
  0008b	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00091	0f bf c2	 movsx	 eax, dx
  00094	89 45 f8	 mov	 DWORD PTR _nPredSampleR$[ebp], eax

; 1109 :         nStepIndexR = (int)(BYTE)HIWORD(dwHeader);

  00097	8b 4d ec	 mov	 ecx, DWORD PTR _dwHeader$[ebp]
  0009a	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0009d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000a3	89 4d cc	 mov	 DWORD PTR _nStepIndexR$[ebp], ecx

; 1110 : 
; 1111 :         if(!ValidStepIndex(nStepIndexR))

  000a6	8b 55 cc	 mov	 edx, DWORD PTR _nStepIndexR$[ebp]
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@@CGHH@Z ; CImaAdpcmCodec::ValidStepIndex
  000af	85 c0		 test	 eax, eax
  000b1	75 0c		 jne	 SHORT $L23524

; 1112 :         {
; 1113 :             //
; 1114 :             // The step index is out of range - this is considered a fatal
; 1115 :             // error as the input stream is corrupted.  We fail by returning
; 1116 :             // zero bytes converted.
; 1117 :             //
; 1118 : 
; 1119 :             fSuccess = FALSE;

  000b3	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 1120 :             break;

  000ba	e9 6c 01 00 00	 jmp	 $L23502
$L23524:

; 1121 :         }
; 1122 : 
; 1123 :         //
; 1124 :         // Write out first sample
; 1125 :         //
; 1126 : 
; 1127 :         *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);

  000bf	8b 45 d4	 mov	 eax, DWORD PTR _nPredSampleL$[ebp]
  000c2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000c7	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _nPredSampleR$[ebp]
  000cf	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000d5	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000db	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000de	0b c1		 or	 eax, ecx
  000e0	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  000e3	89 02		 mov	 DWORD PTR [edx], eax

; 1128 :         pbDst += sizeof(DWORD);

  000e5	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  000e8	83 c0 04	 add	 eax, 4
  000eb	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax
$L23534:

; 1129 : 
; 1130 :         //
; 1131 :         // The first DWORD contains 4 left samples, the second DWORD
; 1132 :         // contains 4 right samples.  We process the source in 8-byte
; 1133 :         // chunks to make it easy to interleave the output correctly.
; 1134 :         //
; 1135 : 
; 1136 :         while(cSamples)

  000ee	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000f2	0f 84 25 01 00
	00		 je	 $L23535

; 1137 :         {
; 1138 :             dwLeft = *(LPDWORD)pbBlock;

  000f8	8b 4d e8	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  000fb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fd	89 55 d8	 mov	 DWORD PTR _dwLeft$[ebp], edx

; 1139 :             pbBlock += sizeof(DWORD);

  00100	8b 45 e8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  00103	83 c0 04	 add	 eax, 4
  00106	89 45 e8	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 1140 :             dwRight = *(LPDWORD)pbBlock;

  00109	8b 4d e8	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  0010c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010e	89 55 e0	 mov	 DWORD PTR _dwRight$[ebp], edx

; 1141 :             pbBlock += sizeof(DWORD);

  00111	8b 45 e8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  00114	83 c0 04	 add	 eax, 4
  00117	89 45 e8	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 1142 : 
; 1143 :             cSubSamples = min(cSamples, 8);

  0011a	83 7d f0 08	 cmp	 DWORD PTR _cSamples$[ebp], 8
  0011e	73 08		 jae	 SHORT $L23638
  00120	8b 4d f0	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  00123	89 4d c0	 mov	 DWORD PTR -64+[ebp], ecx
  00126	eb 07		 jmp	 SHORT $L23639
$L23638:
  00128	c7 45 c0 08 00
	00 00		 mov	 DWORD PTR -64+[ebp], 8
$L23639:
  0012f	8b 55 c0	 mov	 edx, DWORD PTR -64+[ebp]
  00132	89 55 fc	 mov	 DWORD PTR _cSubSamples$[ebp], edx

; 1144 :             
; 1145 :             for(i = 0; i < cSubSamples; i++)

  00135	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0013c	eb 09		 jmp	 SHORT $L23540
$L23541:
  0013e	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  00141	83 c0 01	 add	 eax, 1
  00144	89 45 dc	 mov	 DWORD PTR _i$[ebp], eax
$L23540:
  00147	8b 4d dc	 mov	 ecx, DWORD PTR _i$[ebp]
  0014a	3b 4d fc	 cmp	 ecx, DWORD PTR _cSubSamples$[ebp]
  0014d	0f 83 bc 00 00
	00		 jae	 $L23542

; 1146 :             {
; 1147 :                 //
; 1148 :                 // LEFT channel
; 1149 :                 //
; 1150 : 
; 1151 :                 nEncSampleL = (dwLeft & 0x0F);

  00153	8b 55 d8	 mov	 edx, DWORD PTR _dwLeft$[ebp]
  00156	83 e2 0f	 and	 edx, 15			; 0000000fH
  00159	89 55 c8	 mov	 DWORD PTR _nEncSampleL$[ebp], edx

; 1152 :                 nStepSize = m_asStep[nStepIndexL];

  0015c	8b 45 e4	 mov	 eax, DWORD PTR _nStepIndexL$[ebp]
  0015f	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_asStep@CImaAdpcmCodec@@0QBFB[eax*2]
  00167	89 4d c4	 mov	 DWORD PTR _nStepSize$[ebp], ecx

; 1153 :                 nPredSampleL = DecodeSample(nEncSampleL, nPredSampleL, nStepSize);

  0016a	8b 55 c4	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  0016d	52		 push	 edx
  0016e	8b 45 d4	 mov	 eax, DWORD PTR _nPredSampleL$[ebp]
  00171	50		 push	 eax
  00172	8b 4d c8	 mov	 ecx, DWORD PTR _nEncSampleL$[ebp]
  00175	51		 push	 ecx
  00176	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@@CGHHHH@Z ; CImaAdpcmCodec::DecodeSample
  0017b	89 45 d4	 mov	 DWORD PTR _nPredSampleL$[ebp], eax

; 1154 :                 nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);

  0017e	8b 55 e4	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  00181	52		 push	 edx
  00182	8b 45 c8	 mov	 eax, DWORD PTR _nEncSampleL$[ebp]
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@@CGHHH@Z ; CImaAdpcmCodec::NextStepIndex
  0018b	89 45 e4	 mov	 DWORD PTR _nStepIndexL$[ebp], eax

; 1155 : 
; 1156 :                 //
; 1157 :                 // RIGHT channel
; 1158 :                 //
; 1159 : 
; 1160 :                 nEncSampleR = (dwRight & 0x0F);

  0018e	8b 4d e0	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  00191	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00194	89 4d f4	 mov	 DWORD PTR _nEncSampleR$[ebp], ecx

; 1161 :                 nStepSize = m_asStep[nStepIndexR];

  00197	8b 55 cc	 mov	 edx, DWORD PTR _nStepIndexR$[ebp]
  0019a	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@@0QBFB[edx*2]
  001a2	89 45 c4	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 1162 :                 nPredSampleR = DecodeSample(nEncSampleR, nPredSampleR, nStepSize);

  001a5	8b 4d c4	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  001a8	51		 push	 ecx
  001a9	8b 55 f8	 mov	 edx, DWORD PTR _nPredSampleR$[ebp]
  001ac	52		 push	 edx
  001ad	8b 45 f4	 mov	 eax, DWORD PTR _nEncSampleR$[ebp]
  001b0	50		 push	 eax
  001b1	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@@CGHHHH@Z ; CImaAdpcmCodec::DecodeSample
  001b6	89 45 f8	 mov	 DWORD PTR _nPredSampleR$[ebp], eax

; 1163 :                 nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);

  001b9	8b 4d cc	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  001bc	51		 push	 ecx
  001bd	8b 55 f4	 mov	 edx, DWORD PTR _nEncSampleR$[ebp]
  001c0	52		 push	 edx
  001c1	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@@CGHHH@Z ; CImaAdpcmCodec::NextStepIndex
  001c6	89 45 cc	 mov	 DWORD PTR _nStepIndexR$[ebp], eax

; 1164 : 
; 1165 :                 //
; 1166 :                 // Write out sample
; 1167 :                 //
; 1168 : 
; 1169 :                 *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);

  001c9	8b 45 d4	 mov	 eax, DWORD PTR _nPredSampleL$[ebp]
  001cc	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001d1	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001d6	8b 4d f8	 mov	 ecx, DWORD PTR _nPredSampleR$[ebp]
  001d9	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  001df	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  001e5	c1 e1 10	 shl	 ecx, 16			; 00000010H
  001e8	0b c1		 or	 eax, ecx
  001ea	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  001ed	89 02		 mov	 DWORD PTR [edx], eax

; 1170 :                 pbDst += sizeof(DWORD);

  001ef	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  001f2	83 c0 04	 add	 eax, 4
  001f5	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 1171 : 
; 1172 :                 //
; 1173 :                 // Shift the next input sample into the low-order 4 bits.
; 1174 :                 //
; 1175 : 
; 1176 :                 dwLeft >>= 4;

  001f8	8b 4d d8	 mov	 ecx, DWORD PTR _dwLeft$[ebp]
  001fb	c1 e9 04	 shr	 ecx, 4
  001fe	89 4d d8	 mov	 DWORD PTR _dwLeft$[ebp], ecx

; 1177 :                 dwRight >>= 4;

  00201	8b 55 e0	 mov	 edx, DWORD PTR _dwRight$[ebp]
  00204	c1 ea 04	 shr	 edx, 4
  00207	89 55 e0	 mov	 DWORD PTR _dwRight$[ebp], edx

; 1178 :             }

  0020a	e9 2f ff ff ff	 jmp	 $L23541
$L23542:

; 1179 : 
; 1180 :             cSamples -= cSubSamples;

  0020f	8b 45 f0	 mov	 eax, DWORD PTR _cSamples$[ebp]
  00212	2b 45 fc	 sub	 eax, DWORD PTR _cSubSamples$[ebp]
  00215	89 45 f0	 mov	 DWORD PTR _cSamples$[ebp], eax

; 1181 :         }

  00218	e9 d1 fe ff ff	 jmp	 $L23534
$L23535:

; 1182 : 
; 1183 :         //
; 1184 :         // Skip padding
; 1185 :         //
; 1186 : 
; 1187 :         pbSrc += nBlockAlignment;

  0021d	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  00220	03 4d 14	 add	 ecx, DWORD PTR _nBlockAlignment$[ebp]
  00223	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 1188 :     }

  00226	e9 e2 fd ff ff	 jmp	 $L23501
$L23502:

; 1189 : 
; 1190 :     return fSuccess;

  0022b	8b 45 d0	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 1191 : }

  0022e	8b e5		 mov	 esp, ebp
  00230	5d		 pop	 ebp
  00231	c2 1c 00	 ret	 28			; 0000001cH
?DecodeS16@CImaAdpcmCodec@@CGHPAE0IIIPAH1@Z ENDP	; CImaAdpcmCodec::DecodeS16
_TEXT	ENDS
END
