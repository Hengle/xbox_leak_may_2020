; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\ac97.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
DSOUND_URW	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_URW	ENDS
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_06GGPOMPNM@?$CInone?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DK@BHCCMBKD@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0O@GGBLDHEI@?$CBm_dwRefCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BE@DAEOBIBM@m_dwRefCount?5?$DM?5?$HO0UL?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0N@OILPJBKD@m_dwRefCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DG@LNGLCLLL@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@MLMBNMPN@nLength?5?$DO?5sizeof?$CI?$CKpRunMarker?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_07CNKCBOKB@TESTSND?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DH@NAFPMNMN@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0FF@CEBOEHDG@DirectSound?5is?5in?5the?5final?5stag@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@GKNCNMBD@CDirectSoundTest?3?3AddRef?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@KCMACBKL@CDirectSoundTest?3?3Release?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DK@PBGBJGJP@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0O@JCBGLFIF@?$CBm_paNotifier?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@JLKNBNJM@?$CBm_dwNotifierCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0N@BMLCBDGO@m_paNotifier?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@ELEAODJN@dwNotifierIndex?5?$DM?5m_dwNotifierCo@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@MEDKFNKN@Unexpected?5notifier?5status?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BC@NHNIONPC@m_dwNotifierCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DI@JEPBENHJ@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BA@IANIBDAF@m_pGpDspManager?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@ONCKHILO@m_dwState?5?$CG?5MCPX_APUSTATE_GPIMAG@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@FGGNHBE@KeGetCurrentIrql?$CI?$CJ?5?$DO?$DN?5DISPATCH_L@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@IECLLDN@m_dwVoiceMapLock?5?$DM?5?$HO0UL?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@FFOHIBNC@m_dwVoiceMapLock?5?$DO?$DN?51?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@EHADIMFA@CAc97Device?3?3CAc97Device?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CK@JJOOJCMG@The?5AC97?5device?5driver?5is?5alread@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@JOAPHODK@CAc97Device?3?3Initialize?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BA@DNIFEHFF@CODEC?5not?5ready?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@GIKFABDJ@Failed?5to?5connect?5interrupt?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@NAGMAMBI@Unable?5to?5set?5front?5volume?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BN@BOHODCI@Unable?5to?5set?5PCM?5out?5volume?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@LBDLLBEL@?$CBm_apChannels?$FLnChannelType?$FN?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@EBLNFACL@CAc97Channel?$CIthis?0?5nChannelType?$CJ@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CD@OAIDILGI@CAc97Device?3?3AcquireCodecSemapho@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@PEFIIICE@Failed?5to?5get?5CODEC?5semaphore?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@MMMJCIJG@CAc97Device?3?3CodecReady?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@EBHBCGLE@Timed?5out?5waiting?5for?5ready?5bit?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@DMKKGDEM@CAc97Device?3?3ServiceAciInterrupt@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@HDJNMBLD@Channel?5?$CFlu?5not?5allocated?$CB?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@OPIJJKBJ@CAc97Device?3?3PeekAc97Register?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@ELGJIPAJ@AC?5?897?5register?5peek?5failed?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BF@HKCIBLPB@CAc97Device?3?3PowerUp?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@PNLPHEF@Failed?5to?5set?5power?5state?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_06GMOAGDML@ACIPRD?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_04ELFAHOMP@BYTE?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@GIEFHAAL@m_bPrdCount?5?$DM?5ACIPRDL_ENTRY_COUN@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0EH@NFHOMJAA@?$CIdwBufferSize?5?1?5?$CIm_pDevice?9?$DOm_wf@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DF@GAHFEOCL@?$CB?$CIdwBufferSize?5?$CF?5m_pDevice?9?$DOm_wf@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0P@NNIHOMBL@?$CBm_bCurrentPrd?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CH@NBJNCKCO@m_dwFlags?5?$CG?5AC97CHANNEL_OBJECTF_@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0M@CIAIIEJM@m_bPrdCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@ODFENEBH@?$CB?$CIdwBufferSize?5?$CF?5dwPacketCount?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BP@DKHIOCCO@CAc97Channel?3?3ServiceInterrupt?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@HOPFFPKD@AC?897?5stream?5starving?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@JMNBEPBG@bPrdCount?5?$DM?$DN?5ACIPRDL_ENTRY_COUNT@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CP@DOECGKNM@Improperly?5looping?5on?5the?5discon@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@POAMABGN@?$CBPeekAciRegister8?$CIX_CTRL?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@ICDCGPHP@dwPosition?5?$DM?$DN?5dwLength?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BE@OIJNCBGH@dwPosition?5?$DM?50xFFFF?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@GLKFBKGJ@NULL?5?$CCthis?$CC?5pointer?5?$CI?$CFx?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@LEKIOFPG@Invalid?5?$CCthis?$CC?5pointer?5?$CI?$CFx?5?$CB?$DN?5?$CFx@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
DSOUND_RW	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RW	ENDS
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IsEqualGUID@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _==@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _KeGetCurrentIrql@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _KeIsExecutingDpc@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_AddRef@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_Release@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_GetAdapterCount@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_BeginScene@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_EndScene@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_GetRenderState@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_GetTextureStageState@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_SetRenderState@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_SetTextureStageState@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DResource_MoveResourceMemory@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DTexture_UnlockRect@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVolumeTexture_UnlockBox@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DCubeTexture_UnlockRect@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVertexBuffer_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DIndexBuffer_Lock@20
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DIndexBuffer_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DPalette_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DSurface_UnlockRect@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVolume_UnlockBox@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _sqrtf@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@MMMMMMMMMMMMMMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXPLANE@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??2@YAPAXIPBDK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??3@YAXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CIrql@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Raise@CIrql@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Lower@CIrql@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAutoIrql@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAutoIrql@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Save@CFpState@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Restore@CFpState@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCRefCountTest@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CRefCountTest@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AddRef@CRefCountTest@@UAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Release@CRefCountTest@@UAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister8@CAc97Device@@KGEK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister8@CAc97Device@@KGXKE@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister16@CAc97Device@@KGGK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister16@CAc97Device@@KGXKG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister32@CAc97Device@@KGKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister32@CAc97Device@@KGXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister8@CAc97Device@@KGEK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister8@CAc97Device@@KGXKE@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister16@CAc97Device@@KGGK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister16@CAc97Device@@KGXKG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister32@CAc97Device@@KGKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister32@CAc97Device@@KGXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?WaitRegisterRetry@CAc97Device@@KGXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AciInterruptServiceRoutine@CAc97Device@@CGEPAU_KINTERRUPT@@PAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AciInterruptDpcHandler@CAc97Device@@CGXPAU_KDPC@@PAX11@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AciShutdownNotifier@CAc97Device@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AciSynchronizationRoutine@CAc97Device@@CGEPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ReleaseChannel@CAc97Device@@QAEXPAVCAc97Channel@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AttachPacket@CAc97Channel@@QAEXPBXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister8@CAc97Channel@@IAEEK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister8@CAc97Channel@@IAEXKE@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister16@CAc97Channel@@IAEGK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister16@CAc97Channel@@IAEXKG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister32@CAc97Channel@@IAEXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestEnterCriticalSection@@YGHXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestLeaveCriticalSection@@YGXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAutoLockTest@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAutoLockTest@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Free@CMcpxNotifierTest@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Reset@CMcpxNotifierTest@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetScratchSpaceLinAddr@CMcpxDspScratchDmaTest@@QAEPAXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAc97Device@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAc97Device@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CAc97Device@@QAEJK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Terminate@CAc97Device@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreateChannel@CAc97Device@@QAEJW4AC97CHANNELTYPE@@PAPAVCAc97Channel@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ReleaseChannel@CAc97Device@@QAEXW4AC97CHANNELTYPE@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCAc97Channel@@QAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AcquireCodecSemaphore@CAc97Device@@KGHXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CodecReady@CAc97Device@@IAEHXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetInterruptStatus@CAc97Device@@IAEKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ServiceAciInterrupt@CAc97Device@@IAEKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ServiceAciInterruptDpc@CAc97Device@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SynchronizeAciInterrupt@CAc97Device@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAc97Register@CAc97Device@@KGHW4AC97REGISTER@@PAG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAc97Register@CAc97Device@@KGHW4AC97REGISTER@@G@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?VerifyPokeAc97Register@CAc97Device@@KGHW4AC97REGISTER@@G@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PowerUp@CAc97Device@@IAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAc97Channel@@QAE@PAVCAc97Device@@W4AC97CHANNELTYPE@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAc97Channel@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CAc97Channel@@QAEJKP6GXPAX@Z0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Terminate@CAc97Channel@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AttachPacket@CAc97Channel@@QAEXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AttachBuffer@CAc97Channel@@QAEXKKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Discontinuity@CAc97Channel@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ServiceInterrupt@CAc97Channel@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Reset@CAc97Channel@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Flush@CAc97Channel@@QAEXH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Run@CAc97Channel@@QAEXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Pause@CAc97Channel@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetPrdIndeces@CAc97Channel@@IAEXEEHH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetMode@CAc97Channel@@QAEXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetPosition@CAc97Channel@@QAEKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetPosition@CAc97Channel@@IAEXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1?$CValidObject@$0EEFDEOEE@@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AssertValidObject@?$CValidObject@$0EEFDEOEE@@@QAEXPBDK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_G?$CValidObject@$0EEFDEOEE@@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_7?$CValidObject@$0EEFDEOEE@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?adwChannelStatusMasks@?1??ServiceAciInterrupt@CAc97Device@@IAEKXZ@4QBKB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT _TestSoundLibBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_7CRefCountTest@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?dwStatusMask@?1??GetInterruptStatus@CAc97Device@@IAEKXZ@4KB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, DSOUND_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_D3DPRIMITIVETOVERTEXCOUNT
PUBLIC	_D3DSIMPLERENDERSTATEENCODE
PUBLIC	_D3DTEXTUREDIRECTENCODE
PUBLIC	_D3DDIRTYFROMRENDERSTATE
PUBLIC	_D3DDIRTYFROMTEXTURESTATE
PUBLIC	?m_wfxFormat@CAc97Device@@2UtWAVEFORMATEX@@B	; CAc97Device::m_wfxFormat
PUBLIC	?m_dwAc97RegisterBase@CAc97Device@@2KB		; CAc97Device::m_dwAc97RegisterBase
PUBLIC	?m_dwAciRegisterBase@CAc97Device@@2KB		; CAc97Device::m_dwAciRegisterBase
PUBLIC	?m_pDevice@CAc97Device@@2PAV1@A			; CAc97Device::m_pDevice
PUBLIC	?m_Interrupt@CAc97Device@@1U_KINTERRUPT@@A	; CAc97Device::m_Interrupt
PUBLIC	?m_adwRegisterOffsets@CAc97Channel@@2QBKB	; CAc97Channel::m_adwRegisterOffsets
PUBLIC	?m_dwSilenceSize@CAc97Channel@@2KB		; CAc97Channel::m_dwSilenceSize
PUBLIC	_TestSoundLibBuildNumberD
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
DSOUND_RD	SEGMENT
_D3DPRIMITIVETOVERTEXCOUNT DD 00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
DSOUND_RD	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
DSOUND_RD	SEGMENT
_D3DSIMPLERENDERSTATEENCODE DD 040260H
	DD	040264H
	DD	040268H
	DD	04026cH
	DD	040270H
	DD	040274H
	DD	040278H
	DD	04027cH
	DD	040288H
	DD	04028cH
	DD	040a60H
	DD	040a64H
	DD	040a68H
	DD	040a6cH
	DD	040a70H
	DD	040a74H
	DD	040a78H
	DD	040a7cH
	DD	040a80H
	DD	040a84H
	DD	040a88H
	DD	040a8cH
	DD	040a90H
	DD	040a94H
	DD	040a98H
	DD	040a9cH
	DD	040aa0H
	DD	040aa4H
	DD	040aa8H
	DD	040aacH
	DD	040ab0H
	DD	040ab4H
	DD	040ab8H
	DD	040abcH
	DD	040ac0H
	DD	040ac4H
	DD	040ac8H
	DD	040accH
	DD	040ad0H
	DD	040ad4H
	DD	040ad8H
	DD	040adcH
	DD	0417f8H
	DD	041e20H
	DD	041e24H
	DD	041e40H
	DD	041e44H
	DD	041e48H
	DD	041e4cH
	DD	041e50H
	DD	041e54H
	DD	041e58H
	DD	041e5cH
	DD	041e60H
	DD	041d90H
	DD	041e74H
	DD	041e78H
	DD	040354H
	DD	04033cH
	DD	040304H
	DD	040300H
	DD	040340H
	DD	040344H
	DD	040348H
	DD	04035cH
	DD	040310H
	DD	04037cH
	DD	040358H
	DD	040374H
	DD	040378H
	DD	040364H
	DD	040368H
	DD	04036cH
	DD	040360H
	DD	040350H
	DD	04034cH
	DD	0409f8H
	DD	040384H
	DD	040388H
	DD	040330H
	DD	040334H
	DD	040338H
DSOUND_RD	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
DSOUND_RD	SEGMENT
_D3DTEXTUREDIRECTENCODE DD 081b00H
	DD	081b40H
	DD	081b80H
	DD	081bc0H
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
DSOUND_RD	SEGMENT
_D3DDIRTYFROMRENDERSTATE DD 02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	01200H
	DD	03000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	0100H
	DD	0100H
	DD	0900H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	00H
	DD	00H
	DD	00H
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
DSOUND_RD	SEGMENT
_D3DDIRTYFROMTEXTURESTATE DD 0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0480fH
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0400H
DSOUND_RD	ENDS
;	COMDAT _TestSoundLibBuildNumberD
XBLD$V	SEGMENT
_TestSoundLibBuildNumberD DW 04554H
	DW	05453H
	DW	04e53H
	DW	04444H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
DSOUND_RD	SEGMENT
?m_dwAc97RegisterBase@CAc97Device@@2KB DD 0fec00000H	; CAc97Device::m_dwAc97RegisterBase
?m_dwAciRegisterBase@CAc97Device@@2KB DD 0fec00100H	; CAc97Device::m_dwAciRegisterBase
?m_wfxFormat@CAc97Device@@2UtWAVEFORMATEX@@B DW 01H	; CAc97Device::m_wfxFormat
	DW	02H
	DD	0bb80H
	DD	02ee00H
	DW	04H
	DW	010H
	DW	00H
DSOUND_RD	ENDS
DSOUND_RW	SEGMENT
?m_pDevice@CAc97Device@@2PAV1@A DD 00H			; CAc97Device::m_pDevice
	ORG $+4
?m_Interrupt@CAc97Device@@1U_KINTERRUPT@@A DD 00H	; CAc97Device::m_Interrupt
	ORG $+108
DSOUND_RW	ENDS
DSOUND_RD	SEGMENT
	ORG $+2
?m_adwRegisterOffsets@CAc97Channel@@2QBKB DD 010H	; CAc97Channel::m_adwRegisterOffsets
	DD	070H
?m_dwSilenceSize@CAc97Channel@@2KB DD 02000H		; CAc97Channel::m_dwSilenceSize
DSOUND_RD	ENDS
PUBLIC	??_C@_07CNKCBOKB@TESTSND?$AA@			; `string'
PUBLIC	??_C@_0BJ@EHADIMFA@CAc97Device?3?3CAc97Device?$AA@ ; `string'
PUBLIC	??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CK@JJOOJCMG@The?5AC97?5device?5driver?5is?5alread@ ; `string'
PUBLIC	??0CAc97Device@@QAE@XZ				; CAc97Device::CAc97Device
EXTRN	_DwDbgSetContext:NEAR
EXTRN	_DwDbgPrint:NEAR
;	COMDAT ??_C@_07CNKCBOKB@TESTSND?$AA@
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.cpp
DSOUND_RD	SEGMENT
??_C@_07CNKCBOKB@TESTSND?$AA@ DB 'TESTSND', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@EHADIMFA@CAc97Device?3?3CAc97Device?$AA@
DSOUND_RD	SEGMENT
??_C@_0BJ@EHADIMFA@CAc97Device?3?3CAc97Device?$AA@ DB 'CAc97Device::CAc97'
	DB	'Device', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT
??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\initlib\ac97.cpp', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CK@JJOOJCMG@The?5AC97?5device?5driver?5is?5alread@
DSOUND_RD	SEGMENT
??_C@_0CK@JJOOJCMG@The?5AC97?5device?5driver?5is?5alread@ DB 'The AC97 de'
	DB	'vice driver is already running', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ??0CAc97Device@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CAc97Device@@QAE@XZ PROC NEAR			; CAc97Device::CAc97Device, COMDAT
; _this$ = ecx

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 83   :     DPF_ENTER();
; 84   : 
; 85   :     if(m_pDevice)

  00007	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pDevice@CAc97Device@@2PAV1@A, 0 ; CAc97Device::m_pDevice
  0000e	74 2a		 je	 SHORT $L32058

; 86   :     {
; 87   :         DPF_ERROR("The AC97 device driver is already running");

  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@EHADIMFA@CAc97Device?3?3CAc97Device?$AA@
  0001a	6a 57		 push	 87			; 00000057H
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  00021	6a 01		 push	 1
  00023	6a 09		 push	 9
  00025	e8 00 00 00 00	 call	 _DwDbgSetContext
  0002a	83 c4 18	 add	 esp, 24			; 00000018H
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@JJOOJCMG@The?5AC97?5device?5driver?5is?5alread@
  00032	e8 00 00 00 00	 call	 _DwDbgPrint
  00037	83 c4 04	 add	 esp, 4
$L32058:

; 88   :     }
; 89   : 
; 90   :     m_pDevice = this;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	a3 00 00 00 00	 mov	 DWORD PTR ?m_pDevice@CAc97Device@@2PAV1@A, eax ; CAc97Device::m_pDevice

; 91   : 
; 92   :     DPF_LEAVE_VOID();
; 93   : }

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??0CAc97Device@@QAE@XZ ENDP				; CAc97Device::CAc97Device
DSOUND	ENDS
PUBLIC	??1CAc97Device@@QAE@XZ				; CAc97Device::~CAc97Device
PUBLIC	?Terminate@CAc97Device@@QAEXXZ			; CAc97Device::Terminate
; Function compile flags: /Odt
;	COMDAT ??1CAc97Device@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CAc97Device@@QAE@XZ PROC NEAR			; CAc97Device::~CAc97Device, COMDAT
; _this$ = ecx

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  :     DPF_ENTER();
; 120  : 
; 121  :     Terminate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Terminate@CAc97Device@@QAEXXZ ; CAc97Device::Terminate

; 122  : 
; 123  :     m_pDevice = NULL;

  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_pDevice@CAc97Device@@2PAV1@A, 0 ; CAc97Device::m_pDevice

; 124  : 
; 125  :     DPF_LEAVE_VOID();
; 126  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??1CAc97Device@@QAE@XZ ENDP				; CAc97Device::~CAc97Device
DSOUND	ENDS
PUBLIC	??_C@_0BI@JOAPHODK@CAc97Device?3?3Initialize?$AA@ ; `string'
PUBLIC	??_C@_0BA@DNIFEHFF@CODEC?5not?5ready?$AA@	; `string'
PUBLIC	??_C@_0BM@GIKFABDJ@Failed?5to?5connect?5interrupt?$AA@ ; `string'
PUBLIC	??_C@_0BL@NAGMAMBI@Unable?5to?5set?5front?5volume?$AA@ ; `string'
PUBLIC	??_C@_0BN@BOHODCI@Unable?5to?5set?5PCM?5out?5volume?$AA@ ; `string'
PUBLIC	?Initialize@CAc97Device@@QAEJK@Z		; CAc97Device::Initialize
PUBLIC	?CodecReady@CAc97Device@@IAEHXZ			; CAc97Device::CodecReady
PUBLIC	?PowerUp@CAc97Device@@IAEJXZ			; CAc97Device::PowerUp
PUBLIC	?PokeAciRegister8@CAc97Device@@KGXKE@Z		; CAc97Device::PokeAciRegister8
PUBLIC	?PokeAc97Register@CAc97Device@@KGHW4AC97REGISTER@@G@Z ; CAc97Device::PokeAc97Register
PUBLIC	?AciInterruptServiceRoutine@CAc97Device@@CGEPAU_KINTERRUPT@@PAX@Z ; CAc97Device::AciInterruptServiceRoutine
PUBLIC	?AciInterruptDpcHandler@CAc97Device@@CGXPAU_KDPC@@PAX11@Z ; CAc97Device::AciInterruptDpcHandler
PUBLIC	?AciShutdownNotifier@CAc97Device@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z ; CAc97Device::AciShutdownNotifier
EXTRN	__imp__HalRegisterShutdownNotification@8:NEAR
EXTRN	__imp__HalGetInterruptVector@8:NEAR
EXTRN	__imp__KeInitializeDpc@12:NEAR
EXTRN	__imp__KeInitializeInterrupt@28:NEAR
EXTRN	__imp__KeConnectInterrupt@4:NEAR
;	COMDAT ??_C@_0BI@JOAPHODK@CAc97Device?3?3Initialize?$AA@
DSOUND_RD	SEGMENT
??_C@_0BI@JOAPHODK@CAc97Device?3?3Initialize?$AA@ DB 'CAc97Device::Initia'
	DB	'lize', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BA@DNIFEHFF@CODEC?5not?5ready?$AA@
DSOUND_RD	SEGMENT
??_C@_0BA@DNIFEHFF@CODEC?5not?5ready?$AA@ DB 'CODEC not ready', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@GIKFABDJ@Failed?5to?5connect?5interrupt?$AA@
DSOUND_RD	SEGMENT
??_C@_0BM@GIKFABDJ@Failed?5to?5connect?5interrupt?$AA@ DB 'Failed to conn'
	DB	'ect interrupt', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@NAGMAMBI@Unable?5to?5set?5front?5volume?$AA@
DSOUND_RD	SEGMENT
??_C@_0BL@NAGMAMBI@Unable?5to?5set?5front?5volume?$AA@ DB 'Unable to set '
	DB	'front volume', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BN@BOHODCI@Unable?5to?5set?5PCM?5out?5volume?$AA@
DSOUND_RD	SEGMENT
??_C@_0BN@BOHODCI@Unable?5to?5set?5PCM?5out?5volume?$AA@ DB 'Unable to se'
	DB	't PCM out volume', 00H			; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Initialize@CAc97Device@@QAEJK@Z
DSOUND	SEGMENT
_this$ = -20
_hr$ = -16
_Irql$ = -9
_i$ = -8
_ulInterruptVector$ = -4
_dwFlags$ = 8
?Initialize@CAc97Device@@QAEJK@Z PROC NEAR		; CAc97Device::Initialize, COMDAT
; _this$ = ecx

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 153  :     HRESULT                 hr                  = DS_OK;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 154  : 
; 155  : #ifdef AC97_AMR
; 156  : 
; 157  :     DWORD                   dwRegisterValue;
; 158  :     BYTE                    bInterruptLine;
; 159  :     PCI_COMMON_CONFIG       PciConfig;
; 160  :     PCI_SLOT_NUMBER         Slot;
; 161  : 
; 162  : #endif // AC97_AMR
; 163  : 
; 164  :     KIRQL                   Irql;
; 165  :     ULONG                   ulInterruptVector;
; 166  :     DWORD                   i;
; 167  : 
; 168  :     DPF_ENTER();
; 169  : 
; 170  :     //
; 171  :     // Save the flags
; 172  :     //
; 173  :     
; 174  :     m_dwFlags = dwFlags;

  00010	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00016	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 175  : 
; 176  : #ifdef AC97_AMR
; 177  : 
; 178  :     //
; 179  :     // Poke the PCI controller to enable the AMR sound device
; 180  :     //
; 181  : 
; 182  :     _outpd(0xCF8, 0x8000F8F0);
; 183  : 
; 184  :     dwRegisterValue = _inpd(0xCFC);
; 185  : 
; 186  :     if(dwRegisterValue & 0x200000)
; 187  :     {
; 188  :         _outpd(0xCFC, dwRegisterValue & ~0x200000);
; 189  :     }
; 190  : 
; 191  :     //
; 192  :     // Get the device's interrupt line, since it won't be in the PCI config
; 193  :     //
; 194  : 
; 195  :     Slot.u.bits.DeviceNumber = m_dwDeviceNumber;
; 196  :     Slot.u.bits.FunctionNumber = 0;
; 197  :     Slot.u.bits.Reserved = 0;
; 198  : 
; 199  :     HalReadPCISpace(m_dwBusNumber, Slot.u.AsULONG, 0x61, &bInterruptLine, sizeof(bInterruptLine));
; 200  : 
; 201  :     //
; 202  :     // Get the device's current PCI config data
; 203  :     //
; 204  : 
; 205  :     Slot.u.bits.FunctionNumber = m_dwFunctionNumber;
; 206  : 
; 207  :     HalReadPCISpace(m_dwBusNumber, Slot.u.AsULONG, 0, &PciConfig, sizeof(PciConfig));
; 208  : 
; 209  :     ASSERT(m_dwVendorId == PciConfig.VendorID);
; 210  :     ASSERT(m_dwDeviceId == PciConfig.DeviceID);
; 211  : 
; 212  :     //
; 213  :     // Assign base addresses and IRQ
; 214  :     //
; 215  : 
; 216  :     DPF_AC97("Using IRQ %x", (DWORD)bInterruptLine);
; 217  : 
; 218  :     PciConfig.Command = 5;
; 219  : 
; 220  :     PciConfig.u.type0.BaseAddresses[0] = m_dwAc97RegisterBase | 1;
; 221  :     PciConfig.u.type0.BaseAddresses[1] = m_dwAciRegisterBase | 1;
; 222  : 
; 223  :     PciConfig.u.type0.InterruptLine = bInterruptLine;
; 224  :     PciConfig.u.type0.InterruptPin = 0;
; 225  : 
; 226  :     HalWritePCISpace(m_dwBusNumber, Slot.u.AsULONG, 0, &PciConfig, sizeof(PciConfig));
; 227  : 
; 228  : #endif // AC97_AMR
; 229  : 
; 230  :     //
; 231  :     // Make sure the CODEC is ready to be powered up
; 232  :     //
; 233  : 
; 234  :     if(!CodecReady())

  00019	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?CodecReady@CAc97Device@@IAEHXZ ; CAc97Device::CodecReady
  00021	85 c0		 test	 eax, eax
  00023	75 34		 jne	 SHORT $L32075

; 235  :     {
; 236  :         DPF_ERROR("CODEC not ready");

  00025	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@JOAPHODK@CAc97Device?3?3Initialize?$AA@
  0002f	68 ec 00 00 00	 push	 236			; 000000ecH
  00034	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  00039	6a 01		 push	 1
  0003b	6a 09		 push	 9
  0003d	e8 00 00 00 00	 call	 _DwDbgSetContext
  00042	83 c4 18	 add	 esp, 24			; 00000018H
  00045	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@DNIFEHFF@CODEC?5not?5ready?$AA@
  0004a	e8 00 00 00 00	 call	 _DwDbgPrint
  0004f	83 c4 04	 add	 esp, 4

; 237  :         hr = DSERR_NODRIVER;

  00052	c7 45 f0 78 00
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005401480 ; 88780078H
$L32075:

; 238  :     }
; 239  :     
; 240  :     //
; 241  :     // Power up the CODEC
; 242  :     //
; 243  : 
; 244  :     if(SUCCEEDED(hr))

  00059	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0005d	7c 0b		 jl	 SHORT $L32083

; 245  :     {
; 246  :         hr = PowerUp();

  0005f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	e8 00 00 00 00	 call	 ?PowerUp@CAc97Device@@IAEJXZ ; CAc97Device::PowerUp
  00067	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
$L32083:

; 247  :     }
; 248  : 
; 249  :     //
; 250  :     // Reset all channels
; 251  :     //
; 252  : 
; 253  :     if(SUCCEEDED(hr))

  0006a	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006e	7c 2f		 jl	 SHORT $L32085

; 254  :     {
; 255  :         for(i = 0; i < NUMELMS(CAc97Channel::m_adwRegisterOffsets); i++)

  00070	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00077	eb 09		 jmp	 SHORT $L32086
$L32087:
  00079	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0007c	83 c2 01	 add	 edx, 1
  0007f	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L32086:
  00082	83 7d f8 02	 cmp	 DWORD PTR _i$[ebp], 2
  00086	73 17		 jae	 SHORT $L32085

; 256  :         {
; 257  :             PokeAciRegister8(CAc97Channel::m_adwRegisterOffsets[i] + X_CTRL, X_CTRL_RBMR);

  00088	6a 02		 push	 2
  0008a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0008d	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?m_adwRegisterOffsets@CAc97Channel@@2QBKB[eax*4]
  00094	83 c1 0b	 add	 ecx, 11			; 0000000bH
  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 ?PokeAciRegister8@CAc97Device@@KGXKE@Z ; CAc97Device::PokeAciRegister8

; 258  :         }

  0009d	eb da		 jmp	 SHORT $L32087
$L32085:

; 259  :     }
; 260  : 
; 261  :     //
; 262  :     // Initialize the interrupt DPC
; 263  :     //
; 264  : 
; 265  :     if(SUCCEEDED(hr) && !(m_dwFlags & AC97_OBJECTF_DIRECTISR))

  0009f	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a3	7c 23		 jl	 SHORT $L32090
  000a5	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000a8	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ab	83 e0 01	 and	 eax, 1
  000ae	85 c0		 test	 eax, eax
  000b0	75 16		 jne	 SHORT $L32090

; 266  :     {
; 267  :         KeInitializeDpc(&m_dpc, AciInterruptDpcHandler, this);

  000b2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	51		 push	 ecx
  000b6	68 00 00 00 00	 push	 OFFSET FLAT:?AciInterruptDpcHandler@CAc97Device@@CGXPAU_KDPC@@PAX11@Z ; CAc97Device::AciInterruptDpcHandler
  000bb	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000be	83 c2 1c	 add	 edx, 28			; 0000001cH
  000c1	52		 push	 edx
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeDpc@12
$L32090:

; 268  :     }
; 269  : 
; 270  :     //
; 271  :     // Set up the interrupt handler
; 272  :     //
; 273  : 
; 274  :     if(SUCCEEDED(hr))

  000c8	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000cc	7c 75		 jl	 SHORT $L32092

; 275  :     {
; 276  : 
; 277  : #ifdef AC97_AMR
; 278  : 
; 279  :         ulInterruptVector = HalGetInterruptVector(PciConfig.u.type0.InterruptLine, &Irql);
; 280  : 
; 281  : #else // AC97_AMR
; 282  : 
; 283  :         ulInterruptVector = HalGetInterruptVector(XPCICFG_ACI_IRQ, &Irql);

  000ce	8d 45 f7	 lea	 eax, DWORD PTR _Irql$[ebp]
  000d1	50		 push	 eax
  000d2	6a 06		 push	 6
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HalGetInterruptVector@8
  000da	89 45 fc	 mov	 DWORD PTR _ulInterruptVector$[ebp], eax

; 284  : 
; 285  : #endif // AC97_AMR
; 286  : 
; 287  :         KeInitializeInterrupt(&m_Interrupt, AciInterruptServiceRoutine, this, ulInterruptVector, Irql, LevelSensitive, TRUE);

  000dd	6a 01		 push	 1
  000df	6a 00		 push	 0
  000e1	8a 4d f7	 mov	 cl, BYTE PTR _Irql$[ebp]
  000e4	51		 push	 ecx
  000e5	8b 55 fc	 mov	 edx, DWORD PTR _ulInterruptVector$[ebp]
  000e8	52		 push	 edx
  000e9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ec	50		 push	 eax
  000ed	68 00 00 00 00	 push	 OFFSET FLAT:?AciInterruptServiceRoutine@CAc97Device@@CGEPAU_KINTERRUPT@@PAX@Z ; CAc97Device::AciInterruptServiceRoutine
  000f2	68 00 00 00 00	 push	 OFFSET FLAT:?m_Interrupt@CAc97Device@@1U_KINTERRUPT@@A ; CAc97Device::m_Interrupt
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeInterrupt@28

; 288  : 
; 289  :         if(!KeConnectInterrupt(&m_Interrupt))

  000fd	68 00 00 00 00	 push	 OFFSET FLAT:?m_Interrupt@CAc97Device@@1U_KINTERRUPT@@A ; CAc97Device::m_Interrupt
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeConnectInterrupt@4
  00108	0f b6 c8	 movzx	 ecx, al
  0010b	85 c9		 test	 ecx, ecx
  0010d	75 34		 jne	 SHORT $L32092

; 290  :         {
; 291  :             DPF_ERROR("Failed to connect interrupt");

  0010f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  00114	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@JOAPHODK@CAc97Device?3?3Initialize?$AA@
  00119	68 23 01 00 00	 push	 291			; 00000123H
  0011e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  00123	6a 01		 push	 1
  00125	6a 09		 push	 9
  00127	e8 00 00 00 00	 call	 _DwDbgSetContext
  0012c	83 c4 18	 add	 esp, 24			; 00000018H
  0012f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@GIKFABDJ@Failed?5to?5connect?5interrupt?$AA@
  00134	e8 00 00 00 00	 call	 _DwDbgPrint
  00139	83 c4 04	 add	 esp, 4

; 292  :             hr = DSERR_GENERIC;

  0013c	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L32092:

; 293  :         }
; 294  :     }
; 295  : 
; 296  :     //
; 297  :     // Unmute the CODEC
; 298  :     //
; 299  : 
; 300  :     if(SUCCEEDED(hr))

  00143	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00147	7c 41		 jl	 SHORT $L32097

; 301  :     {
; 302  :         if(!PokeAc97Register(AC97REG_FRONT_VOLUME, 0))

  00149	6a 00		 push	 0
  0014b	6a 01		 push	 1
  0014d	e8 00 00 00 00	 call	 ?PokeAc97Register@CAc97Device@@KGHW4AC97REGISTER@@G@Z ; CAc97Device::PokeAc97Register
  00152	85 c0		 test	 eax, eax
  00154	75 34		 jne	 SHORT $L32097

; 303  :         {
; 304  :             DPF_ERROR("Unable to set front volume");

  00156	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  0015b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@JOAPHODK@CAc97Device?3?3Initialize?$AA@
  00160	68 30 01 00 00	 push	 304			; 00000130H
  00165	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  0016a	6a 01		 push	 1
  0016c	6a 09		 push	 9
  0016e	e8 00 00 00 00	 call	 _DwDbgSetContext
  00173	83 c4 18	 add	 esp, 24			; 00000018H
  00176	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@NAGMAMBI@Unable?5to?5set?5front?5volume?$AA@
  0017b	e8 00 00 00 00	 call	 _DwDbgPrint
  00180	83 c4 04	 add	 esp, 4

; 305  :             hr = DSERR_GENERIC;

  00183	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L32097:

; 306  :         }
; 307  :     }
; 308  : 
; 309  :     if(SUCCEEDED(hr))

  0018a	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0018e	7c 44		 jl	 SHORT $L32102

; 310  :     {
; 311  :         if(!PokeAc97Register(AC97REG_PCM_OUT_VOLUME, 0x0808))

  00190	68 08 08 00 00	 push	 2056			; 00000808H
  00195	6a 0c		 push	 12			; 0000000cH
  00197	e8 00 00 00 00	 call	 ?PokeAc97Register@CAc97Device@@KGHW4AC97REGISTER@@G@Z ; CAc97Device::PokeAc97Register
  0019c	85 c0		 test	 eax, eax
  0019e	75 34		 jne	 SHORT $L32102

; 312  :         {
; 313  :             DPF_ERROR("Unable to set PCM out volume");

  001a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  001a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@JOAPHODK@CAc97Device?3?3Initialize?$AA@
  001aa	68 39 01 00 00	 push	 313			; 00000139H
  001af	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  001b4	6a 01		 push	 1
  001b6	6a 09		 push	 9
  001b8	e8 00 00 00 00	 call	 _DwDbgSetContext
  001bd	83 c4 18	 add	 esp, 24			; 00000018H
  001c0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@BOHODCI@Unable?5to?5set?5PCM?5out?5volume?$AA@
  001c5	e8 00 00 00 00	 call	 _DwDbgPrint
  001ca	83 c4 04	 add	 esp, 4

; 314  :             hr = DSERR_GENERIC;

  001cd	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L32102:

; 315  :         }
; 316  :     }
; 317  : 
; 318  :     //
; 319  :     // Register for HAL shutdown notification
; 320  :     //
; 321  : 
; 322  :     if(SUCCEEDED(hr))

  001d4	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001d8	7c 19		 jl	 SHORT $L32107

; 323  :     {
; 324  :         m_HalShutdownData.NotificationRoutine = AciShutdownNotifier;

  001da	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  001dd	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], OFFSET FLAT:?AciShutdownNotifier@CAc97Device@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z ; CAc97Device::AciShutdownNotifier

; 325  : 
; 326  :         HalRegisterShutdownNotification(&m_HalShutdownData, TRUE);

  001e4	6a 01		 push	 1
  001e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001e9	83 c0 0c	 add	 eax, 12			; 0000000cH
  001ec	50		 push	 eax
  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HalRegisterShutdownNotification@8
$L32107:

; 327  :     }
; 328  : 
; 329  :     DPF_LEAVE_HRESULT(hr);
; 330  : 
; 331  :     return hr;

  001f3	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]

; 332  : }

  001f6	8b e5		 mov	 esp, ebp
  001f8	5d		 pop	 ebp
  001f9	c2 04 00	 ret	 4
?Initialize@CAc97Device@@QAEJK@Z ENDP			; CAc97Device::Initialize
DSOUND	ENDS
PUBLIC	?PokeRegister8@CAc97Device@@KGXKE@Z		; CAc97Device::PokeRegister8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.h
;	COMDAT ?PokeAciRegister8@CAc97Device@@KGXKE@Z
DSOUND	SEGMENT
_dwRegister$ = 8
_bValue$ = 12
?PokeAciRegister8@CAc97Device@@KGXKE@Z PROC NEAR	; CAc97Device::PokeAciRegister8, COMDAT

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 266  :     PokeRegister8(m_dwAciRegisterBase + dwRegister, bValue);

  00003	8a 45 0c	 mov	 al, BYTE PTR _bValue$[ebp]
  00006	50		 push	 eax
  00007	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwAciRegisterBase@CAc97Device@@2KB ; CAc97Device::m_dwAciRegisterBase
  0000d	03 4d 08	 add	 ecx, DWORD PTR _dwRegister$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ?PokeRegister8@CAc97Device@@KGXKE@Z ; CAc97Device::PokeRegister8

; 267  : }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?PokeAciRegister8@CAc97Device@@KGXKE@Z ENDP		; CAc97Device::PokeAciRegister8
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PokeRegister8@CAc97Device@@KGXKE@Z
DSOUND	SEGMENT
_dwRegister$ = 8
_bValue$ = 12
?PokeRegister8@CAc97Device@@KGXKE@Z PROC NEAR		; CAc97Device::PokeRegister8, COMDAT

; 185  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 186  : 
; 187  : #ifdef AC97_USE_MIO
; 188  : 
; 189  :     *(LPBYTE)dwRegister = bValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00006	8a 4d 0c	 mov	 cl, BYTE PTR _bValue$[ebp]
  00009	88 08		 mov	 BYTE PTR [eax], cl

; 190  : 
; 191  : #else // AC97_USE_MIO
; 192  : 
; 193  :     _outp((WORD)dwRegister, bValue);
; 194  : 
; 195  : #endif // AC97_USE_MIO
; 196  : 
; 197  : }

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?PokeRegister8@CAc97Device@@KGXKE@Z ENDP		; CAc97Device::PokeRegister8
DSOUND	ENDS
PUBLIC	?ServiceAciInterrupt@CAc97Device@@IAEKXZ	; CAc97Device::ServiceAciInterrupt
; Function compile flags: /Odt
;	COMDAT ?AciInterruptServiceRoutine@CAc97Device@@CGEPAU_KINTERRUPT@@PAX@Z
DSOUND	SEGMENT
_pThis$ = -4
_pInterrupt$ = 8
_pvContext$ = 12
?AciInterruptServiceRoutine@CAc97Device@@CGEPAU_KINTERRUPT@@PAX@Z PROC NEAR ; CAc97Device::AciInterruptServiceRoutine, COMDAT

; 295  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 296  :     CAc97Device *           pThis   = (CAc97Device *)pvContext;

  00004	8b 45 0c	 mov	 eax, DWORD PTR _pvContext$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pThis$[ebp], eax

; 297  :     
; 298  :     return (BOOLEAN)MAKEBOOL(pThis->ServiceAciInterrupt());

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _pThis$[ebp]
  0000d	e8 00 00 00 00	 call	 ?ServiceAciInterrupt@CAc97Device@@IAEKXZ ; CAc97Device::ServiceAciInterrupt
  00012	85 c0		 test	 eax, eax
  00014	0f 95 c0	 setne	 al

; 299  : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?AciInterruptServiceRoutine@CAc97Device@@CGEPAU_KINTERRUPT@@PAX@Z ENDP ; CAc97Device::AciInterruptServiceRoutine
DSOUND	ENDS
PUBLIC	?ServiceAciInterruptDpc@CAc97Device@@IAEXXZ	; CAc97Device::ServiceAciInterruptDpc
; Function compile flags: /Odt
;	COMDAT ?AciInterruptDpcHandler@CAc97Device@@CGXPAU_KDPC@@PAX11@Z
DSOUND	SEGMENT
_pThis$ = -4
_pdpc$ = 8
_pvDeferredContext$ = 12
_pvSystemArgument1$ = 16
_pvSystemArgument2$ = 20
?AciInterruptDpcHandler@CAc97Device@@CGXPAU_KDPC@@PAX11@Z PROC NEAR ; CAc97Device::AciInterruptDpcHandler, COMDAT

; 302  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 303  :     CAc97Device *           pThis   = (CAc97Device *)pvDeferredContext;

  00004	8b 45 0c	 mov	 eax, DWORD PTR _pvDeferredContext$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pThis$[ebp], eax

; 304  :     
; 305  :     pThis->ServiceAciInterruptDpc();

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _pThis$[ebp]
  0000d	e8 00 00 00 00	 call	 ?ServiceAciInterruptDpc@CAc97Device@@IAEXXZ ; CAc97Device::ServiceAciInterruptDpc

; 306  : }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 10 00	 ret	 16			; 00000010H
?AciInterruptDpcHandler@CAc97Device@@CGXPAU_KDPC@@PAX11@Z ENDP ; CAc97Device::AciInterruptDpcHandler
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?AciShutdownNotifier@CAc97Device@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z
DSOUND	SEGMENT
_pThis$ = -4
_pHalShutdownData$ = 8
?AciShutdownNotifier@CAc97Device@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z PROC NEAR ; CAc97Device::AciShutdownNotifier, COMDAT

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 310  :     CAc97Device *           pThis   = CONTAINING_RECORD(pHalShutdownData, CAc97Device, m_HalShutdownData);

  00004	8b 45 08	 mov	 eax, DWORD PTR _pHalShutdownData$[ebp]
  00007	83 e8 0c	 sub	 eax, 12			; 0000000cH
  0000a	89 45 fc	 mov	 DWORD PTR _pThis$[ebp], eax

; 311  :     
; 312  :     pThis->Terminate();

  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _pThis$[ebp]
  00010	e8 00 00 00 00	 call	 ?Terminate@CAc97Device@@QAEXXZ ; CAc97Device::Terminate

; 313  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?AciShutdownNotifier@CAc97Device@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z ENDP ; CAc97Device::AciShutdownNotifier
DSOUND	ENDS
PUBLIC	??0CAutoIrql@@QAE@XZ				; CAutoIrql::CAutoIrql
PUBLIC	??1CAutoIrql@@QAE@XZ				; CAutoIrql::~CAutoIrql
PUBLIC	?ReleaseChannel@CAc97Device@@QAEXW4AC97CHANNELTYPE@@@Z ; CAc97Device::ReleaseChannel
EXTRN	__imp__KeRemoveQueueDpc@4:NEAR
EXTRN	__imp__KeDisconnectInterrupt@4:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.cpp
;	COMDAT ?Terminate@CAc97Device@@QAEXXZ
DSOUND	SEGMENT
_this$ = -16
___AutoIrql$ = -12
_i$ = -4
?Terminate@CAc97Device@@QAEXXZ PROC NEAR		; CAc97Device::Terminate, COMDAT
; _this$ = ecx

; 358  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 359  :     DWORD                   i;
; 360  : 
; 361  :     DPF_ENTER();
; 362  :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 363  : 
; 364  :     //
; 365  :     // Disconnect the interrupt handler
; 366  :     //
; 367  : 
; 368  :     if(m_Interrupt.ServiceRoutine)

  00011	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_Interrupt@CAc97Device@@1U_KINTERRUPT@@A, 0
  00018	74 15		 je	 SHORT $L32114

; 369  :     {
; 370  :         KeDisconnectInterrupt(&m_Interrupt);

  0001a	68 00 00 00 00	 push	 OFFSET FLAT:?m_Interrupt@CAc97Device@@1U_KINTERRUPT@@A ; CAc97Device::m_Interrupt
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeDisconnectInterrupt@4

; 371  :         m_Interrupt.ServiceRoutine = NULL;

  00025	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_Interrupt@CAc97Device@@1U_KINTERRUPT@@A, 0
$L32114:

; 372  :     }
; 373  : 
; 374  :     //
; 375  :     // Clear any pending DPCs
; 376  :     //
; 377  : 
; 378  :     if(DpcObject == m_dpc.Type)

  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00032	0f bf 48 1c	 movsx	 ecx, WORD PTR [eax+28]
  00036	83 f9 13	 cmp	 ecx, 19			; 00000013H
  00039	75 1d		 jne	 SHORT $L32115

; 379  :     {
; 380  :         KeRemoveQueueDpc(&m_dpc);

  0003b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	83 c2 1c	 add	 edx, 28			; 0000001cH
  00041	52		 push	 edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeRemoveQueueDpc@4

; 381  :         m_dpc.Type = ~m_dpc.Type;

  00048	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	0f bf 48 1c	 movsx	 ecx, WORD PTR [eax+28]
  0004f	f7 d1		 not	 ecx
  00051	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00054	66 89 4a 1c	 mov	 WORD PTR [edx+28], cx
$L32115:

; 382  :     }
; 383  : 
; 384  :     //
; 385  :     // Unregister the shutdown handler
; 386  :     //
; 387  : 
; 388  :     if(m_HalShutdownData.NotificationRoutine)

  00058	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0005f	74 19		 je	 SHORT $L32116

; 389  :     {
; 390  :         HalRegisterShutdownNotification(&m_HalShutdownData, FALSE);

  00061	6a 00		 push	 0
  00063	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00069	51		 push	 ecx
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HalRegisterShutdownNotification@8

; 391  :         m_HalShutdownData.NotificationRoutine = NULL;

  00070	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00073	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
$L32116:

; 392  :     }
; 393  : 
; 394  :     //
; 395  :     // Free all channels
; 396  :     //
; 397  : 
; 398  :     for(i = 0; i < AC97_CHANNELTYPE_COUNT; i++)

  0007a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00081	eb 09		 jmp	 SHORT $L32117
$L32118:
  00083	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00086	83 c0 01	 add	 eax, 1
  00089	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L32117:
  0008c	83 7d fc 02	 cmp	 DWORD PTR _i$[ebp], 2
  00090	73 0e		 jae	 SHORT $L32119

; 399  :     {
; 400  :         ReleaseChannel((AC97CHANNELTYPE)i);

  00092	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00095	51		 push	 ecx
  00096	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ?ReleaseChannel@CAc97Device@@QAEXW4AC97CHANNELTYPE@@@Z ; CAc97Device::ReleaseChannel

; 401  :     }

  0009e	eb e3		 jmp	 SHORT $L32118
$L32119:

; 402  : 
; 403  :     DPF_LEAVE_VOID();
; 404  : }

  000a0	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000a3	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
?Terminate@CAc97Device@@QAEXXZ ENDP			; CAc97Device::Terminate
DSOUND	ENDS
PUBLIC	??0CIrql@@QAE@XZ				; CIrql::CIrql
PUBLIC	?Raise@CIrql@@QAEXXZ				; CIrql::Raise
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\drvhlp.h
;	COMDAT ??0CAutoIrql@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CAutoIrql@@QAE@XZ PROC NEAR				; CAutoIrql::CAutoIrql, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CIrql@@QAE@XZ	; CIrql::CIrql

; 73   :     Raise();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?Raise@CIrql@@QAEXXZ	; CIrql::Raise

; 74   : }

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CAutoIrql@@QAE@XZ ENDP				; CAutoIrql::CAutoIrql
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??0CIrql@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CIrql@@QAE@XZ PROC NEAR				; CIrql::CIrql, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 39   :     m_fRaised = FALSE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 40   : }

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0CIrql@@QAE@XZ ENDP					; CIrql::CIrql
DSOUND	ENDS
EXTRN	__imp_@KfRaiseIrql@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Raise@CIrql@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Raise@CIrql@@QAEXXZ PROC NEAR				; CIrql::Raise, COMDAT
; _this$ = ecx

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 44   :     if(m_fRaised = (KeGetCurrentIrql() < DISPATCH_LEVEL))

  00007	e8 00 00 00 00	 call	 _KeGetCurrentIrql@0
  0000c	0f b6 c0	 movzx	 eax, al
  0000f	33 c9		 xor	 ecx, ecx
  00011	83 f8 02	 cmp	 eax, 2
  00014	0f 9c c1	 setl	 cl
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00024	74 0d		 je	 SHORT $L29688

; 45   :     {
; 46   :         m_irql = KfRaiseIrql(DISPATCH_LEVEL);

  00026	b1 02		 mov	 cl, 2
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfRaiseIrql@4
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	88 01		 mov	 BYTE PTR [ecx], al
$L29688:

; 47   :     }
; 48   : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?Raise@CIrql@@QAEXXZ ENDP				; CIrql::Raise
; Function compile flags: /Odt
; File c:\xbox\private\ntos\inc\i386.h
DSOUND	ENDS
;	COMDAT _KeGetCurrentIrql@0
DSOUND	SEGMENT
_KeGetCurrentIrql@0 PROC NEAR				; COMDAT

; 1496 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1497 : #if defined(_NTSYSTEM_)
; 1498 :     return KeGetPcr()->Irql;
; 1499 : #else
; 1500 :     __asm {  movzx eax, byte ptr fs:[0] KPCR.Irql }

  00003	64 0f b6 05 24
	00 00 00	 movzx	 eax, BYTE PTR fs:36

; 1501 : #endif
; 1502 : }    

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_KeGetCurrentIrql@0 ENDP
DSOUND	ENDS
PUBLIC	?Lower@CIrql@@QAEXXZ				; CIrql::Lower
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\drvhlp.h
;	COMDAT ??1CAutoIrql@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CAutoIrql@@QAE@XZ PROC NEAR				; CAutoIrql::~CAutoIrql, COMDAT
; _this$ = ecx

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   :     Lower();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Lower@CIrql@@QAEXXZ	; CIrql::Lower

; 79   : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CAutoIrql@@QAE@XZ ENDP				; CAutoIrql::~CAutoIrql
DSOUND	ENDS
EXTRN	__imp_@KfLowerIrql@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Lower@CIrql@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Lower@CIrql@@QAEXXZ PROC NEAR				; CIrql::Lower, COMDAT
; _this$ = ecx

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   :     if(m_fRaised)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 15		 je	 SHORT $L29693

; 53   :     {
; 54   :         KfLowerIrql(m_irql);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8a 09		 mov	 cl, BYTE PTR [ecx]
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfLowerIrql@4

; 55   :         m_fRaised = FALSE;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$L29693:

; 56   :     }
; 57   : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?Lower@CIrql@@QAEXXZ ENDP				; CIrql::Lower
DSOUND	ENDS
PUBLIC	??_C@_0BM@LBDLLBEL@?$CBm_apChannels?$FLnChannelType?$FN?$AA@ ; `string'
PUBLIC	??_C@_0CB@EBLNFACL@CAc97Channel?$CIthis?0?5nChannelType?$CJ@ ; `string'
PUBLIC	?CreateChannel@CAc97Device@@QAEJW4AC97CHANNELTYPE@@PAPAVCAc97Channel@@@Z ; CAc97Device::CreateChannel
PUBLIC	??0CAc97Channel@@QAE@PAVCAc97Device@@W4AC97CHANNELTYPE@@@Z ; CAc97Channel::CAc97Channel
EXTRN	_DwDbgAssert:NEAR
;	COMDAT ??_C@_0BM@LBDLLBEL@?$CBm_apChannels?$FLnChannelType?$FN?$AA@
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.cpp
DSOUND_RD	SEGMENT
??_C@_0BM@LBDLLBEL@?$CBm_apChannels?$FLnChannelType?$FN?$AA@ DB '!m_apCha'
	DB	'nnels[nChannelType]', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@EBLNFACL@CAc97Channel?$CIthis?0?5nChannelType?$CJ@
DSOUND_RD	SEGMENT
??_C@_0CB@EBLNFACL@CAc97Channel?$CIthis?0?5nChannelType?$CJ@ DB 'CAc97Cha'
	DB	'nnel(this, nChannelType)', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?CreateChannel@CAc97Device@@QAEJW4AC97CHANNELTYPE@@PAPAVCAc97Channel@@@Z
DSOUND	SEGMENT
tv87 = -28
_this$ = -24
$T32731 = -20
$T32728 = -16
___AutoIrql$ = -12
_hr$ = -4
_nChannelType$ = 8
_ppChannel$ = 12
?CreateChannel@CAc97Device@@QAEJW4AC97CHANNELTYPE@@PAPAVCAc97Channel@@@Z PROC NEAR ; CAc97Device::CreateChannel, COMDAT
; _this$ = ecx

; 436  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 437  :     HRESULT                 hr;
; 438  :     
; 439  :     DPF_ENTER();
; 440  :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 441  :     
; 442  :     ASSERT(!m_apChannels[nChannelType]);

  00011	68 ba 01 00 00	 push	 442			; 000001baH
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@LBDLLBEL@?$CBm_apChannels?$FLnChannelType?$FN?$AA@
  00020	8b 45 08	 mov	 eax, DWORD PTR _nChannelType$[ebp]
  00023	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	33 d2		 xor	 edx, edx
  00028	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  0002c	0f 95 c2	 setne	 dl
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _DwDbgAssert
  00035	83 c4 10	 add	 esp, 16			; 00000010H

; 443  : 
; 444  :     hr = HRFROMP(m_apChannels[nChannelType] = NEW(CAc97Channel(this, nChannelType)));

  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@EBLNFACL@CAc97Channel?$CIthis?0?5nChannelType?$CJ@
  0003d	68 bc 01 00 00	 push	 444			; 000001bcH
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  00047	6a 30		 push	 48			; 00000030H
  00049	e8 00 00 00 00	 call	 ??2@YAPAXIPBDK0@Z	; operator new
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	89 45 f0	 mov	 DWORD PTR $T32728[ebp], eax
  00054	83 7d f0 00	 cmp	 DWORD PTR $T32728[ebp], 0
  00058	74 15		 je	 SHORT $L32729
  0005a	8b 45 08	 mov	 eax, DWORD PTR _nChannelType$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	51		 push	 ecx
  00062	8b 4d f0	 mov	 ecx, DWORD PTR $T32728[ebp]
  00065	e8 00 00 00 00	 call	 ??0CAc97Channel@@QAE@PAVCAc97Device@@W4AC97CHANNELTYPE@@@Z ; CAc97Channel::CAc97Channel
  0006a	89 45 e4	 mov	 DWORD PTR tv87[ebp], eax
  0006d	eb 07		 jmp	 SHORT $L32730
$L32729:
  0006f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
$L32730:
  00076	8b 55 08	 mov	 edx, DWORD PTR _nChannelType$[ebp]
  00079	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	8b 4d e4	 mov	 ecx, DWORD PTR tv87[ebp]
  0007f	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  00082	33 d2		 xor	 edx, edx
  00084	83 7d e4 00	 cmp	 DWORD PTR tv87[ebp], 0
  00088	0f 95 c2	 setne	 dl
  0008b	4a		 dec	 edx
  0008c	81 e2 0e 00 07
	80		 and	 edx, -2147024882	; 8007000eH
  00092	89 55 fc	 mov	 DWORD PTR _hr$[ebp], edx

; 445  : 
; 446  :     if(SUCCEEDED(hr) && ppChannel)

  00095	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00099	7c 14		 jl	 SHORT $L32135
  0009b	83 7d 0c 00	 cmp	 DWORD PTR _ppChannel$[ebp], 0
  0009f	74 0e		 je	 SHORT $L32135

; 447  :     {
; 448  :         *ppChannel = m_apChannels[nChannelType];

  000a1	8b 45 0c	 mov	 eax, DWORD PTR _ppChannel$[ebp]
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _nChannelType$[ebp]
  000a7	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000aa	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
$L32135:

; 449  :     }
; 450  : 
; 451  :     DPF_LEAVE_HRESULT(hr);
; 452  : 
; 453  :     return hr;

  000af	8b 55 fc	 mov	 edx, DWORD PTR _hr$[ebp]
  000b2	89 55 ec	 mov	 DWORD PTR $T32731[ebp], edx
  000b5	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000b8	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  000bd	8b 45 ec	 mov	 eax, DWORD PTR $T32731[ebp]

; 454  : }

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8
?CreateChannel@CAc97Device@@QAEJW4AC97CHANNELTYPE@@PAPAVCAc97Channel@@@Z ENDP ; CAc97Device::CreateChannel
DSOUND	ENDS
EXTRN	_DirectSoundTestTrackingMemAlloc@24:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\memmgr.h
;	COMDAT ??2@YAPAXIPBDK0@Z
DSOUND	SEGMENT
_cbBuffer$ = 8
_pszFile$ = 12
_nLine$ = 16
_pszClass$ = 20
??2@YAPAXIPBDK0@Z PROC NEAR				; operator new, COMDAT

; 168  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 169  :     return DirectSoundTestTrackingMemAlloc(pszFile, nLine, pszClass, DSOUND_OBJECT_POOL_TAG, cbBuffer, TRUE); 

  00003	6a 01		 push	 1
  00005	8b 45 08	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  00008	50		 push	 eax
  00009	68 44 53 6f 62	 push	 1651462980		; 626f5344H
  0000e	8b 4d 14	 mov	 ecx, DWORD PTR _pszClass$[ebp]
  00011	51		 push	 ecx
  00012	8b 55 10	 mov	 edx, DWORD PTR _nLine$[ebp]
  00015	52		 push	 edx
  00016	8b 45 0c	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _DirectSoundTestTrackingMemAlloc@24

; 170  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??2@YAPAXIPBDK0@Z ENDP					; operator new
DSOUND	ENDS
PUBLIC	??_GCAc97Channel@@QAEPAXI@Z			; CAc97Channel::`scalar deleting destructor'
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.cpp
;	COMDAT ?ReleaseChannel@CAc97Device@@QAEXW4AC97CHANNELTYPE@@@Z
DSOUND	SEGMENT
tv76 = -24
_this$ = -20
$T32739 = -16
$T32738 = -12
___AutoIrql$ = -8
_Channel$ = 8
?ReleaseChannel@CAc97Device@@QAEXW4AC97CHANNELTYPE@@@Z PROC NEAR ; CAc97Device::ReleaseChannel, COMDAT
; _this$ = ecx

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 481  :     DPF_ENTER();
; 482  :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 483  :     
; 484  :     DELETE(m_apChannels[Channel]);

  00011	8b 45 08	 mov	 eax, DWORD PTR _Channel$[ebp]
  00014	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  0001b	74 3b		 je	 SHORT $L32142
  0001d	8b 55 08	 mov	 edx, DWORD PTR _Channel$[ebp]
  00020	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00026	89 4d f0	 mov	 DWORD PTR $T32739[ebp], ecx
  00029	8b 55 f0	 mov	 edx, DWORD PTR $T32739[ebp]
  0002c	89 55 f4	 mov	 DWORD PTR $T32738[ebp], edx
  0002f	83 7d f4 00	 cmp	 DWORD PTR $T32738[ebp], 0
  00033	74 0f		 je	 SHORT $L32740
  00035	6a 01		 push	 1
  00037	8b 4d f4	 mov	 ecx, DWORD PTR $T32738[ebp]
  0003a	e8 00 00 00 00	 call	 ??_GCAc97Channel@@QAEPAXI@Z
  0003f	89 45 e8	 mov	 DWORD PTR tv76[ebp], eax
  00042	eb 07		 jmp	 SHORT $L32741
$L32740:
  00044	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$L32741:
  0004b	8b 45 08	 mov	 eax, DWORD PTR _Channel$[ebp]
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0
$L32142:

; 485  : 
; 486  :     DPF_LEAVE_VOID();
; 487  : }

  00058	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0005b	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?ReleaseChannel@CAc97Device@@QAEXW4AC97CHANNELTYPE@@@Z ENDP ; CAc97Device::ReleaseChannel
DSOUND	ENDS
PUBLIC	??1CAc97Channel@@QAE@XZ				; CAc97Channel::~CAc97Channel
; Function compile flags: /Odt
;	COMDAT ??_GCAc97Channel@@QAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCAc97Channel@@QAEPAXI@Z PROC NEAR			; CAc97Channel::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CAc97Channel@@QAE@XZ	; CAc97Channel::~CAc97Channel
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L32148
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L32148:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCAc97Channel@@QAEPAXI@Z ENDP			; CAc97Channel::`scalar deleting destructor'
DSOUND	ENDS
EXTRN	_DirectSoundTestTrackingMemFree@4:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\memmgr.h
;	COMDAT ??3@YAXPAX@Z
DSOUND	SEGMENT
_pvBuffer$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 180  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 181  :     DirectSoundTestTrackingMemFree(pvBuffer); 

  00003	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _DirectSoundTestTrackingMemFree@4

; 182  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
DSOUND	ENDS
PUBLIC	??_C@_0CD@OAIDILGI@CAc97Device?3?3AcquireCodecSemapho@ ; `string'
PUBLIC	??_C@_0BO@PEFIIICE@Failed?5to?5get?5CODEC?5semaphore?$AA@ ; `string'
PUBLIC	?AcquireCodecSemaphore@CAc97Device@@KGHXZ	; CAc97Device::AcquireCodecSemaphore
PUBLIC	?PeekAciRegister8@CAc97Device@@KGEK@Z		; CAc97Device::PeekAciRegister8
PUBLIC	?WaitRegisterRetry@CAc97Device@@KGXXZ		; CAc97Device::WaitRegisterRetry
;	COMDAT ??_C@_0CD@OAIDILGI@CAc97Device?3?3AcquireCodecSemapho@
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.cpp
DSOUND_RD	SEGMENT
??_C@_0CD@OAIDILGI@CAc97Device?3?3AcquireCodecSemapho@ DB 'CAc97Device::A'
	DB	'cquireCodecSemaphore', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@PEFIIICE@Failed?5to?5get?5CODEC?5semaphore?$AA@
DSOUND_RD	SEGMENT
??_C@_0BO@PEFIIICE@Failed?5to?5get?5CODEC?5semaphore?$AA@ DB 'Failed to g'
	DB	'et CODEC semaphore', 00H			; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?AcquireCodecSemaphore@CAc97Device@@KGHXZ
DSOUND	SEGMENT
_fAcquired$ = -8
_dwAttempts$ = -4
?AcquireCodecSemaphore@CAc97Device@@KGHXZ PROC NEAR	; CAc97Device::AcquireCodecSemaphore, COMDAT

; 513  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 514  :     DWORD                   dwAttempts  = 1000;

  00006	c7 45 fc e8 03
	00 00		 mov	 DWORD PTR _dwAttempts$[ebp], 1000 ; 000003e8H

; 515  :     BOOL                    fAcquired   = TRUE;

  0000d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fAcquired$[ebp], 1
$L32155:

; 516  : 
; 517  :     DPF_ENTER();
; 518  : 
; 519  :     while(PeekAciRegister8(AC97_SEM4) & AC97_SEM4_OWNED)

  00014	6a 34		 push	 52			; 00000034H
  00016	e8 00 00 00 00	 call	 ?PeekAciRegister8@CAc97Device@@KGEK@Z ; CAc97Device::PeekAciRegister8
  0001b	0f b6 c0	 movzx	 eax, al
  0001e	83 e0 01	 and	 eax, 1
  00021	85 c0		 test	 eax, eax
  00023	74 4d		 je	 SHORT $L32156

; 520  :     {
; 521  :         if(!dwAttempts--)

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _dwAttempts$[ebp]
  00028	8b 55 fc	 mov	 edx, DWORD PTR _dwAttempts$[ebp]
  0002b	83 ea 01	 sub	 edx, 1
  0002e	89 55 fc	 mov	 DWORD PTR _dwAttempts$[ebp], edx
  00031	85 c9		 test	 ecx, ecx
  00033	75 36		 jne	 SHORT $L32157

; 522  :         {
; 523  :             DPF_ERROR("Failed to get CODEC semaphore");

  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@OAIDILGI@CAc97Device?3?3AcquireCodecSemapho@
  0003f	68 0b 02 00 00	 push	 523			; 0000020bH
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  00049	6a 01		 push	 1
  0004b	6a 09		 push	 9
  0004d	e8 00 00 00 00	 call	 _DwDbgSetContext
  00052	83 c4 18	 add	 esp, 24			; 00000018H
  00055	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@PEFIIICE@Failed?5to?5get?5CODEC?5semaphore?$AA@
  0005a	e8 00 00 00 00	 call	 _DwDbgPrint
  0005f	83 c4 04	 add	 esp, 4

; 524  :             fAcquired = FALSE;

  00062	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fAcquired$[ebp], 0

; 525  :             break;

  00069	eb 07		 jmp	 SHORT $L32156
$L32157:

; 526  :         }
; 527  : 
; 528  :         WaitRegisterRetry();

  0006b	e8 00 00 00 00	 call	 ?WaitRegisterRetry@CAc97Device@@KGXXZ ; CAc97Device::WaitRegisterRetry

; 529  :     }

  00070	eb a2		 jmp	 SHORT $L32155
$L32156:

; 530  : 
; 531  :     DPF_LEAVE(fAcquired);
; 532  : 
; 533  :     return fAcquired;

  00072	8b 45 f8	 mov	 eax, DWORD PTR _fAcquired$[ebp]

; 534  : }

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?AcquireCodecSemaphore@CAc97Device@@KGHXZ ENDP		; CAc97Device::AcquireCodecSemaphore
DSOUND	ENDS
PUBLIC	?PeekRegister8@CAc97Device@@KGEK@Z		; CAc97Device::PeekRegister8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.h
;	COMDAT ?PeekAciRegister8@CAc97Device@@KGEK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
?PeekAciRegister8@CAc97Device@@KGEK@Z PROC NEAR		; CAc97Device::PeekAciRegister8, COMDAT

; 260  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 261  :     return PeekRegister8(m_dwAciRegisterBase + dwRegister);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwAciRegisterBase@CAc97Device@@2KB ; CAc97Device::m_dwAciRegisterBase
  00008	03 45 08	 add	 eax, DWORD PTR _dwRegister$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PeekRegister8@CAc97Device@@KGEK@Z ; CAc97Device::PeekRegister8

; 262  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?PeekAciRegister8@CAc97Device@@KGEK@Z ENDP		; CAc97Device::PeekAciRegister8
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PeekRegister8@CAc97Device@@KGEK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
?PeekRegister8@CAc97Device@@KGEK@Z PROC NEAR		; CAc97Device::PeekRegister8, COMDAT

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 171  : 
; 172  : #ifdef AC97_USE_MIO
; 173  : 
; 174  :     return *(LPBYTE)dwRegister;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00006	8a 00		 mov	 al, BYTE PTR [eax]

; 175  : 
; 176  : #else // AC97_USE_MIO
; 177  : 
; 178  :     return (BYTE)_inp((WORD)dwRegister);
; 179  : 
; 180  : #endif // AC97_USE_MIO
; 181  : 
; 182  : }    

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?PeekRegister8@CAc97Device@@KGEK@Z ENDP			; CAc97Device::PeekRegister8
DSOUND	ENDS
EXTRN	__imp__KeStallExecutionProcessor@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?WaitRegisterRetry@CAc97Device@@KGXXZ
DSOUND	SEGMENT
?WaitRegisterRetry@CAc97Device@@KGXXZ PROC NEAR		; CAc97Device::WaitRegisterRetry, COMDAT

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 291  :     KeStallExecutionProcessor(20);

  00003	6a 14		 push	 20			; 00000014H
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeStallExecutionProcessor@4

; 292  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?WaitRegisterRetry@CAc97Device@@KGXXZ ENDP		; CAc97Device::WaitRegisterRetry
DSOUND	ENDS
PUBLIC	??_C@_0BI@MMMJCIJG@CAc97Device?3?3CodecReady?$AA@ ; `string'
PUBLIC	??_C@_0CA@EBHBCGLE@Timed?5out?5waiting?5for?5ready?5bit?$AA@ ; `string'
PUBLIC	?PeekAciRegister32@CAc97Device@@KGKK@Z		; CAc97Device::PeekAciRegister32
PUBLIC	?PokeAciRegister32@CAc97Device@@KGXKK@Z		; CAc97Device::PokeAciRegister32
;	COMDAT ??_C@_0BI@MMMJCIJG@CAc97Device?3?3CodecReady?$AA@
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.cpp
DSOUND_RD	SEGMENT
??_C@_0BI@MMMJCIJG@CAc97Device?3?3CodecReady?$AA@ DB 'CAc97Device::CodecR'
	DB	'eady', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@EBHBCGLE@Timed?5out?5waiting?5for?5ready?5bit?$AA@
DSOUND_RD	SEGMENT
??_C@_0CA@EBHBCGLE@Timed?5out?5waiting?5for?5ready?5bit?$AA@ DB 'Timed ou'
	DB	't waiting for ready bit', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?CodecReady@CAc97Device@@IAEHXZ
DSOUND	SEGMENT
_this$ = -16
_fReady$ = -12
_dwValue$ = -8
_dwAttempts$ = -4
?CodecReady@CAc97Device@@IAEHXZ PROC NEAR		; CAc97Device::CodecReady, COMDAT
; _this$ = ecx

; 560  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 561  :     BOOL                    fReady      = TRUE;

  00009	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _fReady$[ebp], 1

; 562  :     DWORD                   dwAttempts  = 1000;

  00010	c7 45 fc e8 03
	00 00		 mov	 DWORD PTR _dwAttempts$[ebp], 1000 ; 000003e8H

; 563  :     DWORD                   dwValue;
; 564  :     
; 565  :     DPF_ENTER();
; 566  : 
; 567  :     //
; 568  :     // Get the value of the control register.
; 569  :     //
; 570  : 
; 571  :     dwValue = PeekAciRegister32(GLB_CTRL);

  00017	6a 2c		 push	 44			; 0000002cH
  00019	e8 00 00 00 00	 call	 ?PeekAciRegister32@CAc97Device@@KGKK@Z ; CAc97Device::PeekAciRegister32
  0001e	89 45 f8	 mov	 DWORD PTR _dwValue$[ebp], eax

; 572  :     
; 573  :     //
; 574  :     // If the AC_RST# line is low, raise it and do a cold reset.
; 575  :     //
; 576  : 
; 577  :     if(!(dwValue & GLB_CTRL_COLD))

  00021	8b 45 f8	 mov	 eax, DWORD PTR _dwValue$[ebp]
  00024	83 e0 02	 and	 eax, 2
  00027	85 c0		 test	 eax, eax
  00029	75 14		 jne	 SHORT $L32167

; 578  :     {
; 579  :         DPF_AC97("Performing cold reset");
; 580  :         
; 581  :         dwValue |= GLB_CTRL_COLD;

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _dwValue$[ebp]
  0002e	83 c9 02	 or	 ecx, 2
  00031	89 4d f8	 mov	 DWORD PTR _dwValue$[ebp], ecx

; 582  : 
; 583  :         PokeAciRegister32(GLB_CTRL, dwValue);

  00034	8b 55 f8	 mov	 edx, DWORD PTR _dwValue$[ebp]
  00037	52		 push	 edx
  00038	6a 2c		 push	 44			; 0000002cH
  0003a	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Device@@KGXKK@Z ; CAc97Device::PokeAciRegister32
$L32167:

; 584  :     }
; 585  : 
; 586  :     //
; 587  :     // If the AC link is down, raise it and do a warm reset.  This is only
; 588  :     // needed if agressive power management is used.
; 589  :     //
; 590  : 
; 591  :     if(dwValue & GLB_CTRL_ACSD)

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _dwValue$[ebp]
  00042	83 e0 08	 and	 eax, 8
  00045	85 c0		 test	 eax, eax
  00047	74 14		 je	 SHORT $L32170

; 592  :     {
; 593  :         DPF_AC97("Performing warm reset");
; 594  :         
; 595  :         dwValue &= ~(GLB_CTRL_ACSD | GLB_CTRL_WARM);

  00049	8b 4d f8	 mov	 ecx, DWORD PTR _dwValue$[ebp]
  0004c	83 e1 f3	 and	 ecx, -13		; fffffff3H
  0004f	89 4d f8	 mov	 DWORD PTR _dwValue$[ebp], ecx

; 596  : 
; 597  :         PokeAciRegister32(GLB_CTRL, dwValue);

  00052	8b 55 f8	 mov	 edx, DWORD PTR _dwValue$[ebp]
  00055	52		 push	 edx
  00056	6a 2c		 push	 44			; 0000002cH
  00058	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Device@@KGXKK@Z ; CAc97Device::PokeAciRegister32
$L32170:

; 598  :     }
; 599  : 
; 600  :     //
; 601  :     // Check to see if the ready bit is set.  This takes a maximum of 200us.
; 602  :     //
; 603  : 
; 604  :     while(!(PeekAciRegister32(GLB_STATUS) & GLB_STATUS_PCR))

  0005d	6a 30		 push	 48			; 00000030H
  0005f	e8 00 00 00 00	 call	 ?PeekAciRegister32@CAc97Device@@KGKK@Z ; CAc97Device::PeekAciRegister32
  00064	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00069	85 c0		 test	 eax, eax
  0006b	75 4d		 jne	 SHORT $L32175

; 605  :     {
; 606  :         if(!dwAttempts--)

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _dwAttempts$[ebp]
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _dwAttempts$[ebp]
  00073	83 e9 01	 sub	 ecx, 1
  00076	89 4d fc	 mov	 DWORD PTR _dwAttempts$[ebp], ecx
  00079	85 c0		 test	 eax, eax
  0007b	75 36		 jne	 SHORT $L32172

; 607  :         {
; 608  :             DPF_ERROR("Timed out waiting for ready bit");

  0007d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  00082	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@MMMJCIJG@CAc97Device?3?3CodecReady?$AA@
  00087	68 60 02 00 00	 push	 608			; 00000260H
  0008c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  00091	6a 01		 push	 1
  00093	6a 09		 push	 9
  00095	e8 00 00 00 00	 call	 _DwDbgSetContext
  0009a	83 c4 18	 add	 esp, 24			; 00000018H
  0009d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@EBHBCGLE@Timed?5out?5waiting?5for?5ready?5bit?$AA@
  000a2	e8 00 00 00 00	 call	 _DwDbgPrint
  000a7	83 c4 04	 add	 esp, 4

; 609  :             fReady = FALSE;

  000aa	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fReady$[ebp], 0

; 610  :             break;

  000b1	eb 07		 jmp	 SHORT $L32175
$L32172:

; 611  :         }
; 612  : 
; 613  :         WaitRegisterRetry();

  000b3	e8 00 00 00 00	 call	 ?WaitRegisterRetry@CAc97Device@@KGXXZ ; CAc97Device::WaitRegisterRetry

; 614  :     }

  000b8	eb a3		 jmp	 SHORT $L32170
$L32175:

; 615  : 
; 616  :     if(fReady)
; 617  :     {
; 618  :         DPF_AC97("CODEC ready");
; 619  :     }
; 620  : 
; 621  :     DPF_LEAVE(fReady);
; 622  : 
; 623  :     return fReady;

  000ba	8b 45 f4	 mov	 eax, DWORD PTR _fReady$[ebp]

; 624  : }

  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
?CodecReady@CAc97Device@@IAEHXZ ENDP			; CAc97Device::CodecReady
DSOUND	ENDS
PUBLIC	?PeekRegister32@CAc97Device@@KGKK@Z		; CAc97Device::PeekRegister32
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.h
;	COMDAT ?PeekAciRegister32@CAc97Device@@KGKK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
?PeekAciRegister32@CAc97Device@@KGKK@Z PROC NEAR	; CAc97Device::PeekAciRegister32, COMDAT

; 280  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  :     return PeekRegister32(m_dwAciRegisterBase + dwRegister);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwAciRegisterBase@CAc97Device@@2KB ; CAc97Device::m_dwAciRegisterBase
  00008	03 45 08	 add	 eax, DWORD PTR _dwRegister$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PeekRegister32@CAc97Device@@KGKK@Z ; CAc97Device::PeekRegister32

; 282  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?PeekAciRegister32@CAc97Device@@KGKK@Z ENDP		; CAc97Device::PeekAciRegister32
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PeekRegister32@CAc97Device@@KGKK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
?PeekRegister32@CAc97Device@@KGKK@Z PROC NEAR		; CAc97Device::PeekRegister32, COMDAT

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 231  : 
; 232  : #ifdef AC97_USE_MIO
; 233  : 
; 234  :     return *(LPDWORD)dwRegister;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 235  : 
; 236  : #else // AC97_USE_MIO
; 237  : 
; 238  :     return _inpd((WORD)dwRegister);
; 239  : 
; 240  : #endif // AC97_USE_MIO
; 241  : 
; 242  : }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?PeekRegister32@CAc97Device@@KGKK@Z ENDP		; CAc97Device::PeekRegister32
DSOUND	ENDS
PUBLIC	?PokeRegister32@CAc97Device@@KGXKK@Z		; CAc97Device::PokeRegister32
; Function compile flags: /Odt
;	COMDAT ?PokeAciRegister32@CAc97Device@@KGXKK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
_dwValue$ = 12
?PokeAciRegister32@CAc97Device@@KGXKK@Z PROC NEAR	; CAc97Device::PokeAciRegister32, COMDAT

; 285  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 286  :     PokeRegister32(m_dwAciRegisterBase + dwRegister, dwValue);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _dwValue$[ebp]
  00006	50		 push	 eax
  00007	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwAciRegisterBase@CAc97Device@@2KB ; CAc97Device::m_dwAciRegisterBase
  0000d	03 4d 08	 add	 ecx, DWORD PTR _dwRegister$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ?PokeRegister32@CAc97Device@@KGXKK@Z ; CAc97Device::PokeRegister32

; 287  : }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?PokeAciRegister32@CAc97Device@@KGXKK@Z ENDP		; CAc97Device::PokeAciRegister32
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PokeRegister32@CAc97Device@@KGXKK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
_dwValue$ = 12
?PokeRegister32@CAc97Device@@KGXKK@Z PROC NEAR		; CAc97Device::PokeRegister32, COMDAT

; 245  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 246  : 
; 247  : #ifdef AC97_USE_MIO
; 248  : 
; 249  :     *(LPDWORD)dwRegister = dwValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _dwValue$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 250  : 
; 251  : #else // AC97_USE_MIO
; 252  : 
; 253  :     _outpd((WORD)dwRegister, dwValue);
; 254  : 
; 255  : #endif // AC97_USE_MIO
; 256  : 
; 257  : }

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?PokeRegister32@CAc97Device@@KGXKK@Z ENDP		; CAc97Device::PokeRegister32
DSOUND	ENDS
PUBLIC	?GetInterruptStatus@CAc97Device@@IAEKXZ		; CAc97Device::GetInterruptStatus
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.cpp
;	COMDAT ?GetInterruptStatus@CAc97Device@@IAEKXZ
DSOUND	SEGMENT
_this$ = -4
?GetInterruptStatus@CAc97Device@@IAEKXZ PROC NEAR	; CAc97Device::GetInterruptStatus, COMDAT
; _this$ = ecx

; 650  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 651  :     static const DWORD      dwStatusMask    = GLB_STATUS_AOINT | GLB_STATUS_SOINT | GLB_STATUS_GPINT;
; 652  : 
; 653  :     return PeekAciRegister32(GLB_STATUS) & dwStatusMask;

  00007	6a 30		 push	 48			; 00000030H
  00009	e8 00 00 00 00	 call	 ?PeekAciRegister32@CAc97Device@@KGKK@Z ; CAc97Device::PeekAciRegister32
  0000e	83 e0 51	 and	 eax, 81			; 00000051H

; 654  : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?GetInterruptStatus@CAc97Device@@IAEKXZ ENDP		; CAc97Device::GetInterruptStatus
DSOUND	ENDS
PUBLIC	??_C@_0CB@DMKKGDEM@CAc97Device?3?3ServiceAciInterrupt@ ; `string'
PUBLIC	??_C@_0BL@HDJNMBLD@Channel?5?$CFlu?5not?5allocated?$CB?$AA@ ; `string'
PUBLIC	?ServiceInterrupt@CAc97Channel@@IAEXXZ		; CAc97Channel::ServiceInterrupt
PUBLIC	?PeekAciRegister16@CAc97Channel@@IAEGK@Z	; CAc97Channel::PeekAciRegister16
PUBLIC	?PokeAciRegister16@CAc97Channel@@IAEXKG@Z	; CAc97Channel::PokeAciRegister16
EXTRN	__imp__KeInsertQueueDpc@12:NEAR
;	COMDAT ?adwChannelStatusMasks@?1??ServiceAciInterrupt@CAc97Device@@IAEKXZ@4QBKB
DSOUND_RD	SEGMENT
?adwChannelStatusMasks@?1??ServiceAciInterrupt@CAc97Device@@IAEKXZ@4QBKB DD 040H ; `CAc97Device::ServiceAciInterrupt'::`2'::adwChannelStatusMasks
	DD	010H
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@DMKKGDEM@CAc97Device?3?3ServiceAciInterrupt@
DSOUND_RD	SEGMENT
??_C@_0CB@DMKKGDEM@CAc97Device?3?3ServiceAciInterrupt@ DB 'CAc97Device::S'
	DB	'erviceAciInterrupt', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@HDJNMBLD@Channel?5?$CFlu?5not?5allocated?$CB?$AA@
DSOUND_RD	SEGMENT
??_C@_0BL@HDJNMBLD@Channel?5?$CFlu?5not?5allocated?$CB?$AA@ DB 'Channel %'
	DB	'lu not allocated!', 00H			; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?ServiceAciInterrupt@CAc97Device@@IAEKXZ
DSOUND	SEGMENT
_this$ = -20
_dwStatus$ = -16
_wChannelStatus$ = -12
_dwInterruptMask$ = -8
_i$ = -4
?ServiceAciInterrupt@CAc97Device@@IAEKXZ PROC NEAR	; CAc97Device::ServiceAciInterrupt, COMDAT
; _this$ = ecx

; 680  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 681  :     static const DWORD      adwChannelStatusMasks[AC97_CHANNELTYPE_COUNT] = 
; 682  :     { 
; 683  :         GLB_STATUS_AOINT, 
; 684  :         GLB_STATUS_SOINT,
; 685  :     };
; 686  : 
; 687  :     DWORD                   dwInterruptMask;
; 688  :     DWORD                   dwStatus;
; 689  :     WORD                    wChannelStatus;
; 690  :     DWORD                   i;
; 691  : 
; 692  :     DPF_ENTER();
; 693  : 
; 694  :     //
; 695  :     // Get the ACI interrupt status bits
; 696  :     //
; 697  : 
; 698  :     if(dwStatus = GetInterruptStatus())

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetInterruptStatus@CAc97Device@@IAEKXZ ; CAc97Device::GetInterruptStatus
  00011	89 45 f0	 mov	 DWORD PTR _dwStatus$[ebp], eax
  00014	83 7d f0 00	 cmp	 DWORD PTR _dwStatus$[ebp], 0
  00018	0f 84 2e 01 00
	00		 je	 $L32192

; 699  :     {
; 700  :         //
; 701  :         // Set the interrupt mask to a non-zero value that won't conflict
; 702  :         // with any of the channel-specific values.
; 703  :         //
; 704  :         
; 705  :         dwInterruptMask = 0x80000000;

  0001e	c7 45 f8 00 00
	00 80		 mov	 DWORD PTR _dwInterruptMask$[ebp], -2147483648 ; 80000000H

; 706  : 
; 707  :         //
; 708  :         // Handle channel interrupts
; 709  :         //
; 710  :         
; 711  :         for(i = 0; i < AC97_CHANNELTYPE_COUNT; i++)

  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002c	eb 09		 jmp	 SHORT $L32193
$L32194:
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00031	83 c0 01	 add	 eax, 1
  00034	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L32193:
  00037	83 7d fc 02	 cmp	 DWORD PTR _i$[ebp], 2
  0003b	0f 83 d3 00 00
	00		 jae	 $L32195

; 712  :         {
; 713  :             if(dwStatus & adwChannelStatusMasks[i])

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00044	8b 55 f0	 mov	 edx, DWORD PTR _dwStatus$[ebp]
  00047	23 14 8d 00 00
	00 00		 and	 edx, DWORD PTR ?adwChannelStatusMasks@?1??ServiceAciInterrupt@CAc97Device@@IAEKXZ@4QBKB[ecx*4]
  0004e	85 d2		 test	 edx, edx
  00050	0f 84 b9 00 00
	00		 je	 $L32196

; 714  :             {
; 715  :                 if(m_apChannels[i])

  00056	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00060	74 7c		 je	 SHORT $L32197

; 716  :                 {
; 717  :                     //
; 718  :                     // Ok, this channel had an interrupt.  The only ones we
; 719  :                     // really care about are buffer completion interrupts.
; 720  :                     // If either of those are set in the channel status 
; 721  :                     // registers, increment the channel's count of pending
; 722  :                     // completions and schedule a DPC to handle them.
; 723  :                     //
; 724  : 
; 725  :                     wChannelStatus = m_apChannels[i]->PeekAciRegister16(X_STATUS);

  00062	6a 06		 push	 6
  00064	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  0006d	e8 00 00 00 00	 call	 ?PeekAciRegister16@CAc97Channel@@IAEGK@Z ; CAc97Channel::PeekAciRegister16
  00072	66 89 45 f4	 mov	 WORD PTR _wChannelStatus$[ebp], ax

; 726  : 
; 727  :                     if(wChannelStatus & X_STATUS_FIFOE) 
; 728  :                     {
; 729  :                         DPF_AC97("(channel %lu) FIFO underrun", i);
; 730  :                     }
; 731  : 
; 732  :                     if(wChannelStatus & X_STATUS_CIELV)
; 733  :                     {
; 734  :                         DPF_AC97("(channel %lu) Current index equals last valid", i);
; 735  :                     }
; 736  : 
; 737  :                     if(wChannelStatus & X_STATUS_LVBCI)
; 738  :                     {
; 739  :                         DPF_AC97("(channel %lu) Last valid buffer completion interrupt", i);
; 740  :                     }
; 741  :                 
; 742  :                     if(wChannelStatus & X_STATUS_BCI)

  00076	0f b7 4d f4	 movzx	 ecx, WORD PTR _wChannelStatus$[ebp]
  0007a	83 e1 08	 and	 ecx, 8
  0007d	85 c9		 test	 ecx, ecx
  0007f	74 46		 je	 SHORT $L32201

; 743  :                     {
; 744  :                         DPF_AC97("(channel %lu) Buffer completed", i);
; 745  : 
; 746  :                         dwInterruptMask |= AC97_CHANNELINTERRUPT(i);

  00081	ba 01 00 00 00	 mov	 edx, 1
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00089	d3 e2		 shl	 edx, cl
  0008b	8b 45 f8	 mov	 eax, DWORD PTR _dwInterruptMask$[ebp]
  0008e	0b c2		 or	 eax, edx
  00090	89 45 f8	 mov	 DWORD PTR _dwInterruptMask$[ebp], eax

; 747  : 
; 748  :                         if(m_dwFlags & AC97_OBJECTF_DIRECTISR)

  00093	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00099	83 e2 01	 and	 edx, 1
  0009c	85 d2		 test	 edx, edx
  0009e	74 10		 je	 SHORT $L32202

; 749  :                         {
; 750  :                             m_apChannels[i]->ServiceInterrupt();

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000a3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  000a9	e8 00 00 00 00	 call	 ?ServiceInterrupt@CAc97Channel@@IAEXXZ ; CAc97Channel::ServiceInterrupt

; 751  :                         }
; 752  :                         else

  000ae	eb 17		 jmp	 SHORT $L32201
$L32202:

; 753  :                         {
; 754  :                             m_abPendingBufferCompletions[i][0]++;

  000b0	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000b3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	8a 4c 50 38	 mov	 cl, BYTE PTR [eax+edx*2+56]
  000ba	80 c1 01	 add	 cl, 1
  000bd	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000c0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	88 4c 50 38	 mov	 BYTE PTR [eax+edx*2+56], cl
$L32201:

; 755  :                         }
; 756  :                     }
; 757  : 
; 758  :                     m_apChannels[i]->PokeAciRegister16(X_STATUS, wChannelStatus);

  000c7	66 8b 4d f4	 mov	 cx, WORD PTR _wChannelStatus$[ebp]
  000cb	51		 push	 ecx
  000cc	6a 06		 push	 6
  000ce	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  000d7	e8 00 00 00 00	 call	 ?PokeAciRegister16@CAc97Channel@@IAEXKG@Z ; CAc97Channel::PokeAciRegister16

; 759  :                 }
; 760  :                 else

  000dc	eb 31		 jmp	 SHORT $L32196
$L32197:

; 761  :                 {
; 762  :                     DPF_WARNING("Channel %lu not allocated!", i);

  000de	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  000e3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@DMKKGDEM@CAc97Device?3?3ServiceAciInterrupt@
  000e8	68 fa 02 00 00	 push	 762			; 000002faH
  000ed	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  000f2	6a 03		 push	 3
  000f4	6a 09		 push	 9
  000f6	e8 00 00 00 00	 call	 _DwDbgSetContext
  000fb	83 c4 18	 add	 esp, 24			; 00000018H
  000fe	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00101	51		 push	 ecx
  00102	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@HDJNMBLD@Channel?5?$CFlu?5not?5allocated?$CB?$AA@
  00107	e8 00 00 00 00	 call	 _DwDbgPrint
  0010c	83 c4 08	 add	 esp, 8
$L32196:

; 763  :                 }
; 764  :             }
; 765  :         }

  0010f	e9 1a ff ff ff	 jmp	 $L32194
$L32195:

; 766  :     
; 767  :         //
; 768  :         // Schedule a DPC to handle any buffer completion interrupts
; 769  :         //
; 770  : 
; 771  :         if(!(m_dwFlags & AC97_OBJECTF_DIRECTISR) && (dwInterruptMask & AC97_CHANNELINTERRUPT_MASK))

  00114	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00117	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0011a	83 e0 01	 and	 eax, 1
  0011d	85 c0		 test	 eax, eax
  0011f	75 1b		 jne	 SHORT $L32207
  00121	8b 4d f8	 mov	 ecx, DWORD PTR _dwInterruptMask$[ebp]
  00124	83 e1 03	 and	 ecx, 3
  00127	85 c9		 test	 ecx, ecx
  00129	74 11		 je	 SHORT $L32207

; 772  :         {
; 773  :             KeInsertQueueDpc(&m_dpc, NULL, NULL);

  0012b	6a 00		 push	 0
  0012d	6a 00		 push	 0
  0012f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00132	83 c2 1c	 add	 edx, 28			; 0000001cH
  00135	52		 push	 edx
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInsertQueueDpc@12
$L32207:

; 774  :         }
; 775  : 
; 776  :         //
; 777  :         // Acknowlege the interrupt
; 778  :         //
; 779  :         
; 780  :         PokeAciRegister32(GLB_STATUS, dwStatus & ~GLB_STATUS_GPINT);

  0013c	8b 45 f0	 mov	 eax, DWORD PTR _dwStatus$[ebp]
  0013f	83 e0 fe	 and	 eax, -2			; fffffffeH
  00142	50		 push	 eax
  00143	6a 30		 push	 48			; 00000030H
  00145	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Device@@KGXKK@Z ; CAc97Device::PokeAciRegister32

; 781  :     }
; 782  :     else

  0014a	eb 07		 jmp	 SHORT $L32208
$L32192:

; 783  :     {
; 784  :         //
; 785  :         // Not our interrupt
; 786  :         //
; 787  : 
; 788  :         dwInterruptMask = 0;

  0014c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwInterruptMask$[ebp], 0
$L32208:

; 789  :     }
; 790  : 
; 791  :     DPF_LEAVE(dwInterruptMask);
; 792  : 
; 793  :     return dwInterruptMask;

  00153	8b 45 f8	 mov	 eax, DWORD PTR _dwInterruptMask$[ebp]

; 794  : }

  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c3		 ret	 0
?ServiceAciInterrupt@CAc97Device@@IAEKXZ ENDP		; CAc97Device::ServiceAciInterrupt
DSOUND	ENDS
PUBLIC	?PeekAciRegister16@CAc97Device@@KGGK@Z		; CAc97Device::PeekAciRegister16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.h
;	COMDAT ?PeekAciRegister16@CAc97Channel@@IAEGK@Z
DSOUND	SEGMENT
_this$ = -4
_dwRegister$ = 8
?PeekAciRegister16@CAc97Channel@@IAEGK@Z PROC NEAR	; CAc97Channel::PeekAciRegister16, COMDAT
; _this$ = ecx

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 444  :     return m_pDevice->PeekAciRegister16(dwRegister + m_adwRegisterOffsets[m_nChannelType]);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 55 08	 mov	 edx, DWORD PTR _dwRegister$[ebp]
  0000f	03 14 8d 00 00
	00 00		 add	 edx, DWORD PTR ?m_adwRegisterOffsets@CAc97Channel@@2QBKB[ecx*4]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 ?PeekAciRegister16@CAc97Device@@KGGK@Z ; CAc97Device::PeekAciRegister16

; 445  : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?PeekAciRegister16@CAc97Channel@@IAEGK@Z ENDP		; CAc97Channel::PeekAciRegister16
DSOUND	ENDS
PUBLIC	?PeekRegister16@CAc97Device@@KGGK@Z		; CAc97Device::PeekRegister16
; Function compile flags: /Odt
;	COMDAT ?PeekAciRegister16@CAc97Device@@KGGK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
?PeekAciRegister16@CAc97Device@@KGGK@Z PROC NEAR	; CAc97Device::PeekAciRegister16, COMDAT

; 270  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  :     return PeekRegister16(m_dwAciRegisterBase + dwRegister);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwAciRegisterBase@CAc97Device@@2KB ; CAc97Device::m_dwAciRegisterBase
  00008	03 45 08	 add	 eax, DWORD PTR _dwRegister$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PeekRegister16@CAc97Device@@KGGK@Z ; CAc97Device::PeekRegister16

; 272  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?PeekAciRegister16@CAc97Device@@KGGK@Z ENDP		; CAc97Device::PeekAciRegister16
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PeekRegister16@CAc97Device@@KGGK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
?PeekRegister16@CAc97Device@@KGGK@Z PROC NEAR		; CAc97Device::PeekRegister16, COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 201  : 
; 202  : #ifdef AC97_USE_MIO
; 203  : 
; 204  :     return *(LPWORD)dwRegister;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00006	66 8b 00	 mov	 ax, WORD PTR [eax]

; 205  : 
; 206  : #else // AC97_USE_MIO
; 207  : 
; 208  :     return _inpw((WORD)dwRegister);
; 209  : 
; 210  : #endif // AC97_USE_MIO
; 211  : 
; 212  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?PeekRegister16@CAc97Device@@KGGK@Z ENDP		; CAc97Device::PeekRegister16
DSOUND	ENDS
PUBLIC	?PokeAciRegister16@CAc97Device@@KGXKG@Z		; CAc97Device::PokeAciRegister16
; Function compile flags: /Odt
;	COMDAT ?PokeAciRegister16@CAc97Channel@@IAEXKG@Z
DSOUND	SEGMENT
_this$ = -4
_dwRegister$ = 8
_wValue$ = 12
?PokeAciRegister16@CAc97Channel@@IAEXKG@Z PROC NEAR	; CAc97Channel::PokeAciRegister16, COMDAT
; _this$ = ecx

; 448  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 449  :     m_pDevice->PokeAciRegister16(dwRegister + m_adwRegisterOffsets[m_nChannelType], wValue);

  00007	66 8b 45 0c	 mov	 ax, WORD PTR _wValue$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00014	03 04 95 00 00
	00 00		 add	 eax, DWORD PTR ?m_adwRegisterOffsets@CAc97Channel@@2QBKB[edx*4]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PokeAciRegister16@CAc97Device@@KGXKG@Z ; CAc97Device::PokeAciRegister16

; 450  : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?PokeAciRegister16@CAc97Channel@@IAEXKG@Z ENDP		; CAc97Channel::PokeAciRegister16
DSOUND	ENDS
PUBLIC	?PokeRegister16@CAc97Device@@KGXKG@Z		; CAc97Device::PokeRegister16
; Function compile flags: /Odt
;	COMDAT ?PokeAciRegister16@CAc97Device@@KGXKG@Z
DSOUND	SEGMENT
_dwRegister$ = 8
_wValue$ = 12
?PokeAciRegister16@CAc97Device@@KGXKG@Z PROC NEAR	; CAc97Device::PokeAciRegister16, COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 276  :     PokeRegister16(m_dwAciRegisterBase + dwRegister, wValue);

  00003	66 8b 45 0c	 mov	 ax, WORD PTR _wValue$[ebp]
  00007	50		 push	 eax
  00008	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwAciRegisterBase@CAc97Device@@2KB ; CAc97Device::m_dwAciRegisterBase
  0000e	03 4d 08	 add	 ecx, DWORD PTR _dwRegister$[ebp]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?PokeRegister16@CAc97Device@@KGXKG@Z ; CAc97Device::PokeRegister16

; 277  : }

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?PokeAciRegister16@CAc97Device@@KGXKG@Z ENDP		; CAc97Device::PokeAciRegister16
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PokeRegister16@CAc97Device@@KGXKG@Z
DSOUND	SEGMENT
_dwRegister$ = 8
_wValue$ = 12
?PokeRegister16@CAc97Device@@KGXKG@Z PROC NEAR		; CAc97Device::PokeRegister16, COMDAT

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 216  : 
; 217  : #ifdef AC97_USE_MIO
; 218  : 
; 219  :     *(LPWORD)dwRegister = wValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00006	66 8b 4d 0c	 mov	 cx, WORD PTR _wValue$[ebp]
  0000a	66 89 08	 mov	 WORD PTR [eax], cx

; 220  : 
; 221  : #else // AC97_USE_MIO
; 222  : 
; 223  :     _outpw((WORD)dwRegister, wValue);
; 224  : 
; 225  : #endif // AC97_USE_MIO
; 226  : 
; 227  : }

  0000d	5d		 pop	 ebp
  0000e	c2 08 00	 ret	 8
?PokeRegister16@CAc97Device@@KGXKG@Z ENDP		; CAc97Device::PokeRegister16
DSOUND	ENDS
PUBLIC	?AciSynchronizationRoutine@CAc97Device@@CGEPAX@Z ; CAc97Device::AciSynchronizationRoutine
EXTRN	__imp__KeSynchronizeExecution@12:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.cpp
;	COMDAT ?ServiceAciInterruptDpc@CAc97Device@@IAEXXZ
DSOUND	SEGMENT
_this$ = -12
_fContinue$ = -8
_i$ = -4
?ServiceAciInterruptDpc@CAc97Device@@IAEXXZ PROC NEAR	; CAc97Device::ServiceAciInterruptDpc, COMDAT
; _this$ = ecx

; 820  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
$L32215:

; 821  :     BOOL                    fContinue;
; 822  :     DWORD                   i;
; 823  : 
; 824  :     DPF_ENTER();
; 825  : 
; 826  :     do
; 827  :     {
; 828  :         //
; 829  :         // Copy live buffer completion counts to cached
; 830  :         //
; 831  : 
; 832  :         KeSynchronizeExecution(&m_Interrupt, AciSynchronizationRoutine, this);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:?AciSynchronizationRoutine@CAc97Device@@CGEPAX@Z ; CAc97Device::AciSynchronizationRoutine
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?m_Interrupt@CAc97Device@@1U_KINTERRUPT@@A ; CAc97Device::m_Interrupt
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSynchronizeExecution@12

; 833  : 
; 834  :         //
; 835  :         // Handle all pending buffer completions
; 836  :         //
; 837  : 
; 838  :         for(i = 0, fContinue = FALSE; i < AC97_CHANNELTYPE_COUNT; i++)

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fContinue$[ebp], 0
  0002b	eb 09		 jmp	 SHORT $L32218
$L32219:
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00030	83 c1 01	 add	 ecx, 1
  00033	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L32218:
  00036	83 7d fc 02	 cmp	 DWORD PTR _i$[ebp], 2
  0003a	73 65		 jae	 SHORT $L32216

; 839  :         {
; 840  :             if(m_abPendingBufferCompletions[i][1])

  0003c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00042	0f b6 4c 50 39	 movzx	 ecx, BYTE PTR [eax+edx*2+57]
  00047	85 c9		 test	 ecx, ecx
  00049	74 54		 je	 SHORT $L32221

; 841  :             {
; 842  :                 fContinue = TRUE;

  0004b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fContinue$[ebp], 1

; 843  : 
; 844  :                 if(m_apChannels[i])

  00052	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00055	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00058	83 3c 90 00	 cmp	 DWORD PTR [eax+edx*4], 0
  0005c	74 36		 je	 SHORT $L32222
$L32223:

; 845  :                 {
; 846  :                     do
; 847  :                     {
; 848  :                         m_apChannels[i]->ServiceInterrupt();

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00061	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00064	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00067	e8 00 00 00 00	 call	 ?ServiceInterrupt@CAc97Channel@@IAEXXZ ; CAc97Channel::ServiceInterrupt

; 849  :                     }
; 850  :                     while(--m_abPendingBufferCompletions[i][1]);

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	8a 54 41 39	 mov	 dl, BYTE PTR [ecx+eax*2+57]
  00076	80 ea 01	 sub	 dl, 1
  00079	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0007c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	88 54 41 39	 mov	 BYTE PTR [ecx+eax*2+57], dl
  00083	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00086	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00089	0f b6 4c 50 39	 movzx	 ecx, BYTE PTR [eax+edx*2+57]
  0008e	85 c9		 test	 ecx, ecx
  00090	75 cc		 jne	 SHORT $L32223

; 851  :                 }
; 852  :                 else

  00092	eb 0b		 jmp	 SHORT $L32221
$L32222:

; 853  :                 {
; 854  :                     m_abPendingBufferCompletions[i][1] = 0;

  00094	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00097	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	c6 44 50 39 00	 mov	 BYTE PTR [eax+edx*2+57], 0
$L32221:

; 855  :                 }
; 856  :             }
; 857  :         }

  0009f	eb 8c		 jmp	 SHORT $L32219
$L32216:

; 858  :     }
; 859  :     while(fContinue);

  000a1	83 7d f8 00	 cmp	 DWORD PTR _fContinue$[ebp], 0
  000a5	0f 85 5e ff ff
	ff		 jne	 $L32215

; 860  : 
; 861  :     DPF_LEAVE_VOID();
; 862  : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
?ServiceAciInterruptDpc@CAc97Device@@IAEXXZ ENDP	; CAc97Device::ServiceAciInterruptDpc
DSOUND	ENDS
PUBLIC	?SynchronizeAciInterrupt@CAc97Device@@IAEXXZ	; CAc97Device::SynchronizeAciInterrupt
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.h
;	COMDAT ?AciSynchronizationRoutine@CAc97Device@@CGEPAX@Z
DSOUND	SEGMENT
_pThis$ = -4
_pvContext$ = 8
?AciSynchronizationRoutine@CAc97Device@@CGEPAX@Z PROC NEAR ; CAc97Device::AciSynchronizationRoutine, COMDAT

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 317  :     CAc97Device *           pThis   = (CAc97Device *)pvContext;

  00004	8b 45 08	 mov	 eax, DWORD PTR _pvContext$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pThis$[ebp], eax

; 318  :     
; 319  :     pThis->SynchronizeAciInterrupt();

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _pThis$[ebp]
  0000d	e8 00 00 00 00	 call	 ?SynchronizeAciInterrupt@CAc97Device@@IAEXXZ ; CAc97Device::SynchronizeAciInterrupt

; 320  : 
; 321  :     return TRUE;

  00012	b0 01		 mov	 al, 1

; 322  : }    

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?AciSynchronizationRoutine@CAc97Device@@CGEPAX@Z ENDP	; CAc97Device::AciSynchronizationRoutine
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.cpp
DSOUND	ENDS
;	COMDAT ?SynchronizeAciInterrupt@CAc97Device@@IAEXXZ
DSOUND	SEGMENT
_this$ = -8
_i$ = -4
?SynchronizeAciInterrupt@CAc97Device@@IAEXXZ PROC NEAR	; CAc97Device::SynchronizeAciInterrupt, COMDAT
; _this$ = ecx

; 888  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 889  :     DWORD                   i;
; 890  : 
; 891  :     DPF_ENTER();
; 892  : 
; 893  :     //
; 894  :     // Copy live pending buffer completions to cached and clear the live
; 895  :     // ones.
; 896  :     //
; 897  : 
; 898  :     for(i = 0; i < AC97_CHANNELTYPE_COUNT; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $L32232
$L32233:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L32232:
  0001b	83 7d fc 02	 cmp	 DWORD PTR _i$[ebp], 2
  0001f	73 2f		 jae	 SHORT $L32230

; 899  :     {
; 900  :         m_abPendingBufferCompletions[i][1] += m_abPendingBufferCompletions[i][0];

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00024	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00027	0f b6 44 4a 38	 movzx	 eax, BYTE PTR [edx+ecx*2+56]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0002f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00032	0f b6 4c 4a 39	 movzx	 ecx, BYTE PTR [edx+ecx*2+57]
  00037	03 c8		 add	 ecx, eax
  00039	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	88 4c 50 39	 mov	 BYTE PTR [eax+edx*2+57], cl

; 901  : 
; 902  :         m_abPendingBufferCompletions[i][0] = 0;

  00043	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00046	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00049	c6 44 4a 38 00	 mov	 BYTE PTR [edx+ecx*2+56], 0

; 903  :     }

  0004e	eb c2		 jmp	 SHORT $L32233
$L32230:

; 904  : 
; 905  :     DPF_LEAVE_VOID();
; 906  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?SynchronizeAciInterrupt@CAc97Device@@IAEXXZ ENDP	; CAc97Device::SynchronizeAciInterrupt
DSOUND	ENDS
PUBLIC	??_C@_0BO@OPIJJKBJ@CAc97Device?3?3PeekAc97Register?$AA@ ; `string'
PUBLIC	??_C@_0BM@ELGJIPAJ@AC?5?897?5register?5peek?5failed?$AA@ ; `string'
PUBLIC	?PeekAc97Register@CAc97Device@@KGHW4AC97REGISTER@@PAG@Z ; CAc97Device::PeekAc97Register
;	COMDAT ??_C@_0BO@OPIJJKBJ@CAc97Device?3?3PeekAc97Register?$AA@
DSOUND_RD	SEGMENT
??_C@_0BO@OPIJJKBJ@CAc97Device?3?3PeekAc97Register?$AA@ DB 'CAc97Device::'
	DB	'PeekAc97Register', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@ELGJIPAJ@AC?5?897?5register?5peek?5failed?$AA@
DSOUND_RD	SEGMENT
??_C@_0BM@ELGJIPAJ@AC?5?897?5register?5peek?5failed?$AA@ DB 'AC ''97 regi'
	DB	'ster peek failed', 00H			; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?PeekAc97Register@CAc97Device@@KGHW4AC97REGISTER@@PAG@Z
DSOUND	SEGMENT
_dwStatus$ = -8
_fSuccess$ = -4
_reg$ = 8
_pwValue$ = 12
?PeekAc97Register@CAc97Device@@KGHW4AC97REGISTER@@PAG@Z PROC NEAR ; CAc97Device::PeekAc97Register, COMDAT

; 934  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 935  :     DWORD                   dwStatus;
; 936  :     BOOL                    fSuccess;
; 937  : 
; 938  :     DPF_ENTER();
; 939  :     
; 940  :     //
; 941  :     // Acquire the CODEC semaphore
; 942  :     //
; 943  : 
; 944  :     fSuccess = AcquireCodecSemaphore();

  00006	e8 00 00 00 00	 call	 ?AcquireCodecSemaphore@CAc97Device@@KGHXZ ; CAc97Device::AcquireCodecSemaphore
  0000b	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 945  : 
; 946  :     //
; 947  :     // Read the contents of the register
; 948  :     //
; 949  : 
; 950  :     if(fSuccess)

  0000e	83 7d fc 00	 cmp	 DWORD PTR _fSuccess$[ebp], 0
  00012	74 16		 je	 SHORT $L32241

; 951  :     {
; 952  :         *pwValue = PeekRegister16(m_dwAc97RegisterBase + (reg * 2));

  00014	8b 45 08	 mov	 eax, DWORD PTR _reg$[ebp]
  00017	8d 8c 00 00 00
	c0 fe		 lea	 ecx, DWORD PTR [eax+eax-20971520]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ?PeekRegister16@CAc97Device@@KGGK@Z ; CAc97Device::PeekRegister16
  00024	8b 55 0c	 mov	 edx, DWORD PTR _pwValue$[ebp]
  00027	66 89 02	 mov	 WORD PTR [edx], ax
$L32241:

; 953  :     }
; 954  : 
; 955  :     //
; 956  :     // Make sure the read was successful
; 957  :     //
; 958  : 
; 959  :     if(fSuccess)

  0002a	83 7d fc 00	 cmp	 DWORD PTR _fSuccess$[ebp], 0
  0002e	74 5b		 je	 SHORT $L32242

; 960  :     {
; 961  :         if((dwStatus = PeekAciRegister32(GLB_STATUS)) & GLB_STATUS_RCS)

  00030	6a 30		 push	 48			; 00000030H
  00032	e8 00 00 00 00	 call	 ?PeekAciRegister32@CAc97Device@@KGKK@Z ; CAc97Device::PeekAciRegister32
  00037	89 45 f8	 mov	 DWORD PTR _dwStatus$[ebp], eax
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _dwStatus$[ebp]
  0003d	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00042	85 c0		 test	 eax, eax
  00044	74 45		 je	 SHORT $L32242

; 962  :         {
; 963  :             //
; 964  :             // Nope.  Clear the bit.
; 965  :             //
; 966  : 
; 967  :             DPF_ERROR("AC '97 register peek failed");

  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@OPIJJKBJ@CAc97Device?3?3PeekAc97Register?$AA@
  00050	68 c7 03 00 00	 push	 967			; 000003c7H
  00055	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  0005a	6a 01		 push	 1
  0005c	6a 09		 push	 9
  0005e	e8 00 00 00 00	 call	 _DwDbgSetContext
  00063	83 c4 18	 add	 esp, 24			; 00000018H
  00066	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@ELGJIPAJ@AC?5?897?5register?5peek?5failed?$AA@
  0006b	e8 00 00 00 00	 call	 _DwDbgPrint
  00070	83 c4 04	 add	 esp, 4

; 968  :             
; 969  :             PokeAciRegister32(GLB_STATUS, dwStatus & ~GLB_STATUS_RCS);

  00073	8b 4d f8	 mov	 ecx, DWORD PTR _dwStatus$[ebp]
  00076	81 e1 ff 7f ff
	ff		 and	 ecx, -32769		; ffff7fffH
  0007c	51		 push	 ecx
  0007d	6a 30		 push	 48			; 00000030H
  0007f	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Device@@KGXKK@Z ; CAc97Device::PokeAciRegister32

; 970  :             
; 971  :             fSuccess = FALSE;

  00084	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0
$L32242:

; 972  :         }
; 973  :     }
; 974  : 
; 975  :     DPF_LEAVE(fSuccess);
; 976  : 
; 977  :     return fSuccess;

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 978  : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 08 00	 ret	 8
?PeekAc97Register@CAc97Device@@KGHW4AC97REGISTER@@PAG@Z ENDP ; CAc97Device::PeekAc97Register
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PokeAc97Register@CAc97Device@@KGHW4AC97REGISTER@@G@Z
DSOUND	SEGMENT
_fSuccess$ = -4
_reg$ = 8
_wValue$ = 12
?PokeAc97Register@CAc97Device@@KGHW4AC97REGISTER@@G@Z PROC NEAR ; CAc97Device::PokeAc97Register, COMDAT

; 1006 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1007 :     BOOL                    fSuccess;
; 1008 : 
; 1009 :     DPF_ENTER();
; 1010 :     
; 1011 :     //
; 1012 :     // Acquire the CODEC semaphore
; 1013 :     //
; 1014 : 
; 1015 :     fSuccess = AcquireCodecSemaphore();

  00004	e8 00 00 00 00	 call	 ?AcquireCodecSemaphore@CAc97Device@@KGHXZ ; CAc97Device::AcquireCodecSemaphore
  00009	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 1016 : 
; 1017 :     //
; 1018 :     // Write to the register
; 1019 :     //
; 1020 : 
; 1021 :     if(fSuccess)

  0000c	83 7d fc 00	 cmp	 DWORD PTR _fSuccess$[ebp], 0
  00010	74 15		 je	 SHORT $L32251

; 1022 :     {
; 1023 :         PokeRegister16(m_dwAc97RegisterBase + (reg * 2), wValue);

  00012	66 8b 45 0c	 mov	 ax, WORD PTR _wValue$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _reg$[ebp]
  0001a	8d 94 09 00 00
	c0 fe		 lea	 edx, DWORD PTR [ecx+ecx-20971520]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 ?PokeRegister16@CAc97Device@@KGXKG@Z ; CAc97Device::PokeRegister16
$L32251:

; 1024 :     }
; 1025 : 
; 1026 :     DPF_LEAVE(fSuccess);
; 1027 : 
; 1028 :     return fSuccess;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 1029 : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?PokeAc97Register@CAc97Device@@KGHW4AC97REGISTER@@G@Z ENDP ; CAc97Device::PokeAc97Register
DSOUND	ENDS
PUBLIC	?VerifyPokeAc97Register@CAc97Device@@KGHW4AC97REGISTER@@G@Z ; CAc97Device::VerifyPokeAc97Register
; Function compile flags: /Odt
;	COMDAT ?VerifyPokeAc97Register@CAc97Device@@KGHW4AC97REGISTER@@G@Z
DSOUND	SEGMENT
_wNewValue$ = -8
_fSuccess$ = -4
_reg$ = 8
_wValue$ = 12
?VerifyPokeAc97Register@CAc97Device@@KGHW4AC97REGISTER@@G@Z PROC NEAR ; CAc97Device::VerifyPokeAc97Register, COMDAT

; 1058 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1059 :     WORD                    wNewValue;
; 1060 :     BOOL                    fSuccess;
; 1061 : 
; 1062 :     DPF_ENTER();
; 1063 :     
; 1064 :     //
; 1065 :     // Write the new value
; 1066 :     //
; 1067 : 
; 1068 :     fSuccess = PokeAc97Register(reg, wValue);

  00006	66 8b 45 0c	 mov	 ax, WORD PTR _wValue$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _reg$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ?PokeAc97Register@CAc97Device@@KGHW4AC97REGISTER@@G@Z ; CAc97Device::PokeAc97Register
  00014	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 1069 : 
; 1070 :     //
; 1071 :     // Read back the new value
; 1072 :     //
; 1073 : 
; 1074 :     if(fSuccess)

  00017	83 7d fc 00	 cmp	 DWORD PTR _fSuccess$[ebp], 0
  0001b	74 10		 je	 SHORT $L32258

; 1075 :     {
; 1076 :         fSuccess = PeekAc97Register(reg, &wNewValue);

  0001d	8d 55 f8	 lea	 edx, DWORD PTR _wNewValue$[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR _reg$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?PeekAc97Register@CAc97Device@@KGHW4AC97REGISTER@@PAG@Z ; CAc97Device::PeekAc97Register
  0002a	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax
$L32258:

; 1077 :     }
; 1078 : 
; 1079 :     //
; 1080 :     // Did it stick?
; 1081 :     //
; 1082 : 
; 1083 :     if(fSuccess && (wValue != wNewValue))

  0002d	83 7d fc 00	 cmp	 DWORD PTR _fSuccess$[ebp], 0
  00031	74 13		 je	 SHORT $L32259
  00033	0f b7 4d 0c	 movzx	 ecx, WORD PTR _wValue$[ebp]
  00037	0f b7 55 f8	 movzx	 edx, WORD PTR _wNewValue$[ebp]
  0003b	3b ca		 cmp	 ecx, edx
  0003d	74 07		 je	 SHORT $L32259

; 1084 :     {
; 1085 :         fSuccess = FALSE;

  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0
$L32259:

; 1086 :     }
; 1087 : 
; 1088 :     DPF_LEAVE(fSuccess);
; 1089 : 
; 1090 :     return fSuccess;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 1091 : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?VerifyPokeAc97Register@CAc97Device@@KGHW4AC97REGISTER@@G@Z ENDP ; CAc97Device::VerifyPokeAc97Register
DSOUND	ENDS
PUBLIC	??_C@_0BF@HKCIBLPB@CAc97Device?3?3PowerUp?$AA@	; `string'
PUBLIC	??_C@_0BK@PNLPHEF@Failed?5to?5set?5power?5state?$AA@ ; `string'
;	COMDAT ??_C@_0BF@HKCIBLPB@CAc97Device?3?3PowerUp?$AA@
DSOUND_RD	SEGMENT
??_C@_0BF@HKCIBLPB@CAc97Device?3?3PowerUp?$AA@ DB 'CAc97Device::PowerUp', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@PNLPHEF@Failed?5to?5set?5power?5state?$AA@
DSOUND_RD	SEGMENT
??_C@_0BK@PNLPHEF@Failed?5to?5set?5power?5state?$AA@ DB 'Failed to set po'
	DB	'wer state', 00H				; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?PowerUp@CAc97Device@@IAEJXZ
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
?PowerUp@CAc97Device@@IAEJXZ PROC NEAR			; CAc97Device::PowerUp, COMDAT
; _this$ = ecx

; 1117 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1118 :     HRESULT                 hr  = DS_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1119 :     
; 1120 :     DPF_ENTER();
; 1121 : 
; 1122 :     //
; 1123 :     // Set the CODEC to full power
; 1124 :     //
; 1125 : 
; 1126 :     if(!PokeAc97Register(AC97REG_POWERDOWN, AC97REG_PCS_FULL_POWER))

  00010	6a 00		 push	 0
  00012	6a 13		 push	 19			; 00000013H
  00014	e8 00 00 00 00	 call	 ?PokeAc97Register@CAc97Device@@KGHW4AC97REGISTER@@G@Z ; CAc97Device::PokeAc97Register
  00019	85 c0		 test	 eax, eax
  0001b	75 34		 jne	 SHORT $L32266

; 1127 :     {
; 1128 :         DPF_ERROR("Failed to set power state");

  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  00022	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@HKCIBLPB@CAc97Device?3?3PowerUp?$AA@
  00027	68 68 04 00 00	 push	 1128			; 00000468H
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  00031	6a 01		 push	 1
  00033	6a 09		 push	 9
  00035	e8 00 00 00 00	 call	 _DwDbgSetContext
  0003a	83 c4 18	 add	 esp, 24			; 00000018H
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@PNLPHEF@Failed?5to?5set?5power?5state?$AA@
  00042	e8 00 00 00 00	 call	 _DwDbgPrint
  00047	83 c4 04	 add	 esp, 4

; 1129 :         hr = DSERR_GENERIC;

  0004a	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L32266:

; 1130 :     }
; 1131 : 
; 1132 :     DPF_LEAVE_HRESULT(hr);
; 1133 : 
; 1134 :     return hr;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1135 : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?PowerUp@CAc97Device@@IAEJXZ ENDP			; CAc97Device::PowerUp
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??0CAc97Channel@@QAE@PAVCAc97Device@@W4AC97CHANNELTYPE@@@Z
DSOUND	SEGMENT
_this$ = -4
_pDevice$ = 8
_nChannelType$ = 12
??0CAc97Channel@@QAE@PAVCAc97Device@@W4AC97CHANNELTYPE@@@Z PROC NEAR ; CAc97Channel::CAc97Channel, COMDAT
; _this$ = ecx

; 1171 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _nChannelType$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 1172 : 
; 1173 :     DPF_ENTER();
; 1174 : 
; 1175 :     //
; 1176 :     // Initialize defaults
; 1177 :     //
; 1178 : 
; 1179 :     m_dwMode = DSAC97_MODE_DEFAULT;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	c7 42 28 00 00
	00 02		 mov	 DWORD PTR [edx+40], 33554432 ; 02000000H

; 1180 : 
; 1181 :     //
; 1182 :     // Save a pointer back to the parent device.  Note that we're not 
; 1183 :     // AddRef'ing it, since the device controls our construction and 
; 1184 :     // destruction.
; 1185 :     //
; 1186 : 
; 1187 :     m_pDevice = pDevice;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _pDevice$[ebp]
  0001f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1188 : 
; 1189 :     DPF_LEAVE_VOID();
; 1190 : }

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
??0CAc97Channel@@QAE@PAVCAc97Device@@W4AC97CHANNELTYPE@@@Z ENDP ; CAc97Channel::CAc97Channel
DSOUND	ENDS
PUBLIC	?Terminate@CAc97Channel@@QAEXXZ			; CAc97Channel::Terminate
; Function compile flags: /Odt
;	COMDAT ??1CAc97Channel@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CAc97Channel@@QAE@XZ PROC NEAR			; CAc97Channel::~CAc97Channel, COMDAT
; _this$ = ecx

; 1215 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1216 :     DPF_ENTER();
; 1217 :     
; 1218 :     Terminate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Terminate@CAc97Channel@@QAEXXZ ; CAc97Channel::Terminate

; 1219 : 
; 1220 :     DPF_LEAVE_VOID();
; 1221 : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CAc97Channel@@QAE@XZ ENDP				; CAc97Channel::~CAc97Channel
DSOUND	ENDS
PUBLIC	??_C@_06GMOAGDML@ACIPRD?$AA@			; `string'
PUBLIC	??_C@_04ELFAHOMP@BYTE?$AA@			; `string'
PUBLIC	?Initialize@CAc97Channel@@QAEJKP6GXPAX@Z0@Z	; CAc97Channel::Initialize
PUBLIC	?Reset@CAc97Channel@@QAEXXZ			; CAc97Channel::Reset
EXTRN	_DirectSoundTestTrackingPhysicalAlloc@28:NEAR
EXTRN	__imp__MmGetPhysicalAddress@4:NEAR
;	COMDAT ??_C@_06GMOAGDML@ACIPRD?$AA@
DSOUND_RD	SEGMENT
??_C@_06GMOAGDML@ACIPRD?$AA@ DB 'ACIPRD', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_04ELFAHOMP@BYTE?$AA@
DSOUND_RD	SEGMENT
??_C@_04ELFAHOMP@BYTE?$AA@ DB 'BYTE', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Initialize@CAc97Channel@@QAEJKP6GXPAX@Z0@Z
DSOUND	SEGMENT
_this$ = -20
$T32829 = -16
___AutoIrql$ = -12
_hr$ = -4
_dwFlags$ = 8
_pfnCallback$ = 12
_pvContext$ = 16
?Initialize@CAc97Channel@@QAEJKP6GXPAX@Z0@Z PROC NEAR	; CAc97Channel::Initialize, COMDAT
; _this$ = ecx

; 1251 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1252 :     HRESULT                 hr;
; 1253 :     
; 1254 :     DPF_ENTER();
; 1255 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 1256 : 
; 1257 : 
; 1258 :     m_dwFlags = dwFlags;

  00011	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00017	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 1259 :     m_pfnCallback = pfnCallback;

  0001a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 45 0c	 mov	 eax, DWORD PTR _pfnCallback$[ebp]
  00020	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 1260 :     m_pvCallbackContext = pvContext;

  00023	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 55 10	 mov	 edx, DWORD PTR _pvContext$[ebp]
  00029	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 1261 : 
; 1262 :     //
; 1263 :     // Allocate the PRDL
; 1264 :     //
; 1265 : 
; 1266 :     hr = HRFROMP(m_pPrdl = PHYSALLOC(ACIPRD, ACIPRDL_ENTRY_COUNT, PAGE_SIZE, PAGE_READWRITE));

  0002c	6a 01		 push	 1
  0002e	6a 04		 push	 4
  00030	68 00 10 00 00	 push	 4096			; 00001000H
  00035	68 00 01 00 00	 push	 256			; 00000100H
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06GMOAGDML@ACIPRD?$AA@
  0003f	68 f2 04 00 00	 push	 1266			; 000004f2H
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  00049	e8 00 00 00 00	 call	 _DirectSoundTestTrackingPhysicalAlloc@28
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00054	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00057	33 c0		 xor	 eax, eax
  00059	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  0005d	0f 95 c0	 setne	 al
  00060	48		 dec	 eax
  00061	25 0e 00 07 80	 and	 eax, -2147024882	; 8007000eH
  00066	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1267 : 
; 1268 :     if(SUCCEEDED(hr))

  00069	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006d	7c 13		 jl	 SHORT $L32293

; 1269 :     {
; 1270 :         m_dwPrdlAddress = MmGetPhysicalAddress(m_pPrdl);

  0006f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00075	52		 push	 edx
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmGetPhysicalAddress@4
  0007c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$L32293:

; 1271 :     }
; 1272 : 
; 1273 :     //
; 1274 :     // If we're a stream, allocate a packet of silence to loop on when we
; 1275 :     // starve.
; 1276 :     //
; 1277 : 
; 1278 :     if(SUCCEEDED(hr) && (dwFlags & AC97CHANNEL_OBJECTF_STREAM))

  00082	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00086	7c 47		 jl	 SHORT $L32295
  00088	8b 55 08	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0008b	83 e2 01	 and	 edx, 1
  0008e	85 d2		 test	 edx, edx
  00090	74 3d		 je	 SHORT $L32295

; 1279 :     {
; 1280 :         hr = HRFROMP(m_pvSilence = PHYSALLOC(BYTE, m_dwSilenceSize, PAGE_SIZE, PAGE_READWRITE));

  00092	6a 01		 push	 1
  00094	6a 04		 push	 4
  00096	68 00 10 00 00	 push	 4096			; 00001000H
  0009b	68 00 20 00 00	 push	 8192			; 00002000H
  000a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04ELFAHOMP@BYTE?$AA@
  000a5	68 00 05 00 00	 push	 1280			; 00000500H
  000aa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  000af	e8 00 00 00 00	 call	 _DirectSoundTestTrackingPhysicalAlloc@28
  000b4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  000ba	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000bd	33 c0		 xor	 eax, eax
  000bf	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  000c3	0f 95 c0	 setne	 al
  000c6	48		 dec	 eax
  000c7	25 0e 00 07 80	 and	 eax, -2147024882	; 8007000eH
  000cc	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L32295:

; 1281 :     }
; 1282 : 
; 1283 :     //
; 1284 :     // Reset the channel
; 1285 :     //
; 1286 : 
; 1287 :     if(SUCCEEDED(hr))

  000cf	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000d3	7c 08		 jl	 SHORT $L32302

; 1288 :     {
; 1289 :         Reset();

  000d5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?Reset@CAc97Channel@@QAEXXZ ; CAc97Channel::Reset
$L32302:

; 1290 :     }
; 1291 : 
; 1292 :     DPF_LEAVE_HRESULT(hr);
; 1293 : 
; 1294 :     return hr;

  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _hr$[ebp]
  000e0	89 4d f0	 mov	 DWORD PTR $T32829[ebp], ecx
  000e3	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000e6	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  000eb	8b 45 f0	 mov	 eax, DWORD PTR $T32829[ebp]

; 1295 : }

  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 0c 00	 ret	 12			; 0000000cH
?Initialize@CAc97Channel@@QAEJKP6GXPAX@Z0@Z ENDP	; CAc97Channel::Initialize
DSOUND	ENDS
PUBLIC	?Flush@CAc97Channel@@QAEXH@Z			; CAc97Channel::Flush
EXTRN	_DirectSoundTestTrackingPhysicalFree@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Terminate@CAc97Channel@@QAEXXZ
DSOUND	SEGMENT
_this$ = -12
___AutoIrql$ = -8
?Terminate@CAc97Channel@@QAEXXZ PROC NEAR		; CAc97Channel::Terminate, COMDAT
; _this$ = ecx

; 1321 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1322 :     DPF_ENTER();
; 1323 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 1324 : 
; 1325 :     //
; 1326 :     // Reset the channel
; 1327 :     //
; 1328 : 
; 1329 :     Flush();

  00011	6a 01		 push	 1
  00013	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?Flush@CAc97Channel@@QAEXH@Z ; CAc97Channel::Flush

; 1330 :     
; 1331 :     //
; 1332 :     // Free resources
; 1333 :     //
; 1334 : 
; 1335 :     PHYSFREE(m_pPrdl);

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00022	74 16		 je	 SHORT $L32309
  00024	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0002a	52		 push	 edx
  0002b	e8 00 00 00 00	 call	 _DirectSoundTestTrackingPhysicalFree@4
  00030	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
$L32309:

; 1336 :     PHYSFREE(m_pvSilence);

  0003a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00041	74 16		 je	 SHORT $L32310
  00043	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00046	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _DirectSoundTestTrackingPhysicalFree@4
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
$L32310:

; 1337 : 
; 1338 :     m_dwPrdlAddress = 0;

  00059	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1339 : 
; 1340 :     DPF_LEAVE_VOID();
; 1341 : }

  00063	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00066	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?Terminate@CAc97Channel@@QAEXXZ ENDP			; CAc97Channel::Terminate
DSOUND	ENDS
PUBLIC	??_C@_0CC@GIEFHAAL@m_bPrdCount?5?$DM?5ACIPRDL_ENTRY_COUN@ ; `string'
PUBLIC	??_C@_0EH@NFHOMJAA@?$CIdwBufferSize?5?1?5?$CIm_pDevice?9?$DOm_wf@ ; `string'
PUBLIC	??_C@_0DF@GAHFEOCL@?$CB?$CIdwBufferSize?5?$CF?5m_pDevice?9?$DOm_wf@ ; `string'
PUBLIC	??_C@_0P@NNIHOMBL@?$CBm_bCurrentPrd?$AA@	; `string'
PUBLIC	??_C@_0CH@NBJNCKCO@m_dwFlags?5?$CG?5AC97CHANNEL_OBJECTF_@ ; `string'
PUBLIC	??_C@_0M@CIAIIEJM@m_bPrdCount?$AA@		; `string'
PUBLIC	?AttachPacket@CAc97Channel@@QAEXKK@Z		; CAc97Channel::AttachPacket
PUBLIC	?SetPrdIndeces@CAc97Channel@@IAEXEEHH@Z		; CAc97Channel::SetPrdIndeces
;	COMDAT ??_C@_0CC@GIEFHAAL@m_bPrdCount?5?$DM?5ACIPRDL_ENTRY_COUN@
DSOUND_RD	SEGMENT
??_C@_0CC@GIEFHAAL@m_bPrdCount?5?$DM?5ACIPRDL_ENTRY_COUN@ DB 'm_bPrdCount'
	DB	' < ACIPRDL_ENTRY_COUNT', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0EH@NFHOMJAA@?$CIdwBufferSize?5?1?5?$CIm_pDevice?9?$DOm_wf@
DSOUND_RD	SEGMENT
??_C@_0EH@NFHOMJAA@?$CIdwBufferSize?5?1?5?$CIm_pDevice?9?$DOm_wf@ DB '(dw'
	DB	'BufferSize / (m_pDevice->m_wfxFormat.wBitsPerSample / 8)) <= '
	DB	'0xFFFF', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DF@GAHFEOCL@?$CB?$CIdwBufferSize?5?$CF?5m_pDevice?9?$DOm_wf@
DSOUND_RD	SEGMENT
??_C@_0DF@GAHFEOCL@?$CB?$CIdwBufferSize?5?$CF?5m_pDevice?9?$DOm_wf@ DB '!'
	DB	'(dwBufferSize % m_pDevice->m_wfxFormat.nBlockAlign)', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0P@NNIHOMBL@?$CBm_bCurrentPrd?$AA@
DSOUND_RD	SEGMENT
??_C@_0P@NNIHOMBL@?$CBm_bCurrentPrd?$AA@ DB '!m_bCurrentPrd', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CH@NBJNCKCO@m_dwFlags?5?$CG?5AC97CHANNEL_OBJECTF_@
DSOUND_RD	SEGMENT
??_C@_0CH@NBJNCKCO@m_dwFlags?5?$CG?5AC97CHANNEL_OBJECTF_@ DB 'm_dwFlags &'
	DB	' AC97CHANNEL_OBJECTF_STREAM', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0M@CIAIIEJM@m_bPrdCount?$AA@
DSOUND_RD	SEGMENT
??_C@_0M@CIAIIEJM@m_bPrdCount?$AA@ DB 'm_bPrdCount', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?AttachPacket@CAc97Channel@@QAEXKK@Z
DSOUND	SEGMENT
_this$ = -16
___AutoIrql$ = -12
_bPrdIndex$ = -1
_dwBufferAddress$ = 8
_dwBufferSize$ = 12
?AttachPacket@CAc97Channel@@QAEXKK@Z PROC NEAR		; CAc97Channel::AttachPacket, COMDAT
; _this$ = ecx

; 1369 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1370 :     BYTE                    bPrdIndex;
; 1371 :     
; 1372 :     DPF_ENTER();
; 1373 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 1374 : 
; 1375 :     ASSERT(m_bPrdCount < ACIPRDL_ENTRY_COUNT);

  00011	68 5f 05 00 00	 push	 1375			; 0000055fH
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@GIEFHAAL@m_bPrdCount?5?$DM?5ACIPRDL_ENTRY_COUN@
  00020	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00023	0f b6 48 24	 movzx	 ecx, BYTE PTR [eax+36]
  00027	33 d2		 xor	 edx, edx
  00029	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0002c	0f 9d c2	 setge	 dl
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _DwDbgAssert
  00035	83 c4 10	 add	 esp, 16			; 00000010H

; 1376 :     ASSERT((dwBufferSize / (m_pDevice->m_wfxFormat.wBitsPerSample / 8)) <= 0xFFFF);

  00038	68 60 05 00 00	 push	 1376			; 00000560H
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@NFHOMJAA@?$CIdwBufferSize?5?1?5?$CIm_pDevice?9?$DOm_wf@
  00047	0f b7 05 0e 00
	00 00		 movzx	 eax, WORD PTR ?m_wfxFormat@CAc97Device@@2UtWAVEFORMATEX@@B+14
  0004e	99		 cdq
  0004f	83 e2 07	 and	 edx, 7
  00052	03 c2		 add	 eax, edx
  00054	8b c8		 mov	 ecx, eax
  00056	c1 f9 03	 sar	 ecx, 3
  00059	8b 45 0c	 mov	 eax, DWORD PTR _dwBufferSize$[ebp]
  0005c	33 d2		 xor	 edx, edx
  0005e	f7 f1		 div	 ecx
  00060	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00065	3b d0		 cmp	 edx, eax
  00067	1b c0		 sbb	 eax, eax
  00069	f7 d8		 neg	 eax
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _DwDbgAssert
  00071	83 c4 10	 add	 esp, 16			; 00000010H

; 1377 :     ASSERT(!(dwBufferSize % m_pDevice->m_wfxFormat.nBlockAlign));

  00074	68 61 05 00 00	 push	 1377			; 00000561H
  00079	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  0007e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DF@GAHFEOCL@?$CB?$CIdwBufferSize?5?$CF?5m_pDevice?9?$DOm_wf@
  00083	0f b7 0d 0c 00
	00 00		 movzx	 ecx, WORD PTR ?m_wfxFormat@CAc97Device@@2UtWAVEFORMATEX@@B+12
  0008a	8b 45 0c	 mov	 eax, DWORD PTR _dwBufferSize$[ebp]
  0008d	33 d2		 xor	 edx, edx
  0008f	f7 f1		 div	 ecx
  00091	f7 da		 neg	 edx
  00093	1b d2		 sbb	 edx, edx
  00095	f7 da		 neg	 edx
  00097	52		 push	 edx
  00098	e8 00 00 00 00	 call	 _DwDbgAssert
  0009d	83 c4 10	 add	 esp, 16			; 00000010H

; 1378 : 
; 1379 :     if(!(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM))

  000a0	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000a6	83 e0 01	 and	 eax, 1
  000a9	85 c0		 test	 eax, eax
  000ab	75 25		 jne	 SHORT $L32321

; 1380 :     {
; 1381 :         ASSERT(!m_bCurrentPrd);

  000ad	68 65 05 00 00	 push	 1381			; 00000565H
  000b2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  000b7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@NNIHOMBL@?$CBm_bCurrentPrd?$AA@
  000bc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	0f b6 51 25	 movzx	 edx, BYTE PTR [ecx+37]
  000c3	f7 da		 neg	 edx
  000c5	1b d2		 sbb	 edx, edx
  000c7	f7 da		 neg	 edx
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 _DwDbgAssert
  000cf	83 c4 10	 add	 esp, 16			; 00000010H
$L32321:

; 1382 :     }
; 1383 : 
; 1384 :     //
; 1385 :     // If a discontinuity has been signaled, but another packet has been
; 1386 :     // attached, we can remove the discontinuity by resetting the flags and
; 1387 :     // removing the silence packet.  The easiest way to remove the silence
; 1388 :     // packet is to just stomp on the PRD.
; 1389 :     //
; 1390 : 
; 1391 :     if(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY)

  000d2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000d8	83 e1 02	 and	 ecx, 2
  000db	85 c9		 test	 ecx, ecx
  000dd	74 68		 je	 SHORT $L32323

; 1392 :     {
; 1393 :         ASSERT(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM);

  000df	68 71 05 00 00	 push	 1393			; 00000571H
  000e4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  000e9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@NBJNCKCO@m_dwFlags?5?$CG?5AC97CHANNEL_OBJECTF_@
  000ee	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000f1	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000f4	83 e0 01	 and	 eax, 1
  000f7	f7 d8		 neg	 eax
  000f9	1b c0		 sbb	 eax, eax
  000fb	40		 inc	 eax
  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 _DwDbgAssert
  00102	83 c4 10	 add	 esp, 16			; 00000010H

; 1394 :         ASSERT(m_bPrdCount);

  00105	68 72 05 00 00	 push	 1394			; 00000572H
  0010a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  0010f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@CIAIIEJM@m_bPrdCount?$AA@
  00114	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	0f b6 51 24	 movzx	 edx, BYTE PTR [ecx+36]
  0011b	f7 da		 neg	 edx
  0011d	1b d2		 sbb	 edx, edx
  0011f	42		 inc	 edx
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 _DwDbgAssert
  00126	83 c4 10	 add	 esp, 16			; 00000010H

; 1395 :         
; 1396 :         m_dwFlags &= ~AC97CHANNEL_OBJECTF_DISCONTINUITY;

  00129	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0012c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0012f	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00132	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00135	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1397 : 
; 1398 :         m_bPrdCount--;

  00138	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0013b	8a 48 24	 mov	 cl, BYTE PTR [eax+36]
  0013e	80 e9 01	 sub	 cl, 1
  00141	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00144	88 4a 24	 mov	 BYTE PTR [edx+36], cl
$L32323:

; 1399 :     }
; 1400 : 
; 1401 :     //
; 1402 :     // Add the PRD to the end of the list.  We're assuming that the buffer
; 1403 :     // is already locked.
; 1404 :     //
; 1405 : 
; 1406 :     bPrdIndex = (m_bCurrentPrd + m_bPrdCount) & ACIPRDL_ENTRY_MASK;

  00147	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0014a	0f b6 48 25	 movzx	 ecx, BYTE PTR [eax+37]
  0014e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00151	0f b6 42 24	 movzx	 eax, BYTE PTR [edx+36]
  00155	03 c8		 add	 ecx, eax
  00157	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0015a	88 4d ff	 mov	 BYTE PTR _bPrdIndex$[ebp], cl

; 1407 : 
; 1408 :     m_pPrdl[bPrdIndex].dwPhysicalAddress = dwBufferAddress;

  0015d	0f b6 4d ff	 movzx	 ecx, BYTE PTR _bPrdIndex$[ebp]
  00161	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00164	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00167	8b 55 08	 mov	 edx, DWORD PTR _dwBufferAddress$[ebp]
  0016a	89 14 c8	 mov	 DWORD PTR [eax+ecx*8], edx

; 1409 :     m_pPrdl[bPrdIndex].wLength = LOWORD(dwBufferSize / (m_pDevice->m_wfxFormat.wBitsPerSample / 8));

  0016d	0f b7 05 0e 00
	00 00		 movzx	 eax, WORD PTR ?m_wfxFormat@CAc97Device@@2UtWAVEFORMATEX@@B+14
  00174	99		 cdq
  00175	83 e2 07	 and	 edx, 7
  00178	03 c2		 add	 eax, edx
  0017a	8b c8		 mov	 ecx, eax
  0017c	c1 f9 03	 sar	 ecx, 3
  0017f	8b 45 0c	 mov	 eax, DWORD PTR _dwBufferSize$[ebp]
  00182	33 d2		 xor	 edx, edx
  00184	f7 f1		 div	 ecx
  00186	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0018b	0f b7 d0	 movzx	 edx, ax
  0018e	0f b6 45 ff	 movzx	 eax, BYTE PTR _bPrdIndex$[ebp]
  00192	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00195	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00198	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0019e	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  001a2	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H
  001a7	0b c2		 or	 eax, edx
  001a9	0f b6 4d ff	 movzx	 ecx, BYTE PTR _bPrdIndex$[ebp]
  001ad	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  001b0	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  001b3	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 1410 :     m_pPrdl[bPrdIndex].wReserved = 0;

  001b7	0f b6 45 ff	 movzx	 eax, BYTE PTR _bPrdIndex$[ebp]
  001bb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001be	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001c1	8b 44 c2 04	 mov	 eax, DWORD PTR [edx+eax*8+4]
  001c5	25 ff ff 00 c0	 and	 eax, -1073676289	; c000ffffH
  001ca	0f b6 4d ff	 movzx	 ecx, BYTE PTR _bPrdIndex$[ebp]
  001ce	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  001d1	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  001d4	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 1411 :     m_pPrdl[bPrdIndex].fBufferUnderrunPolicy = TRUE;

  001d8	0f b6 45 ff	 movzx	 eax, BYTE PTR _bPrdIndex$[ebp]
  001dc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001df	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001e2	8b 44 c2 04	 mov	 eax, DWORD PTR [edx+eax*8+4]
  001e6	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  001eb	0f b6 4d ff	 movzx	 ecx, BYTE PTR _bPrdIndex$[ebp]
  001ef	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  001f2	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  001f5	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 1412 :     m_pPrdl[bPrdIndex].fInterruptOnCompletion = TRUE;

  001f9	0f b6 45 ff	 movzx	 eax, BYTE PTR _bPrdIndex$[ebp]
  001fd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00200	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00203	8b 44 c2 04	 mov	 eax, DWORD PTR [edx+eax*8+4]
  00207	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  0020c	0d 00 00 00 80	 or	 eax, -2147483648	; 80000000H
  00211	0f b6 4d ff	 movzx	 ecx, BYTE PTR _bPrdIndex$[ebp]
  00215	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00218	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  0021b	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 1413 : 
; 1414 :     DPF_AC97("(channel %lu) PRD %d set to %x %x", m_nChannelType, (int)bPrdIndex, m_pPrdl[bPrdIndex].dwPhysicalAddress, (DWORD)m_pPrdl[bPrdIndex].wLength);
; 1415 : 
; 1416 :     //
; 1417 :     // Inform the hardware that the last valid PRD has changed
; 1418 :     //
; 1419 : 
; 1420 :     SetPrdIndeces(m_bCurrentPrd, m_bPrdCount + 1, FALSE, TRUE);

  0021f	6a 01		 push	 1
  00221	6a 00		 push	 0
  00223	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00226	0f b6 48 24	 movzx	 ecx, BYTE PTR [eax+36]
  0022a	83 c1 01	 add	 ecx, 1
  0022d	51		 push	 ecx
  0022e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00231	8a 42 25	 mov	 al, BYTE PTR [edx+37]
  00234	50		 push	 eax
  00235	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00238	e8 00 00 00 00	 call	 ?SetPrdIndeces@CAc97Channel@@IAEXEEHH@Z ; CAc97Channel::SetPrdIndeces

; 1421 : 
; 1422 :     DPF_LEAVE_VOID();
; 1423 : }

  0023d	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00240	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  00245	8b e5		 mov	 esp, ebp
  00247	5d		 pop	 ebp
  00248	c2 08 00	 ret	 8
?AttachPacket@CAc97Channel@@QAEXKK@Z ENDP		; CAc97Channel::AttachPacket
DSOUND	ENDS
PUBLIC	??_C@_0CA@ODFENEBH@?$CB?$CIdwBufferSize?5?$CF?5dwPacketCount?$CJ?$AA@ ; `string'
PUBLIC	?AttachBuffer@CAc97Channel@@QAEXKKK@Z		; CAc97Channel::AttachBuffer
;	COMDAT ??_C@_0CA@ODFENEBH@?$CB?$CIdwBufferSize?5?$CF?5dwPacketCount?$CJ?$AA@
DSOUND_RD	SEGMENT
??_C@_0CA@ODFENEBH@?$CB?$CIdwBufferSize?5?$CF?5dwPacketCount?$CJ?$AA@ DB '!'
	DB	'(dwBufferSize % dwPacketCount)', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?AttachBuffer@CAc97Channel@@QAEXKKK@Z
DSOUND	SEGMENT
_this$ = -12
___AutoIrql$ = -8
_dwBufferAddress$ = 8
_dwBufferSize$ = 12
_dwPacketCount$ = 16
?AttachBuffer@CAc97Channel@@QAEXKKK@Z PROC NEAR		; CAc97Channel::AttachBuffer, COMDAT
; _this$ = ecx

; 1453 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 :     DPF_ENTER();
; 1455 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 1456 : 
; 1457 :     //
; 1458 :     // Attach the buffer in as many packets as were specified
; 1459 :     //
; 1460 : 
; 1461 :     ASSERT(!(dwBufferSize % dwPacketCount));

  00011	68 b5 05 00 00	 push	 1461			; 000005b5H
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@ODFENEBH@?$CB?$CIdwBufferSize?5?$CF?5dwPacketCount?$CJ?$AA@
  00020	8b 45 0c	 mov	 eax, DWORD PTR _dwBufferSize$[ebp]
  00023	33 d2		 xor	 edx, edx
  00025	f7 75 10	 div	 DWORD PTR _dwPacketCount$[ebp]
  00028	f7 da		 neg	 edx
  0002a	1b d2		 sbb	 edx, edx
  0002c	f7 da		 neg	 edx
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 _DwDbgAssert
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 1462 : 
; 1463 :     dwBufferSize /= dwPacketCount;

  00037	8b 45 0c	 mov	 eax, DWORD PTR _dwBufferSize$[ebp]
  0003a	33 d2		 xor	 edx, edx
  0003c	f7 75 10	 div	 DWORD PTR _dwPacketCount$[ebp]
  0003f	89 45 0c	 mov	 DWORD PTR _dwBufferSize$[ebp], eax
$L32337:

; 1464 : 
; 1465 :     while(dwPacketCount--)

  00042	8b 45 10	 mov	 eax, DWORD PTR _dwPacketCount$[ebp]
  00045	8b 4d 10	 mov	 ecx, DWORD PTR _dwPacketCount$[ebp]
  00048	83 e9 01	 sub	 ecx, 1
  0004b	89 4d 10	 mov	 DWORD PTR _dwPacketCount$[ebp], ecx
  0004e	85 c0		 test	 eax, eax
  00050	74 1b		 je	 SHORT $L32338

; 1466 :     {
; 1467 :         AttachPacket(dwBufferAddress, dwBufferSize);

  00052	8b 55 0c	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  00055	52		 push	 edx
  00056	8b 45 08	 mov	 eax, DWORD PTR _dwBufferAddress$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?AttachPacket@CAc97Channel@@QAEXKK@Z ; CAc97Channel::AttachPacket

; 1468 : 
; 1469 :         dwBufferAddress += dwBufferSize;

  00062	8b 4d 08	 mov	 ecx, DWORD PTR _dwBufferAddress$[ebp]
  00065	03 4d 0c	 add	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00068	89 4d 08	 mov	 DWORD PTR _dwBufferAddress$[ebp], ecx

; 1470 :     }

  0006b	eb d5		 jmp	 SHORT $L32337
$L32338:

; 1471 : 
; 1472 :     DPF_LEAVE_VOID();
; 1473 : }

  0006d	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00070	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
?AttachBuffer@CAc97Channel@@QAEXKKK@Z ENDP		; CAc97Channel::AttachBuffer
DSOUND	ENDS
PUBLIC	?AttachPacket@CAc97Channel@@QAEXPBXK@Z		; CAc97Channel::AttachPacket
PUBLIC	?Discontinuity@CAc97Channel@@QAEXXZ		; CAc97Channel::Discontinuity
; Function compile flags: /Odt
;	COMDAT ?Discontinuity@CAc97Channel@@QAEXXZ
DSOUND	SEGMENT
_this$ = -12
___AutoIrql$ = -8
?Discontinuity@CAc97Channel@@QAEXXZ PROC NEAR		; CAc97Channel::Discontinuity, COMDAT
; _this$ = ecx

; 1499 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1500 :     DPF_ENTER();
; 1501 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 1502 : 
; 1503 :     ASSERT(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM);

  00011	68 df 05 00 00	 push	 1503			; 000005dfH
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@NBJNCKCO@m_dwFlags?5?$CG?5AC97CHANNEL_OBJECTF_@
  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00026	83 e1 01	 and	 ecx, 1
  00029	f7 d9		 neg	 ecx
  0002b	1b c9		 sbb	 ecx, ecx
  0002d	41		 inc	 ecx
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 _DwDbgAssert
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 1504 : 
; 1505 :     //
; 1506 :     // Attach a packet of silence that the DMA can spin on when we starve.
; 1507 :     //
; 1508 : 
; 1509 :     if(!(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY))

  00037	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0003a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0003d	83 e0 02	 and	 eax, 2
  00040	85 c0		 test	 eax, eax
  00042	75 23		 jne	 SHORT $L32344

; 1510 :     {
; 1511 :         AttachPacket(m_pvSilence, m_dwSilenceSize);

  00044	68 00 20 00 00	 push	 8192			; 00002000H
  00049	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0004f	52		 push	 edx
  00050	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?AttachPacket@CAc97Channel@@QAEXPBXK@Z ; CAc97Channel::AttachPacket

; 1512 : 
; 1513 :         m_dwFlags |= AC97CHANNEL_OBJECTF_DISCONTINUITY;

  00058	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0005e	83 c9 02	 or	 ecx, 2
  00061	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00064	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$L32344:

; 1514 :     }
; 1515 : 
; 1516 :     DPF_LEAVE_VOID();
; 1517 : }

  00067	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0006a	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?Discontinuity@CAc97Channel@@QAEXXZ ENDP		; CAc97Channel::Discontinuity
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.h
DSOUND	ENDS
;	COMDAT ?AttachPacket@CAc97Channel@@QAEXPBXK@Z
DSOUND	SEGMENT
_this$ = -4
_pvBufferData$ = 8
_dwBufferSize$ = 12
?AttachPacket@CAc97Channel@@QAEXPBXK@Z PROC NEAR	; CAc97Channel::AttachPacket, COMDAT
; _this$ = ecx

; 418  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 419  :     AttachPacket(MmGetPhysicalAddress((LPVOID)pvBufferData), dwBufferSize);

  00007	8b 45 0c	 mov	 eax, DWORD PTR _dwBufferSize$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _pvBufferData$[ebp]
  0000e	51		 push	 ecx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmGetPhysicalAddress@4
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AttachPacket@CAc97Channel@@QAEXKK@Z ; CAc97Channel::AttachPacket

; 420  : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?AttachPacket@CAc97Channel@@QAEXPBXK@Z ENDP		; CAc97Channel::AttachPacket
DSOUND	ENDS
PUBLIC	??_C@_0BP@DKHIOCCO@CAc97Channel?3?3ServiceInterrupt?$AA@ ; `string'
PUBLIC	??_C@_0BG@HOPFFPKD@AC?897?5stream?5starving?$AA@ ; `string'
;	COMDAT ??_C@_0BP@DKHIOCCO@CAc97Channel?3?3ServiceInterrupt?$AA@
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.cpp
DSOUND_RD	SEGMENT
??_C@_0BP@DKHIOCCO@CAc97Channel?3?3ServiceInterrupt?$AA@ DB 'CAc97Channel'
	DB	'::ServiceInterrupt', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@HOPFFPKD@AC?897?5stream?5starving?$AA@
DSOUND_RD	SEGMENT
??_C@_0BG@HOPFFPKD@AC?897?5stream?5starving?$AA@ DB 'AC''97 stream starvi'
	DB	'ng', 00H					; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?ServiceInterrupt@CAc97Channel@@IAEXXZ
DSOUND	SEGMENT
_this$ = -4
?ServiceInterrupt@CAc97Channel@@IAEXXZ PROC NEAR	; CAc97Channel::ServiceInterrupt, COMDAT
; _this$ = ecx

; 1543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1544 :     DPF_ENTER();
; 1545 : 
; 1546 :     if(m_bPrdCount)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 48 24	 movzx	 ecx, BYTE PTR [eax+36]
  0000e	85 c9		 test	 ecx, ecx
  00010	0f 84 d9 00 00
	00		 je	 $L32348

; 1547 :     {
; 1548 :         //
; 1549 :         // A buffer has completed.  If we're a stream, we'll need to increment
; 1550 :         // the first PRD index and decrement the count in order to detach the
; 1551 :         // packet.
; 1552 :         //
; 1553 :         // If we're out of PRDs, stop the DMA.  This only happens because you
; 1554 :         // starved the stream.  Until we get a chance to stop the DMA, it's 
; 1555 :         // going to continue to play the last PRD over again.  If you know 
; 1556 :         // you're going to starve me, attach a packet of silence.
; 1557 :         //
; 1558 : 
; 1559 :         m_dwPosition += m_pPrdl[m_bCurrentPrd].wLength;

  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	0f b6 42 25	 movzx	 eax, BYTE PTR [edx+37]
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00023	8b 44 c2 04	 mov	 eax, DWORD PTR [edx+eax*8+4]
  00027	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00035	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1560 : 
; 1561 :         if(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM)

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0003e	83 e1 01	 and	 ecx, 1
  00041	85 c9		 test	 ecx, ecx
  00043	74 76		 je	 SHORT $L32350

; 1562 :         {
; 1563 :             if(m_bPrdCount > 2)

  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	0f b6 42 24	 movzx	 eax, BYTE PTR [edx+36]
  0004c	83 f8 02	 cmp	 eax, 2
  0004f	7e 24		 jle	 SHORT $L32351

; 1564 :             {
; 1565 :                 SetPrdIndeces(m_bCurrentPrd + 1, m_bPrdCount - 1, FALSE, FALSE);

  00051	6a 00		 push	 0
  00053	6a 00		 push	 0
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	0f b6 51 24	 movzx	 edx, BYTE PTR [ecx+36]
  0005c	83 ea 01	 sub	 edx, 1
  0005f	52		 push	 edx
  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	0f b6 48 25	 movzx	 ecx, BYTE PTR [eax+37]
  00067	83 c1 01	 add	 ecx, 1
  0006a	51		 push	 ecx
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?SetPrdIndeces@CAc97Channel@@IAEXEEHH@Z ; CAc97Channel::SetPrdIndeces

; 1566 :             }
; 1567 :             else

  00073	eb 44		 jmp	 SHORT $L32352
$L32351:

; 1568 :             {
; 1569 :                 if(!(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY))

  00075	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00078	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0007b	83 e0 02	 and	 eax, 2
  0007e	85 c0		 test	 eax, eax
  00080	75 2d		 jne	 SHORT $L32353

; 1570 :                 {
; 1571 :                     DPF_WARNING("AC'97 stream starving");

  00082	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  00087	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DKHIOCCO@CAc97Channel?3?3ServiceInterrupt?$AA@
  0008c	68 23 06 00 00	 push	 1571			; 00000623H
  00091	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  00096	6a 03		 push	 3
  00098	6a 09		 push	 9
  0009a	e8 00 00 00 00	 call	 _DwDbgSetContext
  0009f	83 c4 18	 add	 esp, 24			; 00000018H
  000a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@HOPFFPKD@AC?897?5stream?5starving?$AA@
  000a7	e8 00 00 00 00	 call	 _DwDbgPrint
  000ac	83 c4 04	 add	 esp, 4
$L32353:

; 1572 :                 }
; 1573 :                 
; 1574 :                 Flush(FALSE);

  000af	6a 00		 push	 0
  000b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e8 00 00 00 00	 call	 ?Flush@CAc97Channel@@QAEXH@Z ; CAc97Channel::Flush
$L32352:

; 1575 :             }
; 1576 :         }
; 1577 :         else

  000b9	eb 1e		 jmp	 SHORT $L32356
$L32350:

; 1578 :         {
; 1579 :             SetPrdIndeces(m_bCurrentPrd + 1, m_bPrdCount, FALSE, FALSE);

  000bb	6a 00		 push	 0
  000bd	6a 00		 push	 0
  000bf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c2	8a 51 24	 mov	 dl, BYTE PTR [ecx+36]
  000c5	52		 push	 edx
  000c6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	0f b6 48 25	 movzx	 ecx, BYTE PTR [eax+37]
  000cd	83 c1 01	 add	 ecx, 1
  000d0	51		 push	 ecx
  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	e8 00 00 00 00	 call	 ?SetPrdIndeces@CAc97Channel@@IAEXEEHH@Z ; CAc97Channel::SetPrdIndeces
$L32356:

; 1580 :         }
; 1581 : 
; 1582 :         //
; 1583 :         // Notify the callback function
; 1584 :         //
; 1585 : 
; 1586 :         if(m_pfnCallback)

  000d9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000dc	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  000e0	74 0d		 je	 SHORT $L32348

; 1587 :         {
; 1588 :             m_pfnCallback(m_pvCallbackContext);

  000e2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e5	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000e8	51		 push	 ecx
  000e9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ec	ff 52 10	 call	 DWORD PTR [edx+16]
$L32348:

; 1589 :         }
; 1590 :     }
; 1591 : 
; 1592 :     DPF_LEAVE_VOID();
; 1593 : }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c3		 ret	 0
?ServiceInterrupt@CAc97Channel@@IAEXXZ ENDP		; CAc97Channel::ServiceInterrupt
DSOUND	ENDS
PUBLIC	?PeekAciRegister8@CAc97Channel@@IAEEK@Z		; CAc97Channel::PeekAciRegister8
PUBLIC	?PokeAciRegister8@CAc97Channel@@IAEXKE@Z	; CAc97Channel::PokeAciRegister8
PUBLIC	?PokeAciRegister32@CAc97Channel@@IAEXKK@Z	; CAc97Channel::PokeAciRegister32
; Function compile flags: /Odt
;	COMDAT ?Reset@CAc97Channel@@QAEXXZ
DSOUND	SEGMENT
_this$ = -12
___AutoIrql$ = -8
?Reset@CAc97Channel@@QAEXXZ PROC NEAR			; CAc97Channel::Reset, COMDAT
; _this$ = ecx

; 1619 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1620 :     DPF_ENTER();
; 1621 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 1622 : 
; 1623 :     DPF_AC97("(channel %lu) Resetting DMA registers", m_nChannelType);
; 1624 : 
; 1625 :     //
; 1626 :     // Reset the channel
; 1627 :     //
; 1628 : 
; 1629 :     PokeAciRegister8(X_CTRL, X_CTRL_RBMR);

  00011	6a 02		 push	 2
  00013	6a 0b		 push	 11			; 0000000bH
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?PokeAciRegister8@CAc97Channel@@IAEXKE@Z ; CAc97Channel::PokeAciRegister8
$L32364:

; 1630 : 
; 1631 :     //
; 1632 :     // Wait for the reset to be acknowledged
; 1633 :     //
; 1634 : 
; 1635 :     while(PeekAciRegister8(X_CTRL) & X_CTRL_RBMR);

  0001d	6a 0b		 push	 11			; 0000000bH
  0001f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?PeekAciRegister8@CAc97Channel@@IAEEK@Z ; CAc97Channel::PeekAciRegister8
  00027	0f b6 c0	 movzx	 eax, al
  0002a	83 e0 02	 and	 eax, 2
  0002d	85 c0		 test	 eax, eax
  0002f	74 02		 je	 SHORT $L32365
  00031	eb ea		 jmp	 SHORT $L32364
$L32365:

; 1636 : 
; 1637 :     //
; 1638 :     // Set the PRDL location
; 1639 :     //
; 1640 : 
; 1641 :     PokeAciRegister32(X_BL_BASE, m_dwPrdlAddress);

  00033	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00039	52		 push	 edx
  0003a	6a 00		 push	 0
  0003c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Channel@@IAEXKK@Z ; CAc97Channel::PokeAciRegister32

; 1642 : 
; 1643 :     //
; 1644 :     // If this is the S/PDIF channel, set the output mode
; 1645 :     //
; 1646 : 
; 1647 :     if(AC97_CHANNELTYPE_DIGITAL == m_nChannelType)

  00044	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00047	83 38 01	 cmp	 DWORD PTR [eax], 1
  0004a	75 11		 jne	 SHORT $L32366

; 1648 :     {
; 1649 :         PokeAciRegister32(X_STWD, m_dwMode);

  0004c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00052	52		 push	 edx
  00053	6a 0c		 push	 12			; 0000000cH
  00055	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Channel@@IAEXKK@Z ; CAc97Channel::PokeAciRegister32
$L32366:

; 1650 :     }
; 1651 : 
; 1652 :     //
; 1653 :     // Reset PRD indeces
; 1654 :     //
; 1655 : 
; 1656 :     SetPrdIndeces(m_bCurrentPrd, m_bPrdCount, TRUE, TRUE);

  0005d	6a 01		 push	 1
  0005f	6a 01		 push	 1
  00061	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8a 48 24	 mov	 cl, BYTE PTR [eax+36]
  00067	51		 push	 ecx
  00068	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	8a 42 25	 mov	 al, BYTE PTR [edx+37]
  0006e	50		 push	 eax
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?SetPrdIndeces@CAc97Channel@@IAEXEEHH@Z ; CAc97Channel::SetPrdIndeces

; 1657 : 
; 1658 :     DPF_LEAVE_VOID();
; 1659 : }

  00077	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0007a	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?Reset@CAc97Channel@@QAEXXZ ENDP			; CAc97Channel::Reset
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.h
DSOUND	ENDS
;	COMDAT ?PeekAciRegister8@CAc97Channel@@IAEEK@Z
DSOUND	SEGMENT
_this$ = -4
_dwRegister$ = 8
?PeekAciRegister8@CAc97Channel@@IAEEK@Z PROC NEAR	; CAc97Channel::PeekAciRegister8, COMDAT
; _this$ = ecx

; 433  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  :     return m_pDevice->PeekAciRegister8(dwRegister + m_adwRegisterOffsets[m_nChannelType]);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 55 08	 mov	 edx, DWORD PTR _dwRegister$[ebp]
  0000f	03 14 8d 00 00
	00 00		 add	 edx, DWORD PTR ?m_adwRegisterOffsets@CAc97Channel@@2QBKB[ecx*4]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 ?PeekAciRegister8@CAc97Device@@KGEK@Z ; CAc97Device::PeekAciRegister8

; 435  : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?PeekAciRegister8@CAc97Channel@@IAEEK@Z ENDP		; CAc97Channel::PeekAciRegister8
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PokeAciRegister8@CAc97Channel@@IAEXKE@Z
DSOUND	SEGMENT
_this$ = -4
_dwRegister$ = 8
_bValue$ = 12
?PokeAciRegister8@CAc97Channel@@IAEXKE@Z PROC NEAR	; CAc97Channel::PokeAciRegister8, COMDAT
; _this$ = ecx

; 438  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 439  :     m_pDevice->PokeAciRegister8(dwRegister + m_adwRegisterOffsets[m_nChannelType], bValue);

  00007	8a 45 0c	 mov	 al, BYTE PTR _bValue$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00013	03 04 95 00 00
	00 00		 add	 eax, DWORD PTR ?m_adwRegisterOffsets@CAc97Channel@@2QBKB[edx*4]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PokeAciRegister8@CAc97Device@@KGXKE@Z ; CAc97Device::PokeAciRegister8

; 440  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?PokeAciRegister8@CAc97Channel@@IAEXKE@Z ENDP		; CAc97Channel::PokeAciRegister8
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PokeAciRegister32@CAc97Channel@@IAEXKK@Z
DSOUND	SEGMENT
_this$ = -4
_dwRegister$ = 8
_dwValue$ = 12
?PokeAciRegister32@CAc97Channel@@IAEXKK@Z PROC NEAR	; CAc97Channel::PokeAciRegister32, COMDAT
; _this$ = ecx

; 458  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 459  :     m_pDevice->PokeAciRegister32(dwRegister + m_adwRegisterOffsets[m_nChannelType], dwValue);

  00007	8b 45 0c	 mov	 eax, DWORD PTR _dwValue$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00013	03 04 95 00 00
	00 00		 add	 eax, DWORD PTR ?m_adwRegisterOffsets@CAc97Channel@@2QBKB[edx*4]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Device@@KGXKK@Z ; CAc97Device::PokeAciRegister32

; 460  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?PokeAciRegister32@CAc97Channel@@IAEXKK@Z ENDP		; CAc97Channel::PokeAciRegister32
DSOUND	ENDS
PUBLIC	?Pause@CAc97Channel@@QAEXXZ			; CAc97Channel::Pause
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ac97.cpp
;	COMDAT ?Flush@CAc97Channel@@QAEXH@Z
DSOUND	SEGMENT
_this$ = -16
___AutoIrql$ = -12
_fResetPosition$ = 8
?Flush@CAc97Channel@@QAEXH@Z PROC NEAR			; CAc97Channel::Flush, COMDAT
; _this$ = ecx

; 1685 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1686 :     BYTE                    bState;
; 1687 : 
; 1688 :     DPF_ENTER();
; 1689 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 1690 : 
; 1691 :     //
; 1692 :     // Stop the DMA
; 1693 :     //
; 1694 :     
; 1695 :     Pause();

  00011	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Pause@CAc97Channel@@QAEXXZ ; CAc97Channel::Pause

; 1696 : 
; 1697 :     //
; 1698 :     // Reset the channel
; 1699 :     //
; 1700 : 
; 1701 :     Reset();

  00019	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?Reset@CAc97Channel@@QAEXXZ ; CAc97Channel::Reset

; 1702 : 
; 1703 :     //
; 1704 :     // Update PRD indeces
; 1705 :     //
; 1706 : 
; 1707 :     SetPrdIndeces(0, 0, TRUE, TRUE);

  00021	6a 01		 push	 1
  00023	6a 01		 push	 1
  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?SetPrdIndeces@CAc97Channel@@IAEXEEHH@Z ; CAc97Channel::SetPrdIndeces

; 1708 : 
; 1709 :     //
; 1710 :     // Remove any existing discontinuity
; 1711 :     //
; 1712 : 
; 1713 :     m_dwFlags &= ~AC97CHANNEL_OBJECTF_DISCONTINUITY;

  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00037	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0003a	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1714 : 
; 1715 :     //
; 1716 :     // Reset stored positions
; 1717 :     //
; 1718 : 
; 1719 :     if(fResetPosition)

  00040	83 7d 08 00	 cmp	 DWORD PTR _fResetPosition$[ebp], 0
  00044	74 14		 je	 SHORT $L32373

; 1720 :     {
; 1721 :         m_dwPosition = 0;

  00046	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00049	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1722 :         m_dwLastPosition = 0;

  00050	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
$L32373:

; 1723 :     }
; 1724 : 
; 1725 :     DPF_LEAVE_VOID();
; 1726 : }

  0005a	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0005d	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?Flush@CAc97Channel@@QAEXH@Z ENDP			; CAc97Channel::Flush
DSOUND	ENDS
PUBLIC	?Run@CAc97Channel@@QAEXK@Z			; CAc97Channel::Run
PUBLIC	?SetPosition@CAc97Channel@@IAEXK@Z		; CAc97Channel::SetPosition
; Function compile flags: /Odt
;	COMDAT ?Run@CAc97Channel@@QAEXK@Z
DSOUND	SEGMENT
_this$ = -12
___AutoIrql$ = -8
_dwPosition$ = 8
?Run@CAc97Channel@@QAEXK@Z PROC NEAR			; CAc97Channel::Run, COMDAT
; _this$ = ecx

; 1752 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1753 :     DPF_ENTER();
; 1754 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 1755 : 
; 1756 :     ASSERT(m_bPrdCount);

  00011	68 dc 06 00 00	 push	 1756			; 000006dcH
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@CIAIIEJM@m_bPrdCount?$AA@
  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00023	0f b6 48 24	 movzx	 ecx, BYTE PTR [eax+36]
  00027	f7 d9		 neg	 ecx
  00029	1b c9		 sbb	 ecx, ecx
  0002b	41		 inc	 ecx
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _DwDbgAssert
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 1757 : 
; 1758 :     //
; 1759 :     // Check the channel status.  If the DMA is halted, we'll have to
; 1760 :     // reset before we can run.
; 1761 :     //
; 1762 : 
; 1763 :     if(PeekAciRegister16(X_STATUS) & X_STATUS_DCH)

  00035	6a 06		 push	 6
  00037	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?PeekAciRegister16@CAc97Channel@@IAEGK@Z ; CAc97Channel::PeekAciRegister16
  0003f	0f b7 d0	 movzx	 edx, ax
  00042	83 e2 01	 and	 edx, 1
  00045	85 d2		 test	 edx, edx
  00047	74 08		 je	 SHORT $L32379

; 1764 :     {
; 1765 :         Reset();

  00049	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?Reset@CAc97Channel@@QAEXXZ ; CAc97Channel::Reset
$L32379:

; 1766 :     }
; 1767 : 
; 1768 :     //
; 1769 :     // Set the buffer position
; 1770 :     //
; 1771 : 
; 1772 :     if(-1 != dwPosition)

  00051	83 7d 08 ff	 cmp	 DWORD PTR _dwPosition$[ebp], -1
  00055	74 0c		 je	 SHORT $L32380

; 1773 :     {
; 1774 :         SetPosition(dwPosition);

  00057	8b 45 08	 mov	 eax, DWORD PTR _dwPosition$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?SetPosition@CAc97Channel@@IAEXK@Z ; CAc97Channel::SetPosition
$L32380:

; 1775 :     }
; 1776 : 
; 1777 :     //
; 1778 :     // Set the channel to RUN state and enable interrupts
; 1779 :     //
; 1780 : 
; 1781 :     PokeAciRegister8(X_CTRL, X_CTRL_IOCE | X_CTRL_FEIE | X_CTRL_LVBIE | X_CTRL_RPBM);

  00063	6a 1d		 push	 29			; 0000001dH
  00065	6a 0b		 push	 11			; 0000000bH
  00067	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?PokeAciRegister8@CAc97Channel@@IAEXKE@Z ; CAc97Channel::PokeAciRegister8

; 1782 : 
; 1783 :     DPF_LEAVE_VOID();
; 1784 : }

  0006f	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00072	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
?Run@CAc97Channel@@QAEXK@Z ENDP				; CAc97Channel::Run
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?Pause@CAc97Channel@@QAEXXZ
DSOUND	SEGMENT
_this$ = -12
___AutoIrql$ = -8
?Pause@CAc97Channel@@QAEXXZ PROC NEAR			; CAc97Channel::Pause, COMDAT
; _this$ = ecx

; 1810 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1811 :     DPF_ENTER();
; 1812 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 1813 : 
; 1814 :     PokeAciRegister8(X_CTRL, 0);

  00011	6a 00		 push	 0
  00013	6a 0b		 push	 11			; 0000000bH
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?PokeAciRegister8@CAc97Channel@@IAEXKE@Z ; CAc97Channel::PokeAciRegister8

; 1815 : 
; 1816 :     DPF_LEAVE_VOID();
; 1817 : }

  0001d	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00020	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?Pause@CAc97Channel@@QAEXXZ ENDP			; CAc97Channel::Pause
DSOUND	ENDS
PUBLIC	??_C@_0CB@JMNBEPBG@bPrdCount?5?$DM?$DN?5ACIPRDL_ENTRY_COUNT@ ; `string'
;	COMDAT ??_C@_0CB@JMNBEPBG@bPrdCount?5?$DM?$DN?5ACIPRDL_ENTRY_COUNT@
DSOUND_RD	SEGMENT
??_C@_0CB@JMNBEPBG@bPrdCount?5?$DM?$DN?5ACIPRDL_ENTRY_COUNT@ DB 'bPrdCoun'
	DB	't <= ACIPRDL_ENTRY_COUNT', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?SetPrdIndeces@CAc97Channel@@IAEXEEHH@Z
DSOUND	SEGMENT
_this$ = -16
___AutoIrql$ = -12
_bLastPrd$ = -1
_bCurrentPrd$ = 8
_bPrdCount$ = 12
_fApplyCurrent$ = 16
_fApplyLast$ = 20
?SetPrdIndeces@CAc97Channel@@IAEXEEHH@Z PROC NEAR	; CAc97Channel::SetPrdIndeces, COMDAT
; _this$ = ecx

; 1850 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1851 :     BYTE                    bLastPrd;
; 1852 :     
; 1853 :     DPF_ENTER();
; 1854 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 1855 : 
; 1856 :     //
; 1857 :     // Calculate the current and last valid PRDs
; 1858 :     //
; 1859 : 
; 1860 :     if(bPrdCount)

  00011	0f b6 45 0c	 movzx	 eax, BYTE PTR _bPrdCount$[ebp]
  00015	85 c0		 test	 eax, eax
  00017	74 74		 je	 SHORT $L32395

; 1861 :     {
; 1862 :         ASSERT(bPrdCount <= ACIPRDL_ENTRY_COUNT);

  00019	68 46 07 00 00	 push	 1862			; 00000746H
  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  00023	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@JMNBEPBG@bPrdCount?5?$DM?$DN?5ACIPRDL_ENTRY_COUNT@
  00028	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bPrdCount$[ebp]
  0002c	33 d2		 xor	 edx, edx
  0002e	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00031	0f 9f c2	 setg	 dl
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 _DwDbgAssert
  0003a	83 c4 10	 add	 esp, 16			; 00000010H

; 1863 : 
; 1864 :         bLastPrd = bCurrentPrd + bPrdCount - 1;

  0003d	0f b6 45 08	 movzx	 eax, BYTE PTR _bCurrentPrd$[ebp]
  00041	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bPrdCount$[ebp]
  00045	8d 54 08 ff	 lea	 edx, DWORD PTR [eax+ecx-1]
  00049	88 55 ff	 mov	 BYTE PTR _bLastPrd$[ebp], dl

; 1865 : 
; 1866 :         if(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM)

  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00052	83 e1 01	 and	 ecx, 1
  00055	85 c9		 test	 ecx, ecx
  00057	74 16		 je	 SHORT $L32397

; 1867 :         {
; 1868 :             bCurrentPrd &= ACIPRDL_ENTRY_MASK;

  00059	0f b6 55 08	 movzx	 edx, BYTE PTR _bCurrentPrd$[ebp]
  0005d	83 e2 1f	 and	 edx, 31			; 0000001fH
  00060	88 55 08	 mov	 BYTE PTR _bCurrentPrd$[ebp], dl

; 1869 :             bLastPrd &= ACIPRDL_ENTRY_MASK;

  00063	0f b6 45 ff	 movzx	 eax, BYTE PTR _bLastPrd$[ebp]
  00067	83 e0 1f	 and	 eax, 31			; 0000001fH
  0006a	88 45 ff	 mov	 BYTE PTR _bLastPrd$[ebp], al

; 1870 :         }
; 1871 :         else

  0006d	eb 1c		 jmp	 SHORT $L32398
$L32397:

; 1872 :         {
; 1873 :             bCurrentPrd %= bPrdCount;

  0006f	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bPrdCount$[ebp]
  00073	0f b6 45 08	 movzx	 eax, BYTE PTR _bCurrentPrd$[ebp]
  00077	99		 cdq
  00078	f7 f9		 idiv	 ecx
  0007a	88 55 08	 mov	 BYTE PTR _bCurrentPrd$[ebp], dl

; 1874 :             bLastPrd %= bPrdCount;

  0007d	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bPrdCount$[ebp]
  00081	0f b6 45 ff	 movzx	 eax, BYTE PTR _bLastPrd$[ebp]
  00085	99		 cdq
  00086	f7 f9		 idiv	 ecx
  00088	88 55 ff	 mov	 BYTE PTR _bLastPrd$[ebp], dl
$L32398:

; 1875 :         }
; 1876 :     }
; 1877 :     else

  0008b	eb 08		 jmp	 SHORT $L32399
$L32395:

; 1878 :     {
; 1879 :         bCurrentPrd = 0;

  0008d	c6 45 08 00	 mov	 BYTE PTR _bCurrentPrd$[ebp], 0

; 1880 :         bLastPrd = 0;

  00091	c6 45 ff 00	 mov	 BYTE PTR _bLastPrd$[ebp], 0
$L32399:

; 1881 :     }
; 1882 : 
; 1883 :     //
; 1884 :     // Inform the hardware
; 1885 :     //
; 1886 :     
; 1887 :     if(fApplyCurrent)

  00095	83 7d 10 00	 cmp	 DWORD PTR _fApplyCurrent$[ebp], 0
  00099	74 0e		 je	 SHORT $L32400

; 1888 :     {
; 1889 :         PokeAciRegister8(X_CUR_IDX, bCurrentPrd);

  0009b	8a 55 08	 mov	 dl, BYTE PTR _bCurrentPrd$[ebp]
  0009e	52		 push	 edx
  0009f	6a 04		 push	 4
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	e8 00 00 00 00	 call	 ?PokeAciRegister8@CAc97Channel@@IAEXKE@Z ; CAc97Channel::PokeAciRegister8
$L32400:

; 1890 :     }
; 1891 : 
; 1892 :     if(fApplyLast)

  000a9	83 7d 14 00	 cmp	 DWORD PTR _fApplyLast$[ebp], 0
  000ad	74 0e		 je	 SHORT $L32401

; 1893 :     {
; 1894 :         PokeAciRegister8(X_LST_IDX, bLastPrd);

  000af	8a 45 ff	 mov	 al, BYTE PTR _bLastPrd$[ebp]
  000b2	50		 push	 eax
  000b3	6a 05		 push	 5
  000b5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?PokeAciRegister8@CAc97Channel@@IAEXKE@Z ; CAc97Channel::PokeAciRegister8
$L32401:

; 1895 :     }
; 1896 : 
; 1897 :     m_bCurrentPrd = bCurrentPrd;

  000bd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	8a 55 08	 mov	 dl, BYTE PTR _bCurrentPrd$[ebp]
  000c3	88 51 25	 mov	 BYTE PTR [ecx+37], dl

; 1898 :     m_bPrdCount = bPrdCount;

  000c6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	8a 4d 0c	 mov	 cl, BYTE PTR _bPrdCount$[ebp]
  000cc	88 48 24	 mov	 BYTE PTR [eax+36], cl

; 1899 : 
; 1900 :     DPF_AC97("(channel %lu) PRD indeces set to %d, %d (%d)", m_nChannelType, (int)bCurrentPrd, (int)bLastPrd, (int)bPrdCount);
; 1901 : 
; 1902 :     DPF_LEAVE_VOID();
; 1903 : }

  000cf	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000d2	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c2 10 00	 ret	 16			; 00000010H
?SetPrdIndeces@CAc97Channel@@IAEXEEHH@Z ENDP		; CAc97Channel::SetPrdIndeces
DSOUND	ENDS
PUBLIC	?SetMode@CAc97Channel@@QAEXK@Z			; CAc97Channel::SetMode
; Function compile flags: /Odt
;	COMDAT ?SetMode@CAc97Channel@@QAEXK@Z
DSOUND	SEGMENT
_this$ = -16
___AutoIrql$ = -12
_dwMode$ = 8
?SetMode@CAc97Channel@@QAEXK@Z PROC NEAR		; CAc97Channel::SetMode, COMDAT
; _this$ = ecx

; 1929 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1930 :     BYTE                    bState;
; 1931 :     
; 1932 :     DPF_ENTER();
; 1933 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 1934 : 
; 1935 :     if(AC97_CHANNELTYPE_DIGITAL == m_nChannelType)

  00011	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00014	83 38 01	 cmp	 DWORD PTR [eax], 1
  00017	75 1a		 jne	 SHORT $L32408

; 1936 :     {
; 1937 :         //
; 1938 :         // Save the mode
; 1939 :         //
; 1940 : 
; 1941 :         m_dwMode = dwMode;

  00019	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 55 08	 mov	 edx, DWORD PTR _dwMode$[ebp]
  0001f	89 51 28	 mov	 DWORD PTR [ecx+40], edx

; 1942 : 
; 1943 :         //
; 1944 :         // Update the STWD register
; 1945 :         //
; 1946 : 
; 1947 :         PokeAciRegister32(X_STWD, m_dwMode);

  00022	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00028	51		 push	 ecx
  00029	6a 0c		 push	 12			; 0000000cH
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Channel@@IAEXKK@Z ; CAc97Channel::PokeAciRegister32
$L32408:

; 1948 :     }
; 1949 : 
; 1950 :     DPF_LEAVE_VOID();
; 1951 : }

  00033	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00036	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?SetMode@CAc97Channel@@QAEXK@Z ENDP			; CAc97Channel::SetMode
DSOUND	ENDS
PUBLIC	??_C@_0CP@DOECGKNM@Improperly?5looping?5on?5the?5discon@ ; `string'
PUBLIC	?GetPosition@CAc97Channel@@QAEKXZ		; CAc97Channel::GetPosition
;	COMDAT ??_C@_0CP@DOECGKNM@Improperly?5looping?5on?5the?5discon@
DSOUND_RD	SEGMENT
??_C@_0CP@DOECGKNM@Improperly?5looping?5on?5the?5discon@ DB 'Improperly l'
	DB	'ooping on the discontinuity packet', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?GetPosition@CAc97Channel@@QAEKXZ
DSOUND	SEGMENT
_this$ = -24
_iTry$32418 = -20
_dwPosition$ = -16
_dwLength$ = -12
_bCurrentPrd$ = -5
_dwLastPosition$ = -4
?GetPosition@CAc97Channel@@QAEKXZ PROC NEAR		; CAc97Channel::GetPosition, COMDAT
; _this$ = ecx

; 1979 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1980 :     DWORD               dwLastPosition;
; 1981 :     DWORD               dwPosition;
; 1982 :     DWORD               dwLength;
; 1983 :     BYTE                bCurrentPrd;
; 1984 :         
; 1985 :     DPF_ENTER();
; 1986 : 
; 1987 :     if(m_bPrdCount)

  00009	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 24	 movzx	 ecx, BYTE PTR [eax+36]
  00010	85 c9		 test	 ecx, ecx
  00012	0f 84 42 01 00
	00		 je	 $L32417

; 1988 :     {
; 1989 :         //
; 1990 :         // Calculate the position until we get the same position twice.
; 1991 :         // That way, we don't have to synchronize this function with the
; 1992 :         // ISR.
; 1993 :         //
; 1994 :     
; 1995 :         dwPosition = -1;

  00018	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _dwPosition$[ebp], -1

; 1996 : 
; 1997 :         int iTry = 0;

  0001f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iTry$32418[ebp], 0
$L32420:

; 1998 : 
; 1999 :         while(TRUE)

  00026	ba 01 00 00 00	 mov	 edx, 1
  0002b	85 d2		 test	 edx, edx
  0002d	0f 84 25 01 00
	00		 je	 $L32421

; 2000 :         {
; 2001 :             iTry++;

  00033	8b 45 ec	 mov	 eax, DWORD PTR _iTry$32418[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	89 45 ec	 mov	 DWORD PTR _iTry$32418[ebp], eax

; 2002 :             
; 2003 :             //
; 2004 :             // Save the last position we got
; 2005 :             //
; 2006 : 
; 2007 :             dwLastPosition = dwPosition;

  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _dwPosition$[ebp]
  0003f	89 4d fc	 mov	 DWORD PTR _dwLastPosition$[ebp], ecx

; 2008 : 
; 2009 :             //
; 2010 :             // Check the PRD index register and compare it to our own index.
; 2011 :             // There seems to be some delay between when the DMA program
; 2012 :             // changes PRDs and when we get notified.
; 2013 :             //
; 2014 : 
; 2015 :             if((bCurrentPrd = PeekAciRegister8(X_CUR_IDX)) == m_bCurrentPrd)

  00042	6a 04		 push	 4
  00044	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?PeekAciRegister8@CAc97Channel@@IAEEK@Z ; CAc97Channel::PeekAciRegister8
  0004c	88 45 fb	 mov	 BYTE PTR _bCurrentPrd$[ebp], al
  0004f	0f b6 55 fb	 movzx	 edx, BYTE PTR _bCurrentPrd$[ebp]
  00053	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	0f b6 48 25	 movzx	 ecx, BYTE PTR [eax+37]
  0005a	3b d1		 cmp	 edx, ecx
  0005c	0f 85 94 00 00
	00		 jne	 $L32422

; 2016 :             {
; 2017 : 
; 2018 : #ifdef DEBUG
; 2019 :                 //
; 2020 :                 // Since they're in sync, we should never be playing the
; 2021 :                 // discontinuity packet.
; 2022 :                 //
; 2023 : 
; 2024 :                 if(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY)

  00062	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00065	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00068	83 e0 02	 and	 eax, 2
  0006b	85 c0		 test	 eax, eax
  0006d	74 41		 je	 SHORT $L32423

; 2025 :                 {
; 2026 :                     if(m_bPrdCount <= 1)

  0006f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	0f b6 51 24	 movzx	 edx, BYTE PTR [ecx+36]
  00076	83 fa 01	 cmp	 edx, 1
  00079	7f 35		 jg	 SHORT $L32423

; 2027 :                     {
; 2028 :                         if((bCurrentPrd = PeekAciRegister8(X_CUR_IDX)) == m_bCurrentPrd)

  0007b	6a 04		 push	 4
  0007d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?PeekAciRegister8@CAc97Channel@@IAEEK@Z ; CAc97Channel::PeekAciRegister8
  00085	88 45 fb	 mov	 BYTE PTR _bCurrentPrd$[ebp], al
  00088	0f b6 45 fb	 movzx	 eax, BYTE PTR _bCurrentPrd$[ebp]
  0008c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	0f b6 51 25	 movzx	 edx, BYTE PTR [ecx+37]
  00093	3b c2		 cmp	 eax, edx
  00095	75 19		 jne	 SHORT $L32423

; 2029 :                         {
; 2030 :                             ASSERTMSG("Improperly looping on the discontinuity packet");

  00097	68 ee 07 00 00	 push	 2030			; 000007eeH
  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  000a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@DOECGKNM@Improperly?5looping?5on?5the?5discon@
  000a6	6a 01		 push	 1
  000a8	e8 00 00 00 00	 call	 _DwDbgAssert
  000ad	83 c4 10	 add	 esp, 16			; 00000010H
$L32423:

; 2031 :                         }
; 2032 :                     }
; 2033 :                 }
; 2034 : 
; 2035 : #endif // DEBUG
; 2036 : 
; 2037 :                 //
; 2038 :                 // The position in the ACI register is really the count of samples 
; 2039 :                 // left to transfer.
; 2040 :                 //
; 2041 : 
; 2042 :                 dwLength = m_pPrdl[m_bCurrentPrd].wLength;

  000b0	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	0f b6 48 25	 movzx	 ecx, BYTE PTR [eax+37]
  000b7	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000ba	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000bd	8b 4c c8 04	 mov	 ecx, DWORD PTR [eax+ecx*8+4]
  000c1	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000c7	89 4d f4	 mov	 DWORD PTR _dwLength$[ebp], ecx

; 2043 : 
; 2044 :                 dwPosition = PeekAciRegister16(X_CUR_POS);

  000ca	6a 08		 push	 8
  000cc	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	e8 00 00 00 00	 call	 ?PeekAciRegister16@CAc97Channel@@IAEGK@Z ; CAc97Channel::PeekAciRegister16
  000d4	0f b7 d0	 movzx	 edx, ax
  000d7	89 55 f0	 mov	 DWORD PTR _dwPosition$[ebp], edx

; 2045 : 
; 2046 :                 if(dwPosition <= dwLength)

  000da	8b 45 f0	 mov	 eax, DWORD PTR _dwPosition$[ebp]
  000dd	3b 45 f4	 cmp	 eax, DWORD PTR _dwLength$[ebp]
  000e0	77 0b		 ja	 SHORT $L32427

; 2047 :                 {
; 2048 :                     dwPosition = dwLength - dwPosition;

  000e2	8b 4d f4	 mov	 ecx, DWORD PTR _dwLength$[ebp]
  000e5	2b 4d f0	 sub	 ecx, DWORD PTR _dwPosition$[ebp]
  000e8	89 4d f0	 mov	 DWORD PTR _dwPosition$[ebp], ecx

; 2049 :                 }
; 2050 :                 else

  000eb	eb 07		 jmp	 SHORT $L32428
$L32427:

; 2051 :                 {
; 2052 :                     dwPosition = 0;

  000ed	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwPosition$[ebp], 0
$L32428:

; 2053 :                 }
; 2054 :             }
; 2055 :             else

  000f4	eb 19		 jmp	 SHORT $L32429
$L32422:

; 2056 :             {
; 2057 :                 //
; 2058 :                 // Our internal state and the hardware's aren't in synch.  Simply
; 2059 :                 // return that we're at the end of the current packet
; 2060 :                 //
; 2061 : 
; 2062 :                 dwPosition = m_pPrdl[m_bCurrentPrd].wLength;

  000f6	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	0f b6 42 25	 movzx	 eax, BYTE PTR [edx+37]
  000fd	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00103	8b 44 c2 04	 mov	 eax, DWORD PTR [edx+eax*8+4]
  00107	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0010c	89 45 f0	 mov	 DWORD PTR _dwPosition$[ebp], eax
$L32429:

; 2063 :             }
; 2064 : 
; 2065 :             //
; 2066 :             // Add the absolute stream position.  If you're a buffer, well, you'll
; 2067 :             // need to MOD this value with the buffer size.  We don't currently 
; 2068 :             // have any buffer clients of this function, so why bother writing
; 2069 :             // the code?
; 2070 :             //
; 2071 : 
; 2072 :             dwPosition += m_dwPosition;

  0010f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	8b 55 f0	 mov	 edx, DWORD PTR _dwPosition$[ebp]
  00115	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00118	89 55 f0	 mov	 DWORD PTR _dwPosition$[ebp], edx

; 2073 : 
; 2074 :             //
; 2075 :             // Compare this position to the last one we calculated.  If they 
; 2076 :             // match, we can quit looping.
; 2077 :             //
; 2078 : 
; 2079 :             if(dwLastPosition == dwPosition)

  0011b	8b 45 fc	 mov	 eax, DWORD PTR _dwLastPosition$[ebp]
  0011e	3b 45 f0	 cmp	 eax, DWORD PTR _dwPosition$[ebp]
  00121	75 21		 jne	 SHORT $L32430

; 2080 :             {
; 2081 :                 //
; 2082 :                 // Compare this position to the last one we returned.  If the 
; 2083 :                 // current position is less than the last one, the buffer has 
; 2084 :                 // wrapped, but the interrupt hasn't happened yet.
; 2085 :                 //
; 2086 : 
; 2087 :                 if(dwPosition >= m_dwLastPosition)

  00123	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00126	8b 55 f0	 mov	 edx, DWORD PTR _dwPosition$[ebp]
  00129	3b 51 2c	 cmp	 edx, DWORD PTR [ecx+44]
  0012c	72 0b		 jb	 SHORT $L32431

; 2088 :                 {
; 2089 :                     m_dwLastPosition = dwPosition;

  0012e	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00131	8b 4d f0	 mov	 ecx, DWORD PTR _dwPosition$[ebp]
  00134	89 48 2c	 mov	 DWORD PTR [eax+44], ecx

; 2090 :                 }
; 2091 :                 else

  00137	eb 09		 jmp	 SHORT $L32432
$L32431:

; 2092 :                 {
; 2093 :                     dwPosition = m_dwLastPosition;

  00139	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0013c	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0013f	89 45 f0	 mov	 DWORD PTR _dwPosition$[ebp], eax
$L32432:

; 2094 :                 }
; 2095 : 
; 2096 :                 break;

  00142	eb 14		 jmp	 SHORT $L32421
$L32430:

; 2097 :             }
; 2098 : 
; 2099 :             //
; 2100 :             // If we're at raised IRQL, we can't loop
; 2101 :             //
; 2102 : 
; 2103 :             if(KeGetCurrentIrql() >= DISPATCH_LEVEL)

  00144	e8 00 00 00 00	 call	 _KeGetCurrentIrql@0
  00149	0f b6 c8	 movzx	 ecx, al
  0014c	83 f9 02	 cmp	 ecx, 2
  0014f	7c 02		 jl	 SHORT $L32433

; 2104 :             {
; 2105 :                 break;

  00151	eb 05		 jmp	 SHORT $L32421
$L32433:

; 2106 :             }
; 2107 :         }

  00153	e9 ce fe ff ff	 jmp	 $L32420
$L32421:

; 2108 :     }
; 2109 :     else

  00158	eb 09		 jmp	 SHORT $L32434
$L32417:

; 2110 :     {
; 2111 :         dwPosition = m_dwPosition;

  0015a	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0015d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00160	89 45 f0	 mov	 DWORD PTR _dwPosition$[ebp], eax
$L32434:

; 2112 :     }
; 2113 : 
; 2114 :     //
; 2115 :     // Convert sample position to bytes
; 2116 :     //
; 2117 : 
; 2118 :     dwPosition *= m_pDevice->m_wfxFormat.wBitsPerSample / 8;

  00163	0f b7 05 0e 00
	00 00		 movzx	 eax, WORD PTR ?m_wfxFormat@CAc97Device@@2UtWAVEFORMATEX@@B+14
  0016a	99		 cdq
  0016b	83 e2 07	 and	 edx, 7
  0016e	03 c2		 add	 eax, edx
  00170	c1 f8 03	 sar	 eax, 3
  00173	8b 4d f0	 mov	 ecx, DWORD PTR _dwPosition$[ebp]
  00176	0f af c8	 imul	 ecx, eax
  00179	89 4d f0	 mov	 DWORD PTR _dwPosition$[ebp], ecx

; 2119 : 
; 2120 :     DPF_LEAVE(dwPosition);
; 2121 : 
; 2122 :     return dwPosition;

  0017c	8b 45 f0	 mov	 eax, DWORD PTR _dwPosition$[ebp]

; 2123 : }

  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c3		 ret	 0
?GetPosition@CAc97Channel@@QAEKXZ ENDP			; CAc97Channel::GetPosition
DSOUND	ENDS
PUBLIC	??_C@_0BK@POAMABGN@?$CBPeekAciRegister8?$CIX_CTRL?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BH@ICDCGPHP@dwPosition?5?$DM?$DN?5dwLength?$AA@ ; `string'
PUBLIC	??_C@_0BE@OIJNCBGH@dwPosition?5?$DM?50xFFFF?$AA@ ; `string'
;	COMDAT ??_C@_0BK@POAMABGN@?$CBPeekAciRegister8?$CIX_CTRL?$CJ?$AA@
DSOUND_RD	SEGMENT
??_C@_0BK@POAMABGN@?$CBPeekAciRegister8?$CIX_CTRL?$CJ?$AA@ DB '!PeekAciRe'
	DB	'gister8(X_CTRL)', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@ICDCGPHP@dwPosition?5?$DM?$DN?5dwLength?$AA@
DSOUND_RD	SEGMENT
??_C@_0BH@ICDCGPHP@dwPosition?5?$DM?$DN?5dwLength?$AA@ DB 'dwPosition <= '
	DB	'dwLength', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BE@OIJNCBGH@dwPosition?5?$DM?50xFFFF?$AA@
DSOUND_RD	SEGMENT
??_C@_0BE@OIJNCBGH@dwPosition?5?$DM?50xFFFF?$AA@ DB 'dwPosition < 0xFFFF', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?SetPosition@CAc97Channel@@IAEXK@Z
DSOUND	SEGMENT
_this$ = -8
_dwLength$ = -4
_dwPosition$ = 8
?SetPosition@CAc97Channel@@IAEXK@Z PROC NEAR		; CAc97Channel::SetPosition, COMDAT
; _this$ = ecx

; 2151 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2152 :     DWORD               dwLength;
; 2153 : 
; 2154 :     DPF_ENTER();
; 2155 : 
; 2156 :     //
; 2157 :     // Make sure we're stopped
; 2158 :     //
; 2159 : 
; 2160 :     ASSERT(!PeekAciRegister8(X_CTRL));

  00009	68 70 08 00 00	 push	 2160			; 00000870H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@POAMABGN@?$CBPeekAciRegister8?$CIX_CTRL?$CJ?$AA@
  00018	6a 0b		 push	 11			; 0000000bH
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?PeekAciRegister8@CAc97Channel@@IAEEK@Z ; CAc97Channel::PeekAciRegister8
  00022	0f b6 c0	 movzx	 eax, al
  00025	f7 d8		 neg	 eax
  00027	1b c0		 sbb	 eax, eax
  00029	f7 d8		 neg	 eax
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _DwDbgAssert
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 2161 : 
; 2162 :     //
; 2163 :     // Convert byte position to samples
; 2164 :     //
; 2165 : 
; 2166 :     dwPosition /= m_pDevice->m_wfxFormat.wBitsPerSample / 8;

  00034	0f b7 05 0e 00
	00 00		 movzx	 eax, WORD PTR ?m_wfxFormat@CAc97Device@@2UtWAVEFORMATEX@@B+14
  0003b	99		 cdq
  0003c	83 e2 07	 and	 edx, 7
  0003f	03 c2		 add	 eax, edx
  00041	8b c8		 mov	 ecx, eax
  00043	c1 f9 03	 sar	 ecx, 3
  00046	8b 45 08	 mov	 eax, DWORD PTR _dwPosition$[ebp]
  00049	33 d2		 xor	 edx, edx
  0004b	f7 f1		 div	 ecx
  0004d	89 45 08	 mov	 DWORD PTR _dwPosition$[ebp], eax

; 2167 : 
; 2168 :     //
; 2169 :     // Convert buffer position to samples remaining
; 2170 :     //
; 2171 : 
; 2172 :     dwLength = m_pPrdl[m_bCurrentPrd].wLength;

  00050	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00053	0f b6 42 25	 movzx	 eax, BYTE PTR [edx+37]
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0005d	8b 44 c2 04	 mov	 eax, DWORD PTR [edx+eax*8+4]
  00061	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00066	89 45 fc	 mov	 DWORD PTR _dwLength$[ebp], eax

; 2173 :     ASSERT(dwPosition <= dwLength);

  00069	68 7d 08 00 00	 push	 2173			; 0000087dH
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  00073	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@ICDCGPHP@dwPosition?5?$DM?$DN?5dwLength?$AA@
  00078	8b 4d 08	 mov	 ecx, DWORD PTR _dwPosition$[ebp]
  0007b	39 4d fc	 cmp	 DWORD PTR _dwLength$[ebp], ecx
  0007e	1b d2		 sbb	 edx, edx
  00080	f7 da		 neg	 edx
  00082	52		 push	 edx
  00083	e8 00 00 00 00	 call	 _DwDbgAssert
  00088	83 c4 10	 add	 esp, 16			; 00000010H

; 2174 :     
; 2175 :     dwPosition = dwLength - dwPosition;

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _dwLength$[ebp]
  0008e	2b 45 08	 sub	 eax, DWORD PTR _dwPosition$[ebp]
  00091	89 45 08	 mov	 DWORD PTR _dwPosition$[ebp], eax

; 2176 : 
; 2177 :     //
; 2178 :     // Set the position
; 2179 :     //
; 2180 : 
; 2181 :     ASSERT(dwPosition < 0xFFFF);

  00094	68 85 08 00 00	 push	 2181			; 00000885H
  00099	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GPOJIHCH@c?3?2xbox?2private?2windows?2directx?2@
  0009e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OIJNCBGH@dwPosition?5?$DM?50xFFFF?$AA@
  000a3	81 7d 08 ff ff
	00 00		 cmp	 DWORD PTR _dwPosition$[ebp], 65535 ; 0000ffffH
  000aa	1b c9		 sbb	 ecx, ecx
  000ac	41		 inc	 ecx
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 _DwDbgAssert
  000b3	83 c4 10	 add	 esp, 16			; 00000010H

; 2182 :     PokeAciRegister16(X_CUR_POS, (WORD)dwPosition);

  000b6	66 8b 55 08	 mov	 dx, WORD PTR _dwPosition$[ebp]
  000ba	52		 push	 edx
  000bb	6a 08		 push	 8
  000bd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	e8 00 00 00 00	 call	 ?PokeAciRegister16@CAc97Channel@@IAEXKG@Z ; CAc97Channel::PokeAciRegister16

; 2183 : 
; 2184 :     //
; 2185 :     // Clear the last returned position
; 2186 :     //
; 2187 : 
; 2188 :     m_dwLastPosition = 0;

  000c5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c8	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 2189 : 
; 2190 :     DPF_LEAVE_VOID();
; 2191 : }

  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c2 04 00	 ret	 4
?SetPosition@CAc97Channel@@IAEXK@Z ENDP			; CAc97Channel::SetPosition
DSOUND	ENDS
END
