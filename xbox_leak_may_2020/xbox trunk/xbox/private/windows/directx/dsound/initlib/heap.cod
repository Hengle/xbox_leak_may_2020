; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\heap.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
DSOUND_URW	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_URW	ENDS
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_06GGPOMPNM@?$CInone?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DK@BHCCMBKD@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0O@GGBLDHEI@?$CBm_dwRefCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BE@DAEOBIBM@m_dwRefCount?5?$DM?5?$HO0UL?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0N@OILPJBKD@m_dwRefCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DG@LNGLCLLL@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@MLMBNMPN@nLength?5?$DO?5sizeof?$CI?$CKpRunMarker?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_07CNKCBOKB@TESTSND?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DH@NAFPMNMN@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0FF@CEBOEHDG@DirectSound?5is?5in?5the?5final?5stag@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@GKNCNMBD@CDirectSoundTest?3?3AddRef?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@KCMACBKL@CDirectSoundTest?3?3Release?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DK@PBGBJGJP@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0O@JCBGLFIF@?$CBm_paNotifier?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@JLKNBNJM@?$CBm_dwNotifierCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0N@BMLCBDGO@m_paNotifier?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@ELEAODJN@dwNotifierIndex?5?$DM?5m_dwNotifierCo@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@MEDKFNKN@Unexpected?5notifier?5status?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BC@NHNIONPC@m_dwNotifierCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DI@JEPBENHJ@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BA@IANIBDAF@m_pGpDspManager?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@ONCKHILO@m_dwState?5?$CG?5MCPX_APUSTATE_GPIMAG@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@FGGNHBE@KeGetCurrentIrql?$CI?$CJ?5?$DO?$DN?5DISPATCH_L@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@IECLLDN@m_dwVoiceMapLock?5?$DM?5?$HO0UL?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@FFOHIBNC@m_dwVoiceMapLock?5?$DO?$DN?51?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BB@KMKNPDHL@SGEHEAPRUNMARKER?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CM@DPDIDAEM@pRunMarker?9?$DOdwRefCount?5?$DM?5MCPX_HW@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@BOPNGALO@CMcpxBufferSgeHeapTest?3?3Alloc?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CD@JOGDFDFB@Sharing?5SGE?5run?5?$CFx?5?$CIref?5count?5?$CFl@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@OMIGBIHN@?$CBIsListEmpty?$CI?$CGm_lstMarkers?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@KBHBBNLJ@CMcpxBufferSgeHeapTest?3?3AllocRun@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CJ@PALLACNB@Split?5SGE?5run?5into?5?$CFx?5?$CI?$CFlu?$CJ?5and?5@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@GDHANFCL@Allocating?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CL@FOCIIPBL@m_nFreeElementCount?5?$DO?$DN?5pRunMarke@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@CBCHBLME@?$CBpRunMarker?9?$DOfAllocated?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@IGLMCICG@CMcpxBufferSgeHeapTest?3?3FreeRun?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@JGFNOCPN@Freeing?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0EH@MGPIEIAF@pRunMarker?9?$DOnElement?5?$CL?5pRunMarke@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@KEHGDJCK@CMcpxBufferSgeHeapTest?3?3Coalesce@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CJ@OLPJCOOI@Coalescing?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?5and?5@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@MKDGEMOO@dwSgeIndex?5?$DM?5MCPX_HW_MAX_BUFFER_@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CK@JMKAKNMM@?$CB?$CI?$CIDWORD?$CJpvBaseAddress?5?$CG?5?$CIPAGE_S@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_08HIKFCPCB@dnLength?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BP@FIHLJGA@?$CB?$CIdwAddress?5?$CG?5?$CIPAGE_SIZE?5?9?51?$CJ?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@OPOAAKHG@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5DISPATCH_L@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@MKPFBHKH@?$CI2?$CJ?5?$DM?$DN?5PIO_METHOD_QUEUE_CLEAR?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0P@BDCAGIHP@?$CBm_dwAvailable?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_09DCOKMFNA@?$CBm_dwUsed?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@JMLOFGEJ@?$CBg_pDirectSoundTestSlopMemoryHea@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@ENDNGINI@?$CBpMarkerNode?9?$DOfAllocated?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CJ@ECJOOPDJ@this?5?$DN?$DN?5g_pDirectSoundTestSlopMe@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BB@IJHIFFPC@nLength?5?$DO?$DN?5nUsed?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@LEMCKDJM@CMcpxSlopMemoryHeapTest?3?3AddRun?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0HM@DHDLHGJJ@Added?5?$CFx?5to?5the?5slop?5heap?5?$CIentry@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BP@KGPIEHJJ@CMcpxSlopMemoryHeapTest?3?3Alloc?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CM@HIFFJDIO@Split?5memory?5run?5into?5?$CFx?5?$CI?$CFlu?$CJ?5a@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BP@IKOBCBBA@Allocating?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DB@NIHOPDML@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5pRunMar@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@GHHDOBPO@CMcpxSlopMemoryHeapTest?3?3Free?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@NGDNJECG@Freeing?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@OGPDEANK@m_dwUsed?5?$DO?$DN?5pRunMarker?9?$DOnLength?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0ED@KLOEHPFP@?$CILPBYTE?$CJpRunMarker?5?$CL?5pRunMarker?9@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@IEHJELCG@?$CBpNextRunMarker?9?$DOfAllocated?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CG@KEODOCLD@CMcpxSlopMemoryHeapTest?3?3Coalesc@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CM@MKMMHKFA@Coalescing?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?5a@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@GLKFBKGJ@NULL?5?$CCthis?$CC?5pointer?5?$CI?$CFx?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@LEKIOFPG@Invalid?5?$CCthis?$CC?5pointer?5?$CI?$CFx?5?$CB?$DN?5?$CFx@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
DSOUND_RW	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RW	ENDS
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IsEqualGUID@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _==@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _KeGetCurrentIrql@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _KeIsExecutingDpc@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_AddRef@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_Release@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_GetAdapterCount@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_BeginScene@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_EndScene@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_GetRenderState@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_GetTextureStageState@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_SetRenderState@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_SetTextureStageState@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DResource_MoveResourceMemory@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DTexture_UnlockRect@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVolumeTexture_UnlockBox@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DCubeTexture_UnlockRect@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVertexBuffer_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DIndexBuffer_Lock@20
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DIndexBuffer_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DPalette_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DSurface_UnlockRect@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVolume_UnlockBox@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _sqrtf@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@MMMMMMMMMMMMMMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXPLANE@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??3@YAXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CIrql@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Raise@CIrql@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Lower@CIrql@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAutoIrql@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAutoIrql@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Save@CFpState@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Restore@CFpState@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CRefCountTest@@QAE@K@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCRefCountTest@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CRefCountTest@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AddRef@CRefCountTest@@UAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Release@CRefCountTest@@UAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreateMarker@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAU2@GGPAU_LIST_ENTRY@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreateMarker@CMcpxSlopMemoryHeapTest@@IAEPAUSLOPRUNMARKER@@PAXKPAU_LIST_ENTRY@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister8@CAc97Device@@KGEK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister8@CAc97Device@@KGXKE@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister16@CAc97Device@@KGGK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister16@CAc97Device@@KGXKG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister32@CAc97Device@@KGKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister32@CAc97Device@@KGXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister8@CAc97Device@@KGEK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister8@CAc97Device@@KGXKE@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister16@CAc97Device@@KGGK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister16@CAc97Device@@KGXKG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister32@CAc97Device@@KGKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister32@CAc97Device@@KGXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ReleaseChannel@CAc97Device@@QAEXPAVCAc97Channel@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestEnterCriticalSection@@YGHXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestLeaveCriticalSection@@YGXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAutoLockTest@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAutoLockTest@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Free@CMcpxNotifierTest@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Reset@CMcpxNotifierTest@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetScratchSpaceLinAddr@CMcpxDspScratchDmaTest@@QAEPAXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CMcpxBufferSgeHeapTest@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCMcpxBufferSgeHeapTest@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CMcpxBufferSgeHeapTest@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CMcpxBufferSgeHeapTest@@QAEJG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Alloc@CMcpxBufferSgeHeapTest@@QAEPAUSGEHEAPRUNMARKER@@PAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Free@CMcpxBufferSgeHeapTest@@QAEXPAUSGEHEAPRUNMARKER@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AllocRun@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAXG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?FreeRun@CMcpxBufferSgeHeapTest@@IAEXPAUSGEHEAPRUNMARKER@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CoalesceRuns@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAU2@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MapBuffer@CMcpxBufferSgeHeapTest@@KGXKPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?UnmapBuffer@CMcpxBufferSgeHeapTest@@KGXPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _$E1
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _$E3
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CMcpxSlopMemoryHeapTest@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCMcpxSlopMemoryHeapTest@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CMcpxSlopMemoryHeapTest@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AddRun@CMcpxSlopMemoryHeapTest@@QAEHPAXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Alloc@CMcpxSlopMemoryHeapTest@@QAEPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Free@CMcpxSlopMemoryHeapTest@@QAEXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CoalesceRuns@CMcpxSlopMemoryHeapTest@@IAEPAUSLOPRUNMARKER@@PAU2@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1?$CValidObject@$0EEFDEOEE@@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AssertValidObject@?$CValidObject@$0EEFDEOEE@@@QAEXPBDK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_G?$CValidObject@$0EEFDEOEE@@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_7?$CValidObject@$0EEFDEOEE@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_7CMcpxBufferSgeHeapTest@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMcpxSlopMemoryHeapTest@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _TestSoundLibBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_7CRefCountTest@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, DSOUND_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_D3DPRIMITIVETOVERTEXCOUNT
PUBLIC	_D3DSIMPLERENDERSTATEENCODE
PUBLIC	_D3DTEXTUREDIRECTENCODE
PUBLIC	_D3DDIRTYFROMRENDERSTATE
PUBLIC	_D3DDIRTYFROMTEXTURESTATE
PUBLIC	?m_dwUsageThreshold@CMcpxSlopMemoryHeapTest@@2KB ; CMcpxSlopMemoryHeapTest::m_dwUsageThreshold
PUBLIC	_g_dwDirectSoundTestPoolMemoryUsage
PUBLIC	_g_dwDirectSoundTestPhysicalMemoryUsage
PUBLIC	_g_dwDirectSoundTestPhysicalMemorySlop
PUBLIC	_g_dwDirectSoundTestPhysicalMemoryRecovered
PUBLIC	?g_pDirectSoundTestSlopMemoryHeap@@3PAVCMcpxSlopMemoryHeapTest@@A ; g_pDirectSoundTestSlopMemoryHeap
PUBLIC	_TestSoundLibBuildNumberD
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
DSOUND_RD	SEGMENT
_D3DPRIMITIVETOVERTEXCOUNT DD 00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
DSOUND_RD	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
DSOUND_RD	SEGMENT
_D3DSIMPLERENDERSTATEENCODE DD 040260H
	DD	040264H
	DD	040268H
	DD	04026cH
	DD	040270H
	DD	040274H
	DD	040278H
	DD	04027cH
	DD	040288H
	DD	04028cH
	DD	040a60H
	DD	040a64H
	DD	040a68H
	DD	040a6cH
	DD	040a70H
	DD	040a74H
	DD	040a78H
	DD	040a7cH
	DD	040a80H
	DD	040a84H
	DD	040a88H
	DD	040a8cH
	DD	040a90H
	DD	040a94H
	DD	040a98H
	DD	040a9cH
	DD	040aa0H
	DD	040aa4H
	DD	040aa8H
	DD	040aacH
	DD	040ab0H
	DD	040ab4H
	DD	040ab8H
	DD	040abcH
	DD	040ac0H
	DD	040ac4H
	DD	040ac8H
	DD	040accH
	DD	040ad0H
	DD	040ad4H
	DD	040ad8H
	DD	040adcH
	DD	0417f8H
	DD	041e20H
	DD	041e24H
	DD	041e40H
	DD	041e44H
	DD	041e48H
	DD	041e4cH
	DD	041e50H
	DD	041e54H
	DD	041e58H
	DD	041e5cH
	DD	041e60H
	DD	041d90H
	DD	041e74H
	DD	041e78H
	DD	040354H
	DD	04033cH
	DD	040304H
	DD	040300H
	DD	040340H
	DD	040344H
	DD	040348H
	DD	04035cH
	DD	040310H
	DD	04037cH
	DD	040358H
	DD	040374H
	DD	040378H
	DD	040364H
	DD	040368H
	DD	04036cH
	DD	040360H
	DD	040350H
	DD	04034cH
	DD	0409f8H
	DD	040384H
	DD	040388H
	DD	040330H
	DD	040334H
	DD	040338H
DSOUND_RD	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
DSOUND_RD	SEGMENT
_D3DTEXTUREDIRECTENCODE DD 081b00H
	DD	081b40H
	DD	081b80H
	DD	081bc0H
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
DSOUND_RD	SEGMENT
_D3DDIRTYFROMRENDERSTATE DD 02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	01200H
	DD	03000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	0100H
	DD	0100H
	DD	0900H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	00H
	DD	00H
	DD	00H
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
DSOUND_RD	SEGMENT
_D3DDIRTYFROMTEXTURESTATE DD 0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0480fH
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0400H
DSOUND_RD	ENDS
;	COMDAT _TestSoundLibBuildNumberD
XBLD$V	SEGMENT
_TestSoundLibBuildNumberD DW 04554H
	DW	05453H
	DW	04e53H
	DW	04444H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
DSOUND_RW	SEGMENT
_g_dwDirectSoundTestPoolMemoryUsage DD 00H
_g_dwDirectSoundTestPhysicalMemoryUsage DD 00H
_g_dwDirectSoundTestPhysicalMemorySlop DD 00H
_g_dwDirectSoundTestPhysicalMemoryRecovered DD 00H
?g_pDirectSoundTestSlopMemoryHeap@@3PAVCMcpxSlopMemoryHeapTest@@A DD 00H ; g_pDirectSoundTestSlopMemoryHeap
DSOUND_RW	ENDS
DSOUND_RD	SEGMENT
?m_dwUsageThreshold@CMcpxSlopMemoryHeapTest@@2KB DD 040H ; CMcpxSlopMemoryHeapTest::m_dwUsageThreshold
DSOUND_RD	ENDS
PUBLIC	??0CMcpxBufferSgeHeapTest@@QAE@XZ		; CMcpxBufferSgeHeapTest::CMcpxBufferSgeHeapTest
PUBLIC	??_7CMcpxBufferSgeHeapTest@@6B@			; CMcpxBufferSgeHeapTest::`vftable'
PUBLIC	??_GCMcpxBufferSgeHeapTest@@UAEPAXI@Z		; CMcpxBufferSgeHeapTest::`scalar deleting destructor'
EXTRN	??_ECMcpxBufferSgeHeapTest@@UAEPAXI@Z:NEAR	; CMcpxBufferSgeHeapTest::`vector deleting destructor'
;	COMDAT ??_7CMcpxBufferSgeHeapTest@@6B@
; File c:\xbox\private\windows\directx\dsound\initlib\heap.cpp
CONST	SEGMENT
??_7CMcpxBufferSgeHeapTest@@6B@ DD FLAT:??_ECMcpxBufferSgeHeapTest@@UAEPAXI@Z ; CMcpxBufferSgeHeapTest::`vftable'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CMcpxBufferSgeHeapTest@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CMcpxBufferSgeHeapTest@@QAE@XZ PROC NEAR		; CMcpxBufferSgeHeapTest::CMcpxBufferSgeHeapTest, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMcpxBufferSgeHeapTest@@6B@

; 54   :     DPF_ENTER();
; 55   : 
; 56   :     InitializeListHead(&m_lstRuns);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 04	 add	 ecx, 4
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00025	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 57   :     InitializeListHead(&m_lstMarkers);

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 0c	 add	 eax, 12			; 0000000cH
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00034	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0003d	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 58   : 
; 59   :     DPF_LEAVE_VOID();
; 60   : }

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??0CMcpxBufferSgeHeapTest@@QAE@XZ ENDP			; CMcpxBufferSgeHeapTest::CMcpxBufferSgeHeapTest
DSOUND	ENDS
PUBLIC	??1CMcpxBufferSgeHeapTest@@UAE@XZ		; CMcpxBufferSgeHeapTest::~CMcpxBufferSgeHeapTest
; Function compile flags: /Odt
;	COMDAT ??_GCMcpxBufferSgeHeapTest@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCMcpxBufferSgeHeapTest@@UAEPAXI@Z PROC NEAR		; CMcpxBufferSgeHeapTest::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMcpxBufferSgeHeapTest@@UAE@XZ ; CMcpxBufferSgeHeapTest::~CMcpxBufferSgeHeapTest
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L32065
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L32065:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCMcpxBufferSgeHeapTest@@UAEPAXI@Z ENDP		; CMcpxBufferSgeHeapTest::`scalar deleting destructor'
DSOUND	ENDS
EXTRN	_DirectSoundTestTrackingMemFree@4:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\memmgr.h
;	COMDAT ??3@YAXPAX@Z
DSOUND	SEGMENT
_pvBuffer$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 180  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 181  :     DirectSoundTestTrackingMemFree(pvBuffer); 

  00003	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _DirectSoundTestTrackingMemFree@4

; 182  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\heap.cpp
DSOUND	ENDS
;	COMDAT ??1CMcpxBufferSgeHeapTest@@UAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CMcpxBufferSgeHeapTest@@UAE@XZ PROC NEAR		; CMcpxBufferSgeHeapTest::~CMcpxBufferSgeHeapTest, COMDAT
; _this$ = ecx

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMcpxBufferSgeHeapTest@@6B@

; 86   :     DPF_ENTER();
; 87   : 
; 88   :     MEMFREE(m_paMarkers);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  00017	74 16		 je	 SHORT $L32069
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _DirectSoundTestTrackingMemFree@4
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
$L32069:

; 89   : 
; 90   :     DPF_LEAVE_VOID();
; 91   : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??1CMcpxBufferSgeHeapTest@@UAE@XZ ENDP			; CMcpxBufferSgeHeapTest::~CMcpxBufferSgeHeapTest
DSOUND	ENDS
PUBLIC	?Initialize@CMcpxBufferSgeHeapTest@@QAEJG@Z	; CMcpxBufferSgeHeapTest::Initialize
PUBLIC	?CreateMarker@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAU2@GGPAU_LIST_ENTRY@@@Z ; CMcpxBufferSgeHeapTest::CreateMarker
PUBLIC	??_C@_0BB@KMKNPDHL@SGEHEAPRUNMARKER?$AA@	; `string'
PUBLIC	??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z	; InsertTailListUninit
EXTRN	_DirectSoundTestTrackingMemAlloc@24:NEAR
;	COMDAT ??_C@_0BB@KMKNPDHL@SGEHEAPRUNMARKER?$AA@
DSOUND_RD	SEGMENT
??_C@_0BB@KMKNPDHL@SGEHEAPRUNMARKER?$AA@ DB 'SGEHEAPRUNMARKER', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT
??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pri'
	DB	'vate\windows\directx\dsound\initlib\heap.cpp', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Initialize@CMcpxBufferSgeHeapTest@@QAEJG@Z
DSOUND	SEGMENT
_this$ = -12
_hr$ = -8
_i$ = -4
_nLength$ = 8
?Initialize@CMcpxBufferSgeHeapTest@@QAEJG@Z PROC NEAR	; CMcpxBufferSgeHeapTest::Initialize, COMDAT
; _this$ = ecx

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 118  :     HRESULT                 hr;
; 119  :     DWORD                   i;
; 120  : 
; 121  :     m_nFreeElementCount = nLength;

  00009	0f b7 45 08	 movzx	 eax, WORD PTR _nLength$[ebp]
  0000d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 122  : 
; 123  :     //
; 124  :     // Allocate markers, include one extra marker for slop
; 125  :     //
; 126  : 
; 127  :     hr = HRFROMP(m_paMarkers = MEMALLOC(SGEHEAPRUNMARKER, nLength + 1));

  00013	6a 01		 push	 1
  00015	0f b7 55 08	 movzx	 edx, WORD PTR _nLength$[ebp]
  00019	83 c2 01	 add	 edx, 1
  0001c	6b d2 14	 imul	 edx, 20			; 00000014H
  0001f	52		 push	 edx
  00020	68 44 53 64 61	 push	 1633964868		; 61645344H
  00025	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@KMKNPDHL@SGEHEAPRUNMARKER?$AA@
  0002a	6a 7f		 push	 127			; 0000007fH
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00031	e8 00 00 00 00	 call	 _DirectSoundTestTrackingMemAlloc@24
  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0003c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	33 c0		 xor	 eax, eax
  00041	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  00045	0f 95 c0	 setne	 al
  00048	48		 dec	 eax
  00049	25 0e 00 07 80	 and	 eax, -2147024882	; 8007000eH
  0004e	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 128  : 
; 129  :     //
; 130  :     // All elements are initially free, so add 1 run marker to the run list
; 131  :     //
; 132  : 
; 133  :     if(SUCCEEDED(hr))

  00051	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00055	7c 23		 jl	 SHORT $L32084

; 134  :     {
; 135  :         m_pLargestFreeRunMarker = CreateMarker(&m_paMarkers[0], 0, nLength, &m_lstRuns);

  00057	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 04	 add	 ecx, 4
  0005d	51		 push	 ecx
  0005e	66 8b 55 08	 mov	 dx, WORD PTR _nLength$[ebp]
  00062	52		 push	 edx
  00063	6a 00		 push	 0
  00065	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0006b	51		 push	 ecx
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?CreateMarker@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAU2@GGPAU_LIST_ENTRY@@@Z ; CMcpxBufferSgeHeapTest::CreateMarker
  00074	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00077	89 42 1c	 mov	 DWORD PTR [edx+28], eax
$L32084:

; 136  :     }
; 137  : 
; 138  :     //
; 139  :     // The remaining markers are unused
; 140  :     //
; 141  : 
; 142  :     if(SUCCEEDED(hr))

  0007a	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0007e	7c 39		 jl	 SHORT $L32086

; 143  :     {
; 144  :         for(i = 1; i < (DWORD)nLength + 1; i++)

  00080	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00087	eb 09		 jmp	 SHORT $L32088
$L32089:
  00089	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L32088:
  00092	0f b7 4d 08	 movzx	 ecx, WORD PTR _nLength$[ebp]
  00096	83 c1 01	 add	 ecx, 1
  00099	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  0009c	73 1b		 jae	 SHORT $L32086

; 145  :         {
; 146  :             InsertTailListUninit(&m_lstMarkers, &m_paMarkers[i].leListEntry);

  0009e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000a1	6b d2 14	 imul	 edx, 20			; 00000014H
  000a4	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	03 50 14	 add	 edx, DWORD PTR [eax+20]
  000aa	52		 push	 edx
  000ab	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000b1	51		 push	 ecx
  000b2	e8 00 00 00 00	 call	 ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailListUninit

; 147  :         }

  000b7	eb d0		 jmp	 SHORT $L32089
$L32086:

; 148  :     }
; 149  : 
; 150  :     DPF_LEAVE_HRESULT(hr);
; 151  : 
; 152  :     return hr;

  000b9	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 153  : }

  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 04 00	 ret	 4
?Initialize@CMcpxBufferSgeHeapTest@@QAEJG@Z ENDP	; CMcpxBufferSgeHeapTest::Initialize
DSOUND	ENDS
PUBLIC	?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList
PUBLIC	??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
;	COMDAT ??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\initlib\ntlist.h
DSOUND_RD	SEGMENT
??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\initlib\ntlist.h', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT
_ListHead$ = 8
_Entry$ = 12
?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z PROC NEAR	; InsertTailListUninit, COMDAT

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

  00003	6a 72		 push	 114			; 00000072H
  00005	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
  0000a	6a 00		 push	 0
  0000c	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 115  : 
; 116  :     Entry->Flink = ListHead;

  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00018	8b 55 08	 mov	 edx, DWORD PTR _ListHead$[ebp]
  0001b	89 11		 mov	 DWORD PTR [ecx], edx

; 117  :     Entry->Blink = ListHead->Blink;

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  00023	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00026	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 118  :     
; 119  :     Entry->Flink->Blink = Entry;

  00029	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00031	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 120  :     Entry->Blink->Flink = Entry;

  00034	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  0003d	89 11		 mov	 DWORD PTR [ecx], edx

; 121  : 
; 122  :     AssertValidEntryList(Entry, ASSERT_IN_LIST);

  0003f	6a 7a		 push	 122			; 0000007aH
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
  00046	6a 01		 push	 1
  00048	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 123  : }    

  00051	5d		 pop	 ebp
  00052	c2 08 00	 ret	 8
?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ENDP	; InsertTailListUninit
DSOUND	ENDS
PUBLIC	??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@ ; `string'
PUBLIC	??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@ ; `string'
PUBLIC	??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@ ; `string'
PUBLIC	??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@ ; `string'
PUBLIC	??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@	; `string'
EXTRN	_DwDbgAssert:NEAR
;	COMDAT ??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@
DSOUND_RD	SEGMENT
??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@ DB 'NULL list entry po'
	DB	'inter', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@
DSOUND_RD	SEGMENT
??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@ DB 'List entry c'
	DB	'ontains NULL pointer', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@
DSOUND_RD	SEGMENT
??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@ DB 'List entry '
	DB	'partially points to itself', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@
DSOUND_RD	SEGMENT
??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@ DB 'List entry not in '
	DB	'list', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@
DSOUND_RD	SEGMENT
??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@ DB 'List entry in list', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
DSOUND	SEGMENT
_Entry$ = 8
_nFlags$ = 12
_pszFile$ = 16
_nLine$ = 20
?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z PROC NEAR ; __AssertValidEntryList, COMDAT

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   :     if(!Entry)

  00003	83 7d 08 00	 cmp	 DWORD PTR _Entry$[ebp], 0
  00007	75 1c		 jne	 SHORT $L29503

; 35   :     {
; 36   :         DwDbgAssert(TRUE, "NULL list entry pointer", pszFile, nLine);

  00009	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  00010	51		 push	 ecx
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 _DwDbgAssert
  0001d	83 c4 10	 add	 esp, 16			; 00000010H

; 37   :     }
; 38   :     else if(!Entry->Flink || !Entry->Blink)

  00020	e9 c0 00 00 00	 jmp	 $L29502
$L29503:
  00025	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  00028	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0002b	74 09		 je	 SHORT $L29507
  0002d	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	75 1c		 jne	 SHORT $L29506
$L29507:

; 39   :     {
; 40   :         DwDbgAssert(TRUE, "List entry contains NULL pointer", pszFile, nLine);

  00036	8b 4d 14	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  0003d	52		 push	 edx
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@
  00043	6a 01		 push	 1
  00045	e8 00 00 00 00	 call	 _DwDbgAssert
  0004a	83 c4 10	 add	 esp, 16			; 00000010H

; 41   :     }
; 42   :     else if((Entry == Entry->Flink) || (Entry == Entry->Blink))

  0004d	e9 93 00 00 00	 jmp	 $L29502
$L29506:
  00052	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00058	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0005a	74 0b		 je	 SHORT $L29511
  0005c	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0005f	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00062	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00065	75 2e		 jne	 SHORT $L29510
$L29511:

; 43   :     {
; 44   :         if((Entry != Entry->Flink) || (Entry != Entry->Blink))

  00067	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0006a	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0006d	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0006f	75 0b		 jne	 SHORT $L29513
  00071	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00077	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0007a	74 17		 je	 SHORT $L29512
$L29513:

; 45   :         {
; 46   :             DwDbgAssert(TRUE, "List entry partially points to itself", pszFile, nLine);

  0007c	8b 55 14	 mov	 edx, DWORD PTR _nLine$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 10	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00083	50		 push	 eax
  00084	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@
  00089	6a 01		 push	 1
  0008b	e8 00 00 00 00	 call	 _DwDbgAssert
  00090	83 c4 10	 add	 esp, 16			; 00000010H
$L29512:

; 47   :         }
; 48   :     }
; 49   :     else if(ASSERT_IN_LIST == nFlags)

  00093	eb 50		 jmp	 SHORT $L29502
$L29510:
  00095	83 7d 0c 01	 cmp	 DWORD PTR _nFlags$[ebp], 1
  00099	75 23		 jne	 SHORT $L29516

; 50   :     {
; 51   :         if(!IsEntryInList(Entry))

  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0009e	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a0	3b 55 08	 cmp	 edx, DWORD PTR _Entry$[ebp]
  000a3	75 17		 jne	 SHORT $L29517

; 52   :         {
; 53   :             DwDbgAssert(TRUE, "List entry not in list", pszFile, nLine);

  000a5	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  000ac	51		 push	 ecx
  000ad	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@
  000b2	6a 01		 push	 1
  000b4	e8 00 00 00 00	 call	 _DwDbgAssert
  000b9	83 c4 10	 add	 esp, 16			; 00000010H
$L29517:

; 54   :         }
; 55   :     }
; 56   :     else if(ASSERT_NOT_IN_LIST == nFlags)

  000bc	eb 27		 jmp	 SHORT $L29502
$L29516:
  000be	83 7d 0c 02	 cmp	 DWORD PTR _nFlags$[ebp], 2
  000c2	75 21		 jne	 SHORT $L29502

; 57   :     {
; 58   :         if(IsEntryInList(Entry))

  000c4	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  000c7	8b 02		 mov	 eax, DWORD PTR [edx]
  000c9	3b 45 08	 cmp	 eax, DWORD PTR _Entry$[ebp]
  000cc	74 17		 je	 SHORT $L29502

; 59   :         {
; 60   :             DwDbgAssert(TRUE, "List entry in list", pszFile, nLine);

  000ce	8b 4d 14	 mov	 ecx, DWORD PTR _nLine$[ebp]
  000d1	51		 push	 ecx
  000d2	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  000d5	52		 push	 edx
  000d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@
  000db	6a 01		 push	 1
  000dd	e8 00 00 00 00	 call	 _DwDbgAssert
  000e2	83 c4 10	 add	 esp, 16			; 00000010H
$L29502:

; 61   :         }
; 62   :     }
; 63   : }

  000e5	5d		 pop	 ebp
  000e6	c2 10 00	 ret	 16			; 00000010H
?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ENDP ; __AssertValidEntryList
DSOUND	ENDS
PUBLIC	?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z	; InsertHeadListUninit
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\heap.h
;	COMDAT ?CreateMarker@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAU2@GGPAU_LIST_ENTRY@@@Z
DSOUND	SEGMENT
_this$ = -4
_pMarker$ = 8
_nElement$ = 12
_nLength$ = 16
_plePrevEntry$ = 20
?CreateMarker@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAU2@GGPAU_LIST_ENTRY@@@Z PROC NEAR ; CMcpxBufferSgeHeapTest::CreateMarker, COMDAT
; _this$ = ecx

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  :     InsertHeadListUninit(plePrevEntry, &pMarker->leListEntry);

  00007	8b 45 08	 mov	 eax, DWORD PTR _pMarker$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 14	 mov	 ecx, DWORD PTR _plePrevEntry$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertHeadListUninit

; 110  : 
; 111  :     pMarker->nElement = nElement;

  00014	8b 55 08	 mov	 edx, DWORD PTR _pMarker$[ebp]
  00017	66 8b 45 0c	 mov	 ax, WORD PTR _nElement$[ebp]
  0001b	66 89 42 08	 mov	 WORD PTR [edx+8], ax

; 112  :     pMarker->nLength = nLength;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _pMarker$[ebp]
  00022	66 8b 55 10	 mov	 dx, WORD PTR _nLength$[ebp]
  00026	66 89 51 0a	 mov	 WORD PTR [ecx+10], dx

; 113  :     pMarker->dwRefCount = 0;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _pMarker$[ebp]
  0002d	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 114  :     pMarker->pvBaseAddress = NULL;

  00034	8b 4d 08	 mov	 ecx, DWORD PTR _pMarker$[ebp]
  00037	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 115  : 
; 116  :     return pMarker;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _pMarker$[ebp]

; 117  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 10 00	 ret	 16			; 00000010H
?CreateMarker@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAU2@GGPAU_LIST_ENTRY@@@Z ENDP ; CMcpxBufferSgeHeapTest::CreateMarker
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ntlist.h
DSOUND	ENDS
;	COMDAT ?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT
_ListHead$ = 8
_Entry$ = 12
?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z PROC NEAR	; InsertHeadListUninit, COMDAT

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 165  :     AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

  00003	68 a5 00 00 00	 push	 165			; 000000a5H
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
  0000d	6a 00		 push	 0
  0000f	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 166  : 
; 167  :     Entry->Flink = ListHead->Flink;

  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR _ListHead$[ebp]
  0001e	8b 02		 mov	 eax, DWORD PTR [edx]
  00020	89 01		 mov	 DWORD PTR [ecx], eax

; 168  :     Entry->Blink = ListHead;

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00025	8b 55 08	 mov	 edx, DWORD PTR _ListHead$[ebp]
  00028	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 169  :     
; 170  :     Entry->Flink->Blink = Entry;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00033	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 171  :     Entry->Blink->Flink = Entry;

  00036	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  0003f	89 11		 mov	 DWORD PTR [ecx], edx

; 172  : 
; 173  :     AssertValidEntryList(Entry, ASSERT_IN_LIST);

  00041	68 ad 00 00 00	 push	 173			; 000000adH
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
  0004b	6a 01		 push	 1
  0004d	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 174  : }

  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z ENDP	; InsertHeadListUninit
DSOUND	ENDS
PUBLIC	??_C@_07CNKCBOKB@TESTSND?$AA@			; `string'
PUBLIC	?Alloc@CMcpxBufferSgeHeapTest@@QAEPAUSGEHEAPRUNMARKER@@PAXK@Z ; CMcpxBufferSgeHeapTest::Alloc
PUBLIC	?AllocRun@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAXG@Z ; CMcpxBufferSgeHeapTest::AllocRun
PUBLIC	?MapBuffer@CMcpxBufferSgeHeapTest@@KGXKPAXK@Z	; CMcpxBufferSgeHeapTest::MapBuffer
PUBLIC	??_C@_0CM@DPDIDAEM@pRunMarker?9?$DOdwRefCount?5?$DM?5MCPX_HW@ ; `string'
PUBLIC	??_C@_0BO@BOPNGALO@CMcpxBufferSgeHeapTest?3?3Alloc?$AA@ ; `string'
PUBLIC	??_C@_0CD@JOGDFDFB@Sharing?5SGE?5run?5?$CFx?5?$CIref?5count?5?$CFl@ ; `string'
PUBLIC	??0CIrql@@QAE@XZ				; CIrql::CIrql
PUBLIC	?Raise@CIrql@@QAEXXZ				; CIrql::Raise
PUBLIC	?Lower@CIrql@@QAEXXZ				; CIrql::Lower
EXTRN	_DwDbgSetContext:NEAR
EXTRN	_DwDbgPrint:NEAR
;	COMDAT ??_C@_0CM@DPDIDAEM@pRunMarker?9?$DOdwRefCount?5?$DM?5MCPX_HW@
; File c:\xbox\private\windows\directx\dsound\initlib\heap.cpp
DSOUND_RD	SEGMENT
??_C@_0CM@DPDIDAEM@pRunMarker?9?$DOdwRefCount?5?$DM?5MCPX_HW@ DB 'pRunMar'
	DB	'ker->dwRefCount < MCPX_HW_MAX_VOICES', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_07CNKCBOKB@TESTSND?$AA@
DSOUND_RD	SEGMENT
??_C@_07CNKCBOKB@TESTSND?$AA@ DB 'TESTSND', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@BOPNGALO@CMcpxBufferSgeHeapTest?3?3Alloc?$AA@
DSOUND_RD	SEGMENT
??_C@_0BO@BOPNGALO@CMcpxBufferSgeHeapTest?3?3Alloc?$AA@ DB 'CMcpxBufferSg'
	DB	'eHeapTest::Alloc', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CD@JOGDFDFB@Sharing?5SGE?5run?5?$CFx?5?$CIref?5count?5?$CFl@
DSOUND_RD	SEGMENT
??_C@_0CD@JOGDFDFB@Sharing?5SGE?5run?5?$CFx?5?$CIref?5count?5?$CFl@ DB 'S'
	DB	'haring SGE run %x (ref count %lu)', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Alloc@CMcpxBufferSgeHeapTest@@QAEPAUSGEHEAPRUNMARKER@@PAXK@Z
DSOUND	SEGMENT
_this$ = -28
_nLength$ = -24
_pleEntry$ = -20
_pRunMarker$ = -16
_irql$ = -12
_pMarkerNode$ = -4
_pvBaseAddress$ = 8
_dwBufferSize$ = 12
?Alloc@CMcpxBufferSgeHeapTest@@QAEPAUSGEHEAPRUNMARKER@@PAXK@Z PROC NEAR ; CMcpxBufferSgeHeapTest::Alloc, COMDAT
; _this$ = ecx

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 183  :     LPSGEHEAPRUNMARKER      pRunMarker      = NULL;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pRunMarker$[ebp], 0

; 184  :     PLIST_ENTRY             pleEntry;
; 185  :     LPSGEHEAPRUNMARKER      pMarkerNode;
; 186  :     WORD                    nLength;
; 187  :     CIrql                   irql;

  00010	8d 4d f4	 lea	 ecx, DWORD PTR _irql$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CIrql@@QAE@XZ	; CIrql::CIrql

; 188  :     
; 189  :     DPF_ENTER();
; 190  : 
; 191  :     //
; 192  :     // Page-align the buffer address and size
; 193  :     //
; 194  : 
; 195  :     nLength = (WORD)COMPUTE_PAGES_SPANNED(pvBaseAddress, dwBufferSize);

  00018	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  0001b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00023	8d 94 08 ff 0f
	00 00		 lea	 edx, DWORD PTR [eax+ecx+4095]
  0002a	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  0002d	66 89 55 e8	 mov	 WORD PTR _nLength$[ebp], dx

; 196  :     pvBaseAddress = (LPVOID)((DWORD)pvBaseAddress & ~(PAGE_SIZE - 1));

  00031	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  00034	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  00039	89 45 08	 mov	 DWORD PTR _pvBaseAddress$[ebp], eax

; 197  : 
; 198  :     //
; 199  :     // Check the list for a buffer whose SGEs we can share
; 200  :     //
; 201  : 
; 202  :     irql.Raise();

  0003c	8d 4d f4	 lea	 ecx, DWORD PTR _irql$[ebp]
  0003f	e8 00 00 00 00	 call	 ?Raise@CIrql@@QAEXXZ	; CIrql::Raise

; 203  : 
; 204  : #ifndef MCPX_NO_SGE_SHARING
; 205  : 
; 206  :     for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)

  00044	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004a	89 55 ec	 mov	 DWORD PTR _pleEntry$[ebp], edx
  0004d	eb 08		 jmp	 SHORT $L32106
$L32107:
  0004f	8b 45 ec	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  00052	8b 08		 mov	 ecx, DWORD PTR [eax]
  00054	89 4d ec	 mov	 DWORD PTR _pleEntry$[ebp], ecx
$L32106:
  00057	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	83 c2 04	 add	 edx, 4
  0005d	39 55 ec	 cmp	 DWORD PTR _pleEntry$[ebp], edx
  00060	74 48		 je	 SHORT $L32108

; 207  :     {
; 208  :         AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

  00062	68 d0 00 00 00	 push	 208			; 000000d0H
  00067	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0006c	6a 01		 push	 1
  0006e	8b 45 ec	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 209  : 
; 210  :         pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

  00077	8b 4d ec	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  0007a	89 4d fc	 mov	 DWORD PTR _pMarkerNode$[ebp], ecx

; 211  : 
; 212  :         if(pMarkerNode->dwRefCount)

  0007d	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  00080	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  00084	74 22		 je	 SHORT $L32113

; 213  :         {
; 214  :             if((DWORD)pvBaseAddress == (DWORD)pMarkerNode->pvBaseAddress)

  00086	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  0008c	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0008f	75 17		 jne	 SHORT $L32113

; 215  :             {
; 216  :                 if(nLength == pMarkerNode->nLength)

  00091	0f b7 55 e8	 movzx	 edx, WORD PTR _nLength$[ebp]
  00095	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  00098	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  0009c	3b d1		 cmp	 edx, ecx
  0009e	75 08		 jne	 SHORT $L32113

; 217  :                 {
; 218  :                     pRunMarker = pMarkerNode;

  000a0	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  000a3	89 55 f0	 mov	 DWORD PTR _pRunMarker$[ebp], edx

; 219  :                     break;

  000a6	eb 02		 jmp	 SHORT $L32108
$L32113:

; 220  :                 }
; 221  :             }
; 222  :         }
; 223  :     }

  000a8	eb a5		 jmp	 SHORT $L32107
$L32108:

; 224  : 
; 225  :     if(pRunMarker)

  000aa	83 7d f0 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  000ae	74 72		 je	 SHORT $L32118

; 226  :     {
; 227  :         //
; 228  :         // We found one, so just AddRef it
; 229  :         //
; 230  : 
; 231  :         ASSERT(pRunMarker->dwRefCount < MCPX_HW_MAX_VOICES);

  000b0	68 e7 00 00 00	 push	 231			; 000000e7H
  000b5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  000ba	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@DPDIDAEM@pRunMarker?9?$DOdwRefCount?5?$DM?5MCPX_HW@
  000bf	8b 45 f0	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000c2	81 78 0c 00 01
	00 00		 cmp	 DWORD PTR [eax+12], 256	; 00000100H
  000c9	1b c9		 sbb	 ecx, ecx
  000cb	41		 inc	 ecx
  000cc	51		 push	 ecx
  000cd	e8 00 00 00 00	 call	 _DwDbgAssert
  000d2	83 c4 10	 add	 esp, 16			; 00000010H

; 232  : 
; 233  :         pRunMarker->dwRefCount++;

  000d5	8b 55 f0	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000d8	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000db	83 c0 01	 add	 eax, 1
  000de	8b 4d f0	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000e1	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 234  : 
; 235  :         DPF_SGE_HEAP("Sharing SGE run %x (ref count %lu)", pRunMarker->nElement, pRunMarker->dwRefCount);

  000e4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  000e9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@BOPNGALO@CMcpxBufferSgeHeapTest?3?3Alloc?$AA@
  000ee	68 eb 00 00 00	 push	 235			; 000000ebH
  000f3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  000f8	6a 05		 push	 5
  000fa	6a 09		 push	 9
  000fc	e8 00 00 00 00	 call	 _DwDbgSetContext
  00101	83 c4 18	 add	 esp, 24			; 00000018H
  00104	8b 55 f0	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00107	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0010a	50		 push	 eax
  0010b	8b 4d f0	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  0010e	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  00112	52		 push	 edx
  00113	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@JOGDFDFB@Sharing?5SGE?5run?5?$CFx?5?$CIref?5count?5?$CFl@
  00118	e8 00 00 00 00	 call	 _DwDbgPrint
  0011d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 236  :     }
; 237  :     else

  00120	eb 38		 jmp	 SHORT $L32122
$L32118:

; 238  : 
; 239  : #endif // MCPX_NO_SGE_SHARING
; 240  : 
; 241  :     {
; 242  :         //
; 243  :         // Allocate a new run and map it into SGEs.  Note that we're not 
; 244  :         // setting the run marker's base address until after it's been
; 245  :         // mapped.  This will prevent us from ever trying to use an unmapped
; 246  :         // run if a higher IRQL call comes in.
; 247  :         //
; 248  :         
; 249  :         if(pRunMarker = AllocRun(pvBaseAddress, nLength))

  00122	66 8b 45 e8	 mov	 ax, WORD PTR _nLength$[ebp]
  00126	50		 push	 eax
  00127	8b 4d 08	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  0012a	51		 push	 ecx
  0012b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	e8 00 00 00 00	 call	 ?AllocRun@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAXG@Z ; CMcpxBufferSgeHeapTest::AllocRun
  00133	89 45 f0	 mov	 DWORD PTR _pRunMarker$[ebp], eax
  00136	83 7d f0 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  0013a	74 1e		 je	 SHORT $L32122

; 250  :         {
; 251  :             irql.Lower();

  0013c	8d 4d f4	 lea	 ecx, DWORD PTR _irql$[ebp]
  0013f	e8 00 00 00 00	 call	 ?Lower@CIrql@@QAEXXZ	; CIrql::Lower

; 252  : 
; 253  :             MapBuffer(pRunMarker->nElement, pvBaseAddress, nLength);

  00144	0f b7 55 e8	 movzx	 edx, WORD PTR _nLength$[ebp]
  00148	52		 push	 edx
  00149	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  0014c	50		 push	 eax
  0014d	8b 4d f0	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  00150	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  00154	52		 push	 edx
  00155	e8 00 00 00 00	 call	 ?MapBuffer@CMcpxBufferSgeHeapTest@@KGXKPAXK@Z ; CMcpxBufferSgeHeapTest::MapBuffer
$L32122:

; 254  :         }
; 255  :     }
; 256  : 
; 257  :     irql.Lower();

  0015a	8d 4d f4	 lea	 ecx, DWORD PTR _irql$[ebp]
  0015d	e8 00 00 00 00	 call	 ?Lower@CIrql@@QAEXXZ	; CIrql::Lower

; 258  : 
; 259  :     DPF_LEAVE(pRunMarker);
; 260  : 
; 261  :     return pRunMarker;

  00162	8b 45 f0	 mov	 eax, DWORD PTR _pRunMarker$[ebp]

; 262  : }

  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c2 08 00	 ret	 8
?Alloc@CMcpxBufferSgeHeapTest@@QAEPAUSGEHEAPRUNMARKER@@PAXK@Z ENDP ; CMcpxBufferSgeHeapTest::Alloc
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\drvhlp.h
DSOUND	ENDS
;	COMDAT ??0CIrql@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CIrql@@QAE@XZ PROC NEAR				; CIrql::CIrql, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 39   :     m_fRaised = FALSE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 40   : }

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0CIrql@@QAE@XZ ENDP					; CIrql::CIrql
DSOUND	ENDS
EXTRN	__imp_@KfRaiseIrql@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Raise@CIrql@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Raise@CIrql@@QAEXXZ PROC NEAR				; CIrql::Raise, COMDAT
; _this$ = ecx

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 44   :     if(m_fRaised = (KeGetCurrentIrql() < DISPATCH_LEVEL))

  00007	e8 00 00 00 00	 call	 _KeGetCurrentIrql@0
  0000c	0f b6 c0	 movzx	 eax, al
  0000f	33 c9		 xor	 ecx, ecx
  00011	83 f8 02	 cmp	 eax, 2
  00014	0f 9c c1	 setl	 cl
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00024	74 0d		 je	 SHORT $L29688

; 45   :     {
; 46   :         m_irql = KfRaiseIrql(DISPATCH_LEVEL);

  00026	b1 02		 mov	 cl, 2
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfRaiseIrql@4
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	88 01		 mov	 BYTE PTR [ecx], al
$L29688:

; 47   :     }
; 48   : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?Raise@CIrql@@QAEXXZ ENDP				; CIrql::Raise
; Function compile flags: /Odt
; File c:\xbox\private\ntos\inc\i386.h
DSOUND	ENDS
;	COMDAT _KeGetCurrentIrql@0
DSOUND	SEGMENT
_KeGetCurrentIrql@0 PROC NEAR				; COMDAT

; 1496 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1497 : #if defined(_NTSYSTEM_)
; 1498 :     return KeGetPcr()->Irql;
; 1499 : #else
; 1500 :     __asm {  movzx eax, byte ptr fs:[0] KPCR.Irql }

  00003	64 0f b6 05 24
	00 00 00	 movzx	 eax, BYTE PTR fs:36

; 1501 : #endif
; 1502 : }    

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_KeGetCurrentIrql@0 ENDP
DSOUND	ENDS
EXTRN	__imp_@KfLowerIrql@4:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\drvhlp.h
;	COMDAT ?Lower@CIrql@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Lower@CIrql@@QAEXXZ PROC NEAR				; CIrql::Lower, COMDAT
; _this$ = ecx

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   :     if(m_fRaised)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 15		 je	 SHORT $L29693

; 53   :     {
; 54   :         KfLowerIrql(m_irql);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8a 09		 mov	 cl, BYTE PTR [ecx]
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfLowerIrql@4

; 55   :         m_fRaised = FALSE;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$L29693:

; 56   :     }
; 57   : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?Lower@CIrql@@QAEXXZ ENDP				; CIrql::Lower
DSOUND	ENDS
PUBLIC	?Free@CMcpxBufferSgeHeapTest@@QAEXPAUSGEHEAPRUNMARKER@@@Z ; CMcpxBufferSgeHeapTest::Free
PUBLIC	?FreeRun@CMcpxBufferSgeHeapTest@@IAEXPAUSGEHEAPRUNMARKER@@@Z ; CMcpxBufferSgeHeapTest::FreeRun
PUBLIC	?UnmapBuffer@CMcpxBufferSgeHeapTest@@KGXPAXK@Z	; CMcpxBufferSgeHeapTest::UnmapBuffer
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\heap.cpp
;	COMDAT ?Free@CMcpxBufferSgeHeapTest@@QAEXPAUSGEHEAPRUNMARKER@@@Z
DSOUND	SEGMENT
_this$ = -20
_dnLength$ = -16
_pvBaseAddress$ = -12
_irql$ = -8
_pRunMarker$ = 8
?Free@CMcpxBufferSgeHeapTest@@QAEXPAUSGEHEAPRUNMARKER@@@Z PROC NEAR ; CMcpxBufferSgeHeapTest::Free, COMDAT
; _this$ = ecx

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 289  :     LPVOID                  pvBaseAddress;
; 290  :     DWORD                   dnLength;
; 291  :     CIrql                   irql;

  00009	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CIrql@@QAE@XZ	; CIrql::CIrql

; 292  :     
; 293  :     DPF_ENTER();
; 294  : 
; 295  :     irql.Raise();

  00011	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00014	e8 00 00 00 00	 call	 ?Raise@CIrql@@QAEXXZ	; CIrql::Raise

; 296  :     
; 297  :     if(!--pRunMarker->dwRefCount)

  00019	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0001c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0001f	83 e9 01	 sub	 ecx, 1
  00022	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00025	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00028	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0002b	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0002f	75 34		 jne	 SHORT $L32131

; 298  :     {
; 299  :         pvBaseAddress = pRunMarker->pvBaseAddress;

  00031	8b 4d 08	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  00034	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00037	89 55 f4	 mov	 DWORD PTR _pvBaseAddress$[ebp], edx

; 300  :         dnLength = pRunMarker->nLength;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0003d	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  00041	89 4d f0	 mov	 DWORD PTR _dnLength$[ebp], ecx

; 301  :         
; 302  :         FreeRun(pRunMarker);

  00044	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00047	52		 push	 edx
  00048	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?FreeRun@CMcpxBufferSgeHeapTest@@IAEXPAUSGEHEAPRUNMARKER@@@Z ; CMcpxBufferSgeHeapTest::FreeRun

; 303  : 
; 304  :         irql.Lower();

  00050	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00053	e8 00 00 00 00	 call	 ?Lower@CIrql@@QAEXXZ	; CIrql::Lower

; 305  : 
; 306  :         UnmapBuffer(pvBaseAddress, dnLength);

  00058	8b 45 f0	 mov	 eax, DWORD PTR _dnLength$[ebp]
  0005b	50		 push	 eax
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 ?UnmapBuffer@CMcpxBufferSgeHeapTest@@KGXPAXK@Z ; CMcpxBufferSgeHeapTest::UnmapBuffer
$L32131:

; 307  :     }
; 308  :     
; 309  :     irql.Lower();

  00065	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00068	e8 00 00 00 00	 call	 ?Lower@CIrql@@QAEXXZ	; CIrql::Lower

; 310  : 
; 311  :     DPF_LEAVE_VOID();
; 312  : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?Free@CMcpxBufferSgeHeapTest@@QAEXPAUSGEHEAPRUNMARKER@@@Z ENDP ; CMcpxBufferSgeHeapTest::Free
DSOUND	ENDS
PUBLIC	??_C@_0BM@OMIGBIHN@?$CBIsListEmpty?$CI?$CGm_lstMarkers?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CB@KBHBBNLJ@CMcpxBufferSgeHeapTest?3?3AllocRun@ ; `string'
PUBLIC	??_C@_0CJ@PALLACNB@Split?5SGE?5run?5into?5?$CFx?5?$CI?$CFlu?$CJ?5and?5@ ; `string'
PUBLIC	??_C@_0BM@GDHANFCL@Allocating?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CL@FOCIIPBL@m_nFreeElementCount?5?$DO?$DN?5pRunMarke@ ; `string'
PUBLIC	?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z	; RemoveEntryList
;	COMDAT ??_C@_0BM@OMIGBIHN@?$CBIsListEmpty?$CI?$CGm_lstMarkers?$CJ?$AA@
DSOUND_RD	SEGMENT
??_C@_0BM@OMIGBIHN@?$CBIsListEmpty?$CI?$CGm_lstMarkers?$CJ?$AA@ DB '!IsLi'
	DB	'stEmpty(&m_lstMarkers)', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@KBHBBNLJ@CMcpxBufferSgeHeapTest?3?3AllocRun@
DSOUND_RD	SEGMENT
??_C@_0CB@KBHBBNLJ@CMcpxBufferSgeHeapTest?3?3AllocRun@ DB 'CMcpxBufferSge'
	DB	'HeapTest::AllocRun', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CJ@PALLACNB@Split?5SGE?5run?5into?5?$CFx?5?$CI?$CFlu?$CJ?5and?5@
DSOUND_RD	SEGMENT
??_C@_0CJ@PALLACNB@Split?5SGE?5run?5into?5?$CFx?5?$CI?$CFlu?$CJ?5and?5@ DB 'S'
	DB	'plit SGE run into %x (%lu) and %x (%lu)', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@GDHANFCL@Allocating?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@
DSOUND_RD	SEGMENT
??_C@_0BM@GDHANFCL@Allocating?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@ DB 'A'
	DB	'llocating SGE run %x (%lu)', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CL@FOCIIPBL@m_nFreeElementCount?5?$DO?$DN?5pRunMarke@
DSOUND_RD	SEGMENT
??_C@_0CL@FOCIIPBL@m_nFreeElementCount?5?$DO?$DN?5pRunMarke@ DB 'm_nFreeE'
	DB	'lementCount >= pRunMarker->nLength', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?AllocRun@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAXG@Z
DSOUND	SEGMENT
_this$ = -16
_pleEntry$ = -12
_pRunMarker$ = -8
_pMarkerNode$ = -4
_pvBaseAddress$ = 8
_nLength$ = 12
?AllocRun@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAXG@Z PROC NEAR ; CMcpxBufferSgeHeapTest::AllocRun, COMDAT
; _this$ = ecx

; 341  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 342  :     LPSGEHEAPRUNMARKER      pRunMarker  = NULL;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pRunMarker$[ebp], 0

; 343  :     LPSGEHEAPRUNMARKER      pMarkerNode;
; 344  :     PLIST_ENTRY             pleEntry;
; 345  : 
; 346  :     DPF_ENTER();
; 347  : 
; 348  :     //
; 349  :     // Check the largest available run length to see if we can service
; 350  :     // the request
; 351  :     //
; 352  : 
; 353  :     if(m_pLargestFreeRunMarker)

  00010	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00017	0f 84 97 02 00
	00		 je	 $L32140

; 354  :     {
; 355  :         if(m_pLargestFreeRunMarker->nLength >= nLength)

  0001d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00023	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  00027	0f b7 4d 0c	 movzx	 ecx, WORD PTR _nLength$[ebp]
  0002b	3b c1		 cmp	 eax, ecx
  0002d	0f 8c 81 02 00
	00		 jl	 $L32140

; 356  :         {
; 357  :             //
; 358  :             // Find a free run that is as close as possible to the requested element
; 359  :             // count.  This will help to reduce fragmentation.
; 360  :             //
; 361  : 
; 362  :             for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)

  00033	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00039	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax
  0003c	eb 08		 jmp	 SHORT $L32142
$L32143:
  0003e	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx
$L32142:
  00046	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00049	83 c0 04	 add	 eax, 4
  0004c	39 45 f4	 cmp	 DWORD PTR _pleEntry$[ebp], eax
  0004f	74 5b		 je	 SHORT $L32144

; 363  :             {
; 364  :                 AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

  00051	68 6c 01 00 00	 push	 364			; 0000016cH
  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0005b	6a 01		 push	 1
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 365  : 
; 366  :                 pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

  00066	8b 55 f4	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  00069	89 55 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], edx

; 367  :             
; 368  :                 if(!pMarkerNode->fAllocated)

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  0006f	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00073	75 35		 jne	 SHORT $L32149

; 369  :                 {
; 370  :                     if(pMarkerNode->nLength >= nLength)

  00075	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  00078	0f b7 51 0a	 movzx	 edx, WORD PTR [ecx+10]
  0007c	0f b7 45 0c	 movzx	 eax, WORD PTR _nLength$[ebp]
  00080	3b d0		 cmp	 edx, eax
  00082	7c 26		 jl	 SHORT $L32149

; 371  :                     {
; 372  :                         if(!pRunMarker)

  00084	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  00088	75 08		 jne	 SHORT $L32151

; 373  :                         {
; 374  :                             pRunMarker = pMarkerNode;

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  0008d	89 4d f8	 mov	 DWORD PTR _pRunMarker$[ebp], ecx

; 375  :                         }
; 376  :                         else if(pMarkerNode->nLength < pRunMarker->nLength)

  00090	eb 18		 jmp	 SHORT $L32149
$L32151:
  00092	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  00095	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  00099	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  0009c	0f b7 51 0a	 movzx	 edx, WORD PTR [ecx+10]
  000a0	3b c2		 cmp	 eax, edx
  000a2	7d 06		 jge	 SHORT $L32149

; 377  :                         {
; 378  :                             pRunMarker = pMarkerNode;

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  000a7	89 45 f8	 mov	 DWORD PTR _pRunMarker$[ebp], eax
$L32149:

; 379  :                         }
; 380  :                     }
; 381  :                 }
; 382  :             }

  000aa	eb 92		 jmp	 SHORT $L32143
$L32144:

; 383  : 
; 384  :             //
; 385  :             // If we're using the whole run, just flag it as allocated.  If not,
; 386  :             // get a free marker from the pool and add it to the list.  We're only
; 387  :             // using a single list so that runs can be broken and coalesced without
; 388  :             // having to walk the list.
; 389  :             //
; 390  : 
; 391  :             if(pRunMarker)

  000ac	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  000b0	0f 84 27 01 00
	00		 je	 $L32154

; 392  :             {
; 393  :                 if(nLength < pRunMarker->nLength)

  000b6	0f b7 4d 0c	 movzx	 ecx, WORD PTR _nLength$[ebp]
  000ba	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000bd	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  000c1	3b c8		 cmp	 ecx, eax
  000c3	0f 8d c4 00 00
	00		 jge	 $L32155

; 394  :                 {
; 395  :                     ASSERT(!IsListEmpty(&m_lstMarkers));

  000c9	68 8b 01 00 00	 push	 395			; 0000018bH
  000ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  000d3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@OMIGBIHN@?$CBIsListEmpty?$CI?$CGm_lstMarkers?$CJ?$AA@
  000d8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000de	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000e1	33 c0		 xor	 eax, eax
  000e3	39 4a 0c	 cmp	 DWORD PTR [edx+12], ecx
  000e6	0f 94 c0	 sete	 al
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 _DwDbgAssert
  000ef	83 c4 10	 add	 esp, 16			; 00000010H

; 396  :             
; 397  :                     pleEntry = RemoveHeadList(&m_lstMarkers);

  000f2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000f8	52		 push	 edx
  000f9	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList
  000fe	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax

; 398  :                     pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

  00101	8b 45 f4	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  00104	89 45 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], eax

; 399  : 
; 400  :                     CreateMarker(pMarkerNode, pRunMarker->nElement + nLength, pRunMarker->nLength - nLength, &pRunMarker->leListEntry);

  00107	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  0010a	51		 push	 ecx
  0010b	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  0010e	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  00112	0f b7 4d 0c	 movzx	 ecx, WORD PTR _nLength$[ebp]
  00116	2b c1		 sub	 eax, ecx
  00118	50		 push	 eax
  00119	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  0011c	0f b7 42 08	 movzx	 eax, WORD PTR [edx+8]
  00120	0f b7 4d 0c	 movzx	 ecx, WORD PTR _nLength$[ebp]
  00124	03 c1		 add	 eax, ecx
  00126	50		 push	 eax
  00127	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  0012a	52		 push	 edx
  0012b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	e8 00 00 00 00	 call	 ?CreateMarker@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAU2@GGPAU_LIST_ENTRY@@@Z ; CMcpxBufferSgeHeapTest::CreateMarker

; 401  : 
; 402  :                     pRunMarker->nLength = nLength;

  00133	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00136	66 8b 4d 0c	 mov	 cx, WORD PTR _nLength$[ebp]
  0013a	66 89 48 0a	 mov	 WORD PTR [eax+10], cx

; 403  : 
; 404  :                     DPF_SGE_HEAP("Split SGE run into %x (%lu) and %x (%lu)", pRunMarker->nElement, pRunMarker->nLength, pMarkerNode->nElement, pMarkerNode->nLength);

  0013e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  00143	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@KBHBBNLJ@CMcpxBufferSgeHeapTest?3?3AllocRun@
  00148	68 94 01 00 00	 push	 404			; 00000194H
  0014d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00152	6a 05		 push	 5
  00154	6a 09		 push	 9
  00156	e8 00 00 00 00	 call	 _DwDbgSetContext
  0015b	83 c4 18	 add	 esp, 24			; 00000018H
  0015e	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  00161	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  00165	50		 push	 eax
  00166	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  00169	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  0016d	52		 push	 edx
  0016e	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00171	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  00175	51		 push	 ecx
  00176	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00179	0f b7 42 08	 movzx	 eax, WORD PTR [edx+8]
  0017d	50		 push	 eax
  0017e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@PALLACNB@Split?5SGE?5run?5into?5?$CFx?5?$CI?$CFlu?$CJ?5and?5@
  00183	e8 00 00 00 00	 call	 _DwDbgPrint
  00188	83 c4 14	 add	 esp, 20			; 00000014H

; 405  :                 }
; 406  :                 else

  0018b	eb 3d		 jmp	 SHORT $L32163
$L32155:

; 407  :                 {
; 408  :                     DPF_SGE_HEAP("Allocating SGE run %x (%lu)", pRunMarker->nElement, pRunMarker->nLength);

  0018d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  00192	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@KBHBBNLJ@CMcpxBufferSgeHeapTest?3?3AllocRun@
  00197	68 98 01 00 00	 push	 408			; 00000198H
  0019c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  001a1	6a 05		 push	 5
  001a3	6a 09		 push	 9
  001a5	e8 00 00 00 00	 call	 _DwDbgSetContext
  001aa	83 c4 18	 add	 esp, 24			; 00000018H
  001ad	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  001b0	0f b7 51 0a	 movzx	 edx, WORD PTR [ecx+10]
  001b4	52		 push	 edx
  001b5	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  001b8	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  001bc	51		 push	 ecx
  001bd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@GDHANFCL@Allocating?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@
  001c2	e8 00 00 00 00	 call	 _DwDbgPrint
  001c7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L32163:

; 409  :                 }
; 410  : 
; 411  :                 pRunMarker->fAllocated = TRUE;

  001ca	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  001cd	c7 42 0c 01 00
	00 00		 mov	 DWORD PTR [edx+12], 1

; 412  :                 pRunMarker->pvBaseAddress = pvBaseAddress;

  001d4	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  001d7	8b 4d 08	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  001da	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$L32154:

; 413  :             }
; 414  : 
; 415  :             //
; 416  :             // Update the free element count and largest run members
; 417  :             //
; 418  : 
; 419  :             if(pRunMarker)

  001dd	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  001e1	0f 84 cd 00 00
	00		 je	 $L32140

; 420  :             {
; 421  :                 ASSERT(m_nFreeElementCount >= pRunMarker->nLength);

  001e7	68 a5 01 00 00	 push	 421			; 000001a5H
  001ec	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  001f1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CL@FOCIIPBL@m_nFreeElementCount?5?$DO?$DN?5pRunMarke@
  001f6	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  001f9	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  001fd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00200	39 41 18	 cmp	 DWORD PTR [ecx+24], eax
  00203	1b d2		 sbb	 edx, edx
  00205	f7 da		 neg	 edx
  00207	52		 push	 edx
  00208	e8 00 00 00 00	 call	 _DwDbgAssert
  0020d	83 c4 10	 add	 esp, 16			; 00000010H

; 422  :                 m_nFreeElementCount -= pRunMarker->nLength;

  00210	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00213	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  00217	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0021a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0021d	2b c1		 sub	 eax, ecx
  0021f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00222	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 423  : 
; 424  :                 if(pRunMarker == m_pLargestFreeRunMarker)

  00225	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00228	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0022b	3b 42 1c	 cmp	 eax, DWORD PTR [edx+28]
  0022e	0f 85 80 00 00
	00		 jne	 $L32140

; 425  :                 {
; 426  :                     m_pLargestFreeRunMarker = NULL;

  00234	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00237	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 427  :                     
; 428  :                     for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)

  0023e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00241	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00244	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax
  00247	eb 08		 jmp	 SHORT $L32168
$L32169:
  00249	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  0024c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0024e	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx
$L32168:
  00251	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00254	83 c0 04	 add	 eax, 4
  00257	39 45 f4	 cmp	 DWORD PTR _pleEntry$[ebp], eax
  0025a	74 58		 je	 SHORT $L32140

; 429  :                     {
; 430  :                         AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

  0025c	68 ae 01 00 00	 push	 430			; 000001aeH
  00261	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00266	6a 01		 push	 1
  00268	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  0026b	51		 push	 ecx
  0026c	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 431  : 
; 432  :                         pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

  00271	8b 55 f4	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  00274	89 55 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], edx

; 433  :             
; 434  :                         if(!pMarkerNode->fAllocated)

  00277	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  0027a	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0027e	75 32		 jne	 SHORT $L32175

; 435  :                         {
; 436  :                             if(!m_pLargestFreeRunMarker)

  00280	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00283	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00287	75 0b		 jne	 SHORT $L32176

; 437  :                             {
; 438  :                                 m_pLargestFreeRunMarker = pMarkerNode;

  00289	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0028c	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  0028f	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 439  :                             }
; 440  :                             else if(pMarkerNode->nLength > m_pLargestFreeRunMarker->nLength)

  00292	eb 1e		 jmp	 SHORT $L32175
$L32176:
  00294	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  00297	0f b7 51 0a	 movzx	 edx, WORD PTR [ecx+10]
  0029b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0029e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  002a1	0f b7 41 0a	 movzx	 eax, WORD PTR [ecx+10]
  002a5	3b d0		 cmp	 edx, eax
  002a7	7e 09		 jle	 SHORT $L32175

; 441  :                             {
; 442  :                                 m_pLargestFreeRunMarker = pMarkerNode;

  002a9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  002ac	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  002af	89 51 1c	 mov	 DWORD PTR [ecx+28], edx
$L32175:

; 443  :                             }
; 444  :                         }
; 445  :                     }

  002b2	eb 95		 jmp	 SHORT $L32169
$L32140:

; 446  :                 }                    
; 447  :             }
; 448  :         }
; 449  :     }
; 450  : 
; 451  :     DPF_LEAVE(pRunMarker);
; 452  : 
; 453  :     return pRunMarker;

  002b4	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]

; 454  : }

  002b7	8b e5		 mov	 esp, ebp
  002b9	5d		 pop	 ebp
  002ba	c2 08 00	 ret	 8
?AllocRun@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAXG@Z ENDP ; CMcpxBufferSgeHeapTest::AllocRun
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ntlist.h
DSOUND	ENDS
;	COMDAT ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z
DSOUND	SEGMENT
_Entry$ = 8
?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z PROC NEAR	; RemoveEntryList, COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  :     AssertValidEntryList(Entry, ASSERT_VALID_ONLY);

  00003	68 c2 00 00 00	 push	 194			; 000000c2H
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
  0000d	6a 00		 push	 0
  0000f	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 195  : 
; 196  :     if(IsEntryInList(Entry))

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001d	3b 55 08	 cmp	 edx, DWORD PTR _Entry$[ebp]
  00020	74 2c		 je	 SHORT $L29543

; 197  :     {
; 198  :         Entry->Flink->Blink = Entry->Blink;

  00022	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0002a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 199  :         Entry->Blink->Flink = Entry->Flink;

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00033	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00036	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 0a		 mov	 DWORD PTR [edx], ecx

; 200  : 
; 201  :         Entry->Flink = Entry->Blink = Entry;

  0003d	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  00040	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00043	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00049	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0004c	89 11		 mov	 DWORD PTR [ecx], edx
$L29543:

; 202  :     }
; 203  : 
; 204  :     return Entry;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]

; 205  : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ENDP	; RemoveEntryList
DSOUND	ENDS
PUBLIC	?CoalesceRuns@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAU2@0@Z ; CMcpxBufferSgeHeapTest::CoalesceRuns
PUBLIC	??_C@_0BI@CBCHBLME@?$CBpRunMarker?9?$DOfAllocated?$AA@ ; `string'
PUBLIC	??_C@_0CA@IGLMCICG@CMcpxBufferSgeHeapTest?3?3FreeRun?$AA@ ; `string'
PUBLIC	??_C@_0BJ@JGFNOCPN@Freeing?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@ ; `string'
;	COMDAT ??_C@_0BI@CBCHBLME@?$CBpRunMarker?9?$DOfAllocated?$AA@
; File c:\xbox\private\windows\directx\dsound\initlib\heap.cpp
DSOUND_RD	SEGMENT
??_C@_0BI@CBCHBLME@?$CBpRunMarker?9?$DOfAllocated?$AA@ DB '!pRunMarker->f'
	DB	'Allocated', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@IGLMCICG@CMcpxBufferSgeHeapTest?3?3FreeRun?$AA@
DSOUND_RD	SEGMENT
??_C@_0CA@IGLMCICG@CMcpxBufferSgeHeapTest?3?3FreeRun?$AA@ DB 'CMcpxBuffer'
	DB	'SgeHeapTest::FreeRun', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@JGFNOCPN@Freeing?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@
DSOUND_RD	SEGMENT
??_C@_0BJ@JGFNOCPN@Freeing?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@ DB 'Free'
	DB	'ing SGE run %x (%lu)', 00H			; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?FreeRun@CMcpxBufferSgeHeapTest@@IAEXPAUSGEHEAPRUNMARKER@@@Z
DSOUND	SEGMENT
_this$ = -12
_pleEntry$ = -8
_pMarkerNode$ = -4
_pRunMarker$ = 8
?FreeRun@CMcpxBufferSgeHeapTest@@IAEXPAUSGEHEAPRUNMARKER@@@Z PROC NEAR ; CMcpxBufferSgeHeapTest::FreeRun, COMDAT
; _this$ = ecx

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 481  :     PLIST_ENTRY             pleEntry;
; 482  :     LPSGEHEAPRUNMARKER      pMarkerNode;
; 483  :     
; 484  :     DPF_ENTER();
; 485  : 
; 486  :     ASSERT(!pRunMarker->fAllocated);

  00009	68 e6 01 00 00	 push	 486			; 000001e6H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@CBCHBLME@?$CBpRunMarker?9?$DOfAllocated?$AA@
  00018	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0001b	33 c9		 xor	 ecx, ecx
  0001d	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00021	0f 95 c1	 setne	 cl
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 _DwDbgAssert
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 487  : 
; 488  :     DPF_SGE_HEAP("Freeing SGE run %x (%lu)", pRunMarker->nElement, pRunMarker->nLength);

  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@IGLMCICG@CMcpxBufferSgeHeapTest?3?3FreeRun?$AA@
  00037	68 e8 01 00 00	 push	 488			; 000001e8H
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00041	6a 05		 push	 5
  00043	6a 09		 push	 9
  00045	e8 00 00 00 00	 call	 _DwDbgSetContext
  0004a	83 c4 18	 add	 esp, 24			; 00000018H
  0004d	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00050	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  00054	50		 push	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  00058	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  0005c	52		 push	 edx
  0005d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@JGFNOCPN@Freeing?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@
  00062	e8 00 00 00 00	 call	 _DwDbgPrint
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 489  : 
; 490  :     //
; 491  :     // Update the free element count
; 492  :     //
; 493  : 
; 494  :     m_nFreeElementCount += pRunMarker->nLength;

  0006a	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0006d	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  00071	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00074	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  00077	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$L32189:

; 495  : 
; 496  :     //
; 497  :     // Coalesce the run with those around it and add it back to the free 
; 498  :     // marker pool.
; 499  :     //
; 500  : 
; 501  :     while(TRUE)

  0007d	b9 01 00 00 00	 mov	 ecx, 1
  00082	85 c9		 test	 ecx, ecx
  00084	74 3b		 je	 SHORT $L32198

; 502  :     {
; 503  :         if((pleEntry = pRunMarker->leListEntry.Flink) == &m_lstRuns)

  00086	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00089	8b 02		 mov	 eax, DWORD PTR [edx]
  0008b	89 45 f8	 mov	 DWORD PTR _pleEntry$[ebp], eax
  0008e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	83 c1 04	 add	 ecx, 4
  00094	39 4d f8	 cmp	 DWORD PTR _pleEntry$[ebp], ecx
  00097	75 02		 jne	 SHORT $L32191

; 504  :         {
; 505  :             break;

  00099	eb 26		 jmp	 SHORT $L32198
$L32191:

; 506  :         }
; 507  : 
; 508  :         pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

  0009b	8b 55 f8	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  0009e	89 55 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], edx

; 509  : 
; 510  :         if(pMarkerNode->fAllocated)

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  000a4	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000a8	74 02		 je	 SHORT $L32196

; 511  :         {
; 512  :             break;

  000aa	eb 15		 jmp	 SHORT $L32198
$L32196:

; 513  :         }
; 514  : 
; 515  :         pRunMarker = CoalesceRuns(pRunMarker, pMarkerNode);

  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  000af	51		 push	 ecx
  000b0	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000b3	52		 push	 edx
  000b4	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ?CoalesceRuns@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAU2@0@Z ; CMcpxBufferSgeHeapTest::CoalesceRuns
  000bc	89 45 08	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 516  :     }

  000bf	eb bc		 jmp	 SHORT $L32189
$L32198:

; 517  : 
; 518  :     while(TRUE)

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	85 c0		 test	 eax, eax
  000c8	74 3c		 je	 SHORT $L32199

; 519  :     {
; 520  :         if((pleEntry = pRunMarker->leListEntry.Blink) == &m_lstRuns)

  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000cd	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d0	89 55 f8	 mov	 DWORD PTR _pleEntry$[ebp], edx
  000d3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	83 c0 04	 add	 eax, 4
  000d9	39 45 f8	 cmp	 DWORD PTR _pleEntry$[ebp], eax
  000dc	75 02		 jne	 SHORT $L32200

; 521  :         {
; 522  :             break;

  000de	eb 26		 jmp	 SHORT $L32199
$L32200:

; 523  :         }
; 524  : 
; 525  :         pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

  000e0	8b 4d f8	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  000e3	89 4d fc	 mov	 DWORD PTR _pMarkerNode$[ebp], ecx

; 526  : 
; 527  :         if(pMarkerNode->fAllocated)

  000e6	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  000e9	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  000ed	74 02		 je	 SHORT $L32205

; 528  :         {
; 529  :             break;

  000ef	eb 15		 jmp	 SHORT $L32199
$L32205:

; 530  :         }
; 531  : 
; 532  :         pRunMarker = CoalesceRuns(pMarkerNode, pRunMarker);

  000f1	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000f4	50		 push	 eax
  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  000f8	51		 push	 ecx
  000f9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	e8 00 00 00 00	 call	 ?CoalesceRuns@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAU2@0@Z ; CMcpxBufferSgeHeapTest::CoalesceRuns
  00101	89 45 08	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 533  :     }

  00104	eb bb		 jmp	 SHORT $L32198
$L32199:

; 534  : 
; 535  :     //
; 536  :     // Update the largest run pointer
; 537  :     //
; 538  : 
; 539  :     if(m_pLargestFreeRunMarker)

  00106	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00109	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  0010d	74 20		 je	 SHORT $L32206

; 540  :     {
; 541  :         if(pRunMarker->nLength > m_pLargestFreeRunMarker->nLength)

  0010f	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00112	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  00116	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00119	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0011c	0f b7 50 0a	 movzx	 edx, WORD PTR [eax+10]
  00120	3b ca		 cmp	 ecx, edx
  00122	7e 09		 jle	 SHORT $L32207

; 542  :         {
; 543  :             m_pLargestFreeRunMarker = pRunMarker;

  00124	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00127	8b 4d 08	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  0012a	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L32207:

; 544  :         }
; 545  :     }
; 546  :     else

  0012d	eb 09		 jmp	 SHORT $L32182
$L32206:

; 547  :     {
; 548  :         m_pLargestFreeRunMarker = pRunMarker;

  0012f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00132	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00135	89 42 1c	 mov	 DWORD PTR [edx+28], eax
$L32182:

; 549  :     }
; 550  : 
; 551  :     DPF_LEAVE_VOID();
; 552  : }

  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c2 04 00	 ret	 4
?FreeRun@CMcpxBufferSgeHeapTest@@IAEXPAUSGEHEAPRUNMARKER@@@Z ENDP ; CMcpxBufferSgeHeapTest::FreeRun
DSOUND	ENDS
PUBLIC	??_C@_0EH@MGPIEIAF@pRunMarker?9?$DOnElement?5?$CL?5pRunMarke@ ; `string'
PUBLIC	??_C@_0CF@KEHGDJCK@CMcpxBufferSgeHeapTest?3?3Coalesce@ ; `string'
PUBLIC	??_C@_0CJ@OLPJCOOI@Coalescing?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?5and?5@ ; `string'
PUBLIC	?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z	; MoveEntryTailList
;	COMDAT ??_C@_0EH@MGPIEIAF@pRunMarker?9?$DOnElement?5?$CL?5pRunMarke@
DSOUND_RD	SEGMENT
??_C@_0EH@MGPIEIAF@pRunMarker?9?$DOnElement?5?$CL?5pRunMarke@ DB 'pRunMar'
	DB	'ker->nElement + pRunMarker->nLength == pNextRunMarker->nEleme'
	DB	'nt', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@KEHGDJCK@CMcpxBufferSgeHeapTest?3?3Coalesce@
DSOUND_RD	SEGMENT
??_C@_0CF@KEHGDJCK@CMcpxBufferSgeHeapTest?3?3Coalesce@ DB 'CMcpxBufferSge'
	DB	'HeapTest::CoalesceRuns', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CJ@OLPJCOOI@Coalescing?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?5and?5@
DSOUND_RD	SEGMENT
??_C@_0CJ@OLPJCOOI@Coalescing?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?5and?5@ DB 'C'
	DB	'oalescing SGE run %x (%lu) and %x (%lu)', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?CoalesceRuns@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAU2@0@Z
DSOUND	SEGMENT
_this$ = -4
_pRunMarker$ = 8
_pNextRunMarker$ = 12
?CoalesceRuns@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAU2@0@Z PROC NEAR ; CMcpxBufferSgeHeapTest::CoalesceRuns, COMDAT
; _this$ = ecx

; 581  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 582  :     DPF_ENTER();
; 583  : 
; 584  :     ASSERT(pRunMarker->nElement + pRunMarker->nLength == pNextRunMarker->nElement);

  00007	68 48 02 00 00	 push	 584			; 00000248H
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@MGPIEIAF@pRunMarker?9?$DOnElement?5?$CL?5pRunMarke@
  00016	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00019	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  0001d	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00020	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  00024	03 c8		 add	 ecx, eax
  00026	8b 55 0c	 mov	 edx, DWORD PTR _pNextRunMarker$[ebp]
  00029	0f b7 42 08	 movzx	 eax, WORD PTR [edx+8]
  0002d	33 d2		 xor	 edx, edx
  0002f	3b c8		 cmp	 ecx, eax
  00031	0f 95 c2	 setne	 dl
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 _DwDbgAssert
  0003a	83 c4 10	 add	 esp, 16			; 00000010H

; 585  : 
; 586  :     AssertValidEntryList(&pRunMarker->leListEntry, ASSERT_IN_LIST);

  0003d	68 4a 02 00 00	 push	 586			; 0000024aH
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00047	6a 01		 push	 1
  00049	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 587  :     AssertValidEntryList(&pNextRunMarker->leListEntry, ASSERT_IN_LIST);

  00052	68 4b 02 00 00	 push	 587			; 0000024bH
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0005c	6a 01		 push	 1
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR _pNextRunMarker$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 588  : 
; 589  :     DPF_SGE_HEAP("Coalescing SGE run %x (%lu) and %x (%lu)", pRunMarker->nElement, pRunMarker->nLength, pNextRunMarker->nElement, pNextRunMarker->nLength);

  00067	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  0006c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@KEHGDJCK@CMcpxBufferSgeHeapTest?3?3Coalesce@
  00071	68 4d 02 00 00	 push	 589			; 0000024dH
  00076	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0007b	6a 05		 push	 5
  0007d	6a 09		 push	 9
  0007f	e8 00 00 00 00	 call	 _DwDbgSetContext
  00084	83 c4 18	 add	 esp, 24			; 00000018H
  00087	8b 55 0c	 mov	 edx, DWORD PTR _pNextRunMarker$[ebp]
  0008a	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  0008e	50		 push	 eax
  0008f	8b 4d 0c	 mov	 ecx, DWORD PTR _pNextRunMarker$[ebp]
  00092	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  00096	52		 push	 edx
  00097	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0009a	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  0009e	51		 push	 ecx
  0009f	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000a2	0f b7 42 08	 movzx	 eax, WORD PTR [edx+8]
  000a6	50		 push	 eax
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@OLPJCOOI@Coalescing?5SGE?5run?5?$CFx?5?$CI?$CFlu?$CJ?5and?5@
  000ac	e8 00 00 00 00	 call	 _DwDbgPrint
  000b1	83 c4 14	 add	 esp, 20			; 00000014H

; 590  : 
; 591  :     pRunMarker->nLength += pNextRunMarker->nLength;

  000b4	8b 4d 0c	 mov	 ecx, DWORD PTR _pNextRunMarker$[ebp]
  000b7	0f b7 51 0a	 movzx	 edx, WORD PTR [ecx+10]
  000bb	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000be	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  000c2	03 ca		 add	 ecx, edx
  000c4	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000c7	66 89 4a 0a	 mov	 WORD PTR [edx+10], cx

; 592  : 
; 593  :     MoveEntryTailList(&m_lstMarkers, &pNextRunMarker->leListEntry);

  000cb	8b 45 0c	 mov	 eax, DWORD PTR _pNextRunMarker$[ebp]
  000ce	50		 push	 eax
  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000d5	51		 push	 ecx
  000d6	e8 00 00 00 00	 call	 ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z ; MoveEntryTailList

; 594  : 
; 595  :     DPF_LEAVE(pRunMarker);
; 596  : 
; 597  :     return pRunMarker;

  000db	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]

; 598  : }

  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 08 00	 ret	 8
?CoalesceRuns@CMcpxBufferSgeHeapTest@@IAEPAUSGEHEAPRUNMARKER@@PAU2@0@Z ENDP ; CMcpxBufferSgeHeapTest::CoalesceRuns
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ntlist.h
DSOUND	ENDS
;	COMDAT ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z
DSOUND	SEGMENT
_ListHead$ = 8
_Entry$ = 12
?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z PROC NEAR ; MoveEntryTailList, COMDAT

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 233  :     AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

  00003	68 e9 00 00 00	 push	 233			; 000000e9H
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
  0000d	6a 00		 push	 0
  0000f	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 234  :     AssertValidEntryList(Entry, ASSERT_VALID_ONLY);

  00018	68 ea 00 00 00	 push	 234			; 000000eaH
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
  00022	6a 00		 push	 0
  00024	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 235  : 
; 236  :     Entry->Flink->Blink = Entry->Blink;

  0002d	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00035	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00038	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 237  :     Entry->Blink->Flink = Entry->Flink;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0003e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00041	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00044	8b 02		 mov	 eax, DWORD PTR [edx]
  00046	89 01		 mov	 DWORD PTR [ecx], eax

; 238  : 
; 239  :     Entry->Flink = ListHead;

  00048	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0004b	8b 55 08	 mov	 edx, DWORD PTR _ListHead$[ebp]
  0004e	89 11		 mov	 DWORD PTR [ecx], edx

; 240  :     Entry->Blink = ListHead->Blink;

  00050	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  00056	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00059	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 241  : 
; 242  :     Entry->Flink->Blink = Entry;

  0005c	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00064	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 243  :     Entry->Blink->Flink = Entry;

  00067	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0006a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006d	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00070	89 11		 mov	 DWORD PTR [ecx], edx

; 244  : 
; 245  :     AssertValidEntryList(Entry, ASSERT_IN_LIST);

  00072	68 f5 00 00 00	 push	 245			; 000000f5H
  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
  0007c	6a 01		 push	 1
  0007e	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 246  : 
; 247  :     return Entry;

  00087	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]

; 248  : }

  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z ENDP	; MoveEntryTailList
DSOUND	ENDS
PUBLIC	??_C@_0CF@MKDGEMOO@dwSgeIndex?5?$DM?5MCPX_HW_MAX_BUFFER_@ ; `string'
PUBLIC	??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@		; `string'
PUBLIC	??_C@_0CK@JMKAKNMM@?$CB?$CI?$CIDWORD?$CJpvBaseAddress?5?$CG?5?$CIPAGE_S@ ; `string'
PUBLIC	??_C@_08HIKFCPCB@dnLength?$AA@			; `string'
PUBLIC	??_C@_0BP@FIHLJGA@?$CB?$CIdwAddress?5?$CG?5?$CIPAGE_SIZE?5?9?51?$CJ?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CF@OPOAAKHG@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5DISPATCH_L@ ; `string'
PUBLIC	??_C@_0BO@MKPFBHKH@?$CI2?$CJ?5?$DM?$DN?5PIO_METHOD_QUEUE_CLEAR?$AA@ ; `string'
EXTRN	__imp__MmLockUnlockBufferPages@12:NEAR
EXTRN	__imp__MmGetPhysicalAddress@4:NEAR
;	COMDAT ??_C@_0CF@MKDGEMOO@dwSgeIndex?5?$DM?5MCPX_HW_MAX_BUFFER_@
; File c:\xbox\private\windows\directx\dsound\initlib\heap.cpp
DSOUND_RD	SEGMENT
??_C@_0CF@MKDGEMOO@dwSgeIndex?5?$DM?5MCPX_HW_MAX_BUFFER_@ DB 'dwSgeIndex '
	DB	'< MCPX_HW_MAX_BUFFER_PRDS', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@
DSOUND_RD	SEGMENT
??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@ DB 'pvBaseAddress', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CK@JMKAKNMM@?$CB?$CI?$CIDWORD?$CJpvBaseAddress?5?$CG?5?$CIPAGE_S@
DSOUND_RD	SEGMENT
??_C@_0CK@JMKAKNMM@?$CB?$CI?$CIDWORD?$CJpvBaseAddress?5?$CG?5?$CIPAGE_S@ DB '!'
	DB	'((DWORD)pvBaseAddress & (PAGE_SIZE - 1))', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_08HIKFCPCB@dnLength?$AA@
DSOUND_RD	SEGMENT
??_C@_08HIKFCPCB@dnLength?$AA@ DB 'dnLength', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BP@FIHLJGA@?$CB?$CIdwAddress?5?$CG?5?$CIPAGE_SIZE?5?9?51?$CJ?$CJ?$AA@
DSOUND_RD	SEGMENT
??_C@_0BP@FIHLJGA@?$CB?$CIdwAddress?5?$CG?5?$CIPAGE_SIZE?5?9?51?$CJ?$CJ?$AA@ DB '!'
	DB	'(dwAddress & (PAGE_SIZE - 1))', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@OPOAAKHG@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5DISPATCH_L@
DSOUND_RD	SEGMENT
??_C@_0CF@OPOAAKHG@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5DISPATCH_L@ DB 'Ke'
	DB	'GetCurrentIrql() == DISPATCH_LEVEL', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@MKPFBHKH@?$CI2?$CJ?5?$DM?$DN?5PIO_METHOD_QUEUE_CLEAR?$AA@
DSOUND_RD	SEGMENT
??_C@_0BO@MKPFBHKH@?$CI2?$CJ?5?$DM?$DN?5PIO_METHOD_QUEUE_CLEAR?$AA@ DB '('
	DB	'2) <= PIO_METHOD_QUEUE_CLEAR', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?MapBuffer@CMcpxBufferSgeHeapTest@@KGXKPAXK@Z
DSOUND	SEGMENT
_dwAddress$ = -12
_irql$ = -8
_dwSgeIndex$ = 8
_pvBaseAddress$ = 12
_dnLength$ = 16
?MapBuffer@CMcpxBufferSgeHeapTest@@KGXKPAXK@Z PROC NEAR	; CMcpxBufferSgeHeapTest::MapBuffer, COMDAT

; 628  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 629  :     DWORD                   dwAddress;
; 630  :     CIrql                   irql;

  00006	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CIrql@@QAE@XZ	; CIrql::CIrql

; 631  :     
; 632  :     DPF_ENTER();
; 633  : 
; 634  :     ASSERT(dwSgeIndex < MCPX_HW_MAX_BUFFER_PRDS);

  0000e	68 7a 02 00 00	 push	 634			; 0000027aH
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@MKDGEMOO@dwSgeIndex?5?$DM?5MCPX_HW_MAX_BUFFER_@
  0001d	81 7d 08 00 08
	00 00		 cmp	 DWORD PTR _dwSgeIndex$[ebp], 2048 ; 00000800H
  00024	1b c0		 sbb	 eax, eax
  00026	40		 inc	 eax
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _DwDbgAssert
  0002d	83 c4 10	 add	 esp, 16			; 00000010H

; 635  :     ASSERT(pvBaseAddress);

  00030	68 7b 02 00 00	 push	 635			; 0000027bH
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@
  0003f	33 c9		 xor	 ecx, ecx
  00041	83 7d 0c 00	 cmp	 DWORD PTR _pvBaseAddress$[ebp], 0
  00045	0f 94 c1	 sete	 cl
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 _DwDbgAssert
  0004e	83 c4 10	 add	 esp, 16			; 00000010H

; 636  :     ASSERT(!((DWORD)pvBaseAddress & (PAGE_SIZE - 1)));

  00051	68 7c 02 00 00	 push	 636			; 0000027cH
  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@JMKAKNMM@?$CB?$CI?$CIDWORD?$CJpvBaseAddress?5?$CG?5?$CIPAGE_S@
  00060	8b 55 0c	 mov	 edx, DWORD PTR _pvBaseAddress$[ebp]
  00063	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  00069	f7 da		 neg	 edx
  0006b	1b d2		 sbb	 edx, edx
  0006d	f7 da		 neg	 edx
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _DwDbgAssert
  00075	83 c4 10	 add	 esp, 16			; 00000010H

; 637  :     ASSERT(dnLength);

  00078	68 7d 02 00 00	 push	 637			; 0000027dH
  0007d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00082	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08HIKFCPCB@dnLength?$AA@
  00087	33 c0		 xor	 eax, eax
  00089	83 7d 10 00	 cmp	 DWORD PTR _dnLength$[ebp], 0
  0008d	0f 94 c0	 sete	 al
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _DwDbgAssert
  00096	83 c4 10	 add	 esp, 16			; 00000010H

; 638  : 
; 639  :     //
; 640  :     // Lock the buffer data
; 641  :     //
; 642  : 
; 643  :     MmLockUnlockBufferPages(pvBaseAddress, dnLength << PAGE_SHIFT, FALSE);

  00099	6a 00		 push	 0
  0009b	8b 4d 10	 mov	 ecx, DWORD PTR _dnLength$[ebp]
  0009e	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  000a1	51		 push	 ecx
  000a2	8b 55 0c	 mov	 edx, DWORD PTR _pvBaseAddress$[ebp]
  000a5	52		 push	 edx
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmLockUnlockBufferPages@12
$L32230:

; 644  : 
; 645  :     //
; 646  :     // Start mapping pages into SGEs
; 647  :     //
; 648  : 
; 649  :     while(dnLength--)

  000ac	8b 45 10	 mov	 eax, DWORD PTR _dnLength$[ebp]
  000af	8b 4d 10	 mov	 ecx, DWORD PTR _dnLength$[ebp]
  000b2	83 e9 01	 sub	 ecx, 1
  000b5	89 4d 10	 mov	 DWORD PTR _dnLength$[ebp], ecx
  000b8	85 c0		 test	 eax, eax
  000ba	0f 84 ce 00 00
	00		 je	 $L32221

; 650  :     {
; 651  :         dwAddress = MmGetPhysicalAddress(pvBaseAddress);

  000c0	8b 55 0c	 mov	 edx, DWORD PTR _pvBaseAddress$[ebp]
  000c3	52		 push	 edx
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmGetPhysicalAddress@4
  000ca	89 45 f4	 mov	 DWORD PTR _dwAddress$[ebp], eax

; 652  :         ASSERT(!(dwAddress & (PAGE_SIZE - 1)));

  000cd	68 8c 02 00 00	 push	 652			; 0000028cH
  000d2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  000d7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@FIHLJGA@?$CB?$CIdwAddress?5?$CG?5?$CIPAGE_SIZE?5?9?51?$CJ?$CJ?$AA@
  000dc	8b 45 f4	 mov	 eax, DWORD PTR _dwAddress$[ebp]
  000df	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000e4	f7 d8		 neg	 eax
  000e6	1b c0		 sbb	 eax, eax
  000e8	f7 d8		 neg	 eax
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 _DwDbgAssert
  000f0	83 c4 10	 add	 esp, 16			; 00000010H

; 653  : 
; 654  :         irql.Raise();

  000f3	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  000f6	e8 00 00 00 00	 call	 ?Raise@CIrql@@QAEXXZ	; CIrql::Raise

; 655  :         
; 656  :         MCPX_CHECK_VOICE_FIFO(2);

  000fb	68 90 02 00 00	 push	 656			; 00000290H
  00100	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00105	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@OPOAAKHG@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5DISPATCH_L@
  0010a	e8 00 00 00 00	 call	 _KeGetCurrentIrql@0
  0010f	0f b6 c8	 movzx	 ecx, al
  00112	33 d2		 xor	 edx, edx
  00114	83 f9 02	 cmp	 ecx, 2
  00117	0f 95 c2	 setne	 dl
  0011a	52		 push	 edx
  0011b	e8 00 00 00 00	 call	 _DwDbgAssert
  00120	83 c4 10	 add	 esp, 16			; 00000010H
  00123	68 90 02 00 00	 push	 656			; 00000290H
  00128	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0012d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@MKPFBHKH@?$CI2?$CJ?5?$DM?$DN?5PIO_METHOD_QUEUE_CLEAR?$AA@
  00132	6a 00		 push	 0
  00134	e8 00 00 00 00	 call	 _DwDbgAssert
  00139	83 c4 10	 add	 esp, 16			; 00000010H
$L32236:
  0013c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00141	8b 88 00 00 82
	fe		 mov	 ecx, DWORD PTR [eax-25034752]
  00147	c1 e9 02	 shr	 ecx, 2
  0014a	83 f9 02	 cmp	 ecx, 2
  0014d	73 02		 jae	 SHORT $L32237
  0014f	eb eb		 jmp	 SHORT $L32236
$L32237:

; 657  : 
; 658  :         MCPX_VOICE_WRITE(SetCurrentInBufSGE, dwSgeIndex);

  00151	ba 04 08 00 00	 mov	 edx, 2052		; 00000804H
  00156	8b 45 08	 mov	 eax, DWORD PTR _dwSgeIndex$[ebp]
  00159	89 82 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], eax

; 659  :         MCPX_VOICE_WRITE(SetCurrentInBufSGEOffset, dwAddress);

  0015f	b9 08 08 00 00	 mov	 ecx, 2056		; 00000808H
  00164	8b 55 f4	 mov	 edx, DWORD PTR _dwAddress$[ebp]
  00167	89 91 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], edx

; 660  : 
; 661  :         irql.Lower();

  0016d	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00170	e8 00 00 00 00	 call	 ?Lower@CIrql@@QAEXXZ	; CIrql::Lower

; 662  : 
; 663  :         pvBaseAddress = (LPBYTE)pvBaseAddress + PAGE_SIZE;

  00175	8b 45 0c	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  00178	05 00 10 00 00	 add	 eax, 4096		; 00001000H
  0017d	89 45 0c	 mov	 DWORD PTR _pvBaseAddress$[ebp], eax

; 664  :         
; 665  :         dwSgeIndex++;

  00180	8b 4d 08	 mov	 ecx, DWORD PTR _dwSgeIndex$[ebp]
  00183	83 c1 01	 add	 ecx, 1
  00186	89 4d 08	 mov	 DWORD PTR _dwSgeIndex$[ebp], ecx

; 666  :     }

  00189	e9 1e ff ff ff	 jmp	 $L32230
$L32221:

; 667  : 
; 668  :     DPF_LEAVE_VOID();
; 669  : }

  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c2 0c 00	 ret	 12			; 0000000cH
?MapBuffer@CMcpxBufferSgeHeapTest@@KGXKPAXK@Z ENDP	; CMcpxBufferSgeHeapTest::MapBuffer
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?UnmapBuffer@CMcpxBufferSgeHeapTest@@KGXPAXK@Z
DSOUND	SEGMENT
_pvBaseAddress$ = 8
_dnLength$ = 12
?UnmapBuffer@CMcpxBufferSgeHeapTest@@KGXPAXK@Z PROC NEAR ; CMcpxBufferSgeHeapTest::UnmapBuffer, COMDAT

; 697  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 698  :     DPF_ENTER();
; 699  : 
; 700  :     ASSERT(pvBaseAddress);

  00003	68 bc 02 00 00	 push	 700			; 000002bcH
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@
  00012	33 c0		 xor	 eax, eax
  00014	83 7d 08 00	 cmp	 DWORD PTR _pvBaseAddress$[ebp], 0
  00018	0f 94 c0	 sete	 al
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _DwDbgAssert
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 701  :     ASSERT(!((DWORD)pvBaseAddress & (PAGE_SIZE - 1)));

  00024	68 bd 02 00 00	 push	 701			; 000002bdH
  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@JMKAKNMM@?$CB?$CI?$CIDWORD?$CJpvBaseAddress?5?$CG?5?$CIPAGE_S@
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  00036	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  0003c	f7 d9		 neg	 ecx
  0003e	1b c9		 sbb	 ecx, ecx
  00040	f7 d9		 neg	 ecx
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 _DwDbgAssert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 702  :     ASSERT(dnLength);

  0004b	68 be 02 00 00	 push	 702			; 000002beH
  00050	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00055	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08HIKFCPCB@dnLength?$AA@
  0005a	33 d2		 xor	 edx, edx
  0005c	83 7d 0c 00	 cmp	 DWORD PTR _dnLength$[ebp], 0
  00060	0f 94 c2	 sete	 dl
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 _DwDbgAssert
  00069	83 c4 10	 add	 esp, 16			; 00000010H

; 703  : 
; 704  :     //
; 705  :     // Unlock the buffer data
; 706  :     //
; 707  : 
; 708  :     MmLockUnlockBufferPages(pvBaseAddress, dnLength << PAGE_SHIFT, TRUE);

  0006c	6a 01		 push	 1
  0006e	8b 45 0c	 mov	 eax, DWORD PTR _dnLength$[ebp]
  00071	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00074	50		 push	 eax
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  00078	51		 push	 ecx
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmLockUnlockBufferPages@12

; 709  : 
; 710  :     DPF_LEAVE_VOID();
; 711  : }

  0007f	5d		 pop	 ebp
  00080	c2 08 00	 ret	 8
?UnmapBuffer@CMcpxBufferSgeHeapTest@@KGXPAXK@Z ENDP	; CMcpxBufferSgeHeapTest::UnmapBuffer
DSOUND	ENDS
CRT$XCU	SEGMENT
_$S2	DD	FLAT:_$E1
; Function compile flags: /Odt
CRT$XCU	ENDS
;	COMDAT _$E1
DSOUND	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 733  : DWORD &CMcpxSlopMemoryHeapTest::m_dwAvailable = g_dwDirectSoundTestPhysicalMemorySlop;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_dwAvailable@CMcpxSlopMemoryHeapTest@@2AAKA, OFFSET FLAT:_g_dwDirectSoundTestPhysicalMemorySlop ; CMcpxSlopMemoryHeapTest::m_dwAvailable
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_$E1	ENDP
DSOUND	ENDS
CRT$XCU	SEGMENT
_$S4	DD	FLAT:_$E3
; Function compile flags: /Odt
CRT$XCU	ENDS
;	COMDAT _$E3
DSOUND	SEGMENT
_$E3	PROC NEAR					; COMDAT

; 734  : DWORD &CMcpxSlopMemoryHeapTest::m_dwUsed = g_dwDirectSoundTestPhysicalMemoryRecovered;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeapTest@@2AAKA, OFFSET FLAT:_g_dwDirectSoundTestPhysicalMemoryRecovered ; CMcpxSlopMemoryHeapTest::m_dwUsed
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_$E3	ENDP
DSOUND	ENDS
PUBLIC	??0CRefCountTest@@QAE@K@Z			; CRefCountTest::CRefCountTest
PUBLIC	?AddRef@CRefCountTest@@UAGKXZ			; CRefCountTest::AddRef
PUBLIC	?Release@CRefCountTest@@UAGKXZ			; CRefCountTest::Release
PUBLIC	??0CMcpxSlopMemoryHeapTest@@QAE@XZ		; CMcpxSlopMemoryHeapTest::CMcpxSlopMemoryHeapTest
PUBLIC	??_7CMcpxSlopMemoryHeapTest@@6B@		; CMcpxSlopMemoryHeapTest::`vftable'
PUBLIC	??_GCMcpxSlopMemoryHeapTest@@UAEPAXI@Z		; CMcpxSlopMemoryHeapTest::`scalar deleting destructor'
PUBLIC	??_C@_0P@BDCAGIHP@?$CBm_dwAvailable?$AA@	; `string'
PUBLIC	??_C@_09DCOKMFNA@?$CBm_dwUsed?$AA@		; `string'
PUBLIC	??_C@_0CC@JMLOFGEJ@?$CBg_pDirectSoundTestSlopMemoryHea@ ; `string'
EXTRN	??_ECMcpxSlopMemoryHeapTest@@UAEPAXI@Z:NEAR	; CMcpxSlopMemoryHeapTest::`vector deleting destructor'
;	COMDAT ??_7CMcpxSlopMemoryHeapTest@@6B@
CONST	SEGMENT
??_7CMcpxSlopMemoryHeapTest@@6B@ DD FLAT:??_ECMcpxSlopMemoryHeapTest@@UAEPAXI@Z ; CMcpxSlopMemoryHeapTest::`vftable'
	DD	FLAT:?AddRef@CRefCountTest@@UAGKXZ
	DD	FLAT:?Release@CRefCountTest@@UAGKXZ
CONST	ENDS
;	COMDAT ??_C@_0P@BDCAGIHP@?$CBm_dwAvailable?$AA@
DSOUND_RD	SEGMENT
??_C@_0P@BDCAGIHP@?$CBm_dwAvailable?$AA@ DB '!m_dwAvailable', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_09DCOKMFNA@?$CBm_dwUsed?$AA@
DSOUND_RD	SEGMENT
??_C@_09DCOKMFNA@?$CBm_dwUsed?$AA@ DB '!m_dwUsed', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@JMLOFGEJ@?$CBg_pDirectSoundTestSlopMemoryHea@
DSOUND_RD	SEGMENT
??_C@_0CC@JMLOFGEJ@?$CBg_pDirectSoundTestSlopMemoryHea@ DB '!g_pDirectSou'
	DB	'ndTestSlopMemoryHeap', 00H			; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ??0CMcpxSlopMemoryHeapTest@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CMcpxSlopMemoryHeapTest@@QAE@XZ PROC NEAR		; CMcpxSlopMemoryHeapTest::CMcpxSlopMemoryHeapTest, COMDAT
; _this$ = ecx

; 740  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 01		 push	 1
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CRefCountTest@@QAE@K@Z ; CRefCountTest::CRefCountTest
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMcpxSlopMemoryHeapTest@@6B@

; 741  :     DPF_ENTER();
; 742  : 
; 743  :     ASSERT(!m_dwAvailable);

  0001a	68 e7 02 00 00	 push	 743			; 000002e7H
  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00024	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@BDCAGIHP@?$CBm_dwAvailable?$AA@
  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwAvailable@CMcpxSlopMemoryHeapTest@@2AAKA ; CMcpxSlopMemoryHeapTest::m_dwAvailable
  0002f	33 d2		 xor	 edx, edx
  00031	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00034	0f 95 c2	 setne	 dl
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 _DwDbgAssert
  0003d	83 c4 10	 add	 esp, 16			; 00000010H

; 744  :     ASSERT(!m_dwUsed);

  00040	68 e8 02 00 00	 push	 744			; 000002e8H
  00045	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09DCOKMFNA@?$CBm_dwUsed?$AA@
  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeapTest@@2AAKA ; CMcpxSlopMemoryHeapTest::m_dwUsed
  00054	33 c9		 xor	 ecx, ecx
  00056	83 38 00	 cmp	 DWORD PTR [eax], 0
  00059	0f 95 c1	 setne	 cl
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 _DwDbgAssert
  00062	83 c4 10	 add	 esp, 16			; 00000010H

; 745  : 
; 746  :     ASSERT(!g_pDirectSoundTestSlopMemoryHeap);

  00065	68 ea 02 00 00	 push	 746			; 000002eaH
  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0006f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@JMLOFGEJ@?$CBg_pDirectSoundTestSlopMemoryHea@
  00074	33 d2		 xor	 edx, edx
  00076	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pDirectSoundTestSlopMemoryHeap@@3PAVCMcpxSlopMemoryHeapTest@@A, 0 ; g_pDirectSoundTestSlopMemoryHeap
  0007d	0f 95 c2	 setne	 dl
  00080	52		 push	 edx
  00081	e8 00 00 00 00	 call	 _DwDbgAssert
  00086	83 c4 10	 add	 esp, 16			; 00000010H

; 747  :     g_pDirectSoundTestSlopMemoryHeap = this;

  00089	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	a3 00 00 00 00	 mov	 DWORD PTR ?g_pDirectSoundTestSlopMemoryHeap@@3PAVCMcpxSlopMemoryHeapTest@@A, eax ; g_pDirectSoundTestSlopMemoryHeap

; 748  : 
; 749  :     InitializeListHead(&m_lstEntries);

  00091	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	83 c1 08	 add	 ecx, 8
  00097	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009a	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0009d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000a6	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 750  :     InitializeListHead(&m_lstRuns);

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	83 c0 10	 add	 eax, 16			; 00000010H
  000af	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  000b5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000be	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 751  : 
; 752  :     DPF_LEAVE_VOID();
; 753  : }

  000c1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
??0CMcpxSlopMemoryHeapTest@@QAE@XZ ENDP			; CMcpxSlopMemoryHeapTest::CMcpxSlopMemoryHeapTest
DSOUND	ENDS
PUBLIC	??_7CRefCountTest@@6B@				; CRefCountTest::`vftable'
PUBLIC	??_GCRefCountTest@@UAEPAXI@Z			; CRefCountTest::`scalar deleting destructor'
EXTRN	??_ECRefCountTest@@UAEPAXI@Z:NEAR		; CRefCountTest::`vector deleting destructor'
;	COMDAT ??_7CRefCountTest@@6B@
; File c:\xbox\private\windows\directx\dsound\initlib\refcount.h
CONST	SEGMENT
??_7CRefCountTest@@6B@ DD FLAT:??_ECRefCountTest@@UAEPAXI@Z ; CRefCountTest::`vftable'
	DD	FLAT:?AddRef@CRefCountTest@@UAGKXZ
	DD	FLAT:?Release@CRefCountTest@@UAGKXZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CRefCountTest@@QAE@K@Z
DSOUND	SEGMENT
_this$ = -4
_dwInitialRefCount$ = 8
??0CRefCountTest@@QAE@K@Z PROC NEAR			; CRefCountTest::CRefCountTest, COMDAT
; _this$ = ecx

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CRefCountTest@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _dwInitialRefCount$[ebp]
  00016	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 36   : }

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??0CRefCountTest@@QAE@K@Z ENDP				; CRefCountTest::CRefCountTest
DSOUND	ENDS
PUBLIC	??1CRefCountTest@@UAE@XZ			; CRefCountTest::~CRefCountTest
; Function compile flags: /Odt
;	COMDAT ??_GCRefCountTest@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCRefCountTest@@UAEPAXI@Z PROC NEAR			; CRefCountTest::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CRefCountTest@@UAE@XZ ; CRefCountTest::~CRefCountTest
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L29812
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L29812:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCRefCountTest@@UAEPAXI@Z ENDP			; CRefCountTest::`scalar deleting destructor'
DSOUND	ENDS
PUBLIC	??_C@_0DK@BHCCMBKD@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0O@GGBLDHEI@?$CBm_dwRefCount?$AA@		; `string'
;	COMDAT ??_C@_0DK@BHCCMBKD@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT
??_C@_0DK@BHCCMBKD@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\initlib\refcount.h', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0O@GGBLDHEI@?$CBm_dwRefCount?$AA@
DSOUND_RD	SEGMENT
??_C@_0O@GGBLDHEI@?$CBm_dwRefCount?$AA@ DB '!m_dwRefCount', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ??1CRefCountTest@@UAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CRefCountTest@@UAE@XZ PROC NEAR			; CRefCountTest::~CRefCountTest, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CRefCountTest@@6B@

; 40   :     ASSERT(!m_dwRefCount);

  00010	6a 28		 push	 40			; 00000028H
  00012	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@BHCCMBKD@c?3?2xbox?2private?2windows?2directx?2@
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@GGBLDHEI@?$CBm_dwRefCount?$AA@
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	33 d2		 xor	 edx, edx
  00021	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00025	0f 95 c2	 setne	 dl
  00028	52		 push	 edx
  00029	e8 00 00 00 00	 call	 _DwDbgAssert
  0002e	83 c4 10	 add	 esp, 16			; 00000010H

; 41   : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??1CRefCountTest@@UAE@XZ ENDP				; CRefCountTest::~CRefCountTest
DSOUND	ENDS
PUBLIC	??_C@_0BE@DAEOBIBM@m_dwRefCount?5?$DM?5?$HO0UL?$AA@ ; `string'
;	COMDAT ??_C@_0BE@DAEOBIBM@m_dwRefCount?5?$DM?5?$HO0UL?$AA@
DSOUND_RD	SEGMENT
??_C@_0BE@DAEOBIBM@m_dwRefCount?5?$DM?5?$HO0UL?$AA@ DB 'm_dwRefCount < ~0'
	DB	'UL', 00H					; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?AddRef@CRefCountTest@@UAGKXZ
DSOUND	SEGMENT
_this$ = 8
?AddRef@CRefCountTest@@UAGKXZ PROC NEAR			; CRefCountTest::AddRef, COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   :     ASSERT(m_dwRefCount < ~0UL);

  00003	6a 2d		 push	 45			; 0000002dH
  00005	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@BHCCMBKD@c?3?2xbox?2private?2windows?2directx?2@
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@DAEOBIBM@m_dwRefCount?5?$DM?5?$HO0UL?$AA@
  0000f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 04 ff	 cmp	 DWORD PTR [eax+4], -1
  00016	1b c9		 sbb	 ecx, ecx
  00018	41		 inc	 ecx
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 _DwDbgAssert
  0001f	83 c4 10	 add	 esp, 16			; 00000010H

; 46   :     return ++m_dwRefCount;

  00022	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00028	83 c0 01	 add	 eax, 1
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00031	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00034	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 47   : }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?AddRef@CRefCountTest@@UAGKXZ ENDP			; CRefCountTest::AddRef
DSOUND	ENDS
PUBLIC	??_C@_0N@OILPJBKD@m_dwRefCount?$AA@		; `string'
;	COMDAT ??_C@_0N@OILPJBKD@m_dwRefCount?$AA@
DSOUND_RD	SEGMENT
??_C@_0N@OILPJBKD@m_dwRefCount?$AA@ DB 'm_dwRefCount', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Release@CRefCountTest@@UAGKXZ
DSOUND	SEGMENT
tv84 = -12
$T32723 = -8
$T32722 = -4
_this$ = 8
?Release@CRefCountTest@@UAGKXZ PROC NEAR		; CRefCountTest::Release, COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 51   :     ASSERT(m_dwRefCount);

  00006	6a 33		 push	 51			; 00000033H
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@BHCCMBKD@c?3?2xbox?2private?2windows?2directx?2@
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@OILPJBKD@m_dwRefCount?$AA@
  00012	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00015	33 c9		 xor	 ecx, ecx
  00017	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001b	0f 94 c1	 sete	 cl
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _DwDbgAssert
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 52   : 
; 53   :     if(m_dwRefCount > 0)

  00027	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0002e	76 46		 jbe	 SHORT $L29829

; 54   :     {
; 55   :         if(!--m_dwRefCount)

  00030	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00036	83 e9 01	 sub	 ecx, 1
  00039	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0003f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00046	75 2e		 jne	 SHORT $L29829

; 56   :         {
; 57   :             delete this;

  00048	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	89 4d f8	 mov	 DWORD PTR $T32723[ebp], ecx
  0004e	8b 55 f8	 mov	 edx, DWORD PTR $T32723[ebp]
  00051	89 55 fc	 mov	 DWORD PTR $T32722[ebp], edx
  00054	83 7d fc 00	 cmp	 DWORD PTR $T32722[ebp], 0
  00058	74 11		 je	 SHORT $L32724
  0005a	6a 01		 push	 1
  0005c	8b 45 fc	 mov	 eax, DWORD PTR $T32722[ebp]
  0005f	8b 10		 mov	 edx, DWORD PTR [eax]
  00061	8b 4d fc	 mov	 ecx, DWORD PTR $T32722[ebp]
  00064	ff 12		 call	 DWORD PTR [edx]
  00066	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
  00069	eb 07		 jmp	 SHORT $L32725
$L32724:
  0006b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
$L32725:

; 58   :             return 0;

  00072	33 c0		 xor	 eax, eax
  00074	eb 06		 jmp	 SHORT $L29827
$L29829:

; 59   :         }
; 60   :     }
; 61   : 
; 62   :     return m_dwRefCount;

  00076	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00079	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
$L29827:

; 63   : }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
?Release@CRefCountTest@@UAGKXZ ENDP			; CRefCountTest::Release
DSOUND	ENDS
PUBLIC	??1CMcpxSlopMemoryHeapTest@@UAE@XZ		; CMcpxSlopMemoryHeapTest::~CMcpxSlopMemoryHeapTest
; Function compile flags: /Odt
;	COMDAT ??_GCMcpxSlopMemoryHeapTest@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCMcpxSlopMemoryHeapTest@@UAEPAXI@Z PROC NEAR	; CMcpxSlopMemoryHeapTest::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMcpxSlopMemoryHeapTest@@UAE@XZ ; CMcpxSlopMemoryHeapTest::~CMcpxSlopMemoryHeapTest
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L32272
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L32272:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCMcpxSlopMemoryHeapTest@@UAEPAXI@Z ENDP		; CMcpxSlopMemoryHeapTest::`scalar deleting destructor'
DSOUND	ENDS
PUBLIC	??0CAutoIrql@@QAE@XZ				; CAutoIrql::CAutoIrql
PUBLIC	??1CAutoIrql@@QAE@XZ				; CAutoIrql::~CAutoIrql
PUBLIC	??_C@_0BJ@ENDNGINI@?$CBpMarkerNode?9?$DOfAllocated?$AA@ ; `string'
PUBLIC	??_C@_0CJ@ECJOOPDJ@this?5?$DN?$DN?5g_pDirectSoundTestSlopMe@ ; `string'
EXTRN	_DirectSoundTestTrackingPhysicalFree@4:NEAR
;	COMDAT ??_C@_0BJ@ENDNGINI@?$CBpMarkerNode?9?$DOfAllocated?$AA@
; File c:\xbox\private\windows\directx\dsound\initlib\heap.cpp
DSOUND_RD	SEGMENT
??_C@_0BJ@ENDNGINI@?$CBpMarkerNode?9?$DOfAllocated?$AA@ DB '!pMarkerNode-'
	DB	'>fAllocated', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CJ@ECJOOPDJ@this?5?$DN?$DN?5g_pDirectSoundTestSlopMe@
DSOUND_RD	SEGMENT
??_C@_0CJ@ECJOOPDJ@this?5?$DN?$DN?5g_pDirectSoundTestSlopMe@ DB 'this == '
	DB	'g_pDirectSoundTestSlopMemoryHeap', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ??1CMcpxSlopMemoryHeapTest@@UAE@XZ
DSOUND	SEGMENT
_this$ = -28
___AutoIrql$ = -24
_pEntryNode$ = -16
_pleEntry$ = -12
_pvBaseAddress$ = -8
_pMarkerNode$ = -4
??1CMcpxSlopMemoryHeapTest@@UAE@XZ PROC NEAR		; CMcpxSlopMemoryHeapTest::~CMcpxSlopMemoryHeapTest, COMDAT
; _this$ = ecx

; 778  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMcpxSlopMemoryHeapTest@@6B@

; 779  : 
; 780  : #ifdef DEBUG
; 781  : 
; 782  :     LPSLOPRUNMARKER         pMarkerNode;
; 783  : 
; 784  : #endif // DEBUG
; 785  : 
; 786  :     PLIST_ENTRY             pleEntry;
; 787  :     LPSLOPMEMENTRY          pEntryNode;
; 788  :     LPVOID                  pvBaseAddress;
; 789  : 
; 790  :     DPF_ENTER();
; 791  :     AutoIrql();

  00012	8d 4d e8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00015	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 792  : 
; 793  : #ifdef DEBUG
; 794  : 
; 795  :     // 
; 796  :     // Make sure no memory is still being used
; 797  :     //
; 798  :     
; 799  :     for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)

  0001a	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00020	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx
  00023	eb 08		 jmp	 SHORT $L32282
$L32283:
  00025	8b 45 f4	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	89 4d f4	 mov	 DWORD PTR _pleEntry$[ebp], ecx
$L32282:
  0002d	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00030	83 c2 10	 add	 edx, 16			; 00000010H
  00033	39 55 f4	 cmp	 DWORD PTR _pleEntry$[ebp], edx
  00036	74 2c		 je	 SHORT $L32284

; 800  :     {
; 801  :         pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

  00038	8b 45 f4	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  0003b	89 45 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], eax

; 802  : 
; 803  :         ASSERT(!pMarkerNode->fAllocated);

  0003e	68 23 03 00 00	 push	 803			; 00000323H
  00043	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00048	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@ENDNGINI@?$CBpMarkerNode?9?$DOfAllocated?$AA@
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  00050	33 d2		 xor	 edx, edx
  00052	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00056	0f 95 c2	 setne	 dl
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 _DwDbgAssert
  0005f	83 c4 10	 add	 esp, 16			; 00000010H

; 804  :     }

  00062	eb c1		 jmp	 SHORT $L32283
$L32284:

; 805  : 
; 806  : #endif // DEBUG
; 807  : 
; 808  :     //
; 809  :     // Free the global pointer
; 810  :     //
; 811  :     
; 812  :     ASSERT(this == g_pDirectSoundTestSlopMemoryHeap);

  00064	68 2c 03 00 00	 push	 812			; 0000032cH
  00069	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@ECJOOPDJ@this?5?$DN?$DN?5g_pDirectSoundTestSlopMe@
  00073	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00076	33 c9		 xor	 ecx, ecx
  00078	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_pDirectSoundTestSlopMemoryHeap@@3PAVCMcpxSlopMemoryHeapTest@@A ; g_pDirectSoundTestSlopMemoryHeap
  0007e	0f 95 c1	 setne	 cl
  00081	51		 push	 ecx
  00082	e8 00 00 00 00	 call	 _DwDbgAssert
  00087	83 c4 10	 add	 esp, 16			; 00000010H

; 813  :     g_pDirectSoundTestSlopMemoryHeap = NULL;

  0008a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_pDirectSoundTestSlopMemoryHeap@@3PAVCMcpxSlopMemoryHeapTest@@A, 0 ; g_pDirectSoundTestSlopMemoryHeap
$L32292:

; 814  : 
; 815  :     //
; 816  :     // Free memory owned by the heap
; 817  :     //
; 818  : 
; 819  :     while((pleEntry = RemoveHeadList(&m_lstEntries)) != &m_lstEntries)

  00094	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00097	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList
  000a0	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax
  000a3	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	83 c1 08	 add	 ecx, 8
  000a9	39 4d f4	 cmp	 DWORD PTR _pleEntry$[ebp], ecx
  000ac	74 27		 je	 SHORT $L32293

; 820  :     {
; 821  :         pEntryNode = CONTAINING_RECORD(pleEntry, SLOPMEMENTRY, leListEntry);

  000ae	8b 55 f4	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  000b1	89 55 f0	 mov	 DWORD PTR _pEntryNode$[ebp], edx

; 822  :         pvBaseAddress = pEntryNode->pvBaseAddress;

  000b4	8b 45 f0	 mov	 eax, DWORD PTR _pEntryNode$[ebp]
  000b7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ba	89 4d f8	 mov	 DWORD PTR _pvBaseAddress$[ebp], ecx

; 823  :         
; 824  :         PHYSFREE(pvBaseAddress);

  000bd	83 7d f8 00	 cmp	 DWORD PTR _pvBaseAddress$[ebp], 0
  000c1	74 10		 je	 SHORT $L32298
  000c3	8b 55 f8	 mov	 edx, DWORD PTR _pvBaseAddress$[ebp]
  000c6	52		 push	 edx
  000c7	e8 00 00 00 00	 call	 _DirectSoundTestTrackingPhysicalFree@4
  000cc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pvBaseAddress$[ebp], 0
$L32298:

; 825  :     }

  000d3	eb bf		 jmp	 SHORT $L32292
$L32293:

; 826  : 
; 827  :     //
; 828  :     // Reset tracking values
; 829  :     //
; 830  : 
; 831  :     ASSERT(!m_dwUsed);

  000d5	68 3f 03 00 00	 push	 831			; 0000033fH
  000da	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  000df	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09DCOKMFNA@?$CBm_dwUsed?$AA@
  000e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeapTest@@2AAKA ; CMcpxSlopMemoryHeapTest::m_dwUsed
  000e9	33 c9		 xor	 ecx, ecx
  000eb	83 38 00	 cmp	 DWORD PTR [eax], 0
  000ee	0f 95 c1	 setne	 cl
  000f1	51		 push	 ecx
  000f2	e8 00 00 00 00	 call	 _DwDbgAssert
  000f7	83 c4 10	 add	 esp, 16			; 00000010H

; 832  : 
; 833  :     m_dwAvailable = 0;

  000fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwAvailable@CMcpxSlopMemoryHeapTest@@2AAKA ; CMcpxSlopMemoryHeapTest::m_dwAvailable
  00100	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 834  :     m_dwUsed = 0;

  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeapTest@@2AAKA ; CMcpxSlopMemoryHeapTest::m_dwUsed
  0010b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 835  : 
; 836  :     DPF_LEAVE_VOID();
; 837  : }

  00111	8d 4d e8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00114	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  00119	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	e8 00 00 00 00	 call	 ??1CRefCountTest@@UAE@XZ ; CRefCountTest::~CRefCountTest
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c3		 ret	 0
??1CMcpxSlopMemoryHeapTest@@UAE@XZ ENDP			; CMcpxSlopMemoryHeapTest::~CMcpxSlopMemoryHeapTest
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\drvhlp.h
DSOUND	ENDS
;	COMDAT ??0CAutoIrql@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CAutoIrql@@QAE@XZ PROC NEAR				; CAutoIrql::CAutoIrql, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CIrql@@QAE@XZ	; CIrql::CIrql

; 73   :     Raise();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?Raise@CIrql@@QAEXXZ	; CIrql::Raise

; 74   : }

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CAutoIrql@@QAE@XZ ENDP				; CAutoIrql::CAutoIrql
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??1CAutoIrql@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CAutoIrql@@QAE@XZ PROC NEAR				; CAutoIrql::~CAutoIrql, COMDAT
; _this$ = ecx

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   :     Lower();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Lower@CIrql@@QAEXXZ	; CIrql::Lower

; 79   : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CAutoIrql@@QAE@XZ ENDP				; CAutoIrql::~CAutoIrql
DSOUND	ENDS
PUBLIC	?AddRun@CMcpxSlopMemoryHeapTest@@QAEHPAXKK@Z	; CMcpxSlopMemoryHeapTest::AddRun
PUBLIC	?CreateMarker@CMcpxSlopMemoryHeapTest@@IAEPAUSLOPRUNMARKER@@PAXKPAU_LIST_ENTRY@@@Z ; CMcpxSlopMemoryHeapTest::CreateMarker
PUBLIC	??_C@_0BB@IJHIFFPC@nLength?5?$DO?$DN?5nUsed?$AA@ ; `string'
PUBLIC	??_C@_0CA@LEMCKDJM@CMcpxSlopMemoryHeapTest?3?3AddRun?$AA@ ; `string'
PUBLIC	??_C@_0HM@DHDLHGJJ@Added?5?$CFx?5to?5the?5slop?5heap?5?$CIentry@ ; `string'
;	COMDAT ??_C@_0BB@IJHIFFPC@nLength?5?$DO?$DN?5nUsed?$AA@
; File c:\xbox\private\windows\directx\dsound\initlib\heap.cpp
DSOUND_RD	SEGMENT
??_C@_0BB@IJHIFFPC@nLength?5?$DO?$DN?5nUsed?$AA@ DB 'nLength >= nUsed', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@LEMCKDJM@CMcpxSlopMemoryHeapTest?3?3AddRun?$AA@
DSOUND_RD	SEGMENT
??_C@_0CA@LEMCKDJM@CMcpxSlopMemoryHeapTest?3?3AddRun?$AA@ DB 'CMcpxSlopMe'
	DB	'moryHeapTest::AddRun', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0HM@DHDLHGJJ@Added?5?$CFx?5to?5the?5slop?5heap?5?$CIentry@
DSOUND_RD	SEGMENT
??_C@_0HM@DHDLHGJJ@Added?5?$CFx?5to?5the?5slop?5heap?5?$CIentry@ DB 'Adde'
	DB	'd %x to the slop heap (entry %x, run marker %x, length %lu, %'
	DB	'lu bytes used for tracking, %lu bytes used for run marker)', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?AddRun@CMcpxSlopMemoryHeapTest@@QAEHPAXKK@Z
DSOUND	SEGMENT
_this$ = -32
$T32741 = -28
___AutoIrql$ = -24
_pRunMarker$ = -16
_nSlopLength$ = -12
_fOwned$ = -8
_pEntry$ = -4
_pvBaseAddress$ = 8
_nLength$ = 12
_nUsed$ = 16
?AddRun@CMcpxSlopMemoryHeapTest@@QAEHPAXKK@Z PROC NEAR	; CMcpxSlopMemoryHeapTest::AddRun, COMDAT
; _this$ = ecx

; 870  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 871  :     DWORD                   nSlopLength;
; 872  :     LPSLOPRUNMARKER         pRunMarker;
; 873  :     LPSLOPMEMENTRY          pEntry;
; 874  :     BOOL                    fOwned;
; 875  :     
; 876  :     DPF_ENTER();
; 877  :     AutoIrql();

  00009	8d 4d e8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 878  : 
; 879  :     //
; 880  :     // Make sure the run is large enough to hold the tracking entry, at least
; 881  :     // one run marker and still have some space left over for data.
; 882  :     //
; 883  : 
; 884  :     ASSERT(nLength >= nUsed);

  00011	68 74 03 00 00	 push	 884			; 00000374H
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@IJHIFFPC@nLength?5?$DO?$DN?5nUsed?$AA@
  00020	8b 45 0c	 mov	 eax, DWORD PTR _nLength$[ebp]
  00023	3b 45 10	 cmp	 eax, DWORD PTR _nUsed$[ebp]
  00026	1b c9		 sbb	 ecx, ecx
  00028	f7 d9		 neg	 ecx
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 _DwDbgAssert
  00030	83 c4 10	 add	 esp, 16			; 00000010H

; 885  :     nSlopLength = nLength - nUsed;

  00033	8b 55 0c	 mov	 edx, DWORD PTR _nLength$[ebp]
  00036	2b 55 10	 sub	 edx, DWORD PTR _nUsed$[ebp]
  00039	89 55 f4	 mov	 DWORD PTR _nSlopLength$[ebp], edx

; 886  : 
; 887  :     if(fOwned = (nSlopLength > sizeof(*pEntry) + sizeof(*pRunMarker) + m_dwUsageThreshold))

  0003c	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  00041	3b 45 f4	 cmp	 eax, DWORD PTR _nSlopLength$[ebp]
  00044	1b c9		 sbb	 ecx, ecx
  00046	f7 d9		 neg	 ecx
  00048	89 4d f8	 mov	 DWORD PTR _fOwned$[ebp], ecx
  0004b	83 7d f8 00	 cmp	 DWORD PTR _fOwned$[ebp], 0
  0004f	0f 84 c3 00 00
	00		 je	 $L32311

; 888  :     {
; 889  :         //
; 890  :         // Add the allocation to the entry list so we can free it later.  
; 891  :         // We'll use the first part of the unused memory as the entry marker
; 892  :         //
; 893  : 
; 894  :         pEntry = (LPSLOPMEMENTRY)((LPBYTE)pvBaseAddress + nUsed);

  00055	8b 55 08	 mov	 edx, DWORD PTR _pvBaseAddress$[ebp]
  00058	03 55 10	 add	 edx, DWORD PTR _nUsed$[ebp]
  0005b	89 55 fc	 mov	 DWORD PTR _pEntry$[ebp], edx

; 895  : 
; 896  :         pEntry->pvBaseAddress = pvBaseAddress;

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _pEntry$[ebp]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  00064	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 897  : 
; 898  :         InsertTailListUninit(&m_lstEntries, &pEntry->leListEntry);

  00067	8b 55 fc	 mov	 edx, DWORD PTR _pEntry$[ebp]
  0006a	52		 push	 edx
  0006b	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 c0 08	 add	 eax, 8
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailListUninit

; 899  : 
; 900  :         //
; 901  :         // Initialize a run marker immediately after the tracking entry and
; 902  :         // add it to the run list.
; 903  :         //
; 904  : 
; 905  :         pRunMarker = CreateMarker(pEntry + 1, nSlopLength - sizeof(*pEntry), &m_lstRuns);

  00077	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	83 c1 10	 add	 ecx, 16			; 00000010H
  0007d	51		 push	 ecx
  0007e	8b 55 f4	 mov	 edx, DWORD PTR _nSlopLength$[ebp]
  00081	83 ea 0c	 sub	 edx, 12			; 0000000cH
  00084	52		 push	 edx
  00085	8b 45 fc	 mov	 eax, DWORD PTR _pEntry$[ebp]
  00088	83 c0 0c	 add	 eax, 12			; 0000000cH
  0008b	50		 push	 eax
  0008c	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?CreateMarker@CMcpxSlopMemoryHeapTest@@IAEPAUSLOPRUNMARKER@@PAXKPAU_LIST_ENTRY@@@Z ; CMcpxSlopMemoryHeapTest::CreateMarker
  00094	89 45 f0	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 906  : 
; 907  :         if(m_pLargestFreeRunMarker)

  00097	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  0009e	74 1c		 je	 SHORT $L32314

; 908  :         {
; 909  :             if(pRunMarker->nLength > m_pLargestFreeRunMarker->nLength)

  000a0	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000a6	8b 4d f0	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000a9	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ac	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  000af	76 09		 jbe	 SHORT $L32315

; 910  :             {
; 911  :                 m_pLargestFreeRunMarker = pRunMarker;

  000b1	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	8b 4d f0	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000b7	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$L32315:

; 912  :             }
; 913  :         }
; 914  :         else

  000ba	eb 09		 jmp	 SHORT $L32316
$L32314:

; 915  :         {
; 916  :             m_pLargestFreeRunMarker = pRunMarker;

  000bc	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000bf	8b 45 f0	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000c2	89 42 18	 mov	 DWORD PTR [edx+24], eax
$L32316:

; 917  :         }
; 918  : 
; 919  :         m_dwAvailable += nLength;

  000c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwAvailable@CMcpxSlopMemoryHeapTest@@2AAKA ; CMcpxSlopMemoryHeapTest::m_dwAvailable
  000cb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000cd	03 55 0c	 add	 edx, DWORD PTR _nLength$[ebp]
  000d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwAvailable@CMcpxSlopMemoryHeapTest@@2AAKA ; CMcpxSlopMemoryHeapTest::m_dwAvailable
  000d5	89 10		 mov	 DWORD PTR [eax], edx

; 920  : 
; 921  :         DPF_MEM_HEAP("Added %x to the slop heap (entry %x, run marker %x, length %lu, %lu bytes used for tracking, %lu bytes used for run marker)", pvBaseAddress, pEntry, pRunMarker, nSlopLength, sizeof(*pEntry), sizeof(*pRunMarker));

  000d7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  000dc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@LEMCKDJM@CMcpxSlopMemoryHeapTest?3?3AddRun?$AA@
  000e1	68 99 03 00 00	 push	 921			; 00000399H
  000e6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  000eb	6a 05		 push	 5
  000ed	6a 09		 push	 9
  000ef	e8 00 00 00 00	 call	 _DwDbgSetContext
  000f4	83 c4 18	 add	 esp, 24			; 00000018H
  000f7	6a 10		 push	 16			; 00000010H
  000f9	6a 0c		 push	 12			; 0000000cH
  000fb	8b 4d f4	 mov	 ecx, DWORD PTR _nSlopLength$[ebp]
  000fe	51		 push	 ecx
  000ff	8b 55 f0	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00102	52		 push	 edx
  00103	8b 45 fc	 mov	 eax, DWORD PTR _pEntry$[ebp]
  00106	50		 push	 eax
  00107	8b 4d 08	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  0010a	51		 push	 ecx
  0010b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0HM@DHDLHGJJ@Added?5?$CFx?5to?5the?5slop?5heap?5?$CIentry@
  00110	e8 00 00 00 00	 call	 _DwDbgPrint
  00115	83 c4 1c	 add	 esp, 28			; 0000001cH
$L32311:

; 922  :     }
; 923  : 
; 924  :     DPF_LEAVE(fOwned);
; 925  : 
; 926  :     return fOwned;

  00118	8b 55 f8	 mov	 edx, DWORD PTR _fOwned$[ebp]
  0011b	89 55 e4	 mov	 DWORD PTR $T32741[ebp], edx
  0011e	8d 4d e8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00121	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  00126	8b 45 e4	 mov	 eax, DWORD PTR $T32741[ebp]

; 927  : }

  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c2 0c 00	 ret	 12			; 0000000cH
?AddRun@CMcpxSlopMemoryHeapTest@@QAEHPAXKK@Z ENDP	; CMcpxSlopMemoryHeapTest::AddRun
DSOUND	ENDS
PUBLIC	??_C@_0DG@LNGLCLLL@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BO@MLMBNMPN@nLength?5?$DO?5sizeof?$CI?$CKpRunMarker?$CJ?$AA@ ; `string'
;	COMDAT ??_C@_0DG@LNGLCLLL@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\initlib\heap.h
DSOUND_RD	SEGMENT
??_C@_0DG@LNGLCLLL@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\initlib\heap.h', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@MLMBNMPN@nLength?5?$DO?5sizeof?$CI?$CKpRunMarker?$CJ?$AA@
DSOUND_RD	SEGMENT
??_C@_0BO@MLMBNMPN@nLength?5?$DO?5sizeof?$CI?$CKpRunMarker?$CJ?$AA@ DB 'n'
	DB	'Length > sizeof(*pRunMarker)', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?CreateMarker@CMcpxSlopMemoryHeapTest@@IAEPAUSLOPRUNMARKER@@PAXKPAU_LIST_ENTRY@@@Z
DSOUND	SEGMENT
_this$ = -8
_pRunMarker$ = -4
_pvBaseAddress$ = 8
_nLength$ = 12
_plePrevEntry$ = 16
?CreateMarker@CMcpxSlopMemoryHeapTest@@IAEPAUSLOPRUNMARKER@@PAXKPAU_LIST_ENTRY@@@Z PROC NEAR ; CMcpxSlopMemoryHeapTest::CreateMarker, COMDAT
; _this$ = ecx

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 158  :     LPSLOPRUNMARKER         pRunMarker  = (LPSLOPRUNMARKER)pvBaseAddress;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 159  :     
; 160  :     ASSERT(nLength > sizeof(*pRunMarker));

  0000f	68 a0 00 00 00	 push	 160			; 000000a0H
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DG@LNGLCLLL@c?3?2xbox?2private?2windows?2directx?2@
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@MLMBNMPN@nLength?5?$DO?5sizeof?$CI?$CKpRunMarker?$CJ?$AA@
  0001e	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00023	3b 4d 0c	 cmp	 ecx, DWORD PTR _nLength$[ebp]
  00026	1b d2		 sbb	 edx, edx
  00028	42		 inc	 edx
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 _DwDbgAssert
  0002f	83 c4 10	 add	 esp, 16			; 00000010H

; 161  : 
; 162  :     InsertHeadListUninit(plePrevEntry, &pRunMarker->leListEntry);

  00032	8b 45 fc	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 10	 mov	 ecx, DWORD PTR _plePrevEntry$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertHeadListUninit

; 163  : 
; 164  :     pRunMarker->nLength = nLength;

  0003f	8b 55 fc	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00042	8b 45 0c	 mov	 eax, DWORD PTR _nLength$[ebp]
  00045	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 165  :     pRunMarker->dwSignature = 0;

  00048	8b 4d fc	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  0004b	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 166  : 
; 167  :     return pRunMarker;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _pRunMarker$[ebp]

; 168  : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
?CreateMarker@CMcpxSlopMemoryHeapTest@@IAEPAUSLOPRUNMARKER@@PAXKPAU_LIST_ENTRY@@@Z ENDP ; CMcpxSlopMemoryHeapTest::CreateMarker
DSOUND	ENDS
PUBLIC	?Alloc@CMcpxSlopMemoryHeapTest@@QAEPAXK@Z	; CMcpxSlopMemoryHeapTest::Alloc
PUBLIC	??_C@_0BP@KGPIEHJJ@CMcpxSlopMemoryHeapTest?3?3Alloc?$AA@ ; `string'
PUBLIC	??_C@_0CM@HIFFJDIO@Split?5memory?5run?5into?5?$CFx?5?$CI?$CFlu?$CJ?5a@ ; `string'
PUBLIC	??_C@_0BP@IKOBCBBA@Allocating?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@ ; `string'
;	COMDAT ??_C@_0BP@KGPIEHJJ@CMcpxSlopMemoryHeapTest?3?3Alloc?$AA@
; File c:\xbox\private\windows\directx\dsound\initlib\heap.cpp
DSOUND_RD	SEGMENT
??_C@_0BP@KGPIEHJJ@CMcpxSlopMemoryHeapTest?3?3Alloc?$AA@ DB 'CMcpxSlopMem'
	DB	'oryHeapTest::Alloc', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CM@HIFFJDIO@Split?5memory?5run?5into?5?$CFx?5?$CI?$CFlu?$CJ?5a@
DSOUND_RD	SEGMENT
??_C@_0CM@HIFFJDIO@Split?5memory?5run?5into?5?$CFx?5?$CI?$CFlu?$CJ?5a@ DB 'S'
	DB	'plit memory run into %x (%lu) and %x (%lu)', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BP@IKOBCBBA@Allocating?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@
DSOUND_RD	SEGMENT
??_C@_0BP@IKOBCBBA@Allocating?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@ DB 'A'
	DB	'llocating memory run %x (%lu)', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Alloc@CMcpxSlopMemoryHeapTest@@QAEPAXK@Z
DSOUND	SEGMENT
tv190 = -32
_this$ = -28
$T32748 = -24
___AutoIrql$ = -20
_pleEntry$ = -12
_pRunMarker$ = -8
_pMarkerNode$ = -4
_nLength$ = 8
?Alloc@CMcpxSlopMemoryHeapTest@@QAEPAXK@Z PROC NEAR	; CMcpxSlopMemoryHeapTest::Alloc, COMDAT
; _this$ = ecx

; 953  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 954  :     LPSLOPRUNMARKER         pRunMarker      = NULL;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pRunMarker$[ebp], 0

; 955  :     LPSLOPRUNMARKER         pMarkerNode;
; 956  :     PLIST_ENTRY             pleEntry;
; 957  : 
; 958  :     DPF_ENTER();
; 959  :     AutoIrql();

  00010	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 960  : 
; 961  :     //
; 962  :     // The length must include the space to hold the run marker
; 963  :     //
; 964  : 
; 965  :     nLength += sizeof(SLOPRUNMARKER);

  00018	8b 45 08	 mov	 eax, DWORD PTR _nLength$[ebp]
  0001b	83 c0 10	 add	 eax, 16			; 00000010H
  0001e	89 45 08	 mov	 DWORD PTR _nLength$[ebp], eax

; 966  : 
; 967  :     //
; 968  :     // Check the largest available run length to see if we can service
; 969  :     // the request
; 970  :     //
; 971  : 
; 972  :     if(m_pLargestFreeRunMarker)

  00021	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  00028	0f 84 0a 02 00
	00		 je	 $L32329

; 973  :     {
; 974  :         if(m_pLargestFreeRunMarker->nLength >= nLength)

  0002e	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00034	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00037	3b 4d 08	 cmp	 ecx, DWORD PTR _nLength$[ebp]
  0003a	0f 82 f8 01 00
	00		 jb	 $L32329

; 975  :         {
; 976  :             //
; 977  :             // Find a free run that is as close as possible to the requested element
; 978  :             // count.  This will help to reduce fragmentation.
; 979  :             //
; 980  : 
; 981  :             for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)

  00040	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00043	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00046	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax
  00049	eb 08		 jmp	 SHORT $L32331
$L32332:
  0004b	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  0004e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00050	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx
$L32331:
  00053	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00056	83 c0 10	 add	 eax, 16			; 00000010H
  00059	39 45 f4	 cmp	 DWORD PTR _pleEntry$[ebp], eax
  0005c	74 53		 je	 SHORT $L32333

; 982  :             {
; 983  :                 AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

  0005e	68 d7 03 00 00	 push	 983			; 000003d7H
  00063	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00068	6a 01		 push	 1
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 984  : 
; 985  :                 pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

  00073	8b 55 f4	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  00076	89 55 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], edx

; 986  :             
; 987  :                 if(!pMarkerNode->fAllocated)

  00079	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  0007c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00080	75 2d		 jne	 SHORT $L32338

; 988  :                 {
; 989  :                     if(pMarkerNode->nLength >= nLength)

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  00085	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00088	3b 55 08	 cmp	 edx, DWORD PTR _nLength$[ebp]
  0008b	72 22		 jb	 SHORT $L32338

; 990  :                     {
; 991  :                         if(!pRunMarker)

  0008d	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  00091	75 08		 jne	 SHORT $L32340

; 992  :                         {
; 993  :                             pRunMarker = pMarkerNode;

  00093	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  00096	89 45 f8	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 994  :                         }
; 995  :                         else if(pMarkerNode->nLength < pRunMarker->nLength)

  00099	eb 14		 jmp	 SHORT $L32338
$L32340:
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  0009e	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000a1	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000a4	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  000a7	73 06		 jae	 SHORT $L32338

; 996  :                         {
; 997  :                             pRunMarker = pMarkerNode;

  000a9	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  000ac	89 4d f8	 mov	 DWORD PTR _pRunMarker$[ebp], ecx
$L32338:

; 998  :                         }
; 999  :                     }
; 1000 :                 }
; 1001 :             }

  000af	eb 9a		 jmp	 SHORT $L32332
$L32333:

; 1002 : 
; 1003 :             //
; 1004 :             // If we're using the whole run, just flag it as allocated.  If not,
; 1005 :             // create a new marker from the remaining buffer and add it to the 
; 1006 :             // list.  We're only using a single list so that runs can be broken 
; 1007 :             // and coalesced without having to walk the list.
; 1008 :             //
; 1009 : 
; 1010 :             if(pRunMarker)

  000b1	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  000b5	0f 84 be 00 00
	00		 je	 $L32343

; 1011 :             {
; 1012 :                 if(nLength + sizeof(*pRunMarker) + m_dwUsageThreshold < pRunMarker->nLength)

  000bb	8b 55 08	 mov	 edx, DWORD PTR _nLength$[ebp]
  000be	83 c2 50	 add	 edx, 80			; 00000050H
  000c1	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000c4	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  000c7	73 6e		 jae	 SHORT $L32344

; 1013 :                 {
; 1014 :                     pMarkerNode = CreateMarker((LPBYTE)pRunMarker + nLength, pRunMarker->nLength - nLength, &pRunMarker->leListEntry);

  000c9	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000cc	51		 push	 ecx
  000cd	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000d0	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000d3	2b 45 08	 sub	 eax, DWORD PTR _nLength$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000da	03 4d 08	 add	 ecx, DWORD PTR _nLength$[ebp]
  000dd	51		 push	 ecx
  000de	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?CreateMarker@CMcpxSlopMemoryHeapTest@@IAEPAUSLOPRUNMARKER@@PAXKPAU_LIST_ENTRY@@@Z ; CMcpxSlopMemoryHeapTest::CreateMarker
  000e6	89 45 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], eax

; 1015 : 
; 1016 :                     pRunMarker->nLength = nLength;

  000e9	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000ec	8b 45 08	 mov	 eax, DWORD PTR _nLength$[ebp]
  000ef	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1017 : 
; 1018 :                     DPF_MEM_HEAP("Split memory run into %x (%lu) and %x (%lu)", pRunMarker, pRunMarker->nLength, pMarkerNode, pMarkerNode->nLength);

  000f2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  000f7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@KGPIEHJJ@CMcpxSlopMemoryHeapTest?3?3Alloc?$AA@
  000fc	68 fa 03 00 00	 push	 1018			; 000003faH
  00101	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00106	6a 05		 push	 5
  00108	6a 09		 push	 9
  0010a	e8 00 00 00 00	 call	 _DwDbgSetContext
  0010f	83 c4 18	 add	 esp, 24			; 00000018H
  00112	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  00115	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00118	52		 push	 edx
  00119	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  0011c	50		 push	 eax
  0011d	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  00120	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00123	52		 push	 edx
  00124	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00127	50		 push	 eax
  00128	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@HIFFJDIO@Split?5memory?5run?5into?5?$CFx?5?$CI?$CFlu?$CJ?5a@
  0012d	e8 00 00 00 00	 call	 _DwDbgPrint
  00132	83 c4 14	 add	 esp, 20			; 00000014H

; 1019 :                 }
; 1020 :                 else

  00135	eb 38		 jmp	 SHORT $L32348
$L32344:

; 1021 :                 {
; 1022 :                     DPF_MEM_HEAP("Allocating memory run %x (%lu)", pRunMarker, pRunMarker->nLength);

  00137	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  0013c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@KGPIEHJJ@CMcpxSlopMemoryHeapTest?3?3Alloc?$AA@
  00141	68 fe 03 00 00	 push	 1022			; 000003feH
  00146	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0014b	6a 05		 push	 5
  0014d	6a 09		 push	 9
  0014f	e8 00 00 00 00	 call	 _DwDbgSetContext
  00154	83 c4 18	 add	 esp, 24			; 00000018H
  00157	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  0015a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0015d	52		 push	 edx
  0015e	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00161	50		 push	 eax
  00162	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@IKOBCBBA@Allocating?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@
  00167	e8 00 00 00 00	 call	 _DwDbgPrint
  0016c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L32348:

; 1023 :                 }
; 1024 : 
; 1025 :                 pRunMarker->dwSignature = DSOUND_ALLOCATOR_SLOP;

  0016f	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  00172	c7 41 0c 73 6c
	6f 70		 mov	 DWORD PTR [ecx+12], 1886350451 ; 706f6c73H
$L32343:

; 1026 :             }
; 1027 : 
; 1028 :             //
; 1029 :             // Update the largest run member
; 1030 :             //
; 1031 : 
; 1032 :             if(pRunMarker)

  00179	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  0017d	0f 84 87 00 00
	00		 je	 $L32350

; 1033 :             {
; 1034 :                 if(pRunMarker == m_pLargestFreeRunMarker)

  00183	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00186	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00189	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  0018c	75 7c		 jne	 SHORT $L32350

; 1035 :                 {
; 1036 :                     m_pLargestFreeRunMarker = NULL;

  0018e	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00191	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 1037 :                     
; 1038 :                     for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)

  00198	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0019b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0019e	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax
  001a1	eb 08		 jmp	 SHORT $L32352
$L32353:
  001a3	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  001a6	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a8	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx
$L32352:
  001ab	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  001ae	83 c0 10	 add	 eax, 16			; 00000010H
  001b1	39 45 f4	 cmp	 DWORD PTR _pleEntry$[ebp], eax
  001b4	74 54		 je	 SHORT $L32350

; 1039 :                     {
; 1040 :                         AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

  001b6	68 10 04 00 00	 push	 1040			; 00000410H
  001bb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  001c0	6a 01		 push	 1
  001c2	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  001c5	51		 push	 ecx
  001c6	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 1041 : 
; 1042 :                         pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

  001cb	8b 55 f4	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  001ce	89 55 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], edx

; 1043 :             
; 1044 :                         if(!pMarkerNode->fAllocated)

  001d1	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  001d4	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  001d8	75 2e		 jne	 SHORT $L32359

; 1045 :                         {
; 1046 :                             if(!m_pLargestFreeRunMarker)

  001da	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001dd	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  001e1	75 0b		 jne	 SHORT $L32360

; 1047 :                             {
; 1048 :                                 m_pLargestFreeRunMarker = pMarkerNode;

  001e3	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  001e6	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  001e9	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 1049 :                             }
; 1050 :                             else if(pMarkerNode->nLength > m_pLargestFreeRunMarker->nLength)

  001ec	eb 1a		 jmp	 SHORT $L32359
$L32360:
  001ee	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001f1	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001f4	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  001f7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001fa	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  001fd	76 09		 jbe	 SHORT $L32359

; 1051 :                             {
; 1052 :                                 m_pLargestFreeRunMarker = pMarkerNode;

  001ff	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00202	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  00205	89 42 18	 mov	 DWORD PTR [edx+24], eax
$L32359:

; 1053 :                             }
; 1054 :                         }
; 1055 :                     }

  00208	eb 99		 jmp	 SHORT $L32353
$L32350:

; 1056 :                 }                    
; 1057 :             }
; 1058 : 
; 1059 :             //
; 1060 :             // Update the amount of memory recovered
; 1061 :             //
; 1062 : 
; 1063 :             if(pRunMarker)

  0020a	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  0020e	74 16		 je	 SHORT $L32363

; 1064 :             {
; 1065 :                 m_dwUsed += pRunMarker->nLength;

  00210	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeapTest@@2AAKA ; CMcpxSlopMemoryHeapTest::m_dwUsed
  00216	8b 11		 mov	 edx, DWORD PTR [ecx]
  00218	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0021b	03 50 08	 add	 edx, DWORD PTR [eax+8]
  0021e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeapTest@@2AAKA ; CMcpxSlopMemoryHeapTest::m_dwUsed
  00224	89 11		 mov	 DWORD PTR [ecx], edx
$L32363:

; 1066 :             }
; 1067 : 
; 1068 :             //
; 1069 :             // AddRef ourselves so we're always around as long as allocated
; 1070 :             // memory is.
; 1071 :             //
; 1072 : 
; 1073 :             if(pRunMarker)

  00226	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  0022a	74 0c		 je	 SHORT $L32329

; 1074 :             {
; 1075 :                 AddRef();

  0022c	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0022f	8b 02		 mov	 eax, DWORD PTR [edx]
  00231	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	51		 push	 ecx
  00235	ff 50 04	 call	 DWORD PTR [eax+4]
$L32329:

; 1076 :             }
; 1077 :         }
; 1078 :     }
; 1079 : 
; 1080 :     DPF_LEAVE(pRunMarker ? pRunMarker + 1 : NULL);
; 1081 : 
; 1082 :     return pRunMarker ? pRunMarker + 1 : NULL;

  00238	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  0023c	74 0b		 je	 SHORT $L32749
  0023e	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00241	83 c2 10	 add	 edx, 16			; 00000010H
  00244	89 55 e0	 mov	 DWORD PTR tv190[ebp], edx
  00247	eb 07		 jmp	 SHORT $L32750
$L32749:
  00249	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv190[ebp], 0
$L32750:
  00250	8b 45 e0	 mov	 eax, DWORD PTR tv190[ebp]
  00253	89 45 e8	 mov	 DWORD PTR $T32748[ebp], eax
  00256	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00259	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  0025e	8b 45 e8	 mov	 eax, DWORD PTR $T32748[ebp]

; 1083 : }

  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c2 04 00	 ret	 4
?Alloc@CMcpxSlopMemoryHeapTest@@QAEPAXK@Z ENDP		; CMcpxSlopMemoryHeapTest::Alloc
DSOUND	ENDS
PUBLIC	?Free@CMcpxSlopMemoryHeapTest@@QAEXPAX@Z	; CMcpxSlopMemoryHeapTest::Free
PUBLIC	?CoalesceRuns@CMcpxSlopMemoryHeapTest@@IAEPAUSLOPRUNMARKER@@PAU2@0@Z ; CMcpxSlopMemoryHeapTest::CoalesceRuns
PUBLIC	??_C@_0DB@NIHOPDML@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5pRunMar@ ; `string'
PUBLIC	??_C@_0BO@GHHDOBPO@CMcpxSlopMemoryHeapTest?3?3Free?$AA@ ; `string'
PUBLIC	??_C@_0BM@NGDNJECG@Freeing?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CA@OGPDEANK@m_dwUsed?5?$DO?$DN?5pRunMarker?9?$DOnLength?$AA@ ; `string'
;	COMDAT ??_C@_0DB@NIHOPDML@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5pRunMar@
DSOUND_RD	SEGMENT
??_C@_0DB@NIHOPDML@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5pRunMar@ DB 'DSOUND_A'
	DB	'LLOCATOR_SLOP == pRunMarker->dwSignature', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@GHHDOBPO@CMcpxSlopMemoryHeapTest?3?3Free?$AA@
DSOUND_RD	SEGMENT
??_C@_0BO@GHHDOBPO@CMcpxSlopMemoryHeapTest?3?3Free?$AA@ DB 'CMcpxSlopMemo'
	DB	'ryHeapTest::Free', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@NGDNJECG@Freeing?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@
DSOUND_RD	SEGMENT
??_C@_0BM@NGDNJECG@Freeing?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@ DB 'F'
	DB	'reeing memory run %x (%lu)', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@OGPDEANK@m_dwUsed?5?$DO?$DN?5pRunMarker?9?$DOnLength?$AA@
DSOUND_RD	SEGMENT
??_C@_0CA@OGPDEANK@m_dwUsed?5?$DO?$DN?5pRunMarker?9?$DOnLength?$AA@ DB 'm'
	DB	'_dwUsed >= pRunMarker->nLength', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Free@CMcpxSlopMemoryHeapTest@@QAEXPAX@Z
DSOUND	SEGMENT
_this$ = -24
___AutoIrql$ = -20
_pleEntry$ = -12
_pRunMarker$ = -8
_pMarkerNode$ = -4
_pvBaseAddress$ = 8
?Free@CMcpxSlopMemoryHeapTest@@QAEXPAX@Z PROC NEAR	; CMcpxSlopMemoryHeapTest::Free, COMDAT
; _this$ = ecx

; 1109 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1110 :     LPSLOPRUNMARKER         pRunMarker  = (LPSLOPRUNMARKER)pvBaseAddress - 1;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  0000c	83 e8 10	 sub	 eax, 16			; 00000010H
  0000f	89 45 f8	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 1111 :     PLIST_ENTRY             pleEntry;
; 1112 :     LPSLOPRUNMARKER         pMarkerNode;
; 1113 :     
; 1114 :     DPF_ENTER();
; 1115 :     AutoIrql();

  00012	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00015	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 1116 : 
; 1117 :     ASSERT(DSOUND_ALLOCATOR_SLOP == pRunMarker->dwSignature);

  0001a	68 5d 04 00 00	 push	 1117			; 0000045dH
  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00024	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@NIHOPDML@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5pRunMar@
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  0002c	33 d2		 xor	 edx, edx
  0002e	81 79 0c 73 6c
	6f 70		 cmp	 DWORD PTR [ecx+12], 1886350451 ; 706f6c73H
  00035	0f 95 c2	 setne	 dl
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _DwDbgAssert
  0003e	83 c4 10	 add	 esp, 16			; 00000010H

; 1118 : 
; 1119 :     DPF_MEM_HEAP("Freeing memory run %x (%lu)", pRunMarker, pRunMarker->nLength);

  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@GHHDOBPO@CMcpxSlopMemoryHeapTest?3?3Free?$AA@
  0004b	68 5f 04 00 00	 push	 1119			; 0000045fH
  00050	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00055	6a 05		 push	 5
  00057	6a 09		 push	 9
  00059	e8 00 00 00 00	 call	 _DwDbgSetContext
  0005e	83 c4 18	 add	 esp, 24			; 00000018H
  00061	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00064	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00067	51		 push	 ecx
  00068	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  0006b	52		 push	 edx
  0006c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@NGDNJECG@Freeing?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?$AA@
  00071	e8 00 00 00 00	 call	 _DwDbgPrint
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1120 : 
; 1121 :     //
; 1122 :     // Update the amount of memory recovered
; 1123 :     //
; 1124 : 
; 1125 :     ASSERT(m_dwUsed >= pRunMarker->nLength);

  00079	68 65 04 00 00	 push	 1125			; 00000465H
  0007e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00083	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@OGPDEANK@m_dwUsed?5?$DO?$DN?5pRunMarker?9?$DOnLength?$AA@
  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeapTest@@2AAKA ; CMcpxSlopMemoryHeapTest::m_dwUsed
  0008d	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  00090	8b 10		 mov	 edx, DWORD PTR [eax]
  00092	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00095	1b c0		 sbb	 eax, eax
  00097	f7 d8		 neg	 eax
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _DwDbgAssert
  0009f	83 c4 10	 add	 esp, 16			; 00000010H

; 1126 :     m_dwUsed -= pRunMarker->nLength;

  000a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeapTest@@2AAKA ; CMcpxSlopMemoryHeapTest::m_dwUsed
  000a8	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000ab	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ad	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  000b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeapTest@@2AAKA ; CMcpxSlopMemoryHeapTest::m_dwUsed
  000b6	89 01		 mov	 DWORD PTR [ecx], eax

; 1127 : 
; 1128 :     //
; 1129 :     // Reset the run signature so it's flagged as free
; 1130 :     //
; 1131 : 
; 1132 :     pRunMarker->dwSignature = 0;

  000b8	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000bb	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
$L32380:

; 1133 : 
; 1134 :     //
; 1135 :     // Coalesce the run with those around it
; 1136 :     //
; 1137 : 
; 1138 :     while(TRUE)

  000c2	b8 01 00 00 00	 mov	 eax, 1
  000c7	85 c0		 test	 eax, eax
  000c9	74 4b		 je	 SHORT $L32392

; 1139 :     {
; 1140 :         if((pleEntry = pRunMarker->leListEntry.Flink) == &m_lstRuns)

  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000ce	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d0	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx
  000d3	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	83 c0 10	 add	 eax, 16			; 00000010H
  000d9	39 45 f4	 cmp	 DWORD PTR _pleEntry$[ebp], eax
  000dc	75 02		 jne	 SHORT $L32382

; 1141 :         {
; 1142 :             break;

  000de	eb 36		 jmp	 SHORT $L32392
$L32382:

; 1143 :         }
; 1144 : 
; 1145 :         pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

  000e0	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  000e3	89 4d fc	 mov	 DWORD PTR _pMarkerNode$[ebp], ecx

; 1146 : 
; 1147 :         if(pMarkerNode->fAllocated)

  000e6	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  000e9	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  000ed	74 02		 je	 SHORT $L32387

; 1148 :         {
; 1149 :             break;

  000ef	eb 25		 jmp	 SHORT $L32392
$L32387:

; 1150 :         }
; 1151 : 
; 1152 :         if((LPBYTE)pRunMarker + pRunMarker->nLength != (LPBYTE)pMarkerNode)

  000f1	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000f4	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000f7	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  000fa	3b 4d fc	 cmp	 ecx, DWORD PTR _pMarkerNode$[ebp]
  000fd	74 02		 je	 SHORT $L32390

; 1153 :         {
; 1154 :             break;

  000ff	eb 15		 jmp	 SHORT $L32392
$L32390:

; 1155 :         }
; 1156 : 
; 1157 :         pRunMarker = CoalesceRuns(pRunMarker, pMarkerNode);

  00101	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  00104	52		 push	 edx
  00105	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00108	50		 push	 eax
  00109	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	e8 00 00 00 00	 call	 ?CoalesceRuns@CMcpxSlopMemoryHeapTest@@IAEPAUSLOPRUNMARKER@@PAU2@0@Z ; CMcpxSlopMemoryHeapTest::CoalesceRuns
  00111	89 45 f8	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 1158 :     }

  00114	eb ac		 jmp	 SHORT $L32380
$L32392:

; 1159 : 
; 1160 :     while(TRUE)

  00116	b9 01 00 00 00	 mov	 ecx, 1
  0011b	85 c9		 test	 ecx, ecx
  0011d	74 4c		 je	 SHORT $L32393

; 1161 :     {
; 1162 :         if((pleEntry = pRunMarker->leListEntry.Blink) == &m_lstRuns)

  0011f	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00122	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00125	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax
  00128	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	83 c1 10	 add	 ecx, 16			; 00000010H
  0012e	39 4d f4	 cmp	 DWORD PTR _pleEntry$[ebp], ecx
  00131	75 02		 jne	 SHORT $L32394

; 1163 :         {
; 1164 :             break;

  00133	eb 36		 jmp	 SHORT $L32393
$L32394:

; 1165 :         }
; 1166 : 
; 1167 :         pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

  00135	8b 55 f4	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  00138	89 55 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], edx

; 1168 : 
; 1169 :         if(pMarkerNode->fAllocated)

  0013b	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  0013e	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00142	74 02		 je	 SHORT $L32399

; 1170 :         {
; 1171 :             break;

  00144	eb 25		 jmp	 SHORT $L32393
$L32399:

; 1172 :         }
; 1173 : 
; 1174 :         if((LPBYTE)pMarkerNode + pMarkerNode->nLength != (LPBYTE)pRunMarker)

  00146	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  00149	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  0014c	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  0014f	3b 55 f8	 cmp	 edx, DWORD PTR _pRunMarker$[ebp]
  00152	74 02		 je	 SHORT $L32402

; 1175 :         {
; 1176 :             break;

  00154	eb 15		 jmp	 SHORT $L32393
$L32402:

; 1177 :         }
; 1178 : 
; 1179 :         pRunMarker = CoalesceRuns(pMarkerNode, pRunMarker);

  00156	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00159	50		 push	 eax
  0015a	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  0015d	51		 push	 ecx
  0015e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	e8 00 00 00 00	 call	 ?CoalesceRuns@CMcpxSlopMemoryHeapTest@@IAEPAUSLOPRUNMARKER@@PAU2@0@Z ; CMcpxSlopMemoryHeapTest::CoalesceRuns
  00166	89 45 f8	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 1180 :     }

  00169	eb ab		 jmp	 SHORT $L32392
$L32393:

; 1181 : 
; 1182 :     //
; 1183 :     // Update the largest run pointer
; 1184 :     //
; 1185 : 
; 1186 :     if(m_pLargestFreeRunMarker)

  0016b	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0016e	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00172	74 1c		 je	 SHORT $L32403

; 1187 :     {
; 1188 :         if(pRunMarker->nLength > m_pLargestFreeRunMarker->nLength)

  00174	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00177	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0017a	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  0017d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00180	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00183	76 09		 jbe	 SHORT $L32404

; 1189 :         {
; 1190 :             m_pLargestFreeRunMarker = pRunMarker;

  00185	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00188	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  0018b	89 51 18	 mov	 DWORD PTR [ecx+24], edx
$L32404:

; 1191 :         }
; 1192 :     }
; 1193 :     else

  0018e	eb 09		 jmp	 SHORT $L32405
$L32403:

; 1194 :     {
; 1195 :         m_pLargestFreeRunMarker = pRunMarker;

  00190	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00193	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  00196	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$L32405:

; 1196 :     }
; 1197 : 
; 1198 :     //
; 1199 :     // Release the reference added in Alloc
; 1200 :     //
; 1201 : 
; 1202 :     Release();

  00199	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0019c	8b 02		 mov	 eax, DWORD PTR [edx]
  0019e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a1	51		 push	 ecx
  001a2	ff 50 08	 call	 DWORD PTR [eax+8]

; 1203 : 
; 1204 :     DPF_LEAVE_VOID();
; 1205 : }

  001a5	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  001a8	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  001ad	8b e5		 mov	 esp, ebp
  001af	5d		 pop	 ebp
  001b0	c2 04 00	 ret	 4
?Free@CMcpxSlopMemoryHeapTest@@QAEXPAX@Z ENDP		; CMcpxSlopMemoryHeapTest::Free
DSOUND	ENDS
PUBLIC	??_C@_0ED@KLOEHPFP@?$CILPBYTE?$CJpRunMarker?5?$CL?5pRunMarker?9@ ; `string'
PUBLIC	??_C@_0BM@IEHJELCG@?$CBpNextRunMarker?9?$DOfAllocated?$AA@ ; `string'
PUBLIC	??_C@_0CG@KEODOCLD@CMcpxSlopMemoryHeapTest?3?3Coalesc@ ; `string'
PUBLIC	??_C@_0CM@MKMMHKFA@Coalescing?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?5a@ ; `string'
;	COMDAT ??_C@_0ED@KLOEHPFP@?$CILPBYTE?$CJpRunMarker?5?$CL?5pRunMarker?9@
DSOUND_RD	SEGMENT
??_C@_0ED@KLOEHPFP@?$CILPBYTE?$CJpRunMarker?5?$CL?5pRunMarker?9@ DB '(LPB'
	DB	'YTE)pRunMarker + pRunMarker->nLength == (LPBYTE)pNextRunMarke'
	DB	'r', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@IEHJELCG@?$CBpNextRunMarker?9?$DOfAllocated?$AA@
DSOUND_RD	SEGMENT
??_C@_0BM@IEHJELCG@?$CBpNextRunMarker?9?$DOfAllocated?$AA@ DB '!pNextRunM'
	DB	'arker->fAllocated', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CG@KEODOCLD@CMcpxSlopMemoryHeapTest?3?3Coalesc@
DSOUND_RD	SEGMENT
??_C@_0CG@KEODOCLD@CMcpxSlopMemoryHeapTest?3?3Coalesc@ DB 'CMcpxSlopMemor'
	DB	'yHeapTest::CoalesceRuns', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CM@MKMMHKFA@Coalescing?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?5a@
DSOUND_RD	SEGMENT
??_C@_0CM@MKMMHKFA@Coalescing?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?5a@ DB 'C'
	DB	'oalescing memory run %x (%lu) and %x (%lu)', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?CoalesceRuns@CMcpxSlopMemoryHeapTest@@IAEPAUSLOPRUNMARKER@@PAU2@0@Z
DSOUND	SEGMENT
_this$ = -4
_pRunMarker$ = 8
_pNextRunMarker$ = 12
?CoalesceRuns@CMcpxSlopMemoryHeapTest@@IAEPAUSLOPRUNMARKER@@PAU2@0@Z PROC NEAR ; CMcpxSlopMemoryHeapTest::CoalesceRuns, COMDAT
; _this$ = ecx

; 1234 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1235 :     DPF_ENTER();
; 1236 : 
; 1237 :     ASSERT((LPBYTE)pRunMarker + pRunMarker->nLength == (LPBYTE)pNextRunMarker);

  00007	68 d5 04 00 00	 push	 1237			; 000004d5H
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0ED@KLOEHPFP@?$CILPBYTE?$CJpRunMarker?5?$CL?5pRunMarker?9@
  00016	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  0001c	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  0001f	33 d2		 xor	 edx, edx
  00021	3b 4d 0c	 cmp	 ecx, DWORD PTR _pNextRunMarker$[ebp]
  00024	0f 95 c2	 setne	 dl
  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 _DwDbgAssert
  0002d	83 c4 10	 add	 esp, 16			; 00000010H

; 1238 :     ASSERT(!pRunMarker->fAllocated);

  00030	68 d6 04 00 00	 push	 1238			; 000004d6H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@CBCHBLME@?$CBpRunMarker?9?$DOfAllocated?$AA@
  0003f	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00042	33 c9		 xor	 ecx, ecx
  00044	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00048	0f 95 c1	 setne	 cl
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _DwDbgAssert
  00051	83 c4 10	 add	 esp, 16			; 00000010H

; 1239 :     ASSERT(!pNextRunMarker->fAllocated);

  00054	68 d7 04 00 00	 push	 1239			; 000004d7H
  00059	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  0005e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@IEHJELCG@?$CBpNextRunMarker?9?$DOfAllocated?$AA@
  00063	8b 55 0c	 mov	 edx, DWORD PTR _pNextRunMarker$[ebp]
  00066	33 c0		 xor	 eax, eax
  00068	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0006c	0f 95 c0	 setne	 al
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _DwDbgAssert
  00075	83 c4 10	 add	 esp, 16			; 00000010H

; 1240 : 
; 1241 :     AssertValidEntryList(&pRunMarker->leListEntry, ASSERT_IN_LIST);

  00078	68 d9 04 00 00	 push	 1241			; 000004d9H
  0007d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00082	6a 01		 push	 1
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 1242 :     AssertValidEntryList(&pNextRunMarker->leListEntry, ASSERT_IN_LIST);

  0008d	68 da 04 00 00	 push	 1242			; 000004daH
  00092	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  00097	6a 01		 push	 1
  00099	8b 55 0c	 mov	 edx, DWORD PTR _pNextRunMarker$[ebp]
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 1243 : 
; 1244 :     DPF_MEM_HEAP("Coalescing memory run %x (%lu) and %x (%lu)", pRunMarker, pRunMarker->nLength, pNextRunMarker, pNextRunMarker->nLength);

  000a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@KEODOCLD@CMcpxSlopMemoryHeapTest?3?3Coalesc@
  000ac	68 dc 04 00 00	 push	 1244			; 000004dcH
  000b1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@HECKFPP@c?3?2xbox?2private?2windows?2directx?2@
  000b6	6a 05		 push	 5
  000b8	6a 09		 push	 9
  000ba	e8 00 00 00 00	 call	 _DwDbgSetContext
  000bf	83 c4 18	 add	 esp, 24			; 00000018H
  000c2	8b 45 0c	 mov	 eax, DWORD PTR _pNextRunMarker$[ebp]
  000c5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000c8	51		 push	 ecx
  000c9	8b 55 0c	 mov	 edx, DWORD PTR _pNextRunMarker$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000d0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000d3	51		 push	 ecx
  000d4	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000d7	52		 push	 edx
  000d8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@MKMMHKFA@Coalescing?5memory?5run?5?$CFx?5?$CI?$CFlu?$CJ?5a@
  000dd	e8 00 00 00 00	 call	 _DwDbgPrint
  000e2	83 c4 14	 add	 esp, 20			; 00000014H

; 1245 : 
; 1246 :     pRunMarker->nLength += pNextRunMarker->nLength;

  000e5	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000e8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000eb	8b 55 0c	 mov	 edx, DWORD PTR _pNextRunMarker$[ebp]
  000ee	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  000f1	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000f4	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1247 :     
; 1248 :     RemoveEntryList(&pNextRunMarker->leListEntry);

  000f7	8b 4d 0c	 mov	 ecx, DWORD PTR _pNextRunMarker$[ebp]
  000fa	51		 push	 ecx
  000fb	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 1249 : 
; 1250 :     DPF_LEAVE(pRunMarker);
; 1251 : 
; 1252 :     return pRunMarker;

  00100	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]

; 1253 : }

  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c2 08 00	 ret	 8
?CoalesceRuns@CMcpxSlopMemoryHeapTest@@IAEPAUSLOPRUNMARKER@@PAU2@0@Z ENDP ; CMcpxSlopMemoryHeapTest::CoalesceRuns
DSOUND	ENDS
PUBLIC	?m_dwAvailable@CMcpxSlopMemoryHeapTest@@2AAKA	; CMcpxSlopMemoryHeapTest::m_dwAvailable
PUBLIC	?m_dwUsed@CMcpxSlopMemoryHeapTest@@2AAKA	; CMcpxSlopMemoryHeapTest::m_dwUsed
DSOUND_URW	SEGMENT
?m_dwAvailable@CMcpxSlopMemoryHeapTest@@2AAKA DD 01H DUP (?) ; CMcpxSlopMemoryHeapTest::m_dwAvailable
?m_dwUsed@CMcpxSlopMemoryHeapTest@@2AAKA DD 01H DUP (?)	; CMcpxSlopMemoryHeapTest::m_dwUsed
DSOUND_URW	ENDS
END
