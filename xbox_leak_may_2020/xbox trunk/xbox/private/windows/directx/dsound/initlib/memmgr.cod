; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\memmgr.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
DSOUND_URW	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_URW	ENDS
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_06GGPOMPNM@?$CInone?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DK@BHCCMBKD@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0O@GGBLDHEI@?$CBm_dwRefCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BE@DAEOBIBM@m_dwRefCount?5?$DM?5?$HO0UL?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0N@OILPJBKD@m_dwRefCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DG@LNGLCLLL@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@MLMBNMPN@nLength?5?$DO?5sizeof?$CI?$CKpRunMarker?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_07CNKCBOKB@TESTSND?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DH@NAFPMNMN@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0FF@CEBOEHDG@DirectSound?5is?5in?5the?5final?5stag@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@GKNCNMBD@CDirectSoundTest?3?3AddRef?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@KCMACBKL@CDirectSoundTest?3?3Release?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DK@PBGBJGJP@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0O@JCBGLFIF@?$CBm_paNotifier?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@JLKNBNJM@?$CBm_dwNotifierCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0N@BMLCBDGO@m_paNotifier?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@ELEAODJN@dwNotifierIndex?5?$DM?5m_dwNotifierCo@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@MEDKFNKN@Unexpected?5notifier?5status?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BC@NHNIONPC@m_dwNotifierCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DI@JEPBENHJ@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BA@IANIBDAF@m_pGpDspManager?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@ONCKHILO@m_dwState?5?$CG?5MCPX_APUSTATE_GPIMAG@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@FGGNHBE@KeGetCurrentIrql?$CI?$CJ?5?$DO?$DN?5DISPATCH_L@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@IECLLDN@m_dwVoiceMapLock?5?$DM?5?$HO0UL?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@FFOHIBNC@m_dwVoiceMapLock?5?$DO?$DN?51?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_08DNIHDBFJ@cbBuffer?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@KABANJOE@DirectSoundTestPoolAlloc?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@EKDKBHPJ@Out?5of?5pool?5memory?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_08FADLHADM@pvBuffer?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CP@MKHDPMLC@g_dwDirectSoundTestPoolMemoryUsa@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_07KIGAHELJ@dwFlags?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BN@KHNKFGCK@DirectSoundTestPhysicalAlloc?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@BGANBOHC@Out?5of?5contiguous?5memory?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DD@HPMJMKCE@g_dwDirectSoundTestPhysicalMemor@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DC@OLMEENNO@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5?$CK?$CI?$CILPDW@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@GADDBPNL@Slop?5memory?5heap?5does?5not?5exist?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BE@FMKOLKGH@Invalid?5memory?5free?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@KOBBHKIF@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_06OFIAKHFO@cbSize?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CK@PJHOCMHE@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0EP@IIFDJHMP@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BP@DCCEGIIC@DirectSoundTestDumpMemoryUsage?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@MIBDOIDJ@Begin?5memory?5usage?5dump?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@JPIKIBNC@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@OHKIAENG@Pool?5memory?5used?3?5?5?$CFlu?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@OGBIDBPB@Physical?5memory?5used?3?5?5?$CFlu?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CN@EIKGFANE@Physical?5memory?5available?5for?5re@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@HBBPMJBE@Physical?5memory?5recovered?3?5?5?$CFlu?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@DICBIGIJ@End?5memory?5usage?5dump?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DC@JOELGBPO@?$CBIsListEmpty?$CI?$CGg_lstDirectSoundTe@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DB@LDBGAFO@IsListEmpty?$CI?$CGg_lstDirectSoundTes@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@GLKFBKGJ@NULL?5?$CCthis?$CC?5pointer?5?$CI?$CFx?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@LEKIOFPG@Invalid?5?$CCthis?$CC?5pointer?5?$CI?$CFx?5?$CB?$DN?5?$CFx@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
DSOUND_RW	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RW	ENDS
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IsEqualGUID@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _==@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _KeGetCurrentIrql@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _KeIsExecutingDpc@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_AddRef@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_Release@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_GetAdapterCount@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_BeginScene@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_EndScene@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_GetRenderState@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_GetTextureStageState@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_SetRenderState@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_SetTextureStageState@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DResource_MoveResourceMemory@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DTexture_UnlockRect@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVolumeTexture_UnlockBox@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DCubeTexture_UnlockRect@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVertexBuffer_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DIndexBuffer_Lock@20
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DIndexBuffer_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DPalette_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DSurface_UnlockRect@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVolume_UnlockBox@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _sqrtf@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@MMMMMMMMMMMMMMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXPLANE@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??3@YAXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CIrql@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Raise@CIrql@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Lower@CIrql@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAutoIrql@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAutoIrql@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Save@CFpState@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Restore@CFpState@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCRefCountTest@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CRefCountTest@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AddRef@CRefCountTest@@UAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Release@CRefCountTest@@UAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister8@CAc97Device@@KGEK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister8@CAc97Device@@KGXKE@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister16@CAc97Device@@KGGK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister16@CAc97Device@@KGXKG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister32@CAc97Device@@KGKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister32@CAc97Device@@KGXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister8@CAc97Device@@KGEK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister8@CAc97Device@@KGXKE@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister16@CAc97Device@@KGGK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister16@CAc97Device@@KGXKG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister32@CAc97Device@@KGKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister32@CAc97Device@@KGXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ReleaseChannel@CAc97Device@@QAEXPAVCAc97Channel@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestEnterCriticalSection@@YGHXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestLeaveCriticalSection@@YGXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAutoLockTest@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAutoLockTest@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Free@CMcpxNotifierTest@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Reset@CMcpxNotifierTest@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetScratchSpaceLinAddr@CMcpxDspScratchDmaTest@@QAEPAXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestPoolAlloc@@YGPAXW4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestPoolFree@@YGXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestPhysicalAlloc@@YGPAXKKKH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestPhysicalFree@@YGXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestMemAlloc@@YGPAXW4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestMemFree@@YGXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestTrackAlloc@@YGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestForgetAlloc@@YGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _DirectSoundTestTrackingPoolAlloc@24
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _DirectSoundTestTrackingPoolFree@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _DirectSoundTestTrackingPhysicalAlloc@28
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _DirectSoundTestTrackingPhysicalFree@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _DirectSoundTestTrackingMemAlloc@24
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _DirectSoundTestTrackingMemFree@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundTestDumpMemoryUsage@@YGXH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1?$CValidObject@$0EEFDEOEE@@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AssertValidObject@?$CValidObject@$0EEFDEOEE@@@QAEXPBDK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_G?$CValidObject@$0EEFDEOEE@@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_7?$CValidObject@$0EEFDEOEE@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?pszBanner@?1??DirectSoundTestDumpMemoryUsage@@YGXH@Z@4QBDB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT _TestSoundLibBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_7CRefCountTest@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?cbTracking@?1??DirectSoundTestTrackingMemAlloc@@9@24@4KB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?cbTracking@?1??DirectSoundTestTrackingPoolAlloc@@9@24@4KB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, DSOUND_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_D3DPRIMITIVETOVERTEXCOUNT
PUBLIC	_D3DSIMPLERENDERSTATEENCODE
PUBLIC	_D3DTEXTUREDIRECTENCODE
PUBLIC	_D3DDIRTYFROMRENDERSTATE
PUBLIC	_D3DDIRTYFROMTEXTURESTATE
PUBLIC	?g_dwDirectSoundTestPoolMemoryUsage@@3KA	; g_dwDirectSoundTestPoolMemoryUsage
PUBLIC	?g_dwDirectSoundTestPhysicalMemoryUsage@@3KA	; g_dwDirectSoundTestPhysicalMemoryUsage
PUBLIC	?g_dwDirectSoundTestPhysicalMemorySlop@@3KA	; g_dwDirectSoundTestPhysicalMemorySlop
PUBLIC	?g_dwDirectSoundTestPhysicalMemoryRecovered@@3KA ; g_dwDirectSoundTestPhysicalMemoryRecovered
PUBLIC	?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A ; g_lstDirectSoundTestMemoryTracking
PUBLIC	_TestSoundLibBuildNumberD
DSOUND_URW	SEGMENT
?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A DQ 01H DUP (?) ; g_lstDirectSoundTestMemoryTracking
DSOUND_URW	ENDS
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
DSOUND_RD	SEGMENT
_D3DPRIMITIVETOVERTEXCOUNT DD 00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
DSOUND_RD	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
DSOUND_RD	SEGMENT
_D3DSIMPLERENDERSTATEENCODE DD 040260H
	DD	040264H
	DD	040268H
	DD	04026cH
	DD	040270H
	DD	040274H
	DD	040278H
	DD	04027cH
	DD	040288H
	DD	04028cH
	DD	040a60H
	DD	040a64H
	DD	040a68H
	DD	040a6cH
	DD	040a70H
	DD	040a74H
	DD	040a78H
	DD	040a7cH
	DD	040a80H
	DD	040a84H
	DD	040a88H
	DD	040a8cH
	DD	040a90H
	DD	040a94H
	DD	040a98H
	DD	040a9cH
	DD	040aa0H
	DD	040aa4H
	DD	040aa8H
	DD	040aacH
	DD	040ab0H
	DD	040ab4H
	DD	040ab8H
	DD	040abcH
	DD	040ac0H
	DD	040ac4H
	DD	040ac8H
	DD	040accH
	DD	040ad0H
	DD	040ad4H
	DD	040ad8H
	DD	040adcH
	DD	0417f8H
	DD	041e20H
	DD	041e24H
	DD	041e40H
	DD	041e44H
	DD	041e48H
	DD	041e4cH
	DD	041e50H
	DD	041e54H
	DD	041e58H
	DD	041e5cH
	DD	041e60H
	DD	041d90H
	DD	041e74H
	DD	041e78H
	DD	040354H
	DD	04033cH
	DD	040304H
	DD	040300H
	DD	040340H
	DD	040344H
	DD	040348H
	DD	04035cH
	DD	040310H
	DD	04037cH
	DD	040358H
	DD	040374H
	DD	040378H
	DD	040364H
	DD	040368H
	DD	04036cH
	DD	040360H
	DD	040350H
	DD	04034cH
	DD	0409f8H
	DD	040384H
	DD	040388H
	DD	040330H
	DD	040334H
	DD	040338H
DSOUND_RD	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
DSOUND_RD	SEGMENT
_D3DTEXTUREDIRECTENCODE DD 081b00H
	DD	081b40H
	DD	081b80H
	DD	081bc0H
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
DSOUND_RD	SEGMENT
_D3DDIRTYFROMRENDERSTATE DD 02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	01200H
	DD	03000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	0100H
	DD	0100H
	DD	0900H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	00H
	DD	00H
	DD	00H
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
DSOUND_RD	SEGMENT
_D3DDIRTYFROMTEXTURESTATE DD 0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0480fH
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0400H
DSOUND_RD	ENDS
;	COMDAT _TestSoundLibBuildNumberD
XBLD$V	SEGMENT
_TestSoundLibBuildNumberD DW 04554H
	DW	05453H
	DW	04e53H
	DW	04444H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
DSOUND_RW	SEGMENT
?g_dwDirectSoundTestPoolMemoryUsage@@3KA DD 00H		; g_dwDirectSoundTestPoolMemoryUsage
?g_dwDirectSoundTestPhysicalMemoryUsage@@3KA DD 00H	; g_dwDirectSoundTestPhysicalMemoryUsage
?g_dwDirectSoundTestPhysicalMemorySlop@@3KA DD 00H	; g_dwDirectSoundTestPhysicalMemorySlop
?g_dwDirectSoundTestPhysicalMemoryRecovered@@3KA DD 00H	; g_dwDirectSoundTestPhysicalMemoryRecovered
DSOUND_RW	ENDS
PUBLIC	??_C@_07CNKCBOKB@TESTSND?$AA@			; `string'
PUBLIC	?DirectSoundTestPoolAlloc@@YGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSoundTestPoolAlloc
PUBLIC	??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_08DNIHDBFJ@cbBuffer?$AA@			; `string'
PUBLIC	??_C@_0BJ@KABANJOE@DirectSoundTestPoolAlloc?$AA@ ; `string'
PUBLIC	??_C@_0BD@EKDKBHPJ@Out?5of?5pool?5memory?$AA@	; `string'
EXTRN	__imp__ExAllocatePoolWithTag@8:NEAR
EXTRN	__imp__ExQueryPoolBlockSize@4:NEAR
EXTRN	_DwDbgSetContext:NEAR
EXTRN	_DwDbgPrint:NEAR
EXTRN	_DwDbgAssert:NEAR
EXTRN	_memset:NEAR
;	COMDAT ??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\initlib\memmgr.cpp
DSOUND_RD	SEGMENT
??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\initlib\memmgr.cpp', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_08DNIHDBFJ@cbBuffer?$AA@
DSOUND_RD	SEGMENT
??_C@_08DNIHDBFJ@cbBuffer?$AA@ DB 'cbBuffer', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_07CNKCBOKB@TESTSND?$AA@
DSOUND_RD	SEGMENT
??_C@_07CNKCBOKB@TESTSND?$AA@ DB 'TESTSND', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@KABANJOE@DirectSoundTestPoolAlloc?$AA@
DSOUND_RD	SEGMENT
??_C@_0BJ@KABANJOE@DirectSoundTestPoolAlloc?$AA@ DB 'DirectSoundTestPoolA'
	DB	'lloc', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@EKDKBHPJ@Out?5of?5pool?5memory?$AA@
DSOUND_RD	SEGMENT
??_C@_0BD@EKDKBHPJ@Out?5of?5pool?5memory?$AA@ DB 'Out of pool memory', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?DirectSoundTestPoolAlloc@@YGPAXW4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT
_pvBuffer$ = -4
_nPoolTag$ = 8
_cbBuffer$ = 12
_fZeroInit$ = 16
?DirectSoundTestPoolAlloc@@YGPAXW4DSOUND_POOL_TAG@@KH@Z PROC NEAR ; DirectSoundTestPoolAlloc, COMDAT

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 72   :     static const ULONG      cbLowerThreshold    = 0x20;
; 73   :     static const DWORD      cbUpperThreshold    = 0xFD8;
; 74   :     LPVOID                  pvBuffer;
; 75   : 
; 76   :     ASSERT(cbBuffer);

  00004	6a 4c		 push	 76			; 0000004cH
  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08DNIHDBFJ@cbBuffer?$AA@
  00010	33 c0		 xor	 eax, eax
  00012	83 7d 0c 00	 cmp	 DWORD PTR _cbBuffer$[ebp], 0
  00016	0f 94 c0	 sete	 al
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _DwDbgAssert
  0001f	83 c4 10	 add	 esp, 16			; 00000010H

; 77   : 
; 78   : #ifdef MEM_SIZE_CHECK
; 79   : 
; 80   : #pragma TODO("Don't ship with this check turned on")
; 81   :     
; 82   :     if((DSOUND_OBJECT_POOL_TAG == nPoolTag) && (cbBuffer >= cbUpperThreshold))
; 83   :     {
; 84   :         ASSERTMSG("Allocating an object larger than the pool threshold");
; 85   :     }
; 86   :     else if((DSOUND_DATA_POOL_TAG == nPoolTag) && (cbBuffer < cbLowerThreshold))
; 87   :     {
; 88   :         ASSERTMSG("Allocating a buffer smaller than 32 bytes");
; 89   :     }
; 90   : 
; 91   : #endif
; 92   : 
; 93   :     if(pvBuffer = ExAllocatePoolWithTag(cbBuffer, nPoolTag))

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _nPoolTag$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 0c	 mov	 edx, DWORD PTR _cbBuffer$[ebp]
  00029	52		 push	 edx
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@8
  00030	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  00033	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00037	74 36		 je	 SHORT $L32090

; 94   :     {
; 95   :         cbBuffer = ExQueryPoolBlockSize(pvBuffer);

  00039	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExQueryPoolBlockSize@4
  00043	89 45 0c	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 96   :         g_dwDirectSoundTestPoolMemoryUsage += cbBuffer;

  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_dwDirectSoundTestPoolMemoryUsage@@3KA ; g_dwDirectSoundTestPoolMemoryUsage
  0004c	03 4d 0c	 add	 ecx, DWORD PTR _cbBuffer$[ebp]
  0004f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?g_dwDirectSoundTestPoolMemoryUsage@@3KA, ecx ; g_dwDirectSoundTestPoolMemoryUsage

; 97   : 
; 98   :         if(fZeroInit)

  00055	83 7d 10 00	 cmp	 DWORD PTR _fZeroInit$[ebp], 0
  00059	74 12		 je	 SHORT $L32091

; 99   :         {
; 100  :             ZeroMemory(pvBuffer, cbBuffer);

  0005b	8b 55 0c	 mov	 edx, DWORD PTR _cbBuffer$[ebp]
  0005e	52		 push	 edx
  0005f	6a 00		 push	 0
  00061	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _memset
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L32091:

; 101  :         }
; 102  :     }
; 103  :     else

  0006d	eb 2a		 jmp	 SHORT $L32092
$L32090:

; 104  :     {
; 105  :         DPF_RESOURCE("Out of pool memory");

  0006f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  00074	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@KABANJOE@DirectSoundTestPoolAlloc?$AA@
  00079	6a 69		 push	 105			; 00000069H
  0007b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  00080	6a 02		 push	 2
  00082	6a 09		 push	 9
  00084	e8 00 00 00 00	 call	 _DwDbgSetContext
  00089	83 c4 18	 add	 esp, 24			; 00000018H
  0008c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@EKDKBHPJ@Out?5of?5pool?5memory?$AA@
  00091	e8 00 00 00 00	 call	 _DwDbgPrint
  00096	83 c4 04	 add	 esp, 4
$L32092:

; 106  :     }
; 107  : 
; 108  :     return pvBuffer;

  00099	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 109  : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 0c 00	 ret	 12			; 0000000cH
?DirectSoundTestPoolAlloc@@YGPAXW4DSOUND_POOL_TAG@@KH@Z ENDP ; DirectSoundTestPoolAlloc
DSOUND	ENDS
PUBLIC	?DirectSoundTestPoolFree@@YGXPAX@Z		; DirectSoundTestPoolFree
PUBLIC	??_C@_08FADLHADM@pvBuffer?$AA@			; `string'
PUBLIC	??_C@_0CP@MKHDPMLC@g_dwDirectSoundTestPoolMemoryUsa@ ; `string'
EXTRN	__imp__ExFreePool@4:NEAR
;	COMDAT ??_C@_08FADLHADM@pvBuffer?$AA@
DSOUND_RD	SEGMENT
??_C@_08FADLHADM@pvBuffer?$AA@ DB 'pvBuffer', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CP@MKHDPMLC@g_dwDirectSoundTestPoolMemoryUsa@
DSOUND_RD	SEGMENT
??_C@_0CP@MKHDPMLC@g_dwDirectSoundTestPoolMemoryUsa@ DB 'g_dwDirectSoundT'
	DB	'estPoolMemoryUsage >= cbBuffer', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?DirectSoundTestPoolFree@@YGXPAX@Z
DSOUND	SEGMENT
_cbBuffer$ = -4
_pvBuffer$ = 8
?DirectSoundTestPoolFree@@YGXPAX@Z PROC NEAR		; DirectSoundTestPoolFree, COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 136  :     DWORD                   cbBuffer;
; 137  : 
; 138  :     ASSERT(pvBuffer);

  00004	68 8a 00 00 00	 push	 138			; 0000008aH
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08FADLHADM@pvBuffer?$AA@
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 08 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _DwDbgAssert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 139  : 
; 140  :     cbBuffer = ExQueryPoolBlockSize(pvBuffer);

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00028	51		 push	 ecx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExQueryPoolBlockSize@4
  0002f	89 45 fc	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 141  : 
; 142  :     ASSERT(g_dwDirectSoundTestPoolMemoryUsage >= cbBuffer);

  00032	68 8e 00 00 00	 push	 142			; 0000008eH
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@MKHDPMLC@g_dwDirectSoundTestPoolMemoryUsa@
  00041	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_dwDirectSoundTestPoolMemoryUsage@@3KA ; g_dwDirectSoundTestPoolMemoryUsage
  00047	3b 55 fc	 cmp	 edx, DWORD PTR _cbBuffer$[ebp]
  0004a	1b c0		 sbb	 eax, eax
  0004c	f7 d8		 neg	 eax
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _DwDbgAssert
  00054	83 c4 10	 add	 esp, 16			; 00000010H

; 143  :     g_dwDirectSoundTestPoolMemoryUsage -= cbBuffer;

  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_dwDirectSoundTestPoolMemoryUsage@@3KA ; g_dwDirectSoundTestPoolMemoryUsage
  0005d	2b 4d fc	 sub	 ecx, DWORD PTR _cbBuffer$[ebp]
  00060	89 0d 00 00 00
	00		 mov	 DWORD PTR ?g_dwDirectSoundTestPoolMemoryUsage@@3KA, ecx ; g_dwDirectSoundTestPoolMemoryUsage

; 144  : 
; 145  :     ExFreePool(pvBuffer);

  00066	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00069	52		 push	 edx
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 146  : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
?DirectSoundTestPoolFree@@YGXPAX@Z ENDP			; DirectSoundTestPoolFree
DSOUND	ENDS
PUBLIC	?DirectSoundTestPhysicalAlloc@@YGPAXKKKH@Z	; DirectSoundTestPhysicalAlloc
PUBLIC	??_C@_07KIGAHELJ@dwFlags?$AA@			; `string'
PUBLIC	??_C@_0BN@KHNKFGCK@DirectSoundTestPhysicalAlloc?$AA@ ; `string'
PUBLIC	??_C@_0BJ@BGANBOHC@Out?5of?5contiguous?5memory?$AA@ ; `string'
EXTRN	__imp__MmAllocateContiguousMemoryEx@20:NEAR
EXTRN	__imp__MmQueryAllocationSize@4:NEAR
;	COMDAT ??_C@_07KIGAHELJ@dwFlags?$AA@
DSOUND_RD	SEGMENT
??_C@_07KIGAHELJ@dwFlags?$AA@ DB 'dwFlags', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BN@KHNKFGCK@DirectSoundTestPhysicalAlloc?$AA@
DSOUND_RD	SEGMENT
??_C@_0BN@KHNKFGCK@DirectSoundTestPhysicalAlloc?$AA@ DB 'DirectSoundTestP'
	DB	'hysicalAlloc', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@BGANBOHC@Out?5of?5contiguous?5memory?$AA@
DSOUND_RD	SEGMENT
??_C@_0BJ@BGANBOHC@Out?5of?5contiguous?5memory?$AA@ DB 'Out of contiguous'
	DB	' memory', 00H				; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?DirectSoundTestPhysicalAlloc@@YGPAXKKKH@Z
DSOUND	SEGMENT
_pvBuffer$ = -4
_cbBuffer$ = 8
_cbAlignment$ = 12
_dwFlags$ = 16
_fZeroInit$ = 20
?DirectSoundTestPhysicalAlloc@@YGPAXKKKH@Z PROC NEAR	; DirectSoundTestPhysicalAlloc, COMDAT

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 179  :     LPVOID                  pvBuffer;
; 180  : 
; 181  :     ASSERT(cbBuffer);

  00004	68 b5 00 00 00	 push	 181			; 000000b5H
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08DNIHDBFJ@cbBuffer?$AA@
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 08 00	 cmp	 DWORD PTR _cbBuffer$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _DwDbgAssert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 182  :     ASSERT(dwFlags);

  00025	68 b6 00 00 00	 push	 182			; 000000b6H
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07KIGAHELJ@dwFlags?$AA@
  00034	33 c9		 xor	 ecx, ecx
  00036	83 7d 10 00	 cmp	 DWORD PTR _dwFlags$[ebp], 0
  0003a	0f 94 c1	 sete	 cl
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 _DwDbgAssert
  00043	83 c4 10	 add	 esp, 16			; 00000010H

; 183  :     
; 184  :     if(pvBuffer = MmAllocateContiguousMemoryEx(cbBuffer, 0, 0xFFFFFFFF, cbAlignment, dwFlags))

  00046	8b 55 10	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00049	52		 push	 edx
  0004a	8b 45 0c	 mov	 eax, DWORD PTR _cbAlignment$[ebp]
  0004d	50		 push	 eax
  0004e	6a ff		 push	 -1
  00050	6a 00		 push	 0
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00055	51		 push	 ecx
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmAllocateContiguousMemoryEx@20
  0005c	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  0005f	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00063	74 34		 je	 SHORT $L32109

; 185  :     {
; 186  :         cbBuffer = MmQueryAllocationSize(pvBuffer);

  00065	8b 55 fc	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00068	52		 push	 edx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmQueryAllocationSize@4
  0006f	89 45 08	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 187  :         g_dwDirectSoundTestPhysicalMemoryUsage += cbBuffer;

  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_dwDirectSoundTestPhysicalMemoryUsage@@3KA ; g_dwDirectSoundTestPhysicalMemoryUsage
  00077	03 45 08	 add	 eax, DWORD PTR _cbBuffer$[ebp]
  0007a	a3 00 00 00 00	 mov	 DWORD PTR ?g_dwDirectSoundTestPhysicalMemoryUsage@@3KA, eax ; g_dwDirectSoundTestPhysicalMemoryUsage

; 188  : 
; 189  :         if(fZeroInit)

  0007f	83 7d 14 00	 cmp	 DWORD PTR _fZeroInit$[ebp], 0
  00083	74 12		 je	 SHORT $L32110

; 190  :         {
; 191  :             ZeroMemory(pvBuffer, cbBuffer);

  00085	8b 4d 08	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00088	51		 push	 ecx
  00089	6a 00		 push	 0
  0008b	8b 55 fc	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 _memset
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
$L32110:

; 192  :         }
; 193  :     }
; 194  :     else

  00097	eb 2d		 jmp	 SHORT $L32111
$L32109:

; 195  :     {
; 196  :         DPF_RESOURCE("Out of contiguous memory");

  00099	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  0009e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@KHNKFGCK@DirectSoundTestPhysicalAlloc?$AA@
  000a3	68 c4 00 00 00	 push	 196			; 000000c4H
  000a8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  000ad	6a 02		 push	 2
  000af	6a 09		 push	 9
  000b1	e8 00 00 00 00	 call	 _DwDbgSetContext
  000b6	83 c4 18	 add	 esp, 24			; 00000018H
  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@BGANBOHC@Out?5of?5contiguous?5memory?$AA@
  000be	e8 00 00 00 00	 call	 _DwDbgPrint
  000c3	83 c4 04	 add	 esp, 4
$L32111:

; 197  :     }
; 198  : 
; 199  :     return pvBuffer;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 200  : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 10 00	 ret	 16			; 00000010H
?DirectSoundTestPhysicalAlloc@@YGPAXKKKH@Z ENDP		; DirectSoundTestPhysicalAlloc
DSOUND	ENDS
PUBLIC	?DirectSoundTestPhysicalFree@@YGXPAX@Z		; DirectSoundTestPhysicalFree
PUBLIC	??_C@_0DD@HPMJMKCE@g_dwDirectSoundTestPhysicalMemor@ ; `string'
EXTRN	__imp__MmFreeContiguousMemory@4:NEAR
;	COMDAT ??_C@_0DD@HPMJMKCE@g_dwDirectSoundTestPhysicalMemor@
DSOUND_RD	SEGMENT
??_C@_0DD@HPMJMKCE@g_dwDirectSoundTestPhysicalMemor@ DB 'g_dwDirectSoundT'
	DB	'estPhysicalMemoryUsage >= cbBuffer', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?DirectSoundTestPhysicalFree@@YGXPAX@Z
DSOUND	SEGMENT
_cbBuffer$ = -4
_pvBuffer$ = 8
?DirectSoundTestPhysicalFree@@YGXPAX@Z PROC NEAR	; DirectSoundTestPhysicalFree, COMDAT

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 227  :     DWORD                   cbBuffer;
; 228  : 
; 229  :     ASSERT(pvBuffer);

  00004	68 e5 00 00 00	 push	 229			; 000000e5H
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08FADLHADM@pvBuffer?$AA@
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 08 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _DwDbgAssert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 230  : 
; 231  :     cbBuffer = MmQueryAllocationSize(pvBuffer);

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00028	51		 push	 ecx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmQueryAllocationSize@4
  0002f	89 45 fc	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 232  : 
; 233  :     ASSERT(g_dwDirectSoundTestPhysicalMemoryUsage >= cbBuffer);

  00032	68 e9 00 00 00	 push	 233			; 000000e9H
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@HPMJMKCE@g_dwDirectSoundTestPhysicalMemor@
  00041	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_dwDirectSoundTestPhysicalMemoryUsage@@3KA ; g_dwDirectSoundTestPhysicalMemoryUsage
  00047	3b 55 fc	 cmp	 edx, DWORD PTR _cbBuffer$[ebp]
  0004a	1b c0		 sbb	 eax, eax
  0004c	f7 d8		 neg	 eax
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _DwDbgAssert
  00054	83 c4 10	 add	 esp, 16			; 00000010H

; 234  :     g_dwDirectSoundTestPhysicalMemoryUsage -= cbBuffer;

  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_dwDirectSoundTestPhysicalMemoryUsage@@3KA ; g_dwDirectSoundTestPhysicalMemoryUsage
  0005d	2b 4d fc	 sub	 ecx, DWORD PTR _cbBuffer$[ebp]
  00060	89 0d 00 00 00
	00		 mov	 DWORD PTR ?g_dwDirectSoundTestPhysicalMemoryUsage@@3KA, ecx ; g_dwDirectSoundTestPhysicalMemoryUsage

; 235  : 
; 236  :     MmFreeContiguousMemory(pvBuffer);

  00066	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00069	52		 push	 edx
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmFreeContiguousMemory@4

; 237  : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
?DirectSoundTestPhysicalFree@@YGXPAX@Z ENDP		; DirectSoundTestPhysicalFree
DSOUND	ENDS
PUBLIC	?DirectSoundTestMemAlloc@@YGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSoundTestMemAlloc
PUBLIC	??_C@_0DC@OLMEENNO@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5?$CK?$CI?$CILPDW@ ; `string'
EXTRN	?Alloc@CMcpxSlopMemoryHeapTest@@QAEPAXK@Z:NEAR	; CMcpxSlopMemoryHeapTest::Alloc
EXTRN	?g_pDirectSoundTestSlopMemoryHeap@@3PAVCMcpxSlopMemoryHeapTest@@A:DWORD ; g_pDirectSoundTestSlopMemoryHeap
;	COMDAT ??_C@_0DC@OLMEENNO@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5?$CK?$CI?$CILPDW@
DSOUND_RD	SEGMENT
??_C@_0DC@OLMEENNO@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5?$CK?$CI?$CILPDW@ DB 'D'
	DB	'SOUND_ALLOCATOR_SLOP == *((LPDWORD)pvBuffer - 1)', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?DirectSoundTestMemAlloc@@YGPAXW4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT
_pvBuffer$ = -4
_nPoolTag$ = 8
_cbBuffer$ = 12
_fZeroInit$ = 16
?DirectSoundTestMemAlloc@@YGPAXW4DSOUND_POOL_TAG@@KH@Z PROC NEAR ; DirectSoundTestMemAlloc, COMDAT

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 270  :     static const ULONG      cbLowerThreshold    = 0x20;
; 271  :     static const DWORD      cbUpperThreshold    = 0xFD8;
; 272  :     LPVOID                  pvBuffer;
; 273  : 
; 274  :     ASSERT(cbBuffer);

  00004	68 12 01 00 00	 push	 274			; 00000112H
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08DNIHDBFJ@cbBuffer?$AA@
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 0c 00	 cmp	 DWORD PTR _cbBuffer$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _DwDbgAssert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 275  : 
; 276  : #ifdef MEM_SIZE_CHECK
; 277  : 
; 278  : #pragma TODO("Don't ship with this check turned on")
; 279  :     
; 280  :     if((DSOUND_OBJECT_POOL_TAG == nPoolTag) && (cbBuffer >= cbUpperThreshold))
; 281  :     {
; 282  :         ASSERTMSG("Allocating an object larger than the pool threshold");
; 283  :     }
; 284  :     else if((DSOUND_DATA_POOL_TAG == nPoolTag) && (cbBuffer < cbLowerThreshold))
; 285  :     {
; 286  :         ASSERTMSG("Allocating a buffer smaller than 32 bytes");
; 287  :     }
; 288  : 
; 289  : #endif
; 290  : 
; 291  :     if(g_pDirectSoundTestSlopMemoryHeap)

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pDirectSoundTestSlopMemoryHeap@@3PAVCMcpxSlopMemoryHeapTest@@A, 0 ; g_pDirectSoundTestSlopMemoryHeap
  0002c	74 59		 je	 SHORT $L32129

; 292  :     {
; 293  :         if(pvBuffer = g_pDirectSoundTestSlopMemoryHeap->Alloc(cbBuffer))

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00031	51		 push	 ecx
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pDirectSoundTestSlopMemoryHeap@@3PAVCMcpxSlopMemoryHeapTest@@A ; g_pDirectSoundTestSlopMemoryHeap
  00038	e8 00 00 00 00	 call	 ?Alloc@CMcpxSlopMemoryHeapTest@@QAEPAXK@Z ; CMcpxSlopMemoryHeapTest::Alloc
  0003d	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  00040	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00044	74 3f		 je	 SHORT $L32130

; 294  :         {
; 295  :             ASSERT(DSOUND_ALLOCATOR_SLOP == *((LPDWORD)pvBuffer - 1));

  00046	68 27 01 00 00	 push	 295			; 00000127H
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  00050	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DC@OLMEENNO@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5?$CK?$CI?$CILPDW@
  00055	8b 55 fc	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00058	33 c0		 xor	 eax, eax
  0005a	81 7a fc 73 6c
	6f 70		 cmp	 DWORD PTR [edx-4], 1886350451 ; 706f6c73H
  00061	0f 95 c0	 setne	 al
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _DwDbgAssert
  0006a	83 c4 10	 add	 esp, 16			; 00000010H

; 296  : 
; 297  :             if(fZeroInit)

  0006d	83 7d 10 00	 cmp	 DWORD PTR _fZeroInit$[ebp], 0
  00071	74 12		 je	 SHORT $L32130

; 298  :             {
; 299  :                 ZeroMemory(pvBuffer, cbBuffer);

  00073	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00076	51		 push	 ecx
  00077	6a 00		 push	 0
  00079	8b 55 fc	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 _memset
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
$L32130:

; 300  :             }
; 301  :         }
; 302  :     }
; 303  :     else

  00085	eb 07		 jmp	 SHORT $L32134
$L32129:

; 304  :     {
; 305  :         pvBuffer = NULL;

  00087	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pvBuffer$[ebp], 0
$L32134:

; 306  :     }
; 307  : 
; 308  :     if(!pvBuffer)

  0008e	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00092	75 2f		 jne	 SHORT $L32135

; 309  :     {
; 310  :         if(pvBuffer = DirectSoundTestPoolAlloc(nPoolTag, cbBuffer + sizeof(DWORD), fZeroInit))

  00094	8b 45 10	 mov	 eax, DWORD PTR _fZeroInit$[ebp]
  00097	50		 push	 eax
  00098	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  0009b	83 c1 04	 add	 ecx, 4
  0009e	51		 push	 ecx
  0009f	8b 55 08	 mov	 edx, DWORD PTR _nPoolTag$[ebp]
  000a2	52		 push	 edx
  000a3	e8 00 00 00 00	 call	 ?DirectSoundTestPoolAlloc@@YGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSoundTestPoolAlloc
  000a8	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  000ab	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  000af	74 12		 je	 SHORT $L32135

; 311  :         {
; 312  :             *(LPDWORD)pvBuffer = DSOUND_ALLOCATOR_POOL;

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  000b4	c7 00 70 6f 6f
	6c		 mov	 DWORD PTR [eax], 1819242352 ; 6c6f6f70H

; 313  :             pvBuffer = (LPDWORD)pvBuffer + 1;

  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  000bd	83 c1 04	 add	 ecx, 4
  000c0	89 4d fc	 mov	 DWORD PTR _pvBuffer$[ebp], ecx
$L32135:

; 314  :         }
; 315  :     }
; 316  : 
; 317  :     return pvBuffer;

  000c3	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 318  : }

  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 0c 00	 ret	 12			; 0000000cH
?DirectSoundTestMemAlloc@@YGPAXW4DSOUND_POOL_TAG@@KH@Z ENDP ; DirectSoundTestMemAlloc
DSOUND	ENDS
PUBLIC	?DirectSoundTestMemFree@@YGXPAX@Z		; DirectSoundTestMemFree
PUBLIC	??_C@_0CA@GADDBPNL@Slop?5memory?5heap?5does?5not?5exist?$AA@ ; `string'
PUBLIC	??_C@_0BE@FMKOLKGH@Invalid?5memory?5free?$AA@	; `string'
EXTRN	?Free@CMcpxSlopMemoryHeapTest@@QAEXPAX@Z:NEAR	; CMcpxSlopMemoryHeapTest::Free
;	COMDAT ??_C@_0CA@GADDBPNL@Slop?5memory?5heap?5does?5not?5exist?$AA@
DSOUND_RD	SEGMENT
??_C@_0CA@GADDBPNL@Slop?5memory?5heap?5does?5not?5exist?$AA@ DB 'Slop mem'
	DB	'ory heap does not exist', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BE@FMKOLKGH@Invalid?5memory?5free?$AA@
DSOUND_RD	SEGMENT
??_C@_0BE@FMKOLKGH@Invalid?5memory?5free?$AA@ DB 'Invalid memory free', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?DirectSoundTestMemFree@@YGXPAX@Z
DSOUND	SEGMENT
_pdwSignature$ = -8
_pvBuffer$ = 8
?DirectSoundTestMemFree@@YGXPAX@Z PROC NEAR		; DirectSoundTestMemFree, COMDAT

; 348  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 349  :     LPDWORD                 pdwSignature;
; 350  :     DWORD                   cbBuffer;
; 351  : 
; 352  :     ASSERT(pvBuffer);

  00006	68 60 01 00 00	 push	 352			; 00000160H
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08FADLHADM@pvBuffer?$AA@
  00015	33 c0		 xor	 eax, eax
  00017	83 7d 08 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  0001b	0f 94 c0	 sete	 al
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _DwDbgAssert
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 353  : 
; 354  :     pdwSignature = (LPDWORD)pvBuffer - 1;

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  0002a	83 e9 04	 sub	 ecx, 4
  0002d	89 4d f8	 mov	 DWORD PTR _pdwSignature$[ebp], ecx

; 355  :     
; 356  :     if(DSOUND_ALLOCATOR_POOL == *pdwSignature)

  00030	8b 55 f8	 mov	 edx, DWORD PTR _pdwSignature$[ebp]
  00033	81 3a 70 6f 6f
	6c		 cmp	 DWORD PTR [edx], 1819242352 ; 6c6f6f70H
  00039	75 0b		 jne	 SHORT $L32146

; 357  :     {
; 358  :         DirectSoundTestPoolFree(pdwSignature);

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _pdwSignature$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?DirectSoundTestPoolFree@@YGXPAX@Z ; DirectSoundTestPoolFree

; 359  :     }
; 360  :     else if(DSOUND_ALLOCATOR_SLOP == *pdwSignature)

  00044	eb 59		 jmp	 SHORT $L32142
$L32146:
  00046	8b 4d f8	 mov	 ecx, DWORD PTR _pdwSignature$[ebp]
  00049	81 39 73 6c 6f
	70		 cmp	 DWORD PTR [ecx], 1886350451 ; 706f6c73H
  0004f	75 35		 jne	 SHORT $L32148

; 361  :     {
; 362  :         if(g_pDirectSoundTestSlopMemoryHeap)

  00051	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pDirectSoundTestSlopMemoryHeap@@3PAVCMcpxSlopMemoryHeapTest@@A, 0 ; g_pDirectSoundTestSlopMemoryHeap
  00058	74 11		 je	 SHORT $L32149

; 363  :         {
; 364  :             g_pDirectSoundTestSlopMemoryHeap->Free(pvBuffer);

  0005a	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  0005d	52		 push	 edx
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pDirectSoundTestSlopMemoryHeap@@3PAVCMcpxSlopMemoryHeapTest@@A ; g_pDirectSoundTestSlopMemoryHeap
  00064	e8 00 00 00 00	 call	 ?Free@CMcpxSlopMemoryHeapTest@@QAEXPAX@Z ; CMcpxSlopMemoryHeapTest::Free

; 365  :         }
; 366  :         else

  00069	eb 19		 jmp	 SHORT $L32150
$L32149:

; 367  :         {
; 368  :             ASSERTMSG("Slop memory heap does not exist");

  0006b	68 70 01 00 00	 push	 368			; 00000170H
  00070	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@GADDBPNL@Slop?5memory?5heap?5does?5not?5exist?$AA@
  0007a	6a 01		 push	 1
  0007c	e8 00 00 00 00	 call	 _DwDbgAssert
  00081	83 c4 10	 add	 esp, 16			; 00000010H
$L32150:

; 369  :         }
; 370  :     }
; 371  :     else

  00084	eb 19		 jmp	 SHORT $L32142
$L32148:

; 372  :     {
; 373  :         ASSERTMSG("Invalid memory free");

  00086	68 75 01 00 00	 push	 373			; 00000175H
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@FMKOLKGH@Invalid?5memory?5free?$AA@
  00095	6a 01		 push	 1
  00097	e8 00 00 00 00	 call	 _DwDbgAssert
  0009c	83 c4 10	 add	 esp, 16			; 00000010H
$L32142:

; 374  :     }
; 375  : }

  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 04 00	 ret	 4
?DirectSoundTestMemFree@@YGXPAX@Z ENDP			; DirectSoundTestMemFree
DSOUND	ENDS
PUBLIC	??0CAutoIrql@@QAE@XZ				; CAutoIrql::CAutoIrql
PUBLIC	??1CAutoIrql@@QAE@XZ				; CAutoIrql::~CAutoIrql
PUBLIC	?DirectSoundTestTrackAlloc@@YGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ; DirectSoundTestTrackAlloc
PUBLIC	??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@		; `string'
PUBLIC	??_C@_0CB@KOBBHKIF@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@ ; `string'
PUBLIC	??_C@_06OFIAKHFO@cbSize?$AA@			; `string'
PUBLIC	?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z	; InsertTailListUninit
;	COMDAT ??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@
DSOUND_RD	SEGMENT
??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@ DB 'pvBaseAddress', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@KOBBHKIF@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@
DSOUND_RD	SEGMENT
??_C@_0CB@KOBBHKIF@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@ DB 'c'
	DB	'bTracking >= sizeof(*pTracking)', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_06OFIAKHFO@cbSize?$AA@
DSOUND_RD	SEGMENT
??_C@_06OFIAKHFO@cbSize?$AA@ DB 'cbSize', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?DirectSoundTestTrackAlloc@@YGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z
DSOUND	SEGMENT
$T32483 = -16
___AutoIrql$ = -12
_pTracking$ = -4
_pvBaseAddress$ = 8
_cbTracking$ = 12
_pszFile$ = 16
_nLine$ = 20
_pszClass$ = 24
_nAllocatorTag$ = 28
_cbSize$ = 32
?DirectSoundTestTrackAlloc@@YGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z PROC NEAR ; DirectSoundTestTrackAlloc, COMDAT

; 416  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 417  :     LPDSMEMTRACK            pTracking;
; 418  :     
; 419  :     ASSERT(pvBaseAddress);

  00006	68 a3 01 00 00	 push	 419			; 000001a3H
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@
  00015	33 c0		 xor	 eax, eax
  00017	83 7d 08 00	 cmp	 DWORD PTR _pvBaseAddress$[ebp], 0
  0001b	0f 94 c0	 sete	 al
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _DwDbgAssert
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 420  :     ASSERT(cbTracking >= sizeof(*pTracking));

  00027	68 a4 01 00 00	 push	 420			; 000001a4H
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@KOBBHKIF@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@
  00036	83 7d 0c 20	 cmp	 DWORD PTR _cbTracking$[ebp], 32 ; 00000020H
  0003a	1b c9		 sbb	 ecx, ecx
  0003c	f7 d9		 neg	 ecx
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 _DwDbgAssert
  00044	83 c4 10	 add	 esp, 16			; 00000010H

; 421  :     ASSERT(cbSize);

  00047	68 a5 01 00 00	 push	 421			; 000001a5H
  0004c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06OFIAKHFO@cbSize?$AA@
  00056	33 d2		 xor	 edx, edx
  00058	83 7d 20 00	 cmp	 DWORD PTR _cbSize$[ebp], 0
  0005c	0f 94 c2	 sete	 dl
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 _DwDbgAssert
  00065	83 c4 10	 add	 esp, 16			; 00000010H

; 422  :     
; 423  :     //
; 424  :     // Because of alignment issues, the base address may be incremented more
; 425  :     // than sizeof(DSMEMTRACK).  For this reason, we store the tracking data
; 426  :     // directly behind the allocation, but allocate more than cbSize +
; 427  :     // sizeof(DSMEMTRACK).
; 428  :     //
; 429  : 
; 430  :     pTracking = (LPDSMEMTRACK)((LPBYTE)pvBaseAddress + cbTracking - sizeof(*pTracking));

  00068	8b 45 0c	 mov	 eax, DWORD PTR _cbTracking$[ebp]
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  0006e	8d 54 01 e0	 lea	 edx, DWORD PTR [ecx+eax-32]
  00072	89 55 fc	 mov	 DWORD PTR _pTracking$[ebp], edx

; 431  : 
; 432  :     //
; 433  :     // Create the tracking info
; 434  :     //
; 435  : 
; 436  :     pTracking->pszFile = pszFile;

  00075	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  00078	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  0007b	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 437  :     pTracking->nLine = nLine;

  0007e	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  00081	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  00084	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 438  :     pTracking->pszClass = pszClass;

  00087	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  0008a	8b 55 18	 mov	 edx, DWORD PTR _pszClass$[ebp]
  0008d	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 439  :     pTracking->nAllocatorTag = nAllocatorTag;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  00093	8b 4d 1c	 mov	 ecx, DWORD PTR _nAllocatorTag$[ebp]
  00096	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 440  :     pTracking->cbSize = cbSize;

  00099	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  0009c	8b 45 20	 mov	 eax, DWORD PTR _cbSize$[ebp]
  0009f	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 441  :     pTracking->pvBaseAddress = pvBaseAddress;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000a5	8b 55 08	 mov	 edx, DWORD PTR _pvBaseAddress$[ebp]
  000a8	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 442  : 
; 443  :     //
; 444  :     // Raise IRQL for synchronization
; 445  :     //
; 446  : 
; 447  :     AutoIrql();

  000ab	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000ae	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 448  : 
; 449  :     //
; 450  :     // Add the allocation to the list
; 451  :     //
; 452  : 
; 453  :     if(!g_lstDirectSoundTestMemoryTracking.Flink && !g_lstDirectSoundTestMemoryTracking.Blink)

  000b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A, 0
  000ba	75 1d		 jne	 SHORT $L32170
  000bc	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A+4, 0
  000c3	75 14		 jne	 SHORT $L32170

; 454  :     {
; 455  :         InitializeListHead(&g_lstDirectSoundTestMemoryTracking);

  000c5	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A+4, OFFSET FLAT:?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A ; g_lstDirectSoundTestMemoryTracking
  000cf	a1 04 00 00 00	 mov	 eax, DWORD PTR ?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A+4
  000d4	a3 00 00 00 00	 mov	 DWORD PTR ?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A, eax
$L32170:

; 456  :     }
; 457  :     
; 458  :     InsertTailListUninit(&g_lstDirectSoundTestMemoryTracking, &pTracking->leListEntry);

  000d9	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000dc	51		 push	 ecx
  000dd	68 00 00 00 00	 push	 OFFSET FLAT:?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A ; g_lstDirectSoundTestMemoryTracking
  000e2	e8 00 00 00 00	 call	 ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailListUninit

; 459  : 
; 460  :     //
; 461  :     // Fix up the base address
; 462  :     //
; 463  : 
; 464  :     return pTracking + 1;

  000e7	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  000ea	83 c2 20	 add	 edx, 32			; 00000020H
  000ed	89 55 f0	 mov	 DWORD PTR $T32483[ebp], edx
  000f0	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000f3	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  000f8	8b 45 f0	 mov	 eax, DWORD PTR $T32483[ebp]

; 465  : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 1c 00	 ret	 28			; 0000001cH
?DirectSoundTestTrackAlloc@@YGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ENDP ; DirectSoundTestTrackAlloc
DSOUND	ENDS
PUBLIC	?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList
PUBLIC	??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
;	COMDAT ??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\initlib\ntlist.h
DSOUND_RD	SEGMENT
??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\initlib\ntlist.h', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT
_ListHead$ = 8
_Entry$ = 12
?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z PROC NEAR	; InsertTailListUninit, COMDAT

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

  00003	6a 72		 push	 114			; 00000072H
  00005	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
  0000a	6a 00		 push	 0
  0000c	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 115  : 
; 116  :     Entry->Flink = ListHead;

  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00018	8b 55 08	 mov	 edx, DWORD PTR _ListHead$[ebp]
  0001b	89 11		 mov	 DWORD PTR [ecx], edx

; 117  :     Entry->Blink = ListHead->Blink;

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  00023	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00026	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 118  :     
; 119  :     Entry->Flink->Blink = Entry;

  00029	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00031	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 120  :     Entry->Blink->Flink = Entry;

  00034	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  0003d	89 11		 mov	 DWORD PTR [ecx], edx

; 121  : 
; 122  :     AssertValidEntryList(Entry, ASSERT_IN_LIST);

  0003f	6a 7a		 push	 122			; 0000007aH
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
  00046	6a 01		 push	 1
  00048	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 123  : }    

  00051	5d		 pop	 ebp
  00052	c2 08 00	 ret	 8
?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ENDP	; InsertTailListUninit
DSOUND	ENDS
PUBLIC	??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@ ; `string'
PUBLIC	??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@ ; `string'
PUBLIC	??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@ ; `string'
PUBLIC	??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@ ; `string'
PUBLIC	??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@	; `string'
;	COMDAT ??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@
DSOUND_RD	SEGMENT
??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@ DB 'NULL list entry po'
	DB	'inter', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@
DSOUND_RD	SEGMENT
??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@ DB 'List entry c'
	DB	'ontains NULL pointer', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@
DSOUND_RD	SEGMENT
??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@ DB 'List entry '
	DB	'partially points to itself', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@
DSOUND_RD	SEGMENT
??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@ DB 'List entry not in '
	DB	'list', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@
DSOUND_RD	SEGMENT
??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@ DB 'List entry in list', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
DSOUND	SEGMENT
_Entry$ = 8
_nFlags$ = 12
_pszFile$ = 16
_nLine$ = 20
?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z PROC NEAR ; __AssertValidEntryList, COMDAT

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   :     if(!Entry)

  00003	83 7d 08 00	 cmp	 DWORD PTR _Entry$[ebp], 0
  00007	75 1c		 jne	 SHORT $L29503

; 35   :     {
; 36   :         DwDbgAssert(TRUE, "NULL list entry pointer", pszFile, nLine);

  00009	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  00010	51		 push	 ecx
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 _DwDbgAssert
  0001d	83 c4 10	 add	 esp, 16			; 00000010H

; 37   :     }
; 38   :     else if(!Entry->Flink || !Entry->Blink)

  00020	e9 c0 00 00 00	 jmp	 $L29502
$L29503:
  00025	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  00028	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0002b	74 09		 je	 SHORT $L29507
  0002d	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	75 1c		 jne	 SHORT $L29506
$L29507:

; 39   :     {
; 40   :         DwDbgAssert(TRUE, "List entry contains NULL pointer", pszFile, nLine);

  00036	8b 4d 14	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  0003d	52		 push	 edx
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@
  00043	6a 01		 push	 1
  00045	e8 00 00 00 00	 call	 _DwDbgAssert
  0004a	83 c4 10	 add	 esp, 16			; 00000010H

; 41   :     }
; 42   :     else if((Entry == Entry->Flink) || (Entry == Entry->Blink))

  0004d	e9 93 00 00 00	 jmp	 $L29502
$L29506:
  00052	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00058	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0005a	74 0b		 je	 SHORT $L29511
  0005c	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0005f	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00062	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00065	75 2e		 jne	 SHORT $L29510
$L29511:

; 43   :     {
; 44   :         if((Entry != Entry->Flink) || (Entry != Entry->Blink))

  00067	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0006a	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0006d	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0006f	75 0b		 jne	 SHORT $L29513
  00071	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00077	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0007a	74 17		 je	 SHORT $L29512
$L29513:

; 45   :         {
; 46   :             DwDbgAssert(TRUE, "List entry partially points to itself", pszFile, nLine);

  0007c	8b 55 14	 mov	 edx, DWORD PTR _nLine$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 10	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00083	50		 push	 eax
  00084	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@
  00089	6a 01		 push	 1
  0008b	e8 00 00 00 00	 call	 _DwDbgAssert
  00090	83 c4 10	 add	 esp, 16			; 00000010H
$L29512:

; 47   :         }
; 48   :     }
; 49   :     else if(ASSERT_IN_LIST == nFlags)

  00093	eb 50		 jmp	 SHORT $L29502
$L29510:
  00095	83 7d 0c 01	 cmp	 DWORD PTR _nFlags$[ebp], 1
  00099	75 23		 jne	 SHORT $L29516

; 50   :     {
; 51   :         if(!IsEntryInList(Entry))

  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0009e	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a0	3b 55 08	 cmp	 edx, DWORD PTR _Entry$[ebp]
  000a3	75 17		 jne	 SHORT $L29517

; 52   :         {
; 53   :             DwDbgAssert(TRUE, "List entry not in list", pszFile, nLine);

  000a5	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  000ac	51		 push	 ecx
  000ad	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@
  000b2	6a 01		 push	 1
  000b4	e8 00 00 00 00	 call	 _DwDbgAssert
  000b9	83 c4 10	 add	 esp, 16			; 00000010H
$L29517:

; 54   :         }
; 55   :     }
; 56   :     else if(ASSERT_NOT_IN_LIST == nFlags)

  000bc	eb 27		 jmp	 SHORT $L29502
$L29516:
  000be	83 7d 0c 02	 cmp	 DWORD PTR _nFlags$[ebp], 2
  000c2	75 21		 jne	 SHORT $L29502

; 57   :     {
; 58   :         if(IsEntryInList(Entry))

  000c4	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  000c7	8b 02		 mov	 eax, DWORD PTR [edx]
  000c9	3b 45 08	 cmp	 eax, DWORD PTR _Entry$[ebp]
  000cc	74 17		 je	 SHORT $L29502

; 59   :         {
; 60   :             DwDbgAssert(TRUE, "List entry in list", pszFile, nLine);

  000ce	8b 4d 14	 mov	 ecx, DWORD PTR _nLine$[ebp]
  000d1	51		 push	 ecx
  000d2	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  000d5	52		 push	 edx
  000d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@
  000db	6a 01		 push	 1
  000dd	e8 00 00 00 00	 call	 _DwDbgAssert
  000e2	83 c4 10	 add	 esp, 16			; 00000010H
$L29502:

; 61   :         }
; 62   :     }
; 63   : }

  000e5	5d		 pop	 ebp
  000e6	c2 10 00	 ret	 16			; 00000010H
?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ENDP ; __AssertValidEntryList
DSOUND	ENDS
PUBLIC	??0CIrql@@QAE@XZ				; CIrql::CIrql
PUBLIC	?Raise@CIrql@@QAEXXZ				; CIrql::Raise
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\drvhlp.h
;	COMDAT ??0CAutoIrql@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CAutoIrql@@QAE@XZ PROC NEAR				; CAutoIrql::CAutoIrql, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CIrql@@QAE@XZ	; CIrql::CIrql

; 73   :     Raise();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?Raise@CIrql@@QAEXXZ	; CIrql::Raise

; 74   : }

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CAutoIrql@@QAE@XZ ENDP				; CAutoIrql::CAutoIrql
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??0CIrql@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CIrql@@QAE@XZ PROC NEAR				; CIrql::CIrql, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 39   :     m_fRaised = FALSE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 40   : }

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0CIrql@@QAE@XZ ENDP					; CIrql::CIrql
DSOUND	ENDS
EXTRN	__imp_@KfRaiseIrql@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Raise@CIrql@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Raise@CIrql@@QAEXXZ PROC NEAR				; CIrql::Raise, COMDAT
; _this$ = ecx

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 44   :     if(m_fRaised = (KeGetCurrentIrql() < DISPATCH_LEVEL))

  00007	e8 00 00 00 00	 call	 _KeGetCurrentIrql@0
  0000c	0f b6 c0	 movzx	 eax, al
  0000f	33 c9		 xor	 ecx, ecx
  00011	83 f8 02	 cmp	 eax, 2
  00014	0f 9c c1	 setl	 cl
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00024	74 0d		 je	 SHORT $L29688

; 45   :     {
; 46   :         m_irql = KfRaiseIrql(DISPATCH_LEVEL);

  00026	b1 02		 mov	 cl, 2
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfRaiseIrql@4
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	88 01		 mov	 BYTE PTR [ecx], al
$L29688:

; 47   :     }
; 48   : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?Raise@CIrql@@QAEXXZ ENDP				; CIrql::Raise
; Function compile flags: /Odt
; File c:\xbox\private\ntos\inc\i386.h
DSOUND	ENDS
;	COMDAT _KeGetCurrentIrql@0
DSOUND	SEGMENT
_KeGetCurrentIrql@0 PROC NEAR				; COMDAT

; 1496 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1497 : #if defined(_NTSYSTEM_)
; 1498 :     return KeGetPcr()->Irql;
; 1499 : #else
; 1500 :     __asm {  movzx eax, byte ptr fs:[0] KPCR.Irql }

  00003	64 0f b6 05 24
	00 00 00	 movzx	 eax, BYTE PTR fs:36

; 1501 : #endif
; 1502 : }    

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_KeGetCurrentIrql@0 ENDP
DSOUND	ENDS
PUBLIC	?Lower@CIrql@@QAEXXZ				; CIrql::Lower
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\drvhlp.h
;	COMDAT ??1CAutoIrql@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CAutoIrql@@QAE@XZ PROC NEAR				; CAutoIrql::~CAutoIrql, COMDAT
; _this$ = ecx

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   :     Lower();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Lower@CIrql@@QAEXXZ	; CIrql::Lower

; 79   : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CAutoIrql@@QAE@XZ ENDP				; CAutoIrql::~CAutoIrql
DSOUND	ENDS
EXTRN	__imp_@KfLowerIrql@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Lower@CIrql@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Lower@CIrql@@QAEXXZ PROC NEAR				; CIrql::Lower, COMDAT
; _this$ = ecx

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   :     if(m_fRaised)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 15		 je	 SHORT $L29693

; 53   :     {
; 54   :         KfLowerIrql(m_irql);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8a 09		 mov	 cl, BYTE PTR [ecx]
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfLowerIrql@4

; 55   :         m_fRaised = FALSE;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$L29693:

; 56   :     }
; 57   : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?Lower@CIrql@@QAEXXZ ENDP				; CIrql::Lower
DSOUND	ENDS
PUBLIC	?DirectSoundTestForgetAlloc@@YGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ; DirectSoundTestForgetAlloc
PUBLIC	??_C@_0CK@PJHOCMHE@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@ ; `string'
PUBLIC	?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z	; RemoveEntryList
;	COMDAT ??_C@_0CK@PJHOCMHE@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@
; File c:\xbox\private\windows\directx\dsound\initlib\memmgr.cpp
DSOUND_RD	SEGMENT
??_C@_0CK@PJHOCMHE@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@ DB 'nAll'
	DB	'ocatorTag == pTracking->nAllocatorTag', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?DirectSoundTestForgetAlloc@@YGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z
DSOUND	SEGMENT
$T32511 = -16
___AutoIrql$ = -12
_pTracking$ = -4
_pvBaseAddress$ = 8
_nAllocatorTag$ = 12
?DirectSoundTestForgetAlloc@@YGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z PROC NEAR ; DirectSoundTestForgetAlloc, COMDAT

; 493  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 494  :     LPDSMEMTRACK            pTracking   = (LPDSMEMTRACK)pvBaseAddress - 1;

  00006	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  00009	83 e8 20	 sub	 eax, 32			; 00000020H
  0000c	89 45 fc	 mov	 DWORD PTR _pTracking$[ebp], eax

; 495  : 
; 496  :     ASSERT(pvBaseAddress);

  0000f	68 f0 01 00 00	 push	 496			; 000001f0H
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@
  0001e	33 c9		 xor	 ecx, ecx
  00020	83 7d 08 00	 cmp	 DWORD PTR _pvBaseAddress$[ebp], 0
  00024	0f 94 c1	 sete	 cl
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _DwDbgAssert
  0002d	83 c4 10	 add	 esp, 16			; 00000010H

; 497  : 
; 498  :     //
; 499  :     // Assert that the tag matches what we expect
; 500  :     //
; 501  : 
; 502  :     ASSERT(nAllocatorTag == pTracking->nAllocatorTag);

  00030	68 f6 01 00 00	 push	 502			; 000001f6H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@PJHOCMHE@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@
  0003f	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  00042	8b 45 0c	 mov	 eax, DWORD PTR _nAllocatorTag$[ebp]
  00045	33 c9		 xor	 ecx, ecx
  00047	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  0004a	0f 95 c1	 setne	 cl
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _DwDbgAssert
  00053	83 c4 10	 add	 esp, 16			; 00000010H

; 503  :     
; 504  :     //
; 505  :     // Raise IRQL for synchronization
; 506  :     //
; 507  : 
; 508  :     AutoIrql();

  00056	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00059	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 509  : 
; 510  :     //
; 511  :     // Remove the allocation from the list
; 512  :     //
; 513  : 
; 514  :     RemoveEntryList(&pTracking->leListEntry);

  0005e	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 515  : 
; 516  :     //
; 517  :     // Return the proper base address
; 518  :     //
; 519  : 
; 520  :     return pTracking->pvBaseAddress;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  0006a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0006d	89 4d f0	 mov	 DWORD PTR $T32511[ebp], ecx
  00070	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00073	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  00078	8b 45 f0	 mov	 eax, DWORD PTR $T32511[ebp]

; 521  : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8
?DirectSoundTestForgetAlloc@@YGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ENDP ; DirectSoundTestForgetAlloc
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\ntlist.h
DSOUND	ENDS
;	COMDAT ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z
DSOUND	SEGMENT
_Entry$ = 8
?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z PROC NEAR	; RemoveEntryList, COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  :     AssertValidEntryList(Entry, ASSERT_VALID_ONLY);

  00003	68 c2 00 00 00	 push	 194			; 000000c2H
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIDDCAOM@c?3?2xbox?2private?2windows?2directx?2@
  0000d	6a 00		 push	 0
  0000f	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 195  : 
; 196  :     if(IsEntryInList(Entry))

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001d	3b 55 08	 cmp	 edx, DWORD PTR _Entry$[ebp]
  00020	74 2c		 je	 SHORT $L29543

; 197  :     {
; 198  :         Entry->Flink->Blink = Entry->Blink;

  00022	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0002a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 199  :         Entry->Blink->Flink = Entry->Flink;

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00033	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00036	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 0a		 mov	 DWORD PTR [edx], ecx

; 200  : 
; 201  :         Entry->Flink = Entry->Blink = Entry;

  0003d	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  00040	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00043	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00049	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0004c	89 11		 mov	 DWORD PTR [ecx], edx
$L29543:

; 202  :     }
; 203  : 
; 204  :     return Entry;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]

; 205  : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ENDP	; RemoveEntryList
DSOUND	ENDS
PUBLIC	_DirectSoundTestTrackingPoolAlloc@24
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\initlib\memmgr.cpp
;	COMDAT _DirectSoundTestTrackingPoolAlloc@24
DSOUND	SEGMENT
_pvBuffer$ = -4
_pszFile$ = 8
_nLine$ = 12
_pszClass$ = 16
_nPoolTag$ = 20
_cbBuffer$ = 24
_fZeroInit$ = 28
_DirectSoundTestTrackingPoolAlloc@24 PROC NEAR		; COMDAT

; 557  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 558  :     static const ULONG      cbTracking  = PAGE_SIZE;
; 559  :     LPVOID                  pvBuffer;
; 560  :     
; 561  :     //
; 562  :     // Do the actual allocation
; 563  :     //
; 564  :     
; 565  :     if(pvBuffer = DirectSoundTestPoolAlloc(nPoolTag, cbBuffer + cbTracking, fZeroInit))

  00004	8b 45 1c	 mov	 eax, DWORD PTR _fZeroInit$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 18	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  0000b	81 c1 00 10 00
	00		 add	 ecx, 4096		; 00001000H
  00011	51		 push	 ecx
  00012	8b 55 14	 mov	 edx, DWORD PTR _nPoolTag$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ?DirectSoundTestPoolAlloc@@YGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSoundTestPoolAlloc
  0001b	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  0001e	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00022	74 26		 je	 SHORT $L32192

; 566  :     {
; 567  :         //
; 568  :         // Complete the tracking
; 569  :         //
; 570  : 
; 571  :         pvBuffer = DirectSoundTestTrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_POOL, cbBuffer);

  00024	8b 45 18	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  00027	50		 push	 eax
  00028	68 70 6f 6f 6c	 push	 1819242352		; 6c6f6f70H
  0002d	8b 4d 10	 mov	 ecx, DWORD PTR _pszClass$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 0c	 mov	 edx, DWORD PTR _nLine$[ebp]
  00034	52		 push	 edx
  00035	8b 45 08	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00038	50		 push	 eax
  00039	68 00 10 00 00	 push	 4096			; 00001000H
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ?DirectSoundTestTrackAlloc@@YGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ; DirectSoundTestTrackAlloc
  00047	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
$L32192:

; 572  :     }
; 573  : 
; 574  :     return pvBuffer;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 575  : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 18 00	 ret	 24			; 00000018H
_DirectSoundTestTrackingPoolAlloc@24 ENDP
DSOUND	ENDS
PUBLIC	_DirectSoundTestTrackingPoolFree@4
; Function compile flags: /Odt
;	COMDAT _DirectSoundTestTrackingPoolFree@4
DSOUND	SEGMENT
_pvBuffer$ = 8
_DirectSoundTestTrackingPoolFree@4 PROC NEAR		; COMDAT

; 601  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 602  :     //
; 603  :     // Free tracking information
; 604  :     //
; 605  : 
; 606  :     pvBuffer = DirectSoundTestForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_POOL);

  00003	68 70 6f 6f 6c	 push	 1819242352		; 6c6f6f70H
  00008	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?DirectSoundTestForgetAlloc@@YGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ; DirectSoundTestForgetAlloc
  00011	89 45 08	 mov	 DWORD PTR _pvBuffer$[ebp], eax

; 607  : 
; 608  :     //
; 609  :     // Free memory
; 610  :     //
; 611  : 
; 612  :     DirectSoundTestPoolFree(pvBuffer);

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?DirectSoundTestPoolFree@@YGXPAX@Z ; DirectSoundTestPoolFree

; 613  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
_DirectSoundTestTrackingPoolFree@4 ENDP
DSOUND	ENDS
PUBLIC	_DirectSoundTestTrackingPhysicalAlloc@28
; Function compile flags: /Odt
;	COMDAT _DirectSoundTestTrackingPhysicalAlloc@28
DSOUND	SEGMENT
_pvBuffer$ = -8
_cbTracking$ = -4
_pszFile$ = 8
_nLine$ = 12
_pszClass$ = 16
_cbBuffer$ = 20
_cbAlignment$ = 24
_dwFlags$ = 28
_fZeroInit$ = 32
_DirectSoundTestTrackingPhysicalAlloc@28 PROC NEAR	; COMDAT

; 648  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 649  :     ULONG                   cbTracking;
; 650  :     LPVOID                  pvBuffer;
; 651  : 
; 652  :     //
; 653  :     // Make sure we allocate enough information for the tracking data
; 654  :     //
; 655  : 
; 656  :     if(cbAlignment >= sizeof(DSMEMTRACK))

  00006	83 7d 18 20	 cmp	 DWORD PTR _cbAlignment$[ebp], 32 ; 00000020H
  0000a	72 08		 jb	 SHORT $L32208

; 657  :     {
; 658  :         cbTracking = cbAlignment;

  0000c	8b 45 18	 mov	 eax, DWORD PTR _cbAlignment$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _cbTracking$[ebp], eax

; 659  :     }
; 660  :     else

  00012	eb 12		 jmp	 SHORT $L32209
$L32208:

; 661  :     {
; 662  :         cbTracking = BLOCKALIGNPAD(sizeof(DSMEMTRACK), cbAlignment);

  00014	8b 45 18	 mov	 eax, DWORD PTR _cbAlignment$[ebp]
  00017	83 c0 1f	 add	 eax, 31			; 0000001fH
  0001a	33 d2		 xor	 edx, edx
  0001c	f7 75 18	 div	 DWORD PTR _cbAlignment$[ebp]
  0001f	0f af 45 18	 imul	 eax, DWORD PTR _cbAlignment$[ebp]
  00023	89 45 fc	 mov	 DWORD PTR _cbTracking$[ebp], eax
$L32209:

; 663  :     }
; 664  :     
; 665  :     //
; 666  :     // Do the actual allocation
; 667  :     //
; 668  :     
; 669  :     if(pvBuffer = DirectSoundTestPhysicalAlloc(cbBuffer + cbTracking, cbAlignment, dwFlags, fZeroInit))

  00026	8b 4d 20	 mov	 ecx, DWORD PTR _fZeroInit$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 1c	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 18	 mov	 eax, DWORD PTR _cbAlignment$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 14	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00035	03 4d fc	 add	 ecx, DWORD PTR _cbTracking$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?DirectSoundTestPhysicalAlloc@@YGPAXKKKH@Z ; DirectSoundTestPhysicalAlloc
  0003e	89 45 f8	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  00041	83 7d f8 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00045	74 25		 je	 SHORT $L32211

; 670  :     {
; 671  :         //
; 672  :         // Complete the tracking
; 673  :         //
; 674  : 
; 675  :         pvBuffer = DirectSoundTestTrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_PHYS, cbBuffer);

  00047	8b 55 14	 mov	 edx, DWORD PTR _cbBuffer$[ebp]
  0004a	52		 push	 edx
  0004b	68 70 68 79 73	 push	 1937336432		; 73796870H
  00050	8b 45 10	 mov	 eax, DWORD PTR _pszClass$[ebp]
  00053	50		 push	 eax
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00057	51		 push	 ecx
  00058	8b 55 08	 mov	 edx, DWORD PTR _pszFile$[ebp]
  0005b	52		 push	 edx
  0005c	8b 45 fc	 mov	 eax, DWORD PTR _cbTracking$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d f8	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ?DirectSoundTestTrackAlloc@@YGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ; DirectSoundTestTrackAlloc
  00069	89 45 f8	 mov	 DWORD PTR _pvBuffer$[ebp], eax
$L32211:

; 676  :     }
; 677  : 
; 678  :     return pvBuffer;

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 679  : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 1c 00	 ret	 28			; 0000001cH
_DirectSoundTestTrackingPhysicalAlloc@28 ENDP
DSOUND	ENDS
PUBLIC	_DirectSoundTestTrackingPhysicalFree@4
; Function compile flags: /Odt
;	COMDAT _DirectSoundTestTrackingPhysicalFree@4
DSOUND	SEGMENT
_pvBuffer$ = 8
_DirectSoundTestTrackingPhysicalFree@4 PROC NEAR	; COMDAT

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 706  :     //
; 707  :     // Free tracking information
; 708  :     //
; 709  : 
; 710  :     pvBuffer = DirectSoundTestForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_PHYS);

  00003	68 70 68 79 73	 push	 1937336432		; 73796870H
  00008	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?DirectSoundTestForgetAlloc@@YGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ; DirectSoundTestForgetAlloc
  00011	89 45 08	 mov	 DWORD PTR _pvBuffer$[ebp], eax

; 711  : 
; 712  :     //
; 713  :     // Free memory
; 714  :     //
; 715  : 
; 716  :     DirectSoundTestPhysicalFree(pvBuffer);

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?DirectSoundTestPhysicalFree@@YGXPAX@Z ; DirectSoundTestPhysicalFree

; 717  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
_DirectSoundTestTrackingPhysicalFree@4 ENDP
DSOUND	ENDS
PUBLIC	_DirectSoundTestTrackingMemAlloc@24
; Function compile flags: /Odt
;	COMDAT _DirectSoundTestTrackingMemAlloc@24
DSOUND	SEGMENT
_pvBuffer$ = -4
_pszFile$ = 8
_nLine$ = 12
_pszClass$ = 16
_nPoolTag$ = 20
_cbBuffer$ = 24
_fZeroInit$ = 28
_DirectSoundTestTrackingMemAlloc@24 PROC NEAR		; COMDAT

; 752  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 753  :     static const ULONG      cbTracking  = sizeof(DSMEMTRACK);
; 754  :     LPVOID                  pvBuffer;
; 755  :     
; 756  :     //
; 757  :     // Do the actual allocation
; 758  :     //
; 759  :     
; 760  :     if(pvBuffer = DirectSoundTestMemAlloc(nPoolTag, cbBuffer + cbTracking, fZeroInit))

  00004	8b 45 1c	 mov	 eax, DWORD PTR _fZeroInit$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 18	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  0000b	83 c1 20	 add	 ecx, 32			; 00000020H
  0000e	51		 push	 ecx
  0000f	8b 55 14	 mov	 edx, DWORD PTR _nPoolTag$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?DirectSoundTestMemAlloc@@YGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSoundTestMemAlloc
  00018	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  0001b	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  0001f	74 23		 je	 SHORT $L32227

; 761  :     {
; 762  :         //
; 763  :         // Complete the tracking
; 764  :         //
; 765  : 
; 766  :         pvBuffer = DirectSoundTestTrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_SLOP, cbBuffer);

  00021	8b 45 18	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  00024	50		 push	 eax
  00025	68 73 6c 6f 70	 push	 1886350451		; 706f6c73H
  0002a	8b 4d 10	 mov	 ecx, DWORD PTR _pszClass$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 0c	 mov	 edx, DWORD PTR _nLine$[ebp]
  00031	52		 push	 edx
  00032	8b 45 08	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00035	50		 push	 eax
  00036	6a 20		 push	 32			; 00000020H
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ?DirectSoundTestTrackAlloc@@YGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ; DirectSoundTestTrackAlloc
  00041	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
$L32227:

; 767  :     }
; 768  : 
; 769  :     return pvBuffer;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 770  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 18 00	 ret	 24			; 00000018H
_DirectSoundTestTrackingMemAlloc@24 ENDP
DSOUND	ENDS
PUBLIC	_DirectSoundTestTrackingMemFree@4
; Function compile flags: /Odt
;	COMDAT _DirectSoundTestTrackingMemFree@4
DSOUND	SEGMENT
_pvBuffer$ = 8
_DirectSoundTestTrackingMemFree@4 PROC NEAR		; COMDAT

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 801  :     //
; 802  :     // Free tracking information
; 803  :     //
; 804  : 
; 805  :     pvBuffer = DirectSoundTestForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_SLOP);

  00003	68 73 6c 6f 70	 push	 1886350451		; 706f6c73H
  00008	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?DirectSoundTestForgetAlloc@@YGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ; DirectSoundTestForgetAlloc
  00011	89 45 08	 mov	 DWORD PTR _pvBuffer$[ebp], eax

; 806  : 
; 807  :     //
; 808  :     // Free memory
; 809  :     //
; 810  : 
; 811  :     DirectSoundTestMemFree(pvBuffer);

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?DirectSoundTestMemFree@@YGXPAX@Z ; DirectSoundTestMemFree

; 812  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
_DirectSoundTestTrackingMemFree@4 ENDP
DSOUND	ENDS
PUBLIC	?DirectSoundTestDumpMemoryUsage@@YGXH@Z		; DirectSoundTestDumpMemoryUsage
PUBLIC	??_C@_0EP@IIFDJHMP@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_0BP@DCCEGIIC@DirectSoundTestDumpMemoryUsage?$AA@ ; `string'
PUBLIC	??_C@_0BI@MIBDOIDJ@Begin?5memory?5usage?5dump?$AA@ ; `string'
PUBLIC	??_C@_0BI@JPIKIBNC@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BH@OHKIAENG@Pool?5memory?5used?3?5?5?$CFlu?$AA@ ; `string'
PUBLIC	??_C@_0BL@OGBIDBPB@Physical?5memory?5used?3?5?5?$CFlu?$AA@ ; `string'
PUBLIC	??_C@_0CN@EIKGFANE@Physical?5memory?5available?5for?5re@ ; `string'
PUBLIC	??_C@_0CA@HBBPMJBE@Physical?5memory?5recovered?3?5?5?$CFlu?$AA@ ; `string'
PUBLIC	??_C@_0BG@DICBIGIJ@End?5memory?5usage?5dump?$AA@ ; `string'
PUBLIC	??_C@_0DC@JOELGBPO@?$CBIsListEmpty?$CI?$CGg_lstDirectSoundTe@ ; `string'
PUBLIC	??_C@_0DB@LDBGAFO@IsListEmpty?$CI?$CGg_lstDirectSoundTes@ ; `string'
;	COMDAT ??_C@_0BP@DCCEGIIC@DirectSoundTestDumpMemoryUsage?$AA@
DSOUND_RD	SEGMENT
??_C@_0BP@DCCEGIIC@DirectSoundTestDumpMemoryUsage?$AA@ DB 'DirectSoundTes'
	DB	'tDumpMemoryUsage', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ?pszBanner@?1??DirectSoundTestDumpMemoryUsage@@YGXH@Z@4QBDB
DSOUND_RD	SEGMENT
?pszBanner@?1??DirectSoundTestDumpMemoryUsage@@YGXH@Z@4QBDB DD FLAT:??_C@_0EP@IIFDJHMP@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `DirectSoundTestDumpMemoryUsage'::`2'::pszBanner
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@MIBDOIDJ@Begin?5memory?5usage?5dump?$AA@
DSOUND_RD	SEGMENT
??_C@_0BI@MIBDOIDJ@Begin?5memory?5usage?5dump?$AA@ DB 'Begin memory usage'
	DB	' dump', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@JPIKIBNC@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@
DSOUND_RD	SEGMENT
??_C@_0BI@JPIKIBNC@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@ DB '%'
	DB	'x (%lu bytes, type %s)', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@OHKIAENG@Pool?5memory?5used?3?5?5?$CFlu?$AA@
DSOUND_RD	SEGMENT
??_C@_0BH@OHKIAENG@Pool?5memory?5used?3?5?5?$CFlu?$AA@ DB 'Pool memory us'
	DB	'ed:  %lu', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@OGBIDBPB@Physical?5memory?5used?3?5?5?$CFlu?$AA@
DSOUND_RD	SEGMENT
??_C@_0BL@OGBIDBPB@Physical?5memory?5used?3?5?5?$CFlu?$AA@ DB 'Physical m'
	DB	'emory used:  %lu', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CN@EIKGFANE@Physical?5memory?5available?5for?5re@
DSOUND_RD	SEGMENT
??_C@_0CN@EIKGFANE@Physical?5memory?5available?5for?5re@ DB 'Physical mem'
	DB	'ory available for recovery:  %lu', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@HBBPMJBE@Physical?5memory?5recovered?3?5?5?$CFlu?$AA@
DSOUND_RD	SEGMENT
??_C@_0CA@HBBPMJBE@Physical?5memory?5recovered?3?5?5?$CFlu?$AA@ DB 'Physi'
	DB	'cal memory recovered:  %lu', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@DICBIGIJ@End?5memory?5usage?5dump?$AA@
DSOUND_RD	SEGMENT
??_C@_0BG@DICBIGIJ@End?5memory?5usage?5dump?$AA@ DB 'End memory usage dum'
	DB	'p', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DC@JOELGBPO@?$CBIsListEmpty?$CI?$CGg_lstDirectSoundTe@
DSOUND_RD	SEGMENT
??_C@_0DC@JOELGBPO@?$CBIsListEmpty?$CI?$CGg_lstDirectSoundTe@ DB '!IsList'
	DB	'Empty(&g_lstDirectSoundTestMemoryTracking)', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DB@LDBGAFO@IsListEmpty?$CI?$CGg_lstDirectSoundTes@
DSOUND_RD	SEGMENT
??_C@_0DB@LDBGAFO@IsListEmpty?$CI?$CGg_lstDirectSoundTes@ DB 'IsListEmpty'
	DB	'(&g_lstDirectSoundTestMemoryTracking)', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0EP@IIFDJHMP@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
DSOUND_RD	SEGMENT
??_C@_0EP@IIFDJHMP@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'-------------------------------------------------------------'
	DB	'----------------', 00H			; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?DirectSoundTestDumpMemoryUsage@@YGXH@Z
DSOUND	SEGMENT
___AutoIrql$ = -16
_pleEntry$ = -8
_pTracking$ = -4
_fAssertNone$ = 8
?DirectSoundTestDumpMemoryUsage@@YGXH@Z PROC NEAR	; DirectSoundTestDumpMemoryUsage, COMDAT

; 842  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 843  : 
; 844  : #ifdef DEBUG
; 845  : 
; 846  :     static const LPCSTR     pszBanner           = "------------------------------------------------------------------------------";
; 847  : 
; 848  : #ifdef TRACK_MEMORY_USAGE
; 849  : 
; 850  :     PLIST_ENTRY             pleEntry;
; 851  :     LPDSMEMTRACK            pTracking;
; 852  : 
; 853  : #endif // TRACK_MEMORY_USAGE
; 854  : 
; 855  :     DwDbgSetContext(DPRINTF_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);

  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DCCEGIIC@DirectSoundTestDumpMemoryUsage?$AA@
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 _DwDbgSetContext
  0001d	83 c4 18	 add	 esp, 24			; 00000018H

; 856  :     DwDbgPrint(pszBanner);

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pszBanner@?1??DirectSoundTestDumpMemoryUsage@@YGXH@Z@4QBDB
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _DwDbgPrint
  0002b	83 c4 04	 add	 esp, 4

; 857  :     DwDbgPrint("Begin memory usage dump");

  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@MIBDOIDJ@Begin?5memory?5usage?5dump?$AA@
  00033	e8 00 00 00 00	 call	 _DwDbgPrint
  00038	83 c4 04	 add	 esp, 4

; 858  :     DwDbgPrint(pszBanner);

  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??DirectSoundTestDumpMemoryUsage@@YGXH@Z@4QBDB
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 _DwDbgPrint
  00047	83 c4 04	 add	 esp, 4

; 859  :     
; 860  : #ifdef TRACK_MEMORY_USAGE
; 861  : 
; 862  :     //
; 863  :     // Raise IRQL for synchronization
; 864  :     //
; 865  : 
; 866  :     AutoIrql();

  0004a	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0004d	e8 00 00 00 00	 call	 ??0CAutoIrql@@QAE@XZ	; CAutoIrql::CAutoIrql

; 867  :    
; 868  :     //
; 869  :     // Show specifically what allocations are remaining
; 870  :     //
; 871  :     
; 872  :     if(g_lstDirectSoundTestMemoryTracking.Flink)

  00052	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A, 0
  00059	0f 84 b8 00 00
	00		 je	 $L32242

; 873  :     {
; 874  :         if(!IsListEmpty(&g_lstDirectSoundTestMemoryTracking))

  0005f	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR ?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A, OFFSET FLAT:?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A ; g_lstDirectSoundTestMemoryTracking
  00069	0f 84 a8 00 00
	00		 je	 $L32242

; 875  :         {
; 876  :             for(pleEntry = g_lstDirectSoundTestMemoryTracking.Flink; pleEntry != &g_lstDirectSoundTestMemoryTracking; pleEntry = pleEntry->Flink)

  0006f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A
  00075	89 55 f8	 mov	 DWORD PTR _pleEntry$[ebp], edx
  00078	eb 08		 jmp	 SHORT $L32244
$L32245:
  0007a	8b 45 f8	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  0007d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007f	89 4d f8	 mov	 DWORD PTR _pleEntry$[ebp], ecx
$L32244:
  00082	81 7d f8 00 00
	00 00		 cmp	 DWORD PTR _pleEntry$[ebp], OFFSET FLAT:?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A ; g_lstDirectSoundTestMemoryTracking
  00089	74 63		 je	 SHORT $L32246

; 877  :             {
; 878  :                 AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

  0008b	68 6e 03 00 00	 push	 878			; 0000036eH
  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  00095	6a 01		 push	 1
  00097	8b 55 f8	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 879  :             
; 880  :                 pTracking = CONTAINING_RECORD(pleEntry, DSMEMTRACK, leListEntry);

  000a0	8b 45 f8	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  000a3	89 45 fc	 mov	 DWORD PTR _pTracking$[ebp], eax

; 881  : 
; 882  :                 DwDbgSetContext(DPRINTF_FILELINE, DPFLVL_ABSOLUTE, pTracking->pszFile, pTracking->nLine, DPF_FNAME, DPF_LIBRARY);

  000a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  000ab	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DCCEGIIC@DirectSoundTestDumpMemoryUsage?$AA@
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000b3	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000b6	52		 push	 edx
  000b7	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  000ba	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000bd	51		 push	 ecx
  000be	6a 00		 push	 0
  000c0	6a 02		 push	 2
  000c2	e8 00 00 00 00	 call	 _DwDbgSetContext
  000c7	83 c4 18	 add	 esp, 24			; 00000018H

; 883  :                 DwDbgPrint("%x (%lu bytes, type %s)", pTracking + 1, pTracking->cbSize, pTracking->pszClass);

  000ca	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  000cd	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000d0	50		 push	 eax
  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000d4	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000d7	52		 push	 edx
  000d8	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  000db	83 c0 20	 add	 eax, 32			; 00000020H
  000de	50		 push	 eax
  000df	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@JPIKIBNC@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@
  000e4	e8 00 00 00 00	 call	 _DwDbgPrint
  000e9	83 c4 10	 add	 esp, 16			; 00000010H

; 884  :             }

  000ec	eb 8c		 jmp	 SHORT $L32245
$L32246:

; 885  : 
; 886  :             DwDbgSetContext(DPRINTF_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);

  000ee	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  000f3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DCCEGIIC@DirectSoundTestDumpMemoryUsage?$AA@
  000f8	6a 00		 push	 0
  000fa	6a 00		 push	 0
  000fc	6a 00		 push	 0
  000fe	6a 01		 push	 1
  00100	e8 00 00 00 00	 call	 _DwDbgSetContext
  00105	83 c4 18	 add	 esp, 24			; 00000018H

; 887  :             DwDbgPrint(pszBanner);

  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??DirectSoundTestDumpMemoryUsage@@YGXH@Z@4QBDB
  0010e	51		 push	 ecx
  0010f	e8 00 00 00 00	 call	 _DwDbgPrint
  00114	83 c4 04	 add	 esp, 4
$L32242:

; 888  :         }
; 889  :     }
; 890  : 
; 891  : #endif // TRACK_MEMORY_USAGE
; 892  : 
; 893  :     DwDbgSetContext(DPRINTF_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);

  00117	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CNKCBOKB@TESTSND?$AA@
  0011c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DCCEGIIC@DirectSoundTestDumpMemoryUsage?$AA@
  00121	6a 00		 push	 0
  00123	6a 00		 push	 0
  00125	6a 00		 push	 0
  00127	6a 01		 push	 1
  00129	e8 00 00 00 00	 call	 _DwDbgSetContext
  0012e	83 c4 18	 add	 esp, 24			; 00000018H

; 894  :     DwDbgPrint("Pool memory used:  %lu", g_dwDirectSoundTestPoolMemoryUsage);

  00131	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_dwDirectSoundTestPoolMemoryUsage@@3KA ; g_dwDirectSoundTestPoolMemoryUsage
  00137	52		 push	 edx
  00138	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@OHKIAENG@Pool?5memory?5used?3?5?5?$CFlu?$AA@
  0013d	e8 00 00 00 00	 call	 _DwDbgPrint
  00142	83 c4 08	 add	 esp, 8

; 895  :     DwDbgPrint("Physical memory used:  %lu", g_dwDirectSoundTestPhysicalMemoryUsage);

  00145	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_dwDirectSoundTestPhysicalMemoryUsage@@3KA ; g_dwDirectSoundTestPhysicalMemoryUsage
  0014a	50		 push	 eax
  0014b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@OGBIDBPB@Physical?5memory?5used?3?5?5?$CFlu?$AA@
  00150	e8 00 00 00 00	 call	 _DwDbgPrint
  00155	83 c4 08	 add	 esp, 8

; 896  :     DwDbgPrint("Physical memory available for recovery:  %lu", g_dwDirectSoundTestPhysicalMemorySlop);

  00158	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_dwDirectSoundTestPhysicalMemorySlop@@3KA ; g_dwDirectSoundTestPhysicalMemorySlop
  0015e	51		 push	 ecx
  0015f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@EIKGFANE@Physical?5memory?5available?5for?5re@
  00164	e8 00 00 00 00	 call	 _DwDbgPrint
  00169	83 c4 08	 add	 esp, 8

; 897  :     DwDbgPrint("Physical memory recovered:  %lu", g_dwDirectSoundTestPhysicalMemoryRecovered);

  0016c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_dwDirectSoundTestPhysicalMemoryRecovered@@3KA ; g_dwDirectSoundTestPhysicalMemoryRecovered
  00172	52		 push	 edx
  00173	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@HBBPMJBE@Physical?5memory?5recovered?3?5?5?$CFlu?$AA@
  00178	e8 00 00 00 00	 call	 _DwDbgPrint
  0017d	83 c4 08	 add	 esp, 8

; 898  :     DwDbgPrint(pszBanner);

  00180	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pszBanner@?1??DirectSoundTestDumpMemoryUsage@@YGXH@Z@4QBDB
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 _DwDbgPrint
  0018b	83 c4 04	 add	 esp, 4

; 899  :     DwDbgPrint("End memory usage dump");

  0018e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@DICBIGIJ@End?5memory?5usage?5dump?$AA@
  00193	e8 00 00 00 00	 call	 _DwDbgPrint
  00198	83 c4 04	 add	 esp, 4

; 900  :     DwDbgPrint(pszBanner);

  0019b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??DirectSoundTestDumpMemoryUsage@@YGXH@Z@4QBDB
  001a1	51		 push	 ecx
  001a2	e8 00 00 00 00	 call	 _DwDbgPrint
  001a7	83 c4 04	 add	 esp, 4

; 901  : 
; 902  :     if(g_dwDirectSoundTestPoolMemoryUsage || g_dwDirectSoundTestPhysicalMemoryUsage || g_dwDirectSoundTestPhysicalMemorySlop || g_dwDirectSoundTestPhysicalMemoryRecovered)

  001aa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_dwDirectSoundTestPoolMemoryUsage@@3KA, 0 ; g_dwDirectSoundTestPoolMemoryUsage
  001b1	75 1b		 jne	 SHORT $L32258
  001b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_dwDirectSoundTestPhysicalMemoryUsage@@3KA, 0 ; g_dwDirectSoundTestPhysicalMemoryUsage
  001ba	75 12		 jne	 SHORT $L32258
  001bc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_dwDirectSoundTestPhysicalMemorySlop@@3KA, 0 ; g_dwDirectSoundTestPhysicalMemorySlop
  001c3	75 09		 jne	 SHORT $L32258
  001c5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_dwDirectSoundTestPhysicalMemoryRecovered@@3KA, 0 ; g_dwDirectSoundTestPhysicalMemoryRecovered
  001cc	74 30		 je	 SHORT $L32257
$L32258:

; 903  :     {
; 904  :         if(fAssertNone)

  001ce	83 7d 08 00	 cmp	 DWORD PTR _fAssertNone$[ebp], 0
  001d2	74 01		 je	 SHORT $L32259

; 905  :         {
; 906  :             __asm int 3

  001d4	cc		 int	 3
$L32259:

; 907  :         }
; 908  : 
; 909  : #ifdef TRACK_MEMORY_USAGE
; 910  : 
; 911  :         ASSERT(!IsListEmpty(&g_lstDirectSoundTestMemoryTracking));

  001d5	68 8f 03 00 00	 push	 911			; 0000038fH
  001da	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  001df	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DC@JOELGBPO@?$CBIsListEmpty?$CI?$CGg_lstDirectSoundTe@
  001e4	33 d2		 xor	 edx, edx
  001e6	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR ?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A, OFFSET FLAT:?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A ; g_lstDirectSoundTestMemoryTracking
  001f0	0f 94 c2	 sete	 dl
  001f3	52		 push	 edx
  001f4	e8 00 00 00 00	 call	 _DwDbgAssert
  001f9	83 c4 10	 add	 esp, 16			; 00000010H

; 912  : 
; 913  : #endif // TRACK_MEMORY_USAGE
; 914  : 
; 915  :     }
; 916  : 
; 917  : #ifdef TRACK_MEMORY_USAGE
; 918  : 
; 919  :     else

  001fc	eb 27		 jmp	 SHORT $L32261
$L32257:

; 920  :     {
; 921  :         ASSERT(IsListEmpty(&g_lstDirectSoundTestMemoryTracking));

  001fe	68 99 03 00 00	 push	 921			; 00000399H
  00203	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OCBNKPBC@c?3?2xbox?2private?2windows?2directx?2@
  00208	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@LDBGAFO@IsListEmpty?$CI?$CGg_lstDirectSoundTes@
  0020d	33 c0		 xor	 eax, eax
  0020f	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR ?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A, OFFSET FLAT:?g_lstDirectSoundTestMemoryTracking@@3U_LIST_ENTRY@@A ; g_lstDirectSoundTestMemoryTracking
  00219	0f 95 c0	 setne	 al
  0021c	50		 push	 eax
  0021d	e8 00 00 00 00	 call	 _DwDbgAssert
  00222	83 c4 10	 add	 esp, 16			; 00000010H
$L32261:

; 922  :     }
; 923  : 
; 924  : #endif // TRACK_MEMORY_USAGE
; 925  : 
; 926  : #endif // DEBUG
; 927  : 
; 928  : }

  00225	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00228	e8 00 00 00 00	 call	 ??1CAutoIrql@@QAE@XZ	; CAutoIrql::~CAutoIrql
  0022d	8b e5		 mov	 esp, ebp
  0022f	5d		 pop	 ebp
  00230	c2 04 00	 ret	 4
?DirectSoundTestDumpMemoryUsage@@YGXH@Z ENDP		; DirectSoundTestDumpMemoryUsage
DSOUND	ENDS
END
