; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\msaudiodec.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
WMADEC_RW	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RW	ENDS
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT @ByteSwap@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmBitsLeft@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmSetGetMoreData@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmSetUserData@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmSetOwner@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmGetPacketHeader@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmSetPacketHeader@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmFlush@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _audecDelete_XDS@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _audecFlush_XDS@32
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _audecNew_XDS@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _audecInit_XDS@48
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auInitPcInfoDEC@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _audecReset_XDS@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvOutputBufferSize@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _audecOutputBufferSize_XDS@20
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _audecDecode_XDS@44
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvDecodePacket_XDS@44
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _audecDecodeInfo_XDS@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _audecDecodeData_XDS@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _audecGetPCM_XDS@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvDecodeSubFrame_XDS@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvUpdateSubFrameConfig_XDS@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvDecodeSubFrameHighRate_XDS@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvWMAGetMoreData_XDS@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, WMADEC_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_g_cBitGet
PUBLIC	_DSoundBuildNumberD
WMADEC_RD	SEGMENT
_WMA_OK	DD	00H
_WMA_S_FALSE DD	01H
_WMA_S_BUFUNDERFLOW DD 02H
_WMA_S_NEWPACKET DD 03H
_WMA_S_NO_MORE_FRAME DD 04H
_WMA_S_DEFAULT DD 05H
_WMA_S_SWITCHCHMODE DD 06H
_WMA_E_FAIL DD	080004005H
_WMA_E_OUTOFMEMORY DD 08007000eH
_WMA_E_INVALIDARG DD 080070057H
_WMA_E_NOTSUPPORTED DD 080040000H
_WMA_E_LOSTPACKET DD 080040001H
_WMA_E_BROKEN_FRAME DD 080040002H
_WMA_E_BUFFEROVERFLOW DD 080040003H
_WMA_E_ONHOLD DD 080040004H
_WMA_E_BUFFERUNDERFLOW DD 080040005H
_WMA_E_INVALIDRECHDR DD 080040006H
_WMA_E_SYNCERROR DD 080040007H
_WMA_E_NOTIMPL DD 080040008H
_WMA_E_FLUSHOVERFLOW DD 080040009H
WMADEC_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT
_DSoundBuildNumberD DW 05344H
	DW	0554fH
	DW	0444eH
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
WMADEC_RW	SEGMENT
_g_cBitGet DD	00H
_iSampleTotal DD 00H
WMADEC_RW	ENDS
PUBLIC	_audecDelete_XDS@4
EXTRN	_auMallocSetState_XDS@12:NEAR
EXTRN	_auFree_XDS@4:NEAR
EXTRN	_auDelete_XDS@4:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\msaudiodec.c
;	COMDAT _audecDelete_XDS@4
WMADEC	SEGMENT
_paudec$ = 8
_audecDelete_XDS@4 PROC NEAR				; COMDAT

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 103  :     auMallocSetState(MAS_DELETE, NULL, 0);

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	6a 02		 push	 2
  00009	e8 00 00 00 00	 call	 _auMallocSetState_XDS@12

; 104  : 
; 105  :     auDelete (paudec->pau);

  0000e	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 _auDelete_XDS@4

; 106  :     paudec->pau = NULL;

  00019	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0001c	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 107  : 
; 108  :     auFree(paudec);

  00022	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _auFree_XDS@4

; 109  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
_audecDelete_XDS@4 ENDP
WMADEC	ENDS
PUBLIC	_audecReset_XDS@4
PUBLIC	_audecFlush_XDS@32
PUBLIC	_prvDecodePacket_XDS@44
PUBLIC	??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@ ; `string'
EXTRN	_ibstrmPeekBitsNonStop@12:NEAR
EXTRN	_MyOutputDbgStr:NEAR
;	COMDAT ??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
WMADEC_RD	SEGMENT
??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\wmalib\wmadec_s\msaudiode'
	DB	'c.c', 00H					; `string'
WMADEC_RD	ENDS
;	COMDAT ??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
WMADEC_RD	SEGMENT
??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@ DB '%'
	DB	's(%d) : *** TRACE *** code = 0x%x!', 0aH, 00H ; `string'
; Function compile flags: /Odt
WMADEC_RD	ENDS
;	COMDAT _audecFlush_XDS@32
WMADEC	SEGMENT
tv129 = -16
_hr$ = -12
_cbSrcUsed$ = -8
_cSamplesPrevPacket$ = -4
_paudec$ = 8
_pbDst$ = 12
_cbDstLength$ = 16
_pcbDstUsed$ = 20
_pbEqu$ = 24
_cbEquLength$ = 28
_pcbEquUsed$ = 32
_pcSamplesFromBefore$ = 36
_audecFlush_XDS@32 PROC NEAR				; COMDAT

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 129  :     WMARESULT hr = WMA_OK;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000b	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 130  :     Int     cbSrcUsed;
; 131  :     U32     cSamplesPrevPacket = 0;

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cSamplesPrevPacket$[ebp], 0

; 132  : 
; 133  :     assert (pbDst != NULL);
; 134  :     assert (pcbDstUsed != NULL);
; 135  : 
; 136  : #if !defined(_Embedded_x86)
; 137  : #if defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE))
; 138  :     // This function may use the FFT. Therefore, on every call to this function,
; 139  :     // we must check if the current thread has been initialized to use the Intel FFT.
; 140  :     // This is because under the DMO, the thread which decoded may not be the
; 141  :     // thread that does the flushing.
; 142  :     if (paudec->pau->m_fIntelFFT)
; 143  :         auInitIntelFFT(paudec->pau, INTELFFT_INIT_THREAD);
; 144  : #endif // defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE))
; 145  : #endif
; 146  : 
; 147  :     if (pcSamplesFromBefore != NULL)

  00015	83 7d 24 00	 cmp	 DWORD PTR _pcSamplesFromBefore$[ebp], 0
  00019	74 08		 je	 SHORT $L2885

; 148  :         *pcSamplesFromBefore = cSamplesPrevPacket;

  0001b	8b 4d 24	 mov	 ecx, DWORD PTR _pcSamplesFromBefore$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _cSamplesPrevPacket$[ebp]
  00021	89 11		 mov	 DWORD PTR [ecx], edx
$L2885:

; 149  :     if (pcbDstUsed != NULL)

  00023	83 7d 14 00	 cmp	 DWORD PTR _pcbDstUsed$[ebp], 0
  00027	74 09		 je	 SHORT $L2887

; 150  :         *pcbDstUsed = 0;

  00029	8b 45 14	 mov	 eax, DWORD PTR _pcbDstUsed$[ebp]
  0002c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L2887:

; 151  :     if (pcbEquUsed != NULL)

  00032	83 7d 20 00	 cmp	 DWORD PTR _pcbEquUsed$[ebp], 0
  00036	74 09		 je	 SHORT $L2889

; 152  :         *pcbEquUsed = 0;

  00038	8b 4d 20	 mov	 ecx, DWORD PTR _pcbEquUsed$[ebp]
  0003b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L2889:

; 153  : 
; 154  :     paudec->m_ibstrm.ibstrmpfnPeekBits = ibstrmPeekBitsNonStop;

  00041	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00044	c7 82 64 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+356], OFFSET FLAT:_ibstrmPeekBitsNonStop@12

; 155  : 
; 156  :     if (paudec->pau->m_fAllowSuperFrame) {

  0004e	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	83 79 64 00	 cmp	 DWORD PTR [ecx+100], 0
  00057	0f 84 b9 00 00
	00		 je	 $L2890

; 157  :         if (!paudec->m_fPacketLoss && 0 != paudec->m_cFrmInPacket)  

  0005d	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00060	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00064	0f 85 aa 00 00
	00		 jne	 $L2891
  0006a	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0006d	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00071	85 c9		 test	 ecx, ecx
  00073	0f 84 9b 00 00
	00		 je	 $L2891

; 158  :         {
; 159  :             hr = prvDecodePacket (paudec, 
; 160  :                                   NULL,
; 161  :                                   0,
; 162  :                                   &cbSrcUsed,
; 163  :                                   pbDst,
; 164  :                                   cbDstLength,
; 165  :                                   pcbDstUsed,
; 166  :                                   pbEqu,
; 167  :                                   cbEquLength,
; 168  :                                   pcbEquUsed,
; 169  :                                   (I32 *)&cSamplesPrevPacket);

  00079	8d 55 fc	 lea	 edx, DWORD PTR _cSamplesPrevPacket$[ebp]
  0007c	52		 push	 edx
  0007d	8b 45 20	 mov	 eax, DWORD PTR _pcbEquUsed$[ebp]
  00080	50		 push	 eax
  00081	8b 4d 1c	 mov	 ecx, DWORD PTR _cbEquLength$[ebp]
  00084	51		 push	 ecx
  00085	8b 55 18	 mov	 edx, DWORD PTR _pbEqu$[ebp]
  00088	52		 push	 edx
  00089	8b 45 14	 mov	 eax, DWORD PTR _pcbDstUsed$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d 10	 mov	 ecx, DWORD PTR _cbDstLength$[ebp]
  00090	51		 push	 ecx
  00091	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  00094	52		 push	 edx
  00095	8d 45 f8	 lea	 eax, DWORD PTR _cbSrcUsed$[ebp]
  00098	50		 push	 eax
  00099	6a 00		 push	 0
  0009b	6a 00		 push	 0
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _prvDecodePacket_XDS@44
  000a6	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 170  : 
; 171  :             if (pcSamplesFromBefore != NULL)

  000a9	83 7d 24 00	 cmp	 DWORD PTR _pcSamplesFromBefore$[ebp], 0
  000ad	74 08		 je	 SHORT $L2895

; 172  :                 *pcSamplesFromBefore = cSamplesPrevPacket;

  000af	8b 55 24	 mov	 edx, DWORD PTR _pcSamplesFromBefore$[ebp]
  000b2	8b 45 fc	 mov	 eax, DWORD PTR _cSamplesPrevPacket$[ebp]
  000b5	89 02		 mov	 DWORD PTR [edx], eax
$L2895:

; 173  : 
; 174  :             assert (*pcbDstUsed <= cbDstLength);
; 175  :             if (*pcbDstUsed > cbDstLength)

  000b7	8b 4d 14	 mov	 ecx, DWORD PTR _pcbDstUsed$[ebp]
  000ba	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bc	3b 55 10	 cmp	 edx, DWORD PTR _cbDstLength$[ebp]
  000bf	7e 53		 jle	 SHORT $L2891

; 176  :                 hr = TraceResult(WMA_E_BUFFEROVERFLOW);

  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BUFFEROVERFLOW
  000c6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  000cc	74 37		 je	 SHORT $L3515
  000ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BUFFEROVERFLOW
  000d4	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  000da	74 29		 je	 SHORT $L3515
  000dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BUFFEROVERFLOW
  000e2	52		 push	 edx
  000e3	68 b0 00 00 00	 push	 176			; 000000b0H
  000e8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  000ed	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  000f2	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BUFFEROVERFLOW
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 _MyOutputDbgStr
  000fd	83 c4 14	 add	 esp, 20			; 00000014H
  00100	89 45 f0	 mov	 DWORD PTR tv129[ebp], eax
  00103	eb 09		 jmp	 SHORT $L3516
$L3515:
  00105	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BUFFEROVERFLOW
  0010b	89 4d f0	 mov	 DWORD PTR tv129[ebp], ecx
$L3516:
  0010e	8b 55 f0	 mov	 edx, DWORD PTR tv129[ebp]
  00111	89 55 f4	 mov	 DWORD PTR _hr$[ebp], edx
$L2891:

; 177  :         }
; 178  :     }
; 179  :     else                //don't do anything

  00114	eb 09		 jmp	 SHORT $L2899
$L2890:

; 180  :         *pcbDstUsed = 0;

  00116	8b 45 14	 mov	 eax, DWORD PTR _pcbDstUsed$[ebp]
  00119	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L2899:

; 181  : 
; 182  :     audecReset(paudec);

  0011f	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 _audecReset_XDS@4

; 183  : 
; 184  :     return hr;

  00128	8b 45 f4	 mov	 eax, DWORD PTR _hr$[ebp]

; 185  : } // audecFlush

  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c2 20 00	 ret	 32			; 00000020H
_audecFlush_XDS@32 ENDP
WMADEC	ENDS
PUBLIC	_audecNew_XDS@8
EXTRN	_memset:NEAR
EXTRN	_auMalloc_XDS@4:NEAR
; Function compile flags: /Odt
;	COMDAT _audecNew_XDS@8
WMADEC	SEGMENT
tv78 = -8
_paudec$ = -4
_pMemBuf$ = 8
_iMemBufSize$ = 12
_audecNew_XDS@8 PROC NEAR				; COMDAT

; 195  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 196  :     CAudioObjectDecoder* paudec;
; 197  : 
; 198  :     auMallocSetState(MAS_ALLOCATE, pMemBuf, iMemBufSize);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _iMemBufSize$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pMemBuf$[ebp]
  0000d	51		 push	 ecx
  0000e	6a 00		 push	 0
  00010	e8 00 00 00 00	 call	 _auMallocSetState_XDS@12

; 199  :     paudec = (CAudioObjectDecoder*) auMalloc (sizeof (CAudioObjectDecoder));

  00015	68 a0 01 00 00	 push	 416			; 000001a0H
  0001a	e8 00 00 00 00	 call	 _auMalloc_XDS@4
  0001f	89 45 fc	 mov	 DWORD PTR _paudec$[ebp], eax

; 200  :     if(paudec == NULL)

  00022	83 7d fc 00	 cmp	 DWORD PTR _paudec$[ebp], 0
  00026	75 55		 jne	 SHORT $L2909

; 201  :     {
; 202  :         TraceResult(WMA_E_OUTOFMEMORY);

  00028	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  0002e	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  00034	74 37		 je	 SHORT $L3520
  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  0003b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00041	74 2a		 je	 SHORT $L3520
  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  00049	51		 push	 ecx
  0004a	68 ca 00 00 00	 push	 202			; 000000caH
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00054	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00065	83 c4 14	 add	 esp, 20			; 00000014H
  00068	89 45 f8	 mov	 DWORD PTR tv78[ebp], eax
  0006b	eb 08		 jmp	 SHORT $L3521
$L3520:
  0006d	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  00072	89 45 f8	 mov	 DWORD PTR tv78[ebp], eax
$L3521:

; 203  :         return paudec;

  00075	8b 45 fc	 mov	 eax, DWORD PTR _paudec$[ebp]
  00078	e9 4c 01 00 00	 jmp	 $L2904
$L2909:

; 204  :     }
; 205  : 
; 206  :     paudec->pau = NULL;

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00080	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 207  :     paudec->m_fPacketLoss = WMAB_FALSE;

  00086	8b 55 fc	 mov	 edx, DWORD PTR _paudec$[ebp]
  00089	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 208  :     paudec->m_cFrmInPacket = 0;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _paudec$[ebp]
  00093	66 c7 40 08 00
	00		 mov	 WORD PTR [eax+8], 0

; 209  :     paudec->m_pbSrcCurr = NULL;

  00099	8b 4d fc	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0009c	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 210  :     paudec->m_cbSrcCurrLength = 0; 

  000a3	8b 55 fc	 mov	 edx, DWORD PTR _paudec$[ebp]
  000a6	66 c7 42 10 00
	00		 mov	 WORD PTR [edx+16], 0

; 211  :     paudec->m_decsts = BEGIN_PACKET;

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _paudec$[ebp]
  000af	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 212  :     paudec->m_subfrmdecsts = SUBFRM_HDR;

  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _paudec$[ebp]
  000b9	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 213  :     paudec->m_hdrdecsts = HDR_SIZE;

  000c0	8b 55 fc	 mov	 edx, DWORD PTR _paudec$[ebp]
  000c3	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 214  :     paudec->m_rlsts = VLC;

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _paudec$[ebp]
  000cd	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 215  :     paudec->m_iChannel = 0;

  000d4	8b 4d fc	 mov	 ecx, DWORD PTR _paudec$[ebp]
  000d7	66 c7 41 24 00
	00		 mov	 WORD PTR [ecx+36], 0

; 216  :     paudec->m_iBand = 0;

  000dd	8b 55 fc	 mov	 edx, DWORD PTR _paudec$[ebp]
  000e0	66 c7 42 26 00
	00		 mov	 WORD PTR [edx+38], 0

; 217  :     paudec->m_fNoMoreData = WMAB_FALSE;

  000e6	8b 45 fc	 mov	 eax, DWORD PTR _paudec$[ebp]
  000e9	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 218  :     paudec->m_fLastSubFrame = WMAB_TRUE;

  000f0	8b 4d fc	 mov	 ecx, DWORD PTR _paudec$[ebp]
  000f3	c7 41 2c 01 00
	00 00		 mov	 DWORD PTR [ecx+44], 1

; 219  :     memset(&paudec->m_ibstrm, 0, sizeof(paudec->m_ibstrm));

  000fa	68 38 01 00 00	 push	 312			; 00000138H
  000ff	6a 00		 push	 0
  00101	8b 55 fc	 mov	 edx, DWORD PTR _paudec$[ebp]
  00104	83 c2 30	 add	 edx, 48			; 00000030H
  00107	52		 push	 edx
  00108	e8 00 00 00 00	 call	 _memset
  0010d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 220  :     paudec->m_rgiRunEntry44ssQb = NULL;

  00110	8b 45 fc	 mov	 eax, DWORD PTR _paudec$[ebp]
  00113	c7 80 68 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+360], 0

; 221  :     paudec->m_rgiLevelEntry44ssQb = NULL;

  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00120	c7 81 6c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+364], 0

; 222  :     paudec->m_rgiRunEntry44smQb = NULL;

  0012a	8b 55 fc	 mov	 edx, DWORD PTR _paudec$[ebp]
  0012d	c7 82 70 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+368], 0

; 223  :     paudec->m_rgiLevelEntry44smQb = NULL;

  00137	8b 45 fc	 mov	 eax, DWORD PTR _paudec$[ebp]
  0013a	c7 80 74 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+372], 0

; 224  :     paudec->m_rgiRunEntry44ssOb = NULL;

  00144	8b 4d fc	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00147	c7 81 78 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+376], 0

; 225  :     paudec->m_rgiLevelEntry44ssOb = NULL;

  00151	8b 55 fc	 mov	 edx, DWORD PTR _paudec$[ebp]
  00154	c7 82 7c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+380], 0

; 226  :     paudec->m_rgiRunEntry44smOb = NULL;

  0015e	8b 45 fc	 mov	 eax, DWORD PTR _paudec$[ebp]
  00161	c7 80 80 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+384], 0

; 227  :     paudec->m_rgiLevelEntry44smOb = NULL;

  0016b	8b 4d fc	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0016e	c7 81 84 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+388], 0

; 228  :     paudec->m_rgiRunEntry16ssOb = NULL;

  00178	8b 55 fc	 mov	 edx, DWORD PTR _paudec$[ebp]
  0017b	c7 82 88 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+392], 0

; 229  :     paudec->m_rgiLevelEntry16ssOb = NULL;

  00185	8b 45 fc	 mov	 eax, DWORD PTR _paudec$[ebp]
  00188	c7 80 8c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+396], 0

; 230  :     paudec->m_rgiRunEntry16smOb = NULL;

  00192	8b 4d fc	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00195	c7 81 90 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+400], 0

; 231  :     paudec->m_rgiLevelEntry16smOb = NULL;

  0019f	8b 55 fc	 mov	 edx, DWORD PTR _paudec$[ebp]
  001a2	c7 82 94 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+404], 0

; 232  : #if defined(UNDER_CE) && defined(_ARM_)
; 233  :     paudec->lPrivate1 = 0;
; 234  :     paudec->lPrivate2 = 0;
; 235  : #endif //defined(UNDER_CE) && defined(_ARM_)
; 236  : #ifdef ENABLE_EQUALIZER
; 237  :     memset(&paudec->m_rgfltEqBandWeight, 0, sizeof(paudec->m_rgfltEqBandWeight));
; 238  :     memset(&paudec->m_rgwEqBandBoundary, 0, sizeof(paudec->m_rgwEqBandBoundary));
; 239  :     paudec->m_cEqBand = 0;
; 240  :     paudec->m_fNoEq = WMAB_TRUE; 
; 241  :     memset(&paudec->m_rgbBandPower, 0, sizeof(paudec->m_rgbBandPower));
; 242  :     paudec->m_fComputeBandPower = WMAB_FALSE;
; 243  :     paudec->m_iEqFrameSize = 0;
; 244  : #endif // ENABLE_EQUALIZER
; 245  :     paudec->m_pfnDecodeSubFrame = NULL;

  001ac	8b 45 fc	 mov	 eax, DWORD PTR _paudec$[ebp]
  001af	c7 80 98 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+408], 0

; 246  :     paudec->m_pfnDecodeCoefficient = NULL;

  001b9	8b 4d fc	 mov	 ecx, DWORD PTR _paudec$[ebp]
  001bc	c7 81 9c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+412], 0

; 247  :     
; 248  :     return paudec;

  001c6	8b 45 fc	 mov	 eax, DWORD PTR _paudec$[ebp]
$L2904:

; 249  : }

  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c2 08 00	 ret	 8
_audecNew_XDS@8 ENDP
WMADEC	ENDS
PUBLIC	_ibstrmSetGetMoreData@8
PUBLIC	_ibstrmSetUserData@8
PUBLIC	_ibstrmSetOwner@8
PUBLIC	_audecInit_XDS@48
PUBLIC	_prvWMAGetMoreData_XDS@16
PUBLIC	_prvDecodeSubFrame_XDS@8
PUBLIC	_prvDecodeSubFrameHighRate_XDS@8
PUBLIC	_auInitPcInfoDEC@4
EXTRN	_auInit_XDS@36:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_auMallocGetCount_XDS@0:NEAR
EXTRN	_ibstrmInit@8:NEAR
EXTRN	_ibstrmPeekBits@12:NEAR
EXTRN	__fltused:NEAR
EXTRN	_g_rgiHuffDecTbl16smOb:BYTE
EXTRN	_gRun16smOb:BYTE
EXTRN	_gLevel16smOb:BYTE
EXTRN	_prvGetNextRunDEC_XDS@12:NEAR
EXTRN	_prvDecodeCoefficientMono_XDS@12:NEAR
EXTRN	_g_rgiHuffDecTbl44smOb:BYTE
EXTRN	_gRun44smOb:BYTE
EXTRN	_prvDecodeCoefficientStereo_XDS@12:NEAR
EXTRN	_gLevel44smOb:BYTE
EXTRN	_g_rgiHuffDecTbl44smQb:BYTE
EXTRN	_gRun44smQb:BYTE
EXTRN	_gLevel44smQb:BYTE
EXTRN	_msaudioGetSamplePerFrame_XDS@16:NEAR
EXTRN	_auNew_XDS@0:NEAR
; Function compile flags: /Odt
;	COMDAT _audecInit_XDS@48
WMADEC	SEGMENT
tv183 = -20
tv95 = -16
_pau$ = -12
_wmaResult$ = -8
_fltBitsPerSample$ = -4
_paudec$ = 8
_iVersionNumber$ = 12
_cSubband$ = 16
_iSamplingRate$ = 20
_cChannel$ = 24
_cBytePerSec$ = 28
_cbPacketLength$ = 32
_wEncodeOpt$ = 36
_wPlayerOpt$ = 40
_pfnGetMoreData$ = 44
_dwUserData$ = 48
_piMemUsed$ = 52
_audecInit_XDS@48 PROC NEAR				; COMDAT

; 270  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 271  :     Float fltBitsPerSample = 0.0F;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fltBitsPerSample$[ebp], 0

; 272  :     CAudioObject* pau = paudec->pau;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	89 4d f4	 mov	 DWORD PTR _pau$[ebp], ecx

; 273  :     WMARESULT   wmaResult = WMA_OK;

  00015	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_OK
  0001b	89 55 f8	 mov	 DWORD PTR _wmaResult$[ebp], edx

; 274  : 
; 275  :     if (pau == NULL)

  0001e	83 7d f4 00	 cmp	 DWORD PTR _pau$[ebp], 0
  00022	75 10		 jne	 SHORT $L2955

; 276  :         paudec->pau = pau = auNew ();

  00024	e8 00 00 00 00	 call	 _auNew_XDS@0
  00029	89 45 f4	 mov	 DWORD PTR _pau$[ebp], eax
  0002c	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0002f	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  00032	89 08		 mov	 DWORD PTR [eax], ecx
$L2955:

; 277  : 
; 278  :     // Fill in function ptrs with decoder fns
; 279  :     pau->aupfnGetNextRun = prvGetNextRunDEC;

  00034	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00037	c7 82 f4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1012], OFFSET FLAT:_prvGetNextRunDEC_XDS@12

; 280  : 
; 281  :     if (pau->m_codecStatus == CODEC_BEGIN)

  00041	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00044	83 78 48 03	 cmp	 DWORD PTR [eax+72], 3
  00048	75 05		 jne	 SHORT $L2956

; 282  :         goto exit;

  0004a	e9 3e 03 00 00	 jmp	 $exit$2957
$L2956:

; 283  : 
; 284  :     //wchen: in the future we should use the one directly from the bitstream.
; 285  :     //but for now the one in the bistream doesn't represent Sample/Frame
; 286  :     //instead it represents Sample/Raw Packet that is useless for the decoder
; 287  :     //other than serving the stupidity in the V4RTM decoder. We can't change the format for now.
; 288  :     //but it should be changed to reprsent Sample/Frame and that should nullify the following function call.
; 289  :     cSubband = msaudioGetSamplePerFrame (iSamplingRate, cBytePerSec * 8, cChannel, iVersionNumber);

  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _iVersionNumber$[ebp]
  00052	51		 push	 ecx
  00053	0f b7 55 18	 movzx	 edx, WORD PTR _cChannel$[ebp]
  00057	52		 push	 edx
  00058	8b 45 1c	 mov	 eax, DWORD PTR _cBytePerSec$[ebp]
  0005b	c1 e0 03	 shl	 eax, 3
  0005e	50		 push	 eax
  0005f	8b 4d 14	 mov	 ecx, DWORD PTR _iSamplingRate$[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _msaudioGetSamplePerFrame_XDS@16
  00068	89 45 10	 mov	 DWORD PTR _cSubband$[ebp], eax

; 290  :     TRACEWMA_EXIT(wmaResult, auInit (pau, iVersionNumber, cSubband, iSamplingRate, 
; 291  :         cChannel, cBytePerSec, cbPacketLength, wEncodeOpt, wPlayerOpt));

  0006b	66 8b 55 28	 mov	 dx, WORD PTR _wPlayerOpt$[ebp]
  0006f	52		 push	 edx
  00070	66 8b 45 24	 mov	 ax, WORD PTR _wEncodeOpt$[ebp]
  00074	50		 push	 eax
  00075	8b 4d 20	 mov	 ecx, DWORD PTR _cbPacketLength$[ebp]
  00078	51		 push	 ecx
  00079	8b 55 1c	 mov	 edx, DWORD PTR _cBytePerSec$[ebp]
  0007c	52		 push	 edx
  0007d	66 8b 45 18	 mov	 ax, WORD PTR _cChannel$[ebp]
  00081	50		 push	 eax
  00082	8b 4d 14	 mov	 ecx, DWORD PTR _iSamplingRate$[ebp]
  00085	51		 push	 ecx
  00086	8b 55 10	 mov	 edx, DWORD PTR _cSubband$[ebp]
  00089	52		 push	 edx
  0008a	8b 45 0c	 mov	 eax, DWORD PTR _iVersionNumber$[ebp]
  0008d	50		 push	 eax
  0008e	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 _auInit_XDS@36
  00097	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0009a	83 7d f8 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  0009e	7d 45		 jge	 SHORT $L2960
  000a0	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000a3	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  000a9	74 2f		 je	 SHORT $L3525
  000ab	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000ae	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  000b4	74 24		 je	 SHORT $L3525
  000b6	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000b9	51		 push	 ecx
  000ba	68 23 01 00 00	 push	 291			; 00000123H
  000bf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  000c4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  000c9	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 _MyOutputDbgStr
  000d2	83 c4 14	 add	 esp, 20			; 00000014H
  000d5	89 45 f0	 mov	 DWORD PTR tv95[ebp], eax
  000d8	eb 06		 jmp	 SHORT $L3526
$L3525:
  000da	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000dd	89 45 f0	 mov	 DWORD PTR tv95[ebp], eax
$L3526:
  000e0	e9 a8 02 00 00	 jmp	 $exit$2957
$L2960:

; 292  :     auInitPcInfoDEC (pau);

  000e5	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 _auInitPcInfoDEC@4

; 293  : 
; 294  :     if (cChannel == 1)

  000ee	0f b7 55 18	 movzx	 edx, WORD PTR _cChannel$[ebp]
  000f2	83 fa 01	 cmp	 edx, 1
  000f5	75 0f		 jne	 SHORT $L2961

; 295  :         paudec->m_pfnDecodeCoefficient = &prvDecodeCoefficientMono;

  000f7	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  000fa	c7 80 9c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+412], OFFSET FLAT:_prvDecodeCoefficientMono_XDS@12

; 296  :     else

  00104	eb 0d		 jmp	 SHORT $L2962
$L2961:

; 297  :         paudec->m_pfnDecodeCoefficient = &prvDecodeCoefficientStereo;

  00106	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00109	c7 81 9c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+412], OFFSET FLAT:_prvDecodeCoefficientStereo_XDS@12
$L2962:

; 298  : 
; 299  : #ifdef ENABLE_EQUALIZER
; 300  :     wmaResult = audecResetEqualizer(paudec);
; 301  :     TraceError(wmaResult);
; 302  : #endif //ENABLE_EQUALIZER
; 303  : 
; 304  :     ibstrmInit (&paudec->m_ibstrm, pau->m_fAllowSuperFrame);

  00113	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00116	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00119	50		 push	 eax
  0011a	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0011d	83 c1 30	 add	 ecx, 48			; 00000030H
  00120	51		 push	 ecx
  00121	e8 00 00 00 00	 call	 _ibstrmInit@8

; 305  :     ibstrmSetOwner (&paudec->m_ibstrm, (U32)paudec); 

  00126	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00129	52		 push	 edx
  0012a	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0012d	83 c0 30	 add	 eax, 48			; 00000030H
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 _ibstrmSetOwner@8

; 306  : 
; 307  :     if (NULL == pfnGetMoreData)

  00136	83 7d 2c 00	 cmp	 DWORD PTR _pfnGetMoreData$[ebp], 0
  0013a	75 0d		 jne	 SHORT $L2965

; 308  :     {
; 309  :         // Set us up for non-streaming mode
; 310  :         assert(0 == dwUserData); // We ignore user-supplied data in non-streaming mode
; 311  :         pfnGetMoreData = prvWMAGetMoreData;

  0013c	c7 45 2c 00 00
	00 00		 mov	 DWORD PTR _pfnGetMoreData$[ebp], OFFSET FLAT:_prvWMAGetMoreData_XDS@16

; 312  :         dwUserData = (U32)paudec;

  00143	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00146	89 4d 30	 mov	 DWORD PTR _dwUserData$[ebp], ecx
$L2965:

; 313  :     }
; 314  : 
; 315  :     ibstrmSetGetMoreData (&paudec->m_ibstrm, pfnGetMoreData);

  00149	8b 55 2c	 mov	 edx, DWORD PTR _pfnGetMoreData$[ebp]
  0014c	52		 push	 edx
  0014d	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00150	83 c0 30	 add	 eax, 48			; 00000030H
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _ibstrmSetGetMoreData@8

; 316  :     ibstrmSetUserData (&paudec->m_ibstrm, (U32)dwUserData); //need to change for real streaming mode

  00159	8b 4d 30	 mov	 ecx, DWORD PTR _dwUserData$[ebp]
  0015c	51		 push	 ecx
  0015d	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00160	83 c2 30	 add	 edx, 48			; 00000030H
  00163	52		 push	 edx
  00164	e8 00 00 00 00	 call	 _ibstrmSetUserData@8

; 317  : 
; 318  :     if (pau->m_fAllowSuperFrame)

  00169	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  0016c	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  00170	74 0f		 je	 SHORT $L2968

; 319  :         paudec->m_ibstrm.ibstrmpfnPeekBits = ibstrmPeekBits;

  00172	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00175	c7 81 64 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+356], OFFSET FLAT:_ibstrmPeekBits@12

; 320  :     else

  0017f	eb 0d		 jmp	 SHORT $L2969
$L2968:

; 321  :         paudec->m_ibstrm.ibstrmpfnPeekBits = ibstrmPeekBitsNonStop;

  00181	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00184	c7 82 64 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+356], OFFSET FLAT:_ibstrmPeekBitsNonStop@12
$L2969:

; 322  : 
; 323  :     if (pau->m_iEntropyMode == SIXTEENS_OB)   {

  0018e	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00191	83 b8 3c 03 00
	00 03		 cmp	 DWORD PTR [eax+828], 3
  00198	75 35		 jne	 SHORT $L2970

; 324  :         pau->m_rgpcinfo [0].m_rgiHuffDecTbl = g_rgiHuffDecTbl16smOb;

  0019a	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  0019d	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  001a3	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET FLAT:_g_rgiHuffDecTbl16smOb

; 325  :         pau->m_rgpcinfo [0].m_rgiRunEntry   = gRun16smOb;

  001aa	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  001ad	8b 88 a0 03 00
	00		 mov	 ecx, DWORD PTR [eax+928]
  001b3	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET FLAT:_gRun16smOb

; 326  :         pau->m_rgpcinfo [0].m_rgiLevelEntry = gLevel16smOb;

  001ba	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  001bd	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  001c3	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET FLAT:_gLevel16smOb

; 327  :     }
; 328  : #ifdef ENABLE_ALL_ENCOPT
; 329  :     else if (pau->m_iEntropyMode == FOURTYFOURS_QB)   {

  001ca	e9 d7 00 00 00	 jmp	 $L2971
$L2970:
  001cf	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  001d2	83 b9 3c 03 00
	00 01		 cmp	 DWORD PTR [ecx+828], 1
  001d9	75 35		 jne	 SHORT $L2972

; 330  :         pau->m_rgpcinfo [0].m_rgiHuffDecTbl = g_rgiHuffDecTbl44smQb; 

  001db	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  001de	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  001e4	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET FLAT:_g_rgiHuffDecTbl44smQb

; 331  :         pau->m_rgpcinfo [0].m_rgiRunEntry   = gRun44smQb; 

  001eb	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  001ee	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  001f4	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET FLAT:_gRun44smQb

; 332  :         pau->m_rgpcinfo [0].m_rgiLevelEntry = gLevel44smQb;

  001fb	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  001fe	8b 88 a0 03 00
	00		 mov	 ecx, DWORD PTR [eax+928]
  00204	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], OFFSET FLAT:_gLevel44smQb

; 333  :     }
; 334  :     else if (pau->m_iEntropyMode == FOURTYFOURS_OB)   {

  0020b	e9 96 00 00 00	 jmp	 $L2971
$L2972:
  00210	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00213	83 ba 3c 03 00
	00 02		 cmp	 DWORD PTR [edx+828], 2
  0021a	75 32		 jne	 SHORT $L2974

; 335  :         pau->m_rgpcinfo [0].m_rgiHuffDecTbl = g_rgiHuffDecTbl44smOb; 

  0021c	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  0021f	8b 88 a0 03 00
	00		 mov	 ecx, DWORD PTR [eax+928]
  00225	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET FLAT:_g_rgiHuffDecTbl44smOb

; 336  :         pau->m_rgpcinfo [0].m_rgiRunEntry   = gRun44smOb; 

  0022c	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  0022f	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  00235	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET FLAT:_gRun44smOb

; 337  :         pau->m_rgpcinfo [0].m_rgiLevelEntry = gLevel44smOb;

  0023c	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  0023f	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  00245	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], OFFSET FLAT:_gLevel44smOb

; 338  :     }
; 339  : #endif // ENABLE_ALL_ENCOPT
; 340  :     else {

  0024c	eb 58		 jmp	 SHORT $L2971
$L2974:

; 341  :         assert (WMAB_FALSE);
; 342  :         wmaResult = TraceResult(WMA_E_INVALIDARG);

  0024e	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  00253	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00259	74 37		 je	 SHORT $L3527
  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_INVALIDARG
  00261	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  00267	74 29		 je	 SHORT $L3527
  00269	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_INVALIDARG
  0026f	52		 push	 edx
  00270	68 56 01 00 00	 push	 342			; 00000156H
  00275	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  0027a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0027f	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  00284	50		 push	 eax
  00285	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0028a	83 c4 14	 add	 esp, 20			; 00000014H
  0028d	89 45 ec	 mov	 DWORD PTR tv183[ebp], eax
  00290	eb 09		 jmp	 SHORT $L3528
$L3527:
  00292	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_INVALIDARG
  00298	89 4d ec	 mov	 DWORD PTR tv183[ebp], ecx
$L3528:
  0029b	8b 55 ec	 mov	 edx, DWORD PTR tv183[ebp]
  0029e	89 55 f8	 mov	 DWORD PTR _wmaResult$[ebp], edx

; 343  :         goto exit;

  002a1	e9 e7 00 00 00	 jmp	 $exit$2957
$L2971:

; 344  :     }
; 345  : 
; 346  :     //init subfrm configration
; 347  :     pau->m_subfrmconfigPrev.m_cSubFrame = 1;

  002a6	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  002a9	c7 80 a4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+164], 1

; 348  :     pau->m_subfrmconfigPrev.m_rgiSubFrameSize [0]  = pau->m_cFrameSampleHalf;

  002b3	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  002b6	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  002b9	8b 82 1c 03 00
	00		 mov	 eax, DWORD PTR [edx+796]
  002bf	89 81 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], eax

; 349  :     pau->m_subfrmconfigPrev.m_rgiSubFrameStart [0] = 0;

  002c5	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  002c8	c7 81 e8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+232], 0

; 350  :     pau->m_subfrmconfigPrev.m_iFirstTransientSubFrm = -1;

  002d2	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  002d5	c7 82 28 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+296], -1

; 351  :     pau->m_subfrmconfigPrev.m_iLastTransientSubFrm  = -1;

  002df	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  002e2	c7 80 2c 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+300], -1

; 352  :     memcpy (&pau->m_subfrmconfigCurr, &pau->m_subfrmconfigPrev, sizeof (SubFrameConfigInfo));

  002ec	68 d0 00 00 00	 push	 208			; 000000d0H
  002f1	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  002f4	81 c1 a4 00 00
	00		 add	 ecx, 164		; 000000a4H
  002fa	51		 push	 ecx
  002fb	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  002fe	81 c2 74 01 00
	00		 add	 edx, 372		; 00000174H
  00304	52		 push	 edx
  00305	e8 00 00 00 00	 call	 _memcpy
  0030a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 353  :     memcpy (&pau->m_subfrmconfigNext, &pau->m_subfrmconfigPrev, sizeof (SubFrameConfigInfo));

  0030d	68 d0 00 00 00	 push	 208			; 000000d0H
  00312	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00315	05 a4 00 00 00	 add	 eax, 164		; 000000a4H
  0031a	50		 push	 eax
  0031b	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  0031e	81 c1 44 02 00
	00		 add	 ecx, 580		; 00000244H
  00324	51		 push	 ecx
  00325	e8 00 00 00 00	 call	 _memcpy
  0032a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 354  : 
; 355  :     pau->m_codecStatus = CODEC_BEGIN;

  0032d	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00330	c7 42 48 03 00
	00 00		 mov	 DWORD PTR [edx+72], 3

; 356  :     pau->m_iPacketCurr = -2;                // force a Packet Loss to begin

  00337	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  0033a	c7 40 04 fe ff
	ff ff		 mov	 DWORD PTR [eax+4], -2	; fffffffeH

; 357  : 
; 358  : #if 0
; 359  :     {   Int i;
; 360  :         // Initialize quant step table
; 361  :         for (i = 0; i < ARRAY_SIZE(paudec->m_rgiQuantStepFract); i++)
; 362  :         {
; 363  :             paudec->m_rgiQuantStepFract[i] = (UInt)(pow(10, (Float)(i + 1) / QUANTSTEP_DENOMINATOR) *
; 364  :                 (1 << QUANTSTEP_FRACT_BITS));
; 365  :         }
; 366  :     }
; 367  : #endif  // 0
; 368  : 
; 369  :     if (pau->m_iWeightingMode == LPC_MODE || pau->m_fNoiseSub)

  00341	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  00344	83 b9 34 03 00
	00 00		 cmp	 DWORD PTR [ecx+820], 0
  0034b	74 09		 je	 SHORT $L2979
  0034d	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00350	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00354	74 0f		 je	 SHORT $L2978
$L2979:

; 370  :     {
; 371  :         //low rate or mid rate
; 372  :         paudec->m_pfnDecodeSubFrame = prvDecodeSubFrame;

  00356	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00359	c7 80 98 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+408], OFFSET FLAT:_prvDecodeSubFrame_XDS@8

; 373  :     }
; 374  :     else

  00363	eb 0d		 jmp	 SHORT $L2980
$L2978:

; 375  :     {
; 376  :         //high rate
; 377  :         paudec->m_pfnDecodeSubFrame = prvDecodeSubFrameHighRate;

  00365	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00368	c7 81 98 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+408], OFFSET FLAT:_prvDecodeSubFrameHighRate_XDS@8
$L2980:

; 378  :     }
; 379  : 
; 380  : #ifdef BITRATE_REPORT
; 381  :     printf("Fr#\tSubF#\tTime\tPCM\tSF Bits\tSF Bitr\tFr Bits\tFr Bitrate\n");
; 382  :     printf("---\t-----\t----\t---\t-------\t-------\t-------\t----------\n");
; 383  : #endif   // BITRATE_REPORT
; 384  : 
; 385  :     if (NULL != piMemUsed)

  00372	83 7d 34 00	 cmp	 DWORD PTR _piMemUsed$[ebp], 0
  00376	74 0a		 je	 SHORT $L2982

; 386  :         *piMemUsed = auMallocGetCount();

  00378	e8 00 00 00 00	 call	 _auMallocGetCount_XDS@0
  0037d	8b 55 34	 mov	 edx, DWORD PTR _piMemUsed$[ebp]
  00380	89 02		 mov	 DWORD PTR [edx], eax
$L2982:

; 387  : 
; 388  :     auMallocSetState(MAS_LOCKED, NULL, 0);

  00382	6a 00		 push	 0
  00384	6a 00		 push	 0
  00386	6a 01		 push	 1
  00388	e8 00 00 00 00	 call	 _auMallocSetState_XDS@12
$exit$2957:

; 389  : 
; 390  : #ifdef TRANSCODER
; 391  :     if (TT_SIMPLE == pau->m_ttTranscodeType)
; 392  :         pau->aupfnInverseQuantize = prvInverseQuantizeTRANSCODE;
; 393  : #endif  // TRANSCODER
; 394  : 
; 395  : exit:
; 396  :     return wmaResult;

  0038d	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 397  : }

  00390	8b e5		 mov	 esp, ebp
  00392	5d		 pop	 ebp
  00393	c2 30 00	 ret	 48			; 00000030H
_audecInit_XDS@48 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\decoder\strmdec_wma.h
WMADEC	ENDS
;	COMDAT _ibstrmSetGetMoreData@8
WMADEC	SEGMENT
_pibs$ = 8
_pfnGetMoreData$ = 12
_ibstrmSetGetMoreData@8 PROC NEAR			; COMDAT

; 86   :                         { pibs->m_pfnGetMoreData = pfnGetMoreData; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _pfnGetMoreData$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx
  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
_ibstrmSetGetMoreData@8 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _ibstrmSetUserData@8
WMADEC	SEGMENT
_pibs$ = 8
_dwUser$ = 12
_ibstrmSetUserData@8 PROC NEAR				; COMDAT

; 88   :                         { pibs->m_dwUser = dwUser; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _dwUser$[ebp]
  00009	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
_ibstrmSetUserData@8 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _ibstrmSetOwner@8
WMADEC	SEGMENT
_pibs$ = 8
_dwOwner$ = 12
_ibstrmSetOwner@8 PROC NEAR				; COMDAT

; 90   :                         { pibs->m_dwOwner = dwOwner; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _dwOwner$[ebp]
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
_ibstrmSetOwner@8 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\msaudiodec.c
WMADEC	ENDS
;	COMDAT _auInitPcInfoDEC@4
WMADEC	SEGMENT
_ppcinfo$2994 = -16
_c_iSizeOfPrevOutput$ = -12
_i$ = -8
_piSignBase$ = -4
_pau$ = 8
_auInitPcInfoDEC@4 PROC NEAR				; COMDAT

; 406  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 407  :     I16 i;
; 408  :     const U16 c_iSizeOfPrevOutput = (U16) DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) ;

  00006	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00009	66 8b 88 1c 03
	00 00		 mov	 cx, WORD PTR [eax+796]
  00010	66 89 4d f4	 mov	 WORD PTR _c_iSizeOfPrevOutput$[ebp], cx

; 409  :     I16* piSignBase = pau->m_piPrevOutput + c_iSizeOfPrevOutput * pau->m_cChannel;

  00014	0f b7 55 f4	 movzx	 edx, WORD PTR _c_iSizeOfPrevOutput$[ebp]
  00018	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0001b	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  0001f	0f af d1	 imul	 edx, ecx
  00022	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00025	8b 88 b4 03 00
	00		 mov	 ecx, DWORD PTR [eax+948]
  0002b	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0002e	89 55 fc	 mov	 DWORD PTR _piSignBase$[ebp], edx

; 410  :     for (i = 0; i < pau->m_cChannel; i++)

  00031	66 c7 45 f8 00
	00		 mov	 WORD PTR _i$[ebp], 0
  00037	eb 0c		 jmp	 SHORT $L2991
$L2992:
  00039	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0003d	66 05 01 00	 add	 ax, 1
  00041	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$L2991:
  00045	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00049	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0004c	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  00050	3b c8		 cmp	 ecx, eax
  00052	0f 8d d2 02 00
	00		 jge	 $L2986

; 411  :     {
; 412  :         PerChannelInfo* ppcinfo = pau->m_rgpcinfo + i;

  00058	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  0005c	6b c9 70	 imul	 ecx, 112		; 00000070H
  0005f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00062	03 8a a0 03 00
	00		 add	 ecx, DWORD PTR [edx+928]
  00068	89 4d f0	 mov	 DWORD PTR _ppcinfo$2994[ebp], ecx

; 413  : 
; 414  : //      memset(ppcinfo->m_rgfltMask, 0, sizeof(ppcinfo->m_rgfltMask));
; 415  :         ppcinfo->m_rgiCoefQ = NULL;

  0006b	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2994[ebp]
  0006e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 416  :         ppcinfo->m_rgiMaskQ = pau->m_rgiMaskQ + pau->m_cValidBarkBand * i;

  00074	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00078	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0007b	8b 82 50 03 00
	00		 mov	 eax, DWORD PTR [edx+848]
  00081	0f af c1	 imul	 eax, ecx
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00087	8b 91 a8 03 00
	00		 mov	 edx, DWORD PTR [ecx+936]
  0008d	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  00090	8b 4d f0	 mov	 ecx, DWORD PTR _ppcinfo$2994[ebp]
  00093	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 417  :         ppcinfo->m_rgiHuffDecTbl = NULL;

  00096	8b 55 f0	 mov	 edx, DWORD PTR _ppcinfo$2994[ebp]
  00099	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 418  :         ppcinfo->m_rgiRunEntry = NULL;

  000a0	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2994[ebp]
  000a3	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 419  :         ppcinfo->m_rgiLevelEntry = NULL;

  000aa	8b 4d f0	 mov	 ecx, DWORD PTR _ppcinfo$2994[ebp]
  000ad	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 420  :         ppcinfo->m_cSubbandActual = pau->m_cHighCutOff - pau->m_cLowCutOff;

  000b4	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000b7	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000ba	8b 8a 28 03 00
	00		 mov	 ecx, DWORD PTR [edx+808]
  000c0	2b 88 24 03 00
	00		 sub	 ecx, DWORD PTR [eax+804]
  000c6	8b 55 f0	 mov	 edx, DWORD PTR _ppcinfo$2994[ebp]
  000c9	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 421  :         ppcinfo->m_iPower = 0;

  000cc	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2994[ebp]
  000cf	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 422  :         ppcinfo->m_iActualPower = 0;

  000d6	8b 4d f0	 mov	 ecx, DWORD PTR _ppcinfo$2994[ebp]
  000d9	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 423  : 
; 424  :         //ppcinfo->m_rgiWeightFactor: initialized below
; 425  :         ppcinfo->m_rgiCoefRecon = pau->m_rgiCoefReconOrig + DOUBLE(pau->m_fPad2XTransform,
; 426  :             pau->m_cSubband) * i;

  000e0	0f bf 55 f8	 movsx	 edx, WORD PTR _i$[ebp]
  000e4	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000e7	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000ea	0f af ca	 imul	 ecx, edx
  000ed	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000f0	8b 82 a4 03 00
	00		 mov	 eax, DWORD PTR [edx+932]
  000f6	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  000f9	8b 55 f0	 mov	 edx, DWORD PTR _ppcinfo$2994[ebp]
  000fc	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 427  :         ppcinfo->m_iMaxMaskQ = 0;

  000ff	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2994[ebp]
  00102	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 428  :         ppcinfo->m_iCurrGetPCM_SubFrame = (I16) pau->m_cSubFrameSampleHalfAdjusted;

  00109	8b 4d f0	 mov	 ecx, DWORD PTR _ppcinfo$2994[ebp]
  0010c	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0010f	66 8b 82 9c 00
	00 00		 mov	 ax, WORD PTR [edx+156]
  00116	66 89 41 38	 mov	 WORD PTR [ecx+56], ax

; 429  : 
; 430  :         ppcinfo->m_rgiCoefReconCurr = ppcinfo->m_rgiCoefRecon + pau->m_cSubbandAdjusted /2;

  0011a	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0011d	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00120	99		 cdq
  00121	2b c2		 sub	 eax, edx
  00123	d1 f8		 sar	 eax, 1
  00125	8b 55 f0	 mov	 edx, DWORD PTR _ppcinfo$2994[ebp]
  00128	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  0012b	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0012e	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2994[ebp]
  00131	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 431  :         ppcinfo->m_piPrevOutput = pau->m_piPrevOutput + i;

  00134	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00138	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0013b	8b 82 b4 03 00
	00		 mov	 eax, DWORD PTR [edx+948]
  00141	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00144	8b 55 f0	 mov	 edx, DWORD PTR _ppcinfo$2994[ebp]
  00147	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 432  :         ppcinfo->m_piPrevOutputSign = piSignBase + i * (c_iSizeOfPrevOutput /
; 433  :             BITS_PER_BYTE / sizeof (I16)); //non 17bit shouldn't use this pointer at all

  0014a	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  0014e	0f b7 45 f4	 movzx	 eax, WORD PTR _c_iSizeOfPrevOutput$[ebp]
  00152	99		 cdq
  00153	83 e2 07	 and	 edx, 7
  00156	03 c2		 add	 eax, edx
  00158	c1 f8 03	 sar	 eax, 3
  0015b	d1 e8		 shr	 eax, 1
  0015d	0f af c8	 imul	 ecx, eax
  00160	8b 55 fc	 mov	 edx, DWORD PTR _piSignBase$[ebp]
  00163	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00166	8b 4d f0	 mov	 ecx, DWORD PTR _ppcinfo$2994[ebp]
  00169	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 434  :         ppcinfo->m_piPrevOutputCurr = ppcinfo->m_piPrevOutput;

  0016c	8b 55 f0	 mov	 edx, DWORD PTR _ppcinfo$2994[ebp]
  0016f	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2994[ebp]
  00172	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00175	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 435  : 
; 436  :         ppcinfo->m_iSin = 0;

  00178	8b 55 f0	 mov	 edx, DWORD PTR _ppcinfo$2994[ebp]
  0017b	c7 42 4c 00 00
	00 00		 mov	 DWORD PTR [edx+76], 0

; 437  :         ppcinfo->m_iCos = 0;

  00182	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2994[ebp]
  00185	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 438  :         ppcinfo->m_iSin1 = 0;

  0018c	8b 4d f0	 mov	 ecx, DWORD PTR _ppcinfo$2994[ebp]
  0018f	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0

; 439  :         ppcinfo->m_iCos1 = 0;

  00196	8b 55 f0	 mov	 edx, DWORD PTR _ppcinfo$2994[ebp]
  00199	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 440  :         ppcinfo->m_iStep = 0;

  001a0	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2994[ebp]
  001a3	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [eax+92], 0

; 441  : 
; 442  :         ppcinfo->m_rgfltCoefRecon = (Float *)(ppcinfo->m_rgiCoefRecon); //This will soon be removed

  001aa	8b 4d f0	 mov	 ecx, DWORD PTR _ppcinfo$2994[ebp]
  001ad	8b 55 f0	 mov	 edx, DWORD PTR _ppcinfo$2994[ebp]
  001b0	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  001b3	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 443  :     
; 444  :         //ppcinfo->m_rgfltWeightFactor: initialized below
; 445  :         ppcinfo->m_wtMaxWeight = 0; // Currently always used because LPC not integerized at encoder

  001b6	8b 4d f0	 mov	 ecx, DWORD PTR _ppcinfo$2994[ebp]
  001b9	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 446  :     
; 447  :         if (pau->m_iWeightingMode == LPC_MODE)

  001c0	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  001c3	83 ba 34 03 00
	00 00		 cmp	 DWORD PTR [edx+820], 0
  001ca	75 40		 jne	 SHORT $L3002

; 448  :         { // LPC
; 449  :             ppcinfo->m_rguiWeightFactor = pau->m_rguiWeightFactor + DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * i;

  001cc	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  001d0	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  001d3	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  001d6	0f af d0	 imul	 edx, eax
  001d9	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001dc	8b 88 e4 03 00
	00		 mov	 ecx, DWORD PTR [eax+996]
  001e2	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  001e5	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2994[ebp]
  001e8	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 450  :             ppcinfo->m_rgfltWeightFactor = (float*)(pau->m_rguiWeightFactor + DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * i);

  001eb	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  001ef	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  001f2	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  001f5	0f af c1	 imul	 eax, ecx
  001f8	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  001fb	8b 91 e4 03 00
	00		 mov	 edx, DWORD PTR [ecx+996]
  00201	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  00204	8b 4d f0	 mov	 ecx, DWORD PTR _ppcinfo$2994[ebp]
  00207	89 41 68	 mov	 DWORD PTR [ecx+104], eax

; 451  :         } else 

  0020a	eb 34		 jmp	 SHORT $L3004
$L3002:

; 452  :         {
; 453  :             ppcinfo->m_rguiWeightFactor =(U32*) pau->m_rgpcinfo [i].m_rgiMaskQ;

  0020c	0f bf 55 f8	 movsx	 edx, WORD PTR _i$[ebp]
  00210	6b d2 70	 imul	 edx, 112		; 00000070H
  00213	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00216	8b 88 a0 03 00
	00		 mov	 ecx, DWORD PTR [eax+928]
  0021c	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2994[ebp]
  0021f	8b 4c 11 04	 mov	 ecx, DWORD PTR [ecx+edx+4]
  00223	89 48 2c	 mov	 DWORD PTR [eax+44], ecx

; 454  :             ppcinfo->m_rgfltWeightFactor = (float*)(pau->m_rgpcinfo [i].m_rgiMaskQ);

  00226	0f bf 55 f8	 movsx	 edx, WORD PTR _i$[ebp]
  0022a	6b d2 70	 imul	 edx, 112		; 00000070H
  0022d	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00230	8b 88 a0 03 00
	00		 mov	 ecx, DWORD PTR [eax+928]
  00236	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2994[ebp]
  00239	8b 4c 11 04	 mov	 ecx, DWORD PTR [ecx+edx+4]
  0023d	89 48 68	 mov	 DWORD PTR [eax+104], ecx
$L3004:

; 455  :         }
; 456  : 
; 457  :         ppcinfo->m_rgbBandNotCoded = NULL;

  00240	8b 55 f0	 mov	 edx, DWORD PTR _ppcinfo$2994[ebp]
  00243	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 458  :         ppcinfo->m_rgffltSqrtBWRatio = NULL;

  0024a	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2994[ebp]
  0024d	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 459  :         ppcinfo->m_rgiNoisePower = NULL;

  00254	8b 4d f0	 mov	 ecx, DWORD PTR _ppcinfo$2994[ebp]
  00257	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 460  :         ppcinfo->m_rgfltBandWeight = NULL;

  0025e	8b 55 f0	 mov	 edx, DWORD PTR _ppcinfo$2994[ebp]
  00261	c7 42 64 00 00
	00 00		 mov	 DWORD PTR [edx+100], 0

; 461  : #ifdef ENABLE_ALL_ENCOPT
; 462  :         //set up default pcinfo for noise sub
; 463  :         pau->m_rgpcinfo [i].m_rgbBandNotCoded   = pau->m_rgbBandNotCoded   + pau->m_cValidBarkBand * i;

  00268	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0026c	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0026f	8b 91 50 03 00
	00		 mov	 edx, DWORD PTR [ecx+848]
  00275	0f af d0	 imul	 edx, eax
  00278	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0027b	03 90 d0 03 00
	00		 add	 edx, DWORD PTR [eax+976]
  00281	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00285	6b c9 70	 imul	 ecx, 112		; 00000070H
  00288	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0028b	8b 80 a0 03 00
	00		 mov	 eax, DWORD PTR [eax+928]
  00291	89 54 08 08	 mov	 DWORD PTR [eax+ecx+8], edx

; 464  :         pau->m_rgpcinfo [i].m_rgffltSqrtBWRatio = pau->m_rgffltSqrtBWRatio + pau->m_cValidBarkBand * i;

  00295	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00299	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0029c	8b 82 50 03 00
	00		 mov	 eax, DWORD PTR [edx+848]
  002a2	0f af c1	 imul	 eax, ecx
  002a5	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002a8	8b 91 d4 03 00
	00		 mov	 edx, DWORD PTR [ecx+980]
  002ae	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  002b1	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  002b5	6b c9 70	 imul	 ecx, 112		; 00000070H
  002b8	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  002bb	8b 92 a0 03 00
	00		 mov	 edx, DWORD PTR [edx+928]
  002c1	89 44 0a 0c	 mov	 DWORD PTR [edx+ecx+12], eax

; 465  :         pau->m_rgpcinfo [i].m_rgiNoisePower     = pau->m_rgiNoisePower     + pau->m_cValidBarkBand * i;

  002c5	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  002c9	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002cc	8b 91 50 03 00
	00		 mov	 edx, DWORD PTR [ecx+848]
  002d2	0f af d0	 imul	 edx, eax
  002d5	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002d8	8b 88 d8 03 00
	00		 mov	 ecx, DWORD PTR [eax+984]
  002de	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  002e1	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  002e5	6b c0 70	 imul	 eax, 112		; 00000070H
  002e8	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002eb	8b 89 a0 03 00
	00		 mov	 ecx, DWORD PTR [ecx+928]
  002f1	89 54 01 10	 mov	 DWORD PTR [ecx+eax+16], edx

; 466  : #ifndef BUILD_INTEGER
; 467  :         pau->m_rgpcinfo [i].m_rgfltBandWeight   = pau->m_rgfltBandWeight   + pau->m_cValidBarkBand * i;

  002f5	0f bf 55 f8	 movsx	 edx, WORD PTR _i$[ebp]
  002f9	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002fc	8b 88 50 03 00
	00		 mov	 ecx, DWORD PTR [eax+848]
  00302	0f af ca	 imul	 ecx, edx
  00305	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00308	8b 82 dc 03 00
	00		 mov	 eax, DWORD PTR [edx+988]
  0030e	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00311	0f bf 55 f8	 movsx	 edx, WORD PTR _i$[ebp]
  00315	6b d2 70	 imul	 edx, 112		; 00000070H
  00318	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0031b	8b 80 a0 03 00
	00		 mov	 eax, DWORD PTR [eax+928]
  00321	89 4c 10 64	 mov	 DWORD PTR [eax+edx+100], ecx

; 468  : #endif
; 469  : #endif
; 470  : 
; 471  :     } // for

  00325	e9 0f fd ff ff	 jmp	 $L2992
$L2986:

; 472  : }

  0032a	8b e5		 mov	 esp, ebp
  0032c	5d		 pop	 ebp
  0032d	c2 04 00	 ret	 4
_auInitPcInfoDEC@4 ENDP
WMADEC	ENDS
PUBLIC	_ibstrmSetPacketHeader@8
EXTRN	_ibstrmReset@4:NEAR
; Function compile flags: /Odt
;	COMDAT _audecReset_XDS@4
WMADEC	SEGMENT
_pau$ = -4
_paudec$ = 8
_audecReset_XDS@4 PROC NEAR				; COMDAT

; 475  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 476  :     CAudioObject* pau;
; 477  :     if (paudec == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _paudec$[ebp], 0
  00008	75 07		 jne	 SHORT $L3016

; 478  :         return WMA_OK;

  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000f	eb 44		 jmp	 SHORT $L3013
$L3016:

; 479  :     pau = paudec->pau;

  00011	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	89 4d fc	 mov	 DWORD PTR _pau$[ebp], ecx

; 480  : 
; 481  :     //since a packet loss will be forced; the following are already being done there
; 482  : #if 0
; 483  :     for (i = 0; i < pau->m_cChannel; i++)
; 484  :     {
; 485  :         PerChannelInfo* ppcinfo = pau->m_rgpcinfo + i;
; 486  :         ppcinfo->m_iCurrGetPCM_SubFrame = (I16) pau->m_iCoefRecurQ3;
; 487  :     }
; 488  : 
; 489  :     if ( pau->m_piPrevOutput != NULL )
; 490  :     {
; 491  :         const int c_iSizeOfPrevOutput = sizeof (I16) * DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel;
; 492  : #       ifndef PREVOUTPUT_16BITS
; 493  :             const int c_iSizeOfPrevOutputSign = DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel / BITS_PER_BYTE + pau->m_cChannel*sizeof(I16);
; 494  : #       else 
; 495  :             const int c_iSizeOfPrevOutputSign = 0;
; 496  : #       endif
; 497  :         memset (pau->m_piPrevOutput, 0, c_iSizeOfPrevOutput + c_iSizeOfPrevOutputSign);
; 498  :     }
; 499  : #endif
; 500  : 
; 501  :     //this is not needed anymore
; 502  :     //if we set packetheader to 0, meaning whatever left in the current packet
; 503  :     //will be discarded by decodeInfo(). We just have to make sure
; 504  :     //decodeInfo() gets called right after this. But it has to be since we are forcing
; 505  :     //a packet loss situation.
; 506  : 
; 507  : 
; 508  : 	//to suppress packet loss check
; 509  :     ibstrmReset(&paudec->m_ibstrm);

  00019	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0001c	83 c2 30	 add	 edx, 48			; 00000030H
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 _ibstrmReset@4

; 510  :     ibstrmSetPacketHeader(&paudec->m_ibstrm, 0);

  00025	6a 00		 push	 0
  00027	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0002a	83 c0 30	 add	 eax, 48			; 00000030H
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _ibstrmSetPacketHeader@8

; 511  : 
; 512  :     //unlock ourself because there is an error already
; 513  :     //wouldn't continue to decode the frame, making sure decodeInfo will be called
; 514  :     if (pau->m_codecStatus == CODEC_ONHOLD)

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00036	83 79 48 05	 cmp	 DWORD PTR [ecx+72], 5
  0003a	75 0a		 jne	 SHORT $L3017

; 515  :     {
; 516  :         pau->m_codecStatus = CODEC_STEADY;

  0003c	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  0003f	c7 42 48 01 00
	00 00		 mov	 DWORD PTR [edx+72], 1
$L3017:

; 517  :     }
; 518  : 
; 519  :     //== to codec begin
; 520  :     pau->m_iPacketCurr = -2;        //make sure we see a packet loss

  00046	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00049	c7 40 04 fe ff
	ff ff		 mov	 DWORD PTR [eax+4], -2	; fffffffeH

; 521  : 
; 522  :     return WMA_OK;

  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
$L3013:

; 523  : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
_audecReset_XDS@4 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\decoder\strmdec_wma.h
WMADEC	ENDS
;	COMDAT _ibstrmSetPacketHeader@8
WMADEC	SEGMENT
_pibs$ = 8
_iVal$ = 12
_ibstrmSetPacketHeader@8 PROC NEAR			; COMDAT

; 94   :                         { pibs->m_dwHeaderBuf = iVal; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _iVal$[ebp]
  00009	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
_ibstrmSetPacketHeader@8 ENDP
WMADEC	ENDS
PUBLIC	_prvOutputBufferSize@12
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\msaudiodec.c
;	COMDAT _prvOutputBufferSize@12
WMADEC	SEGMENT
_fAllowSuperFrame$ = 8
_cSamplesPerFrame$ = 12
_cChannels$ = 16
_prvOutputBufferSize@12 PROC NEAR			; COMDAT

; 525  : U32 prvOutputBufferSize(Bool fAllowSuperFrame, Int cSamplesPerFrame, Int cChannels) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 526  :   return sizeof (I16) * ( fAllowSuperFrame ? 32 : 1 )
; 527  :                       * cSamplesPerFrame * cChannels;

  00003	8b 45 08	 mov	 eax, DWORD PTR _fAllowSuperFrame$[ebp]
  00006	f7 d8		 neg	 eax
  00008	1b c0		 sbb	 eax, eax
  0000a	83 e0 1f	 and	 eax, 31			; 0000001fH
  0000d	83 c0 01	 add	 eax, 1
  00010	d1 e0		 shl	 eax, 1
  00012	0f af 45 0c	 imul	 eax, DWORD PTR _cSamplesPerFrame$[ebp]
  00016	0f af 45 10	 imul	 eax, DWORD PTR _cChannels$[ebp]

; 528  : 
; 529  : }

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
_prvOutputBufferSize@12 ENDP
WMADEC	ENDS
PUBLIC	_audecOutputBufferSize_XDS@20
; Function compile flags: /Odt
;	COMDAT _audecOutputBufferSize_XDS@20
WMADEC	SEGMENT
_iVersion$ = 8
_iSamplingRate$ = 12
_cChannels$ = 16
_cBytesPerSec$ = 20
_wEncodeOpt$ = 24
_audecOutputBufferSize_XDS@20 PROC NEAR			; COMDAT

; 531  : U32 audecOutputBufferSize(Int iVersion, Int iSamplingRate, Int cChannels, Int cBytesPerSec, U16 wEncodeOpt) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 532  :   return prvOutputBufferSize(!!(wEncodeOpt & ENCOPT_SUPERFRAME),
; 533  :                              msaudioGetSamplePerFrame (iSamplingRate,
; 534  :                                                        cBytesPerSec * 8,
; 535  :                                                        cChannels,
; 536  :                                                        iVersion),
; 537  :                              cChannels);

  00003	8b 45 10	 mov	 eax, DWORD PTR _cChannels$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _iVersion$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 10	 mov	 edx, DWORD PTR _cChannels$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 14	 mov	 eax, DWORD PTR _cBytesPerSec$[ebp]
  00012	c1 e0 03	 shl	 eax, 3
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _iSamplingRate$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 _msaudioGetSamplePerFrame_XDS@16
  0001f	50		 push	 eax
  00020	0f b7 55 18	 movzx	 edx, WORD PTR _wEncodeOpt$[ebp]
  00024	83 e2 02	 and	 edx, 2
  00027	f7 da		 neg	 edx
  00029	1b d2		 sbb	 edx, edx
  0002b	f7 da		 neg	 edx
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 _prvOutputBufferSize@12

; 538  : }

  00033	5d		 pop	 ebp
  00034	c2 14 00	 ret	 20			; 00000014H
_audecOutputBufferSize_XDS@20 ENDP
WMADEC	ENDS
PUBLIC	_audecDecode_XDS@44
; Function compile flags: /Odt
;	COMDAT _audecDecode_XDS@44
WMADEC	SEGMENT
tv154 = -44
tv76 = -40
_cbRawPacket$ = -36
_hr$ = -32
_fFirstPacket$ = -28
_cbDstUsed$ = -24
_cbEquUsed$ = -20
_pau$ = -16
_cbSrcUsed$ = -12
_cbEquRemaining$ = -8
_cSamplesPrevPacket$ = -4
_paudec$ = 8
_pbSrc$ = 12
_cbSrcLength$ = 16
_pcbSrcUsed$ = 20
_pbDst$ = 24
_cbDstLength$ = 28
_pcbDstUsed$ = 32
_pbEqu$ = 36
_cbEqu$ = 40
_pcbEquUsed$ = 44
_pcSamplesFromBefore$ = 48
_audecDecode_XDS@44 PROC NEAR				; COMDAT

; 557  : {   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 558  :     WMARESULT hr;
; 559  :     Int cbRawPacket;
; 560  :     Int cbSrcUsed; 
; 561  :     Int cbDstUsed;
; 562  :     Int cbEquUsed;
; 563  :     Int cbEquRemaining;
; 564  :     Int cSamplesPrevPacket = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cSamplesPrevPacket$[ebp], 0

; 565  :     Bool fFirstPacket = WMAB_TRUE;

  0000d	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _fFirstPacket$[ebp], 1

; 566  :     CAudioObject* pau = paudec->pau;

  00014	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	89 4d f0	 mov	 DWORD PTR _pau$[ebp], ecx

; 567  : #ifdef PROFILE
; 568  :     //FunctionProfile fp;
; 569  :     //FunctionProfileStart(&fp,DECODE_PROFILE);
; 570  : #endif
; 571  : 
; 572  :     assert (pbSrc != NULL && pcbSrcUsed != NULL && pbDst != NULL && pcbDstUsed != NULL);
; 573  :     if (pbSrc == NULL || pcbSrcUsed == NULL || pbDst == NULL || pcbDstUsed == NULL)

  0001c	83 7d 0c 00	 cmp	 DWORD PTR _pbSrc$[ebp], 0
  00020	74 12		 je	 SHORT $L3075
  00022	83 7d 14 00	 cmp	 DWORD PTR _pcbSrcUsed$[ebp], 0
  00026	74 0c		 je	 SHORT $L3075
  00028	83 7d 18 00	 cmp	 DWORD PTR _pbDst$[ebp], 0
  0002c	74 06		 je	 SHORT $L3075
  0002e	83 7d 20 00	 cmp	 DWORD PTR _pcbDstUsed$[ebp], 0
  00032	75 55		 jne	 SHORT $L3074
$L3075:

; 574  :         return TraceResult(WMA_E_INVALIDARG);

  00034	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_INVALIDARG
  0003a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  00040	74 37		 je	 SHORT $L3557
  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  00047	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  0004d	74 2a		 je	 SHORT $L3557
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_INVALIDARG
  00055	51		 push	 ecx
  00056	68 3e 02 00 00	 push	 574			; 0000023eH
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00060	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00065	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_INVALIDARG
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00071	83 c4 14	 add	 esp, 20			; 00000014H
  00074	89 45 d8	 mov	 DWORD PTR tv76[ebp], eax
  00077	eb 08		 jmp	 SHORT $L3558
$L3557:
  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  0007e	89 45 d8	 mov	 DWORD PTR tv76[ebp], eax
$L3558:
  00081	8b 45 d8	 mov	 eax, DWORD PTR tv76[ebp]
  00084	e9 a7 01 00 00	 jmp	 $L3060
$L3074:

; 575  : 
; 576  :     if (cbSrcLength <= 0) {  //nothing to decode

  00089	83 7d 10 00	 cmp	 DWORD PTR _cbSrcLength$[ebp], 0
  0008d	7f 17		 jg	 SHORT $L3076

; 577  :         *pcbDstUsed   = 0;

  0008f	8b 4d 20	 mov	 ecx, DWORD PTR _pcbDstUsed$[ebp]
  00092	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 578  :         hr = WMA_OK;

  00098	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_OK
  0009e	89 55 e0	 mov	 DWORD PTR _hr$[ebp], edx

; 579  :         goto exit;

  000a1	e9 87 01 00 00	 jmp	 $exit$3077
$L3076:

; 580  :     }
; 581  : 
; 582  :     cbRawPacket = prvOutputBufferSize(pau->m_fAllowSuperFrame, pau->m_cFrameSampleHalfAdjusted, pau->m_cChannel);

  000a6	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  000a9	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  000ad	51		 push	 ecx
  000ae	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  000b1	8b 82 1c 03 00
	00		 mov	 eax, DWORD PTR [edx+796]
  000b7	50		 push	 eax
  000b8	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  000bb	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  000be	52		 push	 edx
  000bf	e8 00 00 00 00	 call	 _prvOutputBufferSize@12
  000c4	89 45 dc	 mov	 DWORD PTR _cbRawPacket$[ebp], eax

; 583  :     
; 584  :     *pcbSrcUsed = 0;

  000c7	8b 45 14	 mov	 eax, DWORD PTR _pcbSrcUsed$[ebp]
  000ca	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 585  :     *pcbDstUsed = 0;

  000d0	8b 4d 20	 mov	 ecx, DWORD PTR _pcbDstUsed$[ebp]
  000d3	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 586  :     if (NULL != pcbEquUsed)

  000d9	83 7d 2c 00	 cmp	 DWORD PTR _pcbEquUsed$[ebp], 0
  000dd	74 09		 je	 SHORT $L3079

; 587  :         *pcbEquUsed = 0;

  000df	8b 55 2c	 mov	 edx, DWORD PTR _pcbEquUsed$[ebp]
  000e2	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L3079:

; 588  : 
; 589  :     cbEquRemaining = cbEqu;

  000e8	8b 45 28	 mov	 eax, DWORD PTR _cbEqu$[ebp]
  000eb	89 45 f8	 mov	 DWORD PTR _cbEquRemaining$[ebp], eax

; 590  :     hr = WMA_OK;

  000ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_OK
  000f4	89 4d e0	 mov	 DWORD PTR _hr$[ebp], ecx
$L3081:

; 591  :     while (WMAB_TRUE)    {

  000f7	ba 01 00 00 00	 mov	 edx, 1
  000fc	85 d2		 test	 edx, edx
  000fe	0f 84 29 01 00
	00		 je	 $exit$3077

; 592  :         if ((cbSrcLength - *pcbSrcUsed) * BITS_PER_BYTE < pau->m_cBitPacketLength ||
; 593  :             (cbDstLength - *pcbDstUsed) < cbRawPacket)      //this is to be safe, usually less than cbRawPacket is needed

  00104	8b 45 14	 mov	 eax, DWORD PTR _pcbSrcUsed$[ebp]
  00107	8b 4d 10	 mov	 ecx, DWORD PTR _cbSrcLength$[ebp]
  0010a	2b 08		 sub	 ecx, DWORD PTR [eax]
  0010c	c1 e1 03	 shl	 ecx, 3
  0010f	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00112	3b 4a 18	 cmp	 ecx, DWORD PTR [edx+24]
  00115	7c 0d		 jl	 SHORT $L3084
  00117	8b 45 20	 mov	 eax, DWORD PTR _pcbDstUsed$[ebp]
  0011a	8b 4d 1c	 mov	 ecx, DWORD PTR _cbDstLength$[ebp]
  0011d	2b 08		 sub	 ecx, DWORD PTR [eax]
  0011f	3b 4d dc	 cmp	 ecx, DWORD PTR _cbRawPacket$[ebp]
  00122	7d 05		 jge	 SHORT $L3083
$L3084:

; 594  :             break;

  00124	e9 04 01 00 00	 jmp	 $exit$3077
$L3083:

; 595  : 
; 596  :         hr = prvDecodePacket  (paudec,
; 597  :                                pbSrc, 
; 598  :                                pau->m_cBitPacketLength/BITS_PER_BYTE, 
; 599  :                                &cbSrcUsed,
; 600  :                                pbDst, 
; 601  :                                cbDstLength - *pcbDstUsed, 
; 602  :                                &cbDstUsed,
; 603  :                                pbEqu,
; 604  :                                cbEquRemaining,
; 605  :                                &cbEquUsed, 
; 606  :                                &cSamplesPrevPacket);

  00129	8d 55 fc	 lea	 edx, DWORD PTR _cSamplesPrevPacket$[ebp]
  0012c	52		 push	 edx
  0012d	8d 45 ec	 lea	 eax, DWORD PTR _cbEquUsed$[ebp]
  00130	50		 push	 eax
  00131	8b 4d f8	 mov	 ecx, DWORD PTR _cbEquRemaining$[ebp]
  00134	51		 push	 ecx
  00135	8b 55 24	 mov	 edx, DWORD PTR _pbEqu$[ebp]
  00138	52		 push	 edx
  00139	8d 45 e8	 lea	 eax, DWORD PTR _cbDstUsed$[ebp]
  0013c	50		 push	 eax
  0013d	8b 4d 20	 mov	 ecx, DWORD PTR _pcbDstUsed$[ebp]
  00140	8b 55 1c	 mov	 edx, DWORD PTR _cbDstLength$[ebp]
  00143	2b 11		 sub	 edx, DWORD PTR [ecx]
  00145	52		 push	 edx
  00146	8b 45 18	 mov	 eax, DWORD PTR _pbDst$[ebp]
  00149	50		 push	 eax
  0014a	8d 4d f4	 lea	 ecx, DWORD PTR _cbSrcUsed$[ebp]
  0014d	51		 push	 ecx
  0014e	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00151	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00154	99		 cdq
  00155	83 e2 07	 and	 edx, 7
  00158	03 c2		 add	 eax, edx
  0015a	c1 f8 03	 sar	 eax, 3
  0015d	50		 push	 eax
  0015e	8b 45 0c	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00161	50		 push	 eax
  00162	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 _prvDecodePacket_XDS@44
  0016b	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax

; 607  : 
; 608  :         //first time
; 609  :         if (fFirstPacket && pcSamplesFromBefore != NULL)

  0016e	83 7d e4 00	 cmp	 DWORD PTR _fFirstPacket$[ebp], 0
  00172	74 15		 je	 SHORT $L3086
  00174	83 7d 30 00	 cmp	 DWORD PTR _pcSamplesFromBefore$[ebp], 0
  00178	74 0f		 je	 SHORT $L3086

; 610  :         {
; 611  :             *pcSamplesFromBefore = cSamplesPrevPacket;

  0017a	8b 55 30	 mov	 edx, DWORD PTR _pcSamplesFromBefore$[ebp]
  0017d	8b 45 fc	 mov	 eax, DWORD PTR _cSamplesPrevPacket$[ebp]
  00180	89 02		 mov	 DWORD PTR [edx], eax

; 612  :             fFirstPacket = WMAB_FALSE;

  00182	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _fFirstPacket$[ebp], 0
$L3086:

; 613  :         }
; 614  : 
; 615  :         assert (cbSrcUsed == pau->m_cBitPacketLength/BITS_PER_BYTE);
; 616  :         pbSrc       += cbSrcUsed;

  00189	8b 4d 0c	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  0018c	03 4d f4	 add	 ecx, DWORD PTR _cbSrcUsed$[ebp]
  0018f	89 4d 0c	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 617  :         *pcbSrcUsed += cbSrcUsed;

  00192	8b 55 14	 mov	 edx, DWORD PTR _pcbSrcUsed$[ebp]
  00195	8b 02		 mov	 eax, DWORD PTR [edx]
  00197	03 45 f4	 add	 eax, DWORD PTR _cbSrcUsed$[ebp]
  0019a	8b 4d 14	 mov	 ecx, DWORD PTR _pcbSrcUsed$[ebp]
  0019d	89 01		 mov	 DWORD PTR [ecx], eax

; 618  : 
; 619  :         CHECKWMA_EXIT(hr);

  0019f	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001a3	7d 42		 jge	 SHORT $L3089
  001a5	8b 55 e0	 mov	 edx, DWORD PTR _hr$[ebp]
  001a8	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  001ae	74 2f		 je	 SHORT $L3559
  001b0	8b 45 e0	 mov	 eax, DWORD PTR _hr$[ebp]
  001b3	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  001b9	74 24		 je	 SHORT $L3559
  001bb	8b 4d e0	 mov	 ecx, DWORD PTR _hr$[ebp]
  001be	51		 push	 ecx
  001bf	68 6b 02 00 00	 push	 619			; 0000026bH
  001c4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  001c9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  001ce	8b 55 e0	 mov	 edx, DWORD PTR _hr$[ebp]
  001d1	52		 push	 edx
  001d2	e8 00 00 00 00	 call	 _MyOutputDbgStr
  001d7	83 c4 14	 add	 esp, 20			; 00000014H
  001da	89 45 d4	 mov	 DWORD PTR tv154[ebp], eax
  001dd	eb 06		 jmp	 SHORT $L3560
$L3559:
  001df	8b 45 e0	 mov	 eax, DWORD PTR _hr$[ebp]
  001e2	89 45 d4	 mov	 DWORD PTR tv154[ebp], eax
$L3560:
  001e5	eb 46		 jmp	 SHORT $exit$3077
$L3089:

; 620  : 
; 621  :         assert (cbDstUsed <= cbRawPacket);
; 622  :         pbDst       += cbDstUsed;

  001e7	8b 4d 18	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  001ea	03 4d e8	 add	 ecx, DWORD PTR _cbDstUsed$[ebp]
  001ed	89 4d 18	 mov	 DWORD PTR _pbDst$[ebp], ecx

; 623  :         *pcbDstUsed += cbDstUsed;

  001f0	8b 55 20	 mov	 edx, DWORD PTR _pcbDstUsed$[ebp]
  001f3	8b 02		 mov	 eax, DWORD PTR [edx]
  001f5	03 45 e8	 add	 eax, DWORD PTR _cbDstUsed$[ebp]
  001f8	8b 4d 20	 mov	 ecx, DWORD PTR _pcbDstUsed$[ebp]
  001fb	89 01		 mov	 DWORD PTR [ecx], eax

; 624  : 
; 625  :         if (NULL != pbEqu)

  001fd	83 7d 24 00	 cmp	 DWORD PTR _pbEqu$[ebp], 0
  00201	74 25		 je	 SHORT $L3091

; 626  :         {
; 627  :             pbEqu       += cbEquUsed;

  00203	8b 55 24	 mov	 edx, DWORD PTR _pbEqu$[ebp]
  00206	03 55 ec	 add	 edx, DWORD PTR _cbEquUsed$[ebp]
  00209	89 55 24	 mov	 DWORD PTR _pbEqu$[ebp], edx

; 628  :             cbEquRemaining -= cbEquUsed;

  0020c	8b 45 f8	 mov	 eax, DWORD PTR _cbEquRemaining$[ebp]
  0020f	2b 45 ec	 sub	 eax, DWORD PTR _cbEquUsed$[ebp]
  00212	89 45 f8	 mov	 DWORD PTR _cbEquRemaining$[ebp], eax

; 629  :             if (NULL != pcbEquUsed)

  00215	83 7d 2c 00	 cmp	 DWORD PTR _pcbEquUsed$[ebp], 0
  00219	74 0d		 je	 SHORT $L3091

; 630  :                 *pcbEquUsed += cbEquUsed;

  0021b	8b 4d 2c	 mov	 ecx, DWORD PTR _pcbEquUsed$[ebp]
  0021e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00220	03 55 ec	 add	 edx, DWORD PTR _cbEquUsed$[ebp]
  00223	8b 45 2c	 mov	 eax, DWORD PTR _pcbEquUsed$[ebp]
  00226	89 10		 mov	 DWORD PTR [eax], edx
$L3091:

; 631  :         }
; 632  :         
; 633  :     }

  00228	e9 ca fe ff ff	 jmp	 $L3081
$exit$3077:

; 634  : exit:
; 635  : #ifdef PROFILE
; 636  :     //FunctionProfileStop(&fp);
; 637  : #endif
; 638  : 
; 639  :     return hr;

  0022d	8b 45 e0	 mov	 eax, DWORD PTR _hr$[ebp]
$L3060:

; 640  : }

  00230	8b e5		 mov	 esp, ebp
  00232	5d		 pop	 ebp
  00233	c2 2c 00	 ret	 44			; 0000002cH
_audecDecode_XDS@44 ENDP
WMADEC	ENDS
PUBLIC	_audecDecodeInfo_XDS@4
PUBLIC	_audecDecodeData_XDS@8
PUBLIC	_audecGetPCM_XDS@16
; Function compile flags: /Odt
;	COMDAT _prvDecodePacket_XDS@44
WMADEC	SEGMENT
tv260 = -72
tv248 = -68
tv214 = -64
tv204 = -60
tv194 = -56
tv183 = -52
tv164 = -48
tv152 = -44
tv141 = -40
tv137 = -36
tv128 = -32
tv75 = -28
_hr$ = -24
_cSampleDecoded$ = -20
_cIteration$ = -16
_pau$ = -12
_cbRawFrame$ = -8
_fDoDecode$ = -4
_paudec$ = 8
_pbSrc$ = 12
_cbSrcLength$ = 16
_pcbSrcUsed$ = 20
_pbDst$ = 24
_cbDstLength$ = 28
_pcbDstUsed$ = 32
_pbEqu$ = 36
_cbEquLength$ = 40
_pcbEquUsed$ = 44
_pcSamplesPrevPacket$ = 48
_prvDecodePacket_XDS@44 PROC NEAR			; COMDAT

; 662  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H

; 663  :     WMARESULT hr;
; 664  :     Int cbRawFrame;
; 665  :     U16 cSampleDecoded = 0;

  00006	66 c7 45 ec 00
	00		 mov	 WORD PTR _cSampleDecoded$[ebp], 0

; 666  :     CAudioObject* pau = paudec->pau;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f4	 mov	 DWORD PTR _pau$[ebp], ecx

; 667  :     Int cIteration = 0;

  00014	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _cIteration$[ebp], 0

; 668  :     Bool fDoDecode = WMAB_TRUE;

  0001b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fDoDecode$[ebp], 1

; 669  : #ifdef PROFILE
; 670  :     //FunctionProfile fp;
; 671  : #endif
; 672  : 
; 673  :     assert(pcbSrcUsed != NULL && pbDst != NULL && pcbDstUsed != NULL);
; 674  :     assert(paudec->m_ibstrm.m_pfnGetMoreData == prvWMAGetMoreData); // non-streaming mode MUST use the std fn
; 675  :     assert(paudec->m_ibstrm.m_dwUser == (U32)paudec);
; 676  : 
; 677  :     if (pcbSrcUsed == NULL || pbDst == NULL || pcbDstUsed == NULL)

  00022	83 7d 14 00	 cmp	 DWORD PTR _pcbSrcUsed$[ebp], 0
  00026	74 0c		 je	 SHORT $L3128
  00028	83 7d 18 00	 cmp	 DWORD PTR _pbDst$[ebp], 0
  0002c	74 06		 je	 SHORT $L3128
  0002e	83 7d 20 00	 cmp	 DWORD PTR _pcbDstUsed$[ebp], 0
  00032	75 55		 jne	 SHORT $L3127
$L3128:

; 678  :         return TraceResult(WMA_E_INVALIDARG);

  00034	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_INVALIDARG
  0003a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  00040	74 37		 je	 SHORT $L3564
  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  00047	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  0004d	74 2a		 je	 SHORT $L3564
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_INVALIDARG
  00055	51		 push	 ecx
  00056	68 a6 02 00 00	 push	 678			; 000002a6H
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00060	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00065	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_INVALIDARG
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00071	83 c4 14	 add	 esp, 20			; 00000014H
  00074	89 45 e4	 mov	 DWORD PTR tv75[ebp], eax
  00077	eb 08		 jmp	 SHORT $L3565
$L3564:
  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  0007e	89 45 e4	 mov	 DWORD PTR tv75[ebp], eax
$L3565:
  00081	8b 45 e4	 mov	 eax, DWORD PTR tv75[ebp]
  00084	e9 96 05 00 00	 jmp	 $L3117
$L3127:

; 679  : 
; 680  :     *pcbSrcUsed = *pcbDstUsed = 0;

  00089	8b 4d 20	 mov	 ecx, DWORD PTR _pcbDstUsed$[ebp]
  0008c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00092	8b 55 14	 mov	 edx, DWORD PTR _pcbSrcUsed$[ebp]
  00095	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 681  :     *pcSamplesPrevPacket = 0;

  0009b	8b 45 30	 mov	 eax, DWORD PTR _pcSamplesPrevPacket$[ebp]
  0009e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 682  :     cbRawFrame = pau->m_cFrameSampleHalfAdjusted * sizeof (I16) * pau->m_cChannel;

  000a4	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  000a7	8b 91 1c 03 00
	00		 mov	 edx, DWORD PTR [ecx+796]
  000ad	d1 e2		 shl	 edx, 1
  000af	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  000b2	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  000b6	0f af d1	 imul	 edx, ecx
  000b9	89 55 f8	 mov	 DWORD PTR _cbRawFrame$[ebp], edx

; 683  : 
; 684  :     // Verify that we have enough space in destination for worst-case scenario
; 685  :     if ((paudec->pau->m_fAllowSuperFrame && cbDstLength < 16 * cbRawFrame) ||
; 686  :         (WMAB_FALSE == paudec->pau->m_fAllowSuperFrame && cbDstLength < cbRawFrame))

  000bc	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  000bf	8b 02		 mov	 eax, DWORD PTR [edx]
  000c1	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  000c5	74 0b		 je	 SHORT $L3132
  000c7	8b 4d f8	 mov	 ecx, DWORD PTR _cbRawFrame$[ebp]
  000ca	c1 e1 04	 shl	 ecx, 4
  000cd	39 4d 1c	 cmp	 DWORD PTR _cbDstLength$[ebp], ecx
  000d0	7c 13		 jl	 SHORT $L3131
$L3132:
  000d2	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  000d5	8b 02		 mov	 eax, DWORD PTR [edx]
  000d7	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  000db	75 5d		 jne	 SHORT $L3130
  000dd	8b 4d 1c	 mov	 ecx, DWORD PTR _cbDstLength$[ebp]
  000e0	3b 4d f8	 cmp	 ecx, DWORD PTR _cbRawFrame$[ebp]
  000e3	7d 55		 jge	 SHORT $L3130
$L3131:

; 687  :         return TraceResult(WMA_E_BUFFEROVERFLOW);

  000e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BUFFEROVERFLOW
  000eb	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  000f1	74 37		 je	 SHORT $L3566
  000f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BUFFEROVERFLOW
  000f8	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  000fe	74 2a		 je	 SHORT $L3566
  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BUFFEROVERFLOW
  00106	51		 push	 ecx
  00107	68 af 02 00 00	 push	 687			; 000002afH
  0010c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00111	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00116	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BUFFEROVERFLOW
  0011c	52		 push	 edx
  0011d	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00122	83 c4 14	 add	 esp, 20			; 00000014H
  00125	89 45 e0	 mov	 DWORD PTR tv128[ebp], eax
  00128	eb 08		 jmp	 SHORT $L3567
$L3566:
  0012a	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BUFFEROVERFLOW
  0012f	89 45 e0	 mov	 DWORD PTR tv128[ebp], eax
$L3567:
  00132	8b 45 e0	 mov	 eax, DWORD PTR tv128[ebp]
  00135	e9 e5 04 00 00	 jmp	 $L3117
$L3130:

; 688  : 
; 689  : #if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
; 690  :     if ( pau->m_fUpsample || pau->m_fPad2XTransform )
; 691  :         cbRawFrame *= 2;    
; 692  : #endif
; 693  : 
; 694  : #ifdef PROFILE
; 695  :     //FunctionProfileStart(&fp,DECODE_PACKET_PROFILE);
; 696  : #endif
; 697  : 
; 698  :     *pcbSrcUsed = 0;

  0013a	8b 4d 14	 mov	 ecx, DWORD PTR _pcbSrcUsed$[ebp]
  0013d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 699  :     *pcbDstUsed = 0;

  00143	8b 55 20	 mov	 edx, DWORD PTR _pcbDstUsed$[ebp]
  00146	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 700  :     if (NULL != pcbEquUsed)

  0014c	83 7d 2c 00	 cmp	 DWORD PTR _pcbEquUsed$[ebp], 0
  00150	74 09		 je	 SHORT $L3134

; 701  :         *pcbEquUsed = 0;

  00152	8b 45 2c	 mov	 eax, DWORD PTR _pcbEquUsed$[ebp]
  00155	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L3134:

; 702  : 
; 703  :     //to be used by getMoreData
; 704  :     paudec->m_pbSrcCurr = (U8*) pbSrc; 

  0015b	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0015e	8b 55 0c	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00161	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 705  :     paudec->m_cbSrcCurrLength = (U16) min (cbSrcLength, paudec->pau->m_cBitPacketLength/BITS_PER_BYTE); 

  00164	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00167	8b 08		 mov	 ecx, DWORD PTR [eax]
  00169	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0016c	99		 cdq
  0016d	83 e2 07	 and	 edx, 7
  00170	03 c2		 add	 eax, edx
  00172	c1 f8 03	 sar	 eax, 3
  00175	39 45 10	 cmp	 DWORD PTR _cbSrcLength$[ebp], eax
  00178	7d 08		 jge	 SHORT $L3568
  0017a	8b 55 10	 mov	 edx, DWORD PTR _cbSrcLength$[ebp]
  0017d	89 55 dc	 mov	 DWORD PTR tv137[ebp], edx
  00180	eb 14		 jmp	 SHORT $L3569
$L3568:
  00182	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00185	8b 08		 mov	 ecx, DWORD PTR [eax]
  00187	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0018a	99		 cdq
  0018b	83 e2 07	 and	 edx, 7
  0018e	03 c2		 add	 eax, edx
  00190	c1 f8 03	 sar	 eax, 3
  00193	89 45 dc	 mov	 DWORD PTR tv137[ebp], eax
$L3569:
  00196	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00199	66 8b 45 dc	 mov	 ax, WORD PTR tv137[ebp]
  0019d	66 89 42 10	 mov	 WORD PTR [edx+16], ax
$L3138:

; 706  :    
; 707  :     while (fDoDecode)

  001a1	83 7d fc 00	 cmp	 DWORD PTR _fDoDecode$[ebp], 0
  001a5	0f 84 5d 04 00
	00		 je	 $exit$3148

; 708  :     {
; 709  :         switch (pau->m_codecStatus)
; 710  :         {

  001ab	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  001ae	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  001b1	89 55 d8	 mov	 DWORD PTR tv141[ebp], edx
  001b4	83 7d d8 01	 cmp	 DWORD PTR tv141[ebp], 1
  001b8	74 15		 je	 SHORT $L3144
  001ba	83 7d d8 03	 cmp	 DWORD PTR tv141[ebp], 3
  001be	74 0f		 je	 SHORT $L3144
  001c0	83 7d d8 05	 cmp	 DWORD PTR tv141[ebp], 5
  001c4	0f 84 dd 00 00
	00		 je	 $L3155
  001ca	e9 34 04 00 00	 jmp	 $L3141
$L3144:

; 711  :         case CODEC_BEGIN:
; 712  :         case CODEC_STEADY:
; 713  :             //only flush will call with null,but, in which case it goes to on-hold directly
; 714  :             if (pbSrc == NULL || cbSrcLength <= 0)

  001cf	83 7d 0c 00	 cmp	 DWORD PTR _pbSrc$[ebp], 0
  001d3	74 06		 je	 SHORT $L3147
  001d5	83 7d 10 00	 cmp	 DWORD PTR _cbSrcLength$[ebp], 0
  001d9	7f 58		 jg	 SHORT $L3146
$L3147:

; 715  :             {
; 716  :                 hr = TraceResult(WMA_E_INVALIDARG);

  001db	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  001e0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  001e6	74 37		 je	 SHORT $L3570
  001e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_INVALIDARG
  001ee	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  001f4	74 29		 je	 SHORT $L3570
  001f6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_INVALIDARG
  001fc	52		 push	 edx
  001fd	68 cc 02 00 00	 push	 716			; 000002ccH
  00202	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00207	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0020c	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  00211	50		 push	 eax
  00212	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00217	83 c4 14	 add	 esp, 20			; 00000014H
  0021a	89 45 d4	 mov	 DWORD PTR tv152[ebp], eax
  0021d	eb 09		 jmp	 SHORT $L3571
$L3570:
  0021f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_INVALIDARG
  00225	89 4d d4	 mov	 DWORD PTR tv152[ebp], ecx
$L3571:
  00228	8b 55 d4	 mov	 edx, DWORD PTR tv152[ebp]
  0022b	89 55 e8	 mov	 DWORD PTR _hr$[ebp], edx

; 717  :                 goto exit;

  0022e	e9 d5 03 00 00	 jmp	 $exit$3148
$L3146:

; 718  :             }
; 719  : 
; 720  :             TRACEWMA_EXIT (hr, audecDecodeInfo (paudec));

  00233	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00236	50		 push	 eax
  00237	e8 00 00 00 00	 call	 _audecDecodeInfo_XDS@4
  0023c	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax
  0023f	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00243	7d 45		 jge	 SHORT $L3151
  00245	8b 4d e8	 mov	 ecx, DWORD PTR _hr$[ebp]
  00248	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  0024e	74 2f		 je	 SHORT $L3572
  00250	8b 55 e8	 mov	 edx, DWORD PTR _hr$[ebp]
  00253	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  00259	74 24		 je	 SHORT $L3572
  0025b	8b 45 e8	 mov	 eax, DWORD PTR _hr$[ebp]
  0025e	50		 push	 eax
  0025f	68 d0 02 00 00	 push	 720			; 000002d0H
  00264	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00269	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0026e	8b 4d e8	 mov	 ecx, DWORD PTR _hr$[ebp]
  00271	51		 push	 ecx
  00272	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00277	83 c4 14	 add	 esp, 20			; 00000014H
  0027a	89 45 d0	 mov	 DWORD PTR tv164[ebp], eax
  0027d	eb 06		 jmp	 SHORT $L3573
$L3572:
  0027f	8b 55 e8	 mov	 edx, DWORD PTR _hr$[ebp]
  00282	89 55 d0	 mov	 DWORD PTR tv164[ebp], edx
$L3573:
  00285	e9 7e 03 00 00	 jmp	 $exit$3148
$L3151:

; 721  :             *pcSamplesPrevPacket = *pcbDstUsed / pau->m_cChannel / sizeof (I16);

  0028a	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  0028d	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  00291	8b 55 20	 mov	 edx, DWORD PTR _pcbDstUsed$[ebp]
  00294	8b 02		 mov	 eax, DWORD PTR [edx]
  00296	99		 cdq
  00297	f7 f9		 idiv	 ecx
  00299	d1 e8		 shr	 eax, 1
  0029b	8b 4d 30	 mov	 ecx, DWORD PTR _pcSamplesPrevPacket$[ebp]
  0029e	89 01		 mov	 DWORD PTR [ecx], eax

; 722  :             fDoDecode = WMAB_FALSE;

  002a0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fDoDecode$[ebp], 0
$L3155:

; 723  : 
; 724  : #           if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
; 725  :             prvWmaShowFrames(paudec->pau, "\nDecPkt2", " %1d ", 
; 726  :                 paudec->m_cFrmInPacket );
; 727  : #           endif
; 728  : 
; 729  :         case CODEC_ONHOLD:
; 730  :             // If no superframes, WMA_S_NO_MORE_SRCDATA always happens at the end of
; 731  :             // each frame and should constitute an exit condition. If superframes,
; 732  :             // WMA_S_NO_MORE_SRCDATA should not exit this loop or we may not decode
; 733  :             // last frame.
; 734  :             while (WMAB_TRUE) 

  002a7	ba 01 00 00 00	 mov	 edx, 1
  002ac	85 d2		 test	 edx, edx
  002ae	0f 84 45 03 00
	00		 je	 $L3156

; 735  :             {
; 736  :                 HEAP_DEBUG_CHECK;
; 737  :                 hr = audecDecodeData (paudec, &cSampleDecoded);

  002b4	8d 45 ec	 lea	 eax, DWORD PTR _cSampleDecoded$[ebp]
  002b7	50		 push	 eax
  002b8	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  002bb	51		 push	 ecx
  002bc	e8 00 00 00 00	 call	 _audecDecodeData_XDS@8
  002c1	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 738  :                 HEAP_DEBUG_CHECK;
; 739  : 
; 740  :                 if (hr == WMA_E_ONHOLD)

  002c4	8b 55 e8	 mov	 edx, DWORD PTR _hr$[ebp]
  002c7	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  002cd	75 79		 jne	 SHORT $L3157

; 741  :                 {
; 742  :                     //remembers it
; 743  :                     pau->m_codecStatus = CODEC_ONHOLD; 

  002cf	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  002d2	c7 40 48 05 00
	00 00		 mov	 DWORD PTR [eax+72], 5

; 744  :                     //map it to okay
; 745  :                     TraceResult (hr = WMA_OK);

  002d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_OK
  002df	89 4d e8	 mov	 DWORD PTR _hr$[ebp], ecx
  002e2	8b 55 e8	 mov	 edx, DWORD PTR _hr$[ebp]
  002e5	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  002eb	74 48		 je	 SHORT $L3574
  002ed	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  002f2	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax
  002f5	8b 4d e8	 mov	 ecx, DWORD PTR _hr$[ebp]
  002f8	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  002fe	74 35		 je	 SHORT $L3574
  00300	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_OK
  00306	89 55 e8	 mov	 DWORD PTR _hr$[ebp], edx
  00309	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0030e	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax
  00311	8b 4d e8	 mov	 ecx, DWORD PTR _hr$[ebp]
  00314	51		 push	 ecx
  00315	68 e9 02 00 00	 push	 745			; 000002e9H
  0031a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  0031f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00324	8b 55 e8	 mov	 edx, DWORD PTR _hr$[ebp]
  00327	52		 push	 edx
  00328	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0032d	83 c4 14	 add	 esp, 20			; 00000014H
  00330	89 45 cc	 mov	 DWORD PTR tv183[ebp], eax
  00333	eb 0e		 jmp	 SHORT $L3575
$L3574:
  00335	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0033a	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax
  0033d	8b 4d e8	 mov	 ecx, DWORD PTR _hr$[ebp]
  00340	89 4d cc	 mov	 DWORD PTR tv183[ebp], ecx
$L3575:

; 746  :                     goto exit;

  00343	e9 c0 02 00 00	 jmp	 $exit$3148
$L3157:

; 747  :                 }
; 748  :                 else if (hr == WMA_E_BROKEN_FRAME)

  00348	8b 55 e8	 mov	 edx, DWORD PTR _hr$[ebp]
  0034b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  00351	75 78		 jne	 SHORT $L3159

; 749  :                 {
; 750  :                     audecReset (paudec);

  00353	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00356	50		 push	 eax
  00357	e8 00 00 00 00	 call	 _audecReset_XDS@4

; 751  :                     TraceResult (hr = WMA_OK);

  0035c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_OK
  00362	89 4d e8	 mov	 DWORD PTR _hr$[ebp], ecx
  00365	8b 55 e8	 mov	 edx, DWORD PTR _hr$[ebp]
  00368	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  0036e	74 48		 je	 SHORT $L3576
  00370	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  00375	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax
  00378	8b 4d e8	 mov	 ecx, DWORD PTR _hr$[ebp]
  0037b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  00381	74 35		 je	 SHORT $L3576
  00383	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_OK
  00389	89 55 e8	 mov	 DWORD PTR _hr$[ebp], edx
  0038c	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  00391	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax
  00394	8b 4d e8	 mov	 ecx, DWORD PTR _hr$[ebp]
  00397	51		 push	 ecx
  00398	68 ef 02 00 00	 push	 751			; 000002efH
  0039d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  003a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  003a7	8b 55 e8	 mov	 edx, DWORD PTR _hr$[ebp]
  003aa	52		 push	 edx
  003ab	e8 00 00 00 00	 call	 _MyOutputDbgStr
  003b0	83 c4 14	 add	 esp, 20			; 00000014H
  003b3	89 45 c8	 mov	 DWORD PTR tv194[ebp], eax
  003b6	eb 0e		 jmp	 SHORT $L3577
$L3576:
  003b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  003bd	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax
  003c0	8b 4d e8	 mov	 ecx, DWORD PTR _hr$[ebp]
  003c3	89 4d c8	 mov	 DWORD PTR tv194[ebp], ecx
$L3577:

; 752  :                     goto exit;  //bits will be advanced

  003c6	e9 3d 02 00 00	 jmp	 $exit$3148
$L3159:

; 753  :                 }
; 754  :                 else if (hr == WMA_E_LOSTPACKET)

  003cb	8b 55 e8	 mov	 edx, DWORD PTR _hr$[ebp]
  003ce	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_LOSTPACKET
  003d4	75 71		 jne	 SHORT $L3158

; 755  :                 {
; 756  :                     TraceResult (hr = WMA_OK);

  003d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  003db	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax
  003de	8b 4d e8	 mov	 ecx, DWORD PTR _hr$[ebp]
  003e1	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  003e7	74 4a		 je	 SHORT $L3578
  003e9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_OK
  003ef	89 55 e8	 mov	 DWORD PTR _hr$[ebp], edx
  003f2	8b 45 e8	 mov	 eax, DWORD PTR _hr$[ebp]
  003f5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  003fb	74 36		 je	 SHORT $L3578
  003fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_OK
  00403	89 4d e8	 mov	 DWORD PTR _hr$[ebp], ecx
  00406	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_OK
  0040c	89 55 e8	 mov	 DWORD PTR _hr$[ebp], edx
  0040f	8b 45 e8	 mov	 eax, DWORD PTR _hr$[ebp]
  00412	50		 push	 eax
  00413	68 f4 02 00 00	 push	 756			; 000002f4H
  00418	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  0041d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00422	8b 4d e8	 mov	 ecx, DWORD PTR _hr$[ebp]
  00425	51		 push	 ecx
  00426	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0042b	83 c4 14	 add	 esp, 20			; 00000014H
  0042e	89 45 c4	 mov	 DWORD PTR tv204[ebp], eax
  00431	eb 0f		 jmp	 SHORT $L3579
$L3578:
  00433	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_OK
  00439	89 55 e8	 mov	 DWORD PTR _hr$[ebp], edx
  0043c	8b 45 e8	 mov	 eax, DWORD PTR _hr$[ebp]
  0043f	89 45 c4	 mov	 DWORD PTR tv204[ebp], eax
$L3579:

; 757  :                     break;      //try it again will call decodeInfo next round

  00442	e9 b2 01 00 00	 jmp	 $L3156
$L3158:

; 758  :                 }
; 759  : 
; 760  :                 CHECKWMA_EXIT(hr);

  00447	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0044b	7d 45		 jge	 SHORT $L3164
  0044d	8b 4d e8	 mov	 ecx, DWORD PTR _hr$[ebp]
  00450	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  00456	74 2f		 je	 SHORT $L3580
  00458	8b 55 e8	 mov	 edx, DWORD PTR _hr$[ebp]
  0045b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  00461	74 24		 je	 SHORT $L3580
  00463	8b 45 e8	 mov	 eax, DWORD PTR _hr$[ebp]
  00466	50		 push	 eax
  00467	68 f8 02 00 00	 push	 760			; 000002f8H
  0046c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00471	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00476	8b 4d e8	 mov	 ecx, DWORD PTR _hr$[ebp]
  00479	51		 push	 ecx
  0047a	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0047f	83 c4 14	 add	 esp, 20			; 00000014H
  00482	89 45 c0	 mov	 DWORD PTR tv214[ebp], eax
  00485	eb 06		 jmp	 SHORT $L3581
$L3580:
  00487	8b 55 e8	 mov	 edx, DWORD PTR _hr$[ebp]
  0048a	89 55 c0	 mov	 DWORD PTR tv214[ebp], edx
$L3581:
  0048d	e9 76 01 00 00	 jmp	 $exit$3148
$L3164:

; 761  : 
; 762  : #               if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
; 763  :                 prvWmaShowFrames(pau, "GetPCM2", " %4d 0x%08x %6d     @%8d",
; 764  :                     cSampleDecoded, pbDst, cbDstLength - *pcbDstUsed, iSampleTotal);
; 765  : #               endif
; 766  : 
; 767  :                 HEAP_DEBUG_CHECK;
; 768  :                 audecGetPCM (paudec, &cSampleDecoded, pbDst, cbDstLength - *pcbDstUsed);

  00492	8b 45 20	 mov	 eax, DWORD PTR _pcbDstUsed$[ebp]
  00495	8b 4d 1c	 mov	 ecx, DWORD PTR _cbDstLength$[ebp]
  00498	2b 08		 sub	 ecx, DWORD PTR [eax]
  0049a	51		 push	 ecx
  0049b	8b 55 18	 mov	 edx, DWORD PTR _pbDst$[ebp]
  0049e	52		 push	 edx
  0049f	8d 45 ec	 lea	 eax, DWORD PTR _cSampleDecoded$[ebp]
  004a2	50		 push	 eax
  004a3	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  004a6	51		 push	 ecx
  004a7	e8 00 00 00 00	 call	 _audecGetPCM_XDS@16

; 769  :                 HEAP_DEBUG_CHECK;
; 770  : 
; 771  : #               if defined(_DEBUG)
; 772  :                 assert(pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame >= pau->m_iCoefRecurQ3);
; 773  :                 iSampleTotal += cSampleDecoded;

  004ac	0f b7 55 ec	 movzx	 edx, WORD PTR _cSampleDecoded$[ebp]
  004b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _iSampleTotal
  004b5	03 c2		 add	 eax, edx
  004b7	a3 00 00 00 00	 mov	 DWORD PTR _iSampleTotal, eax

; 774  : #               endif
; 775  :                 cSampleDecoded *= sizeof (I16) * paudec->pau->m_cChannel; //in bytes

  004bc	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  004bf	8b 11		 mov	 edx, DWORD PTR [ecx]
  004c1	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  004c5	d1 e0		 shl	 eax, 1
  004c7	0f b7 4d ec	 movzx	 ecx, WORD PTR _cSampleDecoded$[ebp]
  004cb	0f af c8	 imul	 ecx, eax
  004ce	66 89 4d ec	 mov	 WORD PTR _cSampleDecoded$[ebp], cx

; 776  :                 //when seeking, we can return the 1st half of the subframe
; 777  :                 //whose begining the packet timestamp points to 
; 778  :                 //we use this negative number as a workaround
; 779  :                 if (pau->m_fSeekAdjustment && pau->m_fAllowSuperFrame)

  004d2	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  004d5	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  004d9	74 26		 je	 SHORT $L3166
  004db	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  004de	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  004e2	74 1d		 je	 SHORT $L3166

; 780  :                 {
; 781  :                     *pcSamplesPrevPacket -= pau->m_cSubFrameSampleHalfAdjusted;

  004e4	8b 4d 30	 mov	 ecx, DWORD PTR _pcSamplesPrevPacket$[ebp]
  004e7	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  004ea	8b 01		 mov	 eax, DWORD PTR [ecx]
  004ec	2b 82 9c 00 00
	00		 sub	 eax, DWORD PTR [edx+156]
  004f2	8b 4d 30	 mov	 ecx, DWORD PTR _pcSamplesPrevPacket$[ebp]
  004f5	89 01		 mov	 DWORD PTR [ecx], eax

; 782  :                     pau->m_fSeekAdjustment = WMAB_FALSE;

  004f7	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  004fa	c7 42 4c 00 00
	00 00		 mov	 DWORD PTR [edx+76], 0
$L3166:

; 783  :                 }
; 784  : 
; 785  :                 pbDst           += cSampleDecoded;

  00501	0f b7 45 ec	 movzx	 eax, WORD PTR _cSampleDecoded$[ebp]
  00505	8b 4d 18	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  00508	03 c8		 add	 ecx, eax
  0050a	89 4d 18	 mov	 DWORD PTR _pbDst$[ebp], ecx

; 786  :                 *pcbDstUsed     += cSampleDecoded;

  0050d	0f b7 55 ec	 movzx	 edx, WORD PTR _cSampleDecoded$[ebp]
  00511	8b 45 20	 mov	 eax, DWORD PTR _pcbDstUsed$[ebp]
  00514	03 10		 add	 edx, DWORD PTR [eax]
  00516	8b 4d 20	 mov	 ecx, DWORD PTR _pcbDstUsed$[ebp]
  00519	89 11		 mov	 DWORD PTR [ecx], edx

; 787  :                 assert (*pcbDstUsed <= cbDstLength);
; 788  :                 if (*pcbDstUsed > cbDstLength)          //out of space

  0051b	8b 55 20	 mov	 edx, DWORD PTR _pcbDstUsed$[ebp]
  0051e	8b 02		 mov	 eax, DWORD PTR [edx]
  00520	3b 45 1c	 cmp	 eax, DWORD PTR _cbDstLength$[ebp]
  00523	7e 56		 jle	 SHORT $L3167

; 789  :                 {
; 790  :                     //FUNCTION_PROFILE_STOP(&fp);
; 791  :                     return TraceResult(WMA_E_BUFFEROVERFLOW);

  00525	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BUFFEROVERFLOW
  0052b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  00531	74 37		 je	 SHORT $L3582
  00533	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BUFFEROVERFLOW
  00539	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  0053f	74 29		 je	 SHORT $L3582
  00541	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BUFFEROVERFLOW
  00546	50		 push	 eax
  00547	68 17 03 00 00	 push	 791			; 00000317H
  0054c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00551	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00556	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BUFFEROVERFLOW
  0055c	51		 push	 ecx
  0055d	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00562	83 c4 14	 add	 esp, 20			; 00000014H
  00565	89 45 bc	 mov	 DWORD PTR tv248[ebp], eax
  00568	eb 09		 jmp	 SHORT $L3583
$L3582:
  0056a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BUFFEROVERFLOW
  00570	89 55 bc	 mov	 DWORD PTR tv248[ebp], edx
$L3583:
  00573	8b 45 bc	 mov	 eax, DWORD PTR tv248[ebp]
  00576	e9 a4 00 00 00	 jmp	 $L3117
$L3167:

; 792  :                 }
; 793  : #ifdef ENABLE_EQUALIZER        
; 794  :                 if (paudec->m_fLastSubFrame)    
; 795  :                 {
; 796  :                     if (NULL != pbEqu && paudec->m_fComputeBandPower) 
; 797  :                     {
; 798  :                         Int cbEquUsedFrame = sizeof (I8) * MAX_NO_EQBAND;
; 799  :                         memcpy (pbEqu, paudec->m_rgbBandPower, cbEquUsedFrame);
; 800  :                         pbEqu       += cbEquUsedFrame;
; 801  :                         cbEquLength -= cbEquUsedFrame;
; 802  :                         if (NULL != pcbEquUsed)
; 803  :                             *pcbEquUsed += cbEquUsedFrame;
; 804  :                     }
; 805  :                 }
; 806  : #endif
; 807  : 
; 808  :                 if (cIteration > pau->m_iMaxSubFrameDiv * 0x0F)

  0057b	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  0057e	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00584	6b c9 0f	 imul	 ecx, 15			; 0000000fH
  00587	39 4d f0	 cmp	 DWORD PTR _cIteration$[ebp], ecx
  0058a	7e 52		 jle	 SHORT $L3168

; 809  :                     return TraceResult(WMA_E_BROKEN_FRAME);              //never overflow the stack

  0058c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  00592	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  00598	74 37		 je	 SHORT $L3584
  0059a	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  0059f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  005a5	74 2a		 je	 SHORT $L3584
  005a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  005ad	51		 push	 ecx
  005ae	68 29 03 00 00	 push	 809			; 00000329H
  005b3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  005b8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  005bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  005c3	52		 push	 edx
  005c4	e8 00 00 00 00	 call	 _MyOutputDbgStr
  005c9	83 c4 14	 add	 esp, 20			; 00000014H
  005cc	89 45 b8	 mov	 DWORD PTR tv260[ebp], eax
  005cf	eb 08		 jmp	 SHORT $L3585
$L3584:
  005d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  005d6	89 45 b8	 mov	 DWORD PTR tv260[ebp], eax
$L3585:
  005d9	8b 45 b8	 mov	 eax, DWORD PTR tv260[ebp]
  005dc	eb 41		 jmp	 SHORT $L3117
$L3168:

; 810  :                 else 
; 811  :                 {
; 812  :                     cIteration++;

  005de	8b 4d f0	 mov	 ecx, DWORD PTR _cIteration$[ebp]
  005e1	83 c1 01	 add	 ecx, 1
  005e4	89 4d f0	 mov	 DWORD PTR _cIteration$[ebp], ecx

; 813  :                     if (hr == WMA_S_NO_MORE_FRAME)

  005e7	8b 55 e8	 mov	 edx, DWORD PTR _hr$[ebp]
  005ea	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_S_NO_MORE_FRAME
  005f0	75 02		 jne	 SHORT $L3169

; 814  :                         break;

  005f2	eb 05		 jmp	 SHORT $L3156
$L3169:

; 815  :                 }
; 816  :             }

  005f4	e9 ae fc ff ff	 jmp	 $L3155
$L3156:

; 817  :             pau->m_codecStatus = CODEC_STEADY;

  005f9	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  005fc	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [eax+72], 1
$L3141:

; 818  :         }
; 819  :     }

  00603	e9 99 fb ff ff	 jmp	 $L3138
$exit$3148:

; 820  : 
; 821  : exit:
; 822  :     // always tell them to give us the next packet.
; 823  :     *pcbSrcUsed = pau->m_cBitPacketLength/BITS_PER_BYTE;

  00608	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  0060b	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0060e	99		 cdq
  0060f	83 e2 07	 and	 edx, 7
  00612	03 c2		 add	 eax, edx
  00614	c1 f8 03	 sar	 eax, 3
  00617	8b 55 14	 mov	 edx, DWORD PTR _pcbSrcUsed$[ebp]
  0061a	89 02		 mov	 DWORD PTR [edx], eax

; 824  : 
; 825  :     //FUNCTION_PROFILE_STOP(&fp);
; 826  :     HEAP_DEBUG_CHECK;
; 827  :     return hr;

  0061c	8b 45 e8	 mov	 eax, DWORD PTR _hr$[ebp]
$L3117:

; 828  : }

  0061f	8b e5		 mov	 esp, ebp
  00621	5d		 pop	 ebp
  00622	c2 2c 00	 ret	 44			; 0000002cH
_prvDecodePacket_XDS@44 ENDP
WMADEC	ENDS
PUBLIC	_ibstrmGetPacketHeader@4
EXTRN	_ibstrmResetPacket@4:NEAR
EXTRN	_ibstrmGetMoreData@8:NEAR
EXTRN	_ibstrmFlushBits@8:NEAR
; Function compile flags: /Odt
;	COMDAT _audecDecodeInfo_XDS@4
WMADEC	SEGMENT
tv246 = -68
tv231 = -64
tv192 = -60
tv88 = -56
_ppcinfo$3228 = -52
_c_iSizeOfPrevOutput$3212 = -48
_c_iSizeOfPrevOutputSign$3214 = -44
_pau$3210 = -40
_i$3211 = -36
_iBufLen$3202 = -32
_iCurrPrevDiff$3195 = -28
_iBufLen$3183 = -24
_cBitRs$ = -20
_cBitLeftOver$ = -16
_wmaResult$ = -12
_cBitLs$ = -8
_iPacketCurr$ = -4
_paudec$ = 8
_audecDecodeInfo_XDS@4 PROC NEAR			; COMDAT

; 836  : {   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H

; 837  :     Int iPacketCurr;
; 838  :     Int cBitLeftOver = 0;

  00006	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _cBitLeftOver$[ebp], 0

; 839  :     Int cBitLs, cBitRs;
; 840  :     WMARESULT   wmaResult = WMA_OK;

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  00012	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 841  : 
; 842  :     paudec->m_decsts = BEGIN_PACKET;

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00018	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 843  :     paudec->m_fPacketLoss = WMAB_FALSE;

  0001f	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00022	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 844  :     paudec->m_cFrmInPacket = 1;

  00029	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0002c	66 c7 40 08 01
	00		 mov	 WORD PTR [eax+8], 1

; 845  : 
; 846  :     if (paudec->pau->m_fAllowSuperFrame) 

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	83 7a 64 00	 cmp	 DWORD PTR [edx+100], 0
  0003b	0f 84 85 01 00
	00		 je	 $L3179
$L3181:

; 847  :     {
; 848  :         //no left over
; 849  :         while(ibstrmGetPacketHeader(&paudec->m_ibstrm) == 0) 

  00041	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00044	83 c0 30	 add	 eax, 48			; 00000030H
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _ibstrmGetPacketHeader@4
  0004d	85 c0		 test	 eax, eax
  0004f	0f 85 86 00 00
	00		 jne	 $L3182

; 850  :         {
; 851  :             U32         iBufLen;
; 852  : 
; 853  :             ibstrmReset(&paudec->m_ibstrm);

  00055	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00058	83 c1 30	 add	 ecx, 48			; 00000030H
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _ibstrmReset@4

; 854  :             TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData(&paudec->m_ibstrm, &iBufLen));

  00061	8d 55 e8	 lea	 edx, DWORD PTR _iBufLen$3183[ebp]
  00064	52		 push	 edx
  00065	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00068	83 c0 30	 add	 eax, 48			; 00000030H
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _ibstrmGetMoreData@8
  00071	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00074	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00078	7d 45		 jge	 SHORT $L3187
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0007d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  00083	74 2f		 je	 SHORT $L3589
  00085	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00088	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  0008e	74 24		 je	 SHORT $L3589
  00090	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00093	50		 push	 eax
  00094	68 56 03 00 00	 push	 854			; 00000356H
  00099	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  0009e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  000a3	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 _MyOutputDbgStr
  000ac	83 c4 14	 add	 esp, 20			; 00000014H
  000af	89 45 c8	 mov	 DWORD PTR tv88[ebp], eax
  000b2	eb 06		 jmp	 SHORT $L3590
$L3589:
  000b4	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000b7	89 55 c8	 mov	 DWORD PTR tv88[ebp], edx
$L3590:
  000ba	e9 d0 03 00 00	 jmp	 $exit$3186
$L3187:

; 855  : 
; 856  :             if(paudec->m_fNoMoreData)

  000bf	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  000c2	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  000c6	74 0e		 je	 SHORT $L3188

; 857  :             {
; 858  :                 //wmaResult = WMA_S_NO_MORE_SRCDATA;
; 859  :                 //theoretically we can be on-hold but not tested as apps don't do this
; 860  :                 wmaResult = WMA_E_ONHOLD;

  000c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_ONHOLD
  000ce	89 4d f4	 mov	 DWORD PTR _wmaResult$[ebp], ecx

; 861  :                 goto exit;

  000d1	e9 b9 03 00 00	 jmp	 $exit$3186
$L3188:

; 862  :             }
; 863  :         }

  000d6	e9 66 ff ff ff	 jmp	 $L3181
$L3182:

; 864  : 
; 865  :         cBitLs = 0;

  000db	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cBitLs$[ebp], 0

; 866  :         cBitRs = (BITS_PER_DWORD - NBITS_PACKET_CNT);

  000e2	c7 45 ec 1c 00
	00 00		 mov	 DWORD PTR _cBitRs$[ebp], 28 ; 0000001cH

; 867  :         iPacketCurr = ibstrmGetPacketHeader(&paudec->m_ibstrm) >> cBitRs;

  000e9	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  000ec	83 c2 30	 add	 edx, 48			; 00000030H
  000ef	52		 push	 edx
  000f0	e8 00 00 00 00	 call	 _ibstrmGetPacketHeader@4
  000f5	8b 4d ec	 mov	 ecx, DWORD PTR _cBitRs$[ebp]
  000f8	d3 e8		 shr	 eax, cl
  000fa	89 45 fc	 mov	 DWORD PTR _iPacketCurr$[ebp], eax

; 868  :         if (iPacketCurr - paudec->pau->m_iPacketCurr == 1 || 
; 869  :             iPacketCurr - paudec->pau->m_iPacketCurr + (1 << NBITS_PACKET_CNT) == 1) {

  000fd	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00100	8b 08		 mov	 ecx, DWORD PTR [eax]
  00102	8b 55 fc	 mov	 edx, DWORD PTR _iPacketCurr$[ebp]
  00105	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00108	83 fa 01	 cmp	 edx, 1
  0010b	74 13		 je	 SHORT $L3190
  0010d	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00110	8b 08		 mov	 ecx, DWORD PTR [eax]
  00112	8b 55 fc	 mov	 edx, DWORD PTR _iPacketCurr$[ebp]
  00115	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00118	83 c2 10	 add	 edx, 16			; 00000010H
  0011b	83 fa 01	 cmp	 edx, 1
  0011e	75 0c		 jne	 SHORT $L3189
$L3190:

; 870  :             paudec->m_fPacketLoss = WMAB_FALSE;

  00120	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00123	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 871  :         }
; 872  :         else 

  0012a	eb 0a		 jmp	 SHORT $L3191
$L3189:

; 873  :             paudec->m_fPacketLoss = WMAB_TRUE;

  0012c	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0012f	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
$L3191:

; 874  :         paudec->pau->m_iPacketCurr = iPacketCurr;

  00136	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00139	8b 02		 mov	 eax, DWORD PTR [edx]
  0013b	8b 4d fc	 mov	 ecx, DWORD PTR _iPacketCurr$[ebp]
  0013e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 875  : 
; 876  :         cBitLs = NBITS_FRM_CNT;

  00141	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _cBitLs$[ebp], 4

; 877  :         cBitRs = BITS_PER_DWORD - NBITS_FRM_CNT;

  00148	c7 45 ec 1c 00
	00 00		 mov	 DWORD PTR _cBitRs$[ebp], 28 ; 0000001cH

; 878  :         paudec->m_cFrmInPacket = (U16) ((ibstrmGetPacketHeader(&paudec->m_ibstrm) 
; 879  :                                  << cBitLs) >> cBitRs);

  0014f	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00152	83 c2 30	 add	 edx, 48			; 00000030H
  00155	52		 push	 edx
  00156	e8 00 00 00 00	 call	 _ibstrmGetPacketHeader@4
  0015b	8b 4d f8	 mov	 ecx, DWORD PTR _cBitLs$[ebp]
  0015e	d3 e0		 shl	 eax, cl
  00160	8b 4d ec	 mov	 ecx, DWORD PTR _cBitRs$[ebp]
  00163	d3 e8		 shr	 eax, cl
  00165	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00168	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 880  :         assert (paudec->m_cFrmInPacket < (1 << NBITS_FRM_CNT));
; 881  : 
; 882  :         cBitLs = NBITS_PACKET_CNT + NBITS_FRM_CNT;

  0016c	c7 45 f8 08 00
	00 00		 mov	 DWORD PTR _cBitLs$[ebp], 8

; 883  :         cBitRs = BITS_PER_DWORD - (paudec->pau->m_cBitPackedFrameSize + 3); 

  00173	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00176	8b 02		 mov	 eax, DWORD PTR [edx]
  00178	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0017b	83 c1 03	 add	 ecx, 3
  0017e	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00183	2b d1		 sub	 edx, ecx
  00185	89 55 ec	 mov	 DWORD PTR _cBitRs$[ebp], edx

; 884  :         cBitLeftOver = (ibstrmGetPacketHeader(&paudec->m_ibstrm) << cBitLs) >> cBitRs;

  00188	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0018b	83 c0 30	 add	 eax, 48			; 00000030H
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 _ibstrmGetPacketHeader@4
  00194	8b 4d f8	 mov	 ecx, DWORD PTR _cBitLs$[ebp]
  00197	d3 e0		 shl	 eax, cl
  00199	8b 4d ec	 mov	 ecx, DWORD PTR _cBitRs$[ebp]
  0019c	d3 e8		 shr	 eax, cl
  0019e	89 45 f0	 mov	 DWORD PTR _cBitLeftOver$[ebp], eax

; 885  :         if (cBitLeftOver == 0) 

  001a1	83 7d f0 00	 cmp	 DWORD PTR _cBitLeftOver$[ebp], 0
  001a5	75 0c		 jne	 SHORT $L3193

; 886  :             ibstrmResetPacket(&paudec->m_ibstrm);

  001a7	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  001aa	83 c1 30	 add	 ecx, 48			; 00000030H
  001ad	51		 push	 ecx
  001ae	e8 00 00 00 00	 call	 _ibstrmResetPacket@4
$L3193:

; 887  :         ibstrmSetPacketHeader(&paudec->m_ibstrm, 0);

  001b3	6a 00		 push	 0
  001b5	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  001b8	83 c2 30	 add	 edx, 48			; 00000030H
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 _ibstrmSetPacketHeader@8

; 888  :     }
; 889  :     else 

  001c1	e9 13 01 00 00	 jmp	 $L3194
$L3179:

; 890  :     {
; 891  :         Int iCurrPrevDiff;
; 892  : 
; 893  :         // We should only hit this on very first frame
; 894  :         if (paudec->pau->m_iPacketCurr < 0)

  001c6	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  001c9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cb	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  001cf	7d 14		 jge	 SHORT $L3196

; 895  :         {
; 896  :             assert(ibstrmGetPacketHeader(&paudec->m_ibstrm) == 0);
; 897  :             paudec->pau->m_iPacketCurr = ibstrmGetPacketHeader(&paudec->m_ibstrm);

  001d1	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  001d4	83 c2 30	 add	 edx, 48			; 00000030H
  001d7	52		 push	 edx
  001d8	e8 00 00 00 00	 call	 _ibstrmGetPacketHeader@4
  001dd	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  001e0	8b 11		 mov	 edx, DWORD PTR [ecx]
  001e2	89 42 04	 mov	 DWORD PTR [edx+4], eax
$L3196:

; 898  :         }
; 899  : 
; 900  :         iCurrPrevDiff = ibstrmGetPacketHeader(&paudec->m_ibstrm) -
; 901  :             paudec->pau->m_iPacketCurr;

  001e5	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  001e8	83 c0 30	 add	 eax, 48			; 00000030H
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 _ibstrmGetPacketHeader@4
  001f1	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  001f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  001f6	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  001f9	89 45 e4	 mov	 DWORD PTR _iCurrPrevDiff$3195[ebp], eax

; 902  : 
; 903  :         // Non-superframe mode can't really lose packets
; 904  :         assert(iCurrPrevDiff >= 0 || iCurrPrevDiff <= 1 - NONSUPER_WRAPAROUND);
; 905  :         assert(iCurrPrevDiff < 0 || iCurrPrevDiff <= 1);
; 906  :         assert(iCurrPrevDiff >= 0 || NONSUPER_WRAPAROUND + iCurrPrevDiff <= 1);
; 907  : 
; 908  :         // If, while processing the last frame we loaded in the start of next frame,
; 909  :         // cue bitstream pointer to start of next frame
; 910  :         if (iCurrPrevDiff != 0)

  001fc	83 7d e4 00	 cmp	 DWORD PTR _iCurrPrevDiff$3195[ebp], 0
  00200	74 0c		 je	 SHORT $L3200

; 911  :             ibstrmResetPacket(&paudec->m_ibstrm);

  00202	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00205	83 c0 30	 add	 eax, 48			; 00000030H
  00208	50		 push	 eax
  00209	e8 00 00 00 00	 call	 _ibstrmResetPacket@4
$L3200:

; 912  : 
; 913  :         // Advance to next payload: discard data until we hit next frame
; 914  :         while (ibstrmGetPacketHeader(&paudec->m_ibstrm) == (U32)paudec->pau->m_iPacketCurr)

  0020e	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00211	83 c1 30	 add	 ecx, 48			; 00000030H
  00214	51		 push	 ecx
  00215	e8 00 00 00 00	 call	 _ibstrmGetPacketHeader@4
  0021a	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0021d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0021f	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00222	0f 85 86 00 00
	00		 jne	 $L3201

; 915  :         {
; 916  :             U32 iBufLen;
; 917  : 
; 918  :             ibstrmReset(&paudec->m_ibstrm);

  00228	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0022b	83 c2 30	 add	 edx, 48			; 00000030H
  0022e	52		 push	 edx
  0022f	e8 00 00 00 00	 call	 _ibstrmReset@4

; 919  :             TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData(&paudec->m_ibstrm, &iBufLen));

  00234	8d 45 e0	 lea	 eax, DWORD PTR _iBufLen$3202[ebp]
  00237	50		 push	 eax
  00238	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0023b	83 c1 30	 add	 ecx, 48			; 00000030H
  0023e	51		 push	 ecx
  0023f	e8 00 00 00 00	 call	 _ibstrmGetMoreData@8
  00244	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00247	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  0024b	7d 45		 jge	 SHORT $L3205
  0024d	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00250	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  00256	74 2f		 je	 SHORT $L3591
  00258	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  0025b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00261	74 24		 je	 SHORT $L3591
  00263	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00266	51		 push	 ecx
  00267	68 97 03 00 00	 push	 919			; 00000397H
  0026c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00271	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00276	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00279	52		 push	 edx
  0027a	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0027f	83 c4 14	 add	 esp, 20			; 00000014H
  00282	89 45 c4	 mov	 DWORD PTR tv192[ebp], eax
  00285	eb 06		 jmp	 SHORT $L3592
$L3591:
  00287	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  0028a	89 45 c4	 mov	 DWORD PTR tv192[ebp], eax
$L3592:
  0028d	e9 fd 01 00 00	 jmp	 $exit$3186
$L3205:

; 920  : 
; 921  :             if(paudec->m_fNoMoreData)

  00292	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00295	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  00299	74 0e		 je	 SHORT $L3206

; 922  :             {
; 923  :                 //wmaResult = WMA_S_NO_MORE_SRCDATA;
; 924  :                 wmaResult = WMA_E_ONHOLD;

  0029b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_ONHOLD
  002a1	89 55 f4	 mov	 DWORD PTR _wmaResult$[ebp], edx

; 925  :                 goto exit;

  002a4	e9 e6 01 00 00	 jmp	 $exit$3186
$L3206:

; 926  :             }
; 927  :         }

  002a9	e9 60 ff ff ff	 jmp	 $L3200
$L3201:

; 928  : 
; 929  :         paudec->pau->m_iPacketCurr = ibstrmGetPacketHeader(&paudec->m_ibstrm);

  002ae	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  002b1	83 c0 30	 add	 eax, 48			; 00000030H
  002b4	50		 push	 eax
  002b5	e8 00 00 00 00	 call	 _ibstrmGetPacketHeader@4
  002ba	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  002bd	8b 11		 mov	 edx, DWORD PTR [ecx]
  002bf	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 930  : 
; 931  :         if(paudec->m_fNoMoreData)

  002c2	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  002c5	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  002c9	74 0e		 je	 SHORT $L3194

; 932  :         {
; 933  :             //wmaResult = WMA_S_NO_MORE_SRCDATA;
; 934  :             wmaResult = WMA_E_FAIL;

  002cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_FAIL
  002d1	89 4d f4	 mov	 DWORD PTR _wmaResult$[ebp], ecx

; 935  :             goto exit;

  002d4	e9 b6 01 00 00	 jmp	 $exit$3186
$L3194:

; 936  :         }
; 937  :     }
; 938  : 
; 939  :     if (paudec->m_fPacketLoss == WMAB_FALSE)

  002d9	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  002dc	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  002e0	75 0d		 jne	 SHORT $L3208

; 940  :     {
; 941  :         wmaResult = WMA_OK;

  002e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  002e7	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 942  :         goto exit;

  002ea	e9 a0 01 00 00	 jmp	 $exit$3186
$L3208:

; 943  :     }
; 944  :     else    {
; 945  :         CAudioObject* pau = paudec->pau;

  002ef	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  002f2	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f4	89 55 d8	 mov	 DWORD PTR _pau$3210[ebp], edx

; 946  :         I16 i;
; 947  :         const int c_iSizeOfPrevOutput = sizeof (I16) * DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel;

  002f7	8b 45 d8	 mov	 eax, DWORD PTR _pau$3210[ebp]
  002fa	8b 88 1c 03 00
	00		 mov	 ecx, DWORD PTR [eax+796]
  00300	d1 e1		 shl	 ecx, 1
  00302	8b 55 d8	 mov	 edx, DWORD PTR _pau$3210[ebp]
  00305	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  00309	0f af c8	 imul	 ecx, eax
  0030c	89 4d d0	 mov	 DWORD PTR _c_iSizeOfPrevOutput$3212[ebp], ecx

; 948  : #       ifndef PREVOUTPUT_16BITS
; 949  :             const int c_iSizeOfPrevOutputSign = DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel / BITS_PER_BYTE + pau->m_cChannel*sizeof(I16);

  0030f	8b 4d d8	 mov	 ecx, DWORD PTR _pau$3210[ebp]
  00312	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  00316	8b 45 d8	 mov	 eax, DWORD PTR _pau$3210[ebp]
  00319	8b 80 1c 03 00
	00		 mov	 eax, DWORD PTR [eax+796]
  0031f	0f af c2	 imul	 eax, edx
  00322	99		 cdq
  00323	83 e2 07	 and	 edx, 7
  00326	03 c2		 add	 eax, edx
  00328	c1 f8 03	 sar	 eax, 3
  0032b	8b 4d d8	 mov	 ecx, DWORD PTR _pau$3210[ebp]
  0032e	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  00332	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  00335	89 45 d4	 mov	 DWORD PTR _c_iSizeOfPrevOutputSign$3214[ebp], eax
$L3217:

; 950  : #       else 
; 951  :             const int c_iSizeOfPrevOutputSign = 0;
; 952  : #       endif
; 953  : 
; 954  :         //packet loss or a broken frame earlier, seek to next complete frm
; 955  :         while (cBitLeftOver > 24)   {

  00338	83 7d f0 18	 cmp	 DWORD PTR _cBitLeftOver$[ebp], 24 ; 00000018H
  0033c	7e 67		 jle	 SHORT $L3218

; 956  :             TRACEWMA_EXIT(wmaResult, ibstrmFlushBits (&paudec->m_ibstrm, 24));

  0033e	6a 18		 push	 24			; 00000018H
  00340	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00343	83 c1 30	 add	 ecx, 48			; 00000030H
  00346	51		 push	 ecx
  00347	e8 00 00 00 00	 call	 _ibstrmFlushBits@8
  0034c	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0034f	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00353	7d 45		 jge	 SHORT $L3221
  00355	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00358	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  0035e	74 2f		 je	 SHORT $L3593
  00360	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00363	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00369	74 24		 je	 SHORT $L3593
  0036b	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0036e	51		 push	 ecx
  0036f	68 bc 03 00 00	 push	 956			; 000003bcH
  00374	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00379	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0037e	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00381	52		 push	 edx
  00382	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00387	83 c4 14	 add	 esp, 20			; 00000014H
  0038a	89 45 c0	 mov	 DWORD PTR tv231[ebp], eax
  0038d	eb 06		 jmp	 SHORT $L3594
$L3593:
  0038f	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00392	89 45 c0	 mov	 DWORD PTR tv231[ebp], eax
$L3594:
  00395	e9 f5 00 00 00	 jmp	 $exit$3186
$L3221:

; 957  :             cBitLeftOver -= 24;

  0039a	8b 4d f0	 mov	 ecx, DWORD PTR _cBitLeftOver$[ebp]
  0039d	83 e9 18	 sub	 ecx, 24			; 00000018H
  003a0	89 4d f0	 mov	 DWORD PTR _cBitLeftOver$[ebp], ecx

; 958  :         }

  003a3	eb 93		 jmp	 SHORT $L3217
$L3218:

; 959  :         TRACEWMA_EXIT(wmaResult, ibstrmFlushBits (&paudec->m_ibstrm, cBitLeftOver));

  003a5	8b 55 f0	 mov	 edx, DWORD PTR _cBitLeftOver$[ebp]
  003a8	52		 push	 edx
  003a9	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  003ac	83 c0 30	 add	 eax, 48			; 00000030H
  003af	50		 push	 eax
  003b0	e8 00 00 00 00	 call	 _ibstrmFlushBits@8
  003b5	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  003b8	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  003bc	7d 45		 jge	 SHORT $L3224
  003be	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  003c1	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  003c7	74 2f		 je	 SHORT $L3595
  003c9	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  003cc	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  003d2	74 24		 je	 SHORT $L3595
  003d4	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  003d7	50		 push	 eax
  003d8	68 bf 03 00 00	 push	 959			; 000003bfH
  003dd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  003e2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  003e7	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  003ea	51		 push	 ecx
  003eb	e8 00 00 00 00	 call	 _MyOutputDbgStr
  003f0	83 c4 14	 add	 esp, 20			; 00000014H
  003f3	89 45 bc	 mov	 DWORD PTR tv246[ebp], eax
  003f6	eb 06		 jmp	 SHORT $L3596
$L3595:
  003f8	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  003fb	89 55 bc	 mov	 DWORD PTR tv246[ebp], edx
$L3596:
  003fe	e9 8c 00 00 00	 jmp	 $exit$3186
$L3224:

; 960  : 
; 961  :         for (i = 0; i < pau->m_cChannel; i++)

  00403	66 c7 45 dc 00
	00		 mov	 WORD PTR _i$3211[ebp], 0
  00409	eb 0c		 jmp	 SHORT $L3225
$L3226:
  0040b	66 8b 45 dc	 mov	 ax, WORD PTR _i$3211[ebp]
  0040f	66 05 01 00	 add	 ax, 1
  00413	66 89 45 dc	 mov	 WORD PTR _i$3211[ebp], ax
$L3225:
  00417	0f bf 4d dc	 movsx	 ecx, WORD PTR _i$3211[ebp]
  0041b	8b 55 d8	 mov	 edx, DWORD PTR _pau$3210[ebp]
  0041e	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  00422	3b c8		 cmp	 ecx, eax
  00424	7d 26		 jge	 SHORT $L3227

; 962  :         {
; 963  :             PerChannelInfo* ppcinfo = pau->m_rgpcinfo + i;

  00426	0f bf 4d dc	 movsx	 ecx, WORD PTR _i$3211[ebp]
  0042a	6b c9 70	 imul	 ecx, 112		; 00000070H
  0042d	8b 55 d8	 mov	 edx, DWORD PTR _pau$3210[ebp]
  00430	03 8a a0 03 00
	00		 add	 ecx, DWORD PTR [edx+928]
  00436	89 4d cc	 mov	 DWORD PTR _ppcinfo$3228[ebp], ecx

; 964  :             ppcinfo->m_iCurrGetPCM_SubFrame = (I16) pau->m_iCoefRecurQ3;

  00439	8b 45 cc	 mov	 eax, DWORD PTR _ppcinfo$3228[ebp]
  0043c	8b 4d d8	 mov	 ecx, DWORD PTR _pau$3210[ebp]
  0043f	66 8b 91 94 03
	00 00		 mov	 dx, WORD PTR [ecx+916]
  00446	66 89 50 38	 mov	 WORD PTR [eax+56], dx

; 965  :         }

  0044a	eb bf		 jmp	 SHORT $L3226
$L3227:

; 966  : 
; 967  :         if (pau->m_piPrevOutput != NULL)

  0044c	8b 45 d8	 mov	 eax, DWORD PTR _pau$3210[ebp]
  0044f	83 b8 b4 03 00
	00 00		 cmp	 DWORD PTR [eax+948], 0
  00456	74 1b		 je	 SHORT $L3231

; 968  :             memset (pau->m_piPrevOutput, 0, c_iSizeOfPrevOutput + c_iSizeOfPrevOutputSign);

  00458	8b 4d d0	 mov	 ecx, DWORD PTR _c_iSizeOfPrevOutput$3212[ebp]
  0045b	03 4d d4	 add	 ecx, DWORD PTR _c_iSizeOfPrevOutputSign$3214[ebp]
  0045e	51		 push	 ecx
  0045f	6a 00		 push	 0
  00461	8b 55 d8	 mov	 edx, DWORD PTR _pau$3210[ebp]
  00464	8b 82 b4 03 00
	00		 mov	 eax, DWORD PTR [edx+948]
  0046a	50		 push	 eax
  0046b	e8 00 00 00 00	 call	 _memset
  00470	83 c4 0c	 add	 esp, 12			; 0000000cH
$L3231:

; 969  : 
; 970  : 		//so that the 1st frame doesn't output anything
; 971  :         pau->m_fPacketLossAdj = WMAB_TRUE;

  00473	8b 4d d8	 mov	 ecx, DWORD PTR _pau$3210[ebp]
  00476	c7 41 50 01 00
	00 00		 mov	 DWORD PTR [ecx+80], 1

; 972  :         pau->m_fSeekAdjustment = WMAB_TRUE; //not relavent in streaming mode

  0047d	8b 55 d8	 mov	 edx, DWORD PTR _pau$3210[ebp]
  00480	c7 42 4c 01 00
	00 00		 mov	 DWORD PTR [edx+76], 1

; 973  : 
; 974  :         // Ignore packet loss, we're already set to deal with it
; 975  :         wmaResult = WMA_OK; // WMA_BROKEN_FRAME;

  00487	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0048c	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
$exit$3186:

; 976  :         goto exit;
; 977  :     }
; 978  : 
; 979  : exit:
; 980  :     return wmaResult;

  0048f	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 981  : }

  00492	8b e5		 mov	 esp, ebp
  00494	5d		 pop	 ebp
  00495	c2 04 00	 ret	 4
_audecDecodeInfo_XDS@4 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\decoder\strmdec_wma.h
WMADEC	ENDS
;	COMDAT _ibstrmGetPacketHeader@4
WMADEC	SEGMENT
_pibs$ = 8
_ibstrmGetPacketHeader@4 PROC NEAR			; COMDAT

; 92   :                         { return pibs->m_dwHeaderBuf; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  00006	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
_ibstrmGetPacketHeader@4 ENDP
WMADEC	ENDS
EXTRN	_auPreGetPCM_XDS@8:NEAR
EXTRN	_auSaveHistoryMono_XDS@12:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\msaudiodec.c
;	COMDAT _audecDecodeData_XDS@8
WMADEC	SEGMENT
tv173 = -40
tv144 = -36
tv83 = -32
tv80 = -28
_cBitUsed$ = -24
_iBufLen$ = -20
_hr$ = -16
_ppcinfo$ = -12
_iChannel$ = -8
_pau$ = -4
_paudec$ = 8
_pcSampleReady$ = 12
_audecDecodeData_XDS@8 PROC NEAR			; COMDAT

; 1037 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 1038 :     CAudioObject* pau = paudec->pau;

  00006	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d fc	 mov	 DWORD PTR _pau$[ebp], ecx

; 1039 :     PerChannelInfo* ppcinfo = pau->m_rgpcinfo;

  0000e	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00011	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  00017	89 45 f4	 mov	 DWORD PTR _ppcinfo$[ebp], eax

; 1040 :     WMARESULT hr = WMA_OK;

  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_OK
  00020	89 4d f0	 mov	 DWORD PTR _hr$[ebp], ecx

; 1041 :     I16 iChannel;
; 1042 :     Int cBitUsed = 0;

  00023	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _cBitUsed$[ebp], 0

; 1043 :     U32 iBufLen;
; 1044 : 
; 1045 : #ifdef PROFILE
; 1046 :     //FunctionProfile fp;
; 1047 :     //FunctionProfileStart(&fp,AUDEC_DECODE_DATA_PROFILE);
; 1048 : #endif
; 1049 : 
; 1050 : #if !defined(_Embedded_x86)
; 1051 : #if defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE))
; 1052 :     // This function may use the FFT. Therefore, on every call to this function,
; 1053 :     // we must check if the current thread has been initialized to use the Intel FFT.
; 1054 :     // This is because under the DMO, the thread which initialized us may not be the
; 1055 :     // thread that does the decoding.
; 1056 :     if (pau->m_fIntelFFT)
; 1057 :         auInitIntelFFT(pau, INTELFFT_INIT_THREAD);
; 1058 : #endif // defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE))
; 1059 : #endif // if !def embedded_x86
; 1060 : 
; 1061 :     *pcSampleReady = 0;

  0002a	8b 55 0c	 mov	 edx, DWORD PTR _pcSampleReady$[ebp]
  0002d	66 c7 02 00 00	 mov	 WORD PTR [edx], 0

; 1062 :     //if we are being resumed, we need to get the new data
; 1063 :     if (paudec->m_fNoMoreData)

  00032	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00035	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00039	74 13		 je	 SHORT $L3243

; 1064 :         TRACEWMA_EXIT(hr, ibstrmGetMoreData(&paudec->m_ibstrm, &iBufLen));

  0003b	8d 4d ec	 lea	 ecx, DWORD PTR _iBufLen$[ebp]
  0003e	51		 push	 ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00042	83 c2 30	 add	 edx, 48			; 00000030H
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 _ibstrmGetMoreData@8
  0004b	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
$L3243:
  0004e	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00052	7d 45		 jge	 SHORT $L3249
  00054	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  00057	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  0005d	74 2f		 je	 SHORT $L3603
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR _hr$[ebp]
  00062	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  00068	74 24		 je	 SHORT $L3603
  0006a	8b 55 f0	 mov	 edx, DWORD PTR _hr$[ebp]
  0006d	52		 push	 edx
  0006e	68 28 04 00 00	 push	 1064			; 00000428H
  00073	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00086	83 c4 14	 add	 esp, 20			; 00000014H
  00089	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax
  0008c	eb 06		 jmp	 SHORT $L3604
$L3603:
  0008e	8b 4d f0	 mov	 ecx, DWORD PTR _hr$[ebp]
  00091	89 4d e4	 mov	 DWORD PTR tv80[ebp], ecx
$L3604:
  00094	e9 15 03 00 00	 jmp	 $exit$3246
$L3249:

; 1065 : 
; 1066 :     while(1)

  00099	ba 01 00 00 00	 mov	 edx, 1
  0009e	85 d2		 test	 edx, edx
  000a0	0f 84 08 03 00
	00		 je	 $exit$3246

; 1067 :     {
; 1068 :         BITRATE_REPORT_VARS;
; 1069 :         switch (paudec->m_decsts)
; 1070 :         {

  000a6	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  000a9	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000ac	89 4d e0	 mov	 DWORD PTR tv83[ebp], ecx
  000af	83 7d e0 05	 cmp	 DWORD PTR tv83[ebp], 5
  000b3	0f 87 f0 02 00
	00		 ja	 $L3252
  000b9	8b 55 e0	 mov	 edx, DWORD PTR tv83[ebp]
  000bc	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L3609[edx*4]
$L3255:

; 1071 :             case BEGIN_SUBFRAME :
; 1072 :                 if (!paudec->m_fLastSubFrame) 

  000c3	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  000c6	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  000ca	0f 85 46 01 00
	00		 jne	 $L3256

; 1073 :                 {                   
; 1074 :                     for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)

  000d0	66 c7 45 f8 00
	00		 mov	 WORD PTR _iChannel$[ebp], 0
  000d6	eb 0c		 jmp	 SHORT $L3257
$L3258:
  000d8	66 8b 4d f8	 mov	 cx, WORD PTR _iChannel$[ebp]
  000dc	66 83 c1 01	 add	 cx, 1
  000e0	66 89 4d f8	 mov	 WORD PTR _iChannel$[ebp], cx
$L3257:
  000e4	0f bf 55 f8	 movsx	 edx, WORD PTR _iChannel$[ebp]
  000e8	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  000eb	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  000ef	3b d1		 cmp	 edx, ecx
  000f1	0f 8d ed 00 00
	00		 jge	 $L3259

; 1075 :                     {
; 1076 :                         ppcinfo = pau->m_rgpcinfo + iChannel;

  000f7	0f bf 55 f8	 movsx	 edx, WORD PTR _iChannel$[ebp]
  000fb	6b d2 70	 imul	 edx, 112		; 00000070H
  000fe	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00101	03 90 a0 03 00
	00		 add	 edx, DWORD PTR [eax+928]
  00107	89 55 f4	 mov	 DWORD PTR _ppcinfo$[ebp], edx

; 1077 :                         if (!(ppcinfo->m_iCurrGetPCM_SubFrame==pau->m_iCoefRecurQ3 || ppcinfo->m_iCurrGetPCM_SubFrame>=pau->m_iCoefRecurQ4))

  0010a	8b 4d f4	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  0010d	0f bf 51 38	 movsx	 edx, WORD PTR [ecx+56]
  00111	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00114	3b 90 94 03 00
	00		 cmp	 edx, DWORD PTR [eax+916]
  0011a	0f 84 96 00 00
	00		 je	 $L3260
  00120	8b 4d f4	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00123	0f bf 51 38	 movsx	 edx, WORD PTR [ecx+56]
  00127	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  0012a	3b 90 98 03 00
	00		 cmp	 edx, DWORD PTR [eax+920]
  00130	0f 8d 80 00 00
	00		 jge	 $L3260

; 1078 :                             CHECKWMA_EXIT( hr = WMA_E_BROKEN_FRAME );

  00136	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  0013c	89 4d f0	 mov	 DWORD PTR _hr$[ebp], ecx
  0013f	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00143	7d 71		 jge	 SHORT $L3260
  00145	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  0014b	89 55 f0	 mov	 DWORD PTR _hr$[ebp], edx
  0014e	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  00151	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00157	74 49		 je	 SHORT $L3605
  00159	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  0015f	89 4d f0	 mov	 DWORD PTR _hr$[ebp], ecx
  00162	8b 55 f0	 mov	 edx, DWORD PTR _hr$[ebp]
  00165	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  0016b	74 35		 je	 SHORT $L3605
  0016d	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  00172	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
  00175	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  0017b	89 4d f0	 mov	 DWORD PTR _hr$[ebp], ecx
  0017e	8b 55 f0	 mov	 edx, DWORD PTR _hr$[ebp]
  00181	52		 push	 edx
  00182	68 36 04 00 00	 push	 1078			; 00000436H
  00187	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  0018c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00191	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0019a	83 c4 14	 add	 esp, 20			; 00000014H
  0019d	89 45 dc	 mov	 DWORD PTR tv144[ebp], eax
  001a0	eb 0f		 jmp	 SHORT $L3606
$L3605:
  001a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  001a8	89 4d f0	 mov	 DWORD PTR _hr$[ebp], ecx
  001ab	8b 55 f0	 mov	 edx, DWORD PTR _hr$[ebp]
  001ae	89 55 dc	 mov	 DWORD PTR tv144[ebp], edx
$L3606:
  001b1	e9 f8 01 00 00	 jmp	 $exit$3246
$L3260:

; 1079 : 
; 1080 : #if 0 // TRANSCODER
; 1081 :                         // No PCM required (or available) when doing simple transcode
; 1082 :                         // *** TODO: Enable this code to enhance efficiency.
; 1083 :                         if (TT_SIMPLE != paudec->pau->m_ttTranscodeType)
; 1084 :                         {
; 1085 : #endif  // TRANSCODER
; 1086 :                         HEAP_DEBUG_CHECK;
; 1087 :                         hr = auSaveHistoryMono (pau, ppcinfo, WMAB_FALSE);

  001b6	6a 00		 push	 0
  001b8	8b 45 f4	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  001bb	50		 push	 eax
  001bc	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  001bf	51		 push	 ecx
  001c0	e8 00 00 00 00	 call	 _auSaveHistoryMono_XDS@12
  001c5	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 1088 :                         HEAP_DEBUG_CHECK;
; 1089 : 
; 1090 :                         // Effectively disable GetPCM in case we find broken frame or packet
; 1091 :                         // (stupid caller maps WMA_E_LOSTPACKET to WMA_OK and therefore
; 1092 :                         // will try to retrieve the PCM, in which case we must return nothing)
; 1093 :                         pau->m_rgpcinfo[iChannel].m_iCurrGetPCM_SubFrame = CURRGETPCM_INVALID;

  001c8	0f bf 55 f8	 movsx	 edx, WORD PTR _iChannel$[ebp]
  001cc	6b d2 70	 imul	 edx, 112		; 00000070H
  001cf	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  001d2	8b 88 a0 03 00
	00		 mov	 ecx, DWORD PTR [eax+928]
  001d8	66 c7 44 11 38
	ff 7f		 mov	 WORD PTR [ecx+edx+56], 32767 ; 00007fffH

; 1094 :                     }

  001df	e9 f4 fe ff ff	 jmp	 $L3258
$L3259:

; 1095 : 
; 1096 :                     BITRATE_REPORT_CHECKPT;
; 1097 :                     paudec->m_decsts = DECODE_SUBFRAME; 

  001e4	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  001e7	c7 42 14 03 00
	00 00		 mov	 DWORD PTR [edx+20], 3

; 1098 :                     paudec->m_subfrmdecsts = SUBFRM_HDR;

  001ee	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  001f1	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 1099 :                     paudec->m_hdrdecsts = HDR_SIZE;

  001f8	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  001fb	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 1100 :                     paudec->m_iChannel = 0;  

  00202	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00205	66 c7 42 24 00
	00		 mov	 WORD PTR [edx+36], 0

; 1101 :                     paudec->m_iBand = 0;     

  0020b	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0020e	66 c7 40 26 00
	00		 mov	 WORD PTR [eax+38], 0

; 1102 : 
; 1103 :                 }
; 1104 :                 else 

  00214	eb 0a		 jmp	 SHORT $L3265
$L3256:

; 1105 :                     paudec->m_decsts = END_SUBFRAME2;

  00216	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00219	c7 41 14 05 00
	00 00		 mov	 DWORD PTR [ecx+20], 5
$L3265:

; 1106 : 
; 1107 :             case DECODE_SUBFRAME :
; 1108 :                 TRACEWMA_EXIT(hr, (*(paudec->m_pfnDecodeSubFrame))(paudec, &cBitUsed));

  00220	8d 55 e8	 lea	 edx, DWORD PTR _cBitUsed$[ebp]
  00223	52		 push	 edx
  00224	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00227	50		 push	 eax
  00228	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0022b	ff 91 98 01 00
	00		 call	 DWORD PTR [ecx+408]
  00231	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
  00234	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00238	7d 45		 jge	 SHORT $L3268
  0023a	8b 55 f0	 mov	 edx, DWORD PTR _hr$[ebp]
  0023d	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  00243	74 2f		 je	 SHORT $L3607
  00245	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  00248	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  0024e	74 24		 je	 SHORT $L3607
  00250	8b 4d f0	 mov	 ecx, DWORD PTR _hr$[ebp]
  00253	51		 push	 ecx
  00254	68 54 04 00 00	 push	 1108			; 00000454H
  00259	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  0025e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00263	8b 55 f0	 mov	 edx, DWORD PTR _hr$[ebp]
  00266	52		 push	 edx
  00267	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0026c	83 c4 14	 add	 esp, 20			; 00000014H
  0026f	89 45 d8	 mov	 DWORD PTR tv173[ebp], eax
  00272	eb 06		 jmp	 SHORT $L3608
$L3607:
  00274	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  00277	89 45 d8	 mov	 DWORD PTR tv173[ebp], eax
$L3608:
  0027a	e9 2f 01 00 00	 jmp	 $exit$3246
$L3268:

; 1109 : 
; 1110 :                 HEAP_DEBUG_CHECK;
; 1111 :                 BITRATE_REPORT_PRINT;
; 1112 :                 if (paudec->m_subfrmdecsts == SUBFRM_DONE)

  0027f	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00282	83 79 18 02	 cmp	 DWORD PTR [ecx+24], 2
  00286	75 0a		 jne	 SHORT $L3270

; 1113 :                     paudec->m_decsts = END_SUBFRAME1;

  00288	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0028b	c7 42 14 04 00
	00 00		 mov	 DWORD PTR [edx+20], 4
$L3270:

; 1114 : 
; 1115 :             case END_SUBFRAME1 :
; 1116 : 
; 1117 : #ifdef TRANSCODER
; 1118 :                 // No PCM required (or available) when doing simple transcode
; 1119 :                 if (TT_SIMPLE == paudec->pau->m_ttTranscodeType)
; 1120 :                 {
; 1121 :                     *pcSampleReady = 0;
; 1122 : 
; 1123 :                     // Don't record the first frame, we want to fill NEXT subfrm config
; 1124 :                     if (CODEC_BEGIN != pau->m_codecStatus)
; 1125 :                     {
; 1126 :                         TRACEWMA_EXIT(hr, coefstrmRecordCoefs(pau->m_pcstrmSubFrameSizes,
; 1127 :                             &pau->m_cSubbandAdjusted, 1));
; 1128 :                         TRACEWMA_EXIT(hr, coefstrmRecordCoefs(pau->m_pcstrmBitAllocs,
; 1129 :                             &cBitUsed, 1));
; 1130 : 
; 1131 :                         if (paudec->m_fLastSubFrame)
; 1132 :                         {
; 1133 :                             TRACEWMA_EXIT(hr, coefstrmRecordDone(pau->m_pcstrmSubFrameSizes));
; 1134 :                             TRACEWMA_EXIT(hr, coefstrmRecordDone(pau->m_pcstrmBitAllocs));
; 1135 : 
; 1136 :                             TRACEWMA_EXIT(hr, coefstrmRecordCoefs(pau->m_pcstrmMaskUpdate,
; 1137 :                                 &pau->m_subfrmconfigCurr.m_rgfMaskUpdate,
; 1138 :                                 pau->m_subfrmconfigCurr.m_cSubFrame));
; 1139 :                             TRACEWMA_EXIT(hr, coefstrmRecordDone(pau->m_pcstrmMaskUpdate));
; 1140 :                         }
; 1141 :                     }
; 1142 :                 }
; 1143 : #if 0
; 1144 :                 // *** TODO: Enable this code to enhance efficiency.
; 1145 :                 else
; 1146 : #endif
; 1147 : #endif  // TRANSCODER
; 1148 :                 auPreGetPCM (pau, pcSampleReady);

  00292	8b 45 0c	 mov	 eax, DWORD PTR _pcSampleReady$[ebp]
  00295	50		 push	 eax
  00296	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00299	51		 push	 ecx
  0029a	e8 00 00 00 00	 call	 _auPreGetPCM_XDS@8

; 1149 :                 paudec->pau->m_iCurrSubFrame++;

  0029f	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  002a2	8b 02		 mov	 eax, DWORD PTR [edx]
  002a4	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  002a7	83 c1 01	 add	 ecx, 1
  002aa	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  002ad	8b 02		 mov	 eax, DWORD PTR [edx]
  002af	89 48 70	 mov	 DWORD PTR [eax+112], ecx
$L3271:

; 1150 : 
; 1151 :             case END_SUBFRAME2 :
; 1152 :                 if (paudec->m_fLastSubFrame) 

  002b2	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  002b5	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  002b9	74 7d		 je	 SHORT $L3272

; 1153 :                 {
; 1154 :                     //take care the end of a frame
; 1155 :                     if (pau->m_fAllowSuperFrame)

  002bb	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  002be	83 7a 64 00	 cmp	 DWORD PTR [edx+100], 0
  002c2	74 40		 je	 SHORT $L3273

; 1156 :                     {
; 1157 :                         //copy next subfrm config to curr
; 1158 :                         memcpy (&pau->m_subfrmconfigPrev, &pau->m_subfrmconfigCurr, sizeof (SubFrameConfigInfo));

  002c4	68 d0 00 00 00	 push	 208			; 000000d0H
  002c9	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  002cc	05 74 01 00 00	 add	 eax, 372		; 00000174H
  002d1	50		 push	 eax
  002d2	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  002d5	81 c1 a4 00 00
	00		 add	 ecx, 164		; 000000a4H
  002db	51		 push	 ecx
  002dc	e8 00 00 00 00	 call	 _memcpy
  002e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1159 :                         memcpy (&pau->m_subfrmconfigCurr, &pau->m_subfrmconfigNext, sizeof (SubFrameConfigInfo));

  002e4	68 d0 00 00 00	 push	 208			; 000000d0H
  002e9	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  002ec	81 c2 44 02 00
	00		 add	 edx, 580		; 00000244H
  002f2	52		 push	 edx
  002f3	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  002f6	05 74 01 00 00	 add	 eax, 372		; 00000174H
  002fb	50		 push	 eax
  002fc	e8 00 00 00 00	 call	 _memcpy
  00301	83 c4 0c	 add	 esp, 12			; 0000000cH
$L3273:

; 1160 :                     }
; 1161 :                     paudec->m_cFrmInPacket--;

  00304	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00307	66 8b 51 08	 mov	 dx, WORD PTR [ecx+8]
  0030b	66 83 ea 01	 sub	 dx, 1
  0030f	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00312	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 1162 :                     //start decoding the next frame
; 1163 :                     paudec->m_decsts = BEGIN_FRAME; 

  00316	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00319	c7 41 14 01 00
	00 00		 mov	 DWORD PTR [ecx+20], 1

; 1164 : 
; 1165 :                     if (paudec->m_cFrmInPacket <= 0)

  00320	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00323	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  00327	85 c0		 test	 eax, eax
  00329	7f 0b		 jg	 SHORT $L3276

; 1166 :                     {
; 1167 :                         hr = WMA_S_NO_MORE_FRAME;

  0032b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_S_NO_MORE_FRAME
  00331	89 4d f0	 mov	 DWORD PTR _hr$[ebp], ecx

; 1168 :                         goto exit;

  00334	eb 78		 jmp	 SHORT $exit$3246
$L3276:

; 1169 :                     }
; 1170 :                 }
; 1171 :                 else                    

  00336	eb 0a		 jmp	 SHORT $L3277
$L3272:

; 1172 :                     paudec->m_decsts = BEGIN_SUBFRAME; //goto the start of next subfrm

  00338	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0033b	c7 42 14 02 00
	00 00		 mov	 DWORD PTR [edx+20], 2
$L3277:

; 1173 :                 goto exit;

  00342	eb 6a		 jmp	 SHORT $exit$3246
$L3278:

; 1174 : 
; 1175 :            case BEGIN_PACKET:
; 1176 : 
; 1177 :                 paudec->pau->m_fHeaderReset = WMAB_TRUE;

  00344	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00347	8b 08		 mov	 ecx, DWORD PTR [eax]
  00349	c7 41 78 01 00
	00 00		 mov	 DWORD PTR [ecx+120], 1

; 1178 :                 assert (paudec->pau->m_fAllowSuperFrame || (paudec->m_cFrmInPacket == 1));
; 1179 :                 paudec->m_decsts = BEGIN_FRAME; 

  00350	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00353	c7 42 14 01 00
	00 00		 mov	 DWORD PTR [edx+20], 1
$L3279:

; 1180 : 
; 1181 :            case BEGIN_FRAME:
; 1182 :                 paudec->pau->m_iFrameNumber++;

  0035a	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0035d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0035f	8b 91 e8 03 00
	00		 mov	 edx, DWORD PTR [ecx+1000]
  00365	83 c2 01	 add	 edx, 1
  00368	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0036b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0036d	89 91 e8 03 00
	00		 mov	 DWORD PTR [ecx+1000], edx

; 1183 :                 paudec->pau->m_iCurrSubFrame = 0;

  00373	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00376	8b 02		 mov	 eax, DWORD PTR [edx]
  00378	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], 0

; 1184 :                 paudec->m_fLastSubFrame = WMAB_FALSE;

  0037f	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00382	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 1185 : 
; 1186 :                 paudec->m_decsts = BEGIN_SUBFRAME;

  00389	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0038c	c7 42 14 02 00
	00 00		 mov	 DWORD PTR [edx+20], 2

; 1187 :                 if (paudec->m_cFrmInPacket == 0)

  00393	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00396	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  0039a	85 c9		 test	 ecx, ecx
  0039c	75 0b		 jne	 SHORT $L3252

; 1188 :                 {
; 1189 :                     hr = WMA_S_NO_MORE_FRAME;

  0039e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_S_NO_MORE_FRAME
  003a4	89 55 f0	 mov	 DWORD PTR _hr$[ebp], edx

; 1190 :                     goto exit;

  003a7	eb 05		 jmp	 SHORT $exit$3246
$L3252:

; 1191 :                 }
; 1192 :                 break;
; 1193 :          }
; 1194 :     }

  003a9	e9 eb fc ff ff	 jmp	 $L3249
$exit$3246:

; 1195 : 
; 1196 : exit:
; 1197 :     //FUNCTION_PROFILE_STOP(&fp);
; 1198 : #if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
; 1199 :         prvWmaShowFrames(paudec->pau, "RetDecD", hr<0 ? " 0x%08x " : " %d ", hr );
; 1200 : #endif
; 1201 :     HEAP_DEBUG_CHECK;
; 1202 : 
; 1203 :     return hr;

  003ae	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]

; 1204 : }

  003b1	8b e5		 mov	 esp, ebp
  003b3	5d		 pop	 ebp
  003b4	c2 08 00	 ret	 8
$L3609:
  003b7	00 00 00 00	 DD	 $L3278
  003bb	00 00 00 00	 DD	 $L3279
  003bf	00 00 00 00	 DD	 $L3255
  003c3	00 00 00 00	 DD	 $L3265
  003c7	00 00 00 00	 DD	 $L3270
  003cb	00 00 00 00	 DD	 $L3271
_audecDecodeData_XDS@8 ENDP
WMADEC	ENDS
EXTRN	_auGetPCM_XDS@16:NEAR
; Function compile flags: /Odt
;	COMDAT _audecGetPCM_XDS@16
WMADEC	SEGMENT
_wmaResult$ = -4
_paudec$ = 8
_pcSampleReady$ = 12
_pbDst$ = 16
_cbDstLength$ = 20
_audecGetPCM_XDS@16 PROC NEAR				; COMDAT

; 1207 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1208 :     WMARESULT wmaResult = WMA_OK;

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  00009	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 1209 :     
; 1210 : #if 0
; 1211 :     // *** TODO: Enable this code to enhance efficiency.
; 1212 :     // No PCM required (or available) when doing simple transcode
; 1213 :     if (TT_SIMPLE == paudec->pau->m_ttTranscodeType)
; 1214 :     {
; 1215 :         *pcSampleReady = 0;
; 1216 :         return WMA_OK;
; 1217 :     }
; 1218 : #endif
; 1219 : 
; 1220 :     //get pcm only when we are in these states
; 1221 :     if (paudec->m_decsts == BEGIN_FRAME || paudec->m_decsts == BEGIN_SUBFRAME)

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0000f	83 79 14 01	 cmp	 DWORD PTR [ecx+20], 1
  00013	74 09		 je	 SHORT $L3292
  00015	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00018	83 7a 14 02	 cmp	 DWORD PTR [edx+20], 2
  0001c	75 1c		 jne	 SHORT $L3291
$L3292:

; 1222 :         wmaResult = auGetPCM (paudec->pau, pcSampleReady, pbDst, cbDstLength);

  0001e	8b 45 14	 mov	 eax, DWORD PTR _cbDstLength$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 10	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 0c	 mov	 edx, DWORD PTR _pcSampleReady$[ebp]
  00029	52		 push	 edx
  0002a	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _auGetPCM_XDS@16
  00035	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 1223 :     else

  00038	eb 08		 jmp	 SHORT $L3293
$L3291:

; 1224 :         *pcSampleReady = 0;         //we are in a state of error; don't return anything

  0003a	8b 55 0c	 mov	 edx, DWORD PTR _pcSampleReady$[ebp]
  0003d	66 c7 02 00 00	 mov	 WORD PTR [edx], 0
$L3293:

; 1225 : 
; 1226 : #if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
; 1227 :     prvWmaShowFrames(paudec->pau, "RetGetP", wmaResult<0 ? " 0x%08x " : " %d ", wmaResult );
; 1228 : #endif
; 1229 :     return wmaResult;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 1230 : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 10 00	 ret	 16			; 00000010H
_audecGetPCM_XDS@16 ENDP
WMADEC	ENDS
PUBLIC	__real@40000000
EXTRN	_qstCalcQuantStep_XDS@4:NEAR
EXTRN	_SetActualPower_XDS@16:NEAR
EXTRN	_prvDecodeFrameHeader_XDS@8:NEAR
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _prvDecodeSubFrame_XDS@8
WMADEC	SEGMENT
tv254 = -68
tv188 = -64
tv132 = -60
tv78 = -56
tv65 = -52
_ppcinfo$3358 = -48
_fltAfterScaleFactor$3353 = -44
_iHighToBeZeroed$3348 = -40
_ppcinfo$3327 = -36
_hr$ = -32
_pctCoefRecon0$ = -28
_ctTemp0$ = -24
_pctCoefRecon1$ = -20
_iChannel$ = -16
_pau$ = -12
_ctTemp1$ = -8
_i$ = -4
_paudec$ = 8
_piBitCnt$ = 12
_prvDecodeSubFrame_XDS@8 PROC NEAR			; COMDAT

; 1240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H

; 1241 :     WMARESULT hr = WMA_OK;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000b	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax

; 1242 :     Int     i, iChannel;
; 1243 :     CAudioObject* pau = paudec->pau;

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00011	8b 11		 mov	 edx, DWORD PTR [ecx]
  00013	89 55 f4	 mov	 DWORD PTR _pau$[ebp], edx

; 1244 :     CoefType     ctTemp0, ctTemp1;
; 1245 :     CoefType*    pctCoefRecon0;
; 1246 :     CoefType*    pctCoefRecon1;
; 1247 : 
; 1248 : #ifdef PROFILE
; 1249 :     //FunctionProfile fp;
; 1250 :     //FunctionProfileStart(&fp,DECODE_SUB_FRAME_PROFILE);
; 1251 : #endif
; 1252 : 
; 1253 :     switch (paudec->m_subfrmdecsts)
; 1254 :     {

  00016	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00019	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0001c	89 4d cc	 mov	 DWORD PTR tv65[ebp], ecx
  0001f	83 7d cc 00	 cmp	 DWORD PTR tv65[ebp], 0
  00023	74 19		 je	 SHORT $L3311
  00025	83 7d cc 01	 cmp	 DWORD PTR tv65[ebp], 1
  00029	0f 84 a2 00 00
	00		 je	 $L3318
  0002f	83 7d cc 02	 cmp	 DWORD PTR tv65[ebp], 2
  00033	0f 84 0b 01 00
	00		 je	 $L3322
  00039	e9 94 04 00 00	 jmp	 $exit$3314
$L3311:

; 1255 :         case SUBFRM_HDR :   
; 1256 :             TRACEWMA_EXIT(hr, prvDecodeFrameHeader (paudec, piBitCnt));

  0003e	8b 55 0c	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  00041	52		 push	 edx
  00042	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _prvDecodeFrameHeader_XDS@8
  0004b	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax
  0004e	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00052	7d 45		 jge	 SHORT $L3315
  00054	8b 4d e0	 mov	 ecx, DWORD PTR _hr$[ebp]
  00057	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  0005d	74 2f		 je	 SHORT $L3616
  0005f	8b 55 e0	 mov	 edx, DWORD PTR _hr$[ebp]
  00062	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  00068	74 24		 je	 SHORT $L3616
  0006a	8b 45 e0	 mov	 eax, DWORD PTR _hr$[ebp]
  0006d	50		 push	 eax
  0006e	68 e8 04 00 00	 push	 1256			; 000004e8H
  00073	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0007d	8b 4d e0	 mov	 ecx, DWORD PTR _hr$[ebp]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00086	83 c4 14	 add	 esp, 20			; 00000014H
  00089	89 45 c8	 mov	 DWORD PTR tv78[ebp], eax
  0008c	eb 06		 jmp	 SHORT $L3617
$L3616:
  0008e	8b 55 e0	 mov	 edx, DWORD PTR _hr$[ebp]
  00091	89 55 c8	 mov	 DWORD PTR tv78[ebp], edx
$L3617:
  00094	e9 39 04 00 00	 jmp	 $exit$3314
$L3315:

; 1257 :             if (paudec->m_hdrdecsts == HDR_DONE)

  00099	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0009c	83 78 1c 06	 cmp	 DWORD PTR [eax+28], 6
  000a0	75 2a		 jne	 SHORT $L3316

; 1258 :             {
; 1259 :                 paudec->m_subfrmdecsts = SUBFRM_COEF;

  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  000a5	c7 41 18 01 00
	00 00		 mov	 DWORD PTR [ecx+24], 1

; 1260 :                 paudec->pau->m_iCurrReconCoef = 0;             //iRecon is offset by -1 so comarison 

  000ac	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	66 c7 40 74 00
	00		 mov	 WORD PTR [eax+116], 0

; 1261 :                 paudec->m_iChannel = 0;

  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  000ba	66 c7 41 24 00
	00		 mov	 WORD PTR [ecx+36], 0

; 1262 :                 paudec->m_rlsts = VLC;

  000c0	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  000c3	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0

; 1263 : 
; 1264 :             }
; 1265 :             else

  000ca	eb 05		 jmp	 SHORT $L3318
$L3316:

; 1266 :                 break;

  000cc	e9 01 04 00 00	 jmp	 $exit$3314
$L3318:

; 1267 : 
; 1268 :         case SUBFRM_COEF:
; 1269 :             TRACEWMA_EXIT(hr, (*(paudec->m_pfnDecodeCoefficient))(paudec, pau->m_rgpcinfo, piBitCnt));

  000d1	8b 45 0c	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  000d8	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  000de	52		 push	 edx
  000df	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  000e2	50		 push	 eax
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  000e6	ff 91 9c 01 00
	00		 call	 DWORD PTR [ecx+412]
  000ec	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax
  000ef	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000f3	7d 45		 jge	 SHORT $L3321
  000f5	8b 55 e0	 mov	 edx, DWORD PTR _hr$[ebp]
  000f8	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  000fe	74 2f		 je	 SHORT $L3618
  00100	8b 45 e0	 mov	 eax, DWORD PTR _hr$[ebp]
  00103	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00109	74 24		 je	 SHORT $L3618
  0010b	8b 4d e0	 mov	 ecx, DWORD PTR _hr$[ebp]
  0010e	51		 push	 ecx
  0010f	68 f5 04 00 00	 push	 1269			; 000004f5H
  00114	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00119	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0011e	8b 55 e0	 mov	 edx, DWORD PTR _hr$[ebp]
  00121	52		 push	 edx
  00122	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00127	83 c4 14	 add	 esp, 20			; 00000014H
  0012a	89 45 c4	 mov	 DWORD PTR tv132[ebp], eax
  0012d	eb 06		 jmp	 SHORT $L3619
$L3618:
  0012f	8b 45 e0	 mov	 eax, DWORD PTR _hr$[ebp]
  00132	89 45 c4	 mov	 DWORD PTR tv132[ebp], eax
$L3619:
  00135	e9 98 03 00 00	 jmp	 $exit$3314
$L3321:

; 1270 :             paudec->m_subfrmdecsts = SUBFRM_DONE;

  0013a	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0013d	c7 41 18 02 00
	00 00		 mov	 DWORD PTR [ecx+24], 2
$L3322:

; 1271 : 
; 1272 :         case SUBFRM_DONE:
; 1273 :             // WMA Timestamps: To detect start-of-stream and discard correct amount of silence,
; 1274 :             // we need to verify claim that m_iPower[*] = 1, ForceMaskUpdate and actual power = 0.
; 1275 :             // If m_rgiCoefQ is all 0, we will accept that as actual power = 0 even though it is
; 1276 :             // theoretically possible for actual power != 0 if all bands inside noise-sub band are
; 1277 :             // substituted.
; 1278 :             if (CODEC_BEGIN == pau->m_codecStatus)

  00144	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00147	83 7a 48 03	 cmp	 DWORD PTR [edx+72], 3
  0014b	75 65		 jne	 SHORT $L3323

; 1279 :             {
; 1280 :                 for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)

  0014d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iChannel$[ebp], 0
  00154	eb 09		 jmp	 SHORT $L3324
$L3325:
  00156	8b 45 f0	 mov	 eax, DWORD PTR _iChannel$[ebp]
  00159	83 c0 01	 add	 eax, 1
  0015c	89 45 f0	 mov	 DWORD PTR _iChannel$[ebp], eax
$L3324:
  0015f	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  00162	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  00166	39 55 f0	 cmp	 DWORD PTR _iChannel$[ebp], edx
  00169	7d 47		 jge	 SHORT $L3323

; 1281 :                 {
; 1282 :                     PerChannelInfo *ppcinfo = &(pau->m_rgpcinfo[iChannel]);

  0016b	8b 45 f0	 mov	 eax, DWORD PTR _iChannel$[ebp]
  0016e	6b c0 70	 imul	 eax, 112		; 00000070H
  00171	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  00174	03 81 a0 03 00
	00		 add	 eax, DWORD PTR [ecx+928]
  0017a	89 45 dc	 mov	 DWORD PTR _ppcinfo$3327[ebp], eax

; 1283 :                     if (pau->m_rgpcinfo[iChannel].m_iPower != 0)

  0017d	8b 55 f0	 mov	 edx, DWORD PTR _iChannel$[ebp]
  00180	6b d2 70	 imul	 edx, 112		; 00000070H
  00183	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00186	8b 88 a0 03 00
	00		 mov	 ecx, DWORD PTR [eax+928]
  0018c	83 7c 11 24 00	 cmp	 DWORD PTR [ecx+edx+36], 0
  00191	74 1d		 je	 SHORT $L3328

; 1284 :                         SetActualPower (ppcinfo->m_rgiCoefQ, ppcinfo->m_cSubbandActual,
; 1285 :                                        ppcinfo, pau->m_codecStatus);

  00193	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00196	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00199	50		 push	 eax
  0019a	8b 4d dc	 mov	 ecx, DWORD PTR _ppcinfo$3327[ebp]
  0019d	51		 push	 ecx
  0019e	8b 55 dc	 mov	 edx, DWORD PTR _ppcinfo$3327[ebp]
  001a1	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  001a4	50		 push	 eax
  001a5	8b 4d dc	 mov	 ecx, DWORD PTR _ppcinfo$3327[ebp]
  001a8	8b 11		 mov	 edx, DWORD PTR [ecx]
  001aa	52		 push	 edx
  001ab	e8 00 00 00 00	 call	 _SetActualPower_XDS@16
$L3328:

; 1286 :                 }

  001b0	eb a4		 jmp	 SHORT $L3325
$L3323:

; 1287 :             }
; 1288 : 
; 1289 :             pau->m_qstQuantStep = qstCalcQuantStep(pau->m_iQuantStepSize);

  001b2	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  001b5	8b 88 44 03 00
	00		 mov	 ecx, DWORD PTR [eax+836]
  001bb	51		 push	 ecx
  001bc	e8 00 00 00 00	 call	 _qstCalcQuantStep_XDS@4
  001c1	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  001c4	d9 1a		 fstp	 DWORD PTR [edx]

; 1290 :             for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) 

  001c6	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iChannel$[ebp], 0
  001cd	eb 09		 jmp	 SHORT $L3329
$L3330:
  001cf	8b 45 f0	 mov	 eax, DWORD PTR _iChannel$[ebp]
  001d2	83 c0 01	 add	 eax, 1
  001d5	89 45 f0	 mov	 DWORD PTR _iChannel$[ebp], eax
$L3329:
  001d8	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  001db	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  001df	39 55 f0	 cmp	 DWORD PTR _iChannel$[ebp], edx
  001e2	0f 8d ce 00 00
	00		 jge	 $L3331

; 1291 :             {
; 1292 :                 if (pau->m_rgpcinfo[iChannel].m_iPower != 0 ||
; 1293 :                     TRANSCODER_AB(TT_SIMPLE == pau->m_ttTranscodeType, WMAB_FALSE))

  001e8	8b 45 f0	 mov	 eax, DWORD PTR _iChannel$[ebp]
  001eb	6b c0 70	 imul	 eax, 112		; 00000070H
  001ee	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  001f1	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  001f7	83 7c 02 24 00	 cmp	 DWORD PTR [edx+eax+36], 0
  001fc	75 0a		 jne	 SHORT $L3333
  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	0f 84 81 00 00
	00		 je	 $L3332
$L3333:

; 1294 :                 {
; 1295 :                     TRACEWMA_EXIT(hr, (*pau->aupfnInverseQuantize)(pau, pau->m_rgpcinfo + iChannel,
; 1296 :                         (I32 *)(pau->m_rgpcinfo + iChannel)->m_rguiWeightFactor));

  00208	8b 4d f0	 mov	 ecx, DWORD PTR _iChannel$[ebp]
  0020b	6b c9 70	 imul	 ecx, 112		; 00000070H
  0020e	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00211	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  00217	8b 4c 08 2c	 mov	 ecx, DWORD PTR [eax+ecx+44]
  0021b	51		 push	 ecx
  0021c	8b 55 f0	 mov	 edx, DWORD PTR _iChannel$[ebp]
  0021f	6b d2 70	 imul	 edx, 112		; 00000070H
  00222	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00225	03 90 a0 03 00
	00		 add	 edx, DWORD PTR [eax+928]
  0022b	52		 push	 edx
  0022c	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  0022f	51		 push	 ecx
  00230	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00233	ff 92 ec 03 00
	00		 call	 DWORD PTR [edx+1004]
  00239	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax
  0023c	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00240	7d 45		 jge	 SHORT $L3337
  00242	8b 45 e0	 mov	 eax, DWORD PTR _hr$[ebp]
  00245	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  0024b	74 2f		 je	 SHORT $L3620
  0024d	8b 4d e0	 mov	 ecx, DWORD PTR _hr$[ebp]
  00250	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  00256	74 24		 je	 SHORT $L3620
  00258	8b 55 e0	 mov	 edx, DWORD PTR _hr$[ebp]
  0025b	52		 push	 edx
  0025c	68 10 05 00 00	 push	 1296			; 00000510H
  00261	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00266	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0026b	8b 45 e0	 mov	 eax, DWORD PTR _hr$[ebp]
  0026e	50		 push	 eax
  0026f	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00274	83 c4 14	 add	 esp, 20			; 00000014H
  00277	89 45 c0	 mov	 DWORD PTR tv188[ebp], eax
  0027a	eb 06		 jmp	 SHORT $L3621
$L3620:
  0027c	8b 4d e0	 mov	 ecx, DWORD PTR _hr$[ebp]
  0027f	89 4d c0	 mov	 DWORD PTR tv188[ebp], ecx
$L3621:
  00282	e9 4b 02 00 00	 jmp	 $exit$3314
$L3337:

; 1297 :                 }
; 1298 :                 else

  00287	eb 28		 jmp	 SHORT $L3338
$L3332:

; 1299 :                 {
; 1300 :                     memset (pau->m_rgpcinfo [iChannel].COEF, 0, sizeof (Int) * DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband));

  00289	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  0028c	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0028f	c1 e0 02	 shl	 eax, 2
  00292	50		 push	 eax
  00293	6a 00		 push	 0
  00295	8b 4d f0	 mov	 ecx, DWORD PTR _iChannel$[ebp]
  00298	6b c9 70	 imul	 ecx, 112		; 00000070H
  0029b	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  0029e	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  002a4	8b 4c 08 60	 mov	 ecx, DWORD PTR [eax+ecx+96]
  002a8	51		 push	 ecx
  002a9	e8 00 00 00 00	 call	 _memset
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH
$L3338:

; 1301 :                 }
; 1302 :             }

  002b1	e9 19 ff ff ff	 jmp	 $L3330
$L3331:

; 1303 : 
; 1304 : #if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
; 1305 :             if (pau->m_cChannel==1)
; 1306 :                 prvWmaShowFrames(pau, "\nDecSub ", " %2d   0x%08x            [%4d %4d %4d]",
; 1307 :                     pau->m_rgpcinfo[0].m_iPower,
; 1308 :                     pau->m_rgpcinfo[0].m_rgiCoefRecon,
; 1309 :                     pau->m_cFrameSample,
; 1310 :                     pau->m_cSubFrameSample,
; 1311 :                     pau->m_cSubband );
; 1312 :             else
; 1313 :                 prvWmaShowFrames(pau, "\nDecSub ", " %2d%2d 0x%08x 0x%08x [%4d %4d %4d]",
; 1314 :                     pau->m_rgpcinfo[0].m_iPower,
; 1315 :                     pau->m_rgpcinfo[1].m_iPower,
; 1316 :                     pau->m_rgpcinfo[0].m_rgiCoefRecon,
; 1317 :                     pau->m_rgpcinfo[1].m_rgiCoefRecon,
; 1318 :                     pau->m_cFrameSample,
; 1319 :                     pau->m_cSubFrameSample,
; 1320 :                     pau->m_cSubband );
; 1321 : #endif
; 1322 : 
; 1323 : #ifdef TRANSCODER
; 1324 :             // If performing simple transcode, we don't need to do any more processing
; 1325 :             if (TT_SIMPLE == pau->m_ttTranscodeType)
; 1326 :             {
; 1327 :                 for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
; 1328 :                 {
; 1329 :                     PerChannelInfo *ppcinfo = &pau->m_rgpcinfo[iChannel];
; 1330 : 
; 1331 :                     //start recursion
; 1332 :                     ppcinfo->m_iSin  = SIN_START;
; 1333 :                     ppcinfo->m_iCos  = COS_START;
; 1334 :                     ppcinfo->m_iSin1 = SIN1_START;
; 1335 :                     ppcinfo->m_iCos1 = COS1_START;
; 1336 :                     ppcinfo->m_iStep = SIN_STEP;
; 1337 :                 }
; 1338 :                 break;
; 1339 :             }
; 1340 : #endif  // TRANSCODER
; 1341 : 
; 1342 :             //convert s/d to l/r
; 1343 :             if (pau->m_cChannel == 2 && pau->m_stereoMode == STEREO_SUMDIFF && 
; 1344 :                             (pau->m_rgpcinfo[0].m_iPower != 0 || pau->m_rgpcinfo[1].m_iPower != 0)) {

  002b6	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  002b9	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  002bd	83 f8 02	 cmp	 eax, 2
  002c0	0f 85 cd 00 00
	00		 jne	 $L3340
  002c6	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  002c9	83 b9 38 03 00
	00 01		 cmp	 DWORD PTR [ecx+824], 1
  002d0	0f 85 bd 00 00
	00		 jne	 $L3340
  002d6	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  002d9	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  002df	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  002e3	75 16		 jne	 SHORT $L3341
  002e5	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  002e8	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  002ee	83 ba 94 00 00
	00 00		 cmp	 DWORD PTR [edx+148], 0
  002f5	0f 84 98 00 00
	00		 je	 $L3340
$L3341:

; 1345 :                 pctCoefRecon0 = (CoefType*)pau->m_rgpcinfo[0].m_rgiCoefRecon;

  002fb	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  002fe	8b 88 a0 03 00
	00		 mov	 ecx, DWORD PTR [eax+928]
  00304	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00307	89 55 e4	 mov	 DWORD PTR _pctCoefRecon0$[ebp], edx

; 1346 :                 pctCoefRecon1 = (CoefType*)pau->m_rgpcinfo[1].m_rgiCoefRecon;

  0030a	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  0030d	8b 88 a0 03 00
	00		 mov	 ecx, DWORD PTR [eax+928]
  00313	8b 91 a0 00 00
	00		 mov	 edx, DWORD PTR [ecx+160]
  00319	89 55 ec	 mov	 DWORD PTR _pctCoefRecon1$[ebp], edx

; 1347 :                 for (i = pau->m_cSubbandAdjusted; i > 0; i--)   

  0031c	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  0031f	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00322	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00325	eb 09		 jmp	 SHORT $L3344
$L3345:
  00327	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0032a	83 ea 01	 sub	 edx, 1
  0032d	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L3344:
  00330	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00334	7e 3a		 jle	 SHORT $L3346

; 1348 :                 {
; 1349 :                     ctTemp0 = *pctCoefRecon0;

  00336	8b 45 e4	 mov	 eax, DWORD PTR _pctCoefRecon0$[ebp]
  00339	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033b	89 4d e8	 mov	 DWORD PTR _ctTemp0$[ebp], ecx

; 1350 :                     ctTemp1 = *pctCoefRecon1;

  0033e	8b 55 ec	 mov	 edx, DWORD PTR _pctCoefRecon1$[ebp]
  00341	8b 02		 mov	 eax, DWORD PTR [edx]
  00343	89 45 f8	 mov	 DWORD PTR _ctTemp1$[ebp], eax

; 1351 :                     *pctCoefRecon0++ = ctTemp0 + ctTemp1;

  00346	d9 45 e8	 fld	 DWORD PTR _ctTemp0$[ebp]
  00349	d8 45 f8	 fadd	 DWORD PTR _ctTemp1$[ebp]
  0034c	8b 4d e4	 mov	 ecx, DWORD PTR _pctCoefRecon0$[ebp]
  0034f	d9 19		 fstp	 DWORD PTR [ecx]
  00351	8b 55 e4	 mov	 edx, DWORD PTR _pctCoefRecon0$[ebp]
  00354	83 c2 04	 add	 edx, 4
  00357	89 55 e4	 mov	 DWORD PTR _pctCoefRecon0$[ebp], edx

; 1352 :                     *pctCoefRecon1++ = ctTemp0 - ctTemp1;

  0035a	d9 45 e8	 fld	 DWORD PTR _ctTemp0$[ebp]
  0035d	d8 65 f8	 fsub	 DWORD PTR _ctTemp1$[ebp]
  00360	8b 45 ec	 mov	 eax, DWORD PTR _pctCoefRecon1$[ebp]
  00363	d9 18		 fstp	 DWORD PTR [eax]
  00365	8b 4d ec	 mov	 ecx, DWORD PTR _pctCoefRecon1$[ebp]
  00368	83 c1 04	 add	 ecx, 4
  0036b	89 4d ec	 mov	 DWORD PTR _pctCoefRecon1$[ebp], ecx

; 1353 :                 }

  0036e	eb b7		 jmp	 SHORT $L3345
$L3346:

; 1354 :                 pau->m_rgpcinfo[0].m_iPower = 1;

  00370	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00373	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  00379	c7 40 24 01 00
	00 00		 mov	 DWORD PTR [eax+36], 1

; 1355 :                 pau->m_rgpcinfo[1].m_iPower = 1;

  00380	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  00383	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  00389	c7 82 94 00 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+148], 1
$L3340:

; 1356 :             }
; 1357 : 
; 1358 :             if ( ! pau->m_fNoiseSub )

  00393	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00396	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  0039a	75 63		 jne	 SHORT $L3347

; 1359 :             {   // V4 only zeroed above HighCutOff when NoiseSubstitution was not in effect - e.g. it only zeros for HighRate
; 1360 :                 Int iHighToBeZeroed = sizeof(CoefType) * (pau->m_cSubbandAdjusted - pau->m_cHighCutOffAdjusted);

  0039c	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  0039f	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  003a2	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  003a5	2b 82 28 03 00
	00		 sub	 eax, DWORD PTR [edx+808]
  003ab	c1 e0 02	 shl	 eax, 2
  003ae	89 45 d8	 mov	 DWORD PTR _iHighToBeZeroed$3348[ebp], eax

; 1361 :                 for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)

  003b1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iChannel$[ebp], 0
  003b8	eb 09		 jmp	 SHORT $L3350
$L3351:
  003ba	8b 4d f0	 mov	 ecx, DWORD PTR _iChannel$[ebp]
  003bd	83 c1 01	 add	 ecx, 1
  003c0	89 4d f0	 mov	 DWORD PTR _iChannel$[ebp], ecx
$L3350:
  003c3	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  003c6	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  003ca	39 45 f0	 cmp	 DWORD PTR _iChannel$[ebp], eax
  003cd	7d 30		 jge	 SHORT $L3347

; 1362 :                 {
; 1363 :                     memset (pau->m_rgpcinfo [iChannel].m_rgiCoefRecon + pau->m_cHighCutOffAdjusted, 0, iHighToBeZeroed);    

  003cf	8b 4d d8	 mov	 ecx, DWORD PTR _iHighToBeZeroed$3348[ebp]
  003d2	51		 push	 ecx
  003d3	6a 00		 push	 0
  003d5	8b 55 f0	 mov	 edx, DWORD PTR _iChannel$[ebp]
  003d8	6b d2 70	 imul	 edx, 112		; 00000070H
  003db	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  003de	8b 88 a0 03 00
	00		 mov	 ecx, DWORD PTR [eax+928]
  003e4	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  003e7	8b 80 28 03 00
	00		 mov	 eax, DWORD PTR [eax+808]
  003ed	8b 4c 11 30	 mov	 ecx, DWORD PTR [ecx+edx+48]
  003f1	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  003f4	52		 push	 edx
  003f5	e8 00 00 00 00	 call	 _memset
  003fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1364 : #           if defined(_DEBUG) && defined(WMA_MONITOR)
; 1365 :                     {   int ii;
; 1366 :                         for( ii = 0; ii < iHighToBeZeroed; ii += sizeof(Int) )
; 1367 :                             MONITOR_RANGE(gMR_CoefRecon,0);
; 1368 :                     }
; 1369 : #           endif
; 1370 :                 }

  003fd	eb bb		 jmp	 SHORT $L3351
$L3347:

; 1371 :             }
; 1372 : 
; 1373 : #ifdef ENABLE_EQUALIZER
; 1374 :             //equalize
; 1375 :             for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {
; 1376 :                 if (pau->m_rgpcinfo[iChannel].m_iPower != 0) {
; 1377 :                     TRACEWMA_EXIT(hr, prvEqualize(paudec, pau->m_rgpcinfo + iChannel));
; 1378 : 
; 1379 :                     if (paudec->m_fComputeBandPower == WMAB_TRUE)
; 1380 :                         prvComputeBandPower (paudec);
; 1381 :                 }
; 1382 :             }
; 1383 : #endif // ENABLE_EQUALIZER
; 1384 : 
; 1385 :             {
; 1386 :                 Float fltAfterScaleFactor = (pau->m_iVersion == 1) ? pau->m_fltDctScale :
; 1387 :                     (Float)(2.0f/pau->m_cSubband);

  003ff	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00402	83 78 44 01	 cmp	 DWORD PTR [eax+68], 1
  00406	75 0e		 jne	 SHORT $L3622
  00408	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  0040b	8b 91 4c 03 00
	00		 mov	 edx, DWORD PTR [ecx+844]
  00411	89 55 bc	 mov	 DWORD PTR tv254[ebp], edx
  00414	eb 0f		 jmp	 SHORT $L3623
$L3622:
  00416	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00419	db 40 60	 fild	 DWORD PTR [eax+96]
  0041c	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@40000000
  00422	d9 5d bc	 fstp	 DWORD PTR tv254[ebp]
$L3623:
  00425	8b 4d bc	 mov	 ecx, DWORD PTR tv254[ebp]
  00428	89 4d d4	 mov	 DWORD PTR _fltAfterScaleFactor$3353[ebp], ecx

; 1388 : 
; 1389 :                 for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {

  0042b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iChannel$[ebp], 0
  00432	eb 09		 jmp	 SHORT $L3355
$L3356:
  00434	8b 55 f0	 mov	 edx, DWORD PTR _iChannel$[ebp]
  00437	83 c2 01	 add	 edx, 1
  0043a	89 55 f0	 mov	 DWORD PTR _iChannel$[ebp], edx
$L3355:
  0043d	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00440	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  00444	39 4d f0	 cmp	 DWORD PTR _iChannel$[ebp], ecx
  00447	0f 8d 85 00 00
	00		 jge	 $exit$3314

; 1390 :                     PerChannelInfo* ppcinfo = pau->m_rgpcinfo + iChannel;

  0044d	8b 55 f0	 mov	 edx, DWORD PTR _iChannel$[ebp]
  00450	6b d2 70	 imul	 edx, 112		; 00000070H
  00453	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00456	03 90 a0 03 00
	00		 add	 edx, DWORD PTR [eax+928]
  0045c	89 55 d0	 mov	 DWORD PTR _ppcinfo$3358[ebp], edx

; 1391 : #if defined(INTERPOLATED_DOWNSAMPLE)
; 1392 :                     if (paudec->pau->m_fLowPass)
; 1393 :                         auLowPass(paudec->pau, (CoefType*) ppcinfo->COEF, pau->m_cSubband / 2);
; 1394 : #endif  // defined(INTERPOLATED_DOWNSAMPLE)
; 1395 :                     if (ppcinfo->m_iPower != 0) 

  0045f	8b 4d d0	 mov	 ecx, DWORD PTR _ppcinfo$3358[ebp]
  00462	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00466	74 1a		 je	 SHORT $L3359

; 1396 :                         (*pau->aupfnDctIV) (pau, (CoefType*) ppcinfo->COEF, fltAfterScaleFactor, NULL);

  00468	6a 00		 push	 0
  0046a	8b 55 d4	 mov	 edx, DWORD PTR _fltAfterScaleFactor$3353[ebp]
  0046d	52		 push	 edx
  0046e	8b 45 d0	 mov	 eax, DWORD PTR _ppcinfo$3358[ebp]
  00471	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00474	51		 push	 ecx
  00475	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00478	52		 push	 edx
  00479	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  0047c	ff 90 fc 03 00
	00		 call	 DWORD PTR [eax+1020]
$L3359:

; 1397 : 
; 1398 :                     //start recursion
; 1399 :                     ppcinfo->m_iSin  = SIN_START;

  00482	8b 4d d0	 mov	 ecx, DWORD PTR _ppcinfo$3358[ebp]
  00485	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00488	8b 82 58 03 00
	00		 mov	 eax, DWORD PTR [edx+856]
  0048e	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1400 :                     ppcinfo->m_iCos  = COS_START;

  00491	8b 4d d0	 mov	 ecx, DWORD PTR _ppcinfo$3358[ebp]
  00494	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00497	8b 82 5c 03 00
	00		 mov	 eax, DWORD PTR [edx+860]
  0049d	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 1401 :                     ppcinfo->m_iSin1 = SIN1_START;

  004a0	8b 4d d0	 mov	 ecx, DWORD PTR _ppcinfo$3358[ebp]
  004a3	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  004a6	8b 82 60 03 00
	00		 mov	 eax, DWORD PTR [edx+864]
  004ac	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 1402 :                     ppcinfo->m_iCos1 = COS1_START;

  004af	8b 4d d0	 mov	 ecx, DWORD PTR _ppcinfo$3358[ebp]
  004b2	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  004b5	8b 82 64 03 00
	00		 mov	 eax, DWORD PTR [edx+868]
  004bb	89 41 58	 mov	 DWORD PTR [ecx+88], eax

; 1403 :                     ppcinfo->m_iStep = SIN_STEP;

  004be	8b 4d d0	 mov	 ecx, DWORD PTR _ppcinfo$3358[ebp]
  004c1	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  004c4	8b 82 68 03 00
	00		 mov	 eax, DWORD PTR [edx+872]
  004ca	89 41 5c	 mov	 DWORD PTR [ecx+92], eax

; 1404 :                 }

  004cd	e9 62 ff ff ff	 jmp	 $L3356
$exit$3314:

; 1405 :             }
; 1406 :         }
; 1407 : exit:
; 1408 :     //FUNCTION_PROFILE_STOP(&fp);
; 1409 :     return hr;

  004d2	8b 45 e0	 mov	 eax, DWORD PTR _hr$[ebp]

; 1410 : }

  004d5	8b e5		 mov	 esp, ebp
  004d7	5d		 pop	 ebp
  004d8	c2 08 00	 ret	 8
_prvDecodeSubFrame_XDS@8 ENDP
WMADEC	ENDS
PUBLIC	_prvUpdateSubFrameConfig_XDS@16
; Function compile flags: /Odt
;	COMDAT _prvUpdateSubFrameConfig_XDS@16
WMADEC	SEGMENT
tv168 = -16
_iCurr$3383 = -12
_iStartCurr$ = -8
_pau$ = -4
_paudec$ = 8
_iSizeNext$ = 12
_iSizePrev$ = 16
_iSizeCurr$ = 20
_prvUpdateSubFrameConfig_XDS@16 PROC NEAR		; COMDAT

; 1420 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1421 :     Int iStartCurr;
; 1422 :     CAudioObject* pau = paudec->pau;

  00006	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d fc	 mov	 DWORD PTR _pau$[ebp], ecx

; 1423 : /*** less than 0.5%
; 1424 : #ifdef PROFILE
; 1425 :     //FunctionProfile fp;
; 1426 :     //FunctionProfileStart(&fp,UPDATE_SUB_FRAME_CONFIG_PROFILE);
; 1427 : #endif
; 1428 : *///
; 1429 :     if (iSizeNext == 0) {

  0000e	83 7d 0c 00	 cmp	 DWORD PTR _iSizeNext$[ebp], 0
  00012	75 14		 jne	 SHORT $L3378

; 1430 :         assert (pau->m_subfrmconfigCurr.m_cSubFrame > 0);
; 1431 :         paudec->m_fLastSubFrame = WMAB_TRUE;

  00014	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00017	c7 42 2c 01 00
	00 00		 mov	 DWORD PTR [edx+44], 1

; 1432 :         return WMA_OK;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  00023	e9 ad 01 00 00	 jmp	 $L3375
$L3378:

; 1433 :     }
; 1434 : 
; 1435 :     //only useful in case of packet loss and prev info lost or first in sequece
; 1436 :     if (iSizePrev != 0) {

  00028	83 7d 10 00	 cmp	 DWORD PTR _iSizePrev$[ebp], 0
  0002c	74 19		 je	 SHORT $L3379

; 1437 :         assert (pau->m_iCurrSubFrame == 0);
; 1438 :         pau->m_subfrmconfigPrev.m_cSubFrame = 1;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00031	c7 80 a4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+164], 1

; 1439 :         pau->m_subfrmconfigPrev.m_rgiSubFrameSize [0] = iSizePrev;

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  0003e	8b 55 10	 mov	 edx, DWORD PTR _iSizePrev$[ebp]
  00041	89 91 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], edx
$L3379:

; 1440 :     }
; 1441 : 
; 1442 :     //first frame in super and first sub frame; init
; 1443 :     if (iSizeCurr != 0) {

  00047	83 7d 14 00	 cmp	 DWORD PTR _iSizeCurr$[ebp], 0
  0004b	74 3b		 je	 SHORT $L3380

; 1444 :         assert (pau->m_iCurrSubFrame == 0);
; 1445 :         pau->m_subfrmconfigCurr.m_cSubFrame = 0;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00050	c7 80 74 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+372], 0

; 1446 :         pau->m_subfrmconfigCurr.m_rgiSubFrameSize [0] = iSizeCurr;

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  0005d	8b 55 14	 mov	 edx, DWORD PTR _iSizeCurr$[ebp]
  00060	89 91 78 01 00
	00		 mov	 DWORD PTR [ecx+376], edx

; 1447 :         pau->m_subfrmconfigCurr.m_rgiSubFrameStart[0] = 0;

  00066	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00069	c7 80 b8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+440], 0

; 1448 :         pau->m_subfrmconfigCurr.m_cSubFrame++;

  00073	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00076	8b 91 74 01 00
	00		 mov	 edx, DWORD PTR [ecx+372]
  0007c	83 c2 01	 add	 edx, 1
  0007f	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00082	89 90 74 01 00
	00		 mov	 DWORD PTR [eax+372], edx
$L3380:

; 1449 :     }
; 1450 : 
; 1451 :     iStartCurr = pau->m_subfrmconfigCurr.m_rgiSubFrameStart [pau->m_iCurrSubFrame] 
; 1452 :                    + pau->m_subfrmconfigCurr.m_rgiSubFrameSize  [pau->m_iCurrSubFrame];

  00088	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  0008b	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  0008e	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00091	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00094	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00097	8b 94 90 b8 01
	00 00		 mov	 edx, DWORD PTR [eax+edx*4+440]
  0009e	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  000a1	03 94 88 78 01
	00 00		 add	 edx, DWORD PTR [eax+ecx*4+376]
  000a8	89 55 f8	 mov	 DWORD PTR _iStartCurr$[ebp], edx

; 1453 :     if (iStartCurr >= pau->m_cFrameSampleHalf) {

  000ab	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  000ae	8b 55 f8	 mov	 edx, DWORD PTR _iStartCurr$[ebp]
  000b1	3b 91 1c 03 00
	00		 cmp	 edx, DWORD PTR [ecx+796]
  000b7	7c 4a		 jl	 SHORT $L3381

; 1454 :         //init the next frame
; 1455 :         paudec->m_fLastSubFrame = WMAB_TRUE;

  000b9	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  000bc	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1

; 1456 :         pau->m_subfrmconfigNext.m_cSubFrame = 0;

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  000c6	c7 81 44 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+580], 0

; 1457 :         pau->m_subfrmconfigNext.m_rgiSubFrameSize [0] = iSizeNext;

  000d0	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  000d3	8b 45 0c	 mov	 eax, DWORD PTR _iSizeNext$[ebp]
  000d6	89 82 48 02 00
	00		 mov	 DWORD PTR [edx+584], eax

; 1458 :         pau->m_subfrmconfigNext.m_rgiSubFrameStart[0] = 0;

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  000df	c7 81 88 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+648], 0

; 1459 :         pau->m_subfrmconfigNext.m_cSubFrame++;

  000e9	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  000ec	8b 82 44 02 00
	00		 mov	 eax, DWORD PTR [edx+580]
  000f2	83 c0 01	 add	 eax, 1
  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  000f8	89 81 44 02 00
	00		 mov	 DWORD PTR [ecx+580], eax

; 1460 :     }
; 1461 :     else {

  000fe	e9 cd 00 00 00	 jmp	 $L3382
$L3381:

; 1462 :         //must be within one frame; must have received the first one
; 1463 :         Int iCurr = pau->m_iCurrSubFrame;

  00103	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00106	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00109	89 45 f4	 mov	 DWORD PTR _iCurr$3383[ebp], eax

; 1464 :         assert (pau->m_subfrmconfigCurr.m_cSubFrame == iCurr + 1);
; 1465 :         assert (iSizeNext < pau->m_cFrameSampleHalf);        //> 1 subfrm
; 1466 :         pau->m_subfrmconfigCurr.m_rgiSubFrameSize [iCurr + 1] = iSizeNext;

  0010c	8b 4d f4	 mov	 ecx, DWORD PTR _iCurr$3383[ebp]
  0010f	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00112	8b 45 0c	 mov	 eax, DWORD PTR _iSizeNext$[ebp]
  00115	89 84 8a 7c 01
	00 00		 mov	 DWORD PTR [edx+ecx*4+380], eax

; 1467 :         pau->m_subfrmconfigCurr.m_rgiSubFrameStart[iCurr + 1] = 
; 1468 :             pau->m_subfrmconfigCurr.m_rgiSubFrameStart[iCurr] + 
; 1469 :             pau->m_subfrmconfigCurr.m_rgiSubFrameSize[iCurr];

  0011c	8b 4d f4	 mov	 ecx, DWORD PTR _iCurr$3383[ebp]
  0011f	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00122	8b 84 8a b8 01
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+440]
  00129	8b 4d f4	 mov	 ecx, DWORD PTR _iCurr$3383[ebp]
  0012c	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  0012f	03 84 8a 78 01
	00 00		 add	 eax, DWORD PTR [edx+ecx*4+376]
  00136	8b 4d f4	 mov	 ecx, DWORD PTR _iCurr$3383[ebp]
  00139	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  0013c	89 84 8a bc 01
	00 00		 mov	 DWORD PTR [edx+ecx*4+444], eax

; 1470 :         if (pau->m_subfrmconfigCurr.m_rgiSubFrameStart[iCurr + 1] + 
; 1471 :             pau->m_subfrmconfigCurr.m_rgiSubFrameSize [iCurr + 1] > pau->m_cFrameSampleHalf)  {

  00143	8b 45 f4	 mov	 eax, DWORD PTR _iCurr$3383[ebp]
  00146	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00149	8b 94 81 bc 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+444]
  00150	8b 45 f4	 mov	 eax, DWORD PTR _iCurr$3383[ebp]
  00153	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00156	03 94 81 7c 01
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+380]
  0015d	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00160	3b 90 1c 03 00
	00		 cmp	 edx, DWORD PTR [eax+796]
  00166	7e 53		 jle	 SHORT $L3384

; 1472 :             assert (WMAB_FALSE);
; 1473 :             return TraceResult(WMA_E_BROKEN_FRAME);

  00168	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  0016e	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  00174	74 37		 je	 SHORT $L3629
  00176	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  0017c	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  00182	74 29		 je	 SHORT $L3629
  00184	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  00189	50		 push	 eax
  0018a	68 c1 05 00 00	 push	 1473			; 000005c1H
  0018f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00194	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00199	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  0019f	51		 push	 ecx
  001a0	e8 00 00 00 00	 call	 _MyOutputDbgStr
  001a5	83 c4 14	 add	 esp, 20			; 00000014H
  001a8	89 45 f0	 mov	 DWORD PTR tv168[ebp], eax
  001ab	eb 09		 jmp	 SHORT $L3630
$L3629:
  001ad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  001b3	89 55 f0	 mov	 DWORD PTR tv168[ebp], edx
$L3630:
  001b6	8b 45 f0	 mov	 eax, DWORD PTR tv168[ebp]
  001b9	eb 1a		 jmp	 SHORT $L3375
$L3384:

; 1474 :         }
; 1475 :         pau->m_subfrmconfigCurr.m_cSubFrame++;

  001bb	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  001be	8b 88 74 01 00
	00		 mov	 ecx, DWORD PTR [eax+372]
  001c4	83 c1 01	 add	 ecx, 1
  001c7	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  001ca	89 8a 74 01 00
	00		 mov	 DWORD PTR [edx+372], ecx
$L3382:

; 1476 :     }
; 1477 : /***
; 1478 : #ifdef PROFILE
; 1479 :     //FunctionProfileStop(&fp);
; 1480 : #endif
; 1481 : *///
; 1482 :     return WMA_OK;

  001d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
$L3375:

; 1483 : }

  001d5	8b e5		 mov	 esp, ebp
  001d7	5d		 pop	 ebp
  001d8	c2 10 00	 ret	 16			; 00000010H
_prvUpdateSubFrameConfig_XDS@16 ENDP
WMADEC	ENDS
PUBLIC	_ibstrmBitsLeft@4
PUBLIC	_ibstrmFlush@4
EXTRN	_auReconCoefficentsHighRate_XDS@16:NEAR
EXTRN	_SetActualPowerHighRate_XDS@16:NEAR
; Function compile flags: /Odt
;	COMDAT _prvDecodeSubFrameHighRate_XDS@8
WMADEC	SEGMENT
tv248 = -64
tv169 = -60
tv78 = -56
tv65 = -52
_ppcinfo$3446 = -48
_fltAfterScaleFactor$3441 = -44
_iChannel$3409 = -40
_hr$ = -36
_pctCoefRecon0$ = -32
_ctTemp0$ = -28
_ppcinfo$ = -24
_pctCoefRecon1$ = -20
_iChannel$ = -16
_ctTemp1$ = -12
_pau$ = -8
_i$ = -4
_paudec$ = 8
_piBitCnt$ = 12
_prvDecodeSubFrameHighRate_XDS@8 PROC NEAR		; COMDAT

; 1491 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 1492 :     WMARESULT hr = WMA_OK;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000b	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 1493 :     Int     iChannel,i;
; 1494 :     PerChannelInfo* ppcinfo;
; 1495 :     CoefType *pctCoefRecon0,*pctCoefRecon1, ctTemp0, ctTemp1;
; 1496 :     CAudioObject* pau = paudec->pau;

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00011	8b 11		 mov	 edx, DWORD PTR [ecx]
  00013	89 55 f8	 mov	 DWORD PTR _pau$[ebp], edx

; 1497 : 
; 1498 : #ifdef PROFILE
; 1499 :     //FunctionProfile fp;
; 1500 :     //FunctionProfileStart(&fp,DECODE_SUB_FRAME_HIGH_RATE_PROFILE);
; 1501 : #endif  // PROFILE
; 1502 : 
; 1503 :     assert(0 == *piBitCnt); // Need this assumption, storing bit allocs for transcoding
; 1504 : 
; 1505 :     switch (paudec->m_subfrmdecsts)
; 1506 :     {

  00016	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00019	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0001c	89 4d cc	 mov	 DWORD PTR tv65[ebp], ecx
  0001f	83 7d cc 00	 cmp	 DWORD PTR tv65[ebp], 0
  00023	74 19		 je	 SHORT $L3403
  00025	83 7d cc 01	 cmp	 DWORD PTR tv65[ebp], 1
  00029	0f 84 1b 01 00
	00		 je	 $L3416
  0002f	83 7d cc 02	 cmp	 DWORD PTR tv65[ebp], 2
  00033	0f 84 18 02 00
	00		 je	 $L3426
  00039	e9 5c 04 00 00	 jmp	 $exit$3406
$L3403:

; 1507 :         case SUBFRM_HDR :   
; 1508 :             TRACEWMA_EXIT(hr, prvDecodeFrameHeader(paudec, piBitCnt));    

  0003e	8b 55 0c	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  00041	52		 push	 edx
  00042	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _prvDecodeFrameHeader_XDS@8
  0004b	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax
  0004e	83 7d dc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00052	7d 45		 jge	 SHORT $L3407
  00054	8b 4d dc	 mov	 ecx, DWORD PTR _hr$[ebp]
  00057	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  0005d	74 2f		 je	 SHORT $L3634
  0005f	8b 55 dc	 mov	 edx, DWORD PTR _hr$[ebp]
  00062	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  00068	74 24		 je	 SHORT $L3634
  0006a	8b 45 dc	 mov	 eax, DWORD PTR _hr$[ebp]
  0006d	50		 push	 eax
  0006e	68 e4 05 00 00	 push	 1508			; 000005e4H
  00073	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0007d	8b 4d dc	 mov	 ecx, DWORD PTR _hr$[ebp]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00086	83 c4 14	 add	 esp, 20			; 00000014H
  00089	89 45 c8	 mov	 DWORD PTR tv78[ebp], eax
  0008c	eb 06		 jmp	 SHORT $L3635
$L3634:
  0008e	8b 55 dc	 mov	 edx, DWORD PTR _hr$[ebp]
  00091	89 55 c8	 mov	 DWORD PTR tv78[ebp], edx
$L3635:
  00094	e9 01 04 00 00	 jmp	 $exit$3406
$L3407:

; 1509 :             pau->m_qstQuantStep = qstCalcQuantStep(pau->m_iQuantStepSize);

  00099	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  0009c	8b 88 44 03 00
	00		 mov	 ecx, DWORD PTR [eax+836]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 _qstCalcQuantStep_XDS@4
  000a8	8b 55 f8	 mov	 edx, DWORD PTR _pau$[ebp]
  000ab	d9 1a		 fstp	 DWORD PTR [edx]

; 1510 :             if (paudec->m_hdrdecsts == HDR_DONE)

  000ad	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  000b0	83 78 1c 06	 cmp	 DWORD PTR [eax+28], 6
  000b4	0f 85 8b 00 00
	00		 jne	 $L3408

; 1511 :             {
; 1512 :                 I16 iChannel;
; 1513 :                 for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)

  000ba	66 c7 45 d8 00
	00		 mov	 WORD PTR _iChannel$3409[ebp], 0
  000c0	eb 0c		 jmp	 SHORT $L3410
$L3411:
  000c2	66 8b 4d d8	 mov	 cx, WORD PTR _iChannel$3409[ebp]
  000c6	66 83 c1 01	 add	 cx, 1
  000ca	66 89 4d d8	 mov	 WORD PTR _iChannel$3409[ebp], cx
$L3410:
  000ce	0f bf 55 d8	 movsx	 edx, WORD PTR _iChannel$3409[ebp]
  000d2	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  000d5	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  000d9	3b d1		 cmp	 edx, ecx
  000db	7d 33		 jge	 SHORT $L3412

; 1514 :                 {
; 1515 :                     ppcinfo = pau->m_rgpcinfo + iChannel;

  000dd	0f bf 55 d8	 movsx	 edx, WORD PTR _iChannel$3409[ebp]
  000e1	6b d2 70	 imul	 edx, 112		; 00000070H
  000e4	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  000e7	03 90 a0 03 00
	00		 add	 edx, DWORD PTR [eax+928]
  000ed	89 55 e8	 mov	 DWORD PTR _ppcinfo$[ebp], edx

; 1516 :                     memset (ppcinfo->m_rgiCoefRecon, 0, sizeof (CoefType) * pau->m_cHighCutOff);

  000f0	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  000f3	8b 91 28 03 00
	00		 mov	 edx, DWORD PTR [ecx+808]
  000f9	c1 e2 02	 shl	 edx, 2
  000fc	52		 push	 edx
  000fd	6a 00		 push	 0
  000ff	8b 45 e8	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00102	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00105	51		 push	 ecx
  00106	e8 00 00 00 00	 call	 _memset
  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1517 :                 }

  0010e	eb b2		 jmp	 SHORT $L3411
$L3412:

; 1518 :                 paudec->m_subfrmdecsts = SUBFRM_COEF;

  00110	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00113	c7 42 18 01 00
	00 00		 mov	 DWORD PTR [edx+24], 1

; 1519 : 
; 1520 : #ifdef TRANSCODER
; 1521 :                 if (TT_SIMPLE == pau->m_ttTranscodeType)
; 1522 :                     paudec->pau->m_iCurrReconCoef = 0;
; 1523 :                 else
; 1524 : #endif  // TRANSCODER
; 1525 :                     //iRecon is offset by -1 so comarison 
; 1526 :                     paudec->pau->m_iCurrReconCoef = (I16) pau->m_cLowCutOff-1;

  0011a	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  0011d	0f bf 88 24 03
	00 00		 movsx	 ecx, WORD PTR [eax+804]
  00124	83 e9 01	 sub	 ecx, 1
  00127	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0012a	8b 02		 mov	 eax, DWORD PTR [edx]
  0012c	66 89 48 74	 mov	 WORD PTR [eax+116], cx

; 1527 : 
; 1528 :                 paudec->m_iChannel = 0;

  00130	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00133	66 c7 41 24 00
	00		 mov	 WORD PTR [ecx+36], 0

; 1529 :                 paudec->m_rlsts = VLC;

  00139	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0013c	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0

; 1530 :             }
; 1531 :             else

  00143	eb 05		 jmp	 SHORT $L3416
$L3408:

; 1532 :                 break;

  00145	e9 50 03 00 00	 jmp	 $exit$3406
$L3416:

; 1533 : 
; 1534 :         case SUBFRM_COEF:
; 1535 : #ifdef TRANSCODER
; 1536 :             if (TT_SIMPLE == pau->m_ttTranscodeType)
; 1537 :             {
; 1538 :                 TRACEWMA_EXIT(hr, (*(paudec->m_pfnDecodeCoefficient))(paudec,
; 1539 :                     pau->m_rgpcinfo, piBitCnt));
; 1540 :                 paudec->m_iChannel = 0;
; 1541 :             }
; 1542 : #endif  // TRANSCODER
; 1543 : 
; 1544 :             //Decode coefficents for sum channel or left & right channels 
; 1545 :             for (; paudec->m_iChannel < pau->m_cChannel; paudec->m_iChannel++) 

  0014a	eb 12		 jmp	 SHORT $L3417
$L3418:
  0014c	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0014f	66 8b 48 24	 mov	 cx, WORD PTR [eax+36]
  00153	66 83 c1 01	 add	 cx, 1
  00157	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0015a	66 89 4a 24	 mov	 WORD PTR [edx+36], cx
$L3417:
  0015e	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00161	0f bf 48 24	 movsx	 ecx, WORD PTR [eax+36]
  00165	8b 55 f8	 mov	 edx, DWORD PTR _pau$[ebp]
  00168	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  0016c	3b c8		 cmp	 ecx, eax
  0016e	0f 8d d3 00 00
	00		 jge	 $L3419

; 1546 :             {
; 1547 :                 ppcinfo = pau->m_rgpcinfo + paudec->m_iChannel;

  00174	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00177	0f bf 51 24	 movsx	 edx, WORD PTR [ecx+36]
  0017b	6b d2 70	 imul	 edx, 112		; 00000070H
  0017e	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  00181	03 90 a0 03 00
	00		 add	 edx, DWORD PTR [eax+928]
  00187	89 55 e8	 mov	 DWORD PTR _ppcinfo$[ebp], edx

; 1548 : 
; 1549 : #ifdef TRANSCODER
; 1550 :                 if (TT_SIMPLE == pau->m_ttTranscodeType)
; 1551 :                     prvInverseQuantizeTRANSCODE(pau, ppcinfo, NULL);
; 1552 :                 else
; 1553 : #endif  // TRANSCODER
; 1554 :                 {
; 1555 :                     if (ppcinfo->m_iPower != 0)

  0018a	8b 4d e8	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  0018d	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00191	74 65		 je	 SHORT $L3420

; 1556 :                     {
; 1557 :                         TRACEWMA_EXIT(hr, auReconCoefficentsHighRate (paudec->pau,
; 1558 :                             paudec, ppcinfo, piBitCnt));

  00193	8b 55 0c	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  00196	52		 push	 edx
  00197	8b 45 e8	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  0019a	50		 push	 eax
  0019b	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0019e	51		 push	 ecx
  0019f	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  001a2	8b 02		 mov	 eax, DWORD PTR [edx]
  001a4	50		 push	 eax
  001a5	e8 00 00 00 00	 call	 _auReconCoefficentsHighRate_XDS@16
  001aa	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax
  001ad	83 7d dc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001b1	7d 45		 jge	 SHORT $L3420
  001b3	8b 4d dc	 mov	 ecx, DWORD PTR _hr$[ebp]
  001b6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  001bc	74 2f		 je	 SHORT $L3636
  001be	8b 55 dc	 mov	 edx, DWORD PTR _hr$[ebp]
  001c1	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  001c7	74 24		 je	 SHORT $L3636
  001c9	8b 45 dc	 mov	 eax, DWORD PTR _hr$[ebp]
  001cc	50		 push	 eax
  001cd	68 16 06 00 00	 push	 1558			; 00000616H
  001d2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  001d7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  001dc	8b 4d dc	 mov	 ecx, DWORD PTR _hr$[ebp]
  001df	51		 push	 ecx
  001e0	e8 00 00 00 00	 call	 _MyOutputDbgStr
  001e5	83 c4 14	 add	 esp, 20			; 00000014H
  001e8	89 45 c4	 mov	 DWORD PTR tv169[ebp], eax
  001eb	eb 06		 jmp	 SHORT $L3637
$L3636:
  001ed	8b 55 dc	 mov	 edx, DWORD PTR _hr$[ebp]
  001f0	89 55 c4	 mov	 DWORD PTR tv169[ebp], edx
$L3637:
  001f3	e9 a2 02 00 00	 jmp	 $exit$3406
$L3420:

; 1559 :                     }
; 1560 :                 }
; 1561 : 
; 1562 :                 if(pau->m_iVersion == 1) 

  001f8	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  001fb	83 78 44 01	 cmp	 DWORD PTR [eax+68], 1
  001ff	75 2b		 jne	 SHORT $L3424

; 1563 :                 {
; 1564 :                     *piBitCnt += ibstrmBitsLeft (&paudec->m_ibstrm) % 8;

  00201	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00204	83 c1 30	 add	 ecx, 48			; 00000030H
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 _ibstrmBitsLeft@4
  0020d	33 d2		 xor	 edx, edx
  0020f	b9 08 00 00 00	 mov	 ecx, 8
  00214	f7 f1		 div	 ecx
  00216	8b 45 0c	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  00219	03 10		 add	 edx, DWORD PTR [eax]
  0021b	8b 4d 0c	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  0021e	89 11		 mov	 DWORD PTR [ecx], edx

; 1565 :                     ibstrmFlush(&paudec->m_ibstrm);

  00220	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00223	83 c2 30	 add	 edx, 48			; 00000030H
  00226	52		 push	 edx
  00227	e8 00 00 00 00	 call	 _ibstrmFlush@4
$L3424:

; 1566 :                 }
; 1567 :                 assert (paudec->pau->m_iCurrReconCoef < (I16) pau->m_cSubband);
; 1568 :                 paudec->pau->m_iCurrReconCoef = (I16) pau->m_cLowCutOff-1;             //iRecon is offset by -1 so comarison 

  0022c	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  0022f	0f bf 88 24 03
	00 00		 movsx	 ecx, WORD PTR [eax+804]
  00236	83 e9 01	 sub	 ecx, 1
  00239	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0023c	8b 02		 mov	 eax, DWORD PTR [edx]
  0023e	66 89 48 74	 mov	 WORD PTR [eax+116], cx

; 1569 :             }

  00242	e9 05 ff ff ff	 jmp	 $L3418
$L3419:

; 1570 :             paudec->m_subfrmdecsts = SUBFRM_DONE;

  00247	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0024a	c7 41 18 02 00
	00 00		 mov	 DWORD PTR [ecx+24], 2
$L3426:

; 1571 : 
; 1572 :         case SUBFRM_DONE:
; 1573 :             for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {

  00251	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iChannel$[ebp], 0
  00258	eb 09		 jmp	 SHORT $L3427
$L3428:
  0025a	8b 55 f0	 mov	 edx, DWORD PTR _iChannel$[ebp]
  0025d	83 c2 01	 add	 edx, 1
  00260	89 55 f0	 mov	 DWORD PTR _iChannel$[ebp], edx
$L3427:
  00263	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  00266	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  0026a	39 4d f0	 cmp	 DWORD PTR _iChannel$[ebp], ecx
  0026d	7d 78		 jge	 SHORT $L3429

; 1574 :                 ppcinfo = pau->m_rgpcinfo + iChannel;

  0026f	8b 55 f0	 mov	 edx, DWORD PTR _iChannel$[ebp]
  00272	6b d2 70	 imul	 edx, 112		; 00000070H
  00275	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  00278	03 90 a0 03 00
	00		 add	 edx, DWORD PTR [eax+928]
  0027e	89 55 e8	 mov	 DWORD PTR _ppcinfo$[ebp], edx

; 1575 :                 if (ppcinfo->m_iPower != 0)

  00281	8b 4d e8	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00284	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00288	74 33		 je	 SHORT $L3430

; 1576 :                 {
; 1577 :                     // WMA Timestamps: To detect start-of-stream and discard correct amount of silence,
; 1578 :                     // we need to verify claim that m_iPower[*] = 1, ForceMaskUpdate and actual power = 0.
; 1579 :                     ppcinfo->m_iActualPower = 0;

  0028a	8b 55 e8	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  0028d	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], 0

; 1580 :                     if (CODEC_BEGIN == pau->m_codecStatus)

  00294	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  00297	83 78 48 03	 cmp	 DWORD PTR [eax+72], 3
  0029b	75 1e		 jne	 SHORT $L3431

; 1581 :                     {
; 1582 :                         SetActualPowerHighRate (ppcinfo->m_rgiCoefRecon, 
; 1583 :                                                 pau->m_cSubband, ppcinfo, pau->m_codecStatus);

  0029d	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  002a0	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  002a3	52		 push	 edx
  002a4	8b 45 e8	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  002a7	50		 push	 eax
  002a8	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  002ab	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  002ae	52		 push	 edx
  002af	8b 45 e8	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  002b2	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  002b5	51		 push	 ecx
  002b6	e8 00 00 00 00	 call	 _SetActualPowerHighRate_XDS@16
$L3431:

; 1584 :                     }
; 1585 :                 }
; 1586 :                 else 

  002bb	eb 25		 jmp	 SHORT $L3432
$L3430:

; 1587 :                 {
; 1588 :                     memset (ppcinfo->COEF, 0, sizeof (CoefType) * pau->m_cSubbandAdjusted);

  002bd	8b 55 f8	 mov	 edx, DWORD PTR _pau$[ebp]
  002c0	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  002c3	c1 e0 02	 shl	 eax, 2
  002c6	50		 push	 eax
  002c7	6a 00		 push	 0
  002c9	8b 4d e8	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  002cc	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  002cf	52		 push	 edx
  002d0	e8 00 00 00 00	 call	 _memset
  002d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1589 :                     ppcinfo->m_iActualPower = 0;

  002d8	8b 45 e8	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  002db	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
$L3432:

; 1590 :                 }
; 1591 :             }

  002e2	e9 73 ff ff ff	 jmp	 $L3428
$L3429:

; 1592 : #if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
; 1593 :             if (pau->m_cChannel==1)
; 1594 :                 prvWmaShowFrames(pau, "\nDecSubH", " %2d   0x%08x            [%4d %4d %4d]",
; 1595 :                     pau->m_rgpcinfo[0].m_iPower,
; 1596 :                     pau->m_rgpcinfo[0].m_rgiCoefRecon,
; 1597 :                     pau->m_cFrameSample,
; 1598 :                     pau->m_cSubFrameSample,
; 1599 :                     pau->m_cSubband );
; 1600 :             else
; 1601 :                 prvWmaShowFrames(pau, "\nDecSubH", " %2d%2d 0x%08x 0x%08x [%4d %4d %4d]",
; 1602 :                     pau->m_rgpcinfo[0].m_iPower,
; 1603 :                     pau->m_rgpcinfo[1].m_iPower,
; 1604 :                     pau->m_rgpcinfo[0].m_rgiCoefRecon,
; 1605 :                     pau->m_rgpcinfo[1].m_rgiCoefRecon,
; 1606 :                     pau->m_cFrameSample,
; 1607 :                     pau->m_cSubFrameSample,
; 1608 :                     pau->m_cSubband );
; 1609 : #endif
; 1610 : 
; 1611 : #ifdef TRANSCODER
; 1612 :             // If performing simple transcode, we don't need to do any more processing
; 1613 :             if (TT_SIMPLE == pau->m_ttTranscodeType)
; 1614 :             {
; 1615 :                 for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
; 1616 :                 {
; 1617 :                     PerChannelInfo *ppcinfo = &pau->m_rgpcinfo[iChannel];
; 1618 : 
; 1619 :                     //start recursion
; 1620 :                     ppcinfo->m_iSin  = SIN_START;
; 1621 :                     ppcinfo->m_iCos  = COS_START;
; 1622 :                     ppcinfo->m_iSin1 = SIN1_START;
; 1623 :                     ppcinfo->m_iCos1 = COS1_START;
; 1624 :                     ppcinfo->m_iStep = SIN_STEP;
; 1625 :                 }
; 1626 :                 break;
; 1627 :             }
; 1628 : #endif  // TRANSCODER
; 1629 : 
; 1630 :             //convert s/d to l/r
; 1631 :             if (pau->m_cChannel == 2 && pau->m_stereoMode == STEREO_SUMDIFF && 
; 1632 :                             (pau->m_rgpcinfo[0].m_iPower != 0 || pau->m_rgpcinfo[1].m_iPower != 0)) {

  002e7	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  002ea	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  002ee	83 fa 02	 cmp	 edx, 2
  002f1	0f 85 d0 00 00
	00		 jne	 $L3434
  002f7	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  002fa	83 b8 38 03 00
	00 01		 cmp	 DWORD PTR [eax+824], 1
  00301	0f 85 c0 00 00
	00		 jne	 $L3434
  00307	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  0030a	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  00310	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  00314	75 16		 jne	 SHORT $L3435
  00316	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  00319	8b 88 a0 03 00
	00		 mov	 ecx, DWORD PTR [eax+928]
  0031f	83 b9 94 00 00
	00 00		 cmp	 DWORD PTR [ecx+148], 0
  00326	0f 84 9b 00 00
	00		 je	 $L3434
$L3435:

; 1633 :                 pctCoefRecon0 = (CoefType*)pau->m_rgpcinfo[0].m_rgiCoefRecon;

  0032c	8b 55 f8	 mov	 edx, DWORD PTR _pau$[ebp]
  0032f	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  00335	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00338	89 4d e0	 mov	 DWORD PTR _pctCoefRecon0$[ebp], ecx

; 1634 :                 pctCoefRecon1 = (CoefType*)pau->m_rgpcinfo[1].m_rgiCoefRecon;

  0033b	8b 55 f8	 mov	 edx, DWORD PTR _pau$[ebp]
  0033e	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  00344	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0034a	89 4d ec	 mov	 DWORD PTR _pctCoefRecon1$[ebp], ecx

; 1635 :                 for (i = pau->m_cHighCutOffAdjusted; i >0; i--) {

  0034d	8b 55 f8	 mov	 edx, DWORD PTR _pau$[ebp]
  00350	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  00356	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00359	eb 09		 jmp	 SHORT $L3438
$L3439:
  0035b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0035e	83 e9 01	 sub	 ecx, 1
  00361	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L3438:
  00364	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00368	7e 3a		 jle	 SHORT $L3440

; 1636 :                     ctTemp0 = *pctCoefRecon0;

  0036a	8b 55 e0	 mov	 edx, DWORD PTR _pctCoefRecon0$[ebp]
  0036d	8b 02		 mov	 eax, DWORD PTR [edx]
  0036f	89 45 e4	 mov	 DWORD PTR _ctTemp0$[ebp], eax

; 1637 :                     *pctCoefRecon0++ = ctTemp0 + (ctTemp1 = *pctCoefRecon1);

  00372	8b 4d ec	 mov	 ecx, DWORD PTR _pctCoefRecon1$[ebp]
  00375	8b 11		 mov	 edx, DWORD PTR [ecx]
  00377	89 55 f4	 mov	 DWORD PTR _ctTemp1$[ebp], edx
  0037a	d9 45 f4	 fld	 DWORD PTR _ctTemp1$[ebp]
  0037d	d8 45 e4	 fadd	 DWORD PTR _ctTemp0$[ebp]
  00380	8b 45 e0	 mov	 eax, DWORD PTR _pctCoefRecon0$[ebp]
  00383	d9 18		 fstp	 DWORD PTR [eax]
  00385	8b 4d e0	 mov	 ecx, DWORD PTR _pctCoefRecon0$[ebp]
  00388	83 c1 04	 add	 ecx, 4
  0038b	89 4d e0	 mov	 DWORD PTR _pctCoefRecon0$[ebp], ecx

; 1638 :                     *pctCoefRecon1++ = ctTemp0 - ctTemp1;

  0038e	d9 45 e4	 fld	 DWORD PTR _ctTemp0$[ebp]
  00391	d8 65 f4	 fsub	 DWORD PTR _ctTemp1$[ebp]
  00394	8b 55 ec	 mov	 edx, DWORD PTR _pctCoefRecon1$[ebp]
  00397	d9 1a		 fstp	 DWORD PTR [edx]
  00399	8b 45 ec	 mov	 eax, DWORD PTR _pctCoefRecon1$[ebp]
  0039c	83 c0 04	 add	 eax, 4
  0039f	89 45 ec	 mov	 DWORD PTR _pctCoefRecon1$[ebp], eax

; 1639 :                 }

  003a2	eb b7		 jmp	 SHORT $L3439
$L3440:

; 1640 :                 pau->m_rgpcinfo[0].m_iPower = 1;

  003a4	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  003a7	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  003ad	c7 42 24 01 00
	00 00		 mov	 DWORD PTR [edx+36], 1

; 1641 :                 pau->m_rgpcinfo[1].m_iPower = 1;

  003b4	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  003b7	8b 88 a0 03 00
	00		 mov	 ecx, DWORD PTR [eax+928]
  003bd	c7 81 94 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+148], 1
$L3434:

; 1642 :                 assert( pctCoefRecon0 == (CoefType*)pau->m_rgpcinfo [0].m_rgiCoefRecon + pau->m_cHighCutOffAdjusted );
; 1643 :                 assert( pctCoefRecon1 == (CoefType*)pau->m_rgpcinfo [1].m_rgiCoefRecon + pau->m_cHighCutOffAdjusted );
; 1644 :             }
; 1645 : 
; 1646 : #ifdef ENABLE_EQUALIZER
; 1647 :             //equalize
; 1648 :             for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {
; 1649 :                 if (pau->m_rgpcinfo[iChannel].m_iPower != 0) {
; 1650 :                     TRACEWMA_EXIT(hr, prvEqualize(paudec, pau->m_rgpcinfo + iChannel));
; 1651 : 
; 1652 :                     if (paudec->m_fComputeBandPower == WMAB_TRUE)
; 1653 :                         prvComputeBandPower (paudec);
; 1654 :                 }
; 1655 :             }
; 1656 : #endif // ENABLE_EQUALIZER
; 1657 :     
; 1658 :             {
; 1659 :                 Float fltAfterScaleFactor = (pau->m_iVersion == 1) ? pau->m_fltDctScale :
; 1660 :                     (Float)(2.0f/pau->m_cSubband);

  003c7	8b 55 f8	 mov	 edx, DWORD PTR _pau$[ebp]
  003ca	83 7a 44 01	 cmp	 DWORD PTR [edx+68], 1
  003ce	75 0e		 jne	 SHORT $L3638
  003d0	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  003d3	8b 88 4c 03 00
	00		 mov	 ecx, DWORD PTR [eax+844]
  003d9	89 4d c0	 mov	 DWORD PTR tv248[ebp], ecx
  003dc	eb 0f		 jmp	 SHORT $L3639
$L3638:
  003de	8b 55 f8	 mov	 edx, DWORD PTR _pau$[ebp]
  003e1	db 42 60	 fild	 DWORD PTR [edx+96]
  003e4	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@40000000
  003ea	d9 5d c0	 fstp	 DWORD PTR tv248[ebp]
$L3639:
  003ed	8b 45 c0	 mov	 eax, DWORD PTR tv248[ebp]
  003f0	89 45 d4	 mov	 DWORD PTR _fltAfterScaleFactor$3441[ebp], eax

; 1661 : 
; 1662 :                 for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {

  003f3	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iChannel$[ebp], 0
  003fa	eb 09		 jmp	 SHORT $L3443
$L3444:
  003fc	8b 4d f0	 mov	 ecx, DWORD PTR _iChannel$[ebp]
  003ff	83 c1 01	 add	 ecx, 1
  00402	89 4d f0	 mov	 DWORD PTR _iChannel$[ebp], ecx
$L3443:
  00405	8b 55 f8	 mov	 edx, DWORD PTR _pau$[ebp]
  00408	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  0040c	39 45 f0	 cmp	 DWORD PTR _iChannel$[ebp], eax
  0040f	0f 8d 85 00 00
	00		 jge	 $exit$3406

; 1663 :                     PerChannelInfo* ppcinfo = pau->m_rgpcinfo + iChannel;

  00415	8b 4d f0	 mov	 ecx, DWORD PTR _iChannel$[ebp]
  00418	6b c9 70	 imul	 ecx, 112		; 00000070H
  0041b	8b 55 f8	 mov	 edx, DWORD PTR _pau$[ebp]
  0041e	03 8a a0 03 00
	00		 add	 ecx, DWORD PTR [edx+928]
  00424	89 4d d0	 mov	 DWORD PTR _ppcinfo$3446[ebp], ecx

; 1664 : #if defined(INTERPOLATED_DOWNSAMPLE)
; 1665 :                     if (paudec->pau->m_fLowPass)
; 1666 :                         auLowPass(paudec->pau, (CoefType*) ppcinfo->COEF, pau->m_cSubband / 2);
; 1667 : #endif  // defined(INTERPOLATED_DOWNSAMPLE)
; 1668 :                     if (ppcinfo->m_iPower != 0) 

  00427	8b 45 d0	 mov	 eax, DWORD PTR _ppcinfo$3446[ebp]
  0042a	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0042e	74 1a		 je	 SHORT $L3447

; 1669 :                         (*pau->aupfnDctIV) (pau, (CoefType*) ppcinfo->COEF, fltAfterScaleFactor, NULL);

  00430	6a 00		 push	 0
  00432	8b 4d d4	 mov	 ecx, DWORD PTR _fltAfterScaleFactor$3441[ebp]
  00435	51		 push	 ecx
  00436	8b 55 d0	 mov	 edx, DWORD PTR _ppcinfo$3446[ebp]
  00439	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0043c	50		 push	 eax
  0043d	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  00440	51		 push	 ecx
  00441	8b 55 f8	 mov	 edx, DWORD PTR _pau$[ebp]
  00444	ff 92 fc 03 00
	00		 call	 DWORD PTR [edx+1020]
$L3447:

; 1670 : 
; 1671 :                     //start recursion
; 1672 :                     ppcinfo->m_iSin  = SIN_START;

  0044a	8b 45 d0	 mov	 eax, DWORD PTR _ppcinfo$3446[ebp]
  0044d	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  00450	8b 91 58 03 00
	00		 mov	 edx, DWORD PTR [ecx+856]
  00456	89 50 4c	 mov	 DWORD PTR [eax+76], edx

; 1673 :                     ppcinfo->m_iCos  = COS_START;

  00459	8b 45 d0	 mov	 eax, DWORD PTR _ppcinfo$3446[ebp]
  0045c	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  0045f	8b 91 5c 03 00
	00		 mov	 edx, DWORD PTR [ecx+860]
  00465	89 50 50	 mov	 DWORD PTR [eax+80], edx

; 1674 :                     ppcinfo->m_iSin1 = SIN1_START;

  00468	8b 45 d0	 mov	 eax, DWORD PTR _ppcinfo$3446[ebp]
  0046b	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  0046e	8b 91 60 03 00
	00		 mov	 edx, DWORD PTR [ecx+864]
  00474	89 50 54	 mov	 DWORD PTR [eax+84], edx

; 1675 :                     ppcinfo->m_iCos1 = COS1_START;

  00477	8b 45 d0	 mov	 eax, DWORD PTR _ppcinfo$3446[ebp]
  0047a	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  0047d	8b 91 64 03 00
	00		 mov	 edx, DWORD PTR [ecx+868]
  00483	89 50 58	 mov	 DWORD PTR [eax+88], edx

; 1676 :                     ppcinfo->m_iStep = SIN_STEP;

  00486	8b 45 d0	 mov	 eax, DWORD PTR _ppcinfo$3446[ebp]
  00489	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  0048c	8b 91 68 03 00
	00		 mov	 edx, DWORD PTR [ecx+872]
  00492	89 50 5c	 mov	 DWORD PTR [eax+92], edx

; 1677 :                 }

  00495	e9 62 ff ff ff	 jmp	 $L3444
$exit$3406:

; 1678 :             }
; 1679 :     }
; 1680 : 
; 1681 : exit:
; 1682 : #ifdef PROFILE
; 1683 :     //FunctionProfileStop(&fp);
; 1684 : #endif  // PROFILE
; 1685 : 
; 1686 :     return hr;

  0049a	8b 45 dc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1687 : }

  0049d	8b e5		 mov	 esp, ebp
  0049f	5d		 pop	 ebp
  004a0	c2 08 00	 ret	 8
_prvDecodeSubFrameHighRate_XDS@8 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\decoder\strmdec_wma.h
WMADEC	ENDS
;	COMDAT _ibstrmBitsLeft@4
WMADEC	SEGMENT
_pibstrm$ = 8
_ibstrmBitsLeft@4 PROC NEAR				; COMDAT

; 80   : INLINE UInt ibstrmBitsLeft (const CWMAInputBitStream* pibstrm) {return pibstrm->m_dwBitsLeft;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00006	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
_ibstrmBitsLeft@4 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _ibstrmFlush@4
WMADEC	SEGMENT
_pibstrm$ = 8
_ibstrmFlush@4 PROC NEAR				; COMDAT

; 104  :                         { pibstrm->m_dwBitsLeft -= (pibstrm->m_dwBitsLeft % 8); } 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00006	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00009	33 d2		 xor	 edx, edx
  0000b	b9 08 00 00 00	 mov	 ecx, 8
  00010	f7 f1		 div	 ecx
  00012	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00015	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00018	2b ca		 sub	 ecx, edx
  0001a	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0001d	89 4a 24	 mov	 DWORD PTR [edx+36], ecx
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
_ibstrmFlush@4 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\msaudiodec.c
WMADEC	ENDS
;	COMDAT _prvWMAGetMoreData_XDS@16
WMADEC	SEGMENT
tv77 = -8
_paudec$ = -4
_ppBuffer$ = 8
_pcbBuffer$ = 12
_dwUserData$ = 16
_pDummy$ = 20
_prvWMAGetMoreData_XDS@16 PROC NEAR			; COMDAT

; 1698 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1699 :     CAudioObjectDecoder* paudec = (CAudioObjectDecoder*) dwUserData;

  00006	8b 45 10	 mov	 eax, DWORD PTR _dwUserData$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _paudec$[ebp], eax

; 1700 : 
; 1701 :     if(paudec == NULL || ppBuffer == NULL || pcbBuffer == NULL)

  0000c	83 7d fc 00	 cmp	 DWORD PTR _paudec$[ebp], 0
  00010	74 0c		 je	 SHORT $L3470
  00012	83 7d 08 00	 cmp	 DWORD PTR _ppBuffer$[ebp], 0
  00016	74 06		 je	 SHORT $L3470
  00018	83 7d 0c 00	 cmp	 DWORD PTR _pcbBuffer$[ebp], 0
  0001c	75 70		 jne	 SHORT $L3469
$L3470:

; 1702 :     {
; 1703 :         if(ppBuffer != NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _ppBuffer$[ebp], 0
  00022	74 09		 je	 SHORT $L3472

; 1704 :             *ppBuffer = NULL;

  00024	8b 4d 08	 mov	 ecx, DWORD PTR _ppBuffer$[ebp]
  00027	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L3472:

; 1705 :         if(pcbBuffer != NULL)

  0002d	83 7d 0c 00	 cmp	 DWORD PTR _pcbBuffer$[ebp], 0
  00031	74 09		 je	 SHORT $L3475

; 1706 :             *pcbBuffer = 0;

  00033	8b 55 0c	 mov	 edx, DWORD PTR _pcbBuffer$[ebp]
  00036	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L3475:

; 1707 : 
; 1708 :         assert(WMAB_FALSE);
; 1709 :         return TraceResult(WMA_E_INVALIDARG);

  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  00041	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00047	74 37		 je	 SHORT $L3649
  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_INVALIDARG
  0004f	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  00055	74 29		 je	 SHORT $L3649
  00057	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_INVALIDARG
  0005d	52		 push	 edx
  0005e	68 ad 06 00 00	 push	 1709			; 000006adH
  00063	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@EBIOAIHO@c?3?2xbox?2private?2windows?2directx?2@
  00068	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0006d	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00078	83 c4 14	 add	 esp, 20			; 00000014H
  0007b	89 45 f8	 mov	 DWORD PTR tv77[ebp], eax
  0007e	eb 09		 jmp	 SHORT $L3650
$L3649:
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_INVALIDARG
  00086	89 4d f8	 mov	 DWORD PTR tv77[ebp], ecx
$L3650:
  00089	8b 45 f8	 mov	 eax, DWORD PTR tv77[ebp]
  0008c	eb 38		 jmp	 SHORT $L3463
$L3469:

; 1710 :     }
; 1711 : 
; 1712 :     if (paudec->m_pbSrcCurr != NULL)

  0008e	8b 55 fc	 mov	 edx, DWORD PTR _paudec$[ebp]
  00091	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  00095	74 2a		 je	 SHORT $L3477

; 1713 :     {
; 1714 :         *ppBuffer  = paudec->m_pbSrcCurr;

  00097	8b 45 08	 mov	 eax, DWORD PTR _ppBuffer$[ebp]
  0009a	8b 4d fc	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0009d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000a0	89 10		 mov	 DWORD PTR [eax], edx

; 1715 :         *pcbBuffer = paudec->m_cbSrcCurrLength;

  000a2	8b 45 fc	 mov	 eax, DWORD PTR _paudec$[ebp]
  000a5	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  000a9	8b 55 0c	 mov	 edx, DWORD PTR _pcbBuffer$[ebp]
  000ac	89 0a		 mov	 DWORD PTR [edx], ecx

; 1716 :         //make sure nothing is left
; 1717 :         paudec->m_pbSrcCurr = NULL;

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _paudec$[ebp]
  000b1	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 1718 :         paudec->m_cbSrcCurrLength = 0;

  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _paudec$[ebp]
  000bb	66 c7 41 10 00
	00		 mov	 WORD PTR [ecx+16], 0
$L3477:

; 1719 :     }
; 1720 :     return WMA_S_NEWPACKET;

  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_S_NEWPACKET
$L3463:

; 1721 : }

  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 10 00	 ret	 16			; 00000010H
_prvWMAGetMoreData_XDS@16 ENDP
WMADEC	ENDS
END
