; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\wmadec_api.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
WMADEC_RW	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RW	ENDS
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT @ByteSwap@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMADEChIsValid@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMADEChNew@0
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMADEChDelete@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMADECCreate@32
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMADECDestroy@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMADECDecode@32
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMADECFlush@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMADECOutputBufferSize@20
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, WMADEC_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_DSoundBuildNumberD
WMADEC_RD	SEGMENT
_WMA_OK	DD	00H
_WMA_S_FALSE DD	01H
_WMA_S_BUFUNDERFLOW DD 02H
_WMA_S_NEWPACKET DD 03H
_WMA_S_NO_MORE_FRAME DD 04H
_WMA_S_DEFAULT DD 05H
_WMA_S_SWITCHCHMODE DD 06H
_WMA_E_FAIL DD	080004005H
_WMA_E_OUTOFMEMORY DD 08007000eH
_WMA_E_INVALIDARG DD 080070057H
_WMA_E_NOTSUPPORTED DD 080040000H
_WMA_E_LOSTPACKET DD 080040001H
_WMA_E_BROKEN_FRAME DD 080040002H
_WMA_E_BUFFEROVERFLOW DD 080040003H
_WMA_E_ONHOLD DD 080040004H
_WMA_E_BUFFERUNDERFLOW DD 080040005H
_WMA_E_INVALIDRECHDR DD 080040006H
_WMA_E_SYNCERROR DD 080040007H
_WMA_E_NOTIMPL DD 080040008H
_WMA_E_FLUSHOVERFLOW DD 080040009H
WMADEC_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT
_DSoundBuildNumberD DW 05344H
	DW	0554fH
	DW	0444eH
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_WMADEChIsValid@4
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wmadec_api.c
;	COMDAT _WMADEChIsValid@4
WMADEC	SEGMENT
tv68 = -4
_pHandle$ = 8
_WMADEChIsValid@4 PROC NEAR				; COMDAT

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 48   :     return pHandle != NULL &&
; 49   :            pHandle->magic == WMADECHANDLE_MAGIC &&
; 50   :            pHandle->pDecoder != NULL;

  00004	83 7d 08 00	 cmp	 DWORD PTR _pHandle$[ebp], 0
  00008	74 1d		 je	 SHORT $L3083
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pHandle$[ebp]
  0000d	81 38 8e 8a fb
	dc		 cmp	 DWORD PTR [eax], -587494770 ; dcfb8a8eH
  00013	75 12		 jne	 SHORT $L3083
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _pHandle$[ebp]
  00018	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0001c	74 09		 je	 SHORT $L3083
  0001e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00025	eb 07		 jmp	 SHORT $L3084
$L3083:
  00027	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$L3084:
  0002e	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]

; 51   : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
_WMADEChIsValid@4 ENDP
WMADEC	ENDS
PUBLIC	_WMADEChNew@0
EXTRN	_malloc:NEAR
; Function compile flags: /Odt
;	COMDAT _WMADEChNew@0
WMADEC	SEGMENT
_pHandle$ = -4
_WMADEChNew@0 PROC NEAR					; COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 56   :     CWMADECHANDLE *pHandle = (CWMADECHANDLE *)malloc(sizeof(CWMADECHANDLE));

  00004	6a 0c		 push	 12			; 0000000cH
  00006	e8 00 00 00 00	 call	 _malloc
  0000b	83 c4 04	 add	 esp, 4
  0000e	89 45 fc	 mov	 DWORD PTR _pHandle$[ebp], eax

; 57   :     if(pHandle == NULL)

  00011	83 7d fc 00	 cmp	 DWORD PTR _pHandle$[ebp], 0
  00015	75 04		 jne	 SHORT $L2943

; 58   :         return NULL;

  00017	33 c0		 xor	 eax, eax
  00019	eb 20		 jmp	 SHORT $L2938
$L2943:

; 59   : 
; 60   :     pHandle->magic        = WMADECHANDLE_MAGIC;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _pHandle$[ebp]
  0001e	c7 00 8e 8a fb
	dc		 mov	 DWORD PTR [eax], -587494770 ; dcfb8a8eH

; 61   :     pHandle->nFrameLength = 0;

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _pHandle$[ebp]
  00027	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 62   :     pHandle->pDecoder     = NULL;

  0002e	8b 55 fc	 mov	 edx, DWORD PTR _pHandle$[ebp]
  00031	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 63   : 
; 64   :     return pHandle;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _pHandle$[ebp]
$L2938:

; 65   : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
_WMADEChNew@0 ENDP
WMADEC	ENDS
PUBLIC	_WMADEChDelete@4
EXTRN	_free:NEAR
EXTRN	_audecDelete_XDS@4:NEAR
; Function compile flags: /Odt
;	COMDAT _WMADEChDelete@4
WMADEC	SEGMENT
_pHandle$ = 8
_WMADEChDelete@4 PROC NEAR				; COMDAT

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 70   :     if(pHandle)

  00003	83 7d 08 00	 cmp	 DWORD PTR _pHandle$[ebp], 0
  00007	74 2b		 je	 SHORT $L2949

; 71   :     {
; 72   :         if(pHandle->pDecoder)

  00009	8b 45 08	 mov	 eax, DWORD PTR _pHandle$[ebp]
  0000c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00010	74 16		 je	 SHORT $L2951

; 73   :         {
; 74   :             audecDelete(pHandle->pDecoder);

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _pHandle$[ebp]
  00015	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 _audecDelete_XDS@4

; 75   :             pHandle->pDecoder = NULL;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pHandle$[ebp]
  00021	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$L2951:

; 76   :         }
; 77   :         free(pHandle);

  00028	8b 4d 08	 mov	 ecx, DWORD PTR _pHandle$[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 _free
  00031	83 c4 04	 add	 esp, 4
$L2949:

; 78   :     }
; 79   : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
_WMADEChDelete@4 ENDP
WMADEC	ENDS
PUBLIC	_WMADECCreate@32
EXTRN	_audecNew_XDS@8:NEAR
EXTRN	_audecInit_XDS@48:NEAR
; Function compile flags: /Odt
;	COMDAT _WMADECCreate@32
WMADEC	SEGMENT
_pHandle$ = -8
_hr$ = -4
_nVersion$ = 8
_nSamplesPerSec$ = 12
_nChannels$ = 16
_nBytesPerSec$ = 20
_nSamplesPerBlock$ = 24
_nFrameLength$ = 28
_nEncodeOpt$ = 32
_nPlayerOpt$ = 36
_WMADECCreate@32 PROC NEAR				; COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 108  :     WMARESULT hr;
; 109  :     CWMADECHANDLE *pHandle = NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pHandle$[ebp], 0

; 110  : 
; 111  :     // create the handle
; 112  :     pHandle = WMADEChNew();

  0000d	e8 00 00 00 00	 call	 _WMADEChNew@0
  00012	89 45 f8	 mov	 DWORD PTR _pHandle$[ebp], eax

; 113  :     if(pHandle == NULL)

  00015	83 7d f8 00	 cmp	 DWORD PTR _pHandle$[ebp], 0
  00019	75 02		 jne	 SHORT $L2974

; 114  :         goto lerror;

  0001b	eb 68		 jmp	 SHORT $lerror$2975
$L2974:

; 115  : 
; 116  :     // create the object
; 117  :     pHandle->pDecoder = audecNew(NULL, 0);

  0001d	6a 00		 push	 0
  0001f	6a 00		 push	 0
  00021	e8 00 00 00 00	 call	 _audecNew_XDS@8
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _pHandle$[ebp]
  00029	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 118  :     if(pHandle->pDecoder == NULL)

  0002c	8b 55 f8	 mov	 edx, DWORD PTR _pHandle$[ebp]
  0002f	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00033	75 02		 jne	 SHORT $L2978

; 119  :         goto lerror;

  00035	eb 4e		 jmp	 SHORT $lerror$2975
$L2978:

; 120  : 
; 121  :     // store this for later
; 122  :     pHandle->nFrameLength = nFrameLength;

  00037	8b 45 f8	 mov	 eax, DWORD PTR _pHandle$[ebp]
  0003a	8b 4d 1c	 mov	 ecx, DWORD PTR _nFrameLength$[ebp]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 123  : 
; 124  :     // initialize the object
; 125  :     hr = audecInit(pHandle->pDecoder,
; 126  :                    nVersion,
; 127  :                    nSamplesPerBlock,
; 128  :                    nSamplesPerSec,
; 129  :                    (U16)nChannels,
; 130  :                    nBytesPerSec,
; 131  :                    nFrameLength,
; 132  :                    (U16)nEncodeOpt, 
; 133  :                    (U16)nPlayerOpt,
; 134  :                    NULL, (U32)0, NULL);

  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	66 8b 55 24	 mov	 dx, WORD PTR _nPlayerOpt$[ebp]
  0004a	52		 push	 edx
  0004b	66 8b 45 20	 mov	 ax, WORD PTR _nEncodeOpt$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d 1c	 mov	 ecx, DWORD PTR _nFrameLength$[ebp]
  00053	51		 push	 ecx
  00054	8b 55 14	 mov	 edx, DWORD PTR _nBytesPerSec$[ebp]
  00057	52		 push	 edx
  00058	66 8b 45 10	 mov	 ax, WORD PTR _nChannels$[ebp]
  0005c	50		 push	 eax
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  00060	51		 push	 ecx
  00061	8b 55 18	 mov	 edx, DWORD PTR _nSamplesPerBlock$[ebp]
  00064	52		 push	 edx
  00065	8b 45 08	 mov	 eax, DWORD PTR _nVersion$[ebp]
  00068	50		 push	 eax
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _pHandle$[ebp]
  0006c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _audecInit_XDS@48
  00075	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 135  :     if(hr != WMADECERR_NOERROR)

  00078	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0007c	74 02		 je	 SHORT $L2985

; 136  :         goto lerror;

  0007e	eb 05		 jmp	 SHORT $lerror$2975
$L2985:

; 137  : 
; 138  : 
; 139  :     return (WMADECHANDLE)pHandle;

  00080	8b 45 f8	 mov	 eax, DWORD PTR _pHandle$[ebp]
  00083	eb 11		 jmp	 SHORT $L2969
$lerror$2975:

; 140  : 
; 141  : lerror:
; 142  :     if(pHandle)

  00085	83 7d f8 00	 cmp	 DWORD PTR _pHandle$[ebp], 0
  00089	74 09		 je	 SHORT $L2987

; 143  :         WMADEChDelete(pHandle);

  0008b	8b 45 f8	 mov	 eax, DWORD PTR _pHandle$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _WMADEChDelete@4
$L2987:

; 144  :     return NULL;

  00094	33 c0		 xor	 eax, eax
$L2969:

; 145  : }

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 20 00	 ret	 32			; 00000020H
_WMADECCreate@32 ENDP
WMADEC	ENDS
PUBLIC	_WMADECDestroy@4
; Function compile flags: /Odt
;	COMDAT _WMADECDestroy@4
WMADEC	SEGMENT
_pHandle$ = -4
_hDecoder$ = 8
_WMADECDestroy@4 PROC NEAR				; COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 156  :     CWMADECHANDLE *pHandle = (CWMADECHANDLE *)hDecoder;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hDecoder$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pHandle$[ebp], eax

; 157  : 
; 158  :     // check for a valid handle
; 159  :     if(!WMADEChIsValid(pHandle))

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _pHandle$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _WMADEChIsValid@4
  00013	85 c0		 test	 eax, eax
  00015	75 07		 jne	 SHORT $L2994

; 160  :         return WMADECERR_INVALIDHANDLE;

  00017	b8 03 00 00 00	 mov	 eax, 3
  0001c	eb 21		 jmp	 SHORT $L2991
$L2994:

; 161  : 
; 162  :     // destroy the object and the handle
; 163  :     audecDelete(pHandle->pDecoder);

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _pHandle$[ebp]
  00021	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _audecDelete_XDS@4

; 164  :     pHandle->pDecoder = NULL;

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _pHandle$[ebp]
  0002d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 165  :     WMADEChDelete(pHandle);

  00034	8b 55 fc	 mov	 edx, DWORD PTR _pHandle$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 _WMADEChDelete@4

; 166  : 
; 167  :     return WMADECERR_NOERROR;

  0003d	33 c0		 xor	 eax, eax
$L2991:

; 168  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
_WMADECDestroy@4 ENDP
WMADEC	ENDS
PUBLIC	_WMADECDecode@32
EXTRN	_audecDecode_XDS@44:NEAR
; Function compile flags: /Odt
;	COMDAT _WMADECDecode@32
WMADEC	SEGMENT
_pHandle$ = -16
_hr$ = -12
_nSrcUsed$ = -8
_nDstUsed$ = -4
_hDecoder$ = 8
_pSrc$ = 12
_nSrcLen$ = 16
_pnSrcUsed$ = 20
_pDst$ = 24
_nDstLen$ = 28
_pnDstUsed$ = 32
_pnSamplesFromBefore$ = 36
_WMADECDecode@32 PROC NEAR				; COMDAT

; 195  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 196  :     WMARESULT hr;
; 197  :     //NQF+
; 198  :     //long nSrcUsed, nDstUsed;
; 199  :     Int nSrcUsed, nDstUsed;    
; 200  :     //NQF-
; 201  :     CWMADECHANDLE *pHandle = (CWMADECHANDLE *)hDecoder;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hDecoder$[ebp]
  00009	89 45 f0	 mov	 DWORD PTR _pHandle$[ebp], eax

; 202  : 
; 203  :     // check for a valid handle
; 204  :     if(!WMADEChIsValid(pHandle))

  0000c	8b 4d f0	 mov	 ecx, DWORD PTR _pHandle$[ebp]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _WMADEChIsValid@4
  00015	85 c0		 test	 eax, eax
  00017	75 07		 jne	 SHORT $L3018

; 205  :         return WMADECERR_INVALIDHANDLE;

  00019	b8 03 00 00 00	 mov	 eax, 3
  0001e	eb 7c		 jmp	 SHORT $L3012
$L3018:

; 206  : 
; 207  :     // check for the memory pointers
; 208  :     if(pSrc == NULL || pDst == NULL)

  00020	83 7d 0c 00	 cmp	 DWORD PTR _pSrc$[ebp], 0
  00024	74 06		 je	 SHORT $L3022
  00026	83 7d 18 00	 cmp	 DWORD PTR _pDst$[ebp], 0
  0002a	75 07		 jne	 SHORT $L3021
$L3022:

; 209  :         return WMADECERR_INVALIDPOINTER;

  0002c	b8 04 00 00 00	 mov	 eax, 4
  00031	eb 69		 jmp	 SHORT $L3012
$L3021:

; 210  : 
; 211  :     // decode
; 212  :     hr = audecDecode(pHandle->pDecoder,
; 213  :                      pSrc, nSrcLen, &nSrcUsed,
; 214  :                      pDst, nDstLen, &nDstUsed,
; 215  :                      NULL, 0, NULL, (long *)pnSamplesFromBefore);

  00033	8b 55 24	 mov	 edx, DWORD PTR _pnSamplesFromBefore$[ebp]
  00036	52		 push	 edx
  00037	6a 00		 push	 0
  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	8d 45 fc	 lea	 eax, DWORD PTR _nDstUsed$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 1c	 mov	 ecx, DWORD PTR _nDstLen$[ebp]
  00044	51		 push	 ecx
  00045	8b 55 18	 mov	 edx, DWORD PTR _pDst$[ebp]
  00048	52		 push	 edx
  00049	8d 45 f8	 lea	 eax, DWORD PTR _nSrcUsed$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d 10	 mov	 ecx, DWORD PTR _nSrcLen$[ebp]
  00050	51		 push	 ecx
  00051	8b 55 0c	 mov	 edx, DWORD PTR _pSrc$[ebp]
  00054	52		 push	 edx
  00055	8b 45 f0	 mov	 eax, DWORD PTR _pHandle$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _audecDecode_XDS@44
  00061	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 216  : 	if (hr == 4)

  00064	83 7d f4 04	 cmp	 DWORD PTR _hr$[ebp], 4
  00068	75 07		 jne	 SHORT $L3026

; 217  : 		hr = WMADECERR_NOERROR; 

  0006a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0
$L3026:

; 218  : 	if(hr != WMADECERR_NOERROR)

  00071	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00075	74 07		 je	 SHORT $L3027

; 219  :         return WMADECERR_FAIL;

  00077	b8 01 00 00 00	 mov	 eax, 1
  0007c	eb 1e		 jmp	 SHORT $L3012
$L3027:

; 220  : 
; 221  :     // update the out arguments
; 222  :     if(pnSrcUsed)

  0007e	83 7d 14 00	 cmp	 DWORD PTR _pnSrcUsed$[ebp], 0
  00082	74 08		 je	 SHORT $L3028

; 223  :         *pnSrcUsed = nSrcUsed;

  00084	8b 55 14	 mov	 edx, DWORD PTR _pnSrcUsed$[ebp]
  00087	8b 45 f8	 mov	 eax, DWORD PTR _nSrcUsed$[ebp]
  0008a	89 02		 mov	 DWORD PTR [edx], eax
$L3028:

; 224  :     if(pnDstUsed)

  0008c	83 7d 20 00	 cmp	 DWORD PTR _pnDstUsed$[ebp], 0
  00090	74 08		 je	 SHORT $L3029

; 225  :         *pnDstUsed = nDstUsed;

  00092	8b 4d 20	 mov	 ecx, DWORD PTR _pnDstUsed$[ebp]
  00095	8b 55 fc	 mov	 edx, DWORD PTR _nDstUsed$[ebp]
  00098	89 11		 mov	 DWORD PTR [ecx], edx
$L3029:

; 226  : 
; 227  :     return WMADECERR_NOERROR;

  0009a	33 c0		 xor	 eax, eax
$L3012:

; 228  : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 20 00	 ret	 32			; 00000020H
_WMADECDecode@32 ENDP
WMADEC	ENDS
PUBLIC	_WMADECFlush@16
EXTRN	_audecFlush_XDS@32:NEAR
; Function compile flags: /Odt
;	COMDAT _WMADECFlush@16
WMADEC	SEGMENT
_pHandle$ = -12
_hr$ = -8
_nDstUsed$ = -4
_hDecoder$ = 8
_pDst$ = 12
_nDstLen$ = 16
_pnDstUsed$ = 20
_WMADECFlush@16 PROC NEAR				; COMDAT

; 246  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 247  :     WMARESULT hr;
; 248  :     //NQF+
; 249  :     //long nDstUsed;
; 250  :     Int nDstUsed;
; 251  :     //NQF-
; 252  :     
; 253  :     CWMADECHANDLE *pHandle = (CWMADECHANDLE *)hDecoder;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hDecoder$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR _pHandle$[ebp], eax

; 254  : 
; 255  :     // check for a valid handle
; 256  :     if(!WMADEChIsValid(pHandle))

  0000c	8b 4d f4	 mov	 ecx, DWORD PTR _pHandle$[ebp]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _WMADEChIsValid@4
  00015	85 c0		 test	 eax, eax
  00017	75 07		 jne	 SHORT $L3043

; 257  :         return WMADECERR_INVALIDHANDLE;

  00019	b8 03 00 00 00	 mov	 eax, 3
  0001e	eb 4d		 jmp	 SHORT $L3038
$L3043:

; 258  : 
; 259  :     // check for the memory pointers
; 260  :     if(pDst == NULL)

  00020	83 7d 0c 00	 cmp	 DWORD PTR _pDst$[ebp], 0
  00024	75 07		 jne	 SHORT $L3045

; 261  :         return WMADECERR_INVALIDPOINTER;

  00026	b8 04 00 00 00	 mov	 eax, 4
  0002b	eb 40		 jmp	 SHORT $L3038
$L3045:

; 262  :     
; 263  :     // flush
; 264  :     hr = audecFlush(pHandle->pDecoder,
; 265  :                     pDst, nDstLen, &nDstUsed,
; 266  :                     NULL, 0, NULL, NULL);

  0002d	6a 00		 push	 0
  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8d 55 fc	 lea	 edx, DWORD PTR _nDstUsed$[ebp]
  00038	52		 push	 edx
  00039	8b 45 10	 mov	 eax, DWORD PTR _nDstLen$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _pDst$[ebp]
  00040	51		 push	 ecx
  00041	8b 55 f4	 mov	 edx, DWORD PTR _pHandle$[ebp]
  00044	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _audecFlush_XDS@32
  0004d	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 267  :     if(hr != WMADECERR_NOERROR)

  00050	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00054	74 07		 je	 SHORT $L3049

; 268  :         return WMADECERR_FAIL;

  00056	b8 01 00 00 00	 mov	 eax, 1
  0005b	eb 10		 jmp	 SHORT $L3038
$L3049:

; 269  : 
; 270  :     // update the out argument
; 271  :     if(pnDstUsed)

  0005d	83 7d 14 00	 cmp	 DWORD PTR _pnDstUsed$[ebp], 0
  00061	74 08		 je	 SHORT $L3050

; 272  :         *pnDstUsed = nDstUsed;

  00063	8b 4d 14	 mov	 ecx, DWORD PTR _pnDstUsed$[ebp]
  00066	8b 55 fc	 mov	 edx, DWORD PTR _nDstUsed$[ebp]
  00069	89 11		 mov	 DWORD PTR [ecx], edx
$L3050:

; 273  : 
; 274  :     return WMADECERR_NOERROR;

  0006b	33 c0		 xor	 eax, eax
$L3038:

; 275  : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 10 00	 ret	 16			; 00000010H
_WMADECFlush@16 ENDP
WMADEC	ENDS
PUBLIC	_WMADECOutputBufferSize@20
EXTRN	_audecOutputBufferSize_XDS@20:NEAR
; Function compile flags: /Odt
;	COMDAT _WMADECOutputBufferSize@20
WMADEC	SEGMENT
_nVersion$ = 8
_nSamplingRate$ = 12
_nChannels$ = 16
_nBytesPerSec$ = 20
_nEncodeOpt$ = 24
_WMADECOutputBufferSize@20 PROC NEAR			; COMDAT

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 295  :     return (unsigned long)audecOutputBufferSize( (Int)nVersion, (Int)nSamplingRate, (Int)nChannels, 
; 296  :                                                  (Int)nBytesPerSec, (U16)nEncodeOpt);

  00003	66 8b 45 18	 mov	 ax, WORD PTR _nEncodeOpt$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 14	 mov	 ecx, DWORD PTR _nBytesPerSec$[ebp]
  0000b	51		 push	 ecx
  0000c	8b 55 10	 mov	 edx, DWORD PTR _nChannels$[ebp]
  0000f	52		 push	 edx
  00010	8b 45 0c	 mov	 eax, DWORD PTR _nSamplingRate$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _nVersion$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _audecOutputBufferSize_XDS@20

; 297  : }

  0001d	5d		 pop	 ebp
  0001e	c2 14 00	 ret	 20			; 00000014H
_WMADECOutputBufferSize@20 ENDP
WMADEC	ENDS
END
