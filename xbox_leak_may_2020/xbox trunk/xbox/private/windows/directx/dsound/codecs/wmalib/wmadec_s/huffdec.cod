; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\huffdec.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_0EI@NJPDMLPP@c?3?2xbox?2private?2windows?2directx?2@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
WMADEC_RW	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RW	ENDS
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT @ByteSwap@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _huffDecGet@20
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, WMADEC_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_DSoundBuildNumberD
WMADEC_RD	SEGMENT
_WMA_OK	DD	00H
_WMA_S_FALSE DD	01H
_WMA_S_BUFUNDERFLOW DD 02H
_WMA_S_NEWPACKET DD 03H
_WMA_S_NO_MORE_FRAME DD 04H
_WMA_S_DEFAULT DD 05H
_WMA_S_SWITCHCHMODE DD 06H
_WMA_E_FAIL DD	080004005H
_WMA_E_OUTOFMEMORY DD 08007000eH
_WMA_E_INVALIDARG DD 080070057H
_WMA_E_NOTSUPPORTED DD 080040000H
_WMA_E_LOSTPACKET DD 080040001H
_WMA_E_BROKEN_FRAME DD 080040002H
_WMA_E_BUFFEROVERFLOW DD 080040003H
_WMA_E_ONHOLD DD 080040004H
_WMA_E_BUFFERUNDERFLOW DD 080040005H
_WMA_E_INVALIDRECHDR DD 080040006H
_WMA_E_SYNCERROR DD 080040007H
_WMA_E_NOTIMPL DD 080040008H
_WMA_E_FLUSHOVERFLOW DD 080040009H
WMADEC_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT
_DSoundBuildNumberD DW 05344H
	DW	0554fH
	DW	0444eH
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_huffDecGet@20
PUBLIC	??_C@_0EI@NJPDMLPP@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@ ; `string'
EXTRN	_MyOutputDbgStr:NEAR
;	COMDAT ??_C@_0EI@NJPDMLPP@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\huffdec.c
WMADEC_RD	SEGMENT
??_C@_0EI@NJPDMLPP@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\wmalib\wmadec_s\huffdec.c'
	DB	00H						; `string'
WMADEC_RD	ENDS
;	COMDAT ??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
WMADEC_RD	SEGMENT
??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@ DB '%'
	DB	's(%d) : *** TRACE *** code = 0x%x!', 0aH, 00H ; `string'
; Function compile flags: /Odt
WMADEC_RD	ENDS
;	COMDAT _huffDecGet@20
WMADEC	SEGMENT
tv80 = -36
_SECOND_LOAD$ = -32
_node_base$ = -28
_uBits$ = -24
_FIRST_LOAD$ = -20
_wmaResult$ = -16
_i$ = -12
_ret_value$ = -8
_codeword$ = -4
_pDecodeTable$ = 8
_bs$ = 12
_puBitCnt$ = 16
_puResult$ = 20
_puSign$ = 24
_huffDecGet@20 PROC NEAR				; COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 40   :      const int FIRST_LOAD = 10;

  00006	c7 45 ec 0a 00
	00 00		 mov	 DWORD PTR _FIRST_LOAD$[ebp], 10 ; 0000000aH

; 41   :      const int SECOND_LOAD = 12;

  0000d	c7 45 e0 0c 00
	00 00		 mov	 DWORD PTR _SECOND_LOAD$[ebp], 12 ; 0000000cH

; 42   : 
; 43   :      unsigned int ret_value;
; 44   :      const unsigned short* node_base = pDecodeTable;

  00014	8b 45 08	 mov	 eax, DWORD PTR _pDecodeTable$[ebp]
  00017	89 45 e4	 mov	 DWORD PTR _node_base$[ebp], eax

; 45   : 
; 46   :      U32 uBits;
; 47   :      U32 codeword;
; 48   :      int i;
; 49   : 
; 50   :      WMARESULT  wmaResult;
; 51   : #ifdef PROFILE
; 52   : 	 //profiling a function that gets called this often has too much overhead.
; 53   :      //FunctionProfile fp;
; 54   :      //FunctionProfileStart(&fp,HUFF_DEC_GET_PROFILE);
; 55   : #endif
; 56   : 
; 57   :      TRACEWMA_EXIT(wmaResult, (*(bs->ibstrmpfnPeekBits))(bs, FIRST_LOAD + SECOND_LOAD + 1, &uBits));

  0001a	8d 4d e8	 lea	 ecx, DWORD PTR _uBits$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 e0	 mov	 edx, DWORD PTR _SECOND_LOAD$[ebp]
  00021	8b 45 ec	 mov	 eax, DWORD PTR _FIRST_LOAD$[ebp]
  00024	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00028	51		 push	 ecx
  00029	8b 55 0c	 mov	 edx, DWORD PTR _bs$[ebp]
  0002c	52		 push	 edx
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _bs$[ebp]
  00030	ff 90 34 01 00
	00		 call	 DWORD PTR [eax+308]
  00036	89 45 f0	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00039	83 7d f0 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  0003d	7d 42		 jge	 SHORT $L1830
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00042	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  00048	74 2c		 je	 SHORT $L1857
  0004a	8b 55 f0	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0004d	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  00053	74 21		 je	 SHORT $L1857
  00055	8b 45 f0	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00058	50		 push	 eax
  00059	6a 39		 push	 57			; 00000039H
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@NJPDMLPP@c?3?2xbox?2private?2windows?2directx?2@
  00060	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00065	8b 4d f0	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0006e	83 c4 14	 add	 esp, 20			; 00000014H
  00071	89 45 dc	 mov	 DWORD PTR tv80[ebp], eax
  00074	eb 06		 jmp	 SHORT $L1858
$L1857:
  00076	8b 55 f0	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00079	89 55 dc	 mov	 DWORD PTR tv80[ebp], edx
$L1858:
  0007c	e9 5e 01 00 00	 jmp	 $exit$1829
$L1830:

; 58   :      codeword = uBits;

  00081	8b 45 e8	 mov	 eax, DWORD PTR _uBits$[ebp]
  00084	89 45 fc	 mov	 DWORD PTR _codeword$[ebp], eax

; 59   : 
; 60   :      // Do first five 2-bit tables
; 61   :      i = 5;

  00087	c7 45 f4 05 00
	00 00		 mov	 DWORD PTR _i$[ebp], 5
$L1831:

; 62   :      do
; 63   :      {
; 64   :          node_base += ((codeword & 0xC0000000) >> 30);  // Use top 2 bits as offset

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _codeword$[ebp]
  00091	81 e1 00 00 00
	c0		 and	 ecx, -1073741824	; c0000000H
  00097	c1 e9 1e	 shr	 ecx, 30			; 0000001eH
  0009a	8b 55 e4	 mov	 edx, DWORD PTR _node_base$[ebp]
  0009d	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000a0	89 45 e4	 mov	 DWORD PTR _node_base$[ebp], eax

; 65   :          ret_value = *node_base;

  000a3	8b 4d e4	 mov	 ecx, DWORD PTR _node_base$[ebp]
  000a6	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000a9	89 55 f8	 mov	 DWORD PTR _ret_value$[ebp], edx

; 66   :          if (ret_value & 0x8000)

  000ac	8b 45 f8	 mov	 eax, DWORD PTR _ret_value$[ebp]
  000af	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  000b4	85 c0		 test	 eax, eax
  000b6	74 05		 je	 SHORT $L1834

; 67   :              goto decode_complete;  // Found a leaf node!

  000b8	e9 d2 00 00 00	 jmp	 $decode_complete$1835
$L1834:

; 68   : 
; 69   :          node_base += ret_value;    // No leaf node, follow the offset

  000bd	8b 4d f8	 mov	 ecx, DWORD PTR _ret_value$[ebp]
  000c0	8b 55 e4	 mov	 edx, DWORD PTR _node_base$[ebp]
  000c3	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000c6	89 45 e4	 mov	 DWORD PTR _node_base$[ebp], eax

; 70   :          codeword <<= 2;            // Advance to next 2 bits

  000c9	8b 4d fc	 mov	 ecx, DWORD PTR _codeword$[ebp]
  000cc	c1 e1 02	 shl	 ecx, 2
  000cf	89 4d fc	 mov	 DWORD PTR _codeword$[ebp], ecx

; 71   :          i -= 1;

  000d2	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000d5	83 ea 01	 sub	 edx, 1
  000d8	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx

; 72   :      } while (i > 0);

  000db	83 7d f4 00	 cmp	 DWORD PTR _i$[ebp], 0
  000df	7f ad		 jg	 SHORT $L1831

; 73   : 
; 74   :      // Do remaining three 2-bit tables
; 75   :      i = 3;

  000e1	c7 45 f4 03 00
	00 00		 mov	 DWORD PTR _i$[ebp], 3
$L1836:

; 76   :      do
; 77   :      {
; 78   :          node_base += ((codeword & 0xC0000000) >> 30);  // Use top 2 bits as offset

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _codeword$[ebp]
  000eb	25 00 00 00 c0	 and	 eax, -1073741824	; c0000000H
  000f0	c1 e8 1e	 shr	 eax, 30			; 0000001eH
  000f3	8b 4d e4	 mov	 ecx, DWORD PTR _node_base$[ebp]
  000f6	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  000f9	89 55 e4	 mov	 DWORD PTR _node_base$[ebp], edx

; 79   :          ret_value = *node_base;

  000fc	8b 45 e4	 mov	 eax, DWORD PTR _node_base$[ebp]
  000ff	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00102	89 4d f8	 mov	 DWORD PTR _ret_value$[ebp], ecx

; 80   :          if (ret_value & 0x8000)

  00105	8b 55 f8	 mov	 edx, DWORD PTR _ret_value$[ebp]
  00108	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  0010e	85 d2		 test	 edx, edx
  00110	74 02		 je	 SHORT $L1839

; 81   :              goto decode_complete;  // Found a leaf node!

  00112	eb 7b		 jmp	 SHORT $decode_complete$1835
$L1839:

; 82   : 
; 83   :          node_base += ret_value;    // No leaf node, follow the offset

  00114	8b 45 f8	 mov	 eax, DWORD PTR _ret_value$[ebp]
  00117	8b 4d e4	 mov	 ecx, DWORD PTR _node_base$[ebp]
  0011a	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0011d	89 55 e4	 mov	 DWORD PTR _node_base$[ebp], edx

; 84   :          codeword <<= 2;            // Advance to next 2 bits

  00120	8b 45 fc	 mov	 eax, DWORD PTR _codeword$[ebp]
  00123	c1 e0 02	 shl	 eax, 2
  00126	89 45 fc	 mov	 DWORD PTR _codeword$[ebp], eax

; 85   :          i -= 1;

  00129	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0012c	83 e9 01	 sub	 ecx, 1
  0012f	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx

; 86   :      } while (i > 0);

  00132	83 7d f4 00	 cmp	 DWORD PTR _i$[ebp], 0
  00136	7f b0		 jg	 SHORT $L1836

; 87   : 
; 88   :      // Do six 1-bit tables
; 89   :      i = 6;

  00138	c7 45 f4 06 00
	00 00		 mov	 DWORD PTR _i$[ebp], 6
$L1840:

; 90   :      do
; 91   :      {
; 92   :          node_base += ((codeword & 0x80000000) >> 31);  // Use top bit as offset

  0013f	8b 55 fc	 mov	 edx, DWORD PTR _codeword$[ebp]
  00142	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00148	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  0014b	8b 45 e4	 mov	 eax, DWORD PTR _node_base$[ebp]
  0014e	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00151	89 4d e4	 mov	 DWORD PTR _node_base$[ebp], ecx

; 93   :          ret_value = *node_base;

  00154	8b 55 e4	 mov	 edx, DWORD PTR _node_base$[ebp]
  00157	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0015a	89 45 f8	 mov	 DWORD PTR _ret_value$[ebp], eax

; 94   :          if (ret_value & 0x8000)

  0015d	8b 4d f8	 mov	 ecx, DWORD PTR _ret_value$[ebp]
  00160	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  00166	85 c9		 test	 ecx, ecx
  00168	74 02		 je	 SHORT $L1843

; 95   :              goto decode_complete;  // Found a leaf node!

  0016a	eb 23		 jmp	 SHORT $decode_complete$1835
$L1843:

; 96   : 
; 97   :          node_base += ret_value;    // No leaf node, follow the offset

  0016c	8b 55 f8	 mov	 edx, DWORD PTR _ret_value$[ebp]
  0016f	8b 45 e4	 mov	 eax, DWORD PTR _node_base$[ebp]
  00172	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00175	89 4d e4	 mov	 DWORD PTR _node_base$[ebp], ecx

; 98   :          codeword <<= 1;            // Advance to next bit

  00178	8b 55 fc	 mov	 edx, DWORD PTR _codeword$[ebp]
  0017b	d1 e2		 shl	 edx, 1
  0017d	89 55 fc	 mov	 DWORD PTR _codeword$[ebp], edx

; 99   :          i -= 1;

  00180	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00183	83 e8 01	 sub	 eax, 1
  00186	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax

; 100  :      } while (i > 0);

  00189	83 7d f4 00	 cmp	 DWORD PTR _i$[ebp], 0
  0018d	7f b0		 jg	 SHORT $L1840
$decode_complete$1835:

; 101  : 
; 102  : 
; 103  : decode_complete:
; 104  :      assert(ret_value & 0x8000);
; 105  :      *puBitCnt = ((ret_value >> 10) & (0x0000001F));

  0018f	8b 4d f8	 mov	 ecx, DWORD PTR _ret_value$[ebp]
  00192	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  00195	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00198	8b 55 10	 mov	 edx, DWORD PTR _puBitCnt$[ebp]
  0019b	89 0a		 mov	 DWORD PTR [edx], ecx

; 106  :      *puResult = ret_value & 0x000003FF;

  0019d	8b 45 f8	 mov	 eax, DWORD PTR _ret_value$[ebp]
  001a0	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  001a5	8b 4d 14	 mov	 ecx, DWORD PTR _puResult$[ebp]
  001a8	89 01		 mov	 DWORD PTR [ecx], eax

; 107  :      if (*puResult >= 0x03FC)

  001aa	8b 55 14	 mov	 edx, DWORD PTR _puResult$[ebp]
  001ad	81 3a fc 03 00
	00		 cmp	 DWORD PTR [edx], 1020	; 000003fcH
  001b3	72 15		 jb	 SHORT $L1844

; 108  :          *puResult = *(node_base + (*puResult & 0x0003) + 1);

  001b5	8b 45 14	 mov	 eax, DWORD PTR _puResult$[ebp]
  001b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ba	83 e1 03	 and	 ecx, 3
  001bd	8b 55 e4	 mov	 edx, DWORD PTR _node_base$[ebp]
  001c0	0f b7 44 4a 02	 movzx	 eax, WORD PTR [edx+ecx*2+2]
  001c5	8b 4d 14	 mov	 ecx, DWORD PTR _puResult$[ebp]
  001c8	89 01		 mov	 DWORD PTR [ecx], eax
$L1844:

; 109  :      
; 110  :      if (puSign != NULL)

  001ca	83 7d 18 00	 cmp	 DWORD PTR _puSign$[ebp], 0
  001ce	74 0f		 je	 SHORT $exit$1829

; 111  :         *puSign = uBits << *puBitCnt;

  001d0	8b 55 10	 mov	 edx, DWORD PTR _puBitCnt$[ebp]
  001d3	8b 45 e8	 mov	 eax, DWORD PTR _uBits$[ebp]
  001d6	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001d8	d3 e0		 shl	 eax, cl
  001da	8b 4d 18	 mov	 ecx, DWORD PTR _puSign$[ebp]
  001dd	89 01		 mov	 DWORD PTR [ecx], eax
$exit$1829:

; 112  : 
; 113  : exit:
; 114  : #ifdef PROFILE
; 115  :     //FunctionProfileStop(&fp);
; 116  : #endif
; 117  :      return wmaResult;

  001df	8b 45 f0	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 118  : }

  001e2	8b e5		 mov	 esp, ebp
  001e4	5d		 pop	 ebp
  001e5	c2 14 00	 ret	 20			; 00000014H
_huffDecGet@20 ENDP
WMADEC	ENDS
END
