; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\trackpth.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EB@IJCIMIKP@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@FGMPAOFK@kend?5?$DM?5PITCH_CAND?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@PMBEPNII@kend?$CL1?5?$DM?5PITCH_CAND?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxTrackPitch@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _LookForward@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _LookBackward@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_VoxTrackPitch@8
PUBLIC	__real@3f000000
PUBLIC	__real@3f7ae148
PUBLIC	__real@3f6e147b
EXTRN	__fltused:NEAR
EXTRN	_memcpy:NEAR
;	COMDAT __real@3f000000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\trackpth.c
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3f7ae148
CONST	SEGMENT
__real@3f7ae148 DD 03f7ae148r			; 0.98
CONST	ENDS
;	COMDAT __real@3f6e147b
CONST	SEGMENT
__real@3f6e147b DD 03f6e147br			; 0.93
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxTrackPitch@8
_TEXT	SEGMENT
_cost_b$ = -24
_cost_f$ = -20
_p0_f$ = -16
_p0_b$ = -12
_pitch$ = -8
_tooSmall_flag$ = -4
_costs1$ = 8
_myCorrPDA_mblk$ = 12
_VoxTrackPitch@8 PROC NEAR				; COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 56   :   float cost_f, cost_b;
; 57   :   short p0_f, p0_b;
; 58   :   short pitch;
; 59   :   short tooSmall_flag = 0;

  00006	66 c7 45 fc 00
	00		 mov	 WORD PTR _tooSmall_flag$[ebp], 0

; 60   : 
; 61   :   /*--------------------------------------------------
; 62   :     forward tracking :
; 63   :     --------------------------------------------------*/
; 64   :   LookForward(STACK_S costs1, myCorrPDA_mblk, &cost_f, &p0_f, &tooSmall_flag);

  0000c	8d 45 fc	 lea	 eax, DWORD PTR _tooSmall_flag$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f0	 lea	 ecx, DWORD PTR _p0_f$[ebp]
  00013	51		 push	 ecx
  00014	8d 55 ec	 lea	 edx, DWORD PTR _cost_f$[ebp]
  00017	52		 push	 edx
  00018	8b 45 0c	 mov	 eax, DWORD PTR _myCorrPDA_mblk$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _costs1$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _LookForward@20

; 65   : 
; 66   : 
; 67   :   /*-------------------------------------------------- 
; 68   :     backward tracking :
; 69   :     find the maximum costs while tracking.
; 70   :     --------------------------------------------------*/
; 71   :   LookBackward(myCorrPDA_mblk, &cost_b, &p0_b);

  00025	8d 55 f4	 lea	 edx, DWORD PTR _p0_b$[ebp]
  00028	52		 push	 edx
  00029	8d 45 e8	 lea	 eax, DWORD PTR _cost_b$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _myCorrPDA_mblk$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _LookBackward@12

; 72   : 
; 73   :   if (tooSmall_flag == 1) {

  00036	0f bf 55 fc	 movsx	 edx, WORD PTR _tooSmall_flag$[ebp]
  0003a	83 fa 01	 cmp	 edx, 1
  0003d	75 20		 jne	 SHORT $L1252

; 74   :     /* need check p0_b to see if pitch candidate is not reliable */
; 75   :     if (p0_b <= LPITCH_MIN_CONF && cost_b < 0.5F) {

  0003f	0f bf 45 f4	 movsx	 eax, WORD PTR _p0_b$[ebp]
  00043	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00046	7f 17		 jg	 SHORT $L1252
  00048	d9 45 e8	 fld	 DWORD PTR _cost_b$[ebp]
  0004b	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f000000
  00051	df e0		 fnstsw	 ax
  00053	f6 c4 05	 test	 ah, 5
  00056	7a 07		 jp	 SHORT $L1252

; 76   :       cost_b = INIT_COST;

  00058	c7 45 e8 00 00
	80 bf		 mov	 DWORD PTR _cost_b$[ebp], -1082130432 ; bf800000H
$L1252:

; 77   :     }
; 78   :   }
; 79   : 
; 80   :   /*-----------------------------------------------------------------
; 81   :     make the decision to choose from backward pitch or forward pitch.
; 82   :     -----------------------------------------------------------------*/
; 83   :   if (((p0_b>p0_f)&&(cost_f<=BIAS_FORWARD*cost_b))
; 84   :       ||((p0_b <= p0_f) && ( (cost_b >= (BIAS_BACKWARD * cost_f)))))

  0005f	0f bf 4d f4	 movsx	 ecx, WORD PTR _p0_b$[ebp]
  00063	0f bf 55 f0	 movsx	 edx, WORD PTR _p0_f$[ebp]
  00067	3b ca		 cmp	 ecx, edx
  00069	7e 13		 jle	 SHORT $L1256
  0006b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f7ae148
  00071	d8 4d e8	 fmul	 DWORD PTR _cost_b$[ebp]
  00074	d8 5d ec	 fcomp	 DWORD PTR _cost_f$[ebp]
  00077	df e0		 fnstsw	 ax
  00079	f6 c4 01	 test	 ah, 1
  0007c	74 1f		 je	 SHORT $L1255
$L1256:
  0007e	0f bf 45 f4	 movsx	 eax, WORD PTR _p0_b$[ebp]
  00082	0f bf 4d f0	 movsx	 ecx, WORD PTR _p0_f$[ebp]
  00086	3b c1		 cmp	 eax, ecx
  00088	7f 1d		 jg	 SHORT $L1254
  0008a	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f6e147b
  00090	d8 4d ec	 fmul	 DWORD PTR _cost_f$[ebp]
  00093	d8 5d e8	 fcomp	 DWORD PTR _cost_b$[ebp]
  00096	df e0		 fnstsw	 ax
  00098	f6 c4 41	 test	 ah, 65			; 00000041H
  0009b	7a 0a		 jp	 SHORT $L1254
$L1255:

; 85   :     pitch = p0_b;

  0009d	66 8b 55 f4	 mov	 dx, WORD PTR _p0_b$[ebp]
  000a1	66 89 55 f8	 mov	 WORD PTR _pitch$[ebp], dx

; 86   :   else 

  000a5	eb 08		 jmp	 SHORT $L1257
$L1254:

; 87   :     pitch = p0_f;

  000a7	66 8b 45 f0	 mov	 ax, WORD PTR _p0_f$[ebp]
  000ab	66 89 45 f8	 mov	 WORD PTR _pitch$[ebp], ax
$L1257:

; 88   : 
; 89   : 
; 90   :   /*------------------------------------------------------------
; 91   :     Save the tracking information.
; 92   :     ------------------------------------------------------------*/
; 93   :   myCorrPDA_mblk->pitch_2 = myCorrPDA_mblk->pitch_1;

  000af	8b 4d 0c	 mov	 ecx, DWORD PTR _myCorrPDA_mblk$[ebp]
  000b2	8b 55 0c	 mov	 edx, DWORD PTR _myCorrPDA_mblk$[ebp]
  000b5	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000b8	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 94   :   myCorrPDA_mblk->pitch_1 = pitch;

  000bb	0f bf 4d f8	 movsx	 ecx, WORD PTR _pitch$[ebp]
  000bf	8b 55 0c	 mov	 edx, DWORD PTR _myCorrPDA_mblk$[ebp]
  000c2	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 95   : 
; 96   :   myCorrPDA_mblk->cost_2 = myCorrPDA_mblk->cost_1;

  000c5	8b 45 0c	 mov	 eax, DWORD PTR _myCorrPDA_mblk$[ebp]
  000c8	8b 4d 0c	 mov	 ecx, DWORD PTR _myCorrPDA_mblk$[ebp]
  000cb	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000ce	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 97   :   myCorrPDA_mblk->cost_1 = myCorrPDA_mblk->costs0[pitch-LPITCH_MIN];

  000d1	0f bf 45 f8	 movsx	 eax, WORD PTR _pitch$[ebp]
  000d5	8b 4d 0c	 mov	 ecx, DWORD PTR _myCorrPDA_mblk$[ebp]
  000d8	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000db	8b 4d 0c	 mov	 ecx, DWORD PTR _myCorrPDA_mblk$[ebp]
  000de	8b 54 82 ec	 mov	 edx, DWORD PTR [edx+eax*4-20]
  000e2	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 98   : 
; 99   :   memcpy(myCorrPDA_mblk->costs0, costs1, PITCH_CAND*sizeof(float));

  000e5	68 58 01 00 00	 push	 344			; 00000158H
  000ea	8b 45 08	 mov	 eax, DWORD PTR _costs1$[ebp]
  000ed	50		 push	 eax
  000ee	8b 4d 0c	 mov	 ecx, DWORD PTR _myCorrPDA_mblk$[ebp]
  000f1	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 _memcpy
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 100  : 
; 101  : 
; 102  :   return pitch;

  000fd	66 8b 45 f8	 mov	 ax, WORD PTR _pitch$[ebp]

; 103  : }

  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 08 00	 ret	 8
_VoxTrackPitch@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EB@IJCIMIKP@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BC@FGMPAOFK@kend?5?$DM?5PITCH_CAND?$AA@	; `string'
PUBLIC	??_C@_0BE@PMBEPNII@kend?$CL1?5?$DM?5PITCH_CAND?$AA@ ; `string'
EXTRN	__assert:NEAR
EXTRN	_FindMaxValueFlt@16:NEAR
;	COMDAT ??_C@_0EB@IJCIMIKP@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0EB@IJCIMIKP@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\trackpth.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FGMPAOFK@kend?5?$DM?5PITCH_CAND?$AA@
CONST	SEGMENT
??_C@_0BC@FGMPAOFK@kend?5?$DM?5PITCH_CAND?$AA@ DB 'kend < PITCH_CAND', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PMBEPNII@kend?$CL1?5?$DM?5PITCH_CAND?$AA@
CONST	SEGMENT
??_C@_0BE@PMBEPNII@kend?$CL1?5?$DM?5PITCH_CAND?$AA@ DB 'kend+1 < PITCH_CA'
	DB	'ND', 00H					; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _LookForward@20
_TEXT	SEGMENT
_k$1282 = -1100
_kend$1284 = -1096
_tmpmaxlag1$1286 = -1092
_tmpmaxcost1$1285 = -1088
_length$1283 = -1084
_pforward_costs$ = -1080
_forcosts$ = -44
_dLagStart$ = -40
_tmpmaxcost$ = -36
_cost_f$ = -32
_tmpmaxlag$ = -28
_dLagLength$ = -24
_p0_f$ = -20
_tmpcost3$ = -16
_jlag$ = -12
_pcost0$ = -8
_tmpcost2$ = -4
_pcost1$ = 8
_myCorrPDA_mblk$ = 12
_pcost_f$ = 16
_pp0_f$ = 20
_tooSmall_flag$ = 24
_LookForward@20 PROC NEAR				; COMDAT

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 04 00
	00		 sub	 esp, 1100		; 0000044cH

; 115  :   STACK_INIT
; 116  :   float pforward_costs[3*PITCH_CAND];
; 117  :   STACK_INIT_END
; 118  :   STACK_ATTACH(float*,pforward_costs)
; 119  :   float *pcost0 = myCorrPDA_mblk->costs0;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _myCorrPDA_mblk$[ebp]
  0000c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000f	89 4d f8	 mov	 DWORD PTR _pcost0$[ebp], ecx

; 120  :   int *dLagStart = myCorrPDA_mblk->dInterLagStart;

  00012	8b 55 0c	 mov	 edx, DWORD PTR _myCorrPDA_mblk$[ebp]
  00015	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00018	89 45 d8	 mov	 DWORD PTR _dLagStart$[ebp], eax

; 121  :   int *dLagLength = myCorrPDA_mblk->dInterLagLength;

  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _myCorrPDA_mblk$[ebp]
  0001e	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00021	89 55 e8	 mov	 DWORD PTR _dLagLength$[ebp], edx

; 122  :   float cost_f;
; 123  :   int p0_f;
; 124  :   int jlag;
; 125  :   float forcosts;
; 126  : 
; 127  :   float tmpmaxcost;
; 128  :   int tmpmaxlag = -1;

  00024	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _tmpmaxlag$[ebp], -1

; 129  :   float tmpcost2, tmpcost3;
; 130  : 
; 131  :   STACK_START
; 132  : 
; 133  :   /*--------------------------------------------------
; 134  :     calculate the forward cost function.
; 135  :     --------------------------------------------------*/
; 136  :   {
; 137  :     int k, length, kend=0;

  0002b	c7 85 b8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _kend$1284[ebp], 0

; 138  :     float tmpmaxcost1;
; 139  :     int tmpmaxlag1;
; 140  : 
; 141  :     cost_f = INIT_COST;

  00035	c7 45 e0 00 00
	80 bf		 mov	 DWORD PTR _cost_f$[ebp], -1082130432 ; bf800000H

; 142  :     for (jlag = 0; jlag < PITCH_CAND; jlag++) {

  0003c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _jlag$[ebp], 0
  00043	eb 09		 jmp	 SHORT $L1287
$L1288:
  00045	8b 45 f4	 mov	 eax, DWORD PTR _jlag$[ebp]
  00048	83 c0 01	 add	 eax, 1
  0004b	89 45 f4	 mov	 DWORD PTR _jlag$[ebp], eax
$L1287:
  0004e	83 7d f4 56	 cmp	 DWORD PTR _jlag$[ebp], 86 ; 00000056H
  00052	0f 8d 9d 01 00
	00		 jge	 $L1289

; 143  :       k = *dLagStart++;

  00058	8b 4d d8	 mov	 ecx, DWORD PTR _dLagStart$[ebp]
  0005b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005d	89 95 b4 fb ff
	ff		 mov	 DWORD PTR _k$1282[ebp], edx
  00063	8b 45 d8	 mov	 eax, DWORD PTR _dLagStart$[ebp]
  00066	83 c0 04	 add	 eax, 4
  00069	89 45 d8	 mov	 DWORD PTR _dLagStart$[ebp], eax

; 144  :       length = k+ *dLagLength-kend;

  0006c	8b 4d e8	 mov	 ecx, DWORD PTR _dLagLength$[ebp]
  0006f	8b 95 b4 fb ff
	ff		 mov	 edx, DWORD PTR _k$1282[ebp]
  00075	03 11		 add	 edx, DWORD PTR [ecx]
  00077	2b 95 b8 fb ff
	ff		 sub	 edx, DWORD PTR _kend$1284[ebp]
  0007d	89 95 c4 fb ff
	ff		 mov	 DWORD PTR _length$1283[ebp], edx

; 145  :       if(tmpmaxlag < k) {

  00083	8b 45 e4	 mov	 eax, DWORD PTR _tmpmaxlag$[ebp]
  00086	3b 85 b4 fb ff
	ff		 cmp	 eax, DWORD PTR _k$1282[ebp]
  0008c	7d 31		 jge	 SHORT $L1290

; 146  : 	FindMaxValueFlt(&(pcost1[k]), *dLagLength, &tmpmaxlag, &tmpmaxcost);

  0008e	8d 4d dc	 lea	 ecx, DWORD PTR _tmpmaxcost$[ebp]
  00091	51		 push	 ecx
  00092	8d 55 e4	 lea	 edx, DWORD PTR _tmpmaxlag$[ebp]
  00095	52		 push	 edx
  00096	8b 45 e8	 mov	 eax, DWORD PTR _dLagLength$[ebp]
  00099	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009b	51		 push	 ecx
  0009c	8b 95 b4 fb ff
	ff		 mov	 edx, DWORD PTR _k$1282[ebp]
  000a2	8b 45 08	 mov	 eax, DWORD PTR _pcost1$[ebp]
  000a5	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 _FindMaxValueFlt@16

; 147  : 	tmpmaxlag += k;

  000ae	8b 55 e4	 mov	 edx, DWORD PTR _tmpmaxlag$[ebp]
  000b1	03 95 b4 fb ff
	ff		 add	 edx, DWORD PTR _k$1282[ebp]
  000b7	89 55 e4	 mov	 DWORD PTR _tmpmaxlag$[ebp], edx

; 148  :       }
; 149  :       else if(length) {

  000ba	e9 d7 00 00 00	 jmp	 $L1291
$L1290:
  000bf	83 bd c4 fb ff
	ff 00		 cmp	 DWORD PTR _length$1283[ebp], 0
  000c6	0f 84 ca 00 00
	00		 je	 $L1291

; 150  : 	assert(kend < PITCH_CAND);

  000cc	83 bd b8 fb ff
	ff 56		 cmp	 DWORD PTR _kend$1284[ebp], 86 ; 00000056H
  000d3	7c 17		 jl	 SHORT $L1354
  000d5	68 96 00 00 00	 push	 150			; 00000096H
  000da	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@IJCIMIKP@c?3?2xbox?2private?2windows?2directx?2@
  000df	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@FGMPAOFK@kend?5?$DM?5PITCH_CAND?$AA@
  000e4	e8 00 00 00 00	 call	 __assert
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1354:

; 151  : 	tmpmaxcost1 = pcost1[kend];

  000ec	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR _kend$1284[ebp]
  000f2	8b 55 08	 mov	 edx, DWORD PTR _pcost1$[ebp]
  000f5	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  000f8	89 85 c0 fb ff
	ff		 mov	 DWORD PTR _tmpmaxcost1$1285[ebp], eax

; 152  : 	tmpmaxlag1 = kend;

  000fe	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR _kend$1284[ebp]
  00104	89 8d bc fb ff
	ff		 mov	 DWORD PTR _tmpmaxlag1$1286[ebp], ecx

; 153  : 	if(length == 2) {

  0010a	83 bd c4 fb ff
	ff 02		 cmp	 DWORD PTR _length$1283[ebp], 2
  00111	75 61		 jne	 SHORT $L1296

; 154  : 	  assert( kend+1 < PITCH_CAND);

  00113	8b 95 b8 fb ff
	ff		 mov	 edx, DWORD PTR _kend$1284[ebp]
  00119	83 c2 01	 add	 edx, 1
  0011c	83 fa 56	 cmp	 edx, 86			; 00000056H
  0011f	7c 17		 jl	 SHORT $L1355
  00121	68 9a 00 00 00	 push	 154			; 0000009aH
  00126	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@IJCIMIKP@c?3?2xbox?2private?2windows?2directx?2@
  0012b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@PMBEPNII@kend?$CL1?5?$DM?5PITCH_CAND?$AA@
  00130	e8 00 00 00 00	 call	 __assert
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1355:

; 155  : 	  if(tmpmaxcost1 < pcost1[kend+1]) {

  00138	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR _kend$1284[ebp]
  0013e	8b 55 08	 mov	 edx, DWORD PTR _pcost1$[ebp]
  00141	d9 85 c0 fb ff
	ff		 fld	 DWORD PTR _tmpmaxcost1$1285[ebp]
  00147	d8 5c 8a 04	 fcomp	 DWORD PTR [edx+ecx*4+4]
  0014b	df e0		 fnstsw	 ax
  0014d	f6 c4 05	 test	 ah, 5
  00150	7a 22		 jp	 SHORT $L1296

; 156  : 	    tmpmaxcost1 = pcost1[kend+1];

  00152	8b 85 b8 fb ff
	ff		 mov	 eax, DWORD PTR _kend$1284[ebp]
  00158	8b 4d 08	 mov	 ecx, DWORD PTR _pcost1$[ebp]
  0015b	8b 54 81 04	 mov	 edx, DWORD PTR [ecx+eax*4+4]
  0015f	89 95 c0 fb ff
	ff		 mov	 DWORD PTR _tmpmaxcost1$1285[ebp], edx

; 157  : 	    tmpmaxlag1 ++;

  00165	8b 85 bc fb ff
	ff		 mov	 eax, DWORD PTR _tmpmaxlag1$1286[ebp]
  0016b	83 c0 01	 add	 eax, 1
  0016e	89 85 bc fb ff
	ff		 mov	 DWORD PTR _tmpmaxlag1$1286[ebp], eax
$L1296:

; 158  : 	  }
; 159  : 	}
; 160  : 	if(tmpmaxcost1>tmpmaxcost) {

  00174	d9 85 c0 fb ff
	ff		 fld	 DWORD PTR _tmpmaxcost1$1285[ebp]
  0017a	d8 5d dc	 fcomp	 DWORD PTR _tmpmaxcost$[ebp]
  0017d	df e0		 fnstsw	 ax
  0017f	f6 c4 41	 test	 ah, 65			; 00000041H
  00182	75 12		 jne	 SHORT $L1291

; 161  : 	  tmpmaxlag = tmpmaxlag1;

  00184	8b 8d bc fb ff
	ff		 mov	 ecx, DWORD PTR _tmpmaxlag1$1286[ebp]
  0018a	89 4d e4	 mov	 DWORD PTR _tmpmaxlag$[ebp], ecx

; 162  : 	  tmpmaxcost = tmpmaxcost1;

  0018d	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _tmpmaxcost1$1285[ebp]
  00193	89 55 dc	 mov	 DWORD PTR _tmpmaxcost$[ebp], edx
$L1291:

; 163  : 	}
; 164  :       }
; 165  :       kend = k + *dLagLength++;

  00196	8b 45 e8	 mov	 eax, DWORD PTR _dLagLength$[ebp]
  00199	8b 8d b4 fb ff
	ff		 mov	 ecx, DWORD PTR _k$1282[ebp]
  0019f	03 08		 add	 ecx, DWORD PTR [eax]
  001a1	89 8d b8 fb ff
	ff		 mov	 DWORD PTR _kend$1284[ebp], ecx
  001a7	8b 55 e8	 mov	 edx, DWORD PTR _dLagLength$[ebp]
  001aa	83 c2 04	 add	 edx, 4
  001ad	89 55 e8	 mov	 DWORD PTR _dLagLength$[ebp], edx

; 166  :       forcosts = 0.5F * (tmpmaxcost + *pcost0++);

  001b0	8b 45 f8	 mov	 eax, DWORD PTR _pcost0$[ebp]
  001b3	d9 45 dc	 fld	 DWORD PTR _tmpmaxcost$[ebp]
  001b6	d8 00		 fadd	 DWORD PTR [eax]
  001b8	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  001be	d9 5d d4	 fstp	 DWORD PTR _forcosts$[ebp]
  001c1	8b 4d f8	 mov	 ecx, DWORD PTR _pcost0$[ebp]
  001c4	83 c1 04	 add	 ecx, 4
  001c7	89 4d f8	 mov	 DWORD PTR _pcost0$[ebp], ecx

; 167  :       if (forcosts > cost_f) {

  001ca	d9 45 d4	 fld	 DWORD PTR _forcosts$[ebp]
  001cd	d8 5d e0	 fcomp	 DWORD PTR _cost_f$[ebp]
  001d0	df e0		 fnstsw	 ax
  001d2	f6 c4 41	 test	 ah, 65			; 00000041H
  001d5	75 0c		 jne	 SHORT $L1301

; 168  : 	cost_f = forcosts;

  001d7	8b 55 d4	 mov	 edx, DWORD PTR _forcosts$[ebp]
  001da	89 55 e0	 mov	 DWORD PTR _cost_f$[ebp], edx

; 169  : 	p0_f = jlag;

  001dd	8b 45 f4	 mov	 eax, DWORD PTR _jlag$[ebp]
  001e0	89 45 ec	 mov	 DWORD PTR _p0_f$[ebp], eax
$L1301:

; 170  :       }
; 171  :       pforward_costs[jlag] = forcosts;

  001e3	8b 4d f4	 mov	 ecx, DWORD PTR _jlag$[ebp]
  001e6	8b 55 d4	 mov	 edx, DWORD PTR _forcosts$[ebp]
  001e9	89 94 8d c8 fb
	ff ff		 mov	 DWORD PTR _pforward_costs$[ebp+ecx*4], edx

; 172  :     }

  001f0	e9 50 fe ff ff	 jmp	 $L1288
$L1289:

; 173  :   }
; 174  : 
; 175  :   p0_f += LPITCH_MIN;

  001f5	8b 45 ec	 mov	 eax, DWORD PTR _p0_f$[ebp]
  001f8	83 c0 05	 add	 eax, 5
  001fb	89 45 ec	 mov	 DWORD PTR _p0_f$[ebp], eax

; 176  : 
; 177  : 
; 178  :   /*--------------------------------------------------
; 179  :     To prevent pick too small pitch as the candidates,
; 180  :     If p0_f is [PITCH_MIN:PITCH_MIN+1], we have to check
; 181  :     the costs of 2*p0_f and 3*p0_f. If all of them are 
; 182  :     very large, then we keep this candidates. Otherwise,
; 183  :     we have to find the largest cost from 3*p0_f+1:
; 184  :     PITCH_MAX.
; 185  :     --------------------------------------------------*/
; 186  :   if (p0_f <= LPITCH_MIN_CONF) {

  001fe	83 7d ec 0a	 cmp	 DWORD PTR _p0_f$[ebp], 10 ; 0000000aH
  00202	0f 8f 92 00 00
	00		 jg	 $L1302

; 187  :     jlag = 2*p0_f-LPITCH_MIN;

  00208	8b 4d ec	 mov	 ecx, DWORD PTR _p0_f$[ebp]
  0020b	8d 54 09 fb	 lea	 edx, DWORD PTR [ecx+ecx-5]
  0020f	89 55 f4	 mov	 DWORD PTR _jlag$[ebp], edx

; 188  :     tmpcost2 = pforward_costs[jlag];

  00212	8b 45 f4	 mov	 eax, DWORD PTR _jlag$[ebp]
  00215	8b 8c 85 c8 fb
	ff ff		 mov	 ecx, DWORD PTR _pforward_costs$[ebp+eax*4]
  0021c	89 4d fc	 mov	 DWORD PTR _tmpcost2$[ebp], ecx

; 189  :     jlag += p0_f;

  0021f	8b 55 f4	 mov	 edx, DWORD PTR _jlag$[ebp]
  00222	03 55 ec	 add	 edx, DWORD PTR _p0_f$[ebp]
  00225	89 55 f4	 mov	 DWORD PTR _jlag$[ebp], edx

; 190  :     tmpcost3 = pforward_costs[jlag];

  00228	8b 45 f4	 mov	 eax, DWORD PTR _jlag$[ebp]
  0022b	8b 8c 85 c8 fb
	ff ff		 mov	 ecx, DWORD PTR _pforward_costs$[ebp+eax*4]
  00232	89 4d f0	 mov	 DWORD PTR _tmpcost3$[ebp], ecx

; 191  :     if ((tmpcost2 < 0.5F*cost_f) || (tmpcost3 < 0.5F*cost_f)) {

  00235	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000
  0023b	d8 4d e0	 fmul	 DWORD PTR _cost_f$[ebp]
  0023e	d8 5d fc	 fcomp	 DWORD PTR _tmpcost2$[ebp]
  00241	df e0		 fnstsw	 ax
  00243	f6 c4 41	 test	 ah, 65			; 00000041H
  00246	74 13		 je	 SHORT $L1304
  00248	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000
  0024e	d8 4d e0	 fmul	 DWORD PTR _cost_f$[ebp]
  00251	d8 5d f0	 fcomp	 DWORD PTR _tmpcost3$[ebp]
  00254	df e0		 fnstsw	 ax
  00256	f6 c4 41	 test	 ah, 65			; 00000041H
  00259	75 3f		 jne	 SHORT $L1302
$L1304:

; 192  :       /* we have to find the new forward tracking candidates */
; 193  :       jlag++;

  0025b	8b 55 f4	 mov	 edx, DWORD PTR _jlag$[ebp]
  0025e	83 c2 01	 add	 edx, 1
  00261	89 55 f4	 mov	 DWORD PTR _jlag$[ebp], edx

; 194  :       FindMaxValueFlt(&(pforward_costs[jlag]), (PITCH_CAND-jlag),
; 195  : 		      &tmpmaxlag, &cost_f);

  00264	8d 45 e0	 lea	 eax, DWORD PTR _cost_f$[ebp]
  00267	50		 push	 eax
  00268	8d 4d e4	 lea	 ecx, DWORD PTR _tmpmaxlag$[ebp]
  0026b	51		 push	 ecx
  0026c	ba 56 00 00 00	 mov	 edx, 86			; 00000056H
  00271	2b 55 f4	 sub	 edx, DWORD PTR _jlag$[ebp]
  00274	52		 push	 edx
  00275	8b 45 f4	 mov	 eax, DWORD PTR _jlag$[ebp]
  00278	8d 8c 85 c8 fb
	ff ff		 lea	 ecx, DWORD PTR _pforward_costs$[ebp+eax*4]
  0027f	51		 push	 ecx
  00280	e8 00 00 00 00	 call	 _FindMaxValueFlt@16

; 196  :       p0_f = tmpmaxlag + jlag + LPITCH_MIN;

  00285	8b 55 f4	 mov	 edx, DWORD PTR _jlag$[ebp]
  00288	8b 45 e4	 mov	 eax, DWORD PTR _tmpmaxlag$[ebp]
  0028b	8d 4c 10 05	 lea	 ecx, DWORD PTR [eax+edx+5]
  0028f	89 4d ec	 mov	 DWORD PTR _p0_f$[ebp], ecx

; 197  : 
; 198  :       *tooSmall_flag = 1;

  00292	8b 55 18	 mov	 edx, DWORD PTR _tooSmall_flag$[ebp]
  00295	66 c7 02 01 00	 mov	 WORD PTR [edx], 1
$L1302:

; 199  :     }
; 200  :   }
; 201  :   
; 202  :   *pp0_f = (short) p0_f;

  0029a	8b 45 14	 mov	 eax, DWORD PTR _pp0_f$[ebp]
  0029d	66 8b 4d ec	 mov	 cx, WORD PTR _p0_f$[ebp]
  002a1	66 89 08	 mov	 WORD PTR [eax], cx

; 203  :   *pcost_f = cost_f;

  002a4	8b 55 10	 mov	 edx, DWORD PTR _pcost_f$[ebp]
  002a7	8b 45 e0	 mov	 eax, DWORD PTR _cost_f$[ebp]
  002aa	89 02		 mov	 DWORD PTR [edx], eax

; 204  :   STACK_END
; 205  : }

  002ac	8b e5		 mov	 esp, ebp
  002ae	5d		 pop	 ebp
  002af	c2 14 00	 ret	 20			; 00000014H
_LookForward@20 ENDP
_TEXT	ENDS
PUBLIC	__real@3e800000
PUBLIC	__real@3eb33333
PUBLIC	__real@3ecccccd
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3eb33333
CONST	SEGMENT
__real@3eb33333 DD 03eb33333r			; 0.35
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _LookBackward@12
_TEXT	SEGMENT
_lag_2$ = -44
_lag_1$ = -40
_k$ = -36
_dLagStart$ = -32
_tmpmaxcost$ = -28
_cost_b$ = -24
_tmpmaxlag$ = -20
_dLagLength$ = -16
_tmpcost$ = -12
_p0_b$ = -8
_pcost0$ = -4
_myCorrPDA_mblk$ = 8
_pcost_b$ = 12
_pp0_b$ = 16
_LookBackward@12 PROC NEAR				; COMDAT

; 212  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi

; 213  :   float *pcost0 = myCorrPDA_mblk->costs0;

  00007	8b 45 08	 mov	 eax, DWORD PTR _myCorrPDA_mblk$[ebp]
  0000a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000d	89 4d fc	 mov	 DWORD PTR _pcost0$[ebp], ecx

; 214  :   short lag_1, lag_2;
; 215  :   int *dLagStart = myCorrPDA_mblk->dInterLagStart;

  00010	8b 55 08	 mov	 edx, DWORD PTR _myCorrPDA_mblk$[ebp]
  00013	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00016	89 45 e0	 mov	 DWORD PTR _dLagStart$[ebp], eax

; 216  :   int *dLagLength = myCorrPDA_mblk->dInterLagLength;

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _myCorrPDA_mblk$[ebp]
  0001c	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0001f	89 55 f0	 mov	 DWORD PTR _dLagLength$[ebp], edx

; 217  :   float tmpcost;
; 218  :   float tmpmaxcost;
; 219  :   int tmpmaxlag;
; 220  :   float cost_b;
; 221  :   short p0_b;
; 222  :   short k;
; 223  : 
; 224  :   /*--------------------------------------------------
; 225  :     find out the backward candidate.
; 226  :     --------------------------------------------------*/
; 227  :   lag_1 = (short)(myCorrPDA_mblk->pitch_1 - LPITCH_MIN);

  00022	8b 45 08	 mov	 eax, DWORD PTR _myCorrPDA_mblk$[ebp]
  00025	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00028	83 e9 05	 sub	 ecx, 5
  0002b	66 89 4d d8	 mov	 WORD PTR _lag_1$[ebp], cx

; 228  :   k = (short) dLagStart[lag_1];

  0002f	0f bf 55 d8	 movsx	 edx, WORD PTR _lag_1$[ebp]
  00033	8b 45 e0	 mov	 eax, DWORD PTR _dLagStart$[ebp]
  00036	66 8b 0c 90	 mov	 cx, WORD PTR [eax+edx*4]
  0003a	66 89 4d dc	 mov	 WORD PTR _k$[ebp], cx

; 229  :   FindMaxValueFlt(&(pcost0[k]), dLagLength[lag_1], &tmpmaxlag, &tmpmaxcost);

  0003e	8d 55 e4	 lea	 edx, DWORD PTR _tmpmaxcost$[ebp]
  00041	52		 push	 edx
  00042	8d 45 ec	 lea	 eax, DWORD PTR _tmpmaxlag$[ebp]
  00045	50		 push	 eax
  00046	0f bf 4d d8	 movsx	 ecx, WORD PTR _lag_1$[ebp]
  0004a	8b 55 f0	 mov	 edx, DWORD PTR _dLagLength$[ebp]
  0004d	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00050	50		 push	 eax
  00051	0f bf 4d dc	 movsx	 ecx, WORD PTR _k$[ebp]
  00055	8b 55 fc	 mov	 edx, DWORD PTR _pcost0$[ebp]
  00058	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _FindMaxValueFlt@16

; 230  : 
; 231  :   p0_b = (short)(tmpmaxlag + k + LPITCH_MIN);

  00061	0f bf 4d dc	 movsx	 ecx, WORD PTR _k$[ebp]
  00065	8b 55 ec	 mov	 edx, DWORD PTR _tmpmaxlag$[ebp]
  00068	8d 44 0a 05	 lea	 eax, DWORD PTR [edx+ecx+5]
  0006c	66 89 45 f8	 mov	 WORD PTR _p0_b$[ebp], ax

; 232  :   cost_b = (tmpmaxcost + myCorrPDA_mblk->cost_1) * 0.5F; 

  00070	8b 4d 08	 mov	 ecx, DWORD PTR _myCorrPDA_mblk$[ebp]
  00073	d9 45 e4	 fld	 DWORD PTR _tmpmaxcost$[ebp]
  00076	d8 41 20	 fadd	 DWORD PTR [ecx+32]
  00079	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  0007f	d9 5d e8	 fstp	 DWORD PTR _cost_b$[ebp]

; 233  : 
; 234  :   
; 235  :   /*--------------------------------------------------
; 236  :     lookback to see if the previous previous frame is under
; 237  :     tracking.
; 238  :     --------------------------------------------------*/
; 239  :   lag_2 = (short)(myCorrPDA_mblk->pitch_2 - LPITCH_MIN);

  00082	8b 55 08	 mov	 edx, DWORD PTR _myCorrPDA_mblk$[ebp]
  00085	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00088	83 e8 05	 sub	 eax, 5
  0008b	66 89 45 d4	 mov	 WORD PTR _lag_2$[ebp], ax

; 240  :   k = (short) dLagStart[lag_2];

  0008f	0f bf 4d d4	 movsx	 ecx, WORD PTR _lag_2$[ebp]
  00093	8b 55 e0	 mov	 edx, DWORD PTR _dLagStart$[ebp]
  00096	66 8b 04 8a	 mov	 ax, WORD PTR [edx+ecx*4]
  0009a	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax

; 241  : 
; 242  :   if (lag_1>=k && lag_1< (k+dLagLength[lag_2])) {

  0009e	0f bf 4d d8	 movsx	 ecx, WORD PTR _lag_1$[ebp]
  000a2	0f bf 55 dc	 movsx	 edx, WORD PTR _k$[ebp]
  000a6	3b ca		 cmp	 ecx, edx
  000a8	7c 4e		 jl	 SHORT $L1329
  000aa	0f bf 45 d8	 movsx	 eax, WORD PTR _lag_1$[ebp]
  000ae	0f bf 4d dc	 movsx	 ecx, WORD PTR _k$[ebp]
  000b2	0f bf 55 d4	 movsx	 edx, WORD PTR _lag_2$[ebp]
  000b6	8b 75 f0	 mov	 esi, DWORD PTR _dLagLength$[ebp]
  000b9	03 0c 96	 add	 ecx, DWORD PTR [esi+edx*4]
  000bc	3b c1		 cmp	 eax, ecx
  000be	7d 38		 jge	 SHORT $L1329

; 243  :     tmpcost = (float)(myCorrPDA_mblk->cost_2*0.25F + myCorrPDA_mblk->cost_1*0.35F
; 244  :       + tmpmaxcost*0.4F);

  000c0	8b 45 08	 mov	 eax, DWORD PTR _myCorrPDA_mblk$[ebp]
  000c3	d9 40 24	 fld	 DWORD PTR [eax+36]
  000c6	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e800000
  000cc	8b 4d 08	 mov	 ecx, DWORD PTR _myCorrPDA_mblk$[ebp]
  000cf	d9 41 20	 fld	 DWORD PTR [ecx+32]
  000d2	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3eb33333
  000d8	de c1		 faddp	 ST(1), ST(0)
  000da	d9 45 e4	 fld	 DWORD PTR _tmpmaxcost$[ebp]
  000dd	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3ecccccd
  000e3	de c1		 faddp	 ST(1), ST(0)
  000e5	d9 55 f4	 fst	 DWORD PTR _tmpcost$[ebp]

; 245  :     if (tmpcost > cost_b)

  000e8	d8 5d e8	 fcomp	 DWORD PTR _cost_b$[ebp]
  000eb	df e0		 fnstsw	 ax
  000ed	f6 c4 41	 test	 ah, 65			; 00000041H
  000f0	75 06		 jne	 SHORT $L1329

; 246  :       cost_b = tmpcost;

  000f2	8b 55 f4	 mov	 edx, DWORD PTR _tmpcost$[ebp]
  000f5	89 55 e8	 mov	 DWORD PTR _cost_b$[ebp], edx
$L1329:

; 247  :   } /* end of "if (lag_1 ... " */
; 248  : 
; 249  :   *pcost_b = cost_b;

  000f8	8b 45 0c	 mov	 eax, DWORD PTR _pcost_b$[ebp]
  000fb	8b 4d e8	 mov	 ecx, DWORD PTR _cost_b$[ebp]
  000fe	89 08		 mov	 DWORD PTR [eax], ecx

; 250  :   *pp0_b = p0_b;

  00100	8b 55 10	 mov	 edx, DWORD PTR _pp0_b$[ebp]
  00103	66 8b 45 f8	 mov	 ax, WORD PTR _p0_b$[ebp]
  00107	66 89 02	 mov	 WORD PTR [edx], ax

; 251  : }

  0010a	5e		 pop	 esi
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c2 0c 00	 ret	 12			; 0000000cH
_LookBackward@12 ENDP
_TEXT	ENDS
END
