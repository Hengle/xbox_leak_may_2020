; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\encsc.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_02CNCKJAMN@pv?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KKGCKCNJ@energy?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@CLPIAPDA@post?5encode?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@DPMHLOK@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@FOIFDNEI@?$CIiLength?$DO?$DO1?$CJ?5?$DM?$DN?5?$CIENC_DELAY_SIZE?$CL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxEncodeSC@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxInitEncodeSC3@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxInitEncodeSC6@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxFreeEncodeSC3@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxFreeEncodeSC6@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _voxSetEncodeRate@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _voxGetEncodeRate@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _voxGetEncodeInitRate@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CoarsePitchAndFrameEnergy@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _PitchAdaptiveSpectrum@28
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _OuterFrameParam@36
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
PUBLIC	_Kaiwin0
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
CONST	SEGMENT
_Kaiwin0 DD	03cc98aa3r			; 0.0246022
	DD	03ce34189r			; 0.0277412
	DD	03cfe61f7r			; 0.0310526
	DD	03d0d79fcr			; 0.0345402
	DD	03d1c7fb8r			; 0.0382077
	DD	03d2c4613r			; 0.042059
	DD	03d3cd0d9r			; 0.0460976
	DD	03d4e23c2r			; 0.0503271
	DD	03d60426fr			; 0.0547509
	DD	03d73306ar			; 0.0593723
	DD	03d837890r			; 0.0641948
	DD	03d8dc3f3r			; 0.0692214
	DD	03d987bfar			; 0.0744552
	DD	03da3a232r			; 0.0798992
	DD	03daf3819r			; 0.0855562
	DD	03dbb3f1br			; 0.091429
	DD	03dc7b897r			; 0.09752
	DD	03dd4a5d8r			; 0.103832
	DD	03de20817r			; 0.110367
	DD	03defe077r			; 0.117127
	DD	03dfe3010r			; 0.124115
	DD	03e067befr			; 0.131332
	DD	03e0e1c69r			; 0.13878
	DD	03e15f9dcr			; 0.146461
	DD	03e1e14acr			; 0.154376
	DD	03e266d2br			; 0.162526
	DD	03e2f03a9r			; 0.170912
	DD	03e37d85dr			; 0.179536
	DD	03e40eb7br			; 0.188398
	DD	03e4a3d2dr			; 0.197499
	DD	03e53cd8cr			; 0.206839
	DD	03e5d9ca4r			; 0.216418
	DD	03e67aa77r			; 0.226236
	DD	03e71f6f9r			; 0.236294
	DD	03e7c820fr			; 0.24659
	DD	03e83a5cbr			; 0.257124
	DD	03e8929adr			; 0.267896
	DD	03e8ecc8fr			; 0.278904
	DD	03e948e45r			; 0.290148
	DD	03e9a6ea5r			; 0.301625
	DD	03ea06d74r			; 0.313335
	DD	03ea68a7dr			; 0.325275
	DD	03eacc57cr			; 0.337444
	DD	03eb31e23r			; 0.349839
	DD	03eb99422r			; 0.362458
	DD	03ec02724r			; 0.375299
	DD	03ec6d6c5r			; 0.388357
	DD	03ecda2a2r			; 0.401631
	DD	03ed48a4cr			; 0.415118
	DD	03edb8d4br			; 0.428812
	DD	03ee2ab2br			; 0.442712
	DD	03ee9e361r			; 0.456813
	DD	03ef13565r			; 0.47111
	DD	03ef8a0a8r			; 0.485601
	DD	03f00124br			; 0.500279
	DD	03f03e045r			; 0.515141
	DD	03f07b9f0r			; 0.530181
	DD	03f0b9ef4r			; 0.545394
	DD	03f0f8efer			; 0.560776
	DD	03f1389a9r			; 0.576319
	DD	03f178e95r			; 0.592019
	DD	03f1b9d66r			; 0.60787
	DD	03f1fb5b1r			; 0.623866
	DD	03f23d70dr			; 0.64
	DD	03f280110r			; 0.656266
	DD	03f2c3344r			; 0.672657
	DD	03f306d3cr			; 0.689167
	DD	03f34ae81r			; 0.705788
	DD	03f38f696r			; 0.722513
	DD	03f3d4508r			; 0.739335
	DD	03f419956r			; 0.756246
	DD	03f45f2fer			; 0.773239
	DD	03f4a5182r			; 0.790306
	DD	03f4eb458r			; 0.807439
	DD	03f531afcr			; 0.82463
	DD	03f5784e9r			; 0.841872
	DD	03f5bf18br			; 0.859154
	DD	03f606056r			; 0.87647
	DD	03f64d0c1r			; 0.89381
	DD	03f694236r			; 0.911167
	DD	03f6db41dr			; 0.92853
	DD	03f7225edr			; 0.945891
	DD	03f76970er			; 0.963242
	DD	03f7b06e7r			; 0.980574
	DD	03f7f74dar			; 0.997877
	DD	03f81f02br			; 1.01514
	DD	03f84245br			; 1.03236
	DD	03f8656b4r			; 1.04952
	DD	03f8886e8r			; 1.06662
	DD	03f8ab4a8r			; 1.08364
	DD	03f8cdfa7r			; 1.10058
	DD	03f8f0792r			; 1.11742
	DD	03f912c1cr			; 1.13416
	DD	03f934cf7r			; 1.15079
	DD	03f9569d2r			; 1.16729
	DD	03f978264r			; 1.18367
	DD	03f999657r			; 1.1999
	DD	03f9ba566r			; 1.21599
	DD	03f9daf33r			; 1.23191
	DD	03f9fb37fr			; 1.24767
	DD	03fa1b1fbr			; 1.26324
	DD	03fa3aa50r			; 1.27864
	DD	03fa59c3dr			; 1.29383
	DD	03fa78771r			; 1.30882
	DD	03fa96ba0r			; 1.3236
	DD	03fab4881r			; 1.33815
	DD	03fad1dcbr			; 1.35247
	DD	03faeeb32r			; 1.36655
	DD	03fb0b076r			; 1.38039
	DD	03fb26d47r			; 1.39396
	DD	03fb42165r			; 1.40727
	DD	03fb5cc89r			; 1.4203
	DD	03fb76e70r			; 1.43306
	DD	03fb906d8r			; 1.44552
	DD	03fba9581r			; 1.45769
	DD	03fbc1a28r			; 1.46955
	DD	03fbd9495r			; 1.4811
	DD	03fbf0481r			; 1.49232
	DD	03fc069ber			; 1.50323
	DD	03fc1c405r			; 1.51379
	DD	03fc31329r			; 1.52402
	DD	03fc456f1r			; 1.5339
	DD	03fc58f20r			; 1.54343
	DD	03fc6bb8er			; 1.5526
	DD	03fc7dc05r			; 1.5614
	DD	03fc8f053r			; 1.56983
	DD	03fc9f855r			; 1.57789
	DD	03fcaf3d4r			; 1.58557
	DD	03fcbe2a9r			; 1.59285
	DD	03fccc4b4r			; 1.59975
	DD	03fcd99c9r			; 1.60626
	DD	03fce61c3r			; 1.61236
	DD	03fcf1c88r			; 1.61806
	DD	03fcfc9f4r			; 1.62335
	DD	03fd069e8r			; 1.62823
	DD	03fd0fc54r			; 1.6327
	DD	03fd1810fr			; 1.63675
	DD	03fd1f813r			; 1.64038
	DD	03fd26147r			; 1.64359
	DD	03fd2bc94r			; 1.64638
	DD	03fd309f2r			; 1.64874
	DD	03fd3494cr			; 1.65067
	DD	03fd37aa4r			; 1.65218
	DD	03fd39de3r			; 1.65326
	DD	03fd3b310r			; 1.6539
	DD	03fd3ba1br			; 1.65412
CONST	ENDS
PUBLIC	_VoxEncodeSC@12
EXTRN	_MidFrameParam@24:NEAR
EXTRN	_UpdateVF_States@8:NEAR
EXTRN	_vemServiceState@4:NEAR
EXTRN	__fltused:NEAR
EXTRN	_PutFrameSpCBM@16:NEAR
EXTRN	_VoxPreProcess@16:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\encsc.c
;	COMDAT _VoxEncodeSC@12
_TEXT	SEGMENT
_SWI$2285 = -3752
_SWR$2284 = -2728
_fSpBuf$2283 = -672
_pParamMblk$ = -32
_hCircBufBlk$ = -28
_iLength$ = -24
_fCorrCost$ = -20
_pSubParam$ = -16
_WinShift$ = -12
_vfFlag$ = -8
_pEncMemBlk$ = -4
_pPCMBuffer$ = 8
_hEncMemBlk$ = 12
_hParamMblk$ = 16
_VoxEncodeSC@12 PROC NEAR				; COMDAT

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 0e 00
	00		 sub	 esp, 3752		; 00000ea8H

; 137  :    ENC_MEM_BLK *pEncMemBlk   = (ENC_MEM_BLK *)hEncMemBlk;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _hEncMemBlk$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _pEncMemBlk$[ebp], eax

; 138  :    PARAM_SC    *pParamMblk   = (PARAM_SC *)hParamMblk;

  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _hParamMblk$[ebp]
  00012	89 4d e0	 mov	 DWORD PTR _pParamMblk$[ebp], ecx

; 139  :    void        *hCircBufBlk = pEncMemBlk->CircBuf_mblk;

  00015	8b 55 fc	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	89 45 e4	 mov	 DWORD PTR _hCircBufBlk$[ebp], eax

; 140  :    SUBFRAME_PARAM_SC *pSubParam;
; 141  : 
; 142  : 
; 143  :    int    iLength;              /* window length */
; 144  :    int    vfFlag = 0;

  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _vfFlag$[ebp], 0

; 145  :    int    WinShift = 0;

  00024	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _WinShift$[ebp], 0

; 146  :    float  fCorrCost;
; 147  :    
; 148  :    pSubParam = &(pParamMblk->SubParam[PARAM_ENDFRAME]);

  0002b	8b 4d e0	 mov	 ecx, DWORD PTR _pParamMblk$[ebp]
  0002e	83 c1 28	 add	 ecx, 40			; 00000028H
  00031	89 4d f0	 mov	 DWORD PTR _pSubParam$[ebp], ecx

; 149  : 
; 150  :    /*--------------------------------------------------------------
; 151  :      Test for a valid bitrate
; 152  :    --------------------------------------------------------------*/
; 153  :    if (!(pEncMemBlk->iSCTargetRate & pEncMemBlk->iSCRateValid))

  00034	8b 55 fc	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  00037	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  0003a	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  0003d	23 48 20	 and	 ecx, DWORD PTR [eax+32]
  00040	85 c9		 test	 ecx, ecx
  00042	75 09		 jne	 SHORT $L2282

; 154  :       return 1;

  00044	66 b8 01 00	 mov	 ax, 1
  00048	e9 0e 01 00 00	 jmp	 $L2271
$L2282:

; 155  : 
; 156  :    /*--------------------------------------------------------------
; 157  :      Preprocess two 10ms frames of speech with a high-pass filter
; 158  :        and store the result in the circular buffer.
; 159  :    --------------------------------------------------------------*/
; 160  :    {
; 161  :       STACK_INIT
; 162  :       float fSpBuf[FRAME_LENGTH_SC];
; 163  :       STACK_INIT_END
; 164  :  
; 165  :       STACK_ATTACH(float *, fSpBuf)
; 166  :  
; 167  :       STACK_START
; 168  : 
; 169  :       VoxPreProcess( pPCMBuffer, fSpBuf, FRAME_LENGTH_SC, 
; 170  :                      pEncMemBlk->PreProc_mblk );

  0004d	8b 55 fc	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  00050	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00053	50		 push	 eax
  00054	68 a0 00 00 00	 push	 160			; 000000a0H
  00059	8d 8d 60 fd ff
	ff		 lea	 ecx, DWORD PTR _fSpBuf$2283[ebp]
  0005f	51		 push	 ecx
  00060	8b 55 08	 mov	 edx, DWORD PTR _pPCMBuffer$[ebp]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 _VoxPreProcess@16

; 171  : 
; 172  :       PutFrameSpCBM( hCircBufBlk, 0, FRAME_LENGTH_SC, fSpBuf );

  00069	8d 85 60 fd ff
	ff		 lea	 eax, DWORD PTR _fSpBuf$2283[ebp]
  0006f	50		 push	 eax
  00070	68 a0 00 00 00	 push	 160			; 000000a0H
  00075	6a 00		 push	 0
  00077	8b 4d e4	 mov	 ecx, DWORD PTR _hCircBufBlk$[ebp]
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 _PutFrameSpCBM@16

; 173  : 
; 174  :       STACK_END
; 175  :    }
; 176  : 
; 177  : 
; 178  :    /*--------------------------------------------------------------
; 179  :      Make a coarse pitch estimate and compute the frame energy
; 180  :    --------------------------------------------------------------*/
; 181  :    pSubParam->Pitch = CoarsePitchAndFrameEnergy( STACK_S
; 182  :                                                hCircBufBlk,
; 183  :                                                pEncMemBlk->LDPDA_mblk,
; 184  :                                                &(pEncMemBlk->frameEnergy) );

  00080	8b 55 fc	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  00083	83 c2 2c	 add	 edx, 44			; 0000002cH
  00086	52		 push	 edx
  00087	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  0008a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0008d	51		 push	 ecx
  0008e	8b 55 e4	 mov	 edx, DWORD PTR _hCircBufBlk$[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 _CoarsePitchAndFrameEnergy@12
  00097	8b 45 f0	 mov	 eax, DWORD PTR _pSubParam$[ebp]
  0009a	d9 18		 fstp	 DWORD PTR [eax]

; 185  : 
; 186  :    
; 187  :    {
; 188  :    STACK_INIT    /*%#  scratch memory #%*/
; 189  :       float SWR[NFFT+2];
; 190  :       float SWI[NFFT_2];
; 191  :    STACK_INIT_END
; 192  :  
; 193  :       STACK_ATTACH(float *, SWR)
; 194  :       STACK_ATTACH(float *, SWI)
; 195  :  
; 196  :       STACK_START
; 197  : 
; 198  :       /*--------------------------------------------------------------
; 199  :         Compute the spectrum based on a pitch-adaptive Hamming
; 200  :           window
; 201  :       --------------------------------------------------------------*/
; 202  :       PitchAdaptiveSpectrum( STACK_S pSubParam->Pitch,
; 203  :                              pEncMemBlk->Onset_mblk, 
; 204  :                              hCircBufBlk, SWR, SWI, &iLength, &WinShift );

  0009c	8d 4d f4	 lea	 ecx, DWORD PTR _WinShift$[ebp]
  0009f	51		 push	 ecx
  000a0	8d 55 e8	 lea	 edx, DWORD PTR _iLength$[ebp]
  000a3	52		 push	 edx
  000a4	8d 85 58 f1 ff
	ff		 lea	 eax, DWORD PTR _SWI$2285[ebp]
  000aa	50		 push	 eax
  000ab	8d 8d 58 f5 ff
	ff		 lea	 ecx, DWORD PTR _SWR$2284[ebp]
  000b1	51		 push	 ecx
  000b2	8b 55 e4	 mov	 edx, DWORD PTR _hCircBufBlk$[ebp]
  000b5	52		 push	 edx
  000b6	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  000b9	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000bc	51		 push	 ecx
  000bd	8b 55 f0	 mov	 edx, DWORD PTR _pSubParam$[ebp]
  000c0	8b 02		 mov	 eax, DWORD PTR [edx]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _PitchAdaptiveSpectrum@28

; 205  : 
; 206  :       /*--------------------------------------------------------------
; 207  :         Compute outer frame parameters (i.e. at 20 ms)
; 208  :       --------------------------------------------------------------*/
; 209  :       OuterFrameParam( STACK_S hCircBufBlk, SWR, SWI, pParamMblk, pEncMemBlk,
; 210  :                                iLength, WinShift, &vfFlag, &fCorrCost);

  000c8	8d 4d ec	 lea	 ecx, DWORD PTR _fCorrCost$[ebp]
  000cb	51		 push	 ecx
  000cc	8d 55 f8	 lea	 edx, DWORD PTR _vfFlag$[ebp]
  000cf	52		 push	 edx
  000d0	8b 45 f4	 mov	 eax, DWORD PTR _WinShift$[ebp]
  000d3	50		 push	 eax
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _iLength$[ebp]
  000d7	51		 push	 ecx
  000d8	8b 55 fc	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  000db	52		 push	 edx
  000dc	8b 45 e0	 mov	 eax, DWORD PTR _pParamMblk$[ebp]
  000df	50		 push	 eax
  000e0	8d 8d 58 f1 ff
	ff		 lea	 ecx, DWORD PTR _SWI$2285[ebp]
  000e6	51		 push	 ecx
  000e7	8d 95 58 f5 ff
	ff		 lea	 edx, DWORD PTR _SWR$2284[ebp]
  000ed	52		 push	 edx
  000ee	8b 45 e4	 mov	 eax, DWORD PTR _hCircBufBlk$[ebp]
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 _OuterFrameParam@36

; 211  :       STACK_END
; 212  :    }
; 213  : 
; 214  :    /*--------------------------------------------------------------
; 215  :      Compute mid-frame parameters (i.e. at 10 ms)
; 216  :    --------------------------------------------------------------*/
; 217  :    MidFrameParam( STACK_S pEncMemBlk, hParamMblk, 
; 218  :                   ENC_DELAY_SIZE+HALF_FRAME_LENGTH_SC, 
; 219  :                   (short)pEncMemBlk->iSCTargetRate, fCorrCost, vfFlag );

  000f7	8b 4d f8	 mov	 ecx, DWORD PTR _vfFlag$[ebp]
  000fa	51		 push	 ecx
  000fb	8b 55 ec	 mov	 edx, DWORD PTR _fCorrCost$[ebp]
  000fe	52		 push	 edx
  000ff	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  00102	0f bf 48 28	 movsx	 ecx, WORD PTR [eax+40]
  00106	51		 push	 ecx
  00107	68 e1 00 00 00	 push	 225			; 000000e1H
  0010c	8b 55 10	 mov	 edx, DWORD PTR _hParamMblk$[ebp]
  0010f	52		 push	 edx
  00110	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 _MidFrameParam@24

; 220  : 
; 221  :    /*--------------------------------------------------------------
; 222  :      update the states of vocal fry detector
; 223  :    --------------------------------------------------------------*/
; 224  :    UpdateVF_States((void *)pParamMblk, pEncMemBlk->VocalFry_mblk );

  00119	8b 4d fc	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  0011c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0011f	52		 push	 edx
  00120	8b 45 e0	 mov	 eax, DWORD PTR _pParamMblk$[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _UpdateVF_States@8

; 225  : 
; 226  :    /*--------------------------------------------------------------
; 227  :      Save pitch and voicing estimates and the bit-rate
; 228  :    --------------------------------------------------------------*/
; 229  :    pEncMemBlk->uq_Pitch_1 = pSubParam->Pitch;

  00129	8b 4d fc	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  0012c	8b 55 f0	 mov	 edx, DWORD PTR _pSubParam$[ebp]
  0012f	8b 02		 mov	 eax, DWORD PTR [edx]
  00131	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 230  :    pEncMemBlk->uq_Pv_1    = pSubParam->Pv;

  00134	8b 4d fc	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  00137	8b 55 f0	 mov	 edx, DWORD PTR _pSubParam$[ebp]
  0013a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0013d	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 231  :    pEncMemBlk->iSCRate_1  = pEncMemBlk->iSCTargetRate;

  00140	8b 4d fc	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  00143	8b 55 fc	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  00146	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00149	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 232  : 
; 233  : 
; 234  :    /*--------------------------------------------------------------
; 235  :      Service the Voxware Extention Manager (VEM).
; 236  :    --------------------------------------------------------------*/
; 237  :    vemServiceState(pEncMemBlk->postEnc);

  0014c	8b 4d fc	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  0014f	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00152	52		 push	 edx
  00153	e8 00 00 00 00	 call	 _vemServiceState@4

; 238  : 
; 239  :    return 0;

  00158	66 33 c0	 xor	 ax, ax
$L2271:

; 240  : 
; 241  : } /*VoxEncodeSC()*/

  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c2 0c 00	 ret	 12			; 0000000cH
_VoxEncodeSC@12 ENDP
_TEXT	ENDS
PUBLIC	_VoxInitEncodeSC3@8
PUBLIC	??_C@_02CNCKJAMN@pv?$AA@			; `string'
PUBLIC	??_C@_06KKGCKCNJ@energy?$AA@			; `string'
PUBLIC	??_C@_0M@CLPIAPDA@post?5encode?$AA@		; `string'
EXTRN	_VoxInitVocalFry@4:NEAR
EXTRN	_VoxInitEstOnset@4:NEAR
EXTRN	_vemRegisterState@8:NEAR
EXTRN	_vemRegisterVariable@16:NEAR
EXTRN	_calloc:NEAR
EXTRN	_InitSpCBM@8:NEAR
EXTRN	_VoxInitPreProc@8:NEAR
EXTRN	_VoxInitLDPDA@4:NEAR
;	COMDAT ??_C@_02CNCKJAMN@pv?$AA@
CONST	SEGMENT
??_C@_02CNCKJAMN@pv?$AA@ DB 'pv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KKGCKCNJ@energy?$AA@
CONST	SEGMENT
??_C@_06KKGCKCNJ@energy?$AA@ DB 'energy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CLPIAPDA@post?5encode?$AA@
CONST	SEGMENT
??_C@_0M@CLPIAPDA@post?5encode?$AA@ DB 'post encode', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxInitEncodeSC3@8
_TEXT	SEGMENT
_pEncode_mblk$ = -4
_hMemBlkE$ = 8
_pVemMem$ = 12
_VoxInitEncodeSC3@8 PROC NEAR				; COMDAT

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 270  : 
; 271  :   ENC_MEM_BLK *pEncode_mblk;
; 272  : 
; 273  :    
; 274  :   if(VOX_MEM_INIT(pEncode_mblk=*hMemBlkE,1,sizeof(ENC_MEM_BLK)))

  00004	6a 48		 push	 72			; 00000048H
  00006	6a 01		 push	 1
  00008	e8 00 00 00 00	 call	 _calloc
  0000d	83 c4 08	 add	 esp, 8
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _hMemBlkE$[ebp]
  00013	89 01		 mov	 DWORD PTR [ecx], eax
  00015	8b 55 08	 mov	 edx, DWORD PTR _hMemBlkE$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	89 45 fc	 mov	 DWORD PTR _pEncode_mblk$[ebp], eax
  0001d	83 7d fc 00	 cmp	 DWORD PTR _pEncode_mblk$[ebp], 0
  00021	75 09		 jne	 SHORT $L2295

; 275  :      return 1;

  00023	66 b8 01 00	 mov	 ax, 1
  00027	e9 07 01 00 00	 jmp	 $L2292
$L2295:

; 276  : 
; 277  :   /****************************************************
; 278  :    Ensure bit allocation is byte aligned
; 279  :    ****************************************************/
; 280  :   assert(!(TOTAL_BITS_SC3%8));
; 281  : 
; 282  :   /****************************************************
; 283  :    Attaching the main vem mem handle
; 284  :    ****************************************************/
; 285  :   pEncode_mblk->pVemMem=pVemMem;

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  0002f	8b 55 0c	 mov	 edx, DWORD PTR _pVemMem$[ebp]
  00032	89 51 40	 mov	 DWORD PTR [ecx+64], edx

; 286  : 
; 287  : 
; 288  :   /****************************************************
; 289  :   initialize circular buffer structure
; 290  :   ****************************************************/
; 291  :   /* initialize the circular buffer manager */
; 292  :   if(InitSpCBM(CIRCBUF_LENGTH, &pEncode_mblk->CircBuf_mblk))

  00035	8b 45 fc	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  00038	50		 push	 eax
  00039	68 73 01 00 00	 push	 371			; 00000173H
  0003e	e8 00 00 00 00	 call	 _InitSpCBM@8
  00043	0f b7 c8	 movzx	 ecx, ax
  00046	85 c9		 test	 ecx, ecx
  00048	74 09		 je	 SHORT $L2297

; 293  :       return 1;

  0004a	66 b8 01 00	 mov	 ax, 1
  0004e	e9 e0 00 00 00	 jmp	 $L2292
$L2297:

; 294  :  
; 295  :  
; 296  :   /****************************************************
; 297  :   initialize the pre-process structure
; 298  :   ****************************************************/
; 299  :   if(VoxInitPreProc(&pEncode_mblk->PreProc_mblk, PREPROC_COEF))

  00053	68 a4 70 7d 3f	 push	 1065185444		; 3f7d70a4H
  00058	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  0005b	83 c2 04	 add	 edx, 4
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 _VoxInitPreProc@8
  00064	0f b7 c0	 movzx	 eax, ax
  00067	85 c0		 test	 eax, eax
  00069	74 09		 je	 SHORT $L2298

; 300  :       return 1;

  0006b	66 b8 01 00	 mov	 ax, 1
  0006f	e9 bf 00 00 00	 jmp	 $L2292
$L2298:

; 301  :    
; 302  :  
; 303  :   /****************************************************
; 304  :   initialize PEA structure
; 305  :   ****************************************************/
; 306  :   pEncode_mblk->fVoicing_km1 = 0.0F;

  00074	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  00077	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 307  : 
; 308  :   /****************************************************
; 309  :   initialize LDPDA structure
; 310  :   ****************************************************/
; 311  :   VoxInitLDPDA(&pEncode_mblk->LDPDA_mblk);

  0007e	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  00081	83 c2 10	 add	 edx, 16			; 00000010H
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _VoxInitLDPDA@4

; 312  : 
; 313  :   /****************************************************
; 314  :     initialize vocal fry detector structure 
; 315  :   ***************************************************/
; 316  :   VoxInitVocalFry(&pEncode_mblk->VocalFry_mblk);

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  0008d	83 c0 14	 add	 eax, 20			; 00000014H
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _VoxInitVocalFry@4

; 317  : 
; 318  :   /***************************************************
; 319  :     Initialize onset detector structure 
; 320  :   **************************************************/
; 321  :   VoxInitEstOnset(&pEncode_mblk->Onset_mblk);

  00096	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  00099	83 c1 18	 add	 ecx, 24			; 00000018H
  0009c	51		 push	 ecx
  0009d	e8 00 00 00 00	 call	 _VoxInitEstOnset@4

; 322  : 
; 323  :   /**** set the rate valid bit for SC_RATE_3K ****/
; 324  :   pEncode_mblk->iSCRateValid = SC_RATE_3K;

  000a2	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  000a5	c7 42 20 01 00
	00 00		 mov	 DWORD PTR [edx+32], 1

; 325  :   pEncode_mblk->iSCTargetRate = SC_RATE_3K;

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  000af	c7 40 28 01 00
	00 00		 mov	 DWORD PTR [eax+40], 1

; 326  : 
; 327  :   /***** Set the Cost for middle-frame ******/
; 328  :   pEncode_mblk->lastCorrCost = 0.0F;

  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  000b9	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 329  : 
; 330  :   /***** set the unquantized parameters of previous frame *****/
; 331  :   pEncode_mblk->uq_Pv_1 = 0.0F;

  000c0	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  000c3	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 332  :   pEncode_mblk->uq_Pitch_1 = INITIAL_PITCH;

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  000cd	c7 40 34 00 00
	c8 42		 mov	 DWORD PTR [eax+52], 1120403456 ; 42c80000H

; 333  : 
; 334  :   /***** set the unquantized parameters of previous frame *****/
; 335  :   pEncode_mblk->Pv_1 = 0.0F;

  000d4	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  000d7	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 336  :   pEncode_mblk->Pitch_1 = INITIAL_PITCH;

  000de	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  000e1	c7 42 3c 00 00
	c8 42		 mov	 DWORD PTR [edx+60], 1120403456 ; 42c80000H

; 337  : 
; 338  :   vemRegisterVariable(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler,  
; 339  :                       &pEncode_mblk->uq_Pv_1, VEM_FLOAT, "pv");

  000e8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02CNCKJAMN@pv?$AA@
  000ed	6a 09		 push	 9
  000ef	8b 45 fc	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  000f2	83 c0 30	 add	 eax, 48			; 00000030H
  000f5	50		 push	 eax
  000f6	8b 4d 0c	 mov	 ecx, DWORD PTR _pVemMem$[ebp]
  000f9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fb	52		 push	 edx
  000fc	e8 00 00 00 00	 call	 _vemRegisterVariable@16

; 340  : 
; 341  :   vemRegisterVariable(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler,  
; 342  :                       &pEncode_mblk->frameEnergy, VEM_FLOAT, "energy");

  00101	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06KKGCKCNJ@energy?$AA@
  00106	6a 09		 push	 9
  00108	8b 45 fc	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  0010b	83 c0 2c	 add	 eax, 44			; 0000002cH
  0010e	50		 push	 eax
  0010f	8b 4d 0c	 mov	 ecx, DWORD PTR _pVemMem$[ebp]
  00112	8b 11		 mov	 edx, DWORD PTR [ecx]
  00114	52		 push	 edx
  00115	e8 00 00 00 00	 call	 _vemRegisterVariable@16

; 343  :   
; 344  :   pEncode_mblk->postEnc=vemRegisterState(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, "post encode");

  0011a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@CLPIAPDA@post?5encode?$AA@
  0011f	8b 45 0c	 mov	 eax, DWORD PTR _pVemMem$[ebp]
  00122	8b 08		 mov	 ecx, DWORD PTR [eax]
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 _vemRegisterState@8
  0012a	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  0012d	89 42 44	 mov	 DWORD PTR [edx+68], eax

; 345  : 
; 346  :   return 0; 

  00130	66 33 c0	 xor	 ax, ax
$L2292:

; 347  : }

  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c2 08 00	 ret	 8
_VoxInitEncodeSC3@8 ENDP
_TEXT	ENDS
PUBLIC	_VoxInitEncodeSC6@4
; Function compile flags: /Odt
;	COMDAT _VoxInitEncodeSC6@4
_TEXT	SEGMENT
_pEncode_mblk$ = -4
_hMemBlkE$ = 8
_VoxInitEncodeSC6@4 PROC NEAR				; COMDAT

; 350  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 351  :  
; 352  :    ENC_MEM_BLK *pEncode_mblk=(ENC_MEM_BLK *)*hMemBlkE;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hMemBlkE$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _pEncode_mblk$[ebp], ecx

; 353  : 
; 354  : 
; 355  :    /****************************************************
; 356  :      Ensure bit allocation is byte aligned
; 357  :    ****************************************************/
; 358  :    assert( ADDITIONAL_BITS_SC6 == ADDITIONAL_BYTES_SC6*8 );
; 359  : 
; 360  :    /****************************************************
; 361  :      check for a valid pointer
; 362  :    ****************************************************/
; 363  :    if (pEncode_mblk==NULL)

  0000c	83 7d fc 00	 cmp	 DWORD PTR _pEncode_mblk$[ebp], 0
  00010	75 06		 jne	 SHORT $L2312

; 364  :       return 1;

  00012	66 b8 01 00	 mov	 ax, 1
  00016	eb 2f		 jmp	 SHORT $L2307
$L2312:

; 365  : 
; 366  :    /****************************************************
; 367  :      make sure SC_RATE_3K was already initialized
; 368  :    ****************************************************/
; 369  :    if(!(pEncode_mblk->iSCRateValid & SC_RATE_3K))

  00018	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  0001b	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001e	83 e0 01	 and	 eax, 1
  00021	85 c0		 test	 eax, eax
  00023	75 06		 jne	 SHORT $L2313

; 370  :       return 1;

  00025	66 b8 01 00	 mov	 ax, 1
  00029	eb 1c		 jmp	 SHORT $L2307
$L2313:

; 371  : 
; 372  :   /**** set the rate valid bit for SC_RATE_6K ****/
; 373  :   pEncode_mblk->iSCRateValid |= SC_RATE_6K;

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  0002e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00031	83 ca 02	 or	 edx, 2
  00034	8b 45 fc	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  00037	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 374  :   pEncode_mblk->iSCTargetRate = SC_RATE_6K;

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  0003d	c7 41 28 02 00
	00 00		 mov	 DWORD PTR [ecx+40], 2

; 375  : 
; 376  :   return 0;

  00044	66 33 c0	 xor	 ax, ax
$L2307:

; 377  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
_VoxInitEncodeSC6@4 ENDP
_TEXT	ENDS
PUBLIC	_VoxFreeEncodeSC3@4
EXTRN	_VoxFreeLDPDA@4:NEAR
EXTRN	_VoxFreeVocalFry@4:NEAR
EXTRN	_VoxFreeEstOnset@4:NEAR
EXTRN	_free:NEAR
EXTRN	_FreeSpCBM@4:NEAR
EXTRN	_nspFreeFftResources@0:NEAR
EXTRN	_VoxFreePreProc@4:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxFreeEncodeSC3@4
_TEXT	SEGMENT
_pEncode_mblk$ = -4
_hMemBlkE$ = 8
_VoxFreeEncodeSC3@4 PROC NEAR				; COMDAT

; 403  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 404  :   ENC_MEM_BLK *pEncode_mblk=(ENC_MEM_BLK*)*hMemBlkE;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hMemBlkE$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _pEncode_mblk$[ebp], ecx

; 405  : 
; 406  :    if (pEncode_mblk) {

  0000c	83 7d fc 00	 cmp	 DWORD PTR _pEncode_mblk$[ebp], 0
  00010	74 57		 je	 SHORT $L2319

; 407  : 
; 408  :      /**** free circular structure ****/
; 409  :      FreeSpCBM(&pEncode_mblk->CircBuf_mblk);

  00012	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 _FreeSpCBM@4

; 410  :  
; 411  :      /**** free preprocess structure ****/
; 412  :      VoxFreePreProc(&pEncode_mblk->PreProc_mblk);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _VoxFreePreProc@4

; 413  : 
; 414  :      /**** free LDPDA structure *****/
; 415  :      VoxFreeLDPDA(&pEncode_mblk->LDPDA_mblk);

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  0002a	83 c1 10	 add	 ecx, 16			; 00000010H
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 _VoxFreeLDPDA@4

; 416  : 
; 417  :      /**** free vocal fry structure ****/
; 418  :      VoxFreeVocalFry(&pEncode_mblk->VocalFry_mblk);

  00033	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  00036	83 c2 14	 add	 edx, 20			; 00000014H
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 _VoxFreeVocalFry@4

; 419  : 
; 420  :      /**** free onset structure ****/
; 421  :      VoxFreeEstOnset(&pEncode_mblk->Onset_mblk);

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  00042	83 c0 18	 add	 eax, 24			; 00000018H
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _VoxFreeEstOnset@4

; 422  :     
; 423  :      VOX_MEM_FREE(pEncode_mblk);

  0004b	83 7d fc 00	 cmp	 DWORD PTR _pEncode_mblk$[ebp], 0
  0004f	74 13		 je	 SHORT $L2320
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _free
  0005a	83 c4 04	 add	 esp, 4
  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pEncode_mblk$[ebp], 0
$L2320:

; 424  : 
; 425  : #ifdef WIN32
; 426  :      nspFreeFftResources();

  00064	e8 00 00 00 00	 call	 _nspFreeFftResources@0
$L2319:

; 427  : #endif
; 428  :   }
; 429  :   return 0;

  00069	66 33 c0	 xor	 ax, ax

; 430  : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
_VoxFreeEncodeSC3@4 ENDP
_TEXT	ENDS
PUBLIC	_VoxFreeEncodeSC6@4
; Function compile flags: /Odt
;	COMDAT _VoxFreeEncodeSC6@4
_TEXT	SEGMENT
_pEncode_mblk$ = -4
_hMemBlkE$ = 8
_VoxFreeEncodeSC6@4 PROC NEAR				; COMDAT

; 433  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 434  :   ENC_MEM_BLK *pEncode_mblk=(ENC_MEM_BLK*)*hMemBlkE;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hMemBlkE$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _pEncode_mblk$[ebp], ecx

; 435  : 
; 436  :   if (pEncode_mblk) {

  0000c	83 7d fc 00	 cmp	 DWORD PTR _pEncode_mblk$[ebp], 0
  00010	74 0f		 je	 SHORT $L2327

; 437  :      /**** clear the rate valid bit for SC_RATE_6K ****/
; 438  :      pEncode_mblk->iSCRateValid &= (~(SC_RATE_6K));

  00012	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  00015	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00018	83 e0 fd	 and	 eax, -3			; fffffffdH
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  0001e	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$L2327:

; 439  : 
; 440  :   }
; 441  :   return 0;

  00021	66 33 c0	 xor	 ax, ax

; 442  : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
_VoxFreeEncodeSC6@4 ENDP
_TEXT	ENDS
PUBLIC	_voxSetEncodeRate@8
; Function compile flags: /Odt
;	COMDAT _voxSetEncodeRate@8
_TEXT	SEGMENT
_pEncode_mblk$ = -8
_check$ = -4
_pMemBlkE$ = 8
_wBitField$ = 12
_voxSetEncodeRate@8 PROC NEAR				; COMDAT

; 451  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 452  :    ENC_MEM_BLK *pEncode_mblk=(ENC_MEM_BLK*)pMemBlkE;

  00006	8b 45 08	 mov	 eax, DWORD PTR _pMemBlkE$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _pEncode_mblk$[ebp], eax

; 453  :    unsigned short check=0;

  0000c	66 c7 45 fc 00
	00		 mov	 WORD PTR _check$[ebp], 0

; 454  : 
; 455  :    /* determine the highest rate in the field and set accordingly */
; 456  :    if(wBitField&SC_RATE_6K) 

  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _wBitField$[ebp]
  00015	83 e1 02	 and	 ecx, 2
  00018	85 c9		 test	 ecx, ecx
  0001a	74 23		 je	 SHORT $L2336

; 457  :       if(pEncode_mblk->iSCRateValid&SC_RATE_6K) 

  0001c	8b 55 f8	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  0001f	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00022	83 e0 02	 and	 eax, 2
  00025	85 c0		 test	 eax, eax
  00027	74 10		 je	 SHORT $L2337

; 458  :          return((unsigned short)(pEncode_mblk->iSCTargetRate=SC_RATE_6K));

  00029	8b 4d f8	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  0002c	c7 41 28 02 00
	00 00		 mov	 DWORD PTR [ecx+40], 2
  00033	66 b8 02 00	 mov	 ax, 2
  00037	eb 3d		 jmp	 SHORT $L2332
$L2337:

; 459  :       else
; 460  :          check=1;

  00039	66 c7 45 fc 01
	00		 mov	 WORD PTR _check$[ebp], 1
$L2336:

; 461  : 
; 462  :    if(wBitField&SC_RATE_3K||check) {

  0003f	8b 55 0c	 mov	 edx, DWORD PTR _wBitField$[ebp]
  00042	83 e2 01	 and	 edx, 1
  00045	85 d2		 test	 edx, edx
  00047	75 08		 jne	 SHORT $L2341
  00049	0f b7 45 fc	 movzx	 eax, WORD PTR _check$[ebp]
  0004d	85 c0		 test	 eax, eax
  0004f	74 22		 je	 SHORT $L2340
$L2341:

; 463  :       if(pEncode_mblk->iSCRateValid&SC_RATE_3K) 

  00051	8b 4d f8	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  00054	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00057	83 e2 01	 and	 edx, 1
  0005a	85 d2		 test	 edx, edx
  0005c	74 10		 je	 SHORT $L2342

; 464  :          return((unsigned short)(pEncode_mblk->iSCTargetRate=SC_RATE_3K));

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  00061	c7 40 28 01 00
	00 00		 mov	 DWORD PTR [eax+40], 1
  00068	66 b8 01 00	 mov	 ax, 1
  0006c	eb 08		 jmp	 SHORT $L2332
$L2342:

; 465  :       else
; 466  :          return 0; /* couldn't find the rate */

  0006e	66 33 c0	 xor	 ax, ax
  00071	eb 03		 jmp	 SHORT $L2332
$L2340:

; 467  :    }
; 468  :    return 0; /* couldn't find the bit rate */

  00073	66 33 c0	 xor	 ax, ax
$L2332:

; 469  : }

  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c2 08 00	 ret	 8
_voxSetEncodeRate@8 ENDP
_TEXT	ENDS
PUBLIC	_voxGetEncodeRate@4
; Function compile flags: /Odt
;	COMDAT _voxGetEncodeRate@4
_TEXT	SEGMENT
_pMemBlkE$ = 8
_voxGetEncodeRate@4 PROC NEAR				; COMDAT

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 473  :    return(((ENC_MEM_BLK*)pMemBlkE)->iSCTargetRate);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pMemBlkE$[ebp]
  00006	8b 40 28	 mov	 eax, DWORD PTR [eax+40]

; 474  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
_voxGetEncodeRate@4 ENDP
_TEXT	ENDS
PUBLIC	_voxGetEncodeInitRate@4
; Function compile flags: /Odt
;	COMDAT _voxGetEncodeInitRate@4
_TEXT	SEGMENT
_pMemBlkE$ = 8
_voxGetEncodeInitRate@4 PROC NEAR			; COMDAT

; 477  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 478  :    return(((ENC_MEM_BLK*)pMemBlkE)->iSCRateValid);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pMemBlkE$[ebp]
  00006	8b 40 20	 mov	 eax, DWORD PTR [eax+32]

; 479  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
_voxGetEncodeInitRate@4 ENDP
_TEXT	ENDS
PUBLIC	__real@3b6135aa
EXTRN	_GetFrameSpCBM@16:NEAR
EXTRN	_SymWindowSignal@16:NEAR
EXTRN	_VoxFftCenter@16:NEAR
EXTRN	_DotProd@12:NEAR
EXTRN	_VoxLDPDA@8:NEAR
;	COMDAT __real@3b6135aa
CONST	SEGMENT
__real@3b6135aa DD 03b6135aar			; 0.00343643
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _CoarsePitchAndFrameEnergy@12
_TEXT	SEGMENT
_fPitch$ = -2068
_pfSW$ = -2064
_pfSpBuf$ = -4
_hCircBufBlk$ = 8
_hLdPdaBlk$ = 12
_fFrameEnergy$ = 16
_CoarsePitchAndFrameEnergy@12 PROC NEAR			; COMDAT

; 514  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 08 00
	00		 sub	 esp, 2068		; 00000814H

; 515  :    float  fPitch;
; 516  :    float *pfSpBuf;
; 517  : STACK_INIT
; 518  :    float pfSW[NFFT+2];
; 519  : STACK_INIT_END
; 520  :  
; 521  :    STACK_ATTACH(float *, pfSW)
; 522  :  
; 523  :    STACK_START
; 524  : 
; 525  :    assert((NFFT+2) >= PDA_FRAME_SIZE0);
; 526  :    pfSpBuf = pfSW; /* make sure sharing is ok */

  00009	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _pfSW$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _pfSpBuf$[ebp], eax

; 527  : 
; 528  :    /*-------------------------------------------------------------------
; 529  :      Get a segment of speech from the circular buffer and window it
; 530  :        with a 291 point Kaiser window.
; 531  :    -------------------------------------------------------------------*/
; 532  :    GetFrameSpCBM( hCircBufBlk, ENC_DELAY_SIZE, PDA_FRAME_SIZE0, pfSpBuf);

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _pfSpBuf$[ebp]
  00015	51		 push	 ecx
  00016	68 23 01 00 00	 push	 291			; 00000123H
  0001b	68 91 00 00 00	 push	 145			; 00000091H
  00020	8b 55 08	 mov	 edx, DWORD PTR _hCircBufBlk$[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 _GetFrameSpCBM@16

; 533  :    SymWindowSignal( pfSpBuf, Kaiwin0, pfSpBuf, PDA_FRAME_SIZE0);

  00029	68 23 01 00 00	 push	 291			; 00000123H
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _pfSpBuf$[ebp]
  00031	50		 push	 eax
  00032	68 00 00 00 00	 push	 OFFSET FLAT:_Kaiwin0
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _pfSpBuf$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _SymWindowSignal@16

; 534  : 
; 535  :    /*-------------------------------------------------------------------
; 536  :      Compute fFrameEnergy as the power of the windowed speech.
; 537  :    -------------------------------------------------------------------*/
; 538  :    *fFrameEnergy  = DotProd( pfSpBuf, pfSpBuf, PDA_FRAME_SIZE0);

  00040	68 23 01 00 00	 push	 291			; 00000123H
  00045	8b 55 fc	 mov	 edx, DWORD PTR _pfSpBuf$[ebp]
  00048	52		 push	 edx
  00049	8b 45 fc	 mov	 eax, DWORD PTR _pfSpBuf$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _DotProd@12
  00052	8b 4d 10	 mov	 ecx, DWORD PTR _fFrameEnergy$[ebp]
  00055	d9 19		 fstp	 DWORD PTR [ecx]

; 539  :    *fFrameEnergy *= INV_PEA_FRAME_SIZE0;

  00057	8b 55 10	 mov	 edx, DWORD PTR _fFrameEnergy$[ebp]
  0005a	d9 02		 fld	 DWORD PTR [edx]
  0005c	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3b6135aa
  00062	8b 45 10	 mov	 eax, DWORD PTR _fFrameEnergy$[ebp]
  00065	d9 18		 fstp	 DWORD PTR [eax]

; 540  : 
; 541  :    /*------------------------------------------------------------
; 542  :       Take the FFT of fSpBuf[] -- (in-place operation).
; 543  :       The output is interleaved.
; 544  :      ------------------------------------------------------------*/
; 545  :    VoxFftCenter( pfSpBuf, PDA_FRAME_SIZE0, pfSW, FFT_ORDER);

  00067	6a 09		 push	 9
  00069	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR _pfSW$[ebp]
  0006f	51		 push	 ecx
  00070	68 23 01 00 00	 push	 291			; 00000123H
  00075	8b 55 fc	 mov	 edx, DWORD PTR _pfSpBuf$[ebp]
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 _VoxFftCenter@16

; 546  : 
; 547  :    /*------------------------------------------------------------
; 548  :       Coarse pitch estimation.
; 549  :      ------------------------------------------------------------*/
; 550  :     fPitch = VoxLDPDA(STACK_S pfSW, hLdPdaBlk);

  0007e	8b 45 0c	 mov	 eax, DWORD PTR _hLdPdaBlk$[ebp]
  00081	50		 push	 eax
  00082	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR _pfSW$[ebp]
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 _VoxLDPDA@8
  0008e	d9 95 ec f7 ff
	ff		 fst	 DWORD PTR _fPitch$[ebp]

; 551  : 
; 552  :    STACK_END
; 553  : 
; 554  :    return fPitch;
; 555  : 
; 556  : } /* CoarsePitchAndFrameEnergy() */

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 0c 00	 ret	 12			; 0000000cH
_CoarsePitchAndFrameEnergy@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DO@DPMHLOK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CN@FOIFDNEI@?$CIiLength?$DO?$DO1?$CJ?5?$DM?$DN?5?$CIENC_DELAY_SIZE?$CL@ ; `string'
EXTRN	_EstOnset@20:NEAR
EXTRN	_HammingWindowNormSC@8:NEAR
EXTRN	_VoxDemultiplex@16:NEAR
EXTRN	_ScaleVector@16:NEAR
EXTRN	__assert:NEAR
EXTRN	_VoxAdaptiveWindow@4:NEAR
;	COMDAT ??_C@_0DO@DPMHLOK@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DO@DPMHLOK@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pri'
	DB	'vate\windows\directx\dsound\codecs\voxware\encsc.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FOIFDNEI@?$CIiLength?$DO?$DO1?$CJ?5?$DM?$DN?5?$CIENC_DELAY_SIZE?$CL@
CONST	SEGMENT
??_C@_0CN@FOIFDNEI@?$CIiLength?$DO?$DO1?$CJ?5?$DM?$DN?5?$CIENC_DELAY_SIZE?$CL@ DB '('
	DB	'iLength>>1) <= (ENC_DELAY_SIZE+*piWinShift)', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _PitchAdaptiveSpectrum@28
_TEXT	SEGMENT
_fSpBuf$ = -1056
_iLength$ = -4
_fPitch$ = 8
_hOnsetBlk$ = 12
_hCircBufBlk$ = 16
_pfSWR$ = 20
_pfSWI$ = 24
_piLength$ = 28
_piWinShift$ = 32
_PitchAdaptiveSpectrum@28 PROC NEAR			; COMDAT

; 596  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 04 00
	00		 sub	 esp, 1056		; 00000420H

; 597  :  
; 598  :    int    iLength;
; 599  : 
; 600  : STACK_INIT
; 601  :    float fSpBuf[PDA_FRAME_SIZE1];
; 602  : STACK_INIT_END
; 603  :  
; 604  :    STACK_ATTACH(float *, fSpBuf)
; 605  :  
; 606  :    STACK_START
; 607  : 
; 608  :    /*-------------------------------------------------------------------
; 609  :      Set pitch-adaptive window length.
; 610  :    -------------------------------------------------------------------*/
; 611  :    iLength = VoxAdaptiveWindow( fPitch );

  00009	8b 45 08	 mov	 eax, DWORD PTR _fPitch$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _VoxAdaptiveWindow@4
  00012	89 45 fc	 mov	 DWORD PTR _iLength$[ebp], eax

; 612  :  
; 613  :    /*-------------------------------------------------------------------
; 614  :      Compute an adjustment of the window location to account for
; 615  :        onsets within the window.
; 616  :    -------------------------------------------------------------------*/
; 617  :    *piWinShift = EstOnset( hOnsetBlk, hCircBufBlk, ENC_DELAY_SIZE, iLength, 
; 618  :                            fSpBuf);

  00015	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _fSpBuf$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 fc	 mov	 edx, DWORD PTR _iLength$[ebp]
  0001f	52		 push	 edx
  00020	68 91 00 00 00	 push	 145			; 00000091H
  00025	8b 45 10	 mov	 eax, DWORD PTR _hCircBufBlk$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _hOnsetBlk$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _EstOnset@20
  00032	8b 55 20	 mov	 edx, DWORD PTR _piWinShift$[ebp]
  00035	89 02		 mov	 DWORD PTR [edx], eax

; 619  :  
; 620  :    /*-------------------------------------------------------------------
; 621  :      Get the speech
; 622  :    -------------------------------------------------------------------*/
; 623  :    assert((iLength>>1) <= (ENC_DELAY_SIZE+*piWinShift));

  00037	8b 45 fc	 mov	 eax, DWORD PTR _iLength$[ebp]
  0003a	d1 f8		 sar	 eax, 1
  0003c	8b 4d 20	 mov	 ecx, DWORD PTR _piWinShift$[ebp]
  0003f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00041	81 c2 91 00 00
	00		 add	 edx, 145		; 00000091H
  00047	3b c2		 cmp	 eax, edx
  00049	7e 17		 jle	 SHORT $L2481
  0004b	68 6f 02 00 00	 push	 623			; 0000026fH
  00050	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@DPMHLOK@c?3?2xbox?2private?2windows?2directx?2@
  00055	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@FOIFDNEI@?$CIiLength?$DO?$DO1?$CJ?5?$DM?$DN?5?$CIENC_DELAY_SIZE?$CL@
  0005a	e8 00 00 00 00	 call	 __assert
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L2481:

; 624  :    GetFrameSpCBM( hCircBufBlk, ENC_DELAY_SIZE+*piWinShift, iLength, fSpBuf );

  00062	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _fSpBuf$[ebp]
  00068	51		 push	 ecx
  00069	8b 55 fc	 mov	 edx, DWORD PTR _iLength$[ebp]
  0006c	52		 push	 edx
  0006d	8b 45 20	 mov	 eax, DWORD PTR _piWinShift$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	81 c1 91 00 00
	00		 add	 ecx, 145		; 00000091H
  00078	51		 push	 ecx
  00079	8b 55 10	 mov	 edx, DWORD PTR _hCircBufBlk$[ebp]
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 _GetFrameSpCBM@16

; 625  :  
; 626  :    /*-------------------------------------------------------------------
; 627  :      Multiply by 2.0 because of complex analysis
; 628  :    -------------------------------------------------------------------*/
; 629  :    ScaleVector( fSpBuf, iLength, 2.0F, fSpBuf );

  00082	8d 85 e0 fb ff
	ff		 lea	 eax, DWORD PTR _fSpBuf$[ebp]
  00088	50		 push	 eax
  00089	68 00 00 00 40	 push	 1073741824		; 40000000H
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _iLength$[ebp]
  00091	51		 push	 ecx
  00092	8d 95 e0 fb ff
	ff		 lea	 edx, DWORD PTR _fSpBuf$[ebp]
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 _ScaleVector@16

; 630  :  
; 631  :    /*-------------------------------------------------------------------
; 632  :      Apply a unit area Hamming window (NOTE: the area of the window in
; 633  :        HammingWindowNormSC() is 8% too big, but it is not changed for
; 634  :        backward compatability with coding tables)
; 635  :    -------------------------------------------------------------------*/
; 636  :    HammingWindowNormSC(fSpBuf, iLength);

  0009e	8b 45 fc	 mov	 eax, DWORD PTR _iLength$[ebp]
  000a1	50		 push	 eax
  000a2	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _fSpBuf$[ebp]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 _HammingWindowNormSC@8

; 637  :  
; 638  :    /*-------------------------------------------------------------------
; 639  :      Take the FFT of fSpBuf[].  The output is interleaved
; 640  :        so demultiplex it.  (the real part is demultiplexed
; 641  :        "in place")
; 642  :    -------------------------------------------------------------------*/
; 643  :    VoxFftCenter( fSpBuf, iLength, pfSWR, FFT_ORDER);

  000ae	6a 09		 push	 9
  000b0	8b 55 14	 mov	 edx, DWORD PTR _pfSWR$[ebp]
  000b3	52		 push	 edx
  000b4	8b 45 fc	 mov	 eax, DWORD PTR _iLength$[ebp]
  000b7	50		 push	 eax
  000b8	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _fSpBuf$[ebp]
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 _VoxFftCenter@16

; 644  :    VoxDemultiplex( pfSWR, pfSWR, pfSWI, NFFT_2);

  000c4	68 00 01 00 00	 push	 256			; 00000100H
  000c9	8b 55 18	 mov	 edx, DWORD PTR _pfSWI$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 14	 mov	 eax, DWORD PTR _pfSWR$[ebp]
  000d0	50		 push	 eax
  000d1	8b 4d 14	 mov	 ecx, DWORD PTR _pfSWR$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 _VoxDemultiplex@16

; 645  : 
; 646  :    *piLength = iLength;

  000da	8b 55 1c	 mov	 edx, DWORD PTR _piLength$[ebp]
  000dd	8b 45 fc	 mov	 eax, DWORD PTR _iLength$[ebp]
  000e0	89 02		 mov	 DWORD PTR [edx], eax

; 647  : 
; 648  :    STACK_END
; 649  : 
; 650  : } /* PitchAdaptiveSpectrum() */

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 1c 00	 ret	 28			; 0000001cH
_PitchAdaptiveSpectrum@28 ENDP
_TEXT	ENDS
PUBLIC	__real@44000000
PUBLIC	__real@3f000000
EXTRN	_TDPitchRefine@20:NEAR
EXTRN	_Detect_VocalFry@16:NEAR
EXTRN	_linearinterp@12:NEAR
EXTRN	_K2ASK@12:NEAR
EXTRN	_VoxSTFTpeaks@24:NEAR
EXTRN	_memset:NEAR
EXTRN	_VoxSeevocFlattop@24:NEAR
EXTRN	_LogEnvelopeToAs@20:NEAR
EXTRN	_VoxSTCVoicing@28:NEAR
EXTRN	_ModifyPv@20:NEAR
EXTRN	_VoxSTFTPhase@24:NEAR
;	COMDAT __real@44000000
CONST	SEGMENT
__real@44000000 DD 044000000r			; 512
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _OuterFrameParam@36
_TEXT	SEGMENT
_MagSq$ = -3024
_fAS$ = -2000
_fPitchDFT$ = -1996
_fSpBuf$ = -1992
_fKS$ = -824
_fLogSeeEnv$ = -820
_PeakPwr$ = -816
_pSubParam$ = -412
_PeakFrq$ = -408
_iPeakCount$ = -4
_hCircBufBlk$ = 8
_pfSWR$ = 12
_pfSWI$ = 16
_pParamMblk$ = 20
_pEncMemBlk$ = 24
_iLength$ = 28
_iWinShift$ = 32
_piVFflag$ = 36
_pfCorrCost$ = 40
_OuterFrameParam@36 PROC NEAR				; COMDAT

; 692  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 0b 00
	00		 sub	 esp, 3024		; 00000bd0H

; 693  :    int   iPeakCount;
; 694  :    float fPitchDFT;
; 695  : 
; 696  :    SUBFRAME_PARAM_SC *pSubParam;
; 697  :    STACK_INIT
; 698  :      float PeakPwr[MAXHARM];
; 699  :      float PeakFrq[MAXHARM];
; 700  :      float MagSq[NFFT_2];
; 701  :      float fSpBuf[PDA_FRAME_SIZE0];
; 702  :    STACK_INIT_END
; 703  :     
; 704  :    STACK_ATTACH(float *, PeakPwr)
; 705  :    STACK_ATTACH(float *, PeakFrq)
; 706  :    STACK_ATTACH(float *, MagSq)
; 707  :    STACK_ATTACH(float *, fSpBuf)
; 708  : 
; 709  :    float *fAS = (float *)PeakPwr;        /***** fAS[LPC_ORDER_SC6+1]    *****/

  00009	8d 85 d0 fc ff
	ff		 lea	 eax, DWORD PTR _PeakPwr$[ebp]
  0000f	89 85 30 f8 ff
	ff		 mov	 DWORD PTR _fAS$[ebp], eax

; 710  :    float *fKS = (float *)PeakFrq;        /***** fKS[LPC_ORDER_SC6]      *****/

  00015	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR _PeakFrq$[ebp]
  0001b	89 8d c8 fc ff
	ff		 mov	 DWORD PTR _fKS$[ebp], ecx

; 711  :    float *fLogSeeEnv = (float *)MagSq;   /***** share MagSq with the    *****/

  00021	8d 95 30 f4 ff
	ff		 lea	 edx, DWORD PTR _MagSq$[ebp]
  00027	89 95 cc fc ff
	ff		 mov	 DWORD PTR _fLogSeeEnv$[ebp], edx

; 712  :                                          /***** memory fLogSeeEnv       *****/
; 713  :    
; 714  :    STACK_START
; 715  : 
; 716  :    assert(PDA_FRAME_SIZE0>=(2*MAXHARM)); /**** make sure the memory     *****/
; 717  :                                          /**** sharing is ok            *****/
; 718  :    assert(MAXHARM>=LPC_ORDER);           /**** make sure the memory     *****/
; 719  :                                          /**** sharing is ok            *****/
; 720  : 
; 721  :    pSubParam = &(pParamMblk->SubParam[PARAM_ENDFRAME]);

  0002d	8b 45 14	 mov	 eax, DWORD PTR _pParamMblk$[ebp]
  00030	83 c0 28	 add	 eax, 40			; 00000028H
  00033	89 85 64 fe ff
	ff		 mov	 DWORD PTR _pSubParam$[ebp], eax

; 722  :       
; 723  :    memset(PeakPwr, 0, MAXHARM*sizeof(float));

  00039	68 90 01 00 00	 push	 400			; 00000190H
  0003e	6a 00		 push	 0
  00040	8d 8d d0 fc ff
	ff		 lea	 ecx, DWORD PTR _PeakPwr$[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 _memset
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 724  :    memset(PeakFrq, 0, MAXHARM*sizeof(float));

  0004f	68 90 01 00 00	 push	 400			; 00000190H
  00054	6a 00		 push	 0
  00056	8d 95 68 fe ff
	ff		 lea	 edx, DWORD PTR _PeakFrq$[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 _memset
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH

; 725  :     
; 726  : 
; 727  :    /*-------------------------------------------------------------------
; 728  :      Compute the magnitude-squared STFT envelope and pick peaks
; 729  :    -------------------------------------------------------------------*/
; 730  :    VoxSTFTpeaks(STACK_S pfSWR, pfSWI, MagSq, PeakPwr, PeakFrq, &iPeakCount);

  00065	8d 45 fc	 lea	 eax, DWORD PTR _iPeakCount$[ebp]
  00068	50		 push	 eax
  00069	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR _PeakFrq$[ebp]
  0006f	51		 push	 ecx
  00070	8d 95 d0 fc ff
	ff		 lea	 edx, DWORD PTR _PeakPwr$[ebp]
  00076	52		 push	 edx
  00077	8d 85 30 f4 ff
	ff		 lea	 eax, DWORD PTR _MagSq$[ebp]
  0007d	50		 push	 eax
  0007e	8b 4d 10	 mov	 ecx, DWORD PTR _pfSWI$[ebp]
  00081	51		 push	 ecx
  00082	8b 55 0c	 mov	 edx, DWORD PTR _pfSWR$[ebp]
  00085	52		 push	 edx
  00086	e8 00 00 00 00	 call	 _VoxSTFTpeaks@24

; 731  : 
; 732  :    /*-------------------------------------------------------------------
; 733  :      Compute the flattop envelope of the squared STFT seevoc peaks
; 734  :    -------------------------------------------------------------------*/
; 735  :    fPitchDFT = (float)NFFT/pSubParam->Pitch;

  0008b	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _pSubParam$[ebp]
  00091	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@44000000
  00097	d8 30		 fdiv	 DWORD PTR [eax]
  00099	d9 9d 34 f8 ff
	ff		 fstp	 DWORD PTR _fPitchDFT$[ebp]

; 736  :    VoxSeevocFlattop(STACK_S MagSq, PeakPwr, PeakFrq, iPeakCount,fLogSeeEnv, 
; 737  :                     fPitchDFT);

  0009f	8b 8d 34 f8 ff
	ff		 mov	 ecx, DWORD PTR _fPitchDFT$[ebp]
  000a5	51		 push	 ecx
  000a6	8b 95 cc fc ff
	ff		 mov	 edx, DWORD PTR _fLogSeeEnv$[ebp]
  000ac	52		 push	 edx
  000ad	8b 45 fc	 mov	 eax, DWORD PTR _iPeakCount$[ebp]
  000b0	50		 push	 eax
  000b1	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR _PeakFrq$[ebp]
  000b7	51		 push	 ecx
  000b8	8d 95 d0 fc ff
	ff		 lea	 edx, DWORD PTR _PeakPwr$[ebp]
  000be	52		 push	 edx
  000bf	8d 85 30 f4 ff
	ff		 lea	 eax, DWORD PTR _MagSq$[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _VoxSeevocFlattop@24

; 738  :  
; 739  :    /*-------------------------------------------------------------------
; 740  :      Refine the pitch and compute the voicing probability
; 741  :    -------------------------------------------------------------------*/
; 742  :    VoxSTCVoicing(STACK_S &(pEncMemBlk->fVoicing_km1), fLogSeeEnv,
; 743  :                  &(pSubParam->Pitch), 
; 744  :                  &(pSubParam->Pv), 
; 745  :                  PeakPwr, PeakFrq, iPeakCount);

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _iPeakCount$[ebp]
  000ce	51		 push	 ecx
  000cf	8d 95 68 fe ff
	ff		 lea	 edx, DWORD PTR _PeakFrq$[ebp]
  000d5	52		 push	 edx
  000d6	8d 85 d0 fc ff
	ff		 lea	 eax, DWORD PTR _PeakPwr$[ebp]
  000dc	50		 push	 eax
  000dd	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR _pSubParam$[ebp]
  000e3	83 c1 04	 add	 ecx, 4
  000e6	51		 push	 ecx
  000e7	8b 95 64 fe ff
	ff		 mov	 edx, DWORD PTR _pSubParam$[ebp]
  000ed	52		 push	 edx
  000ee	8b 85 cc fc ff
	ff		 mov	 eax, DWORD PTR _fLogSeeEnv$[ebp]
  000f4	50		 push	 eax
  000f5	8b 4d 18	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  000f8	83 c1 08	 add	 ecx, 8
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 _VoxSTCVoicing@28

; 746  : 
; 747  :    /*-------------------------------------------------------------------
; 748  :      Interpolate the spectrum, fit a frequency-domain all-pole model,
; 749  :        and compute the arcsin reflection coefficients.
; 750  :    -------------------------------------------------------------------*/
; 751  :    linearinterp (fPitchDFT, fLogSeeEnv, NFFT_2);

  00101	68 00 01 00 00	 push	 256			; 00000100H
  00106	8b 95 cc fc ff
	ff		 mov	 edx, DWORD PTR _fLogSeeEnv$[ebp]
  0010c	52		 push	 edx
  0010d	8b 85 34 f8 ff
	ff		 mov	 eax, DWORD PTR _fPitchDFT$[ebp]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 _linearinterp@12

; 752  : 
; 753  :    LogEnvelopeToAs(STACK_S fLogSeeEnv, LPC_ORDER, &(pParamMblk->fLog2Gain),
; 754  :                    fAS, fKS);

  00119	8b 8d c8 fc ff
	ff		 mov	 ecx, DWORD PTR _fKS$[ebp]
  0011f	51		 push	 ecx
  00120	8b 95 30 f8 ff
	ff		 mov	 edx, DWORD PTR _fAS$[ebp]
  00126	52		 push	 edx
  00127	8b 45 14	 mov	 eax, DWORD PTR _pParamMblk$[ebp]
  0012a	83 c0 50	 add	 eax, 80			; 00000050H
  0012d	50		 push	 eax
  0012e	6a 0c		 push	 12			; 0000000cH
  00130	8b 8d cc fc ff
	ff		 mov	 ecx, DWORD PTR _fLogSeeEnv$[ebp]
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 _LogEnvelopeToAs@20

; 755  : 
; 756  :    K2ASK( LPC_ORDER,fKS, pParamMblk->pfASK );

  0013c	8b 55 14	 mov	 edx, DWORD PTR _pParamMblk$[ebp]
  0013f	83 c2 54	 add	 edx, 84			; 00000054H
  00142	52		 push	 edx
  00143	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR _fKS$[ebp]
  00149	50		 push	 eax
  0014a	6a 0c		 push	 12			; 0000000cH
  0014c	e8 00 00 00 00	 call	 _K2ASK@12

; 757  : 
; 758  :    /*-------------------------------------------------------------------
; 759  :      Compute a pitch correlation coefficient
; 760  :    -------------------------------------------------------------------*/
; 761  :    GetFrameSpCBM(hCircBufBlk, ENC_DELAY_SIZE+iWinShift, iLength, fSpBuf);

  00151	8d 8d 38 f8 ff
	ff		 lea	 ecx, DWORD PTR _fSpBuf$[ebp]
  00157	51		 push	 ecx
  00158	8b 55 1c	 mov	 edx, DWORD PTR _iLength$[ebp]
  0015b	52		 push	 edx
  0015c	8b 45 20	 mov	 eax, DWORD PTR _iWinShift$[ebp]
  0015f	05 91 00 00 00	 add	 eax, 145		; 00000091H
  00164	50		 push	 eax
  00165	8b 4d 08	 mov	 ecx, DWORD PTR _hCircBufBlk$[ebp]
  00168	51		 push	 ecx
  00169	e8 00 00 00 00	 call	 _GetFrameSpCBM@16

; 762  : 
; 763  :    ScaleVector( fSpBuf, iLength, 2.0F, fSpBuf );

  0016e	8d 95 38 f8 ff
	ff		 lea	 edx, DWORD PTR _fSpBuf$[ebp]
  00174	52		 push	 edx
  00175	68 00 00 00 40	 push	 1073741824		; 40000000H
  0017a	8b 45 1c	 mov	 eax, DWORD PTR _iLength$[ebp]
  0017d	50		 push	 eax
  0017e	8d 8d 38 f8 ff
	ff		 lea	 ecx, DWORD PTR _fSpBuf$[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _ScaleVector@16

; 764  : 
; 765  :    HammingWindowNormSC( fSpBuf, iLength);

  0018a	8b 55 1c	 mov	 edx, DWORD PTR _iLength$[ebp]
  0018d	52		 push	 edx
  0018e	8d 85 38 f8 ff
	ff		 lea	 eax, DWORD PTR _fSpBuf$[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 _HammingWindowNormSC@8

; 766  : 
; 767  :    TDPitchRefine(fSpBuf, (short)iLength, pSubParam->Pitch,
; 768  :                  pfCorrCost, 0.0F);

  0019a	6a 00		 push	 0
  0019c	8b 4d 28	 mov	 ecx, DWORD PTR _pfCorrCost$[ebp]
  0019f	51		 push	 ecx
  001a0	8b 95 64 fe ff
	ff		 mov	 edx, DWORD PTR _pSubParam$[ebp]
  001a6	8b 02		 mov	 eax, DWORD PTR [edx]
  001a8	50		 push	 eax
  001a9	66 8b 4d 1c	 mov	 cx, WORD PTR _iLength$[ebp]
  001ad	51		 push	 ecx
  001ae	8d 95 38 f8 ff
	ff		 lea	 edx, DWORD PTR _fSpBuf$[ebp]
  001b4	52		 push	 edx
  001b5	e8 00 00 00 00	 call	 _TDPitchRefine@20
  001ba	dd d8		 fstp	 ST(0)

; 769  :    
; 770  :    /*-------------------------------------------------------------------
; 771  :      Modify the voicing probability if it changes too sharply.
; 772  :    -------------------------------------------------------------------*/
; 773  :    pSubParam->Pv = ModifyPv(*pfCorrCost, pSubParam->Pv,
; 774  :                             pEncMemBlk->uq_Pv_1,
; 775  :                             pSubParam->Pitch,
; 776  :                             pEncMemBlk->uq_Pitch_1);

  001bc	8b 45 18	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  001bf	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001c2	51		 push	 ecx
  001c3	8b 95 64 fe ff
	ff		 mov	 edx, DWORD PTR _pSubParam$[ebp]
  001c9	8b 02		 mov	 eax, DWORD PTR [edx]
  001cb	50		 push	 eax
  001cc	8b 4d 18	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  001cf	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  001d2	52		 push	 edx
  001d3	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _pSubParam$[ebp]
  001d9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001dc	51		 push	 ecx
  001dd	8b 55 28	 mov	 edx, DWORD PTR _pfCorrCost$[ebp]
  001e0	8b 02		 mov	 eax, DWORD PTR [edx]
  001e2	50		 push	 eax
  001e3	e8 00 00 00 00	 call	 _ModifyPv@20
  001e8	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR _pSubParam$[ebp]
  001ee	d9 59 04	 fstp	 DWORD PTR [ecx+4]

; 777  : 
; 778  :    /*-------------------------------------------------------------------
; 779  :      Detect the presence of vocal fry.  When it is present, cut the
; 780  :        pitch period in half.
; 781  :    -------------------------------------------------------------------*/
; 782  :    *piVFflag = Detect_VocalFry( STACK_S (void *)pParamMblk,
; 783  :                                 pEncMemBlk->VocalFry_mblk, fAS, LPC_ORDER);

  001f1	6a 0c		 push	 12			; 0000000cH
  001f3	8b 95 30 f8 ff
	ff		 mov	 edx, DWORD PTR _fAS$[ebp]
  001f9	52		 push	 edx
  001fa	8b 45 18	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  001fd	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00200	51		 push	 ecx
  00201	8b 55 14	 mov	 edx, DWORD PTR _pParamMblk$[ebp]
  00204	52		 push	 edx
  00205	e8 00 00 00 00	 call	 _Detect_VocalFry@16
  0020a	0f bf c0	 movsx	 eax, ax
  0020d	8b 4d 24	 mov	 ecx, DWORD PTR _piVFflag$[ebp]
  00210	89 01		 mov	 DWORD PTR [ecx], eax

; 784  : 
; 785  :    if (*piVFflag == 1)

  00212	8b 55 24	 mov	 edx, DWORD PTR _piVFflag$[ebp]
  00215	83 3a 01	 cmp	 DWORD PTR [edx], 1
  00218	75 16		 jne	 SHORT $L2424

; 786  :      pSubParam->Pitch *= 0.5F;

  0021a	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _pSubParam$[ebp]
  00220	d9 00		 fld	 DWORD PTR [eax]
  00222	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00228	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR _pSubParam$[ebp]
  0022e	d9 19		 fstp	 DWORD PTR [ecx]
$L2424:

; 787  : 
; 788  :    STACK_END
; 789  : 
; 790  :    /*-------------------------------------------------------------------
; 791  :      Compute the baseband measured phases for SC6.
; 792  :    -------------------------------------------------------------------*/
; 793  :    if (pEncMemBlk->iSCTargetRate==SC_RATE_6K)

  00230	8b 55 18	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  00233	83 7a 28 02	 cmp	 DWORD PTR [edx+40], 2
  00237	75 30		 jne	 SHORT $L2403

; 794  :    {
; 795  :       /*** sample the 20ms STFT phase at the 20ms harmonics ***/
; 796  :       VoxSTFTPhase(pfSWR, pfSWI, (int)SC6_PHASES,
; 797  :                    pSubParam->pfVEVphase,
; 798  :                    (float)NFFT/(pSubParam->Pitch),
; 799  :                    (short)iWinShift);

  00239	66 8b 45 20	 mov	 ax, WORD PTR _iWinShift$[ebp]
  0023d	50		 push	 eax
  0023e	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR _pSubParam$[ebp]
  00244	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@44000000
  0024a	d8 31		 fdiv	 DWORD PTR [ecx]
  0024c	51		 push	 ecx
  0024d	d9 1c 24	 fstp	 DWORD PTR [esp]
  00250	8b 95 64 fe ff
	ff		 mov	 edx, DWORD PTR _pSubParam$[ebp]
  00256	83 c2 08	 add	 edx, 8
  00259	52		 push	 edx
  0025a	6a 08		 push	 8
  0025c	8b 45 10	 mov	 eax, DWORD PTR _pfSWI$[ebp]
  0025f	50		 push	 eax
  00260	8b 4d 0c	 mov	 ecx, DWORD PTR _pfSWR$[ebp]
  00263	51		 push	 ecx
  00264	e8 00 00 00 00	 call	 _VoxSTFTPhase@24
$L2403:

; 800  :    }
; 801  : 
; 802  : } /* OuterFrameParam() */   

  00269	8b e5		 mov	 esp, ebp
  0026b	5d		 pop	 ebp
  0026c	c2 24 00	 ret	 36			; 00000024H
_OuterFrameParam@36 ENDP
_TEXT	ENDS
END
