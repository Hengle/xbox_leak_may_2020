; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\outbuf.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxOutputManager@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxInitOutputBuffers@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxFreeOutputBuffers@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_VoxOutputManager@12
EXTRN	__ftol2:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\outbuf.c
;	COMDAT _VoxOutputManager@12
_TEXT	SEGMENT
_dataAend$ = -40
_dataAstart$ = -36
_outBufB1$ = -32
_outBufB$ = -28
_pInBuf$ = -24
_outBufB2$ = -20
_pOutBufB$ = -16
_i$ = -12
_dataB$ = -8
_myOutputBuffer_mblk$ = -4
_OutputBuffer_mblk$ = 8
_outFrameLEN$ = 12
_InBuf$ = 16
_VoxOutputManager@12 PROC NEAR				; COMDAT

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx

; 99   :    OutputBuffer *myOutputBuffer_mblk=(OutputBuffer *)OutputBuffer_mblk;

  00007	8b 45 08	 mov	 eax, DWORD PTR _OutputBuffer_mblk$[ebp]
  0000a	89 45 fc	 mov	 DWORD PTR _myOutputBuffer_mblk$[ebp], eax

; 100  : 
; 101  :    short		*outBufB1 = myOutputBuffer_mblk->outBufferB1;

  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	89 55 e0	 mov	 DWORD PTR _outBufB1$[ebp], edx

; 102  :    short		*outBufB2 = myOutputBuffer_mblk->outBufferB2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _myOutputBuffer_mblk$[ebp]
  00018	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001b	89 4d ec	 mov	 DWORD PTR _outBufB2$[ebp], ecx

; 103  :    short		*outBufB = myOutputBuffer_mblk->outBufferB;

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  00021	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00024	89 45 e4	 mov	 DWORD PTR _outBufB$[ebp], eax

; 104  :    int		dataB = myOutputBuffer_mblk->dataB;

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  0002a	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  0002e	89 55 f8	 mov	 DWORD PTR _dataB$[ebp], edx

; 105  :    short		dataAstart, dataAend;
; 106  :    int      i;
; 107  :    short    *pOutBufB;
; 108  :    float    *pInBuf;
; 109  : 
; 110  :    /* check if buffer B will be overflowed if the current frame is copied to it */
; 111  :    if ((outFrameLEN+dataB) < FRAME_LEN)

  00031	8b 45 0c	 mov	 eax, DWORD PTR _outFrameLEN$[ebp]
  00034	03 45 f8	 add	 eax, DWORD PTR _dataB$[ebp]
  00037	3d b4 00 00 00	 cmp	 eax, 180		; 000000b4H
  0003c	7d 43		 jge	 SHORT $L1299

; 112  :    { 
; 113  :       pOutBufB = outBufB + dataB;

  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _dataB$[ebp]
  00041	8b 55 e4	 mov	 edx, DWORD PTR _outBufB$[ebp]
  00044	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00047	89 45 f0	 mov	 DWORD PTR _pOutBufB$[ebp], eax

; 114  : #ifndef WIN32
; 115  :       for (i=0; i<outFrameLEN; i++)
; 116  :          pOutBufB[i] = (short) InBuf[i];
; 117  : #else
; 118  :       _asm
; 119  :       {
; 120  :          push ecx

  0004a	51		 push	 ecx

; 121  :          push eax

  0004b	50		 push	 eax

; 122  : 
; 123  :          push ebx

  0004c	53		 push	 ebx

; 124  :          mov ecx, outFrameLEN

  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _outFrameLEN$[ebp]

; 125  : 
; 126  :          mov eax, pOutBufB

  00050	8b 45 f0	 mov	 eax, DWORD PTR _pOutBufB$[ebp]

; 127  :          mov ebx, InBuf

  00053	8b 5d 10	 mov	 ebx, DWORD PTR _InBuf$[ebp]
$l1$1300:

; 128  : 
; 129  : l1:      fld dword ptr [ebx]

  00056	d9 03		 fld	 DWORD PTR [ebx]

; 130  :          
; 131  :          fistp word ptr [eax]

  00058	df 18		 fistp	 WORD PTR [eax]

; 132  :          
; 133  :          add eax, 2

  0005a	83 c0 02	 add	 eax, 2

; 134  :          add ebx, 4

  0005d	83 c3 04	 add	 ebx, 4

; 135  :          
; 136  :          dec ecx

  00060	49		 dec	 ecx

; 137  :          
; 138  :          jnz l1

  00061	75 f3		 jne	 SHORT $l1$1300

; 139  :          
; 140  :          pop ebx

  00063	5b		 pop	 ebx

; 141  :          pop eax

  00064	58		 pop	 eax

; 142  : 
; 143  :          pop ecx

  00065	59		 pop	 ecx

; 144  :       }
; 145  : #endif
; 146  :       myOutputBuffer_mblk->dataB = dataB + outFrameLEN;

  00066	8b 4d f8	 mov	 ecx, DWORD PTR _dataB$[ebp]
  00069	03 4d 0c	 add	 ecx, DWORD PTR _outFrameLEN$[ebp]
  0006c	8b 55 fc	 mov	 edx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  0006f	66 89 4a 08	 mov	 WORD PTR [edx+8], cx

; 147  :       myOutputBuffer_mblk->writeBuffer = 0;

  00073	8b 45 fc	 mov	 eax, DWORD PTR _myOutputBuffer_mblk$[ebp]
  00076	66 c7 40 14 00
	00		 mov	 WORD PTR [eax+20], 0

; 148  :    }
; 149  :    else

  0007c	e9 f2 00 00 00	 jmp	 $L1301
$L1299:

; 150  :    {
; 151  :    /* Copy only part of buffer A */
; 152  :       pOutBufB = outBufB + dataB;

  00081	8b 4d f8	 mov	 ecx, DWORD PTR _dataB$[ebp]
  00084	8b 55 e4	 mov	 edx, DWORD PTR _outBufB$[ebp]
  00087	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0008a	89 45 f0	 mov	 DWORD PTR _pOutBufB$[ebp], eax

; 153  : #ifndef WIN32
; 154  :       for (i=0; i<(FRAME_LEN-dataB); i++)
; 155  :          pOutBufB[i] = (short) InBuf[i];
; 156  : #else
; 157  :       _asm
; 158  :       {
; 159  :          push ecx

  0008d	51		 push	 ecx

; 160  :          push eax

  0008e	50		 push	 eax

; 161  : 
; 162  :          push ebx

  0008f	53		 push	 ebx

; 163  :          mov ecx, FRAME_LEN

  00090	b9 b4 00 00 00	 mov	 ecx, 180		; 000000b4H

; 164  : 
; 165  :          mov eax, pOutBufB

  00095	8b 45 f0	 mov	 eax, DWORD PTR _pOutBufB$[ebp]

; 166  :          sub ecx, dataB

  00098	2b 4d f8	 sub	 ecx, DWORD PTR _dataB$[ebp]

; 167  : 
; 168  :          mov ebx, InBuf

  0009b	8b 5d 10	 mov	 ebx, DWORD PTR _InBuf$[ebp]

; 169  :          jle l2

  0009e	7e 0d		 jle	 SHORT $l2$1302
$l3$1303:

; 170  : 
; 171  : l3:      fld dword ptr [ebx]

  000a0	d9 03		 fld	 DWORD PTR [ebx]

; 172  :          
; 173  :          fistp word ptr [eax]

  000a2	df 18		 fistp	 WORD PTR [eax]

; 174  :          
; 175  :          add eax, 2

  000a4	83 c0 02	 add	 eax, 2

; 176  :          add ebx, 4

  000a7	83 c3 04	 add	 ebx, 4

; 177  :          
; 178  :          dec ecx

  000aa	49		 dec	 ecx

; 179  :          jnz l3

  000ab	75 f3		 jne	 SHORT $l3$1303
$l2$1302:

; 180  :          
; 181  : l2:      pop ebx

  000ad	5b		 pop	 ebx

; 182  :          pop eax

  000ae	58		 pop	 eax

; 183  : 
; 184  :          pop ecx

  000af	59		 pop	 ecx

; 185  :       }
; 186  : 
; 187  : #endif
; 188  : 
; 189  :       dataAstart = FRAME_LEN-dataB;

  000b0	b9 b4 00 00 00	 mov	 ecx, 180		; 000000b4H
  000b5	2b 4d f8	 sub	 ecx, DWORD PTR _dataB$[ebp]
  000b8	66 89 4d dc	 mov	 WORD PTR _dataAstart$[ebp], cx

; 190  :       dataAend = (short) outFrameLEN;    

  000bc	66 8b 55 0c	 mov	 dx, WORD PTR _outFrameLEN$[ebp]
  000c0	66 89 55 d8	 mov	 WORD PTR _dataAend$[ebp], dx

; 191  : 
; 192  :    /* switch data buffers */
; 193  :       if (outBufB==outBufB1)

  000c4	8b 45 e4	 mov	 eax, DWORD PTR _outBufB$[ebp]
  000c7	3b 45 e0	 cmp	 eax, DWORD PTR _outBufB1$[ebp]
  000ca	75 1a		 jne	 SHORT $L1305

; 194  :       {
; 195  :          outBufB = myOutputBuffer_mblk->outBufferB = outBufB2;

  000cc	8b 4d fc	 mov	 ecx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  000cf	8b 55 ec	 mov	 edx, DWORD PTR _outBufB2$[ebp]
  000d2	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  000d5	8b 45 ec	 mov	 eax, DWORD PTR _outBufB2$[ebp]
  000d8	89 45 e4	 mov	 DWORD PTR _outBufB$[ebp], eax

; 196  :          myOutputBuffer_mblk->writeBuffer = 1;

  000db	8b 4d fc	 mov	 ecx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  000de	66 c7 41 14 01
	00		 mov	 WORD PTR [ecx+20], 1

; 197  :       }
; 198  :       else if (outBufB==outBufB2)

  000e4	eb 28		 jmp	 SHORT $L1306
$L1305:
  000e6	8b 55 e4	 mov	 edx, DWORD PTR _outBufB$[ebp]
  000e9	3b 55 ec	 cmp	 edx, DWORD PTR _outBufB2$[ebp]
  000ec	75 1a		 jne	 SHORT $L1307

; 199  :       {
; 200  :          outBufB = myOutputBuffer_mblk->outBufferB = outBufB1;

  000ee	8b 45 fc	 mov	 eax, DWORD PTR _myOutputBuffer_mblk$[ebp]
  000f1	8b 4d e0	 mov	 ecx, DWORD PTR _outBufB1$[ebp]
  000f4	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  000f7	8b 55 e0	 mov	 edx, DWORD PTR _outBufB1$[ebp]
  000fa	89 55 e4	 mov	 DWORD PTR _outBufB$[ebp], edx

; 201  :          myOutputBuffer_mblk->writeBuffer = 2;

  000fd	8b 45 fc	 mov	 eax, DWORD PTR _myOutputBuffer_mblk$[ebp]
  00100	66 c7 40 14 02
	00		 mov	 WORD PTR [eax+20], 2

; 202  :       }
; 203  :       else {

  00106	eb 06		 jmp	 SHORT $L1306
$L1307:

; 204  :          return 1;

  00108	66 b8 01 00	 mov	 ax, 1
  0010c	eb 68		 jmp	 SHORT $L1287
$L1306:

; 205  :       }
; 206  : 
; 207  :    /* Copy remaining part of buffer A to start of new Buffer B */
; 208  :       if (dataAstart < FRAME_LEN)

  0010e	0f bf 4d dc	 movsx	 ecx, WORD PTR _dataAstart$[ebp]
  00112	81 f9 b4 00 00
	00		 cmp	 ecx, 180		; 000000b4H
  00118	7d 48		 jge	 SHORT $L1309

; 209  :       {
; 210  :          pInBuf = InBuf + dataAstart;

  0011a	0f bf 55 dc	 movsx	 edx, WORD PTR _dataAstart$[ebp]
  0011e	8b 45 10	 mov	 eax, DWORD PTR _InBuf$[ebp]
  00121	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00124	89 4d e8	 mov	 DWORD PTR _pInBuf$[ebp], ecx

; 211  :          for (i=0; i<(dataAend-dataAstart); i++)

  00127	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0012e	eb 09		 jmp	 SHORT $L1310
$L1311:
  00130	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00133	83 c2 01	 add	 edx, 1
  00136	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
$L1310:
  00139	0f bf 45 d8	 movsx	 eax, WORD PTR _dataAend$[ebp]
  0013d	0f bf 4d dc	 movsx	 ecx, WORD PTR _dataAstart$[ebp]
  00141	2b c1		 sub	 eax, ecx
  00143	39 45 f4	 cmp	 DWORD PTR _i$[ebp], eax
  00146	7d 1a		 jge	 SHORT $L1309

; 212  :          {
; 213  :             outBufB[i] = (short) pInBuf[i];

  00148	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0014b	8b 45 e8	 mov	 eax, DWORD PTR _pInBuf$[ebp]
  0014e	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  00151	e8 00 00 00 00	 call	 __ftol2
  00156	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00159	8b 55 e4	 mov	 edx, DWORD PTR _outBufB$[ebp]
  0015c	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 214  :          }

  00160	eb ce		 jmp	 SHORT $L1311
$L1309:

; 215  :       }
; 216  :       myOutputBuffer_mblk->dataB = dataAend-dataAstart;

  00162	0f bf 45 d8	 movsx	 eax, WORD PTR _dataAend$[ebp]
  00166	0f bf 4d dc	 movsx	 ecx, WORD PTR _dataAstart$[ebp]
  0016a	2b c1		 sub	 eax, ecx
  0016c	8b 55 fc	 mov	 edx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  0016f	66 89 42 08	 mov	 WORD PTR [edx+8], ax
$L1301:

; 217  :    } 
; 218  :     
; 219  :    return 0; 

  00173	66 33 c0	 xor	 ax, ax
$L1287:

; 220  : }

  00176	5b		 pop	 ebx
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c2 0c 00	 ret	 12			; 0000000cH
_VoxOutputManager@12 ENDP
_TEXT	ENDS
PUBLIC	_VoxInitOutputBuffers@4
EXTRN	_calloc:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxInitOutputBuffers@4
_TEXT	SEGMENT
_myOutputBuffer_mblk$ = -4
_OutputBuffer_mblk$ = 8
_VoxInitOutputBuffers@4 PROC NEAR			; COMDAT

; 246  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 247  :    OutputBuffer *myOutputBuffer_mblk;
; 248  : 
; 249  :    if(VOX_MEM_INIT(myOutputBuffer_mblk=*OutputBuffer_mblk,1,sizeof(OutputBuffer))) 

  00004	6a 18		 push	 24			; 00000018H
  00006	6a 01		 push	 1
  00008	e8 00 00 00 00	 call	 _calloc
  0000d	83 c4 08	 add	 esp, 8
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _OutputBuffer_mblk$[ebp]
  00013	89 01		 mov	 DWORD PTR [ecx], eax
  00015	8b 55 08	 mov	 edx, DWORD PTR _OutputBuffer_mblk$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	89 45 fc	 mov	 DWORD PTR _myOutputBuffer_mblk$[ebp], eax
  0001d	83 7d fc 00	 cmp	 DWORD PTR _myOutputBuffer_mblk$[ebp], 0
  00021	75 06		 jne	 SHORT $L1319

; 250  :       return 1;

  00023	66 b8 01 00	 mov	 ax, 1
  00027	eb 54		 jmp	 SHORT $L1316
$L1319:

; 251  : 
; 252  :    if(VOX_MEM_INIT(myOutputBuffer_mblk->outBufferB1,FRAME_LEN,sizeof(short))) 

  00029	6a 02		 push	 2
  0002b	68 b4 00 00 00	 push	 180			; 000000b4H
  00030	e8 00 00 00 00	 call	 _calloc
  00035	83 c4 08	 add	 esp, 8
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  0003b	89 01		 mov	 DWORD PTR [ecx], eax
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  00040	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00043	75 06		 jne	 SHORT $L1321

; 253  :       return 1;

  00045	66 b8 01 00	 mov	 ax, 1
  00049	eb 32		 jmp	 SHORT $L1316
$L1321:

; 254  : 
; 255  :    if(VOX_MEM_INIT(myOutputBuffer_mblk->outBufferB2,FRAME_LEN,sizeof(short))) 

  0004b	6a 02		 push	 2
  0004d	68 b4 00 00 00	 push	 180			; 000000b4H
  00052	e8 00 00 00 00	 call	 _calloc
  00057	83 c4 08	 add	 esp, 8
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  0005d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00060	8b 55 fc	 mov	 edx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  00063	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00067	75 06		 jne	 SHORT $L1323

; 256  :       return 1;

  00069	66 b8 01 00	 mov	 ax, 1
  0006d	eb 0e		 jmp	 SHORT $L1316
$L1323:

; 257  : 
; 258  :    myOutputBuffer_mblk->outBufferB = myOutputBuffer_mblk->outBufferB1;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _myOutputBuffer_mblk$[ebp]
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  00075	8b 11		 mov	 edx, DWORD PTR [ecx]
  00077	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 259  : 
; 260  :    return 0;

  0007a	66 33 c0	 xor	 ax, ax
$L1316:

; 261  : }

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
_VoxInitOutputBuffers@4 ENDP
_TEXT	ENDS
PUBLIC	_VoxFreeOutputBuffers@4
EXTRN	_free:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxFreeOutputBuffers@4
_TEXT	SEGMENT
_myOutputBuffer_mblk$ = -4
_OutputBuffer_mblk$ = 8
_VoxFreeOutputBuffers@4 PROC NEAR			; COMDAT

; 287  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 288  :    OutputBuffer *myOutputBuffer_mblk=(OutputBuffer *)*OutputBuffer_mblk;

  00004	8b 45 08	 mov	 eax, DWORD PTR _OutputBuffer_mblk$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _myOutputBuffer_mblk$[ebp], ecx

; 289  : 
; 290  :    if(*OutputBuffer_mblk) {

  0000c	8b 55 08	 mov	 edx, DWORD PTR _OutputBuffer_mblk$[ebp]
  0000f	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00012	74 60		 je	 SHORT $L1329

; 291  :       VOX_MEM_FREE(myOutputBuffer_mblk->outBufferB1);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _myOutputBuffer_mblk$[ebp]
  00017	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001a	74 17		 je	 SHORT $L1330
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 _free
  00027	83 c4 04	 add	 esp, 4
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _myOutputBuffer_mblk$[ebp]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L1330:

; 292  :       VOX_MEM_FREE(myOutputBuffer_mblk->outBufferB2);

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  00036	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0003a	74 19		 je	 SHORT $L1332
  0003c	8b 55 fc	 mov	 edx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  0003f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _free
  00048	83 c4 04	 add	 esp, 4
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _myOutputBuffer_mblk$[ebp]
  0004e	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$L1332:

; 293  : 
; 294  :       VOX_MEM_FREE(*OutputBuffer_mblk);

  00055	8b 55 08	 mov	 edx, DWORD PTR _OutputBuffer_mblk$[ebp]
  00058	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0005b	74 17		 je	 SHORT $L1329
  0005d	8b 45 08	 mov	 eax, DWORD PTR _OutputBuffer_mblk$[ebp]
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _free
  00068	83 c4 04	 add	 esp, 4
  0006b	8b 55 08	 mov	 edx, DWORD PTR _OutputBuffer_mblk$[ebp]
  0006e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L1329:

; 295  :    }
; 296  :    return 0;

  00074	66 33 c0	 xor	 ax, ax

; 297  : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_VoxFreeOutputBuffers@4 ENDP
_TEXT	ENDS
END
