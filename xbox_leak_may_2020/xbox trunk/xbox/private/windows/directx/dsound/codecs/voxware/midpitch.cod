; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\midpitch.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _MidEstPitch@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TDPitchRefine@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_MidEstPitch@16
PUBLIC	__real@3fa00000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f000000
PUBLIC	__real@41f00000
PUBLIC	__real@3f800000
EXTRN	__fltused:NEAR
;	COMDAT __real@3fa00000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\midpitch.c
CONST	SEGMENT
__real@3fa00000 DD 03fa00000r			; 1.25
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _MidEstPitch@16
_TEXT	SEGMENT
_pitch$ = -8
_Pv$ = -4
_Pitchm1$ = 8
_Pitchp1$ = 12
_Pvm1$ = 16
_Pvp1$ = 20
_MidEstPitch@16 PROC NEAR				; COMDAT

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 44   :   float pitch, Pv;
; 45   : 
; 46   :   /*----------------------------------------------------------------------------
; 47   :     Determine the initial pitch value at the middle frame from pitch values 
; 48   :     and voicing probability values at k-1 and k+1 frames.
; 49   :     ----------------------------------------------------------------------------*/
; 50   :   if( (Pitchp1 <= 1.25F*Pitchm1)  && (Pitchp1 >= Pitchm1*0.8F))

  00006	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3fa00000
  0000c	d8 4d 08	 fmul	 DWORD PTR _Pitchm1$[ebp]
  0000f	d8 5d 0c	 fcomp	 DWORD PTR _Pitchp1$[ebp]
  00012	df e0		 fnstsw	 ax
  00014	f6 c4 01	 test	 ah, 1
  00017	75 24		 jne	 SHORT $L1355
  00019	d9 45 08	 fld	 DWORD PTR _Pitchm1$[ebp]
  0001c	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f4ccccd
  00022	d8 5d 0c	 fcomp	 DWORD PTR _Pitchp1$[ebp]
  00025	df e0		 fnstsw	 ax
  00027	f6 c4 41	 test	 ah, 65			; 00000041H
  0002a	7a 11		 jp	 SHORT $L1355

; 51   :     pitch = (Pitchm1 + Pitchp1) *0.5F;

  0002c	d9 45 08	 fld	 DWORD PTR _Pitchm1$[ebp]
  0002f	d8 45 0c	 fadd	 DWORD PTR _Pitchp1$[ebp]
  00032	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00038	d9 5d f8	 fstp	 DWORD PTR _pitch$[ebp]

; 52   :   else 

  0003b	eb 6b		 jmp	 SHORT $L1356
$L1355:

; 53   :     {
; 54   :       if(Pvm1>Pvp1) {       /* prevent quantization rounding error */

  0003d	d9 45 10	 fld	 DWORD PTR _Pvm1$[ebp]
  00040	d8 5d 14	 fcomp	 DWORD PTR _Pvp1$[ebp]
  00043	df e0		 fnstsw	 ax
  00045	f6 c4 41	 test	 ah, 65			; 00000041H
  00048	75 0e		 jne	 SHORT $L1357

; 55   :         pitch=Pitchm1;

  0004a	8b 45 08	 mov	 eax, DWORD PTR _Pitchm1$[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR _pitch$[ebp], eax

; 56   :         Pv = Pvm1;

  00050	8b 4d 10	 mov	 ecx, DWORD PTR _Pvm1$[ebp]
  00053	89 4d fc	 mov	 DWORD PTR _Pv$[ebp], ecx

; 57   :       }
; 58   :       else {

  00056	eb 0c		 jmp	 SHORT $L1358
$L1357:

; 59   :         pitch=Pitchp1;

  00058	8b 55 0c	 mov	 edx, DWORD PTR _Pitchp1$[ebp]
  0005b	89 55 f8	 mov	 DWORD PTR _pitch$[ebp], edx

; 60   :         Pv = Pvp1;

  0005e	8b 45 14	 mov	 eax, DWORD PTR _Pvp1$[ebp]
  00061	89 45 fc	 mov	 DWORD PTR _Pv$[ebp], eax
$L1358:

; 61   :       }
; 62   : 
; 63   :       if (pitch < 30 && (Pv*pitch*0.5F) < 1.0F)   /* to prevent pulsive sound */

  00064	d9 45 f8	 fld	 DWORD PTR _pitch$[ebp]
  00067	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41f00000
  0006d	df e0		 fnstsw	 ax
  0006f	f6 c4 05	 test	 ah, 5
  00072	7a 34		 jp	 SHORT $L1356
  00074	d9 45 fc	 fld	 DWORD PTR _Pv$[ebp]
  00077	d8 4d f8	 fmul	 DWORD PTR _pitch$[ebp]
  0007a	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00080	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f800000
  00086	df e0		 fnstsw	 ax
  00088	f6 c4 05	 test	 ah, 5
  0008b	7a 1b		 jp	 SHORT $L1356

; 64   :         {
; 65   :          if (Pitchp1 > Pitchm1)

  0008d	d9 45 0c	 fld	 DWORD PTR _Pitchp1$[ebp]
  00090	d8 5d 08	 fcomp	 DWORD PTR _Pitchm1$[ebp]
  00093	df e0		 fnstsw	 ax
  00095	f6 c4 41	 test	 ah, 65			; 00000041H
  00098	75 08		 jne	 SHORT $L1360

; 66   :             pitch = Pitchp1;

  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR _Pitchp1$[ebp]
  0009d	89 4d f8	 mov	 DWORD PTR _pitch$[ebp], ecx

; 67   :          else

  000a0	eb 06		 jmp	 SHORT $L1356
$L1360:

; 68   :             pitch = Pitchm1;

  000a2	8b 55 08	 mov	 edx, DWORD PTR _Pitchm1$[ebp]
  000a5	89 55 f8	 mov	 DWORD PTR _pitch$[ebp], edx
$L1356:

; 69   :         }
; 70   :     }
; 71   : 
; 72   :   return pitch;

  000a8	d9 45 f8	 fld	 DWORD PTR _pitch$[ebp]

; 73   : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 10 00	 ret	 16			; 00000010H
_MidEstPitch@16 ENDP
_TEXT	ENDS
PUBLIC	_TDPitchRefine@20
PUBLIC	__real@358637bd
EXTRN	_DotProd@12:NEAR
EXTRN	_QuadraticPeak@16:NEAR
EXTRN	_sqrt:NEAR
;	COMDAT __real@358637bd
CONST	SEGMENT
__real@358637bd DD 0358637bdr			; 1e-006
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _TDPitchRefine@20
_TEXT	SEGMENT
tv201 = -72
tv189 = -68
_Left_lag$ = -64
_refine_pitch$ = -60
_ftmp$ = -56
_delta$ = -52
_eng1$ = -48
_maxCorr$ = -44
_Right_lag$ = -40
_bestI$ = -36
_totalCorr$ = -32
_bestLag$ = -28
_jlag$ = -24
_i$ = -20
_pCorrCosts$ = -16
_eng2$ = -4
_Spbuf$ = 8
_length$ = 12
_pitch$ = 16
_maxCost$ = 20
_deltaP0$ = 24
_TDPitchRefine@20 PROC NEAR				; COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H

; 81   :   int delta;
; 82   :   int Left_lag, Right_lag;
; 83   :   float maxCorr;
; 84   :   float refine_pitch;
; 85   :   int bestLag, bestI;
; 86   :   int jlag, i;
; 87   :   float totalCorr;
; 88   :   float pCorrCosts[3];
; 89   :   float eng1, eng2;
; 90   :   float ftmp;
; 91   : 
; 92   :   /*------------------------------------------------------------
; 93   :     Find out the pitch searching range.
; 94   :     ------------------------------------------------------------*/
; 95   :   ftmp = deltaP0*pitch;

  00006	d9 45 18	 fld	 DWORD PTR _deltaP0$[ebp]
  00009	d8 4d 10	 fmul	 DWORD PTR _pitch$[ebp]
  0000c	d9 5d c8	 fstp	 DWORD PTR _ftmp$[ebp]

; 96   :   VoxROUND2pos(ftmp, delta);

  0000f	d9 45 c8	 fld	 DWORD PTR _ftmp$[ebp]
  00012	db 5d cc	 fistp	 DWORD PTR _delta$[ebp]

; 97   :   if (delta > MAX_DELTA)

  00015	83 7d cc 04	 cmp	 DWORD PTR _delta$[ebp], 4
  00019	7e 07		 jle	 SHORT $L1387

; 98   :     delta = MAX_DELTA;

  0001b	c7 45 cc 04 00
	00 00		 mov	 DWORD PTR _delta$[ebp], 4
$L1387:

; 99   :   
; 100  :   ftmp = pitch-delta;

  00022	db 45 cc	 fild	 DWORD PTR _delta$[ebp]
  00025	d8 6d 10	 fsubr	 DWORD PTR _pitch$[ebp]
  00028	d9 5d c8	 fstp	 DWORD PTR _ftmp$[ebp]

; 101  :   VoxROUND2pos(ftmp, Left_lag);

  0002b	d9 45 c8	 fld	 DWORD PTR _ftmp$[ebp]
  0002e	db 5d c0	 fistp	 DWORD PTR _Left_lag$[ebp]

; 102  : 
; 103  :   ftmp = pitch+delta;

  00031	db 45 cc	 fild	 DWORD PTR _delta$[ebp]
  00034	d8 45 10	 fadd	 DWORD PTR _pitch$[ebp]
  00037	d9 5d c8	 fstp	 DWORD PTR _ftmp$[ebp]

; 104  :   VoxROUND2pos(ftmp, Right_lag);

  0003a	d9 45 c8	 fld	 DWORD PTR _ftmp$[ebp]
  0003d	db 5d d8	 fistp	 DWORD PTR _Right_lag$[ebp]

; 105  : 
; 106  :   if (Left_lag < MIN_PITCH)

  00040	83 7d c0 08	 cmp	 DWORD PTR _Left_lag$[ebp], 8
  00044	7d 07		 jge	 SHORT $L1388

; 107  :   Left_lag = MIN_PITCH;

  00046	c7 45 c0 08 00
	00 00		 mov	 DWORD PTR _Left_lag$[ebp], 8
$L1388:

; 108  :     
; 109  :   if (Right_lag > MAX_PITCH)

  0004d	81 7d d8 a0 00
	00 00		 cmp	 DWORD PTR _Right_lag$[ebp], 160 ; 000000a0H
  00054	7e 07		 jle	 SHORT $L1389

; 110  :   Right_lag = MAX_PITCH;

  00056	c7 45 d8 a0 00
	00 00		 mov	 DWORD PTR _Right_lag$[ebp], 160 ; 000000a0H
$L1389:

; 111  : 
; 112  : 
; 113  :   /*--------------------------------------------------
; 114  :     calculate the autocorrelation function.
; 115  :     --------------------------------------------------*/
; 116  :   jlag = Left_lag;

  0005d	8b 45 c0	 mov	 eax, DWORD PTR _Left_lag$[ebp]
  00060	89 45 e8	 mov	 DWORD PTR _jlag$[ebp], eax

; 117  :   maxCorr = -MAXFLT;

  00063	c7 45 d4 ff ff
	7f ff		 mov	 DWORD PTR _maxCorr$[ebp], -8388609 ; ff7fffffH

; 118  :   bestI = 0;

  0006a	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _bestI$[ebp], 0

; 119  :   pCorrCosts[0] = pCorrCosts[1] = pCorrCosts[2] = 0.0F;

  00071	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pCorrCosts$[ebp+8], 0
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _pCorrCosts$[ebp+8]
  0007b	89 4d f4	 mov	 DWORD PTR _pCorrCosts$[ebp+4], ecx
  0007e	8b 55 f4	 mov	 edx, DWORD PTR _pCorrCosts$[ebp+4]
  00081	89 55 f0	 mov	 DWORD PTR _pCorrCosts$[ebp], edx

; 120  :   i=0;

  00084	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$L1390:

; 121  :   do {
; 122  :     totalCorr = DotProd(Spbuf, Spbuf+jlag, length-jlag);

  0008b	0f bf 45 0c	 movsx	 eax, WORD PTR _length$[ebp]
  0008f	2b 45 e8	 sub	 eax, DWORD PTR _jlag$[ebp]
  00092	50		 push	 eax
  00093	8b 4d e8	 mov	 ecx, DWORD PTR _jlag$[ebp]
  00096	8b 55 08	 mov	 edx, DWORD PTR _Spbuf$[ebp]
  00099	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0009c	50		 push	 eax
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _Spbuf$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _DotProd@12
  000a6	d9 55 e0	 fst	 DWORD PTR _totalCorr$[ebp]

; 123  :     if (totalCorr > maxCorr) {

  000a9	d8 5d d4	 fcomp	 DWORD PTR _maxCorr$[ebp]
  000ac	df e0		 fnstsw	 ax
  000ae	f6 c4 41	 test	 ah, 65			; 00000041H
  000b1	75 14		 jne	 SHORT $L1393

; 124  :       maxCorr = totalCorr;

  000b3	8b 55 e0	 mov	 edx, DWORD PTR _totalCorr$[ebp]
  000b6	89 55 d4	 mov	 DWORD PTR _maxCorr$[ebp], edx

; 125  :       bestI = i;

  000b9	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000bc	89 45 dc	 mov	 DWORD PTR _bestI$[ebp], eax

; 126  :       pCorrCosts[0] = pCorrCosts[1];

  000bf	8b 4d f4	 mov	 ecx, DWORD PTR _pCorrCosts$[ebp+4]
  000c2	89 4d f0	 mov	 DWORD PTR _pCorrCosts$[ebp], ecx

; 127  :     }
; 128  :     else {

  000c5	eb 11		 jmp	 SHORT $L1394
$L1393:

; 129  :       if (bestI == (i-1)) {

  000c7	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  000ca	83 ea 01	 sub	 edx, 1
  000cd	39 55 dc	 cmp	 DWORD PTR _bestI$[ebp], edx
  000d0	75 06		 jne	 SHORT $L1394

; 130  :         pCorrCosts[2] = totalCorr;

  000d2	8b 45 e0	 mov	 eax, DWORD PTR _totalCorr$[ebp]
  000d5	89 45 f8	 mov	 DWORD PTR _pCorrCosts$[ebp+8], eax
$L1394:

; 131  :       }
; 132  :     }
; 133  : 
; 134  :     pCorrCosts[1] = totalCorr;

  000d8	8b 4d e0	 mov	 ecx, DWORD PTR _totalCorr$[ebp]
  000db	89 4d f4	 mov	 DWORD PTR _pCorrCosts$[ebp+4], ecx

; 135  : 
; 136  :     i++;

  000de	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  000e1	83 c2 01	 add	 edx, 1
  000e4	89 55 ec	 mov	 DWORD PTR _i$[ebp], edx

; 137  :     jlag++;

  000e7	8b 45 e8	 mov	 eax, DWORD PTR _jlag$[ebp]
  000ea	83 c0 01	 add	 eax, 1
  000ed	89 45 e8	 mov	 DWORD PTR _jlag$[ebp], eax

; 138  :   } while (jlag <= Right_lag);

  000f0	8b 4d e8	 mov	 ecx, DWORD PTR _jlag$[ebp]
  000f3	3b 4d d8	 cmp	 ecx, DWORD PTR _Right_lag$[ebp]
  000f6	7e 93		 jle	 SHORT $L1390

; 139  :   
; 140  : 
; 141  :   /*-------------------------------------------------------
; 142  :     use quadratic interpolation to get refined pitch.
; 143  :     -------------------------------------------------------*/
; 144  :   bestLag = bestI+Left_lag;

  000f8	8b 55 dc	 mov	 edx, DWORD PTR _bestI$[ebp]
  000fb	03 55 c0	 add	 edx, DWORD PTR _Left_lag$[ebp]
  000fe	89 55 e4	 mov	 DWORD PTR _bestLag$[ebp], edx

; 145  : 
; 146  :   if ((bestLag > Left_lag) && (bestLag < Right_lag)) 

  00101	8b 45 e4	 mov	 eax, DWORD PTR _bestLag$[ebp]
  00104	3b 45 c0	 cmp	 eax, DWORD PTR _Left_lag$[ebp]
  00107	7e 2b		 jle	 SHORT $L1396
  00109	8b 4d e4	 mov	 ecx, DWORD PTR _bestLag$[ebp]
  0010c	3b 4d d8	 cmp	 ecx, DWORD PTR _Right_lag$[ebp]
  0010f	7d 23		 jge	 SHORT $L1396

; 147  :     refine_pitch = (float)bestLag + QuadraticPeak(pCorrCosts[0], maxCorr, 
; 148  :                              pCorrCosts[2], maxCost);

  00111	db 45 e4	 fild	 DWORD PTR _bestLag$[ebp]
  00114	d9 5d bc	 fstp	 DWORD PTR tv189[ebp]
  00117	8b 55 14	 mov	 edx, DWORD PTR _maxCost$[ebp]
  0011a	52		 push	 edx
  0011b	8b 45 f8	 mov	 eax, DWORD PTR _pCorrCosts$[ebp+8]
  0011e	50		 push	 eax
  0011f	8b 4d d4	 mov	 ecx, DWORD PTR _maxCorr$[ebp]
  00122	51		 push	 ecx
  00123	8b 55 f0	 mov	 edx, DWORD PTR _pCorrCosts$[ebp]
  00126	52		 push	 edx
  00127	e8 00 00 00 00	 call	 _QuadraticPeak@16
  0012c	d8 45 bc	 fadd	 DWORD PTR tv189[ebp]
  0012f	d9 5d c4	 fstp	 DWORD PTR _refine_pitch$[ebp]

; 149  :   else {

  00132	eb 0e		 jmp	 SHORT $L1398
$L1396:

; 150  :     refine_pitch = (float)bestLag;

  00134	db 45 e4	 fild	 DWORD PTR _bestLag$[ebp]
  00137	d9 5d c4	 fstp	 DWORD PTR _refine_pitch$[ebp]

; 151  :     *maxCost = maxCorr;

  0013a	8b 45 14	 mov	 eax, DWORD PTR _maxCost$[ebp]
  0013d	8b 4d d4	 mov	 ecx, DWORD PTR _maxCorr$[ebp]
  00140	89 08		 mov	 DWORD PTR [eax], ecx
$L1398:

; 152  :   }
; 153  :      
; 154  :   /*------------------------------------------------------------
; 155  :     now normalized the cost value.
; 156  :     ------------------------------------------------------------*/
; 157  :   /* calculate energy of psigBuf[0:win_length-bestLag-1] and psigBuf[bestLag:win_length-1] */
; 158  :   eng1 = DotProd(Spbuf, Spbuf, length-bestLag);

  00142	0f bf 55 0c	 movsx	 edx, WORD PTR _length$[ebp]
  00146	2b 55 e4	 sub	 edx, DWORD PTR _bestLag$[ebp]
  00149	52		 push	 edx
  0014a	8b 45 08	 mov	 eax, DWORD PTR _Spbuf$[ebp]
  0014d	50		 push	 eax
  0014e	8b 4d 08	 mov	 ecx, DWORD PTR _Spbuf$[ebp]
  00151	51		 push	 ecx
  00152	e8 00 00 00 00	 call	 _DotProd@12
  00157	d9 5d d0	 fstp	 DWORD PTR _eng1$[ebp]

; 159  :   eng2 = DotProd(Spbuf+bestLag, Spbuf+bestLag, length-bestLag);

  0015a	0f bf 55 0c	 movsx	 edx, WORD PTR _length$[ebp]
  0015e	2b 55 e4	 sub	 edx, DWORD PTR _bestLag$[ebp]
  00161	52		 push	 edx
  00162	8b 45 e4	 mov	 eax, DWORD PTR _bestLag$[ebp]
  00165	8b 4d 08	 mov	 ecx, DWORD PTR _Spbuf$[ebp]
  00168	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0016b	52		 push	 edx
  0016c	8b 45 e4	 mov	 eax, DWORD PTR _bestLag$[ebp]
  0016f	8b 4d 08	 mov	 ecx, DWORD PTR _Spbuf$[ebp]
  00172	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00175	52		 push	 edx
  00176	e8 00 00 00 00	 call	 _DotProd@12
  0017b	d9 5d fc	 fstp	 DWORD PTR _eng2$[ebp]

; 160  : 
; 161  :   *maxCost /= ((float)sqrt(eng1*eng2+MINCON));

  0017e	d9 45 d0	 fld	 DWORD PTR _eng1$[ebp]
  00181	d8 4d fc	 fmul	 DWORD PTR _eng2$[ebp]
  00184	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@358637bd
  0018a	83 ec 08	 sub	 esp, 8
  0018d	dd 1c 24	 fstp	 QWORD PTR [esp]
  00190	e8 00 00 00 00	 call	 _sqrt
  00195	83 c4 08	 add	 esp, 8
  00198	d9 55 b8	 fst	 DWORD PTR tv201[ebp]
  0019b	8b 45 14	 mov	 eax, DWORD PTR _maxCost$[ebp]
  0019e	d8 38		 fdivr	 DWORD PTR [eax]
  001a0	8b 4d 14	 mov	 ecx, DWORD PTR _maxCost$[ebp]
  001a3	d9 19		 fstp	 DWORD PTR [ecx]

; 162  : 
; 163  :  
; 164  :   return refine_pitch;

  001a5	d9 45 c4	 fld	 DWORD PTR _refine_pitch$[ebp]

; 165  : }

  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c2 14 00	 ret	 20			; 00000014H
_TDPitchRefine@20 ENDP
_TEXT	ENDS
END
