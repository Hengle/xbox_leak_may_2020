; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\estonset.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _EstOnset@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxInitEstOnset@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxFreeEstOnset@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_EstOnset@20
PUBLIC	__real@3cfe0000
PUBLIC	__real@3f781000
PUBLIC	__real@3c4ccccd
EXTRN	_GetFrameSpCBM@16:NEAR
EXTRN	__fltused:NEAR
EXTRN	_fabs:NEAR
;	COMDAT __real@3cfe0000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\estonset.c
CONST	SEGMENT
__real@3cfe0000 DD 03cfe0000r			; 0.0310059
CONST	ENDS
;	COMDAT __real@3f781000
CONST	SEGMENT
__real@3f781000 DD 03f781000r			; 0.968994
CONST	ENDS
;	COMDAT __real@3c4ccccd
CONST	SEGMENT
__real@3c4ccccd DD 03c4ccccdr			; 0.0125
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _EstOnset@20
_TEXT	SEGMENT
tv275 = -88
tv271 = -84
tv268 = -80
_psaveAC1$ = -76
_ftmp$ = -72
_t0$ = -68
_union_t0$ = -64
_AC0$ = -60
_maxT0$ = -56
_t1$ = -52
_psaveAC0$ = -48
_k$ = -44
_maxT1$ = -40
_pOnsetMblk$ = -36
_OnsetK$ = -32
_WinShift$ = -28
_ptr0$ = -24
_AC1$ = -20
_sumAC0$ = -16
_sumAC1$ = -12
_union_t1$ = -8
_OnsetDur$ = -4
_hOnsetMblk$ = 8
_pCircBufMblk$ = 12
_codec_delay_size$ = 16
_winLength$ = 20
_SpBuf$ = 24
_EstOnset@20 PROC NEAR					; COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H

; 69   :   ONSET_Mblk *pOnsetMblk = (ONSET_Mblk *)hOnsetMblk;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hOnsetMblk$[ebp]
  00009	89 45 dc	 mov	 DWORD PTR _pOnsetMblk$[ebp], eax

; 70   :   int OnsetK=0, OnsetDur = pOnsetMblk->Onset_1+MIN_ONSET_DIFF-FRAME_LENGTH_SC;

  0000c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _OnsetK$[ebp], 0
  00013	8b 4d dc	 mov	 ecx, DWORD PTR _pOnsetMblk$[ebp]
  00016	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00019	81 ea 96 00 00
	00		 sub	 edx, 150		; 00000096H
  0001f	89 55 fc	 mov	 DWORD PTR _OnsetDur$[ebp], edx

; 71   : 
; 72   :   float *psaveAC0 = pOnsetMblk->saveAC0;

  00022	8b 45 dc	 mov	 eax, DWORD PTR _pOnsetMblk$[ebp]
  00025	89 45 d0	 mov	 DWORD PTR _psaveAC0$[ebp], eax

; 73   :   float *psaveAC1 = pOnsetMblk->saveAC1;

  00028	8b 4d dc	 mov	 ecx, DWORD PTR _pOnsetMblk$[ebp]
  0002b	83 c1 10	 add	 ecx, 16			; 00000010H
  0002e	89 4d b4	 mov	 DWORD PTR _psaveAC1$[ebp], ecx

; 74   : 
; 75   :   int ptr0 = pOnsetMblk->ptr0;     /**** the pointer for the buffer ****/

  00031	8b 55 dc	 mov	 edx, DWORD PTR _pOnsetMblk$[ebp]
  00034	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00037	89 45 e8	 mov	 DWORD PTR _ptr0$[ebp], eax

; 76   : 
; 77   :   float AC0 = psaveAC0[ptr0];    /**** point to the previous sample ****/

  0003a	8b 4d e8	 mov	 ecx, DWORD PTR _ptr0$[ebp]
  0003d	8b 55 d0	 mov	 edx, DWORD PTR _psaveAC0$[ebp]
  00040	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00043	89 45 c4	 mov	 DWORD PTR _AC0$[ebp], eax

; 78   :   float AC1 = psaveAC1[ptr0];

  00046	8b 4d e8	 mov	 ecx, DWORD PTR _ptr0$[ebp]
  00049	8b 55 b4	 mov	 edx, DWORD PTR _psaveAC1$[ebp]
  0004c	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0004f	89 45 ec	 mov	 DWORD PTR _AC1$[ebp], eax

; 79   : 
; 80   :   float sumAC0 = pOnsetMblk->sumAC0;

  00052	8b 4d dc	 mov	 ecx, DWORD PTR _pOnsetMblk$[ebp]
  00055	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00058	89 55 f0	 mov	 DWORD PTR _sumAC0$[ebp], edx

; 81   :   float sumAC1 = pOnsetMblk->sumAC1;

  0005b	8b 45 dc	 mov	 eax, DWORD PTR _pOnsetMblk$[ebp]
  0005e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00061	89 4d f4	 mov	 DWORD PTR _sumAC1$[ebp], ecx

; 82   :   float ftmp;
; 83   :   int WinShift;
; 84   :   int k;
; 85   :   register float t0, t1;
; 86   :   float maxT0 = 1.0F;

  00064	c7 45 c8 00 00
	80 3f		 mov	 DWORD PTR _maxT0$[ebp], 1065353216 ; 3f800000H

; 87   :   float maxT1 = ONSET_THRESHOLD;

  0006b	c7 45 d8 0a d7
	23 3e		 mov	 DWORD PTR _maxT1$[ebp], 1042536202 ; 3e23d70aH

; 88   :   
; 89   : #ifdef WIN32
; 90   :   union {
; 91   :     float f;
; 92   :     long l;
; 93   :   } union_t0, union_t1;
; 94   : #else
; 95   :   float s0, s1;
; 96   : #endif
; 97   : 
; 98   :   /*----------------------------------------------------------------------
; 99   :     (1) Get the current frame of speech out. 
; 100  :     ----------------------------------------------------------------------*/
; 101  :   GetFrameSpCBM(pCircBufMblk, codec_delay_size, FRAME_LENGTH_SC+1, SpBuf);

  00072	8b 55 18	 mov	 edx, DWORD PTR _SpBuf$[ebp]
  00075	52		 push	 edx
  00076	68 a1 00 00 00	 push	 161			; 000000a1H
  0007b	8b 45 10	 mov	 eax, DWORD PTR _codec_delay_size$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d 0c	 mov	 ecx, DWORD PTR _pCircBufMblk$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _GetFrameSpCBM@16

; 102  : 
; 103  :   for (k = 0; k < FRAME_LENGTH_SC; k+=DECIM_R, SpBuf+=DECIM_R) {

  00088	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  0008f	eb 12		 jmp	 SHORT $L1301
$L1302:
  00091	8b 55 d4	 mov	 edx, DWORD PTR _k$[ebp]
  00094	83 c2 02	 add	 edx, 2
  00097	89 55 d4	 mov	 DWORD PTR _k$[ebp], edx
  0009a	8b 45 18	 mov	 eax, DWORD PTR _SpBuf$[ebp]
  0009d	83 c0 08	 add	 eax, 8
  000a0	89 45 18	 mov	 DWORD PTR _SpBuf$[ebp], eax
$L1301:
  000a3	81 7d d4 a0 00
	00 00		 cmp	 DWORD PTR _k$[ebp], 160	; 000000a0H
  000aa	0f 8d f0 00 00
	00		 jge	 $L1303

; 104  : 
; 105  :     /*-----------------------------------------------------------------
; 106  :       (2) increase the pointer: point to k-8 sample.
; 107  :       -----------------------------------------------------------------*/
; 108  :     ptr0 = (ptr0+1)%R;

  000b0	8b 4d e8	 mov	 ecx, DWORD PTR _ptr0$[ebp]
  000b3	83 c1 01	 add	 ecx, 1
  000b6	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  000bc	79 05		 jns	 SHORT $L1343
  000be	49		 dec	 ecx
  000bf	83 c9 fc	 or	 ecx, -4			; fffffffcH
  000c2	41		 inc	 ecx
$L1343:
  000c3	89 4d e8	 mov	 DWORD PTR _ptr0$[ebp], ecx

; 109  : 
; 110  :     /*-----------------------------------------------------------------
; 111  :       (3) Calculate the 1st order forward-autocorrelation coefficients.      
; 112  :       -----------------------------------------------------------------*/
; 113  :     t1 = AC_WEIGHT1*SpBuf[0];

  000c6	8b 55 18	 mov	 edx, DWORD PTR _SpBuf$[ebp]
  000c9	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3cfe0000
  000cf	d8 0a		 fmul	 DWORD PTR [edx]
  000d1	d9 5d cc	 fstp	 DWORD PTR _t1$[ebp]

; 114  :     AC0 = t1*SpBuf[0] + AC_WEIGHT2*AC0;

  000d4	8b 45 18	 mov	 eax, DWORD PTR _SpBuf$[ebp]
  000d7	d9 45 cc	 fld	 DWORD PTR _t1$[ebp]
  000da	d8 08		 fmul	 DWORD PTR [eax]
  000dc	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f781000
  000e2	d8 4d c4	 fmul	 DWORD PTR _AC0$[ebp]
  000e5	de c1		 faddp	 ST(1), ST(0)
  000e7	d9 5d c4	 fstp	 DWORD PTR _AC0$[ebp]

; 115  :     AC1 = t1*SpBuf[1] + AC_WEIGHT2*AC1;

  000ea	8b 4d 18	 mov	 ecx, DWORD PTR _SpBuf$[ebp]
  000ed	d9 45 cc	 fld	 DWORD PTR _t1$[ebp]
  000f0	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  000f3	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f781000
  000f9	d8 4d ec	 fmul	 DWORD PTR _AC1$[ebp]
  000fc	de c1		 faddp	 ST(1), ST(0)
  000fe	d9 55 ec	 fst	 DWORD PTR _AC1$[ebp]

; 116  : 
; 117  :     /*-----------------------------------------------------------------
; 118  :       (4) Find the fabs(AC1/AC0-sumAC1/sumAC0) > maxDCep ? 
; 119  :       -----------------------------------------------------------------*/
; 120  :     t1 = (float)fabs(AC1*sumAC0-AC0*sumAC1);

  00101	d8 4d f0	 fmul	 DWORD PTR _sumAC0$[ebp]
  00104	d9 45 c4	 fld	 DWORD PTR _AC0$[ebp]
  00107	d8 4d f4	 fmul	 DWORD PTR _sumAC1$[ebp]
  0010a	de e9		 fsubp	 ST(1), ST(0)
  0010c	83 ec 08	 sub	 esp, 8
  0010f	dd 1c 24	 fstp	 QWORD PTR [esp]
  00112	e8 00 00 00 00	 call	 _fabs
  00117	83 c4 08	 add	 esp, 8
  0011a	d9 5d cc	 fstp	 DWORD PTR _t1$[ebp]

; 121  :     t0 = (sumAC0*AC0);

  0011d	d9 45 f0	 fld	 DWORD PTR _sumAC0$[ebp]
  00120	d8 4d c4	 fmul	 DWORD PTR _AC0$[ebp]
  00123	d9 5d bc	 fstp	 DWORD PTR _t0$[ebp]

; 122  : 
; 123  :     /*-----------------------------------------------------------------
; 124  :       (5) calculate the cumulative Ac: sumAC = sumAC+AC[0]-AC[-8]
; 125  :       -----------------------------------------------------------------*/
; 126  :     sumAC0 = sumAC0 + AC0 - psaveAC0[ptr0];

  00126	d9 45 f0	 fld	 DWORD PTR _sumAC0$[ebp]
  00129	d8 45 c4	 fadd	 DWORD PTR _AC0$[ebp]
  0012c	8b 55 e8	 mov	 edx, DWORD PTR _ptr0$[ebp]
  0012f	8b 45 d0	 mov	 eax, DWORD PTR _psaveAC0$[ebp]
  00132	d8 24 90	 fsub	 DWORD PTR [eax+edx*4]
  00135	d9 5d f0	 fstp	 DWORD PTR _sumAC0$[ebp]

; 127  :     sumAC1 = sumAC1 + AC1 - psaveAC1[ptr0];

  00138	d9 45 f4	 fld	 DWORD PTR _sumAC1$[ebp]
  0013b	d8 45 ec	 fadd	 DWORD PTR _AC1$[ebp]
  0013e	8b 4d e8	 mov	 ecx, DWORD PTR _ptr0$[ebp]
  00141	8b 55 b4	 mov	 edx, DWORD PTR _psaveAC1$[ebp]
  00144	d8 24 8a	 fsub	 DWORD PTR [edx+ecx*4]
  00147	d9 5d f4	 fstp	 DWORD PTR _sumAC1$[ebp]

; 128  :     psaveAC0[ptr0] = AC0;

  0014a	8b 45 e8	 mov	 eax, DWORD PTR _ptr0$[ebp]
  0014d	8b 4d d0	 mov	 ecx, DWORD PTR _psaveAC0$[ebp]
  00150	8b 55 c4	 mov	 edx, DWORD PTR _AC0$[ebp]
  00153	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 129  :     psaveAC1[ptr0] = AC1;

  00156	8b 45 e8	 mov	 eax, DWORD PTR _ptr0$[ebp]
  00159	8b 4d b4	 mov	 ecx, DWORD PTR _psaveAC1$[ebp]
  0015c	8b 55 ec	 mov	 edx, DWORD PTR _AC1$[ebp]
  0015f	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 130  : 
; 131  :     if (k < OnsetDur) 

  00162	8b 45 d4	 mov	 eax, DWORD PTR _k$[ebp]
  00165	3b 45 fc	 cmp	 eax, DWORD PTR _OnsetDur$[ebp]
  00168	7d 05		 jge	 SHORT $L1305

; 132  :       continue;

  0016a	e9 22 ff ff ff	 jmp	 $L1302
$L1305:

; 133  : 
; 134  : #ifndef WIN32
; 135  :     s0 = t1*maxT0;
; 136  :     s1 = t0*maxT1;
; 137  :     if (s0 > s1) {
; 138  :       maxT0 = t0;
; 139  :       maxT1 = t1;
; 140  :       OnsetK = k;
; 141  :     }
; 142  : #else
; 143  :     union_t0.f = t1*maxT0;

  0016f	d9 45 cc	 fld	 DWORD PTR _t1$[ebp]
  00172	d8 4d c8	 fmul	 DWORD PTR _maxT0$[ebp]
  00175	d9 5d c0	 fstp	 DWORD PTR _union_t0$[ebp]

; 144  :     union_t1.f = t0*maxT1;

  00178	d9 45 bc	 fld	 DWORD PTR _t0$[ebp]
  0017b	d8 4d d8	 fmul	 DWORD PTR _maxT1$[ebp]
  0017e	d9 5d f8	 fstp	 DWORD PTR _union_t1$[ebp]

; 145  :     if (union_t0.l > union_t1.l) {

  00181	8b 4d c0	 mov	 ecx, DWORD PTR _union_t0$[ebp]
  00184	3b 4d f8	 cmp	 ecx, DWORD PTR _union_t1$[ebp]
  00187	7e 12		 jle	 SHORT $L1306

; 146  :       maxT0 = t0;

  00189	8b 55 bc	 mov	 edx, DWORD PTR _t0$[ebp]
  0018c	89 55 c8	 mov	 DWORD PTR _maxT0$[ebp], edx

; 147  :       maxT1 = t1;

  0018f	8b 45 cc	 mov	 eax, DWORD PTR _t1$[ebp]
  00192	89 45 d8	 mov	 DWORD PTR _maxT1$[ebp], eax

; 148  :       OnsetK = k;

  00195	8b 4d d4	 mov	 ecx, DWORD PTR _k$[ebp]
  00198	89 4d e0	 mov	 DWORD PTR _OnsetK$[ebp], ecx
$L1306:

; 149  :     }
; 150  : #endif
; 151  :   }

  0019b	e9 f1 fe ff ff	 jmp	 $L1302
$L1303:

; 152  : 
; 153  :   /*------------------------------------------------------------
; 154  :     (6) Update the memory 
; 155  :     ------------------------------------------------------------*/
; 156  :   pOnsetMblk->Onset_1 = OnsetK;

  001a0	8b 55 dc	 mov	 edx, DWORD PTR _pOnsetMblk$[ebp]
  001a3	8b 45 e0	 mov	 eax, DWORD PTR _OnsetK$[ebp]
  001a6	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 157  :   pOnsetMblk->sumAC0 = sumAC0;

  001a9	8b 4d dc	 mov	 ecx, DWORD PTR _pOnsetMblk$[ebp]
  001ac	8b 55 f0	 mov	 edx, DWORD PTR _sumAC0$[ebp]
  001af	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 158  :   pOnsetMblk->sumAC1 = sumAC1;

  001b2	8b 45 dc	 mov	 eax, DWORD PTR _pOnsetMblk$[ebp]
  001b5	8b 4d f4	 mov	 ecx, DWORD PTR _sumAC1$[ebp]
  001b8	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 159  :   pOnsetMblk->ptr0 = ptr0;

  001bb	8b 55 dc	 mov	 edx, DWORD PTR _pOnsetMblk$[ebp]
  001be	8b 45 e8	 mov	 eax, DWORD PTR _ptr0$[ebp]
  001c1	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 160  : 
; 161  :   /*-----------------------------------------------------------------
; 162  :     (7) Compute the window shift based on the onset time.
; 163  :     -----------------------------------------------------------------*/
; 164  :   if (OnsetK > HALF_FRAME_LENGTH_SC) {

  001c4	83 7d e0 50	 cmp	 DWORD PTR _OnsetK$[ebp], 80 ; 00000050H
  001c8	7e 3c		 jle	 SHORT $L1307

; 165  :     ftmp = ((float)(FRAME_LENGTH_SC-OnsetK)*(codec_delay_size-(winLength>>1)))*INV_FRAME_LEN;

  001ca	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  001cf	2b 4d e0	 sub	 ecx, DWORD PTR _OnsetK$[ebp]
  001d2	89 4d b0	 mov	 DWORD PTR tv268[ebp], ecx
  001d5	db 45 b0	 fild	 DWORD PTR tv268[ebp]
  001d8	8b 55 14	 mov	 edx, DWORD PTR _winLength$[ebp]
  001db	d1 fa		 sar	 edx, 1
  001dd	8b 45 10	 mov	 eax, DWORD PTR _codec_delay_size$[ebp]
  001e0	2b c2		 sub	 eax, edx
  001e2	89 45 ac	 mov	 DWORD PTR tv271[ebp], eax
  001e5	da 4d ac	 fimul	 DWORD PTR tv271[ebp]
  001e8	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c4ccccd
  001ee	d9 5d b8	 fstp	 DWORD PTR _ftmp$[ebp]

; 166  :     VoxROUND2pos(ftmp, WinShift);

  001f1	d9 45 b8	 fld	 DWORD PTR _ftmp$[ebp]
  001f4	db 5d e4	 fistp	 DWORD PTR _WinShift$[ebp]

; 167  :     if (WinShift > MAX_SHIFT)

  001f7	83 7d e4 28	 cmp	 DWORD PTR _WinShift$[ebp], 40 ; 00000028H
  001fb	7e 07		 jle	 SHORT $L1309

; 168  :       WinShift = MAX_SHIFT;

  001fd	c7 45 e4 28 00
	00 00		 mov	 DWORD PTR _WinShift$[ebp], 40 ; 00000028H
$L1309:

; 169  :   }
; 170  :   else {

  00204	eb 3a		 jmp	 SHORT $L1310
$L1307:

; 171  :     ftmp = (float)(OnsetK*(codec_delay_size-(winLength>>1)))*INV_FRAME_LEN;

  00206	8b 4d 14	 mov	 ecx, DWORD PTR _winLength$[ebp]
  00209	d1 f9		 sar	 ecx, 1
  0020b	8b 55 10	 mov	 edx, DWORD PTR _codec_delay_size$[ebp]
  0020e	2b d1		 sub	 edx, ecx
  00210	8b 45 e0	 mov	 eax, DWORD PTR _OnsetK$[ebp]
  00213	0f af c2	 imul	 eax, edx
  00216	89 45 a8	 mov	 DWORD PTR tv275[ebp], eax
  00219	db 45 a8	 fild	 DWORD PTR tv275[ebp]
  0021c	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c4ccccd
  00222	d9 5d b8	 fstp	 DWORD PTR _ftmp$[ebp]

; 172  :     VoxROUND2pos(ftmp, WinShift);

  00225	d9 45 b8	 fld	 DWORD PTR _ftmp$[ebp]
  00228	db 5d e4	 fistp	 DWORD PTR _WinShift$[ebp]

; 173  :     WinShift = -WinShift;

  0022b	8b 4d e4	 mov	 ecx, DWORD PTR _WinShift$[ebp]
  0022e	f7 d9		 neg	 ecx
  00230	89 4d e4	 mov	 DWORD PTR _WinShift$[ebp], ecx

; 174  :     if (WinShift < -MAX_SHIFT)

  00233	83 7d e4 d8	 cmp	 DWORD PTR _WinShift$[ebp], -40 ; ffffffd8H
  00237	7d 07		 jge	 SHORT $L1310

; 175  :       WinShift = -MAX_SHIFT;

  00239	c7 45 e4 d8 ff
	ff ff		 mov	 DWORD PTR _WinShift$[ebp], -40 ; ffffffd8H
$L1310:

; 176  :   }
; 177  : 
; 178  :   return WinShift;

  00240	8b 45 e4	 mov	 eax, DWORD PTR _WinShift$[ebp]

; 179  : }

  00243	8b e5		 mov	 esp, ebp
  00245	5d		 pop	 ebp
  00246	c2 14 00	 ret	 20			; 00000014H
_EstOnset@20 ENDP
_TEXT	ENDS
PUBLIC	_VoxInitEstOnset@4
EXTRN	_calloc:NEAR
EXTRN	_memset:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxInitEstOnset@4
_TEXT	SEGMENT
_pOnsetMblk$ = -4
_hOnsetMblk$ = 8
_VoxInitEstOnset@4 PROC NEAR				; COMDAT

; 185  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 186  :   ONSET_Mblk *pOnsetMblk;
; 187  : 
; 188  :   /* init the structure */
; 189  :   if (VOX_MEM_INIT(*hOnsetMblk, 1, sizeof(ONSET_Mblk)))

  00004	6a 30		 push	 48			; 00000030H
  00006	6a 01		 push	 1
  00008	e8 00 00 00 00	 call	 _calloc
  0000d	83 c4 08	 add	 esp, 8
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _hOnsetMblk$[ebp]
  00013	89 01		 mov	 DWORD PTR [ecx], eax
  00015	8b 55 08	 mov	 edx, DWORD PTR _hOnsetMblk$[ebp]
  00018	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0001b	75 06		 jne	 SHORT $L1318

; 190  :     return 1;

  0001d	66 b8 01 00	 mov	 ax, 1
  00021	eb 56		 jmp	 SHORT $L1315
$L1318:

; 191  : 
; 192  :   pOnsetMblk = (ONSET_Mblk *)*hOnsetMblk;

  00023	8b 45 08	 mov	 eax, DWORD PTR _hOnsetMblk$[ebp]
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	89 4d fc	 mov	 DWORD PTR _pOnsetMblk$[ebp], ecx

; 193  :   
; 194  :   pOnsetMblk->Onset_1 = 0;

  0002b	8b 55 fc	 mov	 edx, DWORD PTR _pOnsetMblk$[ebp]
  0002e	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 195  :   pOnsetMblk->sumAC0 = 0.0F;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _pOnsetMblk$[ebp]
  00038	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 196  :   pOnsetMblk->sumAC1 = 0.0F;

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _pOnsetMblk$[ebp]
  00042	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 197  :   pOnsetMblk->ptr0 = 0;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _pOnsetMblk$[ebp]
  0004c	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], 0

; 198  :   memset(pOnsetMblk->saveAC0, 0, R*sizeof(float));

  00053	6a 10		 push	 16			; 00000010H
  00055	6a 00		 push	 0
  00057	8b 45 fc	 mov	 eax, DWORD PTR _pOnsetMblk$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _memset
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 199  :   memset(pOnsetMblk->saveAC1, 0, R*sizeof(float));

  00063	6a 10		 push	 16			; 00000010H
  00065	6a 00		 push	 0
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _pOnsetMblk$[ebp]
  0006a	83 c1 10	 add	 ecx, 16			; 00000010H
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 _memset
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 200  : 
; 201  :   return 0;

  00076	66 33 c0	 xor	 ax, ax
$L1315:

; 202  : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
_VoxInitEstOnset@4 ENDP
_TEXT	ENDS
PUBLIC	_VoxFreeEstOnset@4
EXTRN	_free:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxFreeEstOnset@4
_TEXT	SEGMENT
_hOnsetMblk$ = 8
_VoxFreeEstOnset@4 PROC NEAR				; COMDAT

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  :   if (*hOnsetMblk) {

  00003	8b 45 08	 mov	 eax, DWORD PTR _hOnsetMblk$[ebp]
  00006	83 38 00	 cmp	 DWORD PTR [eax], 0
  00009	74 1f		 je	 SHORT $L1325

; 208  :     VOX_MEM_FREE(*hOnsetMblk);

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _hOnsetMblk$[ebp]
  0000e	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00011	74 17		 je	 SHORT $L1325
  00013	8b 55 08	 mov	 edx, DWORD PTR _hOnsetMblk$[ebp]
  00016	8b 02		 mov	 eax, DWORD PTR [edx]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _free
  0001e	83 c4 04	 add	 esp, 4
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _hOnsetMblk$[ebp]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L1325:

; 209  :   }
; 210  : 
; 211  :   return 0;

  0002a	66 33 c0	 xor	 ax, ax

; 212  : }

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
_VoxFreeEstOnset@4 ENDP
_TEXT	ENDS
END
