; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\calclpc.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxLPCAnaly4PDA@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_VoxLPCAnaly4PDA@16
PUBLIC	__real@42800000
PUBLIC	__real@3eaaaaab
EXTRN	_VoxAsToLspEven@16:NEAR
EXTRN	_VoxLspToAsEven@16:NEAR
EXTRN	_BandExpand@16:NEAR
EXTRN	_VoxDurbin@20:NEAR
EXTRN	_AutoCor@16:NEAR
EXTRN	_VoxNspIIRFlt@24:NEAR
EXTRN	__fltused:NEAR
EXTRN	_memcpy:NEAR
;	COMDAT __real@42800000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\calclpc.c
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@3eaaaaab
CONST	SEGMENT
__real@3eaaaaab DD 03eaaaaabr			; 0.333333
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxLPCAnaly4PDA@16
_TEXT	SEGMENT
_j$ = -1068
_pAutoCorrBuf$ = -1064
_diffLsf$ = -1020
_pWeightCoef$ = -1016
_fPARCOR$ = -924
_weight_den$ = -884
_weight_num$ = -880
_pAlsf0$ = -876
_fSlope$ = -872
_pAlsf$ = -868
_ResidueEng$ = -828
_psigIn$ = -824
_myCorrPDA_mblk$ = -820
_pAlsf1$ = -816
_psigBuf$ = -776
_pAlpc$ = -56
_i$ = -12
_pwin$ = -8
_psigOut$ = -4
_sigin$ = 8
_sigout$ = 12
_length$ = 16
_pCorrPDA_mblk$ = 20
_VoxLPCAnaly4PDA@16 PROC NEAR				; COMDAT

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 04 00
	00		 sub	 esp, 1068		; 0000042cH
  00009	56		 push	 esi

; 43   :   CorrPDA_mblk *myCorrPDA_mblk=(CorrPDA_mblk *)pCorrPDA_mblk;

  0000a	8b 45 14	 mov	 eax, DWORD PTR _pCorrPDA_mblk$[ebp]
  0000d	89 85 cc fc ff
	ff		 mov	 DWORD PTR _myCorrPDA_mblk$[ebp], eax

; 44   : 
; 45   : STACK_INIT
; 46   :   float psigBuf[FRAME_LEN];   /* psigBuf[FRAME_LEN] */
; 47   :   float fPARCOR[PDA_LPC_ORDER];
; 48   :   float pAutoCorrBuf[PDA_LPC_ORDER+1];
; 49   :   float pAlpc[PDA_LPC_ORDER+1];
; 50   :   float pAlsf1[PDA_LPC_ORDER];
; 51   :   float pAlsf[PDA_LPC_ORDER];
; 52   :   float pWeightCoef[2*PDA_LPC_ORDER+1];
; 53   : STACK_INIT_END
; 54   : 
; 55   : STACK_ATTACH(float *, psigBuf)
; 56   : STACK_ATTACH(float *, fPARCOR)
; 57   : STACK_ATTACH(float *, pAutoCorrBuf)
; 58   : STACK_ATTACH(float *, pAlpc)
; 59   : STACK_ATTACH(float *, pAlsf1)
; 60   : STACK_ATTACH(float *, pAlsf)
; 61   : STACK_ATTACH(float *, pWeightCoef)
; 62   : 
; 63   :   float ResidueEng;
; 64   : 
; 65   :   int i, j;
; 66   : 
; 67   :   float diffLsf;
; 68   :   float *pAlsf0;               /* LSF of previous frame */
; 69   :   float fSlope;
; 70   :   float weight_den, weight_num;
; 71   : 
; 72   :   float *psigIn, *psigOut;
; 73   :   float *pwin;
; 74   : 
; 75   : STACK_START
; 76   : 
; 77   :   /*------------------------------------------------------------
; 78   :     (1). asymmetric windowing the signal. 
; 79   :     ------------------------------------------------------------*/
; 80   :   pwin = myCorrPDA_mblk->LpcWindow;

  00013	8b 8d cc fc ff
	ff		 mov	 ecx, DWORD PTR _myCorrPDA_mblk$[ebp]
  00019	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0001c	89 55 f8	 mov	 DWORD PTR _pwin$[ebp], edx

; 81   :   psigIn = sigin;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _sigin$[ebp]
  00022	89 85 c8 fc ff
	ff		 mov	 DWORD PTR _psigIn$[ebp], eax

; 82   :   for (i = 0; i < length; i++)

  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002f	eb 09		 jmp	 SHORT $L1441
$L1442:
  00031	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00034	83 c1 01	 add	 ecx, 1
  00037	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$L1441:
  0003a	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0003d	3b 55 10	 cmp	 edx, DWORD PTR _length$[ebp]
  00040	7d 21		 jge	 SHORT $L1443

; 83   :     psigBuf[i] = psigIn[i] * pwin[i]; 

  00042	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00045	8b 8d c8 fc ff
	ff		 mov	 ecx, DWORD PTR _psigIn$[ebp]
  0004b	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0004e	8b 75 f8	 mov	 esi, DWORD PTR _pwin$[ebp]
  00051	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  00054	d8 0c 96	 fmul	 DWORD PTR [esi+edx*4]
  00057	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0005a	d9 9c 85 f8 fc
	ff ff		 fstp	 DWORD PTR _psigBuf$[ebp+eax*4]
  00061	eb ce		 jmp	 SHORT $L1442
$L1443:

; 84   : 
; 85   : 
; 86   :   /*------------------------------------------------------------
; 87   :     (2). calcualte auto-correlation coefficients.
; 88   :     ------------------------------------------------------------*/
; 89   :   AutoCor( (PDA_LPC_ORDER+1), psigBuf, length, pAutoCorrBuf);

  00063	8d 8d d8 fb ff
	ff		 lea	 ecx, DWORD PTR _pAutoCorrBuf$[ebp]
  00069	51		 push	 ecx
  0006a	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp]
  0006d	52		 push	 edx
  0006e	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _psigBuf$[ebp]
  00074	50		 push	 eax
  00075	6a 0b		 push	 11			; 0000000bH
  00077	e8 00 00 00 00	 call	 _AutoCor@16

; 90   : 
; 91   :   
; 92   :   /*------------------------------------------------------------
; 93   :     (3). calculate LPC coefficients by using Levinson-Durbin
; 94   :     algorithm.
; 95   :     ------------------------------------------------------------*/
; 96   :   VoxDurbin(pAutoCorrBuf, PDA_LPC_ORDER, pAlpc, fPARCOR, &ResidueEng);

  0007c	8d 8d c4 fc ff
	ff		 lea	 ecx, DWORD PTR _ResidueEng$[ebp]
  00082	51		 push	 ecx
  00083	8d 95 64 fc ff
	ff		 lea	 edx, DWORD PTR _fPARCOR$[ebp]
  00089	52		 push	 edx
  0008a	8d 45 c8	 lea	 eax, DWORD PTR _pAlpc$[ebp]
  0008d	50		 push	 eax
  0008e	6a 0a		 push	 10			; 0000000aH
  00090	8d 8d d8 fb ff
	ff		 lea	 ecx, DWORD PTR _pAutoCorrBuf$[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _VoxDurbin@20

; 97   : 
; 98   :   /*------------------------------------------------------------
; 99   :     (4). expand the LPC pole. pAlpc is overwritten.
; 100  :     ------------------------------------------------------------*/
; 101  :   BandExpand(pAlpc, pAlpc, PDA_LPC_ORDER, PDA_EXPAND_COEF);

  0009c	68 00 00 7e 3f	 push	 1065222144		; 3f7e0000H
  000a1	6a 0a		 push	 10			; 0000000aH
  000a3	8d 55 c8	 lea	 edx, DWORD PTR _pAlpc$[ebp]
  000a6	52		 push	 edx
  000a7	8d 45 c8	 lea	 eax, DWORD PTR _pAlpc$[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 _BandExpand@16

; 102  : 
; 103  : 
; 104  :   /*------------------------------------------------------------
; 105  :     (5). calculate LSFs.
; 106  :     ------------------------------------------------------------*/
; 107  :   VoxAsToLspEven(pAlpc, PDA_LPC_ORDER, RATE8K, pAlsf1);

  000b0	8d 8d d0 fc ff
	ff		 lea	 ecx, DWORD PTR _pAlsf1$[ebp]
  000b6	51		 push	 ecx
  000b7	68 00 00 fa 45	 push	 1174011904		; 45fa0000H
  000bc	6a 0a		 push	 10			; 0000000aH
  000be	8d 55 c8	 lea	 edx, DWORD PTR _pAlpc$[ebp]
  000c1	52		 push	 edx
  000c2	e8 00 00 00 00	 call	 _VoxAsToLspEven@16

; 108  : 
; 109  :   /*------------------------------------------------------------
; 110  :     (6). check the difference of LSFs.
; 111  :     ------------------------------------------------------------*/
; 112  :   weight_num = PERCEP_WEIGHT_NUM_BIG;

  000c7	c7 85 90 fc ff
	ff 00 00 7e 3f	 mov	 DWORD PTR _weight_num$[ebp], 1065222144 ; 3f7e0000H

; 113  :   for (i = 1; i < PDA_LPC_ORDER; i++) {

  000d1	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000d8	eb 09		 jmp	 SHORT $L1444
$L1445:
  000da	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000dd	83 c0 01	 add	 eax, 1
  000e0	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$L1444:
  000e3	83 7d f4 0a	 cmp	 DWORD PTR _i$[ebp], 10	; 0000000aH
  000e7	7d 33		 jge	 SHORT $L1446

; 114  :     diffLsf = pAlsf1[i]-pAlsf1[i-1];

  000e9	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000ec	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000ef	d9 84 8d d0 fc
	ff ff		 fld	 DWORD PTR _pAlsf1$[ebp+ecx*4]
  000f6	d8 a4 95 cc fc
	ff ff		 fsub	 DWORD PTR _pAlsf1$[ebp+edx*4-4]
  000fd	d9 95 04 fc ff
	ff		 fst	 DWORD PTR _diffLsf$[ebp]

; 115  :     if (diffLsf < MIN_DIFF_LSF)

  00103	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@42800000
  00109	df e0		 fnstsw	 ax
  0010b	f6 c4 05	 test	 ah, 5
  0010e	7a 0a		 jp	 SHORT $L1447

; 116  :       weight_num = PERCEP_WEIGHT_NUM_SMALL;

  00110	c7 85 90 fc ff
	ff 00 00 7d 3f	 mov	 DWORD PTR _weight_num$[ebp], 1065156608 ; 3f7d0000H
$L1447:

; 117  :   }

  0011a	eb be		 jmp	 SHORT $L1445
$L1446:

; 118  :   
; 119  :   /*------------------------------------------------------------
; 120  :     (7). interpolate the LSFs between subframes. 
; 121  :     do perceptual weighting of signal.
; 122  :     ------------------------------------------------------------*/
; 123  :   pAlsf0 = myCorrPDA_mblk->Alsf0;

  0011c	8b 85 cc fc ff
	ff		 mov	 eax, DWORD PTR _myCorrPDA_mblk$[ebp]
  00122	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00125	89 8d 94 fc ff
	ff		 mov	 DWORD PTR _pAlsf0$[ebp], ecx

; 124  :   fSlope = INTERP_LSF_COEF;

  0012b	c7 85 98 fc ff
	ff ab aa aa 3e	 mov	 DWORD PTR _fSlope$[ebp], 1051372203 ; 3eaaaaabH

; 125  :   weight_den = PERCEP_WEIGHT_DEN; 

  00135	c7 85 8c fc ff
	ff cd cc 4c 3f	 mov	 DWORD PTR _weight_den$[ebp], 1061997773 ; 3f4ccccdH

; 126  :   psigIn = sigin;

  0013f	8b 55 08	 mov	 edx, DWORD PTR _sigin$[ebp]
  00142	89 95 c8 fc ff
	ff		 mov	 DWORD PTR _psigIn$[ebp], edx

; 127  :   psigOut = sigout;

  00148	8b 45 0c	 mov	 eax, DWORD PTR _sigout$[ebp]
  0014b	89 45 fc	 mov	 DWORD PTR _psigOut$[ebp], eax

; 128  :   for (i = 0; i < NUM_SUBFRAME; i++) {

  0014e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00155	eb 09		 jmp	 SHORT $L1450
$L1451:
  00157	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0015a	83 c1 01	 add	 ecx, 1
  0015d	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$L1450:
  00160	83 7d f4 03	 cmp	 DWORD PTR _i$[ebp], 3
  00164	0f 8d 18 01 00
	00		 jge	 $L1452

; 129  :     /* interpolate LSFs */
; 130  :     for (j = 0; j < PDA_LPC_ORDER; j++)

  0016a	c7 85 d4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  00174	eb 0f		 jmp	 SHORT $L1453
$L1454:
  00176	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  0017c	83 c2 01	 add	 edx, 1
  0017f	89 95 d4 fb ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
$L1453:
  00185	83 bd d4 fb ff
	ff 0a		 cmp	 DWORD PTR _j$[ebp], 10	; 0000000aH
  0018c	7d 40		 jge	 SHORT $L1455

; 131  :       pAlsf[j] = pAlsf0[j] + fSlope*(pAlsf1[j]-pAlsf0[j]);

  0018e	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00194	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  0019a	8b 95 94 fc ff
	ff		 mov	 edx, DWORD PTR _pAlsf0$[ebp]
  001a0	d9 84 85 d0 fc
	ff ff		 fld	 DWORD PTR _pAlsf1$[ebp+eax*4]
  001a7	d8 24 8a	 fsub	 DWORD PTR [edx+ecx*4]
  001aa	d8 8d 98 fc ff
	ff		 fmul	 DWORD PTR _fSlope$[ebp]
  001b0	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  001b6	8b 8d 94 fc ff
	ff		 mov	 ecx, DWORD PTR _pAlsf0$[ebp]
  001bc	d8 04 81	 fadd	 DWORD PTR [ecx+eax*4]
  001bf	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  001c5	d9 9c 95 9c fc
	ff ff		 fstp	 DWORD PTR _pAlsf$[ebp+edx*4]
  001cc	eb a8		 jmp	 SHORT $L1454
$L1455:

; 132  :     fSlope += INTERP_LSF_COEF;

  001ce	d9 85 98 fc ff
	ff		 fld	 DWORD PTR _fSlope$[ebp]
  001d4	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3eaaaaab
  001da	d9 9d 98 fc ff
	ff		 fstp	 DWORD PTR _fSlope$[ebp]

; 133  : 
; 134  : 
; 135  :     /* Lsf converts to Lpc */
; 136  :     VoxLspToAsEven(pAlsf, PDA_LPC_ORDER, INV_RATE8K, pAlpc);

  001e0	8d 45 c8	 lea	 eax, DWORD PTR _pAlpc$[ebp]
  001e3	50		 push	 eax
  001e4	68 6f 12 03 39	 push	 956502639		; 3903126fH
  001e9	6a 0a		 push	 10			; 0000000aH
  001eb	8d 8d 9c fc ff
	ff		 lea	 ecx, DWORD PTR _pAlsf$[ebp]
  001f1	51		 push	 ecx
  001f2	e8 00 00 00 00	 call	 _VoxLspToAsEven@16

; 137  : 
; 138  :     /** numerator of weighting filter **/
; 139  :     BandExpand(pAlpc, &(pWeightCoef[0]), PDA_LPC_ORDER, weight_num);

  001f7	8b 95 90 fc ff
	ff		 mov	 edx, DWORD PTR _weight_num$[ebp]
  001fd	52		 push	 edx
  001fe	6a 0a		 push	 10			; 0000000aH
  00200	8d 85 08 fc ff
	ff		 lea	 eax, DWORD PTR _pWeightCoef$[ebp]
  00206	50		 push	 eax
  00207	8d 4d c8	 lea	 ecx, DWORD PTR _pAlpc$[ebp]
  0020a	51		 push	 ecx
  0020b	e8 00 00 00 00	 call	 _BandExpand@16

; 140  :     /** denominator of weighting filter **/
; 141  :     BandExpand(pAlpc, pAlpc, PDA_LPC_ORDER, weight_den);

  00210	8b 95 8c fc ff
	ff		 mov	 edx, DWORD PTR _weight_den$[ebp]
  00216	52		 push	 edx
  00217	6a 0a		 push	 10			; 0000000aH
  00219	8d 45 c8	 lea	 eax, DWORD PTR _pAlpc$[ebp]
  0021c	50		 push	 eax
  0021d	8d 4d c8	 lea	 ecx, DWORD PTR _pAlpc$[ebp]
  00220	51		 push	 ecx
  00221	e8 00 00 00 00	 call	 _BandExpand@16

; 142  :     memcpy( &(pWeightCoef[PDA_LPC_ORDER+1]), pAlpc+1, PDA_LPC_ORDER*sizeof(float));

  00226	6a 28		 push	 40			; 00000028H
  00228	8d 55 cc	 lea	 edx, DWORD PTR _pAlpc$[ebp+4]
  0022b	52		 push	 edx
  0022c	8d 85 34 fc ff
	ff		 lea	 eax, DWORD PTR _pWeightCoef$[ebp+44]
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 _memcpy
  00238	83 c4 0c	 add	 esp, 12			; 0000000cH

; 143  : 
; 144  :     /** filter the signal using IIR filter.**/
; 145  :     VoxNspIIRFlt(psigIn, psigOut, SUBFRAME_LEN, pWeightCoef, PDA_LPC_ORDER,
; 146  : 		 myCorrPDA_mblk->percWeight_mem);

  0023b	8b 8d cc fc ff
	ff		 mov	 ecx, DWORD PTR _myCorrPDA_mblk$[ebp]
  00241	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00244	52		 push	 edx
  00245	6a 0a		 push	 10			; 0000000aH
  00247	8d 85 08 fc ff
	ff		 lea	 eax, DWORD PTR _pWeightCoef$[ebp]
  0024d	50		 push	 eax
  0024e	6a 3c		 push	 60			; 0000003cH
  00250	8b 4d fc	 mov	 ecx, DWORD PTR _psigOut$[ebp]
  00253	51		 push	 ecx
  00254	8b 95 c8 fc ff
	ff		 mov	 edx, DWORD PTR _psigIn$[ebp]
  0025a	52		 push	 edx
  0025b	e8 00 00 00 00	 call	 _VoxNspIIRFlt@24

; 147  :     
; 148  :     psigIn += SUBFRAME_LEN;

  00260	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR _psigIn$[ebp]
  00266	05 f0 00 00 00	 add	 eax, 240		; 000000f0H
  0026b	89 85 c8 fc ff
	ff		 mov	 DWORD PTR _psigIn$[ebp], eax

; 149  :     psigOut += SUBFRAME_LEN;

  00271	8b 4d fc	 mov	 ecx, DWORD PTR _psigOut$[ebp]
  00274	81 c1 f0 00 00
	00		 add	 ecx, 240		; 000000f0H
  0027a	89 4d fc	 mov	 DWORD PTR _psigOut$[ebp], ecx

; 150  :   }

  0027d	e9 d5 fe ff ff	 jmp	 $L1451
$L1452:

; 151  : 
; 152  : 
; 153  :   /*------------------------------------------------------------
; 154  :     (8) copy Alsf1[0:9] to Alsf0[0:9] for next frame.
; 155  :     ------------------------------------------------------------*/
; 156  :   memcpy(pAlsf0, pAlsf1, PDA_LPC_ORDER*sizeof(float));

  00282	6a 28		 push	 40			; 00000028H
  00284	8d 95 d0 fc ff
	ff		 lea	 edx, DWORD PTR _pAlsf1$[ebp]
  0028a	52		 push	 edx
  0028b	8b 85 94 fc ff
	ff		 mov	 eax, DWORD PTR _pAlsf0$[ebp]
  00291	50		 push	 eax
  00292	e8 00 00 00 00	 call	 _memcpy
  00297	83 c4 0c	 add	 esp, 12			; 0000000cH

; 157  : 
; 158  : STACK_END
; 159  : }

  0029a	5e		 pop	 esi
  0029b	8b e5		 mov	 esp, ebp
  0029d	5d		 pop	 ebp
  0029e	c2 10 00	 ret	 16			; 00000010H
_VoxLPCAnaly4PDA@16 ENDP
_TEXT	ENDS
END
