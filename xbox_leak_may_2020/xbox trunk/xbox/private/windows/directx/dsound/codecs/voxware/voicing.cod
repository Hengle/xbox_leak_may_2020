; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\voicing.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EA@EELDKBHG@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@FPFPMING@iBaseBand?5?$DM?$DN?5NFFT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxSTCVoicing@28
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ComputePv@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ModifyPv@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
CONST	SEGMENT
_fCutOffBand DD	043200000r			; 160
CONST	ENDS
PUBLIC	_VoxSTCVoicing@28
PUBLIC	??_C@_0EA@EELDKBHG@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BC@FPFPMING@iBaseBand?5?$DM?$DN?5NFFT?$AA@ ; `string'
PUBLIC	__real@44000000
PUBLIC	__real@3e2c0000
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@3e000000
PUBLIC	__real@bf000000
PUBLIC	__real@40900000
EXTRN	_FindMaxValueFlt@16:NEAR
EXTRN	_ScaleAndCompress@16:NEAR
EXTRN	_VoxRefineC0@28:NEAR
EXTRN	_VoxSquareLawPeaks@28:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	__assert:NEAR
;	COMDAT __real@44000000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\voicing.c
CONST	SEGMENT
__real@44000000 DD 044000000r			; 512
CONST	ENDS
;	COMDAT __real@3e2c0000
CONST	SEGMENT
__real@3e2c0000 DD 03e2c0000r			; 0.167969
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
CONST	ENDS
;	COMDAT ??_C@_0EA@EELDKBHG@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0EA@EELDKBHG@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\voicing.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FPFPMING@iBaseBand?5?$DM?$DN?5NFFT?$AA@
CONST	SEGMENT
??_C@_0BC@FPFPMING@iBaseBand?5?$DM?$DN?5NFFT?$AA@ DB 'iBaseBand <= NFFT', 00H ; `string'
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@40900000
CONST	SEGMENT
__real@40900000 DD 040900000r			; 4.5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxSTCVoicing@28
_TEXT	SEGMENT
tv131 = -1912
tv70 = -1908
_fNuAmp$1439 = -1904
_fNuFrq$1440 = -1504
_fFltSee$1434 = -1104
_j$ = -76
_fCoarsePitchPeriod$ = -72
_k$ = -68
_iBasePeakCount$ = -64
_NuPeaks$ = -60
_LoBandEdge$ = -56
_fBaseBand$ = -52
_fMaxMagSq$ = -48
_iIndex$ = -44
_fdBmin$ = -40
_PvFinal$ = -36
_iBaseBand$ = -32
_fRefinedPitchPeriod$ = -28
_PvLastTime$ = -24
_fCoarsePitchDFT$ = -20
_fRhoRefined$ = -16
_ratio$ = -12
_NuEnergy$ = -8
_fTemp$ = -4
_pfPv_km1$ = 8
_pfSeevocEnv$ = 12
_pfPitchPeriod$ = 16
_pfPv$ = 20
_pfPeakPwr$ = 24
_pfPeakFrq$ = 28
_iPeakCount$ = 32
_VoxSTCVoicing@28 PROC NEAR				; COMDAT

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 78 07 00
	00		 sub	 esp, 1912		; 00000778H

; 104  :   int j, k, iIndex;
; 105  :   int iBaseBand, iBasePeakCount, NuPeaks;
; 106  : 
; 107  :   float fCoarsePitchDFT, ratio;
; 108  :   float LoBandEdge, fBaseBand, NuEnergy;
; 109  :   float fRhoRefined, fRefinedPitchPeriod, fCoarsePitchPeriod;
; 110  :   float fTemp,fdBmin, PvLastTime, PvFinal;
; 111  :   float fMaxMagSq;
; 112  : 
; 113  :    /*-----------------------------------------------------------------
; 114  :      Compute the band edges in DFT points 
; 115  :    -----------------------------------------------------------------*/
; 116  :    fCoarsePitchPeriod = *pfPitchPeriod;

  00009	8b 45 10	 mov	 eax, DWORD PTR _pfPitchPeriod$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d b8	 mov	 DWORD PTR _fCoarsePitchPeriod$[ebp], ecx

; 117  :    fCoarsePitchDFT = (float)NFFT/ fCoarsePitchPeriod;

  00011	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@44000000
  00017	d8 75 b8	 fdiv	 DWORD PTR _fCoarsePitchPeriod$[ebp]
  0001a	d9 5d ec	 fstp	 DWORD PTR _fCoarsePitchDFT$[ebp]

; 118  : 
; 119  :    iBasePeakCount = VoxFLOOR((PV_BANDEDGE/(float)NFFT)*fCoarsePitchPeriod);

  0001d	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3e2c0000
  00023	d8 4d b8	 fmul	 DWORD PTR _fCoarsePitchPeriod$[ebp]
  00026	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  0002c	df e0		 fnstsw	 ax
  0002e	f6 c4 01	 test	 ah, 1
  00031	75 11		 jne	 SHORT $L1490
  00033	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3e2c0000
  00039	d8 4d b8	 fmul	 DWORD PTR _fCoarsePitchPeriod$[ebp]
  0003c	d9 9d 8c f8 ff
	ff		 fstp	 DWORD PTR tv70[ebp]
  00042	eb 15		 jmp	 SHORT $L1491
$L1490:
  00044	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3e2c0000
  0004a	d8 4d b8	 fmul	 DWORD PTR _fCoarsePitchPeriod$[ebp]
  0004d	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3f800000
  00053	d9 9d 8c f8 ff
	ff		 fstp	 DWORD PTR tv70[ebp]
$L1491:
  00059	d9 85 8c f8 ff
	ff		 fld	 DWORD PTR tv70[ebp]
  0005f	e8 00 00 00 00	 call	 __ftol2
  00064	89 45 c0	 mov	 DWORD PTR _iBasePeakCount$[ebp], eax

; 120  :    if(iBasePeakCount < MIN_PV_HARM)

  00067	83 7d c0 05	 cmp	 DWORD PTR _iBasePeakCount$[ebp], 5
  0006b	7d 07		 jge	 SHORT $L1424

; 121  :       iBasePeakCount = MIN_PV_HARM;

  0006d	c7 45 c0 05 00
	00 00		 mov	 DWORD PTR _iBasePeakCount$[ebp], 5
$L1424:

; 122  : 
; 123  : 
; 124  :    fBaseBand = (iBasePeakCount + 0.125F)*fCoarsePitchDFT;  /** was 0.5F **/

  00074	db 45 c0	 fild	 DWORD PTR _iBasePeakCount$[ebp]
  00077	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3e000000
  0007d	d8 4d ec	 fmul	 DWORD PTR _fCoarsePitchDFT$[ebp]
  00080	d9 55 cc	 fst	 DWORD PTR _fBaseBand$[ebp]

; 125  :    if (fBaseBand > fCutOffBand)                /***** extend to 2500.0Hz *****/

  00083	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR _fCutOffBand
  00089	df e0		 fnstsw	 ax
  0008b	f6 c4 41	 test	 ah, 65			; 00000041H
  0008e	75 09		 jne	 SHORT $L1425

; 126  :      fBaseBand = fCutOffBand;

  00090	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _fCutOffBand
  00096	89 55 cc	 mov	 DWORD PTR _fBaseBand$[ebp], edx
$L1425:

; 127  : 
; 128  :   
; 129  :    VoxROUND2pos(fBaseBand, iBaseBand);

  00099	d9 45 cc	 fld	 DWORD PTR _fBaseBand$[ebp]
  0009c	db 5d e0	 fistp	 DWORD PTR _iBaseBand$[ebp]

; 130  : 
; 131  :    /*-----------------------------------------------------------------
; 132  :      Here we add 1 to iBaseBand.  The peaks to be used are
; 133  :        0 through round(fBaseBand), including 0 and round(fBaseBand).
; 134  :        Since we include both endpoints, the value of iBaseBand should 
; 135  :        be round(fBaseBand)+1.
; 136  :    -----------------------------------------------------------------*/
; 137  :    iBaseBand++;

  0009f	8b 45 e0	 mov	 eax, DWORD PTR _iBaseBand$[ebp]
  000a2	83 c0 01	 add	 eax, 1
  000a5	89 45 e0	 mov	 DWORD PTR _iBaseBand$[ebp], eax

; 138  :    assert( iBaseBand <= NFFT );

  000a8	81 7d e0 00 02
	00 00		 cmp	 DWORD PTR _iBaseBand$[ebp], 512 ; 00000200H
  000af	7e 17		 jle	 SHORT $L1492
  000b1	68 8a 00 00 00	 push	 138			; 0000008aH
  000b6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@EELDKBHG@c?3?2xbox?2private?2windows?2directx?2@
  000bb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@FPFPMING@iBaseBand?5?$DM?$DN?5NFFT?$AA@
  000c0	e8 00 00 00 00	 call	 __assert
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1492:

; 139  : 
; 140  :    /*-----------------------------------------------------------------
; 141  :      Compute the number of baseband peaks 
; 142  :    -----------------------------------------------------------------*/
; 143  :    for (k = 0; k < iPeakCount; k++)

  000c8	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  000cf	eb 09		 jmp	 SHORT $L1429
$L1430:
  000d1	8b 55 bc	 mov	 edx, DWORD PTR _k$[ebp]
  000d4	83 c2 01	 add	 edx, 1
  000d7	89 55 bc	 mov	 DWORD PTR _k$[ebp], edx
$L1429:
  000da	8b 45 bc	 mov	 eax, DWORD PTR _k$[ebp]
  000dd	3b 45 20	 cmp	 eax, DWORD PTR _iPeakCount$[ebp]
  000e0	7d 17		 jge	 SHORT $L1431

; 144  :    {
; 145  :       if (pfPeakFrq[k] > fBaseBand)

  000e2	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  000e5	8b 55 1c	 mov	 edx, DWORD PTR _pfPeakFrq$[ebp]
  000e8	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  000eb	d8 5d cc	 fcomp	 DWORD PTR _fBaseBand$[ebp]
  000ee	df e0		 fnstsw	 ax
  000f0	f6 c4 41	 test	 ah, 65			; 00000041H
  000f3	75 02		 jne	 SHORT $L1432

; 146  :             break;

  000f5	eb 02		 jmp	 SHORT $L1431
$L1432:

; 147  :    }

  000f7	eb d8		 jmp	 SHORT $L1430
$L1431:

; 148  :    iBasePeakCount = k;

  000f9	8b 45 bc	 mov	 eax, DWORD PTR _k$[ebp]
  000fc	89 45 c0	 mov	 DWORD PTR _iBasePeakCount$[ebp], eax

; 149  : 
; 150  :    if (iBasePeakCount>0)

  000ff	83 7d c0 00	 cmp	 DWORD PTR _iBasePeakCount$[ebp], 0
  00103	0f 8e 51 01 00
	00		 jle	 $L1433

; 151  :    {
; 152  :       /*-----------------------------------------------------------------
; 153  :         Find the maximum magnitude of the baseband peaks and 
; 154  :           the baseband region of pfSeevocEnv[].
; 155  :       -----------------------------------------------------------------*/
; 156  :       FindMaxValueFlt( pfPeakPwr, iBasePeakCount, &k, &fMaxMagSq );

  00109	8d 4d d0	 lea	 ecx, DWORD PTR _fMaxMagSq$[ebp]
  0010c	51		 push	 ecx
  0010d	8d 55 bc	 lea	 edx, DWORD PTR _k$[ebp]
  00110	52		 push	 edx
  00111	8b 45 c0	 mov	 eax, DWORD PTR _iBasePeakCount$[ebp]
  00114	50		 push	 eax
  00115	8b 4d 18	 mov	 ecx, DWORD PTR _pfPeakPwr$[ebp]
  00118	51		 push	 ecx
  00119	e8 00 00 00 00	 call	 _FindMaxValueFlt@16

; 157  :       FindMaxValueFlt( pfSeevocEnv, iBaseBand, &k, &fTemp );

  0011e	8d 55 fc	 lea	 edx, DWORD PTR _fTemp$[ebp]
  00121	52		 push	 edx
  00122	8d 45 bc	 lea	 eax, DWORD PTR _k$[ebp]
  00125	50		 push	 eax
  00126	8b 4d e0	 mov	 ecx, DWORD PTR _iBaseBand$[ebp]
  00129	51		 push	 ecx
  0012a	8b 55 0c	 mov	 edx, DWORD PTR _pfSeevocEnv$[ebp]
  0012d	52		 push	 edx
  0012e	e8 00 00 00 00	 call	 _FindMaxValueFlt@16

; 158  :       fMaxMagSq = VoxMAX( fMaxMagSq, fTemp );

  00133	d9 45 d0	 fld	 DWORD PTR _fMaxMagSq$[ebp]
  00136	d8 5d fc	 fcomp	 DWORD PTR _fTemp$[ebp]
  00139	df e0		 fnstsw	 ax
  0013b	f6 c4 41	 test	 ah, 65			; 00000041H
  0013e	75 0b		 jne	 SHORT $L1493
  00140	8b 45 d0	 mov	 eax, DWORD PTR _fMaxMagSq$[ebp]
  00143	89 85 88 f8 ff
	ff		 mov	 DWORD PTR tv131[ebp], eax
  00149	eb 09		 jmp	 SHORT $L1494
$L1493:
  0014b	8b 4d fc	 mov	 ecx, DWORD PTR _fTemp$[ebp]
  0014e	89 8d 88 f8 ff
	ff		 mov	 DWORD PTR tv131[ebp], ecx
$L1494:
  00154	8b 95 88 f8 ff
	ff		 mov	 edx, DWORD PTR tv131[ebp]
  0015a	89 55 d0	 mov	 DWORD PTR _fMaxMagSq$[ebp], edx

; 159  :    
; 160  :       /*-----------------------------------------------------------------
; 161  :         Compress the baseband STFT peaks in place.
; 162  :       -----------------------------------------------------------------*/
; 163  :       ScaleAndCompress( pfPeakPwr, iBasePeakCount, fMaxMagSq, pfPeakPwr);

  0015d	8b 45 18	 mov	 eax, DWORD PTR _pfPeakPwr$[ebp]
  00160	50		 push	 eax
  00161	8b 4d d0	 mov	 ecx, DWORD PTR _fMaxMagSq$[ebp]
  00164	51		 push	 ecx
  00165	8b 55 c0	 mov	 edx, DWORD PTR _iBasePeakCount$[ebp]
  00168	52		 push	 edx
  00169	8b 45 18	 mov	 eax, DWORD PTR _pfPeakPwr$[ebp]
  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 _ScaleAndCompress@16

; 164  :    
; 165  :       {
; 166  :          /*-----------------------------------------------------------------
; 167  :            The length of fFltSee[] only need cover the baseband harmonics.
; 168  :              We should figure out how to make this array smaller.
; 169  :          -----------------------------------------------------------------*/
; 170  :          STACK_INIT
; 171  :            float  fFltSee[NFFT_2];         /** flattend Seevoc envelope      **/
; 172  :          STACK_INIT_END
; 173  :            STACK_ATTACH(float *, fFltSee)
; 174  :          STACK_START
; 175  :     
; 176  :    
; 177  :          /*-----------------------------------------------------------------
; 178  :            Compress the baseband magnitude-squared seevoc flattop envelope.
; 179  :              This operation is done out of place since the seevoc envelope
; 180  :              will be needed later.
; 181  :          -----------------------------------------------------------------*/
; 182  :          ScaleAndCompress( pfSeevocEnv, iBaseBand, fMaxMagSq, fFltSee);

  00172	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _fFltSee$1434[ebp]
  00178	51		 push	 ecx
  00179	8b 55 d0	 mov	 edx, DWORD PTR _fMaxMagSq$[ebp]
  0017c	52		 push	 edx
  0017d	8b 45 e0	 mov	 eax, DWORD PTR _iBaseBand$[ebp]
  00180	50		 push	 eax
  00181	8b 4d 0c	 mov	 ecx, DWORD PTR _pfSeevocEnv$[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _ScaleAndCompress@16

; 183  :    
; 184  :          /*-----------------------------------------------------------------
; 185  :            Suppress the peaks below the compressed flattop envelope
; 186  :          -----------------------------------------------------------------*/
; 187  :          for (j = 0; j < iBasePeakCount; j++)

  0018a	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00191	eb 09		 jmp	 SHORT $L1435
$L1436:
  00193	8b 55 b4	 mov	 edx, DWORD PTR _j$[ebp]
  00196	83 c2 01	 add	 edx, 1
  00199	89 55 b4	 mov	 DWORD PTR _j$[ebp], edx
$L1435:
  0019c	8b 45 b4	 mov	 eax, DWORD PTR _j$[ebp]
  0019f	3b 45 c0	 cmp	 eax, DWORD PTR _iBasePeakCount$[ebp]
  001a2	7d 5f		 jge	 SHORT $L1437

; 188  :          {
; 189  :             fTemp = pfPeakFrq[j];

  001a4	8b 4d b4	 mov	 ecx, DWORD PTR _j$[ebp]
  001a7	8b 55 1c	 mov	 edx, DWORD PTR _pfPeakFrq$[ebp]
  001aa	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  001ad	89 45 fc	 mov	 DWORD PTR _fTemp$[ebp], eax

; 190  :             VoxROUND2pos(fTemp, iIndex);

  001b0	d9 45 fc	 fld	 DWORD PTR _fTemp$[ebp]
  001b3	db 5d d4	 fistp	 DWORD PTR _iIndex$[ebp]

; 191  :    
; 192  :             if(pfPeakPwr[j] < fFltSee[iIndex])

  001b6	8b 4d b4	 mov	 ecx, DWORD PTR _j$[ebp]
  001b9	8b 55 18	 mov	 edx, DWORD PTR _pfPeakPwr$[ebp]
  001bc	8b 45 d4	 mov	 eax, DWORD PTR _iIndex$[ebp]
  001bf	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  001c2	d8 9c 85 b0 fb
	ff ff		 fcomp	 DWORD PTR _fFltSee$1434[ebp+eax*4]
  001c9	df e0		 fnstsw	 ax
  001cb	f6 c4 05	 test	 ah, 5
  001ce	7a 31		 jp	 SHORT $L1438

; 193  :             {
; 194  :                ratio = pfPeakPwr[j]/fFltSee[iIndex];

  001d0	8b 4d b4	 mov	 ecx, DWORD PTR _j$[ebp]
  001d3	8b 55 18	 mov	 edx, DWORD PTR _pfPeakPwr$[ebp]
  001d6	8b 45 d4	 mov	 eax, DWORD PTR _iIndex$[ebp]
  001d9	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  001dc	d8 b4 85 b0 fb
	ff ff		 fdiv	 DWORD PTR _fFltSee$1434[ebp+eax*4]
  001e3	d9 55 f4	 fst	 DWORD PTR _ratio$[ebp]

; 195  :                fTemp = ratio*ratio;

  001e6	d8 4d f4	 fmul	 DWORD PTR _ratio$[ebp]
  001e9	d9 55 fc	 fst	 DWORD PTR _fTemp$[ebp]

; 196  :                pfPeakPwr[j] *= (fTemp*fTemp);

  001ec	d8 4d fc	 fmul	 DWORD PTR _fTemp$[ebp]
  001ef	8b 4d b4	 mov	 ecx, DWORD PTR _j$[ebp]
  001f2	8b 55 18	 mov	 edx, DWORD PTR _pfPeakPwr$[ebp]
  001f5	d8 0c 8a	 fmul	 DWORD PTR [edx+ecx*4]
  001f8	8b 45 b4	 mov	 eax, DWORD PTR _j$[ebp]
  001fb	8b 4d 18	 mov	 ecx, DWORD PTR _pfPeakPwr$[ebp]
  001fe	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
$L1438:

; 197  :             }
; 198  :          }

  00201	eb 90		 jmp	 SHORT $L1436
$L1437:

; 199  :    
; 200  :          STACK_END
; 201  :       }
; 202  :    
; 203  :       {
; 204  :          STACK_INIT
; 205  :            float  fNuAmp[MAXHARM];
; 206  :            float  fNuFrq[MAXHARM];
; 207  :          STACK_INIT_END
; 208  :            STACK_ATTACH(float *, fNuAmp)
; 209  :            STACK_ATTACH(float *, fNuFrq)
; 210  :          STACK_START
; 211  :    
; 212  :          /*-----------------------------------------------------------------
; 213  :            Compute the sine-wave representation of the square-law output 
; 214  :          -----------------------------------------------------------------*/
; 215  :          LoBandEdge = SQVOC_LO_EDGE*HZ2DFT;  /** ~850Hz **/

  00203	c7 45 c8 9a 99
	59 42		 mov	 DWORD PTR _LoBandEdge$[ebp], 1113168282 ; 4259999aH

; 216  :    
; 217  :          VoxSquareLawPeaks( pfPeakPwr, pfPeakFrq, iBasePeakCount, 
; 218  :                             LoBandEdge, fNuAmp, fNuFrq, &NuPeaks ); 

  0020a	8d 55 c4	 lea	 edx, DWORD PTR _NuPeaks$[ebp]
  0020d	52		 push	 edx
  0020e	8d 85 20 fa ff
	ff		 lea	 eax, DWORD PTR _fNuFrq$1440[ebp]
  00214	50		 push	 eax
  00215	8d 8d 90 f8 ff
	ff		 lea	 ecx, DWORD PTR _fNuAmp$1439[ebp]
  0021b	51		 push	 ecx
  0021c	8b 55 c8	 mov	 edx, DWORD PTR _LoBandEdge$[ebp]
  0021f	52		 push	 edx
  00220	8b 45 c0	 mov	 eax, DWORD PTR _iBasePeakCount$[ebp]
  00223	50		 push	 eax
  00224	8b 4d 1c	 mov	 ecx, DWORD PTR _pfPeakFrq$[ebp]
  00227	51		 push	 ecx
  00228	8b 55 18	 mov	 edx, DWORD PTR _pfPeakPwr$[ebp]
  0022b	52		 push	 edx
  0022c	e8 00 00 00 00	 call	 _VoxSquareLawPeaks@28

; 219  :    
; 220  :          /*-----------------------------------------------------------------
; 221  :            Refine the pitch about the previously estimated value
; 222  :          -----------------------------------------------------------------*/
; 223  :          VoxRefineC0(STACK_S fCoarsePitchPeriod, fNuAmp, fNuFrq, NuPeaks, 
; 224  :                      &NuEnergy, &fRefinedPitchPeriod, &fRhoRefined); 

  00231	8d 45 f0	 lea	 eax, DWORD PTR _fRhoRefined$[ebp]
  00234	50		 push	 eax
  00235	8d 4d e4	 lea	 ecx, DWORD PTR _fRefinedPitchPeriod$[ebp]
  00238	51		 push	 ecx
  00239	8d 55 f8	 lea	 edx, DWORD PTR _NuEnergy$[ebp]
  0023c	52		 push	 edx
  0023d	8b 45 c4	 mov	 eax, DWORD PTR _NuPeaks$[ebp]
  00240	50		 push	 eax
  00241	8d 8d 20 fa ff
	ff		 lea	 ecx, DWORD PTR _fNuFrq$1440[ebp]
  00247	51		 push	 ecx
  00248	8d 95 90 f8 ff
	ff		 lea	 edx, DWORD PTR _fNuAmp$1439[ebp]
  0024e	52		 push	 edx
  0024f	8b 45 b8	 mov	 eax, DWORD PTR _fCoarsePitchPeriod$[ebp]
  00252	50		 push	 eax
  00253	e8 00 00 00 00	 call	 _VoxRefineC0@28

; 225  :    
; 226  :          STACK_END
; 227  :       }
; 228  :    } else { /* if (iBasePeakCount>0) */

  00258	eb 0d		 jmp	 SHORT $L1443
$L1433:

; 229  :       /*------------------------------------------------------------
; 230  :         There are no peaks in the baseband!
; 231  :       ------------------------------------------------------------*/
; 232  :       fRefinedPitchPeriod = fCoarsePitchPeriod;

  0025a	8b 4d b8	 mov	 ecx, DWORD PTR _fCoarsePitchPeriod$[ebp]
  0025d	89 4d e4	 mov	 DWORD PTR _fRefinedPitchPeriod$[ebp], ecx

; 233  :       fRhoRefined         = 0.0;

  00260	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _fRhoRefined$[ebp], 0
$L1443:

; 234  :    } /* end of else for condition: (iBasePeakCount>0) */
; 235  : 
; 236  : 
; 237  :    /*-----------------------------------------------------------------
; 238  :      Compute the coarse pitch voicing probability
; 239  :    -----------------------------------------------------------------*/
; 240  :    PvLastTime = *pfPv_km1;

  00267	8b 55 08	 mov	 edx, DWORD PTR _pfPv_km1$[ebp]
  0026a	8b 02		 mov	 eax, DWORD PTR [edx]
  0026c	89 45 e8	 mov	 DWORD PTR _PvLastTime$[ebp], eax

; 241  :    fdBmin     = DBMID + (DBMIN - DBMID)*PvLastTime;

  0026f	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@bf000000
  00275	d8 4d e8	 fmul	 DWORD PTR _PvLastTime$[ebp]
  00278	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@40900000
  0027e	d9 5d d8	 fstp	 DWORD PTR _fdBmin$[ebp]

; 242  :    PvFinal    = ComputePv (fdBmin, DBMAX, fRhoRefined);

  00281	8b 4d f0	 mov	 ecx, DWORD PTR _fRhoRefined$[ebp]
  00284	51		 push	 ecx
  00285	68 00 00 50 41	 push	 1095761920		; 41500000H
  0028a	8b 55 d8	 mov	 edx, DWORD PTR _fdBmin$[ebp]
  0028d	52		 push	 edx
  0028e	e8 00 00 00 00	 call	 _ComputePv@12
  00293	d9 5d dc	 fstp	 DWORD PTR _PvFinal$[ebp]

; 243  :    *pfPv_km1  = PvFinal;

  00296	8b 45 08	 mov	 eax, DWORD PTR _pfPv_km1$[ebp]
  00299	8b 4d dc	 mov	 ecx, DWORD PTR _PvFinal$[ebp]
  0029c	89 08		 mov	 DWORD PTR [eax], ecx

; 244  : 
; 245  :    /*-----------------------------------------------------------------
; 246  :      Use the refined pitch and voicing 
; 247  :    -----------------------------------------------------------------*/
; 248  :    *pfPitchPeriod = fRefinedPitchPeriod;

  0029e	8b 55 10	 mov	 edx, DWORD PTR _pfPitchPeriod$[ebp]
  002a1	8b 45 e4	 mov	 eax, DWORD PTR _fRefinedPitchPeriod$[ebp]
  002a4	89 02		 mov	 DWORD PTR [edx], eax

; 249  :    *pfPv          = PvFinal;

  002a6	8b 4d 14	 mov	 ecx, DWORD PTR _pfPv$[ebp]
  002a9	8b 55 dc	 mov	 edx, DWORD PTR _PvFinal$[ebp]
  002ac	89 11		 mov	 DWORD PTR [ecx], edx

; 250  : 
; 251  : } /*VoxVoicing()*/

  002ae	8b e5		 mov	 esp, ebp
  002b0	5d		 pop	 ebp
  002b1	c2 1c 00	 ret	 28			; 0000001cH
_VoxSTCVoicing@28 ENDP
_TEXT	ENDS
PUBLIC	__real@c1200000
EXTRN	_log10:NEAR
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _ComputePv@12
_TEXT	SEGMENT
tv90 = -12
_fSNRdB$ = -8
_fPv$ = -4
_fdBmin$ = 8
_fdBmax$ = 12
_fRho$ = 16
_ComputePv@12 PROC NEAR					; COMDAT

; 287  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 288  :    float fSNRdB;
; 289  :    float fPv;
; 290  : 
; 291  :    /*-----------------------------------------------------------------
; 292  :      Check for numerical instabilities
; 293  :    -----------------------------------------------------------------*/
; 294  :    if (fRho <= 0.0F)

  00006	d9 45 10	 fld	 DWORD PTR _fRho$[ebp]
  00009	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  0000f	df e0		 fnstsw	 ax
  00011	f6 c4 41	 test	 ah, 65			; 00000041H
  00014	7a 07		 jp	 SHORT $L1453

; 295  :             fRho = 0.000001F;

  00016	c7 45 10 bd 37
	86 35		 mov	 DWORD PTR _fRho$[ebp], 897988541 ; 358637bdH
$L1453:

; 296  :    if (fRho >= 1.0F)

  0001d	d9 45 10	 fld	 DWORD PTR _fRho$[ebp]
  00020	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f800000
  00026	df e0		 fnstsw	 ax
  00028	f6 c4 01	 test	 ah, 1
  0002b	75 07		 jne	 SHORT $L1454

; 297  :             fRho = 0.999999F;

  0002d	c7 45 10 ef ff
	7f 3f		 mov	 DWORD PTR _fRho$[ebp], 1065353199 ; 3f7fffefH
$L1454:

; 298  :  
; 299  :    /*-----------------------------------------------------------------
; 300  :      Convert fRho to dB
; 301  :    -----------------------------------------------------------------*/
; 302  :    fSNRdB = -10.0F*(float)log10(1.0F - fRho);          /* SNR in dB */

  00034	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  0003a	d8 65 10	 fsub	 DWORD PTR _fRho$[ebp]
  0003d	83 ec 08	 sub	 esp, 8
  00040	dd 1c 24	 fstp	 QWORD PTR [esp]
  00043	e8 00 00 00 00	 call	 _log10
  00048	83 c4 08	 add	 esp, 8
  0004b	d9 55 f4	 fst	 DWORD PTR tv90[ebp]
  0004e	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@c1200000
  00054	d9 55 f8	 fst	 DWORD PTR _fSNRdB$[ebp]

; 303  : 
; 304  :    /*-----------------------------------------------------------------
; 305  :      Voicing probability is linear in dB SNR
; 306  :    -----------------------------------------------------------------*/
; 307  :    if (fSNRdB < fdBmin)

  00057	d8 5d 08	 fcomp	 DWORD PTR _fdBmin$[ebp]
  0005a	df e0		 fnstsw	 ax
  0005c	f6 c4 05	 test	 ah, 5
  0005f	7a 09		 jp	 SHORT $L1456

; 308  :       fPv = 0.0F;      /* fully unvoiced */

  00061	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fPv$[ebp], 0

; 309  : 
; 310  :    else if (fSNRdB > fdBmax)

  00068	eb 27		 jmp	 SHORT $L1457
$L1456:
  0006a	d9 45 f8	 fld	 DWORD PTR _fSNRdB$[ebp]
  0006d	d8 5d 0c	 fcomp	 DWORD PTR _fdBmax$[ebp]
  00070	df e0		 fnstsw	 ax
  00072	f6 c4 41	 test	 ah, 65			; 00000041H
  00075	75 09		 jne	 SHORT $L1458

; 311  :       fPv = 1.0F;      /* fully voiced */

  00077	c7 45 fc 00 00
	80 3f		 mov	 DWORD PTR _fPv$[ebp], 1065353216 ; 3f800000H

; 312  : 
; 313  :    else 

  0007e	eb 11		 jmp	 SHORT $L1457
$L1458:

; 314  :       /*------------------------------------------------
; 315  :         if (fSNRdB >= fdBmin && fSNRdB <= fdBmax) 
; 316  :              (partial voicing)
; 317  :       ------------------------------------------------*/
; 318  :       fPv = (fSNRdB - fdBmin)/(fdBmax - fdBmin);

  00080	d9 45 f8	 fld	 DWORD PTR _fSNRdB$[ebp]
  00083	d8 65 08	 fsub	 DWORD PTR _fdBmin$[ebp]
  00086	d9 45 0c	 fld	 DWORD PTR _fdBmax$[ebp]
  00089	d8 65 08	 fsub	 DWORD PTR _fdBmin$[ebp]
  0008c	de f9		 fdivp	 ST(1), ST(0)
  0008e	d9 5d fc	 fstp	 DWORD PTR _fPv$[ebp]
$L1457:

; 319  : 
; 320  :    return( fPv );

  00091	d9 45 fc	 fld	 DWORD PTR _fPv$[ebp]

; 321  : } /* ComputePv() */

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 0c 00	 ret	 12			; 0000000cH
_ComputePv@12 ENDP
_TEXT	ENDS
PUBLIC	_ModifyPv@20
PUBLIC	__real@3c23d70a
PUBLIC	__real@3ee66666
PUBLIC	__real@3f000000
PUBLIC	__real@3d924925
PUBLIC	__real@3fa00000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f333333
PUBLIC	__real@3e99999a
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3ee66666
CONST	SEGMENT
__real@3ee66666 DD 03ee66666r			; 0.45
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3d924925
CONST	SEGMENT
__real@3d924925 DD 03d924925r			; 0.0714286
CONST	ENDS
;	COMDAT __real@3fa00000
CONST	SEGMENT
__real@3fa00000 DD 03fa00000r			; 1.25
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _ModifyPv@20
_TEXT	SEGMENT
_fEstPv$ = -4
_fCorrCost$ = 8
_fPv$ = 12
_fPv_1$ = 16
_fPitch$ = 20
_fPitch_1$ = 24
_ModifyPv@20 PROC NEAR					; COMDAT

; 362  : {     

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 363  :   float fEstPv;
; 364  : 
; 365  :   /*-----------------------------------------------------------------
; 366  :     If fCorrCost is negative, fPv should be 0.
; 367  :   -----------------------------------------------------------------*/
; 368  :   if (fCorrCost <= 0.01F)   /* unvoiced speech */

  00004	d9 45 08	 fld	 DWORD PTR _fCorrCost$[ebp]
  00007	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3c23d70a
  0000d	df e0		 fnstsw	 ax
  0000f	f6 c4 41	 test	 ah, 65			; 00000041H
  00012	7a 07		 jp	 SHORT $L1472

; 369  :     fPv = 0.0F;

  00014	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _fPv$[ebp], 0
$L1472:

; 370  : 
; 371  :   /*-----------------------------------------------------------------
; 372  :     If fCorrCost is large enough and fPv is too small, we have to
; 373  :       reset fPv to a larger number.
; 374  :   -----------------------------------------------------------------*/
; 375  :   if (fCorrCost >= 0.45F)   /* voiced speech */

  0001b	d9 45 08	 fld	 DWORD PTR _fCorrCost$[ebp]
  0001e	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3ee66666
  00024	df e0		 fnstsw	 ax
  00026	f6 c4 01	 test	 ah, 1
  00029	75 44		 jne	 SHORT $L1473

; 376  :   {
; 377  :     fEstPv = fCorrCost - 0.45F;

  0002b	d9 45 08	 fld	 DWORD PTR _fCorrCost$[ebp]
  0002e	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3ee66666
  00034	d9 5d fc	 fstp	 DWORD PTR _fEstPv$[ebp]

; 378  : 
; 379  :     if ((fEstPv * (fPitch * 0.5F)) < 1.0F)    /* at least one harmonic */

  00037	d9 45 14	 fld	 DWORD PTR _fPitch$[ebp]
  0003a	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00040	d8 4d fc	 fmul	 DWORD PTR _fEstPv$[ebp]
  00043	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f800000
  00049	df e0		 fnstsw	 ax
  0004b	f6 c4 05	 test	 ah, 5
  0004e	7a 0c		 jp	 SHORT $L1474

; 380  :       fEstPv += MIN_QPV;

  00050	d9 45 fc	 fld	 DWORD PTR _fEstPv$[ebp]
  00053	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3d924925
  00059	d9 5d fc	 fstp	 DWORD PTR _fEstPv$[ebp]
$L1474:

; 381  : 
; 382  :     if (fEstPv > fPv)

  0005c	d9 45 fc	 fld	 DWORD PTR _fEstPv$[ebp]
  0005f	d8 5d 0c	 fcomp	 DWORD PTR _fPv$[ebp]
  00062	df e0		 fnstsw	 ax
  00064	f6 c4 41	 test	 ah, 65			; 00000041H
  00067	75 06		 jne	 SHORT $L1473

; 383  :       fPv = fEstPv;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _fEstPv$[ebp]
  0006c	89 45 0c	 mov	 DWORD PTR _fPv$[ebp], eax
$L1473:

; 384  :   }
; 385  : 
; 386  :   /*-----------------------------------------------------------------
; 387  :     Now smooth the fPv
; 388  :   -----------------------------------------------------------------*/
; 389  :   if (fPv_1 > fPv && fPv_1 >= MIN_QPV) 

  0006f	d9 45 10	 fld	 DWORD PTR _fPv_1$[ebp]
  00072	d8 5d 0c	 fcomp	 DWORD PTR _fPv$[ebp]
  00075	df e0		 fnstsw	 ax
  00077	f6 c4 41	 test	 ah, 65			; 00000041H
  0007a	75 69		 jne	 SHORT $L1476
  0007c	d9 45 10	 fld	 DWORD PTR _fPv_1$[ebp]
  0007f	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3d924925
  00085	df e0		 fnstsw	 ax
  00087	f6 c4 01	 test	 ah, 1
  0008a	75 59		 jne	 SHORT $L1476

; 390  :   {
; 391  :     if ((fPitch < 1.25F * fPitch_1)&&(fPitch > 0.8F * fPitch_1))

  0008c	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3fa00000
  00092	d8 4d 18	 fmul	 DWORD PTR _fPitch_1$[ebp]
  00095	d8 5d 14	 fcomp	 DWORD PTR _fPitch$[ebp]
  00098	df e0		 fnstsw	 ax
  0009a	f6 c4 41	 test	 ah, 65			; 00000041H
  0009d	75 2a		 jne	 SHORT $L1477
  0009f	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f4ccccd
  000a5	d8 4d 18	 fmul	 DWORD PTR _fPitch_1$[ebp]
  000a8	d8 5d 14	 fcomp	 DWORD PTR _fPitch$[ebp]
  000ab	df e0		 fnstsw	 ax
  000ad	f6 c4 05	 test	 ah, 5
  000b0	7a 17		 jp	 SHORT $L1477

; 392  :       fPv = 0.7F*fPv + 0.3F*fPv_1;

  000b2	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f333333
  000b8	d8 4d 0c	 fmul	 DWORD PTR _fPv$[ebp]
  000bb	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3e99999a
  000c1	d8 4d 10	 fmul	 DWORD PTR _fPv_1$[ebp]
  000c4	de c1		 faddp	 ST(1), ST(0)
  000c6	d9 5d 0c	 fstp	 DWORD PTR _fPv$[ebp]
$L1477:

; 393  :     
; 394  :     if (fPv < MIN_QPV)

  000c9	d9 45 0c	 fld	 DWORD PTR _fPv$[ebp]
  000cc	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3d924925
  000d2	df e0		 fnstsw	 ax
  000d4	f6 c4 05	 test	 ah, 5
  000d7	7a 0c		 jp	 SHORT $L1476

; 395  :       fPv += MIN_QPV;

  000d9	d9 45 0c	 fld	 DWORD PTR _fPv$[ebp]
  000dc	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3d924925
  000e2	d9 5d 0c	 fstp	 DWORD PTR _fPv$[ebp]
$L1476:

; 396  :   }
; 397  :   
; 398  :   return fPv;

  000e5	d9 45 0c	 fld	 DWORD PTR _fPv$[ebp]

; 399  : 
; 400  : } /* ModifyPv() */

  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 14 00	 ret	 20			; 00000014H
_ModifyPv@20 ENDP
_TEXT	ENDS
END
