; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\vemfrm12.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _framesInBufferVR12@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _seekForwardVR12@32
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_framesInBufferVR12@8
PUBLIC	_seekForwardVR12@32
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\vemfrm12.c
;	COMDAT _framesInBufferVR12@8
_TEXT	SEGMENT
_NumBits$ = -36
_BufferSize$ = -32
_ReadByteOffset$ = -28
_WriteBitOffset$ = -21
_BitsRead$ = -20
_BitsInBuffer$ = -16
_ReadBitOffset$ = -9
_WriteByteOffset$ = -8
_pBuffer$ = -4
_hvciCodecIOBlk$ = 8
_pwNumFrames$ = 12
_framesInBufferVR12@8 PROC NEAR				; COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 54   :    unsigned short  ReadByteOffset,WriteByteOffset;
; 55   :    unsigned char   ReadBitOffset, WriteBitOffset;
; 56   :    unsigned short  BufferSize;
; 57   :    unsigned long   BitsInBuffer;
; 58   :    unsigned long   BitsRead;
; 59   :    unsigned short  NumBits;
; 60   :    unsigned char   *pBuffer;
; 61   : 
; 62   :    ReadByteOffset  = hvciCodecIOBlk->wVoxBufferReadByteOffset;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hvciCodecIOBlk$[ebp]
  00009	66 8b 48 0e	 mov	 cx, WORD PTR [eax+14]
  0000d	66 89 4d e4	 mov	 WORD PTR _ReadByteOffset$[ebp], cx

; 63   :    WriteByteOffset = hvciCodecIOBlk->wVoxBufferWriteByteOffset;

  00011	8b 55 08	 mov	 edx, DWORD PTR _hvciCodecIOBlk$[ebp]
  00014	66 8b 42 12	 mov	 ax, WORD PTR [edx+18]
  00018	66 89 45 f8	 mov	 WORD PTR _WriteByteOffset$[ebp], ax

; 64   :    ReadBitOffset   = hvciCodecIOBlk->chVoxBufferReadBitOffset;

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _hvciCodecIOBlk$[ebp]
  0001f	8a 51 10	 mov	 dl, BYTE PTR [ecx+16]
  00022	88 55 f7	 mov	 BYTE PTR _ReadBitOffset$[ebp], dl

; 65   :    WriteBitOffset  = hvciCodecIOBlk->chVoxBufferWriteBitOffset;

  00025	8b 45 08	 mov	 eax, DWORD PTR _hvciCodecIOBlk$[ebp]
  00028	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  0002b	88 4d eb	 mov	 BYTE PTR _WriteBitOffset$[ebp], cl

; 66   :    BufferSize      = hvciCodecIOBlk->wVoxBufferSize;

  0002e	8b 55 08	 mov	 edx, DWORD PTR _hvciCodecIOBlk$[ebp]
  00031	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  00035	66 89 45 e0	 mov	 WORD PTR _BufferSize$[ebp], ax

; 67   :    pBuffer         = hvciCodecIOBlk->pVoxBuffer;

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _hvciCodecIOBlk$[ebp]
  0003c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0003f	89 55 fc	 mov	 DWORD PTR _pBuffer$[ebp], edx

; 68   :    BitsRead        = 0;

  00042	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _BitsRead$[ebp], 0

; 69   :   *pwNumFrames     = 0;

  00049	8b 45 0c	 mov	 eax, DWORD PTR _pwNumFrames$[ebp]
  0004c	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 70   : 
; 71   :    /* First we calculate the number of bits in the buffer. We split this      */
; 72   :    /* into two cases. Case 1 is without wrap-around of the circular buffer    */
; 73   :    /* Case 2 is with wrap-around of the circular buffer.                      */
; 74   :    if(WriteByteOffset>=ReadByteOffset) /* This means we have not wraped       */

  00051	0f b7 4d f8	 movzx	 ecx, WORD PTR _WriteByteOffset$[ebp]
  00055	0f b7 55 e4	 movzx	 edx, WORD PTR _ReadByteOffset$[ebp]
  00059	3b ca		 cmp	 ecx, edx
  0005b	7c 2f		 jl	 SHORT $L568

; 75   :                                        /* around in the buffer.               */
; 76   :    {
; 77   :       BitsInBuffer = (WriteByteOffset-ReadByteOffset+1)*8;

  0005d	0f b7 45 f8	 movzx	 eax, WORD PTR _WriteByteOffset$[ebp]
  00061	0f b7 4d e4	 movzx	 ecx, WORD PTR _ReadByteOffset$[ebp]
  00065	2b c1		 sub	 eax, ecx
  00067	8d 14 c5 08 00
	00 00		 lea	 edx, DWORD PTR [eax*8+8]
  0006e	89 55 f0	 mov	 DWORD PTR _BitsInBuffer$[ebp], edx

; 78   :       BitsInBuffer = BitsInBuffer-ReadBitOffset-(8-WriteBitOffset);

  00071	0f b6 45 f7	 movzx	 eax, BYTE PTR _ReadBitOffset$[ebp]
  00075	8b 4d f0	 mov	 ecx, DWORD PTR _BitsInBuffer$[ebp]
  00078	2b c8		 sub	 ecx, eax
  0007a	0f b6 55 eb	 movzx	 edx, BYTE PTR _WriteBitOffset$[ebp]
  0007e	b8 08 00 00 00	 mov	 eax, 8
  00083	2b c2		 sub	 eax, edx
  00085	2b c8		 sub	 ecx, eax
  00087	89 4d f0	 mov	 DWORD PTR _BitsInBuffer$[ebp], ecx

; 79   :    }
; 80   :    else /* This is the case whereby the buffer has wrapped around.            */

  0008a	eb 33		 jmp	 SHORT $L571
$L568:

; 81   :    {
; 82   :       BitsInBuffer = (WriteByteOffset+(BufferSize-ReadByteOffset)+1)*8;

  0008c	0f b7 4d f8	 movzx	 ecx, WORD PTR _WriteByteOffset$[ebp]
  00090	0f b7 55 e0	 movzx	 edx, WORD PTR _BufferSize$[ebp]
  00094	0f b7 45 e4	 movzx	 eax, WORD PTR _ReadByteOffset$[ebp]
  00098	2b d0		 sub	 edx, eax
  0009a	03 ca		 add	 ecx, edx
  0009c	8d 0c cd 08 00
	00 00		 lea	 ecx, DWORD PTR [ecx*8+8]
  000a3	89 4d f0	 mov	 DWORD PTR _BitsInBuffer$[ebp], ecx

; 83   :       BitsInBuffer = BitsInBuffer-ReadBitOffset-(8-WriteBitOffset);

  000a6	0f b6 55 f7	 movzx	 edx, BYTE PTR _ReadBitOffset$[ebp]
  000aa	8b 45 f0	 mov	 eax, DWORD PTR _BitsInBuffer$[ebp]
  000ad	2b c2		 sub	 eax, edx
  000af	0f b6 4d eb	 movzx	 ecx, BYTE PTR _WriteBitOffset$[ebp]
  000b3	ba 08 00 00 00	 mov	 edx, 8
  000b8	2b d1		 sub	 edx, ecx
  000ba	2b c2		 sub	 eax, edx
  000bc	89 45 f0	 mov	 DWORD PTR _BitsInBuffer$[ebp], eax
$L571:

; 84   :    }
; 85   : 
; 86   :   /* Now read until we exhaust the number of bits we have in the buffer */
; 87   :    while(BitsRead < BitsInBuffer)

  000bf	8b 45 ec	 mov	 eax, DWORD PTR _BitsRead$[ebp]
  000c2	3b 45 f0	 cmp	 eax, DWORD PTR _BitsInBuffer$[ebp]
  000c5	73 43		 jae	 SHORT $L572

; 88   :    {
; 89   :      (*pwNumFrames)++;

  000c7	8b 4d 0c	 mov	 ecx, DWORD PTR _pwNumFrames$[ebp]
  000ca	66 8b 11	 mov	 dx, WORD PTR [ecx]
  000cd	66 83 c2 01	 add	 dx, 1
  000d1	8b 45 0c	 mov	 eax, DWORD PTR _pwNumFrames$[ebp]
  000d4	66 89 10	 mov	 WORD PTR [eax], dx

; 90   :       seekForwardVR12(ReadByteOffset, ReadBitOffset, BufferSize, pBuffer, 1,
; 91   :                       &ReadByteOffset, &ReadBitOffset, &NumBits);

  000d7	8d 4d dc	 lea	 ecx, DWORD PTR _NumBits$[ebp]
  000da	51		 push	 ecx
  000db	8d 55 f7	 lea	 edx, DWORD PTR _ReadBitOffset$[ebp]
  000de	52		 push	 edx
  000df	8d 45 e4	 lea	 eax, DWORD PTR _ReadByteOffset$[ebp]
  000e2	50		 push	 eax
  000e3	6a 01		 push	 1
  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  000e8	51		 push	 ecx
  000e9	66 8b 55 e0	 mov	 dx, WORD PTR _BufferSize$[ebp]
  000ed	52		 push	 edx
  000ee	8a 45 f7	 mov	 al, BYTE PTR _ReadBitOffset$[ebp]
  000f1	50		 push	 eax
  000f2	66 8b 4d e4	 mov	 cx, WORD PTR _ReadByteOffset$[ebp]
  000f6	51		 push	 ecx
  000f7	e8 00 00 00 00	 call	 _seekForwardVR12@32

; 92   :       BitsRead += NumBits;

  000fc	0f b7 55 dc	 movzx	 edx, WORD PTR _NumBits$[ebp]
  00100	8b 45 ec	 mov	 eax, DWORD PTR _BitsRead$[ebp]
  00103	03 c2		 add	 eax, edx
  00105	89 45 ec	 mov	 DWORD PTR _BitsRead$[ebp], eax

; 93   :    }

  00108	eb b5		 jmp	 SHORT $L571
$L572:

; 94   :    if(BitsRead>BitsInBuffer)

  0010a	8b 4d ec	 mov	 ecx, DWORD PTR _BitsRead$[ebp]
  0010d	3b 4d f0	 cmp	 ecx, DWORD PTR _BitsInBuffer$[ebp]
  00110	76 10		 jbe	 SHORT $L558

; 95   :       (*pwNumFrames)--;

  00112	8b 55 0c	 mov	 edx, DWORD PTR _pwNumFrames$[ebp]
  00115	66 8b 02	 mov	 ax, WORD PTR [edx]
  00118	66 2d 01 00	 sub	 ax, 1
  0011c	8b 4d 0c	 mov	 ecx, DWORD PTR _pwNumFrames$[ebp]
  0011f	66 89 01	 mov	 WORD PTR [ecx], ax
$L558:

; 96   : }

  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c2 08 00	 ret	 8
_framesInBufferVR12@8 ENDP
_TEXT	ENDS
EXTRN	_BitUnpackCBuffer@12:NEAR
; Function compile flags: /Odt
;	COMDAT _seekForwardVR12@32
_TEXT	SEGMENT
_CBuffer$ = -48
_DummyRead$ = -24
_CurrentFrames$ = -16
_Class$ = -12
_wBitsInClass$ = -8
_ulReadByteOffset$ = -4
_ReadByteOffset$ = 8
_ReadBitOffset$ = 12
_BufferSize$ = 16
_pBuffer$ = 20
_wNumFrames$ = 24
_pwByteOffset$ = 28
_pchBitOffset$ = 32
_BitsInFrames$ = 36
_seekForwardVR12@32 PROC NEAR				; COMDAT

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 114  :    C_BUFFER_TYPE   CBuffer; 
; 115  :    unsigned short  CurrentFrames;
; 116  :    unsigned char   DummyRead[BYTESPERFRAME_VR]; /* the maximum bytes/frame */ 
; 117  :    unsigned short  Class, wBitsInClass=0;

  00006	66 c7 45 f8 00
	00		 mov	 WORD PTR _wBitsInClass$[ebp], 0

; 118  :    unsigned long   ulReadByteOffset;
; 119  : 
; 120  :    CurrentFrames       = 0;

  0000c	66 c7 45 f0 00
	00		 mov	 WORD PTR _CurrentFrames$[ebp], 0

; 121  :    *BitsInFrames       = 0;

  00012	8b 45 24	 mov	 eax, DWORD PTR _BitsInFrames$[ebp]
  00015	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 122  :    CBuffer.wBufferSize           = BufferSize;

  0001a	66 8b 4d 10	 mov	 cx, WORD PTR _BufferSize$[ebp]
  0001e	66 89 4d d4	 mov	 WORD PTR _CBuffer$[ebp+4], cx

; 123  :    CBuffer.pBufferReadByteOffset = &ReadByteOffset;

  00022	8d 55 08	 lea	 edx, DWORD PTR _ReadByteOffset$[ebp]
  00025	89 55 d8	 mov	 DWORD PTR _CBuffer$[ebp+8], edx

; 124  :    CBuffer.pBufferReadBitOffset  = &ReadBitOffset;

  00028	8d 45 0c	 lea	 eax, DWORD PTR _ReadBitOffset$[ebp]
  0002b	89 45 dc	 mov	 DWORD PTR _CBuffer$[ebp+12], eax

; 125  :    CBuffer.pBuffer               = pBuffer;   

  0002e	8b 4d 14	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  00031	89 4d d0	 mov	 DWORD PTR _CBuffer$[ebp], ecx
$L598:

; 126  : 
; 127  :    while (CurrentFrames < wNumFrames)

  00034	0f b7 55 f0	 movzx	 edx, WORD PTR _CurrentFrames$[ebp]
  00038	0f b7 45 18	 movzx	 eax, WORD PTR _wNumFrames$[ebp]
  0003c	3b d0		 cmp	 edx, eax
  0003e	0f 8d e7 00 00
	00		 jge	 $L599

; 128  :    {
; 129  :       BitUnpackCBuffer(&CBuffer, DummyRead, CLASS_BITS_VR12);

  00044	6a 02		 push	 2
  00046	8d 4d e8	 lea	 ecx, DWORD PTR _DummyRead$[ebp]
  00049	51		 push	 ecx
  0004a	8d 55 d0	 lea	 edx, DWORD PTR _CBuffer$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _BitUnpackCBuffer@12

; 130  :       Class = (unsigned short) DummyRead[0];

  00053	66 0f b6 45 e8	 movzx	 ax, BYTE PTR _DummyRead$[ebp]
  00058	66 89 45 f4	 mov	 WORD PTR _Class$[ebp], ax

; 131  :       *BitsInFrames += CLASS_BITS_VR12;

  0005c	8b 4d 24	 mov	 ecx, DWORD PTR _BitsInFrames$[ebp]
  0005f	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00062	83 c2 02	 add	 edx, 2
  00065	8b 45 24	 mov	 eax, DWORD PTR _BitsInFrames$[ebp]
  00068	66 89 10	 mov	 WORD PTR [eax], dx

; 132  : 
; 133  :       if (Class == UV_FRAME)

  0006b	0f b7 4d f4	 movzx	 ecx, WORD PTR _Class$[ebp]
  0006f	83 f9 02	 cmp	 ecx, 2
  00072	75 08		 jne	 SHORT $L601

; 134  :          wBitsInClass=TOTAL_BITS_VR12_UNVOICED-CLASS_BITS_VR12;

  00074	66 c7 45 f8 0d
	00		 mov	 WORD PTR _wBitsInClass$[ebp], 13 ; 0000000dH

; 135  :       else if (Class == V_FRAME)  

  0007a	eb 27		 jmp	 SHORT $L602
$L601:
  0007c	0f b7 55 f4	 movzx	 edx, WORD PTR _Class$[ebp]
  00080	85 d2		 test	 edx, edx
  00082	75 08		 jne	 SHORT $L603

; 136  :          wBitsInClass=TOTAL_BITS_VR12_VOICED-CLASS_BITS_VR12;

  00084	66 c7 45 f8 24
	00		 mov	 WORD PTR _wBitsInClass$[ebp], 36 ; 00000024H

; 137  :       else if (Class == MIX_FRAME)

  0008a	eb 17		 jmp	 SHORT $L602
$L603:
  0008c	0f b7 45 f4	 movzx	 eax, WORD PTR _Class$[ebp]
  00090	83 f8 01	 cmp	 eax, 1
  00093	75 08		 jne	 SHORT $L605

; 138  :          wBitsInClass=TOTAL_BITS_VR12_MIXED-CLASS_BITS_VR12;

  00095	66 c7 45 f8 27
	00		 mov	 WORD PTR _wBitsInClass$[ebp], 39 ; 00000027H

; 139  :       else

  0009b	eb 06		 jmp	 SHORT $L602
$L605:

; 140  :          wBitsInClass=0;

  0009d	66 c7 45 f8 00
	00		 mov	 WORD PTR _wBitsInClass$[ebp], 0
$L602:

; 141  : 
; 142  :       (*CBuffer.pBufferReadBitOffset)+=wBitsInClass;

  000a3	0f b7 4d f8	 movzx	 ecx, WORD PTR _wBitsInClass$[ebp]
  000a7	8b 55 dc	 mov	 edx, DWORD PTR _CBuffer$[ebp+12]
  000aa	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000ad	03 c1		 add	 eax, ecx
  000af	8b 4d dc	 mov	 ecx, DWORD PTR _CBuffer$[ebp+12]
  000b2	88 01		 mov	 BYTE PTR [ecx], al

; 143  :       *BitsInFrames += wBitsInClass;  

  000b4	0f b7 55 f8	 movzx	 edx, WORD PTR _wBitsInClass$[ebp]
  000b8	8b 45 24	 mov	 eax, DWORD PTR _BitsInFrames$[ebp]
  000bb	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000be	03 ca		 add	 ecx, edx
  000c0	8b 55 24	 mov	 edx, DWORD PTR _BitsInFrames$[ebp]
  000c3	66 89 0a	 mov	 WORD PTR [edx], cx

; 144  :       
; 145  :       /*-------------------------------------------------------------
; 146  :         We have to be careful here since the sum
; 147  :           ulReadByteOffset + (ReadBitOffset/8) could be greater
; 148  :           than the maximum (unsigned short).  We use an
; 149  :           (unsigned long) to do the computation and testing.
; 150  :       -------------------------------------------------------------*/
; 151  :       ulReadByteOffset  = (unsigned long) (*CBuffer.pBufferReadByteOffset);

  000c6	8b 45 d8	 mov	 eax, DWORD PTR _CBuffer$[ebp+8]
  000c9	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000cc	89 4d fc	 mov	 DWORD PTR _ulReadByteOffset$[ebp], ecx

; 152  :       ulReadByteOffset += (unsigned long) (ReadBitOffset/8);

  000cf	0f b6 45 0c	 movzx	 eax, BYTE PTR _ReadBitOffset$[ebp]
  000d3	99		 cdq
  000d4	83 e2 07	 and	 edx, 7
  000d7	03 c2		 add	 eax, edx
  000d9	c1 f8 03	 sar	 eax, 3
  000dc	8b 55 fc	 mov	 edx, DWORD PTR _ulReadByteOffset$[ebp]
  000df	03 d0		 add	 edx, eax
  000e1	89 55 fc	 mov	 DWORD PTR _ulReadByteOffset$[ebp], edx

; 153  : 
; 154  :       if ( ulReadByteOffset >= (unsigned long)(CBuffer.wBufferSize) )

  000e4	0f b7 45 d4	 movzx	 eax, WORD PTR _CBuffer$[ebp+4]
  000e8	39 45 fc	 cmp	 DWORD PTR _ulReadByteOffset$[ebp], eax
  000eb	72 0c		 jb	 SHORT $L610

; 155  :          ulReadByteOffset -= (unsigned long) (CBuffer.wBufferSize);

  000ed	0f b7 4d d4	 movzx	 ecx, WORD PTR _CBuffer$[ebp+4]
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _ulReadByteOffset$[ebp]
  000f4	2b d1		 sub	 edx, ecx
  000f6	89 55 fc	 mov	 DWORD PTR _ulReadByteOffset$[ebp], edx
$L610:

; 156  : 
; 157  :       /*-------------------------------------------------------------
; 158  :         After the above test we can guarantee that ulReadByteOffset
; 159  :           can be represented as an (unsigned short).
; 160  :       -------------------------------------------------------------*/
; 161  :       (*CBuffer.pBufferReadByteOffset) = (unsigned short) ulReadByteOffset;

  000f9	8b 45 d8	 mov	 eax, DWORD PTR _CBuffer$[ebp+8]
  000fc	66 8b 4d fc	 mov	 cx, WORD PTR _ulReadByteOffset$[ebp]
  00100	66 89 08	 mov	 WORD PTR [eax], cx

; 162  : 
; 163  :       (*CBuffer.pBufferReadBitOffset)%=8;

  00103	8b 55 dc	 mov	 edx, DWORD PTR _CBuffer$[ebp+12]
  00106	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00109	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0010e	79 05		 jns	 SHORT $L624
  00110	48		 dec	 eax
  00111	83 c8 f8	 or	 eax, -8			; fffffff8H
  00114	40		 inc	 eax
$L624:
  00115	8b 4d dc	 mov	 ecx, DWORD PTR _CBuffer$[ebp+12]
  00118	88 01		 mov	 BYTE PTR [ecx], al

; 164  : 
; 165  :       CurrentFrames++;

  0011a	66 8b 55 f0	 mov	 dx, WORD PTR _CurrentFrames$[ebp]
  0011e	66 83 c2 01	 add	 dx, 1
  00122	66 89 55 f0	 mov	 WORD PTR _CurrentFrames$[ebp], dx

; 166  :    }

  00126	e9 09 ff ff ff	 jmp	 $L598
$L599:

; 167  :    *pwByteOffset = ReadByteOffset;

  0012b	8b 45 1c	 mov	 eax, DWORD PTR _pwByteOffset$[ebp]
  0012e	66 8b 4d 08	 mov	 cx, WORD PTR _ReadByteOffset$[ebp]
  00132	66 89 08	 mov	 WORD PTR [eax], cx

; 168  :    *pchBitOffset = ReadBitOffset;

  00135	8b 55 20	 mov	 edx, DWORD PTR _pchBitOffset$[ebp]
  00138	8a 45 0c	 mov	 al, BYTE PTR _ReadBitOffset$[ebp]
  0013b	88 02		 mov	 BYTE PTR [edx], al

; 169  : 
; 170  : }

  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c2 20 00	 ret	 32			; 00000020H
_seekForwardVR12@32 ENDP
_TEXT	ENDS
END
