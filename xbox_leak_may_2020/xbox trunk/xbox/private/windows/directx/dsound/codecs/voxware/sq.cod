; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\sq.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DL@CLJMGHEK@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OHJAPAEA@pfCodeBook?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FOHMHBAL@iLength?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09FMCBIJCP@iLength?$DO0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@EKMPPGKN@iIndex?$DMiLength?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09ILLECNFF@iIndex?$DO?$DN0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _ScalarQuant@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ScalarLUT@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_ScalarQuant@12
PUBLIC	??_C@_0DL@CLJMGHEK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BD@OHJAPAEA@pfCodeBook?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	??_C@_0M@FOHMHBAL@iLength?5?$DO?50?$AA@		; `string'
EXTRN	__assert:NEAR
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_0DL@CLJMGHEK@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\sq.c
CONST	SEGMENT
??_C@_0DL@CLJMGHEK@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\sq.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OHJAPAEA@pfCodeBook?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BD@OHJAPAEA@pfCodeBook?5?$CB?$DN?5NULL?$AA@ DB 'pfCodeBook != NULL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FOHMHBAL@iLength?5?$DO?50?$AA@
CONST	SEGMENT
??_C@_0M@FOHMHBAL@iLength?5?$DO?50?$AA@ DB 'iLength > 0', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _ScalarQuant@12
_TEXT	SEGMENT
_iIndex$ = -16
_fMinErr$ = -12
_i$ = -8
_fErr$ = -4
_fValue$ = 8
_pfCodeBook$ = 12
_iLength$ = 16
_ScalarQuant@12 PROC NEAR				; COMDAT

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 52   :    int   i;
; 53   :    int   iIndex;
; 54   :    float fMinErr;
; 55   :    float fErr;
; 56   : 
; 57   :    assert( pfCodeBook != NULL);

  00006	83 7d 0c 00	 cmp	 DWORD PTR _pfCodeBook$[ebp], 0
  0000a	75 14		 jne	 SHORT $L934
  0000c	6a 39		 push	 57			; 00000039H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DL@CLJMGHEK@c?3?2xbox?2private?2windows?2directx?2@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OHJAPAEA@pfCodeBook?5?$CB?$DN?5NULL?$AA@
  00018	e8 00 00 00 00	 call	 __assert
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L934:

; 58   :    assert( iLength > 0);

  00020	83 7d 10 00	 cmp	 DWORD PTR _iLength$[ebp], 0
  00024	7f 14		 jg	 SHORT $L935
  00026	6a 3a		 push	 58			; 0000003aH
  00028	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DL@CLJMGHEK@c?3?2xbox?2private?2windows?2directx?2@
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@FOHMHBAL@iLength?5?$DO?50?$AA@
  00032	e8 00 00 00 00	 call	 __assert
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$L935:

; 59   : 
; 60   :    iIndex   = 0;

  0003a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iIndex$[ebp], 0

; 61   :    fMinErr  = fValue-pfCodeBook[0];

  00041	8b 55 0c	 mov	 edx, DWORD PTR _pfCodeBook$[ebp]
  00044	d9 45 08	 fld	 DWORD PTR _fValue$[ebp]
  00047	d8 22		 fsub	 DWORD PTR [edx]
  00049	d9 55 f4	 fst	 DWORD PTR _fMinErr$[ebp]

; 62   :    fMinErr *= fMinErr;

  0004c	d8 4d f4	 fmul	 DWORD PTR _fMinErr$[ebp]
  0004f	d9 5d f4	 fstp	 DWORD PTR _fMinErr$[ebp]

; 63   : 
; 64   :    for (i=1;i<iLength;i++)

  00052	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00059	eb 09		 jmp	 SHORT $L900
$L901:
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0005e	83 c0 01	 add	 eax, 1
  00061	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L900:
  00064	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00067	3b 4d 10	 cmp	 ecx, DWORD PTR _iLength$[ebp]
  0006a	7d 2d		 jge	 SHORT $L902

; 65   :    {
; 66   :       fErr  = fValue-pfCodeBook[i];

  0006c	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _pfCodeBook$[ebp]
  00072	d9 45 08	 fld	 DWORD PTR _fValue$[ebp]
  00075	d8 24 90	 fsub	 DWORD PTR [eax+edx*4]
  00078	d9 55 fc	 fst	 DWORD PTR _fErr$[ebp]

; 67   :       fErr *= fErr;

  0007b	d8 4d fc	 fmul	 DWORD PTR _fErr$[ebp]
  0007e	d9 55 fc	 fst	 DWORD PTR _fErr$[ebp]

; 68   :       if (fErr < fMinErr)

  00081	d8 5d f4	 fcomp	 DWORD PTR _fMinErr$[ebp]
  00084	df e0		 fnstsw	 ax
  00086	f6 c4 05	 test	 ah, 5
  00089	7a 0c		 jp	 SHORT $L903

; 69   :       {
; 70   :          fMinErr = fErr;

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _fErr$[ebp]
  0008e	89 4d f4	 mov	 DWORD PTR _fMinErr$[ebp], ecx

; 71   :          iIndex = i;

  00091	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00094	89 55 f0	 mov	 DWORD PTR _iIndex$[ebp], edx
$L903:

; 72   :       }
; 73   :    }

  00097	eb c2		 jmp	 SHORT $L901
$L902:

; 74   : 
; 75   :    return( iIndex );

  00099	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$[ebp]

; 76   : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 0c 00	 ret	 12			; 0000000cH
_ScalarQuant@12 ENDP
_TEXT	ENDS
PUBLIC	_ScalarLUT@12
PUBLIC	??_C@_09FMCBIJCP@iLength?$DO0?$AA@		; `string'
PUBLIC	??_C@_0P@EKMPPGKN@iIndex?$DMiLength?$AA@	; `string'
PUBLIC	??_C@_09ILLECNFF@iIndex?$DO?$DN0?$AA@		; `string'
;	COMDAT ??_C@_09FMCBIJCP@iLength?$DO0?$AA@
CONST	SEGMENT
??_C@_09FMCBIJCP@iLength?$DO0?$AA@ DB 'iLength>0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EKMPPGKN@iIndex?$DMiLength?$AA@
CONST	SEGMENT
??_C@_0P@EKMPPGKN@iIndex?$DMiLength?$AA@ DB 'iIndex<iLength', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ILLECNFF@iIndex?$DO?$DN0?$AA@
CONST	SEGMENT
??_C@_09ILLECNFF@iIndex?$DO?$DN0?$AA@ DB 'iIndex>=0', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _ScalarLUT@12
_TEXT	SEGMENT
_pfCodeBook$ = 8
_iLength$ = 12
_iIndex$ = 16
_ScalarLUT@12 PROC NEAR					; COMDAT

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 97   :    assert( pfCodeBook != NULL);

  00003	83 7d 08 00	 cmp	 DWORD PTR _pfCodeBook$[ebp], 0
  00007	75 14		 jne	 SHORT $L940
  00009	6a 61		 push	 97			; 00000061H
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DL@CLJMGHEK@c?3?2xbox?2private?2windows?2directx?2@
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OHJAPAEA@pfCodeBook?5?$CB?$DN?5NULL?$AA@
  00015	e8 00 00 00 00	 call	 __assert
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L940:

; 98   :    assert( iLength>0 );

  0001d	83 7d 0c 00	 cmp	 DWORD PTR _iLength$[ebp], 0
  00021	7f 14		 jg	 SHORT $L941
  00023	6a 62		 push	 98			; 00000062H
  00025	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DL@CLJMGHEK@c?3?2xbox?2private?2windows?2directx?2@
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09FMCBIJCP@iLength?$DO0?$AA@
  0002f	e8 00 00 00 00	 call	 __assert
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
$L941:

; 99   :    assert( iIndex<iLength );

  00037	8b 55 10	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0003a	3b 55 0c	 cmp	 edx, DWORD PTR _iLength$[ebp]
  0003d	7c 14		 jl	 SHORT $L942
  0003f	6a 63		 push	 99			; 00000063H
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DL@CLJMGHEK@c?3?2xbox?2private?2windows?2directx?2@
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@EKMPPGKN@iIndex?$DMiLength?$AA@
  0004b	e8 00 00 00 00	 call	 __assert
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
$L942:

; 100  :    assert( iIndex>=0);

  00053	83 7d 10 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00057	7d 14		 jge	 SHORT $L943
  00059	6a 64		 push	 100			; 00000064H
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DL@CLJMGHEK@c?3?2xbox?2private?2windows?2directx?2@
  00060	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09ILLECNFF@iIndex?$DO?$DN0?$AA@
  00065	e8 00 00 00 00	 call	 __assert
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L943:

; 101  : 
; 102  :    if (iIndex >= iLength)

  0006d	8b 55 10	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00070	3b 55 0c	 cmp	 edx, DWORD PTR _iLength$[ebp]
  00073	7c 07		 jl	 SHORT $L919

; 103  :       iIndex = 0;

  00075	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _iIndex$[ebp], 0
$L919:

; 104  :    return (pfCodeBook[iIndex]);

  0007c	8b 45 10	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _pfCodeBook$[ebp]
  00082	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]

; 105  : } 

  00085	5d		 pop	 ebp
  00086	c2 0c 00	 ret	 12			; 0000000cH
_ScalarLUT@12 ENDP
_TEXT	ENDS
END
