; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\wmaudio_parse.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
WMADEC_RW	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RW	ENDS
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT @ByteSwap@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _FloatToLong@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _SWAPWORD@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _SWAPDWORD@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _SwapWstr@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _HnsQWORDtoMsDWORD@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_GetBuffer@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_LoadObjectHeader@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_LoadHeaderObject@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_LoadPropertiesObject@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_LoadAudioObject@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_LoadEncryptionObject@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_LoadContentDescriptionObject@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_LoadExtendedContentDescObject@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_LoadLicenseStoreObject@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_LoadMarkerObject@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_GetMarkerObject@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_ParseAsfHeader@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_ParsePacketHeader@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_ParsePayloadHeader@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, WMADEC_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_CLSID_CAsfHeaderObjectV0_XDS
PUBLIC	_CLSID_CAsfPropertiesObjectV2_XDS
PUBLIC	_CLSID_CAsfStreamPropertiesObjectV1_XDS
PUBLIC	_CLSID_CAsfContentDescriptionObjectV0_XDS
PUBLIC	_CLSID_CAsfDataObjectV0_XDS
PUBLIC	_CLSID_AsfXNullErrorMaskingStrategy_XDS
PUBLIC	_CLSID_AsfXAcmAudioErrorMaskingStrategy_XDS
PUBLIC	_CLSID_AsfXSignatureAudioErrorMaskingStrategy_XDS
PUBLIC	_CLSID_AsfXStreamTypeAcmAudio_XDS
PUBLIC	_CLSID_CAsfContentEncryptionObject_XDS
PUBLIC	_CLSID_CAsfExtendedContentDescObject_XDS
PUBLIC	_CLSID_CAsfMarkerObjectV0_XDS
PUBLIC	_CLSID_CAsfLicenseStoreObject_XDS
PUBLIC	_CLSID_CAsfStreamPropertiesObjectV2_XDS
PUBLIC	_CLSID_AsfXStreamTypeDRMAuxData
PUBLIC	_DSoundBuildNumberD
WMADEC_RD	SEGMENT
_WMA_OK	DD	00H
_WMA_S_FALSE DD	01H
_WMA_S_BUFUNDERFLOW DD 02H
_WMA_S_NEWPACKET DD 03H
_WMA_S_NO_MORE_FRAME DD 04H
_WMA_S_DEFAULT DD 05H
_WMA_S_SWITCHCHMODE DD 06H
_WMA_E_FAIL DD	080004005H
_WMA_E_OUTOFMEMORY DD 08007000eH
_WMA_E_INVALIDARG DD 080070057H
_WMA_E_NOTSUPPORTED DD 080040000H
_WMA_E_LOSTPACKET DD 080040001H
_WMA_E_BROKEN_FRAME DD 080040002H
_WMA_E_BUFFEROVERFLOW DD 080040003H
_WMA_E_ONHOLD DD 080040004H
_WMA_E_BUFFERUNDERFLOW DD 080040005H
_WMA_E_INVALIDRECHDR DD 080040006H
_WMA_E_SYNCERROR DD 080040007H
_WMA_E_NOTIMPL DD 080040008H
_WMA_E_FLUSHOVERFLOW DD 080040009H
_CLSID_CAsfHeaderObjectV0_XDS DD 075b22630H
	DW	0668eH
	DW	011cfH
	DB	0a6H
	DB	0d9H
	DB	00H
	DB	0aaH
	DB	00H
	DB	062H
	DB	0ceH
	DB	06cH
_CLSID_CAsfPropertiesObjectV2_XDS DD 08cabdca1H
	DW	0a947H
	DW	011cfH
	DB	08eH
	DB	0e4H
	DB	00H
	DB	0c0H
	DB	0cH
	DB	020H
	DB	053H
	DB	065H
_CLSID_CAsfStreamPropertiesObjectV1_XDS DD 0b7dc0791H
	DW	0a9b7H
	DW	011cfH
	DB	08eH
	DB	0e6H
	DB	00H
	DB	0c0H
	DB	0cH
	DB	020H
	DB	053H
	DB	065H
_CLSID_CAsfContentDescriptionObjectV0_XDS DD 075b22633H
	DW	0668eH
	DW	011cfH
	DB	0a6H
	DB	0d9H
	DB	00H
	DB	0aaH
	DB	00H
	DB	062H
	DB	0ceH
	DB	06cH
_CLSID_CAsfDataObjectV0_XDS DD 075b22636H
	DW	0668eH
	DW	011cfH
	DB	0a6H
	DB	0d9H
	DB	00H
	DB	0aaH
	DB	00H
	DB	062H
	DB	0ceH
	DB	06cH
_CLSID_AsfXNullErrorMaskingStrategy_XDS DD 020fb5700H
	DW	05b55H
	DW	011cfH
	DB	0a8H
	DB	0fdH
	DB	00H
	DB	080H
	DB	05fH
	DB	05cH
	DB	044H
	DB	02bH
_CLSID_AsfXAcmAudioErrorMaskingStrategy_XDS DD 0bfc3cd50H
	DW	0618fH
	DW	011cfH
	DB	08bH
	DB	0b2H
	DB	00H
	DB	0aaH
	DB	00H
	DB	0b4H
	DB	0e2H
	DB	020H
_CLSID_AsfXSignatureAudioErrorMaskingStrategy_XDS DD 049f1a440H
	DW	04eceH
	DW	011d0H
	DB	0a3H
	DB	0acH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	048H
	DB	0f6H
_CLSID_AsfXStreamTypeAcmAudio_XDS DD 0f8699e40H
	DW	05b4dH
	DW	011cfH
	DB	0a8H
	DB	0fdH
	DB	00H
	DB	080H
	DB	05fH
	DB	05cH
	DB	044H
	DB	02bH
_CLSID_CAsfContentEncryptionObject_XDS DD 02211b3fbH
	DW	0bd23H
	DW	011d2H
	DB	0b4H
	DB	0b7H
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	055H
	DB	0fcH
	DB	06eH
_CLSID_CAsfExtendedContentDescObject_XDS DD 0d2d0a440H
	DW	0e307H
	DW	011d2H
	DB	097H
	DB	0f0H
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	05eH
	DB	0a8H
	DB	050H
_CLSID_CAsfMarkerObjectV0_XDS DD 0f487cd01H
	DW	0a951H
	DW	011cfH
	DB	08eH
	DB	0e6H
	DB	00H
	DB	0c0H
	DB	0cH
	DB	020H
	DB	053H
	DB	065H
_CLSID_CAsfLicenseStoreObject_XDS DD 08fa7857bH
	DW	0ddc0H
	DW	011d3H
	DB	0b6H
	DB	0bdH
	DB	00H
	DB	0c0H
	DB	04fH
	DB	061H
	DB	0dH
	DB	062H
_CLSID_CAsfStreamPropertiesObjectV2_XDS DD 0818d0d47H
	DW	043H
	DW	04451H
	DB	092H
	DB	037H
	DB	0daH
	DB	0efH
	DB	0bcH
	DB	048H
	DB	04fH
	DB	050H
_CLSID_AsfXStreamTypeDRMAuxData DD 0d5c82c81H
	DW	08264H
	DW	04abdH
	DB	0a7H
	DB	014H
	DB	0cdH
	DB	04fH
	DB	085H
	DB	054H
	DB	0c7H
	DB	02eH
WMADEC_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT
_DSoundBuildNumberD DW 05344H
	DW	0554fH
	DW	0444eH
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_SWAPWORD@4
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wmaudio_parse.c
;	COMDAT _SWAPWORD@4
WMADEC	SEGMENT
_Temp$ = -1
_pSrc$ = 8
_SWAPWORD@4 PROC NEAR					; COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 54   :     tWMA_U8 Temp;
; 55   :     Temp  = *pSrc;

  00004	8b 45 08	 mov	 eax, DWORD PTR _pSrc$[ebp]
  00007	8a 08		 mov	 cl, BYTE PTR [eax]
  00009	88 4d ff	 mov	 BYTE PTR _Temp$[ebp], cl

; 56   :     *pSrc = *(pSrc+1);

  0000c	8b 55 08	 mov	 edx, DWORD PTR _pSrc$[ebp]
  0000f	8b 45 08	 mov	 eax, DWORD PTR _pSrc$[ebp]
  00012	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00015	88 0a		 mov	 BYTE PTR [edx], cl

; 57   :     *(pSrc+1)= Temp;

  00017	8b 55 08	 mov	 edx, DWORD PTR _pSrc$[ebp]
  0001a	8a 45 ff	 mov	 al, BYTE PTR _Temp$[ebp]
  0001d	88 42 01	 mov	 BYTE PTR [edx+1], al

; 58   : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
_SWAPWORD@4 ENDP
WMADEC	ENDS
PUBLIC	_SWAPDWORD@4
; Function compile flags: /Odt
;	COMDAT _SWAPDWORD@4
WMADEC	SEGMENT
_Temp$ = -1
_pSrc$ = 8
_SWAPDWORD@4 PROC NEAR					; COMDAT

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 62   :     tWMA_U8 Temp;
; 63   :     Temp      = *pSrc;

  00004	8b 45 08	 mov	 eax, DWORD PTR _pSrc$[ebp]
  00007	8a 08		 mov	 cl, BYTE PTR [eax]
  00009	88 4d ff	 mov	 BYTE PTR _Temp$[ebp], cl

; 64   :     *pSrc     = *(pSrc+3);

  0000c	8b 55 08	 mov	 edx, DWORD PTR _pSrc$[ebp]
  0000f	8b 45 08	 mov	 eax, DWORD PTR _pSrc$[ebp]
  00012	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00015	88 0a		 mov	 BYTE PTR [edx], cl

; 65   :     *(pSrc+3) = Temp;

  00017	8b 55 08	 mov	 edx, DWORD PTR _pSrc$[ebp]
  0001a	8a 45 ff	 mov	 al, BYTE PTR _Temp$[ebp]
  0001d	88 42 03	 mov	 BYTE PTR [edx+3], al

; 66   :     Temp      = *(pSrc+1);

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _pSrc$[ebp]
  00023	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00026	88 55 ff	 mov	 BYTE PTR _Temp$[ebp], dl

; 67   :     *(pSrc+1) = *(pSrc+2);

  00029	8b 45 08	 mov	 eax, DWORD PTR _pSrc$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pSrc$[ebp]
  0002f	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  00032	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 68   :     *(pSrc+2) = Temp;

  00035	8b 45 08	 mov	 eax, DWORD PTR _pSrc$[ebp]
  00038	8a 4d ff	 mov	 cl, BYTE PTR _Temp$[ebp]
  0003b	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 69   : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
_SWAPDWORD@4 ENDP
WMADEC	ENDS
PUBLIC	_SwapWstr@8
; Function compile flags: /Odt
;	COMDAT _SwapWstr@8
WMADEC	SEGMENT
_j$ = -8
_p$ = -4
_src$ = 8
_n$ = 12
_SwapWstr@8 PROC NEAR					; COMDAT

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 73   :     tWMA_U32 j;
; 74   :     tWMA_U8 *p = (tWMA_U8 *)src;

  00006	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 75   :     for (j = 0; j < n; j++) {

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00013	eb 09		 jmp	 SHORT $L10063
$L10064:
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  00018	83 c1 01	 add	 ecx, 1
  0001b	89 4d f8	 mov	 DWORD PTR _j$[ebp], ecx
$L10063:
  0001e	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  00021	3b 55 0c	 cmp	 edx, DWORD PTR _n$[ebp]
  00024	73 14		 jae	 SHORT $L10059

; 76   :         SWAPWORD(p);

  00026	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _SWAPWORD@4

; 77   :         p += 2;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00032	83 c1 02	 add	 ecx, 2
  00035	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx

; 78   :     }

  00038	eb db		 jmp	 SHORT $L10064
$L10059:

; 79   : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
_SwapWstr@8 ENDP
WMADEC	ENDS
PUBLIC	_WMA_GetBuffer@16
EXTRN	_WMAFileCBGetData@20:NEAR
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt
;	COMDAT _WMA_GetBuffer@16
WMADEC	SEGMENT
tv67 = -20
_cbReturn$ = -16
_cbActual$ = -12
_cbWanted$ = -8
_pData$ = -4
_pInt$ = 8
_cbOffset$ = 12
_cbTotal$ = 16
_pBuffer$ = 20
_WMA_GetBuffer@16 PROC NEAR				; COMDAT

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 131  :     DWORD cbReturn = 0;

  00006	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _cbReturn$[ebp], 0

; 132  :     BYTE *pData;
; 133  :     DWORD cbActual;
; 134  :     DWORD cbWanted;
; 135  : 
; 136  :     if(pBuffer == NULL)

  0000d	83 7d 14 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00011	75 07		 jne	 SHORT $L10091

; 137  :     {
; 138  :         return 0;

  00013	33 c0		 xor	 eax, eax
  00015	e9 96 00 00 00	 jmp	 $L10083
$L10091:

; 139  :     }
; 140  : 
; 141  :     while(cbTotal > 0)

  0001a	83 7d 10 00	 cmp	 DWORD PTR _cbTotal$[ebp], 0
  0001e	0f 86 89 00 00
	00		 jbe	 $L10092

; 142  :     {
; 143  :         cbWanted = MIN(WMA_MAX_DATA_REQUESTED, cbTotal);

  00024	81 7d 10 80 00
	00 00		 cmp	 DWORD PTR _cbTotal$[ebp], 128 ; 00000080H
  0002b	76 09		 jbe	 SHORT $L10996
  0002d	c7 45 ec 80 00
	00 00		 mov	 DWORD PTR tv67[ebp], 128 ; 00000080H
  00034	eb 06		 jmp	 SHORT $L10997
$L10996:
  00036	8b 45 10	 mov	 eax, DWORD PTR _cbTotal$[ebp]
  00039	89 45 ec	 mov	 DWORD PTR tv67[ebp], eax
$L10997:
  0003c	8b 4d ec	 mov	 ecx, DWORD PTR tv67[ebp]
  0003f	89 4d f8	 mov	 DWORD PTR _cbWanted$[ebp], ecx

; 144  :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 145  :                                     pInt->hdr_parse.pCallbackContext,
; 146  :                                     cbOffset, cbWanted, &pData);

  00042	8d 55 fc	 lea	 edx, DWORD PTR _pData$[ebp]
  00045	52		 push	 edx
  00046	8b 45 f8	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _cbOffset$[ebp]
  0004d	51		 push	 ecx
  0004e	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00051	8b 82 c0 00 00
	00		 mov	 eax, DWORD PTR [edx+192]
  00057	50		 push	 eax
  00058	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00061	89 45 f4	 mov	 DWORD PTR _cbActual$[ebp], eax

; 147  :         if(cbActual != cbWanted)

  00064	8b 55 f4	 mov	 edx, DWORD PTR _cbActual$[ebp]
  00067	3b 55 f8	 cmp	 edx, DWORD PTR _cbWanted$[ebp]
  0006a	74 04		 je	 SHORT $L10094

; 148  :         {
; 149  :             return 0;

  0006c	33 c0		 xor	 eax, eax
  0006e	eb 40		 jmp	 SHORT $L10083
$L10094:

; 150  :         }
; 151  : 
; 152  :         memcpy(pBuffer, pData, (size_t)cbActual);

  00070	8b 45 f4	 mov	 eax, DWORD PTR _cbActual$[ebp]
  00073	50		 push	 eax
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  00077	51		 push	 ecx
  00078	8b 55 14	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  0007b	52		 push	 edx
  0007c	e8 00 00 00 00	 call	 _memcpy
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 153  : 
; 154  :         pBuffer += cbActual;

  00084	8b 45 14	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  00087	03 45 f4	 add	 eax, DWORD PTR _cbActual$[ebp]
  0008a	89 45 14	 mov	 DWORD PTR _pBuffer$[ebp], eax

; 155  :         cbOffset += cbActual;

  0008d	8b 4d 0c	 mov	 ecx, DWORD PTR _cbOffset$[ebp]
  00090	03 4d f4	 add	 ecx, DWORD PTR _cbActual$[ebp]
  00093	89 4d 0c	 mov	 DWORD PTR _cbOffset$[ebp], ecx

; 156  :         cbTotal -= cbActual;

  00096	8b 55 10	 mov	 edx, DWORD PTR _cbTotal$[ebp]
  00099	2b 55 f4	 sub	 edx, DWORD PTR _cbActual$[ebp]
  0009c	89 55 10	 mov	 DWORD PTR _cbTotal$[ebp], edx

; 157  :         cbReturn += cbActual;

  0009f	8b 45 f0	 mov	 eax, DWORD PTR _cbReturn$[ebp]
  000a2	03 45 f4	 add	 eax, DWORD PTR _cbActual$[ebp]
  000a5	89 45 f0	 mov	 DWORD PTR _cbReturn$[ebp], eax

; 158  :     }

  000a8	e9 6d ff ff ff	 jmp	 $L10091
$L10092:

; 159  : 
; 160  :     return cbReturn;        

  000ad	8b 45 f0	 mov	 eax, DWORD PTR _cbReturn$[ebp]
$L10083:

; 161  : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 10 00	 ret	 16			; 00000010H
_WMA_GetBuffer@16 ENDP
WMADEC	ENDS
PUBLIC	_WMA_LoadObjectHeader@12
; Function compile flags: /Odt
;	COMDAT _WMA_LoadObjectHeader@12
WMADEC	SEGMENT
_cbActual$ = -12
_cbWanted$ = -8
_pData$ = -4
_pInt$ = 8
_pObjectId$ = 12
_pqwSize$ = 16
_WMA_LoadObjectHeader@12 PROC NEAR			; COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 170  :     BYTE *pData;
; 171  :     DWORD cbWanted;
; 172  :     DWORD cbActual;
; 173  : 
; 174  :     if(pInt == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  0000a	75 0a		 jne	 SHORT $L10107

; 175  :     {
; 176  :         return WMAERR_INVALIDARG;

  0000c	b8 02 00 00 00	 mov	 eax, 2
  00011	e9 44 01 00 00	 jmp	 $L10102
$L10107:

; 177  :     }
; 178  : 
; 179  :     cbWanted = MIN_OBJECT_SIZE;

  00016	c7 45 f8 18 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 24 ; 00000018H

; 180  :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 181  :                                 pInt->pCallbackContext,
; 182  :                                 pInt->currPacketOffset, cbWanted, &pData);

  0001d	8d 45 fc	 lea	 eax, DWORD PTR _pData$[ebp]
  00020	50		 push	 eax
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00028	8b 02		 mov	 eax, DWORD PTR [edx]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0002e	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  00034	52		 push	 edx
  00035	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  0003e	89 45 f4	 mov	 DWORD PTR _cbActual$[ebp], eax

; 183  :     if(cbActual != cbWanted)

  00041	8b 4d f4	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  00044	3b 4d f8	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  00047	74 0a		 je	 SHORT $L10109

; 184  :     {
; 185  :         return WMAERR_BUFFERTOOSMALL;

  00049	b8 03 00 00 00	 mov	 eax, 3
  0004e	e9 07 01 00 00	 jmp	 $L10102
$L10109:

; 186  :     }
; 187  :     pInt->currPacketOffset += cbActual;

  00053	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00056	8b 02		 mov	 eax, DWORD PTR [edx]
  00058	03 45 f4	 add	 eax, DWORD PTR _cbActual$[ebp]
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax

; 188  : 
; 189  :     LoadGUID(*pObjectId, pData);

  00060	8b 55 0c	 mov	 edx, DWORD PTR _pObjectId$[ebp]
  00063	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	89 0a		 mov	 DWORD PTR [edx], ecx
  0006a	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  0006d	83 c2 04	 add	 edx, 4
  00070	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx
  00073	8b 45 0c	 mov	 eax, DWORD PTR _pObjectId$[ebp]
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  00079	66 8b 11	 mov	 dx, WORD PTR [ecx]
  0007c	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00083	83 c0 02	 add	 eax, 2
  00086	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _pObjectId$[ebp]
  0008c	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  0008f	66 8b 02	 mov	 ax, WORD PTR [edx]
  00092	66 89 41 06	 mov	 WORD PTR [ecx+6], ax
  00096	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  00099	83 c1 02	 add	 ecx, 2
  0009c	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  0009f	8b 55 0c	 mov	 edx, DWORD PTR _pObjectId$[ebp]
  000a2	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  000a5	8a 08		 mov	 cl, BYTE PTR [eax]
  000a7	88 4a 08	 mov	 BYTE PTR [edx+8], cl
  000aa	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000ad	83 c2 01	 add	 edx, 1
  000b0	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx
  000b3	8b 45 0c	 mov	 eax, DWORD PTR _pObjectId$[ebp]
  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000b9	8a 11		 mov	 dl, BYTE PTR [ecx]
  000bb	88 50 09	 mov	 BYTE PTR [eax+9], dl
  000be	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  000c1	83 c0 01	 add	 eax, 1
  000c4	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax
  000c7	8b 4d 0c	 mov	 ecx, DWORD PTR _pObjectId$[ebp]
  000ca	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000cd	8a 02		 mov	 al, BYTE PTR [edx]
  000cf	88 41 0a	 mov	 BYTE PTR [ecx+10], al
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000d5	83 c1 01	 add	 ecx, 1
  000d8	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  000db	8b 55 0c	 mov	 edx, DWORD PTR _pObjectId$[ebp]
  000de	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  000e1	8a 08		 mov	 cl, BYTE PTR [eax]
  000e3	88 4a 0b	 mov	 BYTE PTR [edx+11], cl
  000e6	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000e9	83 c2 01	 add	 edx, 1
  000ec	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx
  000ef	8b 45 0c	 mov	 eax, DWORD PTR _pObjectId$[ebp]
  000f2	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000f5	8a 11		 mov	 dl, BYTE PTR [ecx]
  000f7	88 50 0c	 mov	 BYTE PTR [eax+12], dl
  000fa	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  000fd	83 c0 01	 add	 eax, 1
  00100	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax
  00103	8b 4d 0c	 mov	 ecx, DWORD PTR _pObjectId$[ebp]
  00106	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00109	8a 02		 mov	 al, BYTE PTR [edx]
  0010b	88 41 0d	 mov	 BYTE PTR [ecx+13], al
  0010e	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  00111	83 c1 01	 add	 ecx, 1
  00114	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  00117	8b 55 0c	 mov	 edx, DWORD PTR _pObjectId$[ebp]
  0011a	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  0011d	8a 08		 mov	 cl, BYTE PTR [eax]
  0011f	88 4a 0e	 mov	 BYTE PTR [edx+14], cl
  00122	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00125	83 c2 01	 add	 edx, 1
  00128	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx
  0012b	8b 45 0c	 mov	 eax, DWORD PTR _pObjectId$[ebp]
  0012e	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  00131	8a 11		 mov	 dl, BYTE PTR [ecx]
  00133	88 50 0f	 mov	 BYTE PTR [eax+15], dl
  00136	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00139	83 c0 01	 add	 eax, 1
  0013c	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax

; 190  :     LoadQWORD(*pqwSize, pData);

  0013f	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  00142	8b 11		 mov	 edx, DWORD PTR [ecx]
  00144	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00147	8b 4d 10	 mov	 ecx, DWORD PTR _pqwSize$[ebp]
  0014a	89 11		 mov	 DWORD PTR [ecx], edx
  0014c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0014f	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00152	83 c2 08	 add	 edx, 8
  00155	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 191  : 
; 192  :     return WMAERR_OK;

  00158	33 c0		 xor	 eax, eax
$L10102:

; 193  : }

  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c2 0c 00	 ret	 12			; 0000000cH
_WMA_LoadObjectHeader@12 ENDP
WMADEC	ENDS
PUBLIC	_WMA_LoadHeaderObject@8
EXTRN	_memcmp:NEAR
; Function compile flags: /Odt
;	COMDAT _WMA_LoadHeaderObject@8
WMADEC	SEGMENT
_cHeaders$ = -44
_objectId$ = -40
_cbActual$ = -24
_align$ = -18
_arch$ = -17
_qwSize$ = -16
_cbWanted$ = -8
_pData$ = -4
_pInt$ = 8
_isFull$ = 12
_WMA_LoadHeaderObject@8 PROC NEAR			; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 201  :     GUID objectId;
; 202  :     QWORD qwSize;
; 203  :     DWORD cHeaders;
; 204  :     BYTE align;
; 205  :     BYTE arch;
; 206  : 
; 207  :     BYTE *pData;
; 208  :     DWORD cbWanted;
; 209  :     DWORD cbActual;
; 210  : 
; 211  :     if(pInt == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  0000a	75 0a		 jne	 SHORT $L10148

; 212  :     {
; 213  :         return WMAERR_INVALIDARG;

  0000c	b8 02 00 00 00	 mov	 eax, 2
  00011	e9 8e 01 00 00	 jmp	 $L10138
$L10148:

; 214  :     }
; 215  : 
; 216  : #ifndef WMAAPI_NO_DRM
; 217  : #ifdef GLOBAL_SECRET
; 218  : 
; 219  :     if(isFull)
; 220  :     {
; 221  :         SetSecret_4of7(((tWMAFileStateInternal *)pInt)->pDRM_state);
; 222  :     }
; 223  : #endif // GLOBAL_SECRET
; 224  : 
; 225  : #endif /* WMAAPI_NO_DRM */
; 226  : 
; 227  :     cbWanted = MIN_OBJECT_SIZE + sizeof(DWORD) + 2*sizeof(BYTE);

  00016	c7 45 f8 1e 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 30 ; 0000001eH

; 228  :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 229  :                                 pInt->pCallbackContext,
; 230  :                                 pInt->currPacketOffset, cbWanted, &pData);

  0001d	8d 45 fc	 lea	 eax, DWORD PTR _pData$[ebp]
  00020	50		 push	 eax
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00028	8b 02		 mov	 eax, DWORD PTR [edx]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0002e	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  00034	52		 push	 edx
  00035	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  0003e	89 45 e8	 mov	 DWORD PTR _cbActual$[ebp], eax

; 231  :     if(cbActual != cbWanted)

  00041	8b 4d e8	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  00044	3b 4d f8	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  00047	74 0a		 je	 SHORT $L10152

; 232  :     {
; 233  :         return WMAERR_BUFFERTOOSMALL;

  00049	b8 03 00 00 00	 mov	 eax, 3
  0004e	e9 51 01 00 00	 jmp	 $L10138
$L10152:

; 234  :     }
; 235  :     pInt->currPacketOffset += cbActual;

  00053	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00056	8b 02		 mov	 eax, DWORD PTR [edx]
  00058	03 45 e8	 add	 eax, DWORD PTR _cbActual$[ebp]
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax

; 236  : 
; 237  :     LoadGUID(objectId, pData);

  00060	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00063	8b 02		 mov	 eax, DWORD PTR [edx]
  00065	89 45 d8	 mov	 DWORD PTR _objectId$[ebp], eax
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  0006b	83 c1 04	 add	 ecx, 4
  0006e	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  00071	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00074	66 8b 02	 mov	 ax, WORD PTR [edx]
  00077	66 89 45 dc	 mov	 WORD PTR _objectId$[ebp+4], ax
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  0007e	83 c1 02	 add	 ecx, 2
  00081	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  00084	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00087	66 8b 02	 mov	 ax, WORD PTR [edx]
  0008a	66 89 45 de	 mov	 WORD PTR _objectId$[ebp+6], ax
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  00091	83 c1 02	 add	 ecx, 2
  00094	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  00097	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  0009a	8a 02		 mov	 al, BYTE PTR [edx]
  0009c	88 45 e0	 mov	 BYTE PTR _objectId$[ebp+8], al
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000a2	83 c1 01	 add	 ecx, 1
  000a5	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  000a8	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000ab	8a 02		 mov	 al, BYTE PTR [edx]
  000ad	88 45 e1	 mov	 BYTE PTR _objectId$[ebp+9], al
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000b3	83 c1 01	 add	 ecx, 1
  000b6	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  000b9	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000bc	8a 02		 mov	 al, BYTE PTR [edx]
  000be	88 45 e2	 mov	 BYTE PTR _objectId$[ebp+10], al
  000c1	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000c4	83 c1 01	 add	 ecx, 1
  000c7	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  000ca	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000cd	8a 02		 mov	 al, BYTE PTR [edx]
  000cf	88 45 e3	 mov	 BYTE PTR _objectId$[ebp+11], al
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000d5	83 c1 01	 add	 ecx, 1
  000d8	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  000db	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000de	8a 02		 mov	 al, BYTE PTR [edx]
  000e0	88 45 e4	 mov	 BYTE PTR _objectId$[ebp+12], al
  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000e6	83 c1 01	 add	 ecx, 1
  000e9	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  000ec	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000ef	8a 02		 mov	 al, BYTE PTR [edx]
  000f1	88 45 e5	 mov	 BYTE PTR _objectId$[ebp+13], al
  000f4	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000f7	83 c1 01	 add	 ecx, 1
  000fa	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  000fd	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00100	8a 02		 mov	 al, BYTE PTR [edx]
  00102	88 45 e6	 mov	 BYTE PTR _objectId$[ebp+14], al
  00105	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  00108	83 c1 01	 add	 ecx, 1
  0010b	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  0010e	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00111	8a 02		 mov	 al, BYTE PTR [edx]
  00113	88 45 e7	 mov	 BYTE PTR _objectId$[ebp+15], al
  00116	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  00119	83 c1 01	 add	 ecx, 1
  0011c	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx

; 238  :     LoadQWORD(qwSize, pData);

  0011f	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00122	8b 02		 mov	 eax, DWORD PTR [edx]
  00124	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00127	89 45 f0	 mov	 DWORD PTR _qwSize$[ebp], eax
  0012a	89 4d f4	 mov	 DWORD PTR _qwSize$[ebp+4], ecx
  0012d	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00130	83 c2 08	 add	 edx, 8
  00133	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 239  :     LoadDWORD(cHeaders, pData);

  00136	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00139	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013b	89 4d d4	 mov	 DWORD PTR _cHeaders$[ebp], ecx
  0013e	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00141	83 c2 04	 add	 edx, 4
  00144	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 240  :     LoadBYTE(align, pData);

  00147	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  0014a	8a 08		 mov	 cl, BYTE PTR [eax]
  0014c	88 4d ee	 mov	 BYTE PTR _align$[ebp], cl
  0014f	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00152	83 c2 01	 add	 edx, 1
  00155	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 241  :     LoadBYTE(arch, pData);

  00158	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  0015b	8a 08		 mov	 cl, BYTE PTR [eax]
  0015d	88 4d ef	 mov	 BYTE PTR _arch$[ebp], cl
  00160	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00163	83 c2 01	 add	 edx, 1
  00166	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 242  : 
; 243  :     if(!WMA_IsEqualGUID(&CLSID_CAsfHeaderObjectV0, &objectId)
; 244  :        || align != 1
; 245  :        || arch != 2)

  00169	6a 10		 push	 16			; 00000010H
  0016b	8d 45 d8	 lea	 eax, DWORD PTR _objectId$[ebp]
  0016e	50		 push	 eax
  0016f	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_CAsfHeaderObjectV0_XDS
  00174	e8 00 00 00 00	 call	 _memcmp
  00179	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017c	85 c0		 test	 eax, eax
  0017e	75 12		 jne	 SHORT $L10187
  00180	0f b6 4d ee	 movzx	 ecx, BYTE PTR _align$[ebp]
  00184	83 f9 01	 cmp	 ecx, 1
  00187	75 09		 jne	 SHORT $L10187
  00189	0f b6 55 ef	 movzx	 edx, BYTE PTR _arch$[ebp]
  0018d	83 fa 02	 cmp	 edx, 2
  00190	74 07		 je	 SHORT $L10186
$L10187:

; 246  :     {
; 247  :         return WMAERR_INVALIDHEADER;

  00192	b8 04 00 00 00	 mov	 eax, 4
  00197	eb 0b		 jmp	 SHORT $L10138
$L10186:

; 248  :     }
; 249  : 
; 250  :     /* use all */
; 251  :     pInt->cbHeader = qwSize.dwLo;

  00199	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0019c	8b 4d f0	 mov	 ecx, DWORD PTR _qwSize$[ebp]
  0019f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 252  :     
; 253  :     return WMAERR_OK;

  001a2	33 c0		 xor	 eax, eax
$L10138:

; 254  : }

  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c2 08 00	 ret	 8
_WMA_LoadHeaderObject@8 ENDP
WMADEC	ENDS
PUBLIC	_WMA_LoadPropertiesObject@12
; Function compile flags: /Odt
;	COMDAT _WMA_LoadPropertiesObject@12
WMADEC	SEGMENT
_qwTotalSize$ = -92
_mmsId$ = -84
_qwCreateTime$ = -68
_dwFlags$ = -60
_qwPreroll$ = -56
_dwMinPacketSize$ = -48
_cbActual$ = -44
_qwSendDuration$ = -40
_dwMaxBitrate$ = -32
_cbWanted$ = -28
_qwPackets$ = -24
_dwMaxPacketSize$ = -16
_pData$ = -12
_qwPlayDuration$ = -8
_pInt$ = 8
_cbSize$ = 12
_isFull$ = 16
_WMA_LoadPropertiesObject@12 PROC NEAR			; COMDAT

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH

; 263  :     GUID mmsId;
; 264  :     QWORD qwTotalSize;
; 265  :     QWORD qwCreateTime;
; 266  :     QWORD qwPackets;
; 267  :     QWORD qwPlayDuration;
; 268  :     QWORD qwSendDuration;
; 269  :     QWORD qwPreroll;
; 270  :     DWORD dwFlags;
; 271  :     DWORD dwMinPacketSize;
; 272  :     DWORD dwMaxPacketSize;
; 273  :     DWORD dwMaxBitrate;
; 274  : 
; 275  :     BYTE *pData;
; 276  :     DWORD cbWanted;
; 277  :     DWORD cbActual;
; 278  : 
; 279  :     if(pInt == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  0000a	75 0a		 jne	 SHORT $L10210

; 280  :     {
; 281  :         return WMAERR_INVALIDARG;

  0000c	b8 02 00 00 00	 mov	 eax, 2
  00011	e9 3d 02 00 00	 jmp	 $L10194
$L10210:

; 282  :     }
; 283  :     cbSize -= MIN_OBJECT_SIZE;

  00016	8b 45 0c	 mov	 eax, DWORD PTR _cbSize$[ebp]
  00019	83 e8 18	 sub	 eax, 24			; 00000018H
  0001c	89 45 0c	 mov	 DWORD PTR _cbSize$[ebp], eax

; 284  : 
; 285  : #ifndef WMAAPI_NO_DRM
; 286  : #ifdef GLOBAL_SECRET
; 287  : 
; 288  :     if(isFull)
; 289  :     {
; 290  :         SetSecret_5of7(((tWMAFileStateInternal *)pInt)->pDRM_state);
; 291  :     }
; 292  : #endif // GLOBAL_SECRET
; 293  : 
; 294  : #endif /* WMAAPI_NO_DRM */
; 295  : 
; 296  :     cbWanted = sizeof(GUID) + 6*sizeof(QWORD) + 4*sizeof(DWORD);

  0001f	c7 45 e4 50 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 80 ; 00000050H

; 297  :     if(cbWanted > cbSize)

  00026	8b 4d e4	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00029	3b 4d 0c	 cmp	 ecx, DWORD PTR _cbSize$[ebp]
  0002c	76 0a		 jbe	 SHORT $L10214

; 298  :     {
; 299  :         return WMAERR_BUFFERTOOSMALL;

  0002e	b8 03 00 00 00	 mov	 eax, 3
  00033	e9 1b 02 00 00	 jmp	 $L10194
$L10214:

; 300  :     }
; 301  :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 302  :                                 pInt->pCallbackContext,
; 303  :                                 pInt->currPacketOffset, cbWanted, &pData);

  00038	8d 55 f4	 lea	 edx, DWORD PTR _pData$[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 e4	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00043	8b 11		 mov	 edx, DWORD PTR [ecx]
  00045	52		 push	 edx
  00046	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00049	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  0004f	51		 push	 ecx
  00050	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00059	89 45 d4	 mov	 DWORD PTR _cbActual$[ebp], eax

; 304  :     if(cbActual != cbWanted)

  0005c	8b 45 d4	 mov	 eax, DWORD PTR _cbActual$[ebp]
  0005f	3b 45 e4	 cmp	 eax, DWORD PTR _cbWanted$[ebp]
  00062	74 0a		 je	 SHORT $L10216

; 305  :     {
; 306  :         return WMAERR_BUFFERTOOSMALL;

  00064	b8 03 00 00 00	 mov	 eax, 3
  00069	e9 e5 01 00 00	 jmp	 $L10194
$L10216:

; 307  :     }
; 308  : 
; 309  :     LoadGUID(mmsId, pData);

  0006e	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  00071	8b 11		 mov	 edx, DWORD PTR [ecx]
  00073	89 55 ac	 mov	 DWORD PTR _mmsId$[ebp], edx
  00076	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  00079	83 c0 04	 add	 eax, 4
  0007c	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax
  0007f	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  00082	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00085	66 89 55 b0	 mov	 WORD PTR _mmsId$[ebp+4], dx
  00089	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  0008c	83 c0 02	 add	 eax, 2
  0008f	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax
  00092	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  00095	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00098	66 89 55 b2	 mov	 WORD PTR _mmsId$[ebp+6], dx
  0009c	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  0009f	83 c0 02	 add	 eax, 2
  000a2	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax
  000a5	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  000a8	8a 11		 mov	 dl, BYTE PTR [ecx]
  000aa	88 55 b4	 mov	 BYTE PTR _mmsId$[ebp+8], dl
  000ad	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  000b0	83 c0 01	 add	 eax, 1
  000b3	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax
  000b6	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  000b9	8a 11		 mov	 dl, BYTE PTR [ecx]
  000bb	88 55 b5	 mov	 BYTE PTR _mmsId$[ebp+9], dl
  000be	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  000c1	83 c0 01	 add	 eax, 1
  000c4	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax
  000c7	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  000ca	8a 11		 mov	 dl, BYTE PTR [ecx]
  000cc	88 55 b6	 mov	 BYTE PTR _mmsId$[ebp+10], dl
  000cf	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  000d2	83 c0 01	 add	 eax, 1
  000d5	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax
  000d8	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  000db	8a 11		 mov	 dl, BYTE PTR [ecx]
  000dd	88 55 b7	 mov	 BYTE PTR _mmsId$[ebp+11], dl
  000e0	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  000e3	83 c0 01	 add	 eax, 1
  000e6	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  000ec	8a 11		 mov	 dl, BYTE PTR [ecx]
  000ee	88 55 b8	 mov	 BYTE PTR _mmsId$[ebp+12], dl
  000f1	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  000f4	83 c0 01	 add	 eax, 1
  000f7	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax
  000fa	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  000fd	8a 11		 mov	 dl, BYTE PTR [ecx]
  000ff	88 55 b9	 mov	 BYTE PTR _mmsId$[ebp+13], dl
  00102	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  00105	83 c0 01	 add	 eax, 1
  00108	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax
  0010b	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  0010e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00110	88 55 ba	 mov	 BYTE PTR _mmsId$[ebp+14], dl
  00113	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  00116	83 c0 01	 add	 eax, 1
  00119	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax
  0011c	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  0011f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00121	88 55 bb	 mov	 BYTE PTR _mmsId$[ebp+15], dl
  00124	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  00127	83 c0 01	 add	 eax, 1
  0012a	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax

; 310  :     LoadQWORD(qwTotalSize, pData);

  0012d	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  00130	8b 11		 mov	 edx, DWORD PTR [ecx]
  00132	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00135	89 55 a4	 mov	 DWORD PTR _qwTotalSize$[ebp], edx
  00138	89 45 a8	 mov	 DWORD PTR _qwTotalSize$[ebp+4], eax
  0013b	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  0013e	83 c1 08	 add	 ecx, 8
  00141	89 4d f4	 mov	 DWORD PTR _pData$[ebp], ecx

; 311  :     LoadQWORD(qwCreateTime, pData);

  00144	8b 55 f4	 mov	 edx, DWORD PTR _pData$[ebp]
  00147	8b 02		 mov	 eax, DWORD PTR [edx]
  00149	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0014c	89 45 bc	 mov	 DWORD PTR _qwCreateTime$[ebp], eax
  0014f	89 4d c0	 mov	 DWORD PTR _qwCreateTime$[ebp+4], ecx
  00152	8b 55 f4	 mov	 edx, DWORD PTR _pData$[ebp]
  00155	83 c2 08	 add	 edx, 8
  00158	89 55 f4	 mov	 DWORD PTR _pData$[ebp], edx

; 312  :     LoadQWORD(qwPackets, pData);

  0015b	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  0015e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00160	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00163	89 4d e8	 mov	 DWORD PTR _qwPackets$[ebp], ecx
  00166	89 55 ec	 mov	 DWORD PTR _qwPackets$[ebp+4], edx
  00169	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  0016c	83 c0 08	 add	 eax, 8
  0016f	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax

; 313  :     LoadQWORD(qwPlayDuration, pData);

  00172	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  00175	8b 11		 mov	 edx, DWORD PTR [ecx]
  00177	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0017a	89 55 f8	 mov	 DWORD PTR _qwPlayDuration$[ebp], edx
  0017d	89 45 fc	 mov	 DWORD PTR _qwPlayDuration$[ebp+4], eax
  00180	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  00183	83 c1 08	 add	 ecx, 8
  00186	89 4d f4	 mov	 DWORD PTR _pData$[ebp], ecx

; 314  :     LoadQWORD(qwSendDuration, pData);

  00189	8b 55 f4	 mov	 edx, DWORD PTR _pData$[ebp]
  0018c	8b 02		 mov	 eax, DWORD PTR [edx]
  0018e	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00191	89 45 d8	 mov	 DWORD PTR _qwSendDuration$[ebp], eax
  00194	89 4d dc	 mov	 DWORD PTR _qwSendDuration$[ebp+4], ecx
  00197	8b 55 f4	 mov	 edx, DWORD PTR _pData$[ebp]
  0019a	83 c2 08	 add	 edx, 8
  0019d	89 55 f4	 mov	 DWORD PTR _pData$[ebp], edx

; 315  :     LoadQWORD(qwPreroll, pData);

  001a0	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  001a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001a8	89 4d c8	 mov	 DWORD PTR _qwPreroll$[ebp], ecx
  001ab	89 55 cc	 mov	 DWORD PTR _qwPreroll$[ebp+4], edx
  001ae	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  001b1	83 c0 08	 add	 eax, 8
  001b4	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax

; 316  :     LoadDWORD(dwFlags, pData);

  001b7	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  001ba	8b 11		 mov	 edx, DWORD PTR [ecx]
  001bc	89 55 c4	 mov	 DWORD PTR _dwFlags$[ebp], edx
  001bf	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  001c2	83 c0 04	 add	 eax, 4
  001c5	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax

; 317  :     LoadDWORD(dwMinPacketSize, pData);

  001c8	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  001cb	8b 11		 mov	 edx, DWORD PTR [ecx]
  001cd	89 55 d0	 mov	 DWORD PTR _dwMinPacketSize$[ebp], edx
  001d0	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  001d3	83 c0 04	 add	 eax, 4
  001d6	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax

; 318  :     LoadDWORD(dwMaxPacketSize, pData);

  001d9	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  001dc	8b 11		 mov	 edx, DWORD PTR [ecx]
  001de	89 55 f0	 mov	 DWORD PTR _dwMaxPacketSize$[ebp], edx
  001e1	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  001e4	83 c0 04	 add	 eax, 4
  001e7	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax

; 319  :     LoadDWORD(dwMaxBitrate, pData);

  001ea	8b 4d f4	 mov	 ecx, DWORD PTR _pData$[ebp]
  001ed	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ef	89 55 e0	 mov	 DWORD PTR _dwMaxBitrate$[ebp], edx
  001f2	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  001f5	83 c0 04	 add	 eax, 4
  001f8	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax

; 320  : 
; 321  :     if(dwMinPacketSize != dwMaxPacketSize
; 322  :        || (qwPackets.dwLo == 0 && qwPackets.dwHi == 0))

  001fb	8b 4d d0	 mov	 ecx, DWORD PTR _dwMinPacketSize$[ebp]
  001fe	3b 4d f0	 cmp	 ecx, DWORD PTR _dwMaxPacketSize$[ebp]
  00201	75 0c		 jne	 SHORT $L10260
  00203	83 7d e8 00	 cmp	 DWORD PTR _qwPackets$[ebp], 0
  00207	75 0d		 jne	 SHORT $L10259
  00209	83 7d ec 00	 cmp	 DWORD PTR _qwPackets$[ebp+4], 0
  0020d	75 07		 jne	 SHORT $L10259
$L10260:

; 323  :     {
; 324  :         return WMAERR_FAIL;

  0020f	b8 01 00 00 00	 mov	 eax, 1
  00214	eb 3d		 jmp	 SHORT $L10194
$L10259:

; 325  :     }
; 326  : 
; 327  :     pInt->cbPacketSize = dwMaxPacketSize;

  00216	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00219	8b 45 f0	 mov	 eax, DWORD PTR _dwMaxPacketSize$[ebp]
  0021c	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 328  :     pInt->cPackets     = qwPackets.dwLo;

  0021f	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00222	8b 55 e8	 mov	 edx, DWORD PTR _qwPackets$[ebp]
  00225	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 329  :     pInt->msDuration   = HnsQWORDtoMsDWORD(qwSendDuration);

  00228	8b 45 dc	 mov	 eax, DWORD PTR _qwSendDuration$[ebp+4]
  0022b	50		 push	 eax
  0022c	8b 4d d8	 mov	 ecx, DWORD PTR _qwSendDuration$[ebp]
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 _HnsQWORDtoMsDWORD@8
  00235	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00238	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 330  :     pInt->msPreroll    = qwPreroll.dwLo;

  0023b	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0023e	8b 4d c8	 mov	 ecx, DWORD PTR _qwPreroll$[ebp]
  00241	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 331  :     
; 332  :     /* use all */
; 333  :     pInt->currPacketOffset += cbSize;

  00244	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00247	8b 02		 mov	 eax, DWORD PTR [edx]
  00249	03 45 0c	 add	 eax, DWORD PTR _cbSize$[ebp]
  0024c	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0024f	89 01		 mov	 DWORD PTR [ecx], eax

; 334  : 
; 335  :     return WMAERR_OK;

  00251	33 c0		 xor	 eax, eax
$L10194:

; 336  : }

  00253	8b e5		 mov	 esp, ebp
  00255	5d		 pop	 ebp
  00256	c2 0c 00	 ret	 12			; 0000000cH
_WMA_LoadPropertiesObject@12 ENDP
WMADEC	ENDS
PUBLIC	__real@48d1b717
EXTRN	__fltused:NEAR
;	COMDAT __real@48d1b717
CONST	SEGMENT
__real@48d1b717 DD 048d1b717r			; 429497
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _HnsQWORDtoMsDWORD@8
WMADEC	SEGMENT
tv75 = -16
_msLo$ = -8
_msHi$ = -4
_qw$ = 8
_HnsQWORDtoMsDWORD@8 PROC NEAR				; COMDAT

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 114  :     DWORD msLo, msHi;
; 115  : 
; 116  :     msLo = qw.dwLo/10000;

  00006	8b 45 08	 mov	 eax, DWORD PTR _qw$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00010	f7 f1		 div	 ecx
  00012	89 45 f8	 mov	 DWORD PTR _msLo$[ebp], eax

; 117  :     msHi = (DWORD)ftoi((float)qw.dwHi*429496.7296f);

  00015	8b 55 0c	 mov	 edx, DWORD PTR _qw$[ebp+4]
  00018	89 55 f0	 mov	 DWORD PTR tv75[ebp], edx
  0001b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv75[ebp+4], 0
  00022	df 6d f0	 fild	 QWORD PTR tv75[ebp]
  00025	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@48d1b717
  0002b	51		 push	 ecx
  0002c	d9 1c 24	 fstp	 DWORD PTR [esp]
  0002f	e8 00 00 00 00	 call	 _FloatToLong@4
  00034	89 45 fc	 mov	 DWORD PTR _msHi$[ebp], eax

; 118  : 
; 119  :     return msLo + msHi;

  00037	8b 45 f8	 mov	 eax, DWORD PTR _msLo$[ebp]
  0003a	03 45 fc	 add	 eax, DWORD PTR _msHi$[ebp]

; 120  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
_HnsQWORDtoMsDWORD@8 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wmamath.h
WMADEC	ENDS
;	COMDAT _FloatToLong@4
WMADEC	SEGMENT
_x$ = 8
_FloatToLong@4 PROC NEAR				; COMDAT

; 6    :     __asm
; 7    :     {
; 8    :         cvttss2si eax, [esp+4]

  00000	f3 0f 2c 44 24
	04		 cvttss2si eax, DWORD PTR [esp+4]

; 9    :         ret 4

  00006	c2 04 00	 ret	 4
_FloatToLong@4 ENDP
WMADEC	ENDS
PUBLIC	_WMA_LoadAudioObject@12
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wmaudio_parse.c
;	COMDAT _WMA_LoadAudioObject@12
WMADEC	SEGMENT
tv209 = -96
_tp$ = -92
_dwJunk$ = -88
_cbActual$ = -84
_tw$ = -80
_ecStrategy$ = -76
_streamType$ = -60
_cbErrConcealment$ = -44
_qwOffset$ = -40
_wStreamNum$ = -32
_nBlocksPerObject$ = -28
_tdw$ = -24
_cbObjectOffset$ = -20
_pScramblingData$ = -16
_cbWanted$ = -12
_pData$ = -8
_cbTypeSpecific$ = -4
_pInt$ = 8
_cbSize$ = 12
_isFull$ = 16
_WMA_LoadAudioObject@12 PROC NEAR			; COMDAT

; 344  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H

; 345  :     GUID streamType;
; 346  :     GUID ecStrategy;
; 347  :     QWORD qwOffset;
; 348  :     DWORD cbTypeSpecific;
; 349  :     DWORD cbErrConcealment;
; 350  :     WORD wStreamNum;
; 351  :     DWORD dwJunk;
; 352  :     DWORD nBlocksPerObject;
; 353  :     AsfXAcmAudioErrorMaskingData *pScramblingData;
; 354  :     // WAVEFORMATEX *pFmt;
; 355  : 
; 356  :     BYTE *pData;
; 357  :     DWORD cbWanted;
; 358  :     DWORD cbActual;
; 359  : 
; 360  : 	    WORD  tw;
; 361  : 	    DWORD tdw;
; 362  : 	    const BYTE *tp;
; 363  : 
; 364  :     
; 365  :     DWORD cbObjectOffset = 0;

  00006	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _cbObjectOffset$[ebp], 0

; 366  : 
; 367  : 
; 368  : 
; 369  :     if(pInt == NULL)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00011	75 0a		 jne	 SHORT $L10285

; 370  :     {
; 371  :         return WMAERR_INVALIDARG;

  00013	b8 02 00 00 00	 mov	 eax, 2
  00018	e9 83 06 00 00	 jmp	 $L10267
$L10285:

; 372  :     }
; 373  : 
; 374  :     cbSize -= MIN_OBJECT_SIZE;

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _cbSize$[ebp]
  00020	83 e8 18	 sub	 eax, 24			; 00000018H
  00023	89 45 0c	 mov	 DWORD PTR _cbSize$[ebp], eax

; 375  : 
; 376  : #ifndef WMAAPI_NO_DRM
; 377  : #ifdef GLOBAL_SECRET
; 378  : 
; 379  :     if (isFull)
; 380  :     {
; 381  :         SetSecret_3of7(((tWMAFileStateInternal *)pInt)->pDRM_state);
; 382  :     }
; 383  : #endif // GLOBAL_SECRET
; 384  : 
; 385  : #endif /* WMAAPI_NO_DRM */
; 386  : 
; 387  :     cbWanted = 2*sizeof(GUID) + sizeof(QWORD) + 3*sizeof(DWORD) + sizeof(WORD);

  00026	c7 45 f4 36 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 54 ; 00000036H

; 388  :     if(cbObjectOffset + cbWanted > cbSize)

  0002d	8b 4d ec	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  00030	03 4d f4	 add	 ecx, DWORD PTR _cbWanted$[ebp]
  00033	3b 4d 0c	 cmp	 ecx, DWORD PTR _cbSize$[ebp]
  00036	76 0a		 jbe	 SHORT $L10290

; 389  :     {
; 390  :         return WMAERR_BUFFERTOOSMALL;

  00038	b8 03 00 00 00	 mov	 eax, 3
  0003d	e9 5e 06 00 00	 jmp	 $L10267
$L10290:

; 391  :     }
; 392  :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 393  :                                 pInt->pCallbackContext,
; 394  :                                 pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  00042	8d 55 f8	 lea	 edx, DWORD PTR _pData$[ebp]
  00045	52		 push	 edx
  00046	8b 45 f4	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0004d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004f	03 55 ec	 add	 edx, DWORD PTR _cbObjectOffset$[ebp]
  00052	52		 push	 edx
  00053	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00056	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  0005c	51		 push	 ecx
  0005d	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00066	89 45 ac	 mov	 DWORD PTR _cbActual$[ebp], eax

; 395  :     if(cbActual != cbWanted)

  00069	8b 45 ac	 mov	 eax, DWORD PTR _cbActual$[ebp]
  0006c	3b 45 f4	 cmp	 eax, DWORD PTR _cbWanted$[ebp]
  0006f	74 0a		 je	 SHORT $L10292

; 396  :     {
; 397  :         return WMAERR_BUFFERTOOSMALL;

  00071	b8 03 00 00 00	 mov	 eax, 3
  00076	e9 25 06 00 00	 jmp	 $L10267
$L10292:

; 398  :     }
; 399  :     cbObjectOffset += cbActual;

  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  0007e	03 4d ac	 add	 ecx, DWORD PTR _cbActual$[ebp]
  00081	89 4d ec	 mov	 DWORD PTR _cbObjectOffset$[ebp], ecx

; 400  : 
; 401  :     LoadGUID(streamType, pData);

  00084	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00087	8b 02		 mov	 eax, DWORD PTR [edx]
  00089	89 45 c4	 mov	 DWORD PTR _streamType$[ebp], eax
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  0008f	83 c1 04	 add	 ecx, 4
  00092	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  00095	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00098	66 8b 02	 mov	 ax, WORD PTR [edx]
  0009b	66 89 45 c8	 mov	 WORD PTR _streamType$[ebp+4], ax
  0009f	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  000a2	83 c1 02	 add	 ecx, 2
  000a5	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  000a8	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  000ab	66 8b 02	 mov	 ax, WORD PTR [edx]
  000ae	66 89 45 ca	 mov	 WORD PTR _streamType$[ebp+6], ax
  000b2	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  000b5	83 c1 02	 add	 ecx, 2
  000b8	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  000bb	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  000be	8a 02		 mov	 al, BYTE PTR [edx]
  000c0	88 45 cc	 mov	 BYTE PTR _streamType$[ebp+8], al
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  000c6	83 c1 01	 add	 ecx, 1
  000c9	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  000cc	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  000cf	8a 02		 mov	 al, BYTE PTR [edx]
  000d1	88 45 cd	 mov	 BYTE PTR _streamType$[ebp+9], al
  000d4	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  000d7	83 c1 01	 add	 ecx, 1
  000da	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  000dd	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  000e0	8a 02		 mov	 al, BYTE PTR [edx]
  000e2	88 45 ce	 mov	 BYTE PTR _streamType$[ebp+10], al
  000e5	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  000e8	83 c1 01	 add	 ecx, 1
  000eb	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  000ee	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  000f1	8a 02		 mov	 al, BYTE PTR [edx]
  000f3	88 45 cf	 mov	 BYTE PTR _streamType$[ebp+11], al
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  000f9	83 c1 01	 add	 ecx, 1
  000fc	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  000ff	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00102	8a 02		 mov	 al, BYTE PTR [edx]
  00104	88 45 d0	 mov	 BYTE PTR _streamType$[ebp+12], al
  00107	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  0010a	83 c1 01	 add	 ecx, 1
  0010d	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  00110	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00113	8a 02		 mov	 al, BYTE PTR [edx]
  00115	88 45 d1	 mov	 BYTE PTR _streamType$[ebp+13], al
  00118	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  0011b	83 c1 01	 add	 ecx, 1
  0011e	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  00121	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00124	8a 02		 mov	 al, BYTE PTR [edx]
  00126	88 45 d2	 mov	 BYTE PTR _streamType$[ebp+14], al
  00129	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  0012c	83 c1 01	 add	 ecx, 1
  0012f	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  00132	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00135	8a 02		 mov	 al, BYTE PTR [edx]
  00137	88 45 d3	 mov	 BYTE PTR _streamType$[ebp+15], al
  0013a	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  0013d	83 c1 01	 add	 ecx, 1
  00140	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx

; 402  :     LoadGUID(ecStrategy, pData);

  00143	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00146	8b 02		 mov	 eax, DWORD PTR [edx]
  00148	89 45 b4	 mov	 DWORD PTR _ecStrategy$[ebp], eax
  0014b	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  0014e	83 c1 04	 add	 ecx, 4
  00151	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  00154	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00157	66 8b 02	 mov	 ax, WORD PTR [edx]
  0015a	66 89 45 b8	 mov	 WORD PTR _ecStrategy$[ebp+4], ax
  0015e	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  00161	83 c1 02	 add	 ecx, 2
  00164	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  00167	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  0016a	66 8b 02	 mov	 ax, WORD PTR [edx]
  0016d	66 89 45 ba	 mov	 WORD PTR _ecStrategy$[ebp+6], ax
  00171	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  00174	83 c1 02	 add	 ecx, 2
  00177	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  0017a	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  0017d	8a 02		 mov	 al, BYTE PTR [edx]
  0017f	88 45 bc	 mov	 BYTE PTR _ecStrategy$[ebp+8], al
  00182	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  00185	83 c1 01	 add	 ecx, 1
  00188	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  0018b	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  0018e	8a 02		 mov	 al, BYTE PTR [edx]
  00190	88 45 bd	 mov	 BYTE PTR _ecStrategy$[ebp+9], al
  00193	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  00196	83 c1 01	 add	 ecx, 1
  00199	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  0019c	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  0019f	8a 02		 mov	 al, BYTE PTR [edx]
  001a1	88 45 be	 mov	 BYTE PTR _ecStrategy$[ebp+10], al
  001a4	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  001a7	83 c1 01	 add	 ecx, 1
  001aa	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  001ad	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  001b0	8a 02		 mov	 al, BYTE PTR [edx]
  001b2	88 45 bf	 mov	 BYTE PTR _ecStrategy$[ebp+11], al
  001b5	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  001b8	83 c1 01	 add	 ecx, 1
  001bb	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  001be	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  001c1	8a 02		 mov	 al, BYTE PTR [edx]
  001c3	88 45 c0	 mov	 BYTE PTR _ecStrategy$[ebp+12], al
  001c6	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  001c9	83 c1 01	 add	 ecx, 1
  001cc	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  001cf	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  001d2	8a 02		 mov	 al, BYTE PTR [edx]
  001d4	88 45 c1	 mov	 BYTE PTR _ecStrategy$[ebp+13], al
  001d7	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  001da	83 c1 01	 add	 ecx, 1
  001dd	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  001e0	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  001e3	8a 02		 mov	 al, BYTE PTR [edx]
  001e5	88 45 c2	 mov	 BYTE PTR _ecStrategy$[ebp+14], al
  001e8	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  001eb	83 c1 01	 add	 ecx, 1
  001ee	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx
  001f1	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  001f4	8a 02		 mov	 al, BYTE PTR [edx]
  001f6	88 45 c3	 mov	 BYTE PTR _ecStrategy$[ebp+15], al
  001f9	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  001fc	83 c1 01	 add	 ecx, 1
  001ff	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx

; 403  :     LoadQWORD(qwOffset, pData);

  00202	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00205	8b 02		 mov	 eax, DWORD PTR [edx]
  00207	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0020a	89 45 d8	 mov	 DWORD PTR _qwOffset$[ebp], eax
  0020d	89 4d dc	 mov	 DWORD PTR _qwOffset$[ebp+4], ecx
  00210	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00213	83 c2 08	 add	 edx, 8
  00216	89 55 f8	 mov	 DWORD PTR _pData$[ebp], edx

; 404  :     LoadDWORD(cbTypeSpecific, pData);

  00219	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  0021c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021e	89 4d fc	 mov	 DWORD PTR _cbTypeSpecific$[ebp], ecx
  00221	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00224	83 c2 04	 add	 edx, 4
  00227	89 55 f8	 mov	 DWORD PTR _pData$[ebp], edx

; 405  :     LoadDWORD(cbErrConcealment, pData);

  0022a	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  0022d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022f	89 4d d4	 mov	 DWORD PTR _cbErrConcealment$[ebp], ecx
  00232	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00235	83 c2 04	 add	 edx, 4
  00238	89 55 f8	 mov	 DWORD PTR _pData$[ebp], edx

; 406  :     LoadWORD(wStreamNum, pData);

  0023b	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  0023e	66 8b 08	 mov	 cx, WORD PTR [eax]
  00241	66 89 4d e0	 mov	 WORD PTR _wStreamNum$[ebp], cx
  00245	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00248	83 c2 02	 add	 edx, 2
  0024b	89 55 f8	 mov	 DWORD PTR _pData$[ebp], edx

; 407  :     LoadDWORD(dwJunk, pData);

  0024e	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  00251	8b 08		 mov	 ecx, DWORD PTR [eax]
  00253	89 4d a8	 mov	 DWORD PTR _dwJunk$[ebp], ecx
  00256	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00259	83 c2 04	 add	 edx, 4
  0025c	89 55 f8	 mov	 DWORD PTR _pData$[ebp], edx

; 408  : 
; 409  :     wStreamNum &= 0x7F;

  0025f	0f b7 45 e0	 movzx	 eax, WORD PTR _wStreamNum$[ebp]
  00263	83 e0 7f	 and	 eax, 127		; 0000007fH
  00266	66 89 45 e0	 mov	 WORD PTR _wStreamNum$[ebp], ax

; 410  : 
; 411  :     if( !WMA_IsEqualGUID( &CLSID_AsfXStreamTypeAcmAudio, &streamType ) )

  0026a	6a 10		 push	 16			; 00000010H
  0026c	8d 4d c4	 lea	 ecx, DWORD PTR _streamType$[ebp]
  0026f	51		 push	 ecx
  00270	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_AsfXStreamTypeAcmAudio_XDS
  00275	e8 00 00 00 00	 call	 _memcmp
  0027a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027d	85 c0		 test	 eax, eax
  0027f	74 14		 je	 SHORT $L10350

; 412  :     {
; 413  : #ifndef WMAAPI_NO_DRM_STREAM
; 414  :         /* Remember the DRM Aux Data stream number */
; 415  :         if( WMA_IsEqualGUID( &CLSID_AsfXStreamTypeDRMAuxData, &streamType ) )
; 416  :         {
; 417  :             pInt->bDRMAuxStreamNum = (BYTE) wStreamNum;
; 418  :         }
; 419  : #endif  /* WMAAPI_NO_DRM_STREAM */
; 420  : 
; 421  :         /* Skip over the rest */
; 422  :         pInt->currPacketOffset += cbSize;

  00281	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00284	8b 02		 mov	 eax, DWORD PTR [edx]
  00286	03 45 0c	 add	 eax, DWORD PTR _cbSize$[ebp]
  00289	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0028c	89 01		 mov	 DWORD PTR [ecx], eax

; 423  :         return WMAERR_OK;

  0028e	33 c0		 xor	 eax, eax
  00290	e9 0b 04 00 00	 jmp	 $L10267
$L10350:

; 424  :     }
; 425  : 
; 426  :     /* Type specific */
; 427  :     pInt->wAudioStreamId = wStreamNum; //Amit

  00295	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00298	66 8b 45 e0	 mov	 ax, WORD PTR _wStreamNum$[ebp]
  0029c	66 89 82 bc 00
	00 00		 mov	 WORD PTR [edx+188], ax

; 428  : 
; 429  :     if(cbTypeSpecific > 0)

  002a3	83 7d fc 00	 cmp	 DWORD PTR _cbTypeSpecific$[ebp], 0
  002a7	0f 86 98 02 00
	00		 jbe	 $L10351

; 430  :     {
; 431  :         cbWanted = cbTypeSpecific;

  002ad	8b 4d fc	 mov	 ecx, DWORD PTR _cbTypeSpecific$[ebp]
  002b0	89 4d f4	 mov	 DWORD PTR _cbWanted$[ebp], ecx

; 432  :         if(cbObjectOffset + cbWanted > cbSize)

  002b3	8b 55 ec	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  002b6	03 55 f4	 add	 edx, DWORD PTR _cbWanted$[ebp]
  002b9	3b 55 0c	 cmp	 edx, DWORD PTR _cbSize$[ebp]
  002bc	76 0a		 jbe	 SHORT $L10352

; 433  :         {
; 434  :             return WMAERR_BUFFERTOOSMALL;

  002be	b8 03 00 00 00	 mov	 eax, 3
  002c3	e9 d8 03 00 00	 jmp	 $L10267
$L10352:

; 435  :         }
; 436  :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 437  :                                     pInt->pCallbackContext,
; 438  :                                     pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  002c8	8d 45 f8	 lea	 eax, DWORD PTR _pData$[ebp]
  002cb	50		 push	 eax
  002cc	8b 4d f4	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  002cf	51		 push	 ecx
  002d0	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  002d3	8b 02		 mov	 eax, DWORD PTR [edx]
  002d5	03 45 ec	 add	 eax, DWORD PTR _cbObjectOffset$[ebp]
  002d8	50		 push	 eax
  002d9	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  002dc	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  002e2	52		 push	 edx
  002e3	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  002ec	89 45 ac	 mov	 DWORD PTR _cbActual$[ebp], eax

; 439  :         if(cbActual != cbWanted)

  002ef	8b 4d ac	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  002f2	3b 4d f4	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  002f5	74 0a		 je	 SHORT $L10354

; 440  :         {
; 441  :             return WMAERR_BUFFERTOOSMALL;

  002f7	b8 03 00 00 00	 mov	 eax, 3
  002fc	e9 9f 03 00 00	 jmp	 $L10267
$L10354:

; 442  :         }
; 443  :         cbObjectOffset += cbActual;

  00301	8b 55 ec	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  00304	03 55 ac	 add	 edx, DWORD PTR _cbActual$[ebp]
  00307	89 55 ec	 mov	 DWORD PTR _cbObjectOffset$[ebp], edx

; 444  : 
; 445  :         tp = pData;

  0030a	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  0030d	89 45 a4	 mov	 DWORD PTR _tp$[ebp], eax

; 446  :         LoadWORD (tw ,tp);

  00310	8b 4d a4	 mov	 ecx, DWORD PTR _tp$[ebp]
  00313	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00316	66 89 55 b0	 mov	 WORD PTR _tw$[ebp], dx
  0031a	8b 45 a4	 mov	 eax, DWORD PTR _tp$[ebp]
  0031d	83 c0 02	 add	 eax, 2
  00320	89 45 a4	 mov	 DWORD PTR _tp$[ebp], eax

; 447  : 
; 448  :         switch(tw)
; 449  :         {

  00323	0f b7 4d b0	 movzx	 ecx, WORD PTR _tw$[ebp]
  00327	89 4d a0	 mov	 DWORD PTR tv209[ebp], ecx
  0032a	81 7d a0 60 01
	00 00		 cmp	 DWORD PTR tv209[ebp], 352 ; 00000160H
  00331	0f 84 09 01 00
	00		 je	 $L10375
  00337	81 7d a0 61 01
	00 00		 cmp	 DWORD PTR tv209[ebp], 353 ; 00000161H
  0033e	74 05		 je	 SHORT $L10361
  00340	e9 f6 01 00 00	 jmp	 $L10389
$L10361:

; 450  :         case WAVE_FORMAT_WMAUDIO2:
; 451  : 
; 452  :             if(cbTypeSpecific < 28 /*sizeof(WMAUDIO2WAVEFORMAT)*/)

  00345	83 7d fc 1c	 cmp	 DWORD PTR _cbTypeSpecific$[ebp], 28 ; 0000001cH
  00349	73 0a		 jae	 SHORT $L10362

; 453  :             {
; 454  :                 return WMAERR_FAIL;

  0034b	b8 01 00 00 00	 mov	 eax, 1
  00350	e9 4b 03 00 00	 jmp	 $L10267
$L10362:

; 455  :             }
; 456  : 
; 457  :             pInt->nVersion         = 2;

  00355	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00358	66 c7 42 28 02
	00		 mov	 WORD PTR [edx+40], 2

; 458  : 		    tp = pData +  4; LoadDWORD(tdw,tp); 

  0035e	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  00361	83 c0 04	 add	 eax, 4
  00364	89 45 a4	 mov	 DWORD PTR _tp$[ebp], eax
  00367	8b 4d a4	 mov	 ecx, DWORD PTR _tp$[ebp]
  0036a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0036c	89 55 e8	 mov	 DWORD PTR _tdw$[ebp], edx
  0036f	8b 45 a4	 mov	 eax, DWORD PTR _tp$[ebp]
  00372	83 c0 04	 add	 eax, 4
  00375	89 45 a4	 mov	 DWORD PTR _tp$[ebp], eax

; 459  :             pInt->nSamplesPerSec   = tdw;

  00378	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0037b	8b 55 e8	 mov	 edx, DWORD PTR _tdw$[ebp]
  0037e	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 460  :             tp = pData +  8; LoadDWORD(tdw,tp);

  00381	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  00384	83 c0 08	 add	 eax, 8
  00387	89 45 a4	 mov	 DWORD PTR _tp$[ebp], eax
  0038a	8b 4d a4	 mov	 ecx, DWORD PTR _tp$[ebp]
  0038d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0038f	89 55 e8	 mov	 DWORD PTR _tdw$[ebp], edx
  00392	8b 45 a4	 mov	 eax, DWORD PTR _tp$[ebp]
  00395	83 c0 04	 add	 eax, 4
  00398	89 45 a4	 mov	 DWORD PTR _tp$[ebp], eax

; 461  :             pInt->nAvgBytesPerSec  = tdw;

  0039b	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0039e	8b 55 e8	 mov	 edx, DWORD PTR _tdw$[ebp]
  003a1	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 462  :             tp = pData + 12; LoadWORD (tw ,tp);

  003a4	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  003a7	83 c0 0c	 add	 eax, 12			; 0000000cH
  003aa	89 45 a4	 mov	 DWORD PTR _tp$[ebp], eax
  003ad	8b 4d a4	 mov	 ecx, DWORD PTR _tp$[ebp]
  003b0	66 8b 11	 mov	 dx, WORD PTR [ecx]
  003b3	66 89 55 b0	 mov	 WORD PTR _tw$[ebp], dx
  003b7	8b 45 a4	 mov	 eax, DWORD PTR _tp$[ebp]
  003ba	83 c0 02	 add	 eax, 2
  003bd	89 45 a4	 mov	 DWORD PTR _tp$[ebp], eax

; 463  :             pInt->nBlockAlign      = tw;

  003c0	0f b7 4d b0	 movzx	 ecx, WORD PTR _tw$[ebp]
  003c4	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  003c7	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 464  :             tp = pData +  2; LoadWORD (tw ,tp);

  003ca	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  003cd	83 c0 02	 add	 eax, 2
  003d0	89 45 a4	 mov	 DWORD PTR _tp$[ebp], eax
  003d3	8b 4d a4	 mov	 ecx, DWORD PTR _tp$[ebp]
  003d6	66 8b 11	 mov	 dx, WORD PTR [ecx]
  003d9	66 89 55 b0	 mov	 WORD PTR _tw$[ebp], dx
  003dd	8b 45 a4	 mov	 eax, DWORD PTR _tp$[ebp]
  003e0	83 c0 02	 add	 eax, 2
  003e3	89 45 a4	 mov	 DWORD PTR _tp$[ebp], eax

; 465  :             pInt->nChannels        = tw;

  003e6	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  003e9	66 8b 55 b0	 mov	 dx, WORD PTR _tw$[ebp]
  003ed	66 89 51 38	 mov	 WORD PTR [ecx+56], dx

; 466  : 	        tp = pData + 22; LoadWORD (tw ,tp);

  003f1	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  003f4	83 c0 16	 add	 eax, 22			; 00000016H
  003f7	89 45 a4	 mov	 DWORD PTR _tp$[ebp], eax
  003fa	8b 4d a4	 mov	 ecx, DWORD PTR _tp$[ebp]
  003fd	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00400	66 89 55 b0	 mov	 WORD PTR _tw$[ebp], dx
  00404	8b 45 a4	 mov	 eax, DWORD PTR _tp$[ebp]
  00407	83 c0 02	 add	 eax, 2
  0040a	89 45 a4	 mov	 DWORD PTR _tp$[ebp], eax

; 467  : 	        tp = pData + 18; LoadDWORD(tdw,tp);

  0040d	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  00410	83 c1 12	 add	 ecx, 18			; 00000012H
  00413	89 4d a4	 mov	 DWORD PTR _tp$[ebp], ecx
  00416	8b 55 a4	 mov	 edx, DWORD PTR _tp$[ebp]
  00419	8b 02		 mov	 eax, DWORD PTR [edx]
  0041b	89 45 e8	 mov	 DWORD PTR _tdw$[ebp], eax
  0041e	8b 4d a4	 mov	 ecx, DWORD PTR _tp$[ebp]
  00421	83 c1 04	 add	 ecx, 4
  00424	89 4d a4	 mov	 DWORD PTR _tp$[ebp], ecx

; 468  :             pInt->nSamplesPerBlock = tdw;

  00427	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0042a	8b 45 e8	 mov	 eax, DWORD PTR _tdw$[ebp]
  0042d	89 42 3c	 mov	 DWORD PTR [edx+60], eax

; 469  :             pInt->nEncodeOpt       = tw;

  00430	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00433	66 8b 55 b0	 mov	 dx, WORD PTR _tw$[ebp]
  00437	66 89 51 40	 mov	 WORD PTR [ecx+64], dx

; 470  : 
; 471  :             break;

  0043b	e9 05 01 00 00	 jmp	 $L10351
$L10375:

; 472  :         case WAVE_FORMAT_MSAUDIO1:
; 473  :             if(cbTypeSpecific < 22 /*sizeof(MSAUDIO1WAVEFORMAT)*/)

  00440	83 7d fc 16	 cmp	 DWORD PTR _cbTypeSpecific$[ebp], 22 ; 00000016H
  00444	73 0a		 jae	 SHORT $L10376

; 474  :             {
; 475  :                 return WMAERR_FAIL;

  00446	b8 01 00 00 00	 mov	 eax, 1
  0044b	e9 50 02 00 00	 jmp	 $L10267
$L10376:

; 476  :             }
; 477  : 
; 478  :             pInt->nVersion         = 1;

  00450	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00453	66 c7 40 28 01
	00		 mov	 WORD PTR [eax+40], 1

; 479  : 		    tp = pData +  4; LoadDWORD(tdw,tp); 

  00459	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  0045c	83 c1 04	 add	 ecx, 4
  0045f	89 4d a4	 mov	 DWORD PTR _tp$[ebp], ecx
  00462	8b 55 a4	 mov	 edx, DWORD PTR _tp$[ebp]
  00465	8b 02		 mov	 eax, DWORD PTR [edx]
  00467	89 45 e8	 mov	 DWORD PTR _tdw$[ebp], eax
  0046a	8b 4d a4	 mov	 ecx, DWORD PTR _tp$[ebp]
  0046d	83 c1 04	 add	 ecx, 4
  00470	89 4d a4	 mov	 DWORD PTR _tp$[ebp], ecx

; 480  :             pInt->nSamplesPerSec   = tdw;

  00473	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00476	8b 45 e8	 mov	 eax, DWORD PTR _tdw$[ebp]
  00479	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 481  :             tp = pData +  8; LoadDWORD(tdw,tp);

  0047c	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  0047f	83 c1 08	 add	 ecx, 8
  00482	89 4d a4	 mov	 DWORD PTR _tp$[ebp], ecx
  00485	8b 55 a4	 mov	 edx, DWORD PTR _tp$[ebp]
  00488	8b 02		 mov	 eax, DWORD PTR [edx]
  0048a	89 45 e8	 mov	 DWORD PTR _tdw$[ebp], eax
  0048d	8b 4d a4	 mov	 ecx, DWORD PTR _tp$[ebp]
  00490	83 c1 04	 add	 ecx, 4
  00493	89 4d a4	 mov	 DWORD PTR _tp$[ebp], ecx

; 482  :             pInt->nAvgBytesPerSec  = tdw;

  00496	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00499	8b 45 e8	 mov	 eax, DWORD PTR _tdw$[ebp]
  0049c	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 483  :             tp = pData + 12; LoadWORD (tw ,tp);

  0049f	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  004a2	83 c1 0c	 add	 ecx, 12			; 0000000cH
  004a5	89 4d a4	 mov	 DWORD PTR _tp$[ebp], ecx
  004a8	8b 55 a4	 mov	 edx, DWORD PTR _tp$[ebp]
  004ab	66 8b 02	 mov	 ax, WORD PTR [edx]
  004ae	66 89 45 b0	 mov	 WORD PTR _tw$[ebp], ax
  004b2	8b 4d a4	 mov	 ecx, DWORD PTR _tp$[ebp]
  004b5	83 c1 02	 add	 ecx, 2
  004b8	89 4d a4	 mov	 DWORD PTR _tp$[ebp], ecx

; 484  :             pInt->nBlockAlign      = tw;

  004bb	0f b7 55 b0	 movzx	 edx, WORD PTR _tw$[ebp]
  004bf	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  004c2	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 485  :             tp = pData +  2; LoadWORD (tw ,tp);

  004c5	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  004c8	83 c1 02	 add	 ecx, 2
  004cb	89 4d a4	 mov	 DWORD PTR _tp$[ebp], ecx
  004ce	8b 55 a4	 mov	 edx, DWORD PTR _tp$[ebp]
  004d1	66 8b 02	 mov	 ax, WORD PTR [edx]
  004d4	66 89 45 b0	 mov	 WORD PTR _tw$[ebp], ax
  004d8	8b 4d a4	 mov	 ecx, DWORD PTR _tp$[ebp]
  004db	83 c1 02	 add	 ecx, 2
  004de	89 4d a4	 mov	 DWORD PTR _tp$[ebp], ecx

; 486  :             pInt->nChannels        = tw;

  004e1	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  004e4	66 8b 45 b0	 mov	 ax, WORD PTR _tw$[ebp]
  004e8	66 89 42 38	 mov	 WORD PTR [edx+56], ax

; 487  : 	        tp = pData + 20; LoadWORD (tw,tp);

  004ec	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  004ef	83 c1 14	 add	 ecx, 20			; 00000014H
  004f2	89 4d a4	 mov	 DWORD PTR _tp$[ebp], ecx
  004f5	8b 55 a4	 mov	 edx, DWORD PTR _tp$[ebp]
  004f8	66 8b 02	 mov	 ax, WORD PTR [edx]
  004fb	66 89 45 b0	 mov	 WORD PTR _tw$[ebp], ax
  004ff	8b 4d a4	 mov	 ecx, DWORD PTR _tp$[ebp]
  00502	83 c1 02	 add	 ecx, 2
  00505	89 4d a4	 mov	 DWORD PTR _tp$[ebp], ecx

; 488  :             pInt->nEncodeOpt       = tw;

  00508	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0050b	66 8b 45 b0	 mov	 ax, WORD PTR _tw$[ebp]
  0050f	66 89 42 40	 mov	 WORD PTR [edx+64], ax

; 489  : 	        tp = pData + 18; LoadWORD (tw,tp);

  00513	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  00516	83 c1 12	 add	 ecx, 18			; 00000012H
  00519	89 4d a4	 mov	 DWORD PTR _tp$[ebp], ecx
  0051c	8b 55 a4	 mov	 edx, DWORD PTR _tp$[ebp]
  0051f	66 8b 02	 mov	 ax, WORD PTR [edx]
  00522	66 89 45 b0	 mov	 WORD PTR _tw$[ebp], ax
  00526	8b 4d a4	 mov	 ecx, DWORD PTR _tp$[ebp]
  00529	83 c1 02	 add	 ecx, 2
  0052c	89 4d a4	 mov	 DWORD PTR _tp$[ebp], ecx

; 490  :             pInt->nSamplesPerBlock = tw;

  0052f	0f b7 55 b0	 movzx	 edx, WORD PTR _tw$[ebp]
  00533	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00536	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 491  : 
; 492  :             break;

  00539	eb 0a		 jmp	 SHORT $L10351
$L10389:

; 493  :         default:
; 494  :             // unknown...
; 495  :             return WMAERR_FAIL;

  0053b	b8 01 00 00 00	 mov	 eax, 1
  00540	e9 5b 01 00 00	 jmp	 $L10267
$L10351:

; 496  :         }
; 497  :     }
; 498  : 
; 499  :     /* Error concealment - this can get as big as 400!!! */
; 500  : 
; 501  :     if(cbErrConcealment > 0)

  00545	83 7d d4 00	 cmp	 DWORD PTR _cbErrConcealment$[ebp], 0
  00549	0f 86 15 01 00
	00		 jbe	 $L10390

; 502  :     {
; 503  :         if(WMA_IsEqualGUID(&CLSID_AsfXSignatureAudioErrorMaskingStrategy, &ecStrategy))

  0054f	6a 10		 push	 16			; 00000010H
  00551	8d 4d b4	 lea	 ecx, DWORD PTR _ecStrategy$[ebp]
  00554	51		 push	 ecx
  00555	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_AsfXSignatureAudioErrorMaskingStrategy_XDS
  0055a	e8 00 00 00 00	 call	 _memcmp
  0055f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00562	85 c0		 test	 eax, eax
  00564	75 09		 jne	 SHORT $L10394

; 504  :         {
; 505  :             cbWanted = sizeof(AsfXSignatureAudioErrorMaskingData);

  00566	c7 45 f4 09 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 9

; 506  :         }
; 507  :         else if(WMA_IsEqualGUID(&CLSID_AsfXAcmAudioErrorMaskingStrategy, &ecStrategy))

  0056d	eb 2a		 jmp	 SHORT $L10396
$L10394:
  0056f	6a 10		 push	 16			; 00000010H
  00571	8d 55 b4	 lea	 edx, DWORD PTR _ecStrategy$[ebp]
  00574	52		 push	 edx
  00575	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_AsfXAcmAudioErrorMaskingStrategy_XDS
  0057a	e8 00 00 00 00	 call	 _memcmp
  0057f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00582	85 c0		 test	 eax, eax
  00584	75 09		 jne	 SHORT $L10400

; 508  :         {
; 509  : //            cbWanted = sizeof(AsfXAcmAudioErrorMaskingData);
; 510  :             cbWanted = 8;

  00586	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 8

; 511  :         }
; 512  :         else

  0058d	eb 0a		 jmp	 SHORT $L10396
$L10400:

; 513  :         {
; 514  :             return WMAERR_FAIL;

  0058f	b8 01 00 00 00	 mov	 eax, 1
  00594	e9 07 01 00 00	 jmp	 $L10267
$L10396:

; 515  :         }
; 516  : 
; 517  :         if(cbObjectOffset + cbWanted > cbSize)

  00599	8b 45 ec	 mov	 eax, DWORD PTR _cbObjectOffset$[ebp]
  0059c	03 45 f4	 add	 eax, DWORD PTR _cbWanted$[ebp]
  0059f	3b 45 0c	 cmp	 eax, DWORD PTR _cbSize$[ebp]
  005a2	76 0a		 jbe	 SHORT $L10402

; 518  :         {
; 519  :             return WMAERR_BUFFERTOOSMALL;

  005a4	b8 03 00 00 00	 mov	 eax, 3
  005a9	e9 f2 00 00 00	 jmp	 $L10267
$L10402:

; 520  :         }
; 521  :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 522  :                                     pInt->pCallbackContext,
; 523  :                                     pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  005ae	8d 4d f8	 lea	 ecx, DWORD PTR _pData$[ebp]
  005b1	51		 push	 ecx
  005b2	8b 55 f4	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  005b5	52		 push	 edx
  005b6	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  005b9	8b 08		 mov	 ecx, DWORD PTR [eax]
  005bb	03 4d ec	 add	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  005be	51		 push	 ecx
  005bf	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  005c2	8b 82 c0 00 00
	00		 mov	 eax, DWORD PTR [edx+192]
  005c8	50		 push	 eax
  005c9	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  005cc	51		 push	 ecx
  005cd	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  005d2	89 45 ac	 mov	 DWORD PTR _cbActual$[ebp], eax

; 524  :         if(cbActual != cbWanted)

  005d5	8b 55 ac	 mov	 edx, DWORD PTR _cbActual$[ebp]
  005d8	3b 55 f4	 cmp	 edx, DWORD PTR _cbWanted$[ebp]
  005db	74 0a		 je	 SHORT $L10404

; 525  :         {
; 526  :             return WMAERR_BUFFERTOOSMALL;

  005dd	b8 03 00 00 00	 mov	 eax, 3
  005e2	e9 b9 00 00 00	 jmp	 $L10267
$L10404:

; 527  :         }
; 528  :         cbObjectOffset += cbErrConcealment; // Skip over the rest - cbActual;

  005e7	8b 45 ec	 mov	 eax, DWORD PTR _cbObjectOffset$[ebp]
  005ea	03 45 d4	 add	 eax, DWORD PTR _cbErrConcealment$[ebp]
  005ed	89 45 ec	 mov	 DWORD PTR _cbObjectOffset$[ebp], eax

; 529  : 
; 530  :         if(WMA_IsEqualGUID(&CLSID_AsfXSignatureAudioErrorMaskingStrategy, &ecStrategy))

  005f0	6a 10		 push	 16			; 00000010H
  005f2	8d 4d b4	 lea	 ecx, DWORD PTR _ecStrategy$[ebp]
  005f5	51		 push	 ecx
  005f6	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_AsfXSignatureAudioErrorMaskingStrategy_XDS
  005fb	e8 00 00 00 00	 call	 _memcmp
  00600	83 c4 0c	 add	 esp, 12			; 0000000cH
  00603	85 c0		 test	 eax, eax
  00605	75 0d		 jne	 SHORT $L10408

; 531  :         {
; 532  :             pInt->cbAudioSize = ((AsfXSignatureAudioErrorMaskingData *)pData)->maxObjectSize;

  00607	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0060a	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  0060d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0060f	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 533  :             
; 534  : #ifdef BIG_ENDIAN
; 535  : 			// byte-swap the object size
; 536  : 			SWAP_DWORD(pInt->cbAudioSize);
; 537  : #endif
; 538  : 
; 539  :         }
; 540  :         else if(WMA_IsEqualGUID(&CLSID_AsfXAcmAudioErrorMaskingStrategy, &ecStrategy))

  00612	eb 50		 jmp	 SHORT $L10390
$L10408:
  00614	6a 10		 push	 16			; 00000010H
  00616	8d 55 b4	 lea	 edx, DWORD PTR _ecStrategy$[ebp]
  00619	52		 push	 edx
  0061a	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_AsfXAcmAudioErrorMaskingStrategy_XDS
  0061f	e8 00 00 00 00	 call	 _memcmp
  00624	83 c4 0c	 add	 esp, 12			; 0000000cH
  00627	85 c0		 test	 eax, eax
  00629	75 32		 jne	 SHORT $L10414

; 541  :         {
; 542  :             pScramblingData = (AsfXAcmAudioErrorMaskingData *)pData;

  0062b	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  0062e	89 45 f0	 mov	 DWORD PTR _pScramblingData$[ebp], eax

; 543  :             
; 544  : #ifdef BIG_ENDIAN
; 545  : 			// byte-swap the struct
; 546  : 			ByteSwapAsfXAcmAudioErrorMaskingData( *pScramblingData );
; 547  : #endif
; 548  : 
; 549  : 
; 550  : //            pInt->cbAudioSize = (DWORD)(pScramblingData->virtualPacketLen*pScramblingData->span);
; 551  :             pInt->cbAudioSize = (DWORD)(((WORD)(pData+1)) * ((WORD)(*pData)));

  00631	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  00634	83 c1 01	 add	 ecx, 1
  00637	0f b7 d1	 movzx	 edx, cx
  0063a	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  0063d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00640	0f af d1	 imul	 edx, ecx
  00643	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00646	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 552  : 
; 553  : 			if (pScramblingData->span >1)

  00649	8b 4d f0	 mov	 ecx, DWORD PTR _pScramblingData$[ebp]
  0064c	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0064f	83 fa 01	 cmp	 edx, 1
  00652	7e 07		 jle	 SHORT $L10419

; 554  : 				return WMAERR_FAIL;

  00654	b8 01 00 00 00	 mov	 eax, 1
  00659	eb 45		 jmp	 SHORT $L10267
$L10419:

; 555  :             
; 556  : #ifdef BIG_ENDIAN
; 557  : 			// byte-swap the object size
; 558  : 			SWAP_DWORD(pInt->cbAudioSize);
; 559  : #endif
; 560  :         }
; 561  :         else

  0065b	eb 07		 jmp	 SHORT $L10390
$L10414:

; 562  :         {
; 563  :             return WMAERR_FAIL;

  0065d	b8 01 00 00 00	 mov	 eax, 1
  00662	eb 3c		 jmp	 SHORT $L10267
$L10390:

; 564  :         }
; 565  :     }
; 566  : 
; 567  :     nBlocksPerObject = pInt->cbAudioSize/pInt->nBlockAlign;

  00664	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00667	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0066a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0066d	33 d2		 xor	 edx, edx
  0066f	f7 71 34	 div	 DWORD PTR [ecx+52]
  00672	89 45 e4	 mov	 DWORD PTR _nBlocksPerObject$[ebp], eax

; 568  :     pInt->cbAudioSize = nBlocksPerObject*pInt->nSamplesPerBlock*pInt->nChannels*2;

  00675	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00678	8b 45 e4	 mov	 eax, DWORD PTR _nBlocksPerObject$[ebp]
  0067b	0f af 42 3c	 imul	 eax, DWORD PTR [edx+60]
  0067f	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00682	0f b7 51 38	 movzx	 edx, WORD PTR [ecx+56]
  00686	0f af c2	 imul	 eax, edx
  00689	d1 e0		 shl	 eax, 1
  0068b	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0068e	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 569  : 
; 570  : #ifndef WMAAPI_NO_DRM_STREAM
; 571  :     /* Remember which stream contains the audio payloads */
; 572  :     pInt->bAudioStreamNum = (BYTE) wStreamNum;
; 573  : #endif  /* WMAAPI_NO_DRM_STREAM */
; 574  :     
; 575  :     /* use all */
; 576  :     pInt->currPacketOffset += cbSize;

  00691	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00694	8b 02		 mov	 eax, DWORD PTR [edx]
  00696	03 45 0c	 add	 eax, DWORD PTR _cbSize$[ebp]
  00699	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0069c	89 01		 mov	 DWORD PTR [ecx], eax

; 577  : 
; 578  :     return WMAERR_OK;

  0069e	33 c0		 xor	 eax, eax
$L10267:

; 579  : }

  006a0	8b e5		 mov	 esp, ebp
  006a2	5d		 pop	 ebp
  006a3	c2 0c 00	 ret	 12			; 0000000cH
_WMA_LoadAudioObject@12 ENDP
WMADEC	ENDS
PUBLIC	_WMA_LoadEncryptionObject@8
; Function compile flags: /Odt
;	COMDAT _WMA_LoadEncryptionObject@8
WMADEC	SEGMENT
_cbBlock$ = -20
_cbActual$ = -16
_cbObjectOffset$ = -12
_cbWanted$ = -8
_pData$ = -4
_pInt$ = 8
_cbSize$ = 12
_WMA_LoadEncryptionObject@8 PROC NEAR			; COMDAT

; 586  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 587  :     DWORD cbBlock;
; 588  : 
; 589  :     BYTE *pData;
; 590  :     DWORD cbWanted;
; 591  :     DWORD cbActual;
; 592  : 
; 593  :     DWORD cbObjectOffset = 0;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _cbObjectOffset$[ebp], 0

; 594  : 
; 595  :     if(pInt == NULL)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00011	75 0a		 jne	 SHORT $L10432

; 596  :     {
; 597  :         return WMAERR_INVALIDARG;

  00013	b8 02 00 00 00	 mov	 eax, 2
  00018	e9 b4 03 00 00	 jmp	 $L10425
$L10432:

; 598  :     }
; 599  : 
; 600  :     cbSize -= MIN_OBJECT_SIZE;

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _cbSize$[ebp]
  00020	83 e8 18	 sub	 eax, 24			; 00000018H
  00023	89 45 0c	 mov	 DWORD PTR _cbSize$[ebp], eax

; 601  : 
; 602  :     pInt->cbSecretData = 0;

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00029	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], 0

; 603  : 
; 604  :     /* SecretData */
; 605  : 
; 606  :     cbWanted = sizeof(DWORD);

  00030	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 4

; 607  :     if(cbObjectOffset + cbWanted > cbSize)

  00037	8b 55 f4	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  0003a	03 55 f8	 add	 edx, DWORD PTR _cbWanted$[ebp]
  0003d	3b 55 0c	 cmp	 edx, DWORD PTR _cbSize$[ebp]
  00040	76 0a		 jbe	 SHORT $L10434

; 608  :     {
; 609  :         return WMAERR_BUFFERTOOSMALL;

  00042	b8 03 00 00 00	 mov	 eax, 3
  00047	e9 85 03 00 00	 jmp	 $L10425
$L10434:

; 610  :     }
; 611  :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 612  :                                 pInt->pCallbackContext,
; 613  :                                 pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  0004c	8d 45 fc	 lea	 eax, DWORD PTR _pData$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00053	51		 push	 ecx
  00054	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00057	8b 02		 mov	 eax, DWORD PTR [edx]
  00059	03 45 f4	 add	 eax, DWORD PTR _cbObjectOffset$[ebp]
  0005c	50		 push	 eax
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00060	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  00066	52		 push	 edx
  00067	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00070	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 614  :     if(cbActual != cbWanted)

  00073	8b 4d f0	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  00076	3b 4d f8	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  00079	74 0a		 je	 SHORT $L10436

; 615  :     {
; 616  :         return WMAERR_BUFFERTOOSMALL;

  0007b	b8 03 00 00 00	 mov	 eax, 3
  00080	e9 4c 03 00 00	 jmp	 $L10425
$L10436:

; 617  :     }
; 618  :     cbObjectOffset += cbActual;

  00085	8b 55 f4	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  00088	03 55 f0	 add	 edx, DWORD PTR _cbActual$[ebp]
  0008b	89 55 f4	 mov	 DWORD PTR _cbObjectOffset$[ebp], edx

; 619  : 
; 620  :     LoadDWORD(pInt->cbSecretData, pData);

  0008e	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  00094	8b 11		 mov	 edx, DWORD PTR [ecx]
  00096	89 50 64	 mov	 DWORD PTR [eax+100], edx
  00099	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  0009c	83 c0 04	 add	 eax, 4
  0009f	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax

; 621  : 
; 622  :     if(pInt->cbSecretData)

  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000a5	83 79 64 00	 cmp	 DWORD PTR [ecx+100], 0
  000a9	74 77		 je	 SHORT $L10439

; 623  :     {
; 624  :         cbWanted = pInt->cbSecretData;

  000ab	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  000ae	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  000b1	89 45 f8	 mov	 DWORD PTR _cbWanted$[ebp], eax

; 625  :         if(cbObjectOffset + cbWanted > cbSize)

  000b4	8b 4d f4	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  000b7	03 4d f8	 add	 ecx, DWORD PTR _cbWanted$[ebp]
  000ba	3b 4d 0c	 cmp	 ecx, DWORD PTR _cbSize$[ebp]
  000bd	76 0a		 jbe	 SHORT $L10440

; 626  :         {
; 627  :             return WMAERR_BUFFERTOOSMALL;

  000bf	b8 03 00 00 00	 mov	 eax, 3
  000c4	e9 08 03 00 00	 jmp	 $L10425
$L10440:

; 628  :         }
; 629  :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 630  :                                     pInt->pCallbackContext,
; 631  :                                     pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  000c9	8d 55 fc	 lea	 edx, DWORD PTR _pData$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 f8	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  000d0	50		 push	 eax
  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000d4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d6	03 55 f4	 add	 edx, DWORD PTR _cbObjectOffset$[ebp]
  000d9	52		 push	 edx
  000da	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  000dd	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  000e3	51		 push	 ecx
  000e4	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  000ed	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 632  :         if(cbActual != cbWanted)

  000f0	8b 45 f0	 mov	 eax, DWORD PTR _cbActual$[ebp]
  000f3	3b 45 f8	 cmp	 eax, DWORD PTR _cbWanted$[ebp]
  000f6	74 0a		 je	 SHORT $L10442

; 633  :         {
; 634  :             return WMAERR_BUFFERTOOSMALL;

  000f8	b8 03 00 00 00	 mov	 eax, 3
  000fd	e9 cf 02 00 00	 jmp	 $L10425
$L10442:

; 635  :         }
; 636  :         cbObjectOffset += cbActual;

  00102	8b 4d f4	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  00105	03 4d f0	 add	 ecx, DWORD PTR _cbActual$[ebp]
  00108	89 4d f4	 mov	 DWORD PTR _cbObjectOffset$[ebp], ecx

; 637  : 
; 638  :         memcpy(pInt->pbSecretData, pData, (size_t)cbActual);

  0010b	8b 55 f0	 mov	 edx, DWORD PTR _cbActual$[ebp]
  0010e	52		 push	 edx
  0010f	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00112	50		 push	 eax
  00113	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00116	83 c1 42	 add	 ecx, 66			; 00000042H
  00119	51		 push	 ecx
  0011a	e8 00 00 00 00	 call	 _memcpy
  0011f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L10439:

; 639  :     }
; 640  : 
; 641  :     /* Type string */
; 642  : 
; 643  :     cbWanted = sizeof(DWORD);

  00122	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 4

; 644  :     if(cbObjectOffset + cbWanted > cbSize)

  00129	8b 55 f4	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  0012c	03 55 f8	 add	 edx, DWORD PTR _cbWanted$[ebp]
  0012f	3b 55 0c	 cmp	 edx, DWORD PTR _cbSize$[ebp]
  00132	76 0a		 jbe	 SHORT $L10445

; 645  :     {
; 646  :         return WMAERR_BUFFERTOOSMALL;

  00134	b8 03 00 00 00	 mov	 eax, 3
  00139	e9 93 02 00 00	 jmp	 $L10425
$L10445:

; 647  :     }
; 648  :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 649  :                                 pInt->pCallbackContext,
; 650  :                                 pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  0013e	8d 45 fc	 lea	 eax, DWORD PTR _pData$[ebp]
  00141	50		 push	 eax
  00142	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00145	51		 push	 ecx
  00146	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00149	8b 02		 mov	 eax, DWORD PTR [edx]
  0014b	03 45 f4	 add	 eax, DWORD PTR _cbObjectOffset$[ebp]
  0014e	50		 push	 eax
  0014f	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00152	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  00158	52		 push	 edx
  00159	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00162	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 651  :     if(cbActual != cbWanted)

  00165	8b 4d f0	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  00168	3b 4d f8	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  0016b	74 0a		 je	 SHORT $L10447

; 652  :     {
; 653  :         return WMAERR_BUFFERTOOSMALL;

  0016d	b8 03 00 00 00	 mov	 eax, 3
  00172	e9 5a 02 00 00	 jmp	 $L10425
$L10447:

; 654  :     }
; 655  :     cbObjectOffset += cbActual;

  00177	8b 55 f4	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  0017a	03 55 f0	 add	 edx, DWORD PTR _cbActual$[ebp]
  0017d	89 55 f4	 mov	 DWORD PTR _cbObjectOffset$[ebp], edx

; 656  : 
; 657  :     LoadDWORD(cbBlock, pData);

  00180	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00183	8b 08		 mov	 ecx, DWORD PTR [eax]
  00185	89 4d ec	 mov	 DWORD PTR _cbBlock$[ebp], ecx
  00188	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  0018b	83 c2 04	 add	 edx, 4
  0018e	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 658  : 
; 659  :     if(cbBlock)

  00191	83 7d ec 00	 cmp	 DWORD PTR _cbBlock$[ebp], 0
  00195	74 74		 je	 SHORT $L10450

; 660  :     {
; 661  :         cbWanted = cbBlock;

  00197	8b 45 ec	 mov	 eax, DWORD PTR _cbBlock$[ebp]
  0019a	89 45 f8	 mov	 DWORD PTR _cbWanted$[ebp], eax

; 662  :         if(cbObjectOffset + cbWanted > cbSize)

  0019d	8b 4d f4	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  001a0	03 4d f8	 add	 ecx, DWORD PTR _cbWanted$[ebp]
  001a3	3b 4d 0c	 cmp	 ecx, DWORD PTR _cbSize$[ebp]
  001a6	76 0a		 jbe	 SHORT $L10451

; 663  :         {
; 664  :             return WMAERR_BUFFERTOOSMALL;

  001a8	b8 03 00 00 00	 mov	 eax, 3
  001ad	e9 1f 02 00 00	 jmp	 $L10425
$L10451:

; 665  :         }
; 666  :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 667  :                                     pInt->pCallbackContext,
; 668  :                                     pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  001b2	8d 55 fc	 lea	 edx, DWORD PTR _pData$[ebp]
  001b5	52		 push	 edx
  001b6	8b 45 f8	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  001b9	50		 push	 eax
  001ba	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  001bd	8b 11		 mov	 edx, DWORD PTR [ecx]
  001bf	03 55 f4	 add	 edx, DWORD PTR _cbObjectOffset$[ebp]
  001c2	52		 push	 edx
  001c3	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  001c6	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  001cc	51		 push	 ecx
  001cd	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  001d0	52		 push	 edx
  001d1	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  001d6	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 669  :         if(cbActual != cbWanted)

  001d9	8b 45 f0	 mov	 eax, DWORD PTR _cbActual$[ebp]
  001dc	3b 45 f8	 cmp	 eax, DWORD PTR _cbWanted$[ebp]
  001df	74 0a		 je	 SHORT $L10453

; 670  :         {
; 671  :             return WMAERR_BUFFERTOOSMALL;

  001e1	b8 03 00 00 00	 mov	 eax, 3
  001e6	e9 e6 01 00 00	 jmp	 $L10425
$L10453:

; 672  :         }
; 673  :         cbObjectOffset += cbActual;

  001eb	8b 4d f4	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  001ee	03 4d f0	 add	 ecx, DWORD PTR _cbActual$[ebp]
  001f1	89 4d f4	 mov	 DWORD PTR _cbObjectOffset$[ebp], ecx

; 674  : 
; 675  :         memcpy(pInt->pbType, pData, (size_t)cbActual);

  001f4	8b 55 f0	 mov	 edx, DWORD PTR _cbActual$[ebp]
  001f7	52		 push	 edx
  001f8	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  001fb	50		 push	 eax
  001fc	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  001ff	83 c1 68	 add	 ecx, 104		; 00000068H
  00202	51		 push	 ecx
  00203	e8 00 00 00 00	 call	 _memcpy
  00208	83 c4 0c	 add	 esp, 12			; 0000000cH
$L10450:

; 676  :     }
; 677  : 
; 678  :     /* Key ID */
; 679  : 
; 680  :     cbWanted = sizeof(DWORD);

  0020b	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 4

; 681  :     if(cbObjectOffset + cbWanted > cbSize)

  00212	8b 55 f4	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  00215	03 55 f8	 add	 edx, DWORD PTR _cbWanted$[ebp]
  00218	3b 55 0c	 cmp	 edx, DWORD PTR _cbSize$[ebp]
  0021b	76 0a		 jbe	 SHORT $L10456

; 682  :     {
; 683  :         return WMAERR_BUFFERTOOSMALL;

  0021d	b8 03 00 00 00	 mov	 eax, 3
  00222	e9 aa 01 00 00	 jmp	 $L10425
$L10456:

; 684  :     }
; 685  :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 686  :                                 pInt->pCallbackContext,
; 687  :                                 pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  00227	8d 45 fc	 lea	 eax, DWORD PTR _pData$[ebp]
  0022a	50		 push	 eax
  0022b	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  0022e	51		 push	 ecx
  0022f	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00232	8b 02		 mov	 eax, DWORD PTR [edx]
  00234	03 45 f4	 add	 eax, DWORD PTR _cbObjectOffset$[ebp]
  00237	50		 push	 eax
  00238	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0023b	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  00241	52		 push	 edx
  00242	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00245	50		 push	 eax
  00246	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  0024b	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 688  :     if(cbActual != cbWanted)

  0024e	8b 4d f0	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  00251	3b 4d f8	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  00254	74 0a		 je	 SHORT $L10458

; 689  :     {
; 690  :         return WMAERR_BUFFERTOOSMALL;

  00256	b8 03 00 00 00	 mov	 eax, 3
  0025b	e9 71 01 00 00	 jmp	 $L10425
$L10458:

; 691  :     }
; 692  :     cbObjectOffset += cbActual;

  00260	8b 55 f4	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  00263	03 55 f0	 add	 edx, DWORD PTR _cbActual$[ebp]
  00266	89 55 f4	 mov	 DWORD PTR _cbObjectOffset$[ebp], edx

; 693  : 
; 694  :     LoadDWORD(cbBlock, pData);

  00269	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  0026c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0026e	89 4d ec	 mov	 DWORD PTR _cbBlock$[ebp], ecx
  00271	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00274	83 c2 04	 add	 edx, 4
  00277	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 695  : 
; 696  :     if(cbBlock)

  0027a	83 7d ec 00	 cmp	 DWORD PTR _cbBlock$[ebp], 0
  0027e	74 74		 je	 SHORT $L10461

; 697  :     {
; 698  :         cbWanted = cbBlock;

  00280	8b 45 ec	 mov	 eax, DWORD PTR _cbBlock$[ebp]
  00283	89 45 f8	 mov	 DWORD PTR _cbWanted$[ebp], eax

; 699  :         if(cbObjectOffset + cbWanted > cbSize)

  00286	8b 4d f4	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  00289	03 4d f8	 add	 ecx, DWORD PTR _cbWanted$[ebp]
  0028c	3b 4d 0c	 cmp	 ecx, DWORD PTR _cbSize$[ebp]
  0028f	76 0a		 jbe	 SHORT $L10462

; 700  :         {
; 701  :             return WMAERR_BUFFERTOOSMALL;

  00291	b8 03 00 00 00	 mov	 eax, 3
  00296	e9 36 01 00 00	 jmp	 $L10425
$L10462:

; 702  :         }
; 703  :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 704  :                                     pInt->pCallbackContext,
; 705  :                                     pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  0029b	8d 55 fc	 lea	 edx, DWORD PTR _pData$[ebp]
  0029e	52		 push	 edx
  0029f	8b 45 f8	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  002a2	50		 push	 eax
  002a3	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  002a6	8b 11		 mov	 edx, DWORD PTR [ecx]
  002a8	03 55 f4	 add	 edx, DWORD PTR _cbObjectOffset$[ebp]
  002ab	52		 push	 edx
  002ac	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  002af	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  002b5	51		 push	 ecx
  002b6	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  002b9	52		 push	 edx
  002ba	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  002bf	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 706  :         if(cbActual != cbWanted)

  002c2	8b 45 f0	 mov	 eax, DWORD PTR _cbActual$[ebp]
  002c5	3b 45 f8	 cmp	 eax, DWORD PTR _cbWanted$[ebp]
  002c8	74 0a		 je	 SHORT $L10464

; 707  :         {
; 708  :             return WMAERR_BUFFERTOOSMALL;

  002ca	b8 03 00 00 00	 mov	 eax, 3
  002cf	e9 fd 00 00 00	 jmp	 $L10425
$L10464:

; 709  :         }
; 710  :         cbObjectOffset += cbActual;

  002d4	8b 4d f4	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  002d7	03 4d f0	 add	 ecx, DWORD PTR _cbActual$[ebp]
  002da	89 4d f4	 mov	 DWORD PTR _cbObjectOffset$[ebp], ecx

; 711  : 
; 712  :         memcpy(pInt->pbKeyID, pData, (size_t)cbActual);

  002dd	8b 55 f0	 mov	 edx, DWORD PTR _cbActual$[ebp]
  002e0	52		 push	 edx
  002e1	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  002e4	50		 push	 eax
  002e5	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  002e8	83 c1 78	 add	 ecx, 120		; 00000078H
  002eb	51		 push	 ecx
  002ec	e8 00 00 00 00	 call	 _memcpy
  002f1	83 c4 0c	 add	 esp, 12			; 0000000cH
$L10461:

; 713  :     }
; 714  : 
; 715  :     /* License URL */
; 716  : 
; 717  :     cbWanted = sizeof(DWORD);

  002f4	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 4

; 718  :     if(cbObjectOffset + cbWanted > cbSize)

  002fb	8b 55 f4	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  002fe	03 55 f8	 add	 edx, DWORD PTR _cbWanted$[ebp]
  00301	3b 55 0c	 cmp	 edx, DWORD PTR _cbSize$[ebp]
  00304	76 0a		 jbe	 SHORT $L10467

; 719  :     {
; 720  :         return WMAERR_BUFFERTOOSMALL;

  00306	b8 03 00 00 00	 mov	 eax, 3
  0030b	e9 c1 00 00 00	 jmp	 $L10425
$L10467:

; 721  :     }
; 722  :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 723  :                                 pInt->pCallbackContext,
; 724  :                                 pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  00310	8d 45 fc	 lea	 eax, DWORD PTR _pData$[ebp]
  00313	50		 push	 eax
  00314	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00317	51		 push	 ecx
  00318	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0031b	8b 02		 mov	 eax, DWORD PTR [edx]
  0031d	03 45 f4	 add	 eax, DWORD PTR _cbObjectOffset$[ebp]
  00320	50		 push	 eax
  00321	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00324	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  0032a	52		 push	 edx
  0032b	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0032e	50		 push	 eax
  0032f	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00334	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 725  :     if(cbActual != cbWanted)

  00337	8b 4d f0	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  0033a	3b 4d f8	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  0033d	74 0a		 je	 SHORT $L10469

; 726  :     {
; 727  :         return WMAERR_BUFFERTOOSMALL;

  0033f	b8 03 00 00 00	 mov	 eax, 3
  00344	e9 88 00 00 00	 jmp	 $L10425
$L10469:

; 728  :     }
; 729  :     cbObjectOffset += cbActual;

  00349	8b 55 f4	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  0034c	03 55 f0	 add	 edx, DWORD PTR _cbActual$[ebp]
  0034f	89 55 f4	 mov	 DWORD PTR _cbObjectOffset$[ebp], edx

; 730  : 
; 731  :     LoadDWORD(cbBlock, pData);

  00352	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00355	8b 08		 mov	 ecx, DWORD PTR [eax]
  00357	89 4d ec	 mov	 DWORD PTR _cbBlock$[ebp], ecx
  0035a	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  0035d	83 c2 04	 add	 edx, 4
  00360	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 732  : 
; 733  :     if(cbBlock)

  00363	83 7d ec 00	 cmp	 DWORD PTR _cbBlock$[ebp], 0
  00367	74 59		 je	 SHORT $L10472

; 734  :     {
; 735  :         cbWanted = cbBlock;

  00369	8b 45 ec	 mov	 eax, DWORD PTR _cbBlock$[ebp]
  0036c	89 45 f8	 mov	 DWORD PTR _cbWanted$[ebp], eax

; 736  :         if(cbObjectOffset + cbWanted > cbSize)

  0036f	8b 4d f4	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  00372	03 4d f8	 add	 ecx, DWORD PTR _cbWanted$[ebp]
  00375	3b 4d 0c	 cmp	 ecx, DWORD PTR _cbSize$[ebp]
  00378	76 07		 jbe	 SHORT $L10475

; 737  :         {
; 738  :             return WMAERR_BUFFERTOOSMALL;

  0037a	b8 03 00 00 00	 mov	 eax, 3
  0037f	eb 50		 jmp	 SHORT $L10425
$L10475:

; 739  :         }
; 740  : 		while (cbWanted>0) {

  00381	83 7d f8 00	 cmp	 DWORD PTR _cbWanted$[ebp], 0
  00385	76 3b		 jbe	 SHORT $L10472

; 741  : 			cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 742  :                                         pInt->pCallbackContext,
; 743  : 										pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  00387	8d 55 fc	 lea	 edx, DWORD PTR _pData$[ebp]
  0038a	52		 push	 edx
  0038b	8b 45 f8	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  0038e	50		 push	 eax
  0038f	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00392	8b 11		 mov	 edx, DWORD PTR [ecx]
  00394	03 55 f4	 add	 edx, DWORD PTR _cbObjectOffset$[ebp]
  00397	52		 push	 edx
  00398	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0039b	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  003a1	51		 push	 ecx
  003a2	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  003a5	52		 push	 edx
  003a6	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  003ab	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 744  : 			cbObjectOffset += cbActual;

  003ae	8b 45 f4	 mov	 eax, DWORD PTR _cbObjectOffset$[ebp]
  003b1	03 45 f0	 add	 eax, DWORD PTR _cbActual$[ebp]
  003b4	89 45 f4	 mov	 DWORD PTR _cbObjectOffset$[ebp], eax

; 745  : 			cbWanted -= cbActual;

  003b7	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  003ba	2b 4d f0	 sub	 ecx, DWORD PTR _cbActual$[ebp]
  003bd	89 4d f8	 mov	 DWORD PTR _cbWanted$[ebp], ecx

; 746  : 		}

  003c0	eb bf		 jmp	 SHORT $L10475
$L10472:

; 747  : 
; 748  :         /* ignore */
; 749  :     }
; 750  : 
; 751  :     /* use all */
; 752  :     pInt->currPacketOffset += cbSize;

  003c2	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  003c5	8b 02		 mov	 eax, DWORD PTR [edx]
  003c7	03 45 0c	 add	 eax, DWORD PTR _cbSize$[ebp]
  003ca	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  003cd	89 01		 mov	 DWORD PTR [ecx], eax

; 753  : 
; 754  :     return WMAERR_OK;

  003cf	33 c0		 xor	 eax, eax
$L10425:

; 755  : }

  003d1	8b e5		 mov	 esp, ebp
  003d3	5d		 pop	 ebp
  003d4	c2 08 00	 ret	 8
_WMA_LoadEncryptionObject@8 ENDP
WMADEC	ENDS
PUBLIC	_WMA_LoadContentDescriptionObject@8
; Function compile flags: /Odt
;	COMDAT _WMA_LoadContentDescriptionObject@8
WMADEC	SEGMENT
_cbActual$ = -16
_cbObjectOffset$ = -12
_cbWanted$ = -8
_pData$ = -4
_pInt$ = 8
_cbSize$ = 12
_WMA_LoadContentDescriptionObject@8 PROC NEAR		; COMDAT

; 762  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 763  :     BYTE *pData;
; 764  :     DWORD cbWanted;
; 765  :     DWORD cbActual;
; 766  : 
; 767  :     DWORD cbObjectOffset = 0;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _cbObjectOffset$[ebp], 0

; 768  : 
; 769  :     if(pInt == NULL)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00011	75 0a		 jne	 SHORT $L10488

; 770  :     {
; 771  :         return WMAERR_INVALIDARG;

  00013	b8 02 00 00 00	 mov	 eax, 2
  00018	e9 04 01 00 00	 jmp	 $L10482
$L10488:

; 772  :     }
; 773  : 
; 774  :     cbSize -= MIN_OBJECT_SIZE;

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _cbSize$[ebp]
  00020	83 e8 18	 sub	 eax, 24			; 00000018H
  00023	89 45 0c	 mov	 DWORD PTR _cbSize$[ebp], eax

; 775  : 
; 776  :     cbWanted = 5*sizeof(WORD);

  00026	c7 45 f8 0a 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 10 ; 0000000aH

; 777  :     if(cbObjectOffset + cbWanted > cbSize)

  0002d	8b 4d f4	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  00030	03 4d f8	 add	 ecx, DWORD PTR _cbWanted$[ebp]
  00033	3b 4d 0c	 cmp	 ecx, DWORD PTR _cbSize$[ebp]
  00036	76 0a		 jbe	 SHORT $L10490

; 778  :     {
; 779  :         return WMAERR_BUFFERTOOSMALL;

  00038	b8 03 00 00 00	 mov	 eax, 3
  0003d	e9 df 00 00 00	 jmp	 $L10482
$L10490:

; 780  :     }
; 781  :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 782  :                                 pInt->pCallbackContext,
; 783  :                                 pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  00042	8d 55 fc	 lea	 edx, DWORD PTR _pData$[ebp]
  00045	52		 push	 edx
  00046	8b 45 f8	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0004d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004f	03 55 f4	 add	 edx, DWORD PTR _cbObjectOffset$[ebp]
  00052	52		 push	 edx
  00053	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00056	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  0005c	51		 push	 ecx
  0005d	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00066	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 784  :     if(cbActual != cbWanted)

  00069	8b 45 f0	 mov	 eax, DWORD PTR _cbActual$[ebp]
  0006c	3b 45 f8	 cmp	 eax, DWORD PTR _cbWanted$[ebp]
  0006f	74 0a		 je	 SHORT $L10492

; 785  :     {
; 786  :         return WMAERR_BUFFERTOOSMALL;

  00071	b8 03 00 00 00	 mov	 eax, 3
  00076	e9 a6 00 00 00	 jmp	 $L10482
$L10492:

; 787  :     }
; 788  :     cbObjectOffset += cbActual;

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  0007e	03 4d f0	 add	 ecx, DWORD PTR _cbActual$[ebp]
  00081	89 4d f4	 mov	 DWORD PTR _cbObjectOffset$[ebp], ecx

; 789  : 
; 790  :     LoadWORD(pInt->cbCDTitle, pData);

  00084	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00087	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  0008a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0008d	66 89 8a 9c 00
	00 00		 mov	 WORD PTR [edx+156], cx
  00094	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00097	83 c2 02	 add	 edx, 2
  0009a	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 791  :     LoadWORD(pInt->cbCDAuthor, pData);

  0009d	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000a3	66 8b 11	 mov	 dx, WORD PTR [ecx]
  000a6	66 89 90 9e 00
	00 00		 mov	 WORD PTR [eax+158], dx
  000ad	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  000b0	83 c0 02	 add	 eax, 2
  000b3	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax

; 792  :     LoadWORD(pInt->cbCDCopyright, pData);

  000b6	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000b9	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000bc	66 8b 02	 mov	 ax, WORD PTR [edx]
  000bf	66 89 81 a0 00
	00 00		 mov	 WORD PTR [ecx+160], ax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000c9	83 c1 02	 add	 ecx, 2
  000cc	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx

; 793  :     LoadWORD(pInt->cbCDDescription, pData);

  000cf	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  000d2	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  000d5	66 8b 08	 mov	 cx, WORD PTR [eax]
  000d8	66 89 8a a2 00
	00 00		 mov	 WORD PTR [edx+162], cx
  000df	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000e2	83 c2 02	 add	 edx, 2
  000e5	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 794  :     LoadWORD(pInt->cbCDRating, pData);

  000e8	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  000eb	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000ee	66 8b 11	 mov	 dx, WORD PTR [ecx]
  000f1	66 89 90 a4 00
	00 00		 mov	 WORD PTR [eax+164], dx
  000f8	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  000fb	83 c0 02	 add	 eax, 2
  000fe	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax

; 795  : 
; 796  :     pInt->cbCDOffset = pInt->currPacketOffset + cbObjectOffset;

  00101	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00104	8b 11		 mov	 edx, DWORD PTR [ecx]
  00106	03 55 f4	 add	 edx, DWORD PTR _cbObjectOffset$[ebp]
  00109	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0010c	89 90 98 00 00
	00		 mov	 DWORD PTR [eax+152], edx

; 797  : 
; 798  :     /* use all */
; 799  :     pInt->currPacketOffset += cbSize;

  00112	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00115	8b 11		 mov	 edx, DWORD PTR [ecx]
  00117	03 55 0c	 add	 edx, DWORD PTR _cbSize$[ebp]
  0011a	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0011d	89 10		 mov	 DWORD PTR [eax], edx

; 800  : 
; 801  :     return WMAERR_OK;

  0011f	33 c0		 xor	 eax, eax
$L10482:

; 802  : }

  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 08 00	 ret	 8
_WMA_LoadContentDescriptionObject@8 ENDP
WMADEC	ENDS
PUBLIC	_WMA_LoadExtendedContentDescObject@8
EXTRN	_malloc:NEAR
; Function compile flags: /Odt
;	COMDAT _WMA_LoadExtendedContentDescObject@8
WMADEC	SEGMENT
tv295 = -48
tv183 = -44
_cbActual$ = -40
_pECDesc$ = -36
_cbObjectOffset$ = -32
_cbBuffer$ = -28
_i$ = -24
_cbWanted$ = -20
_pData$ = -16
_cDescriptors$ = -12
_cbOffset$ = -8
_cbWanted1$ = -4
_pInt$ = 8
_cbSize$ = 12
_WMA_LoadExtendedContentDescObject@8 PROC NEAR		; COMDAT

; 808  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 809  :     BYTE *pData;
; 810  :     DWORD cbWanted;
; 811  :     DWORD cbActual;
; 812  :     DWORD cbBuffer;
; 813  :     WORD i;
; 814  :     tWMAExtendedContentDesc *pECDesc = NULL;

  00006	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _pECDesc$[ebp], 0

; 815  :     tWMA_U16 cDescriptors;
; 816  :     DWORD cbOffset=0;

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cbOffset$[ebp], 0

; 817  :     DWORD cbWanted1 =0;

  00014	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cbWanted1$[ebp], 0

; 818  : //    unsigned char g_Buffer[1024];
; 819  : //    #define MAX_BUFSIZE 128
; 820  : 
; 821  : 
; 822  :     DWORD cbObjectOffset = 0;

  0001b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _cbObjectOffset$[ebp], 0

; 823  : 
; 824  :     if(pInt == NULL)

  00022	83 7d 08 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00026	75 0a		 jne	 SHORT $L10520

; 825  :     {
; 826  :         return WMAERR_INVALIDARG;

  00028	b8 02 00 00 00	 mov	 eax, 2
  0002d	e9 d4 05 00 00	 jmp	 $L10507
$L10520:

; 827  :     }
; 828  : 
; 829  :     cbSize -= MIN_OBJECT_SIZE;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _cbSize$[ebp]
  00035	83 e8 18	 sub	 eax, 24			; 00000018H
  00038	89 45 0c	 mov	 DWORD PTR _cbSize$[ebp], eax

; 830  : 
; 831  : /////////////////////////S//////////////////////
; 832  :     cbBuffer = cbSize;

  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _cbSize$[ebp]
  0003e	89 4d e4	 mov	 DWORD PTR _cbBuffer$[ebp], ecx

; 833  : 
; 834  : /*    cbWanted = cbSize;
; 835  :     cbBuffer = cbSize;
; 836  : 
; 837  :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 838  :                                 pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
; 839  :     if(cbActual != cbWanted)
; 840  :     {
; 841  :         return WMAERR_BUFFERTOOSMALL;
; 842  :     }
; 843  :     cbObjectOffset += cbActual;
; 844  : */
; 845  : ///////////////////////////////////////E//////////
; 846  :     if(pInt->m_pECDesc != NULL) 

  00041	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00044	83 ba a8 00 00
	00 00		 cmp	 DWORD PTR [edx+168], 0
  0004b	74 05		 je	 SHORT $L10522

; 847  :         goto SKIP;

  0004d	e9 a5 05 00 00	 jmp	 $SKIP$10523
$L10522:

; 848  : 
; 849  :     pInt->m_pECDesc = (tWMAExtendedContentDesc *)malloc(sizeof(tWMAExtendedContentDesc));

  00052	6a 06		 push	 6
  00054	e8 00 00 00 00	 call	 _malloc
  00059	83 c4 04	 add	 esp, 4
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0005f	89 81 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], eax

; 850  :     if( pInt->m_pECDesc == NULL) {

  00065	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00068	83 ba a8 00 00
	00 00		 cmp	 DWORD PTR [edx+168], 0
  0006f	75 0a		 jne	 SHORT $L10527

; 851  :         return( WMAERR_OUTOFMEMORY );

  00071	b8 05 00 00 00	 mov	 eax, 5
  00076	e9 8b 05 00 00	 jmp	 $L10507
$L10527:

; 852  :     }
; 853  :     pECDesc = pInt->m_pECDesc;

  0007b	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0007e	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00084	89 4d dc	 mov	 DWORD PTR _pECDesc$[ebp], ecx

; 854  : ////////////////////////////S//////////////
; 855  :     cbWanted = sizeof(tWMA_U16);

  00087	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 2

; 856  : 
; 857  :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 858  :                                 pInt->pCallbackContext,
; 859  :                                 pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  0008e	8d 55 f0	 lea	 edx, DWORD PTR _pData$[ebp]
  00091	52		 push	 edx
  00092	8b 45 ec	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  00095	50		 push	 eax
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00099	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009b	03 55 e0	 add	 edx, DWORD PTR _cbObjectOffset$[ebp]
  0009e	52		 push	 edx
  0009f	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  000a2	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  000a8	51		 push	 ecx
  000a9	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  000ac	52		 push	 edx
  000ad	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  000b2	89 45 d8	 mov	 DWORD PTR _cbActual$[ebp], eax

; 860  :     if(cbActual != cbWanted)

  000b5	8b 45 d8	 mov	 eax, DWORD PTR _cbActual$[ebp]
  000b8	3b 45 ec	 cmp	 eax, DWORD PTR _cbWanted$[ebp]
  000bb	74 0a		 je	 SHORT $L10530

; 861  :     {
; 862  :         return WMAERR_BUFFERTOOSMALL;

  000bd	b8 03 00 00 00	 mov	 eax, 3
  000c2	e9 3f 05 00 00	 jmp	 $L10507
$L10530:

; 863  :     }
; 864  :     cbObjectOffset += cbActual;

  000c7	8b 4d e0	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  000ca	03 4d d8	 add	 ecx, DWORD PTR _cbActual$[ebp]
  000cd	89 4d e0	 mov	 DWORD PTR _cbObjectOffset$[ebp], ecx

; 865  :     cbBuffer -= cbActual;

  000d0	8b 55 e4	 mov	 edx, DWORD PTR _cbBuffer$[ebp]
  000d3	2b 55 d8	 sub	 edx, DWORD PTR _cbActual$[ebp]
  000d6	89 55 e4	 mov	 DWORD PTR _cbBuffer$[ebp], edx

; 866  : ////////////////////////////E/////////////
; 867  :     LoadWORD(cDescriptors, pData);

  000d9	8b 45 f0	 mov	 eax, DWORD PTR _pData$[ebp]
  000dc	66 8b 08	 mov	 cx, WORD PTR [eax]
  000df	66 89 4d f4	 mov	 WORD PTR _cDescriptors$[ebp], cx
  000e3	8b 55 f0	 mov	 edx, DWORD PTR _pData$[ebp]
  000e6	83 c2 02	 add	 edx, 2
  000e9	89 55 f0	 mov	 DWORD PTR _pData$[ebp], edx

; 868  : //    cbBuffer -= sizeof(tWMA_U16);
; 869  : 
; 870  :     pECDesc->cDescriptors = cDescriptors;

  000ec	8b 45 dc	 mov	 eax, DWORD PTR _pECDesc$[ebp]
  000ef	66 8b 4d f4	 mov	 cx, WORD PTR _cDescriptors$[ebp]
  000f3	66 89 08	 mov	 WORD PTR [eax], cx

; 871  :     pECDesc->pDescriptors = (ECD_DESCRIPTOR *)malloc(cDescriptors * sizeof(ECD_DESCRIPTOR));

  000f6	0f bf 55 f4	 movsx	 edx, WORD PTR _cDescriptors$[ebp]
  000fa	6b d2 0e	 imul	 edx, 14			; 0000000eH
  000fd	52		 push	 edx
  000fe	e8 00 00 00 00	 call	 _malloc
  00103	83 c4 04	 add	 esp, 4
  00106	8b 4d dc	 mov	 ecx, DWORD PTR _pECDesc$[ebp]
  00109	89 41 02	 mov	 DWORD PTR [ecx+2], eax

; 872  :    if(pECDesc->pDescriptors == NULL)

  0010c	8b 55 dc	 mov	 edx, DWORD PTR _pECDesc$[ebp]
  0010f	83 7a 02 00	 cmp	 DWORD PTR [edx+2], 0
  00113	75 0a		 jne	 SHORT $L10536

; 873  :        return( WMAERR_OUTOFMEMORY );

  00115	b8 05 00 00 00	 mov	 eax, 5
  0011a	e9 e7 04 00 00	 jmp	 $L10507
$L10536:

; 874  : 
; 875  :    for(i = 0; i < cDescriptors; i++) {

  0011f	66 c7 45 e8 00
	00		 mov	 WORD PTR _i$[ebp], 0
  00125	eb 0c		 jmp	 SHORT $L10537
$L10538:
  00127	66 8b 45 e8	 mov	 ax, WORD PTR _i$[ebp]
  0012b	66 05 01 00	 add	 ax, 1
  0012f	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax
$L10537:
  00133	0f b7 4d e8	 movzx	 ecx, WORD PTR _i$[ebp]
  00137	0f bf 55 f4	 movsx	 edx, WORD PTR _cDescriptors$[ebp]
  0013b	3b ca		 cmp	 ecx, edx
  0013d	0f 8d b4 04 00
	00		 jge	 $SKIP$10523

; 876  :   
; 877  : ///////////////////////////////////////////S/////////////////////////////
; 878  :         cbWanted = sizeof(tWMA_U16);

  00143	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 2

; 879  : 
; 880  :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 881  :                                     pInt->pCallbackContext,
; 882  :                                     pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  0014a	8d 45 f0	 lea	 eax, DWORD PTR _pData$[ebp]
  0014d	50		 push	 eax
  0014e	8b 4d ec	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00151	51		 push	 ecx
  00152	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00155	8b 02		 mov	 eax, DWORD PTR [edx]
  00157	03 45 e0	 add	 eax, DWORD PTR _cbObjectOffset$[ebp]
  0015a	50		 push	 eax
  0015b	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0015e	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  00164	52		 push	 edx
  00165	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00168	50		 push	 eax
  00169	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  0016e	89 45 d8	 mov	 DWORD PTR _cbActual$[ebp], eax

; 883  :         if(cbActual != cbWanted)

  00171	8b 4d d8	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  00174	3b 4d ec	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  00177	74 0a		 je	 SHORT $L10542

; 884  :         {
; 885  :             return WMAERR_BUFFERTOOSMALL;

  00179	b8 03 00 00 00	 mov	 eax, 3
  0017e	e9 83 04 00 00	 jmp	 $L10507
$L10542:

; 886  :         }
; 887  :         cbObjectOffset += cbActual;

  00183	8b 55 e0	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  00186	03 55 d8	 add	 edx, DWORD PTR _cbActual$[ebp]
  00189	89 55 e0	 mov	 DWORD PTR _cbObjectOffset$[ebp], edx

; 888  : ///////////////////////////////////////////E///////////////////////////       
; 889  :        LoadWORD(pECDesc->pDescriptors[i].cbName, pData);

  0018c	0f b7 45 e8	 movzx	 eax, WORD PTR _i$[ebp]
  00190	6b c0 0e	 imul	 eax, 14			; 0000000eH
  00193	8b 4d dc	 mov	 ecx, DWORD PTR _pECDesc$[ebp]
  00196	8b 51 02	 mov	 edx, DWORD PTR [ecx+2]
  00199	8b 4d f0	 mov	 ecx, DWORD PTR _pData$[ebp]
  0019c	66 8b 09	 mov	 cx, WORD PTR [ecx]
  0019f	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx
  001a3	8b 55 f0	 mov	 edx, DWORD PTR _pData$[ebp]
  001a6	83 c2 02	 add	 edx, 2
  001a9	89 55 f0	 mov	 DWORD PTR _pData$[ebp], edx

; 890  :        cbBuffer -= sizeof(tWMA_U16);

  001ac	8b 45 e4	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  001af	83 e8 02	 sub	 eax, 2
  001b2	89 45 e4	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 891  :         if(cbBuffer < pECDesc->pDescriptors[i].cbName + sizeof(tWMA_U16) * 2)

  001b5	0f b7 4d e8	 movzx	 ecx, WORD PTR _i$[ebp]
  001b9	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  001bc	8b 55 dc	 mov	 edx, DWORD PTR _pECDesc$[ebp]
  001bf	8b 42 02	 mov	 eax, DWORD PTR [edx+2]
  001c2	0f bf 0c 08	 movsx	 ecx, WORD PTR [eax+ecx]
  001c6	83 c1 04	 add	 ecx, 4
  001c9	39 4d e4	 cmp	 DWORD PTR _cbBuffer$[ebp], ecx
  001cc	73 0a		 jae	 SHORT $L10547

; 892  :             return( WMAERR_BUFFERTOOSMALL );

  001ce	b8 03 00 00 00	 mov	 eax, 3
  001d3	e9 2e 04 00 00	 jmp	 $L10507
$L10547:

; 893  :         pECDesc->pDescriptors[i].pwszName = NULL;

  001d8	0f b7 55 e8	 movzx	 edx, WORD PTR _i$[ebp]
  001dc	6b d2 0e	 imul	 edx, 14			; 0000000eH
  001df	8b 45 dc	 mov	 eax, DWORD PTR _pECDesc$[ebp]
  001e2	8b 48 02	 mov	 ecx, DWORD PTR [eax+2]
  001e5	c7 44 11 02 00
	00 00 00	 mov	 DWORD PTR [ecx+edx+2], 0

; 894  :         pECDesc->pDescriptors[i].pwszName = (tWMA_U16 *)malloc(pECDesc->pDescriptors[i].cbName);

  001ed	0f b7 55 e8	 movzx	 edx, WORD PTR _i$[ebp]
  001f1	6b d2 0e	 imul	 edx, 14			; 0000000eH
  001f4	8b 45 dc	 mov	 eax, DWORD PTR _pECDesc$[ebp]
  001f7	8b 48 02	 mov	 ecx, DWORD PTR [eax+2]
  001fa	0f bf 14 11	 movsx	 edx, WORD PTR [ecx+edx]
  001fe	52		 push	 edx
  001ff	e8 00 00 00 00	 call	 _malloc
  00204	83 c4 04	 add	 esp, 4
  00207	0f b7 4d e8	 movzx	 ecx, WORD PTR _i$[ebp]
  0020b	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  0020e	8b 55 dc	 mov	 edx, DWORD PTR _pECDesc$[ebp]
  00211	8b 52 02	 mov	 edx, DWORD PTR [edx+2]
  00214	89 44 0a 02	 mov	 DWORD PTR [edx+ecx+2], eax

; 895  :         if (pECDesc->pDescriptors[i].pwszName == NULL)

  00218	0f b7 45 e8	 movzx	 eax, WORD PTR _i$[ebp]
  0021c	6b c0 0e	 imul	 eax, 14			; 0000000eH
  0021f	8b 4d dc	 mov	 ecx, DWORD PTR _pECDesc$[ebp]
  00222	8b 51 02	 mov	 edx, DWORD PTR [ecx+2]
  00225	83 7c 02 02 00	 cmp	 DWORD PTR [edx+eax+2], 0
  0022a	75 0a		 jne	 SHORT $L10551

; 896  :             return( WMAERR_OUTOFMEMORY );

  0022c	b8 05 00 00 00	 mov	 eax, 5
  00231	e9 d0 03 00 00	 jmp	 $L10507
$L10551:

; 897  :         else
; 898  :         {
; 899  : 
; 900  :     ///////////////////////////////////////////S/////////////////////////////
; 901  :             cbWanted = pECDesc->pDescriptors[i].cbName + sizeof(tWMA_U16) * 2;

  00236	0f b7 45 e8	 movzx	 eax, WORD PTR _i$[ebp]
  0023a	6b c0 0e	 imul	 eax, 14			; 0000000eH
  0023d	8b 4d dc	 mov	 ecx, DWORD PTR _pECDesc$[ebp]
  00240	8b 51 02	 mov	 edx, DWORD PTR [ecx+2]
  00243	0f bf 04 02	 movsx	 eax, WORD PTR [edx+eax]
  00247	83 c0 04	 add	 eax, 4
  0024a	89 45 ec	 mov	 DWORD PTR _cbWanted$[ebp], eax

; 902  :             
; 903  :             if(cbWanted > MAX_BUFSIZE)

  0024d	81 7d ec 80 00
	00 00		 cmp	 DWORD PTR _cbWanted$[ebp], 128 ; 00000080H
  00254	0f 86 ad 00 00
	00		 jbe	 $L10554

; 904  :             {
; 905  :                 cbOffset=0;

  0025a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cbOffset$[ebp], 0
$L10555:

; 906  :                 do
; 907  :                 {
; 908  :                     cbWanted1 =  cbWanted > MAX_BUFSIZE ? MAX_BUFSIZE : cbWanted;

  00261	81 7d ec 80 00
	00 00		 cmp	 DWORD PTR _cbWanted$[ebp], 128 ; 00000080H
  00268	76 09		 jbe	 SHORT $L11028
  0026a	c7 45 d4 80 00
	00 00		 mov	 DWORD PTR tv183[ebp], 128 ; 00000080H
  00271	eb 06		 jmp	 SHORT $L11029
$L11028:
  00273	8b 4d ec	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00276	89 4d d4	 mov	 DWORD PTR tv183[ebp], ecx
$L11029:
  00279	8b 55 d4	 mov	 edx, DWORD PTR tv183[ebp]
  0027c	89 55 fc	 mov	 DWORD PTR _cbWanted1$[ebp], edx

; 909  :                     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 910  :                                                 pInt->pCallbackContext,
; 911  :                                                 pInt->currPacketOffset + cbObjectOffset, cbWanted1, &pData);

  0027f	8d 45 f0	 lea	 eax, DWORD PTR _pData$[ebp]
  00282	50		 push	 eax
  00283	8b 4d fc	 mov	 ecx, DWORD PTR _cbWanted1$[ebp]
  00286	51		 push	 ecx
  00287	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0028a	8b 02		 mov	 eax, DWORD PTR [edx]
  0028c	03 45 e0	 add	 eax, DWORD PTR _cbObjectOffset$[ebp]
  0028f	50		 push	 eax
  00290	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00293	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  00299	52		 push	 edx
  0029a	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0029d	50		 push	 eax
  0029e	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  002a3	89 45 d8	 mov	 DWORD PTR _cbActual$[ebp], eax

; 912  :                     if(cbActual != cbWanted1)

  002a6	8b 4d d8	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  002a9	3b 4d fc	 cmp	 ecx, DWORD PTR _cbWanted1$[ebp]
  002ac	74 0a		 je	 SHORT $L10559

; 913  :                     {
; 914  :                         return WMAERR_BUFFERTOOSMALL;

  002ae	b8 03 00 00 00	 mov	 eax, 3
  002b3	e9 4e 03 00 00	 jmp	 $L10507
$L10559:

; 915  :                     }
; 916  :                     cbObjectOffset += cbActual;

  002b8	8b 55 e0	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  002bb	03 55 d8	 add	 edx, DWORD PTR _cbActual$[ebp]
  002be	89 55 e0	 mov	 DWORD PTR _cbObjectOffset$[ebp], edx

; 917  :                     cbWanted -=cbActual;

  002c1	8b 45 ec	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  002c4	2b 45 d8	 sub	 eax, DWORD PTR _cbActual$[ebp]
  002c7	89 45 ec	 mov	 DWORD PTR _cbWanted$[ebp], eax

; 918  :             ///////////////////////////////////////////E///////////////////////////       
; 919  : 
; 920  :                     memcpy(pECDesc->pDescriptors[i].pwszName+cbOffset, pData, cbActual);

  002ca	8b 4d d8	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  002cd	51		 push	 ecx
  002ce	8b 55 f0	 mov	 edx, DWORD PTR _pData$[ebp]
  002d1	52		 push	 edx
  002d2	0f b7 45 e8	 movzx	 eax, WORD PTR _i$[ebp]
  002d6	6b c0 0e	 imul	 eax, 14			; 0000000eH
  002d9	8b 4d dc	 mov	 ecx, DWORD PTR _pECDesc$[ebp]
  002dc	8b 51 02	 mov	 edx, DWORD PTR [ecx+2]
  002df	8b 44 02 02	 mov	 eax, DWORD PTR [edx+eax+2]
  002e3	8b 4d f8	 mov	 ecx, DWORD PTR _cbOffset$[ebp]
  002e6	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  002e9	52		 push	 edx
  002ea	e8 00 00 00 00	 call	 _memcpy
  002ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 921  :                     cbOffset +=cbActual;

  002f2	8b 45 f8	 mov	 eax, DWORD PTR _cbOffset$[ebp]
  002f5	03 45 d8	 add	 eax, DWORD PTR _cbActual$[ebp]
  002f8	89 45 f8	 mov	 DWORD PTR _cbOffset$[ebp], eax

; 922  :                 }while(cbWanted >0);

  002fb	83 7d ec 00	 cmp	 DWORD PTR _cbWanted$[ebp], 0
  002ff	0f 87 5c ff ff
	ff		 ja	 $L10555

; 923  :             }
; 924  :             else

  00305	eb 72		 jmp	 SHORT $L10552
$L10554:

; 925  :             {
; 926  :                 cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 927  :                                             pInt->pCallbackContext,
; 928  :                                             pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  00307	8d 4d f0	 lea	 ecx, DWORD PTR _pData$[ebp]
  0030a	51		 push	 ecx
  0030b	8b 55 ec	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  0030e	52		 push	 edx
  0030f	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00312	8b 08		 mov	 ecx, DWORD PTR [eax]
  00314	03 4d e0	 add	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  00317	51		 push	 ecx
  00318	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0031b	8b 82 c0 00 00
	00		 mov	 eax, DWORD PTR [edx+192]
  00321	50		 push	 eax
  00322	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00325	51		 push	 ecx
  00326	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  0032b	89 45 d8	 mov	 DWORD PTR _cbActual$[ebp], eax

; 929  :                 if(cbActual != cbWanted)

  0032e	8b 55 d8	 mov	 edx, DWORD PTR _cbActual$[ebp]
  00331	3b 55 ec	 cmp	 edx, DWORD PTR _cbWanted$[ebp]
  00334	74 0a		 je	 SHORT $L10562

; 930  :                 {
; 931  :                     return WMAERR_BUFFERTOOSMALL;

  00336	b8 03 00 00 00	 mov	 eax, 3
  0033b	e9 c6 02 00 00	 jmp	 $L10507
$L10562:

; 932  :                 }
; 933  :                 cbObjectOffset += cbActual;

  00340	8b 45 e0	 mov	 eax, DWORD PTR _cbObjectOffset$[ebp]
  00343	03 45 d8	 add	 eax, DWORD PTR _cbActual$[ebp]
  00346	89 45 e0	 mov	 DWORD PTR _cbObjectOffset$[ebp], eax

; 934  :         ///////////////////////////////////////////E///////////////////////////       
; 935  : 
; 936  :                 memcpy(pECDesc->pDescriptors[i].pwszName, pData, pECDesc->pDescriptors[i].cbName);

  00349	0f b7 4d e8	 movzx	 ecx, WORD PTR _i$[ebp]
  0034d	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  00350	8b 55 dc	 mov	 edx, DWORD PTR _pECDesc$[ebp]
  00353	8b 42 02	 mov	 eax, DWORD PTR [edx+2]
  00356	0f bf 0c 08	 movsx	 ecx, WORD PTR [eax+ecx]
  0035a	51		 push	 ecx
  0035b	8b 55 f0	 mov	 edx, DWORD PTR _pData$[ebp]
  0035e	52		 push	 edx
  0035f	0f b7 45 e8	 movzx	 eax, WORD PTR _i$[ebp]
  00363	6b c0 0e	 imul	 eax, 14			; 0000000eH
  00366	8b 4d dc	 mov	 ecx, DWORD PTR _pECDesc$[ebp]
  00369	8b 51 02	 mov	 edx, DWORD PTR [ecx+2]
  0036c	8b 44 02 02	 mov	 eax, DWORD PTR [edx+eax+2]
  00370	50		 push	 eax
  00371	e8 00 00 00 00	 call	 _memcpy
  00376	83 c4 0c	 add	 esp, 12			; 0000000cH
$L10552:

; 937  :             }
; 938  :         }
; 939  : #ifndef LITTLE_ENDIAN
; 940  :         SwapWstr((tWMA_U16 *)pECDesc->pDescriptors[i].pwszName, (tWMA_U32)(pECDesc->pDescriptors[i].cbName / sizeof(tWMA_U16)));
; 941  : #endif
; 942  :         pData += pECDesc->pDescriptors[i].cbName;

  00379	0f b7 4d e8	 movzx	 ecx, WORD PTR _i$[ebp]
  0037d	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  00380	8b 55 dc	 mov	 edx, DWORD PTR _pECDesc$[ebp]
  00383	8b 42 02	 mov	 eax, DWORD PTR [edx+2]
  00386	0f bf 0c 08	 movsx	 ecx, WORD PTR [eax+ecx]
  0038a	8b 55 f0	 mov	 edx, DWORD PTR _pData$[ebp]
  0038d	03 d1		 add	 edx, ecx
  0038f	89 55 f0	 mov	 DWORD PTR _pData$[ebp], edx

; 943  :         cbBuffer -= pECDesc->pDescriptors[i].cbName;

  00392	0f b7 45 e8	 movzx	 eax, WORD PTR _i$[ebp]
  00396	6b c0 0e	 imul	 eax, 14			; 0000000eH
  00399	8b 4d dc	 mov	 ecx, DWORD PTR _pECDesc$[ebp]
  0039c	8b 51 02	 mov	 edx, DWORD PTR [ecx+2]
  0039f	0f bf 04 02	 movsx	 eax, WORD PTR [edx+eax]
  003a3	8b 4d e4	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  003a6	2b c8		 sub	 ecx, eax
  003a8	89 4d e4	 mov	 DWORD PTR _cbBuffer$[ebp], ecx

; 944  :         LoadWORD(pECDesc->pDescriptors[i].data_type, pData);

  003ab	0f b7 55 e8	 movzx	 edx, WORD PTR _i$[ebp]
  003af	6b d2 0e	 imul	 edx, 14			; 0000000eH
  003b2	8b 45 dc	 mov	 eax, DWORD PTR _pECDesc$[ebp]
  003b5	8b 48 02	 mov	 ecx, DWORD PTR [eax+2]
  003b8	8b 45 f0	 mov	 eax, DWORD PTR _pData$[ebp]
  003bb	66 8b 00	 mov	 ax, WORD PTR [eax]
  003be	66 89 44 11 06	 mov	 WORD PTR [ecx+edx+6], ax
  003c3	8b 4d f0	 mov	 ecx, DWORD PTR _pData$[ebp]
  003c6	83 c1 02	 add	 ecx, 2
  003c9	89 4d f0	 mov	 DWORD PTR _pData$[ebp], ecx

; 945  :         cbBuffer -= sizeof(tWMA_U16);

  003cc	8b 55 e4	 mov	 edx, DWORD PTR _cbBuffer$[ebp]
  003cf	83 ea 02	 sub	 edx, 2
  003d2	89 55 e4	 mov	 DWORD PTR _cbBuffer$[ebp], edx

; 946  :         LoadWORD(pECDesc->pDescriptors[i].cbValue, pData);

  003d5	0f b7 45 e8	 movzx	 eax, WORD PTR _i$[ebp]
  003d9	6b c0 0e	 imul	 eax, 14			; 0000000eH
  003dc	8b 4d dc	 mov	 ecx, DWORD PTR _pECDesc$[ebp]
  003df	8b 51 02	 mov	 edx, DWORD PTR [ecx+2]
  003e2	8b 4d f0	 mov	 ecx, DWORD PTR _pData$[ebp]
  003e5	66 8b 09	 mov	 cx, WORD PTR [ecx]
  003e8	66 89 4c 02 08	 mov	 WORD PTR [edx+eax+8], cx
  003ed	8b 55 f0	 mov	 edx, DWORD PTR _pData$[ebp]
  003f0	83 c2 02	 add	 edx, 2
  003f3	89 55 f0	 mov	 DWORD PTR _pData$[ebp], edx

; 947  :         cbBuffer -= sizeof(tWMA_U16);

  003f6	8b 45 e4	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  003f9	83 e8 02	 sub	 eax, 2
  003fc	89 45 e4	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 948  :         if(cbBuffer < (DWORD)pECDesc->pDescriptors[i].cbValue)

  003ff	0f b7 4d e8	 movzx	 ecx, WORD PTR _i$[ebp]
  00403	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  00406	8b 55 dc	 mov	 edx, DWORD PTR _pECDesc$[ebp]
  00409	8b 42 02	 mov	 eax, DWORD PTR [edx+2]
  0040c	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  00411	39 4d e4	 cmp	 DWORD PTR _cbBuffer$[ebp], ecx
  00414	73 0a		 jae	 SHORT $L10570

; 949  :             return( WMAERR_BUFFERTOOSMALL );

  00416	b8 03 00 00 00	 mov	 eax, 3
  0041b	e9 e6 01 00 00	 jmp	 $L10507
$L10570:

; 950  :         pECDesc->pDescriptors[i].uValue.pbBinary = NULL;

  00420	0f b7 55 e8	 movzx	 edx, WORD PTR _i$[ebp]
  00424	6b d2 0e	 imul	 edx, 14			; 0000000eH
  00427	8b 45 dc	 mov	 eax, DWORD PTR _pECDesc$[ebp]
  0042a	8b 48 02	 mov	 ecx, DWORD PTR [eax+2]
  0042d	c7 44 11 0a 00
	00 00 00	 mov	 DWORD PTR [ecx+edx+10], 0

; 951  :         pECDesc->pDescriptors[i].uValue.pbBinary = (tWMA_U8 *)malloc (pECDesc->pDescriptors[i].cbValue);

  00435	0f b7 55 e8	 movzx	 edx, WORD PTR _i$[ebp]
  00439	6b d2 0e	 imul	 edx, 14			; 0000000eH
  0043c	8b 45 dc	 mov	 eax, DWORD PTR _pECDesc$[ebp]
  0043f	8b 48 02	 mov	 ecx, DWORD PTR [eax+2]
  00442	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  00447	52		 push	 edx
  00448	e8 00 00 00 00	 call	 _malloc
  0044d	83 c4 04	 add	 esp, 4
  00450	0f b7 4d e8	 movzx	 ecx, WORD PTR _i$[ebp]
  00454	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  00457	8b 55 dc	 mov	 edx, DWORD PTR _pECDesc$[ebp]
  0045a	8b 52 02	 mov	 edx, DWORD PTR [edx+2]
  0045d	89 44 0a 0a	 mov	 DWORD PTR [edx+ecx+10], eax

; 952  :         if (pECDesc->pDescriptors[i].uValue.pbBinary == NULL)

  00461	0f b7 45 e8	 movzx	 eax, WORD PTR _i$[ebp]
  00465	6b c0 0e	 imul	 eax, 14			; 0000000eH
  00468	8b 4d dc	 mov	 ecx, DWORD PTR _pECDesc$[ebp]
  0046b	8b 51 02	 mov	 edx, DWORD PTR [ecx+2]
  0046e	83 7c 02 0a 00	 cmp	 DWORD PTR [edx+eax+10], 0
  00473	75 0a		 jne	 SHORT $L10574

; 953  :             return( WMAERR_OUTOFMEMORY );

  00475	b8 05 00 00 00	 mov	 eax, 5
  0047a	e9 87 01 00 00	 jmp	 $L10507
$L10574:

; 954  :         else
; 955  :         {
; 956  :     ///////////////////////////////////////////S/////////////////////////////
; 957  :             cbWanted = pECDesc->pDescriptors[i].cbValue;

  0047f	0f b7 45 e8	 movzx	 eax, WORD PTR _i$[ebp]
  00483	6b c0 0e	 imul	 eax, 14			; 0000000eH
  00486	8b 4d dc	 mov	 ecx, DWORD PTR _pECDesc$[ebp]
  00489	8b 51 02	 mov	 edx, DWORD PTR [ecx+2]
  0048c	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00491	89 45 ec	 mov	 DWORD PTR _cbWanted$[ebp], eax

; 958  : 
; 959  :             if(cbWanted > MAX_BUFSIZE)

  00494	81 7d ec 80 00
	00 00		 cmp	 DWORD PTR _cbWanted$[ebp], 128 ; 00000080H
  0049b	0f 86 aa 00 00
	00		 jbe	 $L10576

; 960  :             {
; 961  :                 cbOffset=0;

  004a1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cbOffset$[ebp], 0
$L10577:

; 962  :                 do
; 963  :                 {
; 964  :                     cbWanted1 =  cbWanted > MAX_BUFSIZE ? MAX_BUFSIZE : cbWanted;

  004a8	81 7d ec 80 00
	00 00		 cmp	 DWORD PTR _cbWanted$[ebp], 128 ; 00000080H
  004af	76 09		 jbe	 SHORT $L11030
  004b1	c7 45 d0 80 00
	00 00		 mov	 DWORD PTR tv295[ebp], 128 ; 00000080H
  004b8	eb 06		 jmp	 SHORT $L11031
$L11030:
  004ba	8b 4d ec	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  004bd	89 4d d0	 mov	 DWORD PTR tv295[ebp], ecx
$L11031:
  004c0	8b 55 d0	 mov	 edx, DWORD PTR tv295[ebp]
  004c3	89 55 fc	 mov	 DWORD PTR _cbWanted1$[ebp], edx

; 965  :                     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 966  :                                                 pInt->pCallbackContext,
; 967  :                                                 pInt->currPacketOffset + cbObjectOffset, cbWanted1, &pData);

  004c6	8d 45 f0	 lea	 eax, DWORD PTR _pData$[ebp]
  004c9	50		 push	 eax
  004ca	8b 4d fc	 mov	 ecx, DWORD PTR _cbWanted1$[ebp]
  004cd	51		 push	 ecx
  004ce	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  004d1	8b 02		 mov	 eax, DWORD PTR [edx]
  004d3	03 45 e0	 add	 eax, DWORD PTR _cbObjectOffset$[ebp]
  004d6	50		 push	 eax
  004d7	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  004da	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  004e0	52		 push	 edx
  004e1	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  004e4	50		 push	 eax
  004e5	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  004ea	89 45 d8	 mov	 DWORD PTR _cbActual$[ebp], eax

; 968  :                     if(cbActual != cbWanted1)

  004ed	8b 4d d8	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  004f0	3b 4d fc	 cmp	 ecx, DWORD PTR _cbWanted1$[ebp]
  004f3	74 0a		 je	 SHORT $L10581

; 969  :                     {
; 970  :                         return WMAERR_BUFFERTOOSMALL;

  004f5	b8 03 00 00 00	 mov	 eax, 3
  004fa	e9 07 01 00 00	 jmp	 $L10507
$L10581:

; 971  :                     }
; 972  :                     cbObjectOffset += cbActual;

  004ff	8b 55 e0	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  00502	03 55 d8	 add	 edx, DWORD PTR _cbActual$[ebp]
  00505	89 55 e0	 mov	 DWORD PTR _cbObjectOffset$[ebp], edx

; 973  :                     cbWanted -=cbActual;

  00508	8b 45 ec	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  0050b	2b 45 d8	 sub	 eax, DWORD PTR _cbActual$[ebp]
  0050e	89 45 ec	 mov	 DWORD PTR _cbWanted$[ebp], eax

; 974  :             ///////////////////////////////////////////E///////////////////////////       
; 975  :                     memcpy(pECDesc->pDescriptors[i].uValue.pbBinary+cbOffset, pData, cbActual);

  00511	8b 4d d8	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  00514	51		 push	 ecx
  00515	8b 55 f0	 mov	 edx, DWORD PTR _pData$[ebp]
  00518	52		 push	 edx
  00519	0f b7 45 e8	 movzx	 eax, WORD PTR _i$[ebp]
  0051d	6b c0 0e	 imul	 eax, 14			; 0000000eH
  00520	8b 4d dc	 mov	 ecx, DWORD PTR _pECDesc$[ebp]
  00523	8b 51 02	 mov	 edx, DWORD PTR [ecx+2]
  00526	8b 44 02 0a	 mov	 eax, DWORD PTR [edx+eax+10]
  0052a	03 45 f8	 add	 eax, DWORD PTR _cbOffset$[ebp]
  0052d	50		 push	 eax
  0052e	e8 00 00 00 00	 call	 _memcpy
  00533	83 c4 0c	 add	 esp, 12			; 0000000cH

; 976  :                     cbOffset +=cbActual;

  00536	8b 4d f8	 mov	 ecx, DWORD PTR _cbOffset$[ebp]
  00539	03 4d d8	 add	 ecx, DWORD PTR _cbActual$[ebp]
  0053c	89 4d f8	 mov	 DWORD PTR _cbOffset$[ebp], ecx

; 977  :                 }while(cbWanted >0);

  0053f	83 7d ec 00	 cmp	 DWORD PTR _cbWanted$[ebp], 0
  00543	0f 87 5f ff ff
	ff		 ja	 $L10577

; 978  :             }
; 979  :             else

  00549	eb 73		 jmp	 SHORT $L10575
$L10576:

; 980  :             {
; 981  :                 cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 982  :                                             pInt->pCallbackContext,
; 983  :                                             pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  0054b	8d 55 f0	 lea	 edx, DWORD PTR _pData$[ebp]
  0054e	52		 push	 edx
  0054f	8b 45 ec	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  00552	50		 push	 eax
  00553	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00556	8b 11		 mov	 edx, DWORD PTR [ecx]
  00558	03 55 e0	 add	 edx, DWORD PTR _cbObjectOffset$[ebp]
  0055b	52		 push	 edx
  0055c	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0055f	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  00565	51		 push	 ecx
  00566	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00569	52		 push	 edx
  0056a	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  0056f	89 45 d8	 mov	 DWORD PTR _cbActual$[ebp], eax

; 984  :                 if(cbActual != cbWanted)

  00572	8b 45 d8	 mov	 eax, DWORD PTR _cbActual$[ebp]
  00575	3b 45 ec	 cmp	 eax, DWORD PTR _cbWanted$[ebp]
  00578	74 0a		 je	 SHORT $L10584

; 985  :                 {
; 986  :                     return WMAERR_BUFFERTOOSMALL;

  0057a	b8 03 00 00 00	 mov	 eax, 3
  0057f	e9 82 00 00 00	 jmp	 $L10507
$L10584:

; 987  :                 }
; 988  :                 cbObjectOffset += cbActual;

  00584	8b 4d e0	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  00587	03 4d d8	 add	 ecx, DWORD PTR _cbActual$[ebp]
  0058a	89 4d e0	 mov	 DWORD PTR _cbObjectOffset$[ebp], ecx

; 989  :         ///////////////////////////////////////////E///////////////////////////       
; 990  : 
; 991  :                 memcpy(pECDesc->pDescriptors[i].uValue.pbBinary, pData, pECDesc->pDescriptors[i].cbValue);

  0058d	0f b7 55 e8	 movzx	 edx, WORD PTR _i$[ebp]
  00591	6b d2 0e	 imul	 edx, 14			; 0000000eH
  00594	8b 45 dc	 mov	 eax, DWORD PTR _pECDesc$[ebp]
  00597	8b 48 02	 mov	 ecx, DWORD PTR [eax+2]
  0059a	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  0059f	52		 push	 edx
  005a0	8b 45 f0	 mov	 eax, DWORD PTR _pData$[ebp]
  005a3	50		 push	 eax
  005a4	0f b7 4d e8	 movzx	 ecx, WORD PTR _i$[ebp]
  005a8	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  005ab	8b 55 dc	 mov	 edx, DWORD PTR _pECDesc$[ebp]
  005ae	8b 42 02	 mov	 eax, DWORD PTR [edx+2]
  005b1	8b 4c 08 0a	 mov	 ecx, DWORD PTR [eax+ecx+10]
  005b5	51		 push	 ecx
  005b6	e8 00 00 00 00	 call	 _memcpy
  005bb	83 c4 0c	 add	 esp, 12			; 0000000cH
$L10575:

; 992  : 
; 993  :             }
; 994  :     }
; 995  : #ifndef LITTLE_ENDIAN
; 996  :         if((pECDesc->pDescriptors[i].data_type == ECD_DWORD) ||
; 997  :         (pECDesc->pDescriptors[i].data_type == ECD_BOOL))
; 998  :             SWAPDWORD((tWMA_U8 *)pECDesc->pDescriptors[i].uValue.pbBinary);
; 999  :         else if(pECDesc->pDescriptors[i].data_type == ECD_STRING)
; 1000 :             SwapWstr((tWMA_U16 *)pECDesc->pDescriptors[i].uValue.pwszString, (tWMA_U32)(pECDesc->pDescriptors[i].cbValue / sizeof(tWMA_U16));
; 1001 :         else if(pECDesc->pDescriptors[i].data_type == ECD_WORD)
; 1002 :             SWAPWORD((tWMA_U8 *)pECDesc->pDescriptors[i].uValue.pbBinary);
; 1003 : #endif
; 1004 :         pData += pECDesc->pDescriptors[i].cbValue;

  005be	0f b7 55 e8	 movzx	 edx, WORD PTR _i$[ebp]
  005c2	6b d2 0e	 imul	 edx, 14			; 0000000eH
  005c5	8b 45 dc	 mov	 eax, DWORD PTR _pECDesc$[ebp]
  005c8	8b 48 02	 mov	 ecx, DWORD PTR [eax+2]
  005cb	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  005d0	8b 45 f0	 mov	 eax, DWORD PTR _pData$[ebp]
  005d3	03 c2		 add	 eax, edx
  005d5	89 45 f0	 mov	 DWORD PTR _pData$[ebp], eax

; 1005 :         cbBuffer -= pECDesc->pDescriptors[i].cbValue;

  005d8	0f b7 4d e8	 movzx	 ecx, WORD PTR _i$[ebp]
  005dc	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  005df	8b 55 dc	 mov	 edx, DWORD PTR _pECDesc$[ebp]
  005e2	8b 42 02	 mov	 eax, DWORD PTR [edx+2]
  005e5	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  005ea	8b 55 e4	 mov	 edx, DWORD PTR _cbBuffer$[ebp]
  005ed	2b d1		 sub	 edx, ecx
  005ef	89 55 e4	 mov	 DWORD PTR _cbBuffer$[ebp], edx

; 1006 :     }

  005f2	e9 30 fb ff ff	 jmp	 $L10538
$SKIP$10523:

; 1007 : 
; 1008 : SKIP:
; 1009 :     /* use all */
; 1010 :     pInt->currPacketOffset += cbSize;

  005f7	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  005fa	8b 08		 mov	 ecx, DWORD PTR [eax]
  005fc	03 4d 0c	 add	 ecx, DWORD PTR _cbSize$[ebp]
  005ff	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00602	89 0a		 mov	 DWORD PTR [edx], ecx

; 1011 : 
; 1012 :     return( WMAERR_OK );

  00604	33 c0		 xor	 eax, eax
$L10507:

; 1013 : }

  00606	8b e5		 mov	 esp, ebp
  00608	5d		 pop	 ebp
  00609	c2 08 00	 ret	 8
_WMA_LoadExtendedContentDescObject@8 ENDP
WMADEC	ENDS
PUBLIC	_WMA_LoadLicenseStoreObject@8
; Function compile flags: /Odt
;	COMDAT _WMA_LoadLicenseStoreObject@8
WMADEC	SEGMENT
_m_dwFlag$ = -24
_cbActual$ = -20
_cbObjectOffset$ = -16
_cbWanted$ = -12
_pData$ = -8
_cbDone$ = -4
_pInt$ = 8
_cbSize$ = 12
_WMA_LoadLicenseStoreObject@8 PROC NEAR			; COMDAT

; 1019 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 1020 :     BYTE *pData;
; 1021 :     DWORD cbWanted;
; 1022 :     DWORD cbDone;
; 1023 :     DWORD cbActual;
; 1024 : 
; 1025 :     DWORD m_dwFlag;
; 1026 : 
; 1027 :     DWORD cbObjectOffset = 0;

  00006	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _cbObjectOffset$[ebp], 0

; 1028 : 
; 1029 :     if(pInt == NULL)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00011	75 0a		 jne	 SHORT $L10598

; 1030 :     {
; 1031 :         return WMAERR_INVALIDARG;

  00013	b8 02 00 00 00	 mov	 eax, 2
  00018	e9 4f 01 00 00	 jmp	 $L10590
$L10598:

; 1032 :     }
; 1033 : 
; 1034 :     cbSize -= MIN_OBJECT_SIZE;

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _cbSize$[ebp]
  00020	83 e8 18	 sub	 eax, 24			; 00000018H
  00023	89 45 0c	 mov	 DWORD PTR _cbSize$[ebp], eax

; 1035 : 
; 1036 :     cbWanted = 8;

  00026	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 8

; 1037 :     if(cbObjectOffset + cbWanted > cbSize)

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  00030	03 4d f4	 add	 ecx, DWORD PTR _cbWanted$[ebp]
  00033	3b 4d 0c	 cmp	 ecx, DWORD PTR _cbSize$[ebp]
  00036	76 0a		 jbe	 SHORT $L10599

; 1038 :     {
; 1039 :         return WMAERR_BUFFERTOOSMALL;

  00038	b8 03 00 00 00	 mov	 eax, 3
  0003d	e9 2a 01 00 00	 jmp	 $L10590
$L10599:

; 1040 :     }
; 1041 :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1042 :                                 pInt->pCallbackContext,
; 1043 :                                 pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  00042	8d 55 f8	 lea	 edx, DWORD PTR _pData$[ebp]
  00045	52		 push	 edx
  00046	8b 45 f4	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0004d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004f	03 55 f0	 add	 edx, DWORD PTR _cbObjectOffset$[ebp]
  00052	52		 push	 edx
  00053	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00056	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  0005c	51		 push	 ecx
  0005d	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00066	89 45 ec	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1044 :     if(cbActual != cbWanted)

  00069	8b 45 ec	 mov	 eax, DWORD PTR _cbActual$[ebp]
  0006c	3b 45 f4	 cmp	 eax, DWORD PTR _cbWanted$[ebp]
  0006f	74 0a		 je	 SHORT $L10601

; 1045 :     {
; 1046 :         return WMAERR_BUFFERTOOSMALL;

  00071	b8 03 00 00 00	 mov	 eax, 3
  00076	e9 f1 00 00 00	 jmp	 $L10590
$L10601:

; 1047 :     }
; 1048 :     cbObjectOffset += cbActual;

  0007b	8b 4d f0	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  0007e	03 4d ec	 add	 ecx, DWORD PTR _cbActual$[ebp]
  00081	89 4d f0	 mov	 DWORD PTR _cbObjectOffset$[ebp], ecx

; 1049 : 
; 1050 :     LoadDWORD(m_dwFlag, pData);

  00084	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  00087	8b 02		 mov	 eax, DWORD PTR [edx]
  00089	89 45 e8	 mov	 DWORD PTR _m_dwFlag$[ebp], eax
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  0008f	83 c1 04	 add	 ecx, 4
  00092	89 4d f8	 mov	 DWORD PTR _pData$[ebp], ecx

; 1051 :     LoadDWORD(pInt->m_dwLicenseLen, pData);

  00095	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00098	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  0009b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009d	89 8a b4 00 00
	00		 mov	 DWORD PTR [edx+180], ecx
  000a3	8b 55 f8	 mov	 edx, DWORD PTR _pData$[ebp]
  000a6	83 c2 04	 add	 edx, 4
  000a9	89 55 f8	 mov	 DWORD PTR _pData$[ebp], edx

; 1052 : 
; 1053 :     cbWanted = pInt->m_dwLicenseLen;

  000ac	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  000af	8b 88 b4 00 00
	00		 mov	 ecx, DWORD PTR [eax+180]
  000b5	89 4d f4	 mov	 DWORD PTR _cbWanted$[ebp], ecx

; 1054 :     if(cbObjectOffset + cbWanted > cbSize)

  000b8	8b 55 f0	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  000bb	03 55 f4	 add	 edx, DWORD PTR _cbWanted$[ebp]
  000be	3b 55 0c	 cmp	 edx, DWORD PTR _cbSize$[ebp]
  000c1	76 0a		 jbe	 SHORT $L10606

; 1055 :     {
; 1056 :         return WMAERR_NOTDONE;

  000c3	b8 07 00 00 00	 mov	 eax, 7
  000c8	e9 9f 00 00 00	 jmp	 $L10590
$L10606:

; 1057 :     }
; 1058 :     pInt->m_pLicData = malloc(cbWanted);

  000cd	8b 45 f4	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _malloc
  000d6	83 c4 04	 add	 esp, 4
  000d9	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000dc	89 81 b8 00 00
	00		 mov	 DWORD PTR [ecx+184], eax

; 1059 : 
; 1060 :     cbDone = 0;

  000e2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cbDone$[ebp], 0
$L10608:

; 1061 :     while (cbWanted) {

  000e9	83 7d f4 00	 cmp	 DWORD PTR _cbWanted$[ebp], 0
  000ed	74 6e		 je	 SHORT $L10609

; 1062 :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1063 :                                     pInt->pCallbackContext,
; 1064 :                                     pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  000ef	8d 55 f8	 lea	 edx, DWORD PTR _pData$[ebp]
  000f2	52		 push	 edx
  000f3	8b 45 f4	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  000f6	50		 push	 eax
  000f7	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000fa	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fc	03 55 f0	 add	 edx, DWORD PTR _cbObjectOffset$[ebp]
  000ff	52		 push	 edx
  00100	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00103	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  00109	51		 push	 ecx
  0010a	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0010d	52		 push	 edx
  0010e	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00113	89 45 ec	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1065 :         memcpy(pInt->m_pLicData + cbDone, pData, cbActual);

  00116	8b 45 ec	 mov	 eax, DWORD PTR _cbActual$[ebp]
  00119	50		 push	 eax
  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  0011d	51		 push	 ecx
  0011e	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00121	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  00127	03 45 fc	 add	 eax, DWORD PTR _cbDone$[ebp]
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _memcpy
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1066 :         cbObjectOffset += cbActual;

  00133	8b 4d f0	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  00136	03 4d ec	 add	 ecx, DWORD PTR _cbActual$[ebp]
  00139	89 4d f0	 mov	 DWORD PTR _cbObjectOffset$[ebp], ecx

; 1067 :         cbWanted -= cbActual;

  0013c	8b 55 f4	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  0013f	2b 55 ec	 sub	 edx, DWORD PTR _cbActual$[ebp]
  00142	89 55 f4	 mov	 DWORD PTR _cbWanted$[ebp], edx

; 1068 :         cbDone   += cbActual;

  00145	8b 45 fc	 mov	 eax, DWORD PTR _cbDone$[ebp]
  00148	03 45 ec	 add	 eax, DWORD PTR _cbActual$[ebp]
  0014b	89 45 fc	 mov	 DWORD PTR _cbDone$[ebp], eax

; 1069 :         if(cbActual == 0)

  0014e	83 7d ec 00	 cmp	 DWORD PTR _cbActual$[ebp], 0
  00152	75 07		 jne	 SHORT $L10611

; 1070 :         {
; 1071 :             return WMAERR_FAIL;

  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	eb 11		 jmp	 SHORT $L10590
$L10611:

; 1072 :         }
; 1073 :     }

  0015b	eb 8c		 jmp	 SHORT $L10608
$L10609:

; 1074 : 
; 1075 : //    pInt->cbCDOffset = pInt->currPacketOffset + cbObjectOffset;
; 1076 : 
; 1077 :     /* use all */
; 1078 :     pInt->currPacketOffset += cbSize;

  0015d	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00160	8b 11		 mov	 edx, DWORD PTR [ecx]
  00162	03 55 0c	 add	 edx, DWORD PTR _cbSize$[ebp]
  00165	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00168	89 10		 mov	 DWORD PTR [eax], edx

; 1079 : 
; 1080 :     return WMAERR_OK;

  0016a	33 c0		 xor	 eax, eax
$L10590:

; 1081 : }

  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c2 08 00	 ret	 8
_WMA_LoadLicenseStoreObject@8 ENDP
WMADEC	ENDS
PUBLIC	_WMA_LoadMarkerObject@12
; Function compile flags: /Odt
;	COMDAT _WMA_LoadMarkerObject@12
WMADEC	SEGMENT
_j$ = -52
_cbActual$ = -48
_m_gMarkerStrategy$ = -44
_m_wNameLen$ = -28
_tw$ = -24
_m_wAlignment$ = -20
_cbObjectOffset$ = -16
_i$ = -12
_cbWanted$ = -8
_pData$ = -4
_pInt$ = 8
_cbSize$ = 12
_iIndex$ = 16
_WMA_LoadMarkerObject@12 PROC NEAR			; COMDAT

; 1086 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 1087 :     BYTE *pData;
; 1088 :     DWORD cbWanted;
; 1089 :     DWORD cbActual;
; 1090 : 
; 1091 :     DWORD cbObjectOffset = 0;

  00006	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _cbObjectOffset$[ebp], 0

; 1092 : 
; 1093 :     GUID    m_gMarkerStrategy;
; 1094 :     WORD    m_wAlignment;
; 1095 :     WORD    m_wNameLen;
; 1096 :     WORD    tw;
; 1097 :     unsigned int i, j;
; 1098 : 
; 1099 : 
; 1100 :     if(pInt == NULL)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00011	75 0a		 jne	 SHORT $L10631

; 1101 :     {
; 1102 :         return WMAERR_INVALIDARG;

  00013	b8 02 00 00 00	 mov	 eax, 2
  00018	e9 b5 03 00 00	 jmp	 $L10619
$L10631:

; 1103 :     }
; 1104 : 
; 1105 : 
; 1106 :     cbSize -= MIN_OBJECT_SIZE;

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _cbSize$[ebp]
  00020	83 e8 18	 sub	 eax, 24			; 00000018H
  00023	89 45 0c	 mov	 DWORD PTR _cbSize$[ebp], eax

; 1107 : 
; 1108 :     cbWanted = 24;

  00026	c7 45 f8 18 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 24 ; 00000018H

; 1109 :     if(cbObjectOffset + cbWanted > cbSize)

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  00030	03 4d f8	 add	 ecx, DWORD PTR _cbWanted$[ebp]
  00033	3b 4d 0c	 cmp	 ecx, DWORD PTR _cbSize$[ebp]
  00036	76 0a		 jbe	 SHORT $L10632

; 1110 :     {
; 1111 :         return WMAERR_BUFFERTOOSMALL;

  00038	b8 03 00 00 00	 mov	 eax, 3
  0003d	e9 90 03 00 00	 jmp	 $L10619
$L10632:

; 1112 :     }
; 1113 :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1114 :                                 pInt->pCallbackContext,
; 1115 :                                 pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  00042	8d 55 fc	 lea	 edx, DWORD PTR _pData$[ebp]
  00045	52		 push	 edx
  00046	8b 45 f8	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0004d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004f	03 55 f0	 add	 edx, DWORD PTR _cbObjectOffset$[ebp]
  00052	52		 push	 edx
  00053	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00056	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  0005c	51		 push	 ecx
  0005d	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00066	89 45 d0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1116 :     if(cbActual != cbWanted)

  00069	8b 45 d0	 mov	 eax, DWORD PTR _cbActual$[ebp]
  0006c	3b 45 f8	 cmp	 eax, DWORD PTR _cbWanted$[ebp]
  0006f	74 0a		 je	 SHORT $L10634

; 1117 :     {
; 1118 :         return WMAERR_BUFFERTOOSMALL;

  00071	b8 03 00 00 00	 mov	 eax, 3
  00076	e9 57 03 00 00	 jmp	 $L10619
$L10634:

; 1119 :     }
; 1120 :     cbObjectOffset += cbActual;

  0007b	8b 4d f0	 mov	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  0007e	03 4d d0	 add	 ecx, DWORD PTR _cbActual$[ebp]
  00081	89 4d f0	 mov	 DWORD PTR _cbObjectOffset$[ebp], ecx

; 1121 : 
; 1122 :     LoadGUID (m_gMarkerStrategy, pData);

  00084	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00087	8b 02		 mov	 eax, DWORD PTR [edx]
  00089	89 45 d4	 mov	 DWORD PTR _m_gMarkerStrategy$[ebp], eax
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  0008f	83 c1 04	 add	 ecx, 4
  00092	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  00095	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00098	66 8b 02	 mov	 ax, WORD PTR [edx]
  0009b	66 89 45 d8	 mov	 WORD PTR _m_gMarkerStrategy$[ebp+4], ax
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000a2	83 c1 02	 add	 ecx, 2
  000a5	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  000a8	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000ab	66 8b 02	 mov	 ax, WORD PTR [edx]
  000ae	66 89 45 da	 mov	 WORD PTR _m_gMarkerStrategy$[ebp+6], ax
  000b2	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000b5	83 c1 02	 add	 ecx, 2
  000b8	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  000bb	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000be	8a 02		 mov	 al, BYTE PTR [edx]
  000c0	88 45 dc	 mov	 BYTE PTR _m_gMarkerStrategy$[ebp+8], al
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000c6	83 c1 01	 add	 ecx, 1
  000c9	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  000cc	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000cf	8a 02		 mov	 al, BYTE PTR [edx]
  000d1	88 45 dd	 mov	 BYTE PTR _m_gMarkerStrategy$[ebp+9], al
  000d4	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000d7	83 c1 01	 add	 ecx, 1
  000da	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  000dd	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000e0	8a 02		 mov	 al, BYTE PTR [edx]
  000e2	88 45 de	 mov	 BYTE PTR _m_gMarkerStrategy$[ebp+10], al
  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000e8	83 c1 01	 add	 ecx, 1
  000eb	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  000ee	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000f1	8a 02		 mov	 al, BYTE PTR [edx]
  000f3	88 45 df	 mov	 BYTE PTR _m_gMarkerStrategy$[ebp+11], al
  000f6	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000f9	83 c1 01	 add	 ecx, 1
  000fc	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  000ff	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00102	8a 02		 mov	 al, BYTE PTR [edx]
  00104	88 45 e0	 mov	 BYTE PTR _m_gMarkerStrategy$[ebp+12], al
  00107	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  0010a	83 c1 01	 add	 ecx, 1
  0010d	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  00110	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00113	8a 02		 mov	 al, BYTE PTR [edx]
  00115	88 45 e1	 mov	 BYTE PTR _m_gMarkerStrategy$[ebp+13], al
  00118	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  0011b	83 c1 01	 add	 ecx, 1
  0011e	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  00121	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00124	8a 02		 mov	 al, BYTE PTR [edx]
  00126	88 45 e2	 mov	 BYTE PTR _m_gMarkerStrategy$[ebp+14], al
  00129	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  0012c	83 c1 01	 add	 ecx, 1
  0012f	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx
  00132	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00135	8a 02		 mov	 al, BYTE PTR [edx]
  00137	88 45 e3	 mov	 BYTE PTR _m_gMarkerStrategy$[ebp+15], al
  0013a	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  0013d	83 c1 01	 add	 ecx, 1
  00140	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx

; 1123 :     LoadDWORD(pInt->m_dwMarkerNum, pData);

  00143	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00146	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00149	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014b	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx
  00151	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00154	83 c2 04	 add	 edx, 4
  00157	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 1124 :     LoadWORD (m_wAlignment, pData);

  0015a	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  0015d	66 8b 08	 mov	 cx, WORD PTR [eax]
  00160	66 89 4d ec	 mov	 WORD PTR _m_wAlignment$[ebp], cx
  00164	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00167	83 c2 02	 add	 edx, 2
  0016a	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 1125 :     LoadWORD (m_wNameLen, pData);

  0016d	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00170	66 8b 08	 mov	 cx, WORD PTR [eax]
  00173	66 89 4d e4	 mov	 WORD PTR _m_wNameLen$[ebp], cx
  00177	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  0017a	83 c2 02	 add	 edx, 2
  0017d	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 1126 : 
; 1127 :     //pInt->m_pMarkers = (MarkerEntry *) malloc(sizeof(MarkerEntry)*pInt->m_dwMarkerNum);
; 1128 : 	
; 1129 : //NQF+
; 1130 : 	if( pInt->m_dwMarkerNum == 0)

  00180	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00183	83 b8 ac 00 00
	00 00		 cmp	 DWORD PTR [eax+172], 0
  0018a	75 14		 jne	 SHORT $L10663

; 1131 : 	{
; 1132 :         /* use all */
; 1133 :         pInt->currPacketOffset += cbSize;

  0018c	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0018f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00191	03 55 0c	 add	 edx, DWORD PTR _cbSize$[ebp]
  00194	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00197	89 10		 mov	 DWORD PTR [eax], edx

; 1134 :     	return WMAERR_OK;

  00199	33 c0		 xor	 eax, eax
  0019b	e9 32 02 00 00	 jmp	 $L10619
$L10663:

; 1135 : 
; 1136 :     } else if ( iIndex < 0 ) {  //for query number of Markers

  001a0	83 7d 10 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  001a4	7d 14		 jge	 SHORT $L10665

; 1137 :         
; 1138 :         /* use all */
; 1139 :         pInt->currPacketOffset += cbSize;

  001a6	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  001a9	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ab	03 55 0c	 add	 edx, DWORD PTR _cbSize$[ebp]
  001ae	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  001b1	89 10		 mov	 DWORD PTR [eax], edx

; 1140 :         return WMAERR_OK;

  001b3	33 c0		 xor	 eax, eax
  001b5	e9 18 02 00 00	 jmp	 $L10619
$L10665:

; 1141 : 
; 1142 :     } else if ( iIndex >= (int) pInt -> m_dwMarkerNum) {

  001ba	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  001bd	8b 55 10	 mov	 edx, DWORD PTR _iIndex$[ebp]
  001c0	3b 91 ac 00 00
	00		 cmp	 edx, DWORD PTR [ecx+172]
  001c6	7c 17		 jl	 SHORT $L10664

; 1143 :         /* use all */
; 1144 :         pInt->currPacketOffset += cbSize;

  001c8	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  001cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cd	03 4d 0c	 add	 ecx, DWORD PTR _cbSize$[ebp]
  001d0	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  001d3	89 0a		 mov	 DWORD PTR [edx], ecx

; 1145 :         return WMAERR_BUFFERTOOSMALL;  //NQF_temp 

  001d5	b8 03 00 00 00	 mov	 eax, 3
  001da	e9 f3 01 00 00	 jmp	 $L10619
$L10664:

; 1146 :     }
; 1147 : //NQF-
; 1148 : 
; 1149 :     for (j = 0; j <= (unsigned int) iIndex; j++) {

  001df	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  001e6	eb 09		 jmp	 SHORT $L10670
$L10671:
  001e8	8b 45 cc	 mov	 eax, DWORD PTR _j$[ebp]
  001eb	83 c0 01	 add	 eax, 1
  001ee	89 45 cc	 mov	 DWORD PTR _j$[ebp], eax
$L10670:
  001f1	8b 4d cc	 mov	 ecx, DWORD PTR _j$[ebp]
  001f4	3b 4d 10	 cmp	 ecx, DWORD PTR _iIndex$[ebp]
  001f7	0f 87 c6 01 00
	00		 ja	 $L10672

; 1150 :         cbWanted = 18;

  001fd	c7 45 f8 12 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 18 ; 00000012H

; 1151 :         if(cbObjectOffset + cbWanted > cbSize)

  00204	8b 55 f0	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  00207	03 55 f8	 add	 edx, DWORD PTR _cbWanted$[ebp]
  0020a	3b 55 0c	 cmp	 edx, DWORD PTR _cbSize$[ebp]
  0020d	76 0a		 jbe	 SHORT $L10673

; 1152 :         {
; 1153 :             return WMAERR_BUFFERTOOSMALL;

  0020f	b8 03 00 00 00	 mov	 eax, 3
  00214	e9 b9 01 00 00	 jmp	 $L10619
$L10673:

; 1154 :         }
; 1155 :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1156 :                                     pInt->pCallbackContext,
; 1157 :                                     pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  00219	8d 45 fc	 lea	 eax, DWORD PTR _pData$[ebp]
  0021c	50		 push	 eax
  0021d	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00220	51		 push	 ecx
  00221	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00224	8b 02		 mov	 eax, DWORD PTR [edx]
  00226	03 45 f0	 add	 eax, DWORD PTR _cbObjectOffset$[ebp]
  00229	50		 push	 eax
  0022a	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0022d	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  00233	52		 push	 edx
  00234	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00237	50		 push	 eax
  00238	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  0023d	89 45 d0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1158 :         if(cbActual != cbWanted)

  00240	8b 4d d0	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  00243	3b 4d f8	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  00246	74 0a		 je	 SHORT $L10675

; 1159 :         {
; 1160 :             return WMAERR_BUFFERTOOSMALL;

  00248	b8 03 00 00 00	 mov	 eax, 3
  0024d	e9 80 01 00 00	 jmp	 $L10619
$L10675:

; 1161 :         }
; 1162 :         cbObjectOffset += cbActual;

  00252	8b 55 f0	 mov	 edx, DWORD PTR _cbObjectOffset$[ebp]
  00255	03 55 d0	 add	 edx, DWORD PTR _cbActual$[ebp]
  00258	89 55 f0	 mov	 DWORD PTR _cbObjectOffset$[ebp], edx

; 1163 : 
; 1164 :         LoadQWORD(pInt->m_pMarker->m_qOffset, pData);

  0025b	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  0025e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00260	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00263	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00266	8b 80 b0 00 00
	00		 mov	 eax, DWORD PTR [eax+176]
  0026c	89 08		 mov	 DWORD PTR [eax], ecx
  0026e	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00271	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  00274	83 c1 08	 add	 ecx, 8
  00277	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx

; 1165 :         LoadQWORD(pInt->m_pMarker->m_qtime, pData);

  0027a	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  0027d	8b 02		 mov	 eax, DWORD PTR [edx]
  0027f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00282	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00285	8b 92 b0 00 00
	00		 mov	 edx, DWORD PTR [edx+176]
  0028b	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0028e	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00291	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00294	83 c0 08	 add	 eax, 8
  00297	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax

; 1166 :         LoadWORD (pInt->m_pMarker->m_wEntryLen, pData);

  0029a	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0029d	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  002a3	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  002a6	66 8b 08	 mov	 cx, WORD PTR [eax]
  002a9	66 89 4a 10	 mov	 WORD PTR [edx+16], cx
  002ad	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  002b0	83 c2 02	 add	 edx, 2
  002b3	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 1167 : 
; 1168 :         cbWanted = pInt->m_pMarker->m_wEntryLen;

  002b6	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  002b9	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  002bf	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  002c3	89 55 f8	 mov	 DWORD PTR _cbWanted$[ebp], edx

; 1169 :         if(cbObjectOffset + cbWanted > cbSize)

  002c6	8b 45 f0	 mov	 eax, DWORD PTR _cbObjectOffset$[ebp]
  002c9	03 45 f8	 add	 eax, DWORD PTR _cbWanted$[ebp]
  002cc	3b 45 0c	 cmp	 eax, DWORD PTR _cbSize$[ebp]
  002cf	76 0a		 jbe	 SHORT $L10682

; 1170 :         {
; 1171 :             return WMAERR_BUFFERTOOSMALL;

  002d1	b8 03 00 00 00	 mov	 eax, 3
  002d6	e9 f7 00 00 00	 jmp	 $L10619
$L10682:

; 1172 :         }
; 1173 :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1174 :                                     pInt->pCallbackContext,
; 1175 :                                     pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);

  002db	8d 4d fc	 lea	 ecx, DWORD PTR _pData$[ebp]
  002de	51		 push	 ecx
  002df	8b 55 f8	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  002e2	52		 push	 edx
  002e3	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  002e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e8	03 4d f0	 add	 ecx, DWORD PTR _cbObjectOffset$[ebp]
  002eb	51		 push	 ecx
  002ec	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  002ef	8b 82 c0 00 00
	00		 mov	 eax, DWORD PTR [edx+192]
  002f5	50		 push	 eax
  002f6	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  002f9	51		 push	 ecx
  002fa	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  002ff	89 45 d0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1176 :         if(cbActual != cbWanted)

  00302	8b 55 d0	 mov	 edx, DWORD PTR _cbActual$[ebp]
  00305	3b 55 f8	 cmp	 edx, DWORD PTR _cbWanted$[ebp]
  00308	74 0a		 je	 SHORT $L10684

; 1177 :         {
; 1178 :             return WMAERR_BUFFERTOOSMALL;

  0030a	b8 03 00 00 00	 mov	 eax, 3
  0030f	e9 be 00 00 00	 jmp	 $L10619
$L10684:

; 1179 :         }
; 1180 :         cbObjectOffset += cbActual;

  00314	8b 45 f0	 mov	 eax, DWORD PTR _cbObjectOffset$[ebp]
  00317	03 45 d0	 add	 eax, DWORD PTR _cbActual$[ebp]
  0031a	89 45 f0	 mov	 DWORD PTR _cbObjectOffset$[ebp], eax

; 1181 : 
; 1182 :         LoadDWORD(pInt->m_pMarker->m_dwSendTime, pData);

  0031d	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00320	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  00326	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00329	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032b	89 4a 12	 mov	 DWORD PTR [edx+18], ecx
  0032e	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00331	83 c2 04	 add	 edx, 4
  00334	89 55 fc	 mov	 DWORD PTR _pData$[ebp], edx

; 1183 :         LoadDWORD(pInt->m_pMarker->m_dwFlags, pData);

  00337	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0033a	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00340	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00343	8b 02		 mov	 eax, DWORD PTR [edx]
  00345	89 41 16	 mov	 DWORD PTR [ecx+22], eax
  00348	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  0034b	83 c1 04	 add	 ecx, 4
  0034e	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx

; 1184 :         LoadDWORD(pInt->m_pMarker->m_dwDescLen, pData);

  00351	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00354	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  0035a	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  0035d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0035f	89 50 1a	 mov	 DWORD PTR [eax+26], edx
  00362	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00365	83 c0 04	 add	 eax, 4
  00368	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax

; 1185 : 
; 1186 :         //pInt->m_pMarkers[j].m_pwDescName = (WORD *)malloc(sizeof(WORD)*pInt->m_pMarkers[j].m_dwDescLen);
; 1187 : 
; 1188 :         for (i=0;i<pInt->m_pMarker->m_dwDescLen && i < DESC_NAME_MAX_LENGTH; i++) {

  0036b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00372	eb 09		 jmp	 SHORT $L10691
$L10692:
  00374	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00377	83 c1 01	 add	 ecx, 1
  0037a	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$L10691:
  0037d	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00380	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  00386	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00389	3b 48 1a	 cmp	 ecx, DWORD PTR [eax+26]
  0038c	73 30		 jae	 SHORT $L10693
  0038e	83 7d f4 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  00392	73 2a		 jae	 SHORT $L10693

; 1189 :             LoadWORD(tw, pData);

  00394	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00397	66 8b 02	 mov	 ax, WORD PTR [edx]
  0039a	66 89 45 e8	 mov	 WORD PTR _tw$[ebp], ax
  0039e	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  003a1	83 c1 02	 add	 ecx, 2
  003a4	89 4d fc	 mov	 DWORD PTR _pData$[ebp], ecx

; 1190 :             pInt->m_pMarker->m_pwDescName[i] = tw;

  003a7	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  003aa	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  003b0	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  003b3	66 8b 55 e8	 mov	 dx, WORD PTR _tw$[ebp]
  003b7	66 89 54 48 1e	 mov	 WORD PTR [eax+ecx*2+30], dx

; 1191 :         }

  003bc	eb b6		 jmp	 SHORT $L10692
$L10693:

; 1192 :     }

  003be	e9 25 fe ff ff	 jmp	 $L10671
$L10672:

; 1193 : 
; 1194 :     /* use all */
; 1195 :     pInt->currPacketOffset += cbSize;

  003c3	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  003c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c8	03 4d 0c	 add	 ecx, DWORD PTR _cbSize$[ebp]
  003cb	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  003ce	89 0a		 mov	 DWORD PTR [edx], ecx

; 1196 : 
; 1197 :     return WMAERR_OK;

  003d0	33 c0		 xor	 eax, eax
$L10619:

; 1198 : }

  003d2	8b e5		 mov	 esp, ebp
  003d4	5d		 pop	 ebp
  003d5	c2 0c 00	 ret	 12			; 0000000cH
_WMA_LoadMarkerObject@12 ENDP
WMADEC	ENDS
PUBLIC	_WMA_GetMarkerObject@8
; Function compile flags: /Odt
;	COMDAT _WMA_GetMarkerObject@8
WMADEC	SEGMENT
_objId$ = -28
_wmarc$ = -12
_qwSize$ = -8
_pInt$ = 8
_iIndex$ = 12
_WMA_GetMarkerObject@8 PROC NEAR			; COMDAT

; 1202 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1203 :     WMAERR wmarc;
; 1204 :     GUID objId;
; 1205 :     QWORD qwSize;
; 1206 : 
; 1207 :     if(pInt == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  0000a	75 0a		 jne	 SHORT $L10705

; 1208 :     {
; 1209 :         return WMAERR_INVALIDARG;

  0000c	b8 02 00 00 00	 mov	 eax, 2
  00011	e9 02 01 00 00	 jmp	 $L10700
$L10705:

; 1210 :     }
; 1211 : 
; 1212 :     /* initialize the some state */
; 1213 : 
; 1214 :     pInt->currPacketOffset = 0;

  00016	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00019	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1215 : 
; 1216 :     pInt->cbCDOffset      = 0;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00022	c7 81 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+152], 0

; 1217 :     pInt->cbCDTitle       = 0;

  0002c	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0002f	66 c7 82 9c 00
	00 00 00 00	 mov	 WORD PTR [edx+156], 0

; 1218 :     pInt->cbCDAuthor      = 0;

  00038	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0003b	66 c7 80 9e 00
	00 00 00 00	 mov	 WORD PTR [eax+158], 0

; 1219 :     pInt->cbCDCopyright   = 0;

  00044	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00047	66 c7 81 a0 00
	00 00 00 00	 mov	 WORD PTR [ecx+160], 0

; 1220 :     pInt->cbCDDescription = 0;

  00050	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00053	66 c7 82 a2 00
	00 00 00 00	 mov	 WORD PTR [edx+162], 0

; 1221 :     pInt->cbCDRating      = 0;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0005f	66 c7 80 a4 00
	00 00 00 00	 mov	 WORD PTR [eax+164], 0

; 1222 : 
; 1223 : 
; 1224 :     /* ASF Header Object */
; 1225 : 
; 1226 :     wmarc = WMA_LoadHeaderObject(pInt, 0);

  00068	6a 00		 push	 0
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 _WMA_LoadHeaderObject@8
  00073	89 45 f4	 mov	 DWORD PTR _wmarc$[ebp], eax

; 1227 :     if(wmarc != WMAERR_OK)

  00076	83 7d f4 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  0007a	74 08		 je	 SHORT $L10706

; 1228 :     {
; 1229 :         return wmarc;

  0007c	8b 45 f4	 mov	 eax, DWORD PTR _wmarc$[ebp]
  0007f	e9 94 00 00 00	 jmp	 $L10700
$L10706:

; 1230 :     }
; 1231 :     pInt->cbFirstPacketOffset = pInt->cbHeader += DATA_OBJECT_SIZE;

  00084	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00087	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008a	83 c0 32	 add	 eax, 50			; 00000032H
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00090	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00093	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00096	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00099	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0009c	89 4a 20	 mov	 DWORD PTR [edx+32], ecx
$L10708:

; 1232 : 
; 1233 :     /* Scan Header Objects */
; 1234 : 
; 1235 :     while(pInt->currPacketOffset < pInt->cbFirstPacketOffset)

  0009f	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  000a2	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  000a5	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000a7	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  000aa	73 6a		 jae	 SHORT $L10709

; 1236 :     {
; 1237 :         wmarc = WMA_LoadObjectHeader(pInt, &objId, &qwSize);

  000ac	8d 55 f8	 lea	 edx, DWORD PTR _qwSize$[ebp]
  000af	52		 push	 edx
  000b0	8d 45 e4	 lea	 eax, DWORD PTR _objId$[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000b7	51		 push	 ecx
  000b8	e8 00 00 00 00	 call	 _WMA_LoadObjectHeader@12
  000bd	89 45 f4	 mov	 DWORD PTR _wmarc$[ebp], eax

; 1238 :         if(wmarc != WMAERR_OK)

  000c0	83 7d f4 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  000c4	74 05		 je	 SHORT $L10710

; 1239 :         {
; 1240 :             return wmarc;

  000c6	8b 45 f4	 mov	 eax, DWORD PTR _wmarc$[ebp]
  000c9	eb 4d		 jmp	 SHORT $L10700
$L10710:

; 1241 :         }
; 1242 : 
; 1243 :         if(WMA_IsEqualGUID(&CLSID_CAsfMarkerObjectV0, &objId))

  000cb	6a 10		 push	 16			; 00000010H
  000cd	8d 55 e4	 lea	 edx, DWORD PTR _objId$[ebp]
  000d0	52		 push	 edx
  000d1	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_CAsfMarkerObjectV0_XDS
  000d6	e8 00 00 00 00	 call	 _memcmp
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH
  000de	85 c0		 test	 eax, eax
  000e0	75 21		 jne	 SHORT $L10714

; 1244 :         {
; 1245 :             wmarc = WMA_LoadMarkerObject(pInt, qwSize.dwLo, iIndex);

  000e2	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000e5	50		 push	 eax
  000e6	8b 4d f8	 mov	 ecx, DWORD PTR _qwSize$[ebp]
  000e9	51		 push	 ecx
  000ea	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 _WMA_LoadMarkerObject@12
  000f3	89 45 f4	 mov	 DWORD PTR _wmarc$[ebp], eax

; 1246 :             if(wmarc != WMAERR_OK)

  000f6	83 7d f4 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  000fa	74 05		 je	 SHORT $L10715

; 1247 :             {
; 1248 :                 return wmarc;            

  000fc	8b 45 f4	 mov	 eax, DWORD PTR _wmarc$[ebp]
  000ff	eb 17		 jmp	 SHORT $L10700
$L10715:

; 1249 :             }
; 1250 :             break;  

  00101	eb 13		 jmp	 SHORT $L10709
$L10714:

; 1251 :         }
; 1252 :         else
; 1253 :         {
; 1254 :             /* skip over this object */
; 1255 :             pInt->currPacketOffset += qwSize.dwLo - MIN_OBJECT_SIZE;

  00103	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00106	8b 08		 mov	 ecx, DWORD PTR [eax]
  00108	8b 55 f8	 mov	 edx, DWORD PTR _qwSize$[ebp]
  0010b	8d 44 0a e8	 lea	 eax, DWORD PTR [edx+ecx-24]
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00112	89 01		 mov	 DWORD PTR [ecx], eax

; 1256 :         }
; 1257 :     }

  00114	eb 89		 jmp	 SHORT $L10708
$L10709:

; 1258 : 
; 1259 :     return WMAERR_OK;

  00116	33 c0		 xor	 eax, eax
$L10700:

; 1260 : }

  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 08 00	 ret	 8
_WMA_GetMarkerObject@8 ENDP
WMADEC	ENDS
PUBLIC	_WMA_ParseAsfHeader@8
; Function compile flags: /Odt
;	COMDAT _WMA_ParseAsfHeader@8
WMADEC	SEGMENT
_objId$ = -28
_wmarc$ = -12
_qwSize$ = -8
_pInt$ = 8
_isFull$ = 12
_WMA_ParseAsfHeader@8 PROC NEAR				; COMDAT

; 1267 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1268 :     WMAERR wmarc;
; 1269 :     GUID objId;
; 1270 :     QWORD qwSize;
; 1271 : 
; 1272 :     if(pInt == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  0000a	75 0a		 jne	 SHORT $L10726

; 1273 :     {
; 1274 :         return WMAERR_INVALIDARG;

  0000c	b8 02 00 00 00	 mov	 eax, 2
  00011	e9 65 02 00 00	 jmp	 $L10721
$L10726:

; 1275 :     }
; 1276 : 
; 1277 :     /* initialize the some state */
; 1278 : 
; 1279 :     pInt->currPacketOffset = 0;

  00016	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00019	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1280 : 
; 1281 :     pInt->cbCDOffset      = 0;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00022	c7 81 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+152], 0

; 1282 :     pInt->cbCDTitle       = 0;

  0002c	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0002f	66 c7 82 9c 00
	00 00 00 00	 mov	 WORD PTR [edx+156], 0

; 1283 :     pInt->cbCDAuthor      = 0;

  00038	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0003b	66 c7 80 9e 00
	00 00 00 00	 mov	 WORD PTR [eax+158], 0

; 1284 :     pInt->cbCDCopyright   = 0;

  00044	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00047	66 c7 81 a0 00
	00 00 00 00	 mov	 WORD PTR [ecx+160], 0

; 1285 :     pInt->cbCDDescription = 0;

  00050	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00053	66 c7 82 a2 00
	00 00 00 00	 mov	 WORD PTR [edx+162], 0

; 1286 :     pInt->cbCDRating      = 0;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0005f	66 c7 80 a4 00
	00 00 00 00	 mov	 WORD PTR [eax+164], 0

; 1287 : 
; 1288 : #ifndef WMAAPI_NO_DRM
; 1289 : #ifdef GLOBAL_SECRET
; 1290 : 
; 1291 :     if(isFull)
; 1292 :     {
; 1293 :         SetSecret_7of7(((tWMAFileStateInternal *)pInt)->pDRM_state);
; 1294 :     }
; 1295 : 
; 1296 : #endif // GLOBAL_SECRET
; 1297 : 
; 1298 : #endif /* WMAAPI_NO_DRM */
; 1299 : 
; 1300 :     /* ASF Header Object */
; 1301 : 
; 1302 :     wmarc = WMA_LoadHeaderObject(pInt, isFull);

  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _isFull$[ebp]
  0006b	51		 push	 ecx
  0006c	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _WMA_LoadHeaderObject@8
  00075	89 45 f4	 mov	 DWORD PTR _wmarc$[ebp], eax

; 1303 :     if(wmarc != WMAERR_OK)

  00078	83 7d f4 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  0007c	74 08		 je	 SHORT $L10727

; 1304 :     {
; 1305 :         return wmarc;

  0007e	8b 45 f4	 mov	 eax, DWORD PTR _wmarc$[ebp]
  00081	e9 f5 01 00 00	 jmp	 $L10721
$L10727:

; 1306 :     }
; 1307 :     pInt->cbFirstPacketOffset = pInt->cbHeader += DATA_OBJECT_SIZE;

  00086	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00089	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0008c	83 c1 32	 add	 ecx, 50			; 00000032H
  0008f	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00092	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00095	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0009b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0009e	89 50 20	 mov	 DWORD PTR [eax+32], edx
$L10729:

; 1308 : 
; 1309 :     /* Scan Header Objects */
; 1310 : 
; 1311 :     while(pInt->currPacketOffset < pInt->cbFirstPacketOffset)

  000a1	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000a7	8b 10		 mov	 edx, DWORD PTR [eax]
  000a9	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  000ac	0f 83 c7 01 00
	00		 jae	 $L10730

; 1312 :     {
; 1313 :         wmarc = WMA_LoadObjectHeader(pInt, &objId, &qwSize);

  000b2	8d 45 f8	 lea	 eax, DWORD PTR _qwSize$[ebp]
  000b5	50		 push	 eax
  000b6	8d 4d e4	 lea	 ecx, DWORD PTR _objId$[ebp]
  000b9	51		 push	 ecx
  000ba	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _WMA_LoadObjectHeader@12
  000c3	89 45 f4	 mov	 DWORD PTR _wmarc$[ebp], eax

; 1314 :         if(wmarc != WMAERR_OK)

  000c6	83 7d f4 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  000ca	74 08		 je	 SHORT $L10731

; 1315 :         {
; 1316 :             return wmarc;

  000cc	8b 45 f4	 mov	 eax, DWORD PTR _wmarc$[ebp]
  000cf	e9 a7 01 00 00	 jmp	 $L10721
$L10731:

; 1317 :         }
; 1318 : 
; 1319 :         if(WMA_IsEqualGUID(&CLSID_CAsfPropertiesObjectV2, &objId))

  000d4	6a 10		 push	 16			; 00000010H
  000d6	8d 45 e4	 lea	 eax, DWORD PTR _objId$[ebp]
  000d9	50		 push	 eax
  000da	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_CAsfPropertiesObjectV2_XDS
  000df	e8 00 00 00 00	 call	 _memcmp
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e7	85 c0		 test	 eax, eax
  000e9	75 27		 jne	 SHORT $L10735

; 1320 :         {
; 1321 :             wmarc = WMA_LoadPropertiesObject(pInt, qwSize.dwLo,
; 1322 :                                              isFull);

  000eb	8b 4d 0c	 mov	 ecx, DWORD PTR _isFull$[ebp]
  000ee	51		 push	 ecx
  000ef	8b 55 f8	 mov	 edx, DWORD PTR _qwSize$[ebp]
  000f2	52		 push	 edx
  000f3	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _WMA_LoadPropertiesObject@12
  000fc	89 45 f4	 mov	 DWORD PTR _wmarc$[ebp], eax

; 1323 :             if(wmarc != WMAERR_OK)

  000ff	83 7d f4 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  00103	74 08		 je	 SHORT $L10736

; 1324 :             {
; 1325 :                 return wmarc;

  00105	8b 45 f4	 mov	 eax, DWORD PTR _wmarc$[ebp]
  00108	e9 6e 01 00 00	 jmp	 $L10721
$L10736:

; 1326 :             }
; 1327 :         }
; 1328 :         else if( WMA_IsEqualGUID( &CLSID_CAsfStreamPropertiesObjectV1, &objId )

  0010d	e9 62 01 00 00	 jmp	 $L10737
$L10735:

; 1329 :                  || WMA_IsEqualGUID( &CLSID_CAsfStreamPropertiesObjectV2, &objId ) )

  00112	6a 10		 push	 16			; 00000010H
  00114	8d 4d e4	 lea	 ecx, DWORD PTR _objId$[ebp]
  00117	51		 push	 ecx
  00118	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_CAsfStreamPropertiesObjectV1_XDS
  0011d	e8 00 00 00 00	 call	 _memcmp
  00122	83 c4 0c	 add	 esp, 12			; 0000000cH
  00125	85 c0		 test	 eax, eax
  00127	74 17		 je	 SHORT $L10745
  00129	6a 10		 push	 16			; 00000010H
  0012b	8d 55 e4	 lea	 edx, DWORD PTR _objId$[ebp]
  0012e	52		 push	 edx
  0012f	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_CAsfStreamPropertiesObjectV2_XDS
  00134	e8 00 00 00 00	 call	 _memcmp
  00139	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013c	85 c0		 test	 eax, eax
  0013e	75 27		 jne	 SHORT $L10744
$L10745:

; 1330 :         {
; 1331 :             wmarc = WMA_LoadAudioObject(pInt, qwSize.dwLo,
; 1332 :                                         isFull);

  00140	8b 45 0c	 mov	 eax, DWORD PTR _isFull$[ebp]
  00143	50		 push	 eax
  00144	8b 4d f8	 mov	 ecx, DWORD PTR _qwSize$[ebp]
  00147	51		 push	 ecx
  00148	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0014b	52		 push	 edx
  0014c	e8 00 00 00 00	 call	 _WMA_LoadAudioObject@12
  00151	89 45 f4	 mov	 DWORD PTR _wmarc$[ebp], eax

; 1333 :             if(wmarc != WMAERR_OK)

  00154	83 7d f4 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  00158	74 08		 je	 SHORT $L10746

; 1334 :             {
; 1335 :                 return wmarc;

  0015a	8b 45 f4	 mov	 eax, DWORD PTR _wmarc$[ebp]
  0015d	e9 19 01 00 00	 jmp	 $L10721
$L10746:

; 1336 :             }
; 1337 :         }
; 1338 :         else if(WMA_IsEqualGUID(&CLSID_CAsfContentEncryptionObject, &objId))

  00162	e9 0d 01 00 00	 jmp	 $L10737
$L10744:
  00167	6a 10		 push	 16			; 00000010H
  00169	8d 45 e4	 lea	 eax, DWORD PTR _objId$[ebp]
  0016c	50		 push	 eax
  0016d	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_CAsfContentEncryptionObject_XDS
  00172	e8 00 00 00 00	 call	 _memcmp
  00177	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017a	85 c0		 test	 eax, eax
  0017c	75 23		 jne	 SHORT $L10751

; 1339 :         {
; 1340 :             wmarc = WMA_LoadEncryptionObject(pInt, qwSize.dwLo);

  0017e	8b 4d f8	 mov	 ecx, DWORD PTR _qwSize$[ebp]
  00181	51		 push	 ecx
  00182	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00185	52		 push	 edx
  00186	e8 00 00 00 00	 call	 _WMA_LoadEncryptionObject@8
  0018b	89 45 f4	 mov	 DWORD PTR _wmarc$[ebp], eax

; 1341 :             if(wmarc != WMAERR_OK)

  0018e	83 7d f4 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  00192	74 08		 je	 SHORT $L10752

; 1342 :             {
; 1343 :                 return wmarc;

  00194	8b 45 f4	 mov	 eax, DWORD PTR _wmarc$[ebp]
  00197	e9 df 00 00 00	 jmp	 $L10721
$L10752:

; 1344 :             }
; 1345 :         }
; 1346 :         else if(WMA_IsEqualGUID(&CLSID_CAsfContentDescriptionObjectV0, &objId))

  0019c	e9 d3 00 00 00	 jmp	 $L10737
$L10751:
  001a1	6a 10		 push	 16			; 00000010H
  001a3	8d 45 e4	 lea	 eax, DWORD PTR _objId$[ebp]
  001a6	50		 push	 eax
  001a7	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_CAsfContentDescriptionObjectV0_XDS
  001ac	e8 00 00 00 00	 call	 _memcmp
  001b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b4	85 c0		 test	 eax, eax
  001b6	75 23		 jne	 SHORT $L10757

; 1347 :         {
; 1348 :             wmarc = WMA_LoadContentDescriptionObject(pInt, qwSize.dwLo);

  001b8	8b 4d f8	 mov	 ecx, DWORD PTR _qwSize$[ebp]
  001bb	51		 push	 ecx
  001bc	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  001bf	52		 push	 edx
  001c0	e8 00 00 00 00	 call	 _WMA_LoadContentDescriptionObject@8
  001c5	89 45 f4	 mov	 DWORD PTR _wmarc$[ebp], eax

; 1349 :             if(wmarc != WMAERR_OK)

  001c8	83 7d f4 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  001cc	74 08		 je	 SHORT $L10758

; 1350 :             {
; 1351 :                 return wmarc;

  001ce	8b 45 f4	 mov	 eax, DWORD PTR _wmarc$[ebp]
  001d1	e9 a5 00 00 00	 jmp	 $L10721
$L10758:

; 1352 :             }
; 1353 :         }
; 1354 :         else if(WMA_IsEqualGUID(&CLSID_CAsfExtendedContentDescObject, &objId))

  001d6	e9 99 00 00 00	 jmp	 $L10737
$L10757:
  001db	6a 10		 push	 16			; 00000010H
  001dd	8d 45 e4	 lea	 eax, DWORD PTR _objId$[ebp]
  001e0	50		 push	 eax
  001e1	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_CAsfExtendedContentDescObject_XDS
  001e6	e8 00 00 00 00	 call	 _memcmp
  001eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ee	85 c0		 test	 eax, eax
  001f0	75 3d		 jne	 SHORT $L10763

; 1355 :         {
; 1356 :             if(isFull) { // only in this case, we parse extended content desc

  001f2	83 7d 0c 00	 cmp	 DWORD PTR _isFull$[ebp], 0
  001f6	74 1d		 je	 SHORT $L10764

; 1357 :                 wmarc = WMA_LoadExtendedContentDescObject(pInt, qwSize.dwLo);

  001f8	8b 4d f8	 mov	 ecx, DWORD PTR _qwSize$[ebp]
  001fb	51		 push	 ecx
  001fc	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  001ff	52		 push	 edx
  00200	e8 00 00 00 00	 call	 _WMA_LoadExtendedContentDescObject@8
  00205	89 45 f4	 mov	 DWORD PTR _wmarc$[ebp], eax

; 1358 :                 if(wmarc != WMAERR_OK) {

  00208	83 7d f4 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  0020c	74 05		 je	 SHORT $L10765

; 1359 :                     return wmarc;

  0020e	8b 45 f4	 mov	 eax, DWORD PTR _wmarc$[ebp]
  00211	eb 68		 jmp	 SHORT $L10721
$L10765:

; 1360 :                 }
; 1361 :             }
; 1362 :             else

  00213	eb 18		 jmp	 SHORT $L10766
$L10764:

; 1363 : 			{
; 1364 : 				pInt->currPacketOffset += qwSize.dwLo - MIN_OBJECT_SIZE;

  00215	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00218	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021a	8b 55 f8	 mov	 edx, DWORD PTR _qwSize$[ebp]
  0021d	8d 44 0a e8	 lea	 eax, DWORD PTR [edx+ecx-24]
  00221	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00224	89 01		 mov	 DWORD PTR [ecx], eax

; 1365 : 				wmarc = WMAERR_OK;

  00226	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _wmarc$[ebp], 0
$L10766:

; 1366 : 			}
; 1367 :         }
; 1368 :         //else if( 0 && WMA_IsEqualGUID(&CLSID_CAsfMarkerObjectV0, &objId))
; 1369 :         //{
; 1370 :         //   wmarc = WMA_LoadMarkerObject(pInt, qwSize.dwLo);
; 1371 :         //    if(wmarc != WMAERR_OK)
; 1372 :         //    {
; 1373 :         //        return wmarc;
; 1374 :         //    }
; 1375 :         //}
; 1376 :         else if(WMA_IsEqualGUID(&CLSID_CAsfLicenseStoreObject, &objId))

  0022d	eb 45		 jmp	 SHORT $L10737
$L10763:
  0022f	6a 10		 push	 16			; 00000010H
  00231	8d 55 e4	 lea	 edx, DWORD PTR _objId$[ebp]
  00234	52		 push	 edx
  00235	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_CAsfLicenseStoreObject_XDS
  0023a	e8 00 00 00 00	 call	 _memcmp
  0023f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00242	85 c0		 test	 eax, eax
  00244	75 1d		 jne	 SHORT $L10771

; 1377 :         {
; 1378 :             wmarc = WMA_LoadLicenseStoreObject(pInt, qwSize.dwLo);

  00246	8b 45 f8	 mov	 eax, DWORD PTR _qwSize$[ebp]
  00249	50		 push	 eax
  0024a	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0024d	51		 push	 ecx
  0024e	e8 00 00 00 00	 call	 _WMA_LoadLicenseStoreObject@8
  00253	89 45 f4	 mov	 DWORD PTR _wmarc$[ebp], eax

; 1379 :             if(wmarc != WMAERR_OK)

  00256	83 7d f4 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  0025a	74 05		 je	 SHORT $L10772

; 1380 :             {
; 1381 :                 return wmarc;

  0025c	8b 45 f4	 mov	 eax, DWORD PTR _wmarc$[ebp]
  0025f	eb 1a		 jmp	 SHORT $L10721
$L10772:

; 1382 :             }
; 1383 :         }
; 1384 :         else

  00261	eb 11		 jmp	 SHORT $L10737
$L10771:

; 1385 :         {
; 1386 :             /* skip over this object */
; 1387 :             pInt->currPacketOffset += qwSize.dwLo - MIN_OBJECT_SIZE;

  00263	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00266	8b 02		 mov	 eax, DWORD PTR [edx]
  00268	8b 4d f8	 mov	 ecx, DWORD PTR _qwSize$[ebp]
  0026b	8d 54 01 e8	 lea	 edx, DWORD PTR [ecx+eax-24]
  0026f	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00272	89 10		 mov	 DWORD PTR [eax], edx
$L10737:

; 1388 :         }
; 1389 :     }

  00274	e9 28 fe ff ff	 jmp	 $L10729
$L10730:

; 1390 : 
; 1391 :     return WMAERR_OK;

  00279	33 c0		 xor	 eax, eax
$L10721:

; 1392 : }

  0027b	8b e5		 mov	 esp, ebp
  0027d	5d		 pop	 ebp
  0027e	c2 08 00	 ret	 8
_WMA_ParseAsfHeader@8 ENDP
WMADEC	ENDS
PUBLIC	_WMA_ParsePacketHeader@4
; Function compile flags: /Odt
;	COMDAT _WMA_ParsePacketHeader@4
WMADEC	SEGMENT
tv324 = -60
tv272 = -56
tv220 = -52
_dw$10872 = -48
_w$10867 = -44
_dw$10855 = -40
_w$10850 = -36
_dw$10838 = -32
_w$10833 = -28
_pParseInfoEx$ = -24
_b$ = -17
_cbActual$ = -16
_cbLocalOffset$ = -12
_cbWanted$ = -8
_pData$ = -4
_pInt$ = 8
_WMA_ParsePacketHeader@4 PROC NEAR			; COMDAT

; 1432 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 1433 :     BYTE b;
; 1434 :     PACKET_PARSE_INFO_EX *pParseInfoEx;
; 1435 : 
; 1436 :     BYTE *pData;
; 1437 :     DWORD cbWanted;
; 1438 :     DWORD cbActual;
; 1439 :     DWORD cbLocalOffset=0;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _cbLocalOffset$[ebp], 0

; 1440 : 
; 1441 :     if(pInt == NULL)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00011	75 0a		 jne	 SHORT $L10804

; 1442 :     {
; 1443 :         return WMAERR_INVALIDARG;

  00013	b8 02 00 00 00	 mov	 eax, 2
  00018	e9 b2 07 00 00	 jmp	 $L10796
$L10804:

; 1444 :     }
; 1445 : 
; 1446 :     pParseInfoEx = &pInt->ppex;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00020	05 dc 00 00 00	 add	 eax, 220		; 000000dcH
  00025	89 45 e8	 mov	 DWORD PTR _pParseInfoEx$[ebp], eax

; 1447 : 
; 1448 : //    cbWanted = 24;              /* at most */
; 1449 :     
; 1450 :     cbWanted = 1;              /* at least */

  00028	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 1

; 1451 :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1452 :                                 pInt->pCallbackContext,
; 1453 :                                 pInt->hdr_parse.currPacketOffset,
; 1454 :                                 cbWanted, &pData);

  0002f	8d 4d fc	 lea	 ecx, DWORD PTR _pData$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f8	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  00036	52		 push	 edx
  00037	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	51		 push	 ecx
  0003d	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00040	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00046	50		 push	 eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00050	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1455 : 
; 1456 : 
; 1457 :     if(cbActual != cbWanted)

  00053	8b 55 f0	 mov	 edx, DWORD PTR _cbActual$[ebp]
  00056	3b 55 f8	 cmp	 edx, DWORD PTR _cbWanted$[ebp]
  00059	74 0a		 je	 SHORT $L10806

; 1458 :     {
; 1459 :         return WMAERR_BUFFERTOOSMALL;

  0005b	b8 03 00 00 00	 mov	 eax, 3
  00060	e9 6a 07 00 00	 jmp	 $L10796
$L10806:

; 1460 :     }
; 1461 : 
; 1462 :     /* ParsePacket begins */
; 1463 : 
; 1464 :     pParseInfoEx->fParityPacket = FALSE;

  00065	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00068	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1465 :     pParseInfoEx->cbParseOffset = 0;

  0006e	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00071	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 1466 : 
; 1467 : //////////////////////////////////////////////////
; 1468 : //    b = pData[pParseInfoEx->cbParseOffset];
; 1469 : 
; 1470 :     b = pData[cbLocalOffset];

  00078	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  0007b	03 55 f4	 add	 edx, DWORD PTR _cbLocalOffset$[ebp]
  0007e	8a 02		 mov	 al, BYTE PTR [edx]
  00080	88 45 ef	 mov	 BYTE PTR _b$[ebp], al

; 1471 : ///////////////////////////////////////////////////
; 1472 :     
; 1473 :     pParseInfoEx->fEccPresent = (BOOL)( (b&0x80) == 0x80 );

  00083	0f b6 4d ef	 movzx	 ecx, BYTE PTR _b$[ebp]
  00087	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0008d	81 e9 80 00 00
	00		 sub	 ecx, 128		; 00000080H
  00093	f7 d9		 neg	 ecx
  00095	1b c9		 sbb	 ecx, ecx
  00097	41		 inc	 ecx
  00098	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  0009b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1474 :     pParseInfoEx->bECLen = 0;

  0009e	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  000a1	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1475 : 
; 1476 :     if(pParseInfoEx->fEccPresent)

  000a5	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  000a8	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000ac	0f 84 9f 00 00
	00		 je	 $L10808

; 1477 :     {
; 1478 :         if(b&0x10)

  000b2	0f b6 55 ef	 movzx	 edx, BYTE PTR _b$[ebp]
  000b6	83 e2 10	 and	 edx, 16			; 00000010H
  000b9	85 d2		 test	 edx, edx
  000bb	74 10		 je	 SHORT $L10809

; 1479 :         {
; 1480 :             pParseInfoEx->fParityPacket = TRUE;

  000bd	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  000c0	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 1481 :             return WMAERR_OK;

  000c6	33 c0		 xor	 eax, eax
  000c8	e9 02 07 00 00	 jmp	 $L10796
$L10809:

; 1482 :         }
; 1483 : 
; 1484 :         if(b&0x60)

  000cd	0f b6 4d ef	 movzx	 ecx, BYTE PTR _b$[ebp]
  000d1	83 e1 60	 and	 ecx, 96			; 00000060H
  000d4	85 c9		 test	 ecx, ecx
  000d6	74 0a		 je	 SHORT $L10810

; 1485 :         {
; 1486 :             return WMAERR_FAIL;

  000d8	b8 01 00 00 00	 mov	 eax, 1
  000dd	e9 ed 06 00 00	 jmp	 $L10796
$L10810:

; 1487 :         }
; 1488 : 
; 1489 :         pParseInfoEx->bECLen = (b&0x0f);

  000e2	0f b6 55 ef	 movzx	 edx, BYTE PTR _b$[ebp]
  000e6	83 e2 0f	 and	 edx, 15			; 0000000fH
  000e9	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  000ec	88 50 0c	 mov	 BYTE PTR [eax+12], dl

; 1490 :         if(pParseInfoEx->bECLen != 2)

  000ef	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  000f2	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  000f6	83 fa 02	 cmp	 edx, 2
  000f9	74 0a		 je	 SHORT $L10811

; 1491 :         {
; 1492 :             return WMAERR_FAIL;

  000fb	b8 01 00 00 00	 mov	 eax, 1
  00100	e9 ca 06 00 00	 jmp	 $L10796
$L10811:

; 1493 :         }
; 1494 : 
; 1495 :         pParseInfoEx->cbParseOffset = (DWORD)(1 + pParseInfoEx->bECLen);

  00105	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00108	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  0010c	83 c1 01	 add	 ecx, 1
  0010f	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00112	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1496 : //////////////////////////////////////////////////////////////////////////////
; 1497 :         cbWanted = 1;              /* at least */

  00115	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 1

; 1498 :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1499 :                                     pInt->pCallbackContext,
; 1500 :                                     pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
; 1501 :                                     cbWanted, &pData);

  0011c	8d 45 fc	 lea	 eax, DWORD PTR _pData$[ebp]
  0011f	50		 push	 eax
  00120	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00123	51		 push	 ecx
  00124	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00127	8b 02		 mov	 eax, DWORD PTR [edx]
  00129	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  0012c	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0012f	50		 push	 eax
  00130	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00133	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00139	50		 push	 eax
  0013a	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0013d	51		 push	 ecx
  0013e	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00143	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1502 : 
; 1503 : //        b = pData[pParseInfoEx->cbParseOffset];
; 1504 :           b = pData[cbLocalOffset];

  00146	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00149	03 55 f4	 add	 edx, DWORD PTR _cbLocalOffset$[ebp]
  0014c	8a 02		 mov	 al, BYTE PTR [edx]
  0014e	88 45 ef	 mov	 BYTE PTR _b$[ebp], al
$L10808:

; 1505 : 
; 1506 : //////////////////////////////////////////////////////////////////////////////
; 1507 :     }
; 1508 : 
; 1509 :     pParseInfoEx->cbPacketLenTypeOffset = pParseInfoEx->cbParseOffset;

  00151	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00154	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00157	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0015a	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 1510 : 
; 1511 :     pParseInfoEx->bPacketLenType = (b&0x60)>>5;

  0015d	0f b6 4d ef	 movzx	 ecx, BYTE PTR _b$[ebp]
  00161	83 e1 60	 and	 ecx, 96			; 00000060H
  00164	c1 f9 05	 sar	 ecx, 5
  00167	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  0016a	88 4a 0d	 mov	 BYTE PTR [edx+13], cl

; 1512 :     if(pParseInfoEx->bPacketLenType != 0
; 1513 :        && pParseInfoEx->bPacketLenType != 2)

  0016d	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00170	0f b6 48 0d	 movzx	 ecx, BYTE PTR [eax+13]
  00174	85 c9		 test	 ecx, ecx
  00176	74 16		 je	 SHORT $L10814
  00178	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  0017b	0f b6 42 0d	 movzx	 eax, BYTE PTR [edx+13]
  0017f	83 f8 02	 cmp	 eax, 2
  00182	74 0a		 je	 SHORT $L10814

; 1514 :     {
; 1515 :         return WMAERR_FAIL;

  00184	b8 01 00 00 00	 mov	 eax, 1
  00189	e9 41 06 00 00	 jmp	 $L10796
$L10814:

; 1516 :     }
; 1517 : 
; 1518 :     pParseInfoEx->bPadLenType = (b&0x18)>>3;

  0018e	0f b6 4d ef	 movzx	 ecx, BYTE PTR _b$[ebp]
  00192	83 e1 18	 and	 ecx, 24			; 00000018H
  00195	c1 f9 03	 sar	 ecx, 3
  00198	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  0019b	88 4a 14	 mov	 BYTE PTR [edx+20], cl

; 1519 :     if(pParseInfoEx->bPadLenType == 3)

  0019e	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  001a1	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  001a5	83 f9 03	 cmp	 ecx, 3
  001a8	75 0a		 jne	 SHORT $L10815

; 1520 :     {
; 1521 :         return WMAERR_FAIL;

  001aa	b8 01 00 00 00	 mov	 eax, 1
  001af	e9 1b 06 00 00	 jmp	 $L10796
$L10815:

; 1522 :     }
; 1523 : 
; 1524 :     pParseInfoEx->bSequenceLenType = (b&0x06)>>1;

  001b4	0f b6 55 ef	 movzx	 edx, BYTE PTR _b$[ebp]
  001b8	83 e2 06	 and	 edx, 6
  001bb	d1 fa		 sar	 edx, 1
  001bd	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  001c0	88 50 15	 mov	 BYTE PTR [eax+21], dl

; 1525 : 
; 1526 :     pParseInfoEx->fMultiPayloads = (BOOL)(b&0x01);

  001c3	0f b6 4d ef	 movzx	 ecx, BYTE PTR _b$[ebp]
  001c7	83 e1 01	 and	 ecx, 1
  001ca	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  001cd	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 1527 : 
; 1528 :     pParseInfoEx->cbParseOffset++;

  001d0	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  001d3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001d6	83 c1 01	 add	 ecx, 1
  001d9	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  001dc	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1529 : 
; 1530 : //////////////////////////////////////////////////////////////////////////////
; 1531 :         cbWanted = 1;              /* at least */

  001df	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 1

; 1532 :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1533 :                                     pInt->pCallbackContext,
; 1534 :                                     pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
; 1535 :                                     cbWanted, &pData);

  001e6	8d 45 fc	 lea	 eax, DWORD PTR _pData$[ebp]
  001e9	50		 push	 eax
  001ea	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  001ed	51		 push	 ecx
  001ee	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  001f1	8b 02		 mov	 eax, DWORD PTR [edx]
  001f3	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  001f6	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  001f9	50		 push	 eax
  001fa	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  001fd	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00203	50		 push	 eax
  00204	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  0020d	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1536 : 
; 1537 : //        b = pData[pParseInfoEx->cbParseOffset];
; 1538 :           b = pData[cbLocalOffset];

  00210	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00213	03 55 f4	 add	 edx, DWORD PTR _cbLocalOffset$[ebp]
  00216	8a 02		 mov	 al, BYTE PTR [edx]
  00218	88 45 ef	 mov	 BYTE PTR _b$[ebp], al

; 1539 : 
; 1540 : //////////////////////////////////////////////////////////////////////////////
; 1541 : 
; 1542 :     pParseInfoEx->bOffsetBytes = 4;

  0021b	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  0021e	c6 41 1c 04	 mov	 BYTE PTR [ecx+28], 4

; 1543 :     pParseInfoEx->bOffsetLenType = 3;

  00222	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00225	c6 42 1d 03	 mov	 BYTE PTR [edx+29], 3

; 1544 : 
; 1545 :     if(b != 0x5d)

  00229	0f b6 45 ef	 movzx	 eax, BYTE PTR _b$[ebp]
  0022d	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  00230	0f 84 82 00 00
	00		 je	 $L10818

; 1546 :     {
; 1547 :         if((b&0xc0) != 0x40)

  00236	0f b6 4d ef	 movzx	 ecx, BYTE PTR _b$[ebp]
  0023a	81 e1 c0 00 00
	00		 and	 ecx, 192		; 000000c0H
  00240	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00243	74 0a		 je	 SHORT $L10819

; 1548 :         {
; 1549 :             return WMAERR_FAIL;

  00245	b8 01 00 00 00	 mov	 eax, 1
  0024a	e9 80 05 00 00	 jmp	 $L10796
$L10819:

; 1550 :         }
; 1551 : 
; 1552 :         if((b&0x30) != 0x10)

  0024f	0f b6 55 ef	 movzx	 edx, BYTE PTR _b$[ebp]
  00253	83 e2 30	 and	 edx, 48			; 00000030H
  00256	83 fa 10	 cmp	 edx, 16			; 00000010H
  00259	74 0a		 je	 SHORT $L10820

; 1553 :         {
; 1554 :             return WMAERR_FAIL;

  0025b	b8 01 00 00 00	 mov	 eax, 1
  00260	e9 6a 05 00 00	 jmp	 $L10796
$L10820:

; 1555 :         }
; 1556 : 
; 1557 :         pParseInfoEx->bOffsetLenType = (b&0x0c)>>2;

  00265	0f b6 45 ef	 movzx	 eax, BYTE PTR _b$[ebp]
  00269	83 e0 0c	 and	 eax, 12			; 0000000cH
  0026c	c1 f8 02	 sar	 eax, 2
  0026f	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00272	88 41 1d	 mov	 BYTE PTR [ecx+29], al

; 1558 :         if(pParseInfoEx->bOffsetLenType == 0)

  00275	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00278	0f b6 42 1d	 movzx	 eax, BYTE PTR [edx+29]
  0027c	85 c0		 test	 eax, eax
  0027e	75 0a		 jne	 SHORT $L10821

; 1559 :         {
; 1560 :             return WMAERR_FAIL;

  00280	b8 01 00 00 00	 mov	 eax, 1
  00285	e9 45 05 00 00	 jmp	 $L10796
$L10821:

; 1561 :         }
; 1562 :         else if(pParseInfoEx->bOffsetLenType < 3)

  0028a	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  0028d	0f b6 51 1d	 movzx	 edx, BYTE PTR [ecx+29]
  00291	83 fa 03	 cmp	 edx, 3
  00294	7d 0c		 jge	 SHORT $L10822

; 1563 :         {
; 1564 :             pParseInfoEx->bOffsetBytes = pParseInfoEx->bOffsetLenType;

  00296	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00299	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  0029c	8a 51 1d	 mov	 dl, BYTE PTR [ecx+29]
  0029f	88 50 1c	 mov	 BYTE PTR [eax+28], dl
$L10822:

; 1565 :         }
; 1566 : 
; 1567 :         if((b&0x03) != 0x01)

  002a2	0f b6 45 ef	 movzx	 eax, BYTE PTR _b$[ebp]
  002a6	83 e0 03	 and	 eax, 3
  002a9	83 f8 01	 cmp	 eax, 1
  002ac	74 0a		 je	 SHORT $L10818

; 1568 :         {
; 1569 :             return WMAERR_FAIL;

  002ae	b8 01 00 00 00	 mov	 eax, 1
  002b3	e9 17 05 00 00	 jmp	 $L10796
$L10818:

; 1570 :         }
; 1571 :     }
; 1572 : 
; 1573 :     pParseInfoEx->cbParseOffset++;

  002b8	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  002bb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002be	83 c2 01	 add	 edx, 1
  002c1	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  002c4	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1574 : 
; 1575 : //////////////////////////////////////////////////////////////////////////////
; 1576 :     pParseInfoEx->cbPacketLenOffset = pParseInfoEx->cbParseOffset; 

  002c7	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  002ca	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  002cd	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002d0	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 1577 :     switch(pParseInfoEx->bPacketLenType)
; 1578 :     {

  002d3	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  002d6	8a 51 0d	 mov	 dl, BYTE PTR [ecx+13]
  002d9	88 55 cc	 mov	 BYTE PTR tv220[ebp], dl
  002dc	80 7d cc 01	 cmp	 BYTE PTR tv220[ebp], 1
  002e0	74 15		 je	 SHORT $L10829
  002e2	80 7d cc 02	 cmp	 BYTE PTR tv220[ebp], 2
  002e6	74 60		 je	 SHORT $L10832
  002e8	80 7d cc 03	 cmp	 BYTE PTR tv220[ebp], 3
  002ec	0f 84 ac 00 00
	00		 je	 $L10837
  002f2	e9 fa 00 00 00	 jmp	 $L10841
$L10829:

; 1579 :     case 0x01:
; 1580 :         {
; 1581 :             cbWanted =1;

  002f7	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 1

; 1582 :             cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1583 :                                         pInt->pCallbackContext,
; 1584 :                                         pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
; 1585 :                                         cbWanted, &pData);

  002fe	8d 45 fc	 lea	 eax, DWORD PTR _pData$[ebp]
  00301	50		 push	 eax
  00302	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00305	51		 push	 ecx
  00306	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00309	8b 02		 mov	 eax, DWORD PTR [edx]
  0030b	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  0030e	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00311	50		 push	 eax
  00312	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00315	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  0031b	50		 push	 eax
  0031c	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0031f	51		 push	 ecx
  00320	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00325	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1586 :             pParseInfoEx->cbExplicitPacketLength =  (DWORD)(*pData);

  00328	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  0032b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0032e	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00331	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 1587 :             pParseInfoEx->cbParseOffset++;

  00334	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00337	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0033a	83 c0 01	 add	 eax, 1
  0033d	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00340	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1588 :             break;

  00343	e9 b0 00 00 00	 jmp	 $L10826
$L10832:

; 1589 :         }
; 1590 :     case 0x02:
; 1591 :         {
; 1592 :             WORD w;
; 1593 :             cbWanted =2;

  00348	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 2

; 1594 :             cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1595 :                                         pInt->pCallbackContext,
; 1596 :                                         pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
; 1597 :                                         cbWanted, &pData);

  0034f	8d 55 fc	 lea	 edx, DWORD PTR _pData$[ebp]
  00352	52		 push	 edx
  00353	8b 45 f8	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  00356	50		 push	 eax
  00357	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0035a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0035c	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  0035f	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00362	52		 push	 edx
  00363	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00366	8b 91 c4 00 00
	00		 mov	 edx, DWORD PTR [ecx+196]
  0036c	52		 push	 edx
  0036d	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00370	50		 push	 eax
  00371	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00376	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1598 :             GetUnalignedWord(pData, w);

  00379	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  0037c	66 8b 11	 mov	 dx, WORD PTR [ecx]
  0037f	66 89 55 e4	 mov	 WORD PTR _w$10833[ebp], dx

; 1599 :             pParseInfoEx->cbExplicitPacketLength =  (DWORD)(w);

  00383	0f b7 45 e4	 movzx	 eax, WORD PTR _w$10833[ebp]
  00387	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  0038a	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 1600 :             pParseInfoEx->cbParseOffset+=2;

  0038d	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00390	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00393	83 c0 02	 add	 eax, 2
  00396	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00399	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1601 :         
; 1602 :             break;

  0039c	eb 5a		 jmp	 SHORT $L10826
$L10837:

; 1603 : 
; 1604 :         }
; 1605 :     case 0x03:
; 1606 :         {
; 1607 :             DWORD dw;
; 1608 :             cbWanted =4;

  0039e	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 4

; 1609 :             cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1610 :                                         pInt->pCallbackContext,
; 1611 :                                         pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
; 1612 :                                         cbWanted, &pData);

  003a5	8d 55 fc	 lea	 edx, DWORD PTR _pData$[ebp]
  003a8	52		 push	 edx
  003a9	8b 45 f8	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  003ac	50		 push	 eax
  003ad	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  003b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  003b2	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  003b5	03 50 04	 add	 edx, DWORD PTR [eax+4]
  003b8	52		 push	 edx
  003b9	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  003bc	8b 91 c4 00 00
	00		 mov	 edx, DWORD PTR [ecx+196]
  003c2	52		 push	 edx
  003c3	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  003c6	50		 push	 eax
  003c7	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  003cc	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1613 :             GetUnalignedDword(pData, dw);

  003cf	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  003d2	8b 11		 mov	 edx, DWORD PTR [ecx]
  003d4	89 55 e0	 mov	 DWORD PTR _dw$10838[ebp], edx

; 1614 :             pParseInfoEx->cbExplicitPacketLength =  dw;

  003d7	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  003da	8b 4d e0	 mov	 ecx, DWORD PTR _dw$10838[ebp]
  003dd	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 1615 :             pParseInfoEx->cbParseOffset+=4;

  003e0	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  003e3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003e6	83 c0 04	 add	 eax, 4
  003e9	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  003ec	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1616 :             break;

  003ef	eb 07		 jmp	 SHORT $L10826
$L10841:

; 1617 :         }
; 1618 :     default:
; 1619 :         cbWanted =0;

  003f1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 0
$L10826:

; 1620 :     }
; 1621 : 
; 1622 : /*    pParseInfoEx->cbPacketLenOffset = pParseInfoEx->cbParseOffset;
; 1623 :     pParseInfoEx->cbExplicitPacketLength = GetASFVarField(pParseInfoEx->bPacketLenType,
; 1624 :                                                           &pData[pParseInfoEx->cbParseOffset],
; 1625 :                                                           &pParseInfoEx->cbParseOffset);
; 1626 : */
; 1627 : 
; 1628 : //////////////////////////////////////////////////////////////////////////////
; 1629 : 
; 1630 : //////////////////////////////////////////////////////////////////////////////
; 1631 :     pParseInfoEx->cbSequenceOffset = pParseInfoEx->cbParseOffset;

  003f8	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  003fb	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  003fe	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00401	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 1632 :     switch(pParseInfoEx->bSequenceLenType)
; 1633 :     {

  00404	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00407	8a 42 15	 mov	 al, BYTE PTR [edx+21]
  0040a	88 45 c8	 mov	 BYTE PTR tv272[ebp], al
  0040d	80 7d c8 01	 cmp	 BYTE PTR tv272[ebp], 1
  00411	74 15		 je	 SHORT $L10846
  00413	80 7d c8 02	 cmp	 BYTE PTR tv272[ebp], 2
  00417	74 60		 je	 SHORT $L10849
  00419	80 7d c8 03	 cmp	 BYTE PTR tv272[ebp], 3
  0041d	0f 84 ac 00 00
	00		 je	 $L10854
  00423	e9 fa 00 00 00	 jmp	 $L10858
$L10846:

; 1634 :     case 0x01:
; 1635 :         {
; 1636 :             cbWanted =1;

  00428	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 1

; 1637 :             cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1638 :                                         pInt->pCallbackContext,
; 1639 :                                         pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
; 1640 :                                         cbWanted, &pData);

  0042f	8d 4d fc	 lea	 ecx, DWORD PTR _pData$[ebp]
  00432	51		 push	 ecx
  00433	8b 55 f8	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  00436	52		 push	 edx
  00437	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0043a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0043c	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  0043f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00442	51		 push	 ecx
  00443	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00446	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  0044c	51		 push	 ecx
  0044d	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00450	52		 push	 edx
  00451	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00456	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1641 :             pParseInfoEx->dwSequenceNum =  (DWORD)(*pData);

  00459	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  0045c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0045f	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00462	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 1642 :             pParseInfoEx->cbParseOffset++;

  00465	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00468	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0046b	83 c1 01	 add	 ecx, 1
  0046e	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00471	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1643 :             break;

  00474	e9 b0 00 00 00	 jmp	 $L10843
$L10849:

; 1644 :         }
; 1645 :     case 0x02:
; 1646 :         {
; 1647 :             WORD w;
; 1648 :             cbWanted =2;

  00479	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 2

; 1649 :             cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1650 :                                         pInt->pCallbackContext,
; 1651 :                                         pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
; 1652 :                                         cbWanted, &pData);

  00480	8d 45 fc	 lea	 eax, DWORD PTR _pData$[ebp]
  00483	50		 push	 eax
  00484	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00487	51		 push	 ecx
  00488	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0048b	8b 02		 mov	 eax, DWORD PTR [edx]
  0048d	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00490	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00493	50		 push	 eax
  00494	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00497	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  0049d	50		 push	 eax
  0049e	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  004a1	51		 push	 ecx
  004a2	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  004a7	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1653 :             GetUnalignedWord(pData, w);

  004aa	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  004ad	66 8b 02	 mov	 ax, WORD PTR [edx]
  004b0	66 89 45 dc	 mov	 WORD PTR _w$10850[ebp], ax

; 1654 :             pParseInfoEx->dwSequenceNum =  (DWORD)(w);

  004b4	0f b7 4d dc	 movzx	 ecx, WORD PTR _w$10850[ebp]
  004b8	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  004bb	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 1655 :             pParseInfoEx->cbParseOffset+=2;

  004be	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  004c1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004c4	83 c1 02	 add	 ecx, 2
  004c7	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  004ca	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1656 :         
; 1657 :             break;

  004cd	eb 5a		 jmp	 SHORT $L10843
$L10854:

; 1658 : 
; 1659 :         }
; 1660 :     case 0x03:
; 1661 :         {
; 1662 :             DWORD dw;
; 1663 :             cbWanted =4;

  004cf	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 4

; 1664 :             cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1665 :                                         pInt->pCallbackContext,
; 1666 :                                         pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
; 1667 :                                         cbWanted, &pData);

  004d6	8d 45 fc	 lea	 eax, DWORD PTR _pData$[ebp]
  004d9	50		 push	 eax
  004da	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  004dd	51		 push	 ecx
  004de	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  004e1	8b 02		 mov	 eax, DWORD PTR [edx]
  004e3	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  004e6	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  004e9	50		 push	 eax
  004ea	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  004ed	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  004f3	50		 push	 eax
  004f4	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  004f7	51		 push	 ecx
  004f8	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  004fd	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1668 :             GetUnalignedDword(pData, dw);

  00500	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00503	8b 02		 mov	 eax, DWORD PTR [edx]
  00505	89 45 d8	 mov	 DWORD PTR _dw$10855[ebp], eax

; 1669 :             pParseInfoEx->dwSequenceNum =  dw;

  00508	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  0050b	8b 55 d8	 mov	 edx, DWORD PTR _dw$10855[ebp]
  0050e	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 1670 :             pParseInfoEx->cbParseOffset+=4;

  00511	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00514	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00517	83 c1 04	 add	 ecx, 4
  0051a	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  0051d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1671 :             break;

  00520	eb 07		 jmp	 SHORT $L10843
$L10858:

; 1672 :         }
; 1673 :     default:
; 1674 :         cbWanted =0;

  00522	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 0
$L10843:

; 1675 :     }
; 1676 : 
; 1677 :     /*    pParseInfoEx->cbSequenceOffset = pParseInfoEx->cbParseOffset;
; 1678 :     pParseInfoEx->dwSequenceNum = GetASFVarField(pParseInfoEx->bSequenceLenType,
; 1679 :                                                  &pData[pParseInfoEx->cbParseOffset],
; 1680 :                                                  &pParseInfoEx->cbParseOffset);
; 1681 : */
; 1682 : ///////////////////////////////////////////////////////////////////////////////
; 1683 : 
; 1684 : ///////////////////////////////////////////////////////////////////////////////    
; 1685 :     pParseInfoEx->cbPadLenOffset = pParseInfoEx->cbParseOffset;

  00529	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  0052c	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  0052f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00532	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 1686 :     switch(pParseInfoEx->bPadLenType)
; 1687 :     {

  00535	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00538	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  0053b	88 4d c4	 mov	 BYTE PTR tv324[ebp], cl
  0053e	80 7d c4 01	 cmp	 BYTE PTR tv324[ebp], 1
  00542	74 15		 je	 SHORT $L10863
  00544	80 7d c4 02	 cmp	 BYTE PTR tv324[ebp], 2
  00548	74 60		 je	 SHORT $L10866
  0054a	80 7d c4 03	 cmp	 BYTE PTR tv324[ebp], 3
  0054e	0f 84 ac 00 00
	00		 je	 $L10871
  00554	e9 fa 00 00 00	 jmp	 $L10875
$L10863:

; 1688 :     case 0x01:
; 1689 :         {
; 1690 :             cbWanted =1;

  00559	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 1

; 1691 :             cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1692 :                                         pInt->pCallbackContext,
; 1693 :                                         pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
; 1694 :                                         cbWanted, &pData);

  00560	8d 55 fc	 lea	 edx, DWORD PTR _pData$[ebp]
  00563	52		 push	 edx
  00564	8b 45 f8	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  00567	50		 push	 eax
  00568	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0056b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0056d	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00570	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00573	52		 push	 edx
  00574	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00577	8b 91 c4 00 00
	00		 mov	 edx, DWORD PTR [ecx+196]
  0057d	52		 push	 edx
  0057e	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00581	50		 push	 eax
  00582	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00587	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1695 :             pParseInfoEx->cbPadding =  (DWORD)(*pData);

  0058a	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  0058d	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00590	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00593	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 1696 :             pParseInfoEx->cbParseOffset++;

  00596	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00599	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0059c	83 c2 01	 add	 edx, 1
  0059f	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  005a2	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1697 :             break;

  005a5	e9 b0 00 00 00	 jmp	 $L10860
$L10866:

; 1698 :         }
; 1699 :     case 0x02:
; 1700 :         {
; 1701 :             WORD w;
; 1702 :             cbWanted =2;

  005aa	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 2

; 1703 :             cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1704 :                                         pInt->pCallbackContext,
; 1705 :                                         pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
; 1706 :                                         cbWanted, &pData);

  005b1	8d 4d fc	 lea	 ecx, DWORD PTR _pData$[ebp]
  005b4	51		 push	 ecx
  005b5	8b 55 f8	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  005b8	52		 push	 edx
  005b9	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  005bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  005be	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  005c1	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  005c4	51		 push	 ecx
  005c5	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  005c8	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  005ce	51		 push	 ecx
  005cf	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  005d2	52		 push	 edx
  005d3	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  005d8	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1707 :             GetUnalignedWord(pData, w);

  005db	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  005de	66 8b 08	 mov	 cx, WORD PTR [eax]
  005e1	66 89 4d d4	 mov	 WORD PTR _w$10867[ebp], cx

; 1708 :             pParseInfoEx->cbPadding =  (DWORD)(w);

  005e5	0f b7 55 d4	 movzx	 edx, WORD PTR _w$10867[ebp]
  005e9	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  005ec	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 1709 :             pParseInfoEx->cbParseOffset+=2;

  005ef	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  005f2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  005f5	83 c2 02	 add	 edx, 2
  005f8	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  005fb	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1710 :         
; 1711 :             break;

  005fe	eb 5a		 jmp	 SHORT $L10860
$L10871:

; 1712 : 
; 1713 :         }
; 1714 :     case 0x03:
; 1715 :         {
; 1716 :             DWORD dw;
; 1717 :             cbWanted =4;

  00600	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 4

; 1718 :             cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1719 :                                         pInt->pCallbackContext,
; 1720 :                                         pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
; 1721 :                                         cbWanted, &pData);

  00607	8d 4d fc	 lea	 ecx, DWORD PTR _pData$[ebp]
  0060a	51		 push	 ecx
  0060b	8b 55 f8	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  0060e	52		 push	 edx
  0060f	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00612	8b 08		 mov	 ecx, DWORD PTR [eax]
  00614	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00617	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0061a	51		 push	 ecx
  0061b	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0061e	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  00624	51		 push	 ecx
  00625	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00628	52		 push	 edx
  00629	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  0062e	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1722 :             GetUnalignedDword(pData, dw);

  00631	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00634	8b 08		 mov	 ecx, DWORD PTR [eax]
  00636	89 4d d0	 mov	 DWORD PTR _dw$10872[ebp], ecx

; 1723 :             pParseInfoEx->cbPadding =  dw;

  00639	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  0063c	8b 45 d0	 mov	 eax, DWORD PTR _dw$10872[ebp]
  0063f	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 1724 :             pParseInfoEx->cbParseOffset+=4;

  00642	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00645	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00648	83 c2 04	 add	 edx, 4
  0064b	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  0064e	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1725 :             break;

  00651	eb 07		 jmp	 SHORT $L10860
$L10875:

; 1726 :         }
; 1727 :     default:
; 1728 :         cbWanted =0;

  00653	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 0
$L10860:

; 1729 :     }
; 1730 : 
; 1731 :     
; 1732 :     
; 1733 :     
; 1734 :     /*    pParseInfoEx->cbPadLenOffset = pParseInfoEx->cbParseOffset;
; 1735 :     pParseInfoEx->cbPadding = GetASFVarField(pParseInfoEx->bPadLenType,
; 1736 :                                              &pData[pParseInfoEx->cbParseOffset],
; 1737 :                                              &pParseInfoEx->cbParseOffset);
; 1738 : */
; 1739 : 
; 1740 : /////////////////////////////////////////////////////////////////////////////////
; 1741 : 
; 1742 : /////////////////////////////////////////////////////////////////////////////////
; 1743 : // Now read 6 bytes
; 1744 :     
; 1745 :     cbWanted =6;

  0065a	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 6

; 1746 :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1747 :                                 pInt->pCallbackContext,
; 1748 :                                  pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
; 1749 :                                  cbWanted, &pData);

  00661	8d 4d fc	 lea	 ecx, DWORD PTR _pData$[ebp]
  00664	51		 push	 ecx
  00665	8b 55 f8	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  00668	52		 push	 edx
  00669	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0066c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0066e	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00671	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00674	51		 push	 ecx
  00675	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00678	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  0067e	51		 push	 ecx
  0067f	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00682	52		 push	 edx
  00683	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00688	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1750 :     if(cbActual != cbWanted)

  0068b	8b 45 f0	 mov	 eax, DWORD PTR _cbActual$[ebp]
  0068e	3b 45 f8	 cmp	 eax, DWORD PTR _cbWanted$[ebp]
  00691	74 0a		 je	 SHORT $L10877

; 1751 :     {
; 1752 :         return WMAERR_BUFFERTOOSMALL;

  00693	b8 03 00 00 00	 mov	 eax, 3
  00698	e9 32 01 00 00	 jmp	 $L10796
$L10877:

; 1753 :     }
; 1754 : ////////////////////////////////////////////////////////////////////////////////////
; 1755 : 
; 1756 : 
; 1757 : /////////////////////////////////////////////////////////////////////////////////
; 1758 :     GetUnalignedDword(&pData[cbLocalOffset], pParseInfoEx->dwSCR);

  0069d	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  006a0	03 4d f4	 add	 ecx, DWORD PTR _cbLocalOffset$[ebp]
  006a3	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  006a6	8b 01		 mov	 eax, DWORD PTR [ecx]
  006a8	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 1759 : //    GetUnalignedDword(&pData[pParseInfoEx->cbParseOffset], pParseInfoEx->dwSCR);
; 1760 : 
; 1761 : /////////////////////////////////////////////////////////////////////////////////
; 1762 :     
; 1763 :     pParseInfoEx->cbParseOffset += 4;

  006ab	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  006ae	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  006b1	83 c2 04	 add	 edx, 4
  006b4	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  006b7	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1764 : 
; 1765 : 
; 1766 : //////////////////////////////////////////////////////////////////////////////////
; 1767 :     GetUnalignedWord(&pData[cbLocalOffset+4], pParseInfoEx->wDuration);

  006ba	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  006bd	03 4d f4	 add	 ecx, DWORD PTR _cbLocalOffset$[ebp]
  006c0	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  006c3	66 8b 41 04	 mov	 ax, WORD PTR [ecx+4]
  006c7	66 89 42 3c	 mov	 WORD PTR [edx+60], ax

; 1768 :     
; 1769 : //    GetUnalignedWord(&pData[pParseInfoEx->cbParseOffset], pParseInfoEx->wDuration);
; 1770 : 
; 1771 : ////////////////////////////////////////////////////////////////////////////////////
; 1772 :     
; 1773 :     pParseInfoEx->cbParseOffset += 2;

  006cb	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  006ce	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  006d1	83 c2 02	 add	 edx, 2
  006d4	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  006d7	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1774 : 
; 1775 : 
; 1776 :     /* ParsePacketEx begins */
; 1777 : 
; 1778 :     pParseInfoEx->cbPayLenTypeOffset = 0;

  006da	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  006dd	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 1779 :     pParseInfoEx->bPayLenType = 0;

  006e4	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  006e7	c6 42 3e 00	 mov	 BYTE PTR [edx+62], 0

; 1780 :     pParseInfoEx->bPayBytes = 0;

  006eb	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  006ee	c6 40 3f 00	 mov	 BYTE PTR [eax+63], 0

; 1781 :     pParseInfoEx->cPayloads = 1;

  006f2	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  006f5	c7 41 44 01 00
	00 00		 mov	 DWORD PTR [ecx+68], 1

; 1782 : 
; 1783 :     if(pParseInfoEx->fMultiPayloads)

  006fc	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  006ff	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00703	0f 84 c4 00 00
	00		 je	 $L10880

; 1784 :     {
; 1785 : //////////////////////////////////////////////////////
; 1786 :         cbWanted =1;

  00709	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 1

; 1787 :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1788 :                                     pInt->pCallbackContext,
; 1789 :                                      pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
; 1790 :                                      cbWanted, &pData);

  00710	8d 45 fc	 lea	 eax, DWORD PTR _pData$[ebp]
  00713	50		 push	 eax
  00714	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00717	51		 push	 ecx
  00718	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0071b	8b 02		 mov	 eax, DWORD PTR [edx]
  0071d	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00720	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00723	50		 push	 eax
  00724	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00727	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  0072d	50		 push	 eax
  0072e	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00731	51		 push	 ecx
  00732	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00737	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1791 :         if(cbActual != cbWanted)

  0073a	8b 55 f0	 mov	 edx, DWORD PTR _cbActual$[ebp]
  0073d	3b 55 f8	 cmp	 edx, DWORD PTR _cbWanted$[ebp]
  00740	74 0a		 je	 SHORT $L10882

; 1792 :         {
; 1793 :             return WMAERR_BUFFERTOOSMALL;

  00742	b8 03 00 00 00	 mov	 eax, 3
  00747	e9 83 00 00 00	 jmp	 $L10796
$L10882:

; 1794 :         }
; 1795 : 
; 1796 : //        b = pData[pParseInfoEx->cbParseOffset];
; 1797 :         b = pData[cbLocalOffset];

  0074c	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  0074f	03 45 f4	 add	 eax, DWORD PTR _cbLocalOffset$[ebp]
  00752	8a 08		 mov	 cl, BYTE PTR [eax]
  00754	88 4d ef	 mov	 BYTE PTR _b$[ebp], cl

; 1798 : //////////////////////////////////////////////////////
; 1799 :         pParseInfoEx->cbPayLenTypeOffset = pParseInfoEx->cbParseOffset;

  00757	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  0075a	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  0075d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00760	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 1800 : 
; 1801 :         pParseInfoEx->bPayLenType = (b&0xc0)>>6;

  00763	0f b6 55 ef	 movzx	 edx, BYTE PTR _b$[ebp]
  00767	81 e2 c0 00 00
	00		 and	 edx, 192		; 000000c0H
  0076d	c1 fa 06	 sar	 edx, 6
  00770	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00773	88 50 3e	 mov	 BYTE PTR [eax+62], dl

; 1802 :         if(pParseInfoEx->bPayLenType != 2
; 1803 :            && pParseInfoEx->bPayLenType != 1)

  00776	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00779	0f b6 51 3e	 movzx	 edx, BYTE PTR [ecx+62]
  0077d	83 fa 02	 cmp	 edx, 2
  00780	74 13		 je	 SHORT $L10883
  00782	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00785	0f b6 48 3e	 movzx	 ecx, BYTE PTR [eax+62]
  00789	83 f9 01	 cmp	 ecx, 1
  0078c	74 07		 je	 SHORT $L10883

; 1804 :         {
; 1805 :             return WMAERR_FAIL;

  0078e	b8 01 00 00 00	 mov	 eax, 1
  00793	eb 3a		 jmp	 SHORT $L10796
$L10883:

; 1806 :         }
; 1807 : 
; 1808 :         pParseInfoEx->bPayBytes = pParseInfoEx->bPayLenType;

  00795	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00798	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  0079b	8a 48 3e	 mov	 cl, BYTE PTR [eax+62]
  0079e	88 4a 3f	 mov	 BYTE PTR [edx+63], cl

; 1809 : 
; 1810 :         pParseInfoEx->cPayloads = (DWORD)(b&0x3f);

  007a1	0f b6 55 ef	 movzx	 edx, BYTE PTR _b$[ebp]
  007a5	83 e2 3f	 and	 edx, 63			; 0000003fH
  007a8	8b 45 e8	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  007ab	89 50 44	 mov	 DWORD PTR [eax+68], edx

; 1811 :         if(pParseInfoEx->cPayloads == 0)

  007ae	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  007b1	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  007b5	75 07		 jne	 SHORT $L10885

; 1812 :         {
; 1813 :             return WMAERR_FAIL;

  007b7	b8 01 00 00 00	 mov	 eax, 1
  007bc	eb 11		 jmp	 SHORT $L10796
$L10885:

; 1814 :         }
; 1815 : 
; 1816 :         pParseInfoEx->cbParseOffset++;

  007be	8b 55 e8	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  007c1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  007c4	83 c0 01	 add	 eax, 1
  007c7	8b 4d e8	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  007ca	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L10880:

; 1817 :     }
; 1818 : 
; 1819 :     return WMAERR_OK;

  007cd	33 c0		 xor	 eax, eax
$L10796:

; 1820 : }

  007cf	8b e5		 mov	 esp, ebp
  007d1	5d		 pop	 ebp
  007d2	c2 04 00	 ret	 4
_WMA_ParsePacketHeader@4 ENDP
WMADEC	ENDS
PUBLIC	_WMA_ParsePayloadHeader@4
; Function compile flags: /Odt
;	COMDAT _WMA_ParsePayloadHeader@4
WMADEC	SEGMENT
tv237 = -68
tv88 = -64
_dw$10948 = -60
_w$10943 = -56
_dw$10918 = -52
_w$10913 = -48
_cbDummy$ = -44
_cbRepDataOffset$ = -40
_pParseInfoEx$ = -36
_wTotalDataBytes$ = -32
_cbActual$ = -28
_cbParseOffset$ = -24
_dwPayloadSize$ = -20
_cbLocalOffset$ = -16
_pPayload$ = -12
_cbWanted$ = -8
_pData$ = -4
_pInt$ = 8
_WMA_ParsePayloadHeader@4 PROC NEAR			; COMDAT

; 1826 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H

; 1827 :     DWORD cbDummy;
; 1828 :     DWORD cbParseOffset;
; 1829 :     DWORD cbRepDataOffset;
; 1830 :     DWORD dwPayloadSize;
; 1831 :     PACKET_PARSE_INFO_EX *pParseInfoEx;
; 1832 :     PAYLOAD_MAP_ENTRY_EX *pPayload;
; 1833 :     DWORD cbLocalOffset=0;

  00006	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _cbLocalOffset$[ebp], 0

; 1834 : 
; 1835 :     BYTE *pData;
; 1836 :     DWORD cbWanted;
; 1837 :     DWORD cbActual;
; 1838 : //	BYTE bFrameRate = 0;
; 1839 : 	WORD wTotalDataBytes=0;

  0000d	66 c7 45 e0 00
	00		 mov	 WORD PTR _wTotalDataBytes$[ebp], 0

; 1840 : 
; 1841 :     if(pInt == NULL)

  00013	83 7d 08 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00017	75 0a		 jne	 SHORT $L10901

; 1842 :     {
; 1843 :         return WMAERR_INVALIDARG;

  00019	b8 02 00 00 00	 mov	 eax, 2
  0001e	e9 0e 05 00 00	 jmp	 $L10888
$L10901:

; 1844 :     }
; 1845 : 
; 1846 :     pParseInfoEx = &pInt->ppex;

  00023	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00026	05 dc 00 00 00	 add	 eax, 220		; 000000dcH
  0002b	89 45 dc	 mov	 DWORD PTR _pParseInfoEx$[ebp], eax

; 1847 :     pPayload = &pInt->payload;

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00031	81 c1 24 01 00
	00		 add	 ecx, 292		; 00000124H
  00037	89 4d f4	 mov	 DWORD PTR _pPayload$[ebp], ecx

; 1848 : 
; 1849 : //    cbWanted = 24;              /* at most */
; 1850 : 
; 1851 :     cbWanted = 2;              /* at least */

  0003a	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 2

; 1852 :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1853 :                                 pInt->pCallbackContext,
; 1854 :                                 pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
; 1855 :                                 cbWanted, &pData);

  00041	8d 55 fc	 lea	 edx, DWORD PTR _pData$[ebp]
  00044	52		 push	 edx
  00045	8b 45 f8	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	8b 45 dc	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00051	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00054	52		 push	 edx
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00058	8b 91 c4 00 00
	00		 mov	 edx, DWORD PTR [ecx+196]
  0005e	52		 push	 edx
  0005f	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00068	89 45 e4	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1856 :     if(cbActual != cbWanted)

  0006b	8b 4d e4	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  0006e	3b 4d f8	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  00071	74 0a		 je	 SHORT $L10903

; 1857 :     {
; 1858 :         return WMAERR_BUFFERTOOSMALL;

  00073	b8 03 00 00 00	 mov	 eax, 3
  00078	e9 b4 04 00 00	 jmp	 $L10888
$L10903:

; 1859 :     }
; 1860 : 
; 1861 :     cbParseOffset = 0;

  0007d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _cbParseOffset$[ebp], 0

; 1862 : 
; 1863 :     /* Loop in ParsePacketAndPayloads */
; 1864 : 
; 1865 :     pPayload->cbPacketOffset = (WORD)pParseInfoEx->cbParseOffset;

  00084	8b 55 f4	 mov	 edx, DWORD PTR _pPayload$[ebp]
  00087	8b 45 dc	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  0008a	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  0008e	66 89 0a	 mov	 WORD PTR [edx], cx

; 1866 : //    pPayload->bStreamId = pData[cbParseOffset];
; 1867 :     pPayload->bStreamId = (pData[cbParseOffset])&0x03; // Amit to get correct Streamid 

  00091	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00094	03 55 e8	 add	 edx, DWORD PTR _cbParseOffset$[ebp]
  00097	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0009a	83 e0 03	 and	 eax, 3
  0009d	8b 4d f4	 mov	 ecx, DWORD PTR _pPayload$[ebp]
  000a0	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 1868 :     pPayload->bObjectId = pData[cbParseOffset + 1];

  000a3	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  000a6	03 55 e8	 add	 edx, DWORD PTR _cbParseOffset$[ebp]
  000a9	8b 45 f4	 mov	 eax, DWORD PTR _pPayload$[ebp]
  000ac	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]
  000af	88 48 05	 mov	 BYTE PTR [eax+5], cl

; 1869 : 
; 1870 :     cbDummy = 0;

  000b2	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _cbDummy$[ebp], 0

; 1871 : //////////////////////////////////////////////////////////////////////////////////////
; 1872 : /*    pPayload->cbObjectOffset = GetASFVarField(pParseInfoEx->bOffsetLenType,
; 1873 :                                               &pData[cbParseOffset + 2],
; 1874 :                                               &cbDummy);
; 1875 : 
; 1876 :   */  switch(pParseInfoEx->bOffsetLenType)
; 1877 :     {

  000b9	8b 55 dc	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  000bc	8a 42 1d	 mov	 al, BYTE PTR [edx+29]
  000bf	88 45 c0	 mov	 BYTE PTR tv88[ebp], al
  000c2	80 7d c0 01	 cmp	 BYTE PTR tv88[ebp], 1
  000c6	74 15		 je	 SHORT $L10909
  000c8	80 7d c0 02	 cmp	 BYTE PTR tv88[ebp], 2
  000cc	74 55		 je	 SHORT $L10912
  000ce	80 7d c0 03	 cmp	 BYTE PTR tv88[ebp], 3
  000d2	0f 84 96 00 00
	00		 je	 $L10917
  000d8	e9 d9 00 00 00	 jmp	 $L10921
$L10909:

; 1878 :     case 0x01:
; 1879 :         {
; 1880 :             cbWanted =1;

  000dd	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 1

; 1881 :             cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1882 :                                         pInt->pCallbackContext,
; 1883 :                                         pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset +2,
; 1884 :                                         cbWanted, &pData);

  000e4	8d 4d fc	 lea	 ecx, DWORD PTR _pData$[ebp]
  000e7	51		 push	 ecx
  000e8	8b 55 f8	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  000eb	52		 push	 edx
  000ec	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  000ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f1	8b 55 dc	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  000f4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f7	8d 4c 01 02	 lea	 ecx, DWORD PTR [ecx+eax+2]
  000fb	51		 push	 ecx
  000fc	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  000ff	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00105	50		 push	 eax
  00106	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00109	51		 push	 ecx
  0010a	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  0010f	89 45 e4	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1885 :             pPayload->cbObjectOffset =  (DWORD)(*pData);

  00112	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00115	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00118	8b 4d f4	 mov	 ecx, DWORD PTR _pPayload$[ebp]
  0011b	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1886 :             break;

  0011e	e9 9a 00 00 00	 jmp	 $L10906
$L10912:

; 1887 :         }
; 1888 :     case 0x02:
; 1889 :         {
; 1890 :             WORD w;
; 1891 :             cbWanted =2;

  00123	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 2

; 1892 :             cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1893 :                                         pInt->pCallbackContext,
; 1894 :                                         pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset+2,
; 1895 :                                         cbWanted, &pData);

  0012a	8d 55 fc	 lea	 edx, DWORD PTR _pData$[ebp]
  0012d	52		 push	 edx
  0012e	8b 45 f8	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  00131	50		 push	 eax
  00132	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00135	8b 11		 mov	 edx, DWORD PTR [ecx]
  00137	8b 45 dc	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  0013a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013d	8d 54 0a 02	 lea	 edx, DWORD PTR [edx+ecx+2]
  00141	52		 push	 edx
  00142	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00145	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  0014b	51		 push	 ecx
  0014c	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0014f	52		 push	 edx
  00150	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00155	89 45 e4	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1896 :             GetUnalignedWord(pData, w);

  00158	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  0015b	66 8b 08	 mov	 cx, WORD PTR [eax]
  0015e	66 89 4d d0	 mov	 WORD PTR _w$10913[ebp], cx

; 1897 :             pPayload->cbObjectOffset =  (DWORD)(w);

  00162	0f b7 55 d0	 movzx	 edx, WORD PTR _w$10913[ebp]
  00166	8b 45 f4	 mov	 eax, DWORD PTR _pPayload$[ebp]
  00169	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1898 :         
; 1899 :             break;

  0016c	eb 4f		 jmp	 SHORT $L10906
$L10917:

; 1900 : 
; 1901 :         }
; 1902 :     case 0x03:
; 1903 :         {
; 1904 :             DWORD dw;
; 1905 :             cbWanted =4;

  0016e	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 4

; 1906 :             cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1907 :                                         pInt->pCallbackContext,
; 1908 :                                         pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset +2,
; 1909 :                                         cbWanted, &pData);

  00175	8d 4d fc	 lea	 ecx, DWORD PTR _pData$[ebp]
  00178	51		 push	 ecx
  00179	8b 55 f8	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  0017c	52		 push	 edx
  0017d	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00180	8b 08		 mov	 ecx, DWORD PTR [eax]
  00182	8b 55 dc	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00185	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00188	8d 4c 01 02	 lea	 ecx, DWORD PTR [ecx+eax+2]
  0018c	51		 push	 ecx
  0018d	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00190	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00196	50		 push	 eax
  00197	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0019a	51		 push	 ecx
  0019b	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  001a0	89 45 e4	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1910 :             GetUnalignedDword(pData, dw);

  001a3	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  001a6	8b 02		 mov	 eax, DWORD PTR [edx]
  001a8	89 45 cc	 mov	 DWORD PTR _dw$10918[ebp], eax

; 1911 :             pPayload->cbObjectOffset =  dw;

  001ab	8b 4d f4	 mov	 ecx, DWORD PTR _pPayload$[ebp]
  001ae	8b 55 cc	 mov	 edx, DWORD PTR _dw$10918[ebp]
  001b1	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1912 :             break;

  001b4	eb 07		 jmp	 SHORT $L10906
$L10921:

; 1913 :         }
; 1914 :     default:
; 1915 :         cbWanted =0;

  001b6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 0
$L10906:

; 1916 :     }
; 1917 : 
; 1918 : //////////////////////////////////////////////////////////////////////////////////////
; 1919 : 
; 1920 :     cbRepDataOffset = cbParseOffset + 2 + pParseInfoEx->bOffsetBytes;

  001bd	8b 45 dc	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  001c0	0f b6 48 1c	 movzx	 ecx, BYTE PTR [eax+28]
  001c4	8b 55 e8	 mov	 edx, DWORD PTR _cbParseOffset$[ebp]
  001c7	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  001cb	89 45 d8	 mov	 DWORD PTR _cbRepDataOffset$[ebp], eax

; 1921 : 
; 1922 : ///////////////////////////////////////////////////////////////////////////////////////
; 1923 : 
; 1924 :     cbWanted =1;

  001ce	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 1

; 1925 :     cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1926 :                                 pInt->pCallbackContext,
; 1927 :                                 pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset,
; 1928 :                                 cbWanted, &pData);

  001d5	8d 4d fc	 lea	 ecx, DWORD PTR _pData$[ebp]
  001d8	51		 push	 ecx
  001d9	8b 55 f8	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  001dc	52		 push	 edx
  001dd	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  001e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e2	8b 55 dc	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  001e5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001e8	03 4d d8	 add	 ecx, DWORD PTR _cbRepDataOffset$[ebp]
  001eb	51		 push	 ecx
  001ec	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  001ef	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  001f5	51		 push	 ecx
  001f6	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  001f9	52		 push	 edx
  001fa	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  001ff	89 45 e4	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1929 : 
; 1930 : //    pPayload->cbRepData = pData[cbRepDataOffset];
; 1931 :     pPayload->cbRepData = pData[cbLocalOffset];

  00202	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00205	03 45 f0	 add	 eax, DWORD PTR _cbLocalOffset$[ebp]
  00208	8b 4d f4	 mov	 ecx, DWORD PTR _pPayload$[ebp]
  0020b	8a 10		 mov	 dl, BYTE PTR [eax]
  0020d	88 51 14	 mov	 BYTE PTR [ecx+20], dl

; 1932 : 
; 1933 : ///////////////////////////////////////////////////////////////////////////////////////
; 1934 :     pPayload->msObjectPres = 0xffffffff;

  00210	8b 45 f4	 mov	 eax, DWORD PTR _pPayload$[ebp]
  00213	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+16], -1

; 1935 : 
; 1936 :     if(pPayload->cbRepData == 1)

  0021a	8b 4d f4	 mov	 ecx, DWORD PTR _pPayload$[ebp]
  0021d	0f b6 51 14	 movzx	 edx, BYTE PTR [ecx+20]
  00221	83 fa 01	 cmp	 edx, 1
  00224	0f 85 8d 00 00
	00		 jne	 $L10923

; 1937 :     {
; 1938 :         pPayload->msObjectPres = pPayload->cbObjectOffset;

  0022a	8b 45 f4	 mov	 eax, DWORD PTR _pPayload$[ebp]
  0022d	8b 4d f4	 mov	 ecx, DWORD PTR _pPayload$[ebp]
  00230	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00233	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 1939 :         pPayload->cbObjectOffset = 0;

  00236	8b 45 f4	 mov	 eax, DWORD PTR _pPayload$[ebp]
  00239	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1940 :         pPayload->cbObjectSize = 0;

  00240	8b 4d f4	 mov	 ecx, DWORD PTR _pPayload$[ebp]
  00243	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 1941 :         pPayload->bIsCompressedPayload =1;

  0024a	8b 55 f4	 mov	 edx, DWORD PTR _pPayload$[ebp]
  0024d	c6 42 1d 01	 mov	 BYTE PTR [edx+29], 1

; 1942 : ///////////////////////////////////////////////////////////////////////////////////////
; 1943 : 
; 1944 :         cbWanted =3;

  00251	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 3

; 1945 :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1946 :                                     pInt->pCallbackContext,
; 1947 :                                 pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset +1,
; 1948 :                                 cbWanted, &pData);

  00258	8d 45 fc	 lea	 eax, DWORD PTR _pData$[ebp]
  0025b	50		 push	 eax
  0025c	8b 4d f8	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  0025f	51		 push	 ecx
  00260	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00263	8b 02		 mov	 eax, DWORD PTR [edx]
  00265	8b 4d dc	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00268	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0026b	8b 55 d8	 mov	 edx, DWORD PTR _cbRepDataOffset$[ebp]
  0026e	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  00272	50		 push	 eax
  00273	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00276	8b 91 c4 00 00
	00		 mov	 edx, DWORD PTR [ecx+196]
  0027c	52		 push	 edx
  0027d	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00280	50		 push	 eax
  00281	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00286	89 45 e4	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1949 : 
; 1950 : /********************Amit to take care of compressed payload**************************/
; 1951 : //       if(pData[cbRepDataOffset +1] >0)
; 1952 :        if(pData[cbLocalOffset] >0)

  00289	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  0028c	03 4d f0	 add	 ecx, DWORD PTR _cbLocalOffset$[ebp]
  0028f	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00292	85 d2		 test	 edx, edx
  00294	7e 1f		 jle	 SHORT $L10925

; 1953 : //			bFrameRate = 1000/pData[cbRepDataOffset +1];
; 1954 : 		
; 1955 : 
; 1956 : ///////////////////////////////////////////////////////////////////////////////////////
; 1957 : 		if( pParseInfoEx->fMultiPayloads)

  00296	8b 45 dc	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00299	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0029d	74 10		 je	 SHORT $L10926

; 1958 : 		{
; 1959 : 			//GetUnalignedWord( &pData[ cbRepDataOffset + 2 ],wTotalDataBytes ); // changed by amit
; 1960 :             GetUnalignedWord( &pData[ cbLocalOffset + 1 ],wTotalDataBytes );

  0029f	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  002a2	03 4d f0	 add	 ecx, DWORD PTR _cbLocalOffset$[ebp]
  002a5	66 8b 51 01	 mov	 dx, WORD PTR [ecx+1]
  002a9	66 89 55 e0	 mov	 WORD PTR _wTotalDataBytes$[ebp], dx

; 1961 : 		}
; 1962 : 		else

  002ad	eb 06		 jmp	 SHORT $L10925
$L10926:

; 1963 : 		{
; 1964 : 			wTotalDataBytes = 0; //pData[ cbRepDataOffset + 2 ];

  002af	66 c7 45 e0 00
	00		 mov	 WORD PTR _wTotalDataBytes$[ebp], 0
$L10925:

; 1965 : 		}
; 1966 : /********************End of Amit to take care of compressed payload**************************/
; 1967 :     }
; 1968 :     else if(pPayload->cbRepData >= 8)

  002b5	eb 68		 jmp	 SHORT $L10929
$L10923:
  002b7	8b 45 f4	 mov	 eax, DWORD PTR _pPayload$[ebp]
  002ba	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  002be	83 f9 08	 cmp	 ecx, 8
  002c1	7c 5c		 jl	 SHORT $L10929

; 1969 :     {
; 1970 : ///////////////////////////////////////////////////////////////////////////////////////
; 1971 : 
; 1972 :         cbWanted =8;

  002c3	c7 45 f8 08 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 8

; 1973 :         cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1974 :                                     pInt->pCallbackContext,
; 1975 :                                 pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset +1,
; 1976 :                                 cbWanted, &pData);

  002ca	8d 55 fc	 lea	 edx, DWORD PTR _pData$[ebp]
  002cd	52		 push	 edx
  002ce	8b 45 f8	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  002d1	50		 push	 eax
  002d2	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  002d5	8b 11		 mov	 edx, DWORD PTR [ecx]
  002d7	8b 45 dc	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  002da	03 50 04	 add	 edx, DWORD PTR [eax+4]
  002dd	8b 4d d8	 mov	 ecx, DWORD PTR _cbRepDataOffset$[ebp]
  002e0	8d 54 0a 01	 lea	 edx, DWORD PTR [edx+ecx+1]
  002e4	52		 push	 edx
  002e5	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  002e8	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  002ee	51		 push	 ecx
  002ef	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  002f2	52		 push	 edx
  002f3	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  002f8	89 45 e4	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1977 :         GetUnalignedDword(&pData[cbLocalOffset],
; 1978 :                           pPayload->cbObjectSize);

  002fb	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  002fe	03 45 f0	 add	 eax, DWORD PTR _cbLocalOffset$[ebp]
  00301	8b 4d f4	 mov	 ecx, DWORD PTR _pPayload$[ebp]
  00304	8b 10		 mov	 edx, DWORD PTR [eax]
  00306	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 1979 :         GetUnalignedDword(&pData[cbLocalOffset+ 4],
; 1980 :                           pPayload->msObjectPres);

  00309	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  0030c	03 45 f0	 add	 eax, DWORD PTR _cbLocalOffset$[ebp]
  0030f	8b 4d f4	 mov	 ecx, DWORD PTR _pPayload$[ebp]
  00312	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00315	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 1981 : 
; 1982 :         
; 1983 : /*        GetUnalignedDword(&pData[cbRepDataOffset + 1],
; 1984 :                           pPayload->cbObjectSize);
; 1985 :         GetUnalignedDword(&pData[cbRepDataOffset + 1 + 4],
; 1986 :                           pPayload->msObjectPres);
; 1987 : */
; 1988 : //////////////////////////////////////////////////////////////////////////////////////////        
; 1989 :         pPayload->bIsCompressedPayload =0;

  00318	8b 45 f4	 mov	 eax, DWORD PTR _pPayload$[ebp]
  0031b	c6 40 1d 00	 mov	 BYTE PTR [eax+29], 0
$L10929:

; 1990 :     }
; 1991 : 
; 1992 :     pPayload->cbTotalSize = 1 + 1 + pParseInfoEx->bOffsetBytes + 1 + pPayload->cbRepData;

  0031f	8b 4d dc	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00322	0f b6 51 1c	 movzx	 edx, BYTE PTR [ecx+28]
  00326	8b 45 f4	 mov	 eax, DWORD PTR _pPayload$[ebp]
  00329	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  0032d	8d 54 0a 03	 lea	 edx, DWORD PTR [edx+ecx+3]
  00331	8b 45 f4	 mov	 eax, DWORD PTR _pPayload$[ebp]
  00334	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 1993 : 
; 1994 :     if(pParseInfoEx->fMultiPayloads)

  00338	8b 4d dc	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  0033b	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  0033f	0f 84 13 01 00
	00		 je	 $L10934

; 1995 :     {
; 1996 :         cbDummy = 0;

  00345	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _cbDummy$[ebp], 0

; 1997 : 
; 1998 : //////////////////////////////////////////////////////////////////////////////////////
; 1999 :       /*  dwPayloadSize = GetASFVarField(pParseInfoEx->bPayLenType,
; 2000 :                                        &pData[cbParseOffset + pPayload->cbTotalSize],
; 2001 :                                        &cbDummy);
; 2002 : */
; 2003 :         switch(pParseInfoEx->bPayLenType)
; 2004 :         {

  0034c	8b 55 dc	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  0034f	8a 42 3e	 mov	 al, BYTE PTR [edx+62]
  00352	88 45 bc	 mov	 BYTE PTR tv237[ebp], al
  00355	80 7d bc 01	 cmp	 BYTE PTR tv237[ebp], 1
  00359	74 15		 je	 SHORT $L10939
  0035b	80 7d bc 02	 cmp	 BYTE PTR tv237[ebp], 2
  0035f	74 57		 je	 SHORT $L10942
  00361	80 7d bc 03	 cmp	 BYTE PTR tv237[ebp], 3
  00365	0f 84 9a 00 00
	00		 je	 $L10947
  0036b	e9 df 00 00 00	 jmp	 $L10951
$L10939:

; 2005 :         case 0x01:
; 2006 :             {
; 2007 :                 cbWanted =1;

  00370	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 1

; 2008 :                 cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 2009 :                                             pInt->pCallbackContext,
; 2010 :                                             pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset +pPayload->cbTotalSize,
; 2011 :                                             cbWanted, &pData);

  00377	8d 4d fc	 lea	 ecx, DWORD PTR _pData$[ebp]
  0037a	51		 push	 ecx
  0037b	8b 55 f8	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  0037e	52		 push	 edx
  0037f	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00382	8b 08		 mov	 ecx, DWORD PTR [eax]
  00384	8b 55 dc	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00387	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0038a	8b 45 f4	 mov	 eax, DWORD PTR _pPayload$[ebp]
  0038d	0f b7 50 02	 movzx	 edx, WORD PTR [eax+2]
  00391	03 ca		 add	 ecx, edx
  00393	51		 push	 ecx
  00394	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00397	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  0039d	51		 push	 ecx
  0039e	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  003a1	52		 push	 edx
  003a2	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  003a7	89 45 e4	 mov	 DWORD PTR _cbActual$[ebp], eax

; 2012 :                 dwPayloadSize =  (DWORD)(*pData);

  003aa	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  003ad	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  003b0	89 4d ec	 mov	 DWORD PTR _dwPayloadSize$[ebp], ecx

; 2013 :                 break;

  003b3	e9 9e 00 00 00	 jmp	 $L10936
$L10942:

; 2014 :             }
; 2015 :         case 0x02:
; 2016 :             {
; 2017 :                 WORD w;
; 2018 :                 cbWanted =2;

  003b8	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 2

; 2019 :                 cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 2020 :                                             pInt->pCallbackContext,
; 2021 :                                             pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset+pPayload->cbTotalSize,
; 2022 :                                             cbWanted, &pData);

  003bf	8d 55 fc	 lea	 edx, DWORD PTR _pData$[ebp]
  003c2	52		 push	 edx
  003c3	8b 45 f8	 mov	 eax, DWORD PTR _cbWanted$[ebp]
  003c6	50		 push	 eax
  003c7	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  003ca	8b 11		 mov	 edx, DWORD PTR [ecx]
  003cc	8b 45 dc	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  003cf	03 50 04	 add	 edx, DWORD PTR [eax+4]
  003d2	8b 4d f4	 mov	 ecx, DWORD PTR _pPayload$[ebp]
  003d5	0f b7 41 02	 movzx	 eax, WORD PTR [ecx+2]
  003d9	03 d0		 add	 edx, eax
  003db	52		 push	 edx
  003dc	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  003df	8b 91 c4 00 00
	00		 mov	 edx, DWORD PTR [ecx+196]
  003e5	52		 push	 edx
  003e6	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  003e9	50		 push	 eax
  003ea	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  003ef	89 45 e4	 mov	 DWORD PTR _cbActual$[ebp], eax

; 2023 :                 GetUnalignedWord(pData, w);

  003f2	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  003f5	66 8b 11	 mov	 dx, WORD PTR [ecx]
  003f8	66 89 55 c8	 mov	 WORD PTR _w$10943[ebp], dx

; 2024 :                 dwPayloadSize =  (DWORD)(w);

  003fc	0f b7 45 c8	 movzx	 eax, WORD PTR _w$10943[ebp]
  00400	89 45 ec	 mov	 DWORD PTR _dwPayloadSize$[ebp], eax

; 2025 :         
; 2026 :                 break;

  00403	eb 51		 jmp	 SHORT $L10936
$L10947:

; 2027 : 
; 2028 :             }
; 2029 :         case 0x03:
; 2030 :             {
; 2031 :                 DWORD dw;
; 2032 :                 cbWanted =4;

  00405	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 4

; 2033 :                 cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 2034 :                                             pInt->pCallbackContext,
; 2035 :                                             pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset + pPayload->cbTotalSize,
; 2036 :                                             cbWanted, &pData);

  0040c	8d 4d fc	 lea	 ecx, DWORD PTR _pData$[ebp]
  0040f	51		 push	 ecx
  00410	8b 55 f8	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  00413	52		 push	 edx
  00414	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00417	8b 08		 mov	 ecx, DWORD PTR [eax]
  00419	8b 55 dc	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  0041c	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0041f	8b 45 f4	 mov	 eax, DWORD PTR _pPayload$[ebp]
  00422	0f b7 50 02	 movzx	 edx, WORD PTR [eax+2]
  00426	03 ca		 add	 ecx, edx
  00428	51		 push	 ecx
  00429	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0042c	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  00432	51		 push	 ecx
  00433	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00436	52		 push	 edx
  00437	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  0043c	89 45 e4	 mov	 DWORD PTR _cbActual$[ebp], eax

; 2037 :                 GetUnalignedDword(pData, dw);

  0043f	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00442	8b 08		 mov	 ecx, DWORD PTR [eax]
  00444	89 4d c4	 mov	 DWORD PTR _dw$10948[ebp], ecx

; 2038 :                 dwPayloadSize =  dw;

  00447	8b 55 c4	 mov	 edx, DWORD PTR _dw$10948[ebp]
  0044a	89 55 ec	 mov	 DWORD PTR _dwPayloadSize$[ebp], edx

; 2039 :                 break;

  0044d	eb 07		 jmp	 SHORT $L10936
$L10951:

; 2040 :             }
; 2041 :         default:
; 2042 :             cbWanted =0;

  0044f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 0
$L10936:

; 2043 :         }
; 2044 : 
; 2045 : //////////////////////////////////////////////////////////////////////////////////////
; 2046 : 
; 2047 :     
; 2048 :     }
; 2049 :     else if(pParseInfoEx->cbExplicitPacketLength > 0)

  00456	eb 47		 jmp	 SHORT $L10952
$L10934:
  00458	8b 45 dc	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  0045b	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0045f	76 20		 jbe	 SHORT $L10953

; 2050 :     {
; 2051 :         dwPayloadSize = pParseInfoEx->cbExplicitPacketLength
; 2052 :                       - pParseInfoEx->cbParseOffset
; 2053 :                       - pPayload->cbTotalSize
; 2054 :                       - pParseInfoEx->cbPadding;

  00461	8b 4d dc	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00464	8b 55 dc	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00467	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0046a	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  0046d	8b 4d f4	 mov	 ecx, DWORD PTR _pPayload$[ebp]
  00470	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00474	2b c2		 sub	 eax, edx
  00476	8b 4d dc	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  00479	2b 41 34	 sub	 eax, DWORD PTR [ecx+52]
  0047c	89 45 ec	 mov	 DWORD PTR _dwPayloadSize$[ebp], eax

; 2055 :     }
; 2056 :     else

  0047f	eb 1e		 jmp	 SHORT $L10952
$L10953:

; 2057 :     {
; 2058 :         dwPayloadSize = pInt->hdr_parse.cbPacketSize
; 2059 :                       - pParseInfoEx->cbParseOffset
; 2060 :                       - pPayload->cbTotalSize
; 2061 :                       - pParseInfoEx->cbPadding;

  00481	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00484	8b 45 dc	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00487	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0048a	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  0048d	8b 55 f4	 mov	 edx, DWORD PTR _pPayload$[ebp]
  00490	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00494	2b c8		 sub	 ecx, eax
  00496	8b 55 dc	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  00499	2b 4a 34	 sub	 ecx, DWORD PTR [edx+52]
  0049c	89 4d ec	 mov	 DWORD PTR _dwPayloadSize$[ebp], ecx
$L10952:

; 2062 :     }
; 2063 :     if (0 == wTotalDataBytes)

  0049f	0f b7 45 e0	 movzx	 eax, WORD PTR _wTotalDataBytes$[ebp]
  004a3	85 c0		 test	 eax, eax
  004a5	75 08		 jne	 SHORT $L10955

; 2064 :         wTotalDataBytes = (WORD) dwPayloadSize;

  004a7	66 8b 4d ec	 mov	 cx, WORD PTR _dwPayloadSize$[ebp]
  004ab	66 89 4d e0	 mov	 WORD PTR _wTotalDataBytes$[ebp], cx
$L10955:

; 2065 : 
; 2066 :     pPayload->cbPayloadSize = (WORD)dwPayloadSize;

  004af	8b 55 f4	 mov	 edx, DWORD PTR _pPayload$[ebp]
  004b2	66 8b 45 ec	 mov	 ax, WORD PTR _dwPayloadSize$[ebp]
  004b6	66 89 42 16	 mov	 WORD PTR [edx+22], ax

; 2067 : 
; 2068 :     pPayload->cbTotalSize += pParseInfoEx->bPayBytes
; 2069 :                           + (WORD)pPayload->cbPayloadSize;

  004ba	8b 4d dc	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  004bd	0f b6 51 3f	 movzx	 edx, BYTE PTR [ecx+63]
  004c1	8b 45 f4	 mov	 eax, DWORD PTR _pPayload$[ebp]
  004c4	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  004c8	03 d1		 add	 edx, ecx
  004ca	8b 45 f4	 mov	 eax, DWORD PTR _pPayload$[ebp]
  004cd	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  004d1	03 ca		 add	 ecx, edx
  004d3	8b 55 f4	 mov	 edx, DWORD PTR _pPayload$[ebp]
  004d6	66 89 4a 02	 mov	 WORD PTR [edx+2], cx

; 2070 : 
; 2071 :  	pPayload->wTotalDataBytes = wTotalDataBytes; // Amit

  004da	8b 45 f4	 mov	 eax, DWORD PTR _pPayload$[ebp]
  004dd	66 8b 4d e0	 mov	 cx, WORD PTR _wTotalDataBytes$[ebp]
  004e1	66 89 48 1a	 mov	 WORD PTR [eax+26], cx

; 2072 : 
; 2073 : /*    if( 1 == pPayload->cbRepData )
; 2074 :     {
; 2075 :         pPayload->cbPayloadSize--;
; 2076 :     }
; 2077 : */
; 2078 :     pParseInfoEx->cbParseOffset += pPayload->cbTotalSize;

  004e5	8b 55 f4	 mov	 edx, DWORD PTR _pPayload$[ebp]
  004e8	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  004ec	8b 4d dc	 mov	 ecx, DWORD PTR _pParseInfoEx$[ebp]
  004ef	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  004f2	8b 55 dc	 mov	 edx, DWORD PTR _pParseInfoEx$[ebp]
  004f5	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 2079 : 
; 2080 :     if(pParseInfoEx->cbParseOffset > pInt->hdr_parse.cbPacketSize
; 2081 :        || (pParseInfoEx->cbParseOffset == pInt->hdr_parse.cbPacketSize
; 2082 :            && pInt->iPayload < pParseInfoEx->cPayloads - 1))

  004f8	8b 45 dc	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  004fb	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  004fe	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00501	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00504	77 22		 ja	 SHORT $L10960
  00506	8b 45 dc	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00509	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0050c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0050f	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00512	75 1b		 jne	 SHORT $L10959
  00514	8b 45 dc	 mov	 eax, DWORD PTR _pParseInfoEx$[ebp]
  00517	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0051a	83 e9 01	 sub	 ecx, 1
  0051d	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00520	39 8a 48 01 00
	00		 cmp	 DWORD PTR [edx+328], ecx
  00526	73 07		 jae	 SHORT $L10959
$L10960:

; 2083 :     {
; 2084 :         return WMAERR_CORRUPTDATA;

  00528	b8 06 00 00 00	 mov	 eax, 6
  0052d	eb 02		 jmp	 SHORT $L10888
$L10959:

; 2085 :     }
; 2086 : 
; 2087 :     return WMAERR_OK;

  0052f	33 c0		 xor	 eax, eax
$L10888:

; 2088 : }

  00531	8b e5		 mov	 esp, ebp
  00533	5d		 pop	 ebp
  00534	c2 04 00	 ret	 4
_WMA_ParsePayloadHeader@4 ENDP
WMADEC	ENDS
END
