; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\lspmsvq.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxLspMSVQ@36
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxDecLspMSVQ@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxInitMSVQ@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxFreeMSVQ@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CalcWeightedMSE@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	__real@457a0000
PUBLIC	__real@400921fb54524550
PUBLIC	__real@3f800000
PUBLIC	__real@007fffe1
PUBLIC	__real@7f7fffee
PUBLIC	__real@3cb81301
PUBLIC	__real@43340000
PUBLIC	__real@41300000
PUBLIC	__real@4066800000000000
PUBLIC	__real@3e800000
PUBLIC	__real@40400000
PUBLIC	__real@3c23d70a
PUBLIC	_VoxLspMSVQ@36
EXTRN	__fltused:NEAR
EXTRN	_cos:NEAR
EXTRN	_sin:NEAR
EXTRN	_sqrt:NEAR
;	COMDAT __real@457a0000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\lspmsvq.c
CONST	SEGMENT
__real@457a0000 DD 0457a0000r			; 4000
CONST	ENDS
;	COMDAT __real@400921fb54524550
CONST	SEGMENT
__real@400921fb54524550 DQ 0400921fb54524550r	; 3.14159
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@007fffe1
CONST	SEGMENT
__real@007fffe1 DD 0007fffe1r			; 1.17549e-038
CONST	ENDS
;	COMDAT __real@7f7fffee
CONST	SEGMENT
__real@7f7fffee DD 07f7fffeer			; 3.40282e+038
CONST	ENDS
;	COMDAT __real@3cb81301
CONST	SEGMENT
__real@3cb81301 DD 03cb81301r			; 0.02247
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@41300000
CONST	SEGMENT
__real@41300000 DD 041300000r			; 11
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxLspMSVQ@36
_TEXT	SEGMENT
tv392 = -184
tv716 = -180
tv684 = -176
tv669 = -172
_newcand$1102 = -168
_residue$ = -164
_j$ = -160
_c$ = -156
_entry$ = -152
_r$ = -148
_d$ = -144
_newIndex$ = -140
_ncPrev$ = -136
_tempfloat$ = -132
_dMin$ = -128
_tempshort$ = -124
_cand$ = -120
_k$ = -116
_nextIndex$ = -112
_bestIndex$ = -108
_hw$ = -104
_candBAD$ = -96
_dm_sq$ = -92
_tmp$ = -88
_index$ = -84
_cs$ = -80
_s$ = -76
_u$ = -72
_weight$ = -68
_sn$ = -28
_i$ = -24
_uHat$ = -20
_dhw$ = -16
_newresidue$ = -8
_tbl$ = -4
_vectin$ = 8
_lpcin$ = 12
_cbNdx$ = 16
_myMSVQ_mblk$ = 20
_numStages$ = 24
_numCand$ = 28
_dim$ = 32
_tableSize$ = 36
_cb$ = 40
_VoxLspMSVQ@36 PROC NEAR				; COMDAT

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	56		 push	 esi

; 55   :    short    c, s, entry, ncPrev,  i, r;
; 56   :    float       d;
; 57   :    short    *newIndex=myMSVQ_mblk->newIndex,*tempshort;

  0000a	8b 45 14	 mov	 eax, DWORD PTR _myMSVQ_mblk$[ebp]
  0000d	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00010	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _newIndex$[ebp], ecx

; 58   :    float    *tempfloat,*u;
; 59   :    float	*newresidue = myMSVQ_mblk->newresidue; 

  00016	8b 55 14	 mov	 edx, DWORD PTR _myMSVQ_mblk$[ebp]
  00019	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001c	89 45 f8	 mov	 DWORD PTR _newresidue$[ebp], eax

; 60   :    float	*dMin = myMSVQ_mblk->dMin;

  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _myMSVQ_mblk$[ebp]
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	89 55 80	 mov	 DWORD PTR _dMin$[ebp], edx

; 61   :    float	*residue = myMSVQ_mblk->cand;

  00027	8b 45 14	 mov	 eax, DWORD PTR _myMSVQ_mblk$[ebp]
  0002a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002d	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _residue$[ebp], ecx

; 62   :    float	*cand = myMSVQ_mblk->cand;

  00033	8b 55 14	 mov	 edx, DWORD PTR _myMSVQ_mblk$[ebp]
  00036	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00039	89 45 88	 mov	 DWORD PTR _cand$[ebp], eax

; 63   :    short	*index = myMSVQ_mblk->index;

  0003c	8b 4d 14	 mov	 ecx, DWORD PTR _myMSVQ_mblk$[ebp]
  0003f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00042	89 55 ac	 mov	 DWORD PTR _index$[ebp], edx

; 64   :    short	*nextIndex = myMSVQ_mblk->nextIndex;

  00045	8b 45 14	 mov	 eax, DWORD PTR _myMSVQ_mblk$[ebp]
  00048	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0004b	89 4d 90	 mov	 DWORD PTR _nextIndex$[ebp], ecx

; 65   :    float	*uHat;
; 66   :    float	*tbl;
; 67   :    float	weight[LPC_ORDER];
; 68   :    short	bestIndex, candBAD;   
; 69   :    MTHT_complex      hw, dhw;
; 70   :    float             dm_sq, cs, sn, tmp;
; 71   :    int               k,j;
; 72   : 
; 73   : 
; 74   :    for (r=0;r<dim;r++)  

  0004e	66 c7 85 6c ff
	ff ff 00 00	 mov	 WORD PTR _r$[ebp], 0
  00057	eb 12		 jmp	 SHORT $L1044
$L1045:
  00059	66 8b 95 6c ff
	ff ff		 mov	 dx, WORD PTR _r$[ebp]
  00060	66 83 c2 01	 add	 dx, 1
  00064	66 89 95 6c ff
	ff ff		 mov	 WORD PTR _r$[ebp], dx
$L1044:
  0006b	0f bf 85 6c ff
	ff ff		 movsx	 eax, WORD PTR _r$[ebp]
  00072	3b 45 20	 cmp	 eax, DWORD PTR _dim$[ebp]
  00075	7d 25		 jge	 SHORT $L1046

; 75   :  	  residue[r] =  vectin[r]/4000.0F;

  00077	0f bf 8d 6c ff
	ff ff		 movsx	 ecx, WORD PTR _r$[ebp]
  0007e	8b 55 08	 mov	 edx, DWORD PTR _vectin$[ebp]
  00081	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  00084	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@457a0000
  0008a	0f bf 85 6c ff
	ff ff		 movsx	 eax, WORD PTR _r$[ebp]
  00091	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _residue$[ebp]
  00097	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
  0009a	eb bd		 jmp	 SHORT $L1045
$L1046:

; 76   :     
; 77   :    for(j=0; j <dim; j++) {

  0009c	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  000a6	eb 0f		 jmp	 SHORT $L1047
$L1048:
  000a8	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  000ae	83 c2 01	 add	 edx, 1
  000b1	89 95 60 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
$L1047:
  000b7	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  000bd	3b 45 20	 cmp	 eax, DWORD PTR _dim$[ebp]
  000c0	0f 8d ea 02 00
	00		 jge	 $L1049

; 78   :      cs = (float)cos((double)(residue[j]*PI));

  000c6	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  000cc	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _residue$[ebp]
  000d2	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  000d5	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@400921fb54524550
  000db	83 ec 08	 sub	 esp, 8
  000de	dd 1c 24	 fstp	 QWORD PTR [esp]
  000e1	e8 00 00 00 00	 call	 _cos
  000e6	83 c4 08	 add	 esp, 8
  000e9	d9 5d b0	 fstp	 DWORD PTR _cs$[ebp]

; 79   :      sn = -(float)sin((double)(residue[j]*PI));

  000ec	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  000f2	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _residue$[ebp]
  000f8	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  000fb	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@400921fb54524550
  00101	83 ec 08	 sub	 esp, 8
  00104	dd 1c 24	 fstp	 QWORD PTR [esp]
  00107	e8 00 00 00 00	 call	 _sin
  0010c	83 c4 08	 add	 esp, 8
  0010f	d9 95 54 ff ff
	ff		 fst	 DWORD PTR tv669[ebp]
  00115	d9 e0		 fchs
  00117	d9 5d e4	 fstp	 DWORD PTR _sn$[ebp]

; 80   : 
; 81   :      dhw.re = cs*dim*(-lpcin[dim-1]);

  0011a	db 45 20	 fild	 DWORD PTR _dim$[ebp]
  0011d	d8 4d b0	 fmul	 DWORD PTR _cs$[ebp]
  00120	8b 55 20	 mov	 edx, DWORD PTR _dim$[ebp]
  00123	8b 45 0c	 mov	 eax, DWORD PTR _lpcin$[ebp]
  00126	d9 44 90 fc	 fld	 DWORD PTR [eax+edx*4-4]
  0012a	d9 e0		 fchs
  0012c	de c9		 fmulp	 ST(1), ST(0)
  0012e	d9 5d f0	 fstp	 DWORD PTR _dhw$[ebp]

; 82   :      dhw.im = sn*dim*(-lpcin[dim-1]);

  00131	db 45 20	 fild	 DWORD PTR _dim$[ebp]
  00134	d8 4d e4	 fmul	 DWORD PTR _sn$[ebp]
  00137	8b 4d 20	 mov	 ecx, DWORD PTR _dim$[ebp]
  0013a	8b 55 0c	 mov	 edx, DWORD PTR _lpcin$[ebp]
  0013d	d9 44 8a fc	 fld	 DWORD PTR [edx+ecx*4-4]
  00141	d9 e0		 fchs
  00143	de c9		 fmulp	 ST(1), ST(0)
  00145	d9 5d f4	 fstp	 DWORD PTR _dhw$[ebp+4]

; 83   : 
; 84   :      hw.re = cs*(-lpcin[dim-1]);

  00148	8b 45 20	 mov	 eax, DWORD PTR _dim$[ebp]
  0014b	8b 4d 0c	 mov	 ecx, DWORD PTR _lpcin$[ebp]
  0014e	d9 44 81 fc	 fld	 DWORD PTR [ecx+eax*4-4]
  00152	d9 e0		 fchs
  00154	d8 4d b0	 fmul	 DWORD PTR _cs$[ebp]
  00157	d9 5d 98	 fstp	 DWORD PTR _hw$[ebp]

; 85   :      hw.im = sn*(-lpcin[dim-1]);  

  0015a	8b 55 20	 mov	 edx, DWORD PTR _dim$[ebp]
  0015d	8b 45 0c	 mov	 eax, DWORD PTR _lpcin$[ebp]
  00160	d9 44 90 fc	 fld	 DWORD PTR [eax+edx*4-4]
  00164	d9 e0		 fchs
  00166	d8 4d e4	 fmul	 DWORD PTR _sn$[ebp]
  00169	d9 5d 9c	 fstp	 DWORD PTR _hw$[ebp+4]

; 86   :     
; 87   :      for(i=dim-2; i >= 0; i--) {

  0016c	8b 4d 20	 mov	 ecx, DWORD PTR _dim$[ebp]
  0016f	83 e9 02	 sub	 ecx, 2
  00172	66 89 4d e8	 mov	 WORD PTR _i$[ebp], cx
  00176	eb 0c		 jmp	 SHORT $L1056
$L1057:
  00178	66 8b 55 e8	 mov	 dx, WORD PTR _i$[ebp]
  0017c	66 83 ea 01	 sub	 dx, 1
  00180	66 89 55 e8	 mov	 WORD PTR _i$[ebp], dx
$L1056:
  00184	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  00188	85 c0		 test	 eax, eax
  0018a	0f 8c 8e 00 00
	00		 jl	 $L1058

; 88   :         /* add a[i] */
; 89   :         dhw.re += (float)(i+1)*(-lpcin[i]);

  00190	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  00194	83 c1 01	 add	 ecx, 1
  00197	89 8d 50 ff ff
	ff		 mov	 DWORD PTR tv684[ebp], ecx
  0019d	db 85 50 ff ff
	ff		 fild	 DWORD PTR tv684[ebp]
  001a3	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  001a7	8b 45 0c	 mov	 eax, DWORD PTR _lpcin$[ebp]
  001aa	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  001ad	d9 e0		 fchs
  001af	de c9		 fmulp	 ST(1), ST(0)
  001b1	d8 45 f0	 fadd	 DWORD PTR _dhw$[ebp]
  001b4	d9 5d f0	 fstp	 DWORD PTR _dhw$[ebp]

; 90   :         hw.re += -lpcin[i];

  001b7	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  001bb	8b 55 0c	 mov	 edx, DWORD PTR _lpcin$[ebp]
  001be	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  001c1	d9 e0		 fchs
  001c3	d8 45 98	 fadd	 DWORD PTR _hw$[ebp]
  001c6	d9 5d 98	 fstp	 DWORD PTR _hw$[ebp]

; 91   : 
; 92   :         /* multiply by exp(-jw) */
; 93   :         dhw.im = cs*(tmp=dhw.im) + sn*dhw.re;

  001c9	8b 45 f4	 mov	 eax, DWORD PTR _dhw$[ebp+4]
  001cc	89 45 a8	 mov	 DWORD PTR _tmp$[ebp], eax
  001cf	d9 45 a8	 fld	 DWORD PTR _tmp$[ebp]
  001d2	d8 4d b0	 fmul	 DWORD PTR _cs$[ebp]
  001d5	d9 45 e4	 fld	 DWORD PTR _sn$[ebp]
  001d8	d8 4d f0	 fmul	 DWORD PTR _dhw$[ebp]
  001db	de c1		 faddp	 ST(1), ST(0)
  001dd	d9 5d f4	 fstp	 DWORD PTR _dhw$[ebp+4]

; 94   :         dhw.re = cs*dhw.re - sn*tmp;

  001e0	d9 45 b0	 fld	 DWORD PTR _cs$[ebp]
  001e3	d8 4d f0	 fmul	 DWORD PTR _dhw$[ebp]
  001e6	d9 45 e4	 fld	 DWORD PTR _sn$[ebp]
  001e9	d8 4d a8	 fmul	 DWORD PTR _tmp$[ebp]
  001ec	de e9		 fsubp	 ST(1), ST(0)
  001ee	d9 5d f0	 fstp	 DWORD PTR _dhw$[ebp]

; 95   : 
; 96   :         /* multiply by exp(-jw) */
; 97   :         hw.im = cs*(tmp=hw.im) + sn*hw.re;

  001f1	8b 4d 9c	 mov	 ecx, DWORD PTR _hw$[ebp+4]
  001f4	89 4d a8	 mov	 DWORD PTR _tmp$[ebp], ecx
  001f7	d9 45 a8	 fld	 DWORD PTR _tmp$[ebp]
  001fa	d8 4d b0	 fmul	 DWORD PTR _cs$[ebp]
  001fd	d9 45 e4	 fld	 DWORD PTR _sn$[ebp]
  00200	d8 4d 98	 fmul	 DWORD PTR _hw$[ebp]
  00203	de c1		 faddp	 ST(1), ST(0)
  00205	d9 5d 9c	 fstp	 DWORD PTR _hw$[ebp+4]

; 98   :         hw.re = cs*hw.re - sn*tmp;

  00208	d9 45 b0	 fld	 DWORD PTR _cs$[ebp]
  0020b	d8 4d 98	 fmul	 DWORD PTR _hw$[ebp]
  0020e	d9 45 e4	 fld	 DWORD PTR _sn$[ebp]
  00211	d8 4d a8	 fmul	 DWORD PTR _tmp$[ebp]
  00214	de e9		 fsubp	 ST(1), ST(0)
  00216	d9 5d 98	 fstp	 DWORD PTR _hw$[ebp]

; 99   : 
; 100  :      }

  00219	e9 5a ff ff ff	 jmp	 $L1057
$L1058:

; 101  :      /* scale result by j and add 1 */
; 102  :      tmp = dhw.re;

  0021e	8b 55 f0	 mov	 edx, DWORD PTR _dhw$[ebp]
  00221	89 55 a8	 mov	 DWORD PTR _tmp$[ebp], edx

; 103  :      dhw.re = -dhw.im;

  00224	d9 45 f4	 fld	 DWORD PTR _dhw$[ebp+4]
  00227	d9 e0		 fchs
  00229	d9 5d f0	 fstp	 DWORD PTR _dhw$[ebp]

; 104  :      dhw.im = tmp;

  0022c	8b 45 a8	 mov	 eax, DWORD PTR _tmp$[ebp]
  0022f	89 45 f4	 mov	 DWORD PTR _dhw$[ebp+4], eax

; 105  : 
; 106  :      hw.re = 1.0F - hw.re;

  00232	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  00238	d8 65 98	 fsub	 DWORD PTR _hw$[ebp]
  0023b	d9 5d 98	 fstp	 DWORD PTR _hw$[ebp]

; 107  :      hw.im = -hw.im;

  0023e	d9 45 9c	 fld	 DWORD PTR _hw$[ebp+4]
  00241	d9 e0		 fchs
  00243	d9 5d 9c	 fstp	 DWORD PTR _hw$[ebp+4]

; 108  : 
; 109  :      dm_sq = hw.re*hw.re + hw.im*hw.im;

  00246	d9 45 98	 fld	 DWORD PTR _hw$[ebp]
  00249	d8 4d 98	 fmul	 DWORD PTR _hw$[ebp]
  0024c	d9 45 9c	 fld	 DWORD PTR _hw$[ebp+4]
  0024f	d8 4d 9c	 fmul	 DWORD PTR _hw$[ebp+4]
  00252	de c1		 faddp	 ST(1), ST(0)
  00254	d9 55 a4	 fst	 DWORD PTR _dm_sq$[ebp]

; 110  : 
; 111  :      /* catch divide by zero (zero on or very near unit circle)
; 112  :         -1 indicates to calling routine that error (or something funny
; 113  :             occurred) */
; 114  :      if (dm_sq <= (float)FLT_MIN)

  00257	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@007fffe1
  0025d	df e0		 fnstsw	 ax
  0025f	f6 c4 41	 test	 ah, 65			; 00000041H
  00262	7a 13		 jp	 SHORT $L1061

; 115  :        weight[j] = 1.0F;  

  00264	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  0026a	c7 44 8d bc 00
	00 80 3f	 mov	 DWORD PTR _weight$[ebp+ecx*4], 1065353216 ; 3f800000H

; 116  :      else if (dm_sq >= (float)FLT_MAX)

  00272	e9 e1 00 00 00	 jmp	 $L1062
$L1061:
  00277	d9 45 a4	 fld	 DWORD PTR _dm_sq$[ebp]
  0027a	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@7f7fffee
  00280	df e0		 fnstsw	 ax
  00282	f6 c4 01	 test	 ah, 1
  00285	75 27		 jne	 SHORT $L1064

; 117  :         weight[j] = (float)(dim+1)*D_RATIO;

  00287	8b 55 20	 mov	 edx, DWORD PTR _dim$[ebp]
  0028a	83 c2 01	 add	 edx, 1
  0028d	89 95 4c ff ff
	ff		 mov	 DWORD PTR tv716[ebp], edx
  00293	db 85 4c ff ff
	ff		 fild	 DWORD PTR tv716[ebp]
  00299	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3cb81301
  0029f	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  002a5	d9 5c 85 bc	 fstp	 DWORD PTR _weight$[ebp+eax*4]

; 118  :         
; 119  :      else  {

  002a9	e9 aa 00 00 00	 jmp	 $L1062
$L1064:

; 120  :        weight[j] = (float)dim + 1.0F + 2.0F*(dhw.im*hw.re - dhw.re*hw.im)/dm_sq;

  002ae	db 45 20	 fild	 DWORD PTR _dim$[ebp]
  002b1	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  002b7	d9 45 f4	 fld	 DWORD PTR _dhw$[ebp+4]
  002ba	d8 4d 98	 fmul	 DWORD PTR _hw$[ebp]
  002bd	d9 45 f0	 fld	 DWORD PTR _dhw$[ebp]
  002c0	d8 4d 9c	 fmul	 DWORD PTR _hw$[ebp+4]
  002c3	de e9		 fsubp	 ST(1), ST(0)
  002c5	dc c0		 fadd	 ST(0), ST(0)
  002c7	d8 75 a4	 fdiv	 DWORD PTR _dm_sq$[ebp]
  002ca	de c1		 faddp	 ST(1), ST(0)
  002cc	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  002d2	d9 5c 8d bc	 fstp	 DWORD PTR _weight$[ebp+ecx*4]

; 121  : 
; 122  :        if (weight[j] > D_MAX)

  002d6	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  002dc	d9 44 95 bc	 fld	 DWORD PTR _weight$[ebp+edx*4]
  002e0	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@43340000
  002e6	df e0		 fnstsw	 ax
  002e8	f6 c4 41	 test	 ah, 65			; 00000041H
  002eb	75 10		 jne	 SHORT $L1068

; 123  :          weight[j] = 1.0F;

  002ed	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  002f3	c7 44 85 bc 00
	00 80 3f	 mov	 DWORD PTR _weight$[ebp+eax*4], 1065353216 ; 3f800000H

; 124  :        else if (weight[j] > D_CRIT)

  002fb	eb 5b		 jmp	 SHORT $L1062
$L1068:
  002fd	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00303	d9 44 8d bc	 fld	 DWORD PTR _weight$[ebp+ecx*4]
  00307	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41300000
  0030d	df e0		 fnstsw	 ax
  0030f	f6 c4 41	 test	 ah, 65			; 00000041H
  00312	75 2a		 jne	 SHORT $L1070

; 125  :          weight[j] = (float)sqrt((double)weight[j]/D_MAX);

  00314	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  0031a	d9 44 95 bc	 fld	 DWORD PTR _weight$[ebp+edx*4]
  0031e	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4066800000000000
  00324	83 ec 08	 sub	 esp, 8
  00327	dd 1c 24	 fstp	 QWORD PTR [esp]
  0032a	e8 00 00 00 00	 call	 _sqrt
  0032f	83 c4 08	 add	 esp, 8
  00332	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00338	d9 5c 85 bc	 fstp	 DWORD PTR _weight$[ebp+eax*4]

; 126  :        else

  0033c	eb 1a		 jmp	 SHORT $L1062
$L1070:

; 127  :          weight[j] *= D_RATIO;

  0033e	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00344	d9 44 8d bc	 fld	 DWORD PTR _weight$[ebp+ecx*4]
  00348	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3cb81301
  0034e	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00354	d9 5c 95 bc	 fstp	 DWORD PTR _weight$[ebp+edx*4]
$L1062:

; 128  :      }
; 129  :      if (residue[j] > W_CRIT)

  00358	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  0035e	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _residue$[ebp]
  00364	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  00367	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3e800000
  0036d	df e0		 fnstsw	 ax
  0036f	f6 c4 41	 test	 ah, 65			; 00000041H
  00372	75 37		 jne	 SHORT $L1074

; 130  :          weight[j] *= 1.0F-2.0F*(residue[j]-W_CRIT)/3.0F;

  00374	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  0037a	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _residue$[ebp]
  00380	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  00383	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3e800000
  00389	dc c0		 fadd	 ST(0), ST(0)
  0038b	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@40400000
  00391	d8 2d 00 00 00
	00		 fsubr	 DWORD PTR __real@3f800000
  00397	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  0039d	d8 4c 8d bc	 fmul	 DWORD PTR _weight$[ebp+ecx*4]
  003a1	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  003a7	d9 5c 95 bc	 fstp	 DWORD PTR _weight$[ebp+edx*4]
$L1074:

; 131  : 
; 132  :    }

  003ab	e9 f8 fc ff ff	 jmp	 $L1048
$L1049:

; 133  : 
; 134  :    
; 135  : 
; 136  : /*********************************************************************
; 137  :    Initialize the data before starting the tree search.
; 138  :       - the number of candidates from the "previous" stage is set
; 139  :         to 1 since there is no previous stage!
; 140  :       - the candidate vector from the previous stage is set to zero
; 141  :       - the list of indeces for each candidate is set to 1
; 142  :   *********************************************************************/
; 143  :    for (c=0; c<numCand; c++) {

  003b0	66 c7 85 64 ff
	ff ff 00 00	 mov	 WORD PTR _c$[ebp], 0
  003b9	eb 12		 jmp	 SHORT $L1075
$L1076:
  003bb	66 8b 85 64 ff
	ff ff		 mov	 ax, WORD PTR _c$[ebp]
  003c2	66 05 01 00	 add	 ax, 1
  003c6	66 89 85 64 ff
	ff ff		 mov	 WORD PTR _c$[ebp], ax
$L1075:
  003cd	0f bf 8d 64 ff
	ff ff		 movsx	 ecx, WORD PTR _c$[ebp]
  003d4	0f bf 55 1c	 movsx	 edx, WORD PTR _numCand$[ebp]
  003d8	3b ca		 cmp	 ecx, edx
  003da	7d 5e		 jge	 SHORT $L1077

; 144  :        for (s=0; s<numStages; s++)

  003dc	66 c7 45 b4 00
	00		 mov	 WORD PTR _s$[ebp], 0
  003e2	eb 0c		 jmp	 SHORT $L1078
$L1079:
  003e4	66 8b 45 b4	 mov	 ax, WORD PTR _s$[ebp]
  003e8	66 05 01 00	 add	 ax, 1
  003ec	66 89 45 b4	 mov	 WORD PTR _s$[ebp], ax
$L1078:
  003f0	0f bf 4d b4	 movsx	 ecx, WORD PTR _s$[ebp]
  003f4	0f bf 55 18	 movsx	 edx, WORD PTR _numStages$[ebp]
  003f8	3b ca		 cmp	 ecx, edx
  003fa	7d 3c		 jge	 SHORT $L1080

; 145  :          index[c*numStages+s] = nextIndex[c*numStages+s] = 0;

  003fc	0f bf 85 64 ff
	ff ff		 movsx	 eax, WORD PTR _c$[ebp]
  00403	0f bf 4d 18	 movsx	 ecx, WORD PTR _numStages$[ebp]
  00407	0f af c1	 imul	 eax, ecx
  0040a	0f bf 55 b4	 movsx	 edx, WORD PTR _s$[ebp]
  0040e	03 c2		 add	 eax, edx
  00410	8b 4d 90	 mov	 ecx, DWORD PTR _nextIndex$[ebp]
  00413	66 c7 04 41 00
	00		 mov	 WORD PTR [ecx+eax*2], 0
  00419	0f bf 95 64 ff
	ff ff		 movsx	 edx, WORD PTR _c$[ebp]
  00420	0f bf 45 18	 movsx	 eax, WORD PTR _numStages$[ebp]
  00424	0f af d0	 imul	 edx, eax
  00427	0f bf 4d b4	 movsx	 ecx, WORD PTR _s$[ebp]
  0042b	03 d1		 add	 edx, ecx
  0042d	8b 45 ac	 mov	 eax, DWORD PTR _index$[ebp]
  00430	66 c7 04 50 00
	00		 mov	 WORD PTR [eax+edx*2], 0
  00436	eb ac		 jmp	 SHORT $L1079
$L1080:

; 146  :    }

  00438	eb 81		 jmp	 SHORT $L1076
$L1077:

; 147  :    ncPrev = 1;

  0043a	66 c7 85 78 ff
	ff ff 01 00	 mov	 WORD PTR _ncPrev$[ebp], 1

; 148  :    
; 149  : /* ********************************************************************
; 150  :    Now we start the search:
; 151  :       For each stage
; 152  :          For each candidate from the previous stage
; 153  :             For each entry in the current stage codebook
; 154  :                * add the codebook vector to the current candidate
; 155  :                * compute the distortion with the target
; 156  :                * retain as a candidate if it is one of the best so far
; 157  : 
; 158  :    ******************************************************************** */
; 159  :    for (s=0; s<numStages; s++) {

  00443	66 c7 45 b4 00
	00		 mov	 WORD PTR _s$[ebp], 0
  00449	eb 0c		 jmp	 SHORT $L1081
$L1082:
  0044b	66 8b 4d b4	 mov	 cx, WORD PTR _s$[ebp]
  0044f	66 83 c1 01	 add	 cx, 1
  00453	66 89 4d b4	 mov	 WORD PTR _s$[ebp], cx
$L1081:
  00457	0f bf 55 b4	 movsx	 edx, WORD PTR _s$[ebp]
  0045b	0f bf 45 18	 movsx	 eax, WORD PTR _numStages$[ebp]
  0045f	3b d0		 cmp	 edx, eax
  00461	0f 8d c2 03 00
	00		 jge	 $L1083

; 160  :       /* set the distortions to huge values */
; 161  :       for (c=0; c<numCand; c++)

  00467	66 c7 85 64 ff
	ff ff 00 00	 mov	 WORD PTR _c$[ebp], 0
  00470	eb 12		 jmp	 SHORT $L1084
$L1085:
  00472	66 8b 8d 64 ff
	ff ff		 mov	 cx, WORD PTR _c$[ebp]
  00479	66 83 c1 01	 add	 cx, 1
  0047d	66 89 8d 64 ff
	ff ff		 mov	 WORD PTR _c$[ebp], cx
$L1084:
  00484	0f bf 95 64 ff
	ff ff		 movsx	 edx, WORD PTR _c$[ebp]
  0048b	0f bf 45 1c	 movsx	 eax, WORD PTR _numCand$[ebp]
  0048f	3b d0		 cmp	 edx, eax
  00491	7d 13		 jge	 SHORT $L1086

; 162  :          dMin[c] = (float)FLT_MAX;

  00493	0f bf 8d 64 ff
	ff ff		 movsx	 ecx, WORD PTR _c$[ebp]
  0049a	8b 55 80	 mov	 edx, DWORD PTR _dMin$[ebp]
  0049d	c7 04 8a ee ff
	7f 7f		 mov	 DWORD PTR [edx+ecx*4], 2139095022 ; 7f7fffeeH
  004a4	eb cc		 jmp	 SHORT $L1085
$L1086:

; 163  : 
; 164  : 	   /* Loop for each previous candidate selected, and try each entry */
; 165  :      
; 166  :       for (c=0, u=residue; c<ncPrev; u+=dim, c++) {   

  004a6	66 c7 85 64 ff
	ff ff 00 00	 mov	 WORD PTR _c$[ebp], 0
  004af	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _residue$[ebp]
  004b5	89 45 b8	 mov	 DWORD PTR _u$[ebp], eax
  004b8	eb 1e		 jmp	 SHORT $L1088
$L1089:
  004ba	8b 4d 20	 mov	 ecx, DWORD PTR _dim$[ebp]
  004bd	8b 55 b8	 mov	 edx, DWORD PTR _u$[ebp]
  004c0	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  004c3	89 45 b8	 mov	 DWORD PTR _u$[ebp], eax
  004c6	66 8b 8d 64 ff
	ff ff		 mov	 cx, WORD PTR _c$[ebp]
  004cd	66 83 c1 01	 add	 cx, 1
  004d1	66 89 8d 64 ff
	ff ff		 mov	 WORD PTR _c$[ebp], cx
$L1088:
  004d8	0f bf 95 64 ff
	ff ff		 movsx	 edx, WORD PTR _c$[ebp]
  004df	0f bf 85 78 ff
	ff ff		 movsx	 eax, WORD PTR _ncPrev$[ebp]
  004e6	3b d0		 cmp	 edx, eax
  004e8	0f 8d 52 01 00
	00		 jge	 $L1090

; 167  :          for (entry=0,uHat=(float *)cb[s]; entry <tableSize; entry++, uHat+=dim) {

  004ee	66 c7 85 68 ff
	ff ff 00 00	 mov	 WORD PTR _entry$[ebp], 0
  004f7	0f bf 4d b4	 movsx	 ecx, WORD PTR _s$[ebp]
  004fb	8b 55 28	 mov	 edx, DWORD PTR _cb$[ebp]
  004fe	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00501	89 45 ec	 mov	 DWORD PTR _uHat$[ebp], eax
  00504	eb 1e		 jmp	 SHORT $L1092
$L1093:
  00506	66 8b 8d 68 ff
	ff ff		 mov	 cx, WORD PTR _entry$[ebp]
  0050d	66 83 c1 01	 add	 cx, 1
  00511	66 89 8d 68 ff
	ff ff		 mov	 WORD PTR _entry$[ebp], cx
  00518	8b 55 20	 mov	 edx, DWORD PTR _dim$[ebp]
  0051b	8b 45 ec	 mov	 eax, DWORD PTR _uHat$[ebp]
  0051e	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00521	89 4d ec	 mov	 DWORD PTR _uHat$[ebp], ecx
$L1092:
  00524	0f bf 95 68 ff
	ff ff		 movsx	 edx, WORD PTR _entry$[ebp]
  0052b	0f bf 45 24	 movsx	 eax, WORD PTR _tableSize$[ebp]
  0052f	3b d0		 cmp	 edx, eax
  00531	0f 8d 04 01 00
	00		 jge	 $L1094

; 168  : #ifndef WIN32
; 169  :             for(i=dim-1,d=0.0F;i>=0;i--)
; 170  :  	            d += weight[i]*(MTH_SQR(uHat[i] - u[i]));
; 171  : #else  /* WIN32 */
; 172  :             d=CalcWeightedMSE(weight,uHat,u,dim);

  00537	8b 4d 20	 mov	 ecx, DWORD PTR _dim$[ebp]
  0053a	51		 push	 ecx
  0053b	8b 55 b8	 mov	 edx, DWORD PTR _u$[ebp]
  0053e	52		 push	 edx
  0053f	8b 45 ec	 mov	 eax, DWORD PTR _uHat$[ebp]
  00542	50		 push	 eax
  00543	8d 4d bc	 lea	 ecx, DWORD PTR _weight$[ebp]
  00546	51		 push	 ecx
  00547	e8 00 00 00 00	 call	 _CalcWeightedMSE@16
  0054c	d9 9d 70 ff ff
	ff		 fstp	 DWORD PTR _d$[ebp]

; 173  : #endif /* WIN32 */
; 174  : /* ********************************************************************
; 175  :    If the error for this entry is less than the worst retained
; 176  :    candidate so far, keep it. Note that the error list is maintained
; 177  :    in order of best (min error) to worst.
; 178  :    ******************************************************************** */
; 179  :             if (d < dMin[numCand-1]) { 

  00552	0f bf 55 1c	 movsx	 edx, WORD PTR _numCand$[ebp]
  00556	8b 45 80	 mov	 eax, DWORD PTR _dMin$[ebp]
  00559	d9 85 70 ff ff
	ff		 fld	 DWORD PTR _d$[ebp]
  0055f	d8 5c 90 fc	 fcomp	 DWORD PTR [eax+edx*4-4]
  00563	df e0		 fnstsw	 ax
  00565	f6 c4 05	 test	 ah, 5
  00568	0f 8a c8 00 00
	00		 jp	 $L1095

; 180  :                for(k=numCand-1;k>0&&d<=dMin[k-1];k--) {

  0056e	0f bf 4d 1c	 movsx	 ecx, WORD PTR _numCand$[ebp]
  00572	83 e9 01	 sub	 ecx, 1
  00575	89 4d 8c	 mov	 DWORD PTR _k$[ebp], ecx
  00578	eb 09		 jmp	 SHORT $L1096
$L1097:
  0057a	8b 55 8c	 mov	 edx, DWORD PTR _k$[ebp]
  0057d	83 ea 01	 sub	 edx, 1
  00580	89 55 8c	 mov	 DWORD PTR _k$[ebp], edx
$L1096:
  00583	83 7d 8c 00	 cmp	 DWORD PTR _k$[ebp], 0
  00587	7e 6f		 jle	 SHORT $L1098
  00589	8b 45 8c	 mov	 eax, DWORD PTR _k$[ebp]
  0058c	8b 4d 80	 mov	 ecx, DWORD PTR _dMin$[ebp]
  0058f	d9 85 70 ff ff
	ff		 fld	 DWORD PTR _d$[ebp]
  00595	d8 5c 81 fc	 fcomp	 DWORD PTR [ecx+eax*4-4]
  00599	df e0		 fnstsw	 ax
  0059b	f6 c4 41	 test	 ah, 65			; 00000041H
  0059e	7a 58		 jp	 SHORT $L1098

; 181  : 		            dMin[k] = dMin[k-1];

  005a0	8b 55 8c	 mov	 edx, DWORD PTR _k$[ebp]
  005a3	8b 45 80	 mov	 eax, DWORD PTR _dMin$[ebp]
  005a6	8b 4d 8c	 mov	 ecx, DWORD PTR _k$[ebp]
  005a9	8b 75 80	 mov	 esi, DWORD PTR _dMin$[ebp]
  005ac	8b 4c 8e fc	 mov	 ecx, DWORD PTR [esi+ecx*4-4]
  005b0	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 182  : 		            newIndex[k+k] = newIndex[k+k-2];

  005b3	8b 55 8c	 mov	 edx, DWORD PTR _k$[ebp]
  005b6	03 55 8c	 add	 edx, DWORD PTR _k$[ebp]
  005b9	8b 45 8c	 mov	 eax, DWORD PTR _k$[ebp]
  005bc	03 45 8c	 add	 eax, DWORD PTR _k$[ebp]
  005bf	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _newIndex$[ebp]
  005c5	8b b5 74 ff ff
	ff		 mov	 esi, DWORD PTR _newIndex$[ebp]
  005cb	66 8b 54 56 fc	 mov	 dx, WORD PTR [esi+edx*2-4]
  005d0	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 183  : 		            newIndex[k+k+1] = newIndex[k+k-1];

  005d4	8b 45 8c	 mov	 eax, DWORD PTR _k$[ebp]
  005d7	03 45 8c	 add	 eax, DWORD PTR _k$[ebp]
  005da	8b 4d 8c	 mov	 ecx, DWORD PTR _k$[ebp]
  005dd	03 4d 8c	 add	 ecx, DWORD PTR _k$[ebp]
  005e0	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _newIndex$[ebp]
  005e6	8b b5 74 ff ff
	ff		 mov	 esi, DWORD PTR _newIndex$[ebp]
  005ec	66 8b 44 46 fe	 mov	 ax, WORD PTR [esi+eax*2-2]
  005f1	66 89 44 4a 02	 mov	 WORD PTR [edx+ecx*2+2], ax

; 184  : 		         }

  005f6	eb 82		 jmp	 SHORT $L1097
$L1098:

; 185  :                dMin[k] = d;

  005f8	8b 4d 8c	 mov	 ecx, DWORD PTR _k$[ebp]
  005fb	8b 55 80	 mov	 edx, DWORD PTR _dMin$[ebp]
  005fe	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  00604	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 186  :                newIndex[k+k] = c;

  00607	8b 4d 8c	 mov	 ecx, DWORD PTR _k$[ebp]
  0060a	03 4d 8c	 add	 ecx, DWORD PTR _k$[ebp]
  0060d	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _newIndex$[ebp]
  00613	66 8b 85 64 ff
	ff ff		 mov	 ax, WORD PTR _c$[ebp]
  0061a	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 187  :                newIndex[k+k+1] = entry;

  0061e	8b 4d 8c	 mov	 ecx, DWORD PTR _k$[ebp]
  00621	03 4d 8c	 add	 ecx, DWORD PTR _k$[ebp]
  00624	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _newIndex$[ebp]
  0062a	66 8b 85 68 ff
	ff ff		 mov	 ax, WORD PTR _entry$[ebp]
  00631	66 89 44 4a 02	 mov	 WORD PTR [edx+ecx*2+2], ax
$L1095:

; 188  :             }
; 189  : 
; 190  :          } /* for each entry */

  00636	e9 cb fe ff ff	 jmp	 $L1093
$L1094:

; 191  :       } /* Try out each previous candidate codevector */

  0063b	e9 7a fe ff ff	 jmp	 $L1089
$L1090:

; 192  :     
; 193  : /* ********************************************************************
; 194  :    Compute the number of candidate vectors which we kept for the next
; 195  :    stage. Note that if the size of the stages is less than the number
; 196  :    of candidates, we build them up using all entries until we have
; 197  :    kept numCand candidates.
; 198  :    ******************************************************************** */
; 199  :       ncPrev = MTH_MIN (ncPrev*tableSize, numCand);

  00640	0f bf 8d 78 ff
	ff ff		 movsx	 ecx, WORD PTR _ncPrev$[ebp]
  00647	0f bf 55 24	 movsx	 edx, WORD PTR _tableSize$[ebp]
  0064b	0f af ca	 imul	 ecx, edx
  0064e	0f bf 45 1c	 movsx	 eax, WORD PTR _numCand$[ebp]
  00652	3b c8		 cmp	 ecx, eax
  00654	7f 16		 jg	 SHORT $L1261
  00656	0f bf 8d 78 ff
	ff ff		 movsx	 ecx, WORD PTR _ncPrev$[ebp]
  0065d	0f bf 55 24	 movsx	 edx, WORD PTR _tableSize$[ebp]
  00661	0f af ca	 imul	 ecx, edx
  00664	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv392[ebp], ecx
  0066a	eb 0a		 jmp	 SHORT $L1262
$L1261:
  0066c	0f bf 45 1c	 movsx	 eax, WORD PTR _numCand$[ebp]
  00670	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv392[ebp], eax
$L1262:
  00676	66 8b 8d 48 ff
	ff ff		 mov	 cx, WORD PTR tv392[ebp]
  0067d	66 89 8d 78 ff
	ff ff		 mov	 WORD PTR _ncPrev$[ebp], cx

; 200  : 
; 201  : /* ********************************************************************
; 202  :    We now have the  best indeces for the stage just completed, so
; 203  :    compute the new candidate vectors for the next stage...
; 204  :    ******************************************************************** */
; 205  :  	  for (c=0; c<ncPrev; c++) {

  00684	66 c7 85 64 ff
	ff ff 00 00	 mov	 WORD PTR _c$[ebp], 0
  0068d	eb 12		 jmp	 SHORT $L1099
$L1100:
  0068f	66 8b 95 64 ff
	ff ff		 mov	 dx, WORD PTR _c$[ebp]
  00696	66 83 c2 01	 add	 dx, 1
  0069a	66 89 95 64 ff
	ff ff		 mov	 WORD PTR _c$[ebp], dx
$L1099:
  006a1	0f bf 85 64 ff
	ff ff		 movsx	 eax, WORD PTR _c$[ebp]
  006a8	0f bf 8d 78 ff
	ff ff		 movsx	 ecx, WORD PTR _ncPrev$[ebp]
  006af	3b c1		 cmp	 eax, ecx
  006b1	0f 8d 3d 01 00
	00		 jge	 $L1101

; 206  :          register short newcand;
; 207  :          newcand = newIndex[c+c]; 

  006b7	0f bf 95 64 ff
	ff ff		 movsx	 edx, WORD PTR _c$[ebp]
  006be	0f bf 85 64 ff
	ff ff		 movsx	 eax, WORD PTR _c$[ebp]
  006c5	03 d0		 add	 edx, eax
  006c7	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _newIndex$[ebp]
  006cd	66 8b 14 51	 mov	 dx, WORD PTR [ecx+edx*2]
  006d1	66 89 95 58 ff
	ff ff		 mov	 WORD PTR _newcand$1102[ebp], dx

; 208  :          nextIndex[c*numStages+s] = newIndex[c+c+1];

  006d8	0f bf 85 64 ff
	ff ff		 movsx	 eax, WORD PTR _c$[ebp]
  006df	0f bf 8d 64 ff
	ff ff		 movsx	 ecx, WORD PTR _c$[ebp]
  006e6	03 c1		 add	 eax, ecx
  006e8	0f bf 95 64 ff
	ff ff		 movsx	 edx, WORD PTR _c$[ebp]
  006ef	0f bf 4d 18	 movsx	 ecx, WORD PTR _numStages$[ebp]
  006f3	0f af d1	 imul	 edx, ecx
  006f6	0f bf 4d b4	 movsx	 ecx, WORD PTR _s$[ebp]
  006fa	03 d1		 add	 edx, ecx
  006fc	8b 4d 90	 mov	 ecx, DWORD PTR _nextIndex$[ebp]
  006ff	8b b5 74 ff ff
	ff		 mov	 esi, DWORD PTR _newIndex$[ebp]
  00705	66 8b 44 46 02	 mov	 ax, WORD PTR [esi+eax*2+2]
  0070a	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 209  :          for (i=0; i<s; i++)

  0070e	66 c7 45 e8 00
	00		 mov	 WORD PTR _i$[ebp], 0
  00714	eb 0c		 jmp	 SHORT $L1103
$L1104:
  00716	66 8b 4d e8	 mov	 cx, WORD PTR _i$[ebp]
  0071a	66 83 c1 01	 add	 cx, 1
  0071e	66 89 4d e8	 mov	 WORD PTR _i$[ebp], cx
$L1103:
  00722	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  00726	0f bf 45 b4	 movsx	 eax, WORD PTR _s$[ebp]
  0072a	3b d0		 cmp	 edx, eax
  0072c	7d 38		 jge	 SHORT $L1105

; 210  :             nextIndex[c*numStages+i] = index[newcand*numStages+i];

  0072e	0f bf 8d 58 ff
	ff ff		 movsx	 ecx, WORD PTR _newcand$1102[ebp]
  00735	0f bf 55 18	 movsx	 edx, WORD PTR _numStages$[ebp]
  00739	0f af ca	 imul	 ecx, edx
  0073c	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  00740	03 c8		 add	 ecx, eax
  00742	0f bf 95 64 ff
	ff ff		 movsx	 edx, WORD PTR _c$[ebp]
  00749	0f bf 45 18	 movsx	 eax, WORD PTR _numStages$[ebp]
  0074d	0f af d0	 imul	 edx, eax
  00750	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  00754	03 d0		 add	 edx, eax
  00756	8b 45 90	 mov	 eax, DWORD PTR _nextIndex$[ebp]
  00759	8b 75 ac	 mov	 esi, DWORD PTR _index$[ebp]
  0075c	66 8b 0c 4e	 mov	 cx, WORD PTR [esi+ecx*2]
  00760	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  00764	eb b0		 jmp	 SHORT $L1104
$L1105:

; 211  :          tbl = (float *)cb[s]+newIndex[c+c+1]*dim;

  00766	0f bf 55 b4	 movsx	 edx, WORD PTR _s$[ebp]
  0076a	0f bf 85 64 ff
	ff ff		 movsx	 eax, WORD PTR _c$[ebp]
  00771	0f bf 8d 64 ff
	ff ff		 movsx	 ecx, WORD PTR _c$[ebp]
  00778	03 c1		 add	 eax, ecx
  0077a	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _newIndex$[ebp]
  00780	0f bf 44 41 02	 movsx	 eax, WORD PTR [ecx+eax*2+2]
  00785	0f af 45 20	 imul	 eax, DWORD PTR _dim$[ebp]
  00789	8b 4d 28	 mov	 ecx, DWORD PTR _cb$[ebp]
  0078c	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  0078f	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  00792	89 45 fc	 mov	 DWORD PTR _tbl$[ebp], eax

; 212  : 		   for (i =0; i<dim; i++)

  00795	66 c7 45 e8 00
	00		 mov	 WORD PTR _i$[ebp], 0
  0079b	eb 0c		 jmp	 SHORT $L1107
$L1108:
  0079d	66 8b 4d e8	 mov	 cx, WORD PTR _i$[ebp]
  007a1	66 83 c1 01	 add	 cx, 1
  007a5	66 89 4d e8	 mov	 WORD PTR _i$[ebp], cx
$L1107:
  007a9	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  007ad	3b 55 20	 cmp	 edx, DWORD PTR _dim$[ebp]
  007b0	7d 3d		 jge	 SHORT $L1109

; 213  : 			   newresidue[c*dim+i] = residue[newcand*dim+i]-tbl[i];

  007b2	0f bf 85 58 ff
	ff ff		 movsx	 eax, WORD PTR _newcand$1102[ebp]
  007b9	0f af 45 20	 imul	 eax, DWORD PTR _dim$[ebp]
  007bd	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  007c1	03 c1		 add	 eax, ecx
  007c3	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  007c7	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _residue$[ebp]
  007cd	8b 75 fc	 mov	 esi, DWORD PTR _tbl$[ebp]
  007d0	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  007d3	d8 24 96	 fsub	 DWORD PTR [esi+edx*4]
  007d6	0f bf 95 64 ff
	ff ff		 movsx	 edx, WORD PTR _c$[ebp]
  007dd	0f af 55 20	 imul	 edx, DWORD PTR _dim$[ebp]
  007e1	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  007e5	03 d0		 add	 edx, eax
  007e7	8b 4d f8	 mov	 ecx, DWORD PTR _newresidue$[ebp]
  007ea	d9 1c 91	 fstp	 DWORD PTR [ecx+edx*4]
  007ed	eb ae		 jmp	 SHORT $L1108
$L1109:

; 214  :      }

  007ef	e9 9b fe ff ff	 jmp	 $L1100
$L1101:

; 215  :      tempshort = index;

  007f4	8b 55 ac	 mov	 edx, DWORD PTR _index$[ebp]
  007f7	89 55 84	 mov	 DWORD PTR _tempshort$[ebp], edx

; 216  : 	  tempfloat = residue;

  007fa	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _residue$[ebp]
  00800	89 85 7c ff ff
	ff		 mov	 DWORD PTR _tempfloat$[ebp], eax

; 217  : 	  index = nextIndex;

  00806	8b 4d 90	 mov	 ecx, DWORD PTR _nextIndex$[ebp]
  00809	89 4d ac	 mov	 DWORD PTR _index$[ebp], ecx

; 218  : 	  residue = newresidue;

  0080c	8b 55 f8	 mov	 edx, DWORD PTR _newresidue$[ebp]
  0080f	89 95 5c ff ff
	ff		 mov	 DWORD PTR _residue$[ebp], edx

; 219  :       nextIndex = tempshort;

  00815	8b 45 84	 mov	 eax, DWORD PTR _tempshort$[ebp]
  00818	89 45 90	 mov	 DWORD PTR _nextIndex$[ebp], eax

; 220  :       newresidue = tempfloat;

  0081b	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _tempfloat$[ebp]
  00821	89 4d f8	 mov	 DWORD PTR _newresidue$[ebp], ecx

; 221  :    } /* for each stage */

  00824	e9 22 fc ff ff	 jmp	 $L1082
$L1083:

; 222  :    for (c=0; c<numCand; c++) {

  00829	66 c7 85 64 ff
	ff ff 00 00	 mov	 WORD PTR _c$[ebp], 0
  00832	eb 12		 jmp	 SHORT $L1110
$L1111:
  00834	66 8b 95 64 ff
	ff ff		 mov	 dx, WORD PTR _c$[ebp]
  0083b	66 83 c2 01	 add	 dx, 1
  0083f	66 89 95 64 ff
	ff ff		 mov	 WORD PTR _c$[ebp], dx
$L1110:
  00846	0f bf 85 64 ff
	ff ff		 movsx	 eax, WORD PTR _c$[ebp]
  0084d	0f bf 4d 1c	 movsx	 ecx, WORD PTR _numCand$[ebp]
  00851	3b c1		 cmp	 eax, ecx
  00853	0f 8d f7 00 00
	00		 jge	 $L1112

; 223  :       for(i = 0; i<dim; i++) 

  00859	66 c7 45 e8 00
	00		 mov	 WORD PTR _i$[ebp], 0
  0085f	eb 0c		 jmp	 SHORT $L1113
$L1114:
  00861	66 8b 55 e8	 mov	 dx, WORD PTR _i$[ebp]
  00865	66 83 c2 01	 add	 dx, 1
  00869	66 89 55 e8	 mov	 WORD PTR _i$[ebp], dx
$L1113:
  0086d	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  00871	3b 45 20	 cmp	 eax, DWORD PTR _dim$[ebp]
  00874	7d 1d		 jge	 SHORT $L1115

; 224  :          cand[c*dim+i] = 0.0F;

  00876	0f bf 8d 64 ff
	ff ff		 movsx	 ecx, WORD PTR _c$[ebp]
  0087d	0f af 4d 20	 imul	 ecx, DWORD PTR _dim$[ebp]
  00881	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  00885	03 ca		 add	 ecx, edx
  00887	8b 45 88	 mov	 eax, DWORD PTR _cand$[ebp]
  0088a	c7 04 88 00 00
	00 00		 mov	 DWORD PTR [eax+ecx*4], 0
  00891	eb ce		 jmp	 SHORT $L1114
$L1115:

; 225  :          for (i=0; i<numStages; i++) {

  00893	66 c7 45 e8 00
	00		 mov	 WORD PTR _i$[ebp], 0
  00899	eb 0c		 jmp	 SHORT $L1116
$L1117:
  0089b	66 8b 4d e8	 mov	 cx, WORD PTR _i$[ebp]
  0089f	66 83 c1 01	 add	 cx, 1
  008a3	66 89 4d e8	 mov	 WORD PTR _i$[ebp], cx
$L1116:
  008a7	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  008ab	0f bf 45 18	 movsx	 eax, WORD PTR _numStages$[ebp]
  008af	3b d0		 cmp	 edx, eax
  008b1	0f 8d 94 00 00
	00		 jge	 $L1118

; 226  :             tbl = (float *)cb[i]+index[c*numStages+i]*dim;

  008b7	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  008bb	0f bf 95 64 ff
	ff ff		 movsx	 edx, WORD PTR _c$[ebp]
  008c2	0f bf 45 18	 movsx	 eax, WORD PTR _numStages$[ebp]
  008c6	0f af d0	 imul	 edx, eax
  008c9	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  008cd	03 d0		 add	 edx, eax
  008cf	8b 45 ac	 mov	 eax, DWORD PTR _index$[ebp]
  008d2	0f bf 14 50	 movsx	 edx, WORD PTR [eax+edx*2]
  008d6	0f af 55 20	 imul	 edx, DWORD PTR _dim$[ebp]
  008da	8b 45 28	 mov	 eax, DWORD PTR _cb$[ebp]
  008dd	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  008e0	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  008e3	89 55 fc	 mov	 DWORD PTR _tbl$[ebp], edx

; 227  :             u = cand+c*dim;

  008e6	0f bf 85 64 ff
	ff ff		 movsx	 eax, WORD PTR _c$[ebp]
  008ed	0f af 45 20	 imul	 eax, DWORD PTR _dim$[ebp]
  008f1	8b 4d 88	 mov	 ecx, DWORD PTR _cand$[ebp]
  008f4	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  008f7	89 55 b8	 mov	 DWORD PTR _u$[ebp], edx

; 228  :             for (r=0; r<dim; r++)

  008fa	66 c7 85 6c ff
	ff ff 00 00	 mov	 WORD PTR _r$[ebp], 0
  00903	eb 12		 jmp	 SHORT $L1120
$L1121:
  00905	66 8b 85 6c ff
	ff ff		 mov	 ax, WORD PTR _r$[ebp]
  0090c	66 05 01 00	 add	 ax, 1
  00910	66 89 85 6c ff
	ff ff		 mov	 WORD PTR _r$[ebp], ax
$L1120:
  00917	0f bf 8d 6c ff
	ff ff		 movsx	 ecx, WORD PTR _r$[ebp]
  0091e	3b 4d 20	 cmp	 ecx, DWORD PTR _dim$[ebp]
  00921	7d 23		 jge	 SHORT $L1122

; 229  :                 *u++ += *tbl++;

  00923	8b 55 b8	 mov	 edx, DWORD PTR _u$[ebp]
  00926	8b 45 fc	 mov	 eax, DWORD PTR _tbl$[ebp]
  00929	d9 02		 fld	 DWORD PTR [edx]
  0092b	d8 00		 fadd	 DWORD PTR [eax]
  0092d	8b 4d b8	 mov	 ecx, DWORD PTR _u$[ebp]
  00930	d9 19		 fstp	 DWORD PTR [ecx]
  00932	8b 55 fc	 mov	 edx, DWORD PTR _tbl$[ebp]
  00935	83 c2 04	 add	 edx, 4
  00938	89 55 fc	 mov	 DWORD PTR _tbl$[ebp], edx
  0093b	8b 45 b8	 mov	 eax, DWORD PTR _u$[ebp]
  0093e	83 c0 04	 add	 eax, 4
  00941	89 45 b8	 mov	 DWORD PTR _u$[ebp], eax
  00944	eb bf		 jmp	 SHORT $L1121
$L1122:

; 230  :          }

  00946	e9 50 ff ff ff	 jmp	 $L1117
$L1118:

; 231  :    }

  0094b	e9 e4 fe ff ff	 jmp	 $L1111
$L1112:

; 232  : 
; 233  :    i=1;    

  00950	66 c7 45 e8 01
	00		 mov	 WORD PTR _i$[ebp], 1
$L1124:

; 234  :    while (i<dim&&cand[i]>=cand[i-1]) i++;

  00956	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  0095a	3b 4d 20	 cmp	 ecx, DWORD PTR _dim$[ebp]
  0095d	7d 2a		 jge	 SHORT $L1125
  0095f	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  00963	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  00967	8b 4d 88	 mov	 ecx, DWORD PTR _cand$[ebp]
  0096a	8b 75 88	 mov	 esi, DWORD PTR _cand$[ebp]
  0096d	d9 04 91	 fld	 DWORD PTR [ecx+edx*4]
  00970	d8 5c 86 fc	 fcomp	 DWORD PTR [esi+eax*4-4]
  00974	df e0		 fnstsw	 ax
  00976	f6 c4 01	 test	 ah, 1
  00979	75 0e		 jne	 SHORT $L1125
  0097b	66 8b 55 e8	 mov	 dx, WORD PTR _i$[ebp]
  0097f	66 83 c2 01	 add	 dx, 1
  00983	66 89 55 e8	 mov	 WORD PTR _i$[ebp], dx
  00987	eb cd		 jmp	 SHORT $L1124
$L1125:

; 235  :    if (i<dim&&cand[i]<cand[i-1]) {

  00989	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  0098d	3b 45 20	 cmp	 eax, DWORD PTR _dim$[ebp]
  00990	0f 8d b9 00 00
	00		 jge	 $L1126
  00996	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  0099a	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  0099e	8b 45 88	 mov	 eax, DWORD PTR _cand$[ebp]
  009a1	8b 75 88	 mov	 esi, DWORD PTR _cand$[ebp]
  009a4	d9 04 88	 fld	 DWORD PTR [eax+ecx*4]
  009a7	d8 5c 96 fc	 fcomp	 DWORD PTR [esi+edx*4-4]
  009ab	df e0		 fnstsw	 ax
  009ad	f6 c4 05	 test	 ah, 5
  009b0	0f 8a 99 00 00
	00		 jp	 $L1126

; 236  :    for (j=2;j<=dim;j++) {

  009b6	c7 85 60 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _j$[ebp], 2
  009c0	eb 0f		 jmp	 SHORT $L1127
$L1128:
  009c2	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  009c8	83 c1 01	 add	 ecx, 1
  009cb	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx
$L1127:
  009d1	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  009d7	3b 55 20	 cmp	 edx, DWORD PTR _dim$[ebp]
  009da	7f 73		 jg	 SHORT $L1126

; 237  :       i=j-1;

  009dc	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  009e2	83 e8 01	 sub	 eax, 1
  009e5	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax
$L1131:

; 238  :       while (i>0 && cand[i-1] > cand[j-1]) {

  009e9	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  009ed	85 c9		 test	 ecx, ecx
  009ef	7e 42		 jle	 SHORT $L1132
  009f1	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  009f5	8b 45 88	 mov	 eax, DWORD PTR _cand$[ebp]
  009f8	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  009fe	8b 75 88	 mov	 esi, DWORD PTR _cand$[ebp]
  00a01	d9 44 90 fc	 fld	 DWORD PTR [eax+edx*4-4]
  00a05	d8 5c 8e fc	 fcomp	 DWORD PTR [esi+ecx*4-4]
  00a09	df e0		 fnstsw	 ax
  00a0b	f6 c4 41	 test	 ah, 65			; 00000041H
  00a0e	75 23		 jne	 SHORT $L1132

; 239  :          cand[i]=cand[i-1];

  00a10	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  00a14	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  00a18	8b 4d 88	 mov	 ecx, DWORD PTR _cand$[ebp]
  00a1b	8b 75 88	 mov	 esi, DWORD PTR _cand$[ebp]
  00a1e	8b 54 96 fc	 mov	 edx, DWORD PTR [esi+edx*4-4]
  00a22	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 240  :          i--;

  00a25	66 8b 45 e8	 mov	 ax, WORD PTR _i$[ebp]
  00a29	66 2d 01 00	 sub	 ax, 1
  00a2d	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax

; 241  :       }

  00a31	eb b6		 jmp	 SHORT $L1131
$L1132:

; 242  :       cand[i]=cand[j-1];

  00a33	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  00a37	8b 55 88	 mov	 edx, DWORD PTR _cand$[ebp]
  00a3a	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00a40	8b 75 88	 mov	 esi, DWORD PTR _cand$[ebp]
  00a43	8b 44 86 fc	 mov	 eax, DWORD PTR [esi+eax*4-4]
  00a47	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 243  :    }

  00a4a	e9 73 ff ff ff	 jmp	 $L1128
$L1126:

; 244  :    }
; 245  :    for (c=0; c<numCand; c++){

  00a4f	66 c7 85 64 ff
	ff ff 00 00	 mov	 WORD PTR _c$[ebp], 0
  00a58	eb 12		 jmp	 SHORT $L1133
$L1134:
  00a5a	66 8b 8d 64 ff
	ff ff		 mov	 cx, WORD PTR _c$[ebp]
  00a61	66 83 c1 01	 add	 cx, 1
  00a65	66 89 8d 64 ff
	ff ff		 mov	 WORD PTR _c$[ebp], cx
$L1133:
  00a6c	0f bf 95 64 ff
	ff ff		 movsx	 edx, WORD PTR _c$[ebp]
  00a73	0f bf 45 1c	 movsx	 eax, WORD PTR _numCand$[ebp]
  00a77	3b d0		 cmp	 edx, eax
  00a79	0f 8d 81 00 00
	00		 jge	 $L1135

; 246  :       candBAD=0;

  00a7f	66 c7 45 a0 00
	00		 mov	 WORD PTR _candBAD$[ebp], 0

; 247  :       for (i=1;i<dim;i++){

  00a85	66 c7 45 e8 01
	00		 mov	 WORD PTR _i$[ebp], 1
  00a8b	eb 0c		 jmp	 SHORT $L1136
$L1137:
  00a8d	66 8b 4d e8	 mov	 cx, WORD PTR _i$[ebp]
  00a91	66 83 c1 01	 add	 cx, 1
  00a95	66 89 4d e8	 mov	 WORD PTR _i$[ebp], cx
$L1136:
  00a99	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  00a9d	3b 55 20	 cmp	 edx, DWORD PTR _dim$[ebp]
  00aa0	7d 44		 jge	 SHORT $L1138

; 248  :          if ((cand[c*dim+i]-cand[c*dim+i-1]) <LSPDIFF_THRESHOLD){

  00aa2	0f bf 85 64 ff
	ff ff		 movsx	 eax, WORD PTR _c$[ebp]
  00aa9	0f af 45 20	 imul	 eax, DWORD PTR _dim$[ebp]
  00aad	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  00ab1	03 c1		 add	 eax, ecx
  00ab3	0f bf 95 64 ff
	ff ff		 movsx	 edx, WORD PTR _c$[ebp]
  00aba	0f af 55 20	 imul	 edx, DWORD PTR _dim$[ebp]
  00abe	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  00ac2	03 d1		 add	 edx, ecx
  00ac4	8b 4d 88	 mov	 ecx, DWORD PTR _cand$[ebp]
  00ac7	8b 75 88	 mov	 esi, DWORD PTR _cand$[ebp]
  00aca	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  00acd	d8 64 96 fc	 fsub	 DWORD PTR [esi+edx*4-4]
  00ad1	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3c23d70a
  00ad7	df e0		 fnstsw	 ax
  00ad9	f6 c4 05	 test	 ah, 5
  00adc	7a 06		 jp	 SHORT $L1139

; 249  :             candBAD=1; 

  00ade	66 c7 45 a0 01
	00		 mov	 WORD PTR _candBAD$[ebp], 1
$L1139:

; 250  :          }
; 251  :       }

  00ae4	eb a7		 jmp	 SHORT $L1137
$L1138:

; 252  :       if (candBAD==0){

  00ae6	0f bf 55 a0	 movsx	 edx, WORD PTR _candBAD$[ebp]
  00aea	85 d2		 test	 edx, edx
  00aec	75 0d		 jne	 SHORT $L1140

; 253  :          bestIndex=c;

  00aee	66 8b 85 64 ff
	ff ff		 mov	 ax, WORD PTR _c$[ebp]
  00af5	66 89 45 94	 mov	 WORD PTR _bestIndex$[ebp], ax

; 254  :          break;

  00af9	eb 05		 jmp	 SHORT $L1135
$L1140:

; 255  :       }
; 256  :    }

  00afb	e9 5a ff ff ff	 jmp	 $L1134
$L1135:

; 257  :    if ((c>=numCand)&&(candBAD==1)){

  00b00	0f bf 8d 64 ff
	ff ff		 movsx	 ecx, WORD PTR _c$[ebp]
  00b07	0f bf 55 1c	 movsx	 edx, WORD PTR _numCand$[ebp]
  00b0b	3b ca		 cmp	 ecx, edx
  00b0d	0f 8c 85 00 00
	00		 jl	 $L1141
  00b13	0f bf 45 a0	 movsx	 eax, WORD PTR _candBAD$[ebp]
  00b17	83 f8 01	 cmp	 eax, 1
  00b1a	75 7c		 jne	 SHORT $L1141

; 258  :       bestIndex=0;

  00b1c	66 c7 45 94 00
	00		 mov	 WORD PTR _bestIndex$[ebp], 0

; 259  :       for (i=1;i<dim;i++){

  00b22	66 c7 45 e8 01
	00		 mov	 WORD PTR _i$[ebp], 1
  00b28	eb 0c		 jmp	 SHORT $L1142
$L1143:
  00b2a	66 8b 4d e8	 mov	 cx, WORD PTR _i$[ebp]
  00b2e	66 83 c1 01	 add	 cx, 1
  00b32	66 89 4d e8	 mov	 WORD PTR _i$[ebp], cx
$L1142:
  00b36	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  00b3a	3b 55 20	 cmp	 edx, DWORD PTR _dim$[ebp]
  00b3d	7d 59		 jge	 SHORT $L1141

; 260  :          if ((cand[c*dim+i]-cand[c*dim+i-1]) <LSPDIFF_THRESHOLD){

  00b3f	0f bf 85 64 ff
	ff ff		 movsx	 eax, WORD PTR _c$[ebp]
  00b46	0f af 45 20	 imul	 eax, DWORD PTR _dim$[ebp]
  00b4a	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  00b4e	03 c1		 add	 eax, ecx
  00b50	0f bf 95 64 ff
	ff ff		 movsx	 edx, WORD PTR _c$[ebp]
  00b57	0f af 55 20	 imul	 edx, DWORD PTR _dim$[ebp]
  00b5b	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  00b5f	03 d1		 add	 edx, ecx
  00b61	8b 4d 88	 mov	 ecx, DWORD PTR _cand$[ebp]
  00b64	8b 75 88	 mov	 esi, DWORD PTR _cand$[ebp]
  00b67	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  00b6a	d8 64 96 fc	 fsub	 DWORD PTR [esi+edx*4-4]
  00b6e	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3c23d70a
  00b74	df e0		 fnstsw	 ax
  00b76	f6 c4 05	 test	 ah, 5
  00b79	7a 1b		 jp	 SHORT $L1145

; 261  :             cand[i] = cand[i-1]+LSPDIFF_THRESHOLD;

  00b7b	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  00b7f	8b 45 88	 mov	 eax, DWORD PTR _cand$[ebp]
  00b82	d9 44 90 fc	 fld	 DWORD PTR [eax+edx*4-4]
  00b86	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3c23d70a
  00b8c	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  00b90	8b 55 88	 mov	 edx, DWORD PTR _cand$[ebp]
  00b93	d9 1c 8a	 fstp	 DWORD PTR [edx+ecx*4]
$L1145:

; 262  :          }
; 263  :       }

  00b96	eb 92		 jmp	 SHORT $L1143
$L1141:

; 264  :    }
; 265  :    for (r=0; r<dim; r++)

  00b98	66 c7 85 6c ff
	ff ff 00 00	 mov	 WORD PTR _r$[ebp], 0
  00ba1	eb 12		 jmp	 SHORT $L1146
$L1147:
  00ba3	66 8b 85 6c ff
	ff ff		 mov	 ax, WORD PTR _r$[ebp]
  00baa	66 05 01 00	 add	 ax, 1
  00bae	66 89 85 6c ff
	ff ff		 mov	 WORD PTR _r$[ebp], ax
$L1146:
  00bb5	0f bf 8d 6c ff
	ff ff		 movsx	 ecx, WORD PTR _r$[ebp]
  00bbc	3b 4d 20	 cmp	 ecx, DWORD PTR _dim$[ebp]
  00bbf	7d 2c		 jge	 SHORT $L1148

; 266  :       vectin[r] = cand[bestIndex*dim+r]*4000.0F;

  00bc1	0f bf 55 94	 movsx	 edx, WORD PTR _bestIndex$[ebp]
  00bc5	0f af 55 20	 imul	 edx, DWORD PTR _dim$[ebp]
  00bc9	0f bf 85 6c ff
	ff ff		 movsx	 eax, WORD PTR _r$[ebp]
  00bd0	03 d0		 add	 edx, eax
  00bd2	8b 4d 88	 mov	 ecx, DWORD PTR _cand$[ebp]
  00bd5	d9 04 91	 fld	 DWORD PTR [ecx+edx*4]
  00bd8	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@457a0000
  00bde	0f bf 95 6c ff
	ff ff		 movsx	 edx, WORD PTR _r$[ebp]
  00be5	8b 45 08	 mov	 eax, DWORD PTR _vectin$[ebp]
  00be8	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]
  00beb	eb b6		 jmp	 SHORT $L1147
$L1148:

; 267  :    
; 268  :    for (s=0; s<numStages; s++)

  00bed	66 c7 45 b4 00
	00		 mov	 WORD PTR _s$[ebp], 0
  00bf3	eb 0c		 jmp	 SHORT $L1149
$L1150:
  00bf5	66 8b 4d b4	 mov	 cx, WORD PTR _s$[ebp]
  00bf9	66 83 c1 01	 add	 cx, 1
  00bfd	66 89 4d b4	 mov	 WORD PTR _s$[ebp], cx
$L1149:
  00c01	0f bf 55 b4	 movsx	 edx, WORD PTR _s$[ebp]
  00c05	0f bf 45 18	 movsx	 eax, WORD PTR _numStages$[ebp]
  00c09	3b d0		 cmp	 edx, eax
  00c0b	7d 25		 jge	 SHORT $L1151

; 269  :       cbNdx[s] = index[bestIndex*numStages+s];

  00c0d	0f bf 4d 94	 movsx	 ecx, WORD PTR _bestIndex$[ebp]
  00c11	0f bf 55 18	 movsx	 edx, WORD PTR _numStages$[ebp]
  00c15	0f af ca	 imul	 ecx, edx
  00c18	0f bf 45 b4	 movsx	 eax, WORD PTR _s$[ebp]
  00c1c	03 c8		 add	 ecx, eax
  00c1e	0f bf 55 b4	 movsx	 edx, WORD PTR _s$[ebp]
  00c22	8b 45 10	 mov	 eax, DWORD PTR _cbNdx$[ebp]
  00c25	8b 75 ac	 mov	 esi, DWORD PTR _index$[ebp]
  00c28	66 8b 0c 4e	 mov	 cx, WORD PTR [esi+ecx*2]
  00c2c	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  00c30	eb c3		 jmp	 SHORT $L1150
$L1151:

; 270  : 
; 271  :    return 0;

  00c32	66 33 c0	 xor	 ax, ax

; 272  : } /* VQstfCoeffs */

  00c35	5e		 pop	 esi
  00c36	8b e5		 mov	 esp, ebp
  00c38	5d		 pop	 ebp
  00c39	c2 24 00	 ret	 36			; 00000024H
_VoxLspMSVQ@36 ENDP
_TEXT	ENDS
PUBLIC	_VoxDecLspMSVQ@20
; Function compile flags: /Odt
;	COMDAT _VoxDecLspMSVQ@20
_TEXT	SEGMENT
_j$ = -20
_s$ = -16
_i$ = -12
_ndx$ = -8
_tbl$ = -4
_index$ = 8
_vect$ = 12
_cb$ = 16
_dim$ = 20
_numStages$ = 24
_VoxDecLspMSVQ@20 PROC NEAR				; COMDAT

; 284  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi

; 285  :    int         i,j, s, ndx;
; 286  :    float	*tbl;
; 287  : 
; 288  :    for (i=0; i<dim;i++)

  00007	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000e	eb 09		 jmp	 SHORT $L1168
$L1169:
  00010	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00013	83 c0 01	 add	 eax, 1
  00016	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$L1168:
  00019	0f bf 4d 14	 movsx	 ecx, WORD PTR _dim$[ebp]
  0001d	39 4d f4	 cmp	 DWORD PTR _i$[ebp], ecx
  00020	7d 0f		 jge	 SHORT $L1170

; 289  :          vect[i] = 0.0F;

  00022	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00025	8b 45 0c	 mov	 eax, DWORD PTR _vect$[ebp]
  00028	c7 04 90 00 00
	00 00		 mov	 DWORD PTR [eax+edx*4], 0
  0002f	eb df		 jmp	 SHORT $L1169
$L1170:

; 290  : 
; 291  :    for (s=0; s<numStages; s++) {

  00031	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _s$[ebp], 0
  00038	eb 09		 jmp	 SHORT $L1171
$L1172:
  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _s$[ebp]
  0003d	83 c1 01	 add	 ecx, 1
  00040	89 4d f0	 mov	 DWORD PTR _s$[ebp], ecx
$L1171:
  00043	0f bf 55 18	 movsx	 edx, WORD PTR _numStages$[ebp]
  00047	39 55 f0	 cmp	 DWORD PTR _s$[ebp], edx
  0004a	7d 60		 jge	 SHORT $L1173

; 292  :        ndx = index[s];

  0004c	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00052	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00056	89 55 f8	 mov	 DWORD PTR _ndx$[ebp], edx

; 293  :        tbl = (float *)cb[s]+(ndx)*dim;

  00059	0f bf 45 14	 movsx	 eax, WORD PTR _dim$[ebp]
  0005d	8b 4d f8	 mov	 ecx, DWORD PTR _ndx$[ebp]
  00060	0f af c8	 imul	 ecx, eax
  00063	8b 55 f0	 mov	 edx, DWORD PTR _s$[ebp]
  00066	8b 45 10	 mov	 eax, DWORD PTR _cb$[ebp]
  00069	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  0006c	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0006f	89 45 fc	 mov	 DWORD PTR _tbl$[ebp], eax

; 294  :        for (i=0; i<dim; i++) 

  00072	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00079	eb 09		 jmp	 SHORT $L1175
$L1176:
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0007e	83 c1 01	 add	 ecx, 1
  00081	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$L1175:
  00084	0f bf 55 14	 movsx	 edx, WORD PTR _dim$[ebp]
  00088	39 55 f4	 cmp	 DWORD PTR _i$[ebp], edx
  0008b	7d 1d		 jge	 SHORT $L1177

; 295  :            vect[i] += tbl[i];

  0008d	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00090	8b 4d 0c	 mov	 ecx, DWORD PTR _vect$[ebp]
  00093	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00096	8b 75 fc	 mov	 esi, DWORD PTR _tbl$[ebp]
  00099	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  0009c	d8 04 96	 fadd	 DWORD PTR [esi+edx*4]
  0009f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000a2	8b 4d 0c	 mov	 ecx, DWORD PTR _vect$[ebp]
  000a5	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
  000a8	eb d1		 jmp	 SHORT $L1176
$L1177:

; 296  :    }

  000aa	eb 8e		 jmp	 SHORT $L1172
$L1173:

; 297  : 
; 298  : 
; 299  :    /* ********************************************************************
; 300  :       Note that we check to see if the quantized LSPs are stable, and if
; 301  :       not, we sort them so that they are stable.  The this "trick" is
; 302  :       (of course!) also used in the encoder.
; 303  :       ******************************************************************** */
; 304  :    i=1;    

  000ac	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
$L1179:

; 305  :    while (i<dim&&vect[i]>=vect[i-1]) i++;

  000b3	0f bf 55 14	 movsx	 edx, WORD PTR _dim$[ebp]
  000b7	39 55 f4	 cmp	 DWORD PTR _i$[ebp], edx
  000ba	7d 25		 jge	 SHORT $L1180
  000bc	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000bf	8b 4d 0c	 mov	 ecx, DWORD PTR _vect$[ebp]
  000c2	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000c5	8b 75 0c	 mov	 esi, DWORD PTR _vect$[ebp]
  000c8	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  000cb	d8 5c 96 fc	 fcomp	 DWORD PTR [esi+edx*4-4]
  000cf	df e0		 fnstsw	 ax
  000d1	f6 c4 01	 test	 ah, 1
  000d4	75 0b		 jne	 SHORT $L1180
  000d6	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000d9	83 c0 01	 add	 eax, 1
  000dc	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  000df	eb d2		 jmp	 SHORT $L1179
$L1180:

; 306  :    if (i<dim&&vect[i]<vect[i-1]) {

  000e1	0f bf 4d 14	 movsx	 ecx, WORD PTR _dim$[ebp]
  000e5	39 4d f4	 cmp	 DWORD PTR _i$[ebp], ecx
  000e8	0f 8d 92 00 00
	00		 jge	 $L1181
  000ee	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000f1	8b 45 0c	 mov	 eax, DWORD PTR _vect$[ebp]
  000f4	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000f7	8b 75 0c	 mov	 esi, DWORD PTR _vect$[ebp]
  000fa	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  000fd	d8 5c 8e fc	 fcomp	 DWORD PTR [esi+ecx*4-4]
  00101	df e0		 fnstsw	 ax
  00103	f6 c4 05	 test	 ah, 5
  00106	7a 78		 jp	 SHORT $L1181

; 307  :      for (j=2;j<=dim;j++) {

  00108	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _j$[ebp], 2
  0010f	eb 09		 jmp	 SHORT $L1182
$L1183:
  00111	8b 55 ec	 mov	 edx, DWORD PTR _j$[ebp]
  00114	83 c2 01	 add	 edx, 1
  00117	89 55 ec	 mov	 DWORD PTR _j$[ebp], edx
$L1182:
  0011a	0f bf 45 14	 movsx	 eax, WORD PTR _dim$[ebp]
  0011e	39 45 ec	 cmp	 DWORD PTR _j$[ebp], eax
  00121	7f 5d		 jg	 SHORT $L1181

; 308  :          i=j-1;

  00123	8b 4d ec	 mov	 ecx, DWORD PTR _j$[ebp]
  00126	83 e9 01	 sub	 ecx, 1
  00129	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$L1186:

; 309  :          while (i>0 && vect[i-1] > vect[j-1]) {

  0012c	83 7d f4 00	 cmp	 DWORD PTR _i$[ebp], 0
  00130	7e 39		 jle	 SHORT $L1187
  00132	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00135	8b 45 0c	 mov	 eax, DWORD PTR _vect$[ebp]
  00138	8b 4d ec	 mov	 ecx, DWORD PTR _j$[ebp]
  0013b	8b 75 0c	 mov	 esi, DWORD PTR _vect$[ebp]
  0013e	d9 44 90 fc	 fld	 DWORD PTR [eax+edx*4-4]
  00142	d8 5c 8e fc	 fcomp	 DWORD PTR [esi+ecx*4-4]
  00146	df e0		 fnstsw	 ax
  00148	f6 c4 41	 test	 ah, 65			; 00000041H
  0014b	75 1e		 jne	 SHORT $L1187

; 310  :            vect[i]=vect[i-1];

  0014d	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00150	8b 45 0c	 mov	 eax, DWORD PTR _vect$[ebp]
  00153	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00156	8b 75 0c	 mov	 esi, DWORD PTR _vect$[ebp]
  00159	8b 4c 8e fc	 mov	 ecx, DWORD PTR [esi+ecx*4-4]
  0015d	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 311  :            i--;

  00160	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00163	83 ea 01	 sub	 edx, 1
  00166	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx

; 312  :          }

  00169	eb c1		 jmp	 SHORT $L1186
$L1187:

; 313  :          vect[i]=vect[j-1];

  0016b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0016e	8b 4d 0c	 mov	 ecx, DWORD PTR _vect$[ebp]
  00171	8b 55 ec	 mov	 edx, DWORD PTR _j$[ebp]
  00174	8b 75 0c	 mov	 esi, DWORD PTR _vect$[ebp]
  00177	8b 54 96 fc	 mov	 edx, DWORD PTR [esi+edx*4-4]
  0017b	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 314  :      }

  0017e	eb 91		 jmp	 SHORT $L1183
$L1181:

; 315  :    }
; 316  :                   
; 317  :      for (i=1;i<dim;i++){

  00180	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00187	eb 09		 jmp	 SHORT $L1188
$L1189:
  00189	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0018c	83 c0 01	 add	 eax, 1
  0018f	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$L1188:
  00192	0f bf 4d 14	 movsx	 ecx, WORD PTR _dim$[ebp]
  00196	39 4d f4	 cmp	 DWORD PTR _i$[ebp], ecx
  00199	7d 3b		 jge	 SHORT $L1190

; 318  :          if ((vect[i]-vect[i-1]) < LSPDIFF_THRESHOLD)

  0019b	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0019e	8b 45 0c	 mov	 eax, DWORD PTR _vect$[ebp]
  001a1	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  001a4	8b 75 0c	 mov	 esi, DWORD PTR _vect$[ebp]
  001a7	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  001aa	d8 64 8e fc	 fsub	 DWORD PTR [esi+ecx*4-4]
  001ae	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3c23d70a
  001b4	df e0		 fnstsw	 ax
  001b6	f6 c4 05	 test	 ah, 5
  001b9	7a 19		 jp	 SHORT $L1191

; 319  :              vect[i] = vect[i-1]+LSPDIFF_THRESHOLD;

  001bb	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  001be	8b 45 0c	 mov	 eax, DWORD PTR _vect$[ebp]
  001c1	d9 44 90 fc	 fld	 DWORD PTR [eax+edx*4-4]
  001c5	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3c23d70a
  001cb	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  001ce	8b 55 0c	 mov	 edx, DWORD PTR _vect$[ebp]
  001d1	d9 1c 8a	 fstp	 DWORD PTR [edx+ecx*4]
$L1191:

; 320  :      }

  001d4	eb b3		 jmp	 SHORT $L1189
$L1190:

; 321  : 
; 322  :      /* un-normalize */
; 323  :      for (i=0; i<dim; i++)

  001d6	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001dd	eb 09		 jmp	 SHORT $L1192
$L1193:
  001df	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001e2	83 c0 01	 add	 eax, 1
  001e5	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$L1192:
  001e8	0f bf 4d 14	 movsx	 ecx, WORD PTR _dim$[ebp]
  001ec	39 4d f4	 cmp	 DWORD PTR _i$[ebp], ecx
  001ef	7d 1a		 jge	 SHORT $L1194

; 324  :          vect[i] *= (4000.0F);

  001f1	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  001f4	8b 45 0c	 mov	 eax, DWORD PTR _vect$[ebp]
  001f7	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  001fa	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@457a0000
  00200	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00203	8b 55 0c	 mov	 edx, DWORD PTR _vect$[ebp]
  00206	d9 1c 8a	 fstp	 DWORD PTR [edx+ecx*4]
  00209	eb d4		 jmp	 SHORT $L1193
$L1194:

; 325  : 
; 326  :      return 0;

  0020b	66 33 c0	 xor	 ax, ax

; 327  : 
; 328  : } /* DecodeMSVQcoeffs */

  0020e	5e		 pop	 esi
  0020f	8b e5		 mov	 esp, ebp
  00211	5d		 pop	 ebp
  00212	c2 14 00	 ret	 20			; 00000014H
_VoxDecLspMSVQ@20 ENDP
_TEXT	ENDS
PUBLIC	_VoxInitMSVQ@4
EXTRN	_calloc:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxInitMSVQ@4
_TEXT	SEGMENT
_pMSVQ_mblk$ = -4
_hMSVQ_mblk$ = 8
_VoxInitMSVQ@4 PROC NEAR				; COMDAT

; 332  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 333  :    MSVQ_mblk *pMSVQ_mblk;
; 334  : 
; 335  :    if (VOX_MEM_INIT(pMSVQ_mblk=*hMSVQ_mblk, 1, sizeof(MSVQ_mblk))) 

  00004	6a 24		 push	 36			; 00000024H
  00006	6a 01		 push	 1
  00008	e8 00 00 00 00	 call	 _calloc
  0000d	83 c4 08	 add	 esp, 8
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _hMSVQ_mblk$[ebp]
  00013	89 01		 mov	 DWORD PTR [ecx], eax
  00015	8b 55 08	 mov	 edx, DWORD PTR _hMSVQ_mblk$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	89 45 fc	 mov	 DWORD PTR _pMSVQ_mblk$[ebp], eax
  0001d	83 7d fc 00	 cmp	 DWORD PTR _pMSVQ_mblk$[ebp], 0
  00021	75 09		 jne	 SHORT $L1200

; 336  :       return 1;

  00023	66 b8 01 00	 mov	 ax, 1
  00027	e9 21 01 00 00	 jmp	 $L1197
$L1200:

; 337  : 
; 338  : 
; 339  :    if(VOX_MEM_INIT(pMSVQ_mblk->dMin,MAX_NUMCAND_MSVQ,sizeof(float))) 

  0002c	6a 04		 push	 4
  0002e	6a 10		 push	 16			; 00000010H
  00030	e8 00 00 00 00	 call	 _calloc
  00035	83 c4 08	 add	 esp, 8
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _pMSVQ_mblk$[ebp]
  0003b	89 01		 mov	 DWORD PTR [ecx], eax
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _pMSVQ_mblk$[ebp]
  00040	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00043	75 09		 jne	 SHORT $L1202

; 340  :       return 1;

  00045	66 b8 01 00	 mov	 ax, 1
  00049	e9 ff 00 00 00	 jmp	 $L1197
$L1202:

; 341  : 
; 342  :    if(VOX_MEM_INIT(pMSVQ_mblk->cand,MAX_NUMCANDxTABLEDIM_MSVQ,sizeof(float))) 

  0004e	6a 04		 push	 4
  00050	68 a0 00 00 00	 push	 160			; 000000a0H
  00055	e8 00 00 00 00	 call	 _calloc
  0005a	83 c4 08	 add	 esp, 8
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _pMSVQ_mblk$[ebp]
  00060	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00063	8b 55 fc	 mov	 edx, DWORD PTR _pMSVQ_mblk$[ebp]
  00066	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0006a	75 09		 jne	 SHORT $L1204

; 343  :       return 1;

  0006c	66 b8 01 00	 mov	 ax, 1
  00070	e9 d8 00 00 00	 jmp	 $L1197
$L1204:

; 344  : 
; 345  :    if(VOX_MEM_INIT(pMSVQ_mblk->index,MAX_NUMCANDxNUMSTAGES,sizeof(short))) 

  00075	6a 02		 push	 2
  00077	68 80 00 00 00	 push	 128			; 00000080H
  0007c	e8 00 00 00 00	 call	 _calloc
  00081	83 c4 08	 add	 esp, 8
  00084	8b 4d fc	 mov	 ecx, DWORD PTR _pMSVQ_mblk$[ebp]
  00087	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0008a	8b 55 fc	 mov	 edx, DWORD PTR _pMSVQ_mblk$[ebp]
  0008d	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00091	75 09		 jne	 SHORT $L1206

; 346  :       return 1;

  00093	66 b8 01 00	 mov	 ax, 1
  00097	e9 b1 00 00 00	 jmp	 $L1197
$L1206:

; 347  : 
; 348  :    if(VOX_MEM_INIT(pMSVQ_mblk->nextIndex,MAX_NUMCANDxNUMSTAGES,sizeof(short))) 

  0009c	6a 02		 push	 2
  0009e	68 80 00 00 00	 push	 128			; 00000080H
  000a3	e8 00 00 00 00	 call	 _calloc
  000a8	83 c4 08	 add	 esp, 8
  000ab	8b 4d fc	 mov	 ecx, DWORD PTR _pMSVQ_mblk$[ebp]
  000ae	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _pMSVQ_mblk$[ebp]
  000b4	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  000b8	75 09		 jne	 SHORT $L1208

; 349  :       return 1;

  000ba	66 b8 01 00	 mov	 ax, 1
  000be	e9 8a 00 00 00	 jmp	 $L1197
$L1208:

; 350  : 
; 351  :    if(VOX_MEM_INIT(pMSVQ_mblk->u,MAX_TABLEDIM_MSVQ,sizeof(float))) 

  000c3	6a 04		 push	 4
  000c5	6a 0a		 push	 10			; 0000000aH
  000c7	e8 00 00 00 00	 call	 _calloc
  000cc	83 c4 08	 add	 esp, 8
  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _pMSVQ_mblk$[ebp]
  000d2	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  000d5	8b 55 fc	 mov	 edx, DWORD PTR _pMSVQ_mblk$[ebp]
  000d8	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  000dc	75 06		 jne	 SHORT $L1210

; 352  :       return 1;

  000de	66 b8 01 00	 mov	 ax, 1
  000e2	eb 69		 jmp	 SHORT $L1197
$L1210:

; 353  : 
; 354  :    if(VOX_MEM_INIT(pMSVQ_mblk->lpc,MAX_TABLEDIM_MSVQ,sizeof(float))) 

  000e4	6a 04		 push	 4
  000e6	6a 0a		 push	 10			; 0000000aH
  000e8	e8 00 00 00 00	 call	 _calloc
  000ed	83 c4 08	 add	 esp, 8
  000f0	8b 4d fc	 mov	 ecx, DWORD PTR _pMSVQ_mblk$[ebp]
  000f3	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _pMSVQ_mblk$[ebp]
  000f9	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  000fd	75 06		 jne	 SHORT $L1212

; 355  :       return 1;

  000ff	66 b8 01 00	 mov	 ax, 1
  00103	eb 48		 jmp	 SHORT $L1197
$L1212:

; 356  :   
; 357  :    if(VOX_MEM_INIT(pMSVQ_mblk->newIndex,MAX_NUMCAND_MSVQ<<1,sizeof(short))) 

  00105	6a 02		 push	 2
  00107	6a 20		 push	 32			; 00000020H
  00109	e8 00 00 00 00	 call	 _calloc
  0010e	83 c4 08	 add	 esp, 8
  00111	8b 4d fc	 mov	 ecx, DWORD PTR _pMSVQ_mblk$[ebp]
  00114	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00117	8b 55 fc	 mov	 edx, DWORD PTR _pMSVQ_mblk$[ebp]
  0011a	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  0011e	75 06		 jne	 SHORT $L1214

; 358  :       return 1;

  00120	66 b8 01 00	 mov	 ax, 1
  00124	eb 27		 jmp	 SHORT $L1197
$L1214:

; 359  : 
; 360  :    if(VOX_MEM_INIT(pMSVQ_mblk->newresidue,MAX_NUMCANDxTABLEDIM_MSVQ,sizeof(float))) 

  00126	6a 04		 push	 4
  00128	68 a0 00 00 00	 push	 160			; 000000a0H
  0012d	e8 00 00 00 00	 call	 _calloc
  00132	83 c4 08	 add	 esp, 8
  00135	8b 4d fc	 mov	 ecx, DWORD PTR _pMSVQ_mblk$[ebp]
  00138	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  0013b	8b 55 fc	 mov	 edx, DWORD PTR _pMSVQ_mblk$[ebp]
  0013e	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  00142	75 06		 jne	 SHORT $L1216

; 361  :       return 1;

  00144	66 b8 01 00	 mov	 ax, 1
  00148	eb 03		 jmp	 SHORT $L1197
$L1216:

; 362  : 
; 363  :    return 0;

  0014a	66 33 c0	 xor	 ax, ax
$L1197:

; 364  : }

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 04 00	 ret	 4
_VoxInitMSVQ@4 ENDP
_TEXT	ENDS
PUBLIC	_VoxFreeMSVQ@4
EXTRN	_free:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxFreeMSVQ@4
_TEXT	SEGMENT
_myMSVQ_mblk$ = -4
_hMSVQ_mblk$ = 8
_VoxFreeMSVQ@4 PROC NEAR				; COMDAT

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 369  :    MSVQ_mblk *myMSVQ_mblk = (MSVQ_mblk *) *hMSVQ_mblk;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hMSVQ_mblk$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _myMSVQ_mblk$[ebp], ecx

; 370  : 
; 371  :    VOX_MEM_FREE(myMSVQ_mblk->dMin);

  0000c	8b 55 fc	 mov	 edx, DWORD PTR _myMSVQ_mblk$[ebp]
  0000f	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00012	74 17		 je	 SHORT $L1222
  00014	8b 45 fc	 mov	 eax, DWORD PTR _myMSVQ_mblk$[ebp]
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 _free
  0001f	83 c4 04	 add	 esp, 4
  00022	8b 55 fc	 mov	 edx, DWORD PTR _myMSVQ_mblk$[ebp]
  00025	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L1222:

; 372  :    VOX_MEM_FREE(myMSVQ_mblk->cand);

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _myMSVQ_mblk$[ebp]
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	74 19		 je	 SHORT $L1224
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _myMSVQ_mblk$[ebp]
  00037	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 _free
  00040	83 c4 04	 add	 esp, 4
  00043	8b 45 fc	 mov	 eax, DWORD PTR _myMSVQ_mblk$[ebp]
  00046	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L1224:

; 373  :    VOX_MEM_FREE(myMSVQ_mblk->index);

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _myMSVQ_mblk$[ebp]
  00050	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00054	74 19		 je	 SHORT $L1226
  00056	8b 55 fc	 mov	 edx, DWORD PTR _myMSVQ_mblk$[ebp]
  00059	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _free
  00062	83 c4 04	 add	 esp, 4
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _myMSVQ_mblk$[ebp]
  00068	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
$L1226:

; 374  :    VOX_MEM_FREE(myMSVQ_mblk->nextIndex);

  0006f	8b 55 fc	 mov	 edx, DWORD PTR _myMSVQ_mblk$[ebp]
  00072	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  00076	74 19		 je	 SHORT $L1228
  00078	8b 45 fc	 mov	 eax, DWORD PTR _myMSVQ_mblk$[ebp]
  0007b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 _free
  00084	83 c4 04	 add	 esp, 4
  00087	8b 55 fc	 mov	 edx, DWORD PTR _myMSVQ_mblk$[ebp]
  0008a	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
$L1228:

; 375  :    VOX_MEM_FREE(myMSVQ_mblk->lpc);

  00091	8b 45 fc	 mov	 eax, DWORD PTR _myMSVQ_mblk$[ebp]
  00094	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00098	74 19		 je	 SHORT $L1230
  0009a	8b 4d fc	 mov	 ecx, DWORD PTR _myMSVQ_mblk$[ebp]
  0009d	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 _free
  000a6	83 c4 04	 add	 esp, 4
  000a9	8b 45 fc	 mov	 eax, DWORD PTR _myMSVQ_mblk$[ebp]
  000ac	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
$L1230:

; 376  :    VOX_MEM_FREE(myMSVQ_mblk->u);

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _myMSVQ_mblk$[ebp]
  000b6	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  000ba	74 19		 je	 SHORT $L1232
  000bc	8b 55 fc	 mov	 edx, DWORD PTR _myMSVQ_mblk$[ebp]
  000bf	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _free
  000c8	83 c4 04	 add	 esp, 4
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _myMSVQ_mblk$[ebp]
  000ce	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
$L1232:

; 377  : 
; 378  :    VOX_MEM_FREE(myMSVQ_mblk->newIndex);

  000d5	8b 55 fc	 mov	 edx, DWORD PTR _myMSVQ_mblk$[ebp]
  000d8	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  000dc	74 19		 je	 SHORT $L1234
  000de	8b 45 fc	 mov	 eax, DWORD PTR _myMSVQ_mblk$[ebp]
  000e1	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000e4	51		 push	 ecx
  000e5	e8 00 00 00 00	 call	 _free
  000ea	83 c4 04	 add	 esp, 4
  000ed	8b 55 fc	 mov	 edx, DWORD PTR _myMSVQ_mblk$[ebp]
  000f0	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0
$L1234:

; 379  :    VOX_MEM_FREE(myMSVQ_mblk->newresidue);

  000f7	8b 45 fc	 mov	 eax, DWORD PTR _myMSVQ_mblk$[ebp]
  000fa	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  000fe	74 19		 je	 SHORT $L1236
  00100	8b 4d fc	 mov	 ecx, DWORD PTR _myMSVQ_mblk$[ebp]
  00103	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00106	52		 push	 edx
  00107	e8 00 00 00 00	 call	 _free
  0010c	83 c4 04	 add	 esp, 4
  0010f	8b 45 fc	 mov	 eax, DWORD PTR _myMSVQ_mblk$[ebp]
  00112	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
$L1236:

; 380  : 
; 381  :    VOX_MEM_FREE(*hMSVQ_mblk);

  00119	8b 4d 08	 mov	 ecx, DWORD PTR _hMSVQ_mblk$[ebp]
  0011c	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0011f	74 17		 je	 SHORT $L1238
  00121	8b 55 08	 mov	 edx, DWORD PTR _hMSVQ_mblk$[ebp]
  00124	8b 02		 mov	 eax, DWORD PTR [edx]
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 _free
  0012c	83 c4 04	 add	 esp, 4
  0012f	8b 4d 08	 mov	 ecx, DWORD PTR _hMSVQ_mblk$[ebp]
  00132	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L1238:

; 382  : 
; 383  :    return 0;

  00138	66 33 c0	 xor	 ax, ax

; 384  : }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 04 00	 ret	 4
_VoxFreeMSVQ@4 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _CalcWeightedMSE@16
_TEXT	SEGMENT
_weight$ = 8
_x$ = 12
_y$ = 16
_Len$ = 20
_CalcWeightedMSE@16 PROC NEAR				; COMDAT

; 389  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 390  :   _asm
; 391  :   {
; 392  :      mov ecx, Len;

  00006	8b 4d 14	 mov	 ecx, DWORD PTR _Len$[ebp]

; 393  :      mov esi, x;

  00009	8b 75 0c	 mov	 esi, DWORD PTR _x$[ebp]

; 394  :    
; 395  :      mov ebx, weight;

  0000c	8b 5d 08	 mov	 ebx, DWORD PTR _weight$[ebp]

; 396  :      mov edi, y;

  0000f	8b 7d 10	 mov	 edi, DWORD PTR _y$[ebp]

; 397  :    
; 398  :      fldz;

  00012	d9 ee		 fldz

; 399  :    
; 400  :      fld st(0);

  00014	d9 c0		 fld	 ST(0)
$loop1$1249:

; 401  : 
; 402  : loop1:
; 403  : 
; 404  :      faddp st(1), st(0);

  00016	de c1		 faddp	 ST(1), ST(0)

; 405  : 
; 406  :      /** difference **/
; 407  :      fld DWORD PTR[esi];

  00018	d9 06		 fld	 DWORD PTR [esi]

; 408  :    
; 409  :      fsub DWORD PTR[edi];

  0001a	d8 27		 fsub	 DWORD PTR [edi]

; 410  :    
; 411  :      fld DWORD PTR[esi+4];

  0001c	d9 46 04	 fld	 DWORD PTR [esi+4]

; 412  : 	  
; 413  : 	  fsub DWORD PTR[edi+4];

  0001f	d8 67 04	 fsub	 DWORD PTR [edi+4]

; 414  : 	  
; 415  : 	  fld DWORD PTR[esi+8];

  00022	d9 46 08	 fld	 DWORD PTR [esi+8]

; 416  : 
; 417  :      fsub DWORD PTR[edi+8];

  00025	d8 67 08	 fsub	 DWORD PTR [edi+8]

; 418  :  
; 419  :      fld DWORD PTR[esi+12];

  00028	d9 46 0c	 fld	 DWORD PTR [esi+12]

; 420  : 	  
; 421  : 	  fsub DWORD PTR[edi+12];

  0002b	d8 67 0c	 fsub	 DWORD PTR [edi+12]

; 422  : 	  
; 423  : 	  fld DWORD PTR[esi+16];

  0002e	d9 46 10	 fld	 DWORD PTR [esi+16]

; 424  : 
; 425  :      fsub DWORD PTR[edi+16];

  00031	d8 67 10	 fsub	 DWORD PTR [edi+16]

; 426  : 
; 427  :      /** square **/
; 428  :      fxch st(4);

  00034	d9 cc		 fxch	 ST(4)

; 429  :      fmul st(0), st(0);   /* 1 ~4 ~3 ~2 ~5 */

  00036	dc c8		 fmul	 ST(0), ST(0)

; 430  : 
; 431  :      fxch st(3);

  00038	d9 cb		 fxch	 ST(3)

; 432  :      fmul st(0), st(0);  /* 2,~4,~3 1, ~5 */

  0003a	dc c8		 fmul	 ST(0), ST(0)

; 433  : 
; 434  :      fxch st(2);

  0003c	d9 ca		 fxch	 ST(2)

; 435  :      fmul st(0), st(0);  /* 3 ~4, 2, 1, ~5 */

  0003e	dc c8		 fmul	 ST(0), ST(0)

; 436  : 
; 437  :      fxch st(1);

  00040	d9 c9		 fxch	 ST(1)

; 438  :      fmul st(0), st(0);  /* 4, 3, 2, 1, ~5 */

  00042	dc c8		 fmul	 ST(0), ST(0)

; 439  : 
; 440  :      fxch st(4);

  00044	d9 cc		 fxch	 ST(4)

; 441  :      fmul st(0), st(0);  /* 5, 3, 2, 1, 4 */

  00046	dc c8		 fmul	 ST(0), ST(0)

; 442  : 
; 443  :      /** multiple the weights **/
; 444  :      fxch st(3);         /* ~1, 3, 2, 5, 4 */

  00048	d9 cb		 fxch	 ST(3)

; 445  :      fmul DWORD PTR[ebx];

  0004a	d8 0b		 fmul	 DWORD PTR [ebx]

; 446  : 
; 447  :      fxch st(2);         /* ~2, 3, ~1, 5, 4 */

  0004c	d9 ca		 fxch	 ST(2)

; 448  :      fmul DWORD PTR[ebx+4];

  0004e	d8 4b 04	 fmul	 DWORD PTR [ebx+4]

; 449  : 
; 450  :      fxch st(1);

  00051	d9 c9		 fxch	 ST(1)

; 451  :      fmul DWORD PTR[ebx+8]; /* ~3, ~2, ~1, 5, 4 */

  00053	d8 4b 08	 fmul	 DWORD PTR [ebx+8]

; 452  : 
; 453  :      fxch st(4);

  00056	d9 cc		 fxch	 ST(4)

; 454  :      fmul DWORD PTR[ebx+12];/* ~4, ~2, ~1, 5, ~3 */

  00058	d8 4b 0c	 fmul	 DWORD PTR [ebx+12]

; 455  : 
; 456  :      fxch st(3);

  0005b	d9 cb		 fxch	 ST(3)

; 457  :      fmul DWORD PTR[ebx+16];/* ~5, ~2, ~1, ~4, ~3 */

  0005d	d8 4b 10	 fmul	 DWORD PTR [ebx+16]

; 458  : 
; 459  :      fxch st(2);

  00060	d9 ca		 fxch	 ST(2)

; 460  :      faddp st(5), st(0); /* 2, 5, 4, 3, 1+sum */

  00062	de c5		 faddp	 ST(5), ST(0)

; 461  : 
; 462  :      faddp st(3), st(0); /* 5,4, 3+2 1+sum */

  00064	de c3		 faddp	 ST(3), ST(0)

; 463  : 
; 464  :      faddp st(1), st(0); /* 4+5, 3+2, 1+sum */

  00066	de c1		 faddp	 ST(1), ST(0)

; 465  : 
; 466  :      add ebx, 20;

  00068	83 c3 14	 add	 ebx, 20			; 00000014H

; 467  :      add esi, 20;

  0006b	83 c6 14	 add	 esi, 20			; 00000014H

; 468  : 
; 469  :      add edi, 20;

  0006e	83 c7 14	 add	 edi, 20			; 00000014H

; 470  :      sub ecx, 5;

  00071	83 e9 05	 sub	 ecx, 5

; 471  : 
; 472  :      fxch st(2);         /* 1+sum, 3+2 , 4+5 */

  00074	d9 ca		 fxch	 ST(2)

; 473  :      faddp st(1), st(0); /* 1+sum+3+2, 4+5 */

  00076	de c1		 faddp	 ST(1), ST(0)

; 474  : 
; 475  :      jnz    loop1;

  00078	75 9c		 jne	 SHORT $loop1$1249

; 476  : 
; 477  :      faddp st(1), st(0); /* add to one term */

  0007a	de c1		 faddp	 ST(1), ST(0)

; 478  :   }
; 479  : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	5d		 pop	 ebp
  00080	c2 10 00	 ret	 16			; 00000010H
_CalcWeightedMSE@16 ENDP
_TEXT	ENDS
END
