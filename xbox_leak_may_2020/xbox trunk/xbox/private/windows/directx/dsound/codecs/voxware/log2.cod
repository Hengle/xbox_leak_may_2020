; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\log2.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _fLog2@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fInvLog2@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxfrExp@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxldExp@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_fLog2@4
PUBLIC	__real@3f800000
EXTRN	__fltused:NEAR
;	COMDAT __real@3f800000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\log2.c
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _fLog2@4
_TEXT	SEGMENT
_fLogB2$ = -12
_fMant$ = -8
_iExponent$ = -4
_fx$ = 8
_fLog2@4 PROC NEAR					; COMDAT

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 111  :   int    iExponent;
; 112  :   float  fLogB2;
; 113  :   float  fMant;
; 114  : 
; 115  :   /*------------------------------------------------------------
; 116  :     Change fx to fMant * 2**iExponent,  with 0.5 <= fMant < 1.0.
; 117  :   ------------------------------------------------------------*/
; 118  :   fMant = (float)VoxfrExp(fx, &iExponent);  

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iExponent$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _fx$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _VoxfrExp@8
  00013	d9 5d f8	 fstp	 DWORD PTR _fMant$[ebp]

; 119  : 
; 120  :   /*------------------------------------------------------------
; 121  :     Do linear interpolation.
; 122  :   ------------------------------------------------------------*/
; 123  :   fLogB2 = (float)iExponent + 2.0F*(fMant - 1.0F);

  00016	db 45 fc	 fild	 DWORD PTR _iExponent$[ebp]
  00019	d9 45 f8	 fld	 DWORD PTR _fMant$[ebp]
  0001c	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3f800000
  00022	dc c0		 fadd	 ST(0), ST(0)
  00024	de c1		 faddp	 ST(1), ST(0)
  00026	d9 55 f4	 fst	 DWORD PTR _fLogB2$[ebp]

; 124  : 
; 125  :   return (fLogB2);
; 126  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
_fLog2@4 ENDP
_TEXT	ENDS
PUBLIC	_fInvLog2@4
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
EXTRN	__ftol2:NEAR
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _fInvLog2@4
_TEXT	SEGMENT
tv66 = -20
_fLogMant$ = -16
_fMant$ = -12
_fx$ = -8
_iExponent$ = -4
_fLogB2$ = 8
_fInvLog2@4 PROC NEAR					; COMDAT

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 164  :   int   iExponent;
; 165  :   float fx, fLogMant, fMant;
; 166  : 
; 167  :   /*------------------------------------------------------------
; 168  :     Find exponent value.
; 169  :   ------------------------------------------------------------*/
; 170  :   iExponent = (int)VoxFLOOR(fLogB2)+1;

  00006	d9 45 08	 fld	 DWORD PTR _fLogB2$[ebp]
  00009	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  0000f	df e0		 fnstsw	 ax
  00011	f6 c4 01	 test	 ah, 1
  00014	75 08		 jne	 SHORT $L663
  00016	8b 45 08	 mov	 eax, DWORD PTR _fLogB2$[ebp]
  00019	89 45 ec	 mov	 DWORD PTR tv66[ebp], eax
  0001c	eb 0c		 jmp	 SHORT $L664
$L663:
  0001e	d9 45 08	 fld	 DWORD PTR _fLogB2$[ebp]
  00021	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3f800000
  00027	d9 5d ec	 fstp	 DWORD PTR tv66[ebp]
$L664:
  0002a	d9 45 ec	 fld	 DWORD PTR tv66[ebp]
  0002d	e8 00 00 00 00	 call	 __ftol2
  00032	83 c0 01	 add	 eax, 1
  00035	89 45 fc	 mov	 DWORD PTR _iExponent$[ebp], eax

; 171  : 
; 172  :   /*------------------------------------------------------------
; 173  :     compute mantissa which between 0.5 to 1.0 
; 174  :   ------------------------------------------------------------*/
; 175  :   fLogMant = fLogB2 - iExponent;      /* -1.0 <= fLogMant < 0.0 */

  00038	db 45 fc	 fild	 DWORD PTR _iExponent$[ebp]
  0003b	d8 6d 08	 fsubr	 DWORD PTR _fLogB2$[ebp]
  0003e	d9 5d f0	 fstp	 DWORD PTR _fLogMant$[ebp]

; 176  :   //assert((fLogMant < 0.0F) && (fLogMant >= -1.0F));
; 177  : 
; 178  :   fMant = 0.5F*fLogMant + 1.0F;       /* 0.5 <= fMant < 1.0 */

  00041	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000
  00047	d8 4d f0	 fmul	 DWORD PTR _fLogMant$[ebp]
  0004a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  00050	d9 5d f4	 fstp	 DWORD PTR _fMant$[ebp]

; 179  :   //assert((fMant < 1.0F) && (fMant >= 0.5F));
; 180  : 
; 181  :   /*------------------------------------------------------------
; 182  :     fx = fMant * 2**iExponent 
; 183  :   ------------------------------------------------------------*/
; 184  :   fx = (float)VoxldExp(fMant, iExponent);  

  00053	8b 4d fc	 mov	 ecx, DWORD PTR _iExponent$[ebp]
  00056	51		 push	 ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR _fMant$[ebp]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 _VoxldExp@8
  00060	d9 55 f8	 fst	 DWORD PTR _fx$[ebp]

; 185  :  
; 186  :   return ( fx );
; 187  : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_fInvLog2@4 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _VoxfrExp@8
_TEXT	SEGMENT
_ux$ = -12
_fMant$ = -8
_iExponent$ = -4
_fx$ = 8
_piExponent$ = 12
_VoxfrExp@8 PROC NEAR					; COMDAT

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 361  :   UnionFltInt ux;
; 362  :   int iExponent;
; 363  :   float fMant;
; 364  : 
; 365  :   /**** change the float to 32 bits int */
; 366  :   ux.f = fx;

  00006	8b 45 08	 mov	 eax, DWORD PTR _fx$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR _ux$[ebp], eax

; 367  :   /**** find the exponent by shifting out mantissa bits ****/
; 368  :   iExponent = (int)((ux.l & EXP_MASK) >> MANT_BITS);

  0000c	8b 4d f4	 mov	 ecx, DWORD PTR _ux$[ebp]
  0000f	81 e1 00 00 80
	7f		 and	 ecx, 2139095040		; 7f800000H
  00015	c1 f9 17	 sar	 ecx, 23			; 00000017H
  00018	89 4d fc	 mov	 DWORD PTR _iExponent$[ebp], ecx

; 369  :   iExponent -= EXP_OFFSET;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _iExponent$[ebp]
  0001e	83 ea 7f	 sub	 edx, 127		; 0000007fH
  00021	89 55 fc	 mov	 DWORD PTR _iExponent$[ebp], edx

; 370  :   
; 371  :   /**** find the mantissa part by masking out the exponent bits ****/
; 372  :   ux.l= (ux.l & MANT_MASK) | SHIFT_EXP_OFFSET;   /* 1.0 < ux.f < 2.0 */

  00024	8b 45 f4	 mov	 eax, DWORD PTR _ux$[ebp]
  00027	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  0002c	0d 00 00 80 3f	 or	 eax, 1065353216		; 3f800000H
  00031	89 45 f4	 mov	 DWORD PTR _ux$[ebp], eax

; 373  :   fMant = ux.f * 0.5F;   /*    0.5< fMant < 1.0 */

  00034	d9 45 f4	 fld	 DWORD PTR _ux$[ebp]
  00037	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  0003d	d9 5d f8	 fstp	 DWORD PTR _fMant$[ebp]

; 374  :   iExponent ++;        /*   normalize iExponent   */

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _iExponent$[ebp]
  00043	83 c1 01	 add	 ecx, 1
  00046	89 4d fc	 mov	 DWORD PTR _iExponent$[ebp], ecx

; 375  : 
; 376  :   *piExponent = iExponent;

  00049	8b 55 0c	 mov	 edx, DWORD PTR _piExponent$[ebp]
  0004c	8b 45 fc	 mov	 eax, DWORD PTR _iExponent$[ebp]
  0004f	89 02		 mov	 DWORD PTR [edx], eax

; 377  :   return fMant;

  00051	d9 45 f8	 fld	 DWORD PTR _fMant$[ebp]

; 378  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
_VoxfrExp@8 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _VoxldExp@8
_TEXT	SEGMENT
_ux$ = -12
_fx$ = -8
_lExponent$ = -4
_fMant$ = 8
_iExponent$ = 12
_VoxldExp@8 PROC NEAR					; COMDAT

; 399  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 400  :   UnionFltInt ux;
; 401  :   float fx;
; 402  :   long lExponent;
; 403  : 
; 404  :   /* reconstruct exponent part */
; 405  :   iExponent --;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _iExponent$[ebp]
  00009	83 e8 01	 sub	 eax, 1
  0000c	89 45 0c	 mov	 DWORD PTR _iExponent$[ebp], eax

; 406  :   lExponent = ((long)(iExponent+EXP_OFFSET)<<MANT_BITS) & EXP_MASK;

  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _iExponent$[ebp]
  00012	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00015	c1 e1 17	 shl	 ecx, 23			; 00000017H
  00018	81 e1 00 00 80
	7f		 and	 ecx, 2139095040		; 7f800000H
  0001e	89 4d fc	 mov	 DWORD PTR _lExponent$[ebp], ecx

; 407  : 
; 408  :   /* reconstruct mantissa part */
; 409  :   ux.f = fMant;

  00021	8b 55 08	 mov	 edx, DWORD PTR _fMant$[ebp]
  00024	89 55 f4	 mov	 DWORD PTR _ux$[ebp], edx

; 410  :   ux.l = (ux.l & MANT_MASK);

  00027	8b 45 f4	 mov	 eax, DWORD PTR _ux$[ebp]
  0002a	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  0002f	89 45 f4	 mov	 DWORD PTR _ux$[ebp], eax

; 411  : 
; 412  :   /* combine exponent and mantissa parts */
; 413  :   ux.l |= lExponent;

  00032	8b 4d f4	 mov	 ecx, DWORD PTR _ux$[ebp]
  00035	0b 4d fc	 or	 ecx, DWORD PTR _lExponent$[ebp]
  00038	89 4d f4	 mov	 DWORD PTR _ux$[ebp], ecx

; 414  : 
; 415  :   fx = ux.f;

  0003b	8b 55 f4	 mov	 edx, DWORD PTR _ux$[ebp]
  0003e	89 55 f8	 mov	 DWORD PTR _fx$[ebp], edx

; 416  : 
; 417  :   return fx;

  00041	d9 45 f8	 fld	 DWORD PTR _fx$[ebp]

; 418  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
_VoxldExp@8 ENDP
_TEXT	ENDS
END
