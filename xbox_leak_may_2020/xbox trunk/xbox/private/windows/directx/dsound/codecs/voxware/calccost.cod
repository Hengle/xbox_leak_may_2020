; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\calccost.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EB@FKLDAOEF@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@CBPJJMML@pfMag?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _CalcCostFunc@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_CalcCostFunc@20
PUBLIC	??_C@_0EB@FKLDAOEF@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	??_C@_0O@CBPJJMML@pfMag?5?$CB?$DN?5NULL?$AA@	; `string'
PUBLIC	__real@43000000
PUBLIC	__real@42800000
PUBLIC	__real@3f800000
PUBLIC	__real@3f000000
PUBLIC	__real@3ec00000
EXTRN	__assert:NEAR
EXTRN	_cosTBL_32:DWORD
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_0EB@FKLDAOEF@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\calccost.c
CONST	SEGMENT
??_C@_0EB@FKLDAOEF@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\calccost.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@ DB 'piPeakFreq != NULL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBPJJMML@pfMag?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0O@CBPJJMML@pfMag?5?$CB?$DN?5NULL?$AA@ DB 'pfMag != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ec00000
CONST	SEGMENT
__real@3ec00000 DD 03ec00000r			; 0.375
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _CalcCostFunc@20
_TEXT	SEGMENT
_lHarmF0$ = -56
_iHarmF0$ = -52
_uMaxMag$ = -48
_fHarmMag$ = -44
_fHarmPower$ = -40
_lScaledPitch$ = -36
_lTableIndex$ = -32
_lF0$ = -28
_fCrossCost$ = -24
_lRightBound$ = -20
_iPeaks$ = -16
_uPeakMag$ = -12
_i$ = -8
_lPitch$ = -4
_fPitch$ = 8
_piPeakFreq$ = 12
_pfMag$ = 16
_iNBand$ = 20
_fEngScale$ = 24
_CalcCostFunc@20 PROC NEAR				; COMDAT

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H

; 109  :   long lPitch, lScaledPitch;
; 110  :   long lF0, lHarmF0;
; 111  :   float fCrossCost, fHarmPower;
; 112  :   float fHarmMag;
; 113  :   long lRightBound, lTableIndex;
; 114  :   int iHarmF0;
; 115  :   int iPeaks;
; 116  :   int i;
; 117  :   UnionFltLng uMaxMag, uPeakMag;
; 118  : 
; 119  :   assert(piPeakFreq != NULL);

  00006	83 7d 0c 00	 cmp	 DWORD PTR _piPeakFreq$[ebp], 0
  0000a	75 14		 jne	 SHORT $L916
  0000c	6a 77		 push	 119			; 00000077H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@FKLDAOEF@c?3?2xbox?2private?2windows?2directx?2@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@
  00018	e8 00 00 00 00	 call	 __assert
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L916:

; 120  :   assert(pfMag != NULL);

  00020	83 7d 10 00	 cmp	 DWORD PTR _pfMag$[ebp], 0
  00024	75 14		 jne	 SHORT $L917
  00026	6a 78		 push	 120			; 00000078H
  00028	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@FKLDAOEF@c?3?2xbox?2private?2windows?2directx?2@
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@CBPJJMML@pfMag?5?$CB?$DN?5NULL?$AA@
  00032	e8 00 00 00 00	 call	 __assert
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$L917:

; 121  : 
; 122  :   /*------------------------------------------------------------
; 123  :     (1) Initializations.
; 124  :     ------------------------------------------------------------*/
; 125  :   /* initialize lPitch: shift fPitch by PITCH_SHIFT_BITS */
; 126  :   lPitch = (long)(fPitch*PITCH_SHIFT_SCALE);

  0003a	d9 45 08	 fld	 DWORD PTR _fPitch$[ebp]
  0003d	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@43000000
  00043	e8 00 00 00 00	 call	 __ftol2
  00048	89 45 fc	 mov	 DWORD PTR _lPitch$[ebp], eax

; 127  : 
; 128  :   /* initialize lScaledPitch: scaled lPitch by TRIG_SIZE over NFFT */
; 129  :   lScaledPitch = (long)(fPitch*SCALED_TABLE_SIZE_D_NFFT); 

  0004b	d9 45 08	 fld	 DWORD PTR _fPitch$[ebp]
  0004e	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@42800000
  00054	e8 00 00 00 00	 call	 __ftol2
  00059	89 45 dc	 mov	 DWORD PTR _lScaledPitch$[ebp], eax

; 130  : 
; 131  :   /* initialize lF0: shift F0=NFFT/fPitch by LDF0_SHIFT_BITS */
; 132  :   assert(F0_FFT_PITCH_SHIFT_BITS < 31);
; 133  :   lF0 = ((long)1<<F0_FFT_PITCH_SHIFT_BITS)/lPitch;

  0005c	b8 00 00 00 10	 mov	 eax, 268435456		; 10000000H
  00061	99		 cdq
  00062	f7 7d fc	 idiv	 DWORD PTR _lPitch$[ebp]
  00065	89 45 e4	 mov	 DWORD PTR _lF0$[ebp], eax

; 134  : 
; 135  :   /* lHarmF0: iHarm * lF0 */
; 136  :   lHarmF0 = lF0;

  00068	8b 55 e4	 mov	 edx, DWORD PTR _lF0$[ebp]
  0006b	89 55 c8	 mov	 DWORD PTR _lHarmF0$[ebp], edx

; 137  :   
; 138  :   /* initialize the accumulators: 
; 139  :      fCrossCosts -- sum of cross correlation term.
; 140  :      fHarmPower  -- sum of harmonics' power */
; 141  :   fCrossCost = EPS;

  0006e	c7 45 e8 95 95
	e6 24		 mov	 DWORD PTR _fCrossCost$[ebp], 619091349 ; 24e69595H

; 142  :   fHarmPower = EPS;

  00075	c7 45 d8 95 95
	e6 24		 mov	 DWORD PTR _fHarmPower$[ebp], 619091349 ; 24e69595H

; 143  : 
; 144  :   /*---------------------------------------------------------------
; 145  :     (2) Skip peak indices which are smaller than 0.5F0.
; 146  :     ---------------------------------------------------------------*/
; 147  :   /* lRightBound: mapped from harmonic's boundary to scaled 
; 148  :      Cosine table index. */
; 149  :   lRightBound = SCALED_HALF_TBL_SIZE;

  0007c	c7 45 ec 00 40
	00 00		 mov	 DWORD PTR _lRightBound$[ebp], 16384 ; 00004000H

; 150  :   iPeaks = 0;

  00083	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iPeaks$[ebp], 0

; 151  : 
; 152  :   /* lTableIndex: mapped to unwarped scaled Cosine table. 
; 153  :      This index should related to fPitch and peaks in frequency domain. */
; 154  :   lTableIndex = CALC_TAB_INDEX(piPeakFreq[iPeaks], lScaledPitch);

  0008a	8b 45 f0	 mov	 eax, DWORD PTR _iPeaks$[ebp]
  0008d	8b 4d 0c	 mov	 ecx, DWORD PTR _piPeakFreq$[ebp]
  00090	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00093	0f af 55 dc	 imul	 edx, DWORD PTR _lScaledPitch$[ebp]
  00097	89 55 e0	 mov	 DWORD PTR _lTableIndex$[ebp], edx
$L885:

; 155  : 
; 156  :   /* skip first few peaks ... */
; 157  :   while (lTableIndex < lRightBound)

  0009a	8b 45 e0	 mov	 eax, DWORD PTR _lTableIndex$[ebp]
  0009d	3b 45 ec	 cmp	 eax, DWORD PTR _lRightBound$[ebp]
  000a0	7d 1b		 jge	 SHORT $L886

; 158  :     lTableIndex = CALC_TAB_INDEX(piPeakFreq[++iPeaks], lScaledPitch);

  000a2	8b 4d f0	 mov	 ecx, DWORD PTR _iPeaks$[ebp]
  000a5	83 c1 01	 add	 ecx, 1
  000a8	89 4d f0	 mov	 DWORD PTR _iPeaks$[ebp], ecx
  000ab	8b 55 f0	 mov	 edx, DWORD PTR _iPeaks$[ebp]
  000ae	8b 45 0c	 mov	 eax, DWORD PTR _piPeakFreq$[ebp]
  000b1	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  000b4	0f af 4d dc	 imul	 ecx, DWORD PTR _lScaledPitch$[ebp]
  000b8	89 4d e0	 mov	 DWORD PTR _lTableIndex$[ebp], ecx
  000bb	eb dd		 jmp	 SHORT $L885
$L886:

; 159  : 
; 160  :   /*------------------------------------------------------------
; 161  :     (3) Compute fCrossCost and fHarmPower for all harmonics
; 162  :     within [0.5F0, iNBand].
; 163  :     ------------------------------------------------------------*/
; 164  : 
; 165  :   /* iHarmF0:  round(N * F0), N refers to number of harmonics */
; 166  :   iHarmF0 = (int)((lHarmF0+LDF0_SCALED_05) >> LDF0_SHIFT_BITS);

  000bd	8b 55 c8	 mov	 edx, DWORD PTR _lHarmF0$[ebp]
  000c0	81 c2 00 08 00
	00		 add	 edx, 2048		; 00000800H
  000c6	c1 fa 0c	 sar	 edx, 12			; 0000000cH
  000c9	89 55 cc	 mov	 DWORD PTR _iHarmF0$[ebp], edx
$L892:

; 167  : 
; 168  :   /* main loop: search all harmonics within [0.5F0, iNBand]. */
; 169  :   while (iHarmF0 < iNBand) 

  000cc	8b 45 cc	 mov	 eax, DWORD PTR _iHarmF0$[ebp]
  000cf	3b 45 14	 cmp	 eax, DWORD PTR _iNBand$[ebp]
  000d2	0f 8d b6 00 00
	00		 jge	 $L893

; 170  :     {
; 171  :       /* lRightBound: mapped from (N+0.5)*F0 to (N+0.5)*SCALED_TABLE_SIZE */
; 172  :       lRightBound += SCALED_TABLE_SIZE;

  000d8	8b 4d ec	 mov	 ecx, DWORD PTR _lRightBound$[ebp]
  000db	81 c1 00 80 00
	00		 add	 ecx, 32768		; 00008000H
  000e1	89 4d ec	 mov	 DWORD PTR _lRightBound$[ebp], ecx

; 173  : 
; 174  :       /* Find out the most confident peak within one harmonic band */
; 175  :       uMaxMag.f = EPS;

  000e4	c7 45 d0 95 95
	e6 24		 mov	 DWORD PTR _uMaxMag$[ebp], 619091349 ; 24e69595H
$L896:

; 176  : 
; 177  :       while (lTableIndex < lRightBound)

  000eb	8b 55 e0	 mov	 edx, DWORD PTR _lTableIndex$[ebp]
  000ee	3b 55 ec	 cmp	 edx, DWORD PTR _lRightBound$[ebp]
  000f1	7d 5b		 jge	 SHORT $L897

; 178  :         {
; 179  :           /* peak magnitude is scaled by 1+cos[i], where i can be calculated 
; 180  :            * by lTableIndex. And i refers to how closely the peak to center
; 181  :            * harmonic frequency. */
; 182  :           i = (int)((lTableIndex & SCALED_TABLE_MASK) >> PITCH_SHIFT_BITS);

  000f3	8b 45 e0	 mov	 eax, DWORD PTR _lTableIndex$[ebp]
  000f6	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  000fb	c1 f8 07	 sar	 eax, 7
  000fe	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 183  :           uPeakMag.f = pfMag[piPeakFreq[iPeaks]] * (1.0F+cosTBL_32[i]);

  00101	8b 4d f0	 mov	 ecx, DWORD PTR _iPeaks$[ebp]
  00104	8b 55 0c	 mov	 edx, DWORD PTR _piPeakFreq$[ebp]
  00107	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0010a	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0010d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _cosTBL_32
  00113	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  00119	d8 04 8a	 fadd	 DWORD PTR [edx+ecx*4]
  0011c	8b 4d 10	 mov	 ecx, DWORD PTR _pfMag$[ebp]
  0011f	d8 0c 81	 fmul	 DWORD PTR [ecx+eax*4]
  00122	d9 5d f4	 fstp	 DWORD PTR _uPeakMag$[ebp]

; 184  : 
; 185  :           if (uPeakMag.l > uMaxMag.l)

  00125	8b 55 f4	 mov	 edx, DWORD PTR _uPeakMag$[ebp]
  00128	3b 55 d0	 cmp	 edx, DWORD PTR _uMaxMag$[ebp]
  0012b	7e 06		 jle	 SHORT $L901

; 186  :              uMaxMag.l = uPeakMag.l;

  0012d	8b 45 f4	 mov	 eax, DWORD PTR _uPeakMag$[ebp]
  00130	89 45 d0	 mov	 DWORD PTR _uMaxMag$[ebp], eax
$L901:

; 187  : 
; 188  :           lTableIndex = CALC_TAB_INDEX(piPeakFreq[++iPeaks], lScaledPitch);

  00133	8b 4d f0	 mov	 ecx, DWORD PTR _iPeaks$[ebp]
  00136	83 c1 01	 add	 ecx, 1
  00139	89 4d f0	 mov	 DWORD PTR _iPeaks$[ebp], ecx
  0013c	8b 55 f0	 mov	 edx, DWORD PTR _iPeaks$[ebp]
  0013f	8b 45 0c	 mov	 eax, DWORD PTR _piPeakFreq$[ebp]
  00142	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00145	0f af 4d dc	 imul	 ecx, DWORD PTR _lScaledPitch$[ebp]
  00149	89 4d e0	 mov	 DWORD PTR _lTableIndex$[ebp], ecx

; 189  :         }

  0014c	eb 9d		 jmp	 SHORT $L896
$L897:

; 190  : 
; 191  :       /* accumulate fCrossCost and fHarmPower: */
; 192  :       fHarmMag = pfMag[iHarmF0];

  0014e	8b 55 cc	 mov	 edx, DWORD PTR _iHarmF0$[ebp]
  00151	8b 45 10	 mov	 eax, DWORD PTR _pfMag$[ebp]
  00154	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00157	89 4d d4	 mov	 DWORD PTR _fHarmMag$[ebp], ecx

; 193  :       fCrossCost += uMaxMag.f * fHarmMag;

  0015a	d9 45 d0	 fld	 DWORD PTR _uMaxMag$[ebp]
  0015d	d8 4d d4	 fmul	 DWORD PTR _fHarmMag$[ebp]
  00160	d8 45 e8	 fadd	 DWORD PTR _fCrossCost$[ebp]
  00163	d9 5d e8	 fstp	 DWORD PTR _fCrossCost$[ebp]

; 194  :       fHarmPower += fHarmMag * fHarmMag;

  00166	d9 45 d4	 fld	 DWORD PTR _fHarmMag$[ebp]
  00169	d8 4d d4	 fmul	 DWORD PTR _fHarmMag$[ebp]
  0016c	d8 45 d8	 fadd	 DWORD PTR _fHarmPower$[ebp]
  0016f	d9 5d d8	 fstp	 DWORD PTR _fHarmPower$[ebp]

; 195  : 
; 196  :       /* update lHarmF0 and iHarmF0 */
; 197  :       lHarmF0 += lF0;

  00172	8b 55 c8	 mov	 edx, DWORD PTR _lHarmF0$[ebp]
  00175	03 55 e4	 add	 edx, DWORD PTR _lF0$[ebp]
  00178	89 55 c8	 mov	 DWORD PTR _lHarmF0$[ebp], edx

; 198  :       iHarmF0 = (int)((lHarmF0+LDF0_SCALED_05)>>LDF0_SHIFT_BITS);

  0017b	8b 45 c8	 mov	 eax, DWORD PTR _lHarmF0$[ebp]
  0017e	05 00 08 00 00	 add	 eax, 2048		; 00000800H
  00183	c1 f8 0c	 sar	 eax, 12			; 0000000cH
  00186	89 45 cc	 mov	 DWORD PTR _iHarmF0$[ebp], eax

; 199  :     }

  00189	e9 3e ff ff ff	 jmp	 $L892
$L893:

; 200  : 
; 201  :   /* return the final likelyhood function. */
; 202  :   return  (fEngScale*(0.5F*fCrossCost - 0.375F*fHarmPower));

  0018e	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000
  00194	d8 4d e8	 fmul	 DWORD PTR _fCrossCost$[ebp]
  00197	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3ec00000
  0019d	d8 4d d8	 fmul	 DWORD PTR _fHarmPower$[ebp]
  001a0	de e9		 fsubp	 ST(1), ST(0)
  001a2	d8 4d 18	 fmul	 DWORD PTR _fEngScale$[ebp]

; 203  : } /* CalcCostFunc() */

  001a5	8b e5		 mov	 esp, ebp
  001a7	5d		 pop	 ebp
  001a8	c2 14 00	 ret	 20			; 00000014H
_CalcCostFunc@20 ENDP
_TEXT	ENDS
END
