; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\normwin.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EA@PHNAMGDL@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@EAPGIOEP@pfWindow?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _NormSymWindowByPower@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _NormSymWindowByArea@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_NormSymWindowByPower@8
PUBLIC	??_C@_0EA@PHNAMGDL@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BB@EAPGIOEP@pfWindow?5?$CB?$DN?5NULL?$AA@ ; `string'
EXTRN	__fltused:NEAR
EXTRN	__assert:NEAR
EXTRN	_sqrt:NEAR
;	COMDAT ??_C@_0EA@PHNAMGDL@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\normwin.c
CONST	SEGMENT
??_C@_0EA@PHNAMGDL@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\normwin.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EAPGIOEP@pfWindow?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BB@EAPGIOEP@pfWindow?5?$CB?$DN?5NULL?$AA@ DB 'pfWindow != NULL', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _NormSymWindowByPower@8
_TEXT	SEGMENT
_iHalfSize$ = -16
_fNormFactor$ = -12
_i$ = -8
_fWindowPower$ = -4
_pfWindow$ = 8
_iWindowSize$ = 12
_NormSymWindowByPower@8 PROC NEAR			; COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 64   :   int iHalfSize;
; 65   :   float fWindowPower, fNormFactor;
; 66   :   int i;
; 67   : 
; 68   :   iHalfSize = iWindowSize >> 1;

  00007	8b 45 0c	 mov	 eax, DWORD PTR _iWindowSize$[ebp]
  0000a	d1 f8		 sar	 eax, 1
  0000c	89 45 f0	 mov	 DWORD PTR _iHalfSize$[ebp], eax

; 69   : 
; 70   :   assert(pfWindow != NULL);

  0000f	83 7d 08 00	 cmp	 DWORD PTR _pfWindow$[ebp], 0
  00013	75 14		 jne	 SHORT $L1053
  00015	6a 46		 push	 70			; 00000046H
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@PHNAMGDL@c?3?2xbox?2private?2windows?2directx?2@
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@EAPGIOEP@pfWindow?5?$CB?$DN?5NULL?$AA@
  00021	e8 00 00 00 00	 call	 __assert
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1053:

; 71   : 
; 72   :   /**** compute the left half size of window Power *****/
; 73   :   fWindowPower = 0.0F;

  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fWindowPower$[ebp], 0

; 74   :   for (i = 0; i < iHalfSize; i++)

  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00037	eb 09		 jmp	 SHORT $L1016
$L1017:
  00039	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0003c	83 c2 01	 add	 edx, 1
  0003f	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L1016:
  00042	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00045	3b 45 f0	 cmp	 eax, DWORD PTR _iHalfSize$[ebp]
  00048	7d 1a		 jge	 SHORT $L1018

; 75   :     fWindowPower += pfWindow[i] * pfWindow[i];

  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _pfWindow$[ebp]
  00050	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00053	8b 75 08	 mov	 esi, DWORD PTR _pfWindow$[ebp]
  00056	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  00059	d8 0c 86	 fmul	 DWORD PTR [esi+eax*4]
  0005c	d8 45 fc	 fadd	 DWORD PTR _fWindowPower$[ebp]
  0005f	d9 5d fc	 fstp	 DWORD PTR _fWindowPower$[ebp]
  00062	eb d5		 jmp	 SHORT $L1017
$L1018:

; 76   : 
; 77   :   /**** add the right half size of window Power *****/
; 78   :   fWindowPower *= 2.0F;

  00064	d9 45 fc	 fld	 DWORD PTR _fWindowPower$[ebp]
  00067	dc c0		 fadd	 ST(0), ST(0)
  00069	d9 5d fc	 fstp	 DWORD PTR _fWindowPower$[ebp]

; 79   : 
; 80   :   /**** consider the center point *****/
; 81   :   if (iWindowSize & 1)

  0006c	8b 4d 0c	 mov	 ecx, DWORD PTR _iWindowSize$[ebp]
  0006f	83 e1 01	 and	 ecx, 1
  00072	85 c9		 test	 ecx, ecx
  00074	74 18		 je	 SHORT $L1019

; 82   :     fWindowPower += pfWindow[iHalfSize] * pfWindow[iHalfSize];

  00076	8b 55 f0	 mov	 edx, DWORD PTR _iHalfSize$[ebp]
  00079	8b 45 08	 mov	 eax, DWORD PTR _pfWindow$[ebp]
  0007c	8b 4d f0	 mov	 ecx, DWORD PTR _iHalfSize$[ebp]
  0007f	8b 75 08	 mov	 esi, DWORD PTR _pfWindow$[ebp]
  00082	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  00085	d8 0c 8e	 fmul	 DWORD PTR [esi+ecx*4]
  00088	d8 45 fc	 fadd	 DWORD PTR _fWindowPower$[ebp]
  0008b	d9 5d fc	 fstp	 DWORD PTR _fWindowPower$[ebp]
$L1019:

; 83   : 
; 84   :   /***** compute the normalization factor *****/
; 85   :   fNormFactor = (float)sqrt((float)iWindowSize/fWindowPower);

  0008e	db 45 0c	 fild	 DWORD PTR _iWindowSize$[ebp]
  00091	d8 75 fc	 fdiv	 DWORD PTR _fWindowPower$[ebp]
  00094	83 ec 08	 sub	 esp, 8
  00097	dd 1c 24	 fstp	 QWORD PTR [esp]
  0009a	e8 00 00 00 00	 call	 _sqrt
  0009f	83 c4 08	 add	 esp, 8
  000a2	d9 5d f4	 fstp	 DWORD PTR _fNormFactor$[ebp]

; 86   :   
; 87   :   /***** apply the normalization factor to the window *****/
; 88   :   for (i = 0; i < iHalfSize; i++)

  000a5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ac	eb 09		 jmp	 SHORT $L1022
$L1023:
  000ae	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000b1	83 c2 01	 add	 edx, 1
  000b4	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L1022:
  000b7	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ba	3b 45 f0	 cmp	 eax, DWORD PTR _iHalfSize$[ebp]
  000bd	7d 17		 jge	 SHORT $L1024

; 89   :     pfWindow[i] *= fNormFactor;

  000bf	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000c2	8b 55 08	 mov	 edx, DWORD PTR _pfWindow$[ebp]
  000c5	d9 45 f4	 fld	 DWORD PTR _fNormFactor$[ebp]
  000c8	d8 0c 8a	 fmul	 DWORD PTR [edx+ecx*4]
  000cb	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ce	8b 4d 08	 mov	 ecx, DWORD PTR _pfWindow$[ebp]
  000d1	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
  000d4	eb d8		 jmp	 SHORT $L1023
$L1024:

; 90   : 
; 91   :   if (iWindowSize & 1)

  000d6	8b 55 0c	 mov	 edx, DWORD PTR _iWindowSize$[ebp]
  000d9	83 e2 01	 and	 edx, 1
  000dc	85 d2		 test	 edx, edx
  000de	74 15		 je	 SHORT $L1007

; 92   :     pfWindow[i] *= fNormFactor;

  000e0	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _pfWindow$[ebp]
  000e6	d9 45 f4	 fld	 DWORD PTR _fNormFactor$[ebp]
  000e9	d8 0c 81	 fmul	 DWORD PTR [ecx+eax*4]
  000ec	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000ef	8b 45 08	 mov	 eax, DWORD PTR _pfWindow$[ebp]
  000f2	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]
$L1007:

; 93   : }

  000f5	5e		 pop	 esi
  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c2 08 00	 ret	 8
_NormSymWindowByPower@8 ENDP
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	_NormSymWindowByArea@8
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _NormSymWindowByArea@8
_TEXT	SEGMENT
_iHalfSize$ = -16
_fWindowArea$ = -12
_fNormFactor$ = -8
_i$ = -4
_pfWindow$ = 8
_iWindowSize$ = 12
_NormSymWindowByArea@8 PROC NEAR			; COMDAT

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 112  :   int iHalfSize;
; 113  :   float fWindowArea, fNormFactor;
; 114  :   int i;
; 115  : 
; 116  :   iHalfSize = iWindowSize >> 1;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _iWindowSize$[ebp]
  00009	d1 f8		 sar	 eax, 1
  0000b	89 45 f0	 mov	 DWORD PTR _iHalfSize$[ebp], eax

; 117  : 
; 118  :   /**** compute the left half size of window area function ****/
; 119  :   fWindowArea = 0.0F;

  0000e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fWindowArea$[ebp], 0

; 120  :   for (i = 0; i < iHalfSize; i++)

  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001c	eb 09		 jmp	 SHORT $L1035
$L1036:
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00021	83 c1 01	 add	 ecx, 1
  00024	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L1035:
  00027	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002a	3b 55 f0	 cmp	 edx, DWORD PTR _iHalfSize$[ebp]
  0002d	7d 11		 jge	 SHORT $L1037

; 121  :     fWindowArea += pfWindow[i];

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _pfWindow$[ebp]
  00035	d9 45 f4	 fld	 DWORD PTR _fWindowArea$[ebp]
  00038	d8 04 81	 fadd	 DWORD PTR [ecx+eax*4]
  0003b	d9 5d f4	 fstp	 DWORD PTR _fWindowArea$[ebp]
  0003e	eb de		 jmp	 SHORT $L1036
$L1037:

; 122  : 
; 123  :   /**** add the right half size of window energy *****/
; 124  :   fWindowArea *= 2.0F;

  00040	d9 45 f4	 fld	 DWORD PTR _fWindowArea$[ebp]
  00043	dc c0		 fadd	 ST(0), ST(0)
  00045	d9 5d f4	 fstp	 DWORD PTR _fWindowArea$[ebp]

; 125  : 
; 126  :   /**** consider the center point *****/
; 127  :   if (iWindowSize & 1)

  00048	8b 55 0c	 mov	 edx, DWORD PTR _iWindowSize$[ebp]
  0004b	83 e2 01	 and	 edx, 1
  0004e	85 d2		 test	 edx, edx
  00050	74 0f		 je	 SHORT $L1038

; 128  :     fWindowArea += pfWindow[iHalfSize];

  00052	8b 45 f0	 mov	 eax, DWORD PTR _iHalfSize$[ebp]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _pfWindow$[ebp]
  00058	d9 45 f4	 fld	 DWORD PTR _fWindowArea$[ebp]
  0005b	d8 04 81	 fadd	 DWORD PTR [ecx+eax*4]
  0005e	d9 5d f4	 fstp	 DWORD PTR _fWindowArea$[ebp]
$L1038:

; 129  : 
; 130  :   /***** compute the normalization factor *****/
; 131  :   fNormFactor = 1.0F/fWindowArea;

  00061	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  00067	d8 75 f4	 fdiv	 DWORD PTR _fWindowArea$[ebp]
  0006a	d9 5d f8	 fstp	 DWORD PTR _fNormFactor$[ebp]

; 132  :   
; 133  :   /***** apply the normalization factor to the window *****/
; 134  :   for (i = 0; i < iHalfSize; i++)

  0006d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00074	eb 09		 jmp	 SHORT $L1039
$L1040:
  00076	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00079	83 c2 01	 add	 edx, 1
  0007c	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L1039:
  0007f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00082	3b 45 f0	 cmp	 eax, DWORD PTR _iHalfSize$[ebp]
  00085	7d 17		 jge	 SHORT $L1041

; 135  :     pfWindow[i] *= fNormFactor;

  00087	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0008a	8b 55 08	 mov	 edx, DWORD PTR _pfWindow$[ebp]
  0008d	d9 45 f8	 fld	 DWORD PTR _fNormFactor$[ebp]
  00090	d8 0c 8a	 fmul	 DWORD PTR [edx+ecx*4]
  00093	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _pfWindow$[ebp]
  00099	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
  0009c	eb d8		 jmp	 SHORT $L1040
$L1041:

; 136  :   if (iWindowSize & 1)

  0009e	8b 55 0c	 mov	 edx, DWORD PTR _iWindowSize$[ebp]
  000a1	83 e2 01	 and	 edx, 1
  000a4	85 d2		 test	 edx, edx
  000a6	74 15		 je	 SHORT $L1030

; 137  :     pfWindow[i] *= fNormFactor;

  000a8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ab	8b 4d 08	 mov	 ecx, DWORD PTR _pfWindow$[ebp]
  000ae	d9 45 f8	 fld	 DWORD PTR _fNormFactor$[ebp]
  000b1	d8 0c 81	 fmul	 DWORD PTR [ecx+eax*4]
  000b4	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000b7	8b 45 08	 mov	 eax, DWORD PTR _pfWindow$[ebp]
  000ba	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]
$L1030:

; 138  : }

  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 08 00	 ret	 8
_NormSymWindowByArea@8 ENDP
_TEXT	ENDS
END
