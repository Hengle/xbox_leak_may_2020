; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\ptchcand.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@CBPJJMML@pfMag?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@IGCCJIDJ@pfPitchCand?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@FIDFLIFO@piHP_Index?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@DHIBENDA@pfCostFunc?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@HDNLJLMD@pfNewBackCost?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@KEJBFKEF@piIndCand?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@CDPBMAEK@piHPIndex?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@GNKIGEMB@piNumCand?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@FBAJAPB@pfMaxCost?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _SelectPitchCandidates@32
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _BackWard_Check@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _HarmThreshold@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _EliminateSmallP0@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _AddBackTrackCand@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _RefineLDPitch@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	__real@358637bd
PUBLIC	__real@41200000
PUBLIC	__real@3f000000
PUBLIC	_SelectPitchCandidates@32
PUBLIC	??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0O@CBPJJMML@pfMag?5?$CB?$DN?5NULL?$AA@	; `string'
PUBLIC	??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	??_C@_0BE@IGCCJIDJ@pfPitchCand?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	??_C@_0BD@FIDFLIFO@piHP_Index?5?$CB?$DN?5NULL?$AA@ ; `string'
EXTRN	__fltused:NEAR
EXTRN	__assert:NEAR
EXTRN	_DotProd@12:NEAR
EXTRN	_CalcCostFunc@20:NEAR
EXTRN	_CpfPitchTable:BYTE
;	COMDAT ??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\ptchcand.c
CONST	SEGMENT
??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\ptchcand.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBPJJMML@pfMag?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0O@CBPJJMML@pfMag?5?$CB?$DN?5NULL?$AA@ DB 'pfMag != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@ DB 'piPeakFreq != NULL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IGCCJIDJ@pfPitchCand?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BE@IGCCJIDJ@pfPitchCand?5?$CB?$DN?5NULL?$AA@ DB 'pfPitchCand != NU'
	DB	'LL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FIDFLIFO@piHP_Index?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BD@FIDFLIFO@piHP_Index?5?$CB?$DN?5NULL?$AA@ DB 'piHP_Index != NULL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __real@358637bd
CONST	SEGMENT
__real@358637bd DD 0358637bdr			; 1e-006
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _SelectPitchCandidates@32
_TEXT	SEGMENT
tv186 = -440
_a$1024 = -436
_a$1023 = -432
_fNewBackCost$ = -428
_fNormEnergy$ = -424
_iBackIndex$ = -420
_iNumCand$ = -416
_iNumCand_1$ = -412
_k$ = -408
_iIndex$ = -404
_piCandInd_0$ = -400
_pfCostFunc$ = -376
_i$ = -12
_iHP_Index$ = -8
_fCost$ = -4
_pfMag$ = 8
_iBaseBand$ = 12
_piPeakFreq$ = 16
_pfPitchCand$ = 20
_pfCandCost$ = 24
_fLastP0$ = 28
_fLastCost$ = 32
_piHP_Index$ = 36
_SelectPitchCandidates@32 PROC NEAR			; COMDAT

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 01 00
	00		 sub	 esp, 440		; 000001b8H

; 145  :   int iBackIndex;
; 146  :   float fNewBackCost;
; 147  :   int iNumCand, iNumCand_1;
; 148  :   int i, k;
; 149  :   int iHP_Index;
; 150  :   float fCost;
; 151  :   int iIndex;
; 152  :   float fNormEnergy;
; 153  : 
; 154  : STACK_INIT
; 155  :   int piCandInd_0[SUB_MAX+1];
; 156  :   float pfCostFunc[PITCH_TABLE_SIZE];
; 157  : STACK_INIT_END
; 158  : 
; 159  : STACK_ATTACH(int *, piCandInd_0)
; 160  : STACK_ATTACH(float *, pfCostFunc)
; 161  : 
; 162  : STACK_START
; 163  : 
; 164  :   assert(pfMag != NULL);

  00009	83 7d 08 00	 cmp	 DWORD PTR _pfMag$[ebp], 0
  0000d	75 17		 jne	 SHORT $L1231
  0000f	68 a4 00 00 00	 push	 164			; 000000a4H
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@CBPJJMML@pfMag?5?$CB?$DN?5NULL?$AA@
  0001e	e8 00 00 00 00	 call	 __assert
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1231:

; 165  :   assert(piPeakFreq != NULL);

  00026	83 7d 10 00	 cmp	 DWORD PTR _piPeakFreq$[ebp], 0
  0002a	75 17		 jne	 SHORT $L1232
  0002c	68 a5 00 00 00	 push	 165			; 000000a5H
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00036	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@
  0003b	e8 00 00 00 00	 call	 __assert
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1232:

; 166  :   assert(pfPitchCand != NULL);

  00043	83 7d 14 00	 cmp	 DWORD PTR _pfPitchCand$[ebp], 0
  00047	75 17		 jne	 SHORT $L1233
  00049	68 a6 00 00 00	 push	 166			; 000000a6H
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@IGCCJIDJ@pfPitchCand?5?$CB?$DN?5NULL?$AA@
  00058	e8 00 00 00 00	 call	 __assert
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1233:

; 167  :   assert(piHP_Index != NULL);

  00060	83 7d 24 00	 cmp	 DWORD PTR _piHP_Index$[ebp], 0
  00064	75 17		 jne	 SHORT $L1234
  00066	68 a7 00 00 00	 push	 167			; 000000a7H
  0006b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00070	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@FIDFLIFO@piHP_Index?5?$CB?$DN?5NULL?$AA@
  00075	e8 00 00 00 00	 call	 __assert
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1234:

; 168  : 
; 169  :   /*----------------------------------------------------------------------
; 170  :     (0) Compute normalization factor .
; 171  :     ----------------------------------------------------------------------*/
; 172  :   fNormEnergy = MINCON + DotProd(pfMag, pfMag, iBaseBand);

  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR _iBaseBand$[ebp]
  00080	51		 push	 ecx
  00081	8b 55 08	 mov	 edx, DWORD PTR _pfMag$[ebp]
  00084	52		 push	 edx
  00085	8b 45 08	 mov	 eax, DWORD PTR _pfMag$[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _DotProd@12
  0008e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@358637bd
  00094	d9 9d 58 fe ff
	ff		 fstp	 DWORD PTR _fNormEnergy$[ebp]

; 173  :   
; 174  :   fNormEnergy = 10.0F/fNormEnergy;

  0009a	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@41200000
  000a0	d8 b5 58 fe ff
	ff		 fdiv	 DWORD PTR _fNormEnergy$[ebp]
  000a6	d9 9d 58 fe ff
	ff		 fstp	 DWORD PTR _fNormEnergy$[ebp]

; 175  : 
; 176  :   /*----------------------------------------------------------------------
; 177  :     (1) Compute the cost function (or likelyhood function) of all pitch
; 178  :         candidates.
; 179  :     ----------------------------------------------------------------------*/
; 180  :   for (i = 0; i < PITCH_TABLE_SIZE; i++)

  000ac	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000b3	eb 09		 jmp	 SHORT $L1020
$L1021:
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000b8	83 c1 01	 add	 ecx, 1
  000bb	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$L1020:
  000be	83 7d f4 59	 cmp	 DWORD PTR _i$[ebp], 89	; 00000059H
  000c2	7d 2f		 jge	 SHORT $L1022

; 181  :     pfCostFunc[i] = CalcCostFunc(CpfPitchTable[i], piPeakFreq, pfMag,
; 182  :                                  iBaseBand, fNormEnergy);

  000c4	8b 95 58 fe ff
	ff		 mov	 edx, DWORD PTR _fNormEnergy$[ebp]
  000ca	52		 push	 edx
  000cb	8b 45 0c	 mov	 eax, DWORD PTR _iBaseBand$[ebp]
  000ce	50		 push	 eax
  000cf	8b 4d 08	 mov	 ecx, DWORD PTR _pfMag$[ebp]
  000d2	51		 push	 ecx
  000d3	8b 55 10	 mov	 edx, DWORD PTR _piPeakFreq$[ebp]
  000d6	52		 push	 edx
  000d7	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000da	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _CpfPitchTable[eax*4]
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 _CalcCostFunc@20
  000e7	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000ea	d9 9c 95 88 fe
	ff ff		 fstp	 DWORD PTR _pfCostFunc$[ebp+edx*4]
  000f1	eb c2		 jmp	 SHORT $L1021
$L1022:

; 183  : 
; 184  : 
; 185  :   /*----------------------------------------------------------------------
; 186  :     (2) Backward tracking and modify the cost function for pre-selection.
; 187  :     ----------------------------------------------------------------------*/
; 188  :   iBackIndex = BackWard_Check(pfCostFunc, fLastP0, fLastCost,
; 189  :                               &fNewBackCost);

  000f3	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _fNewBackCost$[ebp]
  000f9	50		 push	 eax
  000fa	8b 4d 20	 mov	 ecx, DWORD PTR _fLastCost$[ebp]
  000fd	51		 push	 ecx
  000fe	8b 55 1c	 mov	 edx, DWORD PTR _fLastP0$[ebp]
  00101	52		 push	 edx
  00102	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _pfCostFunc$[ebp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _BackWard_Check@16
  0010e	89 85 5c fe ff
	ff		 mov	 DWORD PTR _iBackIndex$[ebp], eax

; 190  : 
; 191  : 
; 192  :   /*----------------------------------------------------------------------
; 193  :     (3) Replace the cost value of iBackIndex using fNewBackCost.
; 194  :     Then extract good pitch candidates using progressive harmonic thresholding.
; 195  :     Then change back to the original value.
; 196  :     ----------------------------------------------------------------------*/
; 197  : 
; 198  :   /*----------------------------------------------------------------------
; 199  :     Get the regular candidates using Harmonic Progressive thresholding.
; 200  :     ----------------------------------------------------------------------*/
; 201  :   ExchangeFltValue(fNewBackCost, pfCostFunc[iBackIndex]);

  00114	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _fNewBackCost$[ebp]
  0011a	89 8d 50 fe ff
	ff		 mov	 DWORD PTR _a$1023[ebp], ecx
  00120	8b 95 5c fe ff
	ff		 mov	 edx, DWORD PTR _iBackIndex$[ebp]
  00126	8b 84 95 88 fe
	ff ff		 mov	 eax, DWORD PTR _pfCostFunc$[ebp+edx*4]
  0012d	89 85 54 fe ff
	ff		 mov	 DWORD PTR _fNewBackCost$[ebp], eax
  00133	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR _iBackIndex$[ebp]
  00139	8b 95 50 fe ff
	ff		 mov	 edx, DWORD PTR _a$1023[ebp]
  0013f	89 94 8d 88 fe
	ff ff		 mov	 DWORD PTR _pfCostFunc$[ebp+ecx*4], edx

; 202  : 
; 203  :   iNumCand = HarmThreshold(pfCostFunc, piCandInd_0, &iHP_Index);

  00146	8d 45 f8	 lea	 eax, DWORD PTR _iHP_Index$[ebp]
  00149	50		 push	 eax
  0014a	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _piCandInd_0$[ebp]
  00150	51		 push	 ecx
  00151	8d 95 88 fe ff
	ff		 lea	 edx, DWORD PTR _pfCostFunc$[ebp]
  00157	52		 push	 edx
  00158	e8 00 00 00 00	 call	 _HarmThreshold@12
  0015d	89 85 60 fe ff
	ff		 mov	 DWORD PTR _iNumCand$[ebp], eax

; 204  :   
; 205  :   /*----------------------------------------------------------------------
; 206  :     Prevent pick up too small pitch candidate, -- important for the plusive
; 207  :     speech.
; 208  :     ----------------------------------------------------------------------*/
; 209  :   EliminateSmallP0(pfCostFunc, piCandInd_0, &iNumCand, &iHP_Index);

  00163	8d 45 f8	 lea	 eax, DWORD PTR _iHP_Index$[ebp]
  00166	50		 push	 eax
  00167	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _iNumCand$[ebp]
  0016d	51		 push	 ecx
  0016e	8d 95 70 fe ff
	ff		 lea	 edx, DWORD PTR _piCandInd_0$[ebp]
  00174	52		 push	 edx
  00175	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _pfCostFunc$[ebp]
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 _EliminateSmallP0@16

; 210  : 
; 211  : 
; 212  :   /*----------------------------------------------------------------------
; 213  :     Add the backward-tracked candidate.
; 214  :     ----------------------------------------------------------------------*/
; 215  :   AddBackTrackCand(pfCostFunc, iBackIndex, piCandInd_0, &iNumCand, &iHP_Index);

  00181	8d 4d f8	 lea	 ecx, DWORD PTR _iHP_Index$[ebp]
  00184	51		 push	 ecx
  00185	8d 95 60 fe ff
	ff		 lea	 edx, DWORD PTR _iNumCand$[ebp]
  0018b	52		 push	 edx
  0018c	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR _piCandInd_0$[ebp]
  00192	50		 push	 eax
  00193	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR _iBackIndex$[ebp]
  00199	51		 push	 ecx
  0019a	8d 95 88 fe ff
	ff		 lea	 edx, DWORD PTR _pfCostFunc$[ebp]
  001a0	52		 push	 edx
  001a1	e8 00 00 00 00	 call	 _AddBackTrackCand@20

; 216  : 
; 217  :   ExchangeFltValue(fNewBackCost, pfCostFunc[iBackIndex]);

  001a6	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _fNewBackCost$[ebp]
  001ac	89 85 4c fe ff
	ff		 mov	 DWORD PTR _a$1024[ebp], eax
  001b2	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR _iBackIndex$[ebp]
  001b8	8b 94 8d 88 fe
	ff ff		 mov	 edx, DWORD PTR _pfCostFunc$[ebp+ecx*4]
  001bf	89 95 54 fe ff
	ff		 mov	 DWORD PTR _fNewBackCost$[ebp], edx
  001c5	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR _iBackIndex$[ebp]
  001cb	8b 8d 4c fe ff
	ff		 mov	 ecx, DWORD PTR _a$1024[ebp]
  001d1	89 8c 85 88 fe
	ff ff		 mov	 DWORD PTR _pfCostFunc$[ebp+eax*4], ecx

; 218  : 
; 219  :   
; 220  :   /*----------------------------------------------------------------------
; 221  :     (4) Refine the pitch and only choose at most 3 candidates for later
; 222  :     calculateion.
; 223  :     ----------------------------------------------------------------------*/
; 224  :   k = 0;  

  001d8	c7 85 68 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$[ebp], 0

; 225  :   iNumCand_1 = iNumCand-1;

  001e2	8b 95 60 fe ff
	ff		 mov	 edx, DWORD PTR _iNumCand$[ebp]
  001e8	83 ea 01	 sub	 edx, 1
  001eb	89 95 64 fe ff
	ff		 mov	 DWORD PTR _iNumCand_1$[ebp], edx

; 226  :   for (i = 0; i < iNumCand; i++)

  001f1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001f8	eb 09		 jmp	 SHORT $L1025
$L1026:
  001fa	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001fd	83 c0 01	 add	 eax, 1
  00200	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$L1025:
  00203	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00206	3b 8d 60 fe ff
	ff		 cmp	 ecx, DWORD PTR _iNumCand$[ebp]
  0020c	0f 8d e1 00 00
	00		 jge	 $L1027

; 227  :     {
; 228  :       if ((i != 0) && (i != (iNumCand_1)) && (i != iHP_Index))

  00212	83 7d f4 00	 cmp	 DWORD PTR _i$[ebp], 0
  00216	74 15		 je	 SHORT $L1028
  00218	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0021b	3b 95 64 fe ff
	ff		 cmp	 edx, DWORD PTR _iNumCand_1$[ebp]
  00221	74 0a		 je	 SHORT $L1028
  00223	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00226	3b 45 f8	 cmp	 eax, DWORD PTR _iHP_Index$[ebp]
  00229	74 02		 je	 SHORT $L1028

; 229  :         continue;

  0022b	eb cd		 jmp	 SHORT $L1026
$L1028:

; 230  : 
; 231  :       /*** find the new high possibility index ***/
; 232  :       if (i == iHP_Index)

  0022d	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00230	3b 4d f8	 cmp	 ecx, DWORD PTR _iHP_Index$[ebp]
  00233	75 0b		 jne	 SHORT $L1029

; 233  :         *piHP_Index = k;

  00235	8b 55 24	 mov	 edx, DWORD PTR _piHP_Index$[ebp]
  00238	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _k$[ebp]
  0023e	89 02		 mov	 DWORD PTR [edx], eax
$L1029:

; 234  : 
; 235  :       iIndex = piCandInd_0[i];

  00240	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00243	8b 94 8d 70 fe
	ff ff		 mov	 edx, DWORD PTR _piCandInd_0$[ebp+ecx*4]
  0024a	89 95 6c fe ff
	ff		 mov	 DWORD PTR _iIndex$[ebp], edx

; 236  : 
; 237  :       /*** find the cost value ***/
; 238  :       fCost = pfCostFunc[iIndex];

  00250	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR _iIndex$[ebp]
  00256	8b 8c 85 88 fe
	ff ff		 mov	 ecx, DWORD PTR _pfCostFunc$[ebp+eax*4]
  0025d	89 4d fc	 mov	 DWORD PTR _fCost$[ebp], ecx

; 239  : 
; 240  :       /*** refine pitch value ***/
; 241  :       pfPitchCand[k] = RefineLDPitch(iIndex, piPeakFreq, pfMag,
; 242  :                                      iBaseBand, fNormEnergy, &fCost);

  00260	8d 55 fc	 lea	 edx, DWORD PTR _fCost$[ebp]
  00263	52		 push	 edx
  00264	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR _fNormEnergy$[ebp]
  0026a	50		 push	 eax
  0026b	8b 4d 0c	 mov	 ecx, DWORD PTR _iBaseBand$[ebp]
  0026e	51		 push	 ecx
  0026f	8b 55 08	 mov	 edx, DWORD PTR _pfMag$[ebp]
  00272	52		 push	 edx
  00273	8b 45 10	 mov	 eax, DWORD PTR _piPeakFreq$[ebp]
  00276	50		 push	 eax
  00277	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0027d	51		 push	 ecx
  0027e	e8 00 00 00 00	 call	 _RefineLDPitch@24
  00283	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR _k$[ebp]
  00289	8b 45 14	 mov	 eax, DWORD PTR _pfPitchCand$[ebp]
  0028c	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]

; 243  : 
; 244  :       /*** put back the backward tracking information ***/
; 245  :       if (iIndex == iBackIndex)

  0028f	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00295	3b 8d 5c fe ff
	ff		 cmp	 ecx, DWORD PTR _iBackIndex$[ebp]
  0029b	75 33		 jne	 SHORT $L1030

; 246  :         fCost = CompBackCost(fLastCost, fCost);

  0029d	d9 45 20	 fld	 DWORD PTR _fLastCost$[ebp]
  002a0	d8 5d fc	 fcomp	 DWORD PTR _fCost$[ebp]
  002a3	df e0		 fnstsw	 ax
  002a5	f6 c4 41	 test	 ah, 65			; 00000041H
  002a8	75 14		 jne	 SHORT $L1235
  002aa	d9 45 20	 fld	 DWORD PTR _fLastCost$[ebp]
  002ad	d8 45 fc	 fadd	 DWORD PTR _fCost$[ebp]
  002b0	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  002b6	d9 9d 48 fe ff
	ff		 fstp	 DWORD PTR tv186[ebp]
  002bc	eb 09		 jmp	 SHORT $L1236
$L1235:
  002be	8b 55 fc	 mov	 edx, DWORD PTR _fCost$[ebp]
  002c1	89 95 48 fe ff
	ff		 mov	 DWORD PTR tv186[ebp], edx
$L1236:
  002c7	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  002cd	89 45 fc	 mov	 DWORD PTR _fCost$[ebp], eax
$L1030:

; 247  : 
; 248  :       /*** Save to New arrays ***/
; 249  :       pfCandCost[k] = fCost;

  002d0	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR _k$[ebp]
  002d6	8b 55 18	 mov	 edx, DWORD PTR _pfCandCost$[ebp]
  002d9	8b 45 fc	 mov	 eax, DWORD PTR _fCost$[ebp]
  002dc	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 250  : 
; 251  :       k++;

  002df	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR _k$[ebp]
  002e5	83 c1 01	 add	 ecx, 1
  002e8	89 8d 68 fe ff
	ff		 mov	 DWORD PTR _k$[ebp], ecx

; 252  :     } 

  002ee	e9 07 ff ff ff	 jmp	 $L1026
$L1027:

; 253  : 
; 254  :   iNumCand = k;

  002f3	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR _k$[ebp]
  002f9	89 95 60 fe ff
	ff		 mov	 DWORD PTR _iNumCand$[ebp], edx

; 255  : 
; 256  : STACK_END
; 257  : 
; 258  :   return iNumCand;

  002ff	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _iNumCand$[ebp]

; 259  : }

  00305	8b e5		 mov	 esp, ebp
  00307	5d		 pop	 ebp
  00308	c2 20 00	 ret	 32			; 00000020H
_SelectPitchCandidates@32 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@DHIBENDA@pfCostFunc?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	??_C@_0BG@HDNLJLMD@pfNewBackCost?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	__real@3faa9fbe
PUBLIC	__real@3f400000
;	COMDAT ??_C@_0BD@DHIBENDA@pfCostFunc?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BD@DHIBENDA@pfCostFunc?5?$CB?$DN?5NULL?$AA@ DB 'pfCostFunc != NULL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HDNLJLMD@pfNewBackCost?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BG@HDNLJLMD@pfNewBackCost?5?$CB?$DN?5NULL?$AA@ DB 'pfNewBackCost !'
	DB	'= NULL', 00H				; `string'
CONST	ENDS
;	COMDAT __real@3faa9fbe
CONST	SEGMENT
__real@3faa9fbe DD 03faa9fber			; 1.333
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _BackWard_Check@16
_TEXT	SEGMENT
tv129 = -24
_fLeftP0$ = -20
_fMaxCost$ = -16
_iBackIndex$ = -12
_fRightP0$ = -8
_i$ = -4
_pfCostFunc$ = 8
_fLastP0$ = 12
_fLastCost$ = 16
_pfNewBackCost$ = 20
_BackWard_Check@16 PROC NEAR				; COMDAT

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 299  :   float fRightP0, fLeftP0;
; 300  :   int i;
; 301  :   float fMaxCost;
; 302  :   int iBackIndex;
; 303  : 
; 304  :   assert(pfCostFunc != NULL);

  00006	83 7d 08 00	 cmp	 DWORD PTR _pfCostFunc$[ebp], 0
  0000a	75 17		 jne	 SHORT $L1247
  0000c	68 30 01 00 00	 push	 304			; 00000130H
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@DHIBENDA@pfCostFunc?5?$CB?$DN?5NULL?$AA@
  0001b	e8 00 00 00 00	 call	 __assert
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1247:

; 305  :   assert(pfNewBackCost != NULL);

  00023	83 7d 14 00	 cmp	 DWORD PTR _pfNewBackCost$[ebp], 0
  00027	75 17		 jne	 SHORT $L1248
  00029	68 31 01 00 00	 push	 305			; 00000131H
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@HDNLJLMD@pfNewBackCost?5?$CB?$DN?5NULL?$AA@
  00038	e8 00 00 00 00	 call	 __assert
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1248:

; 306  : 
; 307  :   /* Find the boundaries */
; 308  :   fRightP0 = fLastP0*RIGHT_P0_SCALE;

  00040	d9 45 0c	 fld	 DWORD PTR _fLastP0$[ebp]
  00043	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3faa9fbe
  00049	d9 5d f8	 fstp	 DWORD PTR _fRightP0$[ebp]

; 309  :   fLeftP0 = fLastP0*LEFT_P0_SCALE;

  0004c	d9 45 0c	 fld	 DWORD PTR _fLastP0$[ebp]
  0004f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f400000
  00055	d9 5d ec	 fstp	 DWORD PTR _fLeftP0$[ebp]

; 310  : 
; 311  :   /* find the left boundary */
; 312  :   i = 0;

  00058	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$L1052:

; 313  :   while (CpfPitchTable[i] < fLeftP0) 

  0005f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00062	d9 04 95 00 00
	00 00		 fld	 DWORD PTR _CpfPitchTable[edx*4]
  00069	d8 5d ec	 fcomp	 DWORD PTR _fLeftP0$[ebp]
  0006c	df e0		 fnstsw	 ax
  0006e	f6 c4 05	 test	 ah, 5
  00071	7a 0b		 jp	 SHORT $L1053

; 314  :      i++;

  00073	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00076	83 c0 01	 add	 eax, 1
  00079	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  0007c	eb e1		 jmp	 SHORT $L1052
$L1053:

; 315  : 
; 316  :   /* Find the candidate with the maximum cost value from the 
; 317  :      backward tracking */
; 318  :   fMaxCost = pfCostFunc[i];

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00081	8b 55 08	 mov	 edx, DWORD PTR _pfCostFunc$[ebp]
  00084	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00087	89 45 f0	 mov	 DWORD PTR _fMaxCost$[ebp], eax

; 319  :   iBackIndex = i;

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0008d	89 4d f4	 mov	 DWORD PTR _iBackIndex$[ebp], ecx
$L1054:

; 320  : 
; 321  :   do {
; 322  :     if (fMaxCost < pfCostFunc[i])

  00090	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00093	8b 45 08	 mov	 eax, DWORD PTR _pfCostFunc$[ebp]
  00096	d9 45 f0	 fld	 DWORD PTR _fMaxCost$[ebp]
  00099	d8 1c 90	 fcomp	 DWORD PTR [eax+edx*4]
  0009c	df e0		 fnstsw	 ax
  0009e	f6 c4 05	 test	 ah, 5
  000a1	7a 12		 jp	 SHORT $L1057

; 323  :       {
; 324  :         fMaxCost = pfCostFunc[i];

  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000a6	8b 55 08	 mov	 edx, DWORD PTR _pfCostFunc$[ebp]
  000a9	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  000ac	89 45 f0	 mov	 DWORD PTR _fMaxCost$[ebp], eax

; 325  :         iBackIndex = i;

  000af	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000b2	89 4d f4	 mov	 DWORD PTR _iBackIndex$[ebp], ecx
$L1057:

; 326  :       }
; 327  :     i++;

  000b5	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000b8	83 c2 01	 add	 edx, 1
  000bb	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx

; 328  :   } while((i < PITCH_TABLE_SIZE) && (CpfPitchTable[i] <= fRightP0));

  000be	83 7d fc 59	 cmp	 DWORD PTR _i$[ebp], 89	; 00000059H
  000c2	7d 14		 jge	 SHORT $L1056
  000c4	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000c7	d9 04 85 00 00
	00 00		 fld	 DWORD PTR _CpfPitchTable[eax*4]
  000ce	d8 5d f8	 fcomp	 DWORD PTR _fRightP0$[ebp]
  000d1	df e0		 fnstsw	 ax
  000d3	f6 c4 41	 test	 ah, 65			; 00000041H
  000d6	7b b8		 jnp	 SHORT $L1054
$L1056:

; 329  :   
; 330  :   /* Now compute the total cost value (combine the cost from the last 
; 331  :      frame and the current frame) */
; 332  :   *pfNewBackCost = CompBackCost(fLastCost, fMaxCost);

  000d8	d9 45 10	 fld	 DWORD PTR _fLastCost$[ebp]
  000db	d8 5d f0	 fcomp	 DWORD PTR _fMaxCost$[ebp]
  000de	df e0		 fnstsw	 ax
  000e0	f6 c4 41	 test	 ah, 65			; 00000041H
  000e3	75 11		 jne	 SHORT $L1249
  000e5	d9 45 10	 fld	 DWORD PTR _fLastCost$[ebp]
  000e8	d8 45 f0	 fadd	 DWORD PTR _fMaxCost$[ebp]
  000eb	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  000f1	d9 5d e8	 fstp	 DWORD PTR tv129[ebp]
  000f4	eb 06		 jmp	 SHORT $L1250
$L1249:
  000f6	8b 4d f0	 mov	 ecx, DWORD PTR _fMaxCost$[ebp]
  000f9	89 4d e8	 mov	 DWORD PTR tv129[ebp], ecx
$L1250:
  000fc	8b 55 14	 mov	 edx, DWORD PTR _pfNewBackCost$[ebp]
  000ff	8b 45 e8	 mov	 eax, DWORD PTR tv129[ebp]
  00102	89 02		 mov	 DWORD PTR [edx], eax

; 333  : 
; 334  :   return iBackIndex;

  00104	8b 45 f4	 mov	 eax, DWORD PTR _iBackIndex$[ebp]

; 335  : }

  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c2 10 00	 ret	 16			; 00000010H
_BackWard_Check@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@KEJBFKEF@piIndCand?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	??_C@_0BC@CDPBMAEK@piHPIndex?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	__real@3f47ae14
PUBLIC	__real@3f570a3d
PUBLIC	__real@3f555555
EXTRN	_FindMaxValueFlt@16:NEAR
;	COMDAT ??_C@_0BC@KEJBFKEF@piIndCand?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BC@KEJBFKEF@piIndCand?5?$CB?$DN?5NULL?$AA@ DB 'piIndCand != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CDPBMAEK@piHPIndex?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BC@CDPBMAEK@piHPIndex?5?$CB?$DN?5NULL?$AA@ DB 'piHPIndex != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3f47ae14
CONST	SEGMENT
__real@3f47ae14 DD 03f47ae14r			; 0.78
CONST	ENDS
;	COMDAT __real@3f570a3d
CONST	SEGMENT
__real@3f570a3d DD 03f570a3dr			; 0.84
CONST	ENDS
;	COMDAT __real@3f555555
CONST	SEGMENT
__real@3f555555 DD 03f555555r			; 0.833333
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _HarmThreshold@12
_TEXT	SEGMENT
_fMaxCost$ = -32
_iNumCand$ = -28
_iLocalLength$ = -24
_iLocalMaxInd$ = -20
_fLocalMaxCost$ = -16
_iHPIndex$ = -12
_iPitchIndex$ = -8
_fP0$ = -4
_pfCostFunc$ = 8
_piIndCand$ = 12
_piHPIndex$ = 16
_HarmThreshold@12 PROC NEAR				; COMDAT

; 372  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi

; 373  :   float fMaxCost;
; 374  :   int iPitchIndex;
; 375  :   float fP0;
; 376  :   int iHPIndex;
; 377  :   float fLocalMaxCost;
; 378  :   int iLocalMaxInd;
; 379  :   int iLocalLength;
; 380  :   int iNumCand;
; 381  : 
; 382  : 
; 383  :   assert(pfCostFunc != NULL);

  00007	83 7d 08 00	 cmp	 DWORD PTR _pfCostFunc$[ebp], 0
  0000b	75 17		 jne	 SHORT $L1258
  0000d	68 7f 01 00 00	 push	 383			; 0000017fH
  00012	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@DHIBENDA@pfCostFunc?5?$CB?$DN?5NULL?$AA@
  0001c	e8 00 00 00 00	 call	 __assert
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1258:

; 384  :   assert(piIndCand != NULL);

  00024	83 7d 0c 00	 cmp	 DWORD PTR _piIndCand$[ebp], 0
  00028	75 17		 jne	 SHORT $L1259
  0002a	68 80 01 00 00	 push	 384			; 00000180H
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00034	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@KEJBFKEF@piIndCand?5?$CB?$DN?5NULL?$AA@
  00039	e8 00 00 00 00	 call	 __assert
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1259:

; 385  :   assert(piHPIndex != NULL);

  00041	83 7d 10 00	 cmp	 DWORD PTR _piHPIndex$[ebp], 0
  00045	75 17		 jne	 SHORT $L1260
  00047	68 81 01 00 00	 push	 385			; 00000181H
  0004c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@CDPBMAEK@piHPIndex?5?$CB?$DN?5NULL?$AA@
  00056	e8 00 00 00 00	 call	 __assert
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1260:

; 386  : 
; 387  :   /*--------------------------------------------------
; 388  :     Initializing ...
; 389  :     --------------------------------------------------*/
; 390  :   iHPIndex = 0;

  0005e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iHPIndex$[ebp], 0

; 391  :   iNumCand = 0;

  00065	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iNumCand$[ebp], 0

; 392  :   iPitchIndex = PITCH_TABLE_SIZE-1;   /* the end point index */

  0006c	c7 45 f8 58 00
	00 00		 mov	 DWORD PTR _iPitchIndex$[ebp], 88 ; 00000058H

; 393  :   fMaxCost = -1.0F;

  00073	c7 45 e0 00 00
	80 bf		 mov	 DWORD PTR _fMaxCost$[ebp], -1082130432 ; bf800000H
$L1083:

; 394  : 
; 395  :   while (iNumCand < SUB_MAX)

  0007a	83 7d e4 05	 cmp	 DWORD PTR _iNumCand$[ebp], 5
  0007e	0f 8d e9 00 00
	00		 jge	 $L1084

; 396  :     { 
; 397  :       /*--------------------------------------------------
; 398  :         Find the local maxima.
; 399  :         --------------------------------------------------*/
; 400  :       iLocalLength = iPitchIndex+1;

  00084	8b 45 f8	 mov	 eax, DWORD PTR _iPitchIndex$[ebp]
  00087	83 c0 01	 add	 eax, 1
  0008a	89 45 e8	 mov	 DWORD PTR _iLocalLength$[ebp], eax

; 401  :       FindMaxValueFlt(pfCostFunc, iLocalLength, &iLocalMaxInd,
; 402  :                       &fLocalMaxCost);

  0008d	8d 4d f0	 lea	 ecx, DWORD PTR _fLocalMaxCost$[ebp]
  00090	51		 push	 ecx
  00091	8d 55 ec	 lea	 edx, DWORD PTR _iLocalMaxInd$[ebp]
  00094	52		 push	 edx
  00095	8b 45 e8	 mov	 eax, DWORD PTR _iLocalLength$[ebp]
  00098	50		 push	 eax
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _pfCostFunc$[ebp]
  0009c	51		 push	 ecx
  0009d	e8 00 00 00 00	 call	 _FindMaxValueFlt@16

; 403  : 
; 404  :       /*--------------------------------------------------
; 405  :         Only choose the candidate > threshold.
; 406  :         --------------------------------------------------*/
; 407  :       if (fLocalMaxCost < (COST_THRESHOLD*fMaxCost)) 

  000a2	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f47ae14
  000a8	d8 4d e0	 fmul	 DWORD PTR _fMaxCost$[ebp]
  000ab	d8 5d f0	 fcomp	 DWORD PTR _fLocalMaxCost$[ebp]
  000ae	df e0		 fnstsw	 ax
  000b0	f6 c4 41	 test	 ah, 65			; 00000041H
  000b3	75 05		 jne	 SHORT $L1085

; 408  :          break;

  000b5	e9 b3 00 00 00	 jmp	 $L1084
$L1085:

; 409  : 
; 410  :       /*--------------------------------------------------
; 411  :         Fill up the local candidate.
; 412  :         --------------------------------------------------*/
; 413  :       piIndCand[iNumCand] = iLocalMaxInd;

  000ba	8b 55 e4	 mov	 edx, DWORD PTR _iNumCand$[ebp]
  000bd	8b 45 0c	 mov	 eax, DWORD PTR _piIndCand$[ebp]
  000c0	8b 4d ec	 mov	 ecx, DWORD PTR _iLocalMaxInd$[ebp]
  000c3	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 414  : 
; 415  :       /*--------------------------------------------------
; 416  :         Find the high probability candidate.
; 417  :         --------------------------------------------------*/
; 418  :       if (fLocalMaxCost >= (HP_COST_THRESHOLD*fMaxCost))

  000c6	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f570a3d
  000cc	d8 4d e0	 fmul	 DWORD PTR _fMaxCost$[ebp]
  000cf	d8 5d f0	 fcomp	 DWORD PTR _fLocalMaxCost$[ebp]
  000d2	df e0		 fnstsw	 ax
  000d4	f6 c4 41	 test	 ah, 65			; 00000041H
  000d7	7a 06		 jp	 SHORT $L1086

; 419  :         iHPIndex = iNumCand;

  000d9	8b 55 e4	 mov	 edx, DWORD PTR _iNumCand$[ebp]
  000dc	89 55 f4	 mov	 DWORD PTR _iHPIndex$[ebp], edx
$L1086:

; 420  : 
; 421  :       /*--------------------------------------------------
; 422  :         Replace global maxima with the local one.
; 423  :         --------------------------------------------------*/
; 424  :       fMaxCost = fLocalMaxCost;

  000df	8b 45 f0	 mov	 eax, DWORD PTR _fLocalMaxCost$[ebp]
  000e2	89 45 e0	 mov	 DWORD PTR _fMaxCost$[ebp], eax

; 425  : 
; 426  :       /*--------------------------------------------------
; 427  :         Update ... 
; 428  :         --------------------------------------------------*/
; 429  :       iNumCand++;

  000e5	8b 4d e4	 mov	 ecx, DWORD PTR _iNumCand$[ebp]
  000e8	83 c1 01	 add	 ecx, 1
  000eb	89 4d e4	 mov	 DWORD PTR _iNumCand$[ebp], ecx

; 430  : 
; 431  :       /*--------------------------------------------------
; 432  :         Find the next search range 
; 433  :         --------------------------------------------------*/
; 434  :       iPitchIndex = iLocalMaxInd;

  000ee	8b 55 ec	 mov	 edx, DWORD PTR _iLocalMaxInd$[ebp]
  000f1	89 55 f8	 mov	 DWORD PTR _iPitchIndex$[ebp], edx

; 435  :       fP0 = CpfPitchTable[iPitchIndex]*SEARCH_BOUND;  

  000f4	8b 45 f8	 mov	 eax, DWORD PTR _iPitchIndex$[ebp]
  000f7	d9 04 85 00 00
	00 00		 fld	 DWORD PTR _CpfPitchTable[eax*4]
  000fe	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f555555
  00104	d9 55 fc	 fst	 DWORD PTR _fP0$[ebp]

; 436  :       if (fP0 < CpfPitchTable[0])   /* don't go over table length */

  00107	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR _CpfPitchTable
  0010d	df e0		 fnstsw	 ax
  0010f	f6 c4 05	 test	 ah, 5
  00112	7a 02		 jp	 SHORT $L1089

; 437  :          break;

  00114	eb 57		 jmp	 SHORT $L1084
$L1089:

; 438  : 
; 439  :       while (CpfPitchTable[iPitchIndex] > fP0)  

  00116	8b 4d f8	 mov	 ecx, DWORD PTR _iPitchIndex$[ebp]
  00119	d9 04 8d 00 00
	00 00		 fld	 DWORD PTR _CpfPitchTable[ecx*4]
  00120	d8 5d fc	 fcomp	 DWORD PTR _fP0$[ebp]
  00123	df e0		 fnstsw	 ax
  00125	f6 c4 41	 test	 ah, 65			; 00000041H
  00128	75 0b		 jne	 SHORT $L1092

; 440  :          iPitchIndex--;

  0012a	8b 55 f8	 mov	 edx, DWORD PTR _iPitchIndex$[ebp]
  0012d	83 ea 01	 sub	 edx, 1
  00130	89 55 f8	 mov	 DWORD PTR _iPitchIndex$[ebp], edx
  00133	eb e1		 jmp	 SHORT $L1089
$L1092:

; 441  : 
; 442  :       /*--------------------------------------------------
; 443  :         Pass a valley to make sure the new candidate is
; 444  :         a peak.
; 445  :         --------------------------------------------------*/
; 446  :       while ((iPitchIndex >= 0)&&
; 447  :              (pfCostFunc[iPitchIndex] < pfCostFunc[iPitchIndex+1]))

  00135	83 7d f8 00	 cmp	 DWORD PTR _iPitchIndex$[ebp], 0
  00139	7c 25		 jl	 SHORT $L1093
  0013b	8b 45 f8	 mov	 eax, DWORD PTR _iPitchIndex$[ebp]
  0013e	8b 4d 08	 mov	 ecx, DWORD PTR _pfCostFunc$[ebp]
  00141	8b 55 f8	 mov	 edx, DWORD PTR _iPitchIndex$[ebp]
  00144	8b 75 08	 mov	 esi, DWORD PTR _pfCostFunc$[ebp]
  00147	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  0014a	d8 5c 96 04	 fcomp	 DWORD PTR [esi+edx*4+4]
  0014e	df e0		 fnstsw	 ax
  00150	f6 c4 05	 test	 ah, 5
  00153	7a 0b		 jp	 SHORT $L1093

; 448  :           iPitchIndex --;         

  00155	8b 45 f8	 mov	 eax, DWORD PTR _iPitchIndex$[ebp]
  00158	83 e8 01	 sub	 eax, 1
  0015b	89 45 f8	 mov	 DWORD PTR _iPitchIndex$[ebp], eax
  0015e	eb d5		 jmp	 SHORT $L1092
$L1093:

; 449  : 
; 450  :       if (iPitchIndex<0) break;

  00160	83 7d f8 00	 cmp	 DWORD PTR _iPitchIndex$[ebp], 0
  00164	7d 02		 jge	 SHORT $L1094
  00166	eb 05		 jmp	 SHORT $L1084
$L1094:

; 451  :     }

  00168	e9 0d ff ff ff	 jmp	 $L1083
$L1084:

; 452  : 
; 453  :   *piHPIndex = iHPIndex;

  0016d	8b 4d 10	 mov	 ecx, DWORD PTR _piHPIndex$[ebp]
  00170	8b 55 f4	 mov	 edx, DWORD PTR _iHPIndex$[ebp]
  00173	89 11		 mov	 DWORD PTR [ecx], edx

; 454  : 
; 455  :   return iNumCand;

  00175	8b 45 e4	 mov	 eax, DWORD PTR _iNumCand$[ebp]

; 456  : }

  00178	5e		 pop	 esi
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c2 0c 00	 ret	 12			; 0000000cH
_HarmThreshold@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@GNKIGEMB@piNumCand?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	__real@41f00000
PUBLIC	__real@3e4ccccd
PUBLIC	__real@40400000
;	COMDAT ??_C@_0BC@GNKIGEMB@piNumCand?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BC@GNKIGEMB@piNumCand?5?$CB?$DN?5NULL?$AA@ DB 'piNumCand != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _EliminateSmallP0@16
_TEXT	SEGMENT
_fMaxCost$ = -40
_fHitThreshold$ = -36
_iNumCand$ = -32
_iNumP0Index$ = -28
_iLocalMaxInd$ = -24
_iHitFlag$ = -20
_fOrgP0$ = -16
_iHPIndex$ = -12
_iPitchIndex$ = -8
_fTryP0$ = -4
_pfCostFunc$ = 8
_piIndCand$ = 12
_piNumCand$ = 16
_piHPIndex$ = 20
_EliminateSmallP0@16 PROC NEAR				; COMDAT

; 498  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 499  :   float fMaxCost;
; 500  :   int iPitchIndex;
; 501  :   int iLocalMaxInd;
; 502  :   float fOrgP0, fTryP0;
; 503  :   int iHPIndex;
; 504  :   int iHitFlag;
; 505  :   float fHitThreshold;
; 506  :   int iNumP0Index;
; 507  :   int iNumCand;
; 508  : 
; 509  :   assert(pfCostFunc != NULL);

  00006	83 7d 08 00	 cmp	 DWORD PTR _pfCostFunc$[ebp], 0
  0000a	75 17		 jne	 SHORT $L1270
  0000c	68 fd 01 00 00	 push	 509			; 000001fdH
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@DHIBENDA@pfCostFunc?5?$CB?$DN?5NULL?$AA@
  0001b	e8 00 00 00 00	 call	 __assert
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1270:

; 510  :   assert(piIndCand != NULL);

  00023	83 7d 0c 00	 cmp	 DWORD PTR _piIndCand$[ebp], 0
  00027	75 17		 jne	 SHORT $L1271
  00029	68 fe 01 00 00	 push	 510			; 000001feH
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@KEJBFKEF@piIndCand?5?$CB?$DN?5NULL?$AA@
  00038	e8 00 00 00 00	 call	 __assert
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1271:

; 511  :   assert(piNumCand != NULL);

  00040	83 7d 10 00	 cmp	 DWORD PTR _piNumCand$[ebp], 0
  00044	75 17		 jne	 SHORT $L1272
  00046	68 ff 01 00 00	 push	 511			; 000001ffH
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00050	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@GNKIGEMB@piNumCand?5?$CB?$DN?5NULL?$AA@
  00055	e8 00 00 00 00	 call	 __assert
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1272:

; 512  :   assert(piHPIndex != NULL);

  0005d	83 7d 14 00	 cmp	 DWORD PTR _piHPIndex$[ebp], 0
  00061	75 17		 jne	 SHORT $L1273
  00063	68 00 02 00 00	 push	 512			; 00000200H
  00068	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@CDPBMAEK@piHPIndex?5?$CB?$DN?5NULL?$AA@
  00072	e8 00 00 00 00	 call	 __assert
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1273:

; 513  : 
; 514  :   iHPIndex = *piHPIndex;

  0007a	8b 4d 14	 mov	 ecx, DWORD PTR _piHPIndex$[ebp]
  0007d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007f	89 55 f4	 mov	 DWORD PTR _iHPIndex$[ebp], edx

; 515  :   iNumCand = *piNumCand;

  00082	8b 45 10	 mov	 eax, DWORD PTR _piNumCand$[ebp]
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	89 4d e0	 mov	 DWORD PTR _iNumCand$[ebp], ecx

; 516  : 
; 517  :   /*--------------------------------------------------
; 518  :     Get the pitch value of the smallest candidate.
; 519  :     --------------------------------------------------*/
; 520  :   iPitchIndex = piIndCand[iNumCand-1];

  0008a	8b 55 e0	 mov	 edx, DWORD PTR _iNumCand$[ebp]
  0008d	8b 45 0c	 mov	 eax, DWORD PTR _piIndCand$[ebp]
  00090	8b 4c 90 fc	 mov	 ecx, DWORD PTR [eax+edx*4-4]
  00094	89 4d f8	 mov	 DWORD PTR _iPitchIndex$[ebp], ecx

; 521  :   fOrgP0 = CpfPitchTable[iPitchIndex];

  00097	8b 55 f8	 mov	 edx, DWORD PTR _iPitchIndex$[ebp]
  0009a	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _CpfPitchTable[edx*4]
  000a1	89 45 f0	 mov	 DWORD PTR _fOrgP0$[ebp], eax

; 522  : 
; 523  :   /*--------------------------------------------------
; 524  :     Only search if Pitch < 30.0F
; 525  :     --------------------------------------------------*/
; 526  :   if (fOrgP0 <= CONF_PITCH)

  000a4	d9 45 f0	 fld	 DWORD PTR _fOrgP0$[ebp]
  000a7	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41f00000
  000ad	df e0		 fnstsw	 ax
  000af	f6 c4 41	 test	 ah, 65			; 00000041H
  000b2	0f 8a 1e 01 00
	00		 jp	 $L1123

; 527  :     {
; 528  :       /*--------------------------------------------------
; 529  :         Set the cost threshold.
; 530  :         --------------------------------------------------*/
; 531  :       iHitFlag = LD_FALSE;

  000b8	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iHitFlag$[ebp], 0

; 532  :       fHitThreshold = pfCostFunc[iPitchIndex] * LOW_THRESHOLD;

  000bf	8b 4d f8	 mov	 ecx, DWORD PTR _iPitchIndex$[ebp]
  000c2	8b 55 08	 mov	 edx, DWORD PTR _pfCostFunc$[ebp]
  000c5	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  000c8	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e4ccccd
  000ce	d9 5d dc	 fstp	 DWORD PTR _fHitThreshold$[ebp]

; 533  : 
; 534  :       /*--------------------------------------------------
; 535  :         check the cost values around 2*P0.
; 536  :         --------------------------------------------------*/
; 537  :       fTryP0 = fOrgP0 * 2.0F;

  000d1	d9 45 f0	 fld	 DWORD PTR _fOrgP0$[ebp]
  000d4	dc c0		 fadd	 ST(0), ST(0)
  000d6	d9 5d fc	 fstp	 DWORD PTR _fTryP0$[ebp]
$L1125:

; 538  : 
; 539  :       while(CpfPitchTable[++iPitchIndex] < fTryP0);

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _iPitchIndex$[ebp]
  000dc	83 c0 01	 add	 eax, 1
  000df	89 45 f8	 mov	 DWORD PTR _iPitchIndex$[ebp], eax
  000e2	8b 4d f8	 mov	 ecx, DWORD PTR _iPitchIndex$[ebp]
  000e5	d9 04 8d 00 00
	00 00		 fld	 DWORD PTR _CpfPitchTable[ecx*4]
  000ec	d8 5d fc	 fcomp	 DWORD PTR _fTryP0$[ebp]
  000ef	df e0		 fnstsw	 ax
  000f1	f6 c4 05	 test	 ah, 5
  000f4	7a 02		 jp	 SHORT $L1126
  000f6	eb e1		 jmp	 SHORT $L1125
$L1126:

; 540  : 
; 541  :       if ((pfCostFunc[iPitchIndex-1]<fHitThreshold)
; 542  :           && (pfCostFunc[iPitchIndex]<fHitThreshold))

  000f8	8b 55 f8	 mov	 edx, DWORD PTR _iPitchIndex$[ebp]
  000fb	8b 45 08	 mov	 eax, DWORD PTR _pfCostFunc$[ebp]
  000fe	d9 44 90 fc	 fld	 DWORD PTR [eax+edx*4-4]
  00102	d8 5d dc	 fcomp	 DWORD PTR _fHitThreshold$[ebp]
  00105	df e0		 fnstsw	 ax
  00107	f6 c4 05	 test	 ah, 5
  0010a	7a 1a		 jp	 SHORT $L1127
  0010c	8b 4d f8	 mov	 ecx, DWORD PTR _iPitchIndex$[ebp]
  0010f	8b 55 08	 mov	 edx, DWORD PTR _pfCostFunc$[ebp]
  00112	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  00115	d8 5d dc	 fcomp	 DWORD PTR _fHitThreshold$[ebp]
  00118	df e0		 fnstsw	 ax
  0011a	f6 c4 05	 test	 ah, 5
  0011d	7a 07		 jp	 SHORT $L1127

; 543  :         iHitFlag = LD_TRUE;

  0011f	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iHitFlag$[ebp], 1
$L1127:

; 544  : 
; 545  : 
; 546  :       /*--------------------------------------------------
; 547  :         check the cost values around 3*P0.
; 548  :         -------------------------------------------------*/
; 549  :       fTryP0 = fOrgP0 * 3.0F;

  00126	d9 45 f0	 fld	 DWORD PTR _fOrgP0$[ebp]
  00129	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40400000
  0012f	d9 5d fc	 fstp	 DWORD PTR _fTryP0$[ebp]
$L1129:

; 550  : 
; 551  :       while(CpfPitchTable[++iPitchIndex] < fTryP0);

  00132	8b 45 f8	 mov	 eax, DWORD PTR _iPitchIndex$[ebp]
  00135	83 c0 01	 add	 eax, 1
  00138	89 45 f8	 mov	 DWORD PTR _iPitchIndex$[ebp], eax
  0013b	8b 4d f8	 mov	 ecx, DWORD PTR _iPitchIndex$[ebp]
  0013e	d9 04 8d 00 00
	00 00		 fld	 DWORD PTR _CpfPitchTable[ecx*4]
  00145	d8 5d fc	 fcomp	 DWORD PTR _fTryP0$[ebp]
  00148	df e0		 fnstsw	 ax
  0014a	f6 c4 05	 test	 ah, 5
  0014d	7a 02		 jp	 SHORT $L1130
  0014f	eb e1		 jmp	 SHORT $L1129
$L1130:

; 552  : 
; 553  :       if ((pfCostFunc[iPitchIndex-1]<fHitThreshold)
; 554  :           && (pfCostFunc[iPitchIndex]<fHitThreshold))

  00151	8b 55 f8	 mov	 edx, DWORD PTR _iPitchIndex$[ebp]
  00154	8b 45 08	 mov	 eax, DWORD PTR _pfCostFunc$[ebp]
  00157	d9 44 90 fc	 fld	 DWORD PTR [eax+edx*4-4]
  0015b	d8 5d dc	 fcomp	 DWORD PTR _fHitThreshold$[ebp]
  0015e	df e0		 fnstsw	 ax
  00160	f6 c4 05	 test	 ah, 5
  00163	7a 1a		 jp	 SHORT $L1131
  00165	8b 4d f8	 mov	 ecx, DWORD PTR _iPitchIndex$[ebp]
  00168	8b 55 08	 mov	 edx, DWORD PTR _pfCostFunc$[ebp]
  0016b	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  0016e	d8 5d dc	 fcomp	 DWORD PTR _fHitThreshold$[ebp]
  00171	df e0		 fnstsw	 ax
  00173	f6 c4 05	 test	 ah, 5
  00176	7a 07		 jp	 SHORT $L1131

; 555  :         iHitFlag = LD_TRUE;

  00178	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iHitFlag$[ebp], 1
$L1131:

; 556  : 
; 557  :       
; 558  :       /*--------------------------------------------------
; 559  :         Re-select the pitch candidate if the conditions
; 560  :         are failed.
; 561  :         --------------------------------------------------*/
; 562  :       if (iHitFlag == LD_TRUE) {

  0017f	83 7d ec 01	 cmp	 DWORD PTR _iHitFlag$[ebp], 1
  00183	75 51		 jne	 SHORT $L1123

; 563  :         if (iNumCand == LD_TRUE) 

  00185	83 7d e0 01	 cmp	 DWORD PTR _iNumCand$[ebp], 1
  00189	75 33		 jne	 SHORT $L1133

; 564  :           {
; 565  :             /*--------------------------------------------------
; 566  :               if there is only one candidate, replace it using 
; 567  :               the largest cost from [3*P0 MAX_PITCH].
; 568  :               --------------------------------------------------*/
; 569  :             iNumP0Index = PITCH_TABLE_SIZE-iPitchIndex;

  0018b	b8 59 00 00 00	 mov	 eax, 89			; 00000059H
  00190	2b 45 f8	 sub	 eax, DWORD PTR _iPitchIndex$[ebp]
  00193	89 45 e4	 mov	 DWORD PTR _iNumP0Index$[ebp], eax

; 570  :             FindMaxValueFlt(&(pfCostFunc[iPitchIndex]), iNumP0Index,
; 571  :                             &iLocalMaxInd, &fMaxCost);

  00196	8d 4d d8	 lea	 ecx, DWORD PTR _fMaxCost$[ebp]
  00199	51		 push	 ecx
  0019a	8d 55 e8	 lea	 edx, DWORD PTR _iLocalMaxInd$[ebp]
  0019d	52		 push	 edx
  0019e	8b 45 e4	 mov	 eax, DWORD PTR _iNumP0Index$[ebp]
  001a1	50		 push	 eax
  001a2	8b 4d f8	 mov	 ecx, DWORD PTR _iPitchIndex$[ebp]
  001a5	8b 55 08	 mov	 edx, DWORD PTR _pfCostFunc$[ebp]
  001a8	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 _FindMaxValueFlt@16

; 572  :             piIndCand[0] = iLocalMaxInd + iPitchIndex;

  001b1	8b 4d e8	 mov	 ecx, DWORD PTR _iLocalMaxInd$[ebp]
  001b4	03 4d f8	 add	 ecx, DWORD PTR _iPitchIndex$[ebp]
  001b7	8b 55 0c	 mov	 edx, DWORD PTR _piIndCand$[ebp]
  001ba	89 0a		 mov	 DWORD PTR [edx], ecx

; 573  :           }
; 574  :         else 

  001bc	eb 18		 jmp	 SHORT $L1123
$L1133:

; 575  :           {
; 576  :             /*--------------------------------------------------
; 577  :               if there are more than one candidate, remove the
; 578  :               smallest pitch candidate.
; 579  :               --------------------------------------------------*/
; 580  :             iNumCand--;

  001be	8b 45 e0	 mov	 eax, DWORD PTR _iNumCand$[ebp]
  001c1	83 e8 01	 sub	 eax, 1
  001c4	89 45 e0	 mov	 DWORD PTR _iNumCand$[ebp], eax

; 581  :             
; 582  :             /*--------------------------------------------------
; 583  :               if the removed one is with high-possibility,
; 584  :               reset the HP candidate with the largest cost value.
; 585  :               --------------------------------------------------*/
; 586  :             if (iHPIndex == iNumCand)

  001c7	8b 4d f4	 mov	 ecx, DWORD PTR _iHPIndex$[ebp]
  001ca	3b 4d e0	 cmp	 ecx, DWORD PTR _iNumCand$[ebp]
  001cd	75 07		 jne	 SHORT $L1123

; 587  :               iHPIndex = 0;

  001cf	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iHPIndex$[ebp], 0
$L1123:

; 588  :           }
; 589  :       }
; 590  :     }
; 591  : 
; 592  :   *piHPIndex = iHPIndex;

  001d6	8b 55 14	 mov	 edx, DWORD PTR _piHPIndex$[ebp]
  001d9	8b 45 f4	 mov	 eax, DWORD PTR _iHPIndex$[ebp]
  001dc	89 02		 mov	 DWORD PTR [edx], eax

; 593  :   *piNumCand = iNumCand;

  001de	8b 4d 10	 mov	 ecx, DWORD PTR _piNumCand$[ebp]
  001e1	8b 55 e0	 mov	 edx, DWORD PTR _iNumCand$[ebp]
  001e4	89 11		 mov	 DWORD PTR [ecx], edx

; 594  : }

  001e6	8b e5		 mov	 esp, ebp
  001e8	5d		 pop	 ebp
  001e9	c2 10 00	 ret	 16			; 00000010H
_EliminateSmallP0@16 ENDP
_TEXT	ENDS
PUBLIC	__real@3f3851ec
;	COMDAT __real@3f3851ec
CONST	SEGMENT
__real@3f3851ec DD 03f3851ecr			; 0.72
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _AddBackTrackCand@20
_TEXT	SEGMENT
_fMaxCost$ = -32
_fHitThreshold$ = -28
_iNumCand$ = -24
_iHitFlag$ = -20
_fBackCost$ = -16
_iHPIndex$ = -12
_i$ = -8
_iInsertPoint$ = -4
_pfCostFunc$ = 8
_iBackIndex$ = 12
_piIndCand$ = 16
_piNumCand$ = 20
_piHPIndex$ = 24
_AddBackTrackCand@20 PROC NEAR				; COMDAT

; 637  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi

; 638  :   float fMaxCost;
; 639  :   int iHPIndex;
; 640  :   int iHitFlag;
; 641  :   float fHitThreshold;
; 642  :   int iNumCand;
; 643  :   int iInsertPoint;
; 644  :   float fBackCost;
; 645  :   int i;
; 646  : 
; 647  :   assert(pfCostFunc != NULL);

  00007	83 7d 08 00	 cmp	 DWORD PTR _pfCostFunc$[ebp], 0
  0000b	75 17		 jne	 SHORT $L1285
  0000d	68 87 02 00 00	 push	 647			; 00000287H
  00012	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@DHIBENDA@pfCostFunc?5?$CB?$DN?5NULL?$AA@
  0001c	e8 00 00 00 00	 call	 __assert
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1285:

; 648  :   assert(piIndCand != NULL);

  00024	83 7d 10 00	 cmp	 DWORD PTR _piIndCand$[ebp], 0
  00028	75 17		 jne	 SHORT $L1286
  0002a	68 88 02 00 00	 push	 648			; 00000288H
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00034	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@KEJBFKEF@piIndCand?5?$CB?$DN?5NULL?$AA@
  00039	e8 00 00 00 00	 call	 __assert
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1286:

; 649  :   assert(piNumCand != NULL);

  00041	83 7d 14 00	 cmp	 DWORD PTR _piNumCand$[ebp], 0
  00045	75 17		 jne	 SHORT $L1287
  00047	68 89 02 00 00	 push	 649			; 00000289H
  0004c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@GNKIGEMB@piNumCand?5?$CB?$DN?5NULL?$AA@
  00056	e8 00 00 00 00	 call	 __assert
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1287:

; 650  :   assert(piHPIndex != NULL);

  0005e	83 7d 18 00	 cmp	 DWORD PTR _piHPIndex$[ebp], 0
  00062	75 17		 jne	 SHORT $L1288
  00064	68 8a 02 00 00	 push	 650			; 0000028aH
  00069	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@CDPBMAEK@piHPIndex?5?$CB?$DN?5NULL?$AA@
  00073	e8 00 00 00 00	 call	 __assert
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1288:

; 651  :   
; 652  :   iHPIndex = *piHPIndex;

  0007b	8b 4d 18	 mov	 ecx, DWORD PTR _piHPIndex$[ebp]
  0007e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00080	89 55 f4	 mov	 DWORD PTR _iHPIndex$[ebp], edx

; 653  :   iNumCand = *piNumCand;

  00083	8b 45 14	 mov	 eax, DWORD PTR _piNumCand$[ebp]
  00086	8b 08		 mov	 ecx, DWORD PTR [eax]
  00088	89 4d e8	 mov	 DWORD PTR _iNumCand$[ebp], ecx

; 654  : 
; 655  :   /*--------------------------------------------------
; 656  :     Search whether the backward tracked candidate
; 657  :     is in the list. And find the location 
; 658  :     where BackIndex>Ind_Cand[i].
; 659  :     --------------------------------------------------*/
; 660  :   iHitFlag = LD_FALSE;

  0008b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iHitFlag$[ebp], 0

; 661  :   for (i = 0; i < iNumCand; i++) {

  00092	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00099	eb 09		 jmp	 SHORT $L1163
$L1164:
  0009b	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0009e	83 c2 01	 add	 edx, 1
  000a1	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L1163:
  000a4	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000a7	3b 45 e8	 cmp	 eax, DWORD PTR _iNumCand$[ebp]
  000aa	7d 27		 jge	 SHORT $L1165

; 662  :     if (iBackIndex == piIndCand[i])

  000ac	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000af	8b 55 10	 mov	 edx, DWORD PTR _piIndCand$[ebp]
  000b2	8b 45 0c	 mov	 eax, DWORD PTR _iBackIndex$[ebp]
  000b5	3b 04 8a	 cmp	 eax, DWORD PTR [edx+ecx*4]
  000b8	75 07		 jne	 SHORT $L1166

; 663  :        iHitFlag = LD_TRUE;

  000ba	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iHitFlag$[ebp], 1
$L1166:

; 664  :     if (iBackIndex > piIndCand[i]) 

  000c1	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000c4	8b 55 10	 mov	 edx, DWORD PTR _piIndCand$[ebp]
  000c7	8b 45 0c	 mov	 eax, DWORD PTR _iBackIndex$[ebp]
  000ca	3b 04 8a	 cmp	 eax, DWORD PTR [edx+ecx*4]
  000cd	7e 02		 jle	 SHORT $L1167

; 665  :        break;

  000cf	eb 02		 jmp	 SHORT $L1165
$L1167:

; 666  :   }

  000d1	eb c8		 jmp	 SHORT $L1164
$L1165:

; 667  :   iInsertPoint = i;

  000d3	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000d6	89 4d fc	 mov	 DWORD PTR _iInsertPoint$[ebp], ecx

; 668  : 
; 669  :   /*-----------------------------------------------------
; 670  :     If the backward-tracked candidate is an extra one ...
; 671  :     -----------------------------------------------------*/
; 672  :   if (iHitFlag == LD_FALSE) 

  000d9	83 7d ec 00	 cmp	 DWORD PTR _iHitFlag$[ebp], 0
  000dd	0f 85 b8 00 00
	00		 jne	 $L1168

; 673  :     {
; 674  :       /*--------------------------------------------------
; 675  :         Find the thresholds
; 676  :         --------------------------------------------------*/
; 677  :       fBackCost = pfCostFunc[iBackIndex];

  000e3	8b 55 0c	 mov	 edx, DWORD PTR _iBackIndex$[ebp]
  000e6	8b 45 08	 mov	 eax, DWORD PTR _pfCostFunc$[ebp]
  000e9	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  000ec	89 4d f0	 mov	 DWORD PTR _fBackCost$[ebp], ecx

; 678  :       fHitThreshold = COST_THRESHOLD_BACK*pfCostFunc[piIndCand[0]];

  000ef	8b 55 10	 mov	 edx, DWORD PTR _piIndCand$[ebp]
  000f2	8b 02		 mov	 eax, DWORD PTR [edx]
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _pfCostFunc$[ebp]
  000f7	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f3851ec
  000fd	d8 0c 81	 fmul	 DWORD PTR [ecx+eax*4]
  00100	d9 5d e4	 fstp	 DWORD PTR _fHitThreshold$[ebp]

; 679  :       fMaxCost = HP_COST_THRESHOLD*pfCostFunc[piIndCand[iHPIndex]];

  00103	8b 55 f4	 mov	 edx, DWORD PTR _iHPIndex$[ebp]
  00106	8b 45 10	 mov	 eax, DWORD PTR _piIndCand$[ebp]
  00109	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  0010c	8b 55 08	 mov	 edx, DWORD PTR _pfCostFunc$[ebp]
  0010f	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f570a3d
  00115	d8 0c 8a	 fmul	 DWORD PTR [edx+ecx*4]
  00118	d9 5d e0	 fstp	 DWORD PTR _fMaxCost$[ebp]

; 680  : 
; 681  :       /*--------------------------------------------------
; 682  :         If the new candidate is smaller than whole selected
; 683  :         candidatesthe, or if it's small than the 
; 684  :         high-possibility one, add it to the list.
; 685  :         --------------------------------------------------*/
; 686  :       if ((iInsertPoint==iNumCand && fBackCost>=fHitThreshold)
; 687  :           || (iInsertPoint>iHPIndex && fBackCost>=fMaxCost))

  0011b	8b 45 fc	 mov	 eax, DWORD PTR _iInsertPoint$[ebp]
  0011e	3b 45 e8	 cmp	 eax, DWORD PTR _iNumCand$[ebp]
  00121	75 0d		 jne	 SHORT $L1171
  00123	d9 45 f0	 fld	 DWORD PTR _fBackCost$[ebp]
  00126	d8 5d e4	 fcomp	 DWORD PTR _fHitThreshold$[ebp]
  00129	df e0		 fnstsw	 ax
  0012b	f6 c4 01	 test	 ah, 1
  0012e	74 15		 je	 SHORT $L1170
$L1171:
  00130	8b 4d fc	 mov	 ecx, DWORD PTR _iInsertPoint$[ebp]
  00133	3b 4d f4	 cmp	 ecx, DWORD PTR _iHPIndex$[ebp]
  00136	7e 63		 jle	 SHORT $L1168
  00138	d9 45 f0	 fld	 DWORD PTR _fBackCost$[ebp]
  0013b	d8 5d e0	 fcomp	 DWORD PTR _fMaxCost$[ebp]
  0013e	df e0		 fnstsw	 ax
  00140	f6 c4 01	 test	 ah, 1
  00143	75 56		 jne	 SHORT $L1168
$L1170:

; 688  :         {
; 689  :           /*----------------------------------------
; 690  :             Shift the indeces.
; 691  :             ----------------------------------------*/
; 692  :           for (i = iNumCand; i > iInsertPoint; i--) 

  00145	8b 55 e8	 mov	 edx, DWORD PTR _iNumCand$[ebp]
  00148	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  0014b	eb 09		 jmp	 SHORT $L1172
$L1173:
  0014d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00150	83 e8 01	 sub	 eax, 1
  00153	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L1172:
  00156	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00159	3b 4d fc	 cmp	 ecx, DWORD PTR _iInsertPoint$[ebp]
  0015c	7e 15		 jle	 SHORT $L1174

; 693  :             piIndCand[i] = piIndCand[i-1];

  0015e	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00161	8b 45 10	 mov	 eax, DWORD PTR _piIndCand$[ebp]
  00164	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00167	8b 75 10	 mov	 esi, DWORD PTR _piIndCand$[ebp]
  0016a	8b 4c 8e fc	 mov	 ecx, DWORD PTR [esi+ecx*4-4]
  0016e	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  00171	eb da		 jmp	 SHORT $L1173
$L1174:

; 694  :         
; 695  :           /*----------------------------------------
; 696  :             Insert the new candidate.
; 697  :             ----------------------------------------*/
; 698  :           piIndCand[iInsertPoint] = iBackIndex;

  00173	8b 55 fc	 mov	 edx, DWORD PTR _iInsertPoint$[ebp]
  00176	8b 45 10	 mov	 eax, DWORD PTR _piIndCand$[ebp]
  00179	8b 4d 0c	 mov	 ecx, DWORD PTR _iBackIndex$[ebp]
  0017c	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 699  : 
; 700  :           /*----------------------------------------
; 701  :             Test and reset the high-possibility 
; 702  :             index.
; 703  :             ----------------------------------------*/
; 704  :           if (fBackCost>=fMaxCost)

  0017f	d9 45 f0	 fld	 DWORD PTR _fBackCost$[ebp]
  00182	d8 5d e0	 fcomp	 DWORD PTR _fMaxCost$[ebp]
  00185	df e0		 fnstsw	 ax
  00187	f6 c4 01	 test	 ah, 1
  0018a	75 06		 jne	 SHORT $L1175

; 705  :             iHPIndex = iInsertPoint;

  0018c	8b 55 fc	 mov	 edx, DWORD PTR _iInsertPoint$[ebp]
  0018f	89 55 f4	 mov	 DWORD PTR _iHPIndex$[ebp], edx
$L1175:

; 706  : 
; 707  :           /*----------------------------------------
; 708  :             Increase the number of candidates.
; 709  :             ----------------------------------------*/
; 710  :           iNumCand++;

  00192	8b 45 e8	 mov	 eax, DWORD PTR _iNumCand$[ebp]
  00195	83 c0 01	 add	 eax, 1
  00198	89 45 e8	 mov	 DWORD PTR _iNumCand$[ebp], eax
$L1168:

; 711  :         }
; 712  :     }
; 713  : 
; 714  :   /*--------------------------------------------------
; 715  :     Return the HP_Index and number of candidates.
; 716  :     --------------------------------------------------*/
; 717  :   *piHPIndex = iHPIndex;

  0019b	8b 4d 18	 mov	 ecx, DWORD PTR _piHPIndex$[ebp]
  0019e	8b 55 f4	 mov	 edx, DWORD PTR _iHPIndex$[ebp]
  001a1	89 11		 mov	 DWORD PTR [ecx], edx

; 718  :   *piNumCand = iNumCand;

  001a3	8b 45 14	 mov	 eax, DWORD PTR _piNumCand$[ebp]
  001a6	8b 4d e8	 mov	 ecx, DWORD PTR _iNumCand$[ebp]
  001a9	89 08		 mov	 DWORD PTR [eax], ecx

; 719  : 
; 720  : }

  001ab	5e		 pop	 esi
  001ac	8b e5		 mov	 esp, ebp
  001ae	5d		 pop	 ebp
  001af	c2 14 00	 ret	 20			; 00000014H
_AddBackTrackCand@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@FBAJAPB@pfMaxCost?5?$CB?$DN?5NULL?$AA@ ; `string'
;	COMDAT ??_C@_0BC@FBAJAPB@pfMaxCost?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BC@FBAJAPB@pfMaxCost?5?$CB?$DN?5NULL?$AA@ DB 'pfMaxCost != NULL', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _RefineLDPitch@24
_TEXT	SEGMENT
_pfPitchCand$ = -28
_fPitch$ = -20
_k$ = -16
_i$ = -12
_fCost$ = -8
_fBestPitch$ = -4
_iIndex$ = 8
_piPeakFreq$ = 12
_pfMag$ = 16
_iBaseBand$ = 20
_fNormEng$ = 24
_pfMaxCost$ = 28
_RefineLDPitch@24 PROC NEAR				; COMDAT

; 762  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 763  :   float fBestPitch;
; 764  :   float fPitch;
; 765  :   float fCost;
; 766  :   float pfPitchCand[2];
; 767  :   int k, i;
; 768  : 
; 769  :   assert(piPeakFreq != NULL);

  00006	83 7d 0c 00	 cmp	 DWORD PTR _piPeakFreq$[ebp], 0
  0000a	75 17		 jne	 SHORT $L1294
  0000c	68 01 03 00 00	 push	 769			; 00000301H
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@
  0001b	e8 00 00 00 00	 call	 __assert
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1294:

; 770  :   assert(pfMag != NULL);

  00023	83 7d 10 00	 cmp	 DWORD PTR _pfMag$[ebp], 0
  00027	75 17		 jne	 SHORT $L1295
  00029	68 02 03 00 00	 push	 770			; 00000302H
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@CBPJJMML@pfMag?5?$CB?$DN?5NULL?$AA@
  00038	e8 00 00 00 00	 call	 __assert
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1295:

; 771  :   assert(pfMaxCost != NULL);

  00040	83 7d 1c 00	 cmp	 DWORD PTR _pfMaxCost$[ebp], 0
  00044	75 17		 jne	 SHORT $L1296
  00046	68 03 03 00 00	 push	 771			; 00000303H
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NMJAFAHI@c?3?2xbox?2private?2windows?2directx?2@
  00050	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@FBAJAPB@pfMaxCost?5?$CB?$DN?5NULL?$AA@
  00055	e8 00 00 00 00	 call	 __assert
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1296:

; 772  : 
; 773  :   /* get the pitch candidates */
; 774  :   fBestPitch = CpfPitchTable[iIndex];

  0005d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00060	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _CpfPitchTable[eax*4]
  00067	89 4d fc	 mov	 DWORD PTR _fBestPitch$[ebp], ecx

; 775  : 
; 776  :   k = 0;

  0006a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0

; 777  :   /* find pitch period on the left side of input candidate */
; 778  :   if (iIndex > 0)

  00071	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00075	7e 23		 jle	 SHORT $L1202

; 779  :     pfPitchCand[k++] = 0.5F*(fBestPitch + CpfPitchTable[iIndex-1]);

  00077	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0007a	d9 45 fc	 fld	 DWORD PTR _fBestPitch$[ebp]
  0007d	d8 04 95 fc ff
	ff ff		 fadd	 DWORD PTR _CpfPitchTable[edx*4-4]
  00084	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  0008a	8b 45 f0	 mov	 eax, DWORD PTR _k$[ebp]
  0008d	d9 5c 85 e4	 fstp	 DWORD PTR _pfPitchCand$[ebp+eax*4]
  00091	8b 4d f0	 mov	 ecx, DWORD PTR _k$[ebp]
  00094	83 c1 01	 add	 ecx, 1
  00097	89 4d f0	 mov	 DWORD PTR _k$[ebp], ecx
$L1202:

; 780  :   iIndex++;

  0009a	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0009d	83 c2 01	 add	 edx, 1
  000a0	89 55 08	 mov	 DWORD PTR _iIndex$[ebp], edx

; 781  :   /* find pitch period on the right side of input candidate */
; 782  :   if (iIndex < PITCH_TABLE_SIZE)

  000a3	83 7d 08 59	 cmp	 DWORD PTR _iIndex$[ebp], 89 ; 00000059H
  000a7	7d 23		 jge	 SHORT $L1203

; 783  :     pfPitchCand[k++] = 0.5F*(fBestPitch + CpfPitchTable[iIndex]);

  000a9	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000ac	d9 45 fc	 fld	 DWORD PTR _fBestPitch$[ebp]
  000af	d8 04 85 00 00
	00 00		 fadd	 DWORD PTR _CpfPitchTable[eax*4]
  000b6	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  000bc	8b 4d f0	 mov	 ecx, DWORD PTR _k$[ebp]
  000bf	d9 5c 8d e4	 fstp	 DWORD PTR _pfPitchCand$[ebp+ecx*4]
  000c3	8b 55 f0	 mov	 edx, DWORD PTR _k$[ebp]
  000c6	83 c2 01	 add	 edx, 1
  000c9	89 55 f0	 mov	 DWORD PTR _k$[ebp], edx
$L1203:

; 784  : 
; 785  : 
; 786  :   /* compute the cost values of two refined pitch period. 
; 787  :      And find the maximum among the original and the two refined ones. */
; 788  :   for (i = 0; i < k; i++)

  000cc	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000d3	eb 09		 jmp	 SHORT $L1204
$L1205:
  000d5	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000d8	83 c0 01	 add	 eax, 1
  000db	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$L1204:
  000de	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000e1	3b 4d f0	 cmp	 ecx, DWORD PTR _k$[ebp]
  000e4	7d 45		 jge	 SHORT $L1206

; 789  :     {
; 790  :       fPitch = pfPitchCand[i];

  000e6	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000e9	8b 44 95 e4	 mov	 eax, DWORD PTR _pfPitchCand$[ebp+edx*4]
  000ed	89 45 ec	 mov	 DWORD PTR _fPitch$[ebp], eax

; 791  :       fCost = CalcCostFunc(fPitch, piPeakFreq, pfMag, 
; 792  :                            iBaseBand, fNormEng);

  000f0	8b 4d 18	 mov	 ecx, DWORD PTR _fNormEng$[ebp]
  000f3	51		 push	 ecx
  000f4	8b 55 14	 mov	 edx, DWORD PTR _iBaseBand$[ebp]
  000f7	52		 push	 edx
  000f8	8b 45 10	 mov	 eax, DWORD PTR _pfMag$[ebp]
  000fb	50		 push	 eax
  000fc	8b 4d 0c	 mov	 ecx, DWORD PTR _piPeakFreq$[ebp]
  000ff	51		 push	 ecx
  00100	8b 55 ec	 mov	 edx, DWORD PTR _fPitch$[ebp]
  00103	52		 push	 edx
  00104	e8 00 00 00 00	 call	 _CalcCostFunc@20
  00109	d9 5d f8	 fstp	 DWORD PTR _fCost$[ebp]

; 793  :       if (fCost > *pfMaxCost) {

  0010c	8b 45 1c	 mov	 eax, DWORD PTR _pfMaxCost$[ebp]
  0010f	d9 45 f8	 fld	 DWORD PTR _fCost$[ebp]
  00112	d8 18		 fcomp	 DWORD PTR [eax]
  00114	df e0		 fnstsw	 ax
  00116	f6 c4 41	 test	 ah, 65			; 00000041H
  00119	75 0e		 jne	 SHORT $L1207

; 794  :         fBestPitch = fPitch;

  0011b	8b 4d ec	 mov	 ecx, DWORD PTR _fPitch$[ebp]
  0011e	89 4d fc	 mov	 DWORD PTR _fBestPitch$[ebp], ecx

; 795  :         *pfMaxCost = fCost;

  00121	8b 55 1c	 mov	 edx, DWORD PTR _pfMaxCost$[ebp]
  00124	8b 45 f8	 mov	 eax, DWORD PTR _fCost$[ebp]
  00127	89 02		 mov	 DWORD PTR [edx], eax
$L1207:

; 796  :       }
; 797  :     }

  00129	eb aa		 jmp	 SHORT $L1205
$L1206:

; 798  : 
; 799  :   return fBestPitch;

  0012b	d9 45 fc	 fld	 DWORD PTR _fBestPitch$[ebp]

; 800  : }

  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 18 00	 ret	 24			; 00000018H
_RefineLDPitch@24 ENDP
_TEXT	ENDS
END
