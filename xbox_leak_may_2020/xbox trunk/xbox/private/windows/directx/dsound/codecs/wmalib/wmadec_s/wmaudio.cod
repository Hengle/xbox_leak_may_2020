; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\wmaudio.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_0DM@PJPEDCFM@?$CK?$CK?5Internal?5Error?3?5sizeof?$CItWMAFi@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
WMADEC_RW	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RW	ENDS
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAF_UpdateNewPayload@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAFileIsWMA@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAGetLicenseStore@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAFileDecodeClose@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAFileDecodeCreate@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAFileDecodeInit@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAFileDecodeInfo@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAFileContentDesc@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAFileExtendedContentDesc@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAGetNumberOfMarkers@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAGetMarker@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAFileLicenseInit@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAFileSeek@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAFileDecodeData@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMAFileGetPCM@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMARawDecCBGetData@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, WMADEC_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_DSoundBuildNumberD
_DATA	SEGMENT
COMM	_pDrmBuffer:BYTE:01000H
_DATA	ENDS
WMADEC_RD	SEGMENT
_WMA_OK	DD	00H
_WMA_S_FALSE DD	01H
_WMA_S_BUFUNDERFLOW DD 02H
_WMA_S_NEWPACKET DD 03H
_WMA_S_NO_MORE_FRAME DD 04H
_WMA_S_NO_MORE_SRCDATA DD 05H
_WMA_E_FAIL DD	080004005H
_WMA_E_OUTOFMEMORY DD 08007000eH
_WMA_E_INVALIDARG DD 080070057H
_WMA_E_NOTSUPPORTED DD 080040000H
_WMA_E_LOSTPACKET DD 080040001H
_WMA_E_BROKEN_FRAME DD 080040002H
_WMA_E_BUFFEROVERFLOW DD 080040003H
_WMA_E_ONHOLD DD 080040004H
WMADEC_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT
_DSoundBuildNumberD DW 05344H
	DW	0554fH
	DW	0444eH
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_WMAFileIsWMA@4
PUBLIC	??_C@_0DM@PJPEDCFM@?$CK?$CK?5Internal?5Error?3?5sizeof?$CItWMAFi@ ; `string'
EXTRN	_WMADebugMessage:NEAR
EXTRN	_WMA_ParseAsfHeader@8:NEAR
;	COMDAT ??_C@_0DM@PJPEDCFM@?$CK?$CK?5Internal?5Error?3?5sizeof?$CItWMAFi@
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wmaudio.c
WMADEC_RD	SEGMENT
??_C@_0DM@PJPEDCFM@?$CK?$CK?5Internal?5Error?3?5sizeof?$CItWMAFi@ DB '** '
	DB	'Internal Error: sizeof(tWMAFileHdrStateInternal) = %d.', 0aH, 0dH
	DB	00H						; `string'
; Function compile flags: /Odt
WMADEC_RD	ENDS
;	COMDAT _WMAFileIsWMA@4
WMADEC	SEGMENT
_wmarc$ = -8
_pInt$ = -4
_pstate$ = 8
_WMAFileIsWMA@4 PROC NEAR				; COMDAT

; 691  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 692  :     tWMAFileHdrStateInternal *pInt = (tWMAFileHdrStateInternal *)pstate;

  00006	8b 45 08	 mov	 eax, DWORD PTR _pstate$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _pInt$[ebp], eax

; 693  :     WMAERR wmarc;
; 694  : 
; 695  :     if(sizeof(tWMAFileHdrState) != sizeof(tWMAFileHdrStateInternal))

  0000c	b9 01 00 00 00	 mov	 ecx, 1
  00011	85 c9		 test	 ecx, ecx
  00013	74 19		 je	 SHORT $L8898

; 696  :     {
; 697  :         /* this should NOT happen */
; 698  :         WMADebugMessage("** Internal Error: sizeof(tWMAFileHdrStateInternal) = %d.\n\r",
; 699  :                 sizeof(tWMAFileHdrStateInternal));

  00015	68 c4 00 00 00	 push	 196			; 000000c4H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DM@PJPEDCFM@?$CK?$CK?5Internal?5Error?3?5sizeof?$CItWMAFi@
  0001f	e8 00 00 00 00	 call	 _WMADebugMessage
  00024	83 c4 08	 add	 esp, 8

; 700  :         // while(1);
; 701  :         return cWMA_BadArgument;

  00027	b8 02 00 00 00	 mov	 eax, 2
  0002c	eb 2a		 jmp	 SHORT $L8892
$L8898:

; 702  :     }
; 703  :     if(pInt == NULL)

  0002e	83 7d fc 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00032	75 07		 jne	 SHORT $L8902

; 704  :         return cWMA_BadArgument;

  00034	b8 02 00 00 00	 mov	 eax, 2
  00039	eb 1d		 jmp	 SHORT $L8892
$L8902:

; 705  : 
; 706  :     /* parse ASF header */
; 707  : 
; 708  :     wmarc = WMA_ParseAsfHeader(pInt, 0);

  0003b	6a 00		 push	 0
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 _WMA_ParseAsfHeader@8
  00046	89 45 f8	 mov	 DWORD PTR _wmarc$[ebp], eax

; 709  :     if(wmarc != WMAERR_OK)

  00049	83 7d f8 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  0004d	74 07		 je	 SHORT $L8903

; 710  :         return cWMA_BadAsfHeader;

  0004f	b8 03 00 00 00	 mov	 eax, 3
  00054	eb 02		 jmp	 SHORT $L8892
$L8903:

; 711  : 
; 712  :     return cWMA_NoErr;

  00056	33 c0		 xor	 eax, eax
$L8892:

; 713  : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
_WMAFileIsWMA@4 ENDP
WMADEC	ENDS
PUBLIC	_WMAGetLicenseStore@8
; Function compile flags: /Odt
;	COMDAT _WMAGetLicenseStore@8
WMADEC	SEGMENT
_pInt$ = -4
_pstate$ = 8
_pLen$ = 12
_WMAGetLicenseStore@8 PROC NEAR				; COMDAT

; 719  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 720  :     tWMAFileHdrStateInternal *pInt = (tWMAFileHdrStateInternal *)pstate;

  00004	8b 45 08	 mov	 eax, DWORD PTR _pstate$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pInt$[ebp], eax

; 721  : 
; 722  :     if(sizeof(tWMAFileHdrState) != sizeof(tWMAFileHdrStateInternal))

  0000a	b9 01 00 00 00	 mov	 ecx, 1
  0000f	85 c9		 test	 ecx, ecx
  00011	74 16		 je	 SHORT $L8913

; 723  :     {
; 724  :         /* this should NOT happen */
; 725  :         WMADebugMessage("** Internal Error: sizeof(tWMAFileHdrStateInternal) = %d.\n\r",
; 726  :                 sizeof(tWMAFileHdrStateInternal));

  00013	68 c4 00 00 00	 push	 196			; 000000c4H
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DM@PJPEDCFM@?$CK?$CK?5Internal?5Error?3?5sizeof?$CItWMAFi@
  0001d	e8 00 00 00 00	 call	 _WMADebugMessage
  00022	83 c4 08	 add	 esp, 8

; 727  :         // while(1);
; 728  :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 21		 jmp	 SHORT $L8908
$L8913:

; 729  :     }
; 730  :     if(pInt == NULL)

  00029	83 7d fc 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  0002d	75 04		 jne	 SHORT $L8917

; 731  :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 17		 jmp	 SHORT $L8908
$L8917:

; 732  : 
; 733  :     *pLen = pInt->m_dwLicenseLen;

  00033	8b 55 0c	 mov	 edx, DWORD PTR _pLen$[ebp]
  00036	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  00039	8b 88 b4 00 00
	00		 mov	 ecx, DWORD PTR [eax+180]
  0003f	89 0a		 mov	 DWORD PTR [edx], ecx

; 734  : 
; 735  :     return pInt->m_pLicData;

  00041	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00044	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
$L8908:

; 736  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
_WMAGetLicenseStore@8 ENDP
WMADEC	ENDS
PUBLIC	_WMAFileDecodeClose@4
EXTRN	_WMARawDecClose@4:NEAR
EXTRN	_free:NEAR
; Function compile flags: /Odt
;	COMDAT _WMAFileDecodeClose@4
WMADEC	SEGMENT
_i$ = -8
_pInt$ = -4
_phstate$ = 8
_WMAFileDecodeClose@4 PROC NEAR				; COMDAT

; 742  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 743  :     tWMAFileStateInternal *pInt;
; 744  :     unsigned int i;
; 745  : 
; 746  :     pInt = (tWMAFileStateInternal*) (*phstate);

  00006	8b 45 08	 mov	 eax, DWORD PTR _phstate$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d fc	 mov	 DWORD PTR _pInt$[ebp], ecx

; 747  : 
; 748  :     if (pInt != NULL ) {

  0000e	83 7d fc 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00012	0f 84 51 01 00
	00		 je	 $L8926

; 749  :         WMARawDecClose (&(pInt->hWMA));

  00018	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  0001b	81 c2 58 01 00
	00		 add	 edx, 344		; 00000158H
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 _WMARawDecClose@4

; 750  : #ifndef WMAAPI_NO_DRM
; 751  : 		if (pInt->pDRM_state != NULL) {
; 752  : 			free (pInt->pDRM_state);
; 753  :             pInt->pDRM_state = NULL;
; 754  :         }
; 755  : #endif
; 756  : #if 0
; 757  :         if (pInt->hdr_parse.m_pMarkers) {
; 758  :             for (i=0;i<pInt->hdr_parse.m_dwMarkerNum;i++)
; 759  :                 if ( pInt->hdr_parse.m_pMarkers[i].m_pwDescName != NULL )
; 760  :                 {
; 761  :                     free (pInt->hdr_parse.m_pMarkers[i].m_pwDescName);
; 762  :                     pInt->hdr_parse.m_pMarkers[i].m_pwDescName = NULL;
; 763  :                 }
; 764  :             free (pInt->hdr_parse.m_pMarkers);
; 765  :             pInt->hdr_parse.m_pMarkers = NULL;
; 766  :         }
; 767  : #endif 
; 768  :         if (pInt->hdr_parse.m_pLicData) 

  00027	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  0002a	83 b8 b8 00 00
	00 00		 cmp	 DWORD PTR [eax+184], 0
  00031	74 1f		 je	 SHORT $L8927

; 769  :         {
; 770  :     		free (pInt->hdr_parse.m_pLicData);

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00036	8b 91 b8 00 00
	00		 mov	 edx, DWORD PTR [ecx+184]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _free
  00042	83 c4 04	 add	 esp, 4

; 771  :             pInt->hdr_parse.m_pLicData = NULL;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  00048	c7 80 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+184], 0
$L8927:

; 772  :         }
; 773  : 
; 774  :         if(pInt->hdr_parse.m_pECDesc != NULL) {

  00052	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00055	83 b9 a8 00 00
	00 00		 cmp	 DWORD PTR [ecx+168], 0
  0005c	0f 84 f2 00 00
	00		 je	 $L8930

; 775  :             if(pInt->hdr_parse.m_pECDesc->cDescriptors > 0) {

  00062	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00065	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  0006b	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0006e	85 c9		 test	 ecx, ecx
  00070	0f 8e bf 00 00
	00		 jle	 $L8931

; 776  :                 for (i = 0; i < (unsigned int) pInt->hdr_parse.m_pECDesc->cDescriptors; i++) {

  00076	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0007d	eb 09		 jmp	 SHORT $L8933
$L8934:
  0007f	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00082	83 c2 01	 add	 edx, 1
  00085	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L8933:
  00088	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  0008b	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00091	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00094	39 55 f8	 cmp	 DWORD PTR _i$[ebp], edx
  00097	73 77		 jae	 SHORT $L8935

; 777  :                     free(pInt->hdr_parse.m_pECDesc->pDescriptors[i].uValue.pbBinary);

  00099	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  0009c	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  000a2	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000a5	6b d2 0e	 imul	 edx, 14			; 0000000eH
  000a8	8b 41 02	 mov	 eax, DWORD PTR [ecx+2]
  000ab	8b 4c 10 0a	 mov	 ecx, DWORD PTR [eax+edx+10]
  000af	51		 push	 ecx
  000b0	e8 00 00 00 00	 call	 _free
  000b5	83 c4 04	 add	 esp, 4

; 778  :                     free(pInt->hdr_parse.m_pECDesc->pDescriptors[i].pwszName);

  000b8	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  000bb	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  000c1	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000c4	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  000c7	8b 50 02	 mov	 edx, DWORD PTR [eax+2]
  000ca	8b 44 0a 02	 mov	 eax, DWORD PTR [edx+ecx+2]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 _free
  000d4	83 c4 04	 add	 esp, 4

; 779  :                     pInt->hdr_parse.m_pECDesc->pDescriptors[i].uValue.pbBinary = NULL;

  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000da	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  000e0	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000e3	6b c0 0e	 imul	 eax, 14			; 0000000eH
  000e6	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  000e9	c7 44 01 0a 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+10], 0

; 780  :                     pInt->hdr_parse.m_pECDesc->pDescriptors[i].pwszName = NULL;

  000f1	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  000f4	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  000fa	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000fd	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  00100	8b 50 02	 mov	 edx, DWORD PTR [eax+2]
  00103	c7 44 0a 02 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+2], 0

; 781  :                 }

  0010b	e9 6f ff ff ff	 jmp	 $L8934
$L8935:

; 782  :                 free(pInt->hdr_parse.m_pECDesc->pDescriptors);

  00110	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  00113	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00119	8b 51 02	 mov	 edx, DWORD PTR [ecx+2]
  0011c	52		 push	 edx
  0011d	e8 00 00 00 00	 call	 _free
  00122	83 c4 04	 add	 esp, 4

; 783  :                 pInt->hdr_parse.m_pECDesc->pDescriptors = NULL;

  00125	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  00128	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  0012e	c7 41 02 00 00
	00 00		 mov	 DWORD PTR [ecx+2], 0
$L8931:

; 784  :             }
; 785  :             free(pInt->hdr_parse.m_pECDesc);

  00135	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00138	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 _free
  00144	83 c4 04	 add	 esp, 4

; 786  :             pInt->hdr_parse.m_pECDesc = NULL;

  00147	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0014a	c7 81 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+168], 0
$L8930:

; 787  :         }
; 788  : 
; 789  : 		free (pInt);

  00154	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00157	52		 push	 edx
  00158	e8 00 00 00 00	 call	 _free
  0015d	83 c4 04	 add	 esp, 4

; 790  :         *phstate = NULL;

  00160	8b 45 08	 mov	 eax, DWORD PTR _phstate$[ebp]
  00163	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L8926:

; 791  :     }
; 792  :     phstate = NULL;

  00169	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _phstate$[ebp], 0

; 793  :     return cWMA_NoErr;

  00170	33 c0		 xor	 eax, eax

; 794  : }

  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c2 04 00	 ret	 4
_WMAFileDecodeClose@4 ENDP
WMADEC	ENDS
PUBLIC	_WMAFileDecodeCreate@8
EXTRN	_memset:NEAR
EXTRN	_malloc:NEAR
; Function compile flags: /Odt
;	COMDAT _WMAFileDecodeCreate@8
WMADEC	SEGMENT
_pInt$ = -4
_phstate$ = 8
_pCallbackContext$ = 12
_WMAFileDecodeCreate@8 PROC NEAR			; COMDAT

; 801  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 802  :     tWMAFileStateInternal *pInt;
; 803  : 
; 804  : #ifdef USE_WOW_FILTER
; 805  :     WowControls         tempWowControls;
; 806  : #endif
; 807  : 
; 808  :     // first try to close in case someone calls us without prior close
; 809  :     WMAFileDecodeClose (phstate);

  00004	8b 45 08	 mov	 eax, DWORD PTR _phstate$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _WMAFileDecodeClose@4

; 810  : 
; 811  :     // Now start to allocate and initialize
; 812  : 
; 813  :     pInt = (tWMAFileStateInternal*) malloc (sizeof (tWMAFileStateInternal));

  0000d	68 60 01 00 00	 push	 352			; 00000160H
  00012	e8 00 00 00 00	 call	 _malloc
  00017	83 c4 04	 add	 esp, 4
  0001a	89 45 fc	 mov	 DWORD PTR _pInt$[ebp], eax

; 814  : 
; 815  :     if (pInt == NULL)

  0001d	83 7d fc 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00021	75 07		 jne	 SHORT $L8952

; 816  :         return cWMA_Failed;

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	eb 42		 jmp	 SHORT $L8947
$L8952:

; 817  : 
; 818  :     memset (pInt, 0, sizeof (tWMAFileStateInternal));

  0002a	68 60 01 00 00	 push	 352			; 00000160H
  0002f	6a 00		 push	 0
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _memset
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 819  : 
; 820  :     /* initialize the some state */
; 821  : 
; 822  :     pInt->parse_state = csWMA_HeaderStart;

  0003d	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00040	c7 82 c8 00 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+200], 1

; 823  :     // georgioc
; 824  :     pInt->pCallbackContext = pCallbackContext;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _pCallbackContext$[ebp]
  00050	89 88 c4 00 00
	00		 mov	 DWORD PTR [eax+196], ecx

; 825  :     pInt->hdr_parse.pCallbackContext = pCallbackContext;

  00056	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00059	8b 45 0c	 mov	 eax, DWORD PTR _pCallbackContext$[ebp]
  0005c	89 82 c0 00 00
	00		 mov	 DWORD PTR [edx+192], eax

; 826  : 
; 827  :     /* parse ASF header */
; 828  : 
; 829  :     *phstate = (tHWMAFileState) pInt;

  00062	8b 4d 08	 mov	 ecx, DWORD PTR _phstate$[ebp]
  00065	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00068	89 11		 mov	 DWORD PTR [ecx], edx

; 830  : 
; 831  :     return cWMA_NoErr;

  0006a	33 c0		 xor	 eax, eax
$L8947:

; 832  : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 08 00	 ret	 8
_WMAFileDecodeCreate@8 ENDP
WMADEC	ENDS
PUBLIC	_WMAFileDecodeInit@4
PUBLIC	_WMARawDecCBGetData@16
EXTRN	_WMARawDecInit@44:NEAR
; Function compile flags: /Odt
;	COMDAT _WMAFileDecodeInit@4
WMADEC	SEGMENT
_p$8975 = -16
_wmarc$ = -12
_wmar$ = -8
_pInt$ = -4
_hstate$ = 8
_WMAFileDecodeInit@4 PROC NEAR				; COMDAT

; 835  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 836  :     tWMAFileStateInternal *pInt;
; 837  :     WMAERR wmarc;
; 838  :     WMARESULT wmar;
; 839  : #ifndef WMAAPI_NO_DRM
; 840  :     HRESULT hr;
; 841  : #endif // WMAAPI_NO_DRM
; 842  : 
; 843  : #ifdef USE_WOW_FILTER
; 844  :     WowControls         tempWowControls;
; 845  : #endif
; 846  : 
; 847  :     pInt = (tWMAFileStateInternal*) hstate;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hstate$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _pInt$[ebp], eax

; 848  : 
; 849  :     wmarc = WMA_ParseAsfHeader(&pInt->hdr_parse, 1);

  0000c	6a 01		 push	 1
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 _WMA_ParseAsfHeader@8
  00017	89 45 f4	 mov	 DWORD PTR _wmarc$[ebp], eax

; 850  :     if(wmarc != WMAERR_OK)

  0001a	83 7d f4 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  0001e	74 0a		 je	 SHORT $L8962

; 851  :         return cWMA_BadAsfHeader;

  00020	b8 03 00 00 00	 mov	 eax, 3
  00025	e9 37 01 00 00	 jmp	 $L8957
$L8962:

; 852  : 
; 853  :     /* Set up and initialize the WMA bitstreamd decoder */
; 854  : 
; 855  :     wmar = WMARawDecInit (
; 856  :         &pInt->hWMA,
; 857  :         (U32_WMARawDec) pInt,
; 858  :         WMARawDecCBGetData,
; 859  :         (U16_WMARawDec) pInt->hdr_parse.nVersion,
; 860  :         (U16_WMARawDec) pInt->hdr_parse.nSamplesPerBlock,
; 861  :         (U16_WMARawDec) pInt->hdr_parse.nSamplesPerSec,
; 862  :         (U16_WMARawDec) pInt->hdr_parse.nChannels,
; 863  :         (U16_WMARawDec) pInt->hdr_parse.nAvgBytesPerSec,
; 864  :         (U16_WMARawDec) pInt->hdr_parse.nBlockAlign,
; 865  :         (U16_WMARawDec) pInt->hdr_parse.nEncodeOpt,
; 866  :         0
; 867  :     );

  0002a	6a 00		 push	 0
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  0002f	66 8b 42 40	 mov	 ax, WORD PTR [edx+64]
  00033	50		 push	 eax
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00037	66 8b 51 34	 mov	 dx, WORD PTR [ecx+52]
  0003b	52		 push	 edx
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  0003f	66 8b 48 30	 mov	 cx, WORD PTR [eax+48]
  00043	51		 push	 ecx
  00044	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00047	66 8b 42 38	 mov	 ax, WORD PTR [edx+56]
  0004b	50		 push	 eax
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0004f	66 8b 51 2c	 mov	 dx, WORD PTR [ecx+44]
  00053	52		 push	 edx
  00054	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  00057	66 8b 48 3c	 mov	 cx, WORD PTR [eax+60]
  0005b	51		 push	 ecx
  0005c	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  0005f	66 8b 42 28	 mov	 ax, WORD PTR [edx+40]
  00063	50		 push	 eax
  00064	68 00 00 00 00	 push	 OFFSET FLAT:_WMARawDecCBGetData@16
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00070	81 c2 58 01 00
	00		 add	 edx, 344		; 00000158H
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 _WMARawDecInit@44
  0007c	89 45 f8	 mov	 DWORD PTR _wmar$[ebp], eax

; 868  :  	if (wmar == 0x80040000)

  0007f	81 7d f8 00 00
	04 80		 cmp	 DWORD PTR _wmar$[ebp], -2147221504 ; 80040000H
  00086	75 0a		 jne	 SHORT $L8971

; 869  :         return cWMA_BadSamplingRate;

  00088	b8 07 00 00 00	 mov	 eax, 7
  0008d	e9 cf 00 00 00	 jmp	 $L8957
$L8971:

; 870  : 
; 871  : 	if (wmar != WMA_OK)

  00092	8b 45 f8	 mov	 eax, DWORD PTR _wmar$[ebp]
  00095	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  0009b	74 0a		 je	 SHORT $L8972

; 872  :         return cWMA_Failed;

  0009d	b8 01 00 00 00	 mov	 eax, 1
  000a2	e9 ba 00 00 00	 jmp	 $L8957
$L8972:

; 873  : 
; 874  :     /* Set up the decryption if necessary */
; 875  : 
; 876  :     pInt->bHasDRM = (BOOL) 0;

  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000aa	c7 81 50 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+336], 0

; 877  : 
; 878  :     if(pInt->hdr_parse.cbSecretData > 0)

  000b4	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  000b7	83 7a 64 00	 cmp	 DWORD PTR [edx+100], 0
  000bb	76 4d		 jbe	 SHORT $L8974

; 879  :     {
; 880  :         /* only for DRM now */
; 881  :         char *p = (char *)pInt->hdr_parse.pbType;

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  000c0	83 c0 68	 add	 eax, 104		; 00000068H
  000c3	89 45 f0	 mov	 DWORD PTR _p$8975[ebp], eax

; 882  : 
; 883  :         if(p[0] == 'D' && p[1] == 'R' && p[2] == 'M' && p[3] == '\0')

  000c6	8b 4d f0	 mov	 ecx, DWORD PTR _p$8975[ebp]
  000c9	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000cc	83 fa 44	 cmp	 edx, 68			; 00000044H
  000cf	75 32		 jne	 SHORT $L8977
  000d1	8b 45 f0	 mov	 eax, DWORD PTR _p$8975[ebp]
  000d4	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  000d8	83 f9 52	 cmp	 ecx, 82			; 00000052H
  000db	75 26		 jne	 SHORT $L8977
  000dd	8b 55 f0	 mov	 edx, DWORD PTR _p$8975[ebp]
  000e0	0f be 42 02	 movsx	 eax, BYTE PTR [edx+2]
  000e4	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  000e7	75 1a		 jne	 SHORT $L8977
  000e9	8b 4d f0	 mov	 ecx, DWORD PTR _p$8975[ebp]
  000ec	0f be 51 03	 movsx	 edx, BYTE PTR [ecx+3]
  000f0	85 d2		 test	 edx, edx
  000f2	75 0f		 jne	 SHORT $L8977

; 884  :         {
; 885  :             pInt->bHasDRM = (BOOL)( 1 );

  000f4	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  000f7	c7 80 50 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+336], 1

; 886  : 
; 887  : #ifndef WMAAPI_NO_DRM
; 888  :             pInt->pDRM_state = (CDrmPD*) malloc (sizeof (CDrmPD));
; 889  :             if (pInt->pDRM_state == NULL)
; 890  :                 return cWMA_DRMFailed;
; 891  : #ifndef WMAAPI_NO_DRM
; 892  : #ifdef GLOBAL_SECRET
; 893  :             SetSecret_1of7 (pInt->pDRM_state);
; 894  : #endif // GLOBAL_SECRET
; 895  : #endif /* WMAAPI_NO_DRM */
; 896  :             hr = CDrmPD_Init(pInt->pDRM_state,pDrmBuffer,2048);
; 897  :             if(hr != S_OK)
; 898  :                 return cWMA_DRMFailed;
; 899  : #endif /* WMAAPI_NO_DRM */
; 900  :         }
; 901  :         else

  00101	eb 07		 jmp	 SHORT $L8974
$L8977:

; 902  :             return cWMA_BadDRMType;

  00103	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00108	eb 57		 jmp	 SHORT $L8957
$L8974:

; 903  :     }
; 904  : 
; 905  :     pInt->hdr_parse.cbLastPacketOffset = pInt->hdr_parse.cbFirstPacketOffset;

  0010a	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0010d	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00110	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00113	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 906  :     if (pInt->hdr_parse.cPackets > 0)

  00116	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00119	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  0011d	76 1c		 jbe	 SHORT $L8980

; 907  :         pInt->hdr_parse.cbLastPacketOffset += (pInt->hdr_parse.cPackets - 1)*pInt->hdr_parse.cbPacketSize;

  0011f	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00122	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00125	83 e8 01	 sub	 eax, 1
  00128	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0012b	0f af 41 0c	 imul	 eax, DWORD PTR [ecx+12]
  0012f	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00132	03 42 24	 add	 eax, DWORD PTR [edx+36]
  00135	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00138	89 41 24	 mov	 DWORD PTR [ecx+36], eax
$L8980:

; 908  : 
; 909  : 	pInt->hdr_parse.currPacketOffset = pInt->hdr_parse.cbHeader;// Added by amit

  0013b	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  0013e	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  00141	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00144	89 0a		 mov	 DWORD PTR [edx], ecx

; 910  :     pInt->hdr_parse.nextPacketOffset = pInt->hdr_parse.cbHeader;

  00146	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00149	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  0014c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0014f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 911  :     pInt->parse_state = csWMA_NewAsfPacket;

  00152	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00155	c7 82 c8 00 00
	00 03 00 00 00	 mov	 DWORD PTR [edx+200], 3

; 912  : 
; 913  : 
; 914  : 
; 915  : #ifdef USE_WOW_FILTER
; 916  :     tempWowControls.bEnableWow = TRUE;
; 917  :     tempWowControls.bMonoInput = FALSE;
; 918  :     tempWowControls.bHighBitRate = TRUE;
; 919  :     tempWowControls.iSampleRate = k44100;
; 920  :     tempWowControls.mBrightness = kHigh;
; 921  :     tempWowControls.mSpeakerSize = kMedium;
; 922  :     tempWowControls.dTruBass = 0.8;
; 923  :     tempWowControls.dWidthControl = 0.6;
; 924  : 
; 925  :     switch(pInt->hdr_parse.nSamplesPerSec)
; 926  :     {
; 927  :         case 22050:
; 928  :                 tempWowControls.iSampleRate = k22050;
; 929  :                 break;
; 930  :         case 32000:
; 931  :                 tempWowControls.iSampleRate = k32000;
; 932  :                 break;
; 933  :         case 44100:
; 934  :                 tempWowControls.iSampleRate = k44100;
; 935  :                 break;
; 936  :         default:
; 937  :                 break;
; 938  :     }
; 939  : 
; 940  :     if ( pInt->hdr_parse.nChannels  == 1)
; 941  :     {
; 942  :             tempWowControls.bMonoInput          = TRUE;
; 943  :     }
; 944  : 
; 945  : 	if ( pInt->hdr_parse.nAvgBytesPerSec * 8 < 64000)
; 946  : 		tempWowControls.bHighBitRate    = FALSE;
; 947  : 
; 948  :     tempWowControls.bEnableWow      = TRUE;
; 949  : 
; 950  :     if ( InitWow(&(pInt->sWowChannel), &tempWowControls ) != 0) {
; 951  :         return cWMA_BadDRMType;   //NQF_temp
; 952  :     }
; 953  : 
; 954  : #endif  //USE_WOW_FILTER
; 955  : 
; 956  :     return cWMA_NoErr;

  0015f	33 c0		 xor	 eax, eax
$L8957:

; 957  : }

  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c2 04 00	 ret	 4
_WMAFileDecodeInit@4 ENDP
WMADEC	ENDS
PUBLIC	_WMAFileDecodeInfo@8
; Function compile flags: /Odt
;	COMDAT _WMAFileDecodeInfo@8
WMADEC	SEGMENT
tv72 = -8
_pInt$ = -4
_hstate$ = 8
_hdr$ = 12
_WMAFileDecodeInfo@8 PROC NEAR				; COMDAT

; 965  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 966  :     tWMAFileStateInternal *pInt; 
; 967  :     pInt = (tWMAFileStateInternal*) hstate;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hstate$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _pInt$[ebp], eax

; 968  : 
; 969  :     if(pInt == NULL || hdr == NULL)

  0000c	83 7d fc 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00010	74 06		 je	 SHORT $L8991
  00012	83 7d 0c 00	 cmp	 DWORD PTR _hdr$[ebp], 0
  00016	75 0a		 jne	 SHORT $L8990
$L8991:

; 970  :         return cWMA_BadArgument;

  00018	b8 02 00 00 00	 mov	 eax, 2
  0001d	e9 28 01 00 00	 jmp	 $L8985
$L8990:

; 971  : 
; 972  :     /* Fill in the structure */
; 973  : 
; 974  :     hdr->version      = (tWMAFileVersion)pInt->hdr_parse.nVersion;

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00025	0f b7 51 28	 movzx	 edx, WORD PTR [ecx+40]
  00029	8b 45 0c	 mov	 eax, DWORD PTR _hdr$[ebp]
  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 975  :     hdr->num_channels = (tWMAFileChannels)pInt->hdr_parse.nChannels;

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00031	0f b7 51 38	 movzx	 edx, WORD PTR [ecx+56]
  00035	8b 45 0c	 mov	 eax, DWORD PTR _hdr$[ebp]
  00038	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 976  : 
; 977  :     switch(pInt->hdr_parse.nSamplesPerSec)
; 978  :     {

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0003e	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00041	89 55 f8	 mov	 DWORD PTR tv72[ebp], edx
  00044	81 7d f8 22 56
	00 00		 cmp	 DWORD PTR tv72[ebp], 22050 ; 00005622H
  0004b	77 26		 ja	 SHORT $L9356
  0004d	81 7d f8 22 56
	00 00		 cmp	 DWORD PTR tv72[ebp], 22050 ; 00005622H
  00054	74 5e		 je	 SHORT $L9001
  00056	81 7d f8 40 1f
	00 00		 cmp	 DWORD PTR tv72[ebp], 8000 ; 00001f40H
  0005d	74 31		 je	 SHORT $L8998
  0005f	81 7d f8 11 2b
	00 00		 cmp	 DWORD PTR tv72[ebp], 11025 ; 00002b11H
  00066	74 34		 je	 SHORT $L8999
  00068	81 7d f8 80 3e
	00 00		 cmp	 DWORD PTR tv72[ebp], 16000 ; 00003e80H
  0006f	74 37		 je	 SHORT $L9000
  00071	eb 71		 jmp	 SHORT $L9005
$L9356:
  00073	81 7d f8 00 7d
	00 00		 cmp	 DWORD PTR tv72[ebp], 32000 ; 00007d00H
  0007a	74 44		 je	 SHORT $L9002
  0007c	81 7d f8 44 ac
	00 00		 cmp	 DWORD PTR tv72[ebp], 44100 ; 0000ac44H
  00083	74 47		 je	 SHORT $L9003
  00085	81 7d f8 80 bb
	00 00		 cmp	 DWORD PTR tv72[ebp], 48000 ; 0000bb80H
  0008c	74 4a		 je	 SHORT $L9004
  0008e	eb 54		 jmp	 SHORT $L9005
$L8998:

; 979  :     case 8000:
; 980  :         hdr->sample_rate = cWMA_SR_08kHz;

  00090	8b 45 0c	 mov	 eax, DWORD PTR _hdr$[ebp]
  00093	c7 40 04 06 00
	00 00		 mov	 DWORD PTR [eax+4], 6

; 981  :         break;

  0009a	eb 4f		 jmp	 SHORT $L8995
$L8999:

; 982  :     case 11025:
; 983  :         hdr->sample_rate = cWMA_SR_11_025kHz;

  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR _hdr$[ebp]
  0009f	c7 41 04 05 00
	00 00		 mov	 DWORD PTR [ecx+4], 5

; 984  :         break;

  000a6	eb 43		 jmp	 SHORT $L8995
$L9000:

; 985  :     case 16000:
; 986  :         hdr->sample_rate = cWMA_SR_16kHz;

  000a8	8b 55 0c	 mov	 edx, DWORD PTR _hdr$[ebp]
  000ab	c7 42 04 04 00
	00 00		 mov	 DWORD PTR [edx+4], 4

; 987  :         break;

  000b2	eb 37		 jmp	 SHORT $L8995
$L9001:

; 988  :     case 22050:
; 989  :         hdr->sample_rate = cWMA_SR_22_05kHz;

  000b4	8b 45 0c	 mov	 eax, DWORD PTR _hdr$[ebp]
  000b7	c7 40 04 03 00
	00 00		 mov	 DWORD PTR [eax+4], 3

; 990  :         break;

  000be	eb 2b		 jmp	 SHORT $L8995
$L9002:

; 991  :     case 32000:
; 992  :         hdr->sample_rate = cWMA_SR_32kHz;

  000c0	8b 4d 0c	 mov	 ecx, DWORD PTR _hdr$[ebp]
  000c3	c7 41 04 02 00
	00 00		 mov	 DWORD PTR [ecx+4], 2

; 993  :         break;

  000ca	eb 1f		 jmp	 SHORT $L8995
$L9003:

; 994  :     case 44100:
; 995  :         hdr->sample_rate = cWMA_SR_44_1kHz;

  000cc	8b 55 0c	 mov	 edx, DWORD PTR _hdr$[ebp]
  000cf	c7 42 04 01 00
	00 00		 mov	 DWORD PTR [edx+4], 1

; 996  :         break;

  000d6	eb 13		 jmp	 SHORT $L8995
$L9004:

; 997  :     case 48000:
; 998  :         hdr->sample_rate = cWMA_SR_48kHz;

  000d8	8b 45 0c	 mov	 eax, DWORD PTR _hdr$[ebp]
  000db	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 999  :         break;

  000e2	eb 07		 jmp	 SHORT $L8995
$L9005:

; 1000 :     default:
; 1001 :         return cWMA_BadSamplingRate;

  000e4	b8 07 00 00 00	 mov	 eax, 7
  000e9	eb 5f		 jmp	 SHORT $L8985
$L8995:

; 1002 :     }
; 1003 : 
; 1004 :     hdr->duration            = pInt->hdr_parse.msDuration;

  000eb	8b 4d 0c	 mov	 ecx, DWORD PTR _hdr$[ebp]
  000ee	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  000f1	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000f4	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1005 :     hdr->packet_size         = pInt->hdr_parse.cbPacketSize;

  000f7	8b 4d 0c	 mov	 ecx, DWORD PTR _hdr$[ebp]
  000fa	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  000fd	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00100	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 1006 :     hdr->first_packet_offset = pInt->hdr_parse.cbFirstPacketOffset;

  00103	8b 4d 0c	 mov	 ecx, DWORD PTR _hdr$[ebp]
  00106	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00109	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0010c	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1007 :     hdr->last_packet_offset  = pInt->hdr_parse.cbLastPacketOffset;

  0010f	8b 4d 0c	 mov	 ecx, DWORD PTR _hdr$[ebp]
  00112	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00115	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00118	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1008 : 
; 1009 :     hdr->has_DRM             = (tWMA_U32)pInt->bHasDRM;

  0011b	8b 4d 0c	 mov	 ecx, DWORD PTR _hdr$[ebp]
  0011e	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00121	8b 82 50 01 00
	00		 mov	 eax, DWORD PTR [edx+336]
  00127	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 1010 : 
; 1011 :     hdr->LicenseLength       = (tWMA_U32)pInt->hdr_parse.m_dwLicenseLen;

  0012a	8b 4d 0c	 mov	 ecx, DWORD PTR _hdr$[ebp]
  0012d	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00130	8b 82 b4 00 00
	00		 mov	 eax, DWORD PTR [edx+180]
  00136	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 1012 : 
; 1013 :     hdr->bitrate             = pInt->hdr_parse.nAvgBytesPerSec*8;

  00139	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0013c	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0013f	c1 e2 03	 shl	 edx, 3
  00142	8b 45 0c	 mov	 eax, DWORD PTR _hdr$[ebp]
  00145	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 1014 : 
; 1015 :     return cWMA_NoErr;

  00148	33 c0		 xor	 eax, eax
$L8985:

; 1016 : }

  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c2 08 00	 ret	 8
_WMAFileDecodeInfo@8 ENDP
WMADEC	ENDS
PUBLIC	_WMAFileContentDesc@8
EXTRN	_WMA_GetBuffer@16:NEAR
; Function compile flags: /Odt
;	COMDAT _WMAFileContentDesc@8
WMADEC	SEGMENT
tv276 = -36
tv232 = -32
tv191 = -28
tv153 = -24
tv87 = -20
_cbActual$ = -16
_cbWanted$ = -12
_pInt$ = -8
_cbOffset$ = -4
_hstate$ = 8
_desc$ = 12
_WMAFileContentDesc@8 PROC NEAR				; COMDAT

; 1023 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 1024 :     tWMAFileStateInternal *pInt; 
; 1025 :     DWORD cbOffset;
; 1026 :     DWORD cbWanted;
; 1027 :     DWORD cbActual;
; 1028 : 
; 1029 :     pInt = (tWMAFileStateInternal*) hstate;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hstate$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _pInt$[ebp], eax

; 1030 :     if(pInt == NULL || desc == NULL)

  0000c	83 7d f8 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00010	74 06		 je	 SHORT $L9021
  00012	83 7d 0c 00	 cmp	 DWORD PTR _desc$[ebp], 0
  00016	75 0a		 jne	 SHORT $L9020
$L9021:

; 1031 :         return cWMA_BadArgument;

  00018	b8 02 00 00 00	 mov	 eax, 2
  0001d	e9 6d 04 00 00	 jmp	 $L9012
$L9020:

; 1032 : 
; 1033 :     if(pInt->hdr_parse.cbCDOffset == 0)

  00022	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00025	83 b9 98 00 00
	00 00		 cmp	 DWORD PTR [ecx+152], 0
  0002c	75 33		 jne	 SHORT $L9022

; 1034 :     {
; 1035 :         /* no content description object in the header */
; 1036 : 
; 1037 :         desc->title_len       = 0;

  0002e	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  00031	66 c7 02 00 00	 mov	 WORD PTR [edx], 0

; 1038 :         desc->author_len      = 0;

  00036	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  00039	66 c7 40 02 00
	00		 mov	 WORD PTR [eax+2], 0

; 1039 :         desc->copyright_len   = 0;

  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _desc$[ebp]
  00042	66 c7 41 04 00
	00		 mov	 WORD PTR [ecx+4], 0

; 1040 :         desc->description_len = 0;

  00048	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  0004b	66 c7 42 06 00
	00		 mov	 WORD PTR [edx+6], 0

; 1041 :         desc->rating_len      = 0;

  00051	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  00054	66 c7 40 08 00
	00		 mov	 WORD PTR [eax+8], 0

; 1042 : 
; 1043 :         return cWMA_NoErr;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 2e 04 00 00	 jmp	 $L9012
$L9022:

; 1044 :     }
; 1045 : 
; 1046 :     /* Title */
; 1047 : 
; 1048 :     if(desc->title_len > 0)

  00061	8b 4d 0c	 mov	 ecx, DWORD PTR _desc$[ebp]
  00064	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00067	85 d2		 test	 edx, edx
  00069	0f 8e ab 00 00
	00		 jle	 $L9023

; 1049 :     {
; 1050 :         if(desc->pTitle != NULL)

  0006f	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  00072	83 78 0a 00	 cmp	 DWORD PTR [eax+10], 0
  00076	0f 84 8e 00 00
	00		 je	 $L9025

; 1051 :         {
; 1052 :             if(pInt->hdr_parse.cbCDTitle > 0)

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0007f	0f b7 91 9c 00
	00 00		 movzx	 edx, WORD PTR [ecx+156]
  00086	85 d2		 test	 edx, edx
  00088	7e 6d		 jle	 SHORT $L9026

; 1053 :             {
; 1054 :                 cbOffset = pInt->hdr_parse.cbCDOffset;

  0008a	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  0008d	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00093	89 4d fc	 mov	 DWORD PTR _cbOffset$[ebp], ecx

; 1055 :                 cbWanted = MIN(pInt->hdr_parse.cbCDTitle, desc->title_len);

  00096	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  00099	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR _desc$[ebp]
  000a3	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  000a6	3b c2		 cmp	 eax, edx
  000a8	7d 0f		 jge	 SHORT $L9360
  000aa	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  000ad	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000b4	89 4d ec	 mov	 DWORD PTR tv87[ebp], ecx
  000b7	eb 09		 jmp	 SHORT $L9361
$L9360:
  000b9	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  000bc	0f bf 02	 movsx	 eax, WORD PTR [edx]
  000bf	89 45 ec	 mov	 DWORD PTR tv87[ebp], eax
$L9361:
  000c2	8b 4d ec	 mov	 ecx, DWORD PTR tv87[ebp]
  000c5	89 4d f4	 mov	 DWORD PTR _cbWanted$[ebp], ecx

; 1056 :                 cbActual = WMA_GetBuffer(pInt, cbOffset, cbWanted, desc->pTitle);

  000c8	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  000cb	8b 42 0a	 mov	 eax, DWORD PTR [edx+10]
  000ce	50		 push	 eax
  000cf	8b 4d f4	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  000d2	51		 push	 ecx
  000d3	8b 55 fc	 mov	 edx, DWORD PTR _cbOffset$[ebp]
  000d6	52		 push	 edx
  000d7	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 _WMA_GetBuffer@16
  000e0	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1057 :                 if(cbActual != cbWanted)

  000e3	8b 4d f0	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  000e6	3b 4d f4	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  000e9	74 0a		 je	 SHORT $L9027

; 1058 :                     return cWMA_BadAsfHeader;

  000eb	b8 03 00 00 00	 mov	 eax, 3
  000f0	e9 9a 03 00 00	 jmp	 $L9012
$L9027:

; 1059 :             }
; 1060 :             else

  000f5	eb 13		 jmp	 SHORT $L9025
$L9026:

; 1061 :                 desc->pTitle[0] = desc->pTitle[1] = 0;

  000f7	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  000fa	8b 42 0a	 mov	 eax, DWORD PTR [edx+10]
  000fd	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
  00101	8b 4d 0c	 mov	 ecx, DWORD PTR _desc$[ebp]
  00104	8b 51 0a	 mov	 edx, DWORD PTR [ecx+10]
  00107	c6 02 00	 mov	 BYTE PTR [edx], 0
$L9025:

; 1062 :         }
; 1063 : 
; 1064 :         desc->title_len = pInt->hdr_parse.cbCDTitle;

  0010a	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  0010d	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00110	66 8b 91 9c 00
	00 00		 mov	 dx, WORD PTR [ecx+156]
  00117	66 89 10	 mov	 WORD PTR [eax], dx
$L9023:

; 1065 :     }
; 1066 : 
; 1067 :     /* Author */
; 1068 : 
; 1069 :     if (desc->author_len > 0)

  0011a	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  0011d	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00121	85 c9		 test	 ecx, ecx
  00123	0f 8e b8 00 00
	00		 jle	 $L9029

; 1070 :     {
; 1071 :         if (desc->pAuthor != NULL)

  00129	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  0012c	83 7a 0e 00	 cmp	 DWORD PTR [edx+14], 0
  00130	0f 84 9a 00 00
	00		 je	 $L9031

; 1072 :         {
; 1073 :             if (pInt->hdr_parse.cbCDAuthor > 0)

  00136	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00139	0f b7 88 9e 00
	00 00		 movzx	 ecx, WORD PTR [eax+158]
  00140	85 c9		 test	 ecx, ecx
  00142	7e 79		 jle	 SHORT $L9032

; 1074 :             {
; 1075 :                 cbOffset = pInt->hdr_parse.cbCDOffset
; 1076 :                          + pInt->hdr_parse.cbCDTitle;

  00144	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  00147	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  0014e	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00151	03 81 98 00 00
	00		 add	 eax, DWORD PTR [ecx+152]
  00157	89 45 fc	 mov	 DWORD PTR _cbOffset$[ebp], eax

; 1077 :                 cbWanted = MIN(pInt->hdr_parse.cbCDAuthor, desc->author_len);

  0015a	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  0015d	0f b7 82 9e 00
	00 00		 movzx	 eax, WORD PTR [edx+158]
  00164	8b 4d 0c	 mov	 ecx, DWORD PTR _desc$[ebp]
  00167	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0016b	3b c2		 cmp	 eax, edx
  0016d	7d 0f		 jge	 SHORT $L9362
  0016f	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00172	0f b7 88 9e 00
	00 00		 movzx	 ecx, WORD PTR [eax+158]
  00179	89 4d e8	 mov	 DWORD PTR tv153[ebp], ecx
  0017c	eb 0a		 jmp	 SHORT $L9363
$L9362:
  0017e	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  00181	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  00185	89 45 e8	 mov	 DWORD PTR tv153[ebp], eax
$L9363:
  00188	8b 4d e8	 mov	 ecx, DWORD PTR tv153[ebp]
  0018b	89 4d f4	 mov	 DWORD PTR _cbWanted$[ebp], ecx

; 1078 :                 cbActual = WMA_GetBuffer(pInt, cbOffset, cbWanted, desc->pAuthor);

  0018e	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  00191	8b 42 0e	 mov	 eax, DWORD PTR [edx+14]
  00194	50		 push	 eax
  00195	8b 4d f4	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00198	51		 push	 ecx
  00199	8b 55 fc	 mov	 edx, DWORD PTR _cbOffset$[ebp]
  0019c	52		 push	 edx
  0019d	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  001a0	50		 push	 eax
  001a1	e8 00 00 00 00	 call	 _WMA_GetBuffer@16
  001a6	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1079 :                 if(cbActual != cbWanted)

  001a9	8b 4d f0	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  001ac	3b 4d f4	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  001af	74 0a		 je	 SHORT $L9033

; 1080 :                     return cWMA_BadAsfHeader;

  001b1	b8 03 00 00 00	 mov	 eax, 3
  001b6	e9 d4 02 00 00	 jmp	 $L9012
$L9033:

; 1081 :             }
; 1082 :             else

  001bb	eb 13		 jmp	 SHORT $L9031
$L9032:

; 1083 :                 desc->pAuthor[0] = desc->pAuthor[1] = 0;

  001bd	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  001c0	8b 42 0e	 mov	 eax, DWORD PTR [edx+14]
  001c3	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
  001c7	8b 4d 0c	 mov	 ecx, DWORD PTR _desc$[ebp]
  001ca	8b 51 0e	 mov	 edx, DWORD PTR [ecx+14]
  001cd	c6 02 00	 mov	 BYTE PTR [edx], 0
$L9031:

; 1084 :         }
; 1085 :         desc->author_len = pInt->hdr_parse.cbCDAuthor;

  001d0	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  001d3	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  001d6	66 8b 91 9e 00
	00 00		 mov	 dx, WORD PTR [ecx+158]
  001dd	66 89 50 02	 mov	 WORD PTR [eax+2], dx
$L9029:

; 1086 :     }
; 1087 : 
; 1088 :     /* Copyright */
; 1089 : 
; 1090 :     if(desc->copyright_len > 0)

  001e1	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  001e4	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  001e8	85 c9		 test	 ecx, ecx
  001ea	0f 8e ca 00 00
	00		 jle	 $L9035

; 1091 :     {
; 1092 :         if(desc->pCopyright != NULL)

  001f0	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  001f3	83 7a 12 00	 cmp	 DWORD PTR [edx+18], 0
  001f7	0f 84 ac 00 00
	00		 je	 $L9037

; 1093 :         {
; 1094 :             if(pInt->hdr_parse.cbCDCopyright > 0)

  001fd	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00200	0f b7 88 a0 00
	00 00		 movzx	 ecx, WORD PTR [eax+160]
  00207	85 c9		 test	 ecx, ecx
  00209	0f 8e 87 00 00
	00		 jle	 $L9038

; 1095 :             {
; 1096 :                 cbOffset = pInt->hdr_parse.cbCDOffset
; 1097 :                          + pInt->hdr_parse.cbCDTitle + pInt->hdr_parse.cbCDAuthor;

  0020f	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  00212	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  00219	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0021c	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  00222	03 d0		 add	 edx, eax
  00224	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00227	0f b7 88 9e 00
	00 00		 movzx	 ecx, WORD PTR [eax+158]
  0022e	03 d1		 add	 edx, ecx
  00230	89 55 fc	 mov	 DWORD PTR _cbOffset$[ebp], edx

; 1098 :                 cbWanted = MIN(pInt->hdr_parse.cbCDCopyright, desc->copyright_len);

  00233	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  00236	0f b7 82 a0 00
	00 00		 movzx	 eax, WORD PTR [edx+160]
  0023d	8b 4d 0c	 mov	 ecx, DWORD PTR _desc$[ebp]
  00240	0f bf 51 04	 movsx	 edx, WORD PTR [ecx+4]
  00244	3b c2		 cmp	 eax, edx
  00246	7d 0f		 jge	 SHORT $L9364
  00248	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  0024b	0f b7 88 a0 00
	00 00		 movzx	 ecx, WORD PTR [eax+160]
  00252	89 4d e4	 mov	 DWORD PTR tv191[ebp], ecx
  00255	eb 0a		 jmp	 SHORT $L9365
$L9364:
  00257	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  0025a	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  0025e	89 45 e4	 mov	 DWORD PTR tv191[ebp], eax
$L9365:
  00261	8b 4d e4	 mov	 ecx, DWORD PTR tv191[ebp]
  00264	89 4d f4	 mov	 DWORD PTR _cbWanted$[ebp], ecx

; 1099 :                 cbActual = WMA_GetBuffer(pInt, cbOffset, cbWanted, desc->pCopyright);

  00267	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  0026a	8b 42 12	 mov	 eax, DWORD PTR [edx+18]
  0026d	50		 push	 eax
  0026e	8b 4d f4	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00271	51		 push	 ecx
  00272	8b 55 fc	 mov	 edx, DWORD PTR _cbOffset$[ebp]
  00275	52		 push	 edx
  00276	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00279	50		 push	 eax
  0027a	e8 00 00 00 00	 call	 _WMA_GetBuffer@16
  0027f	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1100 :                 if(cbActual != cbWanted)

  00282	8b 4d f0	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  00285	3b 4d f4	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  00288	74 0a		 je	 SHORT $L9039

; 1101 :                     return cWMA_BadAsfHeader;

  0028a	b8 03 00 00 00	 mov	 eax, 3
  0028f	e9 fb 01 00 00	 jmp	 $L9012
$L9039:

; 1102 :             }
; 1103 :             else

  00294	eb 13		 jmp	 SHORT $L9037
$L9038:

; 1104 :                 desc->pCopyright[0] = desc->pCopyright[1] = 0;

  00296	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  00299	8b 42 12	 mov	 eax, DWORD PTR [edx+18]
  0029c	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
  002a0	8b 4d 0c	 mov	 ecx, DWORD PTR _desc$[ebp]
  002a3	8b 51 12	 mov	 edx, DWORD PTR [ecx+18]
  002a6	c6 02 00	 mov	 BYTE PTR [edx], 0
$L9037:

; 1105 :         }
; 1106 :         desc->copyright_len = pInt->hdr_parse.cbCDCopyright;

  002a9	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  002ac	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  002af	66 8b 91 a0 00
	00 00		 mov	 dx, WORD PTR [ecx+160]
  002b6	66 89 50 04	 mov	 WORD PTR [eax+4], dx
$L9035:

; 1107 :     }
; 1108 : 
; 1109 :     /* Description */
; 1110 : 
; 1111 :     if(desc->description_len > 0)

  002ba	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  002bd	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  002c1	85 c9		 test	 ecx, ecx
  002c3	0f 8e d6 00 00
	00		 jle	 $L9041

; 1112 :     {
; 1113 :         if(desc->pDescription != NULL)

  002c9	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  002cc	83 7a 16 00	 cmp	 DWORD PTR [edx+22], 0
  002d0	0f 84 b8 00 00
	00		 je	 $L9043

; 1114 :         {
; 1115 :             if(pInt->hdr_parse.cbCDDescription > 0)

  002d6	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  002d9	0f b7 88 a2 00
	00 00		 movzx	 ecx, WORD PTR [eax+162]
  002e0	85 c9		 test	 ecx, ecx
  002e2	0f 8e 93 00 00
	00		 jle	 $L9044

; 1116 :             {
; 1117 :                 cbOffset = pInt->hdr_parse.cbCDOffset
; 1118 :                          + pInt->hdr_parse.cbCDTitle + pInt->hdr_parse.cbCDAuthor
; 1119 :                          + pInt->hdr_parse.cbCDCopyright;

  002e8	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  002eb	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  002f2	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  002f5	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  002fb	03 d0		 add	 edx, eax
  002fd	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00300	0f b7 88 9e 00
	00 00		 movzx	 ecx, WORD PTR [eax+158]
  00307	03 d1		 add	 edx, ecx
  00309	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  0030c	0f b7 88 a0 00
	00 00		 movzx	 ecx, WORD PTR [eax+160]
  00313	03 d1		 add	 edx, ecx
  00315	89 55 fc	 mov	 DWORD PTR _cbOffset$[ebp], edx

; 1120 : //                cbWanted = MIN(pInt->hdr_parse.cbCDCopyright, desc->copyright_len);
; 1121 :                 cbWanted = MIN(pInt->hdr_parse.cbCDDescription, desc->description_len);

  00318	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  0031b	0f b7 82 a2 00
	00 00		 movzx	 eax, WORD PTR [edx+162]
  00322	8b 4d 0c	 mov	 ecx, DWORD PTR _desc$[ebp]
  00325	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00329	3b c2		 cmp	 eax, edx
  0032b	7d 0f		 jge	 SHORT $L9366
  0032d	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00330	0f b7 88 a2 00
	00 00		 movzx	 ecx, WORD PTR [eax+162]
  00337	89 4d e0	 mov	 DWORD PTR tv232[ebp], ecx
  0033a	eb 0a		 jmp	 SHORT $L9367
$L9366:
  0033c	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  0033f	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  00343	89 45 e0	 mov	 DWORD PTR tv232[ebp], eax
$L9367:
  00346	8b 4d e0	 mov	 ecx, DWORD PTR tv232[ebp]
  00349	89 4d f4	 mov	 DWORD PTR _cbWanted$[ebp], ecx

; 1122 :                 cbActual = WMA_GetBuffer(pInt, cbOffset, cbWanted, desc->pDescription);

  0034c	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  0034f	8b 42 16	 mov	 eax, DWORD PTR [edx+22]
  00352	50		 push	 eax
  00353	8b 4d f4	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00356	51		 push	 ecx
  00357	8b 55 fc	 mov	 edx, DWORD PTR _cbOffset$[ebp]
  0035a	52		 push	 edx
  0035b	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  0035e	50		 push	 eax
  0035f	e8 00 00 00 00	 call	 _WMA_GetBuffer@16
  00364	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1123 :                 if(cbActual != cbWanted)

  00367	8b 4d f0	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  0036a	3b 4d f4	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  0036d	74 0a		 je	 SHORT $L9045

; 1124 :                     return cWMA_BadAsfHeader;

  0036f	b8 03 00 00 00	 mov	 eax, 3
  00374	e9 16 01 00 00	 jmp	 $L9012
$L9045:

; 1125 :             }
; 1126 :             else

  00379	eb 13		 jmp	 SHORT $L9043
$L9044:

; 1127 :                 desc->pDescription[0] = desc->pDescription[1] = 0;

  0037b	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  0037e	8b 42 16	 mov	 eax, DWORD PTR [edx+22]
  00381	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
  00385	8b 4d 0c	 mov	 ecx, DWORD PTR _desc$[ebp]
  00388	8b 51 16	 mov	 edx, DWORD PTR [ecx+22]
  0038b	c6 02 00	 mov	 BYTE PTR [edx], 0
$L9043:

; 1128 :         }
; 1129 :         desc->description_len = pInt->hdr_parse.cbCDDescription;

  0038e	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  00391	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00394	66 8b 91 a2 00
	00 00		 mov	 dx, WORD PTR [ecx+162]
  0039b	66 89 50 06	 mov	 WORD PTR [eax+6], dx
$L9041:

; 1130 :     }
; 1131 : 
; 1132 :     /* Rating */
; 1133 : 
; 1134 :     if(desc->rating_len > 0)

  0039f	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  003a2	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  003a6	85 c9		 test	 ecx, ecx
  003a8	0f 8e df 00 00
	00		 jle	 $L9047

; 1135 :     {
; 1136 :         if(desc->pRating != NULL)

  003ae	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  003b1	83 7a 1a 00	 cmp	 DWORD PTR [edx+26], 0
  003b5	0f 84 c1 00 00
	00		 je	 $L9049

; 1137 :         {
; 1138 :             if(pInt->hdr_parse.cbCDRating > 0)

  003bb	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  003be	0f b7 88 a4 00
	00 00		 movzx	 ecx, WORD PTR [eax+164]
  003c5	85 c9		 test	 ecx, ecx
  003c7	0f 8e 9c 00 00
	00		 jle	 $L9050

; 1139 :             {
; 1140 :                 cbOffset = pInt->hdr_parse.cbCDOffset
; 1141 :                          + pInt->hdr_parse.cbCDTitle + pInt->hdr_parse.cbCDAuthor
; 1142 :                          + pInt->hdr_parse.cbCDCopyright + pInt->hdr_parse.cbCDDescription;

  003cd	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  003d0	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  003d7	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  003da	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  003e0	03 d0		 add	 edx, eax
  003e2	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  003e5	0f b7 88 9e 00
	00 00		 movzx	 ecx, WORD PTR [eax+158]
  003ec	03 d1		 add	 edx, ecx
  003ee	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  003f1	0f b7 88 a0 00
	00 00		 movzx	 ecx, WORD PTR [eax+160]
  003f8	03 d1		 add	 edx, ecx
  003fa	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  003fd	0f b7 88 a2 00
	00 00		 movzx	 ecx, WORD PTR [eax+162]
  00404	03 d1		 add	 edx, ecx
  00406	89 55 fc	 mov	 DWORD PTR _cbOffset$[ebp], edx

; 1143 :                 cbWanted = MIN(pInt->hdr_parse.cbCDRating, desc->rating_len);

  00409	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  0040c	0f b7 82 a4 00
	00 00		 movzx	 eax, WORD PTR [edx+164]
  00413	8b 4d 0c	 mov	 ecx, DWORD PTR _desc$[ebp]
  00416	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  0041a	3b c2		 cmp	 eax, edx
  0041c	7d 0f		 jge	 SHORT $L9368
  0041e	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00421	0f b7 88 a4 00
	00 00		 movzx	 ecx, WORD PTR [eax+164]
  00428	89 4d dc	 mov	 DWORD PTR tv276[ebp], ecx
  0042b	eb 0a		 jmp	 SHORT $L9369
$L9368:
  0042d	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  00430	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  00434	89 45 dc	 mov	 DWORD PTR tv276[ebp], eax
$L9369:
  00437	8b 4d dc	 mov	 ecx, DWORD PTR tv276[ebp]
  0043a	89 4d f4	 mov	 DWORD PTR _cbWanted$[ebp], ecx

; 1144 :                 cbActual = WMA_GetBuffer(pInt, cbOffset, cbWanted, desc->pRating);

  0043d	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  00440	8b 42 1a	 mov	 eax, DWORD PTR [edx+26]
  00443	50		 push	 eax
  00444	8b 4d f4	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  00447	51		 push	 ecx
  00448	8b 55 fc	 mov	 edx, DWORD PTR _cbOffset$[ebp]
  0044b	52		 push	 edx
  0044c	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  0044f	50		 push	 eax
  00450	e8 00 00 00 00	 call	 _WMA_GetBuffer@16
  00455	89 45 f0	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1145 : 
; 1146 :                 if(cbActual != cbWanted)

  00458	8b 4d f0	 mov	 ecx, DWORD PTR _cbActual$[ebp]
  0045b	3b 4d f4	 cmp	 ecx, DWORD PTR _cbWanted$[ebp]
  0045e	74 07		 je	 SHORT $L9051

; 1147 :                     return cWMA_BadAsfHeader;

  00460	b8 03 00 00 00	 mov	 eax, 3
  00465	eb 28		 jmp	 SHORT $L9012
$L9051:

; 1148 :             }
; 1149 :             else

  00467	eb 13		 jmp	 SHORT $L9049
$L9050:

; 1150 :                 desc->pRating[0] = desc->pRating[1] = 0;

  00469	8b 55 0c	 mov	 edx, DWORD PTR _desc$[ebp]
  0046c	8b 42 1a	 mov	 eax, DWORD PTR [edx+26]
  0046f	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
  00473	8b 4d 0c	 mov	 ecx, DWORD PTR _desc$[ebp]
  00476	8b 51 1a	 mov	 edx, DWORD PTR [ecx+26]
  00479	c6 02 00	 mov	 BYTE PTR [edx], 0
$L9049:

; 1151 :         }
; 1152 :         desc->rating_len = pInt->hdr_parse.cbCDRating;

  0047c	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  0047f	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00482	66 8b 91 a4 00
	00 00		 mov	 dx, WORD PTR [ecx+164]
  00489	66 89 50 08	 mov	 WORD PTR [eax+8], dx
$L9047:

; 1153 :     }
; 1154 : 
; 1155 :     return cWMA_NoErr;

  0048d	33 c0		 xor	 eax, eax
$L9012:

; 1156 : }

  0048f	8b e5		 mov	 esp, ebp
  00491	5d		 pop	 ebp
  00492	c2 08 00	 ret	 8
_WMAFileContentDesc@8 ENDP
WMADEC	ENDS
PUBLIC	_WMAFileExtendedContentDesc@8
; Function compile flags: /Odt
;	COMDAT _WMAFileExtendedContentDesc@8
WMADEC	SEGMENT
_pInt$ = -4
_hstate$ = 8
_pECDesc$ = 12
_WMAFileExtendedContentDesc@8 PROC NEAR			; COMDAT

; 1162 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1163 :     tWMAFileStateInternal *pInt;
; 1164 : 
; 1165 :     pInt = (tWMAFileStateInternal*) hstate;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hstate$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pInt$[ebp], eax

; 1166 :     if(pInt == NULL)

  0000a	83 7d fc 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  0000e	75 07		 jne	 SHORT $L9061

; 1167 :         return cWMA_BadArgument;

  00010	b8 02 00 00 00	 mov	 eax, 2
  00015	eb 27		 jmp	 SHORT $L9057
$L9061:

; 1168 : 
; 1169 :     if(pInt->hdr_parse.m_pECDesc == NULL) {

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0001a	83 b9 a8 00 00
	00 00		 cmp	 DWORD PTR [ecx+168], 0
  00021	75 0b		 jne	 SHORT $L9063

; 1170 :         *pECDesc = NULL;

  00023	8b 55 0c	 mov	 edx, DWORD PTR _pECDesc$[ebp]
  00026	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1171 :     }
; 1172 :     else {

  0002c	eb 0e		 jmp	 SHORT $L9065
$L9063:

; 1173 :         *pECDesc = pInt->hdr_parse.m_pECDesc;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _pECDesc$[ebp]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00034	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  0003a	89 10		 mov	 DWORD PTR [eax], edx
$L9065:

; 1174 :     }
; 1175 : 
; 1176 :     return cWMA_NoErr;

  0003c	33 c0		 xor	 eax, eax
$L9057:

; 1177 : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
_WMAFileExtendedContentDesc@8 ENDP
WMADEC	ENDS
PUBLIC	_WMAGetNumberOfMarkers@4
EXTRN	_WMA_GetMarkerObject@8:NEAR
; Function compile flags: /Odt
;	COMDAT _WMAGetNumberOfMarkers@4
WMADEC	SEGMENT
_pInt$ = -4
_state$ = 8
_WMAGetNumberOfMarkers@4 PROC NEAR			; COMDAT

; 1185 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1186 :     tWMAFileHdrStateInternal *pInt = (tWMAFileHdrStateInternal *)state;

  00004	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pInt$[ebp], eax

; 1187 : 
; 1188 :     if(sizeof(tWMAFileHdrState) != sizeof(tWMAFileHdrStateInternal))

  0000a	b9 01 00 00 00	 mov	 ecx, 1
  0000f	85 c9		 test	 ecx, ecx
  00011	74 16		 je	 SHORT $L9073

; 1189 :     {
; 1190 :         /* this should NOT happen */
; 1191 :         WMADebugMessage("** Internal Error: sizeof(tWMAFileHdrStateInternal) = %d.\n\r",
; 1192 :                 sizeof(tWMAFileHdrStateInternal));

  00013	68 c4 00 00 00	 push	 196			; 000000c4H
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DM@PJPEDCFM@?$CK?$CK?5Internal?5Error?3?5sizeof?$CItWMAFi@
  0001d	e8 00 00 00 00	 call	 _WMADebugMessage
  00022	83 c4 08	 add	 esp, 8

; 1193 : 
; 1194 :         return 0;

  00025	33 c0		 xor	 eax, eax
  00027	eb 26		 jmp	 SHORT $L9068
$L9073:

; 1195 :     }
; 1196 : 
; 1197 :     if(pInt == NULL)

  00029	83 7d fc 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  0002d	75 04		 jne	 SHORT $L9076

; 1198 :     {
; 1199 :         return 0;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 1c		 jmp	 SHORT $L9068
$L9076:

; 1200 :     }
; 1201 : 
; 1202 :     if (WMAERR_OK == WMA_GetMarkerObject(pInt, -1)) // filled up pInt->m_dwMarkerNum 

  00033	6a ff		 push	 -1
  00035	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _WMA_GetMarkerObject@8
  0003e	85 c0		 test	 eax, eax
  00040	75 0b		 jne	 SHORT $L9077

; 1203 :     {
; 1204 :         return pInt->m_dwMarkerNum;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  00045	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  0004b	eb 02		 jmp	 SHORT $L9068
$L9077:

; 1205 :     } else {
; 1206 :         return 0;  

  0004d	33 c0		 xor	 eax, eax
$L9068:

; 1207 :     }
; 1208 : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
_WMAGetNumberOfMarkers@4 ENDP
WMADEC	ENDS
PUBLIC	_WMAGetMarker@12
; Function compile flags: /Odt
;	COMDAT _WMAGetMarker@12
WMADEC	SEGMENT
_pInt$ = -4
_state$ = 8
_iIndex$ = 12
_pEntry$ = 16
_WMAGetMarker@12 PROC NEAR				; COMDAT

; 1215 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1216 :     tWMAFileHdrStateInternal *pInt = (tWMAFileHdrStateInternal *)state;

  00004	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pInt$[ebp], eax

; 1217 : 
; 1218 :     if(sizeof(tWMAFileHdrState) != sizeof(tWMAFileHdrStateInternal))

  0000a	b9 01 00 00 00	 mov	 ecx, 1
  0000f	85 c9		 test	 ecx, ecx
  00011	74 1c		 je	 SHORT $L9090

; 1219 :     {
; 1220 :         /* this should NOT happen */
; 1221 :         WMADebugMessage("** Internal Error: sizeof(tWMAFileHdrStateInternal) = %d.\n\r",
; 1222 :                 sizeof(tWMAFileHdrStateInternal));

  00013	68 c4 00 00 00	 push	 196			; 000000c4H
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DM@PJPEDCFM@?$CK?$CK?5Internal?5Error?3?5sizeof?$CItWMAFi@
  0001d	e8 00 00 00 00	 call	 _WMADebugMessage
  00022	83 c4 08	 add	 esp, 8

; 1223 : 
; 1224 :         return cWMA_Failed; 

  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	e9 84 00 00 00	 jmp	 $L9085
$L9090:

; 1225 :     }
; 1226 : 
; 1227 :     if(pInt == NULL)

  0002f	83 7d fc 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00033	75 07		 jne	 SHORT $L9093

; 1228 :     {
; 1229 :        return cWMA_Failed; 

  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	eb 77		 jmp	 SHORT $L9085
$L9093:

; 1230 :     }
; 1231 :  
; 1232 :     if (WMAERR_OK != WMA_GetMarkerObject(pInt, -1)) // filled up pInt->m_dwMarkerNum

  0003c	6a ff		 push	 -1
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _pInt$[ebp]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 _WMA_GetMarkerObject@8
  00047	85 c0		 test	 eax, eax
  00049	74 07		 je	 SHORT $L9094

; 1233 :     {
; 1234 :         return cWMA_Failed;  

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	eb 61		 jmp	 SHORT $L9085
$L9094:

; 1235 :     } 
; 1236 : 
; 1237 :     if ( pInt->m_dwMarkerNum == 0 ) 

  00052	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  00055	83 b8 ac 00 00
	00 00		 cmp	 DWORD PTR [eax+172], 0
  0005c	75 07		 jne	 SHORT $L9095

; 1238 :     {
; 1239 :         return cWMA_Failed;  

  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	eb 4e		 jmp	 SHORT $L9085
$L9095:

; 1240 :     } 
; 1241 : 
; 1242 :     if ( pEntry == NULL ) 

  00065	83 7d 10 00	 cmp	 DWORD PTR _pEntry$[ebp], 0
  00069	75 07		 jne	 SHORT $L9097

; 1243 :     {
; 1244 :         return cWMA_Failed;  

  0006b	b8 01 00 00 00	 mov	 eax, 1
  00070	eb 41		 jmp	 SHORT $L9085
$L9097:

; 1245 :     } 
; 1246 : 
; 1247 :     pInt->m_pMarker = pEntry;  

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00075	8b 55 10	 mov	 edx, DWORD PTR _pEntry$[ebp]
  00078	89 91 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], edx

; 1248 : 
; 1249 :     if ( 0 <= iIndex < (int) pInt->m_dwMarkerNum )

  0007e	33 c0		 xor	 eax, eax
  00080	83 7d 0c 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00084	0f 9d c0	 setge	 al
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0008a	3b 81 ac 00 00
	00		 cmp	 eax, DWORD PTR [ecx+172]
  00090	7d 1c		 jge	 SHORT $L9099

; 1250 :     {
; 1251 :         if (WMAERR_OK == WMA_GetMarkerObject(pInt, iIndex))

  00092	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00095	52		 push	 edx
  00096	8b 45 fc	 mov	 eax, DWORD PTR _pInt$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _WMA_GetMarkerObject@8
  0009f	85 c0		 test	 eax, eax
  000a1	75 04		 jne	 SHORT $L9100

; 1252 :         {
; 1253 :             return cWMA_NoErr; 

  000a3	33 c0		 xor	 eax, eax
  000a5	eb 0c		 jmp	 SHORT $L9085
$L9100:

; 1254 :         } else {
; 1255 :             return cWMA_Failed;  

  000a7	b8 01 00 00 00	 mov	 eax, 1
  000ac	eb 05		 jmp	 SHORT $L9085
$L9099:

; 1256 :         }
; 1257 : 
; 1258 :     } else {
; 1259 : 
; 1260 :         return cWMA_Failed; 

  000ae	b8 01 00 00 00	 mov	 eax, 1
$L9085:

; 1261 :         
; 1262 :     }
; 1263 : }

  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 0c 00	 ret	 12			; 0000000cH
_WMAGetMarker@12 ENDP
WMADEC	ENDS
PUBLIC	_WMAFileLicenseInit@12
; Function compile flags: /Odt
;	COMDAT _WMAFileLicenseInit@12
WMADEC	SEGMENT
_pInt$ = -4
_hstate$ = 8
_lic_params$ = 12
_CheckLicTypes$ = 16
_WMAFileLicenseInit@12 PROC NEAR			; COMDAT

; 1270 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1271 :     tWMAFileStateInternal *pInt; 
; 1272 : #ifndef WMAAPI_NO_DRM
; 1273 :    	tWMA_U16 i;
; 1274 : #endif // WMAAPI_NO_DRM
; 1275 :     pInt = (tWMAFileStateInternal*) hstate;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hstate$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pInt$[ebp], eax

; 1276 : 
; 1277 :     if(pInt == NULL || lic_params == NULL)

  0000a	83 7d fc 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  0000e	74 06		 je	 SHORT $L9115
  00010	83 7d 0c 00	 cmp	 DWORD PTR _lic_params$[ebp], 0
  00014	75 07		 jne	 SHORT $L9114
$L9115:

; 1278 :         return cWMA_BadArgument;

  00016	b8 02 00 00 00	 mov	 eax, 2
  0001b	eb 18		 jmp	 SHORT $L9109
$L9114:

; 1279 : 
; 1280 :     if(pInt->bHasDRM)

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00020	83 b9 50 01 00
	00 00		 cmp	 DWORD PTR [ecx+336], 0
  00027	74 07		 je	 SHORT $L9116

; 1281 :     {
; 1282 : 
; 1283 : #ifdef WMAAPI_NO_DRM
; 1284 : 
; 1285 :         return cWMA_DRMUnsupported;

  00029	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  0002e	eb 05		 jmp	 SHORT $L9109
$L9116:

; 1286 : 
; 1287 : #else  /* WMAAPI_NO_DRM */
; 1288 : 
; 1289 :         HRESULT hr;
; 1290 :         PMLICENSE pmlic;
; 1291 :         DWORD dwRight;
; 1292 : 
; 1293 :         BYTE *pData;
; 1294 :         DWORD dwOffset;
; 1295 :         DWORD dwWanted;
; 1296 :         DWORD dwActual;
; 1297 : 
; 1298 :         /* set up for InitDecrypt */
; 1299 : 
; 1300 :         memset (&pmlic, 0, sizeof(pmlic));
; 1301 :         memcpy (pmlic.ld.KID, (char *)pInt->hdr_parse.pbKeyID,
; 1302 :                strlen((const char *)pInt->hdr_parse.pbKeyID) + 1);
; 1303 :         memcpy (pmlic.ld.appSec, APPSEC_1000, APPSEC_LEN);
; 1304 : 
; 1305 : 	    CheckLicTypes = CheckLicTypes & 3;
; 1306 :         for (i = 1; i < 3; i++) {
; 1307 : 		    if (CheckLicTypes & i) { 
; 1308 : 				if (i == CHECK_NONSDMI_LIC)
; 1309 : 			        dwRight = DRM_RIGHT_NONSDMI;
; 1310 : 			    else    
; 1311 : 			        dwRight = DRM_RIGHT_SDMI;
; 1312 : 
; 1313 :                 memcpy (pmlic.ld.rights, (BYTE *)&dwRight, RIGHTS_LEN);
; 1314 : 
; 1315 :                 dwOffset = 0;
; 1316 :                 dwActual = WMA_MAX_DATA_REQUESTED;
; 1317 : 
; 1318 :                 do
; 1319 :                 {
; 1320 :                     dwWanted = dwActual;
; 1321 : 
; 1322 :                     if (pInt->hdr_parse.m_dwLicenseLen) 
; 1323 :                     {
; 1324 :                         dwActual = ((dwOffset +dwWanted) > pInt->hdr_parse.m_dwLicenseLen) ? 0: dwWanted;
; 1325 :                         pData = pInt->hdr_parse.m_pLicData + dwOffset;
; 1326 :                     } else {
; 1327 :                         return cWMA_DRMFailed;    
; 1328 :                         //dwActual = WMAFileCBGetLicenseData((tWMAFileState *)pInt,
; 1329 :                         //                                   dwOffset, dwWanted, &pData);
; 1330 :                     }
; 1331 :     
; 1332 :                     if(dwActual != dwWanted)
; 1333 :                         return cWMA_DRMFailed;
; 1334 : 
; 1335 :                     hr = CDrmPD_InitDecrypt(pInt->pDRM_state,
; 1336 :                                             &pmlic,
; 1337 :                                             lic_params->pPMID,
; 1338 :                                             lic_params->cbPMID,
; 1339 :                                             pData,
; 1340 :                                             &dwOffset,
; 1341 :                                             &dwActual);
; 1342 : 
; 1343 : #ifdef LOCAL_DEBUG
; 1344 :                     SerialPrintf("++ WMAFileLicenseInit: CDrmPD_InitDecrypt returned 0x%08x: next [%u @ %u].\n\r",
; 1345 :                                  hr, dwActual, dwOffset);
; 1346 : #endif /* LOCAL_DEBUG */
; 1347 : 
; 1348 :                 } while (hr == 0x80041006 || hr == E_DRM_MORE_DATA);
; 1349 : 
; 1350 :                 if (hr == S_OK)
; 1351 :                     return cWMA_NoErr;
; 1352 :             }
; 1353 :         }
; 1354 : #endif /* WMAAPI_NO_DRM */
; 1355 :     }
; 1356 : 
; 1357 :     return cWMA_DRMFailed;

  00030	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
$L9109:

; 1358 : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 0c 00	 ret	 12			; 0000000cH
_WMAFileLicenseInit@12 ENDP
WMADEC	ENDS
PUBLIC	_WMAFileSeek@8
EXTRN	_WMARawDecReset@4:NEAR
EXTRN	_WMA_ParsePacketHeader@4:NEAR
EXTRN	_WMA_ParsePayloadHeader@4:NEAR
; Function compile flags: /Odt
;	COMDAT _WMAFileSeek@8
WMADEC	SEGMENT
_nPacket$ = -16
_wmar$ = -12
_pInt$ = -8
_msActual$ = -4
_hstate$ = 8
_msSeek$ = 12
_WMAFileSeek@8 PROC NEAR				; COMDAT

; 1365 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1366 :     tWMAFileStateInternal *pInt; 
; 1367 :     tWMA_U32 msActual;
; 1368 :     tWMA_U32 nPacket;
; 1369 :     WMARESULT wmar;
; 1370 : 
; 1371 :     pInt = (tWMAFileStateInternal*) hstate;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hstate$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _pInt$[ebp], eax

; 1372 :     if(pInt == NULL || pInt->hWMA == NULL )

  0000c	83 7d f8 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00010	74 0c		 je	 SHORT $L9130
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00015	83 b9 58 01 00
	00 00		 cmp	 DWORD PTR [ecx+344], 0
  0001c	75 0a		 jne	 SHORT $L9129
$L9130:

; 1373 :     {
; 1374 :         return cWMA_BadArgument;

  0001e	b8 02 00 00 00	 mov	 eax, 2
  00023	e9 5a 01 00 00	 jmp	 $L9121
$L9129:

; 1375 :     }
; 1376 : 
; 1377 :     /* which packet? */
; 1378 : 
; 1379 :     nPacket = 0;

  00028	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _nPacket$[ebp], 0

; 1380 :     if(pInt->hdr_parse.msDuration > 0)

  0002f	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  00032	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00036	76 39		 jbe	 SHORT $L9131

; 1381 :     {
; 1382 :         /* rounding down because I want the requested time frame to be
; 1383 :          * played */
; 1384 : 
; 1385 :         nPacket = msSeek / (pInt->hdr_parse.msDuration / pInt->hdr_parse.cPackets);

  00038	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0003e	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00041	33 d2		 xor	 edx, edx
  00043	f7 71 14	 div	 DWORD PTR [ecx+20]
  00046	8b c8		 mov	 ecx, eax
  00048	8b 45 0c	 mov	 eax, DWORD PTR _msSeek$[ebp]
  0004b	33 d2		 xor	 edx, edx
  0004d	f7 f1		 div	 ecx
  0004f	89 45 f0	 mov	 DWORD PTR _nPacket$[ebp], eax

; 1386 : 		//NQF, 061800, temp fix for the seek() bug reported by Creative 
; 1387 : 		if ((nPacket) &&( nPacket % 16 == 0 )){

  00052	83 7d f0 00	 cmp	 DWORD PTR _nPacket$[ebp], 0
  00056	74 19		 je	 SHORT $L9131
  00058	8b 45 f0	 mov	 eax, DWORD PTR _nPacket$[ebp]
  0005b	33 d2		 xor	 edx, edx
  0005d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00062	f7 f1		 div	 ecx
  00064	85 d2		 test	 edx, edx
  00066	75 09		 jne	 SHORT $L9131

; 1388 : 			nPacket++;  

  00068	8b 55 f0	 mov	 edx, DWORD PTR _nPacket$[ebp]
  0006b	83 c2 01	 add	 edx, 1
  0006e	89 55 f0	 mov	 DWORD PTR _nPacket$[ebp], edx
$L9131:

; 1389 : 		}
; 1390 :     }
; 1391 : 
; 1392 :     /* see if it's within the bounds */
; 1393 : 
; 1394 :     if(nPacket < pInt->hdr_parse.cPackets)

  00071	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00074	8b 4d f0	 mov	 ecx, DWORD PTR _nPacket$[ebp]
  00077	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  0007a	0f 83 a6 00 00
	00		 jae	 $L9133

; 1395 :     {
; 1396 :         /* parse the packet and the payload header
; 1397 :          *
; 1398 :          * a bit of a duplication from WMAF_UpdateNewPayload...
; 1399 :          */
; 1400 : 
; 1401 :         pInt->hdr_parse.currPacketOffset = pInt->hdr_parse.cbHeader
; 1402 :                                          + nPacket*pInt->hdr_parse.cbPacketSize;

  00080	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  00083	8b 45 f0	 mov	 eax, DWORD PTR _nPacket$[ebp]
  00086	0f af 42 0c	 imul	 eax, DWORD PTR [edx+12]
  0008a	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0008d	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00090	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  00093	89 02		 mov	 DWORD PTR [edx], eax

; 1403 : 
; 1404 :         if(WMA_ParsePacketHeader(pInt) != WMAERR_OK)

  00095	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _WMA_ParsePacketHeader@4
  0009e	85 c0		 test	 eax, eax
  000a0	74 0e		 je	 SHORT $L9134

; 1405 :         {
; 1406 :             msActual = pInt->hdr_parse.msDuration;

  000a2	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000a5	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000a8	89 55 fc	 mov	 DWORD PTR _msActual$[ebp], edx

; 1407 :             goto lexit;

  000ab	e9 88 00 00 00	 jmp	 $lexit$9135
$L9134:

; 1408 :         }
; 1409 : 
; 1410 :         if(pInt->ppex.fEccPresent && pInt->ppex.fParityPacket)

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  000b3	83 b8 e4 00 00
	00 00		 cmp	 DWORD PTR [eax+228], 0
  000ba	74 17		 je	 SHORT $L9136
  000bc	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000bf	83 b9 dc 00 00
	00 00		 cmp	 DWORD PTR [ecx+220], 0
  000c6	74 0b		 je	 SHORT $L9136

; 1411 :         {
; 1412 :             msActual = pInt->hdr_parse.msDuration;

  000c8	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  000cb	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000ce	89 45 fc	 mov	 DWORD PTR _msActual$[ebp], eax

; 1413 :             goto lexit;

  000d1	eb 65		 jmp	 SHORT $lexit$9135
$L9136:

; 1414 :         }
; 1415 : 
; 1416 :         pInt->iPayload = 0;

  000d3	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000d6	c7 81 48 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+328], 0

; 1417 : 
; 1418 :         if(WMA_ParsePayloadHeader(pInt) != WMAERR_OK)

  000e0	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  000e3	52		 push	 edx
  000e4	e8 00 00 00 00	 call	 _WMA_ParsePayloadHeader@4
  000e9	85 c0		 test	 eax, eax
  000eb	74 0b		 je	 SHORT $L9137

; 1419 :         {
; 1420 :             msActual = pInt->hdr_parse.msDuration;

  000ed	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  000f0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000f3	89 4d fc	 mov	 DWORD PTR _msActual$[ebp], ecx

; 1421 :             goto lexit;

  000f6	eb 40		 jmp	 SHORT $lexit$9135
$L9137:

; 1422 :         }
; 1423 : 
; 1424 :         if(pInt->payload.cbRepData == 1)

  000f8	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  000fb	0f b6 82 38 01
	00 00		 movzx	 eax, BYTE PTR [edx+312]
  00102	83 f8 01	 cmp	 eax, 1
  00105	75 0b		 jne	 SHORT $L9138

; 1425 :         {
; 1426 :             msActual = pInt->hdr_parse.msDuration;

  00107	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0010a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0010d	89 55 fc	 mov	 DWORD PTR _msActual$[ebp], edx

; 1427 :             goto lexit;

  00110	eb 26		 jmp	 SHORT $lexit$9135
$L9138:

; 1428 :         }
; 1429 : 
; 1430 :         /* whew... finally got here */
; 1431 : 
; 1432 :         msActual = pInt->payload.msObjectPres - pInt->hdr_parse.msPreroll;

  00112	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00115	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00118	8b 90 34 01 00
	00		 mov	 edx, DWORD PTR [eax+308]
  0011e	2b 51 1c	 sub	 edx, DWORD PTR [ecx+28]
  00121	89 55 fc	 mov	 DWORD PTR _msActual$[ebp], edx

; 1433 :     }
; 1434 :     else

  00124	eb 12		 jmp	 SHORT $lexit$9135
$L9133:

; 1435 :     {
; 1436 :         nPacket = pInt->hdr_parse.cPackets;

  00126	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00129	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0012c	89 4d f0	 mov	 DWORD PTR _nPacket$[ebp], ecx

; 1437 :         msActual = pInt->hdr_parse.msDuration;

  0012f	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  00132	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00135	89 45 fc	 mov	 DWORD PTR _msActual$[ebp], eax
$lexit$9135:

; 1438 :     }
; 1439 : 
; 1440 : lexit:
; 1441 : 
; 1442 :     /* reset the states */
; 1443 : 
; 1444 :     wmar = WMARawDecReset (pInt->hWMA);

  00138	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0013b	8b 91 58 01 00
	00		 mov	 edx, DWORD PTR [ecx+344]
  00141	52		 push	 edx
  00142	e8 00 00 00 00	 call	 _WMARawDecReset@4
  00147	89 45 f4	 mov	 DWORD PTR _wmar$[ebp], eax

; 1445 :     if (wmar != WMA_OK)

  0014a	8b 45 f4	 mov	 eax, DWORD PTR _wmar$[ebp]
  0014d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00153	74 07		 je	 SHORT $L9140

; 1446 :         return cWMA_Failed;

  00155	b8 01 00 00 00	 mov	 eax, 1
  0015a	eb 26		 jmp	 SHORT $L9121
$L9140:

; 1447 :     pInt->hdr_parse.nextPacketOffset = pInt->hdr_parse.cbHeader
; 1448 :                                      + nPacket*pInt->hdr_parse.cbPacketSize;

  0015c	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0015f	8b 55 f0	 mov	 edx, DWORD PTR _nPacket$[ebp]
  00162	0f af 51 0c	 imul	 edx, DWORD PTR [ecx+12]
  00166	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00169	03 50 08	 add	 edx, DWORD PTR [eax+8]
  0016c	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0016f	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1449 :     pInt->parse_state = csWMA_NewAsfPacket;

  00172	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  00175	c7 82 c8 00 00
	00 03 00 00 00	 mov	 DWORD PTR [edx+200], 3

; 1450 : 
; 1451 :     return msActual;

  0017f	8b 45 fc	 mov	 eax, DWORD PTR _msActual$[ebp]
$L9121:

; 1452 : }

  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c2 08 00	 ret	 8
_WMAFileSeek@8 ENDP
WMADEC	ENDS
PUBLIC	_WMAFileDecodeData@4
EXTRN	_WMARawDecStatus@4:NEAR
EXTRN	_WMARawDecDecodeData@4:NEAR
; Function compile flags: /Odt
;	COMDAT _WMAFileDecodeData@4
WMADEC	SEGMENT
tv68 = -16
_wmar$ = -12
_pInt$ = -8
_rc$ = -4
_hstate$ = 8
_WMAFileDecodeData@4 PROC NEAR				; COMDAT

; 1459 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1460 :     tWMAFileStateInternal *pInt;
; 1461 :     WMARESULT wmar;
; 1462 :     tWMAFileStatus rc;
; 1463 :     FUNCTION_PROFILE(fp);
; 1464 : 
; 1465 :     pInt = (tWMAFileStateInternal*) hstate;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hstate$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _pInt$[ebp], eax

; 1466 : 
; 1467 :     if(pInt == NULL || pInt->hWMA == NULL)

  0000c	83 7d f8 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00010	74 0c		 je	 SHORT $L9151
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00015	83 b9 58 01 00
	00 00		 cmp	 DWORD PTR [ecx+344], 0
  0001c	75 0a		 jne	 SHORT $L9152
$L9151:

; 1468 :         return cWMA_BadArgument;

  0001e	b8 02 00 00 00	 mov	 eax, 2
  00023	e9 92 02 00 00	 jmp	 $L9143
$L9152:

; 1469 : 
; 1470 : 	FUNCTION_PROFILE_START(&fp,WMA_FILE_DECODE_DATA_PROFILE);
; 1471 : 
; 1472 :     do
; 1473 :     {
; 1474 :         switch(pInt->parse_state)
; 1475 :         {

  00028	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  0002b	8b 82 c8 00 00
	00		 mov	 eax, DWORD PTR [edx+200]
  00031	89 45 f0	 mov	 DWORD PTR tv68[ebp], eax
  00034	83 7d f0 06	 cmp	 DWORD PTR tv68[ebp], 6
  00038	74 0f		 je	 SHORT $L9159
  0003a	83 7d f0 07	 cmp	 DWORD PTR tv68[ebp], 7
  0003e	0f 84 19 01 00
	00		 je	 $L9172
  00044	e9 4b 02 00 00	 jmp	 $L9185
$L9159:

; 1476 :         case csWMA_DecodePayloadHeader:
; 1477 : 
; 1478 : 
; 1479 : #ifdef WMAAPI_DEMO
; 1480 :             if(pInt->nSampleCount >= WMAAPI_DEMO_LIMIT*pInt->hdr_parse.nSamplesPerSec)
; 1481 :             {
; 1482 : 				FUNCTION_PROFILE_STOP(&fp);
; 1483 :                 return cWMA_DemoExpired;
; 1484 :             }
; 1485 : #endif /* WMAAPI_DEMO */
; 1486 : /*
; 1487 : 			pInt->parse_state = csWMA_DecodeLoopStart;
; 1488 : 			break;
; 1489 : */
; 1490 : 			if (pInt->bDecInWaitState == 1)

  00049	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0004c	0f b6 91 5c 01
	00 00		 movzx	 edx, BYTE PTR [ecx+348]
  00053	83 fa 01	 cmp	 edx, 1
  00056	75 12		 jne	 SHORT $L9160

; 1491 : 			{
; 1492 : 				pInt->parse_state = csWMA_DecodeLoopStart;

  00058	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  0005b	c7 80 c8 00 00
	00 07 00 00 00	 mov	 DWORD PTR [eax+200], 7

; 1493 : 				break;

  00065	e9 41 02 00 00	 jmp	 $L9153
$L9160:

; 1494 : 			}
; 1495 : 
; 1496 : 			if (pInt->bAllFramesDone ==1 || pInt->bDecInWaitState == 2 || pInt->bFirst ==0)

  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0006d	0f b6 91 5d 01
	00 00		 movzx	 edx, BYTE PTR [ecx+349]
  00074	83 fa 01	 cmp	 edx, 1
  00077	74 21		 je	 SHORT $L9162
  00079	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  0007c	0f b6 88 5c 01
	00 00		 movzx	 ecx, BYTE PTR [eax+348]
  00083	83 f9 02	 cmp	 ecx, 2
  00086	74 12		 je	 SHORT $L9162
  00088	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  0008b	0f b6 82 5e 01
	00 00		 movzx	 eax, BYTE PTR [edx+350]
  00092	85 c0		 test	 eax, eax
  00094	0f 85 b1 00 00
	00		 jne	 $L9161
$L9162:

; 1497 :             {
; 1498 : 				if (pInt->bDecInWaitState == 2)

  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0009d	0f b6 91 5c 01
	00 00		 movzx	 edx, BYTE PTR [ecx+348]
  000a4	83 fa 02	 cmp	 edx, 2
  000a7	75 0c		 jne	 SHORT $L9163

; 1499 : 					pInt->bDecInWaitState =0;

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  000ac	c6 80 5c 01 00
	00 00		 mov	 BYTE PTR [eax+348], 0

; 1500 : 				else if (pInt->bAllFramesDone == 1)

  000b3	eb 19		 jmp	 SHORT $L9164
$L9163:
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000b8	0f b6 91 5d 01
	00 00		 movzx	 edx, BYTE PTR [ecx+349]
  000bf	83 fa 01	 cmp	 edx, 1
  000c2	75 0a		 jne	 SHORT $L9164

; 1501 : 					pInt->bAllFramesDone =0;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  000c7	c6 80 5d 01 00
	00 00		 mov	 BYTE PTR [eax+349], 0
$L9164:

; 1502 : 
; 1503 : 				pInt->bFirst =1;

  000ce	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000d1	c6 81 5e 01 00
	00 01		 mov	 BYTE PTR [ecx+350], 1

; 1504 : 				
; 1505 : 
; 1506 : 				wmar = WMARawDecStatus (pInt->hWMA);

  000d8	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  000db	8b 82 58 01 00
	00		 mov	 eax, DWORD PTR [edx+344]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 _WMARawDecStatus@4
  000e7	89 45 f4	 mov	 DWORD PTR _wmar$[ebp], eax

; 1507 : 				
; 1508 : 
; 1509 : 				if (wmar == WMA_E_ONHOLD) 

  000ea	8b 4d f4	 mov	 ecx, DWORD PTR _wmar$[ebp]
  000ed	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  000f3	75 32		 jne	 SHORT $L9166

; 1510 : 				{
; 1511 : 					
; 1512 : 					if (pInt->hdr_parse.nextPacketOffset <= pInt->hdr_parse.cbLastPacketOffset)

  000f5	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  000f8	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  000fb	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000fe	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  00101	77 1a		 ja	 SHORT $L9167

; 1513 : 					{
; 1514 : 						wmar = WMA_OK;

  00103	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_OK
  00109	89 55 f4	 mov	 DWORD PTR _wmar$[ebp], edx

; 1515 : 						pInt->bDecInWaitState =2;

  0010c	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  0010f	c6 80 5c 01 00
	00 02		 mov	 BYTE PTR [eax+348], 2

; 1516 : 						return cWMA_NoErr;

  00116	33 c0		 xor	 eax, eax
  00118	e9 9d 01 00 00	 jmp	 $L9143
$L9167:

; 1517 : 					}
; 1518 : 					else
; 1519 : 						return cWMA_NoMoreFrames;

  0011d	b8 06 00 00 00	 mov	 eax, 6
  00122	e9 93 01 00 00	 jmp	 $L9143
$L9166:

; 1520 : 
; 1521 : 				}
; 1522 : 
; 1523 : 				if (wmar == WMA_E_LOSTPACKET)

  00127	8b 4d f4	 mov	 ecx, DWORD PTR _wmar$[ebp]
  0012a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_LOSTPACKET
  00130	75 09		 jne	 SHORT $L9169

; 1524 : 					wmar = WMA_OK;

  00132	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_OK
  00138	89 55 f4	 mov	 DWORD PTR _wmar$[ebp], edx
$L9169:

; 1525 : 
; 1526 : 				if (WMARAW_FAILED (wmar)) {

  0013b	83 7d f4 00	 cmp	 DWORD PTR _wmar$[ebp], 0
  0013f	7d 0a		 jge	 SHORT $L9161

; 1527 : 					FUNCTION_PROFILE_STOP (&fp);
; 1528 : 					return cWMA_Failed;

  00141	b8 01 00 00 00	 mov	 eax, 1
  00146	e9 6f 01 00 00	 jmp	 $L9143
$L9161:

; 1529 : 				}
; 1530 : 			}
; 1531 :             pInt->parse_state = csWMA_DecodeLoopStart;

  0014b	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  0014e	c7 80 c8 00 00
	00 07 00 00 00	 mov	 DWORD PTR [eax+200], 7

; 1532 :             break;

  00158	e9 4e 01 00 00	 jmp	 $L9153
$L9172:

; 1533 : 
; 1534 :         case csWMA_DecodeLoopStart:
; 1535 :             {
; 1536 : #ifdef WMAAPI_DEMO
; 1537 :                 if(pInt->nSampleCount >= WMAAPI_DEMO_LIMIT*pInt->hdr_parse.nSamplesPerSec)
; 1538 :                 {
; 1539 : 					FUNCTION_PROFILE_STOP(&fp);
; 1540 :                     return cWMA_DemoExpired;
; 1541 :                 }
; 1542 : #endif /* WMAAPI_DEMO */
; 1543 : 			if (pInt->bDecInWaitState == 1)

  0015d	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00160	0f b6 91 5c 01
	00 00		 movzx	 edx, BYTE PTR [ecx+348]
  00167	83 fa 01	 cmp	 edx, 1
  0016a	75 17		 jne	 SHORT $L9173

; 1544 : 			{
; 1545 : 				pInt->parse_state = csWMA_DecodePayloadHeader;

  0016c	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  0016f	c7 80 c8 00 00
	00 06 00 00 00	 mov	 DWORD PTR [eax+200], 6

; 1546 : 				pInt->bDecInWaitState =0;

  00179	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0017c	c6 81 5c 01 00
	00 00		 mov	 BYTE PTR [ecx+348], 0
$L9173:

; 1547 : 			}
; 1548 : 
; 1549 : 
; 1550 :                 wmar = WMARawDecDecodeData (pInt->hWMA);

  00183	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  00186	8b 82 58 01 00
	00		 mov	 eax, DWORD PTR [edx+344]
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 _WMARawDecDecodeData@4
  00192	89 45 f4	 mov	 DWORD PTR _wmar$[ebp], eax

; 1551 : 				if (wmar == 4)

  00195	83 7d f4 04	 cmp	 DWORD PTR _wmar$[ebp], 4
  00199	75 0a		 jne	 SHORT $L9174

; 1552 : 				{
; 1553 : 					pInt->bAllFramesDone = 1;

  0019b	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0019e	c6 81 5d 01 00
	00 01		 mov	 BYTE PTR [ecx+349], 1
$L9174:

; 1554 : 				}
; 1555 : 
; 1556 : 				if (wmar == WMA_E_LOSTPACKET)

  001a5	8b 55 f4	 mov	 edx, DWORD PTR _wmar$[ebp]
  001a8	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_LOSTPACKET
  001ae	75 1f		 jne	 SHORT $L9175

; 1557 : 				{
; 1558 : 					wmar = WMA_OK;

  001b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  001b5	89 45 f4	 mov	 DWORD PTR _wmar$[ebp], eax

; 1559 : 					pInt->bAllFramesDone = 1;

  001b8	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  001bb	c6 81 5d 01 00
	00 01		 mov	 BYTE PTR [ecx+349], 1

; 1560 : 					pInt->parse_state = csWMA_DecodePayloadHeader;

  001c2	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  001c5	c7 82 c8 00 00
	00 06 00 00 00	 mov	 DWORD PTR [edx+200], 6
$L9175:

; 1561 : 
; 1562 : 				}
; 1563 : 
; 1564 :                 if (wmar == WMA_E_BROKEN_FRAME) {

  001cf	8b 45 f4	 mov	 eax, DWORD PTR _wmar$[ebp]
  001d2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  001d8	75 2b		 jne	 SHORT $L9176

; 1565 : #ifdef LOCAL_DEBUG
; 1566 :                     SerialSendString("\r** WMAFileDecodeData: WMADecodeData: broken frame\n");
; 1567 : #endif /* LOCAL_DEBUG */
; 1568 :                     // reset is recommended 
; 1569 :                     // then go to the next payload 
; 1570 :                     WMARawDecReset (pInt->hWMA);

  001da	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  001dd	8b 91 58 01 00
	00		 mov	 edx, DWORD PTR [ecx+344]
  001e3	52		 push	 edx
  001e4	e8 00 00 00 00	 call	 _WMARawDecReset@4

; 1571 :                     pInt->bAllFramesDone = 1;

  001e9	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  001ec	c6 80 5d 01 00
	00 01		 mov	 BYTE PTR [eax+349], 1

; 1572 :                     pInt->parse_state = csWMA_DecodePayloadEnd;

  001f3	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  001f6	c7 81 c8 00 00
	00 08 00 00 00	 mov	 DWORD PTR [ecx+200], 8

; 1573 :                     break;

  00200	e9 a6 00 00 00	 jmp	 $L9153
$L9176:

; 1574 :                 }
; 1575 : 
; 1576 :                 if (wmar == WMA_E_ONHOLD) 

  00205	8b 55 f4	 mov	 edx, DWORD PTR _wmar$[ebp]
  00208	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  0020e	75 2e		 jne	 SHORT $L9177

; 1577 : 				{
; 1578 : 					if (pInt->hdr_parse.nextPacketOffset <= pInt->hdr_parse.cbLastPacketOffset)

  00210	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00213	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00216	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00219	3b 51 24	 cmp	 edx, DWORD PTR [ecx+36]
  0021c	77 19		 ja	 SHORT $L9178

; 1579 : 					{
; 1580 : 						wmar = WMA_OK;

  0021e	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  00223	89 45 f4	 mov	 DWORD PTR _wmar$[ebp], eax

; 1581 : 						pInt->bDecInWaitState =1;

  00226	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00229	c6 81 5c 01 00
	00 01		 mov	 BYTE PTR [ecx+348], 1

; 1582 : 						return cWMA_NoErr;

  00230	33 c0		 xor	 eax, eax
  00232	e9 83 00 00 00	 jmp	 $L9143
$L9178:

; 1583 : 					}
; 1584 : 					else
; 1585 : 						return cWMA_NoMoreFrames;

  00237	b8 06 00 00 00	 mov	 eax, 6
  0023c	eb 7c		 jmp	 SHORT $L9143
$L9177:

; 1586 : 				}
; 1587 : 
; 1588 :                 if (wmar != WMA_OK) {

  0023e	8b 55 f4	 mov	 edx, DWORD PTR _wmar$[ebp]
  00241	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  00247	74 47		 je	 SHORT $L9180

; 1589 :                     if (wmar == WMA_S_NO_MORE_SRCDATA) {

  00249	8b 45 f4	 mov	 eax, DWORD PTR _wmar$[ebp]
  0024c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_S_NO_MORE_SRCDATA
  00252	75 07		 jne	 SHORT $L9181

; 1590 : #ifdef LOCAL_DEBUG
; 1591 :                         SerialSendString("\r** WMAFileDecodeData: WMADecodeData: no more data\n");
; 1592 : #endif /* LOCAL_DEBUG */
; 1593 : 						FUNCTION_PROFILE_STOP(&fp);
; 1594 :                         return cWMA_NoMoreFrames;

  00254	b8 06 00 00 00	 mov	 eax, 6
  00259	eb 5f		 jmp	 SHORT $L9143
$L9181:

; 1595 :                     }
; 1596 :                     
; 1597 : 					if (WMA_E_LOSTPACKET == wmar)

  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_LOSTPACKET
  00261	3b 4d f4	 cmp	 ecx, DWORD PTR _wmar$[ebp]
  00264	75 04		 jne	 SHORT $L9182

; 1598 : 						return cWMA_NoErr;

  00266	33 c0		 xor	 eax, eax
  00268	eb 50		 jmp	 SHORT $L9143
$L9182:

; 1599 : 					
; 1600 : 					if (WMARAW_FAILED (wmar)) // Wei-ge recommends resetting after any error

  0026a	83 7d f4 00	 cmp	 DWORD PTR _wmar$[ebp], 0
  0026e	7d 0f		 jge	 SHORT $L9184

; 1601 :                         WMARawDecReset (pInt->hWMA);

  00270	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  00273	8b 82 58 01 00
	00		 mov	 eax, DWORD PTR [edx+344]
  00279	50		 push	 eax
  0027a	e8 00 00 00 00	 call	 _WMARawDecReset@4
$L9184:

; 1602 :                     pInt->parse_state = csWMA_DecodePayloadHeader;

  0027f	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00282	c7 81 c8 00 00
	00 06 00 00 00	 mov	 DWORD PTR [ecx+200], 6

; 1603 : 					FUNCTION_PROFILE_STOP(&fp);
; 1604 : 					return cWMA_NoErr;

  0028c	33 c0		 xor	 eax, eax
  0028e	eb 2a		 jmp	 SHORT $L9143
$L9180:

; 1605 :                 }
; 1606 :             }
; 1607 : 
; 1608 :             /* WMAGetPCM will be done separately in WMAFileGetPCM */
; 1609 : 			FUNCTION_PROFILE_STOP(&fp);
; 1610 :             return cWMA_NoErr;

  00290	33 c0		 xor	 eax, eax
  00292	eb 26		 jmp	 SHORT $L9143
$L9185:

; 1611 : 
; 1612 :         default:
; 1613 :             /* All other state operation is done in this function
; 1614 :              *   so that it can be done somewhere else as well
; 1615 :              */
; 1616 : 
; 1617 :             {
; 1618 :                 rc = WMAF_UpdateNewPayload(pInt);

  00294	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  00297	52		 push	 edx
  00298	e8 00 00 00 00	 call	 _WMAF_UpdateNewPayload@4
  0029d	89 45 fc	 mov	 DWORD PTR _rc$[ebp], eax

; 1619 :                 if(rc != cWMA_NoErr)

  002a0	83 7d fc 00	 cmp	 DWORD PTR _rc$[ebp], 0
  002a4	74 05		 je	 SHORT $L9153

; 1620 :                 {
; 1621 : #ifdef LOCAL_DEBUG
; 1622 :                     SerialSendString("\r** WMAFileDecodeData: WMA_UpdateNewPlayload failed\n");
; 1623 : #endif /* LOCAL_DEBUG */
; 1624 : 					FUNCTION_PROFILE_STOP(&fp);
; 1625 :                     return rc;

  002a6	8b 45 fc	 mov	 eax, DWORD PTR _rc$[ebp]
  002a9	eb 0f		 jmp	 SHORT $L9143
$L9153:

; 1626 :                 }
; 1627 :             }
; 1628 :             break;
; 1629 :         }
; 1630 : 
; 1631 :     } while(1);

  002ab	b8 01 00 00 00	 mov	 eax, 1
  002b0	85 c0		 test	 eax, eax
  002b2	0f 85 70 fd ff
	ff		 jne	 $L9152

; 1632 : 
; 1633 : 	FUNCTION_PROFILE_STOP(&fp);
; 1634 :     return cWMA_NoErr;

  002b8	33 c0		 xor	 eax, eax
$L9143:

; 1635 : }

  002ba	8b e5		 mov	 esp, ebp
  002bc	5d		 pop	 ebp
  002bd	c2 04 00	 ret	 4
_WMAFileDecodeData@4 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _WMAF_UpdateNewPayload@4
WMADEC	SEGMENT
tv65 = -8
_wmarc$ = -4
_pInt$ = 8
_WMAF_UpdateNewPayload@4 PROC NEAR			; COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
$L8863:

; 95   :     /* internal call, so pInt should be okay */
; 96   : 
; 97   :     /* HongCho: separated out these parts from the parsing loop, because
; 98   :      *          other parts (when a new payload is about to be retrieved)
; 99   :      *          need to update the offsets and other states.
; 100  :      *
; 101  :      *          used in WMAFileDecodeData() and WMARawDecCBGetData ().
; 102  :      */
; 103  : 
; 104  :     WMAERR wmarc;
; 105  : #ifndef WMAAPI_NO_DRM
; 106  :     tWMA_U32 cbRead;
; 107  :     HRESULT hr;
; 108  :     BYTE *pLast15;
; 109  : #endif
; 110  : #ifndef WMAAPI_NO_DRM_STREAM
; 111  :     tWMA_U32 cbLeftover;
; 112  :     BYTE *pbDRMPayload;
; 113  :     WORD wDRMOffset;
; 114  : #endif
; 115  : 
; 116  :     do
; 117  :     {
; 118  :         switch (pInt->parse_state)
; 119  :         {

  00006	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00009	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0000f	89 4d f8	 mov	 DWORD PTR tv65[ebp], ecx
  00012	8b 55 f8	 mov	 edx, DWORD PTR tv65[ebp]
  00015	83 ea 03	 sub	 edx, 3
  00018	89 55 f8	 mov	 DWORD PTR tv65[ebp], edx
  0001b	83 7d f8 06	 cmp	 DWORD PTR tv65[ebp], 6
  0001f	0f 87 10 03 00
	00		 ja	 $L8889
  00025	8b 45 f8	 mov	 eax, DWORD PTR tv65[ebp]
  00028	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L9391[eax*4]
$L8870:

; 120  :         case csWMA_NewAsfPacket:
; 121  : 
; 122  : #ifdef WMAAPI_DEMO
; 123  :             if (pInt->nSampleCount >= WMAAPI_DEMO_LIMIT*pInt->hdr_parse.nSamplesPerSec)
; 124  :             {
; 125  :                 return cWMA_DemoExpired;
; 126  :             }
; 127  : #endif /* WMAAPI_DEMO */
; 128  : 
; 129  :             if (pInt->hdr_parse.nextPacketOffset > pInt->hdr_parse.cbLastPacketOffset)

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00032	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00035	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00038	3b 42 24	 cmp	 eax, DWORD PTR [edx+36]
  0003b	76 0a		 jbe	 SHORT $L8871

; 130  :             {
; 131  :                 return cWMA_NoMoreFrames;

  0003d	b8 06 00 00 00	 mov	 eax, 6
  00042	e9 04 03 00 00	 jmp	 $L8861
$L8871:

; 132  :             }
; 133  : 
; 134  :             pInt->hdr_parse.currPacketOffset = pInt->hdr_parse.nextPacketOffset;

  00047	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0004a	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0004d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00050	89 01		 mov	 DWORD PTR [ecx], eax

; 135  :             pInt->hdr_parse.nextPacketOffset += pInt->hdr_parse.cbPacketSize;

  00052	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00055	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00058	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0005b	03 50 0c	 add	 edx, DWORD PTR [eax+12]
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00061	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 136  : 
; 137  :             wmarc = WMA_ParsePacketHeader (pInt);

  00064	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 _WMA_ParsePacketHeader@4
  0006d	89 45 fc	 mov	 DWORD PTR _wmarc$[ebp], eax

; 138  : 
; 139  : 			if (wmarc == WMAERR_BUFFERTOOSMALL)

  00070	83 7d fc 03	 cmp	 DWORD PTR _wmarc$[ebp], 3
  00074	75 15		 jne	 SHORT $L8872

; 140  : 			{
; 141  : 				pInt->hdr_parse.nextPacketOffset = pInt->hdr_parse.currPacketOffset;

  00076	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00079	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0007c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007e	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 142  : 			//	pInt->hdr_parse.currPacketOffset -= pInt->hdr_parse.cbPacketSize;
; 143  : 				return cWMA_NoMoreDataThisTime;

  00081	b8 12 00 00 00	 mov	 eax, 18			; 00000012H
  00086	e9 c0 02 00 00	 jmp	 $L8861
$L8872:

; 144  : 			}
; 145  : 
; 146  : 
; 147  :             if(wmarc != WMAERR_OK)

  0008b	83 7d fc 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  0008f	74 0a		 je	 SHORT $L8873

; 148  :             {
; 149  :                 return cWMA_BadPacketHeader;

  00091	b8 04 00 00 00	 mov	 eax, 4
  00096	e9 b0 02 00 00	 jmp	 $L8861
$L8873:

; 150  :             }
; 151  : 
; 152  :             if (pInt->ppex.fEccPresent && pInt->ppex.fParityPacket)

  0009b	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0009e	83 b8 e4 00 00
	00 00		 cmp	 DWORD PTR [eax+228], 0
  000a5	74 11		 je	 SHORT $L8874
  000a7	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000aa	83 b9 dc 00 00
	00 00		 cmp	 DWORD PTR [ecx+220], 0
  000b1	74 05		 je	 SHORT $L8874

; 153  :             {
; 154  :                 /* HongCho: for some reason, ARM's code thinks a parity packet is
; 155  :                  *          only at the end...  Here, I am not assuming that.
; 156  :                  */
; 157  :                 break;

  000b3	e9 84 02 00 00	 jmp	 $L8864
$L8874:

; 158  :             }
; 159  : 
; 160  :             pInt->parse_state = csWMA_DecodePayloadStart;

  000b8	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  000bb	c7 82 c8 00 00
	00 04 00 00 00	 mov	 DWORD PTR [edx+200], 4

; 161  :             pInt->iPayload = 0;

  000c5	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  000c8	c7 80 48 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+328], 0

; 162  :             break;

  000d2	e9 65 02 00 00	 jmp	 $L8864
$L8875:

; 163  : 
; 164  :         case csWMA_DecodePayloadStart:
; 165  : 
; 166  :             if (pInt->iPayload >= pInt->ppex.cPayloads)

  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000da	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  000dd	8b 81 48 01 00
	00		 mov	 eax, DWORD PTR [ecx+328]
  000e3	3b 82 20 01 00
	00		 cmp	 eax, DWORD PTR [edx+288]
  000e9	72 12		 jb	 SHORT $L8876

; 167  :             {
; 168  :                 pInt->parse_state = csWMA_NewAsfPacket;

  000eb	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000ee	c7 81 c8 00 00
	00 03 00 00 00	 mov	 DWORD PTR [ecx+200], 3

; 169  :                 break;

  000f8	e9 3f 02 00 00	 jmp	 $L8864
$L8876:

; 170  :             }
; 171  : 
; 172  :             wmarc = WMA_ParsePayloadHeader(pInt);

  000fd	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00100	52		 push	 edx
  00101	e8 00 00 00 00	 call	 _WMA_ParsePayloadHeader@4
  00106	89 45 fc	 mov	 DWORD PTR _wmarc$[ebp], eax

; 173  :             if(wmarc != WMAERR_OK)

  00109	83 7d fc 00	 cmp	 DWORD PTR _wmarc$[ebp], 0
  0010d	74 12		 je	 SHORT $L8877

; 174  :             {
; 175  :                 pInt->parse_state = csWMA_DecodePayloadEnd;

  0010f	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00112	c7 80 c8 00 00
	00 08 00 00 00	 mov	 DWORD PTR [eax+200], 8

; 176  :                 break;

  0011c	e9 1b 02 00 00	 jmp	 $L8864
$L8877:

; 177  :             }
; 178  : 
; 179  :             pInt->wPayStart = pInt->payload.cbPacketOffset + pInt->payload.cbTotalSize
; 180  :                             - pInt->payload.cbPayloadSize;

  00121	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00124	0f b7 91 24 01
	00 00		 movzx	 edx, WORD PTR [ecx+292]
  0012b	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0012e	0f b7 88 26 01
	00 00		 movzx	 ecx, WORD PTR [eax+294]
  00135	03 d1		 add	 edx, ecx
  00137	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0013a	0f b7 88 3a 01
	00 00		 movzx	 ecx, WORD PTR [eax+314]
  00141	2b d1		 sub	 edx, ecx
  00143	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00146	66 89 90 4c 01
	00 00		 mov	 WORD PTR [eax+332], dx

; 181  : 
; 182  : #ifndef WMAAPI_NO_DRM_STREAM
; 183  :             if( pInt->payload.bStreamId == pInt->hdr_parse.bDRMAuxStreamNum )
; 184  :             {
; 185  :                 /* Read this payload's data (should be 7-15 bytes) */
; 186  :                 cbRead = WMAFileCBGetData(
; 187  :                                     (tHWMAFileState *) pInt,
; 188  :                                     ((tHWMAFileState *)pInt)->pCallbackContext,                                    
; 189  :                                     pInt->hdr_parse.currPacketOffset + pInt->wPayStart,
; 190  :                                     pInt->payload.cbPayloadSize,
; 191  :                                     &pbDRMPayload );
; 192  :                 
; 193  :                 if (cbRead != pInt->payload.cbPayloadSize)
; 194  :                     return (cWMA_NoMoreFrames);
; 195  : 
; 196  :                 if (cbRead > sizeof (pInt->rgbNextPayloadEnd))
; 197  :                     cbRead = sizeof (pInt->rgbNextPayloadEnd);
; 198  : 
; 199  :                 cbLeftover = sizeof (pInt->rgbNextPayloadEnd) - cbRead;
; 200  : 
; 201  :                 /* Copy this payload's data into our internal state data */
; 202  :                 pInt->cbNextPayloadEndValid = (BYTE) cbRead - 1;
; 203  : 
; 204  :                 memset( pInt->rgbNextPayloadEnd, 0, 15 );
; 205  :                 memcpy( pInt->rgbNextPayloadEnd + 7, pbDRMPayload+1, cbRead-1 );
; 206  : 
; 207  :                 /* Move on to the next payload, which should be the corresponding audio data */
; 208  :                 pInt->parse_state = csWMA_DecodePayloadEnd;
; 209  :                 break;
; 210  :             }
; 211  : #endif  /* WMAAPI_NO_DRM_STREAM */
; 212  : 
; 213  :             if( pInt->payload.cbRepData != 1 )

  0014d	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00150	0f b6 91 38 01
	00 00		 movzx	 edx, BYTE PTR [ecx+312]
  00157	83 fa 01	 cmp	 edx, 1
  0015a	74 1c		 je	 SHORT $L8878

; 214  :             {
; 215  :                 pInt->parse_state = csWMA_DecodePayload;

  0015c	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0015f	c7 80 c8 00 00
	00 05 00 00 00	 mov	 DWORD PTR [eax+200], 5

; 216  :                 pInt->payload.bIsCompressedPayload =0; // Amit to take care of compressed payloads.

  00169	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0016c	c6 81 41 01 00
	00 00		 mov	 BYTE PTR [ecx+321], 0

; 217  :                 break;

  00173	e9 c4 01 00 00	 jmp	 $L8864
$L8878:

; 218  :             }
; 219  :             else if(pInt->payload.cbRepData == 1)    // Amit to take care of compressed payloads.

  00178	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0017b	0f b6 82 38 01
	00 00		 movzx	 eax, BYTE PTR [edx+312]
  00182	83 f8 01	 cmp	 eax, 1
  00185	75 1c		 jne	 SHORT $L8879

; 220  :             {
; 221  :                 pInt->parse_state = csWMA_DecodeCompressedPayload;

  00187	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0018a	c7 81 c8 00 00
	00 09 00 00 00	 mov	 DWORD PTR [ecx+200], 9

; 222  :                 pInt->payload.bIsCompressedPayload =1;

  00194	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00197	c6 82 41 01 00
	00 01		 mov	 BYTE PTR [edx+321], 1

; 223  :                 break;

  0019e	e9 99 01 00 00	 jmp	 $L8864
$L8879:

; 224  :             }
; 225  :             /* a payload has to be a multiple of audio "packets" */
; 226  : 
; 227  :             if(pInt->payload.cbPayloadSize%pInt->hdr_parse.nBlockAlign != 0)

  001a3	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  001a6	0f b7 80 3a 01
	00 00		 movzx	 eax, WORD PTR [eax+314]
  001ad	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  001b0	33 d2		 xor	 edx, edx
  001b2	f7 71 34	 div	 DWORD PTR [ecx+52]
  001b5	85 d2		 test	 edx, edx
  001b7	74 0a		 je	 SHORT $L8881

; 228  :                 return cWMA_BrokenFrame;

  001b9	b8 05 00 00 00	 mov	 eax, 5
  001be	e9 88 01 00 00	 jmp	 $L8861
$L8881:

; 229  : 
; 230  :             pInt->parse_state = csWMA_DecodePayloadEnd;

  001c3	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  001c6	c7 82 c8 00 00
	00 08 00 00 00	 mov	 DWORD PTR [edx+200], 8

; 231  :             break;

  001d0	e9 67 01 00 00	 jmp	 $L8864
$L8882:

; 232  : 
; 233  :         case csWMA_DecodePayload:
; 234  :             if (pInt->payload.bStreamId !=pInt->hdr_parse.wAudioStreamId) // Added by Amit to skip Video Payload

  001d5	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  001d8	0f b6 88 28 01
	00 00		 movzx	 ecx, BYTE PTR [eax+296]
  001df	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  001e2	0f b7 82 bc 00
	00 00		 movzx	 eax, WORD PTR [edx+188]
  001e9	3b c8		 cmp	 ecx, eax
  001eb	74 12		 je	 SHORT $L8883

; 235  :             {
; 236  :                  pInt->parse_state = csWMA_DecodePayloadEnd;

  001ed	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  001f0	c7 81 c8 00 00
	00 08 00 00 00	 mov	 DWORD PTR [ecx+200], 8

; 237  :                 break;

  001fa	e9 3d 01 00 00	 jmp	 $L8864
$L8883:

; 238  :            
; 239  :             }
; 240  :             pInt->cbPayloadOffset = pInt->hdr_parse.currPacketOffset + pInt->wPayStart;

  001ff	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00202	0f b7 82 4c 01
	00 00		 movzx	 eax, WORD PTR [edx+332]
  00209	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0020c	03 01		 add	 eax, DWORD PTR [ecx]
  0020e	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00211	89 82 cc 00 00
	00		 mov	 DWORD PTR [edx+204], eax

; 241  :             pInt->bBlockStart     = TRUE;

  00217	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  0021a	c7 80 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+212], 1

; 242  :             pInt->cbBlockLeft     = pInt->hdr_parse.nBlockAlign;

  00224	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00227	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  0022a	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0022d	89 81 d8 00 00
	00		 mov	 DWORD PTR [ecx+216], eax

; 243  :             pInt->cbPayloadLeft   = pInt->payload.cbPayloadSize - pInt->cbBlockLeft;

  00233	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00236	0f b7 91 3a 01
	00 00		 movzx	 edx, WORD PTR [ecx+314]
  0023d	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00240	2b 90 d8 00 00
	00		 sub	 edx, DWORD PTR [eax+216]
  00246	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00249	89 91 d0 00 00
	00		 mov	 DWORD PTR [ecx+208], edx

; 244  : 
; 245  :             /* new payload, so take care of DRM */
; 246  : 
; 247  :             if(pInt->bHasDRM)

  0024f	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00252	83 ba 50 01 00
	00 00		 cmp	 DWORD PTR [edx+336], 0
  00259	74 0a		 je	 SHORT $L8884

; 248  :             {
; 249  : 
; 250  : #ifdef WMAAPI_NO_DRM
; 251  : 
; 252  :                 return cWMA_DRMUnsupported;

  0025b	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  00260	e9 e6 00 00 00	 jmp	 $L8861
$L8884:

; 253  : 
; 254  : #else  /* WMAAPI_NO_DRM */
; 255  : 
; 256  : #ifndef WMAAPI_NO_DRM_STREAM
; 257  : 
; 258  :                 if( 0 != pInt->cbNextPayloadEndValid )
; 259  :                 {
; 260  :                     /* We pre-cached the last bytes of this payload - no need to seek / read */
; 261  :                     pLast15 = pInt->rgbNextPayloadEnd;
; 262  : 
; 263  :                     /* Move the bytes to the appropriate offset */
; 264  :                     wDRMOffset = pInt->payload.cbPayloadSize % 8;
; 265  : 
; 266  :                     if( ( 0 != wDRMOffset ) && ( 8 == pInt->cbNextPayloadEndValid ) )
; 267  :                     {
; 268  :                         memmove( pLast15 + 7 - wDRMOffset, pLast15 + 7, 8 );
; 269  :                         memset( pLast15 + 15 - wDRMOffset, 0, wDRMOffset );
; 270  :                     }
; 271  :                 }
; 272  :                 else
; 273  :                 {
; 274  : 
; 275  : #endif  /* WMAAPI_NO_DRM_STREAM */
; 276  : 
; 277  :                     /* We need to seek & read the last data from the end of this payload */
; 278  :                     cbRead = WMAFileCBGetData(
; 279  :                                     (tHWMAFileState *)pInt,
; 280  :                                     ((tHWMAFileState *)pInt)->pCallbackContext,
; 281  :                                     pInt->cbPayloadOffset + pInt->payload.cbPayloadSize - 15,
; 282  :                                     15,
; 283  :                                     &pLast15 );
; 284  : 
; 285  :                     if (cbRead != 15)
; 286  :                         return (cWMA_NoMoreFrames);
; 287  : 
; 288  : #ifndef WMAAPI_NO_DRM_STREAM
; 289  :                 }
; 290  : #endif  /* WMAAPI_NO_DRM_STREAM */
; 291  : 
; 292  :                 /* Initialize DRM so it can decrypt this payload properly */
; 293  : 
; 294  :                 hr = CDrmPD_InitPacket(pInt->pDRM_state, pLast15, pInt->payload.cbPayloadSize);
; 295  :                 if(hr != S_OK)
; 296  :                 {
; 297  : #ifdef LOCAL_DEBUG
; 298  :                     SerialPrintf("++ WMA_UpdateNewPayload: CDrmPD_InitPacket failed (0x%08x).\n\r", hr);
; 299  : #endif /* LOCAL_DEBUG */
; 300  :                     return cWMA_DRMFailed;
; 301  :                 }
; 302  : 
; 303  : #ifndef WMAAPI_NO_DRM_STREAM
; 304  :                 pInt->cbNextPayloadEndValid = 0;
; 305  : #endif  /* WMAAPI_NO_DRM_STREAM */
; 306  : 
; 307  : #endif /* WMAAPI_NO_DRM */
; 308  : 
; 309  :             }
; 310  : 
; 311  :             /* Done updating */
; 312  : /*            if (pInt->bDecInWaitState == 1)
; 313  : 			{
; 314  : 				pInt->parse_state = csWMA_DecodeLoopStart;
; 315  : 				pInt->bDecInWaitState =0;
; 316  : 			
; 317  : 			}
; 318  : 			else */
; 319  : 			{
; 320  : 				pInt->parse_state = csWMA_DecodePayloadHeader;

  00265	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00268	c7 80 c8 00 00
	00 06 00 00 00	 mov	 DWORD PTR [eax+200], 6

; 321  : 			}
; 322  :             return cWMA_NoErr;

  00272	33 c0		 xor	 eax, eax
  00274	e9 d2 00 00 00	 jmp	 $L8861
$L8885:

; 323  : 
; 324  :         case csWMA_DecodePayloadEnd:
; 325  :             pInt->iPayload++;

  00279	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0027c	8b 91 48 01 00
	00		 mov	 edx, DWORD PTR [ecx+328]
  00282	83 c2 01	 add	 edx, 1
  00285	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00288	89 90 48 01 00
	00		 mov	 DWORD PTR [eax+328], edx

; 326  :             pInt->parse_state = csWMA_DecodePayloadStart;

  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00291	c7 81 c8 00 00
	00 04 00 00 00	 mov	 DWORD PTR [ecx+200], 4

; 327  :             break;

  0029b	e9 9c 00 00 00	 jmp	 $L8864
$L8886:

; 328  : 
; 329  :         case csWMA_DecodeCompressedPayload: // Added by Amit to take care of compressed payloads
; 330  :             if (pInt->payload.bStreamId !=pInt->hdr_parse.wAudioStreamId) // Added by Amit to skip Video Payload

  002a0	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  002a3	0f b6 82 28 01
	00 00		 movzx	 eax, BYTE PTR [edx+296]
  002aa	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  002ad	0f b7 91 bc 00
	00 00		 movzx	 edx, WORD PTR [ecx+188]
  002b4	3b c2		 cmp	 eax, edx
  002b6	74 0f		 je	 SHORT $L8887

; 331  :             {
; 332  :                  pInt->parse_state = csWMA_DecodePayloadEnd;

  002b8	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  002bb	c7 80 c8 00 00
	00 08 00 00 00	 mov	 DWORD PTR [eax+200], 8

; 333  :                 break;           

  002c5	eb 75		 jmp	 SHORT $L8864
$L8887:

; 334  :             }
; 335  :             pInt->cbPayloadOffset = pInt->hdr_parse.currPacketOffset + pInt->wPayStart;

  002c7	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  002ca	0f b7 91 4c 01
	00 00		 movzx	 edx, WORD PTR [ecx+332]
  002d1	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  002d4	03 10		 add	 edx, DWORD PTR [eax]
  002d6	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  002d9	89 91 cc 00 00
	00		 mov	 DWORD PTR [ecx+204], edx

; 336  :             pInt->bBlockStart     = TRUE;

  002df	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  002e2	c7 82 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+212], 1

; 337  :             pInt->cbBlockLeft     = pInt->hdr_parse.nBlockAlign;

  002ec	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  002ef	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  002f2	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  002f5	89 90 d8 00 00
	00		 mov	 DWORD PTR [eax+216], edx

; 338  :             pInt->payload.wBytesRead =0;

  002fb	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  002fe	66 c7 80 3c 01
	00 00 00 00	 mov	 WORD PTR [eax+316], 0

; 339  :             pInt->payload.bSubPayloadState = 1;

  00307	8b 4d 08	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0030a	c6 81 40 01 00
	00 01		 mov	 BYTE PTR [ecx+320], 1

; 340  : 
; 341  : /****************************************************************************************/    
; 342  :             
; 343  :             /* new payload, so take care of DRM */
; 344  : 
; 345  :             if(pInt->bHasDRM)

  00311	8b 55 08	 mov	 edx, DWORD PTR _pInt$[ebp]
  00314	83 ba 50 01 00
	00 00		 cmp	 DWORD PTR [edx+336], 0
  0031b	74 07		 je	 SHORT $L8888

; 346  :             {
; 347  : 
; 348  : #ifdef WMAAPI_NO_DRM
; 349  : 
; 350  :                 return cWMA_DRMUnsupported;

  0031d	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  00322	eb 27		 jmp	 SHORT $L8861
$L8888:

; 351  : 
; 352  : #else  /* WMAAPI_NO_DRM */
; 353  : 
; 354  : #ifndef WMAAPI_NO_DRM_STREAM
; 355  : 
; 356  :                 if( 0 != pInt->cbNextPayloadEndValid )
; 357  :                 {
; 358  :                     /* We pre-cached the last bytes of this payload - no need to seek / read */
; 359  :                     pLast15 = pInt->rgbNextPayloadEnd;
; 360  : 
; 361  :                     /* Move the bytes to the appropriate offset */
; 362  :                     wDRMOffset = pInt->payload.cbPayloadSize % 8;
; 363  : 
; 364  :                     if( ( 0 != wDRMOffset ) && ( 8 == pInt->cbNextPayloadEndValid ) )
; 365  :                     {
; 366  :                         memmove( pLast15 + 7 - wDRMOffset, pLast15 + 7, 8 );
; 367  :                         memset( pLast15 + 15 - wDRMOffset, 0, wDRMOffset );
; 368  :                     }
; 369  :                 }
; 370  :                 else
; 371  :                 {
; 372  : 
; 373  : #endif  /* WMAAPI_NO_DRM_STREAM */
; 374  : 
; 375  :                     /* We need to seek & read the last data from the end of this payload */
; 376  :                     cbRead = WMAFileCBGetData(
; 377  :                                     (tHWMAFileState *)pInt,
; 378  :                                     ((tHWMAFileState *)pInt)->pCallbackContext,
; 379  :                                     pInt->cbPayloadOffset + pInt->payload.cbPayloadSize - 15,
; 380  :                                     15,
; 381  :                                     &pLast15 );
; 382  : 
; 383  :                     if (cbRead != 15)
; 384  :                         return (cWMA_NoMoreFrames);
; 385  : 
; 386  : #ifndef WMAAPI_NO_DRM_STREAM
; 387  :                 }
; 388  : #endif  /* WMAAPI_NO_DRM_STREAM */
; 389  : 
; 390  :                 /* Initialize DRM so it can decrypt this payload properly */
; 391  : 
; 392  :                 hr = CDrmPD_InitPacket(pInt->pDRM_state, pLast15, pInt->payload.cbPayloadSize);
; 393  :                 if(hr != S_OK)
; 394  :                 {
; 395  : #ifdef LOCAL_DEBUG
; 396  :                     SerialPrintf("++ WMA_UpdateNewPayload: CDrmPD_InitPacket failed (0x%08x).\n\r", hr);
; 397  : #endif /* LOCAL_DEBUG */
; 398  :                     return cWMA_DRMFailed;
; 399  :                 }
; 400  : 
; 401  : #ifndef WMAAPI_NO_DRM_STREAM
; 402  :                 pInt->cbNextPayloadEndValid = 0;
; 403  : #endif  /* WMAAPI_NO_DRM_STREAM */
; 404  : 
; 405  : #endif /* WMAAPI_NO_DRM */
; 406  : 
; 407  :             }
; 408  : 
; 409  :         
; 410  :             
; 411  :             
; 412  :             
; 413  :             
; 414  :             
; 415  :             
; 416  :             
; 417  :             
; 418  :             
; 419  :             
; 420  :             
; 421  :             
; 422  :             
; 423  :             
; 424  : /*******************************************************************************************/            
; 425  :             pInt->parse_state = csWMA_DecodePayloadHeader;

  00324	8b 45 08	 mov	 eax, DWORD PTR _pInt$[ebp]
  00327	c7 80 c8 00 00
	00 06 00 00 00	 mov	 DWORD PTR [eax+200], 6

; 426  :             
; 427  :             return cWMA_NoErr;

  00331	33 c0		 xor	 eax, eax
  00333	eb 16		 jmp	 SHORT $L8861
$L8889:

; 428  :             break;
; 429  : 
; 430  :         default:
; 431  : #ifdef LOCAL_DEBUG
; 432  :             while(1);
; 433  : #else  /* LOCAL_DEBUG */
; 434  :             return cWMA_Internal;

  00335	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0033a	eb 0f		 jmp	 SHORT $L8861
$L8864:

; 435  : #endif /* LOCAL_DEBUG */
; 436  :         }
; 437  : 
; 438  :     } while(1);

  0033c	b9 01 00 00 00	 mov	 ecx, 1
  00341	85 c9		 test	 ecx, ecx
  00343	0f 85 bd fc ff
	ff		 jne	 $L8863

; 439  : 
; 440  :     return cWMA_NoErr;

  00349	33 c0		 xor	 eax, eax
$L8861:

; 441  : }

  0034b	8b e5		 mov	 esp, ebp
  0034d	5d		 pop	 ebp
  0034e	c2 04 00	 ret	 4
$L9391:
  00351	00 00 00 00	 DD	 $L8870
  00355	00 00 00 00	 DD	 $L8875
  00359	00 00 00 00	 DD	 $L8882
  0035d	00 00 00 00	 DD	 $L8889
  00361	00 00 00 00	 DD	 $L8889
  00365	00 00 00 00	 DD	 $L8885
  00369	00 00 00 00	 DD	 $L8886
_WMAF_UpdateNewPayload@4 ENDP
WMADEC	ENDS
PUBLIC	_WMAFileGetPCM@16
EXTRN	_WMARawDecGetPCM@16:NEAR
; Function compile flags: /Odt
;	COMDAT _WMAFileGetPCM@16
WMADEC	SEGMENT
_pi16C1$9217 = -28
_pi16C0dst$9216 = -24
_i$9214 = -20
_pi16C0src$9215 = -16
_wmar$ = -12
_pInt$ = -8
_samples_available$ = -4
_hstate$ = 8
_pi16Channel0$ = 12
_pi16Channel1$ = 16
_max_nsamples$ = 20
_WMAFileGetPCM@16 PROC NEAR				; COMDAT

; 1645 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1646 :     tWMAFileStateInternal *pInt; 
; 1647 :     WMARESULT wmar;
; 1648 :     U16_WMARawDec samples_available = (U16_WMARawDec) max_nsamples;

  00006	66 8b 45 14	 mov	 ax, WORD PTR _max_nsamples$[ebp]
  0000a	66 89 45 fc	 mov	 WORD PTR _samples_available$[ebp], ax

; 1649 : 	FUNCTION_PROFILE(fp);
; 1650 : 
; 1651 :     pInt = (tWMAFileStateInternal*) hstate;

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _hstate$[ebp]
  00011	89 4d f8	 mov	 DWORD PTR _pInt$[ebp], ecx

; 1652 : 
; 1653 :     if (pInt == NULL || pInt->hWMA == NULL || pi16Channel0 == NULL)

  00014	83 7d f8 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00018	74 12		 je	 SHORT $L9205
  0001a	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  0001d	83 ba 58 01 00
	00 00		 cmp	 DWORD PTR [edx+344], 0
  00024	74 06		 je	 SHORT $L9205
  00026	83 7d 0c 00	 cmp	 DWORD PTR _pi16Channel0$[ebp], 0
  0002a	75 07		 jne	 SHORT $L9204
$L9205:

; 1654 :         return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	e9 13 01 00 00	 jmp	 $L9195
$L9204:

; 1655 : 
; 1656 : 	FUNCTION_PROFILE_START (&fp,WMA_FILE_GET_PCM_PROFILE);
; 1657 : 
; 1658 :     if (pi16Channel1 == NULL || pi16Channel1 == pi16Channel0 + 1 || pInt->hdr_parse.nChannels <= 1 ) {

  00033	83 7d 10 00	 cmp	 DWORD PTR _pi16Channel1$[ebp], 0
  00037	74 17		 je	 SHORT $L9208
  00039	8b 45 0c	 mov	 eax, DWORD PTR _pi16Channel0$[ebp]
  0003c	83 c0 02	 add	 eax, 2
  0003f	39 45 10	 cmp	 DWORD PTR _pi16Channel1$[ebp], eax
  00042	74 0c		 je	 SHORT $L9208
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00047	0f b7 51 38	 movzx	 edx, WORD PTR [ecx+56]
  0004b	83 fa 01	 cmp	 edx, 1
  0004e	7f 2c		 jg	 SHORT $L9207
$L9208:

; 1659 : 		// caller wants interleaved data or this sound is mono
; 1660 : 	    WMARawDecGetPCM (
; 1661 :             pInt->hWMA, 
; 1662 :             (U16_WMARawDec*) &samples_available, 
; 1663 :             (U8_WMARawDec*) pi16Channel0, 
; 1664 :             (U32_WMARawDec) max_nsamples * pInt->hdr_parse.nChannels * sizeof (I16_WMARawDec)
; 1665 :         );

  00050	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00053	0f b7 48 38	 movzx	 ecx, WORD PTR [eax+56]
  00057	8b 55 14	 mov	 edx, DWORD PTR _max_nsamples$[ebp]
  0005a	0f af d1	 imul	 edx, ecx
  0005d	d1 e2		 shl	 edx, 1
  0005f	52		 push	 edx
  00060	8b 45 0c	 mov	 eax, DWORD PTR _pi16Channel0$[ebp]
  00063	50		 push	 eax
  00064	8d 4d fc	 lea	 ecx, DWORD PTR _samples_available$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  0006b	8b 82 58 01 00
	00		 mov	 eax, DWORD PTR [edx+344]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _WMARawDecGetPCM@16

; 1666 :     } 
; 1667 :     else {

  00077	e9 b0 00 00 00	 jmp	 $L9213
$L9207:

; 1668 : 		// caller wants de-interleaved stereo data
; 1669 : 		U16_WMARawDec i;
; 1670 : 		tWMA_I16 *pi16C0src = pi16Channel0;

  0007c	8b 4d 0c	 mov	 ecx, DWORD PTR _pi16Channel0$[ebp]
  0007f	89 4d f0	 mov	 DWORD PTR _pi16C0src$9215[ebp], ecx

; 1671 : 		tWMA_I16 *pi16C0dst = pi16Channel0;

  00082	8b 55 0c	 mov	 edx, DWORD PTR _pi16Channel0$[ebp]
  00085	89 55 e8	 mov	 DWORD PTR _pi16C0dst$9216[ebp], edx

; 1672 : 		tWMA_I16 *pi16C1    = pi16Channel1;

  00088	8b 45 10	 mov	 eax, DWORD PTR _pi16Channel1$[ebp]
  0008b	89 45 e4	 mov	 DWORD PTR _pi16C1$9217[ebp], eax

; 1673 : //		assert (pInt->hdr_parse.nChannels == 2);  // if it is  greather than two, this needs work...
; 1674 : 		samples_available >>= 1;  // half the stereo samples in one buffer then they will get split into both

  0008e	66 8b 4d fc	 mov	 cx, WORD PTR _samples_available$[ebp]
  00092	66 d1 e9	 shr	 cx, 1
  00095	66 89 4d fc	 mov	 WORD PTR _samples_available$[ebp], cx

; 1675 :         wmar = WMARawDecGetPCM (
; 1676 :             pInt->hWMA, 
; 1677 :             (U16_WMARawDec*) &samples_available, 
; 1678 :             (U8_WMARawDec*) pi16Channel0, 
; 1679 :             (U32_WMARawDec) max_nsamples * pInt->hdr_parse.nChannels * sizeof (I16_WMARawDec)
; 1680 :         );

  00099	8b 55 f8	 mov	 edx, DWORD PTR _pInt$[ebp]
  0009c	0f b7 42 38	 movzx	 eax, WORD PTR [edx+56]
  000a0	8b 4d 14	 mov	 ecx, DWORD PTR _max_nsamples$[ebp]
  000a3	0f af c8	 imul	 ecx, eax
  000a6	d1 e1		 shl	 ecx, 1
  000a8	51		 push	 ecx
  000a9	8b 55 0c	 mov	 edx, DWORD PTR _pi16Channel0$[ebp]
  000ac	52		 push	 edx
  000ad	8d 45 fc	 lea	 eax, DWORD PTR _samples_available$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000b4	8b 91 58 01 00
	00		 mov	 edx, DWORD PTR [ecx+344]
  000ba	52		 push	 edx
  000bb	e8 00 00 00 00	 call	 _WMARawDecGetPCM@16
  000c0	89 45 f4	 mov	 DWORD PTR _wmar$[ebp], eax

; 1681 :         if (wmar == WMA_OK) {

  000c3	8b 45 f4	 mov	 eax, DWORD PTR _wmar$[ebp]
  000c6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  000cc	75 5e		 jne	 SHORT $L9213

; 1682 : 			for (i = 0; i < samples_available; i++) {

  000ce	66 c7 45 ec 00
	00		 mov	 WORD PTR _i$9214[ebp], 0
  000d4	eb 0c		 jmp	 SHORT $L9223
$L9224:
  000d6	66 8b 4d ec	 mov	 cx, WORD PTR _i$9214[ebp]
  000da	66 83 c1 01	 add	 cx, 1
  000de	66 89 4d ec	 mov	 WORD PTR _i$9214[ebp], cx
$L9223:
  000e2	0f b7 55 ec	 movzx	 edx, WORD PTR _i$9214[ebp]
  000e6	0f b7 45 fc	 movzx	 eax, WORD PTR _samples_available$[ebp]
  000ea	3b d0		 cmp	 edx, eax
  000ec	7d 3e		 jge	 SHORT $L9213

; 1683 : 				*pi16C0dst++ = *pi16C0src++;

  000ee	8b 4d e8	 mov	 ecx, DWORD PTR _pi16C0dst$9216[ebp]
  000f1	8b 55 f0	 mov	 edx, DWORD PTR _pi16C0src$9215[ebp]
  000f4	66 8b 02	 mov	 ax, WORD PTR [edx]
  000f7	66 89 01	 mov	 WORD PTR [ecx], ax
  000fa	8b 4d e8	 mov	 ecx, DWORD PTR _pi16C0dst$9216[ebp]
  000fd	83 c1 02	 add	 ecx, 2
  00100	89 4d e8	 mov	 DWORD PTR _pi16C0dst$9216[ebp], ecx
  00103	8b 55 f0	 mov	 edx, DWORD PTR _pi16C0src$9215[ebp]
  00106	83 c2 02	 add	 edx, 2
  00109	89 55 f0	 mov	 DWORD PTR _pi16C0src$9215[ebp], edx

; 1684 : 				*pi16C1++ = *pi16C0src++;

  0010c	8b 45 e4	 mov	 eax, DWORD PTR _pi16C1$9217[ebp]
  0010f	8b 4d f0	 mov	 ecx, DWORD PTR _pi16C0src$9215[ebp]
  00112	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00115	66 89 10	 mov	 WORD PTR [eax], dx
  00118	8b 45 e4	 mov	 eax, DWORD PTR _pi16C1$9217[ebp]
  0011b	83 c0 02	 add	 eax, 2
  0011e	89 45 e4	 mov	 DWORD PTR _pi16C1$9217[ebp], eax
  00121	8b 4d f0	 mov	 ecx, DWORD PTR _pi16C0src$9215[ebp]
  00124	83 c1 02	 add	 ecx, 2
  00127	89 4d f0	 mov	 DWORD PTR _pi16C0src$9215[ebp], ecx

; 1685 : 			}

  0012a	eb aa		 jmp	 SHORT $L9224
$L9213:

; 1686 : 		}
; 1687 : 	}
; 1688 : 
; 1689 : #ifdef USE_WOW_FILTER
; 1690 :     wowFilter(&(pInt->sWowChannel), pi16Channel0, pi16Channel1, samples_available);
; 1691 : #endif //USE_WOW_FILTER
; 1692 : 
; 1693 :     pInt->nSampleCount += samples_available;

  0012c	0f b7 55 fc	 movzx	 edx, WORD PTR _samples_available$[ebp]
  00130	8b 45 f8	 mov	 eax, DWORD PTR _pInt$[ebp]
  00133	03 90 54 01 00
	00		 add	 edx, DWORD PTR [eax+340]
  00139	8b 4d f8	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0013c	89 91 54 01 00
	00		 mov	 DWORD PTR [ecx+340], edx

; 1694 : 
; 1695 : 	FUNCTION_PROFILE_STOP(&fp);
; 1696 :     return samples_available;

  00142	0f b7 45 fc	 movzx	 eax, WORD PTR _samples_available$[ebp]
$L9195:

; 1697 : }

  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c2 10 00	 ret	 16			; 00000010H
_WMAFileGetPCM@16 ENDP
WMADEC	ENDS
EXTRN	_memcpy:NEAR
EXTRN	_WMAFileCBGetData@20:NEAR
; Function compile flags: /Odt
;	COMDAT _WMARawDecCBGetData@16
WMADEC	SEGMENT
tv74 = -48
tv71 = -44
_parse_state$9306 = -40
_rc$9305 = -36
_parse_state$ = -32
_pbuff$ = -28
_num_bytes$ = -24
_cbActual$ = -20
_cbWanted$ = -16
_pInt$ = -12
_rc$ = -8
_bGlobalDataBuffer$ = -4
_ppBuffer$ = 8
_pcbBuffer$ = 12
_dwUserData$ = 16
_pBuffer$ = 20
_WMARawDecCBGetData@16 PROC NEAR			; COMDAT

; 1705 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 1706 :     tWMAFileStateInternal *pInt = (tWMAFileStateInternal *) dwUserData;

  00006	8b 45 10	 mov	 eax, DWORD PTR _dwUserData$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR _pInt$[ebp], eax

; 1707 :     tWMA_U32 num_bytes = WMA_MAX_DATA_REQUESTED;

  0000c	c7 45 e8 80 00
	00 00		 mov	 DWORD PTR _num_bytes$[ebp], 128 ; 00000080H

; 1708 :     tWMA_U32 cbActual =0;

  00013	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _cbActual$[ebp], 0

; 1709 :     tWMA_U32 cbWanted =0;

  0001a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 0

; 1710 :     BYTE *pbuff = NULL;

  00021	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pbuff$[ebp], 0

; 1711 :     tWMAFileStatus rc;
; 1712 :     tWMAParseState parse_state;
; 1713 : 
; 1714 : 	BYTE *bGlobalDataBuffer = pBuffer;

  00028	8b 4d 14	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  0002b	89 4d fc	 mov	 DWORD PTR _bGlobalDataBuffer$[ebp], ecx

; 1715 : 
; 1716 : #ifndef WMAAPI_NO_DRM
; 1717 :     HRESULT hr;
; 1718 : #endif // WMAAPI_NO_DRM
; 1719 : 
; 1720 :     if(pInt == NULL || ppBuffer == NULL || pcbBuffer == NULL)

  0002e	83 7d f4 00	 cmp	 DWORD PTR _pInt$[ebp], 0
  00032	74 0c		 je	 SHORT $L9249
  00034	83 7d 08 00	 cmp	 DWORD PTR _ppBuffer$[ebp], 0
  00038	74 06		 je	 SHORT $L9249
  0003a	83 7d 0c 00	 cmp	 DWORD PTR _pcbBuffer$[ebp], 0
  0003e	75 28		 jne	 SHORT $L9248
$L9249:

; 1721 :     {
; 1722 :         if(ppBuffer != NULL)

  00040	83 7d 08 00	 cmp	 DWORD PTR _ppBuffer$[ebp], 0
  00044	74 09		 je	 SHORT $L9251

; 1723 :         {
; 1724 :             *ppBuffer = NULL;

  00046	8b 55 08	 mov	 edx, DWORD PTR _ppBuffer$[ebp]
  00049	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L9251:

; 1725 :         }
; 1726 :         if(pcbBuffer != NULL)

  0004f	83 7d 0c 00	 cmp	 DWORD PTR _pcbBuffer$[ebp], 0
  00053	74 09		 je	 SHORT $L9254

; 1727 :         {
; 1728 :             *pcbBuffer = 0;

  00055	8b 45 0c	 mov	 eax, DWORD PTR _pcbBuffer$[ebp]
  00058	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L9254:

; 1729 :         }
; 1730 : 
; 1731 :         return WMA_E_INVALIDARG;

  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  00063	e9 37 06 00 00	 jmp	 $L9234
$L9248:

; 1732 :     }
; 1733 : 
; 1734 :     *ppBuffer = NULL;

  00068	8b 4d 08	 mov	 ecx, DWORD PTR _ppBuffer$[ebp]
  0006b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1735 :     *pcbBuffer = 0;

  00071	8b 55 0c	 mov	 edx, DWORD PTR _pcbBuffer$[ebp]
  00074	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L9256:

; 1736 : 
; 1737 :     /* If we used up the current payload, try to get the
; 1738 :      * next one.
; 1739 :      */
; 1740 :     
; 1741 :     // Added by Amit to take care of compressed payloads
; 1742 : 	do
; 1743 : 	{
; 1744 : 		switch (pInt->payload.bIsCompressedPayload)
; 1745 : 		{

  0007a	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  0007d	8a 88 41 01 00
	00		 mov	 cl, BYTE PTR [eax+321]
  00083	88 4d d4	 mov	 BYTE PTR tv71[ebp], cl
  00086	80 7d d4 01	 cmp	 BYTE PTR tv71[ebp], 1
  0008a	74 05		 je	 SHORT $L9264
  0008c	e9 54 04 00 00	 jmp	 $L9303
$L9264:

; 1746 : 
; 1747 : 
; 1748 : 		case 1:
; 1749 : 			{
; 1750 : 				do
; 1751 : 				{
; 1752 : 					switch (pInt->payload.bSubPayloadState)
; 1753 : 					{

  00091	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  00094	0f b6 82 40 01
	00 00		 movzx	 eax, BYTE PTR [edx+320]
  0009b	89 45 d0	 mov	 DWORD PTR tv74[ebp], eax
  0009e	8b 4d d0	 mov	 ecx, DWORD PTR tv74[ebp]
  000a1	83 e9 01	 sub	 ecx, 1
  000a4	89 4d d0	 mov	 DWORD PTR tv74[ebp], ecx
  000a7	83 7d d0 03	 cmp	 DWORD PTR tv74[ebp], 3
  000ab	0f 87 18 04 00
	00		 ja	 $L9302
  000b1	8b 55 d0	 mov	 edx, DWORD PTR tv74[ebp]
  000b4	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L9398[edx*4]
$L9271:

; 1754 : 					case 1: // Compressed payload just started
; 1755 : 						cbWanted = 1; //to read subpayload length

  000bb	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 1

; 1756 : 						cbActual = WMAFileCBGetData ((tHWMAFileState *)pInt, 
; 1757 :                                                      (tHWMAFileState *)pInt->pCallbackContext,
; 1758 :                                                      pInt->cbPayloadOffset, cbWanted, &pbuff);

  000c2	8d 45 e4	 lea	 eax, DWORD PTR _pbuff$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d f0	 mov	 ecx, DWORD PTR _cbWanted$[ebp]
  000c9	51		 push	 ecx
  000ca	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  000cd	8b 82 cc 00 00
	00		 mov	 eax, DWORD PTR [edx+204]
  000d3	50		 push	 eax
  000d4	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000d7	8b 91 c4 00 00
	00		 mov	 edx, DWORD PTR [ecx+196]
  000dd	52		 push	 edx
  000de	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  000e7	89 45 ec	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1759 : 
; 1760 : 						pInt->cbPayloadOffset += cbWanted;

  000ea	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  000ed	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  000f3	03 55 f0	 add	 edx, DWORD PTR _cbWanted$[ebp]
  000f6	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  000f9	89 90 cc 00 00
	00		 mov	 DWORD PTR [eax+204], edx

; 1761 : 						pInt->bBlockStart = TRUE;

  000ff	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00102	c7 81 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+212], 1

; 1762 : 						pInt->cbBlockLeft = pInt->hdr_parse.nBlockAlign;

  0010c	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  0010f	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00112	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00115	89 8a d8 00 00
	00		 mov	 DWORD PTR [edx+216], ecx

; 1763 : 
; 1764 : 						pInt->payload.bNextSubPayloadSize = pbuff[0];

  0011b	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  0011e	8b 45 e4	 mov	 eax, DWORD PTR _pbuff$[ebp]
  00121	8a 08		 mov	 cl, BYTE PTR [eax]
  00123	88 8a 42 01 00
	00		 mov	 BYTE PTR [edx+322], cl

; 1765 : 						pInt->payload.wSubpayloadLeft = pInt->payload.bNextSubPayloadSize;

  00129	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  0012c	66 0f b6 82 42
	01 00 00	 movzx	 ax, BYTE PTR [edx+322]
  00134	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00137	66 89 81 44 01
	00 00		 mov	 WORD PTR [ecx+324], ax

; 1766 : 						if (pInt->payload.wSubpayloadLeft > 0)

  0013e	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  00141	0f b7 82 44 01
	00 00		 movzx	 eax, WORD PTR [edx+324]
  00148	85 c0		 test	 eax, eax
  0014a	7e 20		 jle	 SHORT $L9274

; 1767 : 							pInt->payload.wSubpayloadLeft -= (WORD)pInt->cbBlockLeft;

  0014c	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0014f	0f b7 91 d8 00
	00 00		 movzx	 edx, WORD PTR [ecx+216]
  00156	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00159	0f b7 88 44 01
	00 00		 movzx	 ecx, WORD PTR [eax+324]
  00160	2b ca		 sub	 ecx, edx
  00162	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  00165	66 89 8a 44 01
	00 00		 mov	 WORD PTR [edx+324], cx
$L9274:

; 1768 : 
; 1769 : 						if( pInt->payload.wTotalDataBytes > pInt->payload.bNextSubPayloadSize)

  0016c	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  0016f	0f b7 88 3e 01
	00 00		 movzx	 ecx, WORD PTR [eax+318]
  00176	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  00179	0f b6 82 42 01
	00 00		 movzx	 eax, BYTE PTR [edx+322]
  00180	3b c8		 cmp	 ecx, eax
  00182	7e 19		 jle	 SHORT $L9276

; 1770 : 							pInt->payload.wBytesRead = pInt->payload.bNextSubPayloadSize+1;

  00184	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00187	0f b6 91 42 01
	00 00		 movzx	 edx, BYTE PTR [ecx+322]
  0018e	83 c2 01	 add	 edx, 1
  00191	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00194	66 89 90 3c 01
	00 00		 mov	 WORD PTR [eax+316], dx

; 1771 : 						else if ( pInt->payload.wTotalDataBytes == pInt->payload.bNextSubPayloadSize)

  0019b	eb 2d		 jmp	 SHORT $L9277
$L9276:
  0019d	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  001a0	0f b7 91 3e 01
	00 00		 movzx	 edx, WORD PTR [ecx+318]
  001a7	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  001aa	0f b6 88 42 01
	00 00		 movzx	 ecx, BYTE PTR [eax+322]
  001b1	3b d1		 cmp	 edx, ecx
  001b3	75 15		 jne	 SHORT $L9277

; 1772 : 							pInt->payload.wBytesRead = pInt->payload.bNextSubPayloadSize;

  001b5	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  001b8	66 0f b6 82 42
	01 00 00	 movzx	 ax, BYTE PTR [edx+322]
  001c0	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  001c3	66 89 81 3c 01
	00 00		 mov	 WORD PTR [ecx+316], ax
$L9277:

; 1773 : 
; 1774 : 						pInt->payload.bSubPayloadState = 2;

  001ca	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  001cd	c6 82 40 01 00
	00 02		 mov	 BYTE PTR [edx+320], 2

; 1775 : 						break;

  001d4	e9 fa 02 00 00	 jmp	 $L9265
$L9279:

; 1776 : 					case 2: // Subpayload started
; 1777 : 						if (pInt->cbBlockLeft == 0 && pInt->payload.wSubpayloadLeft == 0)

  001d9	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  001dc	83 b8 d8 00 00
	00 00		 cmp	 DWORD PTR [eax+216], 0
  001e3	75 1d		 jne	 SHORT $L9280
  001e5	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  001e8	0f b7 91 44 01
	00 00		 movzx	 edx, WORD PTR [ecx+324]
  001ef	85 d2		 test	 edx, edx
  001f1	75 0f		 jne	 SHORT $L9280

; 1778 : 						{
; 1779 : 							pInt->payload.bSubPayloadState =3;

  001f3	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  001f6	c6 80 40 01 00
	00 03		 mov	 BYTE PTR [eax+320], 3

; 1780 : 							break;

  001fd	e9 d1 02 00 00	 jmp	 $L9265
$L9280:

; 1781 : 						}
; 1782 : 						else
; 1783 : 						{
; 1784 : 							if(pInt->cbBlockLeft == 0)

  00202	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00205	83 b9 d8 00 00
	00 00		 cmp	 DWORD PTR [ecx+216], 0
  0020c	75 5f		 jne	 SHORT $L9282

; 1785 : 							{
; 1786 : 								if (/*pInt->cbPayloadLeft*/pInt->payload.wSubpayloadLeft == 0) /* done with the file */

  0020e	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  00211	0f b7 82 44 01
	00 00		 movzx	 eax, WORD PTR [edx+324]
  00218	85 c0		 test	 eax, eax
  0021a	75 0a		 jne	 SHORT $L9283

; 1787 : 									return WMA_S_NEWPACKET;

  0021c	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_S_NEWPACKET
  00221	e9 79 04 00 00	 jmp	 $L9234
$L9283:

; 1788 : 
; 1789 : 								if (pInt->payload.wSubpayloadLeft > 0)

  00226	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00229	0f b7 91 44 01
	00 00		 movzx	 edx, WORD PTR [ecx+324]
  00230	85 d2		 test	 edx, edx
  00232	7e 1d		 jle	 SHORT $L9284

; 1790 : 									pInt->payload.wSubpayloadLeft -= (WORD) pInt->hdr_parse.nBlockAlign;

  00234	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00237	0f b7 48 34	 movzx	 ecx, WORD PTR [eax+52]
  0023b	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  0023e	0f b7 82 44 01
	00 00		 movzx	 eax, WORD PTR [edx+324]
  00245	2b c1		 sub	 eax, ecx
  00247	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0024a	66 89 81 44 01
	00 00		 mov	 WORD PTR [ecx+324], ax
$L9284:

; 1791 : 								pInt->bBlockStart = TRUE;

  00251	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  00254	c7 82 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+212], 1

; 1792 : 								pInt->cbBlockLeft = pInt->hdr_parse.nBlockAlign;

  0025e	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00261	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00264	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00267	89 90 d8 00 00
	00		 mov	 DWORD PTR [eax+216], edx
$L9282:

; 1793 : 							}
; 1794 : 							if(num_bytes > pInt->cbBlockLeft)

  0026d	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00270	8b 4d e8	 mov	 ecx, DWORD PTR _num_bytes$[ebp]
  00273	3b 88 d8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+216]
  00279	76 0c		 jbe	 SHORT $L9286

; 1795 : 								num_bytes = pInt->cbBlockLeft;

  0027b	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  0027e	8b 82 d8 00 00
	00		 mov	 eax, DWORD PTR [edx+216]
  00284	89 45 e8	 mov	 DWORD PTR _num_bytes$[ebp], eax
$L9286:

; 1796 : 
; 1797 : 							*pcbBuffer = (unsigned int)WMAFileCBGetData((tHWMAFileState *)pInt,
; 1798 :                                                                         (tHWMAFileState *)pInt->pCallbackContext,
; 1799 : 																		pInt->cbPayloadOffset, num_bytes, ppBuffer);

  00287	8b 4d 08	 mov	 ecx, DWORD PTR _ppBuffer$[ebp]
  0028a	51		 push	 ecx
  0028b	8b 55 e8	 mov	 edx, DWORD PTR _num_bytes$[ebp]
  0028e	52		 push	 edx
  0028f	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00292	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  00298	51		 push	 ecx
  00299	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  0029c	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  002a2	50		 push	 eax
  002a3	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  002a6	51		 push	 ecx
  002a7	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  002ac	8b 55 0c	 mov	 edx, DWORD PTR _pcbBuffer$[ebp]
  002af	89 02		 mov	 DWORD PTR [edx], eax

; 1800 : 
; 1801 : 							memcpy(&bGlobalDataBuffer[0], *ppBuffer,*pcbBuffer);

  002b1	8b 45 0c	 mov	 eax, DWORD PTR _pcbBuffer$[ebp]
  002b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002b6	51		 push	 ecx
  002b7	8b 55 08	 mov	 edx, DWORD PTR _ppBuffer$[ebp]
  002ba	8b 02		 mov	 eax, DWORD PTR [edx]
  002bc	50		 push	 eax
  002bd	8b 4d fc	 mov	 ecx, DWORD PTR _bGlobalDataBuffer$[ebp]
  002c0	51		 push	 ecx
  002c1	e8 00 00 00 00	 call	 _memcpy
  002c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1802 : 							*ppBuffer = &bGlobalDataBuffer[0];

  002c9	8b 55 08	 mov	 edx, DWORD PTR _ppBuffer$[ebp]
  002cc	8b 45 fc	 mov	 eax, DWORD PTR _bGlobalDataBuffer$[ebp]
  002cf	89 02		 mov	 DWORD PTR [edx], eax

; 1803 : 
; 1804 : 							pInt->cbPayloadOffset+=*pcbBuffer;

  002d1	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  002d4	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  002da	8b 45 0c	 mov	 eax, DWORD PTR _pcbBuffer$[ebp]
  002dd	03 10		 add	 edx, DWORD PTR [eax]
  002df	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  002e2	89 91 cc 00 00
	00		 mov	 DWORD PTR [ecx+204], edx

; 1805 : 							//pInt->payload.wSubpayloadLeft -= *pcbBuffer;
; 1806 : 							pInt->cbBlockLeft     -= *pcbBuffer;

  002e8	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  002eb	8b 45 0c	 mov	 eax, DWORD PTR _pcbBuffer$[ebp]
  002ee	8b 8a d8 00 00
	00		 mov	 ecx, DWORD PTR [edx+216]
  002f4	2b 08		 sub	 ecx, DWORD PTR [eax]
  002f6	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  002f9	89 8a d8 00 00
	00		 mov	 DWORD PTR [edx+216], ecx

; 1807 :                 
; 1808 : 							if (pInt->bHasDRM)

  002ff	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00302	83 b8 50 01 00
	00 00		 cmp	 DWORD PTR [eax+336], 0
  00309	74 0a		 je	 SHORT $L9290

; 1809 : 							{
; 1810 : #ifdef WMAAPI_NO_DRM
; 1811 : 								return WMA_S_NEWPACKET;

  0030b	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_S_NEWPACKET
  00310	e9 8a 03 00 00	 jmp	 $L9234
$L9290:

; 1812 : #else  /* WMAAPI_NO_DRM */
; 1813 : 								hr = CDrmPD_Decrypt (pInt->pDRM_state, *ppBuffer, *pcbBuffer);
; 1814 : 								if (hr != S_OK)
; 1815 : 								{
; 1816 : #ifdef LOCAL_DEBUG
; 1817 : 									SerialPrintf("++ WMARawDecCBGetData: CDrmPD_Decrypt failed (0x%08x).\n\r", hr);
; 1818 : #endif /* LOCAL_DEBUG */
; 1819 : 									*ppBuffer = NULL;
; 1820 : 									*pcbBuffer = 0;
; 1821 : 									return WMA_S_NEWPACKET;
; 1822 : 								}
; 1823 : 
; 1824 : #endif /* WMAAPI_NO_DRM */
; 1825 : 
; 1826 : 							}
; 1827 : 
; 1828 : 							if (pInt->bBlockStart) {

  00315	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00318	83 b9 d4 00 00
	00 00		 cmp	 DWORD PTR [ecx+212], 0
  0031f	74 17		 je	 SHORT $L9291

; 1829 : 								pInt->bBlockStart = FALSE;

  00321	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  00324	c7 82 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+212], 0

; 1830 : 								return WMA_S_NEWPACKET;

  0032e	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_S_NEWPACKET
  00333	e9 67 03 00 00	 jmp	 $L9234
$L9291:

; 1831 : 							}
; 1832 : 
; 1833 : 							return WMA_OK;

  00338	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0033d	e9 5d 03 00 00	 jmp	 $L9234
$L9292:

; 1834 : 						}
; 1835 : 
; 1836 : 						break;
; 1837 : 					case 3: // Subpayload finished
; 1838 : 						if ( pInt->payload.wTotalDataBytes > pInt->payload.wBytesRead)

  00342	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00345	0f b7 88 3e 01
	00 00		 movzx	 ecx, WORD PTR [eax+318]
  0034c	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  0034f	0f b7 82 3c 01
	00 00		 movzx	 eax, WORD PTR [edx+316]
  00356	3b c8		 cmp	 ecx, eax
  00358	0f 8e df 00 00
	00		 jle	 $L9293

; 1839 : 						{ // there are payloads to decode
; 1840 : 							cbWanted = 1; //to read subpayload length

  0035e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _cbWanted$[ebp], 1

; 1841 : 							cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
; 1842 :                                                         (tHWMAFileState *)pInt->pCallbackContext,
; 1843 : 														pInt->cbPayloadOffset, cbWanted, &pbuff);

  00365	8d 4d e4	 lea	 ecx, DWORD PTR _pbuff$[ebp]
  00368	51		 push	 ecx
  00369	8b 55 f0	 mov	 edx, DWORD PTR _cbWanted$[ebp]
  0036c	52		 push	 edx
  0036d	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00370	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  00376	51		 push	 ecx
  00377	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  0037a	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00380	50		 push	 eax
  00381	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00384	51		 push	 ecx
  00385	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  0038a	89 45 ec	 mov	 DWORD PTR _cbActual$[ebp], eax

; 1844 : 
; 1845 : 							pInt->cbPayloadOffset+=cbWanted;

  0038d	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  00390	8b 82 cc 00 00
	00		 mov	 eax, DWORD PTR [edx+204]
  00396	03 45 f0	 add	 eax, DWORD PTR _cbWanted$[ebp]
  00399	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0039c	89 81 cc 00 00
	00		 mov	 DWORD PTR [ecx+204], eax

; 1846 : 							pInt->bBlockStart     = TRUE;

  003a2	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  003a5	c7 82 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+212], 1

; 1847 : 							pInt->cbBlockLeft     = pInt->hdr_parse.nBlockAlign;

  003af	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  003b2	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  003b5	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  003b8	89 90 d8 00 00
	00		 mov	 DWORD PTR [eax+216], edx

; 1848 : 
; 1849 :                     
; 1850 : 							pInt->payload.bNextSubPayloadSize = pbuff[0];

  003be	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  003c1	8b 4d e4	 mov	 ecx, DWORD PTR _pbuff$[ebp]
  003c4	8a 11		 mov	 dl, BYTE PTR [ecx]
  003c6	88 90 42 01 00
	00		 mov	 BYTE PTR [eax+322], dl

; 1851 : 							pInt->payload.wSubpayloadLeft = pInt->payload.bNextSubPayloadSize;

  003cc	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  003cf	66 0f b6 88 42
	01 00 00	 movzx	 cx, BYTE PTR [eax+322]
  003d7	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  003da	66 89 8a 44 01
	00 00		 mov	 WORD PTR [edx+324], cx

; 1852 : 							if (pInt->payload.wSubpayloadLeft > 0)

  003e1	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  003e4	0f b7 88 44 01
	00 00		 movzx	 ecx, WORD PTR [eax+324]
  003eb	85 c9		 test	 ecx, ecx
  003ed	7e 20		 jle	 SHORT $L9296

; 1853 : 								pInt->payload.wSubpayloadLeft -= (WORD)pInt->cbBlockLeft;

  003ef	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  003f2	0f b7 82 d8 00
	00 00		 movzx	 eax, WORD PTR [edx+216]
  003f9	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  003fc	0f b7 91 44 01
	00 00		 movzx	 edx, WORD PTR [ecx+324]
  00403	2b d0		 sub	 edx, eax
  00405	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00408	66 89 90 44 01
	00 00		 mov	 WORD PTR [eax+324], dx
$L9296:

; 1854 : 							pInt->payload.wBytesRead+=pInt->payload.bNextSubPayloadSize+1;

  0040f	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00412	0f b6 91 42 01
	00 00		 movzx	 edx, BYTE PTR [ecx+322]
  00419	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  0041c	0f b7 88 3c 01
	00 00		 movzx	 ecx, WORD PTR [eax+316]
  00423	8d 54 11 01	 lea	 edx, DWORD PTR [ecx+edx+1]
  00427	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  0042a	66 89 90 3c 01
	00 00		 mov	 WORD PTR [eax+316], dx

; 1855 : 							pInt->payload.bSubPayloadState =2;                

  00431	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00434	c6 81 40 01 00
	00 02		 mov	 BYTE PTR [ecx+320], 2

; 1856 : 						}
; 1857 : 						else

  0043b	eb 0a		 jmp	 SHORT $L9298
$L9293:

; 1858 : 							pInt->payload.bSubPayloadState =4; // all subpayloads finished

  0043d	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  00440	c6 82 40 01 00
	00 04		 mov	 BYTE PTR [edx+320], 4
$L9298:

; 1859 : 						break;

  00447	e9 87 00 00 00	 jmp	 $L9265
$L9299:

; 1860 : 
; 1861 : 					case 4: // All Subpayloads finished
; 1862 : 
; 1863 : 						parse_state = pInt->parse_state;

  0044c	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  0044f	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00455	89 4d e0	 mov	 DWORD PTR _parse_state$[ebp], ecx

; 1864 : 						pInt->payload.bSubPayloadState =0;

  00458	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  0045b	c6 82 40 01 00
	00 00		 mov	 BYTE PTR [edx+320], 0

; 1865 : 						pInt->cbPayloadLeft =0;

  00462	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00465	c7 80 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+208], 0

; 1866 : 						pInt->payload.bIsCompressedPayload =0;

  0046f	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00472	c6 81 41 01 00
	00 00		 mov	 BYTE PTR [ecx+321], 0

; 1867 : 
; 1868 : 						pInt->parse_state = csWMA_DecodePayloadEnd;

  00479	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  0047c	c7 82 c8 00 00
	00 08 00 00 00	 mov	 DWORD PTR [edx+200], 8

; 1869 : 						rc = WMAF_UpdateNewPayload(pInt);

  00486	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00489	50		 push	 eax
  0048a	e8 00 00 00 00	 call	 _WMAF_UpdateNewPayload@4
  0048f	89 45 f8	 mov	 DWORD PTR _rc$[ebp], eax

; 1870 : 						if (rc == cWMA_NoMoreDataThisTime)

  00492	83 7d f8 12	 cmp	 DWORD PTR _rc$[ebp], 18	; 00000012H
  00496	75 13		 jne	 SHORT $L9300

; 1871 : 						{
; 1872 : 							*pcbBuffer = 0;

  00498	8b 4d 0c	 mov	 ecx, DWORD PTR _pcbBuffer$[ebp]
  0049b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1873 : 							return WMA_OK;

  004a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  004a6	e9 f4 01 00 00	 jmp	 $L9234
$L9300:

; 1874 : 						}
; 1875 : 
; 1876 : 						pInt->parse_state = parse_state;  //restore 

  004ab	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  004ae	8b 45 e0	 mov	 eax, DWORD PTR _parse_state$[ebp]
  004b1	89 82 c8 00 00
	00		 mov	 DWORD PTR [edx+200], eax

; 1877 : 						if((rc != cWMA_NoErr)) 

  004b7	83 7d f8 00	 cmp	 DWORD PTR _rc$[ebp], 0
  004bb	74 0a		 je	 SHORT $L9301

; 1878 : 							return WMA_S_NEWPACKET;

  004bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_S_NEWPACKET
  004c2	e9 d8 01 00 00	 jmp	 $L9234
$L9301:

; 1879 : 						break;

  004c7	eb 0a		 jmp	 SHORT $L9265
$L9302:

; 1880 : 					default:
; 1881 : 						return WMA_S_NEWPACKET;

  004c9	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_S_NEWPACKET
  004ce	e9 cc 01 00 00	 jmp	 $L9234
$L9265:

; 1882 : 
; 1883 : 					}
; 1884 : 				} while(1);

  004d3	b9 01 00 00 00	 mov	 ecx, 1
  004d8	85 c9		 test	 ecx, ecx
  004da	0f 85 b1 fb ff
	ff		 jne	 $L9264

; 1885 : 
; 1886 : 				break;

  004e0	e9 a8 01 00 00	 jmp	 $L9257
$L9303:

; 1887 : 			}          
; 1888 : 		default :
; 1889 : 			{
; 1890 : 				if(pInt->cbBlockLeft == 0 && pInt->cbPayloadLeft == 0)

  004e5	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  004e8	83 ba d8 00 00
	00 00		 cmp	 DWORD PTR [edx+216], 0
  004ef	75 7a		 jne	 SHORT $L9304
  004f1	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  004f4	83 b8 d0 00 00
	00 00		 cmp	 DWORD PTR [eax+208], 0
  004fb	75 6e		 jne	 SHORT $L9304

; 1891 : 				{
; 1892 : 					tWMAFileStatus rc;
; 1893 : 					tWMAParseState parse_state;
; 1894 : 
; 1895 : 					parse_state = pInt->parse_state;

  004fd	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00500	8b 91 c8 00 00
	00		 mov	 edx, DWORD PTR [ecx+200]
  00506	89 55 d8	 mov	 DWORD PTR _parse_state$9306[ebp], edx

; 1896 : 
; 1897 : 					pInt->parse_state = csWMA_DecodePayloadEnd;

  00509	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  0050c	c7 80 c8 00 00
	00 08 00 00 00	 mov	 DWORD PTR [eax+200], 8

; 1898 : 					rc = WMAF_UpdateNewPayload(pInt);

  00516	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00519	51		 push	 ecx
  0051a	e8 00 00 00 00	 call	 _WMAF_UpdateNewPayload@4
  0051f	89 45 dc	 mov	 DWORD PTR _rc$9305[ebp], eax

; 1899 : 					if (rc == cWMA_NoMoreDataThisTime)

  00522	83 7d dc 12	 cmp	 DWORD PTR _rc$9305[ebp], 18 ; 00000012H
  00526	75 13		 jne	 SHORT $L9307

; 1900 : 					{
; 1901 : 						*pcbBuffer = 0;

  00528	8b 55 0c	 mov	 edx, DWORD PTR _pcbBuffer$[ebp]
  0052b	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1902 : 						return WMA_OK;

  00531	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  00536	e9 64 01 00 00	 jmp	 $L9234
$L9307:

; 1903 : 					}
; 1904 : 					pInt->parse_state = parse_state; /* restore */

  0053b	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  0053e	8b 4d d8	 mov	 ecx, DWORD PTR _parse_state$9306[ebp]
  00541	89 88 c8 00 00
	00		 mov	 DWORD PTR [eax+200], ecx

; 1905 : 					
; 1906 : 					if (pInt->payload.bIsCompressedPayload ==1)

  00547	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  0054a	0f b6 82 41 01
	00 00		 movzx	 eax, BYTE PTR [edx+321]
  00551	83 f8 01	 cmp	 eax, 1
  00554	75 05		 jne	 SHORT $L9308

; 1907 : 						break;

  00556	e9 32 01 00 00	 jmp	 $L9257
$L9308:

; 1908 : 					if(rc != cWMA_NoErr)

  0055b	83 7d dc 00	 cmp	 DWORD PTR _rc$9305[ebp], 0
  0055f	74 0a		 je	 SHORT $L9304

; 1909 : 						return WMA_S_NEWPACKET;

  00561	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_S_NEWPACKET
  00566	e9 34 01 00 00	 jmp	 $L9234
$L9304:

; 1910 : 				}
; 1911 : 
; 1912 : 				/* return as much as we currently have left */
; 1913 : 
; 1914 : 				if(pInt->cbBlockLeft == 0)

  0056b	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0056e	83 b9 d8 00 00
	00 00		 cmp	 DWORD PTR [ecx+216], 0
  00575	75 4a		 jne	 SHORT $L9310

; 1915 : 				{
; 1916 : 					if(pInt->cbPayloadLeft == 0)

  00577	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  0057a	83 ba d0 00 00
	00 00		 cmp	 DWORD PTR [edx+208], 0
  00581	75 0a		 jne	 SHORT $L9311

; 1917 : 					{
; 1918 : 						/* done with the file */
; 1919 : 						return WMA_S_NEWPACKET;

  00583	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_S_NEWPACKET
  00588	e9 12 01 00 00	 jmp	 $L9234
$L9311:

; 1920 : 					}
; 1921 : 
; 1922 : 					pInt->cbPayloadLeft -= pInt->hdr_parse.nBlockAlign;

  0058d	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00590	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00593	8b 90 d0 00 00
	00		 mov	 edx, DWORD PTR [eax+208]
  00599	2b 51 34	 sub	 edx, DWORD PTR [ecx+52]
  0059c	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  0059f	89 90 d0 00 00
	00		 mov	 DWORD PTR [eax+208], edx

; 1923 : 					pInt->bBlockStart = TRUE;

  005a5	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  005a8	c7 81 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+212], 1

; 1924 : 					pInt->cbBlockLeft = pInt->hdr_parse.nBlockAlign;

  005b2	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  005b5	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  005b8	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  005bb	89 8a d8 00 00
	00		 mov	 DWORD PTR [edx+216], ecx
$L9310:

; 1925 : 				}
; 1926 : 				if(num_bytes > pInt->cbBlockLeft)

  005c1	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  005c4	8b 45 e8	 mov	 eax, DWORD PTR _num_bytes$[ebp]
  005c7	3b 82 d8 00 00
	00		 cmp	 eax, DWORD PTR [edx+216]
  005cd	76 0c		 jbe	 SHORT $L9312

; 1927 : 					num_bytes = pInt->cbBlockLeft;

  005cf	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  005d2	8b 91 d8 00 00
	00		 mov	 edx, DWORD PTR [ecx+216]
  005d8	89 55 e8	 mov	 DWORD PTR _num_bytes$[ebp], edx
$L9312:

; 1928 : 
; 1929 : 				*pcbBuffer = (unsigned int)WMAFileCBGetData((tHWMAFileState *)pInt,
; 1930 :                                                             (tHWMAFileState *)pInt->pCallbackContext,
; 1931 : 															pInt->cbPayloadOffset, num_bytes, ppBuffer);

  005db	8b 45 08	 mov	 eax, DWORD PTR _ppBuffer$[ebp]
  005de	50		 push	 eax
  005df	8b 4d e8	 mov	 ecx, DWORD PTR _num_bytes$[ebp]
  005e2	51		 push	 ecx
  005e3	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  005e6	8b 82 cc 00 00
	00		 mov	 eax, DWORD PTR [edx+204]
  005ec	50		 push	 eax
  005ed	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  005f0	8b 91 c4 00 00
	00		 mov	 edx, DWORD PTR [ecx+196]
  005f6	52		 push	 edx
  005f7	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  005fa	50		 push	 eax
  005fb	e8 00 00 00 00	 call	 _WMAFileCBGetData@20
  00600	8b 4d 0c	 mov	 ecx, DWORD PTR _pcbBuffer$[ebp]
  00603	89 01		 mov	 DWORD PTR [ecx], eax

; 1932 : 
; 1933 : 				memcpy(&bGlobalDataBuffer[0], *ppBuffer,*pcbBuffer);

  00605	8b 55 0c	 mov	 edx, DWORD PTR _pcbBuffer$[ebp]
  00608	8b 02		 mov	 eax, DWORD PTR [edx]
  0060a	50		 push	 eax
  0060b	8b 4d 08	 mov	 ecx, DWORD PTR _ppBuffer$[ebp]
  0060e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00610	52		 push	 edx
  00611	8b 45 fc	 mov	 eax, DWORD PTR _bGlobalDataBuffer$[ebp]
  00614	50		 push	 eax
  00615	e8 00 00 00 00	 call	 _memcpy
  0061a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1934 : 				*ppBuffer = &bGlobalDataBuffer[0];

  0061d	8b 4d 08	 mov	 ecx, DWORD PTR _ppBuffer$[ebp]
  00620	8b 55 fc	 mov	 edx, DWORD PTR _bGlobalDataBuffer$[ebp]
  00623	89 11		 mov	 DWORD PTR [ecx], edx

; 1935 : 
; 1936 : 				pInt->cbPayloadOffset += *pcbBuffer;

  00625	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00628	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  0062e	8b 55 0c	 mov	 edx, DWORD PTR _pcbBuffer$[ebp]
  00631	03 0a		 add	 ecx, DWORD PTR [edx]
  00633	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00636	89 88 cc 00 00
	00		 mov	 DWORD PTR [eax+204], ecx

; 1937 : 				pInt->cbBlockLeft     -= *pcbBuffer;

  0063c	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0063f	8b 55 0c	 mov	 edx, DWORD PTR _pcbBuffer$[ebp]
  00642	8b 81 d8 00 00
	00		 mov	 eax, DWORD PTR [ecx+216]
  00648	2b 02		 sub	 eax, DWORD PTR [edx]
  0064a	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  0064d	89 81 d8 00 00
	00		 mov	 DWORD PTR [ecx+216], eax

; 1938 : 
; 1939 : 				/* DRM decryption if necessary */
; 1940 : 
; 1941 : 				if (pInt->bHasDRM)

  00653	8b 55 f4	 mov	 edx, DWORD PTR _pInt$[ebp]
  00656	83 ba 50 01 00
	00 00		 cmp	 DWORD PTR [edx+336], 0
  0065d	74 07		 je	 SHORT $L9316

; 1942 : 				{
; 1943 : 
; 1944 : #ifdef WMAAPI_NO_DRM
; 1945 : 					return WMA_S_NEWPACKET;

  0065f	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_S_NEWPACKET
  00664	eb 39		 jmp	 SHORT $L9234
$L9316:

; 1946 : #else  /* WMAAPI_NO_DRM */
; 1947 : 
; 1948 : 					hr = CDrmPD_Decrypt (pInt->pDRM_state, *ppBuffer, *pcbBuffer);
; 1949 : 					if (hr != S_OK) {
; 1950 : #ifdef LOCAL_DEBUG
; 1951 : 						SerialPrintf("++ WMARawDecCBGetData: CDrmPD_Decrypt failed (0x%08x).\n\r", hr);
; 1952 : #endif /* LOCAL_DEBUG */
; 1953 : 						*ppBuffer = NULL;
; 1954 : 						*pcbBuffer = 0;
; 1955 : 						return WMA_S_NEWPACKET;
; 1956 : 					}
; 1957 : 
; 1958 : #endif /* WMAAPI_NO_DRM */
; 1959 : 
; 1960 : 				}
; 1961 : 
; 1962 : 				if (pInt->bBlockStart) {

  00666	8b 45 f4	 mov	 eax, DWORD PTR _pInt$[ebp]
  00669	83 b8 d4 00 00
	00 00		 cmp	 DWORD PTR [eax+212], 0
  00670	74 14		 je	 SHORT $L9317

; 1963 : 					pInt->bBlockStart = FALSE;

  00672	8b 4d f4	 mov	 ecx, DWORD PTR _pInt$[ebp]
  00675	c7 81 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+212], 0

; 1964 : 					return WMA_S_NEWPACKET;

  0067f	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_S_NEWPACKET
  00684	eb 19		 jmp	 SHORT $L9234
$L9317:

; 1965 : 				}
; 1966 : 
; 1967 : 				return WMA_OK;

  00686	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0068b	eb 12		 jmp	 SHORT $L9234
$L9257:

; 1968 : 			}
; 1969 : 		}
; 1970 : 
; 1971 : 
; 1972 : 	}while(1);

  0068d	ba 01 00 00 00	 mov	 edx, 1
  00692	85 d2		 test	 edx, edx
  00694	0f 85 e0 f9 ff
	ff		 jne	 $L9256

; 1973 :     
; 1974 : 	return WMA_OK;

  0069a	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
$L9234:

; 1975 : }

  0069f	8b e5		 mov	 esp, ebp
  006a1	5d		 pop	 ebp
  006a2	c2 10 00	 ret	 16			; 00000010H
$L9398:
  006a5	00 00 00 00	 DD	 $L9271
  006a9	00 00 00 00	 DD	 $L9279
  006ad	00 00 00 00	 DD	 $L9292
  006b1	00 00 00 00	 DD	 $L9299
_WMARawDecCBGetData@16 ENDP
WMADEC	ENDS
END
