; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\astocs.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DP@CDBGBDMD@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@CAAMOFF@iOrder_Cs?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@BFNLEIMK@iOrder_Cs?5?$DM?$DN?5MAX_CS_TABLE_ORDER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxAsToCs@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
CONST	SEGMENT
_CsTable DD	03f800000r			; 1
	DD	03f38aa3br			; 0.721348
	DD	03eb8aa43r			; 0.360674
	DD	03e763843r			; 0.240449
	DD	03e38aa43r			; 0.180337
	DD	03e13bb41r			; 0.144269
	DD	03df63886r			; 0.120225
	DD	03dd30be1r			; 0.10305
	DD	03db8aa00r			; 0.090168
	DD	03da425afr			; 0.08015
	DD	03d93bb84r			; 0.072135
	DD	03d864d3cr			; 0.065577
	DD	03d763800r			; 0.060112
	DD	03d634763r			; 0.055488
	DD	03d530be1r			; 0.051525
	DD	03d44fa05r			; 0.04809
	DD	03d38aa00r			; 0.045084
	DD	03d2dcd2dr			; 0.042432
	DD	03d2425afr			; 0.040075
	DD	03d1b823dr			; 0.037966
	DD	03d13bafer			; 0.036067
	DD	03d0cb296r			; 0.03435
	DD	03d064dc2r			; 0.032789
	DD	03d00767dr			; 0.031363
	DD	03cf63800r			; 0.030056
	DD	03cec5f39r			; 0.028854
	DD	03ce34763r			; 0.027744
	DD	03cdadd9cr			; 0.026717
	DD	03cd30ad4r			; 0.025762
	DD	03ccbc48fr			; 0.024874
	DD	03cc4fa05r			; 0.024045
	DD	03cbe9ea1r			; 0.023269
	DD	03cb8aa00r			; 0.022542
	DD	03cb311a5r			; 0.021859
	DD	03cadcd2dr			; 0.021216
	DD	03ca8d64dr			; 0.02061
	DD	03ca424a2r			; 0.020037
	DD	03c9fb613r			; 0.019496
	DD	03c9b823dr			; 0.018983
	DD	03c9784ecr			; 0.018496
	DD	03c93bc0ar			; 0.018034
	DD	03c90214br			; 0.017594
	DD	03c8cb296r			; 0.017175
	DD	03c896dd2r			; 0.016776
CONST	ENDS
PUBLIC	_VoxAsToCs@20
PUBLIC	??_C@_0DP@CDBGBDMD@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0P@CAAMOFF@iOrder_Cs?5?$DO?$DN?50?$AA@	; `string'
PUBLIC	??_C@_0CA@BFNLEIMK@iOrder_Cs?5?$DM?$DN?5MAX_CS_TABLE_ORDER?$AA@ ; `string'
EXTRN	__assert:NEAR
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_0DP@CDBGBDMD@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\astocs.c
CONST	SEGMENT
??_C@_0DP@CDBGBDMD@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\astocs.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CAAMOFF@iOrder_Cs?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@CAAMOFF@iOrder_Cs?5?$DO?$DN?50?$AA@ DB 'iOrder_Cs >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BFNLEIMK@iOrder_Cs?5?$DM?$DN?5MAX_CS_TABLE_ORDER?$AA@
CONST	SEGMENT
??_C@_0CA@BFNLEIMK@iOrder_Cs?5?$DM?$DN?5MAX_CS_TABLE_ORDER?$AA@ DB 'iOrde'
	DB	'r_Cs <= MAX_CS_TABLE_ORDER', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxAsToCs@20
_TEXT	SEGMENT
tv76 = -24
_m$ = -20
_iOrder_Cs$ = -16
_k$ = -12
_P$ = -8
_fSum$ = -4
_fGain$ = 8
_pfAs$ = 12
_iOrder_As$ = 16
_pfCs$ = 20
_iLength_Cs$ = 24
_VoxAsToCs@20 PROC NEAR					; COMDAT

; 92   :  {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 93   :    int   m, k;
; 94   :    int   iOrder_Cs;
; 95   :    int   P;
; 96   :    float fSum;
; 97   : 
; 98   :    iOrder_Cs = iLength_Cs - 1;

  00007	8b 45 18	 mov	 eax, DWORD PTR _iLength_Cs$[ebp]
  0000a	83 e8 01	 sub	 eax, 1
  0000d	89 45 f0	 mov	 DWORD PTR _iOrder_Cs$[ebp], eax

; 99   : 
; 100  :    assert(iOrder_Cs >= 0);    

  00010	83 7d f0 00	 cmp	 DWORD PTR _iOrder_Cs$[ebp], 0
  00014	7d 14		 jge	 SHORT $L772
  00016	6a 64		 push	 100			; 00000064H
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@CDBGBDMD@c?3?2xbox?2private?2windows?2directx?2@
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@CAAMOFF@iOrder_Cs?5?$DO?$DN?50?$AA@
  00022	e8 00 00 00 00	 call	 __assert
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
$L772:

; 101  :    assert(iOrder_Cs <= MAX_CS_TABLE_ORDER);    

  0002a	83 7d f0 2b	 cmp	 DWORD PTR _iOrder_Cs$[ebp], 43 ; 0000002bH
  0002e	76 14		 jbe	 SHORT $L773
  00030	6a 65		 push	 101			; 00000065H
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@CDBGBDMD@c?3?2xbox?2private?2windows?2directx?2@
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@BFNLEIMK@iOrder_Cs?5?$DM?$DN?5MAX_CS_TABLE_ORDER?$AA@
  0003c	e8 00 00 00 00	 call	 __assert
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
$L773:

; 102  : 
; 103  :    /*-----------------------------------------------------------------------
; 104  :      chose the order of recursion is min(iOrder_As, iLength_Cs-1)
; 105  :    -----------------------------------------------------------------------*/
; 106  :    P = VoxMIN( iOrder_As, iOrder_Cs );

  00044	8b 45 10	 mov	 eax, DWORD PTR _iOrder_As$[ebp]
  00047	3b 45 f0	 cmp	 eax, DWORD PTR _iOrder_Cs$[ebp]
  0004a	7e 08		 jle	 SHORT $L774
  0004c	8b 4d f0	 mov	 ecx, DWORD PTR _iOrder_Cs$[ebp]
  0004f	89 4d e8	 mov	 DWORD PTR tv76[ebp], ecx
  00052	eb 06		 jmp	 SHORT $L775
$L774:
  00054	8b 55 10	 mov	 edx, DWORD PTR _iOrder_As$[ebp]
  00057	89 55 e8	 mov	 DWORD PTR tv76[ebp], edx
$L775:
  0005a	8b 45 e8	 mov	 eax, DWORD PTR tv76[ebp]
  0005d	89 45 f8	 mov	 DWORD PTR _P$[ebp], eax

; 107  : 
; 108  :    /*-----------------------------------------------------------------------
; 109  :      Use the recursion to convert LPC parameter to Cepstrum Coefficients.
; 110  :    -----------------------------------------------------------------------*/
; 111  :    pfCs[0] = fGain;      /* gain = .5*log_b2(Residue_Eng) */

  00060	8b 4d 14	 mov	 ecx, DWORD PTR _pfCs$[ebp]
  00063	8b 55 08	 mov	 edx, DWORD PTR _fGain$[ebp]
  00066	89 11		 mov	 DWORD PTR [ecx], edx

; 112  : 
; 113  :    /*----------------------------------------------------------------------
; 114  :      For cepstrum order smaller than or equal to LPC order.
; 115  :      using recursion (3.83b) as in P.115 of the reference.
; 116  :      Note: fSum is the normalized cepstrum here: fSum = m*pfCs[m].
; 117  :    ----------------------------------------------------------------------*/
; 118  :    for (m = 1; m <= P; m ++)

  00068	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _m$[ebp], 1
  0006f	eb 09		 jmp	 SHORT $L746
$L747:
  00071	8b 45 ec	 mov	 eax, DWORD PTR _m$[ebp]
  00074	83 c0 01	 add	 eax, 1
  00077	89 45 ec	 mov	 DWORD PTR _m$[ebp], eax
$L746:
  0007a	8b 4d ec	 mov	 ecx, DWORD PTR _m$[ebp]
  0007d	3b 4d f8	 cmp	 ecx, DWORD PTR _P$[ebp]
  00080	7f 56		 jg	 SHORT $L748

; 119  :    {
; 120  :       fSum = -(float)m*pfAs[m];

  00082	db 45 ec	 fild	 DWORD PTR _m$[ebp]
  00085	d9 e0		 fchs
  00087	8b 55 ec	 mov	 edx, DWORD PTR _m$[ebp]
  0008a	8b 45 0c	 mov	 eax, DWORD PTR _pfAs$[ebp]
  0008d	d8 0c 90	 fmul	 DWORD PTR [eax+edx*4]
  00090	d9 5d fc	 fstp	 DWORD PTR _fSum$[ebp]

; 121  :       for (k=1; k<m; k++)

  00093	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _k$[ebp], 1
  0009a	eb 09		 jmp	 SHORT $L750
$L751:
  0009c	8b 4d f4	 mov	 ecx, DWORD PTR _k$[ebp]
  0009f	83 c1 01	 add	 ecx, 1
  000a2	89 4d f4	 mov	 DWORD PTR _k$[ebp], ecx
$L750:
  000a5	8b 55 f4	 mov	 edx, DWORD PTR _k$[ebp]
  000a8	3b 55 ec	 cmp	 edx, DWORD PTR _m$[ebp]
  000ab	7d 1d		 jge	 SHORT $L752

; 122  :          fSum -= pfAs[k]*pfCs[m-k];

  000ad	8b 45 ec	 mov	 eax, DWORD PTR _m$[ebp]
  000b0	2b 45 f4	 sub	 eax, DWORD PTR _k$[ebp]
  000b3	8b 4d f4	 mov	 ecx, DWORD PTR _k$[ebp]
  000b6	8b 55 0c	 mov	 edx, DWORD PTR _pfAs$[ebp]
  000b9	8b 75 14	 mov	 esi, DWORD PTR _pfCs$[ebp]
  000bc	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  000bf	d8 0c 86	 fmul	 DWORD PTR [esi+eax*4]
  000c2	d8 6d fc	 fsubr	 DWORD PTR _fSum$[ebp]
  000c5	d9 5d fc	 fstp	 DWORD PTR _fSum$[ebp]
  000c8	eb d2		 jmp	 SHORT $L751
$L752:

; 123  :       pfCs[m] = fSum;

  000ca	8b 45 ec	 mov	 eax, DWORD PTR _m$[ebp]
  000cd	8b 4d 14	 mov	 ecx, DWORD PTR _pfCs$[ebp]
  000d0	8b 55 fc	 mov	 edx, DWORD PTR _fSum$[ebp]
  000d3	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 124  :    }

  000d6	eb 99		 jmp	 SHORT $L747
$L748:

; 125  : 
; 126  :    /*----------------------------------------------------------------------
; 127  :      For cepstrum order larger than LPC order.
; 128  :      using recursion (3.83c) as in P.115 of the reference.
; 129  :      Note: fSum is the normalized cepstrum here: fSum = m*pfCs[m].
; 130  :    ----------------------------------------------------------------------*/
; 131  :    for (; m <= iOrder_Cs; m++)

  000d8	eb 09		 jmp	 SHORT $L753
$L754:
  000da	8b 45 ec	 mov	 eax, DWORD PTR _m$[ebp]
  000dd	83 c0 01	 add	 eax, 1
  000e0	89 45 ec	 mov	 DWORD PTR _m$[ebp], eax
$L753:
  000e3	8b 4d ec	 mov	 ecx, DWORD PTR _m$[ebp]
  000e6	3b 4d f0	 cmp	 ecx, DWORD PTR _iOrder_Cs$[ebp]
  000e9	7f 4c		 jg	 SHORT $L755

; 132  :    {
; 133  :       fSum = 0.0F;

  000eb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fSum$[ebp], 0

; 134  :       for (k=1; k<=iOrder_As; k++)

  000f2	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _k$[ebp], 1
  000f9	eb 09		 jmp	 SHORT $L756
$L757:
  000fb	8b 55 f4	 mov	 edx, DWORD PTR _k$[ebp]
  000fe	83 c2 01	 add	 edx, 1
  00101	89 55 f4	 mov	 DWORD PTR _k$[ebp], edx
$L756:
  00104	8b 45 f4	 mov	 eax, DWORD PTR _k$[ebp]
  00107	3b 45 10	 cmp	 eax, DWORD PTR _iOrder_As$[ebp]
  0010a	7f 1d		 jg	 SHORT $L758

; 135  :          fSum -= pfAs[k]*pfCs[m-k];

  0010c	8b 4d ec	 mov	 ecx, DWORD PTR _m$[ebp]
  0010f	2b 4d f4	 sub	 ecx, DWORD PTR _k$[ebp]
  00112	8b 55 f4	 mov	 edx, DWORD PTR _k$[ebp]
  00115	8b 45 0c	 mov	 eax, DWORD PTR _pfAs$[ebp]
  00118	8b 75 14	 mov	 esi, DWORD PTR _pfCs$[ebp]
  0011b	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  0011e	d8 0c 8e	 fmul	 DWORD PTR [esi+ecx*4]
  00121	d8 6d fc	 fsubr	 DWORD PTR _fSum$[ebp]
  00124	d9 5d fc	 fstp	 DWORD PTR _fSum$[ebp]
  00127	eb d2		 jmp	 SHORT $L757
$L758:

; 136  :       pfCs[m] = fSum;

  00129	8b 4d ec	 mov	 ecx, DWORD PTR _m$[ebp]
  0012c	8b 55 14	 mov	 edx, DWORD PTR _pfCs$[ebp]
  0012f	8b 45 fc	 mov	 eax, DWORD PTR _fSum$[ebp]
  00132	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 137  :    }

  00135	eb a3		 jmp	 SHORT $L754
$L755:

; 138  : 
; 139  :    /*-----------------------------------------------------------------------
; 140  :       (1) Remove the normalization (i.e. pfCs[m] = pfCs[m]/m).
; 141  :       (2) Convert the log_base_e transform to 0.5*log_base_2 transform.
; 142  :       The constants .5*1.442695041/n are stored in  CsTable[] for speed.
; 143  :    -----------------------------------------------------------------------*/
; 144  :    for(m=1; m<=iOrder_Cs; m++)

  00137	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _m$[ebp], 1
  0013e	eb 09		 jmp	 SHORT $L759
$L760:
  00140	8b 4d ec	 mov	 ecx, DWORD PTR _m$[ebp]
  00143	83 c1 01	 add	 ecx, 1
  00146	89 4d ec	 mov	 DWORD PTR _m$[ebp], ecx
$L759:
  00149	8b 55 ec	 mov	 edx, DWORD PTR _m$[ebp]
  0014c	3b 55 f0	 cmp	 edx, DWORD PTR _iOrder_Cs$[ebp]
  0014f	7f 1e		 jg	 SHORT $L734

; 145  :      pfCs[m] = CsTable[m] * pfCs[m];

  00151	8b 45 ec	 mov	 eax, DWORD PTR _m$[ebp]
  00154	8b 4d ec	 mov	 ecx, DWORD PTR _m$[ebp]
  00157	8b 55 14	 mov	 edx, DWORD PTR _pfCs$[ebp]
  0015a	d9 04 85 00 00
	00 00		 fld	 DWORD PTR _CsTable[eax*4]
  00161	d8 0c 8a	 fmul	 DWORD PTR [edx+ecx*4]
  00164	8b 45 ec	 mov	 eax, DWORD PTR _m$[ebp]
  00167	8b 4d 14	 mov	 ecx, DWORD PTR _pfCs$[ebp]
  0016a	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
  0016d	eb d1		 jmp	 SHORT $L760
$L734:

; 146  : 
; 147  : }

  0016f	5e		 pop	 esi
  00170	8b e5		 mov	 esp, ebp
  00172	5d		 pop	 ebp
  00173	c2 14 00	 ret	 20			; 00000014H
_VoxAsToCs@20 ENDP
_TEXT	ENDS
END
