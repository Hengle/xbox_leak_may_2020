; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\entropydec.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
WMADEC_RW	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RW	ENDS
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _LOG2@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT @ByteSwap@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmBitsLeft@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmFlush@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvDecodeFrameHeader_XDS@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvDecodeCoefficientMono_XDS@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvDecodeCoefficientStereo_XDS@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvGetNextRunDEC_XDS@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvDecodeRunLevel_XDS@20
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvSetDetTable_XDS@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvDecodeFrameHeaderLpc_XDS@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvDecodeFrameHeaderNoiseSub_XDS@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ffltAvgSquareWeights@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ffltSqrtRatio@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvGetBandWeightLowRate_XDS@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, WMADEC_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_DSoundBuildNumberD
WMADEC_RD	SEGMENT
_WMA_OK	DD	00H
_WMA_S_FALSE DD	01H
_WMA_S_BUFUNDERFLOW DD 02H
_WMA_S_NEWPACKET DD 03H
_WMA_S_NO_MORE_FRAME DD 04H
_WMA_S_DEFAULT DD 05H
_WMA_S_SWITCHCHMODE DD 06H
_WMA_E_FAIL DD	080004005H
_WMA_E_OUTOFMEMORY DD 08007000eH
_WMA_E_INVALIDARG DD 080070057H
_WMA_E_NOTSUPPORTED DD 080040000H
_WMA_E_LOSTPACKET DD 080040001H
_WMA_E_BROKEN_FRAME DD 080040002H
_WMA_E_BUFFEROVERFLOW DD 080040003H
_WMA_E_ONHOLD DD 080040004H
_WMA_E_BUFFERUNDERFLOW DD 080040005H
_WMA_E_INVALIDRECHDR DD 080040006H
_WMA_E_SYNCERROR DD 080040007H
_WMA_E_NOTIMPL DD 080040008H
_WMA_E_FLUSHOVERFLOW DD 080040009H
WMADEC_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT
_DSoundBuildNumberD DW 05344H
	DW	0554fH
	DW	0444eH
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_LOG2@4
PUBLIC	_prvDecodeFrameHeader_XDS@8
PUBLIC	_prvSetDetTable_XDS@8
PUBLIC	_prvDecodeFrameHeaderLpc_XDS@8
PUBLIC	_prvDecodeFrameHeaderNoiseSub_XDS@8
PUBLIC	_prvGetBandWeightLowRate_XDS@4
PUBLIC	??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@ ; `string'
EXTRN	_auAdaptToSubFrameConfig_XDS@4:NEAR
EXTRN	_auUpdateMaxEsc_XDS@8:NEAR
EXTRN	_memset:NEAR
EXTRN	_ibstrmLookForBits@8:NEAR
EXTRN	_ibstrmFlushBits@8:NEAR
EXTRN	_ibstrmGetBits@12:NEAR
EXTRN	_MyOutputDbgStr:NEAR
EXTRN	_g_rgiHuffDecTblMsk:BYTE
EXTRN	_prvUpdateSubFrameConfig_XDS@16:NEAR
EXTRN	_huffDecGet@20:NEAR
;	COMDAT ??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\entropydec.c
WMADEC_RD	SEGMENT
??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\wmalib\wmadec_s\entropyde'
	DB	'c.c', 00H					; `string'
WMADEC_RD	ENDS
;	COMDAT ??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
WMADEC_RD	SEGMENT
??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@ DB '%'
	DB	's(%d) : *** TRACE *** code = 0x%x!', 0aH, 00H ; `string'
; Function compile flags: /Odt
WMADEC_RD	ENDS
;	COMDAT _prvDecodeFrameHeader_XDS@8
WMADEC	SEGMENT
tv620 = -168
tv575 = -164
tv565 = -160
tv550 = -156
tv519 = -152
tv480 = -148
tv426 = -144
tv411 = -140
tv382 = -136
tv366 = -132
tv350 = -128
tv315 = -124
tv297 = -120
tv280 = -116
tv255 = -112
tv237 = -108
tv225 = -104
tv210 = -100
tv193 = -96
tv178 = -92
tv156 = -88
tv137 = -84
tv88 = -80
tv66 = -76
_iMax$3001 = -72
_iBand$3002 = -68
_iDiff$2991 = -64
_rgiMaskQ$2981 = -60
_ppcinfo$2979 = -56
_iStepSize$2949 = -52
_cBitsNeed$2891 = -48
_iSizeNext$ = -44
_fSkipAll$ = -40
_iMaskQPrev$ = -36
_iSizeCurr$ = -32
_ppcinfo$ = -28
_iResult$ = -24
_piChannel$ = -20
_pau$ = -16
_wmaResult$ = -12
_fUpdateMask$ = -8
_iSizePrev$ = -4
_paudec$ = 8
_piBitCnt$ = 12
_prvDecodeFrameHeader_XDS@8 PROC NEAR			; COMDAT

; 61   : {      

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	56		 push	 esi

; 62   :     Bool fSkipAll;
; 63   :     Bool* fUpdateMask;
; 64   :     I16  *piChannel = &paudec->m_iChannel;

  0000a	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0000d	83 c0 24	 add	 eax, 36			; 00000024H
  00010	89 45 ec	 mov	 DWORD PTR _piChannel$[ebp], eax

; 65   :     Int iMaskQPrev;
; 66   :     Int iSizePrev = 0, iSizeCurr = 0, iSizeNext = 0;

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iSizePrev$[ebp], 0
  0001a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iSizeCurr$[ebp], 0
  00021	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _iSizeNext$[ebp], 0

; 67   :     PerChannelInfo* ppcinfo;
; 68   : 	CAudioObject* pau = paudec->pau;

  00028	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	89 55 f0	 mov	 DWORD PTR _pau$[ebp], edx

; 69   : 
; 70   :     WMARESULT   wmaResult = WMA_OK;

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  00035	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 71   :     U32         iResult;
; 72   : 
; 73   : #ifdef PROFILE
; 74   :     FunctionProfile fp;
; 75   :     FunctionProfileStart(&fp,DECODE_FRAME_HEADER_PROFILE);
; 76   : #endif
; 77   : 
; 78   :     switch (paudec->m_hdrdecsts)
; 79   :     {

  00038	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0003b	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0003e	89 55 b4	 mov	 DWORD PTR tv66[ebp], edx
  00041	83 7d b4 05	 cmp	 DWORD PTR tv66[ebp], 5
  00045	0f 87 11 0e 00
	00		 ja	 $L2886
  0004b	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  0004e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L3368[eax*4]
$L2889:

; 80   :         case HDR_SIZE:
; 81   :             if (pau->m_fAllowSubFrame) 

  00055	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  00058	83 79 68 00	 cmp	 DWORD PTR [ecx+104], 0
  0005c	0f 84 12 03 00
	00		 je	 $L2890

; 82   :             {
; 83   :                 //peek enough bits for this "case" if not enough will be on hold
; 84   :                 Int cBitsNeed = LOG2 ((U32) LOG2 ((U32)pau->m_iMaxSubFrameDiv)) + 1;

  00062	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00065	8b 82 80 00 00
	00		 mov	 eax, DWORD PTR [edx+128]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _LOG2@4
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _LOG2@4
  00077	83 c0 01	 add	 eax, 1
  0007a	89 45 d0	 mov	 DWORD PTR _cBitsNeed$2891[ebp], eax

; 85   :                 TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, 12));

  0007d	6a 0c		 push	 12			; 0000000cH
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00082	83 c1 30	 add	 ecx, 48			; 00000030H
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 _ibstrmLookForBits@8
  0008b	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0008e	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00092	7d 42		 jge	 SHORT $L2899
  00094	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00097	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  0009d	74 2c		 je	 SHORT $L3322
  0009f	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000a2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  000a8	74 21		 je	 SHORT $L3322
  000aa	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000ad	51		 push	 ecx
  000ae	6a 55		 push	 85			; 00000055H
  000b0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  000b5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  000ba	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _MyOutputDbgStr
  000c3	83 c4 14	 add	 esp, 20			; 00000014H
  000c6	89 45 b0	 mov	 DWORD PTR tv88[ebp], eax
  000c9	eb 06		 jmp	 SHORT $L3323
$L3322:
  000cb	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000ce	89 45 b0	 mov	 DWORD PTR tv88[ebp], eax
$L3323:
  000d1	e9 90 0d 00 00	 jmp	 $exit$2898
$L2899:

; 86   :                 if (pau->m_fHeaderReset) 

  000d6	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  000d9	83 79 78 00	 cmp	 DWORD PTR [ecx+120], 0
  000dd	0f 84 9e 01 00
	00		 je	 $L2900

; 87   :                 {
; 88   :                     TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, cBitsNeed, &iResult));

  000e3	8d 55 e8	 lea	 edx, DWORD PTR _iResult$[ebp]
  000e6	52		 push	 edx
  000e7	8b 45 d0	 mov	 eax, DWORD PTR _cBitsNeed$2891[ebp]
  000ea	50		 push	 eax
  000eb	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  000ee	83 c1 30	 add	 ecx, 48			; 00000030H
  000f1	51		 push	 ecx
  000f2	e8 00 00 00 00	 call	 _ibstrmGetBits@12
  000f7	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  000fa	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  000fe	7d 42		 jge	 SHORT $L2903
  00100	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00103	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  00109	74 2c		 je	 SHORT $L3324
  0010b	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  0010e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00114	74 21		 je	 SHORT $L3324
  00116	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00119	51		 push	 ecx
  0011a	6a 58		 push	 88			; 00000058H
  0011c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00121	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00126	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00129	52		 push	 edx
  0012a	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0012f	83 c4 14	 add	 esp, 20			; 00000014H
  00132	89 45 ac	 mov	 DWORD PTR tv137[ebp], eax
  00135	eb 06		 jmp	 SHORT $L3325
$L3324:
  00137	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  0013a	89 45 ac	 mov	 DWORD PTR tv137[ebp], eax
$L3325:
  0013d	e9 24 0d 00 00	 jmp	 $exit$2898
$L2903:

; 89   :                     COUNT_BITS(*piBitCnt, cBitsNeed);

  00142	8b 4d 0c	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  00145	8b 11		 mov	 edx, DWORD PTR [ecx]
  00147	03 55 d0	 add	 edx, DWORD PTR _cBitsNeed$2891[ebp]
  0014a	8b 45 0c	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  0014d	89 10		 mov	 DWORD PTR [eax], edx

; 90   :                     iSizePrev = pau->m_cFrameSampleHalf / (1 << iResult);

  0014f	be 01 00 00 00	 mov	 esi, 1
  00154	8b 4d e8	 mov	 ecx, DWORD PTR _iResult$[ebp]
  00157	d3 e6		 shl	 esi, cl
  00159	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  0015c	8b 81 1c 03 00
	00		 mov	 eax, DWORD PTR [ecx+796]
  00162	99		 cdq
  00163	f7 fe		 idiv	 esi
  00165	89 45 fc	 mov	 DWORD PTR _iSizePrev$[ebp], eax

; 91   : 
; 92   :                     //current
; 93   :                     TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, cBitsNeed, &iResult));

  00168	8d 55 e8	 lea	 edx, DWORD PTR _iResult$[ebp]
  0016b	52		 push	 edx
  0016c	8b 45 d0	 mov	 eax, DWORD PTR _cBitsNeed$2891[ebp]
  0016f	50		 push	 eax
  00170	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00173	83 c1 30	 add	 ecx, 48			; 00000030H
  00176	51		 push	 ecx
  00177	e8 00 00 00 00	 call	 _ibstrmGetBits@12
  0017c	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0017f	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00183	7d 42		 jge	 SHORT $L2906
  00185	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00188	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  0018e	74 2c		 je	 SHORT $L3326
  00190	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00193	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00199	74 21		 je	 SHORT $L3326
  0019b	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0019e	51		 push	 ecx
  0019f	6a 5d		 push	 93			; 0000005dH
  001a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  001a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  001ab	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  001ae	52		 push	 edx
  001af	e8 00 00 00 00	 call	 _MyOutputDbgStr
  001b4	83 c4 14	 add	 esp, 20			; 00000014H
  001b7	89 45 a8	 mov	 DWORD PTR tv156[ebp], eax
  001ba	eb 06		 jmp	 SHORT $L3327
$L3326:
  001bc	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  001bf	89 45 a8	 mov	 DWORD PTR tv156[ebp], eax
$L3327:
  001c2	e9 9f 0c 00 00	 jmp	 $exit$2898
$L2906:

; 94   :                     COUNT_BITS(*piBitCnt, cBitsNeed);

  001c7	8b 4d 0c	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  001ca	8b 11		 mov	 edx, DWORD PTR [ecx]
  001cc	03 55 d0	 add	 edx, DWORD PTR _cBitsNeed$2891[ebp]
  001cf	8b 45 0c	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  001d2	89 10		 mov	 DWORD PTR [eax], edx

; 95   :                     iSizeCurr = pau->m_cFrameSampleHalf / (1 << iResult);

  001d4	be 01 00 00 00	 mov	 esi, 1
  001d9	8b 4d e8	 mov	 ecx, DWORD PTR _iResult$[ebp]
  001dc	d3 e6		 shl	 esi, cl
  001de	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  001e1	8b 81 1c 03 00
	00		 mov	 eax, DWORD PTR [ecx+796]
  001e7	99		 cdq
  001e8	f7 fe		 idiv	 esi
  001ea	89 45 e0	 mov	 DWORD PTR _iSizeCurr$[ebp], eax

; 96   : 
; 97   :                     assert (iSizePrev != 0 && iSizeCurr != 0);
; 98   :                     pau->m_fHeaderReset = WMAB_FALSE;

  001ed	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  001f0	c7 42 78 00 00
	00 00		 mov	 DWORD PTR [edx+120], 0

; 99   :                     if (iSizePrev  < pau->m_cMinSubFrameSampleHalf || iSizePrev > pau->m_cFrameSampleHalf ||
; 100  :                         iSizeCurr  < pau->m_cMinSubFrameSampleHalf || iSizeCurr > pau->m_cFrameSampleHalf)

  001f7	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  001fa	8b 4d fc	 mov	 ecx, DWORD PTR _iSizePrev$[ebp]
  001fd	3b 88 88 00 00
	00		 cmp	 ecx, DWORD PTR [eax+136]
  00203	7c 2a		 jl	 SHORT $L2908
  00205	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00208	8b 45 fc	 mov	 eax, DWORD PTR _iSizePrev$[ebp]
  0020b	3b 82 1c 03 00
	00		 cmp	 eax, DWORD PTR [edx+796]
  00211	7f 1c		 jg	 SHORT $L2908
  00213	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  00216	8b 55 e0	 mov	 edx, DWORD PTR _iSizeCurr$[ebp]
  00219	3b 91 88 00 00
	00		 cmp	 edx, DWORD PTR [ecx+136]
  0021f	7c 0e		 jl	 SHORT $L2908
  00221	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  00224	8b 4d e0	 mov	 ecx, DWORD PTR _iSizeCurr$[ebp]
  00227	3b 88 1c 03 00
	00		 cmp	 ecx, DWORD PTR [eax+796]
  0022d	7e 52		 jle	 SHORT $L2900
$L2908:

; 101  :                     {
; 102  :                         assert (WMAB_FALSE);
; 103  :                         return TraceResult(WMA_E_BROKEN_FRAME);

  0022f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  00235	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  0023b	74 34		 je	 SHORT $L3328
  0023d	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  00242	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00248	74 27		 je	 SHORT $L3328
  0024a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  00250	51		 push	 ecx
  00251	6a 67		 push	 103			; 00000067H
  00253	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00258	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0025d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  00263	52		 push	 edx
  00264	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00269	83 c4 14	 add	 esp, 20			; 00000014H
  0026c	89 45 a4	 mov	 DWORD PTR tv178[ebp], eax
  0026f	eb 08		 jmp	 SHORT $L3329
$L3328:
  00271	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  00276	89 45 a4	 mov	 DWORD PTR tv178[ebp], eax
$L3329:
  00279	8b 45 a4	 mov	 eax, DWORD PTR tv178[ebp]
  0027c	e9 e8 0b 00 00	 jmp	 $L2873
$L2900:

; 104  :                     }
; 105  :                 }
; 106  : 
; 107  :                 TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, cBitsNeed, &iResult));

  00281	8d 4d e8	 lea	 ecx, DWORD PTR _iResult$[ebp]
  00284	51		 push	 ecx
  00285	8b 55 d0	 mov	 edx, DWORD PTR _cBitsNeed$2891[ebp]
  00288	52		 push	 edx
  00289	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0028c	83 c0 30	 add	 eax, 48			; 00000030H
  0028f	50		 push	 eax
  00290	e8 00 00 00 00	 call	 _ibstrmGetBits@12
  00295	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00298	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  0029c	7d 42		 jge	 SHORT $L2911
  0029e	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  002a1	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  002a7	74 2c		 je	 SHORT $L3330
  002a9	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  002ac	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  002b2	74 21		 je	 SHORT $L3330
  002b4	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  002b7	50		 push	 eax
  002b8	6a 6b		 push	 107			; 0000006bH
  002ba	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  002bf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  002c4	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  002c7	51		 push	 ecx
  002c8	e8 00 00 00 00	 call	 _MyOutputDbgStr
  002cd	83 c4 14	 add	 esp, 20			; 00000014H
  002d0	89 45 a0	 mov	 DWORD PTR tv193[ebp], eax
  002d3	eb 06		 jmp	 SHORT $L3331
$L3330:
  002d5	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  002d8	89 55 a0	 mov	 DWORD PTR tv193[ebp], edx
$L3331:
  002db	e9 86 0b 00 00	 jmp	 $exit$2898
$L2911:

; 108  :                 COUNT_BITS(*piBitCnt, cBitsNeed);

  002e0	8b 45 0c	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  002e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e5	03 4d d0	 add	 ecx, DWORD PTR _cBitsNeed$2891[ebp]
  002e8	8b 55 0c	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  002eb	89 0a		 mov	 DWORD PTR [edx], ecx

; 109  :                 iSizeNext = pau->m_cFrameSampleHalf / (1 << iResult);

  002ed	be 01 00 00 00	 mov	 esi, 1
  002f2	8b 4d e8	 mov	 ecx, DWORD PTR _iResult$[ebp]
  002f5	d3 e6		 shl	 esi, cl
  002f7	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  002fa	8b 80 1c 03 00
	00		 mov	 eax, DWORD PTR [eax+796]
  00300	99		 cdq
  00301	f7 fe		 idiv	 esi
  00303	89 45 d4	 mov	 DWORD PTR _iSizeNext$[ebp], eax

; 110  :                 if (iSizeNext  < pau->m_cMinSubFrameSampleHalf || iSizeNext > pau->m_cFrameSampleHalf)

  00306	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  00309	8b 55 d4	 mov	 edx, DWORD PTR _iSizeNext$[ebp]
  0030c	3b 91 88 00 00
	00		 cmp	 edx, DWORD PTR [ecx+136]
  00312	7c 0e		 jl	 SHORT $L2913
  00314	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  00317	8b 4d d4	 mov	 ecx, DWORD PTR _iSizeNext$[ebp]
  0031a	3b 88 1c 03 00
	00		 cmp	 ecx, DWORD PTR [eax+796]
  00320	7e 52		 jle	 SHORT $L2890
$L2913:

; 111  :                 {
; 112  :                     assert (WMAB_FALSE);
; 113  :                     return TraceResult(WMA_E_BROKEN_FRAME);

  00322	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  00328	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  0032e	74 34		 je	 SHORT $L3332
  00330	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  00335	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  0033b	74 27		 je	 SHORT $L3332
  0033d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  00343	51		 push	 ecx
  00344	6a 71		 push	 113			; 00000071H
  00346	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  0034b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00350	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  00356	52		 push	 edx
  00357	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0035c	83 c4 14	 add	 esp, 20			; 00000014H
  0035f	89 45 9c	 mov	 DWORD PTR tv210[ebp], eax
  00362	eb 08		 jmp	 SHORT $L3333
$L3332:
  00364	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  00369	89 45 9c	 mov	 DWORD PTR tv210[ebp], eax
$L3333:
  0036c	8b 45 9c	 mov	 eax, DWORD PTR tv210[ebp]
  0036f	e9 f5 0a 00 00	 jmp	 $L2873
$L2890:

; 114  :                 }
; 115  :             }
; 116  :             ASSERTWMA_EXIT(wmaResult, prvUpdateSubFrameConfig(paudec, iSizeNext, iSizePrev, iSizeCurr));

  00374	8b 4d e0	 mov	 ecx, DWORD PTR _iSizeCurr$[ebp]
  00377	51		 push	 ecx
  00378	8b 55 fc	 mov	 edx, DWORD PTR _iSizePrev$[ebp]
  0037b	52		 push	 edx
  0037c	8b 45 d4	 mov	 eax, DWORD PTR _iSizeNext$[ebp]
  0037f	50		 push	 eax
  00380	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00383	51		 push	 ecx
  00384	e8 00 00 00 00	 call	 _prvUpdateSubFrameConfig_XDS@16
  00389	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0038c	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00390	7d 42		 jge	 SHORT $L2916
  00392	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00395	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  0039b	74 2c		 je	 SHORT $L3334
  0039d	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  003a0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  003a6	74 21		 je	 SHORT $L3334
  003a8	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  003ab	51		 push	 ecx
  003ac	6a 74		 push	 116			; 00000074H
  003ae	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  003b3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  003b8	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  003bb	52		 push	 edx
  003bc	e8 00 00 00 00	 call	 _MyOutputDbgStr
  003c1	83 c4 14	 add	 esp, 20			; 00000014H
  003c4	89 45 98	 mov	 DWORD PTR tv225[ebp], eax
  003c7	eb 06		 jmp	 SHORT $L3335
$L3334:
  003c9	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  003cc	89 45 98	 mov	 DWORD PTR tv225[ebp], eax
$L3335:
  003cf	e9 92 0a 00 00	 jmp	 $exit$2898
$L2916:

; 117  :             ASSERTWMA_EXIT(wmaResult, auAdaptToSubFrameConfig (pau));

  003d4	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  003d7	51		 push	 ecx
  003d8	e8 00 00 00 00	 call	 _auAdaptToSubFrameConfig_XDS@4
  003dd	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  003e0	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  003e4	7d 42		 jge	 SHORT $L2919
  003e6	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  003e9	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  003ef	74 2c		 je	 SHORT $L3336
  003f1	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  003f4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  003fa	74 21		 je	 SHORT $L3336
  003fc	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  003ff	51		 push	 ecx
  00400	6a 75		 push	 117			; 00000075H
  00402	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00407	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0040c	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0040f	52		 push	 edx
  00410	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00415	83 c4 14	 add	 esp, 20			; 00000014H
  00418	89 45 94	 mov	 DWORD PTR tv237[ebp], eax
  0041b	eb 06		 jmp	 SHORT $L3337
$L3336:
  0041d	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00420	89 45 94	 mov	 DWORD PTR tv237[ebp], eax
$L3337:
  00423	e9 3e 0a 00 00	 jmp	 $exit$2898
$L2919:

; 118  : 
; 119  : #ifdef ENABLE_EQUALIZER
; 120  :             prvAdaptEqToSubFrame(paudec);
; 121  : #endif    //ENABLE_EQUALIZER
; 122  : 
; 123  :             if (pau->m_cChannel == 1)    {

  00428	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  0042b	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  0042f	83 fa 01	 cmp	 edx, 1
  00432	0f 85 93 00 00
	00		 jne	 $L2920

; 124  :                 TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));

  00438	8d 45 e8	 lea	 eax, DWORD PTR _iResult$[ebp]
  0043b	50		 push	 eax
  0043c	6a 01		 push	 1
  0043e	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00441	83 c1 30	 add	 ecx, 48			; 00000030H
  00444	51		 push	 ecx
  00445	e8 00 00 00 00	 call	 _ibstrmGetBits@12
  0044a	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0044d	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00451	7d 42		 jge	 SHORT $L2923
  00453	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00456	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  0045c	74 2c		 je	 SHORT $L3338
  0045e	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00461	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00467	74 21		 je	 SHORT $L3338
  00469	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0046c	51		 push	 ecx
  0046d	6a 7c		 push	 124			; 0000007cH
  0046f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00474	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00479	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0047c	52		 push	 edx
  0047d	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00482	83 c4 14	 add	 esp, 20			; 00000014H
  00485	89 45 90	 mov	 DWORD PTR tv255[ebp], eax
  00488	eb 06		 jmp	 SHORT $L3339
$L3338:
  0048a	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  0048d	89 45 90	 mov	 DWORD PTR tv255[ebp], eax
$L3339:
  00490	e9 d1 09 00 00	 jmp	 $exit$2898
$L2923:

; 125  :                 pau->m_rgpcinfo [0].m_iPower = iResult;

  00495	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  00498	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  0049e	8b 45 e8	 mov	 eax, DWORD PTR _iResult$[ebp]
  004a1	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 126  : 
; 127  :                 COUNT_BITS(*piBitCnt, 1);

  004a4	8b 4d 0c	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  004a7	8b 11		 mov	 edx, DWORD PTR [ecx]
  004a9	83 c2 01	 add	 edx, 1
  004ac	8b 45 0c	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  004af	89 10		 mov	 DWORD PTR [eax], edx

; 128  :                 fSkipAll = (pau->m_rgpcinfo [0].m_iPower == 0);

  004b1	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  004b4	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  004ba	33 c0		 xor	 eax, eax
  004bc	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  004c0	0f 94 c0	 sete	 al
  004c3	89 45 d8	 mov	 DWORD PTR _fSkipAll$[ebp], eax

; 129  : 
; 130  : #ifdef TRANSCODER
; 131  :                 if (TT_SIMPLE == pau->m_ttTranscodeType)
; 132  :                 {
; 133  :                    TRACEWMA_RET(wmaResult, coefstrmRecordCoefs(pau->m_rgpcinfo[0].
; 134  :                        m_pcstrmPower, &iResult, 1));
; 135  :                    TRACEWMA_RET(wmaResult, coefstrmRecordDone(pau->m_rgpcinfo[0].
; 136  :                        m_pcstrmPower));
; 137  :                 }
; 138  : #endif  // TRANSCODER
; 139  : 
; 140  :             }
; 141  : 	        else if (pau->m_cChannel == 2)	{

  004c6	e9 c6 01 00 00	 jmp	 $L2924
$L2920:
  004cb	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  004ce	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  004d2	83 fa 02	 cmp	 edx, 2
  004d5	0f 85 b6 01 00
	00		 jne	 $L2924

; 142  :                 TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));

  004db	8d 45 e8	 lea	 eax, DWORD PTR _iResult$[ebp]
  004de	50		 push	 eax
  004df	6a 01		 push	 1
  004e1	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  004e4	83 c1 30	 add	 ecx, 48			; 00000030H
  004e7	51		 push	 ecx
  004e8	e8 00 00 00 00	 call	 _ibstrmGetBits@12
  004ed	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  004f0	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  004f4	7d 45		 jge	 SHORT $L2928
  004f6	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  004f9	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  004ff	74 2f		 je	 SHORT $L3340
  00501	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00504	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  0050a	74 24		 je	 SHORT $L3340
  0050c	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0050f	51		 push	 ecx
  00510	68 8e 00 00 00	 push	 142			; 0000008eH
  00515	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  0051a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0051f	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00522	52		 push	 edx
  00523	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00528	83 c4 14	 add	 esp, 20			; 00000014H
  0052b	89 45 8c	 mov	 DWORD PTR tv280[ebp], eax
  0052e	eb 06		 jmp	 SHORT $L3341
$L3340:
  00530	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00533	89 45 8c	 mov	 DWORD PTR tv280[ebp], eax
$L3341:
  00536	e9 2b 09 00 00	 jmp	 $exit$2898
$L2928:

; 143  : 		        pau->m_stereoMode = (StereoMode) iResult;

  0053b	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  0053e	8b 55 e8	 mov	 edx, DWORD PTR _iResult$[ebp]
  00541	89 91 38 03 00
	00		 mov	 DWORD PTR [ecx+824], edx

; 144  : 
; 145  :                 COUNT_BITS(*piBitCnt, 1);

  00547	8b 45 0c	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  0054a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0054c	83 c1 01	 add	 ecx, 1
  0054f	8b 55 0c	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  00552	89 0a		 mov	 DWORD PTR [edx], ecx

; 146  :                 TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));

  00554	8d 45 e8	 lea	 eax, DWORD PTR _iResult$[ebp]
  00557	50		 push	 eax
  00558	6a 01		 push	 1
  0055a	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0055d	83 c1 30	 add	 ecx, 48			; 00000030H
  00560	51		 push	 ecx
  00561	e8 00 00 00 00	 call	 _ibstrmGetBits@12
  00566	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00569	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  0056d	7d 45		 jge	 SHORT $L2932
  0056f	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00572	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  00578	74 2f		 je	 SHORT $L3342
  0057a	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  0057d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00583	74 24		 je	 SHORT $L3342
  00585	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00588	51		 push	 ecx
  00589	68 92 00 00 00	 push	 146			; 00000092H
  0058e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00593	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00598	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0059b	52		 push	 edx
  0059c	e8 00 00 00 00	 call	 _MyOutputDbgStr
  005a1	83 c4 14	 add	 esp, 20			; 00000014H
  005a4	89 45 88	 mov	 DWORD PTR tv297[ebp], eax
  005a7	eb 06		 jmp	 SHORT $L3343
$L3342:
  005a9	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  005ac	89 45 88	 mov	 DWORD PTR tv297[ebp], eax
$L3343:
  005af	e9 b2 08 00 00	 jmp	 $exit$2898
$L2932:

; 147  : 		        pau->m_rgpcinfo [0].m_iPower = iResult;

  005b4	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  005b7	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  005bd	8b 45 e8	 mov	 eax, DWORD PTR _iResult$[ebp]
  005c0	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 148  : 
; 149  :                 COUNT_BITS(*piBitCnt, 1);

  005c3	8b 4d 0c	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  005c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  005c8	83 c2 01	 add	 edx, 1
  005cb	8b 45 0c	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  005ce	89 10		 mov	 DWORD PTR [eax], edx

; 150  :                 TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));

  005d0	8d 4d e8	 lea	 ecx, DWORD PTR _iResult$[ebp]
  005d3	51		 push	 ecx
  005d4	6a 01		 push	 1
  005d6	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  005d9	83 c2 30	 add	 edx, 48			; 00000030H
  005dc	52		 push	 edx
  005dd	e8 00 00 00 00	 call	 _ibstrmGetBits@12
  005e2	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  005e5	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  005e9	7d 45		 jge	 SHORT $L2935
  005eb	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  005ee	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  005f4	74 2f		 je	 SHORT $L3344
  005f6	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  005f9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  005ff	74 24		 je	 SHORT $L3344
  00601	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00604	52		 push	 edx
  00605	68 96 00 00 00	 push	 150			; 00000096H
  0060a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  0060f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00614	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00617	50		 push	 eax
  00618	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0061d	83 c4 14	 add	 esp, 20			; 00000014H
  00620	89 45 84	 mov	 DWORD PTR tv315[ebp], eax
  00623	eb 06		 jmp	 SHORT $L3345
$L3344:
  00625	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00628	89 4d 84	 mov	 DWORD PTR tv315[ebp], ecx
$L3345:
  0062b	e9 36 08 00 00	 jmp	 $exit$2898
$L2935:

; 151  : 		        pau->m_rgpcinfo [1].m_iPower = iResult;

  00630	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00633	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  00639	8b 4d e8	 mov	 ecx, DWORD PTR _iResult$[ebp]
  0063c	89 88 94 00 00
	00		 mov	 DWORD PTR [eax+148], ecx

; 152  : 
; 153  :                 COUNT_BITS(*piBitCnt, 1);

  00642	8b 55 0c	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  00645	8b 02		 mov	 eax, DWORD PTR [edx]
  00647	83 c0 01	 add	 eax, 1
  0064a	8b 4d 0c	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  0064d	89 01		 mov	 DWORD PTR [ecx], eax

; 154  :                 fSkipAll = (pau->m_rgpcinfo [0].m_iPower == 0) & (pau->m_rgpcinfo [1].m_iPower == 0);

  0064f	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00652	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  00658	33 c9		 xor	 ecx, ecx
  0065a	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0065e	0f 94 c1	 sete	 cl
  00661	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00664	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  0066a	33 d2		 xor	 edx, edx
  0066c	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [eax+148], 0
  00673	0f 94 c2	 sete	 dl
  00676	23 ca		 and	 ecx, edx
  00678	89 4d d8	 mov	 DWORD PTR _fSkipAll$[ebp], ecx

; 155  :                 prvSetDetTable  (paudec,  pau->m_rgpcinfo + 1);

  0067b	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  0067e	8b 88 a0 03 00
	00		 mov	 ecx, DWORD PTR [eax+928]
  00684	83 c1 70	 add	 ecx, 112		; 00000070H
  00687	51		 push	 ecx
  00688	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0068b	52		 push	 edx
  0068c	e8 00 00 00 00	 call	 _prvSetDetTable_XDS@8
$L2924:

; 156  : 
; 157  : #ifdef TRANSCODER
; 158  :                 if (TT_SIMPLE == pau->m_ttTranscodeType)
; 159  :                 {
; 160  :                     PerChannelInfo *ppcinfo0 = &(pau->m_rgpcinfo[0]);
; 161  :                     PerChannelInfo *ppcinfo1 = &(pau->m_rgpcinfo[1]);
; 162  : 
; 163  :                     TRACEWMA_RET(wmaResult, coefstrmRecordCoefs(pau->m_pcstrmStereoMode,
; 164  :                         &pau->m_stereoMode, 1));
; 165  : 
; 166  :                     TRACEWMA_RET(wmaResult, coefstrmRecordCoefs(ppcinfo0->m_pcstrmPower,
; 167  :                         &ppcinfo0->m_iPower, 1));
; 168  : 
; 169  :                     TRACEWMA_RET(wmaResult, coefstrmRecordCoefs(ppcinfo1->m_pcstrmPower,
; 170  :                         &ppcinfo1->m_iPower, 1));
; 171  : 
; 172  :                     TRACEWMA_RET(wmaResult, coefstrmRecordDone(pau->m_pcstrmStereoMode));
; 173  :                     TRACEWMA_RET(wmaResult, coefstrmRecordDone(ppcinfo0->m_pcstrmPower));
; 174  :                     TRACEWMA_RET(wmaResult, coefstrmRecordDone(ppcinfo1->m_pcstrmPower));
; 175  :                 }
; 176  : #endif  // TRANSCODER
; 177  : 
; 178  :             }
; 179  :             pau->m_iQuantStepSize = MIN_QUANT; // shift it back by the minimum for decode or in case of exit

  00691	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  00694	c7 80 44 03 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+836], 1

; 180  :             if (fSkipAll) {

  0069e	83 7d d8 00	 cmp	 DWORD PTR _fSkipAll$[ebp], 0
  006a2	74 76		 je	 SHORT $L2936

; 181  : #               if defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
; 182  :                     // no bits will be read
; 183  :                     if (pau->m_iWeightingMode == LPC_MODE) 

  006a4	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  006a7	83 b9 34 03 00
	00 00		 cmp	 DWORD PTR [ecx+820], 0
  006ae	75 10		 jne	 SHORT $L2937

; 184  :                         TRACEWMA_EXIT(wmaResult, prvDecodeFrameHeaderLpc(paudec, (Int *)piBitCnt));

  006b0	8b 55 0c	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  006b3	52		 push	 edx
  006b4	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  006b7	50		 push	 eax
  006b8	e8 00 00 00 00	 call	 _prvDecodeFrameHeaderLpc_XDS@8
  006bd	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
$L2937:
  006c0	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  006c4	7d 45		 jge	 SHORT $L2941
  006c6	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  006c9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  006cf	74 2f		 je	 SHORT $L3346
  006d1	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  006d4	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  006da	74 24		 je	 SHORT $L3346
  006dc	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  006df	50		 push	 eax
  006e0	68 b8 00 00 00	 push	 184			; 000000b8H
  006e5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  006ea	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  006ef	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  006f2	51		 push	 ecx
  006f3	e8 00 00 00 00	 call	 _MyOutputDbgStr
  006f8	83 c4 14	 add	 esp, 20			; 00000014H
  006fb	89 45 80	 mov	 DWORD PTR tv350[ebp], eax
  006fe	eb 06		 jmp	 SHORT $L3347
$L3346:
  00700	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00703	89 55 80	 mov	 DWORD PTR tv350[ebp], edx
$L3347:
  00706	e9 5b 07 00 00	 jmp	 $exit$2898
$L2941:

; 185  : #               endif  // defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
; 186  :                 paudec->m_hdrdecsts = HDR_DONE;

  0070b	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0070e	c7 40 1c 06 00
	00 00		 mov	 DWORD PTR [eax+28], 6

; 187  : 
; 188  : #ifdef TRANSCODER
; 189  :                 if (TT_SIMPLE == pau->m_ttTranscodeType)
; 190  :                 {
; 191  :                     // *** TODO: Can probably avoid saving explicitly and implicitly set
; 192  :                     // after noticing fSkipAll condition on encoder side.
; 193  :                     TRACEWMA_EXIT(wmaResult, coefstrmRecordCoefs(pau->m_pcstrmQSteps,
; 194  :                         &pau->m_iQuantStepSize, 1));
; 195  :                     TRACEWMA_EXIT(wmaResult, coefstrmRecordDone(pau->m_pcstrmQSteps));
; 196  :                 }
; 197  : #endif  // TRANSCODER
; 198  : 
; 199  :                 goto exit;

  00715	e9 4c 07 00 00	 jmp	 $exit$2898
$L2936:

; 200  :             }
; 201  :             paudec->m_hdrdecsts = HDR_QUANT;

  0071a	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0071d	c7 41 1c 01 00
	00 00		 mov	 DWORD PTR [ecx+28], 1
$L2942:

; 202  : 
; 203  :         case HDR_QUANT:
; 204  :             TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, 3 * NUM_BITS_QUANTIZER));

  00724	6a 15		 push	 21			; 00000015H
  00726	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00729	83 c2 30	 add	 edx, 48			; 00000030H
  0072c	52		 push	 edx
  0072d	e8 00 00 00 00	 call	 _ibstrmLookForBits@8
  00732	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00735	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00739	7d 4b		 jge	 SHORT $L2947
  0073b	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  0073e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00744	74 32		 je	 SHORT $L3348
  00746	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00749	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  0074f	74 27		 je	 SHORT $L3348
  00751	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00754	52		 push	 edx
  00755	68 cc 00 00 00	 push	 204			; 000000ccH
  0075a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  0075f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00764	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00767	50		 push	 eax
  00768	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0076d	83 c4 14	 add	 esp, 20			; 00000014H
  00770	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv366[ebp], eax
  00776	eb 09		 jmp	 SHORT $L3349
$L3348:
  00778	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0077b	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv366[ebp], ecx
$L3349:
  00781	e9 e0 06 00 00	 jmp	 $exit$2898
$L2947:

; 205  :             while(1) {

  00786	ba 01 00 00 00	 mov	 edx, 1
  0078b	85 d2		 test	 edx, edx
  0078d	0f 84 b0 00 00
	00		 je	 $L2948

; 206  :                 Int iStepSize;
; 207  : 
; 208  :                 TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm,
; 209  :                     NUM_BITS_QUANTIZER, &iResult));

  00793	8d 45 e8	 lea	 eax, DWORD PTR _iResult$[ebp]
  00796	50		 push	 eax
  00797	6a 07		 push	 7
  00799	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0079c	83 c1 30	 add	 ecx, 48			; 00000030H
  0079f	51		 push	 ecx
  007a0	e8 00 00 00 00	 call	 _ibstrmGetBits@12
  007a5	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  007a8	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  007ac	7d 4b		 jge	 SHORT $L2952
  007ae	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  007b1	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  007b7	74 32		 je	 SHORT $L3350
  007b9	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  007bc	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  007c2	74 27		 je	 SHORT $L3350
  007c4	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  007c7	51		 push	 ecx
  007c8	68 d1 00 00 00	 push	 209			; 000000d1H
  007cd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  007d2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  007d7	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  007da	52		 push	 edx
  007db	e8 00 00 00 00	 call	 _MyOutputDbgStr
  007e0	83 c4 14	 add	 esp, 20			; 00000014H
  007e3	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv382[ebp], eax
  007e9	eb 09		 jmp	 SHORT $L3351
$L3350:
  007eb	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  007ee	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv382[ebp], eax
$L3351:
  007f4	e9 6d 06 00 00	 jmp	 $exit$2898
$L2952:

; 210  :                 iStepSize = iResult;

  007f9	8b 4d e8	 mov	 ecx, DWORD PTR _iResult$[ebp]
  007fc	89 4d cc	 mov	 DWORD PTR _iStepSize$2949[ebp], ecx

; 211  : 
; 212  :                 COUNT_BITS(*piBitCnt, NUM_BITS_QUANTIZER);

  007ff	8b 55 0c	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  00802	8b 02		 mov	 eax, DWORD PTR [edx]
  00804	83 c0 07	 add	 eax, 7
  00807	8b 4d 0c	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  0080a	89 01		 mov	 DWORD PTR [ecx], eax

; 213  :                 assert(iStepSize <= MSA_MAX_QUANT_ESC);
; 214  :                 DEBUG_TRACE_QUANT(pau->m_iFrameNumber, pau->m_iCurrSubFrame, iStepSize);
; 215  :                 if(iStepSize != MSA_MAX_QUANT_ESC) {

  0080c	83 7d cc 7f	 cmp	 DWORD PTR _iStepSize$2949[ebp], 127 ; 0000007fH
  00810	74 17		 je	 SHORT $L2953

; 216  :                     // the last one...
; 217  :                     pau->m_iQuantStepSize += iStepSize;

  00812	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00815	8b 82 44 03 00
	00		 mov	 eax, DWORD PTR [edx+836]
  0081b	03 45 cc	 add	 eax, DWORD PTR _iStepSize$2949[ebp]
  0081e	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  00821	89 81 44 03 00
	00		 mov	 DWORD PTR [ecx+836], eax

; 218  : 			        MONITOR_RANGE(gMR_iQuantStepSize,pau->m_iQuantStepSize);
; 219  :                     break;

  00827	eb 1a		 jmp	 SHORT $L2948
$L2953:

; 220  :                 }
; 221  :                 // escape code, so on to the next level...
; 222  :                 pau->m_iQuantStepSize += MSA_MAX_QUANT_ESC;

  00829	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  0082c	8b 82 44 03 00
	00		 mov	 eax, DWORD PTR [edx+836]
  00832	83 c0 7f	 add	 eax, 127		; 0000007fH
  00835	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  00838	89 81 44 03 00
	00		 mov	 DWORD PTR [ecx+836], eax

; 223  :             }

  0083e	e9 43 ff ff ff	 jmp	 $L2947
$L2948:

; 224  :             auUpdateMaxEsc(pau, pau->m_iQuantStepSize);

  00843	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00846	8b 82 44 03 00
	00		 mov	 eax, DWORD PTR [edx+836]
  0084c	50		 push	 eax
  0084d	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  00850	51		 push	 ecx
  00851	e8 00 00 00 00	 call	 _auUpdateMaxEsc_XDS@8

; 225  : 
; 226  : #ifdef TRANSCODER
; 227  :             if (TT_SIMPLE == pau->m_ttTranscodeType)
; 228  :             {
; 229  :                 TRACEWMA_EXIT(wmaResult, coefstrmRecordCoefs(pau->m_pcstrmQSteps,
; 230  :                     &pau->m_iQuantStepSize, 1));
; 231  :                 TRACEWMA_EXIT(wmaResult, coefstrmRecordDone(pau->m_pcstrmQSteps));
; 232  :             }
; 233  : #endif  // TRANSCODER
; 234  :             
; 235  :             *piChannel  = 0;

  00856	8b 55 ec	 mov	 edx, DWORD PTR _piChannel$[ebp]
  00859	66 c7 02 00 00	 mov	 WORD PTR [edx], 0

; 236  : #ifdef ENABLE_ALL_ENCOPT
; 237  :             paudec->m_iBand     = (I16) pau->m_iFirstNoiseBand;;

  0085e	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00861	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  00864	66 8b 91 c0 03
	00 00		 mov	 dx, WORD PTR [ecx+960]
  0086b	66 89 50 26	 mov	 WORD PTR [eax+38], dx

; 238  : #endif // ENABLE_ALL_ENCOPT
; 239  :             paudec->m_hdrdecsts = HDR_NOISE1;

  0086f	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00872	c7 40 1c 02 00
	00 00		 mov	 DWORD PTR [eax+28], 2
$L2955:

; 240  : 
; 241  :         case HDR_NOISE1 :
; 242  :         case HDR_NOISE2 :
; 243  : #           ifdef ENABLE_ALL_ENCOPT
; 244  :             if (pau->m_fNoiseSub == WMAB_TRUE)

  00879	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  0087c	83 79 30 01	 cmp	 DWORD PTR [ecx+48], 1
  00880	75 61		 jne	 SHORT $L2956

; 245  :             {
; 246  :                 TRACEWMA_EXIT(wmaResult, prvDecodeFrameHeaderNoiseSub(paudec, (Int *)piBitCnt));

  00882	8b 55 0c	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  00885	52		 push	 edx
  00886	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00889	50		 push	 eax
  0088a	e8 00 00 00 00	 call	 _prvDecodeFrameHeaderNoiseSub_XDS@8
  0088f	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00892	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00896	7d 4b		 jge	 SHORT $L2956
  00898	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0089b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  008a1	74 32		 je	 SHORT $L3352
  008a3	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  008a6	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  008ac	74 27		 je	 SHORT $L3352
  008ae	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  008b1	50		 push	 eax
  008b2	68 f6 00 00 00	 push	 246			; 000000f6H
  008b7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  008bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  008c1	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  008c4	51		 push	 ecx
  008c5	e8 00 00 00 00	 call	 _MyOutputDbgStr
  008ca	83 c4 14	 add	 esp, 20			; 00000014H
  008cd	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv411[ebp], eax
  008d3	eb 09		 jmp	 SHORT $L3353
$L3352:
  008d5	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  008d8	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv411[ebp], edx
$L3353:
  008de	e9 83 05 00 00	 jmp	 $exit$2898
$L2956:

; 247  :             }
; 248  : #           endif //ENABLE_ALL_ENCOPT
; 249  :             paudec->m_hdrdecsts = HDR_MSKUPD;

  008e3	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  008e6	c7 40 1c 04 00
	00 00		 mov	 DWORD PTR [eax+28], 4
$L2961:

; 250  : 
; 251  :         case HDR_MSKUPD :
; 252  : 
; 253  :             TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, 1));

  008ed	6a 01		 push	 1
  008ef	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  008f2	83 c1 30	 add	 ecx, 48			; 00000030H
  008f5	51		 push	 ecx
  008f6	e8 00 00 00 00	 call	 _ibstrmLookForBits@8
  008fb	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  008fe	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00902	7d 4b		 jge	 SHORT $L2964
  00904	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00907	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  0090d	74 32		 je	 SHORT $L3354
  0090f	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00912	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00918	74 27		 je	 SHORT $L3354
  0091a	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0091d	51		 push	 ecx
  0091e	68 fd 00 00 00	 push	 253			; 000000fdH
  00923	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00928	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0092d	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00930	52		 push	 edx
  00931	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00936	83 c4 14	 add	 esp, 20			; 00000014H
  00939	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv426[ebp], eax
  0093f	eb 09		 jmp	 SHORT $L3355
$L3354:
  00941	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00944	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv426[ebp], eax
$L3355:
  0094a	e9 17 05 00 00	 jmp	 $exit$2898
$L2964:

; 254  :             //Setup the pointer to the quantized coefficents. This must be done after 
; 255  :             //prvDecodeFrameHeaderNoiseSub since it changes the value of m_cSubbandActual
; 256  :             ppcinfo = pau->m_rgpcinfo;

  0094f	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  00952	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  00958	89 55 e4	 mov	 DWORD PTR _ppcinfo$[ebp], edx

; 257  :             ppcinfo->m_rgiCoefQ       = ((I16*) (pau->m_rgiCoefReconOrig + DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf)))  
; 258  :                                       - DOUBLE(pau->m_fPad2XTransform,ppcinfo->m_cSubbandActual);

  0095b	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  0095e	8b 88 1c 03 00
	00		 mov	 ecx, DWORD PTR [eax+796]
  00964	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00967	8b 82 a4 03 00
	00		 mov	 eax, DWORD PTR [edx+932]
  0096d	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00970	8b 55 e4	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00973	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00976	d1 e0		 shl	 eax, 1
  00978	2b c8		 sub	 ecx, eax
  0097a	8b 55 e4	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  0097d	89 0a		 mov	 DWORD PTR [edx], ecx

; 259  :             memset (ppcinfo->m_rgiCoefQ, 0,  sizeof (I16) * DOUBLE(pau->m_fPad2XTransform,ppcinfo->m_cSubbandActual));

  0097f	8b 45 e4	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00982	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00985	d1 e1		 shl	 ecx, 1
  00987	51		 push	 ecx
  00988	6a 00		 push	 0
  0098a	8b 55 e4	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  0098d	8b 02		 mov	 eax, DWORD PTR [edx]
  0098f	50		 push	 eax
  00990	e8 00 00 00 00	 call	 _memset
  00995	83 c4 0c	 add	 esp, 12			; 0000000cH

; 260  :             if (pau->m_cChannel == 2)   {

  00998	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  0099b	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  0099f	83 fa 02	 cmp	 edx, 2
  009a2	75 4e		 jne	 SHORT $L2967

; 261  :                 ppcinfo = pau->m_rgpcinfo + 1;

  009a4	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  009a7	8b 88 a0 03 00
	00		 mov	 ecx, DWORD PTR [eax+928]
  009ad	83 c1 70	 add	 ecx, 112		; 00000070H
  009b0	89 4d e4	 mov	 DWORD PTR _ppcinfo$[ebp], ecx

; 262  :                 ppcinfo->m_rgiCoefQ       = ((I16*) (pau->m_rgiCoefReconOrig + DOUBLE(pau->m_fPad2XTransform, 2 * pau->m_cFrameSampleHalf)))
; 263  :                                           - DOUBLE(pau->m_fPad2XTransform,ppcinfo->m_cSubbandActual);

  009b3	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  009b6	8b 82 1c 03 00
	00		 mov	 eax, DWORD PTR [edx+796]
  009bc	d1 e0		 shl	 eax, 1
  009be	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  009c1	8b 91 a4 03 00
	00		 mov	 edx, DWORD PTR [ecx+932]
  009c7	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  009ca	8b 4d e4	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  009cd	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  009d0	d1 e2		 shl	 edx, 1
  009d2	2b c2		 sub	 eax, edx
  009d4	8b 4d e4	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  009d7	89 01		 mov	 DWORD PTR [ecx], eax

; 264  :                 memset (ppcinfo->m_rgiCoefQ, 0,  sizeof (I16) * DOUBLE(pau->m_fPad2XTransform,ppcinfo->m_cSubbandActual));

  009d9	8b 55 e4	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  009dc	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  009df	d1 e0		 shl	 eax, 1
  009e1	50		 push	 eax
  009e2	6a 00		 push	 0
  009e4	8b 4d e4	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  009e7	8b 11		 mov	 edx, DWORD PTR [ecx]
  009e9	52		 push	 edx
  009ea	e8 00 00 00 00	 call	 _memset
  009ef	83 c4 0c	 add	 esp, 12			; 0000000cH
$L2967:

; 265  :             }
; 266  : 
; 267  :             fUpdateMask = &(pau->m_subfrmconfigCurr.m_rgfMaskUpdate [pau->m_iCurrSubFrame]);

  009f2	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  009f5	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  009f8	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  009fb	8d 84 8a 04 02
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+516]
  00a02	89 45 f8	 mov	 DWORD PTR _fUpdateMask$[ebp], eax

; 268  :             *fUpdateMask = WMAB_TRUE;

  00a05	8b 4d f8	 mov	 ecx, DWORD PTR _fUpdateMask$[ebp]
  00a08	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 269  :             if (pau->m_fAllowSubFrame && pau->m_subfrmconfigCurr.m_cSubFrame > 1) {

  00a0e	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00a11	83 7a 68 00	 cmp	 DWORD PTR [edx+104], 0
  00a15	0f 84 87 00 00
	00		 je	 $L2970
  00a1b	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  00a1e	83 b8 74 01 00
	00 01		 cmp	 DWORD PTR [eax+372], 1
  00a25	7e 7b		 jle	 SHORT $L2970

; 270  :                 TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));

  00a27	8d 4d e8	 lea	 ecx, DWORD PTR _iResult$[ebp]
  00a2a	51		 push	 ecx
  00a2b	6a 01		 push	 1
  00a2d	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00a30	83 c2 30	 add	 edx, 48			; 00000030H
  00a33	52		 push	 edx
  00a34	e8 00 00 00 00	 call	 _ibstrmGetBits@12
  00a39	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00a3c	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00a40	7d 4b		 jge	 SHORT $L2973
  00a42	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00a45	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00a4b	74 32		 je	 SHORT $L3356
  00a4d	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00a50	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  00a56	74 27		 je	 SHORT $L3356
  00a58	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00a5b	52		 push	 edx
  00a5c	68 0e 01 00 00	 push	 270			; 0000010eH
  00a61	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00a66	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00a6b	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00a6e	50		 push	 eax
  00a6f	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00a74	83 c4 14	 add	 esp, 20			; 00000014H
  00a77	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv480[ebp], eax
  00a7d	eb 09		 jmp	 SHORT $L3357
$L3356:
  00a7f	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00a82	89 8d 6c ff ff
	ff		 mov	 DWORD PTR tv480[ebp], ecx
$L3357:
  00a88	e9 d9 03 00 00	 jmp	 $exit$2898
$L2973:

; 271  :                 *fUpdateMask = iResult;

  00a8d	8b 55 f8	 mov	 edx, DWORD PTR _fUpdateMask$[ebp]
  00a90	8b 45 e8	 mov	 eax, DWORD PTR _iResult$[ebp]
  00a93	89 02		 mov	 DWORD PTR [edx], eax

; 272  :                 (*piBitCnt)++;

  00a95	8b 4d 0c	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  00a98	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a9a	83 c2 01	 add	 edx, 1
  00a9d	8b 45 0c	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  00aa0	89 10		 mov	 DWORD PTR [eax], edx
$L2970:

; 273  :             }
; 274  :             *piChannel = 0;

  00aa2	8b 4d ec	 mov	 ecx, DWORD PTR _piChannel$[ebp]
  00aa5	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0

; 275  :             paudec->m_iBand = 0;

  00aaa	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00aad	66 c7 42 26 00
	00		 mov	 WORD PTR [edx+38], 0

; 276  :             paudec->m_hdrdecsts = HDR_BARK;

  00ab3	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00ab6	c7 40 1c 05 00
	00 00		 mov	 DWORD PTR [eax+28], 5
$L2974:

; 277  : 
; 278  :         case HDR_BARK :
; 279  :             fUpdateMask = &(pau->m_subfrmconfigCurr.m_rgfMaskUpdate [pau->m_iCurrSubFrame]);

  00abd	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  00ac0	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00ac3	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  00ac6	8d 8c 90 04 02
	00 00		 lea	 ecx, DWORD PTR [eax+edx*4+516]
  00acd	89 4d f8	 mov	 DWORD PTR _fUpdateMask$[ebp], ecx

; 280  :             if (pau->m_iWeightingMode == BARK_MODE) 

  00ad0	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00ad3	83 ba 34 03 00
	00 01		 cmp	 DWORD PTR [edx+820], 1
  00ada	0f 85 0c 03 00
	00		 jne	 $L2975

; 281  :             {
; 282  :                 for (; *piChannel < pau->m_cChannel; (*piChannel)++)

  00ae0	eb 10		 jmp	 SHORT $L2976
$L2977:
  00ae2	8b 45 ec	 mov	 eax, DWORD PTR _piChannel$[ebp]
  00ae5	66 8b 08	 mov	 cx, WORD PTR [eax]
  00ae8	66 83 c1 01	 add	 cx, 1
  00aec	8b 55 ec	 mov	 edx, DWORD PTR _piChannel$[ebp]
  00aef	66 89 0a	 mov	 WORD PTR [edx], cx
$L2976:
  00af2	8b 45 ec	 mov	 eax, DWORD PTR _piChannel$[ebp]
  00af5	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00af8	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00afb	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  00aff	3b c8		 cmp	 ecx, eax
  00b01	0f 8d e3 02 00
	00		 jge	 $L2978

; 283  :                 {
; 284  :                     PerChannelInfo *ppcinfo = pau->m_rgpcinfo + *piChannel;

  00b07	8b 4d ec	 mov	 ecx, DWORD PTR _piChannel$[ebp]
  00b0a	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00b0d	6b d2 70	 imul	 edx, 112		; 00000070H
  00b10	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  00b13	03 90 a0 03 00
	00		 add	 edx, DWORD PTR [eax+928]
  00b19	89 55 c8	 mov	 DWORD PTR _ppcinfo$2979[ebp], edx

; 285  :                     if (ppcinfo->m_iPower != 0) 

  00b1c	8b 4d c8	 mov	 ecx, DWORD PTR _ppcinfo$2979[ebp]
  00b1f	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00b23	0f 84 8c 02 00
	00		 je	 $L2980

; 286  :                     {
; 287  :                         Int* rgiMaskQ = ppcinfo->m_rgiMaskQ;

  00b29	8b 55 c8	 mov	 edx, DWORD PTR _ppcinfo$2979[ebp]
  00b2c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00b2f	89 45 c4	 mov	 DWORD PTR _rgiMaskQ$2981[ebp], eax

; 288  :                         if (*fUpdateMask == WMAB_TRUE)    

  00b32	8b 4d f8	 mov	 ecx, DWORD PTR _fUpdateMask$[ebp]
  00b35	83 39 01	 cmp	 DWORD PTR [ecx], 1
  00b38	0f 85 1b 02 00
	00		 jne	 $L2982

; 289  :                         {
; 290  :                             if (pau->m_iVersion == 1) {

  00b3e	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00b41	83 7a 44 01	 cmp	 DWORD PTR [edx+68], 1
  00b45	0f 85 90 00 00
	00		 jne	 $L2983

; 291  :                                 TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm,
; 292  :                                     NBITS_FIRST_MASKQUANT, &iResult));

  00b4b	8d 45 e8	 lea	 eax, DWORD PTR _iResult$[ebp]
  00b4e	50		 push	 eax
  00b4f	6a 05		 push	 5
  00b51	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00b54	83 c1 30	 add	 ecx, 48			; 00000030H
  00b57	51		 push	 ecx
  00b58	e8 00 00 00 00	 call	 _ibstrmGetBits@12
  00b5d	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00b60	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00b64	7d 4b		 jge	 SHORT $L2986
  00b66	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00b69	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  00b6f	74 32		 je	 SHORT $L3358
  00b71	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00b74	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00b7a	74 27		 je	 SHORT $L3358
  00b7c	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00b7f	51		 push	 ecx
  00b80	68 24 01 00 00	 push	 292			; 00000124H
  00b85	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00b8a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00b8f	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00b92	52		 push	 edx
  00b93	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00b98	83 c4 14	 add	 esp, 20			; 00000014H
  00b9b	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv519[ebp], eax
  00ba1	eb 09		 jmp	 SHORT $L3359
$L3358:
  00ba3	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00ba6	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv519[ebp], eax
$L3359:
  00bac	e9 b5 02 00 00	 jmp	 $exit$2898
$L2986:

; 293  : 	                            rgiMaskQ [0] = iResult + MIN_MASKQ_IN_DB_V1;

  00bb1	8b 4d e8	 mov	 ecx, DWORD PTR _iResult$[ebp]
  00bb4	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00bb7	8b 55 c4	 mov	 edx, DWORD PTR _rgiMaskQ$2981[ebp]
  00bba	89 0a		 mov	 DWORD PTR [edx], ecx

; 294  : 
; 295  : #ifdef TRANSCODER
; 296  :                                 if (TT_SIMPLE == pau->m_ttTranscodeType)
; 297  :                                 {
; 298  :                                     TRACEWMA_EXIT(wmaResult,
; 299  :                                         coefstrmRecordCoefs(ppcinfo->m_pcstrmMaskQ,
; 300  :                                         &rgiMaskQ[0], 1));
; 301  :                                 }
; 302  : #endif  // TRANSCODER
; 303  : 
; 304  :                                 *piBitCnt += NBITS_FIRST_MASKQUANT;

  00bbc	8b 45 0c	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  00bbf	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bc1	83 c1 05	 add	 ecx, 5
  00bc4	8b 55 0c	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  00bc7	89 0a		 mov	 DWORD PTR [edx], ecx

; 305  :                                 paudec->m_iBand++;

  00bc9	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00bcc	66 8b 48 26	 mov	 cx, WORD PTR [eax+38]
  00bd0	66 83 c1 01	 add	 cx, 1
  00bd4	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00bd7	66 89 4a 26	 mov	 WORD PTR [edx+38], cx
$L2983:

; 306  :                             }
; 307  : 
; 308  :                             for (; paudec->m_iBand < pau->m_cValidBarkBand; paudec->m_iBand++)	

  00bdb	eb 12		 jmp	 SHORT $L2988
$L2989:
  00bdd	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00be0	66 8b 48 26	 mov	 cx, WORD PTR [eax+38]
  00be4	66 83 c1 01	 add	 cx, 1
  00be8	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00beb	66 89 4a 26	 mov	 WORD PTR [edx+38], cx
$L2988:
  00bef	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00bf2	0f bf 48 26	 movsx	 ecx, WORD PTR [eax+38]
  00bf6	8b 55 f0	 mov	 edx, DWORD PTR _pau$[ebp]
  00bf9	3b 8a 50 03 00
	00		 cmp	 ecx, DWORD PTR [edx+848]
  00bff	0f 8d 35 01 00
	00		 jge	 $L2990

; 309  :                             {
; 310  : 				                Int iDiff;                        
; 311  :                                 TRACEWMA_EXIT(wmaResult, huffDecGet (g_rgiHuffDecTblMsk,
; 312  :                                     &paudec->m_ibstrm, &iResult, (unsigned long *)&iDiff, (unsigned long *)0));

  00c05	6a 00		 push	 0
  00c07	8d 45 c0	 lea	 eax, DWORD PTR _iDiff$2991[ebp]
  00c0a	50		 push	 eax
  00c0b	8d 4d e8	 lea	 ecx, DWORD PTR _iResult$[ebp]
  00c0e	51		 push	 ecx
  00c0f	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00c12	83 c2 30	 add	 edx, 48			; 00000030H
  00c15	52		 push	 edx
  00c16	68 00 00 00 00	 push	 OFFSET FLAT:_g_rgiHuffDecTblMsk
  00c1b	e8 00 00 00 00	 call	 _huffDecGet@20
  00c20	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00c23	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00c27	7d 4b		 jge	 SHORT $L2996
  00c29	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00c2c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00c32	74 32		 je	 SHORT $L3360
  00c34	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00c37	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  00c3d	74 27		 je	 SHORT $L3360
  00c3f	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00c42	52		 push	 edx
  00c43	68 38 01 00 00	 push	 312			; 00000138H
  00c48	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00c4d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00c52	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00c55	50		 push	 eax
  00c56	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00c5b	83 c4 14	 add	 esp, 20			; 00000014H
  00c5e	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv550[ebp], eax
  00c64	eb 09		 jmp	 SHORT $L3361
$L3360:
  00c66	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00c69	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv550[ebp], ecx
$L3361:
  00c6f	e9 f2 01 00 00	 jmp	 $exit$2898
$L2996:

; 313  :                                 COUNT_BITS(*piBitCnt, iResult);

  00c74	8b 55 0c	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  00c77	8b 02		 mov	 eax, DWORD PTR [edx]
  00c79	03 45 e8	 add	 eax, DWORD PTR _iResult$[ebp]
  00c7c	8b 4d 0c	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  00c7f	89 01		 mov	 DWORD PTR [ecx], eax

; 314  :                                 TRACEWMA_EXIT(wmaResult, ibstrmFlushBits(&paudec->m_ibstrm, iResult));   //flush bits used by huffDecGet

  00c81	8b 55 e8	 mov	 edx, DWORD PTR _iResult$[ebp]
  00c84	52		 push	 edx
  00c85	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00c88	83 c0 30	 add	 eax, 48			; 00000030H
  00c8b	50		 push	 eax
  00c8c	e8 00 00 00 00	 call	 _ibstrmFlushBits@8
  00c91	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00c94	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00c98	7d 4b		 jge	 SHORT $L2999
  00c9a	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00c9d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  00ca3	74 32		 je	 SHORT $L3362
  00ca5	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00ca8	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  00cae	74 27		 je	 SHORT $L3362
  00cb0	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00cb3	50		 push	 eax
  00cb4	68 3a 01 00 00	 push	 314			; 0000013aH
  00cb9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00cbe	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00cc3	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00cc6	51		 push	 ecx
  00cc7	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00ccc	83 c4 14	 add	 esp, 20			; 00000014H
  00ccf	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv565[ebp], eax
  00cd5	eb 09		 jmp	 SHORT $L3363
$L3362:
  00cd7	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00cda	89 95 60 ff ff
	ff		 mov	 DWORD PTR tv565[ebp], edx
$L3363:
  00ce0	e9 81 01 00 00	 jmp	 $exit$2898
$L2999:

; 315  :                                 iDiff -= MAX_MASKQUANT_DIFF;

  00ce5	8b 45 c0	 mov	 eax, DWORD PTR _iDiff$2991[ebp]
  00ce8	83 e8 3c	 sub	 eax, 60			; 0000003cH
  00ceb	89 45 c0	 mov	 DWORD PTR _iDiff$2991[ebp], eax

; 316  :                                 assert (iDiff >= -MAX_MASKQUANT_DIFF);
; 317  :                                 iMaskQPrev = (paudec->m_iBand == 0) ? 
; 318  :                                               FIRST_V2_MASKQUANT : rgiMaskQ [paudec->m_iBand - 1];

  00cee	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00cf1	0f bf 51 26	 movsx	 edx, WORD PTR [ecx+38]
  00cf5	85 d2		 test	 edx, edx
  00cf7	75 0c		 jne	 SHORT $L3364
  00cf9	c7 85 5c ff ff
	ff 24 00 00 00	 mov	 DWORD PTR tv575[ebp], 36 ; 00000024H
  00d03	eb 14		 jmp	 SHORT $L3365
$L3364:
  00d05	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00d08	0f bf 48 26	 movsx	 ecx, WORD PTR [eax+38]
  00d0c	8b 55 c4	 mov	 edx, DWORD PTR _rgiMaskQ$2981[ebp]
  00d0f	8b 44 8a fc	 mov	 eax, DWORD PTR [edx+ecx*4-4]
  00d13	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv575[ebp], eax
$L3365:
  00d19	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR tv575[ebp]
  00d1f	89 4d dc	 mov	 DWORD PTR _iMaskQPrev$[ebp], ecx

; 319  : 				                rgiMaskQ [paudec->m_iBand] = iDiff + iMaskQPrev;

  00d22	8b 55 c0	 mov	 edx, DWORD PTR _iDiff$2991[ebp]
  00d25	03 55 dc	 add	 edx, DWORD PTR _iMaskQPrev$[ebp]
  00d28	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00d2b	0f bf 48 26	 movsx	 ecx, WORD PTR [eax+38]
  00d2f	8b 45 c4	 mov	 eax, DWORD PTR _rgiMaskQ$2981[ebp]
  00d32	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx

; 320  : 						        MONITOR_RANGE(gMR_rgiMaskQ, rgiMaskQ[paudec->m_iBand]);
; 321  : 
; 322  : #ifdef TRANSCODER
; 323  :                                 if (TT_SIMPLE == pau->m_ttTranscodeType)
; 324  :                                 {
; 325  :                                     TRACEWMA_EXIT(wmaResult,
; 326  :                                         coefstrmRecordCoefs(ppcinfo->m_pcstrmMaskQ,
; 327  :                                         &rgiMaskQ[paudec->m_iBand], 1));
; 328  :                                 }
; 329  : #endif  // TRANSCODER
; 330  : 
; 331  :                             }

  00d35	e9 a3 fe ff ff	 jmp	 $L2989
$L2990:

; 332  :                             pau->m_iSubFrameSizeWithUpdate = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];

  00d3a	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  00d3d	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00d40	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  00d43	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  00d46	8b 94 91 78 01
	00 00		 mov	 edx, DWORD PTR [ecx+edx*4+376]
  00d4d	89 50 7c	 mov	 DWORD PTR [eax+124], edx

; 333  :                             paudec->m_iBand = 0;

  00d50	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00d53	66 c7 40 26 00
	00		 mov	 WORD PTR [eax+38], 0
$L2982:

; 334  : 
; 335  : #ifdef TRANSCODER
; 336  :                             if (TT_SIMPLE == pau->m_ttTranscodeType)
; 337  :                                 TRACEWMA_EXIT(wmaResult, coefstrmRecordDone(ppcinfo->m_pcstrmMaskQ));
; 338  : #endif  // TRANSCODER
; 339  :                         }
; 340  : 
; 341  :                         //for IntFloat this gets done inside ReconWeightFactor()
; 342  :                         //Scan For Max Weight
; 343  :                         if (*fUpdateMask)

  00d59	8b 4d f8	 mov	 ecx, DWORD PTR _fUpdateMask$[ebp]
  00d5c	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00d5f	74 52		 je	 SHORT $L3000

; 344  :                         {
; 345  : 					        Int iMax = rgiMaskQ[0];

  00d61	8b 55 c4	 mov	 edx, DWORD PTR _rgiMaskQ$2981[ebp]
  00d64	8b 02		 mov	 eax, DWORD PTR [edx]
  00d66	89 45 b8	 mov	 DWORD PTR _iMax$3001[ebp], eax

; 346  :                             I16 iBand;
; 347  :                             for (iBand = 1; iBand < pau->m_cValidBarkBand; iBand++)

  00d69	66 c7 45 bc 01
	00		 mov	 WORD PTR _iBand$3002[ebp], 1
  00d6f	eb 0c		 jmp	 SHORT $L3003
$L3004:
  00d71	66 8b 4d bc	 mov	 cx, WORD PTR _iBand$3002[ebp]
  00d75	66 83 c1 01	 add	 cx, 1
  00d79	66 89 4d bc	 mov	 WORD PTR _iBand$3002[ebp], cx
$L3003:
  00d7d	0f bf 55 bc	 movsx	 edx, WORD PTR _iBand$3002[ebp]
  00d81	8b 45 f0	 mov	 eax, DWORD PTR _pau$[ebp]
  00d84	3b 90 50 03 00
	00		 cmp	 edx, DWORD PTR [eax+848]
  00d8a	7d 1e		 jge	 SHORT $L3005

; 348  :                             {
; 349  :                                 if (rgiMaskQ[iBand] > iMax)

  00d8c	0f bf 4d bc	 movsx	 ecx, WORD PTR _iBand$3002[ebp]
  00d90	8b 55 c4	 mov	 edx, DWORD PTR _rgiMaskQ$2981[ebp]
  00d93	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00d96	3b 45 b8	 cmp	 eax, DWORD PTR _iMax$3001[ebp]
  00d99	7e 0d		 jle	 SHORT $L3006

; 350  : 							        iMax = rgiMaskQ[iBand];

  00d9b	0f bf 4d bc	 movsx	 ecx, WORD PTR _iBand$3002[ebp]
  00d9f	8b 55 c4	 mov	 edx, DWORD PTR _rgiMaskQ$2981[ebp]
  00da2	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00da5	89 45 b8	 mov	 DWORD PTR _iMax$3001[ebp], eax
$L3006:

; 351  :                             }

  00da8	eb c7		 jmp	 SHORT $L3004
$L3005:

; 352  : 					        ppcinfo->m_iMaxMaskQ = iMax;

  00daa	8b 4d c8	 mov	 ecx, DWORD PTR _ppcinfo$2979[ebp]
  00dad	8b 55 b8	 mov	 edx, DWORD PTR _iMax$3001[ebp]
  00db0	89 51 34	 mov	 DWORD PTR [ecx+52], edx
$L3000:

; 353  :                         }
; 354  :                     }
; 355  :                     else if (*fUpdateMask == WMAB_TRUE)    

  00db3	eb 30		 jmp	 SHORT $L3007
$L2980:
  00db5	8b 45 f8	 mov	 eax, DWORD PTR _fUpdateMask$[ebp]
  00db8	83 38 01	 cmp	 DWORD PTR [eax], 1
  00dbb	75 28		 jne	 SHORT $L3007

; 356  :                     {	//else artifically set to constants since nothing got sent; see comments in msaudioenc.c
; 357  : 				        //0 db = 1.0 for weightfactor
; 358  : 				        memset( ppcinfo->m_rgiMaskQ, 0, pau->m_cValidBarkBand*sizeof(Int) );

  00dbd	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  00dc0	8b 91 50 03 00
	00		 mov	 edx, DWORD PTR [ecx+848]
  00dc6	c1 e2 02	 shl	 edx, 2
  00dc9	52		 push	 edx
  00dca	6a 00		 push	 0
  00dcc	8b 45 c8	 mov	 eax, DWORD PTR _ppcinfo$2979[ebp]
  00dcf	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00dd2	51		 push	 ecx
  00dd3	e8 00 00 00 00	 call	 _memset
  00dd8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 359  :                         ppcinfo->m_iMaxMaskQ = 0;

  00ddb	8b 55 c8	 mov	 edx, DWORD PTR _ppcinfo$2979[ebp]
  00dde	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0
$L3007:

; 360  : 			        }
; 361  :                 }

  00de5	e9 f8 fc ff ff	 jmp	 $L2977
$L2978:

; 362  :             }
; 363  : #if defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
; 364  :             else 

  00dea	eb 70		 jmp	 SHORT $L2886
$L2975:

; 365  :             {
; 366  :                 TRACEWMA_EXIT(wmaResult, prvDecodeFrameHeaderLpc(paudec, (Int *)piBitCnt));

  00dec	8b 45 0c	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  00def	50		 push	 eax
  00df0	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00df3	51		 push	 ecx
  00df4	e8 00 00 00 00	 call	 _prvDecodeFrameHeaderLpc_XDS@8
  00df9	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00dfc	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00e00	7d 48		 jge	 SHORT $L3014
  00e02	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00e05	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  00e0b	74 32		 je	 SHORT $L3366
  00e0d	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00e10	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00e16	74 27		 je	 SHORT $L3366
  00e18	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00e1b	51		 push	 ecx
  00e1c	68 6e 01 00 00	 push	 366			; 0000016eH
  00e21	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00e26	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00e2b	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00e2e	52		 push	 edx
  00e2f	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00e34	83 c4 14	 add	 esp, 20			; 00000014H
  00e37	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv620[ebp], eax
  00e3d	eb 09		 jmp	 SHORT $L3367
$L3366:
  00e3f	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00e42	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv620[ebp], eax
$L3367:
  00e48	eb 1c		 jmp	 SHORT $exit$2898
$L3014:

; 367  : 		        if (pau->m_fNoiseSub == WMAB_TRUE)	

  00e4a	8b 4d f0	 mov	 ecx, DWORD PTR _pau$[ebp]
  00e4d	83 79 30 01	 cmp	 DWORD PTR [ecx+48], 1
  00e51	75 09		 jne	 SHORT $L2886

; 368  : 			        prvGetBandWeightLowRate (paudec);

  00e53	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00e56	52		 push	 edx
  00e57	e8 00 00 00 00	 call	 _prvGetBandWeightLowRate_XDS@4
$L2886:

; 369  :             }
; 370  : #else   // defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
; 371  :             else {
; 372  :                 assert(WMAB_FALSE);
; 373  :             }
; 374  : #endif  // defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
; 375  :     }
; 376  : 
; 377  :     paudec->m_hdrdecsts = HDR_DONE;

  00e5c	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00e5f	c7 40 1c 06 00
	00 00		 mov	 DWORD PTR [eax+28], 6
$exit$2898:

; 378  : 
; 379  : exit:
; 380  : 
; 381  : #ifdef PROFILE
; 382  :     FunctionProfileStop(&fp);
; 383  : #endif
; 384  : 
; 385  :     return wmaResult;

  00e66	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
$L2873:

; 386  : }

  00e69	5e		 pop	 esi
  00e6a	8b e5		 mov	 esp, ebp
  00e6c	5d		 pop	 ebp
  00e6d	c2 08 00	 ret	 8
$L3368:
  00e70	00 00 00 00	 DD	 $L2889
  00e74	00 00 00 00	 DD	 $L2942
  00e78	00 00 00 00	 DD	 $L2955
  00e7c	00 00 00 00	 DD	 $L2955
  00e80	00 00 00 00	 DD	 $L2961
  00e84	00 00 00 00	 DD	 $L2974
_prvDecodeFrameHeader_XDS@8 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\common\macros.h
WMADEC	ENDS
;	COMDAT _LOG2@4
WMADEC	SEGMENT
_iLog2$ = -4
_i$ = 8
_LOG2@4	PROC NEAR					; COMDAT

; 956  : {   // returns n where n = log2(2^n) = log2(2^(n+1)-1)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 957  :     U32 iLog2 = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iLog2$[ebp], 0
$L1587:

; 958  :     assert (i != 0);
; 959  :     while ((i >> iLog2) > 1)

  0000b	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _iLog2$[ebp]
  00011	d3 e8		 shr	 eax, cl
  00013	83 f8 01	 cmp	 eax, 1
  00016	76 0b		 jbe	 SHORT $L1588

; 960  :         iLog2++;

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _iLog2$[ebp]
  0001b	83 c1 01	 add	 ecx, 1
  0001e	89 4d fc	 mov	 DWORD PTR _iLog2$[ebp], ecx
  00021	eb e8		 jmp	 SHORT $L1587
$L1588:

; 961  : 
; 962  :     return iLog2;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _iLog2$[ebp]

; 963  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
_LOG2@4	ENDP
WMADEC	ENDS
PUBLIC	_prvDecodeCoefficientMono_XDS@12
PUBLIC	_prvDecodeRunLevel_XDS@20
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\entropydec.c
;	COMDAT _prvDecodeCoefficientMono_XDS@12
WMADEC	SEGMENT
tv82 = -8
_wmaResult$ = -4
_paudec$ = 8
_ppcinfo$ = 12
_piBitCnt$ = 16
_prvDecodeCoefficientMono_XDS@12 PROC NEAR		; COMDAT

; 397  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 398  :     WMARESULT   wmaResult = WMA_OK;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000b	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 399  : 
; 400  : #ifdef PROFILE
; 401  :     FunctionProfile fp;
; 402  :     FunctionProfileStart(&fp,DECODE_COEFFICENT_MONO_PROFILE);
; 403  : #endif
; 404  : 
; 405  :     if (ppcinfo->m_iPower == 0)

  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00011	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00015	75 02		 jne	 SHORT $L3024

; 406  :         goto exit;

  00017	eb 63		 jmp	 SHORT $exit$3025
$L3024:

; 407  : 
; 408  :     TRACEWMA_EXIT(wmaResult, prvDecodeRunLevel(paudec, ppcinfo, 0, ppcinfo->m_cSubbandActual, piBitCnt));

  00019	8b 55 10	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  0001c	52		 push	 edx
  0001d	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00020	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00023	51		 push	 ecx
  00024	6a 00		 push	 0
  00026	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00029	52		 push	 edx
  0002a	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _prvDecodeRunLevel_XDS@20
  00033	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00036	83 7d fc 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  0003a	7d 40		 jge	 SHORT $exit$3025
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0003f	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  00045	74 2f		 je	 SHORT $L3375
  00047	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0004a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  00050	74 24		 je	 SHORT $L3375
  00052	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00055	50		 push	 eax
  00056	68 98 01 00 00	 push	 408			; 00000198H
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00060	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0006e	83 c4 14	 add	 esp, 20			; 00000014H
  00071	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
  00074	eb 06		 jmp	 SHORT $exit$3025
$L3375:
  00076	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00079	89 55 f8	 mov	 DWORD PTR tv82[ebp], edx
$exit$3025:

; 409  : 
; 410  : exit:
; 411  : #ifdef PROFILE
; 412  :     FunctionProfileStop(&fp);
; 413  : #endif
; 414  :     return wmaResult;

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 415  : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 0c 00	 ret	 12			; 0000000cH
_prvDecodeCoefficientMono_XDS@12 ENDP
WMADEC	ENDS
PUBLIC	_ibstrmBitsLeft@4
PUBLIC	_ibstrmFlush@4
PUBLIC	_prvDecodeCoefficientStereo_XDS@12
; Function compile flags: /Odt
;	COMDAT _prvDecodeCoefficientStereo_XDS@12
WMADEC	SEGMENT
tv90 = -12
_wmaResult$ = -8
_pau$ = -4
_paudec$ = 8
_ppcinfo$ = 12
_piBitCnt$ = 16
_prvDecodeCoefficientStereo_XDS@12 PROC NEAR		; COMDAT

; 425  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 426  :     WMARESULT   wmaResult = WMA_OK;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000b	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 427  :     CAudioObject* pau = paudec->pau;

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00011	8b 11		 mov	 edx, DWORD PTR [ecx]
  00013	89 55 fc	 mov	 DWORD PTR _pau$[ebp], edx

; 428  : 
; 429  : #ifdef PROFILE
; 430  :     //FunctionProfile fp;
; 431  :     //FunctionProfileStart(&fp,DECODE_COEFFICENT_STEREO_PROFILE);
; 432  : #endif
; 433  : 	for (; paudec->m_iChannel < pau->m_cChannel; paudec->m_iChannel++)	

  00016	eb 12		 jmp	 SHORT $L3038
$L3039:
  00018	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0001b	66 8b 48 24	 mov	 cx, WORD PTR [eax+36]
  0001f	66 83 c1 01	 add	 cx, 1
  00023	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00026	66 89 4a 24	 mov	 WORD PTR [edx+36], cx
$L3038:
  0002a	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0002d	0f bf 48 24	 movsx	 ecx, WORD PTR [eax+36]
  00031	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00034	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  00038	3b c8		 cmp	 ecx, eax
  0003a	0f 8d ac 00 00
	00		 jge	 $exit$3043

; 434  :     {
; 435  :         TRACEWMA_EXIT(wmaResult, prvDecodeCoefficientMono(paudec, ppcinfo + paudec->m_iChannel, piBitCnt));

  00040	8b 4d 10	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00047	0f bf 42 24	 movsx	 eax, WORD PTR [edx+36]
  0004b	6b c0 70	 imul	 eax, 112		; 00000070H
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00051	03 c8		 add	 ecx, eax
  00053	51		 push	 ecx
  00054	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 _prvDecodeCoefficientMono_XDS@12
  0005d	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00060	83 7d f8 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00064	7d 42		 jge	 SHORT $L3044
  00066	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00069	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  0006f	74 2f		 je	 SHORT $L3380
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00074	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  0007a	74 24		 je	 SHORT $L3380
  0007c	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0007f	52		 push	 edx
  00080	68 b3 01 00 00	 push	 435			; 000001b3H
  00085	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0008f	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00098	83 c4 14	 add	 esp, 20			; 00000014H
  0009b	89 45 f4	 mov	 DWORD PTR tv90[ebp], eax
  0009e	eb 06		 jmp	 SHORT $L3381
$L3380:
  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000a3	89 4d f4	 mov	 DWORD PTR tv90[ebp], ecx
$L3381:
  000a6	eb 44		 jmp	 SHORT $exit$3043
$L3044:

; 436  : 
; 437  :         if(pau->m_iVersion == 1) 

  000a8	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  000ab	83 7a 44 01	 cmp	 DWORD PTR [edx+68], 1
  000af	75 2b		 jne	 SHORT $L3045

; 438  :         {
; 439  :             *piBitCnt += ibstrmBitsLeft (&paudec->m_ibstrm) % 8;

  000b1	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  000b4	83 c0 30	 add	 eax, 48			; 00000030H
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _ibstrmBitsLeft@4
  000bd	33 d2		 xor	 edx, edx
  000bf	b9 08 00 00 00	 mov	 ecx, 8
  000c4	f7 f1		 div	 ecx
  000c6	8b 45 10	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  000c9	03 10		 add	 edx, DWORD PTR [eax]
  000cb	8b 4d 10	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  000ce	89 11		 mov	 DWORD PTR [ecx], edx

; 440  : 		    ibstrmFlush(&paudec->m_ibstrm);         //no need to support pause mode (always has fraction bytes)

  000d0	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  000d3	83 c2 30	 add	 edx, 48			; 00000030H
  000d6	52		 push	 edx
  000d7	e8 00 00 00 00	 call	 _ibstrmFlush@4
$L3045:

; 441  :         }
; 442  :         paudec->pau->m_iCurrReconCoef = 0;

  000dc	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  000df	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e1	66 c7 41 74 00
	00		 mov	 WORD PTR [ecx+116], 0

; 443  : 	}

  000e7	e9 2c ff ff ff	 jmp	 $L3039
$exit$3043:

; 444  : 
; 445  : exit:
; 446  : #ifdef PROFILE
; 447  :     //FunctionProfileStop(&fp);
; 448  : #endif
; 449  : 	return wmaResult;

  000ec	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 450  : }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 0c 00	 ret	 12			; 0000000cH
_prvDecodeCoefficientStereo_XDS@12 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\decoder\strmdec_wma.h
WMADEC	ENDS
;	COMDAT _ibstrmBitsLeft@4
WMADEC	SEGMENT
_pibstrm$ = 8
_ibstrmBitsLeft@4 PROC NEAR				; COMDAT

; 80   : INLINE UInt ibstrmBitsLeft (const CWMAInputBitStream* pibstrm) {return pibstrm->m_dwBitsLeft;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00006	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
_ibstrmBitsLeft@4 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _ibstrmFlush@4
WMADEC	SEGMENT
_pibstrm$ = 8
_ibstrmFlush@4 PROC NEAR				; COMDAT

; 104  :                         { pibstrm->m_dwBitsLeft -= (pibstrm->m_dwBitsLeft % 8); } 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00006	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00009	33 d2		 xor	 edx, edx
  0000b	b9 08 00 00 00	 mov	 ecx, 8
  00010	f7 f1		 div	 ecx
  00012	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00015	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00018	2b ca		 sub	 ecx, edx
  0001a	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0001d	89 4a 24	 mov	 DWORD PTR [edx+36], ecx
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
_ibstrmFlush@4 ENDP
WMADEC	ENDS
PUBLIC	_prvGetNextRunDEC_XDS@12
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\entropydec.c
;	COMDAT _prvGetNextRunDEC_XDS@12
WMADEC	SEGMENT
tv211 = -60
tv195 = -56
tv157 = -52
tv131 = -48
tv84 = -44
tv66 = -40
_iEntry$ = -36
_cBitsTotal$ = -32
_paudec$ = -28
_iSign$ = -24
_iResult$ = -20
_pibstrm$ = -16
_wmaResult$ = -12
_pau$ = -8
_uSign$ = -4
_pobjin$ = 8
_ppcinfo$ = 12
_piBitCnt$ = 16
_prvGetNextRunDEC_XDS@12 PROC NEAR			; COMDAT

; 462  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 463  : 	U32 uSign  = 0;		//1 for positive 0 for nonpositive

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _uSign$[ebp], 0

; 464  :     I32 iSign  = 0;

  0000d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iSign$[ebp], 0

; 465  : 	U32 iEntry = 0;		//index to the Vlc table entry

  00014	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _iEntry$[ebp], 0

; 466  :     U32 iResult;
; 467  :     U16 cBitsTotal;
; 468  :     WMARESULT     wmaResult = WMA_OK;

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  00020	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 469  :     CAudioObjectDecoder* paudec  = (CAudioObjectDecoder*) pobjin;

  00023	8b 4d 08	 mov	 ecx, DWORD PTR _pobjin$[ebp]
  00026	89 4d e4	 mov	 DWORD PTR _paudec$[ebp], ecx

; 470  :     CAudioObject*		 pau = paudec->pau;

  00029	8b 55 e4	 mov	 edx, DWORD PTR _paudec$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	89 45 f8	 mov	 DWORD PTR _pau$[ebp], eax

; 471  :     CWMAInputBitStream*  pibstrm = &(paudec->m_ibstrm);

  00031	8b 4d e4	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00034	83 c1 30	 add	 ecx, 48			; 00000030H
  00037	89 4d f0	 mov	 DWORD PTR _pibstrm$[ebp], ecx

; 472  : 
; 473  :     switch (paudec->m_rlsts)
; 474  :     {

  0003a	8b 55 e4	 mov	 edx, DWORD PTR _paudec$[ebp]
  0003d	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00040	89 45 d8	 mov	 DWORD PTR tv66[ebp], eax
  00043	83 7d d8 00	 cmp	 DWORD PTR tv66[ebp], 0
  00047	74 0f		 je	 SHORT $L3068
  00049	83 7d d8 03	 cmp	 DWORD PTR tv66[ebp], 3
  0004d	0f 84 d3 01 00
	00		 je	 $escape$3077
  00053	e9 2e 03 00 00	 jmp	 $exit$3071
$L3068:

; 475  :     case VLC:
; 476  :         TRACEWMA_EXIT(wmaResult, huffDecGet (ppcinfo->m_rgiHuffDecTbl, &paudec->m_ibstrm,
; 477  :             &iResult, &iEntry, &uSign));

  00058	8d 4d fc	 lea	 ecx, DWORD PTR _uSign$[ebp]
  0005b	51		 push	 ecx
  0005c	8d 55 dc	 lea	 edx, DWORD PTR _iEntry$[ebp]
  0005f	52		 push	 edx
  00060	8d 45 ec	 lea	 eax, DWORD PTR _iResult$[ebp]
  00063	50		 push	 eax
  00064	8b 4d e4	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00067	83 c1 30	 add	 ecx, 48			; 00000030H
  0006a	51		 push	 ecx
  0006b	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  0006e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _huffDecGet@20
  00077	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0007a	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  0007e	7d 45		 jge	 SHORT $L3072
  00080	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00083	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  00089	74 2f		 je	 SHORT $L3391
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0008e	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  00094	74 24		 je	 SHORT $L3391
  00096	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00099	50		 push	 eax
  0009a	68 dd 01 00 00	 push	 477			; 000001ddH
  0009f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  000a4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  000a9	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000ac	51		 push	 ecx
  000ad	e8 00 00 00 00	 call	 _MyOutputDbgStr
  000b2	83 c4 14	 add	 esp, 20			; 00000014H
  000b5	89 45 d4	 mov	 DWORD PTR tv84[ebp], eax
  000b8	eb 06		 jmp	 SHORT $L3392
$L3391:
  000ba	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000bd	89 55 d4	 mov	 DWORD PTR tv84[ebp], edx
$L3392:
  000c0	e9 c1 02 00 00	 jmp	 $exit$3071
$L3072:

; 478  :         COUNT_BITS(*piBitCnt, iResult);

  000c5	8b 45 10	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  000c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ca	03 4d ec	 add	 ecx, DWORD PTR _iResult$[ebp]
  000cd	8b 55 10	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  000d0	89 0a		 mov	 DWORD PTR [edx], ecx

; 479  :         TRACEWMA_EXIT(wmaResult, ibstrmFlushBits(&paudec->m_ibstrm, iResult));   //flush bits used by huffDecGet

  000d2	8b 45 ec	 mov	 eax, DWORD PTR _iResult$[ebp]
  000d5	50		 push	 eax
  000d6	8b 4d e4	 mov	 ecx, DWORD PTR _paudec$[ebp]
  000d9	83 c1 30	 add	 ecx, 48			; 00000030H
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 _ibstrmFlushBits@8
  000e2	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  000e5	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  000e9	7d 45		 jge	 SHORT $L3075
  000eb	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000ee	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  000f4	74 2f		 je	 SHORT $L3393
  000f6	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000f9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  000ff	74 24		 je	 SHORT $L3393
  00101	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00104	51		 push	 ecx
  00105	68 df 01 00 00	 push	 479			; 000001dfH
  0010a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  0010f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00114	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0011d	83 c4 14	 add	 esp, 20			; 00000014H
  00120	89 45 d0	 mov	 DWORD PTR tv131[ebp], eax
  00123	eb 06		 jmp	 SHORT $L3394
$L3393:
  00125	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00128	89 45 d0	 mov	 DWORD PTR tv131[ebp], eax
$L3394:
  0012b	e9 56 02 00 00	 jmp	 $exit$3071
$L3075:

; 480  : 	    if (iEntry == 0)

  00130	83 7d dc 00	 cmp	 DWORD PTR _iEntry$[ebp], 0
  00134	75 05		 jne	 SHORT $L3076

; 481  :             goto escape;

  00136	e9 eb 00 00 00	 jmp	 $escape$3077
$L3076:

; 482  :         if (iEntry == 1)

  0013b	83 7d dc 01	 cmp	 DWORD PTR _iEntry$[ebp], 1
  0013f	75 3a		 jne	 SHORT $L3078

; 483  :         {
; 484  : 			/*
; 485  : 		    // [1], end of coefs for this subFrame 
; 486  :             *pcRunOfZeros = ppcinfo->m_cSubbandActual - iCoef - 1;
; 487  :             *piCurrLevel = 0;
; 488  :             wmaResult = WMA_OK;
; 489  : 			*/
; 490  :             pau->m_iLevel = 0;

  00141	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  00144	66 c7 41 20 00
	00		 mov	 WORD PTR [ecx+32], 0

; 491  : 			pau->m_iHighCutOffCurr = -1; 

  0014a	8b 55 f8	 mov	 edx, DWORD PTR _pau$[ebp]
  0014d	c7 42 28 ff ff
	ff ff		 mov	 DWORD PTR [edx+40], -1

; 492  : 			pau->m_iNextBarkIndex = -1;                                                                    

  00154	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  00157	c7 40 2c ff ff
	ff ff		 mov	 DWORD PTR [eax+44], -1

; 493  : 			pau->m_cRunOfZeros = ppcinfo->m_cSubbandActual - pau->m_iCurrReconCoef - 1;

  0015e	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  00161	0f bf 51 74	 movsx	 edx, WORD PTR [ecx+116]
  00165	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00168	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0016b	2b ca		 sub	 ecx, edx
  0016d	83 e9 01	 sub	 ecx, 1
  00170	8b 55 f8	 mov	 edx, DWORD PTR _pau$[ebp]
  00173	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 494  :         }
; 495  :         else 

  00176	e9 a6 00 00 00	 jmp	 $L3079
$L3078:

; 496  :         {
; 497  : 			assert (iEntry >= 2);
; 498  :             COUNT_BITS(*piBitCnt, 1);

  0017b	8b 45 10	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  0017e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00180	83 c1 01	 add	 ecx, 1
  00183	8b 55 10	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  00186	89 0a		 mov	 DWORD PTR [edx], ecx

; 499  :             TRACEWMA_EXIT(wmaResult, ibstrmFlushBits(&paudec->m_ibstrm, 1));   //flush the sign bit also

  00188	6a 01		 push	 1
  0018a	8b 45 e4	 mov	 eax, DWORD PTR _paudec$[ebp]
  0018d	83 c0 30	 add	 eax, 48			; 00000030H
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 _ibstrmFlushBits@8
  00196	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00199	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  0019d	7d 45		 jge	 SHORT $L3082
  0019f	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  001a2	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  001a8	74 2f		 je	 SHORT $L3395
  001aa	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  001ad	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  001b3	74 24		 je	 SHORT $L3395
  001b5	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  001b8	50		 push	 eax
  001b9	68 f3 01 00 00	 push	 499			; 000001f3H
  001be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  001c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  001c8	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  001cb	51		 push	 ecx
  001cc	e8 00 00 00 00	 call	 _MyOutputDbgStr
  001d1	83 c4 14	 add	 esp, 20			; 00000014H
  001d4	89 45 cc	 mov	 DWORD PTR tv157[ebp], eax
  001d7	eb 06		 jmp	 SHORT $L3396
$L3395:
  001d9	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  001dc	89 55 cc	 mov	 DWORD PTR tv157[ebp], edx
$L3396:
  001df	e9 a2 01 00 00	 jmp	 $exit$3071
$L3082:

; 500  : 			pau->m_cRunOfZeros = ppcinfo->m_rgiRunEntry [iEntry - 2] & 0x7FFFFFFF;

  001e4	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  001e7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001ea	8b 55 dc	 mov	 edx, DWORD PTR _iEntry$[ebp]
  001ed	0f b7 44 51 fc	 movzx	 eax, WORD PTR [ecx+edx*2-4]
  001f2	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  001f7	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  001fa	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 501  : 			assert (pau->m_cRunOfZeros >= 0);
; 502  : 			pau->m_iLevel = ppcinfo->m_rgiLevelEntry [iEntry - 2];

  001fd	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00200	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00203	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  00206	8b 55 dc	 mov	 edx, DWORD PTR _iEntry$[ebp]
  00209	66 8b 44 50 fc	 mov	 ax, WORD PTR [eax+edx*2-4]
  0020e	66 89 41 20	 mov	 WORD PTR [ecx+32], ax

; 503  : 			pau->m_iSign = (I32) (uSign >> 31) - 1;

  00212	8b 4d fc	 mov	 ecx, DWORD PTR _uSign$[ebp]
  00215	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00218	83 e9 01	 sub	 ecx, 1
  0021b	8b 55 f8	 mov	 edx, DWORD PTR _pau$[ebp]
  0021e	89 4a 24	 mov	 DWORD PTR [edx+36], ecx
$L3079:

; 504  :         }
; 505  :         break;

  00221	e9 60 01 00 00	 jmp	 $exit$3071
$escape$3077:

; 506  : 
; 507  :     case ESCAPE:
; 508  : escape:
; 509  :         paudec->m_rlsts = ESCAPE;

  00226	8b 45 e4	 mov	 eax, DWORD PTR _paudec$[ebp]
  00229	c7 40 20 03 00
	00 00		 mov	 DWORD PTR [eax+32], 3

; 510  :         cBitsTotal = (U16) pau->m_iMaxEscSize + (U16) pau->m_cBitsSubbandMax + 1; //<=25=13+11+1

  00230	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  00233	0f b7 51 3c	 movzx	 edx, WORD PTR [ecx+60]
  00237	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  0023a	0f b7 88 14 03
	00 00		 movzx	 ecx, WORD PTR [eax+788]
  00241	8d 54 0a 01	 lea	 edx, DWORD PTR [edx+ecx+1]
  00245	66 89 55 e0	 mov	 WORD PTR _cBitsTotal$[ebp], dx

; 511  :         assert (cBitsTotal <= 25);
; 512  :         TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, cBitsTotal));

  00249	0f b7 45 e0	 movzx	 eax, WORD PTR _cBitsTotal$[ebp]
  0024d	50		 push	 eax
  0024e	8b 4d e4	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00251	83 c1 30	 add	 ecx, 48			; 00000030H
  00254	51		 push	 ecx
  00255	e8 00 00 00 00	 call	 _ibstrmLookForBits@8
  0025a	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0025d	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00261	7d 45		 jge	 SHORT $L3089
  00263	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00266	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  0026c	74 2f		 je	 SHORT $L3397
  0026e	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00271	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00277	74 24		 je	 SHORT $L3397
  00279	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0027c	51		 push	 ecx
  0027d	68 00 02 00 00	 push	 512			; 00000200H
  00282	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00287	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0028c	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0028f	52		 push	 edx
  00290	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00295	83 c4 14	 add	 esp, 20			; 00000014H
  00298	89 45 c8	 mov	 DWORD PTR tv195[ebp], eax
  0029b	eb 06		 jmp	 SHORT $L3398
$L3397:
  0029d	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  002a0	89 45 c8	 mov	 DWORD PTR tv195[ebp], eax
$L3398:
  002a3	e9 de 00 00 00	 jmp	 $exit$3071
$L3089:

; 513  : 
; 514  :         TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, cBitsTotal, &iResult));

  002a8	8d 4d ec	 lea	 ecx, DWORD PTR _iResult$[ebp]
  002ab	51		 push	 ecx
  002ac	0f b7 55 e0	 movzx	 edx, WORD PTR _cBitsTotal$[ebp]
  002b0	52		 push	 edx
  002b1	8b 45 e4	 mov	 eax, DWORD PTR _paudec$[ebp]
  002b4	83 c0 30	 add	 eax, 48			; 00000030H
  002b7	50		 push	 eax
  002b8	e8 00 00 00 00	 call	 _ibstrmGetBits@12
  002bd	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  002c0	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  002c4	7d 42		 jge	 SHORT $L3092
  002c6	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  002c9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  002cf	74 2f		 je	 SHORT $L3399
  002d1	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  002d4	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  002da	74 24		 je	 SHORT $L3399
  002dc	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  002df	50		 push	 eax
  002e0	68 02 02 00 00	 push	 514			; 00000202H
  002e5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  002ea	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  002ef	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  002f2	51		 push	 ecx
  002f3	e8 00 00 00 00	 call	 _MyOutputDbgStr
  002f8	83 c4 14	 add	 esp, 20			; 00000014H
  002fb	89 45 c4	 mov	 DWORD PTR tv211[ebp], eax
  002fe	eb 06		 jmp	 SHORT $L3400
$L3399:
  00300	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00303	89 55 c4	 mov	 DWORD PTR tv211[ebp], edx
$L3400:
  00306	eb 7e		 jmp	 SHORT $exit$3071
$L3092:

; 515  :         COUNT_BITS(*piBitCnt, cBitsTotal);

  00308	0f b7 45 e0	 movzx	 eax, WORD PTR _cBitsTotal$[ebp]
  0030c	8b 4d 10	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  0030f	03 01		 add	 eax, DWORD PTR [ecx]
  00311	8b 55 10	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  00314	89 02		 mov	 DWORD PTR [edx], eax

; 516  : 
; 517  :         cBitsTotal = (U16) paudec->pau->m_cBitsSubbandMax + 1;

  00316	8b 45 e4	 mov	 eax, DWORD PTR _paudec$[ebp]
  00319	8b 08		 mov	 ecx, DWORD PTR [eax]
  0031b	0f b7 91 14 03
	00 00		 movzx	 edx, WORD PTR [ecx+788]
  00322	83 c2 01	 add	 edx, 1
  00325	66 89 55 e0	 mov	 WORD PTR _cBitsTotal$[ebp], dx

; 518  : 		pau->m_iLevel = (I16) (iResult >> cBitsTotal);

  00329	0f b7 4d e0	 movzx	 ecx, WORD PTR _cBitsTotal$[ebp]
  0032d	8b 45 ec	 mov	 eax, DWORD PTR _iResult$[ebp]
  00330	d3 e8		 shr	 eax, cl
  00332	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  00335	66 89 41 20	 mov	 WORD PTR [ecx+32], ax

; 519  :         pau->m_iSign = (I32) (iResult & 0x00000001) - 1;

  00339	8b 55 ec	 mov	 edx, DWORD PTR _iResult$[ebp]
  0033c	83 e2 01	 and	 edx, 1
  0033f	83 ea 01	 sub	 edx, 1
  00342	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  00345	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 520  :         //*piCurrLevel = (I16) ((*piCurrLevel ^ iSign) - iSign);
; 521  : 
; 522  : 		pau->m_cRunOfZeros = (I16) (iResult & (0xFFFFFFFF >> (32 - cBitsTotal))) >> 1;

  00348	0f b7 4d e0	 movzx	 ecx, WORD PTR _cBitsTotal$[ebp]
  0034c	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00351	2b d1		 sub	 edx, ecx
  00353	83 c8 ff	 or	 eax, -1
  00356	8b ca		 mov	 ecx, edx
  00358	d3 e8		 shr	 eax, cl
  0035a	8b 4d ec	 mov	 ecx, DWORD PTR _iResult$[ebp]
  0035d	23 c8		 and	 ecx, eax
  0035f	0f bf d1	 movsx	 edx, cx
  00362	d1 fa		 sar	 edx, 1
  00364	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  00367	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 523  : 		pau->m_cRunOfZeros &= 0x7FFFFFFF;

  0036a	8b 4d f8	 mov	 ecx, DWORD PTR _pau$[ebp]
  0036d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00370	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  00376	8b 45 f8	 mov	 eax, DWORD PTR _pau$[ebp]
  00379	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 524  :         paudec->m_rlsts = VLC;

  0037c	8b 4d e4	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0037f	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
$exit$3071:

; 525  : 	}
; 526  : 
; 527  : exit:
; 528  :     return wmaResult;

  00386	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 529  : }

  00389	8b e5		 mov	 esp, ebp
  0038b	5d		 pop	 ebp
  0038c	c2 0c 00	 ret	 12			; 0000000cH
_prvGetNextRunDEC_XDS@12 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _prvDecodeRunLevel_XDS@20
WMADEC	SEGMENT
tv140 = -40
tv87 = -36
tv71 = -32
_rgiCoefQ$ = -28
_rgiLevelEntry$ = -24
_fPrint$ = -20
_piCoef$ = -16
_pau$ = -12
_wmaResult$ = -8
_rgiRunEntry$ = -4
_paudec$ = 8
_ppcinfo$ = 12
_iCoefFirst$ = 16
_iCoefLim$ = 20
_piBitCnt$ = 24
_prvDecodeRunLevel_XDS@20 PROC NEAR			; COMDAT

; 552  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 553  :     I16* rgiCoefQ       = ppcinfo->m_rgiCoefQ;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d e4	 mov	 DWORD PTR _rgiCoefQ$[ebp], ecx

; 554  :     const U16* rgiRunEntry    = ppcinfo->m_rgiRunEntry;    

  0000e	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00011	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00014	89 45 fc	 mov	 DWORD PTR _rgiRunEntry$[ebp], eax

; 555  :     const U16* rgiLevelEntry  = ppcinfo->m_rgiLevelEntry;    

  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  0001a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0001d	89 55 e8	 mov	 DWORD PTR _rgiLevelEntry$[ebp], edx

; 556  :     CAudioObject* pau = paudec->pau;

  00020	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	89 4d f4	 mov	 DWORD PTR _pau$[ebp], ecx

; 557  : 	I16* piCoef = &pau->m_iCurrReconCoef;	

  00028	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  0002b	83 c2 74	 add	 edx, 116		; 00000074H
  0002e	89 55 f0	 mov	 DWORD PTR _piCoef$[ebp], edx

; 558  : #ifdef DEBUG_DECODE_TRACE
; 559  :     DEBUG_ONLY( Bool fPrint = (g_ulOutputSamples==0x4e00); )
; 560  : #else
; 561  :     DEBUG_ONLY( Bool fPrint = (pau->m_iFrameNumber  <= 10 && pau->m_iCurrSubFrame == 0); )

  00031	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00034	83 b8 e8 03 00
	00 0a		 cmp	 DWORD PTR [eax+1000], 10 ; 0000000aH
  0003b	77 12		 ja	 SHORT $L3404
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  00040	83 79 70 00	 cmp	 DWORD PTR [ecx+112], 0
  00044	75 09		 jne	 SHORT $L3404
  00046	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  0004d	eb 07		 jmp	 SHORT $L3405
$L3404:
  0004f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L3405:
  00056	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  00059	89 55 ec	 mov	 DWORD PTR _fPrint$[ebp], edx

; 562  : #endif
; 563  :     WMARESULT   wmaResult = WMA_OK;

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  00061	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax
$L3116:

; 564  : 
; 565  :     // This function is too frequently called to be profiled
; 566  : 	//FUNCTION_PROFILE(fp);
; 567  :     //FUNCTION_PROFILE_START(&fp,DECODE_RUN_LEVEL_PROFILE);
; 568  :     while (*piCoef < iCoefLim) 

  00064	8b 4d f0	 mov	 ecx, DWORD PTR _piCoef$[ebp]
  00067	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0006a	3b 55 14	 cmp	 edx, DWORD PTR _iCoefLim$[ebp]
  0006d	0f 8d 27 01 00
	00		 jge	 $exit$3120

; 569  :     {
; 570  :         TRACEWMA_EXIT(wmaResult, prvGetNextRunDEC(paudec,ppcinfo,piBitCnt));

  00073	8b 45 18	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  00076	50		 push	 eax
  00077	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  0007a	51		 push	 ecx
  0007b	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 _prvGetNextRunDEC_XDS@12
  00084	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00087	83 7d f8 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  0008b	7d 45		 jge	 SHORT $L3121
  0008d	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00090	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00096	74 2f		 je	 SHORT $L3406
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0009b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  000a1	74 24		 je	 SHORT $L3406
  000a3	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000a6	52		 push	 edx
  000a7	68 3a 02 00 00	 push	 570			; 0000023aH
  000ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  000b1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  000b6	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _MyOutputDbgStr
  000bf	83 c4 14	 add	 esp, 20			; 00000014H
  000c2	89 45 dc	 mov	 DWORD PTR tv87[ebp], eax
  000c5	eb 06		 jmp	 SHORT $L3407
$L3406:
  000c7	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000ca	89 4d dc	 mov	 DWORD PTR tv87[ebp], ecx
$L3407:
  000cd	e9 c8 00 00 00	 jmp	 $exit$3120
$L3121:

; 571  :         pau->m_iLevel = (I16) ((pau->m_iLevel ^ pau->m_iSign) - pau->m_iSign);

  000d2	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  000d5	0f bf 42 20	 movsx	 eax, WORD PTR [edx+32]
  000d9	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  000dc	33 41 24	 xor	 eax, DWORD PTR [ecx+36]
  000df	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  000e2	2b 42 24	 sub	 eax, DWORD PTR [edx+36]
  000e5	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  000e8	66 89 41 20	 mov	 WORD PTR [ecx+32], ax

; 572  :         DBG_RUNLEVEL(g_cBitGet-21,pau->m_cRunOfZeros,pau->m_iLevel,fPrint);
; 573  :         if ( (*piCoef+ pau->m_cRunOfZeros) >= iCoefLim)  {

  000ec	8b 55 f0	 mov	 edx, DWORD PTR _piCoef$[ebp]
  000ef	0f bf 02	 movsx	 eax, WORD PTR [edx]
  000f2	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  000f5	03 41 1c	 add	 eax, DWORD PTR [ecx+28]
  000f8	3b 45 14	 cmp	 eax, DWORD PTR _iCoefLim$[ebp]
  000fb	7c 55		 jl	 SHORT $L3123

; 574  :             assert (WMAB_FALSE);
; 575  :             wmaResult = TraceResult(WMA_E_BROKEN_FRAME);

  000fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  00103	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  00109	74 37		 je	 SHORT $L3408
  0010b	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  00110	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00116	74 2a		 je	 SHORT $L3408
  00118	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  0011e	51		 push	 ecx
  0011f	68 3f 02 00 00	 push	 575			; 0000023fH
  00124	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00129	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0012e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  00134	52		 push	 edx
  00135	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0013a	83 c4 14	 add	 esp, 20			; 00000014H
  0013d	89 45 d8	 mov	 DWORD PTR tv140[ebp], eax
  00140	eb 08		 jmp	 SHORT $L3409
$L3408:
  00142	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  00147	89 45 d8	 mov	 DWORD PTR tv140[ebp], eax
$L3409:
  0014a	8b 4d d8	 mov	 ecx, DWORD PTR tv140[ebp]
  0014d	89 4d f8	 mov	 DWORD PTR _wmaResult$[ebp], ecx

; 576  :             goto exit;

  00150	eb 48		 jmp	 SHORT $exit$3120
$L3123:

; 577  :         }
; 578  : //        memset (rgiCoefQ + *piCoef, 0, pau->m_cRunOfZeros * sizeof (I16));
; 579  :     	*piCoef += (I16) pau->m_cRunOfZeros;

  00152	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00155	0f bf 42 1c	 movsx	 eax, WORD PTR [edx+28]
  00159	8b 4d f0	 mov	 ecx, DWORD PTR _piCoef$[ebp]
  0015c	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0015f	03 d0		 add	 edx, eax
  00161	8b 45 f0	 mov	 eax, DWORD PTR _piCoef$[ebp]
  00164	66 89 10	 mov	 WORD PTR [eax], dx

; 580  : 		rgiCoefQ [*piCoef] = pau->m_iLevel;

  00167	8b 4d f0	 mov	 ecx, DWORD PTR _piCoef$[ebp]
  0016a	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0016d	8b 45 e4	 mov	 eax, DWORD PTR _rgiCoefQ$[ebp]
  00170	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  00173	66 8b 49 20	 mov	 cx, WORD PTR [ecx+32]
  00177	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 581  : 		MONITOR_RANGE(gMR_iCoefQ,rgiCoefQ [*piCoef]);
; 582  : 		MONITOR_COUNT_CONDITIONAL(pau->m_cRunOfZeros>0,gMC_0CoefQ,pau->m_cRunOfZeros);
; 583  : 		(*piCoef)++;

  0017b	8b 55 f0	 mov	 edx, DWORD PTR _piCoef$[ebp]
  0017e	66 8b 02	 mov	 ax, WORD PTR [edx]
  00181	66 05 01 00	 add	 ax, 1
  00185	8b 4d f0	 mov	 ecx, DWORD PTR _piCoef$[ebp]
  00188	66 89 01	 mov	 WORD PTR [ecx], ax

; 584  :         paudec->m_rlsts = VLC;

  0018b	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0018e	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0

; 585  : 	}

  00195	e9 ca fe ff ff	 jmp	 $L3116
$exit$3120:

; 586  :     
; 587  : exit:
; 588  :     //FUNCTION_PROFILE_STOP(&fp);
; 589  : 	return wmaResult;

  0019a	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 590  : }

  0019d	8b e5		 mov	 esp, ebp
  0019f	5d		 pop	 ebp
  001a0	c2 14 00	 ret	 20			; 00000014H
_prvDecodeRunLevel_XDS@20 ENDP
WMADEC	ENDS
EXTRN	_g_rgiHuffDecTbl16smOb:BYTE
EXTRN	_gRun16smOb:BYTE
EXTRN	_gLevel16smOb:BYTE
EXTRN	_g_rgiHuffDecTbl16ssOb:BYTE
EXTRN	_gRun16ssOb:BYTE
EXTRN	_gLevel16ssOb:BYTE
EXTRN	_g_rgiHuffDecTbl44smOb:BYTE
EXTRN	_gRun44smOb:BYTE
EXTRN	_gLevel44smOb:BYTE
EXTRN	_g_rgiHuffDecTbl44ssOb:BYTE
EXTRN	_gRun44ssOb:BYTE
EXTRN	_gLevel44ssOb:BYTE
EXTRN	_g_rgiHuffDecTbl44smQb:BYTE
EXTRN	_gRun44smQb:BYTE
EXTRN	_gLevel44smQb:BYTE
EXTRN	_g_rgiHuffDecTbl44ssQb:BYTE
EXTRN	_gRun44ssQb:BYTE
EXTRN	_gLevel44ssQb:BYTE
; Function compile flags: /Odt
;	COMDAT _prvSetDetTable_XDS@8
WMADEC	SEGMENT
_pau$ = -4
_paudec$ = 8
_ppcinfo$ = 12
_prvSetDetTable_XDS@8 PROC NEAR				; COMDAT

; 599  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 600  :     CAudioObject* pau = paudec->pau;

  00004	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _pau$[ebp], ecx

; 601  : /*** less than 0.5%
; 602  : #ifdef PROFILE
; 603  :     //FunctionProfile fp;
; 604  :     //FunctionProfileStart(&fp,SET_DET_TABLE_PROFILE);
; 605  : #endif
; 606  : *///
; 607  :     if (pau->m_iEntropyMode == SIXTEENS_OB)   {

  0000c	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  0000f	83 ba 3c 03 00
	00 03		 cmp	 DWORD PTR [edx+828], 3
  00016	75 4f		 jne	 SHORT $L3131

; 608  :         if (pau->m_stereoMode == STEREO_SUMDIFF)  {

  00018	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  0001b	83 b8 38 03 00
	00 01		 cmp	 DWORD PTR [eax+824], 1
  00022	75 20		 jne	 SHORT $L3132

; 609  :             ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl16ssOb;

  00024	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00027	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET FLAT:_g_rgiHuffDecTbl16ssOb

; 610  :             ppcinfo->m_rgiRunEntry = gRun16ssOb;    

  0002e	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00031	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET FLAT:_gRun16ssOb

; 611  :             ppcinfo->m_rgiLevelEntry = gLevel16ssOb;    

  00038	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  0003b	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET FLAT:_gLevel16ssOb

; 612  :         }
; 613  :         else {

  00042	eb 1e		 jmp	 SHORT $L3133
$L3132:

; 614  :             ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl16smOb; 

  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00047	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET FLAT:_g_rgiHuffDecTbl16smOb

; 615  :             ppcinfo->m_rgiRunEntry = gRun16smOb;    

  0004e	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00051	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET FLAT:_gRun16smOb

; 616  :             ppcinfo->m_rgiLevelEntry = gLevel16smOb;    

  00058	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  0005b	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET FLAT:_gLevel16smOb
$L3133:

; 617  :         }
; 618  :     }
; 619  : #ifdef ENABLE_ALL_ENCOPT
; 620  :     else if (pau->m_iEntropyMode == FOURTYFOURS_QB)   {

  00062	e9 ae 00 00 00	 jmp	 $L3129
$L3131:
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  0006a	83 b9 3c 03 00
	00 01		 cmp	 DWORD PTR [ecx+828], 1
  00071	75 4c		 jne	 SHORT $L3135

; 621  :         if (pau->m_stereoMode == STEREO_SUMDIFF)  {

  00073	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00076	83 ba 38 03 00
	00 01		 cmp	 DWORD PTR [edx+824], 1
  0007d	75 20		 jne	 SHORT $L3136

; 622  :             ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl44ssQb;

  0007f	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00082	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET FLAT:_g_rgiHuffDecTbl44ssQb

; 623  :             ppcinfo->m_rgiRunEntry = gRun44ssQb;    

  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  0008c	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET FLAT:_gRun44ssQb

; 624  :             ppcinfo->m_rgiLevelEntry = gLevel44ssQb;

  00093	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00096	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], OFFSET FLAT:_gLevel44ssQb

; 625  :         }
; 626  :         else {

  0009d	eb 1e		 jmp	 SHORT $L3137
$L3136:

; 627  :             ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl44smQb; 

  0009f	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  000a2	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET FLAT:_g_rgiHuffDecTbl44smQb

; 628  :             ppcinfo->m_rgiRunEntry = gRun44smQb;    

  000a9	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  000ac	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET FLAT:_gRun44smQb

; 629  :             ppcinfo->m_rgiLevelEntry = gLevel44smQb;    

  000b3	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  000b6	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], OFFSET FLAT:_gLevel44smQb
$L3137:

; 630  :         }
; 631  :     }
; 632  :     else if (pau->m_iEntropyMode == FOURTYFOURS_OB)   {

  000bd	eb 56		 jmp	 SHORT $L3129
$L3135:
  000bf	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  000c2	83 b8 3c 03 00
	00 02		 cmp	 DWORD PTR [eax+828], 2
  000c9	75 4a		 jne	 SHORT $L3129

; 633  :         if (pau->m_stereoMode == STEREO_SUMDIFF)  {

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  000ce	83 b9 38 03 00
	00 01		 cmp	 DWORD PTR [ecx+824], 1
  000d5	75 20		 jne	 SHORT $L3140

; 634  :             ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl44ssOb;

  000d7	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  000da	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET FLAT:_g_rgiHuffDecTbl44ssOb

; 635  :             ppcinfo->m_rgiRunEntry = gRun44ssOb;

  000e1	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  000e4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET FLAT:_gRun44ssOb

; 636  :             ppcinfo->m_rgiLevelEntry = gLevel44ssOb;

  000eb	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  000ee	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], OFFSET FLAT:_gLevel44ssOb

; 637  :         }
; 638  :         else {

  000f5	eb 1e		 jmp	 SHORT $L3129
$L3140:

; 639  :             ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl44smOb;

  000f7	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  000fa	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET FLAT:_g_rgiHuffDecTbl44smOb

; 640  :             ppcinfo->m_rgiRunEntry = gRun44smOb;

  00101	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00104	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET FLAT:_gRun44smOb

; 641  :             ppcinfo->m_rgiLevelEntry = gLevel44smOb;

  0010b	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  0010e	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], OFFSET FLAT:_gLevel44smOb
$L3129:

; 642  :         }
; 643  :     }
; 644  : #endif // ENABLE_ALL_ENCOPT
; 645  : /***
; 646  : #ifdef PROFILE
; 647  :     //FunctionProfileStop(&fp);
; 648  : #endif
; 649  : *///
; 650  : }

  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c2 08 00	 ret	 8
_prvSetDetTable_XDS@8 ENDP
WMADEC	ENDS
EXTRN	_auResampleWeightFactorLPC_XDS@8:NEAR
EXTRN	_auLsp2lpc_XDS@16:NEAR
EXTRN	_prvLpcToSpectrum_XDS@12:NEAR
EXTRN	__fltused:NEAR
; Function compile flags: /Odt
;	COMDAT _prvDecodeFrameHeaderLpc_XDS@8
WMADEC	SEGMENT
tv160 = -96
tv139 = -92
tv92 = -88
_iFreq$3180 = -84
_pwtWeightFactor$3178 = -80
_iResult$3165 = -76
_rgiLspFreqQ$3160 = -72
_piFreq$ = -68
_rgLpcCoef$ = -64
_ppcinfo$ = -24
_cBitAlloc$ = -20
_piChannel$ = -16
_pau$ = -12
_wmaResult$ = -8
_fUpdateMask$ = -4
_paudec$ = 8
_piBitCnt$ = 12
_prvDecodeFrameHeaderLpc_XDS@8 PROC NEAR		; COMDAT

; 699  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H

; 700  :     Bool fUpdateMask = paudec->pau->m_subfrmconfigCurr.m_rgfMaskUpdate [paudec->pau->m_iCurrSubFrame];

  00006	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0000e	8b 02		 mov	 eax, DWORD PTR [edx]
  00010	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  00013	8b 84 91 04 02
	00 00		 mov	 eax, DWORD PTR [ecx+edx*4+516]
  0001a	89 45 fc	 mov	 DWORD PTR _fUpdateMask$[ebp], eax

; 701  : 	CAudioObject* pau = paudec->pau;

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00020	8b 11		 mov	 edx, DWORD PTR [ecx]
  00022	89 55 f4	 mov	 DWORD PTR _pau$[ebp], edx

; 702  :     I16* piChannel = &paudec->m_iChannel;

  00025	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00028	83 c0 24	 add	 eax, 36			; 00000024H
  0002b	89 45 f0	 mov	 DWORD PTR _piChannel$[ebp], eax

; 703  :     PerChannelInfo *ppcinfo;
; 704  :     // U8 rgiLspFreqQ[LPCORDER];  ONHOLD will lose this, use WeightFactor instead
; 705  :     I16* piFreq = &paudec->m_iBand;  // preserve this across ONHOLD

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00031	83 c1 26	 add	 ecx, 38			; 00000026H
  00034	89 4d bc	 mov	 DWORD PTR _piFreq$[ebp], ecx

; 706  : 	Int cBitAlloc;
; 707  :     WMARESULT   wmaResult = WMA_OK;

  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_OK
  0003d	89 55 f8	 mov	 DWORD PTR _wmaResult$[ebp], edx

; 708  :     LpType rgLpcCoef [LPCORDER];
; 709  :     FUNCTION_PROFILE(fp);
; 710  :     FUNCTION_PROFILE_START(&fp,FRAME_HEADER_LPC_PROFILE);
; 711  : 
; 712  :     DEBUG_BREAK_AT_FRAME_LPC_WEIGHTS;
; 713  : 
; 714  :     for (; *piChannel < pau->m_cChannel; (*piChannel)++)   

  00040	eb 10		 jmp	 SHORT $L3155
$L3156:
  00042	8b 45 f0	 mov	 eax, DWORD PTR _piChannel$[ebp]
  00045	66 8b 08	 mov	 cx, WORD PTR [eax]
  00048	66 83 c1 01	 add	 cx, 1
  0004c	8b 55 f0	 mov	 edx, DWORD PTR _piChannel$[ebp]
  0004f	66 89 0a	 mov	 WORD PTR [edx], cx
$L3155:
  00052	8b 45 f0	 mov	 eax, DWORD PTR _piChannel$[ebp]
  00055	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00058	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  0005b	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  0005f	3b c8		 cmp	 ecx, eax
  00061	0f 8d 0e 02 00
	00		 jge	 $exit$3168

; 715  : 	{
; 716  : 		ppcinfo = pau->m_rgpcinfo + *piChannel;

  00067	8b 4d f0	 mov	 ecx, DWORD PTR _piChannel$[ebp]
  0006a	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0006d	6b d2 70	 imul	 edx, 112		; 00000070H
  00070	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00073	03 90 a0 03 00
	00		 add	 edx, DWORD PTR [eax+928]
  00079	89 55 e8	 mov	 DWORD PTR _ppcinfo$[ebp], edx

; 717  : 		if (ppcinfo->m_iPower != 0 )   

  0007c	8b 4d e8	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  0007f	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00083	0f 84 79 01 00
	00		 je	 $L3158

; 718  : 		{
; 719  : 			if (fUpdateMask == WMAB_TRUE)

  00089	83 7d fc 01	 cmp	 DWORD PTR _fUpdateMask$[ebp], 1
  0008d	0f 85 57 01 00
	00		 jne	 $L3159

; 720  : 			{
; 721  :                 // these 10 bytes are saved in the WeightFactor array in case we go ONHOLD.  
; 722  :                 // WeightFactor will be set by rgiLspFreqQ
; 723  :                 U8* rgiLspFreqQ = (U8*)(INTEGER_OR_INT_FLOAT( ppcinfo->m_rguiWeightFactor, ppcinfo->m_rgfltWeightFactor ));

  00093	8b 55 e8	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00096	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00099	89 45 b8	 mov	 DWORD PTR _rgiLspFreqQ$3160[ebp], eax

; 724  : 				for (; *piFreq < LPCORDER; (*piFreq)++)	

  0009c	eb 10		 jmp	 SHORT $L3162
$L3163:
  0009e	8b 4d bc	 mov	 ecx, DWORD PTR _piFreq$[ebp]
  000a1	66 8b 11	 mov	 dx, WORD PTR [ecx]
  000a4	66 83 c2 01	 add	 dx, 1
  000a8	8b 45 bc	 mov	 eax, DWORD PTR _piFreq$[ebp]
  000ab	66 89 10	 mov	 WORD PTR [eax], dx
$L3162:
  000ae	8b 4d bc	 mov	 ecx, DWORD PTR _piFreq$[ebp]
  000b1	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  000b4	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  000b7	0f 8d b9 00 00
	00		 jge	 $L3164

; 725  : 				{
; 726  : 					U32         iResult;
; 727  : 					cBitAlloc = (*piFreq == 0 || *piFreq == 8 || *piFreq == 9) ? 3 : 4;

  000bd	8b 45 bc	 mov	 eax, DWORD PTR _piFreq$[ebp]
  000c0	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000c3	85 c9		 test	 ecx, ecx
  000c5	74 1f		 je	 SHORT $L3416
  000c7	8b 55 bc	 mov	 edx, DWORD PTR _piFreq$[ebp]
  000ca	0f bf 02	 movsx	 eax, WORD PTR [edx]
  000cd	83 f8 08	 cmp	 eax, 8
  000d0	74 14		 je	 SHORT $L3416
  000d2	8b 4d bc	 mov	 ecx, DWORD PTR _piFreq$[ebp]
  000d5	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  000d8	83 fa 09	 cmp	 edx, 9
  000db	74 09		 je	 SHORT $L3416
  000dd	c7 45 a8 04 00
	00 00		 mov	 DWORD PTR tv92[ebp], 4
  000e4	eb 07		 jmp	 SHORT $L3417
$L3416:
  000e6	c7 45 a8 03 00
	00 00		 mov	 DWORD PTR tv92[ebp], 3
$L3417:
  000ed	8b 45 a8	 mov	 eax, DWORD PTR tv92[ebp]
  000f0	89 45 ec	 mov	 DWORD PTR _cBitAlloc$[ebp], eax

; 728  :                 
; 729  : 					TRACEWMA_EXIT(wmaResult, ibstrmGetBits(&paudec->m_ibstrm,
; 730  : 						          cBitAlloc, &iResult));

  000f3	8d 4d b4	 lea	 ecx, DWORD PTR _iResult$3165[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 ec	 mov	 edx, DWORD PTR _cBitAlloc$[ebp]
  000fa	52		 push	 edx
  000fb	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  000fe	83 c0 30	 add	 eax, 48			; 00000030H
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _ibstrmGetBits@12
  00107	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0010a	83 7d f8 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  0010e	7d 45		 jge	 SHORT $L3169
  00110	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00113	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  00119	74 2f		 je	 SHORT $L3418
  0011b	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0011e	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  00124	74 24		 je	 SHORT $L3418
  00126	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00129	50		 push	 eax
  0012a	68 da 02 00 00	 push	 730			; 000002daH
  0012f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00134	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00139	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0013c	51		 push	 ecx
  0013d	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00142	83 c4 14	 add	 esp, 20			; 00000014H
  00145	89 45 a4	 mov	 DWORD PTR tv139[ebp], eax
  00148	eb 06		 jmp	 SHORT $L3419
$L3418:
  0014a	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0014d	89 55 a4	 mov	 DWORD PTR tv139[ebp], edx
$L3419:
  00150	e9 20 01 00 00	 jmp	 $exit$3168
$L3169:

; 731  : 					rgiLspFreqQ[*piFreq] = (U8) iResult;

  00155	8b 45 bc	 mov	 eax, DWORD PTR _piFreq$[ebp]
  00158	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0015b	8b 55 b8	 mov	 edx, DWORD PTR _rgiLspFreqQ$3160[ebp]
  0015e	8a 45 b4	 mov	 al, BYTE PTR _iResult$3165[ebp]
  00161	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 732  : 
; 733  : 					*piBitCnt += cBitAlloc;

  00164	8b 4d 0c	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  00167	8b 11		 mov	 edx, DWORD PTR [ecx]
  00169	03 55 ec	 add	 edx, DWORD PTR _cBitAlloc$[ebp]
  0016c	8b 45 0c	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  0016f	89 10		 mov	 DWORD PTR [eax], edx

; 734  : 					MONITOR_RANGE(gMR_rgiLspFreqQ, rgiLspFreqQ[*piFreq]);
; 735  : 				}

  00171	e9 28 ff ff ff	 jmp	 $L3163
$L3164:

; 736  : 				auLsp2lpc(pau, rgiLspFreqQ, rgLpcCoef, LPCORDER);

  00176	6a 0a		 push	 10			; 0000000aH
  00178	8d 4d c0	 lea	 ecx, DWORD PTR _rgLpcCoef$[ebp]
  0017b	51		 push	 ecx
  0017c	8b 55 b8	 mov	 edx, DWORD PTR _rgiLspFreqQ$3160[ebp]
  0017f	52		 push	 edx
  00180	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 _auLsp2lpc_XDS@16

; 737  : 				TRACEWMA_EXIT(wmaResult, prvLpcToSpectrum(pau,
; 738  : 					          rgLpcCoef, ppcinfo));

  00189	8b 4d e8	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  0018c	51		 push	 ecx
  0018d	8d 55 c0	 lea	 edx, DWORD PTR _rgLpcCoef$[ebp]
  00190	52		 push	 edx
  00191	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 _prvLpcToSpectrum_XDS@12
  0019a	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0019d	83 7d f8 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  001a1	7d 45		 jge	 SHORT $L3173
  001a3	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  001a6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  001ac	74 2f		 je	 SHORT $L3420
  001ae	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  001b1	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  001b7	74 24		 je	 SHORT $L3420
  001b9	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  001bc	50		 push	 eax
  001bd	68 e2 02 00 00	 push	 738			; 000002e2H
  001c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  001c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  001cc	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  001cf	51		 push	 ecx
  001d0	e8 00 00 00 00	 call	 _MyOutputDbgStr
  001d5	83 c4 14	 add	 esp, 20			; 00000014H
  001d8	89 45 a0	 mov	 DWORD PTR tv160[ebp], eax
  001db	eb 06		 jmp	 SHORT $L3421
$L3420:
  001dd	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  001e0	89 55 a0	 mov	 DWORD PTR tv160[ebp], edx
$L3421:
  001e3	e9 8d 00 00 00	 jmp	 $exit$3168
$L3173:

; 739  :                 SHOW_OWF(*piChannel,0);
; 740  : 			}
; 741  : 			else if (pau->m_iCurrSubFrame > 0) 

  001e8	eb 16		 jmp	 SHORT $L3174
$L3159:
  001ea	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  001ed	83 78 70 00	 cmp	 DWORD PTR [eax+112], 0
  001f1	7e 0d		 jle	 SHORT $L3174

; 742  : 			{	
; 743  : 				auResampleWeightFactorLPC (pau, ppcinfo);

  001f3	8b 4d e8	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  001f6	51		 push	 ecx
  001f7	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  001fa	52		 push	 edx
  001fb	e8 00 00 00 00	 call	 _auResampleWeightFactorLPC_XDS@8
$L3174:

; 744  :                 SHOW_OWF(*piChannel,1);
; 745  : 			}
; 746  : 		}
; 747  : 		else if (fUpdateMask == WMAB_TRUE)

  00200	eb 66		 jmp	 SHORT $L3176
$L3158:
  00202	83 7d fc 01	 cmp	 DWORD PTR _fUpdateMask$[ebp], 1
  00206	75 4a		 jne	 SHORT $L3177

; 748  : 		{	//artifically set to constants since nothing got sent for this channel; see comments in msaudioenc.c
; 749  : 			WeightType* pwtWeightFactor = (WeightType*) ppcinfo->m_rguiWeightFactor;

  00208	8b 45 e8	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  0020b	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0020e	89 4d b0	 mov	 DWORD PTR _pwtWeightFactor$3178[ebp], ecx

; 750  :             I16 iFreq;
; 751  : 			ppcinfo->m_wtMaxWeight = WEIGHT_FROM_FLOAT(1.0F);

  00211	8b 55 e8	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00214	c7 42 6c 00 00
	80 3f		 mov	 DWORD PTR [edx+108], 1065353216 ; 3f800000H

; 752  : 			for (iFreq = (I16) pau->m_cSubband; iFreq > 0; iFreq-- )

  0021b	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  0021e	66 8b 48 60	 mov	 cx, WORD PTR [eax+96]
  00222	66 89 4d ac	 mov	 WORD PTR _iFreq$3180[ebp], cx
  00226	eb 0c		 jmp	 SHORT $L3183
$L3184:
  00228	66 8b 55 ac	 mov	 dx, WORD PTR _iFreq$3180[ebp]
  0022c	66 83 ea 01	 sub	 dx, 1
  00230	66 89 55 ac	 mov	 WORD PTR _iFreq$3180[ebp], dx
$L3183:
  00234	0f bf 45 ac	 movsx	 eax, WORD PTR _iFreq$3180[ebp]
  00238	85 c0		 test	 eax, eax
  0023a	7e 14		 jle	 SHORT $L3185

; 753  : 				*pwtWeightFactor++ = WEIGHT_FROM_FLOAT(1.0F);

  0023c	8b 4d b0	 mov	 ecx, DWORD PTR _pwtWeightFactor$3178[ebp]
  0023f	c7 01 00 00 80
	3f		 mov	 DWORD PTR [ecx], 1065353216 ; 3f800000H
  00245	8b 55 b0	 mov	 edx, DWORD PTR _pwtWeightFactor$3178[ebp]
  00248	83 c2 04	 add	 edx, 4
  0024b	89 55 b0	 mov	 DWORD PTR _pwtWeightFactor$3178[ebp], edx
  0024e	eb d8		 jmp	 SHORT $L3184
$L3185:

; 754  :             SHOW_OWF(*piChannel,2);
; 755  : 		}
; 756  :         else if (pau->m_iCurrSubFrame > 0) 

  00250	eb 16		 jmp	 SHORT $L3176
$L3177:
  00252	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00255	83 78 70 00	 cmp	 DWORD PTR [eax+112], 0
  00259	7e 0d		 jle	 SHORT $L3176

; 757  : 		{	// resample even if zero power, these weights might be used in a later subframe with non-zero power
; 758  :             auResampleWeightFactorLPC (pau, ppcinfo);

  0025b	8b 4d e8	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  0025e	51		 push	 ecx
  0025f	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00262	52		 push	 edx
  00263	e8 00 00 00 00	 call	 _auResampleWeightFactorLPC_XDS@8
$L3176:

; 759  :             SHOW_OWF(*piChannel,3);
; 760  : 		}
; 761  :         *piFreq = 0;

  00268	8b 45 bc	 mov	 eax, DWORD PTR _piFreq$[ebp]
  0026b	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 762  : 	}

  00270	e9 cd fd ff ff	 jmp	 $L3156
$exit$3168:

; 763  : 
; 764  : exit:
; 765  :     FUNCTION_PROFILE_STOP(&fp);
; 766  :     return wmaResult;

  00275	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 767  : }

  00278	8b e5		 mov	 esp, ebp
  0027a	5d		 pop	 ebp
  0027b	c2 08 00	 ret	 8
_prvDecodeFrameHeaderLpc_XDS@8 ENDP
WMADEC	ENDS
EXTRN	_g_rgiHuffDecTblNoisePower:BYTE
; Function compile flags: /Odt
;	COMDAT _prvDecodeFrameHeaderNoiseSub_XDS@8
WMADEC	SEGMENT
tv267 = -88
tv253 = -84
tv229 = -80
tv176 = -76
tv161 = -72
tv145 = -68
tv93 = -64
tv67 = -60
_rgiNoisePower$3239 = -56
_rgbBandNotCoded$3238 = -52
_ppcinfo$3236 = -48
_ppcinfo$3212 = -44
_cBitUsed$ = -40
_iStart$ = -36
_iEnd$ = -32
_iCode$ = -28
_iResult$ = -24
_piChannel$ = -20
_piBand$ = -16
_pau$ = -12
_wmaResult$ = -8
_rgbBandNotCoded$ = -4
_paudec$ = 8
_piBitCnt$ = 12
_prvDecodeFrameHeaderNoiseSub_XDS@8 PROC NEAR		; COMDAT

; 778  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H

; 779  :     U8*	rgbBandNotCoded;
; 780  :     Int iStart, iEnd;
; 781  :     Int iCode;
; 782  :     U32 cBitUsed;
; 783  :     I16* piChannel = &paudec->m_iChannel;

  00006	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  00009	83 c0 24	 add	 eax, 36			; 00000024H
  0000c	89 45 ec	 mov	 DWORD PTR _piChannel$[ebp], eax

; 784  :     I16* piBand = &paudec->m_iBand;

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00012	83 c1 26	 add	 ecx, 38			; 00000026H
  00015	89 4d f0	 mov	 DWORD PTR _piBand$[ebp], ecx

; 785  : 	CAudioObject* pau = paudec->pau;

  00018	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0001b	8b 02		 mov	 eax, DWORD PTR [edx]
  0001d	89 45 f4	 mov	 DWORD PTR _pau$[ebp], eax

; 786  : 
; 787  :     WMARESULT   wmaResult = WMA_OK;

  00020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_OK
  00026	89 4d f8	 mov	 DWORD PTR _wmaResult$[ebp], ecx

; 788  :     U32         iResult;
; 789  : 	FUNCTION_PROFILE(fp);
; 790  : 	FUNCTION_PROFILE_START(&fp,FRAME_HEADER_NOISE_SUB_PROFILE);
; 791  : 
; 792  :     switch (paudec->m_hdrdecsts)
; 793  :     {

  00029	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0002c	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0002f	89 45 c4	 mov	 DWORD PTR tv67[ebp], eax
  00032	83 7d c4 02	 cmp	 DWORD PTR tv67[ebp], 2
  00036	74 0f		 je	 SHORT $L3208
  00038	83 7d c4 03	 cmp	 DWORD PTR tv67[ebp], 3
  0003c	0f 84 b9 02 00
	00		 je	 $L3232
  00042	e9 dc 04 00 00	 jmp	 $exit$3215
$L3208:

; 794  :         case HDR_NOISE1:
; 795  :             //noise band indicator
; 796  :             for (; *piChannel < pau->m_cChannel; (*piChannel)++)   {

  00047	eb 10		 jmp	 SHORT $L3209
$L3210:
  00049	8b 4d ec	 mov	 ecx, DWORD PTR _piChannel$[ebp]
  0004c	66 8b 11	 mov	 dx, WORD PTR [ecx]
  0004f	66 83 c2 01	 add	 dx, 1
  00053	8b 45 ec	 mov	 eax, DWORD PTR _piChannel$[ebp]
  00056	66 89 10	 mov	 WORD PTR [eax], dx
$L3209:
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _piChannel$[ebp]
  0005c	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0005f	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00062	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  00066	3b d1		 cmp	 edx, ecx
  00068	0f 8d 73 02 00
	00		 jge	 $L3211

; 797  :                 PerChannelInfo* ppcinfo = pau->m_rgpcinfo + *piChannel;

  0006e	8b 55 ec	 mov	 edx, DWORD PTR _piChannel$[ebp]
  00071	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00074	6b c0 70	 imul	 eax, 112		; 00000070H
  00077	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  0007a	03 81 a0 03 00
	00		 add	 eax, DWORD PTR [ecx+928]
  00080	89 45 d4	 mov	 DWORD PTR _ppcinfo$3212[ebp], eax

; 798  :                 TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, 
; 799  :                                 pau->m_cValidBarkBand - pau->m_iFirstNoiseBand));                

  00083	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00086	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00089	8b 8a 50 03 00
	00		 mov	 ecx, DWORD PTR [edx+848]
  0008f	2b 88 c0 03 00
	00		 sub	 ecx, DWORD PTR [eax+960]
  00095	51		 push	 ecx
  00096	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00099	83 c2 30	 add	 edx, 48			; 00000030H
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 _ibstrmLookForBits@8
  000a2	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax
  000a5	83 7d f8 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  000a9	7d 45		 jge	 SHORT $L3216
  000ab	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000ae	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  000b4	74 2f		 je	 SHORT $L3426
  000b6	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000b9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  000bf	74 24		 je	 SHORT $L3426
  000c1	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000c4	52		 push	 edx
  000c5	68 1f 03 00 00	 push	 799			; 0000031fH
  000ca	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  000cf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  000d4	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 _MyOutputDbgStr
  000dd	83 c4 14	 add	 esp, 20			; 00000014H
  000e0	89 45 c0	 mov	 DWORD PTR tv93[ebp], eax
  000e3	eb 06		 jmp	 SHORT $L3427
$L3426:
  000e5	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000e8	89 4d c0	 mov	 DWORD PTR tv93[ebp], ecx
$L3427:
  000eb	e9 33 04 00 00	 jmp	 $exit$3215
$L3216:

; 800  :                 if (ppcinfo->m_iPower != 0) {

  000f0	8b 55 d4	 mov	 edx, DWORD PTR _ppcinfo$3212[ebp]
  000f3	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  000f7	0f 84 c5 01 00
	00		 je	 $L3217

; 801  :                     rgbBandNotCoded = ppcinfo->m_rgbBandNotCoded;

  000fd	8b 45 d4	 mov	 eax, DWORD PTR _ppcinfo$3212[ebp]
  00100	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00103	89 4d fc	 mov	 DWORD PTR _rgbBandNotCoded$[ebp], ecx

; 802  :                     *rgbBandNotCoded = 0;

  00106	8b 55 fc	 mov	 edx, DWORD PTR _rgbBandNotCoded$[ebp]
  00109	c6 02 00	 mov	 BYTE PTR [edx], 0

; 803  :                     ppcinfo->m_cSubbandActual = pau->m_iFirstNoiseIndex - pau->m_cLowCutOff;

  0010c	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  0010f	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  00112	8b 90 c4 03 00
	00		 mov	 edx, DWORD PTR [eax+964]
  00118	2b 91 24 03 00
	00		 sub	 edx, DWORD PTR [ecx+804]
  0011e	8b 45 d4	 mov	 eax, DWORD PTR _ppcinfo$3212[ebp]
  00121	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 804  :                     iStart = 0, iEnd = 0;

  00124	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _iStart$[ebp], 0
  0012b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iEnd$[ebp], 0
$L3219:

; 805  :                     while (WMAB_TRUE) {

  00132	b9 01 00 00 00	 mov	 ecx, 1
  00137	85 c9		 test	 ecx, ecx
  00139	0f 84 63 01 00
	00		 je	 $L3220

; 806  :                         iStart = max (pau->m_iFirstNoiseIndex, pau->m_rgiBarkIndex [*piBand]);

  0013f	8b 55 f0	 mov	 edx, DWORD PTR _piBand$[ebp]
  00142	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00145	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  00148	8b 91 54 03 00
	00		 mov	 edx, DWORD PTR [ecx+852]
  0014e	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  00151	8b 89 c4 03 00
	00		 mov	 ecx, DWORD PTR [ecx+964]
  00157	3b 0c 82	 cmp	 ecx, DWORD PTR [edx+eax*4]
  0015a	7e 0e		 jle	 SHORT $L3428
  0015c	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  0015f	8b 82 c4 03 00
	00		 mov	 eax, DWORD PTR [edx+964]
  00165	89 45 bc	 mov	 DWORD PTR tv145[ebp], eax
  00168	eb 15		 jmp	 SHORT $L3429
$L3428:
  0016a	8b 4d f0	 mov	 ecx, DWORD PTR _piBand$[ebp]
  0016d	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00170	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  00173	8b 88 54 03 00
	00		 mov	 ecx, DWORD PTR [eax+852]
  00179	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  0017c	89 55 bc	 mov	 DWORD PTR tv145[ebp], edx
$L3429:
  0017f	8b 45 bc	 mov	 eax, DWORD PTR tv145[ebp]
  00182	89 45 dc	 mov	 DWORD PTR _iStart$[ebp], eax

; 807  :                         if (iStart >= pau->m_cHighCutOff)

  00185	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  00188	8b 55 dc	 mov	 edx, DWORD PTR _iStart$[ebp]
  0018b	3b 91 28 03 00
	00		 cmp	 edx, DWORD PTR [ecx+808]
  00191	7c 05		 jl	 SHORT $L3221

; 808  :                             break;

  00193	e9 0a 01 00 00	 jmp	 $L3220
$L3221:

; 809  :                         iEnd   = min (pau->m_cHighCutOff, pau->m_rgiBarkIndex [*piBand + 1]);

  00198	8b 45 f0	 mov	 eax, DWORD PTR _piBand$[ebp]
  0019b	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0019e	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  001a1	8b 82 54 03 00
	00		 mov	 eax, DWORD PTR [edx+852]
  001a7	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  001aa	8b 92 28 03 00
	00		 mov	 edx, DWORD PTR [edx+808]
  001b0	3b 54 88 04	 cmp	 edx, DWORD PTR [eax+ecx*4+4]
  001b4	7d 0e		 jge	 SHORT $L3430
  001b6	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  001b9	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  001bf	89 4d b8	 mov	 DWORD PTR tv161[ebp], ecx
  001c2	eb 16		 jmp	 SHORT $L3431
$L3430:
  001c4	8b 55 f0	 mov	 edx, DWORD PTR _piBand$[ebp]
  001c7	0f bf 02	 movsx	 eax, WORD PTR [edx]
  001ca	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  001cd	8b 91 54 03 00
	00		 mov	 edx, DWORD PTR [ecx+852]
  001d3	8b 44 82 04	 mov	 eax, DWORD PTR [edx+eax*4+4]
  001d7	89 45 b8	 mov	 DWORD PTR tv161[ebp], eax
$L3431:
  001da	8b 4d b8	 mov	 ecx, DWORD PTR tv161[ebp]
  001dd	89 4d e0	 mov	 DWORD PTR _iEnd$[ebp], ecx

; 810  : 
; 811  :                         TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));

  001e0	8d 55 e8	 lea	 edx, DWORD PTR _iResult$[ebp]
  001e3	52		 push	 edx
  001e4	6a 01		 push	 1
  001e6	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  001e9	83 c0 30	 add	 eax, 48			; 00000030H
  001ec	50		 push	 eax
  001ed	e8 00 00 00 00	 call	 _ibstrmGetBits@12
  001f2	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax
  001f5	83 7d f8 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  001f9	7d 45		 jge	 SHORT $L3224
  001fb	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  001fe	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  00204	74 2f		 je	 SHORT $L3432
  00206	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00209	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  0020f	74 24		 je	 SHORT $L3432
  00211	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00214	50		 push	 eax
  00215	68 2b 03 00 00	 push	 811			; 0000032bH
  0021a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  0021f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00224	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00227	51		 push	 ecx
  00228	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0022d	83 c4 14	 add	 esp, 20			; 00000014H
  00230	89 45 b4	 mov	 DWORD PTR tv176[ebp], eax
  00233	eb 06		 jmp	 SHORT $L3433
$L3432:
  00235	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00238	89 55 b4	 mov	 DWORD PTR tv176[ebp], edx
$L3433:
  0023b	e9 e3 02 00 00	 jmp	 $exit$3215
$L3224:

; 812  : 				        rgbBandNotCoded [*piBand] = (U8) iResult;

  00240	8b 45 f0	 mov	 eax, DWORD PTR _piBand$[ebp]
  00243	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00246	8b 55 fc	 mov	 edx, DWORD PTR _rgbBandNotCoded$[ebp]
  00249	8a 45 e8	 mov	 al, BYTE PTR _iResult$[ebp]
  0024c	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 813  : 
; 814  :                         (*piBitCnt)++;

  0024f	8b 4d 0c	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  00252	8b 11		 mov	 edx, DWORD PTR [ecx]
  00254	83 c2 01	 add	 edx, 1
  00257	8b 45 0c	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  0025a	89 10		 mov	 DWORD PTR [eax], edx

; 815  : 				        if (rgbBandNotCoded [*piBand] != 0)

  0025c	8b 4d f0	 mov	 ecx, DWORD PTR _piBand$[ebp]
  0025f	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00262	8b 45 fc	 mov	 eax, DWORD PTR _rgbBandNotCoded$[ebp]
  00265	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00269	85 c9		 test	 ecx, ecx
  0026b	74 0e		 je	 SHORT $L3226

; 816  : 					        rgbBandNotCoded [0]++;

  0026d	8b 55 fc	 mov	 edx, DWORD PTR _rgbBandNotCoded$[ebp]
  00270	8a 02		 mov	 al, BYTE PTR [edx]
  00272	04 01		 add	 al, 1
  00274	8b 4d fc	 mov	 ecx, DWORD PTR _rgbBandNotCoded$[ebp]
  00277	88 01		 mov	 BYTE PTR [ecx], al

; 817  :                         else 

  00279	eb 12		 jmp	 SHORT $L3227
$L3226:

; 818  :                             ppcinfo->m_cSubbandActual += iEnd - iStart;

  0027b	8b 55 e0	 mov	 edx, DWORD PTR _iEnd$[ebp]
  0027e	2b 55 dc	 sub	 edx, DWORD PTR _iStart$[ebp]
  00281	8b 45 d4	 mov	 eax, DWORD PTR _ppcinfo$3212[ebp]
  00284	03 50 20	 add	 edx, DWORD PTR [eax+32]
  00287	8b 4d d4	 mov	 ecx, DWORD PTR _ppcinfo$3212[ebp]
  0028a	89 51 20	 mov	 DWORD PTR [ecx+32], edx
$L3227:

; 819  :                         (*piBand)++;

  0028d	8b 55 f0	 mov	 edx, DWORD PTR _piBand$[ebp]
  00290	66 8b 02	 mov	 ax, WORD PTR [edx]
  00293	66 05 01 00	 add	 ax, 1
  00297	8b 4d f0	 mov	 ecx, DWORD PTR _piBand$[ebp]
  0029a	66 89 01	 mov	 WORD PTR [ecx], ax

; 820  : 			        }

  0029d	e9 90 fe ff ff	 jmp	 $L3219
$L3220:

; 821  : 			        if (*piBand < pau->m_cValidBarkBand )

  002a2	8b 55 f0	 mov	 edx, DWORD PTR _piBand$[ebp]
  002a5	0f bf 02	 movsx	 eax, WORD PTR [edx]
  002a8	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  002ab	3b 81 50 03 00
	00		 cmp	 eax, DWORD PTR [ecx+848]
  002b1	7d 0d		 jge	 SHORT $L3228

; 822  : 				        rgbBandNotCoded [*piBand] = (U8) 0;		// protect from debug verify code looking one band past end  

  002b3	8b 55 f0	 mov	 edx, DWORD PTR _piBand$[ebp]
  002b6	0f bf 02	 movsx	 eax, WORD PTR [edx]
  002b9	8b 4d fc	 mov	 ecx, DWORD PTR _rgbBandNotCoded$[ebp]
  002bc	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
$L3228:

; 823  :                 }
; 824  :                 else 

  002c0	eb 0a		 jmp	 SHORT $L3230
$L3217:

; 825  :                     ppcinfo->m_cSubbandActual = 0;

  002c2	8b 55 d4	 mov	 edx, DWORD PTR _ppcinfo$3212[ebp]
  002c5	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
$L3230:

; 826  :                 assert (ppcinfo->m_cSubbandActual >= 0 &&
; 827  :                         ppcinfo->m_cSubbandActual <= pau->m_cHighCutOff - pau->m_cLowCutOff);
; 828  :                 *piBand = (I16) pau->m_iFirstNoiseBand;

  002cc	8b 45 f0	 mov	 eax, DWORD PTR _piBand$[ebp]
  002cf	8b 4d f4	 mov	 ecx, DWORD PTR _pau$[ebp]
  002d2	66 8b 91 c0 03
	00 00		 mov	 dx, WORD PTR [ecx+960]
  002d9	66 89 10	 mov	 WORD PTR [eax], dx

; 829  :             }

  002dc	e9 68 fd ff ff	 jmp	 $L3210
$L3211:

; 830  :             paudec->m_hdrdecsts = HDR_NOISE2;

  002e1	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  002e4	c7 40 1c 03 00
	00 00		 mov	 DWORD PTR [eax+28], 3

; 831  :             *piChannel = 0;

  002eb	8b 4d ec	 mov	 ecx, DWORD PTR _piChannel$[ebp]
  002ee	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0

; 832  :             //I guess
; 833  :             *piBand = 0;

  002f3	8b 55 f0	 mov	 edx, DWORD PTR _piBand$[ebp]
  002f6	66 c7 02 00 00	 mov	 WORD PTR [edx], 0
$L3232:

; 834  : 
; 835  :         case HDR_NOISE2:
; 836  :             //noise power
; 837  :             for (; *piChannel < pau->m_cChannel; (*piChannel)++)   {

  002fb	eb 10		 jmp	 SHORT $L3233
$L3234:
  002fd	8b 45 ec	 mov	 eax, DWORD PTR _piChannel$[ebp]
  00300	66 8b 08	 mov	 cx, WORD PTR [eax]
  00303	66 83 c1 01	 add	 cx, 1
  00307	8b 55 ec	 mov	 edx, DWORD PTR _piChannel$[ebp]
  0030a	66 89 0a	 mov	 WORD PTR [edx], cx
$L3233:
  0030d	8b 45 ec	 mov	 eax, DWORD PTR _piChannel$[ebp]
  00310	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00313	8b 55 f4	 mov	 edx, DWORD PTR _pau$[ebp]
  00316	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  0031a	3b c8		 cmp	 ecx, eax
  0031c	0f 8d 01 02 00
	00		 jge	 $exit$3215

; 838  :                 PerChannelInfo* ppcinfo = pau->m_rgpcinfo + *piChannel;

  00322	8b 4d ec	 mov	 ecx, DWORD PTR _piChannel$[ebp]
  00325	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00328	6b d2 70	 imul	 edx, 112		; 00000070H
  0032b	8b 45 f4	 mov	 eax, DWORD PTR _pau$[ebp]
  0032e	03 90 a0 03 00
	00		 add	 edx, DWORD PTR [eax+928]
  00334	89 55 d0	 mov	 DWORD PTR _ppcinfo$3236[ebp], edx

; 839  :                 if (ppcinfo->m_iPower != 0) {

  00337	8b 4d d0	 mov	 ecx, DWORD PTR _ppcinfo$3236[ebp]
  0033a	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0033e	0f 84 d2 01 00
	00		 je	 $L3237

; 840  : 			        U8*	 rgbBandNotCoded = ppcinfo->m_rgbBandNotCoded;

  00344	8b 55 d0	 mov	 edx, DWORD PTR _ppcinfo$3236[ebp]
  00347	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0034a	89 45 cc	 mov	 DWORD PTR _rgbBandNotCoded$3238[ebp], eax

; 841  : 			        Int* rgiNoisePower   = ppcinfo->m_rgiNoisePower;

  0034d	8b 4d d0	 mov	 ecx, DWORD PTR _ppcinfo$3236[ebp]
  00350	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00353	89 55 c8	 mov	 DWORD PTR _rgiNoisePower$3239[ebp], edx

; 842  : 			        if (rgbBandNotCoded [0] > 0)	{

  00356	8b 45 cc	 mov	 eax, DWORD PTR _rgbBandNotCoded$3238[ebp]
  00359	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0035c	85 c9		 test	 ecx, ecx
  0035e	0f 8e b2 01 00
	00		 jle	 $L3237

; 843  :                         if (*piBand == 0)

  00364	8b 55 f0	 mov	 edx, DWORD PTR _piBand$[ebp]
  00367	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0036a	85 c0		 test	 eax, eax
  0036c	0f 85 88 00 00
	00		 jne	 $L3241

; 844  :                         {
; 845  :                             TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 7, &iResult));

  00372	8d 4d e8	 lea	 ecx, DWORD PTR _iResult$[ebp]
  00375	51		 push	 ecx
  00376	6a 07		 push	 7
  00378	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0037b	83 c2 30	 add	 edx, 48			; 00000030H
  0037e	52		 push	 edx
  0037f	e8 00 00 00 00	 call	 _ibstrmGetBits@12
  00384	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00387	83 7d f8 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  0038b	7d 45		 jge	 SHORT $L3244
  0038d	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00390	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00396	74 2f		 je	 SHORT $L3434
  00398	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0039b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  003a1	74 24		 je	 SHORT $L3434
  003a3	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  003a6	52		 push	 edx
  003a7	68 4d 03 00 00	 push	 845			; 0000034dH
  003ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  003b1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  003b6	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  003b9	50		 push	 eax
  003ba	e8 00 00 00 00	 call	 _MyOutputDbgStr
  003bf	83 c4 14	 add	 esp, 20			; 00000014H
  003c2	89 45 b0	 mov	 DWORD PTR tv229[ebp], eax
  003c5	eb 06		 jmp	 SHORT $L3435
$L3434:
  003c7	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  003ca	89 4d b0	 mov	 DWORD PTR tv229[ebp], ecx
$L3435:
  003cd	e9 51 01 00 00	 jmp	 $exit$3215
$L3244:

; 846  : 				            rgiNoisePower [0] = iResult - 19;

  003d2	8b 55 e8	 mov	 edx, DWORD PTR _iResult$[ebp]
  003d5	83 ea 13	 sub	 edx, 19			; 00000013H
  003d8	8b 45 c8	 mov	 eax, DWORD PTR _rgiNoisePower$3239[ebp]
  003db	89 10		 mov	 DWORD PTR [eax], edx

; 847  :                             (*piBand)++;

  003dd	8b 4d f0	 mov	 ecx, DWORD PTR _piBand$[ebp]
  003e0	66 8b 11	 mov	 dx, WORD PTR [ecx]
  003e3	66 83 c2 01	 add	 dx, 1
  003e7	8b 45 f0	 mov	 eax, DWORD PTR _piBand$[ebp]
  003ea	66 89 10	 mov	 WORD PTR [eax], dx

; 848  :                             *piBitCnt += 7;

  003ed	8b 4d 0c	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  003f0	8b 11		 mov	 edx, DWORD PTR [ecx]
  003f2	83 c2 07	 add	 edx, 7
  003f5	8b 45 0c	 mov	 eax, DWORD PTR _piBitCnt$[ebp]
  003f8	89 10		 mov	 DWORD PTR [eax], edx
$L3241:

; 849  :                         }
; 850  : 
; 851  : 				        for (; *piBand < rgbBandNotCoded [0]; (*piBand)++)	{

  003fa	eb 10		 jmp	 SHORT $L3245
$L3246:
  003fc	8b 4d f0	 mov	 ecx, DWORD PTR _piBand$[ebp]
  003ff	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00402	66 83 c2 01	 add	 dx, 1
  00406	8b 45 f0	 mov	 eax, DWORD PTR _piBand$[ebp]
  00409	66 89 10	 mov	 WORD PTR [eax], dx
$L3245:
  0040c	8b 4d f0	 mov	 ecx, DWORD PTR _piBand$[ebp]
  0040f	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00412	8b 45 cc	 mov	 eax, DWORD PTR _rgbBandNotCoded$3238[ebp]
  00415	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00418	3b d1		 cmp	 edx, ecx
  0041a	0f 8d f6 00 00
	00		 jge	 $L3237

; 852  :                             TRACEWMA_EXIT(wmaResult, huffDecGet (g_rgiHuffDecTblNoisePower,
; 853  :                                           &paudec->m_ibstrm, &cBitUsed, (unsigned long *)&iCode, (unsigned long *)0));

  00420	6a 00		 push	 0
  00422	8d 55 e4	 lea	 edx, DWORD PTR _iCode$[ebp]
  00425	52		 push	 edx
  00426	8d 45 d8	 lea	 eax, DWORD PTR _cBitUsed$[ebp]
  00429	50		 push	 eax
  0042a	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0042d	83 c1 30	 add	 ecx, 48			; 00000030H
  00430	51		 push	 ecx
  00431	68 00 00 00 00	 push	 OFFSET FLAT:_g_rgiHuffDecTblNoisePower
  00436	e8 00 00 00 00	 call	 _huffDecGet@20
  0043b	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0043e	83 7d f8 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00442	7d 45		 jge	 SHORT $L3252
  00444	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00447	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  0044d	74 2f		 je	 SHORT $L3436
  0044f	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00452	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00458	74 24		 je	 SHORT $L3436
  0045a	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0045d	51		 push	 ecx
  0045e	68 55 03 00 00	 push	 853			; 00000355H
  00463	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  00468	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0046d	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00470	52		 push	 edx
  00471	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00476	83 c4 14	 add	 esp, 20			; 00000014H
  00479	89 45 ac	 mov	 DWORD PTR tv253[ebp], eax
  0047c	eb 06		 jmp	 SHORT $L3437
$L3436:
  0047e	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00481	89 45 ac	 mov	 DWORD PTR tv253[ebp], eax
$L3437:
  00484	e9 9a 00 00 00	 jmp	 $exit$3215
$L3252:

; 854  :                             TRACEWMA_EXIT(wmaResult, ibstrmFlushBits(&paudec->m_ibstrm, cBitUsed));     //flush bits used by huffDecGet

  00489	8b 4d d8	 mov	 ecx, DWORD PTR _cBitUsed$[ebp]
  0048c	51		 push	 ecx
  0048d	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00490	83 c2 30	 add	 edx, 48			; 00000030H
  00493	52		 push	 edx
  00494	e8 00 00 00 00	 call	 _ibstrmFlushBits@8
  00499	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0049c	83 7d f8 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  004a0	7d 42		 jge	 SHORT $L3255
  004a2	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  004a5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  004ab	74 2f		 je	 SHORT $L3438
  004ad	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  004b0	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  004b6	74 24		 je	 SHORT $L3438
  004b8	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  004bb	52		 push	 edx
  004bc	68 56 03 00 00	 push	 854			; 00000356H
  004c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EL@FBOIFJNI@c?3?2xbox?2private?2windows?2directx?2@
  004c6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  004cb	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  004ce	50		 push	 eax
  004cf	e8 00 00 00 00	 call	 _MyOutputDbgStr
  004d4	83 c4 14	 add	 esp, 20			; 00000014H
  004d7	89 45 a8	 mov	 DWORD PTR tv267[ebp], eax
  004da	eb 06		 jmp	 SHORT $L3439
$L3438:
  004dc	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  004df	89 4d a8	 mov	 DWORD PTR tv267[ebp], ecx
$L3439:
  004e2	eb 3f		 jmp	 SHORT $exit$3215
$L3255:

; 855  :                             COUNT_BITS(*piBitCnt, cBitUsed);

  004e4	8b 55 0c	 mov	 edx, DWORD PTR _piBitCnt$[ebp]
  004e7	8b 02		 mov	 eax, DWORD PTR [edx]
  004e9	03 45 d8	 add	 eax, DWORD PTR _cBitUsed$[ebp]
  004ec	8b 4d 0c	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  004ef	89 01		 mov	 DWORD PTR [ecx], eax

; 856  : 					        rgiNoisePower [*piBand] = iCode - 18 + rgiNoisePower [*piBand - 1];

  004f1	8b 55 f0	 mov	 edx, DWORD PTR _piBand$[ebp]
  004f4	0f bf 02	 movsx	 eax, WORD PTR [edx]
  004f7	8b 4d c8	 mov	 ecx, DWORD PTR _rgiNoisePower$3239[ebp]
  004fa	8b 54 81 fc	 mov	 edx, DWORD PTR [ecx+eax*4-4]
  004fe	8b 45 e4	 mov	 eax, DWORD PTR _iCode$[ebp]
  00501	8d 4c 10 ee	 lea	 ecx, DWORD PTR [eax+edx-18]
  00505	8b 55 f0	 mov	 edx, DWORD PTR _piBand$[ebp]
  00508	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0050b	8b 55 c8	 mov	 edx, DWORD PTR _rgiNoisePower$3239[ebp]
  0050e	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx

; 857  : 
; 858  : 					        MONITOR_RANGE(gMR_rgiNoisePower,rgiNoisePower[*piBand]);
; 859  : 				        }

  00511	e9 e6 fe ff ff	 jmp	 $L3246
$L3237:

; 860  : 			        }
; 861  :                 }
; 862  :                 *piBand = 0;

  00516	8b 45 f0	 mov	 eax, DWORD PTR _piBand$[ebp]
  00519	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 863  :             }

  0051e	e9 da fd ff ff	 jmp	 $L3234
$exit$3215:

; 864  :     }
; 865  : 
; 866  : exit:
; 867  : 	FUNCTION_PROFILE_STOP(&fp);
; 868  :     return wmaResult;

  00523	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 869  : }

  00526	8b e5		 mov	 esp, ebp
  00528	5d		 pop	 ebp
  00529	c2 08 00	 ret	 8
_prvDecodeFrameHeaderNoiseSub_XDS@8 ENDP
WMADEC	ENDS
PUBLIC	_ffltAvgSquareWeights@8
PUBLIC	_ffltSqrtRatio@8
; Function compile flags: /Odt
;	COMDAT _prvGetBandWeightLowRate_XDS@4
WMADEC	SEGMENT
tv142 = -148
tv128 = -144
_rgffltSqrtBWRatio$3288 = -140
_rgfltBandWeight$3287 = -136
_rgxWeightFactor$3289 = -28
_iStart$ = -24
_iEnd$ = -20
_iBand$ = -16
_iChannel$ = -12
_cNoiseBand$ = -5
_rgbBandNotCoded$ = -4
_paudec$ = 8
_prvGetBandWeightLowRate_XDS@4 PROC NEAR		; COMDAT

; 1012 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H

; 1013 :     U8*	rgbBandNotCoded;
; 1014 :     Int iBand;
; 1015 :     Int iStart, iEnd;
; 1016 :     Int iChannel;
; 1017 : 	U8 cNoiseBand;
; 1018 : #if 0
; 1019 :     Int i;
; 1020 :     Float fltWeightFactor;
; 1021 :     Float fltInvBandWithd;
; 1022 : #endif
; 1023 :     FUNCTION_PROFILE(fp);
; 1024 :     FUNCTION_PROFILE_START(&fp,GET_BAND_WEIGHTS_PROFILE);
; 1025 : 
; 1026 :     //calculating band weight
; 1027 :     for (iChannel = 0; iChannel < paudec->pau->m_cChannel; iChannel++)   {

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iChannel$[ebp], 0
  00010	eb 09		 jmp	 SHORT $L3283
$L3284:
  00012	8b 45 f4	 mov	 eax, DWORD PTR _iChannel$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 f4	 mov	 DWORD PTR _iChannel$[ebp], eax
$L3283:
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  00024	39 45 f4	 cmp	 DWORD PTR _iChannel$[ebp], eax
  00027	0f 8d 02 02 00
	00		 jge	 $L3276

; 1028 :         if (paudec->pau->m_rgpcinfo [iChannel].m_iPower != 0) {

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00030	8b 11		 mov	 edx, DWORD PTR [ecx]
  00032	8b 45 f4	 mov	 eax, DWORD PTR _iChannel$[ebp]
  00035	6b c0 70	 imul	 eax, 112		; 00000070H
  00038	8b 8a a0 03 00
	00		 mov	 ecx, DWORD PTR [edx+928]
  0003e	83 7c 01 24 00	 cmp	 DWORD PTR [ecx+eax+36], 0
  00043	0f 84 e1 01 00
	00		 je	 $L3286

; 1029 : 		    FastFloat rgfltBandWeight[25];
; 1030 : 			FastFloat* rgffltSqrtBWRatio = paudec->pau->m_rgpcinfo[iChannel].m_rgffltSqrtBWRatio;

  00049	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0004c	8b 02		 mov	 eax, DWORD PTR [edx]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR _iChannel$[ebp]
  00051	6b c9 70	 imul	 ecx, 112		; 00000070H
  00054	8b 90 a0 03 00
	00		 mov	 edx, DWORD PTR [eax+928]
  0005a	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  0005e	89 85 74 ff ff
	ff		 mov	 DWORD PTR _rgffltSqrtBWRatio$3288[ebp], eax

; 1031 :             WeightType* rgxWeightFactor  = paudec->pau->m_rgpcinfo[iChannel].INTEGER_OR_INT_FLOAT(m_rguiWeightFactor,m_rgfltWeightFactor);

  00064	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00067	8b 11		 mov	 edx, DWORD PTR [ecx]
  00069	8b 45 f4	 mov	 eax, DWORD PTR _iChannel$[ebp]
  0006c	6b c0 70	 imul	 eax, 112		; 00000070H
  0006f	8b 8a a0 03 00
	00		 mov	 ecx, DWORD PTR [edx+928]
  00075	8b 54 01 68	 mov	 edx, DWORD PTR [ecx+eax+104]
  00079	89 55 e4	 mov	 DWORD PTR _rgxWeightFactor$3289[ebp], edx

; 1032 : 		    rgbBandNotCoded = paudec->pau->m_rgpcinfo[iChannel].m_rgbBandNotCoded;

  0007c	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  0007f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00081	8b 55 f4	 mov	 edx, DWORD PTR _iChannel$[ebp]
  00084	6b d2 70	 imul	 edx, 112		; 00000070H
  00087	8b 81 a0 03 00
	00		 mov	 eax, DWORD PTR [ecx+928]
  0008d	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  00091	89 4d fc	 mov	 DWORD PTR _rgbBandNotCoded$[ebp], ecx

; 1033 : 		    cNoiseBand = 0;

  00094	c6 45 fb 00	 mov	 BYTE PTR _cNoiseBand$[ebp], 0

; 1034 :             iStart = 0, iEnd = 0;

  00098	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iStart$[ebp], 0
  0009f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iEnd$[ebp], 0

; 1035 :             iBand = paudec->pau->m_iFirstNoiseBand;            

  000a6	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  000a9	8b 02		 mov	 eax, DWORD PTR [edx]
  000ab	8b 88 c0 03 00
	00		 mov	 ecx, DWORD PTR [eax+960]
  000b1	89 4d f0	 mov	 DWORD PTR _iBand$[ebp], ecx
$L3291:

; 1036 :             while (WMAB_TRUE)    {

  000b4	ba 01 00 00 00	 mov	 edx, 1
  000b9	85 d2		 test	 edx, edx
  000bb	0f 84 ff 00 00
	00		 je	 $L3292

; 1037 :                 iStart = max (paudec->pau->m_iFirstNoiseIndex, paudec->pau->m_rgiBarkIndex [iBand]);

  000c1	8b 45 08	 mov	 eax, DWORD PTR _paudec$[ebp]
  000c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c6	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  000c9	8b 02		 mov	 eax, DWORD PTR [edx]
  000cb	8b 90 54 03 00
	00		 mov	 edx, DWORD PTR [eax+852]
  000d1	8b 45 f0	 mov	 eax, DWORD PTR _iBand$[ebp]
  000d4	8b 89 c4 03 00
	00		 mov	 ecx, DWORD PTR [ecx+964]
  000da	3b 0c 82	 cmp	 ecx, DWORD PTR [edx+eax*4]
  000dd	7e 13		 jle	 SHORT $L3443
  000df	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  000e2	8b 02		 mov	 eax, DWORD PTR [edx]
  000e4	8b 88 c4 03 00
	00		 mov	 ecx, DWORD PTR [eax+964]
  000ea	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv128[ebp], ecx
  000f0	eb 17		 jmp	 SHORT $L3444
$L3443:
  000f2	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  000f5	8b 02		 mov	 eax, DWORD PTR [edx]
  000f7	8b 88 54 03 00
	00		 mov	 ecx, DWORD PTR [eax+852]
  000fd	8b 55 f0	 mov	 edx, DWORD PTR _iBand$[ebp]
  00100	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00103	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv128[ebp], eax
$L3444:
  00109	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv128[ebp]
  0010f	89 4d e8	 mov	 DWORD PTR _iStart$[ebp], ecx

; 1038 :                 if (iStart >= paudec->pau->m_cHighCutOff)

  00112	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  00115	8b 02		 mov	 eax, DWORD PTR [edx]
  00117	8b 4d e8	 mov	 ecx, DWORD PTR _iStart$[ebp]
  0011a	3b 88 28 03 00
	00		 cmp	 ecx, DWORD PTR [eax+808]
  00120	7c 05		 jl	 SHORT $L3293

; 1039 :                     break;

  00122	e9 99 00 00 00	 jmp	 $L3292
$L3293:

; 1040 :                 assert (iBand < paudec->pau->m_cValidBarkBand);
; 1041 :                 iEnd   = min (paudec->pau->m_cHighCutOff, paudec->pau->m_rgiBarkIndex [iBand + 1]);

  00127	8b 55 08	 mov	 edx, DWORD PTR _paudec$[ebp]
  0012a	8b 02		 mov	 eax, DWORD PTR [edx]
  0012c	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0012f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00131	8b 8a 54 03 00
	00		 mov	 ecx, DWORD PTR [edx+852]
  00137	8b 55 f0	 mov	 edx, DWORD PTR _iBand$[ebp]
  0013a	8b 80 28 03 00
	00		 mov	 eax, DWORD PTR [eax+808]
  00140	3b 44 91 04	 cmp	 eax, DWORD PTR [ecx+edx*4+4]
  00144	7d 13		 jge	 SHORT $L3445
  00146	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  00149	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014b	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  00151	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv142[ebp], eax
  00157	eb 18		 jmp	 SHORT $L3446
$L3445:
  00159	8b 4d 08	 mov	 ecx, DWORD PTR _paudec$[ebp]
  0015c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0015e	8b 82 54 03 00
	00		 mov	 eax, DWORD PTR [edx+852]
  00164	8b 4d f0	 mov	 ecx, DWORD PTR _iBand$[ebp]
  00167	8b 54 88 04	 mov	 edx, DWORD PTR [eax+ecx*4+4]
  0016b	89 95 6c ff ff
	ff		 mov	 DWORD PTR tv142[ebp], edx
$L3446:
  00171	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv142[ebp]
  00177	89 45 ec	 mov	 DWORD PTR _iEnd$[ebp], eax

; 1042 :                 assert (iEnd >= iStart);
; 1043 : 
; 1044 : 			    if (rgbBandNotCoded [iBand] == 1)	{

  0017a	8b 4d fc	 mov	 ecx, DWORD PTR _rgbBandNotCoded$[ebp]
  0017d	03 4d f0	 add	 ecx, DWORD PTR _iBand$[ebp]
  00180	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00183	83 fa 01	 cmp	 edx, 1
  00186	75 2a		 jne	 SHORT $L3294

; 1045 :                     // This may be slower than straight divide, but we must do this to
; 1046 :                     // remain consistent with prvGetNoiseLikeBandsMono
; 1047 :                     rgfltBandWeight [cNoiseBand] = FFLT_AVG_SQUARE_WEIGHTS( rgxWeightFactor+iStart, iEnd-iStart );

  00188	8b 45 ec	 mov	 eax, DWORD PTR _iEnd$[ebp]
  0018b	2b 45 e8	 sub	 eax, DWORD PTR _iStart$[ebp]
  0018e	50		 push	 eax
  0018f	8b 4d e8	 mov	 ecx, DWORD PTR _iStart$[ebp]
  00192	8b 55 e4	 mov	 edx, DWORD PTR _rgxWeightFactor$3289[ebp]
  00195	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _ffltAvgSquareWeights@8
  0019e	0f b6 4d fb	 movzx	 ecx, BYTE PTR _cNoiseBand$[ebp]
  001a2	d9 9c 8d 78 ff
	ff ff		 fstp	 DWORD PTR _rgfltBandWeight$3287[ebp+ecx*4]

; 1048 :                     //// rgfltBandWeight[cNoiseBand].iFraction*1.0F/(1<<rgfltBandWeight[cNoiseBand].iFracBits)
; 1049 : 					MONITOR_RANGE(gMR_rgfltBandWeight,FLOAT_FROM_FASTFLOAT(rgfltBandWeight[cNoiseBand]));
; 1050 : 					MONITOR_COUNT(gMC_GBW_floats,1+(iEnd-iStart)*2 );
; 1051 : 				    cNoiseBand++;

  001a9	8a 55 fb	 mov	 dl, BYTE PTR _cNoiseBand$[ebp]
  001ac	80 c2 01	 add	 dl, 1
  001af	88 55 fb	 mov	 BYTE PTR _cNoiseBand$[ebp], dl
$L3294:

; 1052 : 			    }
; 1053 :                 SHOW_NOISE_BANDS_ONCE;
; 1054 :                 iBand++;

  001b2	8b 45 f0	 mov	 eax, DWORD PTR _iBand$[ebp]
  001b5	83 c0 01	 add	 eax, 1
  001b8	89 45 f0	 mov	 DWORD PTR _iBand$[ebp], eax

; 1055 : 		    }

  001bb	e9 f4 fe ff ff	 jmp	 $L3291
$L3292:

; 1056 : 		    assert (cNoiseBand < paudec->pau->m_cValidBarkBand);
; 1057 : 		    assert (paudec->pau->m_iFirstNoiseBand > 0);
; 1058 : 			for( iBand = 0; iBand < (cNoiseBand-1); iBand++ )

  001c0	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iBand$[ebp], 0
  001c7	eb 09		 jmp	 SHORT $L3295
$L3296:
  001c9	8b 4d f0	 mov	 ecx, DWORD PTR _iBand$[ebp]
  001cc	83 c1 01	 add	 ecx, 1
  001cf	89 4d f0	 mov	 DWORD PTR _iBand$[ebp], ecx
$L3295:
  001d2	0f b6 55 fb	 movzx	 edx, BYTE PTR _cNoiseBand$[ebp]
  001d6	83 ea 01	 sub	 edx, 1
  001d9	39 55 f0	 cmp	 DWORD PTR _iBand$[ebp], edx
  001dc	7d 2a		 jge	 SHORT $L3297

; 1059 : 			{	
; 1060 : 				// This calculation is not ideally suited to FastFloat, leave in float for time being
; 1061 : 				// But note that limited range of the result probably means it can be done more quickly
; 1062 :                 rgffltSqrtBWRatio[iBand] = FFLT_SQRT_RATIO( rgfltBandWeight[iBand], rgfltBandWeight[cNoiseBand-1] );

  001de	0f b6 45 fb	 movzx	 eax, BYTE PTR _cNoiseBand$[ebp]
  001e2	8b 8c 85 74 ff
	ff ff		 mov	 ecx, DWORD PTR _rgfltBandWeight$3287[ebp+eax*4-4]
  001e9	51		 push	 ecx
  001ea	8b 55 f0	 mov	 edx, DWORD PTR _iBand$[ebp]
  001ed	8b 84 95 78 ff
	ff ff		 mov	 eax, DWORD PTR _rgfltBandWeight$3287[ebp+edx*4]
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 _ffltSqrtRatio@8
  001fa	8b 4d f0	 mov	 ecx, DWORD PTR _iBand$[ebp]
  001fd	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _rgffltSqrtBWRatio$3288[ebp]
  00203	d9 1c 8a	 fstp	 DWORD PTR [edx+ecx*4]

; 1063 : 				//// float SqrtBWRatio = fflt.iFraction*1.0F/(1<<fflt.iFracBits)
; 1064 : 				MONITOR_RANGE(gMR_rgffltSqrtBWRatio,FLOAT_FROM_FASTFLOAT(rgffltSqrtBWRatio[iBand]));
; 1065 : 				MONITOR_COUNT(gMC_GBW_floats,14);		// count sqrt as 10.
; 1066 : 			}

  00206	eb c1		 jmp	 SHORT $L3296
$L3297:

; 1067 : 			if (cNoiseBand > 0)

  00208	0f b6 45 fb	 movzx	 eax, BYTE PTR _cNoiseBand$[ebp]
  0020c	85 c0		 test	 eax, eax
  0020e	7e 12		 jle	 SHORT $L3298

; 1068 : 			{	// last band has a ratio of 1.0
; 1069 : #if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
; 1070 : 				rgffltSqrtBWRatio[cNoiseBand-1].iFraction = 0x40000000;
; 1071 : 				rgffltSqrtBWRatio[cNoiseBand-1].iFracBits = 30;
; 1072 : #else
; 1073 : 				rgffltSqrtBWRatio[cNoiseBand-1] = 1.0F;

  00210	0f b6 4d fb	 movzx	 ecx, BYTE PTR _cNoiseBand$[ebp]
  00214	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _rgffltSqrtBWRatio$3288[ebp]
  0021a	c7 44 8a fc 00
	00 80 3f	 mov	 DWORD PTR [edx+ecx*4-4], 1065353216 ; 3f800000H
$L3298:

; 1074 : #endif
; 1075 : 				MONITOR_RANGE(gMR_rgffltSqrtBWRatio,1.0F);
; 1076 : 			}
; 1077 : 		    rgbBandNotCoded [0] = cNoiseBand; //used as cNoiseBand

  00222	8b 45 fc	 mov	 eax, DWORD PTR _rgbBandNotCoded$[ebp]
  00225	8a 4d fb	 mov	 cl, BYTE PTR _cNoiseBand$[ebp]
  00228	88 08		 mov	 BYTE PTR [eax], cl
$L3286:

; 1078 :         }
; 1079 :     }

  0022a	e9 e3 fd ff ff	 jmp	 $L3284
$L3276:

; 1080 :     FUNCTION_PROFILE_STOP(&fp);
; 1081 : }

  0022f	8b e5		 mov	 esp, ebp
  00231	5d		 pop	 ebp
  00232	c2 04 00	 ret	 4
_prvGetBandWeightLowRate_XDS@4 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _ffltAvgSquareWeights@8
WMADEC	SEGMENT
_fltSum$ = -8
_i$ = -4
_pwtWeightFactor$ = 8
_cN$ = 12
_ffltAvgSquareWeights@8 PROC NEAR			; COMDAT

; 903  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 904  :             Float fltSum = 0;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fltSum$[ebp], 0

; 905  :             Int i = cN;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _cN$[ebp]
  00010	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 906  : 	        for ( ; i > 0; i--, pwtWeightFactor++) {

  00013	eb 12		 jmp	 SHORT $L3264
$L3265:
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00018	83 e9 01	 sub	 ecx, 1
  0001b	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0001e	8b 55 08	 mov	 edx, DWORD PTR _pwtWeightFactor$[ebp]
  00021	83 c2 04	 add	 edx, 4
  00024	89 55 08	 mov	 DWORD PTR _pwtWeightFactor$[ebp], edx
$L3264:
  00027	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0002b	7e 12		 jle	 SHORT $L3266

; 907  :                 fltSum += *pwtWeightFactor * *pwtWeightFactor;

  0002d	8b 45 08	 mov	 eax, DWORD PTR _pwtWeightFactor$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _pwtWeightFactor$[ebp]
  00033	d9 00		 fld	 DWORD PTR [eax]
  00035	d8 09		 fmul	 DWORD PTR [ecx]
  00037	d8 45 f8	 fadd	 DWORD PTR _fltSum$[ebp]
  0003a	d9 5d f8	 fstp	 DWORD PTR _fltSum$[ebp]

; 908  : 	        }

  0003d	eb d6		 jmp	 SHORT $L3265
$L3266:

; 909  :             return fltSum/cN;

  0003f	db 45 0c	 fild	 DWORD PTR _cN$[ebp]
  00042	d8 7d f8	 fdivr	 DWORD PTR _fltSum$[ebp]

; 910  :         }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
_ffltAvgSquareWeights@8 ENDP
WMADEC	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt
;	COMDAT _ffltSqrtRatio@8
WMADEC	SEGMENT
tv72 = -4
_fflt1$ = 8
_fflt2$ = 12
_ffltSqrtRatio@8 PROC NEAR				; COMDAT

; 918  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 919  : #       if defined(BUILD_INTEGER)
; 920  :             U64 u64Ratio;
; 921  :             FastFloat fflt;
; 922  :             Int iMSF8;
; 923  :             U32 uiMSF;
; 924  :             U32 uiFrac1;
; 925  :             Int iExp = 0;
; 926  :             if ( fflt2.iFraction==0 ) {
; 927  :                 assert( fflt2.iFraction != 0 ); // divide by 0
; 928  :                 fflt.iFraction = 0x7FFFFFFF;
; 929  :                 fflt.iFracBits = 0;
; 930  :                 return fflt;
; 931  :             }
; 932  :             //// fflt1.iFraction*0.5F/(1<<(fflt1.iFracBits-1))
; 933  :             //// fflt2.iFraction*0.5F/(1<<(fflt2.iFracBits-1))
; 934  :             u64Ratio = (((U64)fflt1.iFraction)<<32)/fflt2.iFraction;
; 935  :             uiMSF = (U32)(u64Ratio>>32);
; 936  :             if ( uiMSF==0 ) {
; 937  :                 iExp = 32;
; 938  :                 uiMSF = (U32)u64Ratio;
; 939  :             }
; 940  :             assert( uiMSF != 0 ) ;
; 941  :             // normalize the most significant fractional part
; 942  :             while( (uiMSF & 0xF0000000)==0 ) {
; 943  :                 iExp += 4;
; 944  :                 uiMSF <<= 4;
; 945  :             }
; 946  :             while( (uiMSF & 0x80000000)==0 ) {
; 947  :                 iExp++;
; 948  :                 uiMSF <<= 1;
; 949  :             }
; 950  :             // discard the most significant one bit (it's presence is built into g_InvQuadRootFraction)
; 951  :             iExp++;
; 952  :             // get all 32 bits from source
; 953  : #           if defined(PLATFORM_OPTIMIZE_MINIMIZE_BRANCHING)
; 954  :                 uiMSF = (U32)((u64Ratio<<iExp)>>32);
; 955  : #           else
; 956  :                 uiMSF = (iExp>32) ? (U32)(u64Ratio<<(iExp-32)) : (U32)(u64Ratio>>(32-iExp));
; 957  : #           endif
; 958  :             // split into top SQRT_FRACTION_TABLE_LOG2_SIZE==8 bits for fractional lookup and bottom bits for interpolation
; 959  :             iMSF8 = uiMSF>>(32-SQRT_FRACTION_TABLE_LOG2_SIZE);
; 960  :             uiMSF <<= SQRT_FRACTION_TABLE_LOG2_SIZE;
; 961  :             // lookup and interpolate
; 962  :             uiFrac1  = g_SqrtFraction[iMSF8++];   // BP2
; 963  :             uiFrac1 += MULT_HI_UDWORD( uiMSF,  g_SqrtFraction[iMSF8] - uiFrac1 );
; 964  :             // adjust by sqrt(1/2) if expoenent is odd
; 965  :             if ( (iExp+fflt1.iFracBits-fflt2.iFracBits) & 1 ) {
; 966  :                 // multiply by 1/sqrt(2) and adjust fracbits by 1/2
; 967  :                 uiFrac1 = MULT_HI_UDWORD( uiFrac1, UBP0_FROM_FLOAT(0.70710678118654752440084436210485) );
; 968  :                 fflt.iFracBits = ((fflt1.iFracBits-(fflt2.iFracBits+1))>>1)+(iExp-3);
; 969  :             } else {
; 970  :                 fflt.iFracBits = ((fflt1.iFracBits-fflt2.iFracBits)>>1)+(iExp-3);
; 971  :             }
; 972  :             fflt.iFraction = uiFrac1>>1;    // make sure sign is positive
; 973  :             //// fflt.iFraction*0.5F/(1<<(fflt.iFracBits-1))
; 974  : 			Norm4FastFloatU( &fflt );
; 975  : #           if defined(_DEBUG) && 0
; 976  :             {   // old way used float
; 977  : 			    Float flt = (Float)sqrt( FloatFromFastFloat(fflt1) / FloatFromFastFloat(fflt2) );
; 978  :                 if ( fabs( flt - FloatFromFastFloat(fflt) ) > 0.01 ) {
; 979  :                     DEBUG_BREAK();
; 980  :                 }
; 981  :             }
; 982  : #           endif
; 983  :             return fflt;
; 984  : #       else
; 985  : 			return (Float)sqrt( fflt1 / fflt2 );

  00004	d9 45 08	 fld	 DWORD PTR _fflt1$[ebp]
  00007	d8 75 0c	 fdiv	 DWORD PTR _fflt2$[ebp]
  0000a	83 ec 08	 sub	 esp, 8
  0000d	dd 1c 24	 fstp	 QWORD PTR [esp]
  00010	e8 00 00 00 00	 call	 _sqrt
  00015	83 c4 08	 add	 esp, 8
  00018	d9 55 fc	 fst	 DWORD PTR tv72[ebp]

; 986  : #       endif
; 987  :     }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
_ffltSqrtRatio@8 ENDP
WMADEC	ENDS
END
