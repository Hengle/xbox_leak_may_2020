; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\voiceencoder.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Direct3D_AddRef@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Direct3D_Release@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Direct3D_GetAdapterCount@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_BeginScene@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_EndScene@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_GetRenderState@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_GetTextureStageState@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_SetRenderState@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_SetTextureStageState@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DResource_MoveResourceMemory@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DTexture_UnlockRect@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DVolumeTexture_UnlockBox@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DCubeTexture_UnlockRect@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DVertexBuffer_Unlock@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DIndexBuffer_Lock@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DIndexBuffer_Unlock@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DPalette_Unlock@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DSurface_UnlockRect@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DVolume_UnlockBox@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXPLANE@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DV_log_1_354@@YGEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DV_log_2@@YGEG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CVoiceEncoderXmo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CVoiceEncoderXmo@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CVoiceEncoderXmo@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XMediaObject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCVoiceEncoderXmo@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceEncoderCreateMediaObject@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CVoiceEncoderXmo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CVoiceEncoderXmo@@QAEJKKPAUtWAVEFORMATEX@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Flush@CVoiceEncoderXmo@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Process@CVoiceEncoderXmo@@UAGJPBU_XMEDIAPACKET@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInfo@CVoiceEncoderXmo@@UAGJPAU_XMEDIAINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Discontinuity@CVoiceEncoderXmo@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStatus@CVoiceEncoderXmo@@UAGJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7XMediaObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CVoiceEncoderXmo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_D3DPRIMITIVETOVERTEXCOUNT
PUBLIC	_D3DSIMPLERENDERSTATEENCODE
PUBLIC	_D3DTEXTUREDIRECTENCODE
PUBLIC	_D3DDIRTYFROMRENDERSTATE
PUBLIC	_D3DDIRTYFROMTEXTURESTATE
PUBLIC	?DV_LOG_1_354_lookup_table@@3PAEA		; DV_LOG_1_354_lookup_table
PUBLIC	_XVoiceBuildNumberD
PUBLIC	?g_VeXmoDebugLevel@@3KA				; g_VeXmoDebugLevel
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
CONST	SEGMENT
_D3DPRIMITIVETOVERTEXCOUNT DD 00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
CONST	SEGMENT
_D3DSIMPLERENDERSTATEENCODE DD 040260H
	DD	040264H
	DD	040268H
	DD	04026cH
	DD	040270H
	DD	040274H
	DD	040278H
	DD	04027cH
	DD	040288H
	DD	04028cH
	DD	040a60H
	DD	040a64H
	DD	040a68H
	DD	040a6cH
	DD	040a70H
	DD	040a74H
	DD	040a78H
	DD	040a7cH
	DD	040a80H
	DD	040a84H
	DD	040a88H
	DD	040a8cH
	DD	040a90H
	DD	040a94H
	DD	040a98H
	DD	040a9cH
	DD	040aa0H
	DD	040aa4H
	DD	040aa8H
	DD	040aacH
	DD	040ab0H
	DD	040ab4H
	DD	040ab8H
	DD	040abcH
	DD	040ac0H
	DD	040ac4H
	DD	040ac8H
	DD	040accH
	DD	040ad0H
	DD	040ad4H
	DD	040ad8H
	DD	040adcH
	DD	0417f8H
	DD	041e20H
	DD	041e24H
	DD	041e40H
	DD	041e44H
	DD	041e48H
	DD	041e4cH
	DD	041e50H
	DD	041e54H
	DD	041e58H
	DD	041e5cH
	DD	041e60H
	DD	041d90H
	DD	041e74H
	DD	041e78H
	DD	040354H
	DD	04033cH
	DD	040304H
	DD	040300H
	DD	040340H
	DD	040344H
	DD	040348H
	DD	04035cH
	DD	040310H
	DD	04037cH
	DD	040358H
	DD	040374H
	DD	040378H
	DD	040364H
	DD	040368H
	DD	04036cH
	DD	040360H
	DD	040350H
	DD	04034cH
	DD	0409f8H
	DD	040384H
	DD	040388H
	DD	040330H
	DD	040334H
	DD	040338H
CONST	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
CONST	SEGMENT
_D3DTEXTUREDIRECTENCODE DD 081b00H
	DD	081b40H
	DD	081b80H
	DD	081bc0H
CONST	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
CONST	SEGMENT
_D3DDIRTYFROMRENDERSTATE DD 02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	01200H
	DD	03000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	0100H
	DD	0100H
	DD	0900H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
CONST	SEGMENT
_D3DDIRTYFROMTEXTURESTATE DD 0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0480fH
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0400H
CONST	ENDS
_DATA	SEGMENT
?DV_LOG_1_354_lookup_table@@3PAEA DB 00H		; DV_LOG_1_354_lookup_table
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
_DATA	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
_DATA	SEGMENT
	ORG $+1
?g_VeXmoDebugLevel@@3KA DD 02H				; g_VeXmoDebugLevel
_DATA	ENDS
PUBLIC	?DV_log_1_354@@YGEE@Z				; DV_log_1_354
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\voiceenc\voiceencoderp.h
;	COMDAT ?DV_log_1_354@@YGEE@Z
_TEXT	SEGMENT
_n$ = 8
?DV_log_1_354@@YGEE@Z PROC NEAR				; DV_log_1_354, COMDAT

; 266  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 267  : 	if (n > 94) return 15;

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _n$[ebp]
  00007	83 f8 5e	 cmp	 eax, 94			; 0000005eH
  0000a	7e 04		 jle	 SHORT $L25924
  0000c	b0 0f		 mov	 al, 15			; 0000000fH
  0000e	eb 0a		 jmp	 SHORT $L25923
$L25924:

; 268  : 	return DV_LOG_1_354_lookup_table[n];

  00010	0f b6 4d 08	 movzx	 ecx, BYTE PTR _n$[ebp]
  00014	8a 81 00 00 00
	00		 mov	 al, BYTE PTR ?DV_LOG_1_354_lookup_table@@3PAEA[ecx]
$L25923:

; 269  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?DV_log_1_354@@YGEE@Z ENDP				; DV_log_1_354
_TEXT	ENDS
PUBLIC	?DV_log_2@@YGEG@Z				; DV_log_2
; Function compile flags: /Odt
;	COMDAT ?DV_log_2@@YGEG@Z
_TEXT	SEGMENT
_n$ = 8
?DV_log_2@@YGEG@Z PROC NEAR				; DV_log_2, COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 276  : 	if (n & 0x8000)

  00003	0f b7 45 08	 movzx	 eax, WORD PTR _n$[ebp]
  00007	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  0000c	85 c0		 test	 eax, eax
  0000e	74 07		 je	 SHORT $L25928

; 277  : 	{
; 278  : 		return 0x0f;

  00010	b0 0f		 mov	 al, 15			; 0000000fH
  00012	e9 fc 00 00 00	 jmp	 $L25927
$L25928:

; 279  : 	}
; 280  : 	if (n & 0x4000)

  00017	0f b7 4d 08	 movzx	 ecx, WORD PTR _n$[ebp]
  0001b	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  00021	85 c9		 test	 ecx, ecx
  00023	74 07		 je	 SHORT $L25929

; 281  : 	{
; 282  : 		return 0x0e;

  00025	b0 0e		 mov	 al, 14			; 0000000eH
  00027	e9 e7 00 00 00	 jmp	 $L25927
$L25929:

; 283  : 	}
; 284  : 	if (n & 0x2000)

  0002c	0f b7 55 08	 movzx	 edx, WORD PTR _n$[ebp]
  00030	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  00036	85 d2		 test	 edx, edx
  00038	74 07		 je	 SHORT $L25930

; 285  : 	{
; 286  : 		return 0x0d;

  0003a	b0 0d		 mov	 al, 13			; 0000000dH
  0003c	e9 d2 00 00 00	 jmp	 $L25927
$L25930:

; 287  : 	}
; 288  : 	if (n & 0x1000)

  00041	0f b7 45 08	 movzx	 eax, WORD PTR _n$[ebp]
  00045	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  0004a	85 c0		 test	 eax, eax
  0004c	74 07		 je	 SHORT $L25931

; 289  : 	{
; 290  : 		return 0x0c;

  0004e	b0 0c		 mov	 al, 12			; 0000000cH
  00050	e9 be 00 00 00	 jmp	 $L25927
$L25931:

; 291  : 	}
; 292  : 	if (n & 0x0800)

  00055	0f b7 4d 08	 movzx	 ecx, WORD PTR _n$[ebp]
  00059	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  0005f	85 c9		 test	 ecx, ecx
  00061	74 07		 je	 SHORT $L25932

; 293  : 	{
; 294  : 		return 0x0b;

  00063	b0 0b		 mov	 al, 11			; 0000000bH
  00065	e9 a9 00 00 00	 jmp	 $L25927
$L25932:

; 295  : 	}
; 296  : 	if (n & 0x0400)

  0006a	0f b7 55 08	 movzx	 edx, WORD PTR _n$[ebp]
  0006e	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  00074	85 d2		 test	 edx, edx
  00076	74 07		 je	 SHORT $L25933

; 297  : 	{
; 298  : 		return 0x0a;

  00078	b0 0a		 mov	 al, 10			; 0000000aH
  0007a	e9 94 00 00 00	 jmp	 $L25927
$L25933:

; 299  : 	}
; 300  : 	if (n & 0x0200)

  0007f	0f b7 45 08	 movzx	 eax, WORD PTR _n$[ebp]
  00083	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00088	85 c0		 test	 eax, eax
  0008a	74 07		 je	 SHORT $L25934

; 301  : 	{
; 302  : 		return 0x09;

  0008c	b0 09		 mov	 al, 9
  0008e	e9 80 00 00 00	 jmp	 $L25927
$L25934:

; 303  : 	}
; 304  : 	if (n & 0x0100)

  00093	0f b7 4d 08	 movzx	 ecx, WORD PTR _n$[ebp]
  00097	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  0009d	85 c9		 test	 ecx, ecx
  0009f	74 04		 je	 SHORT $L25935

; 305  : 	{
; 306  : 		return 0x08;

  000a1	b0 08		 mov	 al, 8
  000a3	eb 6e		 jmp	 SHORT $L25927
$L25935:

; 307  : 	}
; 308  : 	if (n & 0x0080)

  000a5	0f b7 55 08	 movzx	 edx, WORD PTR _n$[ebp]
  000a9	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  000af	85 d2		 test	 edx, edx
  000b1	74 04		 je	 SHORT $L25936

; 309  : 	{
; 310  : 		return 0x07;

  000b3	b0 07		 mov	 al, 7
  000b5	eb 5c		 jmp	 SHORT $L25927
$L25936:

; 311  : 	}
; 312  : 	if (n & 0x0040)

  000b7	0f b7 45 08	 movzx	 eax, WORD PTR _n$[ebp]
  000bb	83 e0 40	 and	 eax, 64			; 00000040H
  000be	85 c0		 test	 eax, eax
  000c0	74 04		 je	 SHORT $L25937

; 313  : 	{
; 314  : 		return 0x06;

  000c2	b0 06		 mov	 al, 6
  000c4	eb 4d		 jmp	 SHORT $L25927
$L25937:

; 315  : 	}
; 316  : 	if (n & 0x0020)

  000c6	0f b7 4d 08	 movzx	 ecx, WORD PTR _n$[ebp]
  000ca	83 e1 20	 and	 ecx, 32			; 00000020H
  000cd	85 c9		 test	 ecx, ecx
  000cf	74 04		 je	 SHORT $L25938

; 317  : 	{
; 318  : 		return 0x05;

  000d1	b0 05		 mov	 al, 5
  000d3	eb 3e		 jmp	 SHORT $L25927
$L25938:

; 319  : 	}
; 320  : 	if (n & 0x0010)

  000d5	0f b7 55 08	 movzx	 edx, WORD PTR _n$[ebp]
  000d9	83 e2 10	 and	 edx, 16			; 00000010H
  000dc	85 d2		 test	 edx, edx
  000de	74 04		 je	 SHORT $L25939

; 321  : 	{
; 322  : 		return 0x04;

  000e0	b0 04		 mov	 al, 4
  000e2	eb 2f		 jmp	 SHORT $L25927
$L25939:

; 323  : 	}
; 324  : 	if (n & 0x0008)

  000e4	0f b7 45 08	 movzx	 eax, WORD PTR _n$[ebp]
  000e8	83 e0 08	 and	 eax, 8
  000eb	85 c0		 test	 eax, eax
  000ed	74 04		 je	 SHORT $L25940

; 325  : 	{
; 326  : 		return 0x03;

  000ef	b0 03		 mov	 al, 3
  000f1	eb 20		 jmp	 SHORT $L25927
$L25940:

; 327  : 	}
; 328  : 	if (n & 0x0004)

  000f3	0f b7 4d 08	 movzx	 ecx, WORD PTR _n$[ebp]
  000f7	83 e1 04	 and	 ecx, 4
  000fa	85 c9		 test	 ecx, ecx
  000fc	74 04		 je	 SHORT $L25941

; 329  : 	{
; 330  : 		return 0x02;

  000fe	b0 02		 mov	 al, 2
  00100	eb 11		 jmp	 SHORT $L25927
$L25941:

; 331  : 	}
; 332  : 	if (n & 0x0002)

  00102	0f b7 55 08	 movzx	 edx, WORD PTR _n$[ebp]
  00106	83 e2 02	 and	 edx, 2
  00109	85 d2		 test	 edx, edx
  0010b	74 04		 je	 SHORT $L25942

; 333  : 	{
; 334  : 		return 0x01;

  0010d	b0 01		 mov	 al, 1
  0010f	eb 02		 jmp	 SHORT $L25927
$L25942:

; 335  : 	}
; 336  : 	return 0x00;

  00111	32 c0		 xor	 al, al
$L25927:

; 337  : }

  00113	5d		 pop	 ebp
  00114	c2 04 00	 ret	 4
?DV_log_2@@YGEG@Z ENDP					; DV_log_2
_TEXT	ENDS
PUBLIC	_XVoiceEncoderCreateMediaObject@20
PUBLIC	??0CVoiceEncoderXmo@@QAE@XZ			; CVoiceEncoderXmo::CVoiceEncoderXmo
PUBLIC	?Init@CVoiceEncoderXmo@@QAEJKKPAUtWAVEFORMATEX@@K@Z ; CVoiceEncoderXmo::Init
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\voiceenc\voiceencoder.cpp
;	COMDAT _XVoiceEncoderCreateMediaObject@20
_TEXT	SEGMENT
tv69 = -16
$T26212 = -12
_hr$ = -8
_pXmo$ = -4
_fAutoMode$ = 8
_dwCodecTag$ = 12
_pwfx$ = 16
_dwThreshold$ = 20
_ppXMO$ = 24
_XVoiceEncoderCreateMediaObject@20 PROC NEAR		; COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 76   :     XMediaObject *pXmo;
; 77   :     HRESULT hr;
; 78   : 
; 79   :     pXmo = new CVoiceEncoderXmo();

  00006	6a 44		 push	 68			; 00000044H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	83 c4 04	 add	 esp, 4
  00010	89 45 f4	 mov	 DWORD PTR $T26212[ebp], eax
  00013	83 7d f4 00	 cmp	 DWORD PTR $T26212[ebp], 0
  00017	74 0d		 je	 SHORT $L26213
  00019	8b 4d f4	 mov	 ecx, DWORD PTR $T26212[ebp]
  0001c	e8 00 00 00 00	 call	 ??0CVoiceEncoderXmo@@QAE@XZ ; CVoiceEncoderXmo::CVoiceEncoderXmo
  00021	89 45 f0	 mov	 DWORD PTR tv69[ebp], eax
  00024	eb 07		 jmp	 SHORT $L26214
$L26213:
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L26214:
  0002d	8b 45 f0	 mov	 eax, DWORD PTR tv69[ebp]
  00030	89 45 fc	 mov	 DWORD PTR _pXmo$[ebp], eax

; 80   :     MY_ASSERT(pXmo);

  00033	83 7d fc 00	 cmp	 DWORD PTR _pXmo$[ebp], 0
  00037	75 01		 jne	 SHORT $L26033
  00039	cc		 int	 3
$L26033:

; 81   : 
; 82   :     if (pXmo == NULL) {

  0003a	83 7d fc 00	 cmp	 DWORD PTR _pXmo$[ebp], 0
  0003e	75 07		 jne	 SHORT $L26034

; 83   :         return E_OUTOFMEMORY;

  00040	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00045	eb 2c		 jmp	 SHORT $L26028
$L26034:

; 84   :     }
; 85   : 
; 86   :     hr = ((CVoiceEncoderXmo *)pXmo)->Init(
; 87   :              fAutoMode,
; 88   :              dwCodecTag,
; 89   :              pwfx,
; 90   :              dwThreshold);

  00047	8b 4d 14	 mov	 ecx, DWORD PTR _dwThreshold$[ebp]
  0004a	51		 push	 ecx
  0004b	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0004e	52		 push	 edx
  0004f	8b 45 0c	 mov	 eax, DWORD PTR _dwCodecTag$[ebp]
  00052	50		 push	 eax
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _fAutoMode$[ebp]
  00056	51		 push	 ecx
  00057	8b 4d fc	 mov	 ecx, DWORD PTR _pXmo$[ebp]
  0005a	e8 00 00 00 00	 call	 ?Init@CVoiceEncoderXmo@@QAEJKKPAUtWAVEFORMATEX@@K@Z ; CVoiceEncoderXmo::Init
  0005f	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 91   : 
; 92   :     if (SUCCEEDED(hr)) {

  00062	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00066	7c 08		 jl	 SHORT $L26038

; 93   : 
; 94   :         *ppXMO = pXmo;

  00068	8b 55 18	 mov	 edx, DWORD PTR _ppXMO$[ebp]
  0006b	8b 45 fc	 mov	 eax, DWORD PTR _pXmo$[ebp]
  0006e	89 02		 mov	 DWORD PTR [edx], eax
$L26038:

; 95   : 
; 96   :     }
; 97   : 
; 98   :     return hr;

  00070	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
$L26028:

; 99   : 
; 100  : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 14 00	 ret	 20			; 00000014H
_XVoiceEncoderCreateMediaObject@20 ENDP
_TEXT	ENDS
PUBLIC	??0XMediaObject@@QAE@XZ				; XMediaObject::XMediaObject
PUBLIC	?AddRef@CVoiceEncoderXmo@@UAGKXZ		; CVoiceEncoderXmo::AddRef
PUBLIC	?Release@CVoiceEncoderXmo@@UAGKXZ		; CVoiceEncoderXmo::Release
PUBLIC	?Process@CVoiceEncoderXmo@@UAGJPBU_XMEDIAPACKET@@0@Z ; CVoiceEncoderXmo::Process
PUBLIC	?GetInfo@CVoiceEncoderXmo@@UAGJPAU_XMEDIAINFO@@@Z ; CVoiceEncoderXmo::GetInfo
PUBLIC	?Flush@CVoiceEncoderXmo@@UAGJXZ			; CVoiceEncoderXmo::Flush
PUBLIC	?Discontinuity@CVoiceEncoderXmo@@UAGJXZ		; CVoiceEncoderXmo::Discontinuity
PUBLIC	?GetStatus@CVoiceEncoderXmo@@UAGJPAK@Z		; CVoiceEncoderXmo::GetStatus
PUBLIC	??_7CVoiceEncoderXmo@@6B@			; CVoiceEncoderXmo::`vftable'
;	COMDAT ??_7CVoiceEncoderXmo@@6B@
; File c:\xbox\private\windows\directx\dsound\codecs\voiceenc\voiceencoderp.h
CONST	SEGMENT
??_7CVoiceEncoderXmo@@6B@ DD FLAT:?AddRef@CVoiceEncoderXmo@@UAGKXZ ; CVoiceEncoderXmo::`vftable'
	DD	FLAT:?Release@CVoiceEncoderXmo@@UAGKXZ
	DD	FLAT:?GetInfo@CVoiceEncoderXmo@@UAGJPAU_XMEDIAINFO@@@Z
	DD	FLAT:?GetStatus@CVoiceEncoderXmo@@UAGJPAK@Z
	DD	FLAT:?Process@CVoiceEncoderXmo@@UAGJPBU_XMEDIAPACKET@@0@Z
	DD	FLAT:?Discontinuity@CVoiceEncoderXmo@@UAGJXZ
	DD	FLAT:?Flush@CVoiceEncoderXmo@@UAGJXZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CVoiceEncoderXmo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CVoiceEncoderXmo@@QAE@XZ PROC NEAR			; CVoiceEncoderXmo::CVoiceEncoderXmo, COMDAT
; _this$ = ecx

; 385  : 		{};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0XMediaObject@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CVoiceEncoderXmo@@6B@
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00040	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00043	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	c6 42 2c 00	 mov	 BYTE PTR [edx+44], 0
  00065	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00068	c6 40 2d 00	 mov	 BYTE PTR [eax+45], 0
  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	66 c7 41 2e 00
	00		 mov	 WORD PTR [ecx+46], 0
  00075	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00078	66 c7 42 30 00
	00		 mov	 WORD PTR [edx+48], 0
  0007e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00081	66 c7 40 32 00
	00		 mov	 WORD PTR [eax+50], 0
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	c7 41 34 04 00
	00 00		 mov	 DWORD PTR [ecx+52], 4
  00091	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00094	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0
  0009b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  000af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
??0CVoiceEncoderXmo@@QAE@XZ ENDP			; CVoiceEncoderXmo::CVoiceEncoderXmo
_TEXT	ENDS
EXTRN	__InterlockedIncrement@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?AddRef@CVoiceEncoderXmo@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8
?AddRef@CVoiceEncoderXmo@@UAGKXZ PROC NEAR		; CVoiceEncoderXmo::AddRef, COMDAT

; 389  :     STDMETHODIMP_(ULONG) AddRef() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 390  :        return InterlockedIncrement((long*)&m_cRef);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	83 c0 40	 add	 eax, 64			; 00000040H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __InterlockedIncrement@4

; 391  :     }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?AddRef@CVoiceEncoderXmo@@UAGKXZ ENDP			; CVoiceEncoderXmo::AddRef
_TEXT	ENDS
PUBLIC	??_GCVoiceEncoderXmo@@QAEPAXI@Z			; CVoiceEncoderXmo::`scalar deleting destructor'
EXTRN	__InterlockedDecrement@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Release@CVoiceEncoderXmo@@UAGKXZ
_TEXT	SEGMENT
tv72 = -16
$T26225 = -12
$T26224 = -8
_l$ = -4
_this$ = 8
?Release@CVoiceEncoderXmo@@UAGKXZ PROC NEAR		; CVoiceEncoderXmo::Release, COMDAT

; 393  :     STDMETHODIMP_(ULONG) Release() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 394  :        long l = InterlockedDecrement((long*)&m_cRef);

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	83 c0 40	 add	 eax, 64			; 00000040H
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __InterlockedDecrement@4
  00012	89 45 fc	 mov	 DWORD PTR _l$[ebp], eax

; 395  :        if (l == 0)

  00015	83 7d fc 00	 cmp	 DWORD PTR _l$[ebp], 0
  00019	75 28		 jne	 SHORT $L26002

; 396  :           delete this;

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	89 4d f4	 mov	 DWORD PTR $T26225[ebp], ecx
  00021	8b 55 f4	 mov	 edx, DWORD PTR $T26225[ebp]
  00024	89 55 f8	 mov	 DWORD PTR $T26224[ebp], edx
  00027	83 7d f8 00	 cmp	 DWORD PTR $T26224[ebp], 0
  0002b	74 0f		 je	 SHORT $L26226
  0002d	6a 01		 push	 1
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR $T26224[ebp]
  00032	e8 00 00 00 00	 call	 ??_GCVoiceEncoderXmo@@QAEPAXI@Z
  00037	89 45 f0	 mov	 DWORD PTR tv72[ebp], eax
  0003a	eb 07		 jmp	 SHORT $L26002
$L26226:
  0003c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L26002:

; 397  :        return l;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _l$[ebp]

; 398  :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
?Release@CVoiceEncoderXmo@@UAGKXZ ENDP			; CVoiceEncoderXmo::Release
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0XMediaObject@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0XMediaObject@@QAE@XZ PROC NEAR			; XMediaObject::XMediaObject, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0XMediaObject@@QAE@XZ ENDP				; XMediaObject::XMediaObject
_TEXT	ENDS
PUBLIC	??1CVoiceEncoderXmo@@QAE@XZ			; CVoiceEncoderXmo::~CVoiceEncoderXmo
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt
;	COMDAT ??_GCVoiceEncoderXmo@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCVoiceEncoderXmo@@QAEPAXI@Z PROC NEAR		; CVoiceEncoderXmo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CVoiceEncoderXmo@@QAE@XZ ; CVoiceEncoderXmo::~CVoiceEncoderXmo
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L26010
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L26010:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCVoiceEncoderXmo@@QAEPAXI@Z ENDP			; CVoiceEncoderXmo::`scalar deleting destructor'
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\voiceenc\voiceencoder.cpp
_TEXT	ENDS
;	COMDAT ??1CVoiceEncoderXmo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CVoiceEncoderXmo@@QAE@XZ PROC NEAR			; CVoiceEncoderXmo::~CVoiceEncoderXmo, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CVoiceEncoderXmo@@6B@

; 106  : 
; 107  :     if (m_pEncoderXmo) {

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00017	74 1c		 je	 SHORT $L26041

; 108  : 
; 109  :         m_pEncoderXmo->Release();

  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	52		 push	 edx
  00028	ff 50 04	 call	 DWORD PTR [eax+4]

; 110  :         m_pEncoderXmo = NULL;

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0
$L26041:

; 111  : 
; 112  :     }
; 113  : 
; 114  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??1CVoiceEncoderXmo@@QAE@XZ ENDP			; CVoiceEncoderXmo::~CVoiceEncoderXmo
_TEXT	ENDS
EXTRN	_VoxwareCreateConverter@20:NEAR
; Function compile flags: /Odt
;	COMDAT ?Init@CVoiceEncoderXmo@@QAEJKKPAUtWAVEFORMATEX@@K@Z
_TEXT	SEGMENT
_this$ = -4
_fAutoMode$ = 8
_dwCodecTag$ = 12
_pwfx$ = 16
_dwSensitivity$ = 20
?Init@CVoiceEncoderXmo@@QAEJKKPAUtWAVEFORMATEX@@K@Z PROC NEAR ; CVoiceEncoderXmo::Init, COMDAT
; _this$ = ecx

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 134  : 
; 135  :     MY_ASSERT(pwfx);

  00007	83 7d 10 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  0000b	75 01		 jne	 SHORT $L26050
  0000d	cc		 int	 3
$L26050:

; 136  : 
; 137  :     m_fAutoMode = fAutoMode;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _fAutoMode$[ebp]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 138  :     m_dwSensitivity = dwSensitivity;

  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 45 14	 mov	 eax, DWORD PTR _dwSensitivity$[ebp]
  0001d	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 139  :     m_dwSampleRate = pwfx->nSamplesPerSec;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00026	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00029	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 140  : 
; 141  :     //
; 142  :     // Figure out the shift constants for this sample rate
; 143  :     //
; 144  : 
; 145  :     m_iShiftConstantFast = (DV_log_2((m_dwSampleRate * 2) / 1000) + 1);

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00032	d1 e0		 shl	 eax, 1
  00034	99		 cdq
  00035	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0003a	f7 f9		 idiv	 ecx
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?DV_log_2@@YGEG@Z	; DV_log_2
  00042	0f b6 d0	 movzx	 edx, al
  00045	83 c2 01	 add	 edx, 1
  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 146  : 
; 147  :     //
; 148  :     // This gives the slow filter a cutoff frequency 1/4 of 
; 149  :     // the fast filter
; 150  :     //
; 151  : 
; 152  :     m_iShiftConstantSlow = m_iShiftConstantFast + 2;

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00054	83 c2 02	 add	 edx, 2
  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 153  : 
; 154  :     // Start the envelope signal at zero
; 155  :     Flush();

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	8b 11		 mov	 edx, DWORD PTR [ecx]
  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	50		 push	 eax
  00066	ff 52 18	 call	 DWORD PTR [edx+24]

; 156  : 
; 157  :    
; 158  :     AddRef();

  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00071	50		 push	 eax
  00072	ff 12		 call	 DWORD PTR [edx]

; 159  : 
; 160  :     //
; 161  :     // instantiate a codec
; 162  :     //
; 163  : 
; 164  :     //
; 165  :     // instantiate the proper vox compressor
; 166  :     //
; 167  :     
; 168  :     return VoxwareCreateConverter((WORD)dwCodecTag,
; 169  :                                   TRUE,
; 170  :                                   NULL,
; 171  :                                   pwfx,
; 172  :                                   &m_pEncoderXmo);

  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	83 c1 38	 add	 ecx, 56			; 00000038H
  0007a	51		 push	 ecx
  0007b	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0007e	52		 push	 edx
  0007f	6a 00		 push	 0
  00081	6a 01		 push	 1
  00083	66 8b 45 0c	 mov	 ax, WORD PTR _dwCodecTag$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _VoxwareCreateConverter@20

; 173  : 
; 174  :    
; 175  : }

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 10 00	 ret	 16			; 00000010H
?Init@CVoiceEncoderXmo@@QAEJKKPAUtWAVEFORMATEX@@K@Z ENDP ; CVoiceEncoderXmo::Init
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Flush@CVoiceEncoderXmo@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8
?Flush@CVoiceEncoderXmo@@UAGJXZ PROC NEAR		; CVoiceEncoderXmo::Flush, COMDAT

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 179  : 
; 180  : 
; 181  :     // Start the envelope signal at zero
; 182  :     m_iCurEnvelopeValueFast = 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 183  :     m_iCurEnvelopeValueSlow = 0;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 184  :     m_iHangoverSamples = 2;

  00017	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	c7 42 1c 02 00
	00 00		 mov	 DWORD PTR [edx+28], 2

; 185  :     return S_OK;

  00021	33 c0		 xor	 eax, eax

; 186  : 
; 187  : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?Flush@CVoiceEncoderXmo@@UAGJXZ ENDP			; CVoiceEncoderXmo::Flush
_TEXT	ENDS
EXTRN	_memset:NEAR
; Function compile flags: /Odt
;	COMDAT ?Process@CVoiceEncoderXmo@@UAGJPBU_XMEDIAPACKET@@0@Z
_TEXT	SEGMENT
tv131 = -56
tv129 = -52
_pXmp$26107 = -48
_iNormalizedCurEnvelopeValueSlow$26088 = -44
_iNormalizedCurEnvelopeValueFast$26087 = -40
_hr$ = -36
_iValueAbs$ = -32
_iIndex$ = -28
_iMaxPossiblePeak$ = -24
_fVoiceDetectedPrevFrame$ = -20
_iNumberOfSamples$ = -16
_pHeader$ = -12
_psiAudioData$ = -8
_iMaxValue$ = -4
_this$ = 8
_pSrc$ = 12
_pDst$ = 16
?Process@CVoiceEncoderXmo@@UAGJPBU_XMEDIAPACKET@@0@Z PROC NEAR ; CVoiceEncoderXmo::Process, COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H

; 194  :     int iMaxValue;
; 195  :     int iValueAbs;
; 196  :     int iIndex;
; 197  :     int iMaxPossiblePeak;
; 198  :     int iNumberOfSamples;
; 199  :     PVOICE_ENCODER_HEADER pHeader;
; 200  :     HRESULT hr = S_OK;

  00006	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 201  : 
; 202  :     DWORD fVoiceDetectedPrevFrame = m_fVoiceDetectedThisFrame;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00013	89 4d ec	 mov	 DWORD PTR _fVoiceDetectedPrevFrame$[ebp], ecx

; 203  : 
; 204  :     MY_ASSERT(pSrc);

  00016	83 7d 0c 00	 cmp	 DWORD PTR _pSrc$[ebp], 0
  0001a	75 01		 jne	 SHORT $L26070
  0001c	cc		 int	 3
$L26070:

; 205  :     MY_ASSERT(pDst);

  0001d	83 7d 10 00	 cmp	 DWORD PTR _pDst$[ebp], 0
  00021	75 01		 jne	 SHORT $L26071
  00023	cc		 int	 3
$L26071:

; 206  : 
; 207  :     MY_ASSERT(pSrc->dwMaxSize >= 2);

  00024	8b 55 0c	 mov	 edx, DWORD PTR _pSrc$[ebp]
  00027	83 7a 04 02	 cmp	 DWORD PTR [edx+4], 2
  0002b	73 01		 jae	 SHORT $L26072
  0002d	cc		 int	 3
$L26072:

; 208  :     MY_ASSERT(pDst->dwMaxSize >= m_dwMinOutputSize);

  0002e	8b 45 10	 mov	 eax, DWORD PTR _pDst$[ebp]
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00037	3b 51 34	 cmp	 edx, DWORD PTR [ecx+52]
  0003a	73 01		 jae	 SHORT $L26073
  0003c	cc		 int	 3
$L26073:

; 209  : 
; 210  :     MY_ASSERT(pDst->pvBuffer);

  0003d	8b 45 10	 mov	 eax, DWORD PTR _pDst$[ebp]
  00040	83 38 00	 cmp	 DWORD PTR [eax], 0
  00043	75 01		 jne	 SHORT $L26074
  00045	cc		 int	 3
$L26074:

; 211  :     MY_ASSERT(pSrc->pvBuffer);

  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _pSrc$[ebp]
  00049	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0004c	75 01		 jne	 SHORT $L26075
  0004e	cc		 int	 3
$L26075:

; 212  : 
; 213  : 	//
; 214  :     // Compute the upper bound for number of sequences in a message
; 215  :     //
; 216  : 	if( 0 == m_wMaxSeqInMsg )

  0004f	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00052	0f b7 42 32	 movzx	 eax, WORD PTR [edx+50]
  00056	85 c0		 test	 eax, eax
  00058	75 14		 jne	 SHORT $L26076

; 217  :     {
; 218  : 		//
; 219  :         // Normal talkspurt is about 30s long
; 220  :         // We'll consider the maximum talkpurt to be 3 minutes 
; 221  : 		//
; 222  : 		m_wMaxSeqInMsg = (WORD)(MAX_MSG_TIME / (pSrc->dwMaxSize));

  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR _pSrc$[ebp]
  0005d	b8 20 bf 02 00	 mov	 eax, 180000		; 0002bf20H
  00062	33 d2		 xor	 edx, edx
  00064	f7 71 04	 div	 DWORD PTR [ecx+4]
  00067	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	66 89 42 32	 mov	 WORD PTR [edx+50], ax
$L26076:

; 223  :     }		
; 224  : 
; 225  :     // cast the audio data to signed 16 bit integers
; 226  :     signed short* psiAudioData = (signed short *)pSrc->pvBuffer;

  0006e	8b 45 0c	 mov	 eax, DWORD PTR _pSrc$[ebp]
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	89 4d f8	 mov	 DWORD PTR _psiAudioData$[ebp], ecx

; 227  : 
; 228  :     // 16 bits per sample assumed!!
; 229  :     iNumberOfSamples = pSrc->dwMaxSize / 2;

  00076	8b 55 0c	 mov	 edx, DWORD PTR _pSrc$[ebp]
  00079	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007c	d1 e8		 shr	 eax, 1
  0007e	89 45 f0	 mov	 DWORD PTR _iNumberOfSamples$[ebp], eax

; 230  : 
; 231  :     //
; 232  :     // BUGBUG the voice peripheral certainly regulates the volume so the max value is never above 600
; 233  :     // we got to figure this out tho
; 234  :     //
; 235  : 
; 236  :     iMaxPossiblePeak = 500;

  00081	c7 45 e8 f4 01
	00 00		 mov	 DWORD PTR _iMaxPossiblePeak$[ebp], 500 ; 000001f4H

; 237  :     iMaxValue = 0;

  00088	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iMaxValue$[ebp], 0

; 238  :     m_fVoiceDetectedThisFrame = FALSE;

  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 239  : 
; 240  :     for (iIndex = 0; iIndex < (int)iNumberOfSamples; ++iIndex)

  00099	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iIndex$[ebp], 0
  000a0	eb 09		 jmp	 SHORT $L26081
$L26082:
  000a2	8b 55 e4	 mov	 edx, DWORD PTR _iIndex$[ebp]
  000a5	83 c2 01	 add	 edx, 1
  000a8	89 55 e4	 mov	 DWORD PTR _iIndex$[ebp], edx
$L26081:
  000ab	8b 45 e4	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000ae	3b 45 f0	 cmp	 eax, DWORD PTR _iNumberOfSamples$[ebp]
  000b1	0f 8d 38 01 00
	00		 jge	 $L26083

; 241  :     {
; 242  :         iValueAbs = DV_ABS((int)psiAudioData[iIndex]);

  000b7	8b 4d e4	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  000ba	8b 55 f8	 mov	 edx, DWORD PTR _psiAudioData$[ebp]
  000bd	0f bf 04 4a	 movsx	 eax, WORD PTR [edx+ecx*2]
  000c1	85 c0		 test	 eax, eax
  000c3	7d 11		 jge	 SHORT $L26246
  000c5	8b 4d e4	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  000c8	8b 55 f8	 mov	 edx, DWORD PTR _psiAudioData$[ebp]
  000cb	0f bf 04 4a	 movsx	 eax, WORD PTR [edx+ecx*2]
  000cf	f7 d8		 neg	 eax
  000d1	89 45 cc	 mov	 DWORD PTR tv129[ebp], eax
  000d4	eb 0d		 jmp	 SHORT $L26247
$L26246:
  000d6	8b 4d e4	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  000d9	8b 55 f8	 mov	 edx, DWORD PTR _psiAudioData$[ebp]
  000dc	0f bf 04 4a	 movsx	 eax, WORD PTR [edx+ecx*2]
  000e0	89 45 cc	 mov	 DWORD PTR tv129[ebp], eax
$L26247:
  000e3	8b 4d cc	 mov	 ecx, DWORD PTR tv129[ebp]
  000e6	89 4d e0	 mov	 DWORD PTR _iValueAbs$[ebp], ecx

; 243  : 
; 244  :         // see if it is the new peak value
; 245  :         iMaxValue = DV_MAX(iValueAbs, iMaxValue);

  000e9	8b 55 e0	 mov	 edx, DWORD PTR _iValueAbs$[ebp]
  000ec	3b 55 fc	 cmp	 edx, DWORD PTR _iMaxValue$[ebp]
  000ef	7e 08		 jle	 SHORT $L26248
  000f1	8b 45 e0	 mov	 eax, DWORD PTR _iValueAbs$[ebp]
  000f4	89 45 c8	 mov	 DWORD PTR tv131[ebp], eax
  000f7	eb 06		 jmp	 SHORT $L26249
$L26248:
  000f9	8b 4d fc	 mov	 ecx, DWORD PTR _iMaxValue$[ebp]
  000fc	89 4d c8	 mov	 DWORD PTR tv131[ebp], ecx
$L26249:
  000ff	8b 55 c8	 mov	 edx, DWORD PTR tv131[ebp]
  00102	89 55 fc	 mov	 DWORD PTR _iMaxValue$[ebp], edx

; 246  : 
; 247  :         // do the low pass filtering, but only if we are in autosensitivity mode
; 248  :         int iNormalizedCurEnvelopeValueFast;
; 249  :         int iNormalizedCurEnvelopeValueSlow;
; 250  :         if (m_fAutoMode)

  00105	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00108	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0010c	0f 84 d8 00 00
	00		 je	 $L26089

; 251  :         {
; 252  :             m_iCurEnvelopeValueFast = 
; 253  :                 iValueAbs + 
; 254  :                 (m_iCurEnvelopeValueFast - (m_iCurEnvelopeValueFast >> m_iShiftConstantFast));

  00112	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00118	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0011b	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  0011e	d3 f8		 sar	 eax, cl
  00120	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00123	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00126	2b d0		 sub	 edx, eax
  00128	8b 45 e0	 mov	 eax, DWORD PTR _iValueAbs$[ebp]
  0012b	03 c2		 add	 eax, edx
  0012d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00130	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 255  :             iNormalizedCurEnvelopeValueFast = m_iCurEnvelopeValueFast >> m_iShiftConstantFast;

  00133	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00136	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00139	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  0013c	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0013f	d3 fa		 sar	 edx, cl
  00141	89 55 d8	 mov	 DWORD PTR _iNormalizedCurEnvelopeValueFast$26087[ebp], edx

; 256  : 
; 257  :             m_iCurEnvelopeValueSlow = 
; 258  :                 iValueAbs + 
; 259  :                 (m_iCurEnvelopeValueSlow - (m_iCurEnvelopeValueSlow >> m_iShiftConstantSlow));

  00144	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00147	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0014a	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0014d	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  00150	d3 fa		 sar	 edx, cl
  00152	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00155	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00158	2b ca		 sub	 ecx, edx
  0015a	8b 55 e0	 mov	 edx, DWORD PTR _iValueAbs$[ebp]
  0015d	03 d1		 add	 edx, ecx
  0015f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00162	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 260  :             iNormalizedCurEnvelopeValueSlow = m_iCurEnvelopeValueSlow >> m_iShiftConstantSlow;

  00165	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00168	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0016b	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0016e	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  00171	d3 f8		 sar	 eax, cl
  00173	89 45 d4	 mov	 DWORD PTR _iNormalizedCurEnvelopeValueSlow$26088[ebp], eax

; 261  : 
; 262  :             // check to see if we consider this voice
; 263  :             if (iNormalizedCurEnvelopeValueFast > VA_LOW_ENVELOPE &&
; 264  :                 (iNormalizedCurEnvelopeValueFast > VA_HIGH_ENVELOPE ||
; 265  :                 CALC_HIGH_PERCENT_RANGE( iNormalizedCurEnvelopeValueSlow ) ||
; 266  :                 CALC_LOW_PERCENT_RANGE( iNormalizedCurEnvelopeValueSlow ) ) )

  00176	81 7d d8 00 01
	00 00		 cmp	 DWORD PTR _iNormalizedCurEnvelopeValueFast$26087[ebp], 256 ; 00000100H
  0017d	7e 38		 jle	 SHORT $L26090
  0017f	81 7d d8 00 0a
	00 00		 cmp	 DWORD PTR _iNormalizedCurEnvelopeValueFast$26087[ebp], 2560 ; 00000a00H
  00186	7f 19		 jg	 SHORT $L26091
  00188	8b 4d d4	 mov	 ecx, DWORD PTR _iNormalizedCurEnvelopeValueSlow$26088[ebp]
  0018b	69 c9 da 00 00
	00		 imul	 ecx, 218		; 000000daH
  00191	c1 f9 07	 sar	 ecx, 7
  00194	85 c9		 test	 ecx, ecx
  00196	75 09		 jne	 SHORT $L26091
  00198	8b 55 d4	 mov	 edx, DWORD PTR _iNormalizedCurEnvelopeValueSlow$26088[ebp]
  0019b	d1 fa		 sar	 edx, 1
  0019d	85 d2		 test	 edx, edx
  0019f	74 16		 je	 SHORT $L26090
$L26091:

; 267  :             {
; 268  :                 m_fVoiceDetectedThisFrame = TRUE;

  001a1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001a4	c7 40 3c 01 00
	00 00		 mov	 DWORD PTR [eax+60], 1

; 269  :                 m_iCurHangoverSamples = 0;

  001ab	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001ae	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 270  :             }
; 271  :             else

  001b5	eb 33		 jmp	 SHORT $L26089
$L26090:

; 272  :             {
; 273  :                 ++m_iCurHangoverSamples;

  001b7	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001ba	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  001bd	83 c0 01	 add	 eax, 1
  001c0	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001c3	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 274  :                 if (m_iCurHangoverSamples > m_iHangoverSamples)

  001c6	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001c9	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001cc	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  001cf	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  001d2	7e 0c		 jle	 SHORT $L26093

; 275  :                 {
; 276  :                     m_fVoiceDetectedThisFrame = FALSE;

  001d4	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001d7	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 277  :                 }
; 278  :                 else

  001de	eb 0a		 jmp	 SHORT $L26089
$L26093:

; 279  :                 {
; 280  :                     m_fVoiceDetectedThisFrame = TRUE;

  001e0	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001e3	c7 40 3c 01 00
	00 00		 mov	 DWORD PTR [eax+60], 1
$L26089:

; 281  :                 }
; 282  :             }
; 283  :         }
; 284  :     }

  001ea	e9 b3 fe ff ff	 jmp	 $L26082
$L26083:

; 285  : 
; 286  :     // Normalize the peak value to the range DVINPUTLEVEL_MIN to DVINPUTLEVEL_MAX
; 287  :     // This is what is returned for caller's peak meters...
; 288  :     m_bPeak = (BYTE)(VE_INPUTLEVEL_MIN + 
; 289  :         ((iMaxValue * (VE_INPUTLEVEL_MAX - VE_INPUTLEVEL_MIN)) / iMaxPossiblePeak));

  001ef	8b 45 fc	 mov	 eax, DWORD PTR _iMaxValue$[ebp]
  001f2	6b c0 63	 imul	 eax, 99			; 00000063H
  001f5	99		 cdq
  001f6	f7 7d e8	 idiv	 DWORD PTR _iMaxPossiblePeak$[ebp]
  001f9	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001fc	88 41 2c	 mov	 BYTE PTR [ecx+44], al

; 290  : 
; 291  :     //
; 292  :     // if we are in manual VA mode (not autovolume) check the peak against
; 293  :     // the sensitivity threshold
; 294  :     //
; 295  : 
; 296  :     if (!m_fAutoMode)

  001ff	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00202	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00206	75 58		 jne	 SHORT $L26096

; 297  :     {
; 298  :         if (m_bPeak > m_dwSensitivity)

  00208	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0020b	0f b6 48 2c	 movzx	 ecx, BYTE PTR [eax+44]
  0020f	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00212	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  00215	76 16		 jbe	 SHORT $L26097

; 299  :         {
; 300  :             m_fVoiceDetectedThisFrame = TRUE;

  00217	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0021a	c7 40 3c 01 00
	00 00		 mov	 DWORD PTR [eax+60], 1

; 301  :             m_iCurHangoverSamples = 0;

  00221	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00224	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 302  :         } 
; 303  : 		else 

  0022b	eb 33		 jmp	 SHORT $L26096
$L26097:

; 304  : 		{
; 305  :                 ++m_iCurHangoverSamples;

  0022d	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00230	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00233	83 c0 01	 add	 eax, 1
  00236	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00239	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 306  :                 if (m_iCurHangoverSamples > m_iHangoverSamples)

  0023c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0023f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00242	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00245	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  00248	7e 0c		 jle	 SHORT $L26099

; 307  :                 {
; 308  :                     m_fVoiceDetectedThisFrame = FALSE;

  0024a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0024d	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 309  :                 }
; 310  :                 else

  00254	eb 0a		 jmp	 SHORT $L26096
$L26099:

; 311  :                 {
; 312  :                     m_fVoiceDetectedThisFrame = TRUE;

  00256	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00259	c7 40 3c 01 00
	00 00		 mov	 DWORD PTR [eax+60], 1
$L26096:

; 313  :                 }
; 314  :         }
; 315  :     }
; 316  : 
; 317  :     //
; 318  :     // now that we have performed the VA, create a packet header 
; 319  :     //
; 320  : 
; 321  :     pHeader = (PVOICE_ENCODER_HEADER) pDst->pvBuffer;

  00260	8b 4d 10	 mov	 ecx, DWORD PTR _pDst$[ebp]
  00263	8b 11		 mov	 edx, DWORD PTR [ecx]
  00265	89 55 f4	 mov	 DWORD PTR _pHeader$[ebp], edx

; 322  :     pHeader->bType = (m_fVoiceDetectedThisFrame ? VOICE_MESSAGE_TYPE_VOICE : VOICE_MESSAGE_TYPE_SILENCE);

  00268	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0026b	33 c9		 xor	 ecx, ecx
  0026d	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00271	0f 95 c1	 setne	 cl
  00274	8b 55 f4	 mov	 edx, DWORD PTR _pHeader$[ebp]
  00277	88 0a		 mov	 BYTE PTR [edx], cl

; 323  : 
; 324  :     if ((!m_fVoiceDetectedThisFrame && fVoiceDetectedPrevFrame) ||
; 325  : 		 (m_wCurrentMsgSeqCount > m_wMaxSeqInMsg))

  00279	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0027c	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00280	75 06		 jne	 SHORT $L26104
  00282	83 7d ec 00	 cmp	 DWORD PTR _fVoiceDetectedPrevFrame$[ebp], 0
  00286	75 12		 jne	 SHORT $L26103
$L26104:
  00288	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0028b	0f b7 51 30	 movzx	 edx, WORD PTR [ecx+48]
  0028f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00292	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]
  00296	3b d1		 cmp	 edx, ecx
  00298	7e 25		 jle	 SHORT $L26102
$L26103:

; 326  : 	{
; 327  : 
; 328  :         pHeader->bMsgNum = m_bMsgNum++;

  0029a	8b 55 f4	 mov	 edx, DWORD PTR _pHeader$[ebp]
  0029d	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002a0	8a 48 2d	 mov	 cl, BYTE PTR [eax+45]
  002a3	88 4a 01	 mov	 BYTE PTR [edx+1], cl
  002a6	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002a9	8a 42 2d	 mov	 al, BYTE PTR [edx+45]
  002ac	04 01		 add	 al, 1
  002ae	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	88 41 2d	 mov	 BYTE PTR [ecx+45], al

; 329  : 		m_wCurrentMsgSeqCount = 0;

  002b4	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002b7	66 c7 42 30 00
	00		 mov	 WORD PTR [edx+48], 0

; 330  : 
; 331  :     }
; 332  : 	else

  002bd	eb 0c		 jmp	 SHORT $L26105
$L26102:

; 333  : 	{
; 334  : 	    pHeader->bMsgNum = m_bMsgNum;

  002bf	8b 45 f4	 mov	 eax, DWORD PTR _pHeader$[ebp]
  002c2	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002c5	8a 51 2d	 mov	 dl, BYTE PTR [ecx+45]
  002c8	88 50 01	 mov	 BYTE PTR [eax+1], dl
$L26105:

; 335  : 	}
; 336  : 
; 337  :     pHeader->wSeqNum = m_wSeqNum++;

  002cb	8b 45 f4	 mov	 eax, DWORD PTR _pHeader$[ebp]
  002ce	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002d1	66 8b 51 2e	 mov	 dx, WORD PTR [ecx+46]
  002d5	66 89 50 02	 mov	 WORD PTR [eax+2], dx
  002d9	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002dc	66 8b 48 2e	 mov	 cx, WORD PTR [eax+46]
  002e0	66 83 c1 01	 add	 cx, 1
  002e4	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002e7	66 89 4a 2e	 mov	 WORD PTR [edx+46], cx

; 338  : 	m_wCurrentMsgSeqCount++;

  002eb	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002ee	66 8b 48 30	 mov	 cx, WORD PTR [eax+48]
  002f2	66 83 c1 01	 add	 cx, 1
  002f6	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002f9	66 89 4a 30	 mov	 WORD PTR [edx+48], cx

; 339  : 
; 340  :     //
; 341  :     // now invoke the encoder XMO to compress the data
; 342  :     //
; 343  : 
; 344  :     if (m_fVoiceDetectedThisFrame) {

  002fd	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00300	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00304	74 54		 je	 SHORT $L26106

; 345  : 
; 346  :         XMEDIAPACKET * pXmp;
; 347  : 
; 348  :         pXmp = (XMEDIAPACKET *)pDst;

  00306	8b 4d 10	 mov	 ecx, DWORD PTR _pDst$[ebp]
  00309	89 4d d0	 mov	 DWORD PTR _pXmp$26107[ebp], ecx

; 349  : 
; 350  :         //
; 351  :         // change the destination packet to not stomp on the voice header we just inserted
; 352  :         //
; 353  : 
; 354  :         pXmp->pvBuffer = (PUCHAR)pHeader + sizeof(VOICE_ENCODER_HEADER);

  0030c	8b 55 f4	 mov	 edx, DWORD PTR _pHeader$[ebp]
  0030f	83 c2 04	 add	 edx, 4
  00312	8b 45 d0	 mov	 eax, DWORD PTR _pXmp$26107[ebp]
  00315	89 10		 mov	 DWORD PTR [eax], edx

; 355  : 
; 356  :         hr = m_pEncoderXmo->Process(pSrc,
; 357  :                                     pDst);

  00317	8b 4d 10	 mov	 ecx, DWORD PTR _pDst$[ebp]
  0031a	51		 push	 ecx
  0031b	8b 55 0c	 mov	 edx, DWORD PTR _pSrc$[ebp]
  0031e	52		 push	 edx
  0031f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00322	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00325	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00328	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0032b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0032d	50		 push	 eax
  0032e	ff 51 10	 call	 DWORD PTR [ecx+16]
  00331	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 358  : 
; 359  : 
; 360  :         //
; 361  :         // re adjust destination packet buffer and size
; 362  :         //
; 363  : 
; 364  :         pXmp->pvBuffer = pHeader;

  00334	8b 55 d0	 mov	 edx, DWORD PTR _pXmp$26107[ebp]
  00337	8b 45 f4	 mov	 eax, DWORD PTR _pHeader$[ebp]
  0033a	89 02		 mov	 DWORD PTR [edx], eax

; 365  :   
; 366  :         //
; 367  :         // the intermediate codec XMO has already updated pdwstatus, etc
; 368  :         //
; 369  : 
; 370  : 		if (pDst->pdwCompletedSize) {

  0033c	8b 4d 10	 mov	 ecx, DWORD PTR _pDst$[ebp]
  0033f	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00343	74 13		 je	 SHORT $L26111

; 371  : 
; 372  :             *pDst->pdwCompletedSize += sizeof(VOICE_ENCODER_HEADER);

  00345	8b 55 10	 mov	 edx, DWORD PTR _pDst$[ebp]
  00348	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0034b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0034d	83 c1 04	 add	 ecx, 4
  00350	8b 55 10	 mov	 edx, DWORD PTR _pDst$[ebp]
  00353	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00356	89 08		 mov	 DWORD PTR [eax], ecx
$L26111:

; 373  : 
; 374  :         }
; 375  : 
; 376  :     } else {

  00358	eb 41		 jmp	 SHORT $L26113
$L26106:

; 377  : 
; 378  :         //
; 379  :         // if voice was not detected we just send a zeroed packet
; 380  :         //
; 381  : 
; 382  : 		memset(pDst->pvBuffer, 0 , pDst->dwMaxSize);

  0035a	8b 4d 10	 mov	 ecx, DWORD PTR _pDst$[ebp]
  0035d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00360	52		 push	 edx
  00361	6a 00		 push	 0
  00363	8b 45 10	 mov	 eax, DWORD PTR _pDst$[ebp]
  00366	8b 08		 mov	 ecx, DWORD PTR [eax]
  00368	51		 push	 ecx
  00369	e8 00 00 00 00	 call	 _memset
  0036e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 383  : 
; 384  :         if (pDst->pdwCompletedSize) {

  00371	8b 55 10	 mov	 edx, DWORD PTR _pDst$[ebp]
  00374	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00378	74 0c		 je	 SHORT $L26114

; 385  : 
; 386  :             *pDst->pdwCompletedSize = 0;

  0037a	8b 45 10	 mov	 eax, DWORD PTR _pDst$[ebp]
  0037d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00380	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L26114:

; 387  :         }
; 388  : 
; 389  :         if (pDst->pdwStatus) {

  00386	8b 55 10	 mov	 edx, DWORD PTR _pDst$[ebp]
  00389	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0038d	74 0c		 je	 SHORT $L26113

; 390  : 
; 391  :             *pDst->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;

  0038f	8b 45 10	 mov	 eax, DWORD PTR _pDst$[ebp]
  00392	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00395	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L26113:

; 392  : 
; 393  :         }
; 394  : 
; 395  :     }
; 396  : 
; 397  :     if (pSrc->pdwCompletedSize) {

  0039b	8b 55 0c	 mov	 edx, DWORD PTR _pSrc$[ebp]
  0039e	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  003a2	74 0e		 je	 SHORT $L26117

; 398  : 
; 399  :         *pSrc->pdwCompletedSize = pSrc->dwMaxSize;

  003a4	8b 45 0c	 mov	 eax, DWORD PTR _pSrc$[ebp]
  003a7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003aa	8b 55 0c	 mov	 edx, DWORD PTR _pSrc$[ebp]
  003ad	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003b0	89 01		 mov	 DWORD PTR [ecx], eax
$L26117:

; 400  : 
; 401  :     }
; 402  : 
; 403  :     if (pSrc->pdwStatus) {

  003b2	8b 4d 0c	 mov	 ecx, DWORD PTR _pSrc$[ebp]
  003b5	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  003b9	74 20		 je	 SHORT $L26118

; 404  : 
; 405  :         if (FAILED(hr)) {

  003bb	83 7d dc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  003bf	7d 0e		 jge	 SHORT $L26120

; 406  : 
; 407  :             *pSrc->pdwStatus = XMEDIAPACKET_STATUS_FAILURE;

  003c1	8b 55 0c	 mov	 edx, DWORD PTR _pSrc$[ebp]
  003c4	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  003c7	c7 00 05 40 00
	80		 mov	 DWORD PTR [eax], -2147467259 ; 80004005H

; 408  : 
; 409  :         } else {

  003cd	eb 0c		 jmp	 SHORT $L26118
$L26120:

; 410  : 
; 411  :             *pSrc->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;

  003cf	8b 4d 0c	 mov	 ecx, DWORD PTR _pSrc$[ebp]
  003d2	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  003d5	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L26118:

; 412  : 
; 413  :         }
; 414  :         
; 415  :     }
; 416  : 
; 417  :     return hr;

  003db	8b 45 dc	 mov	 eax, DWORD PTR _hr$[ebp]

; 418  : }

  003de	8b e5		 mov	 esp, ebp
  003e0	5d		 pop	 ebp
  003e1	c2 0c 00	 ret	 12			; 0000000cH
?Process@CVoiceEncoderXmo@@UAGJPBU_XMEDIAPACKET@@0@Z ENDP ; CVoiceEncoderXmo::Process
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetInfo@CVoiceEncoderXmo@@UAGJPAU_XMEDIAINFO@@@Z
_TEXT	SEGMENT
_hr$ = -4
_this$ = 8
_pInfo$ = 12
?GetInfo@CVoiceEncoderXmo@@UAGJPAU_XMEDIAINFO@@@Z PROC NEAR ; CVoiceEncoderXmo::GetInfo, COMDAT

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 423  :     HRESULT hr;
; 424  : 
; 425  :     MY_ASSERT(pInfo);

  00004	83 7d 0c 00	 cmp	 DWORD PTR _pInfo$[ebp], 0
  00008	75 01		 jne	 SHORT $L26129
  0000a	cc		 int	 3
$L26129:

; 426  : 
; 427  :     //
; 428  :     // use the info from the encoder xmo
; 429  :     //
; 430  :     hr = m_pEncoderXmo->GetInfo(pInfo);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _pInfo$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00015	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0001b	8b 12		 mov	 edx, DWORD PTR [edx]
  0001d	51		 push	 ecx
  0001e	ff 52 08	 call	 DWORD PTR [edx+8]
  00021	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 431  :     if (FAILED(hr)) {

  00024	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00028	7d 05		 jge	 SHORT $L26131

; 432  :         return hr;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  0002d	eb 1d		 jmp	 SHORT $L26127
$L26131:

; 433  :     }
; 434  : 
; 435  : 
; 436  : 	//
; 437  :     // our minimum output size has to account for the header
; 438  :     //
; 439  :     pInfo->dwOutputSize += sizeof(VOICE_ENCODER_HEADER); 

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00032	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00035	83 c1 04	 add	 ecx, 4
  00038	8b 55 0c	 mov	 edx, DWORD PTR _pInfo$[ebp]
  0003b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 440  :     m_dwMinOutputSize = pInfo->dwOutputSize;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 4d 0c	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00044	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00047	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 441  : 
; 442  :     return S_OK;

  0004a	33 c0		 xor	 eax, eax
$L26127:

; 443  : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
?GetInfo@CVoiceEncoderXmo@@UAGJPAU_XMEDIAINFO@@@Z ENDP	; CVoiceEncoderXmo::GetInfo
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Discontinuity@CVoiceEncoderXmo@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8
?Discontinuity@CVoiceEncoderXmo@@UAGJXZ PROC NEAR	; CVoiceEncoderXmo::Discontinuity, COMDAT

; 445  : HRESULT STDMETHODCALLTYPE CVoiceEncoderXmo::Discontinuity(void){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 446  :    return S_OK;

  00003	33 c0		 xor	 eax, eax

; 447  : }

  00005	5d		 pop	 ebp
  00006	c2 04 00	 ret	 4
?Discontinuity@CVoiceEncoderXmo@@UAGJXZ ENDP		; CVoiceEncoderXmo::Discontinuity
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetStatus@CVoiceEncoderXmo@@UAGJPAK@Z
_TEXT	SEGMENT
_this$ = 8
_pdwStatus$ = 12
?GetStatus@CVoiceEncoderXmo@@UAGJPAK@Z PROC NEAR	; CVoiceEncoderXmo::GetStatus, COMDAT

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 453  : 
; 454  :     if (pdwStatus) {

  00003	83 7d 0c 00	 cmp	 DWORD PTR _pdwStatus$[ebp], 0
  00007	74 09		 je	 SHORT $L26143

; 455  : 
; 456  :         *pdwStatus = XMO_STATUSF_ACCEPT_OUTPUT_DATA | XMO_STATUSF_ACCEPT_INPUT_DATA;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _pdwStatus$[ebp]
  0000c	c7 00 03 00 00
	00		 mov	 DWORD PTR [eax], 3
$L26143:

; 457  : 
; 458  :     }
; 459  : 
; 460  :     return S_OK;

  00012	33 c0		 xor	 eax, eax

; 461  : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
?GetStatus@CVoiceEncoderXmo@@UAGJPAK@Z ENDP		; CVoiceEncoderXmo::GetStatus
_TEXT	ENDS
END
