; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\sws.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxSws@40
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxInitSws@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxFreeSws@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_VoxSws@40
PUBLIC	__real@3f800000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fc3333340000000
PUBLIC	__real@43340000
PUBLIC	__real@41000000
PUBLIC	__real@42fa0000
PUBLIC	__real@3f000000
EXTRN	_NuRand@4:NEAR
EXTRN	_SpecIntLn@24:NEAR
EXTRN	_L2Scale@12:NEAR
EXTRN	_HarmSynFHTFloat@52:NEAR
EXTRN	_getnHarm@4:NEAR
EXTRN	_getvHarm@8:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	_fabs:NEAR
;	COMDAT __real@3f800000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\sws.c
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@3fc3333340000000
CONST	SEGMENT
__real@3fc3333340000000 DQ 03fc3333340000000r	; 0.15
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@42fa0000
CONST	SEGMENT
__real@42fa0000 DD 042fa0000r			; 125
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxSws@40
_TEXT	SEGMENT
tv361 = -1172
tv145 = -1168
tv130 = -1164
tv94 = -1160
tv300 = -1156
tv299 = -1152
tv286 = -1148
_Spec_sub_1$1548 = -1144
_pitch_mult$ = -784
_j$ = -780
_subframeLEN$ = -776
_sub$ = -772
_tempvHarm$ = -768
_interp$ = -764
_subPv$ = -760
_SWS_mblk$ = -756
_overlap$ = -752
_uv_energy_desired$ = -748
_Spec_sub$ = -744
_subnHarm$ = -384
_multPitch$ = -380
_i$ = -376
_subPitch$ = -372
_subPitch_1$ = -368
_subvHarm$ = -364
_inPhase$ = -360
_pSWS_mblk$ = 8
_Amps$ = 12
_Amps_1$ = 16
_Pitch$ = 20
_Pitch_1$ = 24
_Pv$ = 28
_Pv_1$ = 32
_frameLEN$ = 36
_nSubs$ = 40
_outspeech$ = 44
_VoxSws@40 PROC NEAR					; COMDAT

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 04 00
	00		 sub	 esp, 1172		; 00000494H

; 114  :    short     subframeLEN, overlap; 
; 115  :    short     pitch_mult, subnHarm, subvHarm;
; 116  :    int       sub,i,j;
; 117  :    float     interp, subPv, subPitch;
; 118  :    float     multPitch, subPitch_1, uv_energy_desired;
; 119  :    SWS *SWS_mblk= (SWS *)pSWS_mblk;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pSWS_mblk$[ebp]
  0000c	89 85 0c fd ff
	ff		 mov	 DWORD PTR _SWS_mblk$[ebp], eax

; 120  :    short     tempvHarm;
; 121  : 
; 122  :    STACK_INIT
; 123  :    float     Spec_sub[MAXHARM];
; 124  :    int       inPhase[MAXHARM];
; 125  :    STACK_INIT_END
; 126  : 
; 127  :    STACK_ATTACH(float*,Spec_sub)
; 128  :    STACK_ATTACH(int*,inPhase)
; 129  : 
; 130  :    STACK_START
; 131  : 
; 132  :    subframeLEN  = (short) (frameLEN/nSubs);

  00012	0f bf 45 24	 movsx	 eax, WORD PTR _frameLEN$[ebp]
  00016	0f bf 4d 28	 movsx	 ecx, WORD PTR _nSubs$[ebp]
  0001a	99		 cdq
  0001b	f7 f9		 idiv	 ecx
  0001d	66 89 85 f8 fc
	ff ff		 mov	 WORD PTR _subframeLEN$[ebp], ax

; 133  :    overlap      = (short)(OVERLAPFACTOR*subframeLEN);

  00024	0f bf 95 f8 fc
	ff ff		 movsx	 edx, WORD PTR _subframeLEN$[ebp]
  0002b	89 95 84 fb ff
	ff		 mov	 DWORD PTR tv286[ebp], edx
  00031	db 85 84 fb ff
	ff		 fild	 DWORD PTR tv286[ebp]
  00037	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f800000
  0003d	e8 00 00 00 00	 call	 __ftol2
  00042	66 89 85 10 fd
	ff ff		 mov	 WORD PTR _overlap$[ebp], ax

; 134  :    subPitch_1   = Pitch_1;

  00049	8b 45 18	 mov	 eax, DWORD PTR _Pitch_1$[ebp]
  0004c	89 85 90 fe ff
	ff		 mov	 DWORD PTR _subPitch_1$[ebp], eax

; 135  : 
; 136  :    if ((overlap&1) == 1)

  00052	0f bf 8d 10 fd
	ff ff		 movsx	 ecx, WORD PTR _overlap$[ebp]
  00059	83 e1 01	 and	 ecx, 1
  0005c	83 f9 01	 cmp	 ecx, 1
  0005f	75 12		 jne	 SHORT $L1544

; 137  :       overlap--;

  00061	66 8b 95 10 fd
	ff ff		 mov	 dx, WORD PTR _overlap$[ebp]
  00068	66 83 ea 01	 sub	 dx, 1
  0006c	66 89 95 10 fd
	ff ff		 mov	 WORD PTR _overlap$[ebp], dx
$L1544:

; 138  : 
; 139  :    for (sub=0; sub < nSubs; sub++)

  00073	c7 85 fc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _sub$[ebp], 0
  0007d	eb 0f		 jmp	 SHORT $L1545
$L1546:
  0007f	8b 85 fc fc ff
	ff		 mov	 eax, DWORD PTR _sub$[ebp]
  00085	83 c0 01	 add	 eax, 1
  00088	89 85 fc fc ff
	ff		 mov	 DWORD PTR _sub$[ebp], eax
$L1545:
  0008e	0f bf 4d 28	 movsx	 ecx, WORD PTR _nSubs$[ebp]
  00092	39 8d fc fc ff
	ff		 cmp	 DWORD PTR _sub$[ebp], ecx
  00098	0f 8d 24 05 00
	00		 jge	 $L1522

; 140  :    {
; 141  :       {
; 142  :          STACK_INIT
; 143  :          float     Spec_sub_1[MAXHARM];
; 144  :          STACK_INIT_END
; 145  :          STACK_ATTACH(float*,Spec_sub_1)
; 146  : 
; 147  :          STACK_START
; 148  : 
; 149  :          if ((Pv > 0.0) && (Pv_1 > 0.0))

  0009e	d9 45 1c	 fld	 DWORD PTR _Pv$[ebp]
  000a1	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  000a7	df e0		 fnstsw	 ax
  000a9	f6 c4 41	 test	 ah, 65			; 00000041H
  000ac	75 3f		 jne	 SHORT $L1549
  000ae	d9 45 20	 fld	 DWORD PTR _Pv_1$[ebp]
  000b1	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  000b7	df e0		 fnstsw	 ax
  000b9	f6 c4 41	 test	 ah, 65			; 00000041H
  000bc	75 2f		 jne	 SHORT $L1549

; 150  :          {
; 151  :             interp = ((float)(sub+1))/((float)nSubs);

  000be	8b 95 fc fc ff
	ff		 mov	 edx, DWORD PTR _sub$[ebp]
  000c4	83 c2 01	 add	 edx, 1
  000c7	89 95 80 fb ff
	ff		 mov	 DWORD PTR tv299[ebp], edx
  000cd	db 85 80 fb ff
	ff		 fild	 DWORD PTR tv299[ebp]
  000d3	0f bf 45 28	 movsx	 eax, WORD PTR _nSubs$[ebp]
  000d7	89 85 7c fb ff
	ff		 mov	 DWORD PTR tv300[ebp], eax
  000dd	db 85 7c fb ff
	ff		 fild	 DWORD PTR tv300[ebp]
  000e3	de f9		 fdivp	 ST(1), ST(0)
  000e5	d9 9d 04 fd ff
	ff		 fstp	 DWORD PTR _interp$[ebp]

; 152  :          }
; 153  :          else

  000eb	eb 30		 jmp	 SHORT $L1552
$L1549:

; 154  :          {
; 155  :             interp = (sub < (nSubs>>1))?0.0F:1.0F;

  000ed	0f bf 4d 28	 movsx	 ecx, WORD PTR _nSubs$[ebp]
  000f1	d1 f9		 sar	 ecx, 1
  000f3	39 8d fc fc ff
	ff		 cmp	 DWORD PTR _sub$[ebp], ecx
  000f9	7d 0c		 jge	 SHORT $L1617
  000fb	c7 85 78 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv94[ebp], 0
  00105	eb 0a		 jmp	 SHORT $L1618
$L1617:
  00107	c7 85 78 fb ff
	ff 00 00 80 3f	 mov	 DWORD PTR tv94[ebp], 1065353216 ; 3f800000H
$L1618:
  00111	8b 95 78 fb ff
	ff		 mov	 edx, DWORD PTR tv94[ebp]
  00117	89 95 04 fd ff
	ff		 mov	 DWORD PTR _interp$[ebp], edx
$L1552:

; 156  :          }
; 157  :        /*---------------------------------
; 158  :           Don't interpolate Pv
; 159  :          ---------------------------------*/
; 160  :          subPv = (sub < (nSubs>>1))?Pv_1:Pv;

  0011d	0f bf 45 28	 movsx	 eax, WORD PTR _nSubs$[ebp]
  00121	d1 f8		 sar	 eax, 1
  00123	39 85 fc fc ff
	ff		 cmp	 DWORD PTR _sub$[ebp], eax
  00129	7d 0b		 jge	 SHORT $L1619
  0012b	8b 4d 20	 mov	 ecx, DWORD PTR _Pv_1$[ebp]
  0012e	89 8d 74 fb ff
	ff		 mov	 DWORD PTR tv130[ebp], ecx
  00134	eb 09		 jmp	 SHORT $L1620
$L1619:
  00136	8b 55 1c	 mov	 edx, DWORD PTR _Pv$[ebp]
  00139	89 95 74 fb ff
	ff		 mov	 DWORD PTR tv130[ebp], edx
$L1620:
  0013f	8b 85 74 fb ff
	ff		 mov	 eax, DWORD PTR tv130[ebp]
  00145	89 85 08 fd ff
	ff		 mov	 DWORD PTR _subPv$[ebp], eax

; 161  : 
; 162  :        /*----------------------------------------------
; 163  :          Calculate the pitch for this subframe ...
; 164  :          ----------------------------------------------*/
; 165  :          if (fabs((Pitch-Pitch_1)/Pitch) < PITCH_RANGE_FOR_INTERP)

  0014b	d9 45 14	 fld	 DWORD PTR _Pitch$[ebp]
  0014e	d8 65 18	 fsub	 DWORD PTR _Pitch_1$[ebp]
  00151	d8 75 14	 fdiv	 DWORD PTR _Pitch$[ebp]
  00154	83 ec 08	 sub	 esp, 8
  00157	dd 1c 24	 fstp	 QWORD PTR [esp]
  0015a	e8 00 00 00 00	 call	 _fabs
  0015f	83 c4 08	 add	 esp, 8
  00162	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3fc3333340000000
  00168	df e0		 fnstsw	 ax
  0016a	f6 c4 05	 test	 ah, 5
  0016d	7a 17		 jp	 SHORT $L1553

; 166  :             subPitch  = Pitch_1 + interp*(Pitch-Pitch_1);

  0016f	d9 45 14	 fld	 DWORD PTR _Pitch$[ebp]
  00172	d8 65 18	 fsub	 DWORD PTR _Pitch_1$[ebp]
  00175	d8 8d 04 fd ff
	ff		 fmul	 DWORD PTR _interp$[ebp]
  0017b	d8 45 18	 fadd	 DWORD PTR _Pitch_1$[ebp]
  0017e	d9 9d 8c fe ff
	ff		 fstp	 DWORD PTR _subPitch$[ebp]

; 167  :          else

  00184	eb 2e		 jmp	 SHORT $L1554
$L1553:

; 168  :             subPitch = (sub < (nSubs>>1))?Pitch_1:Pitch;

  00186	0f bf 4d 28	 movsx	 ecx, WORD PTR _nSubs$[ebp]
  0018a	d1 f9		 sar	 ecx, 1
  0018c	39 8d fc fc ff
	ff		 cmp	 DWORD PTR _sub$[ebp], ecx
  00192	7d 0b		 jge	 SHORT $L1621
  00194	8b 55 18	 mov	 edx, DWORD PTR _Pitch_1$[ebp]
  00197	89 95 70 fb ff
	ff		 mov	 DWORD PTR tv145[ebp], edx
  0019d	eb 09		 jmp	 SHORT $L1622
$L1621:
  0019f	8b 45 14	 mov	 eax, DWORD PTR _Pitch$[ebp]
  001a2	89 85 70 fb ff
	ff		 mov	 DWORD PTR tv145[ebp], eax
$L1622:
  001a8	8b 8d 70 fb ff
	ff		 mov	 ecx, DWORD PTR tv145[ebp]
  001ae	89 8d 8c fe ff
	ff		 mov	 DWORD PTR _subPitch$[ebp], ecx
$L1554:

; 169  :          
; 170  :          if (subPitch > MAX_PITCH)

  001b4	d9 85 8c fe ff
	ff		 fld	 DWORD PTR _subPitch$[ebp]
  001ba	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@43340000
  001c0	df e0		 fnstsw	 ax
  001c2	f6 c4 41	 test	 ah, 65			; 00000041H
  001c5	75 0a		 jne	 SHORT $L1555

; 171  :             subPitch = (float)MAX_PITCH;

  001c7	c7 85 8c fe ff
	ff 00 00 34 43	 mov	 DWORD PTR _subPitch$[ebp], 1127481344 ; 43340000H
$L1555:

; 172  :          if (subPitch < MIN_PITCH)

  001d1	d9 85 8c fe ff
	ff		 fld	 DWORD PTR _subPitch$[ebp]
  001d7	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41000000
  001dd	df e0		 fnstsw	 ax
  001df	f6 c4 05	 test	 ah, 5
  001e2	7a 0a		 jp	 SHORT $L1557

; 173  :             subPitch = (float)MIN_PITCH;

  001e4	c7 85 8c fe ff
	ff 00 00 00 41	 mov	 DWORD PTR _subPitch$[ebp], 1090519040 ; 41000000H
$L1557:

; 174  : 
; 175  :        /*-----------------------------------------------
; 176  :          Calculate the highest multiple of the pitch that
; 177  :          is still less than or equal to MAX_PITCH
; 178  :          -----------------------------------------------*/
; 179  :          pitch_mult = (short)(((float)MAX_PITCH_MULT)/subPitch);

  001ee	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@42fa0000
  001f4	d8 b5 8c fe ff
	ff		 fdiv	 DWORD PTR _subPitch$[ebp]
  001fa	e8 00 00 00 00	 call	 __ftol2
  001ff	66 89 85 f0 fc
	ff ff		 mov	 WORD PTR _pitch_mult$[ebp], ax

; 180  :          if (pitch_mult==0)

  00206	0f bf 95 f0 fc
	ff ff		 movsx	 edx, WORD PTR _pitch_mult$[ebp]
  0020d	85 d2		 test	 edx, edx
  0020f	75 09		 jne	 SHORT $L1561

; 181  :             pitch_mult=1;

  00211	66 c7 85 f0 fc
	ff ff 01 00	 mov	 WORD PTR _pitch_mult$[ebp], 1
$L1561:

; 182  : 
; 183  :          multPitch  = subPitch*((float)pitch_mult);

  0021a	0f bf 85 f0 fc
	ff ff		 movsx	 eax, WORD PTR _pitch_mult$[ebp]
  00221	89 85 6c fb ff
	ff		 mov	 DWORD PTR tv361[ebp], eax
  00227	db 85 6c fb ff
	ff		 fild	 DWORD PTR tv361[ebp]
  0022d	d8 8d 8c fe ff
	ff		 fmul	 DWORD PTR _subPitch$[ebp]
  00233	d9 9d 84 fe ff
	ff		 fstp	 DWORD PTR _multPitch$[ebp]

; 184  : 
; 185  :        /*---------------------------------------------------
; 186  :          Calcuate the number of harmonics for multPitch, and
; 187  :          the number of voiced harmonics.  The true number
; 188  :          of voiced harmonics will be the largest even value
; 189  :          less than or equal to the value calculated divided
; 190  :          by pitch_mult (since this is what we multiplied the
; 191  :          true voiced pitch by.
; 192  :          ---------------------------------------------------*/
; 193  :          tempvHarm = getvHarm(subPitch, subPv);

  00239	8b 8d 08 fd ff
	ff		 mov	 ecx, DWORD PTR _subPv$[ebp]
  0023f	51		 push	 ecx
  00240	8b 95 8c fe ff
	ff		 mov	 edx, DWORD PTR _subPitch$[ebp]
  00246	52		 push	 edx
  00247	e8 00 00 00 00	 call	 _getvHarm@8
  0024c	66 89 85 00 fd
	ff ff		 mov	 WORD PTR _tempvHarm$[ebp], ax

; 194  :          subvHarm  = pitch_mult*tempvHarm;

  00253	0f bf 85 f0 fc
	ff ff		 movsx	 eax, WORD PTR _pitch_mult$[ebp]
  0025a	0f bf 8d 00 fd
	ff ff		 movsx	 ecx, WORD PTR _tempvHarm$[ebp]
  00261	0f af c1	 imul	 eax, ecx
  00264	66 89 85 94 fe
	ff ff		 mov	 WORD PTR _subvHarm$[ebp], ax

; 195  :          subnHarm  = getnHarm(multPitch);

  0026b	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR _multPitch$[ebp]
  00271	52		 push	 edx
  00272	e8 00 00 00 00	 call	 _getnHarm@4
  00277	66 89 85 80 fe
	ff ff		 mov	 WORD PTR _subnHarm$[ebp], ax

; 196  : 
; 197  :          if (subnHarm > MAXHARM)

  0027e	0f bf 85 80 fe
	ff ff		 movsx	 eax, WORD PTR _subnHarm$[ebp]
  00285	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  00288	7e 09		 jle	 SHORT $L1563

; 198  :             subnHarm=MAXHARM;

  0028a	66 c7 85 80 fe
	ff ff 5a 00	 mov	 WORD PTR _subnHarm$[ebp], 90 ; 0000005aH
$L1563:

; 199  :          if (subvHarm > MAXHARM)

  00293	0f bf 8d 94 fe
	ff ff		 movsx	 ecx, WORD PTR _subvHarm$[ebp]
  0029a	83 f9 5a	 cmp	 ecx, 90			; 0000005aH
  0029d	7e 09		 jle	 SHORT $L1564

; 200  :             subvHarm=MAXHARM;

  0029f	66 c7 85 94 fe
	ff ff 5a 00	 mov	 WORD PTR _subvHarm$[ebp], 90 ; 0000005aH
$L1564:

; 201  : 
; 202  :          for (i=0; i < subvHarm; i++)

  002a8	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  002b2	eb 0f		 jmp	 SHORT $L1565
$L1566:
  002b4	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  002ba	83 c2 01	 add	 edx, 1
  002bd	89 95 88 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$L1565:
  002c3	0f bf 85 94 fe
	ff ff		 movsx	 eax, WORD PTR _subvHarm$[ebp]
  002ca	39 85 88 fe ff
	ff		 cmp	 DWORD PTR _i$[ebp], eax
  002d0	7d 13		 jge	 SHORT $L1567

; 203  :             inPhase[i] = 0;

  002d2	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  002d8	c7 84 8d 98 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _inPhase$[ebp+ecx*4], 0
  002e3	eb cf		 jmp	 SHORT $L1566
$L1567:

; 204  : 
; 205  :        /*----------------------------------------------------
; 206  :           Patent Breaking Magical 7 ...
; 207  :          ----------------------------------------------------*/
; 208  :          if (tempvHarm > 0)

  002e5	0f bf 95 00 fd
	ff ff		 movsx	 edx, WORD PTR _tempvHarm$[ebp]
  002ec	85 d2		 test	 edx, edx
  002ee	7e 21		 jle	 SHORT $L1568

; 209  :             inPhase[(((tempvHarm>>1)+1)*pitch_mult)-1] = 7; 

  002f0	0f bf 85 00 fd
	ff ff		 movsx	 eax, WORD PTR _tempvHarm$[ebp]
  002f7	d1 f8		 sar	 eax, 1
  002f9	83 c0 01	 add	 eax, 1
  002fc	0f bf 8d f0 fc
	ff ff		 movsx	 ecx, WORD PTR _pitch_mult$[ebp]
  00303	0f af c1	 imul	 eax, ecx
  00306	c7 84 85 94 fe
	ff ff 07 00 00
	00		 mov	 DWORD PTR _inPhase$[ebp+eax*4-4], 7
$L1568:

; 210  : 
; 211  :        /*-----------------------------------------------
; 212  :          Calculate the harmonic amplitudes at the 
; 213  :          current subframe pitch value...
; 214  :          -----------------------------------------------*/
; 215  :          SpecIntLn(Pitch_1, multPitch, (const int) subnHarm, Amps_1, 
; 216  :                    Spec_sub_1, (const unsigned int) MAXHARM);

  00311	6a 5a		 push	 90			; 0000005aH
  00313	8d 95 88 fb ff
	ff		 lea	 edx, DWORD PTR _Spec_sub_1$1548[ebp]
  00319	52		 push	 edx
  0031a	8b 45 10	 mov	 eax, DWORD PTR _Amps_1$[ebp]
  0031d	50		 push	 eax
  0031e	0f bf 8d 80 fe
	ff ff		 movsx	 ecx, WORD PTR _subnHarm$[ebp]
  00325	51		 push	 ecx
  00326	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR _multPitch$[ebp]
  0032c	52		 push	 edx
  0032d	8b 45 18	 mov	 eax, DWORD PTR _Pitch_1$[ebp]
  00330	50		 push	 eax
  00331	e8 00 00 00 00	 call	 _SpecIntLn@24

; 217  :          SpecIntLn(Pitch, multPitch, (const int) subnHarm, Amps, 
; 218  :                    Spec_sub, (const unsigned int) MAXHARM);

  00336	6a 5a		 push	 90			; 0000005aH
  00338	8d 8d 18 fd ff
	ff		 lea	 ecx, DWORD PTR _Spec_sub$[ebp]
  0033e	51		 push	 ecx
  0033f	8b 55 0c	 mov	 edx, DWORD PTR _Amps$[ebp]
  00342	52		 push	 edx
  00343	0f bf 85 80 fe
	ff ff		 movsx	 eax, WORD PTR _subnHarm$[ebp]
  0034a	50		 push	 eax
  0034b	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _multPitch$[ebp]
  00351	51		 push	 ecx
  00352	8b 55 14	 mov	 edx, DWORD PTR _Pitch$[ebp]
  00355	52		 push	 edx
  00356	e8 00 00 00 00	 call	 _SpecIntLn@24

; 219  : 
; 220  :          for (i=0; i < subnHarm; i++)

  0035b	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00365	eb 0f		 jmp	 SHORT $L1573
$L1574:
  00367	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0036d	83 c0 01	 add	 eax, 1
  00370	89 85 88 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L1573:
  00376	0f bf 8d 80 fe
	ff ff		 movsx	 ecx, WORD PTR _subnHarm$[ebp]
  0037d	39 8d 88 fe ff
	ff		 cmp	 DWORD PTR _i$[ebp], ecx
  00383	7d 3c		 jge	 SHORT $L1575

; 221  :             Spec_sub[i] = Spec_sub_1[i] + 
; 222  :             interp*(Spec_sub[i]-Spec_sub_1[i]);

  00385	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0038b	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00391	d9 84 95 18 fd
	ff ff		 fld	 DWORD PTR _Spec_sub$[ebp+edx*4]
  00398	d8 a4 85 88 fb
	ff ff		 fsub	 DWORD PTR _Spec_sub_1$1548[ebp+eax*4]
  0039f	d8 8d 04 fd ff
	ff		 fmul	 DWORD PTR _interp$[ebp]
  003a5	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  003ab	d8 84 8d 88 fb
	ff ff		 fadd	 DWORD PTR _Spec_sub_1$1548[ebp+ecx*4]
  003b2	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  003b8	d9 9c 95 18 fd
	ff ff		 fstp	 DWORD PTR _Spec_sub$[ebp+edx*4]
  003bf	eb a6		 jmp	 SHORT $L1574
$L1575:

; 223  : 
; 224  :          STACK_END
; 225  :       }
; 226  : 
; 227  :     /*-----------------------------------------------
; 228  :       Set the unwanted harmonics to zero ...
; 229  :       -----------------------------------------------*/
; 230  :       for (i=0; i < pitch_mult-1; i++)

  003c1	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  003cb	eb 0f		 jmp	 SHORT $L1576
$L1577:
  003cd	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  003d3	83 c0 01	 add	 eax, 1
  003d6	89 85 88 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L1576:
  003dc	0f bf 8d f0 fc
	ff ff		 movsx	 ecx, WORD PTR _pitch_mult$[ebp]
  003e3	83 e9 01	 sub	 ecx, 1
  003e6	39 8d 88 fe ff
	ff		 cmp	 DWORD PTR _i$[ebp], ecx
  003ec	7d 47		 jge	 SHORT $L1578

; 231  :       {
; 232  :          for (j=i; j < subvHarm; j+=pitch_mult)

  003ee	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  003f4	89 95 f4 fc ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
  003fa	eb 15		 jmp	 SHORT $L1579
$L1580:
  003fc	0f bf 85 f0 fc
	ff ff		 movsx	 eax, WORD PTR _pitch_mult$[ebp]
  00403	8b 8d f4 fc ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00409	03 c8		 add	 ecx, eax
  0040b	89 8d f4 fc ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx
$L1579:
  00411	0f bf 95 94 fe
	ff ff		 movsx	 edx, WORD PTR _subvHarm$[ebp]
  00418	39 95 f4 fc ff
	ff		 cmp	 DWORD PTR _j$[ebp], edx
  0041e	7d 13		 jge	 SHORT $L1581

; 233  :          {
; 234  :             Spec_sub[j] = 0.0F;

  00420	8b 85 f4 fc ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00426	c7 84 85 18 fd
	ff ff 00 00 00
	00		 mov	 DWORD PTR _Spec_sub$[ebp+eax*4], 0

; 235  :          }

  00431	eb c9		 jmp	 SHORT $L1580
$L1581:

; 236  :       }

  00433	eb 98		 jmp	 SHORT $L1577
$L1578:

; 237  : 
; 238  :     /*-----------------------------------------------
; 239  :       Calculate the desired unvoiced energy ...
; 240  :       -----------------------------------------------*/
; 241  :       uv_energy_desired = 0.0F;

  00435	c7 85 14 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _uv_energy_desired$[ebp], 0

; 242  :       for (i=subvHarm+pitch_mult-1; i < subnHarm; i+=pitch_mult)

  0043f	0f bf 8d 94 fe
	ff ff		 movsx	 ecx, WORD PTR _subvHarm$[ebp]
  00446	0f bf 95 f0 fc
	ff ff		 movsx	 edx, WORD PTR _pitch_mult$[ebp]
  0044d	8d 44 11 ff	 lea	 eax, DWORD PTR [ecx+edx-1]
  00451	89 85 88 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
  00457	eb 15		 jmp	 SHORT $L1582
$L1583:
  00459	0f bf 8d f0 fc
	ff ff		 movsx	 ecx, WORD PTR _pitch_mult$[ebp]
  00460	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00466	03 d1		 add	 edx, ecx
  00468	89 95 88 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$L1582:
  0046e	0f bf 85 80 fe
	ff ff		 movsx	 eax, WORD PTR _subnHarm$[ebp]
  00475	39 85 88 fe ff
	ff		 cmp	 DWORD PTR _i$[ebp], eax
  0047b	7d 28		 jge	 SHORT $L1584

; 243  :       {
; 244  :          uv_energy_desired += (Spec_sub[i])*(Spec_sub[i]);

  0047d	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00483	d9 84 8d 18 fd
	ff ff		 fld	 DWORD PTR _Spec_sub$[ebp+ecx*4]
  0048a	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00490	d8 8c 95 18 fd
	ff ff		 fmul	 DWORD PTR _Spec_sub$[ebp+edx*4]
  00497	d8 85 14 fd ff
	ff		 fadd	 DWORD PTR _uv_energy_desired$[ebp]
  0049d	d9 9d 14 fd ff
	ff		 fstp	 DWORD PTR _uv_energy_desired$[ebp]

; 245  :       }

  004a3	eb b4		 jmp	 SHORT $L1583
$L1584:

; 246  :     /*------------------------------------------------
; 247  :       Rescale the unvoiced energy ...
; 248  :       ------------------------------------------------*/
; 249  :       L2Scale(&(Spec_sub[subvHarm]), (int) (subnHarm-subvHarm), 
; 250  :               uv_energy_desired*UV_SUPPRESSION_FACTOR);

  004a5	d9 85 14 fd ff
	ff		 fld	 DWORD PTR _uv_energy_desired$[ebp]
  004ab	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  004b1	51		 push	 ecx
  004b2	d9 1c 24	 fstp	 DWORD PTR [esp]
  004b5	0f bf 85 80 fe
	ff ff		 movsx	 eax, WORD PTR _subnHarm$[ebp]
  004bc	0f bf 8d 94 fe
	ff ff		 movsx	 ecx, WORD PTR _subvHarm$[ebp]
  004c3	2b c1		 sub	 eax, ecx
  004c5	50		 push	 eax
  004c6	0f bf 95 94 fe
	ff ff		 movsx	 edx, WORD PTR _subvHarm$[ebp]
  004cd	8d 84 95 18 fd
	ff ff		 lea	 eax, DWORD PTR _Spec_sub$[ebp+edx*4]
  004d4	50		 push	 eax
  004d5	e8 00 00 00 00	 call	 _L2Scale@12

; 251  : 
; 252  :     /*------------------------------------------------
; 253  :       Randomize the unvoiced phase ...
; 254  :       ------------------------------------------------*/
; 255  :       for (i=subvHarm; i < subnHarm; i++)

  004da	0f bf 8d 94 fe
	ff ff		 movsx	 ecx, WORD PTR _subvHarm$[ebp]
  004e1	89 8d 88 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
  004e7	eb 0f		 jmp	 SHORT $L1586
$L1587:
  004e9	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  004ef	83 c2 01	 add	 edx, 1
  004f2	89 95 88 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$L1586:
  004f8	0f bf 85 80 fe
	ff ff		 movsx	 eax, WORD PTR _subnHarm$[ebp]
  004ff	39 85 88 fe ff
	ff		 cmp	 DWORD PTR _i$[ebp], eax
  00505	7d 26		 jge	 SHORT $L1588

; 256  :       {
; 257  :          inPhase[i] = (int)((NuRand(&(SWS_mblk->lNrSeed)))&(TRIG_SIZE-1));

  00507	8b 8d 0c fd ff
	ff		 mov	 ecx, DWORD PTR _SWS_mblk$[ebp]
  0050d	81 c1 20 04 00
	00		 add	 ecx, 1056		; 00000420H
  00513	51		 push	 ecx
  00514	e8 00 00 00 00	 call	 _NuRand@4
  00519	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0051e	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00524	89 84 95 98 fe
	ff ff		 mov	 DWORD PTR _inPhase$[ebp+edx*4], eax

; 258  :       }

  0052b	eb bc		 jmp	 SHORT $L1587
$L1588:

; 259  : 
; 260  : #if USE_FHT_SYN==1
; 261  :       HarmSynFHTFloat(STACK_S Spec_sub, inPhase, multPitch, subPitch, 
; 262  :          subPitch_1, &SWS_mblk->fNormPhase, &SWS_mblk->fVoicePhase,
; 263  :          &SWS_mblk->fResampRate, subnHarm, SWS_mblk->PitchCycle, 
; 264  :          &(outspeech[sub*subframeLEN]), subframeLEN, (short)(overlap));

  0052d	66 8b 85 10 fd
	ff ff		 mov	 ax, WORD PTR _overlap$[ebp]
  00534	50		 push	 eax
  00535	66 8b 8d f8 fc
	ff ff		 mov	 cx, WORD PTR _subframeLEN$[ebp]
  0053c	51		 push	 ecx
  0053d	0f bf 95 f8 fc
	ff ff		 movsx	 edx, WORD PTR _subframeLEN$[ebp]
  00544	8b 85 fc fc ff
	ff		 mov	 eax, DWORD PTR _sub$[ebp]
  0054a	0f af c2	 imul	 eax, edx
  0054d	8b 4d 2c	 mov	 ecx, DWORD PTR _outspeech$[ebp]
  00550	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00553	52		 push	 edx
  00554	8b 85 0c fd ff
	ff		 mov	 eax, DWORD PTR _SWS_mblk$[ebp]
  0055a	50		 push	 eax
  0055b	66 8b 8d 80 fe
	ff ff		 mov	 cx, WORD PTR _subnHarm$[ebp]
  00562	51		 push	 ecx
  00563	8b 95 0c fd ff
	ff		 mov	 edx, DWORD PTR _SWS_mblk$[ebp]
  00569	81 c2 10 04 00
	00		 add	 edx, 1040		; 00000410H
  0056f	52		 push	 edx
  00570	8b 85 0c fd ff
	ff		 mov	 eax, DWORD PTR _SWS_mblk$[ebp]
  00576	05 18 04 00 00	 add	 eax, 1048		; 00000418H
  0057b	50		 push	 eax
  0057c	8b 8d 0c fd ff
	ff		 mov	 ecx, DWORD PTR _SWS_mblk$[ebp]
  00582	81 c1 14 04 00
	00		 add	 ecx, 1044		; 00000414H
  00588	51		 push	 ecx
  00589	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _subPitch_1$[ebp]
  0058f	52		 push	 edx
  00590	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _subPitch$[ebp]
  00596	50		 push	 eax
  00597	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _multPitch$[ebp]
  0059d	51		 push	 ecx
  0059e	8d 95 98 fe ff
	ff		 lea	 edx, DWORD PTR _inPhase$[ebp]
  005a4	52		 push	 edx
  005a5	8d 85 18 fd ff
	ff		 lea	 eax, DWORD PTR _Spec_sub$[ebp]
  005ab	50		 push	 eax
  005ac	e8 00 00 00 00	 call	 _HarmSynFHTFloat@52

; 265  : #else
; 266  : {
; 267  :    float Phase[MAXHARM];
; 268  : 
; 269  :    for (i=0; i<subnHarm; i++)
; 270  :       Phase[i] = ((float)inPhase[i])*D_PI*( 1.0/(TRIG_SIZE) );
; 271  : 
; 272  :       SumSyn(STACK_S SWS_mblk->pvSumSynBlk, Spec_sub, subPitch, subPitch_1, 
; 273  :          Phase, multPitch, pitch_mult, subnHarm, subvHarm, subframeLEN, 
; 274  :          (float)OVERLAPFACTOR, &(outspeech[sub*subframeLEN]));
; 275  : }
; 276  : #endif
; 277  : 
; 278  :       subPitch_1 = subPitch;

  005b1	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR _subPitch$[ebp]
  005b7	89 8d 90 fe ff
	ff		 mov	 DWORD PTR _subPitch_1$[ebp], ecx

; 279  :    }

  005bd	e9 bd fa ff ff	 jmp	 $L1546
$L1522:

; 280  :    STACK_END
; 281  : 
; 282  : }

  005c2	8b e5		 mov	 esp, ebp
  005c4	5d		 pop	 ebp
  005c5	c2 28 00	 ret	 40			; 00000028H
_VoxSws@40 ENDP
_TEXT	ENDS
PUBLIC	_VoxInitSws@4
EXTRN	_InitSumSyn@4:NEAR
EXTRN	_calloc:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxInitSws@4
_TEXT	SEGMENT
_pSws$ = -8
_i$ = -4
_hSws$ = 8
_VoxInitSws@4 PROC NEAR					; COMDAT

; 285  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 286  :    SWS *pSws;
; 287  :    int i;
; 288  : 
; 289  :    if (VOX_MEM_INIT(pSws=*hSws, 1, sizeof(SWS))) 

  00006	68 24 04 00 00	 push	 1060			; 00000424H
  0000b	6a 01		 push	 1
  0000d	e8 00 00 00 00	 call	 _calloc
  00012	83 c4 08	 add	 esp, 8
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _hSws$[ebp]
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	8b 55 08	 mov	 edx, DWORD PTR _hSws$[ebp]
  0001d	8b 02		 mov	 eax, DWORD PTR [edx]
  0001f	89 45 f8	 mov	 DWORD PTR _pSws$[ebp], eax
  00022	83 7d f8 00	 cmp	 DWORD PTR _pSws$[ebp], 0
  00026	75 06		 jne	 SHORT $L1597

; 290  :       return 1;

  00028	66 b8 01 00	 mov	 ax, 1
  0002c	eb 7d		 jmp	 SHORT $L1593
$L1597:

; 291  : 
; 292  :    if(InitSumSyn(&pSws->pvSumSynBlk))

  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _pSws$[ebp]
  00031	81 c1 1c 04 00
	00		 add	 ecx, 1052		; 0000041cH
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 _InitSumSyn@4
  0003d	0f b7 d0	 movzx	 edx, ax
  00040	85 d2		 test	 edx, edx
  00042	74 06		 je	 SHORT $L1598

; 293  :       return 1;

  00044	66 b8 01 00	 mov	 ax, 1
  00048	eb 61		 jmp	 SHORT $L1593
$L1598:

; 294  : 
; 295  :    /* initializing static variables */
; 296  :    for (i=0; i < EXP_SIZE+PP_NUM_SAMPLES; i++) 

  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00051	eb 09		 jmp	 SHORT $L1599
$L1600:
  00053	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00056	83 c0 01	 add	 eax, 1
  00059	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L1599:
  0005c	81 7d fc 04 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 260	; 00000104H
  00063	7d 0f		 jge	 SHORT $L1601

; 297  :       pSws->PitchCycle[i] = 0.0F;

  00065	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00068	8b 55 f8	 mov	 edx, DWORD PTR _pSws$[ebp]
  0006b	c7 04 8a 00 00
	00 00		 mov	 DWORD PTR [edx+ecx*4], 0
  00072	eb df		 jmp	 SHORT $L1600
$L1601:

; 298  : 
; 299  :    pSws->fResampRate = 0.0F;

  00074	8b 45 f8	 mov	 eax, DWORD PTR _pSws$[ebp]
  00077	c7 80 10 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1040], 0

; 300  :    pSws->fNormPhase  = 0.0F;

  00081	8b 4d f8	 mov	 ecx, DWORD PTR _pSws$[ebp]
  00084	c7 81 14 04 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1044], 0

; 301  :    pSws->fVoicePhase = 0.0F;

  0008e	8b 55 f8	 mov	 edx, DWORD PTR _pSws$[ebp]
  00091	c7 82 18 04 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1048], 0

; 302  : 
; 303  :    pSws->lNrSeed = 1L;  /* initial seed for random number generator */

  0009b	8b 45 f8	 mov	 eax, DWORD PTR _pSws$[ebp]
  0009e	c7 80 20 04 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1056], 1

; 304  : 
; 305  :    return 0;

  000a8	66 33 c0	 xor	 ax, ax
$L1593:

; 306  : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 04 00	 ret	 4
_VoxInitSws@4 ENDP
_TEXT	ENDS
PUBLIC	_VoxFreeSws@4
EXTRN	_FreeSumSyn@4:NEAR
EXTRN	_free:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxFreeSws@4
_TEXT	SEGMENT
_hSws$ = 8
_VoxFreeSws@4 PROC NEAR					; COMDAT

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 310  :    FreeSumSyn(&(((SWS *)(*hSws))->pvSumSynBlk));

  00003	8b 45 08	 mov	 eax, DWORD PTR _hSws$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	81 c1 1c 04 00
	00		 add	 ecx, 1052		; 0000041cH
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 _FreeSumSyn@4

; 311  : 
; 312  :    VOX_MEM_FREE(*hSws);

  00014	8b 55 08	 mov	 edx, DWORD PTR _hSws$[ebp]
  00017	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0001a	74 17		 je	 SHORT $L1606
  0001c	8b 45 08	 mov	 eax, DWORD PTR _hSws$[ebp]
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 _free
  00027	83 c4 04	 add	 esp, 4
  0002a	8b 55 08	 mov	 edx, DWORD PTR _hSws$[ebp]
  0002d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L1606:

; 313  : 
; 314  :    return 0;

  00033	66 33 c0	 xor	 ax, ax

; 315  : }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
_VoxFreeSws@4 ENDP
_TEXT	ENDS
END
