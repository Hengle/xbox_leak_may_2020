; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\setamps.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EA@NMKPHOEC@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@NNAGLLLM@?$CIpfLogAmps?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfMinFaz@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@OCAGJFPK@?$CIpfEnv?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfEnv_1?5?$CB?$DN?5N@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JCMOAOPJ@?$CIpfPhase?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase_1?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@JOPNNHIE@fWarpedFreq?5?$DO?$DN?50?40F?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@KGNILEKI@iIndex?5?$DM?5CSENV_NFFT_2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LMDCCNJF@pfLogAmps?$CB?$DNNULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@DABJIJMH@pfMinFaz?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _SetAmpAndPhase@44
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _AddSubHarmonics@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	??_C@_0EA@NMKPHOEC@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CK@NNAGLLLM@?$CIpfLogAmps?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfMinFaz@ ; `string'
PUBLIC	??_C@_0CF@OCAGJFPK@?$CIpfEnv?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfEnv_1?5?$CB?$DN?5N@ ; `string'
PUBLIC	??_C@_0CJ@JCMOAOPJ@?$CIpfPhase?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase_1?5@ ; `string'
PUBLIC	??_C@_0BE@JOPNNHIE@fWarpedFreq?5?$DO?$DN?50?40F?$AA@ ; `string'
PUBLIC	??_C@_0BG@KGNILEKI@iIndex?5?$DM?5CSENV_NFFT_2?$AA@ ; `string'
PUBLIC	__real@3e800000
PUBLIC	__real@00000000
PUBLIC	_SetAmpAndPhase@44
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	__assert:NEAR
EXTRN	_CalcWarpedFreq@4:NEAR
;	COMDAT ??_C@_0EA@NMKPHOEC@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\setamps.c
CONST	SEGMENT
??_C@_0EA@NMKPHOEC@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\setamps.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NNAGLLLM@?$CIpfLogAmps?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfMinFaz@
CONST	SEGMENT
??_C@_0CK@NNAGLLLM@?$CIpfLogAmps?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfMinFaz@ DB '('
	DB	'pfLogAmps != NULL) && (pfMinFaz != NULL)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OCAGJFPK@?$CIpfEnv?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfEnv_1?5?$CB?$DN?5N@
CONST	SEGMENT
??_C@_0CF@OCAGJFPK@?$CIpfEnv?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfEnv_1?5?$CB?$DN?5N@ DB '('
	DB	'pfEnv != NULL) && (pfEnv_1 != NULL)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JCMOAOPJ@?$CIpfPhase?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase_1?5@
CONST	SEGMENT
??_C@_0CJ@JCMOAOPJ@?$CIpfPhase?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase_1?5@ DB '('
	DB	'pfPhase != NULL) && (pfPhase_1 != NULL)', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BE@JOPNNHIE@fWarpedFreq?5?$DO?$DN?50?40F?$AA@
CONST	SEGMENT
??_C@_0BE@JOPNNHIE@fWarpedFreq?5?$DO?$DN?50?40F?$AA@ DB 'fWarpedFreq >= 0'
	DB	'.0F', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KGNILEKI@iIndex?5?$DM?5CSENV_NFFT_2?$AA@
CONST	SEGMENT
??_C@_0BG@KGNILEKI@iIndex?5?$DM?5CSENV_NFFT_2?$AA@ DB 'iIndex < CSENV_NFF'
	DB	'T_2', 00H					; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _SetAmpAndPhase@44
_TEXT	SEGMENT
_fFreq$ = -36
_fEnv$ = -32
_fFreqInterp$ = -28
_iIndex$ = -24
_fEnv_1$ = -20
_fPhase$ = -16
_n$ = -12
_fWarpedFreq$ = -8
_fPhase_1$ = -4
_fNoiseScale$ = 8
_fPitchDFT$ = 12
_pfLogAmps$ = 16
_pfMinFaz$ = 20
_iHarmonics$ = 24
_iVoicHarm$ = 28
_pfEnv$ = 32
_pfEnv_1$ = 36
_pfPhase$ = 40
_pfPhase_1$ = 44
_fInterpFactor$ = 48
_SetAmpAndPhase@44 PROC NEAR				; COMDAT

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 109  :    int   n;
; 110  :    int   iIndex;
; 111  :    float fWarpedFreq;
; 112  :    float fFreqInterp;
; 113  :    float fFreq;
; 114  :    float fEnv, fEnv_1;
; 115  :    float fPhase, fPhase_1;
; 116  : 
; 117  :    assert((pfLogAmps != NULL) && (pfMinFaz != NULL));

  00006	83 7d 10 00	 cmp	 DWORD PTR _pfLogAmps$[ebp], 0
  0000a	74 06		 je	 SHORT $L1097
  0000c	83 7d 14 00	 cmp	 DWORD PTR _pfMinFaz$[ebp], 0
  00010	75 14		 jne	 SHORT $L1098
$L1097:
  00012	6a 75		 push	 117			; 00000075H
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@NMKPHOEC@c?3?2xbox?2private?2windows?2directx?2@
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@NNAGLLLM@?$CIpfLogAmps?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfMinFaz@
  0001e	e8 00 00 00 00	 call	 __assert
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1098:

; 118  :    assert((pfEnv != NULL) && (pfEnv_1 != NULL));

  00026	83 7d 20 00	 cmp	 DWORD PTR _pfEnv$[ebp], 0
  0002a	74 06		 je	 SHORT $L1099
  0002c	83 7d 24 00	 cmp	 DWORD PTR _pfEnv_1$[ebp], 0
  00030	75 14		 jne	 SHORT $L1100
$L1099:
  00032	6a 76		 push	 118			; 00000076H
  00034	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@NMKPHOEC@c?3?2xbox?2private?2windows?2directx?2@
  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@OCAGJFPK@?$CIpfEnv?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfEnv_1?5?$CB?$DN?5N@
  0003e	e8 00 00 00 00	 call	 __assert
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1100:

; 119  :    assert((pfPhase != NULL) && (pfPhase_1 != NULL));

  00046	83 7d 28 00	 cmp	 DWORD PTR _pfPhase$[ebp], 0
  0004a	74 06		 je	 SHORT $L1101
  0004c	83 7d 2c 00	 cmp	 DWORD PTR _pfPhase_1$[ebp], 0
  00050	75 14		 jne	 SHORT $L1102
$L1101:
  00052	6a 77		 push	 119			; 00000077H
  00054	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@NMKPHOEC@c?3?2xbox?2private?2windows?2directx?2@
  00059	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@JCMOAOPJ@?$CIpfPhase?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase_1?5@
  0005e	e8 00 00 00 00	 call	 __assert
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1102:

; 120  : 
; 121  :    fFreq = fPitchDFT;

  00066	8b 45 0c	 mov	 eax, DWORD PTR _fPitchDFT$[ebp]
  00069	89 45 dc	 mov	 DWORD PTR _fFreq$[ebp], eax

; 122  : 
; 123  :    /*-------------------------------------------------------------------
; 124  :      The points at PI must be set to avoid
; 125  :      if statements within a for loop in SetAmpAndPhase().
; 126  :    -------------------------------------------------------------------*/
; 127  :    pfEnv[CSENV_NFFT_2]   = pfEnv[CSENV_NFFT_2-1];

  0006c	8b 4d 20	 mov	 ecx, DWORD PTR _pfEnv$[ebp]
  0006f	8b 55 20	 mov	 edx, DWORD PTR _pfEnv$[ebp]
  00072	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  00078	89 81 00 01 00
	00		 mov	 DWORD PTR [ecx+256], eax

; 128  :    pfPhase[CSENV_NFFT_2]   = pfPhase[CSENV_NFFT_2-1];

  0007e	8b 4d 28	 mov	 ecx, DWORD PTR _pfPhase$[ebp]
  00081	8b 55 28	 mov	 edx, DWORD PTR _pfPhase$[ebp]
  00084	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  0008a	89 81 00 01 00
	00		 mov	 DWORD PTR [ecx+256], eax

; 129  : 
; 130  :    for (n = 0; n < iHarmonics; n++) {

  00090	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00097	eb 09		 jmp	 SHORT $L1034
$L1035:
  00099	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  0009c	83 c1 01	 add	 ecx, 1
  0009f	89 4d f4	 mov	 DWORD PTR _n$[ebp], ecx
$L1034:
  000a2	8b 55 f4	 mov	 edx, DWORD PTR _n$[ebp]
  000a5	3b 55 18	 cmp	 edx, DWORD PTR _iHarmonics$[ebp]
  000a8	0f 8d 2c 01 00
	00		 jge	 $L1036

; 131  : 
; 132  :       /*------------------------------------------------------------------
; 133  :         Compute warped frequency on 64 point scale
; 134  :       ------------------------------------------------------------------*/
; 135  :       fWarpedFreq = CalcWarpedFreq(fFreq)*WARP_FREQ_SCALE;

  000ae	8b 45 dc	 mov	 eax, DWORD PTR _fFreq$[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _CalcWarpedFreq@4
  000b7	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e800000
  000bd	d9 5d f8	 fstp	 DWORD PTR _fWarpedFreq$[ebp]

; 136  : 
; 137  :       fFreq += fPitchDFT;

  000c0	d9 45 dc	 fld	 DWORD PTR _fFreq$[ebp]
  000c3	d8 45 0c	 fadd	 DWORD PTR _fPitchDFT$[ebp]
  000c6	d9 5d dc	 fstp	 DWORD PTR _fFreq$[ebp]

; 138  : 
; 139  :       /*------------------------------------------------------------------
; 140  :         Confine frequency to range of 0.0 <= fWarpedFreq <= fLastEnvelopePoint
; 141  :           WARNING: This will actually read from the envelopes
; 142  :                    0<=i<=(fLastEnvelopePoint+1) so be sure the envelopes 
; 143  :                    are (fLastEnvelopePoint+2) points 
; 144  :                    long! (One alternative is to put an if statment 
; 145  :                    in the loop, but this would be slow)
; 146  :       ------------------------------------------------------------------*/
; 147  :       assert(fWarpedFreq >= 0.0F);

  000c9	d9 45 f8	 fld	 DWORD PTR _fWarpedFreq$[ebp]
  000cc	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  000d2	df e0		 fnstsw	 ax
  000d4	f6 c4 01	 test	 ah, 1
  000d7	74 17		 je	 SHORT $L1103
  000d9	68 93 00 00 00	 push	 147			; 00000093H
  000de	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@NMKPHOEC@c?3?2xbox?2private?2windows?2directx?2@
  000e3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JOPNNHIE@fWarpedFreq?5?$DO?$DN?50?40F?$AA@
  000e8	e8 00 00 00 00	 call	 __assert
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1103:

; 148  :       iIndex = VoxFLOORpos( fWarpedFreq );

  000f0	d9 45 f8	 fld	 DWORD PTR _fWarpedFreq$[ebp]
  000f3	e8 00 00 00 00	 call	 __ftol2
  000f8	89 45 e8	 mov	 DWORD PTR _iIndex$[ebp], eax

; 149  : 
; 150  :       assert(iIndex < CSENV_NFFT_2);

  000fb	83 7d e8 40	 cmp	 DWORD PTR _iIndex$[ebp], 64 ; 00000040H
  000ff	7c 17		 jl	 SHORT $L1104
  00101	68 96 00 00 00	 push	 150			; 00000096H
  00106	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@NMKPHOEC@c?3?2xbox?2private?2windows?2directx?2@
  0010b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@KGNILEKI@iIndex?5?$DM?5CSENV_NFFT_2?$AA@
  00110	e8 00 00 00 00	 call	 __assert
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1104:

; 151  :       fFreqInterp = fWarpedFreq - (float) iIndex;

  00118	db 45 e8	 fild	 DWORD PTR _iIndex$[ebp]
  0011b	d8 6d f8	 fsubr	 DWORD PTR _fWarpedFreq$[ebp]
  0011e	d9 5d e4	 fstp	 DWORD PTR _fFreqInterp$[ebp]

; 152  : 
; 153  :       /*------------------------------------------------------------------
; 154  :         Interpolate Log amplitude envelopes, first in frequency, 
; 155  :           then in time.
; 156  :       ------------------------------------------------------------------*/
; 157  :       fEnv_1 = VoxINTERP( pfEnv_1[iIndex], pfEnv_1[iIndex+1], fFreqInterp );

  00121	8b 45 e8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00124	8b 4d 24	 mov	 ecx, DWORD PTR _pfEnv_1$[ebp]
  00127	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  0012a	8b 55 e8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0012d	8b 45 24	 mov	 eax, DWORD PTR _pfEnv_1$[ebp]
  00130	d9 44 90 04	 fld	 DWORD PTR [eax+edx*4+4]
  00134	8b 4d e8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00137	8b 55 24	 mov	 edx, DWORD PTR _pfEnv_1$[ebp]
  0013a	d8 24 8a	 fsub	 DWORD PTR [edx+ecx*4]
  0013d	d8 4d e4	 fmul	 DWORD PTR _fFreqInterp$[ebp]
  00140	de c1		 faddp	 ST(1), ST(0)
  00142	d9 5d ec	 fstp	 DWORD PTR _fEnv_1$[ebp]

; 158  :       fEnv = VoxINTERP( pfEnv[iIndex], pfEnv[iIndex+1], fFreqInterp);

  00145	8b 45 e8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00148	8b 4d 20	 mov	 ecx, DWORD PTR _pfEnv$[ebp]
  0014b	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  0014e	8b 55 e8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00151	8b 45 20	 mov	 eax, DWORD PTR _pfEnv$[ebp]
  00154	d9 44 90 04	 fld	 DWORD PTR [eax+edx*4+4]
  00158	8b 4d e8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0015b	8b 55 20	 mov	 edx, DWORD PTR _pfEnv$[ebp]
  0015e	d8 24 8a	 fsub	 DWORD PTR [edx+ecx*4]
  00161	d8 4d e4	 fmul	 DWORD PTR _fFreqInterp$[ebp]
  00164	de c1		 faddp	 ST(1), ST(0)
  00166	d9 55 e0	 fst	 DWORD PTR _fEnv$[ebp]

; 159  :       pfLogAmps[n] = VoxINTERP( fEnv_1, fEnv, fInterpFactor);

  00169	d8 65 ec	 fsub	 DWORD PTR _fEnv_1$[ebp]
  0016c	d8 4d 30	 fmul	 DWORD PTR _fInterpFactor$[ebp]
  0016f	d8 45 ec	 fadd	 DWORD PTR _fEnv_1$[ebp]
  00172	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00175	8b 4d 10	 mov	 ecx, DWORD PTR _pfLogAmps$[ebp]
  00178	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]

; 160  : 
; 161  :       /*------------------------------------------------------------------
; 162  :         Interpolate unwrapped phase envelopes, first in frequency, 
; 163  :           then in time.
; 164  :       ------------------------------------------------------------------*/
; 165  :       fPhase_1 = VoxINTERP(pfPhase_1[iIndex], pfPhase_1[iIndex+1], fFreqInterp);

  0017b	8b 55 e8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0017e	8b 45 2c	 mov	 eax, DWORD PTR _pfPhase_1$[ebp]
  00181	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  00184	8b 4d e8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00187	8b 55 2c	 mov	 edx, DWORD PTR _pfPhase_1$[ebp]
  0018a	d9 44 8a 04	 fld	 DWORD PTR [edx+ecx*4+4]
  0018e	8b 45 e8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00191	8b 4d 2c	 mov	 ecx, DWORD PTR _pfPhase_1$[ebp]
  00194	d8 24 81	 fsub	 DWORD PTR [ecx+eax*4]
  00197	d8 4d e4	 fmul	 DWORD PTR _fFreqInterp$[ebp]
  0019a	de c1		 faddp	 ST(1), ST(0)
  0019c	d9 5d fc	 fstp	 DWORD PTR _fPhase_1$[ebp]

; 166  :       fPhase = VoxINTERP(pfPhase[iIndex], pfPhase[iIndex+1], fFreqInterp);

  0019f	8b 55 e8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  001a2	8b 45 28	 mov	 eax, DWORD PTR _pfPhase$[ebp]
  001a5	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  001a8	8b 4d e8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  001ab	8b 55 28	 mov	 edx, DWORD PTR _pfPhase$[ebp]
  001ae	d9 44 8a 04	 fld	 DWORD PTR [edx+ecx*4+4]
  001b2	8b 45 e8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  001b5	8b 4d 28	 mov	 ecx, DWORD PTR _pfPhase$[ebp]
  001b8	d8 24 81	 fsub	 DWORD PTR [ecx+eax*4]
  001bb	d8 4d e4	 fmul	 DWORD PTR _fFreqInterp$[ebp]
  001be	de c1		 faddp	 ST(1), ST(0)
  001c0	d9 55 f0	 fst	 DWORD PTR _fPhase$[ebp]

; 167  :       pfMinFaz[n] = VoxINTERP( fPhase_1, fPhase, fInterpFactor );

  001c3	d8 65 fc	 fsub	 DWORD PTR _fPhase_1$[ebp]
  001c6	d8 4d 30	 fmul	 DWORD PTR _fInterpFactor$[ebp]
  001c9	d8 45 fc	 fadd	 DWORD PTR _fPhase_1$[ebp]
  001cc	8b 55 f4	 mov	 edx, DWORD PTR _n$[ebp]
  001cf	8b 45 14	 mov	 eax, DWORD PTR _pfMinFaz$[ebp]
  001d2	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]

; 168  :    }

  001d5	e9 bf fe ff ff	 jmp	 $L1035
$L1036:

; 169  : 
; 170  :    /*------------------------------------------------------------------
; 171  :      Rescale the unvoiced harmonics to account for the analysis window 
; 172  :        energy and the synthesis pitch.
; 173  :    ------------------------------------------------------------------*/
; 174  :    for (n=iVoicHarm; n<iHarmonics; n++)

  001da	8b 4d 1c	 mov	 ecx, DWORD PTR _iVoicHarm$[ebp]
  001dd	89 4d f4	 mov	 DWORD PTR _n$[ebp], ecx
  001e0	eb 09		 jmp	 SHORT $L1044
$L1045:
  001e2	8b 55 f4	 mov	 edx, DWORD PTR _n$[ebp]
  001e5	83 c2 01	 add	 edx, 1
  001e8	89 55 f4	 mov	 DWORD PTR _n$[ebp], edx
$L1044:
  001eb	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  001ee	3b 45 18	 cmp	 eax, DWORD PTR _iHarmonics$[ebp]
  001f1	7d 17		 jge	 SHORT $L1011

; 175  :       pfLogAmps[n] += fNoiseScale;

  001f3	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  001f6	8b 55 10	 mov	 edx, DWORD PTR _pfLogAmps$[ebp]
  001f9	d9 45 08	 fld	 DWORD PTR _fNoiseScale$[ebp]
  001fc	d8 04 8a	 fadd	 DWORD PTR [edx+ecx*4]
  001ff	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00202	8b 4d 10	 mov	 ecx, DWORD PTR _pfLogAmps$[ebp]
  00205	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
  00208	eb d8		 jmp	 SHORT $L1045
$L1011:

; 176  : 
; 177  : }

  0020a	8b e5		 mov	 esp, ebp
  0020c	5d		 pop	 ebp
  0020d	c2 2c 00	 ret	 44			; 0000002cH
_SetAmpAndPhase@44 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@LMDCCNJF@pfLogAmps?$CB?$DNNULL?$AA@	; `string'
PUBLIC	??_C@_0BB@DABJIJMH@pfMinFaz?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	_AddSubHarmonics@24
;	COMDAT ??_C@_0BA@LMDCCNJF@pfLogAmps?$CB?$DNNULL?$AA@
CONST	SEGMENT
??_C@_0BA@LMDCCNJF@pfLogAmps?$CB?$DNNULL?$AA@ DB 'pfLogAmps!=NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DABJIJMH@pfMinFaz?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BB@DABJIJMH@pfMinFaz?5?$CB?$DN?5NULL?$AA@ DB 'pfMinFaz != NULL', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _AddSubHarmonics@24
_TEXT	SEGMENT
_j$ = -12
_k$ = -8
_i$ = -4
_pfLogAmps$ = 8
_pfMinFaz$ = 12
_iHarmonics$ = 16
_iSubHarmonics$ = 20
_iRatio$ = 24
_iVoicHarm$ = 28
_AddSubHarmonics@24 PROC NEAR				; COMDAT

; 219  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 220  :  
; 221  :    int   i, j, k;
; 222  : 
; 223  :    assert(pfLogAmps!=NULL);

  00007	83 7d 08 00	 cmp	 DWORD PTR _pfLogAmps$[ebp], 0
  0000b	75 17		 jne	 SHORT $L1114
  0000d	68 df 00 00 00	 push	 223			; 000000dfH
  00012	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@NMKPHOEC@c?3?2xbox?2private?2windows?2directx?2@
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@LMDCCNJF@pfLogAmps?$CB?$DNNULL?$AA@
  0001c	e8 00 00 00 00	 call	 __assert
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1114:

; 224  :    assert(pfMinFaz != NULL);

  00024	83 7d 0c 00	 cmp	 DWORD PTR _pfMinFaz$[ebp], 0
  00028	75 17		 jne	 SHORT $L1115
  0002a	68 e0 00 00 00	 push	 224			; 000000e0H
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@NMKPHOEC@c?3?2xbox?2private?2windows?2directx?2@
  00034	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@DABJIJMH@pfMinFaz?5?$CB?$DN?5NULL?$AA@
  00039	e8 00 00 00 00	 call	 __assert
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1115:

; 225  : 
; 226  :    k = iSubHarmonics-1;

  00041	8b 55 14	 mov	 edx, DWORD PTR _iSubHarmonics$[ebp]
  00044	83 ea 01	 sub	 edx, 1
  00047	89 55 f8	 mov	 DWORD PTR _k$[ebp], edx

; 227  :    /* unvoiced band */
; 228  :    for (i = iHarmonics-1; i>=iVoicHarm; i--)

  0004a	8b 45 10	 mov	 eax, DWORD PTR _iHarmonics$[ebp]
  0004d	83 e8 01	 sub	 eax, 1
  00050	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00053	eb 09		 jmp	 SHORT $L1069
$L1070:
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00058	83 e9 01	 sub	 ecx, 1
  0005b	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L1069:
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00061	3b 55 1c	 cmp	 edx, DWORD PTR _iVoicHarm$[ebp]
  00064	7c 4b		 jl	 SHORT $L1071

; 229  :      {
; 230  :        for (j = 0; j < iRatio; j++, k--)

  00066	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0006d	eb 12		 jmp	 SHORT $L1072
$L1073:
  0006f	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00072	83 c0 01	 add	 eax, 1
  00075	89 45 f4	 mov	 DWORD PTR _j$[ebp], eax
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  0007b	83 e9 01	 sub	 ecx, 1
  0007e	89 4d f8	 mov	 DWORD PTR _k$[ebp], ecx
$L1072:
  00081	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  00084	3b 55 18	 cmp	 edx, DWORD PTR _iRatio$[ebp]
  00087	7d 26		 jge	 SHORT $L1074

; 231  :          {
; 232  :            pfLogAmps[k] = pfLogAmps[i];

  00089	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _pfLogAmps$[ebp]
  0008f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00092	8b 75 08	 mov	 esi, DWORD PTR _pfLogAmps$[ebp]
  00095	8b 14 96	 mov	 edx, DWORD PTR [esi+edx*4]
  00098	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 233  :            pfMinFaz[k] = pfMinFaz[i];

  0009b	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  0009e	8b 4d 0c	 mov	 ecx, DWORD PTR _pfMinFaz$[ebp]
  000a1	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000a4	8b 75 0c	 mov	 esi, DWORD PTR _pfMinFaz$[ebp]
  000a7	8b 14 96	 mov	 edx, DWORD PTR [esi+edx*4]
  000aa	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 234  :          }

  000ad	eb c0		 jmp	 SHORT $L1073
$L1074:

; 235  :      }

  000af	eb a4		 jmp	 SHORT $L1070
$L1071:

; 236  :    
; 237  :    /* voiced band */
; 238  :    for (; i >= 0; i--)

  000b1	eb 09		 jmp	 SHORT $L1075
$L1076:
  000b3	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000b6	83 e8 01	 sub	 eax, 1
  000b9	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L1075:
  000bc	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  000c0	7c 6e		 jl	 SHORT $L1059

; 239  :      {
; 240  :        pfLogAmps[k] = pfLogAmps[i];

  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  000c5	8b 55 08	 mov	 edx, DWORD PTR _pfLogAmps$[ebp]
  000c8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000cb	8b 75 08	 mov	 esi, DWORD PTR _pfLogAmps$[ebp]
  000ce	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  000d1	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 241  :        pfMinFaz[k] = pfMinFaz[i];

  000d4	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  000d7	8b 55 0c	 mov	 edx, DWORD PTR _pfMinFaz$[ebp]
  000da	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000dd	8b 75 0c	 mov	 esi, DWORD PTR _pfMinFaz$[ebp]
  000e0	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  000e3	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 242  :        k--;

  000e6	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  000e9	83 e9 01	 sub	 ecx, 1
  000ec	89 4d f8	 mov	 DWORD PTR _k$[ebp], ecx

; 243  :        for (j = 1; j < iRatio; j++, k--) 

  000ef	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _j$[ebp], 1
  000f6	eb 12		 jmp	 SHORT $L1078
$L1079:
  000f8	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  000fb	83 c2 01	 add	 edx, 1
  000fe	89 55 f4	 mov	 DWORD PTR _j$[ebp], edx
  00101	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  00104	83 e8 01	 sub	 eax, 1
  00107	89 45 f8	 mov	 DWORD PTR _k$[ebp], eax
$L1078:
  0010a	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  0010d	3b 4d 18	 cmp	 ecx, DWORD PTR _iRatio$[ebp]
  00110	7d 1c		 jge	 SHORT $L1080

; 244  :          {
; 245  :            pfLogAmps[k] = 0.0F;

  00112	8b 55 f8	 mov	 edx, DWORD PTR _k$[ebp]
  00115	8b 45 08	 mov	 eax, DWORD PTR _pfLogAmps$[ebp]
  00118	c7 04 90 00 00
	00 00		 mov	 DWORD PTR [eax+edx*4], 0

; 246  :            pfMinFaz[k] = 0.0F;

  0011f	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  00122	8b 55 0c	 mov	 edx, DWORD PTR _pfMinFaz$[ebp]
  00125	c7 04 8a 00 00
	00 00		 mov	 DWORD PTR [edx+ecx*4], 0

; 247  :          }

  0012c	eb ca		 jmp	 SHORT $L1079
$L1080:

; 248  :      }

  0012e	eb 83		 jmp	 SHORT $L1076
$L1059:

; 249  : }

  00130	5e		 pop	 esi
  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c2 18 00	 ret	 24			; 00000018H
_AddSubHarmonics@24 ENDP
_TEXT	ENDS
END
