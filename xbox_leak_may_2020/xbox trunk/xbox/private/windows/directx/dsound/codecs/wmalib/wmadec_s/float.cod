; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\float.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EG@HMBCDHFH@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _quickRand@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @ByteSwap@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _prvAdaptTrigToSubframeConfig_XDS@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _prvInverseQuantizeLowRate_XDS@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_DSoundBuildNumberD
CONST	SEGMENT
_WMA_OK	DD	00H
_WMA_S_FALSE DD	01H
_WMA_S_BUFUNDERFLOW DD 02H
_WMA_S_NEWPACKET DD 03H
_WMA_S_NO_MORE_FRAME DD 04H
_WMA_S_DEFAULT DD 05H
_WMA_S_SWITCHCHMODE DD 06H
_WMA_E_FAIL DD	080004005H
_WMA_E_OUTOFMEMORY DD 08007000eH
_WMA_E_INVALIDARG DD 080070057H
_WMA_E_NOTSUPPORTED DD 080040000H
_WMA_E_LOSTPACKET DD 080040001H
_WMA_E_BROKEN_FRAME DD 080040002H
_WMA_E_BUFFEROVERFLOW DD 080040003H
_WMA_E_ONHOLD DD 080040004H
_WMA_E_BUFFERUNDERFLOW DD 080040005H
_WMA_E_INVALIDRECHDR DD 080040006H
_WMA_E_SYNCERROR DD 080040007H
_WMA_E_NOTIMPL DD 080040008H
_WMA_E_FLUSHOVERFLOW DD 080040009H
CONST	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT
_DSoundBuildNumberD DW 05344H
	DW	0554fH
	DW	0444eH
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_prvAdaptTrigToSubframeConfig_XDS@4
PUBLIC	??_C@_0EG@HMBCDHFH@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@ ; `string'
PUBLIC	__real@40000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@4000000000000000
EXTRN	__fltused:NEAR
EXTRN	_cos:NEAR
EXTRN	_sin:NEAR
EXTRN	_MyOutputDbgStr:NEAR
EXTRN	_rgSinCosTables:BYTE
;	COMDAT ??_C@_0EG@HMBCDHFH@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\float.c
CONST	SEGMENT
??_C@_0EG@HMBCDHFH@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\wmalib\wmadec_s\float.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
CONST	SEGMENT
??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@ DB '%'
	DB	's(%d) : *** TRACE *** code = 0x%x!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _prvAdaptTrigToSubframeConfig_XDS@4
_TEXT	SEGMENT
tv403 = -52
tv401 = -48
tv212 = -44
tv185 = -40
tv329 = -36
tv327 = -32
tv90 = -28
tv69 = -24
_iSize2Use$ = -20
_dA$ = -16
_pSinCosTable$ = -8
_wmaResult$ = -4
_pau$ = 8
_prvAdaptTrigToSubframeConfig_XDS@4 PROC NEAR		; COMDAT

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 44   :     WMARESULT wmaResult = WMA_OK;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000b	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 45   :     Int iSize2Use;
; 46   : 	Double dA;
; 47   : #   if !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)
; 48   :     const SinCosTable*  pSinCosTable;
; 49   : #endif
; 50   : 
; 51   :     //if the adjacent size is bigger; just keep your own shape
; 52   :     //otherwise a transition window is needed.
; 53   :     if (pau->m_iSizePrev >= pau->m_iSizeCurr) {

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00011	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00014	8b 81 80 03 00
	00		 mov	 eax, DWORD PTR [ecx+896]
  0001a	3b 82 84 03 00
	00		 cmp	 eax, DWORD PTR [edx+900]
  00020	7c 0e		 jl	 SHORT $L2460

; 54   :         //just forward copy curr
; 55   : 		iSize2Use = pau->m_iSizeCurr;

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00025	8b 91 84 03 00
	00		 mov	 edx, DWORD PTR [ecx+900]
  0002b	89 55 ec	 mov	 DWORD PTR _iSize2Use$[ebp], edx

; 56   :     }
; 57   :     else  {

  0002e	eb 0c		 jmp	 SHORT $L2461
$L2460:

; 58   :         //long start
; 59   : 		iSize2Use = pau->m_iSizePrev;

  00030	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00033	8b 88 80 03 00
	00		 mov	 ecx, DWORD PTR [eax+896]
  00039	89 4d ec	 mov	 DWORD PTR _iSize2Use$[ebp], ecx
$L2461:

; 60   :     }
; 61   : 
; 62   : #ifdef USE_SIN_COS_TABLES
; 63   :     switch (iSize2Use){

  0003c	8b 55 ec	 mov	 edx, DWORD PTR _iSize2Use$[ebp]
  0003f	89 55 e8	 mov	 DWORD PTR tv69[ebp], edx
  00042	81 7d e8 00 02
	00 00		 cmp	 DWORD PTR tv69[ebp], 512 ; 00000200H
  00049	7f 2a		 jg	 SHORT $L2587
  0004b	81 7d e8 00 02
	00 00		 cmp	 DWORD PTR tv69[ebp], 512 ; 00000200H
  00052	74 66		 je	 SHORT $L2468
  00054	83 7d e8 40	 cmp	 DWORD PTR tv69[ebp], 64	; 00000040H
  00058	0f 84 9b 00 00
	00		 je	 $L2471
  0005e	81 7d e8 80 00
	00 00		 cmp	 DWORD PTR tv69[ebp], 128 ; 00000080H
  00065	74 7e		 je	 SHORT $L2470
  00067	81 7d e8 00 01
	00 00		 cmp	 DWORD PTR tv69[ebp], 256 ; 00000100H
  0006e	74 61		 je	 SHORT $L2469
  00070	e9 98 00 00 00	 jmp	 $L2472
$L2587:
  00075	81 7d e8 00 04
	00 00		 cmp	 DWORD PTR tv69[ebp], 1024 ; 00000400H
  0007c	74 25		 je	 SHORT $L2467
  0007e	81 7d e8 00 08
	00 00		 cmp	 DWORD PTR tv69[ebp], 2048 ; 00000800H
  00085	74 05		 je	 SHORT $L2466
  00087	e9 81 00 00 00	 jmp	 $L2472
$L2466:

; 64   :         case 2048:
; 65   :             pau->m_piSinForRecon = pau->m_piSinForRecon2048;

  0008c	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00092	8b 91 10 04 00
	00		 mov	 edx, DWORD PTR [ecx+1040]
  00098	89 90 28 04 00
	00		 mov	 DWORD PTR [eax+1064], edx

; 66   :             break;

  0009e	e9 bc 00 00 00	 jmp	 $L2463
$L2467:

; 67   :         case 1024:
; 68   :             pau->m_piSinForRecon = pau->m_piSinForRecon1024;

  000a3	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000a9	8b 91 14 04 00
	00		 mov	 edx, DWORD PTR [ecx+1044]
  000af	89 90 28 04 00
	00		 mov	 DWORD PTR [eax+1064], edx

; 69   :             break;

  000b5	e9 a5 00 00 00	 jmp	 $L2463
$L2468:

; 70   :         case 512 :
; 71   :             pau->m_piSinForRecon = pau->m_piSinForRecon512;

  000ba	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000c0	8b 91 18 04 00
	00		 mov	 edx, DWORD PTR [ecx+1048]
  000c6	89 90 28 04 00
	00		 mov	 DWORD PTR [eax+1064], edx

; 72   :             break;

  000cc	e9 8e 00 00 00	 jmp	 $L2463
$L2469:

; 73   :         case 256 :
; 74   :             pau->m_piSinForRecon = pau->m_piSinForRecon256;

  000d1	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000d4	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000d7	8b 91 1c 04 00
	00		 mov	 edx, DWORD PTR [ecx+1052]
  000dd	89 90 28 04 00
	00		 mov	 DWORD PTR [eax+1064], edx

; 75   :             break;

  000e3	eb 7a		 jmp	 SHORT $L2463
$L2470:

; 76   :         case 128 :
; 77   :             pau->m_piSinForRecon = pau->m_piSinForRecon128;

  000e5	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000e8	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000eb	8b 91 20 04 00
	00		 mov	 edx, DWORD PTR [ecx+1056]
  000f1	89 90 28 04 00
	00		 mov	 DWORD PTR [eax+1064], edx

; 78   :             break;

  000f7	eb 66		 jmp	 SHORT $L2463
$L2471:

; 79   :         case 64  :
; 80   :             pau->m_piSinForRecon = pau->m_piSinForRecon64;

  000f9	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000ff	8b 91 24 04 00
	00		 mov	 edx, DWORD PTR [ecx+1060]
  00105	89 90 28 04 00
	00		 mov	 DWORD PTR [eax+1064], edx

; 81   :             break;

  0010b	eb 52		 jmp	 SHORT $L2463
$L2472:

; 82   :         default: 
; 83   :             assert(0);
; 84   :             return (TraceResult (WMA_E_BROKEN_FRAME));

  0010d	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  00112	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00118	74 34		 je	 SHORT $L2585
  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  00120	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  00126	74 26		 je	 SHORT $L2585
  00128	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  0012e	52		 push	 edx
  0012f	6a 54		 push	 84			; 00000054H
  00131	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EG@HMBCDHFH@c?3?2xbox?2private?2windows?2directx?2@
  00136	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0013b	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00146	83 c4 14	 add	 esp, 20			; 00000014H
  00149	89 45 e4	 mov	 DWORD PTR tv90[ebp], eax
  0014c	eb 09		 jmp	 SHORT $L2586
$L2585:
  0014e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  00154	89 4d e4	 mov	 DWORD PTR tv90[ebp], ecx
$L2586:
  00157	8b 45 e4	 mov	 eax, DWORD PTR tv90[ebp]
  0015a	e9 dc 03 00 00	 jmp	 $L2455
$L2463:

; 85   :     }
; 86   : #endif  //maby else out next section
; 87   : 
; 88   : 
; 89   : #   if !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)
; 90   :         // Use lookup-tables if we can 
; 91   :         // Saves 1% of play time of SH4 and a tiny bit on an 233MHz Pentium II
; 92   :         if (iSize2Use >= 64 && iSize2Use <= 2048)

  0015f	83 7d ec 40	 cmp	 DWORD PTR _iSize2Use$[ebp], 64 ; 00000040H
  00163	0f 8c 84 00 00
	00		 jl	 $L2475
  00169	81 7d ec 00 08
	00 00		 cmp	 DWORD PTR _iSize2Use$[ebp], 2048 ; 00000800H
  00170	7f 7b		 jg	 SHORT $L2475

; 93   :         {
; 94   :             pSinCosTable = rgSinCosTables[iSize2Use>>7];

  00172	8b 55 ec	 mov	 edx, DWORD PTR _iSize2Use$[ebp]
  00175	c1 fa 07	 sar	 edx, 7
  00178	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _rgSinCosTables[edx*4]
  0017f	89 45 f8	 mov	 DWORD PTR _pSinCosTable$[ebp], eax

; 95   :             // START: see below for detailed explaination
; 96   :             pau->m_fltSinRampUpStart =   pSinCosTable->sin_PIby4cSB;    //(Int) (sin (0.5 * PI / iSizeCurr / 2) * 0x3FFFFFFF);

  00182	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00185	8b 55 f8	 mov	 edx, DWORD PTR _pSinCosTable$[ebp]
  00188	8b 02		 mov	 eax, DWORD PTR [edx]
  0018a	89 81 58 03 00
	00		 mov	 DWORD PTR [ecx+856], eax

; 97   :             pau->m_fltCosRampUpStart =   pSinCosTable->cos_PIby4cSB;    //(Int) (cos (0.5 * PI / iSizeCurr / 2) * 0x3FFFFFFF);

  00190	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00193	8b 55 f8	 mov	 edx, DWORD PTR _pSinCosTable$[ebp]
  00196	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00199	89 81 5c 03 00
	00		 mov	 DWORD PTR [ecx+860], eax

; 98   :             // PRIOR: see below for detailed explaination
; 99   :             pau->m_fltSinRampUpPrior =  -pSinCosTable->sin_PIby4cSB;

  0019f	8b 4d f8	 mov	 ecx, DWORD PTR _pSinCosTable$[ebp]
  001a2	d9 01		 fld	 DWORD PTR [ecx]
  001a4	d9 e0		 fchs
  001a6	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  001a9	d9 9a 60 03 00
	00		 fstp	 DWORD PTR [edx+864]

; 100  :             pau->m_fltCosRampUpPrior =   pSinCosTable->cos_PIby4cSB;

  001af	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001b2	8b 4d f8	 mov	 ecx, DWORD PTR _pSinCosTable$[ebp]
  001b5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001b8	89 90 64 03 00
	00		 mov	 DWORD PTR [eax+868], edx

; 101  :             pau->m_fltSinRampUpStep  = 2*pSinCosTable->sin_PIby2cSB;   // STEP = 2 * sin (PI / 2 / iSizeCurr) * 0x3FFFFFFF;

  001be	8b 45 f8	 mov	 eax, DWORD PTR _pSinCosTable$[ebp]
  001c1	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40000000
  001c7	d8 48 20	 fmul	 DWORD PTR [eax+32]
  001ca	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  001cd	d9 99 68 03 00
	00		 fstp	 DWORD PTR [ecx+872]

; 102  : #           ifdef _DEBUG
; 103  :             {   // Include the next code-block to verify changes to the lookup-table
; 104  :                 dA = PI / (4*iSize2Use);

  001d3	8b 55 ec	 mov	 edx, DWORD PTR _iSize2Use$[ebp]
  001d6	c1 e2 02	 shl	 edx, 2
  001d9	89 55 e0	 mov	 DWORD PTR tv327[ebp], edx
  001dc	db 45 e0	 fild	 DWORD PTR tv327[ebp]
  001df	dc 3d 00 00 00
	00		 fdivr	 QWORD PTR __real@400921fb54442d18
  001e5	dd 5d f0	 fstp	 QWORD PTR _dA$[ebp]

; 105  :                 assert(fabs(pau->m_fltSinRampUpStart - sin ( dA ) ) <= 0.0001);
; 106  :                 assert(fabs(pau->m_fltCosRampUpStart - cos ( dA ) ) <= 0.0001);
; 107  :                 assert(fabs(pau->m_fltSinRampUpPrior - sin( -dA ) ) <= 0.0001);
; 108  :                 assert(fabs(pau->m_fltCosRampUpPrior - cos( -dA ) ) <= 0.0001);
; 109  :                 assert(fabs(pau->m_fltSinRampUpStep  -  2 * sin( 2*dA ) ) <= 0.0001); 
; 110  :             }
; 111  : #           endif // _DEBUG
; 112  :         }
; 113  :         else

  001e8	e9 a1 00 00 00	 jmp	 $L2476
$L2475:

; 114  : #   endif // !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)    
; 115  :         {
; 116  :             // START:  sin ((0.5 + iSize2Use) * PI / (2*iSize2Use) )
; 117  : 	        //		 = sin ( PI/(4*iSize2Use) + PI/2 ) =  cos( PI/(4*iSize2Use) )
; 118  : 	        // AND:    cos ((0.5 + iSize2Use) * PI / (2*iSize2Use) )
; 119  : 	        //       = cos ( PI/(4*iSize2Use) + PI/2 ) = -sin( PI/(4*iSize2Use) )
; 120  : 	        dA = PI / (4*iSize2Use);

  001ed	8b 45 ec	 mov	 eax, DWORD PTR _iSize2Use$[ebp]
  001f0	c1 e0 02	 shl	 eax, 2
  001f3	89 45 dc	 mov	 DWORD PTR tv329[ebp], eax
  001f6	db 45 dc	 fild	 DWORD PTR tv329[ebp]
  001f9	dc 3d 00 00 00
	00		 fdivr	 QWORD PTR __real@400921fb54442d18
  001ff	dd 5d f0	 fstp	 QWORD PTR _dA$[ebp]

; 121  :             pau->m_fltSinRampUpStart =  (V4V5COMPARE)(sin ( dA ));

  00202	8b 4d f4	 mov	 ecx, DWORD PTR _dA$[ebp+4]
  00205	51		 push	 ecx
  00206	8b 55 f0	 mov	 edx, DWORD PTR _dA$[ebp]
  00209	52		 push	 edx
  0020a	e8 00 00 00 00	 call	 _sin
  0020f	83 c4 08	 add	 esp, 8
  00212	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00215	d9 98 58 03 00
	00		 fstp	 DWORD PTR [eax+856]

; 122  :             pau->m_fltCosRampUpStart =  (V4V5COMPARE)(cos ( dA ));

  0021b	8b 4d f4	 mov	 ecx, DWORD PTR _dA$[ebp+4]
  0021e	51		 push	 ecx
  0021f	8b 55 f0	 mov	 edx, DWORD PTR _dA$[ebp]
  00222	52		 push	 edx
  00223	e8 00 00 00 00	 call	 _cos
  00228	83 c4 08	 add	 esp, 8
  0022b	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0022e	d9 98 5c 03 00
	00		 fstp	 DWORD PTR [eax+860]

; 123  : 	        // PRIOR:  sin ((0.5 + iSize2Use) * PI / (2*iSize2Use) -PI/(2*iSize2Use) )
; 124  : 	        //       = sin ( PI/(4*iSize2Use) + PI/2 - PI/(2*iSize2Use) ) 
; 125  :             //       = cos( -PI/(4*iSize2Use) ) = cos( PI/(4*iSize2Use) )
; 126  : 	        // AND:    cos ((0.5 + iSize2Use) * PI / (2*iSize2Use) -PI/(2*iSize2Use) )
; 127  : 	        //       = cos ( PI/(4*iSize2Use) + PI/2 - PI/(2*iSize2Use) ) 
; 128  :             //       = -sin( -PI/(4*iSize2Use) ) = sin( PI/(4*iSize2Use) )
; 129  : 	        pau->m_fltSinRampUpPrior =  (V4V5COMPARE)(sin( -dA ));

  00234	dd 45 f0	 fld	 QWORD PTR _dA$[ebp]
  00237	d9 e0		 fchs
  00239	83 ec 08	 sub	 esp, 8
  0023c	dd 1c 24	 fstp	 QWORD PTR [esp]
  0023f	e8 00 00 00 00	 call	 _sin
  00244	83 c4 08	 add	 esp, 8
  00247	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0024a	d9 99 60 03 00
	00		 fstp	 DWORD PTR [ecx+864]

; 130  : 	        pau->m_fltCosRampUpPrior =  (V4V5COMPARE)(cos( -dA ));

  00250	dd 45 f0	 fld	 QWORD PTR _dA$[ebp]
  00253	d9 e0		 fchs
  00255	83 ec 08	 sub	 esp, 8
  00258	dd 1c 24	 fstp	 QWORD PTR [esp]
  0025b	e8 00 00 00 00	 call	 _cos
  00260	83 c4 08	 add	 esp, 8
  00263	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00266	d9 9a 64 03 00
	00		 fstp	 DWORD PTR [edx+868]

; 131  : 
; 132  :             // Rotate by PI/(2*iSize2Use)
; 133  : 	        pau->m_fltSinRampUpStep  =  (V4V5COMPARE)( 2 * sin( 2*dA ) );

  0026c	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4000000000000000
  00272	dc 4d f0	 fmul	 QWORD PTR _dA$[ebp]
  00275	83 ec 08	 sub	 esp, 8
  00278	dd 1c 24	 fstp	 QWORD PTR [esp]
  0027b	e8 00 00 00 00	 call	 _sin
  00280	83 c4 08	 add	 esp, 8
  00283	dc c0		 fadd	 ST(0), ST(0)
  00285	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00288	d9 98 68 03 00
	00		 fstp	 DWORD PTR [eax+872]
$L2476:

; 134  :         }
; 135  : 
; 136  : 
; 137  :     if (pau->m_iSizeNext >= pau->m_iSizeCurr) {

  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00291	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00294	8b 81 88 03 00
	00		 mov	 eax, DWORD PTR [ecx+904]
  0029a	3b 82 84 03 00
	00		 cmp	 eax, DWORD PTR [edx+900]
  002a0	7c 0e		 jl	 SHORT $L2482

; 138  : 		iSize2Use = pau->m_iSizeCurr;

  002a2	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002a5	8b 91 84 03 00
	00		 mov	 edx, DWORD PTR [ecx+900]
  002ab	89 55 ec	 mov	 DWORD PTR _iSize2Use$[ebp], edx

; 139  :     }
; 140  :     else    {

  002ae	eb 0c		 jmp	 SHORT $L2483
$L2482:

; 141  :         //just backward copy curr
; 142  : 		iSize2Use = pau->m_iSizeNext;

  002b0	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002b3	8b 88 88 03 00
	00		 mov	 ecx, DWORD PTR [eax+904]
  002b9	89 4d ec	 mov	 DWORD PTR _iSize2Use$[ebp], ecx
$L2483:

; 143  :     }
; 144  : 
; 145  : #ifdef USE_SIN_COS_TABLES
; 146  :     switch (iSize2Use){

  002bc	8b 55 ec	 mov	 edx, DWORD PTR _iSize2Use$[ebp]
  002bf	89 55 d8	 mov	 DWORD PTR tv185[ebp], edx
  002c2	81 7d d8 00 02
	00 00		 cmp	 DWORD PTR tv185[ebp], 512 ; 00000200H
  002c9	7f 2e		 jg	 SHORT $L2590
  002cb	81 7d d8 00 02
	00 00		 cmp	 DWORD PTR tv185[ebp], 512 ; 00000200H
  002d2	74 76		 je	 SHORT $L2490
  002d4	83 7d d8 40	 cmp	 DWORD PTR tv185[ebp], 64 ; 00000040H
  002d8	0f 84 c0 00 00
	00		 je	 $L2493
  002de	81 7d d8 80 00
	00 00		 cmp	 DWORD PTR tv185[ebp], 128 ; 00000080H
  002e5	0f 84 99 00 00
	00		 je	 $L2492
  002eb	81 7d d8 00 01
	00 00		 cmp	 DWORD PTR tv185[ebp], 256 ; 00000100H
  002f2	74 73		 je	 SHORT $L2491
  002f4	e9 bf 00 00 00	 jmp	 $L2494
$L2590:
  002f9	81 7d d8 00 04
	00 00		 cmp	 DWORD PTR tv185[ebp], 1024 ; 00000400H
  00300	74 2b		 je	 SHORT $L2489
  00302	81 7d d8 00 08
	00 00		 cmp	 DWORD PTR tv185[ebp], 2048 ; 00000800H
  00309	74 05		 je	 SHORT $L2488
  0030b	e9 a8 00 00 00	 jmp	 $L2494
$L2488:

; 147  :         case 2048:
; 148  :             pau->m_piSinForSaveHistory = pau->m_piSinForRecon2048+2048;

  00310	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00313	8b 88 10 04 00
	00		 mov	 ecx, DWORD PTR [eax+1040]
  00319	81 c1 00 20 00
	00		 add	 ecx, 8192		; 00002000H
  0031f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00322	89 8a 2c 04 00
	00		 mov	 DWORD PTR [edx+1068], ecx

; 149  :             break;

  00328	e9 e0 00 00 00	 jmp	 $L2485
$L2489:

; 150  :         case 1024:
; 151  :             pau->m_piSinForSaveHistory = pau->m_piSinForRecon1024+1024;

  0032d	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00330	8b 88 14 04 00
	00		 mov	 ecx, DWORD PTR [eax+1044]
  00336	81 c1 00 10 00
	00		 add	 ecx, 4096		; 00001000H
  0033c	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0033f	89 8a 2c 04 00
	00		 mov	 DWORD PTR [edx+1068], ecx

; 152  :             break;

  00345	e9 c3 00 00 00	 jmp	 $L2485
$L2490:

; 153  :         case 512 :
; 154  :             pau->m_piSinForSaveHistory = pau->m_piSinForRecon512+512;

  0034a	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0034d	8b 88 18 04 00
	00		 mov	 ecx, DWORD PTR [eax+1048]
  00353	81 c1 00 08 00
	00		 add	 ecx, 2048		; 00000800H
  00359	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0035c	89 8a 2c 04 00
	00		 mov	 DWORD PTR [edx+1068], ecx

; 155  :             break;

  00362	e9 a6 00 00 00	 jmp	 $L2485
$L2491:

; 156  :         case 256 :
; 157  :             pau->m_piSinForSaveHistory = pau->m_piSinForRecon256+256;

  00367	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0036a	8b 88 1c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1052]
  00370	81 c1 00 04 00
	00		 add	 ecx, 1024		; 00000400H
  00376	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00379	89 8a 2c 04 00
	00		 mov	 DWORD PTR [edx+1068], ecx

; 158  :             break;

  0037f	e9 89 00 00 00	 jmp	 $L2485
$L2492:

; 159  :         case 128 :
; 160  :             pau->m_piSinForSaveHistory = pau->m_piSinForRecon128+128;

  00384	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00387	8b 88 20 04 00
	00		 mov	 ecx, DWORD PTR [eax+1056]
  0038d	81 c1 00 02 00
	00		 add	 ecx, 512		; 00000200H
  00393	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00396	89 8a 2c 04 00
	00		 mov	 DWORD PTR [edx+1068], ecx

; 161  :             break;

  0039c	eb 6f		 jmp	 SHORT $L2485
$L2493:

; 162  :         case 64  :
; 163  :             pau->m_piSinForSaveHistory = pau->m_piSinForRecon64+64;

  0039e	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  003a1	8b 88 24 04 00
	00		 mov	 ecx, DWORD PTR [eax+1060]
  003a7	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  003ad	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003b0	89 8a 2c 04 00
	00		 mov	 DWORD PTR [edx+1068], ecx

; 164  :             break;

  003b6	eb 55		 jmp	 SHORT $L2485
$L2494:

; 165  :         default: 
; 166  :             assert (0);
; 167  :             return (TraceResult (WMA_E_BROKEN_FRAME));

  003b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  003bd	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  003c3	74 37		 je	 SHORT $L2588
  003c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  003cb	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  003d1	74 29		 je	 SHORT $L2588
  003d3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  003d9	52		 push	 edx
  003da	68 a7 00 00 00	 push	 167			; 000000a7H
  003df	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EG@HMBCDHFH@c?3?2xbox?2private?2windows?2directx?2@
  003e4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  003e9	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  003ee	50		 push	 eax
  003ef	e8 00 00 00 00	 call	 _MyOutputDbgStr
  003f4	83 c4 14	 add	 esp, 20			; 00000014H
  003f7	89 45 d4	 mov	 DWORD PTR tv212[ebp], eax
  003fa	eb 09		 jmp	 SHORT $L2589
$L2588:
  003fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  00402	89 4d d4	 mov	 DWORD PTR tv212[ebp], ecx
$L2589:
  00405	8b 45 d4	 mov	 eax, DWORD PTR tv212[ebp]
  00408	e9 2e 01 00 00	 jmp	 $L2455
$L2485:

; 168  :     }
; 169  : #endif //USE_SIN_COS_TABLES
; 170  : 
; 171  : #   if !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)
; 172  :         // Use lookup-tables if we can
; 173  :         if (iSize2Use >= 64 && iSize2Use <= 2048)

  0040d	83 7d ec 40	 cmp	 DWORD PTR _iSize2Use$[ebp], 64 ; 00000040H
  00411	0f 8c 84 00 00
	00		 jl	 $L2495
  00417	81 7d ec 00 08
	00 00		 cmp	 DWORD PTR _iSize2Use$[ebp], 2048 ; 00000800H
  0041e	7f 7b		 jg	 SHORT $L2495

; 174  :         {
; 175  :             pSinCosTable = rgSinCosTables[iSize2Use>>7];

  00420	8b 55 ec	 mov	 edx, DWORD PTR _iSize2Use$[ebp]
  00423	c1 fa 07	 sar	 edx, 7
  00426	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _rgSinCosTables[edx*4]
  0042d	89 45 f8	 mov	 DWORD PTR _pSinCosTable$[ebp], eax

; 176  :             // START: see below for detailed explaination
; 177  :             pau->m_fltSinRampDownStart =   pSinCosTable->cos_PIby4cSB;  //(Int) sin ((0.5 + iSizeNext) * PI / iSizeNext / 2);

  00430	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00433	8b 55 f8	 mov	 edx, DWORD PTR _pSinCosTable$[ebp]
  00436	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00439	89 81 6c 03 00
	00		 mov	 DWORD PTR [ecx+876], eax

; 178  :             pau->m_fltCosRampDownStart =  -pSinCosTable->sin_PIby4cSB;  //(Int) cos ((0.5 + iSizeNext) * PI / iSizeNext / 2);

  0043f	8b 4d f8	 mov	 ecx, DWORD PTR _pSinCosTable$[ebp]
  00442	d9 01		 fld	 DWORD PTR [ecx]
  00444	d9 e0		 fchs
  00446	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00449	d9 9a 70 03 00
	00		 fstp	 DWORD PTR [edx+880]

; 179  :             // PRIOR: see below for detailed explaination
; 180  :             pau->m_fltSinRampDownPrior =   pSinCosTable->cos_PIby4cSB;

  0044f	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00452	8b 4d f8	 mov	 ecx, DWORD PTR _pSinCosTable$[ebp]
  00455	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00458	89 90 74 03 00
	00		 mov	 DWORD PTR [eax+884], edx

; 181  :             pau->m_fltCosRampDownPrior =   pSinCosTable->sin_PIby4cSB;

  0045e	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00461	8b 4d f8	 mov	 ecx, DWORD PTR _pSinCosTable$[ebp]
  00464	8b 11		 mov	 edx, DWORD PTR [ecx]
  00466	89 90 78 03 00
	00		 mov	 DWORD PTR [eax+888], edx

; 182  :             pau->m_fltSinRampDownStep  = 2*pSinCosTable->sin_PIby2cSB;     // STEP = 2 * sin (PI / 2 / iSizeCurr) * 0x3FFFFFFF;

  0046c	8b 45 f8	 mov	 eax, DWORD PTR _pSinCosTable$[ebp]
  0046f	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40000000
  00475	d8 48 20	 fmul	 DWORD PTR [eax+32]
  00478	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0047b	d9 99 7c 03 00
	00		 fstp	 DWORD PTR [ecx+892]

; 183  : #           ifdef _DEBUG
; 184  :             {   // Include this code-block to verify changes to the lookup-table
; 185  : 	            dA = PI/(4* iSize2Use);

  00481	8b 55 ec	 mov	 edx, DWORD PTR _iSize2Use$[ebp]
  00484	c1 e2 02	 shl	 edx, 2
  00487	89 55 d0	 mov	 DWORD PTR tv401[ebp], edx
  0048a	db 45 d0	 fild	 DWORD PTR tv401[ebp]
  0048d	dc 3d 00 00 00
	00		 fdivr	 QWORD PTR __real@400921fb54442d18
  00493	dd 5d f0	 fstp	 QWORD PTR _dA$[ebp]

; 186  :                 assert(fabs(pau->m_fltSinRampDownStart - cos( dA )) <= 0.0001);
; 187  :                 assert(fabs(pau->m_fltCosRampDownStart + sin( dA )) <= 0.0001);       // + == - -
; 188  :                 assert(fabs(pau->m_fltSinRampDownPrior - cos( dA )) <= 0.0001);
; 189  :                 assert(fabs(pau->m_fltCosRampDownPrior - sin( dA )) <= 0.0001);
; 190  :                 assert(fabs(pau->m_fltSinRampDownStep  - 2 * sin( 2*dA )) <= 0.0001);
; 191  :             }
; 192  : #           endif // _DEBUG
; 193  :         }
; 194  :         else

  00496	e9 9d 00 00 00	 jmp	 $L2496
$L2495:

; 195  : #   endif // !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)    
; 196  :         { 
; 197  :             // START:  sin ((0.5 + iSize2Use) * PI / (2*iSize2Use) )
; 198  : 	        //		 = sin ( PI/(4*iSize2Use) + PI/2 ) =  cos( PI/(4*iSize2Use) )
; 199  : 	        // AND:    cos ((0.5 + iSize2Use) * PI / (2*iSize2Use) )
; 200  : 	        //       = cos ( PI/(4*iSize2Use) + PI/2 ) = -sin( PI/(4*iSize2Use) )
; 201  : 	        dA = PI/(4* iSize2Use);

  0049b	8b 45 ec	 mov	 eax, DWORD PTR _iSize2Use$[ebp]
  0049e	c1 e0 02	 shl	 eax, 2
  004a1	89 45 cc	 mov	 DWORD PTR tv403[ebp], eax
  004a4	db 45 cc	 fild	 DWORD PTR tv403[ebp]
  004a7	dc 3d 00 00 00
	00		 fdivr	 QWORD PTR __real@400921fb54442d18
  004ad	dd 5d f0	 fstp	 QWORD PTR _dA$[ebp]

; 202  :             pau->m_fltSinRampDownStart = (V4V5COMPARE)(cos( dA ));

  004b0	8b 4d f4	 mov	 ecx, DWORD PTR _dA$[ebp+4]
  004b3	51		 push	 ecx
  004b4	8b 55 f0	 mov	 edx, DWORD PTR _dA$[ebp]
  004b7	52		 push	 edx
  004b8	e8 00 00 00 00	 call	 _cos
  004bd	83 c4 08	 add	 esp, 8
  004c0	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  004c3	d9 98 6c 03 00
	00		 fstp	 DWORD PTR [eax+876]

; 203  :             pau->m_fltCosRampDownStart = (V4V5COMPARE)(-sin( dA ));

  004c9	8b 4d f4	 mov	 ecx, DWORD PTR _dA$[ebp+4]
  004cc	51		 push	 ecx
  004cd	8b 55 f0	 mov	 edx, DWORD PTR _dA$[ebp]
  004d0	52		 push	 edx
  004d1	e8 00 00 00 00	 call	 _sin
  004d6	83 c4 08	 add	 esp, 8
  004d9	d9 e0		 fchs
  004db	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  004de	d9 98 70 03 00
	00		 fstp	 DWORD PTR [eax+880]

; 204  : 	        // PRIOR:  sin ((0.5 + iSize2Use) * PI / (2*iSize2Use) -PI/(2*iSize2Use) )
; 205  : 	        //       = sin ( PI/(4*iSize2Use) + PI/2 - PI/(2*iSize2Use) ) 
; 206  :             //       = cos( -PI/(4*iSize2Use) ) = cos( PI/(4*iSize2Use) )
; 207  : 	        // AND:    cos ((0.5 + iSize2Use) * PI / (2*iSize2Use) -PI/(2*iSize2Use) )
; 208  : 	        //       = cos ( PI/(4*iSize2Use) + PI/2 - PI/(2*iSize2Use) ) 
; 209  :             //       = -sin( -PI/(4*iSize2Use) ) = sin( PI/(4*iSize2Use) )
; 210  : 	        pau->m_fltSinRampDownPrior =  (V4V5COMPARE)(cos( dA ));

  004e4	8b 4d f4	 mov	 ecx, DWORD PTR _dA$[ebp+4]
  004e7	51		 push	 ecx
  004e8	8b 55 f0	 mov	 edx, DWORD PTR _dA$[ebp]
  004eb	52		 push	 edx
  004ec	e8 00 00 00 00	 call	 _cos
  004f1	83 c4 08	 add	 esp, 8
  004f4	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  004f7	d9 98 74 03 00
	00		 fstp	 DWORD PTR [eax+884]

; 211  : 	        pau->m_fltCosRampDownPrior =  (V4V5COMPARE)(sin( dA ));

  004fd	8b 4d f4	 mov	 ecx, DWORD PTR _dA$[ebp+4]
  00500	51		 push	 ecx
  00501	8b 55 f0	 mov	 edx, DWORD PTR _dA$[ebp]
  00504	52		 push	 edx
  00505	e8 00 00 00 00	 call	 _sin
  0050a	83 c4 08	 add	 esp, 8
  0050d	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00510	d9 98 78 03 00
	00		 fstp	 DWORD PTR [eax+888]

; 212  : 	        // Rotate by PI/(2*iSize2Use)
; 213  : 
; 214  : 	        pau->m_fltSinRampDownStep  =  (V4V5COMPARE)( 2 * sin( 2*dA ) );

  00516	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4000000000000000
  0051c	dc 4d f0	 fmul	 QWORD PTR _dA$[ebp]
  0051f	83 ec 08	 sub	 esp, 8
  00522	dd 1c 24	 fstp	 QWORD PTR [esp]
  00525	e8 00 00 00 00	 call	 _sin
  0052a	83 c4 08	 add	 esp, 8
  0052d	dc c0		 fadd	 ST(0), ST(0)
  0052f	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00532	d9 99 7c 03 00
	00		 fstp	 DWORD PTR [ecx+892]
$L2496:

; 215  :         }
; 216  : 
; 217  : #ifdef INTEGER_ENCODER
; 218  :     wmaResult = prvAdaptTrigToSubframeConfig_INT(pau);
; 219  : #endif  // INTEGER_ENCODER
; 220  :     return wmaResult;

  00538	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
$L2455:

; 221  : }

  0053b	8b e5		 mov	 esp, ebp
  0053d	5d		 pop	 ebp
  0053e	c2 04 00	 ret	 4
_prvAdaptTrigToSubframeConfig_XDS@4 ENDP
_TEXT	ENDS
PUBLIC	_prvInverseQuantizeLowRate_XDS@12
PUBLIC	__real@3f800000
PUBLIC	__real@4e000000
PUBLIC	_quickRand@4
EXTRN	_memset:NEAR
EXTRN	_qstCalcQuantStep_XDS@4:NEAR
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@4e000000
CONST	SEGMENT
__real@4e000000 DD 04e000000r			; 5.36871e+008
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _prvInverseQuantizeLowRate_XDS@12
_TEXT	SEGMENT
tv416 = -116
tv401 = -112
tv398 = -108
tv384 = -104
tv206 = -100
tv351 = -96
tv344 = -92
tv332 = -88
tv312 = -84
_fltNoise$2565 = -80
_fltNoisePower$2553 = -76
_fltNoise$2544 = -72
_fltNoise$2538 = -68
_qstQuantStep$2509 = -64
_rgiCoefQ$2513 = -60
_rgfltCoefRecon$2514 = -56
_rgiNoisePower$2519 = -52
_iRecon$2517 = -48
_rgffltSqrtBWRatio$2520 = -44
_rgfltWeightFactor$2510 = -40
_fltNoiseFactor$2524 = -36
_fltInvMaxWeight$2512 = -32
_iBark$2515 = -28
_iNoiseBand$2522 = -24
_qstQuantStepDivMaxWeight$2523 = -20
_iCoefQ$2516 = -16
_cNoiseBand$2521 = -9
_rgbBandNotCoded$2518 = -8
_iTarget$2525 = -4
_pau$ = 8
_ppcinfo$ = 12
_rgiWeightFactor$ = 16
_prvInverseQuantizeLowRate_XDS@12 PROC NEAR		; COMDAT

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H

; 273  :     FUNCTION_PROFILE(fp);
; 274  :     FUNCTION_PROFILE_START(&fp,INVERSE_QUAN_LOW_RATE_PROFILE);
; 275  :     {
; 276  : 		//Double dblQuantStep = (double)pau->m_iQuantStep/(1<<pau->m_iQuantStepFractBits);
; 277  : 		QuantStepType qstQuantStep = qstCalcQuantStep( pau->m_iQuantStepSize );

  00006	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00009	8b 88 44 03 00
	00		 mov	 ecx, DWORD PTR [eax+836]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _qstCalcQuantStep_XDS@4
  00015	d9 5d c0	 fstp	 DWORD PTR _qstQuantStep$2509[ebp]

; 278  : 		const Float* rgfltWeightFactor  = (Float*) rgiWeightFactor;

  00018	8b 55 10	 mov	 edx, DWORD PTR _rgiWeightFactor$[ebp]
  0001b	89 55 d8	 mov	 DWORD PTR _rgfltWeightFactor$2510[ebp], edx

; 279  : 		Float fltInvMaxWeight = 1.0F / ppcinfo->m_wtMaxWeight;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00021	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  00027	d8 70 6c	 fdiv	 DWORD PTR [eax+108]
  0002a	d9 5d e0	 fstp	 DWORD PTR _fltInvMaxWeight$2512[ebp]

; 280  :         const I16* rgiCoefQ             = ppcinfo->m_rgiCoefQ;

  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00030	8b 11		 mov	 edx, DWORD PTR [ecx]
  00032	89 55 c4	 mov	 DWORD PTR _rgiCoefQ$2513[ebp], edx

; 281  :         Float* rgfltCoefRecon           = ppcinfo->m_rgfltCoefRecon;

  00035	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00038	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0003b	89 4d c8	 mov	 DWORD PTR _rgfltCoefRecon$2514[ebp], ecx

; 282  : 	    Int iBark = 0;

  0003e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iBark$2515[ebp], 0

; 283  : 	    Int iCoefQ = 0;

  00045	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iCoefQ$2516[ebp], 0

; 284  : 	    Int iRecon = 0;

  0004c	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _iRecon$2517[ebp], 0

; 285  :         const U8* rgbBandNotCoded       = ppcinfo->m_rgbBandNotCoded;

  00053	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00056	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00059	89 45 f8	 mov	 DWORD PTR _rgbBandNotCoded$2518[ebp], eax

; 286  :         const Int* rgiNoisePower		= ppcinfo->m_rgiNoisePower;

  0005c	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  0005f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00062	89 55 cc	 mov	 DWORD PTR _rgiNoisePower$2519[ebp], edx

; 287  : #ifdef ENCODER
; 288  :         const Float* rgfltBandWeight    = ppcinfo->m_rgfltBandWeight;
; 289  : #else
; 290  : 		const FastFloat* const rgffltSqrtBWRatio = ppcinfo->m_rgffltSqrtBWRatio;

  00065	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00068	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006b	89 4d d4	 mov	 DWORD PTR _rgffltSqrtBWRatio$2520[ebp], ecx

; 291  : #endif
; 292  : 	    //	Float* rgfltNoise = pau->m_rgfltGaussRand + (rand () % (20480 / pau->m_cSubband)) * pau->m_cSubband; //swith to diff segments
; 293  : 	    U8 cNoiseBand;
; 294  : 	    Int iNoiseBand = 0;

  0006e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iNoiseBand$2522[ebp], 0

; 295  : 		QuantStepType qstQuantStepDivMaxWeight = qstQuantStep * fltInvMaxWeight;

  00075	d9 45 c0	 fld	 DWORD PTR _qstQuantStep$2509[ebp]
  00078	d8 4d e0	 fmul	 DWORD PTR _fltInvMaxWeight$2512[ebp]
  0007b	d9 5d ec	 fstp	 DWORD PTR _qstQuantStepDivMaxWeight$2523[ebp]

; 296  : 		Float fltNoiseFactor;
; 297  : 		Int iTarget;
; 298  : 
; 299  : 		DEBUG_BREAK_AT_FRAME_INV_QUANT;
; 300  : 		MONITOR_RANGE(gMR_QuantStepXInvMaxWeight,qstQuantStep*fltInvMaxWeight);		// match monitor in integer version
; 301  : 
; 302  : 		if (!pau->m_fNoiseSub) {

  0007e	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00081	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00085	0f 85 a7 00 00
	00		 jne	 $L2526

; 303  : 			// Unusual case, but 8kHz Mono 8kpbs gets here
; 304  : 			memset (rgfltCoefRecon, 0, pau->m_cLowCutOff * sizeof (Float));

  0008b	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0008e	8b 88 24 03 00
	00		 mov	 ecx, DWORD PTR [eax+804]
  00094	c1 e1 02	 shl	 ecx, 2
  00097	51		 push	 ecx
  00098	6a 00		 push	 0
  0009a	8b 55 c8	 mov	 edx, DWORD PTR _rgfltCoefRecon$2514[ebp]
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 _memset
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 305  : 			for (iRecon = pau->m_cLowCutOff; iRecon < pau->m_cHighCutOff; iRecon++, iCoefQ++)

  000a6	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000a9	8b 88 24 03 00
	00		 mov	 ecx, DWORD PTR [eax+804]
  000af	89 4d d0	 mov	 DWORD PTR _iRecon$2517[ebp], ecx
  000b2	eb 12		 jmp	 SHORT $L2528
$L2529:
  000b4	8b 55 d0	 mov	 edx, DWORD PTR _iRecon$2517[ebp]
  000b7	83 c2 01	 add	 edx, 1
  000ba	89 55 d0	 mov	 DWORD PTR _iRecon$2517[ebp], edx
  000bd	8b 45 f0	 mov	 eax, DWORD PTR _iCoefQ$2516[ebp]
  000c0	83 c0 01	 add	 eax, 1
  000c3	89 45 f0	 mov	 DWORD PTR _iCoefQ$2516[ebp], eax
$L2528:
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000c9	8b 55 d0	 mov	 edx, DWORD PTR _iRecon$2517[ebp]
  000cc	3b 91 28 03 00
	00		 cmp	 edx, DWORD PTR [ecx+808]
  000d2	7d 27		 jge	 SHORT $L2530

; 306  :     			rgfltCoefRecon [iRecon] = (Float)((Float) (rgiCoefQ [iCoefQ]) * rgfltWeightFactor [iRecon] * qstQuantStepDivMaxWeight );

  000d4	8b 45 f0	 mov	 eax, DWORD PTR _iCoefQ$2516[ebp]
  000d7	8b 4d c4	 mov	 ecx, DWORD PTR _rgiCoefQ$2513[ebp]
  000da	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  000de	89 55 ac	 mov	 DWORD PTR tv312[ebp], edx
  000e1	db 45 ac	 fild	 DWORD PTR tv312[ebp]
  000e4	8b 45 d0	 mov	 eax, DWORD PTR _iRecon$2517[ebp]
  000e7	8b 4d d8	 mov	 ecx, DWORD PTR _rgfltWeightFactor$2510[ebp]
  000ea	d8 0c 81	 fmul	 DWORD PTR [ecx+eax*4]
  000ed	d8 4d ec	 fmul	 DWORD PTR _qstQuantStepDivMaxWeight$2523[ebp]
  000f0	8b 55 d0	 mov	 edx, DWORD PTR _iRecon$2517[ebp]
  000f3	8b 45 c8	 mov	 eax, DWORD PTR _rgfltCoefRecon$2514[ebp]
  000f6	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]
  000f9	eb b9		 jmp	 SHORT $L2529
$L2530:

; 307  : 			memset (rgfltCoefRecon + pau->m_cHighCutOff, 0, (pau->m_cSubband - pau->m_cHighCutOff) * sizeof (Float));

  000fb	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000fe	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00101	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00104	2b 82 28 03 00
	00		 sub	 eax, DWORD PTR [edx+808]
  0010a	c1 e0 02	 shl	 eax, 2
  0010d	50		 push	 eax
  0010e	6a 00		 push	 0
  00110	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00113	8b 91 28 03 00
	00		 mov	 edx, DWORD PTR [ecx+808]
  00119	8b 45 c8	 mov	 eax, DWORD PTR _rgfltCoefRecon$2514[ebp]
  0011c	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0011f	51		 push	 ecx
  00120	e8 00 00 00 00	 call	 _memset
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH

; 308  :             FUNCTION_PROFILE_STOP(&fp);
; 309  : 			return WMA_OK;

  00128	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0012d	e9 c3 02 00 00	 jmp	 $L2508
$L2526:

; 310  : 		}
; 311  : 
; 312  : 		cNoiseBand = rgbBandNotCoded[0];

  00132	8b 55 f8	 mov	 edx, DWORD PTR _rgbBandNotCoded$2518[ebp]
  00135	8a 02		 mov	 al, BYTE PTR [edx]
  00137	88 45 f7	 mov	 BYTE PTR _cNoiseBand$2521[ebp], al

; 313  : 
; 314  : 		fltNoiseFactor = pau->m_fltDitherLevel / (Float) 0x20000000;

  0013a	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0013d	d9 81 40 03 00
	00		 fld	 DWORD PTR [ecx+832]
  00143	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@4e000000
  00149	d9 5d dc	 fstp	 DWORD PTR _fltNoiseFactor$2524[ebp]

; 315  : 		iTarget = pau->m_cLowCutOff;

  0014c	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0014f	8b 82 24 03 00
	00		 mov	 eax, DWORD PTR [edx+804]
  00155	89 45 fc	 mov	 DWORD PTR _iTarget$2525[ebp], eax
$L2536:

; 316  : 		while  (iRecon < iTarget) 	

  00158	8b 4d d0	 mov	 ecx, DWORD PTR _iRecon$2517[ebp]
  0015b	3b 4d fc	 cmp	 ecx, DWORD PTR _iTarget$2525[ebp]
  0015e	7d 44		 jge	 SHORT $L2537

; 317  : 		{	// This does not happen in V2 sounds, don't bother to optimize
; 318  : 		    Float fltNoise = fltNoiseFactor * ((Float) quickRand (&(pau->m_tRandState)));

  00160	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00163	81 c2 08 04 00
	00		 add	 edx, 1032		; 00000408H
  00169	52		 push	 edx
  0016a	e8 00 00 00 00	 call	 _quickRand@4
  0016f	89 45 a8	 mov	 DWORD PTR tv332[ebp], eax
  00172	db 45 a8	 fild	 DWORD PTR tv332[ebp]
  00175	d8 4d dc	 fmul	 DWORD PTR _fltNoiseFactor$2524[ebp]
  00178	d9 5d bc	 fstp	 DWORD PTR _fltNoise$2538[ebp]

; 319  : 		    rgfltCoefRecon [iRecon] = (Float) (fltNoise * rgfltWeightFactor [pau->m_cLowCutOff] * qstQuantStepDivMaxWeight );

  0017b	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0017e	8b 88 24 03 00
	00		 mov	 ecx, DWORD PTR [eax+804]
  00184	8b 55 d8	 mov	 edx, DWORD PTR _rgfltWeightFactor$2510[ebp]
  00187	d9 45 bc	 fld	 DWORD PTR _fltNoise$2538[ebp]
  0018a	d8 0c 8a	 fmul	 DWORD PTR [edx+ecx*4]
  0018d	d8 4d ec	 fmul	 DWORD PTR _qstQuantStepDivMaxWeight$2523[ebp]
  00190	8b 45 d0	 mov	 eax, DWORD PTR _iRecon$2517[ebp]
  00193	8b 4d c8	 mov	 ecx, DWORD PTR _rgfltCoefRecon$2514[ebp]
  00196	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]

; 320  : 			MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
; 321  : 			MONITOR_COUNT_CONDITIONAL(fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS)),gMC_zeroCoefRecon,1);
; 322  : 			MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[pau->m_cLowCutOff]*fltInvMaxWeight));
; 323  : 			PRINT_INVERSE_QUANTIZE(0,rgfltWeightFactor[pau->m_cLowCutOff],fltNoise);
; 324  : 		    iRecon++;

  00199	8b 55 d0	 mov	 edx, DWORD PTR _iRecon$2517[ebp]
  0019c	83 c2 01	 add	 edx, 1
  0019f	89 55 d0	 mov	 DWORD PTR _iRecon$2517[ebp], edx

; 325  :         }

  001a2	eb b4		 jmp	 SHORT $L2536
$L2537:

; 326  : 
; 327  : 		iTarget = pau->m_iFirstNoiseIndex;

  001a4	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001a7	8b 88 c4 03 00
	00		 mov	 ecx, DWORD PTR [eax+964]
  001ad	89 4d fc	 mov	 DWORD PTR _iTarget$2525[ebp], ecx
$L2542:

; 328  : 	    while  (iRecon < iTarget) {

  001b0	8b 55 d0	 mov	 edx, DWORD PTR _iRecon$2517[ebp]
  001b3	3b 55 fc	 cmp	 edx, DWORD PTR _iTarget$2525[ebp]
  001b6	7d 74		 jge	 SHORT $L2549

; 329  :             Float fltNoise = ((Float) quickRand (&(pau->m_tRandState))) * fltNoiseFactor;

  001b8	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001bb	05 08 04 00 00	 add	 eax, 1032		; 00000408H
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 _quickRand@4
  001c6	89 45 a4	 mov	 DWORD PTR tv344[ebp], eax
  001c9	db 45 a4	 fild	 DWORD PTR tv344[ebp]
  001cc	d8 4d dc	 fmul	 DWORD PTR _fltNoiseFactor$2524[ebp]
  001cf	d9 5d b8	 fstp	 DWORD PTR _fltNoise$2544[ebp]

; 330  : 		    if (iRecon >= pau->m_rgiBarkIndex [iBark + 1]) 

  001d2	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  001d5	8b 91 54 03 00
	00		 mov	 edx, DWORD PTR [ecx+852]
  001db	8b 45 e4	 mov	 eax, DWORD PTR _iBark$2515[ebp]
  001de	8b 4d d0	 mov	 ecx, DWORD PTR _iRecon$2517[ebp]
  001e1	3b 4c 82 04	 cmp	 ecx, DWORD PTR [edx+eax*4+4]
  001e5	7c 09		 jl	 SHORT $L2546

; 331  : 				iBark++;

  001e7	8b 55 e4	 mov	 edx, DWORD PTR _iBark$2515[ebp]
  001ea	83 c2 01	 add	 edx, 1
  001ed	89 55 e4	 mov	 DWORD PTR _iBark$2515[ebp], edx
$L2546:

; 332  :             assert(iBark < NUM_BARK_BAND);
; 333  : 		    rgfltCoefRecon [iRecon] = (Float) ((rgiCoefQ [iCoefQ] + fltNoise) * rgfltWeightFactor [iRecon] *
; 334  :                 qstQuantStepDivMaxWeight );			

  001f0	8b 45 f0	 mov	 eax, DWORD PTR _iCoefQ$2516[ebp]
  001f3	8b 4d c4	 mov	 ecx, DWORD PTR _rgiCoefQ$2513[ebp]
  001f6	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  001fa	89 55 a0	 mov	 DWORD PTR tv351[ebp], edx
  001fd	db 45 a0	 fild	 DWORD PTR tv351[ebp]
  00200	d8 45 b8	 fadd	 DWORD PTR _fltNoise$2544[ebp]
  00203	8b 45 d0	 mov	 eax, DWORD PTR _iRecon$2517[ebp]
  00206	8b 4d d8	 mov	 ecx, DWORD PTR _rgfltWeightFactor$2510[ebp]
  00209	d8 0c 81	 fmul	 DWORD PTR [ecx+eax*4]
  0020c	d8 4d ec	 fmul	 DWORD PTR _qstQuantStepDivMaxWeight$2523[ebp]
  0020f	8b 55 d0	 mov	 edx, DWORD PTR _iRecon$2517[ebp]
  00212	8b 45 c8	 mov	 eax, DWORD PTR _rgfltCoefRecon$2514[ebp]
  00215	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]

; 335  : 			MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
; 336  : 			MONITOR_COUNT_CONDITIONAL(fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS)),gMC_zeroCoefRecon,1);
; 337  : 			MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[iRecon]*fltInvMaxWeight));
; 338  : 			MONITOR_RANGE(gMR_weightFactor,rgfltWeightFactor[iRecon]);
; 339  : 			MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,rgfltWeightFactor[iRecon]*qstQuantStepDivMaxWeight);
; 340  : 			PRINT_INVERSE_QUANTIZE(rgiCoefQ [iCoefQ],rgfltWeightFactor [iRecon],fltNoise);
; 341  : 		    iRecon++;

  00218	8b 4d d0	 mov	 ecx, DWORD PTR _iRecon$2517[ebp]
  0021b	83 c1 01	 add	 ecx, 1
  0021e	89 4d d0	 mov	 DWORD PTR _iRecon$2517[ebp], ecx

; 342  : 		    iCoefQ++;

  00221	8b 55 f0	 mov	 edx, DWORD PTR _iCoefQ$2516[ebp]
  00224	83 c2 01	 add	 edx, 1
  00227	89 55 f0	 mov	 DWORD PTR _iCoefQ$2516[ebp], edx

; 343  :         }  

  0022a	eb 84		 jmp	 SHORT $L2542
$L2549:

; 344  : 		
; 345  :         while  (iRecon < pau->m_cHighCutOff) {

  0022c	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0022f	8b 4d d0	 mov	 ecx, DWORD PTR _iRecon$2517[ebp]
  00232	3b 88 28 03 00
	00		 cmp	 ecx, DWORD PTR [eax+808]
  00238	0f 8d 5c 01 00
	00		 jge	 $L2550

; 346  : 		    if (iRecon >= pau->m_rgiBarkIndex [iBark + 1]) 

  0023e	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00241	8b 82 54 03 00
	00		 mov	 eax, DWORD PTR [edx+852]
  00247	8b 4d e4	 mov	 ecx, DWORD PTR _iBark$2515[ebp]
  0024a	8b 55 d0	 mov	 edx, DWORD PTR _iRecon$2517[ebp]
  0024d	3b 54 88 04	 cmp	 edx, DWORD PTR [eax+ecx*4+4]
  00251	7c 09		 jl	 SHORT $L2551

; 347  : 				iBark++;

  00253	8b 45 e4	 mov	 eax, DWORD PTR _iBark$2515[ebp]
  00256	83 c0 01	 add	 eax, 1
  00259	89 45 e4	 mov	 DWORD PTR _iBark$2515[ebp], eax
$L2551:

; 348  :             assert(iBark < NUM_BARK_BAND);
; 349  : 			iTarget = min(pau->m_rgiBarkIndex [iBark + 1],pau->m_cHighCutOff);

  0025c	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0025f	8b 91 54 03 00
	00		 mov	 edx, DWORD PTR [ecx+852]
  00265	8b 45 e4	 mov	 eax, DWORD PTR _iBark$2515[ebp]
  00268	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0026b	8b 54 82 04	 mov	 edx, DWORD PTR [edx+eax*4+4]
  0026f	3b 91 28 03 00
	00		 cmp	 edx, DWORD PTR [ecx+808]
  00275	7d 15		 jge	 SHORT $L2601
  00277	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0027a	8b 88 54 03 00
	00		 mov	 ecx, DWORD PTR [eax+852]
  00280	8b 55 e4	 mov	 edx, DWORD PTR _iBark$2515[ebp]
  00283	8b 44 91 04	 mov	 eax, DWORD PTR [ecx+edx*4+4]
  00287	89 45 9c	 mov	 DWORD PTR tv206[ebp], eax
  0028a	eb 0c		 jmp	 SHORT $L2602
$L2601:
  0028c	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0028f	8b 91 28 03 00
	00		 mov	 edx, DWORD PTR [ecx+808]
  00295	89 55 9c	 mov	 DWORD PTR tv206[ebp], edx
$L2602:
  00298	8b 45 9c	 mov	 eax, DWORD PTR tv206[ebp]
  0029b	89 45 fc	 mov	 DWORD PTR _iTarget$2525[ebp], eax

; 350  : 
; 351  : 			if (rgbBandNotCoded [iBark] == WMAB_TRUE)

  0029e	8b 4d f8	 mov	 ecx, DWORD PTR _rgbBandNotCoded$2518[ebp]
  002a1	03 4d e4	 add	 ecx, DWORD PTR _iBark$2515[ebp]
  002a4	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  002a7	83 fa 01	 cmp	 edx, 1
  002aa	75 71		 jne	 SHORT $L2552

; 352  :             {
; 353  : #ifdef ENCODER
; 354  :                 Float fltNoisePower0 = (Float) qstCalcQuantStep(rgiNoisePower [iNoiseBand]);
; 355  :                 Float fltNoisePower1 = (Float) (sqrt (rgfltBandWeight [iNoiseBand] / rgfltBandWeight [cNoiseBand - 1]));
; 356  :                 Float fltNoisePower = fltNoisePower0 * fltNoisePower1; // Exact match with int-float decoder only when I store in two variables! Naveen
; 357  : #else
; 358  : 				Float fltNoisePower = (Float)( qstCalcQuantStep(rgiNoisePower [iNoiseBand]) * rgffltSqrtBWRatio[iNoiseBand] );

  002ac	8b 45 e8	 mov	 eax, DWORD PTR _iNoiseBand$2522[ebp]
  002af	8b 4d cc	 mov	 ecx, DWORD PTR _rgiNoisePower$2519[ebp]
  002b2	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  002b5	52		 push	 edx
  002b6	e8 00 00 00 00	 call	 _qstCalcQuantStep_XDS@4
  002bb	8b 45 e8	 mov	 eax, DWORD PTR _iNoiseBand$2522[ebp]
  002be	8b 4d d4	 mov	 ecx, DWORD PTR _rgffltSqrtBWRatio$2520[ebp]
  002c1	d8 0c 81	 fmul	 DWORD PTR [ecx+eax*4]
  002c4	d9 5d b4	 fstp	 DWORD PTR _fltNoisePower$2553[ebp]

; 359  : #endif
; 360  : 			    assert(iBark < NUM_BARK_BAND);
; 361  : 				fltNoisePower *= fltInvMaxWeight / (Float) 0x20000000;

  002c7	d9 45 e0	 fld	 DWORD PTR _fltInvMaxWeight$2512[ebp]
  002ca	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@4e000000
  002d0	d8 4d b4	 fmul	 DWORD PTR _fltNoisePower$2553[ebp]
  002d3	d9 5d b4	 fstp	 DWORD PTR _fltNoisePower$2553[ebp]
$L2557:

; 362  : 			    while (iRecon < iTarget)

  002d6	8b 55 d0	 mov	 edx, DWORD PTR _iRecon$2517[ebp]
  002d9	3b 55 fc	 cmp	 edx, DWORD PTR _iTarget$2525[ebp]
  002dc	7d 34		 jge	 SHORT $L2558

; 363  :                 {
; 364  : 				    rgfltCoefRecon [iRecon] = ((Float) quickRand (&(pau->m_tRandState))) * fltNoisePower 
; 365  : 											* rgfltWeightFactor [iRecon];

  002de	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002e1	05 08 04 00 00	 add	 eax, 1032		; 00000408H
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 _quickRand@4
  002ec	89 45 98	 mov	 DWORD PTR tv384[ebp], eax
  002ef	db 45 98	 fild	 DWORD PTR tv384[ebp]
  002f2	d8 4d b4	 fmul	 DWORD PTR _fltNoisePower$2553[ebp]
  002f5	8b 4d d0	 mov	 ecx, DWORD PTR _iRecon$2517[ebp]
  002f8	8b 55 d8	 mov	 edx, DWORD PTR _rgfltWeightFactor$2510[ebp]
  002fb	d8 0c 8a	 fmul	 DWORD PTR [edx+ecx*4]
  002fe	8b 45 d0	 mov	 eax, DWORD PTR _iRecon$2517[ebp]
  00301	8b 4d c8	 mov	 ecx, DWORD PTR _rgfltCoefRecon$2514[ebp]
  00304	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]

; 366  : 					MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
; 367  : 					MONITOR_COUNT_CONDITIONAL(fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS)),gMC_zeroCoefRecon,1);
; 368  : 					MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[iRecon]*fltInvMaxWeight));
; 369  : 					MONITOR_RANGE(gMR_weightFactor,rgfltWeightFactor[iRecon]);
; 370  : 					PRINT_INVERSE_QUANTIZE(0,rgfltWeightFactor [iRecon],rgfltCoefRecon [iRecon]/rgfltWeightFactor [iRecon]);
; 371  : 				    iRecon++;	

  00307	8b 55 d0	 mov	 edx, DWORD PTR _iRecon$2517[ebp]
  0030a	83 c2 01	 add	 edx, 1
  0030d	89 55 d0	 mov	 DWORD PTR _iRecon$2517[ebp], edx

; 372  : 			    }

  00310	eb c4		 jmp	 SHORT $L2557
$L2558:

; 373  : 			    iNoiseBand++;

  00312	8b 45 e8	 mov	 eax, DWORD PTR _iNoiseBand$2522[ebp]
  00315	83 c0 01	 add	 eax, 1
  00318	89 45 e8	 mov	 DWORD PTR _iNoiseBand$2522[ebp], eax

; 374  : 		    }
; 375  : 		    else 

  0031b	eb 78		 jmp	 SHORT $L2560
$L2552:

; 376  : 			{
; 377  : 				if ( pau->m_cHighCutOff < iTarget )

  0031d	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00320	8b 91 28 03 00
	00		 mov	 edx, DWORD PTR [ecx+808]
  00326	3b 55 fc	 cmp	 edx, DWORD PTR _iTarget$2525[ebp]
  00329	7d 0c		 jge	 SHORT $L2563

; 378  : 					iTarget = pau->m_cHighCutOff;

  0032b	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0032e	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  00334	89 4d fc	 mov	 DWORD PTR _iTarget$2525[ebp], ecx
$L2563:

; 379  : 			    while (iRecon < iTarget)

  00337	8b 55 d0	 mov	 edx, DWORD PTR _iRecon$2517[ebp]
  0033a	3b 55 fc	 cmp	 edx, DWORD PTR _iTarget$2525[ebp]
  0033d	7d 56		 jge	 SHORT $L2560

; 380  :                 {
; 381  : 					Float fltNoise = ((Float) quickRand (&(pau->m_tRandState))) * fltNoiseFactor;

  0033f	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00342	05 08 04 00 00	 add	 eax, 1032		; 00000408H
  00347	50		 push	 eax
  00348	e8 00 00 00 00	 call	 _quickRand@4
  0034d	89 45 94	 mov	 DWORD PTR tv398[ebp], eax
  00350	db 45 94	 fild	 DWORD PTR tv398[ebp]
  00353	d8 4d dc	 fmul	 DWORD PTR _fltNoiseFactor$2524[ebp]
  00356	d9 5d b0	 fstp	 DWORD PTR _fltNoise$2565[ebp]

; 382  : 					rgfltCoefRecon [iRecon] = (Float) ((rgiCoefQ [iCoefQ] + fltNoise) * rgfltWeightFactor [iRecon] *
; 383  : 						qstQuantStepDivMaxWeight );			

  00359	8b 4d f0	 mov	 ecx, DWORD PTR _iCoefQ$2516[ebp]
  0035c	8b 55 c4	 mov	 edx, DWORD PTR _rgiCoefQ$2513[ebp]
  0035f	0f bf 04 4a	 movsx	 eax, WORD PTR [edx+ecx*2]
  00363	89 45 90	 mov	 DWORD PTR tv401[ebp], eax
  00366	db 45 90	 fild	 DWORD PTR tv401[ebp]
  00369	d8 45 b0	 fadd	 DWORD PTR _fltNoise$2565[ebp]
  0036c	8b 4d d0	 mov	 ecx, DWORD PTR _iRecon$2517[ebp]
  0036f	8b 55 d8	 mov	 edx, DWORD PTR _rgfltWeightFactor$2510[ebp]
  00372	d8 0c 8a	 fmul	 DWORD PTR [edx+ecx*4]
  00375	d8 4d ec	 fmul	 DWORD PTR _qstQuantStepDivMaxWeight$2523[ebp]
  00378	8b 45 d0	 mov	 eax, DWORD PTR _iRecon$2517[ebp]
  0037b	8b 4d c8	 mov	 ecx, DWORD PTR _rgfltCoefRecon$2514[ebp]
  0037e	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]

; 384  : 					MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
; 385  : 					MONITOR_COUNT_CONDITIONAL(fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS)),gMC_zeroCoefRecon,1);
; 386  : 					MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[iRecon]*fltInvMaxWeight));
; 387  : 					MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,rgfltWeightFactor[iRecon]*qstQuantStepDivMaxWeight);
; 388  : 					MONITOR_RANGE(gMR_weightFactor,rgfltWeightFactor[iRecon]);
; 389  : 					PRINT_INVERSE_QUANTIZE(rgiCoefQ [iCoefQ],rgfltWeightFactor [iRecon],fltNoise);
; 390  : 					iRecon++;

  00381	8b 55 d0	 mov	 edx, DWORD PTR _iRecon$2517[ebp]
  00384	83 c2 01	 add	 edx, 1
  00387	89 55 d0	 mov	 DWORD PTR _iRecon$2517[ebp], edx

; 391  : 					iCoefQ++;

  0038a	8b 45 f0	 mov	 eax, DWORD PTR _iCoefQ$2516[ebp]
  0038d	83 c0 01	 add	 eax, 1
  00390	89 45 f0	 mov	 DWORD PTR _iCoefQ$2516[ebp], eax

; 392  : 				}

  00393	eb a2		 jmp	 SHORT $L2563
$L2560:

; 393  : 		    }
; 394  : 	    }

  00395	e9 92 fe ff ff	 jmp	 $L2549
$L2550:

; 395  : 
; 396  : 		iTarget = pau->m_cSubband;

  0039a	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0039d	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  003a0	89 55 fc	 mov	 DWORD PTR _iTarget$2525[ebp], edx

; 397  : 		fltNoiseFactor *= (Float)(rgfltWeightFactor [pau->m_cHighCutOff - 1] * qstQuantStepDivMaxWeight);

  003a3	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  003a6	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  003ac	8b 55 d8	 mov	 edx, DWORD PTR _rgfltWeightFactor$2510[ebp]
  003af	d9 45 ec	 fld	 DWORD PTR _qstQuantStepDivMaxWeight$2523[ebp]
  003b2	d8 4c 8a fc	 fmul	 DWORD PTR [edx+ecx*4-4]
  003b6	d8 4d dc	 fmul	 DWORD PTR _fltNoiseFactor$2524[ebp]
  003b9	d9 5d dc	 fstp	 DWORD PTR _fltNoiseFactor$2524[ebp]
$L2570:

; 398  : 	    while  (iRecon < iTarget) 	{

  003bc	8b 45 d0	 mov	 eax, DWORD PTR _iRecon$2517[ebp]
  003bf	3b 45 fc	 cmp	 eax, DWORD PTR _iTarget$2525[ebp]
  003c2	7d 2c		 jge	 SHORT $L2571

; 399  : 		    rgfltCoefRecon [iRecon] = ((Float) quickRand (&(pau->m_tRandState))) * fltNoiseFactor;

  003c4	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  003c7	81 c1 08 04 00
	00		 add	 ecx, 1032		; 00000408H
  003cd	51		 push	 ecx
  003ce	e8 00 00 00 00	 call	 _quickRand@4
  003d3	89 45 8c	 mov	 DWORD PTR tv416[ebp], eax
  003d6	db 45 8c	 fild	 DWORD PTR tv416[ebp]
  003d9	d8 4d dc	 fmul	 DWORD PTR _fltNoiseFactor$2524[ebp]
  003dc	8b 55 d0	 mov	 edx, DWORD PTR _iRecon$2517[ebp]
  003df	8b 45 c8	 mov	 eax, DWORD PTR _rgfltCoefRecon$2514[ebp]
  003e2	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]

; 400  : 			// MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
; 401  : 			// if (fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS))) { MONITOR_COUNT(gMC_zeroCoefRecon,1); }
; 402  : 			MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[pau->m_cHighCutOff-1]*fltInvMaxWeight));
; 403  : 			MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,rgfltWeightFactor[pau->m_cHighCutOff-1]*qstQuantStepDivMaxWeight);
; 404  : 			MONITOR_RANGE(gMR_weightFactor,rgfltWeightFactor[pau->m_cHighCutOff-1]);
; 405  : 			PRINT_INVERSE_QUANTIZE(0,rgfltWeightFactor [iRecon],rgfltCoefRecon [iRecon]/rgfltWeightFactor [pau->m_cHighCutOff - 1]);
; 406  : 		    iRecon++;

  003e5	8b 4d d0	 mov	 ecx, DWORD PTR _iRecon$2517[ebp]
  003e8	83 c1 01	 add	 ecx, 1
  003eb	89 4d d0	 mov	 DWORD PTR _iRecon$2517[ebp], ecx

; 407  :         }    

  003ee	eb cc		 jmp	 SHORT $L2570
$L2571:

; 408  :     }
; 409  :     FUNCTION_PROFILE_STOP(&fp);
; 410  : 	return WMA_OK;

  003f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
$L2508:

; 411  : }

  003f5	8b e5		 mov	 esp, ebp
  003f7	5d		 pop	 ebp
  003f8	c2 0c 00	 ret	 12			; 0000000cH
_prvInverseQuantizeLowRate_XDS@12 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\common\macros.h
_TEXT	ENDS
;	COMDAT _quickRand@4
_TEXT	SEGMENT
_c$ = -16
_iTemp1$ = -12
_a$ = -8
_iTemp$ = -4
_ptRandState$ = 8
_quickRand@4 PROC NEAR					; COMDAT

; 774  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 775  :         const U32 a = 1664525;

  00006	c7 45 f8 0d 66
	19 00		 mov	 DWORD PTR _a$[ebp], 1664525 ; 0019660dH

; 776  :         const U32 c = 1013904223;

  0000d	c7 45 f0 5f f3
	6e 3c		 mov	 DWORD PTR _c$[ebp], 1013904223 ; 3c6ef35fH

; 777  :         I32 iTemp, iTemp1;
; 778  :         //a*x + c has to be done with unsigned 32 bit
; 779  :         ptRandState->uiRand =  a * ptRandState->uiRand + c;

  00014	8b 45 08	 mov	 eax, DWORD PTR _ptRandState$[ebp]
  00017	8b 4d f8	 mov	 ecx, DWORD PTR _a$[ebp]
  0001a	0f af 48 04	 imul	 ecx, DWORD PTR [eax+4]
  0001e	03 4d f0	 add	 ecx, DWORD PTR _c$[ebp]
  00021	8b 55 08	 mov	 edx, DWORD PTR _ptRandState$[ebp]
  00024	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 780  : 
; 781  :         // uiRand values starting from a 0 seed are: 0x3c6ef35f, 0x47502932, 0xd1ccf6e9, 0xaaf95334, 0x6252e503, 0x9f2ec686, 0x57fe6c2d, ...
; 782  : 
; 783  :         // do not change the above - this reference generator has been extensively tested and has excellent randomness properties
; 784  :         // a truism in the world of random number generator theory and practice is:
; 785  :         // "any change, no matter how small, can and will change the properties of the generator and must be fully tested"
; 786  :         // In case you don't know, it can easily take a person-month to fully test a generator.
; 787  :     
; 788  :         // Notwithstanding the above, it is fair to take a function of a random number to shape its range or distribution.
; 789  :         // This we do below to give it a triangular distrbution between -2.5 and 2.5 to roughly approximate a Guassian distribution.
; 790  : 
; 791  :         // cast and shift to make the range (-1, 1) with Binary Point 3.
; 792  :         iTemp = ((I32)(ptRandState->uiRand)) >> 2; 

  00027	8b 45 08	 mov	 eax, DWORD PTR _ptRandState$[ebp]
  0002a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002d	c1 f9 02	 sar	 ecx, 2
  00030	89 4d fc	 mov	 DWORD PTR _iTemp$[ebp], ecx

; 793  : 
; 794  :         // *1.25 to make the range (-1.25, 1.25) 
; 795  :         iTemp += (iTemp>>2);

  00033	8b 55 fc	 mov	 edx, DWORD PTR _iTemp$[ebp]
  00036	c1 fa 02	 sar	 edx, 2
  00039	8b 45 fc	 mov	 eax, DWORD PTR _iTemp$[ebp]
  0003c	03 c2		 add	 eax, edx
  0003e	89 45 fc	 mov	 DWORD PTR _iTemp$[ebp], eax

; 796  :     
; 797  :         // Difference of two random numbers gives a triangle distribution and a range of (-2.5, 2.5)
; 798  :         // it also gives a serial correlation of -0.5 at lag 1.  But all the other lags have normally small correlations.
; 799  :         iTemp1 = iTemp - ptRandState->iPrior;

  00041	8b 4d 08	 mov	 ecx, DWORD PTR _ptRandState$[ebp]
  00044	8b 55 fc	 mov	 edx, DWORD PTR _iTemp$[ebp]
  00047	2b 11		 sub	 edx, DWORD PTR [ecx]
  00049	89 55 f4	 mov	 DWORD PTR _iTemp1$[ebp], edx

; 800  : 
; 801  :         // Save first term of this difference for next time.
; 802  :         ptRandState->iPrior = iTemp;

  0004c	8b 45 08	 mov	 eax, DWORD PTR _ptRandState$[ebp]
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _iTemp$[ebp]
  00052	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 
; 804  :         //return -2.5 to 2.5 with Binary Point = 3 with a triangle distribution
; 805  :         return iTemp1;

  00054	8b 45 f4	 mov	 eax, DWORD PTR _iTemp1$[ebp]

; 806  :     }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
_quickRand@4 ENDP
_TEXT	ENDS
END
