; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\wavfileio.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
WMADEC_RW	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RW	ENDS
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT @ByteSwap@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _Direct3D_AddRef@0
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _Direct3D_Release@0
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _Direct3D_GetAdapterCount@0
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DDevice_BeginScene@0
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DDevice_EndScene@0
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DDevice_GetRenderState@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DDevice_GetTextureStageState@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DDevice_SetRenderState@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DDevice_SetTextureStageState@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DResource_MoveResourceMemory@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DTexture_UnlockRect@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DVolumeTexture_UnlockBox@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DCubeTexture_UnlockRect@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DVertexBuffer_Unlock@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DIndexBuffer_Lock@20
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DIndexBuffer_Unlock@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DPalette_Unlock@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DSurface_UnlockRect@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DVolume_UnlockBox@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _adjustByteOrder16@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _adjustByteOrder32@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioNew@0
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioDelete@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioOpen@20
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioClose@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioSeek@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioRead@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioWrite@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioGetFormat@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioGetFormatLength@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioGetSampleSize@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioGetDataLength@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioGetMode@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioIsOpened@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioReadHeaders@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioWriteHeaders@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioCleanUpRead@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _wfioCleanUpWrite@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, WMADEC_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_D3DPRIMITIVETOVERTEXCOUNT
PUBLIC	_D3DSIMPLERENDERSTATEENCODE
PUBLIC	_D3DTEXTUREDIRECTENCODE
PUBLIC	_D3DDIRTYFROMRENDERSTATE
PUBLIC	_D3DDIRTYFROMTEXTURESTATE
PUBLIC	_DSoundBuildNumberD
WMADEC_RD	SEGMENT
_WMA_OK	DD	00H
_WMA_S_FALSE DD	01H
_WMA_S_BUFUNDERFLOW DD 02H
_WMA_S_NEWPACKET DD 03H
_WMA_S_NO_MORE_FRAME DD 04H
_WMA_S_DEFAULT DD 05H
_WMA_S_SWITCHCHMODE DD 06H
_WMA_E_FAIL DD	080004005H
_WMA_E_OUTOFMEMORY DD 08007000eH
_WMA_E_INVALIDARG DD 080070057H
_WMA_E_NOTSUPPORTED DD 080040000H
_WMA_E_LOSTPACKET DD 080040001H
_WMA_E_BROKEN_FRAME DD 080040002H
_WMA_E_BUFFEROVERFLOW DD 080040003H
_WMA_E_ONHOLD DD 080040004H
_WMA_E_BUFFERUNDERFLOW DD 080040005H
_WMA_E_INVALIDRECHDR DD 080040006H
_WMA_E_SYNCERROR DD 080040007H
_WMA_E_NOTIMPL DD 080040008H
_WMA_E_FLUSHOVERFLOW DD 080040009H
WMADEC_RD	ENDS
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
WMADEC_RD	SEGMENT
_D3DPRIMITIVETOVERTEXCOUNT DD 00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
WMADEC_RD	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
WMADEC_RD	SEGMENT
_D3DSIMPLERENDERSTATEENCODE DD 040260H
	DD	040264H
	DD	040268H
	DD	04026cH
	DD	040270H
	DD	040274H
	DD	040278H
	DD	04027cH
	DD	040288H
	DD	04028cH
	DD	040a60H
	DD	040a64H
	DD	040a68H
	DD	040a6cH
	DD	040a70H
	DD	040a74H
	DD	040a78H
	DD	040a7cH
	DD	040a80H
	DD	040a84H
	DD	040a88H
	DD	040a8cH
	DD	040a90H
	DD	040a94H
	DD	040a98H
	DD	040a9cH
	DD	040aa0H
	DD	040aa4H
	DD	040aa8H
	DD	040aacH
	DD	040ab0H
	DD	040ab4H
	DD	040ab8H
	DD	040abcH
	DD	040ac0H
	DD	040ac4H
	DD	040ac8H
	DD	040accH
	DD	040ad0H
	DD	040ad4H
	DD	040ad8H
	DD	040adcH
	DD	0417f8H
	DD	041e20H
	DD	041e24H
	DD	041e40H
	DD	041e44H
	DD	041e48H
	DD	041e4cH
	DD	041e50H
	DD	041e54H
	DD	041e58H
	DD	041e5cH
	DD	041e60H
	DD	041d90H
	DD	041e74H
	DD	041e78H
	DD	040354H
	DD	04033cH
	DD	040304H
	DD	040300H
	DD	040340H
	DD	040344H
	DD	040348H
	DD	04035cH
	DD	040310H
	DD	04037cH
	DD	040358H
	DD	040374H
	DD	040378H
	DD	040364H
	DD	040368H
	DD	04036cH
	DD	040360H
	DD	040350H
	DD	04034cH
	DD	0409f8H
	DD	040384H
	DD	040388H
	DD	040330H
	DD	040334H
	DD	040338H
WMADEC_RD	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
WMADEC_RD	SEGMENT
_D3DTEXTUREDIRECTENCODE DD 081b00H
	DD	081b40H
	DD	081b80H
	DD	081bc0H
WMADEC_RD	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
WMADEC_RD	SEGMENT
_D3DDIRTYFROMRENDERSTATE DD 02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	01200H
	DD	03000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	0100H
	DD	0100H
	DD	0900H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	00H
	DD	00H
	DD	00H
WMADEC_RD	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
WMADEC_RD	SEGMENT
_D3DDIRTYFROMTEXTURESTATE DD 0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0480fH
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0400H
WMADEC_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT
_DSoundBuildNumberD DW 05344H
	DW	0554fH
	DW	0444eH
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_adjustByteOrder16@4
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wavfileio.c
;	COMDAT _adjustByteOrder16@4
WMADEC	SEGMENT
_val$ = 8
_adjustByteOrder16@4 PROC NEAR				; COMDAT

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 58   : #if WFIO_LITTLE_ENDIAN
; 59   :     return val;

  00003	66 8b 45 08	 mov	 ax, WORD PTR _val$[ebp]

; 60   : #else  /* WFIO_LITTLE_ENDIAN */
; 61   :     U8 *p = (U8 *)&val;
; 62   :     return ((U16)p[0])|((U16)p[1]<<8);
; 63   : #endif /* WFIO_LITTLE_ENDIAN */
; 64   : }

  00007	5d		 pop	 ebp
  00008	c2 04 00	 ret	 4
_adjustByteOrder16@4 ENDP
WMADEC	ENDS
PUBLIC	_adjustByteOrder32@4
; Function compile flags: /Odt
;	COMDAT _adjustByteOrder32@4
WMADEC	SEGMENT
_val$ = 8
_adjustByteOrder32@4 PROC NEAR				; COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   : #if WFIO_LITTLE_ENDIAN
; 70   :     return val;

  00003	8b 45 08	 mov	 eax, DWORD PTR _val$[ebp]

; 71   : #else  /* WFIO_LITTLE_ENDIAN */
; 72   :     U8 *p = (U8 *)&val;
; 73   :     return ((U32)p[0])|((U32)p[1]<<8)|((U32)p[2]<<16)|((U32)p[3]<<24);
; 74   : #endif /* WFIO_LITTLE_ENDIAN */
; 75   : }

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
_adjustByteOrder32@4 ENDP
WMADEC	ENDS
PUBLIC	_wfioNew@0
EXTRN	_malloc:NEAR
; Function compile flags: /Odt
;	COMDAT _wfioNew@0
WMADEC	SEGMENT
_pwfio$ = -4
_wfioNew@0 PROC NEAR					; COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 81   :     WavFileIO *pwfio = (WavFileIO *)malloc(sizeof(WavFileIO));

  00004	6a 20		 push	 32			; 00000020H
  00006	e8 00 00 00 00	 call	 _malloc
  0000b	83 c4 04	 add	 esp, 4
  0000e	89 45 fc	 mov	 DWORD PTR _pwfio$[ebp], eax

; 82   :     if(pwfio == NULL)

  00011	83 7d fc 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  00015	75 04		 jne	 SHORT $L18273

; 83   :         return NULL;

  00017	33 c0		 xor	 eax, eax
  00019	eb 52		 jmp	 SHORT $L18268
$L18273:

; 84   : 
; 85   :     pwfio->m_mode = wfioModeRead;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 86   : #if WFIO_NO_WIN32
; 87   :     pwfio->m_fpWav = NULL;

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00027	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 88   :     pwfio->m_posRiffLength = 0;

  0002e	8b 55 fc	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00031	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 89   :     pwfio->m_posDataLength = 0;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0003b	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 90   : #else   /* WFIO_NO_WIN32 */
; 91   :     pwfio->m_hmmio = NULL;
; 92   : #endif  /* WFIO_NO_WIN32 */
; 93   :     pwfio->m_pFormat = NULL;

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00045	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 94   :     pwfio->m_sizeFormat = 0;

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0004f	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 95   :     pwfio->m_sizeData = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00059	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 96   :     pwfio->m_posDataStart = 0;

  00060	8b 4d fc	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00063	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 97   : 
; 98   : #if !WFIO_NO_WIN32
; 99   :     memset(&pwfio->m_mmioinfo, 0, sizeof(pwfio->m_mmioinfo));
; 100  :     memset(&pwfio->m_ckWave, 0, sizeof(pwfio->m_ckWave));
; 101  :     memset(&pwfio->m_ck, 0, sizeof(pwfio->m_ck));
; 102  : #endif  /* WFIO_NO_WIN32 */
; 103  : 
; 104  :     return pwfio;

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _pwfio$[ebp]
$L18268:

; 105  : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_wfioNew@0 ENDP
WMADEC	ENDS
PUBLIC	_wfioDelete@4
PUBLIC	_wfioClose@4
EXTRN	_free:NEAR
; Function compile flags: /Odt
;	COMDAT _wfioDelete@4
WMADEC	SEGMENT
_pwfio$ = 8
_wfioDelete@4 PROC NEAR					; COMDAT

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  :     wfioClose(pwfio);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _wfioClose@4

; 112  :     free(pwfio);

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _free
  00015	83 c4 04	 add	 esp, 4

; 113  : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
_wfioDelete@4 ENDP
WMADEC	ENDS
PUBLIC	_wfioOpen@20
PUBLIC	_wfioSeek@12
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
EXTRN	_fopen:NEAR
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
WMADEC_RD	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
WMADEC_RD	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
WMADEC_RD	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Odt
WMADEC_RD	ENDS
;	COMDAT _wfioOpen@20
WMADEC	SEGMENT
_lr$ = -4
_pwfio$ = 8
_szFile$ = 12
_pFormat$ = 16
_cbFormat$ = 20
_mode$ = 24
_wfioOpen@20 PROC NEAR					; COMDAT

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 123  :     I32 lr;
; 124  : 
; 125  :     if(pwfio == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  00008	75 0a		 jne	 SHORT $L18293

; 126  :         return MMSYSERR_ERROR;

  0000a	b8 01 00 00 00	 mov	 eax, 1
  0000f	e9 c4 00 00 00	 jmp	 $L18290
$L18293:

; 127  : 
; 128  : #if WFIO_NO_WIN32
; 129  : 
; 130  :     if(pwfio->m_fpWav)

  00014	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00017	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001b	74 0a		 je	 SHORT $L18294

; 131  :         return MMSYSERR_ERROR;

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	e9 b1 00 00 00	 jmp	 $L18290
$L18294:

; 132  : 
; 133  :     pwfio->m_mode = mode;

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  0002a	8b 55 18	 mov	 edx, DWORD PTR _mode$[ebp]
  0002d	89 11		 mov	 DWORD PTR [ecx], edx

; 134  : 
; 135  :     if(pwfio->m_mode == wfioModeWrite)

  0002f	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00032	83 38 01	 cmp	 DWORD PTR [eax], 1
  00035	75 47		 jne	 SHORT $L18295

; 136  :     {
; 137  :         /* open the file for writing */
; 138  :         pwfio->m_fpWav = fopen(szFile, "wb");

  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02GMLFBBN@wb?$AA@
  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR _szFile$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _fopen
  00045	83 c4 08	 add	 esp, 8
  00048	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0004b	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 139  :         if(pwfio->m_fpWav == NULL)

  0004e	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00051	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00055	75 09		 jne	 SHORT $L18298

; 140  :         {
; 141  :             lr = MMSYSERR_ERROR;

  00057	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 142  :             goto lerror;

  0005e	eb 6c		 jmp	 SHORT $lerror$18299
$L18298:

; 143  :         }
; 144  : 
; 145  :         /* write the header info */
; 146  :         lr = wfioWriteHeaders(pwfio, pFormat, cbFormat);

  00060	8b 4d 14	 mov	 ecx, DWORD PTR _cbFormat$[ebp]
  00063	51		 push	 ecx
  00064	8b 55 10	 mov	 edx, DWORD PTR _pFormat$[ebp]
  00067	52		 push	 edx
  00068	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _wfioWriteHeaders@12
  00071	89 45 fc	 mov	 DWORD PTR _lr$[ebp], eax

; 147  :         if(lr != MMSYSERR_NOERROR)

  00074	83 7d fc 00	 cmp	 DWORD PTR _lr$[ebp], 0
  00078	74 02		 je	 SHORT $L18300

; 148  :             goto lerror;

  0007a	eb 50		 jmp	 SHORT $lerror$18299
$L18300:

; 149  :     }
; 150  :     else

  0007c	eb 4a		 jmp	 SHORT $L18301
$L18295:

; 151  :     {
; 152  :         /* open the file for reading */
; 153  :         pwfio->m_fpWav = fopen(szFile, "rb");

  0007e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02JDPG@rb?$AA@
  00083	8b 4d 0c	 mov	 ecx, DWORD PTR _szFile$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 _fopen
  0008c	83 c4 08	 add	 esp, 8
  0008f	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00092	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 154  :         if(pwfio->m_fpWav == NULL)

  00095	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00098	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0009c	75 09		 jne	 SHORT $L18304

; 155  :         {
; 156  :             lr = MMSYSERR_ERROR;

  0009e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 157  :             goto lerror;

  000a5	eb 25		 jmp	 SHORT $lerror$18299
$L18304:

; 158  :         }
; 159  : 
; 160  :         /* read the hearder info */
; 161  :         lr = wfioReadHeaders(pwfio);

  000a7	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  000aa	51		 push	 ecx
  000ab	e8 00 00 00 00	 call	 _wfioReadHeaders@4
  000b0	89 45 fc	 mov	 DWORD PTR _lr$[ebp], eax

; 162  :         if(lr != MMSYSERR_NOERROR)

  000b3	83 7d fc 00	 cmp	 DWORD PTR _lr$[ebp], 0
  000b7	74 02		 je	 SHORT $L18305

; 163  :             goto lerror;

  000b9	eb 11		 jmp	 SHORT $lerror$18299
$L18305:

; 164  : 
; 165  :         /* seek to the beginning */
; 166  :         wfioSeek(pwfio, 0, SEEK_CUR);

  000bb	6a 01		 push	 1
  000bd	6a 00		 push	 0
  000bf	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 _wfioSeek@12
$L18301:

; 167  :     }
; 168  : 
; 169  : #else  /* WFIO_NO_WIN32 */
; 170  : 
; 171  :     if(pwfio->m_hmmio)
; 172  :         return MMSYSERR_ERROR;
; 173  : 
; 174  :     pwfio->m_mode = mode;
; 175  : 
; 176  :     /* slightly different for READ and WRITE */
; 177  :     if(pwfio->m_mode == wfioModeRead)
; 178  :     {
; 179  :         /* open the file for read */
; 180  :         pwfio->m_hmmio = mmioOpen((LPSTR)szFile, NULL, MMIO_READ/*|MMIO_DENYWRITE*/);
; 181  :         if(pwfio->m_hmmio == NULL)
; 182  :         {
; 183  :             lr = MMSYSERR_ERROR;
; 184  :             goto lerror;
; 185  :         }
; 186  : 
; 187  :         /* read the header info */
; 188  :         lr = wfioReadHeaders(pwfio);
; 189  :         if(lr != MMSYSERR_NOERROR)
; 190  :             goto lerror;
; 191  : 
; 192  :         /* seek to the beginning */
; 193  :         wfioSeek(pwfio, 0, SEEK_CUR);
; 194  :   }
; 195  :   else
; 196  :   {
; 197  :       /* open the file for write */
; 198  :       pwfio->m_hmmio = mmioOpen((LPSTR)szFile, NULL, MMIO_READWRITE|MMIO_CREATE|MMIO_ALLOCBUF/*|MMIO_DENYWRITE*/);
; 199  :       if(pwfio->m_hmmio == NULL)
; 200  :       {
; 201  :           lr = MMSYSERR_ERROR;
; 202  :           goto lerror;
; 203  :       }
; 204  : 
; 205  :       lr = wfioWriteHeaders(pwfio, pFormat, cbFormat);
; 206  :       if(lr != MMSYSERR_NOERROR)
; 207  :           goto lerror;
; 208  :   }
; 209  : 
; 210  : #endif /* WFIO_NO_WIN32 */
; 211  : 
; 212  :   return MMSYSERR_NOERROR;

  000c8	33 c0		 xor	 eax, eax
  000ca	eb 0c		 jmp	 SHORT $L18290
$lerror$18299:

; 213  : 
; 214  : lerror:
; 215  :   wfioClose(pwfio);

  000cc	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 _wfioClose@4

; 216  :   return lr;

  000d5	8b 45 fc	 mov	 eax, DWORD PTR _lr$[ebp]
$L18290:

; 217  : }

  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c2 14 00	 ret	 20			; 00000014H
_wfioOpen@20 ENDP
WMADEC	ENDS
EXTRN	_fclose:NEAR
; Function compile flags: /Odt
;	COMDAT _wfioClose@4
WMADEC	SEGMENT
_pwfio$ = 8
_wfioClose@4 PROC NEAR					; COMDAT

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 223  :     if(pwfio == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  00007	75 05		 jne	 SHORT $L18310

; 224  :         return;

  00009	e9 92 00 00 00	 jmp	 $L18308
$L18310:

; 225  : 
; 226  : #if WFIO_NO_WIN32
; 227  : 
; 228  :     if(pwfio->m_fpWav)

  0000e	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00011	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00015	74 35		 je	 SHORT $L18311

; 229  :     {
; 230  :         if(pwfio->m_mode == wfioModeWrite)

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  0001a	83 39 01	 cmp	 DWORD PTR [ecx], 1
  0001d	75 0b		 jne	 SHORT $L18312

; 231  :             wfioCleanUpWrite(pwfio);

  0001f	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 _wfioCleanUpWrite@4

; 232  :         else

  00028	eb 09		 jmp	 SHORT $L18313
$L18312:

; 233  :             wfioCleanUpRead(pwfio);

  0002a	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _wfioCleanUpRead@4
$L18313:

; 234  : 
; 235  :         fclose(pwfio->m_fpWav);

  00033	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00036	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 _fclose
  0003f	83 c4 04	 add	 esp, 4

; 236  :         pwfio->m_fpWav = NULL;

  00042	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00045	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L18311:

; 237  :     }
; 238  : 
; 239  :     if(pwfio->m_pFormat)

  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  0004f	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00053	74 23		 je	 SHORT $L18315

; 240  :     {
; 241  :         free(pwfio->m_pFormat);

  00055	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00058	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _free
  00061	83 c4 04	 add	 esp, 4

; 242  :         pwfio->m_pFormat = NULL;

  00064	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00067	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 243  : 
; 244  :         pwfio->m_sizeFormat = 0;

  0006e	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00071	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
$L18315:

; 245  :     }
; 246  : 
; 247  :     pwfio->m_sizeData = 0;

  00078	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0007b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 248  :     pwfio->m_posDataStart = 0;

  00082	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00085	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 249  : 
; 250  :     /* just for the safety... */
; 251  :     pwfio->m_posRiffLength = 0;

  0008c	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0008f	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 252  :     pwfio->m_posDataLength = 0;

  00096	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00099	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
$L18308:

; 253  : 
; 254  : #else  /* WFIO_NO_WIN32 */
; 255  : 
; 256  :     if(pwfio->m_hmmio)
; 257  :     {
; 258  :         if(pwfio->m_mode == wfioModeWrite)
; 259  :             wfioCleanUpWrite(pwfio);
; 260  :         else
; 261  :             wfioCleanUpRead(pwfio);
; 262  : 
; 263  :         mmioClose(pwfio->m_hmmio, 0);
; 264  :         pwfio->m_hmmio = NULL;
; 265  :     }
; 266  : 
; 267  :     if(pwfio->m_pFormat)
; 268  :     {
; 269  :         free(pwfio->m_pFormat);
; 270  :         pwfio->m_pFormat = NULL;
; 271  : 
; 272  :         pwfio->m_sizeFormat = 0;
; 273  :     }
; 274  : 
; 275  :     pwfio->m_sizeData = 0;
; 276  :     pwfio->m_posDataStart = 0;
; 277  : 
; 278  :     /* just for safety... */
; 279  :     memset(&pwfio->m_mmioinfo, 0, sizeof(pwfio->m_mmioinfo));
; 280  :     memset(&pwfio->m_ckWave, 0, sizeof(pwfio->m_ckWave));
; 281  :     memset(&pwfio->m_ck, 0, sizeof(pwfio->m_ck));
; 282  : 
; 283  : #endif /* WFIO_NO_WIN32 */
; 284  : }

  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
_wfioClose@4 ENDP
WMADEC	ENDS
EXTRN	_fseek:NEAR
; Function compile flags: /Odt
;	COMDAT _wfioSeek@12
WMADEC	SEGMENT
tv66 = -4
_pwfio$ = 8
_position$ = 12
_origin$ = 16
_wfioSeek@12 PROC NEAR					; COMDAT

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 292  :     if(pwfio == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  00008	75 08		 jne	 SHORT $L18325

; 293  :         return -1;

  0000a	83 c8 ff	 or	 eax, -1
  0000d	e9 81 00 00 00	 jmp	 $L18323
$L18325:

; 294  : 
; 295  :     /* only for reading... */
; 296  :     if(pwfio->m_mode != wfioModeRead)

  00012	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00015	83 38 00	 cmp	 DWORD PTR [eax], 0
  00018	74 05		 je	 SHORT $L18326

; 297  :         return -1;

  0001a	83 c8 ff	 or	 eax, -1
  0001d	eb 74		 jmp	 SHORT $L18323
$L18326:

; 298  : 
; 299  : #if WFIO_NO_WIN32
; 300  : 
; 301  :     switch(origin)
; 302  :     {

  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _origin$[ebp]
  00022	89 4d fc	 mov	 DWORD PTR tv66[ebp], ecx
  00025	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00029	74 0e		 je	 SHORT $L18331
  0002b	83 7d fc 01	 cmp	 DWORD PTR tv66[ebp], 1
  0002f	74 25		 je	 SHORT $L18332
  00031	83 7d fc 02	 cmp	 DWORD PTR tv66[ebp], 2
  00035	74 36		 je	 SHORT $L18333
  00037	eb 57		 jmp	 SHORT $L18328
$L18331:

; 303  :     case SEEK_SET:
; 304  :         return fseek(pwfio->m_fpWav, pwfio->m_posDataStart + position, SEEK_SET);

  00039	6a 00		 push	 0
  0003b	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0003e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00041	03 45 0c	 add	 eax, DWORD PTR _position$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00048	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 _fseek
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	eb 3d		 jmp	 SHORT $L18323
$L18332:

; 305  : 
; 306  :     case SEEK_CUR:
; 307  :         return fseek(pwfio->m_fpWav, position, SEEK_CUR);

  00056	6a 01		 push	 1
  00058	8b 45 0c	 mov	 eax, DWORD PTR _position$[ebp]
  0005b	50		 push	 eax
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  0005f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 _fseek
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	eb 26		 jmp	 SHORT $L18323
$L18333:

; 308  : 
; 309  :     case SEEK_END:
; 310  :         return fseek(pwfio->m_fpWav, pwfio->m_posDataStart + pwfio->m_sizeData - position, SEEK_SET);

  0006d	6a 00		 push	 0
  0006f	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00072	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00075	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00078	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  0007b	2b 4d 0c	 sub	 ecx, DWORD PTR _position$[ebp]
  0007e	51		 push	 ecx
  0007f	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00082	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 _fseek
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008e	eb 03		 jmp	 SHORT $L18323
$L18328:

; 311  :     }
; 312  : 
; 313  : #else  /* WFIO_NO_WIN32 */
; 314  : 
; 315  :     switch(origin)
; 316  :     {
; 317  :     case SEEK_SET:
; 318  :         return mmioSeek(pwfio->m_hmmio, pwfio->m_posDataStart + position, SEEK_SET);
; 319  : 
; 320  :     case SEEK_CUR:
; 321  :         return mmioSeek(pwfio->m_hmmio, position, SEEK_CUR);
; 322  : 
; 323  :     case SEEK_END:
; 324  :         return mmioSeek(pwfio->m_hmmio, pwfio->m_posDataStart + pwfio->m_sizeData - position, SEEK_SET);
; 325  :     }
; 326  : 
; 327  : #endif /* WFIO_NO_WIN32 */
; 328  : 
; 329  :   return -1;

  00090	83 c8 ff	 or	 eax, -1
$L18323:

; 330  : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 0c 00	 ret	 12			; 0000000cH
_wfioSeek@12 ENDP
WMADEC	ENDS
PUBLIC	_wfioRead@12
EXTRN	_fread:NEAR
; Function compile flags: /Odt
;	COMDAT _wfioRead@12
WMADEC	SEGMENT
_ret$ = -4
_pwfio$ = 8
_pBuf$ = 12
_cbBuf$ = 16
_wfioRead@12 PROC NEAR					; COMDAT

; 337  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 338  : #if WFIO_NO_WIN32
; 339  : 
; 340  :     size_t ret;
; 341  : 
; 342  :     if(pwfio == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  00008	75 05		 jne	 SHORT $L18343

; 343  :         return (I32)-1;

  0000a	83 c8 ff	 or	 eax, -1
  0000d	eb 70		 jmp	 SHORT $L18340
$L18343:

; 344  : 
; 345  :     if(pwfio->m_fpWav == NULL
; 346  :        || pwfio->m_mode != wfioModeRead
; 347  :        || pBuf == NULL)

  0000f	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00012	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00016	74 0e		 je	 SHORT $L18348
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  0001b	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0001e	75 06		 jne	 SHORT $L18348
  00020	83 7d 0c 00	 cmp	 DWORD PTR _pBuf$[ebp], 0
  00024	75 05		 jne	 SHORT $L18347
$L18348:

; 348  :         return (I32)-1;

  00026	83 c8 ff	 or	 eax, -1
  00029	eb 54		 jmp	 SHORT $L18340
$L18347:

; 349  : 
; 350  :     /* in alignment units... */
; 351  :     cbBuf = (cbBuf/pwfio->m_pFormat->nBlockAlign)*pwfio->m_pFormat->nBlockAlign;

  0002b	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0002e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00031	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00035	8b 45 10	 mov	 eax, DWORD PTR _cbBuf$[ebp]
  00038	99		 cdq
  00039	f7 f9		 idiv	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0003e	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00041	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00045	0f af c2	 imul	 eax, edx
  00048	89 45 10	 mov	 DWORD PTR _cbBuf$[ebp], eax

; 352  : 
; 353  : #if !WFIO_LITTLE_ENDIAN
; 354  : 
; 355  :     /* have to swap bytes... */
; 356  : 
; 357  :     if(pwfio->m_pFormat->wBitsPerSample == 16)
; 358  :     {
; 359  :         I32 i;
; 360  :         U16 *p = (U16 *)pBuf;
; 361  :         for(i = cbBuf/2; i > 0; i--, p++)
; 362  :             *p = adjustByteOrder16(*p);
; 363  :     }
; 364  : 
; 365  : #endif  /* WFIO_LITTLE_ENDIAN */
; 366  : 
; 367  :     ret = fread(pBuf, 1, cbBuf, pwfio->m_fpWav);

  0004b	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0004e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00051	51		 push	 ecx
  00052	8b 55 10	 mov	 edx, DWORD PTR _cbBuf$[ebp]
  00055	52		 push	 edx
  00056	6a 01		 push	 1
  00058	8b 45 0c	 mov	 eax, DWORD PTR _pBuf$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _fread
  00061	83 c4 10	 add	 esp, 16			; 00000010H
  00064	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 368  :     if(ferror(pwfio->m_fpWav))

  00067	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  0006a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0006d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00070	83 e0 20	 and	 eax, 32			; 00000020H
  00073	85 c0		 test	 eax, eax
  00075	74 05		 je	 SHORT $L18350

; 369  :         return (I32)-1;

  00077	83 c8 ff	 or	 eax, -1
  0007a	eb 03		 jmp	 SHORT $L18340
$L18350:

; 370  : 
; 371  :     return (I32)ret;

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
$L18340:

; 372  : 
; 373  : #else  /* WFIO_NO_WIN32 */
; 374  : 
; 375  :     if(pwfio == NULL)
; 376  :         return (I32)-1;
; 377  : 
; 378  :     return mmioRead(pwfio->m_hmmio, (HPSTR)pBuf, cbBuf);
; 379  : 
; 380  : #endif /* WFIO_NO_WIN32 */
; 381  : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 0c 00	 ret	 12			; 0000000cH
_wfioRead@12 ENDP
WMADEC	ENDS
PUBLIC	_wfioWrite@12
EXTRN	_fwrite:NEAR
; Function compile flags: /Odt
;	COMDAT _wfioWrite@12
WMADEC	SEGMENT
_ret$ = -4
_pwfio$ = 8
_pBuf$ = 12
_cbBuf$ = 16
_wfioWrite@12 PROC NEAR					; COMDAT

; 388  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 389  : #if WFIO_NO_WIN32
; 390  : 
; 391  :     size_t ret;
; 392  : 
; 393  :     if(pwfio == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  00008	75 05		 jne	 SHORT $L18362

; 394  :         return (I32)-1;

  0000a	83 c8 ff	 or	 eax, -1
  0000d	eb 7f		 jmp	 SHORT $L18359
$L18362:

; 395  : 
; 396  :     if(pwfio->m_fpWav == NULL
; 397  :        || pwfio->m_mode != wfioModeWrite
; 398  :        || pBuf == NULL)

  0000f	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00012	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00016	74 0e		 je	 SHORT $L18367
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  0001b	83 39 01	 cmp	 DWORD PTR [ecx], 1
  0001e	75 06		 jne	 SHORT $L18367
  00020	83 7d 0c 00	 cmp	 DWORD PTR _pBuf$[ebp], 0
  00024	75 05		 jne	 SHORT $L18366
$L18367:

; 399  :         return (I32)-1;

  00026	83 c8 ff	 or	 eax, -1
  00029	eb 63		 jmp	 SHORT $L18359
$L18366:

; 400  : 
; 401  :     /* in alignment units... */
; 402  :     cbBuf = (cbBuf/pwfio->m_pFormat->nBlockAlign)*pwfio->m_pFormat->nBlockAlign;

  0002b	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0002e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00031	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00035	8b 45 10	 mov	 eax, DWORD PTR _cbBuf$[ebp]
  00038	99		 cdq
  00039	f7 f9		 idiv	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0003e	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00041	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00045	0f af c2	 imul	 eax, edx
  00048	89 45 10	 mov	 DWORD PTR _cbBuf$[ebp], eax

; 403  : 
; 404  : #if !WFIO_LITTLE_ENDIAN
; 405  : 
; 406  :     /* have to swap bytes... */
; 407  : 
; 408  :     if(pwfio->m_pFormat->wBitsPerSample == 16)
; 409  :     {
; 410  :         I32 i;
; 411  :         U16 *p = (U16 *)pBuf;
; 412  :         for(i = cbBuf/2; i > 0; i--, p++)
; 413  :             *p = adjustByteOrder16(*p);
; 414  :     }
; 415  : 
; 416  : #endif  /* WFIO_LITTLE_ENDIAN */
; 417  : 
; 418  :     ret = fwrite(pBuf, 1, cbBuf, pwfio->m_fpWav);

  0004b	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0004e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00051	51		 push	 ecx
  00052	8b 55 10	 mov	 edx, DWORD PTR _cbBuf$[ebp]
  00055	52		 push	 edx
  00056	6a 01		 push	 1
  00058	8b 45 0c	 mov	 eax, DWORD PTR _pBuf$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _fwrite
  00061	83 c4 10	 add	 esp, 16			; 00000010H
  00064	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 419  :     if(ferror(pwfio->m_fpWav))

  00067	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  0006a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0006d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00070	83 e0 20	 and	 eax, 32			; 00000020H
  00073	85 c0		 test	 eax, eax
  00075	74 05		 je	 SHORT $L18369

; 420  :         return (I32)-1;

  00077	83 c8 ff	 or	 eax, -1
  0007a	eb 12		 jmp	 SHORT $L18359
$L18369:

; 421  : 
; 422  :     pwfio->m_sizeData += ret;

  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  0007f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00082	03 55 fc	 add	 edx, DWORD PTR _ret$[ebp]
  00085	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00088	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 423  : 
; 424  :     return ret;

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
$L18359:

; 425  : 
; 426  : #else  /* WFIO_NO_WIN32 */
; 427  : 
; 428  :     /* buffered write (MMIO_ALLOCBUF used for opening) */
; 429  : 
; 430  :     I32 lr;
; 431  :     I32 cbBlock;
; 432  :     I32 cbWritten = 0;
; 433  : 
; 434  :     if(pwfio == NULL)
; 435  :         return (I32)-1;
; 436  : 
; 437  :     if(pBuf == NULL)
; 438  :         return 0;
; 439  : 
; 440  :     while(cbBuf > 0)
; 441  :     {
; 442  :         /* check if we need to advance to the next buffer */
; 443  :         if(pwfio->m_mmioinfo.pchNext == pwfio->m_mmioinfo.pchEndWrite)
; 444  :         {
; 445  :             pwfio->m_mmioinfo.dwFlags |= MMIO_DIRTY;
; 446  :             lr = mmioAdvance(pwfio->m_hmmio, &pwfio->m_mmioinfo, MMIO_WRITE);
; 447  :             if(lr != MMSYSERR_NOERROR)
; 448  :                 goto lerror;
; 449  :         }
; 450  : 
; 451  :         /* copy in blocks */
; 452  :         cbBlock = pwfio->m_mmioinfo.pchEndWrite - pwfio->m_mmioinfo.pchNext;
; 453  :         if(cbBlock > cbBuf)
; 454  :             cbBlock = cbBuf;
; 455  :         CopyMemory(pwfio->m_mmioinfo.pchNext, pBuf, cbBlock);
; 456  : 
; 457  :         /* update pointers and counters */
; 458  :         pBuf                      += cbBlock;
; 459  :         pwfio->m_mmioinfo.pchNext += cbBlock;
; 460  :         cbWritten                 += cbBlock;
; 461  :         cbBuf                     -= cbBlock;
; 462  : 
; 463  :         /* update global stat members */
; 464  :         pwfio->m_sizeData += cbBlock;
; 465  :     }
; 466  : 
; 467  : lerror:
; 468  :     return cbWritten;
; 469  : 
; 470  : #endif /* WFIO_NO_WIN32 */
; 471  : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 0c 00	 ret	 12			; 0000000cH
_wfioWrite@12 ENDP
WMADEC	ENDS
PUBLIC	_wfioGetFormat@4
; Function compile flags: /Odt
;	COMDAT _wfioGetFormat@4
WMADEC	SEGMENT
_pwfio$ = 8
_wfioGetFormat@4 PROC NEAR				; COMDAT

; 476  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 477  :     if(pwfio == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  00007	75 04		 jne	 SHORT $L18375

; 478  :         return NULL;

  00009	33 c0		 xor	 eax, eax
  0000b	eb 06		 jmp	 SHORT $L18373
$L18375:

; 479  : 
; 480  :     return pwfio->m_pFormat;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00010	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
$L18373:

; 481  : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
_wfioGetFormat@4 ENDP
WMADEC	ENDS
PUBLIC	_wfioGetFormatLength@4
; Function compile flags: /Odt
;	COMDAT _wfioGetFormatLength@4
WMADEC	SEGMENT
_pwfio$ = 8
_wfioGetFormatLength@4 PROC NEAR			; COMDAT

; 486  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 487  :     if(pwfio == NULL || pwfio->m_pFormat == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  00007	74 09		 je	 SHORT $L18383
  00009	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0000c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00010	75 04		 jne	 SHORT $L18382
$L18383:

; 488  :         return 0;

  00012	33 c0		 xor	 eax, eax
  00014	eb 0d		 jmp	 SHORT $L18379
$L18382:

; 489  : 
; 490  :     return sizeof(WAVEFORMATEX) + pwfio->m_pFormat->cbSize;

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00019	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0001c	0f b7 42 10	 movzx	 eax, WORD PTR [edx+16]
  00020	83 c0 12	 add	 eax, 18			; 00000012H
$L18379:

; 491  : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
_wfioGetFormatLength@4 ENDP
WMADEC	ENDS
PUBLIC	_wfioGetSampleSize@4
; Function compile flags: /Odt
;	COMDAT _wfioGetSampleSize@4
WMADEC	SEGMENT
_pwfio$ = 8
_wfioGetSampleSize@4 PROC NEAR				; COMDAT

; 496  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 497  :     if(pwfio == NULL || pwfio->m_pFormat == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  00007	74 09		 je	 SHORT $L18391
  00009	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0000c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00010	75 04		 jne	 SHORT $L18390
$L18391:

; 498  :         return 0;

  00012	33 c0		 xor	 eax, eax
  00014	eb 0a		 jmp	 SHORT $L18387
$L18390:

; 499  : 
; 500  :     return pwfio->m_pFormat->nBlockAlign;

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00019	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0001c	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
$L18387:

; 501  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
_wfioGetSampleSize@4 ENDP
WMADEC	ENDS
PUBLIC	_wfioGetDataLength@4
; Function compile flags: /Odt
;	COMDAT _wfioGetDataLength@4
WMADEC	SEGMENT
_pwfio$ = 8
_wfioGetDataLength@4 PROC NEAR				; COMDAT

; 506  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 507  :     if(pwfio == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  00007	75 04		 jne	 SHORT $L18396

; 508  :         return 0;

  00009	33 c0		 xor	 eax, eax
  0000b	eb 06		 jmp	 SHORT $L18394
$L18396:

; 509  : 
; 510  :     return pwfio->m_sizeData;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00010	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
$L18394:

; 511  : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
_wfioGetDataLength@4 ENDP
WMADEC	ENDS
PUBLIC	_wfioGetMode@4
; Function compile flags: /Odt
;	COMDAT _wfioGetMode@4
WMADEC	SEGMENT
_pwfio$ = 8
_wfioGetMode@4 PROC NEAR				; COMDAT

; 516  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 517  :     if(pwfio == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  00007	75 04		 jne	 SHORT $L18401

; 518  :         return 0;

  00009	33 c0		 xor	 eax, eax
  0000b	eb 05		 jmp	 SHORT $L18399
$L18401:

; 519  : 
; 520  :     return pwfio->m_mode;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00010	8b 00		 mov	 eax, DWORD PTR [eax]
$L18399:

; 521  : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
_wfioGetMode@4 ENDP
WMADEC	ENDS
PUBLIC	_wfioIsOpened@4
; Function compile flags: /Odt
;	COMDAT _wfioIsOpened@4
WMADEC	SEGMENT
tv67 = -4
_pwfio$ = 8
_wfioIsOpened@4 PROC NEAR				; COMDAT

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 527  : #if WFIO_NO_WIN32
; 528  :     return pwfio && pwfio->m_fpWav != NULL;

  00004	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  00008	74 12		 je	 SHORT $L18711
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0000d	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00011	74 09		 je	 SHORT $L18711
  00013	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  0001a	eb 07		 jmp	 SHORT $L18712
$L18711:
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$L18712:
  00023	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]

; 529  : #else   /* WFIO_NO_WIN32 */
; 530  :     return pwfio && pwfio->m_hmmio != NULL;
; 531  : #endif  /* WFIO_NO_WIN32 */
; 532  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
_wfioIsOpened@4 ENDP
WMADEC	ENDS
EXTRN	_memset:NEAR
; Function compile flags: /Odt
;	COMDAT _wfioReadHeaders@4
WMADEC	SEGMENT
_fDataChunkFound$ = -36
_ret$ = -32
_dwHead$ = -28
_offset$ = -24
_offSeek$ = -20
_dwSize$ = -16
_fFmtChunkFound$ = -12
_lr$ = -8
_dwTemp$ = -4
_pwfio$ = 8
_wfioReadHeaders@4 PROC NEAR				; COMDAT

; 537  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 538  :     I32 lr;
; 539  :     Bool fFmtChunkFound  = WMAB_FALSE;  

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fFmtChunkFound$[ebp], 0

; 540  :     Bool fDataChunkFound = WMAB_FALSE;

  0000d	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _fDataChunkFound$[ebp], 0

; 541  :     
; 542  : #if WFIO_NO_WIN32
; 543  :     
; 544  :     size_t ret;
; 545  :     size_t offset = 0;

  00014	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _offset$[ebp], 0

; 546  :     size_t offSeek;
; 547  :     
; 548  :     U32 dwTemp;
; 549  :     U32 dwSize;
; 550  :     U32 dwHead;
; 551  :     
; 552  :     if(pwfio == NULL)

  0001b	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  0001f	75 0c		 jne	 SHORT $L18419

; 553  :     {
; 554  :         lr = MMSYSERR_ERROR;

  00021	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 555  :         goto lerror;

  00028	e9 50 04 00 00	 jmp	 $lerror$18420
$L18419:

; 556  :     }
; 557  :     
; 558  :     if(pwfio->m_fpWav == NULL)

  0002d	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	75 0c		 jne	 SHORT $L18422

; 559  :     {
; 560  :         lr = MMSYSERR_ERROR;

  00036	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 561  :         goto lerror;

  0003d	e9 3b 04 00 00	 jmp	 $lerror$18420
$L18422:

; 562  :     }
; 563  :     
; 564  :     /* -----------------------------------------------------------------------
; 565  :     * find the RIFF/WAVE chunk
; 566  :     */
; 567  :     
; 568  :     /* read "RIFF" */
; 569  :     
; 570  :     ret = fread(&dwHead, 1, sizeof(U32), pwfio->m_fpWav);

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00045	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00048	52		 push	 edx
  00049	6a 04		 push	 4
  0004b	6a 01		 push	 1
  0004d	8d 45 e4	 lea	 eax, DWORD PTR _dwHead$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _fread
  00056	83 c4 10	 add	 esp, 16			; 00000010H
  00059	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 571  :     if(ret != sizeof(U32))

  0005c	83 7d e0 04	 cmp	 DWORD PTR _ret$[ebp], 4
  00060	74 0c		 je	 SHORT $L18425

; 572  :     {
; 573  :         lr = MMSYSERR_READERROR;

  00062	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 16	; 00000010H

; 574  :         goto lerror;

  00069	e9 0f 04 00 00	 jmp	 $lerror$18420
$L18425:

; 575  :     }
; 576  :     offset += ret;

  0006e	8b 4d e8	 mov	 ecx, DWORD PTR _offset$[ebp]
  00071	03 4d e0	 add	 ecx, DWORD PTR _ret$[ebp]
  00074	89 4d e8	 mov	 DWORD PTR _offset$[ebp], ecx

; 577  :     
; 578  :     if(dwHead != WFIO_FOURCC_RIFF)

  00077	81 7d e4 52 49
	46 46		 cmp	 DWORD PTR _dwHead$[ebp], 1179011410 ; 46464952H
  0007e	74 0c		 je	 SHORT $L18434

; 579  :     {
; 580  :         lr = MMSYSERR_ERROR;

  00080	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 581  :         goto lerror;

  00087	e9 f1 03 00 00	 jmp	 $lerror$18420
$L18434:

; 582  :     }
; 583  :     
; 584  :     /* read "RIFF" length */
; 585  :     
; 586  :     pwfio->m_posRiffLength = offset;

  0008c	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0008f	8b 45 e8	 mov	 eax, DWORD PTR _offset$[ebp]
  00092	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 587  :     
; 588  :     ret = fread(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);

  00095	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00098	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0009b	52		 push	 edx
  0009c	6a 04		 push	 4
  0009e	6a 01		 push	 1
  000a0	8d 45 fc	 lea	 eax, DWORD PTR _dwTemp$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _fread
  000a9	83 c4 10	 add	 esp, 16			; 00000010H
  000ac	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 589  :     if(ret != sizeof(U32))

  000af	83 7d e0 04	 cmp	 DWORD PTR _ret$[ebp], 4
  000b3	74 0c		 je	 SHORT $L18437

; 590  :     {
; 591  :         lr = MMSYSERR_READERROR;

  000b5	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 16	; 00000010H

; 592  :         goto lerror;

  000bc	e9 bc 03 00 00	 jmp	 $lerror$18420
$L18437:

; 593  :     }
; 594  :     offset += ret;

  000c1	8b 4d e8	 mov	 ecx, DWORD PTR _offset$[ebp]
  000c4	03 4d e0	 add	 ecx, DWORD PTR _ret$[ebp]
  000c7	89 4d e8	 mov	 DWORD PTR _offset$[ebp], ecx

; 595  :     dwSize = adjustByteOrder32(dwTemp); //Ignored

  000ca	8b 55 fc	 mov	 edx, DWORD PTR _dwTemp$[ebp]
  000cd	52		 push	 edx
  000ce	e8 00 00 00 00	 call	 _adjustByteOrder32@4
  000d3	89 45 f0	 mov	 DWORD PTR _dwSize$[ebp], eax

; 596  :     
; 597  :     /* read "WAVE" */
; 598  :     
; 599  :     ret = fread(&dwHead, 1, sizeof(U32), pwfio->m_fpWav);

  000d6	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  000d9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000dc	51		 push	 ecx
  000dd	6a 04		 push	 4
  000df	6a 01		 push	 1
  000e1	8d 55 e4	 lea	 edx, DWORD PTR _dwHead$[ebp]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 _fread
  000ea	83 c4 10	 add	 esp, 16			; 00000010H
  000ed	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 600  :     if(ret != sizeof(U32))

  000f0	83 7d e0 04	 cmp	 DWORD PTR _ret$[ebp], 4
  000f4	74 0c		 je	 SHORT $L18440

; 601  :     {
; 602  :         lr = MMSYSERR_READERROR;

  000f6	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 16	; 00000010H

; 603  :         goto lerror;

  000fd	e9 7b 03 00 00	 jmp	 $lerror$18420
$L18440:

; 604  :     }
; 605  :     offset += ret;

  00102	8b 45 e8	 mov	 eax, DWORD PTR _offset$[ebp]
  00105	03 45 e0	 add	 eax, DWORD PTR _ret$[ebp]
  00108	89 45 e8	 mov	 DWORD PTR _offset$[ebp], eax

; 606  :     
; 607  :     if(dwHead != WFIO_FOURCC_WAVE)

  0010b	81 7d e4 57 41
	56 45		 cmp	 DWORD PTR _dwHead$[ebp], 1163280727 ; 45564157H
  00112	74 0c		 je	 SHORT $L18449

; 608  :     {
; 609  :         lr = MMSYSERR_ERROR;

  00114	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 610  :         goto lerror;

  0011b	e9 5d 03 00 00	 jmp	 $lerror$18420
$L18449:

; 611  :     }
; 612  :     
; 613  :     offSeek = offset;

  00120	8b 4d e8	 mov	 ecx, DWORD PTR _offset$[ebp]
  00123	89 4d ec	 mov	 DWORD PTR _offSeek$[ebp], ecx

; 614  :     
; 615  :     /* -----------------------------------------------------------------------
; 616  :     * find the FMT chunk: skip over unknown chunks
; 617  :     */
; 618  :     
; 619  :     /* read "fmt " */
; 620  :     fFmtChunkFound = WMAB_FALSE;  

  00126	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fFmtChunkFound$[ebp], 0
$L18450:

; 621  :     do {
; 622  :         // Read chunk header
; 623  :         ret = fread(&dwHead, 1, sizeof(U32), pwfio->m_fpWav);

  0012d	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00130	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00133	50		 push	 eax
  00134	6a 04		 push	 4
  00136	6a 01		 push	 1
  00138	8d 4d e4	 lea	 ecx, DWORD PTR _dwHead$[ebp]
  0013b	51		 push	 ecx
  0013c	e8 00 00 00 00	 call	 _fread
  00141	83 c4 10	 add	 esp, 16			; 00000010H
  00144	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 624  :         if(ret != sizeof(U32))

  00147	83 7d e0 04	 cmp	 DWORD PTR _ret$[ebp], 4
  0014b	74 0c		 je	 SHORT $L18455

; 625  :         {
; 626  :             lr = MMSYSERR_READERROR;

  0014d	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 16	; 00000010H

; 627  :             goto lerror;

  00154	e9 24 03 00 00	 jmp	 $lerror$18420
$L18455:

; 628  :         }
; 629  :         offset += ret;

  00159	8b 55 e8	 mov	 edx, DWORD PTR _offset$[ebp]
  0015c	03 55 e0	 add	 edx, DWORD PTR _ret$[ebp]
  0015f	89 55 e8	 mov	 DWORD PTR _offset$[ebp], edx

; 630  :         
; 631  :         if(dwHead == WFIO_FOURCC_fmt)

  00162	81 7d e4 66 6d
	74 20		 cmp	 DWORD PTR _dwHead$[ebp], 544501094 ; 20746d66H
  00169	75 07		 jne	 SHORT $L18464

; 632  :             fFmtChunkFound = WMAB_TRUE;

  0016b	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _fFmtChunkFound$[ebp], 1
$L18464:

; 633  :         
; 634  :         /* read chunk length */
; 635  :         ret = fread(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);

  00172	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00175	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00178	51		 push	 ecx
  00179	6a 04		 push	 4
  0017b	6a 01		 push	 1
  0017d	8d 55 fc	 lea	 edx, DWORD PTR _dwTemp$[ebp]
  00180	52		 push	 edx
  00181	e8 00 00 00 00	 call	 _fread
  00186	83 c4 10	 add	 esp, 16			; 00000010H
  00189	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 636  :         if(ret != sizeof(U32))

  0018c	83 7d e0 04	 cmp	 DWORD PTR _ret$[ebp], 4
  00190	74 0c		 je	 SHORT $L18467

; 637  :         {
; 638  :             lr = MMSYSERR_READERROR;

  00192	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 16	; 00000010H

; 639  :             goto lerror;

  00199	e9 df 02 00 00	 jmp	 $lerror$18420
$L18467:

; 640  :         }
; 641  :         offset += ret;

  0019e	8b 45 e8	 mov	 eax, DWORD PTR _offset$[ebp]
  001a1	03 45 e0	 add	 eax, DWORD PTR _ret$[ebp]
  001a4	89 45 e8	 mov	 DWORD PTR _offset$[ebp], eax

; 642  :         
; 643  :         dwSize = adjustByteOrder32(dwTemp);

  001a7	8b 4d fc	 mov	 ecx, DWORD PTR _dwTemp$[ebp]
  001aa	51		 push	 ecx
  001ab	e8 00 00 00 00	 call	 _adjustByteOrder32@4
  001b0	89 45 f0	 mov	 DWORD PTR _dwSize$[ebp], eax

; 644  :         if (!fFmtChunkFound) {

  001b3	83 7d f4 00	 cmp	 DWORD PTR _fFmtChunkFound$[ebp], 0
  001b7	75 33		 jne	 SHORT $L18451

; 645  :             /* read-off dwSize bytes */
; 646  :             offset += dwSize;

  001b9	8b 55 e8	 mov	 edx, DWORD PTR _offset$[ebp]
  001bc	03 55 f0	 add	 edx, DWORD PTR _dwSize$[ebp]
  001bf	89 55 e8	 mov	 DWORD PTR _offset$[ebp], edx

; 647  :             ret = fseek(pwfio->m_fpWav, offset, SEEK_SET);

  001c2	6a 00		 push	 0
  001c4	8b 45 e8	 mov	 eax, DWORD PTR _offset$[ebp]
  001c7	50		 push	 eax
  001c8	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  001cb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001ce	52		 push	 edx
  001cf	e8 00 00 00 00	 call	 _fseek
  001d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d7	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 648  :             if ( ret ) {

  001da	83 7d e0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  001de	74 0c		 je	 SHORT $L18451

; 649  :                 lr = MMSYSERR_READERROR;

  001e0	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 16	; 00000010H

; 650  :                 goto lerror;

  001e7	e9 91 02 00 00	 jmp	 $lerror$18420
$L18451:

; 651  :             } 
; 652  :         }  
; 653  :     } while (!fFmtChunkFound);

  001ec	83 7d f4 00	 cmp	 DWORD PTR _fFmtChunkFound$[ebp], 0
  001f0	0f 84 37 ff ff
	ff		 je	 $L18450

; 654  :     
; 655  :     /* "fmt " length was read earlier */
; 656  :     /* prepare the format buffer */
; 657  :     
; 658  :     pwfio->m_sizeFormat = dwSize;

  001f6	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  001f9	8b 4d f0	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  001fc	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 659  :     if(pwfio->m_sizeFormat < sizeof(WAVEFORMATEX))

  001ff	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00202	83 7a 14 12	 cmp	 DWORD PTR [edx+20], 18	; 00000012H
  00206	73 0a		 jae	 SHORT $L18471

; 660  :         pwfio->m_sizeFormat = sizeof(WAVEFORMATEX);

  00208	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0020b	c7 40 14 12 00
	00 00		 mov	 DWORD PTR [eax+20], 18	; 00000012H
$L18471:

; 661  :     
; 662  :     pwfio->m_pFormat = (WAVEFORMATEX *)malloc(pwfio->m_sizeFormat);

  00212	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00215	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00218	52		 push	 edx
  00219	e8 00 00 00 00	 call	 _malloc
  0021e	83 c4 04	 add	 esp, 4
  00221	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00224	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 663  :     if(pwfio->m_pFormat == NULL)

  00227	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0022a	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  0022e	75 0c		 jne	 SHORT $L18475

; 664  :     {
; 665  :         lr = MMSYSERR_NOMEM;

  00230	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 7

; 666  :         goto lerror;

  00237	e9 41 02 00 00	 jmp	 $lerror$18420
$L18475:

; 667  :     }
; 668  :     memset(pwfio->m_pFormat, 0, pwfio->m_sizeFormat);

  0023c	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0023f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00242	51		 push	 ecx
  00243	6a 00		 push	 0
  00245	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00248	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0024b	50		 push	 eax
  0024c	e8 00 00 00 00	 call	 _memset
  00251	83 c4 0c	 add	 esp, 12			; 0000000cH

; 669  :     
; 670  :     /* read the format chunk */
; 671  :     
; 672  :     ret = fread(pwfio->m_pFormat, 1, dwSize, pwfio->m_fpWav);

  00254	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00257	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0025a	52		 push	 edx
  0025b	8b 45 f0	 mov	 eax, DWORD PTR _dwSize$[ebp]
  0025e	50		 push	 eax
  0025f	6a 01		 push	 1
  00261	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00264	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00267	52		 push	 edx
  00268	e8 00 00 00 00	 call	 _fread
  0026d	83 c4 10	 add	 esp, 16			; 00000010H
  00270	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 673  :     if(ret != dwSize)

  00273	8b 45 e0	 mov	 eax, DWORD PTR _ret$[ebp]
  00276	3b 45 f0	 cmp	 eax, DWORD PTR _dwSize$[ebp]
  00279	74 0c		 je	 SHORT $L18476

; 674  :     {
; 675  :         lr = MMSYSERR_READERROR;

  0027b	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 16	; 00000010H

; 676  :         goto lerror;

  00282	e9 f6 01 00 00	 jmp	 $lerror$18420
$L18476:

; 677  :     }
; 678  :     offset += ret;

  00287	8b 4d e8	 mov	 ecx, DWORD PTR _offset$[ebp]
  0028a	03 4d e0	 add	 ecx, DWORD PTR _ret$[ebp]
  0028d	89 4d e8	 mov	 DWORD PTR _offset$[ebp], ecx

; 679  :     
; 680  :     /* HongCho: I can convert the fields into the correct order here,
; 681  :     *          but since I don't know the layouts of all the possible
; 682  :     *          formats, only the fields in WAVEFORMATEX will be
; 683  :     *          converted.
; 684  :     */
; 685  :     
; 686  :     pwfio->m_pFormat->wFormatTag      = adjustByteOrder16(pwfio->m_pFormat->wFormatTag);

  00290	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00293	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00296	66 8b 08	 mov	 cx, WORD PTR [eax]
  00299	51		 push	 ecx
  0029a	e8 00 00 00 00	 call	 _adjustByteOrder16@4
  0029f	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  002a2	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  002a5	66 89 01	 mov	 WORD PTR [ecx], ax

; 687  :     pwfio->m_pFormat->nChannels       = adjustByteOrder16(pwfio->m_pFormat->nChannels);

  002a8	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  002ab	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  002ae	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  002b2	51		 push	 ecx
  002b3	e8 00 00 00 00	 call	 _adjustByteOrder16@4
  002b8	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  002bb	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  002be	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 688  :     pwfio->m_pFormat->nSamplesPerSec  = adjustByteOrder32(pwfio->m_pFormat->nSamplesPerSec);

  002c2	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  002c5	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  002c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002cb	51		 push	 ecx
  002cc	e8 00 00 00 00	 call	 _adjustByteOrder32@4
  002d1	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  002d4	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  002d7	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 689  :     pwfio->m_pFormat->nAvgBytesPerSec = adjustByteOrder32(pwfio->m_pFormat->nAvgBytesPerSec);

  002da	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  002dd	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  002e0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002e3	51		 push	 ecx
  002e4	e8 00 00 00 00	 call	 _adjustByteOrder32@4
  002e9	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  002ec	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  002ef	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 690  :     pwfio->m_pFormat->nBlockAlign     = adjustByteOrder16(pwfio->m_pFormat->nBlockAlign);

  002f2	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  002f5	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  002f8	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  002fc	51		 push	 ecx
  002fd	e8 00 00 00 00	 call	 _adjustByteOrder16@4
  00302	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00305	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00308	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 691  :     pwfio->m_pFormat->wBitsPerSample  = adjustByteOrder16(pwfio->m_pFormat->wBitsPerSample);

  0030c	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0030f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00312	66 8b 48 0e	 mov	 cx, WORD PTR [eax+14]
  00316	51		 push	 ecx
  00317	e8 00 00 00 00	 call	 _adjustByteOrder16@4
  0031c	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0031f	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00322	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 692  :     pwfio->m_pFormat->cbSize          = adjustByteOrder16(pwfio->m_pFormat->cbSize);

  00326	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00329	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0032c	66 8b 48 10	 mov	 cx, WORD PTR [eax+16]
  00330	51		 push	 ecx
  00331	e8 00 00 00 00	 call	 _adjustByteOrder16@4
  00336	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00339	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0033c	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 693  :     
; 694  : #if !WFIO_LITTLE_ENDIAN
; 695  :     /* only PCM for big-endian platforms */
; 696  :     if(pwfio->m_pFormat->wFormatTag != WAVE_FORMAT_PCM)
; 697  :     {
; 698  :         lr = MMSYSERR_ERROR;
; 699  :         goto lerror;
; 700  :     }
; 701  : #endif /* WFIO_LITTLE_ENDIAN */
; 702  :     
; 703  :     /* the format chunk for PCM on WAVE files are WAVEFORMAT */
; 704  :     if(pwfio->m_pFormat->wFormatTag == WAVE_FORMAT_PCM)

  00340	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00343	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00346	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00349	83 f9 01	 cmp	 ecx, 1
  0034c	75 0c		 jne	 SHORT $L18477

; 705  :         pwfio->m_pFormat->cbSize = 0;

  0034e	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00351	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00354	66 c7 40 10 00
	00		 mov	 WORD PTR [eax+16], 0
$L18477:

; 706  :     
; 707  :         /* -----------------------------------------------------------------------
; 708  :         * find the DATA chunk: skip over other unknown chunks
; 709  :     */
; 710  :     fDataChunkFound = WMAB_FALSE;

  0035a	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _fDataChunkFound$[ebp], 0
$L18478:

; 711  :     
; 712  :     do {  
; 713  :         /* Read Chunk Header */
; 714  :         ret = fread(&dwHead, 1, sizeof(U32), pwfio->m_fpWav);

  00361	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00364	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00367	52		 push	 edx
  00368	6a 04		 push	 4
  0036a	6a 01		 push	 1
  0036c	8d 45 e4	 lea	 eax, DWORD PTR _dwHead$[ebp]
  0036f	50		 push	 eax
  00370	e8 00 00 00 00	 call	 _fread
  00375	83 c4 10	 add	 esp, 16			; 00000010H
  00378	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 715  :         if(ret != sizeof(U32))

  0037b	83 7d e0 04	 cmp	 DWORD PTR _ret$[ebp], 4
  0037f	74 0c		 je	 SHORT $L18483

; 716  :         {
; 717  :             lr = MMSYSERR_READERROR;

  00381	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 16	; 00000010H

; 718  :             goto lerror;

  00388	e9 f0 00 00 00	 jmp	 $lerror$18420
$L18483:

; 719  :         }
; 720  :         offset += ret;

  0038d	8b 4d e8	 mov	 ecx, DWORD PTR _offset$[ebp]
  00390	03 4d e0	 add	 ecx, DWORD PTR _ret$[ebp]
  00393	89 4d e8	 mov	 DWORD PTR _offset$[ebp], ecx

; 721  :         
; 722  :         fDataChunkFound = (dwHead == WFIO_FOURCC_data);

  00396	33 d2		 xor	 edx, edx
  00398	81 7d e4 64 61
	74 61		 cmp	 DWORD PTR _dwHead$[ebp], 1635017060 ; 61746164H
  0039f	0f 94 c2	 sete	 dl
  003a2	89 55 dc	 mov	 DWORD PTR _fDataChunkFound$[ebp], edx

; 723  :         
; 724  :         if (!fDataChunkFound)

  003a5	83 7d dc 00	 cmp	 DWORD PTR _fDataChunkFound$[ebp], 0
  003a9	75 71		 jne	 SHORT $L18479

; 725  :         {
; 726  :             /* Read chunk length */
; 727  :             ret = fread(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);

  003ab	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  003ae	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003b1	51		 push	 ecx
  003b2	6a 04		 push	 4
  003b4	6a 01		 push	 1
  003b6	8d 55 fc	 lea	 edx, DWORD PTR _dwTemp$[ebp]
  003b9	52		 push	 edx
  003ba	e8 00 00 00 00	 call	 _fread
  003bf	83 c4 10	 add	 esp, 16			; 00000010H
  003c2	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 728  :             if(ret != sizeof(U32))

  003c5	83 7d e0 04	 cmp	 DWORD PTR _ret$[ebp], 4
  003c9	74 0c		 je	 SHORT $L18495

; 729  :             {
; 730  :                 lr = MMSYSERR_READERROR;

  003cb	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 16	; 00000010H

; 731  :                 goto lerror;

  003d2	e9 a6 00 00 00	 jmp	 $lerror$18420
$L18495:

; 732  :             }
; 733  :             offset += ret;

  003d7	8b 45 e8	 mov	 eax, DWORD PTR _offset$[ebp]
  003da	03 45 e0	 add	 eax, DWORD PTR _ret$[ebp]
  003dd	89 45 e8	 mov	 DWORD PTR _offset$[ebp], eax

; 734  :             
; 735  :             dwSize = adjustByteOrder32(dwTemp);

  003e0	8b 4d fc	 mov	 ecx, DWORD PTR _dwTemp$[ebp]
  003e3	51		 push	 ecx
  003e4	e8 00 00 00 00	 call	 _adjustByteOrder32@4
  003e9	89 45 f0	 mov	 DWORD PTR _dwSize$[ebp], eax

; 736  :             offset += dwSize;

  003ec	8b 55 e8	 mov	 edx, DWORD PTR _offset$[ebp]
  003ef	03 55 f0	 add	 edx, DWORD PTR _dwSize$[ebp]
  003f2	89 55 e8	 mov	 DWORD PTR _offset$[ebp], edx

; 737  :             
; 738  :             // Unknown/ un-needed chunk. Skip over it.
; 739  :             /* read-off dwSize bytes */
; 740  :             ret = fseek(pwfio->m_fpWav, offset, SEEK_SET);

  003f5	6a 00		 push	 0
  003f7	8b 45 e8	 mov	 eax, DWORD PTR _offset$[ebp]
  003fa	50		 push	 eax
  003fb	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  003fe	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00401	52		 push	 edx
  00402	e8 00 00 00 00	 call	 _fseek
  00407	83 c4 0c	 add	 esp, 12			; 0000000cH
  0040a	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 741  :             if ( ret) {

  0040d	83 7d e0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00411	74 09		 je	 SHORT $L18479

; 742  :                 lr = MMSYSERR_READERROR;

  00413	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 16	; 00000010H

; 743  :                 goto lerror;

  0041a	eb 61		 jmp	 SHORT $lerror$18420
$L18479:

; 744  :             }
; 745  :         }
; 746  :     } while (!fDataChunkFound);

  0041c	83 7d dc 00	 cmp	 DWORD PTR _fDataChunkFound$[ebp], 0
  00420	0f 84 3b ff ff
	ff		 je	 $L18478

; 747  :     
; 748  :     /* read "data" length */
; 749  :     
; 750  :     pwfio->m_posDataLength = offset;

  00426	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00429	8b 4d e8	 mov	 ecx, DWORD PTR _offset$[ebp]
  0042c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 751  :     
; 752  :     ret = fread(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);

  0042f	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00432	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00435	50		 push	 eax
  00436	6a 04		 push	 4
  00438	6a 01		 push	 1
  0043a	8d 4d fc	 lea	 ecx, DWORD PTR _dwTemp$[ebp]
  0043d	51		 push	 ecx
  0043e	e8 00 00 00 00	 call	 _fread
  00443	83 c4 10	 add	 esp, 16			; 00000010H
  00446	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 753  :     if(ret != sizeof(U32))

  00449	83 7d e0 04	 cmp	 DWORD PTR _ret$[ebp], 4
  0044d	74 09		 je	 SHORT $L18499

; 754  :     {
; 755  :         lr = MMSYSERR_READERROR;

  0044f	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 16	; 00000010H

; 756  :         goto lerror;

  00456	eb 25		 jmp	 SHORT $lerror$18420
$L18499:

; 757  :     }
; 758  :     offset += ret;

  00458	8b 55 e8	 mov	 edx, DWORD PTR _offset$[ebp]
  0045b	03 55 e0	 add	 edx, DWORD PTR _ret$[ebp]
  0045e	89 55 e8	 mov	 DWORD PTR _offset$[ebp], edx

; 759  :     
; 760  :     pwfio->m_sizeData   = adjustByteOrder32(dwTemp);

  00461	8b 45 fc	 mov	 eax, DWORD PTR _dwTemp$[ebp]
  00464	50		 push	 eax
  00465	e8 00 00 00 00	 call	 _adjustByteOrder32@4
  0046a	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  0046d	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 761  :     
; 762  :     pwfio->m_posDataStart = offset;

  00470	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00473	8b 45 e8	 mov	 eax, DWORD PTR _offset$[ebp]
  00476	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 763  :     
; 764  : #else  /* WFIO_NO_WIN32 */
; 765  :     
; 766  :     MMCKINFO ck;
; 767  :     
; 768  :     U32 cksize;
; 769  :     
; 770  :     if(pwfio == NULL)
; 771  :     {
; 772  :         lr = MMSYSERR_ERROR;
; 773  :         goto lerror;
; 774  :     }
; 775  :     
; 776  :     if(pwfio->m_hmmio == NULL)
; 777  :     {
; 778  :         lr = MMSYSERR_ERROR;
; 779  :         goto lerror;
; 780  :     }
; 781  :     
; 782  :     /* find the wave info chunk */
; 783  :     pwfio->m_ckWave.fccType = WFIO_FOURCC_WAVE;
; 784  :     lr = mmioDescend(pwfio->m_hmmio, &pwfio->m_ckWave, NULL, MMIO_FINDRIFF);
; 785  :     if(lr != MMSYSERR_NOERROR)
; 786  :         goto lerror;
; 787  :     
; 788  :     /* find FMT chunk */
; 789  :     ck.ckid = WFIO_FOURCC_fmt;
; 790  :     lr = mmioDescend(pwfio->m_hmmio, &ck, &pwfio->m_ckWave, MMIO_FINDCHUNK);
; 791  :     if(lr != MMSYSERR_NOERROR)
; 792  :         goto lerror;
; 793  :     
; 794  :     cksize = ck.cksize;
; 795  :     if(cksize < sizeof(WAVEFORMATEX))
; 796  :         cksize = sizeof(WAVEFORMATEX);
; 797  :     
; 798  :     /* prepare the format buffer */
; 799  :     pwfio->m_sizeFormat = cksize;
; 800  :     pwfio->m_pFormat = (WAVEFORMATEX *)malloc(pwfio->m_sizeFormat);
; 801  :     if(pwfio->m_pFormat == NULL)
; 802  :     {
; 803  :         lr = MMSYSERR_NOMEM;
; 804  :         goto lerror;
; 805  :     }
; 806  :     memset(pwfio->m_pFormat, 0, pwfio->m_sizeFormat);
; 807  :     
; 808  :     /* read the format chunk */
; 809  :     lr = mmioRead(pwfio->m_hmmio, (HPSTR)pwfio->m_pFormat, ck.cksize);
; 810  :     if(lr != (I32)ck.cksize)
; 811  :     {
; 812  :         lr = MMSYSERR_READERROR;
; 813  :         goto lerror;
; 814  :     }
; 815  :     
; 816  :     /* the format chunk for PCM on WAV files are WAVEFORMAT */
; 817  :     if(pwfio->m_pFormat->wFormatTag == WAVE_FORMAT_PCM)
; 818  :         pwfio->m_pFormat->cbSize = 0;
; 819  :     
; 820  :     /* ascend out of FMT */
; 821  :     lr = mmioAscend(pwfio->m_hmmio, &ck, 0);
; 822  :     if(lr != MMSYSERR_NOERROR)
; 823  :         goto lerror;
; 824  :     
; 825  :     /* find DATA chunk */
; 826  :     pwfio->m_ck.ckid = WFIO_FOURCC_data;
; 827  :     lr = mmioDescend(pwfio->m_hmmio, &pwfio->m_ck, &pwfio->m_ckWave, MMIO_FINDCHUNK);
; 828  :     if(lr != MMSYSERR_NOERROR)
; 829  :         goto lerror;
; 830  :     
; 831  :     pwfio->m_sizeData     = pwfio->m_ck.cksize;
; 832  :     
; 833  :     pwfio->m_posDataStart = pwfio->m_ck.dwDataOffset;
; 834  :     
; 835  :     /* get info */
; 836  :     lr = mmioGetInfo(pwfio->m_hmmio, &pwfio->m_mmioinfo, 0);
; 837  :     if(lr != MMSYSERR_NOERROR)
; 838  :         goto lerror;
; 839  :     
; 840  : #endif /* WFIO_NO_WIN32 */
; 841  :     
; 842  :     return MMSYSERR_NOERROR;

  00479	33 c0		 xor	 eax, eax
  0047b	eb 2f		 jmp	 SHORT $L18408
$lerror$18420:

; 843  :     
; 844  : lerror:
; 845  :     if(pwfio->m_pFormat)

  0047d	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00480	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00484	74 23		 je	 SHORT $L18500

; 846  :     {
; 847  :         free(pwfio->m_pFormat);

  00486	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00489	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0048c	50		 push	 eax
  0048d	e8 00 00 00 00	 call	 _free
  00492	83 c4 04	 add	 esp, 4

; 848  :         pwfio->m_pFormat = NULL;

  00495	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00498	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 849  :         
; 850  :         pwfio->m_sizeFormat = 0;

  0049f	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  004a2	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
$L18500:

; 851  :     }
; 852  :     return lr;

  004a9	8b 45 f8	 mov	 eax, DWORD PTR _lr$[ebp]
$L18408:

; 853  : }

  004ac	8b e5		 mov	 esp, ebp
  004ae	5d		 pop	 ebp
  004af	c2 04 00	 ret	 4
_wfioReadHeaders@4 ENDP
WMADEC	ENDS
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt
;	COMDAT _wfioWriteHeaders@12
WMADEC	SEGMENT
_ret$ = -20
_offset$ = -16
_pWavFormat$ = -12
_lr$ = -8
_dwTemp$ = -4
_pwfio$ = 8
_pFormat$ = 12
_cbFormat$ = 16
_wfioWriteHeaders@12 PROC NEAR				; COMDAT

; 860  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 861  :     I32 lr;
; 862  : 
; 863  : #if WFIO_NO_WIN32
; 864  : 
; 865  :     size_t ret;
; 866  :     size_t offset = 0;

  00006	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _offset$[ebp], 0

; 867  : 
; 868  :     U32 dwTemp;
; 869  : 
; 870  :     WAVEFORMATEX *pWavFormat = NULL;

  0000d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pWavFormat$[ebp], 0

; 871  : 
; 872  :     if(pwfio == NULL)

  00014	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  00018	75 0c		 jne	 SHORT $L18516

; 873  :     {
; 874  :         lr = MMSYSERR_ERROR;

  0001a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 875  :         goto lerror;

  00021	e9 91 03 00 00	 jmp	 $lerror$18517
$L18516:

; 876  :     }
; 877  : 
; 878  :     if(pwfio->m_fpWav == NULL)

  00026	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00029	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002d	75 0c		 jne	 SHORT $L18519

; 879  :     {
; 880  :         lr = MMSYSERR_ERROR;

  0002f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 881  :         goto lerror;

  00036	e9 7c 03 00 00	 jmp	 $lerror$18517
$L18519:

; 882  :     }
; 883  :     if(pFormat == NULL)

  0003b	83 7d 0c 00	 cmp	 DWORD PTR _pFormat$[ebp], 0
  0003f	75 0c		 jne	 SHORT $L18521

; 884  :     {
; 885  :         lr = MMSYSERR_ERROR;

  00041	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 886  :         goto lerror;

  00048	e9 6a 03 00 00	 jmp	 $lerror$18517
$L18521:

; 887  :     }
; 888  :     if(cbFormat < sizeof(WAVEFORMATEX))

  0004d	83 7d 10 12	 cmp	 DWORD PTR _cbFormat$[ebp], 18 ; 00000012H
  00051	73 0c		 jae	 SHORT $L18523

; 889  :     {
; 890  :         lr = MMSYSERR_ERROR;

  00053	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 891  :         goto lerror;

  0005a	e9 58 03 00 00	 jmp	 $lerror$18517
$L18523:

; 892  :     }
; 893  : 
; 894  :     /* copy the format locally */
; 895  : 
; 896  :     if(pwfio->m_pFormat)

  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00062	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00066	74 23		 je	 SHORT $L18524

; 897  :     {
; 898  :         free(pwfio->m_pFormat);

  00068	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0006b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _free
  00074	83 c4 04	 add	 esp, 4

; 899  :         pwfio->m_pFormat = NULL;

  00077	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  0007a	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 900  : 
; 901  :         pwfio->m_sizeFormat = 0;

  00081	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00084	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
$L18524:

; 902  :     }
; 903  :     pwfio->m_sizeFormat = cbFormat;

  0008b	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0008e	8b 4d 10	 mov	 ecx, DWORD PTR _cbFormat$[ebp]
  00091	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 904  :     pwfio->m_pFormat = (WAVEFORMATEX *)malloc(pwfio->m_sizeFormat);

  00094	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00097	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _malloc
  000a0	83 c4 04	 add	 esp, 4
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  000a6	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 905  :     if(pwfio->m_pFormat == NULL)

  000a9	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  000ac	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  000b0	75 0c		 jne	 SHORT $L18528

; 906  :     {
; 907  :         lr = MMSYSERR_NOMEM;

  000b2	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 7

; 908  :         goto lerror;

  000b9	e9 f9 02 00 00	 jmp	 $lerror$18517
$L18528:

; 909  :     }
; 910  :     memcpy(pwfio->m_pFormat, pFormat, pwfio->m_sizeFormat);

  000be	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  000c1	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000c4	51		 push	 ecx
  000c5	8b 55 0c	 mov	 edx, DWORD PTR _pFormat$[ebp]
  000c8	52		 push	 edx
  000c9	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  000cc	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000cf	51		 push	 ecx
  000d0	e8 00 00 00 00	 call	 _memcpy
  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 911  : 
; 912  :     /* format in the right format... */
; 913  :     pWavFormat = (WAVEFORMATEX *)malloc(pwfio->m_sizeFormat);

  000d8	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  000db	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 _malloc
  000e4	83 c4 04	 add	 esp, 4
  000e7	89 45 f4	 mov	 DWORD PTR _pWavFormat$[ebp], eax

; 914  :     if(pWavFormat == NULL)

  000ea	83 7d f4 00	 cmp	 DWORD PTR _pWavFormat$[ebp], 0
  000ee	75 0c		 jne	 SHORT $L18531

; 915  :     {
; 916  :         lr = MMSYSERR_NOMEM;

  000f0	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 7

; 917  :         goto lerror;

  000f7	e9 bb 02 00 00	 jmp	 $lerror$18517
$L18531:

; 918  :     }
; 919  :     memcpy(pWavFormat, pFormat, pwfio->m_sizeFormat);

  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  000ff	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00102	52		 push	 edx
  00103	8b 45 0c	 mov	 eax, DWORD PTR _pFormat$[ebp]
  00106	50		 push	 eax
  00107	8b 4d f4	 mov	 ecx, DWORD PTR _pWavFormat$[ebp]
  0010a	51		 push	 ecx
  0010b	e8 00 00 00 00	 call	 _memcpy
  00110	83 c4 0c	 add	 esp, 12			; 0000000cH

; 920  : 
; 921  : #if !WFIO_LITTLE_ENDIAN
; 922  :     /* only PCM for big-endian platforms... */
; 923  :     if(pFormat->wFormatTag != WAVE_FORMAT_PCM)
; 924  :     {
; 925  :         lr = MMSYSERR_ERROR;
; 926  :         goto lerror;
; 927  :     }
; 928  : #endif /* WFIO_LITTLE_ENDIAN */
; 929  : 
; 930  :     pWavFormat->wFormatTag      = adjustByteOrder16(pWavFormat->wFormatTag);

  00113	8b 55 f4	 mov	 edx, DWORD PTR _pWavFormat$[ebp]
  00116	66 8b 02	 mov	 ax, WORD PTR [edx]
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 _adjustByteOrder16@4
  0011f	8b 4d f4	 mov	 ecx, DWORD PTR _pWavFormat$[ebp]
  00122	66 89 01	 mov	 WORD PTR [ecx], ax

; 931  :     pWavFormat->nChannels       = adjustByteOrder16(pWavFormat->nChannels);

  00125	8b 55 f4	 mov	 edx, DWORD PTR _pWavFormat$[ebp]
  00128	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 _adjustByteOrder16@4
  00132	8b 4d f4	 mov	 ecx, DWORD PTR _pWavFormat$[ebp]
  00135	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 932  :     pWavFormat->nSamplesPerSec  = adjustByteOrder32(pWavFormat->nSamplesPerSec);

  00139	8b 55 f4	 mov	 edx, DWORD PTR _pWavFormat$[ebp]
  0013c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _adjustByteOrder32@4
  00145	8b 4d f4	 mov	 ecx, DWORD PTR _pWavFormat$[ebp]
  00148	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 933  :     pWavFormat->nAvgBytesPerSec = adjustByteOrder32(pWavFormat->nAvgBytesPerSec);

  0014b	8b 55 f4	 mov	 edx, DWORD PTR _pWavFormat$[ebp]
  0014e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 _adjustByteOrder32@4
  00157	8b 4d f4	 mov	 ecx, DWORD PTR _pWavFormat$[ebp]
  0015a	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 934  :     pWavFormat->nBlockAlign     = adjustByteOrder16(pWavFormat->nBlockAlign);

  0015d	8b 55 f4	 mov	 edx, DWORD PTR _pWavFormat$[ebp]
  00160	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 _adjustByteOrder16@4
  0016a	8b 4d f4	 mov	 ecx, DWORD PTR _pWavFormat$[ebp]
  0016d	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 935  :     pWavFormat->wBitsPerSample  = adjustByteOrder16(pWavFormat->wBitsPerSample);

  00171	8b 55 f4	 mov	 edx, DWORD PTR _pWavFormat$[ebp]
  00174	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 _adjustByteOrder16@4
  0017e	8b 4d f4	 mov	 ecx, DWORD PTR _pWavFormat$[ebp]
  00181	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 936  :     pWavFormat->cbSize          = adjustByteOrder16(pWavFormat->cbSize);

  00185	8b 55 f4	 mov	 edx, DWORD PTR _pWavFormat$[ebp]
  00188	66 8b 42 10	 mov	 ax, WORD PTR [edx+16]
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 _adjustByteOrder16@4
  00192	8b 4d f4	 mov	 ecx, DWORD PTR _pWavFormat$[ebp]
  00195	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 937  : 
; 938  :     /* -----------------------------------------------------------------------
; 939  :      * create RIFF/WAVE chunk
; 940  :      */
; 941  : 
; 942  :     /* write "RIFF" */
; 943  : 
; 944  :     dwTemp = WFIO_FOURCC_RIFF;

  00199	c7 45 fc 52 49
	46 46		 mov	 DWORD PTR _dwTemp$[ebp], 1179011410 ; 46464952H

; 945  :     ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);

  001a0	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  001a3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001a6	50		 push	 eax
  001a7	6a 04		 push	 4
  001a9	6a 01		 push	 1
  001ab	8d 4d fc	 lea	 ecx, DWORD PTR _dwTemp$[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 _fwrite
  001b4	83 c4 10	 add	 esp, 16			; 00000010H
  001b7	89 45 ec	 mov	 DWORD PTR _ret$[ebp], eax

; 946  :     if(ret != sizeof(U32))

  001ba	83 7d ec 04	 cmp	 DWORD PTR _ret$[ebp], 4
  001be	74 0c		 je	 SHORT $L18542

; 947  :     {
; 948  :         lr = MMSYSERR_WRITEERROR;

  001c0	c7 45 f8 11 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 17	; 00000011H

; 949  :         goto lerror;

  001c7	e9 eb 01 00 00	 jmp	 $lerror$18517
$L18542:

; 950  :     }
; 951  :     offset += ret;

  001cc	8b 55 f0	 mov	 edx, DWORD PTR _offset$[ebp]
  001cf	03 55 ec	 add	 edx, DWORD PTR _ret$[ebp]
  001d2	89 55 f0	 mov	 DWORD PTR _offset$[ebp], edx

; 952  : 
; 953  :     /* write "RIFF" length, temporarily */
; 954  : 
; 955  :     pwfio->m_posRiffLength = offset;

  001d5	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  001d8	8b 4d f0	 mov	 ecx, DWORD PTR _offset$[ebp]
  001db	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 956  : 
; 957  :     dwTemp = 0;   /* temporary */

  001de	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwTemp$[ebp], 0

; 958  :     ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);

  001e5	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  001e8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001eb	50		 push	 eax
  001ec	6a 04		 push	 4
  001ee	6a 01		 push	 1
  001f0	8d 4d fc	 lea	 ecx, DWORD PTR _dwTemp$[ebp]
  001f3	51		 push	 ecx
  001f4	e8 00 00 00 00	 call	 _fwrite
  001f9	83 c4 10	 add	 esp, 16			; 00000010H
  001fc	89 45 ec	 mov	 DWORD PTR _ret$[ebp], eax

; 959  :     if(ret != sizeof(U32))

  001ff	83 7d ec 04	 cmp	 DWORD PTR _ret$[ebp], 4
  00203	74 0c		 je	 SHORT $L18545

; 960  :     {
; 961  :         lr = MMSYSERR_WRITEERROR;

  00205	c7 45 f8 11 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 17	; 00000011H

; 962  :         goto lerror;

  0020c	e9 a6 01 00 00	 jmp	 $lerror$18517
$L18545:

; 963  :     }
; 964  :     offset += ret;

  00211	8b 55 f0	 mov	 edx, DWORD PTR _offset$[ebp]
  00214	03 55 ec	 add	 edx, DWORD PTR _ret$[ebp]
  00217	89 55 f0	 mov	 DWORD PTR _offset$[ebp], edx

; 965  : 
; 966  :     /* write "WAVE" */
; 967  : 
; 968  :     dwTemp = WFIO_FOURCC_WAVE;

  0021a	c7 45 fc 57 41
	56 45		 mov	 DWORD PTR _dwTemp$[ebp], 1163280727 ; 45564157H

; 969  :     ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);

  00221	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00224	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00227	51		 push	 ecx
  00228	6a 04		 push	 4
  0022a	6a 01		 push	 1
  0022c	8d 55 fc	 lea	 edx, DWORD PTR _dwTemp$[ebp]
  0022f	52		 push	 edx
  00230	e8 00 00 00 00	 call	 _fwrite
  00235	83 c4 10	 add	 esp, 16			; 00000010H
  00238	89 45 ec	 mov	 DWORD PTR _ret$[ebp], eax

; 970  :     if(ret != sizeof(U32))

  0023b	83 7d ec 04	 cmp	 DWORD PTR _ret$[ebp], 4
  0023f	74 0c		 je	 SHORT $L18556

; 971  :     {
; 972  :         lr = MMSYSERR_WRITEERROR;

  00241	c7 45 f8 11 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 17	; 00000011H

; 973  :         goto lerror;

  00248	e9 6a 01 00 00	 jmp	 $lerror$18517
$L18556:

; 974  :     }
; 975  :     offset += ret;

  0024d	8b 45 f0	 mov	 eax, DWORD PTR _offset$[ebp]
  00250	03 45 ec	 add	 eax, DWORD PTR _ret$[ebp]
  00253	89 45 f0	 mov	 DWORD PTR _offset$[ebp], eax

; 976  : 
; 977  :     /* -----------------------------------------------------------------------
; 978  :      * create FMT chunk
; 979  :      */
; 980  : 
; 981  :     /* write "fmt " */
; 982  : 
; 983  :     dwTemp = WFIO_FOURCC_fmt;

  00256	c7 45 fc 66 6d
	74 20		 mov	 DWORD PTR _dwTemp$[ebp], 544501094 ; 20746d66H

; 984  :     ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);

  0025d	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00260	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00263	52		 push	 edx
  00264	6a 04		 push	 4
  00266	6a 01		 push	 1
  00268	8d 45 fc	 lea	 eax, DWORD PTR _dwTemp$[ebp]
  0026b	50		 push	 eax
  0026c	e8 00 00 00 00	 call	 _fwrite
  00271	83 c4 10	 add	 esp, 16			; 00000010H
  00274	89 45 ec	 mov	 DWORD PTR _ret$[ebp], eax

; 985  :     if(ret != sizeof(U32))

  00277	83 7d ec 04	 cmp	 DWORD PTR _ret$[ebp], 4
  0027b	74 0c		 je	 SHORT $L18567

; 986  :     {
; 987  :         lr = MMSYSERR_WRITEERROR;

  0027d	c7 45 f8 11 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 17	; 00000011H

; 988  :         goto lerror;

  00284	e9 2e 01 00 00	 jmp	 $lerror$18517
$L18567:

; 989  :     }
; 990  :     offset += ret;

  00289	8b 4d f0	 mov	 ecx, DWORD PTR _offset$[ebp]
  0028c	03 4d ec	 add	 ecx, DWORD PTR _ret$[ebp]
  0028f	89 4d f0	 mov	 DWORD PTR _offset$[ebp], ecx

; 991  : 
; 992  :     /* write "fmt " length */
; 993  : 
; 994  :     dwTemp = adjustByteOrder32(cbFormat);

  00292	8b 55 10	 mov	 edx, DWORD PTR _cbFormat$[ebp]
  00295	52		 push	 edx
  00296	e8 00 00 00 00	 call	 _adjustByteOrder32@4
  0029b	89 45 fc	 mov	 DWORD PTR _dwTemp$[ebp], eax

; 995  :     ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);

  0029e	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  002a1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002a4	51		 push	 ecx
  002a5	6a 04		 push	 4
  002a7	6a 01		 push	 1
  002a9	8d 55 fc	 lea	 edx, DWORD PTR _dwTemp$[ebp]
  002ac	52		 push	 edx
  002ad	e8 00 00 00 00	 call	 _fwrite
  002b2	83 c4 10	 add	 esp, 16			; 00000010H
  002b5	89 45 ec	 mov	 DWORD PTR _ret$[ebp], eax

; 996  :     if(ret != sizeof(U32))

  002b8	83 7d ec 04	 cmp	 DWORD PTR _ret$[ebp], 4
  002bc	74 0c		 je	 SHORT $L18570

; 997  :     {
; 998  :         lr = MMSYSERR_WRITEERROR;

  002be	c7 45 f8 11 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 17	; 00000011H

; 999  :         goto lerror;

  002c5	e9 ed 00 00 00	 jmp	 $lerror$18517
$L18570:

; 1000 :     }
; 1001 :     offset += ret;

  002ca	8b 45 f0	 mov	 eax, DWORD PTR _offset$[ebp]
  002cd	03 45 ec	 add	 eax, DWORD PTR _ret$[ebp]
  002d0	89 45 f0	 mov	 DWORD PTR _offset$[ebp], eax

; 1002 : 
; 1003 :     /* write actual format */
; 1004 : 
; 1005 :     ret = fwrite(pWavFormat, 1, cbFormat, pwfio->m_fpWav);

  002d3	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  002d6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002d9	52		 push	 edx
  002da	8b 45 10	 mov	 eax, DWORD PTR _cbFormat$[ebp]
  002dd	50		 push	 eax
  002de	6a 01		 push	 1
  002e0	8b 4d f4	 mov	 ecx, DWORD PTR _pWavFormat$[ebp]
  002e3	51		 push	 ecx
  002e4	e8 00 00 00 00	 call	 _fwrite
  002e9	83 c4 10	 add	 esp, 16			; 00000010H
  002ec	89 45 ec	 mov	 DWORD PTR _ret$[ebp], eax

; 1006 :     if(ret != cbFormat)

  002ef	8b 55 ec	 mov	 edx, DWORD PTR _ret$[ebp]
  002f2	3b 55 10	 cmp	 edx, DWORD PTR _cbFormat$[ebp]
  002f5	74 0c		 je	 SHORT $L18571

; 1007 :     {
; 1008 :         lr = MMSYSERR_WRITEERROR;

  002f7	c7 45 f8 11 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 17	; 00000011H

; 1009 :         goto lerror;

  002fe	e9 b4 00 00 00	 jmp	 $lerror$18517
$L18571:

; 1010 :     }
; 1011 :     offset += ret;

  00303	8b 45 f0	 mov	 eax, DWORD PTR _offset$[ebp]
  00306	03 45 ec	 add	 eax, DWORD PTR _ret$[ebp]
  00309	89 45 f0	 mov	 DWORD PTR _offset$[ebp], eax

; 1012 : 
; 1013 :     /* -----------------------------------------------------------------------
; 1014 :      * create DATA chunk
; 1015 :      */
; 1016 : 
; 1017 :     /* write "data" */
; 1018 : 
; 1019 :     dwTemp = WFIO_FOURCC_data;

  0030c	c7 45 fc 64 61
	74 61		 mov	 DWORD PTR _dwTemp$[ebp], 1635017060 ; 61746164H

; 1020 :     ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);

  00313	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00316	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00319	52		 push	 edx
  0031a	6a 04		 push	 4
  0031c	6a 01		 push	 1
  0031e	8d 45 fc	 lea	 eax, DWORD PTR _dwTemp$[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 _fwrite
  00327	83 c4 10	 add	 esp, 16			; 00000010H
  0032a	89 45 ec	 mov	 DWORD PTR _ret$[ebp], eax

; 1021 :     if(ret != sizeof(U32))

  0032d	83 7d ec 04	 cmp	 DWORD PTR _ret$[ebp], 4
  00331	74 09		 je	 SHORT $L18582

; 1022 :     {
; 1023 :         lr = MMSYSERR_WRITEERROR;

  00333	c7 45 f8 11 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 17	; 00000011H

; 1024 :         goto lerror;

  0033a	eb 7b		 jmp	 SHORT $lerror$18517
$L18582:

; 1025 :     }
; 1026 :     offset += ret;

  0033c	8b 4d f0	 mov	 ecx, DWORD PTR _offset$[ebp]
  0033f	03 4d ec	 add	 ecx, DWORD PTR _ret$[ebp]
  00342	89 4d f0	 mov	 DWORD PTR _offset$[ebp], ecx

; 1027 : 
; 1028 :     /* write "data" length */
; 1029 : 
; 1030 :     pwfio->m_posDataLength = offset;

  00345	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00348	8b 45 f0	 mov	 eax, DWORD PTR _offset$[ebp]
  0034b	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 1031 : 
; 1032 :     dwTemp = 0;

  0034e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwTemp$[ebp], 0

; 1033 :     ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);

  00355	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00358	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0035b	52		 push	 edx
  0035c	6a 04		 push	 4
  0035e	6a 01		 push	 1
  00360	8d 45 fc	 lea	 eax, DWORD PTR _dwTemp$[ebp]
  00363	50		 push	 eax
  00364	e8 00 00 00 00	 call	 _fwrite
  00369	83 c4 10	 add	 esp, 16			; 00000010H
  0036c	89 45 ec	 mov	 DWORD PTR _ret$[ebp], eax

; 1034 :     if(ret != sizeof(U32))

  0036f	83 7d ec 04	 cmp	 DWORD PTR _ret$[ebp], 4
  00373	74 09		 je	 SHORT $L18585

; 1035 :     {
; 1036 :         lr = MMSYSERR_WRITEERROR;

  00375	c7 45 f8 11 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 17	; 00000011H

; 1037 :         goto lerror;

  0037c	eb 39		 jmp	 SHORT $lerror$18517
$L18585:

; 1038 :     }
; 1039 :     offset += ret;

  0037e	8b 4d f0	 mov	 ecx, DWORD PTR _offset$[ebp]
  00381	03 4d ec	 add	 ecx, DWORD PTR _ret$[ebp]
  00384	89 4d f0	 mov	 DWORD PTR _offset$[ebp], ecx

; 1040 : 
; 1041 :     pwfio->m_sizeData   = 0;

  00387	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0038a	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 1042 : 
; 1043 :     pwfio->m_posDataStart = offset;

  00391	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  00394	8b 4d f0	 mov	 ecx, DWORD PTR _offset$[ebp]
  00397	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 1044 : 
; 1045 :     if(pWavFormat)

  0039a	83 7d f4 00	 cmp	 DWORD PTR _pWavFormat$[ebp], 0
  0039e	74 13		 je	 SHORT $L18586

; 1046 :     {
; 1047 :         free(pWavFormat);

  003a0	8b 55 f4	 mov	 edx, DWORD PTR _pWavFormat$[ebp]
  003a3	52		 push	 edx
  003a4	e8 00 00 00 00	 call	 _free
  003a9	83 c4 04	 add	 esp, 4

; 1048 :         pWavFormat = NULL;

  003ac	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pWavFormat$[ebp], 0
$L18586:

; 1049 :     }
; 1050 : 
; 1051 :     return MMSYSERR_NOERROR;

  003b3	33 c0		 xor	 eax, eax
  003b5	eb 48		 jmp	 SHORT $L18508
$lerror$18517:

; 1052 : 
; 1053 : lerror:
; 1054 :     if(pwfio->m_pFormat)

  003b7	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  003ba	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  003be	74 23		 je	 SHORT $L18588

; 1055 :     {
; 1056 :         free(pwfio->m_pFormat);

  003c0	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  003c3	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  003c6	52		 push	 edx
  003c7	e8 00 00 00 00	 call	 _free
  003cc	83 c4 04	 add	 esp, 4

; 1057 :         pwfio->m_pFormat = NULL;

  003cf	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  003d2	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 1058 : 
; 1059 :         pwfio->m_sizeFormat = 0;

  003d9	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  003dc	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
$L18588:

; 1060 :     }
; 1061 : 
; 1062 :     if(pWavFormat)

  003e3	83 7d f4 00	 cmp	 DWORD PTR _pWavFormat$[ebp], 0
  003e7	74 13		 je	 SHORT $L18590

; 1063 :     {
; 1064 :         free(pWavFormat);

  003e9	8b 55 f4	 mov	 edx, DWORD PTR _pWavFormat$[ebp]
  003ec	52		 push	 edx
  003ed	e8 00 00 00 00	 call	 _free
  003f2	83 c4 04	 add	 esp, 4

; 1065 :         pWavFormat = NULL;

  003f5	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pWavFormat$[ebp], 0
$L18590:

; 1066 :     }
; 1067 : 
; 1068 :     return lr;

  003fc	8b 45 f8	 mov	 eax, DWORD PTR _lr$[ebp]
$L18508:

; 1069 : 
; 1070 : #else  /* WFIO_NO_WIN32 */
; 1071 : 
; 1072 :     if(pwfio == NULL)
; 1073 :     {
; 1074 :         lr = MMSYSERR_ERROR;
; 1075 :         goto lerror;
; 1076 :     }
; 1077 :     if(pwfio->m_hmmio == NULL)
; 1078 :     {
; 1079 :         lr = MMSYSERR_ERROR;
; 1080 :         goto lerror;
; 1081 :     }
; 1082 :     if(pwfio->m_mode != wfioModeWrite)
; 1083 :     {
; 1084 :         lr = MMSYSERR_ERROR;
; 1085 :         goto lerror;
; 1086 :     }
; 1087 :     if(pFormat == NULL)
; 1088 :     {
; 1089 :         lr = MMSYSERR_ERROR;
; 1090 :         goto lerror;
; 1091 :     }
; 1092 :     if(cbFormat < sizeof(WAVEFORMATEX))
; 1093 :     {
; 1094 :         lr = MMSYSERR_ERROR;
; 1095 :         goto lerror;
; 1096 :     }
; 1097 : 
; 1098 :     /* copy the format locally */
; 1099 :     if(pwfio->m_pFormat)
; 1100 :     {
; 1101 :         free(pwfio->m_pFormat);
; 1102 :         pwfio->m_pFormat = NULL;
; 1103 : 
; 1104 :         pwfio->m_sizeFormat = 0;
; 1105 :     }
; 1106 :     pwfio->m_sizeFormat = cbFormat;
; 1107 :     pwfio->m_pFormat = (WAVEFORMATEX *)malloc(pwfio->m_sizeFormat);
; 1108 :     if(pwfio->m_pFormat == NULL)
; 1109 :     {
; 1110 :         lr = MMSYSERR_NOMEM;
; 1111 :         goto lerror;
; 1112 :     }
; 1113 :     CopyMemory(pwfio->m_pFormat, pFormat, pwfio->m_sizeFormat);
; 1114 : 
; 1115 :     /* create WAVE chunk */
; 1116 :     pwfio->m_ckWave.fccType = WFIO_FOURCC_WAVE;
; 1117 :     pwfio->m_ckWave.cksize  = 0;
; 1118 :     lr = mmioCreateChunk(pwfio->m_hmmio, &pwfio->m_ckWave, MMIO_CREATERIFF);
; 1119 :     if(lr != MMSYSERR_NOERROR)
; 1120 :         goto lerror;
; 1121 : 
; 1122 :     /* create FMT chunk */
; 1123 :     pwfio->m_ck.ckid   = WFIO_FOURCC_fmt;
; 1124 :     pwfio->m_ck.cksize = pwfio->m_sizeFormat;
; 1125 :     lr = mmioCreateChunk(pwfio->m_hmmio, &pwfio->m_ck, 0);
; 1126 :     if(lr != MMSYSERR_NOERROR)
; 1127 :         goto lerror;
; 1128 : 
; 1129 :     /* copy out the format */
; 1130 :     lr = mmioWrite(pwfio->m_hmmio, (HPSTR)pwfio->m_pFormat, pwfio->m_sizeFormat);
; 1131 :     if(lr != (I32)pwfio->m_sizeFormat)
; 1132 :     {
; 1133 :         lr = MMSYSERR_WRITEERROR;
; 1134 :         goto lerror;
; 1135 :     }
; 1136 : 
; 1137 :     /* ascend out of FMT */
; 1138 :     lr = mmioAscend(pwfio->m_hmmio, &pwfio->m_ck, 0);
; 1139 :     if(lr != MMSYSERR_NOERROR)
; 1140 :         goto lerror;
; 1141 : 
; 1142 :     /* create DATA chunk */
; 1143 : 
; 1144 :     pwfio->m_ck.ckid   = WFIO_FOURCC_data;
; 1145 :     pwfio->m_ck.cksize = 0;
; 1146 :     lr = mmioCreateChunk(pwfio->m_hmmio, &pwfio->m_ck, 0);
; 1147 :     if(lr != MMSYSERR_NOERROR)
; 1148 :         goto lerror;
; 1149 : 
; 1150 :     /* get info */
; 1151 :     lr = mmioGetInfo(pwfio->m_hmmio, &pwfio->m_mmioinfo, 0);
; 1152 :     if(lr != MMSYSERR_NOERROR)
; 1153 :         goto lerror;
; 1154 : 
; 1155 :     if(pwfio->m_pFormat)
; 1156 :     {
; 1157 :         free(pwfio->m_pFormat);
; 1158 :         pwfio->m_pFormat = NULL;
; 1159 : 
; 1160 :         pwfio->m_sizeFormat = 0;
; 1161 :     }
; 1162 : 
; 1163 :     return MMSYSERR_NOERROR;
; 1164 : 
; 1165 : lerror:
; 1166 :     if(pwfio->m_pFormat)
; 1167 :     {
; 1168 :         free(pwfio->m_pFormat);
; 1169 :         pwfio->m_pFormat = NULL;
; 1170 : 
; 1171 :         pwfio->m_sizeFormat = 0;
; 1172 :     }
; 1173 :     return lr;
; 1174 : 
; 1175 : #endif /* WFIO_NO_WIN32 */
; 1176 : }

  003ff	8b e5		 mov	 esp, ebp
  00401	5d		 pop	 ebp
  00402	c2 0c 00	 ret	 12			; 0000000cH
_wfioWriteHeaders@12 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _wfioCleanUpRead@4
WMADEC	SEGMENT
_pwfio$ = 8
_wfioCleanUpRead@4 PROC NEAR				; COMDAT

; 1181 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1182 :     if(pwfio == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  00007	75 07		 jne	 SHORT $L18596

; 1183 :         return MMSYSERR_ERROR;

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	eb 02		 jmp	 SHORT $L18594
$L18596:

; 1184 : 
; 1185 :     /* for a historic reason... */
; 1186 :     return MMSYSERR_NOERROR;

  00010	33 c0		 xor	 eax, eax
$L18594:

; 1187 : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
_wfioCleanUpRead@4 ENDP
WMADEC	ENDS
EXTRN	_fflush:NEAR
; Function compile flags: /Odt
;	COMDAT _wfioCleanUpWrite@4
WMADEC	SEGMENT
_ret$ = -12
_lr$ = -8
_dwTemp$ = -4
_pwfio$ = 8
_wfioCleanUpWrite@4 PROC NEAR				; COMDAT

; 1192 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1193 :     I32 lr;
; 1194 : 
; 1195 : #if WFIO_NO_WIN32
; 1196 : 
; 1197 :     size_t ret;
; 1198 : 
; 1199 :     U32 dwTemp;
; 1200 : 
; 1201 :     if(pwfio == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _pwfio$[ebp], 0
  0000a	75 0c		 jne	 SHORT $L18604

; 1202 :     {
; 1203 :         lr = MMSYSERR_ERROR;

  0000c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 1204 :         goto lerror;

  00013	e9 25 01 00 00	 jmp	 $lerror$18605
$L18604:

; 1205 :     }
; 1206 :     if(pwfio->m_fpWav == NULL)

  00018	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0001b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001f	75 0c		 jne	 SHORT $L18607

; 1207 :     {
; 1208 :         lr = MMSYSERR_ERROR;

  00021	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 1209 :         goto lerror;

  00028	e9 10 01 00 00	 jmp	 $lerror$18605
$L18607:

; 1210 :     }
; 1211 :     if(pwfio->m_mode != wfioModeWrite)

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00030	83 39 01	 cmp	 DWORD PTR [ecx], 1
  00033	74 0c		 je	 SHORT $L18608

; 1212 :     {
; 1213 :         lr = MMSYSERR_ERROR;

  00035	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 1214 :         goto lerror;

  0003c	e9 fc 00 00 00	 jmp	 $lerror$18605
$L18608:

; 1215 :     }
; 1216 : 
; 1217 :     /* flush it first */
; 1218 : 
; 1219 :     fflush(pwfio->m_fpWav);

  00041	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00044	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _fflush
  0004d	83 c4 04	 add	 esp, 4

; 1220 : 
; 1221 :     /* write back the data length */
; 1222 : 
; 1223 :     ret = fseek(pwfio->m_fpWav, pwfio->m_posDataLength, SEEK_SET);

  00050	6a 00		 push	 0
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  00055	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 _fseek
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax

; 1224 :     if(ret != 0)

  0006b	83 7d f4 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0006f	74 0c		 je	 SHORT $L18609

; 1225 :     {
; 1226 :         lr = MMSYSERR_ERROR;

  00071	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 1227 :         goto lerror;

  00078	e9 c0 00 00 00	 jmp	 $lerror$18605
$L18609:

; 1228 :     }
; 1229 : 
; 1230 :     dwTemp = adjustByteOrder32(pwfio->m_sizeData);

  0007d	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00080	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _adjustByteOrder32@4
  00089	89 45 fc	 mov	 DWORD PTR _dwTemp$[ebp], eax

; 1231 :     ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  0008f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00092	52		 push	 edx
  00093	6a 04		 push	 4
  00095	6a 01		 push	 1
  00097	8d 45 fc	 lea	 eax, DWORD PTR _dwTemp$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _fwrite
  000a0	83 c4 10	 add	 esp, 16			; 00000010H
  000a3	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax

; 1232 :     if(ret != sizeof(U32))

  000a6	83 7d f4 04	 cmp	 DWORD PTR _ret$[ebp], 4
  000aa	74 0c		 je	 SHORT $L18612

; 1233 :     {
; 1234 :         lr = MMSYSERR_WRITEERROR;

  000ac	c7 45 f8 11 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 17	; 00000011H

; 1235 :         goto lerror;

  000b3	e9 85 00 00 00	 jmp	 $lerror$18605
$L18612:

; 1236 :     }
; 1237 : 
; 1238 :     /* write back the riff length */
; 1239 : 
; 1240 :     ret = fseek(pwfio->m_fpWav, pwfio->m_posRiffLength, SEEK_SET);

  000b8	6a 00		 push	 0
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  000bd	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000c0	52		 push	 edx
  000c1	8b 45 08	 mov	 eax, DWORD PTR _pwfio$[ebp]
  000c4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 _fseek
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d0	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax

; 1241 :     if(ret != 0)

  000d3	83 7d f4 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000d7	74 09		 je	 SHORT $L18613

; 1242 :     {
; 1243 :         lr = MMSYSERR_ERROR;

  000d9	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 1

; 1244 :         goto lerror;

  000e0	eb 5b		 jmp	 SHORT $lerror$18605
$L18613:

; 1245 :     }
; 1246 : 
; 1247 :     dwTemp = pwfio->m_sizeData + pwfio->m_posDataStart - 8; /* "RIFF" and its size (4 + 4 bytes) */

  000e2	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  000e5	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000e8	8b 4d 08	 mov	 ecx, DWORD PTR _pwfio$[ebp]
  000eb	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000ee	8d 44 10 f8	 lea	 eax, DWORD PTR [eax+edx-8]
  000f2	89 45 fc	 mov	 DWORD PTR _dwTemp$[ebp], eax

; 1248 :     dwTemp = adjustByteOrder32(dwTemp);

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _dwTemp$[ebp]
  000f8	51		 push	 ecx
  000f9	e8 00 00 00 00	 call	 _adjustByteOrder32@4
  000fe	89 45 fc	 mov	 DWORD PTR _dwTemp$[ebp], eax

; 1249 :     ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);

  00101	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  00104	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00107	50		 push	 eax
  00108	6a 04		 push	 4
  0010a	6a 01		 push	 1
  0010c	8d 4d fc	 lea	 ecx, DWORD PTR _dwTemp$[ebp]
  0010f	51		 push	 ecx
  00110	e8 00 00 00 00	 call	 _fwrite
  00115	83 c4 10	 add	 esp, 16			; 00000010H
  00118	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax

; 1250 :     if(ret != sizeof(U32))

  0011b	83 7d f4 04	 cmp	 DWORD PTR _ret$[ebp], 4
  0011f	74 09		 je	 SHORT $L18616

; 1251 :     {
; 1252 :         lr = MMSYSERR_WRITEERROR;

  00121	c7 45 f8 11 00
	00 00		 mov	 DWORD PTR _lr$[ebp], 17	; 00000011H

; 1253 :         goto lerror;

  00128	eb 13		 jmp	 SHORT $lerror$18605
$L18616:

; 1254 :     }
; 1255 : 
; 1256 :     /* flush again... */
; 1257 : 
; 1258 :     fflush(pwfio->m_fpWav);

  0012a	8b 55 08	 mov	 edx, DWORD PTR _pwfio$[ebp]
  0012d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 _fflush
  00136	83 c4 04	 add	 esp, 4

; 1259 : 
; 1260 : #else   /* WFIO_NO_WIN32 */
; 1261 : 
; 1262 :     if(pwfio == NULL)
; 1263 :     {
; 1264 :         lr = MMSYSERR_ERROR;
; 1265 :         goto lerror;
; 1266 :     }
; 1267 :     if(pwfio->m_hmmio == NULL)
; 1268 :     {
; 1269 :         lr = MMSYSERR_ERROR;
; 1270 :         goto lerror;
; 1271 :     }
; 1272 :     if(pwfio->m_mode != wfioModeWrite)
; 1273 :     {
; 1274 :         lr = MMSYSERR_ERROR;
; 1275 :         goto lerror;
; 1276 :     }
; 1277 : 
; 1278 :     /* write back the info */
; 1279 :     pwfio->m_mmioinfo.dwFlags |= MMIO_DIRTY;
; 1280 :     lr = mmioSetInfo(pwfio->m_hmmio, &pwfio->m_mmioinfo, 0);
; 1281 :     if(lr != MMSYSERR_NOERROR)
; 1282 :         goto lerror;
; 1283 : 
; 1284 :     /* ascend out of DATA.  this will cause the write-out. */
; 1285 :     lr = mmioAscend(pwfio->m_hmmio, &pwfio->m_ck, 0);
; 1286 :     if(lr != MMSYSERR_NOERROR)
; 1287 :         goto lerror;
; 1288 : 
; 1289 :     /* ascend out of RIFF.  this will cause the file write-out, probably. */
; 1290 :     lr = mmioAscend(pwfio->m_hmmio, &pwfio->m_ckWave, 0);
; 1291 :     if(lr != MMSYSERR_NOERROR)
; 1292 :         goto lerror;
; 1293 : 
; 1294 : #endif  /* WFIO_NO_WIN32 */
; 1295 : 
; 1296 :     return MMSYSERR_NOERROR;

  00139	33 c0		 xor	 eax, eax
  0013b	eb 03		 jmp	 SHORT $L18599
$lerror$18605:

; 1297 : 
; 1298 : lerror:
; 1299 :     return lr;

  0013d	8b 45 f8	 mov	 eax, DWORD PTR _lr$[ebp]
$L18599:

; 1300 : }

  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c2 04 00	 ret	 4
_wfioCleanUpWrite@4 ENDP
WMADEC	ENDS
END
