; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\hfregen.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EA@KDKEKBNK@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DP@DMDGPPCP@hHFRegenMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfLogAmp@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@KJODJPHM@pfOnsetPhase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfBeta?5?$CB@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxHFRegeneration@44
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxInitHFRegen@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxFreeHFRegen@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fComputeOnsetPhase@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fComputeBeta@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SC6Excitation@40
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_VoxHFRegeneration@44
PUBLIC	??_C@_0EA@KDKEKBNK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0DP@DMDGPPCP@hHFRegenMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfLogAmp@ ; `string'
PUBLIC	??_C@_0CH@KJODJPHM@pfOnsetPhase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfBeta?5?$CB@ ; `string'
PUBLIC	__real@3bc90fdb
PUBLIC	__real@3e22f983
PUBLIC	__real@40c90fdb
EXTRN	__assert:NEAR
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_0EA@KDKEKBNK@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\hfregen.c
CONST	SEGMENT
??_C@_0EA@KDKEKBNK@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\hfregen.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@DMDGPPCP@hHFRegenMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfLogAmp@
CONST	SEGMENT
??_C@_0DP@DMDGPPCP@hHFRegenMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfLogAmp@ DB 'h'
	DB	'HFRegenMblk != NULL && pfLogAmp != NULL && pfMinPhase != NULL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KJODJPHM@pfOnsetPhase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfBeta?5?$CB@
CONST	SEGMENT
??_C@_0CH@KJODJPHM@pfOnsetPhase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfBeta?5?$CB@ DB 'p'
	DB	'fOnsetPhase != NULL && pfBeta != NULL', 00H	; `string'
CONST	ENDS
;	COMDAT __real@3bc90fdb
CONST	SEGMENT
__real@3bc90fdb DD 03bc90fdbr			; 0.00613592
CONST	ENDS
;	COMDAT __real@3e22f983
CONST	SEGMENT
__real@3e22f983 DD 03e22f983r			; 0.159155
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxHFRegeneration@44
_TEXT	SEGMENT
_pHFRegenMblk$ = -24
_fDeltaPhase$ = -20
_ftmp$ = -16
_fOnsetPhase$ = -12
_fBeta$ = -8
_iMhat$ = -4
_hHFRegenMblk$ = 8
_pfVEVphase$ = 12
_fPitchDFT$ = 16
_pfLogAmp$ = 20
_pfMinPhase$ = 24
_iHarmonics$ = 28
_pfOnsetPhase$ = 32
_pfBeta$ = 36
_iSCRate$ = 40
_iSynSamples$ = 44
_iUpdatePhaseOffsetFlag$ = 48
_VoxHFRegeneration@44 PROC NEAR				; COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 162  :    HFRegenStruct *pHFRegenMblk = (HFRegenStruct*) hHFRegenMblk;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hHFRegenMblk$[ebp]
  00009	89 45 e8	 mov	 DWORD PTR _pHFRegenMblk$[ebp], eax

; 163  : 
; 164  :    int   iMhat;
; 165  : 
; 166  :    float fOnsetPhase;
; 167  :    float fBeta;
; 168  :    float fDeltaPhase;
; 169  :    float ftmp;
; 170  : 
; 171  :    assert(hHFRegenMblk != NULL && pfLogAmp != NULL && pfMinPhase != NULL);

  0000c	83 7d 08 00	 cmp	 DWORD PTR _hHFRegenMblk$[ebp], 0
  00010	74 0c		 je	 SHORT $L1494
  00012	83 7d 14 00	 cmp	 DWORD PTR _pfLogAmp$[ebp], 0
  00016	74 06		 je	 SHORT $L1494
  00018	83 7d 18 00	 cmp	 DWORD PTR _pfMinPhase$[ebp], 0
  0001c	75 17		 jne	 SHORT $L1495
$L1494:
  0001e	68 ab 00 00 00	 push	 171			; 000000abH
  00023	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@KDKEKBNK@c?3?2xbox?2private?2windows?2directx?2@
  00028	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DMDGPPCP@hHFRegenMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfLogAmp@
  0002d	e8 00 00 00 00	 call	 __assert
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1495:

; 172  :    assert(pfOnsetPhase != NULL && pfBeta != NULL);

  00035	83 7d 20 00	 cmp	 DWORD PTR _pfOnsetPhase$[ebp], 0
  00039	74 06		 je	 SHORT $L1496
  0003b	83 7d 24 00	 cmp	 DWORD PTR _pfBeta$[ebp], 0
  0003f	75 17		 jne	 SHORT $L1497
$L1496:
  00041	68 ac 00 00 00	 push	 172			; 000000acH
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@KDKEKBNK@c?3?2xbox?2private?2windows?2directx?2@
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@KJODJPHM@pfOnsetPhase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfBeta?5?$CB@
  00050	e8 00 00 00 00	 call	 __assert
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1497:

; 173  :    
; 174  :    /*------------------------------------------------------------------------
; 175  :      Compute the onset phase for 3kb/s using quadratic prediction
; 176  :    ------------------------------------------------------------------------*/
; 177  :    if(iSCRate == SC_RATE_3K)

  00058	83 7d 28 01	 cmp	 DWORD PTR _iSCRate$[ebp], 1
  0005c	75 2b		 jne	 SHORT $L1364

; 178  :    {
; 179  :       /*---------------------------------------------------------------------
; 180  :         Apply quadratic phase projection
; 181  :       ---------------------------------------------------------------------*/
; 182  :       fDeltaPhase =  0.5F*TWOPIONFFT*(fPitchDFT+pHFRegenMblk->fPitchDFT_1)
; 183  :                      *iSynSamples;

  0005e	8b 45 e8	 mov	 eax, DWORD PTR _pHFRegenMblk$[ebp]
  00061	d9 45 10	 fld	 DWORD PTR _fPitchDFT$[ebp]
  00064	d8 40 10	 fadd	 DWORD PTR [eax+16]
  00067	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3bc90fdb
  0006d	da 4d 2c	 fimul	 DWORD PTR _iSynSamples$[ebp]
  00070	d9 5d ec	 fstp	 DWORD PTR _fDeltaPhase$[ebp]

; 184  :       fOnsetPhase = pHFRegenMblk->fOnsetPhase_1 + fDeltaPhase;

  00073	8b 4d e8	 mov	 ecx, DWORD PTR _pHFRegenMblk$[ebp]
  00076	d9 45 ec	 fld	 DWORD PTR _fDeltaPhase$[ebp]
  00079	d8 01		 fadd	 DWORD PTR [ecx]
  0007b	d9 5d f4	 fstp	 DWORD PTR _fOnsetPhase$[ebp]

; 185  : 
; 186  :       /*---------------------------------------------------------------------
; 187  :         Use previous Beta value for consistency
; 188  :       ---------------------------------------------------------------------*/
; 189  :       fBeta = pHFRegenMblk->fBeta_1;

  0007e	8b 55 e8	 mov	 edx, DWORD PTR _pHFRegenMblk$[ebp]
  00081	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00084	89 45 f8	 mov	 DWORD PTR _fBeta$[ebp], eax

; 190  : 
; 191  :    } else {

  00087	eb 2d		 jmp	 SHORT $L1366
$L1364:

; 192  : 
; 193  :       SC6Excitation( STACK_S pHFRegenMblk, iHarmonics, fPitchDFT, iSynSamples, 
; 194  :                      iUpdatePhaseOffsetFlag, pfLogAmp, pfMinPhase, pfVEVphase, 
; 195  :                      &fOnsetPhase, &fBeta);

  00089	8d 4d f8	 lea	 ecx, DWORD PTR _fBeta$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 55 f4	 lea	 edx, DWORD PTR _fOnsetPhase$[ebp]
  00090	52		 push	 edx
  00091	8b 45 0c	 mov	 eax, DWORD PTR _pfVEVphase$[ebp]
  00094	50		 push	 eax
  00095	8b 4d 18	 mov	 ecx, DWORD PTR _pfMinPhase$[ebp]
  00098	51		 push	 ecx
  00099	8b 55 14	 mov	 edx, DWORD PTR _pfLogAmp$[ebp]
  0009c	52		 push	 edx
  0009d	8b 45 30	 mov	 eax, DWORD PTR _iUpdatePhaseOffsetFlag$[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d 2c	 mov	 ecx, DWORD PTR _iSynSamples$[ebp]
  000a4	51		 push	 ecx
  000a5	8b 55 10	 mov	 edx, DWORD PTR _fPitchDFT$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 1c	 mov	 eax, DWORD PTR _iHarmonics$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d e8	 mov	 ecx, DWORD PTR _pHFRegenMblk$[ebp]
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 _SC6Excitation@40
$L1366:

; 196  : 
; 197  :    }
; 198  : 
; 199  :    /*-----------------------------------------------------------------------
; 200  :      Compute modulo 2PI of the onset phase
; 201  :    -----------------------------------------------------------------------*/
; 202  :    ftmp=fOnsetPhase*INVTWOPI;

  000b6	d9 45 f4	 fld	 DWORD PTR _fOnsetPhase$[ebp]
  000b9	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e22f983
  000bf	d9 5d f0	 fstp	 DWORD PTR _ftmp$[ebp]

; 203  :    VoxROUND2(ftmp,iMhat);

  000c2	d9 45 f0	 fld	 DWORD PTR _ftmp$[ebp]
  000c5	db 5d fc	 fistp	 DWORD PTR _iMhat$[ebp]

; 204  :    fOnsetPhase -= iMhat*TWOPI;

  000c8	db 45 fc	 fild	 DWORD PTR _iMhat$[ebp]
  000cb	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40c90fdb
  000d1	d8 6d f4	 fsubr	 DWORD PTR _fOnsetPhase$[ebp]
  000d4	d9 5d f4	 fstp	 DWORD PTR _fOnsetPhase$[ebp]

; 205  : 
; 206  :    /*-----------------------------------------------------------------------
; 207  :      Set output parameter values
; 208  :    -----------------------------------------------------------------------*/
; 209  :    *pfOnsetPhase = fOnsetPhase;

  000d7	8b 55 20	 mov	 edx, DWORD PTR _pfOnsetPhase$[ebp]
  000da	8b 45 f4	 mov	 eax, DWORD PTR _fOnsetPhase$[ebp]
  000dd	89 02		 mov	 DWORD PTR [edx], eax

; 210  :    *pfBeta       = fBeta;

  000df	8b 4d 24	 mov	 ecx, DWORD PTR _pfBeta$[ebp]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _fBeta$[ebp]
  000e5	89 11		 mov	 DWORD PTR [ecx], edx

; 211  : 
; 212  :    /*-----------------------------------------------------------------------
; 213  :      Save for next time
; 214  :    -----------------------------------------------------------------------*/
; 215  :    pHFRegenMblk->fOnsetPhase_1 = fOnsetPhase;

  000e7	8b 45 e8	 mov	 eax, DWORD PTR _pHFRegenMblk$[ebp]
  000ea	8b 4d f4	 mov	 ecx, DWORD PTR _fOnsetPhase$[ebp]
  000ed	89 08		 mov	 DWORD PTR [eax], ecx

; 216  :    pHFRegenMblk->fPitchDFT_1   = fPitchDFT;

  000ef	8b 55 e8	 mov	 edx, DWORD PTR _pHFRegenMblk$[ebp]
  000f2	8b 45 10	 mov	 eax, DWORD PTR _fPitchDFT$[ebp]
  000f5	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 217  : 
; 218  : } /*VoxHFRegen*/

  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c2 2c 00	 ret	 44			; 0000002cH
_VoxHFRegeneration@44 ENDP
_TEXT	ENDS
PUBLIC	_VoxInitHFRegen@4
EXTRN	_calloc:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxInitHFRegen@4
_TEXT	SEGMENT
_pHFRegenMblk$ = -8
_usStatus$ = -4
_hHFRegenMblk$ = 8
_VoxInitHFRegen@4 PROC NEAR				; COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 244  :    HFRegenStruct  *pHFRegenMblk;
; 245  :    unsigned short  usStatus = 0;

  00006	66 c7 45 fc 00
	00		 mov	 WORD PTR _usStatus$[ebp], 0

; 246  : 
; 247  :    if(VOX_MEM_INIT(pHFRegenMblk=*hHFRegenMblk,1, sizeof(HFRegenStruct)))

  0000c	6a 14		 push	 20			; 00000014H
  0000e	6a 01		 push	 1
  00010	e8 00 00 00 00	 call	 _calloc
  00015	83 c4 08	 add	 esp, 8
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _hHFRegenMblk$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	8b 55 08	 mov	 edx, DWORD PTR _hHFRegenMblk$[ebp]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	89 45 f8	 mov	 DWORD PTR _pHFRegenMblk$[ebp], eax
  00025	83 7d f8 00	 cmp	 DWORD PTR _pHFRegenMblk$[ebp], 0
  00029	75 08		 jne	 SHORT $L1373

; 248  :    {
; 249  :       usStatus = 1;

  0002b	66 c7 45 fc 01
	00		 mov	 WORD PTR _usStatus$[ebp], 1

; 250  :    } else {

  00031	eb 0a		 jmp	 SHORT $L1374
$L1373:

; 251  : 
; 252  :     /*---------------------------------------------------------------
; 253  :       VOX_MEM_INIT sets pHFRegenMblk to zero on the Sun and PC, so
; 254  :       to reduce code size we can skip the next four lines of code.
; 255  :       On some platforms this code will be necessary.
; 256  : 
; 257  :       pHFRegenMblk->fOnsetPhase_1 = 0.0F;
; 258  :       pHFRegenMblk->fBeta_1       = 0.0F;
; 259  :       pHFRegenMblk->fBetaOffset   = 0.0F;
; 260  :       pHFRegenMblk->fPhaseOffset  = 0.0F;
; 261  :     ---------------------------------------------------------------*/
; 262  :       pHFRegenMblk->fPitchDFT_1   = (float)INITIAL_PITCH_DFT; 

  00033	8b 4d f8	 mov	 ecx, DWORD PTR _pHFRegenMblk$[ebp]
  00036	c7 41 10 00 00
	a0 40		 mov	 DWORD PTR [ecx+16], 1084227584 ; 40a00000H
$L1374:

; 263  :    }
; 264  : 
; 265  :    return usStatus;

  0003d	66 8b 45 fc	 mov	 ax, WORD PTR _usStatus$[ebp]

; 266  : } /* VoxInitHFRegen */

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_VoxInitHFRegen@4 ENDP
_TEXT	ENDS
PUBLIC	_VoxFreeHFRegen@4
EXTRN	_free:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxFreeHFRegen@4
_TEXT	SEGMENT
_hHFRegenMblk$ = 8
_VoxFreeHFRegen@4 PROC NEAR				; COMDAT

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 292  :    if (*hHFRegenMblk)

  00003	8b 45 08	 mov	 eax, DWORD PTR _hHFRegenMblk$[ebp]
  00006	83 38 00	 cmp	 DWORD PTR [eax], 0
  00009	74 1f		 je	 SHORT $L1378

; 293  :       VOX_MEM_FREE(*hHFRegenMblk);

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _hHFRegenMblk$[ebp]
  0000e	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00011	74 17		 je	 SHORT $L1378
  00013	8b 55 08	 mov	 edx, DWORD PTR _hHFRegenMblk$[ebp]
  00016	8b 02		 mov	 eax, DWORD PTR [edx]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _free
  0001e	83 c4 04	 add	 esp, 4
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _hHFRegenMblk$[ebp]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L1378:

; 294  : } /* VoxFreeHFRegen */

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
_VoxFreeHFRegen@4 ENDP
_TEXT	ENDS
PUBLIC	__real@43400000
PUBLIC	__real@3e800000
EXTRN	_fInvLog2@4:NEAR
EXTRN	_sinTBL_32:DWORD
EXTRN	_cosTBL_32:DWORD
EXTRN	_fRadiansToIndex:DWORD
;	COMDAT __real@43400000
CONST	SEGMENT
__real@43400000 DD 043400000r			; 192
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _SC6Excitation@40
_TEXT	SEGMENT
tv65 = -140
_fDeltaPhase$ = -136
_fFreq$ = -132
_pfRE$ = -128
_pfIM$ = -96
_fOnsetPhase$ = -64
_iPhase$ = -60
_fModelPhase$ = -56
_fBeta$ = -52
_fPhase$ = -48
_pfAmp$ = -44
_iMpeaks$ = -12
_i$ = -8
_iBasePeaks$ = -4
_pHFRegenMblk$ = 8
_iHarmonics$ = 12
_fPitchDFT$ = 16
_iSynSamples$ = 20
_iUpdatePhaseOffsetFlag$ = 24
_pfLogAmp$ = 28
_pfMinPhase$ = 32
_pfVEVphase$ = 36
_pfOnsetPhase$ = 40
_pfBeta$ = 44
_SC6Excitation@40 PROC NEAR				; COMDAT

; 493  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	56		 push	 esi

; 494  :    int i;
; 495  :    int iMpeaks;
; 496  :    int iBasePeaks;
; 497  :    int iPhase;
; 498  : 
; 499  :    float fFreq;
; 500  :    float fPhase;
; 501  :    float fOnsetPhase;
; 502  :    float fModelPhase;
; 503  :    float fDeltaPhase;
; 504  :    float fBeta;
; 505  : STACK_INIT
; 506  :    float pfAmp[SC6_PHASES];
; 507  :    float pfRE[SC6_PHASES];
; 508  :    float pfIM[SC6_PHASES];
; 509  : STACK_INIT_END
; 510  : 
; 511  :    STACK_ATTACH(float *, pfAmp)
; 512  :    STACK_ATTACH(float *, pfRE)
; 513  :    STACK_ATTACH(float *, pfIM)
; 514  : 
; 515  : STACK_START
; 516  : 
; 517  :    /*-----------------------------------------------------------------------
; 518  :      Set actual number of measured phases
; 519  :    -----------------------------------------------------------------------*/
; 520  :    iMpeaks = VoxMIN( SC6_PHASES, iHarmonics );

  0000a	83 7d 0c 08	 cmp	 DWORD PTR _iHarmonics$[ebp], 8
  0000e	7d 0b		 jge	 SHORT $L1514
  00010	8b 45 0c	 mov	 eax, DWORD PTR _iHarmonics$[ebp]
  00013	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  00019	eb 0a		 jmp	 SHORT $L1515
$L1514:
  0001b	c7 85 74 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv65[ebp], 8
$L1515:
  00025	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv65[ebp]
  0002b	89 4d f4	 mov	 DWORD PTR _iMpeaks$[ebp], ecx

; 521  : 
; 522  :    /*-----------------------------------------------------------------------
; 523  :      Limit bandwidth of onset phase estimator so that it will not be
; 524  :        affected by the fact that the system phase is zero at PI
; 525  :    -----------------------------------------------------------------------*/
; 526  :    for (iBasePeaks=0, fFreq=fPitchDFT; iBasePeaks<iMpeaks; 
; 527  :         iBasePeaks++, fFreq+=fPitchDFT)

  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iBasePeaks$[ebp], 0
  00035	8b 55 10	 mov	 edx, DWORD PTR _fPitchDFT$[ebp]
  00038	89 95 7c ff ff
	ff		 mov	 DWORD PTR _fFreq$[ebp], edx
  0003e	eb 18		 jmp	 SHORT $L1465
$L1466:
  00040	8b 45 fc	 mov	 eax, DWORD PTR _iBasePeaks$[ebp]
  00043	83 c0 01	 add	 eax, 1
  00046	89 45 fc	 mov	 DWORD PTR _iBasePeaks$[ebp], eax
  00049	d9 85 7c ff ff
	ff		 fld	 DWORD PTR _fFreq$[ebp]
  0004f	d8 45 10	 fadd	 DWORD PTR _fPitchDFT$[ebp]
  00052	d9 9d 7c ff ff
	ff		 fstp	 DWORD PTR _fFreq$[ebp]
$L1465:
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _iBasePeaks$[ebp]
  0005b	3b 4d f4	 cmp	 ecx, DWORD PTR _iMpeaks$[ebp]
  0005e	7d 17		 jge	 SHORT $L1467

; 528  :      {
; 529  :         if (fFreq > BANDLIMIT)

  00060	d9 85 7c ff ff
	ff		 fld	 DWORD PTR _fFreq$[ebp]
  00066	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@43400000
  0006c	df e0		 fnstsw	 ax
  0006e	f6 c4 41	 test	 ah, 65			; 00000041H
  00071	75 02		 jne	 SHORT $L1470

; 530  :            break;

  00073	eb 02		 jmp	 SHORT $L1467
$L1470:

; 531  :      }

  00075	eb c9		 jmp	 SHORT $L1466
$L1467:

; 532  : 
; 533  :    /*-----------------------------------------------------------------------
; 534  :      Compute the real and imaginary parts of the excitation phase
; 535  :    -----------------------------------------------------------------------*/
; 536  :    for (i = 0; i < iMpeaks; i++)

  00077	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0007e	eb 09		 jmp	 SHORT $L1471
$L1472:
  00080	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00083	83 c2 01	 add	 edx, 1
  00086	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L1471:
  00089	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0008c	3b 45 f4	 cmp	 eax, DWORD PTR _iMpeaks$[ebp]
  0008f	0f 8d 96 00 00
	00		 jge	 $L1473

; 537  :    {
; 538  :       /*-------------------------------------------------
; 539  :         Remove minimum-phase system phase
; 540  :       -------------------------------------------------*/
; 541  :       pfVEVphase[i] -= pfMinPhase[i];

  00095	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00098	8b 55 24	 mov	 edx, DWORD PTR _pfVEVphase$[ebp]
  0009b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0009e	8b 75 20	 mov	 esi, DWORD PTR _pfMinPhase$[ebp]
  000a1	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  000a4	d8 24 86	 fsub	 DWORD PTR [esi+eax*4]
  000a7	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000aa	8b 55 24	 mov	 edx, DWORD PTR _pfVEVphase$[ebp]
  000ad	d9 1c 8a	 fstp	 DWORD PTR [edx+ecx*4]

; 542  : 
; 543  :       /*-------------------------------------------------
; 544  :         Compute trig table index.
; 545  :  
; 546  :         NOTE: This assumes a 2's complement integer
; 547  :               representation.  Using the trig mask 
; 548  :               (iResPhase&TRIG_MASK) yeilds the correct
; 549  :               positive index, even if iResPhase is
; 550  :               negative.  This would not be true for  
; 551  :               signed magnitude integer representation.
; 552  :       -------------------------------------------------*/
; 553  :       fPhase = pfVEVphase[i]*fRadiansToIndex;

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000b3	8b 4d 24	 mov	 ecx, DWORD PTR _pfVEVphase$[ebp]
  000b6	d9 05 00 00 00
	00		 fld	 DWORD PTR _fRadiansToIndex
  000bc	d8 0c 81	 fmul	 DWORD PTR [ecx+eax*4]
  000bf	d9 5d d0	 fstp	 DWORD PTR _fPhase$[ebp]

; 554  :       VoxROUND2( fPhase, iPhase );

  000c2	d9 45 d0	 fld	 DWORD PTR _fPhase$[ebp]
  000c5	db 5d c4	 fistp	 DWORD PTR _iPhase$[ebp]

; 555  :       iPhase &= TRIG_MASK;

  000c8	8b 55 c4	 mov	 edx, DWORD PTR _iPhase$[ebp]
  000cb	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000d1	89 55 c4	 mov	 DWORD PTR _iPhase$[ebp], edx

; 556  : 
; 557  :       /*-------------------------------------------------
; 558  :         Compute real and imaginary parts of compressed 
; 559  :           amplitude
; 560  :       -------------------------------------------------*/
; 561  :       pfAmp[i] = fInvLog2(GAMMA_HFREGENERATION*pfLogAmp[i]);

  000d4	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000d7	8b 4d 1c	 mov	 ecx, DWORD PTR _pfLogAmp$[ebp]
  000da	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3e800000
  000e0	d8 0c 81	 fmul	 DWORD PTR [ecx+eax*4]
  000e3	51		 push	 ecx
  000e4	d9 1c 24	 fstp	 DWORD PTR [esp]
  000e7	e8 00 00 00 00	 call	 _fInvLog2@4
  000ec	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000ef	d9 5c 95 d4	 fstp	 DWORD PTR _pfAmp$[ebp+edx*4]

; 562  :       pfRE[i]  = pfAmp[i]*cosTBL_32[iPhase];

  000f3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000f6	8b 4d c4	 mov	 ecx, DWORD PTR _iPhase$[ebp]
  000f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _cosTBL_32
  000ff	d9 44 85 d4	 fld	 DWORD PTR _pfAmp$[ebp+eax*4]
  00103	d8 0c 8a	 fmul	 DWORD PTR [edx+ecx*4]
  00106	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00109	d9 5c 85 80	 fstp	 DWORD PTR _pfRE$[ebp+eax*4]

; 563  :       pfIM[i]  = pfAmp[i]*sinTBL_32[iPhase];

  0010d	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00110	8b 55 c4	 mov	 edx, DWORD PTR _iPhase$[ebp]
  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR _sinTBL_32
  00118	d9 44 8d d4	 fld	 DWORD PTR _pfAmp$[ebp+ecx*4]
  0011c	d8 0c 90	 fmul	 DWORD PTR [eax+edx*4]
  0011f	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00122	d9 5c 8d a0	 fstp	 DWORD PTR _pfIM$[ebp+ecx*4]

; 564  :    }

  00126	e9 55 ff ff ff	 jmp	 $L1472
$L1473:

; 565  : 
; 566  :    /*-----------------------------------------------------------------------
; 567  :      Compute onset phase
; 568  :    -----------------------------------------------------------------------*/
; 569  :    fOnsetPhase = fComputeOnsetPhase(STACK_S iBasePeaks, pfRE, pfIM);

  0012b	8d 55 a0	 lea	 edx, DWORD PTR _pfIM$[ebp]
  0012e	52		 push	 edx
  0012f	8d 45 80	 lea	 eax, DWORD PTR _pfRE$[ebp]
  00132	50		 push	 eax
  00133	8b 4d fc	 mov	 ecx, DWORD PTR _iBasePeaks$[ebp]
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 _fComputeOnsetPhase@12
  0013c	d9 5d c0	 fstp	 DWORD PTR _fOnsetPhase$[ebp]

; 570  : 
; 571  :    /*-----------------------------------------------------------------------
; 572  :         Determine the phase offset at DC 
; 573  :    -----------------------------------------------------------------------*/
; 574  :    fBeta = fComputeBeta( iBasePeaks, pfVEVphase, pfAmp, fOnsetPhase);

  0013f	8b 55 c0	 mov	 edx, DWORD PTR _fOnsetPhase$[ebp]
  00142	52		 push	 edx
  00143	8d 45 d4	 lea	 eax, DWORD PTR _pfAmp$[ebp]
  00146	50		 push	 eax
  00147	8b 4d 24	 mov	 ecx, DWORD PTR _pfVEVphase$[ebp]
  0014a	51		 push	 ecx
  0014b	8b 55 fc	 mov	 edx, DWORD PTR _iBasePeaks$[ebp]
  0014e	52		 push	 edx
  0014f	e8 00 00 00 00	 call	 _fComputeBeta@16
  00154	d9 5d cc	 fstp	 DWORD PTR _fBeta$[ebp]

; 575  : 
; 576  :    /*-----------------------------------------------------------------------
; 577  :         Compute the phase residuals (NOTE: these are WRAPPED)
; 578  :    -----------------------------------------------------------------------*/
; 579  :    fModelPhase = fBeta;

  00157	8b 45 cc	 mov	 eax, DWORD PTR _fBeta$[ebp]
  0015a	89 45 c8	 mov	 DWORD PTR _fModelPhase$[ebp], eax

; 580  :    for (i = 0; i < iMpeaks; i++)

  0015d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00164	eb 09		 jmp	 SHORT $L1474
$L1475:
  00166	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00169	83 c1 01	 add	 ecx, 1
  0016c	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$L1474:
  0016f	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00172	3b 55 f4	 cmp	 edx, DWORD PTR _iMpeaks$[ebp]
  00175	7d 20		 jge	 SHORT $L1476

; 581  :    {
; 582  :       fModelPhase   += fOnsetPhase;

  00177	d9 45 c8	 fld	 DWORD PTR _fModelPhase$[ebp]
  0017a	d8 45 c0	 fadd	 DWORD PTR _fOnsetPhase$[ebp]
  0017d	d9 5d c8	 fstp	 DWORD PTR _fModelPhase$[ebp]

; 583  :       pfVEVphase[i] -= fModelPhase;

  00180	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00183	8b 4d 24	 mov	 ecx, DWORD PTR _pfVEVphase$[ebp]
  00186	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  00189	d8 65 c8	 fsub	 DWORD PTR _fModelPhase$[ebp]
  0018c	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0018f	8b 45 24	 mov	 eax, DWORD PTR _pfVEVphase$[ebp]
  00192	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]

; 584  :    }

  00195	eb cf		 jmp	 SHORT $L1475
$L1476:

; 585  : 
; 586  :    /*-----------------------------------------------------------------------
; 587  :      update phase offset and beta when frame loss occurs
; 588  :    -----------------------------------------------------------------------*/
; 589  :    if (iUpdatePhaseOffsetFlag)

  00197	83 7d 18 00	 cmp	 DWORD PTR _iUpdatePhaseOffsetFlag$[ebp], 0
  0019b	74 3b		 je	 SHORT $L1477

; 590  :    {
; 591  :       fDeltaPhase =  (0.5F*TWOPIONFFT)*(fPitchDFT+pHFRegenMblk->fPitchDFT_1)
; 592  :                      *iSynSamples;

  0019d	8b 4d 08	 mov	 ecx, DWORD PTR _pHFRegenMblk$[ebp]
  001a0	d9 45 10	 fld	 DWORD PTR _fPitchDFT$[ebp]
  001a3	d8 41 10	 fadd	 DWORD PTR [ecx+16]
  001a6	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3bc90fdb
  001ac	da 4d 14	 fimul	 DWORD PTR _iSynSamples$[ebp]
  001af	d9 9d 78 ff ff
	ff		 fstp	 DWORD PTR _fDeltaPhase$[ebp]

; 593  :       pHFRegenMblk->fPhaseOffset = pHFRegenMblk->fOnsetPhase_1 +
; 594  :                                    fDeltaPhase - fOnsetPhase;

  001b5	8b 55 08	 mov	 edx, DWORD PTR _pHFRegenMblk$[ebp]
  001b8	d9 85 78 ff ff
	ff		 fld	 DWORD PTR _fDeltaPhase$[ebp]
  001be	d8 02		 fadd	 DWORD PTR [edx]
  001c0	d8 65 c0	 fsub	 DWORD PTR _fOnsetPhase$[ebp]
  001c3	8b 45 08	 mov	 eax, DWORD PTR _pHFRegenMblk$[ebp]
  001c6	d9 58 0c	 fstp	 DWORD PTR [eax+12]

; 595  :       
; 596  :       pHFRegenMblk->fBetaOffset = pHFRegenMblk->fBeta_1 - fBeta;

  001c9	8b 4d 08	 mov	 ecx, DWORD PTR _pHFRegenMblk$[ebp]
  001cc	d9 41 04	 fld	 DWORD PTR [ecx+4]
  001cf	d8 65 cc	 fsub	 DWORD PTR _fBeta$[ebp]
  001d2	8b 55 08	 mov	 edx, DWORD PTR _pHFRegenMblk$[ebp]
  001d5	d9 5a 08	 fstp	 DWORD PTR [edx+8]
$L1477:

; 597  :    }
; 598  : 
; 599  :    fBeta       += pHFRegenMblk->fBetaOffset;

  001d8	8b 45 08	 mov	 eax, DWORD PTR _pHFRegenMblk$[ebp]
  001db	d9 45 cc	 fld	 DWORD PTR _fBeta$[ebp]
  001de	d8 40 08	 fadd	 DWORD PTR [eax+8]
  001e1	d9 5d cc	 fstp	 DWORD PTR _fBeta$[ebp]

; 600  :    fOnsetPhase += pHFRegenMblk->fPhaseOffset;

  001e4	8b 4d 08	 mov	 ecx, DWORD PTR _pHFRegenMblk$[ebp]
  001e7	d9 45 c0	 fld	 DWORD PTR _fOnsetPhase$[ebp]
  001ea	d8 41 0c	 fadd	 DWORD PTR [ecx+12]
  001ed	d9 5d c0	 fstp	 DWORD PTR _fOnsetPhase$[ebp]

; 601  : 
; 602  :    /*-----------------------------------------------------------------------
; 603  :      Save this parameter for next time
; 604  :    -----------------------------------------------------------------------*/
; 605  :    pHFRegenMblk->fBeta_1 = fBeta;

  001f0	8b 55 08	 mov	 edx, DWORD PTR _pHFRegenMblk$[ebp]
  001f3	8b 45 cc	 mov	 eax, DWORD PTR _fBeta$[ebp]
  001f6	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 606  : 
; 607  :    /*-----------------------------------------------------------------------
; 608  :      Set output values
; 609  :    -----------------------------------------------------------------------*/
; 610  :    *pfOnsetPhase = fOnsetPhase;

  001f9	8b 4d 28	 mov	 ecx, DWORD PTR _pfOnsetPhase$[ebp]
  001fc	8b 55 c0	 mov	 edx, DWORD PTR _fOnsetPhase$[ebp]
  001ff	89 11		 mov	 DWORD PTR [ecx], edx

; 611  :    *pfBeta = fBeta;

  00201	8b 45 2c	 mov	 eax, DWORD PTR _pfBeta$[ebp]
  00204	8b 4d cc	 mov	 ecx, DWORD PTR _fBeta$[ebp]
  00207	89 08		 mov	 DWORD PTR [eax], ecx

; 612  : 
; 613  : STACK_END
; 614  : } /* SC6Excitation */

  00209	5e		 pop	 esi
  0020a	8b e5		 mov	 esp, ebp
  0020c	5d		 pop	 ebp
  0020d	c2 28 00	 ret	 40			; 00000028H
_SC6Excitation@40 ENDP
_TEXT	ENDS
PUBLIC	__real@40000000
PUBLIC	__real@3f000000
EXTRN	_atan2:NEAR
EXTRN	_memset:NEAR
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _fComputeOnsetPhase@12
_TEXT	SEGMENT
tv210 = -108
tv206 = -104
_j$ = -100
_ftmp$ = -96
_fNewOnsetPhase$ = -92
_k$ = -88
_iIndex$ = -84
_fOnsetPhase$ = -80
_iMhat$ = -76
_fYR$ = -72
_fXR$ = -40
_fTemp1$ = -8
_fTemp2$ = -4
_iBasePeaks$ = 8
_pfRE$ = 12
_pfIM$ = 16
_fComputeOnsetPhase@12 PROC NEAR			; COMDAT

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	56		 push	 esi

; 325  :    int   j, k;
; 326  :    int   iIndex;
; 327  :    int   iMhat;
; 328  :    float fOnsetPhase;
; 329  :    float fNewOnsetPhase;
; 330  :    float fTemp1;
; 331  :    float fTemp2;
; 332  :    float ftmp;
; 333  : 
; 334  : STACK_INIT
; 335  :    float fXR[SC6_PHASES];
; 336  :    float fYR[SC6_PHASES];
; 337  : STACK_INIT_END
; 338  : 
; 339  :    STACK_ATTACH(float *, fXR)
; 340  :    STACK_ATTACH(float *, fYR)
; 341  : 
; 342  :    STACK_START
; 343  : 
; 344  :    /*-----------------------------------------------------------------------
; 345  :      Compute the onset time for the first phase difference 
; 346  :    -----------------------------------------------------------------------*/
; 347  :    memset(fXR, 0, SC6_PHASES*sizeof(float));

  00007	6a 20		 push	 32			; 00000020H
  00009	6a 00		 push	 0
  0000b	8d 45 d8	 lea	 eax, DWORD PTR _fXR$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 348  :    memset(fYR, 0, SC6_PHASES*sizeof(float));

  00017	6a 20		 push	 32			; 00000020H
  00019	6a 00		 push	 0
  0001b	8d 4d b8	 lea	 ecx, DWORD PTR _fYR$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _memset
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 349  : 
; 350  :    for (j = 0; j < iBasePeaks; j++)

  00027	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0002e	eb 09		 jmp	 SHORT $L1402
$L1403:
  00030	8b 55 9c	 mov	 edx, DWORD PTR _j$[ebp]
  00033	83 c2 01	 add	 edx, 1
  00036	89 55 9c	 mov	 DWORD PTR _j$[ebp], edx
$L1402:
  00039	8b 45 9c	 mov	 eax, DWORD PTR _j$[ebp]
  0003c	3b 45 08	 cmp	 eax, DWORD PTR _iBasePeaks$[ebp]
  0003f	0f 8d 9e 00 00
	00		 jge	 $L1404

; 351  :    {  
; 352  :      for (k=j+1, iIndex=1; k < iBasePeaks; k++, iIndex++)

  00045	8b 4d 9c	 mov	 ecx, DWORD PTR _j$[ebp]
  00048	83 c1 01	 add	 ecx, 1
  0004b	89 4d a8	 mov	 DWORD PTR _k$[ebp], ecx
  0004e	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR _iIndex$[ebp], 1
  00055	eb 12		 jmp	 SHORT $L1405
$L1406:
  00057	8b 55 a8	 mov	 edx, DWORD PTR _k$[ebp]
  0005a	83 c2 01	 add	 edx, 1
  0005d	89 55 a8	 mov	 DWORD PTR _k$[ebp], edx
  00060	8b 45 ac	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00063	83 c0 01	 add	 eax, 1
  00066	89 45 ac	 mov	 DWORD PTR _iIndex$[ebp], eax
$L1405:
  00069	8b 4d a8	 mov	 ecx, DWORD PTR _k$[ebp]
  0006c	3b 4d 08	 cmp	 ecx, DWORD PTR _iBasePeaks$[ebp]
  0006f	7d 6d		 jge	 SHORT $L1407

; 353  :       {
; 354  :          fXR[iIndex] += (pfRE[j]*pfRE[k] + pfIM[j]*pfIM[k]);

  00071	8b 55 9c	 mov	 edx, DWORD PTR _j$[ebp]
  00074	8b 45 0c	 mov	 eax, DWORD PTR _pfRE$[ebp]
  00077	8b 4d a8	 mov	 ecx, DWORD PTR _k$[ebp]
  0007a	8b 75 0c	 mov	 esi, DWORD PTR _pfRE$[ebp]
  0007d	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  00080	d8 0c 8e	 fmul	 DWORD PTR [esi+ecx*4]
  00083	8b 55 9c	 mov	 edx, DWORD PTR _j$[ebp]
  00086	8b 45 10	 mov	 eax, DWORD PTR _pfIM$[ebp]
  00089	8b 4d a8	 mov	 ecx, DWORD PTR _k$[ebp]
  0008c	8b 75 10	 mov	 esi, DWORD PTR _pfIM$[ebp]
  0008f	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  00092	d8 0c 8e	 fmul	 DWORD PTR [esi+ecx*4]
  00095	de c1		 faddp	 ST(1), ST(0)
  00097	8b 55 ac	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0009a	d8 44 95 d8	 fadd	 DWORD PTR _fXR$[ebp+edx*4]
  0009e	8b 45 ac	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000a1	d9 5c 85 d8	 fstp	 DWORD PTR _fXR$[ebp+eax*4]

; 355  :          fYR[iIndex] += (pfRE[j]*pfIM[k] - pfIM[j]*pfRE[k]); 

  000a5	8b 4d 9c	 mov	 ecx, DWORD PTR _j$[ebp]
  000a8	8b 55 0c	 mov	 edx, DWORD PTR _pfRE$[ebp]
  000ab	8b 45 a8	 mov	 eax, DWORD PTR _k$[ebp]
  000ae	8b 75 10	 mov	 esi, DWORD PTR _pfIM$[ebp]
  000b1	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  000b4	d8 0c 86	 fmul	 DWORD PTR [esi+eax*4]
  000b7	8b 4d 9c	 mov	 ecx, DWORD PTR _j$[ebp]
  000ba	8b 55 10	 mov	 edx, DWORD PTR _pfIM$[ebp]
  000bd	8b 45 a8	 mov	 eax, DWORD PTR _k$[ebp]
  000c0	8b 75 0c	 mov	 esi, DWORD PTR _pfRE$[ebp]
  000c3	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  000c6	d8 0c 86	 fmul	 DWORD PTR [esi+eax*4]
  000c9	de e9		 fsubp	 ST(1), ST(0)
  000cb	8b 4d ac	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  000ce	d8 44 8d b8	 fadd	 DWORD PTR _fYR$[ebp+ecx*4]
  000d2	8b 55 ac	 mov	 edx, DWORD PTR _iIndex$[ebp]
  000d5	d9 5c 95 b8	 fstp	 DWORD PTR _fYR$[ebp+edx*4]

; 356  :       }

  000d9	e9 79 ff ff ff	 jmp	 $L1406
$L1407:

; 357  :    }

  000de	e9 4d ff ff ff	 jmp	 $L1403
$L1404:

; 358  :    fOnsetPhase = VoxATAN2(fYR[1], fXR[1]);

  000e3	d9 45 dc	 fld	 DWORD PTR _fXR$[ebp+4]
  000e6	83 ec 08	 sub	 esp, 8
  000e9	dd 1c 24	 fstp	 QWORD PTR [esp]
  000ec	d9 45 bc	 fld	 DWORD PTR _fYR$[ebp+4]
  000ef	83 ec 08	 sub	 esp, 8
  000f2	dd 1c 24	 fstp	 QWORD PTR [esp]
  000f5	e8 00 00 00 00	 call	 _atan2
  000fa	83 c4 10	 add	 esp, 16			; 00000010H
  000fd	d9 55 98	 fst	 DWORD PTR tv206[ebp]
  00100	d9 5d b0	 fstp	 DWORD PTR _fOnsetPhase$[ebp]

; 359  : 
; 360  : 
; 361  :    /*-----------------------------------------------------------------------
; 362  :        Compute the onset time for the 2nd-order phase difference 
; 363  :    -----------------------------------------------------------------------*/
; 364  :    fTemp2 = 2.0F*fOnsetPhase;

  00103	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40000000
  00109	d8 4d b0	 fmul	 DWORD PTR _fOnsetPhase$[ebp]
  0010c	d9 5d fc	 fstp	 DWORD PTR _fTemp2$[ebp]

; 365  :    fTemp1 = VoxATAN2(fYR[2], fXR[2]);

  0010f	d9 45 e0	 fld	 DWORD PTR _fXR$[ebp+8]
  00112	83 ec 08	 sub	 esp, 8
  00115	dd 1c 24	 fstp	 QWORD PTR [esp]
  00118	d9 45 c0	 fld	 DWORD PTR _fYR$[ebp+8]
  0011b	83 ec 08	 sub	 esp, 8
  0011e	dd 1c 24	 fstp	 QWORD PTR [esp]
  00121	e8 00 00 00 00	 call	 _atan2
  00126	83 c4 10	 add	 esp, 16			; 00000010H
  00129	d9 55 94	 fst	 DWORD PTR tv210[ebp]
  0012c	d9 5d f8	 fstp	 DWORD PTR _fTemp1$[ebp]

; 366  :    ftmp = (fTemp2 - fTemp1)*INVTWOPI;

  0012f	d9 45 fc	 fld	 DWORD PTR _fTemp2$[ebp]
  00132	d8 65 f8	 fsub	 DWORD PTR _fTemp1$[ebp]
  00135	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e22f983
  0013b	d9 5d a0	 fstp	 DWORD PTR _ftmp$[ebp]

; 367  :    VoxROUND2(ftmp, iMhat);

  0013e	d9 45 a0	 fld	 DWORD PTR _ftmp$[ebp]
  00141	db 5d b4	 fistp	 DWORD PTR _iMhat$[ebp]

; 368  :    fNewOnsetPhase = 0.5F*(fTemp1 + (float)iMhat*TWOPI);

  00144	db 45 b4	 fild	 DWORD PTR _iMhat$[ebp]
  00147	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40c90fdb
  0014d	d8 45 f8	 fadd	 DWORD PTR _fTemp1$[ebp]
  00150	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00156	d9 5d a4	 fstp	 DWORD PTR _fNewOnsetPhase$[ebp]

; 369  :    fOnsetPhase = 0.5F*(fOnsetPhase + fNewOnsetPhase);

  00159	d9 45 b0	 fld	 DWORD PTR _fOnsetPhase$[ebp]
  0015c	d8 45 a4	 fadd	 DWORD PTR _fNewOnsetPhase$[ebp]
  0015f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00165	d9 55 b0	 fst	 DWORD PTR _fOnsetPhase$[ebp]

; 370  : 
; 371  :    STACK_END
; 372  : 
; 373  :    return fOnsetPhase;
; 374  : } /* fComputeOnsetPhase */

  00168	5e		 pop	 esi
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c2 0c 00	 ret	 12			; 0000000cH
_fComputeOnsetPhase@12 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _fComputeBeta@16
_TEXT	SEGMENT
tv143 = -32
_j$ = -28
_fRESum$ = -24
_fIMSum$ = -20
_fModelPhase$ = -16
_fBeta$ = -12
_fResPhase$ = -8
_iResPhase$ = -4
_iBasePeaks$ = 8
_pfExcitationPhase$ = 12
_pfAmp$ = 16
_fOnsetPhase$ = 20
_fComputeBeta@16 PROC NEAR				; COMDAT

; 405  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi

; 406  :    int   j;
; 407  :    int   iResPhase;
; 408  :    float fRESum = 0.0F;

  00007	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _fRESum$[ebp], 0

; 409  :    float fIMSum = 0.0F;

  0000e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _fIMSum$[ebp], 0

; 410  :    float fModelPhase = 0.0F;

  00015	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _fModelPhase$[ebp], 0

; 411  :    float fResPhase;
; 412  :    float fBeta;
; 413  : 
; 414  :    for (j = 0; j < iBasePeaks; j++)

  0001c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00023	eb 09		 jmp	 SHORT $L1427
$L1428:
  00025	8b 45 e4	 mov	 eax, DWORD PTR _j$[ebp]
  00028	83 c0 01	 add	 eax, 1
  0002b	89 45 e4	 mov	 DWORD PTR _j$[ebp], eax
$L1427:
  0002e	8b 4d e4	 mov	 ecx, DWORD PTR _j$[ebp]
  00031	3b 4d 08	 cmp	 ecx, DWORD PTR _iBasePeaks$[ebp]
  00034	7d 6b		 jge	 SHORT $L1429

; 415  :    {
; 416  :       /*-------------------------------------------------
; 417  :         Compute residual phase
; 418  :       -------------------------------------------------*/
; 419  :       fModelPhase += fOnsetPhase;

  00036	d9 45 f0	 fld	 DWORD PTR _fModelPhase$[ebp]
  00039	d8 45 14	 fadd	 DWORD PTR _fOnsetPhase$[ebp]
  0003c	d9 5d f0	 fstp	 DWORD PTR _fModelPhase$[ebp]

; 420  :       fResPhase = pfExcitationPhase[j] - fModelPhase;

  0003f	8b 55 e4	 mov	 edx, DWORD PTR _j$[ebp]
  00042	8b 45 0c	 mov	 eax, DWORD PTR _pfExcitationPhase$[ebp]
  00045	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  00048	d8 65 f0	 fsub	 DWORD PTR _fModelPhase$[ebp]
  0004b	d9 55 f8	 fst	 DWORD PTR _fResPhase$[ebp]

; 421  : 
; 422  :       /*-------------------------------------------------
; 423  :         Compute trig table index.
; 424  : 
; 425  :         NOTE: This assumes a 2's complement integer
; 426  :               representation.  Using the trig mask 
; 427  :               (iResPhase&TRIG_MASK) yeilds the correct
; 428  :               positive index, even if iResPhase is
; 429  :               negative.  This would not be true for
; 430  :               signed magnitude integer representation.
; 431  :       -------------------------------------------------*/
; 432  :       fResPhase *= fRadiansToIndex;

  0004e	d8 0d 00 00 00
	00		 fmul	 DWORD PTR _fRadiansToIndex
  00054	d9 5d f8	 fstp	 DWORD PTR _fResPhase$[ebp]

; 433  :       VoxROUND2( fResPhase, iResPhase );

  00057	d9 45 f8	 fld	 DWORD PTR _fResPhase$[ebp]
  0005a	db 5d fc	 fistp	 DWORD PTR _iResPhase$[ebp]

; 434  :       iResPhase &= TRIG_MASK;

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _iResPhase$[ebp]
  00060	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00066	89 4d fc	 mov	 DWORD PTR _iResPhase$[ebp], ecx

; 435  : 
; 436  :       /*-------------------------------------------------
; 437  :         Accumulate real and imaginary parts using
; 438  :           trig tables
; 439  :       -------------------------------------------------*/
; 440  :       fRESum += pfAmp[j]*cosTBL_32[iResPhase];

  00069	8b 55 e4	 mov	 edx, DWORD PTR _j$[ebp]
  0006c	8b 45 10	 mov	 eax, DWORD PTR _pfAmp$[ebp]
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _iResPhase$[ebp]
  00072	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _cosTBL_32
  00078	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  0007b	d8 0c 8e	 fmul	 DWORD PTR [esi+ecx*4]
  0007e	d8 45 e8	 fadd	 DWORD PTR _fRESum$[ebp]
  00081	d9 5d e8	 fstp	 DWORD PTR _fRESum$[ebp]

; 441  :       fIMSum += pfAmp[j]*sinTBL_32[iResPhase];

  00084	8b 55 e4	 mov	 edx, DWORD PTR _j$[ebp]
  00087	8b 45 10	 mov	 eax, DWORD PTR _pfAmp$[ebp]
  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _iResPhase$[ebp]
  0008d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _sinTBL_32
  00093	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  00096	d8 0c 8e	 fmul	 DWORD PTR [esi+ecx*4]
  00099	d8 45 ec	 fadd	 DWORD PTR _fIMSum$[ebp]
  0009c	d9 5d ec	 fstp	 DWORD PTR _fIMSum$[ebp]

; 442  :    }

  0009f	eb 84		 jmp	 SHORT $L1428
$L1429:

; 443  : 
; 444  :    fBeta = VoxATAN2(fIMSum, fRESum);

  000a1	d9 45 e8	 fld	 DWORD PTR _fRESum$[ebp]
  000a4	83 ec 08	 sub	 esp, 8
  000a7	dd 1c 24	 fstp	 QWORD PTR [esp]
  000aa	d9 45 ec	 fld	 DWORD PTR _fIMSum$[ebp]
  000ad	83 ec 08	 sub	 esp, 8
  000b0	dd 1c 24	 fstp	 QWORD PTR [esp]
  000b3	e8 00 00 00 00	 call	 _atan2
  000b8	83 c4 10	 add	 esp, 16			; 00000010H
  000bb	d9 55 e0	 fst	 DWORD PTR tv143[ebp]
  000be	d9 55 f4	 fst	 DWORD PTR _fBeta$[ebp]

; 445  : 
; 446  :    return fBeta;
; 447  : } /* fComputeBeta */

  000c1	5e		 pop	 esi
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 10 00	 ret	 16			; 00000010H
_fComputeBeta@16 ENDP
_TEXT	ENDS
END
