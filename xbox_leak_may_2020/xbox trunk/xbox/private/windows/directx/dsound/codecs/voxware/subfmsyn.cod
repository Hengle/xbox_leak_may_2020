; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\subfmsyn.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _SubFrameSynth@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _OffsetMeasuresPhases@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_SubFrameSynth@24
PUBLIC	__real@43200000
PUBLIC	__real@3e800000
PUBLIC	__real@3f400000
PUBLIC	__real@3e000000
PUBLIC	__real@42a00000
EXTRN	_VoxSWSynth@56:NEAR
EXTRN	__fltused:NEAR
;	COMDAT __real@43200000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\subfmsyn.c
CONST	SEGMENT
__real@43200000 DD 043200000r			; 160
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _SubFrameSynth@24
_TEXT	SEGMENT
_OffsetFlag$ = -92
_pSubParamSyn$ = -88
_pfVEVphaseSyn$ = -84
_pSubParamMblk$ = -52
_iSubFrame$ = -48
_iUpdatePhaseOffsetFlag$ = -44
_iRepeatSamples$ = -40
_iOffsetSamples$ = -36
_pfSynSpeech$ = -32
_fFrameTime$ = -28
_pDecMemBlk$ = -24
_iSCRateSyn$ = -20
_fPitchPeriod_1$ = -16
_piCountSyn$ = -12
_fInterpFactor$ = -8
_fOffsetPitchPeriod$ = -4
_hDecMemBlk$ = 8
_hSubParamMblk$ = 12
_pfSpeechBuf$ = 16
_pfEnv$ = 20
_pfPhase$ = 24
_piSynSamples$ = 28
_SubFrameSynth@24 PROC NEAR				; COMDAT

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH

; 103  :    DEC_MEM_BLK *pDecMemBlk = (DEC_MEM_BLK *)hDecMemBlk;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hDecMemBlk$[ebp]
  00009	89 45 e8	 mov	 DWORD PTR _pDecMemBlk$[ebp], eax

; 104  :    SUBFRAME_PARAM_SC *pSubParamMblk = (SUBFRAME_PARAM_SC *)hSubParamMblk;

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _hSubParamMblk$[ebp]
  0000f	89 4d cc	 mov	 DWORD PTR _pSubParamMblk$[ebp], ecx

; 105  : 
; 106  :    int     iSubFrame;
; 107  :    int     iUpdatePhaseOffsetFlag = 0;

  00012	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _iUpdatePhaseOffsetFlag$[ebp], 0

; 108  :    int     iRepeatSamples;
; 109  :    int     iSCRateSyn = pDecMemBlk->iSCRate_1;

  00019	8b 55 e8	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  0001c	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001f	89 45 ec	 mov	 DWORD PTR _iSCRateSyn$[ebp], eax

; 110  :    int     OffsetFlag = 0;

  00022	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _OffsetFlag$[ebp], 0

; 111  :    int     iOffsetSamples;
; 112  :    float  *pfSynSpeech;
; 113  :    float   fInterpFactor;
; 114  :    float   fPitchPeriod_1;
; 115  :    float   fOffsetPitchPeriod;
; 116  :    float   fFrameTime;
; 117  : 
; 118  :    SUBFRAME_PARAM_SC *pSubParamSyn;
; 119  :    int     *piCountSyn;
; 120  : 
; 121  : STACK_INIT
; 122  :    float pfVEVphaseSyn[SC6_PHASES];
; 123  : STACK_INIT_END
; 124  : 
; 125  :    STACK_ATTACH(float *, pfVEVphaseSyn)
; 126  : 
; 127  :    STACK_START
; 128  : 
; 129  :    pfSynSpeech = pfSpeechBuf;

  00029	8b 4d 10	 mov	 ecx, DWORD PTR _pfSpeechBuf$[ebp]
  0002c	89 4d e0	 mov	 DWORD PTR _pfSynSpeech$[ebp], ecx

; 130  : 
; 131  :    /*-------------------------------------------------------------------------
; 132  :      fFrameTime is the time (in samples) corresponding to the parameters
; 133  :        in pParamMblk after the time scale has been warped.  Time has been
; 134  :        normalized so the parameters in pParamMblk_1 are located at time
; 135  :        sample 0.  (The mid-frame parameters in pParamMblk are at time
; 136  :        0.5*fFrameTime).
; 137  :    -------------------------------------------------------------------------*/
; 138  :    fFrameTime = pDecMemBlk->fActualWarp * FRAME_LENGTH_SC;

  0002f	8b 55 e8	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00032	d9 42 60	 fld	 DWORD PTR [edx+96]
  00035	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@43200000
  0003b	d9 5d e4	 fstp	 DWORD PTR _fFrameTime$[ebp]

; 139  : 
; 140  :    /*-------------------------------------------------------------------
; 141  :    | Synthesize up to two subframes of speech.
; 142  :    --------------------------------------------------------------------*/
; 143  :    for (iSubFrame = 2; iSubFrame > 0; iSubFrame--) {

  0003e	c7 45 d0 02 00
	00 00		 mov	 DWORD PTR _iSubFrame$[ebp], 2
  00045	eb 09		 jmp	 SHORT $L1639
$L1640:
  00047	8b 45 d0	 mov	 eax, DWORD PTR _iSubFrame$[ebp]
  0004a	83 e8 01	 sub	 eax, 1
  0004d	89 45 d0	 mov	 DWORD PTR _iSubFrame$[ebp], eax
$L1639:
  00050	83 7d d0 00	 cmp	 DWORD PTR _iSubFrame$[ebp], 0
  00054	0f 8e 30 02 00
	00		 jle	 $L1641

; 144  :       /*-------------------------------------------------------------------
; 145  :       | If the location of the center of the current synthesis frame
; 146  :       |   is between pParamMblk_1 and pParamMblk (between 0 and fFrameTime)
; 147  :       |   then synthesize the frame.  When warping is not used, 
; 148  :       |   fSynTimeOffset is equal to fFrameTime/2 for the first subframe,
; 149  :       |   and it is equal to fFrameTime for the second subframe.
; 150  :       -------------------------------------------------------------------*/
; 151  :       iUpdatePhaseOffsetFlag = 0;

  0005a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _iUpdatePhaseOffsetFlag$[ebp], 0

; 152  :       if (pDecMemBlk->fSynTimeOffset<=fFrameTime)

  00061	8b 4d e8	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00064	d9 41 68	 fld	 DWORD PTR [ecx+104]
  00067	d8 5d e4	 fcomp	 DWORD PTR _fFrameTime$[ebp]
  0006a	df e0		 fnstsw	 ax
  0006c	f6 c4 41	 test	 ah, 65			; 00000041H
  0006f	0f 8a 10 02 00
	00		 jp	 $L1642

; 153  :       {
; 154  :          /*-------------------------------------------------------------------
; 155  :          | Set the interpolation factor.  When warping is not used, 
; 156  :          |   fInterpFactor is 0.5 for the first subframe, and 1.0 
; 157  :          |   for the second sub-frame.
; 158  :          -------------------------------------------------------------------*/
; 159  :          fInterpFactor = pDecMemBlk->fSynTimeOffset/fFrameTime;

  00075	8b 55 e8	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00078	d9 42 68	 fld	 DWORD PTR [edx+104]
  0007b	d8 75 e4	 fdiv	 DWORD PTR _fFrameTime$[ebp]
  0007e	d9 5d f8	 fstp	 DWORD PTR _fInterpFactor$[ebp]

; 160  :          iRepeatSamples = 0;

  00081	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _iRepeatSamples$[ebp], 0

; 161  :    
; 162  :          /*-------------------------------------------------------------------
; 163  :          | Set the parameters for a 10ms sub-frame
; 164  :          -------------------------------------------------------------------*/
; 165  :          if (fInterpFactor < INTERP_FACTOR_SMALL)

  00088	d9 45 f8	 fld	 DWORD PTR _fInterpFactor$[ebp]
  0008b	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3e800000
  00091	df e0		 fnstsw	 ax
  00093	f6 c4 05	 test	 ah, 5
  00096	7a 3a		 jp	 SHORT $L1643

; 166  :          {  
; 167  :             /*----------------------------------------------------------------
; 168  :             | Use parameters from previous frame (previous 20 ms analysis)
; 169  :             ----------------------------------------------------------------*/
; 170  :            pSubParamSyn =  &(pDecMemBlk->PrevSubParam);

  00098	8b 45 e8	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  0009b	83 c0 34	 add	 eax, 52			; 00000034H
  0009e	89 45 a8	 mov	 DWORD PTR _pSubParamSyn$[ebp], eax

; 171  :            fPitchPeriod_1 = pDecMemBlk->Pitch_1_mid;

  000a1	8b 4d e8	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  000a4	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000a7	89 55 f0	 mov	 DWORD PTR _fPitchPeriod_1$[ebp], edx

; 172  :            piCountSyn = &(pDecMemBlk->piFrameCount[0]);

  000aa	8b 45 e8	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  000ad	05 84 00 00 00	 add	 eax, 132		; 00000084H
  000b2	89 45 f4	 mov	 DWORD PTR _piCountSyn$[ebp], eax

; 173  :            if (pDecMemBlk->iFramesRepeated)

  000b5	8b 4d e8	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  000b8	83 79 7c 00	 cmp	 DWORD PTR [ecx+124], 0
  000bc	74 12		 je	 SHORT $L1644

; 174  :                iRepeatSamples = (pDecMemBlk->iFramesRepeated-1)*FRAME_LENGTH_SC;

  000be	8b 55 e8	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  000c1	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  000c4	83 e8 01	 sub	 eax, 1
  000c7	69 c0 a0 00 00
	00		 imul	 eax, 160		; 000000a0H
  000cd	89 45 d8	 mov	 DWORD PTR _iRepeatSamples$[ebp], eax
$L1644:

; 175  :          } 
; 176  :          else {

  000d0	eb 65		 jmp	 SHORT $L1645
$L1643:

; 177  :            if (fInterpFactor < INTERP_FACTOR_MED)

  000d2	d9 45 f8	 fld	 DWORD PTR _fInterpFactor$[ebp]
  000d5	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f400000
  000db	df e0		 fnstsw	 ax
  000dd	f6 c4 05	 test	 ah, 5
  000e0	7a 1d		 jp	 SHORT $L1646

; 178  :            {
; 179  :               /*----------------------------------------------------------------
; 180  :               | Use parameters from mid-frame frame (current 10 ms analysis)
; 181  :               ----------------------------------------------------------------*/
; 182  :               pSubParamSyn = &(pSubParamMblk[PARAM_MIDFRAME]);

  000e2	8b 4d cc	 mov	 ecx, DWORD PTR _pSubParamMblk$[ebp]
  000e5	89 4d a8	 mov	 DWORD PTR _pSubParamSyn$[ebp], ecx

; 183  :               fPitchPeriod_1 = pDecMemBlk->PrevSubParam.Pitch;           

  000e8	8b 55 e8	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  000eb	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  000ee	89 45 f0	 mov	 DWORD PTR _fPitchPeriod_1$[ebp], eax

; 184  :               piCountSyn = &(pDecMemBlk->piFrameCount[1]);

  000f1	8b 4d e8	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  000f4	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  000fa	89 4d f4	 mov	 DWORD PTR _piCountSyn$[ebp], ecx

; 185  :            } else { 

  000fd	eb 1d		 jmp	 SHORT $L1647
$L1646:

; 186  :              /*----------------------------------------------------------------
; 187  :              | Use parameters from outer frame (current 20 ms analysis)
; 188  :              ----------------------------------------------------------------*/
; 189  :              pSubParamSyn = &(pSubParamMblk[PARAM_ENDFRAME]);

  000ff	8b 55 cc	 mov	 edx, DWORD PTR _pSubParamMblk$[ebp]
  00102	83 c2 28	 add	 edx, 40			; 00000028H
  00105	89 55 a8	 mov	 DWORD PTR _pSubParamSyn$[ebp], edx

; 190  :              fPitchPeriod_1 = pSubParamMblk[PARAM_MIDFRAME].Pitch;

  00108	8b 45 cc	 mov	 eax, DWORD PTR _pSubParamMblk$[ebp]
  0010b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010d	89 4d f0	 mov	 DWORD PTR _fPitchPeriod_1$[ebp], ecx

; 191  :              piCountSyn = &(pDecMemBlk->piFrameCount[2]);

  00110	8b 55 e8	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00113	81 c2 8c 00 00
	00		 add	 edx, 140		; 0000008cH
  00119	89 55 f4	 mov	 DWORD PTR _piCountSyn$[ebp], edx
$L1647:

; 192  :            }
; 193  : 
; 194  :            OffsetFlag     = pDecMemBlk->iSetOffsetFlag;

  0011c	8b 45 e8	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  0011f	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00125	89 4d a4	 mov	 DWORD PTR _OffsetFlag$[ebp], ecx

; 195  :            iRepeatSamples = pDecMemBlk->iFramesRepeated*FRAME_LENGTH_SC;

  00128	8b 55 e8	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  0012b	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  0012e	69 c0 a0 00 00
	00		 imul	 eax, 160		; 000000a0H
  00134	89 45 d8	 mov	 DWORD PTR _iRepeatSamples$[ebp], eax
$L1645:

; 196  :          } 
; 197  : 
; 198  :          /*----------------------------------------------------------------
; 199  :          | Count points to the counter for the number of times the 
; 200  :          |   current sub-frame parameters have been synthesized. iCount_1 
; 201  :          |   is the number of times the previous sub-frame parameters 
; 202  :          |   were synthesized.  
; 203  :          |
; 204  :          | Increment the count.
; 205  :          ----------------------------------------------------------------*/
; 206  :          piCountSyn[1] ++;

  00137	8b 4d f4	 mov	 ecx, DWORD PTR _piCountSyn$[ebp]
  0013a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0013d	83 c2 01	 add	 edx, 1
  00140	8b 45 f4	 mov	 eax, DWORD PTR _piCountSyn$[ebp]
  00143	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 207  :          fOffsetPitchPeriod = pSubParamSyn->Pitch;

  00146	8b 4d a8	 mov	 ecx, DWORD PTR _pSubParamSyn$[ebp]
  00149	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014b	89 55 fc	 mov	 DWORD PTR _fOffsetPitchPeriod$[ebp], edx

; 208  : 
; 209  :          /*----------------------------------------------------------------
; 210  :          | If the count is more than 1 (i.e. the sub-frame parameters have 
; 211  :          |   been used before) then the linear phase offset must be INCREASED
; 212  :          |   by an amount corresponding to HALF_FRAME_LENGTH_SC samples. The 
; 213  :          |   pitch period for this is the pitch period of the current sub-frame.
; 214  :          |   NOTE: The sub-frame can be repeated as many times as 
; 215  :          |   desired since the phase offset is cumulative.
; 216  :          ----------------------------------------------------------------*/
; 217  :          if (piCountSyn[1] > 1)  

  0014e	8b 45 f4	 mov	 eax, DWORD PTR _piCountSyn$[ebp]
  00151	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  00155	7e 09		 jle	 SHORT $L1648

; 218  :             iOffsetSamples = HALF_FRAME_LENGTH_SC;

  00157	c7 45 dc 50 00
	00 00		 mov	 DWORD PTR _iOffsetSamples$[ebp], 80 ; 00000050H

; 219  :          /*----------------------------------------------------------------
; 220  :          | If the count is 1 (i.e. the first time these sub-frame parameters 
; 221  :          |   are used) but iCount_1 is zero (i.e. the previous sub-frame 
; 222  :          |   parameters were skipped) then the linear phase offset must be 
; 223  :          |   DECREASED by an amount corresponding to HALF_FRAME_LENGTH_SC 
; 224  :          |   samples. The pitch period for this is the pitch period of the 
; 225  :          |   sub-frame that was skipped.
; 226  :          |   NOTE: This assumes that a maximum of 1 consecutive sub-frame 
; 227  :          |   will be skipped.  If more than 1 consecutive sub-frame is
; 228  :          |   skipped, the phase offset will not be accounted for.
; 229  :          ----------------------------------------------------------------*/
; 230  :          else if ((piCountSyn[0]==0) && (piCountSyn[1]==1))

  0015e	eb 27		 jmp	 SHORT $L1649
$L1648:
  00160	8b 4d f4	 mov	 ecx, DWORD PTR _piCountSyn$[ebp]
  00163	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00166	75 18		 jne	 SHORT $L1650
  00168	8b 55 f4	 mov	 edx, DWORD PTR _piCountSyn$[ebp]
  0016b	83 7a 04 01	 cmp	 DWORD PTR [edx+4], 1
  0016f	75 0f		 jne	 SHORT $L1650

; 231  :          {
; 232  :             iOffsetSamples = -HALF_FRAME_LENGTH_SC;

  00171	c7 45 dc b0 ff
	ff ff		 mov	 DWORD PTR _iOffsetSamples$[ebp], -80 ; ffffffb0H

; 233  :             fOffsetPitchPeriod = fPitchPeriod_1;

  00178	8b 45 f0	 mov	 eax, DWORD PTR _fPitchPeriod_1$[ebp]
  0017b	89 45 fc	 mov	 DWORD PTR _fOffsetPitchPeriod$[ebp], eax

; 234  :          }
; 235  :          /*----------------------------------------------------------------
; 236  :          | Count is 1 (i.e. the first time these sub-frame parameters
; 237  :          |   are used) and iCount_1 is not zero (i.e. the previous sub-frame
; 238  :          |   parameters were not skipped) so there is no need to change
; 239  :          |   the phase offset.
; 240  :          ----------------------------------------------------------------*/
; 241  :          else

  0017e	eb 07		 jmp	 SHORT $L1649
$L1650:

; 242  :             iOffsetSamples = 0;

  00180	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _iOffsetSamples$[ebp], 0
$L1649:

; 243  : 
; 244  :          /*--------------------------------------------------------------------
; 245  :          | Possibly update the phase offset in VoxHFRegeneration(). This is
; 246  :          |   done when entire frames have been skipped, or when frames have
; 247  :          |   been repeated.  In either of these cases the measured phases
; 248  :          |   have a discontinuity in their embeded linear phases.
; 249  :          --------------------------------------------------------------------*/
; 250  :          if (OffsetFlag > 0) 

  00187	83 7d a4 00	 cmp	 DWORD PTR _OffsetFlag$[ebp], 0
  0018b	7e 14		 jle	 SHORT $L1652

; 251  :          {
; 252  :             iUpdatePhaseOffsetFlag = 1;

  0018d	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _iUpdatePhaseOffsetFlag$[ebp], 1

; 253  :             pDecMemBlk->iSetOffsetFlag = 0;

  00194	8b 4d e8	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00197	c7 81 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+128], 0
$L1652:

; 254  :          }
; 255  :      
; 256  :          /*--------------------------------------------------------------------
; 257  :          | Set the voicing-depdendent bit rate for the synthesizer
; 258  :          --------------------------------------------------------------------*/
; 259  :          if ((pDecMemBlk->iSCTargetRate==SC_RATE_6K) && 
; 260  :              (iSCRateSyn==SC_RATE_3K) &&
; 261  :              (pSubParamSyn->Pv>PV_SWITCH_THRESH))

  001a1	8b 55 e8	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  001a4	83 7a 20 02	 cmp	 DWORD PTR [edx+32], 2
  001a8	75 22		 jne	 SHORT $L1653
  001aa	83 7d ec 01	 cmp	 DWORD PTR _iSCRateSyn$[ebp], 1
  001ae	75 1c		 jne	 SHORT $L1653
  001b0	8b 45 a8	 mov	 eax, DWORD PTR _pSubParamSyn$[ebp]
  001b3	d9 40 04	 fld	 DWORD PTR [eax+4]
  001b6	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3e000000
  001bc	df e0		 fnstsw	 ax
  001be	f6 c4 41	 test	 ah, 65			; 00000041H
  001c1	75 09		 jne	 SHORT $L1653

; 262  :             iSCRateSyn = SC_RATE_3K;

  001c3	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iSCRateSyn$[ebp], 1

; 263  :          else 

  001ca	eb 09		 jmp	 SHORT $L1654
$L1653:

; 264  :             iSCRateSyn = pDecMemBlk->iSCTargetRate;

  001cc	8b 4d e8	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  001cf	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001d2	89 55 ec	 mov	 DWORD PTR _iSCRateSyn$[ebp], edx
$L1654:

; 265  :       
; 266  :          /*--------------------------------------------------------------------
; 267  :          | Add a linear phase offset to the measured phases to account for
; 268  :          |   time warping.  (If iOffsetSamples==0 there is no additional
; 269  :          |   linear phase offset added)
; 270  :          --------------------------------------------------------------------*/
; 271  :          if (pDecMemBlk->iSCTargetRate==SC_RATE_6K)

  001d5	8b 45 e8	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  001d8	83 78 20 02	 cmp	 DWORD PTR [eax+32], 2
  001dc	75 23		 jne	 SHORT $L1655

; 272  :             OffsetMeasuresPhases( pSubParamSyn->pfVEVphase,
; 273  :                                   &(pDecMemBlk->fPhaseOffset), 
; 274  :                                   iOffsetSamples, fOffsetPitchPeriod, 
; 275  :                                   pfVEVphaseSyn,
; 276  :                                   iRepeatSamples);

  001de	8b 4d d8	 mov	 ecx, DWORD PTR _iRepeatSamples$[ebp]
  001e1	51		 push	 ecx
  001e2	8d 55 ac	 lea	 edx, DWORD PTR _pfVEVphaseSyn$[ebp]
  001e5	52		 push	 edx
  001e6	8b 45 fc	 mov	 eax, DWORD PTR _fOffsetPitchPeriod$[ebp]
  001e9	50		 push	 eax
  001ea	8b 4d dc	 mov	 ecx, DWORD PTR _iOffsetSamples$[ebp]
  001ed	51		 push	 ecx
  001ee	8b 55 e8	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  001f1	83 c2 6c	 add	 edx, 108		; 0000006cH
  001f4	52		 push	 edx
  001f5	8b 45 a8	 mov	 eax, DWORD PTR _pSubParamSyn$[ebp]
  001f8	83 c0 08	 add	 eax, 8
  001fb	50		 push	 eax
  001fc	e8 00 00 00 00	 call	 _OffsetMeasuresPhases@24
$L1655:

; 277  : 
; 278  :          /*--------------------------------------------------------------------
; 279  :          | Synthesize 10 ms of Speech
; 280  :          --------------------------------------------------------------------*/
; 281  :          VoxSWSynth(STACK_S pDecMemBlk->hHFRegenMblk,
; 282  :                     iSCRateSyn, pfSynSpeech, pfVEVphaseSyn,
; 283  :                     pDecMemBlk->pWaveform_1, 
; 284  :                     pSubParamSyn->Pitch, pSubParamSyn->Pv,
; 285  :                     pfEnv, pDecMemBlk->pfEnv_1, 
; 286  :                     pfPhase, pDecMemBlk->pfPhase_1, 
; 287  :                     fInterpFactor, iUpdatePhaseOffsetFlag,
; 288  :                     &(pDecMemBlk->lUVPhaseRandSeed));

  00201	8b 4d e8	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00204	83 c1 24	 add	 ecx, 36			; 00000024H
  00207	51		 push	 ecx
  00208	8b 55 d4	 mov	 edx, DWORD PTR _iUpdatePhaseOffsetFlag$[ebp]
  0020b	52		 push	 edx
  0020c	8b 45 f8	 mov	 eax, DWORD PTR _fInterpFactor$[ebp]
  0020f	50		 push	 eax
  00210	8b 4d e8	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00213	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00216	52		 push	 edx
  00217	8b 45 18	 mov	 eax, DWORD PTR _pfPhase$[ebp]
  0021a	50		 push	 eax
  0021b	8b 4d e8	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  0021e	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00221	52		 push	 edx
  00222	8b 45 14	 mov	 eax, DWORD PTR _pfEnv$[ebp]
  00225	50		 push	 eax
  00226	8b 4d a8	 mov	 ecx, DWORD PTR _pSubParamSyn$[ebp]
  00229	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0022c	52		 push	 edx
  0022d	8b 45 a8	 mov	 eax, DWORD PTR _pSubParamSyn$[ebp]
  00230	8b 08		 mov	 ecx, DWORD PTR [eax]
  00232	51		 push	 ecx
  00233	8b 55 e8	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00236	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00239	50		 push	 eax
  0023a	8d 4d ac	 lea	 ecx, DWORD PTR _pfVEVphaseSyn$[ebp]
  0023d	51		 push	 ecx
  0023e	8b 55 e0	 mov	 edx, DWORD PTR _pfSynSpeech$[ebp]
  00241	52		 push	 edx
  00242	8b 45 ec	 mov	 eax, DWORD PTR _iSCRateSyn$[ebp]
  00245	50		 push	 eax
  00246	8b 4d e8	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00249	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0024c	52		 push	 edx
  0024d	e8 00 00 00 00	 call	 _VoxSWSynth@56

; 289  :       
; 290  :          /*--------------------------------------------------------------------
; 291  :          | increment speech pointer, time offset, and sample count
; 292  :          --------------------------------------------------------------------*/
; 293  :          pfSynSpeech                += HALF_FRAME_LENGTH_SC;

  00252	8b 45 e0	 mov	 eax, DWORD PTR _pfSynSpeech$[ebp]
  00255	05 40 01 00 00	 add	 eax, 320		; 00000140H
  0025a	89 45 e0	 mov	 DWORD PTR _pfSynSpeech$[ebp], eax

; 294  :          *piSynSamples              += HALF_FRAME_LENGTH_SC;

  0025d	8b 4d 1c	 mov	 ecx, DWORD PTR _piSynSamples$[ebp]
  00260	8b 11		 mov	 edx, DWORD PTR [ecx]
  00262	83 c2 50	 add	 edx, 80			; 00000050H
  00265	8b 45 1c	 mov	 eax, DWORD PTR _piSynSamples$[ebp]
  00268	89 10		 mov	 DWORD PTR [eax], edx

; 295  :          pDecMemBlk->fSynTimeOffset += HALF_FRAME_LENGTH_SC;

  0026a	8b 4d e8	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  0026d	d9 41 68	 fld	 DWORD PTR [ecx+104]
  00270	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@42a00000
  00276	8b 55 e8	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00279	d9 5a 68	 fstp	 DWORD PTR [edx+104]

; 296  :  
; 297  :          /*--------------------------------------------------------------------
; 298  :          | save synthesis rate flag
; 299  :          --------------------------------------------------------------------*/
; 300  :          pDecMemBlk->iSCRate_1 = iSCRateSyn;

  0027c	8b 45 e8	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  0027f	8b 4d ec	 mov	 ecx, DWORD PTR _iSCRateSyn$[ebp]
  00282	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L1642:

; 301  :       }
; 302  :    }

  00285	e9 bd fd ff ff	 jmp	 $L1640
$L1641:

; 303  : 
; 304  : 
; 305  :    /*--------------------------------------------------------------------
; 306  :      If (fSynTimeOffset>fFrameTime) then set the flag for a new frame
; 307  :        next time
; 308  :    --------------------------------------------------------------------*/
; 309  :    if (pDecMemBlk->fSynTimeOffset>fFrameTime)

  0028a	8b 55 e8	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  0028d	d9 42 68	 fld	 DWORD PTR [edx+104]
  00290	d8 5d e4	 fcomp	 DWORD PTR _fFrameTime$[ebp]
  00293	df e0		 fnstsw	 ax
  00295	f6 c4 41	 test	 ah, 65			; 00000041H
  00298	75 19		 jne	 SHORT $L1620

; 310  :    {
; 311  :       pDecMemBlk->iNewFrame  = 1;

  0029a	8b 45 e8	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  0029d	c7 40 64 01 00
	00 00		 mov	 DWORD PTR [eax+100], 1

; 312  : 
; 313  :       /*----------------------------------------------------------------------
; 314  :         Advance the time reference. (i.e. pParamMblk becomes pParamMblk_1
; 315  :           so the current value of fFrameTime is moved to 0)
; 316  :       ----------------------------------------------------------------------*/
; 317  :       pDecMemBlk->fSynTimeOffset -= fFrameTime;

  002a4	8b 4d e8	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  002a7	d9 41 68	 fld	 DWORD PTR [ecx+104]
  002aa	d8 65 e4	 fsub	 DWORD PTR _fFrameTime$[ebp]
  002ad	8b 55 e8	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  002b0	d9 5a 68	 fstp	 DWORD PTR [edx+104]
$L1620:

; 318  :    }
; 319  : 
; 320  :   STACK_END
; 321  : }

  002b3	8b e5		 mov	 esp, ebp
  002b5	5d		 pop	 ebp
  002b6	c2 18 00	 ret	 24			; 00000018H
_SubFrameSynth@24 ENDP
_TEXT	ENDS
PUBLIC	__real@40c90fdb
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _OffsetMeasuresPhases@24
_TEXT	SEGMENT
_fRatio$ = -16
_i$ = -12
_fPhi$ = -8
_fPhaseOffset$ = -4
_pfVEVphase$ = 8
_pfCumPhaseOffset$ = 12
_iWarpSamples$ = 16
_fPitchPeriod$ = 20
_pfVEVphaseSyn$ = 24
_iRepeatSamples$ = 28
_OffsetMeasuresPhases@24 PROC NEAR			; COMDAT

; 337  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 338  :    int   i;
; 339  :    float fPhi;
; 340  :    float fPhaseOffset;
; 341  :    float fRatio;
; 342  :  
; 343  :    fRatio = TWOPI/fPitchPeriod;

  00006	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40c90fdb
  0000c	d8 75 14	 fdiv	 DWORD PTR _fPitchPeriod$[ebp]
  0000f	d9 5d f0	 fstp	 DWORD PTR _fRatio$[ebp]

; 344  :    *pfCumPhaseOffset += ((float)iWarpSamples)*fRatio;

  00012	db 45 10	 fild	 DWORD PTR _iWarpSamples$[ebp]
  00015	d8 4d f0	 fmul	 DWORD PTR _fRatio$[ebp]
  00018	8b 45 0c	 mov	 eax, DWORD PTR _pfCumPhaseOffset$[ebp]
  0001b	d8 00		 fadd	 DWORD PTR [eax]
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _pfCumPhaseOffset$[ebp]
  00020	d9 19		 fstp	 DWORD PTR [ecx]

; 345  : 
; 346  :    fPhaseOffset = *pfCumPhaseOffset + ((float)iRepeatSamples)*fRatio;

  00022	db 45 1c	 fild	 DWORD PTR _iRepeatSamples$[ebp]
  00025	d8 4d f0	 fmul	 DWORD PTR _fRatio$[ebp]
  00028	8b 55 0c	 mov	 edx, DWORD PTR _pfCumPhaseOffset$[ebp]
  0002b	d8 02		 fadd	 DWORD PTR [edx]
  0002d	d9 5d fc	 fstp	 DWORD PTR _fPhaseOffset$[ebp]

; 347  : 
; 348  :    fPhi = 0.0F;

  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fPhi$[ebp], 0

; 349  :    for (i=SC6_PHASES; i > 0; i--)

  00037	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _i$[ebp], 8
  0003e	eb 09		 jmp	 SHORT $L1676
$L1677:
  00040	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00043	83 e8 01	 sub	 eax, 1
  00046	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$L1676:
  00049	83 7d f4 00	 cmp	 DWORD PTR _i$[ebp], 0
  0004d	7e 2a		 jle	 SHORT $L1669

; 350  :    {
; 351  :       fPhi += fPhaseOffset;

  0004f	d9 45 f8	 fld	 DWORD PTR _fPhi$[ebp]
  00052	d8 45 fc	 fadd	 DWORD PTR _fPhaseOffset$[ebp]
  00055	d9 5d f8	 fstp	 DWORD PTR _fPhi$[ebp]

; 352  :       *pfVEVphaseSyn++ = *pfVEVphase++ + fPhi;

  00058	8b 4d 08	 mov	 ecx, DWORD PTR _pfVEVphase$[ebp]
  0005b	d9 45 f8	 fld	 DWORD PTR _fPhi$[ebp]
  0005e	d8 01		 fadd	 DWORD PTR [ecx]
  00060	8b 55 18	 mov	 edx, DWORD PTR _pfVEVphaseSyn$[ebp]
  00063	d9 1a		 fstp	 DWORD PTR [edx]
  00065	8b 45 18	 mov	 eax, DWORD PTR _pfVEVphaseSyn$[ebp]
  00068	83 c0 04	 add	 eax, 4
  0006b	89 45 18	 mov	 DWORD PTR _pfVEVphaseSyn$[ebp], eax
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _pfVEVphase$[ebp]
  00071	83 c1 04	 add	 ecx, 4
  00074	89 4d 08	 mov	 DWORD PTR _pfVEVphase$[ebp], ecx

; 353  :    }

  00077	eb c7		 jmp	 SHORT $L1677
$L1669:

; 354  : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 18 00	 ret	 24			; 00000018H
_OffsetMeasuresPhases@24 ENDP
_TEXT	ENDS
END
