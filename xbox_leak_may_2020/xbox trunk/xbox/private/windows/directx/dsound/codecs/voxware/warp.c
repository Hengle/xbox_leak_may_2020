/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:        warp.c
* Purpose:         Spectral warping
* Functions:
* Author/Date:     Bob Dunn 10/7/97
*******************************************************************************
*
* Modifications:
*
* Comments:
*           This code applies the warping function corresponding 
*             to the parameter values:
*
*             #define FC_LINEAR   1200.0F
*             #define BW_LINEAR     95.0F
*             #define BW_MAX       200.0F
*             #define FREQ_DC        0.0F
*             #define FREQ_LPC    4000.0F
*
*             The floating point and fixed point computation of indices
*             are both matlab approximations of the tabular version.
*             The approximation assumes PI=256 DFT samples.
*             For the fixed point code, the approximation is linear 
*             below 87 DFT samples and quadratic at and above 87 DFT 
*             samples.   For the floating point code the cutoff is
*             at 97.  It may appear inconsistent that these cutoffs
*             are different, but the curve is still pretty linear
*             betweern 87 and 97 DFT samples.
*
*             The fixed point version of the approximation will work on
*             16 bit platforms.  The indices generated by the fixed point 
*             version vary by +/- 1 from the floating point version.
*             Also, for the UnWarp function, the indices generated by 
*             the fixed point version are not monotonically increasing.
*
*             The code can only warp and unwarp 256 point envelopes.
*             The code allows for warping in place (i.e. the
*             input and output arrays can be the same).
*
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/utils/warp.c_v   1.7   10 Apr 1998 15:29:36   bobd  $
*
******************************************************************************/
#include <math.h>
#include <assert.h>

#include "vLibMath.h"
#include "VoxMem.h"
#include "codec.h"

#include "warp.h"

#include "xvocver.h"

/*---------------------------------------------------------------------
  The coefficients below are for the linear and quadratic 
    approximations to the warping curve.  The coefficients are
    divisible by 2^8 or 2^17 to facilitate writing a fixed point
    version of the code.  

  IMPORTANT NOTE:  The quadratic curve is guaranteed to stay below
    256.0 if the input frequency is less than 256.0.  This is very
    important in SetAmps.c because the returned frequency(/index)
    will be out of bounds if this condition does not hold.
---------------------------------------------------------------------*/
#define QUAD_C    1.78906250F       /* (2^8)*QUAD_C is an integer    */
#define QUAD_B    1.40234375F       /* (2^8)*QUAD_B is an integer    */
#define QUAD_A   -0.00160217285156F /* (2^17)*QUAD_A is an integer   */
#define LINEAR_A  1.26953125F       /* (2^8)*LINEAR_A is an integer  */

/*******************************************************************************
*
* Function:  VoxWarpSC36()
*
* Action:    Perceptually warp a spectral magnitude or phase envelope. The 
*              warping function streatches low frequency regions and
*              compresses high frequency regions.  The warping function
*              is linear in the low end an quadratic in the high end.
*
* Input:     float *pfIn  --> 256 point envelope (magintude or phase)
*                               on a linear scale.
*            
* Output:    float *pfOut --> 256 point envelope (magintude or phase)
*                               on a non-linear perceptually warped scale.
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:  1) The warping may be done in place (i.e. pfIn=pfOut).
*            2) The fixed point index computation is valid for 16 bit
*                 as well as 32 bit word lengths.  This was written in
*                 fixed point for speed.
*            3) If speed is more important that memory size, this code
*                 should be implemented with a look-up table using
*                 256 words of ROM.
*
* Concerns/TBD:
*******************************************************************************/

void VoxWarpSC36( float *pfIn, float *pfOut)
{
   unsigned int i;
   unsigned long i0;
   unsigned long lIndex;
   unsigned int iIndex;

   /*--------------------------------------------------------
     Skip to the end of the pfOut array.  By starting at the 
       end of the array where the envelope is compressed, 
       the warping may be done in place.
   --------------------------------------------------------*/
   pfOut += 255;

   /*--------------------------------------------------------
     Set the initial value for i0 in the quadratic region.  
       This is: i0 = 162*255+128 = 41600
   --------------------------------------------------------*/
   i0 = 41600L;

   /*--------------------------------------------------------
     Compute warping indices with a quadratic curve in the
       region (86 < i < 256)
   --------------------------------------------------------*/
   for (i=255; i>86; i--)
   {
      i0 -= 162L;
      lIndex = i0 >> 8;
      lIndex += 65;
      lIndex *= i;
      lIndex += 209;
      iIndex = (int)(lIndex >> 8);
      iIndex += 29;
      *pfOut-- = pfIn[iIndex];
   }
 
   /*--------------------------------------------------------
     Set the initial value for i0 in the linear region.  
        This is: i0 = 203*87+128 = 17789
   --------------------------------------------------------*/
    i0 = 17789L;

   /*--------------------------------------------------------
     Compute warping indices with a linear curve in the
       region (0 < i < 87)
   --------------------------------------------------------*/
   for (i=87; i; i--)
   {
     i0 -= 203L;
     iIndex = (int)(i0>>8);
     *pfOut-- = pfIn[iIndex];
   }
}
 
/*******************************************************************************
*
* Function:  CaldWarpedFreq()
*
* Action:    Given a frequency in DFT samples on a linear scale, compute
*              the corresponding warped frequency.
*
* Input:     float --> frequency in DFT samples on a linear scale
*
* Output:    float --> frequency in DFT samples on the warped scale
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

float CalcWarpedFreq( float fLinFreq )
{
   float fWarpedFreq;

   if (fLinFreq>97.0F)
   {
      /*-----------------------------------------------------
        Approximate the warping function with a quadratic
          for frequencies above 97 DFT samples.
      -----------------------------------------------------*/
      fWarpedFreq = QUAD_C + fLinFreq*(QUAD_B+QUAD_A*fLinFreq);
   } else {
      /*-----------------------------------------------------
        Approximate the warping function with a straight line
          for frequencies below 97 DFT samples.
      -----------------------------------------------------*/
      fWarpedFreq = LINEAR_A*fLinFreq;
   }

   return( fWarpedFreq );
}

