; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\vcipvr12.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _vciSetWarpFactorVR12@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciGetWarpFactorVR12@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciDecodeNeedsInputVR12@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciGetEnergyVR12@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciSetInjectSilenceFlagVR12@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciNumFramesInBufferVR12@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciSeekForwardVR12@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciGetPlusInfoVR12@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciPlusInitVR12@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciPlusFreeVR12@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_vciSetWarpFactorVR12@8
PUBLIC	__real@3e4ccccd
PUBLIC	__real@40a00000
EXTRN	__fltused:NEAR
;	COMDAT __real@3e4ccccd
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\vcipvr12.c
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciSetWarpFactorVR12@8
_TEXT	SEGMENT
_vciCodecMblk$ = -4
_hCodecMemBlk$ = 8
_wWarpFactor$ = 12
_vciSetWarpFactorVR12@8 PROC NEAR			; COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 64   :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 65   : 
; 66   :    if(!VCI_BLOCK_CHECK(hCodecMemBlk))

  0000b	83 7d 08 00	 cmp	 DWORD PTR _hCodecMemBlk$[ebp], 0
  0000f	74 0b		 je	 SHORT $L1437
  00011	8b 45 08	 mov	 eax, DWORD PTR _hCodecMemBlk$[ebp]
  00014	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0001a	74 06		 je	 SHORT $L1436
$L1437:

; 67   :       return VCI_NOT_VCI_HANDLE;

  0001c	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00020	eb 4d		 jmp	 SHORT $L1432
$L1436:

; 68   : 
; 69   :    if(!VCI_IS_DECODE(hCodecMemBlk))

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _hCodecMemBlk$[ebp]
  00025	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00029	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0002c	74 06		 je	 SHORT $L1439

; 70   :       return VCI_NOT_DEC_HANDLE;

  0002e	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  00032	eb 3b		 jmp	 SHORT $L1432
$L1439:

; 71   : 
; 72   :    vciCodecMblk = (VCI_CODEC_BLOCK *)hCodecMemBlk;

  00034	8b 45 08	 mov	 eax, DWORD PTR _hCodecMemBlk$[ebp]
  00037	89 45 fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax

; 73   : 
; 74   :    if(wWarpFactor<MIN_WARP||wWarpFactor>MAX_WARP)

  0003a	d9 45 0c	 fld	 DWORD PTR _wWarpFactor$[ebp]
  0003d	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3e4ccccd
  00043	df e0		 fnstsw	 ax
  00045	f6 c4 05	 test	 ah, 5
  00048	7b 10		 jnp	 SHORT $L1442
  0004a	d9 45 0c	 fld	 DWORD PTR _wWarpFactor$[ebp]
  0004d	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@40a00000
  00053	df e0		 fnstsw	 ax
  00055	f6 c4 41	 test	 ah, 65			; 00000041H
  00058	75 06		 jne	 SHORT $L1441
$L1442:

; 75   :       return VCI_ARG_OUT_OF_RANGE;

  0005a	66 b8 15 18	 mov	 ax, 6165		; 00001815H
  0005e	eb 0f		 jmp	 SHORT $L1432
$L1441:

; 76   : 
; 77   :    (((DEC_MEM_BLK*)vciCodecMblk->hCodecMblk)->fWarpedLengthFactor)=wWarpFactor;

  00060	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00063	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00066	8b 45 0c	 mov	 eax, DWORD PTR _wWarpFactor$[ebp]
  00069	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 78   : 
; 79   :   return VCI_NO_ERROR;

  0006c	66 33 c0	 xor	 ax, ax
$L1432:

; 80   : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8
_vciSetWarpFactorVR12@8 ENDP
_TEXT	ENDS
PUBLIC	_vciGetWarpFactorVR12@8
; Function compile flags: /Odt
;	COMDAT _vciGetWarpFactorVR12@8
_TEXT	SEGMENT
_vciCodecMblk$ = -4
_hCodecMemBlk$ = 8
_pwWarpFactor$ = 12
_vciGetWarpFactorVR12@8 PROC NEAR			; COMDAT

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 93   :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 94   : 
; 95   :    if(!VCI_BLOCK_CHECK(hCodecMemBlk))

  0000b	83 7d 08 00	 cmp	 DWORD PTR _hCodecMemBlk$[ebp], 0
  0000f	74 0b		 je	 SHORT $L1453
  00011	8b 45 08	 mov	 eax, DWORD PTR _hCodecMemBlk$[ebp]
  00014	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0001a	74 06		 je	 SHORT $L1452
$L1453:

; 96   :       return VCI_NOT_VCI_HANDLE;

  0001c	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00020	eb 35		 jmp	 SHORT $L1448
$L1452:

; 97   : 
; 98   :    if(!VCI_IS_DECODE(hCodecMemBlk))

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _hCodecMemBlk$[ebp]
  00025	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00029	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0002c	74 06		 je	 SHORT $L1455

; 99   :       return VCI_NOT_DEC_HANDLE;

  0002e	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  00032	eb 23		 jmp	 SHORT $L1448
$L1455:

; 100  : 
; 101  :    if(!pwWarpFactor)

  00034	83 7d 0c 00	 cmp	 DWORD PTR _pwWarpFactor$[ebp], 0
  00038	75 06		 jne	 SHORT $L1456

; 102  :       return VCI_NULL_ARG;

  0003a	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  0003e	eb 17		 jmp	 SHORT $L1448
$L1456:

; 103  : 
; 104  :    vciCodecMblk = (VCI_CODEC_BLOCK *)hCodecMemBlk;

  00040	8b 45 08	 mov	 eax, DWORD PTR _hCodecMemBlk$[ebp]
  00043	89 45 fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax

; 105  : 
; 106  :    *pwWarpFactor=(((DEC_MEM_BLK*)vciCodecMblk->hCodecMblk)->fWarpedLengthFactor);

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00049	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004c	d9 42 2c	 fld	 DWORD PTR [edx+44]
  0004f	8b 45 0c	 mov	 eax, DWORD PTR _pwWarpFactor$[ebp]
  00052	d9 18		 fstp	 DWORD PTR [eax]

; 107  :    
; 108  :    return VCI_NO_ERROR;

  00054	66 33 c0	 xor	 ax, ax
$L1448:

; 109  : }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
_vciGetWarpFactorVR12@8 ENDP
_TEXT	ENDS
PUBLIC	_vciDecodeNeedsInputVR12@8
; Function compile flags: /Odt
;	COMDAT _vciDecodeNeedsInputVR12@8
_TEXT	SEGMENT
_vciCodecMblk$ = -4
_hCodecMemBlk$ = 8
_pUnPack$ = 12
_vciDecodeNeedsInputVR12@8 PROC NEAR			; COMDAT

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 120  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 121  : 
; 122  :    if(!VCI_BLOCK_CHECK(hCodecMemBlk))

  0000b	83 7d 08 00	 cmp	 DWORD PTR _hCodecMemBlk$[ebp], 0
  0000f	74 0b		 je	 SHORT $L1468
  00011	8b 45 08	 mov	 eax, DWORD PTR _hCodecMemBlk$[ebp]
  00014	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0001a	74 06		 je	 SHORT $L1467
$L1468:

; 123  :       return VCI_NOT_VCI_HANDLE;

  0001c	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00020	eb 35		 jmp	 SHORT $L1463
$L1467:

; 124  : 
; 125  :    if(!VCI_IS_DECODE(hCodecMemBlk))

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _hCodecMemBlk$[ebp]
  00025	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00029	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0002c	74 06		 je	 SHORT $L1470

; 126  :       return VCI_NOT_DEC_HANDLE;

  0002e	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  00032	eb 23		 jmp	 SHORT $L1463
$L1470:

; 127  : 
; 128  :    if(!pUnPack)

  00034	83 7d 0c 00	 cmp	 DWORD PTR _pUnPack$[ebp], 0
  00038	75 06		 jne	 SHORT $L1471

; 129  :       return VCI_NULL_ARG;

  0003a	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  0003e	eb 17		 jmp	 SHORT $L1463
$L1471:

; 130  : 
; 131  :    vciCodecMblk = (VCI_CODEC_BLOCK *)hCodecMemBlk;

  00040	8b 45 08	 mov	 eax, DWORD PTR _hCodecMemBlk$[ebp]
  00043	89 45 fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax

; 132  : 
; 133  :    *pUnPack=((DEC_MEM_BLK*)vciCodecMblk->hCodecMblk)->unpackFLAG;

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00049	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004c	8b 45 0c	 mov	 eax, DWORD PTR _pUnPack$[ebp]
  0004f	8a 4a 3d	 mov	 cl, BYTE PTR [edx+61]
  00052	88 08		 mov	 BYTE PTR [eax], cl

; 134  : 
; 135  :    return VCI_NO_ERROR;

  00054	66 33 c0	 xor	 ax, ax
$L1463:

; 136  : }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
_vciDecodeNeedsInputVR12@8 ENDP
_TEXT	ENDS
PUBLIC	_vciGetEnergyVR12@8
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@403c555560000000
EXTRN	__ftol2:NEAR
EXTRN	_log10:NEAR
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@403c555560000000
CONST	SEGMENT
__real@403c555560000000 DQ 0403c555560000000r	; 28.3333
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciGetEnergyVR12@8
_TEXT	SEGMENT
_vciCodecMblk$ = -8
_energy$ = -4
_hCodecMemBlk$ = 8
_pwEnergyLevel$ = 12
_vciGetEnergyVR12@8 PROC NEAR				; COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 149  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 150  :    float energy;
; 151  :    *pwEnergyLevel=-1;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _pwEnergyLevel$[ebp]
  00010	66 c7 00 ff ff	 mov	 WORD PTR [eax], -1

; 152  : 
; 153  :    if(!VCI_BLOCK_CHECK(hCodecMemBlk))

  00015	83 7d 08 00	 cmp	 DWORD PTR _hCodecMemBlk$[ebp], 0
  00019	74 0b		 je	 SHORT $L1484
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _hCodecMemBlk$[ebp]
  0001e	81 39 ce fa 00
	00		 cmp	 DWORD PTR [ecx], 64206	; 0000faceH
  00024	74 06		 je	 SHORT $L1483
$L1484:

; 154  :       return VCI_NOT_VCI_HANDLE;

  00026	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  0002a	eb 69		 jmp	 SHORT $L1478
$L1483:

; 155  : 
; 156  :    if(!pwEnergyLevel)

  0002c	83 7d 0c 00	 cmp	 DWORD PTR _pwEnergyLevel$[ebp], 0
  00030	75 06		 jne	 SHORT $L1485

; 157  :       return VCI_NULL_ARG;

  00032	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  00036	eb 5d		 jmp	 SHORT $L1478
$L1485:

; 158  : 
; 159  :    vciCodecMblk = (VCI_CODEC_BLOCK *)hCodecMemBlk;

  00038	8b 55 08	 mov	 edx, DWORD PTR _hCodecMemBlk$[ebp]
  0003b	89 55 f8	 mov	 DWORD PTR _vciCodecMblk$[ebp], edx

; 160  : 
; 161  :    if (vciCodecMblk->chEncOrDec   == ENCODE_ID) {

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00041	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  00045	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00048	75 38		 jne	 SHORT $L1487

; 162  :       energy=*(((ENC_MEM_BLK*)(vciCodecMblk->hCodecMblk))->dwLpc);

  0004a	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0004d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00050	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	89 55 fc	 mov	 DWORD PTR _energy$[ebp], edx

; 163  :       *pwEnergyLevel=(short)(log10(energy+1.0)* DB2LEVEL_VALUE);

  00058	d9 45 fc	 fld	 DWORD PTR _energy$[ebp]
  0005b	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  00061	83 ec 08	 sub	 esp, 8
  00064	dd 1c 24	 fstp	 QWORD PTR [esp]
  00067	e8 00 00 00 00	 call	 _log10
  0006c	83 c4 08	 add	 esp, 8
  0006f	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@403c555560000000
  00075	e8 00 00 00 00	 call	 __ftol2
  0007a	8b 4d 0c	 mov	 ecx, DWORD PTR _pwEnergyLevel$[ebp]
  0007d	66 89 01	 mov	 WORD PTR [ecx], ax

; 164  :    } else  /* hack from the old days ..GA */

  00080	eb 10		 jmp	 SHORT $L1490
$L1487:

; 165  :       *pwEnergyLevel=(short)(((QUAN_12*)(vciCodecMblk->pQuanMemBlk))->Energy_INDEX);

  00082	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00085	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00088	8b 4d 0c	 mov	 ecx, DWORD PTR _pwEnergyLevel$[ebp]
  0008b	66 8b 50 22	 mov	 dx, WORD PTR [eax+34]
  0008f	66 89 11	 mov	 WORD PTR [ecx], dx
$L1490:

; 166  : 
; 167  :    return VCI_NO_ERROR;

  00092	66 33 c0	 xor	 ax, ax
$L1478:

; 168  : }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 08 00	 ret	 8
_vciGetEnergyVR12@8 ENDP
_TEXT	ENDS
PUBLIC	_vciSetInjectSilenceFlagVR12@4
; Function compile flags: /Odt
;	COMDAT _vciSetInjectSilenceFlagVR12@4
_TEXT	SEGMENT
_DecMemBlk$ = -4
_hCodecMemBlk$ = 8
_vciSetInjectSilenceFlagVR12@4 PROC NEAR		; COMDAT

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 179  :    DEC_MEM_BLK *DecMemBlk = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _DecMemBlk$[ebp], 0

; 180  : 
; 181  :    if(!VCI_BLOCK_CHECK(hCodecMemBlk))

  0000b	83 7d 08 00	 cmp	 DWORD PTR _hCodecMemBlk$[ebp], 0
  0000f	74 0b		 je	 SHORT $L1500
  00011	8b 45 08	 mov	 eax, DWORD PTR _hCodecMemBlk$[ebp]
  00014	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0001a	74 06		 je	 SHORT $L1499
$L1500:

; 182  :       return VCI_NOT_VCI_HANDLE;

  0001c	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00020	eb 28		 jmp	 SHORT $L1495
$L1499:

; 183  : 
; 184  :    if(!VCI_IS_DECODE(hCodecMemBlk))

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _hCodecMemBlk$[ebp]
  00025	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00029	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0002c	74 06		 je	 SHORT $L1502

; 185  :       return VCI_NOT_DEC_HANDLE;

  0002e	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  00032	eb 16		 jmp	 SHORT $L1495
$L1502:

; 186  : 
; 187  :    DecMemBlk = (DEC_MEM_BLK *)((VCI_CODEC_BLOCK *)hCodecMemBlk)->hCodecMblk;

  00034	8b 45 08	 mov	 eax, DWORD PTR _hCodecMemBlk$[ebp]
  00037	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0003a	89 4d fc	 mov	 DWORD PTR _DecMemBlk$[ebp], ecx

; 188  : 
; 189  :    ((FadeIOstruct*)(DecMemBlk->pFadeIOMemBlk))->CurrentFrameState=0;

  0003d	8b 55 fc	 mov	 edx, DWORD PTR _DecMemBlk$[ebp]
  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 190  : 
; 191  :    return VCI_NO_ERROR;

  00047	66 33 c0	 xor	 ax, ax
$L1495:

; 192  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
_vciSetInjectSilenceFlagVR12@4 ENDP
_TEXT	ENDS
PUBLIC	_vciNumFramesInBufferVR12@20
EXTRN	_framesInBufferVR12@8:NEAR
EXTRN	_seekForwardVR12@32:NEAR
; Function compile flags: /Odt
;	COMDAT _vciNumFramesInBufferVR12@20
_TEXT	SEGMENT
_BitsInFrame$ = -4
_hCodecMemBlk$ = 8
_hvciCodecIOBlk$ = 12
_pwNumFrames$ = 16
_pwByteOffset$ = 20
_pchBitOffset$ = 24
_vciNumFramesInBufferVR12@20 PROC NEAR			; COMDAT

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 207  : 	unsigned short  BitsInFrame;
; 208  : 
; 209  :    if(!VCI_BLOCK_CHECK(hCodecMemBlk))

  00004	83 7d 08 00	 cmp	 DWORD PTR _hCodecMemBlk$[ebp], 0
  00008	74 0b		 je	 SHORT $L1520
  0000a	8b 45 08	 mov	 eax, DWORD PTR _hCodecMemBlk$[ebp]
  0000d	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  00013	74 09		 je	 SHORT $L1519
$L1520:

; 210  :       return VCI_NOT_VCI_HANDLE;

  00015	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00019	e9 f6 00 00 00	 jmp	 $L1516
$L1519:

; 211  : 
; 212  :    /* Do parameter checking on IO block. */
; 213  :    VCI_IO_BLK_PARAM_CHECK(hvciCodecIOBlk);

  0001e	83 7d 0c 00	 cmp	 DWORD PTR _hvciCodecIOBlk$[ebp], 0
  00022	75 09		 jne	 SHORT $L1521
  00024	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  00028	e9 e7 00 00 00	 jmp	 $L1516
$L1521:
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _hvciCodecIOBlk$[ebp]
  00030	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00034	75 09		 jne	 SHORT $L1522
  00036	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  0003a	e9 d5 00 00 00	 jmp	 $L1516
$L1522:
  0003f	8b 55 0c	 mov	 edx, DWORD PTR _hvciCodecIOBlk$[ebp]
  00042	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00045	75 09		 jne	 SHORT $L1523
  00047	66 b8 ed 17	 mov	 ax, 6125		; 000017edH
  0004b	e9 c4 00 00 00	 jmp	 $L1516
$L1523:
  00050	8b 45 0c	 mov	 eax, DWORD PTR _hvciCodecIOBlk$[ebp]
  00053	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00057	8b 55 0c	 mov	 edx, DWORD PTR _hvciCodecIOBlk$[ebp]
  0005a	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  0005e	3b c8		 cmp	 ecx, eax
  00060	7c 09		 jl	 SHORT $L1524
  00062	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  00066	e9 a9 00 00 00	 jmp	 $L1516
$L1524:
  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR _hvciCodecIOBlk$[ebp]
  0006e	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00072	8b 45 0c	 mov	 eax, DWORD PTR _hvciCodecIOBlk$[ebp]
  00075	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00079	3b d1		 cmp	 edx, ecx
  0007b	7c 09		 jl	 SHORT $L1525
  0007d	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  00081	e9 8e 00 00 00	 jmp	 $L1516
$L1525:
  00086	8b 55 0c	 mov	 edx, DWORD PTR _hvciCodecIOBlk$[ebp]
  00089	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  0008d	83 f8 07	 cmp	 eax, 7
  00090	7e 06		 jle	 SHORT $L1526
  00092	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  00096	eb 7c		 jmp	 SHORT $L1516
$L1526:
  00098	8b 4d 0c	 mov	 ecx, DWORD PTR _hvciCodecIOBlk$[ebp]
  0009b	0f b6 51 14	 movzx	 edx, BYTE PTR [ecx+20]
  0009f	83 fa 07	 cmp	 edx, 7
  000a2	7e 06		 jle	 SHORT $L1527
  000a4	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  000a8	eb 6a		 jmp	 SHORT $L1516
$L1527:

; 214  : 
; 215  :    if(!pwNumFrames)

  000aa	83 7d 10 00	 cmp	 DWORD PTR _pwNumFrames$[ebp], 0
  000ae	75 06		 jne	 SHORT $L1528

; 216  :       return VCI_NULL_ARG;

  000b0	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  000b4	eb 5e		 jmp	 SHORT $L1516
$L1528:

; 217  : 
; 218  :    if(!pwByteOffset)

  000b6	83 7d 14 00	 cmp	 DWORD PTR _pwByteOffset$[ebp], 0
  000ba	75 06		 jne	 SHORT $L1529

; 219  :       return VCI_NULL_ARG;

  000bc	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  000c0	eb 52		 jmp	 SHORT $L1516
$L1529:

; 220  : 
; 221  :    if(!pchBitOffset)

  000c2	83 7d 18 00	 cmp	 DWORD PTR _pchBitOffset$[ebp], 0
  000c6	75 06		 jne	 SHORT $L1530

; 222  :       return VCI_NULL_ARG;

  000c8	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  000cc	eb 46		 jmp	 SHORT $L1516
$L1530:

; 223  : 
; 224  :    framesInBufferVR12(hvciCodecIOBlk, pwNumFrames);

  000ce	8b 45 10	 mov	 eax, DWORD PTR _pwNumFrames$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d 0c	 mov	 ecx, DWORD PTR _hvciCodecIOBlk$[ebp]
  000d5	51		 push	 ecx
  000d6	e8 00 00 00 00	 call	 _framesInBufferVR12@8

; 225  :          seekForwardVR12(hvciCodecIOBlk->wVoxBufferReadByteOffset, 
; 226  :             hvciCodecIOBlk->chVoxBufferReadBitOffset, 
; 227  :             hvciCodecIOBlk->wVoxBufferSize, 
; 228  :             hvciCodecIOBlk->pVoxBuffer,
; 229  :             *pwNumFrames, 
; 230  :             pwByteOffset, 
; 231  :             pchBitOffset, 
; 232  :             &BitsInFrame);

  000db	8d 55 fc	 lea	 edx, DWORD PTR _BitsInFrame$[ebp]
  000de	52		 push	 edx
  000df	8b 45 18	 mov	 eax, DWORD PTR _pchBitOffset$[ebp]
  000e2	50		 push	 eax
  000e3	8b 4d 14	 mov	 ecx, DWORD PTR _pwByteOffset$[ebp]
  000e6	51		 push	 ecx
  000e7	8b 55 10	 mov	 edx, DWORD PTR _pwNumFrames$[ebp]
  000ea	66 8b 02	 mov	 ax, WORD PTR [edx]
  000ed	50		 push	 eax
  000ee	8b 4d 0c	 mov	 ecx, DWORD PTR _hvciCodecIOBlk$[ebp]
  000f1	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000f4	52		 push	 edx
  000f5	8b 45 0c	 mov	 eax, DWORD PTR _hvciCodecIOBlk$[ebp]
  000f8	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  000fc	51		 push	 ecx
  000fd	8b 55 0c	 mov	 edx, DWORD PTR _hvciCodecIOBlk$[ebp]
  00100	8a 42 10	 mov	 al, BYTE PTR [edx+16]
  00103	50		 push	 eax
  00104	8b 4d 0c	 mov	 ecx, DWORD PTR _hvciCodecIOBlk$[ebp]
  00107	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 _seekForwardVR12@32

; 233  :        
; 234  :    return VCI_NO_ERROR;

  00111	66 33 c0	 xor	 ax, ax
$L1516:

; 235  : }

  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c2 14 00	 ret	 20			; 00000014H
_vciNumFramesInBufferVR12@20 ENDP
_TEXT	ENDS
PUBLIC	_vciSeekForwardVR12@20
; Function compile flags: /Odt
;	COMDAT _vciSeekForwardVR12@20
_TEXT	SEGMENT
_TempFrames$ = -8
_BitsInFrame$ = -4
_hCodecMemBlk$ = 8
_hvciCodecIOBlk$ = 12
_wNumFrames$ = 16
_pwByteOffset$ = 20
_pchBitOffset$ = 24
_vciSeekForwardVR12@20 PROC NEAR			; COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 252  : 	unsigned short  BitsInFrame;
; 253  :    unsigned short  TempFrames;
; 254  : 
; 255  :    if(!VCI_BLOCK_CHECK(hCodecMemBlk))

  00006	83 7d 08 00	 cmp	 DWORD PTR _hCodecMemBlk$[ebp], 0
  0000a	74 0b		 je	 SHORT $L1546
  0000c	8b 45 08	 mov	 eax, DWORD PTR _hCodecMemBlk$[ebp]
  0000f	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  00015	74 09		 je	 SHORT $L1545
$L1546:

; 256  :       return VCI_NOT_VCI_HANDLE;

  00017	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  0001b	e9 fd 00 00 00	 jmp	 $L1541
$L1545:

; 257  : 
; 258  :    /* Do parameter checking on IO block. */
; 259  :    VCI_IO_BLK_PARAM_CHECK(hvciCodecIOBlk);

  00020	83 7d 0c 00	 cmp	 DWORD PTR _hvciCodecIOBlk$[ebp], 0
  00024	75 09		 jne	 SHORT $L1547
  00026	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  0002a	e9 ee 00 00 00	 jmp	 $L1541
$L1547:
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _hvciCodecIOBlk$[ebp]
  00032	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00036	75 09		 jne	 SHORT $L1548
  00038	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  0003c	e9 dc 00 00 00	 jmp	 $L1541
$L1548:
  00041	8b 55 0c	 mov	 edx, DWORD PTR _hvciCodecIOBlk$[ebp]
  00044	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00047	75 09		 jne	 SHORT $L1549
  00049	66 b8 ed 17	 mov	 ax, 6125		; 000017edH
  0004d	e9 cb 00 00 00	 jmp	 $L1541
$L1549:
  00052	8b 45 0c	 mov	 eax, DWORD PTR _hvciCodecIOBlk$[ebp]
  00055	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00059	8b 55 0c	 mov	 edx, DWORD PTR _hvciCodecIOBlk$[ebp]
  0005c	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00060	3b c8		 cmp	 ecx, eax
  00062	7c 09		 jl	 SHORT $L1550
  00064	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  00068	e9 b0 00 00 00	 jmp	 $L1541
$L1550:
  0006d	8b 4d 0c	 mov	 ecx, DWORD PTR _hvciCodecIOBlk$[ebp]
  00070	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00074	8b 45 0c	 mov	 eax, DWORD PTR _hvciCodecIOBlk$[ebp]
  00077	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0007b	3b d1		 cmp	 edx, ecx
  0007d	7c 09		 jl	 SHORT $L1551
  0007f	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  00083	e9 95 00 00 00	 jmp	 $L1541
$L1551:
  00088	8b 55 0c	 mov	 edx, DWORD PTR _hvciCodecIOBlk$[ebp]
  0008b	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  0008f	83 f8 07	 cmp	 eax, 7
  00092	7e 09		 jle	 SHORT $L1552
  00094	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  00098	e9 80 00 00 00	 jmp	 $L1541
$L1552:
  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _hvciCodecIOBlk$[ebp]
  000a0	0f b6 51 14	 movzx	 edx, BYTE PTR [ecx+20]
  000a4	83 fa 07	 cmp	 edx, 7
  000a7	7e 06		 jle	 SHORT $L1553
  000a9	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  000ad	eb 6e		 jmp	 SHORT $L1541
$L1553:

; 260  : 
; 261  :    if(!pwByteOffset)

  000af	83 7d 14 00	 cmp	 DWORD PTR _pwByteOffset$[ebp], 0
  000b3	75 06		 jne	 SHORT $L1554

; 262  :       return VCI_NULL_ARG;

  000b5	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  000b9	eb 62		 jmp	 SHORT $L1541
$L1554:

; 263  : 
; 264  :    if(!pchBitOffset)

  000bb	83 7d 18 00	 cmp	 DWORD PTR _pchBitOffset$[ebp], 0
  000bf	75 06		 jne	 SHORT $L1555

; 265  :       return VCI_NULL_ARG;

  000c1	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  000c5	eb 56		 jmp	 SHORT $L1541
$L1555:

; 266  : 
; 267  : 	framesInBufferVR12(hvciCodecIOBlk, &TempFrames);

  000c7	8d 45 f8	 lea	 eax, DWORD PTR _TempFrames$[ebp]
  000ca	50		 push	 eax
  000cb	8b 4d 0c	 mov	 ecx, DWORD PTR _hvciCodecIOBlk$[ebp]
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 _framesInBufferVR12@8

; 268  :    if (TempFrames < wNumFrames)

  000d4	0f b7 55 f8	 movzx	 edx, WORD PTR _TempFrames$[ebp]
  000d8	0f b7 45 10	 movzx	 eax, WORD PTR _wNumFrames$[ebp]
  000dc	3b d0		 cmp	 edx, eax
  000de	7d 06		 jge	 SHORT $L1556

; 269  :       return VCI_INSUFFICIENT_VOX_DATA;

  000e0	66 b8 0b 18	 mov	 ax, 6155		; 0000180bH
  000e4	eb 37		 jmp	 SHORT $L1541
$L1556:

; 270  : 
; 271  :    seekForwardVR12(hvciCodecIOBlk->wVoxBufferReadByteOffset, 
; 272  :       hvciCodecIOBlk->chVoxBufferReadBitOffset, 
; 273  :       hvciCodecIOBlk->wVoxBufferSize, 
; 274  :       hvciCodecIOBlk->pVoxBuffer,
; 275  :       wNumFrames, 
; 276  :       pwByteOffset, 
; 277  :       pchBitOffset, 
; 278  :       &BitsInFrame);

  000e6	8d 4d fc	 lea	 ecx, DWORD PTR _BitsInFrame$[ebp]
  000e9	51		 push	 ecx
  000ea	8b 55 18	 mov	 edx, DWORD PTR _pchBitOffset$[ebp]
  000ed	52		 push	 edx
  000ee	8b 45 14	 mov	 eax, DWORD PTR _pwByteOffset$[ebp]
  000f1	50		 push	 eax
  000f2	66 8b 4d 10	 mov	 cx, WORD PTR _wNumFrames$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 0c	 mov	 edx, DWORD PTR _hvciCodecIOBlk$[ebp]
  000fa	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000fd	50		 push	 eax
  000fe	8b 4d 0c	 mov	 ecx, DWORD PTR _hvciCodecIOBlk$[ebp]
  00101	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  00105	52		 push	 edx
  00106	8b 45 0c	 mov	 eax, DWORD PTR _hvciCodecIOBlk$[ebp]
  00109	8a 48 10	 mov	 cl, BYTE PTR [eax+16]
  0010c	51		 push	 ecx
  0010d	8b 55 0c	 mov	 edx, DWORD PTR _hvciCodecIOBlk$[ebp]
  00110	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 _seekForwardVR12@32

; 279  : 
; 280  :    /* An else would be required here to deal with variable rate codecs.       */
; 281  :    return VCI_NO_ERROR;

  0011a	66 33 c0	 xor	 ax, ax
$L1541:

; 282  : }

  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c2 14 00	 ret	 20			; 00000014H
_vciSeekForwardVR12@20 ENDP
_TEXT	ENDS
PUBLIC	_vciGetPlusInfoVR12@4
; Function compile flags: /Odt
;	COMDAT _vciGetPlusInfoVR12@4
_TEXT	SEGMENT
_pVciPlusInfoBlk$ = 8
_vciGetPlusInfoVR12@4 PROC NEAR				; COMDAT

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 292  : 
; 293  :    if(!pVciPlusInfoBlk)

  00003	83 7d 08 00	 cmp	 DWORD PTR _pVciPlusInfoBlk$[ebp], 0
  00007	75 06		 jne	 SHORT $L1560

; 294  :       return VCI_NULL_ARG;

  00009	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  0000d	eb 5b		 jmp	 SHORT $L1559
$L1560:

; 295  : 
; 296  :    pVciPlusInfoBlk->wPlusFlags=VCI_CODEC_HAS_WARPING; 

  0000f	8b 45 08	 mov	 eax, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00012	66 c7 00 01 00	 mov	 WORD PTR [eax], 1

; 297  :    pVciPlusInfoBlk->wPlusFlags|=VCI_CODEC_HAS_SILENCE_INJECTION;

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _pVciPlusInfoBlk$[ebp]
  0001a	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0001d	83 ca 02	 or	 edx, 2
  00020	8b 45 08	 mov	 eax, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00023	66 89 10	 mov	 WORD PTR [eax], dx

; 298  :    pVciPlusInfoBlk->wPlusFlags|=VCI_CODEC_HAS_GET_ENERGY;

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00029	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0002c	83 ca 08	 or	 edx, 8
  0002f	8b 45 08	 mov	 eax, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00032	66 89 10	 mov	 WORD PTR [eax], dx

; 299  :    pVciPlusInfoBlk->wPlusFlags|=VCI_CODEC_HAS_FRAME_TRAVERSAL;

  00035	8b 4d 08	 mov	 ecx, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00038	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0003b	83 ca 10	 or	 edx, 16			; 00000010H
  0003e	8b 45 08	 mov	 eax, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00041	66 89 10	 mov	 WORD PTR [eax], dx

; 300  :    pVciPlusInfoBlk->wPlusFlags|=VCI_PRIME_FLUSH;

  00044	8b 4d 08	 mov	 ecx, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00047	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0004a	83 ca 20	 or	 edx, 32			; 00000020H
  0004d	8b 45 08	 mov	 eax, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00050	66 89 10	 mov	 WORD PTR [eax], dx

; 301  : 
; 302  :    pVciPlusInfoBlk->dwMinWarp=MIN_WARP;

  00053	8b 4d 08	 mov	 ecx, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00056	c7 41 04 cd cc
	4c 3e		 mov	 DWORD PTR [ecx+4], 1045220557 ; 3e4ccccdH

; 303  :    pVciPlusInfoBlk->dwMaxWarp=MAX_WARP;

  0005d	8b 55 08	 mov	 edx, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00060	c7 42 08 00 00
	a0 40		 mov	 DWORD PTR [edx+8], 1084227584 ; 40a00000H

; 304  : 
; 305  :    return VCI_NO_ERROR;

  00067	66 33 c0	 xor	 ax, ax
$L1559:

; 306  : }

  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
_vciGetPlusInfoVR12@4 ENDP
_TEXT	ENDS
PUBLIC	_vciPlusInitVR12@4
EXTRN	_calloc:NEAR
; Function compile flags: /Odt
;	COMDAT _vciPlusInitVR12@4
_TEXT	SEGMENT
_vciCodecMblk$ = -4
_pCodecMemBlk$ = 8
_vciPlusInitVR12@4 PROC NEAR				; COMDAT

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 310  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 311  : 
; 312  :    if(!VCI_BLOCK_CHECK(pCodecMemBlk))

  0000b	83 7d 08 00	 cmp	 DWORD PTR _pCodecMemBlk$[ebp], 0
  0000f	74 0b		 je	 SHORT $L1568
  00011	8b 45 08	 mov	 eax, DWORD PTR _pCodecMemBlk$[ebp]
  00014	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0001a	74 09		 je	 SHORT $L1567
$L1568:

; 313  :       return VCI_NOT_VCI_HANDLE;

  0001c	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00020	e9 84 00 00 00	 jmp	 $L1563
$L1567:

; 314  : 
; 315  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pCodecMemBlk;

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _pCodecMemBlk$[ebp]
  00028	89 4d fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], ecx

; 316  : 
; 317  :    if(VOX_MEM_INIT(vciCodecMblk->pVciPlusMethodStruct,1,sizeof(VCI_PLUS_METHOD_STRUCT)))

  0002b	6a 48		 push	 72			; 00000048H
  0002d	6a 01		 push	 1
  0002f	e8 00 00 00 00	 call	 _calloc
  00034	83 c4 08	 add	 esp, 8
  00037	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0003a	89 42 28	 mov	 DWORD PTR [edx+40], eax
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00040	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00044	75 06		 jne	 SHORT $L1571

; 318  :       return VCI_FAILED_MEM_ALLOC;

  00046	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  0004a	eb 5d		 jmp	 SHORT $L1563
$L1571:

; 319  : 
; 320  :    vciCodecMblk->pVciPlusMethodStruct->pfVciDecodeNeedsInput=vciDecodeNeedsInputVR12;

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  0004f	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00052	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET FLAT:_vciDecodeNeedsInputVR12@8

; 321  :    vciCodecMblk->pVciPlusMethodStruct->pfVciSetWarpFactor=vciSetWarpFactorVR12;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  0005b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0005e	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:_vciSetWarpFactorVR12@8

; 322  :    vciCodecMblk->pVciPlusMethodStruct->pfVciGetWarpFactor=vciGetWarpFactorVR12;

  00065	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00068	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0006b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET FLAT:_vciGetWarpFactorVR12@8

; 323  : 
; 324  :    vciCodecMblk->pVciPlusMethodStruct->pfVciSetInjectSilenceFlag=vciSetInjectSilenceFlagVR12;

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00075	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00078	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], OFFSET FLAT:_vciSetInjectSilenceFlagVR12@4

; 325  : 
; 326  :    vciCodecMblk->pVciPlusMethodStruct->pfVciGetEnergy=vciGetEnergyVR12;   

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00082	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00085	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], OFFSET FLAT:_vciGetEnergyVR12@8

; 327  :   
; 328  :    vciCodecMblk->pVciPlusMethodStruct->pfVciNumFramesInBuffer=vciNumFramesInBufferVR12;

  0008c	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0008f	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00092	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET FLAT:_vciNumFramesInBufferVR12@20

; 329  :    vciCodecMblk->pVciPlusMethodStruct->pfVciSeekForward=vciSeekForwardVR12;

  00099	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  0009c	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0009f	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET FLAT:_vciSeekForwardVR12@20

; 330  : 
; 331  :    return VCI_NO_ERROR;

  000a6	66 33 c0	 xor	 ax, ax
$L1563:

; 332  : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 04 00	 ret	 4
_vciPlusInitVR12@4 ENDP
_TEXT	ENDS
PUBLIC	_vciPlusFreeVR12@4
EXTRN	_free:NEAR
; Function compile flags: /Odt
;	COMDAT _vciPlusFreeVR12@4
_TEXT	SEGMENT
_pCodecMemBlk$ = 8
_vciPlusFreeVR12@4 PROC NEAR				; COMDAT

; 335  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 336  :    if(!VCI_BLOCK_CHECK(pCodecMemBlk))

  00003	83 7d 08 00	 cmp	 DWORD PTR _pCodecMemBlk$[ebp], 0
  00007	74 0b		 je	 SHORT $L1577
  00009	8b 45 08	 mov	 eax, DWORD PTR _pCodecMemBlk$[ebp]
  0000c	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  00012	74 06		 je	 SHORT $L1576
$L1577:

; 337  :       return VCI_NOT_VCI_HANDLE;

  00014	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00018	eb 25		 jmp	 SHORT $L1574
$L1576:

; 338  : 
; 339  :    VOX_MEM_FREE(((VCI_CODEC_BLOCK *)pCodecMemBlk)->pVciPlusMethodStruct);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _pCodecMemBlk$[ebp]
  0001d	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  00021	74 19		 je	 SHORT $L1579
  00023	8b 55 08	 mov	 edx, DWORD PTR _pCodecMemBlk$[ebp]
  00026	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _free
  0002f	83 c4 04	 add	 esp, 4
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _pCodecMemBlk$[ebp]
  00035	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
$L1579:

; 340  : 
; 341  :    return VCI_NO_ERROR;

  0003c	66 33 c0	 xor	 ax, ax
$L1574:

; 342  : }

  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
_vciPlusFreeVR12@4 ENDP
_TEXT	ENDS
END
