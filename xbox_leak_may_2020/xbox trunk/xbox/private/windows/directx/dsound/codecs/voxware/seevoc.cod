; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\seevoc.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DP@GLGNDPCP@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@ONHCAKBE@fPitchDFT?5?$DM?5?$CI1500?40F?$CKHZ2DFT?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@DHDGLKPI@iSeePeakCount?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxSeevocFlattop@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxSeevocPeaksFast@28
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_VoxSeevocFlattop@24
PUBLIC	??_C@_0DP@GLGNDPCP@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BN@ONHCAKBE@fPitchDFT?5?$DM?5?$CI1500?40F?$CKHZ2DFT?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BC@DHDGLKPI@iSeePeakCount?5?$DO?50?$AA@	; `string'
PUBLIC	__real@42c00000
PUBLIC	__real@bd4ccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f7fbe77
EXTRN	_fLog2@4:NEAR
EXTRN	_fInvLog2@4:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	__assert:NEAR
EXTRN	_memset:NEAR
;	COMDAT __real@42c00000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\seevoc.c
CONST	SEGMENT
__real@42c00000 DD 042c00000r			; 96
CONST	ENDS
;	COMDAT ??_C@_0DP@GLGNDPCP@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DP@GLGNDPCP@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\seevoc.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ONHCAKBE@fPitchDFT?5?$DM?5?$CI1500?40F?$CKHZ2DFT?$CJ?$AA@
CONST	SEGMENT
??_C@_0BN@ONHCAKBE@fPitchDFT?5?$DM?5?$CI1500?40F?$CKHZ2DFT?$CJ?$AA@ DB 'f'
	DB	'PitchDFT < (1500.0F*HZ2DFT)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DHDGLKPI@iSeePeakCount?5?$DO?50?$AA@
CONST	SEGMENT
??_C@_0BC@DHDGLKPI@iSeePeakCount?5?$DO?50?$AA@ DB 'iSeePeakCount > 0', 00H ; `string'
CONST	ENDS
;	COMDAT __real@bd4ccccd
CONST	SEGMENT
__real@bd4ccccd DD 0bd4ccccdr			; -0.05
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3f7fbe77
CONST	SEGMENT
__real@3f7fbe77 DD 03f7fbe77r			; 0.999
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxSeevocFlattop@24
_TEXT	SEGMENT
_j$ = -1464
_ftmp$ = -1460
_pfSeePwr$ = -1456
_frqj$ = -1052
_iSeePeakCount$ = -1048
_ampjm1$ = -1044
_jlo$ = -1040
_i$ = -1036
_pfSeeFrq$ = -1032
_jhi$ = -8
_frqjm1$ = -4
_pfMagSq$ = 8
_pfPwrIn$ = 12
_pfFrqIn$ = 16
_iInCount$ = 20
_pfLogSeeEnv$ = 24
_fPitchDFT$ = 28
_VoxSeevocFlattop@24 PROC NEAR				; COMDAT

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 05 00
	00		 sub	 esp, 1464		; 000005b8H

; 97   :   int   i, j, jlo, jhi;
; 98   :   int   iSeePeakCount;
; 99   :   float ampjm1, frqjm1, frqj;
; 100  :   float ftmp;
; 101  : 
; 102  :   STACK_INIT
; 103  :     float pfSeePwr[MAXHARM];
; 104  :     float pfSeeFrq[NFFT_2];
; 105  :     STACK_INIT_END
; 106  :     STACK_ATTACH(float *, pfSeePwr)
; 107  :     STACK_ATTACH(float *, pfSeeFrq)
; 108  : 
; 109  :    STACK_START
; 110  : 
; 111  :    memset(pfSeePwr, 0, MAXHARM*sizeof(float));

  00009	68 90 01 00 00	 push	 400			; 00000190H
  0000e	6a 00		 push	 0
  00010	8d 85 50 fa ff
	ff		 lea	 eax, DWORD PTR _pfSeePwr$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _memset
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 112  :    memset(pfSeeFrq, 0, MAXHARM*sizeof(float));

  0001f	68 90 01 00 00	 push	 400			; 00000190H
  00024	6a 00		 push	 0
  00026	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _pfSeeFrq$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _memset
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 113  : 
; 114  :    /*----------------------------------------------
; 115  :      If the pitch is too high we will not get 
; 116  :        enough Seevoc peaks.  The pitch estimator
; 117  :        currently (7/6/98) limits the pitch to 1000 
; 118  :        Hz so this should not be a problem.
; 119  :    ----------------------------------------------*/
; 120  :    assert( fPitchDFT < (1500.0F*HZ2DFT) );

  00035	d9 45 1c	 fld	 DWORD PTR _fPitchDFT$[ebp]
  00038	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@42c00000
  0003e	df e0		 fnstsw	 ax
  00040	f6 c4 05	 test	 ah, 5
  00043	7b 14		 jnp	 SHORT $L1346
  00045	6a 78		 push	 120			; 00000078H
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@GLGNDPCP@c?3?2xbox?2private?2windows?2directx?2@
  0004c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@ONHCAKBE@fPitchDFT?5?$DM?5?$CI1500?40F?$CKHZ2DFT?$CJ?$AA@
  00051	e8 00 00 00 00	 call	 __assert
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1346:

; 121  : 
; 122  :    /*----------------------------------------------
; 123  :      Select the largest peak in each pitch adaptive frequency band.
; 124  :    ----------------------------------------------*/
; 125  :    iSeePeakCount = VoxSeevocPeaksFast(pfMagSq, pfPwrIn, pfFrqIn, 
; 126  : 				      iInCount, fPitchDFT,
; 127  : 				      pfSeePwr, pfSeeFrq);

  00059	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _pfSeeFrq$[ebp]
  0005f	50		 push	 eax
  00060	8d 8d 50 fa ff
	ff		 lea	 ecx, DWORD PTR _pfSeePwr$[ebp]
  00066	51		 push	 ecx
  00067	8b 55 1c	 mov	 edx, DWORD PTR _fPitchDFT$[ebp]
  0006a	52		 push	 edx
  0006b	8b 45 14	 mov	 eax, DWORD PTR _iInCount$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d 10	 mov	 ecx, DWORD PTR _pfFrqIn$[ebp]
  00072	51		 push	 ecx
  00073	8b 55 0c	 mov	 edx, DWORD PTR _pfPwrIn$[ebp]
  00076	52		 push	 edx
  00077	8b 45 08	 mov	 eax, DWORD PTR _pfMagSq$[ebp]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _VoxSeevocPeaksFast@28
  00080	89 85 e8 fb ff
	ff		 mov	 DWORD PTR _iSeePeakCount$[ebp], eax

; 128  : 
; 129  :    /*----------------------------------------------
; 130  :      There will always be Seevoc peaks!  
; 131  :    ----------------------------------------------*/
; 132  :    assert( iSeePeakCount > 0 );

  00086	83 bd e8 fb ff
	ff 00		 cmp	 DWORD PTR _iSeePeakCount$[ebp], 0
  0008d	7f 17		 jg	 SHORT $L1347
  0008f	68 84 00 00 00	 push	 132			; 00000084H
  00094	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@GLGNDPCP@c?3?2xbox?2private?2windows?2directx?2@
  00099	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@DHDGLKPI@iSeePeakCount?5?$DO?50?$AA@
  0009e	e8 00 00 00 00	 call	 __assert
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1347:

; 133  : 
; 134  : 
; 135  :    /*----------------------------------------------
; 136  :      Compute the flat-top envelope
; 137  :    ----------------------------------------------*/
; 138  :    i = 0;

  000a6	c7 85 f4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0

; 139  :    jhi = 0;

  000b0	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _jhi$[ebp], 0

; 140  :    ampjm1 = fLog2(pfSeePwr[0]) + DC_SLOPE;

  000b7	8b 95 50 fa ff
	ff		 mov	 edx, DWORD PTR _pfSeePwr$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _fLog2@4
  000c3	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@bd4ccccd
  000c9	d9 9d ec fb ff
	ff		 fstp	 DWORD PTR _ampjm1$[ebp]

; 141  :    ampjm1 = fInvLog2(ampjm1);

  000cf	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _ampjm1$[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _fInvLog2@4
  000db	d9 9d ec fb ff
	ff		 fstp	 DWORD PTR _ampjm1$[ebp]

; 142  :    frqjm1 = 0.0F;

  000e1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _frqjm1$[ebp], 0

; 143  :    for (j = 0; j < iSeePeakCount; j++)

  000e8	c7 85 48 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  000f2	eb 0f		 jmp	 SHORT $L1277
$L1278:
  000f4	8b 8d 48 fa ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  000fa	83 c1 01	 add	 ecx, 1
  000fd	89 8d 48 fa ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx
$L1277:
  00103	8b 95 48 fa ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00109	3b 95 e8 fb ff
	ff		 cmp	 edx, DWORD PTR _iSeePeakCount$[ebp]
  0010f	0f 8d 97 00 00
	00		 jge	 $L1279

; 144  :    {
; 145  :       frqj = pfSeeFrq[j];

  00115	8b 85 48 fa ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  0011b	8b 8c 85 f8 fb
	ff ff		 mov	 ecx, DWORD PTR _pfSeeFrq$[ebp+eax*4]
  00122	89 8d e4 fb ff
	ff		 mov	 DWORD PTR _frqj$[ebp], ecx

; 146  :       jlo = jhi;

  00128	8b 55 f8	 mov	 edx, DWORD PTR _jhi$[ebp]
  0012b	89 95 f0 fb ff
	ff		 mov	 DWORD PTR _jlo$[ebp], edx

; 147  :       ftmp=0.5F*(frqjm1 + frqj);

  00131	d9 45 fc	 fld	 DWORD PTR _frqjm1$[ebp]
  00134	d8 85 e4 fb ff
	ff		 fadd	 DWORD PTR _frqj$[ebp]
  0013a	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00140	d9 9d 4c fa ff
	ff		 fstp	 DWORD PTR _ftmp$[ebp]

; 148  :       VoxROUND2pos(ftmp, jhi);

  00146	d9 85 4c fa ff
	ff		 fld	 DWORD PTR _ftmp$[ebp]
  0014c	db 5d f8	 fistp	 DWORD PTR _jhi$[ebp]

; 149  :       for (i = jlo; i < jhi; i++)

  0014f	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _jlo$[ebp]
  00155	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
  0015b	eb 0f		 jmp	 SHORT $L1280
$L1281:
  0015d	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00163	83 c1 01	 add	 ecx, 1
  00166	89 8d f4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
$L1280:
  0016c	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00172	3b 55 f8	 cmp	 edx, DWORD PTR _jhi$[ebp]
  00175	7d 14		 jge	 SHORT $L1282

; 150  :          pfLogSeeEnv[i] = ampjm1;

  00177	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0017d	8b 4d 18	 mov	 ecx, DWORD PTR _pfLogSeeEnv$[ebp]
  00180	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _ampjm1$[ebp]
  00186	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  00189	eb d2		 jmp	 SHORT $L1281
$L1282:

; 151  : 
; 152  :       ampjm1 = pfSeePwr[j];

  0018b	8b 85 48 fa ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00191	8b 8c 85 50 fa
	ff ff		 mov	 ecx, DWORD PTR _pfSeePwr$[ebp+eax*4]
  00198	89 8d ec fb ff
	ff		 mov	 DWORD PTR _ampjm1$[ebp], ecx

; 153  :       frqjm1 = frqj;

  0019e	8b 95 e4 fb ff
	ff		 mov	 edx, DWORD PTR _frqj$[ebp]
  001a4	89 55 fc	 mov	 DWORD PTR _frqjm1$[ebp], edx

; 154  :    }

  001a7	e9 48 ff ff ff	 jmp	 $L1278
$L1279:

; 155  : 
; 156  :    jhi += VoxFLOORpos(fPitchDFT);

  001ac	d9 45 1c	 fld	 DWORD PTR _fPitchDFT$[ebp]
  001af	e8 00 00 00 00	 call	 __ftol2
  001b4	8b 4d f8	 mov	 ecx, DWORD PTR _jhi$[ebp]
  001b7	03 c8		 add	 ecx, eax
  001b9	89 4d f8	 mov	 DWORD PTR _jhi$[ebp], ecx

; 157  :    if (jhi > NFFT_2)

  001bc	81 7d f8 00 01
	00 00		 cmp	 DWORD PTR _jhi$[ebp], 256 ; 00000100H
  001c3	7e 07		 jle	 SHORT $L1284

; 158  :       jhi = NFFT_2;

  001c5	c7 45 f8 00 01
	00 00		 mov	 DWORD PTR _jhi$[ebp], 256 ; 00000100H
$L1284:

; 159  : 
; 160  :    for (j = i; j < jhi; j++)

  001cc	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  001d2	89 95 48 fa ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
  001d8	eb 0f		 jmp	 SHORT $L1285
$L1286:
  001da	8b 85 48 fa ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  001e0	83 c0 01	 add	 eax, 1
  001e3	89 85 48 fa ff
	ff		 mov	 DWORD PTR _j$[ebp], eax
$L1285:
  001e9	8b 8d 48 fa ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  001ef	3b 4d f8	 cmp	 ecx, DWORD PTR _jhi$[ebp]
  001f2	7d 14		 jge	 SHORT $L1287

; 161  :        pfLogSeeEnv[j] = ampjm1;   /** log_seeamp[iSeePeakCount-1] **/

  001f4	8b 95 48 fa ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  001fa	8b 45 18	 mov	 eax, DWORD PTR _pfLogSeeEnv$[ebp]
  001fd	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _ampjm1$[ebp]
  00203	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  00206	eb d2		 jmp	 SHORT $L1286
$L1287:

; 162  : 
; 163  : 
; 164  :    /*----------------------------------------------
; 165  :      Extrapolate last peak to the folding frequency
; 166  :    ----------------------------------------------*/
; 167  :    for (j = jhi; j < NFFT_2; j++)

  00208	8b 55 f8	 mov	 edx, DWORD PTR _jhi$[ebp]
  0020b	89 95 48 fa ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
  00211	eb 0f		 jmp	 SHORT $L1288
$L1289:
  00213	8b 85 48 fa ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00219	83 c0 01	 add	 eax, 1
  0021c	89 85 48 fa ff
	ff		 mov	 DWORD PTR _j$[ebp], eax
$L1288:
  00222	81 bd 48 fa ff
	ff 00 01 00 00	 cmp	 DWORD PTR _j$[ebp], 256	; 00000100H
  0022c	7d 21		 jge	 SHORT $L1256

; 168  :        pfLogSeeEnv[j] = ALPHA_SEEVOC*pfLogSeeEnv[j-1];

  0022e	8b 8d 48 fa ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00234	8b 55 18	 mov	 edx, DWORD PTR _pfLogSeeEnv$[ebp]
  00237	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f7fbe77
  0023d	d8 4c 8a fc	 fmul	 DWORD PTR [edx+ecx*4-4]
  00241	8b 85 48 fa ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00247	8b 4d 18	 mov	 ecx, DWORD PTR _pfLogSeeEnv$[ebp]
  0024a	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
  0024d	eb c4		 jmp	 SHORT $L1289
$L1256:

; 169  :    
; 170  :    
; 171  :    STACK_END
; 172  : }

  0024f	8b e5		 mov	 esp, ebp
  00251	5d		 pop	 ebp
  00252	c2 18 00	 ret	 24			; 00000018H
_VoxSeevocFlattop@24 ENDP
_TEXT	ENDS
PUBLIC	__real@43800000
PUBLIC	__real@00000000
PUBLIC	__real@358637bd
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@358637bd
CONST	SEGMENT
__real@358637bd DD 0358637bdr			; 1e-006
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxSeevocPeaksFast@28
_TEXT	SEGMENT
_j$ = -32
_iPeakIndex$ = -28
_ftmp$ = -24
_fMaxPwr$ = -20
_fFreqLow$ = -16
_iOutCount$ = -12
_fFreqHigh$ = -8
_fStepSize$ = -4
_pfMagSq$ = 8
_pfPwrIn$ = 12
_pfFrqIn$ = 16
_iInCount$ = 20
_fPitchDFT$ = 24
_pfPwrOut$ = 28
_pfFrqOut$ = 32
_VoxSeevocPeaksFast@28 PROC NEAR			; COMDAT

; 209  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi

; 210  :    int   j;
; 211  :    int   iOutCount;
; 212  :    int   iPeakIndex;
; 213  :    float fStepSize;
; 214  :    float fFreqLow;
; 215  :    float fFreqHigh;
; 216  :    float fMaxPwr;
; 217  :    float ftmp;
; 218  : 
; 219  : 
; 220  :    /*-------------------------------------------
; 221  :      Initialize some things
; 222  :    -------------------------------------------*/
; 223  :    iOutCount  = 0;

  00007	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iOutCount$[ebp], 0

; 224  :    iPeakIndex = 0;

  0000e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iPeakIndex$[ebp], 0

; 225  :    fStepSize  = 0.5F*fPitchDFT;

  00015	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000
  0001b	d8 4d 18	 fmul	 DWORD PTR _fPitchDFT$[ebp]
  0001e	d9 5d fc	 fstp	 DWORD PTR _fStepSize$[ebp]

; 226  :    fFreqLow   = fStepSize;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _fStepSize$[ebp]
  00024	89 45 f0	 mov	 DWORD PTR _fFreqLow$[ebp], eax

; 227  :    fFreqHigh  = fFreqLow+fPitchDFT;

  00027	d9 45 f0	 fld	 DWORD PTR _fFreqLow$[ebp]
  0002a	d8 45 18	 fadd	 DWORD PTR _fPitchDFT$[ebp]
  0002d	d9 5d f8	 fstp	 DWORD PTR _fFreqHigh$[ebp]
$L1315:

; 228  : 
; 229  : 
; 230  :    /*-------------------------------------------
; 231  :      Skip peaks that are out of the harmonic band.
; 232  :        Be careful here, the test of the right
; 233  :        hand side of the expression must be done 
; 234  :        first to avoid an index out of range!
; 235  :    -------------------------------------------*/
; 236  :    while ( (pfFrqIn[iPeakIndex]<fFreqLow) && (iPeakIndex<iInCount) )

  00030	8b 4d e4	 mov	 ecx, DWORD PTR _iPeakIndex$[ebp]
  00033	8b 55 10	 mov	 edx, DWORD PTR _pfFrqIn$[ebp]
  00036	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  00039	d8 5d f0	 fcomp	 DWORD PTR _fFreqLow$[ebp]
  0003c	df e0		 fnstsw	 ax
  0003e	f6 c4 05	 test	 ah, 5
  00041	7a 13		 jp	 SHORT $L1319
  00043	8b 45 e4	 mov	 eax, DWORD PTR _iPeakIndex$[ebp]
  00046	3b 45 14	 cmp	 eax, DWORD PTR _iInCount$[ebp]
  00049	7d 0b		 jge	 SHORT $L1319

; 237  :       iPeakIndex ++;

  0004b	8b 4d e4	 mov	 ecx, DWORD PTR _iPeakIndex$[ebp]
  0004e	83 c1 01	 add	 ecx, 1
  00051	89 4d e4	 mov	 DWORD PTR _iPeakIndex$[ebp], ecx
  00054	eb da		 jmp	 SHORT $L1315
$L1319:

; 238  : 
; 239  : 
; 240  :    /*-------------------------------------------
; 241  :      Now find the largest peak in each pitch
; 242  :        adaptive band.
; 243  :    -------------------------------------------*/
; 244  :    while ( (fFreqLow<((float)NFFT_2-fStepSize)) && (iOutCount<MAXHARM) )

  00056	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@43800000
  0005c	d8 65 fc	 fsub	 DWORD PTR _fStepSize$[ebp]
  0005f	d8 5d f0	 fcomp	 DWORD PTR _fFreqLow$[ebp]
  00062	df e0		 fnstsw	 ax
  00064	f6 c4 41	 test	 ah, 65			; 00000041H
  00067	0f 85 30 01 00
	00		 jne	 $L1320
  0006d	83 7d f4 64	 cmp	 DWORD PTR _iOutCount$[ebp], 100 ; 00000064H
  00071	0f 8d 26 01 00
	00		 jge	 $L1320

; 245  :    {
; 246  :       fMaxPwr = 0.0F;

  00077	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _fMaxPwr$[ebp], 0

; 247  : 
; 248  :      /*-------------------------------------------
; 249  :        If (iPeakIndex<iInCount) then search for
; 250  :          a peak in the pitch bin.  Otherwise
; 251  :          don't search and just use the spectral
; 252  :          magnitude at the middle of the bin.
; 253  :      -------------------------------------------*/
; 254  :       if (iPeakIndex<iInCount)

  0007e	8b 55 e4	 mov	 edx, DWORD PTR _iPeakIndex$[ebp]
  00081	3b 55 14	 cmp	 edx, DWORD PTR _iInCount$[ebp]
  00084	7d 51		 jge	 SHORT $L1321

; 255  :       {
; 256  :          j = iPeakIndex;

  00086	8b 45 e4	 mov	 eax, DWORD PTR _iPeakIndex$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR _j$[ebp], eax
$L1323:

; 257  : 
; 258  :          /*-------------------------------------------
; 259  :              Be careful here, the test of the right
; 260  :              hand side of the expression must be done
; 261  :              first to avoid an index out of range!
; 262  :          -------------------------------------------*/
; 263  :          while ((pfFrqIn[j]<fFreqHigh) && (j<iInCount))

  0008c	8b 4d e0	 mov	 ecx, DWORD PTR _j$[ebp]
  0008f	8b 55 10	 mov	 edx, DWORD PTR _pfFrqIn$[ebp]
  00092	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  00095	d8 5d f8	 fcomp	 DWORD PTR _fFreqHigh$[ebp]
  00098	df e0		 fnstsw	 ax
  0009a	f6 c4 05	 test	 ah, 5
  0009d	7a 38		 jp	 SHORT $L1321
  0009f	8b 45 e0	 mov	 eax, DWORD PTR _j$[ebp]
  000a2	3b 45 14	 cmp	 eax, DWORD PTR _iInCount$[ebp]
  000a5	7d 30		 jge	 SHORT $L1321

; 264  :          {
; 265  :             if (fMaxPwr < pfPwrIn[j])

  000a7	8b 4d e0	 mov	 ecx, DWORD PTR _j$[ebp]
  000aa	8b 55 0c	 mov	 edx, DWORD PTR _pfPwrIn$[ebp]
  000ad	d9 45 ec	 fld	 DWORD PTR _fMaxPwr$[ebp]
  000b0	d8 1c 8a	 fcomp	 DWORD PTR [edx+ecx*4]
  000b3	df e0		 fnstsw	 ax
  000b5	f6 c4 05	 test	 ah, 5
  000b8	7a 12		 jp	 SHORT $L1325

; 266  :             {
; 267  :                fMaxPwr    = pfPwrIn[j];

  000ba	8b 45 e0	 mov	 eax, DWORD PTR _j$[ebp]
  000bd	8b 4d 0c	 mov	 ecx, DWORD PTR _pfPwrIn$[ebp]
  000c0	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000c3	89 55 ec	 mov	 DWORD PTR _fMaxPwr$[ebp], edx

; 268  :                iPeakIndex = j;

  000c6	8b 45 e0	 mov	 eax, DWORD PTR _j$[ebp]
  000c9	89 45 e4	 mov	 DWORD PTR _iPeakIndex$[ebp], eax
$L1325:

; 269  :             }
; 270  :             j ++;

  000cc	8b 4d e0	 mov	 ecx, DWORD PTR _j$[ebp]
  000cf	83 c1 01	 add	 ecx, 1
  000d2	89 4d e0	 mov	 DWORD PTR _j$[ebp], ecx

; 271  :          }

  000d5	eb b5		 jmp	 SHORT $L1323
$L1321:

; 272  :       }
; 273  : 
; 274  : 
; 275  :      /*-------------------------------------------
; 276  :        If no peak was found use STFT magnitude at
; 277  :        the mid-point of the pitch bin
; 278  :      -------------------------------------------*/
; 279  :       if (fMaxPwr > 0.0F)

  000d7	d9 45 ec	 fld	 DWORD PTR _fMaxPwr$[ebp]
  000da	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  000e0	df e0		 fnstsw	 ax
  000e2	f6 c4 41	 test	 ah, 65			; 00000041H
  000e5	75 20		 jne	 SHORT $L1326

; 280  :       {
; 281  :          pfPwrOut[iOutCount] = fMaxPwr;

  000e7	8b 55 f4	 mov	 edx, DWORD PTR _iOutCount$[ebp]
  000ea	8b 45 1c	 mov	 eax, DWORD PTR _pfPwrOut$[ebp]
  000ed	8b 4d ec	 mov	 ecx, DWORD PTR _fMaxPwr$[ebp]
  000f0	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 282  :          pfFrqOut[iOutCount] = pfFrqIn[iPeakIndex];

  000f3	8b 55 f4	 mov	 edx, DWORD PTR _iOutCount$[ebp]
  000f6	8b 45 20	 mov	 eax, DWORD PTR _pfFrqOut$[ebp]
  000f9	8b 4d e4	 mov	 ecx, DWORD PTR _iPeakIndex$[ebp]
  000fc	8b 75 10	 mov	 esi, DWORD PTR _pfFrqIn$[ebp]
  000ff	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  00102	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 283  :       }
; 284  :       else

  00105	eb 39		 jmp	 SHORT $L1327
$L1326:

; 285  :       {
; 286  :          ftmp=0.5F*(fFreqLow+fFreqHigh);

  00107	d9 45 f0	 fld	 DWORD PTR _fFreqLow$[ebp]
  0010a	d8 45 f8	 fadd	 DWORD PTR _fFreqHigh$[ebp]
  0010d	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00113	d9 5d e8	 fstp	 DWORD PTR _ftmp$[ebp]

; 287  :          VoxROUND2pos(ftmp, j);

  00116	d9 45 e8	 fld	 DWORD PTR _ftmp$[ebp]
  00119	db 5d e0	 fistp	 DWORD PTR _j$[ebp]

; 288  :          pfPwrOut[iOutCount] = pfMagSq[j] + 1.E-6F;

  0011c	8b 55 e0	 mov	 edx, DWORD PTR _j$[ebp]
  0011f	8b 45 08	 mov	 eax, DWORD PTR _pfMagSq$[ebp]
  00122	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  00125	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@358637bd
  0012b	8b 4d f4	 mov	 ecx, DWORD PTR _iOutCount$[ebp]
  0012e	8b 55 1c	 mov	 edx, DWORD PTR _pfPwrOut$[ebp]
  00131	d9 1c 8a	 fstp	 DWORD PTR [edx+ecx*4]

; 289  :          pfFrqOut[iOutCount] = (float) j;

  00134	db 45 e0	 fild	 DWORD PTR _j$[ebp]
  00137	8b 45 f4	 mov	 eax, DWORD PTR _iOutCount$[ebp]
  0013a	8b 4d 20	 mov	 ecx, DWORD PTR _pfFrqOut$[ebp]
  0013d	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
$L1327:

; 290  :       }
; 291  : 
; 292  : 
; 293  :      /*-------------------------------------------
; 294  :        Prepare limits for the next iteration.
; 295  :      -------------------------------------------*/
; 296  :       fFreqLow  = pfFrqOut[iOutCount] + fStepSize;

  00140	8b 55 f4	 mov	 edx, DWORD PTR _iOutCount$[ebp]
  00143	8b 45 20	 mov	 eax, DWORD PTR _pfFrqOut$[ebp]
  00146	d9 45 fc	 fld	 DWORD PTR _fStepSize$[ebp]
  00149	d8 04 90	 fadd	 DWORD PTR [eax+edx*4]
  0014c	d9 55 f0	 fst	 DWORD PTR _fFreqLow$[ebp]

; 297  :       fFreqHigh = fFreqLow+fPitchDFT;

  0014f	d8 45 18	 fadd	 DWORD PTR _fPitchDFT$[ebp]
  00152	d9 55 f8	 fst	 DWORD PTR _fFreqHigh$[ebp]

; 298  :       if (fFreqHigh > (float) NFFT_2)

  00155	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@43800000
  0015b	df e0		 fnstsw	 ax
  0015d	f6 c4 41	 test	 ah, 65			; 00000041H
  00160	75 07		 jne	 SHORT $L1330

; 299  :          fFreqHigh = (float) NFFT_2;

  00162	c7 45 f8 00 00
	80 43		 mov	 DWORD PTR _fFreqHigh$[ebp], 1132462080 ; 43800000H
$L1330:

; 300  : 
; 301  :       iOutCount ++;

  00169	8b 4d f4	 mov	 ecx, DWORD PTR _iOutCount$[ebp]
  0016c	83 c1 01	 add	 ecx, 1
  0016f	89 4d f4	 mov	 DWORD PTR _iOutCount$[ebp], ecx
$L1333:

; 302  : 
; 303  : 
; 304  :      /*-------------------------------------------
; 305  :        Skip peaks that are out of the harmonic band.
; 306  :          Be careful here, the test of the right
; 307  :          hand side of the expression must be done 
; 308  :          first to avoid an index out of range!
; 309  :      -------------------------------------------*/
; 310  :       while ( (pfFrqIn[iPeakIndex]<fFreqLow) && (iPeakIndex<iInCount) )

  00172	8b 55 e4	 mov	 edx, DWORD PTR _iPeakIndex$[ebp]
  00175	8b 45 10	 mov	 eax, DWORD PTR _pfFrqIn$[ebp]
  00178	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  0017b	d8 5d f0	 fcomp	 DWORD PTR _fFreqLow$[ebp]
  0017e	df e0		 fnstsw	 ax
  00180	f6 c4 05	 test	 ah, 5
  00183	7a 13		 jp	 SHORT $L1334
  00185	8b 4d e4	 mov	 ecx, DWORD PTR _iPeakIndex$[ebp]
  00188	3b 4d 14	 cmp	 ecx, DWORD PTR _iInCount$[ebp]
  0018b	7d 0b		 jge	 SHORT $L1334

; 311  :          iPeakIndex ++;

  0018d	8b 55 e4	 mov	 edx, DWORD PTR _iPeakIndex$[ebp]
  00190	83 c2 01	 add	 edx, 1
  00193	89 55 e4	 mov	 DWORD PTR _iPeakIndex$[ebp], edx
  00196	eb da		 jmp	 SHORT $L1333
$L1334:

; 312  :    }

  00198	e9 b9 fe ff ff	 jmp	 $L1319
$L1320:

; 313  : 
; 314  :    return iOutCount;

  0019d	8b 45 f4	 mov	 eax, DWORD PTR _iOutCount$[ebp]

; 315  : }

  001a0	5e		 pop	 esi
  001a1	8b e5		 mov	 esp, ebp
  001a3	5d		 pop	 ebp
  001a4	c2 1c 00	 ret	 28			; 0000001cH
_VoxSeevocPeaksFast@28 ENDP
_TEXT	ENDS
END
