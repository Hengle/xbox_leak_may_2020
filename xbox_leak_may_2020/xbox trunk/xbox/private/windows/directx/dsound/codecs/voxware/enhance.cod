; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\enhance.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxEnhance@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _myPower@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_VoxEnhance@20
PUBLIC	__real@00000000
PUBLIC	__real@358637bd
PUBLIC	__real@3f800000
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@425551ec
PUBLIC	__real@42a00000
PUBLIC	__real@42800000
PUBLIC	__real@4b800000
PUBLIC	__real@33800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3e99999a
EXTRN	_sqrt:NEAR
EXTRN	_vox_nspsRealFft@12:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_memset:NEAR
;	COMDAT __real@00000000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\enhance.c
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@358637bd
CONST	SEGMENT
__real@358637bd DD 0358637bdr			; 1e-006
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@425551ec
CONST	SEGMENT
__real@425551ec DD 0425551ecr			; 53.33
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@4b800000
CONST	SEGMENT
__real@4b800000 DD 04b800000r			; 1.67772e+007
CONST	ENDS
;	COMDAT __real@33800000
CONST	SEGMENT
__real@33800000 DD 033800000r			; 5.96046e-008
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxEnhance@20
_TEXT	SEGMENT
tv370 = -612
tv362 = -608
tv357 = -604
_HWR$ = -600
_lf$ = -336
_k$ = -332
_amp$ = -328
_XK$ = -140
_PeakPos$ = -136
_Fi$ = -132
_POWFactor$ = -128
_TTt$ = -124
_TT$ = -120
_Fo$ = -116
_FiInt$ = -112
_scale$ = -108
_i$ = -104
_slope$ = -100
_freq$ = -96
_lpc$ = 8
_Pv$ = 12
_PitchLag$ = 16
_nHarm$ = 20
_HarmAmp$ = 24
_VoxEnhance@20 PROC NEAR				; COMDAT

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 64 02 00
	00		 sub	 esp, 612		; 00000264H
  00009	56		 push	 esi

; 111  :    STACK_INIT
; 112  :    float HWR[ENHANCE_FFT+2];
; 113  :    float amp[MAXHARM_2];
; 114  :    short freq[MAXHARM_2];
; 115  :    STACK_INIT_END
; 116  : 
; 117  :    STACK_ATTACH(float*,HWR)
; 118  :    STACK_ATTACH(float*,amp)
; 119  :    STACK_ATTACH(short*,freq)
; 120  :    float *TT = HWR;

  0000a	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _HWR$[ebp]
  00010	89 45 88	 mov	 DWORD PTR _TT$[ebp], eax

; 121  :    float slope, lf;
; 122  :    float TTt;
; 123  :    float scale;
; 124  : 
; 125  :    float XK;
; 126  :    register int i = 0,k;

  00013	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 127  :    int PeakPos = 1;

  0001a	c7 85 78 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _PeakPos$[ebp], 1
$L1383:

; 128  : 	long Fi, Fo;
; 129  : 	int FiInt;
; 130  : 
; 131  : #if USE_POWER_ESTIMATE==0
; 132  :    float POWFactor; 
; 133  : #endif
; 134  : 
; 135  :    STACK_START
; 136  :    /********************************************************
; 137  :     Check if LPCs are zero since this leads to trouble later
; 138  :     ********************************************************/
; 139  :    while ((i<LPC_ORDER) && (lpc[i+1]!=0.0F))

  00024	83 7d 98 0a	 cmp	 DWORD PTR _i$[ebp], 10	; 0000000aH
  00028	7d 22		 jge	 SHORT $L1384
  0002a	8b 4d 98	 mov	 ecx, DWORD PTR _i$[ebp]
  0002d	8b 55 08	 mov	 edx, DWORD PTR _lpc$[ebp]
  00030	d9 44 8a 04	 fld	 DWORD PTR [edx+ecx*4+4]
  00034	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  0003a	df e0		 fnstsw	 ax
  0003c	f6 c4 44	 test	 ah, 68			; 00000044H
  0003f	7b 0b		 jnp	 SHORT $L1384

; 140  :    {
; 141  :       i++;

  00041	8b 45 98	 mov	 eax, DWORD PTR _i$[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 45 98	 mov	 DWORD PTR _i$[ebp], eax

; 142  :    }/*i==LPC_ORDER is check passes, no LPC is zero*/

  0004a	eb d8		 jmp	 SHORT $L1383
$L1384:

; 143  :    
; 144  :    if ((i==LPC_ORDER) && (nHarm!=0))

  0004c	83 7d 98 0a	 cmp	 DWORD PTR _i$[ebp], 10	; 0000000aH
  00050	0f 85 df 03 00
	00		 jne	 $L1385
  00056	83 7d 14 00	 cmp	 DWORD PTR _nHarm$[ebp], 0
  0005a	0f 84 d5 03 00
	00		 je	 $L1385

; 145  :    {
; 146  : 
; 147  :    /********************************************************
; 148  :     			Calculate LPC Filter Response
; 149  :     ********************************************************/
; 150  : 
; 151  :       memcpy( HWR, lpc, (LPC_ORDER+1)*sizeof(float) );

  00060	6a 2c		 push	 44			; 0000002cH
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _lpc$[ebp]
  00065	51		 push	 ecx
  00066	8d 95 a8 fd ff
	ff		 lea	 edx, DWORD PTR _HWR$[ebp]
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 _memcpy
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 152  :       memset( HWR+LPC_ORDER+1, 0, (ENHANCE_FFT-LPC_ORDER-1)*sizeof(float) );

  00075	68 d4 00 00 00	 push	 212			; 000000d4H
  0007a	6a 00		 push	 0
  0007c	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _HWR$[ebp+44]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _memset
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH

; 153  : 
; 154  :       VoxRealFft( HWR, ENHANCE_FFT_REAL_ORDER );

  0008b	6a 01		 push	 1
  0008d	6a 06		 push	 6
  0008f	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR _HWR$[ebp]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 _vox_nspsRealFft@12

; 155  : 
; 156  :       /** calculate the power spectrum of the LPCs **/
; 157  :       for (i=0; i<ENHANCE_FFT2; i++)

  0009b	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000a2	eb 09		 jmp	 SHORT $L1388
$L1389:
  000a4	8b 55 98	 mov	 edx, DWORD PTR _i$[ebp]
  000a7	83 c2 01	 add	 edx, 1
  000aa	89 55 98	 mov	 DWORD PTR _i$[ebp], edx
$L1388:
  000ad	83 7d 98 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  000b1	7d 43		 jge	 SHORT $L1390

; 158  :          TT[i] = (HWR[2*i]*HWR[2*i] + HWR[2*i+1]*HWR[2*i+1] + SMALL_NUMBER);

  000b3	8b 45 98	 mov	 eax, DWORD PTR _i$[ebp]
  000b6	d1 e0		 shl	 eax, 1
  000b8	8b 4d 98	 mov	 ecx, DWORD PTR _i$[ebp]
  000bb	d1 e1		 shl	 ecx, 1
  000bd	d9 84 85 a8 fd
	ff ff		 fld	 DWORD PTR _HWR$[ebp+eax*4]
  000c4	d8 8c 8d a8 fd
	ff ff		 fmul	 DWORD PTR _HWR$[ebp+ecx*4]
  000cb	8b 55 98	 mov	 edx, DWORD PTR _i$[ebp]
  000ce	d1 e2		 shl	 edx, 1
  000d0	8b 45 98	 mov	 eax, DWORD PTR _i$[ebp]
  000d3	d1 e0		 shl	 eax, 1
  000d5	d9 84 95 ac fd
	ff ff		 fld	 DWORD PTR _HWR$[ebp+edx*4+4]
  000dc	d8 8c 85 ac fd
	ff ff		 fmul	 DWORD PTR _HWR$[ebp+eax*4+4]
  000e3	de c1		 faddp	 ST(1), ST(0)
  000e5	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@358637bd
  000eb	8b 4d 98	 mov	 ecx, DWORD PTR _i$[ebp]
  000ee	8b 55 88	 mov	 edx, DWORD PTR _TT$[ebp]
  000f1	d9 1c 8a	 fstp	 DWORD PTR [edx+ecx*4]
  000f4	eb ae		 jmp	 SHORT $L1389
$L1390:

; 159  :          /* add small number to prevent divide by 0 */
; 160  : 
; 161  :    /********************************************************
; 162  :     			Search For Formant Peaks
; 163  :     ********************************************************/
; 164  : 
; 165  :    /*********************************************************
; 166  :    *  Locate the peaks of 1/TT(or valleys of TT) and        *
; 167  :    *        find  1/sqrt(TT) at those values                *
; 168  :    *********************************************************/
; 169  : 
; 170  : 
; 171  :       for (i=1; i < ENHANCE_FFT2-1; i++)

  000f6	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000fd	eb 09		 jmp	 SHORT $L1391
$L1392:
  000ff	8b 45 98	 mov	 eax, DWORD PTR _i$[ebp]
  00102	83 c0 01	 add	 eax, 1
  00105	89 45 98	 mov	 DWORD PTR _i$[ebp], eax
$L1391:
  00108	83 7d 98 1f	 cmp	 DWORD PTR _i$[ebp], 31	; 0000001fH
  0010c	0f 8d 8a 00 00
	00		 jge	 $L1393

; 172  :       {
; 173  :      	  if ((TT[i]<TT[i-1]) && (TT[i]<TT[i+1]))

  00112	8b 4d 98	 mov	 ecx, DWORD PTR _i$[ebp]
  00115	8b 55 88	 mov	 edx, DWORD PTR _TT$[ebp]
  00118	8b 45 98	 mov	 eax, DWORD PTR _i$[ebp]
  0011b	8b 75 88	 mov	 esi, DWORD PTR _TT$[ebp]
  0011e	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  00121	d8 5c 86 fc	 fcomp	 DWORD PTR [esi+eax*4-4]
  00125	df e0		 fnstsw	 ax
  00127	f6 c4 05	 test	 ah, 5
  0012a	7a 6b		 jp	 SHORT $L1394
  0012c	8b 4d 98	 mov	 ecx, DWORD PTR _i$[ebp]
  0012f	8b 55 88	 mov	 edx, DWORD PTR _TT$[ebp]
  00132	8b 45 98	 mov	 eax, DWORD PTR _i$[ebp]
  00135	8b 75 88	 mov	 esi, DWORD PTR _TT$[ebp]
  00138	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  0013b	d8 5c 86 04	 fcomp	 DWORD PTR [esi+eax*4+4]
  0013f	df e0		 fnstsw	 ax
  00141	f6 c4 05	 test	 ah, 5
  00144	7a 51		 jp	 SHORT $L1394

; 174  :     	  { 
; 175  :               amp[PeakPos] = (float)sqrt((double)(1.0F/TT[i]));

  00146	8b 4d 98	 mov	 ecx, DWORD PTR _i$[ebp]
  00149	8b 55 88	 mov	 edx, DWORD PTR _TT$[ebp]
  0014c	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  00152	d8 34 8a	 fdiv	 DWORD PTR [edx+ecx*4]
  00155	83 ec 08	 sub	 esp, 8
  00158	dd 1c 24	 fstp	 QWORD PTR [esp]
  0015b	e8 00 00 00 00	 call	 _sqrt
  00160	83 c4 08	 add	 esp, 8
  00163	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _PeakPos$[ebp]
  00169	d9 9c 85 b8 fe
	ff ff		 fstp	 DWORD PTR _amp$[ebp+eax*4]

; 176  :               freq[PeakPos++] = (short)i; /* Typically never exceeds 6 */

  00170	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _PeakPos$[ebp]
  00176	66 8b 55 98	 mov	 dx, WORD PTR _i$[ebp]
  0017a	66 89 54 4d a0	 mov	 WORD PTR _freq$[ebp+ecx*2], dx
  0017f	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _PeakPos$[ebp]
  00185	83 c0 01	 add	 eax, 1
  00188	89 85 78 ff ff
	ff		 mov	 DWORD PTR _PeakPos$[ebp], eax

; 177  :               i++;        /* can't hit another peak right away */

  0018e	8b 4d 98	 mov	 ecx, DWORD PTR _i$[ebp]
  00191	83 c1 01	 add	 ecx, 1
  00194	89 4d 98	 mov	 DWORD PTR _i$[ebp], ecx
$L1394:

; 178  :           }
; 179  :       }

  00197	e9 63 ff ff ff	 jmp	 $L1392
$L1393:

; 180  :       
; 181  :       amp[0] = (float)sqrt((double)(1.0F/TT[0])); 

  0019c	8b 55 88	 mov	 edx, DWORD PTR _TT$[ebp]
  0019f	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  001a5	d8 32		 fdiv	 DWORD PTR [edx]
  001a7	83 ec 08	 sub	 esp, 8
  001aa	dd 1c 24	 fstp	 QWORD PTR [esp]
  001ad	e8 00 00 00 00	 call	 _sqrt
  001b2	83 c4 08	 add	 esp, 8
  001b5	d9 9d b8 fe ff
	ff		 fstp	 DWORD PTR _amp$[ebp]

; 182  :       freq[0] = 0;

  001bb	66 c7 45 a0 00
	00		 mov	 WORD PTR _freq$[ebp], 0

; 183  : 
; 184  :       amp[PeakPos] = (float)sqrt((double)(1.0F/TT[ENHANCE_FFT2-1]));

  001c1	8b 45 88	 mov	 eax, DWORD PTR _TT$[ebp]
  001c4	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  001ca	d8 70 7c	 fdiv	 DWORD PTR [eax+124]
  001cd	83 ec 08	 sub	 esp, 8
  001d0	dd 1c 24	 fstp	 QWORD PTR [esp]
  001d3	e8 00 00 00 00	 call	 _sqrt
  001d8	83 c4 08	 add	 esp, 8
  001db	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _PeakPos$[ebp]
  001e1	d9 9c 8d b8 fe
	ff ff		 fstp	 DWORD PTR _amp$[ebp+ecx*4]

; 185  :       freq[PeakPos++] = ENHANCE_FFT2-1;

  001e8	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _PeakPos$[ebp]
  001ee	66 c7 44 55 a0
	1f 00		 mov	 WORD PTR _freq$[ebp+edx*2], 31 ; 0000001fH
  001f5	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _PeakPos$[ebp]
  001fb	83 c0 01	 add	 eax, 1
  001fe	89 85 78 ff ff
	ff		 mov	 DWORD PTR _PeakPos$[ebp], eax

; 186  : 
; 187  :     /********************************************************
; 188  :      multiply by -0.5 instead of taking square root
; 189  :      and then division, used the following two identities 
; 190  :      to eliminate sqrt and div operation
; 191  :      (sqrt(y))^k = y^(k/2)
; 192  :      (1/y)^x = y^(-x)
; 193  : 
; 194  :      since interpolations are only needed at the harmonics, 
; 195  :      there is no need to calculate the whole XK[] array, the
; 196  :      trick here is : just calculate XK at the harmonics
; 197  :     ********************************************************/
; 198  : #if USE_POWER_ESTIMATE
; 199  :       pwrTbl = (Pv<=0.1F)?Poly125:Poly150;
; 200  : #else
; 201  : #if 0 
; 202  :       POWFactor = (Pv<=0.25F)?(SUPPRESSION_FACTOR2*-0.5F):(float)(SUPPRESSION_FACTOR*-0.5F);
; 203  : #else
; 204  : /* Pitch adaptive Post filter AGUILAR 2/26/97 */
; 205  : if(Pv<=0.25){

  00204	d9 45 0c	 fld	 DWORD PTR _Pv$[ebp]
  00207	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3fd0000000000000
  0020d	df e0		 fnstsw	 ax
  0020f	f6 c4 41	 test	 ah, 65			; 00000041H
  00212	7a 09		 jp	 SHORT $L1402

; 206  : 	POWFactor=SF_0*(-0.5F);

  00214	c7 45 80 33 33
	33 be		 mov	 DWORD PTR _POWFactor$[ebp], -1103940813 ; be333333H

; 207  :   }
; 208  :   else

  0021b	eb 59		 jmp	 SHORT $L1403
$L1402:

; 209  :  {
; 210  : 	if(PitchLag<=SF_P1){

  0021d	d9 45 10	 fld	 DWORD PTR _PitchLag$[ebp]
  00220	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@425551ec
  00226	df e0		 fnstsw	 ax
  00228	f6 c4 41	 test	 ah, 65			; 00000041H
  0022b	7a 09		 jp	 SHORT $L1404

; 211  : 		POWFactor=SF_1*(-0.5F);

  0022d	c7 45 80 cd cc
	cc bd		 mov	 DWORD PTR _POWFactor$[ebp], -1110651699 ; bdcccccdH

; 212  : 	}
; 213  : 	else

  00234	eb 40		 jmp	 SHORT $L1403
$L1404:

; 214  : 	{
; 215  : 		if(PitchLag>SF_P1 && PitchLag <=SF_P2 ){

  00236	d9 45 10	 fld	 DWORD PTR _PitchLag$[ebp]
  00239	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@425551ec
  0023f	df e0		 fnstsw	 ax
  00241	f6 c4 41	 test	 ah, 65			; 00000041H
  00244	75 19		 jne	 SHORT $L1406
  00246	d9 45 10	 fld	 DWORD PTR _PitchLag$[ebp]
  00249	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@42a00000
  0024f	df e0		 fnstsw	 ax
  00251	f6 c4 41	 test	 ah, 65			; 00000041H
  00254	7a 09		 jp	 SHORT $L1406

; 216  : 			POWFactor=SF_2*(-0.5F);

  00256	c7 45 80 33 33
	33 be		 mov	 DWORD PTR _POWFactor$[ebp], -1103940813 ; be333333H

; 217  : 		}
; 218  : 		else

  0025d	eb 17		 jmp	 SHORT $L1403
$L1406:

; 219  : 		{
; 220  : 			if(PitchLag>SF_P2)

  0025f	d9 45 10	 fld	 DWORD PTR _PitchLag$[ebp]
  00262	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@42a00000
  00268	df e0		 fnstsw	 ax
  0026a	f6 c4 41	 test	 ah, 65			; 00000041H
  0026d	75 07		 jne	 SHORT $L1403

; 221  : 				POWFactor=SF_3*(-0.5F);

  0026f	c7 45 80 00 00
	80 be		 mov	 DWORD PTR _POWFactor$[ebp], -1098907648 ; be800000H
$L1403:

; 222  : 		}
; 223  : 	}
; 224  : 
; 225  :  }
; 226  : #endif
; 227  : #endif
; 228  : 
; 229  :     /************************************************
; 230  :       Fi = Fo = (float)(ENHANCE_FFT)/PitchLag;
; 231  :      ************************************************/
; 232  :       Fi = (long)((((long)1)<<(F_QFACTOR))*(((float)ENHANCE_FFT)/PitchLag));

  00276	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@42800000
  0027c	d8 75 10	 fdiv	 DWORD PTR _PitchLag$[ebp]
  0027f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@4b800000
  00285	e8 00 00 00 00	 call	 __ftol2
  0028a	89 85 7c ff ff
	ff		 mov	 DWORD PTR _Fi$[ebp], eax

; 233  :       Fo = Fi;

  00290	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _Fi$[ebp]
  00296	89 4d 8c	 mov	 DWORD PTR _Fo$[ebp], ecx

; 234  : 
; 235  :       for (i=0,k=0; i<PeakPos-1; i++)

  00299	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  002a0	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$[ebp], 0
  002aa	eb 09		 jmp	 SHORT $L1412
$L1413:
  002ac	8b 55 98	 mov	 edx, DWORD PTR _i$[ebp]
  002af	83 c2 01	 add	 edx, 1
  002b2	89 55 98	 mov	 DWORD PTR _i$[ebp], edx
$L1412:
  002b5	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _PeakPos$[ebp]
  002bb	83 e8 01	 sub	 eax, 1
  002be	39 45 98	 cmp	 DWORD PTR _i$[ebp], eax
  002c1	0f 8d 6e 01 00
	00		 jge	 $L1385

; 236  :       {
; 237  :          slope = (amp[i+1]-amp[i])/(float)(freq[i+1]-freq[i]); 

  002c7	8b 4d 98	 mov	 ecx, DWORD PTR _i$[ebp]
  002ca	8b 55 98	 mov	 edx, DWORD PTR _i$[ebp]
  002cd	d9 84 8d bc fe
	ff ff		 fld	 DWORD PTR _amp$[ebp+ecx*4+4]
  002d4	d8 a4 95 b8 fe
	ff ff		 fsub	 DWORD PTR _amp$[ebp+edx*4]
  002db	8b 45 98	 mov	 eax, DWORD PTR _i$[ebp]
  002de	0f bf 4c 45 a2	 movsx	 ecx, WORD PTR _freq$[ebp+eax*2+2]
  002e3	8b 55 98	 mov	 edx, DWORD PTR _i$[ebp]
  002e6	0f bf 44 55 a0	 movsx	 eax, WORD PTR _freq$[ebp+edx*2]
  002eb	2b c8		 sub	 ecx, eax
  002ed	89 8d a4 fd ff
	ff		 mov	 DWORD PTR tv357[ebp], ecx
  002f3	da b5 a4 fd ff
	ff		 fidiv	 DWORD PTR tv357[ebp]
  002f9	d9 5d 9c	 fstp	 DWORD PTR _slope$[ebp]

; 238  :        /***********************************************
; 239  :          FiInt = (int)Fi;
; 240  :         ***********************************************/
; 241  : 			FiInt = (int)(Fi>>F_QFACTOR);

  002fc	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _Fi$[ebp]
  00302	c1 f9 18	 sar	 ecx, 24			; 00000018H
  00305	89 4d 90	 mov	 DWORD PTR _FiInt$[ebp], ecx
$L1418:

; 242  : 
; 243  :          while ((k<nHarm)&&(FiInt<freq[i+1]))

  00308	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR _k$[ebp]
  0030e	3b 55 14	 cmp	 edx, DWORD PTR _nHarm$[ebp]
  00311	0f 8d 19 01 00
	00		 jge	 $L1419
  00317	8b 45 98	 mov	 eax, DWORD PTR _i$[ebp]
  0031a	0f bf 4c 45 a2	 movsx	 ecx, WORD PTR _freq$[ebp+eax*2+2]
  0031f	39 4d 90	 cmp	 DWORD PTR _FiInt$[ebp], ecx
  00322	0f 8d 08 01 00
	00		 jge	 $L1419

; 244  :          {
; 245  :             /*calculation the interpolation*/
; 246  : #if (INTERPOLATE_BETWEEN_FFT_BINS==1)
; 247  :             XK = amp[i] + slope*(float)((Fi*F_TO_FLOAT)-freq[i]);

  00328	db 85 7c ff ff
	ff		 fild	 DWORD PTR _Fi$[ebp]
  0032e	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@33800000
  00334	8b 55 98	 mov	 edx, DWORD PTR _i$[ebp]
  00337	0f bf 44 55 a0	 movsx	 eax, WORD PTR _freq$[ebp+edx*2]
  0033c	89 85 a0 fd ff
	ff		 mov	 DWORD PTR tv362[ebp], eax
  00342	da a5 a0 fd ff
	ff		 fisub	 DWORD PTR tv362[ebp]
  00348	d8 4d 9c	 fmul	 DWORD PTR _slope$[ebp]
  0034b	8b 4d 98	 mov	 ecx, DWORD PTR _i$[ebp]
  0034e	d8 84 8d b8 fe
	ff ff		 fadd	 DWORD PTR _amp$[ebp+ecx*4]
  00355	d9 9d 74 ff ff
	ff		 fstp	 DWORD PTR _XK$[ebp]

; 248  : #else
; 249  :             XK = amp[i] + slope*(float)(((Fi+( ((long)1) <<(F_QFACTOR-1) ))>>F_QFACTOR)-freq[i]);
; 250  : #endif
; 251  : 
; 252  :             /* calculate the weighting factor */
; 253  :             /********************************************************************************
; 254  :              Since the FFT size may be reduced, we can increase precision by interpolating
; 255  :              between FFT bins to the frequency of the k'th harmonic instead of just
; 256  :              selecting the nearest bin.  Ideally, we would like to do this interpolation
; 257  :              on the magnitude spectrum of the inverse lpc spectrum, but to reduce complexity,
; 258  :              we interpolate on the PSD of the lpc's, and leave the sqrt and the divide to 
; 259  :              the power function which will handle it all together.  Interpolating the PSD
; 260  :              of the lpc's will perform no worse than just selecting the nearest bin, since
; 261  :              the interpolation is still monotonic, it's just not linear in the 1/MAG domain.
; 262  : 
; 263  :              Note that (Fi&(F_FRACTION_MASK))*F_TO_FLOAT = the fractional part of the FFT
; 264  :                                                            frequency bin.
; 265  :              ********************************************************************************/
; 266  : #if (INTERPOLATE_BETWEEN_FFT_BINS==1)
; 267  :             TTt = TT[FiInt] + (TT[FiInt+1]-TT[FiInt])*((Fi&(F_FRACTION_MASK))*F_TO_FLOAT);

  0035b	8b 55 90	 mov	 edx, DWORD PTR _FiInt$[ebp]
  0035e	8b 45 88	 mov	 eax, DWORD PTR _TT$[ebp]
  00361	8b 4d 90	 mov	 ecx, DWORD PTR _FiInt$[ebp]
  00364	8b 75 88	 mov	 esi, DWORD PTR _TT$[ebp]
  00367	d9 44 90 04	 fld	 DWORD PTR [eax+edx*4+4]
  0036b	d8 24 8e	 fsub	 DWORD PTR [esi+ecx*4]
  0036e	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _Fi$[ebp]
  00374	81 e2 ff ff ff
	00		 and	 edx, 16777215		; 00ffffffH
  0037a	89 95 9c fd ff
	ff		 mov	 DWORD PTR tv370[ebp], edx
  00380	db 85 9c fd ff
	ff		 fild	 DWORD PTR tv370[ebp]
  00386	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@33800000
  0038c	de c9		 fmulp	 ST(1), ST(0)
  0038e	8b 45 90	 mov	 eax, DWORD PTR _FiInt$[ebp]
  00391	8b 4d 88	 mov	 ecx, DWORD PTR _TT$[ebp]
  00394	d8 04 81	 fadd	 DWORD PTR [ecx+eax*4]
  00397	d9 5d 84	 fstp	 DWORD PTR _TTt$[ebp]

; 268  : 
; 269  :            /*************************************************************************************
; 270  :             This commented code is the optimal way to do the interpolation.
; 271  :             -------------------------------------------------------------------------------------
; 272  :             
; 273  :             TTt  = 1.0/( (1.0/sqrt(TT[FiInt])) +  ((1.0/sqrt(TT[FiInt+1]))-(1.0/sqrt(TT[FiInt])))*
; 274  :                    ((Fi&(F_FRACTION_MASK))*F_TO_FLOAT));
; 275  :             TTt *= TTt;
; 276  :             -------------------------------------------------------------------------------------
; 277  :             *************************************************************************************/
; 278  : #else
; 279  :            /**************************************************************************************
; 280  :             Just select the closest FFT bin 
; 281  :             **************************************************************************************/
; 282  :             TTt = TT[(Fi+( ((long)1) <<(F_QFACTOR-1) ))>>F_QFACTOR];
; 283  : #endif
; 284  :             scale = XK*XK*TTt;

  0039a	d9 85 74 ff ff
	ff		 fld	 DWORD PTR _XK$[ebp]
  003a0	d8 8d 74 ff ff
	ff		 fmul	 DWORD PTR _XK$[ebp]
  003a6	d8 4d 84	 fmul	 DWORD PTR _TTt$[ebp]
  003a9	d9 55 94	 fst	 DWORD PTR _scale$[ebp]

; 285  :             if (scale > 1.0)

  003ac	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3ff0000000000000
  003b2	df e0		 fnstsw	 ax
  003b4	f6 c4 41	 test	 ah, 65			; 00000041H
  003b7	75 48		 jne	 SHORT $L1424

; 286  :             {
; 287  : #if (USE_POWER_ESTIMATE==1)
; 288  :                lf = powerpoly(scale, pwrTbl);  /* this function could be inlined */
; 289  : #else
; 290  : #ifndef WIN32
; 291  :                lf = (float)pow((double)(scale), (double)POWFactor);
; 292  : #else  /*WIN32 */
; 293  :                lf = myPower(scale, POWFactor);

  003b9	8b 55 80	 mov	 edx, DWORD PTR _POWFactor$[ebp]
  003bc	52		 push	 edx
  003bd	8b 45 94	 mov	 eax, DWORD PTR _scale$[ebp]
  003c0	50		 push	 eax
  003c1	e8 00 00 00 00	 call	 _myPower@8
  003c6	d9 95 b0 fe ff
	ff		 fst	 DWORD PTR _lf$[ebp]

; 294  : #endif /*WIN32 */
; 295  : #endif
; 296  :                if (lf < 0.3F) 

  003cc	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3e99999a
  003d2	df e0		 fnstsw	 ax
  003d4	f6 c4 05	 test	 ah, 5
  003d7	7a 0a		 jp	 SHORT $L1425

; 297  :                   lf = 0.3F;

  003d9	c7 85 b0 fe ff
	ff 9a 99 99 3e	 mov	 DWORD PTR _lf$[ebp], 1050253722 ; 3e99999aH
$L1425:

; 298  : 
; 299  :                /* weight the harmonic amplitudes */
; 300  :                HarmAmp[k] *= lf;

  003e3	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR _k$[ebp]
  003e9	8b 55 18	 mov	 edx, DWORD PTR _HarmAmp$[ebp]
  003ec	d9 85 b0 fe ff
	ff		 fld	 DWORD PTR _lf$[ebp]
  003f2	d8 0c 8a	 fmul	 DWORD PTR [edx+ecx*4]
  003f5	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _k$[ebp]
  003fb	8b 4d 18	 mov	 ecx, DWORD PTR _HarmAmp$[ebp]
  003fe	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
$L1424:

; 301  :             }
; 302  :             Fi+=Fo;

  00401	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _Fi$[ebp]
  00407	03 55 8c	 add	 edx, DWORD PTR _Fo$[ebp]
  0040a	89 95 7c ff ff
	ff		 mov	 DWORD PTR _Fi$[ebp], edx

; 303  :             FiInt = (int)(Fi>>F_QFACTOR);

  00410	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _Fi$[ebp]
  00416	c1 f8 18	 sar	 eax, 24			; 00000018H
  00419	89 45 90	 mov	 DWORD PTR _FiInt$[ebp], eax

; 304  :             k++;

  0041c	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR _k$[ebp]
  00422	83 c1 01	 add	 ecx, 1
  00425	89 8d b4 fe ff
	ff		 mov	 DWORD PTR _k$[ebp], ecx

; 305  :          }          

  0042b	e9 d8 fe ff ff	 jmp	 $L1418
$L1419:

; 306  :       }

  00430	e9 77 fe ff ff	 jmp	 $L1413
$L1385:

; 307  :    } /* if fail */
; 308  : 
; 309  :    STACK_END
; 310  :    return 0;

  00435	66 33 c0	 xor	 ax, ax

; 311  : }

  00438	5e		 pop	 esi
  00439	8b e5		 mov	 esp, ebp
  0043b	5d		 pop	 ebp
  0043c	c2 14 00	 ret	 20			; 00000014H
_VoxEnhance@20 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _myPower@8
_TEXT	SEGMENT
tv80 = -16
tv75 = -12
_result$ = -8
_IntPow$ = -4
_x$ = 8
_y$ = 12
_myPower@8 PROC NEAR					; COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 318  : 	int IntPow;	
; 319  : 	float result;
; 320  :    _asm												 		
; 321  :    {											
; 322  :       fld1					/*load 1*/				 

  00006	d9 e8		 fld1

; 323  :       fld		y			/*load y*/				 

  00008	d9 45 0c	 fld	 DWORD PTR _y$[ebp]

; 324  :       fld		x		    /*load x*/               

  0000b	d9 45 08	 fld	 DWORD PTR _x$[ebp]

; 325  :       fyl2x                /* y*log2(x)*/           

  0000e	d9 f1		 fyl2x

; 326  :       fist     IntPow      /*save the integer part*/

  00010	db 55 fc	 fist	 DWORD PTR _IntPow$[ebp]

; 327  :       fisub    IntPow      /*fraction part left   */

  00013	da 65 fc	 fisub	 DWORD PTR _IntPow$[ebp]

; 328  :       f2xm1                /* 2^^st(0)-1*/          

  00016	d9 f0		 f2xm1

; 329  :       faddp    st(1), st(0) /*2^^st(0), add 1*/     

  00018	de c1		 faddp	 ST(1), ST(0)

; 330  :       fstp     result                               

  0001a	d9 5d f8	 fstp	 DWORD PTR _result$[ebp]

; 331  :    }												 	
; 332  :    if(IntPow>=0)   result *=(1<<IntPow);				 

  0001d	83 7d fc 00	 cmp	 DWORD PTR _IntPow$[ebp], 0
  00021	7c 18		 jl	 SHORT $L1434
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _IntPow$[ebp]
  0002b	d3 e0		 shl	 eax, cl
  0002d	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00030	db 45 f4	 fild	 DWORD PTR tv75[ebp]
  00033	d8 4d f8	 fmul	 DWORD PTR _result$[ebp]
  00036	d9 5d f8	 fstp	 DWORD PTR _result$[ebp]

; 333  :    else   	    result /=(1<<(-IntPow));				 	

  00039	eb 18		 jmp	 SHORT $L1435
$L1434:
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _IntPow$[ebp]
  0003e	f7 d9		 neg	 ecx
  00040	ba 01 00 00 00	 mov	 edx, 1
  00045	d3 e2		 shl	 edx, cl
  00047	89 55 f0	 mov	 DWORD PTR tv80[ebp], edx
  0004a	db 45 f0	 fild	 DWORD PTR tv80[ebp]
  0004d	d8 7d f8	 fdivr	 DWORD PTR _result$[ebp]
  00050	d9 5d f8	 fstp	 DWORD PTR _result$[ebp]
$L1435:

; 334  :    return result;

  00053	d9 45 f8	 fld	 DWORD PTR _result$[ebp]

; 335  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
_myPower@8 ENDP
_TEXT	ENDS
END
