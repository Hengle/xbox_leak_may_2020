; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\svqphase.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EB@EOCEMGIB@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EC@LDLMIKIO@?$CIpfPhase?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase_Er@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@KAPJIGIO@iIndex?5?$DM?5PHASE0_LEVELS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@HEFFIIAD@piIndices?$FLi?$FN?5?$DM?5?$CI1?$DM?$DMBITS_PHASE_PA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EC@PCMBNHCL@?$CIpiIndices?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@HLINMDHH@pfPhase?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@NAOMJKJJ@pfPhaseMid?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxSVQEncPhase@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxSVQDecPhase@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxEncPhasePrediction@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxDecPhasePrediction@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
CONST	SEGMENT
_fPhaseCodeBookTable DD 03ee1c9d6r		; 0.440993
	DD	0408e71c1r			; 4.45139
	DD	03ede7e41r			; 0.434557
	DD	03fc8ab04r			; 1.56772
	DD	03ef5944br			; 0.479647
	DD	040b0e7f7r			; 5.52832
	DD	03f7294ddr			; 0.947584
	DD	04065cf68r			; 3.59078
	DD	03f1f8898r			; 0.623178
	DD	03f2a5615r			; 0.665376
	DD	03ed81a7ar			; 0.422077
	DD	0402f7d63r			; 2.74203
	DD	03eda1d11r			; 0.426003
	DD	040c119d2r			; 6.0344
	DD	03edb402dr			; 0.428224
	DD	040a04cd3r			; 5.00938
	DD	03ee3506er			; 0.443973
	DD	0400a1334r			; 2.15742
	DD	03eeb9778r			; 0.46014
	DD	0407a58efr			; 3.91168
	DD	03f6aa055r			; 0.916509
	DD	040bf43d4r			; 5.97703
	DD	03f6d9360r			; 0.92803
	DD	040871510r			; 4.22132
	DD	03ed43deer			; 0.414535
	DD	040559585r			; 3.33725
	DD	03eca085br			; 0.394595
	DD	03f8a7475r			; 1.08168
	DD	03f57a42fr			; 0.842349
	DD	040420186r			; 3.03134
	DD	03efecbb8r			; 0.497648
	DD	03e6ab29er			; 0.229197
	DD	03fbfb435r			; 1.49769
	DD	040bf94d3r			; 5.98692
	DD	040336955r			; 2.8033
	DD	04094b01dr			; 4.6465
	DD	03fb4d973r			; 1.41289
	DD	040452e41r			; 3.08095
	DD	03ff7fbc6r			; 1.93737
	DD	03fc95504r			; 1.57291
	DD	03f7e6f93r			; 0.99389
	DD	040ac6ee9r			; 5.38854
	DD	03ffdabb9r			; 1.9818
	DD	0405a8a2br			; 3.41468
	DD	03f656042r			; 0.896
	DD	03fee0b35r			; 1.85972
	DD	03fadf373r			; 1.35899
	DD	03f53ee5fr			; 0.827856
	DD	0400b141ar			; 2.1731
	DD	0409f2961r			; 4.9738
	DD	0402de36dr			; 2.71701
	DD	040441d1dr			; 3.06428
	DD	03fc34ae4r			; 1.52572
	DD	0400b0547r			; 2.1722
	DD	0402cbea5r			; 2.69914
	DD	03e9e10aer			; 0.308721
	DD	03f70aba4r			; 0.940119
	DD	0409a94c0r			; 4.83066
	DD	0400f6e69r			; 2.24111
	DD	0400a5ceer			; 2.16192
	DD	03f626235r			; 0.884311
	DD	03f9b4930r			; 1.21317
	DD	03f8ecc57r			; 1.11561
	DD	03e9401e7r			; 0.289077
	DD	04007d14ar			; 2.12215
	DD	040bc31e8r			; 5.88109
	DD	0402e5087r			; 2.72366
	DD	040aba75br			; 5.36418
	DD	03fc193der			; 1.51233
	DD	04078f7b6r			; 3.89012
	DD	0403060afr			; 2.7559
	DD	03fd17037r			; 1.63624
	DD	03fcac301r			; 1.58408
	DD	040a92b91r			; 5.28657
	DD	040077629r			; 2.11659
	DD	04086fa70r			; 4.21807
	DD	03f8013b2r			; 1.0006
	DD	0401e2bd0r			; 2.47142
	DD	040051b71r			; 2.0798
	DD	03f6bb57cr			; 0.920738
	DD	04032847fr			; 2.78934
	DD	040bfd565r			; 5.9948
	DD	040311fd1r			; 2.76757
	DD	0407555d6r			; 3.83336
	DD	03ffd48dcr			; 1.97879
	DD	0402fe932r			; 2.74861
	DD	04032eb42r			; 2.79561
	DD	03f7d0aaar			; 0.988444
	DD	03fbee3d6r			; 1.49133
	DD	04092c237r			; 4.58621
	DD	04035cfabr			; 2.8408
	DD	04018af60r			; 2.3857
	DD	03faf5504r			; 1.36978
	DD	03fba464ar			; 1.45527
	DD	03fecf15er			; 1.85112
	DD	03e8eba8cr			; 0.278767
_sPhaseCOVIndex DD 00H
	DD	010H
	DD	01H
	DD	011H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	012H
	DD	013H
	DD	06H
	DD	014H
	DD	07H
	DD	015H
	DD	08H
	DD	09H
	DD	016H
	DD	017H
	DD	0aH
	DD	018H
	DD	0bH
	DD	019H
	DD	0cH
	DD	0dH
	DD	01aH
	DD	01bH
	DD	01cH
	DD	01dH
	DD	0eH
	DD	01eH
	DD	0fH
	DD	01fH
	DD	020H
	DD	021H
	DD	022H
	DD	023H
	DD	024H
	DD	025H
	DD	026H
	DD	027H
	DD	028H
	DD	029H
	DD	02aH
	DD	02bH
	DD	02cH
	DD	02dH
	DD	02eH
	DD	02fH
	DD	030H
	DD	031H
	DD	032H
	DD	033H
	DD	034H
	DD	035H
	DD	036H
	DD	037H
	DD	038H
	DD	039H
	DD	03aH
	DD	03bH
	DD	03cH
	DD	03dH
	DD	03eH
	DD	03fH
CONST	ENDS
PUBLIC	??_C@_0EB@EOCEMGIB@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0EC@LDLMIKIO@?$CIpfPhase?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase_Er@ ; `string'
PUBLIC	??_C@_0BH@KAPJIGIO@iIndex?5?$DM?5PHASE0_LEVELS?$AA@ ; `string'
PUBLIC	??_C@_0CI@HEFFIIAD@piIndices?$FLi?$FN?5?$DM?5?$CI1?$DM?$DMBITS_PHASE_PA@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3e5e7360
PUBLIC	__real@3e455326
PUBLIC	__real@40a2f983
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	_VoxSVQEncPhase@12
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	__assert:NEAR
EXTRN	_Dim2VectorQuantize@12:NEAR
;	COMDAT ??_C@_0EB@EOCEMGIB@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\svqphase.c
CONST	SEGMENT
??_C@_0EB@EOCEMGIB@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\svqphase.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@LDLMIKIO@?$CIpfPhase?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase_Er@
CONST	SEGMENT
??_C@_0EC@LDLMIKIO@?$CIpfPhase?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase_Er@ DB '('
	DB	'pfPhase != NULL) && (pfPhase_Err != NULL) && (piIndices != NU'
	DB	'LL)', 00H					; `string'
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3e5e7360
CONST	SEGMENT
__real@3e5e7360 DD 03e5e7360r			; 0.217237
CONST	ENDS
;	COMDAT __real@3e455326
CONST	SEGMENT
__real@3e455326 DD 03e455326r			; 0.1927
CONST	ENDS
;	COMDAT __real@40a2f983
CONST	SEGMENT
__real@40a2f983 DD 040a2f983r			; 5.09296
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_0BH@KAPJIGIO@iIndex?5?$DM?5PHASE0_LEVELS?$AA@
CONST	SEGMENT
??_C@_0BH@KAPJIGIO@iIndex?5?$DM?5PHASE0_LEVELS?$AA@ DB 'iIndex < PHASE0_L'
	DB	'EVELS', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HEFFIIAD@piIndices?$FLi?$FN?5?$DM?5?$CI1?$DM?$DMBITS_PHASE_PA@
CONST	SEGMENT
??_C@_0CI@HEFFIIAD@piIndices?$FLi?$FN?5?$DM?5?$CI1?$DM?$DMBITS_PHASE_PA@ DB 'p'
	DB	'iIndices[i] < (1<<BITS_PHASE_PAIR_SC6)', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxSVQEncPhase@12
_TEXT	SEGMENT
tv136 = -28
_j$ = -24
_iSignBit$ = -20
_pfVector$ = -16
_iIndex$ = -8
_i$ = -4
_pfPhase_Err$ = 8
_pfPhase$ = 12
_piIndices$ = 16
_VoxSVQEncPhase@12 PROC NEAR				; COMDAT

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 112  :   int   i, j;
; 113  :   int   iSignBit, iIndex;
; 114  :   float pfVector[2];
; 115  : 
; 116  :   assert((pfPhase != NULL) && (pfPhase_Err != NULL) && (piIndices != NULL));

  00006	83 7d 0c 00	 cmp	 DWORD PTR _pfPhase$[ebp], 0
  0000a	74 0c		 je	 SHORT $L1163
  0000c	83 7d 08 00	 cmp	 DWORD PTR _pfPhase_Err$[ebp], 0
  00010	74 06		 je	 SHORT $L1163
  00012	83 7d 10 00	 cmp	 DWORD PTR _piIndices$[ebp], 0
  00016	75 14		 jne	 SHORT $L1164
$L1163:
  00018	6a 74		 push	 116			; 00000074H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@EOCEMGIB@c?3?2xbox?2private?2windows?2directx?2@
  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EC@LDLMIKIO@?$CIpfPhase?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase_Er@
  00024	e8 00 00 00 00	 call	 __assert
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1164:

; 117  : 
; 118  :   for (i=0; i<SC6_PHASES; i++)

  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00033	eb 09		 jmp	 SHORT $L1061
$L1062:
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00038	83 c1 01	 add	 ecx, 1
  0003b	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L1061:
  0003e	83 7d fc 08	 cmp	 DWORD PTR _i$[ebp], 8
  00042	0f 8d a4 01 00
	00		 jge	 $L1049

; 119  :     {
; 120  :       /*--------------------------------------------
; 121  :         Get the sign bit and set the phase error 
; 122  :         larger than 0.
; 123  :         --------------------------------------------*/
; 124  :       if (pfPhase_Err[i] < 0.0F)

  00048	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0004b	8b 45 08	 mov	 eax, DWORD PTR _pfPhase_Err$[ebp]
  0004e	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  00051	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00057	df e0		 fnstsw	 ax
  00059	f6 c4 05	 test	 ah, 5
  0005c	7a 1d		 jp	 SHORT $L1064

; 125  :         {
; 126  :           pfPhase_Err[i] = -pfPhase_Err[i];

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00061	8b 55 08	 mov	 edx, DWORD PTR _pfPhase_Err$[ebp]
  00064	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  00067	d9 e0		 fchs
  00069	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _pfPhase_Err$[ebp]
  0006f	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]

; 127  :           iSignBit = 1;

  00072	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iSignBit$[ebp], 1

; 128  :         }
; 129  :       else 

  00079	eb 07		 jmp	 SHORT $L1065
$L1064:

; 130  :         iSignBit = 0;

  0007b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iSignBit$[ebp], 0
$L1065:

; 131  : 
; 132  :       /*--------------------------------------------
; 133  :         Test for a 10ms phase near zero.
; 134  :         If phase error is small enough, use
; 135  :         linear quantizer.
; 136  :         --------------------------------------------*/
; 137  :       if (pfPhase_Err[i] < PHASE0_ERR_THRD)

  00082	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00085	8b 45 08	 mov	 eax, DWORD PTR _pfPhase_Err$[ebp]
  00088	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  0008b	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3e5e7360
  00091	df e0		 fnstsw	 ax
  00093	f6 c4 05	 test	 ah, 5
  00096	0f 8a b6 00 00
	00		 jp	 $L1066

; 138  :         {
; 139  :           /*----------------------------------------
; 140  :             Do linear quantization 
; 141  :             ----------------------------------------*/
; 142  :           iIndex = VoxFLOOR((pfPhase[i]-PHASE0_FLOOR)
; 143  :                             *PHASE0_FACTOR+0.5F);

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0009f	8b 55 0c	 mov	 edx, DWORD PTR _pfPhase$[ebp]
  000a2	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  000a5	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3e455326
  000ab	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40a2f983
  000b1	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f000000
  000b7	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  000bd	df e0		 fnstsw	 ax
  000bf	f6 c4 01	 test	 ah, 1
  000c2	75 20		 jne	 SHORT $L1165
  000c4	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000c7	8b 4d 0c	 mov	 ecx, DWORD PTR _pfPhase$[ebp]
  000ca	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  000cd	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3e455326
  000d3	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40a2f983
  000d9	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f000000
  000df	d9 5d e4	 fstp	 DWORD PTR tv136[ebp]
  000e2	eb 24		 jmp	 SHORT $L1166
$L1165:
  000e4	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000e7	8b 45 0c	 mov	 eax, DWORD PTR _pfPhase$[ebp]
  000ea	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  000ed	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3e455326
  000f3	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40a2f983
  000f9	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f000000
  000ff	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3f800000
  00105	d9 5d e4	 fstp	 DWORD PTR tv136[ebp]
$L1166:
  00108	d9 45 e4	 fld	 DWORD PTR tv136[ebp]
  0010b	e8 00 00 00 00	 call	 __ftol2
  00110	89 45 f8	 mov	 DWORD PTR _iIndex$[ebp], eax

; 144  :           if (iIndex < 0)

  00113	83 7d f8 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00117	7d 09		 jge	 SHORT $L1068

; 145  :             iIndex += PHASE0_LEVELS;

  00119	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0011c	83 c1 20	 add	 ecx, 32			; 00000020H
  0011f	89 4d f8	 mov	 DWORD PTR _iIndex$[ebp], ecx
$L1068:

; 146  : 
; 147  :           assert(iIndex < PHASE0_LEVELS);

  00122	83 7d f8 20	 cmp	 DWORD PTR _iIndex$[ebp], 32 ; 00000020H
  00126	7c 17		 jl	 SHORT $L1167
  00128	68 93 00 00 00	 push	 147			; 00000093H
  0012d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@EOCEMGIB@c?3?2xbox?2private?2windows?2directx?2@
  00132	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@KAPJIGIO@iIndex?5?$DM?5PHASE0_LEVELS?$AA@
  00137	e8 00 00 00 00	 call	 __assert
  0013c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1167:

; 148  : 
; 149  :           /*----------------------------------------
; 150  :             Extract the sign bit.
; 151  :             ----------------------------------------*/
; 152  :           iSignBit = iIndex & 1;

  0013f	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00142	83 e0 01	 and	 eax, 1
  00145	89 45 ec	 mov	 DWORD PTR _iSignBit$[ebp], eax

; 153  :           iIndex = iIndex >> 1;

  00148	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0014b	d1 f9		 sar	 ecx, 1
  0014d	89 4d f8	 mov	 DWORD PTR _iIndex$[ebp], ecx

; 154  :         }
; 155  :       else

  00150	eb 34		 jmp	 SHORT $L1071
$L1066:

; 156  :         /*--------------------------------------------------
; 157  :           Do vector quantization if phase error is above the
; 158  :           threshold.
; 159  :           --------------------------------------------------*/
; 160  :         {
; 161  :          /*--------------------------------------------
; 162  :            Create the vector pair for Dim2VectorQuantize()
; 163  :            --------------------------------------------*/
; 164  :          pfVector[0] = pfPhase_Err[i];

  00152	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00155	8b 45 08	 mov	 eax, DWORD PTR _pfPhase_Err$[ebp]
  00158	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  0015b	89 4d f0	 mov	 DWORD PTR _pfVector$[ebp], ecx

; 165  :          pfVector[1] = pfPhase[i];

  0015e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00161	8b 45 0c	 mov	 eax, DWORD PTR _pfPhase$[ebp]
  00164	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00167	89 4d f4	 mov	 DWORD PTR _pfVector$[ebp+4], ecx

; 166  : 
; 167  :          /*--------------------------------------------
; 168  :            Encode subvector using fast search
; 169  :            --------------------------------------------*/
; 170  :          iIndex = Dim2VectorQuantize(pfVector, fPhaseCodeBookTable, 
; 171  :                                      PHASE_VQ_SIZE);

  0016a	6a 30		 push	 48			; 00000030H
  0016c	68 00 00 00 00	 push	 OFFSET FLAT:_fPhaseCodeBookTable
  00171	8d 55 f0	 lea	 edx, DWORD PTR _pfVector$[ebp]
  00174	52		 push	 edx
  00175	e8 00 00 00 00	 call	 _Dim2VectorQuantize@12
  0017a	89 45 f8	 mov	 DWORD PTR _iIndex$[ebp], eax

; 172  :           
; 173  :          /*--------------------------------------------------
; 174  :            Normalize the index by considering SQ level without
; 175  :            sign bits.
; 176  :            --------------------------------------------------*/
; 177  :          iIndex += (PHASE0_LEVELS>>1);

  0017d	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00180	83 c0 10	 add	 eax, 16			; 00000010H
  00183	89 45 f8	 mov	 DWORD PTR _iIndex$[ebp], eax
$L1071:

; 178  :         }
; 179  : 
; 180  :       /*--------------------------------------------------
; 181  :         Now search for the channel optimized index 
; 182  :         --------------------------------------------------*/
; 183  :       j = 0;

  00186	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$L1073:

; 184  :       while(iIndex != sPhaseCOVIndex[j])

  0018d	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp]
  00190	8b 55 f8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00193	3b 14 8d 00 00
	00 00		 cmp	 edx, DWORD PTR _sPhaseCOVIndex[ecx*4]
  0019a	74 0b		 je	 SHORT $L1074

; 185  :         j++;

  0019c	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  0019f	83 c0 01	 add	 eax, 1
  001a2	89 45 e8	 mov	 DWORD PTR _j$[ebp], eax
  001a5	eb e6		 jmp	 SHORT $L1073
$L1074:

; 186  :       iIndex = j;

  001a7	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp]
  001aa	89 4d f8	 mov	 DWORD PTR _iIndex$[ebp], ecx

; 187  : 
; 188  :       /*--------------------------------------------------
; 189  :         Combine quantization index and the sign bits
; 190  :         --------------------------------------------------*/
; 191  :       piIndices[i] = iIndex + (iSignBit<<(BITS_PHASE_PAIR_SC6-1));

  001ad	8b 55 ec	 mov	 edx, DWORD PTR _iSignBit$[ebp]
  001b0	c1 e2 06	 shl	 edx, 6
  001b3	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  001b6	03 c2		 add	 eax, edx
  001b8	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001bb	8b 55 10	 mov	 edx, DWORD PTR _piIndices$[ebp]
  001be	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 192  : 
; 193  :       assert(piIndices[i] < (1<<BITS_PHASE_PAIR_SC6));

  001c1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001c4	8b 4d 10	 mov	 ecx, DWORD PTR _piIndices$[ebp]
  001c7	81 3c 81 80 00
	00 00		 cmp	 DWORD PTR [ecx+eax*4], 128 ; 00000080H
  001ce	7c 17		 jl	 SHORT $L1168
  001d0	68 c1 00 00 00	 push	 193			; 000000c1H
  001d5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@EOCEMGIB@c?3?2xbox?2private?2windows?2directx?2@
  001da	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@HEFFIIAD@piIndices?$FLi?$FN?5?$DM?5?$CI1?$DM?$DMBITS_PHASE_PA@
  001df	e8 00 00 00 00	 call	 __assert
  001e4	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1168:

; 194  :    }

  001e7	e9 49 fe ff ff	 jmp	 $L1062
$L1049:

; 195  : }

  001ec	8b e5		 mov	 esp, ebp
  001ee	5d		 pop	 ebp
  001ef	c2 0c 00	 ret	 12			; 0000000cH
_VoxSVQEncPhase@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@PCMBNHCL@?$CIpiIndices?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase?5@ ; `string'
PUBLIC	__real@3e490fdb
PUBLIC	__real@40c90fdb
PUBLIC	_VoxSVQDecPhase@12
EXTRN	_Dim2VectorLUT@16:NEAR
;	COMDAT ??_C@_0EC@PCMBNHCL@?$CIpiIndices?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase?5@
CONST	SEGMENT
??_C@_0EC@PCMBNHCL@?$CIpiIndices?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase?5@ DB '('
	DB	'piIndices != NULL) && (pfPhase != NULL) && (pfPhase_Err != NU'
	DB	'LL)', 00H					; `string'
CONST	ENDS
;	COMDAT __real@3e490fdb
CONST	SEGMENT
__real@3e490fdb DD 03e490fdbr			; 0.19635
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxSVQDecPhase@12
_TEXT	SEGMENT
_iSignBit$ = -20
_pfVector$ = -16
_iIndex$ = -8
_i$ = -4
_piIndices$ = 8
_pfPhase_Err$ = 12
_pfPhase$ = 16
_VoxSVQDecPhase@12 PROC NEAR				; COMDAT

; 229  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 230  :   int   i, iIndex, iSignBit;
; 231  :   float pfVector[2];
; 232  : 
; 233  :   assert((piIndices != NULL) && (pfPhase != NULL) && (pfPhase_Err != NULL));

  00006	83 7d 08 00	 cmp	 DWORD PTR _piIndices$[ebp], 0
  0000a	74 0c		 je	 SHORT $L1186
  0000c	83 7d 10 00	 cmp	 DWORD PTR _pfPhase$[ebp], 0
  00010	74 06		 je	 SHORT $L1186
  00012	83 7d 0c 00	 cmp	 DWORD PTR _pfPhase_Err$[ebp], 0
  00016	75 17		 jne	 SHORT $L1187
$L1186:
  00018	68 e9 00 00 00	 push	 233			; 000000e9H
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@EOCEMGIB@c?3?2xbox?2private?2windows?2directx?2@
  00022	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EC@PCMBNHCL@?$CIpiIndices?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfPhase?5@
  00027	e8 00 00 00 00	 call	 __assert
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1187:

; 234  : 
; 235  :   for (i=0; i<SC6_PHASES; i++)

  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00036	eb 09		 jmp	 SHORT $L1093
$L1094:
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0003b	83 c1 01	 add	 ecx, 1
  0003e	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L1093:
  00041	83 7d fc 08	 cmp	 DWORD PTR _i$[ebp], 8
  00045	0f 8d e2 00 00
	00		 jge	 $L1083

; 236  :     {
; 237  :       /*--------------------------------------------------
; 238  :         Get the sign bit and index
; 239  :         --------------------------------------------------*/
; 240  :       iSignBit = piIndices[i]>>(BITS_PHASE_PAIR_SC6-1);

  0004b	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0004e	8b 45 08	 mov	 eax, DWORD PTR _piIndices$[ebp]
  00051	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00054	c1 f9 06	 sar	 ecx, 6
  00057	89 4d ec	 mov	 DWORD PTR _iSignBit$[ebp], ecx

; 241  :       iIndex = piIndices[i] & (PHASE_CODEBOOK_SIZE-1);

  0005a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0005d	8b 45 08	 mov	 eax, DWORD PTR _piIndices$[ebp]
  00060	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00063	83 e1 3f	 and	 ecx, 63			; 0000003fH
  00066	89 4d f8	 mov	 DWORD PTR _iIndex$[ebp], ecx

; 242  : 
; 243  :       /*--------------------------------------------------
; 244  :         Map the channel optimized index to regular index 
; 245  :         --------------------------------------------------*/
; 246  :       iIndex = sPhaseCOVIndex[iIndex];

  00069	8b 55 f8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0006c	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _sPhaseCOVIndex[edx*4]
  00073	89 45 f8	 mov	 DWORD PTR _iIndex$[ebp], eax

; 247  : 
; 248  :       /*--------------------------------------------
; 249  :         Test for a 10ms phase near zero.
; 250  :         The first 16 code entries are for the phase errors
; 251  :         equal to 0. Phases are linearly quantized.
; 252  :         --------------------------------------------*/
; 253  :       if (iIndex < (PHASE0_LEVELS>>1))

  00076	83 7d f8 10	 cmp	 DWORD PTR _iIndex$[ebp], 16 ; 00000010H
  0007a	7d 61		 jge	 SHORT $L1096

; 254  :         {
; 255  :           /*----------------------------------------
; 256  :             Combine the sign bit
; 257  :             ----------------------------------------*/
; 258  :           iIndex = (iIndex<<1) + iSignBit;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0007f	8b 55 ec	 mov	 edx, DWORD PTR _iSignBit$[ebp]
  00082	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00085	89 45 f8	 mov	 DWORD PTR _iIndex$[ebp], eax

; 259  : 
; 260  :          /*----------------------------------------
; 261  :            Decode the phase pair
; 262  :            ----------------------------------------*/
; 263  :           pfPhase_Err[i] = 0.0F;

  00088	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0008b	8b 55 0c	 mov	 edx, DWORD PTR _pfPhase_Err$[ebp]
  0008e	c7 04 8a 00 00
	00 00		 mov	 DWORD PTR [edx+ecx*4], 0

; 264  :           pfPhase[i] = (float)iIndex*INV_PHASE0_FACTOR + PHASE0_FLOOR;

  00095	db 45 f8	 fild	 DWORD PTR _iIndex$[ebp]
  00098	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e490fdb
  0009e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3e455326
  000a4	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000a7	8b 4d 10	 mov	 ecx, DWORD PTR _pfPhase$[ebp]
  000aa	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]

; 265  :           if (pfPhase[i] > TWOPI)

  000ad	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000b0	8b 45 10	 mov	 eax, DWORD PTR _pfPhase$[ebp]
  000b3	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  000b6	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@40c90fdb
  000bc	df e0		 fnstsw	 ax
  000be	f6 c4 41	 test	 ah, 65			; 00000041H
  000c1	75 18		 jne	 SHORT $L1098

; 266  :             pfPhase[i] -= TWOPI;

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000c6	8b 55 10	 mov	 edx, DWORD PTR _pfPhase$[ebp]
  000c9	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  000cc	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@40c90fdb
  000d2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d5	8b 4d 10	 mov	 ecx, DWORD PTR _pfPhase$[ebp]
  000d8	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
$L1098:

; 267  :         }
; 268  :       else

  000db	eb 4b		 jmp	 SHORT $L1099
$L1096:

; 269  :         /*--------------------------------------------------
; 270  :           Decode phase pair using VQ.
; 271  :           --------------------------------------------------*/
; 272  :         {
; 273  :           /*--------------------------------------------
; 274  :             Set pointer to decoded sub vector
; 275  :             --------------------------------------------*/
; 276  :           iIndex -= (PHASE0_LEVELS>>1);

  000dd	8b 55 f8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  000e0	83 ea 10	 sub	 edx, 16			; 00000010H
  000e3	89 55 f8	 mov	 DWORD PTR _iIndex$[ebp], edx

; 277  : 
; 278  :           Dim2VectorLUT(iIndex, fPhaseCodeBookTable, PHASE_VQ_SIZE, pfVector);

  000e6	8d 45 f0	 lea	 eax, DWORD PTR _pfVector$[ebp]
  000e9	50		 push	 eax
  000ea	6a 30		 push	 48			; 00000030H
  000ec	68 00 00 00 00	 push	 OFFSET FLAT:_fPhaseCodeBookTable
  000f1	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  000f4	51		 push	 ecx
  000f5	e8 00 00 00 00	 call	 _Dim2VectorLUT@16

; 279  :           if (iSignBit == 1)

  000fa	83 7d ec 01	 cmp	 DWORD PTR _iSignBit$[ebp], 1
  000fe	75 10		 jne	 SHORT $L1100

; 280  :             pfPhase_Err[i] = -pfVector[0];

  00100	d9 45 f0	 fld	 DWORD PTR _pfVector$[ebp]
  00103	d9 e0		 fchs
  00105	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00108	8b 45 0c	 mov	 eax, DWORD PTR _pfPhase_Err$[ebp]
  0010b	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]

; 281  :           else

  0010e	eb 0c		 jmp	 SHORT $L1101
$L1100:

; 282  :             pfPhase_Err[i] = pfVector[0];

  00110	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00113	8b 55 0c	 mov	 edx, DWORD PTR _pfPhase_Err$[ebp]
  00116	8b 45 f0	 mov	 eax, DWORD PTR _pfVector$[ebp]
  00119	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$L1101:

; 283  : 
; 284  :           pfPhase[i] = pfVector[1];

  0011c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0011f	8b 55 10	 mov	 edx, DWORD PTR _pfPhase$[ebp]
  00122	8b 45 f4	 mov	 eax, DWORD PTR _pfVector$[ebp+4]
  00125	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$L1099:

; 285  :         }
; 286  :     }

  00128	e9 0b ff ff ff	 jmp	 $L1094
$L1083:

; 287  : }

  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 0c 00	 ret	 12			; 0000000cH
_VoxSVQDecPhase@12 ENDP
_TEXT	ENDS
PUBLIC	_VoxEncPhasePrediction@16
PUBLIC	??_C@_0BA@HLINMDHH@pfPhase?5?$CB?$DN?5NULL?$AA@	; `string'
PUBLIC	??_C@_0BD@NAOMJKJJ@pfPhaseMid?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	__real@44000000
PUBLIC	__real@3efb53d2
PUBLIC	__real@3e22f983
;	COMDAT ??_C@_0BA@HLINMDHH@pfPhase?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BA@HLINMDHH@pfPhase?5?$CB?$DN?5NULL?$AA@ DB 'pfPhase != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NAOMJKJJ@pfPhaseMid?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BD@NAOMJKJJ@pfPhaseMid?5?$CB?$DN?5NULL?$AA@ DB 'pfPhaseMid != NULL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __real@44000000
CONST	SEGMENT
__real@44000000 DD 044000000r			; 512
CONST	ENDS
;	COMDAT __real@3efb53d2
CONST	SEGMENT
__real@3efb53d2 DD 03efb53d2r			; 0.490874
CONST	ENDS
;	COMDAT __real@3e22f983
CONST	SEGMENT
__real@3e22f983 DD 03e22f983r			; 0.159155
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxEncPhasePrediction@16
_TEXT	SEGMENT
_fDeltaPhase$ = -28
_fPitchDFT$ = -24
_iMhat$ = -16
_fPhaseShift$ = -12
_i$ = -8
_fTemp$ = -4
_fPitch_Mid$ = 8
_fPitch$ = 12
_pfPhaseMid$ = 16
_pfPhase$ = 20
_VoxEncPhasePrediction@16 PROC NEAR			; COMDAT

; 322  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 323  :    int  i, iMhat;
; 324  :    float fPitchDFT[2];
; 325  :    float fDeltaPhase, fPhaseShift;
; 326  :    float fTemp;
; 327  : 
; 328  :    assert(pfPhase != NULL);

  00006	83 7d 14 00	 cmp	 DWORD PTR _pfPhase$[ebp], 0
  0000a	75 17		 jne	 SHORT $L1195
  0000c	68 48 01 00 00	 push	 328			; 00000148H
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@EOCEMGIB@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@HLINMDHH@pfPhase?5?$CB?$DN?5NULL?$AA@
  0001b	e8 00 00 00 00	 call	 __assert
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1195:

; 329  :    assert(pfPhaseMid != NULL);

  00023	83 7d 10 00	 cmp	 DWORD PTR _pfPhaseMid$[ebp], 0
  00027	75 17		 jne	 SHORT $L1196
  00029	68 49 01 00 00	 push	 329			; 00000149H
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@EOCEMGIB@c?3?2xbox?2private?2windows?2directx?2@
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@NAOMJKJJ@pfPhaseMid?5?$CB?$DN?5NULL?$AA@
  00038	e8 00 00 00 00	 call	 __assert
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1196:

; 330  : 
; 331  :    /*--------------------------------------------------
; 332  :      Compute pitch in DFT domain 
; 333  :      --------------------------------------------------*/
; 334  :    fPitchDFT[0] = (float)NFFT/fPitch_Mid;

  00040	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@44000000
  00046	d8 75 08	 fdiv	 DWORD PTR _fPitch_Mid$[ebp]
  00049	d9 5d e8	 fstp	 DWORD PTR _fPitchDFT$[ebp]

; 335  :    fPitchDFT[1] = (float)NFFT/fPitch;

  0004c	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@44000000
  00052	d8 75 0c	 fdiv	 DWORD PTR _fPitch$[ebp]
  00055	d9 5d ec	 fstp	 DWORD PTR _fPitchDFT$[ebp+4]

; 336  : 
; 337  :    /*--------------------------------------------------
; 338  :      Compute delta-phase and initialize phase-shift
; 339  :      --------------------------------------------------*/
; 340  :    fDeltaPhase = (fPitchDFT[0]+fPitchDFT[1])*
; 341  :                  (0.5F*(float)HALF_FRAME_LENGTH_SC*TWOPIONFFT);

  00058	d9 45 e8	 fld	 DWORD PTR _fPitchDFT$[ebp]
  0005b	d8 45 ec	 fadd	 DWORD PTR _fPitchDFT$[ebp+4]
  0005e	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3efb53d2
  00064	d9 5d e4	 fstp	 DWORD PTR _fDeltaPhase$[ebp]

; 342  :    fPhaseShift = fDeltaPhase;

  00067	8b 55 e4	 mov	 edx, DWORD PTR _fDeltaPhase$[ebp]
  0006a	89 55 f4	 mov	 DWORD PTR _fPhaseShift$[ebp], edx

; 343  : 
; 344  :    for (i = 0; i < SC6_PHASES; i++) {

  0006d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00074	eb 09		 jmp	 SHORT $L1127
$L1128:
  00076	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00079	83 c0 01	 add	 eax, 1
  0007c	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L1127:
  0007f	83 7d f8 08	 cmp	 DWORD PTR _i$[ebp], 8
  00083	7d 5c		 jge	 SHORT $L1110

; 345  :      /*--------------------------------------------------
; 346  :        Compute the predictive error for the middle frame 
; 347  :        phase.
; 348  :        --------------------------------------------------*/
; 349  :       pfPhaseMid[i] = pfPhase[i] - fPhaseShift - pfPhaseMid[i];

  00085	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00088	8b 55 14	 mov	 edx, DWORD PTR _pfPhase$[ebp]
  0008b	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  0008e	d8 65 f4	 fsub	 DWORD PTR _fPhaseShift$[ebp]
  00091	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00094	8b 4d 10	 mov	 ecx, DWORD PTR _pfPhaseMid$[ebp]
  00097	d8 24 81	 fsub	 DWORD PTR [ecx+eax*4]
  0009a	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0009d	8b 45 10	 mov	 eax, DWORD PTR _pfPhaseMid$[ebp]
  000a0	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]

; 350  : 
; 351  :       /*--------------------------------------------------
; 352  :         Normalize the phase error so that it's between -Pi
; 353  :         to Pi
; 354  :         --------------------------------------------------*/
; 355  :       fTemp = pfPhaseMid[i]*INVTWOPI;

  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000a6	8b 55 10	 mov	 edx, DWORD PTR _pfPhaseMid$[ebp]
  000a9	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  000ac	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e22f983
  000b2	d9 5d fc	 fstp	 DWORD PTR _fTemp$[ebp]

; 356  :       VoxROUND2( fTemp, iMhat );

  000b5	d9 45 fc	 fld	 DWORD PTR _fTemp$[ebp]
  000b8	db 5d f0	 fistp	 DWORD PTR _iMhat$[ebp]

; 357  :       pfPhaseMid[i] -= iMhat*TWOPI;

  000bb	db 45 f0	 fild	 DWORD PTR _iMhat$[ebp]
  000be	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40c90fdb
  000c4	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000c7	8b 4d 10	 mov	 ecx, DWORD PTR _pfPhaseMid$[ebp]
  000ca	d8 2c 81	 fsubr	 DWORD PTR [ecx+eax*4]
  000cd	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000d0	8b 45 10	 mov	 eax, DWORD PTR _pfPhaseMid$[ebp]
  000d3	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]

; 358  : 
; 359  :       /*--------------------------------------------------
; 360  :         Update the phase shift 
; 361  :         --------------------------------------------------*/
; 362  :       fPhaseShift += fDeltaPhase;

  000d6	d9 45 f4	 fld	 DWORD PTR _fPhaseShift$[ebp]
  000d9	d8 45 e4	 fadd	 DWORD PTR _fDeltaPhase$[ebp]
  000dc	d9 5d f4	 fstp	 DWORD PTR _fPhaseShift$[ebp]

; 363  :    }

  000df	eb 95		 jmp	 SHORT $L1128
$L1110:

; 364  : 
; 365  : }

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c2 10 00	 ret	 16			; 00000010H
_VoxEncPhasePrediction@16 ENDP
_TEXT	ENDS
PUBLIC	_VoxDecPhasePrediction@16
; Function compile flags: /Odt
;	COMDAT _VoxDecPhasePrediction@16
_TEXT	SEGMENT
_i$ = -4
_fPitchMid$ = 8
_fPitch$ = 12
_pfPhaseMid$ = 16
_pfPhase$ = 20
_VoxDecPhasePrediction@16 PROC NEAR			; COMDAT

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 401  :    int i;
; 402  : 
; 403  :    VoxEncPhasePrediction(fPitchMid, fPitch, pfPhaseMid, pfPhase);

  00004	8b 45 14	 mov	 eax, DWORD PTR _pfPhase$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 10	 mov	 ecx, DWORD PTR _pfPhaseMid$[ebp]
  0000b	51		 push	 ecx
  0000c	8b 55 0c	 mov	 edx, DWORD PTR _fPitch$[ebp]
  0000f	52		 push	 edx
  00010	8b 45 08	 mov	 eax, DWORD PTR _fPitchMid$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _VoxEncPhasePrediction@16

; 404  : 
; 405  :    /*--------------------------------------------------
; 406  :      Normalize the mid-frame phase between 0 to 2*Pi
; 407  :     --------------------------------------------------*/
; 408  :    for (i = 0; i < SC6_PHASES; i++)

  00019	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00020	eb 09		 jmp	 SHORT $L1140
$L1141:
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00025	83 c1 01	 add	 ecx, 1
  00028	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L1140:
  0002b	83 7d fc 08	 cmp	 DWORD PTR _i$[ebp], 8
  0002f	7d 32		 jge	 SHORT $L1138
$L1144:

; 409  :      {
; 410  :         while(pfPhaseMid[i] < 0.0F)

  00031	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00034	8b 45 10	 mov	 eax, DWORD PTR _pfPhaseMid$[ebp]
  00037	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  0003a	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00040	df e0		 fnstsw	 ax
  00042	f6 c4 05	 test	 ah, 5
  00045	7a 1a		 jp	 SHORT $L1145

; 411  :            pfPhaseMid[i] += TWOPI;

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0004a	8b 55 10	 mov	 edx, DWORD PTR _pfPhaseMid$[ebp]
  0004d	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  00050	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@40c90fdb
  00056	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00059	8b 4d 10	 mov	 ecx, DWORD PTR _pfPhaseMid$[ebp]
  0005c	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
  0005f	eb d0		 jmp	 SHORT $L1144
$L1145:

; 412  :      }

  00061	eb bf		 jmp	 SHORT $L1141
$L1138:

; 413  : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 10 00	 ret	 16			; 00000010H
_VoxDecPhasePrediction@16 ENDP
_TEXT	ENDS
END
