; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\wmadecs_api.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
WMADEC_RW	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RW	ENDS
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT @ByteSwap@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMARawDecInit@44
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMARawDecClose@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMARawDecReset@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMARawDecStatus@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMARawDecDecodeData@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMARawDecGetPCM@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, WMADEC_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_DSoundBuildNumberD
WMADEC_RD	SEGMENT
_WMA_OK	DD	00H
_WMA_S_FALSE DD	01H
_WMA_S_BUFUNDERFLOW DD 02H
_WMA_S_NEWPACKET DD 03H
_WMA_S_NO_MORE_FRAME DD 04H
_WMA_S_DEFAULT DD 05H
_WMA_S_SWITCHCHMODE DD 06H
_WMA_E_FAIL DD	080004005H
_WMA_E_OUTOFMEMORY DD 08007000eH
_WMA_E_INVALIDARG DD 080070057H
_WMA_E_NOTSUPPORTED DD 080040000H
_WMA_E_LOSTPACKET DD 080040001H
_WMA_E_BROKEN_FRAME DD 080040002H
_WMA_E_BUFFEROVERFLOW DD 080040003H
_WMA_E_ONHOLD DD 080040004H
_WMA_E_BUFFERUNDERFLOW DD 080040005H
_WMA_E_INVALIDRECHDR DD 080040006H
_WMA_E_SYNCERROR DD 080040007H
_WMA_E_NOTIMPL DD 080040008H
_WMA_E_FLUSHOVERFLOW DD 080040009H
WMADEC_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT
_DSoundBuildNumberD DW 05344H
	DW	0554fH
	DW	0444eH
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_WMARawDecInit@44
EXTRN	_audecNew_XDS@8:NEAR
EXTRN	_audecInit_XDS@48:NEAR
EXTRN	_malloc:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wmadecs_api.c
;	COMDAT _WMARawDecInit@44
WMADEC	SEGMENT
_pWMARawDec$ = -8
_hr$ = -4
_phWMARawDec$ = 8
_dwUserData$ = 12
_pfnGetMoreData$ = 16
_iVersionNumber$ = 20
_cSamplesPerBlock$ = 24
_cSamplesPerSecond$ = 28
_cChannel$ = 32
_cBytePerSec$ = 36
_cPacketLength$ = 40
_cEncodeOpt$ = 44
_cPlayerOpt$ = 48
_WMARawDecInit@44 PROC NEAR				; COMDAT

; 32   : ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 33   :     WMARESULT hr;
; 34   :     WMARawDecStruct* pWMARawDec;
; 35   : 
; 36   : //    phWMARawDec = NULL; // initialize as NULL for later checking
; 37   :     pWMARawDec = (WMARawDecStruct*) malloc (sizeof (WMARawDecStruct));

  00006	6a 04		 push	 4
  00008	e8 00 00 00 00	 call	 _malloc
  0000d	83 c4 04	 add	 esp, 4
  00010	89 45 f8	 mov	 DWORD PTR _pWMARawDec$[ebp], eax

; 38   :     if (pWMARawDec == NULL)

  00013	83 7d f8 00	 cmp	 DWORD PTR _pWMARawDec$[ebp], 0
  00017	75 0a		 jne	 SHORT $L2946

; 39   :         return WMA_E_OUTOFMEMORY;

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  0001e	e9 87 00 00 00	 jmp	 $L2940
$L2946:

; 40   : 
; 41   : 
; 42   :     pWMARawDec->pAudDecoder = audecNew (NULL, 0);

  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	e8 00 00 00 00	 call	 _audecNew_XDS@8
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _pWMARawDec$[ebp]
  0002f	89 01		 mov	 DWORD PTR [ecx], eax

; 43   : //    pWMARawDec->pAudDecoder = audecNew (rgWMAMem, WMAMEM_SIZE);
; 44   :     if (pWMARawDec->pAudDecoder == NULL)

  00031	8b 55 f8	 mov	 edx, DWORD PTR _pWMARawDec$[ebp]
  00034	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00037	75 07		 jne	 SHORT $L2949

; 45   :         return WMA_E_OUTOFMEMORY;

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  0003e	eb 6a		 jmp	 SHORT $L2940
$L2949:

; 46   : 
; 47   :     hr = audecInit (
; 48   :         pWMARawDec->pAudDecoder,
; 49   :         (Int) iVersionNumber,
; 50   :         cSamplesPerBlock,
; 51   :         cSamplesPerSecond,
; 52   :         cChannel,
; 53   :         cBytePerSec,
; 54   :         cPacketLength,
; 55   :         cEncodeOpt,
; 56   :         cPlayerOpt,
; 57   :         (PFNGETMOREDATA)pfnGetMoreData, 
; 58   :         dwUserData,
; 59   :         NULL
; 60   :     );

  00040	6a 00		 push	 0
  00042	8b 45 0c	 mov	 eax, DWORD PTR _dwUserData$[ebp]
  00045	50		 push	 eax
  00046	8b 4d 10	 mov	 ecx, DWORD PTR _pfnGetMoreData$[ebp]
  00049	51		 push	 ecx
  0004a	66 8b 55 30	 mov	 dx, WORD PTR _cPlayerOpt$[ebp]
  0004e	52		 push	 edx
  0004f	66 8b 45 2c	 mov	 ax, WORD PTR _cEncodeOpt$[ebp]
  00053	50		 push	 eax
  00054	0f b7 4d 28	 movzx	 ecx, WORD PTR _cPacketLength$[ebp]
  00058	51		 push	 ecx
  00059	0f b7 55 24	 movzx	 edx, WORD PTR _cBytePerSec$[ebp]
  0005d	52		 push	 edx
  0005e	66 8b 45 20	 mov	 ax, WORD PTR _cChannel$[ebp]
  00062	50		 push	 eax
  00063	0f b7 4d 1c	 movzx	 ecx, WORD PTR _cSamplesPerSecond$[ebp]
  00067	51		 push	 ecx
  00068	0f b7 55 18	 movzx	 edx, WORD PTR _cSamplesPerBlock$[ebp]
  0006c	52		 push	 edx
  0006d	0f b7 45 14	 movzx	 eax, WORD PTR _iVersionNumber$[ebp]
  00071	50		 push	 eax
  00072	8b 4d f8	 mov	 ecx, DWORD PTR _pWMARawDec$[ebp]
  00075	8b 11		 mov	 edx, DWORD PTR [ecx]
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 _audecInit_XDS@48
  0007d	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 61   : // for unsupported formats
; 62   : 
; 63   : 	if (hr == 0x80040000)

  00080	81 7d fc 00 00
	04 80		 cmp	 DWORD PTR _hr$[ebp], -2147221504 ; 80040000H
  00087	75 07		 jne	 SHORT $L2953

; 64   : 		return WMA_E_NOTSUPPORTED;

  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_NOTSUPPORTED
  0008e	eb 1a		 jmp	 SHORT $L2940
$L2953:

; 65   :     
; 66   : 	if (WMA_FAILED (hr))

  00090	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00094	7d 07		 jge	 SHORT $L2955

; 67   :         return WMA_E_FAIL;

  00096	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_FAIL
  0009b	eb 0d		 jmp	 SHORT $L2940
$L2955:

; 68   : 
; 69   :     *phWMARawDec = (WMARawDecHandle) pWMARawDec;

  0009d	8b 45 08	 mov	 eax, DWORD PTR _phWMARawDec$[ebp]
  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _pWMARawDec$[ebp]
  000a3	89 08		 mov	 DWORD PTR [eax], ecx

; 70   :     return WMA_OK;

  000a5	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
$L2940:

; 71   : }

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 2c 00	 ret	 44			; 0000002cH
_WMARawDecInit@44 ENDP
WMADEC	ENDS
PUBLIC	_WMARawDecClose@4
EXTRN	_audecDelete_XDS@4:NEAR
EXTRN	_free:NEAR
; Function compile flags: /Odt
;	COMDAT _WMARawDecClose@4
WMADEC	SEGMENT
_pWMARawDec$ = -4
_phWMARawDec$ = 8
_WMARawDecClose@4 PROC NEAR				; COMDAT

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 75   :     WMARawDecStruct* pWMARawDec;
; 76   : 
; 77   :     pWMARawDec = (WMARawDecStruct*) (*phWMARawDec);

  00004	8b 45 08	 mov	 eax, DWORD PTR _phWMARawDec$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _pWMARawDec$[ebp], ecx

; 78   :     if (pWMARawDec != NULL) {

  0000c	83 7d fc 00	 cmp	 DWORD PTR _pWMARawDec$[ebp], 0
  00010	74 31		 je	 SHORT $L2963

; 79   :         if (pWMARawDec->pAudDecoder != NULL) {

  00012	8b 55 fc	 mov	 edx, DWORD PTR _pWMARawDec$[ebp]
  00015	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00018	74 14		 je	 SHORT $L2965

; 80   :             audecDelete (pWMARawDec->pAudDecoder);

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _pWMARawDec$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _audecDelete_XDS@4

; 81   :             pWMARawDec->pAudDecoder = NULL;

  00025	8b 55 fc	 mov	 edx, DWORD PTR _pWMARawDec$[ebp]
  00028	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L2965:

; 82   :         }
; 83   :         free (pWMARawDec);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _pWMARawDec$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _free
  00037	83 c4 04	 add	 esp, 4

; 84   :         *phWMARawDec = NULL;

  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _phWMARawDec$[ebp]
  0003d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L2963:

; 85   :     }
; 86   :     phWMARawDec = NULL;

  00043	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _phWMARawDec$[ebp], 0

; 87   :     return WMA_OK;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK

; 88   : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
_WMARawDecClose@4 ENDP
WMADEC	ENDS
PUBLIC	_WMARawDecReset@4
EXTRN	_audecReset_XDS@4:NEAR
; Function compile flags: /Odt
;	COMDAT _WMARawDecReset@4
WMADEC	SEGMENT
_pWMARawDec$ = -4
_hWMARawDec$ = 8
_WMARawDecReset@4 PROC NEAR				; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 92   :     WMARawDecStruct* pWMARawDec;
; 93   :     pWMARawDec = (WMARawDecStruct*) hWMARawDec;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hWMARawDec$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pWMARawDec$[ebp], eax

; 94   : 
; 95   :     if (pWMARawDec == NULL || pWMARawDec->pAudDecoder == NULL)

  0000a	83 7d fc 00	 cmp	 DWORD PTR _pWMARawDec$[ebp], 0
  0000e	74 08		 je	 SHORT $L2977
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _pWMARawDec$[ebp]
  00013	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00016	75 07		 jne	 SHORT $L2976
$L2977:

; 96   :         return WMA_E_INVALIDARG;

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  0001d	eb 0b		 jmp	 SHORT $L2971
$L2976:

; 97   :     else
; 98   :         return (audecReset (pWMARawDec->pAudDecoder));

  0001f	8b 55 fc	 mov	 edx, DWORD PTR _pWMARawDec$[ebp]
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _audecReset_XDS@4
$L2971:

; 99   : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
_WMARawDecReset@4 ENDP
WMADEC	ENDS
PUBLIC	_WMARawDecStatus@4
EXTRN	_audecDecodeInfo_XDS@4:NEAR
; Function compile flags: /Odt
;	COMDAT _WMARawDecStatus@4
WMADEC	SEGMENT
_pWMARawDec$ = -4
_hWMARawDec$ = 8
_WMARawDecStatus@4 PROC NEAR				; COMDAT

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 103  :     WMARawDecStruct* pWMARawDec;
; 104  :     pWMARawDec = (WMARawDecStruct*) hWMARawDec;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hWMARawDec$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pWMARawDec$[ebp], eax

; 105  : 
; 106  :     if (pWMARawDec == NULL || pWMARawDec->pAudDecoder == NULL)

  0000a	83 7d fc 00	 cmp	 DWORD PTR _pWMARawDec$[ebp], 0
  0000e	74 08		 je	 SHORT $L2987
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _pWMARawDec$[ebp]
  00013	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00016	75 07		 jne	 SHORT $L2986
$L2987:

; 107  :         return WMA_E_INVALIDARG;

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  0001d	eb 0b		 jmp	 SHORT $L2981
$L2986:

; 108  :     else
; 109  :         return (audecDecodeInfo (pWMARawDec->pAudDecoder));

  0001f	8b 55 fc	 mov	 edx, DWORD PTR _pWMARawDec$[ebp]
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _audecDecodeInfo_XDS@4
$L2981:

; 110  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
_WMARawDecStatus@4 ENDP
WMADEC	ENDS
PUBLIC	_WMARawDecDecodeData@4
EXTRN	_audecDecodeData_XDS@8:NEAR
; Function compile flags: /Odt
;	COMDAT _WMARawDecDecodeData@4
WMADEC	SEGMENT
_pWMARawDec$ = -8
_cSamplesReady$ = -4
_hWMARawDec$ = 8
_WMARawDecDecodeData@4 PROC NEAR			; COMDAT

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 114  :     WMARawDecStruct* pWMARawDec;
; 115  :     U16_WMARawDec cSamplesReady;
; 116  :     pWMARawDec = (WMARawDecStruct*) hWMARawDec;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hWMARawDec$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _pWMARawDec$[ebp], eax

; 117  : 
; 118  :     if (pWMARawDec == NULL || pWMARawDec->pAudDecoder == NULL)

  0000c	83 7d f8 00	 cmp	 DWORD PTR _pWMARawDec$[ebp], 0
  00010	74 08		 je	 SHORT $L2998
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _pWMARawDec$[ebp]
  00015	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00018	75 07		 jne	 SHORT $L2997
$L2998:

; 119  :         return WMA_E_INVALIDARG;

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  0001f	eb 0f		 jmp	 SHORT $L2991
$L2997:

; 120  :     else
; 121  :         return (audecDecodeData (pWMARawDec->pAudDecoder, &cSamplesReady));

  00021	8d 55 fc	 lea	 edx, DWORD PTR _cSamplesReady$[ebp]
  00024	52		 push	 edx
  00025	8b 45 f8	 mov	 eax, DWORD PTR _pWMARawDec$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 _audecDecodeData_XDS@8
$L2991:

; 122  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
_WMARawDecDecodeData@4 ENDP
WMADEC	ENDS
PUBLIC	_WMARawDecGetPCM@16
EXTRN	_audecGetPCM_XDS@16:NEAR
; Function compile flags: /Odt
;	COMDAT _WMARawDecGetPCM@16
WMADEC	SEGMENT
_pWMARawDec$ = -4
_hWMARawDec$ = 8
_pcSampleReady$ = 12
_pbDst$ = 16
_cbDstBufferLength$ = 20
_WMARawDecGetPCM@16 PROC NEAR				; COMDAT

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 126  :     WMARawDecStruct* pWMARawDec;
; 127  :     pWMARawDec = (WMARawDecStruct*) hWMARawDec;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hWMARawDec$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pWMARawDec$[ebp], eax

; 128  :     if (pWMARawDec == NULL || pWMARawDec->pAudDecoder == NULL)

  0000a	83 7d fc 00	 cmp	 DWORD PTR _pWMARawDec$[ebp], 0
  0000e	74 08		 je	 SHORT $L3014
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _pWMARawDec$[ebp]
  00013	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00016	75 07		 jne	 SHORT $L3013
$L3014:

; 129  :         return WMA_E_INVALIDARG;

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_INVALIDARG
  0001d	eb 17		 jmp	 SHORT $L3008
$L3013:

; 130  :     else 
; 131  :         return (audecGetPCM (pWMARawDec->pAudDecoder, pcSampleReady, pbDst, cbDstBufferLength));

  0001f	8b 55 14	 mov	 edx, DWORD PTR _cbDstBufferLength$[ebp]
  00022	52		 push	 edx
  00023	8b 45 10	 mov	 eax, DWORD PTR _pbDst$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _pcSampleReady$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _pWMARawDec$[ebp]
  0002e	8b 02		 mov	 eax, DWORD PTR [edx]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _audecGetPCM_XDS@16
$L3008:

; 132  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 10 00	 ret	 16			; 00000010H
_WMARawDecGetPCM@16 ENDP
WMADEC	ENDS
END
