; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\overadd.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EA@LNDLEIGJ@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@ICIDHBMI@?$CIpfAmps?$CB?$DNNULL?$CJ?5?$CG?$CG?5?$CIpfPhase?$CB?$DNNULL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@BBHFLHAN@?$CIpfOutputBuffer?$CB?$DNNULL?$CJ?5?$CG?$CG?5?$CIpfWav@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@CILMOHFB@pfAmps?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09LBCPLEAK@iHarm?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _FHTOverlapAdd@28
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _FHTSumCos@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GetPhaseIndices@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ClipOverflows@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
CONST	SEGMENT
_fFHTWeights DD	03f00034ar			; 0.50005
	DD	03f000d2ar			; 0.500201
	DD	03f001da0r			; 0.500452
	DD	03f0034afr			; 0.500804
	DD	03f00525cr			; 0.501257
	DD	03f0076acr			; 0.501811
	DD	03f00a1a4r			; 0.502466
	DD	03f00d34cr			; 0.503224
	DD	03f010badr			; 0.504084
	DD	03f014ad0r			; 0.505048
	DD	03f0190bfr			; 0.506115
	DD	03f01dd88r			; 0.507287
	DD	03f023136r			; 0.508563
	DD	03f028bd9r			; 0.509946
	DD	03f02ed80r			; 0.511436
	DD	03f03563cr			; 0.513035
	DD	03f03c620r			; 0.514742
	DD	03f043d3dr			; 0.516559
	DD	03f04bbabr			; 0.518489
	DD	03f05417dr			; 0.520531
	DD	03f05cecdr			; 0.522687
	DD	03f0663b3r			; 0.524959
	DD	03f070049r			; 0.527348
	DD	03f07a4abr			; 0.529856
	DD	03f0850f6r			; 0.532485
	DD	03f09054ar			; 0.535237
	DD	03f09c1c6r			; 0.538113
	DD	03f0a868dr			; 0.541116
	DD	03f0b53c2r			; 0.544247
	DD	03f0c298cr			; 0.547509
	DD	03f0d0811r			; 0.550904
	DD	03f0def79r			; 0.554435
	DD	03f0edff1r			; 0.558105
	DD	03f0fd9a5r			; 0.561915
	DD	03f10dcc4r			; 0.565869
	DD	03f11e97er			; 0.569969
	DD	03f130007r			; 0.574219
	DD	03f142094r			; 0.578622
	DD	03f154b5dr			; 0.583181
	DD	03f16809ar			; 0.5879
	DD	03f17c089r			; 0.592782
	DD	03f190b67r			; 0.59783
	DD	03f1a6178r			; 0.60305
	DD	03f1bc2fdr			; 0.608444
	DD	03f1d303fr			; 0.614017
	DD	03f1ea987r			; 0.619774
	DD	03f202f22r			; 0.625719
	DD	03f21c15fr			; 0.631857
	DD	03f236092r			; 0.638192
	DD	03f250d11r			; 0.644731
	DD	03f26c736r			; 0.651477
	DD	03f288f5er			; 0.658438
	DD	03f2a65ebr			; 0.665618
	DD	03f2c4b43r			; 0.673023
	DD	03f2e3fcer			; 0.680661
	DD	03f3043far			; 0.688537
	DD	03f325839r			; 0.696659
	DD	03f347d02r			; 0.705032
	DD	03f36b2d1r			; 0.713666
	DD	03f38fa25r			; 0.722567
	DD	03f3b5384r			; 0.731743
	DD	03f3dbf7br			; 0.741203
	DD	03f403e98r			; 0.750955
	DD	03f42d174r			; 0.761009
	DD	03f4578acr			; 0.771373
	DD	03f4834e2r			; 0.782057
	DD	03f4b06c1r			; 0.793072
	DD	03f4deefar			; 0.804428
	DD	03f50ee46r			; 0.816136
	DD	03f540565r			; 0.828207
	DD	03f573521r			; 0.840654
	DD	03f5a7e49r			; 0.853489
	DD	03f5de1b7r			; 0.866725
	DD	03f61604fr			; 0.880376
	DD	03f64fafdr			; 0.894455
	DD	03f68b2b8r			; 0.908977
	DD	03f6c8882r			; 0.923958
	DD	03f707d67r			; 0.939413
	DD	03f74927fr			; 0.95536
	DD	03f78c8efr			; 0.971816
	DD	03f7d21e9r			; 0.988799
	DD	03f80cf56r			; 1.00633
	DD	03f832042r			; 1.02442
	DD	03f858466r			; 1.0431
	DD	03f87fc79r			; 1.06239
	DD	03f8a8939r			; 1.08231
	DD	03f8d2b6br			; 1.10289
	DD	03f8fe3e0r			; 1.12414
	DD	03f92b371r			; 1.1461
	DD	03f959b01r			; 1.16879
	DD	03f989b7er			; 1.19225
	DD	03f9bb5e0r			; 1.21649
	DD	03f9eeb2dr			; 1.24155
	DD	03fa23c74r			; 1.26747
	DD	03fa5aad4r			; 1.29428
	DD	03fa93778r			; 1.32201
	DD	03face39ar			; 1.3507
	DD	03fb0b083r			; 1.38039
	DD	03fb49f8cr			; 1.41112
	DD	03fb8b21fr			; 1.44294
	DD	03fbce9b9r			; 1.47588
	DD	03fc147e7r			; 1.51001
	DD	03fc5ce4cr			; 1.54536
	DD	03fca7ea0r			; 1.58199
	DD	03fcf5ab2r			; 1.61996
	DD	03fd46466r			; 1.65931
	DD	03fd99dbbr			; 1.70013
	DD	03fdf08car			; 1.74246
	DD	03fe4a7c8r			; 1.78637
	DD	03fea7d07r			; 1.83194
	DD	03ff08af8r			; 1.87924
	DD	03ff6d430r			; 1.92835
	DD	03ffd5b64r			; 1.97935
	DD	0400211b8r			; 2.03233
	DD	0400597abr			; 2.08738
	DD	040094123r			; 2.1446
	DD	0400d0fccr			; 2.20409
	DD	04011056br			; 2.26596
	DD	0401523dfr			; 2.33031
	DD	040196d21r			; 2.39729
	DD	0401de347r			; 2.467
	DD	040228885r			; 2.53958
	DD	040275f2fr			; 2.61518
	DD	0402c69bdr			; 2.69395
	DD	04031aaccr			; 2.77605
	DD	04037251fr			; 2.86164
	DD	0403cdba4r			; 2.95091
	DD	04042d174r			; 3.04403
CONST	ENDS
PUBLIC	_FHTOverlapAdd@28
PUBLIC	??_C@_0EA@LNDLEIGJ@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CC@ICIDHBMI@?$CIpfAmps?$CB?$DNNULL?$CJ?5?$CG?$CG?5?$CIpfPhase?$CB?$DNNULL@ ; `string'
PUBLIC	??_C@_0CP@BBHFLHAN@?$CIpfOutputBuffer?$CB?$DNNULL?$CJ?5?$CG?$CG?5?$CIpfWav@ ; `string'
EXTRN	__assert:NEAR
EXTRN	_OlAdd@20:NEAR
EXTRN	__fltused:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_memset:NEAR
;	COMDAT ??_C@_0EA@LNDLEIGJ@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\overadd.c
CONST	SEGMENT
??_C@_0EA@LNDLEIGJ@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\overadd.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ICIDHBMI@?$CIpfAmps?$CB?$DNNULL?$CJ?5?$CG?$CG?5?$CIpfPhase?$CB?$DNNULL@
CONST	SEGMENT
??_C@_0CC@ICIDHBMI@?$CIpfAmps?$CB?$DNNULL?$CJ?5?$CG?$CG?5?$CIpfPhase?$CB?$DNNULL@ DB '('
	DB	'pfAmps!=NULL) && (pfPhase!=NULL)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BBHFLHAN@?$CIpfOutputBuffer?$CB?$DNNULL?$CJ?5?$CG?$CG?5?$CIpfWav@
CONST	SEGMENT
??_C@_0CP@BBHFLHAN@?$CIpfOutputBuffer?$CB?$DNNULL?$CJ?5?$CG?$CG?5?$CIpfWav@ DB '('
	DB	'pfOutputBuffer!=NULL) && (pfWaveform_1!=NULL)', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _FHTOverlapAdd@28
_TEXT	SEGMENT
_pfWaveform$ = -648
_iTotalSynLength$ = -4
_pfAmps$ = 8
_fPitchDFT$ = 12
_pfPhase$ = 16
_iHarm$ = 20
_iSynSubFrameLength$ = 24
_pfOutputBuffer$ = 28
_pfWaveform_1$ = 32
_FHTOverlapAdd@28 PROC NEAR				; COMDAT

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 02 00
	00		 sub	 esp, 648		; 00000288H

; 143  :    int   iTotalSynLength;        /* overlap/add window length                 */
; 144  :    STACK_INIT
; 145  :    float pfWaveform[FRAME_LENGTH_SC]; 
; 146  :    STACK_INIT_END
; 147  : 
; 148  :    STACK_ATTACH(float*,pfWaveform)
; 149  : 
; 150  :    STACK_START
; 151  : 
; 152  :    assert((pfAmps!=NULL) && (pfPhase!=NULL));

  00009	83 7d 08 00	 cmp	 DWORD PTR _pfAmps$[ebp], 0
  0000d	74 06		 je	 SHORT $L1617
  0000f	83 7d 10 00	 cmp	 DWORD PTR _pfPhase$[ebp], 0
  00013	75 17		 jne	 SHORT $L1618
$L1617:
  00015	68 98 00 00 00	 push	 152			; 00000098H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@LNDLEIGJ@c?3?2xbox?2private?2windows?2directx?2@
  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@ICIDHBMI@?$CIpfAmps?$CB?$DNNULL?$CJ?5?$CG?$CG?5?$CIpfPhase?$CB?$DNNULL@
  00024	e8 00 00 00 00	 call	 __assert
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1618:

; 153  :    assert((pfOutputBuffer!=NULL) && (pfWaveform_1!=NULL));

  0002c	83 7d 1c 00	 cmp	 DWORD PTR _pfOutputBuffer$[ebp], 0
  00030	74 06		 je	 SHORT $L1619
  00032	83 7d 20 00	 cmp	 DWORD PTR _pfWaveform_1$[ebp], 0
  00036	75 17		 jne	 SHORT $L1620
$L1619:
  00038	68 99 00 00 00	 push	 153			; 00000099H
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@LNDLEIGJ@c?3?2xbox?2private?2windows?2directx?2@
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@BBHFLHAN@?$CIpfOutputBuffer?$CB?$DNNULL?$CJ?5?$CG?$CG?5?$CIpfWav@
  00047	e8 00 00 00 00	 call	 __assert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1620:

; 154  : 
; 155  :    iTotalSynLength = iSynSubFrameLength<<1;

  0004f	8b 55 18	 mov	 edx, DWORD PTR _iSynSubFrameLength$[ebp]
  00052	d1 e2		 shl	 edx, 1
  00054	89 55 fc	 mov	 DWORD PTR _iTotalSynLength$[ebp], edx

; 156  : 
; 157  :    /*--------------------------------------------------
; 158  :      Clear waveform array
; 159  :    --------------------------------------------------*/
; 160  :    memset(pfWaveform, 0, iTotalSynLength*sizeof(float) );

  00057	8b 45 fc	 mov	 eax, DWORD PTR _iTotalSynLength$[ebp]
  0005a	c1 e0 02	 shl	 eax, 2
  0005d	50		 push	 eax
  0005e	6a 00		 push	 0
  00060	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR _pfWaveform$[ebp]
  00066	51		 push	 ecx
  00067	e8 00 00 00 00	 call	 _memset
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 
; 162  :    /*---------------------------------------------------
; 163  :      clip overflows by rescaling the harmonic amplitudes
; 164  :    ---------------------------------------------------*/
; 165  :    ClipOverflows(pfAmps, iHarm);

  0006f	8b 55 14	 mov	 edx, DWORD PTR _iHarm$[ebp]
  00072	52		 push	 edx
  00073	8b 45 08	 mov	 eax, DWORD PTR _pfAmps$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _ClipOverflows@8

; 166  : 
; 167  : 
; 168  : #if (SYNTHESIS_TYPE==FHT_SYNTHESIS)
; 169  :    /*---------------------------------------------------
; 170  :      Sum of cosines using Fast Harmonic Transform
; 171  :    ---------------------------------------------------*/
; 172  :    FHTSumCos(STACK_S fPitchDFT, pfAmps, pfPhase, iHarm, iTotalSynLength, 
; 173  :                      pfWaveform);

  0007c	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR _pfWaveform$[ebp]
  00082	51		 push	 ecx
  00083	8b 55 fc	 mov	 edx, DWORD PTR _iTotalSynLength$[ebp]
  00086	52		 push	 edx
  00087	8b 45 14	 mov	 eax, DWORD PTR _iHarm$[ebp]
  0008a	50		 push	 eax
  0008b	8b 4d 10	 mov	 ecx, DWORD PTR _pfPhase$[ebp]
  0008e	51		 push	 ecx
  0008f	8b 55 08	 mov	 edx, DWORD PTR _pfAmps$[ebp]
  00092	52		 push	 edx
  00093	8b 45 0c	 mov	 eax, DWORD PTR _fPitchDFT$[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _FHTSumCos@24

; 174  : 
; 175  : #endif
; 176  : 
; 177  : #if (SYNTHESIS_TYPE==FFT_SYNTHESIS)
; 178  :    /*---------------------------------------------------
; 179  :      Sum of cosines using FFT
; 180  :    ---------------------------------------------------*/
; 181  :    FftSumCos(STACK_S fPitchDFT, pfAmps, pfPhase, iHarm, iTotalSynLength, 
; 182  :                      pfWaveform);
; 183  : 
; 184  : #endif
; 185  : 
; 186  : #if (SYNTHESIS_TYPE==COS_SYNTHESIS)
; 187  :    /*---------------------------------------------------
; 188  :      Sum of cosines
; 189  :    ---------------------------------------------------*/
; 190  :    SumCos(fPitchDFT, pfAmps, pfPhase, iHarm, iTotalSynLength, pfWaveform);
; 191  : 
; 192  : #endif
; 193  : 
; 194  :    /*---------------------------------------------------
; 195  :      clear temporary output buffer
; 196  :    ---------------------------------------------------*/
; 197  :    memset( pfOutputBuffer, 0, iSynSubFrameLength*sizeof(float) );

  0009c	8b 4d 18	 mov	 ecx, DWORD PTR _iSynSubFrameLength$[ebp]
  0009f	c1 e1 02	 shl	 ecx, 2
  000a2	51		 push	 ecx
  000a3	6a 00		 push	 0
  000a5	8b 55 1c	 mov	 edx, DWORD PTR _pfOutputBuffer$[ebp]
  000a8	52		 push	 edx
  000a9	e8 00 00 00 00	 call	 _memset
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 198  :  
; 199  :    /*---------------------------------------------------
; 200  :      overlap and add waveforms
; 201  :    ---------------------------------------------------*/
; 202  :    OlAdd ( pfWaveform_1, pfWaveform, (short)iSynSubFrameLength,
; 203  :            (short) iSynSubFrameLength, pfOutputBuffer);

  000b1	8b 45 1c	 mov	 eax, DWORD PTR _pfOutputBuffer$[ebp]
  000b4	50		 push	 eax
  000b5	0f bf 4d 18	 movsx	 ecx, WORD PTR _iSynSubFrameLength$[ebp]
  000b9	51		 push	 ecx
  000ba	0f bf 55 18	 movsx	 edx, WORD PTR _iSynSubFrameLength$[ebp]
  000be	52		 push	 edx
  000bf	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _pfWaveform$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d 20	 mov	 ecx, DWORD PTR _pfWaveform_1$[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _OlAdd@20

; 204  :  
; 205  :    /*---------------------------------------------------
; 206  :      Save half of the waveform for next time
; 207  :    ---------------------------------------------------*/
; 208  :    memcpy( pfWaveform_1, pfWaveform+iSynSubFrameLength,
; 209  :            iSynSubFrameLength*sizeof(float) );

  000cf	8b 55 18	 mov	 edx, DWORD PTR _iSynSubFrameLength$[ebp]
  000d2	c1 e2 02	 shl	 edx, 2
  000d5	52		 push	 edx
  000d6	8b 45 18	 mov	 eax, DWORD PTR _iSynSubFrameLength$[ebp]
  000d9	8d 8c 85 78 fd
	ff ff		 lea	 ecx, DWORD PTR _pfWaveform$[ebp+eax*4]
  000e0	51		 push	 ecx
  000e1	8b 55 20	 mov	 edx, DWORD PTR _pfWaveform_1$[ebp]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 _memcpy
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 210  : 
; 211  :    STACK_END
; 212  : 
; 213  :    return;
; 214  : }

  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 1c 00	 ret	 28			; 0000001cH
_FHTOverlapAdd@28 ENDP
_TEXT	ENDS
PUBLIC	__real@3b000000
PUBLIC	__real@43800000
EXTRN	_PolyCycleIntp@24:NEAR
EXTRN	_VoxFHTkrnl@32:NEAR
EXTRN	_sinTBL_32:DWORD
EXTRN	_cosTBL_32:DWORD
;	COMDAT __real@3b000000
CONST	SEGMENT
__real@3b000000 DD 03b000000r			; 0.00195313
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _FHTSumCos@24
_TEXT	SEGMENT
tv132 = -1460
_pfPitchCycle$ = -1456
_fResampRate$ = -412
_fNormFreq$ = -408
_fNormPhase$ = -404
_piPhaseIndex$ = -400
_fPitchDFT$ = 8
_pfAmps$ = 12
_pfPhase$ = 16
_iHarm$ = 20
_iLength$ = 24
_pfWaveform$ = 28
_FHTSumCos@24 PROC NEAR					; COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 05 00
	00		 sub	 esp, 1460		; 000005b4H

; 252  :    float fNormFreq;              /* normalized pitch frequency                */
; 253  :    float fNormPhase;
; 254  :    float fResampRate;
; 255  :    STACK_INIT
; 256  :    float pfPitchCycle[FHT_EXP_SIZE+PP_NUM_SAMPLES];
; 257  :    int   piPhaseIndex[MAXHARM];
; 258  :    STACK_INIT_END
; 259  :  
; 260  :    STACK_ATTACH(float*,pfPitchCycle)
; 261  :    STACK_ATTACH(int*,piPhaseIndex)
; 262  :  
; 263  :    STACK_START
; 264  : 
; 265  :    /*--------------------------------------------------
; 266  :      Get phase indices
; 267  :    --------------------------------------------------*/
; 268  :    GetPhaseIndices( pfPhase, piPhaseIndex, iHarm );

  00009	8b 45 14	 mov	 eax, DWORD PTR _iHarm$[ebp]
  0000c	50		 push	 eax
  0000d	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _piPhaseIndex$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 10	 mov	 edx, DWORD PTR _pfPhase$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _GetPhaseIndices@12

; 269  :  
; 270  :    /*--------------------------------------------------
; 271  :       Create the pitch epoch
; 272  :    --------------------------------------------------*/
; 273  :    VoxFHTkrnl( pfAmps, piPhaseIndex, iHarm, pfPitchCycle+PP_DELAY,
; 274  :                FHT_EXP_SHIFT, fFHTWeights, sinTBL_32, cosTBL_32);

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR _cosTBL_32
  00022	50		 push	 eax
  00023	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sinTBL_32
  00029	51		 push	 ecx
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:_fFHTWeights
  0002f	6a 08		 push	 8
  00031	8d 95 54 fa ff
	ff		 lea	 edx, DWORD PTR _pfPitchCycle$[ebp+4]
  00037	52		 push	 edx
  00038	8b 45 14	 mov	 eax, DWORD PTR _iHarm$[ebp]
  0003b	50		 push	 eax
  0003c	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _piPhaseIndex$[ebp]
  00042	51		 push	 ecx
  00043	8b 55 0c	 mov	 edx, DWORD PTR _pfAmps$[ebp]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 _VoxFHTkrnl@32

; 275  :  
; 276  :    /*--------------------------------------------------
; 277  :      Interpolate the pitch epoch to generate the
; 278  :        synthesized sum of sine waves.
; 279  :    --------------------------------------------------*/
; 280  :    fNormFreq   = fPitchDFT*INV_NFFT;

  0004c	d9 45 08	 fld	 DWORD PTR _fPitchDFT$[ebp]
  0004f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3b000000
  00055	d9 9d 68 fe ff
	ff		 fstp	 DWORD PTR _fNormFreq$[ebp]

; 281  :    fResampRate = (float)FHT_EXP_SIZE*fNormFreq;

  0005b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@43800000
  00061	d8 8d 68 fe ff
	ff		 fmul	 DWORD PTR _fNormFreq$[ebp]
  00067	d9 9d 64 fe ff
	ff		 fstp	 DWORD PTR _fResampRate$[ebp]

; 282  :    fNormPhase  = (float)(-(iLength>>1))*fNormFreq;

  0006d	8b 45 18	 mov	 eax, DWORD PTR _iLength$[ebp]
  00070	d1 f8		 sar	 eax, 1
  00072	f7 d8		 neg	 eax
  00074	89 85 4c fa ff
	ff		 mov	 DWORD PTR tv132[ebp], eax
  0007a	db 85 4c fa ff
	ff		 fild	 DWORD PTR tv132[ebp]
  00080	d8 8d 68 fe ff
	ff		 fmul	 DWORD PTR _fNormFreq$[ebp]
  00086	d9 9d 6c fe ff
	ff		 fstp	 DWORD PTR _fNormPhase$[ebp]

; 283  :  
; 284  :    PolyCycleIntp(pfWaveform, iLength, pfPitchCycle+PP_DELAY,
; 285  :                   FHT_EXP_SHIFT, fResampRate, fNormPhase);

  0008c	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR _fNormPhase$[ebp]
  00092	51		 push	 ecx
  00093	8b 95 64 fe ff
	ff		 mov	 edx, DWORD PTR _fResampRate$[ebp]
  00099	52		 push	 edx
  0009a	6a 08		 push	 8
  0009c	8d 85 54 fa ff
	ff		 lea	 eax, DWORD PTR _pfPitchCycle$[ebp+4]
  000a2	50		 push	 eax
  000a3	8b 4d 18	 mov	 ecx, DWORD PTR _iLength$[ebp]
  000a6	51		 push	 ecx
  000a7	8b 55 1c	 mov	 edx, DWORD PTR _pfWaveform$[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 _PolyCycleIntp@24
  000b0	dd d8		 fstp	 ST(0)

; 286  : 
; 287  :    STACK_END
; 288  : }

  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 18 00	 ret	 24			; 00000018H
_FHTSumCos@24 ENDP
_TEXT	ENDS
PUBLIC	__real@3fc90fdb
EXTRN	_fRadiansToIndex:DWORD
;	COMDAT __real@3fc90fdb
CONST	SEGMENT
__real@3fc90fdb DD 03fc90fdbr			; 1.5708
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _GetPhaseIndices@12
_TEXT	SEGMENT
_i$ = -12
_iTemp$ = -8
_fTemp$ = -4
_pfPhase$ = 8
_piPhaseIndex$ = 12
_iHarm$ = 16
_GetPhaseIndices@12 PROC NEAR				; COMDAT

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 317  :    int   i;
; 318  :    int   iTemp;
; 319  :    float fTemp;
; 320  : 
; 321  :    for (i=0; i<iHarm; i++)

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $L1580
$L1581:
  0000f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$L1580:
  00018	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	3b 4d 10	 cmp	 ecx, DWORD PTR _iHarm$[ebp]
  0001e	7d 32		 jge	 SHORT $L1576

; 322  :    {
; 323  :       /*-------------------------------------------------
; 324  :         Compute trig table index.
; 325  :  
; 326  :         NOTE: This assumes a 2's complement integer
; 327  :               representation.  Using the trig mask 
; 328  :               (iResPhase&TRIG_MASK) yeilds the correct
; 329  :               positive index, even if iResPhase is
; 330  :               negative.  This would not be true for  
; 331  :               signed magnitude integer representation.
; 332  :       -------------------------------------------------*/
; 333  :       fTemp = (pfPhase[i]+PIO2)*fRadiansToIndex;

  00020	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00023	8b 45 08	 mov	 eax, DWORD PTR _pfPhase$[ebp]
  00026	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  00029	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3fc90fdb
  0002f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR _fRadiansToIndex
  00035	d9 5d fc	 fstp	 DWORD PTR _fTemp$[ebp]

; 334  :       VoxROUND2( fTemp, iTemp );

  00038	d9 45 fc	 fld	 DWORD PTR _fTemp$[ebp]
  0003b	db 5d f8	 fistp	 DWORD PTR _iTemp$[ebp]

; 335  :       piPhaseIndex[i] = iTemp & TRIG_MASK;

  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _iTemp$[ebp]
  00041	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00047	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0004a	8b 45 0c	 mov	 eax, DWORD PTR _piPhaseIndex$[ebp]
  0004d	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 336  :    }

  00050	eb bd		 jmp	 SHORT $L1581
$L1576:

; 337  : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 0c 00	 ret	 12			; 0000000cH
_GetPhaseIndices@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@CILMOHFB@pfAmps?5?$CB?$DN?5NULL?$AA@	; `string'
PUBLIC	??_C@_09LBCPLEAK@iHarm?5?$DO?50?$AA@		; `string'
PUBLIC	__real@46fffe00
EXTRN	_ScaleVector@16:NEAR
;	COMDAT ??_C@_0P@CILMOHFB@pfAmps?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0P@CILMOHFB@pfAmps?5?$CB?$DN?5NULL?$AA@ DB 'pfAmps != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LBCPLEAK@iHarm?5?$DO?50?$AA@
CONST	SEGMENT
??_C@_09LBCPLEAK@iHarm?5?$DO?50?$AA@ DB 'iHarm > 0', 00H ; `string'
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _ClipOverflows@8
_TEXT	SEGMENT
_fSumAmp$ = -12
_fScale$ = -8
_i$ = -4
_pfAmps$ = 8
_iHarm$ = 12
_ClipOverflows@8 PROC NEAR				; COMDAT

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 367  :    int   i;
; 368  :    float fSumAmp;
; 369  :    float fScale = 1.0F;

  00006	c7 45 f8 00 00
	80 3f		 mov	 DWORD PTR _fScale$[ebp], 1065353216 ; 3f800000H

; 370  : 
; 371  :    assert(pfAmps != NULL);

  0000d	83 7d 08 00	 cmp	 DWORD PTR _pfAmps$[ebp], 0
  00011	75 17		 jne	 SHORT $L1637
  00013	68 73 01 00 00	 push	 371			; 00000173H
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@LNDLEIGJ@c?3?2xbox?2private?2windows?2directx?2@
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@CILMOHFB@pfAmps?5?$CB?$DN?5NULL?$AA@
  00022	e8 00 00 00 00	 call	 __assert
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1637:

; 372  :    assert(iHarm > 0);

  0002a	83 7d 0c 00	 cmp	 DWORD PTR _iHarm$[ebp], 0
  0002e	7f 17		 jg	 SHORT $L1638
  00030	68 74 01 00 00	 push	 372			; 00000174H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@LNDLEIGJ@c?3?2xbox?2private?2windows?2directx?2@
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09LBCPLEAK@iHarm?5?$DO?50?$AA@
  0003f	e8 00 00 00 00	 call	 __assert
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1638:

; 373  : 
; 374  :    /*--------------------------------------------------
; 375  :      Prevent clipping by scaling the output to have
; 376  :        a maximum value of fClipLevel.
; 377  :    --------------------------------------------------*/
; 378  :    fSumAmp = 0.0F;

  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fSumAmp$[ebp], 0

; 379  :    for (i = 0; i < iHarm; i++)

  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00055	eb 09		 jmp	 SHORT $L1596
$L1597:
  00057	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0005a	83 c2 01	 add	 edx, 1
  0005d	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L1596:
  00060	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00063	3b 45 0c	 cmp	 eax, DWORD PTR _iHarm$[ebp]
  00066	7d 11		 jge	 SHORT $L1598

; 380  :      fSumAmp += pfAmps[i];

  00068	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0006b	8b 55 08	 mov	 edx, DWORD PTR _pfAmps$[ebp]
  0006e	d9 45 f4	 fld	 DWORD PTR _fSumAmp$[ebp]
  00071	d8 04 8a	 fadd	 DWORD PTR [edx+ecx*4]
  00074	d9 5d f4	 fstp	 DWORD PTR _fSumAmp$[ebp]
  00077	eb de		 jmp	 SHORT $L1597
$L1598:

; 381  :  
; 382  :    if (fSumAmp > CLIP_LEVEL) 

  00079	d9 45 f4	 fld	 DWORD PTR _fSumAmp$[ebp]
  0007c	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@46fffe00
  00082	df e0		 fnstsw	 ax
  00084	f6 c4 41	 test	 ah, 65			; 00000041H
  00087	75 0c		 jne	 SHORT $L1600

; 383  :      fScale = CLIP_LEVEL/fSumAmp;

  00089	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@46fffe00
  0008f	d8 75 f4	 fdiv	 DWORD PTR _fSumAmp$[ebp]
  00092	d9 5d f8	 fstp	 DWORD PTR _fScale$[ebp]
$L1600:

; 384  : 
; 385  :    ScaleVector( pfAmps, iHarm, fScale, pfAmps);

  00095	8b 45 08	 mov	 eax, DWORD PTR _pfAmps$[ebp]
  00098	50		 push	 eax
  00099	8b 4d f8	 mov	 ecx, DWORD PTR _fScale$[ebp]
  0009c	51		 push	 ecx
  0009d	8b 55 0c	 mov	 edx, DWORD PTR _iHarm$[ebp]
  000a0	52		 push	 edx
  000a1	8b 45 08	 mov	 eax, DWORD PTR _pfAmps$[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _ScaleVector@16

; 386  : }

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 08 00	 ret	 8
_ClipOverflows@8 ENDP
_TEXT	ENDS
END
