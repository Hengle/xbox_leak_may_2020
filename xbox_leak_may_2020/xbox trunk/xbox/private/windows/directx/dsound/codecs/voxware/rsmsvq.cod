; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\rsmsvq.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@CPANPLLF@iNumCand?5?$DM?$DN?5MAX_NUMCAND?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@KBKODBDP@?$CIpiIndices?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfData?5?$CB@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@BBCNLOI@?$CIpfStage1CB?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRotSc@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@OFJFMNDO@?$CIpfStage2InCellCB?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIp@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@CJIJFOKA@piIndexOfStage2OutCell?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@NKPFBDPM@iMBest?5?$DM?$DN?5MAX_NUMCAND?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@NCFNLJCB@?$CIpfData?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfCB?5?$CB?$DN?5NUL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MDPGCGOF@piMBestCand?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@KOCBFNCO@?$CIpfIn?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRSMatrix?5?$CB?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EFDBGEBJ@piIndexOfOutCell?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@NAOCIKDL@?$CIpfIn?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRef?5?$CB?$DN?5NULL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _RS2StageVQ2Enc@44
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _RS2StageVQ2Dec@40
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VQ2mbest@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _RotScaleVQ2@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DeRotScaleVQ2@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SelectOutCellCB@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CompDistVQ2@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_RS2StageVQ2Enc@44
PUBLIC	??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BI@CPANPLLF@iNumCand?5?$DM?$DN?5MAX_NUMCAND?$AA@ ; `string'
PUBLIC	??_C@_0CI@KBKODBDP@?$CIpiIndices?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfData?5?$CB@ ; `string'
PUBLIC	??_C@_0CP@BBCNLOI@?$CIpfStage1CB?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRotSc@ ; `string'
PUBLIC	??_C@_0DK@OFJFMNDO@?$CIpfStage2InCellCB?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIp@ ; `string'
PUBLIC	??_C@_0BP@CJIJFOKA@piIndexOfStage2OutCell?5?$CB?$DN?5NULL?$AA@ ; `string'
EXTRN	__fltused:NEAR
EXTRN	__assert:NEAR
EXTRN	_Dim2VectorQuantize@12:NEAR
EXTRN	_Dim2VectorLUT@16:NEAR
;	COMDAT ??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\rsmsvq.c
CONST	SEGMENT
??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\rsmsvq.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CPANPLLF@iNumCand?5?$DM?$DN?5MAX_NUMCAND?$AA@
CONST	SEGMENT
??_C@_0BI@CPANPLLF@iNumCand?5?$DM?$DN?5MAX_NUMCAND?$AA@ DB 'iNumCand <= M'
	DB	'AX_NUMCAND', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KBKODBDP@?$CIpiIndices?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfData?5?$CB@
CONST	SEGMENT
??_C@_0CI@KBKODBDP@?$CIpiIndices?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfData?5?$CB@ DB '('
	DB	'piIndices != NULL) && (pfData != NULL)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BBCNLOI@?$CIpfStage1CB?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRotSc@
CONST	SEGMENT
??_C@_0CP@BBCNLOI@?$CIpfStage1CB?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRotSc@ DB '('
	DB	'pfStage1CB != NULL) && (pfRotScaleCB != NULL)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@OFJFMNDO@?$CIpfStage2InCellCB?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIp@
CONST	SEGMENT
??_C@_0DK@OFJFMNDO@?$CIpfStage2InCellCB?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIp@ DB '('
	DB	'pfStage2InCellCB != NULL) && (pfStage2OutCellCB != NULL)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CJIJFOKA@piIndexOfStage2OutCell?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BP@CJIJFOKA@piIndexOfStage2OutCell?5?$CB?$DN?5NULL?$AA@ DB 'piInde'
	DB	'xOfStage2OutCell != NULL', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _RS2StageVQ2Enc@44
_TEXT	SEGMENT
_fDis$ = -64
_pfStage2In$ = -60
_iBestCand$ = -52
_pfStage1Out$ = -48
_iIndex$ = -40
_pfRes$ = -36
_pfQuanVec$ = -28
_piMBestCand$ = -20
_i$ = -12
_fMinDis$ = -8
_pfStage2CB$ = -4
_piIndices$ = 8
_pfData$ = 12
_iNumCand$ = 16
_iStage1Size$ = 20
_pfStage1CB$ = 24
_pfRotScaleCB$ = 28
_iStage2Size$ = 32
_pfStage2InCellCB$ = 36
_pfStage2OutCellCB$ = 40
_iNumOfOutCell$ = 44
_piIndexOfStage2OutCell$ = 48
_RS2StageVQ2Enc@44 PROC NEAR				; COMDAT

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 120  :   int i;
; 121  :   int iBestCand;
; 122  :   int iIndex;
; 123  :   float fDis;
; 124  :   float fMinDis;
; 125  :   const float *pfStage2CB;
; 126  : STACK_INIT
; 127  :   int piMBestCand[MAX_NUMCAND];
; 128  :   float pfStage1Out[VQ2_DIMENSION];
; 129  :   float pfRes[VQ2_DIMENSION];
; 130  :   float pfStage2In[VQ2_DIMENSION];
; 131  :   float pfQuanVec[VQ2_DIMENSION];
; 132  : STACK_INIT_END
; 133  : 
; 134  :   STACK_ATTACH(int *, piMBestCand)
; 135  :   STACK_ATTACH(float *, pfStage1Out)
; 136  :   STACK_ATTACH(float *, pfRes)
; 137  :   STACK_ATTACH(float *, pfStage2In)
; 138  :   STACK_ATTACH(float *, pfQuanVec)
; 139  : 
; 140  : STACK_START
; 141  :   
; 142  :   assert(iNumCand <= MAX_NUMCAND);

  00006	83 7d 10 02	 cmp	 DWORD PTR _iNumCand$[ebp], 2
  0000a	7e 17		 jle	 SHORT $L1183
  0000c	68 8e 00 00 00	 push	 142			; 0000008eH
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@CPANPLLF@iNumCand?5?$DM?$DN?5MAX_NUMCAND?$AA@
  0001b	e8 00 00 00 00	 call	 __assert
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1183:

; 143  :   assert((piIndices != NULL) && (pfData != NULL));

  00023	83 7d 08 00	 cmp	 DWORD PTR _piIndices$[ebp], 0
  00027	74 06		 je	 SHORT $L1184
  00029	83 7d 0c 00	 cmp	 DWORD PTR _pfData$[ebp], 0
  0002d	75 17		 jne	 SHORT $L1185
$L1184:
  0002f	68 8f 00 00 00	 push	 143			; 0000008fH
  00034	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@KBKODBDP@?$CIpiIndices?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfData?5?$CB@
  0003e	e8 00 00 00 00	 call	 __assert
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1185:

; 144  :   assert((pfStage1CB != NULL) && (pfRotScaleCB != NULL));

  00046	83 7d 18 00	 cmp	 DWORD PTR _pfStage1CB$[ebp], 0
  0004a	74 06		 je	 SHORT $L1186
  0004c	83 7d 1c 00	 cmp	 DWORD PTR _pfRotScaleCB$[ebp], 0
  00050	75 17		 jne	 SHORT $L1187
$L1186:
  00052	68 90 00 00 00	 push	 144			; 00000090H
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  0005c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@BBCNLOI@?$CIpfStage1CB?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRotSc@
  00061	e8 00 00 00 00	 call	 __assert
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1187:

; 145  :   assert((pfStage2InCellCB != NULL) && (pfStage2OutCellCB != NULL));

  00069	83 7d 24 00	 cmp	 DWORD PTR _pfStage2InCellCB$[ebp], 0
  0006d	74 06		 je	 SHORT $L1188
  0006f	83 7d 28 00	 cmp	 DWORD PTR _pfStage2OutCellCB$[ebp], 0
  00073	75 17		 jne	 SHORT $L1189
$L1188:
  00075	68 91 00 00 00	 push	 145			; 00000091H
  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  0007f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OFJFMNDO@?$CIpfStage2InCellCB?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIp@
  00084	e8 00 00 00 00	 call	 __assert
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1189:

; 146  :   assert(piIndexOfStage2OutCell != NULL);

  0008c	83 7d 30 00	 cmp	 DWORD PTR _piIndexOfStage2OutCell$[ebp], 0
  00090	75 17		 jne	 SHORT $L1190
  00092	68 92 00 00 00	 push	 146			; 00000092H
  00097	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@CJIJFOKA@piIndexOfStage2OutCell?5?$CB?$DN?5NULL?$AA@
  000a1	e8 00 00 00 00	 call	 __assert
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1190:

; 147  : 
; 148  :   /*--------------------------------------------------
; 149  :     initializethe  minimum distortion.
; 150  :     --------------------------------------------------*/
; 151  :   fMinDis = FLT_MAX;

  000a9	c7 45 f8 ee ff
	7f 7f		 mov	 DWORD PTR _fMinDis$[ebp], 2139095022 ; 7f7fffeeH

; 152  : 
; 153  :   /*--------------------------------------------------
; 154  :     Find the M-Best candidates
; 155  :     --------------------------------------------------*/
; 156  :   VQ2mbest(STACK_S pfData, pfStage1CB, iStage1Size, piMBestCand, iNumCand);

  000b0	8b 55 10	 mov	 edx, DWORD PTR _iNumCand$[ebp]
  000b3	52		 push	 edx
  000b4	8d 45 ec	 lea	 eax, DWORD PTR _piMBestCand$[ebp]
  000b7	50		 push	 eax
  000b8	8b 4d 14	 mov	 ecx, DWORD PTR _iStage1Size$[ebp]
  000bb	51		 push	 ecx
  000bc	8b 55 18	 mov	 edx, DWORD PTR _pfStage1CB$[ebp]
  000bf	52		 push	 edx
  000c0	8b 45 0c	 mov	 eax, DWORD PTR _pfData$[ebp]
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 _VQ2mbest@20

; 157  : 
; 158  : 
; 159  :   /*--------------------------------------------------
; 160  :     Check each candidates for the next stage 
; 161  :     --------------------------------------------------*/
; 162  :    for(i=0; i<iNumCand; i++)

  000c9	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000d0	eb 09		 jmp	 SHORT $L1024
$L1025:
  000d2	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000d5	83 c1 01	 add	 ecx, 1
  000d8	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$L1024:
  000db	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000de	3b 55 10	 cmp	 edx, DWORD PTR _iNumCand$[ebp]
  000e1	0f 8d 01 01 00
	00		 jge	 $L1026

; 163  :      {
; 164  :        iBestCand = piMBestCand[i];

  000e7	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000ea	8b 4c 85 ec	 mov	 ecx, DWORD PTR _piMBestCand$[ebp+eax*4]
  000ee	89 4d cc	 mov	 DWORD PTR _iBestCand$[ebp], ecx

; 165  : 
; 166  :        /*--------------------------------------------------
; 167  :          Find the quantized vector from stage I VQ
; 168  :          --------------------------------------------------*/
; 169  :        Dim2VectorLUT(iBestCand, pfStage1CB, iStage1Size, pfStage1Out);

  000f1	8d 55 d0	 lea	 edx, DWORD PTR _pfStage1Out$[ebp]
  000f4	52		 push	 edx
  000f5	8b 45 14	 mov	 eax, DWORD PTR _iStage1Size$[ebp]
  000f8	50		 push	 eax
  000f9	8b 4d 18	 mov	 ecx, DWORD PTR _pfStage1CB$[ebp]
  000fc	51		 push	 ecx
  000fd	8b 55 cc	 mov	 edx, DWORD PTR _iBestCand$[ebp]
  00100	52		 push	 edx
  00101	e8 00 00 00 00	 call	 _Dim2VectorLUT@16

; 170  : 
; 171  :        /*--------------------------------------------------
; 172  :          Find the residual and do rotation-scaling to 
; 173  :          normalize the residual vector.
; 174  :          --------------------------------------------------*/
; 175  :        pfRes[0] = pfData[0] - pfStage1Out[0];

  00106	8b 45 0c	 mov	 eax, DWORD PTR _pfData$[ebp]
  00109	d9 00		 fld	 DWORD PTR [eax]
  0010b	d8 65 d0	 fsub	 DWORD PTR _pfStage1Out$[ebp]
  0010e	d9 5d dc	 fstp	 DWORD PTR _pfRes$[ebp]

; 176  :        pfRes[1] = pfData[1] - pfStage1Out[1];

  00111	8b 4d 0c	 mov	 ecx, DWORD PTR _pfData$[ebp]
  00114	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00117	d8 65 d4	 fsub	 DWORD PTR _pfStage1Out$[ebp+4]
  0011a	d9 5d e0	 fstp	 DWORD PTR _pfRes$[ebp+4]

; 177  : 
; 178  :        RotScaleVQ2(pfRes, pfRotScaleCB, iBestCand, pfStage2In);

  0011d	8d 55 c4	 lea	 edx, DWORD PTR _pfStage2In$[ebp]
  00120	52		 push	 edx
  00121	8b 45 cc	 mov	 eax, DWORD PTR _iBestCand$[ebp]
  00124	50		 push	 eax
  00125	8b 4d 1c	 mov	 ecx, DWORD PTR _pfRotScaleCB$[ebp]
  00128	51		 push	 ecx
  00129	8d 55 dc	 lea	 edx, DWORD PTR _pfRes$[ebp]
  0012c	52		 push	 edx
  0012d	e8 00 00 00 00	 call	 _RotScaleVQ2@16

; 179  : 
; 180  :        /*--------------------------------------------------
; 181  :         Initialize the codebook for stage II -- from
; 182  :         inner cell or outer cell
; 183  :         --------------------------------------------------*/
; 184  :        if (SelectOutCellCB(piIndexOfStage2OutCell, iNumOfOutCell, 
; 185  :                            iBestCand) == 1)

  00132	8b 45 cc	 mov	 eax, DWORD PTR _iBestCand$[ebp]
  00135	50		 push	 eax
  00136	8b 4d 2c	 mov	 ecx, DWORD PTR _iNumOfOutCell$[ebp]
  00139	51		 push	 ecx
  0013a	8b 55 30	 mov	 edx, DWORD PTR _piIndexOfStage2OutCell$[ebp]
  0013d	52		 push	 edx
  0013e	e8 00 00 00 00	 call	 _SelectOutCellCB@12
  00143	83 f8 01	 cmp	 eax, 1
  00146	75 08		 jne	 SHORT $L1027

; 186  :           pfStage2CB = pfStage2OutCellCB;

  00148	8b 45 28	 mov	 eax, DWORD PTR _pfStage2OutCellCB$[ebp]
  0014b	89 45 fc	 mov	 DWORD PTR _pfStage2CB$[ebp], eax

; 187  :        else

  0014e	eb 06		 jmp	 SHORT $L1028
$L1027:

; 188  :           pfStage2CB = pfStage2InCellCB;

  00150	8b 4d 24	 mov	 ecx, DWORD PTR _pfStage2InCellCB$[ebp]
  00153	89 4d fc	 mov	 DWORD PTR _pfStage2CB$[ebp], ecx
$L1028:

; 189  : 
; 190  : 
; 191  :        /*--------------------------------------------------
; 192  :         Quantize the residual using stage II codebook.
; 193  :         --------------------------------------------------*/
; 194  :        iIndex = Dim2VectorQuantize(pfStage2In, pfStage2CB, iStage2Size);

  00156	8b 55 20	 mov	 edx, DWORD PTR _iStage2Size$[ebp]
  00159	52		 push	 edx
  0015a	8b 45 fc	 mov	 eax, DWORD PTR _pfStage2CB$[ebp]
  0015d	50		 push	 eax
  0015e	8d 4d c4	 lea	 ecx, DWORD PTR _pfStage2In$[ebp]
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 _Dim2VectorQuantize@12
  00167	89 45 d8	 mov	 DWORD PTR _iIndex$[ebp], eax

; 195  : 
; 196  :        /*--------------------------------------------------
; 197  :         Now, get the quantized stage II vector.
; 198  :         --------------------------------------------------*/
; 199  :        Dim2VectorLUT(iIndex, pfStage2CB, iStage2Size, pfStage2In);

  0016a	8d 55 c4	 lea	 edx, DWORD PTR _pfStage2In$[ebp]
  0016d	52		 push	 edx
  0016e	8b 45 20	 mov	 eax, DWORD PTR _iStage2Size$[ebp]
  00171	50		 push	 eax
  00172	8b 4d fc	 mov	 ecx, DWORD PTR _pfStage2CB$[ebp]
  00175	51		 push	 ecx
  00176	8b 55 d8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 _Dim2VectorLUT@16

; 200  : 
; 201  :        /*--------------------------------------------------
; 202  :          undo rotation and scaling 
; 203  :         --------------------------------------------------*/
; 204  :        DeRotScaleVQ2(pfStage2In, pfRotScaleCB, iBestCand, pfRes);

  0017f	8d 45 dc	 lea	 eax, DWORD PTR _pfRes$[ebp]
  00182	50		 push	 eax
  00183	8b 4d cc	 mov	 ecx, DWORD PTR _iBestCand$[ebp]
  00186	51		 push	 ecx
  00187	8b 55 1c	 mov	 edx, DWORD PTR _pfRotScaleCB$[ebp]
  0018a	52		 push	 edx
  0018b	8d 45 c4	 lea	 eax, DWORD PTR _pfStage2In$[ebp]
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 _DeRotScaleVQ2@16

; 205  : 
; 206  :        /*--------------------------------------------------
; 207  :         Get the fully quantized vector by adding the
; 208  :         residual vector.
; 209  :         --------------------------------------------------*/
; 210  :        pfStage1Out[0] += pfRes[0];

  00194	d9 45 d0	 fld	 DWORD PTR _pfStage1Out$[ebp]
  00197	d8 45 dc	 fadd	 DWORD PTR _pfRes$[ebp]
  0019a	d9 5d d0	 fstp	 DWORD PTR _pfStage1Out$[ebp]

; 211  :        pfStage1Out[1] += pfRes[1];

  0019d	d9 45 d4	 fld	 DWORD PTR _pfStage1Out$[ebp+4]
  001a0	d8 45 e0	 fadd	 DWORD PTR _pfRes$[ebp+4]
  001a3	d9 5d d4	 fstp	 DWORD PTR _pfStage1Out$[ebp+4]

; 212  : 
; 213  :        /*--------------------------------------------------
; 214  :         Compute the distortion
; 215  :         --------------------------------------------------*/
; 216  :        fDis = CompDistVQ2(pfData, pfStage1Out);

  001a6	8d 4d d0	 lea	 ecx, DWORD PTR _pfStage1Out$[ebp]
  001a9	51		 push	 ecx
  001aa	8b 55 0c	 mov	 edx, DWORD PTR _pfData$[ebp]
  001ad	52		 push	 edx
  001ae	e8 00 00 00 00	 call	 _CompDistVQ2@8
  001b3	d9 55 c0	 fst	 DWORD PTR _fDis$[ebp]

; 217  : 
; 218  :        /*--------------------------------------------------
; 219  :          Find the minimum distation
; 220  :         --------------------------------------------------*/
; 221  :        if (fDis < fMinDis) 

  001b6	d8 5d f8	 fcomp	 DWORD PTR _fMinDis$[ebp]
  001b9	df e0		 fnstsw	 ax
  001bb	f6 c4 05	 test	 ah, 5
  001be	7a 23		 jp	 SHORT $L1029

; 222  :          {
; 223  :            fMinDis = fDis;

  001c0	8b 45 c0	 mov	 eax, DWORD PTR _fDis$[ebp]
  001c3	89 45 f8	 mov	 DWORD PTR _fMinDis$[ebp], eax

; 224  :            piIndices[0] = iBestCand;

  001c6	8b 4d 08	 mov	 ecx, DWORD PTR _piIndices$[ebp]
  001c9	8b 55 cc	 mov	 edx, DWORD PTR _iBestCand$[ebp]
  001cc	89 11		 mov	 DWORD PTR [ecx], edx

; 225  :            piIndices[1] = iIndex;

  001ce	8b 45 08	 mov	 eax, DWORD PTR _piIndices$[ebp]
  001d1	8b 4d d8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  001d4	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 226  :            pfQuanVec[0] = pfStage1Out[0];

  001d7	8b 55 d0	 mov	 edx, DWORD PTR _pfStage1Out$[ebp]
  001da	89 55 e4	 mov	 DWORD PTR _pfQuanVec$[ebp], edx

; 227  :            pfQuanVec[1] = pfStage1Out[1];

  001dd	8b 45 d4	 mov	 eax, DWORD PTR _pfStage1Out$[ebp+4]
  001e0	89 45 e8	 mov	 DWORD PTR _pfQuanVec$[ebp+4], eax
$L1029:

; 228  :          }
; 229  :      } 

  001e3	e9 ea fe ff ff	 jmp	 $L1025
$L1026:

; 230  : 
; 231  :    /*--------------------------------------------------
; 232  :      Replace pfData with pfQuanVec
; 233  :      --------------------------------------------------*/
; 234  :    pfData[0] = pfQuanVec[0];

  001e8	8b 4d 0c	 mov	 ecx, DWORD PTR _pfData$[ebp]
  001eb	8b 55 e4	 mov	 edx, DWORD PTR _pfQuanVec$[ebp]
  001ee	89 11		 mov	 DWORD PTR [ecx], edx

; 235  :    pfData[1] = pfQuanVec[1];

  001f0	8b 45 0c	 mov	 eax, DWORD PTR _pfData$[ebp]
  001f3	8b 4d e8	 mov	 ecx, DWORD PTR _pfQuanVec$[ebp+4]
  001f6	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 236  :    
; 237  : STACK_END
; 238  : }

  001f9	8b e5		 mov	 esp, ebp
  001fb	5d		 pop	 ebp
  001fc	c2 2c 00	 ret	 44			; 0000002cH
_RS2StageVQ2Enc@44 ENDP
_TEXT	ENDS
PUBLIC	_RS2StageVQ2Dec@40
; Function compile flags: /Odt
;	COMDAT _RS2StageVQ2Dec@40
_TEXT	SEGMENT
_pfStage2In$ = -20
_pfRes$ = -12
_pfStage2CB$ = -4
_piIndices$ = 8
_pfData$ = 12
_iStage1Size$ = 16
_pfStage1CB$ = 20
_pfRotScaleCB$ = 24
_iStage2Size$ = 28
_pfStage2InCellCB$ = 32
_pfStage2OutCellCB$ = 36
_iNumOfOutCell$ = 40
_piIndexOfStage2OutCell$ = 44
_RS2StageVQ2Dec@40 PROC NEAR				; COMDAT

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 291  :   const float *pfStage2CB;
; 292  : STACK_INIT
; 293  :   float pfStage2In[VQ2_DIMENSION];
; 294  :   float pfRes[VQ2_DIMENSION];
; 295  : STACK_INIT_END
; 296  : 
; 297  :   STACK_ATTACH(float *, pfStage2In)  
; 298  :   STACK_ATTACH(float *, pfRes)
; 299  : 
; 300  : STACK_START
; 301  : 
; 302  :   assert((piIndices != NULL) && (pfData != NULL));

  00006	83 7d 08 00	 cmp	 DWORD PTR _piIndices$[ebp], 0
  0000a	74 06		 je	 SHORT $L1195
  0000c	83 7d 0c 00	 cmp	 DWORD PTR _pfData$[ebp], 0
  00010	75 17		 jne	 SHORT $L1196
$L1195:
  00012	68 2e 01 00 00	 push	 302			; 0000012eH
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@KBKODBDP@?$CIpiIndices?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfData?5?$CB@
  00021	e8 00 00 00 00	 call	 __assert
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1196:

; 303  :   assert((pfStage1CB != NULL) && (pfRotScaleCB != NULL));

  00029	83 7d 14 00	 cmp	 DWORD PTR _pfStage1CB$[ebp], 0
  0002d	74 06		 je	 SHORT $L1197
  0002f	83 7d 18 00	 cmp	 DWORD PTR _pfRotScaleCB$[ebp], 0
  00033	75 17		 jne	 SHORT $L1198
$L1197:
  00035	68 2f 01 00 00	 push	 303			; 0000012fH
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@BBCNLOI@?$CIpfStage1CB?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRotSc@
  00044	e8 00 00 00 00	 call	 __assert
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1198:

; 304  :   assert((pfStage2InCellCB != NULL) && (pfStage2OutCellCB != NULL));

  0004c	83 7d 20 00	 cmp	 DWORD PTR _pfStage2InCellCB$[ebp], 0
  00050	74 06		 je	 SHORT $L1199
  00052	83 7d 24 00	 cmp	 DWORD PTR _pfStage2OutCellCB$[ebp], 0
  00056	75 17		 jne	 SHORT $L1200
$L1199:
  00058	68 30 01 00 00	 push	 304			; 00000130H
  0005d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  00062	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@OFJFMNDO@?$CIpfStage2InCellCB?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIp@
  00067	e8 00 00 00 00	 call	 __assert
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1200:

; 305  :   assert(piIndexOfStage2OutCell != NULL);

  0006f	83 7d 2c 00	 cmp	 DWORD PTR _piIndexOfStage2OutCell$[ebp], 0
  00073	75 17		 jne	 SHORT $L1201
  00075	68 31 01 00 00	 push	 305			; 00000131H
  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  0007f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@CJIJFOKA@piIndexOfStage2OutCell?5?$CB?$DN?5NULL?$AA@
  00084	e8 00 00 00 00	 call	 __assert
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1201:

; 306  :  
; 307  :   /*--------------------------------------------------
; 308  :     Decode the Stage I vector
; 309  :     --------------------------------------------------*/
; 310  :   Dim2VectorLUT(piIndices[0], pfStage1CB, iStage1Size, pfData);

  0008c	8b 4d 0c	 mov	 ecx, DWORD PTR _pfData$[ebp]
  0008f	51		 push	 ecx
  00090	8b 55 10	 mov	 edx, DWORD PTR _iStage1Size$[ebp]
  00093	52		 push	 edx
  00094	8b 45 14	 mov	 eax, DWORD PTR _pfStage1CB$[ebp]
  00097	50		 push	 eax
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _piIndices$[ebp]
  0009b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 _Dim2VectorLUT@16

; 311  : 
; 312  :   /*--------------------------------------------------
; 313  :     Find the stage II codebook
; 314  :     --------------------------------------------------*/
; 315  :   if (SelectOutCellCB(piIndexOfStage2OutCell, iNumOfOutCell,
; 316  :                       piIndices[0]) == 1)

  000a3	8b 45 08	 mov	 eax, DWORD PTR _piIndices$[ebp]
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	51		 push	 ecx
  000a9	8b 55 28	 mov	 edx, DWORD PTR _iNumOfOutCell$[ebp]
  000ac	52		 push	 edx
  000ad	8b 45 2c	 mov	 eax, DWORD PTR _piIndexOfStage2OutCell$[ebp]
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 _SelectOutCellCB@12
  000b6	83 f8 01	 cmp	 eax, 1
  000b9	75 08		 jne	 SHORT $L1065

; 317  :     pfStage2CB = pfStage2OutCellCB;

  000bb	8b 4d 24	 mov	 ecx, DWORD PTR _pfStage2OutCellCB$[ebp]
  000be	89 4d fc	 mov	 DWORD PTR _pfStage2CB$[ebp], ecx

; 318  :   else

  000c1	eb 06		 jmp	 SHORT $L1066
$L1065:

; 319  :     pfStage2CB = pfStage2InCellCB;

  000c3	8b 55 20	 mov	 edx, DWORD PTR _pfStage2InCellCB$[ebp]
  000c6	89 55 fc	 mov	 DWORD PTR _pfStage2CB$[ebp], edx
$L1066:

; 320  : 
; 321  :   /*--------------------------------------------------
; 322  :     Decode the stage II vector
; 323  :     --------------------------------------------------*/
; 324  :   Dim2VectorLUT(piIndices[1], pfStage2CB, iStage2Size, pfStage2In);

  000c9	8d 45 ec	 lea	 eax, DWORD PTR _pfStage2In$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d 1c	 mov	 ecx, DWORD PTR _iStage2Size$[ebp]
  000d0	51		 push	 ecx
  000d1	8b 55 fc	 mov	 edx, DWORD PTR _pfStage2CB$[ebp]
  000d4	52		 push	 edx
  000d5	8b 45 08	 mov	 eax, DWORD PTR _piIndices$[ebp]
  000d8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 _Dim2VectorLUT@16

; 325  : 
; 326  :   /*--------------------------------------------------
; 327  :     undo rotation and scaling 
; 328  :     --------------------------------------------------*/
; 329  :   DeRotScaleVQ2(pfStage2In, pfRotScaleCB, piIndices[0], pfRes);

  000e1	8d 55 f4	 lea	 edx, DWORD PTR _pfRes$[ebp]
  000e4	52		 push	 edx
  000e5	8b 45 08	 mov	 eax, DWORD PTR _piIndices$[ebp]
  000e8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ea	51		 push	 ecx
  000eb	8b 55 18	 mov	 edx, DWORD PTR _pfRotScaleCB$[ebp]
  000ee	52		 push	 edx
  000ef	8d 45 ec	 lea	 eax, DWORD PTR _pfStage2In$[ebp]
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 _DeRotScaleVQ2@16

; 330  : 
; 331  :   /*--------------------------------------------------
; 332  :     Add two stage vectors together
; 333  :     --------------------------------------------------*/
; 334  :   pfData[0] += pfRes[0];

  000f8	8b 4d 0c	 mov	 ecx, DWORD PTR _pfData$[ebp]
  000fb	d9 45 f4	 fld	 DWORD PTR _pfRes$[ebp]
  000fe	d8 01		 fadd	 DWORD PTR [ecx]
  00100	8b 55 0c	 mov	 edx, DWORD PTR _pfData$[ebp]
  00103	d9 1a		 fstp	 DWORD PTR [edx]

; 335  :   pfData[1] += pfRes[1];

  00105	8b 45 0c	 mov	 eax, DWORD PTR _pfData$[ebp]
  00108	d9 45 f8	 fld	 DWORD PTR _pfRes$[ebp+4]
  0010b	d8 40 04	 fadd	 DWORD PTR [eax+4]
  0010e	8b 4d 0c	 mov	 ecx, DWORD PTR _pfData$[ebp]
  00111	d9 59 04	 fstp	 DWORD PTR [ecx+4]

; 336  : 
; 337  : STACK_END
; 338  : }

  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c2 28 00	 ret	 40			; 00000028H
_RS2StageVQ2Dec@40 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@NKPFBDPM@iMBest?5?$DM?$DN?5MAX_NUMCAND?$AA@ ; `string'
PUBLIC	??_C@_0CD@NCFNLJCB@?$CIpfData?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfCB?5?$CB?$DN?5NUL@ ; `string'
PUBLIC	??_C@_0BE@MDPGCGOF@piMBestCand?5?$CB?$DN?5NULL?$AA@ ; `string'
;	COMDAT ??_C@_0BG@NKPFBDPM@iMBest?5?$DM?$DN?5MAX_NUMCAND?$AA@
CONST	SEGMENT
??_C@_0BG@NKPFBDPM@iMBest?5?$DM?$DN?5MAX_NUMCAND?$AA@ DB 'iMBest <= MAX_N'
	DB	'UMCAND', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NCFNLJCB@?$CIpfData?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfCB?5?$CB?$DN?5NUL@
CONST	SEGMENT
??_C@_0CD@NCFNLJCB@?$CIpfData?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfCB?5?$CB?$DN?5NUL@ DB '('
	DB	'pfData != NULL) && (pfCB != NULL)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MDPGCGOF@piMBestCand?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BE@MDPGCGOF@piMBestCand?5?$CB?$DN?5NULL?$AA@ DB 'piMBestCand != NU'
	DB	'LL', 00H					; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VQ2mbest@20
_TEXT	SEGMENT
_j$ = -20
_fDis$ = -16
_i$ = -12
_pfMinDis$ = -8
_pfData$ = 8
_pfCB$ = 12
_iCBSize$ = 16
_piMBestCand$ = 20
_iMBest$ = 24
_VQ2mbest@20 PROC NEAR					; COMDAT

; 367  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi

; 368  :   int i, j;
; 369  :   float fDis;
; 370  : 
; 371  : STACK_INIT
; 372  :   float pfMinDis[MAX_NUMCAND];
; 373  : STACK_INIT_END
; 374  : 
; 375  :   STACK_ATTACH (float *, pfMinDis)
; 376  : 
; 377  : STACK_START
; 378  : 
; 379  :   assert(iMBest <= MAX_NUMCAND);

  00007	83 7d 18 02	 cmp	 DWORD PTR _iMBest$[ebp], 2
  0000b	7e 17		 jle	 SHORT $L1205
  0000d	68 7b 01 00 00	 push	 379			; 0000017bH
  00012	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@NKPFBDPM@iMBest?5?$DM?$DN?5MAX_NUMCAND?$AA@
  0001c	e8 00 00 00 00	 call	 __assert
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1205:

; 380  :   assert((pfData != NULL) && (pfCB != NULL));

  00024	83 7d 08 00	 cmp	 DWORD PTR _pfData$[ebp], 0
  00028	74 06		 je	 SHORT $L1206
  0002a	83 7d 0c 00	 cmp	 DWORD PTR _pfCB$[ebp], 0
  0002e	75 17		 jne	 SHORT $L1207
$L1206:
  00030	68 7c 01 00 00	 push	 380			; 0000017cH
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@NCFNLJCB@?$CIpfData?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfCB?5?$CB?$DN?5NUL@
  0003f	e8 00 00 00 00	 call	 __assert
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1207:

; 381  :   assert(piMBestCand != NULL);

  00047	83 7d 14 00	 cmp	 DWORD PTR _piMBestCand$[ebp], 0
  0004b	75 17		 jne	 SHORT $L1208
  0004d	68 7d 01 00 00	 push	 381			; 0000017dH
  00052	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@MDPGCGOF@piMBestCand?5?$CB?$DN?5NULL?$AA@
  0005c	e8 00 00 00 00	 call	 __assert
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1208:

; 382  : 
; 383  :   /*--------------------------------------------------
; 384  :     Initialize piMBestCand and pfMinDis 
; 385  :     --------------------------------------------------*/
; 386  :   for(i = 0; i < iMBest; i++) 

  00064	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0006b	eb 09		 jmp	 SHORT $L1091
$L1092:
  0006d	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00070	83 c0 01	 add	 eax, 1
  00073	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$L1091:
  00076	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00079	3b 4d 18	 cmp	 ecx, DWORD PTR _iMBest$[ebp]
  0007c	7d 1a		 jge	 SHORT $L1093

; 387  :     {
; 388  :       piMBestCand[i] = 0;

  0007e	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00081	8b 45 14	 mov	 eax, DWORD PTR _piMBestCand$[ebp]
  00084	c7 04 90 00 00
	00 00		 mov	 DWORD PTR [eax+edx*4], 0

; 389  :       pfMinDis[i] = FLT_MAX;

  0008b	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0008e	c7 44 8d f8 ee
	ff 7f 7f	 mov	 DWORD PTR _pfMinDis$[ebp+ecx*4], 2139095022 ; 7f7fffeeH

; 390  :     }

  00096	eb d5		 jmp	 SHORT $L1092
$L1093:

; 391  : 
; 392  :   /*--------------------------------------------------
; 393  :     Search each entry of the codebook, and find the
; 394  :     M-Best candidates 
; 395  :     --------------------------------------------------*/
; 396  :   for (i = 0; i < iCBSize; i++)

  00098	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0009f	eb 09		 jmp	 SHORT $L1094
$L1095:
  000a1	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000a4	83 c2 01	 add	 edx, 1
  000a7	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
$L1094:
  000aa	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000ad	3b 45 10	 cmp	 eax, DWORD PTR _iCBSize$[ebp]
  000b0	0f 8d 93 00 00
	00		 jge	 $L1077

; 397  :     {
; 398  :       /*--------------------------------------------------
; 399  :         Compute the distance between the input vector and
; 400  :         each code-vector.
; 401  :         --------------------------------------------------*/
; 402  :       fDis = CompDistVQ2(pfData, pfCB);

  000b6	8b 4d 0c	 mov	 ecx, DWORD PTR _pfCB$[ebp]
  000b9	51		 push	 ecx
  000ba	8b 55 08	 mov	 edx, DWORD PTR _pfData$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _CompDistVQ2@8
  000c3	d9 5d f0	 fstp	 DWORD PTR _fDis$[ebp]

; 403  :       pfCB += 2;

  000c6	8b 45 0c	 mov	 eax, DWORD PTR _pfCB$[ebp]
  000c9	83 c0 08	 add	 eax, 8
  000cc	89 45 0c	 mov	 DWORD PTR _pfCB$[ebp], eax

; 404  :       
; 405  :       /*--------------------------------------------------
; 406  :         If the error for this entry is less than the worst
; 407  :         retained candidate so far, keep it. 
; 408  :         Note that the error list is maintained in order 
; 409  :         of best (min error) to worst.
; 410  :         --------------------------------------------------*/
; 411  :       if (fDis < pfMinDis[iMBest-1])

  000cf	8b 4d 18	 mov	 ecx, DWORD PTR _iMBest$[ebp]
  000d2	d9 45 f0	 fld	 DWORD PTR _fDis$[ebp]
  000d5	d8 5c 8d f4	 fcomp	 DWORD PTR _pfMinDis$[ebp+ecx*4-4]
  000d9	df e0		 fnstsw	 ax
  000db	f6 c4 05	 test	 ah, 5
  000de	7a 64		 jp	 SHORT $L1097

; 412  :         { 
; 413  :           for(j=iMBest-1; ((j>0)&&(fDis<=pfMinDis[j-1])); j--)

  000e0	8b 55 18	 mov	 edx, DWORD PTR _iMBest$[ebp]
  000e3	83 ea 01	 sub	 edx, 1
  000e6	89 55 ec	 mov	 DWORD PTR _j$[ebp], edx
  000e9	eb 09		 jmp	 SHORT $L1098
$L1099:
  000eb	8b 45 ec	 mov	 eax, DWORD PTR _j$[ebp]
  000ee	83 e8 01	 sub	 eax, 1
  000f1	89 45 ec	 mov	 DWORD PTR _j$[ebp], eax
$L1098:
  000f4	83 7d ec 00	 cmp	 DWORD PTR _j$[ebp], 0
  000f8	7e 34		 jle	 SHORT $L1100
  000fa	8b 4d ec	 mov	 ecx, DWORD PTR _j$[ebp]
  000fd	d9 45 f0	 fld	 DWORD PTR _fDis$[ebp]
  00100	d8 5c 8d f4	 fcomp	 DWORD PTR _pfMinDis$[ebp+ecx*4-4]
  00104	df e0		 fnstsw	 ax
  00106	f6 c4 41	 test	 ah, 65			; 00000041H
  00109	7a 23		 jp	 SHORT $L1100

; 414  :             {
; 415  :               pfMinDis[j] = pfMinDis[j-1];

  0010b	8b 55 ec	 mov	 edx, DWORD PTR _j$[ebp]
  0010e	8b 45 ec	 mov	 eax, DWORD PTR _j$[ebp]
  00111	8b 4c 85 f4	 mov	 ecx, DWORD PTR _pfMinDis$[ebp+eax*4-4]
  00115	89 4c 95 f8	 mov	 DWORD PTR _pfMinDis$[ebp+edx*4], ecx

; 416  :               piMBestCand[j] =piMBestCand[j-1];

  00119	8b 55 ec	 mov	 edx, DWORD PTR _j$[ebp]
  0011c	8b 45 14	 mov	 eax, DWORD PTR _piMBestCand$[ebp]
  0011f	8b 4d ec	 mov	 ecx, DWORD PTR _j$[ebp]
  00122	8b 75 14	 mov	 esi, DWORD PTR _piMBestCand$[ebp]
  00125	8b 4c 8e fc	 mov	 ecx, DWORD PTR [esi+ecx*4-4]
  00129	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 417  :             }

  0012c	eb bd		 jmp	 SHORT $L1099
$L1100:

; 418  :              
; 419  :           pfMinDis[j] = fDis;

  0012e	8b 55 ec	 mov	 edx, DWORD PTR _j$[ebp]
  00131	8b 45 f0	 mov	 eax, DWORD PTR _fDis$[ebp]
  00134	89 44 95 f8	 mov	 DWORD PTR _pfMinDis$[ebp+edx*4], eax

; 420  :           piMBestCand[j] = i;

  00138	8b 4d ec	 mov	 ecx, DWORD PTR _j$[ebp]
  0013b	8b 55 14	 mov	 edx, DWORD PTR _piMBestCand$[ebp]
  0013e	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00141	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$L1097:

; 421  :         }
; 422  :     } 

  00144	e9 58 ff ff ff	 jmp	 $L1095
$L1077:

; 423  : 
; 424  : STACK_END
; 425  : }

  00149	5e		 pop	 esi
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c2 14 00	 ret	 20			; 00000014H
_VQ2mbest@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DK@KOCBFNCO@?$CIpfIn?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRSMatrix?5?$CB?$DN@ ; `string'
;	COMDAT ??_C@_0DK@KOCBFNCO@?$CIpfIn?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRSMatrix?5?$CB?$DN@
CONST	SEGMENT
??_C@_0DK@KOCBFNCO@?$CIpfIn?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRSMatrix?5?$CB?$DN@ DB '('
	DB	'pfIn != NULL) && (pfRSMatrix != NULL) && (pfOut != NULL)', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _RotScaleVQ2@16
_TEXT	SEGMENT
_pfRSVec$ = -4
_pfIn$ = 8
_pfRSMatrix$ = 12
_iIndex$ = 16
_pfOut$ = 20
_RotScaleVQ2@16 PROC NEAR				; COMDAT

; 451  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 452  :   const float *pfRSVec = &(pfRSMatrix[iIndex<<1]);

  00004	8b 45 10	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	d1 e0		 shl	 eax, 1
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _pfRSMatrix$[ebp]
  0000c	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0000f	89 55 fc	 mov	 DWORD PTR _pfRSVec$[ebp], edx

; 453  : 
; 454  :   assert((pfIn != NULL) && (pfRSMatrix != NULL) && (pfOut != NULL));

  00012	83 7d 08 00	 cmp	 DWORD PTR _pfIn$[ebp], 0
  00016	74 0c		 je	 SHORT $L1212
  00018	83 7d 0c 00	 cmp	 DWORD PTR _pfRSMatrix$[ebp], 0
  0001c	74 06		 je	 SHORT $L1212
  0001e	83 7d 14 00	 cmp	 DWORD PTR _pfOut$[ebp], 0
  00022	75 17		 jne	 SHORT $L1213
$L1212:
  00024	68 c6 01 00 00	 push	 454			; 000001c6H
  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@KOCBFNCO@?$CIpfIn?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRSMatrix?5?$CB?$DN@
  00033	e8 00 00 00 00	 call	 __assert
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1213:

; 455  : 
; 456  :   pfOut[0]=  pfRSVec[0] * pfIn[0] + pfRSVec[1] * pfIn[1];

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _pfRSVec$[ebp]
  0003e	8b 55 08	 mov	 edx, DWORD PTR _pfIn$[ebp]
  00041	d9 01		 fld	 DWORD PTR [ecx]
  00043	d8 0a		 fmul	 DWORD PTR [edx]
  00045	8b 45 fc	 mov	 eax, DWORD PTR _pfRSVec$[ebp]
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _pfIn$[ebp]
  0004b	d9 40 04	 fld	 DWORD PTR [eax+4]
  0004e	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  00051	de c1		 faddp	 ST(1), ST(0)
  00053	8b 55 14	 mov	 edx, DWORD PTR _pfOut$[ebp]
  00056	d9 1a		 fstp	 DWORD PTR [edx]

; 457  :   pfOut[1]= -pfRSVec[1] * pfIn[0] + pfRSVec[0] * pfIn[1];

  00058	8b 45 fc	 mov	 eax, DWORD PTR _pfRSVec$[ebp]
  0005b	d9 40 04	 fld	 DWORD PTR [eax+4]
  0005e	d9 e0		 fchs
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _pfIn$[ebp]
  00063	d8 09		 fmul	 DWORD PTR [ecx]
  00065	8b 55 fc	 mov	 edx, DWORD PTR _pfRSVec$[ebp]
  00068	8b 45 08	 mov	 eax, DWORD PTR _pfIn$[ebp]
  0006b	d9 02		 fld	 DWORD PTR [edx]
  0006d	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00070	de c1		 faddp	 ST(1), ST(0)
  00072	8b 4d 14	 mov	 ecx, DWORD PTR _pfOut$[ebp]
  00075	d9 59 04	 fstp	 DWORD PTR [ecx+4]

; 458  : }    

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 10 00	 ret	 16			; 00000010H
_RotScaleVQ2@16 ENDP
_TEXT	ENDS
PUBLIC	__real@3f800000
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _DeRotScaleVQ2@16
_TEXT	SEGMENT
_fScale$ = -8
_pfRSVec$ = -4
_pfIn$ = 8
_pfRSMatrix$ = 12
_iIndex$ = 16
_pfOut$ = 20
_DeRotScaleVQ2@16 PROC NEAR				; COMDAT

; 484  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 485  :   float fScale;
; 486  :   const float *pfRSVec = &(pfRSMatrix[iIndex<<1]);

  00006	8b 45 10	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00009	d1 e0		 shl	 eax, 1
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _pfRSMatrix$[ebp]
  0000e	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00011	89 55 fc	 mov	 DWORD PTR _pfRSVec$[ebp], edx

; 487  : 
; 488  :   assert((pfIn != NULL) && (pfRSMatrix != NULL) && (pfOut != NULL));

  00014	83 7d 08 00	 cmp	 DWORD PTR _pfIn$[ebp], 0
  00018	74 0c		 je	 SHORT $L1217
  0001a	83 7d 0c 00	 cmp	 DWORD PTR _pfRSMatrix$[ebp], 0
  0001e	74 06		 je	 SHORT $L1217
  00020	83 7d 14 00	 cmp	 DWORD PTR _pfOut$[ebp], 0
  00024	75 17		 jne	 SHORT $L1218
$L1217:
  00026	68 e8 01 00 00	 push	 488			; 000001e8H
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  00030	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@KOCBFNCO@?$CIpfIn?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRSMatrix?5?$CB?$DN@
  00035	e8 00 00 00 00	 call	 __assert
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1218:

; 489  : 
; 490  :   fScale = pfRSVec[0]*pfRSVec[0] + pfRSVec[1]*pfRSVec[1];

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _pfRSVec$[ebp]
  00040	8b 55 fc	 mov	 edx, DWORD PTR _pfRSVec$[ebp]
  00043	d9 01		 fld	 DWORD PTR [ecx]
  00045	d8 0a		 fmul	 DWORD PTR [edx]
  00047	8b 45 fc	 mov	 eax, DWORD PTR _pfRSVec$[ebp]
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _pfRSVec$[ebp]
  0004d	d9 40 04	 fld	 DWORD PTR [eax+4]
  00050	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  00053	de c1		 faddp	 ST(1), ST(0)
  00055	d9 5d f8	 fstp	 DWORD PTR _fScale$[ebp]

; 491  :   fScale = 1.0F / fScale;

  00058	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  0005e	d8 75 f8	 fdiv	 DWORD PTR _fScale$[ebp]
  00061	d9 5d f8	 fstp	 DWORD PTR _fScale$[ebp]

; 492  :     
; 493  :   pfOut[0] = fScale * (pfIn[0]*pfRSVec[0] - pfIn[1]*pfRSVec[1]);

  00064	8b 55 08	 mov	 edx, DWORD PTR _pfIn$[ebp]
  00067	8b 45 fc	 mov	 eax, DWORD PTR _pfRSVec$[ebp]
  0006a	d9 02		 fld	 DWORD PTR [edx]
  0006c	d8 08		 fmul	 DWORD PTR [eax]
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _pfIn$[ebp]
  00071	8b 55 fc	 mov	 edx, DWORD PTR _pfRSVec$[ebp]
  00074	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00077	d8 4a 04	 fmul	 DWORD PTR [edx+4]
  0007a	de e9		 fsubp	 ST(1), ST(0)
  0007c	d8 4d f8	 fmul	 DWORD PTR _fScale$[ebp]
  0007f	8b 45 14	 mov	 eax, DWORD PTR _pfOut$[ebp]
  00082	d9 18		 fstp	 DWORD PTR [eax]

; 494  :   pfOut[1] = fScale * (pfIn[1]*pfRSVec[0] + pfIn[0]*pfRSVec[1]);

  00084	8b 4d 08	 mov	 ecx, DWORD PTR _pfIn$[ebp]
  00087	8b 55 fc	 mov	 edx, DWORD PTR _pfRSVec$[ebp]
  0008a	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0008d	d8 0a		 fmul	 DWORD PTR [edx]
  0008f	8b 45 08	 mov	 eax, DWORD PTR _pfIn$[ebp]
  00092	8b 4d fc	 mov	 ecx, DWORD PTR _pfRSVec$[ebp]
  00095	d9 00		 fld	 DWORD PTR [eax]
  00097	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  0009a	de c1		 faddp	 ST(1), ST(0)
  0009c	d8 4d f8	 fmul	 DWORD PTR _fScale$[ebp]
  0009f	8b 55 14	 mov	 edx, DWORD PTR _pfOut$[ebp]
  000a2	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 495  : }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 10 00	 ret	 16			; 00000010H
_DeRotScaleVQ2@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@EFDBGEBJ@piIndexOfOutCell?5?$CB?$DN?5NULL?$AA@ ; `string'
;	COMDAT ??_C@_0BJ@EFDBGEBJ@piIndexOfOutCell?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BJ@EFDBGEBJ@piIndexOfOutCell?5?$CB?$DN?5NULL?$AA@ DB 'piIndexOfOut'
	DB	'Cell != NULL', 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _SelectOutCellCB@12
_TEXT	SEGMENT
_flag$ = -8
_i$ = -4
_piIndexOfOutCell$ = 8
_iNumOfOutCell$ = 12
_iIndex$ = 16
_SelectOutCellCB@12 PROC NEAR				; COMDAT

; 521  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 522  :   int flag = 0;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _flag$[ebp], 0

; 523  :   int i;
; 524  : 
; 525  :   assert(piIndexOfOutCell != NULL);

  0000d	83 7d 08 00	 cmp	 DWORD PTR _piIndexOfOutCell$[ebp], 0
  00011	75 17		 jne	 SHORT $L1224
  00013	68 0d 02 00 00	 push	 525			; 0000020dH
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@EFDBGEBJ@piIndexOfOutCell?5?$CB?$DN?5NULL?$AA@
  00022	e8 00 00 00 00	 call	 __assert
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1224:

; 526  : 
; 527  :   for(i=0; i<iNumOfOutCell; i++)

  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00031	eb 09		 jmp	 SHORT $L1143
$L1144:
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00036	83 c1 01	 add	 ecx, 1
  00039	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L1143:
  0003c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003f	3b 55 0c	 cmp	 edx, DWORD PTR _iNumOfOutCell$[ebp]
  00042	7d 19		 jge	 SHORT $L1145

; 528  :     {
; 529  :       if (piIndexOfOutCell[i] == iIndex)

  00044	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _piIndexOfOutCell$[ebp]
  0004a	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0004d	3b 55 10	 cmp	 edx, DWORD PTR _iIndex$[ebp]
  00050	75 09		 jne	 SHORT $L1146

; 530  :         {
; 531  :           flag = 1;

  00052	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _flag$[ebp], 1

; 532  :           break;

  00059	eb 02		 jmp	 SHORT $L1145
$L1146:

; 533  :         }
; 534  :     }

  0005b	eb d6		 jmp	 SHORT $L1144
$L1145:

; 535  : 
; 536  :   return flag;

  0005d	8b 45 f8	 mov	 eax, DWORD PTR _flag$[ebp]

; 537  : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 0c 00	 ret	 12			; 0000000cH
_SelectOutCellCB@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@NAOCIKDL@?$CIpfIn?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRef?5?$CB?$DN?5NULL@ ; `string'
;	COMDAT ??_C@_0CC@NAOCIKDL@?$CIpfIn?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRef?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0CC@NAOCIKDL@?$CIpfIn?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRef?5?$CB?$DN?5NULL@ DB '('
	DB	'pfIn != NULL) && (pfRef != NULL)', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _CompDistVQ2@8
_TEXT	SEGMENT
_fDis$ = -8
_fErr$ = -4
_pfIn$ = 8
_pfRef$ = 12
_CompDistVQ2@8 PROC NEAR				; COMDAT

; 558  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 559  :   float fErr;
; 560  :   float fDis;
; 561  : 
; 562  :   assert((pfIn != NULL) && (pfRef != NULL));

  00006	83 7d 08 00	 cmp	 DWORD PTR _pfIn$[ebp], 0
  0000a	74 06		 je	 SHORT $L1228
  0000c	83 7d 0c 00	 cmp	 DWORD PTR _pfRef$[ebp], 0
  00010	75 17		 jne	 SHORT $L1229
$L1228:
  00012	68 32 02 00 00	 push	 562			; 00000232H
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@DCAAKGPD@c?3?2xbox?2private?2windows?2directx?2@
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@NAOCIKDL@?$CIpfIn?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfRef?5?$CB?$DN?5NULL@
  00021	e8 00 00 00 00	 call	 __assert
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1229:

; 563  : 
; 564  :   fErr = pfIn[0] - pfRef[0];

  00029	8b 4d 08	 mov	 ecx, DWORD PTR _pfIn$[ebp]
  0002c	8b 55 0c	 mov	 edx, DWORD PTR _pfRef$[ebp]
  0002f	d9 01		 fld	 DWORD PTR [ecx]
  00031	d8 22		 fsub	 DWORD PTR [edx]
  00033	d9 55 fc	 fst	 DWORD PTR _fErr$[ebp]

; 565  :   fDis = fErr*fErr;

  00036	d8 4d fc	 fmul	 DWORD PTR _fErr$[ebp]
  00039	d9 5d f8	 fstp	 DWORD PTR _fDis$[ebp]

; 566  : 
; 567  :   fErr = pfIn[1] - pfRef[1];

  0003c	8b 45 08	 mov	 eax, DWORD PTR _pfIn$[ebp]
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _pfRef$[ebp]
  00042	d9 40 04	 fld	 DWORD PTR [eax+4]
  00045	d8 61 04	 fsub	 DWORD PTR [ecx+4]
  00048	d9 55 fc	 fst	 DWORD PTR _fErr$[ebp]

; 568  :   fDis += fErr*fErr;

  0004b	d8 4d fc	 fmul	 DWORD PTR _fErr$[ebp]
  0004e	d8 45 f8	 fadd	 DWORD PTR _fDis$[ebp]
  00051	d9 55 f8	 fst	 DWORD PTR _fDis$[ebp]

; 569  : 
; 570  :   return fDis;
; 571  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
_CompDistVQ2@8 ENDP
_TEXT	ENDS
END
