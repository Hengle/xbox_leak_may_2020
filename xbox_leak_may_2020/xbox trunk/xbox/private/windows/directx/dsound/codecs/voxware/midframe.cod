; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\midframe.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _MidFrameParam@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _MidFramePv@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GetWindowedSpeech@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _MidFramePhases@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	__real@3f000000
PUBLIC	_MidFrameParam@24
EXTRN	__fltused:NEAR
EXTRN	_MidEstPitch@16:NEAR
EXTRN	_TDPitchRefine@20:NEAR
;	COMDAT __real@3f000000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\midframe.c
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _MidFrameParam@24
_TEXT	SEGMENT
_pParamMblk$ = -1076
_fCoarsePitchPeriod$ = -1072
_fCorrCostMid$ = -1068
_fSpBuf$ = -1064
_iLength$ = -16
_pSubParam_End$ = -12
_pSubParam_Mid$ = -8
_pEncMemBlk$ = -4
_hEncMemBlk$ = 8
_hParamMblk$ = 12
_iCodecDelay$ = 16
_iSCRate$ = 20
_Cost1$ = 24
_vfFlag$ = 28
_MidFrameParam@24 PROC NEAR				; COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 04 00
	00		 sub	 esp, 1076		; 00000434H

; 65   :   ENC_MEM_BLK *pEncMemBlk = (ENC_MEM_BLK *)hEncMemBlk;

  00009	8b 45 08	 mov	 eax, DWORD PTR _hEncMemBlk$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _pEncMemBlk$[ebp], eax

; 66   :   PARAM_SC *pParamMblk    = (PARAM_SC *)hParamMblk;

  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _hParamMblk$[ebp]
  00012	89 8d cc fb ff
	ff		 mov	 DWORD PTR _pParamMblk$[ebp], ecx

; 67   : 
; 68   :   int   iLength;
; 69   :   float fCoarsePitchPeriod;
; 70   :   float fCorrCostMid;
; 71   :   SUBFRAME_PARAM_SC *pSubParam_Mid, *pSubParam_End;
; 72   :   
; 73   :   STACK_INIT
; 74   :   float fSpBuf[PDA_FRAME_SIZE1];
; 75   :   STACK_INIT_END
; 76   :  
; 77   :   STACK_ATTACH(float *, fSpBuf)
; 78   : 
; 79   :   STACK_START
; 80   : 
; 81   :   pSubParam_Mid = &(pParamMblk->SubParam[PARAM_MIDFRAME]);

  00018	8b 95 cc fb ff
	ff		 mov	 edx, DWORD PTR _pParamMblk$[ebp]
  0001e	89 55 f8	 mov	 DWORD PTR _pSubParam_Mid$[ebp], edx

; 82   :   pSubParam_End = &(pParamMblk->SubParam[PARAM_ENDFRAME]);

  00021	8b 85 cc fb ff
	ff		 mov	 eax, DWORD PTR _pParamMblk$[ebp]
  00027	83 c0 28	 add	 eax, 40			; 00000028H
  0002a	89 45 f4	 mov	 DWORD PTR _pSubParam_End$[ebp], eax

; 83   : 
; 84   :   /*-----------------------------------------------------------------------
; 85   :     Interpolate for a coarse estimate of the mid-frame pitch
; 86   :   -----------------------------------------------------------------------*/
; 87   :   fCoarsePitchPeriod = MidEstPitch( pEncMemBlk->uq_Pitch_1, 
; 88   :                                     pSubParam_End->Pitch,
; 89   :                                     pEncMemBlk->uq_Pv_1, 
; 90   :                                     pSubParam_End->Pv);

  0002d	8b 4d f4	 mov	 ecx, DWORD PTR _pSubParam_End$[ebp]
  00030	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00033	52		 push	 edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  00037	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0003a	51		 push	 ecx
  0003b	8b 55 f4	 mov	 edx, DWORD PTR _pSubParam_End$[ebp]
  0003e	8b 02		 mov	 eax, DWORD PTR [edx]
  00040	50		 push	 eax
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  00044	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 _MidEstPitch@16
  0004d	d9 9d d0 fb ff
	ff		 fstp	 DWORD PTR _fCoarsePitchPeriod$[ebp]

; 91   :   
; 92   :   /*-----------------------------------------------------------------------
; 93   :     If this is vocal fry, then the pitch has been modified and we want to
; 94   :       undo this.
; 95   :   -----------------------------------------------------------------------*/
; 96   :   if (vfFlag == 1) 

  00053	83 7d 1c 01	 cmp	 DWORD PTR _vfFlag$[ebp], 1
  00057	75 0e		 jne	 SHORT $L973

; 97   :     fCoarsePitchPeriod *= 2.0F;

  00059	d9 85 d0 fb ff
	ff		 fld	 DWORD PTR _fCoarsePitchPeriod$[ebp]
  0005f	dc c0		 fadd	 ST(0), ST(0)
  00061	d9 9d d0 fb ff
	ff		 fstp	 DWORD PTR _fCoarsePitchPeriod$[ebp]
$L973:

; 98   : 
; 99   :   /*-----------------------------------------------------------------------
; 100  :     Get windowed mikd-frame speech
; 101  :   -----------------------------------------------------------------------*/
; 102  :   GetWindowedSpeech( fCoarsePitchPeriod, pEncMemBlk->CircBuf_mblk, fSpBuf, 
; 103  :                      &iLength, iCodecDelay);

  00067	8b 45 10	 mov	 eax, DWORD PTR _iCodecDelay$[ebp]
  0006a	50		 push	 eax
  0006b	8d 4d f0	 lea	 ecx, DWORD PTR _iLength$[ebp]
  0006e	51		 push	 ecx
  0006f	8d 95 d8 fb ff
	ff		 lea	 edx, DWORD PTR _fSpBuf$[ebp]
  00075	52		 push	 edx
  00076	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  00079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007b	51		 push	 ecx
  0007c	8b 95 d0 fb ff
	ff		 mov	 edx, DWORD PTR _fCoarsePitchPeriod$[ebp]
  00082	52		 push	 edx
  00083	e8 00 00 00 00	 call	 _GetWindowedSpeech@20

; 104  : 
; 105  :   /*-----------------------------------------------------------------------
; 106  :     Refine the pitch using autocorrelation calculation.
; 107  :   -----------------------------------------------------------------------*/
; 108  :   pSubParam_Mid->Pitch = TDPitchRefine( fSpBuf, (short)iLength,
; 109  :                                         fCoarsePitchPeriod, 
; 110  :                                         &fCorrCostMid, 0.1F);

  00088	68 cd cc cc 3d	 push	 1036831949		; 3dcccccdH
  0008d	8d 85 d4 fb ff
	ff		 lea	 eax, DWORD PTR _fCorrCostMid$[ebp]
  00093	50		 push	 eax
  00094	8b 8d d0 fb ff
	ff		 mov	 ecx, DWORD PTR _fCoarsePitchPeriod$[ebp]
  0009a	51		 push	 ecx
  0009b	66 8b 55 f0	 mov	 dx, WORD PTR _iLength$[ebp]
  0009f	52		 push	 edx
  000a0	8d 85 d8 fb ff
	ff		 lea	 eax, DWORD PTR _fSpBuf$[ebp]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 _TDPitchRefine@20
  000ac	8b 4d f8	 mov	 ecx, DWORD PTR _pSubParam_Mid$[ebp]
  000af	d9 19		 fstp	 DWORD PTR [ecx]

; 111  : 
; 112  : 
; 113  :   /*-----------------------------------------------------------------------
; 114  :     If this is vocal fry, the reapply the vocal fry pitch period halving
; 115  :   -----------------------------------------------------------------------*/
; 116  :   if (vfFlag == 1) 

  000b1	83 7d 1c 01	 cmp	 DWORD PTR _vfFlag$[ebp], 1
  000b5	75 10		 jne	 SHORT $L975

; 117  :     pSubParam_Mid->Pitch *= 0.5F;

  000b7	8b 55 f8	 mov	 edx, DWORD PTR _pSubParam_Mid$[ebp]
  000ba	d9 02		 fld	 DWORD PTR [edx]
  000bc	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  000c2	8b 45 f8	 mov	 eax, DWORD PTR _pSubParam_Mid$[ebp]
  000c5	d9 18		 fstp	 DWORD PTR [eax]
$L975:

; 118  : 
; 119  :   /*-----------------------------------------------------------------------
; 120  :     If encoding SC6, compute the mid-frame measured phases with a DFT.
; 121  :   -----------------------------------------------------------------------*/
; 122  :   if (iSCRate==SC_RATE_6K) 

  000c7	83 7d 14 02	 cmp	 DWORD PTR _iSCRate$[ebp], 2
  000cb	75 1d		 jne	 SHORT $L976

; 123  :     MidFramePhases( STACK_S fSpBuf, iLength, pSubParam_Mid->Pitch,
; 124  :                     pSubParam_Mid->pfVEVphase);

  000cd	8b 4d f8	 mov	 ecx, DWORD PTR _pSubParam_Mid$[ebp]
  000d0	83 c1 08	 add	 ecx, 8
  000d3	51		 push	 ecx
  000d4	8b 55 f8	 mov	 edx, DWORD PTR _pSubParam_Mid$[ebp]
  000d7	8b 02		 mov	 eax, DWORD PTR [edx]
  000d9	50		 push	 eax
  000da	8b 4d f0	 mov	 ecx, DWORD PTR _iLength$[ebp]
  000dd	51		 push	 ecx
  000de	8d 95 d8 fb ff
	ff		 lea	 edx, DWORD PTR _fSpBuf$[ebp]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 _MidFramePhases@16
$L976:

; 125  : 
; 126  :   /*-----------------------------------------------------------------------
; 127  :     Compute mid-frame voicing probability.
; 128  :   -----------------------------------------------------------------------*/
; 129  :   pSubParam_Mid->Pv = MidFramePv( pEncMemBlk->uq_Pv_1, 
; 130  :                                   pSubParam_End->Pv,
; 131  :                                   Cost1, fCorrCostMid, 
; 132  :                                   &(pEncMemBlk->lastCorrCost));

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  000ed	83 c0 1c	 add	 eax, 28			; 0000001cH
  000f0	50		 push	 eax
  000f1	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _fCorrCostMid$[ebp]
  000f7	51		 push	 ecx
  000f8	8b 55 18	 mov	 edx, DWORD PTR _Cost1$[ebp]
  000fb	52		 push	 edx
  000fc	8b 45 f4	 mov	 eax, DWORD PTR _pSubParam_End$[ebp]
  000ff	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00102	51		 push	 ecx
  00103	8b 55 fc	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  00106	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 _MidFramePv@20
  0010f	8b 4d f8	 mov	 ecx, DWORD PTR _pSubParam_Mid$[ebp]
  00112	d9 59 04	 fstp	 DWORD PTR [ecx+4]

; 133  : 
; 134  :   STACK_END
; 135  : 
; 136  : }

  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c2 18 00	 ret	 24			; 00000018H
_MidFrameParam@24 ENDP
_TEXT	ENDS
PUBLIC	__real@3dcccccd
PUBLIC	__real@3fc3333340000000
PUBLIC	__real@3eb33333
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
EXTRN	_fabs:NEAR
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3fc3333340000000
CONST	SEGMENT
__real@3fc3333340000000 DQ 03fc3333340000000r	; 0.15
CONST	ENDS
;	COMDAT __real@3eb33333
CONST	SEGMENT
__real@3eb33333 DD 03eb33333r			; 0.35
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _MidFramePv@20
_TEXT	SEGMENT
_Pv$ = -4
_Pv_1$ = 8
_Pv1$ = 12
_Cost1$ = 16
_Cost0$ = 20
_Cost_1$ = 24
_MidFramePv@20 PROC NEAR				; COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 149  :   float Pv;
; 150  :   
; 151  : 
; 152  :   /******************************************************************
; 153  :     calculate the cost value of end-frame.
; 154  :     *****************************************************************/
; 155  :   /********* Make the decision. ***********/
; 156  :   if (*Cost_1 < 0.1F)    *Cost_1 = 0.1F;

  00004	8b 45 18	 mov	 eax, DWORD PTR _Cost_1$[ebp]
  00007	d9 00		 fld	 DWORD PTR [eax]
  00009	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3dcccccd
  0000f	df e0		 fnstsw	 ax
  00011	f6 c4 05	 test	 ah, 5
  00014	7a 09		 jp	 SHORT $L989
  00016	8b 4d 18	 mov	 ecx, DWORD PTR _Cost_1$[ebp]
  00019	c7 01 cd cc cc
	3d		 mov	 DWORD PTR [ecx], 1036831949 ; 3dcccccdH
$L989:

; 157  :   if (Cost1 < 0.1F)       Cost1 = 0.1F;

  0001f	d9 45 10	 fld	 DWORD PTR _Cost1$[ebp]
  00022	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3dcccccd
  00028	df e0		 fnstsw	 ax
  0002a	f6 c4 05	 test	 ah, 5
  0002d	7a 07		 jp	 SHORT $L990
  0002f	c7 45 10 cd cc
	cc 3d		 mov	 DWORD PTR _Cost1$[ebp], 1036831949 ; 3dcccccdH
$L990:

; 158  : 
; 159  :   if (fabs(Pv1 - Pv_1) < 0.15F)

  00036	d9 45 0c	 fld	 DWORD PTR _Pv1$[ebp]
  00039	d8 65 08	 fsub	 DWORD PTR _Pv_1$[ebp]
  0003c	83 ec 08	 sub	 esp, 8
  0003f	dd 1c 24	 fstp	 QWORD PTR [esp]
  00042	e8 00 00 00 00	 call	 _fabs
  00047	83 c4 08	 add	 esp, 8
  0004a	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3fc3333340000000
  00050	df e0		 fnstsw	 ax
  00052	f6 c4 05	 test	 ah, 5
  00055	7a 11		 jp	 SHORT $L991

; 160  :     Pv = 0.5F*(Pv1+Pv_1);

  00057	d9 45 0c	 fld	 DWORD PTR _Pv1$[ebp]
  0005a	d8 45 08	 fadd	 DWORD PTR _Pv_1$[ebp]
  0005d	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00063	d9 5d fc	 fstp	 DWORD PTR _Pv$[ebp]

; 161  :   else 

  00066	eb 64		 jmp	 SHORT $L992
$L991:

; 162  :   {
; 163  :     if (Cost0 < 0.35F)     /* noise-like */

  00068	d9 45 14	 fld	 DWORD PTR _Cost0$[ebp]
  0006b	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3eb33333
  00071	df e0		 fnstsw	 ax
  00073	f6 c4 05	 test	 ah, 5
  00076	7a 2b		 jp	 SHORT $L993

; 164  :     {
; 165  :       if (Pv1 > Pv_1) 

  00078	d9 45 0c	 fld	 DWORD PTR _Pv1$[ebp]
  0007b	d8 5d 08	 fcomp	 DWORD PTR _Pv_1$[ebp]
  0007e	df e0		 fnstsw	 ax
  00080	f6 c4 41	 test	 ah, 65			; 00000041H
  00083	75 10		 jne	 SHORT $L994

; 166  :         Pv = Pv_1 * Cost0 / *Cost_1;

  00085	d9 45 08	 fld	 DWORD PTR _Pv_1$[ebp]
  00088	d8 4d 14	 fmul	 DWORD PTR _Cost0$[ebp]
  0008b	8b 55 18	 mov	 edx, DWORD PTR _Cost_1$[ebp]
  0008e	d8 32		 fdiv	 DWORD PTR [edx]
  00090	d9 5d fc	 fstp	 DWORD PTR _Pv$[ebp]

; 167  :       else

  00093	eb 0c		 jmp	 SHORT $L995
$L994:

; 168  :         Pv = Pv1 * Cost0 / Cost1;

  00095	d9 45 0c	 fld	 DWORD PTR _Pv1$[ebp]
  00098	d8 4d 14	 fmul	 DWORD PTR _Cost0$[ebp]
  0009b	d8 75 10	 fdiv	 DWORD PTR _Cost1$[ebp]
  0009e	d9 5d fc	 fstp	 DWORD PTR _Pv$[ebp]
$L995:

; 169  :     } else {

  000a1	eb 29		 jmp	 SHORT $L992
$L993:

; 170  :       if (Pv1 > Pv_1) 

  000a3	d9 45 0c	 fld	 DWORD PTR _Pv1$[ebp]
  000a6	d8 5d 08	 fcomp	 DWORD PTR _Pv_1$[ebp]
  000a9	df e0		 fnstsw	 ax
  000ab	f6 c4 41	 test	 ah, 65			; 00000041H
  000ae	75 0e		 jne	 SHORT $L997

; 171  :         Pv = Pv1 * Cost0 / Cost1;

  000b0	d9 45 0c	 fld	 DWORD PTR _Pv1$[ebp]
  000b3	d8 4d 14	 fmul	 DWORD PTR _Cost0$[ebp]
  000b6	d8 75 10	 fdiv	 DWORD PTR _Cost1$[ebp]
  000b9	d9 5d fc	 fstp	 DWORD PTR _Pv$[ebp]

; 172  :       else

  000bc	eb 0e		 jmp	 SHORT $L992
$L997:

; 173  :         Pv = Pv_1 * Cost0 / *Cost_1;

  000be	d9 45 08	 fld	 DWORD PTR _Pv_1$[ebp]
  000c1	d8 4d 14	 fmul	 DWORD PTR _Cost0$[ebp]
  000c4	8b 45 18	 mov	 eax, DWORD PTR _Cost_1$[ebp]
  000c7	d8 30		 fdiv	 DWORD PTR [eax]
  000c9	d9 5d fc	 fstp	 DWORD PTR _Pv$[ebp]
$L992:

; 174  :     }
; 175  :   }
; 176  : 
; 177  :   if (Pv < 0)    

  000cc	d9 45 fc	 fld	 DWORD PTR _Pv$[ebp]
  000cf	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  000d5	df e0		 fnstsw	 ax
  000d7	f6 c4 05	 test	 ah, 5
  000da	7a 07		 jp	 SHORT $L999

; 178  :      Pv = 0.0F;

  000dc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Pv$[ebp], 0
$L999:

; 179  :   if (Pv > 1)    

  000e3	d9 45 fc	 fld	 DWORD PTR _Pv$[ebp]
  000e6	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f800000
  000ec	df e0		 fnstsw	 ax
  000ee	f6 c4 41	 test	 ah, 65			; 00000041H
  000f1	75 07		 jne	 SHORT $L1000

; 180  :      Pv = 1.0F;

  000f3	c7 45 fc 00 00
	80 3f		 mov	 DWORD PTR _Pv$[ebp], 1065353216 ; 3f800000H
$L1000:

; 181  : 
; 182  :   /******* Replace last frame's cost value with this frame's one. ******/
; 183  :   *Cost_1 = Cost1;

  000fa	8b 4d 18	 mov	 ecx, DWORD PTR _Cost_1$[ebp]
  000fd	8b 55 10	 mov	 edx, DWORD PTR _Cost1$[ebp]
  00100	89 11		 mov	 DWORD PTR [ecx], edx

; 184  : 
; 185  :   return Pv;

  00102	d9 45 fc	 fld	 DWORD PTR _Pv$[ebp]

; 186  : }

  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c2 14 00	 ret	 20			; 00000014H
_MidFramePv@20 ENDP
_TEXT	ENDS
EXTRN	_GetFrameSpCBM@16:NEAR
EXTRN	_HammingWindowNormSC@8:NEAR
EXTRN	_VoxAdaptiveWindow@4:NEAR
; Function compile flags: /Odt
;	COMDAT _GetWindowedSpeech@20
_TEXT	SEGMENT
_fPitch$ = 8
_hCircBufBlk$ = 12
_pfSpBuf$ = 16
_piLength$ = 20
_iDelay$ = 24
_GetWindowedSpeech@20 PROC NEAR				; COMDAT

; 196  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  :   /****** Get the window length and window the signal ******/
; 198  :   *piLength = VoxAdaptiveWindow( fPitch );

  00003	8b 45 08	 mov	 eax, DWORD PTR _fPitch$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _VoxAdaptiveWindow@4
  0000c	8b 4d 14	 mov	 ecx, DWORD PTR _piLength$[ebp]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax

; 199  : 
; 200  :   /**** Take the middle frame speech out ****/
; 201  :   GetFrameSpCBM( hCircBufBlk, iDelay, *piLength, pfSpBuf );

  00011	8b 55 10	 mov	 edx, DWORD PTR _pfSpBuf$[ebp]
  00014	52		 push	 edx
  00015	8b 45 14	 mov	 eax, DWORD PTR _piLength$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	51		 push	 ecx
  0001b	8b 55 18	 mov	 edx, DWORD PTR _iDelay$[ebp]
  0001e	52		 push	 edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR _hCircBufBlk$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _GetFrameSpCBM@16

; 202  : 
; 203  :   /**** window the speech signal ****/
; 204  :   HammingWindowNormSC( pfSpBuf, *piLength );

  00028	8b 4d 14	 mov	 ecx, DWORD PTR _piLength$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	52		 push	 edx
  0002e	8b 45 10	 mov	 eax, DWORD PTR _pfSpBuf$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _HammingWindowNormSC@8

; 205  : }

  00037	5d		 pop	 ebp
  00038	c2 14 00	 ret	 20			; 00000014H
_GetWindowedSpeech@20 ENDP
_TEXT	ENDS
PUBLIC	__real@40c90fdb
EXTRN	_atan2:NEAR
EXTRN	_VoxDFT@24:NEAR
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _MidFramePhases@16
_TEXT	SEGMENT
tv132 = -80
_fSTFTphase$ = -76
_fRadianPitch$ = -72
_SWI$ = -68
_i$ = -36
_SWR$ = -32
_SpBuf$ = 8
_iLength$ = 12
_fPitch$ = 16
_pfPhases$ = 20
_MidFramePhases@16 PROC NEAR				; COMDAT

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H

; 218  :   int   i;
; 219  :   float fSTFTphase;
; 220  :   float fRadianPitch;
; 221  : 
; 222  : STACK_INIT
; 223  :   float SWR[SC6_PHASES];
; 224  :   float SWI[SC6_PHASES];
; 225  : STACK_INIT_END
; 226  : 
; 227  : STACK_ATTACH(float *, SWR)
; 228  : STACK_ATTACH(float *, SWI)
; 229  : 
; 230  : STACK_START
; 231  : 
; 232  :   /*---------------------------------------------------------------
; 233  :     Compute the pitch in radians
; 234  :   ---------------------------------------------------------------*/
; 235  :   fRadianPitch = TWOPI/fPitch;

  00006	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40c90fdb
  0000c	d8 75 10	 fdiv	 DWORD PTR _fPitch$[ebp]
  0000f	d9 5d b8	 fstp	 DWORD PTR _fRadianPitch$[ebp]

; 236  : 
; 237  :   /*---------------------------------------------------------------
; 238  :     Calculate the DFT at the pitch harmonics. (NOTE: It is possible
; 239  :       that fRadianPitch*SC6_PHASES is greater than PI.  If this 
; 240  :       happens we are computing the DFT at frequencies beyond the 
; 241  :       Nyquist rate.  This is okay, because the DFT will just
; 242  :       return the aliased values and they will not be used by 
; 243  :       the decoder.  The other alternative is to compute the number
; 244  :       of harmonics, but that increases code size.)
; 245  :   ---------------------------------------------------------------*/
; 246  :   VoxDFT(SpBuf, iLength, fRadianPitch, SC6_PHASES, SWR, SWI);

  00012	8d 45 bc	 lea	 eax, DWORD PTR _SWI$[ebp]
  00015	50		 push	 eax
  00016	8d 4d e0	 lea	 ecx, DWORD PTR _SWR$[ebp]
  00019	51		 push	 ecx
  0001a	6a 08		 push	 8
  0001c	8b 55 b8	 mov	 edx, DWORD PTR _fRadianPitch$[ebp]
  0001f	52		 push	 edx
  00020	8b 45 0c	 mov	 eax, DWORD PTR _iLength$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _SpBuf$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _VoxDFT@24

; 247  : 
; 248  :   /*---------------------------------------------------------------
; 249  :     Calculate the phases
; 250  :   ---------------------------------------------------------------*/
; 251  :   for (i = 0; i < SC6_PHASES; i++) 

  0002d	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00034	eb 09		 jmp	 SHORT $L1026
$L1027:
  00036	8b 55 dc	 mov	 edx, DWORD PTR _i$[ebp]
  00039	83 c2 01	 add	 edx, 1
  0003c	89 55 dc	 mov	 DWORD PTR _i$[ebp], edx
$L1026:
  0003f	83 7d dc 08	 cmp	 DWORD PTR _i$[ebp], 8
  00043	7d 4f		 jge	 SHORT $L1020

; 252  :   {
; 253  :     fSTFTphase = VoxATAN2(SWI[i], SWR[i]);

  00045	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  00048	d9 44 85 e0	 fld	 DWORD PTR _SWR$[ebp+eax*4]
  0004c	83 ec 08	 sub	 esp, 8
  0004f	dd 1c 24	 fstp	 QWORD PTR [esp]
  00052	8b 4d dc	 mov	 ecx, DWORD PTR _i$[ebp]
  00055	d9 44 8d bc	 fld	 DWORD PTR _SWI$[ebp+ecx*4]
  00059	83 ec 08	 sub	 esp, 8
  0005c	dd 1c 24	 fstp	 QWORD PTR [esp]
  0005f	e8 00 00 00 00	 call	 _atan2
  00064	83 c4 10	 add	 esp, 16			; 00000010H
  00067	d9 55 b0	 fst	 DWORD PTR tv132[ebp]
  0006a	d9 55 b4	 fst	 DWORD PTR _fSTFTphase$[ebp]

; 254  :     if (fSTFTphase < 0.0F)

  0006d	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00073	df e0		 fnstsw	 ax
  00075	f6 c4 05	 test	 ah, 5
  00078	7a 0c		 jp	 SHORT $L1030

; 255  :       fSTFTphase += TWOPI;

  0007a	d9 45 b4	 fld	 DWORD PTR _fSTFTphase$[ebp]
  0007d	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@40c90fdb
  00083	d9 5d b4	 fstp	 DWORD PTR _fSTFTphase$[ebp]
$L1030:

; 256  :     pfPhases[i] = fSTFTphase;

  00086	8b 55 dc	 mov	 edx, DWORD PTR _i$[ebp]
  00089	8b 45 14	 mov	 eax, DWORD PTR _pfPhases$[ebp]
  0008c	8b 4d b4	 mov	 ecx, DWORD PTR _fSTFTphase$[ebp]
  0008f	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 257  :   }

  00092	eb a2		 jmp	 SHORT $L1027
$L1020:

; 258  : 
; 259  : STACK_END
; 260  : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 10 00	 ret	 16			; 00000010H
_MidFramePhases@16 ENDP
_TEXT	ENDS
END
