; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\msaudio.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
WMADEC_RW	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RW	ENDS
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _RandStateClear@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _LOG2@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT @ROUNDF@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT @ByteSwap@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _FloatToLong@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _msaudioGetSamplePerFrame_XDS@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _MaxSamplesPerPacket_XDS@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _mallocAligned_XDS@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _freeAligned_XDS@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auMallocGetCount_XDS@0
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auMallocSetState_XDS@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auMalloc_XDS@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auFree_XDS@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auNew_XDS@0
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auDelete_XDS@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auInit_XDS@36
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvAllocate_XDS@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvSetBarkIndex_XDS@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auPreGetPCM_XDS@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auReconstruct_XDS@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auGetPCM_XDS@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auReconMono_XDS@20
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auAdaptToSubFrameConfig_XDS@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auUpdateMaxEsc_XDS@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _qstCalcQuantStep_XDS@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvWeightedQuantization_XDS@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auReconCoefficentsHighRate_XDS@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvInitDiscardSilence_XDS@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvDiscardSilence_XDS@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _SetActualPower_XDS@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _SetActualPowerHighRate_XDS@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, WMADEC_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_DSoundBuildNumberD
WMADEC_RD	SEGMENT
_WMA_OK	DD	00H
_WMA_S_FALSE DD	01H
_WMA_S_BUFUNDERFLOW DD 02H
_WMA_S_NEWPACKET DD 03H
_WMA_S_NO_MORE_FRAME DD 04H
_WMA_S_DEFAULT DD 05H
_WMA_S_SWITCHCHMODE DD 06H
_WMA_E_FAIL DD	080004005H
_WMA_E_OUTOFMEMORY DD 08007000eH
_WMA_E_INVALIDARG DD 080070057H
_WMA_E_NOTSUPPORTED DD 080040000H
_WMA_E_LOSTPACKET DD 080040001H
_WMA_E_BROKEN_FRAME DD 080040002H
_WMA_E_BUFFEROVERFLOW DD 080040003H
_WMA_E_ONHOLD DD 080040004H
_WMA_E_BUFFERUNDERFLOW DD 080040005H
_WMA_E_INVALIDRECHDR DD 080040006H
_WMA_E_SYNCERROR DD 080040007H
_WMA_E_NOTIMPL DD 080040008H
_WMA_E_FLUSHOVERFLOW DD 080040009H
WMADEC_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT
_DSoundBuildNumberD DW 05344H
	DW	0554fH
	DW	0444eH
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
WMADEC_RD	SEGMENT
?fOKOptions@?1??auInit_XDS@@9@9 DB 01H			; `auInit_XDS'::`2'::fOKOptions
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
WMADEC_RD	ENDS
WMADEC_RW	SEGMENT
_dIorF2F DQ	03ff0000000000000r		; 1
WMADEC_RW	ENDS
PUBLIC	_msaudioGetSamplePerFrame_XDS@16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\msaudio.c
;	COMDAT _msaudioGetSamplePerFrame_XDS@16
WMADEC	SEGMENT
_cSamplePerFrame$ = -8
_dwBytesPerFrame$ = -4
_cSamplePerSec$ = 8
_dwBitPerSec$ = 12
_cNumChannels$ = 16
_iVersion$ = 20
_msaudioGetSamplePerFrame_XDS@16 PROC NEAR		; COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 65   :     //return NEW samples coming into a frame; actual samples in a frame
; 66   :     //should be * 2 due to 50% overlapping window
; 67   :     I32 cSamplePerFrame;
; 68   :     U32 dwBytesPerFrame;
; 69   : 
; 70   :         //don't know what to do
; 71   :     if (dwBitPerSec == 0 || iVersion > 2)

  00006	83 7d 0c 00	 cmp	 DWORD PTR _dwBitPerSec$[ebp], 0
  0000a	74 06		 je	 SHORT $L2538
  0000c	83 7d 14 02	 cmp	 DWORD PTR _iVersion$[ebp], 2
  00010	7e 07		 jle	 SHORT $L2537
$L2538:

; 72   :         return 0;

  00012	33 c0		 xor	 eax, eax
  00014	e9 24 01 00 00	 jmp	 $L2534
$L2537:

; 73   : 
; 74   :     if (cSamplePerSec <= 8000)

  00019	81 7d 08 40 1f
	00 00		 cmp	 DWORD PTR _cSamplePerSec$[ebp], 8000 ; 00001f40H
  00020	7f 0c		 jg	 SHORT $L2539

; 75   :         cSamplePerFrame = 512;

  00022	c7 45 f8 00 02
	00 00		 mov	 DWORD PTR _cSamplePerFrame$[ebp], 512 ; 00000200H

; 76   :     else if (cSamplePerSec <= 11025)

  00029	e9 82 00 00 00	 jmp	 $L2540
$L2539:
  0002e	81 7d 08 11 2b
	00 00		 cmp	 DWORD PTR _cSamplePerSec$[ebp], 11025 ; 00002b11H
  00035	7f 09		 jg	 SHORT $L2541

; 77   :         cSamplePerFrame = 512;

  00037	c7 45 f8 00 02
	00 00		 mov	 DWORD PTR _cSamplePerFrame$[ebp], 512 ; 00000200H

; 78   :     else if (cSamplePerSec <= 16000) {

  0003e	eb 70		 jmp	 SHORT $L2540
$L2541:
  00040	81 7d 08 80 3e
	00 00		 cmp	 DWORD PTR _cSamplePerSec$[ebp], 16000 ; 00003e80H
  00047	7f 09		 jg	 SHORT $L2543

; 79   :         cSamplePerFrame = 512;

  00049	c7 45 f8 00 02
	00 00		 mov	 DWORD PTR _cSamplePerFrame$[ebp], 512 ; 00000200H

; 80   :     }
; 81   :     else if (cSamplePerSec <= 22050) {

  00050	eb 5e		 jmp	 SHORT $L2540
$L2543:
  00052	81 7d 08 22 56
	00 00		 cmp	 DWORD PTR _cSamplePerSec$[ebp], 22050 ; 00005622H
  00059	7f 09		 jg	 SHORT $L2545

; 82   :         cSamplePerFrame = 1024;

  0005b	c7 45 f8 00 04
	00 00		 mov	 DWORD PTR _cSamplePerFrame$[ebp], 1024 ; 00000400H

; 83   :     }
; 84   :     else if (cSamplePerSec <= 32000) {

  00062	eb 4c		 jmp	 SHORT $L2540
$L2545:
  00064	81 7d 08 00 7d
	00 00		 cmp	 DWORD PTR _cSamplePerSec$[ebp], 32000 ; 00007d00H
  0006b	7f 18		 jg	 SHORT $L2547

; 85   :         if(iVersion == 1)

  0006d	83 7d 14 01	 cmp	 DWORD PTR _iVersion$[ebp], 1
  00071	75 09		 jne	 SHORT $L2548

; 86   :             cSamplePerFrame = 1024;

  00073	c7 45 f8 00 04
	00 00		 mov	 DWORD PTR _cSamplePerFrame$[ebp], 1024 ; 00000400H

; 87   :         else

  0007a	eb 07		 jmp	 SHORT $L2549
$L2548:

; 88   :             cSamplePerFrame = 2048;

  0007c	c7 45 f8 00 08
	00 00		 mov	 DWORD PTR _cSamplePerFrame$[ebp], 2048 ; 00000800H
$L2549:

; 89   :     }
; 90   :     else if (cSamplePerSec <= 44100)

  00083	eb 2b		 jmp	 SHORT $L2540
$L2547:
  00085	81 7d 08 44 ac
	00 00		 cmp	 DWORD PTR _cSamplePerSec$[ebp], 44100 ; 0000ac44H
  0008c	7f 09		 jg	 SHORT $L2551

; 91   :         cSamplePerFrame = 2048;

  0008e	c7 45 f8 00 08
	00 00		 mov	 DWORD PTR _cSamplePerFrame$[ebp], 2048 ; 00000800H

; 92   :     else if (cSamplePerSec <= 48000)

  00095	eb 19		 jmp	 SHORT $L2540
$L2551:
  00097	81 7d 08 80 bb
	00 00		 cmp	 DWORD PTR _cSamplePerSec$[ebp], 48000 ; 0000bb80H
  0009e	7f 09		 jg	 SHORT $L2553

; 93   :         cSamplePerFrame = 2048;

  000a0	c7 45 f8 00 08
	00 00		 mov	 DWORD PTR _cSamplePerFrame$[ebp], 2048 ; 00000800H

; 94   :     else

  000a7	eb 07		 jmp	 SHORT $L2540
$L2553:

; 95   :         return 0;

  000a9	33 c0		 xor	 eax, eax
  000ab	e9 8d 00 00 00	 jmp	 $L2534
$L2540:

; 96   :     dwBytesPerFrame = (U32) (((cSamplePerFrame*dwBitPerSec + cSamplePerSec/2)/cSamplePerSec + 7)/8);

  000b0	8b 4d f8	 mov	 ecx, DWORD PTR _cSamplePerFrame$[ebp]
  000b3	0f af 4d 0c	 imul	 ecx, DWORD PTR _dwBitPerSec$[ebp]
  000b7	8b 45 08	 mov	 eax, DWORD PTR _cSamplePerSec$[ebp]
  000ba	99		 cdq
  000bb	2b c2		 sub	 eax, edx
  000bd	d1 f8		 sar	 eax, 1
  000bf	03 c1		 add	 eax, ecx
  000c1	33 d2		 xor	 edx, edx
  000c3	f7 75 08	 div	 DWORD PTR _cSamplePerSec$[ebp]
  000c6	83 c0 07	 add	 eax, 7
  000c9	c1 e8 03	 shr	 eax, 3
  000cc	89 45 fc	 mov	 DWORD PTR _dwBytesPerFrame$[ebp], eax

; 97   :     if ( dwBytesPerFrame==0 && (cSamplePerFrame*dwBitPerSec) == 0 ) {

  000cf	83 7d fc 00	 cmp	 DWORD PTR _dwBytesPerFrame$[ebp], 0
  000d3	75 30		 jne	 SHORT $L2556
  000d5	8b 55 f8	 mov	 edx, DWORD PTR _cSamplePerFrame$[ebp]
  000d8	0f af 55 0c	 imul	 edx, DWORD PTR _dwBitPerSec$[ebp]
  000dc	85 d2		 test	 edx, edx
  000de	75 25		 jne	 SHORT $L2556

; 98   :         // this can happen when garbage data sets dwBitsPerSec to a very large number
; 99   :         // avoid an infinite loop below
; 100  :         dwBitPerSec = cSamplePerSec;

  000e0	8b 45 08	 mov	 eax, DWORD PTR _cSamplePerSec$[ebp]
  000e3	89 45 0c	 mov	 DWORD PTR _dwBitPerSec$[ebp], eax

; 101  :         dwBytesPerFrame = (U32) (((cSamplePerFrame*dwBitPerSec + cSamplePerSec/2)/cSamplePerSec + 7)/8);

  000e6	8b 4d f8	 mov	 ecx, DWORD PTR _cSamplePerFrame$[ebp]
  000e9	0f af 4d 0c	 imul	 ecx, DWORD PTR _dwBitPerSec$[ebp]
  000ed	8b 45 08	 mov	 eax, DWORD PTR _cSamplePerSec$[ebp]
  000f0	99		 cdq
  000f1	2b c2		 sub	 eax, edx
  000f3	d1 f8		 sar	 eax, 1
  000f5	03 c1		 add	 eax, ecx
  000f7	33 d2		 xor	 edx, edx
  000f9	f7 75 08	 div	 DWORD PTR _cSamplePerSec$[ebp]
  000fc	83 c0 07	 add	 eax, 7
  000ff	c1 e8 03	 shr	 eax, 3
  00102	89 45 fc	 mov	 DWORD PTR _dwBytesPerFrame$[ebp], eax
$L2556:

; 102  :     }
; 103  :     if (dwBytesPerFrame <= 1) {   //silence mode

  00105	83 7d fc 01	 cmp	 DWORD PTR _dwBytesPerFrame$[ebp], 1
  00109	77 2f		 ja	 SHORT $L2558
$L2560:

; 104  :         while (dwBytesPerFrame == 0) {

  0010b	83 7d fc 00	 cmp	 DWORD PTR _dwBytesPerFrame$[ebp], 0
  0010f	75 29		 jne	 SHORT $L2558

; 105  :             cSamplePerFrame *= 2;           //save more bits; quartz can't take too big a value

  00111	8b 55 f8	 mov	 edx, DWORD PTR _cSamplePerFrame$[ebp]
  00114	d1 e2		 shl	 edx, 1
  00116	89 55 f8	 mov	 DWORD PTR _cSamplePerFrame$[ebp], edx

; 106  :             dwBytesPerFrame = (U32) (((cSamplePerFrame*dwBitPerSec + cSamplePerSec/2)/cSamplePerSec + 7)/8);

  00119	8b 4d f8	 mov	 ecx, DWORD PTR _cSamplePerFrame$[ebp]
  0011c	0f af 4d 0c	 imul	 ecx, DWORD PTR _dwBitPerSec$[ebp]
  00120	8b 45 08	 mov	 eax, DWORD PTR _cSamplePerSec$[ebp]
  00123	99		 cdq
  00124	2b c2		 sub	 eax, edx
  00126	d1 f8		 sar	 eax, 1
  00128	03 c1		 add	 eax, ecx
  0012a	33 d2		 xor	 edx, edx
  0012c	f7 75 08	 div	 DWORD PTR _cSamplePerSec$[ebp]
  0012f	83 c0 07	 add	 eax, 7
  00132	c1 e8 03	 shr	 eax, 3
  00135	89 45 fc	 mov	 DWORD PTR _dwBytesPerFrame$[ebp], eax

; 107  :         }

  00138	eb d1		 jmp	 SHORT $L2560
$L2558:

; 108  :     }
; 109  :     return cSamplePerFrame;

  0013a	8b 45 f8	 mov	 eax, DWORD PTR _cSamplePerFrame$[ebp]
$L2534:

; 110  : }

  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c2 10 00	 ret	 16			; 00000010H
_msaudioGetSamplePerFrame_XDS@16 ENDP
WMADEC	ENDS
PUBLIC	_MaxSamplesPerPacket_XDS@16
; Function compile flags: /Odt
;	COMDAT _MaxSamplesPerPacket_XDS@16
WMADEC	SEGMENT
_ulVersion$ = 8
_ulSamplingRate$ = 12
_ulChannels$ = 16
_ulBitrate$ = 20
_MaxSamplesPerPacket_XDS@16 PROC NEAR			; COMDAT

; 119  : U32 MaxSamplesPerPacket(U32 ulVersion, U32 ulSamplingRate, U32 ulChannels, U32 ulBitrate) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 120  :    return (16 + 1) * msaudioGetSamplePerFrame(ulSamplingRate,ulBitrate,ulChannels,ulVersion);

  00003	8b 45 08	 mov	 eax, DWORD PTR _ulVersion$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR _ulChannels$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 14	 mov	 edx, DWORD PTR _ulBitrate$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _ulSamplingRate$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _msaudioGetSamplePerFrame_XDS@16
  00018	6b c0 11	 imul	 eax, 17			; 00000011H

; 121  : }

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
_MaxSamplesPerPacket_XDS@16 ENDP
WMADEC	ENDS
PUBLIC	_mallocAligned_XDS@8
PUBLIC	_auMalloc_XDS@4
PUBLIC	??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@ ; `string'
PUBLIC	_LOG2@4
EXTRN	_MyOutputDbgStr:NEAR
;	COMDAT ??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
WMADEC_RD	SEGMENT
??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\wmalib\wmadec_s\msaudio.c'
	DB	00H						; `string'
WMADEC_RD	ENDS
;	COMDAT ??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
WMADEC_RD	SEGMENT
??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@ DB '%'
	DB	's(%d) : *** TRACE *** code = 0x%x!', 0aH, 00H ; `string'
; Function compile flags: /Odt
WMADEC_RD	ENDS
;	COMDAT _mallocAligned_XDS@8
WMADEC	SEGMENT
tv76 = -16
_buffer$ = -12
_mask$ = -8
_retBuffer$ = -4
_size$ = 8
_iAlignToBytes$ = 12
_mallocAligned_XDS@8 PROC NEAR				; COMDAT

; 129  : void *mallocAligned(size_t size,Int iAlignToBytes){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 130  :     Int mask = -1;                                    //Initally set mask to 0xFFFFFFFF

  00006	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _mask$[ebp], -1

; 131  :     void *retBuffer;
; 132  :     void *buffer = auMalloc(size+iAlignToBytes);        //allocate buffer + alignment bytes

  0000d	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00010	03 45 0c	 add	 eax, DWORD PTR _iAlignToBytes$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _auMalloc_XDS@4
  00019	89 45 f4	 mov	 DWORD PTR _buffer$[ebp], eax

; 133  :     if(buffer == NULL)

  0001c	83 7d f4 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00020	75 52		 jne	 SHORT $L2581

; 134  :     {
; 135  :         TraceResult(WMA_E_OUTOFMEMORY);

  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  00028	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  0002e	74 37		 je	 SHORT $L3294
  00030	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  00036	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  0003c	74 29		 je	 SHORT $L3294
  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  00043	50		 push	 eax
  00044	68 87 00 00 00	 push	 135			; 00000087H
  00049	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0005f	83 c4 14	 add	 esp, 20			; 00000014H
  00062	89 45 f0	 mov	 DWORD PTR tv76[ebp], eax
  00065	eb 09		 jmp	 SHORT $L3295
$L3294:
  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  0006d	89 55 f0	 mov	 DWORD PTR tv76[ebp], edx
$L3295:

; 136  :         return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	eb 2e		 jmp	 SHORT $L2576
$L2581:

; 137  :     }
; 138  :     assert(iAlignToBytes > 0);
; 139  :     assert(iAlignToBytes < 256);
; 140  :     mask <<= LOG2(iAlignToBytes);                     //Generate mask to clear lsb's

  00074	8b 45 0c	 mov	 eax, DWORD PTR _iAlignToBytes$[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _LOG2@4
  0007d	8b 55 f8	 mov	 edx, DWORD PTR _mask$[ebp]
  00080	8b c8		 mov	 ecx, eax
  00082	d3 e2		 shl	 edx, cl
  00084	89 55 f8	 mov	 DWORD PTR _mask$[ebp], edx

; 141  :     retBuffer = (void*)(((Int)((U8*)buffer+iAlignToBytes))&mask);//Generate aligned pointer

  00087	8b 45 f4	 mov	 eax, DWORD PTR _buffer$[ebp]
  0008a	03 45 0c	 add	 eax, DWORD PTR _iAlignToBytes$[ebp]
  0008d	23 45 f8	 and	 eax, DWORD PTR _mask$[ebp]
  00090	89 45 fc	 mov	 DWORD PTR _retBuffer$[ebp], eax

; 142  :     ((U8*)retBuffer)[-1] = (U8)((U8*)retBuffer-(U8*)buffer);//Write offset to newPtr-1

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _retBuffer$[ebp]
  00096	2b 4d f4	 sub	 ecx, DWORD PTR _buffer$[ebp]
  00099	8b 55 fc	 mov	 edx, DWORD PTR _retBuffer$[ebp]
  0009c	88 4a ff	 mov	 BYTE PTR [edx-1], cl

; 143  :     return retBuffer;

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _retBuffer$[ebp]
$L2576:

; 144  : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 08 00	 ret	 8
_mallocAligned_XDS@8 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\common\macros.h
WMADEC	ENDS
;	COMDAT _LOG2@4
WMADEC	SEGMENT
_iLog2$ = -4
_i$ = 8
_LOG2@4	PROC NEAR					; COMDAT

; 956  : {   // returns n where n = log2(2^n) = log2(2^(n+1)-1)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 957  :     U32 iLog2 = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iLog2$[ebp], 0
$L1667:

; 958  :     assert (i != 0);
; 959  :     while ((i >> iLog2) > 1)

  0000b	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _iLog2$[ebp]
  00011	d3 e8		 shr	 eax, cl
  00013	83 f8 01	 cmp	 eax, 1
  00016	76 0b		 jbe	 SHORT $L1668

; 960  :         iLog2++;

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _iLog2$[ebp]
  0001b	83 c1 01	 add	 ecx, 1
  0001e	89 4d fc	 mov	 DWORD PTR _iLog2$[ebp], ecx
  00021	eb e8		 jmp	 SHORT $L1667
$L1668:

; 961  : 
; 962  :     return iLog2;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _iLog2$[ebp]

; 963  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
_LOG2@4	ENDP
WMADEC	ENDS
PUBLIC	_freeAligned_XDS@4
EXTRN	_free:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\msaudio.c
;	COMDAT _freeAligned_XDS@4
WMADEC	SEGMENT
_realBuffer$ = -8
_bytesBack$ = -1
_ptr$ = 8
_freeAligned_XDS@4 PROC NEAR				; COMDAT

; 146  : void freeAligned(void *ptr){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 147  :     U8* realBuffer = (U8*)ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _realBuffer$[ebp], eax

; 148  :     U8 bytesBack;
; 149  :     if (realBuffer == NULL) return; 

  0000c	83 7d f8 00	 cmp	 DWORD PTR _realBuffer$[ebp], 0
  00010	75 02		 jne	 SHORT $L2599
  00012	eb 21		 jmp	 SHORT $L2594
$L2599:

; 150  :     bytesBack = ((U8*)ptr)[-1];      //Get offset to real pointer from -1 possition

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00017	8a 51 ff	 mov	 dl, BYTE PTR [ecx-1]
  0001a	88 55 ff	 mov	 BYTE PTR _bytesBack$[ebp], dl

; 151  :     realBuffer -= bytesBack;    //Get original pointer address

  0001d	0f b6 45 ff	 movzx	 eax, BYTE PTR _bytesBack$[ebp]
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _realBuffer$[ebp]
  00024	2b c8		 sub	 ecx, eax
  00026	89 4d f8	 mov	 DWORD PTR _realBuffer$[ebp], ecx

; 152  :     free(realBuffer);

  00029	8b 55 f8	 mov	 edx, DWORD PTR _realBuffer$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 _free
  00032	83 c4 04	 add	 esp, 4
$L2594:

; 153  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
_freeAligned_XDS@4 ENDP
WMADEC	ENDS
PUBLIC	_auMallocGetCount_XDS@0
; Function compile flags: /Odt
;	COMDAT _auMallocGetCount_XDS@0
WMADEC	SEGMENT
_auMallocGetCount_XDS@0 PROC NEAR			; COMDAT

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 250  :     return 0;

  00003	33 c0		 xor	 eax, eax

; 251  : }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
_auMallocGetCount_XDS@0 ENDP
WMADEC	ENDS
PUBLIC	_auMallocSetState_XDS@12
; Function compile flags: /Odt
;	COMDAT _auMallocSetState_XDS@12
WMADEC	SEGMENT
_maState$ = 8
_pBuf$ = 12
_iBufSize$ = 16
_auMallocSetState_XDS@12 PROC NEAR			; COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 255  : }

  00003	5d		 pop	 ebp
  00004	c2 0c 00	 ret	 12			; 0000000cH
_auMallocSetState_XDS@12 ENDP
WMADEC	ENDS
EXTRN	_malloc:NEAR
; Function compile flags: /Odt
;	COMDAT _auMalloc_XDS@4
WMADEC	SEGMENT
_iSize$ = 8
_auMalloc_XDS@4 PROC NEAR				; COMDAT

; 258  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 259  :     return malloc(iSize);

  00003	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _malloc
  0000c	83 c4 04	 add	 esp, 4

; 260  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
_auMalloc_XDS@4 ENDP
WMADEC	ENDS
PUBLIC	_auFree_XDS@4
; Function compile flags: /Odt
;	COMDAT _auFree_XDS@4
WMADEC	SEGMENT
_pFree$ = 8
_auFree_XDS@4 PROC NEAR					; COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 264  :     free(pFree);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pFree$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _free
  0000c	83 c4 04	 add	 esp, 4

; 265  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
_auFree_XDS@4 ENDP
WMADEC	ENDS
PUBLIC	_auNew_XDS@0
PUBLIC	_RandStateClear@4
EXTRN	__fltused:NEAR
EXTRN	_memset:NEAR
EXTRN	_prvInverseQuantizeMidRate_XDS@12:NEAR
; Function compile flags: /Odt
;	COMDAT _auNew_XDS@0
WMADEC	SEGMENT
tv75 = -8
_pau$ = -4
_auNew_XDS@0 PROC NEAR					; COMDAT

; 277  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 278  :     CAudioObject* pau = (CAudioObject*) auMalloc (sizeof (CAudioObject));

  00006	68 30 04 00 00	 push	 1072			; 00000430H
  0000b	e8 00 00 00 00	 call	 _auMalloc_XDS@4
  00010	89 45 fc	 mov	 DWORD PTR _pau$[ebp], eax

; 279  :     if ( pau == NULL )

  00013	83 7d fc 00	 cmp	 DWORD PTR _pau$[ebp], 0
  00017	75 55		 jne	 SHORT $L2621

; 280  :     {
; 281  :         TraceResult(WMA_E_OUTOFMEMORY);

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00024	74 37		 je	 SHORT $L3317
  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  0002c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  00032	74 29		 je	 SHORT $L3317
  00034	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  0003a	52		 push	 edx
  0003b	68 19 01 00 00	 push	 281			; 00000119H
  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  00045	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00055	83 c4 14	 add	 esp, 20			; 00000014H
  00058	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  0005b	eb 09		 jmp	 SHORT $L3318
$L3317:
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  00063	89 4d f8	 mov	 DWORD PTR tv75[ebp], ecx
$L3318:

; 282  :         return pau;

  00066	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00069	e9 6a 05 00 00	 jmp	 $L2616
$L2621:

; 283  :     }
; 284  : 
; 285  :     memset(&pau->m_qstQuantStep, 0, sizeof(pau->m_qstQuantStep)); // May be struct or float/double

  0006e	6a 04		 push	 4
  00070	6a 00		 push	 0
  00072	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00075	52		 push	 edx
  00076	e8 00 00 00 00	 call	 _memset
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 286  :     // memset(pau->m_rgiQuantStepFract, 0, sizeof(pau->m_rgiQuantStepFract));
; 287  :     pau->m_iPacketCurr = 0;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00081	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 288  :     pau->m_cBitPackedFrameSize = 0;

  00088	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  0008b	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 289  :     pau->m_cBitPacketHeader = 0;

  00092	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00095	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 290  :     pau->m_cdwPacketHeader = 0;

  0009c	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  0009f	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 291  :     pau->m_cBitPacketHeaderFractionDw = 0;

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  000a9	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 292  :     pau->m_cBitPacketLength = 0;

  000b0	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  000b3	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 293  :     pau->m_cRunOfZeros = 0;

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  000bd	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 294  :     pau->m_iLevel = 0; 

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  000c7	66 c7 41 20 00
	00		 mov	 WORD PTR [ecx+32], 0

; 295  :     pau->m_iSign = 0;

  000cd	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  000d0	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0

; 296  :     pau->m_iHighCutOffCurr = 0;

  000d7	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  000da	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 297  :     pau->m_iNextBarkIndex = 0;

  000e1	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  000e4	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 298  : 
; 299  :     pau->m_fNoiseSub = WMAB_FALSE; 

  000eb	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  000ee	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 300  :     pau->m_fltBitsPerSample = 0;

  000f5	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  000f8	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 301  :     pau->m_fltWeightedBitsPerSample = 0;

  000ff	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00102	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 302  : 
; 303  :     pau->m_iMaxEscSize = 9;

  00109	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  0010c	c7 42 3c 09 00
	00 00		 mov	 DWORD PTR [edx+60], 9

; 304  :     pau->m_iMaxEscLevel = (1 << pau->m_iMaxEscSize) - 1;

  00113	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00116	ba 01 00 00 00	 mov	 edx, 1
  0011b	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0011e	d3 e2		 shl	 edx, cl
  00120	83 ea 01	 sub	 edx, 1
  00123	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00126	89 50 40	 mov	 DWORD PTR [eax+64], edx

; 305  : 
; 306  :     pau->m_iVersion = 0;

  00129	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  0012c	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 307  :     pau->m_codecStatus = CODEC_NULL;

  00133	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00136	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0

; 308  :     pau->m_fSeekAdjustment = WMAB_FALSE;

  0013d	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00140	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0

; 309  :     pau->m_fPacketLossAdj = WMAB_FALSE;

  00147	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  0014a	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0

; 310  :     pau->m_iSamplingRate = 0;

  00151	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00154	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], 0

; 311  :     pau->m_cChannel = 0;

  0015b	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  0015e	66 c7 40 58 00
	00		 mov	 WORD PTR [eax+88], 0

; 312  :     pau->m_cSubband = 0;

  00164	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00167	c7 41 60 00 00
	00 00		 mov	 DWORD PTR [ecx+96], 0

; 313  : 
; 314  :     pau->m_fAllowSuperFrame = WMAB_FALSE;

  0016e	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00171	c7 42 64 00 00
	00 00		 mov	 DWORD PTR [edx+100], 0

; 315  :     pau->m_fAllowSubFrame = WMAB_FALSE;

  00178	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  0017b	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 316  :     pau->m_iCurrSubFrame = 0;

  00182	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00185	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [ecx+112], 0

; 317  :     pau->m_fHeaderReset = WMAB_TRUE;

  0018c	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  0018f	c7 42 78 01 00
	00 00		 mov	 DWORD PTR [edx+120], 1

; 318  :     pau->m_iSubFrameSizeWithUpdate = 0;

  00196	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00199	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [eax+124], 0

; 319  :     pau->m_iMaxSubFrameDiv = 1;

  001a0	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  001a3	c7 81 80 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+128], 1

; 320  :     pau->m_cMinSubFrameSample = 0;

  001ad	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  001b0	c7 82 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+132], 0

; 321  :     pau->m_cMinSubFrameSampleHalf = 0;

  001ba	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  001bd	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+136], 0

; 322  :     pau->m_cMinSubFrameSampleQuad = 0;

  001c7	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  001ca	c7 81 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+140], 0

; 323  :     pau->m_cPossibleWinSize = 0;

  001d4	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  001d7	c7 82 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+144], 0

; 324  :     pau->m_iIncr = 0;

  001e1	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  001e4	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+148], 0

; 325  :     pau->m_cSubFrameSample = 0;

  001ee	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  001f1	c7 81 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+152], 0

; 326  :     pau->m_cSubFrameSampleHalf = 0;

  001fb	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  001fe	c7 82 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+156], 0

; 327  :     pau->m_cSubFrameSampleQuad = 0;

  00208	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  0020b	c7 80 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+160], 0

; 328  :     memset(&pau->m_subfrmconfigPrev, 0, sizeof(pau->m_subfrmconfigPrev));

  00215	68 d0 00 00 00	 push	 208			; 000000d0H
  0021a	6a 00		 push	 0
  0021c	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  0021f	81 c1 a4 00 00
	00		 add	 ecx, 164		; 000000a4H
  00225	51		 push	 ecx
  00226	e8 00 00 00 00	 call	 _memset
  0022b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 329  :     memset(&pau->m_subfrmconfigCurr, 0, sizeof(pau->m_subfrmconfigCurr));

  0022e	68 d0 00 00 00	 push	 208			; 000000d0H
  00233	6a 00		 push	 0
  00235	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00238	81 c2 74 01 00
	00		 add	 edx, 372		; 00000174H
  0023e	52		 push	 edx
  0023f	e8 00 00 00 00	 call	 _memset
  00244	83 c4 0c	 add	 esp, 12			; 0000000cH

; 330  :     memset(&pau->m_subfrmconfigNext, 0, sizeof(pau->m_subfrmconfigNext));

  00247	68 d0 00 00 00	 push	 208			; 000000d0H
  0024c	6a 00		 push	 0
  0024e	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00251	05 44 02 00 00	 add	 eax, 580		; 00000244H
  00256	50		 push	 eax
  00257	e8 00 00 00 00	 call	 _memset
  0025c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 331  : 
; 332  :     pau->m_cBitsSubbandMax = 0;

  0025f	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00262	c7 81 14 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+788], 0

; 333  :     pau->m_cFrameSample = 0;

  0026c	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  0026f	c7 82 18 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+792], 0

; 334  :     pau->m_cFrameSampleHalf = 0;

  00279	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  0027c	c7 80 1c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+796], 0

; 335  :     pau->m_cFrameSampleQuad = 0;

  00286	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00289	c7 81 20 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+800], 0

; 336  : 
; 337  :     pau->m_cLowCutOff = 0;

  00293	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00296	c7 82 24 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+804], 0

; 338  :     pau->m_cHighCutOff = 0;

  002a0	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  002a3	c7 80 28 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+808], 0

; 339  :     pau->m_cLowCutOffLong = 0;

  002ad	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  002b0	c7 81 2c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+812], 0

; 340  :     pau->m_cHighCutOffLong = 0;

  002ba	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  002bd	c7 82 30 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+816], 0

; 341  : 
; 342  :     pau->m_iWeightingMode = LPC_MODE;

  002c7	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  002ca	c7 80 34 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+820], 0

; 343  :     pau->m_stereoMode = STEREO_LEFTRIGHT;

  002d4	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  002d7	c7 81 38 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+824], 0

; 344  :     pau->m_iEntropyMode = 0;

  002e1	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  002e4	c7 82 3c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+828], 0

; 345  :     pau->m_fltDitherLevel = 0.04F;

  002ee	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  002f1	c7 80 40 03 00
	00 0a d7 23 3d	 mov	 DWORD PTR [eax+832], 1025758986 ; 3d23d70aH

; 346  :     pau->m_iQuantStepSize = (MIN_QUANT + MAX_QUANT - 1) / 2;

  002fb	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  002fe	c7 81 44 03 00
	00 40 00 00 00	 mov	 DWORD PTR [ecx+836], 64	; 00000040H

; 347  :     pau->m_fltFlatenFactor = 0.5F;

  00308	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  0030b	c7 82 48 03 00
	00 00 00 00 3f	 mov	 DWORD PTR [edx+840], 1056964608 ; 3f000000H

; 348  :     pau->m_fltDctScale = 0;

  00315	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00318	c7 80 4c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+844], 0

; 349  :     pau->m_cValidBarkBand = 0;

  00322	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00325	c7 81 50 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+848], 0

; 350  :     pau->m_rgiBarkIndex = NULL;

  0032f	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00332	c7 82 54 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+852], 0

; 351  : 
; 352  : #if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
; 353  :     pau->m_iSinRampUpStart = 0;
; 354  :     pau->m_iCosRampUpStart = 0;
; 355  :     pau->m_iSinRampUpPrior = 0;
; 356  :     pau->m_iCosRampUpPrior = 0;
; 357  :     pau->m_iSinRampUpStep = 0;
; 358  :     pau->m_iSinRampDownStart = 0;
; 359  :     pau->m_iCosRampDownStart = 0;
; 360  :     pau->m_iSinRampDownPrior = 0;
; 361  :     pau->m_iCosRampDownPrior = 0;
; 362  :     pau->m_iSinRampDownStep = 0;
; 363  :     memset(pau->m_iSinInit, 0, sizeof(pau->m_iSinInit));
; 364  :     memset(pau->m_iCosInit, 0, sizeof(pau->m_iCosInit));
; 365  : #endif
; 366  : 
; 367  : #if !defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
; 368  :     pau->m_fltSinRampUpStart = 0;

  0033c	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  0033f	c7 80 58 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+856], 0

; 369  :     pau->m_fltCosRampUpStart = 0;

  00349	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  0034c	c7 81 5c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+860], 0

; 370  :     pau->m_fltSinRampUpPrior = 0;

  00356	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00359	c7 82 60 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+864], 0

; 371  :     pau->m_fltCosRampUpPrior = 0;

  00363	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00366	c7 80 64 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+868], 0

; 372  :     pau->m_fltSinRampUpStep = 0;

  00370	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00373	c7 81 68 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+872], 0

; 373  :     pau->m_fltSinRampDownStart = 0;

  0037d	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00380	c7 82 6c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+876], 0

; 374  :     pau->m_fltCosRampDownStart = 0;

  0038a	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  0038d	c7 80 70 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+880], 0

; 375  :     pau->m_fltSinRampDownPrior = 0;

  00397	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  0039a	c7 81 74 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+884], 0

; 376  :     pau->m_fltCosRampDownPrior = 0;

  003a4	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  003a7	c7 82 78 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+888], 0

; 377  :     pau->m_fltSinRampDownStep = 0;

  003b1	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  003b4	c7 80 7c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+892], 0

; 378  : #endif
; 379  : #ifdef USE_SIN_COS_TABLES
; 380  :     //MMX tables
; 381  :     pau->m_piSinForRecon2048 = NULL;

  003be	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  003c1	c7 81 10 04 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1040], 0

; 382  :     pau->m_piSinForRecon1024 = NULL;

  003cb	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  003ce	c7 82 14 04 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1044], 0

; 383  :     pau->m_piSinForRecon512 = NULL;

  003d8	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  003db	c7 80 18 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1048], 0

; 384  :     pau->m_piSinForRecon256 = NULL;

  003e5	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  003e8	c7 81 1c 04 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1052], 0

; 385  :     pau->m_piSinForRecon128 = NULL;

  003f2	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  003f5	c7 82 20 04 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1056], 0

; 386  :     pau->m_piSinForRecon64 = NULL;

  003ff	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00402	c7 80 24 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1060], 0

; 387  :     pau->m_piSinForRecon = NULL;

  0040c	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  0040f	c7 81 28 04 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1064], 0

; 388  :     pau->m_piSinForSaveHistory = NULL;

  00419	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  0041c	c7 82 2c 04 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1068], 0

; 389  : #endif
; 390  : 
; 391  :     pau->m_iSizePrev = 0;

  00426	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00429	c7 80 80 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+896], 0

; 392  :     pau->m_iSizeCurr = 0;

  00433	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00436	c7 81 84 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+900], 0

; 393  :     pau->m_iSizeNext = 0;

  00440	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00443	c7 82 88 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+904], 0

; 394  : 
; 395  :     pau->m_iCoefRecurQ1 = 0;

  0044d	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00450	c7 80 8c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+908], 0

; 396  :     pau->m_iCoefRecurQ2 = 0;

  0045a	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  0045d	c7 81 90 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+912], 0

; 397  :     pau->m_iCoefRecurQ3 = 0;

  00467	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  0046a	c7 82 94 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+916], 0

; 398  :     pau->m_iCoefRecurQ4 = 0;

  00474	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00477	c7 80 98 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+920], 0

; 399  : 
; 400  :     pau->m_rgiCoefQ = NULL;

  00481	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00484	c7 81 9c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+924], 0

; 401  : 
; 402  :     pau->m_rgpcinfo = NULL;

  0048e	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00491	c7 82 a0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+928], 0

; 403  :     pau->m_rgiCoefReconOrig = NULL;

  0049b	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  0049e	c7 80 a4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+932], 0

; 404  :     pau->m_rgiMaskQ = NULL;

  004a8	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  004ab	c7 81 a8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+936], 0

; 405  :     pau->m_rgcValidBarkBand = NULL;

  004b5	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  004b8	c7 82 ac 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+940], 0

; 406  :     pau->m_rgiBarkIndexOrig = NULL;

  004c2	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  004c5	c7 80 b0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+944], 0

; 407  : 
; 408  : 
; 409  :     pau->m_piPrevOutput = NULL;

  004cf	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  004d2	c7 81 b4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+948], 0

; 410  :     pau->m_iDiscardSilence = 0;

  004dc	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  004df	c7 82 b8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+952], 0

; 411  : 
; 412  : #ifdef TRANSCODER
; 413  :     pau->m_ttTranscodeType = TT_NONE;
; 414  : #endif  // TRANSCODER
; 415  : 
; 416  : #ifdef ENABLE_ALL_ENCOPT
; 417  :     pau->m_fltFirstNoiseFreq = 0;

  004e9	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  004ec	c7 80 bc 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+956], 0

; 418  :     pau->m_iFirstNoiseBand = 0;

  004f6	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  004f9	c7 81 c0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+960], 0

; 419  :     pau->m_iFirstNoiseIndex = 0;

  00503	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00506	c7 82 c4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+964], 0

; 420  :     pau->m_iNoisePeakIgnoreBand = 1;

  00510	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00513	c7 80 c8 03 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+968], 1

; 421  : 
; 422  :     pau->m_rgiFirstNoiseBand = NULL;

  0051d	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00520	c7 81 cc 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+972], 0

; 423  :     pau->m_rgbBandNotCoded = NULL;

  0052a	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  0052d	c7 82 d0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+976], 0

; 424  :     pau->m_rgffltSqrtBWRatio = NULL;

  00537	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  0053a	c7 80 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+980], 0

; 425  :     pau->m_rgiNoisePower = NULL;

  00544	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00547	c7 81 d8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+984], 0

; 426  :     pau->m_rgfltBandWeight = NULL;

  00551	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  00554	c7 82 dc 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+988], 0

; 427  : 
; 428  : #if defined(_DEBUG) && defined(LPC_COMPARE)
; 429  :     memset(pau->m_rgfltLpsSpecCos, 0, sizeof(pau->m_rgfltLpsSpecCos));
; 430  :     memset(pau->m_rgfltLpsSpecSin, 0, sizeof(pau->m_rgfltLpsSpecSin));
; 431  : #endif  // _DEBUG
; 432  : #endif  // ENABLE_ALL_ENCOPT
; 433  : 
; 434  :     pau->m_rgfltWeightFactor = NULL;

  0055e	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00561	c7 80 e0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+992], 0

; 435  :     pau->m_rguiWeightFactor = NULL;

  0056b	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  0056e	c7 81 e4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+996], 0

; 436  : 
; 437  :     pau->m_iFrameNumber = 0;

  00578	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  0057b	c7 82 e8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1000], 0

; 438  : 
; 439  : #if defined(INTERPOLATED_DOWNSAMPLE)
; 440  :     pau->m_fLowPass = WMAB_FALSE;
; 441  :     pau->m_fDownsample = WMAB_FALSE;
; 442  :     pau->m_iInterpolSrcBlkSize = 0;
; 443  :     pau->m_iInterpolDstBlkSize = 0;
; 444  :     pau->m_iInterpolIncr = 0;
; 445  :     pau->m_iInterpolCarry = 0;
; 446  :     pau->m_iInterpolWeightIncr = 0;
; 447  :     pau->m_iInterpolAddInterval = 0;
; 448  :     pau->m_iInterpolNextAdd = 0;
; 449  : #endif  // defined(INTERPOLATED_DOWNSAMPLE)
; 450  : 
; 451  : #if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
; 452  :     pau->m_fHalfTransform = WMAB_FALSE;
; 453  :     pau->m_fUpsample = WMAB_FALSE;
; 454  :     pau->m_fPad2XTransform = WMAB_FALSE;
; 455  :     memset(pau->m_iPriorSample, 0, sizeof(pau->m_iPriorSample));
; 456  :     //pau->m_htiHalfPrevState.m_fSaved = WMAB_FALSE;
; 457  :     //pau->m_htiPad2XPrevState.m_fSaved = WMAB_FALSE;
; 458  :     pau->m_cSubbandAdjusted = 0;
; 459  :     pau->m_cFrameSampleAdjusted = 0; 
; 460  :     pau->m_cFrameSampleHalfAdjusted = 0;
; 461  :     pau->m_cSubFrameSampleAdjusted = 0;
; 462  :     pau->m_cSubFrameSampleHalfAdjusted = 0;
; 463  :     pau->m_cSubFrameSampleQuadAdjusted = 0;
; 464  :     pau->m_cHighCutOffAdjusted = 0;
; 465  : #endif  // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
; 466  : 
; 467  : 	pau->m_fIntelFFT = WMAB_FALSE;

  00585	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00588	c7 80 04 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1028], 0

; 468  : 
; 469  : #if !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)
; 470  :     pau->m_fIntelFFT = WMAB_FALSE;

  00592	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  00595	c7 81 04 04 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1028], 0

; 471  : #endif  // !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)
; 472  : 
; 473  : #ifdef ENABLE_ALL_ENCOPT
; 474  :     pau->aupfnInverseQuantize = prvInverseQuantizeMidRate;

  0059f	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  005a2	c7 82 ec 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1004], OFFSET FLAT:_prvInverseQuantizeMidRate_XDS@12

; 475  : #else
; 476  :     pau->aupfnInverseQuantize = NULL;
; 477  : #endif
; 478  :     pau->prvpfnInverseTransformMono = NULL; // Not currently used

  005ac	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  005af	c7 80 f0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1008], 0

; 479  :     pau->aupfnGetNextRun = NULL;

  005b9	8b 4d fc	 mov	 ecx, DWORD PTR _pau$[ebp]
  005bc	c7 81 f4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1012], 0

; 480  : 
; 481  : 	RandStateClear(&(pau->m_tRandState));

  005c6	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  005c9	81 c2 08 04 00
	00		 add	 edx, 1032		; 00000408H
  005cf	52		 push	 edx
  005d0	e8 00 00 00 00	 call	 _RandStateClear@4

; 482  : 
; 483  :     // OK, now verify the sizes of all fundamental type definitions
; 484  : #ifndef __QNX__
; 485  :     assert(sizeof(U64) == 8);
; 486  :     assert(sizeof(I64) == 8);
; 487  : #endif
; 488  :     assert(sizeof(U32) == 4);
; 489  :     assert(sizeof(I32) == 4);
; 490  :     assert(sizeof(U16) == 2);
; 491  :     assert(sizeof(I16) == 2);
; 492  :     assert(sizeof(U8) == 1);
; 493  :     assert(sizeof(I8) == 1);
; 494  : 
; 495  :     return pau;

  005d5	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
$L2616:

; 496  : }

  005d8	8b e5		 mov	 esp, ebp
  005da	5d		 pop	 ebp
  005db	c3		 ret	 0
_auNew_XDS@0 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\common\macros.h
WMADEC	ENDS
;	COMDAT _RandStateClear@4
WMADEC	SEGMENT
_ptRandState$ = 8
_RandStateClear@4 PROC NEAR				; COMDAT

; 808  :     INLINE void RandStateClear(tRandState* ptRandState) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 809  :         ptRandState->iPrior = 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _ptRandState$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 810  :         ptRandState->uiRand = 0;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _ptRandState$[ebp]
  0000f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 811  :     }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
_RandStateClear@4 ENDP
WMADEC	ENDS
PUBLIC	_auDelete_XDS@4
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\msaudio.c
;	COMDAT _auDelete_XDS@4
WMADEC	SEGMENT
_pau$ = 8
_auDelete_XDS@4 PROC NEAR				; COMDAT

; 506  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 507  :     DELETE_ARRAY (pau->m_rgpcinfo);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00006	83 b8 a0 03 00
	00 00		 cmp	 DWORD PTR [eax+928], 0
  0000d	74 0f		 je	 SHORT $L2651
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00012	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 _auFree_XDS@4
$L2651:
  0001e	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00021	c7 80 a0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+928], 0

; 508  : 
; 509  :     DELETE_ARRAY (pau->m_piPrevOutput);

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0002e	83 b9 b4 03 00
	00 00		 cmp	 DWORD PTR [ecx+948], 0
  00035	74 0f		 je	 SHORT $L2654
  00037	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0003a	8b 82 b4 03 00
	00		 mov	 eax, DWORD PTR [edx+948]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _auFree_XDS@4
$L2654:
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00049	c7 81 b4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+948], 0

; 510  : 
; 511  :     {
; 512  :         freeAligned(pau->m_rgiCoefReconOrig);

  00053	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00056	8b 82 a4 03 00
	00		 mov	 eax, DWORD PTR [edx+932]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _freeAligned_XDS@4

; 513  :         DELETE_ARRAY (pau->m_rguiWeightFactor);

  00062	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00065	83 b9 e4 03 00
	00 00		 cmp	 DWORD PTR [ecx+996], 0
  0006c	74 0f		 je	 SHORT $L2657
  0006e	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00071	8b 82 e4 03 00
	00		 mov	 eax, DWORD PTR [edx+996]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _auFree_XDS@4
$L2657:
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00080	c7 81 e4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+996], 0

; 514  :         pau->m_rgfltWeightFactor = NULL;

  0008a	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0008d	c7 82 e0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+992], 0

; 515  :     }
; 516  :     DELETE_ARRAY (pau->m_rgcValidBarkBand);

  00097	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0009a	83 b8 ac 03 00
	00 00		 cmp	 DWORD PTR [eax+940], 0
  000a1	74 0f		 je	 SHORT $L2661
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000a6	8b 91 ac 03 00
	00		 mov	 edx, DWORD PTR [ecx+940]
  000ac	52		 push	 edx
  000ad	e8 00 00 00 00	 call	 _auFree_XDS@4
$L2661:
  000b2	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000b5	c7 80 ac 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+940], 0

; 517  :     DELETE_ARRAY (pau->m_rgiBarkIndexOrig);

  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000c2	83 b9 b0 03 00
	00 00		 cmp	 DWORD PTR [ecx+944], 0
  000c9	74 0f		 je	 SHORT $L2664
  000cb	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000ce	8b 82 b0 03 00
	00		 mov	 eax, DWORD PTR [edx+944]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _auFree_XDS@4
$L2664:
  000da	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000dd	c7 81 b0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+944], 0

; 518  :     DELETE_ARRAY (pau->m_rgiMaskQ);

  000e7	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000ea	83 ba a8 03 00
	00 00		 cmp	 DWORD PTR [edx+936], 0
  000f1	74 0f		 je	 SHORT $L2667
  000f3	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000f6	8b 88 a8 03 00
	00		 mov	 ecx, DWORD PTR [eax+936]
  000fc	51		 push	 ecx
  000fd	e8 00 00 00 00	 call	 _auFree_XDS@4
$L2667:
  00102	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00105	c7 82 a8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+936], 0

; 519  : 
; 520  : #ifdef ENABLE_ALL_ENCOPT
; 521  :     {
; 522  : #if defined(_DEBUG) && defined(LPC_COMPARE)
; 523  :         Int i;
; 524  :         for (i = 0; i < LPCORDER; i++)  {
; 525  :             if ( pau->m_rgfltLpsSpecCos[i] != NULL )
; 526  :                 DELETE_ARRAY (pau->m_rgfltLpsSpecCos[i]);
; 527  :             if ( pau->m_rgfltLpsSpecSin[i] != NULL )
; 528  :                 DELETE_ARRAY (pau->m_rgfltLpsSpecSin[i]);
; 529  :         }
; 530  : #endif
; 531  :         DELETE_ARRAY (pau->m_rgiFirstNoiseBand);

  0010f	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00112	83 b8 cc 03 00
	00 00		 cmp	 DWORD PTR [eax+972], 0
  00119	74 0f		 je	 SHORT $L2670
  0011b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0011e	8b 91 cc 03 00
	00		 mov	 edx, DWORD PTR [ecx+972]
  00124	52		 push	 edx
  00125	e8 00 00 00 00	 call	 _auFree_XDS@4
$L2670:
  0012a	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0012d	c7 80 cc 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+972], 0

; 532  :         DELETE_ARRAY (pau->m_rgbBandNotCoded);

  00137	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0013a	83 b9 d0 03 00
	00 00		 cmp	 DWORD PTR [ecx+976], 0
  00141	74 0f		 je	 SHORT $L2673
  00143	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00146	8b 82 d0 03 00
	00		 mov	 eax, DWORD PTR [edx+976]
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _auFree_XDS@4
$L2673:
  00152	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00155	c7 81 d0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+976], 0

; 533  :         DELETE_ARRAY (pau->m_rgffltSqrtBWRatio);

  0015f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00162	83 ba d4 03 00
	00 00		 cmp	 DWORD PTR [edx+980], 0
  00169	74 0f		 je	 SHORT $L2676
  0016b	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0016e	8b 88 d4 03 00
	00		 mov	 ecx, DWORD PTR [eax+980]
  00174	51		 push	 ecx
  00175	e8 00 00 00 00	 call	 _auFree_XDS@4
$L2676:
  0017a	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0017d	c7 82 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+980], 0

; 534  :         DELETE_ARRAY (pau->m_rgiNoisePower);

  00187	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0018a	83 b8 d8 03 00
	00 00		 cmp	 DWORD PTR [eax+984], 0
  00191	74 0f		 je	 SHORT $L2679
  00193	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00196	8b 91 d8 03 00
	00		 mov	 edx, DWORD PTR [ecx+984]
  0019c	52		 push	 edx
  0019d	e8 00 00 00 00	 call	 _auFree_XDS@4
$L2679:
  001a2	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001a5	c7 80 d8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+984], 0

; 535  :         DELETE_ARRAY (pau->m_rgfltBandWeight);

  001af	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  001b2	83 b9 dc 03 00
	00 00		 cmp	 DWORD PTR [ecx+988], 0
  001b9	74 0f		 je	 SHORT $L2682
  001bb	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  001be	8b 82 dc 03 00
	00		 mov	 eax, DWORD PTR [edx+988]
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 _auFree_XDS@4
$L2682:
  001ca	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  001cd	c7 81 dc 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+988], 0

; 536  :     }
; 537  : #endif //ENABLE_ALL_ENCOPT
; 538  : 
; 539  :     DELETE_ARRAY (pau->m_rgiCoefQ);

  001d7	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  001da	83 ba 9c 03 00
	00 00		 cmp	 DWORD PTR [edx+924], 0
  001e1	74 0f		 je	 SHORT $L2685
  001e3	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001e6	8b 88 9c 03 00
	00		 mov	 ecx, DWORD PTR [eax+924]
  001ec	51		 push	 ecx
  001ed	e8 00 00 00 00	 call	 _auFree_XDS@4
$L2685:
  001f2	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  001f5	c7 82 9c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+924], 0

; 540  : 
; 541  : #if !defined(_Embedded_x86)
; 542  : #if defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE))
; 543  :     if (pau->m_fIntelFFT)
; 544  :     {
; 545  :         WMARESULT wmaResult;
; 546  : 
; 547  :         wmaResult = auFreeIntelFFT(pau, INTELFFT_FREE_PROCESS);
; 548  :         TraceError(wmaResult);
; 549  :     }
; 550  : #endif  // WMA_TARGET_X86 && !defined(BUILD_INTEGER)
; 551  : #endif
; 552  : 
; 553  :     auFree (pau);

  001ff	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 _auFree_XDS@4

; 554  : 
; 555  :     DUMP_MONITOR_RANGES(0);
; 556  : }

  00208	5d		 pop	 ebp
  00209	c2 04 00	 ret	 4
_auDelete_XDS@4 ENDP
WMADEC	ENDS
PUBLIC	_auInit_XDS@36
PUBLIC	_auReconstruct_XDS@16
PUBLIC	_prvAllocate_XDS@4
PUBLIC	__real@41000000
PUBLIC	__real@3fcccccd
PUBLIC	__real@3f3851ec
PUBLIC	__real@3f947ae1
PUBLIC	@ROUNDF@4
EXTRN	_auDctIV_XDS@16:NEAR
EXTRN	_auReconstruct_X86_XDS@16:NEAR
EXTRN	_auReconStereo_MMX_XDS@16:NEAR
EXTRN	_auReconStereo_SIMDFP_XDS@16:NEAR
EXTRN	_prvFFT4DCT_XDS@8:NEAR
EXTRN	_prvInverseQuantizeLowRate_XDS@12:NEAR
EXTRN	_prvInitInverseQuadRootTable_XDS@4:NEAR
EXTRN	_g_SupportMMX_XDS@0:NEAR
EXTRN	_g_SupportSIMD_FP_XDS@0:NEAR
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@3fcccccd
CONST	SEGMENT
__real@3fcccccd DD 03fcccccdr			; 1.6
CONST	ENDS
;	COMDAT __real@3f3851ec
CONST	SEGMENT
__real@3f3851ec DD 03f3851ecr			; 0.72
CONST	ENDS
;	COMDAT __real@3f947ae1
CONST	SEGMENT
__real@3f947ae1 DD 03f947ae1r			; 1.16
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _auInit_XDS@36
WMADEC	SEGMENT
tv277 = -28
tv397 = -24
tv170 = -20
tv95 = -16
tv83 = -12
_iNonSupportedPlayerOpt$ = -8
_wmaResult$ = -4
_pau$ = 8
_iVersionNumber$ = 12
_cSubband$ = 16
_cSamplePerSec$ = 20
_cChannel$ = 24
_cBytePerSec$ = 28
_cbPacketLength$ = 32
_iEncodeOpt$ = 36
_iPlayerOpt$ = 40
_auInit_XDS@36 PROC NEAR				; COMDAT

; 579  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi

; 580  :     U16 iNonSupportedPlayerOpt;
; 581  :     WMARESULT   wmaResult = WMA_OK;

  00007	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000c	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 582  : 
; 583  :     //set up default pcinfo for noise sub
; 584  : 
; 585  :     static const char fOKOptions[16] = {
; 586  :         // WinCE Player Option Combinations
; 587  :         WMAB_TRUE,  // 0: normal
; 588  :         WMAB_TRUE,  // 1: Device that does not support 32kHz sampling -> interpolated downsample to 22kHz
; 589  :         WMAB_TRUE,  // 2: Background HalfTransform mode to save CPU cycles
; 590  :         WMAB_TRUE,  // 3: Background HalfTransform mode on device that does not support 32kHz sampling, ends up at 11kHz
; 591  :         WMAB_TRUE,  // 4: A slow CPU which does not support F0 but does support 2*F0
; 592  :         WMAB_TRUE,  // 5: Device that does not support 32kHz sample nor 22kHz playback, plays 32kHz data via 22kHz quality at 44kHz
; 593  :         WMAB_TRUE,  // 6: Background HalfTransform mode for device that does not support half sampling rate
; 594  :         WMAB_TRUE,  // 7: Background with downsampling - why?
; 595  :         WMAB_TRUE,  // 8: Hide HP-430's lack of a low-pass filter for 22kHz output
; 596  :         WMAB_FALSE, // 9: not appropriate - would need to interpolate to 44kHz if appropriate
; 597  :         WMAB_TRUE,  // A: Background HalfTransform mode on a HP-430 at 22kHz, decode as normal (neither half nor doubled)
; 598  :         WMAB_TRUE,  // B: why but why not allow?? 
; 599  :         WMAB_FALSE, // C: not appropriate
; 600  :         WMAB_FALSE, // D: not appropriate
; 601  :         WMAB_FALSE, // E: not appropriate
; 602  :         WMAB_FALSE  // F: not appropriate
; 603  :     };
; 604  :     assert( PLAYOPT_DOWNSAMPLE32TO22==1 && PLAYOPT_HALFTRANSFORM==2 && PLAYOPT_UPSAMPLE==4 && PLAYOPT_PAD2XTRANSFORM==8 );
; 605  : 
; 606  :     pau->m_iVersion = iVersionNumber;

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00012	8b 55 0c	 mov	 edx, DWORD PTR _iVersionNumber$[ebp]
  00015	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 607  : 
; 608  : #   if defined(WMA_TARGET_MIPS) && defined(BUILD_INTEGER)
; 609  :         if (pau->m_iVersion < 2 && cSamplePerSec >= 44100 ) {
; 610  :             // bug 813 - mips integer code gets an integer overflow exception on V1 content 11/21/2000
; 611  :             wmaResult = TraceResult(WMA_E_NOTSUPPORTED);
; 612  :             goto exit;
; 613  :         }
; 614  : #   endif
; 615  : 
; 616  :     pau->m_iWeightingMode    = (iEncodeOpt & ENCOPT_BARK) ? BARK_MODE : LPC_MODE;

  00018	0f b7 45 24	 movzx	 eax, WORD PTR _iEncodeOpt$[ebp]
  0001c	83 e0 01	 and	 eax, 1
  0001f	f7 d8		 neg	 eax
  00021	1b c0		 sbb	 eax, eax
  00023	f7 d8		 neg	 eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00028	89 81 34 03 00
	00		 mov	 DWORD PTR [ecx+820], eax

; 617  :     pau->m_fV5Lpc = (iEncodeOpt & ENCOPT_V5LPC);

  0002e	0f b7 55 24	 movzx	 edx, WORD PTR _iEncodeOpt$[ebp]
  00032	83 e2 20	 and	 edx, 32			; 00000020H
  00035	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00038	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 618  : #ifndef ENABLE_LPC
; 619  :     if (LPC_MODE == pau->m_iWeightingMode)
; 620  :     {
; 621  :         // This build of the codec does not support LPC!
; 622  :         wmaResult = TraceResult(WMA_E_NOTSUPPORTED);
; 623  :         goto exit;
; 624  :     }
; 625  : #endif  // ENABLE_LPC
; 626  : 
; 627  : #if !defined(WMA_V9)
; 628  :     if ( cChannel>2 ) {

  0003b	0f b7 4d 18	 movzx	 ecx, WORD PTR _cChannel$[ebp]
  0003f	83 f9 02	 cmp	 ecx, 2
  00042	7e 58		 jle	 SHORT $L2710

; 629  :         // when we add 5.1 support, we don't want existing decoders to try to decode them
; 630  :         wmaResult = TraceResult(WMA_E_NOTSUPPORTED);

  00044	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_NOTSUPPORTED
  0004a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  00050	74 37		 je	 SHORT $L3329
  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_NOTSUPPORTED
  00057	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  0005d	74 2a		 je	 SHORT $L3329
  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_NOTSUPPORTED
  00065	51		 push	 ecx
  00066	68 76 02 00 00	 push	 630			; 00000276H
  0006b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  00070	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00075	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_NOTSUPPORTED
  0007b	52		 push	 edx
  0007c	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00081	83 c4 14	 add	 esp, 20			; 00000014H
  00084	89 45 f4	 mov	 DWORD PTR tv83[ebp], eax
  00087	eb 08		 jmp	 SHORT $L3330
$L3329:
  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_NOTSUPPORTED
  0008e	89 45 f4	 mov	 DWORD PTR tv83[ebp], eax
$L3330:
  00091	8b 4d f4	 mov	 ecx, DWORD PTR tv83[ebp]
  00094	89 4d fc	 mov	 DWORD PTR _wmaResult$[ebp], ecx

; 631  :         goto exit;

  00097	e9 ab 05 00 00	 jmp	 $exit$2711
$L2710:

; 632  :     }
; 633  : #endif
; 634  : 
; 635  :     pau->m_fAllowSuperFrame  = !!(iEncodeOpt & ENCOPT_SUPERFRAME);

  0009c	0f b7 55 24	 movzx	 edx, WORD PTR _iEncodeOpt$[ebp]
  000a0	83 e2 02	 and	 edx, 2
  000a3	f7 da		 neg	 edx
  000a5	1b d2		 sbb	 edx, edx
  000a7	f7 da		 neg	 edx
  000a9	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000ac	89 50 64	 mov	 DWORD PTR [eax+100], edx

; 636  :     pau->m_fAllowSubFrame    = pau->m_fAllowSuperFrame && !!(iEncodeOpt & ENCOPT_SUBFRAME);

  000af	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000b2	83 79 64 00	 cmp	 DWORD PTR [ecx+100], 0
  000b6	74 14		 je	 SHORT $L3331
  000b8	0f b7 55 24	 movzx	 edx, WORD PTR _iEncodeOpt$[ebp]
  000bc	83 e2 04	 and	 edx, 4
  000bf	85 d2		 test	 edx, edx
  000c1	74 09		 je	 SHORT $L3331
  000c3	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
  000ca	eb 07		 jmp	 SHORT $L3332
$L3331:
  000cc	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
$L3332:
  000d3	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000d6	8b 4d f0	 mov	 ecx, DWORD PTR tv95[ebp]
  000d9	89 48 68	 mov	 DWORD PTR [eax+104], ecx

; 637  : 
; 638  :     if (pau->m_fAllowSubFrame) {

  000dc	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000df	83 7a 68 00	 cmp	 DWORD PTR [edx+104], 0
  000e3	74 5a		 je	 SHORT $L2712

; 639  :         pau->m_iMaxSubFrameDiv = ((iEncodeOpt & ENCOPT_SUBFRAMEDIVMASK) >>
; 640  :             ENCOPT_SUBFRAMEDIVSHR);

  000e5	0f b7 45 24	 movzx	 eax, WORD PTR _iEncodeOpt$[ebp]
  000e9	83 e0 18	 and	 eax, 24			; 00000018H
  000ec	c1 f8 03	 sar	 eax, 3
  000ef	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000f2	89 81 80 00 00
	00		 mov	 DWORD PTR [ecx+128], eax

; 641  :         if (cBytePerSec / cChannel >= 4000)

  000f8	0f b7 4d 18	 movzx	 ecx, WORD PTR _cChannel$[ebp]
  000fc	8b 45 1c	 mov	 eax, DWORD PTR _cBytePerSec$[ebp]
  000ff	99		 cdq
  00100	f7 f9		 idiv	 ecx
  00102	3d a0 0f 00 00	 cmp	 eax, 4000		; 00000fa0H
  00107	7c 1b		 jl	 SHORT $L2713

; 642  :             pau->m_iMaxSubFrameDiv = (8 << pau->m_iMaxSubFrameDiv);

  00109	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0010c	b8 08 00 00 00	 mov	 eax, 8
  00111	8b 8a 80 00 00
	00		 mov	 ecx, DWORD PTR [edx+128]
  00117	d3 e0		 shl	 eax, cl
  00119	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0011c	89 81 80 00 00
	00		 mov	 DWORD PTR [ecx+128], eax

; 643  :         else 

  00122	eb 19		 jmp	 SHORT $L2714
$L2713:

; 644  :             pau->m_iMaxSubFrameDiv = (2 << pau->m_iMaxSubFrameDiv);

  00124	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00127	b8 02 00 00 00	 mov	 eax, 2
  0012c	8b 8a 80 00 00
	00		 mov	 ecx, DWORD PTR [edx+128]
  00132	d3 e0		 shl	 eax, cl
  00134	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00137	89 81 80 00 00
	00		 mov	 DWORD PTR [ecx+128], eax
$L2714:

; 645  :     }
; 646  :     else 

  0013d	eb 0d		 jmp	 SHORT $L2715
$L2712:

; 647  :         pau->m_iMaxSubFrameDiv = 1;

  0013f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00142	c7 82 80 00 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+128], 1
$L2715:

; 648  :     if (pau->m_iMaxSubFrameDiv > cSubband / MIN_FRAME_SIZE)

  0014c	8b 45 10	 mov	 eax, DWORD PTR _cSubband$[ebp]
  0014f	99		 cdq
  00150	83 e2 7f	 and	 edx, 127		; 0000007fH
  00153	03 c2		 add	 eax, edx
  00155	c1 f8 07	 sar	 eax, 7
  00158	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0015b	39 81 80 00 00
	00		 cmp	 DWORD PTR [ecx+128], eax
  00161	7e 15		 jle	 SHORT $L2716

; 649  :         pau->m_iMaxSubFrameDiv = cSubband / MIN_FRAME_SIZE;

  00163	8b 45 10	 mov	 eax, DWORD PTR _cSubband$[ebp]
  00166	99		 cdq
  00167	83 e2 7f	 and	 edx, 127		; 0000007fH
  0016a	03 c2		 add	 eax, edx
  0016c	c1 f8 07	 sar	 eax, 7
  0016f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00172	89 82 80 00 00
	00		 mov	 DWORD PTR [edx+128], eax
$L2716:

; 650  : 
; 651  :     assert(TRANSCODER_AB(WMAB_TRUE, 0 == (iEncodeOpt & ENCOPT_TRANSCODE)));
; 652  : #ifdef TRANSCODER
; 653  :     if (iEncodeOpt & ENCOPT_TRANSCODE)
; 654  :         pau->m_ttTranscodeType = TT_SIMPLE;
; 655  : #endif  // TRANSCODER
; 656  : 
; 657  :     // When using noise substitution for uncoded bark or frequency bands, 
; 658  :     // m_fltDitherLevel sets an overall "gain" of the substitution noise
; 659  :     if (pau->m_iWeightingMode == LPC_MODE)

  00178	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0017b	83 b8 34 03 00
	00 00		 cmp	 DWORD PTR [eax+820], 0
  00182	75 0f		 jne	 SHORT $L2717

; 660  :         pau->m_fltDitherLevel = 0.04F;

  00184	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00187	c7 81 40 03 00
	00 0a d7 23 3d	 mov	 DWORD PTR [ecx+832], 1025758986 ; 3d23d70aH

; 661  :     else // BARK_MODE

  00191	eb 0d		 jmp	 SHORT $L2718
$L2717:

; 662  :         pau->m_fltDitherLevel = 0.02F;

  00193	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00196	c7 82 40 03 00
	00 0a d7 a3 3c	 mov	 DWORD PTR [edx+832], 1017370378 ; 3ca3d70aH
$L2718:

; 663  : 
; 664  :     // --- Handle player options ---
; 665  :     // First, figure out if the player has asked us for an option that we
; 666  :     // didn't build
; 667  :     iNonSupportedPlayerOpt = ~0; // Turn everything on

  001a0	66 c7 45 f8 ff
	ff		 mov	 WORD PTR _iNonSupportedPlayerOpt$[ebp], 65535 ; 0000ffffH

; 668  :     DOWNSAMPLE_ONLY(iNonSupportedPlayerOpt &= ~(PLAYOPT_DOWNSAMPLE32TO22));
; 669  :     HALFTRANSFORM_ONLY(iNonSupportedPlayerOpt &= ~(PLAYOPT_HALFTRANSFORM));
; 670  :     UPSAMPLE_ONLY(iNonSupportedPlayerOpt &= ~(PLAYOPT_UPSAMPLE));
; 671  :     PAD2XTRANSFORM_ONLY(iNonSupportedPlayerOpt &= ~(PLAYOPT_PAD2XTRANSFORM));
; 672  : 
; 673  :     if ( (iNonSupportedPlayerOpt & iPlayerOpt) || !fOKOptions[iPlayerOpt&0xF] )

  001a6	0f b7 45 f8	 movzx	 eax, WORD PTR _iNonSupportedPlayerOpt$[ebp]
  001aa	0f b7 4d 28	 movzx	 ecx, WORD PTR _iPlayerOpt$[ebp]
  001ae	23 c1		 and	 eax, ecx
  001b0	85 c0		 test	 eax, eax
  001b2	75 12		 jne	 SHORT $L2720
  001b4	0f b7 55 28	 movzx	 edx, WORD PTR _iPlayerOpt$[ebp]
  001b8	83 e2 0f	 and	 edx, 15			; 0000000fH
  001bb	0f be 82 00 00
	00 00		 movsx	 eax, BYTE PTR ?fOKOptions@?1??auInit_XDS@@9@9[edx]
  001c2	85 c0		 test	 eax, eax
  001c4	75 59		 jne	 SHORT $L2719
$L2720:

; 674  :     {
; 675  :         // Player has requested something that we didn't build 
; 676  :         // or wants an unsupported combination of options
; 677  :         wmaResult = TraceResult(WMA_E_NOTSUPPORTED);

  001c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_NOTSUPPORTED
  001cc	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  001d2	74 37		 je	 SHORT $L3333
  001d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_NOTSUPPORTED
  001da	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  001e0	74 29		 je	 SHORT $L3333
  001e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_NOTSUPPORTED
  001e7	50		 push	 eax
  001e8	68 a5 02 00 00	 push	 677			; 000002a5H
  001ed	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  001f2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  001f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_NOTSUPPORTED
  001fd	51		 push	 ecx
  001fe	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00203	83 c4 14	 add	 esp, 20			; 00000014H
  00206	89 45 ec	 mov	 DWORD PTR tv170[ebp], eax
  00209	eb 09		 jmp	 SHORT $L3334
$L3333:
  0020b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_NOTSUPPORTED
  00211	89 55 ec	 mov	 DWORD PTR tv170[ebp], edx
$L3334:
  00214	8b 45 ec	 mov	 eax, DWORD PTR tv170[ebp]
  00217	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 678  :         goto exit;

  0021a	e9 28 04 00 00	 jmp	 $exit$2711
$L2719:

; 679  :     }
; 680  : 
; 681  :     if ( (iPlayerOpt&(PLAYOPT_HALFTRANSFORM|PLAYOPT_PAD2XTRANSFORM))==(PLAYOPT_HALFTRANSFORM|PLAYOPT_PAD2XTRANSFORM) )

  0021f	0f b7 4d 28	 movzx	 ecx, WORD PTR _iPlayerOpt$[ebp]
  00223	83 e1 0a	 and	 ecx, 10			; 0000000aH
  00226	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00229	75 0b		 jne	 SHORT $L2721

; 682  :     {
; 683  :         // if in pad2X mode and a shift into the background sets half transform mode, do neither
; 684  :         iPlayerOpt &= ~(PLAYOPT_HALFTRANSFORM|PLAYOPT_PAD2XTRANSFORM);

  0022b	0f b7 55 28	 movzx	 edx, WORD PTR _iPlayerOpt$[ebp]
  0022f	83 e2 f5	 and	 edx, -11		; fffffff5H
  00232	66 89 55 28	 mov	 WORD PTR _iPlayerOpt$[ebp], dx
$L2721:

; 685  :     }
; 686  : 
; 687  : #if defined(INTERPOLATED_DOWNSAMPLE)
; 688  :     pau->m_fLowPass = WMAB_FALSE;
; 689  :     pau->m_fDownsample = WMAB_FALSE;
; 690  :     // 16000->11025 produces ticking sounds in tough_16m_16.  32000->22050 also produces ticking, but is less pronounced.
; 691  :     // if ((iPlayerOpt & PLAYOPT_DOWNSAMPLE32TO22) && (32000 == cSamplePerSec || 16000 == cSamplePerSec) )
; 692  :     if ((iPlayerOpt & PLAYOPT_DOWNSAMPLE32TO22) && (32000 == cSamplePerSec) )
; 693  :     {
; 694  :         pau->m_fLowPass = WMAB_TRUE;
; 695  :         pau->m_fDownsample = WMAB_TRUE;
; 696  :         // This works out to 32000=>22050 or 16000=>11025
; 697  :         prvInterpolateInit(pau, cSamplePerSec, 32000 == cSamplePerSec ? 22000 : 11000, 441); 
; 698  :     }
; 699  : #endif  // INTERPOLATED_DOWNSAMPLE
; 700  : 
; 701  : #if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
; 702  :     pau->m_fHalfTransform = WMAB_FALSE;
; 703  :     if (iPlayerOpt & PLAYOPT_HALFTRANSFORM)
; 704  :         pau->m_fHalfTransform = WMAB_TRUE;
; 705  : 
; 706  :     pau->m_fUpsample = WMAB_FALSE;
; 707  :     if (iPlayerOpt & PLAYOPT_UPSAMPLE)
; 708  :         pau->m_fUpsample = WMAB_TRUE;
; 709  : 
; 710  :     pau->m_fPad2XTransform = WMAB_FALSE;
; 711  :     if ((iPlayerOpt & PLAYOPT_PAD2XTRANSFORM)  && 22050 == cSamplePerSec)
; 712  :         pau->m_fPad2XTransform = WMAB_TRUE;
; 713  : #endif  // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
; 714  : 
; 715  :     //assign some basic parameters/mode
; 716  :     pau->m_iSamplingRate    = cSamplePerSec;

  00236	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00239	8b 4d 14	 mov	 ecx, DWORD PTR _cSamplePerSec$[ebp]
  0023c	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 717  :     pau->m_cChannel         = cChannel;

  0023f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00242	66 8b 45 18	 mov	 ax, WORD PTR _cChannel$[ebp]
  00246	66 89 42 58	 mov	 WORD PTR [edx+88], ax

; 718  :     pau->m_nBytePerSample   = sizeof (I16);

  0024a	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0024d	c7 41 5c 02 00
	00 00		 mov	 DWORD PTR [ecx+92], 2

; 719  : #ifdef WMA_V9
; 720  :     pau->m_nBytePerSample   = nBytePerSample;
; 721  :     pau->m_nValidBitsPerSample = nValidBitsPerSample;
; 722  :     pau->m_nChannelMask     = nChannelMask;
; 723  : #endif 
; 724  :     pau->m_cSubband         = cSubband;

  00254	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00257	8b 45 10	 mov	 eax, DWORD PTR _cSubband$[ebp]
  0025a	89 42 60	 mov	 DWORD PTR [edx+96], eax

; 725  :     pau->m_fltBitsPerSample  = (Float)(cBytePerSec*8.0f/(pau->m_iSamplingRate*pau->m_cChannel));    

  0025d	db 45 1c	 fild	 DWORD PTR _cBytePerSec$[ebp]
  00260	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41000000
  00266	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00269	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  0026d	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00270	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00273	0f af ca	 imul	 ecx, edx
  00276	89 4d e8	 mov	 DWORD PTR tv397[ebp], ecx
  00279	da 75 e8	 fidiv	 DWORD PTR tv397[ebp]
  0027c	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0027f	d9 5a 34	 fstp	 DWORD PTR [edx+52]

; 726  :     pau->m_fltWeightedBitsPerSample = pau->m_fltBitsPerSample;

  00282	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00285	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00288	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0028b	89 50 38	 mov	 DWORD PTR [eax+56], edx

; 727  :     // With the same QuantStep, the stereo is equivant to the mono with 1.6 times the bitrate/ch.
; 728  :     if (pau->m_cChannel > 1) 

  0028e	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00291	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  00295	83 f9 01	 cmp	 ecx, 1
  00298	7e 12		 jle	 SHORT $L2724

; 729  :         pau->m_fltWeightedBitsPerSample *= (Float) MSA_STEREO_WEIGHT;

  0029a	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0029d	d9 42 38	 fld	 DWORD PTR [edx+56]
  002a0	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3fcccccd
  002a6	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002a9	d9 58 38	 fstp	 DWORD PTR [eax+56]
$L2724:

; 730  : 
; 731  :     //decide secondary parameters
; 732  :     //first the frame sizes
; 733  :     pau->m_cFrameSample      = 2 * pau->m_cSubband;

  002ac	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002af	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  002b2	d1 e2		 shl	 edx, 1
  002b4	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002b7	89 90 18 03 00
	00		 mov	 DWORD PTR [eax+792], edx

; 734  :     pau->m_cFrameSampleHalf  = pau->m_cSubband;

  002bd	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002c0	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  002c3	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  002c6	89 81 1c 03 00
	00		 mov	 DWORD PTR [ecx+796], eax

; 735  :     pau->m_cFrameSampleQuad  = pau->m_cSubband / 2; 

  002cc	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002cf	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  002d2	99		 cdq
  002d3	2b c2		 sub	 eax, edx
  002d5	d1 f8		 sar	 eax, 1
  002d7	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  002da	89 82 20 03 00
	00		 mov	 DWORD PTR [edx+800], eax

; 736  : 
; 737  :     pau->m_cSubFrameSample      = pau->m_cFrameSample;

  002e0	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002e3	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002e6	8b 91 18 03 00
	00		 mov	 edx, DWORD PTR [ecx+792]
  002ec	89 90 98 00 00
	00		 mov	 DWORD PTR [eax+152], edx

; 738  :     pau->m_cSubFrameSampleHalf  = pau->m_cFrameSampleHalf;

  002f2	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002f5	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002f8	8b 91 1c 03 00
	00		 mov	 edx, DWORD PTR [ecx+796]
  002fe	89 90 9c 00 00
	00		 mov	 DWORD PTR [eax+156], edx

; 739  :     pau->m_cSubFrameSampleQuad  = pau->m_cFrameSampleQuad; 

  00304	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00307	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0030a	8b 91 20 03 00
	00		 mov	 edx, DWORD PTR [ecx+800]
  00310	89 90 a0 00 00
	00		 mov	 DWORD PTR [eax+160], edx

; 740  : 
; 741  :     pau->m_iCoefRecurQ1 = 0;

  00316	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00319	c7 80 8c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+908], 0

; 742  :     pau->m_iCoefRecurQ2 = pau->m_iCoefRecurQ3 = pau->m_cSubFrameSampleHalf;

  00323	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00326	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00329	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  0032f	89 81 94 03 00
	00		 mov	 DWORD PTR [ecx+916], eax
  00335	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00338	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0033b	8b 82 94 03 00
	00		 mov	 eax, DWORD PTR [edx+916]
  00341	89 81 90 03 00
	00		 mov	 DWORD PTR [ecx+912], eax

; 743  :     pau->m_iCoefRecurQ4 = pau->m_cSubFrameSample;

  00347	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0034a	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0034d	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  00353	89 81 98 03 00
	00		 mov	 DWORD PTR [ecx+920], eax

; 744  : 
; 745  :     //init now; but can be reassigned in each frame; if so, be careful with tran. det.
; 746  :     pau->m_cMinSubFrameSample    = pau->m_cSubFrameSample / pau->m_iMaxSubFrameDiv;

  00359	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0035c	8b 75 08	 mov	 esi, DWORD PTR _pau$[ebp]
  0035f	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  00365	99		 cdq
  00366	f7 be 80 00 00
	00		 idiv	 DWORD PTR [esi+128]
  0036c	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0036f	89 82 84 00 00
	00		 mov	 DWORD PTR [edx+132], eax

; 747  :     pau->m_cMinSubFrameSampleHalf= pau->m_cSubFrameSampleHalf / pau->m_iMaxSubFrameDiv;

  00375	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00378	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0037b	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [eax+156]
  00381	99		 cdq
  00382	f7 b9 80 00 00
	00		 idiv	 DWORD PTR [ecx+128]
  00388	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0038b	89 82 88 00 00
	00		 mov	 DWORD PTR [edx+136], eax

; 748  :     pau->m_cMinSubFrameSampleQuad= pau->m_cSubFrameSampleQuad / pau->m_iMaxSubFrameDiv; 

  00391	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00394	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00397	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [eax+160]
  0039d	99		 cdq
  0039e	f7 b9 80 00 00
	00		 idiv	 DWORD PTR [ecx+128]
  003a4	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003a7	89 82 8c 00 00
	00		 mov	 DWORD PTR [edx+140], eax

; 749  :     pau->m_cPossibleWinSize = LOG2 ((U32)pau->m_iMaxSubFrameDiv) + 1;

  003ad	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  003b0	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  003b6	51		 push	 ecx
  003b7	e8 00 00 00 00	 call	 _LOG2@4
  003bc	83 c0 01	 add	 eax, 1
  003bf	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003c2	89 82 90 00 00
	00		 mov	 DWORD PTR [edx+144], eax

; 750  :     pau->m_cBitsSubbandMax = LOG2 ((U32)pau->m_cSubband);

  003c8	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  003cb	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  003ce	51		 push	 ecx
  003cf	e8 00 00 00 00	 call	 _LOG2@4
  003d4	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003d7	89 82 14 03 00
	00		 mov	 DWORD PTR [edx+788], eax

; 751  : 
; 752  :     if(pau->m_iVersion == 1)

  003dd	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  003e0	83 78 44 01	 cmp	 DWORD PTR [eax+68], 1
  003e4	75 0f		 jne	 SHORT $L2728

; 753  :         pau->m_cLowCutOffLong    = LOW_CUTOFF_V1;                     //need investigation

  003e6	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  003e9	c7 81 2c 03 00
	00 03 00 00 00	 mov	 DWORD PTR [ecx+812], 3

; 754  :     else

  003f3	eb 0d		 jmp	 SHORT $L2729
$L2728:

; 755  :         pau->m_cLowCutOffLong    = LOW_CUTOFF;                        //need investigation

  003f5	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003f8	c7 82 2c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+812], 0
$L2729:

; 756  :     pau->m_cHighCutOffLong       = pau->m_cSubband - 9 * pau->m_cSubband / 100; //need investigation

  00402	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00405	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00408	6b c0 09	 imul	 eax, 9
  0040b	99		 cdq
  0040c	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00411	f7 f9		 idiv	 ecx
  00413	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00416	8b 4a 60	 mov	 ecx, DWORD PTR [edx+96]
  00419	2b c8		 sub	 ecx, eax
  0041b	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0041e	89 8a 30 03 00
	00		 mov	 DWORD PTR [edx+816], ecx

; 757  : 
; 758  :     //default
; 759  :     pau->m_cLowCutOff            = pau->m_cLowCutOffLong;

  00424	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00427	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0042a	8b 91 2c 03 00
	00		 mov	 edx, DWORD PTR [ecx+812]
  00430	89 90 24 03 00
	00		 mov	 DWORD PTR [eax+804], edx

; 760  :     pau->m_cHighCutOff           = pau->m_cHighCutOffLong;

  00436	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00439	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0043c	8b 91 30 03 00
	00		 mov	 edx, DWORD PTR [ecx+816]
  00442	89 90 28 03 00
	00		 mov	 DWORD PTR [eax+808], edx

; 761  : 
; 762  :     //set up some global coding condtions based on bitrate
; 763  :     pau->m_iEntropyMode = SIXTEENS_OB;                     //default

  00448	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0044b	c7 80 3c 03 00
	00 03 00 00 00	 mov	 DWORD PTR [eax+828], 3

; 764  : 
; 765  :     if (pau->m_fltWeightedBitsPerSample < 0.72f) {

  00455	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00458	d9 41 38	 fld	 DWORD PTR [ecx+56]
  0045b	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f3851ec
  00461	df e0		 fnstsw	 ax
  00463	f6 c4 05	 test	 ah, 5
  00466	7a 1b		 jp	 SHORT $L2730

; 766  :         if (pau->m_iSamplingRate >= 32000)

  00468	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0046b	81 7a 54 00 7d
	00 00		 cmp	 DWORD PTR [edx+84], 32000 ; 00007d00H
  00472	7c 0d		 jl	 SHORT $L2731

; 767  :             pau->m_iEntropyMode = FOURTYFOURS_QB;

  00474	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00477	c7 80 3c 03 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+828], 1
$L2731:

; 768  :     }
; 769  :     else if (pau->m_fltWeightedBitsPerSample < 1.16f) {

  00481	eb 2c		 jmp	 SHORT $L2732
$L2730:
  00483	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00486	d9 41 38	 fld	 DWORD PTR [ecx+56]
  00489	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f947ae1
  0048f	df e0		 fnstsw	 ax
  00491	f6 c4 05	 test	 ah, 5
  00494	7a 19		 jp	 SHORT $L2732

; 770  :         if (pau->m_iSamplingRate >= 32000)   {

  00496	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00499	81 7a 54 00 7d
	00 00		 cmp	 DWORD PTR [edx+84], 32000 ; 00007d00H
  004a0	7c 0d		 jl	 SHORT $L2732

; 771  :             pau->m_iEntropyMode = FOURTYFOURS_OB;

  004a2	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  004a5	c7 80 3c 03 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+828], 2
$L2732:

; 772  :         }
; 773  :     }
; 774  : 
; 775  : #if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
; 776  :     prvSetAdjustedValues(pau, WMAB_TRUE);
; 777  : #endif
; 778  : 
; 779  :     TRACEWMA_EXIT(wmaResult, prvAllocate (pau));

  004af	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  004b2	51		 push	 ecx
  004b3	e8 00 00 00 00	 call	 _prvAllocate_XDS@4
  004b8	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax
  004bb	83 7d fc 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  004bf	7d 45		 jge	 SHORT $L2737
  004c1	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  004c4	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  004ca	74 2f		 je	 SHORT $L3335
  004cc	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  004cf	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  004d5	74 24		 je	 SHORT $L3335
  004d7	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  004da	51		 push	 ecx
  004db	68 0b 03 00 00	 push	 779			; 0000030bH
  004e0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  004e5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  004ea	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  004ed	52		 push	 edx
  004ee	e8 00 00 00 00	 call	 _MyOutputDbgStr
  004f3	83 c4 14	 add	 esp, 20			; 00000014H
  004f6	89 45 e4	 mov	 DWORD PTR tv277[ebp], eax
  004f9	eb 06		 jmp	 SHORT $L3336
$L3335:
  004fb	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  004fe	89 45 e4	 mov	 DWORD PTR tv277[ebp], eax
$L3336:
  00501	e9 41 01 00 00	 jmp	 $exit$2711
$L2737:

; 780  : 
; 781  :     //initialize constants for packetization
; 782  :     pau->m_cBitPacketLength  = cbPacketLength * BITS_PER_BYTE;

  00506	8b 4d 20	 mov	 ecx, DWORD PTR _cbPacketLength$[ebp]
  00509	c1 e1 03	 shl	 ecx, 3
  0050c	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0050f	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 783  :     pau->m_cBitPackedFrameSize = LOG2 ((U32)ROUNDF (pau->m_fltBitsPerSample * pau->m_cFrameSampleHalf / 8.0F)) + 2;

  00512	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00515	db 80 1c 03 00
	00		 fild	 DWORD PTR [eax+796]
  0051b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0051e	d8 49 34	 fmul	 DWORD PTR [ecx+52]
  00521	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@41000000
  00527	51		 push	 ecx
  00528	d9 1c 24	 fstp	 DWORD PTR [esp]
  0052b	e8 00 00 00 00	 call	 @ROUNDF@4
  00530	50		 push	 eax
  00531	e8 00 00 00 00	 call	 _LOG2@4
  00536	83 c0 02	 add	 eax, 2
  00539	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0053c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 784  : //pau->m_cBitPackedFrameSize += 1;
; 785  :     pau->m_cBitPacketHeader   = NBITS_PACKET_CNT + NBITS_FRM_CNT + pau->m_cBitPackedFrameSize + 3;

  0053f	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00542	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00545	83 c1 0b	 add	 ecx, 11			; 0000000bH
  00548	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0054b	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 786  :     pau->m_cdwPacketHeader     = pau->m_cBitPacketHeader / BITS_PER_DWORD;

  0054e	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00551	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00554	99		 cdq
  00555	83 e2 1f	 and	 edx, 31			; 0000001fH
  00558	03 c2		 add	 eax, edx
  0055a	c1 f8 05	 sar	 eax, 5
  0055d	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00560	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 787  :     pau->m_cBitPacketHeaderFractionDw = pau->m_cBitPacketHeader % BITS_PER_DWORD;

  00563	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00566	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00569	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  0056e	79 05		 jns	 SHORT $L3345
  00570	48		 dec	 eax
  00571	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00574	40		 inc	 eax
$L3345:
  00575	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00578	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 788  :     pau->m_iPacketCurr = 0;

  0057b	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0057e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 789  : 
; 790  : #ifdef ENABLE_ALL_ENCOPT
; 791  : #ifdef ENABLE_LPC
; 792  :     prvInitInverseQuadRootTable(pau);    

  00585	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00588	50		 push	 eax
  00589	e8 00 00 00 00	 call	 _prvInitInverseQuadRootTable_XDS@4

; 793  : #endif  // ENABLE_LPC
; 794  : 
; 795  :     if (pau->m_iWeightingMode == BARK_MODE) 

  0058e	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00591	83 b9 34 03 00
	00 01		 cmp	 DWORD PTR [ecx+820], 1
  00598	75 27		 jne	 SHORT $L2739

; 796  :     {
; 797  :         if (!pau->m_fNoiseSub)   

  0059a	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0059d	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  005a1	75 0f		 jne	 SHORT $L2740

; 798  :             pau->aupfnInverseQuantize = NULL;

  005a3	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  005a6	c7 80 ec 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1004], 0

; 799  :         else

  005b0	eb 0d		 jmp	 SHORT $L2742
$L2740:

; 800  :             pau->aupfnInverseQuantize = prvInverseQuantizeMidRate;

  005b2	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  005b5	c7 81 ec 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1004], OFFSET FLAT:_prvInverseQuantizeMidRate_XDS@12
$L2742:

; 801  :     }
; 802  :     else

  005bf	eb 0d		 jmp	 SHORT $L2743
$L2739:

; 803  :         pau->aupfnInverseQuantize = prvInverseQuantizeLowRate;

  005c1	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  005c4	c7 82 ec 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1004], OFFSET FLAT:_prvInverseQuantizeLowRate_XDS@12
$L2743:

; 804  : #endif  // ENABLE_ALL_ENCOPT
; 805  : 
; 806  :     pau->m_iFrameNumber = 0;

  005ce	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  005d1	c7 80 e8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1000], 0

; 807  : 
; 808  :     pau->aupfnReconstruct = auReconstruct;

  005db	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  005de	c7 81 f8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1016], OFFSET FLAT:_auReconstruct_XDS@16

; 809  : 
; 810  : #if !(defined( WMA_TARGET_MIPS ) && defined( BUILD_INTEGER ))
; 811  :     pau->aupfnDctIV = auDctIV;

  005e8	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  005eb	c7 82 fc 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1020], OFFSET FLAT:_auDctIV_XDS@16

; 812  :     pau->aupfnFFT = prvFFT4DCT;

  005f5	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  005f8	c7 80 00 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1024], OFFSET FLAT:_prvFFT4DCT_XDS@8

; 813  : #endif
; 814  : 
; 815  :     
; 816  : #if !defined(_Embedded_x86)
; 817  : #if defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE))
; 818  :     // auInitIntelFFT call checks CPU abilities for us (MMX, SIMD, etc)
; 819  :     //wmaResult = auInitIntelFFT(pau, INTELFFT_INIT_PROCESS);
; 820  :     if (WMA_SUCCEEDED(wmaResult))
; 821  :     {
; 822  :         pau->aupfnFFT = prvFFT4DCT_INTEL;
; 823  :         pau->m_fIntelFFT = WMAB_FALSE;
; 824  :     }
; 825  : 
; 826  :     // Failure means no applicable optimizations. This isn't a fatal error, so suppress it.
; 827  :     wmaResult = WMA_OK;
; 828  : 
; 829  : #endif  // WMA_TARGET_X86 && !BUILD_INTEGER
; 830  : #endif
; 831  : 
; 832  : #ifdef USE_SIN_COS_TABLES
; 833  : #ifdef WMA_TARGET_X86
; 834  : #if 0 //def BUILD_INTEGER
; 835  :       //This function has been removed because of a streaming mode bug that is can be reproduced
; 836  :       //by setting the streaming mode buffer to 2003
; 837  :     if (g_SupportMMX()){
; 838  :         pau->aupfnReconstruct = auReconstruct_MMX;
; 839  :     }
; 840  : #endif //BUILD_INTEGER
; 841  : 
; 842  : #ifdef BUILD_INT_FLOAT
; 843  : 
; 844  :     pau->aupfnReconstruct = auReconstruct_X86;

  00602	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00605	c7 81 f8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1016], OFFSET FLAT:_auReconstruct_X86_XDS@16

; 845  :     if (pau->m_cChannel==2) {

  0060f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00612	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  00616	83 f8 02	 cmp	 eax, 2
  00619	75 2c		 jne	 SHORT $exit$2711

; 846  :         if (g_SupportMMX()) 

  0061b	e8 00 00 00 00	 call	 _g_SupportMMX_XDS@0
  00620	85 c0		 test	 eax, eax
  00622	74 0d		 je	 SHORT $L2745

; 847  :             pau->aupfnReconstruct = auReconStereo_MMX;

  00624	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00627	c7 81 f8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1016], OFFSET FLAT:_auReconStereo_MMX_XDS@16
$L2745:

; 848  : 
; 849  :         if (g_SupportSIMD_FP()) 

  00631	e8 00 00 00 00	 call	 _g_SupportSIMD_FP_XDS@0
  00636	85 c0		 test	 eax, eax
  00638	74 0d		 je	 SHORT $exit$2711

; 850  :             pau->aupfnReconstruct = auReconStereo_SIMDFP;

  0063a	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0063d	c7 82 f8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1016], OFFSET FLAT:_auReconStereo_SIMDFP_XDS@16
$exit$2711:

; 851  :     }
; 852  : 
; 853  : #endif //BUILD_INT_FLOAT
; 854  : 
; 855  : #else  
; 856  : #pragma message( "Warning! USE_SIN_COS_TABLES defined but no functions are using them. See X86.c for prototype functions." ) 
; 857  : #endif //WMA_TARGET_X86
; 858  : #endif //USE_SIN_COS_TABLES
; 859  : 
; 860  : #ifdef WMA_TARGET_MIPS
; 861  : #   ifdef BUILD_INTEGER
; 862  :         auInitMIPS(pau);
; 863  : #   endif //BUILD_INTEGER
; 864  : #endif //WMA_TARGET_MIPS
; 865  : 
; 866  : exit:
; 867  :     return wmaResult;

  00647	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 868  : }

  0064a	5e		 pop	 esi
  0064b	8b e5		 mov	 esp, ebp
  0064d	5d		 pop	 ebp
  0064e	c2 24 00	 ret	 36			; 00000024H
_auInit_XDS@36 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\x86\macros.h
WMADEC	ENDS
;	COMDAT @ROUNDF@4
WMADEC	SEGMENT
_intval$ = -8
_f$ = 8
@ROUNDF@4 PROC NEAR					; COMDAT

; 35   : INLINE Int FASTCALL ROUNDF(float f) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 36   :     __int64 intval;
; 37   :     _asm {
; 38   :         fld         f

  00006	d9 45 08	 fld	 DWORD PTR _f$[ebp]

; 39   :         fistp       dword ptr [intval]

  00009	db 5d f8	 fistp	 DWORD PTR _intval$[ebp]

; 40   :         mov         eax,dword ptr [intval]

  0000c	8b 45 f8	 mov	 eax, DWORD PTR _intval$[ebp]

; 41   :     }
; 42   : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
@ROUNDF@4 ENDP
WMADEC	ENDS
PUBLIC	_prvSetBarkIndex_XDS@4
PUBLIC	__real@4000000000000000
EXTRN	_prvInitNoiseSub_XDS@4:NEAR
EXTRN	_sqrt:NEAR
EXTRN	_g_SinTableForReconstruction:BYTE
;	COMDAT __real@4000000000000000
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\msaudio.c
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _prvAllocate_XDS@4
WMADEC	SEGMENT
tv273 = -44
tv250 = -40
tv229 = -36
tv209 = -32
tv193 = -28
tv168 = -24
tv143 = -20
tv128 = -16
_c_iSizeOfPrevOutput$ = -12
_c_iSizeOfPrevOutputSign$ = -8
_wmaResult$ = -4
_pau$ = 8
_prvAllocate_XDS@4 PROC NEAR				; COMDAT

; 880  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 881  :     WMARESULT   wmaResult = WMA_OK;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000b	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 882  : 
; 883  :     const int c_iSizeOfPrevOutput = pau->m_nBytePerSample * DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel;

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00011	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00014	8b 41 5c	 mov	 eax, DWORD PTR [ecx+92]
  00017	0f af 82 1c 03
	00 00		 imul	 eax, DWORD PTR [edx+796]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00021	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  00025	0f af c2	 imul	 eax, edx
  00028	89 45 f4	 mov	 DWORD PTR _c_iSizeOfPrevOutput$[ebp], eax

; 884  : #ifndef PREVOUTPUT_16BITS
; 885  :     const int c_iSizeOfPrevOutputSign = DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel / BITS_PER_BYTE 
; 886  :                                         + pau->m_cChannel * pau->m_nBytePerSample; //wchen: not sure what this is for; but needed

  0002b	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0002e	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  00032	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00035	8b 82 1c 03 00
	00		 mov	 eax, DWORD PTR [edx+796]
  0003b	0f af c1	 imul	 eax, ecx
  0003e	99		 cdq
  0003f	83 e2 07	 and	 edx, 7
  00042	03 c2		 add	 eax, edx
  00044	c1 f8 03	 sar	 eax, 3
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0004a	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00051	0f af 51 5c	 imul	 edx, DWORD PTR [ecx+92]
  00055	03 c2		 add	 eax, edx
  00057	89 45 f8	 mov	 DWORD PTR _c_iSizeOfPrevOutputSign$[ebp], eax

; 887  : #else 
; 888  :     const int c_iSizeOfPrevOutputSign = 0;
; 889  : #endif
; 890  : 
; 891  :     pau->m_rgpcinfo = (PerChannelInfo*) auMalloc (sizeof (PerChannelInfo) * pau->m_cChannel);

  0005a	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0005d	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  00061	6b c0 70	 imul	 eax, 112		; 00000070H
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _auMalloc_XDS@4
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0006d	89 81 a0 03 00
	00		 mov	 DWORD PTR [ecx+928], eax

; 892  :     if(pau->m_rgpcinfo == NULL)

  00073	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00076	83 ba a0 03 00
	00 00		 cmp	 DWORD PTR [edx+928], 0
  0007d	75 58		 jne	 SHORT $L2756

; 893  :     {
; 894  :         wmaResult = TraceResult(WMA_E_OUTOFMEMORY);

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  00084	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  0008a	74 37		 je	 SHORT $L3352
  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  00092	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  00098	74 29		 je	 SHORT $L3352
  0009a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  000a0	52		 push	 edx
  000a1	68 7e 03 00 00	 push	 894			; 0000037eH
  000a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  000ab	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _MyOutputDbgStr
  000bb	83 c4 14	 add	 esp, 20			; 00000014H
  000be	89 45 f0	 mov	 DWORD PTR tv128[ebp], eax
  000c1	eb 09		 jmp	 SHORT $L3353
$L3352:
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  000c9	89 4d f0	 mov	 DWORD PTR tv128[ebp], ecx
$L3353:
  000cc	8b 55 f0	 mov	 edx, DWORD PTR tv128[ebp]
  000cf	89 55 fc	 mov	 DWORD PTR _wmaResult$[ebp], edx

; 895  :         goto exit;

  000d2	e9 9c 04 00 00	 jmp	 $exit$2757
$L2756:

; 896  :     }
; 897  : 
; 898  :     pau->m_piPrevOutput = (I16*) auMalloc (c_iSizeOfPrevOutput + c_iSizeOfPrevOutputSign);

  000d7	8b 45 f4	 mov	 eax, DWORD PTR _c_iSizeOfPrevOutput$[ebp]
  000da	03 45 f8	 add	 eax, DWORD PTR _c_iSizeOfPrevOutputSign$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _auMalloc_XDS@4
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000e6	89 81 b4 03 00
	00		 mov	 DWORD PTR [ecx+948], eax

; 899  :     if (pau->m_piPrevOutput == NULL)

  000ec	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000ef	83 ba b4 03 00
	00 00		 cmp	 DWORD PTR [edx+948], 0
  000f6	75 58		 jne	 SHORT $L2760

; 900  :     {
; 901  :         wmaResult = TraceResult(WMA_E_OUTOFMEMORY);

  000f8	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  000fd	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00103	74 37		 je	 SHORT $L3354
  00105	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  0010b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  00111	74 29		 je	 SHORT $L3354
  00113	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  00119	52		 push	 edx
  0011a	68 85 03 00 00	 push	 901			; 00000385H
  0011f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  00124	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00129	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00134	83 c4 14	 add	 esp, 20			; 00000014H
  00137	89 45 ec	 mov	 DWORD PTR tv143[ebp], eax
  0013a	eb 09		 jmp	 SHORT $L3355
$L3354:
  0013c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  00142	89 4d ec	 mov	 DWORD PTR tv143[ebp], ecx
$L3355:
  00145	8b 55 ec	 mov	 edx, DWORD PTR tv143[ebp]
  00148	89 55 fc	 mov	 DWORD PTR _wmaResult$[ebp], edx

; 902  :         goto exit;

  0014b	e9 23 04 00 00	 jmp	 $exit$2757
$L2760:

; 903  :     }
; 904  :     memset (pau->m_piPrevOutput, 0, c_iSizeOfPrevOutput + c_iSizeOfPrevOutputSign);

  00150	8b 45 f4	 mov	 eax, DWORD PTR _c_iSizeOfPrevOutput$[ebp]
  00153	03 45 f8	 add	 eax, DWORD PTR _c_iSizeOfPrevOutputSign$[ebp]
  00156	50		 push	 eax
  00157	6a 00		 push	 0
  00159	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0015c	8b 91 b4 03 00
	00		 mov	 edx, DWORD PTR [ecx+948]
  00162	52		 push	 edx
  00163	e8 00 00 00 00	 call	 _memset
  00168	83 c4 0c	 add	 esp, 12			; 0000000cH

; 905  : 
; 906  :     pau->m_rgiCoefReconOrig     = (Int*) mallocAligned (sizeof (Int) *
; 907  :         DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * pau->m_cChannel, 32);

  0016b	6a 20		 push	 32			; 00000020H
  0016d	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00170	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00173	c1 e1 02	 shl	 ecx, 2
  00176	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00179	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  0017d	0f af c8	 imul	 ecx, eax
  00180	51		 push	 ecx
  00181	e8 00 00 00 00	 call	 _mallocAligned_XDS@8
  00186	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00189	89 81 a4 03 00
	00		 mov	 DWORD PTR [ecx+932], eax

; 908  :     if (pau->m_rgiCoefReconOrig == NULL)

  0018f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00192	83 ba a4 03 00
	00 00		 cmp	 DWORD PTR [edx+932], 0
  00199	75 58		 jne	 SHORT $L2764

; 909  :     {
; 910  :         wmaResult = TraceResult(WMA_E_OUTOFMEMORY);

  0019b	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  001a0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  001a6	74 37		 je	 SHORT $L3356
  001a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  001ae	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  001b4	74 29		 je	 SHORT $L3356
  001b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  001bc	52		 push	 edx
  001bd	68 8e 03 00 00	 push	 910			; 0000038eH
  001c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  001c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  001cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 _MyOutputDbgStr
  001d7	83 c4 14	 add	 esp, 20			; 00000014H
  001da	89 45 e8	 mov	 DWORD PTR tv168[ebp], eax
  001dd	eb 09		 jmp	 SHORT $L3357
$L3356:
  001df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  001e5	89 4d e8	 mov	 DWORD PTR tv168[ebp], ecx
$L3357:
  001e8	8b 55 e8	 mov	 edx, DWORD PTR tv168[ebp]
  001eb	89 55 fc	 mov	 DWORD PTR _wmaResult$[ebp], edx

; 911  :         goto exit;

  001ee	e9 80 03 00 00	 jmp	 $exit$2757
$L2764:

; 912  :     }
; 913  :     memset (pau->m_rgiCoefReconOrig, 0, 
; 914  :             sizeof (Int) * DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * pau->m_cChannel);    

  001f3	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001f6	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  001f9	c1 e1 02	 shl	 ecx, 2
  001fc	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  001ff	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  00203	0f af c8	 imul	 ecx, eax
  00206	51		 push	 ecx
  00207	6a 00		 push	 0
  00209	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0020c	8b 91 a4 03 00
	00		 mov	 edx, DWORD PTR [ecx+932]
  00212	52		 push	 edx
  00213	e8 00 00 00 00	 call	 _memset
  00218	83 c4 0c	 add	 esp, 12			; 0000000cH

; 915  : 
; 916  :     pau->m_rgcValidBarkBand  = (Int*) auMalloc (sizeof (Int) * pau->m_cPossibleWinSize);

  0021b	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0021e	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00224	c1 e1 02	 shl	 ecx, 2
  00227	51		 push	 ecx
  00228	e8 00 00 00 00	 call	 _auMalloc_XDS@4
  0022d	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00230	89 82 ac 03 00
	00		 mov	 DWORD PTR [edx+940], eax

; 917  :     if (pau->m_rgcValidBarkBand == NULL)

  00236	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00239	83 b8 ac 03 00
	00 00		 cmp	 DWORD PTR [eax+940], 0
  00240	75 59		 jne	 SHORT $L2769

; 918  :     {
; 919  :         wmaResult = TraceResult(WMA_E_OUTOFMEMORY);

  00242	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  00248	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  0024e	74 37		 je	 SHORT $L3358
  00250	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  00256	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  0025c	74 29		 je	 SHORT $L3358
  0025e	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  00263	50		 push	 eax
  00264	68 97 03 00 00	 push	 919			; 00000397H
  00269	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  0026e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00273	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  00279	51		 push	 ecx
  0027a	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0027f	83 c4 14	 add	 esp, 20			; 00000014H
  00282	89 45 e4	 mov	 DWORD PTR tv193[ebp], eax
  00285	eb 09		 jmp	 SHORT $L3359
$L3358:
  00287	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  0028d	89 55 e4	 mov	 DWORD PTR tv193[ebp], edx
$L3359:
  00290	8b 45 e4	 mov	 eax, DWORD PTR tv193[ebp]
  00293	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 920  :         goto exit;

  00296	e9 d8 02 00 00	 jmp	 $exit$2757
$L2769:

; 921  :     }
; 922  : 
; 923  :     pau->m_rgiBarkIndexOrig = (Int*) auMalloc (sizeof (Int) * (NUM_BARK_BAND + 1) * pau->m_cPossibleWinSize); //+1 : including bottom and top end

  0029b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0029e	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  002a4	6b d2 68	 imul	 edx, 104		; 00000068H
  002a7	52		 push	 edx
  002a8	e8 00 00 00 00	 call	 _auMalloc_XDS@4
  002ad	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002b0	89 81 b0 03 00
	00		 mov	 DWORD PTR [ecx+944], eax

; 924  :     if (pau->m_rgiBarkIndexOrig == NULL)

  002b6	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  002b9	83 ba b0 03 00
	00 00		 cmp	 DWORD PTR [edx+944], 0
  002c0	75 58		 jne	 SHORT $L2773

; 925  :     {
; 926  :         wmaResult = TraceResult(WMA_E_OUTOFMEMORY);

  002c2	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  002c7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  002cd	74 37		 je	 SHORT $L3360
  002cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  002d5	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  002db	74 29		 je	 SHORT $L3360
  002dd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  002e3	52		 push	 edx
  002e4	68 9e 03 00 00	 push	 926			; 0000039eH
  002e9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  002ee	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  002f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  002f8	50		 push	 eax
  002f9	e8 00 00 00 00	 call	 _MyOutputDbgStr
  002fe	83 c4 14	 add	 esp, 20			; 00000014H
  00301	89 45 e0	 mov	 DWORD PTR tv209[ebp], eax
  00304	eb 09		 jmp	 SHORT $L3361
$L3360:
  00306	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  0030c	89 4d e0	 mov	 DWORD PTR tv209[ebp], ecx
$L3361:
  0030f	8b 55 e0	 mov	 edx, DWORD PTR tv209[ebp]
  00312	89 55 fc	 mov	 DWORD PTR _wmaResult$[ebp], edx

; 927  :         goto exit;

  00315	e9 59 02 00 00	 jmp	 $exit$2757
$L2773:

; 928  :     }
; 929  :     
; 930  :     prvSetBarkIndex (pau);

  0031a	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0031d	50		 push	 eax
  0031e	e8 00 00 00 00	 call	 _prvSetBarkIndex_XDS@4

; 931  :     pau->m_rgiMaskQ         = (Int*) auMalloc (sizeof (Int) * pau->m_cValidBarkBand * pau->m_cChannel);

  00323	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00326	8b 91 50 03 00
	00		 mov	 edx, DWORD PTR [ecx+848]
  0032c	c1 e2 02	 shl	 edx, 2
  0032f	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00332	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  00336	0f af d1	 imul	 edx, ecx
  00339	52		 push	 edx
  0033a	e8 00 00 00 00	 call	 _auMalloc_XDS@4
  0033f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00342	89 82 a8 03 00
	00		 mov	 DWORD PTR [edx+936], eax

; 932  :     if (pau->m_rgiMaskQ == NULL)

  00348	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0034b	83 b8 a8 03 00
	00 00		 cmp	 DWORD PTR [eax+936], 0
  00352	75 59		 jne	 SHORT $L2777

; 933  :     {
; 934  :         wmaResult = TraceResult(WMA_E_OUTOFMEMORY);

  00354	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  0035a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  00360	74 37		 je	 SHORT $L3362
  00362	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  00368	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  0036e	74 29		 je	 SHORT $L3362
  00370	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  00375	50		 push	 eax
  00376	68 a6 03 00 00	 push	 934			; 000003a6H
  0037b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  00380	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00385	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  0038b	51		 push	 ecx
  0038c	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00391	83 c4 14	 add	 esp, 20			; 00000014H
  00394	89 45 dc	 mov	 DWORD PTR tv229[ebp], eax
  00397	eb 09		 jmp	 SHORT $L3363
$L3362:
  00399	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  0039f	89 55 dc	 mov	 DWORD PTR tv229[ebp], edx
$L3363:
  003a2	8b 45 dc	 mov	 eax, DWORD PTR tv229[ebp]
  003a5	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 935  :         goto exit;

  003a8	e9 c6 01 00 00	 jmp	 $exit$2757
$L2777:

; 936  :     }
; 937  : 
; 938  :     //for v2 it has to be dynamically decided
; 939  :     if (pau->m_iVersion == 1) 

  003ad	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  003b0	83 79 44 01	 cmp	 DWORD PTR [ecx+68], 1
  003b4	75 23		 jne	 SHORT $L2778

; 940  :         pau->m_fltDctScale = (Float) sqrt (2.0 / pau->m_cSubbandAdjusted);

  003b6	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003b9	db 42 60	 fild	 DWORD PTR [edx+96]
  003bc	dc 3d 00 00 00
	00		 fdivr	 QWORD PTR __real@4000000000000000
  003c2	83 ec 08	 sub	 esp, 8
  003c5	dd 1c 24	 fstp	 QWORD PTR [esp]
  003c8	e8 00 00 00 00	 call	 _sqrt
  003cd	83 c4 08	 add	 esp, 8
  003d0	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  003d3	d9 98 4c 03 00
	00		 fstp	 DWORD PTR [eax+844]
$L2778:

; 941  : 
; 942  : 
; 943  : #ifdef ENABLE_ALL_ENCOPT
; 944  :     // find the region to apply noise subsitution, in the frequencies...
; 945  :     TRACEWMA_EXIT(wmaResult, prvInitNoiseSub (pau));

  003d9	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  003dc	51		 push	 ecx
  003dd	e8 00 00 00 00	 call	 _prvInitNoiseSub_XDS@4
  003e2	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax
  003e5	83 7d fc 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  003e9	7d 45		 jge	 SHORT $L2782
  003eb	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  003ee	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  003f4	74 2f		 je	 SHORT $L3364
  003f6	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  003f9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  003ff	74 24		 je	 SHORT $L3364
  00401	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00404	51		 push	 ecx
  00405	68 b1 03 00 00	 push	 945			; 000003b1H
  0040a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  0040f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00414	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00417	52		 push	 edx
  00418	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0041d	83 c4 14	 add	 esp, 20			; 00000014H
  00420	89 45 d8	 mov	 DWORD PTR tv250[ebp], eax
  00423	eb 06		 jmp	 SHORT $L3365
$L3364:
  00425	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00428	89 45 d8	 mov	 DWORD PTR tv250[ebp], eax
$L3365:
  0042b	e9 43 01 00 00	 jmp	 $exit$2757
$L2782:

; 946  : 
; 947  : #if defined(_DEBUG) && defined(LPC_COMPARE)
; 948  :     if (pau->m_iWeightingMode == LPC_MODE) {
; 949  :         Int i;
; 950  :         for (i = 0; i < LPCORDER; i++)  {
; 951  :             pau->m_rgfltLpsSpecCos [i] = NULL;
; 952  :             pau->m_rgfltLpsSpecSin [i] = NULL;
; 953  :         }
; 954  :     }
; 955  : #endif
; 956  : 
; 957  :     if (pau->m_iWeightingMode == LPC_MODE && pau->m_rguiWeightFactor==NULL)

  00430	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00433	83 b9 34 03 00
	00 00		 cmp	 DWORD PTR [ecx+820], 0
  0043a	0f 85 96 00 00
	00		 jne	 $L2784
  00440	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00443	83 ba e4 03 00
	00 00		 cmp	 DWORD PTR [edx+996], 0
  0044a	0f 85 86 00 00
	00		 jne	 $L2784

; 958  :     {
; 959  :         pau->m_rguiWeightFactor = (UInt*) auMalloc (sizeof (UInt) * DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * pau->m_cChannel);

  00450	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00453	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00456	c1 e1 02	 shl	 ecx, 2
  00459	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0045c	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  00460	0f af c8	 imul	 ecx, eax
  00463	51		 push	 ecx
  00464	e8 00 00 00 00	 call	 _auMalloc_XDS@4
  00469	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0046c	89 81 e4 03 00
	00		 mov	 DWORD PTR [ecx+996], eax

; 960  :         if (pau->m_rguiWeightFactor == NULL)

  00472	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00475	83 ba e4 03 00
	00 00		 cmp	 DWORD PTR [edx+996], 0
  0047c	75 58		 jne	 SHORT $L2784

; 961  :         {
; 962  :             wmaResult = TraceResult(WMA_E_OUTOFMEMORY);

  0047e	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  00483	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00489	74 37		 je	 SHORT $L3366
  0048b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  00491	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  00497	74 29		 je	 SHORT $L3366
  00499	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  0049f	52		 push	 edx
  004a0	68 c2 03 00 00	 push	 962			; 000003c2H
  004a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  004aa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  004af	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  004b4	50		 push	 eax
  004b5	e8 00 00 00 00	 call	 _MyOutputDbgStr
  004ba	83 c4 14	 add	 esp, 20			; 00000014H
  004bd	89 45 d4	 mov	 DWORD PTR tv273[ebp], eax
  004c0	eb 09		 jmp	 SHORT $L3367
$L3366:
  004c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  004c8	89 4d d4	 mov	 DWORD PTR tv273[ebp], ecx
$L3367:
  004cb	8b 55 d4	 mov	 edx, DWORD PTR tv273[ebp]
  004ce	89 55 fc	 mov	 DWORD PTR _wmaResult$[ebp], edx

; 963  :             goto exit;

  004d1	e9 9d 00 00 00	 jmp	 $exit$2757
$L2784:

; 964  :         }
; 965  :     }
; 966  : 
; 967  : #endif // ENABLE_ALL_ENCOPT
; 968  : 
; 969  : #ifdef USE_SIN_COS_TABLES          
; 970  :         pau->m_piSinForRecon2048 = (BP2Type*)g_SinTableForReconstruction;

  004d6	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  004d9	c7 80 10 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1040], OFFSET FLAT:_g_SinTableForReconstruction

; 971  :         pau->m_piSinForRecon1024 = pau->m_piSinForRecon2048+2048;

  004e3	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  004e6	8b 91 10 04 00
	00		 mov	 edx, DWORD PTR [ecx+1040]
  004ec	81 c2 00 20 00
	00		 add	 edx, 8192		; 00002000H
  004f2	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  004f5	89 90 14 04 00
	00		 mov	 DWORD PTR [eax+1044], edx

; 972  :         pau->m_piSinForRecon512  = pau->m_piSinForRecon1024+1024;

  004fb	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  004fe	8b 91 14 04 00
	00		 mov	 edx, DWORD PTR [ecx+1044]
  00504	81 c2 00 10 00
	00		 add	 edx, 4096		; 00001000H
  0050a	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0050d	89 90 18 04 00
	00		 mov	 DWORD PTR [eax+1048], edx

; 973  :         pau->m_piSinForRecon256  = pau->m_piSinForRecon512+512;

  00513	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00516	8b 91 18 04 00
	00		 mov	 edx, DWORD PTR [ecx+1048]
  0051c	81 c2 00 08 00
	00		 add	 edx, 2048		; 00000800H
  00522	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00525	89 90 1c 04 00
	00		 mov	 DWORD PTR [eax+1052], edx

; 974  :         pau->m_piSinForRecon128  = pau->m_piSinForRecon256+256;

  0052b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0052e	8b 91 1c 04 00
	00		 mov	 edx, DWORD PTR [ecx+1052]
  00534	81 c2 00 04 00
	00		 add	 edx, 1024		; 00000400H
  0053a	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0053d	89 90 20 04 00
	00		 mov	 DWORD PTR [eax+1056], edx

; 975  :         pau->m_piSinForRecon64   = pau->m_piSinForRecon128+128;

  00543	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00546	8b 91 20 04 00
	00		 mov	 edx, DWORD PTR [ecx+1056]
  0054c	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  00552	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00555	89 90 24 04 00
	00		 mov	 DWORD PTR [eax+1060], edx

; 976  : 
; 977  :         pau->m_piSinForSaveHistory = pau->m_piSinForRecon2048+2048;

  0055b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0055e	8b 91 10 04 00
	00		 mov	 edx, DWORD PTR [ecx+1040]
  00564	81 c2 00 20 00
	00		 add	 edx, 8192		; 00002000H
  0056a	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0056d	89 90 2c 04 00
	00		 mov	 DWORD PTR [eax+1068], edx
$exit$2757:

; 978  : #endif
; 979  : exit:
; 980  :     return wmaResult;

  00573	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 981  : }

  00576	8b e5		 mov	 esp, ebp
  00578	5d		 pop	 ebp
  00579	c2 04 00	 ret	 4
_prvAllocate_XDS@4 ENDP
WMADEC	ENDS
PUBLIC	__real@3f800000
PUBLIC	__real@3f000000
PUBLIC	__real@40000000
PUBLIC	__real@40800000
EXTRN	_g_rgiBarkFreq:BYTE
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _prvSetBarkIndex_XDS@4
WMADEC	SEGMENT
tv299 = -52
tv528 = -48
tv362 = -44
_iCurr$2832 = -40
_fltTemp$2829 = -36
_iFreqCurr$2831 = -32
_iIndex$2830 = -28
_bCombined$ = -24
_iWin$ = -20
_piBarkIndex$ = -16
_cFrameSample$ = -12
_fltSamplingPeriod$ = -8
_i$ = -4
_pau$ = 8
_prvSetBarkIndex_XDS@4 PROC NEAR			; COMDAT

; 991  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	56		 push	 esi

; 992  :     Int i, iWin;
; 993  :     Float fltSamplingPeriod;
; 994  : 
; 995  :     Int *piBarkIndex;
; 996  :     Int cFrameSample;
; 997  :     Bool bCombined;
; 998  : 
; 999  :     //calculate index of each bark freq
; 1000 :     fltSamplingPeriod = 1.0F / pau->m_iSamplingRate;

  00007	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0000a	db 40 54	 fild	 DWORD PTR [eax+84]
  0000d	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@3f800000
  00013	d9 5d f8	 fstp	 DWORD PTR _fltSamplingPeriod$[ebp]

; 1001 :     // wchen: we need to think what to do with the cut off frequencies: not include at all or include zeros.
; 1002 :     //for long window
; 1003 :     piBarkIndex = pau->m_rgiBarkIndexOrig;

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00019	8b 91 b0 03 00
	00		 mov	 edx, DWORD PTR [ecx+944]
  0001f	89 55 f0	 mov	 DWORD PTR _piBarkIndex$[ebp], edx

; 1004 : 
; 1005 :     // for the v1 compatibility
; 1006 :     if(pau->m_iVersion == 1)

  00022	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00025	83 78 44 01	 cmp	 DWORD PTR [eax+68], 1
  00029	0f 85 ab 00 00
	00		 jne	 $L2799

; 1007 :     {
; 1008 :         assert(pau->m_cPossibleWinSize == 1);
; 1009 : 
; 1010 :         // set up the bark index
; 1011 :         piBarkIndex[0] = 0;

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00032	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1012 :         for (i = 0; i < NUM_BARK_BAND; i++)

  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0003f	eb 09		 jmp	 SHORT $L2800
$L2801:
  00041	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00044	83 c2 01	 add	 edx, 1
  00047	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L2800:
  0004a	83 7d fc 19	 cmp	 DWORD PTR _i$[ebp], 25	; 00000019H
  0004e	0f 8d 81 00 00
	00		 jge	 $L2802

; 1013 :         {
; 1014 :             piBarkIndex [i + 1] = (Int) ftoi(g_rgiBarkFreq [i] * pau->m_cFrameSample * 
; 1015 :                                          fltSamplingPeriod + 0.5f); //open end

  00054	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00057	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR _g_rgiBarkFreq[eax*2]
  0005f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00062	0f af 8a 18 03
	00 00		 imul	 ecx, DWORD PTR [edx+792]
  00069	89 4d d4	 mov	 DWORD PTR tv362[ebp], ecx
  0006c	db 45 d4	 fild	 DWORD PTR tv362[ebp]
  0006f	d8 4d f8	 fmul	 DWORD PTR _fltSamplingPeriod$[ebp]
  00072	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f000000
  00078	51		 push	 ecx
  00079	d9 1c 24	 fstp	 DWORD PTR [esp]
  0007c	e8 00 00 00 00	 call	 _FloatToLong@4
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00084	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00087	89 44 8a 04	 mov	 DWORD PTR [edx+ecx*4+4], eax

; 1016 :             assert (piBarkIndex [i + 1]);
; 1017 :             if (piBarkIndex [i + 1] > pau->m_cFrameSample / 2)

  0008b	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0008e	8b 80 18 03 00
	00		 mov	 eax, DWORD PTR [eax+792]
  00094	99		 cdq
  00095	2b c2		 sub	 eax, edx
  00097	d1 f8		 sar	 eax, 1
  00099	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0009c	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  0009f	39 44 8a 04	 cmp	 DWORD PTR [edx+ecx*4+4], eax
  000a3	7e 2b		 jle	 SHORT $L2805

; 1018 :             {
; 1019 :                 piBarkIndex [i + 1] = pau->m_cFrameSample / 2;

  000a5	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000a8	8b 80 18 03 00
	00		 mov	 eax, DWORD PTR [eax+792]
  000ae	99		 cdq
  000af	2b c2		 sub	 eax, edx
  000b1	d1 f8		 sar	 eax, 1
  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000b6	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  000b9	89 44 8a 04	 mov	 DWORD PTR [edx+ecx*4+4], eax

; 1020 :                 pau->m_rgcValidBarkBand [0] = i + 1;

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000c0	83 c0 01	 add	 eax, 1
  000c3	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000c6	8b 91 ac 03 00
	00		 mov	 edx, DWORD PTR [ecx+940]
  000cc	89 02		 mov	 DWORD PTR [edx], eax

; 1021 :                 break;

  000ce	eb 05		 jmp	 SHORT $L2802
$L2805:

; 1022 :             }
; 1023 :         }

  000d0	e9 6c ff ff ff	 jmp	 $L2801
$L2802:

; 1024 :     }
; 1025 :     else

  000d5	e9 50 07 00 00	 jmp	 $L2806
$L2799:

; 1026 :     {
; 1027 :         for (iWin = 0; iWin < pau->m_cPossibleWinSize; iWin++)    {

  000da	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iWin$[ebp], 0
  000e1	eb 09		 jmp	 SHORT $L2807
$L2808:
  000e3	8b 45 ec	 mov	 eax, DWORD PTR _iWin$[ebp]
  000e6	83 c0 01	 add	 eax, 1
  000e9	89 45 ec	 mov	 DWORD PTR _iWin$[ebp], eax
$L2807:
  000ec	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000ef	8b 55 ec	 mov	 edx, DWORD PTR _iWin$[ebp]
  000f2	3b 91 90 00 00
	00		 cmp	 edx, DWORD PTR [ecx+144]
  000f8	0f 8d 2c 07 00
	00		 jge	 $L2806

; 1028 :             piBarkIndex  [0] = 0;

  000fe	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  00101	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1029 :             cFrameSample = pau->m_cFrameSample / (1 << iWin);

  00107	be 01 00 00 00	 mov	 esi, 1
  0010c	8b 4d ec	 mov	 ecx, DWORD PTR _iWin$[ebp]
  0010f	d3 e6		 shl	 esi, cl
  00111	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00114	8b 81 18 03 00
	00		 mov	 eax, DWORD PTR [ecx+792]
  0011a	99		 cdq
  0011b	f7 fe		 idiv	 esi
  0011d	89 45 f4	 mov	 DWORD PTR _cFrameSample$[ebp], eax

; 1030 :             bCombined = WMAB_FALSE;

  00120	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bCombined$[ebp], 0

; 1031 :             if (pau->m_iSamplingRate >= 44100) {

  00127	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0012a	81 7a 54 44 ac
	00 00		 cmp	 DWORD PTR [edx+84], 44100 ; 0000ac44H
  00131	0f 8c 3c 02 00
	00		 jl	 $L2810

; 1032 :                 if(cFrameSample == 1024) { // winsize = 512

  00137	81 7d f4 00 04
	00 00		 cmp	 DWORD PTR _cFrameSample$[ebp], 1024 ; 00000400H
  0013e	0f 85 c9 00 00
	00		 jne	 $L2811

; 1033 :                     bCombined = WMAB_TRUE;

  00144	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bCombined$[ebp], 1

; 1034 :                     pau->m_rgcValidBarkBand[iWin] = 17;

  0014b	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0014e	8b 88 ac 03 00
	00		 mov	 ecx, DWORD PTR [eax+940]
  00154	8b 55 ec	 mov	 edx, DWORD PTR _iWin$[ebp]
  00157	c7 04 91 11 00
	00 00		 mov	 DWORD PTR [ecx+edx*4], 17 ; 00000011H

; 1035 :                     piBarkIndex[1]  = 5;    piBarkIndex[2]  = 12;

  0015e	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  00161	c7 40 04 05 00
	00 00		 mov	 DWORD PTR [eax+4], 5
  00168	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  0016b	c7 41 08 0c 00
	00 00		 mov	 DWORD PTR [ecx+8], 12	; 0000000cH

; 1036 :                     piBarkIndex[3]  = 18;   piBarkIndex[4]  = 25;

  00172	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00175	c7 42 0c 12 00
	00 00		 mov	 DWORD PTR [edx+12], 18	; 00000012H
  0017c	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  0017f	c7 40 10 19 00
	00 00		 mov	 DWORD PTR [eax+16], 25	; 00000019H

; 1037 :                     piBarkIndex[5]  = 34;   piBarkIndex[6]  = 46;

  00186	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00189	c7 41 14 22 00
	00 00		 mov	 DWORD PTR [ecx+20], 34	; 00000022H
  00190	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00193	c7 42 18 2e 00
	00 00		 mov	 DWORD PTR [edx+24], 46	; 0000002eH

; 1038 :                     piBarkIndex[7]  = 54;   piBarkIndex[8]  = 63;

  0019a	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  0019d	c7 40 1c 36 00
	00 00		 mov	 DWORD PTR [eax+28], 54	; 00000036H
  001a4	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  001a7	c7 41 20 3f 00
	00 00		 mov	 DWORD PTR [ecx+32], 63	; 0000003fH

; 1039 :                     piBarkIndex[9]  = 86;   piBarkIndex[10] = 102;

  001ae	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  001b1	c7 42 24 56 00
	00 00		 mov	 DWORD PTR [edx+36], 86	; 00000056H
  001b8	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  001bb	c7 40 28 66 00
	00 00		 mov	 DWORD PTR [eax+40], 102	; 00000066H

; 1040 :                     piBarkIndex[11] = 123;  piBarkIndex[12] = 149;

  001c2	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  001c5	c7 41 2c 7b 00
	00 00		 mov	 DWORD PTR [ecx+44], 123	; 0000007bH
  001cc	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  001cf	c7 42 30 95 00
	00 00		 mov	 DWORD PTR [edx+48], 149	; 00000095H

; 1041 :                     piBarkIndex[13] = 179;  piBarkIndex[14] = 221;

  001d6	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  001d9	c7 40 34 b3 00
	00 00		 mov	 DWORD PTR [eax+52], 179	; 000000b3H
  001e0	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  001e3	c7 41 38 dd 00
	00 00		 mov	 DWORD PTR [ecx+56], 221	; 000000ddH

; 1042 :                     piBarkIndex[15] = 279;  piBarkIndex[16] = 360;

  001ea	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  001ed	c7 42 3c 17 01
	00 00		 mov	 DWORD PTR [edx+60], 279	; 00000117H
  001f4	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  001f7	c7 40 40 68 01
	00 00		 mov	 DWORD PTR [eax+64], 360	; 00000168H

; 1043 :                     piBarkIndex[17] = 512;

  001fe	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00201	c7 41 44 00 02
	00 00		 mov	 DWORD PTR [ecx+68], 512	; 00000200H

; 1044 :                 }
; 1045 :                 else if(cFrameSample == 512) { // winsize = 256

  00208	e9 61 01 00 00	 jmp	 $L2812
$L2811:
  0020d	81 7d f4 00 02
	00 00		 cmp	 DWORD PTR _cFrameSample$[ebp], 512 ; 00000200H
  00214	0f 85 b5 00 00
	00		 jne	 $L2813

; 1046 :                     bCombined = WMAB_TRUE;

  0021a	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bCombined$[ebp], 1

; 1047 :                     pau->m_rgcValidBarkBand[iWin] = 15;

  00221	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00224	8b 82 ac 03 00
	00		 mov	 eax, DWORD PTR [edx+940]
  0022a	8b 4d ec	 mov	 ecx, DWORD PTR _iWin$[ebp]
  0022d	c7 04 88 0f 00
	00 00		 mov	 DWORD PTR [eax+ecx*4], 15 ; 0000000fH

; 1048 :                     piBarkIndex[1]  = 5;    piBarkIndex[2]  = 11;

  00234	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00237	c7 42 04 05 00
	00 00		 mov	 DWORD PTR [edx+4], 5
  0023e	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  00241	c7 40 08 0b 00
	00 00		 mov	 DWORD PTR [eax+8], 11	; 0000000bH

; 1049 :                     piBarkIndex[3]  = 17;   piBarkIndex[4]  = 23;

  00248	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  0024b	c7 41 0c 11 00
	00 00		 mov	 DWORD PTR [ecx+12], 17	; 00000011H
  00252	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00255	c7 42 10 17 00
	00 00		 mov	 DWORD PTR [edx+16], 23	; 00000017H

; 1050 :                     piBarkIndex[5]  = 31;   piBarkIndex[6]  = 37;

  0025c	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  0025f	c7 40 14 1f 00
	00 00		 mov	 DWORD PTR [eax+20], 31	; 0000001fH
  00266	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00269	c7 41 18 25 00
	00 00		 mov	 DWORD PTR [ecx+24], 37	; 00000025H

; 1051 :                     piBarkIndex[7]  = 43;   piBarkIndex[8]  = 51;

  00270	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00273	c7 42 1c 2b 00
	00 00		 mov	 DWORD PTR [edx+28], 43	; 0000002bH
  0027a	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  0027d	c7 40 20 33 00
	00 00		 mov	 DWORD PTR [eax+32], 51	; 00000033H

; 1052 :                     piBarkIndex[9]  = 62;   piBarkIndex[10] = 74;

  00284	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00287	c7 41 24 3e 00
	00 00		 mov	 DWORD PTR [ecx+36], 62	; 0000003eH
  0028e	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00291	c7 42 28 4a 00
	00 00		 mov	 DWORD PTR [edx+40], 74	; 0000004aH

; 1053 :                     piBarkIndex[11] = 89;   piBarkIndex[12] = 110;

  00298	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  0029b	c7 40 2c 59 00
	00 00		 mov	 DWORD PTR [eax+44], 89	; 00000059H
  002a2	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  002a5	c7 41 30 6e 00
	00 00		 mov	 DWORD PTR [ecx+48], 110	; 0000006eH

; 1054 :                     piBarkIndex[13] = 139;  piBarkIndex[14] = 180;

  002ac	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  002af	c7 42 34 8b 00
	00 00		 mov	 DWORD PTR [edx+52], 139	; 0000008bH
  002b6	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  002b9	c7 40 38 b4 00
	00 00		 mov	 DWORD PTR [eax+56], 180	; 000000b4H

; 1055 :                     piBarkIndex[15] = 256;

  002c0	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  002c3	c7 41 3c 00 01
	00 00		 mov	 DWORD PTR [ecx+60], 256	; 00000100H

; 1056 :                 }
; 1057 :                 else if(cFrameSample == 256)  { // winsize = 128

  002ca	e9 9f 00 00 00	 jmp	 $L2812
$L2813:
  002cf	81 7d f4 00 01
	00 00		 cmp	 DWORD PTR _cFrameSample$[ebp], 256 ; 00000100H
  002d6	0f 85 92 00 00
	00		 jne	 $L2812

; 1058 :                     bCombined = WMAB_TRUE;

  002dc	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bCombined$[ebp], 1

; 1059 :                     pau->m_rgcValidBarkBand [iWin] = 12;

  002e3	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  002e6	8b 82 ac 03 00
	00		 mov	 eax, DWORD PTR [edx+940]
  002ec	8b 4d ec	 mov	 ecx, DWORD PTR _iWin$[ebp]
  002ef	c7 04 88 0c 00
	00 00		 mov	 DWORD PTR [eax+ecx*4], 12 ; 0000000cH

; 1060 :                     piBarkIndex[1]  = 4;   piBarkIndex[2]  = 9;

  002f6	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  002f9	c7 42 04 04 00
	00 00		 mov	 DWORD PTR [edx+4], 4
  00300	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  00303	c7 40 08 09 00
	00 00		 mov	 DWORD PTR [eax+8], 9

; 1061 :                     piBarkIndex[3]  = 12;  piBarkIndex[4]  = 16;

  0030a	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  0030d	c7 41 0c 0c 00
	00 00		 mov	 DWORD PTR [ecx+12], 12	; 0000000cH
  00314	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00317	c7 42 10 10 00
	00 00		 mov	 DWORD PTR [edx+16], 16	; 00000010H

; 1062 :                     piBarkIndex[5]  = 21;  piBarkIndex[6]  = 26;

  0031e	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  00321	c7 40 14 15 00
	00 00		 mov	 DWORD PTR [eax+20], 21	; 00000015H
  00328	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  0032b	c7 41 18 1a 00
	00 00		 mov	 DWORD PTR [ecx+24], 26	; 0000001aH

; 1063 :                     piBarkIndex[7]  = 37;  piBarkIndex[8]  = 45;

  00332	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00335	c7 42 1c 25 00
	00 00		 mov	 DWORD PTR [edx+28], 37	; 00000025H
  0033c	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  0033f	c7 40 20 2d 00
	00 00		 mov	 DWORD PTR [eax+32], 45	; 0000002dH

; 1064 :                     piBarkIndex[9]  = 55;  piBarkIndex[10] = 70;

  00346	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00349	c7 41 24 37 00
	00 00		 mov	 DWORD PTR [ecx+36], 55	; 00000037H
  00350	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00353	c7 42 28 46 00
	00 00		 mov	 DWORD PTR [edx+40], 70	; 00000046H

; 1065 :                     piBarkIndex[11] = 90;  piBarkIndex[12] = 128;

  0035a	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  0035d	c7 40 2c 5a 00
	00 00		 mov	 DWORD PTR [eax+44], 90	; 0000005aH
  00364	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00367	c7 41 30 80 00
	00 00		 mov	 DWORD PTR [ecx+48], 128	; 00000080H
$L2812:

; 1066 :                 }
; 1067 :             }
; 1068 :             else if(pau->m_iSamplingRate >= 32000) {

  0036e	e9 87 03 00 00	 jmp	 $L2816
$L2810:
  00373	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00376	81 7a 54 00 7d
	00 00		 cmp	 DWORD PTR [edx+84], 32000 ; 00007d00H
  0037d	0f 8c 28 02 00
	00		 jl	 $L2817

; 1069 :                 if(cFrameSample == 1024) { // winsize = 512

  00383	81 7d f4 00 04
	00 00		 cmp	 DWORD PTR _cFrameSample$[ebp], 1024 ; 00000400H
  0038a	0f 85 bf 00 00
	00		 jne	 $L2818

; 1070 :                     bCombined = WMAB_TRUE;

  00390	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bCombined$[ebp], 1

; 1071 :                     pau->m_rgcValidBarkBand[iWin] = 16;

  00397	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0039a	8b 88 ac 03 00
	00		 mov	 ecx, DWORD PTR [eax+940]
  003a0	8b 55 ec	 mov	 edx, DWORD PTR _iWin$[ebp]
  003a3	c7 04 91 10 00
	00 00		 mov	 DWORD PTR [ecx+edx*4], 16 ; 00000010H

; 1072 :                     piBarkIndex[1]  = 6;   piBarkIndex[2]  = 13;

  003aa	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  003ad	c7 40 04 06 00
	00 00		 mov	 DWORD PTR [eax+4], 6
  003b4	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  003b7	c7 41 08 0d 00
	00 00		 mov	 DWORD PTR [ecx+8], 13	; 0000000dH

; 1073 :                     piBarkIndex[3]  = 20;  piBarkIndex[4]  = 29;

  003be	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  003c1	c7 42 0c 14 00
	00 00		 mov	 DWORD PTR [edx+12], 20	; 00000014H
  003c8	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  003cb	c7 40 10 1d 00
	00 00		 mov	 DWORD PTR [eax+16], 29	; 0000001dH

; 1074 :                     piBarkIndex[5]  = 41;  piBarkIndex[6]  = 55;

  003d2	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  003d5	c7 41 14 29 00
	00 00		 mov	 DWORD PTR [ecx+20], 41	; 00000029H
  003dc	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  003df	c7 42 18 37 00
	00 00		 mov	 DWORD PTR [edx+24], 55	; 00000037H

; 1075 :                     piBarkIndex[7]  = 74;  piBarkIndex[8]  = 101;

  003e6	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  003e9	c7 40 1c 4a 00
	00 00		 mov	 DWORD PTR [eax+28], 74	; 0000004aH
  003f0	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  003f3	c7 41 20 65 00
	00 00		 mov	 DWORD PTR [ecx+32], 101	; 00000065H

; 1076 :                     piBarkIndex[9]  = 141; piBarkIndex[10] = 170;

  003fa	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  003fd	c7 42 24 8d 00
	00 00		 mov	 DWORD PTR [edx+36], 141	; 0000008dH
  00404	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  00407	c7 40 28 aa 00
	00 00		 mov	 DWORD PTR [eax+40], 170	; 000000aaH

; 1077 :                     piBarkIndex[11] = 205; piBarkIndex[12] = 246;

  0040e	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00411	c7 41 2c cd 00
	00 00		 mov	 DWORD PTR [ecx+44], 205	; 000000cdH
  00418	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  0041b	c7 42 30 f6 00
	00 00		 mov	 DWORD PTR [edx+48], 246	; 000000f6H

; 1078 :                     piBarkIndex[13] = 304; piBarkIndex[14] = 384;

  00422	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  00425	c7 40 34 30 01
	00 00		 mov	 DWORD PTR [eax+52], 304	; 00000130H
  0042c	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  0042f	c7 41 38 80 01
	00 00		 mov	 DWORD PTR [ecx+56], 384	; 00000180H

; 1079 :                     piBarkIndex[15] = 496; piBarkIndex[16] = 512;

  00436	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00439	c7 42 3c f0 01
	00 00		 mov	 DWORD PTR [edx+60], 496	; 000001f0H
  00440	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  00443	c7 40 40 00 02
	00 00		 mov	 DWORD PTR [eax+64], 512	; 00000200H

; 1080 :                 }
; 1081 :                 else if(cFrameSample == 512) { // winsize = 256

  0044a	e9 57 01 00 00	 jmp	 $L2819
$L2818:
  0044f	81 7d f4 00 02
	00 00		 cmp	 DWORD PTR _cFrameSample$[ebp], 512 ; 00000200H
  00456	0f 85 b5 00 00
	00		 jne	 $L2820

; 1082 :                     bCombined = WMAB_TRUE;

  0045c	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bCombined$[ebp], 1

; 1083 :                     pau->m_rgcValidBarkBand[iWin] = 15;

  00463	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00466	8b 91 ac 03 00
	00		 mov	 edx, DWORD PTR [ecx+940]
  0046c	8b 45 ec	 mov	 eax, DWORD PTR _iWin$[ebp]
  0046f	c7 04 82 0f 00
	00 00		 mov	 DWORD PTR [edx+eax*4], 15 ; 0000000fH

; 1084 :                     piBarkIndex[1]  = 5;   piBarkIndex[2]  = 10;

  00476	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00479	c7 41 04 05 00
	00 00		 mov	 DWORD PTR [ecx+4], 5
  00480	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00483	c7 42 08 0a 00
	00 00		 mov	 DWORD PTR [edx+8], 10	; 0000000aH

; 1085 :                     piBarkIndex[3]  = 15;  piBarkIndex[4]  = 20;

  0048a	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  0048d	c7 40 0c 0f 00
	00 00		 mov	 DWORD PTR [eax+12], 15	; 0000000fH
  00494	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00497	c7 41 10 14 00
	00 00		 mov	 DWORD PTR [ecx+16], 20	; 00000014H

; 1086 :                     piBarkIndex[5]  = 28;  piBarkIndex[6]  = 37;

  0049e	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  004a1	c7 42 14 1c 00
	00 00		 mov	 DWORD PTR [edx+20], 28	; 0000001cH
  004a8	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  004ab	c7 40 18 25 00
	00 00		 mov	 DWORD PTR [eax+24], 37	; 00000025H

; 1087 :                     piBarkIndex[7]  = 50;  piBarkIndex[8]  = 70;

  004b2	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  004b5	c7 41 1c 32 00
	00 00		 mov	 DWORD PTR [ecx+28], 50	; 00000032H
  004bc	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  004bf	c7 42 20 46 00
	00 00		 mov	 DWORD PTR [edx+32], 70	; 00000046H

; 1088 :                     piBarkIndex[9]  = 85;  piBarkIndex[10] = 102;

  004c6	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  004c9	c7 40 24 55 00
	00 00		 mov	 DWORD PTR [eax+36], 85	; 00000055H
  004d0	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  004d3	c7 41 28 66 00
	00 00		 mov	 DWORD PTR [ecx+40], 102	; 00000066H

; 1089 :                     piBarkIndex[11] = 123; piBarkIndex[12] = 152;

  004da	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  004dd	c7 42 2c 7b 00
	00 00		 mov	 DWORD PTR [edx+44], 123	; 0000007bH
  004e4	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  004e7	c7 40 30 98 00
	00 00		 mov	 DWORD PTR [eax+48], 152	; 00000098H

; 1090 :                     piBarkIndex[13] = 192; piBarkIndex[14] = 248;

  004ee	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  004f1	c7 41 34 c0 00
	00 00		 mov	 DWORD PTR [ecx+52], 192	; 000000c0H
  004f8	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  004fb	c7 42 38 f8 00
	00 00		 mov	 DWORD PTR [edx+56], 248	; 000000f8H

; 1091 :                     piBarkIndex[15] = 256;

  00502	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  00505	c7 40 3c 00 01
	00 00		 mov	 DWORD PTR [eax+60], 256	; 00000100H

; 1092 :                 }
; 1093 :                 else if(cFrameSample == 256)  { // winsize = 128

  0050c	e9 95 00 00 00	 jmp	 $L2819
$L2820:
  00511	81 7d f4 00 01
	00 00		 cmp	 DWORD PTR _cFrameSample$[ebp], 256 ; 00000100H
  00518	0f 85 88 00 00
	00		 jne	 $L2819

; 1094 :                     bCombined = WMAB_TRUE;

  0051e	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bCombined$[ebp], 1

; 1095 :                     pau->m_rgcValidBarkBand [iWin] = 11;

  00525	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00528	8b 91 ac 03 00
	00		 mov	 edx, DWORD PTR [ecx+940]
  0052e	8b 45 ec	 mov	 eax, DWORD PTR _iWin$[ebp]
  00531	c7 04 82 0b 00
	00 00		 mov	 DWORD PTR [edx+eax*4], 11 ; 0000000bH

; 1096 :                     piBarkIndex[1]  = 4;   piBarkIndex[2]  = 9;

  00538	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  0053b	c7 41 04 04 00
	00 00		 mov	 DWORD PTR [ecx+4], 4
  00542	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00545	c7 42 08 09 00
	00 00		 mov	 DWORD PTR [edx+8], 9

; 1097 :                     piBarkIndex[3]  = 14;  piBarkIndex[4]  = 19;

  0054c	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  0054f	c7 40 0c 0e 00
	00 00		 mov	 DWORD PTR [eax+12], 14	; 0000000eH
  00556	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00559	c7 41 10 13 00
	00 00		 mov	 DWORD PTR [ecx+16], 19	; 00000013H

; 1098 :                     piBarkIndex[5]  = 25;  piBarkIndex[6]  = 35;

  00560	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00563	c7 42 14 19 00
	00 00		 mov	 DWORD PTR [edx+20], 25	; 00000019H
  0056a	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  0056d	c7 40 18 23 00
	00 00		 mov	 DWORD PTR [eax+24], 35	; 00000023H

; 1099 :                     piBarkIndex[7]  = 51;  piBarkIndex[8]  = 76;

  00574	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00577	c7 41 1c 33 00
	00 00		 mov	 DWORD PTR [ecx+28], 51	; 00000033H
  0057e	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00581	c7 42 20 4c 00
	00 00		 mov	 DWORD PTR [edx+32], 76	; 0000004cH

; 1100 :                     piBarkIndex[9]  = 96;  piBarkIndex[10] = 124;

  00588	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  0058b	c7 40 24 60 00
	00 00		 mov	 DWORD PTR [eax+36], 96	; 00000060H
  00592	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00595	c7 41 28 7c 00
	00 00		 mov	 DWORD PTR [ecx+40], 124	; 0000007cH

; 1101 :                     piBarkIndex[11] = 128;

  0059c	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  0059f	c7 42 2c 80 00
	00 00		 mov	 DWORD PTR [edx+44], 128	; 00000080H
$L2819:

; 1102 :                 }
; 1103 :             }
; 1104 :             else if(pau->m_iSamplingRate >= 22050) {

  005a6	e9 4f 01 00 00	 jmp	 $L2816
$L2817:
  005ab	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  005ae	81 78 54 22 56
	00 00		 cmp	 DWORD PTR [eax+84], 22050 ; 00005622H
  005b5	0f 8c 3f 01 00
	00		 jl	 $L2816

; 1105 :                 if(cFrameSample == 512) { // winsize = 256

  005bb	81 7d f4 00 02
	00 00		 cmp	 DWORD PTR _cFrameSample$[ebp], 512 ; 00000200H
  005c2	0f 85 ab 00 00
	00		 jne	 $L2825

; 1106 :                     bCombined = WMAB_TRUE;

  005c8	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bCombined$[ebp], 1

; 1107 :                     pau->m_rgcValidBarkBand [iWin] = 14;

  005cf	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  005d2	8b 91 ac 03 00
	00		 mov	 edx, DWORD PTR [ecx+940]
  005d8	8b 45 ec	 mov	 eax, DWORD PTR _iWin$[ebp]
  005db	c7 04 82 0e 00
	00 00		 mov	 DWORD PTR [edx+eax*4], 14 ; 0000000eH

; 1108 :                     piBarkIndex[1]  = 5;   piBarkIndex[2]  = 12;

  005e2	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  005e5	c7 41 04 05 00
	00 00		 mov	 DWORD PTR [ecx+4], 5
  005ec	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  005ef	c7 42 08 0c 00
	00 00		 mov	 DWORD PTR [edx+8], 12	; 0000000cH

; 1109 :                     piBarkIndex[3]  = 18;  piBarkIndex[4]  = 25;

  005f6	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  005f9	c7 40 0c 12 00
	00 00		 mov	 DWORD PTR [eax+12], 18	; 00000012H
  00600	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00603	c7 41 10 19 00
	00 00		 mov	 DWORD PTR [ecx+16], 25	; 00000019H

; 1110 :                     piBarkIndex[5]  = 34;  piBarkIndex[6]  = 46;

  0060a	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  0060d	c7 42 14 22 00
	00 00		 mov	 DWORD PTR [edx+20], 34	; 00000022H
  00614	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  00617	c7 40 18 2e 00
	00 00		 mov	 DWORD PTR [eax+24], 46	; 0000002eH

; 1111 :                     piBarkIndex[7]  = 63;  piBarkIndex[8]  = 86;

  0061e	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00621	c7 41 1c 3f 00
	00 00		 mov	 DWORD PTR [ecx+28], 63	; 0000003fH
  00628	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  0062b	c7 42 20 56 00
	00 00		 mov	 DWORD PTR [edx+32], 86	; 00000056H

; 1112 :                     piBarkIndex[9]  = 102; piBarkIndex[10] = 123;

  00632	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  00635	c7 40 24 66 00
	00 00		 mov	 DWORD PTR [eax+36], 102	; 00000066H
  0063c	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  0063f	c7 41 28 7b 00
	00 00		 mov	 DWORD PTR [ecx+40], 123	; 0000007bH

; 1113 :                     piBarkIndex[11] = 149; piBarkIndex[12] = 179;

  00646	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00649	c7 42 2c 95 00
	00 00		 mov	 DWORD PTR [edx+44], 149	; 00000095H
  00650	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  00653	c7 40 30 b3 00
	00 00		 mov	 DWORD PTR [eax+48], 179	; 000000b3H

; 1114 :                     piBarkIndex[13] = 221; piBarkIndex[14] = 256;

  0065a	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  0065d	c7 41 34 dd 00
	00 00		 mov	 DWORD PTR [ecx+52], 221	; 000000ddH
  00664	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00667	c7 42 38 00 01
	00 00		 mov	 DWORD PTR [edx+56], 256	; 00000100H

; 1115 :                 }
; 1116 :                 else if(cFrameSample == 256) { // winsize = 128

  0066e	e9 87 00 00 00	 jmp	 $L2816
$L2825:
  00673	81 7d f4 00 01
	00 00		 cmp	 DWORD PTR _cFrameSample$[ebp], 256 ; 00000100H
  0067a	75 7e		 jne	 SHORT $L2816

; 1117 :                     bCombined = WMAB_TRUE;

  0067c	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bCombined$[ebp], 1

; 1118 :                     pau->m_rgcValidBarkBand [iWin] = 10;

  00683	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00686	8b 88 ac 03 00
	00		 mov	 ecx, DWORD PTR [eax+940]
  0068c	8b 55 ec	 mov	 edx, DWORD PTR _iWin$[ebp]
  0068f	c7 04 91 0a 00
	00 00		 mov	 DWORD PTR [ecx+edx*4], 10 ; 0000000aH

; 1119 :                     piBarkIndex[1]  = 5;   piBarkIndex[2]  = 11;

  00696	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  00699	c7 40 04 05 00
	00 00		 mov	 DWORD PTR [eax+4], 5
  006a0	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  006a3	c7 41 08 0b 00
	00 00		 mov	 DWORD PTR [ecx+8], 11	; 0000000bH

; 1120 :                     piBarkIndex[3]  = 17;  piBarkIndex[4]  = 23;

  006aa	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  006ad	c7 42 0c 11 00
	00 00		 mov	 DWORD PTR [edx+12], 17	; 00000011H
  006b4	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  006b7	c7 40 10 17 00
	00 00		 mov	 DWORD PTR [eax+16], 23	; 00000017H

; 1121 :                     piBarkIndex[5]  = 31;  piBarkIndex[6]  = 43;

  006be	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  006c1	c7 41 14 1f 00
	00 00		 mov	 DWORD PTR [ecx+20], 31	; 0000001fH
  006c8	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  006cb	c7 42 18 2b 00
	00 00		 mov	 DWORD PTR [edx+24], 43	; 0000002bH

; 1122 :                     piBarkIndex[7]  = 62;  piBarkIndex[8]  = 89;

  006d2	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  006d5	c7 40 1c 3e 00
	00 00		 mov	 DWORD PTR [eax+28], 62	; 0000003eH
  006dc	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  006df	c7 41 20 59 00
	00 00		 mov	 DWORD PTR [ecx+32], 89	; 00000059H

; 1123 :                     piBarkIndex[9]  = 110; piBarkIndex[10] = 128;

  006e6	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  006e9	c7 42 24 6e 00
	00 00		 mov	 DWORD PTR [edx+36], 110	; 0000006eH
  006f0	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  006f3	c7 40 28 80 00
	00 00		 mov	 DWORD PTR [eax+40], 128	; 00000080H
$L2816:

; 1124 :                 }
; 1125 :             }
; 1126 : 
; 1127 :             if(!bCombined)

  006fa	83 7d e8 00	 cmp	 DWORD PTR _bCombined$[ebp], 0
  006fe	0f 85 cd 00 00
	00		 jne	 $L2828

; 1128 :             {
; 1129 :                 Float fltTemp = cFrameSample*fltSamplingPeriod;

  00704	db 45 f4	 fild	 DWORD PTR _cFrameSample$[ebp]
  00707	d8 4d f8	 fmul	 DWORD PTR _fltSamplingPeriod$[ebp]
  0070a	d9 5d dc	 fstp	 DWORD PTR _fltTemp$2829[ebp]

; 1130 :                 Int iIndex;
; 1131 :                 Int iFreqCurr = 0;

  0070d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iFreqCurr$2831[ebp], 0

; 1132 :                 Int iCurr = 1;

  00714	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _iCurr$2832[ebp], 1
$L2834:

; 1133 :                 while(WMAB_TRUE)

  0071b	b9 01 00 00 00	 mov	 ecx, 1
  00720	85 c9		 test	 ecx, ecx
  00722	0f 84 a7 00 00
	00		 je	 $L2835

; 1134 :                 {
; 1135 :                     iIndex = ((Int) ftoi((g_rgiBarkFreq [iFreqCurr++]*fltTemp + 2.0f)/4.0f))*4; // open end

  00728	8b 55 e0	 mov	 edx, DWORD PTR _iFreqCurr$2831[ebp]
  0072b	0f b7 04 55 00
	00 00 00	 movzx	 eax, WORD PTR _g_rgiBarkFreq[edx*2]
  00733	89 45 d0	 mov	 DWORD PTR tv528[ebp], eax
  00736	db 45 d0	 fild	 DWORD PTR tv528[ebp]
  00739	d8 4d dc	 fmul	 DWORD PTR _fltTemp$2829[ebp]
  0073c	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@40000000
  00742	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@40800000
  00748	d9 5d cc	 fstp	 DWORD PTR tv299[ebp]
  0074b	8b 4d cc	 mov	 ecx, DWORD PTR tv299[ebp]
  0074e	51		 push	 ecx
  0074f	e8 00 00 00 00	 call	 _FloatToLong@4
  00754	c1 e0 02	 shl	 eax, 2
  00757	89 45 e4	 mov	 DWORD PTR _iIndex$2830[ebp], eax
  0075a	8b 55 e0	 mov	 edx, DWORD PTR _iFreqCurr$2831[ebp]
  0075d	83 c2 01	 add	 edx, 1
  00760	89 55 e0	 mov	 DWORD PTR _iFreqCurr$2831[ebp], edx

; 1136 : 
; 1137 :                     if(iIndex > piBarkIndex[iCurr - 1])

  00763	8b 45 d8	 mov	 eax, DWORD PTR _iCurr$2832[ebp]
  00766	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00769	8b 55 e4	 mov	 edx, DWORD PTR _iIndex$2830[ebp]
  0076c	3b 54 81 fc	 cmp	 edx, DWORD PTR [ecx+eax*4-4]
  00770	7e 15		 jle	 SHORT $L2838

; 1138 :                         piBarkIndex[iCurr++] = iIndex;

  00772	8b 45 d8	 mov	 eax, DWORD PTR _iCurr$2832[ebp]
  00775	8b 4d f0	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  00778	8b 55 e4	 mov	 edx, DWORD PTR _iIndex$2830[ebp]
  0077b	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  0077e	8b 45 d8	 mov	 eax, DWORD PTR _iCurr$2832[ebp]
  00781	83 c0 01	 add	 eax, 1
  00784	89 45 d8	 mov	 DWORD PTR _iCurr$2832[ebp], eax
$L2838:

; 1139 : 
; 1140 :                     if(iFreqCurr >= NUM_BARK_BAND ||
; 1141 :                        piBarkIndex[iCurr - 1] > cFrameSample/2)

  00787	83 7d e0 19	 cmp	 DWORD PTR _iFreqCurr$2831[ebp], 25 ; 00000019H
  0078b	7d 14		 jge	 SHORT $L2840
  0078d	8b 45 f4	 mov	 eax, DWORD PTR _cFrameSample$[ebp]
  00790	99		 cdq
  00791	2b c2		 sub	 eax, edx
  00793	d1 f8		 sar	 eax, 1
  00795	8b 4d d8	 mov	 ecx, DWORD PTR _iCurr$2832[ebp]
  00798	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  0079b	39 44 8a fc	 cmp	 DWORD PTR [edx+ecx*4-4], eax
  0079f	7e 29		 jle	 SHORT $L2839
$L2840:

; 1142 :                     {
; 1143 :                         piBarkIndex[iCurr - 1] = cFrameSample/2;

  007a1	8b 45 f4	 mov	 eax, DWORD PTR _cFrameSample$[ebp]
  007a4	99		 cdq
  007a5	2b c2		 sub	 eax, edx
  007a7	d1 f8		 sar	 eax, 1
  007a9	8b 4d d8	 mov	 ecx, DWORD PTR _iCurr$2832[ebp]
  007ac	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  007af	89 44 8a fc	 mov	 DWORD PTR [edx+ecx*4-4], eax

; 1144 :                         pau->m_rgcValidBarkBand[iWin] = iCurr - 1;

  007b3	8b 45 d8	 mov	 eax, DWORD PTR _iCurr$2832[ebp]
  007b6	83 e8 01	 sub	 eax, 1
  007b9	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  007bc	8b 91 ac 03 00
	00		 mov	 edx, DWORD PTR [ecx+940]
  007c2	8b 4d ec	 mov	 ecx, DWORD PTR _iWin$[ebp]
  007c5	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 1145 :                         break;

  007c8	eb 05		 jmp	 SHORT $L2835
$L2839:

; 1146 :                     }
; 1147 :                 }

  007ca	e9 4c ff ff ff	 jmp	 $L2834
$L2835:

; 1148 :             }
; 1149 :             else

  007cf	eb 4b		 jmp	 SHORT $L2841
$L2828:

; 1150 :             {
; 1151 :                 for (i = 0; i < pau->m_rgcValidBarkBand [iWin]; i++) {

  007d1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  007d8	eb 09		 jmp	 SHORT $L2842
$L2843:
  007da	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  007dd	83 c2 01	 add	 edx, 1
  007e0	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L2842:
  007e3	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  007e6	8b 88 ac 03 00
	00		 mov	 ecx, DWORD PTR [eax+940]
  007ec	8b 55 ec	 mov	 edx, DWORD PTR _iWin$[ebp]
  007ef	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  007f2	3b 04 91	 cmp	 eax, DWORD PTR [ecx+edx*4]
  007f5	7d 25		 jge	 SHORT $L2841

; 1152 :                     piBarkIndex [i + 1] = ((piBarkIndex [i + 1] + 2) / 4) * 4;  //rounding

  007f7	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  007fa	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  007fd	8b 44 8a 04	 mov	 eax, DWORD PTR [edx+ecx*4+4]
  00801	83 c0 02	 add	 eax, 2
  00804	99		 cdq
  00805	83 e2 03	 and	 edx, 3
  00808	03 c2		 add	 eax, edx
  0080a	c1 f8 02	 sar	 eax, 2
  0080d	c1 e0 02	 shl	 eax, 2
  00810	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00813	8b 55 f0	 mov	 edx, DWORD PTR _piBarkIndex$[ebp]
  00816	89 44 8a 04	 mov	 DWORD PTR [edx+ecx*4+4], eax

; 1153 :                     assert (piBarkIndex [i + 1] > piBarkIndex [i]);
; 1154 :                 }

  0081a	eb be		 jmp	 SHORT $L2843
$L2841:

; 1155 :             }
; 1156 : 
; 1157 :             piBarkIndex +=  NUM_BARK_BAND + 1;

  0081c	8b 45 f0	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  0081f	83 c0 68	 add	 eax, 104		; 00000068H
  00822	89 45 f0	 mov	 DWORD PTR _piBarkIndex$[ebp], eax

; 1158 :         }

  00825	e9 b9 f8 ff ff	 jmp	 $L2808
$L2806:

; 1159 :     }
; 1160 :     //default
; 1161 :     pau->m_rgiBarkIndex = pau->m_rgiBarkIndexOrig;

  0082a	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0082d	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00830	8b 82 b0 03 00
	00		 mov	 eax, DWORD PTR [edx+944]
  00836	89 81 54 03 00
	00		 mov	 DWORD PTR [ecx+852], eax

; 1162 :     pau->m_cValidBarkBand = pau->m_rgcValidBarkBand [0];

  0083c	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0083f	8b 91 ac 03 00
	00		 mov	 edx, DWORD PTR [ecx+940]
  00845	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00848	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0084a	89 88 50 03 00
	00		 mov	 DWORD PTR [eax+848], ecx

; 1163 : 
; 1164 : #ifdef DEBUG
; 1165 :     // checking for multiples of 4!!!
; 1166 :     if(pau->m_iVersion != 1)
; 1167 :     {
; 1168 :         Int iWin, iBand;
; 1169 :         for(iWin = 0; iWin < pau->m_cPossibleWinSize; iWin++)
; 1170 :         {
; 1171 :             for(iBand = 0; iBand <= pau->m_rgcValidBarkBand[iWin]; iBand++)
; 1172 :             {
; 1173 :                 i = pau->m_rgiBarkIndexOrig[iWin*(NUM_BARK_BAND + 1) + iBand];
; 1174 :                 assert(i%4 == 0);
; 1175 :             }
; 1176 :         }
; 1177 :     }
; 1178 : #endif // DEBUG
; 1179 : 
; 1180 : }

  00850	5e		 pop	 esi
  00851	8b e5		 mov	 esp, ebp
  00853	5d		 pop	 ebp
  00854	c2 04 00	 ret	 4
_prvSetBarkIndex_XDS@4 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wmamath.h
WMADEC	ENDS
;	COMDAT _FloatToLong@4
WMADEC	SEGMENT
_x$ = 8
_FloatToLong@4 PROC NEAR				; COMDAT

; 6    :     __asm
; 7    :     {
; 8    :         cvttss2si eax, [esp+4]

  00000	f3 0f 2c 44 24
	04		 cvttss2si eax, DWORD PTR [esp+4]

; 9    :         ret 4

  00006	c2 04 00	 ret	 4
_FloatToLong@4 ENDP
WMADEC	ENDS
PUBLIC	_auPreGetPCM_XDS@8
PUBLIC	_prvInitDiscardSilence_XDS@4
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\msaudio.c
;	COMDAT _auPreGetPCM_XDS@8
WMADEC	SEGMENT
tv302 = -100
tv256 = -96
tv225 = -92
tv216 = -88
tv207 = -84
tv196 = -80
_uSilenceQ2MAX$2917 = -76
_bpSinA$2892 = -72
_iSize$2891 = -68
_bpCosB$2895 = -64
_iMultiplier$2896 = -60
_bpCosA$2893 = -56
_bpSinB$2894 = -52
_iCoefPtrOffset$2885 = -48
_iCoefCountMAX$2884 = -44
_ppcinfo$2880 = -40
_iCoefDelta$2886 = -36
_iCoefCount$2883 = -32
_uSilenceQ2MAX$2881 = -28
_fUpdateTrig$2872 = -24
_uSilence$2871 = -20
_ppcinfo$2863 = -16
_ppcinfo$2855 = -12
_iWinDiff$ = -8
_iChannel$ = -4
_pau$ = 8
_pcSampleDecoded$ = 12
_auPreGetPCM_XDS@8 PROC NEAR				; COMDAT

; 1190 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H

; 1191 :     I16 iChannel;
; 1192 :     Int iWinDiff;
; 1193 : 
; 1194 :     //set up for getPCM
; 1195 :     for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) 

  00006	66 c7 45 fc 00
	00		 mov	 WORD PTR _iChannel$[ebp], 0
  0000c	eb 0c		 jmp	 SHORT $L2852
$L2853:
  0000e	66 8b 45 fc	 mov	 ax, WORD PTR _iChannel$[ebp]
  00012	66 05 01 00	 add	 ax, 1
  00016	66 89 45 fc	 mov	 WORD PTR _iChannel$[ebp], ax
$L2852:
  0001a	0f bf 4d fc	 movsx	 ecx, WORD PTR _iChannel$[ebp]
  0001e	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00021	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  00025	3b c8		 cmp	 ecx, eax
  00027	7d 44		 jge	 SHORT $L2854

; 1196 :     {
; 1197 :         PerChannelInfo* ppcinfo = pau->m_rgpcinfo + iChannel;

  00029	0f bf 4d fc	 movsx	 ecx, WORD PTR _iChannel$[ebp]
  0002d	6b c9 70	 imul	 ecx, 112		; 00000070H
  00030	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00033	03 8a a0 03 00
	00		 add	 ecx, DWORD PTR [edx+928]
  00039	89 4d f4	 mov	 DWORD PTR _ppcinfo$2855[ebp], ecx

; 1198 :         ppcinfo->m_rgiCoefReconCurr = ((I32*) ppcinfo->COEF) + pau->m_cSubbandAdjusted /2;

  0003c	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0003f	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00042	99		 cdq
  00043	2b c2		 sub	 eax, edx
  00045	d1 f8		 sar	 eax, 1
  00047	8b 4d f4	 mov	 ecx, DWORD PTR _ppcinfo$2855[ebp]
  0004a	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0004d	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  00050	8b 4d f4	 mov	 ecx, DWORD PTR _ppcinfo$2855[ebp]
  00053	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 1199 :         ppcinfo->m_iCurrGetPCM_SubFrame = 0;       //current position in a subframe

  00056	8b 55 f4	 mov	 edx, DWORD PTR _ppcinfo$2855[ebp]
  00059	66 c7 42 38 00
	00		 mov	 WORD PTR [edx+56], 0

; 1200 :         ppcinfo->m_piPrevOutputCurr = ppcinfo->m_piPrevOutput;

  0005f	8b 45 f4	 mov	 eax, DWORD PTR _ppcinfo$2855[ebp]
  00062	8b 4d f4	 mov	 ecx, DWORD PTR _ppcinfo$2855[ebp]
  00065	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00068	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 1201 :     }

  0006b	eb a1		 jmp	 SHORT $L2853
$L2854:

; 1202 : 
; 1203 :     *pcSampleDecoded = (U16) pau->m_cSubFrameSampleHalfAdjusted;

  0006d	8b 45 0c	 mov	 eax, DWORD PTR _pcSampleDecoded$[ebp]
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00073	66 8b 91 9c 00
	00 00		 mov	 dx, WORD PTR [ecx+156]
  0007a	66 89 10	 mov	 WORD PTR [eax], dx

; 1204 :     iWinDiff = pau->m_iSizeCurr - pau->m_iSizePrev;

  0007d	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00083	8b 90 84 03 00
	00		 mov	 edx, DWORD PTR [eax+900]
  00089	2b 91 80 03 00
	00		 sub	 edx, DWORD PTR [ecx+896]
  0008f	89 55 f8	 mov	 DWORD PTR _iWinDiff$[ebp], edx

; 1205 :     if (iWinDiff > 0)   {

  00092	83 7d f8 00	 cmp	 DWORD PTR _iWinDiff$[ebp], 0
  00096	7e 7a		 jle	 SHORT $L2858

; 1206 :         *pcSampleDecoded -= (U16)(iWinDiff >> 1);

  00098	8b 45 f8	 mov	 eax, DWORD PTR _iWinDiff$[ebp]
  0009b	d1 f8		 sar	 eax, 1
  0009d	0f b7 c8	 movzx	 ecx, ax
  000a0	8b 55 0c	 mov	 edx, DWORD PTR _pcSampleDecoded$[ebp]
  000a3	0f b7 02	 movzx	 eax, WORD PTR [edx]
  000a6	2b c1		 sub	 eax, ecx
  000a8	8b 4d 0c	 mov	 ecx, DWORD PTR _pcSampleDecoded$[ebp]
  000ab	66 89 01	 mov	 WORD PTR [ecx], ax

; 1207 :         for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) 

  000ae	66 c7 45 fc 00
	00		 mov	 WORD PTR _iChannel$[ebp], 0
  000b4	eb 0c		 jmp	 SHORT $L2860
$L2861:
  000b6	66 8b 55 fc	 mov	 dx, WORD PTR _iChannel$[ebp]
  000ba	66 83 c2 01	 add	 dx, 1
  000be	66 89 55 fc	 mov	 WORD PTR _iChannel$[ebp], dx
$L2860:
  000c2	0f bf 45 fc	 movsx	 eax, WORD PTR _iChannel$[ebp]
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000c9	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  000cd	3b c2		 cmp	 eax, edx
  000cf	7d 41		 jge	 SHORT $L2858

; 1208 :         {
; 1209 :             PerChannelInfo* ppcinfo = pau->m_rgpcinfo + iChannel;

  000d1	0f bf 45 fc	 movsx	 eax, WORD PTR _iChannel$[ebp]
  000d5	6b c0 70	 imul	 eax, 112		; 00000070H
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000db	03 81 a0 03 00
	00		 add	 eax, DWORD PTR [ecx+928]
  000e1	89 45 f0	 mov	 DWORD PTR _ppcinfo$2863[ebp], eax

; 1210 :             ppcinfo->m_rgiCoefReconCurr += iWinDiff >> 1;

  000e4	8b 55 f8	 mov	 edx, DWORD PTR _iWinDiff$[ebp]
  000e7	d1 fa		 sar	 edx, 1
  000e9	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2863[ebp]
  000ec	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000ef	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  000f2	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2863[ebp]
  000f5	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 1211 :             ppcinfo->m_iCurrGetPCM_SubFrame += (I16)(iWinDiff >> 1);

  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _iWinDiff$[ebp]
  000fb	d1 f9		 sar	 ecx, 1
  000fd	0f bf d1	 movsx	 edx, cx
  00100	8b 45 f0	 mov	 eax, DWORD PTR _ppcinfo$2863[ebp]
  00103	0f bf 48 38	 movsx	 ecx, WORD PTR [eax+56]
  00107	03 ca		 add	 ecx, edx
  00109	8b 55 f0	 mov	 edx, DWORD PTR _ppcinfo$2863[ebp]
  0010c	66 89 4a 38	 mov	 WORD PTR [edx+56], cx

; 1212 :             assert(0<=ppcinfo->m_iCurrGetPCM_SubFrame && ppcinfo->m_iCurrGetPCM_SubFrame<=pau->m_cSubFrameSampleHalfAdjusted);
; 1213 :         }

  00110	eb a4		 jmp	 SHORT $L2861
$L2858:

; 1214 :     }
; 1215 :     iWinDiff = pau->m_iSizeCurr - pau->m_iSizeNext;

  00112	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00115	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00118	8b 90 84 03 00
	00		 mov	 edx, DWORD PTR [eax+900]
  0011e	2b 91 88 03 00
	00		 sub	 edx, DWORD PTR [ecx+904]
  00124	89 55 f8	 mov	 DWORD PTR _iWinDiff$[ebp], edx

; 1216 :     if (iWinDiff > 0)

  00127	83 7d f8 00	 cmp	 DWORD PTR _iWinDiff$[ebp], 0
  0012b	7e 16		 jle	 SHORT $L2865

; 1217 :         *pcSampleDecoded += (U16)(iWinDiff >> 1);

  0012d	8b 45 f8	 mov	 eax, DWORD PTR _iWinDiff$[ebp]
  00130	d1 f8		 sar	 eax, 1
  00132	0f b7 c8	 movzx	 ecx, ax
  00135	8b 55 0c	 mov	 edx, DWORD PTR _pcSampleDecoded$[ebp]
  00138	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0013b	03 c1		 add	 eax, ecx
  0013d	8b 4d 0c	 mov	 ecx, DWORD PTR _pcSampleDecoded$[ebp]
  00140	66 89 01	 mov	 WORD PTR [ecx], ax
$L2865:

; 1218 : 
; 1219 :     if (CODEC_BEGIN == pau->m_codecStatus)

  00143	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00146	83 7a 48 03	 cmp	 DWORD PTR [edx+72], 3
  0014a	75 0b		 jne	 SHORT $L2867

; 1220 :         prvInitDiscardSilence(pau);

  0014c	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 _prvInitDiscardSilence_XDS@4

; 1221 :     else if (pau->m_fPacketLossAdj == WMAB_TRUE) //being seeked

  00155	eb 1b		 jmp	 SHORT $L2868
$L2867:
  00157	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0015a	83 79 50 01	 cmp	 DWORD PTR [ecx+80], 1
  0015e	75 12		 jne	 SHORT $L2868

; 1222 :         pau->m_iDiscardSilence = pau->m_cSubFrameSampleHalfAdjusted;

  00160	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00163	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00166	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  0016c	89 8a b8 03 00
	00		 mov	 DWORD PTR [edx+952], ecx
$L2868:

; 1223 :     pau->m_fPacketLossAdj = WMAB_FALSE;

  00172	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00175	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], 0

; 1224 : 
; 1225 :     // Check if the samples we just generated are to be discarded (silence)
; 1226 :     // We want to only return what the user should expect to get back from auGetPCM
; 1227 :     if (pau->m_iDiscardSilence)

  0017c	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0017f	83 b8 b8 03 00
	00 00		 cmp	 DWORD PTR [eax+952], 0
  00186	0f 84 9d 03 00
	00		 je	 $L2849

; 1228 :     {
; 1229 :         U16         uSilence;
; 1230 :         Bool        fUpdateTrig;
; 1231 : 
; 1232 :         // Part or all of the samples just generated will be discarded.
; 1233 :         if (pau->m_iDiscardSilence >= *pcSampleDecoded)

  0018c	8b 4d 0c	 mov	 ecx, DWORD PTR _pcSampleDecoded$[ebp]
  0018f	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00192	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00195	39 90 b8 03 00
	00		 cmp	 DWORD PTR [eax+952], edx
  0019b	7c 1b		 jl	 SHORT $L2873

; 1234 :         {
; 1235 :             // ALL of the samples just generated will be discarded
; 1236 : 
; 1237 :             uSilence = *pcSampleDecoded;

  0019d	8b 4d 0c	 mov	 ecx, DWORD PTR _pcSampleDecoded$[ebp]
  001a0	66 8b 11	 mov	 dx, WORD PTR [ecx]
  001a3	66 89 55 ec	 mov	 WORD PTR _uSilence$2871[ebp], dx

; 1238 :             *pcSampleDecoded = 0;

  001a7	8b 45 0c	 mov	 eax, DWORD PTR _pcSampleDecoded$[ebp]
  001aa	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 1239 :             fUpdateTrig = WMAB_FALSE;

  001af	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _fUpdateTrig$2872[ebp], 0

; 1240 :         }
; 1241 :         else

  001b6	eb 2d		 jmp	 SHORT $L2874
$L2873:

; 1242 :         {
; 1243 :             // We don't want to overreport what user will get back from auGetPCM,
; 1244 :             // so subtract the silence.
; 1245 :             uSilence = (U16) pau->m_iDiscardSilence;

  001b8	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  001bb	66 8b 91 b8 03
	00 00		 mov	 dx, WORD PTR [ecx+952]
  001c2	66 89 55 ec	 mov	 WORD PTR _uSilence$2871[ebp], dx

; 1246 :             *pcSampleDecoded -= (U16) pau->m_iDiscardSilence;

  001c6	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001c9	0f b7 88 b8 03
	00 00		 movzx	 ecx, WORD PTR [eax+952]
  001d0	8b 55 0c	 mov	 edx, DWORD PTR _pcSampleDecoded$[ebp]
  001d3	0f b7 02	 movzx	 eax, WORD PTR [edx]
  001d6	2b c1		 sub	 eax, ecx
  001d8	8b 4d 0c	 mov	 ecx, DWORD PTR _pcSampleDecoded$[ebp]
  001db	66 89 01	 mov	 WORD PTR [ecx], ax

; 1247 : 
; 1248 :             // The trigonometry is going to be used after this to compute PCM
; 1249 :             // Update it now as if we had called auGetPCM
; 1250 :             fUpdateTrig = WMAB_TRUE;

  001de	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _fUpdateTrig$2872[ebp], 1
$L2874:

; 1251 :         }
; 1252 : 
; 1253 :         // SIMULATE call to auGetPCM on behalf of the user to flush silence bits out
; 1254 :         // Avoid calling auGetPCM to discard silence because the temporary buffer
; 1255 :         // needed is objectionable to small devices
; 1256 : 
; 1257 :         // First, do things that auReconMono would normally do
; 1258 :         for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)

  001e5	66 c7 45 fc 00
	00		 mov	 WORD PTR _iChannel$[ebp], 0
  001eb	eb 0c		 jmp	 SHORT $L2877
$L2878:
  001ed	66 8b 55 fc	 mov	 dx, WORD PTR _iChannel$[ebp]
  001f1	66 83 c2 01	 add	 dx, 1
  001f5	66 89 55 fc	 mov	 WORD PTR _iChannel$[ebp], dx
$L2877:
  001f9	0f bf 45 fc	 movsx	 eax, WORD PTR _iChannel$[ebp]
  001fd	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00200	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  00204	3b c2		 cmp	 eax, edx
  00206	0f 8d 6f 02 00
	00		 jge	 $L2879

; 1259 :         {
; 1260 :             PerChannelInfo *ppcinfo = &pau->m_rgpcinfo[iChannel];

  0020c	0f bf 45 fc	 movsx	 eax, WORD PTR _iChannel$[ebp]
  00210	6b c0 70	 imul	 eax, 112		; 00000070H
  00213	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00216	03 81 a0 03 00
	00		 add	 eax, DWORD PTR [ecx+928]
  0021c	89 45 d8	 mov	 DWORD PTR _ppcinfo$2880[ebp], eax

; 1261 :             const U16 uSilenceQ2MAX = (U16)min(pau->m_iCoefRecurQ2 -
; 1262 :                 ppcinfo->m_iCurrGetPCM_SubFrame, uSilence);

  0021f	8b 55 d8	 mov	 edx, DWORD PTR _ppcinfo$2880[ebp]
  00222	0f bf 42 38	 movsx	 eax, WORD PTR [edx+56]
  00226	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00229	8b 91 90 03 00
	00		 mov	 edx, DWORD PTR [ecx+912]
  0022f	2b d0		 sub	 edx, eax
  00231	0f b7 45 ec	 movzx	 eax, WORD PTR _uSilence$2871[ebp]
  00235	3b d0		 cmp	 edx, eax
  00237	7d 17		 jge	 SHORT $L3387
  00239	8b 4d d8	 mov	 ecx, DWORD PTR _ppcinfo$2880[ebp]
  0023c	0f bf 51 38	 movsx	 edx, WORD PTR [ecx+56]
  00240	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00243	8b 88 90 03 00
	00		 mov	 ecx, DWORD PTR [eax+912]
  00249	2b ca		 sub	 ecx, edx
  0024b	89 4d b0	 mov	 DWORD PTR tv196[ebp], ecx
  0024e	eb 07		 jmp	 SHORT $L3388
$L3387:
  00250	0f b7 55 ec	 movzx	 edx, WORD PTR _uSilence$2871[ebp]
  00254	89 55 b0	 mov	 DWORD PTR tv196[ebp], edx
$L3388:
  00257	66 8b 45 b0	 mov	 ax, WORD PTR tv196[ebp]
  0025b	66 89 45 e4	 mov	 WORD PTR _uSilenceQ2MAX$2881[ebp], ax

; 1263 :             Int iCoefCount;
; 1264 :             Int iCoefCountMAX;
; 1265 :             I32 iCoefPtrOffset;
; 1266 :             Int iCoefDelta;
; 1267 : 
; 1268 : 
; 1269 :             // Need to simulate movement of coefficient ptr in auGetPCM
; 1270 :             iCoefCount = ppcinfo->m_iCurrGetPCM_SubFrame;

  0025f	8b 4d d8	 mov	 ecx, DWORD PTR _ppcinfo$2880[ebp]
  00262	0f bf 51 38	 movsx	 edx, WORD PTR [ecx+56]
  00266	89 55 e0	 mov	 DWORD PTR _iCoefCount$2883[ebp], edx

; 1271 :             iCoefCountMAX = iCoefCount + uSilence;

  00269	0f b7 45 ec	 movzx	 eax, WORD PTR _uSilence$2871[ebp]
  0026d	8b 4d e0	 mov	 ecx, DWORD PTR _iCoefCount$2883[ebp]
  00270	03 c8		 add	 ecx, eax
  00272	89 4d d4	 mov	 DWORD PTR _iCoefCountMAX$2884[ebp], ecx

; 1272 :             iCoefPtrOffset = 0;

  00275	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _iCoefPtrOffset$2885[ebp], 0

; 1273 :             if (iCoefCount < pau->m_cSubFrameSampleQuadAdjusted)

  0027c	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0027f	8b 45 e0	 mov	 eax, DWORD PTR _iCoefCount$2883[ebp]
  00282	3b 82 a0 00 00
	00		 cmp	 eax, DWORD PTR [edx+160]
  00288	7d 3d		 jge	 SHORT $L2887

; 1274 :             {
; 1275 :                 iCoefDelta = min(iCoefCountMAX, pau->m_cSubFrameSampleQuadAdjusted) - iCoefCount;

  0028a	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0028d	8b 55 d4	 mov	 edx, DWORD PTR _iCoefCountMAX$2884[ebp]
  00290	3b 91 a0 00 00
	00		 cmp	 edx, DWORD PTR [ecx+160]
  00296	7d 08		 jge	 SHORT $L3389
  00298	8b 45 d4	 mov	 eax, DWORD PTR _iCoefCountMAX$2884[ebp]
  0029b	89 45 ac	 mov	 DWORD PTR tv207[ebp], eax
  0029e	eb 0c		 jmp	 SHORT $L3390
$L3389:
  002a0	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002a3	8b 91 a0 00 00
	00		 mov	 edx, DWORD PTR [ecx+160]
  002a9	89 55 ac	 mov	 DWORD PTR tv207[ebp], edx
$L3390:
  002ac	8b 45 ac	 mov	 eax, DWORD PTR tv207[ebp]
  002af	2b 45 e0	 sub	 eax, DWORD PTR _iCoefCount$2883[ebp]
  002b2	89 45 dc	 mov	 DWORD PTR _iCoefDelta$2886[ebp], eax

; 1276 :                 iCoefPtrOffset += iCoefDelta;

  002b5	8b 4d d0	 mov	 ecx, DWORD PTR _iCoefPtrOffset$2885[ebp]
  002b8	03 4d dc	 add	 ecx, DWORD PTR _iCoefDelta$2886[ebp]
  002bb	89 4d d0	 mov	 DWORD PTR _iCoefPtrOffset$2885[ebp], ecx

; 1277 :                 iCoefCount += iCoefDelta;

  002be	8b 55 e0	 mov	 edx, DWORD PTR _iCoefCount$2883[ebp]
  002c1	03 55 dc	 add	 edx, DWORD PTR _iCoefDelta$2886[ebp]
  002c4	89 55 e0	 mov	 DWORD PTR _iCoefCount$2883[ebp], edx
$L2887:

; 1278 :             }
; 1279 : 
; 1280 :             if (iCoefCount < pau->m_iCoefRecurQ2)

  002c7	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002ca	8b 4d e0	 mov	 ecx, DWORD PTR _iCoefCount$2883[ebp]
  002cd	3b 88 90 03 00
	00		 cmp	 ecx, DWORD PTR [eax+912]
  002d3	7d 3d		 jge	 SHORT $L2888

; 1281 :             {
; 1282 :                 iCoefDelta = min(iCoefCountMAX, pau->m_iCoefRecurQ2) - iCoefCount;

  002d5	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  002d8	8b 45 d4	 mov	 eax, DWORD PTR _iCoefCountMAX$2884[ebp]
  002db	3b 82 90 03 00
	00		 cmp	 eax, DWORD PTR [edx+912]
  002e1	7d 08		 jge	 SHORT $L3391
  002e3	8b 4d d4	 mov	 ecx, DWORD PTR _iCoefCountMAX$2884[ebp]
  002e6	89 4d a8	 mov	 DWORD PTR tv216[ebp], ecx
  002e9	eb 0c		 jmp	 SHORT $L3392
$L3391:
  002eb	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  002ee	8b 82 90 03 00
	00		 mov	 eax, DWORD PTR [edx+912]
  002f4	89 45 a8	 mov	 DWORD PTR tv216[ebp], eax
$L3392:
  002f7	8b 4d a8	 mov	 ecx, DWORD PTR tv216[ebp]
  002fa	2b 4d e0	 sub	 ecx, DWORD PTR _iCoefCount$2883[ebp]
  002fd	89 4d dc	 mov	 DWORD PTR _iCoefDelta$2886[ebp], ecx

; 1283 :                 iCoefPtrOffset -= iCoefDelta;

  00300	8b 55 d0	 mov	 edx, DWORD PTR _iCoefPtrOffset$2885[ebp]
  00303	2b 55 dc	 sub	 edx, DWORD PTR _iCoefDelta$2886[ebp]
  00306	89 55 d0	 mov	 DWORD PTR _iCoefPtrOffset$2885[ebp], edx

; 1284 :                 iCoefCount += iCoefDelta;

  00309	8b 45 e0	 mov	 eax, DWORD PTR _iCoefCount$2883[ebp]
  0030c	03 45 dc	 add	 eax, DWORD PTR _iCoefDelta$2886[ebp]
  0030f	89 45 e0	 mov	 DWORD PTR _iCoefCount$2883[ebp], eax
$L2888:

; 1285 :             }
; 1286 : 
; 1287 :             if (iCoefCount < pau->m_iCoefRecurQ3)

  00312	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00315	8b 55 e0	 mov	 edx, DWORD PTR _iCoefCount$2883[ebp]
  00318	3b 91 94 03 00
	00		 cmp	 edx, DWORD PTR [ecx+916]
  0031e	7d 3a		 jge	 SHORT $L2889

; 1288 :             {
; 1289 :                 iCoefDelta = min(iCoefCountMAX, pau->m_iCoefRecurQ3) - iCoefCount;

  00320	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00323	8b 4d d4	 mov	 ecx, DWORD PTR _iCoefCountMAX$2884[ebp]
  00326	3b 88 94 03 00
	00		 cmp	 ecx, DWORD PTR [eax+916]
  0032c	7d 08		 jge	 SHORT $L3393
  0032e	8b 55 d4	 mov	 edx, DWORD PTR _iCoefCountMAX$2884[ebp]
  00331	89 55 a4	 mov	 DWORD PTR tv225[ebp], edx
  00334	eb 0c		 jmp	 SHORT $L3394
$L3393:
  00336	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00339	8b 88 94 03 00
	00		 mov	 ecx, DWORD PTR [eax+916]
  0033f	89 4d a4	 mov	 DWORD PTR tv225[ebp], ecx
$L3394:
  00342	8b 55 a4	 mov	 edx, DWORD PTR tv225[ebp]
  00345	2b 55 e0	 sub	 edx, DWORD PTR _iCoefCount$2883[ebp]
  00348	89 55 dc	 mov	 DWORD PTR _iCoefDelta$2886[ebp], edx

; 1290 :                 iCoefPtrOffset -= iCoefDelta;

  0034b	8b 45 d0	 mov	 eax, DWORD PTR _iCoefPtrOffset$2885[ebp]
  0034e	2b 45 dc	 sub	 eax, DWORD PTR _iCoefDelta$2886[ebp]
  00351	89 45 d0	 mov	 DWORD PTR _iCoefPtrOffset$2885[ebp], eax

; 1291 :                 iCoefCount = iCoefDelta;

  00354	8b 4d dc	 mov	 ecx, DWORD PTR _iCoefDelta$2886[ebp]
  00357	89 4d e0	 mov	 DWORD PTR _iCoefCount$2883[ebp], ecx
$L2889:

; 1292 :             }
; 1293 : 
; 1294 :             assert(iCoefCount <= uSilence);
; 1295 :             ppcinfo->m_rgiCoefReconCurr += iCoefPtrOffset;

  0035a	8b 55 d8	 mov	 edx, DWORD PTR _ppcinfo$2880[ebp]
  0035d	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00360	8b 4d d0	 mov	 ecx, DWORD PTR _iCoefPtrOffset$2885[ebp]
  00363	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00366	8b 45 d8	 mov	 eax, DWORD PTR _ppcinfo$2880[ebp]
  00369	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 1296 :             ppcinfo->m_piPrevOutputCurr += uSilenceQ2MAX * pau->m_cChannel;

  0036c	0f b7 4d e4	 movzx	 ecx, WORD PTR _uSilenceQ2MAX$2881[ebp]
  00370	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00373	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  00377	0f af c8	 imul	 ecx, eax
  0037a	8b 55 d8	 mov	 edx, DWORD PTR _ppcinfo$2880[ebp]
  0037d	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00380	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00383	8b 55 d8	 mov	 edx, DWORD PTR _ppcinfo$2880[ebp]
  00386	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 1297 :             ppcinfo->m_iCurrGetPCM_SubFrame += uSilence;

  00389	0f b7 45 ec	 movzx	 eax, WORD PTR _uSilence$2871[ebp]
  0038d	8b 4d d8	 mov	 ecx, DWORD PTR _ppcinfo$2880[ebp]
  00390	0f bf 51 38	 movsx	 edx, WORD PTR [ecx+56]
  00394	03 d0		 add	 edx, eax
  00396	8b 45 d8	 mov	 eax, DWORD PTR _ppcinfo$2880[ebp]
  00399	66 89 50 38	 mov	 WORD PTR [eax+56], dx

; 1298 : 
; 1299 :             if (fUpdateTrig)

  0039d	83 7d e8 00	 cmp	 DWORD PTR _fUpdateTrig$2872[ebp], 0
  003a1	0f 84 cf 00 00
	00		 je	 $L2890

; 1300 :             {
; 1301 :                 Int         iSize;
; 1302 :                 BP2Type     bpSinA;
; 1303 :                 BP2Type     bpCosA;
; 1304 :                 BP2Type     bpSinB;
; 1305 :                 BP2Type     bpCosB;
; 1306 :                 Int         iMultiplier;
; 1307 : 
; 1308 :                 //if the adjacent size is bigger; just keep your own shape
; 1309 :                 //otherwise a transition window is needed.
; 1310 :                 if (pau->m_iSizePrev >= pau->m_iSizeCurr)

  003a7	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  003aa	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003ad	8b 81 80 03 00
	00		 mov	 eax, DWORD PTR [ecx+896]
  003b3	3b 82 84 03 00
	00		 cmp	 eax, DWORD PTR [edx+900]
  003b9	7c 0e		 jl	 SHORT $L2897

; 1311 :                 {
; 1312 :                     //just forward copy curr
; 1313 : 		            iSize = pau->m_iSizeCurr;

  003bb	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  003be	8b 91 84 03 00
	00		 mov	 edx, DWORD PTR [ecx+900]
  003c4	89 55 bc	 mov	 DWORD PTR _iSize$2891[ebp], edx

; 1314 :                 }
; 1315 :                 else

  003c7	eb 0c		 jmp	 SHORT $L2898
$L2897:

; 1316 :                 {
; 1317 :                     //long start
; 1318 : 		            iSize = pau->m_iSizePrev;

  003c9	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  003cc	8b 88 80 03 00
	00		 mov	 ecx, DWORD PTR [eax+896]
  003d2	89 4d bc	 mov	 DWORD PTR _iSize$2891[ebp], ecx
$L2898:

; 1319 :                 }
; 1320 : 
; 1321 : 
; 1322 :                 // It turns out that uSilenceQ2MAX is either equal to iSize
; 1323 :                 // or equal to half of it. Our trig then simplifies to
; 1324 :                 // sin(pi/(4*iSize) + pi/X) where X = 2 or 4.
; 1325 :                 // Use trig ID's below to calculate these values.
; 1326 :                 bpSinA = *((BP2Type*)(&ppcinfo->m_iSin));

  003d5	8b 55 d8	 mov	 edx, DWORD PTR _ppcinfo$2880[ebp]
  003d8	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  003db	89 45 b8	 mov	 DWORD PTR _bpSinA$2892[ebp], eax

; 1327 :                 bpCosA = *((BP2Type*)(&ppcinfo->m_iCos));

  003de	8b 4d d8	 mov	 ecx, DWORD PTR _ppcinfo$2880[ebp]
  003e1	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  003e4	89 55 c8	 mov	 DWORD PTR _bpCosA$2893[ebp], edx

; 1328 :                 assert(uSilenceQ2MAX == iSize || uSilenceQ2MAX * 2 == iSize);
; 1329 :                 iMultiplier = iSize / uSilenceQ2MAX;

  003e7	0f b7 4d e4	 movzx	 ecx, WORD PTR _uSilenceQ2MAX$2881[ebp]
  003eb	8b 45 bc	 mov	 eax, DWORD PTR _iSize$2891[ebp]
  003ee	99		 cdq
  003ef	f7 f9		 idiv	 ecx
  003f1	89 45 c4	 mov	 DWORD PTR _iMultiplier$2896[ebp], eax

; 1330 :                 switch(iMultiplier)
; 1331 :                 {

  003f4	8b 55 c4	 mov	 edx, DWORD PTR _iMultiplier$2896[ebp]
  003f7	89 55 a0	 mov	 DWORD PTR tv256[ebp], edx
  003fa	83 7d a0 01	 cmp	 DWORD PTR tv256[ebp], 1
  003fe	74 08		 je	 SHORT $L2905
  00400	83 7d a0 02	 cmp	 DWORD PTR tv256[ebp], 2
  00404	74 12		 je	 SHORT $L2908
  00406	eb 1e		 jmp	 SHORT $L2902
$L2905:

; 1332 :                     case 1:
; 1333 :                         bpSinB = BP2_FROM_FLOAT(1.0); // sin(pi/2)

  00408	c7 45 cc 00 00
	80 3f		 mov	 DWORD PTR _bpSinB$2894[ebp], 1065353216 ; 3f800000H

; 1334 :                         bpCosB = BP2_FROM_FLOAT(0.0); // cos(pi/2)

  0040f	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _bpCosB$2895[ebp], 0

; 1335 :                         break;

  00416	eb 0e		 jmp	 SHORT $L2902
$L2908:

; 1336 : 
; 1337 :                     case 2:
; 1338 :                         bpSinB = BP2_FROM_FLOAT(0.70710678118654752440084436210485); // sin(pi/4)

  00418	c7 45 cc f3 04
	35 3f		 mov	 DWORD PTR _bpSinB$2894[ebp], 1060439283 ; 3f3504f3H

; 1339 :                         bpCosB = BP2_FROM_FLOAT(0.70710678118654752440084436210485); // cos(pi/4)

  0041f	c7 45 c0 f3 04
	35 3f		 mov	 DWORD PTR _bpCosB$2895[ebp], 1060439283 ; 3f3504f3H
$L2902:

; 1340 :                         break;
; 1341 : 
; 1342 :                     default:
; 1343 :                         assert(WMAB_FALSE);
; 1344 :                         break;
; 1345 :                 }
; 1346 : 
; 1347 : 
; 1348 :                 // Let A = start = pi/(4*iSize), B = pi/X where X = 2 or 4.
; 1349 :                 // Trig ID's: sin(A+B) = sin(A)cos(B) + cos(A)sin(B)
; 1350 :                 //            cos(A+B) = cos(A)cos(B) + sin(A)sin(B)
; 1351 :                 // To get the prior step for recursion, note that subtracting
; 1352 :                 // a step (step = 2*A) and simplifying gets us to
; 1353 :                 // sin(pi/X - pi/(4*iSize)) where X = 2 or 4.
; 1354 :                 *(BP2Type*)(&ppcinfo->m_iSin)  = MULT_BP2(bpSinA, bpCosB) +
; 1355 :                     MULT_BP2(bpCosA, bpSinB);

  00426	d9 45 b8	 fld	 DWORD PTR _bpSinA$2892[ebp]
  00429	d8 4d c0	 fmul	 DWORD PTR _bpCosB$2895[ebp]
  0042c	d9 45 c8	 fld	 DWORD PTR _bpCosA$2893[ebp]
  0042f	d8 4d cc	 fmul	 DWORD PTR _bpSinB$2894[ebp]
  00432	de c1		 faddp	 ST(1), ST(0)
  00434	8b 45 d8	 mov	 eax, DWORD PTR _ppcinfo$2880[ebp]
  00437	d9 58 4c	 fstp	 DWORD PTR [eax+76]

; 1356 :                 *(BP2Type*)(&ppcinfo->m_iCos)  = MULT_BP2(bpCosA, bpCosB) -
; 1357 :                     MULT_BP2(bpSinA, bpSinB);

  0043a	d9 45 c8	 fld	 DWORD PTR _bpCosA$2893[ebp]
  0043d	d8 4d c0	 fmul	 DWORD PTR _bpCosB$2895[ebp]
  00440	d9 45 b8	 fld	 DWORD PTR _bpSinA$2892[ebp]
  00443	d8 4d cc	 fmul	 DWORD PTR _bpSinB$2894[ebp]
  00446	de e9		 fsubp	 ST(1), ST(0)
  00448	8b 4d d8	 mov	 ecx, DWORD PTR _ppcinfo$2880[ebp]
  0044b	d9 59 50	 fstp	 DWORD PTR [ecx+80]

; 1358 :                 *(BP2Type*)(&ppcinfo->m_iSin1) = MULT_BP2(bpSinB, bpCosA) -
; 1359 :                     MULT_BP2(bpCosB, bpSinA);

  0044e	d9 45 cc	 fld	 DWORD PTR _bpSinB$2894[ebp]
  00451	d8 4d c8	 fmul	 DWORD PTR _bpCosA$2893[ebp]
  00454	d9 45 c0	 fld	 DWORD PTR _bpCosB$2895[ebp]
  00457	d8 4d b8	 fmul	 DWORD PTR _bpSinA$2892[ebp]
  0045a	de e9		 fsubp	 ST(1), ST(0)
  0045c	8b 55 d8	 mov	 edx, DWORD PTR _ppcinfo$2880[ebp]
  0045f	d9 5a 54	 fstp	 DWORD PTR [edx+84]

; 1360 :                 *(BP2Type*)(&ppcinfo->m_iCos1) = MULT_BP2(bpCosB, bpCosA) +
; 1361 :                     MULT_BP2(bpSinB, bpSinA);

  00462	d9 45 c0	 fld	 DWORD PTR _bpCosB$2895[ebp]
  00465	d8 4d c8	 fmul	 DWORD PTR _bpCosA$2893[ebp]
  00468	d9 45 cc	 fld	 DWORD PTR _bpSinB$2894[ebp]
  0046b	d8 4d b8	 fmul	 DWORD PTR _bpSinA$2892[ebp]
  0046e	de c1		 faddp	 ST(1), ST(0)
  00470	8b 45 d8	 mov	 eax, DWORD PTR _ppcinfo$2880[ebp]
  00473	d9 58 58	 fstp	 DWORD PTR [eax+88]
$L2890:

; 1362 : 
; 1363 :                 // Check the accuracy
; 1364 :                 assert(fabs(FLOAT_FROM_BP2(*((BP2Type*)(&ppcinfo->m_iSin))) -
; 1365 :                     sin(0.5 * PI / iSize / 2 * (2*uSilenceQ2MAX + 1))) <= 0.001);
; 1366 :                 assert(fabs(FLOAT_FROM_BP2(*((BP2Type*)(&ppcinfo->m_iCos))) -
; 1367 :                     cos(0.5 * PI / iSize / 2 * (2*uSilenceQ2MAX + 1))) <= 0.001);
; 1368 :                 assert(fabs(FLOAT_FROM_BP2(*((BP2Type*)(&ppcinfo->m_iSin1))) -
; 1369 :                     sin(0.5 * PI / iSize / 2 * (2*uSilenceQ2MAX - 1))) <= 0.001);
; 1370 :                 assert(fabs(FLOAT_FROM_BP2(*((BP2Type*)(&ppcinfo->m_iCos1))) -
; 1371 :                     cos(0.5 * PI / iSize / 2 * (2*uSilenceQ2MAX - 1))) <= 0.001);
; 1372 : 
; 1373 :             }
; 1374 :         }

  00476	e9 72 fd ff ff	 jmp	 $L2878
$L2879:

; 1375 : 
; 1376 : #ifdef USE_SIN_COS_TABLES
; 1377 :         if (fUpdateTrig && pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame < pau->m_iCoefRecurQ2)

  0047b	83 7d e8 00	 cmp	 DWORD PTR _fUpdateTrig$2872[ebp], 0
  0047f	74 7d		 je	 SHORT $L2916
  00481	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00484	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  0048a	0f bf 42 38	 movsx	 eax, WORD PTR [edx+56]
  0048e	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00491	3b 81 90 03 00
	00		 cmp	 eax, DWORD PTR [ecx+912]
  00497	7d 65		 jge	 SHORT $L2916

; 1378 :         {
; 1379 :             const U16 uSilenceQ2MAX = (U16)min(pau->m_iCoefRecurQ2 -
; 1380 :                 pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame, uSilence);

  00499	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0049c	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  004a2	0f bf 48 38	 movsx	 ecx, WORD PTR [eax+56]
  004a6	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  004a9	8b 82 90 03 00
	00		 mov	 eax, DWORD PTR [edx+912]
  004af	2b c1		 sub	 eax, ecx
  004b1	0f b7 4d ec	 movzx	 ecx, WORD PTR _uSilence$2871[ebp]
  004b5	3b c1		 cmp	 eax, ecx
  004b7	7d 1d		 jge	 SHORT $L3395
  004b9	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  004bc	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  004c2	0f bf 48 38	 movsx	 ecx, WORD PTR [eax+56]
  004c6	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  004c9	8b 82 90 03 00
	00		 mov	 eax, DWORD PTR [edx+912]
  004cf	2b c1		 sub	 eax, ecx
  004d1	89 45 9c	 mov	 DWORD PTR tv302[ebp], eax
  004d4	eb 07		 jmp	 SHORT $L3396
$L3395:
  004d6	0f b7 4d ec	 movzx	 ecx, WORD PTR _uSilence$2871[ebp]
  004da	89 4d 9c	 mov	 DWORD PTR tv302[ebp], ecx
$L3396:
  004dd	66 8b 55 9c	 mov	 dx, WORD PTR tv302[ebp]
  004e1	66 89 55 b4	 mov	 WORD PTR _uSilenceQ2MAX$2917[ebp], dx

; 1381 : 
; 1382 :             pau->m_piSinForRecon += uSilenceQ2MAX; // Shared by both channels

  004e5	0f b7 45 b4	 movzx	 eax, WORD PTR _uSilenceQ2MAX$2917[ebp]
  004e9	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  004ec	8b 91 28 04 00
	00		 mov	 edx, DWORD PTR [ecx+1064]
  004f2	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  004f5	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  004f8	89 81 28 04 00
	00		 mov	 DWORD PTR [ecx+1064], eax
$L2916:

; 1383 :         }
; 1384 : #endif  // USE_SIN_COS_TABLES
; 1385 : 
; 1386 :         // Next, do the things that auGetPCM would normally do
; 1387 :         pau->m_iDiscardSilence -= uSilence;

  004fe	0f b7 55 ec	 movzx	 edx, WORD PTR _uSilence$2871[ebp]
  00502	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00505	8b 88 b8 03 00
	00		 mov	 ecx, DWORD PTR [eax+952]
  0050b	2b ca		 sub	 ecx, edx
  0050d	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00510	89 8a b8 03 00
	00		 mov	 DWORD PTR [edx+952], ecx

; 1388 :         assert(pau->m_iDiscardSilence >= 0);
; 1389 :         if (CODEC_BEGIN == pau->m_codecStatus)

  00516	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00519	83 78 48 03	 cmp	 DWORD PTR [eax+72], 3
  0051d	75 0a		 jne	 SHORT $L2849

; 1390 :             pau->m_codecStatus = CODEC_STEADY;

  0051f	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00522	c7 41 48 01 00
	00 00		 mov	 DWORD PTR [ecx+72], 1
$L2849:

; 1391 : 
; 1392 :     }
; 1393 : }

  00529	8b e5		 mov	 esp, ebp
  0052b	5d		 pop	 ebp
  0052c	c2 08 00	 ret	 8
_auPreGetPCM_XDS@8 ENDP
WMADEC	ENDS
PUBLIC	_auReconMono_XDS@20
; Function compile flags: /Odt
;	COMDAT _auReconstruct_XDS@16
WMADEC	SEGMENT
_hr$ = -8
_iChannel$ = -4
_pau$ = 8
_piOutput$ = 12
_pcSampleGet$ = 16
_fForceTransformAll$ = 20
_auReconstruct_XDS@16 PROC NEAR				; COMDAT

; 1396 : WMARESULT auReconstruct (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1397 :     Int iChannel;
; 1398 :     WMARESULT hr;
; 1399 :     for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iChannel$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $L2931
$L2932:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _iChannel$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _iChannel$[ebp], eax
$L2931:
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0001b	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  0001f	39 55 fc	 cmp	 DWORD PTR _iChannel$[ebp], edx
  00022	7d 30		 jge	 SHORT $L2933

; 1400 :     {
; 1401 :         hr = (auReconMono) (pau, 
; 1402 :                           pau->m_rgpcinfo + iChannel, 
; 1403 :                           piOutput + iChannel,  
; 1404 :                           (I16*)pcSampleGet,
; 1405 :                           fForceTransformAll);

  00024	8b 45 14	 mov	 eax, DWORD PTR _fForceTransformAll$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 10	 mov	 ecx, DWORD PTR _pcSampleGet$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _iChannel$[ebp]
  0002f	8b 45 0c	 mov	 eax, DWORD PTR _piOutput$[ebp]
  00032	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00035	51		 push	 ecx
  00036	8b 55 fc	 mov	 edx, DWORD PTR _iChannel$[ebp]
  00039	6b d2 70	 imul	 edx, 112		; 00000070H
  0003c	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0003f	03 90 a0 03 00
	00		 add	 edx, DWORD PTR [eax+928]
  00045	52		 push	 edx
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 _auReconMono_XDS@20
  0004f	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1406 :     }

  00052	eb bb		 jmp	 SHORT $L2932
$L2933:

; 1407 :     return hr;

  00054	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1408 : }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 10 00	 ret	 16			; 00000010H
_auReconstruct_XDS@16 ENDP
WMADEC	ENDS
PUBLIC	_auGetPCM_XDS@16
PUBLIC	_prvDiscardSilence_XDS@16
; Function compile flags: /Odt
;	COMDAT _auGetPCM_XDS@16
WMADEC	SEGMENT
tv72 = -40
tv70 = -36
_u32MaxSamplesReq$2956 = -32
_cMaxSamplesInDst$2954 = -28
_cSamplesLeft$ = -24
_pcbDstUsed$ = -20
_hr$ = -16
_cSamplesREQ$ = -12
_piOutput$ = -8
_cbDstUsed$ = -4
_pau$ = 8
_pcSample$ = 12
_pbDst$ = 16
_cbDstLength$ = 20
_auGetPCM_XDS@16 PROC NEAR				; COMDAT

; 1412 : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 1413 :     Int cbDstUsed;
; 1414 :     Int* pcbDstUsed = &cbDstUsed;

  00006	8d 45 fc	 lea	 eax, DWORD PTR _cbDstUsed$[ebp]
  00009	89 45 ec	 mov	 DWORD PTR _pcbDstUsed$[ebp], eax

; 1415 :     WMARESULT hr;
; 1416 :     I16* piOutput = (I16*) pbDst;

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  0000f	89 4d f8	 mov	 DWORD PTR _piOutput$[ebp], ecx

; 1417 : 
; 1418 :     U32 cSamplesLeft;
; 1419 :     I16 cSamplesREQ;
; 1420 : 
; 1421 :     cSamplesLeft = *pcSample;

  00012	8b 55 0c	 mov	 edx, DWORD PTR _pcSample$[ebp]
  00015	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00018	89 45 e8	 mov	 DWORD PTR _cSamplesLeft$[ebp], eax
$L2951:

; 1422 :     do
; 1423 :     {
; 1424 :         const U32 cMaxSamplesInDst = (cbDstLength / sizeof (I16) / pau->m_cChannel);

  0001b	8b 45 14	 mov	 eax, DWORD PTR _cbDstLength$[ebp]
  0001e	d1 e8		 shr	 eax, 1
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00023	0f b7 49 58	 movzx	 ecx, WORD PTR [ecx+88]
  00027	33 d2		 xor	 edx, edx
  00029	f7 f1		 div	 ecx
  0002b	89 45 e4	 mov	 DWORD PTR _cMaxSamplesInDst$2954[ebp], eax

; 1425 : 
; 1426 :         // Limit requested number of bytes to fit within the buffer
; 1427 :         const U32 u32MaxSamplesReq = min(cSamplesLeft, cMaxSamplesInDst);

  0002e	8b 55 e8	 mov	 edx, DWORD PTR _cSamplesLeft$[ebp]
  00031	3b 55 e4	 cmp	 edx, DWORD PTR _cMaxSamplesInDst$2954[ebp]
  00034	73 08		 jae	 SHORT $L3403
  00036	8b 45 e8	 mov	 eax, DWORD PTR _cSamplesLeft$[ebp]
  00039	89 45 dc	 mov	 DWORD PTR tv70[ebp], eax
  0003c	eb 06		 jmp	 SHORT $L3404
$L3403:
  0003e	8b 4d e4	 mov	 ecx, DWORD PTR _cMaxSamplesInDst$2954[ebp]
  00041	89 4d dc	 mov	 DWORD PTR tv70[ebp], ecx
$L3404:
  00044	8b 55 dc	 mov	 edx, DWORD PTR tv70[ebp]
  00047	89 55 e0	 mov	 DWORD PTR _u32MaxSamplesReq$2956[ebp], edx

; 1428 : 
; 1429 :         // limit request to fit in I16
; 1430 :         cSamplesREQ = (I16) min(u32MaxSamplesReq, SHRT_MAX);

  0004a	81 7d e0 ff 7f
	00 00		 cmp	 DWORD PTR _u32MaxSamplesReq$2956[ebp], 32767 ; 00007fffH
  00051	73 08		 jae	 SHORT $L3405
  00053	8b 45 e0	 mov	 eax, DWORD PTR _u32MaxSamplesReq$2956[ebp]
  00056	89 45 d8	 mov	 DWORD PTR tv72[ebp], eax
  00059	eb 07		 jmp	 SHORT $L3406
$L3405:
  0005b	c7 45 d8 ff 7f
	00 00		 mov	 DWORD PTR tv72[ebp], 32767 ; 00007fffH
$L3406:
  00062	66 8b 4d d8	 mov	 cx, WORD PTR tv72[ebp]
  00066	66 89 4d f4	 mov	 WORD PTR _cSamplesREQ$[ebp], cx

; 1431 : 
; 1432 :         hr = (*pau->aupfnReconstruct) (pau,
; 1433 :                           piOutput,
; 1434 :                           &cSamplesREQ,
; 1435 :                           WMAB_FALSE);

  0006a	6a 00		 push	 0
  0006c	8d 55 f4	 lea	 edx, DWORD PTR _cSamplesREQ$[ebp]
  0006f	52		 push	 edx
  00070	8b 45 f8	 mov	 eax, DWORD PTR _piOutput$[ebp]
  00073	50		 push	 eax
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00077	51		 push	 ecx
  00078	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0007b	ff 92 f8 03 00
	00		 call	 DWORD PTR [edx+1016]
  00081	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 1436 : 
; 1437 :         cSamplesLeft -= cSamplesREQ;

  00084	0f bf 45 f4	 movsx	 eax, WORD PTR _cSamplesREQ$[ebp]
  00088	8b 4d e8	 mov	 ecx, DWORD PTR _cSamplesLeft$[ebp]
  0008b	2b c8		 sub	 ecx, eax
  0008d	89 4d e8	 mov	 DWORD PTR _cSamplesLeft$[ebp], ecx

; 1438 :         if (0 == cSamplesREQ)

  00090	0f bf 55 f4	 movsx	 edx, WORD PTR _cSamplesREQ$[ebp]
  00094	85 d2		 test	 edx, edx
  00096	75 02		 jne	 SHORT $L2958

; 1439 :             // No more samples to retrieve, the well is dry. Avoid infinite loop
; 1440 :             break;

  00098	eb 37		 jmp	 SHORT $L2953
$L2958:

; 1441 : 
; 1442 :         // Check if we just reconstructed silence that we need to toss
; 1443 :         if (pau->m_iDiscardSilence)

  0009a	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0009d	83 b8 b8 03 00
	00 00		 cmp	 DWORD PTR [eax+952], 0
  000a4	74 19		 je	 SHORT $L2952

; 1444 :             prvDiscardSilence(pau, (unsigned short *)&cSamplesREQ, pau->m_cChannel, pbDst);

  000a6	8b 4d 10	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  000a9	51		 push	 ecx
  000aa	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000ad	66 8b 42 58	 mov	 ax, WORD PTR [edx+88]
  000b1	50		 push	 eax
  000b2	8d 4d f4	 lea	 ecx, DWORD PTR _cSamplesREQ$[ebp]
  000b5	51		 push	 ecx
  000b6	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000b9	52		 push	 edx
  000ba	e8 00 00 00 00	 call	 _prvDiscardSilence_XDS@16
$L2952:

; 1445 : 
; 1446 :     } while (0 == cSamplesREQ && 0 != cSamplesLeft);

  000bf	0f bf 45 f4	 movsx	 eax, WORD PTR _cSamplesREQ$[ebp]
  000c3	85 c0		 test	 eax, eax
  000c5	75 0a		 jne	 SHORT $L2953
  000c7	83 7d e8 00	 cmp	 DWORD PTR _cSamplesLeft$[ebp], 0
  000cb	0f 85 4a ff ff
	ff		 jne	 $L2951
$L2953:

; 1447 : 
; 1448 :     if (CODEC_BEGIN == pau->m_codecStatus)

  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000d4	83 79 48 03	 cmp	 DWORD PTR [ecx+72], 3
  000d8	75 0a		 jne	 SHORT $L2962

; 1449 :         pau->m_codecStatus = CODEC_STEADY;

  000da	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000dd	c7 42 48 01 00
	00 00		 mov	 DWORD PTR [edx+72], 1
$L2962:

; 1450 : 
; 1451 :     *pcSample = cSamplesREQ;

  000e4	8b 45 0c	 mov	 eax, DWORD PTR _pcSample$[ebp]
  000e7	66 8b 4d f4	 mov	 cx, WORD PTR _cSamplesREQ$[ebp]
  000eb	66 89 08	 mov	 WORD PTR [eax], cx

; 1452 :     *pcbDstUsed = (*pcSample) * pau->m_cChannel * sizeof (I16); // in bytes

  000ee	8b 55 0c	 mov	 edx, DWORD PTR _pcSample$[ebp]
  000f1	0f b7 02	 movzx	 eax, WORD PTR [edx]
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000f7	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  000fb	0f af c2	 imul	 eax, edx
  000fe	d1 e0		 shl	 eax, 1
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _pcbDstUsed$[ebp]
  00103	89 01		 mov	 DWORD PTR [ecx], eax

; 1453 : 
; 1454 : #   ifdef INTERPOLATED_DOWNSAMPLE
; 1455 :         if (pau->m_fDownsample) {
; 1456 :             prvInterpolate(pau, piOutput, *pcbDstUsed, pau->m_cChannel,
; 1457 :                 piOutput, pcbDstUsed, pcSample);
; 1458 :         }
; 1459 : #   endif  // INTERPOLATED_DOWNSAMPLE
; 1460 : 
; 1461 : #if defined(HALF_TRANSFORM)
; 1462 :     // interpolate 2X 
; 1463 :     // This simple linear interpolation is fast but does not remove aliasing 
; 1464 :     // So it should not be used with the HALF_TRANSFORM case if audio quality is important
; 1465 :     if (pau->m_fUpsample && *pcbDstUsed > 0)
; 1466 :     {
; 1467 :         // work from back of buffer to front so we do not overwrite any values we still need to use
; 1468 :         Int iChannel;
; 1469 :         Int iSamplesPerChannel = *pcbDstUsed / (sizeof(I16) * pau->m_cChannel);
; 1470 :         const int c_iDecr = pau->m_cChannel;
; 1471 : 
; 1472 :         for (iChannel = 0; iChannel < c_iDecr; iChannel++)
; 1473 :         {
; 1474 : 
; 1475 :             I16 *piInput = piOutput + iChannel + (iSamplesPerChannel - 1) * c_iDecr;
; 1476 :             I16 *piOutputx = piOutput + iChannel + (2 * iSamplesPerChannel - 1) * c_iDecr;
; 1477 :             I16 iNextInput, iPrevInput;
; 1478 : 
; 1479 :             iNextInput = *piInput;
; 1480 :             while (piOutputx > (piOutput + iChannel + 2))
; 1481 :             {
; 1482 :                 assert(piOutputx >= piInput + iChannel);
; 1483 :                 *piOutputx = iNextInput;
; 1484 :                 piOutputx -= c_iDecr;
; 1485 : 
; 1486 :                 iPrevInput = iNextInput;
; 1487 : 
; 1488 :                 piInput  -= c_iDecr;
; 1489 :                 assert(piInput >= (piOutput + iChannel));
; 1490 :                 iNextInput = *piInput;
; 1491 : 
; 1492 :                 assert(piOutputx >= piInput + iChannel);
; 1493 :                 *piOutputx = (iPrevInput >> 1) + (iNextInput >> 1);
; 1494 :                 assert(fabs((double)(*piOutputx) - ((double)iPrevInput +
; 1495 :                     (double)iNextInput)/2.0) <= 1);
; 1496 : 
; 1497 :                 piOutputx -= c_iDecr;
; 1498 :             }
; 1499 : 
; 1500 :             // handle beginning of buffer case
; 1501 :             assert( piOutputx == piOutput + iChannel + 2);
; 1502 :             *piOutputx = iNextInput;
; 1503 :             piOutputx -= c_iDecr;
; 1504 : 
; 1505 :             iPrevInput = iNextInput;
; 1506 : 
; 1507 :             assert(piInput >= (piOutput + iChannel));
; 1508 :             iNextInput = pau->m_iPriorSample[iChannel];
; 1509 : 
; 1510 :             assert(piOutputx >= piInput);
; 1511 :             *piOutputx = (iPrevInput >> 1) + (iNextInput >> 1);
; 1512 :             assert(fabs((double)(*piOutputx) - ((double)iPrevInput +
; 1513 :                 (double)iNextInput)/2.0) <= 1);
; 1514 : 
; 1515 :             pau->m_iPriorSample[iChannel] = *(piOutput + iChannel + (2 * iSamplesPerChannel - 1) * c_iDecr);
; 1516 : 
; 1517 :         }
; 1518 : 
; 1519 :         *pcSample   *= 2;
; 1520 :         *pcbDstUsed *= 2;
; 1521 :     }
; 1522 : #endif  // defined(HALF_TRANSFORM)
; 1523 : 
; 1524 :     //FUNCTION_PROFILE_STOP(&fp);
; 1525 :     return WMA_OK;

  00105	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK

; 1526 : 
; 1527 : }

  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c2 10 00	 ret	 16			; 00000010H
_auGetPCM_XDS@16 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _auReconMono_XDS@20
WMADEC	SEGMENT
tv255 = -140
tv256 = -136
tv245 = -132
tv231 = -128
tv232 = -124
tv173 = -120
tv159 = -116
tv160 = -112
tv132 = -108
_c_iSignOffset$3007 = -104
_c_iOffset$3006 = -100
_bp2CosT$ = -96
_iCoefRecurQ2$ = -92
_piSrcSign$ = -88
_bp2Sin1$ = -84
_fTrigUpdated$ = -80
_piCoef$ = -76
_iSegEnd$ = -72
_iEnd$ = -68
_cChan$ = -64
_iCoefRecurQ3$ = -60
_piDst$ = -56
_bp2Step$ = -52
_uiSignbitCount$ = -48
_iResult$ = -44
_cfResult$ = -40
_cSubFrameSampleQuad$ = -36
_cSubFrameSampleHalf$ = -32
_bp2Sin$ = -28
_uiSignbitData$ = -24
_bp2SinT$ = -20
_bp2Cos$ = -16
_i$ = -12
_piSrc$ = -8
_bp2Cos1$ = -4
_pau$ = 8
_ppcinfo$ = 12
_piOutput$ = 16
_pcSampleGet$ = 20
_fForceTransformAll$ = 24
_auReconMono_XDS@20 PROC NEAR				; COMDAT

; 1747 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH

; 1748 :     //all starting from the begining of this frame
; 1749 :     //official starting of a subfrm (including leading zeros)
; 1750 :     //case 1 (Large -> Small):  starts later than what's been reconstructed w/o leading zeros
; 1751 :     //                          in this case dst should be skiped (this may mean memcpy from prev)
; 1752 :     //                          src and coef are fine
; 1753 :     //                          
; 1754 :     //case 2 (Small -> Large):  starts earler than what's been reconstructed but all leading zeros
; 1755 :     //                          in this case dst 
; 1756 : 
; 1757 :     BP2Type bp2SinT;     //temp sin value within recurrsion
; 1758 :     BP2Type bp2CosT;     //temp cos value within recurrsion
; 1759 :     CoefType *piCoef;   //floating vlaue = (float)*piCoef/(1<<5)  assuming TRANSFORM_FRACT_BITS = 5
; 1760 :     Int i, iEnd, iSegEnd;
; 1761 :     I16 *piSrc, *piDst; 
; 1762 :     I32 iResult;
; 1763 :     CoefType cfResult;
; 1764 :     // get local copies of these values which are used frequently or repeatedly (helps optimization)
; 1765 :     Int cChan = pau->m_cChannel;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0000c	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  00010	89 4d c0	 mov	 DWORD PTR _cChan$[ebp], ecx

; 1766 :     Int cSubFrameSampleHalf = pau->m_cSubFrameSampleHalfAdjusted;

  00013	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00016	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  0001c	89 45 e0	 mov	 DWORD PTR _cSubFrameSampleHalf$[ebp], eax

; 1767 :     Int cSubFrameSampleQuad = pau->m_cSubFrameSampleQuadAdjusted;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00022	8b 91 a0 00 00
	00		 mov	 edx, DWORD PTR [ecx+160]
  00028	89 55 dc	 mov	 DWORD PTR _cSubFrameSampleQuad$[ebp], edx

; 1768 :     Int iCoefRecurQ2 = pau->m_iCoefRecurQ2;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0002e	8b 88 90 03 00
	00		 mov	 ecx, DWORD PTR [eax+912]
  00034	89 4d a4	 mov	 DWORD PTR _iCoefRecurQ2$[ebp], ecx

; 1769 :     Int iCoefRecurQ3 = pau->m_iCoefRecurQ3;

  00037	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0003a	8b 82 94 03 00
	00		 mov	 eax, DWORD PTR [edx+916]
  00040	89 45 c4	 mov	 DWORD PTR _iCoefRecurQ3$[ebp], eax

; 1770 :     BP2Type bp2Sin  = *((BP2Type*)(&ppcinfo->m_iSin));

  00043	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00046	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00049	89 55 e4	 mov	 DWORD PTR _bp2Sin$[ebp], edx

; 1771 :     BP2Type bp2Cos  = *((BP2Type*)(&ppcinfo->m_iCos));

  0004c	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  0004f	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00052	89 4d f0	 mov	 DWORD PTR _bp2Cos$[ebp], ecx

; 1772 :     BP2Type bp2Sin1 = *((BP2Type*)(&ppcinfo->m_iSin1));

  00055	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00058	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  0005b	89 45 ac	 mov	 DWORD PTR _bp2Sin1$[ebp], eax

; 1773 :     BP2Type bp2Cos1 = *((BP2Type*)(&ppcinfo->m_iCos1));

  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00061	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00064	89 55 fc	 mov	 DWORD PTR _bp2Cos1$[ebp], edx

; 1774 :     BP2Type bp2Step = *((BP2Type*)(&ppcinfo->m_iStep));

  00067	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  0006a	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0006d	89 4d cc	 mov	 DWORD PTR _bp2Step$[ebp], ecx

; 1775 :     int fTrigUpdated = 0;

  00070	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _fTrigUpdated$[ebp], 0

; 1776 : 
; 1777 : #ifndef PREVOUTPUT_16BITS
; 1778 :     I16    *piSrcSign;
; 1779 :     U32     uiSignbitData;
; 1780 :     U32     uiSignbitCount;
; 1781 : #endif  // PREVOUTPUT_16BITS
; 1782 : #ifdef PROFILE
; 1783 :     FunctionProfile fp;
; 1784 :     FunctionProfileStart(&fp,RECON_MONO_PROFILE);
; 1785 : #endif
; 1786 :     DEBUG_IT_FRAME_BREAK;
; 1787 : 
; 1788 :     //persistent states
; 1789 :     i = ppcinfo->m_iCurrGetPCM_SubFrame;       //current position in a frame

  00077	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  0007a	0f bf 42 38	 movsx	 eax, WORD PTR [edx+56]
  0007e	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax

; 1790 :     piCoef = (CoefType*)ppcinfo->m_rgiCoefReconCurr; 

  00081	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00084	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00087	89 55 b4	 mov	 DWORD PTR _piCoef$[ebp], edx

; 1791 :     piSrc = ppcinfo->m_piPrevOutputCurr;

  0008a	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  0008d	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00090	89 4d f8	 mov	 DWORD PTR _piSrc$[ebp], ecx

; 1792 : 
; 1793 :     //eventually we'll use piOutput directly
; 1794 :     piDst = piOutput;

  00093	8b 55 10	 mov	 edx, DWORD PTR _piOutput$[ebp]
  00096	89 55 c8	 mov	 DWORD PTR _piDst$[ebp], edx

; 1795 : 
; 1796 :     iEnd = i + *pcSampleGet;

  00099	8b 45 14	 mov	 eax, DWORD PTR _pcSampleGet$[ebp]
  0009c	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0009f	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000a2	03 d1		 add	 edx, ecx
  000a4	89 55 bc	 mov	 DWORD PTR _iEnd$[ebp], edx

; 1797 :     *pcSampleGet = 0;

  000a7	8b 45 14	 mov	 eax, DWORD PTR _pcSampleGet$[ebp]
  000aa	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 1798 : 
; 1799 :     CALC_SIGN_OFFSETS(ppcinfo->m_piPrevOutput, piSrc, ppcinfo->m_piPrevOutputSign, piSrcSign, 
; 1800 :         uiSignbitData, uiSignbitCount, cChan)

  000af	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  000b2	8b 55 f8	 mov	 edx, DWORD PTR _piSrc$[ebp]
  000b5	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  000b8	d1 fa		 sar	 edx, 1
  000ba	8b 4d c0	 mov	 ecx, DWORD PTR _cChan$[ebp]
  000bd	83 e9 01	 sub	 ecx, 1
  000c0	d3 fa		 sar	 edx, cl
  000c2	89 55 9c	 mov	 DWORD PTR _c_iOffset$3006[ebp], edx
  000c5	8b 45 9c	 mov	 eax, DWORD PTR _c_iOffset$3006[ebp]
  000c8	83 c0 0f	 add	 eax, 15			; 0000000fH
  000cb	c1 e8 04	 shr	 eax, 4
  000ce	89 45 98	 mov	 DWORD PTR _c_iSignOffset$3007[ebp], eax
  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  000d4	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  000d7	8b 45 98	 mov	 eax, DWORD PTR _c_iSignOffset$3007[ebp]
  000da	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  000dd	89 4d a8	 mov	 DWORD PTR _piSrcSign$[ebp], ecx
  000e0	8b 45 9c	 mov	 eax, DWORD PTR _c_iOffset$3006[ebp]
  000e3	33 d2		 xor	 edx, edx
  000e5	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000ea	f7 f1		 div	 ecx
  000ec	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000f1	2b c2		 sub	 eax, edx
  000f3	89 45 d0	 mov	 DWORD PTR _uiSignbitCount$[ebp], eax
  000f6	83 7d d0 10	 cmp	 DWORD PTR _uiSignbitCount$[ebp], 16 ; 00000010H
  000fa	75 14		 jne	 SHORT $L3011
  000fc	8b 4d a8	 mov	 ecx, DWORD PTR _piSrcSign$[ebp]
  000ff	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00102	89 55 e8	 mov	 DWORD PTR _uiSignbitData$[ebp], edx
  00105	8b 45 a8	 mov	 eax, DWORD PTR _piSrcSign$[ebp]
  00108	83 c0 02	 add	 eax, 2
  0010b	89 45 a8	 mov	 DWORD PTR _piSrcSign$[ebp], eax
  0010e	eb 0a		 jmp	 SHORT $L3012
$L3011:
  00110	8b 4d a8	 mov	 ecx, DWORD PTR _piSrcSign$[ebp]
  00113	0f bf 51 fe	 movsx	 edx, WORD PTR [ecx-2]
  00117	89 55 e8	 mov	 DWORD PTR _uiSignbitData$[ebp], edx
$L3012:

; 1801 :     ASSERT_SIGNBIT_POINTER(piSrcSign);
; 1802 : 
; 1803 : #if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
; 1804 :     iSegEnd = 0;
; 1805 :     if (i < cSubFrameSampleQuad) iSegEnd = min (cSubFrameSampleQuad, iEnd);
; 1806 :     if (iSegEnd < iCoefRecurQ2)  iSegEnd = min (iCoefRecurQ2, iEnd);
; 1807 :     if (iSegEnd < iCoefRecurQ3)  iSegEnd = min (iCoefRecurQ3, iEnd);
; 1808 :     if ( i < iSegEnd )
; 1809 :         prvWmaShowFrames(pau, "RecMono", " %4d 0x%08x 0x%08x 0x%08x %4d %4d %4d %4d", 
; 1810 :             i, piCoef, piSrc, piDst, cSubFrameSampleQuad, iCoefRecurQ2, iCoefRecurQ3, iSegEnd);
; 1811 : #endif
; 1812 :     if (i < cSubFrameSampleQuad) 

  0011a	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0011d	3b 45 dc	 cmp	 eax, DWORD PTR _cSubFrameSampleQuad$[ebp]
  00120	0f 8d 69 01 00
	00		 jge	 $L3013

; 1813 :     {
; 1814 :         DEBUG_IT_SIN_INIT(0,bp2Sin,bp2Cos,bp2Sin1,bp2Cos1,bp2Step);
; 1815 :         iSegEnd = min (cSubFrameSampleQuad, iEnd);

  00126	8b 4d dc	 mov	 ecx, DWORD PTR _cSubFrameSampleQuad$[ebp]
  00129	3b 4d bc	 cmp	 ecx, DWORD PTR _iEnd$[ebp]
  0012c	7d 08		 jge	 SHORT $L3410
  0012e	8b 55 dc	 mov	 edx, DWORD PTR _cSubFrameSampleQuad$[ebp]
  00131	89 55 94	 mov	 DWORD PTR tv132[ebp], edx
  00134	eb 06		 jmp	 SHORT $L3411
$L3410:
  00136	8b 45 bc	 mov	 eax, DWORD PTR _iEnd$[ebp]
  00139	89 45 94	 mov	 DWORD PTR tv132[ebp], eax
$L3411:
  0013c	8b 4d 94	 mov	 ecx, DWORD PTR tv132[ebp]
  0013f	89 4d b8	 mov	 DWORD PTR _iSegEnd$[ebp], ecx

; 1816 :         if ( i < iSegEnd )

  00142	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00145	3b 55 b8	 cmp	 edx, DWORD PTR _iSegEnd$[ebp]
  00148	0f 8d 41 01 00
	00		 jge	 $L3013

; 1817 :         {
; 1818 :             fTrigUpdated = 1;

  0014e	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _fTrigUpdated$[ebp], 1

; 1819 :             for (; i < iSegEnd; i++, (*pcSampleGet)++)    {

  00155	eb 19		 jmp	 SHORT $L3015
$L3016:
  00157	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0015a	83 c0 01	 add	 eax, 1
  0015d	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  00160	8b 4d 14	 mov	 ecx, DWORD PTR _pcSampleGet$[ebp]
  00163	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00166	66 83 c2 01	 add	 dx, 1
  0016a	8b 45 14	 mov	 eax, DWORD PTR _pcSampleGet$[ebp]
  0016d	66 89 10	 mov	 WORD PTR [eax], dx
$L3015:
  00170	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00173	3b 4d b8	 cmp	 ecx, DWORD PTR _iSegEnd$[ebp]
  00176	0f 8d 13 01 00
	00		 jge	 $L3013

; 1820 : 
; 1821 :                 COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData,
; 1822 :                     uiSignbitCount);

  0017c	83 7d d0 00	 cmp	 DWORD PTR _uiSignbitCount$[ebp], 0
  00180	75 19		 jne	 SHORT $L3018
  00182	8b 55 a8	 mov	 edx, DWORD PTR _piSrcSign$[ebp]
  00185	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00188	89 45 e8	 mov	 DWORD PTR _uiSignbitData$[ebp], eax
  0018b	8b 4d a8	 mov	 ecx, DWORD PTR _piSrcSign$[ebp]
  0018e	83 c1 02	 add	 ecx, 2
  00191	89 4d a8	 mov	 DWORD PTR _piSrcSign$[ebp], ecx
  00194	c7 45 d0 10 00
	00 00		 mov	 DWORD PTR _uiSignbitCount$[ebp], 16 ; 00000010H
$L3018:
  0019b	8b 55 e8	 mov	 edx, DWORD PTR _uiSignbitData$[ebp]
  0019e	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  001a4	85 d2		 test	 edx, edx
  001a6	74 09		 je	 SHORT $L3019
  001a8	c7 45 d4 00 00
	ff ff		 mov	 DWORD PTR _iResult$[ebp], -65536 ; ffff0000H
  001af	eb 07		 jmp	 SHORT $L3020
$L3019:
  001b1	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _iResult$[ebp], 0
$L3020:
  001b8	8b 45 f8	 mov	 eax, DWORD PTR _piSrc$[ebp]
  001bb	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  001be	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  001c4	8b 55 d4	 mov	 edx, DWORD PTR _iResult$[ebp]
  001c7	0b d1		 or	 edx, ecx
  001c9	89 55 d4	 mov	 DWORD PTR _iResult$[ebp], edx
  001cc	8b 45 e8	 mov	 eax, DWORD PTR _uiSignbitData$[ebp]
  001cf	d1 e0		 shl	 eax, 1
  001d1	89 45 e8	 mov	 DWORD PTR _uiSignbitData$[ebp], eax
  001d4	8b 4d d0	 mov	 ecx, DWORD PTR _uiSignbitCount$[ebp]
  001d7	83 e9 01	 sub	 ecx, 1
  001da	89 4d d0	 mov	 DWORD PTR _uiSignbitCount$[ebp], ecx

; 1823 : 
; 1824 :                 cfResult = INT_FROM_COEF( MULT_BP2(-bp2Sin,*piCoef++) + COEF_FROM_INT(iResult) );

  001dd	d9 45 e4	 fld	 DWORD PTR _bp2Sin$[ebp]
  001e0	d9 e0		 fchs
  001e2	8b 55 b4	 mov	 edx, DWORD PTR _piCoef$[ebp]
  001e5	d8 0a		 fmul	 DWORD PTR [edx]
  001e7	da 45 d4	 fiadd	 DWORD PTR _iResult$[ebp]
  001ea	d9 5d d8	 fstp	 DWORD PTR _cfResult$[ebp]
  001ed	8b 45 b4	 mov	 eax, DWORD PTR _piCoef$[ebp]
  001f0	83 c0 04	 add	 eax, 4
  001f3	89 45 b4	 mov	 DWORD PTR _piCoef$[ebp], eax

; 1825 :                 ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );

  001f6	8b 4d d8	 mov	 ecx, DWORD PTR _cfResult$[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 @ROUNDF@4
  001ff	89 45 d4	 mov	 DWORD PTR _iResult$[ebp], eax
  00202	81 7d d4 00 80
	ff ff		 cmp	 DWORD PTR _iResult$[ebp], -32768 ; ffff8000H
  00209	7d 09		 jge	 SHORT $L3414
  0020b	c7 45 90 00 80
	ff ff		 mov	 DWORD PTR tv160[ebp], -32768 ; ffff8000H
  00212	eb 1e		 jmp	 SHORT $L3415
$L3414:
  00214	81 7d d4 ff 7f
	00 00		 cmp	 DWORD PTR _iResult$[ebp], 32767 ; 00007fffH
  0021b	7e 09		 jle	 SHORT $L3412
  0021d	c7 45 8c ff 7f
	00 00		 mov	 DWORD PTR tv159[ebp], 32767 ; 00007fffH
  00224	eb 06		 jmp	 SHORT $L3413
$L3412:
  00226	8b 55 d4	 mov	 edx, DWORD PTR _iResult$[ebp]
  00229	89 55 8c	 mov	 DWORD PTR tv159[ebp], edx
$L3413:
  0022c	8b 45 8c	 mov	 eax, DWORD PTR tv159[ebp]
  0022f	89 45 90	 mov	 DWORD PTR tv160[ebp], eax
$L3415:
  00232	8b 4d 90	 mov	 ecx, DWORD PTR tv160[ebp]
  00235	89 4d d4	 mov	 DWORD PTR _iResult$[ebp], ecx
  00238	8b 55 c8	 mov	 edx, DWORD PTR _piDst$[ebp]
  0023b	66 8b 45 d4	 mov	 ax, WORD PTR _iResult$[ebp]
  0023f	66 89 02	 mov	 WORD PTR [edx], ax

; 1826 : 
; 1827 :                 DEBUG_IT_SAMPLE_BREAK(i,  iResult, bp2Sin);
; 1828 : 
; 1829 :                 piSrc += cChan;

  00242	8b 4d c0	 mov	 ecx, DWORD PTR _cChan$[ebp]
  00245	8b 55 f8	 mov	 edx, DWORD PTR _piSrc$[ebp]
  00248	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0024b	89 45 f8	 mov	 DWORD PTR _piSrc$[ebp], eax

; 1830 :                 piDst += cChan;

  0024e	8b 4d c0	 mov	 ecx, DWORD PTR _cChan$[ebp]
  00251	8b 55 c8	 mov	 edx, DWORD PTR _piDst$[ebp]
  00254	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00257	89 45 c8	 mov	 DWORD PTR _piDst$[ebp], eax

; 1831 :                 // sin(a+b) = sin(a-b) + 2*sin(b)*cos(a)
; 1832 :                 // cos(a+b) = cos(a-b) - 2*sin(b)*sin(a)
; 1833 :                 bp2SinT = bp2Sin1 + MULT_BP2(bp2Step,bp2Cos);

  0025a	d9 45 cc	 fld	 DWORD PTR _bp2Step$[ebp]
  0025d	d8 4d f0	 fmul	 DWORD PTR _bp2Cos$[ebp]
  00260	d8 45 ac	 fadd	 DWORD PTR _bp2Sin1$[ebp]
  00263	d9 5d ec	 fstp	 DWORD PTR _bp2SinT$[ebp]

; 1834 :                 bp2CosT = bp2Cos1 - MULT_BP2(bp2Step,bp2Sin);

  00266	d9 45 cc	 fld	 DWORD PTR _bp2Step$[ebp]
  00269	d8 4d e4	 fmul	 DWORD PTR _bp2Sin$[ebp]
  0026c	d8 6d fc	 fsubr	 DWORD PTR _bp2Cos1$[ebp]
  0026f	d9 5d a0	 fstp	 DWORD PTR _bp2CosT$[ebp]

; 1835 :                 bp2Sin1 = bp2Sin;  bp2Sin = bp2SinT;

  00272	8b 4d e4	 mov	 ecx, DWORD PTR _bp2Sin$[ebp]
  00275	89 4d ac	 mov	 DWORD PTR _bp2Sin1$[ebp], ecx
  00278	8b 55 ec	 mov	 edx, DWORD PTR _bp2SinT$[ebp]
  0027b	89 55 e4	 mov	 DWORD PTR _bp2Sin$[ebp], edx

; 1836 :                 bp2Cos1 = bp2Cos;  bp2Cos = bp2CosT;

  0027e	8b 45 f0	 mov	 eax, DWORD PTR _bp2Cos$[ebp]
  00281	89 45 fc	 mov	 DWORD PTR _bp2Cos1$[ebp], eax
  00284	8b 4d a0	 mov	 ecx, DWORD PTR _bp2CosT$[ebp]
  00287	89 4d f0	 mov	 DWORD PTR _bp2Cos$[ebp], ecx

; 1837 :             }

  0028a	e9 c8 fe ff ff	 jmp	 $L3016
$L3013:

; 1838 :         }
; 1839 :     }
; 1840 :     if (i < iCoefRecurQ2)  

  0028f	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00292	3b 55 a4	 cmp	 edx, DWORD PTR _iCoefRecurQ2$[ebp]
  00295	0f 8d 66 01 00
	00		 jge	 $L3023

; 1841 :     {
; 1842 :         DEBUG_IT_SIN_INIT(1,bp2Sin,bp2Cos,bp2Sin1,bp2Cos1,bp2Step);
; 1843 :         iSegEnd = min (iCoefRecurQ2, iEnd);

  0029b	8b 45 a4	 mov	 eax, DWORD PTR _iCoefRecurQ2$[ebp]
  0029e	3b 45 bc	 cmp	 eax, DWORD PTR _iEnd$[ebp]
  002a1	7d 08		 jge	 SHORT $L3416
  002a3	8b 4d a4	 mov	 ecx, DWORD PTR _iCoefRecurQ2$[ebp]
  002a6	89 4d 88	 mov	 DWORD PTR tv173[ebp], ecx
  002a9	eb 06		 jmp	 SHORT $L3417
$L3416:
  002ab	8b 55 bc	 mov	 edx, DWORD PTR _iEnd$[ebp]
  002ae	89 55 88	 mov	 DWORD PTR tv173[ebp], edx
$L3417:
  002b1	8b 45 88	 mov	 eax, DWORD PTR tv173[ebp]
  002b4	89 45 b8	 mov	 DWORD PTR _iSegEnd$[ebp], eax

; 1844 :         if ( i < iSegEnd )

  002b7	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  002ba	3b 4d b8	 cmp	 ecx, DWORD PTR _iSegEnd$[ebp]
  002bd	0f 8d 3e 01 00
	00		 jge	 $L3023

; 1845 :         {
; 1846 :             fTrigUpdated = 1;

  002c3	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _fTrigUpdated$[ebp], 1

; 1847 :             for (; i < iSegEnd; i++,(*pcSampleGet)++)    {

  002ca	eb 19		 jmp	 SHORT $L3025
$L3026:
  002cc	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  002cf	83 c2 01	 add	 edx, 1
  002d2	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
  002d5	8b 45 14	 mov	 eax, DWORD PTR _pcSampleGet$[ebp]
  002d8	66 8b 08	 mov	 cx, WORD PTR [eax]
  002db	66 83 c1 01	 add	 cx, 1
  002df	8b 55 14	 mov	 edx, DWORD PTR _pcSampleGet$[ebp]
  002e2	66 89 0a	 mov	 WORD PTR [edx], cx
$L3025:
  002e5	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  002e8	3b 45 b8	 cmp	 eax, DWORD PTR _iSegEnd$[ebp]
  002eb	0f 8d 10 01 00
	00		 jge	 $L3023

; 1848 : 
; 1849 :                 COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData,
; 1850 :                     uiSignbitCount);

  002f1	83 7d d0 00	 cmp	 DWORD PTR _uiSignbitCount$[ebp], 0
  002f5	75 19		 jne	 SHORT $L3028
  002f7	8b 4d a8	 mov	 ecx, DWORD PTR _piSrcSign$[ebp]
  002fa	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  002fd	89 55 e8	 mov	 DWORD PTR _uiSignbitData$[ebp], edx
  00300	8b 45 a8	 mov	 eax, DWORD PTR _piSrcSign$[ebp]
  00303	83 c0 02	 add	 eax, 2
  00306	89 45 a8	 mov	 DWORD PTR _piSrcSign$[ebp], eax
  00309	c7 45 d0 10 00
	00 00		 mov	 DWORD PTR _uiSignbitCount$[ebp], 16 ; 00000010H
$L3028:
  00310	8b 4d e8	 mov	 ecx, DWORD PTR _uiSignbitData$[ebp]
  00313	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  00319	85 c9		 test	 ecx, ecx
  0031b	74 09		 je	 SHORT $L3029
  0031d	c7 45 d4 00 00
	ff ff		 mov	 DWORD PTR _iResult$[ebp], -65536 ; ffff0000H
  00324	eb 07		 jmp	 SHORT $L3030
$L3029:
  00326	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _iResult$[ebp], 0
$L3030:
  0032d	8b 55 f8	 mov	 edx, DWORD PTR _piSrc$[ebp]
  00330	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00333	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00338	8b 4d d4	 mov	 ecx, DWORD PTR _iResult$[ebp]
  0033b	0b c8		 or	 ecx, eax
  0033d	89 4d d4	 mov	 DWORD PTR _iResult$[ebp], ecx
  00340	8b 55 e8	 mov	 edx, DWORD PTR _uiSignbitData$[ebp]
  00343	d1 e2		 shl	 edx, 1
  00345	89 55 e8	 mov	 DWORD PTR _uiSignbitData$[ebp], edx
  00348	8b 45 d0	 mov	 eax, DWORD PTR _uiSignbitCount$[ebp]
  0034b	83 e8 01	 sub	 eax, 1
  0034e	89 45 d0	 mov	 DWORD PTR _uiSignbitCount$[ebp], eax

; 1851 : 
; 1852 :                 cfResult = INT_FROM_COEF( MULT_BP2(bp2Sin,*--piCoef) + COEF_FROM_INT(iResult) );

  00351	8b 4d b4	 mov	 ecx, DWORD PTR _piCoef$[ebp]
  00354	83 e9 04	 sub	 ecx, 4
  00357	89 4d b4	 mov	 DWORD PTR _piCoef$[ebp], ecx
  0035a	8b 55 b4	 mov	 edx, DWORD PTR _piCoef$[ebp]
  0035d	d9 02		 fld	 DWORD PTR [edx]
  0035f	d8 4d e4	 fmul	 DWORD PTR _bp2Sin$[ebp]
  00362	da 45 d4	 fiadd	 DWORD PTR _iResult$[ebp]
  00365	d9 5d d8	 fstp	 DWORD PTR _cfResult$[ebp]

; 1853 :                 ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );

  00368	8b 45 d8	 mov	 eax, DWORD PTR _cfResult$[ebp]
  0036b	50		 push	 eax
  0036c	e8 00 00 00 00	 call	 @ROUNDF@4
  00371	89 45 d4	 mov	 DWORD PTR _iResult$[ebp], eax
  00374	81 7d d4 00 80
	ff ff		 cmp	 DWORD PTR _iResult$[ebp], -32768 ; ffff8000H
  0037b	7d 09		 jge	 SHORT $L3420
  0037d	c7 45 84 00 80
	ff ff		 mov	 DWORD PTR tv232[ebp], -32768 ; ffff8000H
  00384	eb 1e		 jmp	 SHORT $L3421
$L3420:
  00386	81 7d d4 ff 7f
	00 00		 cmp	 DWORD PTR _iResult$[ebp], 32767 ; 00007fffH
  0038d	7e 09		 jle	 SHORT $L3418
  0038f	c7 45 80 ff 7f
	00 00		 mov	 DWORD PTR tv231[ebp], 32767 ; 00007fffH
  00396	eb 06		 jmp	 SHORT $L3419
$L3418:
  00398	8b 4d d4	 mov	 ecx, DWORD PTR _iResult$[ebp]
  0039b	89 4d 80	 mov	 DWORD PTR tv231[ebp], ecx
$L3419:
  0039e	8b 55 80	 mov	 edx, DWORD PTR tv231[ebp]
  003a1	89 55 84	 mov	 DWORD PTR tv232[ebp], edx
$L3421:
  003a4	8b 45 84	 mov	 eax, DWORD PTR tv232[ebp]
  003a7	89 45 d4	 mov	 DWORD PTR _iResult$[ebp], eax
  003aa	8b 4d c8	 mov	 ecx, DWORD PTR _piDst$[ebp]
  003ad	66 8b 55 d4	 mov	 dx, WORD PTR _iResult$[ebp]
  003b1	66 89 11	 mov	 WORD PTR [ecx], dx

; 1854 : 
; 1855 :                 DEBUG_IT_SAMPLE_BREAK(i, iResult, bp2Sin);
; 1856 : 
; 1857 :                 piSrc += cChan;

  003b4	8b 45 c0	 mov	 eax, DWORD PTR _cChan$[ebp]
  003b7	8b 4d f8	 mov	 ecx, DWORD PTR _piSrc$[ebp]
  003ba	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  003bd	89 55 f8	 mov	 DWORD PTR _piSrc$[ebp], edx

; 1858 :                 piDst += cChan;

  003c0	8b 45 c0	 mov	 eax, DWORD PTR _cChan$[ebp]
  003c3	8b 4d c8	 mov	 ecx, DWORD PTR _piDst$[ebp]
  003c6	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  003c9	89 55 c8	 mov	 DWORD PTR _piDst$[ebp], edx

; 1859 : 
; 1860 :                 bp2SinT = bp2Sin1 + MULT_BP2(bp2Step,bp2Cos);

  003cc	d9 45 cc	 fld	 DWORD PTR _bp2Step$[ebp]
  003cf	d8 4d f0	 fmul	 DWORD PTR _bp2Cos$[ebp]
  003d2	d8 45 ac	 fadd	 DWORD PTR _bp2Sin1$[ebp]
  003d5	d9 5d ec	 fstp	 DWORD PTR _bp2SinT$[ebp]

; 1861 :                 bp2CosT = bp2Cos1 - MULT_BP2(bp2Step,bp2Sin);

  003d8	d9 45 cc	 fld	 DWORD PTR _bp2Step$[ebp]
  003db	d8 4d e4	 fmul	 DWORD PTR _bp2Sin$[ebp]
  003de	d8 6d fc	 fsubr	 DWORD PTR _bp2Cos1$[ebp]
  003e1	d9 5d a0	 fstp	 DWORD PTR _bp2CosT$[ebp]

; 1862 :                 bp2Sin1 = bp2Sin;  bp2Sin = bp2SinT;

  003e4	8b 45 e4	 mov	 eax, DWORD PTR _bp2Sin$[ebp]
  003e7	89 45 ac	 mov	 DWORD PTR _bp2Sin1$[ebp], eax
  003ea	8b 4d ec	 mov	 ecx, DWORD PTR _bp2SinT$[ebp]
  003ed	89 4d e4	 mov	 DWORD PTR _bp2Sin$[ebp], ecx

; 1863 :                 bp2Cos1 = bp2Cos;  bp2Cos = bp2CosT;

  003f0	8b 55 f0	 mov	 edx, DWORD PTR _bp2Cos$[ebp]
  003f3	89 55 fc	 mov	 DWORD PTR _bp2Cos1$[ebp], edx
  003f6	8b 45 a0	 mov	 eax, DWORD PTR _bp2CosT$[ebp]
  003f9	89 45 f0	 mov	 DWORD PTR _bp2Cos$[ebp], eax

; 1864 :             }

  003fc	e9 cb fe ff ff	 jmp	 $L3026
$L3023:

; 1865 :         }
; 1866 :     }
; 1867 :     if (i < iCoefRecurQ3) 

  00401	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00404	3b 4d c4	 cmp	 ecx, DWORD PTR _iCoefRecurQ3$[ebp]
  00407	0f 8d cc 00 00
	00		 jge	 $L3033

; 1868 :     {
; 1869 :         iSegEnd = min (iCoefRecurQ3, iEnd);

  0040d	8b 55 c4	 mov	 edx, DWORD PTR _iCoefRecurQ3$[ebp]
  00410	3b 55 bc	 cmp	 edx, DWORD PTR _iEnd$[ebp]
  00413	7d 0b		 jge	 SHORT $L3422
  00415	8b 45 c4	 mov	 eax, DWORD PTR _iCoefRecurQ3$[ebp]
  00418	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv245[ebp], eax
  0041e	eb 09		 jmp	 SHORT $L3423
$L3422:
  00420	8b 4d bc	 mov	 ecx, DWORD PTR _iEnd$[ebp]
  00423	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv245[ebp], ecx
$L3423:
  00429	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv245[ebp]
  0042f	89 55 b8	 mov	 DWORD PTR _iSegEnd$[ebp], edx

; 1870 :         for (; i < iSegEnd; i++,(*pcSampleGet)++)    {

  00432	eb 19		 jmp	 SHORT $L3034
$L3035:
  00434	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00437	83 c0 01	 add	 eax, 1
  0043a	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  0043d	8b 4d 14	 mov	 ecx, DWORD PTR _pcSampleGet$[ebp]
  00440	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00443	66 83 c2 01	 add	 dx, 1
  00447	8b 45 14	 mov	 eax, DWORD PTR _pcSampleGet$[ebp]
  0044a	66 89 10	 mov	 WORD PTR [eax], dx
$L3034:
  0044d	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00450	3b 4d b8	 cmp	 ecx, DWORD PTR _iSegEnd$[ebp]
  00453	0f 8d 80 00 00
	00		 jge	 $L3033

; 1871 :             cfResult = INT_FROM_COEF( *--piCoef );

  00459	8b 55 b4	 mov	 edx, DWORD PTR _piCoef$[ebp]
  0045c	83 ea 04	 sub	 edx, 4
  0045f	89 55 b4	 mov	 DWORD PTR _piCoef$[ebp], edx
  00462	8b 45 b4	 mov	 eax, DWORD PTR _piCoef$[ebp]
  00465	d9 00		 fld	 DWORD PTR [eax]
  00467	d9 5d d8	 fstp	 DWORD PTR _cfResult$[ebp]

; 1872 :             ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );

  0046a	8b 4d d8	 mov	 ecx, DWORD PTR _cfResult$[ebp]
  0046d	51		 push	 ecx
  0046e	e8 00 00 00 00	 call	 @ROUNDF@4
  00473	89 45 d4	 mov	 DWORD PTR _iResult$[ebp], eax
  00476	81 7d d4 00 80
	ff ff		 cmp	 DWORD PTR _iResult$[ebp], -32768 ; ffff8000H
  0047d	7d 0c		 jge	 SHORT $L3426
  0047f	c7 85 78 ff ff
	ff 00 80 ff ff	 mov	 DWORD PTR tv256[ebp], -32768 ; ffff8000H
  00489	eb 2a		 jmp	 SHORT $L3427
$L3426:
  0048b	81 7d d4 ff 7f
	00 00		 cmp	 DWORD PTR _iResult$[ebp], 32767 ; 00007fffH
  00492	7e 0c		 jle	 SHORT $L3424
  00494	c7 85 74 ff ff
	ff ff 7f 00 00	 mov	 DWORD PTR tv255[ebp], 32767 ; 00007fffH
  0049e	eb 09		 jmp	 SHORT $L3425
$L3424:
  004a0	8b 55 d4	 mov	 edx, DWORD PTR _iResult$[ebp]
  004a3	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv255[ebp], edx
$L3425:
  004a9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv255[ebp]
  004af	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv256[ebp], eax
$L3427:
  004b5	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv256[ebp]
  004bb	89 4d d4	 mov	 DWORD PTR _iResult$[ebp], ecx
  004be	8b 55 c8	 mov	 edx, DWORD PTR _piDst$[ebp]
  004c1	66 8b 45 d4	 mov	 ax, WORD PTR _iResult$[ebp]
  004c5	66 89 02	 mov	 WORD PTR [edx], ax

; 1873 :             DEBUG_IT_SAMPLE_BREAK(i, iResult, IT_NO_SIN);
; 1874 :             piDst += cChan;

  004c8	8b 4d c0	 mov	 ecx, DWORD PTR _cChan$[ebp]
  004cb	8b 55 c8	 mov	 edx, DWORD PTR _piDst$[ebp]
  004ce	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  004d1	89 45 c8	 mov	 DWORD PTR _piDst$[ebp], eax

; 1875 :         }

  004d4	e9 5b ff ff ff	 jmp	 $L3035
$L3033:

; 1876 :     }
; 1877 : 
; 1878 :     SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData);

  004d9	83 7d d0 00	 cmp	 DWORD PTR _uiSignbitCount$[ebp], 0
  004dd	74 0b		 je	 SHORT $L3039
  004df	8b 4d a8	 mov	 ecx, DWORD PTR _piSrcSign$[ebp]
  004e2	66 8b 55 e8	 mov	 dx, WORD PTR _uiSignbitData$[ebp]
  004e6	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx
$L3039:

; 1879 :     if ( fTrigUpdated )

  004ea	83 7d b0 00	 cmp	 DWORD PTR _fTrigUpdated$[ebp], 0
  004ee	74 24		 je	 SHORT $L3041

; 1880 :     {
; 1881 :         *(BP2Type*)(&ppcinfo->m_iSin)  = bp2Sin;

  004f0	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  004f3	8b 4d e4	 mov	 ecx, DWORD PTR _bp2Sin$[ebp]
  004f6	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 1882 :         *(BP2Type*)(&ppcinfo->m_iCos)  = bp2Cos;

  004f9	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  004fc	8b 45 f0	 mov	 eax, DWORD PTR _bp2Cos$[ebp]
  004ff	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 1883 :         *(BP2Type*)(&ppcinfo->m_iSin1) = bp2Sin1;

  00502	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00505	8b 55 ac	 mov	 edx, DWORD PTR _bp2Sin1$[ebp]
  00508	89 51 54	 mov	 DWORD PTR [ecx+84], edx

; 1884 :         *(BP2Type*)(&ppcinfo->m_iCos1) = bp2Cos1;

  0050b	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  0050e	8b 4d fc	 mov	 ecx, DWORD PTR _bp2Cos1$[ebp]
  00511	89 48 58	 mov	 DWORD PTR [eax+88], ecx
$L3041:

; 1885 :     }
; 1886 :     ppcinfo->m_rgiCoefReconCurr = (Int*)piCoef;

  00514	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00517	8b 45 b4	 mov	 eax, DWORD PTR _piCoef$[ebp]
  0051a	89 42 3c	 mov	 DWORD PTR [edx+60], eax

; 1887 :     ppcinfo->m_iCurrGetPCM_SubFrame = (I16)i;

  0051d	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00520	66 8b 55 f4	 mov	 dx, WORD PTR _i$[ebp]
  00524	66 89 51 38	 mov	 WORD PTR [ecx+56], dx

; 1888 :     ppcinfo->m_piPrevOutputCurr = piSrc;

  00528	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  0052b	8b 4d f8	 mov	 ecx, DWORD PTR _piSrc$[ebp]
  0052e	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 1889 : #ifdef PROFILE
; 1890 :     FunctionProfileStop(&fp);
; 1891 : #endif
; 1892 :     return WMA_OK;

  00531	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK

; 1893 : }

  00536	8b e5		 mov	 esp, ebp
  00538	5d		 pop	 ebp
  00539	c2 14 00	 ret	 20			; 00000014H
_auReconMono_XDS@20 ENDP
WMADEC	ENDS
PUBLIC	_auAdaptToSubFrameConfig_XDS@4
EXTRN	_prvAdaptTrigToSubframeConfig_XDS@4:NEAR
; Function compile flags: /Odt
;	COMDAT _auAdaptToSubFrameConfig_XDS@4
WMADEC	SEGMENT
tv256 = -32
tv243 = -28
tv87 = -24
_iTotal$ = -20
_iSizeCurr$ = -16
_ppcinfo$ = -12
_wmaResult$ = -8
_i$ = -4
_pau$ = 8
_auAdaptToSubFrameConfig_XDS@4 PROC NEAR		; COMDAT

; 2074 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi

; 2075 :     Int i, iTotal, iSizeCurr;
; 2076 :     PerChannelInfo* ppcinfo;
; 2077 :     WMARESULT   wmaResult = WMA_OK;

  00007	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000c	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 2078 : 
; 2079 : #ifdef PROFILE
; 2080 :     //FunctionProfile fp;
; 2081 :     //FunctionProfileStart(&fp,ADAPT_TO_SUB_FRAME_CONFIG_PROFILE);
; 2082 : #endif
; 2083 : 
; 2084 :     assert (pau->m_subfrmconfigCurr.m_cSubFrame <= 16);
; 2085 :     pau->m_iSizeCurr = iSizeCurr = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00012	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00015	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00018	8b 8c 90 78 01
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+376]
  0001f	89 4d f0	 mov	 DWORD PTR _iSizeCurr$[ebp], ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00025	8b 45 f0	 mov	 eax, DWORD PTR _iSizeCurr$[ebp]
  00028	89 82 84 03 00
	00		 mov	 DWORD PTR [edx+900], eax

; 2086 : 
; 2087 :     if (pau->m_subfrmconfigCurr.m_cSubFrame > 1) {

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00031	83 b9 74 01 00
	00 01		 cmp	 DWORD PTR [ecx+372], 1
  00038	0f 8e 06 01 00
	00		 jle	 $L3056

; 2088 :         pau->m_iIncr = LOG2 ((U32)(pau->m_cFrameSampleHalf / iSizeCurr));

  0003e	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00041	8b 82 1c 03 00
	00		 mov	 eax, DWORD PTR [edx+796]
  00047	99		 cdq
  00048	f7 7d f0	 idiv	 DWORD PTR _iSizeCurr$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _LOG2@4
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00054	89 81 94 00 00
	00		 mov	 DWORD PTR [ecx+148], eax

; 2089 :         if (pau->m_iIncr >= pau->m_cPossibleWinSize)   {

  0005a	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0005d	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00060	8b 8a 94 00 00
	00		 mov	 ecx, DWORD PTR [edx+148]
  00066	3b 88 90 00 00
	00		 cmp	 ecx, DWORD PTR [eax+144]
  0006c	7c 58		 jl	 SHORT $L3058

; 2090 :             assert (WMAB_FALSE);
; 2091 :             wmaResult = TraceResult(WMA_E_BROKEN_FRAME);

  0006e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  00074	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  0007a	74 37		 je	 SHORT $L3431
  0007c	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  00081	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00087	74 2a		 je	 SHORT $L3431
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_BROKEN_FRAME
  0008f	51		 push	 ecx
  00090	68 2b 08 00 00	 push	 2091			; 0000082bH
  00095	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  0009a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0009f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_BROKEN_FRAME
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 _MyOutputDbgStr
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	89 45 e8	 mov	 DWORD PTR tv87[ebp], eax
  000b1	eb 08		 jmp	 SHORT $L3432
$L3431:
  000b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  000b8	89 45 e8	 mov	 DWORD PTR tv87[ebp], eax
$L3432:
  000bb	8b 4d e8	 mov	 ecx, DWORD PTR tv87[ebp]
  000be	89 4d f8	 mov	 DWORD PTR _wmaResult$[ebp], ecx

; 2092 :             goto exit;

  000c1	e9 17 04 00 00	 jmp	 $exit$3059
$L3058:

; 2093 :         }
; 2094 :         i = 0;

  000c6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 2095 :         iTotal = 0;

  000cd	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iTotal$[ebp], 0
$L3061:

; 2096 :         while (i < pau->m_iIncr) {iTotal += (pau->m_cFrameSampleQuad >> i); i++;}

  000d4	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000d7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000da	3b 82 94 00 00
	00		 cmp	 eax, DWORD PTR [edx+148]
  000e0	7d 21		 jge	 SHORT $L3062
  000e2	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000e5	8b 91 20 03 00
	00		 mov	 edx, DWORD PTR [ecx+800]
  000eb	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000ee	d3 fa		 sar	 edx, cl
  000f0	8b 45 ec	 mov	 eax, DWORD PTR _iTotal$[ebp]
  000f3	03 c2		 add	 eax, edx
  000f5	89 45 ec	 mov	 DWORD PTR _iTotal$[ebp], eax
  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000fb	83 c1 01	 add	 ecx, 1
  000fe	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00101	eb d1		 jmp	 SHORT $L3061
$L3062:

; 2097 : 
; 2098 :         pau->m_cValidBarkBand = pau->m_rgcValidBarkBand [pau->m_iIncr];

  00103	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00106	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [edx+148]
  0010c	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0010f	8b 91 ac 03 00
	00		 mov	 edx, DWORD PTR [ecx+940]
  00115	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00118	8b 14 82	 mov	 edx, DWORD PTR [edx+eax*4]
  0011b	89 91 50 03 00
	00		 mov	 DWORD PTR [ecx+848], edx

; 2099 :         pau->m_rgiBarkIndex   = pau->m_rgiBarkIndexOrig + pau->m_iIncr * (NUM_BARK_BAND + 1);

  00121	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00124	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  0012a	6b c9 1a	 imul	 ecx, 26			; 0000001aH
  0012d	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00130	8b 82 b0 03 00
	00		 mov	 eax, DWORD PTR [edx+944]
  00136	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00139	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0013c	89 8a 54 03 00
	00		 mov	 DWORD PTR [edx+852], ecx

; 2100 :     }
; 2101 :     else {

  00142	eb 33		 jmp	 SHORT $L3063
$L3056:

; 2102 :         pau->m_iIncr = 0;

  00144	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00147	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+148], 0

; 2103 :         pau->m_cValidBarkBand       = pau->m_rgcValidBarkBand [0];

  00151	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00154	8b 91 ac 03 00
	00		 mov	 edx, DWORD PTR [ecx+940]
  0015a	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0015d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0015f	89 88 50 03 00
	00		 mov	 DWORD PTR [eax+848], ecx

; 2104 :         pau->m_rgiBarkIndex         = pau->m_rgiBarkIndexOrig;

  00165	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00168	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0016b	8b 88 b0 03 00
	00		 mov	 ecx, DWORD PTR [eax+944]
  00171	89 8a 54 03 00
	00		 mov	 DWORD PTR [edx+852], ecx
$L3063:

; 2105 :     }
; 2106 :     pau->m_cLowCutOff  = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame]
; 2107 :                     * pau->m_cLowCutOffLong / pau->m_cFrameSampleHalf;    //proportional

  00177	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0017a	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0017d	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00180	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00183	8b 84 81 78 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+376]
  0018a	0f af 82 2c 03
	00 00		 imul	 eax, DWORD PTR [edx+812]
  00191	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00194	99		 cdq
  00195	f7 b9 1c 03 00
	00		 idiv	 DWORD PTR [ecx+796]
  0019b	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0019e	89 82 24 03 00
	00		 mov	 DWORD PTR [edx+804], eax

; 2108 :     pau->m_cHighCutOff = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame]
; 2109 :                     * pau->m_cHighCutOffLong / pau->m_cFrameSampleHalf;    //proportional

  001a4	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001a7	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  001aa	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  001ad	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001b0	8b 8c 8a 78 01
	00 00		 mov	 ecx, DWORD PTR [edx+ecx*4+376]
  001b7	0f af 88 30 03
	00 00		 imul	 ecx, DWORD PTR [eax+816]
  001be	8b 75 08	 mov	 esi, DWORD PTR _pau$[ebp]
  001c1	8b c1		 mov	 eax, ecx
  001c3	99		 cdq
  001c4	f7 be 1c 03 00
	00		 idiv	 DWORD PTR [esi+796]
  001ca	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  001cd	89 82 28 03 00
	00		 mov	 DWORD PTR [edx+808], eax

; 2110 : 
; 2111 :     pau->m_cSubFrameSampleHalf   = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];

  001d3	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001d6	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  001d9	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  001dc	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001df	8b 8c 88 78 01
	00 00		 mov	 ecx, DWORD PTR [eax+ecx*4+376]
  001e6	89 8a 9c 00 00
	00		 mov	 DWORD PTR [edx+156], ecx

; 2112 :     pau->m_cSubFrameSample       = pau->m_cSubFrameSampleHalf * 2;

  001ec	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  001ef	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  001f5	d1 e0		 shl	 eax, 1
  001f7	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  001fa	89 81 98 00 00
	00		 mov	 DWORD PTR [ecx+152], eax

; 2113 :     pau->m_cSubFrameSampleQuad   = pau->m_cSubFrameSampleHalf / 2; 

  00200	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00203	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  00209	99		 cdq
  0020a	2b c2		 sub	 eax, edx
  0020c	d1 f8		 sar	 eax, 1
  0020e	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00211	89 81 a0 00 00
	00		 mov	 DWORD PTR [ecx+160], eax

; 2114 :     pau->m_cSubband              = pau->m_cSubFrameSampleHalf;    //50% frame overlapping

  00217	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0021a	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0021d	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  00223	89 4a 60	 mov	 DWORD PTR [edx+96], ecx

; 2115 : 
; 2116 :     //init; could be modified by noise sub
; 2117 :     ppcinfo = pau->m_rgpcinfo;

  00226	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00229	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  0022f	89 45 f4	 mov	 DWORD PTR _ppcinfo$[ebp], eax

; 2118 :     ppcinfo->m_cSubbandActual = pau->m_cHighCutOff - pau->m_cLowCutOff;

  00232	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00235	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00238	8b 81 28 03 00
	00		 mov	 eax, DWORD PTR [ecx+808]
  0023e	2b 82 24 03 00
	00		 sub	 eax, DWORD PTR [edx+804]
  00244	8b 4d f4	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00247	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 2119 : #ifndef ENCODER
; 2120 :     ppcinfo->m_rgiCoefRecon   = pau->m_rgiCoefReconOrig 
; 2121 :                               + DOUBLE(pau->m_fPad2XTransform,
; 2122 :                                     pau->m_cFrameSampleHalf - pau->m_cSubFrameSampleHalf);

  0024a	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0024d	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00250	8b 8a 1c 03 00
	00		 mov	 ecx, DWORD PTR [edx+796]
  00256	2b 88 9c 00 00
	00		 sub	 ecx, DWORD PTR [eax+156]
  0025c	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0025f	8b 82 a4 03 00
	00		 mov	 eax, DWORD PTR [edx+932]
  00265	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00268	8b 55 f4	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  0026b	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 2123 :     ppcinfo->m_rgfltCoefRecon = (Float *)(ppcinfo->m_rgiCoefRecon); 

  0026e	8b 45 f4	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00271	8b 4d f4	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00274	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00277	89 50 60	 mov	 DWORD PTR [eax+96], edx

; 2124 : #endif // ENCODER
; 2125 :     if (pau->m_cChannel == 2)   {

  0027a	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0027d	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  00281	83 f9 02	 cmp	 ecx, 2
  00284	75 53		 jne	 SHORT $L3065

; 2126 :         ppcinfo = pau->m_rgpcinfo + 1;

  00286	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00289	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  0028f	83 c0 70	 add	 eax, 112		; 00000070H
  00292	89 45 f4	 mov	 DWORD PTR _ppcinfo$[ebp], eax

; 2127 :         ppcinfo->m_cSubbandActual = pau->m_rgpcinfo [0].m_cSubbandActual;

  00295	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00298	8b 91 a0 03 00
	00		 mov	 edx, DWORD PTR [ecx+928]
  0029e	8b 45 f4	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  002a1	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  002a4	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 2128 : #ifndef ENCODER
; 2129 :         ppcinfo->m_rgiCoefRecon   = pau->m_rgiCoefReconOrig 
; 2130 :                                   + DOUBLE(pau->m_fPad2XTransform,
; 2131 :                                         2 * pau->m_cFrameSampleHalf - pau->m_cSubFrameSampleHalf);

  002a7	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  002aa	8b 82 1c 03 00
	00		 mov	 eax, DWORD PTR [edx+796]
  002b0	d1 e0		 shl	 eax, 1
  002b2	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002b5	2b 81 9c 00 00
	00		 sub	 eax, DWORD PTR [ecx+156]
  002bb	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  002be	8b 8a a4 03 00
	00		 mov	 ecx, DWORD PTR [edx+932]
  002c4	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  002c7	8b 45 f4	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  002ca	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 2132 :         ppcinfo->m_rgfltCoefRecon = (Float *)(ppcinfo->m_rgiCoefRecon); 

  002cd	8b 4d f4	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  002d0	8b 55 f4	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  002d3	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  002d6	89 41 60	 mov	 DWORD PTR [ecx+96], eax
$L3065:

; 2133 : #endif // ENCODER
; 2134 :     }
; 2135 : 
; 2136 : 
; 2137 : #ifdef ENABLE_ALL_ENCOPT
; 2138 :     //update first noise index
; 2139 :     if (pau->m_fNoiseSub == WMAB_TRUE)    {

  002d9	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002dc	83 79 30 01	 cmp	 DWORD PTR [ecx+48], 1
  002e0	75 70		 jne	 SHORT $L3067

; 2140 :         pau->m_iFirstNoiseIndex = (Int) ftoi(0.5F + pau->m_fltFirstNoiseFreq * pau->m_cSubFrameSample 
; 2141 :             / ((Float) pau->m_iSamplingRate));  //open end

  002e2	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  002e5	db 82 98 00 00
	00		 fild	 DWORD PTR [edx+152]
  002eb	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002ee	d8 88 bc 03 00
	00		 fmul	 DWORD PTR [eax+956]
  002f4	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002f7	db 41 54	 fild	 DWORD PTR [ecx+84]
  002fa	de f9		 fdivp	 ST(1), ST(0)
  002fc	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f000000
  00302	51		 push	 ecx
  00303	d9 1c 24	 fstp	 DWORD PTR [esp]
  00306	e8 00 00 00 00	 call	 _FloatToLong@4
  0030b	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0030e	89 82 c4 03 00
	00		 mov	 DWORD PTR [edx+964], eax

; 2142 :         if (pau->m_iFirstNoiseIndex > pau->m_cSubband) 

  00314	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00317	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0031a	8b 90 c4 03 00
	00		 mov	 edx, DWORD PTR [eax+964]
  00320	3b 51 60	 cmp	 edx, DWORD PTR [ecx+96]
  00323	7e 0f		 jle	 SHORT $L3071

; 2143 :             pau->m_iFirstNoiseIndex = pau->m_cSubband;

  00325	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00328	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0032b	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0032e	89 90 c4 03 00
	00		 mov	 DWORD PTR [eax+964], edx
$L3071:

; 2144 : 
; 2145 :         // use precalculated values
; 2146 :         pau->m_iFirstNoiseBand = pau->m_rgiFirstNoiseBand[pau->m_iIncr];

  00334	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00337	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  0033d	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00340	8b 82 cc 03 00
	00		 mov	 eax, DWORD PTR [edx+972]
  00346	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00349	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0034c	89 82 c0 03 00
	00		 mov	 DWORD PTR [edx+960], eax
$L3067:

; 2147 :     }
; 2148 : #endif //ENABLE_ALL_ENCOPT
; 2149 : 
; 2150 :     //to decide the current window shape; look at sizes on the left and right
; 2151 : 
; 2152 :     pau->m_iSizePrev = (pau->m_iCurrSubFrame > 0) ? 
; 2153 :                         pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame - 1] :
; 2154 :                         pau->m_subfrmconfigPrev.m_rgiSubFrameSize [pau->m_subfrmconfigPrev.m_cSubFrame - 1];

  00352	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00355	83 79 70 00	 cmp	 DWORD PTR [ecx+112], 0
  00359	7e 15		 jle	 SHORT $L3433
  0035b	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0035e	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00361	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00364	8b 94 81 74 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+372]
  0036b	89 55 e4	 mov	 DWORD PTR tv243[ebp], edx
  0036e	eb 16		 jmp	 SHORT $L3434
$L3433:
  00370	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00373	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00379	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0037c	8b 84 8a a4 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+164]
  00383	89 45 e4	 mov	 DWORD PTR tv243[ebp], eax
$L3434:
  00386	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00389	8b 55 e4	 mov	 edx, DWORD PTR tv243[ebp]
  0038c	89 91 80 03 00
	00		 mov	 DWORD PTR [ecx+896], edx

; 2155 : 
; 2156 :     pau->m_iSizeNext = (pau->m_iCurrSubFrame < pau->m_subfrmconfigCurr.m_cSubFrame - 1) ? 
; 2157 :                         pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame + 1] :
; 2158 :                         pau->m_subfrmconfigNext.m_rgiSubFrameSize [0];

  00392	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00395	8b 88 74 01 00
	00		 mov	 ecx, DWORD PTR [eax+372]
  0039b	83 e9 01	 sub	 ecx, 1
  0039e	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003a1	39 4a 70	 cmp	 DWORD PTR [edx+112], ecx
  003a4	7d 15		 jge	 SHORT $L3435
  003a6	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  003a9	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  003ac	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003af	8b 84 8a 7c 01
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+380]
  003b6	89 45 e0	 mov	 DWORD PTR tv256[ebp], eax
  003b9	eb 0c		 jmp	 SHORT $L3436
$L3435:
  003bb	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  003be	8b 91 48 02 00
	00		 mov	 edx, DWORD PTR [ecx+584]
  003c4	89 55 e0	 mov	 DWORD PTR tv256[ebp], edx
$L3436:
  003c7	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  003ca	8b 4d e0	 mov	 ecx, DWORD PTR tv256[ebp]
  003cd	89 88 88 03 00
	00		 mov	 DWORD PTR [eax+904], ecx

; 2159 : 
; 2160 : 
; 2161 : #if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
; 2162 :     prvSetAdjustedValues(pau, WMAB_FALSE);
; 2163 : #endif
; 2164 : 
; 2165 :     //if the adjacent size is bigger; just keep your own shape
; 2166 :     //otherwise a transition window is needed.
; 2167 :     if (pau->m_iSizePrev >= pau->m_iSizeCurr) {

  003d3	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003d6	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  003d9	8b 8a 80 03 00
	00		 mov	 ecx, DWORD PTR [edx+896]
  003df	3b 88 84 03 00
	00		 cmp	 ecx, DWORD PTR [eax+900]
  003e5	7c 21		 jl	 SHORT $L3072

; 2168 :         //just forward copy curr
; 2169 :         pau->m_iCoefRecurQ1 = 0;

  003e7	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003ea	c7 82 8c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+908], 0

; 2170 :         pau->m_iCoefRecurQ2 = pau->m_iSizeCurr;

  003f4	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  003f7	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  003fa	8b 91 84 03 00
	00		 mov	 edx, DWORD PTR [ecx+900]
  00400	89 90 90 03 00
	00		 mov	 DWORD PTR [eax+912], edx

; 2171 :     }
; 2172 :     else  {

  00406	eb 40		 jmp	 SHORT $L3073
$L3072:

; 2173 :         //long start
; 2174 :         pau->m_iCoefRecurQ1 = (pau->m_iSizeCurr - pau->m_iSizePrev) / 2;

  00408	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0040b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0040e	8b 80 84 03 00
	00		 mov	 eax, DWORD PTR [eax+900]
  00414	2b 81 80 03 00
	00		 sub	 eax, DWORD PTR [ecx+896]
  0041a	99		 cdq
  0041b	2b c2		 sub	 eax, edx
  0041d	d1 f8		 sar	 eax, 1
  0041f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00422	89 82 8c 03 00
	00		 mov	 DWORD PTR [edx+908], eax

; 2175 :         pau->m_iCoefRecurQ2 = (pau->m_iSizeCurr + pau->m_iSizePrev) / 2;

  00428	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0042b	8b 80 84 03 00
	00		 mov	 eax, DWORD PTR [eax+900]
  00431	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00434	03 81 80 03 00
	00		 add	 eax, DWORD PTR [ecx+896]
  0043a	99		 cdq
  0043b	2b c2		 sub	 eax, edx
  0043d	d1 f8		 sar	 eax, 1
  0043f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00442	89 82 90 03 00
	00		 mov	 DWORD PTR [edx+912], eax
$L3073:

; 2176 :     }
; 2177 : 
; 2178 :     if (pau->m_iSizeNext >= pau->m_iSizeCurr) {

  00448	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0044b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0044e	8b 90 88 03 00
	00		 mov	 edx, DWORD PTR [eax+904]
  00454	3b 91 84 03 00
	00		 cmp	 edx, DWORD PTR [ecx+900]
  0045a	7c 26		 jl	 SHORT $L3074

; 2179 :         pau->m_iCoefRecurQ3 = pau->m_cSubFrameSampleHalfAdjusted;

  0045c	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0045f	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00462	8b 91 9c 00 00
	00		 mov	 edx, DWORD PTR [ecx+156]
  00468	89 90 94 03 00
	00		 mov	 DWORD PTR [eax+916], edx

; 2180 :         pau->m_iCoefRecurQ4 = pau->m_cSubFrameSampleAdjusted;

  0046e	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00471	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00474	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  0047a	89 90 98 03 00
	00		 mov	 DWORD PTR [eax+920], edx

; 2181 :     }
; 2182 :     else    {

  00480	eb 52		 jmp	 SHORT $L3075
$L3074:

; 2183 :         //just backward copy curr
; 2184 :         pau->m_iCoefRecurQ3 = pau->m_cSubFrameSampleHalfAdjusted + (pau->m_iSizeCurr - pau->m_iSizeNext) / 2;

  00482	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00485	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00488	8b 80 84 03 00
	00		 mov	 eax, DWORD PTR [eax+900]
  0048e	2b 81 88 03 00
	00		 sub	 eax, DWORD PTR [ecx+904]
  00494	99		 cdq
  00495	2b c2		 sub	 eax, edx
  00497	d1 f8		 sar	 eax, 1
  00499	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0049c	03 82 9c 00 00
	00		 add	 eax, DWORD PTR [edx+156]
  004a2	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  004a5	89 81 94 03 00
	00		 mov	 DWORD PTR [ecx+916], eax

; 2185 :         pau->m_iCoefRecurQ4 = pau->m_cSubFrameSampleHalfAdjusted + (pau->m_iSizeCurr + pau->m_iSizeNext) / 2;

  004ab	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  004ae	8b 82 84 03 00
	00		 mov	 eax, DWORD PTR [edx+900]
  004b4	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  004b7	03 81 88 03 00
	00		 add	 eax, DWORD PTR [ecx+904]
  004bd	99		 cdq
  004be	2b c2		 sub	 eax, edx
  004c0	d1 f8		 sar	 eax, 1
  004c2	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  004c5	03 82 9c 00 00
	00		 add	 eax, DWORD PTR [edx+156]
  004cb	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  004ce	89 81 98 03 00
	00		 mov	 DWORD PTR [ecx+920], eax
$L3075:

; 2186 :     }
; 2187 : 
; 2188 :     prvAdaptTrigToSubframeConfig(pau);

  004d4	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  004d7	52		 push	 edx
  004d8	e8 00 00 00 00	 call	 _prvAdaptTrigToSubframeConfig_XDS@4
$exit$3059:

; 2189 : 
; 2190 : exit:
; 2191 : #ifdef PROFILE
; 2192 :     //FunctionProfileStop(&fp);
; 2193 : #endif
; 2194 :     return wmaResult;

  004dd	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 2195 : }

  004e0	5e		 pop	 esi
  004e1	8b e5		 mov	 esp, ebp
  004e3	5d		 pop	 ebp
  004e4	c2 04 00	 ret	 4
_auAdaptToSubFrameConfig_XDS@4 ENDP
WMADEC	ENDS
PUBLIC	_auUpdateMaxEsc_XDS@8
; Function compile flags: /Odt
;	COMDAT _auUpdateMaxEsc_XDS@8
WMADEC	SEGMENT
_pau$ = 8
_iQuantStepSize$ = 12
_auUpdateMaxEsc_XDS@8 PROC NEAR				; COMDAT

; 2338 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2339 :     // HongCho: Adjust the max Tunstall level according to the quantization step...
; 2340 :     //          Matching if's in the decoder...
; 2341 :     //          Too many?  Maybe...
; 2342 :     // HongCho: Note...  For 22.05kHz, even with all 15bits, the bells don't ring...
; 2343 :     if(iQuantStepSize < 5)       pau->m_iMaxEscSize = 13;

  00003	83 7d 0c 05	 cmp	 DWORD PTR _iQuantStepSize$[ebp], 5
  00007	7d 0c		 jge	 SHORT $L3081
  00009	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0000c	c7 40 3c 0d 00
	00 00		 mov	 DWORD PTR [eax+60], 13	; 0000000dH

; 2344 :     else if(iQuantStepSize < 15) pau->m_iMaxEscSize = 13;

  00013	eb 64		 jmp	 SHORT $L3082
$L3081:
  00015	83 7d 0c 0f	 cmp	 DWORD PTR _iQuantStepSize$[ebp], 15 ; 0000000fH
  00019	7d 0c		 jge	 SHORT $L3083
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0001e	c7 41 3c 0d 00
	00 00		 mov	 DWORD PTR [ecx+60], 13	; 0000000dH

; 2345 :     else if(iQuantStepSize < 32) pau->m_iMaxEscSize = 12;

  00025	eb 52		 jmp	 SHORT $L3082
$L3083:
  00027	83 7d 0c 20	 cmp	 DWORD PTR _iQuantStepSize$[ebp], 32 ; 00000020H
  0002b	7d 0c		 jge	 SHORT $L3085
  0002d	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00030	c7 42 3c 0c 00
	00 00		 mov	 DWORD PTR [edx+60], 12	; 0000000cH

; 2346 :     else if(iQuantStepSize < 40) pau->m_iMaxEscSize = 11;

  00037	eb 40		 jmp	 SHORT $L3082
$L3085:
  00039	83 7d 0c 28	 cmp	 DWORD PTR _iQuantStepSize$[ebp], 40 ; 00000028H
  0003d	7d 0c		 jge	 SHORT $L3087
  0003f	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00042	c7 40 3c 0b 00
	00 00		 mov	 DWORD PTR [eax+60], 11	; 0000000bH

; 2347 :     else if(iQuantStepSize < 45) pau->m_iMaxEscSize = 10;

  00049	eb 2e		 jmp	 SHORT $L3082
$L3087:
  0004b	83 7d 0c 2d	 cmp	 DWORD PTR _iQuantStepSize$[ebp], 45 ; 0000002dH
  0004f	7d 0c		 jge	 SHORT $L3089
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00054	c7 41 3c 0a 00
	00 00		 mov	 DWORD PTR [ecx+60], 10	; 0000000aH

; 2348 :     else if(iQuantStepSize < 55) pau->m_iMaxEscSize =  9;

  0005b	eb 1c		 jmp	 SHORT $L3082
$L3089:
  0005d	83 7d 0c 37	 cmp	 DWORD PTR _iQuantStepSize$[ebp], 55 ; 00000037H
  00061	7d 0c		 jge	 SHORT $L3091
  00063	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00066	c7 42 3c 09 00
	00 00		 mov	 DWORD PTR [edx+60], 9

; 2349 :     else                         pau->m_iMaxEscSize =  9;

  0006d	eb 0a		 jmp	 SHORT $L3082
$L3091:
  0006f	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00072	c7 40 3c 09 00
	00 00		 mov	 DWORD PTR [eax+60], 9
$L3082:

; 2350 :     pau->m_iMaxEscLevel = (1<<pau->m_iMaxEscSize) - 1;

  00079	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0007c	ba 01 00 00 00	 mov	 edx, 1
  00081	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  00084	d3 e2		 shl	 edx, cl
  00086	83 ea 01	 sub	 edx, 1
  00089	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0008c	89 50 40	 mov	 DWORD PTR [eax+64], edx

; 2351 : }

  0008f	5d		 pop	 ebp
  00090	c2 08 00	 ret	 8
_auUpdateMaxEsc_XDS@8 ENDP
WMADEC	ENDS
PUBLIC	_qstCalcQuantStep_XDS@4
PUBLIC	__real@41a00000
EXTRN	_pow:NEAR
EXTRN	_rgDBPower10:BYTE
EXTRN	_rgfltDBPowerExponentScale:BYTE
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _qstCalcQuantStep_XDS@4
WMADEC	SEGMENT
tv134 = -12
tv129 = -8
_qstQuantStep$ = -4
_iQSS$ = 8
_qstCalcQuantStep_XDS@4 PROC NEAR			; COMDAT

; 2584 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2585 :     QuantStepType qstQuantStep;
; 2586 : 
; 2587 : #if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
; 2588 :     if ( iQSS < DBPOWER_TABLE_OFFSET )
; 2589 :     {   // This happens when iPower==0, not an important case, but return 10^(1/20) with 28 FractBits
; 2590 :         // It can also happen with a small NoisePower (-13 has been seen)
; 2591 :         if ( iQSS < 0 )
; 2592 :         {   // negative values of iQSS are being generated in the V5 encoder (LowRate in particular)
; 2593 :             qstQuantStep.iFraction = (I32)(0.382943866392*(1<<QUANTSTEP_FRACT_BITS)),      // Average Fraction
; 2594 :             qstQuantStep.iFracBits = QUANTSTEP_FRACT_BITS - ((-iQSS>>3)+1);                // Approximate Exponent
; 2595 :         }
; 2596 :         else
; 2597 :         {
; 2598 :             qstQuantStep.iFraction = (I32)(0.869439785679*(1<<QUANTSTEP_FRACT_BITS));     // Average Fraction
; 2599 :             qstQuantStep.iFracBits = QUANTSTEP_FRACT_BITS - ((iQSS>>3)+1);                // Approximate Exponent
; 2600 :         }
; 2601 :     }
; 2602 :     else if ( iQSS < (DBPOWER_TABLE_OFFSET+DBPOWER_TABLE_SIZE) )
; 2603 :     {   
; 2604 :         // *** normal case ***
; 2605 :         qstQuantStep.iFraction = rgDBPower10[ iQSS - DBPOWER_TABLE_OFFSET ];
; 2606 :         qstQuantStep.iFracBits = QUANTSTEP_FRACT_BITS - ((iQSS>>3)+4);    // implied FractBit scale for rgiDBPower table
; 2607 :         NormUInt( (UInt*)(&qstQuantStep.iFraction), &qstQuantStep.iFracBits, 0x3FFFFFFF );
; 2608 :     }
; 2609 :     else
; 2610 :     {   // This branch can handle out-of-range cases. 
; 2611 :         // rare - but used in some cases by encoder - e.g. Tough_16m_16, Tough_22m_22(?).
; 2612 :         const double    c_dblTenExpToTwo = 3.3219280948873623478703194294894; // ln(10)/ln(2);
; 2613 :         const double    c_dblPointNineNine = (1.0 - DBL_EPSILON);
; 2614 :         double  dblQuantStep,  dblExponent;
; 2615 :         Int     iNumWholeBits,  iNumFractBits;
; 2616 :         dblExponent = (double)(iQSS/(Float)QUANTSTEP_DENOMINATOR);
; 2617 :         dblQuantStep = pow (10, dblExponent);
; 2618 :         iNumWholeBits = (Int)(dblExponent * c_dblTenExpToTwo + c_dblPointNineNine); // Round UP
; 2619 :         iNumWholeBits = max(iNumWholeBits, 5);
; 2620 :         iNumFractBits = max(31 - iNumWholeBits, TRANSFORM_FRACT_BITS);
; 2621 :         if (dblQuantStep * (1 << iNumFractBits) <= UINT_MAX)
; 2622 :             qstQuantStep.iFraction = (I32)(dblQuantStep * (1 << iNumFractBits));
; 2623 :         else
; 2624 :             qstQuantStep.iFraction = UINT_MAX;      // iQSS of 218 seen in encoding Tough 16kHz Stereo 16kbps
; 2625 :         qstQuantStep.iFracBits = iNumFractBits;
; 2626 :         NormUInt( (UInt*)(&qstQuantStep.iFraction), &qstQuantStep.iFracBits, 0x3FFFFFFF );
; 2627 :     }
; 2628 :     MONITOR_RANGE( gMR_qstQuantStep, (qstQuantStep.iFraction)/(Double)(1 << qstQuantStep.iFracBits) );    
; 2629 : 
; 2630 : #else   // must be BUILD_INT_FLOAT or float encoder
; 2631 : 
; 2632 :     if ( iQSS < DBPOWER_TABLE_OFFSET )

  00006	83 7d 08 12	 cmp	 DWORD PTR _iQSS$[ebp], 18 ; 00000012H
  0000a	7d 52		 jge	 SHORT $L3097

; 2633 :     {   // This happens when iPower==0, not an important case, but return 10^(1/20) with 28 FractBits
; 2634 :         // It can also happen with a small NoisePower (-13 has been seen)
; 2635 :         if ( iQSS < 0 )

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iQSS$[ebp], 0
  00010	7d 27		 jge	 SHORT $L3098

; 2636 :         {   // negative values of iQSS are being generated in the V5 encoder (LowRate in particular)
; 2637 :             qstQuantStep = 0.382943866392f,      // Average Fraction
; 2638 :             qstQuantStep /= (Float)(1<<((-iQSS>>3)+1));                // Approximate Exponent

  00012	c7 45 fc 38 11
	c4 3e		 mov	 DWORD PTR _qstQuantStep$[ebp], 1053036856 ; 3ec41138H
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _iQSS$[ebp]
  0001c	f7 d9		 neg	 ecx
  0001e	c1 f9 03	 sar	 ecx, 3
  00021	83 c1 01	 add	 ecx, 1
  00024	b8 01 00 00 00	 mov	 eax, 1
  00029	d3 e0		 shl	 eax, cl
  0002b	89 45 f8	 mov	 DWORD PTR tv129[ebp], eax
  0002e	db 45 f8	 fild	 DWORD PTR tv129[ebp]
  00031	d8 7d fc	 fdivr	 DWORD PTR _qstQuantStep$[ebp]
  00034	d9 5d fc	 fstp	 DWORD PTR _qstQuantStep$[ebp]

; 2639 :         }
; 2640 :         else

  00037	eb 23		 jmp	 SHORT $L3100
$L3098:

; 2641 :         {
; 2642 :             qstQuantStep = 0.869439785679f;             // Average Fraction

  00039	c7 45 fc 9b 93
	5e 3f		 mov	 DWORD PTR _qstQuantStep$[ebp], 1063162779 ; 3f5e939bH

; 2643 :             qstQuantStep *= (Float)(1<<((iQSS>>3)+1));      // Approximate Exponent

  00040	8b 4d 08	 mov	 ecx, DWORD PTR _iQSS$[ebp]
  00043	c1 f9 03	 sar	 ecx, 3
  00046	83 c1 01	 add	 ecx, 1
  00049	ba 01 00 00 00	 mov	 edx, 1
  0004e	d3 e2		 shl	 edx, cl
  00050	89 55 f4	 mov	 DWORD PTR tv134[ebp], edx
  00053	db 45 f4	 fild	 DWORD PTR tv134[ebp]
  00056	d8 4d fc	 fmul	 DWORD PTR _qstQuantStep$[ebp]
  00059	d9 5d fc	 fstp	 DWORD PTR _qstQuantStep$[ebp]
$L3100:

; 2644 :         }
; 2645 :     }
; 2646 :     else if ( iQSS < (DBPOWER_TABLE_OFFSET+DBPOWER_TABLE_SIZE) )

  0005c	eb 46		 jmp	 SHORT $L3102
$L3097:
  0005e	81 7d 08 92 00
	00 00		 cmp	 DWORD PTR _iQSS$[ebp], 146 ; 00000092H
  00065	7d 1c		 jge	 SHORT $L3103

; 2647 :     {   // *** normal case ***
; 2648 :         // implied FractBit scale for rgiDBPower table
; 2649 :         qstQuantStep = rgDBPower10[ iQSS - DBPOWER_TABLE_OFFSET ] * rgfltDBPowerExponentScale[iQSS>>3];

  00067	8b 45 08	 mov	 eax, DWORD PTR _iQSS$[ebp]
  0006a	c1 f8 03	 sar	 eax, 3
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _iQSS$[ebp]
  00070	d9 04 8d b8 ff
	ff ff		 fld	 DWORD PTR _rgDBPower10[ecx*4-72]
  00077	d8 0c 85 00 00
	00 00		 fmul	 DWORD PTR _rgfltDBPowerExponentScale[eax*4]
  0007e	d9 5d fc	 fstp	 DWORD PTR _qstQuantStep$[ebp]

; 2650 :     }
; 2651 :     else

  00081	eb 21		 jmp	 SHORT $L3102
$L3103:

; 2652 :     {   // This branch can handle out-of-range cases. 
; 2653 :         // rare - but used in some cases by encoder - e.g. Tough_16m_16.
; 2654 :         // iQSS of 218 seen in encoding Tough 16kHz Stereo 16kbps
; 2655 :         qstQuantStep = (QuantStepType)pow (10, (double)(iQSS/(Float)QUANTSTEP_DENOMINATOR) );

  00083	db 45 08	 fild	 DWORD PTR _iQSS$[ebp]
  00086	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@41a00000
  0008c	83 ec 08	 sub	 esp, 8
  0008f	dd 1c 24	 fstp	 QWORD PTR [esp]
  00092	68 00 00 24 40	 push	 1076101120		; 40240000H
  00097	6a 00		 push	 0
  00099	e8 00 00 00 00	 call	 _pow
  0009e	83 c4 10	 add	 esp, 16			; 00000010H
  000a1	d9 5d fc	 fstp	 DWORD PTR _qstQuantStep$[ebp]
$L3102:

; 2656 :     }
; 2657 :     MONITOR_RANGE( gMR_qstQuantStep, qstQuantStep );
; 2658 : 
; 2659 : #endif
; 2660 : 
; 2661 :     return( qstQuantStep );

  000a4	d9 45 fc	 fld	 DWORD PTR _qstQuantStep$[ebp]

; 2662 : }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 04 00	 ret	 4
_qstCalcQuantStep_XDS@4 ENDP
WMADEC	ENDS
PUBLIC	_prvWeightedQuantization_XDS@12
EXTRN	_rgiMaskMinusPower10:BYTE
; Function compile flags: /Odt
;	COMDAT _prvWeightedQuantization_XDS@12
WMADEC	SEGMENT
tv86 = -12
_iIndex$ = -8
_qfltRMS$ = -4
_pau$ = 8
_ppcinfo$ = 12
_iBark$ = 16
_prvWeightedQuantization_XDS@12 PROC NEAR		; COMDAT

; 2672 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2673 :     Int iIndex = ppcinfo->m_iMaxMaskQ - ppcinfo->m_rgiMaskQ[iBark];

  00006	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  0000f	8b 45 10	 mov	 eax, DWORD PTR _iBark$[ebp]
  00012	8b 52 34	 mov	 edx, DWORD PTR [edx+52]
  00015	2b 14 81	 sub	 edx, DWORD PTR [ecx+eax*4]
  00018	89 55 f8	 mov	 DWORD PTR _iIndex$[ebp], edx

; 2674 :     QuantFloat qfltRMS;
; 2675 :     assert( 0 <= iIndex );
; 2676 : 
; 2677 :     if (iIndex >= MASK_MINUS_POWER_TABLE_SIZE)

  0001b	83 7d f8 48	 cmp	 DWORD PTR _iIndex$[ebp], 72 ; 00000048H
  0001f	7c 07		 jl	 SHORT $L3117

; 2678 :         iIndex = MASK_MINUS_POWER_TABLE_SIZE-1;

  00021	c7 45 f8 47 00
	00 00		 mov	 DWORD PTR _iIndex$[ebp], 71 ; 00000047H
$L3117:

; 2679 : #if defined(BUILD_INTEGER) ||defined(INTEGER_ENCODER)
; 2680 :     {
; 2681 :         Int uiFraction, iFracBits;
; 2682 :         uiFraction = rgiMaskMinusPower10[ iIndex ];     // with MASK_POWER_FRAC_BITS==28 fractional bits
; 2683 :         iFracBits = MASK_POWER_FRAC_BITS+(iIndex>>2);
; 2684 :         MONITOR_RANGE(gMR_WeightRatio,(float)uiFraction/pow(2,iFracBits));
; 2685 : #       ifdef _DEBUG
; 2686 :         {
; 2687 :             Float realRMS = (Float)pow(10,(float)(ppcinfo->m_rgiMaskQ[iBark] - ppcinfo->m_iMaxMaskQ)/(1<<4));
; 2688 :             Float Calculated = (float)uiFraction/(float)pow(2,iFracBits); 
; 2689 :             Float diff = (Float)fabs(realRMS-Calculated);
; 2690 :             Float rel = (Float)fabs(diff/realRMS);
; 2691 :             if (rel > .00002)
; 2692 :                 DEBUG_BREAK();
; 2693 :         }
; 2694 : #       endif
; 2695 :         qfltRMS.iFraction = MULT_HI(pau->m_qstQuantStep.iFraction,uiFraction);  
; 2696 :         qfltRMS.iFracBits = pau->m_qstQuantStep.iFracBits + iFracBits - 31;
; 2697 :         Norm4FastFloat( &qfltRMS );
; 2698 :     }
; 2699 : 
; 2700 : #else
; 2701 : 
; 2702 :     qfltRMS = rgiMaskMinusPower10[ iIndex ] / (Float)(1<<(iIndex>>2));

  00028	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0002b	c1 f9 02	 sar	 ecx, 2
  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	d3 e0		 shl	 eax, cl
  00035	89 45 f4	 mov	 DWORD PTR tv86[ebp], eax
  00038	db 45 f4	 fild	 DWORD PTR tv86[ebp]
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0003e	d8 3c 8d 00 00
	00 00		 fdivr	 DWORD PTR _rgiMaskMinusPower10[ecx*4]
  00045	d9 5d fc	 fstp	 DWORD PTR _qfltRMS$[ebp]

; 2703 :     MONITOR_RANGE(gMR_WeightRatio,qfltRMS);
; 2704 :     qfltRMS *= FLOAT_FROM_QUANTSTEPTYPE( pau->m_qstQuantStep );  

  00048	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0004b	d9 45 fc	 fld	 DWORD PTR _qfltRMS$[ebp]
  0004e	d8 0a		 fmul	 DWORD PTR [edx]
  00050	d9 55 fc	 fst	 DWORD PTR _qfltRMS$[ebp]

; 2705 : 
; 2706 : #endif
; 2707 : 
; 2708 :     return qfltRMS;
; 2709 : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 0c 00	 ret	 12			; 0000000cH
_prvWeightedQuantization_XDS@12 ENDP
WMADEC	ENDS
PUBLIC	_auReconCoefficentsHighRate_XDS@16
; Function compile flags: /Odt
;	COMDAT _auReconCoefficentsHighRate_XDS@16
WMADEC	SEGMENT
tv301 = -88
tv478 = -84
tv461 = -80
tv252 = -76
tv237 = -72
tv411 = -68
tv403 = -64
tv168 = -60
tv83 = -56
_fPrint$ = -52
_piRecon$ = -48
_ctCoefRecon$ = -44
_qfltQuantizer$ = -40
_rgiCoefRecon$ = -36
_cValidBarkBandLatestUpdate$ = -32
_iHighToBeZeroed$ = -28
_iMaskResampleRatio$ = -24
_iBark$ = -20
_rgiBarkIndex$ = -16
_wmaResult$ = -12
_iMaskResampleRatioPow$ = -8
_piHighCutOff$ = -4
_pau$ = 8
_pcaller$ = 12
_ppcinfo$ = 16
_piBitCnt$ = 20
_auReconCoefficentsHighRate_XDS@16 PROC NEAR		; COMDAT

; 2852 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	56		 push	 esi

; 2853 :     WMARESULT   wmaResult = WMA_OK;

  00007	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000c	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 2854 : 
; 2855 :     CoefType* rgiCoefRecon   = (CoefType*) ppcinfo->m_rgiCoefRecon;

  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00012	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00015	89 55 dc	 mov	 DWORD PTR _rgiCoefRecon$[ebp], edx

; 2856 :     CoefType ctCoefRecon;
; 2857 :     Int iMaskResampleRatio, cValidBarkBandLatestUpdate;
; 2858 :     Int iBark = 0;

  00018	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iBark$[ebp], 0

; 2859 :     I16* piRecon = &pau->m_iCurrReconCoef;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00022	83 c0 74	 add	 eax, 116		; 00000074H
  00025	89 45 d0	 mov	 DWORD PTR _piRecon$[ebp], eax

; 2860 : #if defined(PLATFORM_OPTIMIZATION_MINIMIZE_BRANCHING)
; 2861 :     Int iMask1,iMask2;
; 2862 : #endif
; 2863 :     INTEGER_ONLY( Int iShift; )
; 2864 :     Int iMaskResampleRatioPow;
; 2865 :     const Int *rgiBarkIndex;
; 2866 :     Int *piHighCutOff = &pau->m_iHighCutOffCurr;

  00028	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0002b	83 c1 28	 add	 ecx, 40			; 00000028H
  0002e	89 4d fc	 mov	 DWORD PTR _piHighCutOff$[ebp], ecx

; 2867 :     Int iHighToBeZeroed;
; 2868 :     QuantFloat qfltQuantizer;   // eithe a FastFloat or a Float, as appropriate to the build.
; 2869 :     Bool fPrint = WMAB_FALSE;

  00031	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _fPrint$[ebp], 0

; 2870 : #ifdef PROFILE
; 2871 :     FunctionProfile fp;
; 2872 :     FunctionProfileStart(&fp,DECODE_COEFFICENTS_HIGH_RATE_PROFILE);
; 2873 : #endif
; 2874 : 
; 2875 :     assert (!pau->m_fNoiseSub &&  pau->m_iWeightingMode == BARK_MODE);
; 2876 :     assert (pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame] != 0);
; 2877 :     assert (pau->m_cFrameSampleHalf <= (1<<12));                                            
; 2878 :     assert (pau->m_iSubFrameSizeWithUpdate != 0);
; 2879 :     DEBUG_BREAK_AT_FRAME_DECODE;
; 2880 : 
; 2881 :     if (pau->m_iSubFrameSizeWithUpdate <= 0 || pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame] <= 0)

  00038	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0003b	83 7a 7c 00	 cmp	 DWORD PTR [edx+124], 0
  0003f	7e 13		 jle	 SHORT $L3143
  00041	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00044	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00047	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0004a	83 bc 8a 78 01
	00 00 00	 cmp	 DWORD PTR [edx+ecx*4+376], 0
  00052	7f 08		 jg	 SHORT $L3142
$L3143:

; 2882 :         wmaResult = WMA_E_BROKEN_FRAME;

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_BROKEN_FRAME
  00059	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
$L3142:

; 2883 :     CHECKWMA_EXIT (wmaResult);

  0005c	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00060	7d 45		 jge	 SHORT $L3147
  00062	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00065	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  0006b	74 2f		 je	 SHORT $L3451
  0006d	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00070	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  00076	74 24		 je	 SHORT $L3451
  00078	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  0007b	50		 push	 eax
  0007c	68 43 0b 00 00	 push	 2883			; 00000b43H
  00081	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  00086	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00094	83 c4 14	 add	 esp, 20			; 00000014H
  00097	89 45 c8	 mov	 DWORD PTR tv83[ebp], eax
  0009a	eb 06		 jmp	 SHORT $L3452
$L3451:
  0009c	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0009f	89 55 c8	 mov	 DWORD PTR tv83[ebp], edx
$L3452:
  000a2	e9 3c 04 00 00	 jmp	 $exit$3146
$L3147:

; 2884 : 
; 2885 :     iMaskResampleRatio = (pau->m_iSubFrameSizeWithUpdate << 12) /                           
; 2886 :                           pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];    

  000a7	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000aa	8b 40 7c	 mov	 eax, DWORD PTR [eax+124]
  000ad	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000b3	8b 49 70	 mov	 ecx, DWORD PTR [ecx+112]
  000b6	8b 75 08	 mov	 esi, DWORD PTR _pau$[ebp]
  000b9	99		 cdq
  000ba	f7 bc 8e 78 01
	00 00		 idiv	 DWORD PTR [esi+ecx*4+376]
  000c1	89 45 e8	 mov	 DWORD PTR _iMaskResampleRatio$[ebp], eax

; 2887 :     iMaskResampleRatioPow = LOG2(iMaskResampleRatio);

  000c4	8b 55 e8	 mov	 edx, DWORD PTR _iMaskResampleRatio$[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 _LOG2@4
  000cd	89 45 f8	 mov	 DWORD PTR _iMaskResampleRatioPow$[ebp], eax

; 2888 :     rgiBarkIndex       = pau->m_rgiBarkIndexOrig + (NUM_BARK_BAND + 1) *                    
; 2889 :                          LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate);   

  000d0	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000d3	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000d6	8b 80 1c 03 00
	00		 mov	 eax, DWORD PTR [eax+796]
  000dc	99		 cdq
  000dd	f7 79 7c	 idiv	 DWORD PTR [ecx+124]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _LOG2@4
  000e6	6b c0 1a	 imul	 eax, 26			; 0000001aH
  000e9	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000ec	8b 8a b0 03 00
	00		 mov	 ecx, DWORD PTR [edx+944]
  000f2	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000f5	89 55 f0	 mov	 DWORD PTR _rgiBarkIndex$[ebp], edx

; 2890 :     cValidBarkBandLatestUpdate = pau->m_rgcValidBarkBand [LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate)];

  000f8	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000fe	8b 80 1c 03 00
	00		 mov	 eax, DWORD PTR [eax+796]
  00104	99		 cdq
  00105	f7 79 7c	 idiv	 DWORD PTR [ecx+124]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _LOG2@4
  0010e	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00111	8b 8a ac 03 00
	00		 mov	 ecx, DWORD PTR [edx+940]
  00117	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0011a	89 55 e0	 mov	 DWORD PTR _cValidBarkBandLatestUpdate$[ebp], edx

; 2891 : 
; 2892 :     //// DEBUG NOTES below are preceeded by four slashes and typically allow cut and paste so you can view scaled integers as floats
; 2893 :     //// They are on the line below where the calculation occurs - of course, with BUILD_INT_FLOAT, they are unnecessary
; 2894 : 
; 2895 :     // zero all coefs so we can just skip the many zero ones as we detect them below
; 2896 :     // note 70% of coefficents are zero in High Rate
; 2897 :     // wchen: moved to outside
; 2898 :     //memset (rgiCoefRecon , 0, sizeof (CoefType) * pau->m_cHighCutOff);//(iRun+pau->m_cLowCutOff));                     
; 2899 : 
; 2900 :     iBark = 0;

  0011d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iBark$[ebp], 0

; 2901 :     pau->m_iLevel = 0;

  00124	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00127	66 c7 40 20 00
	00		 mov	 WORD PTR [eax+32], 0

; 2902 :     *piHighCutOff = ppcinfo->m_cSubbandActual-1;//values need to be offset by -1 too 

  0012d	8b 4d 10	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00130	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00133	83 ea 01	 sub	 edx, 1
  00136	8b 45 fc	 mov	 eax, DWORD PTR _piHighCutOff$[ebp]
  00139	89 10		 mov	 DWORD PTR [eax], edx

; 2903 :     pau->m_iNextBarkIndex = -1; 

  0013b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0013e	c7 41 2c ff ff
	ff ff		 mov	 DWORD PTR [ecx+44], -1
$L3149:

; 2904 : 
; 2905 :     //Scan for the first bark index = note iRecon is 0 and rgiBarkIndex[1] ==0 for 16000 Hz and 11025 Hz frames with 128 oir 64 samples
; 2906 :     while ((((*piRecon) * iMaskResampleRatio) >> 12) >= rgiBarkIndex [iBark+1]) 

  00145	8b 55 d0	 mov	 edx, DWORD PTR _piRecon$[ebp]
  00148	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0014b	0f af 45 e8	 imul	 eax, DWORD PTR _iMaskResampleRatio$[ebp]
  0014f	c1 f8 0c	 sar	 eax, 12			; 0000000cH
  00152	8b 4d ec	 mov	 ecx, DWORD PTR _iBark$[ebp]
  00155	8b 55 f0	 mov	 edx, DWORD PTR _rgiBarkIndex$[ebp]
  00158	3b 44 8a 04	 cmp	 eax, DWORD PTR [edx+ecx*4+4]
  0015c	7c 0b		 jl	 SHORT $L3150

; 2907 :         ++iBark;

  0015e	8b 45 ec	 mov	 eax, DWORD PTR _iBark$[ebp]
  00161	83 c0 01	 add	 eax, 1
  00164	89 45 ec	 mov	 DWORD PTR _iBark$[ebp], eax
  00167	eb dc		 jmp	 SHORT $L3149
$L3150:

; 2908 :         
; 2909 :     TRACEWMA_EXIT (wmaResult, (*pau->aupfnGetNextRun) (pcaller, ppcinfo, piBitCnt));

  00169	8b 4d 14	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  0016c	51		 push	 ecx
  0016d	8b 55 10	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00170	52		 push	 edx
  00171	8b 45 0c	 mov	 eax, DWORD PTR _pcaller$[ebp]
  00174	50		 push	 eax
  00175	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00178	ff 91 f4 03 00
	00		 call	 DWORD PTR [ecx+1012]
  0017e	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00181	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00185	7d 45		 jge	 SHORT $L3153
  00187	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0018a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  00190	74 2f		 je	 SHORT $L3453
  00192	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00195	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  0019b	74 24		 je	 SHORT $L3453
  0019d	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  001a0	51		 push	 ecx
  001a1	68 5d 0b 00 00	 push	 2909			; 00000b5dH
  001a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  001ab	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  001b0	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  001b3	52		 push	 edx
  001b4	e8 00 00 00 00	 call	 _MyOutputDbgStr
  001b9	83 c4 14	 add	 esp, 20			; 00000014H
  001bc	89 45 c4	 mov	 DWORD PTR tv168[ebp], eax
  001bf	eb 06		 jmp	 SHORT $L3454
$L3453:
  001c1	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  001c4	89 45 c4	 mov	 DWORD PTR tv168[ebp], eax
$L3454:
  001c7	e9 17 03 00 00	 jmp	 $exit$3146
$L3153:

; 2910 :     DBG_RUNLEVEL(g_cBitGet-21,pau->m_cRunOfZeros,pau->m_iLevel,pau->m_iSign,fPrint);
; 2911 :     *piRecon += (I16)pau->m_cRunOfZeros+1;

  001cc	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  001cf	0f bf 51 1c	 movsx	 edx, WORD PTR [ecx+28]
  001d3	8b 45 d0	 mov	 eax, DWORD PTR _piRecon$[ebp]
  001d6	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  001d9	8d 54 11 01	 lea	 edx, DWORD PTR [ecx+edx+1]
  001dd	8b 45 d0	 mov	 eax, DWORD PTR _piRecon$[ebp]
  001e0	66 89 10	 mov	 WORD PTR [eax], dx
$L3156:

; 2912 : 
; 2913 :     while (*piRecon < *piHighCutOff && iBark < cValidBarkBandLatestUpdate) {

  001e3	8b 4d d0	 mov	 ecx, DWORD PTR _piRecon$[ebp]
  001e6	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  001e9	8b 45 fc	 mov	 eax, DWORD PTR _piHighCutOff$[ebp]
  001ec	3b 10		 cmp	 edx, DWORD PTR [eax]
  001ee	0f 8d eb 01 00
	00		 jge	 $L3157
  001f4	8b 4d ec	 mov	 ecx, DWORD PTR _iBark$[ebp]
  001f7	3b 4d e0	 cmp	 ecx, DWORD PTR _cValidBarkBandLatestUpdate$[ebp]
  001fa	0f 8d df 01 00
	00		 jge	 $L3157
$L3159:

; 2914 : 
; 2915 :         //Search for the next bark index
; 2916 :         while ((((*piRecon) * iMaskResampleRatio) >> 12) >= rgiBarkIndex [iBark+1]) 

  00200	8b 55 d0	 mov	 edx, DWORD PTR _piRecon$[ebp]
  00203	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00206	0f af 45 e8	 imul	 eax, DWORD PTR _iMaskResampleRatio$[ebp]
  0020a	c1 f8 0c	 sar	 eax, 12			; 0000000cH
  0020d	8b 4d ec	 mov	 ecx, DWORD PTR _iBark$[ebp]
  00210	8b 55 f0	 mov	 edx, DWORD PTR _rgiBarkIndex$[ebp]
  00213	3b 44 8a 04	 cmp	 eax, DWORD PTR [edx+ecx*4+4]
  00217	7c 0b		 jl	 SHORT $L3160

; 2917 :             ++iBark;

  00219	8b 45 ec	 mov	 eax, DWORD PTR _iBark$[ebp]
  0021c	83 c0 01	 add	 eax, 1
  0021f	89 45 ec	 mov	 DWORD PTR _iBark$[ebp], eax
  00222	eb dc		 jmp	 SHORT $L3159
$L3160:

; 2918 : 
; 2919 :         if ( iBark >= cValidBarkBandLatestUpdate )

  00224	8b 4d ec	 mov	 ecx, DWORD PTR _iBark$[ebp]
  00227	3b 4d e0	 cmp	 ecx, DWORD PTR _cValidBarkBandLatestUpdate$[ebp]
  0022a	7c 05		 jl	 SHORT $L3161

; 2920 :         {
; 2921 :             assert( iBark < cValidBarkBandLatestUpdate );
; 2922 :             break;

  0022c	e9 ae 01 00 00	 jmp	 $L3157
$L3161:

; 2923 :         }
; 2924 : 
; 2925 :         // Get the quantStep * (10^(1/16))^(MaxMaskQ-MaskQ[iRecon])
; 2926 :         // as qfltQuantizer.fraction/(1<<(23-qfltQuantizer.exponent))
; 2927 :         // then scale coefficent to give it five FracBits
; 2928 :         if (*piRecon == pau->m_iNextBarkIndex) {                               

  00231	8b 55 d0	 mov	 edx, DWORD PTR _piRecon$[ebp]
  00234	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00237	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0023a	3b 41 2c	 cmp	 eax, DWORD PTR [ecx+44]
  0023d	75 29		 jne	 SHORT $L3162

; 2929 :             //Reconstruct the coefficent before getting the next weighting factor if it lies at the end of a bark band        
; 2930 :             ctCoefRecon = MULT_QUANT(pau->m_iLevel,qfltQuantizer);

  0023f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00242	0f bf 42 20	 movsx	 eax, WORD PTR [edx+32]
  00246	89 45 c0	 mov	 DWORD PTR tv403[ebp], eax
  00249	db 45 c0	 fild	 DWORD PTR tv403[ebp]
  0024c	d8 4d d8	 fmul	 DWORD PTR _qfltQuantizer$[ebp]
  0024f	d9 5d d4	 fstp	 DWORD PTR _ctCoefRecon$[ebp]

; 2931 :             //// Unsigned Float CoefRecon = ctCoefRecon/(1.0F*(1<<(qfltQuantizer.iFracBits+16-31)))
; 2932 :             INTEGER_ONLY( ctCoefRecon = SCALE_COEF_RECON(ctCoefRecon) );
; 2933 :             //// Unsigned Float CoefRecon = ctCoefRecon/32.0F
; 2934 :             VERIFY_DECODED_COEFFICENT(iBark-1);
; 2935 :             qfltQuantizer = prvWeightedQuantization(pau,ppcinfo,iBark);

  00252	8b 4d ec	 mov	 ecx, DWORD PTR _iBark$[ebp]
  00255	51		 push	 ecx
  00256	8b 55 10	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00259	52		 push	 edx
  0025a	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0025d	50		 push	 eax
  0025e	e8 00 00 00 00	 call	 _prvWeightedQuantization_XDS@12
  00263	d9 5d d8	 fstp	 DWORD PTR _qfltQuantizer$[ebp]

; 2936 :             //// Float Quantizer = qfltQuantizer.iFraction/(1024.0F*(1<<(qfltQuantizer-10)))
; 2937 :             MAKE_MASK_FOR_SCALING(qfltQuantizer.iFracBits);
; 2938 :         } else {

  00266	eb 27		 jmp	 SHORT $L3163
$L3162:

; 2939 :             //Otherwize get the next weighting factor first
; 2940 :             assert( *piRecon > pau->m_iNextBarkIndex );
; 2941 :             qfltQuantizer = prvWeightedQuantization(pau,ppcinfo,iBark);         

  00268	8b 4d ec	 mov	 ecx, DWORD PTR _iBark$[ebp]
  0026b	51		 push	 ecx
  0026c	8b 55 10	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  0026f	52		 push	 edx
  00270	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00273	50		 push	 eax
  00274	e8 00 00 00 00	 call	 _prvWeightedQuantization_XDS@12
  00279	d9 5d d8	 fstp	 DWORD PTR _qfltQuantizer$[ebp]

; 2942 :             //// Float Quantizer = qfltQuantizer.iFraction/(1024.0F*(1<<(qfltQuantizer-10)))
; 2943 :             MAKE_MASK_FOR_SCALING(qfltQuantizer.iFracBits);
; 2944 :             ctCoefRecon = MULT_QUANT(pau->m_iLevel,qfltQuantizer);

  0027c	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0027f	0f bf 51 20	 movsx	 edx, WORD PTR [ecx+32]
  00283	89 55 bc	 mov	 DWORD PTR tv411[ebp], edx
  00286	db 45 bc	 fild	 DWORD PTR tv411[ebp]
  00289	d8 4d d8	 fmul	 DWORD PTR _qfltQuantizer$[ebp]
  0028c	d9 5d d4	 fstp	 DWORD PTR _ctCoefRecon$[ebp]
$L3163:

; 2945 :             //// Unsigned Float CoefRecon = ctCoefRecon/(1.0F*(1<<(qfltQuantizer.iFracBits+16-31)))
; 2946 :             INTEGER_ONLY( ctCoefRecon = SCALE_COEF_RECON(ctCoefRecon) );
; 2947 :             //// Unsigned Float CoefRecon = ctCoefRecon/32.0F
; 2948 :             VERIFY_DECODED_COEFFICENT(iBark);
; 2949 :         }
; 2950 : 
; 2951 :         //Calculate the index of the end of this bark band
; 2952 :         if (iMaskResampleRatioPow > 12){

  0028f	83 7d f8 0c	 cmp	 DWORD PTR _iMaskResampleRatioPow$[ebp], 12 ; 0000000cH
  00293	7e 29		 jle	 SHORT $L3164

; 2953 :             pau->m_iNextBarkIndex = (rgiBarkIndex [iBark + 1] + (1<<(iMaskResampleRatioPow-13))) >> (iMaskResampleRatioPow-12);

  00295	8b 4d f8	 mov	 ecx, DWORD PTR _iMaskResampleRatioPow$[ebp]
  00298	83 e9 0d	 sub	 ecx, 13			; 0000000dH
  0029b	b8 01 00 00 00	 mov	 eax, 1
  002a0	d3 e0		 shl	 eax, cl
  002a2	8b 4d ec	 mov	 ecx, DWORD PTR _iBark$[ebp]
  002a5	8b 55 f0	 mov	 edx, DWORD PTR _rgiBarkIndex$[ebp]
  002a8	8b 54 8a 04	 mov	 edx, DWORD PTR [edx+ecx*4+4]
  002ac	03 d0		 add	 edx, eax
  002ae	8b 4d f8	 mov	 ecx, DWORD PTR _iMaskResampleRatioPow$[ebp]
  002b1	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  002b4	d3 fa		 sar	 edx, cl
  002b6	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002b9	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 2954 :         } else {

  002bc	eb 1a		 jmp	 SHORT $L3165
$L3164:

; 2955 :             pau->m_iNextBarkIndex = (rgiBarkIndex [iBark + 1] << (12-iMaskResampleRatioPow));

  002be	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  002c3	2b 4d f8	 sub	 ecx, DWORD PTR _iMaskResampleRatioPow$[ebp]
  002c6	8b 55 ec	 mov	 edx, DWORD PTR _iBark$[ebp]
  002c9	8b 45 f0	 mov	 eax, DWORD PTR _rgiBarkIndex$[ebp]
  002cc	8b 54 90 04	 mov	 edx, DWORD PTR [eax+edx*4+4]
  002d0	d3 e2		 shl	 edx, cl
  002d2	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002d5	89 50 2c	 mov	 DWORD PTR [eax+44], edx
$L3165:

; 2956 :         }
; 2957 :         pau->m_iNextBarkIndex--; //correct by -1

  002d8	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002db	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  002de	83 ea 01	 sub	 edx, 1
  002e1	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002e4	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 2958 :         if (pau->m_iNextBarkIndex > *piHighCutOff) 

  002e7	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002ea	8b 55 fc	 mov	 edx, DWORD PTR _piHighCutOff$[ebp]
  002ed	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  002f0	3b 02		 cmp	 eax, DWORD PTR [edx]
  002f2	7e 0b		 jle	 SHORT $L3167

; 2959 :             pau->m_iNextBarkIndex = *piHighCutOff;

  002f4	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002f7	8b 55 fc	 mov	 edx, DWORD PTR _piHighCutOff$[ebp]
  002fa	8b 02		 mov	 eax, DWORD PTR [edx]
  002fc	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
$L3167:

; 2960 : 
; 2961 :         do {
; 2962 :             rgiCoefRecon [*piRecon] = INTEGER_OR_INT_FLOAT( (ctCoefRecon^pau->m_iSign)-pau->m_iSign, 
; 2963 :                                     pau->m_iSign ? -ctCoefRecon : ctCoefRecon );

  002ff	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00302	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00306	74 0a		 je	 SHORT $L3455
  00308	d9 45 d4	 fld	 DWORD PTR _ctCoefRecon$[ebp]
  0030b	d9 e0		 fchs
  0030d	d9 5d b8	 fstp	 DWORD PTR tv237[ebp]
  00310	eb 06		 jmp	 SHORT $L3456
$L3455:
  00312	8b 55 d4	 mov	 edx, DWORD PTR _ctCoefRecon$[ebp]
  00315	89 55 b8	 mov	 DWORD PTR tv237[ebp], edx
$L3456:
  00318	8b 45 d0	 mov	 eax, DWORD PTR _piRecon$[ebp]
  0031b	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0031e	8b 55 dc	 mov	 edx, DWORD PTR _rgiCoefRecon$[ebp]
  00321	8b 45 b8	 mov	 eax, DWORD PTR tv237[ebp]
  00324	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 2964 :             //// Float CoefRecon = rgiCoefRecon [iRecon]/32.0F
; 2965 :             MONITOR_RANGE(gMR_CoefRecon,FLOAT_FROM_COEF(rgiCoefRecon[*piRecon]));
; 2966 :             MONITOR_COUNT_CONDITIONAL(rgiCoefRecon[*piRecon]==0,gMC_zeroCoefRecon,pau->m_cRunOfZeros);
; 2967 :             TRACEWMA_EXIT (wmaResult, (*pau->aupfnGetNextRun) (pcaller, ppcinfo, piBitCnt));

  00327	8b 4d 14	 mov	 ecx, DWORD PTR _piBitCnt$[ebp]
  0032a	51		 push	 ecx
  0032b	8b 55 10	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  0032e	52		 push	 edx
  0032f	8b 45 0c	 mov	 eax, DWORD PTR _pcaller$[ebp]
  00332	50		 push	 eax
  00333	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00336	ff 91 f4 03 00
	00		 call	 DWORD PTR [ecx+1012]
  0033c	89 45 f4	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0033f	83 7d f4 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00343	7d 45		 jge	 SHORT $L3172
  00345	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00348	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  0034e	74 2f		 je	 SHORT $L3457
  00350	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00353	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00359	74 24		 je	 SHORT $L3457
  0035b	8b 4d f4	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0035e	51		 push	 ecx
  0035f	68 97 0b 00 00	 push	 2967			; 00000b97H
  00364	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EI@JPBFKEMC@c?3?2xbox?2private?2windows?2directx?2@
  00369	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0036e	8b 55 f4	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00371	52		 push	 edx
  00372	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00377	83 c4 14	 add	 esp, 20			; 00000014H
  0037a	89 45 b4	 mov	 DWORD PTR tv252[ebp], eax
  0037d	eb 06		 jmp	 SHORT $L3458
$L3457:
  0037f	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00382	89 45 b4	 mov	 DWORD PTR tv252[ebp], eax
$L3458:
  00385	e9 59 01 00 00	 jmp	 $exit$3146
$L3172:

; 2968 :             DBG_RUNLEVEL(g_cBitGet-21,pau->m_cRunOfZeros,pau->m_iLevel,pau->m_iSign,fPrint);
; 2969 :             *piRecon += (I16)pau->m_cRunOfZeros+1;

  0038a	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0038d	0f bf 51 1c	 movsx	 edx, WORD PTR [ecx+28]
  00391	8b 45 d0	 mov	 eax, DWORD PTR _piRecon$[ebp]
  00394	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00397	8d 54 11 01	 lea	 edx, DWORD PTR [ecx+edx+1]
  0039b	8b 45 d0	 mov	 eax, DWORD PTR _piRecon$[ebp]
  0039e	66 89 10	 mov	 WORD PTR [eax], dx

; 2970 :             if (*piRecon >= pau->m_iNextBarkIndex) 

  003a1	8b 4d d0	 mov	 ecx, DWORD PTR _piRecon$[ebp]
  003a4	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  003a7	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  003aa	3b 50 2c	 cmp	 edx, DWORD PTR [eax+44]
  003ad	7c 02		 jl	 SHORT $L3174

; 2971 :                 break;

  003af	eb 20		 jmp	 SHORT $L3169
$L3174:

; 2972 :             ctCoefRecon = MULT_QUANT(pau->m_iLevel,qfltQuantizer);

  003b1	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  003b4	0f bf 51 20	 movsx	 edx, WORD PTR [ecx+32]
  003b8	89 55 b0	 mov	 DWORD PTR tv461[ebp], edx
  003bb	db 45 b0	 fild	 DWORD PTR tv461[ebp]
  003be	d8 4d d8	 fmul	 DWORD PTR _qfltQuantizer$[ebp]
  003c1	d9 5d d4	 fstp	 DWORD PTR _ctCoefRecon$[ebp]

; 2973 :             INTEGER_ONLY( ctCoefRecon = SCALE_COEF_RECON(ctCoefRecon) );
; 2974 :             VERIFY_DECODED_COEFFICENT(iBark);
; 2975 :         } while (WMAB_TRUE);   

  003c4	b8 01 00 00 00	 mov	 eax, 1
  003c9	85 c0		 test	 eax, eax
  003cb	0f 85 2e ff ff
	ff		 jne	 $L3167
$L3169:

; 2976 :         iBark++;

  003d1	8b 4d ec	 mov	 ecx, DWORD PTR _iBark$[ebp]
  003d4	83 c1 01	 add	 ecx, 1
  003d7	89 4d ec	 mov	 DWORD PTR _iBark$[ebp], ecx

; 2977 :     }

  003da	e9 04 fe ff ff	 jmp	 $L3156
$L3157:

; 2978 :     if (*piRecon == *piHighCutOff) {

  003df	8b 55 d0	 mov	 edx, DWORD PTR _piRecon$[ebp]
  003e2	0f bf 02	 movsx	 eax, WORD PTR [edx]
  003e5	8b 4d fc	 mov	 ecx, DWORD PTR _piHighCutOff$[ebp]
  003e8	3b 01		 cmp	 eax, DWORD PTR [ecx]
  003ea	0f 85 99 00 00
	00		 jne	 $L3175

; 2979 :         if ( *piRecon >= pau->m_iNextBarkIndex  )

  003f0	8b 55 d0	 mov	 edx, DWORD PTR _piRecon$[ebp]
  003f3	0f bf 02	 movsx	 eax, WORD PTR [edx]
  003f6	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  003f9	3b 41 2c	 cmp	 eax, DWORD PTR [ecx+44]
  003fc	7c 50		 jl	 SHORT $L3181
$L3178:

; 2980 :         {   // skipped here via a cRunOfZeros past one or more iBark increments
; 2981 :             while ( ((iBark-1) < cValidBarkBandLatestUpdate) && (((*piRecon) * iMaskResampleRatio) >> 12) >= rgiBarkIndex [iBark] ) 

  003fe	8b 55 ec	 mov	 edx, DWORD PTR _iBark$[ebp]
  00401	83 ea 01	 sub	 edx, 1
  00404	3b 55 e0	 cmp	 edx, DWORD PTR _cValidBarkBandLatestUpdate$[ebp]
  00407	7d 23		 jge	 SHORT $L3179
  00409	8b 45 d0	 mov	 eax, DWORD PTR _piRecon$[ebp]
  0040c	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0040f	0f af 4d e8	 imul	 ecx, DWORD PTR _iMaskResampleRatio$[ebp]
  00413	c1 f9 0c	 sar	 ecx, 12			; 0000000cH
  00416	8b 55 ec	 mov	 edx, DWORD PTR _iBark$[ebp]
  00419	8b 45 f0	 mov	 eax, DWORD PTR _rgiBarkIndex$[ebp]
  0041c	3b 0c 90	 cmp	 ecx, DWORD PTR [eax+edx*4]
  0041f	7c 0b		 jl	 SHORT $L3179

; 2982 :                 ++iBark;

  00421	8b 4d ec	 mov	 ecx, DWORD PTR _iBark$[ebp]
  00424	83 c1 01	 add	 ecx, 1
  00427	89 4d ec	 mov	 DWORD PTR _iBark$[ebp], ecx
  0042a	eb d2		 jmp	 SHORT $L3178
$L3179:

; 2983 :             if ( (iBark-1) <= cValidBarkBandLatestUpdate )

  0042c	8b 55 ec	 mov	 edx, DWORD PTR _iBark$[ebp]
  0042f	83 ea 01	 sub	 edx, 1
  00432	3b 55 e0	 cmp	 edx, DWORD PTR _cValidBarkBandLatestUpdate$[ebp]
  00435	7f 17		 jg	 SHORT $L3181

; 2984 :             {   
; 2985 :                 qfltQuantizer = prvWeightedQuantization(pau,ppcinfo,iBark-1);         

  00437	8b 45 ec	 mov	 eax, DWORD PTR _iBark$[ebp]
  0043a	83 e8 01	 sub	 eax, 1
  0043d	50		 push	 eax
  0043e	8b 4d 10	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00441	51		 push	 ecx
  00442	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00445	52		 push	 edx
  00446	e8 00 00 00 00	 call	 _prvWeightedQuantization_XDS@12
  0044b	d9 5d d8	 fstp	 DWORD PTR _qfltQuantizer$[ebp]
$L3181:

; 2986 :                 //// Float Quantizer = qfltQuantizer.iFraction/(1024.0F*(1<<(qfltQuantizer-10)))
; 2987 :                 MAKE_MASK_FOR_SCALING(qfltQuantizer.iFracBits);
; 2988 :             }
; 2989 :         }
; 2990 :         else
; 2991 :         {
; 2992 :             assert(WMAB_FALSE);
; 2993 :         }
; 2994 :         ctCoefRecon = MULT_QUANT(pau->m_iLevel,qfltQuantizer);

  0044e	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00451	0f bf 48 20	 movsx	 ecx, WORD PTR [eax+32]
  00455	89 4d ac	 mov	 DWORD PTR tv478[ebp], ecx
  00458	db 45 ac	 fild	 DWORD PTR tv478[ebp]
  0045b	d8 4d d8	 fmul	 DWORD PTR _qfltQuantizer$[ebp]
  0045e	d9 5d d4	 fstp	 DWORD PTR _ctCoefRecon$[ebp]

; 2995 :         //// Unsigned Float CoefRecon = ctCoefRecon/(1.0F*(1<<(qfltQuantizer.iFracBits+16-31)))
; 2996 :         INTEGER_ONLY( ctCoefRecon = SCALE_COEF_RECON(ctCoefRecon) );
; 2997 :         //// Unsigned Float CoefRecon = ctCoefRecon/32.0F
; 2998 :         VERIFY_DECODED_COEFFICENT(iBark-1);
; 2999 :         rgiCoefRecon [*piRecon] = INTEGER_OR_INT_FLOAT( (ctCoefRecon^pau->m_iSign)-pau->m_iSign, 
; 3000 :                                 pau->m_iSign ? -ctCoefRecon : ctCoefRecon );

  00461	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00464	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  00468	74 0a		 je	 SHORT $L3459
  0046a	d9 45 d4	 fld	 DWORD PTR _ctCoefRecon$[ebp]
  0046d	d9 e0		 fchs
  0046f	d9 5d a8	 fstp	 DWORD PTR tv301[ebp]
  00472	eb 06		 jmp	 SHORT $L3460
$L3459:
  00474	8b 45 d4	 mov	 eax, DWORD PTR _ctCoefRecon$[ebp]
  00477	89 45 a8	 mov	 DWORD PTR tv301[ebp], eax
$L3460:
  0047a	8b 4d d0	 mov	 ecx, DWORD PTR _piRecon$[ebp]
  0047d	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00480	8b 45 dc	 mov	 eax, DWORD PTR _rgiCoefRecon$[ebp]
  00483	8b 4d a8	 mov	 ecx, DWORD PTR tv301[ebp]
  00486	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
$L3175:

; 3001 :         //// Float CoefRecon = rgiCoefRecon [iRecon]/32.0F
; 3002 :         MONITOR_RANGE(gMR_CoefRecon,FLOAT_FROM_COEF(rgiCoefRecon[*piRecon]));
; 3003 :         MONITOR_COUNT_CONDITIONAL(rgiCoefRecon[*piRecon]==0,gMC_zeroCoefRecon,pau->m_cRunOfZeros);
; 3004 :     }
; 3005 :     assert (*piRecon <= pau->m_cSubband); 
; 3006 :     assert (iBark <=  cValidBarkBandLatestUpdate );
; 3007 : 
; 3008 :     // do low cutoff here so there is less branching in the above loop
; 3009 :     if ( pau->m_cLowCutOff > 0 )

  00489	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0048c	83 ba 24 03 00
	00 00		 cmp	 DWORD PTR [edx+804], 0
  00493	7e 1b		 jle	 SHORT $L3182

; 3010 :     {
; 3011 :         memset (rgiCoefRecon, 0, sizeof (Int) * pau->m_cLowCutOff);

  00495	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00498	8b 88 24 03 00
	00		 mov	 ecx, DWORD PTR [eax+804]
  0049e	c1 e1 02	 shl	 ecx, 2
  004a1	51		 push	 ecx
  004a2	6a 00		 push	 0
  004a4	8b 55 dc	 mov	 edx, DWORD PTR _rgiCoefRecon$[ebp]
  004a7	52		 push	 edx
  004a8	e8 00 00 00 00	 call	 _memset
  004ad	83 c4 0c	 add	 esp, 12			; 0000000cH
$L3182:

; 3012 : #       if defined(_DEBUG) && defined(WMA_MONITOR)
; 3013 :         {   int ii;
; 3014 :             for( ii = 0; ii < pau->m_cLowCutOff; ii++ )
; 3015 :                 MONITOR_RANGE(gMR_CoefRecon,0);
; 3016 :         }
; 3017 : #       endif
; 3018 :     }
; 3019 : 
; 3020 :     //do high cutoff here 
; 3021 :     iHighToBeZeroed = sizeof(CoefType) * (pau->m_cSubbandAdjusted - pau->m_cHighCutOffAdjusted);

  004b0	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  004b3	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  004b6	8b 50 60	 mov	 edx, DWORD PTR [eax+96]
  004b9	2b 91 28 03 00
	00		 sub	 edx, DWORD PTR [ecx+808]
  004bf	c1 e2 02	 shl	 edx, 2
  004c2	89 55 e4	 mov	 DWORD PTR _iHighToBeZeroed$[ebp], edx

; 3022 :     memset (rgiCoefRecon + pau->m_cHighCutOffAdjusted, 0, iHighToBeZeroed);    

  004c5	8b 45 e4	 mov	 eax, DWORD PTR _iHighToBeZeroed$[ebp]
  004c8	50		 push	 eax
  004c9	6a 00		 push	 0
  004cb	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  004ce	8b 91 28 03 00
	00		 mov	 edx, DWORD PTR [ecx+808]
  004d4	8b 45 dc	 mov	 eax, DWORD PTR _rgiCoefRecon$[ebp]
  004d7	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  004da	51		 push	 ecx
  004db	e8 00 00 00 00	 call	 _memset
  004e0	83 c4 0c	 add	 esp, 12			; 0000000cH
$exit$3146:

; 3023 : #   if defined(_DEBUG) && defined(WMA_MONITOR)
; 3024 :     {   
; 3025 :     int ii;
; 3026 :     for( ii = 0; ii < iHighToBeZeroed; ii += sizeof(Int) )
; 3027 :         MONITOR_RANGE(gMR_CoefRecon,0);
; 3028 :     }
; 3029 : #   endif
; 3030 : 
; 3031 : exit:
; 3032 : #ifdef PROFILE
; 3033 :     FunctionProfileStop(&fp);
; 3034 : #endif
; 3035 :     return wmaResult;

  004e3	8b 45 f4	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 3036 : }

  004e6	5e		 pop	 esi
  004e7	8b e5		 mov	 esp, ebp
  004e9	5d		 pop	 ebp
  004ea	c2 10 00	 ret	 16			; 00000010H
_auReconCoefficentsHighRate_XDS@16 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _prvInitDiscardSilence_XDS@4
WMADEC	SEGMENT
_iChan$3196 = -12
_fStartOfStream$ = -8
_i$ = -4
_pau$ = 8
_prvInitDiscardSilence_XDS@4 PROC NEAR			; COMDAT

; 3044 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3045 :     // If this is the very first frame, we need to determine if we are at the
; 3046 :     // start-of-file, rather than seeking. If so, we need to discard the silence
; 3047 :     // frames. If not, we need to only discard half a subframe. NOTE that for
; 3048 :     // V4 encoded streams, WE WILL GUESS INCORRECTLY. Our justification for accepting
; 3049 :     // this is that V4 never had timestamps and so sync was never guaranteed anyway.
; 3050 :     Bool fStartOfStream = WMAB_TRUE;

  00006	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fStartOfStream$[ebp], 1

; 3051 :     int i;
; 3052 : 
; 3053 :     assert(CODEC_BEGIN == pau->m_codecStatus);
; 3054 : 
; 3055 :     // Due to SCRUNCH bug #32, v5 encoder forces fMaskUpdate to TRUE and
; 3056 :     // all channels' m_iPower to 1 in the very first frame only. If we find that
; 3057 :     // fMaskUpdate, m_iPower are all TRUE but in fact there is no power here,
; 3058 :     // then we know this is a v5-encoded file and this is start-of-file
; 3059 :     if (WMAB_FALSE == pau->m_subfrmconfigCurr.m_rgfMaskUpdate[0])

  0000d	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00010	83 b8 04 02 00
	00 00		 cmp	 DWORD PTR [eax+516], 0
  00017	75 07		 jne	 SHORT $L3190

; 3060 :         fStartOfStream = WMAB_FALSE;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fStartOfStream$[ebp], 0
$L3190:

; 3061 : 
; 3062 :     for (i = 0; i < pau->m_cChannel; i++)

  00020	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00027	eb 09		 jmp	 SHORT $L3191
$L3192:
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0002c	83 c1 01	 add	 ecx, 1
  0002f	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L3191:
  00032	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00035	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  00039	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  0003c	7d 1f		 jge	 SHORT $L3193

; 3063 :     {
; 3064 :         if (0 == pau->m_rgpcinfo[i].m_iPower)

  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00041	6b c9 70	 imul	 ecx, 112		; 00000070H
  00044	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00047	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  0004d	83 7c 08 24 00	 cmp	 DWORD PTR [eax+ecx+36], 0
  00052	75 07		 jne	 SHORT $L3194

; 3065 :             fStartOfStream = WMAB_FALSE;

  00054	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fStartOfStream$[ebp], 0
$L3194:

; 3066 :     }

  0005b	eb cc		 jmp	 SHORT $L3192
$L3193:

; 3067 : 
; 3068 :     if (fStartOfStream)

  0005d	83 7d f8 00	 cmp	 DWORD PTR _fStartOfStream$[ebp], 0
  00061	74 3d		 je	 SHORT $L3195

; 3069 :     {
; 3070 :         int iChan;
; 3071 :             
; 3072 :         // Bitstream has forced update, claims non-zero power for all channels.
; 3073 :         // Verify that claim.
; 3074 :         for (iChan = 0; iChan < pau->m_cChannel; iChan++)

  00063	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iChan$3196[ebp], 0
  0006a	eb 09		 jmp	 SHORT $L3197
$L3198:
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR _iChan$3196[ebp]
  0006f	83 c1 01	 add	 ecx, 1
  00072	89 4d f4	 mov	 DWORD PTR _iChan$3196[ebp], ecx
$L3197:
  00075	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00078	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  0007c	39 45 f4	 cmp	 DWORD PTR _iChan$3196[ebp], eax
  0007f	7d 1f		 jge	 SHORT $L3195

; 3075 :         {
; 3076 :             if (0 != pau->m_rgpcinfo[iChan].m_iActualPower)

  00081	8b 4d f4	 mov	 ecx, DWORD PTR _iChan$3196[ebp]
  00084	6b c9 70	 imul	 ecx, 112		; 00000070H
  00087	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0008a	8b 82 a0 03 00
	00		 mov	 eax, DWORD PTR [edx+928]
  00090	83 7c 08 28 00	 cmp	 DWORD PTR [eax+ecx+40], 0
  00095	74 07		 je	 SHORT $L3200

; 3077 :                 fStartOfStream = WMAB_FALSE;

  00097	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fStartOfStream$[ebp], 0
$L3200:

; 3078 :         } // for (channels)

  0009e	eb cc		 jmp	 SHORT $L3198
$L3195:

; 3079 :     }
; 3080 : 
; 3081 :     // Finally the moment of truth: set m_iDiscardSilence
; 3082 :     pau->m_fSeekAdjustment = WMAB_FALSE;

  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000a3	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0

; 3083 :     if (fStartOfStream)

  000aa	83 7d f8 00	 cmp	 DWORD PTR _fStartOfStream$[ebp], 0
  000ae	74 14		 je	 SHORT $L3201

; 3084 :         pau->m_iDiscardSilence = pau->m_cFrameSampleAdjusted;

  000b0	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000b3	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000b6	8b 88 18 03 00
	00		 mov	 ecx, DWORD PTR [eax+792]
  000bc	89 8a b8 03 00
	00		 mov	 DWORD PTR [edx+952], ecx

; 3085 :     else

  000c2	eb 1c		 jmp	 SHORT $L3187
$L3201:

; 3086 :     {
; 3087 :         pau->m_iDiscardSilence = pau->m_cSubFrameSampleHalfAdjusted;

  000c4	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000c7	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000ca	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  000d0	89 8a b8 03 00
	00		 mov	 DWORD PTR [edx+952], ecx

; 3088 :         pau->m_fSeekAdjustment = WMAB_TRUE;

  000d6	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000d9	c7 42 4c 01 00
	00 00		 mov	 DWORD PTR [edx+76], 1
$L3187:

; 3089 :     }
; 3090 : }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 04 00	 ret	 4
_prvInitDiscardSilence_XDS@4 ENDP
WMADEC	ENDS
EXTRN	_memmove:NEAR
; Function compile flags: /Odt
;	COMDAT _prvDiscardSilence_XDS@16
WMADEC	SEGMENT
_pau$ = 8
_pcSampleDecoded$ = 12
_iChannels$ = 16
_pbBuf$ = 20
_prvDiscardSilence_XDS@16 PROC NEAR			; COMDAT

; 3095 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3096 :     if (*pcSampleDecoded > pau->m_iDiscardSilence)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pcSampleDecoded$[ebp]
  00006	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00009	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0000c	3b 8a b8 03 00
	00		 cmp	 ecx, DWORD PTR [edx+952]
  00012	7e 60		 jle	 SHORT $L3212

; 3097 :     {
; 3098 :         // We decoded more than we intend to discard.
; 3099 :         // Discard samples and collapse remaining samples to start of buffer
; 3100 :         memmove(pbBuf, pbBuf + (pau->m_iDiscardSilence * iChannels),
; 3101 :             (*pcSampleDecoded - pau->m_iDiscardSilence) * iChannels);

  00014	8b 45 0c	 mov	 eax, DWORD PTR _pcSampleDecoded$[ebp]
  00017	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0001a	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0001d	2b 8a b8 03 00
	00		 sub	 ecx, DWORD PTR [edx+952]
  00023	0f b7 45 10	 movzx	 eax, WORD PTR _iChannels$[ebp]
  00027	0f af c8	 imul	 ecx, eax
  0002a	51		 push	 ecx
  0002b	0f b7 4d 10	 movzx	 ecx, WORD PTR _iChannels$[ebp]
  0002f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00032	8b 82 b8 03 00
	00		 mov	 eax, DWORD PTR [edx+952]
  00038	0f af c1	 imul	 eax, ecx
  0003b	8b 4d 14	 mov	 ecx, DWORD PTR _pbBuf$[ebp]
  0003e	03 c8		 add	 ecx, eax
  00040	51		 push	 ecx
  00041	8b 55 14	 mov	 edx, DWORD PTR _pbBuf$[ebp]
  00044	52		 push	 edx
  00045	e8 00 00 00 00	 call	 _memmove
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3102 :         *pcSampleDecoded -= (U16) pau->m_iDiscardSilence;

  0004d	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00050	0f b7 88 b8 03
	00 00		 movzx	 ecx, WORD PTR [eax+952]
  00057	8b 55 0c	 mov	 edx, DWORD PTR _pcSampleDecoded$[ebp]
  0005a	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0005d	2b c1		 sub	 eax, ecx
  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _pcSampleDecoded$[ebp]
  00062	66 89 01	 mov	 WORD PTR [ecx], ax

; 3103 :         pau->m_iDiscardSilence = 0;

  00065	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00068	c7 82 b8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+952], 0

; 3104 :     }
; 3105 :     else

  00072	eb 22		 jmp	 SHORT $L3211
$L3212:

; 3106 :     {
; 3107 :         // We intend to discard the entire output
; 3108 :         pau->m_iDiscardSilence -= *pcSampleDecoded;

  00074	8b 45 0c	 mov	 eax, DWORD PTR _pcSampleDecoded$[ebp]
  00077	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0007a	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0007d	8b 82 b8 03 00
	00		 mov	 eax, DWORD PTR [edx+952]
  00083	2b c1		 sub	 eax, ecx
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00088	89 81 b8 03 00
	00		 mov	 DWORD PTR [ecx+952], eax

; 3109 :         *pcSampleDecoded = 0;

  0008e	8b 55 0c	 mov	 edx, DWORD PTR _pcSampleDecoded$[ebp]
  00091	66 c7 02 00 00	 mov	 WORD PTR [edx], 0
$L3211:

; 3110 :     }
; 3111 : }

  00096	5d		 pop	 ebp
  00097	c2 10 00	 ret	 16			; 00000010H
_prvDiscardSilence_XDS@16 ENDP
WMADEC	ENDS
PUBLIC	_SetActualPower_XDS@16
; Function compile flags: /Odt
;	COMDAT _SetActualPower_XDS@16
WMADEC	SEGMENT
_i$ = -4
_piCoefQ$ = 8
_iCount$ = 12
_ppcinfo$ = 16
_codecStatus$ = 20
_SetActualPower_XDS@16 PROC NEAR			; COMDAT

; 3117 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3118 :     int i;
; 3119 : 
; 3120 :     ppcinfo->m_iActualPower = 0;

  00004	8b 45 10	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00007	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 3121 :     if (CODEC_BEGIN != codecStatus || 0 == ppcinfo->m_iPower || NULL == piCoefQ)

  0000e	83 7d 14 03	 cmp	 DWORD PTR _codecStatus$[ebp], 3
  00012	75 0f		 jne	 SHORT $L3227
  00014	8b 4d 10	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00017	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0001b	74 06		 je	 SHORT $L3227
  0001d	83 7d 08 00	 cmp	 DWORD PTR _piCoefQ$[ebp], 0
  00021	75 02		 jne	 SHORT $L3226
$L3227:

; 3122 :         return;

  00023	eb 36		 jmp	 SHORT $L3223
$L3226:

; 3123 : 
; 3124 :     for (i = 0; i < iCount; i++)

  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002c	eb 09		 jmp	 SHORT $L3228
$L3229:
  0002e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00031	83 c2 01	 add	 edx, 1
  00034	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L3228:
  00037	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003a	3b 45 0c	 cmp	 eax, DWORD PTR _iCount$[ebp]
  0003d	7d 1c		 jge	 SHORT $L3223

; 3125 :     {
; 3126 :         if (0 != piCoefQ[i])

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00042	8b 55 08	 mov	 edx, DWORD PTR _piCoefQ$[ebp]
  00045	0f bf 04 4a	 movsx	 eax, WORD PTR [edx+ecx*2]
  00049	85 c0		 test	 eax, eax
  0004b	74 0c		 je	 SHORT $L3231

; 3127 :         {
; 3128 :             ppcinfo->m_iActualPower = 1;

  0004d	8b 4d 10	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00050	c7 41 28 01 00
	00 00		 mov	 DWORD PTR [ecx+40], 1

; 3129 :             break;

  00057	eb 02		 jmp	 SHORT $L3223
$L3231:

; 3130 :         }
; 3131 :     }

  00059	eb d3		 jmp	 SHORT $L3229
$L3223:

; 3132 : }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 10 00	 ret	 16			; 00000010H
_SetActualPower_XDS@16 ENDP
WMADEC	ENDS
PUBLIC	_SetActualPowerHighRate_XDS@16
; Function compile flags: /Odt
;	COMDAT _SetActualPowerHighRate_XDS@16
WMADEC	SEGMENT
_i$ = -4
_piCoefRecon$ = 8
_iCount$ = 12
_ppcinfo$ = 16
_codecStatus$ = 20
_SetActualPowerHighRate_XDS@16 PROC NEAR		; COMDAT

; 3138 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3139 :     int i;
; 3140 : 
; 3141 :     ppcinfo->m_iActualPower = 0;

  00004	8b 45 10	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00007	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 3142 :     if (CODEC_BEGIN != codecStatus || 0 == ppcinfo->m_iPower || NULL == piCoefRecon)

  0000e	83 7d 14 03	 cmp	 DWORD PTR _codecStatus$[ebp], 3
  00012	75 0f		 jne	 SHORT $L3244
  00014	8b 4d 10	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00017	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0001b	74 06		 je	 SHORT $L3244
  0001d	83 7d 08 00	 cmp	 DWORD PTR _piCoefRecon$[ebp], 0
  00021	75 02		 jne	 SHORT $L3243
$L3244:

; 3143 :         return;

  00023	eb 34		 jmp	 SHORT $L3240
$L3243:

; 3144 : 
; 3145 :     for (i = 0; i < iCount; i++)

  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002c	eb 09		 jmp	 SHORT $L3245
$L3246:
  0002e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00031	83 c2 01	 add	 edx, 1
  00034	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L3245:
  00037	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003a	3b 45 0c	 cmp	 eax, DWORD PTR _iCount$[ebp]
  0003d	7d 1a		 jge	 SHORT $L3240

; 3146 :     {
; 3147 :         if (0 != piCoefRecon[i])

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00042	8b 55 08	 mov	 edx, DWORD PTR _piCoefRecon$[ebp]
  00045	83 3c 8a 00	 cmp	 DWORD PTR [edx+ecx*4], 0
  00049	74 0c		 je	 SHORT $L3248

; 3148 :         {
; 3149 :             ppcinfo->m_iActualPower = 1;

  0004b	8b 45 10	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  0004e	c7 40 28 01 00
	00 00		 mov	 DWORD PTR [eax+40], 1

; 3150 :             break;

  00055	eb 02		 jmp	 SHORT $L3240
$L3248:

; 3151 :         }
; 3152 :     }

  00057	eb d5		 jmp	 SHORT $L3246
$L3240:

; 3153 : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 10 00	 ret	 16			; 00000010H
_SetActualPowerHighRate_XDS@16 ENDP
WMADEC	ENDS
END
