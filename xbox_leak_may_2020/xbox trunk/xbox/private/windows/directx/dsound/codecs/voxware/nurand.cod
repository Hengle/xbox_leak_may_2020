; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\nurand.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DP@FGEECKEI@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@DCAPKKLN@plSeed?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@LKEMHNMB@?$CKplSeed?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _NuRand@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_NuRand@4
PUBLIC	??_C@_0DP@FGEECKEI@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0P@DCAPKKLN@plSeed?5?$CB?$DN?5NULL?$AA@	; `string'
PUBLIC	??_C@_0N@LKEMHNMB@?$CKplSeed?5?$CB?$DN?50?$AA@	; `string'
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0DP@FGEECKEI@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\nurand.c
CONST	SEGMENT
??_C@_0DP@FGEECKEI@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\nurand.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DCAPKKLN@plSeed?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0P@DCAPKKLN@plSeed?5?$CB?$DN?5NULL?$AA@ DB 'plSeed != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LKEMHNMB@?$CKplSeed?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0N@LKEMHNMB@?$CKplSeed?5?$CB?$DN?50?$AA@ DB '*plSeed != 0', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _NuRand@4
_TEXT	SEGMENT
_x0$ = -24
_A$ = -20
_x1$ = -16
_LONG_MASK$ = -12
_q$ = -8
_p$ = -4
_plSeed$ = 8
_NuRand@4 PROC NEAR					; COMDAT

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 71   :   const long A = 16807;

  00006	c7 45 ec a7 41
	00 00		 mov	 DWORD PTR _A$[ebp], 16807 ; 000041a7H

; 72   :   const unsigned long LONG_MASK = 0xFFFFFFFFL;

  0000d	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _LONG_MASK$[ebp], -1

; 73   :   unsigned long x0 = ((*plSeed<< 16)&LONG_MASK)>>16;  /* 16 LSBs OF SEED  */

  00014	8b 45 08	 mov	 eax, DWORD PTR _plSeed$[ebp]
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0001c	23 4d f4	 and	 ecx, DWORD PTR _LONG_MASK$[ebp]
  0001f	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00022	89 4d e8	 mov	 DWORD PTR _x0$[ebp], ecx

; 74   :   unsigned long x1 = *plSeed >> 16;                  /* 16 MSBs OF SEED   */

  00025	8b 55 08	 mov	 edx, DWORD PTR _plSeed$[ebp]
  00028	8b 02		 mov	 eax, DWORD PTR [edx]
  0002a	c1 f8 10	 sar	 eax, 16			; 00000010H
  0002d	89 45 f0	 mov	 DWORD PTR _x1$[ebp], eax

; 75   :   unsigned long p, q;                                /* MSW, LSW OF PRODUCT */
; 76   : 
; 77   :   assert(plSeed != NULL);

  00030	83 7d 08 00	 cmp	 DWORD PTR _plSeed$[ebp], 0
  00034	75 14		 jne	 SHORT $L967
  00036	6a 4d		 push	 77			; 0000004dH
  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@FGEECKEI@c?3?2xbox?2private?2windows?2directx?2@
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@DCAPKKLN@plSeed?5?$CB?$DN?5NULL?$AA@
  00042	e8 00 00 00 00	 call	 __assert
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
$L967:

; 78   :   assert(*plSeed != 0);

  0004a	8b 55 08	 mov	 edx, DWORD PTR _plSeed$[ebp]
  0004d	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00050	75 14		 jne	 SHORT $L968
  00052	6a 4e		 push	 78			; 0000004eH
  00054	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@FGEECKEI@c?3?2xbox?2private?2windows?2directx?2@
  00059	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@LKEMHNMB@?$CKplSeed?5?$CB?$DN?50?$AA@
  0005e	e8 00 00 00 00	 call	 __assert
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
$L968:

; 79   : 
; 80   :   /*---------------------------------------------------------------------*/
; 81   :   /* COMPUTE THE PRODUCT (A * lSeed) USING CROSS MULTIPLICATION OF        */
; 82   :   /* 16-BIT HALVES OF THE INPUT VALUES.  THE RESULT IS REPRESENTED AS 2  */
; 83   :   /* 31-BIT VALUES.  SINCE 'A' FITS IN 15 BITS, ITS UPPER HALF CAN BE    */
; 84   :   /* DISREGARDED.  USING THE NOTATION val[m::n] TO MEAN "BITS n THROUGH  */
; 85   :   /* m OF val", THE PRODUCT IS COMPUTED AS:                              */
; 86   :   /*   q = (A * x)[0::30]  = ((A * x1)[0::14] << 16) + (A * x0)[0::30]   */
; 87   :   /*   p = (A * x)[31::60] =  (A * x1)[15::30]       + (A * x0)[31]  + C */
; 88   :   /* WHERE C = q[31] (CARRY BIT FROM q).  NOTE THAT BECAUSE A < 2^15,    */
; 89   :   /* (A * x0)[31] IS ALWAYS 0.                                           */
; 90   :   /*---------------------------------------------------------------------*/
; 91   :   q = ((((A * x1) << 17) & LONG_MASK) >> 1) + (A * x0);

  00066	8b 4d ec	 mov	 ecx, DWORD PTR _A$[ebp]
  00069	0f af 4d f0	 imul	 ecx, DWORD PTR _x1$[ebp]
  0006d	c1 e1 11	 shl	 ecx, 17			; 00000011H
  00070	23 4d f4	 and	 ecx, DWORD PTR _LONG_MASK$[ebp]
  00073	d1 e9		 shr	 ecx, 1
  00075	8b 55 ec	 mov	 edx, DWORD PTR _A$[ebp]
  00078	0f af 55 e8	 imul	 edx, DWORD PTR _x0$[ebp]
  0007c	03 ca		 add	 ecx, edx
  0007e	89 4d f8	 mov	 DWORD PTR _q$[ebp], ecx

; 92   :   q = q & LONG_MASK;

  00081	8b 45 f8	 mov	 eax, DWORD PTR _q$[ebp]
  00084	23 45 f4	 and	 eax, DWORD PTR _LONG_MASK$[ebp]
  00087	89 45 f8	 mov	 DWORD PTR _q$[ebp], eax

; 93   :   p = ((A * x1) >> 15) + (q >> 31);

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _A$[ebp]
  0008d	0f af 4d f0	 imul	 ecx, DWORD PTR _x1$[ebp]
  00091	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  00094	8b 55 f8	 mov	 edx, DWORD PTR _q$[ebp]
  00097	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  0009a	03 ca		 add	 ecx, edx
  0009c	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx

; 94   :   p = p & LONG_MASK;

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  000a2	23 45 f4	 and	 eax, DWORD PTR _LONG_MASK$[ebp]
  000a5	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 95   :   q = ((q << 1) & LONG_MASK) >> 1;             /* CLEAR CARRY */

  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _q$[ebp]
  000ab	d1 e1		 shl	 ecx, 1
  000ad	23 4d f4	 and	 ecx, DWORD PTR _LONG_MASK$[ebp]
  000b0	d1 e9		 shr	 ecx, 1
  000b2	89 4d f8	 mov	 DWORD PTR _q$[ebp], ecx

; 96   : 
; 97   :   /*---------------------------------------------------------------------*/
; 98   :   /* IF (p + q) < 2^31, RESULT IS (p + q).  OTHERWISE, RESULT IS         */
; 99   :   /* (p + q) - 2^31 + 1.                                                 */
; 100  :   /*---------------------------------------------------------------------*/
; 101  :   p += q;

  000b5	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  000b8	03 55 f8	 add	 edx, DWORD PTR _q$[ebp]
  000bb	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx

; 102  :   p = p & LONG_MASK;

  000be	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  000c1	23 45 f4	 and	 eax, DWORD PTR _LONG_MASK$[ebp]
  000c4	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 
; 104  :   /* ADD CARRY, THEN CLEAR IT */
; 105  :   *plSeed = (((p + (p >> 31)) << 1) & LONG_MASK) >> 1;

  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  000ca	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000cd	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  000d0	03 d1		 add	 edx, ecx
  000d2	d1 e2		 shl	 edx, 1
  000d4	23 55 f4	 and	 edx, DWORD PTR _LONG_MASK$[ebp]
  000d7	d1 ea		 shr	 edx, 1
  000d9	8b 45 08	 mov	 eax, DWORD PTR _plSeed$[ebp]
  000dc	89 10		 mov	 DWORD PTR [eax], edx

; 106  : 
; 107  :   return *plSeed;

  000de	8b 4d 08	 mov	 ecx, DWORD PTR _plSeed$[ebp]
  000e1	8b 01		 mov	 eax, DWORD PTR [ecx]

; 108  : }

  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 04 00	 ret	 4
_NuRand@4 ENDP
_TEXT	ENDS
END
