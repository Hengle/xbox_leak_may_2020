; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\specint.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EA@MEOAAKKM@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@FDLCNLAP@iIntHarms?5?$DM?$DN?5?$CIint?$CJiMaxHarm?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@OLJLNJBM@pfAmp?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@NNAEFOFG@pfAmpInt?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@HBNHJDNN@fPitchInt?5?$DO?50?40F?5?$CG?$CG?5fPitch?5?$DO?50?40@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _SpecIntLn@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_SpecIntLn@24
PUBLIC	??_C@_0EA@MEOAAKKM@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BL@FDLCNLAP@iIntHarms?5?$DM?$DN?5?$CIint?$CJiMaxHarm?$AA@ ; `string'
PUBLIC	??_C@_0O@OLJLNJBM@pfAmp?5?$CB?$DN?5NULL?$AA@	; `string'
PUBLIC	??_C@_0BB@NNAEFOFG@pfAmpInt?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	??_C@_0CC@HBNHJDNN@fPitchInt?5?$DO?50?40F?5?$CG?$CG?5fPitch?5?$DO?50?40@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@4b800000
PUBLIC	__real@33800000
EXTRN	_memcpy:NEAR
EXTRN	_memset:NEAR
EXTRN	__assert:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_0EA@MEOAAKKM@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\specint.c
CONST	SEGMENT
??_C@_0EA@MEOAAKKM@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\specint.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FDLCNLAP@iIntHarms?5?$DM?$DN?5?$CIint?$CJiMaxHarm?$AA@
CONST	SEGMENT
??_C@_0BL@FDLCNLAP@iIntHarms?5?$DM?$DN?5?$CIint?$CJiMaxHarm?$AA@ DB 'iInt'
	DB	'Harms <= (int)iMaxHarm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OLJLNJBM@pfAmp?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0O@OLJLNJBM@pfAmp?5?$CB?$DN?5NULL?$AA@ DB 'pfAmp != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NNAEFOFG@pfAmpInt?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BB@NNAEFOFG@pfAmpInt?5?$CB?$DN?5NULL?$AA@ DB 'pfAmpInt != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0CC@HBNHJDNN@fPitchInt?5?$DO?50?40F?5?$CG?$CG?5fPitch?5?$DO?50?40@
CONST	SEGMENT
??_C@_0CC@HBNHJDNN@fPitchInt?5?$DO?50?40F?5?$CG?$CG?5fPitch?5?$DO?50?40@ DB 'f'
	DB	'PitchInt > 0.0F && fPitch > 0.0F', 00H	; `string'
CONST	ENDS
;	COMDAT __real@4b800000
CONST	SEGMENT
__real@4b800000 DD 04b800000r			; 1.67772e+007
CONST	ENDS
;	COMDAT __real@33800000
CONST	SEGMENT
__real@33800000 DD 033800000r			; 5.96046e-008
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _SpecIntLn@24
_TEXT	SEGMENT
tv198 = -40
tv185 = -32
_interp$ = -24
_harmsDone$ = -20
_harmNum$ = -16
_i$ = -12
_harmFactor$ = -8
_totalFactor$ = -4
_fPitch$ = 8
_fPitchInt$ = 12
_iIntHarms$ = 16
_pfAmp$ = 20
_pfAmpInt$ = 24
_iMaxHarm$ = 28
_SpecIntLn@24 PROC NEAR					; COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi

; 82   :    int           i, harmsDone;
; 83   :    float         interp;
; 84   :    int harmNum;
; 85   :    unsigned long harmFactor, totalFactor;
; 86   :    
; 87   :    /* error checking */
; 88   :    assert(iIntHarms <= (int)iMaxHarm);

  00007	8b 45 10	 mov	 eax, DWORD PTR _iIntHarms$[ebp]
  0000a	3b 45 1c	 cmp	 eax, DWORD PTR _iMaxHarm$[ebp]
  0000d	7e 14		 jle	 SHORT $L1000
  0000f	6a 58		 push	 88			; 00000058H
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@MEOAAKKM@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@FDLCNLAP@iIntHarms?5?$DM?$DN?5?$CIint?$CJiMaxHarm?$AA@
  0001b	e8 00 00 00 00	 call	 __assert
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1000:

; 89   :    assert(pfAmp != NULL);

  00023	83 7d 14 00	 cmp	 DWORD PTR _pfAmp$[ebp], 0
  00027	75 14		 jne	 SHORT $L1001
  00029	6a 59		 push	 89			; 00000059H
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@MEOAAKKM@c?3?2xbox?2private?2windows?2directx?2@
  00030	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@OLJLNJBM@pfAmp?5?$CB?$DN?5NULL?$AA@
  00035	e8 00 00 00 00	 call	 __assert
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1001:

; 90   :    assert(pfAmpInt != NULL);

  0003d	83 7d 18 00	 cmp	 DWORD PTR _pfAmpInt$[ebp], 0
  00041	75 14		 jne	 SHORT $L1002
  00043	6a 5a		 push	 90			; 0000005aH
  00045	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@MEOAAKKM@c?3?2xbox?2private?2windows?2directx?2@
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@NNAEFOFG@pfAmpInt?5?$CB?$DN?5NULL?$AA@
  0004f	e8 00 00 00 00	 call	 __assert
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1002:

; 91   :    assert(fPitchInt > 0.0F && fPitch > 0.0F);

  00057	d9 45 0c	 fld	 DWORD PTR _fPitchInt$[ebp]
  0005a	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00060	df e0		 fnstsw	 ax
  00062	f6 c4 41	 test	 ah, 65			; 00000041H
  00065	75 10		 jne	 SHORT $L1003
  00067	d9 45 08	 fld	 DWORD PTR _fPitch$[ebp]
  0006a	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00070	df e0		 fnstsw	 ax
  00072	f6 c4 41	 test	 ah, 65			; 00000041H
  00075	74 14		 je	 SHORT $L1004
$L1003:
  00077	6a 5b		 push	 91			; 0000005bH
  00079	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@MEOAAKKM@c?3?2xbox?2private?2windows?2directx?2@
  0007e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@HBNHJDNN@fPitchInt?5?$DO?50?40F?5?$CG?$CG?5fPitch?5?$DO?50?40@
  00083	e8 00 00 00 00	 call	 __assert
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1004:

; 92   : 
; 93   :    /* if iPitch==iPitchint Harmfactor==1 & interp==0.0  harmNum-1 == i 
; 94   :       there is no need to do interpolation. "for" loops are doing nothing. 
; 95   :       maximum value of harmNum could go up to MAXHARM which may cause 
; 96   :       pfAmpInt index out of boundary
; 97   :    */
; 98   :    if(fPitch != fPitchInt) {

  0008b	d9 45 08	 fld	 DWORD PTR _fPitch$[ebp]
  0008e	d8 5d 0c	 fcomp	 DWORD PTR _fPitchInt$[ebp]
  00091	df e0		 fnstsw	 ax
  00093	f6 c4 44	 test	 ah, 68			; 00000044H
  00096	0f 8b d9 00 00
	00		 jnp	 $L969

; 99   :       harmFactor=(unsigned long)VoxFLOORposLong((float)H_Q2P *(fPitch/fPitchInt));

  0009c	d9 45 08	 fld	 DWORD PTR _fPitch$[ebp]
  0009f	d8 75 0c	 fdiv	 DWORD PTR _fPitchInt$[ebp]
  000a2	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@4b800000
  000a8	e8 00 00 00 00	 call	 __ftol2
  000ad	89 45 f8	 mov	 DWORD PTR _harmFactor$[ebp], eax

; 100  :       totalFactor   = harmFactor;

  000b0	8b 55 f8	 mov	 edx, DWORD PTR _harmFactor$[ebp]
  000b3	89 55 fc	 mov	 DWORD PTR _totalFactor$[ebp], edx

; 101  :       harmsDone     = 0;

  000b6	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _harmsDone$[ebp], 0
$L976:

; 102  :       while (totalFactor <= H_Q2P)          

  000bd	81 7d fc 00 00
	00 01		 cmp	 DWORD PTR _totalFactor$[ebp], 16777216 ; 01000000H
  000c4	77 38		 ja	 SHORT $L977

; 103  :       {
; 104  :          pfAmpInt[harmsDone] = totalFactor*INVHQ2P*pfAmp[0];

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _totalFactor$[ebp]
  000c9	89 45 e0	 mov	 DWORD PTR tv185[ebp], eax
  000cc	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv185[ebp+4], 0
  000d3	df 6d e0	 fild	 QWORD PTR tv185[ebp]
  000d6	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@33800000
  000dc	8b 4d 14	 mov	 ecx, DWORD PTR _pfAmp$[ebp]
  000df	d8 09		 fmul	 DWORD PTR [ecx]
  000e1	8b 55 ec	 mov	 edx, DWORD PTR _harmsDone$[ebp]
  000e4	8b 45 18	 mov	 eax, DWORD PTR _pfAmpInt$[ebp]
  000e7	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]

; 105  :          harmsDone          ++; 

  000ea	8b 4d ec	 mov	 ecx, DWORD PTR _harmsDone$[ebp]
  000ed	83 c1 01	 add	 ecx, 1
  000f0	89 4d ec	 mov	 DWORD PTR _harmsDone$[ebp], ecx

; 106  :          totalFactor        += harmFactor;  

  000f3	8b 55 fc	 mov	 edx, DWORD PTR _totalFactor$[ebp]
  000f6	03 55 f8	 add	 edx, DWORD PTR _harmFactor$[ebp]
  000f9	89 55 fc	 mov	 DWORD PTR _totalFactor$[ebp], edx

; 107  :       }

  000fc	eb bf		 jmp	 SHORT $L976
$L977:

; 108  :       for (i=harmsDone; i<iIntHarms; i++)

  000fe	8b 45 ec	 mov	 eax, DWORD PTR _harmsDone$[ebp]
  00101	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  00104	eb 09		 jmp	 SHORT $L979
$L980:
  00106	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00109	83 c1 01	 add	 ecx, 1
  0010c	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$L979:
  0010f	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00112	3b 55 10	 cmp	 edx, DWORD PTR _iIntHarms$[ebp]
  00115	7d 5c		 jge	 SHORT $L981

; 109  :       {
; 110  :          harmNum      = (int)(totalFactor>>H_QFACTOR);

  00117	8b 45 fc	 mov	 eax, DWORD PTR _totalFactor$[ebp]
  0011a	c1 e8 18	 shr	 eax, 24			; 00000018H
  0011d	89 45 f0	 mov	 DWORD PTR _harmNum$[ebp], eax

; 111  :          interp       = (totalFactor&HMASK)*INVHQ2P;

  00120	8b 4d fc	 mov	 ecx, DWORD PTR _totalFactor$[ebp]
  00123	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00129	89 4d d8	 mov	 DWORD PTR tv198[ebp], ecx
  0012c	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv198[ebp+4], 0
  00133	df 6d d8	 fild	 QWORD PTR tv198[ebp]
  00136	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@33800000
  0013c	d9 5d e8	 fstp	 DWORD PTR _interp$[ebp]

; 112  :          pfAmpInt[i]  = pfAmp[harmNum-1] +
; 113  :                         (pfAmp[harmNum]-pfAmp[harmNum-1])*interp;

  0013f	8b 55 f0	 mov	 edx, DWORD PTR _harmNum$[ebp]
  00142	8b 45 14	 mov	 eax, DWORD PTR _pfAmp$[ebp]
  00145	8b 4d f0	 mov	 ecx, DWORD PTR _harmNum$[ebp]
  00148	8b 75 14	 mov	 esi, DWORD PTR _pfAmp$[ebp]
  0014b	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  0014e	d8 64 8e fc	 fsub	 DWORD PTR [esi+ecx*4-4]
  00152	d8 4d e8	 fmul	 DWORD PTR _interp$[ebp]
  00155	8b 55 f0	 mov	 edx, DWORD PTR _harmNum$[ebp]
  00158	8b 45 14	 mov	 eax, DWORD PTR _pfAmp$[ebp]
  0015b	d8 44 90 fc	 fadd	 DWORD PTR [eax+edx*4-4]
  0015f	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00162	8b 55 18	 mov	 edx, DWORD PTR _pfAmpInt$[ebp]
  00165	d9 1c 8a	 fstp	 DWORD PTR [edx+ecx*4]

; 114  :          totalFactor += harmFactor;

  00168	8b 45 fc	 mov	 eax, DWORD PTR _totalFactor$[ebp]
  0016b	03 45 f8	 add	 eax, DWORD PTR _harmFactor$[ebp]
  0016e	89 45 fc	 mov	 DWORD PTR _totalFactor$[ebp], eax

; 115  :       }

  00171	eb 93		 jmp	 SHORT $L980
$L981:

; 116  :    }
; 117  :    else 

  00173	eb 17		 jmp	 SHORT $L985
$L969:

; 118  :      memcpy(pfAmpInt, pfAmp, sizeof(float)*(iIntHarms));

  00175	8b 4d 10	 mov	 ecx, DWORD PTR _iIntHarms$[ebp]
  00178	c1 e1 02	 shl	 ecx, 2
  0017b	51		 push	 ecx
  0017c	8b 55 14	 mov	 edx, DWORD PTR _pfAmp$[ebp]
  0017f	52		 push	 edx
  00180	8b 45 18	 mov	 eax, DWORD PTR _pfAmpInt$[ebp]
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 _memcpy
  00189	83 c4 0c	 add	 esp, 12			; 0000000cH
$L985:

; 119  : 
; 120  :    memset(pfAmpInt+iIntHarms, 0, sizeof(float)*(iMaxHarm-iIntHarms));

  0018c	8b 4d 1c	 mov	 ecx, DWORD PTR _iMaxHarm$[ebp]
  0018f	2b 4d 10	 sub	 ecx, DWORD PTR _iIntHarms$[ebp]
  00192	c1 e1 02	 shl	 ecx, 2
  00195	51		 push	 ecx
  00196	6a 00		 push	 0
  00198	8b 55 10	 mov	 edx, DWORD PTR _iIntHarms$[ebp]
  0019b	8b 45 18	 mov	 eax, DWORD PTR _pfAmpInt$[ebp]
  0019e	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  001a1	51		 push	 ecx
  001a2	e8 00 00 00 00	 call	 _memset
  001a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 121  : }

  001aa	5e		 pop	 esi
  001ab	8b e5		 mov	 esp, ebp
  001ad	5d		 pop	 ebp
  001ae	c2 18 00	 ret	 24			; 00000018H
_SpecIntLn@24 ENDP
_TEXT	ENDS
END
