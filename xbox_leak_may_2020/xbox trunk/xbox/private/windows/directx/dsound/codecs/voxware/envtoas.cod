; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\envtoas.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _LogEnvelopeToAs@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_LogEnvelopeToAs@20
PUBLIC	__real@3f000000
EXTRN	_vox_nspsCcsFft@12:NEAR
EXTRN	_VoxDurbin@20:NEAR
EXTRN	_VoxWarpSC36@8:NEAR
EXTRN	__fltused:NEAR
EXTRN	_fLog2@4:NEAR
EXTRN	_fInvLog2@4:NEAR
EXTRN	_ScaleVector@16:NEAR
;	COMDAT __real@3f000000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\envtoas.c
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _LogEnvelopeToAs@20
_TEXT	SEGMENT
_j$ = -536
_iStride$ = -532
_fRs$ = -528
_fSigma$ = -8
_i$ = -4
_pfLogSeeEnv$ = 8
_iOrderAllpole$ = 12
_pfGain$ = 16
_pfAS$ = 20
_pfKS$ = 24
_LogEnvelopeToAs@20 PROC NEAR				; COMDAT

; 104  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H

; 105  :    int   i, j;
; 106  :    int   iStride;
; 107  :    float fSigma;
; 108  :    STACK_INIT
; 109  :    float fRs[DFFT+2];
; 110  :    STACK_INIT_END
; 111  :    STACK_ATTACH(float *,fRs) 
; 112  : 
; 113  :    STACK_START
; 114  : 
; 115  :    /*-----------------------------------------------------------------
; 116  :       Warp spectrum for better all-pole fit to low frequencies.
; 117  :    -----------------------------------------------------------------*/
; 118  :    VoxWarpSC36( pfLogSeeEnv, pfLogSeeEnv );

  00009	8b 45 08	 mov	 eax, DWORD PTR _pfLogSeeEnv$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pfLogSeeEnv$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _VoxWarpSC36@8

; 119  : 
; 120  :    /*-----------------------------------------------------------------
; 121  :       Down sample the log spline power envelope and place it in the
; 122  :         real part of the FFT buffer. Clear imaginary part of FFT buffer.
; 123  :    -----------------------------------------------------------------*/
; 124  :    iStride = 1 << DWNSMP;

  00016	c7 85 ec fd ff
	ff 04 00 00 00	 mov	 DWORD PTR _iStride$[ebp], 4

; 125  :    for (i=0, j=0; i<NFFT_2; i+=iStride, j+=2)

  00020	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00027	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  00031	eb 1b		 jmp	 SHORT $L1223
$L1224:
  00033	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00036	03 95 ec fd ff
	ff		 add	 edx, DWORD PTR _iStride$[ebp]
  0003c	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  0003f	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00045	83 c0 02	 add	 eax, 2
  00048	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _j$[ebp], eax
$L1223:
  0004e	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00055	7d 2f		 jge	 SHORT $L1225

; 126  :    {
; 127  :        fRs[j] = fInvLog2(pfLogSeeEnv[i]);

  00057	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0005a	8b 55 08	 mov	 edx, DWORD PTR _pfLogSeeEnv$[ebp]
  0005d	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 _fInvLog2@4
  00066	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  0006c	d9 9c 8d f0 fd
	ff ff		 fstp	 DWORD PTR _fRs$[ebp+ecx*4]

; 128  :        fRs[j+1] = 0.0F;

  00073	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00079	c7 84 95 f4 fd
	ff ff 00 00 00
	00		 mov	 DWORD PTR _fRs$[ebp+edx*4+4], 0

; 129  :    }

  00084	eb ad		 jmp	 SHORT $L1224
$L1225:

; 130  :    fRs[DFFT] = fInvLog2(pfLogSeeEnv[NFFT_2-1]); /* approximate value at PI */

  00086	8b 45 08	 mov	 eax, DWORD PTR _pfLogSeeEnv$[ebp]
  00089	8b 88 fc 03 00
	00		 mov	 ecx, DWORD PTR [eax+1020]
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 _fInvLog2@4
  00095	d9 5d f0	 fstp	 DWORD PTR _fRs$[ebp+512]

; 131  :    fRs[DFFT+1] = 0.0F;

  00098	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fRs$[ebp+516], 0

; 132  : 
; 133  :    /*-----------------------------------------------------------------
; 134  :       Compute autocorrelation function with inverse FFT.
; 135  :    -----------------------------------------------------------------*/
; 136  :    VoxRealInverseFft( fRs, DFFT_ORDER, IFFT_SCALE_FLAG);

  0009f	6a 02		 push	 2
  000a1	6a 07		 push	 7
  000a3	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR _fRs$[ebp]
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 _vox_nspsCcsFft@12

; 137  : 
; 138  :    /*-----------------------------------------------------------------
; 139  :      Apply the white noise scale factor to all but the first
; 140  :       autocorrelation coefficient.
; 141  :    -----------------------------------------------------------------*/
; 142  :    ScaleVector( &fRs[1], iOrderAllpole, WHITE_NOISE_SCALE, &fRs[1] );

  000af	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _fRs$[ebp+4]
  000b5	50		 push	 eax
  000b6	68 ef ff 7f 3f	 push	 1065353199		; 3f7fffefH
  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _iOrderAllpole$[ebp]
  000be	51		 push	 ecx
  000bf	8d 95 f4 fd ff
	ff		 lea	 edx, DWORD PTR _fRs$[ebp+4]
  000c5	52		 push	 edx
  000c6	e8 00 00 00 00	 call	 _ScaleVector@16

; 143  : 
; 144  :    /*-----------------------------------------------------------------
; 145  :       Compute the predictor coefficients and the reflection 
; 146  :        coefficients.
; 147  :    -----------------------------------------------------------------*/
; 148  :    VoxDurbin( fRs, iOrderAllpole, pfAS, pfKS, &fSigma);

  000cb	8d 45 f8	 lea	 eax, DWORD PTR _fSigma$[ebp]
  000ce	50		 push	 eax
  000cf	8b 4d 18	 mov	 ecx, DWORD PTR _pfKS$[ebp]
  000d2	51		 push	 ecx
  000d3	8b 55 14	 mov	 edx, DWORD PTR _pfAS$[ebp]
  000d6	52		 push	 edx
  000d7	8b 45 0c	 mov	 eax, DWORD PTR _iOrderAllpole$[ebp]
  000da	50		 push	 eax
  000db	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _fRs$[ebp]
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 _VoxDurbin@20

; 149  :    
; 150  :    /*-----------------------------------------------------------------
; 151  :       Use the prediction gain calculated within Durbin's recursion.
; 152  :    -----------------------------------------------------------------*/
; 153  :    *pfGain = 0.5F*fLog2(fSigma);

  000e7	8b 55 f8	 mov	 edx, DWORD PTR _fSigma$[ebp]
  000ea	52		 push	 edx
  000eb	e8 00 00 00 00	 call	 _fLog2@4
  000f0	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  000f6	8b 45 10	 mov	 eax, DWORD PTR _pfGain$[ebp]
  000f9	d9 18		 fstp	 DWORD PTR [eax]

; 154  : 
; 155  :    STACK_END
; 156  : 
; 157  : } /* LogEnvelopeToAs() */

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 14 00	 ret	 20			; 00000014H
_LogEnvelopeToAs@20 ENDP
_TEXT	ENDS
END
