; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\kstoas.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DP@MMPIMKDN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxKsToAs@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_VoxKsToAs@12
PUBLIC	??_C@_0DP@MMPIMKDN@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@ ; `string'
EXTRN	__assert:NEAR
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_0DP@MMPIMKDN@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\kstoas.c
CONST	SEGMENT
??_C@_0DP@MMPIMKDN@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\kstoas.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@
CONST	SEGMENT
??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@ DB 'iOrder <= MAX_'
	DB	'LPC_ORDER', 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxKsToAs@12
_TEXT	SEGMENT
_j$ = -104
_k$ = -100
_pfA_1$ = -96
_fK$ = -92
_i$ = -88
_pfSwap$ = -84
_fTemp1$ = -80
_pfKS$ = 8
_pfAS$ = 12
_iOrder$ = 16
_VoxKsToAs@12 PROC NEAR					; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H

; 74   :    float *pfA_1;              /* point to AS for previous iteration           */
; 75   :    float *pfSwap;             /* point for swapping the memory */
; 76   :    float fTemp1[MAX_LPC_ORDER+1]; /*%#  scratch memory #%*/
; 77   :    float fK;               /* reflection coefficient for current iteration */
; 78   :    int i, j, k;
; 79   : 
; 80   :    assert(iOrder <= MAX_LPC_ORDER);

  00006	83 7d 10 12	 cmp	 DWORD PTR _iOrder$[ebp], 18 ; 00000012H
  0000a	7e 14		 jle	 SHORT $L633
  0000c	6a 50		 push	 80			; 00000050H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@MMPIMKDN@c?3?2xbox?2private?2windows?2directx?2@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@
  00018	e8 00 00 00 00	 call	 __assert
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L633:

; 81   : 
; 82   :    pfAS[0] = 1.0F;

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _pfAS$[ebp]
  00023	c7 01 00 00 80
	3f		 mov	 DWORD PTR [ecx], 1065353216 ; 3f800000H

; 83   : 
; 84   :    /*-------------------------------------------------------
; 85   :      Set up pointers so that the predictor coefficients 
; 86   :      will be placed in their final location.
; 87   :    -------------------------------------------------------*/
; 88   :    if (iOrder&1)           /* an odd number of iterations */

  00029	8b 55 10	 mov	 edx, DWORD PTR _iOrder$[ebp]
  0002c	83 e2 01	 and	 edx, 1
  0002f	85 d2		 test	 edx, edx
  00031	74 0e		 je	 SHORT $L616

; 89   :    {
; 90   :       pfA_1 = pfAS;

  00033	8b 45 0c	 mov	 eax, DWORD PTR _pfAS$[ebp]
  00036	89 45 a0	 mov	 DWORD PTR _pfA_1$[ebp], eax

; 91   :       pfAS = fTemp1;      

  00039	8d 4d b0	 lea	 ecx, DWORD PTR _fTemp1$[ebp]
  0003c	89 4d 0c	 mov	 DWORD PTR _pfAS$[ebp], ecx

; 92   :    }
; 93   :    else                    /* an even number of iterations */

  0003f	eb 06		 jmp	 SHORT $L617
$L616:

; 94   :    {
; 95   :       pfA_1 = fTemp1;

  00041	8d 55 b0	 lea	 edx, DWORD PTR _fTemp1$[ebp]
  00044	89 55 a0	 mov	 DWORD PTR _pfA_1$[ebp], edx
$L617:

; 96   :    }
; 97   :   
; 98   :    /*---------------------
; 99   :       Do the interation.
; 100  :    ---------------------*/
; 101  :    for (i=0;i<iOrder; i++)

  00047	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004e	eb 09		 jmp	 SHORT $L618
$L619:
  00050	8b 45 a8	 mov	 eax, DWORD PTR _i$[ebp]
  00053	83 c0 01	 add	 eax, 1
  00056	89 45 a8	 mov	 DWORD PTR _i$[ebp], eax
$L618:
  00059	8b 4d a8	 mov	 ecx, DWORD PTR _i$[ebp]
  0005c	3b 4d 10	 cmp	 ecx, DWORD PTR _iOrder$[ebp]
  0005f	7d 7b		 jge	 SHORT $L605

; 102  :    {
; 103  :       pfSwap = pfAS;   /* swap pfA with pfA_1 */

  00061	8b 55 0c	 mov	 edx, DWORD PTR _pfAS$[ebp]
  00064	89 55 ac	 mov	 DWORD PTR _pfSwap$[ebp], edx

; 104  :       pfAS = pfA_1;

  00067	8b 45 a0	 mov	 eax, DWORD PTR _pfA_1$[ebp]
  0006a	89 45 0c	 mov	 DWORD PTR _pfAS$[ebp], eax

; 105  :       pfA_1 = pfSwap;

  0006d	8b 4d ac	 mov	 ecx, DWORD PTR _pfSwap$[ebp]
  00070	89 4d a0	 mov	 DWORD PTR _pfA_1$[ebp], ecx

; 106  : 
; 107  :       fK =  pfKS[i];  /* get (i+1)th reflection coefficient */

  00073	8b 55 a8	 mov	 edx, DWORD PTR _i$[ebp]
  00076	8b 45 08	 mov	 eax, DWORD PTR _pfKS$[ebp]
  00079	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  0007c	89 4d a4	 mov	 DWORD PTR _fK$[ebp], ecx

; 108  :       /*------------------------------------------------------
; 109  :          Compute (i+1)th order predictor coefficients
; 110  :       ------------------------------------------------------*/
; 111  :       pfAS[i+1] = -fK;

  0007f	d9 45 a4	 fld	 DWORD PTR _fK$[ebp]
  00082	d9 e0		 fchs
  00084	8b 55 a8	 mov	 edx, DWORD PTR _i$[ebp]
  00087	8b 45 0c	 mov	 eax, DWORD PTR _pfAS$[ebp]
  0008a	d9 5c 90 04	 fstp	 DWORD PTR [eax+edx*4+4]

; 112  :       for (j=1, k=i; j<=i; j++, k--)

  0008e	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _j$[ebp], 1
  00095	8b 4d a8	 mov	 ecx, DWORD PTR _i$[ebp]
  00098	89 4d 9c	 mov	 DWORD PTR _k$[ebp], ecx
  0009b	eb 12		 jmp	 SHORT $L621
$L622:
  0009d	8b 55 98	 mov	 edx, DWORD PTR _j$[ebp]
  000a0	83 c2 01	 add	 edx, 1
  000a3	89 55 98	 mov	 DWORD PTR _j$[ebp], edx
  000a6	8b 45 9c	 mov	 eax, DWORD PTR _k$[ebp]
  000a9	83 e8 01	 sub	 eax, 1
  000ac	89 45 9c	 mov	 DWORD PTR _k$[ebp], eax
$L621:
  000af	8b 4d 98	 mov	 ecx, DWORD PTR _j$[ebp]
  000b2	3b 4d a8	 cmp	 ecx, DWORD PTR _i$[ebp]
  000b5	7f 20		 jg	 SHORT $L623

; 113  :          pfAS[j] = pfA_1[j] - fK*pfA_1[k];

  000b7	8b 55 9c	 mov	 edx, DWORD PTR _k$[ebp]
  000ba	8b 45 a0	 mov	 eax, DWORD PTR _pfA_1$[ebp]
  000bd	d9 45 a4	 fld	 DWORD PTR _fK$[ebp]
  000c0	d8 0c 90	 fmul	 DWORD PTR [eax+edx*4]
  000c3	8b 4d 98	 mov	 ecx, DWORD PTR _j$[ebp]
  000c6	8b 55 a0	 mov	 edx, DWORD PTR _pfA_1$[ebp]
  000c9	d8 2c 8a	 fsubr	 DWORD PTR [edx+ecx*4]
  000cc	8b 45 98	 mov	 eax, DWORD PTR _j$[ebp]
  000cf	8b 4d 0c	 mov	 ecx, DWORD PTR _pfAS$[ebp]
  000d2	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
  000d5	eb c6		 jmp	 SHORT $L622
$L623:

; 114  :    }

  000d7	e9 74 ff ff ff	 jmp	 $L619
$L605:

; 115  : }

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 0c 00	 ret	 12			; 0000000cH
_VoxKsToAs@12 ENDP
_TEXT	ENDS
END
