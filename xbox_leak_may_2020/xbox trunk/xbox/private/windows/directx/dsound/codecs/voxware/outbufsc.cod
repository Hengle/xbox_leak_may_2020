; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\outbufsc.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EB@ELJBMKPN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@HOHAKFEP@iSaveSamples?5?$DM?$DN?5HALF_FRAME_LENGT@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@EJGCPNJL@?$CIpfSaveBuffer?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpsPCM@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EA@IGBPMFKN@?$CIpfSaveBuffer?$CB?$DNNULL?$CJ?$CG?$CG?$CIpsPCMBuff@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _PreOutputManagerSC@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _PostOutputManagerSC@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_PreOutputManagerSC@12
PUBLIC	??_C@_0EB@ELJBMKPN@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CF@HOHAKFEP@iSaveSamples?5?$DM?$DN?5HALF_FRAME_LENGT@ ; `string'
PUBLIC	??_C@_0DA@EJGCPNJL@?$CIpfSaveBuffer?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpsPCM@ ; `string'
EXTRN	__assert:NEAR
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_0EB@ELJBMKPN@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\outbufsc.c
CONST	SEGMENT
??_C@_0EB@ELJBMKPN@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\outbufsc.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HOHAKFEP@iSaveSamples?5?$DM?$DN?5HALF_FRAME_LENGT@
CONST	SEGMENT
??_C@_0CF@HOHAKFEP@iSaveSamples?5?$DM?$DN?5HALF_FRAME_LENGT@ DB 'iSaveSam'
	DB	'ples <= HALF_FRAME_LENGTH_SC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@EJGCPNJL@?$CIpfSaveBuffer?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpsPCM@
CONST	SEGMENT
??_C@_0DA@EJGCPNJL@?$CIpfSaveBuffer?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpsPCM@ DB '('
	DB	'pfSaveBuffer != NULL) && (psPCMBuffer != NULL)', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _PreOutputManagerSC@12
_TEXT	SEGMENT
_ftmp$ = -12
_i$ = -8
_iTemp$ = -4
_pfSaveBuffer$ = 8
_iSaveSamples$ = 12
_psPCMBuffer$ = 16
_PreOutputManagerSC@12 PROC NEAR			; COMDAT

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 67   :   int i;
; 68   :   int iTemp; 
; 69   :   float ftmp;
; 70   : 
; 71   :   assert(iSaveSamples <= HALF_FRAME_LENGTH_SC);

  00006	83 7d 0c 50	 cmp	 DWORD PTR _iSaveSamples$[ebp], 80 ; 00000050H
  0000a	7e 14		 jle	 SHORT $L1298
  0000c	6a 47		 push	 71			; 00000047H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@ELJBMKPN@c?3?2xbox?2private?2windows?2directx?2@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@HOHAKFEP@iSaveSamples?5?$DM?$DN?5HALF_FRAME_LENGT@
  00018	e8 00 00 00 00	 call	 __assert
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1298:

; 72   :   assert((pfSaveBuffer != NULL) && (psPCMBuffer != NULL));

  00020	83 7d 08 00	 cmp	 DWORD PTR _pfSaveBuffer$[ebp], 0
  00024	74 06		 je	 SHORT $L1299
  00026	83 7d 10 00	 cmp	 DWORD PTR _psPCMBuffer$[ebp], 0
  0002a	75 14		 jne	 SHORT $L1300
$L1299:
  0002c	6a 48		 push	 72			; 00000048H
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@ELJBMKPN@c?3?2xbox?2private?2windows?2directx?2@
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DA@EJGCPNJL@?$CIpfSaveBuffer?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpsPCM@
  00038	e8 00 00 00 00	 call	 __assert
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1300:

; 73   : 
; 74   :   /*--------------------------------------------------
; 75   :     Copy pfSaveBuffer to psPCMBuffer.
; 76   :     --------------------------------------------------*/
; 77   :   for (i = 0; i < iSaveSamples; i++) {

  00040	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00047	eb 09		 jmp	 SHORT $L1247
$L1248:
  00049	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0004c	83 c2 01	 add	 edx, 1
  0004f	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L1247:
  00052	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00055	3b 45 0c	 cmp	 eax, DWORD PTR _iSaveSamples$[ebp]
  00058	7d 22		 jge	 SHORT $L1236

; 78   :     ftmp = pfSaveBuffer[i];

  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0005d	8b 55 08	 mov	 edx, DWORD PTR _pfSaveBuffer$[ebp]
  00060	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00063	89 45 f4	 mov	 DWORD PTR _ftmp$[ebp], eax

; 79   :     VoxROUND2(ftmp, iTemp);

  00066	d9 45 f4	 fld	 DWORD PTR _ftmp$[ebp]
  00069	db 5d fc	 fistp	 DWORD PTR _iTemp$[ebp]

; 80   :     psPCMBuffer[i] = (short)iTemp;

  0006c	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0006f	8b 55 10	 mov	 edx, DWORD PTR _psPCMBuffer$[ebp]
  00072	66 8b 45 fc	 mov	 ax, WORD PTR _iTemp$[ebp]
  00076	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 81   :   }

  0007a	eb cd		 jmp	 SHORT $L1248
$L1236:

; 82   : }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 0c 00	 ret	 12			; 0000000cH
_PreOutputManagerSC@12 ENDP
_TEXT	ENDS
PUBLIC	_PostOutputManagerSC@20
PUBLIC	??_C@_0EA@IGBPMFKN@?$CIpfSaveBuffer?$CB?$DNNULL?$CJ?$CG?$CG?$CIpsPCMBuff@ ; `string'
EXTRN	_memcpy:NEAR
;	COMDAT ??_C@_0EA@IGBPMFKN@?$CIpfSaveBuffer?$CB?$DNNULL?$CJ?$CG?$CG?$CIpsPCMBuff@
CONST	SEGMENT
??_C@_0EA@IGBPMFKN@?$CIpfSaveBuffer?$CB?$DNNULL?$CJ?$CG?$CG?$CIpsPCMBuff@ DB '('
	DB	'pfSaveBuffer!=NULL)&&(psPCMBuffer!=NULL)&&(pwPCMsamples!=NULL'
	DB	')', 00H					; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _PostOutputManagerSC@20
_TEXT	SEGMENT
tv145 = -28
_ftmp$ = -24
_iSaveSamples$ = -20
_iWriteSamples$ = -16
_i$ = -12
_iTemp$ = -8
_psTemp$ = -4
_pfSaveBuffer$ = 8
_piSaveSamples$ = 12
_iSynSamples$ = 16
_psPCMBuffer$ = 20
_pwPCMsamples$ = 24
_PostOutputManagerSC@20 PROC NEAR			; COMDAT

; 124  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 125  :   int i;
; 126  :   int iSaveSamples = *piSaveSamples;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _piSaveSamples$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d ec	 mov	 DWORD PTR _iSaveSamples$[ebp], ecx

; 127  :   int iWriteSamples;
; 128  :   short *psTemp;
; 129  :   int iTemp;
; 130  :   float ftmp;
; 131  : 
; 132  :   assert(iSaveSamples <= HALF_FRAME_LENGTH_SC);

  0000e	83 7d ec 50	 cmp	 DWORD PTR _iSaveSamples$[ebp], 80 ; 00000050H
  00012	7e 17		 jle	 SHORT $L1305
  00014	68 84 00 00 00	 push	 132			; 00000084H
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@ELJBMKPN@c?3?2xbox?2private?2windows?2directx?2@
  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@HOHAKFEP@iSaveSamples?5?$DM?$DN?5HALF_FRAME_LENGT@
  00023	e8 00 00 00 00	 call	 __assert
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1305:

; 133  :   assert((pfSaveBuffer!=NULL)&&(psPCMBuffer!=NULL)&&(pwPCMsamples!=NULL));

  0002b	83 7d 08 00	 cmp	 DWORD PTR _pfSaveBuffer$[ebp], 0
  0002f	74 0c		 je	 SHORT $L1306
  00031	83 7d 14 00	 cmp	 DWORD PTR _psPCMBuffer$[ebp], 0
  00035	74 06		 je	 SHORT $L1306
  00037	83 7d 18 00	 cmp	 DWORD PTR _pwPCMsamples$[ebp], 0
  0003b	75 17		 jne	 SHORT $L1307
$L1306:
  0003d	68 85 00 00 00	 push	 133			; 00000085H
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@ELJBMKPN@c?3?2xbox?2private?2windows?2directx?2@
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@IGBPMFKN@?$CIpfSaveBuffer?$CB?$DNNULL?$CJ?$CG?$CG?$CIpsPCMBuff@
  0004c	e8 00 00 00 00	 call	 __assert
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1307:

; 134  : 
; 135  :   /*----------------------------------------------------------------------
; 136  :     Case 1: When sum of iSaveSamples and iSynSamples is less than 
; 137  :             FRAME_LENGTH_SC, write_flag is set to 0. 
; 138  :             Then speech should not output to PCMBuffer. 
; 139  :             Such as: iSaveSamples = 0,  iSynSamples = 0 or 80.
; 140  :                      iSaveSamples = 80, iSynSamples = 0
; 141  :    ----------------------------------------------------------------------*/
; 142  :    if ((iSaveSamples+iSynSamples) < FRAME_LENGTH_SC) 

  00054	8b 4d ec	 mov	 ecx, DWORD PTR _iSaveSamples$[ebp]
  00057	03 4d 10	 add	 ecx, DWORD PTR _iSynSamples$[ebp]
  0005a	81 f9 a0 00 00
	00		 cmp	 ecx, 160		; 000000a0H
  00060	7d 50		 jge	 SHORT $L1274

; 143  :      {
; 144  :        *pwPCMsamples = 0;

  00062	8b 55 18	 mov	 edx, DWORD PTR _pwPCMsamples$[ebp]
  00065	66 c7 02 00 00	 mov	 WORD PTR [edx], 0

; 145  : 
; 146  :        /*------------------------------------------------------------
; 147  :          Since pfSynBuffer shares with pfSaveBuffer, we need to make 
; 148  :          sure that pfSaveBuffer won't share with other memory. 
; 149  :          Otherwise, speech in PCMBuffer need be re-written
; 150  :          to pfSaveBuffer if iSaveSamples is larger than 0.
; 151  : 
; 152  :          Such as iSaveSamples = 80, iSynSamples = 0;
; 153  :         ------------------------------------------------------------*/
; 154  :        for (i = 0; i < iSaveSamples; i++)

  0006a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00071	eb 09		 jmp	 SHORT $L1275
$L1276:
  00073	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00076	83 c0 01	 add	 eax, 1
  00079	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$L1275:
  0007c	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0007f	3b 4d ec	 cmp	 ecx, DWORD PTR _iSaveSamples$[ebp]
  00082	7d 1b		 jge	 SHORT $L1277

; 155  :           pfSaveBuffer[i] = (float)psPCMBuffer[i];

  00084	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00087	8b 45 14	 mov	 eax, DWORD PTR _psPCMBuffer$[ebp]
  0008a	0f bf 0c 50	 movsx	 ecx, WORD PTR [eax+edx*2]
  0008e	89 4d e4	 mov	 DWORD PTR tv145[ebp], ecx
  00091	db 45 e4	 fild	 DWORD PTR tv145[ebp]
  00094	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00097	8b 45 08	 mov	 eax, DWORD PTR _pfSaveBuffer$[ebp]
  0009a	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]
  0009d	eb d4		 jmp	 SHORT $L1276
$L1277:

; 156  : 
; 157  :        if (iSynSamples > iSaveSamples)

  0009f	8b 4d 10	 mov	 ecx, DWORD PTR _iSynSamples$[ebp]
  000a2	3b 4d ec	 cmp	 ecx, DWORD PTR _iSaveSamples$[ebp]
  000a5	7e 06		 jle	 SHORT $L1279

; 158  :          iSaveSamples = iSynSamples;

  000a7	8b 55 10	 mov	 edx, DWORD PTR _iSynSamples$[ebp]
  000aa	89 55 ec	 mov	 DWORD PTR _iSaveSamples$[ebp], edx
$L1279:

; 159  :      }
; 160  :    else

  000ad	e9 81 00 00 00	 jmp	 $L1280
$L1274:

; 161  :      {
; 162  :         /*----------------------------------------------------------------------
; 163  :          Case 2: If sum of iSaveSamples and iSynSamples is larger or equal to 
; 164  :              FRAME_LENGTH_SC, one frame of speech will be output to PCMBuffer.
; 165  :              such as: iSaveSamples = 80, iSynSamples = 80 or 160,
; 166  :                       iSaveSamples = 0, iSynSamples = 160.
; 167  :          ---------------------------------------------------------------------*/
; 168  :         *pwPCMsamples = FRAME_LENGTH_SC;

  000b2	8b 45 18	 mov	 eax, DWORD PTR _pwPCMsamples$[ebp]
  000b5	66 c7 00 a0 00	 mov	 WORD PTR [eax], 160	; 000000a0H

; 169  : 
; 170  :         psTemp = &(psPCMBuffer[iSaveSamples]);    

  000ba	8b 4d ec	 mov	 ecx, DWORD PTR _iSaveSamples$[ebp]
  000bd	8b 55 14	 mov	 edx, DWORD PTR _psPCMBuffer$[ebp]
  000c0	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000c3	89 45 fc	 mov	 DWORD PTR _psTemp$[ebp], eax

; 171  :         iWriteSamples = FRAME_LENGTH_SC - iSaveSamples;

  000c6	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  000cb	2b 4d ec	 sub	 ecx, DWORD PTR _iSaveSamples$[ebp]
  000ce	89 4d f0	 mov	 DWORD PTR _iWriteSamples$[ebp], ecx

; 172  :         for (i = 0; i < iWriteSamples; i++) {

  000d1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000d8	eb 09		 jmp	 SHORT $L1281
$L1282:
  000da	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000dd	83 c2 01	 add	 edx, 1
  000e0	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
$L1281:
  000e3	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000e6	3b 45 f0	 cmp	 eax, DWORD PTR _iWriteSamples$[ebp]
  000e9	7d 22		 jge	 SHORT $L1283

; 173  :           ftmp = pfSaveBuffer[i];

  000eb	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000ee	8b 55 08	 mov	 edx, DWORD PTR _pfSaveBuffer$[ebp]
  000f1	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  000f4	89 45 e8	 mov	 DWORD PTR _ftmp$[ebp], eax

; 174  :           VoxROUND2(ftmp, iTemp);

  000f7	d9 45 e8	 fld	 DWORD PTR _ftmp$[ebp]
  000fa	db 5d f8	 fistp	 DWORD PTR _iTemp$[ebp]

; 175  :           psTemp[i] = (short)iTemp;

  000fd	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00100	8b 55 fc	 mov	 edx, DWORD PTR _psTemp$[ebp]
  00103	66 8b 45 f8	 mov	 ax, WORD PTR _iTemp$[ebp]
  00107	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 176  : 	}

  0010b	eb cd		 jmp	 SHORT $L1282
$L1283:

; 177  : 
; 178  : 
; 179  :         /*------------------------------------------------------------
; 180  :           If sum of iSaveSamples and iSynSamples is larger than 
; 181  :           FRAME_LENGTH_SC, such as iSaveSamples = 80, iSynSamples = 160, 
; 182  :           the extra 80 samples in pfSaveBuffer need to be shuffled to 
; 183  :           the beginning.
; 184  :          ------------------------------------------------------------*/
; 185  :         iSaveSamples = iSynSamples - iWriteSamples;

  0010d	8b 4d 10	 mov	 ecx, DWORD PTR _iSynSamples$[ebp]
  00110	2b 4d f0	 sub	 ecx, DWORD PTR _iWriteSamples$[ebp]
  00113	89 4d ec	 mov	 DWORD PTR _iSaveSamples$[ebp], ecx

; 186  :         memcpy(pfSaveBuffer, &(pfSaveBuffer[iWriteSamples]), 
; 187  :                iSaveSamples*sizeof(float));

  00116	8b 55 ec	 mov	 edx, DWORD PTR _iSaveSamples$[ebp]
  00119	c1 e2 02	 shl	 edx, 2
  0011c	52		 push	 edx
  0011d	8b 45 f0	 mov	 eax, DWORD PTR _iWriteSamples$[ebp]
  00120	8b 4d 08	 mov	 ecx, DWORD PTR _pfSaveBuffer$[ebp]
  00123	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00126	52		 push	 edx
  00127	8b 45 08	 mov	 eax, DWORD PTR _pfSaveBuffer$[ebp]
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _memcpy
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1280:

; 188  :      }
; 189  : 
; 190  :     *piSaveSamples = iSaveSamples;

  00133	8b 4d 0c	 mov	 ecx, DWORD PTR _piSaveSamples$[ebp]
  00136	8b 55 ec	 mov	 edx, DWORD PTR _iSaveSamples$[ebp]
  00139	89 11		 mov	 DWORD PTR [ecx], edx

; 191  : }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 14 00	 ret	 20			; 00000014H
_PostOutputManagerSC@20 ENDP
_TEXT	ENDS
END
