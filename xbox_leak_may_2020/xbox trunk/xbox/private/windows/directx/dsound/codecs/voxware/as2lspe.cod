; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\as2lspe.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EA@OCKFNFGO@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04KLAIINDA@pfAs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05FGOOPLEI@pfLSP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@LJCJBAAK@?$CB?$CIiOrder?$CG1?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxAsToLspEven@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxCompRedPoly@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxDIDeven@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _iFindRoot@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxSetArbitraryLSP@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SolveQuad@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	??_C@_0EA@OCKFNFGO@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_04KLAIINDA@pfAs?$AA@			; `string'
PUBLIC	??_C@_05FGOOPLEI@pfLSP?$AA@			; `string'
PUBLIC	??_C@_0M@LJCJBAAK@?$CB?$CIiOrder?$CG1?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@40000000
PUBLIC	__real@c0000000
PUBLIC	__real@3e22f983
PUBLIC	__real@3f000000
PUBLIC	_VoxAsToLspEven@16
EXTRN	__fltused:NEAR
EXTRN	_acos:NEAR
EXTRN	_memcpy:NEAR
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0EA@OCKFNFGO@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\as2lspe.c
CONST	SEGMENT
??_C@_0EA@OCKFNFGO@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\as2lspe.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04KLAIINDA@pfAs?$AA@
CONST	SEGMENT
??_C@_04KLAIINDA@pfAs?$AA@ DB 'pfAs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FGOOPLEI@pfLSP?$AA@
CONST	SEGMENT
??_C@_05FGOOPLEI@pfLSP?$AA@ DB 'pfLSP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LJCJBAAK@?$CB?$CIiOrder?$CG1?$CJ?$AA@
CONST	SEGMENT
??_C@_0M@LJCJBAAK@?$CB?$CIiOrder?$CG1?$CJ?$AA@ DB '!(iOrder&1)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@
CONST	SEGMENT
??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@ DB 'iOrder <= MAX_'
	DB	'LPC_ORDER', 00H				; `string'
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@3e22f983
CONST	SEGMENT
__real@3e22f983 DD 03e22f983r			; 0.159155
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxAsToLspEven@16
_TEXT	SEGMENT
tv403 = -236
_j$ = -232
_iDegree$ = -228
_fRP$ = -224
_fRoot$ = -184
_iQuadRootFlag$ = -180
_fDQ$ = -176
_fQuadRootsD$ = -136
_fScale$ = -120
_pfTemp$ = -116
_iOrder2$ = -112
_fRQ$ = -108
_fDP$ = -68
_i$ = -28
_iMinDegree$ = -24
_iStatus$ = -20
_fQuadRootsQ$ = -16
_pfAs$ = 8
_iOrder$ = 12
_fScaleFactor$ = 16
_pfLSP$ = 20
_VoxAsToLspEven@16 PROC NEAR				; COMDAT

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	56		 push	 esi

; 191  :    int    i, j;
; 192  :    int    iDegree;
; 193  :    int    iOrder2;
; 194  :    int    iStatus = SUCCESS;

  0000a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iStatus$[ebp], 0

; 195  :    int    iQuadRootFlag;
; 196  :    int    iMinDegree;
; 197  :    float  fRoot;
; 198  :    float  fScale;
; 199  :    float *pfTemp;
; 200  :    float  fRP[(MAX_LPC_ORDER>>1)+1];
; 201  :    float  fRQ[(MAX_LPC_ORDER>>1)+1];
; 202  :    float  fDP[(MAX_LPC_ORDER>>1)+1];
; 203  :    float  fDQ[(MAX_LPC_ORDER>>1)+1];
; 204  :    float  fQuadRootsD[4];
; 205  :    float  fQuadRootsQ[4];
; 206  : 
; 207  :    assert( pfAs );

  00011	83 7d 08 00	 cmp	 DWORD PTR _pfAs$[ebp], 0
  00015	75 17		 jne	 SHORT $L1216
  00017	68 cf 00 00 00	 push	 207			; 000000cfH
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@OCKFNFGO@c?3?2xbox?2private?2windows?2directx?2@
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04KLAIINDA@pfAs?$AA@
  00026	e8 00 00 00 00	 call	 __assert
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1216:

; 208  :    assert( pfLSP );

  0002e	83 7d 14 00	 cmp	 DWORD PTR _pfLSP$[ebp], 0
  00032	75 17		 jne	 SHORT $L1217
  00034	68 d0 00 00 00	 push	 208			; 000000d0H
  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@OCKFNFGO@c?3?2xbox?2private?2windows?2directx?2@
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05FGOOPLEI@pfLSP?$AA@
  00043	e8 00 00 00 00	 call	 __assert
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1217:

; 209  :    assert( !(iOrder&1) );             /* model order must be even!  */

  0004b	8b 55 0c	 mov	 edx, DWORD PTR _iOrder$[ebp]
  0004e	83 e2 01	 and	 edx, 1
  00051	85 d2		 test	 edx, edx
  00053	74 17		 je	 SHORT $L1218
  00055	68 d1 00 00 00	 push	 209			; 000000d1H
  0005a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@OCKFNFGO@c?3?2xbox?2private?2windows?2directx?2@
  0005f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@LJCJBAAK@?$CB?$CIiOrder?$CG1?$CJ?$AA@
  00064	e8 00 00 00 00	 call	 __assert
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1218:

; 210  :    assert( iOrder <= MAX_LPC_ORDER ); /* don't exceed MAX_LPC_ORDER */

  0006c	83 7d 0c 12	 cmp	 DWORD PTR _iOrder$[ebp], 18 ; 00000012H
  00070	7e 17		 jle	 SHORT $L1219
  00072	68 d2 00 00 00	 push	 210			; 000000d2H
  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@OCKFNFGO@c?3?2xbox?2private?2windows?2directx?2@
  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@
  00081	e8 00 00 00 00	 call	 __assert
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1219:

; 211  : 
; 212  :    if ((iOrder>MAX_QUAD_ROOT_ORDER) || (iOrder<8))

  00089	83 7d 0c 0e	 cmp	 DWORD PTR _iOrder$[ebp], 14 ; 0000000eH
  0008d	7f 06		 jg	 SHORT $L1056
  0008f	83 7d 0c 08	 cmp	 DWORD PTR _iOrder$[ebp], 8
  00093	7d 0c		 jge	 SHORT $L1055
$L1056:

; 213  :       iQuadRootFlag = 0;

  00095	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _iQuadRootFlag$[ebp], 0

; 214  :    else

  0009f	eb 0a		 jmp	 SHORT $L1057
$L1055:

; 215  :       iQuadRootFlag = 1;

  000a1	c7 85 4c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _iQuadRootFlag$[ebp], 1
$L1057:

; 216  : 
; 217  :    iOrder2 = iOrder>>1;

  000ab	8b 55 0c	 mov	 edx, DWORD PTR _iOrder$[ebp]
  000ae	d1 fa		 sar	 edx, 1
  000b0	89 55 90	 mov	 DWORD PTR _iOrder2$[ebp], edx

; 218  : 
; 219  :    /*--------------------------------------------------------
; 220  :      Compute reduced P and Q polynomials from the predictor
; 221  :        coefficients.
; 222  :    --------------------------------------------------------*/
; 223  :    VoxCompRedPoly( pfAs, iOrder, fRP, fRQ );

  000b3	8d 45 94	 lea	 eax, DWORD PTR _fRQ$[ebp]
  000b6	50		 push	 eax
  000b7	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _fRP$[ebp]
  000bd	51		 push	 ecx
  000be	8b 55 0c	 mov	 edx, DWORD PTR _iOrder$[ebp]
  000c1	52		 push	 edx
  000c2	8b 45 08	 mov	 eax, DWORD PTR _pfAs$[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _VoxCompRedPoly@16

; 224  : 
; 225  :    fRP[iOrder2] = 1.0F;  /* set high order coefficient */

  000cb	8b 4d 90	 mov	 ecx, DWORD PTR _iOrder2$[ebp]
  000ce	c7 84 8d 20 ff
	ff ff 00 00 80
	3f		 mov	 DWORD PTR _fRP$[ebp+ecx*4], 1065353216 ; 3f800000H

; 226  :    fRQ[iOrder2] = 1.0F;  /* set high order coefficient */

  000d9	8b 55 90	 mov	 edx, DWORD PTR _iOrder2$[ebp]
  000dc	c7 44 95 94 00
	00 80 3f	 mov	 DWORD PTR _fRQ$[ebp+edx*4], 1065353216 ; 3f800000H

; 227  : 
; 228  :    /*--------------------------------------------------------
; 229  :      Decimate reduced P and Q polynomials
; 230  :    --------------------------------------------------------*/
; 231  :    VoxDIDeven( fRP, fRQ, iOrder, fDP, fDQ );

  000e4	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _fDQ$[ebp]
  000ea	50		 push	 eax
  000eb	8d 4d bc	 lea	 ecx, DWORD PTR _fDP$[ebp]
  000ee	51		 push	 ecx
  000ef	8b 55 0c	 mov	 edx, DWORD PTR _iOrder$[ebp]
  000f2	52		 push	 edx
  000f3	8d 45 94	 lea	 eax, DWORD PTR _fRQ$[ebp]
  000f6	50		 push	 eax
  000f7	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _fRP$[ebp]
  000fd	51		 push	 ecx
  000fe	e8 00 00 00 00	 call	 _VoxDIDeven@20

; 232  : 
; 233  :    fRoot = 1.99999999F;  /* Initial guess for first root */

  00103	c7 85 48 ff ff
	ff 00 00 00 40	 mov	 DWORD PTR _fRoot$[ebp], 1073741824 ; 40000000H

; 234  :    pfTemp = fRP;         /* re-use this memory for       */

  0010d	8d 95 20 ff ff
	ff		 lea	 edx, DWORD PTR _fRP$[ebp]
  00113	89 55 8c	 mov	 DWORD PTR _pfTemp$[ebp], edx

; 235  :    j = 0;                /* initialize index for LSPs    */

  00116	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0

; 236  : 
; 237  :    /*-----------------------------------------------------
; 238  :      Solve for roots of the decimated polynomials.
; 239  :    -----------------------------------------------------*/
; 240  :    if (iQuadRootFlag)

  00120	83 bd 4c ff ff
	ff 00		 cmp	 DWORD PTR _iQuadRootFlag$[ebp], 0
  00127	74 09		 je	 SHORT $L1058

; 241  :       iMinDegree = 4;

  00129	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR _iMinDegree$[ebp], 4

; 242  :    else 

  00130	eb 07		 jmp	 SHORT $L1059
$L1058:

; 243  :       iMinDegree = 1;

  00132	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _iMinDegree$[ebp], 1
$L1059:

; 244  : 
; 245  :    for (iDegree = iOrder2; iDegree>iMinDegree; iDegree--)

  00139	8b 45 90	 mov	 eax, DWORD PTR _iOrder2$[ebp]
  0013c	89 85 1c ff ff
	ff		 mov	 DWORD PTR _iDegree$[ebp], eax
  00142	eb 0f		 jmp	 SHORT $L1060
$L1061:
  00144	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _iDegree$[ebp]
  0014a	83 e9 01	 sub	 ecx, 1
  0014d	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _iDegree$[ebp], ecx
$L1060:
  00153	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _iDegree$[ebp]
  00159	3b 55 e8	 cmp	 edx, DWORD PTR _iMinDegree$[ebp]
  0015c	0f 8e d5 00 00
	00		 jle	 $L1062

; 246  :    {
; 247  :       /*-----------------------------------------------------
; 248  :         Find a root of fDP[].
; 249  :       -----------------------------------------------------*/
; 250  :       if (iFindRoot(&fRoot, iDegree, fDP, pfTemp)!= ROOT_CONVERGE)

  00162	8b 45 8c	 mov	 eax, DWORD PTR _pfTemp$[ebp]
  00165	50		 push	 eax
  00166	8d 4d bc	 lea	 ecx, DWORD PTR _fDP$[ebp]
  00169	51		 push	 ecx
  0016a	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _iDegree$[ebp]
  00170	52		 push	 edx
  00171	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _fRoot$[ebp]
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 _iFindRoot@16
  0017d	85 c0		 test	 eax, eax
  0017f	74 07		 je	 SHORT $L1063

; 251  :          iStatus = FAILURE;

  00181	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iStatus$[ebp], 1
$L1063:

; 252  : 
; 253  :       pfLSP[j++] = fRoot;

  00188	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  0018e	8b 55 14	 mov	 edx, DWORD PTR _pfLSP$[ebp]
  00191	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _fRoot$[ebp]
  00197	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  0019a	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  001a0	83 c1 01	 add	 ecx, 1
  001a3	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx

; 254  : 
; 255  :       /*-----------------------------------------------------
; 256  :         Copy reduced order polynomial from pfTemp[] to fDP[]
; 257  :       -----------------------------------------------------*/
; 258  :       memcpy( fDP, pfTemp, (iDegree+1)*sizeof(float) );

  001a9	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _iDegree$[ebp]
  001af	8d 04 95 04 00
	00 00		 lea	 eax, DWORD PTR [edx*4+4]
  001b6	50		 push	 eax
  001b7	8b 4d 8c	 mov	 ecx, DWORD PTR _pfTemp$[ebp]
  001ba	51		 push	 ecx
  001bb	8d 55 bc	 lea	 edx, DWORD PTR _fDP$[ebp]
  001be	52		 push	 edx
  001bf	e8 00 00 00 00	 call	 _memcpy
  001c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 259  : 
; 260  :       /*-----------------------------------------------------
; 261  :         Find root of fDQ[].
; 262  :       -----------------------------------------------------*/
; 263  :       if (iFindRoot(&fRoot, iDegree, fDQ, pfTemp)!= ROOT_CONVERGE)

  001c7	8b 45 8c	 mov	 eax, DWORD PTR _pfTemp$[ebp]
  001ca	50		 push	 eax
  001cb	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _fDQ$[ebp]
  001d1	51		 push	 ecx
  001d2	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _iDegree$[ebp]
  001d8	52		 push	 edx
  001d9	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _fRoot$[ebp]
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 _iFindRoot@16
  001e5	85 c0		 test	 eax, eax
  001e7	74 07		 je	 SHORT $L1065

; 264  :          iStatus = FAILURE;

  001e9	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iStatus$[ebp], 1
$L1065:

; 265  : 
; 266  :       pfLSP[j++] = fRoot;

  001f0	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  001f6	8b 55 14	 mov	 edx, DWORD PTR _pfLSP$[ebp]
  001f9	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _fRoot$[ebp]
  001ff	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  00202	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00208	83 c1 01	 add	 ecx, 1
  0020b	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx

; 267  : 
; 268  :       /*-----------------------------------------------------
; 269  :         Copy reduced order polynomial from pfTemp[] to fDQ[]
; 270  :       -----------------------------------------------------*/
; 271  :       memcpy( fDQ, pfTemp, (iDegree+1)*sizeof(float) );

  00211	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _iDegree$[ebp]
  00217	8d 04 95 04 00
	00 00		 lea	 eax, DWORD PTR [edx*4+4]
  0021e	50		 push	 eax
  0021f	8b 4d 8c	 mov	 ecx, DWORD PTR _pfTemp$[ebp]
  00222	51		 push	 ecx
  00223	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR _fDQ$[ebp]
  00229	52		 push	 edx
  0022a	e8 00 00 00 00	 call	 _memcpy
  0022f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 272  :    }

  00232	e9 0d ff ff ff	 jmp	 $L1061
$L1062:

; 273  : 
; 274  :    if (iQuadRootFlag)

  00237	83 bd 4c ff ff
	ff 00		 cmp	 DWORD PTR _iQuadRootFlag$[ebp], 0
  0023e	0f 84 18 01 00
	00		 je	 $L1067

; 275  :    {
; 276  :       /*-----------------------------------------------------
; 277  :         Use the closed form solution to find the roots
; 278  :           of the 4th order polynomial.
; 279  :       -----------------------------------------------------*/
; 280  :       SolveQuad( fDP, fQuadRootsD );

  00244	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _fQuadRootsD$[ebp]
  0024a	50		 push	 eax
  0024b	8d 4d bc	 lea	 ecx, DWORD PTR _fDP$[ebp]
  0024e	51		 push	 ecx
  0024f	e8 00 00 00 00	 call	 _SolveQuad@8

; 281  :       SolveQuad( fDQ, fQuadRootsQ );

  00254	8d 55 f0	 lea	 edx, DWORD PTR _fQuadRootsQ$[ebp]
  00257	52		 push	 edx
  00258	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _fDQ$[ebp]
  0025e	50		 push	 eax
  0025f	e8 00 00 00 00	 call	 _SolveQuad@8

; 282  :    
; 283  :       pfLSP[j++] = fQuadRootsD[0];

  00264	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  0026a	8b 55 14	 mov	 edx, DWORD PTR _pfLSP$[ebp]
  0026d	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _fQuadRootsD$[ebp]
  00273	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  00276	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  0027c	83 c1 01	 add	 ecx, 1
  0027f	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx

; 284  :       pfLSP[j++] = fQuadRootsQ[0];

  00285	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  0028b	8b 45 14	 mov	 eax, DWORD PTR _pfLSP$[ebp]
  0028e	8b 4d f0	 mov	 ecx, DWORD PTR _fQuadRootsQ$[ebp]
  00291	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  00294	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  0029a	83 c2 01	 add	 edx, 1
  0029d	89 95 18 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], edx

; 285  : 
; 286  :       pfLSP[j++] = fQuadRootsD[1];

  002a3	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  002a9	8b 4d 14	 mov	 ecx, DWORD PTR _pfLSP$[ebp]
  002ac	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _fQuadRootsD$[ebp+4]
  002b2	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  002b5	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  002bb	83 c0 01	 add	 eax, 1
  002be	89 85 18 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], eax

; 287  :       pfLSP[j++] = fQuadRootsQ[1];

  002c4	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  002ca	8b 55 14	 mov	 edx, DWORD PTR _pfLSP$[ebp]
  002cd	8b 45 f4	 mov	 eax, DWORD PTR _fQuadRootsQ$[ebp+4]
  002d0	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  002d3	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  002d9	83 c1 01	 add	 ecx, 1
  002dc	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx

; 288  : 
; 289  :       pfLSP[j++] = fQuadRootsD[2];

  002e2	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  002e8	8b 45 14	 mov	 eax, DWORD PTR _pfLSP$[ebp]
  002eb	8b 4d 80	 mov	 ecx, DWORD PTR _fQuadRootsD$[ebp+8]
  002ee	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  002f1	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  002f7	83 c2 01	 add	 edx, 1
  002fa	89 95 18 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], edx

; 290  :       pfLSP[j++] = fQuadRootsQ[2];

  00300	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00306	8b 4d 14	 mov	 ecx, DWORD PTR _pfLSP$[ebp]
  00309	8b 55 f8	 mov	 edx, DWORD PTR _fQuadRootsQ$[ebp+8]
  0030c	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  0030f	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00315	83 c0 01	 add	 eax, 1
  00318	89 85 18 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], eax

; 291  : 
; 292  :       pfLSP[j++] = fQuadRootsD[3];

  0031e	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00324	8b 55 14	 mov	 edx, DWORD PTR _pfLSP$[ebp]
  00327	8b 45 84	 mov	 eax, DWORD PTR _fQuadRootsD$[ebp+12]
  0032a	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  0032d	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00333	83 c1 01	 add	 ecx, 1
  00336	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx

; 293  :       pfLSP[j++] = fQuadRootsQ[3];

  0033c	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00342	8b 45 14	 mov	 eax, DWORD PTR _pfLSP$[ebp]
  00345	8b 4d fc	 mov	 ecx, DWORD PTR _fQuadRootsQ$[ebp+12]
  00348	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  0034b	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00351	83 c2 01	 add	 edx, 1
  00354	89 95 18 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], edx

; 294  :    } else {

  0035a	eb 78		 jmp	 SHORT $L1068
$L1067:

; 295  :       /*-----------------------------------------------------
; 296  :         Solve for 1st order roots.  If (fDP[1]==0.0F) or 
; 297  :          (fDQ[1]==0.0F) then these cannot be found.
; 298  :       -----------------------------------------------------*/
; 299  :       if ( (fDP[1]==0.0F) || (fDQ[1]==0.0F))

  0035c	d9 45 c0	 fld	 DWORD PTR _fDP$[ebp+4]
  0035f	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00365	df e0		 fnstsw	 ax
  00367	f6 c4 44	 test	 ah, 68			; 00000044H
  0036a	7b 13		 jnp	 SHORT $L1070
  0036c	d9 85 54 ff ff
	ff		 fld	 DWORD PTR _fDQ$[ebp+4]
  00372	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00378	df e0		 fnstsw	 ax
  0037a	f6 c4 44	 test	 ah, 68			; 00000044H
  0037d	7a 09		 jp	 SHORT $L1069
$L1070:

; 300  :       {
; 301  :          iStatus = FAILURE;

  0037f	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iStatus$[ebp], 1

; 302  :       } else {

  00386	eb 4c		 jmp	 SHORT $L1068
$L1069:

; 303  :          pfLSP[j++] = -fDP[0]/fDP[1];

  00388	d9 45 bc	 fld	 DWORD PTR _fDP$[ebp]
  0038b	d9 e0		 fchs
  0038d	d8 75 c0	 fdiv	 DWORD PTR _fDP$[ebp+4]
  00390	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00396	8b 4d 14	 mov	 ecx, DWORD PTR _pfLSP$[ebp]
  00399	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
  0039c	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  003a2	83 c2 01	 add	 edx, 1
  003a5	89 95 18 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], edx

; 304  :          pfLSP[j++] = -fDQ[0]/fDQ[1];

  003ab	d9 85 50 ff ff
	ff		 fld	 DWORD PTR _fDQ$[ebp]
  003b1	d9 e0		 fchs
  003b3	d8 b5 54 ff ff
	ff		 fdiv	 DWORD PTR _fDQ$[ebp+4]
  003b9	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  003bf	8b 4d 14	 mov	 ecx, DWORD PTR _pfLSP$[ebp]
  003c2	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
  003c5	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  003cb	83 c2 01	 add	 edx, 1
  003ce	89 95 18 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
$L1068:

; 305  :       }
; 306  :    }
; 307  : 
; 308  :    /*---------------------------------------------------------------
; 309  :      Check if LPSs are valid.  This is done in the domain of 
; 310  :        x[i] = 2*cos( 2*PI*LSP[i] ).  In this domain the 
; 311  :        realtionship is:
; 312  : 
; 313  :      (-2 < x[iOrder-1] < ... < x[i+1] < x[i] < ... < x[0] < 2)
; 314  : 
; 315  :      NOTE: In the above expression the ordering property of the 
; 316  :              LSPs has been reversed by the cosine.
; 317  :    ---------------------------------------------------------------*/
; 318  :    if ((pfLSP[0]>=2.0F) || (pfLSP[iOrder-1]<=-2.0F))

  003d4	8b 45 14	 mov	 eax, DWORD PTR _pfLSP$[ebp]
  003d7	d9 00		 fld	 DWORD PTR [eax]
  003d9	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@40000000
  003df	df e0		 fnstsw	 ax
  003e1	f6 c4 01	 test	 ah, 1
  003e4	74 17		 je	 SHORT $L1073
  003e6	8b 4d 0c	 mov	 ecx, DWORD PTR _iOrder$[ebp]
  003e9	8b 55 14	 mov	 edx, DWORD PTR _pfLSP$[ebp]
  003ec	d9 44 8a fc	 fld	 DWORD PTR [edx+ecx*4-4]
  003f0	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@c0000000
  003f6	df e0		 fnstsw	 ax
  003f8	f6 c4 41	 test	 ah, 65			; 00000041H
  003fb	7a 07		 jp	 SHORT $L1072
$L1073:

; 319  :       iStatus = FAILURE;

  003fd	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iStatus$[ebp], 1
$L1072:

; 320  : 
; 321  :    for (i=1; i<iOrder; i++)

  00404	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0040b	eb 09		 jmp	 SHORT $L1074
$L1075:
  0040d	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00410	83 c0 01	 add	 eax, 1
  00413	89 45 e4	 mov	 DWORD PTR _i$[ebp], eax
$L1074:
  00416	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  00419	3b 4d 0c	 cmp	 ecx, DWORD PTR _iOrder$[ebp]
  0041c	7d 23		 jge	 SHORT $L1076

; 322  :       if (pfLSP[i]>pfLSP[i-1])

  0041e	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  00421	8b 45 14	 mov	 eax, DWORD PTR _pfLSP$[ebp]
  00424	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  00427	8b 75 14	 mov	 esi, DWORD PTR _pfLSP$[ebp]
  0042a	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  0042d	d8 5c 8e fc	 fcomp	 DWORD PTR [esi+ecx*4-4]
  00431	df e0		 fnstsw	 ax
  00433	f6 c4 41	 test	 ah, 65			; 00000041H
  00436	75 07		 jne	 SHORT $L1077

; 323  :          iStatus = FAILURE;

  00438	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iStatus$[ebp], 1
$L1077:

; 324  : 
; 325  :    if (iStatus==SUCCESS)

  0043f	eb cc		 jmp	 SHORT $L1075
$L1076:
  00441	83 7d ec 00	 cmp	 DWORD PTR _iStatus$[ebp], 0
  00445	75 59		 jne	 SHORT $L1078

; 326  :    {
; 327  :       /*-----------------------------------------------------
; 328  :         Convert roots to normalized frequencies.
; 329  :       -----------------------------------------------------*/
; 330  :       fScale = fScaleFactor*(1.0F/DB_PI);

  00447	d9 45 10	 fld	 DWORD PTR _fScaleFactor$[ebp]
  0044a	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e22f983
  00450	d9 5d 88	 fstp	 DWORD PTR _fScale$[ebp]

; 331  :       for (i=0; i<iOrder; i++)

  00453	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0045a	eb 09		 jmp	 SHORT $L1079
$L1080:
  0045c	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  0045f	83 c2 01	 add	 edx, 1
  00462	89 55 e4	 mov	 DWORD PTR _i$[ebp], edx
$L1079:
  00465	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00468	3b 45 0c	 cmp	 eax, DWORD PTR _iOrder$[ebp]
  0046b	7d 31		 jge	 SHORT $L1081

; 332  :          pfLSP[i] = (float)acos( pfLSP[i]*0.5F )*fScale;

  0046d	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  00470	8b 55 14	 mov	 edx, DWORD PTR _pfLSP$[ebp]
  00473	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  00476	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  0047c	83 ec 08	 sub	 esp, 8
  0047f	dd 1c 24	 fstp	 QWORD PTR [esp]
  00482	e8 00 00 00 00	 call	 _acos
  00487	83 c4 08	 add	 esp, 8
  0048a	d9 95 14 ff ff
	ff		 fst	 DWORD PTR tv403[ebp]
  00490	d8 4d 88	 fmul	 DWORD PTR _fScale$[ebp]
  00493	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00496	8b 4d 14	 mov	 ecx, DWORD PTR _pfLSP$[ebp]
  00499	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
  0049c	eb be		 jmp	 SHORT $L1080
$L1081:

; 333  :    } else {

  0049e	eb 11		 jmp	 SHORT $L1083
$L1078:

; 334  :       /*-----------------------------------------------------
; 335  :         Root finding failed....compute evenly spaced LSPs.
; 336  :       -----------------------------------------------------*/
; 337  :       VoxSetArbitraryLSP( pfLSP, iOrder, fScaleFactor );

  004a0	8b 55 10	 mov	 edx, DWORD PTR _fScaleFactor$[ebp]
  004a3	52		 push	 edx
  004a4	8b 45 0c	 mov	 eax, DWORD PTR _iOrder$[ebp]
  004a7	50		 push	 eax
  004a8	8b 4d 14	 mov	 ecx, DWORD PTR _pfLSP$[ebp]
  004ab	51		 push	 ecx
  004ac	e8 00 00 00 00	 call	 _VoxSetArbitraryLSP@12
$L1083:

; 338  :    }
; 339  : 
; 340  :    return iStatus;

  004b1	8b 45 ec	 mov	 eax, DWORD PTR _iStatus$[ebp]

; 341  : 
; 342  : } /* VoxAsToLspEven() */

  004b4	5e		 pop	 esi
  004b5	8b e5		 mov	 esp, ebp
  004b7	5d		 pop	 ebp
  004b8	c2 10 00	 ret	 16			; 00000010H
_VoxAsToLspEven@16 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _VoxCompRedPoly@16
_TEXT	SEGMENT
_pfAs0$ = -20
_pfAs1$ = -16
_fTemp0$ = -12
_i$ = -8
_fTemp1$ = -4
_pfAs$ = 8
_iOrder$ = 12
_pfRP$ = 16
_pfRQ$ = 20
_VoxCompRedPoly@16 PROC NEAR				; COMDAT

; 391  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 392  :    int    i;
; 393  :    float  fTemp0;
; 394  :    float  fTemp1;
; 395  :    float *pfAs0;
; 396  :    float *pfAs1;
; 397  : 
; 398  :    fTemp0  = 1.0F;

  00006	c7 45 f4 00 00
	80 3f		 mov	 DWORD PTR _fTemp0$[ebp], 1065353216 ; 3f800000H

; 399  :    fTemp1  = 1.0F;

  0000d	c7 45 fc 00 00
	80 3f		 mov	 DWORD PTR _fTemp1$[ebp], 1065353216 ; 3f800000H

; 400  :    pfAs0   = pfAs+1;

  00014	8b 45 08	 mov	 eax, DWORD PTR _pfAs$[ebp]
  00017	83 c0 04	 add	 eax, 4
  0001a	89 45 ec	 mov	 DWORD PTR _pfAs0$[ebp], eax

; 401  :    pfAs1   = pfAs+iOrder;

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _iOrder$[ebp]
  00020	8b 55 08	 mov	 edx, DWORD PTR _pfAs$[ebp]
  00023	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00026	89 45 f0	 mov	 DWORD PTR _pfAs1$[ebp], eax

; 402  :    for (i = (iOrder>>1)-1; i>=0; i--)

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _iOrder$[ebp]
  0002c	d1 f9		 sar	 ecx, 1
  0002e	83 e9 01	 sub	 ecx, 1
  00031	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  00034	eb 09		 jmp	 SHORT $L1098
$L1099:
  00036	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00039	83 ea 01	 sub	 edx, 1
  0003c	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L1098:
  0003f	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  00043	7c 58		 jl	 SHORT $L1092

; 403  :    {
; 404  :       fTemp0 = pfRP[i] = *pfAs0   + *pfAs1   - fTemp0;

  00045	8b 45 ec	 mov	 eax, DWORD PTR _pfAs0$[ebp]
  00048	8b 4d f0	 mov	 ecx, DWORD PTR _pfAs1$[ebp]
  0004b	d9 00		 fld	 DWORD PTR [eax]
  0004d	d8 01		 fadd	 DWORD PTR [ecx]
  0004f	d8 65 f4	 fsub	 DWORD PTR _fTemp0$[ebp]
  00052	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00055	8b 45 10	 mov	 eax, DWORD PTR _pfRP$[ebp]
  00058	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0005e	8b 55 10	 mov	 edx, DWORD PTR _pfRP$[ebp]
  00061	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00064	89 45 f4	 mov	 DWORD PTR _fTemp0$[ebp], eax

; 405  :       fTemp1 = pfRQ[i] = *pfAs0++ - *pfAs1-- + fTemp1;

  00067	8b 4d ec	 mov	 ecx, DWORD PTR _pfAs0$[ebp]
  0006a	8b 55 f0	 mov	 edx, DWORD PTR _pfAs1$[ebp]
  0006d	d9 01		 fld	 DWORD PTR [ecx]
  0006f	d8 22		 fsub	 DWORD PTR [edx]
  00071	d8 45 fc	 fadd	 DWORD PTR _fTemp1$[ebp]
  00074	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00077	8b 4d 14	 mov	 ecx, DWORD PTR _pfRQ$[ebp]
  0007a	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
  0007d	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00080	8b 45 14	 mov	 eax, DWORD PTR _pfRQ$[ebp]
  00083	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00086	89 4d fc	 mov	 DWORD PTR _fTemp1$[ebp], ecx
  00089	8b 55 f0	 mov	 edx, DWORD PTR _pfAs1$[ebp]
  0008c	83 ea 04	 sub	 edx, 4
  0008f	89 55 f0	 mov	 DWORD PTR _pfAs1$[ebp], edx
  00092	8b 45 ec	 mov	 eax, DWORD PTR _pfAs0$[ebp]
  00095	83 c0 04	 add	 eax, 4
  00098	89 45 ec	 mov	 DWORD PTR _pfAs0$[ebp], eax

; 406  :    }

  0009b	eb 99		 jmp	 SHORT $L1099
$L1092:

; 407  : } /* VoxCompRedPoly */

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 10 00	 ret	 16			; 00000010H
_VoxCompRedPoly@16 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _VoxDIDeven@20
_TEXT	SEGMENT
_j$ = -56
_k$ = -52
_N$ = -48
_Nv2$ = -44
_i$ = -40
_fS$ = -36
_pfRP$ = 8
_pfRQ$ = 12
_iOrder$ = 16
_pfDP$ = 20
_pfDQ$ = 24
_VoxDIDeven@20 PROC NEAR				; COMDAT

; 451  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	56		 push	 esi

; 452  :    int   i, j, k;
; 453  :    int   N;
; 454  :    int   Nv2;
; 455  :    float fS[MAX_LPC_ORDER>>1];
; 456  : 
; 457  :    N   = iOrder>>1;

  00007	8b 45 10	 mov	 eax, DWORD PTR _iOrder$[ebp]
  0000a	d1 f8		 sar	 eax, 1
  0000c	89 45 d0	 mov	 DWORD PTR _N$[ebp], eax

; 458  :    Nv2 = N>>1;

  0000f	8b 4d d0	 mov	 ecx, DWORD PTR _N$[ebp]
  00012	d1 f9		 sar	 ecx, 1
  00014	89 4d d4	 mov	 DWORD PTR _Nv2$[ebp], ecx

; 459  : 
; 460  :    /*---------------------------------------
; 461  :      Initialize coefficients
; 462  :    ---------------------------------------*/
; 463  :    fS[0] = 1.0F;

  00017	c7 45 dc 00 00
	80 3f		 mov	 DWORD PTR _fS$[ebp], 1065353216 ; 3f800000H

; 464  :    fS[1] = -2.0F;

  0001e	c7 45 e0 00 00
	00 c0		 mov	 DWORD PTR _fS$[ebp+4], -1073741824 ; c0000000H

; 465  :    fS[2] = 2.0F;

  00025	c7 45 e4 00 00
	00 40		 mov	 DWORD PTR _fS$[ebp+8], 1073741824 ; 40000000H

; 466  :    for (i=3; i<=Nv2; i++)

  0002c	c7 45 d8 03 00
	00 00		 mov	 DWORD PTR _i$[ebp], 3
  00033	eb 09		 jmp	 SHORT $L1118
$L1119:
  00035	8b 55 d8	 mov	 edx, DWORD PTR _i$[ebp]
  00038	83 c2 01	 add	 edx, 1
  0003b	89 55 d8	 mov	 DWORD PTR _i$[ebp], edx
$L1118:
  0003e	8b 45 d8	 mov	 eax, DWORD PTR _i$[ebp]
  00041	3b 45 d4	 cmp	 eax, DWORD PTR _Nv2$[ebp]
  00044	7f 10		 jg	 SHORT $L1120

; 467  :       fS[i] = fS[i-2];

  00046	8b 4d d8	 mov	 ecx, DWORD PTR _i$[ebp]
  00049	8b 55 d8	 mov	 edx, DWORD PTR _i$[ebp]
  0004c	8b 44 95 d4	 mov	 eax, DWORD PTR _fS$[ebp+edx*4-8]
  00050	89 44 8d dc	 mov	 DWORD PTR _fS$[ebp+ecx*4], eax
  00054	eb df		 jmp	 SHORT $L1119
$L1120:

; 468  : 
; 469  :    /*---------------------------------------
; 470  :      Decimate polynomials
; 471  :    ---------------------------------------*/
; 472  :    for (k=0; k<=N; k++)

  00056	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  0005d	eb 09		 jmp	 SHORT $L1121
$L1122:
  0005f	8b 4d cc	 mov	 ecx, DWORD PTR _k$[ebp]
  00062	83 c1 01	 add	 ecx, 1
  00065	89 4d cc	 mov	 DWORD PTR _k$[ebp], ecx
$L1121:
  00068	8b 55 cc	 mov	 edx, DWORD PTR _k$[ebp]
  0006b	3b 55 d0	 cmp	 edx, DWORD PTR _N$[ebp]
  0006e	0f 8f b0 00 00
	00		 jg	 $L1111

; 473  :    {
; 474  :       pfDP[k] = pfRP[k];

  00074	8b 45 cc	 mov	 eax, DWORD PTR _k$[ebp]
  00077	8b 4d 14	 mov	 ecx, DWORD PTR _pfDP$[ebp]
  0007a	8b 55 cc	 mov	 edx, DWORD PTR _k$[ebp]
  0007d	8b 75 08	 mov	 esi, DWORD PTR _pfRP$[ebp]
  00080	8b 14 96	 mov	 edx, DWORD PTR [esi+edx*4]
  00083	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 475  :       pfDQ[k] = pfRQ[k];

  00086	8b 45 cc	 mov	 eax, DWORD PTR _k$[ebp]
  00089	8b 4d 18	 mov	 ecx, DWORD PTR _pfDQ$[ebp]
  0008c	8b 55 cc	 mov	 edx, DWORD PTR _k$[ebp]
  0008f	8b 75 0c	 mov	 esi, DWORD PTR _pfRQ$[ebp]
  00092	8b 14 96	 mov	 edx, DWORD PTR [esi+edx*4]
  00095	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 476  :       for (i=k+2, j=1; i<=N; i+=2, j++)

  00098	8b 45 cc	 mov	 eax, DWORD PTR _k$[ebp]
  0009b	83 c0 02	 add	 eax, 2
  0009e	89 45 d8	 mov	 DWORD PTR _i$[ebp], eax
  000a1	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _j$[ebp], 1
  000a8	eb 12		 jmp	 SHORT $L1124
$L1125:
  000aa	8b 4d d8	 mov	 ecx, DWORD PTR _i$[ebp]
  000ad	83 c1 02	 add	 ecx, 2
  000b0	89 4d d8	 mov	 DWORD PTR _i$[ebp], ecx
  000b3	8b 55 c8	 mov	 edx, DWORD PTR _j$[ebp]
  000b6	83 c2 01	 add	 edx, 1
  000b9	89 55 c8	 mov	 DWORD PTR _j$[ebp], edx
$L1124:
  000bc	8b 45 d8	 mov	 eax, DWORD PTR _i$[ebp]
  000bf	3b 45 d0	 cmp	 eax, DWORD PTR _N$[ebp]
  000c2	7f 5b		 jg	 SHORT $L1126

; 477  :       {
; 478  :          pfDP[k] += fS[j]*pfRP[i];

  000c4	8b 4d c8	 mov	 ecx, DWORD PTR _j$[ebp]
  000c7	8b 55 d8	 mov	 edx, DWORD PTR _i$[ebp]
  000ca	8b 45 08	 mov	 eax, DWORD PTR _pfRP$[ebp]
  000cd	d9 44 8d dc	 fld	 DWORD PTR _fS$[ebp+ecx*4]
  000d1	d8 0c 90	 fmul	 DWORD PTR [eax+edx*4]
  000d4	8b 4d cc	 mov	 ecx, DWORD PTR _k$[ebp]
  000d7	8b 55 14	 mov	 edx, DWORD PTR _pfDP$[ebp]
  000da	d8 04 8a	 fadd	 DWORD PTR [edx+ecx*4]
  000dd	8b 45 cc	 mov	 eax, DWORD PTR _k$[ebp]
  000e0	8b 4d 14	 mov	 ecx, DWORD PTR _pfDP$[ebp]
  000e3	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]

; 479  :          pfDQ[k] += fS[j]*pfRQ[i];

  000e6	8b 55 c8	 mov	 edx, DWORD PTR _j$[ebp]
  000e9	8b 45 d8	 mov	 eax, DWORD PTR _i$[ebp]
  000ec	8b 4d 0c	 mov	 ecx, DWORD PTR _pfRQ$[ebp]
  000ef	d9 44 95 dc	 fld	 DWORD PTR _fS$[ebp+edx*4]
  000f3	d8 0c 81	 fmul	 DWORD PTR [ecx+eax*4]
  000f6	8b 55 cc	 mov	 edx, DWORD PTR _k$[ebp]
  000f9	8b 45 18	 mov	 eax, DWORD PTR _pfDQ$[ebp]
  000fc	d8 04 90	 fadd	 DWORD PTR [eax+edx*4]
  000ff	8b 4d cc	 mov	 ecx, DWORD PTR _k$[ebp]
  00102	8b 55 18	 mov	 edx, DWORD PTR _pfDQ$[ebp]
  00105	d9 1c 8a	 fstp	 DWORD PTR [edx+ecx*4]

; 480  :          fS[j]   -= fS[j-1];

  00108	8b 45 c8	 mov	 eax, DWORD PTR _j$[ebp]
  0010b	8b 4d c8	 mov	 ecx, DWORD PTR _j$[ebp]
  0010e	d9 44 85 dc	 fld	 DWORD PTR _fS$[ebp+eax*4]
  00112	d8 64 8d d8	 fsub	 DWORD PTR _fS$[ebp+ecx*4-4]
  00116	8b 55 c8	 mov	 edx, DWORD PTR _j$[ebp]
  00119	d9 5c 95 dc	 fstp	 DWORD PTR _fS$[ebp+edx*4]

; 481  :       }

  0011d	eb 8b		 jmp	 SHORT $L1125
$L1126:

; 482  :    }

  0011f	e9 3b ff ff ff	 jmp	 $L1122
$L1111:

; 483  : } /* VoxDIDeven() */

  00124	5e		 pop	 esi
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c2 14 00	 ret	 20			; 00000014H
_VoxDIDeven@20 ENDP
_TEXT	ENDS
PUBLIC	__real@358637bd
PUBLIC	__real@3c23d70a
;	COMDAT __real@358637bd
CONST	SEGMENT
__real@358637bd DD 0358637bdr			; 1e-006
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _iFindRoot@16
_TEXT	SEGMENT
_dx$ = -40
_iCount$ = -36
_pfOrg$ = -32
_df$ = -28
_pfNew$ = -24
_pfN$ = -20
_f$ = -16
_i$ = -12
_pfO$ = -8
_iStatus$ = -4
_pfRoot$ = 8
_iDegree$ = 12
_pfOrgCoef$ = 16
_pfNewCoef$ = 20
_iFindRoot@16 PROC NEAR					; COMDAT

; 512  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 513  :   float  df;        /* deviation of polynomial at *pfRoot                   */
; 514  :   float  dx;        /* difference of previous position and current position */
; 515  :   float  f=0.0F;    /* evaluation of polynomial at *pfRoot                  */

  00006	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _f$[ebp], 0

; 516  :   int    iCount, i;
; 517  :   const float    *pfOrg;
; 518  :   float          *pfNew;
; 519  :   const float    *pfO;
; 520  :   float          *pfN;
; 521  :   int             iStatus = ROOT_MAXIMUM;

  0000d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _iStatus$[ebp], 1

; 522  : 
; 523  :   /*-------------------------------------
; 524  :     pfOrg = &(pfOrgCoef[iDegree]);
; 525  :     iDegreeOld = iDegree;
; 526  :     pfNew = &(pfNewCoef[iDegree-1]);
; 527  :     iDegree = iDegree - 2;
; 528  :   -------------------------------------*/
; 529  :   pfOrg = pfOrgCoef+iDegree--;

  00014	8b 45 0c	 mov	 eax, DWORD PTR _iDegree$[ebp]
  00017	8b 4d 10	 mov	 ecx, DWORD PTR _pfOrgCoef$[ebp]
  0001a	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0001d	89 55 e0	 mov	 DWORD PTR _pfOrg$[ebp], edx
  00020	8b 45 0c	 mov	 eax, DWORD PTR _iDegree$[ebp]
  00023	83 e8 01	 sub	 eax, 1
  00026	89 45 0c	 mov	 DWORD PTR _iDegree$[ebp], eax

; 530  :   pfNew = pfNewCoef+iDegree--;

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _iDegree$[ebp]
  0002c	8b 55 14	 mov	 edx, DWORD PTR _pfNewCoef$[ebp]
  0002f	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00032	89 45 e8	 mov	 DWORD PTR _pfNew$[ebp], eax
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _iDegree$[ebp]
  00038	83 e9 01	 sub	 ecx, 1
  0003b	89 4d 0c	 mov	 DWORD PTR _iDegree$[ebp], ecx

; 531  : 
; 532  :   for (iCount = 0; (iCount<MAX_ITER) && (iStatus==ROOT_MAXIMUM); iCount++) 

  0003e	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0
  00045	eb 09		 jmp	 SHORT $L1146
$L1147:
  00047	8b 55 dc	 mov	 edx, DWORD PTR _iCount$[ebp]
  0004a	83 c2 01	 add	 edx, 1
  0004d	89 55 dc	 mov	 DWORD PTR _iCount$[ebp], edx
$L1146:
  00050	83 7d dc 0f	 cmp	 DWORD PTR _iCount$[ebp], 15 ; 0000000fH
  00054	0f 8d f5 00 00
	00		 jge	 $L1148
  0005a	83 7d fc 01	 cmp	 DWORD PTR _iStatus$[ebp], 1
  0005e	0f 85 eb 00 00
	00		 jne	 $L1148

; 533  :   {
; 534  :     /*-------------------------------------
; 535  :       f = pfOrgCoef[old_degree];
; 536  :       pfNewCoef[old_degree-1] = f;
; 537  : 
; 538  :       first df = 0; so 
; 539  :         df = df*a+f ==> df = f;
; 540  : 
; 541  :       f = f*a + pfOrgCoef[iDegreeOld-1];
; 542  :     -------------------------------------*/
; 543  :     pfO = pfOrg;    pfN = pfNew;

  00064	8b 45 e0	 mov	 eax, DWORD PTR _pfOrg$[ebp]
  00067	89 45 f8	 mov	 DWORD PTR _pfO$[ebp], eax
  0006a	8b 4d e8	 mov	 ecx, DWORD PTR _pfNew$[ebp]
  0006d	89 4d ec	 mov	 DWORD PTR _pfN$[ebp], ecx

; 544  :     df = f = *pfN-- = *pfO--;

  00070	8b 55 ec	 mov	 edx, DWORD PTR _pfN$[ebp]
  00073	8b 45 f8	 mov	 eax, DWORD PTR _pfO$[ebp]
  00076	8b 08		 mov	 ecx, DWORD PTR [eax]
  00078	89 0a		 mov	 DWORD PTR [edx], ecx
  0007a	8b 55 ec	 mov	 edx, DWORD PTR _pfN$[ebp]
  0007d	8b 02		 mov	 eax, DWORD PTR [edx]
  0007f	89 45 f0	 mov	 DWORD PTR _f$[ebp], eax
  00082	8b 4d f0	 mov	 ecx, DWORD PTR _f$[ebp]
  00085	89 4d e4	 mov	 DWORD PTR _df$[ebp], ecx
  00088	8b 55 ec	 mov	 edx, DWORD PTR _pfN$[ebp]
  0008b	83 ea 04	 sub	 edx, 4
  0008e	89 55 ec	 mov	 DWORD PTR _pfN$[ebp], edx
  00091	8b 45 f8	 mov	 eax, DWORD PTR _pfO$[ebp]
  00094	83 e8 04	 sub	 eax, 4
  00097	89 45 f8	 mov	 DWORD PTR _pfO$[ebp], eax

; 545  : 
; 546  :     f = f*(*pfRoot) + *pfO--;

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _pfRoot$[ebp]
  0009d	d9 45 f0	 fld	 DWORD PTR _f$[ebp]
  000a0	d8 09		 fmul	 DWORD PTR [ecx]
  000a2	8b 55 f8	 mov	 edx, DWORD PTR _pfO$[ebp]
  000a5	d8 02		 fadd	 DWORD PTR [edx]
  000a7	d9 5d f0	 fstp	 DWORD PTR _f$[ebp]
  000aa	8b 45 f8	 mov	 eax, DWORD PTR _pfO$[ebp]
  000ad	83 e8 04	 sub	 eax, 4
  000b0	89 45 f8	 mov	 DWORD PTR _pfO$[ebp], eax

; 547  : 
; 548  : 
; 549  :     for (i = iDegree; i >= 0; i--) 

  000b3	8b 4d 0c	 mov	 ecx, DWORD PTR _iDegree$[ebp]
  000b6	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
  000b9	eb 09		 jmp	 SHORT $L1149
$L1150:
  000bb	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000be	83 ea 01	 sub	 edx, 1
  000c1	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
$L1149:
  000c4	83 7d f4 00	 cmp	 DWORD PTR _i$[ebp], 0
  000c8	7c 3a		 jl	 SHORT $L1151

; 550  :     {
; 551  :       /*-------------------------------------
; 552  :         pfNewCoef[i] = f;
; 553  :         df = df*a + f;
; 554  :         f = f*a + pfOrgCoef[i];
; 555  :       -------------------------------------*/
; 556  :       *pfN-- = f;

  000ca	8b 45 ec	 mov	 eax, DWORD PTR _pfN$[ebp]
  000cd	8b 4d f0	 mov	 ecx, DWORD PTR _f$[ebp]
  000d0	89 08		 mov	 DWORD PTR [eax], ecx
  000d2	8b 55 ec	 mov	 edx, DWORD PTR _pfN$[ebp]
  000d5	83 ea 04	 sub	 edx, 4
  000d8	89 55 ec	 mov	 DWORD PTR _pfN$[ebp], edx

; 557  :       df = df*(*pfRoot) + f;

  000db	8b 45 08	 mov	 eax, DWORD PTR _pfRoot$[ebp]
  000de	d9 45 e4	 fld	 DWORD PTR _df$[ebp]
  000e1	d8 08		 fmul	 DWORD PTR [eax]
  000e3	d8 45 f0	 fadd	 DWORD PTR _f$[ebp]
  000e6	d9 5d e4	 fstp	 DWORD PTR _df$[ebp]

; 558  :       f = f*(*pfRoot) + *pfO--;

  000e9	8b 4d 08	 mov	 ecx, DWORD PTR _pfRoot$[ebp]
  000ec	d9 45 f0	 fld	 DWORD PTR _f$[ebp]
  000ef	d8 09		 fmul	 DWORD PTR [ecx]
  000f1	8b 55 f8	 mov	 edx, DWORD PTR _pfO$[ebp]
  000f4	d8 02		 fadd	 DWORD PTR [edx]
  000f6	d9 5d f0	 fstp	 DWORD PTR _f$[ebp]
  000f9	8b 45 f8	 mov	 eax, DWORD PTR _pfO$[ebp]
  000fc	83 e8 04	 sub	 eax, 4
  000ff	89 45 f8	 mov	 DWORD PTR _pfO$[ebp], eax

; 559  :     }

  00102	eb b7		 jmp	 SHORT $L1150
$L1151:

; 560  : 
; 561  :     /*-----------------------------------------------------------
; 562  :       derivative == 0 -- may need to move initial guess
; 563  :     -----------------------------------------------------------*/
; 564  :     if (df == 0.0F) 

  00104	d9 45 e4	 fld	 DWORD PTR _df$[ebp]
  00107	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  0010d	df e0		 fnstsw	 ax
  0010f	f6 c4 44	 test	 ah, 68			; 00000044H
  00112	7a 09		 jp	 SHORT $L1152

; 565  :     {
; 566  :        iStatus = ROOT_NOT_CONVERGE;

  00114	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _iStatus$[ebp], -1

; 567  :     } else {

  0011b	eb 2d		 jmp	 SHORT $L1153
$L1152:

; 568  :        dx = f/df;

  0011d	d9 45 f0	 fld	 DWORD PTR _f$[ebp]
  00120	d8 75 e4	 fdiv	 DWORD PTR _df$[ebp]
  00123	d9 5d d8	 fstp	 DWORD PTR _dx$[ebp]

; 569  : 
; 570  :        *pfRoot -= dx;              /* set the new root */

  00126	8b 4d 08	 mov	 ecx, DWORD PTR _pfRoot$[ebp]
  00129	d9 01		 fld	 DWORD PTR [ecx]
  0012b	d8 65 d8	 fsub	 DWORD PTR _dx$[ebp]
  0012e	8b 55 08	 mov	 edx, DWORD PTR _pfRoot$[ebp]
  00131	d9 1a		 fstp	 DWORD PTR [edx]

; 571  : 
; 572  :        if (dx <= THRESH_ZERO)  

  00133	d9 45 d8	 fld	 DWORD PTR _dx$[ebp]
  00136	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@358637bd
  0013c	df e0		 fnstsw	 ax
  0013e	f6 c4 41	 test	 ah, 65			; 00000041H
  00141	7a 07		 jp	 SHORT $L1153

; 573  :           iStatus = ROOT_CONVERGE;     /* succeed!! */

  00143	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iStatus$[ebp], 0
$L1153:

; 574  :     }
; 575  :   }

  0014a	e9 f8 fe ff ff	 jmp	 $L1147
$L1148:

; 576  : 
; 577  :   if (f < 0.0F)   

  0014f	d9 45 f0	 fld	 DWORD PTR _f$[ebp]
  00152	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00158	df e0		 fnstsw	 ax
  0015a	f6 c4 05	 test	 ah, 5
  0015d	7a 08		 jp	 SHORT $L1155

; 578  :     f = -f;

  0015f	d9 45 f0	 fld	 DWORD PTR _f$[ebp]
  00162	d9 e0		 fchs
  00164	d9 5d f0	 fstp	 DWORD PTR _f$[ebp]
$L1155:

; 579  : 
; 580  :   if (f >= (float)THRESH_ONE)  

  00167	d9 45 f0	 fld	 DWORD PTR _f$[ebp]
  0016a	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3c23d70a
  00170	df e0		 fnstsw	 ax
  00172	f6 c4 01	 test	 ah, 1
  00175	75 07		 jne	 SHORT $L1157

; 581  :      iStatus = ROOT_NOT_CONVERGE;   /* not converge */

  00177	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _iStatus$[ebp], -1
$L1157:

; 582  : 
; 583  :   return iStatus;

  0017e	8b 45 fc	 mov	 eax, DWORD PTR _iStatus$[ebp]

; 584  : 
; 585  : } /* iFindRoot() */

  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c2 10 00	 ret	 16			; 00000010H
_iFindRoot@16 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _VoxSetArbitraryLSP@12
_TEXT	SEGMENT
_fVal$ = -8
_fStep$ = -4
_pfLSP$ = 8
_iOrder$ = 12
_fScaleFactor$ = 16
_VoxSetArbitraryLSP@12 PROC NEAR			; COMDAT

; 605  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 606  :    float fStep;
; 607  :    float fVal;
; 608  : 
; 609  :    fStep = fScaleFactor/(float)iOrder;

  00006	db 45 0c	 fild	 DWORD PTR _iOrder$[ebp]
  00009	d8 7d 10	 fdivr	 DWORD PTR _fScaleFactor$[ebp]
  0000c	d9 5d fc	 fstp	 DWORD PTR _fStep$[ebp]

; 610  :    fVal = 0.5F*fStep;

  0000f	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000
  00015	d8 4d fc	 fmul	 DWORD PTR _fStep$[ebp]
  00018	d9 5d f8	 fstp	 DWORD PTR _fVal$[ebp]

; 611  : 
; 612  :    for ( ; iOrder>0; iOrder--)

  0001b	eb 09		 jmp	 SHORT $L1168
$L1169:
  0001d	8b 45 0c	 mov	 eax, DWORD PTR _iOrder$[ebp]
  00020	83 e8 01	 sub	 eax, 1
  00023	89 45 0c	 mov	 DWORD PTR _iOrder$[ebp], eax
$L1168:
  00026	83 7d 0c 00	 cmp	 DWORD PTR _iOrder$[ebp], 0
  0002a	7e 1c		 jle	 SHORT $L1164

; 613  :    {
; 614  :       *pfLSP++  = fVal;

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pfLSP$[ebp]
  0002f	8b 55 f8	 mov	 edx, DWORD PTR _fVal$[ebp]
  00032	89 11		 mov	 DWORD PTR [ecx], edx
  00034	8b 45 08	 mov	 eax, DWORD PTR _pfLSP$[ebp]
  00037	83 c0 04	 add	 eax, 4
  0003a	89 45 08	 mov	 DWORD PTR _pfLSP$[ebp], eax

; 615  :       fVal     += fStep;

  0003d	d9 45 f8	 fld	 DWORD PTR _fVal$[ebp]
  00040	d8 45 fc	 fadd	 DWORD PTR _fStep$[ebp]
  00043	d9 5d f8	 fstp	 DWORD PTR _fVal$[ebp]

; 616  :    }

  00046	eb d5		 jmp	 SHORT $L1169
$L1164:

; 617  : } /* VoxSetArbitraryLSP() */

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 0c 00	 ret	 12			; 0000000cH
_VoxSetArbitraryLSP@12 ENDP
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	__real@40800000
PUBLIC	__real@3eaaaaab
PUBLIC	__real@40400000
PUBLIC	__real@3e800000
EXTRN	_cos:NEAR
EXTRN	_sqrt:NEAR
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@3eaaaaab
CONST	SEGMENT
__real@3eaaaaab DD 03eaaaaabr			; 0.333333
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _SolveQuad@8
_TEXT	SEGMENT
tv230 = -76
tv221 = -72
_fd$ = -68
_fcc$ = -64
_faa$ = -60
_fE$ = -56
_fSqrt$ = -52
_fD$ = -48
_fc$ = -44
_fY1$ = -40
_fC$ = -36
_fa$ = -32
_fbb$ = -28
_fAlpha$ = -24
_fInv$ = -20
_fb$ = -16
_fB$ = -12
_fA$ = -8
_fAE$ = -4
_pfCoef$ = 8
_pfRoots$ = 12
_SolveQuad@8 PROC NEAR					; COMDAT

; 653  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 654  :    float fInv;
; 655  :    float fa, fb, fc, fd;      /* coefficients of quartic to solve */
; 656  :    float faa, fbb, fcc;       /* coefficients of cubic            */
; 657  :    float fA, fB, fC, fD, fE;  /* intermediate values              */
; 658  :    float fAlpha;
; 659  :    float fY1;
; 660  :    float fAE;
; 661  :    float fSqrt;
; 662  : 
; 663  :    /*-----------------------------------------------------------
; 664  :      Coefficients of quartic
; 665  :    -----------------------------------------------------------*/
; 666  :    fInv = 1.0F/pfCoef[4];

  00006	8b 45 08	 mov	 eax, DWORD PTR _pfCoef$[ebp]
  00009	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  0000f	d8 70 10	 fdiv	 DWORD PTR [eax+16]
  00012	d9 5d ec	 fstp	 DWORD PTR _fInv$[ebp]

; 667  : 
; 668  :    fa = fInv*pfCoef[3];

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _pfCoef$[ebp]
  00018	d9 45 ec	 fld	 DWORD PTR _fInv$[ebp]
  0001b	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  0001e	d9 5d e0	 fstp	 DWORD PTR _fa$[ebp]

; 669  :    fb = fInv*pfCoef[2];

  00021	8b 55 08	 mov	 edx, DWORD PTR _pfCoef$[ebp]
  00024	d9 45 ec	 fld	 DWORD PTR _fInv$[ebp]
  00027	d8 4a 08	 fmul	 DWORD PTR [edx+8]
  0002a	d9 5d f0	 fstp	 DWORD PTR _fb$[ebp]

; 670  :    fc = fInv*pfCoef[1];

  0002d	8b 45 08	 mov	 eax, DWORD PTR _pfCoef$[ebp]
  00030	d9 45 ec	 fld	 DWORD PTR _fInv$[ebp]
  00033	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00036	d9 5d d4	 fstp	 DWORD PTR _fc$[ebp]

; 671  :    fd = fInv*pfCoef[0];

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _pfCoef$[ebp]
  0003c	d9 45 ec	 fld	 DWORD PTR _fInv$[ebp]
  0003f	d8 09		 fmul	 DWORD PTR [ecx]
  00041	d9 5d bc	 fstp	 DWORD PTR _fd$[ebp]

; 672  : 
; 673  :    /*-----------------------------------------------------------
; 674  :      Coefficients of cubic
; 675  :    -----------------------------------------------------------*/
; 676  :    faa = -fb;

  00044	d9 45 f0	 fld	 DWORD PTR _fb$[ebp]
  00047	d9 e0		 fchs
  00049	d9 5d c4	 fstp	 DWORD PTR _faa$[ebp]

; 677  :    fbb = fa*fc-4.0F*fd;

  0004c	d9 45 e0	 fld	 DWORD PTR _fa$[ebp]
  0004f	d8 4d d4	 fmul	 DWORD PTR _fc$[ebp]
  00052	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40800000
  00058	d8 4d bc	 fmul	 DWORD PTR _fd$[ebp]
  0005b	de e9		 fsubp	 ST(1), ST(0)
  0005d	d9 5d e4	 fstp	 DWORD PTR _fbb$[ebp]

; 678  :    fcc = 4.0F*fb*fd - fa*fa*fd - fc*fc;

  00060	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40800000
  00066	d8 4d f0	 fmul	 DWORD PTR _fb$[ebp]
  00069	d8 4d bc	 fmul	 DWORD PTR _fd$[ebp]
  0006c	d9 45 e0	 fld	 DWORD PTR _fa$[ebp]
  0006f	d8 4d e0	 fmul	 DWORD PTR _fa$[ebp]
  00072	d8 4d bc	 fmul	 DWORD PTR _fd$[ebp]
  00075	de e9		 fsubp	 ST(1), ST(0)
  00077	d9 45 d4	 fld	 DWORD PTR _fc$[ebp]
  0007a	d8 4d d4	 fmul	 DWORD PTR _fc$[ebp]
  0007d	de e9		 fsubp	 ST(1), ST(0)
  0007f	d9 5d c0	 fstp	 DWORD PTR _fcc$[ebp]

; 679  : 
; 680  :    /*-----------------------------------------------------------
; 681  :      solve cubic
; 682  :    -----------------------------------------------------------*/
; 683  :    fE = faa*(1.0F/3.0F);

  00082	d9 45 c4	 fld	 DWORD PTR _faa$[ebp]
  00085	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3eaaaaab
  0008b	d9 5d c8	 fstp	 DWORD PTR _fE$[ebp]

; 684  :    fA = fbb - faa*fE;

  0008e	d9 45 c4	 fld	 DWORD PTR _faa$[ebp]
  00091	d8 4d c8	 fmul	 DWORD PTR _fE$[ebp]
  00094	d8 6d e4	 fsubr	 DWORD PTR _fbb$[ebp]
  00097	d9 5d f8	 fstp	 DWORD PTR _fA$[ebp]

; 685  :    fB = 2.0F*fE*fE*fE - fbb*fE + fcc;

  0009a	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40000000
  000a0	d8 4d c8	 fmul	 DWORD PTR _fE$[ebp]
  000a3	d8 4d c8	 fmul	 DWORD PTR _fE$[ebp]
  000a6	d8 4d c8	 fmul	 DWORD PTR _fE$[ebp]
  000a9	d9 45 e4	 fld	 DWORD PTR _fbb$[ebp]
  000ac	d8 4d c8	 fmul	 DWORD PTR _fE$[ebp]
  000af	de e9		 fsubp	 ST(1), ST(0)
  000b1	d8 45 c0	 fadd	 DWORD PTR _fcc$[ebp]
  000b4	d9 5d f4	 fstp	 DWORD PTR _fB$[ebp]

; 686  :    fC = 2.0F * (float)sqrt((-fA)*(1.0F/3.0F));

  000b7	d9 45 f8	 fld	 DWORD PTR _fA$[ebp]
  000ba	d9 e0		 fchs
  000bc	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3eaaaaab
  000c2	83 ec 08	 sub	 esp, 8
  000c5	dd 1c 24	 fstp	 QWORD PTR [esp]
  000c8	e8 00 00 00 00	 call	 _sqrt
  000cd	83 c4 08	 add	 esp, 8
  000d0	d9 55 b8	 fst	 DWORD PTR tv221[ebp]
  000d3	dc c0		 fadd	 ST(0), ST(0)
  000d5	d9 5d dc	 fstp	 DWORD PTR _fC$[ebp]

; 687  :    fAlpha = (float)acos(3.0F*fB/(fA*fC));

  000d8	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40400000
  000de	d8 4d f4	 fmul	 DWORD PTR _fB$[ebp]
  000e1	d9 45 f8	 fld	 DWORD PTR _fA$[ebp]
  000e4	d8 4d dc	 fmul	 DWORD PTR _fC$[ebp]
  000e7	de f9		 fdivp	 ST(1), ST(0)
  000e9	83 ec 08	 sub	 esp, 8
  000ec	dd 1c 24	 fstp	 QWORD PTR [esp]
  000ef	e8 00 00 00 00	 call	 _acos
  000f4	83 c4 08	 add	 esp, 8
  000f7	d9 55 e8	 fst	 DWORD PTR _fAlpha$[ebp]

; 688  :    fD = fC*(float)cos(fAlpha*(1.0F/3.0F));

  000fa	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3eaaaaab
  00100	83 ec 08	 sub	 esp, 8
  00103	dd 1c 24	 fstp	 QWORD PTR [esp]
  00106	e8 00 00 00 00	 call	 _cos
  0010b	83 c4 08	 add	 esp, 8
  0010e	d9 55 b4	 fst	 DWORD PTR tv230[ebp]
  00111	d8 4d dc	 fmul	 DWORD PTR _fC$[ebp]
  00114	d9 55 d0	 fst	 DWORD PTR _fD$[ebp]

; 689  :    fY1 = fD - fE;

  00117	d8 65 c8	 fsub	 DWORD PTR _fE$[ebp]
  0011a	d9 5d d8	 fstp	 DWORD PTR _fY1$[ebp]

; 690  : 
; 691  :    /*-----------------------------------------------------------
; 692  :      Solve the quartic.  In this result the following 
; 693  :        inequality holds:
; 694  : 
; 695  :         pfRoots[3] < pfRoots[2] < pfRoots[1] < pfRoots[0]
; 696  :    -----------------------------------------------------------*/
; 697  :    fE = 0.5F*fa;

  0011d	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000
  00123	d8 4d e0	 fmul	 DWORD PTR _fa$[ebp]
  00126	d9 5d c8	 fstp	 DWORD PTR _fE$[ebp]

; 698  :    fA = (float)sqrt( fa*fa*0.25F - fb + fY1 );

  00129	d9 45 e0	 fld	 DWORD PTR _fa$[ebp]
  0012c	d8 4d e0	 fmul	 DWORD PTR _fa$[ebp]
  0012f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e800000
  00135	d8 65 f0	 fsub	 DWORD PTR _fb$[ebp]
  00138	d8 45 d8	 fadd	 DWORD PTR _fY1$[ebp]
  0013b	83 ec 08	 sub	 esp, 8
  0013e	dd 1c 24	 fstp	 QWORD PTR [esp]
  00141	e8 00 00 00 00	 call	 _sqrt
  00146	83 c4 08	 add	 esp, 8
  00149	d9 5d f8	 fstp	 DWORD PTR _fA$[ebp]

; 699  :    fB = (fE * fY1 - fc) / fA;

  0014c	d9 45 c8	 fld	 DWORD PTR _fE$[ebp]
  0014f	d8 4d d8	 fmul	 DWORD PTR _fY1$[ebp]
  00152	d8 65 d4	 fsub	 DWORD PTR _fc$[ebp]
  00155	d8 75 f8	 fdiv	 DWORD PTR _fA$[ebp]
  00158	d9 5d f4	 fstp	 DWORD PTR _fB$[ebp]

; 700  : 
; 701  :    fAE = fA - fE;

  0015b	d9 45 f8	 fld	 DWORD PTR _fA$[ebp]
  0015e	d8 65 c8	 fsub	 DWORD PTR _fE$[ebp]
  00161	d9 55 fc	 fst	 DWORD PTR _fAE$[ebp]

; 702  :    fSqrt = (float)sqrt( fAE*fAE - 2.0F*(fY1-fB) );

  00164	d8 4d fc	 fmul	 DWORD PTR _fAE$[ebp]
  00167	d9 45 d8	 fld	 DWORD PTR _fY1$[ebp]
  0016a	d8 65 f4	 fsub	 DWORD PTR _fB$[ebp]
  0016d	dc c0		 fadd	 ST(0), ST(0)
  0016f	de e9		 fsubp	 ST(1), ST(0)
  00171	83 ec 08	 sub	 esp, 8
  00174	dd 1c 24	 fstp	 QWORD PTR [esp]
  00177	e8 00 00 00 00	 call	 _sqrt
  0017c	83 c4 08	 add	 esp, 8
  0017f	d9 5d cc	 fstp	 DWORD PTR _fSqrt$[ebp]

; 703  : 
; 704  :    pfRoots[0] = 0.5F * (fAE+fSqrt);

  00182	d9 45 fc	 fld	 DWORD PTR _fAE$[ebp]
  00185	d8 45 cc	 fadd	 DWORD PTR _fSqrt$[ebp]
  00188	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  0018e	8b 55 0c	 mov	 edx, DWORD PTR _pfRoots$[ebp]
  00191	d9 1a		 fstp	 DWORD PTR [edx]

; 705  :    pfRoots[1] = 0.5F * (fAE-fSqrt);

  00193	d9 45 fc	 fld	 DWORD PTR _fAE$[ebp]
  00196	d8 65 cc	 fsub	 DWORD PTR _fSqrt$[ebp]
  00199	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  0019f	8b 45 0c	 mov	 eax, DWORD PTR _pfRoots$[ebp]
  001a2	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 706  : 
; 707  :    fAE = fA + fE;

  001a5	d9 45 f8	 fld	 DWORD PTR _fA$[ebp]
  001a8	d8 45 c8	 fadd	 DWORD PTR _fE$[ebp]
  001ab	d9 55 fc	 fst	 DWORD PTR _fAE$[ebp]

; 708  :    fSqrt = (float)sqrt( fAE*fAE - 2.0F*(fY1+fB) );

  001ae	d8 4d fc	 fmul	 DWORD PTR _fAE$[ebp]
  001b1	d9 45 d8	 fld	 DWORD PTR _fY1$[ebp]
  001b4	d8 45 f4	 fadd	 DWORD PTR _fB$[ebp]
  001b7	dc c0		 fadd	 ST(0), ST(0)
  001b9	de e9		 fsubp	 ST(1), ST(0)
  001bb	83 ec 08	 sub	 esp, 8
  001be	dd 1c 24	 fstp	 QWORD PTR [esp]
  001c1	e8 00 00 00 00	 call	 _sqrt
  001c6	83 c4 08	 add	 esp, 8
  001c9	d9 5d cc	 fstp	 DWORD PTR _fSqrt$[ebp]

; 709  : 
; 710  :    pfRoots[2] = 0.5F * (-fAE+fSqrt);

  001cc	d9 45 fc	 fld	 DWORD PTR _fAE$[ebp]
  001cf	d9 e0		 fchs
  001d1	d8 45 cc	 fadd	 DWORD PTR _fSqrt$[ebp]
  001d4	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  001da	8b 4d 0c	 mov	 ecx, DWORD PTR _pfRoots$[ebp]
  001dd	d9 59 08	 fstp	 DWORD PTR [ecx+8]

; 711  :    pfRoots[3] = 0.5F * (-fAE-fSqrt);

  001e0	d9 45 fc	 fld	 DWORD PTR _fAE$[ebp]
  001e3	d9 e0		 fchs
  001e5	d8 65 cc	 fsub	 DWORD PTR _fSqrt$[ebp]
  001e8	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  001ee	8b 55 0c	 mov	 edx, DWORD PTR _pfRoots$[ebp]
  001f1	d9 5a 0c	 fstp	 DWORD PTR [edx+12]

; 712  : 
; 713  : } /* SolveQuad() */

  001f4	8b e5		 mov	 esp, ebp
  001f6	5d		 pop	 ebp
  001f7	c2 08 00	 ret	 8
_SolveQuad@8 ENDP
_TEXT	ENDS
END
