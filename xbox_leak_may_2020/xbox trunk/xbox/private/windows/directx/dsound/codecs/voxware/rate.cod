; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\rate.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DN@FHCKKKPP@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@CPOHLHHM@pVoxBuffer?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _isSingleStream@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _isValidStream@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _bytesInStream@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _bytesToStream@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _seekForward@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
PUBLIC	_wDefaultTable
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
CONST	SEGMENT
_wDefaultTable DW 08H
	DW	08H
	DW	00H
CONST	ENDS
PUBLIC	_isSingleStream@4
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\rate.c
;	COMDAT _isSingleStream@4
_TEXT	SEGMENT
_dwStream$ = 8
_isSingleStream@4 PROC NEAR				; COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   :    if(!dwStream)  /* if there is no instance than leave */

  00003	83 7d 08 00	 cmp	 DWORD PTR _dwStream$[ebp], 0
  00007	75 04		 jne	 SHORT $L859

; 46   :       return 0;

  00009	32 c0		 xor	 al, al
  0000b	eb 28		 jmp	 SHORT $L856
$L859:

; 47   : 
; 48   :    while(!(dwStream&0x01))

  0000d	8b 45 08	 mov	 eax, DWORD PTR _dwStream$[ebp]
  00010	83 e0 01	 and	 eax, 1
  00013	85 c0		 test	 eax, eax
  00015	75 0a		 jne	 SHORT $L860

; 49   :       dwStream>>=1;  /* find first bit in stream */

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _dwStream$[ebp]
  0001a	d1 e9		 shr	 ecx, 1
  0001c	89 4d 08	 mov	 DWORD PTR _dwStream$[ebp], ecx
  0001f	eb ec		 jmp	 SHORT $L859
$L860:

; 50   : 
; 51   :    if(dwStream>>=1)

  00021	8b 55 08	 mov	 edx, DWORD PTR _dwStream$[ebp]
  00024	d1 ea		 shr	 edx, 1
  00026	89 55 08	 mov	 DWORD PTR _dwStream$[ebp], edx
  00029	83 7d 08 00	 cmp	 DWORD PTR _dwStream$[ebp], 0
  0002d	74 04		 je	 SHORT $L861

; 52   :       return 0;     /* not a valid stream */

  0002f	32 c0		 xor	 al, al
  00031	eb 02		 jmp	 SHORT $L856
$L861:

; 53   :    else 
; 54   :       return 1;      /* single instance */

  00033	b0 01		 mov	 al, 1
$L856:

; 55   : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
_isSingleStream@4 ENDP
_TEXT	ENDS
PUBLIC	_isValidStream@8
; Function compile flags: /Odt
;	COMDAT _isValidStream@8
_TEXT	SEGMENT
_dwMask$ = -4
_dwStream$ = 8
_wStreamTable$ = 12
_isValidStream@8 PROC NEAR				; COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 66   :    unsigned long dwMask=0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwMask$[ebp], 0

; 67   : 
; 68   :    if(!dwStream)  /* if there is no instance than leave */

  0000b	83 7d 08 00	 cmp	 DWORD PTR _dwStream$[ebp], 0
  0000f	75 04		 jne	 SHORT $L869

; 69   :       return 0;

  00011	32 c0		 xor	 al, al
  00013	eb 60		 jmp	 SHORT $L867
$L869:

; 70   : 
; 71   :    if(!wStreamTable) /* switch to the default table if none was provided */

  00015	83 7d 0c 00	 cmp	 DWORD PTR _wStreamTable$[ebp], 0
  00019	75 07		 jne	 SHORT $L870

; 72   :       wStreamTable=wDefaultTable;

  0001b	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _wStreamTable$[ebp], OFFSET FLAT:_wDefaultTable
$L870:

; 73   : 
; 74   :    dwMask=~dwMask; /* get the inverse for ease of operation */

  00022	8b 45 fc	 mov	 eax, DWORD PTR _dwMask$[ebp]
  00025	f7 d0		 not	 eax
  00027	89 45 fc	 mov	 DWORD PTR _dwMask$[ebp], eax
$L872:

; 75   :    while(*wStreamTable++) 

  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _wStreamTable$[ebp]
  0002d	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00030	8b 45 0c	 mov	 eax, DWORD PTR _wStreamTable$[ebp]
  00033	83 c0 02	 add	 eax, 2
  00036	89 45 0c	 mov	 DWORD PTR _wStreamTable$[ebp], eax
  00039	85 d2		 test	 edx, edx
  0003b	74 0a		 je	 SHORT $L873

; 76   :       dwMask<<=1;

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _dwMask$[ebp]
  00040	d1 e1		 shl	 ecx, 1
  00042	89 4d fc	 mov	 DWORD PTR _dwMask$[ebp], ecx
  00045	eb e3		 jmp	 SHORT $L872
$L873:

; 77   : 
; 78   :    if(dwMask&dwStream)

  00047	8b 55 fc	 mov	 edx, DWORD PTR _dwMask$[ebp]
  0004a	23 55 08	 and	 edx, DWORD PTR _dwStream$[ebp]
  0004d	85 d2		 test	 edx, edx
  0004f	74 04		 je	 SHORT $L876

; 79   :       return 0; /* bit found in invalid section */

  00051	32 c0		 xor	 al, al
  00053	eb 20		 jmp	 SHORT $L867
$L876:

; 80   : 
; 81   :    while(dwStream&0x01)

  00055	8b 45 08	 mov	 eax, DWORD PTR _dwStream$[ebp]
  00058	83 e0 01	 and	 eax, 1
  0005b	85 c0		 test	 eax, eax
  0005d	74 0a		 je	 SHORT $L877

; 82   :       dwStream>>=1;

  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _dwStream$[ebp]
  00062	d1 e9		 shr	 ecx, 1
  00064	89 4d 08	 mov	 DWORD PTR _dwStream$[ebp], ecx
  00067	eb ec		 jmp	 SHORT $L876
$L877:

; 83   : 
; 84   :    if(dwStream)

  00069	83 7d 08 00	 cmp	 DWORD PTR _dwStream$[ebp], 0
  0006d	74 04		 je	 SHORT $L878

; 85   :       return 0; /* not a straight sequence */

  0006f	32 c0		 xor	 al, al
  00071	eb 02		 jmp	 SHORT $L867
$L878:

; 86   :    else 
; 87   :       return 1; /* all checks a success */

  00073	b0 01		 mov	 al, 1
$L867:

; 88   : }

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 08 00	 ret	 8
_isValidStream@8 ENDP
_TEXT	ENDS
PUBLIC	_bytesInStream@8
; Function compile flags: /Odt
;	COMDAT _bytesInStream@8
_TEXT	SEGMENT
_wAccumulate$ = -4
_dwStream$ = 8
_wStreamTable$ = 12
_bytesInStream@8 PROC NEAR				; COMDAT

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 99   :    int wAccumulate=0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _wAccumulate$[ebp], 0

; 100  : 
; 101  :    if(!wStreamTable) /* switch to the default table if none was provided */

  0000b	83 7d 0c 00	 cmp	 DWORD PTR _wStreamTable$[ebp], 0
  0000f	75 07		 jne	 SHORT $L888

; 102  :       wStreamTable=wDefaultTable;

  00011	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _wStreamTable$[ebp], OFFSET FLAT:_wDefaultTable
$L888:

; 103  : 
; 104  :    while(*wStreamTable) {

  00018	8b 45 0c	 mov	 eax, DWORD PTR _wStreamTable$[ebp]
  0001b	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0001e	85 c9		 test	 ecx, ecx
  00020	74 2b		 je	 SHORT $L889

; 105  :       if(dwStream&0x01)

  00022	8b 55 08	 mov	 edx, DWORD PTR _dwStream$[ebp]
  00025	83 e2 01	 and	 edx, 1
  00028	85 d2		 test	 edx, edx
  0002a	74 0e		 je	 SHORT $L890

; 106  :          wAccumulate+=*wStreamTable;

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _wStreamTable$[ebp]
  0002f	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _wAccumulate$[ebp]
  00035	03 d1		 add	 edx, ecx
  00037	89 55 fc	 mov	 DWORD PTR _wAccumulate$[ebp], edx
$L890:

; 107  :       dwStream>>=1;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _dwStream$[ebp]
  0003d	d1 e8		 shr	 eax, 1
  0003f	89 45 08	 mov	 DWORD PTR _dwStream$[ebp], eax

; 108  :       wStreamTable++;

  00042	8b 4d 0c	 mov	 ecx, DWORD PTR _wStreamTable$[ebp]
  00045	83 c1 02	 add	 ecx, 2
  00048	89 4d 0c	 mov	 DWORD PTR _wStreamTable$[ebp], ecx

; 109  :    }

  0004b	eb cb		 jmp	 SHORT $L888
$L889:

; 110  :    return (unsigned short)wAccumulate;

  0004d	66 8b 45 fc	 mov	 ax, WORD PTR _wAccumulate$[ebp]

; 111  : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
_bytesInStream@8 ENDP
_TEXT	ENDS
PUBLIC	_bytesToStream@8
; Function compile flags: /Odt
;	COMDAT _bytesToStream@8
_TEXT	SEGMENT
_dwStream$ = -4
_wBytes$ = 8
_wStreamTable$ = 12
_bytesToStream@8 PROC NEAR				; COMDAT

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 123  : 
; 124  :    unsigned long dwStream=0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwStream$[ebp], 0

; 125  :    if(!wStreamTable) /* switch to the default table if none was provided */

  0000b	83 7d 0c 00	 cmp	 DWORD PTR _wStreamTable$[ebp], 0
  0000f	75 07		 jne	 SHORT $L900

; 126  :       wStreamTable=wDefaultTable;

  00011	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _wStreamTable$[ebp], OFFSET FLAT:_wDefaultTable
$L900:

; 127  : 
; 128  :    while(*wStreamTable) {

  00018	8b 45 0c	 mov	 eax, DWORD PTR _wStreamTable$[ebp]
  0001b	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0001e	85 c9		 test	 ecx, ecx
  00020	74 36		 je	 SHORT $L901

; 129  :       wBytes = (unsigned short)(wBytes - *wStreamTable++);

  00022	0f b7 55 08	 movzx	 edx, WORD PTR _wBytes$[ebp]
  00026	8b 45 0c	 mov	 eax, DWORD PTR _wStreamTable$[ebp]
  00029	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0002c	2b d1		 sub	 edx, ecx
  0002e	66 89 55 08	 mov	 WORD PTR _wBytes$[ebp], dx
  00032	8b 55 0c	 mov	 edx, DWORD PTR _wStreamTable$[ebp]
  00035	83 c2 02	 add	 edx, 2
  00038	89 55 0c	 mov	 DWORD PTR _wStreamTable$[ebp], edx

; 130  : 
; 131  :       if((short)wBytes<0)

  0003b	0f bf 45 08	 movsx	 eax, WORD PTR _wBytes$[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	7d 02		 jge	 SHORT $L904

; 132  :          break;

  00043	eb 13		 jmp	 SHORT $L901
$L904:

; 133  : 
; 134  :       dwStream<<=1;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _dwStream$[ebp]
  00048	d1 e1		 shl	 ecx, 1
  0004a	89 4d fc	 mov	 DWORD PTR _dwStream$[ebp], ecx

; 135  :       dwStream|=0x01;

  0004d	8b 55 fc	 mov	 edx, DWORD PTR _dwStream$[ebp]
  00050	83 ca 01	 or	 edx, 1
  00053	89 55 fc	 mov	 DWORD PTR _dwStream$[ebp], edx

; 136  :    }

  00056	eb c0		 jmp	 SHORT $L900
$L901:

; 137  : 
; 138  :    return(dwStream);

  00058	8b 45 fc	 mov	 eax, DWORD PTR _dwStream$[ebp]

; 139  : }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
_bytesToStream@8 ENDP
_TEXT	ENDS
PUBLIC	_seekForward@24
PUBLIC	??_C@_0DN@FHCKKKPP@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BD@CPOHLHHM@pVoxBuffer?5?$CB?$DN?5NULL?$AA@ ; `string'
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0DN@FHCKKKPP@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DN@FHCKKKPP@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\rate.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CPOHLHHM@pVoxBuffer?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BD@CPOHLHHM@pVoxBuffer?5?$CB?$DN?5NULL?$AA@ DB 'pVoxBuffer != NULL'
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _seekForward@24
_TEXT	SEGMENT
_wBytesLeft$ = -16
_cContinue$ = -9
_iCrossOver$ = -8
_i$ = -4
_pVoxBuffer$ = 8
_wReadByteOffset$ = 12
_wWriteByteOffset$ = 16
_wBufferSize$ = 20
_wNumFrames$ = 24
_wStreamTable$ = 28
_seekForward@24 PROC NEAR				; COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 155  :    int            i;
; 156  :    int            iCrossOver;
; 157  :    unsigned short wBytesLeft;
; 158  :    char           cContinue;
; 159  :    assert(pVoxBuffer != NULL);

  00006	83 7d 08 00	 cmp	 DWORD PTR _pVoxBuffer$[ebp], 0
  0000a	75 17		 jne	 SHORT $L972
  0000c	68 9f 00 00 00	 push	 159			; 0000009fH
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DN@FHCKKKPP@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@CPOHLHHM@pVoxBuffer?5?$CB?$DN?5NULL?$AA@
  0001b	e8 00 00 00 00	 call	 __assert
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
$L972:

; 160  : 
; 161  :    /*---------------------------------------------------
; 162  :      If wReadByteOffset equals wWriteByteOffset then
; 163  :        the buffer is empty!
; 164  :    ---------------------------------------------------*/
; 165  :    if (wReadByteOffset==wWriteByteOffset)

  00023	0f b7 4d 0c	 movzx	 ecx, WORD PTR _wReadByteOffset$[ebp]
  00027	0f b7 55 10	 movzx	 edx, WORD PTR _wWriteByteOffset$[ebp]
  0002b	3b ca		 cmp	 ecx, edx
  0002d	75 09		 jne	 SHORT $L926

; 166  :            return -1;

  0002f	66 0d ff ff	 or	 ax, -1
  00033	e9 4c 01 00 00	 jmp	 $L917
$L926:

; 167  : 
; 168  :    if (wWriteByteOffset>wReadByteOffset)

  00038	0f b7 45 10	 movzx	 eax, WORD PTR _wWriteByteOffset$[ebp]
  0003c	0f b7 4d 0c	 movzx	 ecx, WORD PTR _wReadByteOffset$[ebp]
  00040	3b c1		 cmp	 eax, ecx
  00042	7e 09		 jle	 SHORT $L927

; 169  :       iCrossOver = 1;

  00044	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _iCrossOver$[ebp], 1

; 170  :    else

  0004b	eb 07		 jmp	 SHORT $L928
$L927:

; 171  :       iCrossOver = 0;

  0004d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iCrossOver$[ebp], 0
$L928:

; 172  : 
; 173  :    /*---------------------------------------------------
; 174  :      switch to the default table if none was provided
; 175  :    ---------------------------------------------------*/
; 176  :    if(!wStreamTable)

  00054	83 7d 1c 00	 cmp	 DWORD PTR _wStreamTable$[ebp], 0
  00058	75 07		 jne	 SHORT $L931

; 177  :       wStreamTable=wDefaultTable;

  0005a	c7 45 1c 00 00
	00 00		 mov	 DWORD PTR _wStreamTable$[ebp], OFFSET FLAT:_wDefaultTable
$L931:

; 178  : 
; 179  :    while((wNumFrames--)>0) {

  00061	0f b7 55 18	 movzx	 edx, WORD PTR _wNumFrames$[ebp]
  00065	66 8b 45 18	 mov	 ax, WORD PTR _wNumFrames$[ebp]
  00069	66 2d 01 00	 sub	 ax, 1
  0006d	66 89 45 18	 mov	 WORD PTR _wNumFrames$[ebp], ax
  00071	85 d2		 test	 edx, edx
  00073	0f 8e 07 01 00
	00		 jle	 $L932

; 180  :       i=0;

  00079	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$L933:

; 181  :       do {
; 182  :          /*---------------------------------------------------
; 183  :            Increment wReadByteOffset by wStreamTable[i].
; 184  :              We have to be careful here because 
; 185  :              wReadByteOffset+wStreamTable[i] could be larger
; 186  :              than the maximum unsigned short in which case
; 187  :              we cannot compute the sum directly.
; 188  :          ---------------------------------------------------*/
; 189  :          wBytesLeft = wBufferSize - wReadByteOffset;

  00080	0f b7 4d 14	 movzx	 ecx, WORD PTR _wBufferSize$[ebp]
  00084	0f b7 55 0c	 movzx	 edx, WORD PTR _wReadByteOffset$[ebp]
  00088	2b ca		 sub	 ecx, edx
  0008a	66 89 4d f0	 mov	 WORD PTR _wBytesLeft$[ebp], cx

; 190  :          if (wBytesLeft <= wStreamTable[i])

  0008e	0f b7 45 f0	 movzx	 eax, WORD PTR _wBytesLeft$[ebp]
  00092	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00095	8b 55 1c	 mov	 edx, DWORD PTR _wStreamTable$[ebp]
  00098	0f b7 0c 4a	 movzx	 ecx, WORD PTR [edx+ecx*2]
  0009c	3b c1		 cmp	 eax, ecx
  0009e	7f 32		 jg	 SHORT $L936

; 191  :          {
; 192  :             /*---------------------------------------------------
; 193  :               If we will pass the write pointer as we wrap
; 194  :                 around then there are not enough sample in the 
; 195  :                 buffer.
; 196  :             ---------------------------------------------------*/
; 197  :             if (wWriteByteOffset>wReadByteOffset)

  000a0	0f b7 55 10	 movzx	 edx, WORD PTR _wWriteByteOffset$[ebp]
  000a4	0f b7 45 0c	 movzx	 eax, WORD PTR _wReadByteOffset$[ebp]
  000a8	3b d0		 cmp	 edx, eax
  000aa	7e 09		 jle	 SHORT $L937

; 198  :               return -1;

  000ac	66 0d ff ff	 or	 ax, -1
  000b0	e9 cf 00 00 00	 jmp	 $L917
$L937:

; 199  : 
; 200  :             wReadByteOffset = wStreamTable[i] - wBytesLeft;

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000b8	8b 55 1c	 mov	 edx, DWORD PTR _wStreamTable$[ebp]
  000bb	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  000bf	0f b7 4d f0	 movzx	 ecx, WORD PTR _wBytesLeft$[ebp]
  000c3	2b c1		 sub	 eax, ecx
  000c5	66 89 45 0c	 mov	 WORD PTR _wReadByteOffset$[ebp], ax

; 201  :             iCrossOver      = 1;

  000c9	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _iCrossOver$[ebp], 1

; 202  :          } else {

  000d0	eb 14		 jmp	 SHORT $L938
$L936:

; 203  :             wReadByteOffset += wStreamTable[i];

  000d2	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000d5	8b 45 1c	 mov	 eax, DWORD PTR _wStreamTable$[ebp]
  000d8	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  000dc	0f b7 55 0c	 movzx	 edx, WORD PTR _wReadByteOffset$[ebp]
  000e0	03 d1		 add	 edx, ecx
  000e2	66 89 55 0c	 mov	 WORD PTR _wReadByteOffset$[ebp], dx
$L938:

; 204  :          }
; 205  :          i++;

  000e6	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000e9	83 c0 01	 add	 eax, 1
  000ec	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 206  : 
; 207  :          /*---------------------------------------------------
; 208  :            If wReadByteOffset passses wWriteByteOffset then
; 209  :              we are reading passed the end of the data in
; 210  :              the buffer.  If wReadByteOffset is equal to 
; 211  :              wWriteByteOffset then the buffer is empty, but 
; 212  :              that's okay as long as we don't try to read 
; 213  :              any further.
; 214  :          ---------------------------------------------------*/
; 215  :          if (iCrossOver&&(wReadByteOffset>wWriteByteOffset))

  000ef	83 7d f8 00	 cmp	 DWORD PTR _iCrossOver$[ebp], 0
  000f3	74 12		 je	 SHORT $L939
  000f5	0f b7 4d 0c	 movzx	 ecx, WORD PTR _wReadByteOffset$[ebp]
  000f9	0f b7 55 10	 movzx	 edx, WORD PTR _wWriteByteOffset$[ebp]
  000fd	3b ca		 cmp	 ecx, edx
  000ff	7e 06		 jle	 SHORT $L939

; 216  :            return -1; /* not enough space in buffer to continue */

  00101	66 0d ff ff	 or	 ax, -1
  00105	eb 7d		 jmp	 SHORT $L917
$L939:

; 217  : 
; 218  :          /*---------------------------------------------------
; 219  :             check for continuation bit
; 220  :          ---------------------------------------------------*/
; 221  :          if (wReadByteOffset)

  00107	0f b7 45 0c	 movzx	 eax, WORD PTR _wReadByteOffset$[ebp]
  0010b	85 c0		 test	 eax, eax
  0010d	74 16		 je	 SHORT $L940

; 222  :             cContinue = (char)(pVoxBuffer[wReadByteOffset-1]&0x080);

  0010f	0f b7 4d 0c	 movzx	 ecx, WORD PTR _wReadByteOffset$[ebp]
  00113	8b 55 08	 mov	 edx, DWORD PTR _pVoxBuffer$[ebp]
  00116	0f b6 44 0a ff	 movzx	 eax, BYTE PTR [edx+ecx-1]
  0011b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00120	88 45 f7	 mov	 BYTE PTR _cContinue$[ebp], al

; 223  :          else

  00123	eb 14		 jmp	 SHORT $L942
$L940:

; 224  :             cContinue = (char)(pVoxBuffer[wBufferSize-1]&0x080);

  00125	0f b7 4d 14	 movzx	 ecx, WORD PTR _wBufferSize$[ebp]
  00129	8b 55 08	 mov	 edx, DWORD PTR _pVoxBuffer$[ebp]
  0012c	0f b6 44 0a ff	 movzx	 eax, BYTE PTR [edx+ecx-1]
  00131	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00136	88 45 f7	 mov	 BYTE PTR _cContinue$[ebp], al
$L942:

; 225  : 
; 226  :          /*---------------------------------------------------
; 227  :             We have to be careful on these tests...the test
; 228  :               for the corrupted bitstream comes first.
; 229  :               If the bitstream is not corrupt, then we
; 230  :               could be out of data.
; 231  :          ---------------------------------------------------*/
; 232  :          if((!wStreamTable[i]) && cContinue)

  00139	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0013c	8b 55 1c	 mov	 edx, DWORD PTR _wStreamTable$[ebp]
  0013f	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00143	85 c0		 test	 eax, eax
  00145	75 0e		 jne	 SHORT $L944
  00147	0f be 4d f7	 movsx	 ecx, BYTE PTR _cContinue$[ebp]
  0014b	85 c9		 test	 ecx, ecx
  0014d	74 06		 je	 SHORT $L944

; 233  :             return -2; /* bitstream may be corrupted */

  0014f	66 b8 fe ff	 mov	 ax, -2			; fffffffeH
  00153	eb 2f		 jmp	 SHORT $L917
$L944:

; 234  : 
; 235  :          else if((wWriteByteOffset == wReadByteOffset) && cContinue)

  00155	0f b7 55 10	 movzx	 edx, WORD PTR _wWriteByteOffset$[ebp]
  00159	0f b7 45 0c	 movzx	 eax, WORD PTR _wReadByteOffset$[ebp]
  0015d	3b d0		 cmp	 edx, eax
  0015f	75 0e		 jne	 SHORT $L934
  00161	0f be 4d f7	 movsx	 ecx, BYTE PTR _cContinue$[ebp]
  00165	85 c9		 test	 ecx, ecx
  00167	74 06		 je	 SHORT $L934

; 236  :             return -1; /* need more in buffer */

  00169	66 0d ff ff	 or	 ax, -1
  0016d	eb 15		 jmp	 SHORT $L917
$L934:

; 237  : 
; 238  :       } while(cContinue);

  0016f	0f be 55 f7	 movsx	 edx, BYTE PTR _cContinue$[ebp]
  00173	85 d2		 test	 edx, edx
  00175	0f 85 05 ff ff
	ff		 jne	 $L933

; 239  :    }

  0017b	e9 e1 fe ff ff	 jmp	 $L931
$L932:

; 240  : 
; 241  :    return(wReadByteOffset);

  00180	66 8b 45 0c	 mov	 ax, WORD PTR _wReadByteOffset$[ebp]
$L917:

; 242  : }

  00184	8b e5		 mov	 esp, ebp
  00186	5d		 pop	 ebp
  00187	c2 18 00	 ret	 24			; 00000018H
_seekForward@24 ENDP
_TEXT	ENDS
END
