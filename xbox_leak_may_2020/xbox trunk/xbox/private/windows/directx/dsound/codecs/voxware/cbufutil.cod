; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\cbufutil.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _copyCBuf2LBuf@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_copyCBuf2LBuf@24
EXTRN	_BitUnpackCBuffer@12:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\cbufutil.c
;	COMDAT _copyCBuf2LBuf@24
_TEXT	SEGMENT
tv67 = -28
_CircBuffer$ = -24
_CBuffer$ = 8
_ByteOffset$ = 12
_BitOffset$ = 16
_BufferSize$ = 20
_bitsToCopy$ = 24
_LBuffer$ = 28
_copyCBuf2LBuf@24 PROC NEAR				; COMDAT

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 70   :    C_BUFFER_TYPE CircBuffer;
; 71   :   
; 72   :    CircBuffer.wBufferSize = BufferSize;

  00006	66 8b 45 14	 mov	 ax, WORD PTR _BufferSize$[ebp]
  0000a	66 89 45 ec	 mov	 WORD PTR _CircBuffer$[ebp+4], ax

; 73   :    CircBuffer.pBufferReadByteOffset = ByteOffset;

  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR _ByteOffset$[ebp]
  00011	89 4d f0	 mov	 DWORD PTR _CircBuffer$[ebp+8], ecx

; 74   :    CircBuffer.pBufferReadBitOffset  = BitOffset;

  00014	8b 55 10	 mov	 edx, DWORD PTR _BitOffset$[ebp]
  00017	89 55 f4	 mov	 DWORD PTR _CircBuffer$[ebp+12], edx

; 75   :    CircBuffer.pBuffer = CBuffer;                                       

  0001a	8b 45 08	 mov	 eax, DWORD PTR _CBuffer$[ebp]
  0001d	89 45 e8	 mov	 DWORD PTR _CircBuffer$[ebp], eax
$L516:

; 76   : 
; 77   :    while(bitsToCopy>=PACK_BITS_PER_CHAR)

  00020	83 7d 18 08	 cmp	 DWORD PTR _bitsToCopy$[ebp], 8
  00024	72 29		 jb	 SHORT $L517

; 78   :    {
; 79   :       BitUnpackCBuffer(&CircBuffer, LBuffer++, PACK_BITS_PER_CHAR);

  00026	8b 4d 1c	 mov	 ecx, DWORD PTR _LBuffer$[ebp]
  00029	89 4d e4	 mov	 DWORD PTR tv67[ebp], ecx
  0002c	6a 08		 push	 8
  0002e	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00031	52		 push	 edx
  00032	8d 45 e8	 lea	 eax, DWORD PTR _CircBuffer$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _BitUnpackCBuffer@12
  0003b	8b 4d 1c	 mov	 ecx, DWORD PTR _LBuffer$[ebp]
  0003e	83 c1 01	 add	 ecx, 1
  00041	89 4d 1c	 mov	 DWORD PTR _LBuffer$[ebp], ecx

; 80   :       bitsToCopy-=PACK_BITS_PER_CHAR;

  00044	8b 55 18	 mov	 edx, DWORD PTR _bitsToCopy$[ebp]
  00047	83 ea 08	 sub	 edx, 8
  0004a	89 55 18	 mov	 DWORD PTR _bitsToCopy$[ebp], edx

; 81   :    }

  0004d	eb d1		 jmp	 SHORT $L516
$L517:

; 82   :    BitUnpackCBuffer(&CircBuffer, LBuffer, (short)bitsToCopy);

  0004f	66 8b 45 18	 mov	 ax, WORD PTR _bitsToCopy$[ebp]
  00053	50		 push	 eax
  00054	8b 4d 1c	 mov	 ecx, DWORD PTR _LBuffer$[ebp]
  00057	51		 push	 ecx
  00058	8d 55 e8	 lea	 edx, DWORD PTR _CircBuffer$[ebp]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _BitUnpackCBuffer@12

; 83   : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 18 00	 ret	 24			; 00000018H
_copyCBuf2LBuf@24 ENDP
_TEXT	ENDS
END
