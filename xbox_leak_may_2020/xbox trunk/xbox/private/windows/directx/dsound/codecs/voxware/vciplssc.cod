; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\vciplssc.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EB@HGNGBIFJ@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@NAOMMECF@pwWarpFactor?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@PFJCCICN@pUnPack?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MJGCMMIE@pwEnergyLevel?$CB?$DNNULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@CAOLNIF@pwNumFrames?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@BEIFPMPN@wBitField?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _vciSetFramesSkippedSC@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciSetRepeatFrameFlagSC@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciSetWarpFactorSC@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciGetWarpFactorSC@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciDecodeNeedsInputSC@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciGetEnergyLevelSC@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciSetInjectSilenceFlagSC@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciNumFramesInBufferSC@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciSeekForwardSC@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciExtractFromBitStreamSC@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciCombineBitStreamSC@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciGetRatesInFrameSC@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciSetEncoderRateSC@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciGetEncoderRateSC@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciGetValidRatesSC@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciCalculateBitRateSC@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciCalculateRateSC@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciPlusInitSC@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciPlusFreeSC@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciGetPlusInfoSC@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_vciSetFramesSkippedSC@8
EXTRN	_voxSetFrameSkippedSC@8:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\vciplssc.c
;	COMDAT _vciSetFramesSkippedSC@8
_TEXT	SEGMENT
_vciCodecMblk$ = -4
_pDecodeMemBlk$ = 8
_iFramesSkipped$ = 12
_vciSetFramesSkippedSC@8 PROC NEAR			; COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 66   :    VCI_CODEC_BLOCK *vciCodecMblk=NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 67   :    
; 68   :    if(!VCI_BLOCK_CHECK(pDecodeMemBlk))

  0000b	83 7d 08 00	 cmp	 DWORD PTR _pDecodeMemBlk$[ebp], 0
  0000f	74 0b		 je	 SHORT $L1726
  00011	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  00014	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0001a	74 06		 je	 SHORT $L1725
$L1726:

; 69   :       return VCI_NOT_VCI_HANDLE;

  0001c	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00020	eb 2b		 jmp	 SHORT $L1721
$L1725:

; 70   : 
; 71   :    if(!VCI_IS_DECODE(pDecodeMemBlk))

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _pDecodeMemBlk$[ebp]
  00025	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00029	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0002c	74 06		 je	 SHORT $L1728

; 72   :       return VCI_NOT_DEC_HANDLE;

  0002e	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  00032	eb 19		 jmp	 SHORT $L1721
$L1728:

; 73   :       
; 74   :    vciCodecMblk = (VCI_CODEC_BLOCK *)pDecodeMemBlk;

  00034	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  00037	89 45 fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax

; 75   : 
; 76   :    voxSetFrameSkippedSC(vciCodecMblk->hCodecMblk, iFramesSkipped);

  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR _iFramesSkipped$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00041	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _voxSetFrameSkippedSC@8

; 77   : 
; 78   :    return VCI_NO_ERROR;

  0004a	66 33 c0	 xor	 ax, ax
$L1721:

; 79   : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
_vciSetFramesSkippedSC@8 ENDP
_TEXT	ENDS
PUBLIC	_vciSetRepeatFrameFlagSC@4
EXTRN	_voxSetRepeatFrameSC@8:NEAR
; Function compile flags: /Odt
;	COMDAT _vciSetRepeatFrameFlagSC@4
_TEXT	SEGMENT
_vciCodecMblk$ = -4
_pDecodeMemBlk$ = 8
_vciSetRepeatFrameFlagSC@4 PROC NEAR			; COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 89   :    VCI_CODEC_BLOCK *vciCodecMblk;
; 90   :  
; 91   :    if(!VCI_BLOCK_CHECK(pDecodeMemBlk))

  00004	83 7d 08 00	 cmp	 DWORD PTR _pDecodeMemBlk$[ebp], 0
  00008	74 0b		 je	 SHORT $L1736
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  0000d	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  00013	74 06		 je	 SHORT $L1735
$L1736:

; 92   :       return VCI_NOT_VCI_HANDLE;

  00015	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00019	eb 29		 jmp	 SHORT $L1732
$L1735:

; 93   : 
; 94   :    if(!VCI_IS_DECODE(pDecodeMemBlk))

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _pDecodeMemBlk$[ebp]
  0001e	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00022	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00025	74 06		 je	 SHORT $L1738

; 95   :       return VCI_NOT_DEC_HANDLE;

  00027	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  0002b	eb 17		 jmp	 SHORT $L1732
$L1738:

; 96   : 
; 97   :    vciCodecMblk = (VCI_CODEC_BLOCK *)pDecodeMemBlk;

  0002d	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  00030	89 45 fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax

; 98   : 
; 99   :    voxSetRepeatFrameSC(vciCodecMblk->hCodecMblk, 1);

  00033	6a 01		 push	 1
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00038	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 _voxSetRepeatFrameSC@8

; 100  :  
; 101  :    return VCI_NO_ERROR;

  00041	66 33 c0	 xor	 ax, ax
$L1732:

; 102  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
_vciSetRepeatFrameFlagSC@4 ENDP
_TEXT	ENDS
PUBLIC	__real@3f000000
PUBLIC	__real@40a00000
PUBLIC	_vciSetWarpFactorSC@8
EXTRN	__fltused:NEAR
EXTRN	_voxSetWarpFactorSC@8:NEAR
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciSetWarpFactorSC@8
_TEXT	SEGMENT
_vciCodecMblk$ = -4
_pDecodeMemBlk$ = 8
_wWarpFactor$ = 12
_vciSetWarpFactorSC@8 PROC NEAR				; COMDAT

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 112  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 113  : 
; 114  :    if(!VCI_BLOCK_CHECK(pDecodeMemBlk))

  0000b	83 7d 08 00	 cmp	 DWORD PTR _pDecodeMemBlk$[ebp], 0
  0000f	74 0b		 je	 SHORT $L1749
  00011	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  00014	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0001a	74 06		 je	 SHORT $L1748
$L1749:

; 115  :       return VCI_NOT_VCI_HANDLE;

  0001c	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00020	eb 74		 jmp	 SHORT $L1744
$L1748:

; 116  : 
; 117  :    if(!VCI_IS_DECODE(pDecodeMemBlk))

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _pDecodeMemBlk$[ebp]
  00025	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00029	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0002c	74 06		 je	 SHORT $L1751

; 118  :       return VCI_NOT_DEC_HANDLE;

  0002e	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  00032	eb 62		 jmp	 SHORT $L1744
$L1751:

; 119  : 
; 120  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pDecodeMemBlk;

  00034	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  00037	89 45 fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax

; 121  : 
; 122  :    /* First make sure that the handle passed is the correct one. */
; 123  :    if (vciCodecMblk->dwVciChunkID != SANITY_CHECK) 

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  0003d	81 39 ce fa 00
	00		 cmp	 DWORD PTR [ecx], 64206	; 0000faceH
  00043	74 06		 je	 SHORT $L1753

; 124  :       return VCI_NOT_VCI_HANDLE;

  00045	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00049	eb 4b		 jmp	 SHORT $L1744
$L1753:

; 125  :    if (vciCodecMblk->chEncOrDec   != DECODE_ID)    

  0004b	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0004e	0f b6 42 0c	 movzx	 eax, BYTE PTR [edx+12]
  00052	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00055	74 06		 je	 SHORT $L1754

; 126  :       return VCI_NOT_DEC_HANDLE;

  00057	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  0005b	eb 39		 jmp	 SHORT $L1744
$L1754:

; 127  : 
; 128  :    if(wWarpFactor<MIN_WARP||wWarpFactor>MAX_WARP)

  0005d	d9 45 0c	 fld	 DWORD PTR _wWarpFactor$[ebp]
  00060	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f000000
  00066	df e0		 fnstsw	 ax
  00068	f6 c4 05	 test	 ah, 5
  0006b	7b 10		 jnp	 SHORT $L1756
  0006d	d9 45 0c	 fld	 DWORD PTR _wWarpFactor$[ebp]
  00070	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@40a00000
  00076	df e0		 fnstsw	 ax
  00078	f6 c4 41	 test	 ah, 65			; 00000041H
  0007b	75 06		 jne	 SHORT $L1755
$L1756:

; 129  :       return VCI_ARG_OUT_OF_RANGE;

  0007d	66 b8 15 18	 mov	 ax, 6165		; 00001815H
  00081	eb 13		 jmp	 SHORT $L1744
$L1755:

; 130  : 
; 131  :    voxSetWarpFactorSC(vciCodecMblk->hCodecMblk, wWarpFactor);

  00083	8b 4d 0c	 mov	 ecx, DWORD PTR _wWarpFactor$[ebp]
  00086	51		 push	 ecx
  00087	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0008a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _voxSetWarpFactorSC@8

; 132  : 
; 133  :    return VCI_NO_ERROR;

  00093	66 33 c0	 xor	 ax, ax
$L1744:

; 134  : }

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 08 00	 ret	 8
_vciSetWarpFactorSC@8 ENDP
_TEXT	ENDS
PUBLIC	_vciGetWarpFactorSC@8
PUBLIC	??_C@_0EB@HGNGBIFJ@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BF@NAOMMECF@pwWarpFactor?5?$CB?$DN?5NULL?$AA@ ; `string'
EXTRN	_voxGetWarpFactorSC@4:NEAR
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0EB@HGNGBIFJ@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0EB@HGNGBIFJ@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\vciplssc.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NAOMMECF@pwWarpFactor?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BF@NAOMMECF@pwWarpFactor?5?$CB?$DN?5NULL?$AA@ DB 'pwWarpFactor != '
	DB	'NULL', 00H					; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciGetWarpFactorSC@8
_TEXT	SEGMENT
_vciCodecMblk$ = -4
_pDecodeMemBlk$ = 8
_pwWarpFactor$ = 12
_vciGetWarpFactorSC@8 PROC NEAR				; COMDAT

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 145  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 146  : 
; 147  :    /* First make sure that the handle passed is the correct one. */
; 148  :    if(!VCI_BLOCK_CHECK(pDecodeMemBlk))

  0000b	83 7d 08 00	 cmp	 DWORD PTR _pDecodeMemBlk$[ebp], 0
  0000f	74 0b		 je	 SHORT $L1766
  00011	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  00014	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0001a	74 06		 je	 SHORT $L1765
$L1766:

; 149  :       return VCI_NOT_VCI_HANDLE;

  0001c	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00020	eb 49		 jmp	 SHORT $L1761
$L1765:

; 150  : 
; 151  :    if(!VCI_IS_DECODE(pDecodeMemBlk))

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _pDecodeMemBlk$[ebp]
  00025	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00029	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0002c	74 06		 je	 SHORT $L1768

; 152  :       return VCI_NOT_DEC_HANDLE;

  0002e	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  00032	eb 37		 jmp	 SHORT $L1761
$L1768:

; 153  : 
; 154  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pDecodeMemBlk;

  00034	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  00037	89 45 fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax

; 155  : 
; 156  :    assert(pwWarpFactor != NULL);

  0003a	83 7d 0c 00	 cmp	 DWORD PTR _pwWarpFactor$[ebp], 0
  0003e	75 17		 jne	 SHORT $L2302
  00040	68 9c 00 00 00	 push	 156			; 0000009cH
  00045	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@HGNGBIFJ@c?3?2xbox?2private?2windows?2directx?2@
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@NAOMMECF@pwWarpFactor?5?$CB?$DN?5NULL?$AA@
  0004f	e8 00 00 00 00	 call	 __assert
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
$L2302:

; 157  :    *pwWarpFactor = voxGetWarpFactorSC(vciCodecMblk->hCodecMblk);

  00057	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0005a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _voxGetWarpFactorSC@4
  00063	8b 4d 0c	 mov	 ecx, DWORD PTR _pwWarpFactor$[ebp]
  00066	d9 19		 fstp	 DWORD PTR [ecx]

; 158  : 
; 159  :   return VCI_NO_ERROR;

  00068	66 33 c0	 xor	 ax, ax
$L1761:

; 160  : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 08 00	 ret	 8
_vciGetWarpFactorSC@8 ENDP
_TEXT	ENDS
PUBLIC	_vciDecodeNeedsInputSC@8
PUBLIC	??_C@_0P@PFJCCICN@pUnPack?$CB?$DN?5NULL?$AA@	; `string'
EXTRN	_voxGetDecReqDataFlagSC@4:NEAR
;	COMDAT ??_C@_0P@PFJCCICN@pUnPack?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0P@PFJCCICN@pUnPack?$CB?$DN?5NULL?$AA@ DB 'pUnPack!= NULL', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciDecodeNeedsInputSC@8
_TEXT	SEGMENT
_vciCodecMblk$ = -4
_pDecodeMemBlk$ = 8
_pUnPack$ = 12
_vciDecodeNeedsInputSC@8 PROC NEAR			; COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 170  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 171  : 
; 172  :    /* First make sure that the handle passed is the correct one. */
; 173  :    if(!VCI_BLOCK_CHECK(pDecodeMemBlk))

  0000b	83 7d 08 00	 cmp	 DWORD PTR _pDecodeMemBlk$[ebp], 0
  0000f	74 0b		 je	 SHORT $L1783
  00011	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  00014	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0001a	74 06		 je	 SHORT $L1782
$L1783:

; 174  :       return VCI_NOT_VCI_HANDLE;

  0001c	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00020	eb 49		 jmp	 SHORT $L1778
$L1782:

; 175  : 
; 176  :    if(!VCI_IS_DECODE(pDecodeMemBlk))

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _pDecodeMemBlk$[ebp]
  00025	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00029	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0002c	74 06		 je	 SHORT $L1785

; 177  :       return VCI_NOT_DEC_HANDLE;

  0002e	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  00032	eb 37		 jmp	 SHORT $L1778
$L1785:

; 178  : 
; 179  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pDecodeMemBlk;

  00034	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  00037	89 45 fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax

; 180  :    assert(pUnPack!= NULL);

  0003a	83 7d 0c 00	 cmp	 DWORD PTR _pUnPack$[ebp], 0
  0003e	75 17		 jne	 SHORT $L2306
  00040	68 b4 00 00 00	 push	 180			; 000000b4H
  00045	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@HGNGBIFJ@c?3?2xbox?2private?2windows?2directx?2@
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@PFJCCICN@pUnPack?$CB?$DN?5NULL?$AA@
  0004f	e8 00 00 00 00	 call	 __assert
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
$L2306:

; 181  : 
; 182  :    *pUnPack=voxGetDecReqDataFlagSC(vciCodecMblk->hCodecMblk);

  00057	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0005a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _voxGetDecReqDataFlagSC@4
  00063	8b 4d 0c	 mov	 ecx, DWORD PTR _pUnPack$[ebp]
  00066	88 01		 mov	 BYTE PTR [ecx], al

; 183  : 
; 184  :    return VCI_NO_ERROR;

  00068	66 33 c0	 xor	 ax, ax
$L1778:

; 185  : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 08 00	 ret	 8
_vciDecodeNeedsInputSC@8 ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@403c555560000000
PUBLIC	_vciGetEnergyLevelSC@8
PUBLIC	??_C@_0BE@MJGCMMIE@pwEnergyLevel?$CB?$DNNULL?$AA@ ; `string'
EXTRN	_log10:NEAR
EXTRN	__ftol2:NEAR
;	COMDAT ??_C@_0BE@MJGCMMIE@pwEnergyLevel?$CB?$DNNULL?$AA@
CONST	SEGMENT
??_C@_0BE@MJGCMMIE@pwEnergyLevel?$CB?$DNNULL?$AA@ DB 'pwEnergyLevel!=NULL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@403c555560000000
CONST	SEGMENT
__real@403c555560000000 DQ 0403c555560000000r	; 28.3333
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciGetEnergyLevelSC@8
_TEXT	SEGMENT
tv191 = -28
tv188 = -24
_fSample$ = -20
_vciCodecMblk$ = -16
_vciCodecIOBlk$ = -12
_fFrameEnergy$ = -8
_i$ = -4
_pCodecMemBlk$ = 8
_pwEnergyLevel$ = 12
_vciGetEnergyLevelSC@8 PROC NEAR			; COMDAT

; 194  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 195  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00006	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 196  :    VCI_CODEC_IO_BLOCK *vciCodecIOBlk = NULL;

  0000d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _vciCodecIOBlk$[ebp], 0

; 197  :    float fFrameEnergy = 0.0F ;

  00014	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fFrameEnergy$[ebp], 0

; 198  :    float fSample;
; 199  :    int i;
; 200  : 
; 201  :    assert(pwEnergyLevel!=NULL);

  0001b	83 7d 0c 00	 cmp	 DWORD PTR _pwEnergyLevel$[ebp], 0
  0001f	75 17		 jne	 SHORT $L2310
  00021	68 c9 00 00 00	 push	 201			; 000000c9H
  00026	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@HGNGBIFJ@c?3?2xbox?2private?2windows?2directx?2@
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@MJGCMMIE@pwEnergyLevel?$CB?$DNNULL?$AA@
  00030	e8 00 00 00 00	 call	 __assert
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
$L2310:

; 202  : 
; 203  :    /* First make sure that the handle passed is the correct one. */
; 204  :    if(!VCI_BLOCK_CHECK(pCodecMemBlk))

  00038	83 7d 08 00	 cmp	 DWORD PTR _pCodecMemBlk$[ebp], 0
  0003c	74 0b		 je	 SHORT $L1807
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _pCodecMemBlk$[ebp]
  00041	81 39 ce fa 00
	00		 cmp	 DWORD PTR [ecx], 64206	; 0000faceH
  00047	74 09		 je	 SHORT $L1806
$L1807:

; 205  :       return VCI_NOT_VCI_HANDLE;

  00049	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  0004d	e9 4c 01 00 00	 jmp	 $L1794
$L1806:

; 206  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pCodecMemBlk;

  00052	8b 55 08	 mov	 edx, DWORD PTR _pCodecMemBlk$[ebp]
  00055	89 55 f0	 mov	 DWORD PTR _vciCodecMblk$[ebp], edx

; 207  : 
; 208  :    /* vciCodeIOBlk must be attached to vciCodeMblk */
; 209  :    vciCodecIOBlk = (VCI_CODEC_IO_BLOCK *)(vciCodecMblk->pVciCodecIOBlock);

  00058	8b 45 f0	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  0005b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0005e	89 4d f4	 mov	 DWORD PTR _vciCodecIOBlk$[ebp], ecx

; 210  :    VCI_IO_BLK_PARAM_CHECK(vciCodecIOBlk);

  00061	83 7d f4 00	 cmp	 DWORD PTR _vciCodecIOBlk$[ebp], 0
  00065	75 09		 jne	 SHORT $L1810
  00067	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  0006b	e9 2e 01 00 00	 jmp	 $L1794
$L1810:
  00070	8b 55 f4	 mov	 edx, DWORD PTR _vciCodecIOBlk$[ebp]
  00073	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00077	75 09		 jne	 SHORT $L1811
  00079	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  0007d	e9 1c 01 00 00	 jmp	 $L1794
$L1811:
  00082	8b 45 f4	 mov	 eax, DWORD PTR _vciCodecIOBlk$[ebp]
  00085	83 38 00	 cmp	 DWORD PTR [eax], 0
  00088	75 09		 jne	 SHORT $L1812
  0008a	66 b8 ed 17	 mov	 ax, 6125		; 000017edH
  0008e	e9 0b 01 00 00	 jmp	 $L1794
$L1812:
  00093	8b 4d f4	 mov	 ecx, DWORD PTR _vciCodecIOBlk$[ebp]
  00096	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  0009a	8b 45 f4	 mov	 eax, DWORD PTR _vciCodecIOBlk$[ebp]
  0009d	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  000a1	3b d1		 cmp	 edx, ecx
  000a3	7c 09		 jl	 SHORT $L1813
  000a5	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  000a9	e9 f0 00 00 00	 jmp	 $L1794
$L1813:
  000ae	8b 55 f4	 mov	 edx, DWORD PTR _vciCodecIOBlk$[ebp]
  000b1	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR _vciCodecIOBlk$[ebp]
  000b8	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  000bc	3b c2		 cmp	 eax, edx
  000be	7c 09		 jl	 SHORT $L1814
  000c0	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  000c4	e9 d5 00 00 00	 jmp	 $L1794
$L1814:
  000c9	8b 45 f4	 mov	 eax, DWORD PTR _vciCodecIOBlk$[ebp]
  000cc	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  000d0	83 f9 07	 cmp	 ecx, 7
  000d3	7e 09		 jle	 SHORT $L1815
  000d5	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  000d9	e9 c0 00 00 00	 jmp	 $L1794
$L1815:
  000de	8b 55 f4	 mov	 edx, DWORD PTR _vciCodecIOBlk$[ebp]
  000e1	0f b6 42 14	 movzx	 eax, BYTE PTR [edx+20]
  000e5	83 f8 07	 cmp	 eax, 7
  000e8	7e 09		 jle	 SHORT $L1816
  000ea	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  000ee	e9 ab 00 00 00	 jmp	 $L1794
$L1816:

; 211  : 
; 212  : #ifndef DECODE_ONLY
; 213  :    if(VCI_IS_ENCODE(pCodecMemBlk)) {

  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _pCodecMemBlk$[ebp]
  000f6	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  000fa	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  000fd	75 0c		 jne	 SHORT $L1818

; 214  :      fFrameEnergy = ((ENC_MEM_BLK *)(vciCodecMblk->hCodecMblk))->frameEnergy;

  000ff	8b 45 f0	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00102	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00105	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00108	89 55 f8	 mov	 DWORD PTR _fFrameEnergy$[ebp], edx
$L1818:

; 215  :    }
; 216  : #endif
; 217  : 
; 218  :    if(VCI_IS_DECODE(pCodecMemBlk)) {

  0010b	8b 45 08	 mov	 eax, DWORD PTR _pCodecMemBlk$[ebp]
  0010e	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  00112	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00115	75 5c		 jne	 SHORT $L1821

; 219  :      /* compute frame_energy from PCMBuffer */
; 220  :      if (vciCodecIOBlk->wSamplesInPCMBuffer > 0) {

  00117	8b 55 f4	 mov	 edx, DWORD PTR _vciCodecIOBlk$[ebp]
  0011a	0f b7 42 04	 movzx	 eax, WORD PTR [edx+4]
  0011e	85 c0		 test	 eax, eax
  00120	7e 51		 jle	 SHORT $L1821

; 221  :        for (i = 0; i < vciCodecIOBlk->wSamplesInPCMBuffer; i++) {

  00122	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00129	eb 09		 jmp	 SHORT $L1823
$L1824:
  0012b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0012e	83 c1 01	 add	 ecx, 1
  00131	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L1823:
  00134	8b 55 f4	 mov	 edx, DWORD PTR _vciCodecIOBlk$[ebp]
  00137	0f b7 42 04	 movzx	 eax, WORD PTR [edx+4]
  0013b	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  0013e	7d 20		 jge	 SHORT $L1825

; 222  : 	 fSample = (float)vciCodecIOBlk->pPCMBuffer[i];

  00140	8b 4d f4	 mov	 ecx, DWORD PTR _vciCodecIOBlk$[ebp]
  00143	8b 11		 mov	 edx, DWORD PTR [ecx]
  00145	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00148	0f bf 0c 42	 movsx	 ecx, WORD PTR [edx+eax*2]
  0014c	89 4d e8	 mov	 DWORD PTR tv188[ebp], ecx
  0014f	db 45 e8	 fild	 DWORD PTR tv188[ebp]
  00152	d9 55 ec	 fst	 DWORD PTR _fSample$[ebp]

; 223  : 	 fFrameEnergy += fSample * fSample;

  00155	d8 4d ec	 fmul	 DWORD PTR _fSample$[ebp]
  00158	d8 45 f8	 fadd	 DWORD PTR _fFrameEnergy$[ebp]
  0015b	d9 5d f8	 fstp	 DWORD PTR _fFrameEnergy$[ebp]

; 224  :        }

  0015e	eb cb		 jmp	 SHORT $L1824
$L1825:

; 225  : 
; 226  :        fFrameEnergy /= (float)vciCodecIOBlk->wSamplesInPCMBuffer;

  00160	8b 55 f4	 mov	 edx, DWORD PTR _vciCodecIOBlk$[ebp]
  00163	0f b7 42 04	 movzx	 eax, WORD PTR [edx+4]
  00167	89 45 e4	 mov	 DWORD PTR tv191[ebp], eax
  0016a	db 45 e4	 fild	 DWORD PTR tv191[ebp]
  0016d	d8 7d f8	 fdivr	 DWORD PTR _fFrameEnergy$[ebp]
  00170	d9 5d f8	 fstp	 DWORD PTR _fFrameEnergy$[ebp]
$L1821:

; 227  :      }
; 228  :    }
; 229  : 
; 230  :    *pwEnergyLevel=(short)(log10(fFrameEnergy+1.0)* DB2LEVEL_VALUE);

  00173	d9 45 f8	 fld	 DWORD PTR _fFrameEnergy$[ebp]
  00176	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  0017c	83 ec 08	 sub	 esp, 8
  0017f	dd 1c 24	 fstp	 QWORD PTR [esp]
  00182	e8 00 00 00 00	 call	 _log10
  00187	83 c4 08	 add	 esp, 8
  0018a	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@403c555560000000
  00190	e8 00 00 00 00	 call	 __ftol2
  00195	8b 4d 0c	 mov	 ecx, DWORD PTR _pwEnergyLevel$[ebp]
  00198	66 89 01	 mov	 WORD PTR [ecx], ax

; 231  :   
; 232  :   return VCI_NO_ERROR;

  0019b	66 33 c0	 xor	 ax, ax
$L1794:

; 233  : }

  0019e	8b e5		 mov	 esp, ebp
  001a0	5d		 pop	 ebp
  001a1	c2 08 00	 ret	 8
_vciGetEnergyLevelSC@8 ENDP
_TEXT	ENDS
PUBLIC	_vciSetInjectSilenceFlagSC@4
EXTRN	_SetCurrentFrameStateSC@8:NEAR
; Function compile flags: /Odt
;	COMDAT _vciSetInjectSilenceFlagSC@4
_TEXT	SEGMENT
_pDecMemBlk$ = -4
_pDecodeMemBlk$ = 8
_vciSetInjectSilenceFlagSC@4 PROC NEAR			; COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 244  :    DEC_MEM_BLK *pDecMemBlk = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pDecMemBlk$[ebp], 0

; 245  : 
; 246  :    /* First make sure that the handle passed is the correct one. */
; 247  :    if(!VCI_BLOCK_CHECK(pDecodeMemBlk))

  0000b	83 7d 08 00	 cmp	 DWORD PTR _pDecodeMemBlk$[ebp], 0
  0000f	74 0b		 je	 SHORT $L1836
  00011	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  00014	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0001a	74 06		 je	 SHORT $L1835
$L1836:

; 248  :       return VCI_NOT_VCI_HANDLE;

  0001c	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00020	eb 2b		 jmp	 SHORT $L1831
$L1835:

; 249  : 
; 250  :    if(!VCI_IS_DECODE(pDecodeMemBlk))

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _pDecodeMemBlk$[ebp]
  00025	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00029	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0002c	74 06		 je	 SHORT $L1838

; 251  :       return VCI_NOT_DEC_HANDLE;

  0002e	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  00032	eb 19		 jmp	 SHORT $L1831
$L1838:

; 252  : 
; 253  :    pDecMemBlk = (DEC_MEM_BLK *)((VCI_CODEC_BLOCK *)pDecodeMemBlk)->hCodecMblk;

  00034	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  00037	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0003a	89 4d fc	 mov	 DWORD PTR _pDecMemBlk$[ebp], ecx

; 254  :    SetCurrentFrameStateSC(pDecMemBlk->pFadeIOMemBlk, SILENCE);

  0003d	6a 00		 push	 0
  0003f	8b 55 fc	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00042	8b 02		 mov	 eax, DWORD PTR [edx]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _SetCurrentFrameStateSC@8

; 255  : 
; 256  :    return VCI_NO_ERROR;

  0004a	66 33 c0	 xor	 ax, ax
$L1831:

; 257  : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
_vciSetInjectSilenceFlagSC@4 ENDP
_TEXT	ENDS
PUBLIC	_vciNumFramesInBufferSC@20
PUBLIC	??_C@_0BD@CAOLNIF@pwNumFrames?$CB?$DN?5NULL?$AA@ ; `string'
EXTRN	_seekForward@24:NEAR
;	COMDAT ??_C@_0BD@CAOLNIF@pwNumFrames?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BD@CAOLNIF@pwNumFrames?$CB?$DN?5NULL?$AA@ DB 'pwNumFrames!= NULL', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciNumFramesInBufferSC@20
_TEXT	SEGMENT
_wSeekInitial$ = -24
_wByteOffset$ = -20
_vciCodecMblk$ = -16
_wNumFrames$ = -12
_wSeekReturn$ = -8
_pStreamTable$ = -4
_pVciCodecMemBlk$ = 8
_pvciCodecIOBlk$ = 12
_pwNumFrames$ = 16
_pwByteOffset$ = 20
_pchBitOffset$ = 24
_vciNumFramesInBufferSC@20 PROC NEAR			; COMDAT

; 271  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 272  :    short wSeekReturn, wSeekInitial;
; 273  :    unsigned short wNumFrames=0;

  00006	66 c7 45 f4 00
	00		 mov	 WORD PTR _wNumFrames$[ebp], 0

; 274  :    const VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  0000c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 275  :    const unsigned short *pStreamTable = NULL;

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pStreamTable$[ebp], 0

; 276  :    unsigned short wByteOffset;
; 277  : 
; 278  :     /* Do parameter checking on IO block. */
; 279  :    VCI_IO_BLK_PARAM_CHECK(pvciCodecIOBlk);

  0001a	83 7d 0c 00	 cmp	 DWORD PTR _pvciCodecIOBlk$[ebp], 0
  0001e	75 09		 jne	 SHORT $L1860
  00020	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  00024	e9 73 01 00 00	 jmp	 $L1851
$L1860:
  00029	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  0002c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00030	75 09		 jne	 SHORT $L1861
  00032	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  00036	e9 61 01 00 00	 jmp	 $L1851
$L1861:
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0003e	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00041	75 09		 jne	 SHORT $L1862
  00043	66 b8 ed 17	 mov	 ax, 6125		; 000017edH
  00047	e9 50 01 00 00	 jmp	 $L1851
$L1862:
  0004c	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0004f	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00053	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00056	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  0005a	3b c2		 cmp	 eax, edx
  0005c	7c 09		 jl	 SHORT $L1863
  0005e	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  00062	e9 35 01 00 00	 jmp	 $L1851
$L1863:
  00067	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  0006a	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  0006e	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00071	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00075	3b c8		 cmp	 ecx, eax
  00077	7c 09		 jl	 SHORT $L1864
  00079	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  0007d	e9 1a 01 00 00	 jmp	 $L1851
$L1864:
  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00085	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  00089	83 fa 07	 cmp	 edx, 7
  0008c	7e 09		 jle	 SHORT $L1865
  0008e	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  00092	e9 05 01 00 00	 jmp	 $L1851
$L1865:
  00097	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  0009a	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  0009e	83 f9 07	 cmp	 ecx, 7
  000a1	7e 09		 jle	 SHORT $L1866
  000a3	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  000a7	e9 f0 00 00 00	 jmp	 $L1851
$L1866:

; 280  : 
; 281  :    /* First make sure that the handle passed is the correct one. */
; 282  :    if(!VCI_BLOCK_CHECK(pVciCodecMemBlk))

  000ac	83 7d 08 00	 cmp	 DWORD PTR _pVciCodecMemBlk$[ebp], 0
  000b0	74 0b		 je	 SHORT $L1869
  000b2	8b 55 08	 mov	 edx, DWORD PTR _pVciCodecMemBlk$[ebp]
  000b5	81 3a ce fa 00
	00		 cmp	 DWORD PTR [edx], 64206	; 0000faceH
  000bb	74 09		 je	 SHORT $L1868
$L1869:

; 283  :       return VCI_NOT_VCI_HANDLE;

  000bd	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  000c1	e9 d6 00 00 00	 jmp	 $L1851
$L1868:

; 284  : 
; 285  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pVciCodecMemBlk;

  000c6	8b 45 08	 mov	 eax, DWORD PTR _pVciCodecMemBlk$[ebp]
  000c9	89 45 f0	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax

; 286  : 
; 287  :    if(vciCodecMblk->pVciPlusMethodStruct)

  000cc	8b 4d f0	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000cf	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  000d3	74 18		 je	 SHORT $L1871

; 288  :       if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)

  000d5	8b 55 f0	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000d8	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000db	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  000df	74 0c		 je	 SHORT $L1871

; 289  :          pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

  000e1	8b 4d f0	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000e4	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000e7	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  000ea	89 45 fc	 mov	 DWORD PTR _pStreamTable$[ebp], eax
$L1871:

; 290  : 
; 291  :    assert(pwNumFrames!= NULL);

  000ed	83 7d 10 00	 cmp	 DWORD PTR _pwNumFrames$[ebp], 0
  000f1	75 17		 jne	 SHORT $L2322
  000f3	68 23 01 00 00	 push	 291			; 00000123H
  000f8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@HGNGBIFJ@c?3?2xbox?2private?2windows?2directx?2@
  000fd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@CAOLNIF@pwNumFrames?$CB?$DN?5NULL?$AA@
  00102	e8 00 00 00 00	 call	 __assert
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH
$L2322:

; 292  : 
; 293  :    wByteOffset = wSeekReturn=pvciCodecIOBlk->wVoxBufferReadByteOffset;

  0010a	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0010d	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  00111	66 89 45 f8	 mov	 WORD PTR _wSeekReturn$[ebp], ax
  00115	66 8b 4d f8	 mov	 cx, WORD PTR _wSeekReturn$[ebp]
  00119	66 89 4d ec	 mov	 WORD PTR _wByteOffset$[ebp], cx
$L1877:

; 294  : 
; 295  :    while(wSeekReturn != pvciCodecIOBlk->wVoxBufferWriteByteOffset) {

  0011d	0f bf 55 f8	 movsx	 edx, WORD PTR _wSeekReturn$[ebp]
  00121	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00124	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00128	3b d1		 cmp	 edx, ecx
  0012a	74 53		 je	 SHORT $L1878

; 296  : 
; 297  :       wSeekInitial = wSeekReturn;

  0012c	66 8b 55 f8	 mov	 dx, WORD PTR _wSeekReturn$[ebp]
  00130	66 89 55 e8	 mov	 WORD PTR _wSeekInitial$[ebp], dx

; 298  :       wSeekReturn = seekForward(pvciCodecIOBlk->pVoxBuffer,
; 299  :                   wSeekInitial,
; 300  :                   pvciCodecIOBlk->wVoxBufferWriteByteOffset,
; 301  :                   pvciCodecIOBlk->wVoxBufferSize,
; 302  :                   1, pStreamTable);

  00134	8b 45 fc	 mov	 eax, DWORD PTR _pStreamTable$[ebp]
  00137	50		 push	 eax
  00138	6a 01		 push	 1
  0013a	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0013d	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  00141	52		 push	 edx
  00142	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00145	66 8b 48 12	 mov	 cx, WORD PTR [eax+18]
  00149	51		 push	 ecx
  0014a	66 8b 55 e8	 mov	 dx, WORD PTR _wSeekInitial$[ebp]
  0014e	52		 push	 edx
  0014f	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00152	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00155	51		 push	 ecx
  00156	e8 00 00 00 00	 call	 _seekForward@24
  0015b	66 89 45 f8	 mov	 WORD PTR _wSeekReturn$[ebp], ax

; 303  : 
; 304  :       if(wSeekReturn < 0)

  0015f	0f bf 55 f8	 movsx	 edx, WORD PTR _wSeekReturn$[ebp]
  00163	85 d2		 test	 edx, edx
  00165	7d 02		 jge	 SHORT $L1879

; 305  :         break;

  00167	eb 16		 jmp	 SHORT $L1878
$L1879:

; 306  :       else
; 307  :         wByteOffset = wSeekReturn;

  00169	66 8b 45 f8	 mov	 ax, WORD PTR _wSeekReturn$[ebp]
  0016d	66 89 45 ec	 mov	 WORD PTR _wByteOffset$[ebp], ax

; 308  : 
; 309  :       wNumFrames++;

  00171	66 8b 4d f4	 mov	 cx, WORD PTR _wNumFrames$[ebp]
  00175	66 83 c1 01	 add	 cx, 1
  00179	66 89 4d f4	 mov	 WORD PTR _wNumFrames$[ebp], cx

; 310  :    } 

  0017d	eb 9e		 jmp	 SHORT $L1877
$L1878:

; 311  : 
; 312  :    *pwByteOffset=wByteOffset;

  0017f	8b 55 14	 mov	 edx, DWORD PTR _pwByteOffset$[ebp]
  00182	66 8b 45 ec	 mov	 ax, WORD PTR _wByteOffset$[ebp]
  00186	66 89 02	 mov	 WORD PTR [edx], ax

; 313  :    *pwNumFrames=wNumFrames;

  00189	8b 4d 10	 mov	 ecx, DWORD PTR _pwNumFrames$[ebp]
  0018c	66 8b 55 f4	 mov	 dx, WORD PTR _wNumFrames$[ebp]
  00190	66 89 11	 mov	 WORD PTR [ecx], dx

; 314  :    *pchBitOffset=0;

  00193	8b 45 18	 mov	 eax, DWORD PTR _pchBitOffset$[ebp]
  00196	c6 00 00	 mov	 BYTE PTR [eax], 0

; 315  : 
; 316  :    return VCI_NO_ERROR;

  00199	66 33 c0	 xor	 ax, ax
$L1851:

; 317  : }

  0019c	8b e5		 mov	 esp, ebp
  0019e	5d		 pop	 ebp
  0019f	c2 14 00	 ret	 20			; 00000014H
_vciNumFramesInBufferSC@20 ENDP
_TEXT	ENDS
PUBLIC	_vciSeekForwardSC@20
; Function compile flags: /Odt
;	COMDAT _vciSeekForwardSC@20
_TEXT	SEGMENT
_vciCodecMblk$ = -12
_wSeek$ = -8
_pStreamTable$ = -4
_pVciCodecMemBlk$ = 8
_pvciCodecIOBlk$ = 12
_wNumFrames$ = 16
_pwReadOffset$ = 20
_pchBitOffset$ = 24
_vciSeekForwardSC@20 PROC NEAR				; COMDAT

; 330  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 331  :    short wSeek; 
; 332  :    const VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 333  :    const unsigned short *pStreamTable = NULL;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pStreamTable$[ebp], 0

; 334  : 
; 335  :    VCI_IO_BLK_PARAM_CHECK(pvciCodecIOBlk);

  00014	83 7d 0c 00	 cmp	 DWORD PTR _pvciCodecIOBlk$[ebp], 0
  00018	75 09		 jne	 SHORT $L1897
  0001a	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  0001e	e9 26 01 00 00	 jmp	 $L1891
$L1897:
  00023	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00026	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0002a	75 09		 jne	 SHORT $L1898
  0002c	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  00030	e9 14 01 00 00	 jmp	 $L1891
$L1898:
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00038	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0003b	75 09		 jne	 SHORT $L1899
  0003d	66 b8 ed 17	 mov	 ax, 6125		; 000017edH
  00041	e9 03 01 00 00	 jmp	 $L1891
$L1899:
  00046	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00049	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00050	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00054	3b c2		 cmp	 eax, edx
  00056	7c 09		 jl	 SHORT $L1900
  00058	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  0005c	e9 e8 00 00 00	 jmp	 $L1891
$L1900:
  00061	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00064	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00068	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0006b	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  0006f	3b c8		 cmp	 ecx, eax
  00071	7c 09		 jl	 SHORT $L1901
  00073	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  00077	e9 cd 00 00 00	 jmp	 $L1891
$L1901:
  0007c	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0007f	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  00083	83 fa 07	 cmp	 edx, 7
  00086	7e 09		 jle	 SHORT $L1902
  00088	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  0008c	e9 b8 00 00 00	 jmp	 $L1891
$L1902:
  00091	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00094	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  00098	83 f9 07	 cmp	 ecx, 7
  0009b	7e 09		 jle	 SHORT $L1903
  0009d	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  000a1	e9 a3 00 00 00	 jmp	 $L1891
$L1903:

; 336  : 
; 337  :    /* First make sure that the handle passed is the correct one. */
; 338  :    if(!VCI_BLOCK_CHECK(pVciCodecMemBlk))

  000a6	83 7d 08 00	 cmp	 DWORD PTR _pVciCodecMemBlk$[ebp], 0
  000aa	74 0b		 je	 SHORT $L1906
  000ac	8b 55 08	 mov	 edx, DWORD PTR _pVciCodecMemBlk$[ebp]
  000af	81 3a ce fa 00
	00		 cmp	 DWORD PTR [edx], 64206	; 0000faceH
  000b5	74 09		 je	 SHORT $L1905
$L1906:

; 339  :       return VCI_NOT_VCI_HANDLE;

  000b7	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  000bb	e9 89 00 00 00	 jmp	 $L1891
$L1905:

; 340  : 
; 341  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pVciCodecMemBlk; 

  000c0	8b 45 08	 mov	 eax, DWORD PTR _pVciCodecMemBlk$[ebp]
  000c3	89 45 f4	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax

; 342  : 
; 343  :    if(vciCodecMblk->pVciPlusMethodStruct)

  000c6	8b 4d f4	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000c9	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  000cd	74 18		 je	 SHORT $L1908

; 344  :       if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)

  000cf	8b 55 f4	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000d2	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000d5	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  000d9	74 0c		 je	 SHORT $L1908

; 345  :          pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

  000db	8b 4d f4	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000de	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000e1	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  000e4	89 45 fc	 mov	 DWORD PTR _pStreamTable$[ebp], eax
$L1908:

; 346  : 
; 347  :    wSeek=seekForward(pvciCodecIOBlk->pVoxBuffer,
; 348  :                   pvciCodecIOBlk->wVoxBufferReadByteOffset,
; 349  :                   pvciCodecIOBlk->wVoxBufferWriteByteOffset,
; 350  :                   pvciCodecIOBlk->wVoxBufferSize,
; 351  :                   wNumFrames, 
; 352  :                   pStreamTable);

  000e7	8b 4d fc	 mov	 ecx, DWORD PTR _pStreamTable$[ebp]
  000ea	51		 push	 ecx
  000eb	66 8b 55 10	 mov	 dx, WORD PTR _wNumFrames$[ebp]
  000ef	52		 push	 edx
  000f0	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  000f3	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  000f7	51		 push	 ecx
  000f8	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000fb	66 8b 42 12	 mov	 ax, WORD PTR [edx+18]
  000ff	50		 push	 eax
  00100	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00103	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  00107	52		 push	 edx
  00108	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  0010b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0010e	51		 push	 ecx
  0010f	e8 00 00 00 00	 call	 _seekForward@24
  00114	66 89 45 f8	 mov	 WORD PTR _wSeek$[ebp], ax

; 353  : 
; 354  :    if(wSeek==-1)

  00118	0f bf 55 f8	 movsx	 edx, WORD PTR _wSeek$[ebp]
  0011c	83 fa ff	 cmp	 edx, -1
  0011f	75 06		 jne	 SHORT $L1910

; 355  :       return VCI_INSUFFICIENT_VOX_DATA;

  00121	66 b8 0b 18	 mov	 ax, 6155		; 0000180bH
  00125	eb 22		 jmp	 SHORT $L1891
$L1910:

; 356  :    else if(wSeek==-2)

  00127	0f bf 45 f8	 movsx	 eax, WORD PTR _wSeek$[ebp]
  0012b	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  0012e	75 06		 jne	 SHORT $L1912

; 357  :       return VCI_BITSTREAM_CORRUPTED;

  00130	66 b8 29 18	 mov	 ax, 6185		; 00001829H
  00134	eb 13		 jmp	 SHORT $L1891
$L1912:

; 358  :    else {
; 359  :       *pwReadOffset=(unsigned short)wSeek;

  00136	8b 4d 14	 mov	 ecx, DWORD PTR _pwReadOffset$[ebp]
  00139	66 8b 55 f8	 mov	 dx, WORD PTR _wSeek$[ebp]
  0013d	66 89 11	 mov	 WORD PTR [ecx], dx

; 360  :       *pchBitOffset=0;

  00140	8b 45 18	 mov	 eax, DWORD PTR _pchBitOffset$[ebp]
  00143	c6 00 00	 mov	 BYTE PTR [eax], 0

; 361  :    }
; 362  : 
; 363  :    return VCI_NO_ERROR;

  00146	66 33 c0	 xor	 ax, ax
$L1891:

; 364  : 
; 365  : }

  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c2 14 00	 ret	 20			; 00000014H
_vciSeekForwardSC@20 ENDP
_TEXT	ENDS
PUBLIC	_vciExtractFromBitStreamSC@16
EXTRN	_isSingleStream@4:NEAR
EXTRN	_isValidStream@8:NEAR
EXTRN	_bytesInStream@8:NEAR
; Function compile flags: /Odt
;	COMDAT _vciExtractFromBitStreamSC@16
_TEXT	SEGMENT
_wBytesToExtract$ = -44
_dwCopyBitField$ = -40
_wSeekToSkip$ = -36
_dwSkipBitField$ = -32
_wReadByteOffset$ = -28
_vciCodecMblk$ = -24
_wSkipOverBytes$ = -20
_wSeekActual$ = -16
_wReadIncrementer$ = -12
_wSeekProjected$ = -8
_pStreamTable$ = -4
_pVciCodecMemBlk$ = 8
_pvciInputIOBlk$ = 12
_pvciOutputIOBlk$ = 16
_dwBitField$ = 20
_vciExtractFromBitStreamSC@16 PROC NEAR			; COMDAT

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi

; 379  :    const VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00007	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 380  :    unsigned short wReadByteOffset, wReadIncrementer, wBytesToExtract, wSkipOverBytes;
; 381  :    unsigned long dwSkipBitField=0x0, dwCopyBitField=dwBitField;

  0000e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _dwSkipBitField$[ebp], 0
  00015	8b 45 14	 mov	 eax, DWORD PTR _dwBitField$[ebp]
  00018	89 45 d8	 mov	 DWORD PTR _dwCopyBitField$[ebp], eax

; 382  :    short wSeekActual, wSeekProjected, wSeekToSkip;
; 383  :    const unsigned short *pStreamTable = NULL;

  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pStreamTable$[ebp], 0

; 384  : 
; 385  :    VCI_EXTRACT_IO_BLK_PARAM_CHECK(pvciInputIOBlk);

  00022	83 7d 0c 00	 cmp	 DWORD PTR _pvciInputIOBlk$[ebp], 0
  00026	75 09		 jne	 SHORT $L1937
  00028	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  0002c	e9 08 04 00 00	 jmp	 $L1923
$L1937:
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciInputIOBlk$[ebp]
  00034	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00038	75 09		 jne	 SHORT $L1938
  0003a	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  0003e	e9 f6 03 00 00	 jmp	 $L1923
$L1938:
  00043	8b 55 0c	 mov	 edx, DWORD PTR _pvciInputIOBlk$[ebp]
  00046	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciInputIOBlk$[ebp]
  0004d	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00051	3b c2		 cmp	 eax, edx
  00053	7c 09		 jl	 SHORT $L1939
  00055	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  00059	e9 db 03 00 00	 jmp	 $L1923
$L1939:
  0005e	8b 45 0c	 mov	 eax, DWORD PTR _pvciInputIOBlk$[ebp]
  00061	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00065	8b 55 0c	 mov	 edx, DWORD PTR _pvciInputIOBlk$[ebp]
  00068	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  0006c	3b c8		 cmp	 ecx, eax
  0006e	7c 09		 jl	 SHORT $L1940
  00070	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  00074	e9 c0 03 00 00	 jmp	 $L1923
$L1940:
  00079	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciInputIOBlk$[ebp]
  0007c	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  00080	83 fa 07	 cmp	 edx, 7
  00083	7e 09		 jle	 SHORT $L1941
  00085	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  00089	e9 ab 03 00 00	 jmp	 $L1923
$L1941:
  0008e	8b 45 0c	 mov	 eax, DWORD PTR _pvciInputIOBlk$[ebp]
  00091	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  00095	83 f9 07	 cmp	 ecx, 7
  00098	7e 09		 jle	 SHORT $L1942
  0009a	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  0009e	e9 96 03 00 00	 jmp	 $L1923
$L1942:

; 386  :    VCI_EXTRACT_IO_BLK_PARAM_CHECK(pvciOutputIOBlk);

  000a3	83 7d 10 00	 cmp	 DWORD PTR _pvciOutputIOBlk$[ebp], 0
  000a7	75 09		 jne	 SHORT $L1943
  000a9	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  000ad	e9 87 03 00 00	 jmp	 $L1923
$L1943:
  000b2	8b 55 10	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  000b5	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  000b9	75 09		 jne	 SHORT $L1944
  000bb	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  000bf	e9 75 03 00 00	 jmp	 $L1923
$L1944:
  000c4	8b 45 10	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  000c7	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  000cb	8b 55 10	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  000ce	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  000d2	3b c8		 cmp	 ecx, eax
  000d4	7c 09		 jl	 SHORT $L1945
  000d6	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  000da	e9 5a 03 00 00	 jmp	 $L1923
$L1945:
  000df	8b 4d 10	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  000e2	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  000e6	8b 45 10	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  000e9	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  000ed	3b d1		 cmp	 edx, ecx
  000ef	7c 09		 jl	 SHORT $L1946
  000f1	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  000f5	e9 3f 03 00 00	 jmp	 $L1923
$L1946:
  000fa	8b 55 10	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  000fd	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  00101	83 f8 07	 cmp	 eax, 7
  00104	7e 09		 jle	 SHORT $L1947
  00106	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  0010a	e9 2a 03 00 00	 jmp	 $L1923
$L1947:
  0010f	8b 4d 10	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00112	0f b6 51 14	 movzx	 edx, BYTE PTR [ecx+20]
  00116	83 fa 07	 cmp	 edx, 7
  00119	7e 09		 jle	 SHORT $L1948
  0011b	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  0011f	e9 15 03 00 00	 jmp	 $L1923
$L1948:

; 387  : 
; 388  :    /* First make sure that the handle passed is the correct one. */
; 389  :    if(!VCI_BLOCK_CHECK(pVciCodecMemBlk))

  00124	83 7d 08 00	 cmp	 DWORD PTR _pVciCodecMemBlk$[ebp], 0
  00128	74 0b		 je	 SHORT $L1951
  0012a	8b 45 08	 mov	 eax, DWORD PTR _pVciCodecMemBlk$[ebp]
  0012d	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  00133	74 09		 je	 SHORT $L1950
$L1951:

; 390  :       return VCI_NOT_VCI_HANDLE;

  00135	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00139	e9 fb 02 00 00	 jmp	 $L1923
$L1950:

; 391  : 
; 392  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pVciCodecMemBlk; 

  0013e	8b 4d 08	 mov	 ecx, DWORD PTR _pVciCodecMemBlk$[ebp]
  00141	89 4d e8	 mov	 DWORD PTR _vciCodecMblk$[ebp], ecx

; 393  : 
; 394  :    if(vciCodecMblk->pVciPlusMethodStruct)

  00144	8b 55 e8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00147	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  0014b	74 18		 je	 SHORT $L1953

; 395  :       if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)

  0014d	8b 45 e8	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00150	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00153	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  00157	74 0c		 je	 SHORT $L1953

; 396  :          pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

  00159	8b 55 e8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0015c	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0015f	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00162	89 4d fc	 mov	 DWORD PTR _pStreamTable$[ebp], ecx
$L1953:

; 397  : 
; 398  :    wReadByteOffset=pvciInputIOBlk->wVoxBufferReadByteOffset;

  00165	8b 55 0c	 mov	 edx, DWORD PTR _pvciInputIOBlk$[ebp]
  00168	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  0016c	66 89 45 e4	 mov	 WORD PTR _wReadByteOffset$[ebp], ax

; 399  :    pvciOutputIOBlk->wVoxBufferWriteByteOffset = pvciOutputIOBlk->wVoxBufferReadByteOffset;

  00170	8b 4d 10	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00173	8b 55 10	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00176	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  0017a	66 89 41 12	 mov	 WORD PTR [ecx+18], ax

; 400  : 
; 401  :    if(isValidStream(dwBitField, pStreamTable)) {

  0017e	8b 4d fc	 mov	 ecx, DWORD PTR _pStreamTable$[ebp]
  00181	51		 push	 ecx
  00182	8b 55 14	 mov	 edx, DWORD PTR _dwBitField$[ebp]
  00185	52		 push	 edx
  00186	e8 00 00 00 00	 call	 _isValidStream@8
  0018b	0f b6 c0	 movzx	 eax, al
  0018e	85 c0		 test	 eax, eax
  00190	74 19		 je	 SHORT $L1955

; 402  :       wBytesToExtract = bytesInStream(dwBitField, pStreamTable);

  00192	8b 4d fc	 mov	 ecx, DWORD PTR _pStreamTable$[ebp]
  00195	51		 push	 ecx
  00196	8b 55 14	 mov	 edx, DWORD PTR _dwBitField$[ebp]
  00199	52		 push	 edx
  0019a	e8 00 00 00 00	 call	 _bytesInStream@8
  0019f	66 89 45 d4	 mov	 WORD PTR _wBytesToExtract$[ebp], ax

; 403  :       wSkipOverBytes  = 0;

  001a3	66 c7 45 ec 00
	00		 mov	 WORD PTR _wSkipOverBytes$[ebp], 0

; 404  :    } else {

  001a9	eb 60		 jmp	 SHORT $L1956
$L1955:

; 405  :       if(!isSingleStream(dwBitField))

  001ab	8b 45 14	 mov	 eax, DWORD PTR _dwBitField$[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 _isSingleStream@4
  001b4	0f b6 c8	 movzx	 ecx, al
  001b7	85 c9		 test	 ecx, ecx
  001b9	75 09		 jne	 SHORT $L1959

; 406  :          return VCI_BITSTREAM_NOT_SUPPORTED;

  001bb	66 b8 2a 18	 mov	 ax, 6186		; 0000182aH
  001bf	e9 75 02 00 00	 jmp	 $L1923
$L1959:

; 407  : 
; 408  :       while(!(dwCopyBitField&0x01)) {

  001c4	8b 55 d8	 mov	 edx, DWORD PTR _dwCopyBitField$[ebp]
  001c7	83 e2 01	 and	 edx, 1
  001ca	85 d2		 test	 edx, edx
  001cc	75 1b		 jne	 SHORT $L1960

; 409  :          dwCopyBitField>>=1;

  001ce	8b 45 d8	 mov	 eax, DWORD PTR _dwCopyBitField$[ebp]
  001d1	d1 e8		 shr	 eax, 1
  001d3	89 45 d8	 mov	 DWORD PTR _dwCopyBitField$[ebp], eax

; 410  :          dwSkipBitField<<=1;

  001d6	8b 4d e0	 mov	 ecx, DWORD PTR _dwSkipBitField$[ebp]
  001d9	d1 e1		 shl	 ecx, 1
  001db	89 4d e0	 mov	 DWORD PTR _dwSkipBitField$[ebp], ecx

; 411  :          dwSkipBitField+=1;

  001de	8b 55 e0	 mov	 edx, DWORD PTR _dwSkipBitField$[ebp]
  001e1	83 c2 01	 add	 edx, 1
  001e4	89 55 e0	 mov	 DWORD PTR _dwSkipBitField$[ebp], edx

; 412  :       }

  001e7	eb db		 jmp	 SHORT $L1959
$L1960:

; 413  :       wBytesToExtract = bytesInStream(dwBitField, pStreamTable);

  001e9	8b 45 fc	 mov	 eax, DWORD PTR _pStreamTable$[ebp]
  001ec	50		 push	 eax
  001ed	8b 4d 14	 mov	 ecx, DWORD PTR _dwBitField$[ebp]
  001f0	51		 push	 ecx
  001f1	e8 00 00 00 00	 call	 _bytesInStream@8
  001f6	66 89 45 d4	 mov	 WORD PTR _wBytesToExtract$[ebp], ax

; 414  :       wSkipOverBytes  = bytesInStream(dwSkipBitField, pStreamTable);

  001fa	8b 55 fc	 mov	 edx, DWORD PTR _pStreamTable$[ebp]
  001fd	52		 push	 edx
  001fe	8b 45 e0	 mov	 eax, DWORD PTR _dwSkipBitField$[ebp]
  00201	50		 push	 eax
  00202	e8 00 00 00 00	 call	 _bytesInStream@8
  00207	66 89 45 ec	 mov	 WORD PTR _wSkipOverBytes$[ebp], ax
$L1956:

; 415  :    }
; 416  : 
; 417  :    wSeekActual = pvciInputIOBlk->wVoxBufferReadByteOffset;

  0020b	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciInputIOBlk$[ebp]
  0020e	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  00212	66 89 55 f0	 mov	 WORD PTR _wSeekActual$[ebp], dx
$L1962:

; 418  :    while(wReadByteOffset != pvciInputIOBlk->wVoxBufferWriteByteOffset) {

  00216	0f b7 45 e4	 movzx	 eax, WORD PTR _wReadByteOffset$[ebp]
  0021a	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciInputIOBlk$[ebp]
  0021d	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00221	3b c2		 cmp	 eax, edx
  00223	0f 84 0d 02 00
	00		 je	 $L1963

; 419  : 
; 420  :       wReadIncrementer = wSeekActual;

  00229	66 8b 45 f0	 mov	 ax, WORD PTR _wSeekActual$[ebp]
  0022d	66 89 45 f4	 mov	 WORD PTR _wReadIncrementer$[ebp], ax

; 421  : 
; 422  :       wSeekToSkip = (short)(wReadIncrementer+wSkipOverBytes);

  00231	0f b7 4d f4	 movzx	 ecx, WORD PTR _wReadIncrementer$[ebp]
  00235	0f b7 55 ec	 movzx	 edx, WORD PTR _wSkipOverBytes$[ebp]
  00239	03 ca		 add	 ecx, edx
  0023b	66 89 4d dc	 mov	 WORD PTR _wSeekToSkip$[ebp], cx

; 423  :       if(wSeekToSkip >= pvciInputIOBlk->wVoxBufferSize)

  0023f	0f bf 45 dc	 movsx	 eax, WORD PTR _wSeekToSkip$[ebp]
  00243	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciInputIOBlk$[ebp]
  00246	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  0024a	3b c2		 cmp	 eax, edx
  0024c	7c 11		 jl	 SHORT $L1965

; 424  :          wSeekToSkip = (short)(wSeekToSkip - pvciInputIOBlk->wVoxBufferSize);

  0024e	0f bf 45 dc	 movsx	 eax, WORD PTR _wSeekToSkip$[ebp]
  00252	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciInputIOBlk$[ebp]
  00255	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00259	2b c2		 sub	 eax, edx
  0025b	66 89 45 dc	 mov	 WORD PTR _wSeekToSkip$[ebp], ax
$L1965:

; 425  : 
; 426  :       wSeekProjected  = (short)(wSeekToSkip+wBytesToExtract);

  0025f	0f bf 45 dc	 movsx	 eax, WORD PTR _wSeekToSkip$[ebp]
  00263	0f b7 4d d4	 movzx	 ecx, WORD PTR _wBytesToExtract$[ebp]
  00267	03 c1		 add	 eax, ecx
  00269	66 89 45 f8	 mov	 WORD PTR _wSeekProjected$[ebp], ax

; 427  :       if(wSeekProjected >= pvciInputIOBlk->wVoxBufferSize)

  0026d	0f bf 55 f8	 movsx	 edx, WORD PTR _wSeekProjected$[ebp]
  00271	8b 45 0c	 mov	 eax, DWORD PTR _pvciInputIOBlk$[ebp]
  00274	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00278	3b d1		 cmp	 edx, ecx
  0027a	7c 11		 jl	 SHORT $L1968

; 428  :          wSeekProjected = (short)(wSeekProjected - pvciInputIOBlk->wVoxBufferSize);

  0027c	0f bf 55 f8	 movsx	 edx, WORD PTR _wSeekProjected$[ebp]
  00280	8b 45 0c	 mov	 eax, DWORD PTR _pvciInputIOBlk$[ebp]
  00283	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00287	2b d1		 sub	 edx, ecx
  00289	66 89 55 f8	 mov	 WORD PTR _wSeekProjected$[ebp], dx
$L1968:

; 429  : 
; 430  :       wSeekActual=seekForward(pvciInputIOBlk->pVoxBuffer, wReadByteOffset,
; 431  :          pvciInputIOBlk->wVoxBufferWriteByteOffset,
; 432  :          pvciInputIOBlk->wVoxBufferSize, 1, pStreamTable);

  0028d	8b 55 fc	 mov	 edx, DWORD PTR _pStreamTable$[ebp]
  00290	52		 push	 edx
  00291	6a 01		 push	 1
  00293	8b 45 0c	 mov	 eax, DWORD PTR _pvciInputIOBlk$[ebp]
  00296	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  0029a	51		 push	 ecx
  0029b	8b 55 0c	 mov	 edx, DWORD PTR _pvciInputIOBlk$[ebp]
  0029e	66 8b 42 12	 mov	 ax, WORD PTR [edx+18]
  002a2	50		 push	 eax
  002a3	66 8b 4d e4	 mov	 cx, WORD PTR _wReadByteOffset$[ebp]
  002a7	51		 push	 ecx
  002a8	8b 55 0c	 mov	 edx, DWORD PTR _pvciInputIOBlk$[ebp]
  002ab	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002ae	50		 push	 eax
  002af	e8 00 00 00 00	 call	 _seekForward@24
  002b4	66 89 45 f0	 mov	 WORD PTR _wSeekActual$[ebp], ax

; 433  : 
; 434  :       if(wSeekActual<0)

  002b8	0f bf 4d f0	 movsx	 ecx, WORD PTR _wSeekActual$[ebp]
  002bc	85 c9		 test	 ecx, ecx
  002be	7d 09		 jge	 SHORT $L1970

; 435  :          return VCI_BITSTREAM_CORRUPTED;

  002c0	66 b8 29 18	 mov	 ax, 6185		; 00001829H
  002c4	e9 70 01 00 00	 jmp	 $L1923
$L1970:

; 436  :       else 
; 437  :          wReadByteOffset=(unsigned short)wSeekActual;

  002c9	66 8b 55 f0	 mov	 dx, WORD PTR _wSeekActual$[ebp]
  002cd	66 89 55 e4	 mov	 WORD PTR _wReadByteOffset$[ebp], dx
$L1974:

; 438  : 
; 439  :       while((wReadIncrementer!=wSeekToSkip)&&(wReadIncrementer!=wReadByteOffset)) {

  002d1	0f b7 45 f4	 movzx	 eax, WORD PTR _wReadIncrementer$[ebp]
  002d5	0f bf 4d dc	 movsx	 ecx, WORD PTR _wSeekToSkip$[ebp]
  002d9	3b c1		 cmp	 eax, ecx
  002db	74 3a		 je	 SHORT $L1979
  002dd	0f b7 55 f4	 movzx	 edx, WORD PTR _wReadIncrementer$[ebp]
  002e1	0f b7 45 e4	 movzx	 eax, WORD PTR _wReadByteOffset$[ebp]
  002e5	3b d0		 cmp	 edx, eax
  002e7	74 2e		 je	 SHORT $L1979

; 440  : 
; 441  :          /*-----------------------------------------------------
; 442  :            This line was:
; 443  : 
; 444  :               pvciInputIOBlk->pVoxBuffer[wReadIncrementer++];
; 445  : 
; 446  :            but that seems unnecessary and produces a warning.
; 447  :          -----------------------------------------------------*/
; 448  :          wReadIncrementer++;

  002e9	66 8b 4d f4	 mov	 cx, WORD PTR _wReadIncrementer$[ebp]
  002ed	66 83 c1 01	 add	 cx, 1
  002f1	66 89 4d f4	 mov	 WORD PTR _wReadIncrementer$[ebp], cx

; 449  : 
; 450  :          if(wReadIncrementer >= pvciInputIOBlk->wVoxBufferSize)

  002f5	0f b7 55 f4	 movzx	 edx, WORD PTR _wReadIncrementer$[ebp]
  002f9	8b 45 0c	 mov	 eax, DWORD PTR _pvciInputIOBlk$[ebp]
  002fc	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00300	3b d1		 cmp	 edx, ecx
  00302	7c 11		 jl	 SHORT $L1976

; 451  :             wReadIncrementer= (unsigned short)(wReadIncrementer-pvciInputIOBlk->wVoxBufferSize);

  00304	0f b7 55 f4	 movzx	 edx, WORD PTR _wReadIncrementer$[ebp]
  00308	8b 45 0c	 mov	 eax, DWORD PTR _pvciInputIOBlk$[ebp]
  0030b	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0030f	2b d1		 sub	 edx, ecx
  00311	66 89 55 f4	 mov	 WORD PTR _wReadIncrementer$[ebp], dx
$L1976:

; 452  : 
; 453  :       } 

  00315	eb ba		 jmp	 SHORT $L1974
$L1979:

; 454  : 
; 455  :       while((wReadIncrementer!=wSeekProjected)&&(wReadIncrementer!=wReadByteOffset)) {

  00317	0f b7 55 f4	 movzx	 edx, WORD PTR _wReadIncrementer$[ebp]
  0031b	0f bf 45 f8	 movsx	 eax, WORD PTR _wSeekProjected$[ebp]
  0031f	3b d0		 cmp	 edx, eax
  00321	0f 84 b1 00 00
	00		 je	 $L1980
  00327	0f b7 4d f4	 movzx	 ecx, WORD PTR _wReadIncrementer$[ebp]
  0032b	0f b7 55 e4	 movzx	 edx, WORD PTR _wReadByteOffset$[ebp]
  0032f	3b ca		 cmp	 ecx, edx
  00331	0f 84 a1 00 00
	00		 je	 $L1980

; 456  :          pvciOutputIOBlk->pVoxBuffer[pvciOutputIOBlk->wVoxBufferWriteByteOffset++]=
; 457  :             pvciInputIOBlk->pVoxBuffer[wReadIncrementer++];

  00337	0f b7 45 f4	 movzx	 eax, WORD PTR _wReadIncrementer$[ebp]
  0033b	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciInputIOBlk$[ebp]
  0033e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00341	8b 4d 10	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00344	0f b7 49 12	 movzx	 ecx, WORD PTR [ecx+18]
  00348	8b 75 10	 mov	 esi, DWORD PTR _pvciOutputIOBlk$[ebp]
  0034b	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  0034e	8a 14 10	 mov	 dl, BYTE PTR [eax+edx]
  00351	88 14 31	 mov	 BYTE PTR [ecx+esi], dl
  00354	8b 45 10	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  00357	66 8b 48 12	 mov	 cx, WORD PTR [eax+18]
  0035b	66 83 c1 01	 add	 cx, 1
  0035f	8b 55 10	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00362	66 89 4a 12	 mov	 WORD PTR [edx+18], cx
  00366	66 8b 45 f4	 mov	 ax, WORD PTR _wReadIncrementer$[ebp]
  0036a	66 05 01 00	 add	 ax, 1
  0036e	66 89 45 f4	 mov	 WORD PTR _wReadIncrementer$[ebp], ax

; 458  : 
; 459  :          if(pvciOutputIOBlk->wVoxBufferWriteByteOffset >= pvciOutputIOBlk->wVoxBufferSize)

  00372	8b 4d 10	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00375	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00379	8b 45 10	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  0037c	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00380	3b d1		 cmp	 edx, ecx
  00382	7c 17		 jl	 SHORT $L1981

; 460  :             pvciOutputIOBlk->wVoxBufferWriteByteOffset = 
; 461  :             (unsigned short)(pvciOutputIOBlk->wVoxBufferWriteByteOffset - 
; 462  :                     pvciOutputIOBlk->wVoxBufferSize);

  00384	8b 55 10	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00387	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  0038b	8b 4d 10	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  0038e	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00392	2b c2		 sub	 eax, edx
  00394	8b 4d 10	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00397	66 89 41 12	 mov	 WORD PTR [ecx+18], ax
$L1981:

; 463  : 
; 464  :          if(wReadIncrementer >= pvciInputIOBlk->wVoxBufferSize)

  0039b	0f b7 55 f4	 movzx	 edx, WORD PTR _wReadIncrementer$[ebp]
  0039f	8b 45 0c	 mov	 eax, DWORD PTR _pvciInputIOBlk$[ebp]
  003a2	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  003a6	3b d1		 cmp	 edx, ecx
  003a8	7c 11		 jl	 SHORT $L1983

; 465  :             wReadIncrementer = (unsigned short)(wReadIncrementer-pvciInputIOBlk->wVoxBufferSize);

  003aa	0f b7 55 f4	 movzx	 edx, WORD PTR _wReadIncrementer$[ebp]
  003ae	8b 45 0c	 mov	 eax, DWORD PTR _pvciInputIOBlk$[ebp]
  003b1	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  003b5	2b d1		 sub	 edx, ecx
  003b7	66 89 55 f4	 mov	 WORD PTR _wReadIncrementer$[ebp], dx
$L1983:

; 466  : 
; 467  :          if(pvciOutputIOBlk->wVoxBufferWriteByteOffset==
; 468  :             pvciOutputIOBlk->wVoxBufferReadByteOffset) 

  003bb	8b 55 10	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  003be	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  003c2	8b 4d 10	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  003c5	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  003c9	3b c2		 cmp	 eax, edx
  003cb	75 06		 jne	 SHORT $L1985

; 469  :             return VCI_BITSTREAM_INSUFFICIENT;

  003cd	66 b8 2b 18	 mov	 ax, 6187		; 0000182bH
  003d1	eb 66		 jmp	 SHORT $L1923
$L1985:

; 470  :       }

  003d3	e9 3f ff ff ff	 jmp	 $L1979
$L1980:

; 471  : 
; 472  :       /* set the continuation bit to false */
; 473  :       if(pvciOutputIOBlk->wVoxBufferWriteByteOffset)

  003d8	8b 45 10	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  003db	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  003df	85 c9		 test	 ecx, ecx
  003e1	74 28		 je	 SHORT $L1986

; 474  :          pvciOutputIOBlk->pVoxBuffer[pvciOutputIOBlk->wVoxBufferWriteByteOffset-1] &= 0x07F;

  003e3	8b 55 10	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  003e6	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  003ea	8b 4d 10	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  003ed	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  003f0	0f b6 44 02 ff	 movzx	 eax, BYTE PTR [edx+eax-1]
  003f5	83 e0 7f	 and	 eax, 127		; 0000007fH
  003f8	8b 4d 10	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  003fb	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  003ff	8b 4d 10	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00402	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00405	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al

; 475  :       else

  00409	eb 26		 jmp	 SHORT $L1987
$L1986:

; 476  :          pvciOutputIOBlk->pVoxBuffer[pvciOutputIOBlk->wVoxBufferSize-1] &= 0x07F;

  0040b	8b 55 10	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  0040e	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00412	8b 4d 10	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00415	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00418	0f b6 44 02 ff	 movzx	 eax, BYTE PTR [edx+eax-1]
  0041d	83 e0 7f	 and	 eax, 127		; 0000007fH
  00420	8b 4d 10	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00423	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00427	8b 4d 10	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  0042a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0042d	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
$L1987:

; 477  :    }

  00431	e9 e0 fd ff ff	 jmp	 $L1962
$L1963:

; 478  :    return VCI_NO_ERROR;

  00436	66 33 c0	 xor	 ax, ax
$L1923:

; 479  : }

  00439	5e		 pop	 esi
  0043a	8b e5		 mov	 esp, ebp
  0043c	5d		 pop	 ebp
  0043d	c2 10 00	 ret	 16			; 00000010H
_vciExtractFromBitStreamSC@16 ENDP
_TEXT	ENDS
PUBLIC	_vciCombineBitStreamSC@24
; Function compile flags: /Odt
;	COMDAT _vciCombineBitStreamSC@24
_TEXT	SEGMENT
_j$ = -52
_pCodecIOTempBlk$ = -48
_wNumOfFrames$ = -44
_vciCodecMblk$ = -40
_ScCodecTemp$ = -36
_wReadB$ = -32
_wBytesA$ = -28
_wBytesB$ = -24
_wBytesOut$ = -20
_i$ = -16
_wReadA$ = -12
_pStreamTable$ = -8
_wNumOfBytesInBuffer$ = -4
_pVciCodecMemBlk$ = 8
_pvciInputAIOBlk$ = 12
_pvciInputBIOBlk$ = 16
_pvciOutputIOBlk$ = 20
_ScCodecA$ = 24
_ScCodecB$ = 28
_vciCombineBitStreamSC@24 PROC NEAR			; COMDAT

; 493  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	56		 push	 esi

; 494  :    const VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00007	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 495  :    unsigned short wBytesA, wBytesB, wBytesOut, wNumOfFrames, i, j;
; 496  :    short wNumOfBytesInBuffer;
; 497  :    unsigned short wReadA, wReadB;
; 498  :    const VCI_CODEC_IO_BLOCK *pCodecIOTempBlk;
; 499  :    unsigned long ScCodecTemp;
; 500  :    const unsigned short *pStreamTable = NULL;

  0000e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pStreamTable$[ebp], 0

; 501  : 
; 502  :    /* First make sure that the handle passed is the correct one. */
; 503  :    if(!VCI_BLOCK_CHECK(pVciCodecMemBlk))

  00015	83 7d 08 00	 cmp	 DWORD PTR _pVciCodecMemBlk$[ebp], 0
  00019	74 0b		 je	 SHORT $L2018
  0001b	8b 45 08	 mov	 eax, DWORD PTR _pVciCodecMemBlk$[ebp]
  0001e	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  00024	74 09		 je	 SHORT $L2017
$L2018:

; 504  :       return VCI_NOT_VCI_HANDLE;

  00026	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  0002a	e9 5f 05 00 00	 jmp	 $L2000
$L2017:

; 505  : 
; 506  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pVciCodecMemBlk; 

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _pVciCodecMemBlk$[ebp]
  00032	89 4d d8	 mov	 DWORD PTR _vciCodecMblk$[ebp], ecx

; 507  : 
; 508  :    VCI_EXTRACT_IO_BLK_PARAM_CHECK(pvciInputAIOBlk);

  00035	83 7d 0c 00	 cmp	 DWORD PTR _pvciInputAIOBlk$[ebp], 0
  00039	75 09		 jne	 SHORT $L2020
  0003b	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  0003f	e9 4a 05 00 00	 jmp	 $L2000
$L2020:
  00044	8b 55 0c	 mov	 edx, DWORD PTR _pvciInputAIOBlk$[ebp]
  00047	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  0004b	75 09		 jne	 SHORT $L2021
  0004d	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  00051	e9 38 05 00 00	 jmp	 $L2000
$L2021:
  00056	8b 45 0c	 mov	 eax, DWORD PTR _pvciInputAIOBlk$[ebp]
  00059	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  0005d	8b 55 0c	 mov	 edx, DWORD PTR _pvciInputAIOBlk$[ebp]
  00060	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00064	3b c8		 cmp	 ecx, eax
  00066	7c 09		 jl	 SHORT $L2022
  00068	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  0006c	e9 1d 05 00 00	 jmp	 $L2000
$L2022:
  00071	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciInputAIOBlk$[ebp]
  00074	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00078	8b 45 0c	 mov	 eax, DWORD PTR _pvciInputAIOBlk$[ebp]
  0007b	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0007f	3b d1		 cmp	 edx, ecx
  00081	7c 09		 jl	 SHORT $L2023
  00083	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  00087	e9 02 05 00 00	 jmp	 $L2000
$L2023:
  0008c	8b 55 0c	 mov	 edx, DWORD PTR _pvciInputAIOBlk$[ebp]
  0008f	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  00093	83 f8 07	 cmp	 eax, 7
  00096	7e 09		 jle	 SHORT $L2024
  00098	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  0009c	e9 ed 04 00 00	 jmp	 $L2000
$L2024:
  000a1	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciInputAIOBlk$[ebp]
  000a4	0f b6 51 14	 movzx	 edx, BYTE PTR [ecx+20]
  000a8	83 fa 07	 cmp	 edx, 7
  000ab	7e 09		 jle	 SHORT $L2025
  000ad	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  000b1	e9 d8 04 00 00	 jmp	 $L2000
$L2025:

; 509  :    VCI_EXTRACT_IO_BLK_PARAM_CHECK(pvciInputBIOBlk);

  000b6	83 7d 10 00	 cmp	 DWORD PTR _pvciInputBIOBlk$[ebp], 0
  000ba	75 09		 jne	 SHORT $L2026
  000bc	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  000c0	e9 c9 04 00 00	 jmp	 $L2000
$L2026:
  000c5	8b 45 10	 mov	 eax, DWORD PTR _pvciInputBIOBlk$[ebp]
  000c8	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000cc	75 09		 jne	 SHORT $L2027
  000ce	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  000d2	e9 b7 04 00 00	 jmp	 $L2000
$L2027:
  000d7	8b 4d 10	 mov	 ecx, DWORD PTR _pvciInputBIOBlk$[ebp]
  000da	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  000de	8b 45 10	 mov	 eax, DWORD PTR _pvciInputBIOBlk$[ebp]
  000e1	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  000e5	3b d1		 cmp	 edx, ecx
  000e7	7c 09		 jl	 SHORT $L2028
  000e9	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  000ed	e9 9c 04 00 00	 jmp	 $L2000
$L2028:
  000f2	8b 55 10	 mov	 edx, DWORD PTR _pvciInputBIOBlk$[ebp]
  000f5	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  000f9	8b 4d 10	 mov	 ecx, DWORD PTR _pvciInputBIOBlk$[ebp]
  000fc	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00100	3b c2		 cmp	 eax, edx
  00102	7c 09		 jl	 SHORT $L2029
  00104	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  00108	e9 81 04 00 00	 jmp	 $L2000
$L2029:
  0010d	8b 45 10	 mov	 eax, DWORD PTR _pvciInputBIOBlk$[ebp]
  00110	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00114	83 f9 07	 cmp	 ecx, 7
  00117	7e 09		 jle	 SHORT $L2030
  00119	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  0011d	e9 6c 04 00 00	 jmp	 $L2000
$L2030:
  00122	8b 55 10	 mov	 edx, DWORD PTR _pvciInputBIOBlk$[ebp]
  00125	0f b6 42 14	 movzx	 eax, BYTE PTR [edx+20]
  00129	83 f8 07	 cmp	 eax, 7
  0012c	7e 09		 jle	 SHORT $L2031
  0012e	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  00132	e9 57 04 00 00	 jmp	 $L2000
$L2031:

; 510  :    VCI_EXTRACT_IO_BLK_PARAM_CHECK(pvciOutputIOBlk);

  00137	83 7d 14 00	 cmp	 DWORD PTR _pvciOutputIOBlk$[ebp], 0
  0013b	75 09		 jne	 SHORT $L2032
  0013d	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  00141	e9 48 04 00 00	 jmp	 $L2000
$L2032:
  00146	8b 4d 14	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00149	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0014d	75 09		 jne	 SHORT $L2033
  0014f	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  00153	e9 36 04 00 00	 jmp	 $L2000
$L2033:
  00158	8b 55 14	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  0015b	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  0015f	8b 4d 14	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00162	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00166	3b c2		 cmp	 eax, edx
  00168	7c 09		 jl	 SHORT $L2034
  0016a	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  0016e	e9 1b 04 00 00	 jmp	 $L2000
$L2034:
  00173	8b 45 14	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  00176	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  0017a	8b 55 14	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  0017d	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00181	3b c8		 cmp	 ecx, eax
  00183	7c 09		 jl	 SHORT $L2035
  00185	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  00189	e9 00 04 00 00	 jmp	 $L2000
$L2035:
  0018e	8b 4d 14	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00191	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  00195	83 fa 07	 cmp	 edx, 7
  00198	7e 09		 jle	 SHORT $L2036
  0019a	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  0019e	e9 eb 03 00 00	 jmp	 $L2000
$L2036:
  001a3	8b 45 14	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  001a6	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  001aa	83 f9 07	 cmp	 ecx, 7
  001ad	7e 09		 jle	 SHORT $L2037
  001af	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  001b3	e9 d6 03 00 00	 jmp	 $L2000
$L2037:

; 511  : 
; 512  :    if(vciCodecMblk->pVciPlusMethodStruct)

  001b8	8b 55 d8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  001bb	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  001bf	74 18		 je	 SHORT $L2038

; 513  :       if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)

  001c1	8b 45 d8	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  001c4	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001c7	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  001cb	74 0c		 je	 SHORT $L2038

; 514  :          pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

  001cd	8b 55 d8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  001d0	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  001d3	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  001d6	89 4d f8	 mov	 DWORD PTR _pStreamTable$[ebp], ecx
$L2038:

; 515  : 
; 516  :    
; 517  :    if(ScCodecA&ScCodecB)

  001d9	8b 55 18	 mov	 edx, DWORD PTR _ScCodecA$[ebp]
  001dc	23 55 1c	 and	 edx, DWORD PTR _ScCodecB$[ebp]
  001df	85 d2		 test	 edx, edx
  001e1	74 09		 je	 SHORT $L2040

; 518  :       return VCI_BITSTREAM_NOT_SUPPORTED;

  001e3	66 b8 2a 18	 mov	 ax, 6186		; 0000182aH
  001e7	e9 a2 03 00 00	 jmp	 $L2000
$L2040:

; 519  : 
; 520  :    if(!isValidStream((ScCodecA|ScCodecB), pStreamTable))

  001ec	8b 45 f8	 mov	 eax, DWORD PTR _pStreamTable$[ebp]
  001ef	50		 push	 eax
  001f0	8b 4d 18	 mov	 ecx, DWORD PTR _ScCodecA$[ebp]
  001f3	0b 4d 1c	 or	 ecx, DWORD PTR _ScCodecB$[ebp]
  001f6	51		 push	 ecx
  001f7	e8 00 00 00 00	 call	 _isValidStream@8
  001fc	0f b6 d0	 movzx	 edx, al
  001ff	85 d2		 test	 edx, edx
  00201	75 09		 jne	 SHORT $L2041

; 521  :       return VCI_BITSTREAM_NOT_SUPPORTED;

  00203	66 b8 2a 18	 mov	 ax, 6186		; 0000182aH
  00207	e9 82 03 00 00	 jmp	 $L2000
$L2041:

; 522  : 
; 523  :    /* maybe we have to do a variable shuffle */
; 524  :    if(!(ScCodecA&0x01)) {

  0020c	8b 45 18	 mov	 eax, DWORD PTR _ScCodecA$[ebp]
  0020f	83 e0 01	 and	 eax, 1
  00212	85 c0		 test	 eax, eax
  00214	75 24		 jne	 SHORT $L2042

; 525  :       ScCodecTemp = ScCodecA;

  00216	8b 4d 18	 mov	 ecx, DWORD PTR _ScCodecA$[ebp]
  00219	89 4d dc	 mov	 DWORD PTR _ScCodecTemp$[ebp], ecx

; 526  :       ScCodecA    = ScCodecB;

  0021c	8b 55 1c	 mov	 edx, DWORD PTR _ScCodecB$[ebp]
  0021f	89 55 18	 mov	 DWORD PTR _ScCodecA$[ebp], edx

; 527  :       ScCodecB    = ScCodecTemp;

  00222	8b 45 dc	 mov	 eax, DWORD PTR _ScCodecTemp$[ebp]
  00225	89 45 1c	 mov	 DWORD PTR _ScCodecB$[ebp], eax

; 528  : 
; 529  :       pCodecIOTempBlk = pvciInputAIOBlk;

  00228	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciInputAIOBlk$[ebp]
  0022b	89 4d d0	 mov	 DWORD PTR _pCodecIOTempBlk$[ebp], ecx

; 530  :       pvciInputAIOBlk = pvciInputBIOBlk;

  0022e	8b 55 10	 mov	 edx, DWORD PTR _pvciInputBIOBlk$[ebp]
  00231	89 55 0c	 mov	 DWORD PTR _pvciInputAIOBlk$[ebp], edx

; 531  :       pvciInputBIOBlk = pCodecIOTempBlk;

  00234	8b 45 d0	 mov	 eax, DWORD PTR _pCodecIOTempBlk$[ebp]
  00237	89 45 10	 mov	 DWORD PTR _pvciInputBIOBlk$[ebp], eax
$L2042:

; 532  :    }
; 533  : 
; 534  :    wBytesA=bytesInStream(ScCodecA, pStreamTable);

  0023a	8b 4d f8	 mov	 ecx, DWORD PTR _pStreamTable$[ebp]
  0023d	51		 push	 ecx
  0023e	8b 55 18	 mov	 edx, DWORD PTR _ScCodecA$[ebp]
  00241	52		 push	 edx
  00242	e8 00 00 00 00	 call	 _bytesInStream@8
  00247	66 89 45 e4	 mov	 WORD PTR _wBytesA$[ebp], ax

; 535  :    wBytesB=bytesInStream(ScCodecB, pStreamTable);

  0024b	8b 45 f8	 mov	 eax, DWORD PTR _pStreamTable$[ebp]
  0024e	50		 push	 eax
  0024f	8b 4d 1c	 mov	 ecx, DWORD PTR _ScCodecB$[ebp]
  00252	51		 push	 ecx
  00253	e8 00 00 00 00	 call	 _bytesInStream@8
  00258	66 89 45 e8	 mov	 WORD PTR _wBytesB$[ebp], ax

; 536  :    wBytesOut=(unsigned short)(wBytesA+wBytesB);

  0025c	0f b7 55 e4	 movzx	 edx, WORD PTR _wBytesA$[ebp]
  00260	0f b7 45 e8	 movzx	 eax, WORD PTR _wBytesB$[ebp]
  00264	03 d0		 add	 edx, eax
  00266	66 89 55 ec	 mov	 WORD PTR _wBytesOut$[ebp], dx

; 537  : 
; 538  :    /* the following block etablishes the number of itterations that we'll have to do */
; 539  :    wNumOfBytesInBuffer=
; 540  :       (short)(pvciInputAIOBlk->wVoxBufferWriteByteOffset
; 541  :               -pvciInputAIOBlk->wVoxBufferReadByteOffset);

  0026a	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciInputAIOBlk$[ebp]
  0026d	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00271	8b 45 0c	 mov	 eax, DWORD PTR _pvciInputAIOBlk$[ebp]
  00274	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00278	2b d1		 sub	 edx, ecx
  0027a	66 89 55 fc	 mov	 WORD PTR _wNumOfBytesInBuffer$[ebp], dx

; 542  : 
; 543  :    if(wNumOfBytesInBuffer<=0)

  0027e	0f bf 55 fc	 movsx	 edx, WORD PTR _wNumOfBytesInBuffer$[ebp]
  00282	85 d2		 test	 edx, edx
  00284	7f 11		 jg	 SHORT $L2045

; 544  :       wNumOfBytesInBuffer=(short)(wNumOfBytesInBuffer + pvciInputAIOBlk->wVoxBufferSize);

  00286	0f bf 45 fc	 movsx	 eax, WORD PTR _wNumOfBytesInBuffer$[ebp]
  0028a	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciInputAIOBlk$[ebp]
  0028d	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00291	03 c2		 add	 eax, edx
  00293	66 89 45 fc	 mov	 WORD PTR _wNumOfBytesInBuffer$[ebp], ax
$L2045:

; 545  : 
; 546  :    if(wNumOfBytesInBuffer%wBytesA) /* shouldn't have any left over bits */

  00297	0f bf 45 fc	 movsx	 eax, WORD PTR _wNumOfBytesInBuffer$[ebp]
  0029b	0f b7 4d e4	 movzx	 ecx, WORD PTR _wBytesA$[ebp]
  0029f	99		 cdq
  002a0	f7 f9		 idiv	 ecx
  002a2	85 d2		 test	 edx, edx
  002a4	74 09		 je	 SHORT $L2047

; 547  :       return VCI_BITSTREAM_CORRUPTED;

  002a6	66 b8 29 18	 mov	 ax, 6185		; 00001829H
  002aa	e9 df 02 00 00	 jmp	 $L2000
$L2047:

; 548  : 
; 549  :    wNumOfFrames=(unsigned short)(wNumOfBytesInBuffer/wBytesA);

  002af	0f bf 45 fc	 movsx	 eax, WORD PTR _wNumOfBytesInBuffer$[ebp]
  002b3	0f b7 4d e4	 movzx	 ecx, WORD PTR _wBytesA$[ebp]
  002b7	99		 cdq
  002b8	f7 f9		 idiv	 ecx
  002ba	66 89 45 d4	 mov	 WORD PTR _wNumOfFrames$[ebp], ax

; 550  : 
; 551  :    /* checking B buffer */
; 552  :    wNumOfBytesInBuffer=
; 553  :       (short)(pvciInputBIOBlk->wVoxBufferWriteByteOffset
; 554  :              -pvciInputBIOBlk->wVoxBufferReadByteOffset);

  002be	8b 55 10	 mov	 edx, DWORD PTR _pvciInputBIOBlk$[ebp]
  002c1	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  002c5	8b 4d 10	 mov	 ecx, DWORD PTR _pvciInputBIOBlk$[ebp]
  002c8	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  002cc	2b c2		 sub	 eax, edx
  002ce	66 89 45 fc	 mov	 WORD PTR _wNumOfBytesInBuffer$[ebp], ax

; 555  : 
; 556  :    if(wNumOfBytesInBuffer<=0)

  002d2	0f bf 45 fc	 movsx	 eax, WORD PTR _wNumOfBytesInBuffer$[ebp]
  002d6	85 c0		 test	 eax, eax
  002d8	7f 11		 jg	 SHORT $L2050

; 557  :       wNumOfBytesInBuffer=(short)(wNumOfBytesInBuffer+pvciInputBIOBlk->wVoxBufferSize);

  002da	0f bf 4d fc	 movsx	 ecx, WORD PTR _wNumOfBytesInBuffer$[ebp]
  002de	8b 55 10	 mov	 edx, DWORD PTR _pvciInputBIOBlk$[ebp]
  002e1	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  002e5	03 c8		 add	 ecx, eax
  002e7	66 89 4d fc	 mov	 WORD PTR _wNumOfBytesInBuffer$[ebp], cx
$L2050:

; 558  : 
; 559  :    if(wNumOfBytesInBuffer%wBytesB) /* shouldn't have any left over bytes */

  002eb	0f bf 45 fc	 movsx	 eax, WORD PTR _wNumOfBytesInBuffer$[ebp]
  002ef	0f b7 4d e8	 movzx	 ecx, WORD PTR _wBytesB$[ebp]
  002f3	99		 cdq
  002f4	f7 f9		 idiv	 ecx
  002f6	85 d2		 test	 edx, edx
  002f8	74 09		 je	 SHORT $L2052

; 560  :       return VCI_BITSTREAM_CORRUPTED;

  002fa	66 b8 29 18	 mov	 ax, 6185		; 00001829H
  002fe	e9 8b 02 00 00	 jmp	 $L2000
$L2052:

; 561  : 
; 562  :    if(wNumOfFrames!=wNumOfBytesInBuffer/wBytesB)

  00303	0f b7 4d d4	 movzx	 ecx, WORD PTR _wNumOfFrames$[ebp]
  00307	0f bf 45 fc	 movsx	 eax, WORD PTR _wNumOfBytesInBuffer$[ebp]
  0030b	0f b7 75 e8	 movzx	 esi, WORD PTR _wBytesB$[ebp]
  0030f	99		 cdq
  00310	f7 fe		 idiv	 esi
  00312	3b c8		 cmp	 ecx, eax
  00314	74 09		 je	 SHORT $L2053

; 563  :       return VCI_BITSTREAM_INSUFFICIENT; /* Num of frames doesn't match with A */

  00316	66 b8 2b 18	 mov	 ax, 6187		; 0000182bH
  0031a	e9 6f 02 00 00	 jmp	 $L2000
$L2053:

; 564  : 
; 565  :    /* lastly checking C buffer */
; 566  :    wNumOfBytesInBuffer=
; 567  :       (short)(pvciOutputIOBlk->wVoxBufferWriteByteOffset
; 568  :               -pvciOutputIOBlk->wVoxBufferReadByteOffset);

  0031f	8b 55 14	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00322	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  00326	8b 4d 14	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00329	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  0032d	2b c2		 sub	 eax, edx
  0032f	66 89 45 fc	 mov	 WORD PTR _wNumOfBytesInBuffer$[ebp], ax

; 569  : 
; 570  :    if(wNumOfBytesInBuffer<=0)

  00333	0f bf 45 fc	 movsx	 eax, WORD PTR _wNumOfBytesInBuffer$[ebp]
  00337	85 c0		 test	 eax, eax
  00339	7f 11		 jg	 SHORT $L2055

; 571  :       wNumOfBytesInBuffer=(short)(wNumOfBytesInBuffer+pvciOutputIOBlk->wVoxBufferSize);

  0033b	0f bf 4d fc	 movsx	 ecx, WORD PTR _wNumOfBytesInBuffer$[ebp]
  0033f	8b 55 14	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00342	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00346	03 c8		 add	 ecx, eax
  00348	66 89 4d fc	 mov	 WORD PTR _wNumOfBytesInBuffer$[ebp], cx
$L2055:

; 572  : 
; 573  :    if(wNumOfBytesInBuffer/wBytesOut<wNumOfFrames)

  0034c	0f bf 45 fc	 movsx	 eax, WORD PTR _wNumOfBytesInBuffer$[ebp]
  00350	0f b7 4d ec	 movzx	 ecx, WORD PTR _wBytesOut$[ebp]
  00354	99		 cdq
  00355	f7 f9		 idiv	 ecx
  00357	0f b7 55 d4	 movzx	 edx, WORD PTR _wNumOfFrames$[ebp]
  0035b	3b c2		 cmp	 eax, edx
  0035d	7d 09		 jge	 SHORT $L2057

; 574  :       return VCI_BITSTREAM_INSUFFICIENT;

  0035f	66 b8 2b 18	 mov	 ax, 6187		; 0000182bH
  00363	e9 26 02 00 00	 jmp	 $L2000
$L2057:

; 575  :    else if(wNumOfBytesInBuffer/wBytesOut==wNumOfFrames)

  00368	0f bf 45 fc	 movsx	 eax, WORD PTR _wNumOfBytesInBuffer$[ebp]
  0036c	0f b7 4d ec	 movzx	 ecx, WORD PTR _wBytesOut$[ebp]
  00370	99		 cdq
  00371	f7 f9		 idiv	 ecx
  00373	0f b7 55 d4	 movzx	 edx, WORD PTR _wNumOfFrames$[ebp]
  00377	3b c2		 cmp	 eax, edx
  00379	75 18		 jne	 SHORT $L2058

; 576  :       if(!(wNumOfBytesInBuffer%wBytesOut)) /* need at least one extra byte!! */

  0037b	0f bf 45 fc	 movsx	 eax, WORD PTR _wNumOfBytesInBuffer$[ebp]
  0037f	0f b7 4d ec	 movzx	 ecx, WORD PTR _wBytesOut$[ebp]
  00383	99		 cdq
  00384	f7 f9		 idiv	 ecx
  00386	85 d2		 test	 edx, edx
  00388	75 09		 jne	 SHORT $L2058

; 577  :          return VCI_BITSTREAM_INSUFFICIENT;

  0038a	66 b8 2b 18	 mov	 ax, 6187		; 0000182bH
  0038e	e9 fb 01 00 00	 jmp	 $L2000
$L2058:

; 578  :   
; 579  :    wReadA=pvciInputAIOBlk->wVoxBufferReadByteOffset;

  00393	8b 55 0c	 mov	 edx, DWORD PTR _pvciInputAIOBlk$[ebp]
  00396	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  0039a	66 89 45 f4	 mov	 WORD PTR _wReadA$[ebp], ax

; 580  :    wReadB=pvciInputBIOBlk->wVoxBufferReadByteOffset;

  0039e	8b 4d 10	 mov	 ecx, DWORD PTR _pvciInputBIOBlk$[ebp]
  003a1	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  003a5	66 89 55 e0	 mov	 WORD PTR _wReadB$[ebp], dx

; 581  : 
; 582  :    for(i=0;i<wNumOfFrames;i++) {

  003a9	66 c7 45 f0 00
	00		 mov	 WORD PTR _i$[ebp], 0
  003af	eb 0c		 jmp	 SHORT $L2061
$L2062:
  003b1	66 8b 45 f0	 mov	 ax, WORD PTR _i$[ebp]
  003b5	66 05 01 00	 add	 ax, 1
  003b9	66 89 45 f0	 mov	 WORD PTR _i$[ebp], ax
$L2061:
  003bd	0f b7 4d f0	 movzx	 ecx, WORD PTR _i$[ebp]
  003c1	0f b7 55 d4	 movzx	 edx, WORD PTR _wNumOfFrames$[ebp]
  003c5	3b ca		 cmp	 ecx, edx
  003c7	0f 8d be 01 00
	00		 jge	 $L2063

; 583  :       for(j=0;j<wBytesA;j++) {

  003cd	66 c7 45 cc 00
	00		 mov	 WORD PTR _j$[ebp], 0
  003d3	eb 0c		 jmp	 SHORT $L2064
$L2065:
  003d5	66 8b 45 cc	 mov	 ax, WORD PTR _j$[ebp]
  003d9	66 05 01 00	 add	 ax, 1
  003dd	66 89 45 cc	 mov	 WORD PTR _j$[ebp], ax
$L2064:
  003e1	0f b7 4d cc	 movzx	 ecx, WORD PTR _j$[ebp]
  003e5	0f b7 55 e4	 movzx	 edx, WORD PTR _wBytesA$[ebp]
  003e9	3b ca		 cmp	 ecx, edx
  003eb	0f 8d 89 00 00
	00		 jge	 $L2066

; 584  :          pvciOutputIOBlk->pVoxBuffer[pvciOutputIOBlk->wVoxBufferWriteByteOffset++]=
; 585  :             pvciInputAIOBlk->pVoxBuffer[wReadA++];

  003f1	0f b7 45 f4	 movzx	 eax, WORD PTR _wReadA$[ebp]
  003f5	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciInputAIOBlk$[ebp]
  003f8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  003fb	8b 4d 14	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  003fe	0f b7 49 12	 movzx	 ecx, WORD PTR [ecx+18]
  00402	8b 75 14	 mov	 esi, DWORD PTR _pvciOutputIOBlk$[ebp]
  00405	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00408	8a 14 10	 mov	 dl, BYTE PTR [eax+edx]
  0040b	88 14 31	 mov	 BYTE PTR [ecx+esi], dl
  0040e	8b 45 14	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  00411	66 8b 48 12	 mov	 cx, WORD PTR [eax+18]
  00415	66 83 c1 01	 add	 cx, 1
  00419	8b 55 14	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  0041c	66 89 4a 12	 mov	 WORD PTR [edx+18], cx
  00420	66 8b 45 f4	 mov	 ax, WORD PTR _wReadA$[ebp]
  00424	66 05 01 00	 add	 ax, 1
  00428	66 89 45 f4	 mov	 WORD PTR _wReadA$[ebp], ax

; 586  : 
; 587  :          if(pvciOutputIOBlk->wVoxBufferWriteByteOffset>=pvciOutputIOBlk->wVoxBufferSize)

  0042c	8b 4d 14	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  0042f	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00433	8b 45 14	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  00436	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0043a	3b d1		 cmp	 edx, ecx
  0043c	7c 17		 jl	 SHORT $L2067

; 588  :             pvciOutputIOBlk->wVoxBufferWriteByteOffset=
; 589  :                 (unsigned short)(pvciOutputIOBlk->wVoxBufferWriteByteOffset-
; 590  :                                  pvciOutputIOBlk->wVoxBufferSize);

  0043e	8b 55 14	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00441	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  00445	8b 4d 14	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00448	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  0044c	2b c2		 sub	 eax, edx
  0044e	8b 4d 14	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00451	66 89 41 12	 mov	 WORD PTR [ecx+18], ax
$L2067:

; 591  : 
; 592  :          if(wReadA>=pvciInputAIOBlk->wVoxBufferSize)

  00455	0f b7 55 f4	 movzx	 edx, WORD PTR _wReadA$[ebp]
  00459	8b 45 0c	 mov	 eax, DWORD PTR _pvciInputAIOBlk$[ebp]
  0045c	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00460	3b d1		 cmp	 edx, ecx
  00462	7c 11		 jl	 SHORT $L2069

; 593  :             wReadA=(unsigned short)(wReadA-pvciInputAIOBlk->wVoxBufferSize);

  00464	0f b7 55 f4	 movzx	 edx, WORD PTR _wReadA$[ebp]
  00468	8b 45 0c	 mov	 eax, DWORD PTR _pvciInputAIOBlk$[ebp]
  0046b	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0046f	2b d1		 sub	 edx, ecx
  00471	66 89 55 f4	 mov	 WORD PTR _wReadA$[ebp], dx
$L2069:

; 594  :       }

  00475	e9 5b ff ff ff	 jmp	 $L2065
$L2066:

; 595  :       /* set the continuation bit */
; 596  :       if(pvciOutputIOBlk->wVoxBufferWriteByteOffset)

  0047a	8b 55 14	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  0047d	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  00481	85 c0		 test	 eax, eax
  00483	74 2b		 je	 SHORT $L2071

; 597  :          pvciOutputIOBlk->pVoxBuffer[pvciOutputIOBlk->wVoxBufferWriteByteOffset-1]|=0x080;

  00485	8b 4d 14	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00488	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  0048c	8b 45 14	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  0048f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00492	0f b6 54 11 ff	 movzx	 edx, BYTE PTR [ecx+edx-1]
  00497	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  0049d	8b 45 14	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  004a0	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  004a4	8b 45 14	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  004a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  004aa	88 54 01 ff	 mov	 BYTE PTR [ecx+eax-1], dl

; 598  :       else

  004ae	eb 29		 jmp	 SHORT $L2072
$L2071:

; 599  :          pvciOutputIOBlk->pVoxBuffer[pvciOutputIOBlk->wVoxBufferSize-1]|=0x080;

  004b0	8b 4d 14	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  004b3	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  004b7	8b 45 14	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  004ba	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004bd	0f b6 54 11 ff	 movzx	 edx, BYTE PTR [ecx+edx-1]
  004c2	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  004c8	8b 45 14	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  004cb	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  004cf	8b 45 14	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  004d2	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  004d5	88 54 01 ff	 mov	 BYTE PTR [ecx+eax-1], dl
$L2072:

; 600  : 
; 601  :       for(j=0;j<wBytesB;j++) {

  004d9	66 c7 45 cc 00
	00		 mov	 WORD PTR _j$[ebp], 0
  004df	eb 0c		 jmp	 SHORT $L2073
$L2074:
  004e1	66 8b 4d cc	 mov	 cx, WORD PTR _j$[ebp]
  004e5	66 83 c1 01	 add	 cx, 1
  004e9	66 89 4d cc	 mov	 WORD PTR _j$[ebp], cx
$L2073:
  004ed	0f b7 55 cc	 movzx	 edx, WORD PTR _j$[ebp]
  004f1	0f b7 45 e8	 movzx	 eax, WORD PTR _wBytesB$[ebp]
  004f5	3b d0		 cmp	 edx, eax
  004f7	0f 8d 89 00 00
	00		 jge	 $L2075

; 602  :          pvciOutputIOBlk->pVoxBuffer[pvciOutputIOBlk->wVoxBufferWriteByteOffset++]=
; 603  :             pvciInputBIOBlk->pVoxBuffer[wReadB++];

  004fd	0f b7 4d e0	 movzx	 ecx, WORD PTR _wReadB$[ebp]
  00501	8b 55 10	 mov	 edx, DWORD PTR _pvciInputBIOBlk$[ebp]
  00504	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00507	8b 55 14	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  0050a	0f b7 52 12	 movzx	 edx, WORD PTR [edx+18]
  0050e	8b 75 14	 mov	 esi, DWORD PTR _pvciOutputIOBlk$[ebp]
  00511	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00514	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  00517	88 04 32	 mov	 BYTE PTR [edx+esi], al
  0051a	8b 4d 14	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  0051d	66 8b 51 12	 mov	 dx, WORD PTR [ecx+18]
  00521	66 83 c2 01	 add	 dx, 1
  00525	8b 45 14	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  00528	66 89 50 12	 mov	 WORD PTR [eax+18], dx
  0052c	66 8b 4d e0	 mov	 cx, WORD PTR _wReadB$[ebp]
  00530	66 83 c1 01	 add	 cx, 1
  00534	66 89 4d e0	 mov	 WORD PTR _wReadB$[ebp], cx

; 604  : 
; 605  :          if(pvciOutputIOBlk->wVoxBufferWriteByteOffset>=pvciOutputIOBlk->wVoxBufferSize)

  00538	8b 55 14	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  0053b	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  0053f	8b 4d 14	 mov	 ecx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00542	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00546	3b c2		 cmp	 eax, edx
  00548	7c 17		 jl	 SHORT $L2076

; 606  :             pvciOutputIOBlk->wVoxBufferWriteByteOffset=
; 607  :                (unsigned short)(pvciOutputIOBlk->wVoxBufferWriteByteOffset-
; 608  :                                 pvciOutputIOBlk->wVoxBufferSize);

  0054a	8b 45 14	 mov	 eax, DWORD PTR _pvciOutputIOBlk$[ebp]
  0054d	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00551	8b 55 14	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  00554	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00558	2b c8		 sub	 ecx, eax
  0055a	8b 55 14	 mov	 edx, DWORD PTR _pvciOutputIOBlk$[ebp]
  0055d	66 89 4a 12	 mov	 WORD PTR [edx+18], cx
$L2076:

; 609  : 
; 610  :          if(wReadB>=pvciInputBIOBlk->wVoxBufferSize)

  00561	0f b7 45 e0	 movzx	 eax, WORD PTR _wReadB$[ebp]
  00565	8b 4d 10	 mov	 ecx, DWORD PTR _pvciInputBIOBlk$[ebp]
  00568	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  0056c	3b c2		 cmp	 eax, edx
  0056e	7c 11		 jl	 SHORT $L2078

; 611  :             wReadB=(unsigned short)(wReadB-pvciInputBIOBlk->wVoxBufferSize);

  00570	0f b7 45 e0	 movzx	 eax, WORD PTR _wReadB$[ebp]
  00574	8b 4d 10	 mov	 ecx, DWORD PTR _pvciInputBIOBlk$[ebp]
  00577	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  0057b	2b c2		 sub	 eax, edx
  0057d	66 89 45 e0	 mov	 WORD PTR _wReadB$[ebp], ax
$L2078:

; 612  :       }

  00581	e9 5b ff ff ff	 jmp	 $L2074
$L2075:

; 613  :    }

  00586	e9 26 fe ff ff	 jmp	 $L2062
$L2063:

; 614  :    return VCI_NO_ERROR;

  0058b	66 33 c0	 xor	 ax, ax
$L2000:

; 615  : }

  0058e	5e		 pop	 esi
  0058f	8b e5		 mov	 esp, ebp
  00591	5d		 pop	 ebp
  00592	c2 18 00	 ret	 24			; 00000018H
_vciCombineBitStreamSC@24 ENDP
_TEXT	ENDS
PUBLIC	_vciGetRatesInFrameSC@12
EXTRN	_bytesToStream@8:NEAR
; Function compile flags: /Odt
;	COMDAT _vciGetRatesInFrameSC@12
_TEXT	SEGMENT
_wSeekInitial$ = -24
_vciCodecMblk$ = -20
_wSeekReturn$ = -16
_wBytesSeeked$ = -12
_dwAccumulated$ = -8
_pStreamTable$ = -4
_pVciCodecMemBlk$ = 8
_pvciCodecIOBlk$ = 12
_ScCodec$ = 16
_vciGetRatesInFrameSC@12 PROC NEAR			; COMDAT

; 627  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 628  :    short wSeekReturn, wSeekInitial, wBytesSeeked;
; 629  :    unsigned long dwAccumulated=0;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwAccumulated$[ebp], 0

; 630  :    const VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  0000d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 631  :    const unsigned short *pStreamTable = NULL;

  00014	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pStreamTable$[ebp], 0

; 632  : 
; 633  :    /* First make sure that the handle passed is the correct one. */
; 634  :    if(!VCI_BLOCK_CHECK(pVciCodecMemBlk))

  0001b	83 7d 08 00	 cmp	 DWORD PTR _pVciCodecMemBlk$[ebp], 0
  0001f	74 0b		 je	 SHORT $L2097
  00021	8b 45 08	 mov	 eax, DWORD PTR _pVciCodecMemBlk$[ebp]
  00024	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0002a	74 09		 je	 SHORT $L2096
$L2097:

; 635  :       return VCI_NOT_VCI_HANDLE;

  0002c	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00030	e9 65 01 00 00	 jmp	 $L2086
$L2096:

; 636  : 
; 637  :     /* Do parameter checking on IO block. */
; 638  :    VCI_IO_BLK_PARAM_CHECK(pvciCodecIOBlk);

  00035	83 7d 0c 00	 cmp	 DWORD PTR _pvciCodecIOBlk$[ebp], 0
  00039	75 09		 jne	 SHORT $L2098
  0003b	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  0003f	e9 56 01 00 00	 jmp	 $L2086
$L2098:
  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00047	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0004b	75 09		 jne	 SHORT $L2099
  0004d	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  00051	e9 44 01 00 00	 jmp	 $L2086
$L2099:
  00056	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00059	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0005c	75 09		 jne	 SHORT $L2100
  0005e	66 b8 ed 17	 mov	 ax, 6125		; 000017edH
  00062	e9 33 01 00 00	 jmp	 $L2086
$L2100:
  00067	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  0006a	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  0006e	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00071	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00075	3b c8		 cmp	 ecx, eax
  00077	7c 09		 jl	 SHORT $L2101
  00079	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  0007d	e9 18 01 00 00	 jmp	 $L2086
$L2101:
  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00085	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00089	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  0008c	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00090	3b d1		 cmp	 edx, ecx
  00092	7c 09		 jl	 SHORT $L2102
  00094	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  00098	e9 fd 00 00 00	 jmp	 $L2086
$L2102:
  0009d	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000a0	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  000a4	83 f8 07	 cmp	 eax, 7
  000a7	7e 09		 jle	 SHORT $L2103
  000a9	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  000ad	e9 e8 00 00 00	 jmp	 $L2086
$L2103:
  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000b5	0f b6 51 14	 movzx	 edx, BYTE PTR [ecx+20]
  000b9	83 fa 07	 cmp	 edx, 7
  000bc	7e 09		 jle	 SHORT $L2104
  000be	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  000c2	e9 d3 00 00 00	 jmp	 $L2086
$L2104:

; 639  : 
; 640  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pVciCodecMemBlk; 

  000c7	8b 45 08	 mov	 eax, DWORD PTR _pVciCodecMemBlk$[ebp]
  000ca	89 45 ec	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax

; 641  : 
; 642  :    if(vciCodecMblk->pVciPlusMethodStruct)

  000cd	8b 4d ec	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000d0	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  000d4	74 18		 je	 SHORT $L2106

; 643  :       if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)

  000d6	8b 55 ec	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000d9	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000dc	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  000e0	74 0c		 je	 SHORT $L2106

; 644  :          pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

  000e2	8b 4d ec	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000e5	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000e8	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  000eb	89 45 fc	 mov	 DWORD PTR _pStreamTable$[ebp], eax
$L2106:

; 645  : 
; 646  :    wSeekReturn=pvciCodecIOBlk->wVoxBufferReadByteOffset;

  000ee	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000f1	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  000f5	66 89 55 f0	 mov	 WORD PTR _wSeekReturn$[ebp], dx
$L2109:

; 647  : 
; 648  :    while(wSeekReturn != pvciCodecIOBlk->wVoxBufferWriteByteOffset) {

  000f9	0f bf 45 f0	 movsx	 eax, WORD PTR _wSeekReturn$[ebp]
  000fd	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00100	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00104	3b c2		 cmp	 eax, edx
  00106	0f 84 83 00 00
	00		 je	 $L2110

; 649  : 
; 650  :       wSeekInitial = wSeekReturn;

  0010c	66 8b 45 f0	 mov	 ax, WORD PTR _wSeekReturn$[ebp]
  00110	66 89 45 e8	 mov	 WORD PTR _wSeekInitial$[ebp], ax

; 651  :       
; 652  :       wSeekReturn = seekForward(pvciCodecIOBlk->pVoxBuffer,
; 653  :                   wSeekInitial,
; 654  :                   pvciCodecIOBlk->wVoxBufferWriteByteOffset,
; 655  :                   pvciCodecIOBlk->wVoxBufferSize,
; 656  :                   1, pStreamTable);

  00114	8b 4d fc	 mov	 ecx, DWORD PTR _pStreamTable$[ebp]
  00117	51		 push	 ecx
  00118	6a 01		 push	 1
  0011a	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0011d	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  00121	50		 push	 eax
  00122	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00125	66 8b 51 12	 mov	 dx, WORD PTR [ecx+18]
  00129	52		 push	 edx
  0012a	66 8b 45 e8	 mov	 ax, WORD PTR _wSeekInitial$[ebp]
  0012e	50		 push	 eax
  0012f	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00132	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00135	52		 push	 edx
  00136	e8 00 00 00 00	 call	 _seekForward@24
  0013b	66 89 45 f0	 mov	 WORD PTR _wSeekReturn$[ebp], ax

; 657  : 
; 658  :       if(wSeekReturn < 0)

  0013f	0f bf 45 f0	 movsx	 eax, WORD PTR _wSeekReturn$[ebp]
  00143	85 c0		 test	 eax, eax
  00145	7d 06		 jge	 SHORT $L2111

; 659  :          return VCI_BITSTREAM_CORRUPTED;

  00147	66 b8 29 18	 mov	 ax, 6185		; 00001829H
  0014b	eb 4d		 jmp	 SHORT $L2086
$L2111:

; 660  : 
; 661  :       wBytesSeeked = (short)(wSeekReturn - wSeekInitial);

  0014d	0f bf 4d f0	 movsx	 ecx, WORD PTR _wSeekReturn$[ebp]
  00151	0f bf 55 e8	 movsx	 edx, WORD PTR _wSeekInitial$[ebp]
  00155	2b ca		 sub	 ecx, edx
  00157	66 89 4d f4	 mov	 WORD PTR _wBytesSeeked$[ebp], cx

; 662  : 
; 663  :       if(wBytesSeeked < 0) 

  0015b	0f bf 45 f4	 movsx	 eax, WORD PTR _wBytesSeeked$[ebp]
  0015f	85 c0		 test	 eax, eax
  00161	7d 11		 jge	 SHORT $L2113

; 664  :          wBytesSeeked = (short)(wBytesSeeked + pvciCodecIOBlk->wVoxBufferSize);

  00163	0f bf 4d f4	 movsx	 ecx, WORD PTR _wBytesSeeked$[ebp]
  00167	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0016a	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  0016e	03 c8		 add	 ecx, eax
  00170	66 89 4d f4	 mov	 WORD PTR _wBytesSeeked$[ebp], cx
$L2113:

; 665  : 
; 666  :       dwAccumulated|=bytesToStream(wBytesSeeked, pStreamTable);

  00174	8b 4d fc	 mov	 ecx, DWORD PTR _pStreamTable$[ebp]
  00177	51		 push	 ecx
  00178	66 8b 55 f4	 mov	 dx, WORD PTR _wBytesSeeked$[ebp]
  0017c	52		 push	 edx
  0017d	e8 00 00 00 00	 call	 _bytesToStream@8
  00182	8b 4d f8	 mov	 ecx, DWORD PTR _dwAccumulated$[ebp]
  00185	0b c8		 or	 ecx, eax
  00187	89 4d f8	 mov	 DWORD PTR _dwAccumulated$[ebp], ecx

; 667  :    } 

  0018a	e9 6a ff ff ff	 jmp	 $L2109
$L2110:

; 668  : 
; 669  :    *ScCodec=dwAccumulated;

  0018f	8b 55 10	 mov	 edx, DWORD PTR _ScCodec$[ebp]
  00192	8b 45 f8	 mov	 eax, DWORD PTR _dwAccumulated$[ebp]
  00195	89 02		 mov	 DWORD PTR [edx], eax

; 670  : 
; 671  :    return VCI_NO_ERROR;

  00197	66 33 c0	 xor	 ax, ax
$L2086:

; 672  : }

  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	c2 0c 00	 ret	 12			; 0000000cH
_vciGetRatesInFrameSC@12 ENDP
_TEXT	ENDS
PUBLIC	_vciSetEncoderRateSC@8
EXTRN	_voxSetEncodeRate@8:NEAR
; Function compile flags: /Odt
;	COMDAT _vciSetEncoderRateSC@8
_TEXT	SEGMENT
_wTemp$ = -16
_vciCodecMblk$ = -12
_wMask$ = -8
_pStreamTable$ = -4
_pEncodeMemBlk$ = 8
_wBitField$ = 12
_vciSetEncoderRateSC@8 PROC NEAR			; COMDAT

; 684  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 685  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 686  :    unsigned long wTemp=wBitField;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _wBitField$[ebp]
  00010	89 45 f0	 mov	 DWORD PTR _wTemp$[ebp], eax

; 687  :    unsigned long wMask=~wTemp;

  00013	8b 4d f0	 mov	 ecx, DWORD PTR _wTemp$[ebp]
  00016	f7 d1		 not	 ecx
  00018	89 4d f8	 mov	 DWORD PTR _wMask$[ebp], ecx

; 688  :    const unsigned short *pStreamTable = NULL;

  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pStreamTable$[ebp], 0

; 689  : 
; 690  :    /* First make sure that the handle passed is the correct one. */
; 691  :    if(!VCI_BLOCK_CHECK(pEncodeMemBlk))

  00022	83 7d 08 00	 cmp	 DWORD PTR _pEncodeMemBlk$[ebp], 0
  00026	74 0b		 je	 SHORT $L2128
  00028	8b 55 08	 mov	 edx, DWORD PTR _pEncodeMemBlk$[ebp]
  0002b	81 3a ce fa 00
	00		 cmp	 DWORD PTR [edx], 64206	; 0000faceH
  00031	74 09		 je	 SHORT $L2127
$L2128:

; 692  :       return VCI_NOT_VCI_HANDLE;

  00033	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00037	e9 aa 00 00 00	 jmp	 $L2119
$L2127:

; 693  : 
; 694  :    if(!VCI_IS_ENCODE(pEncodeMemBlk))

  0003c	8b 45 08	 mov	 eax, DWORD PTR _pEncodeMemBlk$[ebp]
  0003f	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  00043	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00046	74 09		 je	 SHORT $L2130

; 695  :       return VCI_NOT_ENC_HANDLE;

  00048	66 b8 de 17	 mov	 ax, 6110		; 000017deH
  0004c	e9 95 00 00 00	 jmp	 $L2119
$L2130:

; 696  : 
; 697  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pEncodeMemBlk;

  00051	8b 55 08	 mov	 edx, DWORD PTR _pEncodeMemBlk$[ebp]
  00054	89 55 f4	 mov	 DWORD PTR _vciCodecMblk$[ebp], edx

; 698  : 
; 699  :    if(vciCodecMblk->pVciPlusMethodStruct)

  00057	8b 45 f4	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  0005a	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  0005e	74 18		 je	 SHORT $L2132

; 700  :       if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)

  00060	8b 4d f4	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00063	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00066	83 7a 44 00	 cmp	 DWORD PTR [edx+68], 0
  0006a	74 0c		 je	 SHORT $L2132

; 701  :          pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

  0006c	8b 45 f4	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  0006f	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00072	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00075	89 55 fc	 mov	 DWORD PTR _pStreamTable$[ebp], edx
$L2132:

; 702  : 
; 703  :    if(!isValidStream(wBitField, pStreamTable))

  00078	8b 45 fc	 mov	 eax, DWORD PTR _pStreamTable$[ebp]
  0007b	50		 push	 eax
  0007c	8b 4d 0c	 mov	 ecx, DWORD PTR _wBitField$[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 _isValidStream@8
  00085	0f b6 d0	 movzx	 edx, al
  00088	85 d2		 test	 edx, edx
  0008a	75 06		 jne	 SHORT $L2136

; 704  :       return VCI_BITSTREAM_NOT_SUPPORTED;

  0008c	66 b8 2a 18	 mov	 ax, 6186		; 0000182aH
  00090	eb 54		 jmp	 SHORT $L2119
$L2136:

; 705  : 
; 706  :    /* adjusting rate to assure that it's a single rate */
; 707  :    while(wTemp>>=1) {

  00092	8b 45 f0	 mov	 eax, DWORD PTR _wTemp$[ebp]
  00095	d1 e8		 shr	 eax, 1
  00097	89 45 f0	 mov	 DWORD PTR _wTemp$[ebp], eax
  0009a	83 7d f0 00	 cmp	 DWORD PTR _wTemp$[ebp], 0
  0009e	74 19		 je	 SHORT $L2137

; 708  :       wMask=(wMask>>1)|0x8000;

  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _wMask$[ebp]
  000a3	d1 e9		 shr	 ecx, 1
  000a5	81 c9 00 80 00
	00		 or	 ecx, 32768		; 00008000H
  000ab	89 4d f8	 mov	 DWORD PTR _wMask$[ebp], ecx

; 709  :       wBitField&=wMask;

  000ae	8b 55 0c	 mov	 edx, DWORD PTR _wBitField$[ebp]
  000b1	23 55 f8	 and	 edx, DWORD PTR _wMask$[ebp]
  000b4	89 55 0c	 mov	 DWORD PTR _wBitField$[ebp], edx

; 710  :    }

  000b7	eb d9		 jmp	 SHORT $L2136
$L2137:

; 711  : 
; 712  :    if (wBitField == 0)

  000b9	83 7d 0c 00	 cmp	 DWORD PTR _wBitField$[ebp], 0
  000bd	75 06		 jne	 SHORT $L2138

; 713  :      return VCI_RATE_INVALID;

  000bf	66 b8 2f 18	 mov	 ax, 6191		; 0000182fH
  000c3	eb 21		 jmp	 SHORT $L2119
$L2138:

; 714  : 
; 715  :    if(voxSetEncodeRate(vciCodecMblk->hCodecMblk, wBitField)!=wBitField)

  000c5	8b 45 0c	 mov	 eax, DWORD PTR _wBitField$[ebp]
  000c8	50		 push	 eax
  000c9	8b 4d f4	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000cc	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000cf	52		 push	 edx
  000d0	e8 00 00 00 00	 call	 _voxSetEncodeRate@8
  000d5	0f b7 c0	 movzx	 eax, ax
  000d8	3b 45 0c	 cmp	 eax, DWORD PTR _wBitField$[ebp]
  000db	74 06		 je	 SHORT $L2139

; 716  :       return VCI_RATE_INVALID;

  000dd	66 b8 2f 18	 mov	 ax, 6191		; 0000182fH
  000e1	eb 03		 jmp	 SHORT $L2119
$L2139:

; 717  :    else
; 718  :       return VCI_NO_ERROR;

  000e3	66 33 c0	 xor	 ax, ax
$L2119:

; 719  : }

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 08 00	 ret	 8
_vciSetEncoderRateSC@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@BEIFPMPN@wBitField?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	_vciGetEncoderRateSC@8
EXTRN	_voxGetEncodeRate@4:NEAR
;	COMDAT ??_C@_0BC@BEIFPMPN@wBitField?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BC@BEIFPMPN@wBitField?5?$CB?$DN?5NULL?$AA@ DB 'wBitField != NULL', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciGetEncoderRateSC@8
_TEXT	SEGMENT
_wTemp$ = -8
_vciCodecMblk$ = -4
_pEncodeMemBlk$ = 8
_wBitField$ = 12
_vciGetEncoderRateSC@8 PROC NEAR			; COMDAT

; 729  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 730  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 731  :    unsigned short wTemp;
; 732  : 
; 733  :    /* First make sure that the handle passed is the correct one. */
; 734  :    if(!VCI_BLOCK_CHECK(pEncodeMemBlk))

  0000d	83 7d 08 00	 cmp	 DWORD PTR _pEncodeMemBlk$[ebp], 0
  00011	74 0b		 je	 SHORT $L2151
  00013	8b 45 08	 mov	 eax, DWORD PTR _pEncodeMemBlk$[ebp]
  00016	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0001c	74 06		 je	 SHORT $L2150
$L2151:

; 735  :       return VCI_NOT_VCI_HANDLE;

  0001e	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00022	eb 74		 jmp	 SHORT $L2145
$L2150:

; 736  : 
; 737  :    if(!VCI_IS_ENCODE(pEncodeMemBlk))

  00024	8b 4d 08	 mov	 ecx, DWORD PTR _pEncodeMemBlk$[ebp]
  00027	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  0002b	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0002e	74 06		 je	 SHORT $L2153

; 738  :       return VCI_NOT_ENC_HANDLE;

  00030	66 b8 de 17	 mov	 ax, 6110		; 000017deH
  00034	eb 62		 jmp	 SHORT $L2145
$L2153:

; 739  : 
; 740  :    assert(wBitField != NULL);

  00036	83 7d 0c 00	 cmp	 DWORD PTR _wBitField$[ebp], 0
  0003a	75 17		 jne	 SHORT $L2341
  0003c	68 e4 02 00 00	 push	 740			; 000002e4H
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@HGNGBIFJ@c?3?2xbox?2private?2windows?2directx?2@
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@BEIFPMPN@wBitField?5?$CB?$DN?5NULL?$AA@
  0004b	e8 00 00 00 00	 call	 __assert
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
$L2341:

; 741  : 
; 742  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pEncodeMemBlk;

  00053	8b 4d 08	 mov	 ecx, DWORD PTR _pEncodeMemBlk$[ebp]
  00056	89 4d fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], ecx

; 743  :    *wBitField=wTemp=(unsigned short)voxGetEncodeRate(vciCodecMblk->hCodecMblk);

  00059	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0005c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _voxGetEncodeRate@4
  00065	66 89 45 f8	 mov	 WORD PTR _wTemp$[ebp], ax
  00069	0f b7 4d f8	 movzx	 ecx, WORD PTR _wTemp$[ebp]
  0006d	8b 55 0c	 mov	 edx, DWORD PTR _wBitField$[ebp]
  00070	89 0a		 mov	 DWORD PTR [edx], ecx
$L2159:

; 744  : 
; 745  :    /* adjust rate so that it becomes a valid bit field */
; 746  :    do
; 747  :       *wBitField|=(wTemp>>=1);

  00072	66 8b 45 f8	 mov	 ax, WORD PTR _wTemp$[ebp]
  00076	66 d1 e8	 shr	 ax, 1
  00079	66 89 45 f8	 mov	 WORD PTR _wTemp$[ebp], ax
  0007d	0f b7 4d f8	 movzx	 ecx, WORD PTR _wTemp$[ebp]
  00081	8b 55 0c	 mov	 edx, DWORD PTR _wBitField$[ebp]
  00084	8b 02		 mov	 eax, DWORD PTR [edx]
  00086	0b c1		 or	 eax, ecx
  00088	8b 4d 0c	 mov	 ecx, DWORD PTR _wBitField$[ebp]
  0008b	89 01		 mov	 DWORD PTR [ecx], eax

; 748  :    while (wTemp);

  0008d	0f b7 55 f8	 movzx	 edx, WORD PTR _wTemp$[ebp]
  00091	85 d2		 test	 edx, edx
  00093	75 dd		 jne	 SHORT $L2159

; 749  : 
; 750  :    return VCI_NO_ERROR;

  00095	66 33 c0	 xor	 ax, ax
$L2145:

; 751  : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
_vciGetEncoderRateSC@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	_vciGetValidRatesSC@8
EXTRN	_voxGetDecodeInitRateSC@4:NEAR
EXTRN	_voxGetEncodeInitRate@4:NEAR
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciGetValidRatesSC@8
_TEXT	SEGMENT
tv73 = -8
_vciCodecMblk$ = -4
_pCodecMemBlk$ = 8
_wBitField$ = 12
_vciGetValidRatesSC@8 PROC NEAR				; COMDAT

; 763  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 764  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 765  : 
; 766  :    if(!VCI_BLOCK_CHECK(pCodecMemBlk))

  0000d	83 7d 08 00	 cmp	 DWORD PTR _pCodecMemBlk$[ebp], 0
  00011	74 0b		 je	 SHORT $L2171
  00013	8b 45 08	 mov	 eax, DWORD PTR _pCodecMemBlk$[ebp]
  00016	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0001c	74 09		 je	 SHORT $L2170
$L2171:

; 767  :       return VCI_NOT_VCI_HANDLE;

  0001e	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00022	e9 8f 00 00 00	 jmp	 $L2166
$L2170:

; 768  : 
; 769  :    assert(wBitField != NULL);

  00027	83 7d 0c 00	 cmp	 DWORD PTR _wBitField$[ebp], 0
  0002b	75 17		 jne	 SHORT $L2345
  0002d	68 01 03 00 00	 push	 769			; 00000301H
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@HGNGBIFJ@c?3?2xbox?2private?2windows?2directx?2@
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@BEIFPMPN@wBitField?5?$CB?$DN?5NULL?$AA@
  0003c	e8 00 00 00 00	 call	 __assert
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
$L2345:

; 770  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pCodecMemBlk;

  00044	8b 55 08	 mov	 edx, DWORD PTR _pCodecMemBlk$[ebp]
  00047	89 55 fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], edx

; 771  : 
; 772  :    switch(vciCodecMblk->chEncOrDec) {

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  0004d	8a 48 0c	 mov	 cl, BYTE PTR [eax+12]
  00050	88 4d f8	 mov	 BYTE PTR tv73[ebp], cl
  00053	80 7d f8 0a	 cmp	 BYTE PTR tv73[ebp], 10	; 0000000aH
  00057	74 08		 je	 SHORT $L2179
  00059	80 7d f8 0b	 cmp	 BYTE PTR tv73[ebp], 11	; 0000000bH
  0005d	74 15		 je	 SHORT $L2180
  0005f	eb 26		 jmp	 SHORT $L2181
$L2179:

; 773  : #ifndef DECODE_ONLY
; 774  :       case ENCODE_ID:
; 775  :          *wBitField=voxGetEncodeInitRate(vciCodecMblk->hCodecMblk);

  00061	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00064	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _voxGetEncodeInitRate@4
  0006d	8b 4d 0c	 mov	 ecx, DWORD PTR _wBitField$[ebp]
  00070	89 01		 mov	 DWORD PTR [ecx], eax

; 776  :          break;

  00072	eb 3f		 jmp	 SHORT $L2176
$L2180:

; 777  : #endif
; 778  : 
; 779  :       case DECODE_ID:
; 780  :          *wBitField=voxGetDecodeInitRateSC(vciCodecMblk->hCodecMblk);

  00074	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00077	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _voxGetDecodeInitRateSC@4
  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _wBitField$[ebp]
  00083	89 01		 mov	 DWORD PTR [ecx], eax

; 781  :          break;

  00085	eb 2c		 jmp	 SHORT $L2176
$L2181:

; 782  : 
; 783  :       default:
; 784  :          *wBitField=0;

  00087	8b 55 0c	 mov	 edx, DWORD PTR _wBitField$[ebp]
  0008a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 785  :          assert(0);

  00090	33 c0		 xor	 eax, eax
  00092	85 c0		 test	 eax, eax
  00094	75 17		 jne	 SHORT $L2346
  00096	68 11 03 00 00	 push	 785			; 00000311H
  0009b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@HGNGBIFJ@c?3?2xbox?2private?2windows?2directx?2@
  000a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  000a5	e8 00 00 00 00	 call	 __assert
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH
$L2346:

; 786  :          return VCI_INCOMPATIBLE_HANDLE;

  000ad	66 b8 d9 17	 mov	 ax, 6105		; 000017d9H
  000b1	eb 03		 jmp	 SHORT $L2166
$L2176:

; 787  :    }
; 788  :    return VCI_NO_ERROR;

  000b3	66 33 c0	 xor	 ax, ax
$L2166:

; 789  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c2 08 00	 ret	 8
_vciGetValidRatesSC@8 ENDP
_TEXT	ENDS
PUBLIC	__real@45fa0000
PUBLIC	__real@43200000
PUBLIC	_vciCalculateBitRateSC@12
;	COMDAT __real@45fa0000
CONST	SEGMENT
__real@45fa0000 DD 045fa0000r			; 8000
CONST	ENDS
;	COMDAT __real@43200000
CONST	SEGMENT
__real@43200000 DD 043200000r			; 160
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciCalculateBitRateSC@12
_TEXT	SEGMENT
tv130 = -16
_wBytesInStream$ = -12
_vciCodecMblk$ = -8
_pStreamTable$ = -4
_pCodecMemBlk$ = 8
_wBitField$ = 12
_pwBitRate$ = 16
_vciCalculateBitRateSC@12 PROC NEAR			; COMDAT

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 801  :    short wBytesInStream=0;

  00006	66 c7 45 f4 00
	00		 mov	 WORD PTR _wBytesInStream$[ebp], 0

; 802  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 803  :    const unsigned short *pStreamTable = NULL;

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pStreamTable$[ebp], 0

; 804  : 
; 805  :    if(!VCI_BLOCK_CHECK(pCodecMemBlk))

  0001a	83 7d 08 00	 cmp	 DWORD PTR _pCodecMemBlk$[ebp], 0
  0001e	74 0b		 je	 SHORT $L2198
  00020	8b 45 08	 mov	 eax, DWORD PTR _pCodecMemBlk$[ebp]
  00023	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  00029	74 06		 je	 SHORT $L2197
$L2198:

; 806  :       return VCI_NOT_VCI_HANDLE;

  0002b	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  0002f	eb 6e		 jmp	 SHORT $L2190
$L2197:

; 807  : 
; 808  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pCodecMemBlk;

  00031	8b 4d 08	 mov	 ecx, DWORD PTR _pCodecMemBlk$[ebp]
  00034	89 4d f8	 mov	 DWORD PTR _vciCodecMblk$[ebp], ecx

; 809  : 
; 810  :    if(vciCodecMblk->pVciPlusMethodStruct)

  00037	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0003a	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  0003e	74 18		 je	 SHORT $L2200

; 811  :       if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)

  00040	8b 45 f8	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00043	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00046	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  0004a	74 0c		 je	 SHORT $L2200

; 812  :          pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

  0004c	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0004f	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00052	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00055	89 4d fc	 mov	 DWORD PTR _pStreamTable$[ebp], ecx
$L2200:

; 813  : 
; 814  :    if((wBytesInStream=bytesInStream(wBitField, pStreamTable))==-1)

  00058	8b 55 fc	 mov	 edx, DWORD PTR _pStreamTable$[ebp]
  0005b	52		 push	 edx
  0005c	8b 45 0c	 mov	 eax, DWORD PTR _wBitField$[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _bytesInStream@8
  00065	66 89 45 f4	 mov	 WORD PTR _wBytesInStream$[ebp], ax
  00069	0f bf 4d f4	 movsx	 ecx, WORD PTR _wBytesInStream$[ebp]
  0006d	83 f9 ff	 cmp	 ecx, -1
  00070	75 06		 jne	 SHORT $L2202

; 815  :       return VCI_BITSTREAM_CORRUPTED;

  00072	66 b8 29 18	 mov	 ax, 6185		; 00001829H
  00076	eb 27		 jmp	 SHORT $L2190
$L2202:

; 816  : 
; 817  :    *pwBitRate=(unsigned short)((float)RATE8K*(float)(wBytesInStream*8)/(float)FRAME_LENGTH_SC);

  00078	0f bf 55 f4	 movsx	 edx, WORD PTR _wBytesInStream$[ebp]
  0007c	c1 e2 03	 shl	 edx, 3
  0007f	89 55 f0	 mov	 DWORD PTR tv130[ebp], edx
  00082	db 45 f0	 fild	 DWORD PTR tv130[ebp]
  00085	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@45fa0000
  0008b	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@43200000
  00091	e8 00 00 00 00	 call	 __ftol2
  00096	8b 4d 10	 mov	 ecx, DWORD PTR _pwBitRate$[ebp]
  00099	66 89 01	 mov	 WORD PTR [ecx], ax

; 818  : 
; 819  :    return VCI_NO_ERROR;

  0009c	66 33 c0	 xor	 ax, ax
$L2190:

; 820  : }

  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 0c 00	 ret	 12			; 0000000cH
_vciCalculateBitRateSC@12 ENDP
_TEXT	ENDS
PUBLIC	__real@3b23d70a
PUBLIC	_vciCalculateRateSC@12
;	COMDAT __real@3b23d70a
CONST	SEGMENT
__real@3b23d70a DD 03b23d70ar			; 0.0025
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciCalculateRateSC@12
_TEXT	SEGMENT
tv82 = -16
_vciCodecMblk$ = -12
_rateBytes$ = -8
_pStreamTable$ = -4
_pCodecMemBlk$ = 8
_wBitRate$ = 12
_wBitField$ = 16
_vciCalculateRateSC@12 PROC NEAR			; COMDAT

; 830  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 831  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 832  :    float rateBytes=(float)wBitRate*((float)FRAME_LENGTH_SC/((float)RATE8K*8));

  0000d	0f b7 45 0c	 movzx	 eax, WORD PTR _wBitRate$[ebp]
  00011	89 45 f0	 mov	 DWORD PTR tv82[ebp], eax
  00014	db 45 f0	 fild	 DWORD PTR tv82[ebp]
  00017	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3b23d70a
  0001d	d9 5d f8	 fstp	 DWORD PTR _rateBytes$[ebp]

; 833  :    const unsigned short *pStreamTable = NULL;

  00020	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pStreamTable$[ebp], 0

; 834  : 
; 835  :    if(!VCI_BLOCK_CHECK(pCodecMemBlk))

  00027	83 7d 08 00	 cmp	 DWORD PTR _pCodecMemBlk$[ebp], 0
  0002b	74 0b		 je	 SHORT $L2224
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _pCodecMemBlk$[ebp]
  00030	81 39 ce fa 00
	00		 cmp	 DWORD PTR [ecx], 64206	; 0000faceH
  00036	74 06		 je	 SHORT $L2223
$L2224:

; 836  :       return VCI_NOT_VCI_HANDLE;

  00038	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  0003c	eb 41		 jmp	 SHORT $L2213
$L2223:

; 837  : 
; 838  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pCodecMemBlk;   

  0003e	8b 55 08	 mov	 edx, DWORD PTR _pCodecMemBlk$[ebp]
  00041	89 55 f4	 mov	 DWORD PTR _vciCodecMblk$[ebp], edx

; 839  : 
; 840  :    if(vciCodecMblk->pVciPlusMethodStruct)

  00044	8b 45 f4	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00047	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  0004b	74 18		 je	 SHORT $L2226

; 841  :       if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00050	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00053	83 7a 44 00	 cmp	 DWORD PTR [edx+68], 0
  00057	74 0c		 je	 SHORT $L2226

; 842  :          pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

  00059	8b 45 f4	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  0005c	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0005f	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00062	89 55 fc	 mov	 DWORD PTR _pStreamTable$[ebp], edx
$L2226:

; 843  : 
; 844  :    *wBitField = bytesToStream((unsigned short)rateBytes, pStreamTable);

  00065	8b 45 fc	 mov	 eax, DWORD PTR _pStreamTable$[ebp]
  00068	50		 push	 eax
  00069	d9 45 f8	 fld	 DWORD PTR _rateBytes$[ebp]
  0006c	e8 00 00 00 00	 call	 __ftol2
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _bytesToStream@8
  00077	8b 4d 10	 mov	 ecx, DWORD PTR _wBitField$[ebp]
  0007a	89 01		 mov	 DWORD PTR [ecx], eax

; 845  : 
; 846  :    return VCI_NO_ERROR;

  0007c	66 33 c0	 xor	 ax, ax
$L2213:

; 847  : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 0c 00	 ret	 12			; 0000000cH
_vciCalculateRateSC@12 ENDP
_TEXT	ENDS
PUBLIC	_vciPlusInitSC@4
EXTRN	_calloc:NEAR
; Function compile flags: /Odt
;	COMDAT _vciPlusInitSC@4
_TEXT	SEGMENT
_vciCodecMblk$ = -4
_pCodecMemBlk$ = 8
_vciPlusInitSC@4 PROC NEAR				; COMDAT

; 857  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 858  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 859  : 
; 860  :    if(!VCI_BLOCK_CHECK(pCodecMemBlk))

  0000b	83 7d 08 00	 cmp	 DWORD PTR _pCodecMemBlk$[ebp], 0
  0000f	74 0b		 je	 SHORT $L2236
  00011	8b 45 08	 mov	 eax, DWORD PTR _pCodecMemBlk$[ebp]
  00014	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0001a	74 09		 je	 SHORT $L2235
$L2236:

; 861  :       return VCI_NOT_VCI_HANDLE;

  0001c	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00020	e9 16 01 00 00	 jmp	 $L2231
$L2235:

; 862  : 
; 863  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pCodecMemBlk;

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _pCodecMemBlk$[ebp]
  00028	89 4d fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], ecx

; 864  : 
; 865  :    if(VOX_MEM_INIT(vciCodecMblk->pVciPlusMethodStruct,1,sizeof(VCI_PLUS_METHOD_STRUCT)))

  0002b	6a 48		 push	 72			; 00000048H
  0002d	6a 01		 push	 1
  0002f	e8 00 00 00 00	 call	 _calloc
  00034	83 c4 08	 add	 esp, 8
  00037	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0003a	89 42 28	 mov	 DWORD PTR [edx+40], eax
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00040	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00044	75 09		 jne	 SHORT $L2239

; 866  :       return VCI_FAILED_MEM_ALLOC;

  00046	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  0004a	e9 ec 00 00 00	 jmp	 $L2231
$L2239:

; 867  : 
; 868  :    vciCodecMblk->pVciPlusMethodStruct->pfVciDecodeNeedsInput=vciDecodeNeedsInputSC;

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00052	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00055	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET FLAT:_vciDecodeNeedsInputSC@8

; 869  :    vciCodecMblk->pVciPlusMethodStruct->pfVciSetWarpFactor=vciSetWarpFactorSC;

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  0005e	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00061	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:_vciSetWarpFactorSC@8

; 870  :    vciCodecMblk->pVciPlusMethodStruct->pfVciGetWarpFactor=vciGetWarpFactorSC;

  00068	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0006b	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0006e	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET FLAT:_vciGetWarpFactorSC@8

; 871  : 
; 872  :    vciCodecMblk->pVciPlusMethodStruct->pfVciSetInjectSilenceFlag=vciSetInjectSilenceFlagSC;

  00075	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00078	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0007b	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], OFFSET FLAT:_vciSetInjectSilenceFlagSC@4

; 873  : 
; 874  :    vciCodecMblk->pVciPlusMethodStruct->pfVciGetEnergy=vciGetEnergyLevelSC;   

  00082	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00085	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00088	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], OFFSET FLAT:_vciGetEnergyLevelSC@8

; 875  :   
; 876  :    vciCodecMblk->pVciPlusMethodStruct->pfVciNumFramesInBuffer=vciNumFramesInBufferSC;

  0008f	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00092	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00095	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET FLAT:_vciNumFramesInBufferSC@20

; 877  :    vciCodecMblk->pVciPlusMethodStruct->pfVciSeekForward=vciSeekForwardSC;

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  0009f	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000a2	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET FLAT:_vciSeekForwardSC@20

; 878  : 
; 879  :    vciCodecMblk->pVciPlusMethodStruct->pfVciSetFramesSkipped=vciSetFramesSkippedSC;

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  000ac	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000af	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], OFFSET FLAT:_vciSetFramesSkippedSC@8

; 880  :    vciCodecMblk->pVciPlusMethodStruct->pfVciSetRepeatFrameFlag=vciSetRepeatFrameFlagSC;

  000b6	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000b9	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000bc	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET FLAT:_vciSetRepeatFrameFlagSC@4

; 881  : 
; 882  : 
; 883  :    vciCodecMblk->pVciPlusMethodStruct->pfVciExtractFromBitStream=vciExtractFromBitStreamSC;

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000c6	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000c9	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], OFFSET FLAT:_vciExtractFromBitStreamSC@16

; 884  : 
; 885  :    vciCodecMblk->pVciPlusMethodStruct->pfVciCombineBitStream=vciCombineBitStreamSC;

  000d0	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  000d3	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000d6	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], OFFSET FLAT:_vciCombineBitStreamSC@24

; 886  : 
; 887  :    vciCodecMblk->pVciPlusMethodStruct->pfVciGetRatesInFrame=vciGetRatesInFrameSC;

  000dd	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000e0	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000e3	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], OFFSET FLAT:_vciGetRatesInFrameSC@12

; 888  : 
; 889  : #ifndef DECODE_ONLY
; 890  :    vciCodecMblk->pVciPlusMethodStruct->pfVciSetEncoderRate=vciSetEncoderRateSC;

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000ed	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000f0	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], OFFSET FLAT:_vciSetEncoderRateSC@8

; 891  :    vciCodecMblk->pVciPlusMethodStruct->pfVciGetEncoderRate=vciGetEncoderRateSC; 

  000f7	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  000fa	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000fd	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], OFFSET FLAT:_vciGetEncoderRateSC@8

; 892  : #endif
; 893  : 
; 894  :    vciCodecMblk->pVciPlusMethodStruct->pfVciGetValidRates=vciGetValidRatesSC;

  00104	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00107	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0010a	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], OFFSET FLAT:_vciGetValidRatesSC@8

; 895  : 
; 896  :    vciCodecMblk->pVciPlusMethodStruct->pfVciCalculateBitRate=vciCalculateBitRateSC;

  00111	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00114	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00117	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], OFFSET FLAT:_vciCalculateBitRateSC@12

; 897  :    vciCodecMblk->pVciPlusMethodStruct->pfVciCalculateRateSC=vciCalculateRateSC;

  0011e	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00121	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00124	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], OFFSET FLAT:_vciCalculateRateSC@12

; 898  : 
; 899  :    vciCodecMblk->pVciPlusMethodStruct->wStreamTable = NULL;

  0012b	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0012e	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00131	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 900  : 
; 901  :    return VCI_NO_ERROR;

  00138	66 33 c0	 xor	 ax, ax
$L2231:

; 902  : }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 04 00	 ret	 4
_vciPlusInitSC@4 ENDP
_TEXT	ENDS
PUBLIC	_vciPlusFreeSC@4
EXTRN	_free:NEAR
; Function compile flags: /Odt
;	COMDAT _vciPlusFreeSC@4
_TEXT	SEGMENT
_pCodecMemBlk$ = 8
_vciPlusFreeSC@4 PROC NEAR				; COMDAT

; 912  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 
; 914  :    if(!VCI_BLOCK_CHECK(pCodecMemBlk))

  00003	83 7d 08 00	 cmp	 DWORD PTR _pCodecMemBlk$[ebp], 0
  00007	74 0b		 je	 SHORT $L2246
  00009	8b 45 08	 mov	 eax, DWORD PTR _pCodecMemBlk$[ebp]
  0000c	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  00012	74 06		 je	 SHORT $L2245
$L2246:

; 915  :       return VCI_NOT_VCI_HANDLE;

  00014	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00018	eb 25		 jmp	 SHORT $L2243
$L2245:

; 916  : 
; 917  :    VOX_MEM_FREE(((VCI_CODEC_BLOCK *)pCodecMemBlk)->pVciPlusMethodStruct);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _pCodecMemBlk$[ebp]
  0001d	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  00021	74 19		 je	 SHORT $L2248
  00023	8b 55 08	 mov	 edx, DWORD PTR _pCodecMemBlk$[ebp]
  00026	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _free
  0002f	83 c4 04	 add	 esp, 4
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _pCodecMemBlk$[ebp]
  00035	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
$L2248:

; 918  : 
; 919  :    return VCI_NO_ERROR;

  0003c	66 33 c0	 xor	 ax, ax
$L2243:

; 920  : }

  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
_vciPlusFreeSC@4 ENDP
_TEXT	ENDS
PUBLIC	_vciGetPlusInfoSC@4
; Function compile flags: /Odt
;	COMDAT _vciGetPlusInfoSC@4
_TEXT	SEGMENT
_pVciPlusInfoBlk$ = 8
_vciGetPlusInfoSC@4 PROC NEAR				; COMDAT

; 929  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 930  :    pVciPlusInfoBlk->wPlusFlags=VCI_CODEC_HAS_WARPING; 

  00003	8b 45 08	 mov	 eax, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00006	66 c7 00 01 00	 mov	 WORD PTR [eax], 1

; 931  :    pVciPlusInfoBlk->wPlusFlags|=VCI_CODEC_HAS_SILENCE_INJECTION;

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _pVciPlusInfoBlk$[ebp]
  0000e	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00011	83 ca 02	 or	 edx, 2
  00014	8b 45 08	 mov	 eax, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00017	66 89 10	 mov	 WORD PTR [eax], dx

; 932  :    pVciPlusInfoBlk->wPlusFlags|=VCI_CODEC_HAS_GET_ENERGY;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _pVciPlusInfoBlk$[ebp]
  0001d	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00020	83 ca 08	 or	 edx, 8
  00023	8b 45 08	 mov	 eax, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00026	66 89 10	 mov	 WORD PTR [eax], dx

; 933  :    pVciPlusInfoBlk->wPlusFlags|=VCI_CODEC_HAS_FRAME_TRAVERSAL;

  00029	8b 4d 08	 mov	 ecx, DWORD PTR _pVciPlusInfoBlk$[ebp]
  0002c	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0002f	83 ca 10	 or	 edx, 16			; 00000010H
  00032	8b 45 08	 mov	 eax, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00035	66 89 10	 mov	 WORD PTR [eax], dx

; 934  :    pVciPlusInfoBlk->wPlusFlags|=VCI_PRIME_FLUSH;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR _pVciPlusInfoBlk$[ebp]
  0003b	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0003e	83 ca 20	 or	 edx, 32			; 00000020H
  00041	8b 45 08	 mov	 eax, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00044	66 89 10	 mov	 WORD PTR [eax], dx

; 935  :    pVciPlusInfoBlk->wPlusFlags|=VCI_STREAM_MANIPULATION;

  00047	8b 4d 08	 mov	 ecx, DWORD PTR _pVciPlusInfoBlk$[ebp]
  0004a	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0004d	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  00053	8b 45 08	 mov	 eax, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00056	66 89 10	 mov	 WORD PTR [eax], dx

; 936  :    pVciPlusInfoBlk->wPlusFlags|=VCI_CODEC_IS_SCALEABLE;

  00059	8b 4d 08	 mov	 ecx, DWORD PTR _pVciPlusInfoBlk$[ebp]
  0005c	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0005f	83 ca 40	 or	 edx, 64			; 00000040H
  00062	8b 45 08	 mov	 eax, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00065	66 89 10	 mov	 WORD PTR [eax], dx

; 937  :    pVciPlusInfoBlk->dwMinWarp=MIN_WARP;

  00068	8b 4d 08	 mov	 ecx, DWORD PTR _pVciPlusInfoBlk$[ebp]
  0006b	c7 41 04 00 00
	00 3f		 mov	 DWORD PTR [ecx+4], 1056964608 ; 3f000000H

; 938  :    pVciPlusInfoBlk->dwMaxWarp=MAX_WARP;

  00072	8b 55 08	 mov	 edx, DWORD PTR _pVciPlusInfoBlk$[ebp]
  00075	c7 42 08 00 00
	a0 40		 mov	 DWORD PTR [edx+8], 1084227584 ; 40a00000H

; 939  : 
; 940  :    return VCI_NO_ERROR;

  0007c	66 33 c0	 xor	 ax, ax

; 941  : }

  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
_vciGetPlusInfoSC@4 ENDP
_TEXT	ENDS
END
