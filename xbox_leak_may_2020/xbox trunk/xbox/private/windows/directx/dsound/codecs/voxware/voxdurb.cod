; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\voxdurb.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EA@NHNPOGBM@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@OEEAOMCE@iLpcOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@BGMKKMPN@pAutoCorr?5?$CB?$DN?5NULL?5?$CG?$CG?5pfLPCoef?5?$CB?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@HFNGDCHD@pfPARCOR?5?$CB?$DN?5NULL?5?$CG?$CG?5pfResidEnrg?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxDurbin@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
CONST	SEGMENT
_fOverflowThreshold DD 03f7ff972r		; 0.9999
CONST	ENDS
PUBLIC	_VoxDurbin@20
PUBLIC	??_C@_0EA@NHNPOGBM@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BL@OEEAOMCE@iLpcOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@ ; `string'
PUBLIC	??_C@_0CG@BGMKKMPN@pAutoCorr?5?$CB?$DN?5NULL?5?$CG?$CG?5pfLPCoef?5?$CB?$DN@ ; `string'
PUBLIC	??_C@_0CI@HFNGDCHD@pfPARCOR?5?$CB?$DN?5NULL?5?$CG?$CG?5pfResidEnrg?5@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
EXTRN	__fltused:NEAR
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0EA@NHNPOGBM@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\voxdurb.c
CONST	SEGMENT
??_C@_0EA@NHNPOGBM@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\voxdurb.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OEEAOMCE@iLpcOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@
CONST	SEGMENT
??_C@_0BL@OEEAOMCE@iLpcOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@ DB 'iLpcOrder '
	DB	'<= MAX_LPC_ORDER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BGMKKMPN@pAutoCorr?5?$CB?$DN?5NULL?5?$CG?$CG?5pfLPCoef?5?$CB?$DN@
CONST	SEGMENT
??_C@_0CG@BGMKKMPN@pAutoCorr?5?$CB?$DN?5NULL?5?$CG?$CG?5pfLPCoef?5?$CB?$DN@ DB 'p'
	DB	'AutoCorr != NULL && pfLPCoef != NULL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HFNGDCHD@pfPARCOR?5?$CB?$DN?5NULL?5?$CG?$CG?5pfResidEnrg?5@
CONST	SEGMENT
??_C@_0CI@HFNGDCHD@pfPARCOR?5?$CB?$DN?5NULL?5?$CG?$CG?5pfResidEnrg?5@ DB 'p'
	DB	'fPARCOR != NULL && pfResidEnrg != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxDurbin@20
_TEXT	SEGMENT
_j$ = -116
_pfA$ = -112
_pfA_1$ = -108
_fResidEnrg$ = -104
_fDelta$ = -100
_fTmp$ = -96
_i$ = -16
_pfSwap$ = -12
_fGamma$ = -8
_p$ = -4
_pAutoCorr$ = 8
_iLpcOrder$ = 12
_pfLPCoef$ = 16
_pfPARCOR$ = 20
_pfResidEnrg$ = 24
_VoxDurbin@20 PROC NEAR					; COMDAT

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	56		 push	 esi

; 58   :    int             i, j, p;
; 59   :    float           *pfA;
; 60   :    float           *pfA_1;
; 61   :    float          *pfSwap;
; 62   :    float           fTmp[MAX_LPC_ORDER+1];
; 63   :    float           fDelta;
; 64   :    float           fGamma;
; 65   :    float           fResidEnrg;
; 66   :    
; 67   :    assert(iLpcOrder <= MAX_LPC_ORDER);

  00007	83 7d 0c 12	 cmp	 DWORD PTR _iLpcOrder$[ebp], 18 ; 00000012H
  0000b	7e 14		 jle	 SHORT $L1191
  0000d	6a 43		 push	 67			; 00000043H
  0000f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@NHNPOGBM@c?3?2xbox?2private?2windows?2directx?2@
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@OEEAOMCE@iLpcOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@
  00019	e8 00 00 00 00	 call	 __assert
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1191:

; 68   :    assert(pAutoCorr != NULL && pfLPCoef != NULL);

  00021	83 7d 08 00	 cmp	 DWORD PTR _pAutoCorr$[ebp], 0
  00025	74 06		 je	 SHORT $L1192
  00027	83 7d 10 00	 cmp	 DWORD PTR _pfLPCoef$[ebp], 0
  0002b	75 14		 jne	 SHORT $L1193
$L1192:
  0002d	6a 44		 push	 68			; 00000044H
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@NHNPOGBM@c?3?2xbox?2private?2windows?2directx?2@
  00034	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@BGMKKMPN@pAutoCorr?5?$CB?$DN?5NULL?5?$CG?$CG?5pfLPCoef?5?$CB?$DN@
  00039	e8 00 00 00 00	 call	 __assert
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1193:

; 69   :    assert(pfPARCOR != NULL && pfResidEnrg != NULL);

  00041	83 7d 14 00	 cmp	 DWORD PTR _pfPARCOR$[ebp], 0
  00045	74 06		 je	 SHORT $L1194
  00047	83 7d 18 00	 cmp	 DWORD PTR _pfResidEnrg$[ebp], 0
  0004b	75 14		 jne	 SHORT $L1195
$L1194:
  0004d	6a 45		 push	 69			; 00000045H
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@NHNPOGBM@c?3?2xbox?2private?2windows?2directx?2@
  00054	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@HFNGDCHD@pfPARCOR?5?$CB?$DN?5NULL?5?$CG?$CG?5pfResidEnrg?5@
  00059	e8 00 00 00 00	 call	 __assert
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1195:

; 70   : 
; 71   :    /*--------------------------------------------------
; 72   :     check the frame energy first. If frame is almost
; 73   :     silence, put a small number for the energy.
; 74   :    --------------------------------------------------*/
; 75   :    fResidEnrg = pAutoCorr[0];

  00061	8b 45 08	 mov	 eax, DWORD PTR _pAutoCorr$[ebp]
  00064	8b 08		 mov	 ecx, DWORD PTR [eax]
  00066	89 4d 98	 mov	 DWORD PTR _fResidEnrg$[ebp], ecx

; 76   :    if (fResidEnrg == 0.0F)

  00069	d9 45 98	 fld	 DWORD PTR _fResidEnrg$[ebp]
  0006c	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00072	df e0		 fnstsw	 ax
  00074	f6 c4 44	 test	 ah, 68			; 00000044H
  00077	7a 07		 jp	 SHORT $L1166

; 77   :       fResidEnrg = VERY_SMALL_FLOAT;

  00079	c7 45 98 ea 1c
	08 02		 mov	 DWORD PTR _fResidEnrg$[ebp], 34086122 ; 02081ceaH
$L1166:

; 78   :    
; 79   :    /*--------------------------------------------------
; 80   :     do Leveinson-Durbin iteration.
; 81   :    --------------------------------------------------*/
; 82   :    if(iLpcOrder&1)           /* an odd number of iterations */

  00080	8b 55 0c	 mov	 edx, DWORD PTR _iLpcOrder$[ebp]
  00083	83 e2 01	 and	 edx, 1
  00086	85 d2		 test	 edx, edx
  00088	74 0e		 je	 SHORT $L1167

; 83   :    {
; 84   :       pfA    = fTmp;

  0008a	8d 45 a0	 lea	 eax, DWORD PTR _fTmp$[ebp]
  0008d	89 45 90	 mov	 DWORD PTR _pfA$[ebp], eax

; 85   :       pfA_1  = pfLPCoef;

  00090	8b 4d 10	 mov	 ecx, DWORD PTR _pfLPCoef$[ebp]
  00093	89 4d 94	 mov	 DWORD PTR _pfA_1$[ebp], ecx

; 86   :    }
; 87   :    else                    /* an even number of iterations */

  00096	eb 0c		 jmp	 SHORT $L1168
$L1167:

; 88   :    {  
; 89   :       pfA   = pfLPCoef;

  00098	8b 55 10	 mov	 edx, DWORD PTR _pfLPCoef$[ebp]
  0009b	89 55 90	 mov	 DWORD PTR _pfA$[ebp], edx

; 90   :       pfA_1 = fTmp;

  0009e	8d 45 a0	 lea	 eax, DWORD PTR _fTmp$[ebp]
  000a1	89 45 94	 mov	 DWORD PTR _pfA_1$[ebp], eax
$L1168:

; 91   :    }
; 92   : 
; 93   :    pfA[0] = pfA_1[0] = 1.0F;

  000a4	8b 4d 94	 mov	 ecx, DWORD PTR _pfA_1$[ebp]
  000a7	c7 01 00 00 80
	3f		 mov	 DWORD PTR [ecx], 1065353216 ; 3f800000H
  000ad	8b 55 90	 mov	 edx, DWORD PTR _pfA$[ebp]
  000b0	c7 02 00 00 80
	3f		 mov	 DWORD PTR [edx], 1065353216 ; 3f800000H

; 94   :    for (p=0; p<iLpcOrder; p++) 

  000b6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0
  000bd	eb 09		 jmp	 SHORT $L1169
$L1170:
  000bf	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  000c2	83 c0 01	 add	 eax, 1
  000c5	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax
$L1169:
  000c8	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  000cb	3b 4d 0c	 cmp	 ecx, DWORD PTR _iLpcOrder$[ebp]
  000ce	0f 8d 0f 01 00
	00		 jge	 $L1171

; 95   :    {
; 96   :       fDelta = 0.0F;

  000d4	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _fDelta$[ebp], 0

; 97   :       for( i=0; i<=p; i++) 

  000db	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e2	eb 09		 jmp	 SHORT $L1172
$L1173:
  000e4	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  000e7	83 c2 01	 add	 edx, 1
  000ea	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx
$L1172:
  000ed	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000f0	3b 45 fc	 cmp	 eax, DWORD PTR _p$[ebp]
  000f3	7f 20		 jg	 SHORT $L1174

; 98   :          fDelta += pfA[i] * pAutoCorr[p+1-i];

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  000f8	83 c1 01	 add	 ecx, 1
  000fb	2b 4d f0	 sub	 ecx, DWORD PTR _i$[ebp]
  000fe	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00101	8b 45 90	 mov	 eax, DWORD PTR _pfA$[ebp]
  00104	8b 75 08	 mov	 esi, DWORD PTR _pAutoCorr$[ebp]
  00107	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  0010a	d8 0c 8e	 fmul	 DWORD PTR [esi+ecx*4]
  0010d	d8 45 9c	 fadd	 DWORD PTR _fDelta$[ebp]
  00110	d9 5d 9c	 fstp	 DWORD PTR _fDelta$[ebp]
  00113	eb cf		 jmp	 SHORT $L1173
$L1174:

; 99   :    
; 100  :       /*--------------------------------------------------
; 101  :          calculate reflection coefficients (Equation 5.3.11
; 102  :          page 205). Then convergence checking is applied.
; 103  :       --------------------------------------------------*/
; 104  :       fGamma =  fDelta / fResidEnrg;

  00115	d9 45 9c	 fld	 DWORD PTR _fDelta$[ebp]
  00118	d8 75 98	 fdiv	 DWORD PTR _fResidEnrg$[ebp]
  0011b	d9 55 f8	 fst	 DWORD PTR _fGamma$[ebp]

; 105  : 
; 106  :       if ( fGamma > fOverflowThreshold ) 

  0011e	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR _fOverflowThreshold
  00124	df e0		 fnstsw	 ax
  00126	f6 c4 41	 test	 ah, 65			; 00000041H
  00129	75 09		 jne	 SHORT $L1175

; 107  :          fGamma = fOverflowThreshold;

  0012b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _fOverflowThreshold
  00131	89 4d f8	 mov	 DWORD PTR _fGamma$[ebp], ecx
$L1175:

; 108  :       if ( fGamma < (-fOverflowThreshold) ) 

  00134	d9 05 00 00 00
	00		 fld	 DWORD PTR _fOverflowThreshold
  0013a	d9 e0		 fchs
  0013c	d8 5d f8	 fcomp	 DWORD PTR _fGamma$[ebp]
  0013f	df e0		 fnstsw	 ax
  00141	f6 c4 41	 test	 ah, 65			; 00000041H
  00144	75 0b		 jne	 SHORT $L1176

; 109  :          fGamma = (-fOverflowThreshold);      

  00146	d9 05 00 00 00
	00		 fld	 DWORD PTR _fOverflowThreshold
  0014c	d9 e0		 fchs
  0014e	d9 5d f8	 fstp	 DWORD PTR _fGamma$[ebp]
$L1176:

; 110  : 
; 111  :       *pfPARCOR++ = fGamma;

  00151	8b 55 14	 mov	 edx, DWORD PTR _pfPARCOR$[ebp]
  00154	8b 45 f8	 mov	 eax, DWORD PTR _fGamma$[ebp]
  00157	89 02		 mov	 DWORD PTR [edx], eax
  00159	8b 4d 14	 mov	 ecx, DWORD PTR _pfPARCOR$[ebp]
  0015c	83 c1 04	 add	 ecx, 4
  0015f	89 4d 14	 mov	 DWORD PTR _pfPARCOR$[ebp], ecx

; 112  :      
; 113  :       /*------------------------------------------------------
; 114  :         Move pfA[] to pfA_1[] by swapping pointers
; 115  :       ------------------------------------------------------*/
; 116  :       pfSwap = pfA;   /* swap pfA with pfA_1 */

  00162	8b 55 90	 mov	 edx, DWORD PTR _pfA$[ebp]
  00165	89 55 f4	 mov	 DWORD PTR _pfSwap$[ebp], edx

; 117  :       pfA    = pfA_1;

  00168	8b 45 94	 mov	 eax, DWORD PTR _pfA_1$[ebp]
  0016b	89 45 90	 mov	 DWORD PTR _pfA$[ebp], eax

; 118  :       pfA_1  = pfSwap;

  0016e	8b 4d f4	 mov	 ecx, DWORD PTR _pfSwap$[ebp]
  00171	89 4d 94	 mov	 DWORD PTR _pfA_1$[ebp], ecx

; 119  : 
; 120  :       /*------------------------------------------------------
; 121  :         Compute (i+1)th order predictor coefficients
; 122  :       ------------------------------------------------------*/
; 123  :       pfA[p+1] = -fGamma;

  00174	d9 45 f8	 fld	 DWORD PTR _fGamma$[ebp]
  00177	d9 e0		 fchs
  00179	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0017c	8b 45 90	 mov	 eax, DWORD PTR _pfA$[ebp]
  0017f	d9 5c 90 04	 fstp	 DWORD PTR [eax+edx*4+4]

; 124  :       for (j=1, i=p; j<=p; j++, i--)

  00183	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _j$[ebp], 1
  0018a	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0018d	89 4d f0	 mov	 DWORD PTR _i$[ebp], ecx
  00190	eb 12		 jmp	 SHORT $L1177
$L1178:
  00192	8b 55 8c	 mov	 edx, DWORD PTR _j$[ebp]
  00195	83 c2 01	 add	 edx, 1
  00198	89 55 8c	 mov	 DWORD PTR _j$[ebp], edx
  0019b	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0019e	83 e8 01	 sub	 eax, 1
  001a1	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$L1177:
  001a4	8b 4d 8c	 mov	 ecx, DWORD PTR _j$[ebp]
  001a7	3b 4d fc	 cmp	 ecx, DWORD PTR _p$[ebp]
  001aa	7f 20		 jg	 SHORT $L1179

; 125  :          pfA[j] = pfA_1[j] - fGamma*pfA_1[i];

  001ac	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  001af	8b 45 94	 mov	 eax, DWORD PTR _pfA_1$[ebp]
  001b2	d9 45 f8	 fld	 DWORD PTR _fGamma$[ebp]
  001b5	d8 0c 90	 fmul	 DWORD PTR [eax+edx*4]
  001b8	8b 4d 8c	 mov	 ecx, DWORD PTR _j$[ebp]
  001bb	8b 55 94	 mov	 edx, DWORD PTR _pfA_1$[ebp]
  001be	d8 2c 8a	 fsubr	 DWORD PTR [edx+ecx*4]
  001c1	8b 45 8c	 mov	 eax, DWORD PTR _j$[ebp]
  001c4	8b 4d 90	 mov	 ecx, DWORD PTR _pfA$[ebp]
  001c7	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]
  001ca	eb c6		 jmp	 SHORT $L1178
$L1179:

; 126  :    
; 127  :       /*--------------------------------------------------
; 128  :         iteratively calculate residue energy.
; 129  :       --------------------------------------------------*/
; 130  :       fResidEnrg *= 1.0F-fGamma*fGamma;

  001cc	d9 45 f8	 fld	 DWORD PTR _fGamma$[ebp]
  001cf	d8 4d f8	 fmul	 DWORD PTR _fGamma$[ebp]
  001d2	d8 2d 00 00 00
	00		 fsubr	 DWORD PTR __real@3f800000
  001d8	d8 4d 98	 fmul	 DWORD PTR _fResidEnrg$[ebp]
  001db	d9 5d 98	 fstp	 DWORD PTR _fResidEnrg$[ebp]

; 131  :    }

  001de	e9 dc fe ff ff	 jmp	 $L1170
$L1171:

; 132  :    *pfResidEnrg = fResidEnrg;

  001e3	8b 55 18	 mov	 edx, DWORD PTR _pfResidEnrg$[ebp]
  001e6	8b 45 98	 mov	 eax, DWORD PTR _fResidEnrg$[ebp]
  001e9	89 02		 mov	 DWORD PTR [edx], eax

; 133  : }

  001eb	5e		 pop	 esi
  001ec	8b e5		 mov	 esp, ebp
  001ee	5d		 pop	 ebp
  001ef	c2 14 00	 ret	 20			; 00000014H
_VoxDurbin@20 ENDP
_TEXT	ENDS
END
