; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\lpcsynth.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxLPCSyn@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxInitLPCSyn@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxFreeLPCSyn@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
CONST	SEGMENT
_cfInvRate8k DD	03903126fr			; 0.000125
CONST	ENDS
PUBLIC	_VoxLPCSyn@16
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@42340000
PUBLIC	__real@46fa0000
PUBLIC	__real@c6fa0000
EXTRN	_VoxLspToAsEven@16:NEAR
EXTRN	_DotProd@12:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	_memcpy:NEAR
;	COMDAT __real@3fd0000000000000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\lpcsynth.c
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@42340000
CONST	SEGMENT
__real@42340000 DD 042340000r			; 45
CONST	ENDS
;	COMDAT __real@46fa0000
CONST	SEGMENT
__real@46fa0000 DD 046fa0000r			; 32000
CONST	ENDS
;	COMDAT __real@c6fa0000
CONST	SEGMENT
__real@c6fa0000 DD 0c6fa0000r			; -32000
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxLPCSyn@16
_TEXT	SEGMENT
tv223 = -152
_SubframeLen$ = -148
_InterpFactor$ = -144
_deltaInterp$ = -140
_Offset_exciteIN$ = -136
_Synthesis_mblk$ = -132
_pexciteIN$ = -128
_lpcMEM$ = -124
_prevLSP$ = -120
_temp$ = -116
_TrueSubLen$ = -112
_pSpeech$ = -108
_SubFrame$ = -104
_Samp$ = -100
_i$ = -96
_interpLSP$ = -92
_interpLPC$ = -52
_SampsDone$ = -8
_Index$ = -4
_lsp$ = 8
_exciteIN$ = 12
_pSynthesis_mblk$ = 16
_outputLEN$ = 20
_VoxLPCSyn@16 PROC NEAR					; COMDAT

; 100  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	56		 push	 esi

; 101  :    Synthesis *Synthesis_mblk = (Synthesis *)pSynthesis_mblk;

  0000a	8b 45 10	 mov	 eax, DWORD PTR _pSynthesis_mblk$[ebp]
  0000d	89 85 7c ff ff
	ff		 mov	 DWORD PTR _Synthesis_mblk$[ebp], eax

; 102  :    float     *prevLSP        = Synthesis_mblk->prevLSP;

  00013	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _Synthesis_mblk$[ebp]
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	89 55 88	 mov	 DWORD PTR _prevLSP$[ebp], edx

; 103  : 
; 104  :    STACK_INIT
; 105  :    float    interpLSP[LPC_ORDER];
; 106  :    float    interpLPC[LPC_ORDER+1];
; 107  :    STACK_INIT_END
; 108  :    STACK_ATTACH(float*,interpLSP)
; 109  :    STACK_ATTACH(float*,interpLPC)
; 110  :    float   *lpcMEM = Synthesis_mblk->lpcMEM;

  0001e	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _Synthesis_mblk$[ebp]
  00024	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00027	89 4d 84	 mov	 DWORD PTR _lpcMEM$[ebp], ecx

; 111  :    int      SubFrame, Samp, Index;
; 112  :    float    InterpFactor;
; 113  :    int      SampsDone;
; 114  :    float    temp;
; 115  :    float   *pexciteIN, *Offset_exciteIN;
; 116  :    short    SubframeLen;
; 117  :    short    TrueSubLen;
; 118  :    float    deltaInterp;
; 119  :    int      i;
; 120  :    float   *pSpeech;
; 121  : 
; 122  :    STACK_START
; 123  : 
; 124  :  /*--------------------------------------------------
; 125  :    Compute the number of lsf subframes we should use
; 126  :    --------------------------------------------------*/
; 127  :    TrueSubLen  = (short)(((float)outputLEN)*(1.0/(float)LPCSYN_SUBFRAMES));

  0002a	0f bf 55 14	 movsx	 edx, WORD PTR _outputLEN$[ebp]
  0002e	89 95 68 ff ff
	ff		 mov	 DWORD PTR tv223[ebp], edx
  00034	db 85 68 ff ff
	ff		 fild	 DWORD PTR tv223[ebp]
  0003a	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fd0000000000000
  00040	e8 00 00 00 00	 call	 __ftol2
  00045	66 89 45 90	 mov	 WORD PTR _TrueSubLen$[ebp], ax

; 128  :    SubframeLen = TrueSubLen>>1;  /* first subframe is half */

  00049	0f bf 45 90	 movsx	 eax, WORD PTR _TrueSubLen$[ebp]
  0004d	d1 f8		 sar	 eax, 1
  0004f	66 89 85 6c ff
	ff ff		 mov	 WORD PTR _SubframeLen$[ebp], ax

; 129  :    deltaInterp = (1.0F/((float)LPCSYN_SUBFRAMES));

  00056	c7 85 74 ff ff
	ff 00 00 80 3e	 mov	 DWORD PTR _deltaInterp$[ebp], 1048576000 ; 3e800000H

; 130  : 
; 131  :  /*------------------------------------------------
; 132  :    Copy the memory into the input buffer
; 133  :    ------------------------------------------------*/
; 134  :    memcpy(exciteIN, lpcMEM, LPC_ORDER*sizeof(*exciteIN));

  00060	6a 28		 push	 40			; 00000028H
  00062	8b 4d 84	 mov	 ecx, DWORD PTR _lpcMEM$[ebp]
  00065	51		 push	 ecx
  00066	8b 55 0c	 mov	 edx, DWORD PTR _exciteIN$[ebp]
  00069	52		 push	 edx
  0006a	e8 00 00 00 00	 call	 _memcpy
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 135  : 
; 136  :  /*------------------------------------------------
; 137  :    For each Subframe ...
; 138  :       1. Interpolate the lsp's
; 139  :       2. Convert lsp's to lpc's
; 140  :       3. Filter 1 subframe worth of excitation
; 141  :    ------------------------------------------------*/
; 142  :    SampsDone=0;

  00072	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _SampsDone$[ebp], 0

; 143  :    Offset_exciteIN = exciteIN; /* speeds stuff up below */

  00079	8b 45 0c	 mov	 eax, DWORD PTR _exciteIN$[ebp]
  0007c	89 85 78 ff ff
	ff		 mov	 DWORD PTR _Offset_exciteIN$[ebp], eax

; 144  :    InterpFactor = 0.0F;

  00082	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _InterpFactor$[ebp], 0

; 145  :    VoxLspToAsEven(prevLSP, LPC_ORDER, cfInvRate8k, interpLPC);

  0008c	8d 4d cc	 lea	 ecx, DWORD PTR _interpLPC$[ebp]
  0008f	51		 push	 ecx
  00090	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _cfInvRate8k
  00096	52		 push	 edx
  00097	6a 0a		 push	 10			; 0000000aH
  00099	8b 45 88	 mov	 eax, DWORD PTR _prevLSP$[ebp]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _VoxLspToAsEven@16

; 146  : 
; 147  :    for (SubFrame=0; SubFrame<=LPCSYN_SUBFRAMES; SubFrame++)

  000a2	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _SubFrame$[ebp], 0
  000a9	eb 09		 jmp	 SHORT $L1453
$L1454:
  000ab	8b 4d 98	 mov	 ecx, DWORD PTR _SubFrame$[ebp]
  000ae	83 c1 01	 add	 ecx, 1
  000b1	89 4d 98	 mov	 DWORD PTR _SubFrame$[ebp], ecx
$L1453:
  000b4	83 7d 98 04	 cmp	 DWORD PTR _SubFrame$[ebp], 4
  000b8	0f 8f aa 01 00
	00		 jg	 $L1455

; 148  :    {
; 149  :       for (i=0;i<(LPC_ORDER>>1);i++)

  000be	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000c5	eb 09		 jmp	 SHORT $L1456
$L1457:
  000c7	8b 55 a0	 mov	 edx, DWORD PTR _i$[ebp]
  000ca	83 c2 01	 add	 edx, 1
  000cd	89 55 a0	 mov	 DWORD PTR _i$[ebp], edx
$L1456:
  000d0	83 7d a0 05	 cmp	 DWORD PTR _i$[ebp], 5
  000d4	7d 32		 jge	 SHORT $L1458

; 150  :       {
; 151  :          temp = interpLPC[i+1];

  000d6	8b 45 a0	 mov	 eax, DWORD PTR _i$[ebp]
  000d9	8b 4c 85 d0	 mov	 ecx, DWORD PTR _interpLPC$[ebp+eax*4+4]
  000dd	89 4d 8c	 mov	 DWORD PTR _temp$[ebp], ecx

; 152  :          interpLPC[i+1] = -interpLPC[LPC_ORDER-i];

  000e0	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
  000e5	2b 55 a0	 sub	 edx, DWORD PTR _i$[ebp]
  000e8	d9 44 95 cc	 fld	 DWORD PTR _interpLPC$[ebp+edx*4]
  000ec	d9 e0		 fchs
  000ee	8b 45 a0	 mov	 eax, DWORD PTR _i$[ebp]
  000f1	d9 5c 85 d0	 fstp	 DWORD PTR _interpLPC$[ebp+eax*4+4]

; 153  :          interpLPC[LPC_ORDER-i] = -temp;

  000f5	d9 45 8c	 fld	 DWORD PTR _temp$[ebp]
  000f8	d9 e0		 fchs
  000fa	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000ff	2b 4d a0	 sub	 ecx, DWORD PTR _i$[ebp]
  00102	d9 5c 8d cc	 fstp	 DWORD PTR _interpLPC$[ebp+ecx*4]

; 154  :       }

  00106	eb bf		 jmp	 SHORT $L1457
$L1458:

; 155  : 
; 156  :       if (SubFrame == (LPCSYN_SUBFRAMES))

  00108	83 7d 98 04	 cmp	 DWORD PTR _SubFrame$[ebp], 4
  0010c	75 0e		 jne	 SHORT $L1459

; 157  :           SubframeLen = outputLEN - SampsDone;

  0010e	0f bf 55 14	 movsx	 edx, WORD PTR _outputLEN$[ebp]
  00112	2b 55 f8	 sub	 edx, DWORD PTR _SampsDone$[ebp]
  00115	66 89 95 6c ff
	ff ff		 mov	 WORD PTR _SubframeLen$[ebp], dx
$L1459:

; 158  : 
; 159  :       for (Samp = SampsDone; Samp<(SampsDone+SubframeLen); Samp++)

  0011c	8b 45 f8	 mov	 eax, DWORD PTR _SampsDone$[ebp]
  0011f	89 45 9c	 mov	 DWORD PTR _Samp$[ebp], eax
  00122	eb 09		 jmp	 SHORT $L1460
$L1461:
  00124	8b 4d 9c	 mov	 ecx, DWORD PTR _Samp$[ebp]
  00127	83 c1 01	 add	 ecx, 1
  0012a	89 4d 9c	 mov	 DWORD PTR _Samp$[ebp], ecx
$L1460:
  0012d	0f bf 95 6c ff
	ff ff		 movsx	 edx, WORD PTR _SubframeLen$[ebp]
  00134	8b 45 f8	 mov	 eax, DWORD PTR _SampsDone$[ebp]
  00137	03 c2		 add	 eax, edx
  00139	39 45 9c	 cmp	 DWORD PTR _Samp$[ebp], eax
  0013c	7d 39		 jge	 SHORT $L1462

; 160  :       {
; 161  :          temp=0.0F;

  0013e	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _temp$[ebp], 0

; 162  :          pexciteIN = Offset_exciteIN+Samp;

  00145	8b 4d 9c	 mov	 ecx, DWORD PTR _Samp$[ebp]
  00148	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _Offset_exciteIN$[ebp]
  0014e	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00151	89 45 80	 mov	 DWORD PTR _pexciteIN$[ebp], eax

; 163  : 
; 164  :          temp = (float)DotProd(pexciteIN, interpLPC+1, LPC_ORDER);

  00154	6a 0a		 push	 10			; 0000000aH
  00156	8d 4d d0	 lea	 ecx, DWORD PTR _interpLPC$[ebp+4]
  00159	51		 push	 ecx
  0015a	8b 55 80	 mov	 edx, DWORD PTR _pexciteIN$[ebp]
  0015d	52		 push	 edx
  0015e	e8 00 00 00 00	 call	 _DotProd@12
  00163	d9 5d 8c	 fstp	 DWORD PTR _temp$[ebp]

; 165  :          *(pexciteIN+LPC_ORDER)+=temp;

  00166	8b 45 80	 mov	 eax, DWORD PTR _pexciteIN$[ebp]
  00169	d9 45 8c	 fld	 DWORD PTR _temp$[ebp]
  0016c	d8 40 28	 fadd	 DWORD PTR [eax+40]
  0016f	8b 4d 80	 mov	 ecx, DWORD PTR _pexciteIN$[ebp]
  00172	d9 59 28	 fstp	 DWORD PTR [ecx+40]

; 166  :       }

  00175	eb ad		 jmp	 SHORT $L1461
$L1462:

; 167  :       SampsDone+=SubframeLen;

  00177	0f bf 95 6c ff
	ff ff		 movsx	 edx, WORD PTR _SubframeLen$[ebp]
  0017e	8b 45 f8	 mov	 eax, DWORD PTR _SampsDone$[ebp]
  00181	03 c2		 add	 eax, edx
  00183	89 45 f8	 mov	 DWORD PTR _SampsDone$[ebp], eax

; 168  :       SubframeLen = TrueSubLen;

  00186	66 8b 4d 90	 mov	 cx, WORD PTR _TrueSubLen$[ebp]
  0018a	66 89 8d 6c ff
	ff ff		 mov	 WORD PTR _SubframeLen$[ebp], cx

; 169  : 
; 170  :       InterpFactor += deltaInterp;

  00191	d9 85 70 ff ff
	ff		 fld	 DWORD PTR _InterpFactor$[ebp]
  00197	d8 85 74 ff ff
	ff		 fadd	 DWORD PTR _deltaInterp$[ebp]
  0019d	d9 9d 70 ff ff
	ff		 fstp	 DWORD PTR _InterpFactor$[ebp]

; 171  :       if (SubFrame == (LPCSYN_SUBFRAMES-1))

  001a3	83 7d 98 03	 cmp	 DWORD PTR _SubFrame$[ebp], 3
  001a7	75 1a		 jne	 SHORT $L1464

; 172  :       {
; 173  :          VoxLspToAsEven(lsp, LPC_ORDER, cfInvRate8k, interpLPC);   

  001a9	8d 55 cc	 lea	 edx, DWORD PTR _interpLPC$[ebp]
  001ac	52		 push	 edx
  001ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _cfInvRate8k
  001b2	50		 push	 eax
  001b3	6a 0a		 push	 10			; 0000000aH
  001b5	8b 4d 08	 mov	 ecx, DWORD PTR _lsp$[ebp]
  001b8	51		 push	 ecx
  001b9	e8 00 00 00 00	 call	 _VoxLspToAsEven@16

; 174  :       }
; 175  :       else

  001be	e9 a0 00 00 00	 jmp	 $L1465
$L1464:

; 176  :       {
; 177  :          for (Index=0; Index<LPC_ORDER; Index++)

  001c3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0
  001ca	eb 09		 jmp	 SHORT $L1466
$L1467:
  001cc	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  001cf	83 c2 01	 add	 edx, 1
  001d2	89 55 fc	 mov	 DWORD PTR _Index$[ebp], edx
$L1466:
  001d5	83 7d fc 0a	 cmp	 DWORD PTR _Index$[ebp], 10 ; 0000000aH
  001d9	7d 2a		 jge	 SHORT $L1468

; 178  :          {
; 179  :             interpLSP[Index] = prevLSP[Index]+((lsp[Index]-prevLSP[Index])*InterpFactor);

  001db	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  001de	8b 4d 08	 mov	 ecx, DWORD PTR _lsp$[ebp]
  001e1	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  001e4	8b 75 88	 mov	 esi, DWORD PTR _prevLSP$[ebp]
  001e7	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  001ea	d8 24 96	 fsub	 DWORD PTR [esi+edx*4]
  001ed	d8 8d 70 ff ff
	ff		 fmul	 DWORD PTR _InterpFactor$[ebp]
  001f3	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  001f6	8b 4d 88	 mov	 ecx, DWORD PTR _prevLSP$[ebp]
  001f9	d8 04 81	 fadd	 DWORD PTR [ecx+eax*4]
  001fc	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  001ff	d9 5c 95 a4	 fstp	 DWORD PTR _interpLSP$[ebp+edx*4]

; 180  :          }

  00203	eb c7		 jmp	 SHORT $L1467
$L1468:

; 181  : 
; 182  :        /*-----------------------------------------------------
; 183  :          Make sure that after interpolation, that the lsp's
; 184  :          are seperated by at least LSP_SEPERATION_HZ Hertz
; 185  :          -----------------------------------------------------*/
; 186  :          for (Index=1; Index<LPC_ORDER; Index++)

  00205	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 1
  0020c	eb 09		 jmp	 SHORT $L1469
$L1470:
  0020e	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00211	83 c0 01	 add	 eax, 1
  00214	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$L1469:
  00217	83 7d fc 0a	 cmp	 DWORD PTR _Index$[ebp], 10 ; 0000000aH
  0021b	7d 31		 jge	 SHORT $L1471

; 187  :             if ((interpLSP[Index] + LSP_SEPERATION_HZ)<interpLSP[Index-1])

  0021d	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00220	d9 44 8d a4	 fld	 DWORD PTR _interpLSP$[ebp+ecx*4]
  00224	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@42340000
  0022a	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  0022d	d8 5c 95 a0	 fcomp	 DWORD PTR _interpLSP$[ebp+edx*4-4]
  00231	df e0		 fnstsw	 ax
  00233	f6 c4 05	 test	 ah, 5
  00236	7a 14		 jp	 SHORT $L1472

; 188  :                interpLSP[Index] = (float)(interpLSP[Index-1]+LSP_SEPERATION_HZ);

  00238	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0023b	d9 44 85 a0	 fld	 DWORD PTR _interpLSP$[ebp+eax*4-4]
  0023f	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@42340000
  00245	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00248	d9 5c 8d a4	 fstp	 DWORD PTR _interpLSP$[ebp+ecx*4]
$L1472:

; 189  : 
; 190  :          VoxLspToAsEven(interpLSP, LPC_ORDER, cfInvRate8k, interpLPC);

  0024c	eb c0		 jmp	 SHORT $L1470
$L1471:
  0024e	8d 55 cc	 lea	 edx, DWORD PTR _interpLPC$[ebp]
  00251	52		 push	 edx
  00252	a1 00 00 00 00	 mov	 eax, DWORD PTR _cfInvRate8k
  00257	50		 push	 eax
  00258	6a 0a		 push	 10			; 0000000aH
  0025a	8d 4d a4	 lea	 ecx, DWORD PTR _interpLSP$[ebp]
  0025d	51		 push	 ecx
  0025e	e8 00 00 00 00	 call	 _VoxLspToAsEven@16
$L1465:

; 191  :       }
; 192  :    }

  00263	e9 43 fe ff ff	 jmp	 $L1454
$L1455:

; 193  : 
; 194  :  /*---------------------------------------------------------
; 195  :    Update frame-to-frame memory of lsps, filter...
; 196  :    ---------------------------------------------------------*/ 
; 197  :    memcpy(Synthesis_mblk->prevLSP, lsp, LPC_ORDER*sizeof(*Synthesis_mblk->prevLSP));

  00268	6a 28		 push	 40			; 00000028H
  0026a	8b 55 08	 mov	 edx, DWORD PTR _lsp$[ebp]
  0026d	52		 push	 edx
  0026e	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _Synthesis_mblk$[ebp]
  00274	8b 08		 mov	 ecx, DWORD PTR [eax]
  00276	51		 push	 ecx
  00277	e8 00 00 00 00	 call	 _memcpy
  0027c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 198  :    memcpy(Synthesis_mblk->lpcMEM, &(Offset_exciteIN[outputLEN]),
; 199  :           sizeof(*Synthesis_mblk->lpcMEM)*LPC_ORDER);

  0027f	6a 28		 push	 40			; 00000028H
  00281	0f bf 55 14	 movsx	 edx, WORD PTR _outputLEN$[ebp]
  00285	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _Offset_exciteIN$[ebp]
  0028b	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0028e	51		 push	 ecx
  0028f	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _Synthesis_mblk$[ebp]
  00295	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00298	50		 push	 eax
  00299	e8 00 00 00 00	 call	 _memcpy
  0029e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 200  : 
; 201  :  /*--------------------------------------------------------
; 202  :    Check overflow before writing to the SHORT output buffer
; 203  :    --------------------------------------------------------*/
; 204  :    pSpeech = Offset_exciteIN + LPC_ORDER;

  002a1	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _Offset_exciteIN$[ebp]
  002a7	83 c1 28	 add	 ecx, 40			; 00000028H
  002aa	89 4d 94	 mov	 DWORD PTR _pSpeech$[ebp], ecx

; 205  :    for (Index=0; Index<outputLEN; Index++)

  002ad	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0
  002b4	eb 09		 jmp	 SHORT $L1474
$L1475:
  002b6	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  002b9	83 c2 01	 add	 edx, 1
  002bc	89 55 fc	 mov	 DWORD PTR _Index$[ebp], edx
$L1474:
  002bf	0f bf 45 14	 movsx	 eax, WORD PTR _outputLEN$[ebp]
  002c3	39 45 fc	 cmp	 DWORD PTR _Index$[ebp], eax
  002c6	7d 4a		 jge	 SHORT $L1476

; 206  :    {
; 207  :       if (pSpeech[Index] > (float)SPEECH_CLIP_MAX)

  002c8	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  002cb	8b 55 94	 mov	 edx, DWORD PTR _pSpeech$[ebp]
  002ce	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  002d1	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@46fa0000
  002d7	df e0		 fnstsw	 ax
  002d9	f6 c4 41	 test	 ah, 65			; 00000041H
  002dc	75 0f		 jne	 SHORT $L1478

; 208  :          pSpeech[Index] = (float)SPEECH_CLIP_MAX;

  002de	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  002e1	8b 4d 94	 mov	 ecx, DWORD PTR _pSpeech$[ebp]
  002e4	c7 04 81 00 00
	fa 46		 mov	 DWORD PTR [ecx+eax*4], 1190789120 ; 46fa0000H

; 209  :       else if (pSpeech[Index] < (float)SPEECH_CLIP_MIN)

  002eb	eb 23		 jmp	 SHORT $L1480
$L1478:
  002ed	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  002f0	8b 45 94	 mov	 eax, DWORD PTR _pSpeech$[ebp]
  002f3	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  002f6	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@c6fa0000
  002fc	df e0		 fnstsw	 ax
  002fe	f6 c4 05	 test	 ah, 5
  00301	7a 0d		 jp	 SHORT $L1480

; 210  :          pSpeech[Index] = (float)SPEECH_CLIP_MIN;

  00303	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00306	8b 55 94	 mov	 edx, DWORD PTR _pSpeech$[ebp]
  00309	c7 04 8a 00 00
	fa c6		 mov	 DWORD PTR [edx+ecx*4], -956694528 ; c6fa0000H
$L1480:

; 211  :    }

  00310	eb a4		 jmp	 SHORT $L1475
$L1476:

; 212  : 
; 213  : 
; 214  :    STACK_END
; 215  :    return 0;

  00312	66 33 c0	 xor	 ax, ax

; 216  : } 

  00315	5e		 pop	 esi
  00316	8b e5		 mov	 esp, ebp
  00318	5d		 pop	 ebp
  00319	c2 10 00	 ret	 16			; 00000010H
_VoxLPCSyn@16 ENDP
_TEXT	ENDS
PUBLIC	_VoxInitLPCSyn@4
PUBLIC	__real@43c80000
PUBLIC	__real@43960000
EXTRN	_calloc:NEAR
;	COMDAT __real@43c80000
CONST	SEGMENT
__real@43c80000 DD 043c80000r			; 400
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxInitLPCSyn@4
_TEXT	SEGMENT
tv145 = -12
_Synthesis_mblk$ = -8
_i$ = -4
_hSynthesis_mblk$ = 8
_VoxInitLPCSyn@4 PROC NEAR				; COMDAT

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 243  :    Synthesis *Synthesis_mblk;
; 244  :    short i;
; 245  : 
; 246  :    if(VOX_MEM_INIT(Synthesis_mblk=*hSynthesis_mblk,1,sizeof(Synthesis)))

  00006	6a 08		 push	 8
  00008	6a 01		 push	 1
  0000a	e8 00 00 00 00	 call	 _calloc
  0000f	83 c4 08	 add	 esp, 8
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _hSynthesis_mblk$[ebp]
  00015	89 01		 mov	 DWORD PTR [ecx], eax
  00017	8b 55 08	 mov	 edx, DWORD PTR _hSynthesis_mblk$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	89 45 f8	 mov	 DWORD PTR _Synthesis_mblk$[ebp], eax
  0001f	83 7d f8 00	 cmp	 DWORD PTR _Synthesis_mblk$[ebp], 0
  00023	75 09		 jne	 SHORT $L1490

; 247  :       return 1;

  00025	66 b8 01 00	 mov	 ax, 1
  00029	e9 b7 00 00 00	 jmp	 $L1486
$L1490:

; 248  : 
; 249  :    if(VOX_MEM_INIT(Synthesis_mblk->prevLSP,LPC_ORDER,sizeof(float))) 

  0002e	6a 04		 push	 4
  00030	6a 0a		 push	 10			; 0000000aH
  00032	e8 00 00 00 00	 call	 _calloc
  00037	83 c4 08	 add	 esp, 8
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _Synthesis_mblk$[ebp]
  0003d	89 01		 mov	 DWORD PTR [ecx], eax
  0003f	8b 55 f8	 mov	 edx, DWORD PTR _Synthesis_mblk$[ebp]
  00042	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00045	75 09		 jne	 SHORT $L1492

; 250  :       return 1;

  00047	66 b8 01 00	 mov	 ax, 1
  0004b	e9 95 00 00 00	 jmp	 $L1486
$L1492:

; 251  : 
; 252  :    if(VOX_MEM_INIT(Synthesis_mblk->lpcMEM,LPC_ORDER,sizeof(float))) 

  00050	6a 04		 push	 4
  00052	6a 0a		 push	 10			; 0000000aH
  00054	e8 00 00 00 00	 call	 _calloc
  00059	83 c4 08	 add	 esp, 8
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _Synthesis_mblk$[ebp]
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 f8	 mov	 edx, DWORD PTR _Synthesis_mblk$[ebp]
  00065	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00069	75 06		 jne	 SHORT $L1494

; 253  :       return 1;

  0006b	66 b8 01 00	 mov	 ax, 1
  0006f	eb 74		 jmp	 SHORT $L1486
$L1494:

; 254  : 
; 255  :    for(i=0;i<LPC_ORDER;i++) 

  00071	66 c7 45 fc 00
	00		 mov	 WORD PTR _i$[ebp], 0
  00077	eb 0c		 jmp	 SHORT $L1495
$L1496:
  00079	66 8b 45 fc	 mov	 ax, WORD PTR _i$[ebp]
  0007d	66 05 01 00	 add	 ax, 1
  00081	66 89 45 fc	 mov	 WORD PTR _i$[ebp], ax
$L1495:
  00085	0f bf 4d fc	 movsx	 ecx, WORD PTR _i$[ebp]
  00089	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0008c	7d 13		 jge	 SHORT $L1497

; 256  :       (Synthesis_mblk->lpcMEM)[i]=0.0F;

  0008e	0f bf 55 fc	 movsx	 edx, WORD PTR _i$[ebp]
  00092	8b 45 f8	 mov	 eax, DWORD PTR _Synthesis_mblk$[ebp]
  00095	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00098	c7 04 91 00 00
	00 00		 mov	 DWORD PTR [ecx+edx*4], 0
  0009f	eb d8		 jmp	 SHORT $L1496
$L1497:

; 257  : 
; 258  :       for(i=0;i<LPC_ORDER;i++) 

  000a1	66 c7 45 fc 00
	00		 mov	 WORD PTR _i$[ebp], 0
  000a7	eb 0c		 jmp	 SHORT $L1498
$L1499:
  000a9	66 8b 55 fc	 mov	 dx, WORD PTR _i$[ebp]
  000ad	66 83 c2 01	 add	 dx, 1
  000b1	66 89 55 fc	 mov	 WORD PTR _i$[ebp], dx
$L1498:
  000b5	0f bf 45 fc	 movsx	 eax, WORD PTR _i$[ebp]
  000b9	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000bc	7d 24		 jge	 SHORT $L1500

; 259  : 		Synthesis_mblk->prevLSP[i] = LSP_INITIAL_COND_DEL*i + LSP_INITIAL_COND_0;

  000be	0f bf 4d fc	 movsx	 ecx, WORD PTR _i$[ebp]
  000c2	89 4d f4	 mov	 DWORD PTR tv145[ebp], ecx
  000c5	db 45 f4	 fild	 DWORD PTR tv145[ebp]
  000c8	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@43c80000
  000ce	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@43960000
  000d4	0f bf 55 fc	 movsx	 edx, WORD PTR _i$[ebp]
  000d8	8b 45 f8	 mov	 eax, DWORD PTR _Synthesis_mblk$[ebp]
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	d9 1c 91	 fstp	 DWORD PTR [ecx+edx*4]
  000e0	eb c7		 jmp	 SHORT $L1499
$L1500:

; 260  : 
; 261  :    return 0;

  000e2	66 33 c0	 xor	 ax, ax
$L1486:

; 262  : }

  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 04 00	 ret	 4
_VoxInitLPCSyn@4 ENDP
_TEXT	ENDS
PUBLIC	_VoxFreeLPCSyn@4
EXTRN	_free:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxFreeLPCSyn@4
_TEXT	SEGMENT
_Synthesis_mblk$ = -4
_hSynthesis_mblk$ = 8
_VoxFreeLPCSyn@4 PROC NEAR				; COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 289  :    Synthesis *Synthesis_mblk=(Synthesis *)*hSynthesis_mblk;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hSynthesis_mblk$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _Synthesis_mblk$[ebp], ecx

; 290  : 
; 291  :    if(*hSynthesis_mblk) {

  0000c	8b 55 08	 mov	 edx, DWORD PTR _hSynthesis_mblk$[ebp]
  0000f	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00012	74 60		 je	 SHORT $L1507

; 292  :       VOX_MEM_FREE(Synthesis_mblk->prevLSP);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _Synthesis_mblk$[ebp]
  00017	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001a	74 17		 je	 SHORT $L1508
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _Synthesis_mblk$[ebp]
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 _free
  00027	83 c4 04	 add	 esp, 4
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _Synthesis_mblk$[ebp]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L1508:

; 293  :       VOX_MEM_FREE(Synthesis_mblk->lpcMEM);

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _Synthesis_mblk$[ebp]
  00036	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0003a	74 19		 je	 SHORT $L1510
  0003c	8b 55 fc	 mov	 edx, DWORD PTR _Synthesis_mblk$[ebp]
  0003f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _free
  00048	83 c4 04	 add	 esp, 4
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _Synthesis_mblk$[ebp]
  0004e	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$L1510:

; 294  : 
; 295  :       VOX_MEM_FREE(*hSynthesis_mblk);

  00055	8b 55 08	 mov	 edx, DWORD PTR _hSynthesis_mblk$[ebp]
  00058	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0005b	74 17		 je	 SHORT $L1507
  0005d	8b 45 08	 mov	 eax, DWORD PTR _hSynthesis_mblk$[ebp]
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _free
  00068	83 c4 04	 add	 esp, 4
  0006b	8b 55 08	 mov	 edx, DWORD PTR _hSynthesis_mblk$[ebp]
  0006e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L1507:

; 296  :    }
; 297  : 
; 298  :    return 0;

  00074	66 33 c0	 xor	 ax, ax

; 299  : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_VoxFreeLPCSyn@4 ENDP
_TEXT	ENDS
END
