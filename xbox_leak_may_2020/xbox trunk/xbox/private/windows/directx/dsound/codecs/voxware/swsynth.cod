; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\swsynth.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EA@PEGBMLPF@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@HHPMGJAK@hHFRegenMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfSynSpe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@BPBHEHMC@pfVEVphase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfWaveform@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@EKFLHMOO@pfEnv?5?$CB?$DN?5NULL?5?$CG?$CG?5pfEnv_1?5?$CB?$DN?5NULL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KNGKCLEO@pfPhase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfPhase_1?5?$CB?$DN?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@LNMKAOD@plUVPhaseRandSeed?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxSWSynth@56
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_VoxSWSynth@56
PUBLIC	??_C@_0EA@PEGBMLPF@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CM@HHPMGJAK@hHFRegenMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfSynSpe@ ; `string'
PUBLIC	??_C@_0CL@BPBHEHMC@pfVEVphase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfWaveform@ ; `string'
PUBLIC	??_C@_0CB@EKFLHMOO@pfEnv?5?$CB?$DN?5NULL?5?$CG?$CG?5pfEnv_1?5?$CB?$DN?5NULL@ ; `string'
PUBLIC	??_C@_0CF@KNGKCLEO@pfPhase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfPhase_1?5?$CB?$DN?5@ ; `string'
PUBLIC	??_C@_0BK@LNMKAOD@plUVPhaseRandSeed?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	__real@44000000
PUBLIC	__real@3f000000
PUBLIC	__real@43800000
PUBLIC	__real@3b000000
EXTRN	_VoxHFRegeneration@44:NEAR
EXTRN	_ExcitationPhase@24:NEAR
EXTRN	_PhaseJitter@16:NEAR
EXTRN	_UnvoicedPhase@16:NEAR
EXTRN	_FHTOverlapAdd@28:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	__assert:NEAR
EXTRN	_fInvLog2@4:NEAR
EXTRN	_fSetKLFactor@8:NEAR
EXTRN	_SetAmpAndPhase@44:NEAR
EXTRN	_AddSubHarmonics@24:NEAR
;	COMDAT ??_C@_0EA@PEGBMLPF@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\swsynth.c
CONST	SEGMENT
??_C@_0EA@PEGBMLPF@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\swsynth.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HHPMGJAK@hHFRegenMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfSynSpe@
CONST	SEGMENT
??_C@_0CM@HHPMGJAK@hHFRegenMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfSynSpe@ DB 'h'
	DB	'HFRegenMblk != NULL && pfSynSpeech != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BPBHEHMC@pfVEVphase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfWaveform@
CONST	SEGMENT
??_C@_0CL@BPBHEHMC@pfVEVphase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfWaveform@ DB 'p'
	DB	'fVEVphase != NULL && pfWaveform_1 != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EKFLHMOO@pfEnv?5?$CB?$DN?5NULL?5?$CG?$CG?5pfEnv_1?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0CB@EKFLHMOO@pfEnv?5?$CB?$DN?5NULL?5?$CG?$CG?5pfEnv_1?5?$CB?$DN?5NULL@ DB 'p'
	DB	'fEnv != NULL && pfEnv_1 != NULL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KNGKCLEO@pfPhase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfPhase_1?5?$CB?$DN?5@
CONST	SEGMENT
??_C@_0CF@KNGKCLEO@pfPhase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfPhase_1?5?$CB?$DN?5@ DB 'p'
	DB	'fPhase != NULL && pfPhase_1 != NULL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LNMKAOD@plUVPhaseRandSeed?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BK@LNMKAOD@plUVPhaseRandSeed?5?$CB?$DN?5NULL?$AA@ DB 'plUVPhaseRan'
	DB	'dSeed != NULL', 00H				; `string'
CONST	ENDS
;	COMDAT __real@44000000
CONST	SEGMENT
__real@44000000 DD 044000000r			; 512
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@3b000000
CONST	SEGMENT
__real@3b000000 DD 03b000000r			; 0.00195313
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxSWSynth@56
_TEXT	SEGMENT
tv147 = -884
tv144 = -880
tv138 = -876
tv134 = -872
_iHarmonics$ = -868
_fVoicingCutoff$ = -864
_fBasebandCutoff$ = -860
_fNoiseScale$ = -856
_fDFT_F0$ = -852
_iIndex$ = -848
_iRatio$ = -844
_fOnsetPhase$ = -840
_iVoicHarm$ = -836
_iVoicSubHarm$ = -832
_fBeta$ = -828
_pfMinPhase$ = -824
_pfAmp$ = -424
_fFHT_F0$ = -24
_i$ = -20
_fFinalCutoff$ = -16
_iSubHarmonics$ = -12
_iBasePeaks$ = -8
_fTemp$ = -4
_hHFRegenMblk$ = 8
_iSCRateSyn$ = 12
_pfSynSpeech$ = 16
_pfVEVphase$ = 20
_pfWaveform_1$ = 24
_fSynPitch$ = 28
_fPv$ = 32
_pfEnv$ = 36
_pfEnv_1$ = 40
_pfPhase$ = 44
_pfPhase_1$ = 48
_fInterpFactor$ = 52
_iUpdatePhaseOffsetFlag$ = 56
_plUVPhaseRandSeed$ = 60
_VoxSWSynth@56 PROC NEAR				; COMDAT

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 74 03 00
	00		 sub	 esp, 884		; 00000374H

; 99   :    int i;
; 100  :    int iIndex;
; 101  :    int iHarmonics;     /* number of sine waves                                */
; 102  :    int iSubHarmonics;  /* number of sine waves including sub-harmonics        */
; 103  :    int iRatio;         /* ratio of iSubHarmonics to iHarmonics                */
; 104  :    int iBasePeaks;     /* number of peaks with measured phases                */
; 105  :    int iVoicHarm;      /* number of voiced sine waves                         */
; 106  :    int iVoicSubHarm;   /* number of voiced sine waves including sub-harmonics */
; 107  : 
; 108  :    float fFHT_F0;       /* F0 to use in FHT synthesis                    */
; 109  :    float fVoicingCutoff;  /* the frequency cutoff for voicing                 */
; 110  :    float fBasebandCutoff; /* the frequency cutoff for measured phases         */
; 111  :    float fFinalCutoff;    /* the frequency cutoff for randomizing phases      */
; 112  :    float fNoiseScale;     /* scale factor for unvoiced harmonics              */
; 113  :    float fOnsetPhase;     /* the onset phase                                  */
; 114  :    float fBeta;           /* the beta factor                                  */
; 115  :    float fTemp;
; 116  :    float fDFT_F0;
; 117  : 
; 118  : STACK_INIT
; 119  :    float pfMinPhase[MAXHARM];
; 120  :    float pfAmp[MAXHARM];
; 121  : STACK_INIT_END
; 122  : 
; 123  :    STACK_ATTACH(float *, pfMinPhase)
; 124  :    STACK_ATTACH(float *, pfAmp)
; 125  :   
; 126  :    STACK_START
; 127  : 
; 128  :    assert(hHFRegenMblk != NULL && pfSynSpeech != NULL);

  00009	83 7d 08 00	 cmp	 DWORD PTR _hHFRegenMblk$[ebp], 0
  0000d	74 06		 je	 SHORT $L1226
  0000f	83 7d 10 00	 cmp	 DWORD PTR _pfSynSpeech$[ebp], 0
  00013	75 17		 jne	 SHORT $L1227
$L1226:
  00015	68 80 00 00 00	 push	 128			; 00000080H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@PEGBMLPF@c?3?2xbox?2private?2windows?2directx?2@
  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@HHPMGJAK@hHFRegenMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfSynSpe@
  00024	e8 00 00 00 00	 call	 __assert
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1227:

; 129  :    assert(pfVEVphase != NULL && pfWaveform_1 != NULL);

  0002c	83 7d 14 00	 cmp	 DWORD PTR _pfVEVphase$[ebp], 0
  00030	74 06		 je	 SHORT $L1228
  00032	83 7d 18 00	 cmp	 DWORD PTR _pfWaveform_1$[ebp], 0
  00036	75 17		 jne	 SHORT $L1229
$L1228:
  00038	68 81 00 00 00	 push	 129			; 00000081H
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@PEGBMLPF@c?3?2xbox?2private?2windows?2directx?2@
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CL@BPBHEHMC@pfVEVphase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfWaveform@
  00047	e8 00 00 00 00	 call	 __assert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1229:

; 130  :    assert(pfEnv != NULL && pfEnv_1 != NULL);

  0004f	83 7d 24 00	 cmp	 DWORD PTR _pfEnv$[ebp], 0
  00053	74 06		 je	 SHORT $L1230
  00055	83 7d 28 00	 cmp	 DWORD PTR _pfEnv_1$[ebp], 0
  00059	75 17		 jne	 SHORT $L1231
$L1230:
  0005b	68 82 00 00 00	 push	 130			; 00000082H
  00060	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@PEGBMLPF@c?3?2xbox?2private?2windows?2directx?2@
  00065	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@EKFLHMOO@pfEnv?5?$CB?$DN?5NULL?5?$CG?$CG?5pfEnv_1?5?$CB?$DN?5NULL@
  0006a	e8 00 00 00 00	 call	 __assert
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1231:

; 131  :    assert(pfPhase != NULL && pfPhase_1 != NULL);

  00072	83 7d 2c 00	 cmp	 DWORD PTR _pfPhase$[ebp], 0
  00076	74 06		 je	 SHORT $L1232
  00078	83 7d 30 00	 cmp	 DWORD PTR _pfPhase_1$[ebp], 0
  0007c	75 17		 jne	 SHORT $L1233
$L1232:
  0007e	68 83 00 00 00	 push	 131			; 00000083H
  00083	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@PEGBMLPF@c?3?2xbox?2private?2windows?2directx?2@
  00088	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@KNGKCLEO@pfPhase?5?$CB?$DN?5NULL?5?$CG?$CG?5pfPhase_1?5?$CB?$DN?5@
  0008d	e8 00 00 00 00	 call	 __assert
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1233:

; 132  :    assert(plUVPhaseRandSeed != NULL);

  00095	83 7d 3c 00	 cmp	 DWORD PTR _plUVPhaseRandSeed$[ebp], 0
  00099	75 17		 jne	 SHORT $L1234
  0009b	68 84 00 00 00	 push	 132			; 00000084H
  000a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@PEGBMLPF@c?3?2xbox?2private?2windows?2directx?2@
  000a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@LNMKAOD@plUVPhaseRandSeed?5?$CB?$DN?5NULL?$AA@
  000aa	e8 00 00 00 00	 call	 __assert
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1234:

; 133  : 
; 134  :    fDFT_F0 = (float)NFFT/fSynPitch;

  000b2	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@44000000
  000b8	d8 75 1c	 fdiv	 DWORD PTR _fSynPitch$[ebp]
  000bb	d9 9d ac fc ff
	ff		 fstp	 DWORD PTR _fDFT_F0$[ebp]

; 135  :  
; 136  :    /*--------------------------------------------------------------------
; 137  :      Determine the number of harmonics
; 138  :    --------------------------------------------------------------------*/
; 139  :    iHarmonics = VoxFLOORpos(0.5F*fSynPitch);

  000c1	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000
  000c7	d8 4d 1c	 fmul	 DWORD PTR _fSynPitch$[ebp]
  000ca	e8 00 00 00 00	 call	 __ftol2
  000cf	89 85 9c fc ff
	ff		 mov	 DWORD PTR _iHarmonics$[ebp], eax

; 140  : 
; 141  :    fTemp = fDFT_F0*(float)iHarmonics;

  000d5	db 85 9c fc ff
	ff		 fild	 DWORD PTR _iHarmonics$[ebp]
  000db	d8 8d ac fc ff
	ff		 fmul	 DWORD PTR _fDFT_F0$[ebp]
  000e1	d9 5d fc	 fstp	 DWORD PTR _fTemp$[ebp]

; 142  :    VoxROUND2pos( fTemp, iIndex );

  000e4	d9 45 fc	 fld	 DWORD PTR _fTemp$[ebp]
  000e7	db 9d b0 fc ff
	ff		 fistp	 DWORD PTR _iIndex$[ebp]

; 143  :  
; 144  :    if (iIndex >= NFFT_2)

  000ed	81 bd b0 fc ff
	ff 00 01 00 00	 cmp	 DWORD PTR _iIndex$[ebp], 256 ; 00000100H
  000f7	7c 0f		 jl	 SHORT $L1202

; 145  :          iHarmonics --;

  000f9	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _iHarmonics$[ebp]
  000ff	83 ea 01	 sub	 edx, 1
  00102	89 95 9c fc ff
	ff		 mov	 DWORD PTR _iHarmonics$[ebp], edx
$L1202:

; 146  :  
; 147  :    iHarmonics = VoxMIN( iHarmonics, MAXHARM );

  00108	83 bd 9c fc ff
	ff 64		 cmp	 DWORD PTR _iHarmonics$[ebp], 100 ; 00000064H
  0010f	7e 0c		 jle	 SHORT $L1235
  00111	c7 85 98 fc ff
	ff 64 00 00 00	 mov	 DWORD PTR tv134[ebp], 100 ; 00000064H
  0011b	eb 0c		 jmp	 SHORT $L1236
$L1235:
  0011d	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _iHarmonics$[ebp]
  00123	89 85 98 fc ff
	ff		 mov	 DWORD PTR tv134[ebp], eax
$L1236:
  00129	8b 8d 98 fc ff
	ff		 mov	 ecx, DWORD PTR tv134[ebp]
  0012f	89 8d 9c fc ff
	ff		 mov	 DWORD PTR _iHarmonics$[ebp], ecx

; 148  : 
; 149  :    /*--------------------------------------------------------------------
; 150  :      Determine the voicing cutoff and the number of baseband peaks
; 151  :    --------------------------------------------------------------------*/
; 152  :    fVoicingCutoff=fPv*(float)NFFT_2;

  00135	d9 45 20	 fld	 DWORD PTR _fPv$[ebp]
  00138	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@43800000
  0013e	d9 9d a0 fc ff
	ff		 fstp	 DWORD PTR _fVoicingCutoff$[ebp]

; 153  :    if (iSCRateSyn==SC_RATE_3K)

  00144	83 7d 0c 01	 cmp	 DWORD PTR _iSCRateSyn$[ebp], 1
  00148	75 12		 jne	 SHORT $L1204

; 154  :    {
; 155  :       iBasePeaks = 0;

  0014a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iBasePeaks$[ebp], 0

; 156  :       fFinalCutoff = fVoicingCutoff;

  00151	8b 95 a0 fc ff
	ff		 mov	 edx, DWORD PTR _fVoicingCutoff$[ebp]
  00157	89 55 f0	 mov	 DWORD PTR _fFinalCutoff$[ebp], edx

; 157  :    } else {

  0015a	eb 6f		 jmp	 SHORT $L1205
$L1204:

; 158  :       iBasePeaks = VoxMIN( SC6_PHASES, iHarmonics );

  0015c	83 bd 9c fc ff
	ff 08		 cmp	 DWORD PTR _iHarmonics$[ebp], 8
  00163	7d 0e		 jge	 SHORT $L1237
  00165	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _iHarmonics$[ebp]
  0016b	89 85 94 fc ff
	ff		 mov	 DWORD PTR tv138[ebp], eax
  00171	eb 0a		 jmp	 SHORT $L1238
$L1237:
  00173	c7 85 94 fc ff
	ff 08 00 00 00	 mov	 DWORD PTR tv138[ebp], 8
$L1238:
  0017d	8b 8d 94 fc ff
	ff		 mov	 ecx, DWORD PTR tv138[ebp]
  00183	89 4d f8	 mov	 DWORD PTR _iBasePeaks$[ebp], ecx

; 159  :       fBasebandCutoff = ((float)iBasePeaks+0.5F)*fDFT_F0;

  00186	db 45 f8	 fild	 DWORD PTR _iBasePeaks$[ebp]
  00189	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f000000
  0018f	d8 8d ac fc ff
	ff		 fmul	 DWORD PTR _fDFT_F0$[ebp]
  00195	d9 95 a4 fc ff
	ff		 fst	 DWORD PTR _fBasebandCutoff$[ebp]

; 160  :       fFinalCutoff = VoxMAX( fBasebandCutoff, fVoicingCutoff );

  0019b	d8 9d a0 fc ff
	ff		 fcomp	 DWORD PTR _fVoicingCutoff$[ebp]
  001a1	df e0		 fnstsw	 ax
  001a3	f6 c4 41	 test	 ah, 65			; 00000041H
  001a6	75 0e		 jne	 SHORT $L1239
  001a8	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _fBasebandCutoff$[ebp]
  001ae	89 95 90 fc ff
	ff		 mov	 DWORD PTR tv144[ebp], edx
  001b4	eb 0c		 jmp	 SHORT $L1240
$L1239:
  001b6	8b 85 a0 fc ff
	ff		 mov	 eax, DWORD PTR _fVoicingCutoff$[ebp]
  001bc	89 85 90 fc ff
	ff		 mov	 DWORD PTR tv144[ebp], eax
$L1240:
  001c2	8b 8d 90 fc ff
	ff		 mov	 ecx, DWORD PTR tv144[ebp]
  001c8	89 4d f0	 mov	 DWORD PTR _fFinalCutoff$[ebp], ecx
$L1205:

; 161  :    }
; 162  :  
; 163  :    /*--------------------------------------------------------------------
; 164  :      Determin iRatio and number of harmonics
; 165  :    --------------------------------------------------------------------*/
; 166  :    iRatio = (fVoicingCutoff<NFFT_2) ? (MAXHARM/iHarmonics) : 1;

  001cb	d9 85 a0 fc ff
	ff		 fld	 DWORD PTR _fVoicingCutoff$[ebp]
  001d1	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@43800000
  001d7	df e0		 fnstsw	 ax
  001d9	f6 c4 05	 test	 ah, 5
  001dc	7a 14		 jp	 SHORT $L1241
  001de	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  001e3	99		 cdq
  001e4	f7 bd 9c fc ff
	ff		 idiv	 DWORD PTR _iHarmonics$[ebp]
  001ea	89 85 8c fc ff
	ff		 mov	 DWORD PTR tv147[ebp], eax
  001f0	eb 0a		 jmp	 SHORT $L1242
$L1241:
  001f2	c7 85 8c fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv147[ebp], 1
$L1242:
  001fc	8b 95 8c fc ff
	ff		 mov	 edx, DWORD PTR tv147[ebp]
  00202	89 95 b4 fc ff
	ff		 mov	 DWORD PTR _iRatio$[ebp], edx

; 167  : 
; 168  :    iSubHarmonics = iHarmonics*iRatio;

  00208	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _iHarmonics$[ebp]
  0020e	0f af 85 b4 fc
	ff ff		 imul	 eax, DWORD PTR _iRatio$[ebp]
  00215	89 45 f4	 mov	 DWORD PTR _iSubHarmonics$[ebp], eax

; 169  : 
; 170  :    fFHT_F0 = fDFT_F0/(float)iRatio;

  00218	db 85 b4 fc ff
	ff		 fild	 DWORD PTR _iRatio$[ebp]
  0021e	d8 bd ac fc ff
	ff		 fdivr	 DWORD PTR _fDFT_F0$[ebp]
  00224	d9 5d e8	 fstp	 DWORD PTR _fFHT_F0$[ebp]

; 171  :  
; 172  :    iVoicHarm = VoxFLOORpos( fFinalCutoff*INV_NFFT*fSynPitch);

  00227	d9 45 f0	 fld	 DWORD PTR _fFinalCutoff$[ebp]
  0022a	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3b000000
  00230	d8 4d 1c	 fmul	 DWORD PTR _fSynPitch$[ebp]
  00233	e8 00 00 00 00	 call	 __ftol2
  00238	89 85 bc fc ff
	ff		 mov	 DWORD PTR _iVoicHarm$[ebp], eax

; 173  : 
; 174  :    iVoicSubHarm = iVoicHarm*iRatio;

  0023e	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _iVoicHarm$[ebp]
  00244	0f af 8d b4 fc
	ff ff		 imul	 ecx, DWORD PTR _iRatio$[ebp]
  0024b	89 8d c0 fc ff
	ff		 mov	 DWORD PTR _iVoicSubHarm$[ebp], ecx

; 175  : 
; 176  : 
; 177  :    /*--------------------------------------------------------------------
; 178  :      Compute the Karhunen-Loeve scale factor to account for the analysis 
; 179  :        window energy and the synthesis pitch for unvoiced harmonics
; 180  :    --------------------------------------------------------------------*/
; 181  :    fNoiseScale = fSetKLFactor( fSynPitch, fFHT_F0);

  00251	8b 55 e8	 mov	 edx, DWORD PTR _fFHT_F0$[ebp]
  00254	52		 push	 edx
  00255	8b 45 1c	 mov	 eax, DWORD PTR _fSynPitch$[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 _fSetKLFactor@8
  0025e	d9 9d a8 fc ff
	ff		 fstp	 DWORD PTR _fNoiseScale$[ebp]

; 182  : 
; 183  :    /*--------------------------------------------------------------------
; 184  :      Generate samples of the amplitude and phase envelopes at the
; 185  :        pitch harmonics by interpolating in both time and frequency.
; 186  :    --------------------------------------------------------------------*/
; 187  :    SetAmpAndPhase ( fNoiseScale, fDFT_F0, pfAmp, pfMinPhase, 
; 188  :                     iHarmonics, iVoicHarm, pfEnv, pfEnv_1, pfPhase, 
; 189  :                     pfPhase_1, fInterpFactor);

  00264	8b 4d 34	 mov	 ecx, DWORD PTR _fInterpFactor$[ebp]
  00267	51		 push	 ecx
  00268	8b 55 30	 mov	 edx, DWORD PTR _pfPhase_1$[ebp]
  0026b	52		 push	 edx
  0026c	8b 45 2c	 mov	 eax, DWORD PTR _pfPhase$[ebp]
  0026f	50		 push	 eax
  00270	8b 4d 28	 mov	 ecx, DWORD PTR _pfEnv_1$[ebp]
  00273	51		 push	 ecx
  00274	8b 55 24	 mov	 edx, DWORD PTR _pfEnv$[ebp]
  00277	52		 push	 edx
  00278	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _iVoicHarm$[ebp]
  0027e	50		 push	 eax
  0027f	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _iHarmonics$[ebp]
  00285	51		 push	 ecx
  00286	8d 95 c8 fc ff
	ff		 lea	 edx, DWORD PTR _pfMinPhase$[ebp]
  0028c	52		 push	 edx
  0028d	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _pfAmp$[ebp]
  00293	50		 push	 eax
  00294	8b 8d ac fc ff
	ff		 mov	 ecx, DWORD PTR _fDFT_F0$[ebp]
  0029a	51		 push	 ecx
  0029b	8b 95 a8 fc ff
	ff		 mov	 edx, DWORD PTR _fNoiseScale$[ebp]
  002a1	52		 push	 edx
  002a2	e8 00 00 00 00	 call	 _SetAmpAndPhase@44

; 190  : 
; 191  :    /*--------------------------------------------------------------------
; 192  :      Estimate the rate-dependent excitation phase parameters
; 193  :    --------------------------------------------------------------------*/
; 194  :    VoxHFRegeneration(STACK_S hHFRegenMblk, pfVEVphase, 
; 195  :                      fDFT_F0, pfAmp, pfMinPhase, iHarmonics,
; 196  :                      &fOnsetPhase, &fBeta, iSCRateSyn, 
; 197  :                      HALF_FRAME_LENGTH_SC, iUpdatePhaseOffsetFlag);

  002a7	8b 45 38	 mov	 eax, DWORD PTR _iUpdatePhaseOffsetFlag$[ebp]
  002aa	50		 push	 eax
  002ab	6a 50		 push	 80			; 00000050H
  002ad	8b 4d 0c	 mov	 ecx, DWORD PTR _iSCRateSyn$[ebp]
  002b0	51		 push	 ecx
  002b1	8d 95 c4 fc ff
	ff		 lea	 edx, DWORD PTR _fBeta$[ebp]
  002b7	52		 push	 edx
  002b8	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _fOnsetPhase$[ebp]
  002be	50		 push	 eax
  002bf	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _iHarmonics$[ebp]
  002c5	51		 push	 ecx
  002c6	8d 95 c8 fc ff
	ff		 lea	 edx, DWORD PTR _pfMinPhase$[ebp]
  002cc	52		 push	 edx
  002cd	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _pfAmp$[ebp]
  002d3	50		 push	 eax
  002d4	8b 8d ac fc ff
	ff		 mov	 ecx, DWORD PTR _fDFT_F0$[ebp]
  002da	51		 push	 ecx
  002db	8b 55 14	 mov	 edx, DWORD PTR _pfVEVphase$[ebp]
  002de	52		 push	 edx
  002df	8b 45 08	 mov	 eax, DWORD PTR _hHFRegenMblk$[ebp]
  002e2	50		 push	 eax
  002e3	e8 00 00 00 00	 call	 _VoxHFRegeneration@44

; 198  : 
; 199  :    /*--------------------------------------------------------------------
; 200  :      Add the linear phase to the minimum phase and the residual phase
; 201  :    --------------------------------------------------------------------*/
; 202  :    ExcitationPhase(fOnsetPhase, fBeta, pfVEVphase,
; 203  :                    pfMinPhase, iHarmonics, iBasePeaks );

  002e8	8b 4d f8	 mov	 ecx, DWORD PTR _iBasePeaks$[ebp]
  002eb	51		 push	 ecx
  002ec	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _iHarmonics$[ebp]
  002f2	52		 push	 edx
  002f3	8d 85 c8 fc ff
	ff		 lea	 eax, DWORD PTR _pfMinPhase$[ebp]
  002f9	50		 push	 eax
  002fa	8b 4d 14	 mov	 ecx, DWORD PTR _pfVEVphase$[ebp]
  002fd	51		 push	 ecx
  002fe	8b 95 c4 fc ff
	ff		 mov	 edx, DWORD PTR _fBeta$[ebp]
  00304	52		 push	 edx
  00305	8b 85 b8 fc ff
	ff		 mov	 eax, DWORD PTR _fOnsetPhase$[ebp]
  0030b	50		 push	 eax
  0030c	e8 00 00 00 00	 call	 _ExcitationPhase@24

; 204  : 
; 205  :    /*--------------------------------------------------------------------
; 206  :      Add glottal pulse jitter to the uncoded odd harmonics 
; 207  :    --------------------------------------------------------------------*/
; 208  :    PhaseJitter( fSynPitch, pfMinPhase, iBasePeaks, iHarmonics );

  00311	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _iHarmonics$[ebp]
  00317	51		 push	 ecx
  00318	8b 55 f8	 mov	 edx, DWORD PTR _iBasePeaks$[ebp]
  0031b	52		 push	 edx
  0031c	8d 85 c8 fc ff
	ff		 lea	 eax, DWORD PTR _pfMinPhase$[ebp]
  00322	50		 push	 eax
  00323	8b 4d 1c	 mov	 ecx, DWORD PTR _fSynPitch$[ebp]
  00326	51		 push	 ecx
  00327	e8 00 00 00 00	 call	 _PhaseJitter@16

; 209  : 
; 210  : 
; 211  :    /*--------------------------------------------------------------------
; 212  :      Convert log_base_2 amplitudes to linear
; 213  :    --------------------------------------------------------------------*/
; 214  :    for(i = 0; i < iHarmonics; i++)

  0032c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00333	eb 09		 jmp	 SHORT $L1210
$L1211:
  00335	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  00338	83 c2 01	 add	 edx, 1
  0033b	89 55 ec	 mov	 DWORD PTR _i$[ebp], edx
$L1210:
  0033e	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00341	3b 85 9c fc ff
	ff		 cmp	 eax, DWORD PTR _iHarmonics$[ebp]
  00347	7d 1c		 jge	 SHORT $L1212

; 215  :       pfAmp[i] = fInvLog2(pfAmp[i]);

  00349	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  0034c	8b 94 8d 58 fe
	ff ff		 mov	 edx, DWORD PTR _pfAmp$[ebp+ecx*4]
  00353	52		 push	 edx
  00354	e8 00 00 00 00	 call	 _fInvLog2@4
  00359	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0035c	d9 9c 85 58 fe
	ff ff		 fstp	 DWORD PTR _pfAmp$[ebp+eax*4]
  00363	eb d0		 jmp	 SHORT $L1211
$L1212:

; 216  : 
; 217  :    /*--------------------------------------------------------------------
; 218  :      Increase the number of unvoiced harmonics by adding sub-harmonics.
; 219  :        This is done now rather the previously in SetAmps() to save on the
; 220  :        maximum number of fInvLog2()'s required.  The maximum number of
; 221  :        pitch harmonics is 80 because the minimum pitch is 50 Hz.  The
; 222  :        maximum number of synthesis harmonics is 100, so we can save
; 223  :        20 fInvLog2()'s from the peak complexity by increasing the
; 224  :        number of harmonics after taking fInvLog2().
; 225  :    --------------------------------------------------------------------*/
; 226  :    AddSubHarmonics ( pfAmp, pfMinPhase, iHarmonics, iSubHarmonics, 
; 227  :                      iRatio, iVoicHarm);

  00365	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _iVoicHarm$[ebp]
  0036b	51		 push	 ecx
  0036c	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _iRatio$[ebp]
  00372	52		 push	 edx
  00373	8b 45 f4	 mov	 eax, DWORD PTR _iSubHarmonics$[ebp]
  00376	50		 push	 eax
  00377	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _iHarmonics$[ebp]
  0037d	51		 push	 ecx
  0037e	8d 95 c8 fc ff
	ff		 lea	 edx, DWORD PTR _pfMinPhase$[ebp]
  00384	52		 push	 edx
  00385	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _pfAmp$[ebp]
  0038b	50		 push	 eax
  0038c	e8 00 00 00 00	 call	 _AddSubHarmonics@24

; 228  :  
; 229  :    /*--------------------------------------------------------------------
; 230  :      For uncoded phases add on the random phase above cutoff
; 231  :    --------------------------------------------------------------------*/
; 232  :    UnvoicedPhase( pfMinPhase, iSubHarmonics, iVoicSubHarm, plUVPhaseRandSeed);

  00391	8b 4d 3c	 mov	 ecx, DWORD PTR _plUVPhaseRandSeed$[ebp]
  00394	51		 push	 ecx
  00395	8b 95 c0 fc ff
	ff		 mov	 edx, DWORD PTR _iVoicSubHarm$[ebp]
  0039b	52		 push	 edx
  0039c	8b 45 f4	 mov	 eax, DWORD PTR _iSubHarmonics$[ebp]
  0039f	50		 push	 eax
  003a0	8d 8d c8 fc ff
	ff		 lea	 ecx, DWORD PTR _pfMinPhase$[ebp]
  003a6	51		 push	 ecx
  003a7	e8 00 00 00 00	 call	 _UnvoicedPhase@16

; 233  : 
; 234  :    /*--------------------------------------------------------------------
; 235  :      Compute the sine-wave parameters and perform sine-wave
; 236  :      synthesis using FHT and overlap-add
; 237  :    --------------------------------------------------------------------*/
; 238  :    FHTOverlapAdd (STACK_S pfAmp, fFHT_F0, pfMinPhase, iSubHarmonics, 
; 239  :                   HALF_FRAME_LENGTH_SC, pfSynSpeech, pfWaveform_1);

  003ac	8b 55 18	 mov	 edx, DWORD PTR _pfWaveform_1$[ebp]
  003af	52		 push	 edx
  003b0	8b 45 10	 mov	 eax, DWORD PTR _pfSynSpeech$[ebp]
  003b3	50		 push	 eax
  003b4	6a 50		 push	 80			; 00000050H
  003b6	8b 4d f4	 mov	 ecx, DWORD PTR _iSubHarmonics$[ebp]
  003b9	51		 push	 ecx
  003ba	8d 95 c8 fc ff
	ff		 lea	 edx, DWORD PTR _pfMinPhase$[ebp]
  003c0	52		 push	 edx
  003c1	8b 45 e8	 mov	 eax, DWORD PTR _fFHT_F0$[ebp]
  003c4	50		 push	 eax
  003c5	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _pfAmp$[ebp]
  003cb	51		 push	 ecx
  003cc	e8 00 00 00 00	 call	 _FHTOverlapAdd@28

; 240  : 
; 241  :    STACK_END
; 242  : }

  003d1	8b e5		 mov	 esp, ebp
  003d3	5d		 pop	 ebp
  003d4	c2 38 00	 ret	 56			; 00000038H
_VoxSWSynth@56 ENDP
_TEXT	ENDS
END
