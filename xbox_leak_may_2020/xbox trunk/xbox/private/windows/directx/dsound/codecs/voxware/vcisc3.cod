; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\vcisc3.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0M@HMONDJF@SC?401?408?400?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@KGCNFMNN@frame?5length?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HCCHHEEF@rate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _vciGetInfoSC3@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciEncodeSC3@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciDecodeSC3@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciInitEncodeSC3@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciInitDecodeSC3@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciFreeEncodeSC3@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciFreeDecodeSC3@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciGetExtCompatibilitySC3@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SC3CompatibilityFunc@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _initMethodStruct@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _freeMethodStruct@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_vciGetInfoSC3@4
PUBLIC	??_C@_0M@HMONDJF@SC?401?408?400?$AA@		; `string'
EXTRN	_ceil:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	_strcpy:NEAR
;	COMDAT ??_C@_0M@HMONDJF@SC?401?408?400?$AA@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\vcisc3.c
CONST	SEGMENT
??_C@_0M@HMONDJF@SC?401?408?400?$AA@ DB 'SC.01.08.00', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciGetInfoSC3@4
_TEXT	SEGMENT
_pvciCodecInfoBlk$ = 8
_vciGetInfoSC3@4 PROC NEAR				; COMDAT

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 131  : 
; 132  :    pvciCodecInfoBlk->wVCIVersion               = (unsigned short) VCI_VERSION;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00006	66 c7 00 04 00	 mov	 WORD PTR [eax], 4

; 133  :    
; 134  :    /* Variables for codec identification.     */
; 135  :    strcpy(pvciCodecInfoBlk->sCodecVersion,       SC_CODEC_VERSION);

  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@HMONDJF@SC?401?408?400?$AA@
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00013	83 c1 02	 add	 ecx, 2
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 _strcpy
  0001c	83 c4 08	 add	 esp, 8

; 136  :    pvciCodecInfoBlk->dwCodecClassID            = (unsigned long)VOXWARE_CODEC_SC_8K_3;      

  0001f	8b 55 08	 mov	 edx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00022	c7 42 24 03 00
	00 03		 mov	 DWORD PTR [edx+36], 50331651 ; 03000003H

; 137  :    pvciCodecInfoBlk->dwCodecID                 = (unsigned long)VOXWARE_CODEC_ID_SC_8K_3_GENERIC;

  00029	8b 45 08	 mov	 eax, DWORD PTR _pvciCodecInfoBlk$[ebp]
  0002c	c7 40 28 03 00
	01 03		 mov	 DWORD PTR [eax+40], 50397187 ; 03010003H

; 138  :    
; 139  :    /* PCM Data formats.                       */
; 140  :    pvciCodecInfoBlk->wSamplingRate             = (unsigned short)RATE8K;   

  00033	8b 4d 08	 mov	 ecx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00036	66 c7 41 2c 40
	1f		 mov	 WORD PTR [ecx+44], 8000	; 00001f40H

; 141  :    pvciCodecInfoBlk->wNumBitsPerSample         = 16; 

  0003c	8b 55 08	 mov	 edx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  0003f	66 c7 42 2e 10
	00		 mov	 WORD PTR [edx+46], 16	; 00000010H

; 142  :    pvciCodecInfoBlk->wNumSamplesPerFrame       = (unsigned short)FRAME_LENGTH_SC;

  00045	8b 45 08	 mov	 eax, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00048	66 c7 40 30 a0
	00		 mov	 WORD PTR [eax+48], 160	; 000000a0H

; 143  : 
; 144  :    /* Bitstream information.                  */
; 145  :    pvciCodecInfoBlk->dwBitRate                 = (unsigned long)(TOTAL_BITS_SC3*
; 146  :                                                     (float)RATE8K/(float)FRAME_LENGTH_SC);

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00051	c7 41 38 80 0c
	00 00		 mov	 DWORD PTR [ecx+56], 3200 ; 00000c80H

; 147  :    pvciCodecInfoBlk->dwMinPacketBits           = (unsigned short) TOTAL_BITS_SC3;

  00058	8b 55 08	 mov	 edx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  0005b	c7 42 3c 40 00
	00 00		 mov	 DWORD PTR [edx+60], 64	; 00000040H

; 148  :    pvciCodecInfoBlk->dwAvgPacketBits           = (unsigned short) TOTAL_BITS_SC3;

  00062	8b 45 08	 mov	 eax, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00065	c7 40 40 40 00
	00 00		 mov	 DWORD PTR [eax+64], 64	; 00000040H

; 149  :    pvciCodecInfoBlk->dwMaxPacketBits           = (unsigned short) TOTAL_BITS_SC3;

  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  0006f	c7 41 44 40 00
	00 00		 mov	 DWORD PTR [ecx+68], 64	; 00000040H

; 150  : 
; 151  :    /* Prime Flush Information */
; 152  :    /* encoder delay + decoder delay == ENC_DELAY_SIZE (145 == 80 + 65) */
; 153  :    pvciCodecInfoBlk->wNumPrimeFlushFrames      = (unsigned short)ceil((float)ENC_DELAY_SIZE
; 154  :                                                  /(float)FRAME_LENGTH_SC);

  00076	68 00 00 ed 3f	 push	 1072496640		; 3fed0000H
  0007b	6a 00		 push	 0
  0007d	e8 00 00 00 00	 call	 _ceil
  00082	83 c4 08	 add	 esp, 8
  00085	e8 00 00 00 00	 call	 __ftol2
  0008a	8b 55 08	 mov	 edx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  0008d	66 89 42 48	 mov	 WORD PTR [edx+72], ax

; 155  :    pvciCodecInfoBlk->wNumPrimeFlushSamples     = 
; 156  :               (unsigned short)(pvciCodecInfoBlk->wNumPrimeFlushFrames*FRAME_LENGTH_SC
; 157  :                                -ENC_DELAY_SIZE);

  00091	8b 45 08	 mov	 eax, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00094	0f b7 48 48	 movzx	 ecx, WORD PTR [eax+72]
  00098	69 c9 a0 00 00
	00		 imul	 ecx, 160		; 000000a0H
  0009e	81 e9 91 00 00
	00		 sub	 ecx, 145		; 00000091H
  000a4	8b 55 08	 mov	 edx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  000a7	66 89 4a 4a	 mov	 WORD PTR [edx+74], cx

; 158  :    
; 159  :    /* Multi-channel support.                  */
; 160  :    pvciCodecInfoBlk->wNumChannels              = 1;

  000ab	8b 45 08	 mov	 eax, DWORD PTR _pvciCodecInfoBlk$[ebp]
  000ae	66 c7 40 32 01
	00		 mov	 WORD PTR [eax+50], 1

; 161  :    pvciCodecInfoBlk->wInterleaveBlockSize      = 1;

  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  000b7	66 c7 41 34 01
	00		 mov	 WORD PTR [ecx+52], 1

; 162  :    
; 163  :    return(VCI_NO_ERROR);

  000bd	66 33 c0	 xor	 ax, ax

; 164  : }

  000c0	5d		 pop	 ebp
  000c1	c2 04 00	 ret	 4
_vciGetInfoSC3@4 ENDP
_TEXT	ENDS
PUBLIC	_vciEncodeSC3@8
EXTRN	_VoxPackSC3@24:NEAR
EXTRN	_VoxEncodeSC@12:NEAR
EXTRN	_voxGetEncodeInitRate@4:NEAR
EXTRN	_VoxQuantSC3@12:NEAR
; Function compile flags: /Odt
;	COMDAT _vciEncodeSC3@8
_TEXT	SEGMENT
_QuanIndex$2297 = -264
_vciCodecMblk$ = -188
_ParamMblk$ = -184
_pEncodeMemBlk$ = 8
_pvciCodecIOBlk$ = 12
_vciEncodeSC3@8 PROC NEAR				; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H

; 201  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00009	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 202  :    PARAM_SC    ParamMblk;  /* scratch memory */
; 203  :    STACK_DECLARE
; 204  : 
; 205  :    /* check the validity of the VCI IO blk */
; 206  :    VCI_IO_BLK_PARAM_CHECK(pvciCodecIOBlk);

  00013	83 7d 0c 00	 cmp	 DWORD PTR _pvciCodecIOBlk$[ebp], 0
  00017	75 09		 jne	 SHORT $L2282
  00019	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  0001d	e9 4a 01 00 00	 jmp	 $L2278
$L2282:
  00022	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00025	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00029	75 09		 jne	 SHORT $L2283
  0002b	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  0002f	e9 38 01 00 00	 jmp	 $L2278
$L2283:
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00037	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0003a	75 09		 jne	 SHORT $L2284
  0003c	66 b8 ed 17	 mov	 ax, 6125		; 000017edH
  00040	e9 27 01 00 00	 jmp	 $L2278
$L2284:
  00045	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00048	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0004f	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00053	3b c2		 cmp	 eax, edx
  00055	7c 09		 jl	 SHORT $L2285
  00057	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  0005b	e9 0c 01 00 00	 jmp	 $L2278
$L2285:
  00060	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00063	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00067	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0006a	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  0006e	3b c8		 cmp	 ecx, eax
  00070	7c 09		 jl	 SHORT $L2286
  00072	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  00076	e9 f1 00 00 00	 jmp	 $L2278
$L2286:
  0007b	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0007e	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  00082	83 fa 07	 cmp	 edx, 7
  00085	7e 09		 jle	 SHORT $L2287
  00087	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  0008b	e9 dc 00 00 00	 jmp	 $L2278
$L2287:
  00090	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00093	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  00097	83 f9 07	 cmp	 ecx, 7
  0009a	7e 09		 jle	 SHORT $L2288
  0009c	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  000a0	e9 c7 00 00 00	 jmp	 $L2278
$L2288:

; 207  : 
; 208  :    if(!VCI_BLOCK_CHECK(pEncodeMemBlk))

  000a5	83 7d 08 00	 cmp	 DWORD PTR _pEncodeMemBlk$[ebp], 0
  000a9	74 0b		 je	 SHORT $L2291
  000ab	8b 55 08	 mov	 edx, DWORD PTR _pEncodeMemBlk$[ebp]
  000ae	81 3a ce fa 00
	00		 cmp	 DWORD PTR [edx], 64206	; 0000faceH
  000b4	74 09		 je	 SHORT $L2290
$L2291:

; 209  :       return VCI_NOT_VCI_HANDLE;

  000b6	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  000ba	e9 ad 00 00 00	 jmp	 $L2278
$L2290:

; 210  : 
; 211  :    if(!VCI_IS_ENCODE(pEncodeMemBlk))

  000bf	8b 45 08	 mov	 eax, DWORD PTR _pEncodeMemBlk$[ebp]
  000c2	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  000c6	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  000c9	74 09		 je	 SHORT $L2293

; 212  :       return VCI_NOT_ENC_HANDLE;

  000cb	66 b8 de 17	 mov	 ax, 6110		; 000017deH
  000cf	e9 98 00 00 00	 jmp	 $L2278
$L2293:

; 213  : 
; 214  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pEncodeMemBlk;

  000d4	8b 55 08	 mov	 edx, DWORD PTR _pEncodeMemBlk$[ebp]
  000d7	89 95 44 ff ff
	ff		 mov	 DWORD PTR _vciCodecMblk$[ebp], edx

; 215  :    STACK_ASSIGN(vciCodecMblk->pScratchBlk)
; 216  :    vciCodecMblk->pVciCodecIOBlock=pvciCodecIOBlk;

  000dd	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  000e3	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000e6	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 217  : 
; 218  :    /* check to make sure that codec was initialized at 3 or higher */
; 219  :    if(!(voxGetEncodeInitRate(vciCodecMblk->hCodecMblk)&SC_RATE_3K))

  000e9	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000ef	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 _voxGetEncodeInitRate@4
  000f8	83 e0 01	 and	 eax, 1
  000fb	85 c0		 test	 eax, eax
  000fd	75 06		 jne	 SHORT $L2295

; 220  :       return VCI_CODEC_NOT_SUPPORTED; 

  000ff	66 b8 64 19	 mov	 ax, 6500		; 00001964H
  00103	eb 67		 jmp	 SHORT $L2278
$L2295:

; 221  : 
; 222  :    VoxEncodeSC(STACK_S pvciCodecIOBlk->pPCMBuffer, vciCodecMblk->hCodecMblk,
; 223  :                (void *)&ParamMblk);

  00105	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _ParamMblk$[ebp]
  0010b	51		 push	 ecx
  0010c	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00112	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00115	50		 push	 eax
  00116	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00119	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011b	52		 push	 edx
  0011c	e8 00 00 00 00	 call	 _VoxEncodeSC@12

; 224  : 
; 225  :    /* combine quantization and pack together to save memory */
; 226  :    {
; 227  :      int QuanIndex[TOTAL_SC3_QUAN_INDICES];
; 228  :  
; 229  :      VoxQuantSC3(STACK_S QuanIndex, vciCodecMblk->hCodecMblk,
; 230  :                  (void *)&ParamMblk);

  00121	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _ParamMblk$[ebp]
  00127	50		 push	 eax
  00128	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  0012e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00131	52		 push	 edx
  00132	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _QuanIndex$2297[ebp]
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 _VoxQuantSC3@12

; 231  : 
; 232  :      VoxPackSC3(QuanIndex, pvciCodecIOBlk->pVoxBuffer, 
; 233  :                 &(pvciCodecIOBlk->wVoxBufferWriteByteOffset),
; 234  :                 &(pvciCodecIOBlk->chVoxBufferWriteBitOffset), 
; 235  :                 pvciCodecIOBlk->wVoxBufferSize,
; 236  :                 (unsigned short) END_OF_FRAME);

  0013e	6a 00		 push	 0
  00140	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00143	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  00147	52		 push	 edx
  00148	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  0014b	83 c0 14	 add	 eax, 20			; 00000014H
  0014e	50		 push	 eax
  0014f	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00152	83 c1 12	 add	 ecx, 18			; 00000012H
  00155	51		 push	 ecx
  00156	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00159	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0015c	50		 push	 eax
  0015d	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _QuanIndex$2297[ebp]
  00163	51		 push	 ecx
  00164	e8 00 00 00 00	 call	 _VoxPackSC3@24

; 237  :    }
; 238  : 
; 239  :    return(VCI_NO_ERROR);

  00169	66 33 c0	 xor	 ax, ax
$L2278:

; 240  : }

  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c2 08 00	 ret	 8
_vciEncodeSC3@8 ENDP
_TEXT	ENDS
PUBLIC	_vciDecodeSC3@8
EXTRN	_VoxUnQuantSC3@12:NEAR
EXTRN	_VoxUnPackSC3@24:NEAR
EXTRN	_VoxFadeSC@8:NEAR
EXTRN	_GetCurrentFrameStateSC@4:NEAR
EXTRN	_UpdateFadeStateSC@8:NEAR
EXTRN	_seekForward@24:NEAR
EXTRN	_vciSeekForwardSC@20:NEAR
EXTRN	_copyCBuf2LBuf@24:NEAR
EXTRN	_VoxDecodeSC@16:NEAR
EXTRN	_voxSetDecodeSC@8:NEAR
EXTRN	_voxGetDecReqDataFlagSC@4:NEAR
; Function compile flags: /Odt
;	COMDAT _vciDecodeSC3@8
_TEXT	SEGMENT
_QuanIndex$2333 = -288
_VoxErrRet$ = -216
_sByteOffset$ = -212
_vciCodecMblk$ = -208
_sLongerFrameFlag$ = -204
_pDecMemBlk$ = -200
_cDecReqDataFlagSC$ = -193
_ParamMblk$ = -192
_wSeek$ = -8
_cBitOffset$ = -1
_pDecodeMemBlk$ = 8
_pvciCodecIOBlk$ = 12
_vciDecodeSC3@8 PROC NEAR				; COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H

; 276  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00009	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 277  :    DEC_MEM_BLK     *pDecMemBlk;
; 278  :    PARAM_SC        ParamMblk; 
; 279  :    unsigned short  sLongerFrameFlag;
; 280  :    short wSeek;
; 281  :    STACK_DECLARE
; 282  :    VCI_RETCODE VoxErrRet = VCI_NO_ERROR;

  00013	66 c7 85 28 ff
	ff ff 00 00	 mov	 WORD PTR _VoxErrRet$[ebp], 0

; 283  :    unsigned short sByteOffset;
; 284  :    unsigned char cBitOffset;
; 285  :    unsigned char cDecReqDataFlagSC;
; 286  : 
; 287  :    /*----------------------------------------------------
; 288  :      sanity check and decode check
; 289  :    ----------------------------------------------------*/
; 290  :    if(!VCI_BLOCK_CHECK(pDecodeMemBlk))

  0001c	83 7d 08 00	 cmp	 DWORD PTR _pDecodeMemBlk$[ebp], 0
  00020	74 0b		 je	 SHORT $L2317
  00022	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  00025	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  0002b	74 09		 je	 SHORT $L2316
$L2317:

; 291  :       return VCI_NOT_VCI_HANDLE;

  0002d	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00031	e9 ac 02 00 00	 jmp	 $L2304
$L2316:

; 292  : 
; 293  :    if(!VCI_IS_DECODE(pDecodeMemBlk))     

  00036	8b 4d 08	 mov	 ecx, DWORD PTR _pDecodeMemBlk$[ebp]
  00039	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  0003d	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00040	74 09		 je	 SHORT $L2319

; 294  :       return VCI_NOT_DEC_HANDLE;

  00042	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  00046	e9 97 02 00 00	 jmp	 $L2304
$L2319:

; 295  :    
; 296  :    /*----------------------------------------------------
; 297  :      set some pointers and assign the VoxStack
; 298  :    ----------------------------------------------------*/
; 299  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pDecodeMemBlk;

  0004b	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  0004e	89 85 30 ff ff
	ff		 mov	 DWORD PTR _vciCodecMblk$[ebp], eax

; 300  : 
; 301  :    pDecMemBlk = (DEC_MEM_BLK *)(vciCodecMblk->hCodecMblk);

  00054	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  0005a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0005d	89 95 38 ff ff
	ff		 mov	 DWORD PTR _pDecMemBlk$[ebp], edx

; 302  : 
; 303  :    STACK_ASSIGN(vciCodecMblk->pScratchBlk);
; 304  :    vciCodecMblk->pVciCodecIOBlock=pvciCodecIOBlk;

  00063	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0006c	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 305  : 
; 306  :    /*----------------------------------------------------
; 307  :      check the validity of the VCI IO Block.
; 308  :    ----------------------------------------------------*/
; 309  :    
; 310  :    if (SILENCE != GetCurrentFrameStateSC(pDecMemBlk->pFadeIOMemBlk))

  0006f	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00075	8b 02		 mov	 eax, DWORD PTR [edx]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _GetCurrentFrameStateSC@4
  0007d	85 c0		 test	 eax, eax
  0007f	0f 84 c6 01 00
	00		 je	 $L2322

; 311  :    {
; 312  : 	   VCI_IO_BLK_PARAM_CHECK(pvciCodecIOBlk);

  00085	83 7d 0c 00	 cmp	 DWORD PTR _pvciCodecIOBlk$[ebp], 0
  00089	75 09		 jne	 SHORT $L2323
  0008b	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  0008f	e9 4e 02 00 00	 jmp	 $L2304
$L2323:
  00094	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00097	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0009b	75 09		 jne	 SHORT $L2324
  0009d	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  000a1	e9 3c 02 00 00	 jmp	 $L2304
$L2324:
  000a6	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000a9	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000ac	75 09		 jne	 SHORT $L2325
  000ae	66 b8 ed 17	 mov	 ax, 6125		; 000017edH
  000b2	e9 2b 02 00 00	 jmp	 $L2304
$L2325:
  000b7	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  000ba	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  000be	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000c1	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  000c5	3b c8		 cmp	 ecx, eax
  000c7	7c 09		 jl	 SHORT $L2326
  000c9	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  000cd	e9 10 02 00 00	 jmp	 $L2304
$L2326:
  000d2	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000d5	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  000d9	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  000dc	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  000e0	3b d1		 cmp	 edx, ecx
  000e2	7c 09		 jl	 SHORT $L2327
  000e4	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  000e8	e9 f5 01 00 00	 jmp	 $L2304
$L2327:
  000ed	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000f0	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  000f4	83 f8 07	 cmp	 eax, 7
  000f7	7e 09		 jle	 SHORT $L2328
  000f9	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  000fd	e9 e0 01 00 00	 jmp	 $L2304
$L2328:
  00102	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00105	0f b6 51 14	 movzx	 edx, BYTE PTR [ecx+20]
  00109	83 fa 07	 cmp	 edx, 7
  0010c	7e 09		 jle	 SHORT $L2329
  0010e	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  00112	e9 cb 01 00 00	 jmp	 $L2304
$L2329:

; 313  : 
; 314  : 	  /*----------------------------------------------------
; 315  : 		 If the decoder needs a new frame to decode then
; 316  : 		   get the new frame from pvciCodecIOBlk->pVoxBuffer
; 317  : 		   and put it in vciCodecMblk->pbSaveVoxBuffer.
; 318  : 	   ----------------------------------------------------*/
; 319  : 	   if (voxGetDecReqDataFlagSC((void *)pDecMemBlk))

  00117	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 _voxGetDecReqDataFlagSC@4
  00123	0f b6 c8	 movzx	 ecx, al
  00126	85 c9		 test	 ecx, ecx
  00128	74 66		 je	 SHORT $L2331

; 320  : 		{
; 321  : 
; 322  : 		/*------------------------------------------------------------
; 323  : 		  Check whether there are sufficient Vox data.
; 324  : 		  ------------------------------------------------------------*/
; 325  : 		  VoxErrRet = vciSeekForwardSC(pDecodeMemBlk, pvciCodecIOBlk,
; 326  : 									   1, &sByteOffset, &cBitOffset);

  0012a	8d 55 ff	 lea	 edx, DWORD PTR _cBitOffset$[ebp]
  0012d	52		 push	 edx
  0012e	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _sByteOffset$[ebp]
  00134	50		 push	 eax
  00135	6a 01		 push	 1
  00137	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0013a	51		 push	 ecx
  0013b	8b 55 08	 mov	 edx, DWORD PTR _pDecodeMemBlk$[ebp]
  0013e	52		 push	 edx
  0013f	e8 00 00 00 00	 call	 _vciSeekForwardSC@20
  00144	66 89 85 28 ff
	ff ff		 mov	 WORD PTR _VoxErrRet$[ebp], ax

; 327  : 
; 328  : 		  if (VoxErrRet != VCI_NO_ERROR)

  0014b	0f b7 85 28 ff
	ff ff		 movzx	 eax, WORD PTR _VoxErrRet$[ebp]
  00152	85 c0		 test	 eax, eax
  00154	74 0c		 je	 SHORT $L2332

; 329  : 			 return VoxErrRet;

  00156	66 8b 85 28 ff
	ff ff		 mov	 ax, WORD PTR _VoxErrRet$[ebp]
  0015d	e9 80 01 00 00	 jmp	 $L2304
$L2332:

; 330  : 
; 331  : 		/*------------------------------------------------------------
; 332  : 		  No further test is needed at this point because the error
; 333  : 			condition has already been tested and there is a frame
; 334  : 			of data available in the circular buffer.
; 335  : 		  ------------------------------------------------------------*/
; 336  : 		  copyCBuf2LBuf(pvciCodecIOBlk->pVoxBuffer, 
; 337  : 						&(pvciCodecIOBlk->wVoxBufferReadByteOffset),
; 338  : 						&(pvciCodecIOBlk->chVoxBufferReadBitOffset), 
; 339  : 						pvciCodecIOBlk->wVoxBufferSize, 
; 340  : 						TOTAL_BITS_SC3, pDecMemBlk->pbSaveVoxBuffer);

  00162	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00168	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0016b	52		 push	 edx
  0016c	6a 40		 push	 64			; 00000040H
  0016e	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00171	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  00175	51		 push	 ecx
  00176	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00179	83 c2 10	 add	 edx, 16			; 00000010H
  0017c	52		 push	 edx
  0017d	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00180	83 c0 0e	 add	 eax, 14			; 0000000eH
  00183	50		 push	 eax
  00184	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00187	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 _copyCBuf2LBuf@24
$L2331:

; 341  : 		}
; 342  : 
; 343  : 	   /*---------------------------------------------------------
; 344  : 		 Unpack and unquantize the frame in 
; 345  : 		   vciCodecMblk->pbSaveVoxBuffer.
; 346  : 	   ---------------------------------------------------------*/
; 347  : 	   {
; 348  : 		 int QuanIndex[TOTAL_SC3_QUAN_INDICES];
; 349  : 		 sByteOffset = 0;

  00190	66 c7 85 2c ff
	ff ff 00 00	 mov	 WORD PTR _sByteOffset$[ebp], 0

; 350  : 		 cBitOffset = 0;

  00199	c6 45 ff 00	 mov	 BYTE PTR _cBitOffset$[ebp], 0

; 351  : 	   /*---------------------------------------------------------
; 352  : 		 This unpacking location is a momentary hack, must be changed 
; 353  : 		 to support time scaling ####
; 354  : 		 ---------------------------------------------------------*/
; 355  : 		 VoxUnPackSC3(QuanIndex,
; 356  : 					  pDecMemBlk->pbSaveVoxBuffer,
; 357  : 					  &sByteOffset,
; 358  : 					  &cBitOffset,
; 359  : 					  TOTAL_BYTES_SC3,
; 360  : 					  &sLongerFrameFlag);

  0019d	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _sLongerFrameFlag$[ebp]
  001a3	50		 push	 eax
  001a4	6a 08		 push	 8
  001a6	8d 4d ff	 lea	 ecx, DWORD PTR _cBitOffset$[ebp]
  001a9	51		 push	 ecx
  001aa	8d 95 2c ff ff
	ff		 lea	 edx, DWORD PTR _sByteOffset$[ebp]
  001b0	52		 push	 edx
  001b1	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  001b7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001ba	51		 push	 ecx
  001bb	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _QuanIndex$2333[ebp]
  001c1	52		 push	 edx
  001c2	e8 00 00 00 00	 call	 _VoxUnPackSC3@24

; 361  : 
; 362  : 		 VoxUnQuantSC3(STACK_S QuanIndex, (void *)pDecMemBlk, &ParamMblk);

  001c7	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _ParamMblk$[ebp]
  001cd	50		 push	 eax
  001ce	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  001d4	51		 push	 ecx
  001d5	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _QuanIndex$2333[ebp]
  001db	52		 push	 edx
  001dc	e8 00 00 00 00	 call	 _VoxUnQuantSC3@12

; 363  : 	   }
; 364  : 
; 365  : 	   /*---------------------------------------------------------
; 366  : 		 if sLongerFrameFlag==LONGER_FRAME then this is a 
; 367  : 		 SC_RATE_6K bitstream and we need to increment the byte
; 368  : 		 pointer in the circular buffer by ADDITIONAL_BYTES_SC6
; 369  : 		 ---------------------------------------------------------*/
; 370  : 	   if (voxGetDecReqDataFlagSC((void *)pDecMemBlk) 
; 371  : 		   && (sLongerFrameFlag==LONGER_FRAME))

  001e1	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  001e7	50		 push	 eax
  001e8	e8 00 00 00 00	 call	 _voxGetDecReqDataFlagSC@4
  001ed	0f b6 c8	 movzx	 ecx, al
  001f0	85 c9		 test	 ecx, ecx
  001f2	74 55		 je	 SHORT $L2336
  001f4	0f b7 95 34 ff
	ff ff		 movzx	 edx, WORD PTR _sLongerFrameFlag$[ebp]
  001fb	83 fa 01	 cmp	 edx, 1
  001fe	75 49		 jne	 SHORT $L2336

; 372  : 		 {
; 373  : 		   wSeek=seekForward(pvciCodecIOBlk->pVoxBuffer,
; 374  : 							 pvciCodecIOBlk->wVoxBufferReadByteOffset,
; 375  : 							 pvciCodecIOBlk->wVoxBufferWriteByteOffset,
; 376  : 							 pvciCodecIOBlk->wVoxBufferSize,
; 377  : 							 1, NULL);

  00200	6a 00		 push	 0
  00202	6a 01		 push	 1
  00204	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00207	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  0020b	51		 push	 ecx
  0020c	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0020f	66 8b 42 12	 mov	 ax, WORD PTR [edx+18]
  00213	50		 push	 eax
  00214	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00217	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  0021b	52		 push	 edx
  0021c	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  0021f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00222	51		 push	 ecx
  00223	e8 00 00 00 00	 call	 _seekForward@24
  00228	66 89 45 f8	 mov	 WORD PTR _wSeek$[ebp], ax

; 378  : 
; 379  : 		   if(wSeek==-2) 

  0022c	0f bf 55 f8	 movsx	 edx, WORD PTR _wSeek$[ebp]
  00230	83 fa fe	 cmp	 edx, -2			; fffffffeH
  00233	75 09		 jne	 SHORT $L2338

; 380  : 			  return VCI_BITSTREAM_CORRUPTED;

  00235	66 b8 29 18	 mov	 ax, 6185		; 00001829H
  00239	e9 a4 00 00 00	 jmp	 $L2304
$L2338:

; 381  : 
; 382  : 		   pvciCodecIOBlk->wVoxBufferReadByteOffset=(unsigned short)wSeek;

  0023e	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00241	66 8b 4d f8	 mov	 cx, WORD PTR _wSeek$[ebp]
  00245	66 89 48 0e	 mov	 WORD PTR [eax+14], cx
$L2336:

; 383  : 		 }
; 384  :    }
; 385  :    else

  00249	eb 1d		 jmp	 SHORT $L2340
$L2322:

; 386  :    {
; 387  : 	   VCI_SIL_IO_BLK_PARAM_CHECK_DEC(pvciCodecIOBlk);

  0024b	83 7d 0c 00	 cmp	 DWORD PTR _pvciCodecIOBlk$[ebp], 0
  0024f	75 09		 jne	 SHORT $L2341
  00251	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  00255	e9 88 00 00 00	 jmp	 $L2304
$L2341:
  0025a	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0025d	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00260	75 06		 jne	 SHORT $L2340
  00262	66 b8 ed 17	 mov	 ax, 6125		; 000017edH
  00266	eb 7a		 jmp	 SHORT $L2304
$L2340:

; 388  :    }
; 389  : 
; 390  :    /*----------------------------------------------------
; 391  :      Set the decoder rate, it is always 3
; 392  :    ----------------------------------------------------*/
; 393  :    if(voxSetDecodeSC((void *)pDecMemBlk, SC_RATE_3K))

  00268	6a 01		 push	 1
  0026a	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  00270	50		 push	 eax
  00271	e8 00 00 00 00	 call	 _voxSetDecodeSC@8
  00276	0f b7 c8	 movzx	 ecx, ax
  00279	85 c9		 test	 ecx, ecx
  0027b	74 06		 je	 SHORT $L2344

; 394  :      return VCI_CODEC_NOT_SUPPORTED;

  0027d	66 b8 64 19	 mov	 ax, 6500		; 00001964H
  00281	eb 5f		 jmp	 SHORT $L2304
$L2344:

; 395  :    
; 396  :    /*---------------------------------------------------------
; 397  :      Call the fade routine to modify parameters if there
; 398  :        has benn a fade.
; 399  :    ---------------------------------------------------------*/
; 400  :    VoxFadeSC(pDecMemBlk->pFadeIOMemBlk, &ParamMblk);

  00283	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR _ParamMblk$[ebp]
  00289	52		 push	 edx
  0028a	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  00290	8b 08		 mov	 ecx, DWORD PTR [eax]
  00292	51		 push	 ecx
  00293	e8 00 00 00 00	 call	 _VoxFadeSC@8

; 401  : 
; 402  :    /*---------------------------------------------------------
; 403  :      Decode the parameters.
; 404  :    ---------------------------------------------------------*/
; 405  :    VoxDecodeSC(STACK_S (void *)pDecMemBlk, &ParamMblk, pvciCodecIOBlk->pPCMBuffer, 
; 406  :                &(pvciCodecIOBlk->wSamplesInPCMBuffer) );

  00298	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0029b	83 c2 04	 add	 edx, 4
  0029e	52		 push	 edx
  0029f	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  002a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a4	51		 push	 ecx
  002a5	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR _ParamMblk$[ebp]
  002ab	52		 push	 edx
  002ac	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  002b2	50		 push	 eax
  002b3	e8 00 00 00 00	 call	 _VoxDecodeSC@16

; 407  :  
; 408  :    /*---------------------------------------------------------
; 409  :      Update the fade block for the case when the decoder
; 410  :        is not yet finished with the current frame.
; 411  :    ---------------------------------------------------------*/
; 412  :    cDecReqDataFlagSC = voxGetDecReqDataFlagSC((void *)pDecMemBlk);

  002b8	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  002be	51		 push	 ecx
  002bf	e8 00 00 00 00	 call	 _voxGetDecReqDataFlagSC@4
  002c4	88 85 3f ff ff
	ff		 mov	 BYTE PTR _cDecReqDataFlagSC$[ebp], al

; 413  :    UpdateFadeStateSC( pDecMemBlk->pFadeIOMemBlk, cDecReqDataFlagSC );

  002ca	8a 95 3f ff ff
	ff		 mov	 dl, BYTE PTR _cDecReqDataFlagSC$[ebp]
  002d0	52		 push	 edx
  002d1	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  002d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d9	51		 push	 ecx
  002da	e8 00 00 00 00	 call	 _UpdateFadeStateSC@8

; 414  : 
; 415  :    return(VCI_NO_ERROR);

  002df	66 33 c0	 xor	 ax, ax
$L2304:

; 416  : }

  002e2	8b e5		 mov	 esp, ebp
  002e4	5d		 pop	 ebp
  002e5	c2 08 00	 ret	 8
_vciDecodeSC3@8 ENDP
_TEXT	ENDS
PUBLIC	_vciInitEncodeSC3@4
PUBLIC	_vciFreeEncodeSC3@4
PUBLIC	??_C@_0N@KGCNFMNN@frame?5length?$AA@		; `string'
PUBLIC	??_C@_04HCCHHEEF@rate?$AA@			; `string'
EXTRN	_calloc:NEAR
EXTRN	_vemRegisterConstShort@12:NEAR
EXTRN	_vemInit@0:NEAR
EXTRN	_VoxInitEncodeSC3@8:NEAR
;	COMDAT ??_C@_0N@KGCNFMNN@frame?5length?$AA@
CONST	SEGMENT
??_C@_0N@KGCNFMNN@frame?5length?$AA@ DB 'frame length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCCHHEEF@rate?$AA@
CONST	SEGMENT
??_C@_04HCCHHEEF@rate?$AA@ DB 'rate', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciInitEncodeSC3@4
_TEXT	SEGMENT
_vciCodecMblk$ = -4
_hEncodeMemBlk$ = 8
_vciInitEncodeSC3@4 PROC NEAR				; COMDAT

; 450  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 451  :    VCI_CODEC_BLOCK *vciCodecMblk=NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 452  :    STACK_DECLARE
; 453  : 
; 454  :    if(!hEncodeMemBlk)

  0000b	83 7d 08 00	 cmp	 DWORD PTR _hEncodeMemBlk$[ebp], 0
  0000f	75 09		 jne	 SHORT $L2352

; 455  :       return VCI_NULL_ARG;

  00011	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  00015	e9 fc 00 00 00	 jmp	 $L2349
$L2352:

; 456  : 
; 457  :    if(VOX_MEM_INIT(vciCodecMblk=*hEncodeMemBlk,1,sizeof(VCI_CODEC_BLOCK))) 

  0001a	6a 2c		 push	 44			; 0000002cH
  0001c	6a 01		 push	 1
  0001e	e8 00 00 00 00	 call	 _calloc
  00023	83 c4 08	 add	 esp, 8
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _hEncodeMemBlk$[ebp]
  00029	89 01		 mov	 DWORD PTR [ecx], eax
  0002b	8b 55 08	 mov	 edx, DWORD PTR _hEncodeMemBlk$[ebp]
  0002e	8b 02		 mov	 eax, DWORD PTR [edx]
  00030	89 45 fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax
  00033	83 7d fc 00	 cmp	 DWORD PTR _vciCodecMblk$[ebp], 0
  00037	75 09		 jne	 SHORT $L2354

; 458  :      return VCI_FAILED_MEM_ALLOC;

  00039	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  0003d	e9 d4 00 00 00	 jmp	 $L2349
$L2354:

; 459  : 
; 460  :    vciCodecMblk->chEncOrDec = ENCODE_ID;  

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00045	c6 41 0c 0a	 mov	 BYTE PTR [ecx+12], 10	; 0000000aH

; 461  :    vciCodecMblk->dwVciChunkID = SANITY_CHECK;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0004c	c7 02 ce fa 00
	00		 mov	 DWORD PTR [edx], 64206	; 0000faceH

; 462  :    vciCodecMblk->dwCodecClassID = VOXWARE_CODEC_SC_8K_3;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00055	c7 40 04 03 00
	00 03		 mov	 DWORD PTR [eax+4], 50331651 ; 03000003H

; 463  :    vciCodecMblk->dwCodecID = VOXWARE_CODEC_ID_SC_8K_3_GENERIC;

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  0005f	c7 41 08 03 00
	01 03		 mov	 DWORD PTR [ecx+8], 50397187 ; 03010003H

; 464  : 
; 465  :    if(STACK_SET(vciCodecMblk->pScratchBlk,(MAX_STACK_WORD_SC3_ENC*sizeof(int)))) {

  00066	33 d2		 xor	 edx, edx
  00068	85 d2		 test	 edx, edx
  0006a	74 12		 je	 SHORT $L2355

; 466  :       vciFreeEncodeSC3(hEncodeMemBlk);

  0006c	8b 45 08	 mov	 eax, DWORD PTR _hEncodeMemBlk$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _vciFreeEncodeSC3@4

; 467  :       return VCI_FAILED_MEM_ALLOC;

  00075	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  00079	e9 98 00 00 00	 jmp	 $L2349
$L2355:

; 468  :    }
; 469  : 
; 470  :    if(!(vciCodecMblk->pvemMemBlk=vemInit())) {

  0007e	e8 00 00 00 00	 call	 _vemInit@0
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00086	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00089	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0008c	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00090	75 0f		 jne	 SHORT $L2356

; 471  : #if VEM_DEFINED == 1
; 472  :       vciFreeEncodeSC3(hEncodeMemBlk);

  00092	8b 45 08	 mov	 eax, DWORD PTR _hEncodeMemBlk$[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 _vciFreeEncodeSC3@4

; 473  :       return VCI_FAILED_MEM_ALLOC; 

  0009b	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  0009f	eb 75		 jmp	 SHORT $L2349
$L2356:

; 474  : #endif
; 475  :    } else {
; 476  :       vemRegisterConstShort(GET_VEM_MEMORY_HANDLE(vciCodecMblk), 
; 477  :                             (short)FRAME_LENGTH_SC, "frame length");

  000a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@KGCNFMNN@frame?5length?$AA@
  000a6	68 a0 00 00 00	 push	 160			; 000000a0H
  000ab	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000ae	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000b1	8b 02		 mov	 eax, DWORD PTR [edx]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _vemRegisterConstShort@12

; 478  :       vemRegisterConstShort(GET_VEM_MEMORY_HANDLE(vciCodecMblk), 
; 479  :                             (short)RATE8K, "rate");

  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04HCCHHEEF@rate?$AA@
  000be	68 40 1f 00 00	 push	 8000			; 00001f40H
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000c6	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000c9	8b 02		 mov	 eax, DWORD PTR [edx]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _vemRegisterConstShort@12

; 480  :    }
; 481  : 
; 482  :    if(VoxInitEncodeSC3(&vciCodecMblk->hCodecMblk, vciCodecMblk->pvemMemBlk)) {

  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000d4	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000d7	52		 push	 edx
  000d8	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  000db	83 c0 10	 add	 eax, 16			; 00000010H
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 _VoxInitEncodeSC3@8
  000e4	0f b7 c8	 movzx	 ecx, ax
  000e7	85 c9		 test	 ecx, ecx
  000e9	74 0f		 je	 SHORT $L2366

; 483  :       vciFreeEncodeSC3(hEncodeMemBlk);

  000eb	8b 55 08	 mov	 edx, DWORD PTR _hEncodeMemBlk$[ebp]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 _vciFreeEncodeSC3@4

; 484  :       return VCI_FAILED_MEM_ALLOC;

  000f4	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  000f8	eb 1c		 jmp	 SHORT $L2349
$L2366:

; 485  :    }
; 486  : 
; 487  :    if(initMethodStruct(&vciCodecMblk->pVciMethodStruct))

  000fa	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  000fd	83 c0 24	 add	 eax, 36			; 00000024H
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 _initMethodStruct@4
  00106	0f b7 c8	 movzx	 ecx, ax
  00109	85 c9		 test	 ecx, ecx
  0010b	74 06		 je	 SHORT $L2367

; 488  :       return VCI_FAILED_MEM_ALLOC;

  0010d	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  00111	eb 03		 jmp	 SHORT $L2349
$L2367:

; 489  : 
; 490  :    return VCI_NO_ERROR;

  00113	66 33 c0	 xor	 ax, ax
$L2349:

; 491  : }

  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c2 04 00	 ret	 4
_vciInitEncodeSC3@4 ENDP
_TEXT	ENDS
PUBLIC	_vciInitDecodeSC3@4
PUBLIC	_vciFreeDecodeSC3@4
EXTRN	_VoxinitFadeSC@4:NEAR
EXTRN	_VoxInitDecodeSC3@4:NEAR
; Function compile flags: /Odt
;	COMDAT _vciInitDecodeSC3@4
_TEXT	SEGMENT
_vciCodecMblk$ = -8
_pDecMemBlk$ = -4
_hDecodeMemBlk$ = 8
_vciInitDecodeSC3@4 PROC NEAR				; COMDAT

; 525  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 526  :    VCI_CODEC_BLOCK *vciCodecMblk=NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 527  :    DEC_MEM_BLK *pDecMemBlk;
; 528  : 
; 529  :    STACK_DECLARE
; 530  : 
; 531  :    if(!hDecodeMemBlk)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _hDecodeMemBlk$[ebp], 0
  00011	75 09		 jne	 SHORT $L2374

; 532  :       return VCI_NULL_ARG;

  00013	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  00017	e9 fd 00 00 00	 jmp	 $L2370
$L2374:

; 533  : 
; 534  :    if(VOX_MEM_INIT(vciCodecMblk=*hDecodeMemBlk,1,sizeof(VCI_CODEC_BLOCK))) 

  0001c	6a 2c		 push	 44			; 0000002cH
  0001e	6a 01		 push	 1
  00020	e8 00 00 00 00	 call	 _calloc
  00025	83 c4 08	 add	 esp, 8
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _hDecodeMemBlk$[ebp]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax
  0002d	8b 55 08	 mov	 edx, DWORD PTR _hDecodeMemBlk$[ebp]
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	89 45 f8	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax
  00035	83 7d f8 00	 cmp	 DWORD PTR _vciCodecMblk$[ebp], 0
  00039	75 09		 jne	 SHORT $L2376

; 535  :       return VCI_FAILED_MEM_ALLOC;

  0003b	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  0003f	e9 d5 00 00 00	 jmp	 $L2370
$L2376:

; 536  : 
; 537  :    vciCodecMblk->chEncOrDec = DECODE_ID;

  00044	8b 4d f8	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00047	c6 41 0c 0b	 mov	 BYTE PTR [ecx+12], 11	; 0000000bH

; 538  :    vciCodecMblk->dwVciChunkID = SANITY_CHECK;

  0004b	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0004e	c7 02 ce fa 00
	00		 mov	 DWORD PTR [edx], 64206	; 0000faceH

; 539  : 
; 540  :    if(STACK_SET(vciCodecMblk->pScratchBlk,MAX_STACK_WORD_SC3_DEC*sizeof(int))) {

  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	74 12		 je	 SHORT $L2377

; 541  :       vciFreeDecodeSC3(hDecodeMemBlk);

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _hDecodeMemBlk$[ebp]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 _vciFreeDecodeSC3@4

; 542  :       return VCI_FAILED_MEM_ALLOC;

  00063	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  00067	e9 ad 00 00 00	 jmp	 $L2370
$L2377:

; 543  :    } 
; 544  : 
; 545  :    if(!(vciCodecMblk->pvemMemBlk=vemInit())) {

  0006c	e8 00 00 00 00	 call	 _vemInit@0
  00071	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00074	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00077	8b 45 f8	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  0007a	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0007e	75 12		 jne	 SHORT $L2378

; 546  : #if VEM_DEFINED == 1
; 547  :       vciFreeDecodeSC3(hDecodeMemBlk);

  00080	8b 4d 08	 mov	 ecx, DWORD PTR _hDecodeMemBlk$[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 _vciFreeDecodeSC3@4

; 548  :       return VCI_FAILED_MEM_ALLOC;

  00089	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  0008d	e9 87 00 00 00	 jmp	 $L2370
$L2378:

; 549  : #endif
; 550  :    }
; 551  : 
; 552  :    if(VoxInitDecodeSC3(&vciCodecMblk->hCodecMblk)) {

  00092	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00095	83 c2 10	 add	 edx, 16			; 00000010H
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 _VoxInitDecodeSC3@4
  0009e	0f b7 c0	 movzx	 eax, ax
  000a1	85 c0		 test	 eax, eax
  000a3	74 0f		 je	 SHORT $L2379

; 553  :       vciFreeDecodeSC3(hDecodeMemBlk);

  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _hDecodeMemBlk$[ebp]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 _vciFreeDecodeSC3@4

; 554  :       return VCI_FAILED_MEM_ALLOC;

  000ae	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  000b2	eb 65		 jmp	 SHORT $L2370
$L2379:

; 555  :    } 
; 556  : 
; 557  :    pDecMemBlk = (DEC_MEM_BLK *)(vciCodecMblk->hCodecMblk);

  000b4	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000b7	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000ba	89 45 fc	 mov	 DWORD PTR _pDecMemBlk$[ebp], eax

; 558  : 
; 559  :    if(VoxinitFadeSC(&pDecMemBlk->pFadeIOMemBlk)) {

  000bd	8b 4d fc	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 _VoxinitFadeSC@4
  000c6	0f b7 d0	 movzx	 edx, ax
  000c9	85 d2		 test	 edx, edx
  000cb	74 0f		 je	 SHORT $L2381

; 560  :       vciFreeDecodeSC3(hDecodeMemBlk);

  000cd	8b 45 08	 mov	 eax, DWORD PTR _hDecodeMemBlk$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _vciFreeDecodeSC3@4

; 561  :       return VCI_FAILED_MEM_ALLOC;

  000d6	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  000da	eb 3d		 jmp	 SHORT $L2370
$L2381:

; 562  :    }
; 563  : 
; 564  :    if (VOX_MEM_INIT(pDecMemBlk->pbSaveVoxBuffer, 
; 565  :                     TOTAL_BYTES_SC3,
; 566  :                     sizeof(unsigned char *)))

  000dc	6a 04		 push	 4
  000de	6a 08		 push	 8
  000e0	e8 00 00 00 00	 call	 _calloc
  000e5	83 c4 08	 add	 esp, 8
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  000eb	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000ee	8b 55 fc	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  000f1	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  000f5	75 06		 jne	 SHORT $L2383

; 567  :      return VCI_FAILED_MEM_ALLOC;

  000f7	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  000fb	eb 1c		 jmp	 SHORT $L2370
$L2383:

; 568  : 
; 569  :    if(initMethodStruct(&vciCodecMblk->pVciMethodStruct))

  000fd	8b 45 f8	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00100	83 c0 24	 add	 eax, 36			; 00000024H
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 _initMethodStruct@4
  00109	0f b7 c8	 movzx	 ecx, ax
  0010c	85 c9		 test	 ecx, ecx
  0010e	74 06		 je	 SHORT $L2384

; 570  :       return VCI_FAILED_MEM_ALLOC;

  00110	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  00114	eb 03		 jmp	 SHORT $L2370
$L2384:

; 571  : 
; 572  :    return VCI_NO_ERROR;

  00116	66 33 c0	 xor	 ax, ax
$L2370:

; 573  : }

  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c2 04 00	 ret	 4
_vciInitDecodeSC3@4 ENDP
_TEXT	ENDS
EXTRN	_free:NEAR
EXTRN	_vemFree@4:NEAR
EXTRN	_VoxFreeEncodeSC3@4:NEAR
; Function compile flags: /Odt
;	COMDAT _vciFreeEncodeSC3@4
_TEXT	SEGMENT
_vciCodecMblk$ = -4
_hEncodeMemBlk$ = 8
_vciFreeEncodeSC3@4 PROC NEAR				; COMDAT

; 606  : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 607  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 608  : 
; 609  :    /* First make sure that the handle passed is the correct one. */
; 610  :    if(!hEncodeMemBlk)

  0000b	83 7d 08 00	 cmp	 DWORD PTR _hEncodeMemBlk$[ebp], 0
  0000f	75 09		 jne	 SHORT $L2390

; 611  :       return VCI_NULL_ARG;

  00011	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  00015	e9 80 00 00 00	 jmp	 $L2387
$L2390:

; 612  : 
; 613  :    if(!VCI_BLOCK_CHECK(*hEncodeMemBlk))

  0001a	8b 45 08	 mov	 eax, DWORD PTR _hEncodeMemBlk$[ebp]
  0001d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00020	74 0d		 je	 SHORT $L2393
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _hEncodeMemBlk$[ebp]
  00025	8b 11		 mov	 edx, DWORD PTR [ecx]
  00027	81 3a ce fa 00
	00		 cmp	 DWORD PTR [edx], 64206	; 0000faceH
  0002d	74 06		 je	 SHORT $L2392
$L2393:

; 614  :       return VCI_NOT_VCI_HANDLE;

  0002f	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00033	eb 65		 jmp	 SHORT $L2387
$L2392:

; 615  : 
; 616  :    if(!VCI_IS_ENCODE(*hEncodeMemBlk))

  00035	8b 45 08	 mov	 eax, DWORD PTR _hEncodeMemBlk$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  0003e	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00041	74 06		 je	 SHORT $L2395

; 617  :       return VCI_NOT_DEC_HANDLE;

  00043	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  00047	eb 51		 jmp	 SHORT $L2387
$L2395:

; 618  : 
; 619  :    vciCodecMblk = (VCI_CODEC_BLOCK *)*hEncodeMemBlk;

  00049	8b 45 08	 mov	 eax, DWORD PTR _hEncodeMemBlk$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	89 4d fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], ecx

; 620  :    
; 621  :    vciCodecMblk->dwVciChunkID=0;

  00051	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00054	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 622  : 
; 623  :    VoxFreeEncodeSC3(&vciCodecMblk->hCodecMblk);

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  0005d	83 c0 10	 add	 eax, 16			; 00000010H
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 _VoxFreeEncodeSC3@4

; 624  : 
; 625  :    vemFree(vciCodecMblk->pvemMemBlk);

  00066	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00069	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 _vemFree@4

; 626  : 
; 627  :    freeMethodStruct(&vciCodecMblk->pVciMethodStruct);

  00072	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00075	83 c0 24	 add	 eax, 36			; 00000024H
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _freeMethodStruct@4

; 628  : 
; 629  :    STACK_UNSET(vciCodecMblk->pScratchBlk)
; 630  : 
; 631  :    VOX_MEM_FREE(vciCodecMblk);

  0007e	83 7d fc 00	 cmp	 DWORD PTR _vciCodecMblk$[ebp], 0
  00082	74 13		 je	 SHORT $L2397
  00084	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _free
  0008d	83 c4 04	 add	 esp, 4
  00090	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0
$L2397:

; 632  : 
; 633  :    return VCI_NO_ERROR;

  00097	66 33 c0	 xor	 ax, ax
$L2387:

; 634  : }

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
_vciFreeEncodeSC3@4 ENDP
_TEXT	ENDS
EXTRN	_VoxfreeFadeSC@4:NEAR
EXTRN	_VoxFreeDecodeSC3@4:NEAR
; Function compile flags: /Odt
;	COMDAT _vciFreeDecodeSC3@4
_TEXT	SEGMENT
_vciCodecMblk$ = -8
_pDecMemBlk$ = -4
_hDecodeMemBlk$ = 8
_vciFreeDecodeSC3@4 PROC NEAR				; COMDAT

; 666  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 667  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 668  :    DEC_MEM_BLK *pDecMemBlk;
; 669  : 
; 670  :    /* First make sure that the handle passed is the correct one. */
; 671  :    if(!hDecodeMemBlk)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _hDecodeMemBlk$[ebp], 0
  00011	75 09		 jne	 SHORT $L2405

; 672  :       return VCI_NULL_ARG;

  00013	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  00017	e9 ba 00 00 00	 jmp	 $L2401
$L2405:

; 673  : 
; 674  :    /* First make sure that the handle passed is the correct one. */
; 675  :    if(!VCI_BLOCK_CHECK(*hDecodeMemBlk))

  0001c	8b 45 08	 mov	 eax, DWORD PTR _hDecodeMemBlk$[ebp]
  0001f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00022	74 0d		 je	 SHORT $L2408
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _hDecodeMemBlk$[ebp]
  00027	8b 11		 mov	 edx, DWORD PTR [ecx]
  00029	81 3a ce fa 00
	00		 cmp	 DWORD PTR [edx], 64206	; 0000faceH
  0002f	74 09		 je	 SHORT $L2407
$L2408:

; 676  :       return VCI_NOT_VCI_HANDLE;

  00031	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00035	e9 9c 00 00 00	 jmp	 $L2401
$L2407:

; 677  : 
; 678  :    if(!VCI_IS_DECODE(*hDecodeMemBlk))

  0003a	8b 45 08	 mov	 eax, DWORD PTR _hDecodeMemBlk$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00043	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00046	74 09		 je	 SHORT $L2410

; 679  :       return VCI_NOT_DEC_HANDLE;

  00048	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  0004c	e9 85 00 00 00	 jmp	 $L2401
$L2410:

; 680  :    
; 681  :    vciCodecMblk = (VCI_CODEC_BLOCK *)*hDecodeMemBlk;

  00051	8b 45 08	 mov	 eax, DWORD PTR _hDecodeMemBlk$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	89 4d f8	 mov	 DWORD PTR _vciCodecMblk$[ebp], ecx

; 682  :    pDecMemBlk = (DEC_MEM_BLK *)(vciCodecMblk->hCodecMblk);

  00059	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0005c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0005f	89 45 fc	 mov	 DWORD PTR _pDecMemBlk$[ebp], eax

; 683  : 
; 684  :    vciCodecMblk->dwVciChunkID=0;

  00062	8b 4d f8	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00065	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 685  : 
; 686  :    VoxfreeFadeSC(&pDecMemBlk->pFadeIOMemBlk);

  0006b	8b 55 fc	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 _VoxfreeFadeSC@4

; 687  : 
; 688  :    VOX_MEM_FREE(pDecMemBlk->pbSaveVoxBuffer);

  00074	8b 45 fc	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  00077	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0007b	74 19		 je	 SHORT $L2413
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00080	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 _free
  00089	83 c4 04	 add	 esp, 4
  0008c	8b 45 fc	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  0008f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L2413:

; 689  : 
; 690  :    VoxFreeDecodeSC3(&vciCodecMblk->hCodecMblk);

  00096	8b 4d f8	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00099	83 c1 10	 add	 ecx, 16			; 00000010H
  0009c	51		 push	 ecx
  0009d	e8 00 00 00 00	 call	 _VoxFreeDecodeSC3@4

; 691  : 
; 692  :    vemFree(vciCodecMblk->pvemMemBlk);

  000a2	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000a5	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _vemFree@4

; 693  : 
; 694  :    freeMethodStruct(&vciCodecMblk->pVciMethodStruct);

  000ae	8b 4d f8	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000b1	83 c1 24	 add	 ecx, 36			; 00000024H
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 _freeMethodStruct@4

; 695  : 
; 696  :    STACK_UNSET(vciCodecMblk->pScratchBlk)
; 697  : 
; 698  :    VOX_MEM_FREE(vciCodecMblk);

  000ba	83 7d f8 00	 cmp	 DWORD PTR _vciCodecMblk$[ebp], 0
  000be	74 13		 je	 SHORT $L2415
  000c0	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000c3	52		 push	 edx
  000c4	e8 00 00 00 00	 call	 _free
  000c9	83 c4 04	 add	 esp, 4
  000cc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0
$L2415:

; 699  : 
; 700  :   return VCI_NO_ERROR;

  000d3	66 33 c0	 xor	 ax, ax
$L2401:

; 701  : }

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 04 00	 ret	 4
_vciFreeDecodeSC3@4 ENDP
_TEXT	ENDS
PUBLIC	_vciGetExtCompatibilitySC3@4
; Function compile flags: /Odt
;	COMDAT _vciGetExtCompatibilitySC3@4
_TEXT	SEGMENT
_pCompatFunc$ = 8
_vciGetExtCompatibilitySC3@4 PROC NEAR			; COMDAT

; 734  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 735  :    *((COMPATIBILITY_FUNCTION **)pCompatFunc)=&SC3CompatibilityFunc;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pCompatFunc$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_SC3CompatibilityFunc@8

; 736  : 
; 737  :    return VCI_NO_ERROR;

  0000c	66 33 c0	 xor	 ax, ax

; 738  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
_vciGetExtCompatibilitySC3@4 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _SC3CompatibilityFunc@8
_TEXT	SEGMENT
tv65 = -8
_vem_compatibility_ID$ = -4
_VemPlugin$ = 8
_pVemCodID$ = 12
_SC3CompatibilityFunc@8 PROC NEAR			; COMDAT

; 771  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 772  :    unsigned short vem_compatibility_ID;
; 773  : 
; 774  :    *pVemCodID=(unsigned long)VOXWARE_CODEC_SC_8K_3;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _pVemCodID$[ebp]
  00009	c7 00 03 00 00
	03		 mov	 DWORD PTR [eax], 50331651 ; 03000003H

; 775  :    
; 776  :    switch(VemPlugin) {

  0000f	0f b7 4d 08	 movzx	 ecx, WORD PTR _VemPlugin$[ebp]
  00013	89 4d f8	 mov	 DWORD PTR tv65[ebp], ecx
  00016	83 7d f8 01	 cmp	 DWORD PTR tv65[ebp], 1
  0001a	74 0e		 je	 SHORT $L2432
  0001c	83 7d f8 02	 cmp	 DWORD PTR tv65[ebp], 2
  00020	74 10		 je	 SHORT $L2434
  00022	83 7d f8 04	 cmp	 DWORD PTR tv65[ebp], 4
  00026	74 12		 je	 SHORT $L2436
  00028	eb 18		 jmp	 SHORT $L2438
$L2432:

; 777  :       case COMPATIBILITY_VFONT:
; 778  :         vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_VFONT;

  0002a	66 c7 45 fc 14
	00		 mov	 WORD PTR _vem_compatibility_ID$[ebp], 20 ; 00000014H

; 779  :         break;

  00030	eb 16		 jmp	 SHORT $L2429
$L2434:

; 780  : 
; 781  :       case COMPATIBILITY_VAD_AGC:
; 782  :         vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_VAD_AGC;

  00032	66 c7 45 fc 14
	00		 mov	 WORD PTR _vem_compatibility_ID$[ebp], 20 ; 00000014H

; 783  :         break;

  00038	eb 0e		 jmp	 SHORT $L2429
$L2436:

; 784  : 
; 785  :       case COMPATIBILITY_PLUS: 
; 786  :         vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_PLUS;

  0003a	66 c7 45 fc 14
	00		 mov	 WORD PTR _vem_compatibility_ID$[ebp], 20 ; 00000014H

; 787  :         break;

  00040	eb 06		 jmp	 SHORT $L2429
$L2438:

; 788  : 
; 789  :       default:
; 790  :         vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_DEFAULT;

  00042	66 c7 45 fc 00
	00		 mov	 WORD PTR _vem_compatibility_ID$[ebp], 0
$L2429:

; 791  :    }
; 792  : 
; 793  :    return vem_compatibility_ID;

  00048	66 8b 45 fc	 mov	 ax, WORD PTR _vem_compatibility_ID$[ebp]

; 794  : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
_SC3CompatibilityFunc@8 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _initMethodStruct@4
_TEXT	SEGMENT
_hVciMethodStruct$ = 8
_initMethodStruct@4 PROC NEAR				; COMDAT

; 827  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 828  :    if(VOX_MEM_INIT(*hVciMethodStruct,1,sizeof(VCI_METHOD_STRUCT)))

  00003	6a 1c		 push	 28			; 0000001cH
  00005	6a 01		 push	 1
  00007	e8 00 00 00 00	 call	 _calloc
  0000c	83 c4 08	 add	 esp, 8
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _hVciMethodStruct$[ebp]
  00012	89 01		 mov	 DWORD PTR [ecx], eax
  00014	8b 55 08	 mov	 edx, DWORD PTR _hVciMethodStruct$[ebp]
  00017	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0001a	75 06		 jne	 SHORT $L2444

; 829  :       return 1;

  0001c	66 b8 01 00	 mov	 ax, 1
  00020	eb 56		 jmp	 SHORT $L2442
$L2444:

; 830  : 
; 831  :    (*hVciMethodStruct)->pfVciGetInfo=vciGetInfoSC3;

  00022	8b 45 08	 mov	 eax, DWORD PTR _hVciMethodStruct$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:_vciGetInfoSC3@4

; 832  : 
; 833  : #ifndef DECODE_ONLY
; 834  :    (*hVciMethodStruct)->pfVciEncode=vciEncodeSC3;

  0002d	8b 55 08	 mov	 edx, DWORD PTR _hVciMethodStruct$[ebp]
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET FLAT:_vciEncodeSC3@8

; 835  :    (*hVciMethodStruct)->pfVciInitEncode=vciInitEncodeSC3;

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _hVciMethodStruct$[ebp]
  0003c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], OFFSET FLAT:_vciInitEncodeSC3@4

; 836  :    (*hVciMethodStruct)->pfVciFreeEncode=vciFreeEncodeSC3;

  00045	8b 45 08	 mov	 eax, DWORD PTR _hVciMethodStruct$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET FLAT:_vciFreeEncodeSC3@4

; 837  : #endif
; 838  : 
; 839  :    (*hVciMethodStruct)->pfVciDecode=vciDecodeSC3;

  00051	8b 55 08	 mov	 edx, DWORD PTR _hVciMethodStruct$[ebp]
  00054	8b 02		 mov	 eax, DWORD PTR [edx]
  00056	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET FLAT:_vciDecodeSC3@8

; 840  :    (*hVciMethodStruct)->pfVciInitDecode=vciInitDecodeSC3; 

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _hVciMethodStruct$[ebp]
  00060	8b 11		 mov	 edx, DWORD PTR [ecx]
  00062	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], OFFSET FLAT:_vciInitDecodeSC3@4

; 841  :    (*hVciMethodStruct)->pfVciFreeDecode=vciFreeDecodeSC3;

  00069	8b 45 08	 mov	 eax, DWORD PTR _hVciMethodStruct$[ebp]
  0006c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006e	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET FLAT:_vciFreeDecodeSC3@4

; 842  : 
; 843  :    return 0;

  00075	66 33 c0	 xor	 ax, ax
$L2442:

; 844  : }

  00078	5d		 pop	 ebp
  00079	c2 04 00	 ret	 4
_initMethodStruct@4 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _freeMethodStruct@4
_TEXT	SEGMENT
_hVciMethodStruct$ = 8
_freeMethodStruct@4 PROC NEAR				; COMDAT

; 874  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  :    if(hVciMethodStruct)

  00003	83 7d 08 00	 cmp	 DWORD PTR _hVciMethodStruct$[ebp], 0
  00007	74 1f		 je	 SHORT $L2448

; 876  :       VOX_MEM_FREE(*hVciMethodStruct);

  00009	8b 45 08	 mov	 eax, DWORD PTR _hVciMethodStruct$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 17		 je	 SHORT $L2448
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _hVciMethodStruct$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 _free
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b 45 08	 mov	 eax, DWORD PTR _hVciMethodStruct$[ebp]
  00022	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L2448:

; 877  : 
; 878  :    return 0;

  00028	66 33 c0	 xor	 ax, ax

; 879  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
_freeMethodStruct@4 ENDP
_TEXT	ENDS
END
