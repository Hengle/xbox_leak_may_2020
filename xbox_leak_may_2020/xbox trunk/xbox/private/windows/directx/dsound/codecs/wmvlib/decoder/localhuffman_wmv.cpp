/*************************************************************************

Copyright (c) 1996 -- 2000  Microsoft Corporation

Module Name:

	localHuffman.cpp

Abstract:

	Local Huffman code generator.

Revision History:

    Sridhar Srinivasan: 3/16/00

*************************************************************************/
#include "bldsetup.h"

#include "xplatform.h"
#include "typedef.hpp"
#include "wmvdec_api.h"
#include "localhuffman_wmv.h"
#include "wmvdec_function.h"

// fineTbl counts bit for "last"
static const U8_WMV fineTbl[] = {
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,
    /* L0 */ 3,3, 2,3, 5,4,  2,2,2,3,3,  2,3,
    /* L1 */ 2,2,2,2,4,4, 2,3,4,  2,3,4,  2,3,
    /* Q0 */ 5, 5, 11, 14
};

static const U8_WMV fineTblJoint[] = {0,1,1,1,1, 2,2, 3,3, 4,4, 5,5, 6,6, 7,7,
                     0,1,1,1,1, 2,2, 3,3, 4,4, 5,5, 6,6, 7,7};

static const I32_WMV iLaplacianAlphabet = 17;
static const U8_WMV aNulls[]={0,0,0,0,0,0,0,0,0,0,0,0};
static const U8_WMV gacCodeLengthsJoint[]={
                3,3,4,5,6,6,7,8,8,9,10,12,13,13,13,13,13,
                2,2,4,5,8,8,9,10,13,13,13,13,13,13,13,13,13};

/**********************************************************************
 generateHuffman_balanced : generates optimum huffman code lengths
 for balanced codeword lengths
 Maximum codeword length allowed = 20
**********************************************************************/

static Void_WMV generateHuffman_balanced(tPackHuffmanCode_WMV *pCodeTable, I32_WMV iN)
{
    pCodeTable->code = iN;
    pCodeTable++;

    const I32_WMV iMaxLength = 20;
    I32_WMV  iLowest = 0;
    I32_WMV  pNextCode[iMaxLength];
    // set all next codes to 0
    memset (pNextCode, 0, sizeof(pNextCode));
    pNextCode[0] = 1 << iMaxLength;
 
    for (I32_WMV i = 0; i < iN; i++) {

        // first set output codeword
        I32_WMV  iLen, iCode, iNewCode;
        iLen = pCodeTable->length;
        iCode = pNextCode[iLen];
        // actual codeword is shifted appropriately
        pCodeTable->code = iCode >> (iMaxLength - iLen);
        pCodeTable++;

        // test last bit : if 1, set to next shorter code
        I32_WMV  iLSB = 1 << (iMaxLength - iLen);
        if (iCode & iLSB)
            iNewCode = pNextCode[iLen - 1];
        else
            iNewCode = iCode + iLSB;

        pNextCode[iLen] = iNewCode;
        if (iNewCode == (1 << iMaxLength))
            iLowest = iLen;

        // for all shorter codewords, check if same - add
        for (I32_WMV j = iLen - 1; j > iLowest; j--) {
            if (pNextCode[j] != iCode)
                break;

            iLSB <<= 1;
            if (pNextCode[j] & iLSB)
                pNextCode[j] = pNextCode[j - 1];
            else
                pNextCode[j] += iLSB;

            if (pNextCode[j] == (1 << iMaxLength))
                iLowest = j;
        }

        // for all longer codewords, check if same - add
        for (j = iLen + 1; j < iMaxLength; j++) {
            if (pNextCode[j] != iCode)
                break;
            pNextCode[j] = iNewCode;
        }
    }
}

U8_WMV zigzagArray[]={0,2,0,1, 1,1,0,2, 2,0, 1,2};

/**********************************************************************************
  Code length arrays : packed arrays
  Author:   Sridhar Srinivasan
  Updated:  4/20/2001
**********************************************************************************/
static U8_WMV gacCodeLengthsOrientLowRate[] = {
1,
0x11,0x22,0x52,0x54,0x55,0x55,
0x10,0x42,0x64,0x65,0x66,0x66,
};

static U8_WMV gacCodeLengthsOrientHighRate[] = {
2,
0x20,0x32,0x53,0x54,0x55,0x55,
0x44,0x14,0x31,0x24,0x33,0x44,
0x11,0x22,0x52,0x45,0x55,0x55,
0x32,0x13,0x41,0x34,0x44,0x44,
};

static U8_WMV gacCodeLengthsInterLowRate[] = {
3,
0x32,0x55,0x56,0x7e,0x8e,0x8e,0xee,0xde,0x54,0x88,0x66,0x18,0x32,0x43,0x75,0x56,0x76,0x6d,0x66,0x48,0x85,0x87,0xd8,0xdd,0xd7,0xdd,0xdd,0xdd,0xdd,0x8d,0xdd,0xdd,0xdd,0xd8,0xd8,0xdd,0x8d,0xdd,0x2d,
0x32,0x43,0x55,0x55,0x76,0x77,0xd7,0x99,0x43,0x65,0x54,0x34,0x44,0x55,0x55,0x65,0x77,0x66,0x66,0x67,0x76,0x77,0x9d,0xd8,0x84,0xdd,0x74,0xdd,0x5d,0x67,0x87,0xd7,0x7d,0xd8,0xdd,0x8d,0x4d,0x87,0x3d,
0x43,0xbb,0xbb,0xbb,0xbb,0xbb,0xaa,0xaa,0xaa,0xaa,0xaa,0xa,0x41,0x44,0xaa,0xaa,0xaa,0xaa,0xaa,0x4a,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0x7a,
0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x7,0x67,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x86,
0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x17,0x70,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x97,
0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x88,0x8,0x82,0x18,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x18,
0x31,0x44,0x55,0x76,0x77,0x88,0x89,0xe9,0x42,0x55,0x63,0x44,0x66,0x76,0x66,0x77,0x77,0x77,0x87,0x77,0x87,0x9e,0x99,0x9e,0x85,0xee,0x53,0xe9,0x5d,0xd7,0xd9,0xdd,0x7d,0x99,0xdd,0xdd,0x4d,0xd9,0x2d,
0x32,0x44,0x75,0x56,0xc6,0x77,0xcc,0x7c,0x43,0x56,0x65,0x25,0x44,0x53,0x55,0x74,0x55,0x55,0x77,0x46,0x66,0x6c,0xc7,0xcc,0x66,0xcc,0xc7,0xcc,0x7c,0x6c,0xc7,0xcc,0x7c,0xcc,0xcc,0x7c,0x5b,0xbb,0xfb,
};

static U8_WMV gacCodeLengthsInterHighRate[] = {
3,
0x21,0x43,0x65,0x66,0x78,0x77,0x99,0x99,0x63,0x98,0x65,0x36,0x43,0x44,0x55,0x55,0x66,0x66,0x66,0x76,0x98,0xdd,0xdd,0xd9,0xd8,0xdd,0xd7,0xdd,0x9d,0x6d,0x77,0xd8,0xdd,0xdd,0xdd,0xdd,0xcc,0xcc,0x2c,
0x42,0x56,0x75,0x77,0xdd,0xd6,0xdd,0xdd,0x75,0x7d,0xdd,0x1d,0x42,0x33,0x53,0x66,0x66,0x67,0x55,0x55,0xd7,0x77,0xd7,0xdd,0xd7,0xdd,0xcc,0xcc,0xcc,0x5c,0xcc,0xcc,0x6c,0xcc,0xcc,0xcc,0xcc,0xcc,0x1c,
0x21,0x32,0x44,0x55,0x66,0x76,0x77,0x98,0x53,0x87,0x85,0x47,0x55,0x65,0x66,0x66,0x66,0x66,0x66,0xf7,0xef,0xeb,0xee,0x97,0xb8,0xee,0xe7,0xee,0x8e,0x6e,0x77,0xba,0xee,0xee,0xee,0xee,0x8e,0xee,0x1e,
0x21,0x43,0x54,0x65,0x76,0x87,0x88,0x99,0x42,0x66,0x63,0x54,0x66,0x76,0x77,0x77,0x87,0x77,0x87,0x9a,0xea,0xe9,0xee,0xa8,0xb6,0xee,0x64,0x97,0x6a,0x79,0x97,0xb9,0xae,0xee,0xee,0xee,0x6e,0xbd,0x2b,
0x32,0x43,0x55,0x65,0x65,0x77,0x87,0x78,0x43,0x55,0x53,0x44,0x55,0x55,0x55,0x65,0x66,0x66,0x76,0x6a,0x76,0x88,0x98,0x98,0x75,0xee,0x63,0xe8,0x5e,0x69,0x77,0x89,0x8e,0x99,0xe9,0xdd,0x4d,0xd8,0x1d,
0x31,0x44,0x55,0x76,0x77,0xa8,0x97,0xea,0x42,0x65,0x53,0x54,0x76,0x76,0x76,0x76,0x87,0x88,0x88,0x8a,0xa9,0x9e,0xaa,0xa9,0x75,0xee,0x43,0x66,0x58,0x77,0xa9,0x9e,0x9e,0xe9,0xde,0xdd,0x4d,0xa9,0x18,
0x31,0x54,0x75,0x98,0x89,0xee,0xe9,0xe9,0x43,0x77,0x84,0x27,0x32,0x54,0x65,0x66,0x77,0x78,0xe9,0x58,0x85,0x79,0x97,0xee,0xe8,0xee,0xe7,0xee,0x8e,0x8e,0xee,0xee,0x9e,0xe9,0xee,0xee,0x7e,0xdd,0x3d,
0xa3,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0x9a,0x99,0x99,0x9,0x91,0x33,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0xf9,
};

static U8_WMV gacCodeLengthsIntraLowRate[] = {
3,
0x32,0x44,0x44,0x65,0x65,0x67,0x76,0x87,0x53,0x65,0x74,0x35,0x43,0x55,0x55,0x66,0x66,0x66,0x66,0x66,0x86,0x88,0x8a,0x75,0x64,0x88,0x96,0xdd,0x6d,0x69,0x87,0x67,0x6d,0x96,0xd9,0x9d,0x5d,0x78,0x1d,
0x31,0x44,0x65,0x66,0x87,0x88,0xe8,0xa9,0x42,0x65,0x43,0x53,0x66,0x77,0x76,0x78,0x88,0x88,0xa9,0x8a,0xa8,0x9e,0xee,0xee,0x75,0xee,0x63,0xa7,0x4e,0xa7,0xe9,0xee,0x8e,0xde,0xdd,0xdd,0x4d,0xdd,0x2d,
0x32,0x43,0x65,0x65,0x88,0xe7,0xe8,0xee,0x42,0x66,0x53,0x34,0x43,0x55,0x55,0x76,0x76,0x79,0x98,0x59,0x86,0x78,0x89,0xee,0x86,0xee,0x74,0xdd,0x5d,0x88,0x99,0xdd,0x7d,0xdd,0xd9,0x8d,0x5d,0x87,0x2d,
0x32,0x44,0x55,0x66,0x55,0x66,0x88,0x76,0x54,0x68,0x65,0x26,0x42,0x54,0x55,0x66,0x77,0x77,0x56,0x66,0x75,0xd8,0xdd,0x86,0x76,0xdd,0xd7,0xcc,0x7c,0x5c,0x86,0x65,0x6c,0xc6,0xcc,0xcc,0x7c,0x8c,0x1c,
0x31,0x44,0x55,0x66,0x76,0x88,0x99,0xe9,0x42,0x65,0x53,0x35,0x54,0x55,0x66,0x66,0x77,0x77,0x77,0x69,0x87,0x98,0xb9,0xb9,0x75,0xee,0x85,0xee,0x6e,0x9b,0xe9,0xab,0x7e,0xe8,0xeb,0xee,0x5d,0xab,0x2d,
0x32,0x43,0x54,0x76,0x8a,0x9a,0xea,0xee,0x43,0x65,0x64,0x25,0x43,0x44,0x54,0x65,0x77,0x67,0x87,0x4a,0x76,0x67,0x89,0xe8,0xe6,0xee,0xa6,0xde,0x6d,0x8d,0x99,0xd8,0x7d,0xda,0xdd,0x8d,0x6d,0xd8,0x2d,
0x32,0x43,0x44,0x54,0x46,0xc6,0xc6,0xc6,0x53,0x66,0x64,0x54,0x65,0x65,0xc6,0x66,0xcc,0x6b,0xb6,0x6b,0xbb,0xbb,0xbb,0x54,0x43,0x6b,0xb4,0xbb,0x5b,0x5b,0xbb,0xbb,0x5b,0xbb,0xbb,0xbb,0x4b,0x6b,0x2b,
0x32,0x54,0x75,0x77,0xea,0xee,0xee,0xee,0x53,0x86,0x74,0x17,0x42,0x44,0x55,0x77,0x78,0x76,0xa8,0x4e,0x76,0x78,0x88,0xee,0x97,0xee,0xe7,0xee,0x8e,0x7e,0xe8,0xee,0x8e,0xee,0xee,0x9e,0x6d,0xd8,0xfd,
};

static U8_WMV gacCodeLengthsIntraHighRate[] = {
3,
0x32,0x43,0x65,0x75,0x87,0x89,0x88,0xae,0x43,0x65,0x64,0x24,0x43,0x44,0x54,0x65,0x77,0x77,0x87,0x59,0x76,0x77,0x9a,0xea,0xd6,0xdd,0x95,0xdd,0x6d,0x7d,0xa8,0xa9,0x7d,0xd9,0xdd,0xdd,0x5d,0xa8,0x1d,
0x21,0x43,0x55,0x76,0x77,0x88,0xaa,0xaa,0x42,0x65,0x53,0x73,0x98,0x98,0xb9,0x99,0x99,0xba,0xb9,0xeb,0xee,0xde,0xdd,0xaa,0x97,0xdb,0x53,0x76,0x59,0xa7,0xd9,0xba,0xdd,0xdd,0xdd,0xdd,0x5d,0xaa,0x29,
0x32,0x54,0x76,0x77,0x89,0x99,0x9f,0xf9,0x42,0x75,0x42,0x63,0x88,0x88,0x98,0x99,0x99,0x89,0xa9,0x9f,0x9a,0x9a,0xaf,0xee,0x86,0xee,0x32,0x55,0x47,0xe6,0xee,0xae,0xae,0xaa,0xee,0xee,0x4e,0x7a,0x17,
0x21,0x33,0x44,0x55,0x55,0x66,0x77,0x87,0x53,0x86,0x75,0x56,0x55,0x55,0x66,0x66,0x66,0x66,0x77,0xa8,0xe9,0xee,0xee,0x76,0xb7,0xe8,0x86,0xee,0x7e,0x5a,0x76,0x67,0xa8,0xea,0xee,0xdd,0x7d,0xdd,0x1d,
0x31,0x54,0x65,0x76,0x77,0x88,0x99,0xbd,0x42,0x65,0x53,0x44,0x55,0x65,0x76,0x76,0x77,0x77,0x98,0x69,0x87,0x98,0x8a,0x98,0x76,0xbb,0x53,0x77,0x58,0x87,0x99,0x9a,0x8a,0xa8,0xda,0xad,0x5d,0x88,0x19,
0x21,0x43,0x54,0x65,0x66,0x77,0x87,0x89,0x42,0x76,0x64,0x45,0x65,0x66,0x77,0x76,0x77,0x77,0x87,0xa8,0xbb,0xce,0xee,0x87,0x97,0xc8,0x64,0x88,0x6e,0x7a,0x77,0x78,0xba,0xec,0xee,0xee,0x6e,0xad,0x2a,
0x32,0x43,0x54,0x65,0x77,0x87,0x88,0xba,0x42,0x65,0x53,0x34,0x54,0x65,0x66,0x66,0x76,0x77,0x78,0x69,0x87,0x8a,0xb9,0xe8,0x65,0xee,0x64,0xa8,0x5e,0x78,0x98,0xa9,0x7e,0xe8,0xee,0xdd,0x4d,0x89,0x1d,
0x31,0x54,0x66,0x77,0x88,0x98,0xee,0xee,0x42,0x65,0x53,0x73,0x87,0x89,0x89,0x99,0x9e,0xaa,0x9e,0x8e,0xea,0xae,0xea,0xea,0x96,0xee,0x42,0x66,0x48,0x86,0xea,0xdd,0x8d,0xd8,0xdd,0xdd,0x4d,0x7a,0xf9,
};

// Joint Laplacian coding for DCT DC components
static U8_WMV gacCodeLengthsDCHighRate[]={
3,
0x34,0x44,0x44,0x55,0x77,0xcc,0xcc,0xcc,0x1c,0x21,0x43,0x75,0xc8,0xcc,0xcc,0xcc,0xcc,
0x23,0x32,0x23,0x23,0x33,0x54,0x88,0xcc,0x5c,0x55,0x86,0x76,0xc8,0xcc,0xbb,0xb8,0xbb,
0x23,0x32,0x33,0x33,0x55,0x66,0xbb,0xbb,0x3b,0x32,0x54,0x65,0xb7,0xbb,0xbb,0xbb,0xaa,
0x13,0x22,0x22,0x33,0x55,0x76,0xdd,0xdd,0x8c,0x76,0xc7,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,
0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x6,0x61,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
0x34,0x54,0x55,0x56,0x56,0x67,0xc7,0xcc,0x2c,0x20,0x76,0xc8,0xcc,0xcc,0xcc,0xcc,0xbc,
0x13,0x22,0x33,0x54,0x66,0xd7,0x9d,0xd8,0x3d,0x42,0x75,0xd7,0xdd,0xdd,0xdd,0xdd,0xcd,
0x55,0x65,0x56,0x55,0x76,0x87,0xd9,0xdd,0xd,0x31,0x54,0x76,0xdd,0xdd,0xdd,0xdd,0xcc,
};

static U8_WMV gacCodeLengthsDCLowRate[] = {
3,
0x34,0x43,0x34,0x44,0x66,0xbb,0xbb,0xbb,0x2b,0x21,0x43,0x64,0xb7,0xbb,0xbb,0xbb,0xbb,
0x22,0x32,0x23,0x33,0x65,0xa6,0xaa,0xaa,0x5a,0x43,0x54,0x64,0xa6,0xa6,0xaa,0xaa,0x99,
0x66,0x65,0x65,0x77,0xcc,0xcc,0xcc,0xcc,0xb,0x21,0x54,0xb7,0xbb,0xbb,0xbb,0xbb,0xbb,
0x23,0x32,0x23,0x22,0x44,0xa6,0xaa,0xaa,0x4a,0x56,0x65,0x66,0xa6,0xaa,0xa6,0xaa,0x99,
0x67,0x66,0x78,0xd8,0xdd,0xdd,0xdd,0xcd,0x1c,0x20,0x53,0x86,0xcc,0xcc,0xcc,0xcc,0xcc,
0x66,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x5,0x55,0x55,0x55,
0x34,0x44,0x45,0x55,0x77,0xcc,0xcc,0xcc,0x1c,0x21,0x43,0x74,0xc8,0xcc,0xcc,0xcc,0xcc,
0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x6,0x61,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
};

/**********************************************************************
 CLocalHuffmanDecoder : definition
**********************************************************************/
typedef struct t_LocalHuffmanDecoder
{
    t_AltTablesDecoder  *m_pAltTable;

    I32_WMV  m_iN;  // number of symbols inc escapes
    const U8_WMV *m_pFine;
    I32_WMV  m_iMode;
    I32_WMV  m_i1shiftMode;
    I32_WMV  m_iK;  // number of codeword tables
    I32_WMV  logK;
    U8_WMV   *opt;
    U8_WMV   *m_pCodeTablePtr;

    I32_WMV  *fineMask;
    Huffman_WMV  *m_pHuff;
    tPackHuffmanCode_WMV      *m_pCodeTable;

} t_CLocalHuffmanDecoder;

/**********************************************************************
  setCodes : setting local huffman codes based on QP
**********************************************************************/

static Void_WMV LhdecSetCodes (t_LocalHuffmanDecoder *pLhdec, I32_WMV inQP)
{
    // inter code tables
    if (pLhdec->m_iMode == LH_INTER0 || pLhdec->m_iMode == LH_INTER) {
        pLhdec->opt = (inQP < 13) ? gacCodeLengthsInterHighRate : gacCodeLengthsInterLowRate;
    }
    // intra code tables
    else if (pLhdec->m_iMode == LH_INTRAY0 || pLhdec->m_iMode == LH_INTRAY) {
        pLhdec->opt = (inQP < 13) ? gacCodeLengthsIntraHighRate : gacCodeLengthsIntraLowRate;
    }
    // Orientation tables
    else if (pLhdec->m_iMode == LH_ORIENT) {
        pLhdec->opt = (inQP < 13) ? gacCodeLengthsOrientHighRate : gacCodeLengthsOrientLowRate;
    }
    // DCT DC code tables
    else if (pLhdec->m_iMode > LH_ORIENT) {  // DCT DC codes
        pLhdec->opt = (inQP < 13) ? gacCodeLengthsDCHighRate : gacCodeLengthsDCLowRate;
    }

    pLhdec->m_iK = 1 << (pLhdec->logK = *pLhdec->opt++);
}

/**********************************************************************
 CLocalHuffmanDecoder : constructor
**********************************************************************/

static t_LocalHuffmanDecoder *LhdecConstruct (I32_WMV iMode,
                                              t_AltTablesDecoder *pAlt)
{
    t_LocalHuffmanDecoder *pLhdec = (t_LocalHuffmanDecoder *)
        wmvalloc (sizeof(t_LocalHuffmanDecoder));
    if (pLhdec == NULL_WMV)
        return NULL_WMV;
    DEBUG_HEAP_ADD(DHEAP_LOCALHUFF,sizeof(t_LocalHuffmanDecoder));

    pLhdec->m_pAltTable  = pAlt;
    pLhdec->m_pHuff = (Huffman_WMV *)wmvalloc(sizeof( Huffman_WMV));// Set Huffman object
    DEBUG_HEAP_ADD(DHEAP_LOCALHUFF,sizeof(t_LocalHuffmanDecoder));

    Huffman_WMV_construct(pLhdec->m_pHuff );

    pLhdec->m_iMode = iMode;  // no checks
    pLhdec->m_i1shiftMode = 1 << pLhdec->m_iMode;

    if (iMode < LH_ORIENT) {
        pLhdec->m_pFine = fineTbl;
        pLhdec->m_iN = X1+1;
    }
    else if (iMode == LH_ORIENT) {
        pLhdec->m_pFine = aNulls;
        pLhdec->m_iN = 12; /* number of orientations */
    }
    else {
        pLhdec->m_pFine = fineTblJoint;
        pLhdec->m_iN = iLaplacianAlphabet << 1;
    }

    pLhdec->m_pCodeTable = (tPackHuffmanCode_WMV *)
        wmvalloc ((pLhdec->m_iN + 2) * sizeof (tPackHuffmanCode_WMV));
    pLhdec->fineMask = (I32_WMV *) wmvalloc (pLhdec->m_iN * sizeof (I32_WMV));
    pLhdec->m_pCodeTablePtr = NULL_WMV;  // no table initialized
    DEBUG_HEAP_ADD(DHEAP_LOCALHUFF, ((pLhdec->m_iN + 2) * sizeof (tPackHuffmanCode_WMV)) + (pLhdec->m_iN * sizeof (I32_WMV)));

    // reset fineMask
    for (I32_WMV j = 0; j < pLhdec->m_iN; j++)
        pLhdec->fineMask[j] = (1 << pLhdec->m_pFine[j]) - 1;

    return pLhdec;
}

/**********************************************************************
 CLocalHuffmanDecoder : destructor
**********************************************************************/

static Void_WMV  LhdecDestruct (t_LocalHuffmanDecoder *pLhdec)
{
    if ( pLhdec != NULL_WMV ) {
        DEBUG_HEAP_SUB(DHEAP_LOCAL_COUNT,1); // count number of tables actually freed
        DEBUG_HEAP_SUB(DHEAP_LOCALHUFF,sizeof(t_LocalHuffmanDecoder)+sizeof(t_LocalHuffmanDecoder)+((pLhdec->m_iN + 2) * sizeof (tPackHuffmanCode_WMV)) + (pLhdec->m_iN * sizeof (I32_WMV)));
        Huffman_WMV_destruct(pLhdec->m_pHuff);
        if ( pLhdec->m_pHuff != NULL_WMV )
            wmvfree ( pLhdec->m_pHuff );
        if (pLhdec->m_pCodeTable != NULL_WMV )
            wmvfree (pLhdec->m_pCodeTable);
        if (pLhdec->fineMask != NULL_WMV )
            wmvfree (pLhdec->fineMask);
        wmvfree (pLhdec);
    }
}

/**********************************************************************
 CLocalHuffman::decodeHeader : decode header
**********************************************************************/

static Void_WMV LhdecDecodeHeader(t_LocalHuffmanDecoder *pLhdec,
                                  CInputBitStream_WMV* pin)
{
    I32_WMV  iCodeIndex = 0;
    FUNCTION_PROFILE_DECL_START(fp,DECODEIX8LHHEADER_PROFILE);

#ifdef LH_FULL_COMPLEXITY
    if ((pLhdec->m_pAltTable->m_iNewIntraFrame & pLhdec->m_i1shiftMode) == 0)
        iCodeIndex = 0;
    pLhdec->m_pAltTable->m_iNewIntraFrame |= pLhdec->m_i1shiftMode;

    if (pLhdec->m_iK > 1) {  // bit is sent only if multiple codetables exist
        if (pLhdec->m_pAltTable->m_bIntraFrame // Intra frame, or
            || BS_getBit(pin)) {  // there's a change in check bit
            iCodeIndex = BS_getBits(pin, pLhdec->logK);
#ifdef VERBOSE
        printf("[%d:%d_%d] ", pLhdec->m_iMode, iCodeIndex, pLhdec->logK);  // whether or not change
#endif  // VERBOSE
        }
    }
#else // default - used in WMV8
    iCodeIndex = BS_getBits(pin, pLhdec->logK);
#endif // LH_FULL_COMPLEXITY

    U8_WMV  *pLengths = pLhdec->opt + iCodeIndex * ((pLhdec->m_iN + 1) >> 1);
    if (pLhdec->m_pCodeTablePtr == pLengths) {
        FUNCTION_PROFILE_STOP(&fp);
        return;
    }
    pLhdec->m_pCodeTablePtr = pLengths;

    for (I32_WMV i = 0; i < pLhdec->m_iN; i++) {
        U8_WMV  c = *pLengths++;
        pLhdec->m_pCodeTable[i + 1].length = (c & 0xf) + 1;
        i++;
        pLhdec->m_pCodeTable[i + 1].length = ((c >> 4) & 0xf) + 1;
    }

    generateHuffman_balanced (pLhdec->m_pCodeTable, pLhdec->m_iN);
    /** reinitialize huffman table **/
    //pLhdec->m_pHuff->init(pLhdec->m_pAltTable->m_uiUserData, pLhdec->m_pCodeTable);
    DEBUG_HEAP_ADD(DHEAP_LOCAL_COUNT,1); // count number of tables actually allocated
    DEBUG_HEAP_ADD(DHEAP_LOCALHUFF,0);  // indicate this huffman table is for localHuffman
    Huffman_WMV_init ( pLhdec->m_pHuff, pLhdec->m_pAltTable->m_uiUserData, pLhdec->m_pCodeTable, NULL, 3);
    FUNCTION_PROFILE_STOP(&fp);
}

/**********************************************************************
 CLocalHuffman::if2rll : converts index, fine into run, level, last
**********************************************************************/
static const I8_WMV gOff0[]={16,24, 4,8, 32,16, 4,8,12,16,24, 3,7};
static const I8_WMV gOff1[]={16,20,24,28,32,48, 4,8,16, 4,8,16, 3,7};

static inline Void_WMV if2rll(I32_WMV iIndex, I32_WMV iFine, U32_WMV &uRun,
                          I32_WMV &iLevel, I32_WMV &bLast, I32_WMV *pFineMask)
{
    if (iIndex < L0a) {
        if (iIndex < (L0a>>1))  bLast=0;
        else {
            bLast=1;
            iIndex -= (L0a>>1);
        }
        if (iIndex < 16) {
            iLevel = 0;
            uRun = iIndex;
        }
        else if (iIndex < 20) {
            iLevel = 1;
            uRun = iIndex-16;
        }
        else if (iIndex < 22) {
            iLevel = 2;
            uRun = iIndex-20;
        }
        else {
            iLevel = 3;
            uRun = 0;
        }
        return;
    }

    HUFFMANGET_DBG_CACHE(pFineMask,index,4);

    iFine &= pFineMask[iIndex];
    iLevel = 0;

    if (iIndex < L1a) {
        bLast=0;
        if (iIndex <= L0b)
            uRun = gOff0[iIndex-L0a]+iFine;
        else if (iIndex<=L0d) {
            iLevel = 1;
            uRun = gOff0[iIndex-L0a]+iFine;
        }
        else if (iIndex==L0e) {
            uRun = gOff0[iIndex-L0a]+iFine;
        }
        else if (iIndex==L0f) {
            iLevel = 1;
            uRun = gOff0[iIndex-L0a]+iFine;
        }
        else if (iIndex <= L0v) {
            uRun=0;
            iLevel = gOff0[iIndex-L0a]+iFine;
        }
        else {
            uRun=1;
            iLevel = gOff0[iIndex-L0a]+iFine;
        }
        return;
    }

    else if (iIndex < Q0) {
        bLast=1;
        if (iIndex <= L1f)
            uRun = gOff1[iIndex-L1a]+iFine;
        else if (iIndex <= L1i) {
            iLevel = 1;
            uRun = gOff1[iIndex-L1a]+iFine;
        }
        else if (iIndex <= L1x) {
            uRun=0;
            iLevel=gOff1[iIndex-L1a]+iFine;
        }
        else {
            uRun=1;
            iLevel=gOff1[iIndex-L1a]+iFine;
        }
        return;
    }

    else if (iIndex < X0) {  // funkyQ processing
        I32_WMV  which=iFine&0x3;
        iFine>>=2;
        bLast=iIndex-Q0;
        switch (which) {
        case 0:
            uRun=2;
            iLevel=2+iFine;
            break;
        case 1:
            uRun=3+iFine;
            iLevel=2;
            break;
        case 2:
            uRun=3+(iFine&1);
            iLevel=3+(iFine>>1);
            break;
        case 3:
            uRun=5+(iFine&3);
            iLevel=3+(iFine>>2);
            break;
        default:;
        }
        return;
    }

    uRun=0;
    bLast = iFine&1;
    I32_WMV hfine = (iFine>>1);

// X0 and X1
    uRun = hfine&0x3f;
    iLevel = hfine>>6;
}

/**********************************************************************
 CLocalHuffman::decodeSymbol : decode symbol (run, level, last)
 Return value: 1 : use legacy decoding
               0 : symbol already decoded
**********************************************************************/

I32_WMV LhdecDecodeSymbol (t_LocalHuffmanDecoder *pLhdec,
                           CInputBitStream_WMV* pbitstrmIn,
                           U32_WMV &uRun, I32_WMV &iLevel, I32_WMV &bLast)
{
/** if m_iNewFrame is true, decode the header and initialize Huffman **/
    if ((pLhdec->m_pAltTable->m_iNewFrame & pLhdec->m_i1shiftMode) == 0) {
        LhdecDecodeHeader(pLhdec, pbitstrmIn);
        pLhdec->m_pAltTable->m_iNewFrame |= pLhdec->m_i1shiftMode;
    }

    //I32_WMV  iIndex = pLhdec->m_pHuff->get (pbitstrmIn);
    I32_WMV  iIndex = Huffman_WMV_get (pLhdec->m_pHuff, pbitstrmIn);
    I32_WMV  iFine = pLhdec->m_pFine[iIndex];
    if (iFine)
        iFine = BS_getBits (pbitstrmIn, iFine);

    if2rll (iIndex, iFine, uRun, iLevel, bLast, pLhdec->fineMask);
    iLevel = iLevel + 1;
    iFine = - (I32_WMV) BS_getBit(pbitstrmIn);
    iLevel = (iLevel ^ iFine) - iFine; // conditional change sign

    return 0;
}

/**********************************************************************
  CLocalHuffman::decodeOrient :  decode orientation
**********************************************************************/

I32_WMV LhdecDecodeOrient (t_LocalHuffmanDecoder *pLhdec,
                           CInputBitStream_WMV *pbitstrmIn)
{
    // if m_iNewFrame is true, decode header and initialize Huffman
    if ((pLhdec->m_pAltTable->m_iNewFrame & pLhdec->m_i1shiftMode) == 0) {
        LhdecDecodeHeader (pLhdec, pbitstrmIn);
        pLhdec->m_pAltTable->m_iNewFrame |= pLhdec->m_i1shiftMode;
    }
   // return pLhdec->m_pHuff->get(pbitstrmIn);
    return Huffman_WMV_get (pLhdec->m_pHuff, pbitstrmIn);
}

/**********************************************************************
  if2ll : index-fine to level-last
**********************************************************************/

static const U8_WMV gIntervals[]={5,7, 9,13, 17,25, 33,49, 65,97, 129,193};

inline static Void_WMV if2ll (I32_WMV index, I32_WMV fine,
                              I32_WMV &level, I32_WMV &last)
{
    last=0;
    if (index >= iLaplacianAlphabet) {
        last++;
        index -= iLaplacianAlphabet;
    }
    if (index >= 5) {
        index = gIntervals[index - 5] + (fine >> 1);  // assumed that fine is masked
    }
    fine = -(fine & 1);
    level = (index ^ fine) - fine;
}

/**********************************************************************
  CLocalHuffman::decodeJoint :  decode DC value (level, last)
**********************************************************************/

I32_WMV LhdecDecodeJoint (t_LocalHuffmanDecoder *pLhdec,
                          CInputBitStream_WMV *pbitstrmIn)
{
/** if m_iNewFrame is true, decode the header and initialize Huffman **/
    if ((pLhdec->m_pAltTable->m_iNewFrame & pLhdec->m_i1shiftMode) == 0) {
        LhdecDecodeHeader (pLhdec, pbitstrmIn);
        pLhdec->m_pAltTable->m_iNewFrame |= pLhdec->m_i1shiftMode;
    }

/** read index **/
    I32_WMV iLevel, iLast, iFine; // iIndex = pLhdec->m_pHuff->get(pbitstrmIn);
    I32_WMV iIndex = Huffman_WMV_get (pLhdec->m_pHuff, pbitstrmIn);

    iFine = pLhdec->m_pFine[iIndex];
    if (iFine)
        iFine = BS_getBits(pbitstrmIn, iFine);
    if2ll(iIndex, iFine, iLevel, iLast);

    iLevel += iLevel;
    iLevel += iLast;
    return iLevel;
}

/**********************************************************************
 CAltTablesDecoder : constructor
**********************************************************************/

t_AltTablesDecoder *t_AltTablesDecoderConstruct (U32_WMV uiUserData)
{
    t_AltTablesDecoder *pAltTab = (t_AltTablesDecoder *)
        wmvalloc (sizeof(t_AltTablesDecoder));
    pAltTab->m_bIntraFrame = FALSE_WMV;
    pAltTab->m_uiUserData = uiUserData;
    pAltTab->m_iNewFrame = 0;
    pAltTab->m_bIsFirstRun = TRUE_WMV;
    pAltTab->m_iNContexts = LH_INTRAC1 + 1;
    DEBUG_HEAP_ADD(DHEAP_LOCALHUFF,sizeof(t_AltTablesDecoder));

    for (I32_WMV i = 0; i < pAltTab->m_iNContexts; i++)
        pAltTab->m_paLH[i]  = LhdecConstruct (i, pAltTab);
    return pAltTab;
}

/**********************************************************************
 CAltTablesDecoder : destructor
**********************************************************************/

Void_WMV t_AltTablesDecoderDestruct (t_AltTablesDecoder *pAltTab)
{
    for (I32_WMV i=0; i<pAltTab->m_iNContexts; i++)
        LhdecDestruct (pAltTab->m_paLH[i]);
    wmvfree (pAltTab);
    DEBUG_HEAP_SUB(DHEAP_LOCALHUFF,sizeof(t_AltTablesDecoder));
}

/**********************************************************************
 CAltTables::setNewFrame
 clears m_iNewFrame parameter, and sets frame-level variables
**********************************************************************/

Void_WMV t_AltTablesSetNewFrame (t_AltTablesDecoder *pAltTab,
              I32_WMV iQLev, I32_WMV pOrI)
{
    pAltTab->m_iNewFrame = 0;
    pAltTab->m_iQLev = iQLev;
    if (pOrI)  {
        pAltTab->m_iNewIntraFrame = 0;
        pAltTab->m_bIntraFrame = TRUE_WMV;
    }
    else
        pAltTab->m_bIntraFrame = FALSE_WMV;

    // Set codes
    for (I32_WMV i = 0; i < pAltTab->m_iNContexts; i++)
        LhdecSetCodes(pAltTab->m_paLH[i], iQLev);
}
