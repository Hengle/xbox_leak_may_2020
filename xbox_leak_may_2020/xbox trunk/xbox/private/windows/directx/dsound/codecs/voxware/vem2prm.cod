; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\vem2prm.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EA@DOABAOKF@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _vemUnregisterParameter@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vemRegisterArray@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vemRegisterTable@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vemRegisterVariable@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vemRegisterStruct@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vemRegisterConstFloat@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vemRegisterConstShort@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vemGetParameter@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vemGetParameterData@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vemSetParameterData@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _registerParameter@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _copyParameter@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vemShowParameters@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_vemUnregisterParameter@8
EXTRN	_vecDelElement@8:NEAR
EXTRN	_vecGetData@4:NEAR
EXTRN	_free:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\vem2prm.c
;	COMDAT _vemUnregisterParameter@8
_TEXT	SEGMENT
_pVemMemHandler$ = -8
_pVemParameter$ = -4
_hVemMemHandle$ = 8
_paramKey$ = 12
_vemUnregisterParameter@8 PROC NEAR			; COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 116  :    VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hVemMemHandle$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _pVemMemHandler$[ebp], eax

; 117  : 
; 118  :    VEM_PARAMETER     *pVemParameter    = (VEM_PARAMETER *)vecGetData((void*)paramKey);

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _paramKey$[ebp]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _vecGetData@4
  00015	89 45 fc	 mov	 DWORD PTR _pVemParameter$[ebp], eax

; 119  : 
; 120  :    if(pVemParameter) {

  00018	83 7d fc 00	 cmp	 DWORD PTR _pVemParameter$[ebp], 0
  0001c	74 48		 je	 SHORT $L1564

; 121  :       vecDelElement(pVemMemHandler->pVemParameters, paramKey);

  0001e	8b 55 0c	 mov	 edx, DWORD PTR _paramKey$[ebp]
  00021	52		 push	 edx
  00022	8b 45 f8	 mov	 eax, DWORD PTR _pVemMemHandler$[ebp]
  00025	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _vecDelElement@8

; 122  :       VOX_MEM_FREE(pVemParameter->pszKey);

  0002e	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  00031	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00034	74 17		 je	 SHORT $L1565
  00036	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 _free
  00041	83 c4 04	 add	 esp, 4
  00044	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  00047	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L1565:

; 123  :       VOX_MEM_FREE(pVemParameter);

  0004d	83 7d fc 00	 cmp	 DWORD PTR _pVemParameter$[ebp], 0
  00051	74 13		 je	 SHORT $L1564
  00053	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _free
  0005c	83 c4 04	 add	 esp, 4
  0005f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pVemParameter$[ebp], 0
$L1564:

; 124  :    }
; 125  :    return ((VEM_KEY)NULL);

  00066	33 c0		 xor	 eax, eax

; 126  : }

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 08 00	 ret	 8
_vemUnregisterParameter@8 ENDP
_TEXT	ENDS
PUBLIC	_vemRegisterArray@20
; Function compile flags: /Odt
;	COMDAT _vemRegisterArray@20
_TEXT	SEGMENT
_paramKey$ = -8
_pVemParameter$ = -4
_hVemMemHandle$ = 8
_pData$ = 12
_dataType$ = 16
_dataSize$ = 20
_pszKey$ = 24
_vemRegisterArray@20 PROC NEAR				; COMDAT

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 164  :    VEM_KEY paramKey=NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _paramKey$[ebp], 0

; 165  :    VEM_PARAMETER *pVemParameter=NULL;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pVemParameter$[ebp], 0

; 166  : 
; 167  :    if(!(paramKey=registerParameter(hVemMemHandle,&pVemParameter, pszKey)))

  00014	8b 45 18	 mov	 eax, DWORD PTR _pszKey$[ebp]
  00017	50		 push	 eax
  00018	8d 4d fc	 lea	 ecx, DWORD PTR _pVemParameter$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR _hVemMemHandle$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 _registerParameter@12
  00025	89 45 f8	 mov	 DWORD PTR _paramKey$[ebp], eax
  00028	83 7d f8 00	 cmp	 DWORD PTR _paramKey$[ebp], 0
  0002c	75 04		 jne	 SHORT $L1586

; 168  :       return ((VEM_KEY)NULL);

  0002e	33 c0		 xor	 eax, eax
  00030	eb 28		 jmp	 SHORT $L1581
$L1586:

; 169  : 
; 170  :    pVemParameter->DataContainer.pData=pData;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  00038	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 171  :    pVemParameter->dataSize=dataSize;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  0003e	8b 45 14	 mov	 eax, DWORD PTR _dataSize$[ebp]
  00041	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 172  :    pVemParameter->dataType=dataType;

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  00047	8b 55 10	 mov	 edx, DWORD PTR _dataType$[ebp]
  0004a	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 173  :    pVemParameter->elementType=VEM_ARRAY;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  00050	c7 40 10 03 00
	00 00		 mov	 DWORD PTR [eax+16], 3

; 174  : 
; 175  :    return(paramKey);

  00057	8b 45 f8	 mov	 eax, DWORD PTR _paramKey$[ebp]
$L1581:

; 176  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 14 00	 ret	 20			; 00000014H
_vemRegisterArray@20 ENDP
_TEXT	ENDS
PUBLIC	_vemRegisterTable@20
; Function compile flags: /Odt
;	COMDAT _vemRegisterTable@20
_TEXT	SEGMENT
_paramKey$ = -8
_pVemParameter$ = -4
_hVemMemHandle$ = 8
_pData$ = 12
_dataType$ = 16
_dataSize$ = 20
_pszKey$ = 24
_vemRegisterTable@20 PROC NEAR				; COMDAT

; 211  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 212  :    VEM_KEY            paramKey         = NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _paramKey$[ebp], 0

; 213  :    VEM_PARAMETER     *pVemParameter    = NULL;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pVemParameter$[ebp], 0

; 214  : 
; 215  :    if(!(paramKey=registerParameter(hVemMemHandle,&pVemParameter, pszKey)))

  00014	8b 45 18	 mov	 eax, DWORD PTR _pszKey$[ebp]
  00017	50		 push	 eax
  00018	8d 4d fc	 lea	 ecx, DWORD PTR _pVemParameter$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR _hVemMemHandle$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 _registerParameter@12
  00025	89 45 f8	 mov	 DWORD PTR _paramKey$[ebp], eax
  00028	83 7d f8 00	 cmp	 DWORD PTR _paramKey$[ebp], 0
  0002c	75 04		 jne	 SHORT $L1604

; 216  :       return ((VEM_KEY)NULL);

  0002e	33 c0		 xor	 eax, eax
  00030	eb 28		 jmp	 SHORT $L1599
$L1604:

; 217  : 
; 218  :    pVemParameter->DataContainer.pData=pData;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  00038	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 219  :    pVemParameter->dataSize=dataSize;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  0003e	8b 45 14	 mov	 eax, DWORD PTR _dataSize$[ebp]
  00041	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 220  :    pVemParameter->dataType=dataType;

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  00047	8b 55 10	 mov	 edx, DWORD PTR _dataType$[ebp]
  0004a	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 221  :    pVemParameter->elementType=VEM_TABLE;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  00050	c7 40 10 04 00
	00 00		 mov	 DWORD PTR [eax+16], 4

; 222  : 
; 223  :    return(paramKey);

  00057	8b 45 f8	 mov	 eax, DWORD PTR _paramKey$[ebp]
$L1599:

; 224  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 14 00	 ret	 20			; 00000014H
_vemRegisterTable@20 ENDP
_TEXT	ENDS
PUBLIC	_vemRegisterVariable@16
; Function compile flags: /Odt
;	COMDAT _vemRegisterVariable@16
_TEXT	SEGMENT
_paramKey$ = -8
_pVemParameter$ = -4
_hVemMemHandle$ = 8
_pData$ = 12
_dataType$ = 16
_pszKey$ = 20
_vemRegisterVariable@16 PROC NEAR			; COMDAT

; 259  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 260  :    VEM_KEY            paramKey         = NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _paramKey$[ebp], 0

; 261  :    VEM_PARAMETER     *pVemParameter    = NULL;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pVemParameter$[ebp], 0

; 262  : 
; 263  :    if(!(paramKey=registerParameter(hVemMemHandle,&pVemParameter, pszKey)))

  00014	8b 45 14	 mov	 eax, DWORD PTR _pszKey$[ebp]
  00017	50		 push	 eax
  00018	8d 4d fc	 lea	 ecx, DWORD PTR _pVemParameter$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR _hVemMemHandle$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 _registerParameter@12
  00025	89 45 f8	 mov	 DWORD PTR _paramKey$[ebp], eax
  00028	83 7d f8 00	 cmp	 DWORD PTR _paramKey$[ebp], 0
  0002c	75 04		 jne	 SHORT $L1620

; 264  :       return ((VEM_KEY)NULL);

  0002e	33 c0		 xor	 eax, eax
  00030	eb 29		 jmp	 SHORT $L1615
$L1620:

; 265  : 
; 266  :    pVemParameter->DataContainer.pData=pData;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  00038	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 267  :    pVemParameter->dataSize=0;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  0003e	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 268  :    pVemParameter->dataType=dataType;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  00048	8b 4d 10	 mov	 ecx, DWORD PTR _dataType$[ebp]
  0004b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 269  :    pVemParameter->elementType=VEM_VARIABLE;

  0004e	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  00051	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 270  : 
; 271  :    return(paramKey);

  00058	8b 45 f8	 mov	 eax, DWORD PTR _paramKey$[ebp]
$L1615:

; 272  : }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 10 00	 ret	 16			; 00000010H
_vemRegisterVariable@16 ENDP
_TEXT	ENDS
PUBLIC	_vemRegisterStruct@16
; Function compile flags: /Odt
;	COMDAT _vemRegisterStruct@16
_TEXT	SEGMENT
_paramKey$ = -8
_pVemParameter$ = -4
_hVemMemHandle$ = 8
_pData$ = 12
_dataSize$ = 16
_pszKey$ = 20
_vemRegisterStruct@16 PROC NEAR				; COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 308  :    VEM_KEY            paramKey         = NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _paramKey$[ebp], 0

; 309  :    VEM_PARAMETER     *pVemParameter    = NULL;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pVemParameter$[ebp], 0

; 310  : 
; 311  :    if(!(paramKey=registerParameter(hVemMemHandle,&pVemParameter, pszKey)))

  00014	8b 45 14	 mov	 eax, DWORD PTR _pszKey$[ebp]
  00017	50		 push	 eax
  00018	8d 4d fc	 lea	 ecx, DWORD PTR _pVemParameter$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR _hVemMemHandle$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 _registerParameter@12
  00025	89 45 f8	 mov	 DWORD PTR _paramKey$[ebp], eax
  00028	83 7d f8 00	 cmp	 DWORD PTR _paramKey$[ebp], 0
  0002c	75 04		 jne	 SHORT $L1636

; 312  :       return ((VEM_KEY)NULL);

  0002e	33 c0		 xor	 eax, eax
  00030	eb 29		 jmp	 SHORT $L1631
$L1636:

; 313  : 
; 314  :    pVemParameter->DataContainer.pData=pData;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  00038	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 315  :    pVemParameter->dataSize=dataSize;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  0003e	8b 45 10	 mov	 eax, DWORD PTR _dataSize$[ebp]
  00041	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 316  :    pVemParameter->dataType=VEM_VOID; /* type doesn't matter */

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  00047	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 317  :    pVemParameter->elementType=VEM_STRUCT;

  0004e	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  00051	c7 42 10 05 00
	00 00		 mov	 DWORD PTR [edx+16], 5

; 318  : 
; 319  :    return(paramKey);

  00058	8b 45 f8	 mov	 eax, DWORD PTR _paramKey$[ebp]
$L1631:

; 320  : }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 10 00	 ret	 16			; 00000010H
_vemRegisterStruct@16 ENDP
_TEXT	ENDS
PUBLIC	_vemRegisterConstFloat@12
EXTRN	__fltused:NEAR
; Function compile flags: /Odt
;	COMDAT _vemRegisterConstFloat@12
_TEXT	SEGMENT
_paramKey$ = -8
_pVemParameter$ = -4
_pvMemMain$ = 8
_val$ = 12
_pszKey$ = 16
_vemRegisterConstFloat@12 PROC NEAR			; COMDAT

; 352  : VEM_KEY vemRegisterConstFloat(void *pvMemMain, float val, const char *pszKey) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 353  :    VEM_KEY            paramKey         = NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _paramKey$[ebp], 0

; 354  :    VEM_PARAMETER     *pVemParameter    = NULL;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pVemParameter$[ebp], 0

; 355  : 
; 356  :    if(!(paramKey=registerParameter(pvMemMain,&pVemParameter, pszKey)))

  00014	8b 45 10	 mov	 eax, DWORD PTR _pszKey$[ebp]
  00017	50		 push	 eax
  00018	8d 4d fc	 lea	 ecx, DWORD PTR _pVemParameter$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR _pvMemMain$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 _registerParameter@12
  00025	89 45 f8	 mov	 DWORD PTR _paramKey$[ebp], eax
  00028	83 7d f8 00	 cmp	 DWORD PTR _paramKey$[ebp], 0
  0002c	75 04		 jne	 SHORT $L1650

; 357  :       return ((VEM_KEY)NULL);

  0002e	33 c0		 xor	 eax, eax
  00030	eb 2a		 jmp	 SHORT $L1645
$L1650:

; 358  : 
; 359  :    pVemParameter->DataContainer.floatData=val;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _val$[ebp]
  00038	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 360  :    pVemParameter->dataSize=0;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  0003e	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 361  :    pVemParameter->dataType=VEM_FLOAT;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  00048	c7 40 0c 09 00
	00 00		 mov	 DWORD PTR [eax+12], 9

; 362  :    pVemParameter->elementType=VEM_FLOAT_CONST;

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  00052	c7 41 10 01 00
	00 00		 mov	 DWORD PTR [ecx+16], 1

; 363  : 
; 364  :    return(paramKey);

  00059	8b 45 f8	 mov	 eax, DWORD PTR _paramKey$[ebp]
$L1645:

; 365  : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 0c 00	 ret	 12			; 0000000cH
_vemRegisterConstFloat@12 ENDP
_TEXT	ENDS
PUBLIC	_vemRegisterConstShort@12
; Function compile flags: /Odt
;	COMDAT _vemRegisterConstShort@12
_TEXT	SEGMENT
_paramKey$ = -8
_pVemParameter$ = -4
_pvMemMain$ = 8
_val$ = 12
_pszKey$ = 16
_vemRegisterConstShort@12 PROC NEAR			; COMDAT

; 397  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 398  :    VEM_KEY            paramKey         = NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _paramKey$[ebp], 0

; 399  :    VEM_PARAMETER     *pVemParameter    = NULL;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pVemParameter$[ebp], 0

; 400  : 
; 401  :    if(!(paramKey=registerParameter(pvMemMain,&pVemParameter, pszKey)))

  00014	8b 45 10	 mov	 eax, DWORD PTR _pszKey$[ebp]
  00017	50		 push	 eax
  00018	8d 4d fc	 lea	 ecx, DWORD PTR _pVemParameter$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR _pvMemMain$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 _registerParameter@12
  00025	89 45 f8	 mov	 DWORD PTR _paramKey$[ebp], eax
  00028	83 7d f8 00	 cmp	 DWORD PTR _paramKey$[ebp], 0
  0002c	75 04		 jne	 SHORT $L1664

; 402  :       return ((VEM_KEY)NULL);

  0002e	33 c0		 xor	 eax, eax
  00030	eb 2c		 jmp	 SHORT $L1659
$L1664:

; 403  : 
; 404  :    pVemParameter->DataContainer.shortData=val;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  00035	66 8b 4d 0c	 mov	 cx, WORD PTR _val$[ebp]
  00039	66 89 48 04	 mov	 WORD PTR [eax+4], cx

; 405  :    pVemParameter->dataSize=0;

  0003d	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  00040	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 406  :    pVemParameter->dataType=VEM_SHORT;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  0004a	c7 40 0c 03 00
	00 00		 mov	 DWORD PTR [eax+12], 3

; 407  :    pVemParameter->elementType=VEM_SHORT_CONST;

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  00054	c7 41 10 02 00
	00 00		 mov	 DWORD PTR [ecx+16], 2

; 408  : 
; 409  :    return(paramKey);

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _paramKey$[ebp]
$L1659:

; 410  : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 0c 00	 ret	 12			; 0000000cH
_vemRegisterConstShort@12 ENDP
_TEXT	ENDS
PUBLIC	_vemGetParameter@8
EXTRN	_vecGetNextElement@8:NEAR
EXTRN	_vecGetFirstElement@4:NEAR
EXTRN	_strcmp:NEAR
; Function compile flags: /Odt
;	COMDAT _vemGetParameter@8
_TEXT	SEGMENT
_pElement$ = -8
_pVemMemHandler$ = -4
_hVemMemHandle$ = 8
_pszKey$ = 12
_vemGetParameter@8 PROC NEAR				; COMDAT

; 442  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 443  :    VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hVemMemHandle$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _pVemMemHandler$[ebp], eax

; 444  : 
; 445  :    void              *pElement         = vecGetFirstElement(pVemMemHandler->pVemParameters);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _pVemMemHandler$[ebp]
  0000f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 _vecGetFirstElement@4
  00018	89 45 f8	 mov	 DWORD PTR _pElement$[ebp], eax
$L1676:

; 446  : 
; 447  :    while(pElement) {

  0001b	83 7d f8 00	 cmp	 DWORD PTR _pElement$[ebp], 0
  0001f	74 2e		 je	 SHORT $L1677

; 448  :       if(!strcmp(((VEM_PARAMETER *)vecGetData(pElement))->pszKey,pszKey))

  00021	8b 45 0c	 mov	 eax, DWORD PTR _pszKey$[ebp]
  00024	50		 push	 eax
  00025	8b 4d f8	 mov	 ecx, DWORD PTR _pElement$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _vecGetData@4
  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
  00030	52		 push	 edx
  00031	e8 00 00 00 00	 call	 _strcmp
  00036	83 c4 08	 add	 esp, 8
  00039	85 c0		 test	 eax, eax
  0003b	75 02		 jne	 SHORT $L1679

; 449  :          break;

  0003d	eb 10		 jmp	 SHORT $L1677
$L1679:

; 450  :       pElement=vecGetNextElement(pElement, FORWARDS);

  0003f	6a 01		 push	 1
  00041	8b 45 f8	 mov	 eax, DWORD PTR _pElement$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _vecGetNextElement@8
  0004a	89 45 f8	 mov	 DWORD PTR _pElement$[ebp], eax

; 451  :    }

  0004d	eb cc		 jmp	 SHORT $L1676
$L1677:

; 452  :    return((VEM_KEY)pElement); /* could be NULL */

  0004f	8b 45 f8	 mov	 eax, DWORD PTR _pElement$[ebp]

; 453  : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
_vemGetParameter@8 ENDP
_TEXT	ENDS
PUBLIC	_vemGetParameterData@8
PUBLIC	??_C@_0EA@DOABAOKF@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
EXTRN	__assert:NEAR
EXTRN	_memcpy:NEAR
;	COMDAT ??_C@_0EA@DOABAOKF@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0EA@DOABAOKF@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\vem2prm.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vemGetParameterData@8
_TEXT	SEGMENT
tv68 = -8
_pVemParameter$ = -4
_pvVemParameter$ = 8
_pData$ = 12
_vemGetParameterData@8 PROC NEAR			; COMDAT

; 484  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 485  :    VEM_PARAMETER *pVemParameter=(VEM_PARAMETER *)vecGetData((void *)pvVemParameter);

  00006	8b 45 08	 mov	 eax, DWORD PTR _pvVemParameter$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _vecGetData@4
  0000f	89 45 fc	 mov	 DWORD PTR _pVemParameter$[ebp], eax

; 486  : 
; 487  :    if(pVemParameter) {

  00012	83 7d fc 00	 cmp	 DWORD PTR _pVemParameter$[ebp], 0
  00016	0f 84 bd 00 00
	00		 je	 $L1689

; 488  :       switch(pVemParameter->elementType) {

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  0001f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00022	89 55 f8	 mov	 DWORD PTR tv68[ebp], edx
  00025	83 7d f8 05	 cmp	 DWORD PTR tv68[ebp], 5
  00029	0f 87 8b 00 00
	00		 ja	 $L1704
  0002f	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]
  00032	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L1880[eax*4]
$L1694:

; 489  :          case VEM_ARRAY:
; 490  :          case VEM_TABLE:
; 491  :             return(copyParameter(pData,pVemParameter->DataContainer.pData,pVemParameter->dataType,
; 492  :                    pVemParameter->dataSize));

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  0003c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  00043	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00046	51		 push	 ecx
  00047	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  0004a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004d	50		 push	 eax
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 _copyParameter@16
  00057	e9 86 00 00 00	 jmp	 $L1685
$L1695:

; 493  :          case VEM_VARIABLE:
; 494  :             return(copyParameter(pData,pVemParameter->DataContainer.pData,pVemParameter->dataType,1));

  0005c	6a 01		 push	 1
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  00061	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  00068	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0006b	52		 push	 edx
  0006c	8b 45 0c	 mov	 eax, DWORD PTR _pData$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _copyParameter@16
  00075	eb 6b		 jmp	 SHORT $L1685
$L1696:

; 495  :          case VEM_FLOAT_CONST:
; 496  :             *(float *)pData=pVemParameter->DataContainer.floatData;

  00077	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  0007a	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  0007d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00080	89 01		 mov	 DWORD PTR [ecx], eax

; 497  :             return 0;

  00082	66 33 c0	 xor	 ax, ax
  00085	eb 5b		 jmp	 SHORT $L1685
$L1698:

; 498  :          case VEM_SHORT_CONST:
; 499  :             *(short *)pData=pVemParameter->DataContainer.shortData;

  00087	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  0008a	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  0008d	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00091	66 89 01	 mov	 WORD PTR [ecx], ax

; 500  :             return 0;

  00094	66 33 c0	 xor	 ax, ax
  00097	eb 49		 jmp	 SHORT $L1685
$L1700:

; 501  :          case VEM_STRUCT:
; 502  :             return((unsigned short)((memcpy(pData,pVemParameter->DataContainer.pData,
; 503  :                pVemParameter->dataSize))?(unsigned short)0:(unsigned short)1));

  00099	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  0009c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0009f	52		 push	 edx
  000a0	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  000a3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a6	51		 push	 ecx
  000a7	8b 55 0c	 mov	 edx, DWORD PTR _pData$[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 _memcpy
  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b3	f7 d8		 neg	 eax
  000b5	1b c0		 sbb	 eax, eax
  000b7	40		 inc	 eax
  000b8	eb 28		 jmp	 SHORT $L1685
$L1704:

; 504  :          default:
; 505  :             assert(0);

  000ba	33 c0		 xor	 eax, eax
  000bc	85 c0		 test	 eax, eax
  000be	75 17		 jne	 SHORT $L1691
  000c0	68 f9 01 00 00	 push	 505			; 000001f9H
  000c5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@DOABAOKF@c?3?2xbox?2private?2windows?2directx?2@
  000ca	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  000cf	e8 00 00 00 00	 call	 __assert
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1691:

; 506  :       }
; 507  :    } else

  000d7	eb 06		 jmp	 SHORT $L1708
$L1689:

; 508  :       return 1;

  000d9	66 b8 01 00	 mov	 ax, 1
  000dd	eb 03		 jmp	 SHORT $L1685
$L1708:

; 509  :       
; 510  :    return 0;   

  000df	66 33 c0	 xor	 ax, ax
$L1685:

; 511  : }

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 08 00	 ret	 8
$L1880:
  000e8	00 00 00 00	 DD	 $L1695
  000ec	00 00 00 00	 DD	 $L1696
  000f0	00 00 00 00	 DD	 $L1698
  000f4	00 00 00 00	 DD	 $L1694
  000f8	00 00 00 00	 DD	 $L1694
  000fc	00 00 00 00	 DD	 $L1700
_vemGetParameterData@8 ENDP
_TEXT	ENDS
PUBLIC	_vemSetParameterData@8
; Function compile flags: /Odt
;	COMDAT _vemSetParameterData@8
_TEXT	SEGMENT
tv68 = -8
_pVemParameter$ = -4
_pvVemParameter$ = 8
_pData$ = 12
_vemSetParameterData@8 PROC NEAR			; COMDAT

; 543  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 544  :    VEM_PARAMETER *pVemParameter=(VEM_PARAMETER *)vecGetData((void *)pvVemParameter);

  00006	8b 45 08	 mov	 eax, DWORD PTR _pvVemParameter$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _vecGetData@4
  0000f	89 45 fc	 mov	 DWORD PTR _pVemParameter$[ebp], eax

; 545  : 
; 546  :    if(pVemParameter) {

  00012	83 7d fc 00	 cmp	 DWORD PTR _pVemParameter$[ebp], 0
  00016	0f 84 9a 00 00
	00		 je	 $L1717

; 547  :       switch(pVemParameter->elementType) {

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  0001f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00022	89 55 f8	 mov	 DWORD PTR tv68[ebp], edx
  00025	83 7d f8 05	 cmp	 DWORD PTR tv68[ebp], 5
  00029	77 6c		 ja	 SHORT $L1727
  0002b	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]
  0002e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L1885[eax*4]
$L1722:

; 548  :          case VEM_ARRAY:
; 549  :             return(copyParameter(pVemParameter->DataContainer.pData,pData,pVemParameter->dataType,
; 550  :                    pVemParameter->dataSize));

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  00038	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0003b	52		 push	 edx
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  0003f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00042	51		 push	 ecx
  00043	8b 55 0c	 mov	 edx, DWORD PTR _pData$[ebp]
  00046	52		 push	 edx
  00047	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  0004a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _copyParameter@16
  00053	eb 6a		 jmp	 SHORT $L1713
$L1723:

; 551  :          case VEM_VARIABLE:
; 552  :             return(copyParameter(pVemParameter->DataContainer.pData,pData,pVemParameter->dataType,1));

  00055	6a 01		 push	 1
  00057	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  0005a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0005d	50		 push	 eax
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  00061	51		 push	 ecx
  00062	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  00065	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _copyParameter@16
  0006e	eb 4f		 jmp	 SHORT $L1713
$L1724:

; 553  :          case VEM_TABLE:
; 554  :          case VEM_FLOAT_CONST:
; 555  :          case VEM_SHORT_CONST:
; 556  :             return 1;

  00070	66 b8 01 00	 mov	 ax, 1
  00074	eb 49		 jmp	 SHORT $L1713
$L1725:

; 557  :          case VEM_STRUCT:
; 558  :             return((unsigned short)((memcpy(pVemParameter->DataContainer.pData,pData,
; 559  :                    pVemParameter->dataSize))?0:1));

  00076	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  00079	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007c	52		 push	 edx
  0007d	8b 45 0c	 mov	 eax, DWORD PTR _pData$[ebp]
  00080	50		 push	 eax
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  00084	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00087	52		 push	 edx
  00088	e8 00 00 00 00	 call	 _memcpy
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	f7 d8		 neg	 eax
  00092	1b c0		 sbb	 eax, eax
  00094	40		 inc	 eax
  00095	eb 28		 jmp	 SHORT $L1713
$L1727:

; 560  :          default:
; 561  :             assert(0);

  00097	33 c0		 xor	 eax, eax
  00099	85 c0		 test	 eax, eax
  0009b	75 17		 jne	 SHORT $L1719
  0009d	68 31 02 00 00	 push	 561			; 00000231H
  000a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@DOABAOKF@c?3?2xbox?2private?2windows?2directx?2@
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  000ac	e8 00 00 00 00	 call	 __assert
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1719:

; 562  :       }
; 563  :    } else

  000b4	eb 06		 jmp	 SHORT $L1729
$L1717:

; 564  :       return 1;

  000b6	66 b8 01 00	 mov	 ax, 1
  000ba	eb 03		 jmp	 SHORT $L1713
$L1729:

; 565  :       
; 566  :    return 0;   

  000bc	66 33 c0	 xor	 ax, ax
$L1713:

; 567  : }

  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 08 00	 ret	 8
$L1885:
  000c5	00 00 00 00	 DD	 $L1723
  000c9	00 00 00 00	 DD	 $L1724
  000cd	00 00 00 00	 DD	 $L1724
  000d1	00 00 00 00	 DD	 $L1722
  000d5	00 00 00 00	 DD	 $L1724
  000d9	00 00 00 00	 DD	 $L1725
_vemSetParameterData@8 ENDP
_TEXT	ENDS
EXTRN	_vecAddElement@12:NEAR
EXTRN	_calloc:NEAR
EXTRN	_strcpy:NEAR
EXTRN	_strlen:NEAR
; Function compile flags: /Odt
;	COMDAT _registerParameter@12
_TEXT	SEGMENT
_pVemMemHandler$ = -12
_paramKey$ = -8
_pVemParameter$ = -4
_hVemMemHandle$ = 8
_hVemParameter$ = 12
_pszKey$ = 16
_registerParameter@12 PROC NEAR				; COMDAT

; 602  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 603  :    VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;

  00006	8b 45 08	 mov	 eax, DWORD PTR _hVemMemHandle$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR _pVemMemHandler$[ebp], eax

; 604  :    VEM_PARAMETER     *pVemParameter    = NULL;

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pVemParameter$[ebp], 0

; 605  :    VEM_KEY            paramKey         = NULL;

  00013	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _paramKey$[ebp], 0

; 606  : 
; 607  :    if(VOX_MEM_INIT(pVemParameter=*hVemParameter, 1, sizeof(VEM_PARAMETER)))

  0001a	6a 14		 push	 20			; 00000014H
  0001c	6a 01		 push	 1
  0001e	e8 00 00 00 00	 call	 _calloc
  00023	83 c4 08	 add	 esp, 8
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _hVemParameter$[ebp]
  00029	89 01		 mov	 DWORD PTR [ecx], eax
  0002b	8b 55 0c	 mov	 edx, DWORD PTR _hVemParameter$[ebp]
  0002e	8b 02		 mov	 eax, DWORD PTR [edx]
  00030	89 45 fc	 mov	 DWORD PTR _pVemParameter$[ebp], eax
  00033	83 7d fc 00	 cmp	 DWORD PTR _pVemParameter$[ebp], 0
  00037	75 07		 jne	 SHORT $L1744

; 608  :       return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 8c 00 00 00	 jmp	 $L1736
$L1744:

; 609  :    else
; 610  :       pVemParameter->pszKey=NULL;

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 611  : 
; 612  :    if(!(paramKey=vecAddElement(pVemMemHandler->pVemParameters, pVemParameter, FORWARDS))) {

  00049	6a 01		 push	 1
  0004b	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  0004e	52		 push	 edx
  0004f	8b 45 f4	 mov	 eax, DWORD PTR _pVemMemHandler$[ebp]
  00052	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 _vecAddElement@12
  0005b	89 45 f8	 mov	 DWORD PTR _paramKey$[ebp], eax
  0005e	83 7d f8 00	 cmp	 DWORD PTR _paramKey$[ebp], 0
  00062	75 1d		 jne	 SHORT $L1748

; 613  :       VOX_MEM_FREE(pVemParameter);

  00064	83 7d fc 00	 cmp	 DWORD PTR _pVemParameter$[ebp], 0
  00068	74 13		 je	 SHORT $L1749
  0006a	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _free
  00073	83 c4 04	 add	 esp, 4
  00076	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pVemParameter$[ebp], 0
$L1749:

; 614  :       return NULL;

  0007d	33 c0		 xor	 eax, eax
  0007f	eb 4b		 jmp	 SHORT $L1736
$L1748:

; 615  :    }
; 616  : 
; 617  :    if(VOX_MEM_INIT(pVemParameter->pszKey,strlen(pszKey)+1,sizeof(char)))

  00081	6a 01		 push	 1
  00083	8b 45 10	 mov	 eax, DWORD PTR _pszKey$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _strlen
  0008c	83 c4 04	 add	 esp, 4
  0008f	83 c0 01	 add	 eax, 1
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _calloc
  00098	83 c4 08	 add	 esp, 8
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _pVemParameter$[ebp]
  0009e	89 01		 mov	 DWORD PTR [ecx], eax
  000a0	8b 55 fc	 mov	 edx, DWORD PTR _pVemParameter$[ebp]
  000a3	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000a6	75 0f		 jne	 SHORT $L1753

; 618  :       return vemUnregisterParameter(hVemMemHandle, paramKey);

  000a8	8b 45 f8	 mov	 eax, DWORD PTR _paramKey$[ebp]
  000ab	50		 push	 eax
  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _hVemMemHandle$[ebp]
  000af	51		 push	 ecx
  000b0	e8 00 00 00 00	 call	 _vemUnregisterParameter@8
  000b5	eb 15		 jmp	 SHORT $L1736
$L1753:

; 619  :    else
; 620  :       strcpy(pVemParameter->pszKey,pszKey);

  000b7	8b 55 10	 mov	 edx, DWORD PTR _pszKey$[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 fc	 mov	 eax, DWORD PTR _pVemParameter$[ebp]
  000be	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 _strcpy
  000c6	83 c4 08	 add	 esp, 8

; 621  : 
; 622  :    return paramKey;

  000c9	8b 45 f8	 mov	 eax, DWORD PTR _paramKey$[ebp]
$L1736:

; 623  : }

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c2 0c 00	 ret	 12			; 0000000cH
_registerParameter@12 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _copyParameter@16
_TEXT	SEGMENT
tv64 = -56
_pFloat$ = -52
_pFloat2$ = -48
_pDouble$ = -44
_pUChar2$ = -40
_pULong2$ = -36
_pUChar$ = -32
_pUInt2$ = -28
_pUInt$ = -24
_i$ = -20
_pULong$ = -16
_pDouble2$ = -12
_pUShort2$ = -8
_pUShort$ = -4
_pVector$ = 8
_pVector2$ = 12
_paramType$ = 16
_count$ = 20
_copyParameter@16 PROC NEAR				; COMDAT

; 659  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 660  :    size_t i;
; 661  : 
; 662  :    unsigned char  *pUChar=NULL,    *pUChar2=NULL;

  00008	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _pUChar$[ebp], 0
  0000f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pUChar2$[ebp], 0

; 663  :    unsigned short *pUShort=NULL,   *pUShort2=NULL;

  00016	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pUShort$[ebp], 0
  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pUShort2$[ebp], 0

; 664  :    unsigned int   *pUInt=NULL,     *pUInt2=NULL;

  00024	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pUInt$[ebp], 0
  0002b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pUInt2$[ebp], 0

; 665  :    unsigned long  *pULong=NULL,    *pULong2=NULL;

  00032	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pULong$[ebp], 0
  00039	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _pULong2$[ebp], 0

; 666  :    float          *pFloat=NULL,    *pFloat2=NULL;

  00040	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _pFloat$[ebp], 0
  00047	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _pFloat2$[ebp], 0

; 667  :    double         *pDouble=NULL,   *pDouble2=NULL;

  0004e	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _pDouble$[ebp], 0
  00055	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pDouble2$[ebp], 0

; 668  : 
; 669  :    switch(paramType) {

  0005c	8b 45 10	 mov	 eax, DWORD PTR _paramType$[ebp]
  0005f	89 45 c8	 mov	 DWORD PTR tv64[ebp], eax
  00062	8b 4d c8	 mov	 ecx, DWORD PTR tv64[ebp]
  00065	83 e9 01	 sub	 ecx, 1
  00068	89 4d c8	 mov	 DWORD PTR tv64[ebp], ecx
  0006b	83 7d c8 09	 cmp	 DWORD PTR tv64[ebp], 9
  0006f	0f 87 86 01 00
	00		 ja	 $L1829
  00075	8b 55 c8	 mov	 edx, DWORD PTR tv64[ebp]
  00078	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L1892[edx*4]
$L1793:

; 670  :       case VEM_CHAR: 
; 671  :       case VEM_U_CHAR:
; 672  :          pUChar=(unsigned char *)pVector;

  0007f	8b 45 08	 mov	 eax, DWORD PTR _pVector$[ebp]
  00082	89 45 e0	 mov	 DWORD PTR _pUChar$[ebp], eax

; 673  :          pUChar2=(unsigned char *)pVector2;

  00085	8b 4d 0c	 mov	 ecx, DWORD PTR _pVector2$[ebp]
  00088	89 4d d8	 mov	 DWORD PTR _pUChar2$[ebp], ecx

; 674  :          for(i=0;i<count;i++)

  0008b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00092	eb 09		 jmp	 SHORT $L1796
$L1797:
  00094	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  00097	83 c2 01	 add	 edx, 1
  0009a	89 55 ec	 mov	 DWORD PTR _i$[ebp], edx
$L1796:
  0009d	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000a0	3b 45 14	 cmp	 eax, DWORD PTR _count$[ebp]
  000a3	73 12		 jae	 SHORT $L1798

; 675  :             pUChar[i]=pUChar2[i];

  000a5	8b 4d e0	 mov	 ecx, DWORD PTR _pUChar$[ebp]
  000a8	03 4d ec	 add	 ecx, DWORD PTR _i$[ebp]
  000ab	8b 55 d8	 mov	 edx, DWORD PTR _pUChar2$[ebp]
  000ae	03 55 ec	 add	 edx, DWORD PTR _i$[ebp]
  000b1	8a 02		 mov	 al, BYTE PTR [edx]
  000b3	88 01		 mov	 BYTE PTR [ecx], al
  000b5	eb dd		 jmp	 SHORT $L1797
$L1798:

; 676  :          break;

  000b7	e9 45 01 00 00	 jmp	 $L1790
$L1799:

; 677  :       case VEM_SHORT:
; 678  :       case VEM_U_SHORT:
; 679  :          pUShort=(unsigned short *)pVector;

  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _pVector$[ebp]
  000bf	89 4d fc	 mov	 DWORD PTR _pUShort$[ebp], ecx

; 680  :          pUShort2=(unsigned short *)pVector2;

  000c2	8b 55 0c	 mov	 edx, DWORD PTR _pVector2$[ebp]
  000c5	89 55 f8	 mov	 DWORD PTR _pUShort2$[ebp], edx

; 681  :          for(i=0;i<count;i++)

  000c8	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000cf	eb 09		 jmp	 SHORT $L1802
$L1803:
  000d1	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000d4	83 c0 01	 add	 eax, 1
  000d7	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$L1802:
  000da	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  000dd	3b 4d 14	 cmp	 ecx, DWORD PTR _count$[ebp]
  000e0	73 16		 jae	 SHORT $L1804

; 682  :             pUShort[i]=pUShort2[i];

  000e2	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  000e5	8b 45 fc	 mov	 eax, DWORD PTR _pUShort$[ebp]
  000e8	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  000eb	8b 75 f8	 mov	 esi, DWORD PTR _pUShort2$[ebp]
  000ee	66 8b 0c 4e	 mov	 cx, WORD PTR [esi+ecx*2]
  000f2	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  000f6	eb d9		 jmp	 SHORT $L1803
$L1804:

; 683  :          break;

  000f8	e9 04 01 00 00	 jmp	 $L1790
$L1805:

; 684  :       case  VEM_INT:
; 685  :       case  VEM_U_INT:
; 686  :          pUInt=(unsigned int *)pVector;

  000fd	8b 55 08	 mov	 edx, DWORD PTR _pVector$[ebp]
  00100	89 55 e8	 mov	 DWORD PTR _pUInt$[ebp], edx

; 687  :          pUInt2=(unsigned int *)pVector2;

  00103	8b 45 0c	 mov	 eax, DWORD PTR _pVector2$[ebp]
  00106	89 45 e4	 mov	 DWORD PTR _pUInt2$[ebp], eax

; 688  :          for(i=0;i<count;i++)

  00109	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00110	eb 09		 jmp	 SHORT $L1808
$L1809:
  00112	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00115	83 c1 01	 add	 ecx, 1
  00118	89 4d ec	 mov	 DWORD PTR _i$[ebp], ecx
$L1808:
  0011b	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  0011e	3b 55 14	 cmp	 edx, DWORD PTR _count$[ebp]
  00121	73 14		 jae	 SHORT $L1810

; 689  :             pUInt[i]=pUInt2[i];

  00123	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00126	8b 4d e8	 mov	 ecx, DWORD PTR _pUInt$[ebp]
  00129	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  0012c	8b 75 e4	 mov	 esi, DWORD PTR _pUInt2$[ebp]
  0012f	8b 14 96	 mov	 edx, DWORD PTR [esi+edx*4]
  00132	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  00135	eb db		 jmp	 SHORT $L1809
$L1810:

; 690  :          break;

  00137	e9 c5 00 00 00	 jmp	 $L1790
$L1811:

; 691  :       case VEM_LONG:
; 692  :       case VEM_U_LONG:
; 693  :          pULong=(unsigned long *)pVector;

  0013c	8b 45 08	 mov	 eax, DWORD PTR _pVector$[ebp]
  0013f	89 45 f0	 mov	 DWORD PTR _pULong$[ebp], eax

; 694  :          pULong2=(unsigned long *)pVector2;

  00142	8b 4d 0c	 mov	 ecx, DWORD PTR _pVector2$[ebp]
  00145	89 4d dc	 mov	 DWORD PTR _pULong2$[ebp], ecx

; 695  :          for(i=0;i<count;i++)

  00148	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0014f	eb 09		 jmp	 SHORT $L1814
$L1815:
  00151	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  00154	83 c2 01	 add	 edx, 1
  00157	89 55 ec	 mov	 DWORD PTR _i$[ebp], edx
$L1814:
  0015a	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0015d	3b 45 14	 cmp	 eax, DWORD PTR _count$[ebp]
  00160	73 14		 jae	 SHORT $L1816

; 696  :             pULong[i]=pULong2[i];

  00162	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00165	8b 55 f0	 mov	 edx, DWORD PTR _pULong$[ebp]
  00168	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0016b	8b 75 dc	 mov	 esi, DWORD PTR _pULong2$[ebp]
  0016e	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  00171	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  00174	eb db		 jmp	 SHORT $L1815
$L1816:

; 697  :          break;

  00176	e9 86 00 00 00	 jmp	 $L1790
$L1817:

; 698  :       case VEM_FLOAT:
; 699  :          pFloat=(float *)pVector;

  0017b	8b 4d 08	 mov	 ecx, DWORD PTR _pVector$[ebp]
  0017e	89 4d cc	 mov	 DWORD PTR _pFloat$[ebp], ecx

; 700  :          pFloat2=(float *)pVector2;

  00181	8b 55 0c	 mov	 edx, DWORD PTR _pVector2$[ebp]
  00184	89 55 d0	 mov	 DWORD PTR _pFloat2$[ebp], edx

; 701  :          for(i=0;i<count;i++)

  00187	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0018e	eb 09		 jmp	 SHORT $L1820
$L1821:
  00190	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00193	83 c0 01	 add	 eax, 1
  00196	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$L1820:
  00199	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  0019c	3b 4d 14	 cmp	 ecx, DWORD PTR _count$[ebp]
  0019f	73 14		 jae	 SHORT $L1822

; 702  :             pFloat[i]=pFloat2[i];

  001a1	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  001a4	8b 45 cc	 mov	 eax, DWORD PTR _pFloat$[ebp]
  001a7	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  001aa	8b 75 d0	 mov	 esi, DWORD PTR _pFloat2$[ebp]
  001ad	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  001b0	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  001b3	eb db		 jmp	 SHORT $L1821
$L1822:

; 703  :          break;

  001b5	eb 4a		 jmp	 SHORT $L1790
$L1823:

; 704  :       case VEM_DOUBLE:
; 705  :          pDouble=(double *)pVector;

  001b7	8b 55 08	 mov	 edx, DWORD PTR _pVector$[ebp]
  001ba	89 55 d4	 mov	 DWORD PTR _pDouble$[ebp], edx

; 706  :          pDouble2=(double *)pVector2;

  001bd	8b 45 0c	 mov	 eax, DWORD PTR _pVector2$[ebp]
  001c0	89 45 f4	 mov	 DWORD PTR _pDouble2$[ebp], eax

; 707  :          for(i=0;i<count;i++)

  001c3	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001ca	eb 09		 jmp	 SHORT $L1826
$L1827:
  001cc	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  001cf	83 c1 01	 add	 ecx, 1
  001d2	89 4d ec	 mov	 DWORD PTR _i$[ebp], ecx
$L1826:
  001d5	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  001d8	3b 55 14	 cmp	 edx, DWORD PTR _count$[ebp]
  001db	73 1c		 jae	 SHORT $L1828

; 708  :             pDouble[i]=pDouble2[i];

  001dd	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  001e0	8b 4d d4	 mov	 ecx, DWORD PTR _pDouble$[ebp]
  001e3	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  001e6	8b 75 f4	 mov	 esi, DWORD PTR _pDouble2$[ebp]
  001e9	8b 3c d6	 mov	 edi, DWORD PTR [esi+edx*8]
  001ec	89 3c c1	 mov	 DWORD PTR [ecx+eax*8], edi
  001ef	8b 54 d6 04	 mov	 edx, DWORD PTR [esi+edx*8+4]
  001f3	89 54 c1 04	 mov	 DWORD PTR [ecx+eax*8+4], edx
  001f7	eb d3		 jmp	 SHORT $L1827
$L1828:

; 709  :          break;

  001f9	eb 06		 jmp	 SHORT $L1790
$L1829:

; 710  :       default:
; 711  :          return 1;

  001fb	66 b8 01 00	 mov	 ax, 1
  001ff	eb 03		 jmp	 SHORT $L1763
$L1790:

; 712  :    }
; 713  :    return 0;

  00201	66 33 c0	 xor	 ax, ax
$L1763:

; 714  : }

  00204	5f		 pop	 edi
  00205	5e		 pop	 esi
  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c2 10 00	 ret	 16			; 00000010H
$L1892:
  0020c	00 00 00 00	 DD	 $L1793
  00210	00 00 00 00	 DD	 $L1793
  00214	00 00 00 00	 DD	 $L1799
  00218	00 00 00 00	 DD	 $L1799
  0021c	00 00 00 00	 DD	 $L1805
  00220	00 00 00 00	 DD	 $L1805
  00224	00 00 00 00	 DD	 $L1811
  00228	00 00 00 00	 DD	 $L1811
  0022c	00 00 00 00	 DD	 $L1817
  00230	00 00 00 00	 DD	 $L1823
_copyParameter@16 ENDP
_TEXT	ENDS
PUBLIC	_vemShowParameters@4
; Function compile flags: /Odt
;	COMDAT _vemShowParameters@4
_TEXT	SEGMENT
_hVemMemHandle$ = 8
_vemShowParameters@4 PROC NEAR				; COMDAT

; 818  : void vemShowParameters(const void *hVemMemHandle) {return;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c2 04 00	 ret	 4
_vemShowParameters@4 ENDP
_TEXT	ENDS
END
