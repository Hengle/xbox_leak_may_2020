; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\selepeak.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EB@NODGEFGN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GGOKBJCK@pfPower?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@PHNFBKLF@pfRs?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@JELHCKNG@pfAlpc?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@DAMEFJOM@pfMaskEnv?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _SelectPeaks@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CalcRSbyPower@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CalcMaskEnvelope@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_SelectPeaks@16
PUBLIC	??_C@_0EB@NODGEFGN@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BA@GGOKBJCK@pfPower?5?$CB?$DN?5NULL?$AA@	; `string'
PUBLIC	??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	__real@40a00000
PUBLIC	__real@42c00000
PUBLIC	__real@3f800008
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3a2bcc77
EXTRN	_BandExpand@16:NEAR
EXTRN	_VoxDurbin@20:NEAR
EXTRN	_PeakPick@24:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	_ceil:NEAR
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0EB@NODGEFGN@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\selepeak.c
CONST	SEGMENT
??_C@_0EB@NODGEFGN@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\selepeak.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GGOKBJCK@pfPower?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BA@GGOKBJCK@pfPower?5?$CB?$DN?5NULL?$AA@ DB 'pfPower != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@ DB 'piPeakFreq != NULL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@42c00000
CONST	SEGMENT
__real@42c00000 DD 042c00000r			; 96
CONST	ENDS
;	COMDAT __real@3f800008
CONST	SEGMENT
__real@3f800008 DD 03f800008r			; 1
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3a2bcc77
CONST	SEGMENT
__real@3a2bcc77 DD 03a2bcc77r			; 0.00065536
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _SelectPeaks@16
_TEXT	SEGMENT
_pfMaskEnv$1518 = -512
_pfRs$1516 = -116
_pfPARCOR$1517 = -84
_fGain$ = -56
_k$ = -52
_iIndex$ = -48
_iNPeaks$ = -44
_fPowerThrd$ = -40
_i$ = -36
_iLPCorder$ = -32
_pfAlpc$ = -28
_pfPower$ = 8
_iBaseBand$ = 12
_piPeakFreq$ = 16
_fMaxPower$ = 20
_SelectPeaks@16 PROC NEAR				; COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 02 00
	00		 sub	 esp, 512		; 00000200H
  00009	56		 push	 esi

; 118  : 
; 119  :   /***** local varibles ******/
; 120  :   int   i,k;
; 121  :   int   iIndex;
; 122  :   int   iNPeaks;
; 123  :   float fGain;
; 124  :   float fPowerThrd;
; 125  :   int   iLPCorder;
; 126  : 
; 127  :   /***** STACK memory ******/
; 128  : STACK_INIT
; 129  :   float pfAlpc[MAX_LPC_MASKING_ORDER];
; 130  : STACK_INIT_END 
; 131  : 
; 132  :   STACK_ATTACH(float *, pfAlpc)
; 133  : STACK_START
; 134  : 
; 135  :   assert(pfPower != NULL);

  0000a	83 7d 08 00	 cmp	 DWORD PTR _pfPower$[ebp], 0
  0000e	75 17		 jne	 SHORT $L1599
  00010	68 87 00 00 00	 push	 135			; 00000087H
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NODGEFGN@c?3?2xbox?2private?2windows?2directx?2@
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@GGOKBJCK@pfPower?5?$CB?$DN?5NULL?$AA@
  0001f	e8 00 00 00 00	 call	 __assert
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1599:

; 136  :   assert(piPeakFreq != NULL);

  00027	83 7d 10 00	 cmp	 DWORD PTR _piPeakFreq$[ebp], 0
  0002b	75 17		 jne	 SHORT $L1600
  0002d	68 88 00 00 00	 push	 136			; 00000088H
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NODGEFGN@c?3?2xbox?2private?2windows?2directx?2@
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@NJKGAINH@piPeakFreq?5?$CB?$DN?5NULL?$AA@
  0003c	e8 00 00 00 00	 call	 __assert
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1600:

; 137  : 
; 138  :   /*----------------------------------------------------------------------
; 139  :     (1) Pick the peaks regularly from the power spectrum.
; 140  :     ----------------------------------------------------------------------*/
; 141  :   PeakPick( pfPower, 0, EXTEND_CUT_LC+1, MAX_NPEAKS,
; 142  :             piPeakFreq, &iNPeaks);

  00044	8d 55 d4	 lea	 edx, DWORD PTR _iNPeaks$[ebp]
  00047	52		 push	 edx
  00048	8b 45 10	 mov	 eax, DWORD PTR _piPeakFreq$[ebp]
  0004b	50		 push	 eax
  0004c	6a 30		 push	 48			; 00000030H
  0004e	6a 61		 push	 97			; 00000061H
  00050	6a 00		 push	 0
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _pfPower$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 _PeakPick@24

; 143  : 
; 144  :   /*----------------------------------------------------------------------
; 145  :     (2) Compute LPC coefficients.
; 146  :     ----------------------------------------------------------------------*/
; 147  : 
; 148  :   /***  Find the lpc order. ***/
; 149  :   iLPCorder = (int)ceil((float)LPC_MASKING_ORDER*(float)iBaseBand/
; 150  :                        (float)EXTEND_CUT_LC);

  0005b	db 45 0c	 fild	 DWORD PTR _iBaseBand$[ebp]
  0005e	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40a00000
  00064	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@42c00000
  0006a	83 ec 08	 sub	 esp, 8
  0006d	dd 1c 24	 fstp	 QWORD PTR [esp]
  00070	e8 00 00 00 00	 call	 _ceil
  00075	83 c4 08	 add	 esp, 8
  00078	e8 00 00 00 00	 call	 __ftol2
  0007d	89 45 e0	 mov	 DWORD PTR _iLPCorder$[ebp], eax

; 151  :   if (iLPCorder > MAX_LPC_MASKING_ORDER)

  00080	83 7d e0 07	 cmp	 DWORD PTR _iLPCorder$[ebp], 7
  00084	7e 07		 jle	 SHORT $L1515

; 152  :     iLPCorder = MAX_LPC_MASKING_ORDER;

  00086	c7 45 e0 07 00
	00 00		 mov	 DWORD PTR _iLPCorder$[ebp], 7
$L1515:

; 153  : 
; 154  :   /*** Compute RS and LPC ***/
; 155  :   {
; 156  : STACK_INIT 
; 157  :   float pfRs[MAX_LPC_MASKING_ORDER+1];
; 158  :   float pfPARCOR[MAX_LPC_MASKING_ORDER];
; 159  : STACK_INIT_END
; 160  : 
; 161  :    STACK_ATTACH(float *, pfRs)
; 162  :    STACK_ATTACH(float *, pfPARCOR)
; 163  : 
; 164  : STACK_START
; 165  :   /*
; 166  :    * Compute autocorrelation coefficients from power spectrum.
; 167  :    * And the autocorrelation coefficients are the inverse FFT of power spectrum.
; 168  :    */
; 169  :   CalcRSbyPower(STACK_S pfPower, iBaseBand, pfRs, iLPCorder);

  0008d	8b 55 e0	 mov	 edx, DWORD PTR _iLPCorder$[ebp]
  00090	52		 push	 edx
  00091	8d 45 8c	 lea	 eax, DWORD PTR _pfRs$1516[ebp]
  00094	50		 push	 eax
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR _iBaseBand$[ebp]
  00098	51		 push	 ecx
  00099	8b 55 08	 mov	 edx, DWORD PTR _pfPower$[ebp]
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 _CalcRSbyPower@16

; 170  : 
; 171  : 
; 172  :   /***  Calculate the LPC coefficients. ***/
; 173  :   pfRs[0] *= 1.000001F;

  000a2	d9 45 8c	 fld	 DWORD PTR _pfRs$1516[ebp]
  000a5	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f800008
  000ab	d9 5d 8c	 fstp	 DWORD PTR _pfRs$1516[ebp]

; 174  :   VoxDurbin(pfRs, iLPCorder, pfAlpc, pfPARCOR, &fGain);

  000ae	8d 45 c8	 lea	 eax, DWORD PTR _fGain$[ebp]
  000b1	50		 push	 eax
  000b2	8d 4d ac	 lea	 ecx, DWORD PTR _pfPARCOR$1517[ebp]
  000b5	51		 push	 ecx
  000b6	8d 55 e4	 lea	 edx, DWORD PTR _pfAlpc$[ebp]
  000b9	52		 push	 edx
  000ba	8b 45 e0	 mov	 eax, DWORD PTR _iLPCorder$[ebp]
  000bd	50		 push	 eax
  000be	8d 4d 8c	 lea	 ecx, DWORD PTR _pfRs$1516[ebp]
  000c1	51		 push	 ecx
  000c2	e8 00 00 00 00	 call	 _VoxDurbin@20

; 175  :   BandExpand(pfAlpc, pfAlpc, iLPCorder, EXPANSION_FACTOR);

  000c7	68 48 e1 7a 3f	 push	 1065017672		; 3f7ae148H
  000cc	8b 55 e0	 mov	 edx, DWORD PTR _iLPCorder$[ebp]
  000cf	52		 push	 edx
  000d0	8d 45 e4	 lea	 eax, DWORD PTR _pfAlpc$[ebp]
  000d3	50		 push	 eax
  000d4	8d 4d e4	 lea	 ecx, DWORD PTR _pfAlpc$[ebp]
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 _BandExpand@16

; 176  : STACK_END
; 177  :   }
; 178  : 
; 179  :   /*----------------------------------------------------------------------
; 180  :    (3) Get masking envelope and apply it to eliminate small peaks.
; 181  :    ----------------------------------------------------------------------*/
; 182  :   {
; 183  : STACK_INIT
; 184  :   float pfMaskEnv[EXTEND_CUT_LC+1];
; 185  : STACK_INIT_END
; 186  : 
; 187  :   STACK_ATTACH(float *, pfMaskEnv)
; 188  : 
; 189  : STACK_START
; 190  :   /*** Compute the Masking Envelope from the inverse all-pole filter. ***/
; 191  :   CalcMaskEnvelope(STACK_S pfAlpc, iLPCorder, pfMaskEnv, iBaseBand);

  000dd	8b 55 0c	 mov	 edx, DWORD PTR _iBaseBand$[ebp]
  000e0	52		 push	 edx
  000e1	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR _pfMaskEnv$1518[ebp]
  000e7	50		 push	 eax
  000e8	8b 4d e0	 mov	 ecx, DWORD PTR _iLPCorder$[ebp]
  000eb	51		 push	 ecx
  000ec	8d 55 e4	 lea	 edx, DWORD PTR _pfAlpc$[ebp]
  000ef	52		 push	 edx
  000f0	e8 00 00 00 00	 call	 _CalcMaskEnvelope@16

; 192  : 
; 193  :   /*** Scale the residue energy.***/
; 194  :   fGain *= MASKING_ATTENUATION;

  000f5	d9 45 c8	 fld	 DWORD PTR _fGain$[ebp]
  000f8	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e4ccccd
  000fe	d9 5d c8	 fstp	 DWORD PTR _fGain$[ebp]

; 195  : 
; 196  :   /*** Reject the peaks below the LPC masking envelope and the global
; 197  :     threshold. ***/
; 198  :   fPowerThrd = fMaxPower * MAX_PEAK_THRESHOLD;

  00101	d9 45 14	 fld	 DWORD PTR _fMaxPower$[ebp]
  00104	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a2bcc77
  0010a	d9 5d d8	 fstp	 DWORD PTR _fPowerThrd$[ebp]

; 199  :   k = 0;

  0010d	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0

; 200  :   for (i = 0; i < iNPeaks; i++) 

  00114	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0011b	eb 09		 jmp	 SHORT $L1519
$L1520:
  0011d	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  00120	83 c0 01	 add	 eax, 1
  00123	89 45 dc	 mov	 DWORD PTR _i$[ebp], eax
$L1519:
  00126	8b 4d dc	 mov	 ecx, DWORD PTR _i$[ebp]
  00129	3b 4d d4	 cmp	 ecx, DWORD PTR _iNPeaks$[ebp]
  0012c	7d 61		 jge	 SHORT $L1521

; 201  :   {
; 202  :     iIndex = piPeakFreq[i];

  0012e	8b 55 dc	 mov	 edx, DWORD PTR _i$[ebp]
  00131	8b 45 10	 mov	 eax, DWORD PTR _piPeakFreq$[ebp]
  00134	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00137	89 4d d0	 mov	 DWORD PTR _iIndex$[ebp], ecx

; 203  : 
; 204  :     if ((iIndex<iBaseBand) && ((pfPower[iIndex]*pfMaskEnv[iIndex]) >= fGain)
; 205  :           && (pfPower[iIndex] > fPowerThrd))

  0013a	8b 55 d0	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0013d	3b 55 0c	 cmp	 edx, DWORD PTR _iBaseBand$[ebp]
  00140	7d 4b		 jge	 SHORT $L1522
  00142	8b 45 d0	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00145	8b 4d 08	 mov	 ecx, DWORD PTR _pfPower$[ebp]
  00148	8b 55 d0	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0014b	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  0014e	d8 8c 95 00 fe
	ff ff		 fmul	 DWORD PTR _pfMaskEnv$1518[ebp+edx*4]
  00155	d8 5d c8	 fcomp	 DWORD PTR _fGain$[ebp]
  00158	df e0		 fnstsw	 ax
  0015a	f6 c4 01	 test	 ah, 1
  0015d	75 2e		 jne	 SHORT $L1522
  0015f	8b 45 d0	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00162	8b 4d 08	 mov	 ecx, DWORD PTR _pfPower$[ebp]
  00165	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  00168	d8 5d d8	 fcomp	 DWORD PTR _fPowerThrd$[ebp]
  0016b	df e0		 fnstsw	 ax
  0016d	f6 c4 41	 test	 ah, 65			; 00000041H
  00170	75 1b		 jne	 SHORT $L1522

; 206  :       {
; 207  :         piPeakFreq[k] = piPeakFreq[i];

  00172	8b 55 cc	 mov	 edx, DWORD PTR _k$[ebp]
  00175	8b 45 10	 mov	 eax, DWORD PTR _piPeakFreq$[ebp]
  00178	8b 4d dc	 mov	 ecx, DWORD PTR _i$[ebp]
  0017b	8b 75 10	 mov	 esi, DWORD PTR _piPeakFreq$[ebp]
  0017e	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  00181	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 208  :         k++;

  00184	8b 55 cc	 mov	 edx, DWORD PTR _k$[ebp]
  00187	83 c2 01	 add	 edx, 1
  0018a	89 55 cc	 mov	 DWORD PTR _k$[ebp], edx
$L1522:

; 209  :       }
; 210  :   }

  0018d	eb 8e		 jmp	 SHORT $L1520
$L1521:

; 211  : 
; 212  :   piPeakFreq[k] = SHRT_MAX;   /* a big number for ending */

  0018f	8b 45 cc	 mov	 eax, DWORD PTR _k$[ebp]
  00192	8b 4d 10	 mov	 ecx, DWORD PTR _piPeakFreq$[ebp]
  00195	c7 04 81 ff 7f
	00 00		 mov	 DWORD PTR [ecx+eax*4], 32767 ; 00007fffH

; 213  : STACK_END
; 214  :   }
; 215  : 
; 216  : STACK_END
; 217  : }

  0019c	5e		 pop	 esi
  0019d	8b e5		 mov	 esp, ebp
  0019f	5d		 pop	 ebp
  001a0	c2 10 00	 ret	 16			; 00000010H
_SelectPeaks@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@PHNFBKLF@pfRs?5?$CB?$DN?5NULL?$AA@	; `string'
PUBLIC	__real@42000000
PUBLIC	__real@47000000
EXTRN	_vox_nspsCcsFft@12:NEAR
EXTRN	_memcpy:NEAR
;	COMDAT ??_C@_0N@PHNFBKLF@pfRs?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0N@PHNFBKLF@pfRs?5?$CB?$DN?5NULL?$AA@ DB 'pfRs != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@47000000
CONST	SEGMENT
__real@47000000 DD 047000000r			; 32768
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _CalcRSbyPower@16
_TEXT	SEGMENT
_j$ = -288
_ftmp$ = -284
_pfMaskPower$ = -280
_fScale$ = -12
_iScale$ = -8
_i$ = -4
_pfPower$ = 8
_iNBand$ = 12
_pfRs$ = 16
_iLPCorder$ = 20
_CalcRSbyPower@16 PROC NEAR				; COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H

; 257  :   int   iScale, i, j;
; 258  :   float fScale;
; 259  :   float ftmp;
; 260  : 
; 261  : STACK_INIT
; 262  :   float pfMaskPower[DFFT+2];
; 263  : STACK_INIT_END
; 264  : 
; 265  : STACK_ATTACH(float *, pfMaskPower)
; 266  : 
; 267  : STACK_START
; 268  : 
; 269  :   assert(pfPower != NULL);

  00009	83 7d 08 00	 cmp	 DWORD PTR _pfPower$[ebp], 0
  0000d	75 17		 jne	 SHORT $L1616
  0000f	68 0d 01 00 00	 push	 269			; 0000010dH
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NODGEFGN@c?3?2xbox?2private?2windows?2directx?2@
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@GGOKBJCK@pfPower?5?$CB?$DN?5NULL?$AA@
  0001e	e8 00 00 00 00	 call	 __assert
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1616:

; 270  :   assert(pfRs != NULL);

  00026	83 7d 10 00	 cmp	 DWORD PTR _pfRs$[ebp], 0
  0002a	75 17		 jne	 SHORT $L1617
  0002c	68 0e 01 00 00	 push	 270			; 0000010eH
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NODGEFGN@c?3?2xbox?2private?2windows?2directx?2@
  00036	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@PHNFBKLF@pfRs?5?$CB?$DN?5NULL?$AA@
  0003b	e8 00 00 00 00	 call	 __assert
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1617:

; 271  : 
; 272  :   /*----------------------------------------------------------------------
; 273  :     (1) Rescale the power spectrum of "DFFT" size. 
; 274  :     Use fix-point index.
; 275  :     ----------------------------------------------------------------------*/
; 276  :   fScale = (float)iNBand/(float)DFFT_2;

  00043	db 45 0c	 fild	 DWORD PTR _iNBand$[ebp]
  00046	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@42000000
  0004c	d9 55 f4	 fst	 DWORD PTR _fScale$[ebp]

; 277  :   ftmp = fScale*CONSTSCALE;

  0004f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@47000000
  00055	d9 9d e4 fe ff
	ff		 fstp	 DWORD PTR _ftmp$[ebp]

; 278  :   VoxROUND2(ftmp, iScale);

  0005b	d9 85 e4 fe ff
	ff		 fld	 DWORD PTR _ftmp$[ebp]
  00061	db 5d f8	 fistp	 DWORD PTR _iScale$[ebp]

; 279  : 
; 280  :   j = 0;

  00064	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0

; 281  :   pfMaskPower[j++] = 0.0F;

  0006e	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00074	c7 84 95 e8 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _pfMaskPower$[ebp+edx*4], 0
  0007f	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00085	83 c0 01	 add	 eax, 1
  00088	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _j$[ebp], eax

; 282  :   pfMaskPower[j++] = 0.0F;

  0008e	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00094	c7 84 8d e8 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _pfMaskPower$[ebp+ecx*4], 0
  0009f	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  000a5	83 c2 01	 add	 edx, 1
  000a8	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _j$[ebp], edx

; 283  : 
; 284  :   for (i = 1; i < DFFT_2; i++)

  000ae	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000b5	eb 09		 jmp	 SHORT $L1546
$L1547:
  000b7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ba	83 c0 01	 add	 eax, 1
  000bd	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L1546:
  000c0	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  000c4	7d 54		 jge	 SHORT $L1548

; 285  :   {
; 286  :     pfMaskPower[j++] = pfPower[ConvertIndex(iScale, i)];

  000c6	8b 4d f8	 mov	 ecx, DWORD PTR _iScale$[ebp]
  000c9	0f af 4d fc	 imul	 ecx, DWORD PTR _i$[ebp]
  000cd	81 c1 00 40 00
	00		 add	 ecx, 16384		; 00004000H
  000d3	c1 f9 0f	 sar	 ecx, 15			; 0000000fH
  000d6	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  000dc	8b 45 08	 mov	 eax, DWORD PTR _pfPower$[ebp]
  000df	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  000e2	89 8c 95 e8 fe
	ff ff		 mov	 DWORD PTR _pfMaskPower$[ebp+edx*4], ecx
  000e9	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  000ef	83 c2 01	 add	 edx, 1
  000f2	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _j$[ebp], edx

; 287  :     pfMaskPower[j++] = 0.0F;

  000f8	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  000fe	c7 84 85 e8 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _pfMaskPower$[ebp+eax*4], 0
  00109	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  0010f	83 c1 01	 add	 ecx, 1
  00112	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx

; 288  :   }

  00118	eb 9d		 jmp	 SHORT $L1547
$L1548:

; 289  :   pfMaskPower[j++] = 0.0F;

  0011a	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00120	c7 84 95 e8 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _pfMaskPower$[ebp+edx*4], 0
  0012b	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00131	83 c0 01	 add	 eax, 1
  00134	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _j$[ebp], eax

; 290  :   pfMaskPower[j++] = 0.0F;

  0013a	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00140	c7 84 8d e8 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _pfMaskPower$[ebp+ecx*4], 0
  0014b	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00151	83 c2 01	 add	 edx, 1
  00154	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _j$[ebp], edx

; 291  : 
; 292  :   /*----------------------------------------------------------------------
; 293  :     (2) Do inverse FFT 
; 294  :     ----------------------------------------------------------------------*/
; 295  :   VoxRealInverseFft(pfMaskPower, DFFT_ORDER, IFFT_SCALE_FLAG);

  0015a	6a 02		 push	 2
  0015c	6a 06		 push	 6
  0015e	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pfMaskPower$[ebp]
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 _vox_nspsCcsFft@12

; 296  : 
; 297  :   /*----------------------------------------------------------------------
; 298  :     (3) copy to RS array.
; 299  :     ----------------------------------------------------------------------*/
; 300  :   memcpy(pfRs, pfMaskPower, (iLPCorder+1)*sizeof(float));

  0016a	8b 4d 14	 mov	 ecx, DWORD PTR _iLPCorder$[ebp]
  0016d	8d 14 8d 04 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+4]
  00174	52		 push	 edx
  00175	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pfMaskPower$[ebp]
  0017b	50		 push	 eax
  0017c	8b 4d 10	 mov	 ecx, DWORD PTR _pfRs$[ebp]
  0017f	51		 push	 ecx
  00180	e8 00 00 00 00	 call	 _memcpy
  00185	83 c4 0c	 add	 esp, 12			; 0000000cH

; 301  : 
; 302  : STACK_END
; 303  : }

  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c2 10 00	 ret	 16			; 00000010H
_CalcRSbyPower@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@JELHCKNG@pfAlpc?5?$CB?$DN?5NULL?$AA@	; `string'
PUBLIC	??_C@_0BC@DAMEFJOM@pfMaskEnv?5?$CB?$DN?5NULL?$AA@ ; `string'
EXTRN	_vox_nspsRealFft@12:NEAR
EXTRN	_memset:NEAR
;	COMDAT ??_C@_0P@JELHCKNG@pfAlpc?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0P@JELHCKNG@pfAlpc?5?$CB?$DN?5NULL?$AA@ DB 'pfAlpc != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DAMEFJOM@pfMaskEnv?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BC@DAMEFJOM@pfMaskEnv?5?$CB?$DN?5NULL?$AA@ DB 'pfMaskEnv != NULL', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _CalcMaskEnvelope@16
_TEXT	SEGMENT
_j$ = -288
_ftmp$ = -284
_pfMaskPower$ = -280
_fScale$ = -12
_iScale$ = -8
_i$ = -4
_pfAlpc$ = 8
_iLPCorder$ = 12
_pfMaskEnv$ = 16
_iNBand$ = 20
_CalcMaskEnvelope@16 PROC NEAR				; COMDAT

; 342  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	56		 push	 esi

; 343  :   int i, j;
; 344  :   int iScale;
; 345  :   float ftmp;
; 346  :   float fScale;
; 347  : 
; 348  : STACK_INIT  
; 349  :   float pfMaskPower[DFFT+2];
; 350  : STACK_INIT_END
; 351  : 
; 352  : STACK_ATTACH(float *, pfMaskPower)
; 353  : 
; 354  : STACK_START
; 355  : 
; 356  :   assert(pfAlpc != NULL);

  0000a	83 7d 08 00	 cmp	 DWORD PTR _pfAlpc$[ebp], 0
  0000e	75 17		 jne	 SHORT $L1625
  00010	68 64 01 00 00	 push	 356			; 00000164H
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NODGEFGN@c?3?2xbox?2private?2windows?2directx?2@
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@JELHCKNG@pfAlpc?5?$CB?$DN?5NULL?$AA@
  0001f	e8 00 00 00 00	 call	 __assert
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1625:

; 357  :   assert(pfMaskEnv != NULL);

  00027	83 7d 10 00	 cmp	 DWORD PTR _pfMaskEnv$[ebp], 0
  0002b	75 17		 jne	 SHORT $L1626
  0002d	68 65 01 00 00	 push	 357			; 00000165H
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@NODGEFGN@c?3?2xbox?2private?2windows?2directx?2@
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@DAMEFJOM@pfMaskEnv?5?$CB?$DN?5NULL?$AA@
  0003c	e8 00 00 00 00	 call	 __assert
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1626:

; 358  : 
; 359  :   /*----------------------------------------------------------------------
; 360  :     (1) Compute the inverse all-pole envelope.
; 361  :     ----------------------------------------------------------------------*/
; 362  :   memcpy(pfMaskPower, pfAlpc, (iLPCorder+1)*sizeof(float));

  00044	8b 55 0c	 mov	 edx, DWORD PTR _iLPCorder$[ebp]
  00047	8d 04 95 04 00
	00 00		 lea	 eax, DWORD PTR [edx*4+4]
  0004e	50		 push	 eax
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _pfAlpc$[ebp]
  00052	51		 push	 ecx
  00053	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _pfMaskPower$[ebp]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 _memcpy
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 363  : 
; 364  :   i = iLPCorder+1;

  00062	8b 45 0c	 mov	 eax, DWORD PTR _iLPCorder$[ebp]
  00065	83 c0 01	 add	 eax, 1
  00068	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 365  :   memset(&(pfMaskPower[i]), 0, (DFFT+2-i)*sizeof(float));

  0006b	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00070	2b 4d fc	 sub	 ecx, DWORD PTR _i$[ebp]
  00073	c1 e1 02	 shl	 ecx, 2
  00076	51		 push	 ecx
  00077	6a 00		 push	 0
  00079	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0007c	8d 84 95 e8 fe
	ff ff		 lea	 eax, DWORD PTR _pfMaskPower$[ebp+edx*4]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _memset
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 366  : 
; 367  :   VoxRealFft(pfMaskPower, DFFT_ORDER);

  0008c	6a 01		 push	 1
  0008e	6a 06		 push	 6
  00090	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pfMaskPower$[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _vox_nspsRealFft@12

; 368  :   
; 369  :   /*----------------------------------------------------------------------
; 370  :     (2) compute the power spectrum of the all-pole envelope.
; 371  :     And rescale it to [0, iNBand].
; 372  :     ----------------------------------------------------------------------*/
; 373  :   fScale = (float)DFFT_2/(float)iNBand;

  0009c	db 45 14	 fild	 DWORD PTR _iNBand$[ebp]
  0009f	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@42000000
  000a5	d9 55 f4	 fst	 DWORD PTR _fScale$[ebp]

; 374  :   ftmp = fScale * CONSTSCALE;

  000a8	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@47000000
  000ae	d9 9d e4 fe ff
	ff		 fstp	 DWORD PTR _ftmp$[ebp]

; 375  :   VoxROUND2(ftmp,iScale);

  000b4	d9 85 e4 fe ff
	ff		 fld	 DWORD PTR _ftmp$[ebp]
  000ba	db 5d f8	 fistp	 DWORD PTR _iScale$[ebp]

; 376  : 
; 377  :   for (i = 0; i < (iNBand-1); i++) /*for interval from [0 iNBand-2]*/

  000bd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000c4	eb 09		 jmp	 SHORT $L1577
$L1578:
  000c6	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000c9	83 c2 01	 add	 edx, 1
  000cc	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L1577:
  000cf	8b 45 14	 mov	 eax, DWORD PTR _iNBand$[ebp]
  000d2	83 e8 01	 sub	 eax, 1
  000d5	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  000d8	7d 7b		 jge	 SHORT $L1579

; 378  :   {
; 379  :     j = 2*ConvertIndex(iScale, i);

  000da	8b 4d f8	 mov	 ecx, DWORD PTR _iScale$[ebp]
  000dd	0f af 4d fc	 imul	 ecx, DWORD PTR _i$[ebp]
  000e1	81 c1 00 40 00
	00		 add	 ecx, 16384		; 00004000H
  000e7	c1 f9 0f	 sar	 ecx, 15			; 0000000fH
  000ea	d1 e1		 shl	 ecx, 1
  000ec	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx

; 380  :     pfMaskEnv[i] = pfMaskPower[j]*pfMaskPower[j];

  000f2	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  000f8	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  000fe	d9 84 95 e8 fe
	ff ff		 fld	 DWORD PTR _pfMaskPower$[ebp+edx*4]
  00105	d8 8c 85 e8 fe
	ff ff		 fmul	 DWORD PTR _pfMaskPower$[ebp+eax*4]
  0010c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0010f	8b 55 10	 mov	 edx, DWORD PTR _pfMaskEnv$[ebp]
  00112	d9 1c 8a	 fstp	 DWORD PTR [edx+ecx*4]

; 381  :     j++;

  00115	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _j$[ebp], eax

; 382  :     pfMaskEnv[i] += pfMaskPower[j]*pfMaskPower[j];

  00124	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  0012a	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00130	d9 84 8d e8 fe
	ff ff		 fld	 DWORD PTR _pfMaskPower$[ebp+ecx*4]
  00137	d8 8c 95 e8 fe
	ff ff		 fmul	 DWORD PTR _pfMaskPower$[ebp+edx*4]
  0013e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00141	8b 4d 10	 mov	 ecx, DWORD PTR _pfMaskEnv$[ebp]
  00144	d8 04 81	 fadd	 DWORD PTR [ecx+eax*4]
  00147	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0014a	8b 45 10	 mov	 eax, DWORD PTR _pfMaskEnv$[ebp]
  0014d	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]

; 383  :   }

  00150	e9 71 ff ff ff	 jmp	 $L1578
$L1579:

; 384  : 
; 385  :   j = 2*ConvertIndex(iScale, i);

  00155	8b 4d f8	 mov	 ecx, DWORD PTR _iScale$[ebp]
  00158	0f af 4d fc	 imul	 ecx, DWORD PTR _i$[ebp]
  0015c	81 c1 00 40 00
	00		 add	 ecx, 16384		; 00004000H
  00162	c1 f9 0f	 sar	 ecx, 15			; 0000000fH
  00165	d1 e1		 shl	 ecx, 1
  00167	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx

; 386  :   if (j >= DFFT)

  0016d	83 bd e0 fe ff
	ff 40		 cmp	 DWORD PTR _j$[ebp], 64	; 00000040H
  00174	7c 15		 jl	 SHORT $L1582

; 387  :     pfMaskEnv[i] = pfMaskEnv[i-1];

  00176	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00179	8b 45 10	 mov	 eax, DWORD PTR _pfMaskEnv$[ebp]
  0017c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0017f	8b 75 10	 mov	 esi, DWORD PTR _pfMaskEnv$[ebp]
  00182	8b 4c 8e fc	 mov	 ecx, DWORD PTR [esi+ecx*4-4]
  00186	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 388  :   else

  00189	eb 5e		 jmp	 SHORT $L1559
$L1582:

; 389  :   {
; 390  :     pfMaskEnv[i] = pfMaskPower[j]*pfMaskPower[j];

  0018b	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00191	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00197	d9 84 95 e8 fe
	ff ff		 fld	 DWORD PTR _pfMaskPower$[ebp+edx*4]
  0019e	d8 8c 85 e8 fe
	ff ff		 fmul	 DWORD PTR _pfMaskPower$[ebp+eax*4]
  001a5	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001a8	8b 55 10	 mov	 edx, DWORD PTR _pfMaskEnv$[ebp]
  001ab	d9 1c 8a	 fstp	 DWORD PTR [edx+ecx*4]

; 391  :     j++;

  001ae	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  001b4	83 c0 01	 add	 eax, 1
  001b7	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _j$[ebp], eax

; 392  :     pfMaskEnv[i] += pfMaskPower[j]*pfMaskPower[j];

  001bd	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  001c3	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  001c9	d9 84 8d e8 fe
	ff ff		 fld	 DWORD PTR _pfMaskPower$[ebp+ecx*4]
  001d0	d8 8c 95 e8 fe
	ff ff		 fmul	 DWORD PTR _pfMaskPower$[ebp+edx*4]
  001d7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001da	8b 4d 10	 mov	 ecx, DWORD PTR _pfMaskEnv$[ebp]
  001dd	d8 04 81	 fadd	 DWORD PTR [ecx+eax*4]
  001e0	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001e3	8b 45 10	 mov	 eax, DWORD PTR _pfMaskEnv$[ebp]
  001e6	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]
$L1559:

; 393  :   }
; 394  : 
; 395  : STACK_END
; 396  : }

  001e9	5e		 pop	 esi
  001ea	8b e5		 mov	 esp, ebp
  001ec	5d		 pop	 ebp
  001ed	c2 10 00	 ret	 16			; 00000010H
_CalcMaskEnvelope@16 ENDP
_TEXT	ENDS
END
