; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\fft.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
WMADEC_RW	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RW	ENDS
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _LOG2@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT @ByteSwap@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvFFT4DCT_XDS@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auDctIV_XDS@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, WMADEC_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_DSoundBuildNumberD
WMADEC_RD	SEGMENT
_WMA_OK	DD	00H
_WMA_S_FALSE DD	01H
_WMA_S_BUFUNDERFLOW DD 02H
_WMA_S_NEWPACKET DD 03H
_WMA_S_NO_MORE_FRAME DD 04H
_WMA_S_DEFAULT DD 05H
_WMA_S_SWITCHCHMODE DD 06H
_WMA_E_FAIL DD	080004005H
_WMA_E_OUTOFMEMORY DD 08007000eH
_WMA_E_INVALIDARG DD 080070057H
_WMA_E_NOTSUPPORTED DD 080040000H
_WMA_E_LOSTPACKET DD 080040001H
_WMA_E_BROKEN_FRAME DD 080040002H
_WMA_E_BUFFEROVERFLOW DD 080040003H
_WMA_E_ONHOLD DD 080040004H
_WMA_E_BUFFERUNDERFLOW DD 080040005H
_WMA_E_INVALIDRECHDR DD 080040006H
_WMA_E_SYNCERROR DD 080040007H
_WMA_E_NOTIMPL DD 080040008H
_WMA_E_FLUSHOVERFLOW DD 080040009H
WMADEC_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT
_DSoundBuildNumberD DW 05344H
	DW	0554fH
	DW	0444eH
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
WMADEC_RD	SEGMENT
_dPI	DQ	0400921fb54442d18r		; 3.14159
WMADEC_RD	ENDS
PUBLIC	_prvFFT4DCT_XDS@8
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
EXTRN	__fltused:NEAR
EXTRN	_cos:NEAR
EXTRN	_sin:NEAR
;	COMDAT __real@3f000000
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\fft.c
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _prvFFT4DCT_XDS@8
WMADEC	SEGMENT
tv273 = -96
tv270 = -92
_n21$2422 = -88
_n2$2421 = -84
_tmp$2423 = -80
_j$ = -76
_m$ = -72
_np$ = -68
_CR$ = -64
_SI2$ = -60
_l$ = -56
_pxk$ = -52
_k$ = -48
_SI$ = -44
_px$ = -40
_ui$ = -36
_i$ = -32
_n$ = -28
_STEP$ = -24
_SI1$ = -20
_ur$ = -16
_CR2$ = -12
_CR1$ = -8
_pxi$ = -4
_data$ = 8
_nLog2np$ = 12
_prvFFT4DCT_XDS@8 PROC NEAR				; COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H

; 193  :     I32 np = (1<<nLog2np);

  00006	b8 01 00 00 00	 mov	 eax, 1
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _nLog2np$[ebp]
  0000e	d3 e0		 shl	 eax, cl
  00010	89 45 bc	 mov	 DWORD PTR _np$[ebp], eax

; 194  :     CoefType *px = data;

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00016	89 4d d8	 mov	 DWORD PTR _px$[ebp], ecx

; 195  :     I32 i, j, k, l, m, n;
; 196  :     CoefType *pxk, *pxi;
; 197  :     CoefType ur, ui;
; 198  : #if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
; 199  :     CoefType tk, ti;
; 200  : #endif
; 201  : 
; 202  :     // defining the following COSSIN structure allows us to pass a pointer to a set of values in asm code
; 203  :     // but WinCE/SH-3 compiler seems to do a particularly bad job of optimizing access to structure members!
; 204  :     // struct COSSIN { I32 CR2,SI2,CR1,SI1,STEP,CR,SI;  } cs;
; 205  :     BP2Type CR2,SI2,CR1,SI1,STEP,CR,SI;
; 206  :     FUNCTION_PROFILE(fp);
; 207  :     FUNCTION_PROFILE_START(&fp,FFT_PROFILE);
; 208  : 
; 209  : #ifdef _M_IX86
; 210  :     // Pentium sin/cos are fast
; 211  :     CR = BP2_FROM_FLOAT(cos(dPI/np));

  00019	db 45 bc	 fild	 DWORD PTR _np$[ebp]
  0001c	dc 3d 00 00 00
	00		 fdivr	 QWORD PTR _dPI
  00022	83 ec 08	 sub	 esp, 8
  00025	dd 1c 24	 fstp	 QWORD PTR [esp]
  00028	e8 00 00 00 00	 call	 _cos
  0002d	83 c4 08	 add	 esp, 8
  00030	d9 55 a4	 fst	 DWORD PTR tv270[ebp]
  00033	d9 5d c0	 fstp	 DWORD PTR _CR$[ebp]

; 212  :     STEP = BP2_FROM_FLOAT(2*sin(-dPI/np));

  00036	dd 05 00 00 00
	00		 fld	 QWORD PTR _dPI
  0003c	d9 e0		 fchs
  0003e	da 75 bc	 fidiv	 DWORD PTR _np$[ebp]
  00041	83 ec 08	 sub	 esp, 8
  00044	dd 1c 24	 fstp	 QWORD PTR [esp]
  00047	e8 00 00 00 00	 call	 _sin
  0004c	83 c4 08	 add	 esp, 8
  0004f	dc c0		 fadd	 ST(0), ST(0)
  00051	d9 55 a0	 fst	 DWORD PTR tv273[ebp]
  00054	d9 55 e8	 fst	 DWORD PTR _STEP$[ebp]

; 213  : #else // _M_IX86
; 214  :     // other platforms' sin/cos unlikely to be that optimized, so do lookup
; 215  :     {
; 216  :         if ( nLog2np < 16 )
; 217  :         {
; 218  :             CR = BP2_FROM_BP1(icosPIbynp[nLog2np]);         // CR = (I32)(cos(PI/np) * NF2BP2)
; 219  : #ifdef BUILD_INTEGER
; 220  :             STEP = isinPIbynp[nLog2np];                     // STEP = (I32)(2*sin(-PI/np) * NF2BP2)
; 221  : #else
; 222  :             STEP = BP2_FROM_FLOAT(2*isinPIbynp[nLog2np]);   // STEP = (I32)(2*sin(-PI/np) * NF2BP2)
; 223  : #endif
; 224  :         }
; 225  :         else
; 226  :         {
; 227  :             CR = BP2_FROM_FLOAT(cos(dPI/np));
; 228  :             STEP = BP2_FROM_FLOAT(2*sin(-dPI/np));
; 229  :         }
; 230  :     }
; 231  : #endif // _M_IX86
; 232  :     SI = DIV2(STEP);                                    // SI = (I32)(sin(-PI/np) * NF2BP2)

  00057	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  0005d	d9 5d d4	 fstp	 DWORD PTR _SI$[ebp]

; 233  : 
; 234  :     ///  comments with three /// show example indexing sequences for np=1024 and times the loop is executed [1x]
; 235  : 
; 236  :     n = 2 * np;                             /// n: 2048

  00060	8b 55 bc	 mov	 edx, DWORD PTR _np$[ebp]
  00063	d1 e2		 shl	 edx, 1
  00065	89 55 e4	 mov	 DWORD PTR _n$[ebp], edx

; 237  :     m = n;

  00068	8b 45 e4	 mov	 eax, DWORD PTR _n$[ebp]
  0006b	89 45 b8	 mov	 DWORD PTR _m$[ebp], eax
$L2403:

; 238  : 
; 239  :     while (m > 4) {                         /// m: {2048, ... 16, 8} [9x]

  0006e	83 7d b8 04	 cmp	 DWORD PTR _m$[ebp], 4
  00072	0f 8e 49 03 00
	00		 jle	 $L2404

; 240  :         l = m >> 1;

  00078	8b 4d b8	 mov	 ecx, DWORD PTR _m$[ebp]
  0007b	d1 f9		 sar	 ecx, 1
  0007d	89 4d c8	 mov	 DWORD PTR _l$[ebp], ecx

; 241  :         CR2 = BP2_FROM_FLOAT(1);                                // cos(0)

  00080	c7 45 f4 00 00
	80 3f		 mov	 DWORD PTR _CR2$[ebp], 1065353216 ; 3f800000H

; 242  :         SI2 = 0;                                                // sin(0)

  00087	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _SI2$[ebp], 0

; 243  :         CR1 = BP2_FROM_FLOAT(1) - MULT_BP2(STEP,SI);    // cos(2*2*PI/m)

  0008e	d9 45 e8	 fld	 DWORD PTR _STEP$[ebp]
  00091	d8 4d d4	 fmul	 DWORD PTR _SI$[ebp]
  00094	d8 2d 00 00 00
	00		 fsubr	 DWORD PTR __real@3f800000
  0009a	d9 5d f8	 fstp	 DWORD PTR _CR1$[ebp]

; 244  :         SI = SI1 = MULT_BP2(STEP,CR);                   // sin(2*2*PI/m)

  0009d	d9 45 e8	 fld	 DWORD PTR _STEP$[ebp]
  000a0	d8 4d c0	 fmul	 DWORD PTR _CR$[ebp]
  000a3	d9 5d ec	 fstp	 DWORD PTR _SI1$[ebp]
  000a6	8b 55 ec	 mov	 edx, DWORD PTR _SI1$[ebp]
  000a9	89 55 d4	 mov	 DWORD PTR _SI$[ebp], edx

; 245  :         CR = CR1;

  000ac	8b 45 f8	 mov	 eax, DWORD PTR _CR1$[ebp]
  000af	89 45 c0	 mov	 DWORD PTR _CR$[ebp], eax

; 246  :         STEP = MUL2(SI1);

  000b2	d9 45 ec	 fld	 DWORD PTR _SI1$[ebp]
  000b5	dc c0		 fadd	 ST(0), ST(0)
  000b7	d9 5d e8	 fstp	 DWORD PTR _STEP$[ebp]

; 247  : 
; 248  :         // Trivial butterflies (angle = 0) 
; 249  :         for (k = 0; k < n; k += m) {        /// k: {0} {0,1024} ... {0,8,16...2044} [512x]

  000ba	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  000c1	eb 09		 jmp	 SHORT $L2407
$L2408:
  000c3	8b 4d d0	 mov	 ecx, DWORD PTR _k$[ebp]
  000c6	03 4d b8	 add	 ecx, DWORD PTR _m$[ebp]
  000c9	89 4d d0	 mov	 DWORD PTR _k$[ebp], ecx
$L2407:
  000cc	8b 55 d0	 mov	 edx, DWORD PTR _k$[ebp]
  000cf	3b 55 e4	 cmp	 edx, DWORD PTR _n$[ebp]
  000d2	0f 8d 26 01 00
	00		 jge	 $L2409

; 250  :             i = k + l;                      /// i: {1024} {1024,2048} ... {4,12,20...2040}

  000d8	8b 45 d0	 mov	 eax, DWORD PTR _k$[ebp]
  000db	03 45 c8	 add	 eax, DWORD PTR _l$[ebp]
  000de	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax

; 251  :             pxk = &px[k];

  000e1	8b 4d d0	 mov	 ecx, DWORD PTR _k$[ebp]
  000e4	8b 55 d8	 mov	 edx, DWORD PTR _px$[ebp]
  000e7	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000ea	89 45 cc	 mov	 DWORD PTR _pxk$[ebp], eax

; 252  :             pxi = &px[i];

  000ed	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  000f0	8b 55 d8	 mov	 edx, DWORD PTR _px$[ebp]
  000f3	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000f6	89 45 fc	 mov	 DWORD PTR _pxi$[ebp], eax

; 253  :             // +1/-1 butterfly 
; 254  :             FFTBUTTERFLY0_N(pxk,pxi);                   // update px[i], px[i+1] and px[k], px[k+1], leave pointers +2

  000f9	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  000fc	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  000ff	d9 01		 fld	 DWORD PTR [ecx]
  00101	d8 22		 fsub	 DWORD PTR [edx]
  00103	d9 5d f0	 fstp	 DWORD PTR _ur$[ebp]
  00106	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  00109	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  0010c	d9 00		 fld	 DWORD PTR [eax]
  0010e	d8 01		 fadd	 DWORD PTR [ecx]
  00110	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  00113	d9 1a		 fstp	 DWORD PTR [edx]
  00115	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  00118	83 c0 04	 add	 eax, 4
  0011b	89 45 cc	 mov	 DWORD PTR _pxk$[ebp], eax
  0011e	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  00121	8b 55 f0	 mov	 edx, DWORD PTR _ur$[ebp]
  00124	89 11		 mov	 DWORD PTR [ecx], edx
  00126	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  00129	83 c0 04	 add	 eax, 4
  0012c	89 45 fc	 mov	 DWORD PTR _pxi$[ebp], eax
  0012f	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  00132	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  00135	d9 01		 fld	 DWORD PTR [ecx]
  00137	d8 22		 fsub	 DWORD PTR [edx]
  00139	d9 5d dc	 fstp	 DWORD PTR _ui$[ebp]
  0013c	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  0013f	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  00142	d9 00		 fld	 DWORD PTR [eax]
  00144	d8 01		 fadd	 DWORD PTR [ecx]
  00146	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  00149	d9 1a		 fstp	 DWORD PTR [edx]
  0014b	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  0014e	83 c0 04	 add	 eax, 4
  00151	89 45 cc	 mov	 DWORD PTR _pxk$[ebp], eax
  00154	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  00157	8b 55 dc	 mov	 edx, DWORD PTR _ui$[ebp]
  0015a	89 11		 mov	 DWORD PTR [ecx], edx
  0015c	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  0015f	83 c0 04	 add	 eax, 4
  00162	89 45 fc	 mov	 DWORD PTR _pxi$[ebp], eax

; 255  :              // +1/-1/W_k butterfly 
; 256  :             FFTBUTTERFLY_N(pxk,pxi,CR1,SI1);    // update px[i+2], px[i+2+1] and px[k+2], px[k+2+1], leave pointers +2

  00165	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  00168	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  0016b	d9 01		 fld	 DWORD PTR [ecx]
  0016d	d8 22		 fsub	 DWORD PTR [edx]
  0016f	d9 5d f0	 fstp	 DWORD PTR _ur$[ebp]
  00172	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  00175	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  00178	d9 00		 fld	 DWORD PTR [eax]
  0017a	d8 01		 fadd	 DWORD PTR [ecx]
  0017c	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  0017f	d9 1a		 fstp	 DWORD PTR [edx]
  00181	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  00184	83 c0 04	 add	 eax, 4
  00187	89 45 fc	 mov	 DWORD PTR _pxi$[ebp], eax
  0018a	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  0018d	83 c1 04	 add	 ecx, 4
  00190	89 4d cc	 mov	 DWORD PTR _pxk$[ebp], ecx
  00193	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  00196	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  00199	d9 02		 fld	 DWORD PTR [edx]
  0019b	d8 20		 fsub	 DWORD PTR [eax]
  0019d	d9 5d dc	 fstp	 DWORD PTR _ui$[ebp]
  001a0	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  001a3	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  001a6	d9 01		 fld	 DWORD PTR [ecx]
  001a8	d8 02		 fadd	 DWORD PTR [edx]
  001aa	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  001ad	d9 18		 fstp	 DWORD PTR [eax]
  001af	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  001b2	83 e9 04	 sub	 ecx, 4
  001b5	89 4d fc	 mov	 DWORD PTR _pxi$[ebp], ecx
  001b8	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  001bb	83 c2 04	 add	 edx, 4
  001be	89 55 cc	 mov	 DWORD PTR _pxk$[ebp], edx
  001c1	d9 45 f8	 fld	 DWORD PTR _CR1$[ebp]
  001c4	d8 4d f0	 fmul	 DWORD PTR _ur$[ebp]
  001c7	d9 45 ec	 fld	 DWORD PTR _SI1$[ebp]
  001ca	d8 4d dc	 fmul	 DWORD PTR _ui$[ebp]
  001cd	de e9		 fsubp	 ST(1), ST(0)
  001cf	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  001d2	d9 18		 fstp	 DWORD PTR [eax]
  001d4	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  001d7	83 c1 04	 add	 ecx, 4
  001da	89 4d fc	 mov	 DWORD PTR _pxi$[ebp], ecx
  001dd	d9 45 f8	 fld	 DWORD PTR _CR1$[ebp]
  001e0	d8 4d dc	 fmul	 DWORD PTR _ui$[ebp]
  001e3	d9 45 ec	 fld	 DWORD PTR _SI1$[ebp]
  001e6	d8 4d f0	 fmul	 DWORD PTR _ur$[ebp]
  001e9	de c1		 faddp	 ST(1), ST(0)
  001eb	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  001ee	d9 1a		 fstp	 DWORD PTR [edx]
  001f0	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  001f3	83 c0 04	 add	 eax, 4
  001f6	89 45 fc	 mov	 DWORD PTR _pxi$[ebp], eax

; 257  :             /* Butterfly at a non-zero angle */ 
; 258  :             //  ur = *pxk - *pxi;           /* ur = px[k] - px[i];    */ \
; 259  :             //  *pxk++ += *pxi++;           /* px[k]   += px[i];      */ \
; 260  :             //  ui = *pxk - *pxi;           /* ui = px[k+1] - px[i+1];*/ \
; 261  :             //  *pxk++ += *pxi--;           /* px[k+1] += px[i+1];    */ \
; 262  :             //  *pxi++ = MULT_BP2(CR,ur) - MULT_BP2(SI,ui);  /* px[i]   = cr * ur - (si) * ui; */ \
; 263  :             //  *pxi++ = MULT_BP2(CR,ui) + MULT_BP2(SI,ur);  /* px[i+1] = cr * ui + (si) * ur; */ \
; 264  :             // leave pxi and pxk incremented by 2
; 265  :             DEBUG_COUNT_BTFLY0(4,0,4);
; 266  :             DEBUG_COUNT_BTFLY1(6,4,6);
; 267  :         }

  001f9	e9 c5 fe ff ff	 jmp	 $L2408
$L2409:

; 268  :         // Nontrivial butterflies 
; 269  :         for (j = 4; j < l; j += 4) {        /// j: {4,8...1020} {4,8,...510} ... {4} {} [~510x]

  001fe	c7 45 b4 04 00
	00 00		 mov	 DWORD PTR _j$[ebp], 4
  00205	eb 09		 jmp	 SHORT $L2410
$L2411:
  00207	8b 4d b4	 mov	 ecx, DWORD PTR _j$[ebp]
  0020a	83 c1 04	 add	 ecx, 4
  0020d	89 4d b4	 mov	 DWORD PTR _j$[ebp], ecx
$L2410:
  00210	8b 55 b4	 mov	 edx, DWORD PTR _j$[ebp]
  00213	3b 55 c8	 cmp	 edx, DWORD PTR _l$[ebp]
  00216	0f 8d 9a 01 00
	00		 jge	 $L2412

; 270  : 
; 271  :             // recurrsion to next sin and cosine values where Theta = 2*PI/m;
; 272  :             // CR2 = cos(-j*Theta);  SI2 = sin(-j*Theta); CR1 = cos((-j-2)*Theta); SI1 = sin((-j-2)*Theta);
; 273  :             // recursion: cos(a-2b) = cos(a) - 2*sin(b)*cos(a-b)
; 274  :             // and:       sin(a-2b) = sin(a) + 2*sin(b)*sin(a-b)
; 275  :             CR2 -= MULT_BP2(STEP,SI1);

  0021c	d9 45 e8	 fld	 DWORD PTR _STEP$[ebp]
  0021f	d8 4d ec	 fmul	 DWORD PTR _SI1$[ebp]
  00222	d8 6d f4	 fsubr	 DWORD PTR _CR2$[ebp]
  00225	d9 5d f4	 fstp	 DWORD PTR _CR2$[ebp]

; 276  :             SI2 += MULT_BP2(STEP,CR1);

  00228	d9 45 e8	 fld	 DWORD PTR _STEP$[ebp]
  0022b	d8 4d f8	 fmul	 DWORD PTR _CR1$[ebp]
  0022e	d8 45 c4	 fadd	 DWORD PTR _SI2$[ebp]
  00231	d9 5d c4	 fstp	 DWORD PTR _SI2$[ebp]

; 277  :             CR1 -= MULT_BP2(STEP,SI2);

  00234	d9 45 e8	 fld	 DWORD PTR _STEP$[ebp]
  00237	d8 4d c4	 fmul	 DWORD PTR _SI2$[ebp]
  0023a	d8 6d f8	 fsubr	 DWORD PTR _CR1$[ebp]
  0023d	d9 5d f8	 fstp	 DWORD PTR _CR1$[ebp]

; 278  :             SI1 += MULT_BP2(STEP,CR2);

  00240	d9 45 e8	 fld	 DWORD PTR _STEP$[ebp]
  00243	d8 4d f4	 fmul	 DWORD PTR _CR2$[ebp]
  00246	d8 45 ec	 fadd	 DWORD PTR _SI1$[ebp]
  00249	d9 5d ec	 fstp	 DWORD PTR _SI1$[ebp]

; 279  : 
; 280  :             // do main butterflies
; 281  :             for (k = j; k <= n; k += m) {   /// k: {{4}{8}...{1020}} {{4,1028}{8,1032}...{508,1020}} ... {{4,20...2044}} [2048x]

  0024c	8b 45 b4	 mov	 eax, DWORD PTR _j$[ebp]
  0024f	89 45 d0	 mov	 DWORD PTR _k$[ebp], eax
  00252	eb 09		 jmp	 SHORT $L2413
$L2414:
  00254	8b 4d d0	 mov	 ecx, DWORD PTR _k$[ebp]
  00257	03 4d b8	 add	 ecx, DWORD PTR _m$[ebp]
  0025a	89 4d d0	 mov	 DWORD PTR _k$[ebp], ecx
$L2413:
  0025d	8b 55 d0	 mov	 edx, DWORD PTR _k$[ebp]
  00260	3b 55 e4	 cmp	 edx, DWORD PTR _n$[ebp]
  00263	0f 8f 48 01 00
	00		 jg	 $L2415

; 282  :                 pxk = &px[k];

  00269	8b 45 d0	 mov	 eax, DWORD PTR _k$[ebp]
  0026c	8b 4d d8	 mov	 ecx, DWORD PTR _px$[ebp]
  0026f	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00272	89 55 cc	 mov	 DWORD PTR _pxk$[ebp], edx

; 283  :                 pxi = &px[k + l];

  00275	8b 45 d0	 mov	 eax, DWORD PTR _k$[ebp]
  00278	03 45 c8	 add	 eax, DWORD PTR _l$[ebp]
  0027b	8b 4d d8	 mov	 ecx, DWORD PTR _px$[ebp]
  0027e	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00281	89 55 fc	 mov	 DWORD PTR _pxi$[ebp], edx

; 284  :                 // +1/-1/W_k butterfly 
; 285  :                 FFTBUTTERFLY_N(pxk,pxi,CR2,SI2);        // update px[i], px[i+1] and px[k], px[k+1], leave pointers at +2

  00284	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  00287	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  0028a	d9 00		 fld	 DWORD PTR [eax]
  0028c	d8 21		 fsub	 DWORD PTR [ecx]
  0028e	d9 5d f0	 fstp	 DWORD PTR _ur$[ebp]
  00291	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  00294	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  00297	d9 02		 fld	 DWORD PTR [edx]
  00299	d8 00		 fadd	 DWORD PTR [eax]
  0029b	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  0029e	d9 19		 fstp	 DWORD PTR [ecx]
  002a0	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  002a3	83 c2 04	 add	 edx, 4
  002a6	89 55 fc	 mov	 DWORD PTR _pxi$[ebp], edx
  002a9	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  002ac	83 c0 04	 add	 eax, 4
  002af	89 45 cc	 mov	 DWORD PTR _pxk$[ebp], eax
  002b2	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  002b5	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  002b8	d9 01		 fld	 DWORD PTR [ecx]
  002ba	d8 22		 fsub	 DWORD PTR [edx]
  002bc	d9 5d dc	 fstp	 DWORD PTR _ui$[ebp]
  002bf	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  002c2	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  002c5	d9 00		 fld	 DWORD PTR [eax]
  002c7	d8 01		 fadd	 DWORD PTR [ecx]
  002c9	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  002cc	d9 1a		 fstp	 DWORD PTR [edx]
  002ce	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  002d1	83 e8 04	 sub	 eax, 4
  002d4	89 45 fc	 mov	 DWORD PTR _pxi$[ebp], eax
  002d7	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  002da	83 c1 04	 add	 ecx, 4
  002dd	89 4d cc	 mov	 DWORD PTR _pxk$[ebp], ecx
  002e0	d9 45 f4	 fld	 DWORD PTR _CR2$[ebp]
  002e3	d8 4d f0	 fmul	 DWORD PTR _ur$[ebp]
  002e6	d9 45 c4	 fld	 DWORD PTR _SI2$[ebp]
  002e9	d8 4d dc	 fmul	 DWORD PTR _ui$[ebp]
  002ec	de e9		 fsubp	 ST(1), ST(0)
  002ee	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  002f1	d9 1a		 fstp	 DWORD PTR [edx]
  002f3	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  002f6	83 c0 04	 add	 eax, 4
  002f9	89 45 fc	 mov	 DWORD PTR _pxi$[ebp], eax
  002fc	d9 45 f4	 fld	 DWORD PTR _CR2$[ebp]
  002ff	d8 4d dc	 fmul	 DWORD PTR _ui$[ebp]
  00302	d9 45 c4	 fld	 DWORD PTR _SI2$[ebp]
  00305	d8 4d f0	 fmul	 DWORD PTR _ur$[ebp]
  00308	de c1		 faddp	 ST(1), ST(0)
  0030a	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  0030d	d9 19		 fstp	 DWORD PTR [ecx]
  0030f	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  00312	83 c2 04	 add	 edx, 4
  00315	89 55 fc	 mov	 DWORD PTR _pxi$[ebp], edx

; 286  :                 // +1/-1/W_k butterfly 
; 287  :                 FFTBUTTERFLY_N(pxk,pxi,CR1,SI1);        // update px[i+2], px[i+2+1] and px[k+2], px[k+2+1], leave pointers at +2

  00318	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  0031b	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  0031e	d9 00		 fld	 DWORD PTR [eax]
  00320	d8 21		 fsub	 DWORD PTR [ecx]
  00322	d9 5d f0	 fstp	 DWORD PTR _ur$[ebp]
  00325	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  00328	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  0032b	d9 02		 fld	 DWORD PTR [edx]
  0032d	d8 00		 fadd	 DWORD PTR [eax]
  0032f	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  00332	d9 19		 fstp	 DWORD PTR [ecx]
  00334	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  00337	83 c2 04	 add	 edx, 4
  0033a	89 55 fc	 mov	 DWORD PTR _pxi$[ebp], edx
  0033d	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  00340	83 c0 04	 add	 eax, 4
  00343	89 45 cc	 mov	 DWORD PTR _pxk$[ebp], eax
  00346	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  00349	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  0034c	d9 01		 fld	 DWORD PTR [ecx]
  0034e	d8 22		 fsub	 DWORD PTR [edx]
  00350	d9 5d dc	 fstp	 DWORD PTR _ui$[ebp]
  00353	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  00356	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  00359	d9 00		 fld	 DWORD PTR [eax]
  0035b	d8 01		 fadd	 DWORD PTR [ecx]
  0035d	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  00360	d9 1a		 fstp	 DWORD PTR [edx]
  00362	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  00365	83 e8 04	 sub	 eax, 4
  00368	89 45 fc	 mov	 DWORD PTR _pxi$[ebp], eax
  0036b	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  0036e	83 c1 04	 add	 ecx, 4
  00371	89 4d cc	 mov	 DWORD PTR _pxk$[ebp], ecx
  00374	d9 45 f8	 fld	 DWORD PTR _CR1$[ebp]
  00377	d8 4d f0	 fmul	 DWORD PTR _ur$[ebp]
  0037a	d9 45 ec	 fld	 DWORD PTR _SI1$[ebp]
  0037d	d8 4d dc	 fmul	 DWORD PTR _ui$[ebp]
  00380	de e9		 fsubp	 ST(1), ST(0)
  00382	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  00385	d9 1a		 fstp	 DWORD PTR [edx]
  00387	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  0038a	83 c0 04	 add	 eax, 4
  0038d	89 45 fc	 mov	 DWORD PTR _pxi$[ebp], eax
  00390	d9 45 f8	 fld	 DWORD PTR _CR1$[ebp]
  00393	d8 4d dc	 fmul	 DWORD PTR _ui$[ebp]
  00396	d9 45 ec	 fld	 DWORD PTR _SI1$[ebp]
  00399	d8 4d f0	 fmul	 DWORD PTR _ur$[ebp]
  0039c	de c1		 faddp	 ST(1), ST(0)
  0039e	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  003a1	d9 19		 fstp	 DWORD PTR [ecx]
  003a3	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  003a6	83 c2 04	 add	 edx, 4
  003a9	89 55 fc	 mov	 DWORD PTR _pxi$[ebp], edx

; 288  :                 /* Butterfly at a non-zero angle */     \
; 289  :                 //  ur = *pxk - *pxi;           /* ur = px[k] - px[i];    */ \
; 290  :                 //  *pxk++ += *pxi++;           /* px[k]   += px[i];      */ \
; 291  :                 //  ui = *pxk - *pxi;           /* ui = px[k+1] - px[i+1];*/ \
; 292  :                 //  *pxk++ += *pxi--;           /* px[k+1] += px[i+1];    */ \
; 293  :                 //  *pxi++ = MULT_BP2(CR,ur) - MULT_BP2(SI,ui);  /* px[i]   = cr * ur - (si) * ui; */ \
; 294  :                 //  *pxi++ = MULT_BP2(CR,ui) + MULT_BP2(SI,ur);  /* px[i+1] = cr * ui + (si) * ur; */ \
; 295  :                 // leave pxi and pxk incremented by 2
; 296  :                 DEBUG_COUNT_BTFLY1(6,4,6);
; 297  :                 DEBUG_COUNT_BTFLY1(6,4,6);
; 298  :                 DEBUG_COUNT_LOOP(2);
; 299  :             }

  003ac	e9 a3 fe ff ff	 jmp	 $L2414
$L2415:

; 300  :             DEBUG_COUNT_TRIG(2,2);
; 301  :             DEBUG_COUNT_TRIG(2,2);
; 302  :             DEBUG_COUNT_LOOP(2);
; 303  :         }

  003b1	e9 51 fe ff ff	 jmp	 $L2411
$L2412:

; 304  :         m  = l;

  003b6	8b 45 c8	 mov	 eax, DWORD PTR _l$[ebp]
  003b9	89 45 b8	 mov	 DWORD PTR _m$[ebp], eax

; 305  :         DEBUG_COUNT_TRIG(2,2);
; 306  :         DEBUG_COUNT_LOOP(2);
; 307  :     }

  003bc	e9 ad fc ff ff	 jmp	 $L2403
$L2404:

; 308  :     if (m > 2) {

  003c1	83 7d b8 02	 cmp	 DWORD PTR _m$[ebp], 2
  003c5	0f 8e a4 00 00
	00		 jle	 $L2416

; 309  :         // m normally exits the loop above == 4, so normally do this except when called with np = 1 or 2
; 310  :         for (j = 0; j < n; j += 4) {        /// j: {0,4...2044}  [512x]

  003cb	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  003d2	eb 09		 jmp	 SHORT $L2417
$L2418:
  003d4	8b 4d b4	 mov	 ecx, DWORD PTR _j$[ebp]
  003d7	83 c1 04	 add	 ecx, 4
  003da	89 4d b4	 mov	 DWORD PTR _j$[ebp], ecx
$L2417:
  003dd	8b 55 b4	 mov	 edx, DWORD PTR _j$[ebp]
  003e0	3b 55 e4	 cmp	 edx, DWORD PTR _n$[ebp]
  003e3	0f 8d 86 00 00
	00		 jge	 $L2416

; 311  :             pxi = (pxk = px+j) + 2;

  003e9	8b 45 b4	 mov	 eax, DWORD PTR _j$[ebp]
  003ec	8b 4d d8	 mov	 ecx, DWORD PTR _px$[ebp]
  003ef	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  003f2	89 55 cc	 mov	 DWORD PTR _pxk$[ebp], edx
  003f5	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  003f8	83 c0 08	 add	 eax, 8
  003fb	89 45 fc	 mov	 DWORD PTR _pxi$[ebp], eax

; 312  :             
; 313  :             // +1/-1 butterfly 
; 314  :             FFTBUTTERFLY0(pxk,pxi);

  003fe	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  00401	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  00404	d9 01		 fld	 DWORD PTR [ecx]
  00406	d8 22		 fsub	 DWORD PTR [edx]
  00408	d9 5d f0	 fstp	 DWORD PTR _ur$[ebp]
  0040b	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  0040e	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  00411	d9 00		 fld	 DWORD PTR [eax]
  00413	d8 01		 fadd	 DWORD PTR [ecx]
  00415	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  00418	d9 1a		 fstp	 DWORD PTR [edx]
  0041a	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  0041d	83 c0 04	 add	 eax, 4
  00420	89 45 cc	 mov	 DWORD PTR _pxk$[ebp], eax
  00423	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  00426	8b 55 f0	 mov	 edx, DWORD PTR _ur$[ebp]
  00429	89 11		 mov	 DWORD PTR [ecx], edx
  0042b	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  0042e	83 c0 04	 add	 eax, 4
  00431	89 45 fc	 mov	 DWORD PTR _pxi$[ebp], eax
  00434	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  00437	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  0043a	d9 01		 fld	 DWORD PTR [ecx]
  0043c	d8 22		 fsub	 DWORD PTR [edx]
  0043e	d9 5d dc	 fstp	 DWORD PTR _ui$[ebp]
  00441	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  00444	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  00447	d9 00		 fld	 DWORD PTR [eax]
  00449	d8 01		 fadd	 DWORD PTR [ecx]
  0044b	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  0044e	d9 1a		 fstp	 DWORD PTR [edx]
  00450	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  00453	83 c0 04	 add	 eax, 4
  00456	89 45 cc	 mov	 DWORD PTR _pxk$[ebp], eax
  00459	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  0045c	8b 55 dc	 mov	 edx, DWORD PTR _ui$[ebp]
  0045f	89 11		 mov	 DWORD PTR [ecx], edx
  00461	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  00464	83 c0 04	 add	 eax, 4
  00467	89 45 fc	 mov	 DWORD PTR _pxi$[ebp], eax

; 315  :             DEBUG_COUNT_BTFLY0(4,0,4);
; 316  :             DEBUG_COUNT_LOOP(2);
; 317  :         }

  0046a	e9 65 ff ff ff	 jmp	 $L2418
$L2416:

; 318  :     }
; 319  :     if (n > 4) {

  0046f	83 7d e4 04	 cmp	 DWORD PTR _n$[ebp], 4
  00473	0f 8e 95 01 00
	00		 jle	 $L2380

; 320  :         I32 n2, n21;
; 321  :         CoefType tmp;
; 322  : 
; 323  :         n2 = np / 2;                        /// n2: 512

  00479	8b 45 bc	 mov	 eax, DWORD PTR _np$[ebp]
  0047c	99		 cdq
  0047d	2b c2		 sub	 eax, edx
  0047f	d1 f8		 sar	 eax, 1
  00481	89 45 ac	 mov	 DWORD PTR _n2$2421[ebp], eax

; 324  :         n21 = np + 1;                       /// n21: 1025

  00484	8b 4d bc	 mov	 ecx, DWORD PTR _np$[ebp]
  00487	83 c1 01	 add	 ecx, 1
  0048a	89 4d a8	 mov	 DWORD PTR _n21$2422[ebp], ecx

; 325  :         j = 0;                              

  0048d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0

; 326  :         for (i = 0; i < np; i += 4) {       /// i,j: 0,0; 4,1024; 8,512; 12,1536; ... 2044,??? [255x]

  00494	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0049b	eb 09		 jmp	 SHORT $L2424
$L2425:
  0049d	8b 55 e0	 mov	 edx, DWORD PTR _i$[ebp]
  004a0	83 c2 04	 add	 edx, 4
  004a3	89 55 e0	 mov	 DWORD PTR _i$[ebp], edx
$L2424:
  004a6	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  004a9	3b 45 bc	 cmp	 eax, DWORD PTR _np$[ebp]
  004ac	0f 8d 5c 01 00
	00		 jge	 $L2380

; 327  : 
; 328  :             if (i < j) {

  004b2	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  004b5	3b 4d b4	 cmp	 ecx, DWORD PTR _j$[ebp]
  004b8	0f 8d bc 00 00
	00		 jge	 $L2427

; 329  :                 // swap 4 pairs of values (2 complex pairs with 2 others)
; 330  :                 // px[i] <-> px[j]; px[i+1] <-> px[j+1]
; 331  :                 // px[i+1+n21] <-> px[j+1+n21];  px[i+1+n21+1] <-> px[j+1+n21+1]
; 332  :                 pxi = &px[i];

  004be	8b 55 e0	 mov	 edx, DWORD PTR _i$[ebp]
  004c1	8b 45 d8	 mov	 eax, DWORD PTR _px$[ebp]
  004c4	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  004c7	89 4d fc	 mov	 DWORD PTR _pxi$[ebp], ecx

; 333  :                 pxk = &px[j];

  004ca	8b 55 b4	 mov	 edx, DWORD PTR _j$[ebp]
  004cd	8b 45 d8	 mov	 eax, DWORD PTR _px$[ebp]
  004d0	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  004d3	89 4d cc	 mov	 DWORD PTR _pxk$[ebp], ecx

; 334  :                 tmp = *pxi; 

  004d6	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  004d9	8b 02		 mov	 eax, DWORD PTR [edx]
  004db	89 45 b0	 mov	 DWORD PTR _tmp$2423[ebp], eax

; 335  :                 *pxi++ = *pxk;

  004de	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  004e1	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  004e4	8b 02		 mov	 eax, DWORD PTR [edx]
  004e6	89 01		 mov	 DWORD PTR [ecx], eax
  004e8	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  004eb	83 c1 04	 add	 ecx, 4
  004ee	89 4d fc	 mov	 DWORD PTR _pxi$[ebp], ecx

; 336  :                 *pxk++ = tmp;

  004f1	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  004f4	8b 45 b0	 mov	 eax, DWORD PTR _tmp$2423[ebp]
  004f7	89 02		 mov	 DWORD PTR [edx], eax
  004f9	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  004fc	83 c1 04	 add	 ecx, 4
  004ff	89 4d cc	 mov	 DWORD PTR _pxk$[ebp], ecx

; 337  :                 tmp = *pxi;

  00502	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  00505	8b 02		 mov	 eax, DWORD PTR [edx]
  00507	89 45 b0	 mov	 DWORD PTR _tmp$2423[ebp], eax

; 338  :                 *pxi = *pxk;

  0050a	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  0050d	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  00510	8b 02		 mov	 eax, DWORD PTR [edx]
  00512	89 01		 mov	 DWORD PTR [ecx], eax

; 339  :                 *pxk = tmp;

  00514	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  00517	8b 55 b0	 mov	 edx, DWORD PTR _tmp$2423[ebp]
  0051a	89 11		 mov	 DWORD PTR [ecx], edx

; 340  :                 pxi  += n21;

  0051c	8b 45 a8	 mov	 eax, DWORD PTR _n21$2422[ebp]
  0051f	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  00522	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00525	89 55 fc	 mov	 DWORD PTR _pxi$[ebp], edx

; 341  :                 pxk  += n21;

  00528	8b 45 a8	 mov	 eax, DWORD PTR _n21$2422[ebp]
  0052b	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  0052e	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00531	89 55 cc	 mov	 DWORD PTR _pxk$[ebp], edx

; 342  :                 tmp = *pxi;

  00534	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  00537	8b 08		 mov	 ecx, DWORD PTR [eax]
  00539	89 4d b0	 mov	 DWORD PTR _tmp$2423[ebp], ecx

; 343  :                 *pxi++ = *pxk;

  0053c	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  0053f	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  00542	8b 08		 mov	 ecx, DWORD PTR [eax]
  00544	89 0a		 mov	 DWORD PTR [edx], ecx
  00546	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  00549	83 c2 04	 add	 edx, 4
  0054c	89 55 fc	 mov	 DWORD PTR _pxi$[ebp], edx

; 344  :                 *pxk++ = tmp;

  0054f	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  00552	8b 4d b0	 mov	 ecx, DWORD PTR _tmp$2423[ebp]
  00555	89 08		 mov	 DWORD PTR [eax], ecx
  00557	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  0055a	83 c2 04	 add	 edx, 4
  0055d	89 55 cc	 mov	 DWORD PTR _pxk$[ebp], edx

; 345  :                 tmp = *pxi;

  00560	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  00563	8b 08		 mov	 ecx, DWORD PTR [eax]
  00565	89 4d b0	 mov	 DWORD PTR _tmp$2423[ebp], ecx

; 346  :                 *pxi = *pxk;

  00568	8b 55 fc	 mov	 edx, DWORD PTR _pxi$[ebp]
  0056b	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  0056e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00570	89 0a		 mov	 DWORD PTR [edx], ecx

; 347  :                 *pxk = tmp;

  00572	8b 55 cc	 mov	 edx, DWORD PTR _pxk$[ebp]
  00575	8b 45 b0	 mov	 eax, DWORD PTR _tmp$2423[ebp]
  00578	89 02		 mov	 DWORD PTR [edx], eax
$L2427:

; 348  :             }
; 349  : 
; 350  :             // swap 2 pairs of values (1 complex pair with another)
; 351  :             // px[i+2] <-> px[j+np];  px[i+3] <-> px[j+np+1]
; 352  :             pxi = &px[i+2];

  0057a	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  0057d	8b 55 d8	 mov	 edx, DWORD PTR _px$[ebp]
  00580	8d 44 8a 08	 lea	 eax, DWORD PTR [edx+ecx*4+8]
  00584	89 45 fc	 mov	 DWORD PTR _pxi$[ebp], eax

; 353  :             pxk = &px[j+np];

  00587	8b 4d b4	 mov	 ecx, DWORD PTR _j$[ebp]
  0058a	03 4d bc	 add	 ecx, DWORD PTR _np$[ebp]
  0058d	8b 55 d8	 mov	 edx, DWORD PTR _px$[ebp]
  00590	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00593	89 45 cc	 mov	 DWORD PTR _pxk$[ebp], eax

; 354  :             tmp = *pxi; 

  00596	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  00599	8b 11		 mov	 edx, DWORD PTR [ecx]
  0059b	89 55 b0	 mov	 DWORD PTR _tmp$2423[ebp], edx

; 355  :             *pxi++ = *pxk;

  0059e	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  005a1	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  005a4	8b 11		 mov	 edx, DWORD PTR [ecx]
  005a6	89 10		 mov	 DWORD PTR [eax], edx
  005a8	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  005ab	83 c0 04	 add	 eax, 4
  005ae	89 45 fc	 mov	 DWORD PTR _pxi$[ebp], eax

; 356  :             *pxk++ = tmp;

  005b1	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  005b4	8b 55 b0	 mov	 edx, DWORD PTR _tmp$2423[ebp]
  005b7	89 11		 mov	 DWORD PTR [ecx], edx
  005b9	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  005bc	83 c0 04	 add	 eax, 4
  005bf	89 45 cc	 mov	 DWORD PTR _pxk$[ebp], eax

; 357  :             tmp = *pxi;

  005c2	8b 4d fc	 mov	 ecx, DWORD PTR _pxi$[ebp]
  005c5	8b 11		 mov	 edx, DWORD PTR [ecx]
  005c7	89 55 b0	 mov	 DWORD PTR _tmp$2423[ebp], edx

; 358  :             *pxi = *pxk;

  005ca	8b 45 fc	 mov	 eax, DWORD PTR _pxi$[ebp]
  005cd	8b 4d cc	 mov	 ecx, DWORD PTR _pxk$[ebp]
  005d0	8b 11		 mov	 edx, DWORD PTR [ecx]
  005d2	89 10		 mov	 DWORD PTR [eax], edx

; 359  :             *pxk = tmp;

  005d4	8b 45 cc	 mov	 eax, DWORD PTR _pxk$[ebp]
  005d7	8b 4d b0	 mov	 ecx, DWORD PTR _tmp$2423[ebp]
  005da	89 08		 mov	 DWORD PTR [eax], ecx

; 360  : 
; 361  :             k = n2;                         

  005dc	8b 55 ac	 mov	 edx, DWORD PTR _n2$2421[ebp]
  005df	89 55 d0	 mov	 DWORD PTR _k$[ebp], edx
$L2429:

; 362  :             while (k <= j) {                /// k: {1024} {1024,512} {1024} {1024,512,256} ...

  005e2	8b 45 d0	 mov	 eax, DWORD PTR _k$[ebp]
  005e5	3b 45 b4	 cmp	 eax, DWORD PTR _j$[ebp]
  005e8	7f 16		 jg	 SHORT $L2430

; 363  :                 j -= k;

  005ea	8b 4d b4	 mov	 ecx, DWORD PTR _j$[ebp]
  005ed	2b 4d d0	 sub	 ecx, DWORD PTR _k$[ebp]
  005f0	89 4d b4	 mov	 DWORD PTR _j$[ebp], ecx

; 364  :                 k = k / 2;

  005f3	8b 45 d0	 mov	 eax, DWORD PTR _k$[ebp]
  005f6	99		 cdq
  005f7	2b c2		 sub	 eax, edx
  005f9	d1 f8		 sar	 eax, 1
  005fb	89 45 d0	 mov	 DWORD PTR _k$[ebp], eax

; 365  :             }

  005fe	eb e2		 jmp	 SHORT $L2429
$L2430:

; 366  :             j += k;                         /// j: {1024} {512} {1536} {256} ...

  00600	8b 55 b4	 mov	 edx, DWORD PTR _j$[ebp]
  00603	03 55 d0	 add	 edx, DWORD PTR _k$[ebp]
  00606	89 55 b4	 mov	 DWORD PTR _j$[ebp], edx

; 367  :         }

  00609	e9 8f fe ff ff	 jmp	 $L2425
$L2380:

; 368  :     }
; 369  :     FUNCTION_PROFILE_STOP(&fp);
; 370  : }

  0060e	8b e5		 mov	 esp, ebp
  00610	5d		 pop	 ebp
  00611	c2 08 00	 ret	 8
_prvFFT4DCT_XDS@8 ENDP
WMADEC	ENDS
PUBLIC	_auDctIV_XDS@16
PUBLIC	__real@40000000
PUBLIC	_LOG2@4
EXTRN	_rgSinCosTables:BYTE
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _auDctIV_XDS@16
WMADEC	SEGMENT
_dSB$2474 = -176
_dA$2473 = -168
_CR$ = -160
_iTi$ = -156
_iBr$ = -152
_CI$ = -148
_UR$ = -144
_iFFTSize$ = -140
_d1Qp0$ = -136
_fac$ = -128
_dPI$ = -120
_d1p0$ = -112
_UI$ = -104
_nLog2SB$ = -100
_iFac$ = -96
_pSinCosTable$ = -92
_dPIby4$ = -88
_CI2$ = -76
_d2p0$ = -72
_iBi$ = -60
_STEP$ = -56
_CI1$ = -52
_i$ = -48
_cSB$ = -44
_d1Hp0$ = -40
_iTr$ = -32
_CR1$ = -28
_CR2$ = -24
_piCoefTop$ = -20
_piCoefBottom$ = -16
_piCoefBottomOut$ = -12
_dPI3Q$ = -8
_pau$ = 8
_rgiCoef$ = 12
_fltAfterScaleFactor$ = 16
_piMagnitude$ = 20
_auDctIV_XDS@16 PROC NEAR				; COMDAT

; 815  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H

; 816  :     CoefType *piCoefTop, *piCoefBottom, *piCoefBottomOut;
; 817  :     CoefType iTr, iTi, iBr, iBi;
; 818  :     BP1Type CR, CI, UR, UI, STEP, CR1, CI1, CR2, CI2;
; 819  :     Int iFFTSize, i, cSB, nLog2SB;
; 820  :     BP1Type  iFac;
; 821  :     const SinCosTable* pSinCosTable;
; 822  :     double fac;
; 823  :     const double dPI = PI;

  00009	c7 45 88 18 2d
	44 54		 mov	 DWORD PTR _dPI$[ebp], 1413754136 ; 54442d18H
  00010	c7 45 8c fb 21
	09 40		 mov	 DWORD PTR _dPI$[ebp+4], 1074340347 ; 400921fbH

; 824  :     const double dPI3Q = 3*PI/4;                        // PI (-1/4 + 1)

  00017	c7 45 f8 d2 21
	33 7f		 mov	 DWORD PTR _dPI3Q$[ebp], 2134057426 ; 7f3321d2H
  0001e	c7 45 fc 7c d9
	02 40		 mov	 DWORD PTR _dPI3Q$[ebp+4], 1073928572 ; 4002d97cH

; 825  :     const double dPIby4 = PI/4;

  00025	c7 45 a8 18 2d
	44 54		 mov	 DWORD PTR _dPIby4$[ebp], 1413754136 ; 54442d18H
  0002c	c7 45 ac fb 21
	e9 3f		 mov	 DWORD PTR _dPIby4$[ebp+4], 1072243195 ; 3fe921fbH

; 826  : #if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
; 827  :     const double d1p0   = 1.0 * NF2BP1;
; 828  :     const double d2p0   = 2.0 * NF2BP1;
; 829  :     const double d1Hp0  = 0.5 * NF2BP1;
; 830  :     const double d1Qp0  = 0.25* NF2BP1;
; 831  :     Int nFacExponent;
; 832  :     U32 iMagnitude = 0;
; 833  : #else  // must be BUILD_INT_FLOAT
; 834  :     const double d1p0   = 1.0;

  00033	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _d1p0$[ebp], 0
  0003a	c7 45 94 00 00
	f0 3f		 mov	 DWORD PTR _d1p0$[ebp+4], 1072693248 ; 3ff00000H

; 835  :     const double d2p0   = 2.0;

  00041	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _d2p0$[ebp], 0
  00048	c7 45 bc 00 00
	00 40		 mov	 DWORD PTR _d2p0$[ebp+4], 1073741824 ; 40000000H

; 836  :     const double d1Hp0  = 0.5;

  0004f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _d1Hp0$[ebp], 0
  00056	c7 45 dc 00 00
	e0 3f		 mov	 DWORD PTR _d1Hp0$[ebp+4], 1071644672 ; 3fe00000H

; 837  :     const double d1Qp0  = 0.25;

  0005d	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _d1Qp0$[ebp], 0
  00067	c7 85 7c ff ff
	ff 00 00 d0 3f	 mov	 DWORD PTR _d1Qp0$[ebp+4], 1070596096 ; 3fd00000H

; 838  : #endif  // BUILD_INTEGER or BUILD_INT_FLOAT
; 839  : #ifdef INTEGER_ENCODER
; 840  :     Int iScaleFactor;
; 841  : #endif
; 842  : 
; 843  :     FUNCTION_PROFILE(fp);
; 844  :     FUNCTION_PROFILE_START(&fp,DCTIV_PROFILE);
; 845  : 
; 846  :     // m_cSubbandAdjusted below deals with the need to scale transform results to compensate the fact 
; 847  :     // that we're inv transforming coefficients from a transform that was twice or half our size
; 848  : 
; 849  :     cSB = pau->m_cSubbandAdjusted;

  00071	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00074	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00077	89 4d d4	 mov	 DWORD PTR _cSB$[ebp], ecx

; 850  :     iFFTSize = cSB/2;

  0007a	8b 45 d4	 mov	 eax, DWORD PTR _cSB$[ebp]
  0007d	99		 cdq
  0007e	2b c2		 sub	 eax, edx
  00080	d1 f8		 sar	 eax, 1
  00082	89 85 74 ff ff
	ff		 mov	 DWORD PTR _iFFTSize$[ebp], eax

; 851  :     nLog2SB = LOG2( cSB );

  00088	8b 55 d4	 mov	 edx, DWORD PTR _cSB$[ebp]
  0008b	52		 push	 edx
  0008c	e8 00 00 00 00	 call	 _LOG2@4
  00091	89 45 9c	 mov	 DWORD PTR _nLog2SB$[ebp], eax

; 852  : 
; 853  :     piCoefTop          = rgiCoef;               

  00094	8b 45 0c	 mov	 eax, DWORD PTR _rgiCoef$[ebp]
  00097	89 45 ec	 mov	 DWORD PTR _piCoefTop$[ebp], eax

; 854  :     piCoefBottom       = rgiCoef + cSB - 1;

  0009a	8b 4d d4	 mov	 ecx, DWORD PTR _cSB$[ebp]
  0009d	8b 55 0c	 mov	 edx, DWORD PTR _rgiCoef$[ebp]
  000a0	8d 44 8a fc	 lea	 eax, DWORD PTR [edx+ecx*4-4]
  000a4	89 45 f0	 mov	 DWORD PTR _piCoefBottom$[ebp], eax

; 855  :     piCoefBottomOut    = rgiCoef + cSB - 1;     // separate pointer now obsolete but still used

  000a7	8b 4d d4	 mov	 ecx, DWORD PTR _cSB$[ebp]
  000aa	8b 55 0c	 mov	 edx, DWORD PTR _rgiCoef$[ebp]
  000ad	8d 44 8a fc	 lea	 eax, DWORD PTR [edx+ecx*4-4]
  000b1	89 45 f4	 mov	 DWORD PTR _piCoefBottomOut$[ebp], eax

; 856  : 
; 857  : #if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
; 858  :     prvWmaShowFrames(pau, "DCT", " %4d 0x%08x 0x%08x", cSB, piCoefTop, piCoefBottom);
; 859  : #endif
; 860  : 
; 861  :     // fltAfterScaleFactor:  V2: 2/cSB == 1/iFFTSize and V1: sqrt(2/cSB)
; 862  : #if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
; 863  :     fac = fltAfterScaleFactor * cSB * d1Qp0;
; 864  :     for( nFacExponent = 0; fabs(fac) > d1p0; nFacExponent++ )
; 865  :         fac /= 2.0f;        // SH warning CBE4717 here is ignorable
; 866  : #else   // must be BUILD_INT_FLOAT
; 867  :     fac = fltAfterScaleFactor;

  000b4	d9 45 10	 fld	 DWORD PTR _fltAfterScaleFactor$[ebp]
  000b7	dd 5d 80	 fstp	 QWORD PTR _fac$[ebp]

; 868  : #endif
; 869  : 
; 870  :     // initialize sin/cos recursion
; 871  :     // note this style of recurrsion is more accurate than Numerical Recipies 5.5.6
; 872  :     if ( 64 <= cSB && cSB <= 2048 )

  000ba	83 7d d4 40	 cmp	 DWORD PTR _cSB$[ebp], 64 ; 00000040H
  000be	7c 78		 jl	 SHORT $L2470
  000c0	81 7d d4 00 08
	00 00		 cmp	 DWORD PTR _cSB$[ebp], 2048 ; 00000800H
  000c7	7f 6f		 jg	 SHORT $L2470

; 873  :     {
; 874  :         pSinCosTable = rgSinCosTables[cSB>>7];

  000c9	8b 4d d4	 mov	 ecx, DWORD PTR _cSB$[ebp]
  000cc	c1 f9 07	 sar	 ecx, 7
  000cf	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _rgSinCosTables[ecx*4]
  000d6	89 55 a4	 mov	 DWORD PTR _pSinCosTable$[ebp], edx

; 875  : #       if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
; 876  :             iFac = (I32)ROUNDD( fac );
; 877  : #       else  // must be BUILD_INT_FLOAT
; 878  :             iFac = (BP1Type)fac;

  000d9	dd 45 80	 fld	 QWORD PTR _fac$[ebp]
  000dc	d9 5d a0	 fstp	 DWORD PTR _iFac$[ebp]

; 879  : #       endif // BUILD_INTEGER or BUILD_INT_FLOAT
; 880  :         // initial cosine/sine values
; 881  :         CR =  MULT_BP1(iFac,pSinCosTable->cos_PIby4cSB);        // CR = (I32)(fac*cos(-PI/(4*m_cSubband)) * NF2BP1)

  000df	8b 45 a4	 mov	 eax, DWORD PTR _pSinCosTable$[ebp]
  000e2	d9 40 04	 fld	 DWORD PTR [eax+4]
  000e5	d8 4d a0	 fmul	 DWORD PTR _iFac$[ebp]
  000e8	d9 9d 60 ff ff
	ff		 fstp	 DWORD PTR _CR$[ebp]

; 882  :         CI = -MULT_BP1(iFac,pSinCosTable->sin_PIby4cSB);        // CI = (I32)(fac*sin(-PI/(4*m_cSubband)) * NF2BP1)

  000ee	8b 4d a4	 mov	 ecx, DWORD PTR _pSinCosTable$[ebp]
  000f1	d9 45 a0	 fld	 DWORD PTR _iFac$[ebp]
  000f4	d8 09		 fmul	 DWORD PTR [ecx]
  000f6	d9 e0		 fchs
  000f8	d9 9d 6c ff ff
	ff		 fstp	 DWORD PTR _CI$[ebp]

; 883  :         // prior cosine/sine values to init Pre-FFT recurrsion trig( -PI/(4*M) - (-PI/M ) = trig( 3*PI/(4*M) )
; 884  :         CR1 =  MULT_BP1(iFac,pSinCosTable->cos_3PIby4cSB);  // CR = (I32)(fac*cos(+3*PI/(4*m_cSubband)) * NF2BP1)

  000fe	8b 55 a4	 mov	 edx, DWORD PTR _pSinCosTable$[ebp]
  00101	d9 42 0c	 fld	 DWORD PTR [edx+12]
  00104	d8 4d a0	 fmul	 DWORD PTR _iFac$[ebp]
  00107	d9 5d e4	 fstp	 DWORD PTR _CR1$[ebp]

; 885  :         CI1 =  MULT_BP1(iFac,pSinCosTable->sin_3PIby4cSB);  // CI = (I32)(fac*sin(+3*PI/(4*m_cSubband)) * NF2BP1)

  0010a	8b 45 a4	 mov	 eax, DWORD PTR _pSinCosTable$[ebp]
  0010d	d9 40 08	 fld	 DWORD PTR [eax+8]
  00110	d8 4d a0	 fmul	 DWORD PTR _iFac$[ebp]
  00113	d9 5d cc	 fstp	 DWORD PTR _CI1$[ebp]

; 886  :         // rotation step for both recurrsions
; 887  :         STEP = -pSinCosTable->two_sin_PIbycSB;              // STEP = 2*sin(-PI/m_cSubband) 

  00116	8b 4d a4	 mov	 ecx, DWORD PTR _pSinCosTable$[ebp]
  00119	d9 41 28	 fld	 DWORD PTR [ecx+40]
  0011c	d9 e0		 fchs
  0011e	d9 5d c8	 fstp	 DWORD PTR _STEP$[ebp]

; 888  :         // prior cosine/sine values to init Post-FFT recurrsion
; 889  :         CR2 =  pSinCosTable->cos_PIbycSB;                   // CR = (I32)(cos( PI/m_cSubband) * NF2BP1)

  00121	8b 55 a4	 mov	 edx, DWORD PTR _pSinCosTable$[ebp]
  00124	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00127	89 45 e8	 mov	 DWORD PTR _CR2$[ebp], eax

; 890  :         CI2 =  pSinCosTable->sin_PIbycSB;                   // CI = (I32)(sin( PI/m_cSubband) * NF2BP1)

  0012a	8b 4d a4	 mov	 ecx, DWORD PTR _pSinCosTable$[ebp]
  0012d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00130	89 55 b4	 mov	 DWORD PTR _CI2$[ebp], edx

; 891  :     }
; 892  :     else

  00133	e9 f2 00 00 00	 jmp	 $L2472
$L2470:

; 893  :     {   // not normally needed in decoder, here for generality
; 894  :         double dA, dSB;
; 895  : 
; 896  :         dA = -dPIby4 / (dSB=cSB);

  00138	db 45 d4	 fild	 DWORD PTR _cSB$[ebp]
  0013b	dd 95 50 ff ff
	ff		 fst	 QWORD PTR _dSB$2474[ebp]
  00141	dd 45 a8	 fld	 QWORD PTR _dPIby4$[ebp]
  00144	d9 e0		 fchs
  00146	de f1		 fdivrp	 ST(1), ST(0)
  00148	dd 9d 58 ff ff
	ff		 fstp	 QWORD PTR _dA$2473[ebp]

; 897  :         CR = (BP1Type)( fac * cos( dA ) );

  0014e	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _dA$2473[ebp+4]
  00154	50		 push	 eax
  00155	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _dA$2473[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _cos
  00161	83 c4 08	 add	 esp, 8
  00164	dc 4d 80	 fmul	 QWORD PTR _fac$[ebp]
  00167	d9 9d 60 ff ff
	ff		 fstp	 DWORD PTR _CR$[ebp]

; 898  :         CI = (BP1Type)( fac * sin( dA ) );

  0016d	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _dA$2473[ebp+4]
  00173	52		 push	 edx
  00174	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _dA$2473[ebp]
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 _sin
  00180	83 c4 08	 add	 esp, 8
  00183	dc 4d 80	 fmul	 QWORD PTR _fac$[ebp]
  00186	d9 9d 6c ff ff
	ff		 fstp	 DWORD PTR _CI$[ebp]

; 899  :         dA = dPI3Q / dSB;

  0018c	dd 45 f8	 fld	 QWORD PTR _dPI3Q$[ebp]
  0018f	dc b5 50 ff ff
	ff		 fdiv	 QWORD PTR _dSB$2474[ebp]
  00195	dd 9d 58 ff ff
	ff		 fstp	 QWORD PTR _dA$2473[ebp]

; 900  :         CR1 = (BP1Type)( fac * cos( dA ) );

  0019b	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _dA$2473[ebp+4]
  001a1	51		 push	 ecx
  001a2	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _dA$2473[ebp]
  001a8	52		 push	 edx
  001a9	e8 00 00 00 00	 call	 _cos
  001ae	83 c4 08	 add	 esp, 8
  001b1	dc 4d 80	 fmul	 QWORD PTR _fac$[ebp]
  001b4	d9 5d e4	 fstp	 DWORD PTR _CR1$[ebp]

; 901  :         CI1 = (BP1Type)( fac * sin( dA ) );

  001b7	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _dA$2473[ebp+4]
  001bd	50		 push	 eax
  001be	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _dA$2473[ebp]
  001c4	51		 push	 ecx
  001c5	e8 00 00 00 00	 call	 _sin
  001ca	83 c4 08	 add	 esp, 8
  001cd	dc 4d 80	 fmul	 QWORD PTR _fac$[ebp]
  001d0	d9 5d cc	 fstp	 DWORD PTR _CI1$[ebp]

; 902  :         dA = -dPI / dSB;

  001d3	dd 45 88	 fld	 QWORD PTR _dPI$[ebp]
  001d6	d9 e0		 fchs
  001d8	dc b5 50 ff ff
	ff		 fdiv	 QWORD PTR _dSB$2474[ebp]
  001de	dd 9d 58 ff ff
	ff		 fstp	 QWORD PTR _dA$2473[ebp]

; 903  :         STEP = (BP1Type)( d2p0 * sin( dA ) );

  001e4	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _dA$2473[ebp+4]
  001ea	52		 push	 edx
  001eb	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _dA$2473[ebp]
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 _sin
  001f7	83 c4 08	 add	 esp, 8
  001fa	dc 4d b8	 fmul	 QWORD PTR _d2p0$[ebp]
  001fd	d9 5d c8	 fstp	 DWORD PTR _STEP$[ebp]

; 904  :         CR2  = (BP1Type)( d1p0 * cos( dA ) );

  00200	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _dA$2473[ebp+4]
  00206	51		 push	 ecx
  00207	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _dA$2473[ebp]
  0020d	52		 push	 edx
  0020e	e8 00 00 00 00	 call	 _cos
  00213	83 c4 08	 add	 esp, 8
  00216	dc 4d 90	 fmul	 QWORD PTR _d1p0$[ebp]
  00219	d9 5d e8	 fstp	 DWORD PTR _CR2$[ebp]

; 905  :         CI2  = -STEP/2;  

  0021c	d9 45 c8	 fld	 DWORD PTR _STEP$[ebp]
  0021f	d9 e0		 fchs
  00221	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@40000000
  00227	d9 5d b4	 fstp	 DWORD PTR _CI2$[ebp]
$L2472:

; 906  :     }
; 907  : 
; 908  :     // Include the next code-block to verify changes to the lookup-table
; 909  : #if 0
; 910  :     {
; 911  : #       if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
; 912  :             const BP1Type Theshold = 1;
; 913  : #       else
; 914  :             const BP1Type Theshold = BP1_FROM_FLOAT(0.001F*fac);
; 915  : #       endif
; 916  :         assert(BPX_ABS(CR - (BP1Type)( fac * cos(-dPIby4 / cSB) )) <= Theshold);
; 917  :         assert(BPX_ABS(CI - (BP1Type)( fac * sin(-dPIby4 / cSB) )) <= Theshold);
; 918  :         assert(BPX_ABS(CR1 - (BP1Type)( fac * cos(dPI3Q / cSB) )) <= Theshold);
; 919  :         assert(BPX_ABS(CI1 - (BP1Type)( fac * sin(dPI3Q / cSB) )) <= Theshold);
; 920  :         assert(BPX_ABS(STEP - (BP1Type)( d2p0 * sin(-dPI / cSB) )) <= Theshold);
; 921  :         assert(BPX_ABS(CR2  - (BP1Type)( d1p0 * cos(-dPI / cSB) )) <= Theshold);
; 922  :         assert(BPX_ABS(CI2  - DIV2((-(BP1Type)( d2p0 * sin(-dPI / cSB) )))) <= Theshold);
; 923  :     }
; 924  : #endif
; 925  : 
; 926  :     DCT_DOPRINT_IN(1.0,rgiCoef);
; 927  : 
; 928  :     for (i = iFFTSize/2; i > 0; i--) {

  0022a	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _iFFTSize$[ebp]
  00230	99		 cdq
  00231	2b c2		 sub	 eax, edx
  00233	d1 f8		 sar	 eax, 1
  00235	89 45 d0	 mov	 DWORD PTR _i$[ebp], eax
  00238	eb 09		 jmp	 SHORT $L2481
$L2482:
  0023a	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  0023d	83 e8 01	 sub	 eax, 1
  00240	89 45 d0	 mov	 DWORD PTR _i$[ebp], eax
$L2481:
  00243	83 7d d0 00	 cmp	 DWORD PTR _i$[ebp], 0
  00247	0f 8e b6 00 00
	00		 jle	 $L2483

; 929  :         iBi = piCoefBottom[0];

  0024d	8b 4d f0	 mov	 ecx, DWORD PTR _piCoefBottom$[ebp]
  00250	8b 11		 mov	 edx, DWORD PTR [ecx]
  00252	89 55 c4	 mov	 DWORD PTR _iBi$[ebp], edx

; 930  :         piCoefBottomOut[0] = piCoefTop[1];

  00255	8b 45 f4	 mov	 eax, DWORD PTR _piCoefBottomOut$[ebp]
  00258	8b 4d ec	 mov	 ecx, DWORD PTR _piCoefTop$[ebp]
  0025b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0025e	89 10		 mov	 DWORD PTR [eax], edx

; 931  : 
; 932  :         iTr = piCoefTop[0];

  00260	8b 45 ec	 mov	 eax, DWORD PTR _piCoefTop$[ebp]
  00263	8b 08		 mov	 ecx, DWORD PTR [eax]
  00265	89 4d e0	 mov	 DWORD PTR _iTr$[ebp], ecx

; 933  :         piCoefTop[0] = MULT_BP1(CR,iTr) - MULT_BP1(CI,iBi);

  00268	d9 85 60 ff ff
	ff		 fld	 DWORD PTR _CR$[ebp]
  0026e	d8 4d e0	 fmul	 DWORD PTR _iTr$[ebp]
  00271	d9 85 6c ff ff
	ff		 fld	 DWORD PTR _CI$[ebp]
  00277	d8 4d c4	 fmul	 DWORD PTR _iBi$[ebp]
  0027a	de e9		 fsubp	 ST(1), ST(0)
  0027c	8b 55 ec	 mov	 edx, DWORD PTR _piCoefTop$[ebp]
  0027f	d9 1a		 fstp	 DWORD PTR [edx]

; 934  :         piCoefTop[1] = MULT_BP1(CR,iBi) + MULT_BP1(CI,iTr);

  00281	d9 85 60 ff ff
	ff		 fld	 DWORD PTR _CR$[ebp]
  00287	d8 4d c4	 fmul	 DWORD PTR _iBi$[ebp]
  0028a	d9 85 6c ff ff
	ff		 fld	 DWORD PTR _CI$[ebp]
  00290	d8 4d e0	 fmul	 DWORD PTR _iTr$[ebp]
  00293	de c1		 faddp	 ST(1), ST(0)
  00295	8b 45 ec	 mov	 eax, DWORD PTR _piCoefTop$[ebp]
  00298	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 935  : 
; 936  :         DEBUG_DCT_SIN(0,i,fac,CI);
; 937  :         MONITOR_RANGE(gMR_DCTCoefIntoFFT,FLOAT_FROM_COEF(piCoefTop[0]));
; 938  :         MONITOR_RANGE(gMR_DCTCoefIntoFFT,FLOAT_FROM_COEF(piCoefTop[1]));
; 939  :         // rotate angle by -b = -pi/cSubband
; 940  :         // recursion: cos(a-b) = cos(a+b) - 2*sin(b)*sin(a)
; 941  :         // and:       sin(a-b) = sin(a+b) + 2*sin(b)*cos(a)
; 942  :         UR = CR1 - MULT_BP1(STEP,CI);

  0029b	d9 45 c8	 fld	 DWORD PTR _STEP$[ebp]
  0029e	d8 8d 6c ff ff
	ff		 fmul	 DWORD PTR _CI$[ebp]
  002a4	d8 6d e4	 fsubr	 DWORD PTR _CR1$[ebp]
  002a7	d9 9d 70 ff ff
	ff		 fstp	 DWORD PTR _UR$[ebp]

; 943  :         UI = CI1 + MULT_BP1(STEP,CR);

  002ad	d9 45 c8	 fld	 DWORD PTR _STEP$[ebp]
  002b0	d8 8d 60 ff ff
	ff		 fmul	 DWORD PTR _CR$[ebp]
  002b6	d8 45 cc	 fadd	 DWORD PTR _CI1$[ebp]
  002b9	d9 5d 98	 fstp	 DWORD PTR _UI$[ebp]

; 944  :         CR1 = CR;  CR = UR;

  002bc	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _CR$[ebp]
  002c2	89 4d e4	 mov	 DWORD PTR _CR1$[ebp], ecx
  002c5	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _UR$[ebp]
  002cb	89 95 60 ff ff
	ff		 mov	 DWORD PTR _CR$[ebp], edx

; 945  :         CI1 = CI;  CI = UI;

  002d1	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _CI$[ebp]
  002d7	89 45 cc	 mov	 DWORD PTR _CI1$[ebp], eax
  002da	8b 4d 98	 mov	 ecx, DWORD PTR _UI$[ebp]
  002dd	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _CI$[ebp], ecx

; 946  : 
; 947  :         piCoefTop += 2;

  002e3	8b 55 ec	 mov	 edx, DWORD PTR _piCoefTop$[ebp]
  002e6	83 c2 08	 add	 edx, 8
  002e9	89 55 ec	 mov	 DWORD PTR _piCoefTop$[ebp], edx

; 948  :         piCoefBottom -= 2;

  002ec	8b 45 f0	 mov	 eax, DWORD PTR _piCoefBottom$[ebp]
  002ef	83 e8 08	 sub	 eax, 8
  002f2	89 45 f0	 mov	 DWORD PTR _piCoefBottom$[ebp], eax

; 949  :         piCoefBottomOut -= 2;

  002f5	8b 4d f4	 mov	 ecx, DWORD PTR _piCoefBottomOut$[ebp]
  002f8	83 e9 08	 sub	 ecx, 8
  002fb	89 4d f4	 mov	 DWORD PTR _piCoefBottomOut$[ebp], ecx

; 950  :     }

  002fe	e9 37 ff ff ff	 jmp	 $L2482
$L2483:

; 951  : 
; 952  :     for (i = iFFTSize/2; i > 0; i--) {

  00303	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _iFFTSize$[ebp]
  00309	99		 cdq
  0030a	2b c2		 sub	 eax, edx
  0030c	d1 f8		 sar	 eax, 1
  0030e	89 45 d0	 mov	 DWORD PTR _i$[ebp], eax
  00311	eb 09		 jmp	 SHORT $L2484
$L2485:
  00313	8b 55 d0	 mov	 edx, DWORD PTR _i$[ebp]
  00316	83 ea 01	 sub	 edx, 1
  00319	89 55 d0	 mov	 DWORD PTR _i$[ebp], edx
$L2484:
  0031c	83 7d d0 00	 cmp	 DWORD PTR _i$[ebp], 0
  00320	0f 8e a3 00 00
	00		 jle	 $L2486

; 953  :         iTr = piCoefTop[0];

  00326	8b 45 ec	 mov	 eax, DWORD PTR _piCoefTop$[ebp]
  00329	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032b	89 4d e0	 mov	 DWORD PTR _iTr$[ebp], ecx

; 954  :         iTi = piCoefTop[1];

  0032e	8b 55 ec	 mov	 edx, DWORD PTR _piCoefTop$[ebp]
  00331	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00334	89 85 64 ff ff
	ff		 mov	 DWORD PTR _iTi$[ebp], eax

; 955  :         piCoefTop[0] = MULT_BP1(CR,iTr) - MULT_BP1(CI,iTi);

  0033a	d9 85 60 ff ff
	ff		 fld	 DWORD PTR _CR$[ebp]
  00340	d8 4d e0	 fmul	 DWORD PTR _iTr$[ebp]
  00343	d9 85 6c ff ff
	ff		 fld	 DWORD PTR _CI$[ebp]
  00349	d8 8d 64 ff ff
	ff		 fmul	 DWORD PTR _iTi$[ebp]
  0034f	de e9		 fsubp	 ST(1), ST(0)
  00351	8b 4d ec	 mov	 ecx, DWORD PTR _piCoefTop$[ebp]
  00354	d9 19		 fstp	 DWORD PTR [ecx]

; 956  :         piCoefTop[1] = MULT_BP1(CR,iTi) + MULT_BP1(CI,iTr);

  00356	d9 85 60 ff ff
	ff		 fld	 DWORD PTR _CR$[ebp]
  0035c	d8 8d 64 ff ff
	ff		 fmul	 DWORD PTR _iTi$[ebp]
  00362	d9 85 6c ff ff
	ff		 fld	 DWORD PTR _CI$[ebp]
  00368	d8 4d e0	 fmul	 DWORD PTR _iTr$[ebp]
  0036b	de c1		 faddp	 ST(1), ST(0)
  0036d	8b 55 ec	 mov	 edx, DWORD PTR _piCoefTop$[ebp]
  00370	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 957  : 
; 958  :         DEBUG_DCT_SIN(1,i,fac,CI);
; 959  :         MONITOR_RANGE(gMR_DCTCoefIntoFFT,FLOAT_FROM_COEF(piCoefTop[0]));
; 960  :         MONITOR_RANGE(gMR_DCTCoefIntoFFT,FLOAT_FROM_COEF(piCoefTop[1]));
; 961  :         // rotate angle by b = -pi/cSubband
; 962  :         UR = CR1 - MULT_BP1(STEP,CI);

  00373	d9 45 c8	 fld	 DWORD PTR _STEP$[ebp]
  00376	d8 8d 6c ff ff
	ff		 fmul	 DWORD PTR _CI$[ebp]
  0037c	d8 6d e4	 fsubr	 DWORD PTR _CR1$[ebp]
  0037f	d9 9d 70 ff ff
	ff		 fstp	 DWORD PTR _UR$[ebp]

; 963  :         UI = CI1 + MULT_BP1(STEP,CR);

  00385	d9 45 c8	 fld	 DWORD PTR _STEP$[ebp]
  00388	d8 8d 60 ff ff
	ff		 fmul	 DWORD PTR _CR$[ebp]
  0038e	d8 45 cc	 fadd	 DWORD PTR _CI1$[ebp]
  00391	d9 5d 98	 fstp	 DWORD PTR _UI$[ebp]

; 964  :         CR1 = CR;  CR = UR;

  00394	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _CR$[ebp]
  0039a	89 45 e4	 mov	 DWORD PTR _CR1$[ebp], eax
  0039d	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _UR$[ebp]
  003a3	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _CR$[ebp], ecx

; 965  :         CI1 = CI;  CI = UI;

  003a9	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _CI$[ebp]
  003af	89 55 cc	 mov	 DWORD PTR _CI1$[ebp], edx
  003b2	8b 45 98	 mov	 eax, DWORD PTR _UI$[ebp]
  003b5	89 85 6c ff ff
	ff		 mov	 DWORD PTR _CI$[ebp], eax

; 966  : 
; 967  :         piCoefTop += 2;

  003bb	8b 4d ec	 mov	 ecx, DWORD PTR _piCoefTop$[ebp]
  003be	83 c1 08	 add	 ecx, 8
  003c1	89 4d ec	 mov	 DWORD PTR _piCoefTop$[ebp], ecx

; 968  :     }

  003c4	e9 4a ff ff ff	 jmp	 $L2485
$L2486:

; 969  : 
; 970  :     DCT_DOPRINT_PRE((fac/d1Hp0),rgiCoef);
; 971  : 
; 972  :     //Call the integer FFT explicitly
; 973  :     pau->aupfnFFT(rgiCoef, nLog2SB - 1);

  003c9	8b 55 9c	 mov	 edx, DWORD PTR _nLog2SB$[ebp]
  003cc	83 ea 01	 sub	 edx, 1
  003cf	52		 push	 edx
  003d0	8b 45 0c	 mov	 eax, DWORD PTR _rgiCoef$[ebp]
  003d3	50		 push	 eax
  003d4	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  003d7	ff 91 00 04 00
	00		 call	 DWORD PTR [ecx+1024]

; 974  : 
; 975  :     DCT_DOPRINT_POST(1.0,rgiCoef);
; 976  : 
; 977  : #ifdef INTEGER_ENCODER
; 978  :     // TODO:  put this in asm for SH4, SH3 and casio
; 979  :     if (nFacExponent > 0)
; 980  :     {   // This scaling needed for encoding only (we think hopefully)
; 981  :         const int c_iMaxScaleUp = 15;
; 982  : 
; 983  :         iScaleFactor = nFacExponent;
; 984  : 
; 985  :         // Limit pre-scale to +c_iMaxScaleUp (to avoid overflow)
; 986  :         if (iScaleFactor > c_iMaxScaleUp)
; 987  :         {
; 988  :             nFacExponent = (iScaleFactor - c_iMaxScaleUp);
; 989  :             iScaleFactor = c_iMaxScaleUp;
; 990  :         }
; 991  :         else
; 992  :             nFacExponent = 0;
; 993  : 
; 994  : #ifdef _DEBUG
; 995  :         if (iScaleFactor > 0)
; 996  :         {
; 997  :             I32 iIntMax = INT_MAX >> iScaleFactor;  
; 998  :             piCoefTop      = rgiCoef; 
; 999  :             for( i = cSB; i > 0; i--, piCoefTop++ )
; 1000 :             {
; 1001 :                 assert(-iIntMax <= (I32)(*piCoefTop)  && (I32)(*piCoefTop) <= iIntMax );
; 1002 :             }
; 1003 :         }
; 1004 : #endif
; 1005 :     }
; 1006 : 
; 1007 : #endif
; 1008 : 
; 1009 :     // post FFT demodulation 
; 1010 :     // using R[i], I[i] as real and imaginary parts of complex point i
; 1011 :     // and C(i), S(i) are cos(i*pi/cSubband) and sin(i*pi/cSubband), and N = cSubband/2
; 1012 :     // R[0] = C(0) R[0] - S(0) I[0]
; 1013 :     // I[0] = -S(-(N-1)) R[N-1] - C(-(N-1)) I[N-1]
; 1014 :     // R[1] = C(1) R[1] - S(-1) I[N-1]
; 1015 :     // I[1] = -S(-(N-2)) R[N-2] - C(-(N-2)) I[N-2]
; 1016 :     // ...
; 1017 :     // R[N-2] = C(-(N-2)) R[N-2] - S(-(N-2)) I[N-2]
; 1018 :     // I[N-2] = -S(-1) R[1] - C(-1) I[1]
; 1019 :     // R[N-1] = C(-(N-1)) R[N-1] - S(-(N-1)) I[N-1]
; 1020 :     // R[N-1] = -S(0) R[0] - C(0) I[0]
; 1021 :     // and where 90 - angle trig formulas reveal:
; 1022 :     // C(-(N-i)) == -S(-i) and S(-(N-i)) = -C(-i)
; 1023 : 
; 1024 :     piCoefTop      = rgiCoef;           //reuse this pointer; start from head;

  003dd	8b 55 0c	 mov	 edx, DWORD PTR _rgiCoef$[ebp]
  003e0	89 55 ec	 mov	 DWORD PTR _piCoefTop$[ebp], edx

; 1025 :     piCoefBottom   = rgiCoef + cSB - 2; //reuse this pointer; start from tail;

  003e3	8b 45 d4	 mov	 eax, DWORD PTR _cSB$[ebp]
  003e6	8b 4d 0c	 mov	 ecx, DWORD PTR _rgiCoef$[ebp]
  003e9	8d 54 81 f8	 lea	 edx, DWORD PTR [ecx+eax*4-8]
  003ed	89 55 f0	 mov	 DWORD PTR _piCoefBottom$[ebp], edx

; 1026 :     CR = BP1_FROM_FLOAT(1);             //one

  003f0	c7 85 60 ff ff
	ff 00 00 80 3f	 mov	 DWORD PTR _CR$[ebp], 1065353216 ; 3f800000H

; 1027 :     CI = 0;                             //zero

  003fa	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _CI$[ebp], 0

; 1028 : 
; 1029 :     for (i = iFFTSize/2; i > 0; i--) {

  00404	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _iFFTSize$[ebp]
  0040a	99		 cdq
  0040b	2b c2		 sub	 eax, edx
  0040d	d1 f8		 sar	 eax, 1
  0040f	89 45 d0	 mov	 DWORD PTR _i$[ebp], eax
  00412	eb 09		 jmp	 SHORT $L2488
$L2489:
  00414	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  00417	83 e8 01	 sub	 eax, 1
  0041a	89 45 d0	 mov	 DWORD PTR _i$[ebp], eax
$L2488:
  0041d	83 7d d0 00	 cmp	 DWORD PTR _i$[ebp], 0
  00421	0f 8e fd 00 00
	00		 jle	 $L2490

; 1030 :         iTr = piCoefTop[0] INTEGER_ENCODER_ONLY( <<iScaleFactor );

  00427	8b 4d ec	 mov	 ecx, DWORD PTR _piCoefTop$[ebp]
  0042a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0042c	89 55 e0	 mov	 DWORD PTR _iTr$[ebp], edx

; 1031 :         iTi = piCoefTop[1] INTEGER_ENCODER_ONLY( <<iScaleFactor );

  0042f	8b 45 ec	 mov	 eax, DWORD PTR _piCoefTop$[ebp]
  00432	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00435	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _iTi$[ebp], ecx

; 1032 :         iBr = piCoefBottom[0] INTEGER_ENCODER_ONLY( <<iScaleFactor );

  0043b	8b 55 f0	 mov	 edx, DWORD PTR _piCoefBottom$[ebp]
  0043e	8b 02		 mov	 eax, DWORD PTR [edx]
  00440	89 85 68 ff ff
	ff		 mov	 DWORD PTR _iBr$[ebp], eax

; 1033 :         iBi = piCoefBottom[1] INTEGER_ENCODER_ONLY( <<iScaleFactor );

  00446	8b 4d f0	 mov	 ecx, DWORD PTR _piCoefBottom$[ebp]
  00449	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0044c	89 55 c4	 mov	 DWORD PTR _iBi$[ebp], edx

; 1034 : 
; 1035 :         piCoefTop[0] =  MULT_BP1(CR,iTr) -  MULT_BP1(CI,iTi);

  0044f	d9 85 60 ff ff
	ff		 fld	 DWORD PTR _CR$[ebp]
  00455	d8 4d e0	 fmul	 DWORD PTR _iTr$[ebp]
  00458	d9 85 6c ff ff
	ff		 fld	 DWORD PTR _CI$[ebp]
  0045e	d8 8d 64 ff ff
	ff		 fmul	 DWORD PTR _iTi$[ebp]
  00464	de e9		 fsubp	 ST(1), ST(0)
  00466	8b 45 ec	 mov	 eax, DWORD PTR _piCoefTop$[ebp]
  00469	d9 18		 fstp	 DWORD PTR [eax]

; 1036 :         piCoefBottom[1] =  MULT_BP1(-CI,iTr) - MULT_BP1(CR,iTi);

  0046b	d9 85 6c ff ff
	ff		 fld	 DWORD PTR _CI$[ebp]
  00471	d9 e0		 fchs
  00473	d8 4d e0	 fmul	 DWORD PTR _iTr$[ebp]
  00476	d9 85 60 ff ff
	ff		 fld	 DWORD PTR _CR$[ebp]
  0047c	d8 8d 64 ff ff
	ff		 fmul	 DWORD PTR _iTi$[ebp]
  00482	de e9		 fsubp	 ST(1), ST(0)
  00484	8b 4d f0	 mov	 ecx, DWORD PTR _piCoefBottom$[ebp]
  00487	d9 59 04	 fstp	 DWORD PTR [ecx+4]

; 1037 :         INTEGER_ONLY( iMagnitude |= abs(piCoefTop[0]) );
; 1038 :         INTEGER_ONLY( iMagnitude |= abs(piCoefBottom[1]) );
; 1039 : 
; 1040 :         DEBUG_DCT_SIN(2,i,d1p0,CI);
; 1041 :         MONITOR_RANGE(gMR_DCTCoefOut,FLOAT_FROM_COEF(piCoefTop[0]));
; 1042 :         MONITOR_RANGE(gMR_DCTCoefOut,FLOAT_FROM_COEF(piCoefBottom[1]));
; 1043 :         // rotate angle by -b = -pi/cSubband
; 1044 :         // recursion: cos(a-b) = cos(a+b) - 2*sin(b)*sin(a)
; 1045 :         // and:       sin(a-b) = sin(a+b) + 2*sin(b)*cos(a)
; 1046 :         UR = CR2 - MULT_BP1(STEP,CI);

  0048a	d9 45 c8	 fld	 DWORD PTR _STEP$[ebp]
  0048d	d8 8d 6c ff ff
	ff		 fmul	 DWORD PTR _CI$[ebp]
  00493	d8 6d e8	 fsubr	 DWORD PTR _CR2$[ebp]
  00496	d9 9d 70 ff ff
	ff		 fstp	 DWORD PTR _UR$[ebp]

; 1047 :         UI = CI2 + MULT_BP1(STEP,CR);

  0049c	d9 45 c8	 fld	 DWORD PTR _STEP$[ebp]
  0049f	d8 8d 60 ff ff
	ff		 fmul	 DWORD PTR _CR$[ebp]
  004a5	d8 45 b4	 fadd	 DWORD PTR _CI2$[ebp]
  004a8	d9 5d 98	 fstp	 DWORD PTR _UI$[ebp]

; 1048 :         CR2 = CR;  CR = UR;

  004ab	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _CR$[ebp]
  004b1	89 55 e8	 mov	 DWORD PTR _CR2$[ebp], edx
  004b4	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _UR$[ebp]
  004ba	89 85 60 ff ff
	ff		 mov	 DWORD PTR _CR$[ebp], eax

; 1049 :         CI2 = CI;  CI = UI;

  004c0	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _CI$[ebp]
  004c6	89 4d b4	 mov	 DWORD PTR _CI2$[ebp], ecx
  004c9	8b 55 98	 mov	 edx, DWORD PTR _UI$[ebp]
  004cc	89 95 6c ff ff
	ff		 mov	 DWORD PTR _CI$[ebp], edx

; 1050 : 
; 1051 :         // note that cos(-(cSubband/2 - i)*pi/cSubband ) = -sin( -i*pi/cSubband )
; 1052 :         piCoefTop[1] = MULT_BP1(CR,iBr) + MULT_BP1(CI,iBi);

  004d2	d9 85 60 ff ff
	ff		 fld	 DWORD PTR _CR$[ebp]
  004d8	d8 8d 68 ff ff
	ff		 fmul	 DWORD PTR _iBr$[ebp]
  004de	d9 85 6c ff ff
	ff		 fld	 DWORD PTR _CI$[ebp]
  004e4	d8 4d c4	 fmul	 DWORD PTR _iBi$[ebp]
  004e7	de c1		 faddp	 ST(1), ST(0)
  004e9	8b 45 ec	 mov	 eax, DWORD PTR _piCoefTop$[ebp]
  004ec	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 1053 :         piCoefBottom[0] = MULT_BP1(-CI,iBr) +  MULT_BP1(CR,iBi);

  004ef	d9 85 6c ff ff
	ff		 fld	 DWORD PTR _CI$[ebp]
  004f5	d9 e0		 fchs
  004f7	d8 8d 68 ff ff
	ff		 fmul	 DWORD PTR _iBr$[ebp]
  004fd	d9 85 60 ff ff
	ff		 fld	 DWORD PTR _CR$[ebp]
  00503	d8 4d c4	 fmul	 DWORD PTR _iBi$[ebp]
  00506	de c1		 faddp	 ST(1), ST(0)
  00508	8b 4d f0	 mov	 ecx, DWORD PTR _piCoefBottom$[ebp]
  0050b	d9 19		 fstp	 DWORD PTR [ecx]

; 1054 :         
; 1055 :         INTEGER_ONLY( iMagnitude |= abs(piCoefTop[1]) );
; 1056 :         INTEGER_ONLY( iMagnitude |= abs(piCoefBottom[0]) );
; 1057 : 
; 1058 :         MONITOR_RANGE(gMR_DCTCoefOut,FLOAT_FROM_COEF(piCoefTop[1]));
; 1059 :         MONITOR_RANGE(gMR_DCTCoefOut,FLOAT_FROM_COEF(piCoefBottom[0]));
; 1060 : 
; 1061 :         piCoefTop += 2;

  0050d	8b 55 ec	 mov	 edx, DWORD PTR _piCoefTop$[ebp]
  00510	83 c2 08	 add	 edx, 8
  00513	89 55 ec	 mov	 DWORD PTR _piCoefTop$[ebp], edx

; 1062 :         piCoefBottom -= 2;

  00516	8b 45 f0	 mov	 eax, DWORD PTR _piCoefBottom$[ebp]
  00519	83 e8 08	 sub	 eax, 8
  0051c	89 45 f0	 mov	 DWORD PTR _piCoefBottom$[ebp], eax

; 1063 :     }

  0051f	e9 f0 fe ff ff	 jmp	 $L2489
$L2490:

; 1064 : #if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
; 1065 :     if ( nFacExponent > 0 )
; 1066 :     {   // This scaling needed in v1 bit-streams
; 1067 :         piCoefTop      = rgiCoef; 
; 1068 :         iMagnitude <<= nFacExponent;
; 1069 :         for( i = cSB; i > 0; i-- )
; 1070 :         {
; 1071 :             *piCoefTop++ <<= nFacExponent;
; 1072 :         }
; 1073 :     }
; 1074 : #endif
; 1075 : 
; 1076 :     if (NULL != piMagnitude)

  00524	83 7d 14 00	 cmp	 DWORD PTR _piMagnitude$[ebp], 0
  00528	74 09		 je	 SHORT $L2492

; 1077 :         *piMagnitude = INTEGER_OR_INT_FLOAT( iMagnitude, 0 );

  0052a	8b 4d 14	 mov	 ecx, DWORD PTR _piMagnitude$[ebp]
  0052d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L2492:

; 1078 : 
; 1079 :     DCT_DOPRINT_OUT(1.0,rgiCoef);
; 1080 : #if defined(DCT_OUT_PRINT) && defined(_DEBUG)
; 1081 :     if ( pau->m_iFrameNumber==DCT_OUT_PRINT)
; 1082 :     { DEBUG_BREAK(); }
; 1083 : #endif
; 1084 :     FUNCTION_PROFILE_STOP(&fp);
; 1085 : 
; 1086 :     return WMA_OK;

  00533	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK

; 1087 : }

  00538	8b e5		 mov	 esp, ebp
  0053a	5d		 pop	 ebp
  0053b	c2 10 00	 ret	 16			; 00000010H
_auDctIV_XDS@16 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\common\macros.h
WMADEC	ENDS
;	COMDAT _LOG2@4
WMADEC	SEGMENT
_iLog2$ = -4
_i$ = 8
_LOG2@4	PROC NEAR					; COMDAT

; 956  : {   // returns n where n = log2(2^n) = log2(2^(n+1)-1)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 957  :     U32 iLog2 = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iLog2$[ebp], 0
$L1586:

; 958  :     assert (i != 0);
; 959  :     while ((i >> iLog2) > 1)

  0000b	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _iLog2$[ebp]
  00011	d3 e8		 shr	 eax, cl
  00013	83 f8 01	 cmp	 eax, 1
  00016	76 0b		 jbe	 SHORT $L1587

; 960  :         iLog2++;

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _iLog2$[ebp]
  0001b	83 c1 01	 add	 ecx, 1
  0001e	89 4d fc	 mov	 DWORD PTR _iLog2$[ebp], ecx
  00021	eb e8		 jmp	 SHORT $L1586
$L1587:

; 961  : 
; 962  :     return iLog2;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _iLog2$[ebp]

; 963  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
_LOG2@4	ENDP
WMADEC	ENDS
END
