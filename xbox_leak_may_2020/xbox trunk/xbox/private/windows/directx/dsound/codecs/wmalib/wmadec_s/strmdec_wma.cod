; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\strmdec_wma.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
WMADEC_RW	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RW	ENDS
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT @ByteSwap@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_set_fNoMoreData@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _WMA_get_nHdrBits@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmInit@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmReset@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmAttach@20
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmPeekBitsNonStop@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmPeekBits@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmLookForBits@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmFlushBits@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvFinalLoad@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmGetMoreData@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmResetPacket@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ibstrmGetBits@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, WMADEC_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_getMask
PUBLIC	_DSoundBuildNumberD
WMADEC_RD	SEGMENT
_WMA_OK	DD	00H
_WMA_S_FALSE DD	01H
_WMA_S_BUFUNDERFLOW DD 02H
_WMA_S_NEWPACKET DD 03H
_WMA_S_NO_MORE_FRAME DD 04H
_WMA_S_DEFAULT DD 05H
_WMA_S_SWITCHCHMODE DD 06H
_WMA_E_FAIL DD	080004005H
_WMA_E_OUTOFMEMORY DD 08007000eH
_WMA_E_INVALIDARG DD 080070057H
_WMA_E_NOTSUPPORTED DD 080040000H
_WMA_E_LOSTPACKET DD 080040001H
_WMA_E_BROKEN_FRAME DD 080040002H
_WMA_E_BUFFEROVERFLOW DD 080040003H
_WMA_E_ONHOLD DD 080040004H
_WMA_E_BUFFERUNDERFLOW DD 080040005H
_WMA_E_INVALIDRECHDR DD 080040006H
_WMA_E_SYNCERROR DD 080040007H
_WMA_E_NOTIMPL DD 080040008H
_WMA_E_FLUSHOVERFLOW DD 080040009H
WMADEC_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT
_DSoundBuildNumberD DW 05344H
	DW	0554fH
	DW	0444eH
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
WMADEC_RD	SEGMENT
_getMask DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
	DD	01ffffH
	DD	03ffffH
	DD	07ffffH
	DD	0fffffH
	DD	01fffffH
	DD	03fffffH
	DD	07fffffH
	DD	0ffffffH
	DD	01ffffffH
	DD	03ffffffH
	DD	07ffffffH
	DD	0fffffffH
	DD	01fffffffH
	DD	03fffffffH
	DD	07fffffffH
	DD	0ffffffffH
WMADEC_RD	ENDS
PUBLIC	_ibstrmInit@8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\strmdec_wma.c
;	COMDAT _ibstrmInit@8
WMADEC	SEGMENT
_pibstrm$ = 8
_fAllowPackets$ = 12
_ibstrmInit@8 PROC NEAR					; COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   :     //added for streaming mode
; 78   :     pibstrm->m_pfnGetMoreData = NULL;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 79   :     pibstrm->m_dwUser  = 0;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  0000f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 80   :     pibstrm->m_dwOwner = 0;    

  00016	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00019	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 81   :     pibstrm->m_dwHeaderBuf   = 0;

  00020	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00023	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 82   :     pibstrm->m_pBufferBegin  = NULL;

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  0002d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 83   :     pibstrm->m_cbBuflenBegin = 0;    // used in association of m_pBufferBegin	

  00034	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00037	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 84   :     //end of streaming mode
; 85   : 
; 86   :     pibstrm->m_pBuffer = NULL;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00041	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 87   :     pibstrm->m_cbBuflen = 0;

  00048	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  0004b	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 88   :     pibstrm->m_dwDot = 0;

  00052	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00055	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0

; 89   :     pibstrm->m_dwBitsLeft = 0;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  0005f	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 90   :     pibstrm->m_iPrevPacketNum = (1 << NBITS_PACKET_CNT) - 1; // Keep -1 spacing w/ curr pkt num

  00066	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00069	c7 41 28 0f 00
	00 00		 mov	 DWORD PTR [ecx+40], 15	; 0000000fH

; 91   :     pibstrm->m_fAllowPackets = fAllowPackets;

  00070	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00073	8b 45 0c	 mov	 eax, DWORD PTR _fAllowPackets$[ebp]
  00076	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 92   :     pibstrm->m_fSuppressPacketLoss = WMAB_TRUE; // Suppress first packet from loss detection

  00079	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  0007c	c7 41 30 01 00
	00 00		 mov	 DWORD PTR [ecx+48], 1

; 93   : }

  00083	5d		 pop	 ebp
  00084	c2 08 00	 ret	 8
_ibstrmInit@8 ENDP
WMADEC	ENDS
PUBLIC	_ibstrmReset@4
; Function compile flags: /Odt
;	COMDAT _ibstrmReset@4
WMADEC	SEGMENT
_pibstrm$ = 8
_ibstrmReset@4 PROC NEAR				; COMDAT

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 97   :     pibstrm->m_dwDot = 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00006	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 98   :     pibstrm->m_dwBitsLeft = 0;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00010	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 99   :     pibstrm->m_cbBuflen = 0;

  00017	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0001a	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 100  :     pibstrm->m_fSuppressPacketLoss = WMAB_TRUE;

  00021	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00024	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1

; 101  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
_ibstrmReset@4 ENDP
WMADEC	ENDS
PUBLIC	_ibstrmAttach@20
; Function compile flags: /Odt
;	COMDAT _ibstrmAttach@20
WMADEC	SEGMENT
_pibstrm$ = 8
_dwDot$ = 12
_dwBitsLeft$ = 16
_pbSrc$ = 20
_cbSrc$ = 24
_ibstrmAttach@20 PROC NEAR				; COMDAT

; 104  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 105  :     //added for streaming mode
; 106  :     pibstrm->m_dwHeaderBuf   = 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00006	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 107  :     pibstrm->m_pBufferBegin  = NULL;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00010	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 108  :     pibstrm->m_cbBuflenBegin = 0;    // used in association of m_pBufferBegin	

  00017	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0001a	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 109  :     //end of streaming mode
; 110  : 
; 111  :     pibstrm->m_pBuffer = pbSrc;

  00021	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  00027	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 112  :     pibstrm->m_cbBuflen = cbSrc;

  0002a	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0002d	8b 45 18	 mov	 eax, DWORD PTR _cbSrc$[ebp]
  00030	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 113  :     pibstrm->m_dwDot = dwDot;

  00033	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00036	8b 55 0c	 mov	 edx, DWORD PTR _dwDot$[ebp]
  00039	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 114  :     pibstrm->m_dwBitsLeft = dwBitsLeft;

  0003c	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  0003f	8b 4d 10	 mov	 ecx, DWORD PTR _dwBitsLeft$[ebp]
  00042	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 115  : }

  00045	5d		 pop	 ebp
  00046	c2 14 00	 ret	 20			; 00000014H
_ibstrmAttach@20 ENDP
WMADEC	ENDS
PUBLIC	_ibstrmGetMoreData@8
PUBLIC	_ibstrmPeekBitsNonStop@12
PUBLIC	??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@ ; `string'
EXTRN	_MyOutputDbgStr:NEAR
;	COMDAT ??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
WMADEC_RD	SEGMENT
??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\wmalib\wmadec_s\strmdec_w'
	DB	'ma.c', 00H					; `string'
WMADEC_RD	ENDS
;	COMDAT ??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
WMADEC_RD	SEGMENT
??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@ DB '%'
	DB	's(%d) : *** TRACE *** code = 0x%x!', 0aH, 00H ; `string'
; Function compile flags: /Odt
WMADEC_RD	ENDS
;	COMDAT _ibstrmPeekBitsNonStop@12
WMADEC	SEGMENT
tv134 = -16
_iBufLen$2891 = -12
_cBitExtra$ = -8
_wmaResult$ = -4
_pibstrm$ = 8
_dwNumBits$ = 12
_piRetBits$ = 16
_ibstrmPeekBitsNonStop@12 PROC NEAR			; COMDAT

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 121  :     I16 cBitExtra;
; 122  :     WMARESULT   wmaResult = WMA_OK;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000b	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax
$L2888:

; 123  : 
; 124  :     assert (dwNumBits <= 24); //only works for sure under this
; 125  :     //make sure there is enougth data in dwDot for peek
; 126  :     while (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen > 0) {

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00011	83 79 24 18	 cmp	 DWORD PTR [ecx+36], 24	; 00000018H
  00015	77 5e		 ja	 SHORT $L2889
  00017	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0001a	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  0001e	7e 55		 jle	 SHORT $L2889

; 127  :         pibstrm->m_dwDot <<= 8;

  00020	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00023	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00026	c1 e1 08	 shl	 ecx, 8
  00029	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0002c	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 128  :         pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00032	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00035	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00038	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  0003b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0003e	0b ca		 or	 ecx, edx
  00040	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00043	89 4a 20	 mov	 DWORD PTR [edx+32], ecx
  00046	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00049	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0004c	83 c1 01	 add	 ecx, 1
  0004f	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00052	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 129  :         --(pibstrm->m_cbBuflen);

  00055	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00058	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00061	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 130  :         pibstrm->m_dwBitsLeft += 8;    

  00064	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00067	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0006a	83 c1 08	 add	 ecx, 8
  0006d	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00070	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 131  :     }

  00073	eb 99		 jmp	 SHORT $L2888
$L2889:

; 132  :     if (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen <= 0)

  00075	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00078	83 78 24 18	 cmp	 DWORD PTR [eax+36], 24	; 00000018H
  0007c	77 61		 ja	 SHORT $L2890
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00081	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00085	7f 58		 jg	 SHORT $L2890

; 133  :     {
; 134  :         U32         iBufLen;
; 135  :         TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));

  00087	8d 55 f4	 lea	 edx, DWORD PTR _iBufLen$2891[ebp]
  0008a	52		 push	 edx
  0008b	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _ibstrmGetMoreData@8
  00094	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00097	83 7d fc 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  0009b	7d 42		 jge	 SHORT $L2890
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000a0	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  000a6	74 2f		 je	 SHORT $L3084
  000a8	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000ab	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  000b1	74 24		 je	 SHORT $L3084
  000b3	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000b6	50		 push	 eax
  000b7	68 87 00 00 00	 push	 135			; 00000087H
  000bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
  000c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _MyOutputDbgStr
  000cf	83 c4 14	 add	 esp, 20			; 00000014H
  000d2	89 45 f0	 mov	 DWORD PTR tv134[ebp], eax
  000d5	eb 06		 jmp	 SHORT $L3085
$L3084:
  000d7	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000da	89 55 f0	 mov	 DWORD PTR tv134[ebp], edx
$L3085:
  000dd	eb 40		 jmp	 SHORT $exit$2896
$L2890:

; 136  :     }
; 137  : 
; 138  :     //if enough take the data and go home; else take what ever is left
; 139  :     if (pibstrm->m_dwBitsLeft < dwNumBits)

  000df	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  000e2	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000e5	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwNumBits$[ebp]
  000e8	73 09		 jae	 SHORT $L2898

; 140  :         dwNumBits = pibstrm->m_dwBitsLeft;

  000ea	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  000ed	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000f0	89 45 0c	 mov	 DWORD PTR _dwNumBits$[ebp], eax
$L2898:

; 141  :     cBitExtra = (I16) pibstrm->m_dwBitsLeft - (I16) dwNumBits;

  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  000f6	0f bf 51 24	 movsx	 edx, WORD PTR [ecx+36]
  000fa	0f bf 45 0c	 movsx	 eax, WORD PTR _dwNumBits$[ebp]
  000fe	2b d0		 sub	 edx, eax
  00100	66 89 55 f8	 mov	 WORD PTR _cBitExtra$[ebp], dx

; 142  : 
; 143  :     assert(NULL != piRetBits); // Avoid conditionals
; 144  :     *piRetBits = (pibstrm->m_dwDot >> cBitExtra) << (32 - dwNumBits);

  00104	0f bf 4d f8	 movsx	 ecx, WORD PTR _cBitExtra$[ebp]
  00108	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0010b	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0010e	d3 e8		 shr	 eax, cl
  00110	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00115	2b 4d 0c	 sub	 ecx, DWORD PTR _dwNumBits$[ebp]
  00118	d3 e0		 shl	 eax, cl
  0011a	8b 4d 10	 mov	 ecx, DWORD PTR _piRetBits$[ebp]
  0011d	89 01		 mov	 DWORD PTR [ecx], eax
$exit$2896:

; 145  : 
; 146  : exit:
; 147  :     return wmaResult;

  0011f	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 148  : }

  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c2 0c 00	 ret	 12			; 0000000cH
_ibstrmPeekBitsNonStop@12 ENDP
WMADEC	ENDS
PUBLIC	_ibstrmPeekBits@12
; Function compile flags: /Odt
;	COMDAT _ibstrmPeekBits@12
WMADEC	SEGMENT
tv145 = -20
tv134 = -16
_iBufLen$2914 = -12
_cBitExtra$ = -8
_wmaResult$ = -4
_pibstrm$ = 8
_dwNumBits$ = 12
_piRetBits$ = 16
_ibstrmPeekBits@12 PROC NEAR				; COMDAT

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 153  :     I16 cBitExtra;
; 154  :     WMARESULT   wmaResult = WMA_OK;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000b	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax
$L2911:

; 155  : 
; 156  :     assert (dwNumBits <= 24); //only works for sure under this
; 157  :     //make sure there is enougth data in dwDot for peek
; 158  :     while (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen > 0) {

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00011	83 79 24 18	 cmp	 DWORD PTR [ecx+36], 24	; 00000018H
  00015	77 5e		 ja	 SHORT $L2912
  00017	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0001a	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  0001e	7e 55		 jle	 SHORT $L2912

; 159  :         pibstrm->m_dwDot <<= 8;

  00020	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00023	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00026	c1 e1 08	 shl	 ecx, 8
  00029	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0002c	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 160  :         pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00032	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00035	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00038	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  0003b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0003e	0b ca		 or	 ecx, edx
  00040	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00043	89 4a 20	 mov	 DWORD PTR [edx+32], ecx
  00046	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00049	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0004c	83 c1 01	 add	 ecx, 1
  0004f	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00052	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 161  :         --(pibstrm->m_cbBuflen);

  00055	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00058	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00061	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 162  :         pibstrm->m_dwBitsLeft += 8;    

  00064	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00067	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0006a	83 c1 08	 add	 ecx, 8
  0006d	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00070	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 163  :     }

  00073	eb 99		 jmp	 SHORT $L2911
$L2912:

; 164  :     if (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen <= 0)

  00075	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00078	83 78 24 18	 cmp	 DWORD PTR [eax+36], 24	; 00000018H
  0007c	77 64		 ja	 SHORT $L2913
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00081	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00085	7f 5b		 jg	 SHORT $L2913

; 165  :     {
; 166  :         U32         iBufLen;
; 167  :         TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));

  00087	8d 55 f4	 lea	 edx, DWORD PTR _iBufLen$2914[ebp]
  0008a	52		 push	 edx
  0008b	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _ibstrmGetMoreData@8
  00094	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00097	83 7d fc 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  0009b	7d 45		 jge	 SHORT $L2913
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000a0	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  000a6	74 2f		 je	 SHORT $L3089
  000a8	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000ab	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  000b1	74 24		 je	 SHORT $L3089
  000b3	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000b6	50		 push	 eax
  000b7	68 a7 00 00 00	 push	 167			; 000000a7H
  000bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
  000c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _MyOutputDbgStr
  000cf	83 c4 14	 add	 esp, 20			; 00000014H
  000d2	89 45 f0	 mov	 DWORD PTR tv134[ebp], eax
  000d5	eb 06		 jmp	 SHORT $L3090
$L3089:
  000d7	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000da	89 55 f0	 mov	 DWORD PTR tv134[ebp], edx
$L3090:
  000dd	e9 82 00 00 00	 jmp	 $exit$2917
$L2913:

; 168  :     }
; 169  : 
; 170  :     //if enough take the data and go home; else take what ever is left
; 171  :     if (pibstrm->m_dwBitsLeft < dwNumBits)

  000e2	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  000e5	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000e8	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwNumBits$[ebp]
  000eb	73 4b		 jae	 SHORT $L2919

; 172  :     {
; 173  :         wmaResult = WMA_E_ONHOLD;

  000ed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_ONHOLD
  000f3	89 55 fc	 mov	 DWORD PTR _wmaResult$[ebp], edx

; 174  :         TraceResult(wmaResult);

  000f6	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000f9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  000ff	74 2f		 je	 SHORT $L3091
  00101	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00104	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  0010a	74 24		 je	 SHORT $L3091
  0010c	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0010f	52		 push	 edx
  00110	68 ae 00 00 00	 push	 174			; 000000aeH
  00115	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
  0011a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0011f	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00128	83 c4 14	 add	 esp, 20			; 00000014H
  0012b	89 45 ec	 mov	 DWORD PTR tv145[ebp], eax
  0012e	eb 06		 jmp	 SHORT $L3092
$L3091:
  00130	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00133	89 4d ec	 mov	 DWORD PTR tv145[ebp], ecx
$L3092:

; 175  :         goto exit;

  00136	eb 2c		 jmp	 SHORT $exit$2917
$L2919:

; 176  :     }
; 177  : 
; 178  :     cBitExtra = (I16) pibstrm->m_dwBitsLeft - (I16) dwNumBits;

  00138	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0013b	0f bf 42 24	 movsx	 eax, WORD PTR [edx+36]
  0013f	0f bf 4d 0c	 movsx	 ecx, WORD PTR _dwNumBits$[ebp]
  00143	2b c1		 sub	 eax, ecx
  00145	66 89 45 f8	 mov	 WORD PTR _cBitExtra$[ebp], ax

; 179  :     assert(NULL != piRetBits); // Avoid conditionals
; 180  :     *piRetBits = (pibstrm->m_dwDot >> cBitExtra) << (32 - dwNumBits);

  00149	0f bf 4d f8	 movsx	 ecx, WORD PTR _cBitExtra$[ebp]
  0014d	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00150	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00153	d3 e8		 shr	 eax, cl
  00155	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0015a	2b 4d 0c	 sub	 ecx, DWORD PTR _dwNumBits$[ebp]
  0015d	d3 e0		 shl	 eax, cl
  0015f	8b 4d 10	 mov	 ecx, DWORD PTR _piRetBits$[ebp]
  00162	89 01		 mov	 DWORD PTR [ecx], eax
$exit$2917:

; 181  : 
; 182  : exit:
; 183  :     return wmaResult;

  00164	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 184  : }

  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c2 0c 00	 ret	 12			; 0000000cH
_ibstrmPeekBits@12 ENDP
WMADEC	ENDS
PUBLIC	_ibstrmLookForBits@8
; Function compile flags: /Odt
;	COMDAT _ibstrmLookForBits@8
WMADEC	SEGMENT
tv149 = -16
tv135 = -12
_iBufLen$ = -8
_wmaResult$ = -4
_pibstrm$ = 8
_dwNumBits$ = 12
_ibstrmLookForBits@8 PROC NEAR				; COMDAT

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 188  :     U32         iBufLen;
; 189  :     WMARESULT   wmaResult = WMA_OK;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000b	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 190  : 
; 191  :     assert (dwNumBits <= 32); //only case that works for certain
; 192  :     if (dwNumBits > pibstrm->m_dwBitsLeft + pibstrm->m_cbBuflen * 8) 

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00011	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00014	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00017	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0001a	8d 14 d1	 lea	 edx, DWORD PTR [ecx+edx*8]
  0001d	39 55 0c	 cmp	 DWORD PTR _dwNumBits$[ebp], edx
  00020	0f 86 bf 00 00
	00		 jbe	 $L2929
$L2931:

; 193  :     {
; 194  :         //load up everything
; 195  :         while (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen > 0) {

  00026	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00029	83 78 24 18	 cmp	 DWORD PTR [eax+36], 24	; 00000018H
  0002d	77 5e		 ja	 SHORT $L2932
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00032	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00036	7e 55		 jle	 SHORT $L2932

; 196  :             pibstrm->m_dwDot <<= 8;

  00038	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0003b	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0003e	c1 e0 08	 shl	 eax, 8
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00044	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 197  :             pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;

  00047	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0004a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0004d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00050	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00053	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00056	0b c1		 or	 eax, ecx
  00058	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  0005b	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  0005e	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00061	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00064	83 c0 01	 add	 eax, 1
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  0006a	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 198  :             --(pibstrm->m_cbBuflen);

  0006d	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00070	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00073	83 e8 01	 sub	 eax, 1
  00076	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00079	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 199  :             pibstrm->m_dwBitsLeft += 8;    

  0007c	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0007f	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00082	83 c0 08	 add	 eax, 8
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00088	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 200  :         }

  0008b	eb 99		 jmp	 SHORT $L2931
$L2932:

; 201  :         TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));

  0008d	8d 55 f8	 lea	 edx, DWORD PTR _iBufLen$[ebp]
  00090	52		 push	 edx
  00091	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _ibstrmGetMoreData@8
  0009a	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0009d	83 7d fc 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  000a1	7d 42		 jge	 SHORT $L2929
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000a6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  000ac	74 2f		 je	 SHORT $L3096
  000ae	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000b1	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  000b7	74 24		 je	 SHORT $L3096
  000b9	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000bc	50		 push	 eax
  000bd	68 c9 00 00 00	 push	 201			; 000000c9H
  000c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  000cc	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000cf	51		 push	 ecx
  000d0	e8 00 00 00 00	 call	 _MyOutputDbgStr
  000d5	83 c4 14	 add	 esp, 20			; 00000014H
  000d8	89 45 f4	 mov	 DWORD PTR tv135[ebp], eax
  000db	eb 06		 jmp	 SHORT $L3097
$L3096:
  000dd	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000e0	89 55 f4	 mov	 DWORD PTR tv135[ebp], edx
$L3097:
  000e3	eb 5d		 jmp	 SHORT $exit$2935
$L2929:

; 202  :     }
; 203  : 
; 204  :     if (dwNumBits > pibstrm->m_dwBitsLeft + pibstrm->m_cbBuflen * 8 )

  000e5	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  000e8	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000eb	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  000ee	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000f1	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  000f4	39 4d 0c	 cmp	 DWORD PTR _dwNumBits$[ebp], ecx
  000f7	76 49		 jbe	 SHORT $exit$2935

; 205  :     {
; 206  :         wmaResult = WMA_E_ONHOLD;

  000f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_ONHOLD
  000ff	89 55 fc	 mov	 DWORD PTR _wmaResult$[ebp], edx

; 207  :         TraceResult(wmaResult);

  00102	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00105	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  0010b	74 2f		 je	 SHORT $L3098
  0010d	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00110	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  00116	74 24		 je	 SHORT $L3098
  00118	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0011b	52		 push	 edx
  0011c	68 cf 00 00 00	 push	 207			; 000000cfH
  00121	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
  00126	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0012b	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00134	83 c4 14	 add	 esp, 20			; 00000014H
  00137	89 45 f0	 mov	 DWORD PTR tv149[ebp], eax
  0013a	eb 06		 jmp	 SHORT $exit$2935
$L3098:
  0013c	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0013f	89 4d f0	 mov	 DWORD PTR tv149[ebp], ecx
$exit$2935:

; 208  :         goto exit;
; 209  :     }
; 210  : 
; 211  : exit:
; 212  :     return wmaResult;

  00142	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 213  : }

  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c2 08 00	 ret	 8
_ibstrmLookForBits@8 ENDP
WMADEC	ENDS
PUBLIC	_ibstrmFlushBits@8
EXTRN	_g_cBitGet:DWORD
; Function compile flags: /Odt
;	COMDAT _ibstrmFlushBits@8
WMADEC	SEGMENT
tv150 = -16
tv135 = -12
_iBufLen$2948 = -8
_wmaResult$ = -4
_pibstrm$ = 8
_dwNumBits$ = 12
_ibstrmFlushBits@8 PROC NEAR				; COMDAT

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 217  :  
; 218  :     WMARESULT wmaResult = WMA_OK;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000b	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 219  : 
; 220  : #if defined(_DEBUG) || defined(BITRATE_REPORT)
; 221  :     g_cBitGet += dwNumBits;

  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_cBitGet
  00014	03 4d 0c	 add	 ecx, DWORD PTR _dwNumBits$[ebp]
  00017	89 0d 00 00 00
	00		 mov	 DWORD PTR _g_cBitGet, ecx
$L2945:

; 222  : #endif  // _DEBUG || BITRATE_REPORT
; 223  : 
; 224  :     assert (dwNumBits <= 24); //only works for sure under this
; 225  :     //make sure there is enougth data in dwDot for peek
; 226  :     while (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen > 0) {

  0001d	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00020	83 7a 24 18	 cmp	 DWORD PTR [edx+36], 24	; 00000018H
  00024	77 5e		 ja	 SHORT $L2946
  00026	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00029	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0002d	7e 55		 jle	 SHORT $L2946

; 227  :         pibstrm->m_dwDot <<= 8;

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00032	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00035	c1 e2 08	 shl	 edx, 8
  00038	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  0003b	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 228  :         pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;

  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00041	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00044	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  0004a	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0004d	0b d0		 or	 edx, eax
  0004f	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00052	89 50 20	 mov	 DWORD PTR [eax+32], edx
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00058	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0005b	83 c2 01	 add	 edx, 1
  0005e	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00061	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 229  :         --(pibstrm->m_cbBuflen);

  00064	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00067	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0006a	83 ea 01	 sub	 edx, 1
  0006d	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00070	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 230  :         pibstrm->m_dwBitsLeft += 8;    

  00073	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00076	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00079	83 c2 08	 add	 edx, 8
  0007c	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  0007f	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 231  :     }

  00082	eb 99		 jmp	 SHORT $L2945
$L2946:

; 232  :     if (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen <= 0)

  00084	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00087	83 79 24 18	 cmp	 DWORD PTR [ecx+36], 24	; 00000018H
  0008b	77 61		 ja	 SHORT $L2947
  0008d	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00090	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  00094	7f 58		 jg	 SHORT $L2947

; 233  :     {
; 234  :         U32 iBufLen;
; 235  : 
; 236  :         TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));

  00096	8d 45 f8	 lea	 eax, DWORD PTR _iBufLen$2948[ebp]
  00099	50		 push	 eax
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 _ibstrmGetMoreData@8
  000a3	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax
  000a6	83 7d fc 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  000aa	7d 42		 jge	 SHORT $L2947
  000ac	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000af	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  000b5	74 2f		 je	 SHORT $L3103
  000b7	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000ba	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  000c0	74 24		 je	 SHORT $L3103
  000c2	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000c5	51		 push	 ecx
  000c6	68 ec 00 00 00	 push	 236			; 000000ecH
  000cb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
  000d0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  000d5	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000d8	52		 push	 edx
  000d9	e8 00 00 00 00	 call	 _MyOutputDbgStr
  000de	83 c4 14	 add	 esp, 20			; 00000014H
  000e1	89 45 f4	 mov	 DWORD PTR tv135[ebp], eax
  000e4	eb 06		 jmp	 SHORT $L3104
$L3103:
  000e6	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000e9	89 45 f4	 mov	 DWORD PTR tv135[ebp], eax
$L3104:
  000ec	eb 6a		 jmp	 SHORT $exit$2951
$L2947:

; 237  :     }
; 238  : 
; 239  :     //take the data and go home; or we have to pause
; 240  :     if (dwNumBits <= pibstrm->m_dwBitsLeft)

  000ee	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  000f1	8b 55 0c	 mov	 edx, DWORD PTR _dwNumBits$[ebp]
  000f4	3b 51 24	 cmp	 edx, DWORD PTR [ecx+36]
  000f7	77 11		 ja	 SHORT $L2953

; 241  :         pibstrm->m_dwBitsLeft -= dwNumBits; 

  000f9	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  000fc	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000ff	2b 4d 0c	 sub	 ecx, DWORD PTR _dwNumBits$[ebp]
  00102	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00105	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 242  :     else 

  00108	eb 08		 jmp	 SHORT $L2954
$L2953:

; 243  :         TRACEWMA_EXIT (wmaResult, WMA_E_ONHOLD);

  0010a	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_ONHOLD
  0010f	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax
$L2954:
  00112	83 7d fc 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00116	7d 40		 jge	 SHORT $exit$2951
  00118	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0011b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  00121	74 2f		 je	 SHORT $L3105
  00123	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00126	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  0012c	74 24		 je	 SHORT $L3105
  0012e	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00131	50		 push	 eax
  00132	68 f3 00 00 00	 push	 243			; 000000f3H
  00137	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
  0013c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00141	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00144	51		 push	 ecx
  00145	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0014a	83 c4 14	 add	 esp, 20			; 00000014H
  0014d	89 45 f0	 mov	 DWORD PTR tv150[ebp], eax
  00150	eb 06		 jmp	 SHORT $exit$2951
$L3105:
  00152	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00155	89 55 f0	 mov	 DWORD PTR tv150[ebp], edx
$exit$2951:

; 244  : 
; 245  : exit:
; 246  :     return wmaResult;

  00158	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 247  : }

  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c2 08 00	 ret	 8
_ibstrmFlushBits@8 ENDP
WMADEC	ENDS
PUBLIC	_prvFinalLoad@16
; Function compile flags: /Odt
;	COMDAT _prvFinalLoad@16
WMADEC	SEGMENT
tv130 = -16
_iBufLen$ = -12
_dwPosition$ = -8
_wmaResult$ = -4
_pibstrm$ = 8
_dwRetval$ = 12
_dwBitsToAdd$ = 16
_piResult$ = 20
_prvFinalLoad@16 PROC NEAR				; COMDAT

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 254  :     WMARESULT   wmaResult = WMA_OK;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000b	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 255  :     U32         iBufLen;
; 256  :     UInt        dwPosition = 4;

  0000e	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _dwPosition$[ebp], 4

; 257  : 
; 258  :     pibstrm->m_dwDot = 0;

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00018	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 259  :     pibstrm->m_dwBitsLeft = 0;

  0001f	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00022	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0
$L2971:

; 260  : 
; 261  :     for (; pibstrm->m_cbBuflen>0;) {

  00029	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  0002c	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00030	7e 55		 jle	 SHORT $L2972

; 262  :         pibstrm->m_dwDot <<= 8;

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00035	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00038	c1 e2 08	 shl	 edx, 8
  0003b	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  0003e	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 263  :         pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;

  00041	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00044	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00047	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  0004d	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00050	0b d0		 or	 edx, eax
  00052	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00055	89 50 20	 mov	 DWORD PTR [eax+32], edx
  00058	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  0005b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0005e	83 c2 01	 add	 edx, 1
  00061	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00064	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 264  :         --(pibstrm->m_cbBuflen);

  00067	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  0006a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0006d	83 ea 01	 sub	 edx, 1
  00070	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00073	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 265  :         pibstrm->m_dwBitsLeft += 8;

  00076	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00079	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0007c	83 c2 08	 add	 edx, 8
  0007f	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00082	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 266  :     }

  00085	eb a2		 jmp	 SHORT $L2971
$L2972:

; 267  : 
; 268  :     TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));

  00087	8d 4d f4	 lea	 ecx, DWORD PTR _iBufLen$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 _ibstrmGetMoreData@8
  00094	89 45 fc	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00097	83 7d fc 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  0009b	7d 42		 jge	 SHORT $L2976
  0009d	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000a0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  000a6	74 2f		 je	 SHORT $L3110
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000ab	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  000b1	74 24		 je	 SHORT $L3110
  000b3	8b 55 fc	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  000b6	52		 push	 edx
  000b7	68 0c 01 00 00	 push	 268			; 0000010cH
  000bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
  000c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  000c6	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _MyOutputDbgStr
  000cf	83 c4 14	 add	 esp, 20			; 00000014H
  000d2	89 45 f0	 mov	 DWORD PTR tv130[ebp], eax
  000d5	eb 06		 jmp	 SHORT $L3111
$L3110:
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  000da	89 4d f0	 mov	 DWORD PTR tv130[ebp], ecx
$L3111:
  000dd	eb 66		 jmp	 SHORT $exit$2975
$L2976:

; 269  : 
; 270  :     if (iBufLen != 0) 

  000df	83 7d f4 00	 cmp	 DWORD PTR _iBufLen$[ebp], 0
  000e3	74 60		 je	 SHORT $exit$2975
$L2979:

; 271  :     { 
; 272  :         while (pibstrm->m_dwBitsLeft < dwBitsToAdd) 

  000e5	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  000e8	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000eb	3b 45 10	 cmp	 eax, DWORD PTR _dwBitsToAdd$[ebp]
  000ee	73 55		 jae	 SHORT $exit$2975

; 273  :         {
; 274  :             pibstrm->m_dwDot <<= 8;

  000f0	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  000f3	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000f6	c1 e2 08	 shl	 edx, 8
  000f9	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  000fc	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 275  :             pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;

  000ff	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00102	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00105	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00108	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  0010b	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0010e	0b d0		 or	 edx, eax
  00110	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00113	89 50 20	 mov	 DWORD PTR [eax+32], edx
  00116	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00119	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0011c	83 c2 01	 add	 edx, 1
  0011f	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00122	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 276  :             --(pibstrm->m_cbBuflen);

  00125	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00128	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0012b	83 ea 01	 sub	 edx, 1
  0012e	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00131	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 277  :             pibstrm->m_dwBitsLeft += 8;

  00134	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00137	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0013a	83 c2 08	 add	 edx, 8
  0013d	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00140	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 278  :             assert (pibstrm->m_dwBitsLeft <= 32);
; 279  :         }

  00143	eb a0		 jmp	 SHORT $L2979
$exit$2975:

; 280  :     }
; 281  : 
; 282  : exit:
; 283  :     dwRetval <<= dwBitsToAdd;

  00145	8b 55 0c	 mov	 edx, DWORD PTR _dwRetval$[ebp]
  00148	8b 4d 10	 mov	 ecx, DWORD PTR _dwBitsToAdd$[ebp]
  0014b	d3 e2		 shl	 edx, cl
  0014d	89 55 0c	 mov	 DWORD PTR _dwRetval$[ebp], edx

; 284  :     dwRetval |= (pibstrm->m_dwDot >> (pibstrm->m_dwBitsLeft - dwBitsToAdd)) & getMask[dwBitsToAdd];

  00150	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00153	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00156	2b 4d 10	 sub	 ecx, DWORD PTR _dwBitsToAdd$[ebp]
  00159	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0015c	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0015f	d3 e8		 shr	 eax, cl
  00161	8b 4d 10	 mov	 ecx, DWORD PTR _dwBitsToAdd$[ebp]
  00164	23 04 8d 00 00
	00 00		 and	 eax, DWORD PTR _getMask[ecx*4]
  0016b	8b 55 0c	 mov	 edx, DWORD PTR _dwRetval$[ebp]
  0016e	0b d0		 or	 edx, eax
  00170	89 55 0c	 mov	 DWORD PTR _dwRetval$[ebp], edx

; 285  :     pibstrm->m_dwBitsLeft -= dwBitsToAdd;

  00173	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00176	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00179	2b 4d 10	 sub	 ecx, DWORD PTR _dwBitsToAdd$[ebp]
  0017c	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0017f	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 286  :     *piResult = dwRetval;

  00182	8b 45 14	 mov	 eax, DWORD PTR _piResult$[ebp]
  00185	8b 4d 0c	 mov	 ecx, DWORD PTR _dwRetval$[ebp]
  00188	89 08		 mov	 DWORD PTR [eax], ecx

; 287  : 
; 288  :     return wmaResult; // bugbug: propagating the error screws up many things. FIX LATER

  0018a	8b 45 fc	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 289  :     //return WMA_OK;
; 290  : }

  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c2 10 00	 ret	 16			; 00000010H
_prvFinalLoad@16 ENDP
WMADEC	ENDS
PUBLIC	_WMA_set_fNoMoreData@8
PUBLIC	_WMA_get_nHdrBits@4
; Function compile flags: /Odt
;	COMDAT _ibstrmGetMoreData@8
WMADEC	SEGMENT
tv208 = -44
tv186 = -40
tv82 = -36
_cPacketNumBitsRS$3004 = -32
_nHdrBits$3003 = -25
_iPrevPacketNum$3001 = -24
_iNextPacketNum$3002 = -20
_iFirstBit$ = -16
_temp$ = -9
_wmaResult$ = -8
_fNewPacket$ = -4
_pibs$ = 8
_piBufLen$ = 12
_ibstrmGetMoreData@8 PROC NEAR				; COMDAT

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 295  :     //a new packet
; 296  :     I32 iFirstBit = 0;

  00006	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iFirstBit$[ebp], 0

; 297  :     U8 temp;
; 298  : 
; 299  :     WMARESULT   wmaResult;
; 300  :     Bool        fNewPacket;
; 301  : 
; 302  :     assert (pibs->m_cbBuflen == 0);
; 303  :     TRACEWMA_EXIT(wmaResult, pibs->m_pfnGetMoreData(&pibs->m_pBuffer,
; 304  :         (U32 *)&pibs->m_cbBuflen, pibs->m_dwUser, pibs->m_pBufferExtra));

  0000d	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  00010	83 c0 34	 add	 eax, 52			; 00000034H
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  0001e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  00025	83 c1 18	 add	 ecx, 24			; 00000018H
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  0002c	ff 12		 call	 DWORD PTR [edx]
  0002e	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax
  00031	83 7d f8 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00035	7d 45		 jge	 SHORT $L2994
  00037	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  0003a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00040	74 2f		 je	 SHORT $L3115
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00045	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  0004b	74 24		 je	 SHORT $L3115
  0004d	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00050	52		 push	 edx
  00051	68 30 01 00 00	 push	 304			; 00000130H
  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00060	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00069	83 c4 14	 add	 esp, 20			; 00000014H
  0006c	89 45 dc	 mov	 DWORD PTR tv82[ebp], eax
  0006f	eb 06		 jmp	 SHORT $L3116
$L3115:
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00074	89 4d dc	 mov	 DWORD PTR tv82[ebp], ecx
$L3116:
  00077	e9 ee 02 00 00	 jmp	 $exit$2993
$L2994:

; 305  : 	pibs->m_pBuffer = pibs->m_pBufferExtra;

  0007c	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  0007f	83 c2 34	 add	 edx, 52			; 00000034H
  00082	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  00085	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 306  :     fNewPacket = (wmaResult == WMA_S_NEWPACKET);

  00088	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  0008b	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _WMA_S_NEWPACKET
  00091	f7 d9		 neg	 ecx
  00093	1b c9		 sbb	 ecx, ecx
  00095	41		 inc	 ecx
  00096	89 4d fc	 mov	 DWORD PTR _fNewPacket$[ebp], ecx

; 307  : 
; 308  :     assert(NULL != piBufLen); // Cut down on expensive conditionals
; 309  :     if(pibs->m_cbBuflen == 0)

  00099	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  0009c	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  000a0	75 24		 jne	 SHORT $L2995

; 310  :     {
; 311  :         WMA_set_fNoMoreData(pibs->m_dwOwner, 1);

  000a2	6a 01		 push	 1
  000a4	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  000a7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000aa	51		 push	 ecx
  000ab	e8 00 00 00 00	 call	 _WMA_set_fNoMoreData@8

; 312  :         *piBufLen = 0;

  000b0	8b 55 0c	 mov	 edx, DWORD PTR _piBufLen$[ebp]
  000b3	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 313  :         wmaResult = WMA_OK;

  000b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  000be	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 314  :         goto exit;

  000c1	e9 a4 02 00 00	 jmp	 $exit$2993
$L2995:

; 315  :     }
; 316  :     WMA_set_fNoMoreData(pibs->m_dwOwner, 0);

  000c6	6a 00		 push	 0
  000c8	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  000cb	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 _WMA_set_fNoMoreData@8

; 317  : 
; 318  : #ifdef WMA2CMP
; 319  :     {   // write out bits to a .cmp file
; 320  :         extern FILE *pfWma2Cmp;       // file (and flag) to output .cmp file
; 321  :         if (pfWma2Cmp != NULL)
; 322  :         {
; 323  :             size_t uWritten = fwrite(pibs->m_pBuffer,pibs->m_cbBuflen,1,pfWma2Cmp);
; 324  :             // Asserts are a lousy way to report errors, but this is for internal test purposes only
; 325  :             assert( uWritten == 1 );
; 326  :         }
; 327  :     }
; 328  : #endif
; 329  : 
; 330  :     if (fNewPacket)

  000d4	83 7d fc 00	 cmp	 DWORD PTR _fNewPacket$[ebp], 0
  000d8	74 18		 je	 SHORT $L2996

; 331  :     {
; 332  :         pibs->m_pBufferBegin = pibs->m_pBuffer;

  000da	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  000dd	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  000e0	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000e3	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 333  :         pibs->m_cbBuflenBegin = pibs->m_cbBuflen;

  000e6	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  000e9	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  000ec	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000ef	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L2996:

; 334  :     }
; 335  : 
; 336  :     if (WMAB_FALSE == pibs->m_fAllowPackets)

  000f2	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  000f5	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  000f9	75 20		 jne	 SHORT $L2997

; 337  :     {
; 338  :         // In non-superframe mode, provide a running packet count that wraps around (to avoid I32 vs. U32 issues)
; 339  :         if (fNewPacket)

  000fb	83 7d fc 00	 cmp	 DWORD PTR _fNewPacket$[ebp], 0
  000ff	74 15		 je	 SHORT $L2998

; 340  :         {
; 341  :             assert(((~(NONSUPER_WRAPAROUND - 1) << 1) & NONSUPER_WRAPAROUND) == 0); // assert Pwr of 2
; 342  :             pibs->m_dwHeaderBuf = (pibs->m_dwHeaderBuf + 1) & (NONSUPER_WRAPAROUND - 1);

  00101	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  00104	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00107	83 c2 01	 add	 edx, 1
  0010a	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00110	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  00113	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$L2998:

; 343  :         }
; 344  :     }
; 345  :     else if (fNewPacket) //set up packet header in superframe mode

  00116	e9 b1 01 00 00	 jmp	 $L3012
$L2997:
  0011b	83 7d fc 00	 cmp	 DWORD PTR _fNewPacket$[ebp], 0
  0011f	0f 84 a7 01 00
	00		 je	 $L3012

; 346  :     {
; 347  :         Int iPrevPacketNum, iNextPacketNum;
; 348  :         unsigned char nHdrBits = WMA_get_nHdrBits(pibs->m_dwOwner); // this only updates per file

  00125	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  00128	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0012b	52		 push	 edx
  0012c	e8 00 00 00 00	 call	 _WMA_get_nHdrBits@4
  00131	88 45 e7	 mov	 BYTE PTR _nHdrBits$3003[ebp], al

; 349  :         const int cPacketNumBitsRS = (BITS_PER_DWORD - NBITS_PACKET_CNT);

  00134	c7 45 e0 1c 00
	00 00		 mov	 DWORD PTR _cPacketNumBitsRS$3004[ebp], 28 ; 0000001cH

; 350  : 
; 351  :         iFirstBit = nHdrBits % 8;

  0013b	0f b6 45 e7	 movzx	 eax, BYTE PTR _nHdrBits$3003[ebp]
  0013f	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00144	79 05		 jns	 SHORT $L3121
  00146	48		 dec	 eax
  00147	83 c8 f8	 or	 eax, -8			; fffffff8H
  0014a	40		 inc	 eax
$L3121:
  0014b	89 45 f0	 mov	 DWORD PTR _iFirstBit$[ebp], eax

; 352  :         assert (pibs->m_pBuffer != NULL); //always get a valid one
; 353  :         pibs->m_dwHeaderBuf = 0;

  0014e	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  00151	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 354  :         pibs->m_dwHeaderBuf = (pibs->m_pBuffer[0]<<24)|(pibs->m_pBuffer[1]<<16)|(pibs->m_pBuffer[2]<<8)|pibs->m_pBuffer[3];

  00158	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  0015b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0015e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00161	c1 e1 18	 shl	 ecx, 24			; 00000018H
  00164	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  00167	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0016a	0f b6 50 01	 movzx	 edx, BYTE PTR [eax+1]
  0016e	c1 e2 10	 shl	 edx, 16			; 00000010H
  00171	0b ca		 or	 ecx, edx
  00173	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  00176	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00179	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  0017d	c1 e0 08	 shl	 eax, 8
  00180	0b c8		 or	 ecx, eax
  00182	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  00185	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00188	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  0018c	0b ca		 or	 ecx, edx
  0018e	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  00191	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 355  :         pibs->m_pBuffer += nHdrBits / 8;

  00194	0f b6 45 e7	 movzx	 eax, BYTE PTR _nHdrBits$3003[ebp]
  00198	99		 cdq
  00199	83 e2 07	 and	 edx, 7
  0019c	03 c2		 add	 eax, edx
  0019e	c1 f8 03	 sar	 eax, 3
  001a1	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  001a4	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  001a7	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  001aa	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 356  :         pibs->m_cbBuflen -= nHdrBits / 8;

  001ad	0f b6 45 e7	 movzx	 eax, BYTE PTR _nHdrBits$3003[ebp]
  001b1	99		 cdq
  001b2	83 e2 07	 and	 edx, 7
  001b5	03 c2		 add	 eax, edx
  001b7	c1 f8 03	 sar	 eax, 3
  001ba	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  001bd	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  001c0	2b d0		 sub	 edx, eax
  001c2	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  001c5	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 357  :         assert (nHdrBits < BITS_PER_DWORD);
; 358  :         assert (pibs->m_dwBitsLeft <= 24);  //so that we have enough to save the fractional byte that would otherwise be lost
; 359  : 
; 360  :         // Now we should check that we didn't lose a packet
; 361  :         iNextPacketNum = (pibs->m_dwHeaderBuf >> cPacketNumBitsRS);

  001c8	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  001cb	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001ce	8b 4d e0	 mov	 ecx, DWORD PTR _cPacketNumBitsRS$3004[ebp]
  001d1	d3 ea		 shr	 edx, cl
  001d3	89 55 ec	 mov	 DWORD PTR _iNextPacketNum$3002[ebp], edx

; 362  :         iPrevPacketNum = pibs->m_iPrevPacketNum;

  001d6	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  001d9	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001dc	89 4d e8	 mov	 DWORD PTR _iPrevPacketNum$3001[ebp], ecx

; 363  :         pibs->m_iPrevPacketNum = iNextPacketNum;

  001df	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  001e2	8b 45 ec	 mov	 eax, DWORD PTR _iNextPacketNum$3002[ebp]
  001e5	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 364  :         if (WMAB_FALSE == pibs->m_fSuppressPacketLoss)

  001e8	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  001eb	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  001ef	0f 85 cd 00 00
	00		 jne	 $L3005

; 365  :         {
; 366  :             if (WMAB_FALSE == (iNextPacketNum - iPrevPacketNum == 1 || 
; 367  : //                iNextPacketNum - iPrevPacketNum == 0 ||
; 368  :                 iNextPacketNum - iPrevPacketNum + (1 << NBITS_PACKET_CNT) == 1))

  001f5	8b 55 ec	 mov	 edx, DWORD PTR _iNextPacketNum$3002[ebp]
  001f8	2b 55 e8	 sub	 edx, DWORD PTR _iPrevPacketNum$3001[ebp]
  001fb	83 fa 01	 cmp	 edx, 1
  001fe	74 17		 je	 SHORT $L3117
  00200	8b 45 ec	 mov	 eax, DWORD PTR _iNextPacketNum$3002[ebp]
  00203	2b 45 e8	 sub	 eax, DWORD PTR _iPrevPacketNum$3001[ebp]
  00206	83 c0 10	 add	 eax, 16			; 00000010H
  00209	83 f8 01	 cmp	 eax, 1
  0020c	74 09		 je	 SHORT $L3117
  0020e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv186[ebp], 0
  00215	eb 07		 jmp	 SHORT $L3118
$L3117:
  00217	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv186[ebp], 1
$L3118:
  0021e	83 7d d8 00	 cmp	 DWORD PTR tv186[ebp], 0
  00222	0f 85 98 00 00
	00		 jne	 $L3006

; 369  :             {
; 370  :                 // PACKET LOSS: Return error. Next call to DecodeInfo will cue to next frame
; 371  :                 *piBufLen = 0;

  00228	8b 4d 0c	 mov	 ecx, DWORD PTR _piBufLen$[ebp]
  0022b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 372  : 				pibs->m_pBuffer = pibs->m_pBufferBegin + 4;

  00231	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  00234	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00237	83 c0 04	 add	 eax, 4
  0023a	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  0023d	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 373  : 				pibs->m_cbBuflen = pibs->m_cbBuflenBegin - 4;

  00240	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  00243	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00246	83 e8 04	 sub	 eax, 4
  00249	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  0024c	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 374  : 
; 375  : 				pibs->m_dwDot = pibs->m_dwHeaderBuf;

  0024f	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  00252	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  00255	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00258	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 376  : 				assert (nHdrBits <= 32);
; 377  : 				pibs->m_dwBitsLeft = 32 - nHdrBits;

  0025b	0f b6 55 e7	 movzx	 edx, BYTE PTR _nHdrBits$3003[ebp]
  0025f	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00264	2b c2		 sub	 eax, edx
  00266	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  00269	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 378  : 
; 379  :                 TRACEWMA_EXIT (wmaResult, WMA_E_LOSTPACKET);

  0026c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_LOSTPACKET
  00272	89 55 f8	 mov	 DWORD PTR _wmaResult$[ebp], edx
  00275	83 7d f8 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00279	7d 45		 jge	 SHORT $L3006
  0027b	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  0027e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00284	74 2f		 je	 SHORT $L3119
  00286	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00289	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  0028f	74 24		 je	 SHORT $L3119
  00291	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00294	52		 push	 edx
  00295	68 7b 01 00 00	 push	 379			; 0000017bH
  0029a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
  0029f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  002a4	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  002a7	50		 push	 eax
  002a8	e8 00 00 00 00	 call	 _MyOutputDbgStr
  002ad	83 c4 14	 add	 esp, 20			; 00000014H
  002b0	89 45 d4	 mov	 DWORD PTR tv208[ebp], eax
  002b3	eb 06		 jmp	 SHORT $L3120
$L3119:
  002b5	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  002b8	89 4d d4	 mov	 DWORD PTR tv208[ebp], ecx
$L3120:
  002bb	e9 aa 00 00 00	 jmp	 $exit$2993
$L3006:

; 380  :             }
; 381  :         }
; 382  :         else

  002c0	eb 0a		 jmp	 SHORT $L3012
$L3005:

; 383  :             // Avoid checking for packet loss, eg, after a seek
; 384  :             pibs->m_fSuppressPacketLoss = WMAB_FALSE;

  002c2	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  002c5	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0
$L3012:

; 385  :     }
; 386  : 
; 387  :     while (pibs->m_cbBuflen > 0 && pibs->m_dwBitsLeft <= 24)    {

  002cc	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  002cf	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  002d3	0f 8e 86 00 00
	00		 jle	 $L3013
  002d9	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  002dc	83 79 24 18	 cmp	 DWORD PTR [ecx+36], 24	; 00000018H
  002e0	77 7d		 ja	 SHORT $L3013

; 388  :         temp = (*pibs->m_pBuffer++);

  002e2	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  002e5	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  002e8	8a 08		 mov	 cl, BYTE PTR [eax]
  002ea	88 4d f7	 mov	 BYTE PTR _temp$[ebp], cl
  002ed	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  002f0	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  002f3	83 c0 01	 add	 eax, 1
  002f6	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  002f9	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 389  :         pibs->m_cbBuflen--;

  002fc	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  002ff	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00302	83 e8 01	 sub	 eax, 1
  00305	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  00308	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 390  : 
; 391  :         //zeros out the top (not valid) bits
; 392  :         temp = temp<<iFirstBit;

  0030b	0f b6 55 f7	 movzx	 edx, BYTE PTR _temp$[ebp]
  0030f	8b 4d f0	 mov	 ecx, DWORD PTR _iFirstBit$[ebp]
  00312	d3 e2		 shl	 edx, cl
  00314	88 55 f7	 mov	 BYTE PTR _temp$[ebp], dl

; 393  :         temp = temp>>iFirstBit;

  00317	0f b6 45 f7	 movzx	 eax, BYTE PTR _temp$[ebp]
  0031b	8b 4d f0	 mov	 ecx, DWORD PTR _iFirstBit$[ebp]
  0031e	d3 f8		 sar	 eax, cl
  00320	88 45 f7	 mov	 BYTE PTR _temp$[ebp], al

; 394  :         pibs->m_dwDot = (pibs->m_dwDot<<(8 - iFirstBit))|temp;

  00323	b9 08 00 00 00	 mov	 ecx, 8
  00328	2b 4d f0	 sub	 ecx, DWORD PTR _iFirstBit$[ebp]
  0032b	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  0032e	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00331	d3 e0		 shl	 eax, cl
  00333	0f b6 4d f7	 movzx	 ecx, BYTE PTR _temp$[ebp]
  00337	0b c1		 or	 eax, ecx
  00339	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  0033c	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 395  : 
; 396  :         pibs->m_dwBitsLeft += (8 - iFirstBit);

  0033f	b8 08 00 00 00	 mov	 eax, 8
  00344	2b 45 f0	 sub	 eax, DWORD PTR _iFirstBit$[ebp]
  00347	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  0034a	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  0034d	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  00350	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 397  :         iFirstBit = 0;

  00353	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iFirstBit$[ebp], 0

; 398  :     }

  0035a	e9 6d ff ff ff	 jmp	 $L3012
$L3013:

; 399  :     *piBufLen = pibs->m_cbBuflen;

  0035f	8b 45 0c	 mov	 eax, DWORD PTR _piBufLen$[ebp]
  00362	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  00365	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00368	89 10		 mov	 DWORD PTR [eax], edx
$exit$2993:

; 400  : 
; 401  : exit:
; 402  :     return wmaResult;

  0036a	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 403  : }

  0036d	8b e5		 mov	 esp, ebp
  0036f	5d		 pop	 ebp
  00370	c2 08 00	 ret	 8
_ibstrmGetMoreData@8 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\decoder\msaudiodec.h
WMADEC	ENDS
;	COMDAT _WMA_set_fNoMoreData@8
WMADEC	SEGMENT
_hWMA$ = 8
_iVal$ = 12
_WMA_set_fNoMoreData@8 PROC NEAR			; COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 265  :     ((CAudioObjectDecoder *)hWMA)->m_fNoMoreData = iVal;

  00003	8b 45 08	 mov	 eax, DWORD PTR _hWMA$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _iVal$[ebp]
  00009	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 266  : }

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
_WMA_set_fNoMoreData@8 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _WMA_get_nHdrBits@4
WMADEC	SEGMENT
_pau$ = -4
_hWMA$ = 8
_WMA_get_nHdrBits@4 PROC NEAR				; COMDAT

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 270  :     const CAudioObject *pau = ((CAudioObjectDecoder *)hWMA)->pau;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hWMA$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _pau$[ebp], ecx

; 271  : 
; 272  :     if (pau->m_fAllowSuperFrame)

  0000c	8b 55 fc	 mov	 edx, DWORD PTR _pau$[ebp]
  0000f	83 7a 64 00	 cmp	 DWORD PTR [edx+100], 0
  00013	74 0b		 je	 SHORT $L2848

; 273  :         return (U8)(pau->m_cBitPackedFrameSize + NBITS_FRM_CNT + NBITS_PACKET_CNT + 3);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _pau$[ebp]
  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001b	83 c0 0b	 add	 eax, 11			; 0000000bH
  0001e	eb 02		 jmp	 SHORT $L2845
$L2848:

; 274  :     else
; 275  :         return 0;

  00020	32 c0		 xor	 al, al
$L2845:

; 276  : }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
_WMA_get_nHdrBits@4 ENDP
WMADEC	ENDS
PUBLIC	_ibstrmResetPacket@4
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\strmdec_wma.c
;	COMDAT _ibstrmResetPacket@4
WMADEC	SEGMENT
_iFirstBit$ = -8
_nHdrBits$ = -2
_temp$ = -1
_pibs$ = 8
_ibstrmResetPacket@4 PROC NEAR				; COMDAT

; 406  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 407  :     U8 nHdrBits = WMA_get_nHdrBits(pibs->m_dwOwner); // this only updates per file

  00006	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _WMA_get_nHdrBits@4
  00012	88 45 fe	 mov	 BYTE PTR _nHdrBits$[ebp], al

; 408  :     I32 iFirstBit;
; 409  :     U8 temp;
; 410  : 
; 411  :     assert (pibs->m_pBuffer != 0);
; 412  :     assert (WMA_get_fNoMoreData(pibs->m_dwOwner) == WMAB_FALSE);
; 413  :     //skip the packet header
; 414  :     iFirstBit = nHdrBits % 8;

  00015	0f b6 55 fe	 movzx	 edx, BYTE PTR _nHdrBits$[ebp]
  00019	81 e2 07 00 00
	80		 and	 edx, -2147483641	; 80000007H
  0001f	79 05		 jns	 SHORT $L3131
  00021	4a		 dec	 edx
  00022	83 ca f8	 or	 edx, -8			; fffffff8H
  00025	42		 inc	 edx
$L3131:
  00026	89 55 f8	 mov	 DWORD PTR _iFirstBit$[ebp], edx

; 415  :     pibs->m_pBuffer = pibs->m_pBufferBegin;

  00029	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  0002f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00032	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 416  :     pibs->m_pBuffer += nHdrBits / 8;

  00035	0f b6 45 fe	 movzx	 eax, BYTE PTR _nHdrBits$[ebp]
  00039	99		 cdq
  0003a	83 e2 07	 and	 edx, 7
  0003d	03 c2		 add	 eax, edx
  0003f	c1 f8 03	 sar	 eax, 3
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  00045	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  00048	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  0004b	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 417  :     pibs->m_cbBuflen = pibs->m_cbBuflenBegin - nHdrBits / 8;

  0004e	0f b6 45 fe	 movzx	 eax, BYTE PTR _nHdrBits$[ebp]
  00052	99		 cdq
  00053	83 e2 07	 and	 edx, 7
  00056	03 c2		 add	 eax, edx
  00058	c1 f8 03	 sar	 eax, 3
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  0005e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00061	2b d0		 sub	 edx, eax
  00063	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  00066	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 418  : 
; 419  :     temp = (*pibs->m_pBuffer++);

  00069	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  0006c	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0006f	8a 02		 mov	 al, BYTE PTR [edx]
  00071	88 45 ff	 mov	 BYTE PTR _temp$[ebp], al
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  00077	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0007a	83 c2 01	 add	 edx, 1
  0007d	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  00080	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 420  :     pibs->m_cbBuflen--;

  00083	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  00086	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00089	83 ea 01	 sub	 edx, 1
  0008c	8b 45 08	 mov	 eax, DWORD PTR _pibs$[ebp]
  0008f	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 421  : 
; 422  :     //zeros out the top (not valid) bits
; 423  :     temp = temp<<iFirstBit;

  00092	0f b6 55 ff	 movzx	 edx, BYTE PTR _temp$[ebp]
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _iFirstBit$[ebp]
  00099	d3 e2		 shl	 edx, cl
  0009b	88 55 ff	 mov	 BYTE PTR _temp$[ebp], dl

; 424  :     temp = temp>>iFirstBit;

  0009e	0f b6 45 ff	 movzx	 eax, BYTE PTR _temp$[ebp]
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR _iFirstBit$[ebp]
  000a5	d3 f8		 sar	 eax, cl
  000a7	88 45 ff	 mov	 BYTE PTR _temp$[ebp], al

; 425  :     pibs->m_dwDot = temp;

  000aa	0f b6 4d ff	 movzx	 ecx, BYTE PTR _temp$[ebp]
  000ae	8b 55 08	 mov	 edx, DWORD PTR _pibs$[ebp]
  000b1	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 426  :     pibs->m_dwBitsLeft = (8 - iFirstBit);

  000b4	b8 08 00 00 00	 mov	 eax, 8
  000b9	2b 45 f8	 sub	 eax, DWORD PTR _iFirstBit$[ebp]
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _pibs$[ebp]
  000bf	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 427  : }

  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 04 00	 ret	 4
_ibstrmResetPacket@4 ENDP
WMADEC	ENDS
PUBLIC	_ibstrmGetBits@12
; Function compile flags: /Odt
;	COMDAT _ibstrmGetBits@12
WMADEC	SEGMENT
tv197 = -36
tv187 = -32
tv81 = -28
_wmaFOOFOO$3046 = -24
_dwAcc$3041 = -20
_iBufLen$3031 = -16
_dwRetval$ = -12
_wmaResult$ = -8
_dwShift$ = -4
_pibstrm$ = 8
_dwNumBits$ = 12
_piResult$ = 16
_ibstrmGetBits@12 PROC NEAR				; COMDAT

; 431  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 432  :     WMARESULT   wmaResult = WMA_OK;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  0000b	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 433  :     register UInt dwRetval;
; 434  :     register UInt dwShift;
; 435  : 
; 436  : #if defined(_DEBUG) || defined(BITRATE_REPORT)
; 437  :     g_cBitGet += dwNumBits;

  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_cBitGet
  00014	03 4d 0c	 add	 ecx, DWORD PTR _dwNumBits$[ebp]
  00017	89 0d 00 00 00
	00		 mov	 DWORD PTR _g_cBitGet, ecx

; 438  : #endif  // _DEBUG || BITRATE_REPORT
; 439  : 
; 440  :     if (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen <= 0)

  0001d	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00020	83 7a 24 18	 cmp	 DWORD PTR [edx+36], 24	; 00000018H
  00024	77 64		 ja	 SHORT $L3030
  00026	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  00029	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0002d	7f 5b		 jg	 SHORT $L3030

; 441  :     {
; 442  :         U32         iBufLen;
; 443  :         TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));

  0002f	8d 4d f0	 lea	 ecx, DWORD PTR _iBufLen$3031[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 _ibstrmGetMoreData@8
  0003c	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax
  0003f	83 7d f8 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00043	7d 45		 jge	 SHORT $L3030
  00045	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00048	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  0004e	74 2f		 je	 SHORT $L3135
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  00059	74 24		 je	 SHORT $L3135
  0005b	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  0005e	52		 push	 edx
  0005f	68 bb 01 00 00	 push	 443			; 000001bbH
  00064	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
  00069	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0006e	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00077	83 c4 14	 add	 esp, 20			; 00000014H
  0007a	89 45 e4	 mov	 DWORD PTR tv81[ebp], eax
  0007d	eb 06		 jmp	 SHORT $L3136
$L3135:
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00082	89 4d e4	 mov	 DWORD PTR tv81[ebp], ecx
$L3136:
  00085	e9 0e 02 00 00	 jmp	 $exit$3034
$L3030:

; 444  :     }
; 445  : 
; 446  :     //
; 447  :     // This is a little unwieldly, but make sure the end-of-file test falls
; 448  :     // through in the usual (not end-of-file) case to avoid CPU pipeline stalls
; 449  :     // due to a branch (or mispredictions on more sophisticated processors).
; 450  :     //
; 451  :     if (((UInt) (pibstrm->m_cbBuflen << 3) >= dwNumBits || 
; 452  :         pibstrm->m_dwBitsLeft + (pibstrm->m_cbBuflen << 3) >= dwNumBits)) {

  0008a	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  0008d	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00090	c1 e0 03	 shl	 eax, 3
  00093	3b 45 0c	 cmp	 eax, DWORD PTR _dwNumBits$[ebp]
  00096	73 18		 jae	 SHORT $L3038
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  0009b	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0009e	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  000a1	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000a4	8d 14 d1	 lea	 edx, DWORD PTR [ecx+edx*8]
  000a7	3b 55 0c	 cmp	 edx, DWORD PTR _dwNumBits$[ebp]
  000aa	0f 82 90 01 00
	00		 jb	 $L3037
$L3038:

; 453  :         //
; 454  :         // Do the most common case first.  If this doesn't play, we have one branch
; 455  :         // to get to the next most common case (usually 1/32 of the time in the case
; 456  :         // of the codec doing a huffman decode).  Note that we use a mask array to
; 457  :         // avoid a special case branch when the bitcount is 32 (even though this is
; 458  :         // relatively unlikely) since a left shift operation where the shift count
; 459  :         // is equal to or greater than the number of bits in the destination is
; 460  :         // undefined.
; 461  :         //
; 462  :         if (dwNumBits <= pibstrm->m_dwBitsLeft) {

  000b0	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  000b3	8b 4d 0c	 mov	 ecx, DWORD PTR _dwNumBits$[ebp]
  000b6	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  000b9	77 3a		 ja	 SHORT $L3039

; 463  :             pibstrm->m_dwBitsLeft -= dwNumBits;

  000bb	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  000be	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000c1	2b 45 0c	 sub	 eax, DWORD PTR _dwNumBits$[ebp]
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  000c7	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 464  : 			*piResult = (pibstrm->m_dwDot >> pibstrm->m_dwBitsLeft) & getMask[dwNumBits];

  000ca	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  000cd	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  000d0	8b 52 20	 mov	 edx, DWORD PTR [edx+32]
  000d3	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000d6	d3 ea		 shr	 edx, cl
  000d8	8b 45 0c	 mov	 eax, DWORD PTR _dwNumBits$[ebp]
  000db	23 14 85 00 00
	00 00		 and	 edx, DWORD PTR _getMask[eax*4]
  000e2	8b 4d 10	 mov	 ecx, DWORD PTR _piResult$[ebp]
  000e5	89 11		 mov	 DWORD PTR [ecx], edx

; 465  :             wmaResult = WMA_OK;

  000e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_OK
  000ed	89 55 f8	 mov	 DWORD PTR _wmaResult$[ebp], edx

; 466  :             goto exit;

  000f0	e9 a3 01 00 00	 jmp	 $exit$3034
$L3039:

; 467  :         }
; 468  :         //
; 469  :         // The next most common case is when we have lots of data left in the buffer.
; 470  :         // and we can fully load (i.e., all 32-bits) our accumulator.  This is
; 471  :         // hard-wired to allow an optimizer to go crazy with all of the constants.
; 472  :         // Note that the data is byte-swapped on the way in.
; 473  :         //
; 474  :         dwRetval = pibstrm->m_dwDot & getMask[pibstrm->m_dwBitsLeft];

  000f5	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  000f8	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000fb	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  000fe	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00101	23 04 8d 00 00
	00 00		 and	 eax, DWORD PTR _getMask[ecx*4]
  00108	89 45 f4	 mov	 DWORD PTR _dwRetval$[ebp], eax

; 475  :         dwShift = dwNumBits - pibstrm->m_dwBitsLeft;

  0010b	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  0010e	8b 55 0c	 mov	 edx, DWORD PTR _dwNumBits$[ebp]
  00111	2b 51 24	 sub	 edx, DWORD PTR [ecx+36]
  00114	89 55 fc	 mov	 DWORD PTR _dwShift$[ebp], edx

; 476  : 
; 477  :         if (pibstrm->m_cbBuflen >= 4) {

  00117	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  0011a	83 78 1c 04	 cmp	 DWORD PTR [eax+28], 4
  0011e	0f 8c b6 00 00
	00		 jl	 $L3040

; 478  :             register UInt     dwAcc;
; 479  : 
; 480  :             dwAcc = (UInt)pibstrm->m_pBuffer[3];

  00124	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00127	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0012a	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  0012e	89 45 ec	 mov	 DWORD PTR _dwAcc$3041[ebp], eax

; 481  :             dwAcc |= (UInt)(pibstrm->m_pBuffer[2]) << 8;

  00131	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00134	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00137	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  0013b	c1 e0 08	 shl	 eax, 8
  0013e	8b 4d ec	 mov	 ecx, DWORD PTR _dwAcc$3041[ebp]
  00141	0b c8		 or	 ecx, eax
  00143	89 4d ec	 mov	 DWORD PTR _dwAcc$3041[ebp], ecx

; 482  :             dwAcc |= (UInt)(pibstrm->m_pBuffer[1]) << 16;

  00146	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00149	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0014c	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00150	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00153	8b 55 ec	 mov	 edx, DWORD PTR _dwAcc$3041[ebp]
  00156	0b d1		 or	 edx, ecx
  00158	89 55 ec	 mov	 DWORD PTR _dwAcc$3041[ebp], edx

; 483  :             dwAcc |= (UInt)(pibstrm->m_pBuffer[0]) << 24;

  0015b	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  0015e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00161	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00164	c1 e2 18	 shl	 edx, 24			; 00000018H
  00167	8b 45 ec	 mov	 eax, DWORD PTR _dwAcc$3041[ebp]
  0016a	0b c2		 or	 eax, edx
  0016c	89 45 ec	 mov	 DWORD PTR _dwAcc$3041[ebp], eax

; 484  :             pibstrm->m_dwDot = dwAcc;

  0016f	8b 4d 08	 mov	 ecx, DWORD PTR _pibstrm$[ebp]
  00172	8b 55 ec	 mov	 edx, DWORD PTR _dwAcc$3041[ebp]
  00175	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 485  :             pibstrm->m_pBuffer += 4;

  00178	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  0017b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0017e	83 c1 04	 add	 ecx, 4
  00181	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00184	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 486  :             pibstrm->m_cbBuflen -= 4;

  00187	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  0018a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0018d	83 e9 04	 sub	 ecx, 4
  00190	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  00193	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 487  :             dwRetval <<= dwShift;

  00196	8b 45 f4	 mov	 eax, DWORD PTR _dwRetval$[ebp]
  00199	8b 4d fc	 mov	 ecx, DWORD PTR _dwShift$[ebp]
  0019c	d3 e0		 shl	 eax, cl
  0019e	89 45 f4	 mov	 DWORD PTR _dwRetval$[ebp], eax

; 488  :             dwRetval |= (dwAcc >> (32 - dwShift));// & getMask[dwShift];

  001a1	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001a6	2b 4d fc	 sub	 ecx, DWORD PTR _dwShift$[ebp]
  001a9	8b 55 ec	 mov	 edx, DWORD PTR _dwAcc$3041[ebp]
  001ac	d3 ea		 shr	 edx, cl
  001ae	8b 45 f4	 mov	 eax, DWORD PTR _dwRetval$[ebp]
  001b1	0b c2		 or	 eax, edx
  001b3	89 45 f4	 mov	 DWORD PTR _dwRetval$[ebp], eax

; 489  :             pibstrm->m_dwBitsLeft = 32 - dwShift;

  001b6	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001bb	2b 4d fc	 sub	 ecx, DWORD PTR _dwShift$[ebp]
  001be	8b 55 08	 mov	 edx, DWORD PTR _pibstrm$[ebp]
  001c1	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 490  :             *piResult = dwRetval;

  001c4	8b 45 10	 mov	 eax, DWORD PTR _piResult$[ebp]
  001c7	8b 4d f4	 mov	 ecx, DWORD PTR _dwRetval$[ebp]
  001ca	89 08		 mov	 DWORD PTR [eax], ecx

; 491  :             wmaResult = WMA_OK;

  001cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_OK
  001d2	89 55 f8	 mov	 DWORD PTR _wmaResult$[ebp], edx

; 492  :             goto exit;

  001d5	e9 be 00 00 00	 jmp	 $exit$3034
$L3040:

; 493  :         }
; 494  :         //
; 495  :         // The final, and least likely case, is when we're at the end of the buffer.
; 496  :         // Since there's really no point in having this inlined since it'll only
; 497  :         // happen once, I'll call a function to make it happen and save the space
; 498  :         // in the inline instances of getBits().
; 499  :         //
; 500  : 		wmaResult = prvFinalLoad(pibstrm, dwRetval, dwShift, piResult);

  001da	8b 45 10	 mov	 eax, DWORD PTR _piResult$[ebp]
  001dd	50		 push	 eax
  001de	8b 4d fc	 mov	 ecx, DWORD PTR _dwShift$[ebp]
  001e1	51		 push	 ecx
  001e2	8b 55 f4	 mov	 edx, DWORD PTR _dwRetval$[ebp]
  001e5	52		 push	 edx
  001e6	8b 45 08	 mov	 eax, DWORD PTR _pibstrm$[ebp]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 _prvFinalLoad@16
  001ef	89 45 f8	 mov	 DWORD PTR _wmaResult$[ebp], eax

; 501  :         TraceError(wmaResult);

  001f2	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  001f5	89 4d e8	 mov	 DWORD PTR _wmaFOOFOO$3046[ebp], ecx
  001f8	83 7d e8 00	 cmp	 DWORD PTR _wmaFOOFOO$3046[ebp], 0
  001fc	7d 40		 jge	 SHORT $L3048
  001fe	8b 55 e8	 mov	 edx, DWORD PTR _wmaFOOFOO$3046[ebp]
  00201	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_E_ONHOLD
  00207	74 2f		 je	 SHORT $L3137
  00209	8b 45 e8	 mov	 eax, DWORD PTR _wmaFOOFOO$3046[ebp]
  0020c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_OK
  00212	74 24		 je	 SHORT $L3137
  00214	8b 4d e8	 mov	 ecx, DWORD PTR _wmaFOOFOO$3046[ebp]
  00217	51		 push	 ecx
  00218	68 f5 01 00 00	 push	 501			; 000001f5H
  0021d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
  00222	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00227	8b 55 e8	 mov	 edx, DWORD PTR _wmaFOOFOO$3046[ebp]
  0022a	52		 push	 edx
  0022b	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00230	83 c4 14	 add	 esp, 20			; 00000014H
  00233	89 45 e0	 mov	 DWORD PTR tv187[ebp], eax
  00236	eb 06		 jmp	 SHORT $L3048
$L3137:
  00238	8b 45 e8	 mov	 eax, DWORD PTR _wmaFOOFOO$3046[ebp]
  0023b	89 45 e0	 mov	 DWORD PTR tv187[ebp], eax
$L3048:

; 502  :         goto exit;

  0023e	eb 58		 jmp	 SHORT $exit$3034
$L3037:

; 503  :     }
; 504  : 	else {
; 505  :         *piResult = 0;

  00240	8b 4d 10	 mov	 ecx, DWORD PTR _piResult$[ebp]
  00243	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 506  :         TRACEWMA_EXIT (wmaResult, WMA_E_ONHOLD);

  00249	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_ONHOLD
  0024f	89 55 f8	 mov	 DWORD PTR _wmaResult$[ebp], edx
  00252	83 7d f8 00	 cmp	 DWORD PTR _wmaResult$[ebp], 0
  00256	7d 40		 jge	 SHORT $exit$3034
  00258	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  0025b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00261	74 2f		 je	 SHORT $L3139
  00263	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00266	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  0026c	74 24		 je	 SHORT $L3139
  0026e	8b 55 f8	 mov	 edx, DWORD PTR _wmaResult$[ebp]
  00271	52		 push	 edx
  00272	68 fa 01 00 00	 push	 506			; 000001faH
  00277	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@BHCBMDJL@c?3?2xbox?2private?2windows?2directx?2@
  0027c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00281	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]
  00284	50		 push	 eax
  00285	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0028a	83 c4 14	 add	 esp, 20			; 00000014H
  0028d	89 45 dc	 mov	 DWORD PTR tv197[ebp], eax
  00290	eb 06		 jmp	 SHORT $exit$3034
$L3139:
  00292	8b 4d f8	 mov	 ecx, DWORD PTR _wmaResult$[ebp]
  00295	89 4d dc	 mov	 DWORD PTR tv197[ebp], ecx
$exit$3034:

; 507  :     }
; 508  : 
; 509  : exit:
; 510  :     return wmaResult;

  00298	8b 45 f8	 mov	 eax, DWORD PTR _wmaResult$[ebp]

; 511  : }

  0029b	8b e5		 mov	 esp, ebp
  0029d	5d		 pop	 ebp
  0029e	c2 0c 00	 ret	 12			; 0000000cH
_ibstrmGetBits@12 ENDP
WMADEC	ENDS
END
