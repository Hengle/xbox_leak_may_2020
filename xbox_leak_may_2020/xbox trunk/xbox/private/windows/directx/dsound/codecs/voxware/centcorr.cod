; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\centcorr.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _calcCenterCorr@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_calcCenterCorr@16
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3eb0c6f7a0000000
EXTRN	_QuadraticPeak@16:NEAR
EXTRN	_DotProd@12:NEAR
EXTRN	_WindowKernel@16:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	_sqrt:NEAR
EXTRN	_memcpy:NEAR
;	COMDAT __real@3dcccccd
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\centcorr.c
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3eb0c6f7a0000000
CONST	SEGMENT
__real@3eb0c6f7a0000000 DQ 03eb0c6f7a0000000r	; 1e-006
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _calcCenterCorr@16
_TEXT	SEGMENT
tv262 = -828
tv252 = -824
_Left_lag$ = -820
_refine_pitch$ = -816
_delta$ = -812
_eng1$ = -808
_biasTab$ = -804
_lpfbuf$ = -800
_win_length$ = -796
_maxCorr$ = -792
_Right_lag$ = -788
_bestI$ = -784
_totalCorr$ = -780
_half_win_length$ = -776
_bestLag$ = -772
_psigBuf$ = -768
_jlag$ = -48
_i$ = -44
_pCorrCosts$ = -40
_eng2$ = -4
_myCorrPDA_mblk$ = 8
_lpfBuf1$ = 12
_pitch$ = 16
_maxCost$ = 20
_calcCenterCorr@16 PROC NEAR				; COMDAT

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 03 00
	00		 sub	 esp, 828		; 0000033cH

; 34   :   float *lpfbuf = myCorrPDA_mblk->lpfbuf;

  00009	8b 45 08	 mov	 eax, DWORD PTR _myCorrPDA_mblk$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	89 8d e0 fc ff
	ff		 mov	 DWORD PTR _lpfbuf$[ebp], ecx

; 35   :   STACK_INIT
; 36   :   float psigBuf[2*LFRAME_LEN];           /* psigBuf[2*LFRAME_LEN] */
; 37   :   float pCorrCosts[9];
; 38   :   STACK_INIT_END
; 39   :   STACK_ATTACH(float*,psigBuf)
; 40   :   STACK_ATTACH(float*,pCorrCosts)
; 41   :   int delta, Left_lag, Right_lag;
; 42   :   int win_length;
; 43   :   int half_win_length;
; 44   :   int jlag, i, bestI;
; 45   :   float eng1, eng2;
; 46   :   float *biasTab = myCorrPDA_mblk->biasTab;

  00015	8b 55 08	 mov	 edx, DWORD PTR _myCorrPDA_mblk$[ebp]
  00018	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0001b	89 85 dc fc ff
	ff		 mov	 DWORD PTR _biasTab$[ebp], eax

; 47   :   float maxCorr, totalCorr;
; 48   :   int bestLag;
; 49   :   float refine_pitch;
; 50   : 
; 51   :   STACK_START
; 52   :   /*------------------------------------------------------------
; 53   :     Find out the pitch searching range.
; 54   :     ------------------------------------------------------------*/
; 55   :   delta = (int)(0.1F*(float)pitch+0.5F);

  00021	db 45 10	 fild	 DWORD PTR _pitch$[ebp]
  00024	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3dcccccd
  0002a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f000000
  00030	e8 00 00 00 00	 call	 __ftol2
  00035	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _delta$[ebp], eax

; 56   :   if (delta > 4)

  0003b	83 bd d4 fc ff
	ff 04		 cmp	 DWORD PTR _delta$[ebp], 4
  00042	7e 0a		 jle	 SHORT $L1481

; 57   :     delta = 4;

  00044	c7 85 d4 fc ff
	ff 04 00 00 00	 mov	 DWORD PTR _delta$[ebp], 4
$L1481:

; 58   :   Left_lag = pitch-delta;

  0004e	8b 4d 10	 mov	 ecx, DWORD PTR _pitch$[ebp]
  00051	2b 8d d4 fc ff
	ff		 sub	 ecx, DWORD PTR _delta$[ebp]
  00057	89 8d cc fc ff
	ff		 mov	 DWORD PTR _Left_lag$[ebp], ecx

; 59   :   if (Left_lag < LPITCH_MIN)

  0005d	83 bd cc fc ff
	ff 05		 cmp	 DWORD PTR _Left_lag$[ebp], 5
  00064	7d 0a		 jge	 SHORT $L1482

; 60   :     Left_lag = LPITCH_MIN;

  00066	c7 85 cc fc ff
	ff 05 00 00 00	 mov	 DWORD PTR _Left_lag$[ebp], 5
$L1482:

; 61   :   
; 62   :   Right_lag = pitch+delta;

  00070	8b 55 10	 mov	 edx, DWORD PTR _pitch$[ebp]
  00073	03 95 d4 fc ff
	ff		 add	 edx, DWORD PTR _delta$[ebp]
  00079	89 95 ec fc ff
	ff		 mov	 DWORD PTR _Right_lag$[ebp], edx

; 63   :   if (Right_lag > LPITCH_MAX)

  0007f	83 bd ec fc ff
	ff 5a		 cmp	 DWORD PTR _Right_lag$[ebp], 90 ; 0000005aH
  00086	7e 0a		 jle	 SHORT $L1483

; 64   :     Right_lag = LPITCH_MAX;

  00088	c7 85 ec fc ff
	ff 5a 00 00 00	 mov	 DWORD PTR _Right_lag$[ebp], 90 ; 0000005aH
$L1483:

; 65   : 
; 66   :   
; 67   :   /*------------------------------------------------------------
; 68   :     Calculate the length of window and copy the data to temporary 
; 69   :     buffer.
; 70   :     ------------------------------------------------------------*/
; 71   :   win_length = 3*Right_lag;

  00092	8b 85 ec fc ff
	ff		 mov	 eax, DWORD PTR _Right_lag$[ebp]
  00098	6b c0 03	 imul	 eax, 3
  0009b	89 85 e4 fc ff
	ff		 mov	 DWORD PTR _win_length$[ebp], eax

; 72   :   if (win_length < 65)     /* smallest window size */

  000a1	83 bd e4 fc ff
	ff 41		 cmp	 DWORD PTR _win_length$[ebp], 65 ; 00000041H
  000a8	7d 0a		 jge	 SHORT $L1484

; 73   :     win_length = 65;

  000aa	c7 85 e4 fc ff
	ff 41 00 00 00	 mov	 DWORD PTR _win_length$[ebp], 65 ; 00000041H
$L1484:

; 74   :   if (win_length > (2*LFRAME_LEN))    /* largest window size */

  000b4	81 bd e4 fc ff
	ff b4 00 00 00	 cmp	 DWORD PTR _win_length$[ebp], 180 ; 000000b4H
  000be	7e 0a		 jle	 SHORT $L1485

; 75   :     win_length = 2*LFRAME_LEN;

  000c0	c7 85 e4 fc ff
	ff b4 00 00 00	 mov	 DWORD PTR _win_length$[ebp], 180 ; 000000b4H
$L1485:

; 76   : 
; 77   :   half_win_length = win_length >> 1;

  000ca	8b 8d e4 fc ff
	ff		 mov	 ecx, DWORD PTR _win_length$[ebp]
  000d0	d1 f9		 sar	 ecx, 1
  000d2	89 8d f8 fc ff
	ff		 mov	 DWORD PTR _half_win_length$[ebp], ecx

; 78   :   if (half_win_length > LFRAME_LEN_2) {

  000d8	83 bd f8 fc ff
	ff 2d		 cmp	 DWORD PTR _half_win_length$[ebp], 45 ; 0000002dH
  000df	7e 63		 jle	 SHORT $L1486

; 79   :     /* copy the signal of previous frame and current frame */
; 80   :     memcpy(psigBuf, &(lpfbuf[LFRAME_LEN-half_win_length]), 
; 81   : 	   (half_win_length+LFRAME_LEN_2)*sizeof(float));

  000e1	8b 95 f8 fc ff
	ff		 mov	 edx, DWORD PTR _half_win_length$[ebp]
  000e7	8d 04 95 b4 00
	00 00		 lea	 eax, DWORD PTR [edx*4+180]
  000ee	50		 push	 eax
  000ef	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  000f4	2b 8d f8 fc ff
	ff		 sub	 ecx, DWORD PTR _half_win_length$[ebp]
  000fa	8b 95 e0 fc ff
	ff		 mov	 edx, DWORD PTR _lpfbuf$[ebp]
  00100	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00103	50		 push	 eax
  00104	8d 8d 00 fd ff
	ff		 lea	 ecx, DWORD PTR _psigBuf$[ebp]
  0010a	51		 push	 ecx
  0010b	e8 00 00 00 00	 call	 _memcpy
  00110	83 c4 0c	 add	 esp, 12			; 0000000cH

; 82   :     /* copy the signal of future frame */
; 83   :     memcpy(&(psigBuf[half_win_length+LFRAME_LEN_2]),lpfBuf1,(win_length-(half_win_length+LFRAME_LEN_2))*sizeof(float));

  00113	8b 95 f8 fc ff
	ff		 mov	 edx, DWORD PTR _half_win_length$[ebp]
  00119	83 c2 2d	 add	 edx, 45			; 0000002dH
  0011c	8b 85 e4 fc ff
	ff		 mov	 eax, DWORD PTR _win_length$[ebp]
  00122	2b c2		 sub	 eax, edx
  00124	c1 e0 02	 shl	 eax, 2
  00127	50		 push	 eax
  00128	8b 4d 0c	 mov	 ecx, DWORD PTR _lpfBuf1$[ebp]
  0012b	51		 push	 ecx
  0012c	8b 95 f8 fc ff
	ff		 mov	 edx, DWORD PTR _half_win_length$[ebp]
  00132	8d 84 95 b4 fd
	ff ff		 lea	 eax, DWORD PTR _psigBuf$[ebp+edx*4+180]
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 _memcpy
  0013f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 84   :   }
; 85   :   else {

  00142	eb 2e		 jmp	 SHORT $L1489
$L1486:

; 86   :     /* only need the signal of current frame */
; 87   :     memcpy(psigBuf, &(lpfbuf[LFRAME_LEN-half_win_length]), 
; 88   : 	   win_length*sizeof(float));

  00144	8b 8d e4 fc ff
	ff		 mov	 ecx, DWORD PTR _win_length$[ebp]
  0014a	c1 e1 02	 shl	 ecx, 2
  0014d	51		 push	 ecx
  0014e	ba 5a 00 00 00	 mov	 edx, 90			; 0000005aH
  00153	2b 95 f8 fc ff
	ff		 sub	 edx, DWORD PTR _half_win_length$[ebp]
  00159	8b 85 e0 fc ff
	ff		 mov	 eax, DWORD PTR _lpfbuf$[ebp]
  0015f	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00162	51		 push	 ecx
  00163	8d 95 00 fd ff
	ff		 lea	 edx, DWORD PTR _psigBuf$[ebp]
  00169	52		 push	 edx
  0016a	e8 00 00 00 00	 call	 _memcpy
  0016f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1489:

; 89   :   }
; 90   : 
; 91   :   /*------------------------------------------------------------
; 92   :     Windowing the signal.
; 93   :     ------------------------------------------------------------*/
; 94   :   WindowKernel(psigBuf, win_length, CENT_WIN_A, CENT_WIN_B);

  00172	68 00 00 80 3e	 push	 1048576000		; 3e800000H
  00177	68 00 00 40 3f	 push	 1061158912		; 3f400000H
  0017c	8b 85 e4 fc ff
	ff		 mov	 eax, DWORD PTR _win_length$[ebp]
  00182	50		 push	 eax
  00183	8d 8d 00 fd ff
	ff		 lea	 ecx, DWORD PTR _psigBuf$[ebp]
  00189	51		 push	 ecx
  0018a	e8 00 00 00 00	 call	 _WindowKernel@16

; 95   : 
; 96   : 
; 97   :   /*--------------------------------------------------
; 98   :     calculate the autocorrelation function.
; 99   :     --------------------------------------------------*/
; 100  :   jlag = Left_lag;

  0018f	8b 95 cc fc ff
	ff		 mov	 edx, DWORD PTR _Left_lag$[ebp]
  00195	89 55 d0	 mov	 DWORD PTR _jlag$[ebp], edx

; 101  :   maxCorr = -MAXFLT;

  00198	c7 85 e8 fc ff
	ff ff ff 7f ff	 mov	 DWORD PTR _maxCorr$[ebp], -8388609 ; ff7fffffH

; 102  :   bestI = 0;

  001a2	c7 85 f0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _bestI$[ebp], 0

; 103  :   i=0;

  001ac	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$L1491:

; 104  :   do {
; 105  :     totalCorr = (float)DotProd(psigBuf, psigBuf+jlag, win_length-jlag);

  001b3	8b 85 e4 fc ff
	ff		 mov	 eax, DWORD PTR _win_length$[ebp]
  001b9	2b 45 d0	 sub	 eax, DWORD PTR _jlag$[ebp]
  001bc	50		 push	 eax
  001bd	8b 4d d0	 mov	 ecx, DWORD PTR _jlag$[ebp]
  001c0	8d 94 8d 00 fd
	ff ff		 lea	 edx, DWORD PTR _psigBuf$[ebp+ecx*4]
  001c7	52		 push	 edx
  001c8	8d 85 00 fd ff
	ff		 lea	 eax, DWORD PTR _psigBuf$[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 _DotProd@12
  001d4	d9 9d f4 fc ff
	ff		 fstp	 DWORD PTR _totalCorr$[ebp]

; 106  : 
; 107  :     pCorrCosts[i] = totalCorr;

  001da	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  001dd	8b 95 f4 fc ff
	ff		 mov	 edx, DWORD PTR _totalCorr$[ebp]
  001e3	89 54 8d d8	 mov	 DWORD PTR _pCorrCosts$[ebp+ecx*4], edx

; 108  :     if (totalCorr > maxCorr) {

  001e7	d9 85 f4 fc ff
	ff		 fld	 DWORD PTR _totalCorr$[ebp]
  001ed	d8 9d e8 fc ff
	ff		 fcomp	 DWORD PTR _maxCorr$[ebp]
  001f3	df e0		 fnstsw	 ax
  001f5	f6 c4 41	 test	 ah, 65			; 00000041H
  001f8	75 15		 jne	 SHORT $L1495

; 109  :       maxCorr = totalCorr;

  001fa	8b 85 f4 fc ff
	ff		 mov	 eax, DWORD PTR _totalCorr$[ebp]
  00200	89 85 e8 fc ff
	ff		 mov	 DWORD PTR _maxCorr$[ebp], eax

; 110  :       bestI = i;

  00206	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  00209	89 8d f0 fc ff
	ff		 mov	 DWORD PTR _bestI$[ebp], ecx
$L1495:

; 111  :     }
; 112  :     i++;

  0020f	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  00212	83 c2 01	 add	 edx, 1
  00215	89 55 d4	 mov	 DWORD PTR _i$[ebp], edx

; 113  :     jlag++;

  00218	8b 45 d0	 mov	 eax, DWORD PTR _jlag$[ebp]
  0021b	83 c0 01	 add	 eax, 1
  0021e	89 45 d0	 mov	 DWORD PTR _jlag$[ebp], eax

; 114  :   } while (jlag <= Right_lag);

  00221	8b 4d d0	 mov	 ecx, DWORD PTR _jlag$[ebp]
  00224	3b 8d ec fc ff
	ff		 cmp	 ecx, DWORD PTR _Right_lag$[ebp]
  0022a	7e 87		 jle	 SHORT $L1491

; 115  :   
; 116  : 
; 117  :   /*-------------------------------------------------------
; 118  :     use quadratic interpolation to get refined pitch.
; 119  :     -------------------------------------------------------*/
; 120  :   bestLag = bestI+Left_lag;

  0022c	8b 95 f0 fc ff
	ff		 mov	 edx, DWORD PTR _bestI$[ebp]
  00232	03 95 cc fc ff
	ff		 add	 edx, DWORD PTR _Left_lag$[ebp]
  00238	89 95 fc fc ff
	ff		 mov	 DWORD PTR _bestLag$[ebp], edx

; 121  : 
; 122  :   if ((bestLag > Left_lag) && (bestLag < Right_lag)) 

  0023e	8b 85 fc fc ff
	ff		 mov	 eax, DWORD PTR _bestLag$[ebp]
  00244	3b 85 cc fc ff
	ff		 cmp	 eax, DWORD PTR _Left_lag$[ebp]
  0024a	7e 4e		 jle	 SHORT $L1496
  0024c	8b 8d fc fc ff
	ff		 mov	 ecx, DWORD PTR _bestLag$[ebp]
  00252	3b 8d ec fc ff
	ff		 cmp	 ecx, DWORD PTR _Right_lag$[ebp]
  00258	7d 40		 jge	 SHORT $L1496

; 123  :     refine_pitch = (float)bestLag + QuadraticPeak(pCorrCosts[bestI-1], 
; 124  :                        maxCorr, pCorrCosts[bestI+1], maxCost);

  0025a	db 85 fc fc ff
	ff		 fild	 DWORD PTR _bestLag$[ebp]
  00260	d9 9d c8 fc ff
	ff		 fstp	 DWORD PTR tv252[ebp]
  00266	8b 55 14	 mov	 edx, DWORD PTR _maxCost$[ebp]
  00269	52		 push	 edx
  0026a	8b 85 f0 fc ff
	ff		 mov	 eax, DWORD PTR _bestI$[ebp]
  00270	8b 4c 85 dc	 mov	 ecx, DWORD PTR _pCorrCosts$[ebp+eax*4+4]
  00274	51		 push	 ecx
  00275	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR _maxCorr$[ebp]
  0027b	52		 push	 edx
  0027c	8b 85 f0 fc ff
	ff		 mov	 eax, DWORD PTR _bestI$[ebp]
  00282	8b 4c 85 d4	 mov	 ecx, DWORD PTR _pCorrCosts$[ebp+eax*4-4]
  00286	51		 push	 ecx
  00287	e8 00 00 00 00	 call	 _QuadraticPeak@16
  0028c	d8 85 c8 fc ff
	ff		 fadd	 DWORD PTR tv252[ebp]
  00292	d9 9d d0 fc ff
	ff		 fstp	 DWORD PTR _refine_pitch$[ebp]

; 125  :   else {

  00298	eb 17		 jmp	 SHORT $L1498
$L1496:

; 126  :     refine_pitch = (float)bestLag;

  0029a	db 85 fc fc ff
	ff		 fild	 DWORD PTR _bestLag$[ebp]
  002a0	d9 9d d0 fc ff
	ff		 fstp	 DWORD PTR _refine_pitch$[ebp]

; 127  :     *maxCost = maxCorr;

  002a6	8b 55 14	 mov	 edx, DWORD PTR _maxCost$[ebp]
  002a9	8b 85 e8 fc ff
	ff		 mov	 eax, DWORD PTR _maxCorr$[ebp]
  002af	89 02		 mov	 DWORD PTR [edx], eax
$L1498:

; 128  :   }
; 129  :   
; 130  :   /*------------------------------------------------------------
; 131  :     now normalized the cost value.
; 132  :     ------------------------------------------------------------*/
; 133  :   /* calculate energy of psigBuf[0:win_length-bestLag-1] and psigBuf[bestLag:win_length-1] */
; 134  :   eng1 = (float)DotProd(psigBuf, psigBuf, win_length-bestLag);

  002b1	8b 8d e4 fc ff
	ff		 mov	 ecx, DWORD PTR _win_length$[ebp]
  002b7	2b 8d fc fc ff
	ff		 sub	 ecx, DWORD PTR _bestLag$[ebp]
  002bd	51		 push	 ecx
  002be	8d 95 00 fd ff
	ff		 lea	 edx, DWORD PTR _psigBuf$[ebp]
  002c4	52		 push	 edx
  002c5	8d 85 00 fd ff
	ff		 lea	 eax, DWORD PTR _psigBuf$[ebp]
  002cb	50		 push	 eax
  002cc	e8 00 00 00 00	 call	 _DotProd@12
  002d1	d9 9d d8 fc ff
	ff		 fstp	 DWORD PTR _eng1$[ebp]

; 135  :   eng2 = (float)DotProd(psigBuf+bestLag, psigBuf+bestLag, win_length-bestLag);

  002d7	8b 8d e4 fc ff
	ff		 mov	 ecx, DWORD PTR _win_length$[ebp]
  002dd	2b 8d fc fc ff
	ff		 sub	 ecx, DWORD PTR _bestLag$[ebp]
  002e3	51		 push	 ecx
  002e4	8b 95 fc fc ff
	ff		 mov	 edx, DWORD PTR _bestLag$[ebp]
  002ea	8d 84 95 00 fd
	ff ff		 lea	 eax, DWORD PTR _psigBuf$[ebp+edx*4]
  002f1	50		 push	 eax
  002f2	8b 8d fc fc ff
	ff		 mov	 ecx, DWORD PTR _bestLag$[ebp]
  002f8	8d 94 8d 00 fd
	ff ff		 lea	 edx, DWORD PTR _psigBuf$[ebp+ecx*4]
  002ff	52		 push	 edx
  00300	e8 00 00 00 00	 call	 _DotProd@12
  00305	d9 5d fc	 fstp	 DWORD PTR _eng2$[ebp]

; 136  : 
; 137  :   *maxCost *= (biasTab[bestLag-LPITCH_MIN]/((float)sqrt((double)eng1*eng2+MINCON)));

  00308	d9 85 d8 fc ff
	ff		 fld	 DWORD PTR _eng1$[ebp]
  0030e	d8 4d fc	 fmul	 DWORD PTR _eng2$[ebp]
  00311	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3eb0c6f7a0000000
  00317	83 ec 08	 sub	 esp, 8
  0031a	dd 1c 24	 fstp	 QWORD PTR [esp]
  0031d	e8 00 00 00 00	 call	 _sqrt
  00322	83 c4 08	 add	 esp, 8
  00325	d9 95 c4 fc ff
	ff		 fst	 DWORD PTR tv262[ebp]
  0032b	8b 85 fc fc ff
	ff		 mov	 eax, DWORD PTR _bestLag$[ebp]
  00331	8b 8d dc fc ff
	ff		 mov	 ecx, DWORD PTR _biasTab$[ebp]
  00337	d8 7c 81 ec	 fdivr	 DWORD PTR [ecx+eax*4-20]
  0033b	8b 55 14	 mov	 edx, DWORD PTR _maxCost$[ebp]
  0033e	d8 0a		 fmul	 DWORD PTR [edx]
  00340	8b 45 14	 mov	 eax, DWORD PTR _maxCost$[ebp]
  00343	d9 18		 fstp	 DWORD PTR [eax]

; 138  : 
; 139  : 
; 140  :   STACK_END
; 141  :   return refine_pitch;

  00345	d9 85 d0 fc ff
	ff		 fld	 DWORD PTR _refine_pitch$[ebp]

; 142  : }

  0034b	8b e5		 mov	 esp, ebp
  0034d	5d		 pop	 ebp
  0034e	c2 10 00	 ret	 16			; 00000010H
_calcCenterCorr@16 ENDP
_TEXT	ENDS
END
