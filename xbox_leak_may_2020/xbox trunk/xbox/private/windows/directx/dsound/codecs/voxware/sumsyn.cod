; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\sumsyn.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _SumSyn@48
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _InitSumSyn@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _FreeSumSyn@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _HarmonicSum@28
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_SumSyn@48
PUBLIC	_HarmonicSum@28
PUBLIC	__real@401921fb54524550
PUBLIC	__real@3f000000
EXTRN	_OlAdd@20:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	_fmod:NEAR
EXTRN	_memcpy:NEAR
;	COMDAT __real@401921fb54524550
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\sumsyn.c
CONST	SEGMENT
__real@401921fb54524550 DQ 0401921fb54524550r	; 6.28319
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _SumSyn@48
_TEXT	SEGMENT
tv255 = -1028
tv253 = -1024
tv240 = -1020
tv237 = -1016
tv230 = -1012
tv219 = -1008
tv201 = -1004
_pSumSynBlk$ = -1000
_Mw$ = -996
_pfPrevSyn$ = -992
_olLEN$ = -508
_synLEN$ = -504
_i$ = -500
_fSynBuf$ = -496
_BaseStep$ = -12
_w$ = -8
_w_1$ = -4
_pvSumSynBlk$ = 8
_Amp$ = 12
_Pitch$ = 16
_Pitch_1$ = 20
_Phase$ = 24
_multPitch$ = 28
_pitch_mult$ = 32
_nHarm$ = 36
_vHarm$ = 40
_frameLen$ = 44
_interpFactor$ = 48
_outSpeech$ = 52
_SumSyn@48 PROC NEAR					; COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H

; 102  : 
; 103  :    SumSynBlk *pSumSynBlk=(SumSynBlk *)pvSumSynBlk;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pvSumSynBlk$[ebp]
  0000c	89 85 18 fc ff
	ff		 mov	 DWORD PTR _pSumSynBlk$[ebp], eax

; 104  :    STACK_INIT
; 105  :    float  fSynBuf[MAXSYNLEN];  /* scratch */
; 106  :    float  pfPrevSyn[MAXSYNLEN];  /* scratch */
; 107  :    STACK_INIT_END
; 108  :    STACK_ATTACH(float*,fSynBuf)
; 109  :    STACK_ATTACH(float*,pfPrevSyn)
; 110  :    short olLEN;
; 111  :    short synLEN;
; 112  :    float w, w_1;
; 113  :    float Mw;
; 114  :    float BaseStep;
; 115  :    int i;
; 116  :    STACK_START
; 117  : 
; 118  :    olLEN = (short)(interpFactor * frameLen);

  00012	0f bf 4d 2c	 movsx	 ecx, WORD PTR _frameLen$[ebp]
  00016	89 8d 14 fc ff
	ff		 mov	 DWORD PTR tv201[ebp], ecx
  0001c	db 85 14 fc ff
	ff		 fild	 DWORD PTR tv201[ebp]
  00022	d8 4d 30	 fmul	 DWORD PTR _interpFactor$[ebp]
  00025	e8 00 00 00 00	 call	 __ftol2
  0002a	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _olLEN$[ebp], ax

; 119  :    synLEN   = olLEN + ((frameLen-olLEN)>>1);

  00031	0f bf 95 04 fe
	ff ff		 movsx	 edx, WORD PTR _olLEN$[ebp]
  00038	0f bf 45 2c	 movsx	 eax, WORD PTR _frameLen$[ebp]
  0003c	0f bf 8d 04 fe
	ff ff		 movsx	 ecx, WORD PTR _olLEN$[ebp]
  00043	2b c1		 sub	 eax, ecx
  00045	d1 f8		 sar	 eax, 1
  00047	03 d0		 add	 edx, eax
  00049	66 89 95 08 fe
	ff ff		 mov	 WORD PTR _synLEN$[ebp], dx

; 120  :    w = (float)(D_PI/Pitch);

  00050	d9 45 10	 fld	 DWORD PTR _Pitch$[ebp]
  00053	dc 3d 00 00 00
	00		 fdivr	 QWORD PTR __real@401921fb54524550
  00059	d9 5d f8	 fstp	 DWORD PTR _w$[ebp]

; 121  :    w_1 = (float)(D_PI/Pitch_1);

  0005c	d9 45 14	 fld	 DWORD PTR _Pitch_1$[ebp]
  0005f	dc 3d 00 00 00
	00		 fdivr	 QWORD PTR __real@401921fb54524550
  00065	d9 5d fc	 fstp	 DWORD PTR _w_1$[ebp]

; 122  :    Mw = (float)(D_PI/multPitch);

  00068	d9 45 1c	 fld	 DWORD PTR _multPitch$[ebp]
  0006b	dc 3d 00 00 00
	00		 fdivr	 QWORD PTR __real@401921fb54524550
  00071	d9 9d 1c fc ff
	ff		 fstp	 DWORD PTR _Mw$[ebp]

; 123  : 
; 124  :    /*------------------------------------------------------------------------------------
; 125  :       Synthesize the previous section of speech ...
; 126  :      ------------------------------------------------------------------------------------*/
; 127  :    HarmonicSum (pSumSynBlk->Amp_1, pSumSynBlk->prevPhase, pSumSynBlk->Mw_1, 0, 
; 128  :       pSumSynBlk->nHarm_1, pfPrevSyn, synLEN );

  00077	66 8b 95 08 fe
	ff ff		 mov	 dx, WORD PTR _synLEN$[ebp]
  0007e	52		 push	 edx
  0007f	8d 85 20 fc ff
	ff		 lea	 eax, DWORD PTR _pfPrevSyn$[ebp]
  00085	50		 push	 eax
  00086	8b 8d 18 fc ff
	ff		 mov	 ecx, DWORD PTR _pSumSynBlk$[ebp]
  0008c	66 8b 91 d8 02
	00 00		 mov	 dx, WORD PTR [ecx+728]
  00093	52		 push	 edx
  00094	6a 00		 push	 0
  00096	8b 85 18 fc ff
	ff		 mov	 eax, DWORD PTR _pSumSynBlk$[ebp]
  0009c	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  000a2	51		 push	 ecx
  000a3	8b 95 18 fc ff
	ff		 mov	 edx, DWORD PTR _pSumSynBlk$[ebp]
  000a9	83 c2 04	 add	 edx, 4
  000ac	52		 push	 edx
  000ad	8b 85 18 fc ff
	ff		 mov	 eax, DWORD PTR _pSumSynBlk$[ebp]
  000b3	05 70 01 00 00	 add	 eax, 368		; 00000170H
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _HarmonicSum@28

; 129  :      
; 130  :    /*------------------------------------------------------------
; 131  :       Set up the phases 
; 132  :      ------------------------------------------------------------*/
; 133  :    pSumSynBlk->BasePhase += (w+w_1)*0.5F*frameLen;

  000be	d9 45 f8	 fld	 DWORD PTR _w$[ebp]
  000c1	d8 45 fc	 fadd	 DWORD PTR _w_1$[ebp]
  000c4	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  000ca	0f bf 4d 2c	 movsx	 ecx, WORD PTR _frameLen$[ebp]
  000ce	89 8d 10 fc ff
	ff		 mov	 DWORD PTR tv219[ebp], ecx
  000d4	da 8d 10 fc ff
	ff		 fimul	 DWORD PTR tv219[ebp]
  000da	8b 95 18 fc ff
	ff		 mov	 edx, DWORD PTR _pSumSynBlk$[ebp]
  000e0	d8 02		 fadd	 DWORD PTR [edx]
  000e2	8b 85 18 fc ff
	ff		 mov	 eax, DWORD PTR _pSumSynBlk$[ebp]
  000e8	d9 18		 fstp	 DWORD PTR [eax]

; 134  :    pSumSynBlk->BasePhase  = (float)fmod(pSumSynBlk->BasePhase, D_PI);

  000ea	68 fb 21 19 40	 push	 1075388923		; 401921fbH
  000ef	68 50 45 52 54	 push	 1414677840		; 54524550H
  000f4	8b 8d 18 fc ff
	ff		 mov	 ecx, DWORD PTR _pSumSynBlk$[ebp]
  000fa	d9 01		 fld	 DWORD PTR [ecx]
  000fc	83 ec 08	 sub	 esp, 8
  000ff	dd 1c 24	 fstp	 QWORD PTR [esp]
  00102	e8 00 00 00 00	 call	 _fmod
  00107	83 c4 10	 add	 esp, 16			; 00000010H
  0010a	8b 95 18 fc ff
	ff		 mov	 edx, DWORD PTR _pSumSynBlk$[ebp]
  00110	d9 1a		 fstp	 DWORD PTR [edx]

; 135  : 
; 136  :    BaseStep = (float)(fmod((pSumSynBlk->BasePhase-synLEN*w), D_PI));

  00112	68 fb 21 19 40	 push	 1075388923		; 401921fbH
  00117	68 50 45 52 54	 push	 1414677840		; 54524550H
  0011c	0f bf 85 08 fe
	ff ff		 movsx	 eax, WORD PTR _synLEN$[ebp]
  00123	89 85 0c fc ff
	ff		 mov	 DWORD PTR tv230[ebp], eax
  00129	db 85 0c fc ff
	ff		 fild	 DWORD PTR tv230[ebp]
  0012f	d8 4d f8	 fmul	 DWORD PTR _w$[ebp]
  00132	8b 8d 18 fc ff
	ff		 mov	 ecx, DWORD PTR _pSumSynBlk$[ebp]
  00138	d8 29		 fsubr	 DWORD PTR [ecx]
  0013a	83 ec 08	 sub	 esp, 8
  0013d	dd 1c 24	 fstp	 QWORD PTR [esp]
  00140	e8 00 00 00 00	 call	 _fmod
  00145	83 c4 10	 add	 esp, 16			; 00000010H
  00148	d9 5d f4	 fstp	 DWORD PTR _BaseStep$[ebp]

; 137  :    BaseStep /=(float)pitch_mult;

  0014b	0f bf 55 20	 movsx	 edx, WORD PTR _pitch_mult$[ebp]
  0014f	89 95 08 fc ff
	ff		 mov	 DWORD PTR tv237[ebp], edx
  00155	db 85 08 fc ff
	ff		 fild	 DWORD PTR tv237[ebp]
  0015b	d8 7d f4	 fdivr	 DWORD PTR _BaseStep$[ebp]
  0015e	d9 5d f4	 fstp	 DWORD PTR _BaseStep$[ebp]

; 138  : 
; 139  :    for (i=0;i<vHarm;i++)

  00161	c7 85 0c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0016b	eb 0f		 jmp	 SHORT $L1376
$L1377:
  0016d	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00173	83 c0 01	 add	 eax, 1
  00176	89 85 0c fe ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L1376:
  0017c	0f bf 4d 28	 movsx	 ecx, WORD PTR _vHarm$[ebp]
  00180	39 8d 0c fe ff
	ff		 cmp	 DWORD PTR _i$[ebp], ecx
  00186	7d 26		 jge	 SHORT $L1378

; 140  :    {
; 141  :       Phase[i] = BaseStep*(i+1);

  00188	8b 95 0c fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0018e	83 c2 01	 add	 edx, 1
  00191	89 95 04 fc ff
	ff		 mov	 DWORD PTR tv240[ebp], edx
  00197	db 85 04 fc ff
	ff		 fild	 DWORD PTR tv240[ebp]
  0019d	d8 4d f4	 fmul	 DWORD PTR _BaseStep$[ebp]
  001a0	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  001a6	8b 4d 18	 mov	 ecx, DWORD PTR _Phase$[ebp]
  001a9	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]

; 142  :    }

  001ac	eb bf		 jmp	 SHORT $L1377
$L1378:

; 143  : 
; 144  :    HarmonicSum (Amp, Phase, Mw, 0, nHarm, fSynBuf, synLEN );

  001ae	66 8b 95 08 fe
	ff ff		 mov	 dx, WORD PTR _synLEN$[ebp]
  001b5	52		 push	 edx
  001b6	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _fSynBuf$[ebp]
  001bc	50		 push	 eax
  001bd	66 8b 4d 24	 mov	 cx, WORD PTR _nHarm$[ebp]
  001c1	51		 push	 ecx
  001c2	6a 00		 push	 0
  001c4	8b 95 1c fc ff
	ff		 mov	 edx, DWORD PTR _Mw$[ebp]
  001ca	52		 push	 edx
  001cb	8b 45 18	 mov	 eax, DWORD PTR _Phase$[ebp]
  001ce	50		 push	 eax
  001cf	8b 4d 0c	 mov	 ecx, DWORD PTR _Amp$[ebp]
  001d2	51		 push	 ecx
  001d3	e8 00 00 00 00	 call	 _HarmonicSum@28

; 145  : 
; 146  :    for (i=0; i<nHarm; i++)

  001d8	c7 85 0c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  001e2	eb 0f		 jmp	 SHORT $L1379
$L1380:
  001e4	8b 95 0c fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  001ea	83 c2 01	 add	 edx, 1
  001ed	89 95 0c fe ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$L1379:
  001f3	0f bf 45 24	 movsx	 eax, WORD PTR _nHarm$[ebp]
  001f7	39 85 0c fe ff
	ff		 cmp	 DWORD PTR _i$[ebp], eax
  001fd	7d 4c		 jge	 SHORT $L1381

; 147  :       pSumSynBlk->prevPhase[i] = Phase[i] + Mw*synLEN*(i+1);

  001ff	0f bf 8d 08 fe
	ff ff		 movsx	 ecx, WORD PTR _synLEN$[ebp]
  00206	89 8d 00 fc ff
	ff		 mov	 DWORD PTR tv253[ebp], ecx
  0020c	db 85 00 fc ff
	ff		 fild	 DWORD PTR tv253[ebp]
  00212	d8 8d 1c fc ff
	ff		 fmul	 DWORD PTR _Mw$[ebp]
  00218	8b 95 0c fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0021e	83 c2 01	 add	 edx, 1
  00221	89 95 fc fb ff
	ff		 mov	 DWORD PTR tv255[ebp], edx
  00227	da 8d fc fb ff
	ff		 fimul	 DWORD PTR tv255[ebp]
  0022d	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00233	8b 4d 18	 mov	 ecx, DWORD PTR _Phase$[ebp]
  00236	d8 04 81	 fadd	 DWORD PTR [ecx+eax*4]
  00239	8b 95 0c fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0023f	8b 85 18 fc ff
	ff		 mov	 eax, DWORD PTR _pSumSynBlk$[ebp]
  00245	d9 5c 90 04	 fstp	 DWORD PTR [eax+edx*4+4]
  00249	eb 99		 jmp	 SHORT $L1380
$L1381:

; 148  : 
; 149  :  /*----------------------------------------------------
; 150  :      Do overlap-add of buffers ...
; 151  :    ----------------------------------------------------*/
; 152  :    OlAdd(pfPrevSyn, fSynBuf, (const int)olLEN, (const int)frameLen, outSpeech);

  0024b	8b 4d 34	 mov	 ecx, DWORD PTR _outSpeech$[ebp]
  0024e	51		 push	 ecx
  0024f	0f bf 55 2c	 movsx	 edx, WORD PTR _frameLen$[ebp]
  00253	52		 push	 edx
  00254	0f bf 85 04 fe
	ff ff		 movsx	 eax, WORD PTR _olLEN$[ebp]
  0025b	50		 push	 eax
  0025c	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR _fSynBuf$[ebp]
  00262	51		 push	 ecx
  00263	8d 95 20 fc ff
	ff		 lea	 edx, DWORD PTR _pfPrevSyn$[ebp]
  00269	52		 push	 edx
  0026a	e8 00 00 00 00	 call	 _OlAdd@20

; 153  : 
; 154  :    memcpy(pSumSynBlk->Amp_1, Amp, sizeof(float)*MAXHARM);

  0026f	68 68 01 00 00	 push	 360			; 00000168H
  00274	8b 45 0c	 mov	 eax, DWORD PTR _Amp$[ebp]
  00277	50		 push	 eax
  00278	8b 8d 18 fc ff
	ff		 mov	 ecx, DWORD PTR _pSumSynBlk$[ebp]
  0027e	81 c1 70 01 00
	00		 add	 ecx, 368		; 00000170H
  00284	51		 push	 ecx
  00285	e8 00 00 00 00	 call	 _memcpy
  0028a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 155  :    pSumSynBlk->nHarm_1 = nHarm;

  0028d	8b 95 18 fc ff
	ff		 mov	 edx, DWORD PTR _pSumSynBlk$[ebp]
  00293	66 8b 45 24	 mov	 ax, WORD PTR _nHarm$[ebp]
  00297	66 89 82 d8 02
	00 00		 mov	 WORD PTR [edx+728], ax

; 156  :    pSumSynBlk->Mw_1 = Mw;

  0029e	8b 8d 18 fc ff
	ff		 mov	 ecx, DWORD PTR _pSumSynBlk$[ebp]
  002a4	8b 95 1c fc ff
	ff		 mov	 edx, DWORD PTR _Mw$[ebp]
  002aa	89 91 6c 01 00
	00		 mov	 DWORD PTR [ecx+364], edx

; 157  :    STACK_END
; 158  : }

  002b0	8b e5		 mov	 esp, ebp
  002b2	5d		 pop	 ebp
  002b3	c2 30 00	 ret	 48			; 00000030H
_SumSyn@48 ENDP
_TEXT	ENDS
PUBLIC	_InitSumSyn@4
EXTRN	_calloc:NEAR
EXTRN	_memset:NEAR
; Function compile flags: /Odt
;	COMDAT _InitSumSyn@4
_TEXT	SEGMENT
_pSumSynBlk$ = -4
_hSumSynBlk$ = 8
_InitSumSyn@4 PROC NEAR					; COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 162  :    SumSynBlk *pSumSynBlk;
; 163  : 
; 164  :    if(VOX_MEM_INIT(pSumSynBlk=*hSumSynBlk,1,sizeof(SumSynBlk)))

  00004	68 dc 02 00 00	 push	 732			; 000002dcH
  00009	6a 01		 push	 1
  0000b	e8 00 00 00 00	 call	 _calloc
  00010	83 c4 08	 add	 esp, 8
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _hSumSynBlk$[ebp]
  00016	89 01		 mov	 DWORD PTR [ecx], eax
  00018	8b 55 08	 mov	 edx, DWORD PTR _hSumSynBlk$[ebp]
  0001b	8b 02		 mov	 eax, DWORD PTR [edx]
  0001d	89 45 fc	 mov	 DWORD PTR _pSumSynBlk$[ebp], eax
  00020	83 7d fc 00	 cmp	 DWORD PTR _pSumSynBlk$[ebp], 0
  00024	75 06		 jne	 SHORT $L1390

; 165  :       return 1;

  00026	66 b8 01 00	 mov	 ax, 1
  0002a	eb 4e		 jmp	 SHORT $L1387
$L1390:

; 166  :    memset(pSumSynBlk->prevPhase,0,MAXHARM);

  0002c	6a 5a		 push	 90			; 0000005aH
  0002e	6a 00		 push	 0
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _pSumSynBlk$[ebp]
  00033	83 c1 04	 add	 ecx, 4
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _memset
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  :    memset(pSumSynBlk->Amp_1,0,MAXHARM);

  0003f	6a 5a		 push	 90			; 0000005aH
  00041	6a 00		 push	 0
  00043	8b 55 fc	 mov	 edx, DWORD PTR _pSumSynBlk$[ebp]
  00046	81 c2 70 01 00
	00		 add	 edx, 368		; 00000170H
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 _memset
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 168  :    pSumSynBlk->BasePhase=0.0F;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _pSumSynBlk$[ebp]
  00058	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 169  :    pSumSynBlk->Mw_1=0.0F;

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _pSumSynBlk$[ebp]
  00061	c7 81 6c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+364], 0

; 170  :    pSumSynBlk->nHarm_1=0;

  0006b	8b 55 fc	 mov	 edx, DWORD PTR _pSumSynBlk$[ebp]
  0006e	66 c7 82 d8 02
	00 00 00 00	 mov	 WORD PTR [edx+728], 0

; 171  : 
; 172  :    return 0;

  00077	66 33 c0	 xor	 ax, ax
$L1387:

; 173  : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 04 00	 ret	 4
_InitSumSyn@4 ENDP
_TEXT	ENDS
PUBLIC	_FreeSumSyn@4
EXTRN	_free:NEAR
; Function compile flags: /Odt
;	COMDAT _FreeSumSyn@4
_TEXT	SEGMENT
_hSumSynBlk$ = 8
_FreeSumSyn@4 PROC NEAR					; COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 177  :    VOX_MEM_FREE(*hSumSynBlk);

  00003	8b 45 08	 mov	 eax, DWORD PTR _hSumSynBlk$[ebp]
  00006	83 38 00	 cmp	 DWORD PTR [eax], 0
  00009	74 17		 je	 SHORT $L1394
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _hSumSynBlk$[ebp]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _free
  00016	83 c4 04	 add	 esp, 4
  00019	8b 45 08	 mov	 eax, DWORD PTR _hSumSynBlk$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L1394:

; 178  : 
; 179  :    return 0;

  00022	66 33 c0	 xor	 ax, ax

; 180  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
_FreeSumSyn@4 ENDP
_TEXT	ENDS
EXTRN	_sin:NEAR
; Function compile flags: /Odt
;	COMDAT _HarmonicSum@28
_TEXT	SEGMENT
tv142 = -36
tv141 = -32
tv130 = -24
_m$ = -20
_theta_t$ = -16
_dP$ = -12
_i$ = -8
_Am$ = -4
_A$ = 8
_phi_o$ = 12
_w$ = 16
_startHarm$ = 20
_endHarm$ = 24
_OutBuf$ = 28
_L$ = 32
_HarmonicSum@28 PROC NEAR				; COMDAT

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 191  :    register int i;                          /* loop var                       */
; 192  :    register int m;                          /* loop var                       */
; 193  :    float        theta_t;                    /* theta(t)                       */
; 194  :    float        dP;                         /* theta increment                */
; 195  :    float        Am;                         /* mth amplitude                  */
; 196  : 
; 197  :    memset(OutBuf, 0, sizeof(float)*L);      /* set output buffer to 0         */

  00006	0f bf 45 20	 movsx	 eax, WORD PTR _L$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	6a 00		 push	 0
  00010	8b 4d 1c	 mov	 ecx, DWORD PTR _OutBuf$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 _memset
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 198  :    dP     = startHarm*w;                    /* init. delta phase              */

  0001c	0f bf 55 14	 movsx	 edx, WORD PTR _startHarm$[ebp]
  00020	89 55 e8	 mov	 DWORD PTR tv130[ebp], edx
  00023	db 45 e8	 fild	 DWORD PTR tv130[ebp]
  00026	d8 4d 10	 fmul	 DWORD PTR _w$[ebp]
  00029	d9 5d f4	 fstp	 DWORD PTR _dP$[ebp]

; 199  :    
; 200  :    for (m=startHarm; m<endHarm; m++)        /* loop over selected harmonics   */

  0002c	0f bf 45 14	 movsx	 eax, WORD PTR _startHarm$[ebp]
  00030	89 45 ec	 mov	 DWORD PTR _m$[ebp], eax
  00033	eb 09		 jmp	 SHORT $L1417
$L1418:
  00035	8b 4d ec	 mov	 ecx, DWORD PTR _m$[ebp]
  00038	83 c1 01	 add	 ecx, 1
  0003b	89 4d ec	 mov	 DWORD PTR _m$[ebp], ecx
$L1417:
  0003e	0f bf 55 18	 movsx	 edx, WORD PTR _endHarm$[ebp]
  00042	39 55 ec	 cmp	 DWORD PTR _m$[ebp], edx
  00045	7d 7b		 jge	 SHORT $L1410

; 201  :    {
; 202  :       theta_t = phi_o[m];                   /* init. theta                    */

  00047	8b 45 ec	 mov	 eax, DWORD PTR _m$[ebp]
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _phi_o$[ebp]
  0004d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00050	89 55 f0	 mov	 DWORD PTR _theta_t$[ebp], edx

; 203  :       dP     += w;                          /* inc. delta theta               */

  00053	d9 45 f4	 fld	 DWORD PTR _dP$[ebp]
  00056	d8 45 10	 fadd	 DWORD PTR _w$[ebp]
  00059	d9 5d f4	 fstp	 DWORD PTR _dP$[ebp]

; 204  :       Am      = A[m];                       /* init. A(m)                     */

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _m$[ebp]
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00062	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00065	89 55 fc	 mov	 DWORD PTR _Am$[ebp], edx

; 205  : 
; 206  :       for (i=0; i<L; i++)                   /* loop over all samples          */

  00068	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0006f	eb 09		 jmp	 SHORT $L1420
$L1421:
  00071	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00074	83 c0 01	 add	 eax, 1
  00077	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L1420:
  0007a	0f bf 4d 20	 movsx	 ecx, WORD PTR _L$[ebp]
  0007e	39 4d f8	 cmp	 DWORD PTR _i$[ebp], ecx
  00081	7d 3a		 jge	 SHORT $L1422

; 207  :       {
; 208  :          OutBuf[i]  += (float)(Am*sin(theta_t));   /* harmonic sum            */

  00083	d9 45 fc	 fld	 DWORD PTR _Am$[ebp]
  00086	dd 5d e0	 fstp	 QWORD PTR tv141[ebp]
  00089	d9 45 f0	 fld	 DWORD PTR _theta_t$[ebp]
  0008c	83 ec 08	 sub	 esp, 8
  0008f	dd 1c 24	 fstp	 QWORD PTR [esp]
  00092	e8 00 00 00 00	 call	 _sin
  00097	83 c4 08	 add	 esp, 8
  0009a	dc 4d e0	 fmul	 QWORD PTR tv141[ebp]
  0009d	d9 55 dc	 fst	 DWORD PTR tv142[ebp]
  000a0	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000a3	8b 45 1c	 mov	 eax, DWORD PTR _OutBuf$[ebp]
  000a6	d8 04 90	 fadd	 DWORD PTR [eax+edx*4]
  000a9	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000ac	8b 55 1c	 mov	 edx, DWORD PTR _OutBuf$[ebp]
  000af	d9 1c 8a	 fstp	 DWORD PTR [edx+ecx*4]

; 209  :          theta_t    += dP;                         /* increment theta_t       */

  000b2	d9 45 f0	 fld	 DWORD PTR _theta_t$[ebp]
  000b5	d8 45 f4	 fadd	 DWORD PTR _dP$[ebp]
  000b8	d9 5d f0	 fstp	 DWORD PTR _theta_t$[ebp]

; 210  :       }                                            /* end for(i)              */

  000bb	eb b4		 jmp	 SHORT $L1421
$L1422:

; 211  :    }                                               /* end for(m)              */

  000bd	e9 73 ff ff ff	 jmp	 $L1418
$L1410:

; 212  : } 

  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 1c 00	 ret	 28			; 0000001cH
_HarmonicSum@28 ENDP
_TEXT	ENDS
END
