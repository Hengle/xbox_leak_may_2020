; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\lsp2ase.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EA@GLHNAOE@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@LJCJBAAK@?$CB?$CIiOrder?$CG1?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05FGOOPLEI@pfLSP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04KLAIINDA@pfAs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxLspToAsEven@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_VoxLspToAsEven@16
PUBLIC	??_C@_0EA@GLHNAOE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0M@LJCJBAAK@?$CB?$CIiOrder?$CG1?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@ ; `string'
PUBLIC	??_C@_05FGOOPLEI@pfLSP?$AA@			; `string'
PUBLIC	??_C@_04KLAIINDA@pfAs?$AA@			; `string'
PUBLIC	__real@40c90fdb
PUBLIC	__real@c0000000
PUBLIC	__real@40000000
PUBLIC	__real@3f000000
EXTRN	_cos:NEAR
EXTRN	__assert:NEAR
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_0EA@GLHNAOE@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\lsp2ase.c
CONST	SEGMENT
??_C@_0EA@GLHNAOE@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pri'
	DB	'vate\windows\directx\dsound\codecs\voxware\lsp2ase.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LJCJBAAK@?$CB?$CIiOrder?$CG1?$CJ?$AA@
CONST	SEGMENT
??_C@_0M@LJCJBAAK@?$CB?$CIiOrder?$CG1?$CJ?$AA@ DB '!(iOrder&1)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@
CONST	SEGMENT
??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@ DB 'iOrder <= MAX_'
	DB	'LPC_ORDER', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05FGOOPLEI@pfLSP?$AA@
CONST	SEGMENT
??_C@_05FGOOPLEI@pfLSP?$AA@ DB 'pfLSP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KLAIINDA@pfAs?$AA@
CONST	SEGMENT
??_C@_04KLAIINDA@pfAs?$AA@ DB 'pfAs', 00H		; `string'
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxLspToAsEven@16
_TEXT	SEGMENT
tv310 = -152
tv151 = -148
tv297 = -140
tv143 = -136
tv282 = -128
tv133 = -124
tv269 = -116
tv92 = -112
_j$ = -104
_fDp$ = -100
_fRp$ = -96
_fScale$ = -56
_iOrder2$ = -52
_fRq$ = -48
_fDq$ = -8
_i$ = -4
_pfLSP$ = 8
_iOrder$ = 12
_fScaleFactor$ = 16
_pfAs$ = 20
_VoxLspToAsEven@16 PROC NEAR				; COMDAT

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H

; 97   :    int   i, j;
; 98   :    int   iOrder2 = iOrder>>1;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _iOrder$[ebp]
  0000c	d1 f8		 sar	 eax, 1
  0000e	89 45 cc	 mov	 DWORD PTR _iOrder2$[ebp], eax

; 99   : 
; 100  :    float fScale;
; 101  :    float fRp[(MAX_LPC_ORDER>>1)+1];
; 102  :    float fRq[(MAX_LPC_ORDER>>1)+1];
; 103  :    float fDp;
; 104  :    float fDq;
; 105  : 
; 106  :    
; 107  :    /*------------------------------------------------------
; 108  :      Make sure the model order is even and that it is less 
; 109  :        than or equal to MAX_LPC_ORDER.  
; 110  :    ------------------------------------------------------*/ 
; 111  :    assert( !(iOrder&1) );

  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _iOrder$[ebp]
  00014	83 e1 01	 and	 ecx, 1
  00017	85 c9		 test	 ecx, ecx
  00019	74 14		 je	 SHORT $L764
  0001b	6a 6f		 push	 111			; 0000006fH
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@GLHNAOE@c?3?2xbox?2private?2windows?2directx?2@
  00022	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@LJCJBAAK@?$CB?$CIiOrder?$CG1?$CJ?$AA@
  00027	e8 00 00 00 00	 call	 __assert
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L764:

; 112  :    assert( iOrder <= MAX_LPC_ORDER );

  0002f	83 7d 0c 12	 cmp	 DWORD PTR _iOrder$[ebp], 18 ; 00000012H
  00033	7e 14		 jle	 SHORT $L765
  00035	6a 70		 push	 112			; 00000070H
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@GLHNAOE@c?3?2xbox?2private?2windows?2directx?2@
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@MPKJKHI@iOrder?5?$DM?$DN?5MAX_LPC_ORDER?$AA@
  00041	e8 00 00 00 00	 call	 __assert
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
$L765:

; 113  :    assert( pfLSP );

  00049	83 7d 08 00	 cmp	 DWORD PTR _pfLSP$[ebp], 0
  0004d	75 14		 jne	 SHORT $L766
  0004f	6a 71		 push	 113			; 00000071H
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@GLHNAOE@c?3?2xbox?2private?2windows?2directx?2@
  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05FGOOPLEI@pfLSP?$AA@
  0005b	e8 00 00 00 00	 call	 __assert
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
$L766:

; 114  :    assert( pfAs );

  00063	83 7d 14 00	 cmp	 DWORD PTR _pfAs$[ebp], 0
  00067	75 14		 jne	 SHORT $L767
  00069	6a 72		 push	 114			; 00000072H
  0006b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EA@GLHNAOE@c?3?2xbox?2private?2windows?2directx?2@
  00070	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04KLAIINDA@pfAs?$AA@
  00075	e8 00 00 00 00	 call	 __assert
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L767:

; 115  : 
; 116  :    fScale = fScaleFactor*DB_PI;

  0007d	d9 45 10	 fld	 DWORD PTR _fScaleFactor$[ebp]
  00080	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40c90fdb
  00086	d9 5d c8	 fstp	 DWORD PTR _fScale$[ebp]

; 117  : 
; 118  :    /*------------------------------------------------------
; 119  :      Compute reduced polynomials Rp(z) and Rq(z).
; 120  :        These are computed from:
; 121  : 
; 122  :        Rp(z) = PROD(i=1...N/2) (1 + Dp_i z^(-1) + z^(-2))
; 123  :        Rq(z) = PROD(i=1...N/2) (1 + Dq_i z^(-1) + z^(-2))
; 124  : 
; 125  :        where:
; 126  : 
; 127  :           Dp_i = -2.0*cos( 2*PI * LSP(2*i-1) )
; 128  :           Dq_i = -2.0*cos( 2*PI * LSP(2*i) )
; 129  : 
; 130  :        Due to the symmetry, only half of the coefficients 
; 131  :        of Rp(z) and Rq(z) need to be computed.  Also,
; 132  :        in each term of the product, the coefficients of 
; 133  :        z^0 and z^(-2) are 1, so multiplication 
; 134  :        by either of these two coefficients is replaced 
; 135  :        by a simple assignment operation.
; 136  :    ------------------------------------------------------*/
; 137  : 
; 138  : 
; 139  :    /*------------------------------------------------------
; 140  :      Assign coefficient values of the first stage of the
; 141  :        product.  The values of fRp[2] and fRq[2] are not
; 142  :        assigned since they are symmetric with fRp[0] and 
; 143  :        fRq[0].
; 144  :    ------------------------------------------------------*/
; 145  :    fRp[0] = 1.0F;

  00089	c7 45 a0 00 00
	80 3f		 mov	 DWORD PTR _fRp$[ebp], 1065353216 ; 3f800000H

; 146  :    fRq[0] = 1.0F;

  00090	c7 45 d0 00 00
	80 3f		 mov	 DWORD PTR _fRq$[ebp], 1065353216 ; 3f800000H

; 147  : 
; 148  :    /*------------------------------------------------------
; 149  :      Compute the coefficients Dp_0 and Dq_0 from the LSPs.
; 150  :    ------------------------------------------------------*/
; 151  :    fRp[1] = -2.0F * (float) cos( fScale * (*pfLSP++) );

  00097	8b 45 08	 mov	 eax, DWORD PTR _pfLSP$[ebp]
  0009a	d9 45 c8	 fld	 DWORD PTR _fScale$[ebp]
  0009d	d8 08		 fmul	 DWORD PTR [eax]
  0009f	dd 5d 90	 fstp	 QWORD PTR tv92[ebp]
  000a2	8b 4d 94	 mov	 ecx, DWORD PTR tv92[ebp+4]
  000a5	51		 push	 ecx
  000a6	8b 55 90	 mov	 edx, DWORD PTR tv92[ebp]
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 _cos
  000af	83 c4 08	 add	 esp, 8
  000b2	d9 55 8c	 fst	 DWORD PTR tv269[ebp]
  000b5	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@c0000000
  000bb	d9 5d a4	 fstp	 DWORD PTR _fRp$[ebp+4]
  000be	8b 45 08	 mov	 eax, DWORD PTR _pfLSP$[ebp]
  000c1	83 c0 04	 add	 eax, 4
  000c4	89 45 08	 mov	 DWORD PTR _pfLSP$[ebp], eax

; 152  :    fRq[1] = -2.0F * (float) cos( fScale * (*pfLSP++) );

  000c7	8b 4d 08	 mov	 ecx, DWORD PTR _pfLSP$[ebp]
  000ca	d9 45 c8	 fld	 DWORD PTR _fScale$[ebp]
  000cd	d8 09		 fmul	 DWORD PTR [ecx]
  000cf	dd 5d 84	 fstp	 QWORD PTR tv133[ebp]
  000d2	8b 55 88	 mov	 edx, DWORD PTR tv133[ebp+4]
  000d5	52		 push	 edx
  000d6	8b 45 84	 mov	 eax, DWORD PTR tv133[ebp]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 _cos
  000df	83 c4 08	 add	 esp, 8
  000e2	d9 55 80	 fst	 DWORD PTR tv282[ebp]
  000e5	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@c0000000
  000eb	d9 5d d4	 fstp	 DWORD PTR _fRq$[ebp+4]
  000ee	8b 4d 08	 mov	 ecx, DWORD PTR _pfLSP$[ebp]
  000f1	83 c1 04	 add	 ecx, 4
  000f4	89 4d 08	 mov	 DWORD PTR _pfLSP$[ebp], ecx

; 153  : 
; 154  :    /*------------------------------------------------------
; 155  :      Multiply out each sucessive stage of the product.
; 156  :    ------------------------------------------------------*/
; 157  :    for (i=1; i<iOrder2; i++)

  000f7	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000fe	eb 09		 jmp	 SHORT $L738
$L739:
  00100	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00103	83 c2 01	 add	 edx, 1
  00106	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L738:
  00109	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0010c	3b 45 cc	 cmp	 eax, DWORD PTR _iOrder2$[ebp]
  0010f	0f 8d 26 01 00
	00		 jge	 $L740

; 158  :    {
; 159  : 
; 160  :       /*------------------------------------------------------
; 161  :         Compute the coefficients Dp_i and Dq_i from the LSPs.
; 162  :       ------------------------------------------------------*/
; 163  :       fDp = -2.0F * (float) cos( fScale * (*pfLSP++) );

  00115	8b 4d 08	 mov	 ecx, DWORD PTR _pfLSP$[ebp]
  00118	d9 45 c8	 fld	 DWORD PTR _fScale$[ebp]
  0011b	d8 09		 fmul	 DWORD PTR [ecx]
  0011d	dd 9d 78 ff ff
	ff		 fstp	 QWORD PTR tv143[ebp]
  00123	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv143[ebp+4]
  00129	52		 push	 edx
  0012a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv143[ebp]
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 _cos
  00136	83 c4 08	 add	 esp, 8
  00139	d9 95 74 ff ff
	ff		 fst	 DWORD PTR tv297[ebp]
  0013f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@c0000000
  00145	d9 5d 9c	 fstp	 DWORD PTR _fDp$[ebp]
  00148	8b 4d 08	 mov	 ecx, DWORD PTR _pfLSP$[ebp]
  0014b	83 c1 04	 add	 ecx, 4
  0014e	89 4d 08	 mov	 DWORD PTR _pfLSP$[ebp], ecx

; 164  :       fDq = -2.0F * (float) cos( fScale * (*pfLSP++) );

  00151	8b 55 08	 mov	 edx, DWORD PTR _pfLSP$[ebp]
  00154	d9 45 c8	 fld	 DWORD PTR _fScale$[ebp]
  00157	d8 0a		 fmul	 DWORD PTR [edx]
  00159	dd 9d 6c ff ff
	ff		 fstp	 QWORD PTR tv151[ebp]
  0015f	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv151[ebp+4]
  00165	50		 push	 eax
  00166	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv151[ebp]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 _cos
  00172	83 c4 08	 add	 esp, 8
  00175	d9 95 68 ff ff
	ff		 fst	 DWORD PTR tv310[ebp]
  0017b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@c0000000
  00181	d9 5d f8	 fstp	 DWORD PTR _fDq$[ebp]
  00184	8b 55 08	 mov	 edx, DWORD PTR _pfLSP$[ebp]
  00187	83 c2 04	 add	 edx, 4
  0018a	89 55 08	 mov	 DWORD PTR _pfLSP$[ebp], edx

; 165  : 
; 166  :       /*------------------------------------------------------
; 167  :          This first step in the product is actually:
; 168  : 
; 169  :            fRp[i+1] = fRp[i+1] + fDp*fRp[i] + fRp[i-1]
; 170  : 
; 171  :          but there is no value for fRp[i+1] from the
; 172  :          previous stage of the product since only half
; 173  :          of the symmetric coefficients are computed.  
; 174  :          The value of fRp[i+1] from the previous stage
; 175  :          can be found from the symmetry:
; 176  : 
; 177  :             fRp[i+1] = fRp[i-1]
; 178  : 
; 179  :          so the new value of fRp[i+1] is computed as:
; 180  : 
; 181  :             fRp[i+1] = fRp[i-1] + fDp*fRp[i] + fRp[i-1]
; 182  : 
; 183  :       ------------------------------------------------------*/
; 184  :       fRp[i+1] = fDp*fRp[i] + 2.0F*fRp[i-1];

  0018d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00190	d9 45 9c	 fld	 DWORD PTR _fDp$[ebp]
  00193	d8 4c 85 a0	 fmul	 DWORD PTR _fRp$[ebp+eax*4]
  00197	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0019a	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40000000
  001a0	d8 4c 8d 9c	 fmul	 DWORD PTR _fRp$[ebp+ecx*4-4]
  001a4	de c1		 faddp	 ST(1), ST(0)
  001a6	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001a9	d9 5c 95 a4	 fstp	 DWORD PTR _fRp$[ebp+edx*4+4]

; 185  :       fRq[i+1] = fDq*fRq[i] + 2.0F*fRq[i-1];

  001ad	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001b0	d9 45 f8	 fld	 DWORD PTR _fDq$[ebp]
  001b3	d8 4c 85 d0	 fmul	 DWORD PTR _fRq$[ebp+eax*4]
  001b7	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001ba	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40000000
  001c0	d8 4c 8d cc	 fmul	 DWORD PTR _fRq$[ebp+ecx*4-4]
  001c4	de c1		 faddp	 ST(1), ST(0)
  001c6	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001c9	d9 5c 95 d4	 fstp	 DWORD PTR _fRq$[ebp+edx*4+4]

; 186  : 
; 187  :       for (j=i; j>1; j--)

  001cd	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001d0	89 45 98	 mov	 DWORD PTR _j$[ebp], eax
  001d3	eb 09		 jmp	 SHORT $L743
$L744:
  001d5	8b 4d 98	 mov	 ecx, DWORD PTR _j$[ebp]
  001d8	83 e9 01	 sub	 ecx, 1
  001db	89 4d 98	 mov	 DWORD PTR _j$[ebp], ecx
$L743:
  001de	83 7d 98 01	 cmp	 DWORD PTR _j$[ebp], 1
  001e2	7e 40		 jle	 SHORT $L745

; 188  :       {
; 189  :          fRp[j] = fRp[j] + fDp*fRp[j-1] + fRp[j-2];

  001e4	8b 55 98	 mov	 edx, DWORD PTR _j$[ebp]
  001e7	d9 45 9c	 fld	 DWORD PTR _fDp$[ebp]
  001ea	d8 4c 95 9c	 fmul	 DWORD PTR _fRp$[ebp+edx*4-4]
  001ee	8b 45 98	 mov	 eax, DWORD PTR _j$[ebp]
  001f1	d8 44 85 a0	 fadd	 DWORD PTR _fRp$[ebp+eax*4]
  001f5	8b 4d 98	 mov	 ecx, DWORD PTR _j$[ebp]
  001f8	d8 44 8d 98	 fadd	 DWORD PTR _fRp$[ebp+ecx*4-8]
  001fc	8b 55 98	 mov	 edx, DWORD PTR _j$[ebp]
  001ff	d9 5c 95 a0	 fstp	 DWORD PTR _fRp$[ebp+edx*4]

; 190  :          fRq[j] = fRq[j] + fDq*fRq[j-1] + fRq[j-2];

  00203	8b 45 98	 mov	 eax, DWORD PTR _j$[ebp]
  00206	d9 45 f8	 fld	 DWORD PTR _fDq$[ebp]
  00209	d8 4c 85 cc	 fmul	 DWORD PTR _fRq$[ebp+eax*4-4]
  0020d	8b 4d 98	 mov	 ecx, DWORD PTR _j$[ebp]
  00210	d8 44 8d d0	 fadd	 DWORD PTR _fRq$[ebp+ecx*4]
  00214	8b 55 98	 mov	 edx, DWORD PTR _j$[ebp]
  00217	d8 44 95 c8	 fadd	 DWORD PTR _fRq$[ebp+edx*4-8]
  0021b	8b 45 98	 mov	 eax, DWORD PTR _j$[ebp]
  0021e	d9 5c 85 d0	 fstp	 DWORD PTR _fRq$[ebp+eax*4]

; 191  :       }

  00222	eb b1		 jmp	 SHORT $L744
$L745:

; 192  : 
; 193  :       /*------------------------------------------------------
; 194  :         This step is actually:
; 195  : 
; 196  :            fRp[1] = fRp[1] + fRp[0]*fDp;
; 197  : 
; 198  :         but fRp[0] = 1.0 always, so the multiplication by
; 199  :         fRp[0] is omitted.
; 200  :       ------------------------------------------------------*/
; 201  :       fRp[1] += fDp;

  00224	d9 45 a4	 fld	 DWORD PTR _fRp$[ebp+4]
  00227	d8 45 9c	 fadd	 DWORD PTR _fDp$[ebp]
  0022a	d9 5d a4	 fstp	 DWORD PTR _fRp$[ebp+4]

; 202  :       fRq[1] += fDq;

  0022d	d9 45 d4	 fld	 DWORD PTR _fRq$[ebp+4]
  00230	d8 45 f8	 fadd	 DWORD PTR _fDq$[ebp]
  00233	d9 5d d4	 fstp	 DWORD PTR _fRq$[ebp+4]

; 203  : 
; 204  :       /*------------------------------------------------------
; 205  :         The final step in this stage of the product is 
; 206  :           fRp[0] = fRp[0] but since that is redundant it
; 207  :           is omitted.
; 208  :       ------------------------------------------------------*/
; 209  :    }

  00236	e9 c5 fe ff ff	 jmp	 $L739
$L740:

; 210  : 
; 211  :    /*------------------------------------------------------
; 212  :      Compute polynomials P(z) and Q(z).  
; 213  : 
; 214  :        P(z) = (1 + z^(-1)) Rp(z)
; 215  :        Q(z) = (1 - z^(-1)) Rq(z)
; 216  : 
; 217  :        These are computed in place! Again, due to symmetry 
; 218  :        only half of the coefficients are computed.
; 219  :    ------------------------------------------------------*/
; 220  :    for (i=iOrder2; i; i--)

  0023b	8b 4d cc	 mov	 ecx, DWORD PTR _iOrder2$[ebp]
  0023e	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00241	eb 09		 jmp	 SHORT $L746
$L747:
  00243	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00246	83 ea 01	 sub	 edx, 1
  00249	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L746:
  0024c	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00250	74 2c		 je	 SHORT $L748

; 221  :    {
; 222  :       fRp[i] += fRp[i-1];

  00252	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00255	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00258	d9 44 85 a0	 fld	 DWORD PTR _fRp$[ebp+eax*4]
  0025c	d8 44 8d 9c	 fadd	 DWORD PTR _fRp$[ebp+ecx*4-4]
  00260	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00263	d9 5c 95 a0	 fstp	 DWORD PTR _fRp$[ebp+edx*4]

; 223  :       fRq[i] -= fRq[i-1];

  00267	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0026a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0026d	d9 44 85 d0	 fld	 DWORD PTR _fRq$[ebp+eax*4]
  00271	d8 64 8d cc	 fsub	 DWORD PTR _fRq$[ebp+ecx*4-4]
  00275	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00278	d9 5c 95 d0	 fstp	 DWORD PTR _fRq$[ebp+edx*4]

; 224  :    }

  0027c	eb c5		 jmp	 SHORT $L747
$L748:

; 225  : 
; 226  :    /*------------------------------------------------------
; 227  :      Compute predictor coefficients:
; 228  : 
; 229  :         A(z) = 0.5 * (P(z) + Q(z))
; 230  :    ------------------------------------------------------*/
; 231  :    pfAs[0] = 1.0F;

  0027e	8b 45 14	 mov	 eax, DWORD PTR _pfAs$[ebp]
  00281	c7 00 00 00 80
	3f		 mov	 DWORD PTR [eax], 1065353216 ; 3f800000H

; 232  :    for (i=1; i<=iOrder2; i++)

  00287	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0028e	eb 09		 jmp	 SHORT $L749
$L750:
  00290	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00293	83 c1 01	 add	 ecx, 1
  00296	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L749:
  00299	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0029c	3b 55 cc	 cmp	 edx, DWORD PTR _iOrder2$[ebp]
  0029f	7f 42		 jg	 SHORT $L718

; 233  :    {
; 234  :       pfAs[i]          = 0.5F*(fRp[i]+fRq[i]);

  002a1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  002a4	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  002a7	d9 44 85 a0	 fld	 DWORD PTR _fRp$[ebp+eax*4]
  002ab	d8 44 8d d0	 fadd	 DWORD PTR _fRq$[ebp+ecx*4]
  002af	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  002b5	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  002b8	8b 45 14	 mov	 eax, DWORD PTR _pfAs$[ebp]
  002bb	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]

; 235  :       pfAs[iOrder+1-i] = 0.5F*(fRp[i]-fRq[i]);

  002be	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  002c1	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  002c4	d9 44 8d a0	 fld	 DWORD PTR _fRp$[ebp+ecx*4]
  002c8	d8 64 95 d0	 fsub	 DWORD PTR _fRq$[ebp+edx*4]
  002cc	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  002d2	8b 45 0c	 mov	 eax, DWORD PTR _iOrder$[ebp]
  002d5	83 c0 01	 add	 eax, 1
  002d8	2b 45 fc	 sub	 eax, DWORD PTR _i$[ebp]
  002db	8b 4d 14	 mov	 ecx, DWORD PTR _pfAs$[ebp]
  002de	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]

; 236  :    }

  002e1	eb ad		 jmp	 SHORT $L750
$L718:

; 237  : }

  002e3	8b e5		 mov	 esp, ebp
  002e5	5d		 pop	 ebp
  002e6	c2 10 00	 ret	 16			; 00000010H
_VoxLspToAsEven@16 ENDP
_TEXT	ENDS
END
