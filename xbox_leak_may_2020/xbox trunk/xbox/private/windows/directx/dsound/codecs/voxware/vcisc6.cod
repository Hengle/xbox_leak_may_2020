; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\vcisc6.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0M@HMONDJF@SC?401?408?400?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@KGCNFMNN@frame?5length?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HCCHHEEF@rate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _vciGetInfoSC6@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciEncodeSC6@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciDecodeSC6@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciInitEncodeSC6@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciInitDecodeSC6@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciFreeEncodeSC6@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciFreeDecodeSC6@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _vciGetExtCompatibilitySC6@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SC6CompatibilityFunc@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _initMethodStruct@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _freeMethodStruct@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_vciGetInfoSC6@4
PUBLIC	??_C@_0M@HMONDJF@SC?401?408?400?$AA@		; `string'
EXTRN	_ceil:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	_strcpy:NEAR
;	COMDAT ??_C@_0M@HMONDJF@SC?401?408?400?$AA@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\vcisc6.c
CONST	SEGMENT
??_C@_0M@HMONDJF@SC?401?408?400?$AA@ DB 'SC.01.08.00', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciGetInfoSC6@4
_TEXT	SEGMENT
_pvciCodecInfoBlk$ = 8
_vciGetInfoSC6@4 PROC NEAR				; COMDAT

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 131  : 
; 132  :    pvciCodecInfoBlk->wVCIVersion               = (unsigned short) VCI_VERSION;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00006	66 c7 00 04 00	 mov	 WORD PTR [eax], 4

; 133  :    
; 134  :    /* Variables for codec identification.     */
; 135  :    strcpy(pvciCodecInfoBlk->sCodecVersion,       SC_CODEC_VERSION);

  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@HMONDJF@SC?401?408?400?$AA@
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00013	83 c1 02	 add	 ecx, 2
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 _strcpy
  0001c	83 c4 08	 add	 esp, 8

; 136  :    pvciCodecInfoBlk->dwCodecClassID            = (unsigned long)VOXWARE_CODEC_SC_8K_6;      

  0001f	8b 55 08	 mov	 edx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00022	c7 42 24 06 00
	00 03		 mov	 DWORD PTR [edx+36], 50331654 ; 03000006H

; 137  :    /* generic codec is SC3 */
; 138  :    pvciCodecInfoBlk->dwCodecID                 = (unsigned long)VOXWARE_CODEC_ID_SC_8K_3_GENERIC;  

  00029	8b 45 08	 mov	 eax, DWORD PTR _pvciCodecInfoBlk$[ebp]
  0002c	c7 40 28 03 00
	01 03		 mov	 DWORD PTR [eax+40], 50397187 ; 03010003H

; 139  :    
; 140  :    /* PCM Data formats.                       */
; 141  :    pvciCodecInfoBlk->wSamplingRate             = (unsigned short)RATE8K;   

  00033	8b 4d 08	 mov	 ecx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00036	66 c7 41 2c 40
	1f		 mov	 WORD PTR [ecx+44], 8000	; 00001f40H

; 142  :    pvciCodecInfoBlk->wNumBitsPerSample         = 16; 

  0003c	8b 55 08	 mov	 edx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  0003f	66 c7 42 2e 10
	00		 mov	 WORD PTR [edx+46], 16	; 00000010H

; 143  :    pvciCodecInfoBlk->wNumSamplesPerFrame       = (unsigned short)FRAME_LENGTH_SC;

  00045	8b 45 08	 mov	 eax, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00048	66 c7 40 30 a0
	00		 mov	 WORD PTR [eax+48], 160	; 000000a0H

; 144  : 
; 145  :    pvciCodecInfoBlk->dwBitRate                 = (unsigned long)((TOTAL_BITS_SC3+
; 146  :                                                     ADDITIONAL_BITS_SC6)*
; 147  :                                                     (float)RATE8K/(float)FRAME_LENGTH_SC);

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00051	c7 41 38 00 19
	00 00		 mov	 DWORD PTR [ecx+56], 6400 ; 00001900H

; 148  : 
; 149  :    /* Prime Flush Information */
; 150  :    /* encoder delay + decoder delay == ENC_DELAY_SIZE (145 == 80 + 65) */
; 151  :    pvciCodecInfoBlk->wNumPrimeFlushFrames      = (unsigned short)ceil((float)ENC_DELAY_SIZE
; 152  :                                                   /(float)FRAME_LENGTH_SC);

  00058	68 00 00 ed 3f	 push	 1072496640		; 3fed0000H
  0005d	6a 00		 push	 0
  0005f	e8 00 00 00 00	 call	 _ceil
  00064	83 c4 08	 add	 esp, 8
  00067	e8 00 00 00 00	 call	 __ftol2
  0006c	8b 55 08	 mov	 edx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  0006f	66 89 42 48	 mov	 WORD PTR [edx+72], ax

; 153  :    pvciCodecInfoBlk->wNumPrimeFlushSamples     = 
; 154  :               (unsigned short)(pvciCodecInfoBlk->wNumPrimeFlushFrames*FRAME_LENGTH_SC
; 155  :                               -ENC_DELAY_SIZE);

  00073	8b 45 08	 mov	 eax, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00076	0f b7 48 48	 movzx	 ecx, WORD PTR [eax+72]
  0007a	69 c9 a0 00 00
	00		 imul	 ecx, 160		; 000000a0H
  00080	81 e9 91 00 00
	00		 sub	 ecx, 145		; 00000091H
  00086	8b 55 08	 mov	 edx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00089	66 89 4a 4a	 mov	 WORD PTR [edx+74], cx

; 156  :    
; 157  :    /* Bitstream information (for fix rate codec). */
; 158  :    pvciCodecInfoBlk->dwMinPacketBits           = (unsigned short) (TOTAL_BITS_SC3+
; 159  :                                                     ADDITIONAL_BITS_SC6);

  0008d	8b 45 08	 mov	 eax, DWORD PTR _pvciCodecInfoBlk$[ebp]
  00090	c7 40 3c 80 00
	00 00		 mov	 DWORD PTR [eax+60], 128	; 00000080H

; 160  :    pvciCodecInfoBlk->dwAvgPacketBits           = pvciCodecInfoBlk->dwMinPacketBits;

  00097	8b 4d 08	 mov	 ecx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  0009a	8b 55 08	 mov	 edx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  0009d	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000a0	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 161  :    pvciCodecInfoBlk->dwMaxPacketBits           = pvciCodecInfoBlk->dwMinPacketBits;

  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  000a6	8b 55 08	 mov	 edx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  000a9	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000ac	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 162  :    
; 163  :    /* Multi-channel support.                  */
; 164  :    pvciCodecInfoBlk->wNumChannels              = 1;

  000af	8b 4d 08	 mov	 ecx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  000b2	66 c7 41 32 01
	00		 mov	 WORD PTR [ecx+50], 1

; 165  :    pvciCodecInfoBlk->wInterleaveBlockSize      = 1;

  000b8	8b 55 08	 mov	 edx, DWORD PTR _pvciCodecInfoBlk$[ebp]
  000bb	66 c7 42 34 01
	00		 mov	 WORD PTR [edx+52], 1

; 166  : 
; 167  :    return(VCI_NO_ERROR);

  000c1	66 33 c0	 xor	 ax, ax

; 168  : }

  000c4	5d		 pop	 ebp
  000c5	c2 04 00	 ret	 4
_vciGetInfoSC6@4 ENDP
_TEXT	ENDS
PUBLIC	_vciEncodeSC6@8
EXTRN	_VoxPackSC3@24:NEAR
EXTRN	_VoxPackSC6@24:NEAR
EXTRN	_VoxEncodeSC@12:NEAR
EXTRN	_voxGetEncodeRate@4:NEAR
EXTRN	_voxGetEncodeInitRate@4:NEAR
EXTRN	_VoxQuantSC3@12:NEAR
EXTRN	_VoxQuantSC6@8:NEAR
; Function compile flags: /Odt
;	COMDAT _vciEncodeSC6@8
_TEXT	SEGMENT
_QuanSC6Index$2325 = -312
_QuanSC3Index$2324 = -264
_vciCodecMblk$ = -188
_ParamMblk$ = -184
_pEncodeMemBlk$ = 8
_pvciCodecIOBlk$ = 12
_vciEncodeSC6@8 PROC NEAR				; COMDAT

; 205  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H

; 206  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00009	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 207  :    PARAM_SC ParamMblk; /* scratch memory */
; 208  :    STACK_DECLARE
; 209  :    
; 210  :    /* check the validity of the VCI IO blk */
; 211  :    VCI_IO_BLK_PARAM_CHECK(pvciCodecIOBlk);

  00013	83 7d 0c 00	 cmp	 DWORD PTR _pvciCodecIOBlk$[ebp], 0
  00017	75 09		 jne	 SHORT $L2309
  00019	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  0001d	e9 e0 01 00 00	 jmp	 $L2305
$L2309:
  00022	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00025	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00029	75 09		 jne	 SHORT $L2310
  0002b	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  0002f	e9 ce 01 00 00	 jmp	 $L2305
$L2310:
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00037	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0003a	75 09		 jne	 SHORT $L2311
  0003c	66 b8 ed 17	 mov	 ax, 6125		; 000017edH
  00040	e9 bd 01 00 00	 jmp	 $L2305
$L2311:
  00045	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00048	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0004f	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00053	3b c2		 cmp	 eax, edx
  00055	7c 09		 jl	 SHORT $L2312
  00057	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  0005b	e9 a2 01 00 00	 jmp	 $L2305
$L2312:
  00060	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00063	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00067	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0006a	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  0006e	3b c8		 cmp	 ecx, eax
  00070	7c 09		 jl	 SHORT $L2313
  00072	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  00076	e9 87 01 00 00	 jmp	 $L2305
$L2313:
  0007b	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0007e	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  00082	83 fa 07	 cmp	 edx, 7
  00085	7e 09		 jle	 SHORT $L2314
  00087	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  0008b	e9 72 01 00 00	 jmp	 $L2305
$L2314:
  00090	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00093	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  00097	83 f9 07	 cmp	 ecx, 7
  0009a	7e 09		 jle	 SHORT $L2315
  0009c	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  000a0	e9 5d 01 00 00	 jmp	 $L2305
$L2315:

; 212  : 
; 213  :    if(!VCI_BLOCK_CHECK(pEncodeMemBlk))

  000a5	83 7d 08 00	 cmp	 DWORD PTR _pEncodeMemBlk$[ebp], 0
  000a9	74 0b		 je	 SHORT $L2318
  000ab	8b 55 08	 mov	 edx, DWORD PTR _pEncodeMemBlk$[ebp]
  000ae	81 3a ce fa 00
	00		 cmp	 DWORD PTR [edx], 64206	; 0000faceH
  000b4	74 09		 je	 SHORT $L2317
$L2318:

; 214  :       return VCI_NOT_VCI_HANDLE;

  000b6	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  000ba	e9 43 01 00 00	 jmp	 $L2305
$L2317:

; 215  : 
; 216  :    if(!VCI_IS_ENCODE(pEncodeMemBlk))     

  000bf	8b 45 08	 mov	 eax, DWORD PTR _pEncodeMemBlk$[ebp]
  000c2	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  000c6	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  000c9	74 09		 je	 SHORT $L2320

; 217  :       return VCI_NOT_ENC_HANDLE;

  000cb	66 b8 de 17	 mov	 ax, 6110		; 000017deH
  000cf	e9 2e 01 00 00	 jmp	 $L2305
$L2320:

; 218  : 
; 219  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pEncodeMemBlk;

  000d4	8b 55 08	 mov	 edx, DWORD PTR _pEncodeMemBlk$[ebp]
  000d7	89 95 44 ff ff
	ff		 mov	 DWORD PTR _vciCodecMblk$[ebp], edx

; 220  :    STACK_ASSIGN(vciCodecMblk->pScratchBlk)
; 221  :    vciCodecMblk->pVciCodecIOBlock=pvciCodecIOBlk;

  000dd	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  000e3	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000e6	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 222  : 
; 223  :    /* check to make sure that codec was initialized at 6 or higher */
; 224  :    if(!(voxGetEncodeInitRate(vciCodecMblk->hCodecMblk)&SC_RATE_6K))

  000e9	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000ef	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 _voxGetEncodeInitRate@4
  000f8	83 e0 02	 and	 eax, 2
  000fb	85 c0		 test	 eax, eax
  000fd	75 09		 jne	 SHORT $L2322

; 225  :       return VCI_CODEC_NOT_SUPPORTED; 

  000ff	66 b8 64 19	 mov	 ax, 6500		; 00001964H
  00103	e9 fa 00 00 00	 jmp	 $L2305
$L2322:

; 226  : 
; 227  :    /*--------------------------------------------------------------------
; 228  :      Encode speech at SC_RATE_6K
; 229  :    --------------------------------------------------------------------*/
; 230  :    VoxEncodeSC(STACK_S pvciCodecIOBlk->pPCMBuffer, vciCodecMblk->hCodecMblk,
; 231  :                (void *)&ParamMblk);

  00108	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _ParamMblk$[ebp]
  0010e	51		 push	 ecx
  0010f	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00115	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00118	50		 push	 eax
  00119	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0011c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 _VoxEncodeSC@12

; 232  : 
; 233  :    {
; 234  :      int QuanSC3Index[TOTAL_SC3_QUAN_INDICES];
; 235  :      int QuanSC6Index[EXTRA_SC6_QUAN_INDICES];
; 236  : 
; 237  :      /*--------------------------------------------------------------------
; 238  :       Quantize 3k parameters and then quantize 6k parameters
; 239  :      --------------------------------------------------------------------*/
; 240  :      VoxQuantSC3(STACK_S QuanSC3Index, vciCodecMblk->hCodecMblk,
; 241  :                  (void *)&ParamMblk);

  00124	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _ParamMblk$[ebp]
  0012a	50		 push	 eax
  0012b	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00131	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00134	52		 push	 edx
  00135	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _QuanSC3Index$2324[ebp]
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _VoxQuantSC3@12

; 242  : 
; 243  :      if(voxGetEncodeRate(vciCodecMblk->hCodecMblk)!=SC_RATE_3K)

  00141	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00147	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0014a	52		 push	 edx
  0014b	e8 00 00 00 00	 call	 _voxGetEncodeRate@4
  00150	83 f8 01	 cmp	 eax, 1
  00153	74 13		 je	 SHORT $L2327

; 244  :         VoxQuantSC6(QuanSC6Index, (void *)&ParamMblk);

  00155	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _ParamMblk$[ebp]
  0015b	50		 push	 eax
  0015c	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _QuanSC6Index$2325[ebp]
  00162	51		 push	 ecx
  00163	e8 00 00 00 00	 call	 _VoxQuantSC6@8
$L2327:

; 245  : 
; 246  :      /*--------------------------------------------------------------------
; 247  :        Pack 3k parameters and then pack 6k parameters
; 248  :      --------------------------------------------------------------------*/
; 249  :      if(voxGetEncodeRate(vciCodecMblk->hCodecMblk)==SC_RATE_3K) {

  00168	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0016e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 _voxGetEncodeRate@4
  00177	83 f8 01	 cmp	 eax, 1
  0017a	75 2d		 jne	 SHORT $L2329

; 250  :         VoxPackSC3(QuanSC3Index,
; 251  :                    pvciCodecIOBlk->pVoxBuffer,
; 252  :                    &(pvciCodecIOBlk->wVoxBufferWriteByteOffset),
; 253  :                    &(pvciCodecIOBlk->chVoxBufferWriteBitOffset),
; 254  :                    pvciCodecIOBlk->wVoxBufferSize,
; 255  :                    (unsigned short) END_OF_FRAME);

  0017c	6a 00		 push	 0
  0017e	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00181	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  00185	52		 push	 edx
  00186	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00189	83 c0 14	 add	 eax, 20			; 00000014H
  0018c	50		 push	 eax
  0018d	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00190	83 c1 12	 add	 ecx, 18			; 00000012H
  00193	51		 push	 ecx
  00194	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00197	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0019a	50		 push	 eax
  0019b	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _QuanSC3Index$2324[ebp]
  001a1	51		 push	 ecx
  001a2	e8 00 00 00 00	 call	 _VoxPackSC3@24

; 256  : 
; 257  :      } else {

  001a7	eb 56		 jmp	 SHORT $L2331
$L2329:

; 258  :         VoxPackSC3(QuanSC3Index,
; 259  :                    pvciCodecIOBlk->pVoxBuffer,
; 260  :                    &(pvciCodecIOBlk->wVoxBufferWriteByteOffset),
; 261  :                    &(pvciCodecIOBlk->chVoxBufferWriteBitOffset),
; 262  :                    pvciCodecIOBlk->wVoxBufferSize,
; 263  :                    (unsigned short) LONGER_FRAME);

  001a9	6a 01		 push	 1
  001ab	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  001ae	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  001b2	50		 push	 eax
  001b3	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  001b6	83 c1 14	 add	 ecx, 20			; 00000014H
  001b9	51		 push	 ecx
  001ba	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  001bd	83 c2 12	 add	 edx, 18			; 00000012H
  001c0	52		 push	 edx
  001c1	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  001c4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001c7	51		 push	 ecx
  001c8	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _QuanSC3Index$2324[ebp]
  001ce	52		 push	 edx
  001cf	e8 00 00 00 00	 call	 _VoxPackSC3@24

; 264  : 
; 265  :         VoxPackSC6(QuanSC6Index,
; 266  :                    pvciCodecIOBlk->pVoxBuffer,
; 267  :                    &(pvciCodecIOBlk->wVoxBufferWriteByteOffset),
; 268  :                    &(pvciCodecIOBlk->chVoxBufferWriteBitOffset),
; 269  :                    pvciCodecIOBlk->wVoxBufferSize,
; 270  :                    (unsigned short) END_OF_FRAME);

  001d4	6a 00		 push	 0
  001d6	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  001d9	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  001dd	51		 push	 ecx
  001de	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  001e1	83 c2 14	 add	 edx, 20			; 00000014H
  001e4	52		 push	 edx
  001e5	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  001e8	83 c0 12	 add	 eax, 18			; 00000012H
  001eb	50		 push	 eax
  001ec	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  001ef	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001f2	52		 push	 edx
  001f3	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _QuanSC6Index$2325[ebp]
  001f9	50		 push	 eax
  001fa	e8 00 00 00 00	 call	 _VoxPackSC6@24
$L2331:

; 271  :      }
; 272  :    }
; 273  : 
; 274  :    return(VCI_NO_ERROR);

  001ff	66 33 c0	 xor	 ax, ax
$L2305:

; 275  : }

  00202	8b e5		 mov	 esp, ebp
  00204	5d		 pop	 ebp
  00205	c2 08 00	 ret	 8
_vciEncodeSC6@8 ENDP
_TEXT	ENDS
PUBLIC	_vciDecodeSC6@8
EXTRN	_VoxUnQuantSC3@12:NEAR
EXTRN	_VoxUnQuantSC6@8:NEAR
EXTRN	_VoxUnPackSC3@24:NEAR
EXTRN	_VoxUnPackSC6@24:NEAR
EXTRN	_VoxFadeSC@8:NEAR
EXTRN	_GetCurrentFrameStateSC@4:NEAR
EXTRN	_UpdateFadeStateSC@8:NEAR
EXTRN	_vciSeekForwardSC@20:NEAR
EXTRN	_copyCBuf2LBuf@24:NEAR
EXTRN	_VoxDecodeSC@16:NEAR
EXTRN	_voxSetDecodeSC@8:NEAR
EXTRN	_voxGetDecReqDataFlagSC@4:NEAR
; Function compile flags: /Odt
;	COMDAT _vciDecodeSC6@8
_TEXT	SEGMENT
_QuanSC6Index$2367 = -336
_QuanSC3Index$2366 = -288
_VoxErrRet$ = -216
_sByteOffset$ = -212
_vciCodecMblk$ = -208
_sLongerFrameFlag$ = -204
_pDecMemBlk$ = -200
_cDecReqDataFlagSC$ = -193
_ParamMblk$ = -192
_cBitOffset$ = -1
_pDecodeMemBlk$ = 8
_pvciCodecIOBlk$ = 12
_vciDecodeSC6@8 PROC NEAR				; COMDAT

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H

; 313  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00009	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 314  :    DEC_MEM_BLK     *pDecMemBlk;
; 315  :    PARAM_SC        ParamMblk;
; 316  :    STACK_DECLARE
; 317  :    unsigned short  sLongerFrameFlag;
; 318  :    VCI_RETCODE VoxErrRet = VCI_NO_ERROR;

  00013	66 c7 85 28 ff
	ff ff 00 00	 mov	 WORD PTR _VoxErrRet$[ebp], 0

; 319  :    unsigned short sByteOffset=0;

  0001c	66 c7 85 2c ff
	ff ff 00 00	 mov	 WORD PTR _sByteOffset$[ebp], 0

; 320  :    unsigned char  cBitOffset=0;

  00025	c6 45 ff 00	 mov	 BYTE PTR _cBitOffset$[ebp], 0

; 321  :    unsigned char cDecReqDataFlagSC;
; 322  : 
; 323  :    /*----------------------------------------------------
; 324  :      sanity check and decode check
; 325  :    ----------------------------------------------------*/
; 326  :    if(!VCI_BLOCK_CHECK(pDecodeMemBlk))

  00029	83 7d 08 00	 cmp	 DWORD PTR _pDecodeMemBlk$[ebp], 0
  0002d	74 0b		 je	 SHORT $L2350
  0002f	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  00032	81 38 ce fa 00
	00		 cmp	 DWORD PTR [eax], 64206	; 0000faceH
  00038	74 09		 je	 SHORT $L2349
$L2350:

; 327  :       return VCI_NOT_VCI_HANDLE;

  0003a	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  0003e	e9 39 03 00 00	 jmp	 $L2338
$L2349:

; 328  : 
; 329  :    if(!VCI_IS_DECODE(pDecodeMemBlk))     

  00043	8b 4d 08	 mov	 ecx, DWORD PTR _pDecodeMemBlk$[ebp]
  00046	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  0004a	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0004d	74 09		 je	 SHORT $L2352

; 330  :       return VCI_NOT_DEC_HANDLE;

  0004f	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  00053	e9 24 03 00 00	 jmp	 $L2338
$L2352:

; 331  :     
; 332  :    /*----------------------------------------------------
; 333  :      set some pointers and assign the VoxStack
; 334  :    ----------------------------------------------------*/
; 335  :    vciCodecMblk = (VCI_CODEC_BLOCK *)pDecodeMemBlk;

  00058	8b 45 08	 mov	 eax, DWORD PTR _pDecodeMemBlk$[ebp]
  0005b	89 85 30 ff ff
	ff		 mov	 DWORD PTR _vciCodecMblk$[ebp], eax

; 336  :    STACK_ASSIGN(vciCodecMblk->pScratchBlk);
; 337  : 
; 338  :    pDecMemBlk= (DEC_MEM_BLK *)vciCodecMblk->hCodecMblk;

  00061	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00067	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0006a	89 95 38 ff ff
	ff		 mov	 DWORD PTR _pDecMemBlk$[ebp], edx

; 339  : 
; 340  :    vciCodecMblk->pVciCodecIOBlock=pvciCodecIOBlk;

  00070	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00076	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00079	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 341  : 
; 342  :    /*----------------------------------------------------
; 343  :      check the validity of the VCI IO Block.
; 344  :    ----------------------------------------------------*/
; 345  :    if (SILENCE != GetCurrentFrameStateSC(pDecMemBlk->pFadeIOMemBlk))

  0007c	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00082	8b 02		 mov	 eax, DWORD PTR [edx]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _GetCurrentFrameStateSC@4
  0008a	85 c0		 test	 eax, eax
  0008c	0f 84 3e 02 00
	00		 je	 $L2355

; 346  :    {
; 347  : 	   VCI_IO_BLK_PARAM_CHECK(pvciCodecIOBlk);

  00092	83 7d 0c 00	 cmp	 DWORD PTR _pvciCodecIOBlk$[ebp], 0
  00096	75 09		 jne	 SHORT $L2356
  00098	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  0009c	e9 db 02 00 00	 jmp	 $L2338
$L2356:
  000a1	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000a4	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000a8	75 09		 jne	 SHORT $L2357
  000aa	66 b8 f2 17	 mov	 ax, 6130		; 000017f2H
  000ae	e9 c9 02 00 00	 jmp	 $L2338
$L2357:
  000b3	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000b6	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000b9	75 09		 jne	 SHORT $L2358
  000bb	66 b8 ed 17	 mov	 ax, 6125		; 000017edH
  000bf	e9 b8 02 00 00	 jmp	 $L2338
$L2358:
  000c4	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  000c7	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  000cb	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000ce	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  000d2	3b c8		 cmp	 ecx, eax
  000d4	7c 09		 jl	 SHORT $L2359
  000d6	66 b8 01 18	 mov	 ax, 6145		; 00001801H
  000da	e9 9d 02 00 00	 jmp	 $L2338
$L2359:
  000df	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000e2	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  000e6	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  000e9	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  000ed	3b d1		 cmp	 edx, ecx
  000ef	7c 09		 jl	 SHORT $L2360
  000f1	66 b8 06 18	 mov	 ax, 6150		; 00001806H
  000f5	e9 82 02 00 00	 jmp	 $L2338
$L2360:
  000fa	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  000fd	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  00101	83 f8 07	 cmp	 eax, 7
  00104	7e 09		 jle	 SHORT $L2361
  00106	66 b8 f7 17	 mov	 ax, 6135		; 000017f7H
  0010a	e9 6d 02 00 00	 jmp	 $L2338
$L2361:
  0010f	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00112	0f b6 51 14	 movzx	 edx, BYTE PTR [ecx+20]
  00116	83 fa 07	 cmp	 edx, 7
  00119	7e 09		 jle	 SHORT $L2362
  0011b	66 b8 fc 17	 mov	 ax, 6140		; 000017fcH
  0011f	e9 58 02 00 00	 jmp	 $L2338
$L2362:

; 348  : 
; 349  : 		/*----------------------------------------------------
; 350  : 			 If the decoder needs a new frame to decode then
; 351  : 			   get the new frame from pvciCodecIOBlk->pVoxBuffer
; 352  : 			   and put it in vciCodecMblk->pbSaveVoxBuffer.
; 353  : 		   ----------------------------------------------------*/
; 354  : 		   if (voxGetDecReqDataFlagSC((void *)pDecMemBlk))

  00124	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _voxGetDecReqDataFlagSC@4
  00130	0f b6 c8	 movzx	 ecx, al
  00133	85 c9		 test	 ecx, ecx
  00135	74 38		 je	 SHORT $L2364

; 355  : 		   {
; 356  : 			/*------------------------------------------------------------
; 357  : 			  Check whether there are sufficient Vox data. If there is not,
; 358  : 				return an error.  In the code below we will assume there
; 359  : 				is enough data.
; 360  : 			  ------------------------------------------------------------*/
; 361  : 			  VoxErrRet = vciSeekForwardSC(pDecodeMemBlk, pvciCodecIOBlk,
; 362  : 										   1, &sByteOffset, &cBitOffset);

  00137	8d 55 ff	 lea	 edx, DWORD PTR _cBitOffset$[ebp]
  0013a	52		 push	 edx
  0013b	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _sByteOffset$[ebp]
  00141	50		 push	 eax
  00142	6a 01		 push	 1
  00144	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00147	51		 push	 ecx
  00148	8b 55 08	 mov	 edx, DWORD PTR _pDecodeMemBlk$[ebp]
  0014b	52		 push	 edx
  0014c	e8 00 00 00 00	 call	 _vciSeekForwardSC@20
  00151	66 89 85 28 ff
	ff ff		 mov	 WORD PTR _VoxErrRet$[ebp], ax

; 363  : 
; 364  : 			  if (VoxErrRet != VCI_NO_ERROR)

  00158	0f b7 85 28 ff
	ff ff		 movzx	 eax, WORD PTR _VoxErrRet$[ebp]
  0015f	85 c0		 test	 eax, eax
  00161	74 0c		 je	 SHORT $L2364

; 365  : 				 return VoxErrRet;

  00163	66 8b 85 28 ff
	ff ff		 mov	 ax, WORD PTR _VoxErrRet$[ebp]
  0016a	e9 0d 02 00 00	 jmp	 $L2338
$L2364:

; 366  : 		   }
; 367  : 
; 368  : 		   /*------------------------------------------------------------
; 369  : 			 Unpack and unquantize the frame.  QuanMemBlk is declared
; 370  : 			   only in this local region to save memory.
; 371  : 		   ------------------------------------------------------------*/
; 372  : 		   {
; 373  : 			 int QuanSC3Index[TOTAL_SC3_QUAN_INDICES];
; 374  : 			 int QuanSC6Index[EXTRA_SC6_QUAN_INDICES];
; 375  : 			 sByteOffset = 0;

  0016f	66 c7 85 2c ff
	ff ff 00 00	 mov	 WORD PTR _sByteOffset$[ebp], 0

; 376  : 			 cBitOffset = 0;

  00178	c6 45 ff 00	 mov	 BYTE PTR _cBitOffset$[ebp], 0

; 377  : 
; 378  : 			 /*---------------------------------------------------------
; 379  : 			   Copy the SC3 bits from the circular buffer to the 
; 380  : 				 linear buffer.
; 381  : 			 ---------------------------------------------------------*/
; 382  : 			 if (voxGetDecReqDataFlagSC((void *)pDecMemBlk))

  0017c	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00182	51		 push	 ecx
  00183	e8 00 00 00 00	 call	 _voxGetDecReqDataFlagSC@4
  00188	0f b6 d0	 movzx	 edx, al
  0018b	85 d2		 test	 edx, edx
  0018d	74 2e		 je	 SHORT $L2369

; 383  : 			   copyCBuf2LBuf(pvciCodecIOBlk->pVoxBuffer, 
; 384  : 							 &(pvciCodecIOBlk->wVoxBufferReadByteOffset),
; 385  : 							 &(pvciCodecIOBlk->chVoxBufferReadBitOffset), 
; 386  : 							 pvciCodecIOBlk->wVoxBufferSize, 
; 387  : 							 TOTAL_BITS_SC3,
; 388  : 							 pDecMemBlk->pbSaveVoxBuffer);

  0018f	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  00195	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00198	51		 push	 ecx
  00199	6a 40		 push	 64			; 00000040H
  0019b	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0019e	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  001a2	50		 push	 eax
  001a3	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  001a6	83 c1 10	 add	 ecx, 16			; 00000010H
  001a9	51		 push	 ecx
  001aa	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  001ad	83 c2 0e	 add	 edx, 14			; 0000000eH
  001b0	52		 push	 edx
  001b1	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  001b4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001b7	51		 push	 ecx
  001b8	e8 00 00 00 00	 call	 _copyCBuf2LBuf@24
$L2369:

; 389  : 
; 390  : 			 /*---------------------------------------------------------
; 391  : 			   Unpack and unquantize SC3 data.
; 392  : 			 ---------------------------------------------------------*/
; 393  : 			 VoxUnPackSC3(QuanSC3Index,
; 394  : 						  pDecMemBlk->pbSaveVoxBuffer,
; 395  : 						  &sByteOffset,
; 396  : 						  &cBitOffset,
; 397  : 						  (TOTAL_BYTES_SC3+ADDITIONAL_BYTES_SC6),
; 398  : 						  &sLongerFrameFlag);

  001bd	8d 95 34 ff ff
	ff		 lea	 edx, DWORD PTR _sLongerFrameFlag$[ebp]
  001c3	52		 push	 edx
  001c4	6a 10		 push	 16			; 00000010H
  001c6	8d 45 ff	 lea	 eax, DWORD PTR _cBitOffset$[ebp]
  001c9	50		 push	 eax
  001ca	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _sByteOffset$[ebp]
  001d0	51		 push	 ecx
  001d1	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  001d7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001da	50		 push	 eax
  001db	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _QuanSC3Index$2366[ebp]
  001e1	51		 push	 ecx
  001e2	e8 00 00 00 00	 call	 _VoxUnPackSC3@24

; 399  : 
; 400  : 			 VoxUnQuantSC3(STACK_S QuanSC3Index, (void *)pDecMemBlk, &ParamMblk);

  001e7	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR _ParamMblk$[ebp]
  001ed	52		 push	 edx
  001ee	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  001f4	50		 push	 eax
  001f5	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _QuanSC3Index$2366[ebp]
  001fb	51		 push	 ecx
  001fc	e8 00 00 00 00	 call	 _VoxUnQuantSC3@12

; 401  : 
; 402  : 			 /*---------------------------------------------------------
; 403  : 			   if sLongerFrameFlag==END_OF_FRAME then decode using
; 404  : 				 SC_RATE_3K, otherwise continue unpacking.
; 405  : 			 ---------------------------------------------------------*/
; 406  : 			 if (sLongerFrameFlag==END_OF_FRAME)

  00201	0f b7 95 34 ff
	ff ff		 movzx	 edx, WORD PTR _sLongerFrameFlag$[ebp]
  00208	85 d2		 test	 edx, edx
  0020a	75 23		 jne	 SHORT $L2371

; 407  : 			 {
; 408  : 				if(voxSetDecodeSC((void *)pDecMemBlk, SC_RATE_3K)) /* set decoder rate to SC3 */

  0020c	6a 01		 push	 1
  0020e	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  00214	50		 push	 eax
  00215	e8 00 00 00 00	 call	 _voxSetDecodeSC@8
  0021a	0f b7 c8	 movzx	 ecx, ax
  0021d	85 c9		 test	 ecx, ecx
  0021f	74 09		 je	 SHORT $L2373

; 409  : 				   return VCI_CODEC_NOT_SUPPORTED;

  00221	66 b8 64 19	 mov	 ax, 6500		; 00001964H
  00225	e9 52 01 00 00	 jmp	 $L2338
$L2373:

; 410  : 			 } else {

  0022a	e9 9f 00 00 00	 jmp	 $L2374
$L2371:

; 411  : 				if(voxSetDecodeSC((void *)pDecMemBlk, SC_RATE_6K)) /* set decoder rate to SC6 */

  0022f	6a 02		 push	 2
  00231	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00237	52		 push	 edx
  00238	e8 00 00 00 00	 call	 _voxSetDecodeSC@8
  0023d	0f b7 c0	 movzx	 eax, ax
  00240	85 c0		 test	 eax, eax
  00242	74 09		 je	 SHORT $L2376

; 412  : 				   return VCI_CODEC_NOT_SUPPORTED;

  00244	66 b8 64 19	 mov	 ax, 6500		; 00001964H
  00248	e9 2f 01 00 00	 jmp	 $L2338
$L2376:

; 413  : 
; 414  : 				/*---------------------------------------------------------
; 415  : 				  Copy the additional SC6 bits from the circular buffer 
; 416  : 					to the linear buffer.  
; 417  : 
; 418  : 				  NOTE: We had to unpack the SC3 bits before we could find 
; 419  : 					out if there are additional SC6 bits.
; 420  : 				---------------------------------------------------------*/
; 421  : 				if (voxGetDecReqDataFlagSC((void *)pDecMemBlk))

  0024d	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00253	51		 push	 ecx
  00254	e8 00 00 00 00	 call	 _voxGetDecReqDataFlagSC@4
  00259	0f b6 d0	 movzx	 edx, al
  0025c	85 d2		 test	 edx, edx
  0025e	74 31		 je	 SHORT $L2378

; 422  : 				   copyCBuf2LBuf(pvciCodecIOBlk->pVoxBuffer, 
; 423  : 								 &(pvciCodecIOBlk->wVoxBufferReadByteOffset),
; 424  : 								 &(pvciCodecIOBlk->chVoxBufferReadBitOffset), 
; 425  : 								 pvciCodecIOBlk->wVoxBufferSize, ADDITIONAL_BITS_SC6,
; 426  : 								 &(pDecMemBlk->pbSaveVoxBuffer[(TOTAL_BITS_SC3)>>3]));

  00260	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  00266	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00269	83 c1 08	 add	 ecx, 8
  0026c	51		 push	 ecx
  0026d	6a 40		 push	 64			; 00000040H
  0026f	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00272	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  00276	50		 push	 eax
  00277	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0027a	83 c1 10	 add	 ecx, 16			; 00000010H
  0027d	51		 push	 ecx
  0027e	8b 55 0c	 mov	 edx, DWORD PTR _pvciCodecIOBlk$[ebp]
  00281	83 c2 0e	 add	 edx, 14			; 0000000eH
  00284	52		 push	 edx
  00285	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00288	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0028b	51		 push	 ecx
  0028c	e8 00 00 00 00	 call	 _copyCBuf2LBuf@24
$L2378:

; 427  : 
; 428  : 				/*---------------------------------------------------------
; 429  : 				  Unpack and unquantize SC6 data.
; 430  : 				---------------------------------------------------------*/
; 431  : 				VoxUnPackSC6(QuanSC6Index,
; 432  : 							 pDecMemBlk->pbSaveVoxBuffer,
; 433  : 							 &sByteOffset,
; 434  : 							 &cBitOffset,
; 435  : 							 (TOTAL_BYTES_SC3+ADDITIONAL_BYTES_SC6),
; 436  : 							 &sLongerFrameFlag);

  00291	8d 95 34 ff ff
	ff		 lea	 edx, DWORD PTR _sLongerFrameFlag$[ebp]
  00297	52		 push	 edx
  00298	6a 10		 push	 16			; 00000010H
  0029a	8d 45 ff	 lea	 eax, DWORD PTR _cBitOffset$[ebp]
  0029d	50		 push	 eax
  0029e	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _sByteOffset$[ebp]
  002a4	51		 push	 ecx
  002a5	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  002ab	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002ae	50		 push	 eax
  002af	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _QuanSC6Index$2367[ebp]
  002b5	51		 push	 ecx
  002b6	e8 00 00 00 00	 call	 _VoxUnPackSC6@24

; 437  : 
; 438  : 			   VoxUnQuantSC6(QuanSC6Index, &ParamMblk);

  002bb	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR _ParamMblk$[ebp]
  002c1	52		 push	 edx
  002c2	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _QuanSC6Index$2367[ebp]
  002c8	50		 push	 eax
  002c9	e8 00 00 00 00	 call	 _VoxUnQuantSC6@8
$L2374:

; 439  : 			 }
; 440  : 		   }
; 441  :    }
; 442  :    else

  002ce	eb 20		 jmp	 SHORT $L2379
$L2355:

; 443  :    {
; 444  : 	   VCI_SIL_IO_BLK_PARAM_CHECK_DEC(pvciCodecIOBlk);

  002d0	83 7d 0c 00	 cmp	 DWORD PTR _pvciCodecIOBlk$[ebp], 0
  002d4	75 09		 jne	 SHORT $L2380
  002d6	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  002da	e9 9d 00 00 00	 jmp	 $L2338
$L2380:
  002df	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  002e2	83 39 00	 cmp	 DWORD PTR [ecx], 0
  002e5	75 09		 jne	 SHORT $L2379
  002e7	66 b8 ed 17	 mov	 ax, 6125		; 000017edH
  002eb	e9 8c 00 00 00	 jmp	 $L2338
$L2379:

; 445  :    }
; 446  : 
; 447  :    
; 448  :    /*---------------------------------------------------------
; 449  :      Call the fade routine to modify parameters if there
; 450  :        has benn a fade.
; 451  :    ---------------------------------------------------------*/
; 452  :    VoxFadeSC(pDecMemBlk->pFadeIOMemBlk, &ParamMblk);

  002f0	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR _ParamMblk$[ebp]
  002f6	52		 push	 edx
  002f7	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  002fd	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ff	51		 push	 ecx
  00300	e8 00 00 00 00	 call	 _VoxFadeSC@8

; 453  : 
; 454  :    /*---------------------------------------------------------
; 455  :      If the Fade state is SILENCE then set the decoder to
; 456  :        SC3 because the fade routine does not generate
; 457  :        measured phase parameters.
; 458  :    ---------------------------------------------------------*/
; 459  :    if (GetCurrentFrameStateSC(pDecMemBlk->pFadeIOMemBlk) == SILENCE)

  00305	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  0030b	8b 02		 mov	 eax, DWORD PTR [edx]
  0030d	50		 push	 eax
  0030e	e8 00 00 00 00	 call	 _GetCurrentFrameStateSC@4
  00313	85 c0		 test	 eax, eax
  00315	75 1b		 jne	 SHORT $L2382

; 460  :      {
; 461  :        if(voxSetDecodeSC((void *)pDecMemBlk, SC_RATE_3K))

  00317	6a 01		 push	 1
  00319	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  0031f	51		 push	 ecx
  00320	e8 00 00 00 00	 call	 _voxSetDecodeSC@8
  00325	0f b7 d0	 movzx	 edx, ax
  00328	85 d2		 test	 edx, edx
  0032a	74 06		 je	 SHORT $L2382

; 462  :           return VCI_CODEC_NOT_SUPPORTED;

  0032c	66 b8 64 19	 mov	 ax, 6500		; 00001964H
  00330	eb 4a		 jmp	 SHORT $L2338
$L2382:

; 463  :      }
; 464  : 
; 465  :    /*---------------------------------------------------------
; 466  :      Decode the parameters.
; 467  :    ---------------------------------------------------------*/
; 468  :    VoxDecodeSC(STACK_S (void *)pDecMemBlk, &ParamMblk, pvciCodecIOBlk->pPCMBuffer, 
; 469  :                &(pvciCodecIOBlk->wSamplesInPCMBuffer) );

  00332	8b 45 0c	 mov	 eax, DWORD PTR _pvciCodecIOBlk$[ebp]
  00335	83 c0 04	 add	 eax, 4
  00338	50		 push	 eax
  00339	8b 4d 0c	 mov	 ecx, DWORD PTR _pvciCodecIOBlk$[ebp]
  0033c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0033e	52		 push	 edx
  0033f	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _ParamMblk$[ebp]
  00345	50		 push	 eax
  00346	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  0034c	51		 push	 ecx
  0034d	e8 00 00 00 00	 call	 _VoxDecodeSC@16

; 470  : 
; 471  :    /*---------------------------------------------------------
; 472  :      Update the fade block for the case when the decoder
; 473  :        is not yet finished with the current frame.
; 474  :    ---------------------------------------------------------*/
; 475  :    cDecReqDataFlagSC = voxGetDecReqDataFlagSC((void *)pDecMemBlk);

  00352	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00358	52		 push	 edx
  00359	e8 00 00 00 00	 call	 _voxGetDecReqDataFlagSC@4
  0035e	88 85 3f ff ff
	ff		 mov	 BYTE PTR _cDecReqDataFlagSC$[ebp], al

; 476  :    UpdateFadeStateSC( pDecMemBlk->pFadeIOMemBlk, cDecReqDataFlagSC );

  00364	8a 85 3f ff ff
	ff		 mov	 al, BYTE PTR _cDecReqDataFlagSC$[ebp]
  0036a	50		 push	 eax
  0036b	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00371	8b 11		 mov	 edx, DWORD PTR [ecx]
  00373	52		 push	 edx
  00374	e8 00 00 00 00	 call	 _UpdateFadeStateSC@8

; 477  : 
; 478  :    return(VCI_NO_ERROR);

  00379	66 33 c0	 xor	 ax, ax
$L2338:

; 479  : }

  0037c	8b e5		 mov	 esp, ebp
  0037e	5d		 pop	 ebp
  0037f	c2 08 00	 ret	 8
_vciDecodeSC6@8 ENDP
_TEXT	ENDS
PUBLIC	_vciInitEncodeSC6@4
PUBLIC	_vciFreeEncodeSC6@4
PUBLIC	??_C@_0N@KGCNFMNN@frame?5length?$AA@		; `string'
PUBLIC	??_C@_04HCCHHEEF@rate?$AA@			; `string'
EXTRN	_calloc:NEAR
EXTRN	_vemInit@0:NEAR
EXTRN	_vemRegisterConstShort@12:NEAR
EXTRN	_VoxInitEncodeSC3@8:NEAR
EXTRN	_VoxInitEncodeSC6@4:NEAR
;	COMDAT ??_C@_0N@KGCNFMNN@frame?5length?$AA@
CONST	SEGMENT
??_C@_0N@KGCNFMNN@frame?5length?$AA@ DB 'frame length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCCHHEEF@rate?$AA@
CONST	SEGMENT
??_C@_04HCCHHEEF@rate?$AA@ DB 'rate', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _vciInitEncodeSC6@4
_TEXT	SEGMENT
_vciCodecMblk$ = -4
_hEncodeMemBlk$ = 8
_vciInitEncodeSC6@4 PROC NEAR				; COMDAT

; 513  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 514  :    VCI_CODEC_BLOCK *vciCodecMblk=NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 515  :    STACK_DECLARE
; 516  : 
; 517  :    if(!hEncodeMemBlk)

  0000b	83 7d 08 00	 cmp	 DWORD PTR _hEncodeMemBlk$[ebp], 0
  0000f	75 09		 jne	 SHORT $L2392

; 518  :       return VCI_NULL_ARG;

  00011	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  00015	e9 0d 01 00 00	 jmp	 $L2389
$L2392:

; 519  : 
; 520  :    if(VOX_MEM_INIT(vciCodecMblk=*hEncodeMemBlk,1,sizeof(VCI_CODEC_BLOCK))) 

  0001a	6a 2c		 push	 44			; 0000002cH
  0001c	6a 01		 push	 1
  0001e	e8 00 00 00 00	 call	 _calloc
  00023	83 c4 08	 add	 esp, 8
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _hEncodeMemBlk$[ebp]
  00029	89 01		 mov	 DWORD PTR [ecx], eax
  0002b	8b 55 08	 mov	 edx, DWORD PTR _hEncodeMemBlk$[ebp]
  0002e	8b 02		 mov	 eax, DWORD PTR [edx]
  00030	89 45 fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax
  00033	83 7d fc 00	 cmp	 DWORD PTR _vciCodecMblk$[ebp], 0
  00037	75 09		 jne	 SHORT $L2394

; 521  :      return VCI_FAILED_MEM_ALLOC;

  00039	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  0003d	e9 e5 00 00 00	 jmp	 $L2389
$L2394:

; 522  : 
; 523  :    vciCodecMblk->chEncOrDec = ENCODE_ID;

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00045	c6 41 0c 0a	 mov	 BYTE PTR [ecx+12], 10	; 0000000aH

; 524  :    vciCodecMblk->dwVciChunkID = SANITY_CHECK;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0004c	c7 02 ce fa 00
	00		 mov	 DWORD PTR [edx], 64206	; 0000faceH

; 525  : 
; 526  :    if(STACK_SET(vciCodecMblk->pScratchBlk,20480)) {

  00052	33 c0		 xor	 eax, eax
  00054	85 c0		 test	 eax, eax
  00056	74 12		 je	 SHORT $L2395

; 527  :       vciFreeEncodeSC6(hEncodeMemBlk);

  00058	8b 4d 08	 mov	 ecx, DWORD PTR _hEncodeMemBlk$[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _vciFreeEncodeSC6@4

; 528  :       return VCI_FAILED_MEM_ALLOC;

  00061	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  00065	e9 bd 00 00 00	 jmp	 $L2389
$L2395:

; 529  :    }
; 530  : 
; 531  :    if(!(vciCodecMblk->pvemMemBlk=vemInit())) {

  0006a	e8 00 00 00 00	 call	 _vemInit@0
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00072	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00075	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00078	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0007c	75 12		 jne	 SHORT $L2396

; 532  : #if VEM_DEFINED == 1
; 533  :       vciFreeEncodeSC6(hEncodeMemBlk);

  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _hEncodeMemBlk$[ebp]
  00081	51		 push	 ecx
  00082	e8 00 00 00 00	 call	 _vciFreeEncodeSC6@4

; 534  :       return VCI_FAILED_MEM_ALLOC; 

  00087	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  0008b	e9 97 00 00 00	 jmp	 $L2389
$L2396:

; 535  : #endif
; 536  :    } else {
; 537  :       vemRegisterConstShort(GET_VEM_MEMORY_HANDLE(vciCodecMblk), (short)FRAME_LENGTH_SC, "frame length");

  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@KGCNFMNN@frame?5length?$AA@
  00095	68 a0 00 00 00	 push	 160			; 000000a0H
  0009a	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0009d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 _vemRegisterConstShort@12

; 538  :       vemRegisterConstShort(GET_VEM_MEMORY_HANDLE(vciCodecMblk), (short)RATE8K, "rate");

  000a8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04HCCHHEEF@rate?$AA@
  000ad	68 40 1f 00 00	 push	 8000			; 00001f40H
  000b2	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000b5	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _vemRegisterConstShort@12

; 539  :    }
; 540  : 
; 541  :    if(VoxInitEncodeSC3(&vciCodecMblk->hCodecMblk,vciCodecMblk->pvemMemBlk)) {

  000c0	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000c3	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000c6	50		 push	 eax
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000ca	83 c1 10	 add	 ecx, 16			; 00000010H
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 _VoxInitEncodeSC3@8
  000d3	0f b7 d0	 movzx	 edx, ax
  000d6	85 d2		 test	 edx, edx
  000d8	74 0f		 je	 SHORT $L2406

; 542  :       vciFreeEncodeSC6(hEncodeMemBlk);

  000da	8b 45 08	 mov	 eax, DWORD PTR _hEncodeMemBlk$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _vciFreeEncodeSC6@4

; 543  :       return VCI_FAILED_MEM_ALLOC;

  000e3	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  000e7	eb 3e		 jmp	 SHORT $L2389
$L2406:

; 544  :    }
; 545  :  
; 546  :    if(VoxInitEncodeSC6(&vciCodecMblk->hCodecMblk)) {

  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  000ec	83 c1 10	 add	 ecx, 16			; 00000010H
  000ef	51		 push	 ecx
  000f0	e8 00 00 00 00	 call	 _VoxInitEncodeSC6@4
  000f5	0f b7 d0	 movzx	 edx, ax
  000f8	85 d2		 test	 edx, edx
  000fa	74 0f		 je	 SHORT $L2407

; 547  :       vciFreeEncodeSC6(hEncodeMemBlk);

  000fc	8b 45 08	 mov	 eax, DWORD PTR _hEncodeMemBlk$[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _vciFreeEncodeSC6@4

; 548  :       return VCI_FAILED_MEM_ALLOC;

  00105	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  00109	eb 1c		 jmp	 SHORT $L2389
$L2407:

; 549  :    } 
; 550  :  
; 551  :    if(initMethodStruct(&vciCodecMblk->pVciMethodStruct))

  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  0010e	83 c1 24	 add	 ecx, 36			; 00000024H
  00111	51		 push	 ecx
  00112	e8 00 00 00 00	 call	 _initMethodStruct@4
  00117	0f b7 d0	 movzx	 edx, ax
  0011a	85 d2		 test	 edx, edx
  0011c	74 06		 je	 SHORT $L2408

; 552  :       return VCI_FAILED_MEM_ALLOC;

  0011e	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  00122	eb 03		 jmp	 SHORT $L2389
$L2408:

; 553  :  
; 554  :    return VCI_NO_ERROR;

  00124	66 33 c0	 xor	 ax, ax
$L2389:

; 555  : }

  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c2 04 00	 ret	 4
_vciInitEncodeSC6@4 ENDP
_TEXT	ENDS
PUBLIC	_vciInitDecodeSC6@4
PUBLIC	_vciFreeDecodeSC6@4
EXTRN	_VoxinitFadeSC@4:NEAR
EXTRN	_VoxInitDecodeSC3@4:NEAR
EXTRN	_VoxInitDecodeSC6@4:NEAR
; Function compile flags: /Odt
;	COMDAT _vciInitDecodeSC6@4
_TEXT	SEGMENT
_vciCodecMblk$ = -8
_pDecMemBlk$ = -4
_hDecodeMemBlk$ = 8
_vciInitDecodeSC6@4 PROC NEAR				; COMDAT

; 588  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 589  :    VCI_CODEC_BLOCK *vciCodecMblk=NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 590  :    DEC_MEM_BLK *pDecMemBlk;   
; 591  : 
; 592  :    STACK_DECLARE
; 593  : 
; 594  :    if(!hDecodeMemBlk)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _hDecodeMemBlk$[ebp], 0
  00011	75 09		 jne	 SHORT $L2415

; 595  :       return VCI_NULL_ARG;

  00013	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  00017	e9 22 01 00 00	 jmp	 $L2411
$L2415:

; 596  : 
; 597  :    if(VOX_MEM_INIT(vciCodecMblk=*hDecodeMemBlk,1,sizeof(VCI_CODEC_BLOCK))) 

  0001c	6a 2c		 push	 44			; 0000002cH
  0001e	6a 01		 push	 1
  00020	e8 00 00 00 00	 call	 _calloc
  00025	83 c4 08	 add	 esp, 8
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _hDecodeMemBlk$[ebp]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax
  0002d	8b 55 08	 mov	 edx, DWORD PTR _hDecodeMemBlk$[ebp]
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	89 45 f8	 mov	 DWORD PTR _vciCodecMblk$[ebp], eax
  00035	83 7d f8 00	 cmp	 DWORD PTR _vciCodecMblk$[ebp], 0
  00039	75 09		 jne	 SHORT $L2417

; 598  :       return VCI_FAILED_MEM_ALLOC;

  0003b	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  0003f	e9 fa 00 00 00	 jmp	 $L2411
$L2417:

; 599  : 
; 600  :    vciCodecMblk->chEncOrDec = DECODE_ID;

  00044	8b 4d f8	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00047	c6 41 0c 0b	 mov	 BYTE PTR [ecx+12], 11	; 0000000bH

; 601  :    vciCodecMblk->dwVciChunkID = SANITY_CHECK;

  0004b	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0004e	c7 02 ce fa 00
	00		 mov	 DWORD PTR [edx], 64206	; 0000faceH

; 602  : 
; 603  :    if(STACK_SET(vciCodecMblk->pScratchBlk,20240)) {

  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	74 12		 je	 SHORT $L2418

; 604  :       vciFreeDecodeSC6(hDecodeMemBlk);

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _hDecodeMemBlk$[ebp]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 _vciFreeDecodeSC6@4

; 605  :       return VCI_FAILED_MEM_ALLOC;

  00063	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  00067	e9 d2 00 00 00	 jmp	 $L2411
$L2418:

; 606  :    } 
; 607  : 
; 608  :    if(!(vciCodecMblk->pvemMemBlk=vemInit())) {

  0006c	e8 00 00 00 00	 call	 _vemInit@0
  00071	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00074	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00077	8b 45 f8	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  0007a	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0007e	75 12		 jne	 SHORT $L2419

; 609  : #if VEM_DEFINED == 1
; 610  :       vciFreeDecodeSC6(hDecodeMemBlk);

  00080	8b 4d 08	 mov	 ecx, DWORD PTR _hDecodeMemBlk$[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 _vciFreeDecodeSC6@4

; 611  :       return VCI_FAILED_MEM_ALLOC;

  00089	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  0008d	e9 ac 00 00 00	 jmp	 $L2411
$L2419:

; 612  : #endif
; 613  :    }
; 614  : 
; 615  :    if(VoxInitDecodeSC3(&vciCodecMblk->hCodecMblk)) {

  00092	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00095	83 c2 10	 add	 edx, 16			; 00000010H
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 _VoxInitDecodeSC3@4
  0009e	0f b7 c0	 movzx	 eax, ax
  000a1	85 c0		 test	 eax, eax
  000a3	74 12		 je	 SHORT $L2420

; 616  :       vciFreeDecodeSC6(hDecodeMemBlk);

  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _hDecodeMemBlk$[ebp]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 _vciFreeDecodeSC6@4

; 617  :       return VCI_FAILED_MEM_ALLOC;

  000ae	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  000b2	e9 87 00 00 00	 jmp	 $L2411
$L2420:

; 618  :    } 
; 619  :  
; 620  :    if(VoxInitDecodeSC6(&vciCodecMblk->hCodecMblk)) {

  000b7	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000ba	83 c2 10	 add	 edx, 16			; 00000010H
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _VoxInitDecodeSC6@4
  000c3	0f b7 c0	 movzx	 eax, ax
  000c6	85 c0		 test	 eax, eax
  000c8	74 0f		 je	 SHORT $L2421

; 621  :       vciFreeDecodeSC6(hDecodeMemBlk);

  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _hDecodeMemBlk$[ebp]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 _vciFreeDecodeSC6@4

; 622  :       return VCI_FAILED_MEM_ALLOC;

  000d3	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  000d7	eb 65		 jmp	 SHORT $L2411
$L2421:

; 623  :    } 
; 624  :    
; 625  :    pDecMemBlk = (DEC_MEM_BLK *)(vciCodecMblk->hCodecMblk);

  000d9	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000dc	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000df	89 45 fc	 mov	 DWORD PTR _pDecMemBlk$[ebp], eax

; 626  : 
; 627  :    if(VoxinitFadeSC(&pDecMemBlk->pFadeIOMemBlk)) {

  000e2	8b 4d fc	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  000e5	51		 push	 ecx
  000e6	e8 00 00 00 00	 call	 _VoxinitFadeSC@4
  000eb	0f b7 d0	 movzx	 edx, ax
  000ee	85 d2		 test	 edx, edx
  000f0	74 0f		 je	 SHORT $L2423

; 628  :       vciFreeDecodeSC6(hDecodeMemBlk);

  000f2	8b 45 08	 mov	 eax, DWORD PTR _hDecodeMemBlk$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _vciFreeDecodeSC6@4

; 629  :       return VCI_FAILED_MEM_ALLOC;

  000fb	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  000ff	eb 3d		 jmp	 SHORT $L2411
$L2423:

; 630  :    }
; 631  :    
; 632  :    if (VOX_MEM_INIT(pDecMemBlk->pbSaveVoxBuffer, 
; 633  :                     TOTAL_BYTES_SC3+ADDITIONAL_BYTES_SC6,
; 634  :                     sizeof(unsigned char *)))

  00101	6a 04		 push	 4
  00103	6a 10		 push	 16			; 00000010H
  00105	e8 00 00 00 00	 call	 _calloc
  0010a	83 c4 08	 add	 esp, 8
  0010d	8b 4d fc	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00110	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00113	8b 55 fc	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00116	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0011a	75 06		 jne	 SHORT $L2425

; 635  :      return VCI_FAILED_MEM_ALLOC;

  0011c	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  00120	eb 1c		 jmp	 SHORT $L2411
$L2425:

; 636  : 
; 637  :    if(initMethodStruct(&vciCodecMblk->pVciMethodStruct))

  00122	8b 45 f8	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00125	83 c0 24	 add	 eax, 36			; 00000024H
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _initMethodStruct@4
  0012e	0f b7 c8	 movzx	 ecx, ax
  00131	85 c9		 test	 ecx, ecx
  00133	74 06		 je	 SHORT $L2426

; 638  :       return VCI_FAILED_MEM_ALLOC;

  00135	66 b8 70 17	 mov	 ax, 6000		; 00001770H
  00139	eb 03		 jmp	 SHORT $L2411
$L2426:

; 639  : 
; 640  :    return VCI_NO_ERROR;

  0013b	66 33 c0	 xor	 ax, ax
$L2411:

; 641  : }

  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c2 04 00	 ret	 4
_vciInitDecodeSC6@4 ENDP
_TEXT	ENDS
EXTRN	_free:NEAR
EXTRN	_vemFree@4:NEAR
EXTRN	_VoxFreeEncodeSC3@4:NEAR
EXTRN	_VoxFreeEncodeSC6@4:NEAR
; Function compile flags: /Odt
;	COMDAT _vciFreeEncodeSC6@4
_TEXT	SEGMENT
_vciCodecMblk$ = -4
_hEncodeMemBlk$ = 8
_vciFreeEncodeSC6@4 PROC NEAR				; COMDAT

; 674  : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 675  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 676  : 
; 677  :    if(!hEncodeMemBlk)

  0000b	83 7d 08 00	 cmp	 DWORD PTR _hEncodeMemBlk$[ebp], 0
  0000f	75 09		 jne	 SHORT $L2432

; 678  :       return VCI_NULL_ARG;

  00011	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  00015	e9 8c 00 00 00	 jmp	 $L2429
$L2432:

; 679  : 
; 680  :    /* First make sure that the handle passed is the correct one. */
; 681  :    if(!VCI_BLOCK_CHECK(*hEncodeMemBlk))

  0001a	8b 45 08	 mov	 eax, DWORD PTR _hEncodeMemBlk$[ebp]
  0001d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00020	74 0d		 je	 SHORT $L2435
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _hEncodeMemBlk$[ebp]
  00025	8b 11		 mov	 edx, DWORD PTR [ecx]
  00027	81 3a ce fa 00
	00		 cmp	 DWORD PTR [edx], 64206	; 0000faceH
  0002d	74 06		 je	 SHORT $L2434
$L2435:

; 682  :       return VCI_NOT_VCI_HANDLE;

  0002f	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00033	eb 71		 jmp	 SHORT $L2429
$L2434:

; 683  : 
; 684  :    if(!VCI_IS_ENCODE(*hEncodeMemBlk))

  00035	8b 45 08	 mov	 eax, DWORD PTR _hEncodeMemBlk$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  0003e	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00041	74 06		 je	 SHORT $L2437

; 685  :       return VCI_NOT_ENC_HANDLE;

  00043	66 b8 de 17	 mov	 ax, 6110		; 000017deH
  00047	eb 5d		 jmp	 SHORT $L2429
$L2437:

; 686  :    
; 687  :    vciCodecMblk = (VCI_CODEC_BLOCK *)*hEncodeMemBlk;

  00049	8b 45 08	 mov	 eax, DWORD PTR _hEncodeMemBlk$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	89 4d fc	 mov	 DWORD PTR _vciCodecMblk$[ebp], ecx

; 688  : 
; 689  :    vciCodecMblk->dwVciChunkID=0;

  00051	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00054	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 690  : 
; 691  :    /*--------------------------------------------
; 692  :      Must free SC6 before the free for SC3.
; 693  :        (The free for SC3 assumes that SC6 was already freed)
; 694  :    --------------------------------------------*/
; 695  :    VoxFreeEncodeSC6(&vciCodecMblk->hCodecMblk);

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  0005d	83 c0 10	 add	 eax, 16			; 00000010H
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 _VoxFreeEncodeSC6@4

; 696  :    VoxFreeEncodeSC3(&vciCodecMblk->hCodecMblk);

  00066	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00069	83 c1 10	 add	 ecx, 16			; 00000010H
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 _VoxFreeEncodeSC3@4

; 697  : 
; 698  :    vemFree(vciCodecMblk->pvemMemBlk);

  00072	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00075	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _vemFree@4

; 699  : 
; 700  :    freeMethodStruct(&vciCodecMblk->pVciMethodStruct);

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00081	83 c1 24	 add	 ecx, 36			; 00000024H
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _freeMethodStruct@4

; 701  : 
; 702  :    STACK_UNSET(vciCodecMblk->pScratchBlk)
; 703  : 
; 704  :    VOX_MEM_FREE(vciCodecMblk);

  0008a	83 7d fc 00	 cmp	 DWORD PTR _vciCodecMblk$[ebp], 0
  0008e	74 13		 je	 SHORT $L2439
  00090	8b 55 fc	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 _free
  00099	83 c4 04	 add	 esp, 4
  0009c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0
$L2439:

; 705  :       
; 706  :    return VCI_NO_ERROR;

  000a3	66 33 c0	 xor	 ax, ax
$L2429:

; 707  : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 04 00	 ret	 4
_vciFreeEncodeSC6@4 ENDP
_TEXT	ENDS
EXTRN	_VoxfreeFadeSC@4:NEAR
EXTRN	_VoxFreeDecodeSC3@4:NEAR
EXTRN	_VoxFreeDecodeSC6@4:NEAR
; Function compile flags: /Odt
;	COMDAT _vciFreeDecodeSC6@4
_TEXT	SEGMENT
_vciCodecMblk$ = -8
_pDecMemBlk$ = -4
_hDecodeMemBlk$ = 8
_vciFreeDecodeSC6@4 PROC NEAR				; COMDAT

; 739  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 740  :    VCI_CODEC_BLOCK *vciCodecMblk = NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0

; 741  :    DEC_MEM_BLK *pDecMemBlk;
; 742  : 
; 743  :    if(!hDecodeMemBlk)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _hDecodeMemBlk$[ebp], 0
  00011	75 09		 jne	 SHORT $L2447

; 744  :       return VCI_NULL_ARG;

  00013	66 b8 1a 18	 mov	 ax, 6170		; 0000181aH
  00017	e9 c6 00 00 00	 jmp	 $L2443
$L2447:

; 745  : 
; 746  :    /* First make sure that the handle passed is the correct one. */
; 747  :    if(!VCI_BLOCK_CHECK(*hDecodeMemBlk))

  0001c	8b 45 08	 mov	 eax, DWORD PTR _hDecodeMemBlk$[ebp]
  0001f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00022	74 0d		 je	 SHORT $L2450
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _hDecodeMemBlk$[ebp]
  00027	8b 11		 mov	 edx, DWORD PTR [ecx]
  00029	81 3a ce fa 00
	00		 cmp	 DWORD PTR [edx], 64206	; 0000faceH
  0002f	74 09		 je	 SHORT $L2449
$L2450:

; 748  :       return VCI_NOT_VCI_HANDLE;

  00031	66 b8 d4 17	 mov	 ax, 6100		; 000017d4H
  00035	e9 a8 00 00 00	 jmp	 $L2443
$L2449:

; 749  : 
; 750  :    if(!VCI_IS_DECODE(*hDecodeMemBlk))

  0003a	8b 45 08	 mov	 eax, DWORD PTR _hDecodeMemBlk$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00043	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00046	74 09		 je	 SHORT $L2452

; 751  :       return VCI_NOT_DEC_HANDLE;

  00048	66 b8 e3 17	 mov	 ax, 6115		; 000017e3H
  0004c	e9 91 00 00 00	 jmp	 $L2443
$L2452:

; 752  : 
; 753  :    vciCodecMblk = (VCI_CODEC_BLOCK *)*hDecodeMemBlk;

  00051	8b 45 08	 mov	 eax, DWORD PTR _hDecodeMemBlk$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	89 4d f8	 mov	 DWORD PTR _vciCodecMblk$[ebp], ecx

; 754  : 
; 755  :    vciCodecMblk->dwVciChunkID=0;

  00059	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  0005c	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 756  : 
; 757  :    pDecMemBlk = (DEC_MEM_BLK *)(vciCodecMblk->hCodecMblk);

  00062	8b 45 f8	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  00065	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00068	89 4d fc	 mov	 DWORD PTR _pDecMemBlk$[ebp], ecx

; 758  : 
; 759  :    VoxfreeFadeSC(&pDecMemBlk->pFadeIOMemBlk);

  0006b	8b 55 fc	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 _VoxfreeFadeSC@4

; 760  : 
; 761  :    VOX_MEM_FREE(pDecMemBlk->pbSaveVoxBuffer);

  00074	8b 45 fc	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  00077	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0007b	74 19		 je	 SHORT $L2455
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00080	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 _free
  00089	83 c4 04	 add	 esp, 4
  0008c	8b 45 fc	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  0008f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L2455:

; 762  : 
; 763  :    /*--------------------------------------------
; 764  :      Must free SC6 before the free for SC3.
; 765  :        (The free for SC3 assumes that SC6 was already freed)
; 766  :    --------------------------------------------*/
; 767  :    VoxFreeDecodeSC6(&vciCodecMblk->hCodecMblk);

  00096	8b 4d f8	 mov	 ecx, DWORD PTR _vciCodecMblk$[ebp]
  00099	83 c1 10	 add	 ecx, 16			; 00000010H
  0009c	51		 push	 ecx
  0009d	e8 00 00 00 00	 call	 _VoxFreeDecodeSC6@4

; 768  :    VoxFreeDecodeSC3(&vciCodecMblk->hCodecMblk);

  000a2	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000a5	83 c2 10	 add	 edx, 16			; 00000010H
  000a8	52		 push	 edx
  000a9	e8 00 00 00 00	 call	 _VoxFreeDecodeSC3@4

; 769  : 
; 770  :    vemFree(vciCodecMblk->pvemMemBlk);

  000ae	8b 45 f8	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  000b1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 _vemFree@4

; 771  : 
; 772  :    freeMethodStruct(&vciCodecMblk->pVciMethodStruct);

  000ba	8b 55 f8	 mov	 edx, DWORD PTR _vciCodecMblk$[ebp]
  000bd	83 c2 24	 add	 edx, 36			; 00000024H
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 _freeMethodStruct@4

; 773  : 
; 774  :    STACK_UNSET(vciCodecMblk->pScratchBlk)
; 775  : 
; 776  :    VOX_MEM_FREE(vciCodecMblk);

  000c6	83 7d f8 00	 cmp	 DWORD PTR _vciCodecMblk$[ebp], 0
  000ca	74 13		 je	 SHORT $L2457
  000cc	8b 45 f8	 mov	 eax, DWORD PTR _vciCodecMblk$[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 _free
  000d5	83 c4 04	 add	 esp, 4
  000d8	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _vciCodecMblk$[ebp], 0
$L2457:

; 777  : 
; 778  :   return VCI_NO_ERROR;

  000df	66 33 c0	 xor	 ax, ax
$L2443:

; 779  : }

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
_vciFreeDecodeSC6@4 ENDP
_TEXT	ENDS
PUBLIC	_vciGetExtCompatibilitySC6@4
; Function compile flags: /Odt
;	COMDAT _vciGetExtCompatibilitySC6@4
_TEXT	SEGMENT
_pCompatFunc$ = 8
_vciGetExtCompatibilitySC6@4 PROC NEAR			; COMDAT

; 812  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 813  :    *((COMPATIBILITY_FUNCTION **)pCompatFunc)=&SC6CompatibilityFunc;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pCompatFunc$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_SC6CompatibilityFunc@8

; 814  : 
; 815  :    return VCI_NO_ERROR;

  0000c	66 33 c0	 xor	 ax, ax

; 816  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
_vciGetExtCompatibilitySC6@4 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _SC6CompatibilityFunc@8
_TEXT	SEGMENT
tv65 = -8
_vem_compatibility_ID$ = -4
_VemPlugin$ = 8
_pVemCodID$ = 12
_SC6CompatibilityFunc@8 PROC NEAR			; COMDAT

; 849  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 850  :    unsigned short vem_compatibility_ID;
; 851  :    *pVemCodID=(unsigned long)VOXWARE_CODEC_SC_8K_6;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _pVemCodID$[ebp]
  00009	c7 00 06 00 00
	03		 mov	 DWORD PTR [eax], 50331654 ; 03000006H

; 852  :    
; 853  :    switch(VemPlugin) {

  0000f	0f b7 4d 08	 movzx	 ecx, WORD PTR _VemPlugin$[ebp]
  00013	89 4d f8	 mov	 DWORD PTR tv65[ebp], ecx
  00016	83 7d f8 01	 cmp	 DWORD PTR tv65[ebp], 1
  0001a	74 0e		 je	 SHORT $L2474
  0001c	83 7d f8 02	 cmp	 DWORD PTR tv65[ebp], 2
  00020	74 10		 je	 SHORT $L2476
  00022	83 7d f8 04	 cmp	 DWORD PTR tv65[ebp], 4
  00026	74 12		 je	 SHORT $L2478
  00028	eb 18		 jmp	 SHORT $L2480
$L2474:

; 854  :       case COMPATIBILITY_VFONT:
; 855  :         vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_VFONT;

  0002a	66 c7 45 fc 14
	00		 mov	 WORD PTR _vem_compatibility_ID$[ebp], 20 ; 00000014H

; 856  :         break;

  00030	eb 16		 jmp	 SHORT $L2471
$L2476:

; 857  : 
; 858  :       case COMPATIBILITY_VAD_AGC:
; 859  :         vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_VAD_AGC;

  00032	66 c7 45 fc 14
	00		 mov	 WORD PTR _vem_compatibility_ID$[ebp], 20 ; 00000014H

; 860  :         break;

  00038	eb 0e		 jmp	 SHORT $L2471
$L2478:

; 861  : 
; 862  :       case COMPATIBILITY_PLUS: 
; 863  :         vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_PLUS;

  0003a	66 c7 45 fc 14
	00		 mov	 WORD PTR _vem_compatibility_ID$[ebp], 20 ; 00000014H

; 864  :         break;

  00040	eb 06		 jmp	 SHORT $L2471
$L2480:

; 865  : 
; 866  :       default:
; 867  :         vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_DEFAULT;

  00042	66 c7 45 fc 00
	00		 mov	 WORD PTR _vem_compatibility_ID$[ebp], 0
$L2471:

; 868  :    }
; 869  : 
; 870  :    return vem_compatibility_ID;

  00048	66 8b 45 fc	 mov	 ax, WORD PTR _vem_compatibility_ID$[ebp]

; 871  : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
_SC6CompatibilityFunc@8 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _initMethodStruct@4
_TEXT	SEGMENT
_hVciMethodStruct$ = 8
_initMethodStruct@4 PROC NEAR				; COMDAT

; 904  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 905  :    if(VOX_MEM_INIT(*hVciMethodStruct,1,sizeof(VCI_METHOD_STRUCT)))

  00003	6a 1c		 push	 28			; 0000001cH
  00005	6a 01		 push	 1
  00007	e8 00 00 00 00	 call	 _calloc
  0000c	83 c4 08	 add	 esp, 8
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _hVciMethodStruct$[ebp]
  00012	89 01		 mov	 DWORD PTR [ecx], eax
  00014	8b 55 08	 mov	 edx, DWORD PTR _hVciMethodStruct$[ebp]
  00017	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0001a	75 06		 jne	 SHORT $L2486

; 906  :       return 1;

  0001c	66 b8 01 00	 mov	 ax, 1
  00020	eb 56		 jmp	 SHORT $L2484
$L2486:

; 907  : 
; 908  :    (*hVciMethodStruct)->pfVciGetInfo=vciGetInfoSC6;

  00022	8b 45 08	 mov	 eax, DWORD PTR _hVciMethodStruct$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:_vciGetInfoSC6@4

; 909  : 
; 910  : #ifndef DECODE_ONLY
; 911  :    (*hVciMethodStruct)->pfVciEncode=vciEncodeSC6;

  0002d	8b 55 08	 mov	 edx, DWORD PTR _hVciMethodStruct$[ebp]
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET FLAT:_vciEncodeSC6@8

; 912  :    (*hVciMethodStruct)->pfVciInitEncode=vciInitEncodeSC6;

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _hVciMethodStruct$[ebp]
  0003c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], OFFSET FLAT:_vciInitEncodeSC6@4

; 913  :    (*hVciMethodStruct)->pfVciFreeEncode=vciFreeEncodeSC6;

  00045	8b 45 08	 mov	 eax, DWORD PTR _hVciMethodStruct$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET FLAT:_vciFreeEncodeSC6@4

; 914  : #endif
; 915  : 
; 916  :    (*hVciMethodStruct)->pfVciDecode=vciDecodeSC6;

  00051	8b 55 08	 mov	 edx, DWORD PTR _hVciMethodStruct$[ebp]
  00054	8b 02		 mov	 eax, DWORD PTR [edx]
  00056	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET FLAT:_vciDecodeSC6@8

; 917  :    (*hVciMethodStruct)->pfVciInitDecode=vciInitDecodeSC6; 

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _hVciMethodStruct$[ebp]
  00060	8b 11		 mov	 edx, DWORD PTR [ecx]
  00062	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], OFFSET FLAT:_vciInitDecodeSC6@4

; 918  :    (*hVciMethodStruct)->pfVciFreeDecode=vciFreeDecodeSC6;

  00069	8b 45 08	 mov	 eax, DWORD PTR _hVciMethodStruct$[ebp]
  0006c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006e	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET FLAT:_vciFreeDecodeSC6@4

; 919  : 
; 920  :    return 0;

  00075	66 33 c0	 xor	 ax, ax
$L2484:

; 921  : }

  00078	5d		 pop	 ebp
  00079	c2 04 00	 ret	 4
_initMethodStruct@4 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _freeMethodStruct@4
_TEXT	SEGMENT
_hVciMethodStruct$ = 8
_freeMethodStruct@4 PROC NEAR				; COMDAT

; 952  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 953  :    if(hVciMethodStruct)

  00003	83 7d 08 00	 cmp	 DWORD PTR _hVciMethodStruct$[ebp], 0
  00007	74 1f		 je	 SHORT $L2490

; 954  :       VOX_MEM_FREE(*hVciMethodStruct);

  00009	8b 45 08	 mov	 eax, DWORD PTR _hVciMethodStruct$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 17		 je	 SHORT $L2490
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _hVciMethodStruct$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 _free
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b 45 08	 mov	 eax, DWORD PTR _hVciMethodStruct$[ebp]
  00022	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L2490:

; 955  : 
; 956  :    return 0;

  00028	66 33 c0	 xor	 ax, ax

; 957  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
_freeMethodStruct@4 ENDP
_TEXT	ENDS
END
