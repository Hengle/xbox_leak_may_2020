; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\spcbm.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DO@DDJGGNNE@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@CEMFHHGN@pvCircMblk?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@DJGACEJM@?$CIpfInBuff?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpvCircMbl@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@DCMOMPFH@pvCircMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfOutBuff?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _InitSpCBM@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _FreeSpCBM@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _PutFrameSpCBM@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GetFrameSpCBM@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CalcCircBufPosition@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_InitSpCBM@8
EXTRN	_calloc:NEAR
EXTRN	_free:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\spcbm.c
;	COMDAT _InitSpCBM@8
_TEXT	SEGMENT
_pCirc_Mblk$ = -8
_iRetFlag$ = -4
_iLength$ = 8
_pvCircMblk$ = 12
_InitSpCBM@8 PROC NEAR					; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 74   :   SP_CIRC_BUF *pCirc_Mblk;
; 75   :   unsigned short iRetFlag = 0;

  00006	66 c7 45 fc 00
	00		 mov	 WORD PTR _iRetFlag$[ebp], 0

; 76   : 
; 77   :   pCirc_Mblk = (SP_CIRC_BUF *)calloc(1,sizeof(SP_CIRC_BUF));

  0000c	6a 0c		 push	 12			; 0000000cH
  0000e	6a 01		 push	 1
  00010	e8 00 00 00 00	 call	 _calloc
  00015	83 c4 08	 add	 esp, 8
  00018	89 45 f8	 mov	 DWORD PTR _pCirc_Mblk$[ebp], eax

; 78   :   *pvCircMblk = pCirc_Mblk;

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _pvCircMblk$[ebp]
  0001e	8b 4d f8	 mov	 ecx, DWORD PTR _pCirc_Mblk$[ebp]
  00021	89 08		 mov	 DWORD PTR [eax], ecx

; 79   :   if(pCirc_Mblk == NULL)

  00023	83 7d f8 00	 cmp	 DWORD PTR _pCirc_Mblk$[ebp], 0
  00027	75 06		 jne	 SHORT $L1247

; 80   :      iRetFlag = 1;

  00029	66 c7 45 fc 01
	00		 mov	 WORD PTR _iRetFlag$[ebp], 1
$L1247:

; 81   : 
; 82   :   if (iRetFlag == 0)

  0002f	0f b7 55 fc	 movzx	 edx, WORD PTR _iRetFlag$[ebp]
  00033	85 d2		 test	 edx, edx
  00035	75 4e		 jne	 SHORT $L1248

; 83   :     {
; 84   :       pCirc_Mblk->iLength = iLength;

  00037	8b 45 f8	 mov	 eax, DWORD PTR _pCirc_Mblk$[ebp]
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _iLength$[ebp]
  0003d	89 08		 mov	 DWORD PTR [eax], ecx

; 85   :       pCirc_Mblk->iIndex  = 0;

  0003f	8b 55 f8	 mov	 edx, DWORD PTR _pCirc_Mblk$[ebp]
  00042	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 86   : 
; 87   :       pCirc_Mblk->pfData = (float *)calloc(iLength,sizeof(float)); 

  00049	6a 04		 push	 4
  0004b	8b 45 08	 mov	 eax, DWORD PTR _iLength$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _calloc
  00054	83 c4 08	 add	 esp, 8
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _pCirc_Mblk$[ebp]
  0005a	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 88   :       if(pCirc_Mblk->pfData == NULL) 

  0005d	8b 55 f8	 mov	 edx, DWORD PTR _pCirc_Mblk$[ebp]
  00060	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00064	75 1f		 jne	 SHORT $L1248

; 89   :         {
; 90   :           SafeFree(pvCircMblk);

  00066	83 7d 0c 00	 cmp	 DWORD PTR _pvCircMblk$[ebp], 0
  0006a	74 13		 je	 SHORT $L1253
  0006c	8b 45 0c	 mov	 eax, DWORD PTR _pvCircMblk$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _free
  00075	83 c4 04	 add	 esp, 4
  00078	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _pvCircMblk$[ebp], 0
$L1253:

; 91   :           iRetFlag = 1;

  0007f	66 c7 45 fc 01
	00		 mov	 WORD PTR _iRetFlag$[ebp], 1
$L1248:

; 92   :         }
; 93   :     }
; 94   : 
; 95   :   return iRetFlag;

  00085	66 8b 45 fc	 mov	 ax, WORD PTR _iRetFlag$[ebp]

; 96   : }

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
_InitSpCBM@8 ENDP
_TEXT	ENDS
PUBLIC	_FreeSpCBM@4
PUBLIC	??_C@_0DO@DDJGGNNE@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BD@CEMFHHGN@pvCircMblk?5?$CB?$DN?5NULL?$AA@ ; `string'
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0DO@DDJGGNNE@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DO@DDJGGNNE@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\spcbm.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CEMFHHGN@pvCircMblk?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BD@CEMFHHGN@pvCircMblk?5?$CB?$DN?5NULL?$AA@ DB 'pvCircMblk != NULL'
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _FreeSpCBM@4
_TEXT	SEGMENT
_pvCircMblk$ = 8
_FreeSpCBM@4 PROC NEAR					; COMDAT

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 121  :   assert(pvCircMblk != NULL);

  00003	83 7d 08 00	 cmp	 DWORD PTR _pvCircMblk$[ebp], 0
  00007	75 14		 jne	 SHORT $L1351
  00009	6a 79		 push	 121			; 00000079H
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@DDJGGNNE@c?3?2xbox?2private?2windows?2directx?2@
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@CEMFHHGN@pvCircMblk?5?$CB?$DN?5NULL?$AA@
  00015	e8 00 00 00 00	 call	 __assert
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1351:

; 122  : 
; 123  :   if(*pvCircMblk)

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _pvCircMblk$[ebp]
  00020	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00023	74 47		 je	 SHORT $L1258

; 124  :     {
; 125  :       SafeFree(((SP_CIRC_BUF *)*pvCircMblk)->pfData);

  00025	8b 55 08	 mov	 edx, DWORD PTR _pvCircMblk$[ebp]
  00028	8b 02		 mov	 eax, DWORD PTR [edx]
  0002a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0002e	74 1d		 je	 SHORT $L1265
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _pvCircMblk$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _free
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _pvCircMblk$[ebp]
  00044	8b 11		 mov	 edx, DWORD PTR [ecx]
  00046	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
$L1265:

; 126  :       SafeFree(*pvCircMblk);

  0004d	8b 45 08	 mov	 eax, DWORD PTR _pvCircMblk$[ebp]
  00050	83 38 00	 cmp	 DWORD PTR [eax], 0
  00053	74 17		 je	 SHORT $L1258
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _pvCircMblk$[ebp]
  00058	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 _free
  00060	83 c4 04	 add	 esp, 4
  00063	8b 45 08	 mov	 eax, DWORD PTR _pvCircMblk$[ebp]
  00066	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L1258:

; 127  :    }
; 128  : }

  0006c	5d		 pop	 ebp
  0006d	c2 04 00	 ret	 4
_FreeSpCBM@4 ENDP
_TEXT	ENDS
PUBLIC	_PutFrameSpCBM@16
PUBLIC	??_C@_0CL@DJGACEJM@?$CIpfInBuff?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpvCircMbl@ ; `string'
EXTRN	_memcpy:NEAR
;	COMDAT ??_C@_0CL@DJGACEJM@?$CIpfInBuff?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpvCircMbl@
CONST	SEGMENT
??_C@_0CL@DJGACEJM@?$CIpfInBuff?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpvCircMbl@ DB '('
	DB	'pfInBuff != NULL) && (pvCircMblk != NULL)', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _PutFrameSpCBM@16
_TEXT	SEGMENT
_pfSpCircBuf$ = -20
_iIndex$ = -16
_iStartPosition$ = -12
_iTotalLength$ = -8
_iRemainLength$ = -4
_pvCircMblk$ = 8
_iOffset$ = 12
_iInLength$ = 16
_pfInBuff$ = 20
_PutFrameSpCBM@16 PROC NEAR				; COMDAT

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 160  :    float        *pfSpCircBuf = ((SP_CIRC_BUF *)pvCircMblk)->pfData;

  00006	8b 45 08	 mov	 eax, DWORD PTR _pvCircMblk$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d ec	 mov	 DWORD PTR _pfSpCircBuf$[ebp], ecx

; 161  :    int           iTotalLength = ((SP_CIRC_BUF *)pvCircMblk)->iLength;

  0000f	8b 55 08	 mov	 edx, DWORD PTR _pvCircMblk$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	89 45 f8	 mov	 DWORD PTR _iTotalLength$[ebp], eax

; 162  :    int           iIndex = ((SP_CIRC_BUF *)pvCircMblk)->iIndex;

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _pvCircMblk$[ebp]
  0001a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001d	89 55 f0	 mov	 DWORD PTR _iIndex$[ebp], edx

; 163  :    int           iStartPosition;
; 164  :    int           iRemainLength;
; 165  : 
; 166  :    assert((pfInBuff != NULL) && (pvCircMblk != NULL));

  00020	83 7d 14 00	 cmp	 DWORD PTR _pfInBuff$[ebp], 0
  00024	74 06		 je	 SHORT $L1355
  00026	83 7d 08 00	 cmp	 DWORD PTR _pvCircMblk$[ebp], 0
  0002a	75 17		 jne	 SHORT $L1356
$L1355:
  0002c	68 a6 00 00 00	 push	 166			; 000000a6H
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@DDJGGNNE@c?3?2xbox?2private?2windows?2directx?2@
  00036	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CL@DJGACEJM@?$CIpfInBuff?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpvCircMbl@
  0003b	e8 00 00 00 00	 call	 __assert
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1356:

; 167  : 
; 168  :    /*----------------------------------------------------
; 169  :       Calculate the start position in circular
; 170  :         buffer to copy data from inBuff
; 171  :    ----------------------------------------------------*/
; 172  :    iStartPosition = CalcCircBufPosition(iOffset, iIndex, iTotalLength);

  00043	8b 4d f8	 mov	 ecx, DWORD PTR _iTotalLength$[ebp]
  00046	51		 push	 ecx
  00047	8b 55 f0	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0004a	52		 push	 edx
  0004b	8b 45 0c	 mov	 eax, DWORD PTR _iOffset$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _CalcCircBufPosition@12
  00054	89 45 f4	 mov	 DWORD PTR _iStartPosition$[ebp], eax

; 173  : 
; 174  :    /*----------------------------------------------------
; 175  :      remain length in circular buffer from the starting
; 176  :        copying position to th end of the circular buffer
; 177  :    ----------------------------------------------------*/
; 178  :    iRemainLength = iTotalLength - iStartPosition;

  00057	8b 4d f8	 mov	 ecx, DWORD PTR _iTotalLength$[ebp]
  0005a	2b 4d f4	 sub	 ecx, DWORD PTR _iStartPosition$[ebp]
  0005d	89 4d fc	 mov	 DWORD PTR _iRemainLength$[ebp], ecx

; 179  : 
; 180  :    /*----------------------------------------------------
; 181  :      Point to the start position in circular buffer
; 182  :    ----------------------------------------------------*/
; 183  :    if (iRemainLength >= iInLength)

  00060	8b 55 fc	 mov	 edx, DWORD PTR _iRemainLength$[ebp]
  00063	3b 55 10	 cmp	 edx, DWORD PTR _iInLength$[ebp]
  00066	7c 1f		 jl	 SHORT $L1294

; 184  :    {
; 185  :       /*----------------------------------------------------
; 186  :         the remain length in circular is suffucient
; 187  :           for copying data from InBuff
; 188  :       ----------------------------------------------------*/
; 189  :      memcpy(&(pfSpCircBuf[iStartPosition]), pfInBuff, iInLength*sizeof(float));

  00068	8b 45 10	 mov	 eax, DWORD PTR _iInLength$[ebp]
  0006b	c1 e0 02	 shl	 eax, 2
  0006e	50		 push	 eax
  0006f	8b 4d 14	 mov	 ecx, DWORD PTR _pfInBuff$[ebp]
  00072	51		 push	 ecx
  00073	8b 55 f4	 mov	 edx, DWORD PTR _iStartPosition$[ebp]
  00076	8b 45 ec	 mov	 eax, DWORD PTR _pfSpCircBuf$[ebp]
  00079	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 _memcpy
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH

; 190  :    }
; 191  :   else {

  00085	eb 3d		 jmp	 SHORT $L1296
$L1294:

; 192  :       /*----------------------------------------------------
; 193  :         the remain length in circular is shorter than
; 194  :           the length to be copied from InBuff
; 195  :       ----------------------------------------------------*/
; 196  : 
; 197  :       /*----------------------------------------------------
; 198  :          fill up the remain length in circular buffer
; 199  :       ----------------------------------------------------*/
; 200  :      memcpy(&(pfSpCircBuf[iStartPosition]), pfInBuff,
; 201  :             iRemainLength*sizeof(float));

  00087	8b 55 fc	 mov	 edx, DWORD PTR _iRemainLength$[ebp]
  0008a	c1 e2 02	 shl	 edx, 2
  0008d	52		 push	 edx
  0008e	8b 45 14	 mov	 eax, DWORD PTR _pfInBuff$[ebp]
  00091	50		 push	 eax
  00092	8b 4d f4	 mov	 ecx, DWORD PTR _iStartPosition$[ebp]
  00095	8b 55 ec	 mov	 edx, DWORD PTR _pfSpCircBuf$[ebp]
  00098	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 _memcpy
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 202  :     
; 203  :       /*----------------------------------------------------
; 204  :          fill up from the beginning of the circular buffer
; 205  :       ----------------------------------------------------*/
; 206  :      memcpy(pfSpCircBuf, &(pfInBuff[iRemainLength]), 
; 207  :             (iInLength-iRemainLength)*sizeof(float));

  000a4	8b 4d 10	 mov	 ecx, DWORD PTR _iInLength$[ebp]
  000a7	2b 4d fc	 sub	 ecx, DWORD PTR _iRemainLength$[ebp]
  000aa	c1 e1 02	 shl	 ecx, 2
  000ad	51		 push	 ecx
  000ae	8b 55 fc	 mov	 edx, DWORD PTR _iRemainLength$[ebp]
  000b1	8b 45 14	 mov	 eax, DWORD PTR _pfInBuff$[ebp]
  000b4	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  000b7	51		 push	 ecx
  000b8	8b 55 ec	 mov	 edx, DWORD PTR _pfSpCircBuf$[ebp]
  000bb	52		 push	 edx
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1296:

; 208  :    }
; 209  : 
; 210  :    /* update the Index -- independant with iOffset */
; 211  :    iIndex = CalcCircBufPosition(iInLength, iIndex, iTotalLength);

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _iTotalLength$[ebp]
  000c7	50		 push	 eax
  000c8	8b 4d f0	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  000cb	51		 push	 ecx
  000cc	8b 55 10	 mov	 edx, DWORD PTR _iInLength$[ebp]
  000cf	52		 push	 edx
  000d0	e8 00 00 00 00	 call	 _CalcCircBufPosition@12
  000d5	89 45 f0	 mov	 DWORD PTR _iIndex$[ebp], eax

; 212  :    ((SP_CIRC_BUF *)pvCircMblk)->iIndex = iIndex;

  000d8	8b 45 08	 mov	 eax, DWORD PTR _pvCircMblk$[ebp]
  000db	8b 4d f0	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  000de	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 213  : }

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c2 10 00	 ret	 16			; 00000010H
_PutFrameSpCBM@16 ENDP
_TEXT	ENDS
PUBLIC	_GetFrameSpCBM@16
PUBLIC	??_C@_0CI@DCMOMPFH@pvCircMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfOutBuff?5@ ; `string'
;	COMDAT ??_C@_0CI@DCMOMPFH@pvCircMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfOutBuff?5@
CONST	SEGMENT
??_C@_0CI@DCMOMPFH@pvCircMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfOutBuff?5@ DB 'p'
	DB	'vCircMblk != NULL && pfOutBuff != NULL', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _GetFrameSpCBM@16
_TEXT	SEGMENT
_pfSpCircBuf$ = -20
_iIndex$ = -16
_iStartPosition$ = -12
_iTotalLength$ = -8
_iRemainLength$ = -4
_pvCircMblk$ = 8
_iDelay$ = 12
_iOutLength$ = 16
_pfOutBuff$ = 20
_GetFrameSpCBM@16 PROC NEAR				; COMDAT

; 245  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 246  :    float        *pfSpCircBuf = ((SP_CIRC_BUF *)pvCircMblk)->pfData;

  00006	8b 45 08	 mov	 eax, DWORD PTR _pvCircMblk$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d ec	 mov	 DWORD PTR _pfSpCircBuf$[ebp], ecx

; 247  :    int          iTotalLength = ((SP_CIRC_BUF *)pvCircMblk)->iLength;

  0000f	8b 55 08	 mov	 edx, DWORD PTR _pvCircMblk$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	89 45 f8	 mov	 DWORD PTR _iTotalLength$[ebp], eax

; 248  :    int          iIndex = ((SP_CIRC_BUF *)pvCircMblk)->iIndex;

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _pvCircMblk$[ebp]
  0001a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001d	89 55 f0	 mov	 DWORD PTR _iIndex$[ebp], edx

; 249  :    int          iStartPosition;
; 250  :    int          iRemainLength;
; 251  : 
; 252  :    assert(pvCircMblk != NULL && pfOutBuff != NULL);

  00020	83 7d 08 00	 cmp	 DWORD PTR _pvCircMblk$[ebp], 0
  00024	74 06		 je	 SHORT $L1360
  00026	83 7d 14 00	 cmp	 DWORD PTR _pfOutBuff$[ebp], 0
  0002a	75 17		 jne	 SHORT $L1361
$L1360:
  0002c	68 fc 00 00 00	 push	 252			; 000000fcH
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@DDJGGNNE@c?3?2xbox?2private?2windows?2directx?2@
  00036	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@DCMOMPFH@pvCircMblk?5?$CB?$DN?5NULL?5?$CG?$CG?5pfOutBuff?5@
  0003b	e8 00 00 00 00	 call	 __assert
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1361:

; 253  : 
; 254  :    /*----------------------------------------------------
; 255  :       get the starting pointer of the frame
; 256  :       Calculate the starting position for extracting
; 257  :       data, which should be half window 
; 258  :       length + position of window center
; 259  :    ----------------------------------------------------*/
; 260  :    iDelay += ((iOutLength+1)>>1);

  00043	8b 4d 10	 mov	 ecx, DWORD PTR _iOutLength$[ebp]
  00046	83 c1 01	 add	 ecx, 1
  00049	d1 f9		 sar	 ecx, 1
  0004b	8b 55 0c	 mov	 edx, DWORD PTR _iDelay$[ebp]
  0004e	03 d1		 add	 edx, ecx
  00050	89 55 0c	 mov	 DWORD PTR _iDelay$[ebp], edx

; 261  : 
; 262  :    /*----------------------------------------------------
; 263  :      locate the starting position in curcular buffer
; 264  :    ----------------------------------------------------*/
; 265  :    iStartPosition = CalcCircBufPosition(-iDelay, iIndex, iTotalLength);

  00053	8b 45 f8	 mov	 eax, DWORD PTR _iTotalLength$[ebp]
  00056	50		 push	 eax
  00057	8b 4d f0	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0005a	51		 push	 ecx
  0005b	8b 55 0c	 mov	 edx, DWORD PTR _iDelay$[ebp]
  0005e	f7 da		 neg	 edx
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 _CalcCircBufPosition@12
  00066	89 45 f4	 mov	 DWORD PTR _iStartPosition$[ebp], eax

; 266  :   
; 267  :    /*----------------------------------------------------
; 268  :      remain length in curcilar buffer
; 269  :    ----------------------------------------------------*/
; 270  :    iRemainLength = iTotalLength - iStartPosition;

  00069	8b 45 f8	 mov	 eax, DWORD PTR _iTotalLength$[ebp]
  0006c	2b 45 f4	 sub	 eax, DWORD PTR _iStartPosition$[ebp]
  0006f	89 45 fc	 mov	 DWORD PTR _iRemainLength$[ebp], eax

; 271  : 
; 272  :    if (iRemainLength >= iOutLength)

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _iRemainLength$[ebp]
  00075	3b 4d 10	 cmp	 ecx, DWORD PTR _iOutLength$[ebp]
  00078	7c 1f		 jl	 SHORT $L1321

; 273  :    {
; 274  :       /*----------------------------------------------------
; 275  :         the remain length in circular is suffucient
; 276  :           for copying data into OutBuff
; 277  :       ----------------------------------------------------*/
; 278  :       memcpy(pfOutBuff, &(pfSpCircBuf[iStartPosition]), 
; 279  :              iOutLength*sizeof(float));

  0007a	8b 55 10	 mov	 edx, DWORD PTR _iOutLength$[ebp]
  0007d	c1 e2 02	 shl	 edx, 2
  00080	52		 push	 edx
  00081	8b 45 f4	 mov	 eax, DWORD PTR _iStartPosition$[ebp]
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _pfSpCircBuf$[ebp]
  00087	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0008a	52		 push	 edx
  0008b	8b 45 14	 mov	 eax, DWORD PTR _pfOutBuff$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _memcpy
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH

; 280  : 
; 281  :    } else {

  00097	eb 3d		 jmp	 SHORT $L1308
$L1321:

; 282  :       /*----------------------------------------------------
; 283  :         the remain length in circular is shorter than
; 284  :           the length to be copied into OutBuff
; 285  : 
; 286  :          fill up the remain length in circular buffer
; 287  :       ----------------------------------------------------*/
; 288  :       memcpy(pfOutBuff, &(pfSpCircBuf[iStartPosition]), 
; 289  :              iRemainLength*sizeof(float));

  00099	8b 4d fc	 mov	 ecx, DWORD PTR _iRemainLength$[ebp]
  0009c	c1 e1 02	 shl	 ecx, 2
  0009f	51		 push	 ecx
  000a0	8b 55 f4	 mov	 edx, DWORD PTR _iStartPosition$[ebp]
  000a3	8b 45 ec	 mov	 eax, DWORD PTR _pfSpCircBuf$[ebp]
  000a6	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  000a9	51		 push	 ecx
  000aa	8b 55 14	 mov	 edx, DWORD PTR _pfOutBuff$[ebp]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 _memcpy
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 290  : 
; 291  :       /*----------------------------------------------------
; 292  :          fill up from the beginning of the circular buffer
; 293  :       ----------------------------------------------------*/
; 294  :       memcpy(&(pfOutBuff[iRemainLength]), pfSpCircBuf, 
; 295  :              (iOutLength-iRemainLength)*sizeof(float));

  000b6	8b 45 10	 mov	 eax, DWORD PTR _iOutLength$[ebp]
  000b9	2b 45 fc	 sub	 eax, DWORD PTR _iRemainLength$[ebp]
  000bc	c1 e0 02	 shl	 eax, 2
  000bf	50		 push	 eax
  000c0	8b 4d ec	 mov	 ecx, DWORD PTR _pfSpCircBuf$[ebp]
  000c3	51		 push	 ecx
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _iRemainLength$[ebp]
  000c7	8b 45 14	 mov	 eax, DWORD PTR _pfOutBuff$[ebp]
  000ca	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 _memcpy
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1308:

; 296  :    }
; 297  : 
; 298  : }

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 10 00	 ret	 16			; 00000010H
_GetFrameSpCBM@16 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _CalcCircBufPosition@12
_TEXT	SEGMENT
_iPosition$ = 8
_iIndex$ = 12
_iLength$ = 16
_CalcCircBufPosition@12 PROC NEAR			; COMDAT

; 326  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 327  :    return ((iLength+(iIndex+iPosition%iLength))%iLength);

  00003	8b 45 08	 mov	 eax, DWORD PTR _iPosition$[ebp]
  00006	99		 cdq
  00007	f7 7d 10	 idiv	 DWORD PTR _iLength$[ebp]
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0000d	03 c2		 add	 eax, edx
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _iLength$[ebp]
  00012	03 c1		 add	 eax, ecx
  00014	99		 cdq
  00015	f7 7d 10	 idiv	 DWORD PTR _iLength$[ebp]
  00018	8b c2		 mov	 eax, edx

; 328  : }

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
_CalcCircBufPosition@12 ENDP
_TEXT	ENDS
END
