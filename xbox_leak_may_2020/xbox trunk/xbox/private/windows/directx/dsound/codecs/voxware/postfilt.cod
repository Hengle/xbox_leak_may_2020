; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\postfilt.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EB@BALIOFEH@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@HFGNPLMK@?$CIpfLogEnv?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfKS?5?$CB?$DN?5N@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09GGNPHDL@iFund?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _PostFilter@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
CONST	SEGMENT
_fLogWOver DD	03e86ac72r			; 0.263034
_fLogWUnder DD	0bf800000r			; -1
_iK0	DD	010H
_fInverseK0 DD	03d800000r			; 0.0625
_iFund	DD	020H
CONST	ENDS
PUBLIC	??_C@_0EB@BALIOFEH@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CF@HFGNPLMK@?$CIpfLogEnv?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfKS?5?$CB?$DN?5N@ ; `string'
PUBLIC	??_C@_09GGNPHDL@iFund?5?$DO?50?$AA@		; `string'
PUBLIC	__real@3f800000
PUBLIC	__real@3f000000
PUBLIC	__real@c0000000
PUBLIC	__real@3d800000
PUBLIC	_PostFilter@12
EXTRN	_cosTBL_32:DWORD
EXTRN	__fltused:NEAR
EXTRN	__assert:NEAR
EXTRN	_fLog2@4:NEAR
EXTRN	_FindMaxValueFlt@16:NEAR
;	COMDAT ??_C@_0EB@BALIOFEH@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\postfilt.c
CONST	SEGMENT
??_C@_0EB@BALIOFEH@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\postfilt.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HFGNPLMK@?$CIpfLogEnv?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfKS?5?$CB?$DN?5N@
CONST	SEGMENT
??_C@_0CF@HFGNPLMK@?$CIpfLogEnv?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfKS?5?$CB?$DN?5N@ DB '('
	DB	'pfLogEnv != NULL) && (pfKS != NULL)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GGNPHDL@iFund?5?$DO?50?$AA@
CONST	SEGMENT
??_C@_09GGNPHDL@iFund?5?$DO?50?$AA@ DB 'iFund > 0', 00H	; `string'
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@3d800000
CONST	SEGMENT
__real@3d800000 DD 03d800000r			; 0.0625
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _PostFilter@12
_TEXT	SEGMENT
tv170 = -96
tv168 = -92
_fGain$ = -88
_fLogWeight$ = -84
_k$ = -80
_iArg$ = -76
_fTemp3$ = -72
_fProd$ = -68
_iIndex$ = -64
_iMax$ = -60
_iMaxNew$ = -56
_fTilt$ = -52
_fTiltSamples$ = -48
_fInterp$ = -28
_i$ = -24
_fMax$ = -20
_fTemp1$ = -16
_iInterp$ = -12
_fTemp2$ = -8
_fMaxNew$ = -4
_pfLogEnv$ = 8
_fLog2Gain$ = 12
_pfKS$ = 16
_PostFilter@12 PROC NEAR				; COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	56		 push	 esi

; 118  :    int   i, k;
; 119  :    int   iIndex;
; 120  :    int   iInterp;
; 121  :    int   iMax;
; 122  :    int   iMaxNew;
; 123  :    int   iArg;
; 124  :    float fMax;
; 125  :    float fMaxNew;
; 126  :    float fLogWeight;
; 127  :    float fTemp1, fTemp2, fTemp3;
; 128  :    float fProd;
; 129  :    float fGain;
; 130  :    float fInterp;
; 131  : 
; 132  :    float fTilt;
; 133  :    float fTiltSamples[NSEGMENTS+1];
; 134  :    
; 135  :    assert((pfLogEnv != NULL) && (pfKS != NULL));

  00007	83 7d 08 00	 cmp	 DWORD PTR _pfLogEnv$[ebp], 0
  0000b	74 06		 je	 SHORT $L1090
  0000d	83 7d 10 00	 cmp	 DWORD PTR _pfKS$[ebp], 0
  00011	75 17		 jne	 SHORT $L1091
$L1090:
  00013	68 87 00 00 00	 push	 135			; 00000087H
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@BALIOFEH@c?3?2xbox?2private?2windows?2directx?2@
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@HFGNPLMK@?$CIpfLogEnv?5?$CB?$DN?5NULL?$CJ?5?$CG?$CG?5?$CIpfKS?5?$CB?$DN?5N@
  00022	e8 00 00 00 00	 call	 __assert
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1091:

; 136  : 
; 137  :    /*-------------------------------------------------------------------------
; 138  :      Check cosine table size...must re-work code if this fails
; 139  :    -------------------------------------------------------------------------*/
; 140  :    assert( iFund > 0 );

  0002a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _iFund, 0
  00031	7f 17		 jg	 SHORT $L1092
  00033	68 8c 00 00 00	 push	 140			; 0000008cH
  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@BALIOFEH@c?3?2xbox?2private?2windows?2directx?2@
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09GGNPHDL@iFund?5?$DO?50?$AA@
  00042	e8 00 00 00 00	 call	 __assert
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1092:

; 141  : 
; 142  :    /*-------------------------------------------------------------------------
; 143  :      Find the peak of the spectral log magnitude.  This will be used to 
; 144  :        normalize the gain of the postfiltered speech.  It is a poor man's 
; 145  :        estimate of R0.  It is a reasonably good approximation when 
; 146  :        the tilt is at least (15 dB / 4000 Hz)
; 147  :    -------------------------------------------------------------------------*/
; 148  :    FindMaxValueFlt( pfLogEnv, CSENV_NFFT_2, &iMax, &fMax );

  0004a	8d 55 ec	 lea	 edx, DWORD PTR _fMax$[ebp]
  0004d	52		 push	 edx
  0004e	8d 45 c4	 lea	 eax, DWORD PTR _iMax$[ebp]
  00051	50		 push	 eax
  00052	6a 40		 push	 64			; 00000040H
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _pfLogEnv$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 _FindMaxValueFlt@16

; 149  : 
; 150  :    /*-------------------------------------------------------------------------
; 151  :      A 1st order all pole model of the spectrum is used to normalize out
; 152  :        the spectral tilt.  The model is:
; 153  : 
; 154  :          Tilt(w) = | G1/(1.0+a_1*exp(-j*w)) |
; 155  : 
; 156  :      where a_1 is the predictor coefficient for a 1st order all pole model,
; 157  :      G1 is the gain of that model, and w is the frequency in radians.  
; 158  :      The value of a_1 is determined from:
; 159  : 
; 160  :          a_1 = - k_1 
; 161  : 
; 162  :      where k_1 is the first reflection coefficient.  The value of G1 can 
; 163  :      found from:
; 164  : 
; 165  :          G1^2 = R0 * (1.0 - k_1^2)
; 166  : 
; 167  :      where R0 is the 0th autocorrelation coefficient.  Finally, R0 is 
; 168  :      determined from the equation:
; 169  : 
; 170  :          G12^2 = R0 * PROD( i=1...12 ) (1.0 - k_i^2)
; 171  : 
; 172  :      where G12 is the gain of the 12th order all pole model and k_i
; 173  :      are the reflection coefficients.
; 174  : 
; 175  :      First compute 1st order system gain from the original gain and the 
; 176  :      reflection coefficients.
; 177  :    -------------------------------------------------------------------------*/
; 178  :    fProd = 1.0F;

  0005d	c7 45 bc 00 00
	80 3f		 mov	 DWORD PTR _fProd$[ebp], 1065353216 ; 3f800000H

; 179  :    for (i=1; i<LPC_ORDER; i++)

  00064	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0006b	eb 09		 jmp	 SHORT $L1064
$L1065:
  0006d	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  00070	83 c2 01	 add	 edx, 1
  00073	89 55 e8	 mov	 DWORD PTR _i$[ebp], edx
$L1064:
  00076	83 7d e8 0c	 cmp	 DWORD PTR _i$[ebp], 12	; 0000000cH
  0007a	7d 26		 jge	 SHORT $L1066

; 180  :    {
; 181  :       fTemp1 = pfKS[i]*pfKS[i];

  0007c	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0007f	8b 4d 10	 mov	 ecx, DWORD PTR _pfKS$[ebp]
  00082	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  00085	8b 75 10	 mov	 esi, DWORD PTR _pfKS$[ebp]
  00088	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  0008b	d8 0c 96	 fmul	 DWORD PTR [esi+edx*4]
  0008e	d9 5d f0	 fstp	 DWORD PTR _fTemp1$[ebp]

; 182  :       fProd *= (1.0F-fTemp1);

  00091	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  00097	d8 65 f0	 fsub	 DWORD PTR _fTemp1$[ebp]
  0009a	d8 4d bc	 fmul	 DWORD PTR _fProd$[ebp]
  0009d	d9 5d bc	 fstp	 DWORD PTR _fProd$[ebp]

; 183  :    }

  000a0	eb cb		 jmp	 SHORT $L1065
$L1066:

; 184  :    fGain = fLog2Gain - 0.5F*fLog2(fProd);

  000a2	8b 45 bc	 mov	 eax, DWORD PTR _fProd$[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _fLog2@4
  000ab	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  000b1	d8 6d 0c	 fsubr	 DWORD PTR _fLog2Gain$[ebp]
  000b4	d9 5d a8	 fstp	 DWORD PTR _fGain$[ebp]

; 185  :  
; 186  :    /*-------------------------------------------------------------------------
; 187  :      Compute samples of the log of the tilt curve using:
; 188  : 
; 189  :          Tilt(w) = | G1/(1.0+a_1*exp(-j*w)) |
; 190  :                  = G1/sqrt(1.0+a_1*a_1-2.0*A_1*cos(w))
; 191  : 
; 192  :          Log2(Tilt(w)) = Log2(G1) - 0.5*Log2(1.0+a_1*a_1-2.0*A_1*cos(w))
; 193  :    -------------------------------------------------------------------------*/
; 194  :    fTemp2 = 1.0F + pfKS[0]*pfKS[0];

  000b7	8b 4d 10	 mov	 ecx, DWORD PTR _pfKS$[ebp]
  000ba	8b 55 10	 mov	 edx, DWORD PTR _pfKS$[ebp]
  000bd	d9 01		 fld	 DWORD PTR [ecx]
  000bf	d8 0a		 fmul	 DWORD PTR [edx]
  000c1	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  000c7	d9 5d f8	 fstp	 DWORD PTR _fTemp2$[ebp]

; 195  :    fTemp3 = -2.0F*pfKS[0];

  000ca	8b 45 10	 mov	 eax, DWORD PTR _pfKS$[ebp]
  000cd	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c0000000
  000d3	d8 08		 fmul	 DWORD PTR [eax]
  000d5	d9 5d b8	 fstp	 DWORD PTR _fTemp3$[ebp]

; 196  :    iArg   = 0;

  000d8	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _iArg$[ebp], 0

; 197  :    for (i=0; i<=NSEGMENTS; i++)

  000df	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e6	eb 09		 jmp	 SHORT $L1067
$L1068:
  000e8	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  000eb	83 c1 01	 add	 ecx, 1
  000ee	89 4d e8	 mov	 DWORD PTR _i$[ebp], ecx
$L1067:
  000f1	83 7d e8 04	 cmp	 DWORD PTR _i$[ebp], 4
  000f5	7f 3b		 jg	 SHORT $L1069

; 198  :    {
; 199  :       fTemp1           = fTemp2 + fTemp3*cosTBL_32[iArg];

  000f7	8b 55 b4	 mov	 edx, DWORD PTR _iArg$[ebp]
  000fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _cosTBL_32
  000ff	d9 45 b8	 fld	 DWORD PTR _fTemp3$[ebp]
  00102	d8 0c 90	 fmul	 DWORD PTR [eax+edx*4]
  00105	d8 45 f8	 fadd	 DWORD PTR _fTemp2$[ebp]
  00108	d9 5d f0	 fstp	 DWORD PTR _fTemp1$[ebp]

; 200  :       iArg            += iFund;

  0010b	8b 4d b4	 mov	 ecx, DWORD PTR _iArg$[ebp]
  0010e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _iFund
  00114	89 4d b4	 mov	 DWORD PTR _iArg$[ebp], ecx

; 201  :       fTiltSamples[i]  = fGain - 0.5F*fLog2(fTemp1);

  00117	8b 55 f0	 mov	 edx, DWORD PTR _fTemp1$[ebp]
  0011a	52		 push	 edx
  0011b	e8 00 00 00 00	 call	 _fLog2@4
  00120	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00126	d8 6d a8	 fsubr	 DWORD PTR _fGain$[ebp]
  00129	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0012c	d9 5c 85 d0	 fstp	 DWORD PTR _fTiltSamples$[ebp+eax*4]

; 202  :    }

  00130	eb b6		 jmp	 SHORT $L1068
$L1069:

; 203  : 
; 204  :    /*------------------------------------------------------------------------
; 205  :      Postfilter using approximation to 1st order all-pole envelope
; 206  :    ------------------------------------------------------------------------*/
; 207  :    iIndex  = 0;

  00132	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _iIndex$[ebp], 0

; 208  :    iInterp = 0;

  00139	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iInterp$[ebp], 0

; 209  :    for (k = 1; k < CSENV_NFFT_2; k++)

  00140	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _k$[ebp], 1
  00147	eb 09		 jmp	 SHORT $L1070
$L1071:
  00149	8b 4d b0	 mov	 ecx, DWORD PTR _k$[ebp]
  0014c	83 c1 01	 add	 ecx, 1
  0014f	89 4d b0	 mov	 DWORD PTR _k$[ebp], ecx
$L1070:
  00152	83 7d b0 40	 cmp	 DWORD PTR _k$[ebp], 64	; 00000040H
  00156	0f 8d ce 00 00
	00		 jge	 $L1072

; 210  :    {
; 211  :       iInterp = k&TILT_MASK;

  0015c	8b 55 b0	 mov	 edx, DWORD PTR _k$[ebp]
  0015f	83 e2 0f	 and	 edx, 15			; 0000000fH
  00162	89 55 f4	 mov	 DWORD PTR _iInterp$[ebp], edx

; 212  :       iIndex  = (k>>(CSENV_FFT_ORDER-LOGNSEGMENTS-1));

  00165	8b 45 b0	 mov	 eax, DWORD PTR _k$[ebp]
  00168	c1 f8 04	 sar	 eax, 4
  0016b	89 45 c0	 mov	 DWORD PTR _iIndex$[ebp], eax

; 213  :       fInterp = (float) iInterp*((float)NSEGMENTS/(float)CSENV_NFFT_2);

  0016e	db 45 f4	 fild	 DWORD PTR _iInterp$[ebp]
  00171	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3d800000
  00177	d9 5d e4	 fstp	 DWORD PTR _fInterp$[ebp]

; 214  :       fTilt = VoxINTERP( fTiltSamples[iIndex], fTiltSamples[iIndex+1], fInterp);

  0017a	8b 4d c0	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0017d	d9 44 8d d0	 fld	 DWORD PTR _fTiltSamples$[ebp+ecx*4]
  00181	8b 55 c0	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00184	d9 44 95 d4	 fld	 DWORD PTR _fTiltSamples$[ebp+edx*4+4]
  00188	8b 45 c0	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0018b	d8 64 85 d0	 fsub	 DWORD PTR _fTiltSamples$[ebp+eax*4]
  0018f	d8 4d e4	 fmul	 DWORD PTR _fInterp$[ebp]
  00192	de c1		 faddp	 ST(1), ST(0)
  00194	d9 5d cc	 fstp	 DWORD PTR _fTilt$[ebp]

; 215  : 
; 216  :       /*-----------------------------------------------------------------
; 217  :         Compute postfilter weight
; 218  :       -----------------------------------------------------------------*/
; 219  :       fLogWeight = BETA*(pfLogEnv[k] - fTilt);

  00197	8b 4d b0	 mov	 ecx, DWORD PTR _k$[ebp]
  0019a	8b 55 08	 mov	 edx, DWORD PTR _pfLogEnv$[ebp]
  0019d	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  001a0	d8 65 cc	 fsub	 DWORD PTR _fTilt$[ebp]
  001a3	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  001a9	d9 55 ac	 fst	 DWORD PTR _fLogWeight$[ebp]

; 220  :  
; 221  :       /*-----------------------------------------------------------------
; 222  :         Clip the postfilter weight
; 223  :       -----------------------------------------------------------------*/
; 224  :       fLogWeight = VoxMIN( fLogWeight, fLogWOver );

  001ac	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR _fLogWOver
  001b2	df e0		 fnstsw	 ax
  001b4	f6 c4 41	 test	 ah, 65			; 00000041H
  001b7	75 0a		 jne	 SHORT $L1093
  001b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _fLogWOver
  001be	89 45 a4	 mov	 DWORD PTR tv168[ebp], eax
  001c1	eb 06		 jmp	 SHORT $L1094
$L1093:
  001c3	8b 4d ac	 mov	 ecx, DWORD PTR _fLogWeight$[ebp]
  001c6	89 4d a4	 mov	 DWORD PTR tv168[ebp], ecx
$L1094:
  001c9	8b 55 a4	 mov	 edx, DWORD PTR tv168[ebp]
  001cc	89 55 ac	 mov	 DWORD PTR _fLogWeight$[ebp], edx

; 225  :       fLogWeight = VoxMAX( fLogWeight, fLogWUnder );

  001cf	d9 45 ac	 fld	 DWORD PTR _fLogWeight$[ebp]
  001d2	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR _fLogWUnder
  001d8	df e0		 fnstsw	 ax
  001da	f6 c4 41	 test	 ah, 65			; 00000041H
  001dd	75 08		 jne	 SHORT $L1095
  001df	8b 45 ac	 mov	 eax, DWORD PTR _fLogWeight$[ebp]
  001e2	89 45 a0	 mov	 DWORD PTR tv170[ebp], eax
  001e5	eb 09		 jmp	 SHORT $L1096
$L1095:
  001e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _fLogWUnder
  001ed	89 4d a0	 mov	 DWORD PTR tv170[ebp], ecx
$L1096:
  001f0	8b 55 a0	 mov	 edx, DWORD PTR tv170[ebp]
  001f3	89 55 ac	 mov	 DWORD PTR _fLogWeight$[ebp], edx

; 226  :  
; 227  :       /*-----------------------------------------------------------------
; 228  :         Fade in the postfilter weight in the region (0<omega<LO_EDGE*PI)
; 229  :       -----------------------------------------------------------------*/
; 230  :       if(k < iK0)

  001f6	8b 45 b0	 mov	 eax, DWORD PTR _k$[ebp]
  001f9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _iK0
  001ff	7d 0f		 jge	 SHORT $L1076

; 231  :          fLogWeight *= (k*fInverseK0);

  00201	db 45 b0	 fild	 DWORD PTR _k$[ebp]
  00204	d8 0d 00 00 00
	00		 fmul	 DWORD PTR _fInverseK0
  0020a	d8 4d ac	 fmul	 DWORD PTR _fLogWeight$[ebp]
  0020d	d9 5d ac	 fstp	 DWORD PTR _fLogWeight$[ebp]
$L1076:

; 232  :  
; 233  :       /*-----------------------------------------------------------------
; 234  :         Apply the weight
; 235  :       -----------------------------------------------------------------*/
; 236  :       pfLogEnv[k] += fLogWeight;

  00210	8b 4d b0	 mov	 ecx, DWORD PTR _k$[ebp]
  00213	8b 55 08	 mov	 edx, DWORD PTR _pfLogEnv$[ebp]
  00216	d9 45 ac	 fld	 DWORD PTR _fLogWeight$[ebp]
  00219	d8 04 8a	 fadd	 DWORD PTR [edx+ecx*4]
  0021c	8b 45 b0	 mov	 eax, DWORD PTR _k$[ebp]
  0021f	8b 4d 08	 mov	 ecx, DWORD PTR _pfLogEnv$[ebp]
  00222	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]

; 237  :    }

  00225	e9 1f ff ff ff	 jmp	 $L1071
$L1072:

; 238  : 
; 239  :    /*-------------------------------------------------------------------------
; 240  :      Re-scale the post-filtered log-envelope to achieve the measured energy
; 241  :    -------------------------------------------------------------------------*/
; 242  :    FindMaxValueFlt( pfLogEnv, CSENV_NFFT_2, &iMaxNew, &fMaxNew );

  0022a	8d 55 fc	 lea	 edx, DWORD PTR _fMaxNew$[ebp]
  0022d	52		 push	 edx
  0022e	8d 45 c8	 lea	 eax, DWORD PTR _iMaxNew$[ebp]
  00231	50		 push	 eax
  00232	6a 40		 push	 64			; 00000040H
  00234	8b 4d 08	 mov	 ecx, DWORD PTR _pfLogEnv$[ebp]
  00237	51		 push	 ecx
  00238	e8 00 00 00 00	 call	 _FindMaxValueFlt@16

; 243  : 
; 244  :    fLogWeight = fMax - fMaxNew;

  0023d	d9 45 ec	 fld	 DWORD PTR _fMax$[ebp]
  00240	d8 65 fc	 fsub	 DWORD PTR _fMaxNew$[ebp]
  00243	d9 5d ac	 fstp	 DWORD PTR _fLogWeight$[ebp]

; 245  :    for (k = 0; k < CSENV_NFFT_2; k++)

  00246	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  0024d	eb 09		 jmp	 SHORT $L1077
$L1078:
  0024f	8b 55 b0	 mov	 edx, DWORD PTR _k$[ebp]
  00252	83 c2 01	 add	 edx, 1
  00255	89 55 b0	 mov	 DWORD PTR _k$[ebp], edx
$L1077:
  00258	83 7d b0 40	 cmp	 DWORD PTR _k$[ebp], 64	; 00000040H
  0025c	7d 17		 jge	 SHORT $L1038

; 246  :       pfLogEnv[k] += fLogWeight;

  0025e	8b 45 b0	 mov	 eax, DWORD PTR _k$[ebp]
  00261	8b 4d 08	 mov	 ecx, DWORD PTR _pfLogEnv$[ebp]
  00264	d9 45 ac	 fld	 DWORD PTR _fLogWeight$[ebp]
  00267	d8 04 81	 fadd	 DWORD PTR [ecx+eax*4]
  0026a	8b 55 b0	 mov	 edx, DWORD PTR _k$[ebp]
  0026d	8b 45 08	 mov	 eax, DWORD PTR _pfLogEnv$[ebp]
  00270	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]
  00273	eb da		 jmp	 SHORT $L1078
$L1038:

; 247  : 
; 248  : } /* PostFilter() */

  00275	5e		 pop	 esi
  00276	8b e5		 mov	 esp, ebp
  00278	5d		 pop	 ebp
  00279	c2 0c 00	 ret	 12			; 0000000cH
_PostFilter@12 ENDP
_TEXT	ENDS
END
