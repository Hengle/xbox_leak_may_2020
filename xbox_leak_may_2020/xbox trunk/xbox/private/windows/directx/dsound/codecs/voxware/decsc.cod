; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\decsc.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxDecodeSC@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxInitDecodeSC3@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxInitDecodeSC6@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxFreeDecodeSC3@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxFreeDecodeSC6@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DecFrameInit@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DecFrameCleanUp@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_VoxDecodeSC@16
EXTRN	_VoxAskToEnv@16:NEAR
EXTRN	_PreOutputManagerSC@12:NEAR
EXTRN	_PostOutputManagerSC@20:NEAR
EXTRN	_SubFrameSynth@24:NEAR
EXTRN	__fltused:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\decsc.c
;	COMDAT _VoxDecodeSC@16
_TEXT	SEGMENT
_pParamMblk$ = -548
_iSynSamples$ = -544
_pDecMemBlk$ = -540
_pfPhase$ = -536
_fSpeechBuf$ = -268
_pfEnv$ = -264
_hMemBlkD$ = 8
_hParamMblk$ = 12
_pPCMBuffer$ = 16
_pwPCMsamples$ = 20
_VoxDecodeSC@16 PROC NEAR				; COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 02 00
	00		 sub	 esp, 548		; 00000224H

; 100  :    DEC_MEM_BLK *pDecMemBlk=(DEC_MEM_BLK*)hMemBlkD;

  00009	8b 45 08	 mov	 eax, DWORD PTR _hMemBlkD$[ebp]
  0000c	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _pDecMemBlk$[ebp], eax

; 101  : 
; 102  :    PARAM_SC  *pParamMblk   = (PARAM_SC *)hParamMblk;

  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _hParamMblk$[ebp]
  00015	89 8d dc fd ff
	ff		 mov	 DWORD PTR _pParamMblk$[ebp], ecx

; 103  : 
; 104  :    float *fSpeechBuf;
; 105  : 
; 106  :    /*---------------------------------------------------
; 107  :      The arrays pfEnv[] and pfPhase[] require
; 108  :        CSENV_NFFT_2+1 points in SetAmpAndPhase().
; 109  :    ---------------------------------------------------*/
; 110  : STACK_INIT
; 111  :    float pfEnv[CSENV_NFFT_2+1];
; 112  :    float pfPhase[CSENV_NFFT_2+1];
; 113  : STACK_INIT_END
; 114  :  
; 115  :    STACK_ATTACH(float *, pfEnv)
; 116  :    STACK_ATTACH(float *, pfPhase)
; 117  :   
; 118  :    int    iSynSamples = 0;

  0001b	c7 85 e0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _iSynSamples$[ebp], 0

; 119  : 
; 120  :    STACK_START
; 121  : 
; 122  :    /*----------------------------------------------------------------------
; 123  :      Initialize some things in the decoder block to prepare for synthesis
; 124  :    ----------------------------------------------------------------------*/
; 125  :    DecFrameInit( pDecMemBlk );

  00025	8b 95 e4 fd ff
	ff		 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 _DecFrameInit@4

; 126  : 
; 127  :    /*----------------------------------------------------------------------
; 128  :      Copy the content of pSaveBuffer to pPCMBuffer.
; 129  :     ----------------------------------------------------------------------*/
; 130  :    PreOutputManagerSC(pDecMemBlk->pfSaveBuffer, pDecMemBlk->iSaveSamples,
; 131  :                       pPCMBuffer);

  00031	8b 45 10	 mov	 eax, DWORD PTR _pPCMBuffer$[ebp]
  00034	50		 push	 eax
  00035	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  0003b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003e	52		 push	 edx
  0003f	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  00045	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 _PreOutputManagerSC@12

; 132  : 
; 133  :    fSpeechBuf = pDecMemBlk->pfSaveBuffer; /* Re-use pSaveBuffer for synthesis */

  0004e	8b 95 e4 fd ff
	ff		 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00054	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00057	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _fSpeechBuf$[ebp], eax

; 134  : 
; 135  :    /*--------------------------------------------------------------------
; 136  :      Compute envelope and phase from arcsin reflection coefficients
; 137  :    --------------------------------------------------------------------*/
; 138  :    VoxAskToEnv(STACK_S pParamMblk->pfASK, pParamMblk->fLog2Gain,
; 139  :                pfEnv, pfPhase);

  0005d	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _pfPhase$[ebp]
  00063	51		 push	 ecx
  00064	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _pfEnv$[ebp]
  0006a	52		 push	 edx
  0006b	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _pParamMblk$[ebp]
  00071	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00074	51		 push	 ecx
  00075	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _pParamMblk$[ebp]
  0007b	83 c2 54	 add	 edx, 84			; 00000054H
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 _VoxAskToEnv@16

; 140  : 
; 141  :    /*--------------------------------------------------------------------
; 142  :      Synthesize 10 ms speech sub-frames (0, 1, or 2 may be synthesized)
; 143  :    --------------------------------------------------------------------*/
; 144  :    SubFrameSynth( STACK_S pDecMemBlk, (void *)(pParamMblk->SubParam),
; 145  :                   fSpeechBuf, pfEnv, pfPhase,
; 146  :                   &iSynSamples);

  00084	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _iSynSamples$[ebp]
  0008a	50		 push	 eax
  0008b	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _pfPhase$[ebp]
  00091	51		 push	 ecx
  00092	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _pfEnv$[ebp]
  00098	52		 push	 edx
  00099	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _fSpeechBuf$[ebp]
  0009f	50		 push	 eax
  000a0	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _pParamMblk$[ebp]
  000a6	51		 push	 ecx
  000a7	8b 95 e4 fd ff
	ff		 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 _SubFrameSynth@24

; 147  : 
; 148  :    /*----------------------------------------------------------------------
; 149  :      Do output buffering and put output in pPCMBuffer
; 150  :    ----------------------------------------------------------------------*/
; 151  :    PostOutputManagerSC(pDecMemBlk->pfSaveBuffer, &(pDecMemBlk->iSaveSamples),
; 152  :                        iSynSamples, pPCMBuffer, pwPCMsamples);

  000b3	8b 45 14	 mov	 eax, DWORD PTR _pwPCMsamples$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d 10	 mov	 ecx, DWORD PTR _pPCMBuffer$[ebp]
  000ba	51		 push	 ecx
  000bb	8b 95 e0 fd ff
	ff		 mov	 edx, DWORD PTR _iSynSamples$[ebp]
  000c1	52		 push	 edx
  000c2	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  000c8	83 c0 14	 add	 eax, 20			; 00000014H
  000cb	50		 push	 eax
  000cc	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  000d2	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 _PostOutputManagerSC@20

; 153  : 
; 154  :    /*----------------------------------------------------------------------
; 155  :      Do book-keeping for next time
; 156  :    ----------------------------------------------------------------------*/
; 157  :    DecFrameCleanUp(pDecMemBlk, pParamMblk, pfEnv, pfPhase );

  000db	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _pfPhase$[ebp]
  000e1	50		 push	 eax
  000e2	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _pfEnv$[ebp]
  000e8	51		 push	 ecx
  000e9	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _pParamMblk$[ebp]
  000ef	52		 push	 edx
  000f0	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _DecFrameCleanUp@16

; 158  : 
; 159  :    STACK_END
; 160  : }

  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c2 10 00	 ret	 16			; 00000010H
_VoxDecodeSC@16 ENDP
_TEXT	ENDS
PUBLIC	_VoxInitDecodeSC3@4
EXTRN	_VoxInitHFRegen@4:NEAR
EXTRN	_calloc:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxInitDecodeSC3@4
_TEXT	SEGMENT
_pDecode_mblk$ = -4
_ppMemBlkD$ = 8
_VoxInitDecodeSC3@4 PROC NEAR				; COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 187  :    DEC_MEM_BLK *pDecode_mblk;
; 188  : 
; 189  :    if(VOX_MEM_INIT(pDecode_mblk=*ppMemBlkD,1,sizeof(DEC_MEM_BLK)))

  00004	68 94 00 00 00	 push	 148			; 00000094H
  00009	6a 01		 push	 1
  0000b	e8 00 00 00 00	 call	 _calloc
  00010	83 c4 08	 add	 esp, 8
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _ppMemBlkD$[ebp]
  00016	89 01		 mov	 DWORD PTR [ecx], eax
  00018	8b 55 08	 mov	 edx, DWORD PTR _ppMemBlkD$[ebp]
  0001b	8b 02		 mov	 eax, DWORD PTR [edx]
  0001d	89 45 fc	 mov	 DWORD PTR _pDecode_mblk$[ebp], eax
  00020	83 7d fc 00	 cmp	 DWORD PTR _pDecode_mblk$[ebp], 0
  00024	75 09		 jne	 SHORT $L1644

; 190  :       return 1;

  00026	66 b8 01 00	 mov	 ax, 1
  0002a	e9 2a 01 00 00	 jmp	 $L1641
$L1644:

; 191  : 
; 192  :    /****************************************************
; 193  :     Ensure bit allocation is byte aligned
; 194  :     ****************************************************/
; 195  :    assert(TOTAL_BITS_SC3%8 == 0);
; 196  : 
; 197  :    /****************************************************
; 198  :      Initialize Overlapadd 
; 199  :      ***************************************************/
; 200  :    if (VOX_MEM_INIT(pDecode_mblk->pWaveform_1, HALF_FRAME_LENGTH_SC, 
; 201  :                     sizeof(float)))

  0002f	6a 04		 push	 4
  00031	6a 50		 push	 80			; 00000050H
  00033	e8 00 00 00 00	 call	 _calloc
  00038	83 c4 08	 add	 esp, 8
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  0003e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00041	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  00044	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  00048	75 09		 jne	 SHORT $L1647

; 202  :        return 1;

  0004a	66 b8 01 00	 mov	 ax, 1
  0004e	e9 06 01 00 00	 jmp	 $L1641
$L1647:

; 203  : 
; 204  :    /****************************************************
; 205  :     Initialize the Output Buffer block
; 206  :     ****************************************************/
; 207  :    if (VOX_MEM_INIT(pDecode_mblk->pfSaveBuffer, FRAME_LENGTH_SC, sizeof(float)))

  00053	6a 04		 push	 4
  00055	68 a0 00 00 00	 push	 160			; 000000a0H
  0005a	e8 00 00 00 00	 call	 _calloc
  0005f	83 c4 08	 add	 esp, 8
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  00065	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00068	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  0006b	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  0006f	75 09		 jne	 SHORT $L1649

; 208  :       return 1;

  00071	66 b8 01 00	 mov	 ax, 1
  00075	e9 df 00 00 00	 jmp	 $L1641
$L1649:

; 209  :    
; 210  :    /****************************************************
; 211  :     initialize HFRegen structure
; 212  :     ****************************************************/
; 213  :    if(VoxInitHFRegen(&pDecode_mblk->hHFRegenMblk))

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _pDecode_mblk$[ebp]
  0007d	83 c0 08	 add	 eax, 8
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _VoxInitHFRegen@4
  00086	0f b7 c8	 movzx	 ecx, ax
  00089	85 c9		 test	 ecx, ecx
  0008b	74 09		 je	 SHORT $L1650

; 214  :       return 1;

  0008d	66 b8 01 00	 mov	 ax, 1
  00091	e9 c3 00 00 00	 jmp	 $L1641
$L1650:

; 215  : 
; 216  :    /****************************************************
; 217  :     initialize the fWarpedLengthFactor
; 218  :     ****************************************************/
; 219  :    pDecode_mblk->fWarpedLengthFactor=1.0F;

  00096	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  00099	c7 42 5c 00 00
	80 3f		 mov	 DWORD PTR [edx+92], 1065353216 ; 3f800000H

; 220  :    pDecode_mblk->fActualWarp=1.0F;

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _pDecode_mblk$[ebp]
  000a3	c7 40 60 00 00
	80 3f		 mov	 DWORD PTR [eax+96], 1065353216 ; 3f800000H

; 221  :    pDecode_mblk->iNewFrame=1;

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  000ad	c7 41 64 01 00
	00 00		 mov	 DWORD PTR [ecx+100], 1

; 222  :    pDecode_mblk->fSynTimeOffset=(float)HALF_FRAME_LENGTH_SC;

  000b4	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  000b7	c7 42 68 00 00
	a0 42		 mov	 DWORD PTR [edx+104], 1117782016 ; 42a00000H

; 223  : 
; 224  :    pDecode_mblk->piFrameCount[0] = 1;   /* value of 1 assumes no warping */

  000be	8b 45 fc	 mov	 eax, DWORD PTR _pDecode_mblk$[ebp]
  000c1	c7 80 84 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+132], 1

; 225  :    pDecode_mblk->piFrameCount[1] = 1;   /* value of 1 assumes no warping */

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  000ce	c7 81 88 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+136], 1

; 226  : 
; 227  :    /****************************************************
; 228  :     Set the random seed for unvoiced phases 
; 229  :     ****************************************************/
; 230  :    pDecode_mblk->lUVPhaseRandSeed = 1;

  000d8	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  000db	c7 42 24 01 00
	00 00		 mov	 DWORD PTR [edx+36], 1

; 231  : 
; 232  :    /****************************************************
; 233  :     Set the rate valid flag
; 234  :     ****************************************************/
; 235  :    pDecode_mblk->iSCRateValid = SC_RATE_3K;

  000e2	8b 45 fc	 mov	 eax, DWORD PTR _pDecode_mblk$[ebp]
  000e5	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 236  :    pDecode_mblk->iSCTargetRate = SC_RATE_3K;

  000ec	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  000ef	c7 41 20 01 00
	00 00		 mov	 DWORD PTR [ecx+32], 1

; 237  :    pDecode_mblk->iSCRate_1 = SC_RATE_3K;

  000f6	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  000f9	c7 42 1c 01 00
	00 00		 mov	 DWORD PTR [edx+28], 1

; 238  : 
; 239  :    /****************************************************
; 240  :     Allocate space for phase and magnitude envelopes
; 241  :     ****************************************************/
; 242  :    if(VOX_MEM_INIT(pDecode_mblk->pfEnv_1,(CSENV_NFFT_2+1),
; 243  :                    sizeof(float)))

  00100	6a 04		 push	 4
  00102	6a 41		 push	 65			; 00000041H
  00104	e8 00 00 00 00	 call	 _calloc
  00109	83 c4 08	 add	 esp, 8
  0010c	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  0010f	89 41 28	 mov	 DWORD PTR [ecx+40], eax
  00112	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  00115	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  00119	75 06		 jne	 SHORT $L1653

; 244  :       return 1;

  0011b	66 b8 01 00	 mov	 ax, 1
  0011f	eb 38		 jmp	 SHORT $L1641
$L1653:

; 245  :  
; 246  :    if(VOX_MEM_INIT(pDecode_mblk->pfPhase_1,(CSENV_NFFT_2+1),
; 247  :                    sizeof(float)))

  00121	6a 04		 push	 4
  00123	6a 41		 push	 65			; 00000041H
  00125	e8 00 00 00 00	 call	 _calloc
  0012a	83 c4 08	 add	 esp, 8
  0012d	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  00130	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
  00133	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  00136	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  0013a	75 06		 jne	 SHORT $L1655

; 248  :       return 1;

  0013c	66 b8 01 00	 mov	 ax, 1
  00140	eb 17		 jmp	 SHORT $L1641
$L1655:

; 249  : 
; 250  :    /***************************************************
; 251  :      Initialize the parameters of previous frame
; 252  :     **************************************************/
; 253  :    pDecode_mblk->Pitch_1_mid = INITIAL_PITCH;

  00142	8b 45 fc	 mov	 eax, DWORD PTR _pDecode_mblk$[ebp]
  00145	c7 40 30 00 00
	c8 42		 mov	 DWORD PTR [eax+48], 1120403456 ; 42c80000H

; 254  :    pDecode_mblk->PrevSubParam.Pitch = INITIAL_PITCH;

  0014c	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  0014f	c7 41 34 00 00
	c8 42		 mov	 DWORD PTR [ecx+52], 1120403456 ; 42c80000H

; 255  : 
; 256  :    return 0;

  00156	66 33 c0	 xor	 ax, ax
$L1641:

; 257  : }

  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c2 04 00	 ret	 4
_VoxInitDecodeSC3@4 ENDP
_TEXT	ENDS
PUBLIC	_VoxInitDecodeSC6@4
; Function compile flags: /Odt
;	COMDAT _VoxInitDecodeSC6@4
_TEXT	SEGMENT
_pDecode_mblk$ = -4
_ppMemBlkD$ = 8
_VoxInitDecodeSC6@4 PROC NEAR				; COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 283  :    DEC_MEM_BLK *pDecode_mblk=(DEC_MEM_BLK *)*ppMemBlkD;

  00004	8b 45 08	 mov	 eax, DWORD PTR _ppMemBlkD$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _pDecode_mblk$[ebp], ecx

; 284  : 
; 285  :    /****************************************************
; 286  :     Ensure bit allocation is byte aligned
; 287  :     ****************************************************/
; 288  :    assert( ADDITIONAL_BITS_SC6 == ADDITIONAL_BYTES_SC6*8 );
; 289  : 
; 290  :    /****************************************************
; 291  :     check for valid pointer
; 292  :     ****************************************************/
; 293  :    if (pDecode_mblk==NULL)

  0000c	83 7d fc 00	 cmp	 DWORD PTR _pDecode_mblk$[ebp], 0
  00010	75 06		 jne	 SHORT $L1663

; 294  :       return 1;

  00012	66 b8 01 00	 mov	 ax, 1
  00016	eb 39		 jmp	 SHORT $L1658
$L1663:

; 295  : 
; 296  :    /****************************************************
; 297  :     make sure SC_RATE_3K was already initialized
; 298  :     ****************************************************/
; 299  :    if(!(pDecode_mblk->iSCRateValid & SC_RATE_3K))

  00018	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	83 e0 01	 and	 eax, 1
  00021	85 c0		 test	 eax, eax
  00023	75 06		 jne	 SHORT $L1664

; 300  :       return 1;

  00025	66 b8 01 00	 mov	 ax, 1
  00029	eb 26		 jmp	 SHORT $L1658
$L1664:

; 301  : 
; 302  : 
; 303  :    /****************************************************
; 304  :     Set the rate valid flag
; 305  :     ****************************************************/
; 306  :    pDecode_mblk->iSCRateValid |= SC_RATE_6K;

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  0002e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00031	83 ca 02	 or	 edx, 2
  00034	8b 45 fc	 mov	 eax, DWORD PTR _pDecode_mblk$[ebp]
  00037	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 307  :    pDecode_mblk->iSCTargetRate = SC_RATE_6K;

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  0003d	c7 41 20 02 00
	00 00		 mov	 DWORD PTR [ecx+32], 2

; 308  :    pDecode_mblk->iSCRate_1 = SC_RATE_6K;

  00044	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  00047	c7 42 1c 02 00
	00 00		 mov	 DWORD PTR [edx+28], 2

; 309  : 
; 310  :    return 0;

  0004e	66 33 c0	 xor	 ax, ax
$L1658:

; 311  : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
_VoxInitDecodeSC6@4 ENDP
_TEXT	ENDS
PUBLIC	_VoxFreeDecodeSC3@4
EXTRN	_nspFreeFftResources@0:NEAR
EXTRN	_VoxFreeHFRegen@4:NEAR
EXTRN	_free:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxFreeDecodeSC3@4
_TEXT	SEGMENT
_pDecode_mblk$ = -4
_hMemBlkD$ = 8
_VoxFreeDecodeSC3@4 PROC NEAR				; COMDAT

; 336  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 337  :     DEC_MEM_BLK *pDecode_mblk=(DEC_MEM_BLK*)*hMemBlkD;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hMemBlkD$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _pDecode_mblk$[ebp], ecx

; 338  : 
; 339  : #ifdef WIN32
; 340  :     nspFreeFftResources();

  0000c	e8 00 00 00 00	 call	 _nspFreeFftResources@0

; 341  : #endif
; 342  : 
; 343  :     if (pDecode_mblk) {

  00011	83 7d fc 00	 cmp	 DWORD PTR _pDecode_mblk$[ebp], 0
  00015	0f 84 ad 00 00
	00		 je	 $L1670

; 344  : 
; 345  :        VOX_MEM_FREE(pDecode_mblk->pWaveform_1);

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  0001e	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  00022	74 19		 je	 SHORT $L1671
  00024	8b 45 fc	 mov	 eax, DWORD PTR _pDecode_mblk$[ebp]
  00027	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 _free
  00030	83 c4 04	 add	 esp, 4
  00033	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  00036	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
$L1671:

; 346  : 
; 347  :        VOX_MEM_FREE(pDecode_mblk->pfSaveBuffer);

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _pDecode_mblk$[ebp]
  00040	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00044	74 19		 je	 SHORT $L1673
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  00049	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 _free
  00052	83 c4 04	 add	 esp, 4
  00055	8b 45 fc	 mov	 eax, DWORD PTR _pDecode_mblk$[ebp]
  00058	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$L1673:

; 348  : 
; 349  :        VoxFreeHFRegen(&pDecode_mblk->hHFRegenMblk);

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  00062	83 c1 08	 add	 ecx, 8
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 _VoxFreeHFRegen@4

; 350  : 
; 351  :        VOX_MEM_FREE(pDecode_mblk->pfEnv_1);

  0006b	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  0006e	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  00072	74 19		 je	 SHORT $L1675
  00074	8b 45 fc	 mov	 eax, DWORD PTR _pDecode_mblk$[ebp]
  00077	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 _free
  00080	83 c4 04	 add	 esp, 4
  00083	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  00086	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], 0
$L1675:

; 352  : 
; 353  :        VOX_MEM_FREE(pDecode_mblk->pfPhase_1);

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _pDecode_mblk$[ebp]
  00090	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00094	74 19		 je	 SHORT $L1677
  00096	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  00099	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 _free
  000a2	83 c4 04	 add	 esp, 4
  000a5	8b 45 fc	 mov	 eax, DWORD PTR _pDecode_mblk$[ebp]
  000a8	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
$L1677:

; 354  : 
; 355  :        VOX_MEM_FREE(pDecode_mblk);

  000af	83 7d fc 00	 cmp	 DWORD PTR _pDecode_mblk$[ebp], 0
  000b3	74 13		 je	 SHORT $L1670
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 _free
  000be	83 c4 04	 add	 esp, 4
  000c1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pDecode_mblk$[ebp], 0
$L1670:

; 356  :     }
; 357  :     return 0;

  000c8	66 33 c0	 xor	 ax, ax

; 358  : }

  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 04 00	 ret	 4
_VoxFreeDecodeSC3@4 ENDP
_TEXT	ENDS
PUBLIC	_VoxFreeDecodeSC6@4
; Function compile flags: /Odt
;	COMDAT _VoxFreeDecodeSC6@4
_TEXT	SEGMENT
_pDecode_mblk$ = -4
_hMemBlkD$ = 8
_VoxFreeDecodeSC6@4 PROC NEAR				; COMDAT

; 382  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 383  :     DEC_MEM_BLK *pDecode_mblk=(DEC_MEM_BLK*)*hMemBlkD;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hMemBlkD$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _pDecode_mblk$[ebp], ecx

; 384  :   
; 385  :     if (pDecode_mblk) {

  0000c	83 7d fc 00	 cmp	 DWORD PTR _pDecode_mblk$[ebp], 0
  00010	74 0f		 je	 SHORT $L1686

; 386  : 
; 387  :        /****************************************************
; 388  :         clear the rate valid flag
; 389  :         ****************************************************/
; 390  :        pDecode_mblk->iSCRateValid &= (~(SC_RATE_6K));

  00012	8b 55 fc	 mov	 edx, DWORD PTR _pDecode_mblk$[ebp]
  00015	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00018	83 e0 fd	 and	 eax, -3			; fffffffdH
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _pDecode_mblk$[ebp]
  0001e	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$L1686:

; 391  :     }
; 392  : 
; 393  :     return 0;

  00021	66 33 c0	 xor	 ax, ax

; 394  : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
_VoxFreeDecodeSC6@4 ENDP
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT _DecFrameInit@4
_TEXT	SEGMENT
_pDecMemBlk$ = 8
_DecFrameInit@4 PROC NEAR				; COMDAT

; 405  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 406  :    /*-------------------------------------------------------------------------
; 407  :      When decoding a new frame of data, the following must be initialized:
; 408  :    -------------------------------------------------------------------------*/
; 409  :    if (pDecMemBlk->iNewFrame)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  00006	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  0000a	0f 84 91 00 00
	00		 je	 $L1689

; 410  :    {
; 411  :       /*----------------------------------------------
; 412  :         Read the time warp factor and the number of
; 413  :           frames skipped.
; 414  :       ----------------------------------------------*/
; 415  :       pDecMemBlk->fActualWarp          = pDecMemBlk->fWarpedLengthFactor;

  00010	8b 4d 08	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00016	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00019	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 416  :       pDecMemBlk->iActualFramesSkipped = pDecMemBlk->iFramesSkipped;

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  0001f	8b 55 08	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00022	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00025	89 41 74	 mov	 DWORD PTR [ecx+116], eax

; 417  :    
; 418  :       /*----------------------------------------------
; 419  :         Determine if the phase offset should be 
; 420  :           adjusted in HighFrequencyRegeneration()
; 421  :           (i.e the value of iSetOffsetFlag)
; 422  :       ----------------------------------------------*/
; 423  :       if (pDecMemBlk->iActualFramesSkipped || (pDecMemBlk->iFramesRepeated
; 424  :           && !(pDecMemBlk->iRepeatFrameFlag)))

  00028	8b 4d 08	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  0002b	83 79 74 00	 cmp	 DWORD PTR [ecx+116], 0
  0002f	75 12		 jne	 SHORT $L1692
  00031	8b 55 08	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00034	83 7a 7c 00	 cmp	 DWORD PTR [edx+124], 0
  00038	74 18		 je	 SHORT $L1691
  0003a	8b 45 08	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  0003d	83 78 78 00	 cmp	 DWORD PTR [eax+120], 0
  00041	75 0f		 jne	 SHORT $L1691
$L1692:

; 425  :          pDecMemBlk->iSetOffsetFlag = 1;

  00043	8b 4d 08	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00046	c7 81 80 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+128], 1

; 426  :       else

  00050	eb 0d		 jmp	 SHORT $L1693
$L1691:

; 427  :          pDecMemBlk->iSetOffsetFlag = 0;

  00052	8b 55 08	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00055	c7 82 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+128], 0
$L1693:

; 428  :    
; 429  :       /*----------------------------------------------
; 430  :         Set the number of frame repeats
; 431  :       ----------------------------------------------*/
; 432  :       if (pDecMemBlk->iRepeatFrameFlag)

  0005f	8b 45 08	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  00062	83 78 78 00	 cmp	 DWORD PTR [eax+120], 0
  00066	74 11		 je	 SHORT $L1694

; 433  :          pDecMemBlk->iFramesRepeated += 1;

  00068	8b 4d 08	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  0006b	8b 51 7c	 mov	 edx, DWORD PTR [ecx+124]
  0006e	83 c2 01	 add	 edx, 1
  00071	8b 45 08	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  00074	89 50 7c	 mov	 DWORD PTR [eax+124], edx

; 434  :       else

  00077	eb 0a		 jmp	 SHORT $L1695
$L1694:

; 435  :          pDecMemBlk->iFramesRepeated = 0;

  00079	8b 4d 08	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  0007c	c7 41 7c 00 00
	00 00		 mov	 DWORD PTR [ecx+124], 0
$L1695:

; 436  : 
; 437  :       /*----------------------------------------------
; 438  :         Reset these values
; 439  :       ----------------------------------------------*/
; 440  :       pDecMemBlk->iFramesSkipped = 0;

  00083	8b 55 08	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00086	c7 42 70 00 00
	00 00		 mov	 DWORD PTR [edx+112], 0

; 441  :       pDecMemBlk->iRepeatFrameFlag = 0;

  0008d	8b 45 08	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  00090	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [eax+120], 0

; 442  :       pDecMemBlk->iNewFrame = 0;

  00097	8b 4d 08	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  0009a	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], 0
$L1689:

; 443  :    }
; 444  : }

  000a1	5d		 pop	 ebp
  000a2	c2 04 00	 ret	 4
_DecFrameInit@4 ENDP
_TEXT	ENDS
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt
;	COMDAT _DecFrameCleanUp@16
_TEXT	SEGMENT
_piFrameCount$ = -4
_pDecMemBlk$ = 8
_pParamMblk$ = 12
_pfEnv$ = 16
_pfPhase$ = 20
_DecFrameCleanUp@16 PROC NEAR				; COMDAT

; 455  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 456  :    int *piFrameCount;
; 457  : 
; 458  :    /*----------------------------------------------------------------------
; 459  :      Save some things and set up for next time
; 460  :    ----------------------------------------------------------------------*/
; 461  :    if (pDecMemBlk->iNewFrame) 

  00004	8b 45 08	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  00007	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  0000b	0f 84 8a 00 00
	00		 je	 $L1704

; 462  :    {
; 463  :       /*----------------------------------------------------------------------
; 464  :         Save/reset frame counters
; 465  :       ----------------------------------------------------------------------*/
; 466  :       piFrameCount = pDecMemBlk->piFrameCount;

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _pDecMemBlk$[ebp]
  00014	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  0001a	89 4d fc	 mov	 DWORD PTR _piFrameCount$[ebp], ecx

; 467  :      
; 468  :       piFrameCount[0] = piFrameCount[2];

  0001d	8b 55 fc	 mov	 edx, DWORD PTR _piFrameCount$[ebp]
  00020	8b 45 fc	 mov	 eax, DWORD PTR _piFrameCount$[ebp]
  00023	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00026	89 0a		 mov	 DWORD PTR [edx], ecx

; 469  :       piFrameCount[1] = piFrameCount[3];

  00028	8b 55 fc	 mov	 edx, DWORD PTR _piFrameCount$[ebp]
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _piFrameCount$[ebp]
  0002e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00031	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 470  :       piFrameCount[2] = 0;

  00034	8b 55 fc	 mov	 edx, DWORD PTR _piFrameCount$[ebp]
  00037	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 471  :       piFrameCount[3] = 0;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _piFrameCount$[ebp]
  00041	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 472  : 
; 473  :       /*----------------------------------------------------------------------
; 474  :         save amplitude and phase envelopes
; 475  :       ----------------------------------------------------------------------*/
; 476  :       memcpy( pDecMemBlk->pfEnv_1, pfEnv, (CSENV_NFFT_2+1)*sizeof(float));

  00048	68 04 01 00 00	 push	 260			; 00000104H
  0004d	8b 4d 10	 mov	 ecx, DWORD PTR _pfEnv$[ebp]
  00050	51		 push	 ecx
  00051	8b 55 08	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00054	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _memcpy
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 477  : 
; 478  :       memcpy( pDecMemBlk->pfPhase_1, pfPhase, (CSENV_NFFT_2+1)*sizeof(float));

  00060	68 04 01 00 00	 push	 260			; 00000104H
  00065	8b 4d 14	 mov	 ecx, DWORD PTR _pfPhase$[ebp]
  00068	51		 push	 ecx
  00069	8b 55 08	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  0006c	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _memcpy
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 479  :  
; 480  :       /*----------------------------------------------------------------------
; 481  :        copy the parameters
; 482  :       ----------------------------------------------------------------------*/
; 483  :       memcpy(&(pDecMemBlk->PrevSubParam), 
; 484  :              &(pParamMblk->SubParam[PARAM_ENDFRAME]),
; 485  :              sizeof(SUBFRAME_PARAM_SC));

  00078	6a 28		 push	 40			; 00000028H
  0007a	8b 4d 0c	 mov	 ecx, DWORD PTR _pParamMblk$[ebp]
  0007d	83 c1 28	 add	 ecx, 40			; 00000028H
  00080	51		 push	 ecx
  00081	8b 55 08	 mov	 edx, DWORD PTR _pDecMemBlk$[ebp]
  00084	83 c2 34	 add	 edx, 52			; 00000034H
  00087	52		 push	 edx
  00088	e8 00 00 00 00	 call	 _memcpy
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 486  : 
; 487  :       pDecMemBlk->Pitch_1_mid = pParamMblk->SubParam[PARAM_MIDFRAME].Pitch;

  00090	8b 45 08	 mov	 eax, DWORD PTR _pDecMemBlk$[ebp]
  00093	8b 4d 0c	 mov	 ecx, DWORD PTR _pParamMblk$[ebp]
  00096	8b 11		 mov	 edx, DWORD PTR [ecx]
  00098	89 50 30	 mov	 DWORD PTR [eax+48], edx
$L1704:

; 488  :    }
; 489  : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 10 00	 ret	 16			; 00000010H
_DecFrameCleanUp@16 ENDP
_TEXT	ENDS
END
