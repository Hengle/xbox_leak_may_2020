; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\vq2.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DM@OKLCGLIK@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HOOFICEM@pfVector?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OHJAPAEA@pfCodeBook?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@EIGCPLHA@iIndex?5?$DM?5?$CIunsigned?5int?$CJ?5iEntries@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _Dim2VectorQuantize@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Dim2VectorLUT@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_Dim2VectorQuantize@12
PUBLIC	??_C@_0DM@OKLCGLIK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BB@HOOFICEM@pfVector?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	??_C@_0BD@OHJAPAEA@pfCodeBook?5?$CB?$DN?5NULL?$AA@ ; `string'
EXTRN	__assert:NEAR
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_0DM@OKLCGLIK@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\vq2.c
CONST	SEGMENT
??_C@_0DM@OKLCGLIK@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\vq2.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HOOFICEM@pfVector?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BB@HOOFICEM@pfVector?5?$CB?$DN?5NULL?$AA@ DB 'pfVector != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OHJAPAEA@pfCodeBook?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BD@OHJAPAEA@pfCodeBook?5?$CB?$DN?5NULL?$AA@ DB 'pfCodeBook != NULL'
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _Dim2VectorQuantize@12
_TEXT	SEGMENT
_iIndex$ = -20
_uError$ = -16
_fTmp$ = -12
_uMinError$ = -8
_i$ = -4
_pfVector$ = 8
_pfCodeBook$ = 12
_iEntries$ = 16
_Dim2VectorQuantize@12 PROC NEAR			; COMDAT

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 63   :    int   i;
; 64   :    int   iIndex;
; 65   :    float fTmp;
; 66   :    union dt {
; 67   :       float f;
; 68   :       long   l;
; 69   :    } uMinError, uError;
; 70   : 
; 71   :    assert( pfVector != NULL);

  00006	83 7d 08 00	 cmp	 DWORD PTR _pfVector$[ebp], 0
  0000a	75 14		 jne	 SHORT $L940
  0000c	6a 47		 push	 71			; 00000047H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DM@OKLCGLIK@c?3?2xbox?2private?2windows?2directx?2@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@HOOFICEM@pfVector?5?$CB?$DN?5NULL?$AA@
  00018	e8 00 00 00 00	 call	 __assert
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L940:

; 72   :    assert( pfCodeBook != NULL);

  00020	83 7d 0c 00	 cmp	 DWORD PTR _pfCodeBook$[ebp], 0
  00024	75 14		 jne	 SHORT $L941
  00026	6a 48		 push	 72			; 00000048H
  00028	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DM@OKLCGLIK@c?3?2xbox?2private?2windows?2directx?2@
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OHJAPAEA@pfCodeBook?5?$CB?$DN?5NULL?$AA@
  00032	e8 00 00 00 00	 call	 __assert
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$L941:

; 73   :    iIndex = 0;

  0003a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iIndex$[ebp], 0

; 74   :    uMinError.f = VERY_LARGE_FLOAT;

  00041	c7 45 f8 99 76
	96 7e		 mov	 DWORD PTR _uMinError$[ebp], 2123789977 ; 7e967699H

; 75   :   
; 76   :    for (i = 0; i < iEntries; i++) 

  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004f	eb 09		 jmp	 SHORT $L906
$L907:
  00051	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00054	83 c2 01	 add	 edx, 1
  00057	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L906:
  0005a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0005d	3b 45 10	 cmp	 eax, DWORD PTR _iEntries$[ebp]
  00060	7d 58		 jge	 SHORT $L908

; 77   :    {
; 78   :       fTmp = *pfCodeBook++ - pfVector[0];

  00062	8b 4d 0c	 mov	 ecx, DWORD PTR _pfCodeBook$[ebp]
  00065	8b 55 08	 mov	 edx, DWORD PTR _pfVector$[ebp]
  00068	d9 01		 fld	 DWORD PTR [ecx]
  0006a	d8 22		 fsub	 DWORD PTR [edx]
  0006c	d9 5d f4	 fstp	 DWORD PTR _fTmp$[ebp]
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _pfCodeBook$[ebp]
  00072	83 c0 04	 add	 eax, 4
  00075	89 45 0c	 mov	 DWORD PTR _pfCodeBook$[ebp], eax

; 79   :       uError.f = fTmp * fTmp;

  00078	d9 45 f4	 fld	 DWORD PTR _fTmp$[ebp]
  0007b	d8 4d f4	 fmul	 DWORD PTR _fTmp$[ebp]
  0007e	d9 5d f0	 fstp	 DWORD PTR _uError$[ebp]

; 80   :       fTmp = *pfCodeBook++ - pfVector[1];

  00081	8b 4d 0c	 mov	 ecx, DWORD PTR _pfCodeBook$[ebp]
  00084	8b 55 08	 mov	 edx, DWORD PTR _pfVector$[ebp]
  00087	d9 01		 fld	 DWORD PTR [ecx]
  00089	d8 62 04	 fsub	 DWORD PTR [edx+4]
  0008c	d9 5d f4	 fstp	 DWORD PTR _fTmp$[ebp]
  0008f	8b 45 0c	 mov	 eax, DWORD PTR _pfCodeBook$[ebp]
  00092	83 c0 04	 add	 eax, 4
  00095	89 45 0c	 mov	 DWORD PTR _pfCodeBook$[ebp], eax

; 81   :       uError.f += fTmp * fTmp;

  00098	d9 45 f4	 fld	 DWORD PTR _fTmp$[ebp]
  0009b	d8 4d f4	 fmul	 DWORD PTR _fTmp$[ebp]
  0009e	d8 45 f0	 fadd	 DWORD PTR _uError$[ebp]
  000a1	d9 5d f0	 fstp	 DWORD PTR _uError$[ebp]

; 82   : 
; 83   :       if (uError.l < uMinError.l) 

  000a4	8b 4d f0	 mov	 ecx, DWORD PTR _uError$[ebp]
  000a7	3b 4d f8	 cmp	 ecx, DWORD PTR _uMinError$[ebp]
  000aa	7d 0c		 jge	 SHORT $L909

; 84   :       {
; 85   :          uMinError.l = uError.l;

  000ac	8b 55 f0	 mov	 edx, DWORD PTR _uError$[ebp]
  000af	89 55 f8	 mov	 DWORD PTR _uMinError$[ebp], edx

; 86   :          iIndex = i;

  000b2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000b5	89 45 ec	 mov	 DWORD PTR _iIndex$[ebp], eax
$L909:

; 87   :       }
; 88   :    }

  000b8	eb 97		 jmp	 SHORT $L907
$L908:

; 89   : 
; 90   :    return( iIndex );

  000ba	8b 45 ec	 mov	 eax, DWORD PTR _iIndex$[ebp]

; 91   : }

  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 0c 00	 ret	 12			; 0000000cH
_Dim2VectorQuantize@12 ENDP
_TEXT	ENDS
PUBLIC	_Dim2VectorLUT@16
PUBLIC	??_C@_0CB@EIGCPLHA@iIndex?5?$DM?5?$CIunsigned?5int?$CJ?5iEntries@ ; `string'
;	COMDAT ??_C@_0CB@EIGCPLHA@iIndex?5?$DM?5?$CIunsigned?5int?$CJ?5iEntries@
CONST	SEGMENT
??_C@_0CB@EIGCPLHA@iIndex?5?$DM?5?$CIunsigned?5int?$CJ?5iEntries@ DB 'iIn'
	DB	'dex < (unsigned int) iEntries', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _Dim2VectorLUT@16
_TEXT	SEGMENT
_iIndex$ = 8
_pfCodeBook$ = 12
_iEntries$ = 16
_pfVector$ = 20
_Dim2VectorLUT@16 PROC NEAR				; COMDAT

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 157  :    assert( pfCodeBook != NULL);

  00003	83 7d 0c 00	 cmp	 DWORD PTR _pfCodeBook$[ebp], 0
  00007	75 17		 jne	 SHORT $L946
  00009	68 9d 00 00 00	 push	 157			; 0000009dH
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DM@OKLCGLIK@c?3?2xbox?2private?2windows?2directx?2@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OHJAPAEA@pfCodeBook?5?$CB?$DN?5NULL?$AA@
  00018	e8 00 00 00 00	 call	 __assert
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L946:

; 158  :    assert( pfVector != NULL);

  00020	83 7d 14 00	 cmp	 DWORD PTR _pfVector$[ebp], 0
  00024	75 17		 jne	 SHORT $L947
  00026	68 9e 00 00 00	 push	 158			; 0000009eH
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DM@OKLCGLIK@c?3?2xbox?2private?2windows?2directx?2@
  00030	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@HOOFICEM@pfVector?5?$CB?$DN?5NULL?$AA@
  00035	e8 00 00 00 00	 call	 __assert
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L947:

; 159  :    assert( iIndex < (unsigned int) iEntries );

  0003d	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00040	3b 55 10	 cmp	 edx, DWORD PTR _iEntries$[ebp]
  00043	72 17		 jb	 SHORT $L948
  00045	68 9f 00 00 00	 push	 159			; 0000009fH
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DM@OKLCGLIK@c?3?2xbox?2private?2windows?2directx?2@
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@EIGCPLHA@iIndex?5?$DM?5?$CIunsigned?5int?$CJ?5iEntries@
  00054	e8 00 00 00 00	 call	 __assert
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
$L948:

; 160  : 
; 161  :    if (iIndex >= (unsigned int) iEntries)

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0005f	3b 4d 10	 cmp	 ecx, DWORD PTR _iEntries$[ebp]
  00062	72 07		 jb	 SHORT $L927

; 162  :       iIndex = 0;

  00064	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iIndex$[ebp], 0
$L927:

; 163  : 
; 164  :    pfCodeBook += (iIndex<<1);    /* increment pointer by 2*iIndex */

  0006b	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0006e	d1 e2		 shl	 edx, 1
  00070	8b 45 0c	 mov	 eax, DWORD PTR _pfCodeBook$[ebp]
  00073	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00076	89 4d 0c	 mov	 DWORD PTR _pfCodeBook$[ebp], ecx

; 165  :    *pfVector++ = *pfCodeBook++;

  00079	8b 55 14	 mov	 edx, DWORD PTR _pfVector$[ebp]
  0007c	8b 45 0c	 mov	 eax, DWORD PTR _pfCodeBook$[ebp]
  0007f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00081	89 0a		 mov	 DWORD PTR [edx], ecx
  00083	8b 55 14	 mov	 edx, DWORD PTR _pfVector$[ebp]
  00086	83 c2 04	 add	 edx, 4
  00089	89 55 14	 mov	 DWORD PTR _pfVector$[ebp], edx
  0008c	8b 45 0c	 mov	 eax, DWORD PTR _pfCodeBook$[ebp]
  0008f	83 c0 04	 add	 eax, 4
  00092	89 45 0c	 mov	 DWORD PTR _pfCodeBook$[ebp], eax

; 166  :    *pfVector   = *pfCodeBook;

  00095	8b 4d 14	 mov	 ecx, DWORD PTR _pfVector$[ebp]
  00098	8b 55 0c	 mov	 edx, DWORD PTR _pfCodeBook$[ebp]
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	89 01		 mov	 DWORD PTR [ecx], eax

; 167  : }

  0009f	5d		 pop	 ebp
  000a0	c2 10 00	 ret	 16			; 00000010H
_Dim2VectorLUT@16 ENDP
_TEXT	ENDS
END
