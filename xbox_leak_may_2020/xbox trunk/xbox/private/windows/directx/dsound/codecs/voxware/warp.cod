; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\warp.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxWarpSC36@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CalcWarpedFreq@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_VoxWarpSC36@8
EXTRN	__fltused:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\warp.c
;	COMDAT _VoxWarpSC36@8
_TEXT	SEGMENT
_iIndex$ = -16
_i0$ = -12
_i$ = -8
_lIndex$ = -4
_pfIn$ = 8
_pfOut$ = 12
_VoxWarpSC36@8 PROC NEAR				; COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 117  :    unsigned int i;
; 118  :    unsigned long i0;
; 119  :    unsigned long lIndex;
; 120  :    unsigned int iIndex;
; 121  : 
; 122  :    /*--------------------------------------------------------
; 123  :      Skip to the end of the pfOut array.  By starting at the 
; 124  :        end of the array where the envelope is compressed, 
; 125  :        the warping may be done in place.
; 126  :    --------------------------------------------------------*/
; 127  :    pfOut += 255;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _pfOut$[ebp]
  00009	05 fc 03 00 00	 add	 eax, 1020		; 000003fcH
  0000e	89 45 0c	 mov	 DWORD PTR _pfOut$[ebp], eax

; 128  : 
; 129  :    /*--------------------------------------------------------
; 130  :      Set the initial value for i0 in the quadratic region.  
; 131  :        This is: i0 = 162*255+128 = 41600
; 132  :    --------------------------------------------------------*/
; 133  :    i0 = 41600L;

  00011	c7 45 f4 80 a2
	00 00		 mov	 DWORD PTR _i0$[ebp], 41600 ; 0000a280H

; 134  : 
; 135  :    /*--------------------------------------------------------
; 136  :      Compute warping indices with a quadratic curve in the
; 137  :        region (86 < i < 256)
; 138  :    --------------------------------------------------------*/
; 139  :    for (i=255; i>86; i--)

  00018	c7 45 f8 ff 00
	00 00		 mov	 DWORD PTR _i$[ebp], 255	; 000000ffH
  0001f	eb 09		 jmp	 SHORT $L616
$L617:
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00024	83 e9 01	 sub	 ecx, 1
  00027	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$L616:
  0002a	83 7d f8 56	 cmp	 DWORD PTR _i$[ebp], 86	; 00000056H
  0002e	76 5e		 jbe	 SHORT $L618

; 140  :    {
; 141  :       i0 -= 162L;

  00030	8b 55 f4	 mov	 edx, DWORD PTR _i0$[ebp]
  00033	81 ea a2 00 00
	00		 sub	 edx, 162		; 000000a2H
  00039	89 55 f4	 mov	 DWORD PTR _i0$[ebp], edx

; 142  :       lIndex = i0 >> 8;

  0003c	8b 45 f4	 mov	 eax, DWORD PTR _i0$[ebp]
  0003f	c1 e8 08	 shr	 eax, 8
  00042	89 45 fc	 mov	 DWORD PTR _lIndex$[ebp], eax

; 143  :       lIndex += 65;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _lIndex$[ebp]
  00048	83 c1 41	 add	 ecx, 65			; 00000041H
  0004b	89 4d fc	 mov	 DWORD PTR _lIndex$[ebp], ecx

; 144  :       lIndex *= i;

  0004e	8b 55 fc	 mov	 edx, DWORD PTR _lIndex$[ebp]
  00051	0f af 55 f8	 imul	 edx, DWORD PTR _i$[ebp]
  00055	89 55 fc	 mov	 DWORD PTR _lIndex$[ebp], edx

; 145  :       lIndex += 209;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _lIndex$[ebp]
  0005b	05 d1 00 00 00	 add	 eax, 209		; 000000d1H
  00060	89 45 fc	 mov	 DWORD PTR _lIndex$[ebp], eax

; 146  :       iIndex = (int)(lIndex >> 8);

  00063	8b 4d fc	 mov	 ecx, DWORD PTR _lIndex$[ebp]
  00066	c1 e9 08	 shr	 ecx, 8
  00069	89 4d f0	 mov	 DWORD PTR _iIndex$[ebp], ecx

; 147  :       iIndex += 29;

  0006c	8b 55 f0	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0006f	83 c2 1d	 add	 edx, 29			; 0000001dH
  00072	89 55 f0	 mov	 DWORD PTR _iIndex$[ebp], edx

; 148  :       *pfOut-- = pfIn[iIndex];

  00075	8b 45 0c	 mov	 eax, DWORD PTR _pfOut$[ebp]
  00078	8b 4d f0	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0007b	8b 55 08	 mov	 edx, DWORD PTR _pfIn$[ebp]
  0007e	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00081	89 08		 mov	 DWORD PTR [eax], ecx
  00083	8b 55 0c	 mov	 edx, DWORD PTR _pfOut$[ebp]
  00086	83 ea 04	 sub	 edx, 4
  00089	89 55 0c	 mov	 DWORD PTR _pfOut$[ebp], edx

; 149  :    }

  0008c	eb 93		 jmp	 SHORT $L617
$L618:

; 150  :  
; 151  :    /*--------------------------------------------------------
; 152  :      Set the initial value for i0 in the linear region.  
; 153  :         This is: i0 = 203*87+128 = 17789
; 154  :    --------------------------------------------------------*/
; 155  :     i0 = 17789L;

  0008e	c7 45 f4 7d 45
	00 00		 mov	 DWORD PTR _i0$[ebp], 17789 ; 0000457dH

; 156  : 
; 157  :    /*--------------------------------------------------------
; 158  :      Compute warping indices with a linear curve in the
; 159  :        region (0 < i < 87)
; 160  :    --------------------------------------------------------*/
; 161  :    for (i=87; i; i--)

  00095	c7 45 f8 57 00
	00 00		 mov	 DWORD PTR _i$[ebp], 87	; 00000057H
  0009c	eb 09		 jmp	 SHORT $L620
$L621:
  0009e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000a1	83 e8 01	 sub	 eax, 1
  000a4	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L620:
  000a7	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  000ab	74 2e		 je	 SHORT $L611

; 162  :    {
; 163  :      i0 -= 203L;

  000ad	8b 4d f4	 mov	 ecx, DWORD PTR _i0$[ebp]
  000b0	81 e9 cb 00 00
	00		 sub	 ecx, 203		; 000000cbH
  000b6	89 4d f4	 mov	 DWORD PTR _i0$[ebp], ecx

; 164  :      iIndex = (int)(i0>>8);

  000b9	8b 55 f4	 mov	 edx, DWORD PTR _i0$[ebp]
  000bc	c1 ea 08	 shr	 edx, 8
  000bf	89 55 f0	 mov	 DWORD PTR _iIndex$[ebp], edx

; 165  :      *pfOut-- = pfIn[iIndex];

  000c2	8b 45 0c	 mov	 eax, DWORD PTR _pfOut$[ebp]
  000c5	8b 4d f0	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  000c8	8b 55 08	 mov	 edx, DWORD PTR _pfIn$[ebp]
  000cb	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  000ce	89 08		 mov	 DWORD PTR [eax], ecx
  000d0	8b 55 0c	 mov	 edx, DWORD PTR _pfOut$[ebp]
  000d3	83 ea 04	 sub	 edx, 4
  000d6	89 55 0c	 mov	 DWORD PTR _pfOut$[ebp], edx

; 166  :    }

  000d9	eb c3		 jmp	 SHORT $L621
$L611:

; 167  : }

  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c2 08 00	 ret	 8
_VoxWarpSC36@8 ENDP
_TEXT	ENDS
PUBLIC	_CalcWarpedFreq@4
PUBLIC	__real@42c20000
PUBLIC	__real@bad20000
PUBLIC	__real@3fb38000
PUBLIC	__real@3fe50000
PUBLIC	__real@3fa28000
;	COMDAT __real@42c20000
CONST	SEGMENT
__real@42c20000 DD 042c20000r			; 97
CONST	ENDS
;	COMDAT __real@bad20000
CONST	SEGMENT
__real@bad20000 DD 0bad20000r			; -0.00160217
CONST	ENDS
;	COMDAT __real@3fb38000
CONST	SEGMENT
__real@3fb38000 DD 03fb38000r			; 1.40234
CONST	ENDS
;	COMDAT __real@3fe50000
CONST	SEGMENT
__real@3fe50000 DD 03fe50000r			; 1.78906
CONST	ENDS
;	COMDAT __real@3fa28000
CONST	SEGMENT
__real@3fa28000 DD 03fa28000r			; 1.26953
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _CalcWarpedFreq@4
_TEXT	SEGMENT
_fWarpedFreq$ = -4
_fLinFreq$ = 8
_CalcWarpedFreq@4 PROC NEAR				; COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 194  :    float fWarpedFreq;
; 195  : 
; 196  :    if (fLinFreq>97.0F)

  00004	d9 45 08	 fld	 DWORD PTR _fLinFreq$[ebp]
  00007	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@42c20000
  0000d	df e0		 fnstsw	 ax
  0000f	f6 c4 41	 test	 ah, 65			; 00000041H
  00012	75 1d		 jne	 SHORT $L628

; 197  :    {
; 198  :       /*-----------------------------------------------------
; 199  :         Approximate the warping function with a quadratic
; 200  :           for frequencies above 97 DFT samples.
; 201  :       -----------------------------------------------------*/
; 202  :       fWarpedFreq = QUAD_C + fLinFreq*(QUAD_B+QUAD_A*fLinFreq);

  00014	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@bad20000
  0001a	d8 4d 08	 fmul	 DWORD PTR _fLinFreq$[ebp]
  0001d	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3fb38000
  00023	d8 4d 08	 fmul	 DWORD PTR _fLinFreq$[ebp]
  00026	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3fe50000
  0002c	d9 5d fc	 fstp	 DWORD PTR _fWarpedFreq$[ebp]

; 203  :    } else {

  0002f	eb 0c		 jmp	 SHORT $L629
$L628:

; 204  :       /*-----------------------------------------------------
; 205  :         Approximate the warping function with a straight line
; 206  :           for frequencies below 97 DFT samples.
; 207  :       -----------------------------------------------------*/
; 208  :       fWarpedFreq = LINEAR_A*fLinFreq;

  00031	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3fa28000
  00037	d8 4d 08	 fmul	 DWORD PTR _fLinFreq$[ebp]
  0003a	d9 5d fc	 fstp	 DWORD PTR _fWarpedFreq$[ebp]
$L629:

; 209  :    }
; 210  : 
; 211  :    return( fWarpedFreq );

  0003d	d9 45 fc	 fld	 DWORD PTR _fWarpedFreq$[ebp]

; 212  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
_CalcWarpedFreq@4 ENDP
_TEXT	ENDS
END
