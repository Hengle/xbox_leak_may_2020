; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\kaiwin.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DP@IJOJEFBA@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@BBGPKNE@fWindow?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@IEMHKGKL@?$CIiWindowSize?91?$CJ?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _Bessel@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KaiserWindow@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _InitKaiserWindow@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _FreeKaiserWindow@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	??_C@_0DP@IJOJEFBA@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BA@BBGPKNE@fWindow?5?$CB?$DN?5NULL?$AA@	; `string'
PUBLIC	??_C@_0BE@IEMHKGKL@?$CIiWindowSize?91?$CJ?5?$DO?50?$AA@ ; `string'
PUBLIC	__real@3f800000
PUBLIC	_KaiserWindow@12
EXTRN	__fltused:NEAR
EXTRN	__assert:NEAR
EXTRN	_sqrt:NEAR
;	COMDAT ??_C@_0DP@IJOJEFBA@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\kaiwin.c
CONST	SEGMENT
??_C@_0DP@IJOJEFBA@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\kaiwin.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BBGPKNE@fWindow?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BA@BBGPKNE@fWindow?5?$CB?$DN?5NULL?$AA@ DB 'fWindow != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IEMHKGKL@?$CIiWindowSize?91?$CJ?5?$DO?50?$AA@
CONST	SEGMENT
??_C@_0BE@IEMHKGKL@?$CIiWindowSize?91?$CJ?5?$DO?50?$AA@ DB '(iWindowSize-'
	DB	'1) > 0', 00H				; `string'
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _KaiserWindow@12
_TEXT	SEGMENT
tv155 = -40
_fInvN$ = -36
_iHalfSize$ = -32
_z$ = -28
_iN$ = -24
_fInvI0B$ = -20
_i$ = -16
_fI0B$ = -12
_x$ = -8
_y$ = -4
_fWindow$ = 8
_iWindowSize$ = 12
_fBeta$ = 16
_KaiserWindow@12 PROC NEAR				; COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 116  :   float fI0B;
; 117  :   float fInvI0B;
; 118  :   float fInvN;
; 119  :   int iN;
; 120  :   int iHalfSize;
; 121  :   int i;
; 122  :   float x, y, z;
; 123  :   
; 124  :   assert(fWindow != NULL);

  00006	83 7d 08 00	 cmp	 DWORD PTR _fWindow$[ebp], 0
  0000a	75 14		 jne	 SHORT $L1084
  0000c	6a 7c		 push	 124			; 0000007cH
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@IJOJEFBA@c?3?2xbox?2private?2windows?2directx?2@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@BBGPKNE@fWindow?5?$CB?$DN?5NULL?$AA@
  00018	e8 00 00 00 00	 call	 __assert
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1084:

; 125  :   assert( (iWindowSize-1) > 0 );

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _iWindowSize$[ebp]
  00023	83 e9 01	 sub	 ecx, 1
  00026	85 c9		 test	 ecx, ecx
  00028	7f 14		 jg	 SHORT $L1085
  0002a	6a 7d		 push	 125			; 0000007dH
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@IJOJEFBA@c?3?2xbox?2private?2windows?2directx?2@
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@IEMHKGKL@?$CIiWindowSize?91?$CJ?5?$DO?50?$AA@
  00036	e8 00 00 00 00	 call	 __assert
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1085:

; 126  : 
; 127  :   /**** initialization ****/
; 128  :   iN = iWindowSize - 1;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _iWindowSize$[ebp]
  00041	83 e8 01	 sub	 eax, 1
  00044	89 45 e8	 mov	 DWORD PTR _iN$[ebp], eax

; 129  :   fI0B = Bessel(fBeta);

  00047	8b 4d 10	 mov	 ecx, DWORD PTR _fBeta$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _Bessel@4
  00050	d9 5d f4	 fstp	 DWORD PTR _fI0B$[ebp]

; 130  :   fInvI0B=1.0F/fI0B;

  00053	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  00059	d8 75 f4	 fdiv	 DWORD PTR _fI0B$[ebp]
  0005c	d9 5d ec	 fstp	 DWORD PTR _fInvI0B$[ebp]

; 131  :   fInvN=1.0F/(float)iN;

  0005f	db 45 e8	 fild	 DWORD PTR _iN$[ebp]
  00062	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@3f800000
  00068	d9 5d dc	 fstp	 DWORD PTR _fInvN$[ebp]

; 132  :   iHalfSize = iWindowSize >> 1;

  0006b	8b 55 0c	 mov	 edx, DWORD PTR _iWindowSize$[ebp]
  0006e	d1 fa		 sar	 edx, 1
  00070	89 55 e0	 mov	 DWORD PTR _iHalfSize$[ebp], edx

; 133  : 
; 134  :   /**** compute the window value of the most left point ****/
; 135  :   fWindow[0] = fInvI0B;

  00073	8b 45 08	 mov	 eax, DWORD PTR _fWindow$[ebp]
  00076	8b 4d ec	 mov	 ecx, DWORD PTR _fInvI0B$[ebp]
  00079	89 08		 mov	 DWORD PTR [eax], ecx

; 136  : 
; 137  :   /**** compute window value at [1...iHalfSize] ****/
; 138  :   for (i=1 ; i<iHalfSize; i++) 

  0007b	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00082	eb 09		 jmp	 SHORT $L1046
$L1047:
  00084	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00087	83 c2 01	 add	 edx, 1
  0008a	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx
$L1046:
  0008d	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00090	3b 45 e0	 cmp	 eax, DWORD PTR _iHalfSize$[ebp]
  00093	7d 53		 jge	 SHORT $L1048

; 139  :     { 
; 140  :       z = 2.0F*((float)i*fInvN);

  00095	db 45 f0	 fild	 DWORD PTR _i$[ebp]
  00098	d8 4d dc	 fmul	 DWORD PTR _fInvN$[ebp]
  0009b	dc c0		 fadd	 ST(0), ST(0)
  0009d	d9 55 e4	 fst	 DWORD PTR _z$[ebp]

; 141  :       z -= 1.0F;  /*** 1/N to prevent sensitivity calculation ***/

  000a0	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3f800000
  000a6	d9 55 e4	 fst	 DWORD PTR _z$[ebp]

; 142  :       x = -(z * z);

  000a9	d8 4d e4	 fmul	 DWORD PTR _z$[ebp]
  000ac	d9 e0		 fchs
  000ae	d9 55 f8	 fst	 DWORD PTR _x$[ebp]

; 143  :       x += 1.0F;

  000b1	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  000b7	d9 55 f8	 fst	 DWORD PTR _x$[ebp]

; 144  :       y = fBeta*(float)sqrt(x);

  000ba	83 ec 08	 sub	 esp, 8
  000bd	dd 1c 24	 fstp	 QWORD PTR [esp]
  000c0	e8 00 00 00 00	 call	 _sqrt
  000c5	83 c4 08	 add	 esp, 8
  000c8	d9 55 d8	 fst	 DWORD PTR tv155[ebp]
  000cb	d8 4d 10	 fmul	 DWORD PTR _fBeta$[ebp]
  000ce	d9 5d fc	 fstp	 DWORD PTR _y$[ebp]

; 145  :       fWindow[i] = Bessel(y)*fInvI0B;

  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _y$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 _Bessel@4
  000da	d8 4d ec	 fmul	 DWORD PTR _fInvI0B$[ebp]
  000dd	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  000e0	8b 45 08	 mov	 eax, DWORD PTR _fWindow$[ebp]
  000e3	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]

; 146  :     }

  000e6	eb 9c		 jmp	 SHORT $L1047
$L1048:

; 147  :   
; 148  :   /**** Compute the center point ****/
; 149  :   if ( iWindowSize & 1 )

  000e8	8b 4d 0c	 mov	 ecx, DWORD PTR _iWindowSize$[ebp]
  000eb	83 e1 01	 and	 ecx, 1
  000ee	85 c9		 test	 ecx, ecx
  000f0	74 0d		 je	 SHORT $L1029

; 150  :      fWindow[i] = 1.0F;

  000f2	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  000f5	8b 45 08	 mov	 eax, DWORD PTR _fWindow$[ebp]
  000f8	c7 04 90 00 00
	80 3f		 mov	 DWORD PTR [eax+edx*4], 1065353216 ; 3f800000H
$L1029:

; 151  : }

  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 0c 00	 ret	 12			; 0000000cH
_KaiserWindow@12 ENDP
_TEXT	ENDS
PUBLIC	__real@3f000000
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _Bessel@4
_TEXT	SEGMENT
tv82 = -36
_ftmp$ = -32
_z0$ = -28
_z$ = -24
_xk$ = -20
_i$ = -16
_halfx$ = -12
_y$ = -8
_MAXiteration$ = -4
_x$ = 8
_Bessel@4 PROC NEAR					; COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 64   :    int i;
; 65   :    float y,z,xk,z0;
; 66   :    float halfx;
; 67   :    float ftmp;
; 68   :    const int MAXiteration = BESSEL_ITERATIONS;

  00006	c7 45 fc 14 00
	00 00		 mov	 DWORD PTR _MAXiteration$[ebp], 20 ; 00000014H

; 69   : 
; 70   :    halfx = 0.5F*x;

  0000d	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000
  00013	d8 4d 08	 fmul	 DWORD PTR _x$[ebp]
  00016	d9 5d f4	 fstp	 DWORD PTR _halfx$[ebp]

; 71   :    z = 1.0F;

  00019	c7 45 e8 00 00
	80 3f		 mov	 DWORD PTR _z$[ebp], 1065353216 ; 3f800000H

; 72   :    y = halfx;

  00020	8b 45 f4	 mov	 eax, DWORD PTR _halfx$[ebp]
  00023	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax

; 73   :    xk = 1.0F;

  00026	c7 45 ec 00 00
	80 3f		 mov	 DWORD PTR _xk$[ebp], 1065353216 ; 3f800000H

; 74   : 
; 75   :    for (i=1; i<=MAXiteration; i++)    /* iterate BESSEL_ITERATIONS times */

  0002d	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00034	eb 09		 jmp	 SHORT $L1018
$L1019:
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00039	83 c1 01	 add	 ecx, 1
  0003c	89 4d f0	 mov	 DWORD PTR _i$[ebp], ecx
$L1018:
  0003f	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00042	3b 55 fc	 cmp	 edx, DWORD PTR _MAXiteration$[ebp]
  00045	7f 35		 jg	 SHORT $L1020

; 76   :    {  
; 77   :       z0 = y * xk;

  00047	d9 45 f8	 fld	 DWORD PTR _y$[ebp]
  0004a	d8 4d ec	 fmul	 DWORD PTR _xk$[ebp]
  0004d	d9 55 e4	 fst	 DWORD PTR _z0$[ebp]

; 78   :       ftmp = z0 * z0;   /* ftmp added to improve cross-platform effects */

  00050	d8 4d e4	 fmul	 DWORD PTR _z0$[ebp]
  00053	d9 5d e0	 fstp	 DWORD PTR _ftmp$[ebp]

; 79   :       z += ftmp;

  00056	d9 45 e8	 fld	 DWORD PTR _z$[ebp]
  00059	d8 45 e0	 fadd	 DWORD PTR _ftmp$[ebp]
  0005c	d9 5d e8	 fstp	 DWORD PTR _z$[ebp]

; 80   :       xk = xk /(float)(i+1);

  0005f	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00062	83 c0 01	 add	 eax, 1
  00065	89 45 dc	 mov	 DWORD PTR tv82[ebp], eax
  00068	db 45 dc	 fild	 DWORD PTR tv82[ebp]
  0006b	d8 7d ec	 fdivr	 DWORD PTR _xk$[ebp]
  0006e	d9 5d ec	 fstp	 DWORD PTR _xk$[ebp]

; 81   :       y *= halfx;

  00071	d9 45 f8	 fld	 DWORD PTR _y$[ebp]
  00074	d8 4d f4	 fmul	 DWORD PTR _halfx$[ebp]
  00077	d9 5d f8	 fstp	 DWORD PTR _y$[ebp]

; 82   :    }

  0007a	eb ba		 jmp	 SHORT $L1019
$L1020:

; 83   :    return((float)z);

  0007c	d9 45 e8	 fld	 DWORD PTR _z$[ebp]

; 84   : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
_Bessel@4 ENDP
_TEXT	ENDS
PUBLIC	_InitKaiserWindow@12
EXTRN	_malloc:NEAR
; Function compile flags: /Odt
;	COMDAT _InitKaiserWindow@12
_TEXT	SEGMENT
_retFlag$ = -4
_pfWindow$ = 8
_iWindowSize$ = 12
_fBeta$ = 16
_InitKaiserWindow@12 PROC NEAR				; COMDAT

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 183  :   unsigned short retFlag = 0;

  00004	66 c7 45 fc 00
	00		 mov	 WORD PTR _retFlag$[ebp], 0

; 184  : 
; 185  :   /***** allocate the memory *****/
; 186  :   *pfWindow = (float *)malloc(((iWindowSize+1)>>1) * sizeof(float));

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _iWindowSize$[ebp]
  0000d	83 c0 01	 add	 eax, 1
  00010	d1 f8		 sar	 eax, 1
  00012	c1 e0 02	 shl	 eax, 2
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _malloc
  0001b	83 c4 04	 add	 esp, 4
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _pfWindow$[ebp]
  00021	89 01		 mov	 DWORD PTR [ecx], eax

; 187  :   if (*pfWindow == NULL)

  00023	8b 55 08	 mov	 edx, DWORD PTR _pfWindow$[ebp]
  00026	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00029	75 08		 jne	 SHORT $L1063

; 188  :     retFlag = 1;

  0002b	66 c7 45 fc 01
	00		 mov	 WORD PTR _retFlag$[ebp], 1

; 189  :   else 

  00031	eb 13		 jmp	 SHORT $L1064
$L1063:

; 190  :     {
; 191  :       /***** compute the Kaiser window ******/
; 192  :       KaiserWindow(*pfWindow, iWindowSize, fBeta);

  00033	8b 45 10	 mov	 eax, DWORD PTR _fBeta$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _iWindowSize$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _pfWindow$[ebp]
  0003e	8b 02		 mov	 eax, DWORD PTR [edx]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _KaiserWindow@12
$L1064:

; 193  :     }
; 194  :   
; 195  :   return retFlag;

  00046	66 8b 45 fc	 mov	 ax, WORD PTR _retFlag$[ebp]

; 196  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 0c 00	 ret	 12			; 0000000cH
_InitKaiserWindow@12 ENDP
_TEXT	ENDS
PUBLIC	_FreeKaiserWindow@4
EXTRN	_free:NEAR
; Function compile flags: /Odt
;	COMDAT _FreeKaiserWindow@4
_TEXT	SEGMENT
_pfWindow$ = 8
_FreeKaiserWindow@4 PROC NEAR				; COMDAT

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 215  :   SafeFree(*pfWindow);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pfWindow$[ebp]
  00006	83 38 00	 cmp	 DWORD PTR [eax], 0
  00009	74 17		 je	 SHORT $L1067
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _pfWindow$[ebp]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _free
  00016	83 c4 04	 add	 esp, 4
  00019	8b 45 08	 mov	 eax, DWORD PTR _pfWindow$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L1067:

; 216  : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
_FreeKaiserWindow@4 ENDP
_TEXT	ENDS
END
