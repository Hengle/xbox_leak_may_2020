; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\lowrate_common.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_0EP@MODOKKIF@c?3?2xbox?2private?2windows?2directx?2@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
;	COMDAT ??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
WMADEC_RD	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RD	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
WMADEC_RW	SEGMENT DWORD USE32 PUBLIC ''
WMADEC_RW	ENDS
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _quickRand@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _LOG2@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT @ByteSwap@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _FloatToLong@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _iResampleIndex@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _iUnResampleIndex@16
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvScanForNextBarkIndex@28
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _ffltMaskPower10@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvGetBandWeightMidRate_XDS@28
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _CoefPlusNoiseInvQuant@28
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvInitNoiseSub_XDS@4
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _auResampleWeightFactorLPC_XDS@8
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _prvInverseQuantizeMidRate_XDS@12
WMADEC	SEGMENT PARA USE32 PUBLIC ''
WMADEC	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, WMADEC_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_DSoundBuildNumberD
PUBLIC	_cDitherFactorMR
PUBLIC	_cfltInverseRand2Float_XDS
WMADEC_RD	SEGMENT
_WMA_OK	DD	00H
_WMA_S_FALSE DD	01H
_WMA_S_BUFUNDERFLOW DD 02H
_WMA_S_NEWPACKET DD 03H
_WMA_S_NO_MORE_FRAME DD 04H
_WMA_S_DEFAULT DD 05H
_WMA_S_SWITCHCHMODE DD 06H
_WMA_E_FAIL DD	080004005H
_WMA_E_OUTOFMEMORY DD 08007000eH
_WMA_E_INVALIDARG DD 080070057H
_WMA_E_NOTSUPPORTED DD 080040000H
_WMA_E_LOSTPACKET DD 080040001H
_WMA_E_BROKEN_FRAME DD 080040002H
_WMA_E_BUFFEROVERFLOW DD 080040003H
_WMA_E_ONHOLD DD 080040004H
_WMA_E_BUFFERUNDERFLOW DD 080040005H
_WMA_E_INVALIDRECHDR DD 080040006H
_WMA_E_SYNCERROR DD 080040007H
_WMA_E_NOTIMPL DD 080040008H
_WMA_E_FLUSHOVERFLOW DD 080040009H
WMADEC_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT
_DSoundBuildNumberD DW 05344H
	DW	0554fH
	DW	0444eH
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
WMADEC_RD	SEGMENT
_cDitherFactorMR DD 03ca3d70ar			; 0.02
_cfltInverseRand2Float_XDS DD 031000000r	; 1.86265e-009
WMADEC_RD	ENDS
PUBLIC	_prvGetBandWeightMidRate_XDS@28
EXTRN	_sqrt:NEAR
EXTRN	__fltused:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\lowrate_common.c
;	COMDAT _prvGetBandWeightMidRate_XDS@28
WMADEC	SEGMENT
tv422 = -192
tv420 = -188
tv418 = -184
tv170 = -180
tv162 = -176
tv154 = -172
tv93 = -168
tv74 = -164
_fltP2$2487 = -160
_fltP1$2486 = -156
_iUnRsmpEnd$2488 = -152
_iMaskStart$ = -148
_rgiMaskQ$ = -144
_iCurrStart$ = -140
_iMaskEnd$ = -136
_iRsmpBand$ = -132
_fAllBandsSynced$ = -128
_rgffltSqrtBWRatio$ = -124
_flt$ = -120
_iRsmpStart$ = -116
_iCurrEnd$ = -112
_iMaskBand$ = -108
_iRsmpEnd$ = -104
_rgiMaskQ4BandNotCoded$ = -100
_fltBandWeight$ = -60
_cMaskHighCutOff$ = -20
_iCurrBand$ = -16
_cNoiseBand$ = -9
_fflt$ = -8
_rgbBandNotCoded$ = -4
_pau$ = 8
_ppcinfo$ = 12
_rgiBarkIndex$ = 16
_rgiBarkIndexResampled$ = 20
_MRI$ = 24
_prvGetBandWeightMidRate_XDS@28 PROC NEAR		; COMDAT

; 721  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H

; 722  :     U8*	rgbBandNotCoded			 = ppcinfo->m_rgbBandNotCoded;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	89 4d fc	 mov	 DWORD PTR _rgbBandNotCoded$[ebp], ecx

; 723  : 	FastFloat* rgffltSqrtBWRatio = ppcinfo->m_rgffltSqrtBWRatio;

  00012	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00015	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00018	89 45 84	 mov	 DWORD PTR _rgffltSqrtBWRatio$[ebp], eax

; 724  : 	Int* rgiMaskQ				 = ppcinfo->m_rgiMaskQ;

  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  0001e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00021	89 95 70 ff ff
	ff		 mov	 DWORD PTR _rgiMaskQ$[ebp], edx

; 725  : 	U8 cNoiseBand	= 0;

  00027	c6 45 f7 00	 mov	 BYTE PTR _cNoiseBand$[ebp], 0

; 726  : 	FastFloat fflt;
; 727  : 	Float flt;
; 728  : 	Int iCurrStart, iCurrBand, iCurrEnd;	// indexes for the current subframe
; 729  : 	Int iMaskStart, iMaskBand, iMaskEnd;	// indexes in the subframe where the MaskQ's were last updated
; 730  : 	Int iRsmpStart, iRsmpBand, iRsmpEnd;	// indexes for the current subframe resampled to the subframe where the MaskQ's were last updated
; 731  : 	int fAllBandsSynced = MRI.iMaskResampleRatioPow==MASKQ_RESAMPLE_OFFSET 
; 732  : 		|| ( pau->m_iVersion!=1 && 32000 <= pau->m_iSamplingRate && pau->m_iSamplingRate < 44100 );

  0002b	83 7d 1c 06	 cmp	 DWORD PTR _MRI$[ebp+4], 6
  0002f	74 2d		 je	 SHORT $L2775
  00031	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00034	83 78 44 01	 cmp	 DWORD PTR [eax+68], 1
  00038	74 18		 je	 SHORT $L2774
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0003d	81 79 54 00 7d
	00 00		 cmp	 DWORD PTR [ecx+84], 32000 ; 00007d00H
  00044	7c 0c		 jl	 SHORT $L2774
  00046	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00049	81 7a 54 44 ac
	00 00		 cmp	 DWORD PTR [edx+84], 44100 ; 0000ac44H
  00050	7c 0c		 jl	 SHORT $L2775
$L2774:
  00052	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], 0
  0005c	eb 0a		 jmp	 SHORT $L2776
$L2775:
  0005e	c7 85 5c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv74[ebp], 1
$L2776:
  00068	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv74[ebp]
  0006e	89 45 80	 mov	 DWORD PTR _fAllBandsSynced$[ebp], eax

; 733  : 	Int rgiMaskQ4BandNotCoded[10];			// used if bands Syncronized
; 734  : 	Float fltBandWeight[10];				// used if bands are no Syncronized
; 735  : 	Int cMaskHighCutOff;
; 736  :     FUNCTION_PROFILE(fp);
; 737  :     FUNCTION_PROFILE_START(&fp,GET_BAND_WEIGHTS_PROFILE);
; 738  : 
; 739  : 	iCurrBand = pau->m_iFirstNoiseBand;

  00071	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00074	8b 91 c0 03 00
	00		 mov	 edx, DWORD PTR [ecx+960]
  0007a	89 55 f0	 mov	 DWORD PTR _iCurrBand$[ebp], edx

; 740  : 	iMaskBand = iRsmpBand = 0;

  0007d	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _iRsmpBand$[ebp], 0
  00087	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _iRsmpBand$[ebp]
  0008d	89 45 94	 mov	 DWORD PTR _iMaskBand$[ebp], eax

; 741  : 	if ( !fAllBandsSynced )

  00090	83 7d 80 00	 cmp	 DWORD PTR _fAllBandsSynced$[ebp], 0
  00094	75 39		 jne	 SHORT $L2472

; 742  : 		cMaskHighCutOff = iResampleIndex( pau->m_cSubband, MRI ) * pau->m_cHighCutOffLong / pau->m_cFrameSampleHalf;

  00096	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00099	8b cc		 mov	 ecx, esp
  0009b	8b 55 18	 mov	 edx, DWORD PTR _MRI$[ebp]
  0009e	89 11		 mov	 DWORD PTR [ecx], edx
  000a0	8b 45 1c	 mov	 eax, DWORD PTR _MRI$[ebp+4]
  000a3	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000a6	8b 55 20	 mov	 edx, DWORD PTR _MRI$[ebp+8]
  000a9	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000ac	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000af	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 _iResampleIndex@16
  000b8	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000bb	0f af 82 30 03
	00 00		 imul	 eax, DWORD PTR [edx+816]
  000c2	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000c5	99		 cdq
  000c6	f7 b9 1c 03 00
	00		 idiv	 DWORD PTR [ecx+796]
  000cc	89 45 ec	 mov	 DWORD PTR _cMaskHighCutOff$[ebp], eax
$L2472:

; 743  : 
; 744  :     while (WMAB_TRUE)    {

  000cf	ba 01 00 00 00	 mov	 edx, 1
  000d4	85 d2		 test	 edx, edx
  000d6	0f 84 ee 02 00
	00		 je	 $L2473

; 745  :         assert (iCurrBand <= pau->m_cValidBarkBand);
; 746  :         iCurrStart = max( rgiBarkIndex [iCurrBand], pau->m_iFirstNoiseIndex );

  000dc	8b 45 f0	 mov	 eax, DWORD PTR _iCurrBand$[ebp]
  000df	8b 4d 10	 mov	 ecx, DWORD PTR _rgiBarkIndex$[ebp]
  000e2	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000e5	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000e8	3b 82 c4 03 00
	00		 cmp	 eax, DWORD PTR [edx+964]
  000ee	7e 11		 jle	 SHORT $L2777
  000f0	8b 4d f0	 mov	 ecx, DWORD PTR _iCurrBand$[ebp]
  000f3	8b 55 10	 mov	 edx, DWORD PTR _rgiBarkIndex$[ebp]
  000f6	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  000f9	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  000ff	eb 0f		 jmp	 SHORT $L2778
$L2777:
  00101	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00104	8b 91 c4 03 00
	00		 mov	 edx, DWORD PTR [ecx+964]
  0010a	89 95 58 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], edx
$L2778:
  00110	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv93[ebp]
  00116	89 85 74 ff ff
	ff		 mov	 DWORD PTR _iCurrStart$[ebp], eax

; 747  :         if (iCurrStart >= pau->m_cHighCutOff)

  0011c	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0011f	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _iCurrStart$[ebp]
  00125	3b 91 28 03 00
	00		 cmp	 edx, DWORD PTR [ecx+808]
  0012b	7c 05		 jl	 SHORT $L2474

; 748  :             break;

  0012d	e9 98 02 00 00	 jmp	 $L2473
$L2474:

; 749  : 
; 750  : 		if (rgbBandNotCoded [iCurrBand] == 1)	{

  00132	8b 45 fc	 mov	 eax, DWORD PTR _rgbBandNotCoded$[ebp]
  00135	03 45 f0	 add	 eax, DWORD PTR _iCurrBand$[ebp]
  00138	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0013b	83 f9 01	 cmp	 ecx, 1
  0013e	0f 85 78 02 00
	00		 jne	 $L2475

; 751  : 			assert( cNoiseBand < 10 );		// probably (cNoiseBand < 5) would be OK
; 752  : 
; 753  : 			// Determine the band for accessing the possibly resampled MaskQ's
; 754  : 			iMaskStart = iResampleIndex( iCurrStart, MRI );

  00144	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00147	8b d4		 mov	 edx, esp
  00149	8b 45 18	 mov	 eax, DWORD PTR _MRI$[ebp]
  0014c	89 02		 mov	 DWORD PTR [edx], eax
  0014e	8b 4d 1c	 mov	 ecx, DWORD PTR _MRI$[ebp+4]
  00151	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00154	8b 45 20	 mov	 eax, DWORD PTR _MRI$[ebp+8]
  00157	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0015a	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _iCurrStart$[ebp]
  00160	51		 push	 ecx
  00161	e8 00 00 00 00	 call	 _iResampleIndex@16
  00166	89 85 6c ff ff
	ff		 mov	 DWORD PTR _iMaskStart$[ebp], eax
$L2477:

; 755  : 			while ( rgiBarkIndexResampled [iMaskBand+1] <= iMaskStart ) 

  0016c	8b 55 94	 mov	 edx, DWORD PTR _iMaskBand$[ebp]
  0016f	8b 45 14	 mov	 eax, DWORD PTR _rgiBarkIndexResampled$[ebp]
  00172	8b 4c 90 04	 mov	 ecx, DWORD PTR [eax+edx*4+4]
  00176	3b 8d 6c ff ff
	ff		 cmp	 ecx, DWORD PTR _iMaskStart$[ebp]
  0017c	7f 0b		 jg	 SHORT $L2478

; 756  : 				++iMaskBand;

  0017e	8b 55 94	 mov	 edx, DWORD PTR _iMaskBand$[ebp]
  00181	83 c2 01	 add	 edx, 1
  00184	89 55 94	 mov	 DWORD PTR _iMaskBand$[ebp], edx
  00187	eb e3		 jmp	 SHORT $L2477
$L2478:

; 757  : 
; 758  : 			if ( fAllBandsSynced )

  00189	83 7d 80 00	 cmp	 DWORD PTR _fAllBandsSynced$[ebp], 0
  0018d	74 19		 je	 SHORT $L2479

; 759  : 			{	// Current subFrame bands synced to band were MaskQ's were last updated
; 760  : 				rgiMaskQ4BandNotCoded[cNoiseBand] = rgiMaskQ[iMaskBand];

  0018f	0f b6 45 f7	 movzx	 eax, BYTE PTR _cNoiseBand$[ebp]
  00193	8b 4d 94	 mov	 ecx, DWORD PTR _iMaskBand$[ebp]
  00196	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _rgiMaskQ$[ebp]
  0019c	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0019f	89 4c 85 9c	 mov	 DWORD PTR _rgiMaskQ4BandNotCoded$[ebp+eax*4], ecx

; 761  : 			}
; 762  : 			else

  001a3	e9 0b 02 00 00	 jmp	 $L2480
$L2479:

; 763  : 			{	// Have to check in detail about whether one or two MaskQ's are used by this BandNotCoded
; 764  : 				iCurrEnd   = min ( pau->m_cHighCutOff, rgiBarkIndex [iCurrBand + 1]);

  001a8	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  001ab	8b 45 f0	 mov	 eax, DWORD PTR _iCurrBand$[ebp]
  001ae	8b 4d 10	 mov	 ecx, DWORD PTR _rgiBarkIndex$[ebp]
  001b1	8b 92 28 03 00
	00		 mov	 edx, DWORD PTR [edx+808]
  001b7	3b 54 81 04	 cmp	 edx, DWORD PTR [ecx+eax*4+4]
  001bb	7d 11		 jge	 SHORT $L2779
  001bd	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001c0	8b 88 28 03 00
	00		 mov	 ecx, DWORD PTR [eax+808]
  001c6	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv154[ebp], ecx
  001cc	eb 10		 jmp	 SHORT $L2780
$L2779:
  001ce	8b 55 f0	 mov	 edx, DWORD PTR _iCurrBand$[ebp]
  001d1	8b 45 10	 mov	 eax, DWORD PTR _rgiBarkIndex$[ebp]
  001d4	8b 4c 90 04	 mov	 ecx, DWORD PTR [eax+edx*4+4]
  001d8	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv154[ebp], ecx
$L2780:
  001de	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv154[ebp]
  001e4	89 55 90	 mov	 DWORD PTR _iCurrEnd$[ebp], edx

; 765  : 				assert (iCurrEnd >= iCurrStart);
; 766  : 				iRsmpStart = iMaskStart;

  001e7	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _iMaskStart$[ebp]
  001ed	89 45 8c	 mov	 DWORD PTR _iRsmpStart$[ebp], eax

; 767  : 				iMaskEnd = min( rgiBarkIndexResampled [ iMaskBand+1 ], cMaskHighCutOff );

  001f0	8b 4d 94	 mov	 ecx, DWORD PTR _iMaskBand$[ebp]
  001f3	8b 55 14	 mov	 edx, DWORD PTR _rgiBarkIndexResampled$[ebp]
  001f6	8b 44 8a 04	 mov	 eax, DWORD PTR [edx+ecx*4+4]
  001fa	3b 45 ec	 cmp	 eax, DWORD PTR _cMaskHighCutOff$[ebp]
  001fd	7d 12		 jge	 SHORT $L2781
  001ff	8b 4d 94	 mov	 ecx, DWORD PTR _iMaskBand$[ebp]
  00202	8b 55 14	 mov	 edx, DWORD PTR _rgiBarkIndexResampled$[ebp]
  00205	8b 44 8a 04	 mov	 eax, DWORD PTR [edx+ecx*4+4]
  00209	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv162[ebp], eax
  0020f	eb 09		 jmp	 SHORT $L2782
$L2781:
  00211	8b 4d ec	 mov	 ecx, DWORD PTR _cMaskHighCutOff$[ebp]
  00214	89 8d 50 ff ff
	ff		 mov	 DWORD PTR tv162[ebp], ecx
$L2782:
  0021a	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv162[ebp]
  00220	89 95 78 ff ff
	ff		 mov	 DWORD PTR _iMaskEnd$[ebp], edx

; 768  : 				iRsmpEnd = min( iResampleIndex( iCurrEnd, MRI ), cMaskHighCutOff );

  00226	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00229	8b c4		 mov	 eax, esp
  0022b	8b 4d 18	 mov	 ecx, DWORD PTR _MRI$[ebp]
  0022e	89 08		 mov	 DWORD PTR [eax], ecx
  00230	8b 55 1c	 mov	 edx, DWORD PTR _MRI$[ebp+4]
  00233	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00236	8b 4d 20	 mov	 ecx, DWORD PTR _MRI$[ebp+8]
  00239	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0023c	8b 55 90	 mov	 edx, DWORD PTR _iCurrEnd$[ebp]
  0023f	52		 push	 edx
  00240	e8 00 00 00 00	 call	 _iResampleIndex@16
  00245	3b 45 ec	 cmp	 eax, DWORD PTR _cMaskHighCutOff$[ebp]
  00248	7d 27		 jge	 SHORT $L2783
  0024a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0024d	8b c4		 mov	 eax, esp
  0024f	8b 4d 18	 mov	 ecx, DWORD PTR _MRI$[ebp]
  00252	89 08		 mov	 DWORD PTR [eax], ecx
  00254	8b 55 1c	 mov	 edx, DWORD PTR _MRI$[ebp+4]
  00257	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0025a	8b 4d 20	 mov	 ecx, DWORD PTR _MRI$[ebp+8]
  0025d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00260	8b 55 90	 mov	 edx, DWORD PTR _iCurrEnd$[ebp]
  00263	52		 push	 edx
  00264	e8 00 00 00 00	 call	 _iResampleIndex@16
  00269	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv170[ebp], eax
  0026f	eb 09		 jmp	 SHORT $L2784
$L2783:
  00271	8b 45 ec	 mov	 eax, DWORD PTR _cMaskHighCutOff$[ebp]
  00274	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv170[ebp], eax
$L2784:
  0027a	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv170[ebp]
  00280	89 4d 98	 mov	 DWORD PTR _iRsmpEnd$[ebp], ecx
$L2482:

; 769  : 				while ( rgiBarkIndexResampled [iRsmpBand+1] <= (iRsmpEnd-1) ) 

  00283	8b 55 98	 mov	 edx, DWORD PTR _iRsmpEnd$[ebp]
  00286	83 ea 01	 sub	 edx, 1
  00289	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _iRsmpBand$[ebp]
  0028f	8b 4d 14	 mov	 ecx, DWORD PTR _rgiBarkIndexResampled$[ebp]
  00292	39 54 81 04	 cmp	 DWORD PTR [ecx+eax*4+4], edx
  00296	7f 11		 jg	 SHORT $L2483

; 770  : 					++iRsmpBand;

  00298	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _iRsmpBand$[ebp]
  0029e	83 c2 01	 add	 edx, 1
  002a1	89 95 7c ff ff
	ff		 mov	 DWORD PTR _iRsmpBand$[ebp], edx
  002a7	eb da		 jmp	 SHORT $L2482
$L2483:

; 771  : 				assert( iMaskBand == iRsmpBand || (iMaskBand+1) == iRsmpBand );
; 772  : 				if ( iRsmpBand == iMaskBand )

  002a9	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _iRsmpBand$[ebp]
  002af	3b 45 94	 cmp	 eax, DWORD PTR _iMaskBand$[ebp]
  002b2	75 2e		 jne	 SHORT $L2484

; 773  : 				{	// just a constant MaskQ for the whole NoiseBand
; 774  : 					fflt = ffltMaskPower10( rgiMaskQ[iMaskBand] );

  002b4	8b 4d 94	 mov	 ecx, DWORD PTR _iMaskBand$[ebp]
  002b7	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _rgiMaskQ$[ebp]
  002bd	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  002c0	50		 push	 eax
  002c1	e8 00 00 00 00	 call	 _ffltMaskPower10@4
  002c6	d9 5d f8	 fstp	 DWORD PTR _fflt$[ebp]

; 775  : 					flt = FLOAT_FROM_FASTFLOAT( fflt );

  002c9	8b 4d f8	 mov	 ecx, DWORD PTR _fflt$[ebp]
  002cc	89 4d 88	 mov	 DWORD PTR _flt$[ebp], ecx

; 776  : 					fltBandWeight[cNoiseBand] = flt*flt;

  002cf	d9 45 88	 fld	 DWORD PTR _flt$[ebp]
  002d2	d8 4d 88	 fmul	 DWORD PTR _flt$[ebp]
  002d5	0f b6 55 f7	 movzx	 edx, BYTE PTR _cNoiseBand$[ebp]
  002d9	d9 5c 95 c4	 fstp	 DWORD PTR _fltBandWeight$[ebp+edx*4]

; 777  : 					MONITOR_COUNT(gMC_GBW_floats,4);
; 778  : 				}
; 779  : 				else

  002dd	e9 d1 00 00 00	 jmp	 $L2480
$L2484:

; 780  : 				{	// Two different MaskQ's for this NoiseBand
; 781  : 					// BW = ( N1 * 10^(2*MarkQ[iBarkResampled]) + N2 * 10^(2*MarkQ[iBarkResampled+1]/16) ) / (N1 + N2)
; 782  : 					// This is not suited to FastFloat - leave in float.
; 783  : 					Float fltP1, fltP2;
; 784  : 					Int iUnRsmpEnd = iUnResampleIndex( iMaskEnd, MRI );

  002e2	83 ec 0c	 sub	 esp, 12			; 0000000cH
  002e5	8b c4		 mov	 eax, esp
  002e7	8b 4d 18	 mov	 ecx, DWORD PTR _MRI$[ebp]
  002ea	89 08		 mov	 DWORD PTR [eax], ecx
  002ec	8b 55 1c	 mov	 edx, DWORD PTR _MRI$[ebp+4]
  002ef	89 50 04	 mov	 DWORD PTR [eax+4], edx
  002f2	8b 4d 20	 mov	 ecx, DWORD PTR _MRI$[ebp+8]
  002f5	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  002f8	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _iMaskEnd$[ebp]
  002fe	52		 push	 edx
  002ff	e8 00 00 00 00	 call	 _iUnResampleIndex@16
  00304	89 85 68 ff ff
	ff		 mov	 DWORD PTR _iUnRsmpEnd$2488[ebp], eax

; 785  : 					fflt  = ffltMaskPower10( rgiMaskQ[iMaskBand] );

  0030a	8b 45 94	 mov	 eax, DWORD PTR _iMaskBand$[ebp]
  0030d	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _rgiMaskQ$[ebp]
  00313	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00316	52		 push	 edx
  00317	e8 00 00 00 00	 call	 _ffltMaskPower10@4
  0031c	d9 5d f8	 fstp	 DWORD PTR _fflt$[ebp]

; 786  : 					fltP1 = FLOAT_FROM_FASTFLOAT( fflt );

  0031f	8b 45 f8	 mov	 eax, DWORD PTR _fflt$[ebp]
  00322	89 85 64 ff ff
	ff		 mov	 DWORD PTR _fltP1$2486[ebp], eax

; 787  : 					fflt  = ffltMaskPower10( rgiMaskQ[iRsmpBand] );

  00328	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _iRsmpBand$[ebp]
  0032e	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _rgiMaskQ$[ebp]
  00334	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00337	50		 push	 eax
  00338	e8 00 00 00 00	 call	 _ffltMaskPower10@4
  0033d	d9 5d f8	 fstp	 DWORD PTR _fflt$[ebp]

; 788  : 					fltP2 = FLOAT_FROM_FASTFLOAT( fflt );

  00340	8b 4d f8	 mov	 ecx, DWORD PTR _fflt$[ebp]
  00343	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _fltP2$2487[ebp], ecx

; 789  : 					flt   = ( (iUnRsmpEnd-iCurrStart)*fltP1*fltP1 + (iCurrEnd-iUnRsmpEnd)*fltP2*fltP2 ) / (iCurrEnd - iCurrStart);

  00349	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _iUnRsmpEnd$2488[ebp]
  0034f	2b 95 74 ff ff
	ff		 sub	 edx, DWORD PTR _iCurrStart$[ebp]
  00355	89 95 48 ff ff
	ff		 mov	 DWORD PTR tv418[ebp], edx
  0035b	db 85 48 ff ff
	ff		 fild	 DWORD PTR tv418[ebp]
  00361	d8 8d 64 ff ff
	ff		 fmul	 DWORD PTR _fltP1$2486[ebp]
  00367	d8 8d 64 ff ff
	ff		 fmul	 DWORD PTR _fltP1$2486[ebp]
  0036d	8b 45 90	 mov	 eax, DWORD PTR _iCurrEnd$[ebp]
  00370	2b 85 68 ff ff
	ff		 sub	 eax, DWORD PTR _iUnRsmpEnd$2488[ebp]
  00376	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv420[ebp], eax
  0037c	db 85 44 ff ff
	ff		 fild	 DWORD PTR tv420[ebp]
  00382	d8 8d 60 ff ff
	ff		 fmul	 DWORD PTR _fltP2$2487[ebp]
  00388	d8 8d 60 ff ff
	ff		 fmul	 DWORD PTR _fltP2$2487[ebp]
  0038e	de c1		 faddp	 ST(1), ST(0)
  00390	8b 4d 90	 mov	 ecx, DWORD PTR _iCurrEnd$[ebp]
  00393	2b 8d 74 ff ff
	ff		 sub	 ecx, DWORD PTR _iCurrStart$[ebp]
  00399	89 8d 40 ff ff
	ff		 mov	 DWORD PTR tv422[ebp], ecx
  0039f	da b5 40 ff ff
	ff		 fidiv	 DWORD PTR tv422[ebp]
  003a5	d9 5d 88	 fstp	 DWORD PTR _flt$[ebp]

; 790  : 					fltBandWeight[cNoiseBand] = flt;

  003a8	0f b6 55 f7	 movzx	 edx, BYTE PTR _cNoiseBand$[ebp]
  003ac	8b 45 88	 mov	 eax, DWORD PTR _flt$[ebp]
  003af	89 44 95 c4	 mov	 DWORD PTR _fltBandWeight$[ebp+edx*4], eax
$L2480:

; 791  : 					MONITOR_COUNT(gMC_GBW_floats,13);
; 792  : 				}
; 793  : 			}
; 794  : 			cNoiseBand++;

  003b3	8a 4d f7	 mov	 cl, BYTE PTR _cNoiseBand$[ebp]
  003b6	80 c1 01	 add	 cl, 1
  003b9	88 4d f7	 mov	 BYTE PTR _cNoiseBand$[ebp], cl
$L2475:

; 795  : 		}
; 796  :         iCurrBand++;

  003bc	8b 55 f0	 mov	 edx, DWORD PTR _iCurrBand$[ebp]
  003bf	83 c2 01	 add	 edx, 1
  003c2	89 55 f0	 mov	 DWORD PTR _iCurrBand$[ebp], edx

; 797  : 	}

  003c5	e9 05 fd ff ff	 jmp	 $L2472
$L2473:

; 798  : 	for( iCurrBand = 0; iCurrBand < (cNoiseBand-1); iCurrBand++ )

  003ca	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iCurrBand$[ebp], 0
  003d1	eb 09		 jmp	 SHORT $L2489
$L2490:
  003d3	8b 45 f0	 mov	 eax, DWORD PTR _iCurrBand$[ebp]
  003d6	83 c0 01	 add	 eax, 1
  003d9	89 45 f0	 mov	 DWORD PTR _iCurrBand$[ebp], eax
$L2489:
  003dc	0f b6 4d f7	 movzx	 ecx, BYTE PTR _cNoiseBand$[ebp]
  003e0	83 e9 01	 sub	 ecx, 1
  003e3	39 4d f0	 cmp	 DWORD PTR _iCurrBand$[ebp], ecx
  003e6	7d 66		 jge	 SHORT $L2491

; 799  : 	{	
; 800  : 		if ( fAllBandsSynced )

  003e8	83 7d 80 00	 cmp	 DWORD PTR _fAllBandsSynced$[ebp], 0
  003ec	74 2c		 je	 SHORT $L2492

; 801  : 		{
; 802  : 			fflt = ffltMaskPower10( rgiMaskQ4BandNotCoded[iCurrBand] - rgiMaskQ4BandNotCoded[cNoiseBand-1] );

  003ee	0f b6 55 f7	 movzx	 edx, BYTE PTR _cNoiseBand$[ebp]
  003f2	8b 45 f0	 mov	 eax, DWORD PTR _iCurrBand$[ebp]
  003f5	8b 4c 85 9c	 mov	 ecx, DWORD PTR _rgiMaskQ4BandNotCoded$[ebp+eax*4]
  003f9	2b 4c 95 98	 sub	 ecx, DWORD PTR _rgiMaskQ4BandNotCoded$[ebp+edx*4-4]
  003fd	51		 push	 ecx
  003fe	e8 00 00 00 00	 call	 _ffltMaskPower10@4
  00403	d9 5d f8	 fstp	 DWORD PTR _fflt$[ebp]

; 803  : 			flt  = FLOAT_FROM_FASTFLOAT( fflt );

  00406	8b 55 f8	 mov	 edx, DWORD PTR _fflt$[ebp]
  00409	89 55 88	 mov	 DWORD PTR _flt$[ebp], edx

; 804  : 			rgffltSqrtBWRatio[iCurrBand] = fflt;

  0040c	8b 45 f0	 mov	 eax, DWORD PTR _iCurrBand$[ebp]
  0040f	8b 4d 84	 mov	 ecx, DWORD PTR _rgffltSqrtBWRatio$[ebp]
  00412	8b 55 f8	 mov	 edx, DWORD PTR _fflt$[ebp]
  00415	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 805  : 			//// float SqrtBWRatio = fflt.iFraction*1.0F/(1<<fflt.iFracBits)
; 806  : 		}
; 807  : 		else

  00418	eb 32		 jmp	 SHORT $L2493
$L2492:

; 808  : 		{
; 809  : 			// This calculation is not ideally suited to FastFloat, leave in float for time being
; 810  : 			// But note that limited range of the result probably means it can be done more quickly
; 811  : 			flt = (Float)sqrt( fltBandWeight[iCurrBand] / fltBandWeight[cNoiseBand-1] );

  0041a	0f b6 45 f7	 movzx	 eax, BYTE PTR _cNoiseBand$[ebp]
  0041e	8b 4d f0	 mov	 ecx, DWORD PTR _iCurrBand$[ebp]
  00421	d9 44 8d c4	 fld	 DWORD PTR _fltBandWeight$[ebp+ecx*4]
  00425	d8 74 85 c0	 fdiv	 DWORD PTR _fltBandWeight$[ebp+eax*4-4]
  00429	83 ec 08	 sub	 esp, 8
  0042c	dd 1c 24	 fstp	 QWORD PTR [esp]
  0042f	e8 00 00 00 00	 call	 _sqrt
  00434	83 c4 08	 add	 esp, 8
  00437	d9 5d 88	 fstp	 DWORD PTR _flt$[ebp]

; 812  : 			fflt = FASTFLOAT_FROM_FLOAT( flt );

  0043a	8b 55 88	 mov	 edx, DWORD PTR _flt$[ebp]
  0043d	89 55 f8	 mov	 DWORD PTR _fflt$[ebp], edx

; 813  : 			rgffltSqrtBWRatio[iCurrBand] = fflt;

  00440	8b 45 f0	 mov	 eax, DWORD PTR _iCurrBand$[ebp]
  00443	8b 4d 84	 mov	 ecx, DWORD PTR _rgffltSqrtBWRatio$[ebp]
  00446	8b 55 f8	 mov	 edx, DWORD PTR _fflt$[ebp]
  00449	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
$L2493:

; 814  : 			//// float SqrtBWRatio = fflt.iFraction*1.0F/(1<<fflt.iFracBits)
; 815  : 		}
; 816  : 		MONITOR_RANGE(gMR_rgffltSqrtBWRatio,FLOAT_FROM_FASTFLOAT(fflt));
; 817  : 		MONITOR_COUNT(gMC_GBW_floats,14);		// count sqrt as 10.
; 818  : 	}

  0044c	eb 85		 jmp	 SHORT $L2490
$L2491:

; 819  : 	if (cNoiseBand > 0)

  0044e	0f b6 45 f7	 movzx	 eax, BYTE PTR _cNoiseBand$[ebp]
  00452	85 c0		 test	 eax, eax
  00454	7e 0f		 jle	 SHORT $L2495

; 820  : 	{	// last band has a ratio of 1.0
; 821  : 
; 822  : #if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
; 823  : 		rgffltSqrtBWRatio[cNoiseBand-1].iFraction = 0x40000000;
; 824  : 		rgffltSqrtBWRatio[cNoiseBand-1].iFracBits = 30;
; 825  : #else
; 826  : 		rgffltSqrtBWRatio[cNoiseBand-1] = 1.0F;

  00456	0f b6 4d f7	 movzx	 ecx, BYTE PTR _cNoiseBand$[ebp]
  0045a	8b 55 84	 mov	 edx, DWORD PTR _rgffltSqrtBWRatio$[ebp]
  0045d	c7 44 8a fc 00
	00 80 3f	 mov	 DWORD PTR [edx+ecx*4-4], 1065353216 ; 3f800000H
$L2495:

; 827  : #endif
; 828  : 		MONITOR_RANGE(gMR_rgffltSqrtBWRatio,1.0F);
; 829  : 	}
; 830  : 
; 831  : 	assert (cNoiseBand < pau->m_cValidBarkBand);
; 832  : 	assert (pau->m_iFirstNoiseBand > 0);
; 833  : 	rgbBandNotCoded [0] = cNoiseBand;				// used as cNoiseBand

  00465	8b 45 fc	 mov	 eax, DWORD PTR _rgbBandNotCoded$[ebp]
  00468	8a 4d f7	 mov	 cl, BYTE PTR _cNoiseBand$[ebp]
  0046b	88 08		 mov	 BYTE PTR [eax], cl

; 834  :     FUNCTION_PROFILE_STOP(&fp);
; 835  : }

  0046d	8b e5		 mov	 esp, ebp
  0046f	5d		 pop	 ebp
  00470	c2 1c 00	 ret	 28			; 0000001cH
_prvGetBandWeightMidRate_XDS@28 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _iResampleIndex@16
WMADEC	SEGMENT
_iRecon$ = 8
_MRI$ = 12
_iResampleIndex@16 PROC NEAR				; COMDAT

; 598  : {	// return resampled linear index suitable for frame that was last updated with MaskQ

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 	// equvilent to iRecon shifted left or right by (MRI.iMaskResampleRatioPow-MASKQ_RESAMPLE_OFFSET)
; 600  : 	return ( (((iRecon) << MRI.iMaskResampleRatioPow) >> MASKQ_RESAMPLE_OFFSET) );

  00003	8b 45 08	 mov	 eax, DWORD PTR _iRecon$[ebp]
  00006	8b 4d 10	 mov	 ecx, DWORD PTR _MRI$[ebp+4]
  00009	d3 e0		 shl	 eax, cl
  0000b	c1 f8 06	 sar	 eax, 6

; 601  : }

  0000e	5d		 pop	 ebp
  0000f	c2 10 00	 ret	 16			; 00000010H
_iResampleIndex@16 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _iUnResampleIndex@16
WMADEC	SEGMENT
_iResampled$ = 8
_MRI$ = 12
_iUnResampleIndex@16 PROC NEAR				; COMDAT

; 609  : {	// return the reverse of iResampleIndex()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 610  : 	// that is, convert from resampled indexes of MaskQ or WeightFactor to natural index for the current frame
; 611  :     if (MRI.iMaskResampleRatioPow > MASKQ_RESAMPLE_OFFSET){

  00003	83 7d 10 06	 cmp	 DWORD PTR _MRI$[ebp+4], 6
  00007	7e 1e		 jle	 SHORT $L2396

; 612  : 		// Rounding for down shift 
; 613  : 		// Although V4 did not round when resampling, this inverse funtion needs to round ???
; 614  :         return (iResampled + (1<<(MRI.iMaskResampleRatioPow-(MASKQ_RESAMPLE_OFFSET+1)))) >> (MRI.iMaskResampleRatioPow-MASKQ_RESAMPLE_OFFSET);

  00009	8b 4d 10	 mov	 ecx, DWORD PTR _MRI$[ebp+4]
  0000c	83 e9 07	 sub	 ecx, 7
  0000f	b8 01 00 00 00	 mov	 eax, 1
  00014	d3 e0		 shl	 eax, cl
  00016	8b 55 08	 mov	 edx, DWORD PTR _iResampled$[ebp]
  00019	03 d0		 add	 edx, eax
  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _MRI$[ebp+4]
  0001e	83 e9 06	 sub	 ecx, 6
  00021	d3 fa		 sar	 edx, cl
  00023	8b c2		 mov	 eax, edx
  00025	eb 0d		 jmp	 SHORT $L2395
$L2396:

; 615  :         // return iResampled >> (MRI.iMaskResampleRatioPow-MASKQ_RESAMPLE_OFFSET);
; 616  :     } else {
; 617  :         return iResampled << (MASKQ_RESAMPLE_OFFSET-MRI.iMaskResampleRatioPow);

  00027	b9 06 00 00 00	 mov	 ecx, 6
  0002c	2b 4d 10	 sub	 ecx, DWORD PTR _MRI$[ebp+4]
  0002f	8b 45 08	 mov	 eax, DWORD PTR _iResampled$[ebp]
  00032	d3 e0		 shl	 eax, cl
$L2395:

; 618  :     }
; 619  : }

  00034	5d		 pop	 ebp
  00035	c2 10 00	 ret	 16			; 00000010H
_iUnResampleIndex@16 ENDP
WMADEC	ENDS
EXTRN	_rgiMaskMinusPower10:BYTE
EXTRN	_rgiMaskPlusPower10:BYTE
; Function compile flags: /Odt
;	COMDAT _ffltMaskPower10@4
WMADEC	SEGMENT
tv92 = -12
tv87 = -8
_fflt$ = -4
_iMaskQ$ = 8
_ffltMaskPower10@4 PROC NEAR				; COMDAT

; 660  : {	// (10^(1/16)) ^ iMaskQ

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 661  : 	FastFloat fflt;
; 662  : 	
; 663  : #if !defined (ENCODER)
; 664  : 	assert( -MASK_MINUS_POWER_TABLE_SIZE < iMaskQ && iMaskQ <= MASK_PLUS_POWER_TABLE_SIZE );
; 665  : #endif
; 666  : 	if ( iMaskQ <= 0 )

  00006	83 7d 08 00	 cmp	 DWORD PTR _iMaskQ$[ebp], 0
  0000a	7f 33		 jg	 SHORT $L2423

; 667  : 	{
; 668  : 		if (iMaskQ < -MASK_MINUS_POWER_TABLE_SIZE)

  0000c	83 7d 08 b8	 cmp	 DWORD PTR _iMaskQ$[ebp], -72 ; ffffffb8H
  00010	7d 07		 jge	 SHORT $L2424

; 669  : 			iMaskQ = -(MASK_MINUS_POWER_TABLE_SIZE-1);

  00012	c7 45 08 b9 ff
	ff ff		 mov	 DWORD PTR _iMaskQ$[ebp], -71 ; ffffffb9H
$L2424:

; 670  : #if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
; 671  : 		fflt.iFraction = rgiMaskMinusPower10[ -iMaskQ ];	// with MASK_POWER_FRAC_BITS==28 fractional bits
; 672  : 		fflt.iFracBits = MASK_POWER_FRAC_BITS+(-iMaskQ>>2);
; 673  : #else
; 674  : 		fflt = rgiMaskMinusPower10[ -iMaskQ ] / (Float)(1<<(-iMaskQ>>2));

  00019	8b 45 08	 mov	 eax, DWORD PTR _iMaskQ$[ebp]
  0001c	f7 d8		 neg	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _iMaskQ$[ebp]
  00021	f7 d9		 neg	 ecx
  00023	c1 f9 02	 sar	 ecx, 2
  00026	ba 01 00 00 00	 mov	 edx, 1
  0002b	d3 e2		 shl	 edx, cl
  0002d	89 55 f8	 mov	 DWORD PTR tv87[ebp], edx
  00030	db 45 f8	 fild	 DWORD PTR tv87[ebp]
  00033	d8 3c 85 00 00
	00 00		 fdivr	 DWORD PTR _rgiMaskMinusPower10[eax*4]
  0003a	d9 5d fc	 fstp	 DWORD PTR _fflt$[ebp]

; 675  : #endif
; 676  : 	}
; 677  : 	else

  0003d	eb 2d		 jmp	 SHORT $L2426
$L2423:

; 678  : 	{
; 679  : 		if (iMaskQ >= MASK_PLUS_POWER_TABLE_SIZE)

  0003f	83 7d 08 32	 cmp	 DWORD PTR _iMaskQ$[ebp], 50 ; 00000032H
  00043	7c 07		 jl	 SHORT $L2427

; 680  : 			iMaskQ = MASK_PLUS_POWER_TABLE_SIZE;

  00045	c7 45 08 32 00
	00 00		 mov	 DWORD PTR _iMaskQ$[ebp], 50 ; 00000032H
$L2427:

; 681  : #if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
; 682  : 		fflt.iFraction = rgiMaskPlusPower10[ iMaskQ-1 ];	// with MASK_POWER_FRAC_BITS==28 fractional bits
; 683  : 		fflt.iFracBits = MASK_POWER_FRAC_BITS-(iMaskQ>>2);
; 684  : #else
; 685  : 		fflt = rgiMaskPlusPower10[ iMaskQ-1 ] * (Float)(1<<(iMaskQ>>2));

  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _iMaskQ$[ebp]
  0004f	c1 f9 02	 sar	 ecx, 2
  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	d3 e0		 shl	 eax, cl
  00059	89 45 f4	 mov	 DWORD PTR tv92[ebp], eax
  0005c	db 45 f4	 fild	 DWORD PTR tv92[ebp]
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _iMaskQ$[ebp]
  00062	d8 0c 8d fc ff
	ff ff		 fmul	 DWORD PTR _rgiMaskPlusPower10[ecx*4-4]
  00069	d9 5d fc	 fstp	 DWORD PTR _fflt$[ebp]
$L2426:

; 686  : #endif
; 687  : 	}
; 688  : 	return fflt;

  0006c	d9 45 fc	 fld	 DWORD PTR _fflt$[ebp]

; 689  : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
_ffltMaskPower10@4 ENDP
WMADEC	ENDS
PUBLIC	_prvInitNoiseSub_XDS@4
PUBLIC	??_C@_0EP@MODOKKIF@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@ ; `string'
PUBLIC	__real@3f000000
PUBLIC	__real@3f947ae1
PUBLIC	__real@3f3851ec
PUBLIC	__real@3f333333
PUBLIC	__real@3f19999a
PUBLIC	__real@3f1c28f6
PUBLIC	__real@3ecccccd
PUBLIC	__real@3e99999a
PUBLIC	__real@3f666666
PUBLIC	__real@3f200000
PUBLIC	__real@3f400000
PUBLIC	__real@3f266666
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f800000
EXTRN	_auMalloc_XDS@4:NEAR
EXTRN	_MyOutputDbgStr:NEAR
EXTRN	_g_rgiBarkFreq:BYTE
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3f947ae1
CONST	SEGMENT
__real@3f947ae1 DD 03f947ae1r			; 1.16
CONST	ENDS
;	COMDAT __real@3f3851ec
CONST	SEGMENT
__real@3f3851ec DD 03f3851ecr			; 0.72
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f1c28f6
CONST	SEGMENT
__real@3f1c28f6 DD 03f1c28f6r			; 0.61
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f200000
CONST	SEGMENT
__real@3f200000 DD 03f200000r			; 0.625
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT ??_C@_0EP@MODOKKIF@c?3?2xbox?2private?2windows?2directx?2@
WMADEC_RD	SEGMENT
??_C@_0EP@MODOKKIF@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\wmalib\wmadec_s\lowrate_c'
	DB	'ommon.c', 00H				; `string'
WMADEC_RD	ENDS
;	COMDAT ??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
WMADEC_RD	SEGMENT
??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@ DB '%'
	DB	's(%d) : *** TRACE *** code = 0x%x!', 0aH, 00H ; `string'
WMADEC_RD	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _prvInitNoiseSub_XDS@4
WMADEC	SEGMENT
tv328 = -44
tv309 = -40
tv290 = -36
tv271 = -32
tv253 = -28
_iWin$ = -24
_piBarkIndex$ = -20
_cFrameSample$ = -16
_fltSamplingPeriod$ = -12
_iBand$ = -8
_iNoiseIndex$ = -4
_pau$ = 8
_prvInitNoiseSub_XDS@4 PROC NEAR			; COMDAT

; 1061 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi

; 1062 :     Int iWin, iBand;
; 1063 :     Float fltSamplingPeriod;
; 1064 : 
; 1065 :     Int *piBarkIndex;
; 1066 :     Int cFrameSample;
; 1067 :     Int iNoiseIndex;
; 1068 : 
; 1069 :     pau->m_fNoiseSub = WMAB_TRUE;

  00007	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0000a	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1

; 1070 :     pau->m_fltFirstNoiseFreq = (Float)(pau->m_iSamplingRate*0.5f);

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00014	db 41 54	 fild	 DWORD PTR [ecx+84]
  00017	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  0001d	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00020	d9 9a bc 03 00
	00		 fstp	 DWORD PTR [edx+956]

; 1071 :     // adjust...
; 1072 :     // HongCho: This is related to Bark bands (re-adjust when Bark bands change)
; 1073 :     if(pau->m_iVersion == 1) {

  00026	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00029	83 78 44 01	 cmp	 DWORD PTR [eax+68], 1
  0002d	0f 85 52 02 00
	00		 jne	 $L2525

; 1074 : 
; 1075 :         // version 1 was incorrectly using the inequalities...
; 1076 :         // do not change!!!
; 1077 : 
; 1078 :         if(pau->m_iSamplingRate == 22050) {

  00033	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00036	81 79 54 22 56
	00 00		 cmp	 DWORD PTR [ecx+84], 22050 ; 00005622H
  0003d	75 69		 jne	 SHORT $L2526

; 1079 :             // somewhat different parameters...
; 1080 :             if (pau->m_fltWeightedBitsPerSample >= 1.16f)

  0003f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00042	d9 42 38	 fld	 DWORD PTR [edx+56]
  00045	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f947ae1
  0004b	df e0		 fnstsw	 ax
  0004d	f6 c4 01	 test	 ah, 1
  00050	75 0c		 jne	 SHORT $L2527

; 1081 :                 pau->m_fNoiseSub = WMAB_FALSE;

  00052	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00055	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1082 :             else if(pau->m_fltWeightedBitsPerSample >= 0.72f)

  0005c	eb 45		 jmp	 SHORT $L2528
$L2527:
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00061	d9 41 38	 fld	 DWORD PTR [ecx+56]
  00064	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f3851ec
  0006a	df e0		 fnstsw	 ax
  0006c	f6 c4 01	 test	 ah, 1
  0006f	75 1a		 jne	 SHORT $L2529

; 1083 :                 pau->m_fltFirstNoiseFreq *= (Float)0.70;

  00071	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00074	d9 82 bc 03 00
	00		 fld	 DWORD PTR [edx+956]
  0007a	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f333333
  00080	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00083	d9 98 bc 03 00
	00		 fstp	 DWORD PTR [eax+956]

; 1084 :             else

  00089	eb 18		 jmp	 SHORT $L2528
$L2529:

; 1085 :                 pau->m_fltFirstNoiseFreq *= (Float)0.60;

  0008b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0008e	d9 81 bc 03 00
	00		 fld	 DWORD PTR [ecx+956]
  00094	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f19999a
  0009a	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0009d	d9 9a bc 03 00
	00		 fstp	 DWORD PTR [edx+956]
$L2528:

; 1086 :         }
; 1087 :         else if (pau->m_iSamplingRate == 44100) {

  000a3	e9 d8 01 00 00	 jmp	 $L2533
$L2526:
  000a8	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000ab	81 78 54 44 ac
	00 00		 cmp	 DWORD PTR [eax+84], 44100 ; 0000ac44H
  000b2	75 3c		 jne	 SHORT $L2534

; 1088 :             if (pau->m_fltWeightedBitsPerSample >= 0.61f)

  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000b7	d9 41 38	 fld	 DWORD PTR [ecx+56]
  000ba	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f1c28f6
  000c0	df e0		 fnstsw	 ax
  000c2	f6 c4 01	 test	 ah, 1
  000c5	75 0c		 jne	 SHORT $L2535

; 1089 :                 pau->m_fNoiseSub = WMAB_FALSE;

  000c7	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000ca	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 1090 :             else

  000d1	eb 18		 jmp	 SHORT $L2536
$L2535:

; 1091 :                 pau->m_fltFirstNoiseFreq *= (Float) 0.4;

  000d3	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000d6	d9 80 bc 03 00
	00		 fld	 DWORD PTR [eax+956]
  000dc	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3ecccccd
  000e2	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000e5	d9 99 bc 03 00
	00		 fstp	 DWORD PTR [ecx+956]
$L2536:

; 1092 :         }
; 1093 :         else if (pau->m_iSamplingRate == 16000) {

  000eb	e9 90 01 00 00	 jmp	 $L2533
$L2534:
  000f0	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000f3	81 7a 54 80 3e
	00 00		 cmp	 DWORD PTR [edx+84], 16000 ; 00003e80H
  000fa	75 57		 jne	 SHORT $L2539

; 1094 :             if (pau->m_fltBitsPerSample <= 0.5f)

  000fc	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000ff	d9 40 34	 fld	 DWORD PTR [eax+52]
  00102	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f000000
  00108	df e0		 fnstsw	 ax
  0010a	f6 c4 41	 test	 ah, 65			; 00000041H
  0010d	7a 1a		 jp	 SHORT $L2540

; 1095 :                 pau->m_fltFirstNoiseFreq *= (Float) 0.30;

  0010f	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00112	d9 81 bc 03 00
	00		 fld	 DWORD PTR [ecx+956]
  00118	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e99999a
  0011e	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00121	d9 9a bc 03 00
	00		 fstp	 DWORD PTR [edx+956]

; 1096 :             else {

  00127	eb 25		 jmp	 SHORT $L2542
$L2540:

; 1097 :                 pau->m_fltFirstNoiseFreq *= (Float) 0.50;

  00129	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0012c	d9 80 bc 03 00
	00		 fld	 DWORD PTR [eax+956]
  00132	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00138	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0013b	d9 99 bc 03 00
	00		 fstp	 DWORD PTR [ecx+956]

; 1098 :                 pau->m_iNoisePeakIgnoreBand = 3;

  00141	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00144	c7 82 c8 03 00
	00 03 00 00 00	 mov	 DWORD PTR [edx+968], 3
$L2542:

; 1099 :             }
; 1100 :         }
; 1101 :         else if (pau->m_iSamplingRate == 11025) {

  0014e	e9 2d 01 00 00	 jmp	 $L2533
$L2539:
  00153	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00156	81 78 54 11 2b
	00 00		 cmp	 DWORD PTR [eax+84], 11025 ; 00002b11H
  0015d	75 3d		 jne	 SHORT $L2545

; 1102 :             assert(1 == pau->m_iNoisePeakIgnoreBand);
; 1103 :             pau->m_fltFirstNoiseFreq *= (Float) 0.70;

  0015f	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00162	d9 81 bc 03 00
	00		 fld	 DWORD PTR [ecx+956]
  00168	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f333333
  0016e	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00171	d9 9a bc 03 00
	00		 fstp	 DWORD PTR [edx+956]

; 1104 :             if (pau->m_fltBitsPerSample >= 0.9f)

  00177	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0017a	d9 40 34	 fld	 DWORD PTR [eax+52]
  0017d	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f666666
  00183	df e0		 fnstsw	 ax
  00185	f6 c4 01	 test	 ah, 1
  00188	75 0d		 jne	 SHORT $L2547

; 1105 :                 pau->m_iNoisePeakIgnoreBand = 3;

  0018a	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0018d	c7 81 c8 03 00
	00 03 00 00 00	 mov	 DWORD PTR [ecx+968], 3
$L2547:

; 1106 :         }
; 1107 :         else if (pau->m_iSamplingRate == 8000) {

  00197	e9 e4 00 00 00	 jmp	 $L2533
$L2545:
  0019c	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0019f	81 7a 54 40 1f
	00 00		 cmp	 DWORD PTR [edx+84], 8000 ; 00001f40H
  001a6	75 66		 jne	 SHORT $L2549

; 1108 :             assert(1 == pau->m_iNoisePeakIgnoreBand);
; 1109 :             if (pau->m_fltBitsPerSample <=0.625f)

  001a8	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001ab	d9 40 34	 fld	 DWORD PTR [eax+52]
  001ae	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f200000
  001b4	df e0		 fnstsw	 ax
  001b6	f6 c4 41	 test	 ah, 65			; 00000041H
  001b9	7a 1a		 jp	 SHORT $L2550

; 1110 :                 pau->m_fltFirstNoiseFreq *= (Float) 0.50;

  001bb	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  001be	d9 81 bc 03 00
	00		 fld	 DWORD PTR [ecx+956]
  001c4	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  001ca	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  001cd	d9 9a bc 03 00
	00		 fstp	 DWORD PTR [edx+956]

; 1111 :             else if (pau->m_fltBitsPerSample <= 0.75f)

  001d3	eb 37		 jmp	 SHORT $L2552
$L2550:
  001d5	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001d8	d9 40 34	 fld	 DWORD PTR [eax+52]
  001db	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f400000
  001e1	df e0		 fnstsw	 ax
  001e3	f6 c4 41	 test	 ah, 65			; 00000041H
  001e6	7a 1a		 jp	 SHORT $L2553

; 1112 :                 pau->m_fltFirstNoiseFreq *= (Float) 0.65;

  001e8	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  001eb	d9 81 bc 03 00
	00		 fld	 DWORD PTR [ecx+956]
  001f1	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f266666
  001f7	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  001fa	d9 9a bc 03 00
	00		 fstp	 DWORD PTR [edx+956]

; 1113 :             else

  00200	eb 0a		 jmp	 SHORT $L2552
$L2553:

; 1114 :                 pau->m_fNoiseSub = WMAB_FALSE;

  00202	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00205	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
$L2552:

; 1115 :         }
; 1116 :         else {

  0020c	eb 72		 jmp	 SHORT $L2533
$L2549:

; 1117 :             if(pau->m_fltBitsPerSample >= 0.8f)

  0020e	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00211	d9 41 34	 fld	 DWORD PTR [ecx+52]
  00214	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f4ccccd
  0021a	df e0		 fnstsw	 ax
  0021c	f6 c4 01	 test	 ah, 1
  0021f	75 1a		 jne	 SHORT $L2557

; 1118 :                 pau->m_fltFirstNoiseFreq *= (Float)0.75;

  00221	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00224	d9 82 bc 03 00
	00		 fld	 DWORD PTR [edx+956]
  0022a	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f400000
  00230	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00233	d9 98 bc 03 00
	00		 fstp	 DWORD PTR [eax+956]

; 1119 :             else if(pau->m_fltBitsPerSample >= 0.6f)

  00239	eb 45		 jmp	 SHORT $L2533
$L2557:
  0023b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0023e	d9 41 34	 fld	 DWORD PTR [ecx+52]
  00241	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f19999a
  00247	df e0		 fnstsw	 ax
  00249	f6 c4 01	 test	 ah, 1
  0024c	75 1a		 jne	 SHORT $L2560

; 1120 :                 pau->m_fltFirstNoiseFreq *= (Float)0.60;

  0024e	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00251	d9 82 bc 03 00
	00		 fld	 DWORD PTR [edx+956]
  00257	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f19999a
  0025d	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00260	d9 98 bc 03 00
	00		 fstp	 DWORD PTR [eax+956]

; 1121 :             else

  00266	eb 18		 jmp	 SHORT $L2533
$L2560:

; 1122 :                 pau->m_fltFirstNoiseFreq *= (Float)0.5;

  00268	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0026b	d9 81 bc 03 00
	00		 fld	 DWORD PTR [ecx+956]
  00271	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00277	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0027a	d9 9a bc 03 00
	00		 fstp	 DWORD PTR [edx+956]
$L2533:

; 1123 :         }
; 1124 : 
; 1125 :     }
; 1126 :     else {

  00280	e9 4d 02 00 00	 jmp	 $L2564
$L2525:

; 1127 : 
; 1128 :         // for newer versions...  more correct using inequality...
; 1129 : 
; 1130 :         if (pau->m_iSamplingRate >= 44100) {

  00285	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00288	81 78 54 44 ac
	00 00		 cmp	 DWORD PTR [eax+84], 44100 ; 0000ac44H
  0028f	7c 3c		 jl	 SHORT $L2565

; 1131 :             if (pau->m_fltWeightedBitsPerSample >= 0.61f)

  00291	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00294	d9 41 38	 fld	 DWORD PTR [ecx+56]
  00297	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f1c28f6
  0029d	df e0		 fnstsw	 ax
  0029f	f6 c4 01	 test	 ah, 1
  002a2	75 0c		 jne	 SHORT $L2566

; 1132 :                 pau->m_fNoiseSub = WMAB_FALSE;

  002a4	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  002a7	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 1133 :             else

  002ae	eb 18		 jmp	 SHORT $L2567
$L2566:

; 1134 :                 pau->m_fltFirstNoiseFreq *= (Float) 0.4;

  002b0	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002b3	d9 80 bc 03 00
	00		 fld	 DWORD PTR [eax+956]
  002b9	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3ecccccd
  002bf	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002c2	d9 99 bc 03 00
	00		 fstp	 DWORD PTR [ecx+956]
$L2567:

; 1135 :         }
; 1136 :         else if(pau->m_iSamplingRate >= 22050) {

  002c8	e9 05 02 00 00	 jmp	 $L2564
$L2565:
  002cd	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  002d0	81 7a 54 22 56
	00 00		 cmp	 DWORD PTR [edx+84], 22050 ; 00005622H
  002d7	7c 69		 jl	 SHORT $L2570

; 1137 :             // somewhat different parameters...
; 1138 :             if (pau->m_fltWeightedBitsPerSample >= 1.16f)

  002d9	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  002dc	d9 40 38	 fld	 DWORD PTR [eax+56]
  002df	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f947ae1
  002e5	df e0		 fnstsw	 ax
  002e7	f6 c4 01	 test	 ah, 1
  002ea	75 0c		 jne	 SHORT $L2571

; 1139 :                 pau->m_fNoiseSub = WMAB_FALSE;

  002ec	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  002ef	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 1140 :             else if(pau->m_fltWeightedBitsPerSample >= 0.72f)

  002f6	eb 45		 jmp	 SHORT $L2572
$L2571:
  002f8	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  002fb	d9 42 38	 fld	 DWORD PTR [edx+56]
  002fe	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f3851ec
  00304	df e0		 fnstsw	 ax
  00306	f6 c4 01	 test	 ah, 1
  00309	75 1a		 jne	 SHORT $L2573

; 1141 :                 pau->m_fltFirstNoiseFreq *= (Float)0.70;

  0030b	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0030e	d9 80 bc 03 00
	00		 fld	 DWORD PTR [eax+956]
  00314	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f333333
  0031a	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0031d	d9 99 bc 03 00
	00		 fstp	 DWORD PTR [ecx+956]

; 1142 :             else

  00323	eb 18		 jmp	 SHORT $L2572
$L2573:

; 1143 :                 pau->m_fltFirstNoiseFreq *= (Float)0.60;

  00325	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00328	d9 82 bc 03 00
	00		 fld	 DWORD PTR [edx+956]
  0032e	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f19999a
  00334	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00337	d9 98 bc 03 00
	00		 fstp	 DWORD PTR [eax+956]
$L2572:

; 1144 :         }
; 1145 :         else if (pau->m_iSamplingRate >= 16000) {

  0033d	e9 90 01 00 00	 jmp	 $L2564
$L2570:
  00342	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00345	81 79 54 80 3e
	00 00		 cmp	 DWORD PTR [ecx+84], 16000 ; 00003e80H
  0034c	7c 57		 jl	 SHORT $L2578

; 1146 :             if (pau->m_fltBitsPerSample <= 0.5f)

  0034e	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00351	d9 42 34	 fld	 DWORD PTR [edx+52]
  00354	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f000000
  0035a	df e0		 fnstsw	 ax
  0035c	f6 c4 41	 test	 ah, 65			; 00000041H
  0035f	7a 1a		 jp	 SHORT $L2579

; 1147 :                 pau->m_fltFirstNoiseFreq *= (Float) 0.30;

  00361	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00364	d9 80 bc 03 00
	00		 fld	 DWORD PTR [eax+956]
  0036a	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e99999a
  00370	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00373	d9 99 bc 03 00
	00		 fstp	 DWORD PTR [ecx+956]

; 1148 :             else {

  00379	eb 25		 jmp	 SHORT $L2581
$L2579:

; 1149 :                 pau->m_fltFirstNoiseFreq *= (Float) 0.50;

  0037b	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0037e	d9 82 bc 03 00
	00		 fld	 DWORD PTR [edx+956]
  00384	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  0038a	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0038d	d9 98 bc 03 00
	00		 fstp	 DWORD PTR [eax+956]

; 1150 :                 pau->m_iNoisePeakIgnoreBand = 3;

  00393	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00396	c7 81 c8 03 00
	00 03 00 00 00	 mov	 DWORD PTR [ecx+968], 3
$L2581:

; 1151 :             }
; 1152 :         }
; 1153 :         else if (pau->m_iSamplingRate >= 11025) {

  003a0	e9 2d 01 00 00	 jmp	 $L2564
$L2578:
  003a5	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003a8	81 7a 54 11 2b
	00 00		 cmp	 DWORD PTR [edx+84], 11025 ; 00002b11H
  003af	7c 3d		 jl	 SHORT $L2584

; 1154 :             assert(1 == pau->m_iNoisePeakIgnoreBand);
; 1155 :             pau->m_fltFirstNoiseFreq *= (Float) 0.70;

  003b1	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  003b4	d9 80 bc 03 00
	00		 fld	 DWORD PTR [eax+956]
  003ba	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f333333
  003c0	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  003c3	d9 99 bc 03 00
	00		 fstp	 DWORD PTR [ecx+956]

; 1156 :             if (pau->m_fltBitsPerSample >= 0.9f)

  003c9	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003cc	d9 42 34	 fld	 DWORD PTR [edx+52]
  003cf	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f666666
  003d5	df e0		 fnstsw	 ax
  003d7	f6 c4 01	 test	 ah, 1
  003da	75 0d		 jne	 SHORT $L2586

; 1157 :                 pau->m_iNoisePeakIgnoreBand = 3;

  003dc	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  003df	c7 80 c8 03 00
	00 03 00 00 00	 mov	 DWORD PTR [eax+968], 3
$L2586:

; 1158 :         }
; 1159 :         else if (pau->m_iSamplingRate >= 8000) {

  003e9	e9 e4 00 00 00	 jmp	 $L2564
$L2584:
  003ee	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  003f1	81 79 54 40 1f
	00 00		 cmp	 DWORD PTR [ecx+84], 8000 ; 00001f40H
  003f8	7c 66		 jl	 SHORT $L2588

; 1160 :             assert(1 == pau->m_iNoisePeakIgnoreBand);
; 1161 :             if (pau->m_fltBitsPerSample <=0.625f)

  003fa	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003fd	d9 42 34	 fld	 DWORD PTR [edx+52]
  00400	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f200000
  00406	df e0		 fnstsw	 ax
  00408	f6 c4 41	 test	 ah, 65			; 00000041H
  0040b	7a 1a		 jp	 SHORT $L2589

; 1162 :                 pau->m_fltFirstNoiseFreq *= (Float) 0.50;

  0040d	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00410	d9 80 bc 03 00
	00		 fld	 DWORD PTR [eax+956]
  00416	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  0041c	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0041f	d9 99 bc 03 00
	00		 fstp	 DWORD PTR [ecx+956]

; 1163 :             else if (pau->m_fltBitsPerSample <= 0.75f)

  00425	eb 37		 jmp	 SHORT $L2591
$L2589:
  00427	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0042a	d9 42 34	 fld	 DWORD PTR [edx+52]
  0042d	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f400000
  00433	df e0		 fnstsw	 ax
  00435	f6 c4 41	 test	 ah, 65			; 00000041H
  00438	7a 1a		 jp	 SHORT $L2592

; 1164 :                 pau->m_fltFirstNoiseFreq *= (Float) 0.65;

  0043a	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  0043d	d9 80 bc 03 00
	00		 fld	 DWORD PTR [eax+956]
  00443	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f266666
  00449	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0044c	d9 99 bc 03 00
	00		 fstp	 DWORD PTR [ecx+956]

; 1165 :             else

  00452	eb 0a		 jmp	 SHORT $L2591
$L2592:

; 1166 :                 pau->m_fNoiseSub = WMAB_FALSE;

  00454	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00457	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0
$L2591:

; 1167 :         }
; 1168 :         else {

  0045e	eb 72		 jmp	 SHORT $L2564
$L2588:

; 1169 :             if(pau->m_fltBitsPerSample >= 0.8f)

  00460	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00463	d9 40 34	 fld	 DWORD PTR [eax+52]
  00466	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f4ccccd
  0046c	df e0		 fnstsw	 ax
  0046e	f6 c4 01	 test	 ah, 1
  00471	75 1a		 jne	 SHORT $L2596

; 1170 :                 pau->m_fltFirstNoiseFreq *= (Float)0.75;

  00473	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00476	d9 81 bc 03 00
	00		 fld	 DWORD PTR [ecx+956]
  0047c	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f400000
  00482	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00485	d9 9a bc 03 00
	00		 fstp	 DWORD PTR [edx+956]

; 1171 :             else if(pau->m_fltBitsPerSample >= 0.6f)

  0048b	eb 45		 jmp	 SHORT $L2564
$L2596:
  0048d	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00490	d9 40 34	 fld	 DWORD PTR [eax+52]
  00493	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f19999a
  00499	df e0		 fnstsw	 ax
  0049b	f6 c4 01	 test	 ah, 1
  0049e	75 1a		 jne	 SHORT $L2599

; 1172 :                 pau->m_fltFirstNoiseFreq *= (Float)0.60;

  004a0	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  004a3	d9 81 bc 03 00
	00		 fld	 DWORD PTR [ecx+956]
  004a9	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f19999a
  004af	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  004b2	d9 9a bc 03 00
	00		 fstp	 DWORD PTR [edx+956]

; 1173 :             else

  004b8	eb 18		 jmp	 SHORT $L2564
$L2599:

; 1174 :                 pau->m_fltFirstNoiseFreq *= (Float)0.5;

  004ba	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  004bd	d9 80 bc 03 00
	00		 fld	 DWORD PTR [eax+956]
  004c3	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  004c9	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  004cc	d9 99 bc 03 00
	00		 fstp	 DWORD PTR [ecx+956]
$L2564:

; 1175 :         }
; 1176 :     }
; 1177 : 
; 1178 : 	if (!pau->m_fNoiseSub)

  004d2	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  004d5	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  004d9	75 0a		 jne	 SHORT $L2603

; 1179 :         return WMA_OK;

  004db	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
  004e0	e9 1a 04 00 00	 jmp	 $L2517
$L2603:

; 1180 : 
; 1181 :     pau->m_rgiFirstNoiseBand = (Int*) auMalloc (sizeof (Int) * pau->m_cPossibleWinSize);

  004e5	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  004e8	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  004ee	c1 e1 02	 shl	 ecx, 2
  004f1	51		 push	 ecx
  004f2	e8 00 00 00 00	 call	 _auMalloc_XDS@4
  004f7	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  004fa	89 82 cc 03 00
	00		 mov	 DWORD PTR [edx+972], eax

; 1182 :     if(pau->m_rgiFirstNoiseBand == NULL)

  00500	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00503	83 b8 cc 03 00
	00 00		 cmp	 DWORD PTR [eax+972], 0
  0050a	75 56		 jne	 SHORT $L2607

; 1183 :         return TraceResult(WMA_E_OUTOFMEMORY);

  0050c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  00512	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_E_ONHOLD
  00518	74 37		 je	 SHORT $L2798
  0051a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  00520	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WMA_OK
  00526	74 29		 je	 SHORT $L2798
  00528	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  0052d	50		 push	 eax
  0052e	68 9f 04 00 00	 push	 1183			; 0000049fH
  00533	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EP@MODOKKIF@c?3?2xbox?2private?2windows?2directx?2@
  00538	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  0053d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  00543	51		 push	 ecx
  00544	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00549	83 c4 14	 add	 esp, 20			; 00000014H
  0054c	89 45 e4	 mov	 DWORD PTR tv253[ebp], eax
  0054f	eb 09		 jmp	 SHORT $L2799
$L2798:
  00551	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  00557	89 55 e4	 mov	 DWORD PTR tv253[ebp], edx
$L2799:
  0055a	8b 45 e4	 mov	 eax, DWORD PTR tv253[ebp]
  0055d	e9 9d 03 00 00	 jmp	 $L2517
$L2607:

; 1184 :     pau->m_rgbBandNotCoded	= (U8*) auMalloc (pau->m_cValidBarkBand * pau->m_cChannel);	

  00562	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00565	0f b7 48 58	 movzx	 ecx, WORD PTR [eax+88]
  00569	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0056c	8b 82 50 03 00
	00		 mov	 eax, DWORD PTR [edx+848]
  00572	0f af c1	 imul	 eax, ecx
  00575	50		 push	 eax
  00576	e8 00 00 00 00	 call	 _auMalloc_XDS@4
  0057b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0057e	89 81 d0 03 00
	00		 mov	 DWORD PTR [ecx+976], eax

; 1185 :     if (pau->m_rgbBandNotCoded == NULL)

  00584	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00587	83 ba d0 03 00
	00 00		 cmp	 DWORD PTR [edx+976], 0
  0058e	75 55		 jne	 SHORT $L2612

; 1186 :         return TraceResult(WMA_E_OUTOFMEMORY);

  00590	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  00595	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  0059b	74 37		 je	 SHORT $L2800
  0059d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  005a3	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  005a9	74 29		 je	 SHORT $L2800
  005ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  005b1	52		 push	 edx
  005b2	68 a2 04 00 00	 push	 1186			; 000004a2H
  005b7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EP@MODOKKIF@c?3?2xbox?2private?2windows?2directx?2@
  005bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  005c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  005c6	50		 push	 eax
  005c7	e8 00 00 00 00	 call	 _MyOutputDbgStr
  005cc	83 c4 14	 add	 esp, 20			; 00000014H
  005cf	89 45 e0	 mov	 DWORD PTR tv271[ebp], eax
  005d2	eb 09		 jmp	 SHORT $L2801
$L2800:
  005d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  005da	89 4d e0	 mov	 DWORD PTR tv271[ebp], ecx
$L2801:
  005dd	8b 45 e0	 mov	 eax, DWORD PTR tv271[ebp]
  005e0	e9 1a 03 00 00	 jmp	 $L2517
$L2612:

; 1187 :     pau->m_rgiNoisePower	= (Int*) auMalloc (sizeof (Int) * pau->m_cValidBarkBand * pau->m_cChannel);

  005e5	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  005e8	8b 82 50 03 00
	00		 mov	 eax, DWORD PTR [edx+848]
  005ee	c1 e0 02	 shl	 eax, 2
  005f1	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  005f4	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  005f8	0f af c2	 imul	 eax, edx
  005fb	50		 push	 eax
  005fc	e8 00 00 00 00	 call	 _auMalloc_XDS@4
  00601	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00604	89 81 d8 03 00
	00		 mov	 DWORD PTR [ecx+984], eax

; 1188 :     if (pau->m_rgiNoisePower == NULL)

  0060a	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0060d	83 ba d8 03 00
	00 00		 cmp	 DWORD PTR [edx+984], 0
  00614	75 55		 jne	 SHORT $L2616

; 1189 :         return TraceResult(WMA_E_OUTOFMEMORY);

  00616	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  0061b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  00621	74 37		 je	 SHORT $L2802
  00623	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  00629	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  0062f	74 29		 je	 SHORT $L2802
  00631	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  00637	52		 push	 edx
  00638	68 a5 04 00 00	 push	 1189			; 000004a5H
  0063d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EP@MODOKKIF@c?3?2xbox?2private?2windows?2directx?2@
  00642	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00647	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  0064c	50		 push	 eax
  0064d	e8 00 00 00 00	 call	 _MyOutputDbgStr
  00652	83 c4 14	 add	 esp, 20			; 00000014H
  00655	89 45 dc	 mov	 DWORD PTR tv290[ebp], eax
  00658	eb 09		 jmp	 SHORT $L2803
$L2802:
  0065a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  00660	89 4d dc	 mov	 DWORD PTR tv290[ebp], ecx
$L2803:
  00663	8b 45 dc	 mov	 eax, DWORD PTR tv290[ebp]
  00666	e9 94 02 00 00	 jmp	 $L2517
$L2616:

; 1190 : #ifndef BUILD_INTEGER
; 1191 :     pau->m_rgfltBandWeight	= (Float*) auMalloc (sizeof (Float) * pau->m_cValidBarkBand * pau->m_cChannel);

  0066b	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0066e	8b 82 50 03 00
	00		 mov	 eax, DWORD PTR [edx+848]
  00674	c1 e0 02	 shl	 eax, 2
  00677	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0067a	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  0067e	0f af c2	 imul	 eax, edx
  00681	50		 push	 eax
  00682	e8 00 00 00 00	 call	 _auMalloc_XDS@4
  00687	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0068a	89 81 dc 03 00
	00		 mov	 DWORD PTR [ecx+988], eax

; 1192 :     if (pau->m_rgfltBandWeight == NULL)

  00690	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00693	83 ba dc 03 00
	00 00		 cmp	 DWORD PTR [edx+988], 0
  0069a	75 55		 jne	 SHORT $L2620

; 1193 :         return TraceResult(WMA_E_OUTOFMEMORY);

  0069c	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  006a1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  006a7	74 37		 je	 SHORT $L2804
  006a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  006af	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  006b5	74 29		 je	 SHORT $L2804
  006b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  006bd	52		 push	 edx
  006be	68 a9 04 00 00	 push	 1193			; 000004a9H
  006c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EP@MODOKKIF@c?3?2xbox?2private?2windows?2directx?2@
  006c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  006cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  006d2	50		 push	 eax
  006d3	e8 00 00 00 00	 call	 _MyOutputDbgStr
  006d8	83 c4 14	 add	 esp, 20			; 00000014H
  006db	89 45 d8	 mov	 DWORD PTR tv309[ebp], eax
  006de	eb 09		 jmp	 SHORT $L2805
$L2804:
  006e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  006e6	89 4d d8	 mov	 DWORD PTR tv309[ebp], ecx
$L2805:
  006e9	8b 45 d8	 mov	 eax, DWORD PTR tv309[ebp]
  006ec	e9 0e 02 00 00	 jmp	 $L2517
$L2620:

; 1194 : #endif
; 1195 :     pau->m_rgffltSqrtBWRatio	= (FastFloat*) auMalloc (sizeof (FastFloat) * pau->m_cValidBarkBand * pau->m_cChannel);

  006f1	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  006f4	8b 82 50 03 00
	00		 mov	 eax, DWORD PTR [edx+848]
  006fa	c1 e0 02	 shl	 eax, 2
  006fd	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00700	0f b7 51 58	 movzx	 edx, WORD PTR [ecx+88]
  00704	0f af c2	 imul	 eax, edx
  00707	50		 push	 eax
  00708	e8 00 00 00 00	 call	 _auMalloc_XDS@4
  0070d	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00710	89 81 d4 03 00
	00		 mov	 DWORD PTR [ecx+980], eax

; 1196 :     if (pau->m_rgffltSqrtBWRatio == NULL)

  00716	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00719	83 ba d4 03 00
	00 00		 cmp	 DWORD PTR [edx+980], 0
  00720	75 55		 jne	 SHORT $L2624

; 1197 :         return TraceResult(WMA_E_OUTOFMEMORY);

  00722	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  00727	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _WMA_E_ONHOLD
  0072d	74 37		 je	 SHORT $L2806
  0072f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  00735	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _WMA_OK
  0073b	74 29		 je	 SHORT $L2806
  0073d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WMA_E_OUTOFMEMORY
  00743	52		 push	 edx
  00744	68 ad 04 00 00	 push	 1197			; 000004adH
  00749	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EP@MODOKKIF@c?3?2xbox?2private?2windows?2directx?2@
  0074e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@ECGGHIKF@?$CFs?$CI?$CFd?$CJ?5?3?5?$CK?$CK?$CK?5TRACE?5?$CK?$CK?$CK?5code?5?$DN?50x@
  00753	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_E_OUTOFMEMORY
  00758	50		 push	 eax
  00759	e8 00 00 00 00	 call	 _MyOutputDbgStr
  0075e	83 c4 14	 add	 esp, 20			; 00000014H
  00761	89 45 d4	 mov	 DWORD PTR tv328[ebp], eax
  00764	eb 09		 jmp	 SHORT $L2807
$L2806:
  00766	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WMA_E_OUTOFMEMORY
  0076c	89 4d d4	 mov	 DWORD PTR tv328[ebp], ecx
$L2807:
  0076f	8b 45 d4	 mov	 eax, DWORD PTR tv328[ebp]
  00772	e9 88 01 00 00	 jmp	 $L2517
$L2624:

; 1198 : 
; 1199 :     //calculate index of each bark freq
; 1200 :     fltSamplingPeriod = 1.0F / pau->m_iSamplingRate;

  00777	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0077a	db 42 54	 fild	 DWORD PTR [edx+84]
  0077d	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@3f800000
  00783	d9 5d f4	 fstp	 DWORD PTR _fltSamplingPeriod$[ebp]

; 1201 :     // wchen: we need to think what to do with the cut off frequencies: not include at all or include zeros.
; 1202 :     //for long window
; 1203 :     piBarkIndex = pau->m_rgiBarkIndexOrig;

  00786	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00789	8b 88 b0 03 00
	00		 mov	 ecx, DWORD PTR [eax+944]
  0078f	89 4d ec	 mov	 DWORD PTR _piBarkIndex$[ebp], ecx

; 1204 : 
; 1205 :     // for the v1 compatibility
; 1206 :     if(pau->m_iVersion == 1)

  00792	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00795	83 7a 44 01	 cmp	 DWORD PTR [edx+68], 1
  00799	75 71		 jne	 SHORT $L2625

; 1207 :     {
; 1208 :         // precalculate the first noise bands
; 1209 :         // wchen: who put these two lines here? No use!
; 1210 :         //pau->m_rgiFirstNoiseBand[0] = (Int)(pau->m_fltFirstNoiseFreq*pau->m_cFrameSample*fltSamplingPeriod + 0.5);
; 1211 :         //if(pau->m_rgiFirstNoiseBand[0] > pau->m_cSubband) pau->m_rgiFirstNoiseBand[0] = pau->m_cSubband;
; 1212 :         for(iBand = 0; iBand < pau->m_rgcValidBarkBand[0]; iBand++) {

  0079b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iBand$[ebp], 0
  007a2	eb 09		 jmp	 SHORT $L2626
$L2627:
  007a4	8b 45 f8	 mov	 eax, DWORD PTR _iBand$[ebp]
  007a7	83 c0 01	 add	 eax, 1
  007aa	89 45 f8	 mov	 DWORD PTR _iBand$[ebp], eax
$L2626:
  007ad	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  007b0	8b 91 ac 03 00
	00		 mov	 edx, DWORD PTR [ecx+940]
  007b6	8b 45 f8	 mov	 eax, DWORD PTR _iBand$[ebp]
  007b9	3b 02		 cmp	 eax, DWORD PTR [edx]
  007bb	7d 30		 jge	 SHORT $L2628

; 1213 :             if(g_rgiBarkFreq[iBand] > (Int)ftoi(pau->m_fltFirstNoiseFreq)) {

  007bd	8b 4d f8	 mov	 ecx, DWORD PTR _iBand$[ebp]
  007c0	0f b7 34 4d 00
	00 00 00	 movzx	 esi, WORD PTR _g_rgiBarkFreq[ecx*2]
  007c8	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  007cb	8b 82 bc 03 00
	00		 mov	 eax, DWORD PTR [edx+956]
  007d1	50		 push	 eax
  007d2	e8 00 00 00 00	 call	 _FloatToLong@4
  007d7	3b f0		 cmp	 esi, eax
  007d9	7e 10		 jle	 SHORT $L2631

; 1214 :                 pau->m_rgiFirstNoiseBand[0] = iBand;

  007db	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  007de	8b 91 cc 03 00
	00		 mov	 edx, DWORD PTR [ecx+972]
  007e4	8b 45 f8	 mov	 eax, DWORD PTR _iBand$[ebp]
  007e7	89 02		 mov	 DWORD PTR [edx], eax

; 1215 :                 break;

  007e9	eb 02		 jmp	 SHORT $L2628
$L2631:

; 1216 :             }
; 1217 :         }

  007eb	eb b7		 jmp	 SHORT $L2627
$L2628:

; 1218 :         // if not there, turn it off...
; 1219 :         if(iBand == pau->m_rgcValidBarkBand[0])

  007ed	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  007f0	8b 91 ac 03 00
	00		 mov	 edx, DWORD PTR [ecx+940]
  007f6	8b 45 f8	 mov	 eax, DWORD PTR _iBand$[ebp]
  007f9	3b 02		 cmp	 eax, DWORD PTR [edx]
  007fb	75 0a		 jne	 SHORT $L2632

; 1220 :             pau->m_fNoiseSub = WMAB_FALSE;

  007fd	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00800	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
$L2632:

; 1221 :     }
; 1222 :     else

  00807	e9 da 00 00 00	 jmp	 $L2633
$L2625:

; 1223 :     {
; 1224 :         for (iWin = 0; iWin < pau->m_cPossibleWinSize; iWin++)    {

  0080c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iWin$[ebp], 0
  00813	eb 09		 jmp	 SHORT $L2634
$L2635:
  00815	8b 55 e8	 mov	 edx, DWORD PTR _iWin$[ebp]
  00818	83 c2 01	 add	 edx, 1
  0081b	89 55 e8	 mov	 DWORD PTR _iWin$[ebp], edx
$L2634:
  0081e	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00821	8b 4d e8	 mov	 ecx, DWORD PTR _iWin$[ebp]
  00824	3b 88 90 00 00
	00		 cmp	 ecx, DWORD PTR [eax+144]
  0082a	0f 8d b6 00 00
	00		 jge	 $L2633

; 1225 :             // precalculate the first noise bands
; 1226 :             pau->m_rgiFirstNoiseBand[iWin] = pau->m_rgcValidBarkBand[iWin] - 1;// init to max...

  00830	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00833	8b 82 ac 03 00
	00		 mov	 eax, DWORD PTR [edx+940]
  00839	8b 4d e8	 mov	 ecx, DWORD PTR _iWin$[ebp]
  0083c	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  0083f	83 ea 01	 sub	 edx, 1
  00842	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00845	8b 88 cc 03 00
	00		 mov	 ecx, DWORD PTR [eax+972]
  0084b	8b 45 e8	 mov	 eax, DWORD PTR _iWin$[ebp]
  0084e	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 1227 :             cFrameSample = pau->m_cFrameSample / (1 << iWin);

  00851	be 01 00 00 00	 mov	 esi, 1
  00856	8b 4d e8	 mov	 ecx, DWORD PTR _iWin$[ebp]
  00859	d3 e6		 shl	 esi, cl
  0085b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0085e	8b 81 18 03 00
	00		 mov	 eax, DWORD PTR [ecx+792]
  00864	99		 cdq
  00865	f7 fe		 idiv	 esi
  00867	89 45 f0	 mov	 DWORD PTR _cFrameSample$[ebp], eax

; 1228 :             iNoiseIndex = (Int)ftoi(pau->m_fltFirstNoiseFreq*cFrameSample*fltSamplingPeriod + 0.5f);

  0086a	db 45 f0	 fild	 DWORD PTR _cFrameSample$[ebp]
  0086d	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00870	d8 8a bc 03 00
	00		 fmul	 DWORD PTR [edx+956]
  00876	d8 4d f4	 fmul	 DWORD PTR _fltSamplingPeriod$[ebp]
  00879	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f000000
  0087f	51		 push	 ecx
  00880	d9 1c 24	 fstp	 DWORD PTR [esp]
  00883	e8 00 00 00 00	 call	 _FloatToLong@4
  00888	89 45 fc	 mov	 DWORD PTR _iNoiseIndex$[ebp], eax

; 1229 :             for(iBand = 1; iBand < pau->m_rgcValidBarkBand[iWin]; iBand++) {

  0088b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _iBand$[ebp], 1
  00892	eb 09		 jmp	 SHORT $L2639
$L2640:
  00894	8b 45 f8	 mov	 eax, DWORD PTR _iBand$[ebp]
  00897	83 c0 01	 add	 eax, 1
  0089a	89 45 f8	 mov	 DWORD PTR _iBand$[ebp], eax
$L2639:
  0089d	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  008a0	8b 91 ac 03 00
	00		 mov	 edx, DWORD PTR [ecx+940]
  008a6	8b 45 e8	 mov	 eax, DWORD PTR _iWin$[ebp]
  008a9	8b 4d f8	 mov	 ecx, DWORD PTR _iBand$[ebp]
  008ac	3b 0c 82	 cmp	 ecx, DWORD PTR [edx+eax*4]
  008af	7d 27		 jge	 SHORT $L2641

; 1230 :                 if(piBarkIndex[iBand] > iNoiseIndex) {

  008b1	8b 55 f8	 mov	 edx, DWORD PTR _iBand$[ebp]
  008b4	8b 45 ec	 mov	 eax, DWORD PTR _piBarkIndex$[ebp]
  008b7	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  008ba	3b 4d fc	 cmp	 ecx, DWORD PTR _iNoiseIndex$[ebp]
  008bd	7e 17		 jle	 SHORT $L2642

; 1231 :                     pau->m_rgiFirstNoiseBand[iWin] = iBand - 1;

  008bf	8b 55 f8	 mov	 edx, DWORD PTR _iBand$[ebp]
  008c2	83 ea 01	 sub	 edx, 1
  008c5	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  008c8	8b 88 cc 03 00
	00		 mov	 ecx, DWORD PTR [eax+972]
  008ce	8b 45 e8	 mov	 eax, DWORD PTR _iWin$[ebp]
  008d1	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 1232 :                     break;

  008d4	eb 02		 jmp	 SHORT $L2641
$L2642:

; 1233 :                 }
; 1234 :             }

  008d6	eb bc		 jmp	 SHORT $L2640
$L2641:

; 1235 :             piBarkIndex +=  NUM_BARK_BAND + 1;

  008d8	8b 4d ec	 mov	 ecx, DWORD PTR _piBarkIndex$[ebp]
  008db	83 c1 68	 add	 ecx, 104		; 00000068H
  008de	89 4d ec	 mov	 DWORD PTR _piBarkIndex$[ebp], ecx

; 1236 :         }

  008e1	e9 2f ff ff ff	 jmp	 $L2635
$L2633:

; 1237 :     }
; 1238 :     pau->m_iFirstNoiseBand = pau->m_rgiFirstNoiseBand[0];    

  008e6	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  008e9	8b 82 cc 03 00
	00		 mov	 eax, DWORD PTR [edx+972]
  008ef	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  008f2	8b 10		 mov	 edx, DWORD PTR [eax]
  008f4	89 91 c0 03 00
	00		 mov	 DWORD PTR [ecx+960], edx

; 1239 :     return WMA_OK;

  008fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK
$L2517:

; 1240 : }

  008ff	5e		 pop	 esi
  00900	8b e5		 mov	 esp, ebp
  00902	5d		 pop	 ebp
  00903	c2 04 00	 ret	 4
_prvInitNoiseSub_XDS@4 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wmamath.h
WMADEC	ENDS
;	COMDAT _FloatToLong@4
WMADEC	SEGMENT
_x$ = 8
_FloatToLong@4 PROC NEAR				; COMDAT

; 6    :     __asm
; 7    :     {
; 8    :         cvttss2si eax, [esp+4]

  00000	f3 0f 2c 44 24
	04		 cvttss2si eax, DWORD PTR [esp+4]

; 9    :         ret 4

  00006	c2 04 00	 ret	 4
_FloatToLong@4 ENDP
WMADEC	ENDS
PUBLIC	_auResampleWeightFactorLPC_XDS@8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\lowrate_common.c
;	COMDAT _auResampleWeightFactorLPC_XDS@8
WMADEC	SEGMENT
_j$ = -24
_rguiWeightFactor$ = -20
_iSizeSrc$ = -16
_iRatio$ = -12
_iSizeDst$ = -8
_i$ = -4
_pau$ = 8
_ppcinfo$ = 12
_auResampleWeightFactorLPC_XDS@8 PROC NEAR		; COMDAT

; 1253 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 1254 :     Int iRatio;
; 1255 :     Int i, j;
; 1256 : 
; 1257 :     UInt*  rguiWeightFactor = ppcinfo->m_rguiWeightFactor;

  00007	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  0000a	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0000d	89 4d ec	 mov	 DWORD PTR _rguiWeightFactor$[ebp], ecx

; 1258 :     Int iSizeSrc = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame - 1];

  00010	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00013	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00019	8b 94 81 74 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+372]
  00020	89 55 f0	 mov	 DWORD PTR _iSizeSrc$[ebp], edx

; 1259 :     Int iSizeDst = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];

  00023	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00026	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00029	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  0002c	8b 84 8a 78 01
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+376]
  00033	89 45 f8	 mov	 DWORD PTR _iSizeDst$[ebp], eax

; 1260 :     assert (pau->m_iCurrSubFrame > 0);
; 1261 : #ifndef BUILD_INTEGER
; 1262 : 	assert( sizeof(Int) == sizeof(Float) );		// rgfltWegihtFactor == rgiWeightFactor
; 1263 : #endif
; 1264 : 
; 1265 :     // This should only be called for LPC mode. Bark mode resamples weight factor
; 1266 :     // from the original weight factor array to avoid losing information.
; 1267 :     assert(LPC_MODE == pau->m_iWeightingMode);
; 1268 : 
; 1269 :     if (iSizeSrc > iSizeDst) {

  00036	8b 4d f0	 mov	 ecx, DWORD PTR _iSizeSrc$[ebp]
  00039	3b 4d f8	 cmp	 ecx, DWORD PTR _iSizeDst$[ebp]
  0003c	7e 3f		 jle	 SHORT $L2654

; 1270 :         //downsample
; 1271 :         iRatio = iSizeSrc / iSizeDst;

  0003e	8b 45 f0	 mov	 eax, DWORD PTR _iSizeSrc$[ebp]
  00041	99		 cdq
  00042	f7 7d f8	 idiv	 DWORD PTR _iSizeDst$[ebp]
  00045	89 45 f4	 mov	 DWORD PTR _iRatio$[ebp], eax

; 1272 :         i = 0;

  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$L2656:

; 1273 :         while (i < pau->m_cSubband) {

  0004f	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00052	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00055	3b 42 60	 cmp	 eax, DWORD PTR [edx+96]
  00058	7d 21		 jge	 SHORT $L2657

; 1274 :             rguiWeightFactor [i] = rguiWeightFactor [i * iRatio];

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0005d	0f af 4d f4	 imul	 ecx, DWORD PTR _iRatio$[ebp]
  00061	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00064	8b 45 ec	 mov	 eax, DWORD PTR _rguiWeightFactor$[ebp]
  00067	8b 75 ec	 mov	 esi, DWORD PTR _rguiWeightFactor$[ebp]
  0006a	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  0006d	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 1275 :             i++;

  00070	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00073	83 c2 01	 add	 edx, 1
  00076	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx

; 1276 :         }

  00079	eb d4		 jmp	 SHORT $L2656
$L2657:

; 1277 :     }
; 1278 :     else if (iSizeSrc < iSizeDst) {

  0007b	eb 68		 jmp	 SHORT $L2647
$L2654:
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _iSizeSrc$[ebp]
  00080	3b 45 f8	 cmp	 eax, DWORD PTR _iSizeDst$[ebp]
  00083	7d 60		 jge	 SHORT $L2647

; 1279 :         //upsample
; 1280 :         iRatio = iSizeDst / iSizeSrc;

  00085	8b 45 f8	 mov	 eax, DWORD PTR _iSizeDst$[ebp]
  00088	99		 cdq
  00089	f7 7d f0	 idiv	 DWORD PTR _iSizeSrc$[ebp]
  0008c	89 45 f4	 mov	 DWORD PTR _iRatio$[ebp], eax

; 1281 :         i = pau->m_cSubband / iRatio - 1;

  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00092	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00095	99		 cdq
  00096	f7 7d f4	 idiv	 DWORD PTR _iRatio$[ebp]
  00099	83 e8 01	 sub	 eax, 1
  0009c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L2661:

; 1282 :         while (i >= 0) {

  0009f	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  000a3	7c 40		 jl	 SHORT $L2647

; 1283 :             for (j = 0; j < iRatio; j++)    {

  000a5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000ac	eb 09		 jmp	 SHORT $L2663
$L2664:
  000ae	8b 55 e8	 mov	 edx, DWORD PTR _j$[ebp]
  000b1	83 c2 01	 add	 edx, 1
  000b4	89 55 e8	 mov	 DWORD PTR _j$[ebp], edx
$L2663:
  000b7	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  000ba	3b 45 f4	 cmp	 eax, DWORD PTR _iRatio$[ebp]
  000bd	7d 1b		 jge	 SHORT $L2665

; 1284 :                 rguiWeightFactor [i * iRatio + j] = rguiWeightFactor [i];

  000bf	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000c2	0f af 4d f4	 imul	 ecx, DWORD PTR _iRatio$[ebp]
  000c6	03 4d e8	 add	 ecx, DWORD PTR _j$[ebp]
  000c9	8b 55 ec	 mov	 edx, DWORD PTR _rguiWeightFactor$[ebp]
  000cc	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000cf	8b 75 ec	 mov	 esi, DWORD PTR _rguiWeightFactor$[ebp]
  000d2	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  000d5	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 1285 :             }

  000d8	eb d4		 jmp	 SHORT $L2664
$L2665:

; 1286 :             i--;

  000da	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000dd	83 e9 01	 sub	 ecx, 1
  000e0	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx

; 1287 :         }                

  000e3	eb ba		 jmp	 SHORT $L2661
$L2647:

; 1288 :     }
; 1289 :     //if == don't need to do anything
; 1290 : 	WFR_PRINT(iSizeSrc > iSizeDst ? 5 :(iSizeSrc < iSizeDst ? 6 : 7),rguiWeightFactor);
; 1291 : }

  000e5	5e		 pop	 esi
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 08 00	 ret	 8
_auResampleWeightFactorLPC_XDS@8 ENDP
WMADEC	ENDS
PUBLIC	_prvInverseQuantizeMidRate_XDS@12
PUBLIC	_quickRand@4
PUBLIC	_LOG2@4
PUBLIC	__real@4e000000
PUBLIC	__real@41800000
EXTRN	_qstCalcQuantStep_XDS@4:NEAR
EXTRN	_prvWeightedQuantization_XDS@12:NEAR
EXTRN	_pow:NEAR
;	COMDAT __real@4e000000
CONST	SEGMENT
__real@4e000000 DD 04e000000r			; 5.36871e+008
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _prvInverseQuantizeMidRate_XDS@12
WMADEC	SEGMENT
tv246 = -140
tv483 = -136
tv478 = -132
_ffltMaskPower$2727 = -128
_iLoopMax$2726 = -124
_ffltNoisePower$2728 = -120
_fltWeightRatio$2708 = -116
_fltNoise$2705 = -112
_fltCoefRecon$2701 = -108
_dblQuantStep$2699 = -104
_iReconTarget$ = -92
_iShift$ = -88
_rgiCoefQ$ = -84
_rgiMaskQ$ = -80
_MRI$ = -76
_rgiBarkIndexResampled$ = -64
_qfltQuantizer$ = -60
_rgiNoisePower$ = -56
_iRecon$ = -52
_rgffltSqrtBWRatio$ = -48
_rgiCoefRecon$ = -44
_iCoefRecon$ = -40
_iBark$ = -36
_rgiBarkIndex$ = -32
_iNoiseBand$ = -28
_iCoefQ$ = -24
_qrand$ = -20
_iBarkResampled$ = -16
_cNoiseBand$ = -9
_rgbBandNotCoded$ = -8
_iMaxMaskQ$ = -4
_pau$ = 8
_ppcinfo$ = 12
_rgiWeightFactor$ = 16
_prvInverseQuantizeMidRate_XDS@12 PROC NEAR		; COMDAT

; 1378 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	56		 push	 esi

; 1379 : 	Int iBark = 0;					// index barks using natural scale for this cSubband (at this sampling frequency)

  0000a	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _iBark$[ebp], 0

; 1380 : 	Int iBarkResampled = 0;			// index barks using resampled scale from cSubbands when the MaskQ's were last updated

  00011	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iBarkResampled$[ebp], 0

; 1381 : 	Int iCoefQ = 0;

  00018	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iCoefQ$[ebp], 0

; 1382 : 	Int iRecon = 0;

  0001f	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _iRecon$[ebp], 0

; 1383 :     const I16* rgiCoefQ				= ppcinfo->m_rgiCoefQ;

  00026	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	89 4d ac	 mov	 DWORD PTR _rgiCoefQ$[ebp], ecx

; 1384 :     const U8*  rgbBandNotCoded		= ppcinfo->m_rgbBandNotCoded;

  0002e	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  00031	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00034	89 45 f8	 mov	 DWORD PTR _rgbBandNotCoded$[ebp], eax

; 1385 :     const Int* rgiNoisePower		= ppcinfo->m_rgiNoisePower;

  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  0003a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0003d	89 55 c8	 mov	 DWORD PTR _rgiNoisePower$[ebp], edx

; 1386 : 	const FastFloat* rgffltSqrtBWRatio	= ppcinfo->m_rgffltSqrtBWRatio;

  00040	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  00043	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00046	89 4d d0	 mov	 DWORD PTR _rgffltSqrtBWRatio$[ebp], ecx

; 1387 : 	const Int* rgiMaskQ				= ppcinfo->m_rgiMaskQ;

  00049	8b 55 0c	 mov	 edx, DWORD PTR _ppcinfo$[ebp]
  0004c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004f	89 45 b0	 mov	 DWORD PTR _rgiMaskQ$[ebp], eax

; 1388 : 	const Int  iMaxMaskQ			= ppcinfo->m_iMaxMaskQ;

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00055	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00058	89 55 fc	 mov	 DWORD PTR _iMaxMaskQ$[ebp], edx

; 1389 :     const Int *rgiBarkIndex;
; 1390 : 	const Int *rgiBarkIndexResampled;
; 1391 :     CoefType* rgiCoefRecon			= (CoefType*)ppcinfo->m_rgiCoefRecon;

  0005b	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  0005e	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00061	89 4d d4	 mov	 DWORD PTR _rgiCoefRecon$[ebp], ecx

; 1392 : 	CoefType iCoefRecon; 
; 1393 :     Int qrand, iReconTarget;
; 1394 :     U8  cNoiseBand = rgbBandNotCoded [0];

  00064	8b 55 f8	 mov	 edx, DWORD PTR _rgbBandNotCoded$[ebp]
  00067	8a 02		 mov	 al, BYTE PTR [edx]
  00069	88 45 f7	 mov	 BYTE PTR _cNoiseBand$[ebp], al

; 1395 :     Int iNoiseBand = 0;

  0006c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iNoiseBand$[ebp], 0

; 1396 :     QuantFloat qfltQuantizer;
; 1397 : 	MaskResampleInfo MRI;
; 1398 : #if defined(PLATFORM_OPTIMIZATION_MINIMIZE_BRANCHING) && defined(BUILD_INTEGER)
; 1399 :     Int iMask1, iMask2;
; 1400 : #endif
; 1401 :     Int iShift = 0;

  00073	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _iShift$[ebp], 0

; 1402 : #if defined (SMOOTH_NMR)
; 1403 :     Bool *rgfMaskNeededForBark = ppcinfo->m_rgfMaskNeededForBark;
; 1404 : 	// A mask value of a bark should be preserved if that bark:
; 1405 : 	// (1) is needed for mask resampling,
; 1406 : 	// (2) not coded (noise substituted),
; 1407 : 	// (3) has a coded coeff with non-zero value,
; 1408 : 	// (4) or has the maximum mask value used in normalization.
; 1409 : #endif // SMOOTH_NMR
; 1410 :     
; 1411 :     FUNCTION_PROFILE(fp);
; 1412 :     FUNCTION_PROFILE_START(&fp,INVERSE_QUAN_MID_RATE_PROFILE);
; 1413 : 
; 1414 : 	DEBUG_BREAK_AT_FRAME_INV_QUANT;
; 1415 : 	MONITOR_COUNT(gMC_IQ,1);
; 1416 :     assert (pau->m_fNoiseSub &&  pau->m_iWeightingMode == BARK_MODE);
; 1417 :     assert(TRANSFORM_FRACT_BITS==5);
; 1418 :     assert (pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame] != 0);         
; 1419 :     // assert (pau->m_cFrameSampleHalf <= (1<<MASKQ_RESAMPLE_OFFSET));       // why???                                  
; 1420 :     assert (pau->m_iSubFrameSizeWithUpdate != 0);                                           
; 1421 : 	assert( pau->m_cPossibleWinSize <= MASKQ_RESAMPLE_OFFSET );
; 1422 :     
; 1423 : #if defined (SMOOTH_NMR)
; 1424 :     // Initially, no bark-mask needs to be preserved.
; 1425 :     memset(rgfMaskNeededForBark, 0, 25 * sizeof(Bool));
; 1426 : #endif //  SMOOTH_NMR
; 1427 :     
; 1428 : 	// handle changing subFrame window sizes by resampling the indexes
; 1429 :     MRI.iMaskResampleRatio = (pau->m_iSubFrameSizeWithUpdate << MASKQ_RESAMPLE_OFFSET) /                           
; 1430 :                           pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];    

  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0007d	8b 41 7c	 mov	 eax, DWORD PTR [ecx+124]
  00080	c1 e0 06	 shl	 eax, 6
  00083	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00086	8b 4a 70	 mov	 ecx, DWORD PTR [edx+112]
  00089	8b 75 08	 mov	 esi, DWORD PTR _pau$[ebp]
  0008c	99		 cdq
  0008d	f7 bc 8e 78 01
	00 00		 idiv	 DWORD PTR [esi+ecx*4+376]
  00094	89 45 b4	 mov	 DWORD PTR _MRI$[ebp], eax

; 1431 :     
; 1432 : 	MRI.iMaskResampleRatioPow = LOG2(MRI.iMaskResampleRatio);

  00097	8b 55 b4	 mov	 edx, DWORD PTR _MRI$[ebp]
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 _LOG2@4
  000a0	89 45 b8	 mov	 DWORD PTR _MRI$[ebp+4], eax

; 1433 :     rgiBarkIndexResampled     = pau->m_rgiBarkIndexOrig + (NUM_BARK_BAND + 1) *                    
; 1434 :                                   LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate);   

  000a3	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000a9	8b 80 1c 03 00
	00		 mov	 eax, DWORD PTR [eax+796]
  000af	99		 cdq
  000b0	f7 79 7c	 idiv	 DWORD PTR [ecx+124]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _LOG2@4
  000b9	6b c0 1a	 imul	 eax, 26			; 0000001aH
  000bc	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000bf	8b 8a b0 03 00
	00		 mov	 ecx, DWORD PTR [edx+944]
  000c5	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000c8	89 55 c0	 mov	 DWORD PTR _rgiBarkIndexResampled$[ebp], edx

; 1435 :     MRI.cValidBarkBandLatestUpdate = pau->m_rgcValidBarkBand [LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate)];

  000cb	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000ce	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  000d1	8b 80 1c 03 00
	00		 mov	 eax, DWORD PTR [eax+796]
  000d7	99		 cdq
  000d8	f7 79 7c	 idiv	 DWORD PTR [ecx+124]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _LOG2@4
  000e1	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000e4	8b 8a ac 03 00
	00		 mov	 ecx, DWORD PTR [edx+940]
  000ea	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000ed	89 55 bc	 mov	 DWORD PTR _MRI$[ebp+8], edx

; 1436 : 
; 1437 : 	rgiBarkIndex  = pau->m_rgiBarkIndexOrig + (NUM_BARK_BAND + 1) * pau->m_iIncr;  

  000f0	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  000f3	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  000f9	6b c9 1a	 imul	 ecx, 26			; 0000001aH
  000fc	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  000ff	8b 82 b0 03 00
	00		 mov	 eax, DWORD PTR [edx+944]
  00105	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00108	89 4d e0	 mov	 DWORD PTR _rgiBarkIndex$[ebp], ecx

; 1438 : 
; 1439 : 	prvGetBandWeightMidRate (pau, ppcinfo, rgiBarkIndex, rgiBarkIndexResampled, MRI);

  0010b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0010e	8b d4		 mov	 edx, esp
  00110	8b 45 b4	 mov	 eax, DWORD PTR _MRI$[ebp]
  00113	89 02		 mov	 DWORD PTR [edx], eax
  00115	8b 4d b8	 mov	 ecx, DWORD PTR _MRI$[ebp+4]
  00118	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0011b	8b 45 bc	 mov	 eax, DWORD PTR _MRI$[ebp+8]
  0011e	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00121	8b 4d c0	 mov	 ecx, DWORD PTR _rgiBarkIndexResampled$[ebp]
  00124	51		 push	 ecx
  00125	8b 55 e0	 mov	 edx, DWORD PTR _rgiBarkIndex$[ebp]
  00128	52		 push	 edx
  00129	8b 45 0c	 mov	 eax, DWORD PTR _ppcinfo$[ebp]
  0012c	50		 push	 eax
  0012d	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00130	51		 push	 ecx
  00131	e8 00 00 00 00	 call	 _prvGetBandWeightMidRate_XDS@28

; 1440 : 
; 1441 :     //Scan for the first bark index = note iRecon is 0 and rgiBarkIndex[1] ==0 for 16000 Hz and 11025 Hz frames with 128 or 64 samples
; 1442 : 	prvScanForNextBarkIndex( iRecon, &iBarkResampled, pau->m_cLowCutOff, rgiBarkIndexResampled, MRI );

  00136	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00139	8b d4		 mov	 edx, esp
  0013b	8b 45 b4	 mov	 eax, DWORD PTR _MRI$[ebp]
  0013e	89 02		 mov	 DWORD PTR [edx], eax
  00140	8b 4d b8	 mov	 ecx, DWORD PTR _MRI$[ebp+4]
  00143	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00146	8b 45 bc	 mov	 eax, DWORD PTR _MRI$[ebp+8]
  00149	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0014c	8b 4d c0	 mov	 ecx, DWORD PTR _rgiBarkIndexResampled$[ebp]
  0014f	51		 push	 ecx
  00150	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00153	8b 82 24 03 00
	00		 mov	 eax, DWORD PTR [edx+804]
  00159	50		 push	 eax
  0015a	8d 4d f0	 lea	 ecx, DWORD PTR _iBarkResampled$[ebp]
  0015d	51		 push	 ecx
  0015e	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  00161	52		 push	 edx
  00162	e8 00 00 00 00	 call	 _prvScanForNextBarkIndex@28
$L2696:

; 1443 : 	while( iRecon >= rgiBarkIndex[iBark+1] )

  00167	8b 45 dc	 mov	 eax, DWORD PTR _iBark$[ebp]
  0016a	8b 4d e0	 mov	 ecx, DWORD PTR _rgiBarkIndex$[ebp]
  0016d	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  00170	3b 54 81 04	 cmp	 edx, DWORD PTR [ecx+eax*4+4]
  00174	7c 0b		 jl	 SHORT $L2697

; 1444 : 		iBark++;

  00176	8b 45 dc	 mov	 eax, DWORD PTR _iBark$[ebp]
  00179	83 c0 01	 add	 eax, 1
  0017c	89 45 dc	 mov	 DWORD PTR _iBark$[ebp], eax
  0017f	eb e6		 jmp	 SHORT $L2696
$L2697:

; 1445 : 
; 1446 : 	if (iRecon < pau->m_cLowCutOff ) {

  00181	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00184	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  00187	3b 91 24 03 00
	00		 cmp	 edx, DWORD PTR [ecx+804]
  0018d	0f 8d a2 00 00
	00		 jge	 $L2713

; 1447 : 		// not integerized since cLowCutOff is typically 0, so this is here for compatability with V1 
; 1448 : 		Double dblQuantStep = DOUBLE_FROM_QUANTSTEPTYPE(pau->m_qstQuantStep);

  00193	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00196	d9 00		 fld	 DWORD PTR [eax]
  00198	dd 5d 98	 fstp	 QWORD PTR _dblQuantStep$2699[ebp]
$L2703:

; 1449 : 		Float fltCoefRecon;
; 1450 : 		while  (iRecon < pau->m_cLowCutOff) 	{

  0019b	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0019e	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  001a1	3b 91 24 03 00
	00		 cmp	 edx, DWORD PTR [ecx+804]
  001a7	0f 8d 88 00 00
	00		 jge	 $L2713

; 1451 : 			Float fltNoise = pau->m_fltDitherLevel * ((Float) quickRand (&(pau->m_tRandState)) / (Float) 0x20000000);//rgfltNoise [iRecon];

  001ad	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  001b0	05 08 04 00 00	 add	 eax, 1032		; 00000408H
  001b5	50		 push	 eax
  001b6	e8 00 00 00 00	 call	 _quickRand@4
  001bb	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv478[ebp], eax
  001c1	db 85 7c ff ff
	ff		 fild	 DWORD PTR tv478[ebp]
  001c7	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@4e000000
  001cd	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  001d0	d8 89 40 03 00
	00		 fmul	 DWORD PTR [ecx+832]
  001d6	d9 5d 90	 fstp	 DWORD PTR _fltNoise$2705[ebp]

; 1452 : 			Float fltWeightRatio = (float)pow(10.0f,(rgiMaskQ[iBarkResampled] - iMaxMaskQ)/16.0f);

  001d9	8b 55 f0	 mov	 edx, DWORD PTR _iBarkResampled$[ebp]
  001dc	8b 45 b0	 mov	 eax, DWORD PTR _rgiMaskQ$[ebp]
  001df	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  001e2	2b 4d fc	 sub	 ecx, DWORD PTR _iMaxMaskQ$[ebp]
  001e5	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv483[ebp], ecx
  001eb	db 85 78 ff ff
	ff		 fild	 DWORD PTR tv483[ebp]
  001f1	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@41800000
  001f7	83 ec 08	 sub	 esp, 8
  001fa	dd 1c 24	 fstp	 QWORD PTR [esp]
  001fd	68 00 00 24 40	 push	 1076101120		; 40240000H
  00202	6a 00		 push	 0
  00204	e8 00 00 00 00	 call	 _pow
  00209	83 c4 10	 add	 esp, 16			; 00000010H
  0020c	d9 5d 8c	 fstp	 DWORD PTR _fltWeightRatio$2708[ebp]

; 1453 : 			fltCoefRecon  = (Float) (fltNoise * fltWeightRatio * dblQuantStep);

  0020f	d9 45 90	 fld	 DWORD PTR _fltNoise$2705[ebp]
  00212	d8 4d 8c	 fmul	 DWORD PTR _fltWeightRatio$2708[ebp]
  00215	dc 4d 98	 fmul	 QWORD PTR _dblQuantStep$2699[ebp]
  00218	d9 5d 94	 fstp	 DWORD PTR _fltCoefRecon$2701[ebp]

; 1454 : 			rgiCoefRecon [iRecon] = COEF_FROM_FLOAT(fltCoefRecon);

  0021b	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  0021e	8b 45 d4	 mov	 eax, DWORD PTR _rgiCoefRecon$[ebp]
  00221	8b 4d 94	 mov	 ecx, DWORD PTR _fltCoefRecon$2701[ebp]
  00224	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 1455 : 			MONITOR_COUNT(gMC_IQ_Float,9);
; 1456 : 			iRecon++;

  00227	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  0022a	83 c2 01	 add	 edx, 1
  0022d	89 55 cc	 mov	 DWORD PTR _iRecon$[ebp], edx

; 1457 : 		}

  00230	e9 66 ff ff ff	 jmp	 $L2703
$L2713:

; 1458 : 	}
; 1459 : 
; 1460 :     while  (iRecon < pau->m_iFirstNoiseIndex) 

  00235	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00238	8b 4d cc	 mov	 ecx, DWORD PTR _iRecon$[ebp]
  0023b	3b 88 c4 03 00
	00		 cmp	 ecx, DWORD PTR [eax+964]
  00241	0f 8d ed 00 00
	00		 jge	 $L2723

; 1461 :     {
; 1462 :         iReconTarget = prvScanForNextBarkIndex( iRecon, &iBarkResampled, pau->m_iFirstNoiseIndex, rgiBarkIndexResampled, MRI );

  00247	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0024a	8b d4		 mov	 edx, esp
  0024c	8b 45 b4	 mov	 eax, DWORD PTR _MRI$[ebp]
  0024f	89 02		 mov	 DWORD PTR [edx], eax
  00251	8b 4d b8	 mov	 ecx, DWORD PTR _MRI$[ebp+4]
  00254	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00257	8b 45 bc	 mov	 eax, DWORD PTR _MRI$[ebp+8]
  0025a	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0025d	8b 4d c0	 mov	 ecx, DWORD PTR _rgiBarkIndexResampled$[ebp]
  00260	51		 push	 ecx
  00261	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00264	8b 82 c4 03 00
	00		 mov	 eax, DWORD PTR [edx+964]
  0026a	50		 push	 eax
  0026b	8d 4d f0	 lea	 ecx, DWORD PTR _iBarkResampled$[ebp]
  0026e	51		 push	 ecx
  0026f	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  00272	52		 push	 edx
  00273	e8 00 00 00 00	 call	 _prvScanForNextBarkIndex@28
  00278	89 45 a4	 mov	 DWORD PTR _iReconTarget$[ebp], eax

; 1463 :         
; 1464 :         qfltQuantizer = prvWeightedQuantization( pau, ppcinfo, iBarkResampled );

  0027b	8b 45 f0	 mov	 eax, DWORD PTR _iBarkResampled$[ebp]
  0027e	50		 push	 eax
  0027f	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  00282	51		 push	 ecx
  00283	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  00286	52		 push	 edx
  00287	e8 00 00 00 00	 call	 _prvWeightedQuantization_XDS@12
  0028c	d9 5d c4	 fstp	 DWORD PTR _qfltQuantizer$[ebp]
$L2716:

; 1465 :         INTEGER_ONLY( qfltQuantizer.iFracBits += COEF_PLUS_NOISE_FRAC_BITS - 31 );      // Account for MULT_HI in loop below
; 1466 :         //// Float Quantizer = qfltQuantizer.iFraction/(512.0F*(1<<qfltQuantizer.iFracBits)
; 1467 :         SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);              
; 1468 :         
; 1469 :         while ( iRecon < iReconTarget )

  0028f	8b 45 cc	 mov	 eax, DWORD PTR _iRecon$[ebp]
  00292	3b 45 a4	 cmp	 eax, DWORD PTR _iReconTarget$[ebp]
  00295	7d 47		 jge	 SHORT $L2717

; 1470 :         {   
; 1471 :             //  CoefRecon[iR] = (CoefQ[iQ] + rand()*DitherLevel) * (10^(1/16)) ^ (MaskQ[iB]-Max(MaskQ[])) * (10^(1/20)) ^ QuantStepSize
; 1472 :             qrand = quickRand (&(pau->m_tRandState));       

  00297	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  0029a	81 c1 08 04 00
	00		 add	 ecx, 1032		; 00000408H
  002a0	51		 push	 ecx
  002a1	e8 00 00 00 00	 call	 _quickRand@4
  002a6	89 45 ec	 mov	 DWORD PTR _qrand$[ebp], eax

; 1473 :             //// Float qrand = qrand/(1024.0F*(1<<25))
; 1474 :             CoefPlusNoiseInvQuant( iRecon, iCoefQ, qrand, rgiCoefQ, rgiCoefRecon, qfltQuantizer, iShift );

  002a9	8b 55 a8	 mov	 edx, DWORD PTR _iShift$[ebp]
  002ac	52		 push	 edx
  002ad	8b 45 c4	 mov	 eax, DWORD PTR _qfltQuantizer$[ebp]
  002b0	50		 push	 eax
  002b1	8b 4d d4	 mov	 ecx, DWORD PTR _rgiCoefRecon$[ebp]
  002b4	51		 push	 ecx
  002b5	8b 55 ac	 mov	 edx, DWORD PTR _rgiCoefQ$[ebp]
  002b8	52		 push	 edx
  002b9	8b 45 ec	 mov	 eax, DWORD PTR _qrand$[ebp]
  002bc	50		 push	 eax
  002bd	8b 4d e8	 mov	 ecx, DWORD PTR _iCoefQ$[ebp]
  002c0	51		 push	 ecx
  002c1	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  002c4	52		 push	 edx
  002c5	e8 00 00 00 00	 call	 _CoefPlusNoiseInvQuant@28

; 1475 :             //// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
; 1476 :             
; 1477 :             VERIFY_COEF_RECON_MR(iRecon,qrand,-1,iBarkResampled);
; 1478 : #if defined (SMOOTH_NMR)
; 1479 :             if (rgiCoefQ[iCoefQ]) rgfMaskNeededForBark[iBark] = WMAB_TRUE;
; 1480 : #endif // SMOOTH_NMR
; 1481 :             
; 1482 :             iRecon++;

  002ca	8b 45 cc	 mov	 eax, DWORD PTR _iRecon$[ebp]
  002cd	83 c0 01	 add	 eax, 1
  002d0	89 45 cc	 mov	 DWORD PTR _iRecon$[ebp], eax

; 1483 :             iCoefQ++;

  002d3	8b 4d e8	 mov	 ecx, DWORD PTR _iCoefQ$[ebp]
  002d6	83 c1 01	 add	 ecx, 1
  002d9	89 4d e8	 mov	 DWORD PTR _iCoefQ$[ebp], ecx

; 1484 :         }

  002dc	eb b1		 jmp	 SHORT $L2716
$L2717:

; 1485 :         if (iResampleIndex (iRecon+1, MRI) >= rgiBarkIndexResampled [iBarkResampled+1]) 

  002de	83 ec 0c	 sub	 esp, 12			; 0000000cH
  002e1	8b d4		 mov	 edx, esp
  002e3	8b 45 b4	 mov	 eax, DWORD PTR _MRI$[ebp]
  002e6	89 02		 mov	 DWORD PTR [edx], eax
  002e8	8b 4d b8	 mov	 ecx, DWORD PTR _MRI$[ebp+4]
  002eb	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  002ee	8b 45 bc	 mov	 eax, DWORD PTR _MRI$[ebp+8]
  002f1	89 42 08	 mov	 DWORD PTR [edx+8], eax
  002f4	8b 4d cc	 mov	 ecx, DWORD PTR _iRecon$[ebp]
  002f7	83 c1 01	 add	 ecx, 1
  002fa	51		 push	 ecx
  002fb	e8 00 00 00 00	 call	 _iResampleIndex@16
  00300	8b 55 f0	 mov	 edx, DWORD PTR _iBarkResampled$[ebp]
  00303	8b 4d c0	 mov	 ecx, DWORD PTR _rgiBarkIndexResampled$[ebp]
  00306	3b 44 91 04	 cmp	 eax, DWORD PTR [ecx+edx*4+4]
  0030a	7c 09		 jl	 SHORT $L2720

; 1486 :             iBarkResampled++;       // normal to increment except when hitting FirstNoiseIndex

  0030c	8b 55 f0	 mov	 edx, DWORD PTR _iBarkResampled$[ebp]
  0030f	83 c2 01	 add	 edx, 1
  00312	89 55 f0	 mov	 DWORD PTR _iBarkResampled$[ebp], edx
$L2720:

; 1487 :         while( iRecon >= rgiBarkIndex[iBark+1] )

  00315	8b 45 dc	 mov	 eax, DWORD PTR _iBark$[ebp]
  00318	8b 4d e0	 mov	 ecx, DWORD PTR _rgiBarkIndex$[ebp]
  0031b	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  0031e	3b 54 81 04	 cmp	 edx, DWORD PTR [ecx+eax*4+4]
  00322	7c 0b		 jl	 SHORT $L2721

; 1488 :             iBark++;

  00324	8b 45 dc	 mov	 eax, DWORD PTR _iBark$[ebp]
  00327	83 c0 01	 add	 eax, 1
  0032a	89 45 dc	 mov	 DWORD PTR _iBark$[ebp], eax
  0032d	eb e6		 jmp	 SHORT $L2720
$L2721:

; 1489 :     }

  0032f	e9 01 ff ff ff	 jmp	 $L2713
$L2723:

; 1490 :     
; 1491 :     while  (iRecon < pau->m_cHighCutOff) 

  00334	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00337	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  0033a	3b 91 28 03 00
	00		 cmp	 edx, DWORD PTR [ecx+808]
  00340	0f 8d 5a 02 00
	00		 jge	 $L2724

; 1492 :     {   // These Bands may or may not be coded, treat as appropriate
; 1493 :         
; 1494 :         if ( (rgbBandNotCoded [iBark] == 1))

  00346	8b 45 f8	 mov	 eax, DWORD PTR _rgbBandNotCoded$[ebp]
  00349	03 45 dc	 add	 eax, DWORD PTR _iBark$[ebp]
  0034c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0034f	83 f9 01	 cmp	 ecx, 1
  00352	0f 85 3f 01 00
	00		 jne	 $L2725

; 1495 :         {   
; 1496 :             Int iLoopMax;
; 1497 :             
; 1498 :             
; 1499 :             // CoefRecon[iR] = rand() * ((10^(1/16)) ^ (MaskQ[iB]-Max(MaskQ[])) * sqrt( BandWeight[iN]/BandWeight[cN-1] ) * ((10^(1/20)) ^ NoisePower[iN])
; 1500 :             // Note BandsNotCoded span whole "natural" bark bands, which are not resampled and are not limited by m_cHighCutOff
; 1501 :             FastFloat ffltMaskPower, ffltNoisePower;
; 1502 :             
; 1503 : #if defined (SMOOTH_NMR)
; 1504 :             rgfMaskNeededForBark[iBark] = WMAB_TRUE;
; 1505 : #endif // SMOOTH_NMR
; 1506 : 
; 1507 :             assert( iNoiseBand < cNoiseBand );
; 1508 :             
; 1509 :             // auCalcQuantStep( rgiNoisePower[iNoiseBand], &ffltNoisePower.iFraction, &ffltNoisePower.iFracBits );
; 1510 :             ffltNoisePower = FASTFLOAT_FROM_QUANTSTEPTYPE( qstCalcQuantStep( rgiNoisePower[iNoiseBand] ) );

  00358	8b 55 e4	 mov	 edx, DWORD PTR _iNoiseBand$[ebp]
  0035b	8b 45 c8	 mov	 eax, DWORD PTR _rgiNoisePower$[ebp]
  0035e	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00361	51		 push	 ecx
  00362	e8 00 00 00 00	 call	 _qstCalcQuantStep_XDS@4
  00367	d9 5d 88	 fstp	 DWORD PTR _ffltNoisePower$2728[ebp]

; 1511 :             ffltNoisePower = FASTFLOAT_MULT( ffltNoisePower, rgffltSqrtBWRatio[iNoiseBand] );

  0036a	8b 55 e4	 mov	 edx, DWORD PTR _iNoiseBand$[ebp]
  0036d	8b 45 d0	 mov	 eax, DWORD PTR _rgffltSqrtBWRatio$[ebp]
  00370	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  00373	d8 4d 88	 fmul	 DWORD PTR _ffltNoisePower$2728[ebp]
  00376	d9 5d 88	 fstp	 DWORD PTR _ffltNoisePower$2728[ebp]

; 1512 :             //// Float Noise Power = ffltNoisePower.iFraction/(4.0F*(1<<ffltNoisePower.iFracBits))
; 1513 :             
; 1514 :             iLoopMax = min(rgiBarkIndex[iBark+1], pau->m_cHighCutOff);

  00379	8b 4d dc	 mov	 ecx, DWORD PTR _iBark$[ebp]
  0037c	8b 55 e0	 mov	 edx, DWORD PTR _rgiBarkIndex$[ebp]
  0037f	8b 45 08	 mov	 eax, DWORD PTR _pau$[ebp]
  00382	8b 4c 8a 04	 mov	 ecx, DWORD PTR [edx+ecx*4+4]
  00386	3b 88 28 03 00
	00		 cmp	 ecx, DWORD PTR [eax+808]
  0038c	7d 12		 jge	 SHORT $L2845
  0038e	8b 55 dc	 mov	 edx, DWORD PTR _iBark$[ebp]
  00391	8b 45 e0	 mov	 eax, DWORD PTR _rgiBarkIndex$[ebp]
  00394	8b 4c 90 04	 mov	 ecx, DWORD PTR [eax+edx*4+4]
  00398	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv246[ebp], ecx
  0039e	eb 0f		 jmp	 SHORT $L2846
$L2845:
  003a0	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  003a3	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  003a9	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv246[ebp], eax
$L2846:
  003af	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv246[ebp]
  003b5	89 4d 84	 mov	 DWORD PTR _iLoopMax$2726[ebp], ecx
$L2731:

; 1515 :             while(iRecon < iLoopMax)

  003b8	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  003bb	3b 55 84	 cmp	 edx, DWORD PTR _iLoopMax$2726[ebp]
  003be	0f 8d c5 00 00
	00		 jge	 $L2732

; 1516 :             {
; 1517 :                 ffltMaskPower = ffltMaskPower10( rgiMaskQ[iBarkResampled] - iMaxMaskQ );

  003c4	8b 45 f0	 mov	 eax, DWORD PTR _iBarkResampled$[ebp]
  003c7	8b 4d b0	 mov	 ecx, DWORD PTR _rgiMaskQ$[ebp]
  003ca	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  003cd	2b 55 fc	 sub	 edx, DWORD PTR _iMaxMaskQ$[ebp]
  003d0	52		 push	 edx
  003d1	e8 00 00 00 00	 call	 _ffltMaskPower10@4
  003d6	d9 55 80	 fst	 DWORD PTR _ffltMaskPower$2727[ebp]

; 1518 :                 //// Float Mask Power = ffltMaskPower.iFraction/(1.0F*(1<<ffltMaskPower.iFracBits))
; 1519 :                 
; 1520 :                 qfltQuantizer = FASTFLOAT_MULT( ffltMaskPower, ffltNoisePower );

  003d9	d8 4d 88	 fmul	 DWORD PTR _ffltNoisePower$2728[ebp]
  003dc	d9 5d c4	 fstp	 DWORD PTR _qfltQuantizer$[ebp]

; 1521 :                 INTEGER_ONLY( qfltQuantizer.iFracBits += (RAND_FRAC_BITS - 31) );       // Account for MULT_HI in loop below
; 1522 :                 //// Float Quantizer = qfltQuantizer.iFraction/(4.0F*(1<<qfltQuantizer.iFracBits))
; 1523 :                 SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);
; 1524 :                 
; 1525 :                 iReconTarget = prvScanForNextBarkIndex( iRecon, &iBarkResampled, iLoopMax, rgiBarkIndexResampled, MRI );

  003df	83 ec 0c	 sub	 esp, 12			; 0000000cH
  003e2	8b c4		 mov	 eax, esp
  003e4	8b 4d b4	 mov	 ecx, DWORD PTR _MRI$[ebp]
  003e7	89 08		 mov	 DWORD PTR [eax], ecx
  003e9	8b 55 b8	 mov	 edx, DWORD PTR _MRI$[ebp+4]
  003ec	89 50 04	 mov	 DWORD PTR [eax+4], edx
  003ef	8b 4d bc	 mov	 ecx, DWORD PTR _MRI$[ebp+8]
  003f2	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  003f5	8b 55 c0	 mov	 edx, DWORD PTR _rgiBarkIndexResampled$[ebp]
  003f8	52		 push	 edx
  003f9	8b 45 84	 mov	 eax, DWORD PTR _iLoopMax$2726[ebp]
  003fc	50		 push	 eax
  003fd	8d 4d f0	 lea	 ecx, DWORD PTR _iBarkResampled$[ebp]
  00400	51		 push	 ecx
  00401	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  00404	52		 push	 edx
  00405	e8 00 00 00 00	 call	 _prvScanForNextBarkIndex@28
  0040a	89 45 a4	 mov	 DWORD PTR _iReconTarget$[ebp], eax
$L2734:

; 1526 :                 while ( iRecon < iReconTarget )

  0040d	8b 45 cc	 mov	 eax, DWORD PTR _iRecon$[ebp]
  00410	3b 45 a4	 cmp	 eax, DWORD PTR _iReconTarget$[ebp]
  00413	7d 38		 jge	 SHORT $L2735

; 1527 :                 {   
; 1528 :                     qrand = quickRand (&(pau->m_tRandState));

  00415	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00418	81 c1 08 04 00
	00		 add	 ecx, 1032		; 00000408H
  0041e	51		 push	 ecx
  0041f	e8 00 00 00 00	 call	 _quickRand@4
  00424	89 45 ec	 mov	 DWORD PTR _qrand$[ebp], eax

; 1529 :                     //// Float qrand = qrand/(1024.0F*(1<<25))
; 1530 :                     iCoefRecon = RAND_X_QUANT( RAND_TO_NOISE(qrand), qfltQuantizer );

  00427	db 45 ec	 fild	 DWORD PTR _qrand$[ebp]
  0042a	d8 0d 00 00 00
	00		 fmul	 DWORD PTR _cfltInverseRand2Float_XDS
  00430	d8 4d c4	 fmul	 DWORD PTR _qfltQuantizer$[ebp]
  00433	d9 5d d8	 fstp	 DWORD PTR _iCoefRecon$[ebp]

; 1531 :                     //// Float CoefRecon = iCoefRecon/(1.0F*(1<<qfltQuantizer.iFracBits))
; 1532 :                     rgiCoefRecon [iRecon] = SCALE_COEF_RECON(iCoefRecon);

  00436	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  00439	8b 45 d4	 mov	 eax, DWORD PTR _rgiCoefRecon$[ebp]
  0043c	8b 4d d8	 mov	 ecx, DWORD PTR _iCoefRecon$[ebp]
  0043f	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 1533 :                     //// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
; 1534 :                     
; 1535 :                     VERIFY_COEF_RECON_MR(iRecon,qrand,cNoiseBand,iBarkResampled);
; 1536 :                     
; 1537 :                     iRecon++;

  00442	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  00445	83 c2 01	 add	 edx, 1
  00448	89 55 cc	 mov	 DWORD PTR _iRecon$[ebp], edx

; 1538 :                 }

  0044b	eb c0		 jmp	 SHORT $L2734
$L2735:

; 1539 :                 if (iResampleIndex (iRecon+1, MRI) >= rgiBarkIndexResampled [iBarkResampled+1]) 

  0044d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00450	8b c4		 mov	 eax, esp
  00452	8b 4d b4	 mov	 ecx, DWORD PTR _MRI$[ebp]
  00455	89 08		 mov	 DWORD PTR [eax], ecx
  00457	8b 55 b8	 mov	 edx, DWORD PTR _MRI$[ebp+4]
  0045a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0045d	8b 4d bc	 mov	 ecx, DWORD PTR _MRI$[ebp+8]
  00460	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00463	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  00466	83 c2 01	 add	 edx, 1
  00469	52		 push	 edx
  0046a	e8 00 00 00 00	 call	 _iResampleIndex@16
  0046f	8b 4d f0	 mov	 ecx, DWORD PTR _iBarkResampled$[ebp]
  00472	8b 55 c0	 mov	 edx, DWORD PTR _rgiBarkIndexResampled$[ebp]
  00475	3b 44 8a 04	 cmp	 eax, DWORD PTR [edx+ecx*4+4]
  00479	7c 09		 jl	 SHORT $L2736

; 1540 :                     iBarkResampled++;       // normal to increment except when hitting end of Bark Band

  0047b	8b 45 f0	 mov	 eax, DWORD PTR _iBarkResampled$[ebp]
  0047e	83 c0 01	 add	 eax, 1
  00481	89 45 f0	 mov	 DWORD PTR _iBarkResampled$[ebp], eax
$L2736:

; 1541 :             }

  00484	e9 2f ff ff ff	 jmp	 $L2731
$L2732:

; 1542 :             iNoiseBand++;

  00489	8b 4d e4	 mov	 ecx, DWORD PTR _iNoiseBand$[ebp]
  0048c	83 c1 01	 add	 ecx, 1
  0048f	89 4d e4	 mov	 DWORD PTR _iNoiseBand$[ebp], ecx

; 1543 :         }
; 1544 :         else 

  00492	e9 b3 00 00 00	 jmp	 $L2737
$L2725:

; 1545 :         {   // This Band is Coded (just like those before FirstNoiseIndex)
; 1546 :             // CoefRecon[iR] = (CoefQ[iQ] + rand()*DitherLevel) * 10^(MaskQ[iB]-Max(MaskQ[]))*2.5*0.5/20 * 10^(QuantStepSize/20)
; 1547 :             iReconTarget = prvScanForNextBarkIndex( iRecon, &iBarkResampled, pau->m_cHighCutOff, rgiBarkIndexResampled, MRI );

  00497	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0049a	8b d4		 mov	 edx, esp
  0049c	8b 45 b4	 mov	 eax, DWORD PTR _MRI$[ebp]
  0049f	89 02		 mov	 DWORD PTR [edx], eax
  004a1	8b 4d b8	 mov	 ecx, DWORD PTR _MRI$[ebp+4]
  004a4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  004a7	8b 45 bc	 mov	 eax, DWORD PTR _MRI$[ebp+8]
  004aa	89 42 08	 mov	 DWORD PTR [edx+8], eax
  004ad	8b 4d c0	 mov	 ecx, DWORD PTR _rgiBarkIndexResampled$[ebp]
  004b0	51		 push	 ecx
  004b1	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  004b4	8b 82 28 03 00
	00		 mov	 eax, DWORD PTR [edx+808]
  004ba	50		 push	 eax
  004bb	8d 4d f0	 lea	 ecx, DWORD PTR _iBarkResampled$[ebp]
  004be	51		 push	 ecx
  004bf	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  004c2	52		 push	 edx
  004c3	e8 00 00 00 00	 call	 _prvScanForNextBarkIndex@28
  004c8	89 45 a4	 mov	 DWORD PTR _iReconTarget$[ebp], eax

; 1548 :             if ( iReconTarget > rgiBarkIndex [iBark + 1] )

  004cb	8b 45 dc	 mov	 eax, DWORD PTR _iBark$[ebp]
  004ce	8b 4d e0	 mov	 ecx, DWORD PTR _rgiBarkIndex$[ebp]
  004d1	8b 55 a4	 mov	 edx, DWORD PTR _iReconTarget$[ebp]
  004d4	3b 54 81 04	 cmp	 edx, DWORD PTR [ecx+eax*4+4]
  004d8	7e 0d		 jle	 SHORT $L2738

; 1549 :                 iReconTarget = rgiBarkIndex [iBark + 1];        

  004da	8b 45 dc	 mov	 eax, DWORD PTR _iBark$[ebp]
  004dd	8b 4d e0	 mov	 ecx, DWORD PTR _rgiBarkIndex$[ebp]
  004e0	8b 54 81 04	 mov	 edx, DWORD PTR [ecx+eax*4+4]
  004e4	89 55 a4	 mov	 DWORD PTR _iReconTarget$[ebp], edx
$L2738:

; 1550 :             qfltQuantizer = prvWeightedQuantization( pau, ppcinfo, iBarkResampled );

  004e7	8b 45 f0	 mov	 eax, DWORD PTR _iBarkResampled$[ebp]
  004ea	50		 push	 eax
  004eb	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  004ee	51		 push	 ecx
  004ef	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  004f2	52		 push	 edx
  004f3	e8 00 00 00 00	 call	 _prvWeightedQuantization_XDS@12
  004f8	d9 5d c4	 fstp	 DWORD PTR _qfltQuantizer$[ebp]
$L2740:

; 1551 :             //// Float Quantizer = qfltQuantizer.iFraction/(1.0F*(1<<qfltQuantizer.iFracBits))
; 1552 :             // account for MULT_HI in loop below
; 1553 :             INTEGER_ONLY( qfltQuantizer.iFracBits += COEF_PLUS_NOISE_FRAC_BITS - 31 );
; 1554 :             //// Float Quantizer = qfltQuantizer.iFraction/(512.0F*(1<<qfltQuantizer.iFracBits))
; 1555 :             SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);
; 1556 :             
; 1557 :             while ( iRecon < iReconTarget )

  004fb	8b 45 cc	 mov	 eax, DWORD PTR _iRecon$[ebp]
  004fe	3b 45 a4	 cmp	 eax, DWORD PTR _iReconTarget$[ebp]
  00501	7d 47		 jge	 SHORT $L2737

; 1558 :             {   
; 1559 :                 //  CoefRecon[iR] = (CoefQ[iQ] + rand()*DitherLevel) * (10^(1/16)) ^ (MaskQ[iB]-Max(MaskQ[])) * (10^(1/20)) ^ QuantStepSize
; 1560 :                 qrand = quickRand (&(pau->m_tRandState));

  00503	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00506	81 c1 08 04 00
	00		 add	 ecx, 1032		; 00000408H
  0050c	51		 push	 ecx
  0050d	e8 00 00 00 00	 call	 _quickRand@4
  00512	89 45 ec	 mov	 DWORD PTR _qrand$[ebp], eax

; 1561 :                 //// Float qrand = qrand/(1024.0F*(1<<25))
; 1562 :                 CoefPlusNoiseInvQuant( iRecon, iCoefQ, qrand, rgiCoefQ, rgiCoefRecon, qfltQuantizer, iShift );

  00515	8b 55 a8	 mov	 edx, DWORD PTR _iShift$[ebp]
  00518	52		 push	 edx
  00519	8b 45 c4	 mov	 eax, DWORD PTR _qfltQuantizer$[ebp]
  0051c	50		 push	 eax
  0051d	8b 4d d4	 mov	 ecx, DWORD PTR _rgiCoefRecon$[ebp]
  00520	51		 push	 ecx
  00521	8b 55 ac	 mov	 edx, DWORD PTR _rgiCoefQ$[ebp]
  00524	52		 push	 edx
  00525	8b 45 ec	 mov	 eax, DWORD PTR _qrand$[ebp]
  00528	50		 push	 eax
  00529	8b 4d e8	 mov	 ecx, DWORD PTR _iCoefQ$[ebp]
  0052c	51		 push	 ecx
  0052d	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  00530	52		 push	 edx
  00531	e8 00 00 00 00	 call	 _CoefPlusNoiseInvQuant@28

; 1563 :                 //// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
; 1564 :                 
; 1565 : #if defined (SMOOTH_NMR)
; 1566 :                 if (rgiCoefQ[iCoefQ]) rgfMaskNeededForBark[iBark] = WMAB_TRUE;
; 1567 : #endif // SMOOTH_NMR
; 1568 : 
; 1569 :                 VERIFY_COEF_RECON_MR(iRecon,qrand,-1,iBarkResampled);
; 1570 :                 
; 1571 :                 iRecon++;

  00536	8b 45 cc	 mov	 eax, DWORD PTR _iRecon$[ebp]
  00539	83 c0 01	 add	 eax, 1
  0053c	89 45 cc	 mov	 DWORD PTR _iRecon$[ebp], eax

; 1572 :                 iCoefQ++;

  0053f	8b 4d e8	 mov	 ecx, DWORD PTR _iCoefQ$[ebp]
  00542	83 c1 01	 add	 ecx, 1
  00545	89 4d e8	 mov	 DWORD PTR _iCoefQ$[ebp], ecx

; 1573 :             }

  00548	eb b1		 jmp	 SHORT $L2740
$L2737:

; 1574 :         }
; 1575 :         if (iResampleIndex (iRecon+1, MRI) >= rgiBarkIndexResampled [iBarkResampled+1]) 

  0054a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0054d	8b d4		 mov	 edx, esp
  0054f	8b 45 b4	 mov	 eax, DWORD PTR _MRI$[ebp]
  00552	89 02		 mov	 DWORD PTR [edx], eax
  00554	8b 4d b8	 mov	 ecx, DWORD PTR _MRI$[ebp+4]
  00557	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0055a	8b 45 bc	 mov	 eax, DWORD PTR _MRI$[ebp+8]
  0055d	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00560	8b 4d cc	 mov	 ecx, DWORD PTR _iRecon$[ebp]
  00563	83 c1 01	 add	 ecx, 1
  00566	51		 push	 ecx
  00567	e8 00 00 00 00	 call	 _iResampleIndex@16
  0056c	8b 55 f0	 mov	 edx, DWORD PTR _iBarkResampled$[ebp]
  0056f	8b 4d c0	 mov	 ecx, DWORD PTR _rgiBarkIndexResampled$[ebp]
  00572	3b 44 91 04	 cmp	 eax, DWORD PTR [ecx+edx*4+4]
  00576	7c 09		 jl	 SHORT $L2744

; 1576 :             iBarkResampled++;       // normal to increment except when hitting HighCutOff

  00578	8b 55 f0	 mov	 edx, DWORD PTR _iBarkResampled$[ebp]
  0057b	83 c2 01	 add	 edx, 1
  0057e	89 55 f0	 mov	 DWORD PTR _iBarkResampled$[ebp], edx
$L2744:

; 1577 :         while( iRecon >= rgiBarkIndex[iBark+1] )

  00581	8b 45 dc	 mov	 eax, DWORD PTR _iBark$[ebp]
  00584	8b 4d e0	 mov	 ecx, DWORD PTR _rgiBarkIndex$[ebp]
  00587	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  0058a	3b 54 81 04	 cmp	 edx, DWORD PTR [ecx+eax*4+4]
  0058e	7c 0b		 jl	 SHORT $L2745

; 1578 :             iBark++;

  00590	8b 45 dc	 mov	 eax, DWORD PTR _iBark$[ebp]
  00593	83 c0 01	 add	 eax, 1
  00596	89 45 dc	 mov	 DWORD PTR _iBark$[ebp], eax
  00599	eb e6		 jmp	 SHORT $L2744
$L2745:

; 1579 :     }

  0059b	e9 94 fd ff ff	 jmp	 $L2723
$L2724:

; 1580 :     
; 1581 :     iReconTarget = pau->m_cSubband;

  005a0	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  005a3	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  005a6	89 55 a4	 mov	 DWORD PTR _iReconTarget$[ebp], edx

; 1582 :     if  (iRecon < iReconTarget) 

  005a9	8b 45 cc	 mov	 eax, DWORD PTR _iRecon$[ebp]
  005ac	3b 45 a4	 cmp	 eax, DWORD PTR _iReconTarget$[ebp]
  005af	0f 8d 87 00 00
	00		 jge	 $L2746
$L2748:

; 1583 :     {   //  CoefRecon[iR] = rand() * DitherLevel * (10^(1/16)) ^ (MaskQ[iB for HighCutOff-1]-Max(MaskQ[])) * (10^(1/20)) ^ QuantStepSize
; 1584 :         // We may have scaned past m_cHighCutOff doing a BandNotCoded, so search back to find it.
; 1585 :         while ( (((pau->m_cHighCutOff-1) << MRI.iMaskResampleRatioPow) >> MASKQ_RESAMPLE_OFFSET) < rgiBarkIndexResampled [iBarkResampled] ) 

  005b5	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  005b8	8b 91 28 03 00
	00		 mov	 edx, DWORD PTR [ecx+808]
  005be	83 ea 01	 sub	 edx, 1
  005c1	8b 4d b8	 mov	 ecx, DWORD PTR _MRI$[ebp+4]
  005c4	d3 e2		 shl	 edx, cl
  005c6	c1 fa 06	 sar	 edx, 6
  005c9	8b 45 f0	 mov	 eax, DWORD PTR _iBarkResampled$[ebp]
  005cc	8b 4d c0	 mov	 ecx, DWORD PTR _rgiBarkIndexResampled$[ebp]
  005cf	3b 14 81	 cmp	 edx, DWORD PTR [ecx+eax*4]
  005d2	7d 0b		 jge	 SHORT $L2749

; 1586 :             --iBarkResampled;

  005d4	8b 55 f0	 mov	 edx, DWORD PTR _iBarkResampled$[ebp]
  005d7	83 ea 01	 sub	 edx, 1
  005da	89 55 f0	 mov	 DWORD PTR _iBarkResampled$[ebp], edx
  005dd	eb d6		 jmp	 SHORT $L2748
$L2749:

; 1587 :         
; 1588 :         qfltQuantizer = prvWeightedQuantization( pau, ppcinfo, iBarkResampled );

  005df	8b 45 f0	 mov	 eax, DWORD PTR _iBarkResampled$[ebp]
  005e2	50		 push	 eax
  005e3	8b 4d 0c	 mov	 ecx, DWORD PTR _ppcinfo$[ebp]
  005e6	51		 push	 ecx
  005e7	8b 55 08	 mov	 edx, DWORD PTR _pau$[ebp]
  005ea	52		 push	 edx
  005eb	e8 00 00 00 00	 call	 _prvWeightedQuantization_XDS@12
  005f0	d9 55 c4	 fst	 DWORD PTR _qfltQuantizer$[ebp]

; 1589 :         //// Float Quantizer = qfltQuantizer.iFraction/(1.0F*(1<<qfltQuantizer.iFracBits))
; 1590 :         UNNORMED_MULT( qfltQuantizer, cDitherFactorMR, (DITHER_FRAC_BITS - 31) + (RAND_FRAC_BITS - 31) );

  005f3	d8 0d 00 00 00
	00		 fmul	 DWORD PTR _cDitherFactorMR
  005f9	d9 5d c4	 fstp	 DWORD PTR _qfltQuantizer$[ebp]
$L2751:

; 1591 :         //// Float Quantizer = qfltQuantizer.iFraction/(4.0F*(1<<qfltQuantizer.iFracBits))
; 1592 :         SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);
; 1593 :         
; 1594 :         while ( iRecon < iReconTarget )

  005fc	8b 45 cc	 mov	 eax, DWORD PTR _iRecon$[ebp]
  005ff	3b 45 a4	 cmp	 eax, DWORD PTR _iReconTarget$[ebp]
  00602	7d 38		 jge	 SHORT $L2746

; 1595 :         {   
; 1596 :             qrand = quickRand (&(pau->m_tRandState));

  00604	8b 4d 08	 mov	 ecx, DWORD PTR _pau$[ebp]
  00607	81 c1 08 04 00
	00		 add	 ecx, 1032		; 00000408H
  0060d	51		 push	 ecx
  0060e	e8 00 00 00 00	 call	 _quickRand@4
  00613	89 45 ec	 mov	 DWORD PTR _qrand$[ebp], eax

; 1597 :             //// Float qrand = qrand/(1024.0F*(1<<25))
; 1598 :             iCoefRecon = RAND_X_QUANT( RAND_TO_NOISE(qrand), qfltQuantizer );

  00616	db 45 ec	 fild	 DWORD PTR _qrand$[ebp]
  00619	d8 0d 00 00 00
	00		 fmul	 DWORD PTR _cfltInverseRand2Float_XDS
  0061f	d8 4d c4	 fmul	 DWORD PTR _qfltQuantizer$[ebp]
  00622	d9 5d d8	 fstp	 DWORD PTR _iCoefRecon$[ebp]

; 1599 :             //// Float CoefRecon = iCoefRecon/(1.0F*(1<<qfltQuantizer.iFracBits))
; 1600 :             rgiCoefRecon [iRecon] = SCALE_COEF_RECON(iCoefRecon);

  00625	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  00628	8b 45 d4	 mov	 eax, DWORD PTR _rgiCoefRecon$[ebp]
  0062b	8b 4d d8	 mov	 ecx, DWORD PTR _iCoefRecon$[ebp]
  0062e	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 1601 :             //// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
; 1602 :             
; 1603 :             VERIFY_COEF_RECON_MR(iRecon,qrand,cNoiseBand,iBarkResampled);
; 1604 :             
; 1605 :             iRecon++;

  00631	8b 55 cc	 mov	 edx, DWORD PTR _iRecon$[ebp]
  00634	83 c2 01	 add	 edx, 1
  00637	89 55 cc	 mov	 DWORD PTR _iRecon$[ebp], edx

; 1606 :         }

  0063a	eb c0		 jmp	 SHORT $L2751
$L2746:

; 1607 :     }
; 1608 : 
; 1609 : #   if defined(REFERENCE_RAND_24) || defined(REFERENCE_RAND_16)
; 1610 :         // call the random generator one extra time per subframe to improve subband randomness
; 1611 :         quickRand (&(pau->m_tRandState));
; 1612 : #   endif
; 1613 : 
; 1614 : #   if defined (SMOOTH_NMR)
; 1615 :         // rgfMaskNeededForBark[bark corresponding to HighCutOff-1 should be made true. 
; 1616 :         for (iBark = pau->m_rgcValidBarkBand [pau->m_iIncr]-1; iBark >= 0; iBark--) {
; 1617 :             if ((pau->m_cHighCutOff >= rgiBarkIndex[iBark]) && (pau->m_cHighCutOff < rgiBarkIndex[iBark+1])) {
; 1618 :                 rgfMaskNeededForBark[iBark] = WMAB_TRUE;
; 1619 :                 break; 
; 1620 :             }
; 1621 :         }
; 1622 : #   endif // SMOOTH_NMR
; 1623 :     
; 1624 :     FUNCTION_PROFILE_STOP(&fp);
; 1625 : 	return WMA_OK;

  0063c	a1 00 00 00 00	 mov	 eax, DWORD PTR _WMA_OK

; 1626 : }

  00641	5e		 pop	 esi
  00642	8b e5		 mov	 esp, ebp
  00644	5d		 pop	 ebp
  00645	c2 0c 00	 ret	 12			; 0000000cH
_prvInverseQuantizeMidRate_XDS@12 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\common\macros.h
WMADEC	ENDS
;	COMDAT _quickRand@4
WMADEC	SEGMENT
_c$ = -16
_iTemp1$ = -12
_a$ = -8
_iTemp$ = -4
_ptRandState$ = 8
_quickRand@4 PROC NEAR					; COMDAT

; 774  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 775  :         const U32 a = 1664525;

  00006	c7 45 f8 0d 66
	19 00		 mov	 DWORD PTR _a$[ebp], 1664525 ; 0019660dH

; 776  :         const U32 c = 1013904223;

  0000d	c7 45 f0 5f f3
	6e 3c		 mov	 DWORD PTR _c$[ebp], 1013904223 ; 3c6ef35fH

; 777  :         I32 iTemp, iTemp1;
; 778  :         //a*x + c has to be done with unsigned 32 bit
; 779  :         ptRandState->uiRand =  a * ptRandState->uiRand + c;

  00014	8b 45 08	 mov	 eax, DWORD PTR _ptRandState$[ebp]
  00017	8b 4d f8	 mov	 ecx, DWORD PTR _a$[ebp]
  0001a	0f af 48 04	 imul	 ecx, DWORD PTR [eax+4]
  0001e	03 4d f0	 add	 ecx, DWORD PTR _c$[ebp]
  00021	8b 55 08	 mov	 edx, DWORD PTR _ptRandState$[ebp]
  00024	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 780  : 
; 781  :         // uiRand values starting from a 0 seed are: 0x3c6ef35f, 0x47502932, 0xd1ccf6e9, 0xaaf95334, 0x6252e503, 0x9f2ec686, 0x57fe6c2d, ...
; 782  : 
; 783  :         // do not change the above - this reference generator has been extensively tested and has excellent randomness properties
; 784  :         // a truism in the world of random number generator theory and practice is:
; 785  :         // "any change, no matter how small, can and will change the properties of the generator and must be fully tested"
; 786  :         // In case you don't know, it can easily take a person-month to fully test a generator.
; 787  :     
; 788  :         // Notwithstanding the above, it is fair to take a function of a random number to shape its range or distribution.
; 789  :         // This we do below to give it a triangular distrbution between -2.5 and 2.5 to roughly approximate a Guassian distribution.
; 790  : 
; 791  :         // cast and shift to make the range (-1, 1) with Binary Point 3.
; 792  :         iTemp = ((I32)(ptRandState->uiRand)) >> 2; 

  00027	8b 45 08	 mov	 eax, DWORD PTR _ptRandState$[ebp]
  0002a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002d	c1 f9 02	 sar	 ecx, 2
  00030	89 4d fc	 mov	 DWORD PTR _iTemp$[ebp], ecx

; 793  : 
; 794  :         // *1.25 to make the range (-1.25, 1.25) 
; 795  :         iTemp += (iTemp>>2);

  00033	8b 55 fc	 mov	 edx, DWORD PTR _iTemp$[ebp]
  00036	c1 fa 02	 sar	 edx, 2
  00039	8b 45 fc	 mov	 eax, DWORD PTR _iTemp$[ebp]
  0003c	03 c2		 add	 eax, edx
  0003e	89 45 fc	 mov	 DWORD PTR _iTemp$[ebp], eax

; 796  :     
; 797  :         // Difference of two random numbers gives a triangle distribution and a range of (-2.5, 2.5)
; 798  :         // it also gives a serial correlation of -0.5 at lag 1.  But all the other lags have normally small correlations.
; 799  :         iTemp1 = iTemp - ptRandState->iPrior;

  00041	8b 4d 08	 mov	 ecx, DWORD PTR _ptRandState$[ebp]
  00044	8b 55 fc	 mov	 edx, DWORD PTR _iTemp$[ebp]
  00047	2b 11		 sub	 edx, DWORD PTR [ecx]
  00049	89 55 f4	 mov	 DWORD PTR _iTemp1$[ebp], edx

; 800  : 
; 801  :         // Save first term of this difference for next time.
; 802  :         ptRandState->iPrior = iTemp;

  0004c	8b 45 08	 mov	 eax, DWORD PTR _ptRandState$[ebp]
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _iTemp$[ebp]
  00052	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 
; 804  :         //return -2.5 to 2.5 with Binary Point = 3 with a triangle distribution
; 805  :         return iTemp1;

  00054	8b 45 f4	 mov	 eax, DWORD PTR _iTemp1$[ebp]

; 806  :     }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
_quickRand@4 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _LOG2@4
WMADEC	SEGMENT
_iLog2$ = -4
_i$ = 8
_LOG2@4	PROC NEAR					; COMDAT

; 956  : {   // returns n where n = log2(2^n) = log2(2^(n+1)-1)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 957  :     U32 iLog2 = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iLog2$[ebp], 0
$L1587:

; 958  :     assert (i != 0);
; 959  :     while ((i >> iLog2) > 1)

  0000b	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _iLog2$[ebp]
  00011	d3 e8		 shr	 eax, cl
  00013	83 f8 01	 cmp	 eax, 1
  00016	76 0b		 jbe	 SHORT $L1588

; 960  :         iLog2++;

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _iLog2$[ebp]
  0001b	83 c1 01	 add	 ecx, 1
  0001e	89 4d fc	 mov	 DWORD PTR _iLog2$[ebp], ecx
  00021	eb e8		 jmp	 SHORT $L1587
$L1588:

; 961  : 
; 962  :     return iLog2;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _iLog2$[ebp]

; 963  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
_LOG2@4	ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\lowrate_common.c
WMADEC	ENDS
;	COMDAT _prvScanForNextBarkIndex@28
WMADEC	SEGMENT
_iReconResampled$ = -12
_iNextBarkIndex$ = -8
_iBarkResampled$ = -4
_iRecon$ = 8
_piBarkResampled$ = 12
_iHighLimit$ = 16
_rgiBarkIndexResampled$ = 20
_MRI$ = 24
_prvScanForNextBarkIndex@28 PROC NEAR			; COMDAT

; 633  : {   //Scan for the next resampled bark index

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 634  : 	Int iNextBarkIndex, iBarkResampled, iReconResampled;
; 635  : 	iReconResampled = iResampleIndex(iRecon, MRI);

  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	8b c4		 mov	 eax, esp
  0000b	8b 4d 18	 mov	 ecx, DWORD PTR _MRI$[ebp]
  0000e	89 08		 mov	 DWORD PTR [eax], ecx
  00010	8b 55 1c	 mov	 edx, DWORD PTR _MRI$[ebp+4]
  00013	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00016	8b 4d 20	 mov	 ecx, DWORD PTR _MRI$[ebp+8]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR _iRecon$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 _iResampleIndex@16
  00025	89 45 f4	 mov	 DWORD PTR _iReconResampled$[ebp], eax
$L2414:

; 636  :     while ( iReconResampled >= rgiBarkIndexResampled [*piBarkResampled+1]) 

  00028	8b 45 0c	 mov	 eax, DWORD PTR _piBarkResampled$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	8b 55 14	 mov	 edx, DWORD PTR _rgiBarkIndexResampled$[ebp]
  00030	8b 45 f4	 mov	 eax, DWORD PTR _iReconResampled$[ebp]
  00033	3b 44 8a 04	 cmp	 eax, DWORD PTR [edx+ecx*4+4]
  00037	7c 0f		 jl	 SHORT $L2415

; 637  : 		++(*piBarkResampled);

  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _piBarkResampled$[ebp]
  0003c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003e	83 c2 01	 add	 edx, 1
  00041	8b 45 0c	 mov	 eax, DWORD PTR _piBarkResampled$[ebp]
  00044	89 10		 mov	 DWORD PTR [eax], edx
  00046	eb e0		 jmp	 SHORT $L2414
$L2415:

; 638  : 	iBarkResampled = *piBarkResampled;

  00048	8b 4d 0c	 mov	 ecx, DWORD PTR _piBarkResampled$[ebp]
  0004b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004d	89 55 fc	 mov	 DWORD PTR _iBarkResampled$[ebp], edx

; 639  : 	if ( iBarkResampled >= MRI.cValidBarkBandLatestUpdate )

  00050	8b 45 fc	 mov	 eax, DWORD PTR _iBarkResampled$[ebp]
  00053	3b 45 20	 cmp	 eax, DWORD PTR _MRI$[ebp+8]
  00056	7c 05		 jl	 SHORT $L2416

; 640  : 	{
; 641  : 		assert( iBarkResampled < MRI.cValidBarkBandLatestUpdate );
; 642  : 		return( MRI.cValidBarkBandLatestUpdate );

  00058	8b 45 20	 mov	 eax, DWORD PTR _MRI$[ebp+8]
  0005b	eb 3a		 jmp	 SHORT $L2409
$L2416:

; 643  : 	}
; 644  : 	iNextBarkIndex = iUnResampleIndex( rgiBarkIndexResampled [iBarkResampled + 1], MRI );

  0005d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00060	8b cc		 mov	 ecx, esp
  00062	8b 55 18	 mov	 edx, DWORD PTR _MRI$[ebp]
  00065	89 11		 mov	 DWORD PTR [ecx], edx
  00067	8b 45 1c	 mov	 eax, DWORD PTR _MRI$[ebp+4]
  0006a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0006d	8b 55 20	 mov	 edx, DWORD PTR _MRI$[ebp+8]
  00070	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00073	8b 45 fc	 mov	 eax, DWORD PTR _iBarkResampled$[ebp]
  00076	8b 4d 14	 mov	 ecx, DWORD PTR _rgiBarkIndexResampled$[ebp]
  00079	8b 54 81 04	 mov	 edx, DWORD PTR [ecx+eax*4+4]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 _iUnResampleIndex@16
  00083	89 45 f8	 mov	 DWORD PTR _iNextBarkIndex$[ebp], eax

; 645  :     if (iNextBarkIndex > iHighLimit) 

  00086	8b 45 f8	 mov	 eax, DWORD PTR _iNextBarkIndex$[ebp]
  00089	3b 45 10	 cmp	 eax, DWORD PTR _iHighLimit$[ebp]
  0008c	7e 06		 jle	 SHORT $L2417

; 646  : 		iNextBarkIndex = iHighLimit;

  0008e	8b 4d 10	 mov	 ecx, DWORD PTR _iHighLimit$[ebp]
  00091	89 4d f8	 mov	 DWORD PTR _iNextBarkIndex$[ebp], ecx
$L2417:

; 647  : 	return iNextBarkIndex;

  00094	8b 45 f8	 mov	 eax, DWORD PTR _iNextBarkIndex$[ebp]
$L2409:

; 648  : }

  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 1c 00	 ret	 28			; 0000001cH
_prvScanForNextBarkIndex@28 ENDP
; Function compile flags: /Odt
WMADEC	ENDS
;	COMDAT _CoefPlusNoiseInvQuant@28
WMADEC	SEGMENT
tv80 = -8
_fltNoise$ = -4
_iRecon$ = 8
_iCoefQ$ = 12
_qrand$ = 16
_rgiCoefQ$ = 20
_rgiCoefRecon$ = 24
_qfltQuantizer$ = 28
_iShift$ = 32
_CoefPlusNoiseInvQuant@28 PROC NEAR			; COMDAT

; 1052 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1053 : 	Float fltNoise =  qrand * (cDitherFactorMR * cfltInverseRand2Float);

  00006	db 45 10	 fild	 DWORD PTR _qrand$[ebp]
  00009	d9 05 00 00 00
	00		 fld	 DWORD PTR _cDitherFactorMR
  0000f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR _cfltInverseRand2Float_XDS
  00015	de c9		 fmulp	 ST(1), ST(0)
  00017	d9 5d fc	 fstp	 DWORD PTR _fltNoise$[ebp]

; 1054 : 	rgiCoefRecon [iRecon] = (rgiCoefQ[iCoefQ] + fltNoise) * qfltQuantizer;

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _iCoefQ$[ebp]
  0001d	8b 4d 14	 mov	 ecx, DWORD PTR _rgiCoefQ$[ebp]
  00020	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  00024	89 55 f8	 mov	 DWORD PTR tv80[ebp], edx
  00027	db 45 f8	 fild	 DWORD PTR tv80[ebp]
  0002a	d8 45 fc	 fadd	 DWORD PTR _fltNoise$[ebp]
  0002d	d8 4d 1c	 fmul	 DWORD PTR _qfltQuantizer$[ebp]
  00030	8b 45 08	 mov	 eax, DWORD PTR _iRecon$[ebp]
  00033	8b 4d 18	 mov	 ecx, DWORD PTR _rgiCoefRecon$[ebp]
  00036	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]

; 1055 : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 1c 00	 ret	 28			; 0000001cH
_CoefPlusNoiseInvQuant@28 ENDP
WMADEC	ENDS
END
