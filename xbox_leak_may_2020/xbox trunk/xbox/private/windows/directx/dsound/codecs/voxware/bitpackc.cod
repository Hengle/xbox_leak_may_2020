; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\bitpackc.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EB@BAMFCFOH@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@HOKLLIAM@cDataWidth?$DM?$DN8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _BitPackCBuffer@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _BitUnpackCBuffer@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_BitPackCBuffer@12
PUBLIC	??_C@_0EB@BAMFCFOH@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0O@HOKLLIAM@cDataWidth?$DM?$DN8?$AA@	; `string'
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0EB@BAMFCFOH@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\bitpackc.c
CONST	SEGMENT
??_C@_0EB@BAMFCFOH@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\bitpackc.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HOKLLIAM@cDataWidth?$DM?$DN8?$AA@
CONST	SEGMENT
??_C@_0O@HOKLLIAM@cDataWidth?$DM?$DN8?$AA@ DB 'cDataWidth<=8', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _BitPackCBuffer@12
_TEXT	SEGMENT
_dwElement$ = -20
_wBufferSize$ = -16
_pByteOffset$ = -12
_pBitOffset$ = -8
_pBuffer$ = -4
_CBuffer$ = 8
_cElement$ = 12
_cDataWidth$ = 16
_BitPackCBuffer@12 PROC NEAR				; COMDAT

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 112  :   unsigned char  *pBuffer;                                       
; 113  :   unsigned short wBufferSize;
; 114  :   unsigned short *pByteOffset;
; 115  :   unsigned char  *pBitOffset;
; 116  :   short          dwElement;
; 117  : 
; 118  :   assert(cDataWidth<=8); /* This routine only writes up to 8 bits at a time.  */

  00006	0f bf 45 10	 movsx	 eax, WORD PTR _cDataWidth$[ebp]
  0000a	83 f8 08	 cmp	 eax, 8
  0000d	7e 14		 jle	 SHORT $L567
  0000f	6a 76		 push	 118			; 00000076H
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@BAMFCFOH@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@HOKLLIAM@cDataWidth?$DM?$DN8?$AA@
  0001b	e8 00 00 00 00	 call	 __assert
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
$L567:

; 119  : 
; 120  : 
; 121  :   /*--------------------------------------------------
; 122  :     Set the circular buffer to the right position.
; 123  :     And initialize the variables.
; 124  :     --------------------------------------------------*/
; 125  :   wBufferSize = CBuffer->wBufferSize;

  00023	8b 55 08	 mov	 edx, DWORD PTR _CBuffer$[ebp]
  00026	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  0002a	66 89 45 f0	 mov	 WORD PTR _wBufferSize$[ebp], ax

; 126  :   pByteOffset = CBuffer->pBufferWriteByteOffset;

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _CBuffer$[ebp]
  00031	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00034	89 55 f4	 mov	 DWORD PTR _pByteOffset$[ebp], edx

; 127  :   pBitOffset  = CBuffer->pBufferWriteBitOffset;

  00037	8b 45 08	 mov	 eax, DWORD PTR _CBuffer$[ebp]
  0003a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0003d	89 4d f8	 mov	 DWORD PTR _pBitOffset$[ebp], ecx

; 128  :   pBuffer     = CBuffer->pBuffer + *pByteOffset;                                       

  00040	8b 55 f4	 mov	 edx, DWORD PTR _pByteOffset$[ebp]
  00043	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _CBuffer$[ebp]
  00049	03 01		 add	 eax, DWORD PTR [ecx]
  0004b	89 45 fc	 mov	 DWORD PTR _pBuffer$[ebp], eax

; 129  :   dwElement   = cElement;

  0004e	66 0f b6 55 0c	 movzx	 dx, BYTE PTR _cElement$[ebp]
  00053	66 89 55 ec	 mov	 WORD PTR _dwElement$[ebp], dx

; 130  : 
; 131  :   /*--------------------------------------------------
; 132  :     Pack to the current byte
; 133  :     --------------------------------------------------*/
; 134  :   if(*pBitOffset==0)

  00057	8b 45 f8	 mov	 eax, DWORD PTR _pBitOffset$[ebp]
  0005a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0005d	85 c9		 test	 ecx, ecx
  0005f	75 11		 jne	 SHORT $L521

; 135  :      *pBuffer = ((unsigned char)(dwElement&0x00ff));

  00061	0f bf 55 ec	 movsx	 edx, WORD PTR _dwElement$[ebp]
  00065	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0006b	8b 45 fc	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0006e	88 10		 mov	 BYTE PTR [eax], dl

; 136  :   else

  00070	eb 22		 jmp	 SHORT $L523
$L521:

; 137  :      *pBuffer |= ((unsigned char)((dwElement << *pBitOffset)&0x00ff));

  00072	0f bf 55 ec	 movsx	 edx, WORD PTR _dwElement$[ebp]
  00076	8b 45 f8	 mov	 eax, DWORD PTR _pBitOffset$[ebp]
  00079	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0007c	d3 e2		 shl	 edx, cl
  0007e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00084	0f b6 ca	 movzx	 ecx, dl
  00087	8b 55 fc	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  0008a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0008d	0b c1		 or	 eax, ecx
  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  00092	88 01		 mov	 BYTE PTR [ecx], al
$L523:

; 138  :   
; 139  : 
; 140  :   /*--------------------------------------------------
; 141  :     When bit-offset >= PACK_BITS_PER_CHAR, pack the 
; 142  :     next byte of the circular buffer.
; 143  :     --------------------------------------------------*/
; 144  :   *pBitOffset = (unsigned char)(*pBitOffset+cDataWidth); 

  00094	8b 55 f8	 mov	 edx, DWORD PTR _pBitOffset$[ebp]
  00097	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0009a	0f bf 4d 10	 movsx	 ecx, WORD PTR _cDataWidth$[ebp]
  0009e	03 c1		 add	 eax, ecx
  000a0	8b 55 f8	 mov	 edx, DWORD PTR _pBitOffset$[ebp]
  000a3	88 02		 mov	 BYTE PTR [edx], al

; 145  :   if (*pBitOffset > PACK_BITS_PER_CHAR) 

  000a5	8b 45 f8	 mov	 eax, DWORD PTR _pBitOffset$[ebp]
  000a8	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000ab	83 f9 08	 cmp	 ecx, 8
  000ae	7e 65		 jle	 SHORT $L526

; 146  :   {
; 147  :     pBuffer++;

  000b0	8b 55 fc	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  000b3	83 c2 01	 add	 edx, 1
  000b6	89 55 fc	 mov	 DWORD PTR _pBuffer$[ebp], edx

; 148  :     (*pByteOffset)++;

  000b9	8b 45 f4	 mov	 eax, DWORD PTR _pByteOffset$[ebp]
  000bc	66 8b 08	 mov	 cx, WORD PTR [eax]
  000bf	66 83 c1 01	 add	 cx, 1
  000c3	8b 55 f4	 mov	 edx, DWORD PTR _pByteOffset$[ebp]
  000c6	66 89 0a	 mov	 WORD PTR [edx], cx

; 149  :     if(*pByteOffset>=wBufferSize)

  000c9	8b 45 f4	 mov	 eax, DWORD PTR _pByteOffset$[ebp]
  000cc	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000cf	0f b7 55 f0	 movzx	 edx, WORD PTR _wBufferSize$[ebp]
  000d3	3b ca		 cmp	 ecx, edx
  000d5	7c 10		 jl	 SHORT $L527

; 150  :     {
; 151  :       *pByteOffset=0;

  000d7	8b 45 f4	 mov	 eax, DWORD PTR _pByteOffset$[ebp]
  000da	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 152  :       pBuffer = CBuffer->pBuffer; 

  000df	8b 4d 08	 mov	 ecx, DWORD PTR _CBuffer$[ebp]
  000e2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e4	89 55 fc	 mov	 DWORD PTR _pBuffer$[ebp], edx
$L527:

; 153  :     }
; 154  :     *pBuffer = (unsigned char)
; 155  :                (dwElement>>(PACK_BITS_PER_CHAR-(*pBitOffset-cDataWidth)));

  000e7	0f bf 45 ec	 movsx	 eax, WORD PTR _dwElement$[ebp]
  000eb	8b 4d f8	 mov	 ecx, DWORD PTR _pBitOffset$[ebp]
  000ee	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000f1	0f bf 4d 10	 movsx	 ecx, WORD PTR _cDataWidth$[ebp]
  000f5	2b d1		 sub	 edx, ecx
  000f7	b9 08 00 00 00	 mov	 ecx, 8
  000fc	2b ca		 sub	 ecx, edx
  000fe	d3 f8		 sar	 eax, cl
  00100	8b 55 fc	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  00103	88 02		 mov	 BYTE PTR [edx], al

; 156  :     *pBitOffset=(unsigned char)(*pBitOffset-PACK_BITS_PER_CHAR);

  00105	8b 45 f8	 mov	 eax, DWORD PTR _pBitOffset$[ebp]
  00108	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0010b	83 e9 08	 sub	 ecx, 8
  0010e	8b 55 f8	 mov	 edx, DWORD PTR _pBitOffset$[ebp]
  00111	88 0a		 mov	 BYTE PTR [edx], cl

; 157  :   }
; 158  :   else if (*pBitOffset == PACK_BITS_PER_CHAR)

  00113	eb 37		 jmp	 SHORT $L512
$L526:
  00115	8b 45 f8	 mov	 eax, DWORD PTR _pBitOffset$[ebp]
  00118	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0011b	83 f9 08	 cmp	 ecx, 8
  0011e	75 2c		 jne	 SHORT $L512

; 159  :   {
; 160  :     *pBitOffset = 0;

  00120	8b 55 f8	 mov	 edx, DWORD PTR _pBitOffset$[ebp]
  00123	c6 02 00	 mov	 BYTE PTR [edx], 0

; 161  :     (*pByteOffset)++;

  00126	8b 45 f4	 mov	 eax, DWORD PTR _pByteOffset$[ebp]
  00129	66 8b 08	 mov	 cx, WORD PTR [eax]
  0012c	66 83 c1 01	 add	 cx, 1
  00130	8b 55 f4	 mov	 edx, DWORD PTR _pByteOffset$[ebp]
  00133	66 89 0a	 mov	 WORD PTR [edx], cx

; 162  :     if(*pByteOffset>=wBufferSize)

  00136	8b 45 f4	 mov	 eax, DWORD PTR _pByteOffset$[ebp]
  00139	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0013c	0f b7 55 f0	 movzx	 edx, WORD PTR _wBufferSize$[ebp]
  00140	3b ca		 cmp	 ecx, edx
  00142	7c 08		 jl	 SHORT $L512

; 163  :       *pByteOffset=0;

  00144	8b 45 f4	 mov	 eax, DWORD PTR _pByteOffset$[ebp]
  00147	66 c7 00 00 00	 mov	 WORD PTR [eax], 0
$L512:

; 164  :   }
; 165  : }

  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c2 0c 00	 ret	 12			; 0000000cH
_BitPackCBuffer@12 ENDP
_TEXT	ENDS
PUBLIC	_BitUnpackCBuffer@12
; Function compile flags: /Odt
;	COMDAT _BitUnpackCBuffer@12
_TEXT	SEGMENT
_Mask$ = -28
_wBufferSize$ = -24
_Shift$ = -20
_NewBitOffset$ = -13
_pByteOffset$ = -12
_pBitOffset$ = -8
_pBuffer$ = -4
_CBuffer$ = 8
_cElement$ = 12
_cDataWidth$ = 16
_BitUnpackCBuffer@12 PROC NEAR				; COMDAT

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 231  :   int Mask = (1<<cDataWidth) - 1;

  00006	0f bf 4d 10	 movsx	 ecx, WORD PTR _cDataWidth$[ebp]
  0000a	b8 01 00 00 00	 mov	 eax, 1
  0000f	d3 e0		 shl	 eax, cl
  00011	83 e8 01	 sub	 eax, 1
  00014	89 45 e4	 mov	 DWORD PTR _Mask$[ebp], eax

; 232  :   int Shift;
; 233  :   unsigned char NewBitOffset;
; 234  :  
; 235  :   unsigned char  *pBuffer;                                       
; 236  :   unsigned short wBufferSize;
; 237  :   unsigned short *pByteOffset;
; 238  :   unsigned char  *pBitOffset;
; 239  : 
; 240  : 
; 241  : 
; 242  :   /*--------------------------------------------------
; 243  :     Set the circular buffer to the right position.
; 244  :     And initialize the variables.
; 245  :     --------------------------------------------------*/
; 246  :   wBufferSize = CBuffer->wBufferSize;

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _CBuffer$[ebp]
  0001a	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  0001e	66 89 55 e8	 mov	 WORD PTR _wBufferSize$[ebp], dx

; 247  :   pByteOffset = CBuffer->pBufferReadByteOffset;

  00022	8b 45 08	 mov	 eax, DWORD PTR _CBuffer$[ebp]
  00025	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00028	89 4d f4	 mov	 DWORD PTR _pByteOffset$[ebp], ecx

; 248  :   pBitOffset  = CBuffer->pBufferReadBitOffset;

  0002b	8b 55 08	 mov	 edx, DWORD PTR _CBuffer$[ebp]
  0002e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00031	89 45 f8	 mov	 DWORD PTR _pBitOffset$[ebp], eax

; 249  :   pBuffer     = CBuffer->pBuffer + *pByteOffset;                                       

  00034	8b 4d f4	 mov	 ecx, DWORD PTR _pByteOffset$[ebp]
  00037	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0003a	8b 45 08	 mov	 eax, DWORD PTR _CBuffer$[ebp]
  0003d	03 10		 add	 edx, DWORD PTR [eax]
  0003f	89 55 fc	 mov	 DWORD PTR _pBuffer$[ebp], edx

; 250  : 
; 251  :   NewBitOffset = (unsigned char)(*pBitOffset + cDataWidth);

  00042	8b 4d f8	 mov	 ecx, DWORD PTR _pBitOffset$[ebp]
  00045	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00048	0f bf 45 10	 movsx	 eax, WORD PTR _cDataWidth$[ebp]
  0004c	03 d0		 add	 edx, eax
  0004e	88 55 f3	 mov	 BYTE PTR _NewBitOffset$[ebp], dl

; 252  : 
; 253  :   /*--------------------------------------------------
; 254  :     When NewBitOffset > PACK_BITS_PER_CHAR, need unpack
; 255  :     two bytes. Otherwise, only unpack the current byte.
; 256  :     --------------------------------------------------*/
; 257  :   if (NewBitOffset > PACK_BITS_PER_CHAR) 

  00051	0f b6 4d f3	 movzx	 ecx, BYTE PTR _NewBitOffset$[ebp]
  00055	83 f9 08	 cmp	 ecx, 8
  00058	0f 8e 88 00 00
	00		 jle	 $L548

; 258  :   {
; 259  :     Shift = (int)(PACK_BITS_PER_CHAR - *pBitOffset);

  0005e	8b 55 f8	 mov	 edx, DWORD PTR _pBitOffset$[ebp]
  00061	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00064	b9 08 00 00 00	 mov	 ecx, 8
  00069	2b c8		 sub	 ecx, eax
  0006b	89 4d ec	 mov	 DWORD PTR _Shift$[ebp], ecx

; 260  :     *cElement = (unsigned char)(*pBuffer >> *pBitOffset);

  0006e	8b 55 fc	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  00071	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00074	8b 4d f8	 mov	 ecx, DWORD PTR _pBitOffset$[ebp]
  00077	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  0007a	d3 f8		 sar	 eax, cl
  0007c	8b 55 0c	 mov	 edx, DWORD PTR _cElement$[ebp]
  0007f	88 02		 mov	 BYTE PTR [edx], al

; 261  :     pBuffer++;

  00081	8b 45 fc	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  00084	83 c0 01	 add	 eax, 1
  00087	89 45 fc	 mov	 DWORD PTR _pBuffer$[ebp], eax

; 262  :     (*pByteOffset)++;

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR _pByteOffset$[ebp]
  0008d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00090	66 83 c2 01	 add	 dx, 1
  00094	8b 45 f4	 mov	 eax, DWORD PTR _pByteOffset$[ebp]
  00097	66 89 10	 mov	 WORD PTR [eax], dx

; 263  :     if(*pByteOffset>=wBufferSize)

  0009a	8b 4d f4	 mov	 ecx, DWORD PTR _pByteOffset$[ebp]
  0009d	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000a0	0f b7 45 e8	 movzx	 eax, WORD PTR _wBufferSize$[ebp]
  000a4	3b d0		 cmp	 edx, eax
  000a6	7c 10		 jl	 SHORT $L551

; 264  :     {
; 265  :       *pByteOffset=0;

  000a8	8b 4d f4	 mov	 ecx, DWORD PTR _pByteOffset$[ebp]
  000ab	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0

; 266  :       pBuffer = CBuffer->pBuffer;                                       

  000b0	8b 55 08	 mov	 edx, DWORD PTR _CBuffer$[ebp]
  000b3	8b 02		 mov	 eax, DWORD PTR [edx]
  000b5	89 45 fc	 mov	 DWORD PTR _pBuffer$[ebp], eax
$L551:

; 267  :     }
; 268  :     *cElement |= (*pBuffer & (Mask >> Shift)) << Shift;

  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  000bb	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000be	8b 45 e4	 mov	 eax, DWORD PTR _Mask$[ebp]
  000c1	8b 4d ec	 mov	 ecx, DWORD PTR _Shift$[ebp]
  000c4	d3 f8		 sar	 eax, cl
  000c6	23 d0		 and	 edx, eax
  000c8	8b 4d ec	 mov	 ecx, DWORD PTR _Shift$[ebp]
  000cb	d3 e2		 shl	 edx, cl
  000cd	8b 4d 0c	 mov	 ecx, DWORD PTR _cElement$[ebp]
  000d0	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  000d3	0b c2		 or	 eax, edx
  000d5	8b 4d 0c	 mov	 ecx, DWORD PTR _cElement$[ebp]
  000d8	88 01		 mov	 BYTE PTR [ecx], al

; 269  :     NewBitOffset = (unsigned char)(NewBitOffset - PACK_BITS_PER_CHAR);

  000da	0f b6 55 f3	 movzx	 edx, BYTE PTR _NewBitOffset$[ebp]
  000de	83 ea 08	 sub	 edx, 8
  000e1	88 55 f3	 mov	 BYTE PTR _NewBitOffset$[ebp], dl

; 270  :   }
; 271  :   else

  000e4	eb 49		 jmp	 SHORT $L553
$L548:

; 272  :   {
; 273  :     *cElement = (unsigned char)((*pBuffer >> *pBitOffset) & Mask);

  000e6	8b 45 fc	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  000e9	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  000ec	8b 45 f8	 mov	 eax, DWORD PTR _pBitOffset$[ebp]
  000ef	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000f2	d3 fa		 sar	 edx, cl
  000f4	23 55 e4	 and	 edx, DWORD PTR _Mask$[ebp]
  000f7	8b 4d 0c	 mov	 ecx, DWORD PTR _cElement$[ebp]
  000fa	88 11		 mov	 BYTE PTR [ecx], dl

; 274  :     if (NewBitOffset == PACK_BITS_PER_CHAR)

  000fc	0f b6 55 f3	 movzx	 edx, BYTE PTR _NewBitOffset$[ebp]
  00100	83 fa 08	 cmp	 edx, 8
  00103	75 2a		 jne	 SHORT $L553

; 275  :     {
; 276  :       NewBitOffset = 0;

  00105	c6 45 f3 00	 mov	 BYTE PTR _NewBitOffset$[ebp], 0

; 277  :       (*pByteOffset)++;

  00109	8b 45 f4	 mov	 eax, DWORD PTR _pByteOffset$[ebp]
  0010c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0010f	66 83 c1 01	 add	 cx, 1
  00113	8b 55 f4	 mov	 edx, DWORD PTR _pByteOffset$[ebp]
  00116	66 89 0a	 mov	 WORD PTR [edx], cx

; 278  :       if(*pByteOffset>=wBufferSize)

  00119	8b 45 f4	 mov	 eax, DWORD PTR _pByteOffset$[ebp]
  0011c	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0011f	0f b7 55 e8	 movzx	 edx, WORD PTR _wBufferSize$[ebp]
  00123	3b ca		 cmp	 ecx, edx
  00125	7c 08		 jl	 SHORT $L553

; 279  :         *pByteOffset=0;

  00127	8b 45 f4	 mov	 eax, DWORD PTR _pByteOffset$[ebp]
  0012a	66 c7 00 00 00	 mov	 WORD PTR [eax], 0
$L553:

; 280  :     }
; 281  :   }
; 282  :   
; 283  :   *pBitOffset = NewBitOffset;

  0012f	8b 4d f8	 mov	 ecx, DWORD PTR _pBitOffset$[ebp]
  00132	8a 55 f3	 mov	 dl, BYTE PTR _NewBitOffset$[ebp]
  00135	88 11		 mov	 BYTE PTR [ecx], dl

; 284  : }

  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c2 0c 00	 ret	 12			; 0000000cH
_BitUnpackCBuffer@12 ENDP
_TEXT	ENDS
END
