; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\stftfaze.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EB@FLBFCONC@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@MIJOGEBE@?$CIfSTFTphase?$DO?$DN0?$CJ?5?$CG?$CG?5?$CIfSTFTphase?$DM?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxSTFTPhase@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxCodePhase@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_VoxSTFTPhase@24
PUBLIC	??_C@_0EB@FLBFCONC@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CH@MIJOGEBE@?$CIfSTFTphase?$DO?$DN0?$CJ?5?$CG?$CG?5?$CIfSTFTphase?$DM?$DN@ ; `string'
PUBLIC	__real@43800000
PUBLIC	__real@3c490fdb
PUBLIC	__real@3e22f983
PUBLIC	__real@40c90fdb
PUBLIC	__real@00000000
EXTRN	_atan2:NEAR
EXTRN	__assert:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
;	COMDAT __real@43800000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\stftfaze.c
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@3c490fdb
CONST	SEGMENT
__real@3c490fdb DD 03c490fdbr			; 0.0122718
CONST	ENDS
;	COMDAT __real@3e22f983
CONST	SEGMENT
__real@3e22f983 DD 03e22f983r			; 0.159155
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0EB@FLBFCONC@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0EB@FLBFCONC@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\codecs\voxware\stftfaze.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MIJOGEBE@?$CIfSTFTphase?$DO?$DN0?$CJ?5?$CG?$CG?5?$CIfSTFTphase?$DM?$DN@
CONST	SEGMENT
??_C@_0CH@MIJOGEBE@?$CIfSTFTphase?$DO?$DN0?$CJ?5?$CG?$CG?5?$CIfSTFTphase?$DM?$DN@ DB '('
	DB	'fSTFTphase>=0) && (fSTFTphase<=TWOPI)', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxSTFTPhase@24
_TEXT	SEGMENT
tv164 = -48
tv154 = -44
_ftmp$ = -40
_fDeltaPhase$ = -36
_fFreq$ = -32
_iIndex$ = -28
_iNpeaks$ = -24
_fSTFTphase$ = -20
_iMhat$ = -16
_fPhaseShift$ = -12
_i$ = -8
_iBasePeaks$ = -4
_pfSWR$ = 8
_pfSWI$ = 12
_iVEVphases$ = 16
_pfVEVphase$ = 20
_fPitchDFT$ = 24
_iWinShift$ = 28
_VoxSTFTPhase@24 PROC NEAR				; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 35   :    int   i, iNpeaks, iBasePeaks, iIndex;
; 36   :    float fFreq, fSTFTphase;
; 37   :    float ftmp;
; 38   : 
; 39   :    float fPhaseShift, fDeltaPhase;
; 40   :    int   iMhat;
; 41   : 
; 42   :  /*** Push down quantized STFT phases from previous 10ms frame ***/
; 43   : 
; 44   :    for (i = 0; i < iVEVphases; i++)

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $L639
$L640:
  0000f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L639:
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	3b 4d 10	 cmp	 ecx, DWORD PTR _iVEVphases$[ebp]
  0001e	7d 0f		 jge	 SHORT $L641

; 45   :    {
; 46   :       pfVEVphase[i]   = 0.0F;

  00020	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00023	8b 45 14	 mov	 eax, DWORD PTR _pfVEVphase$[ebp]
  00026	c7 04 90 00 00
	00 00		 mov	 DWORD PTR [eax+edx*4], 0

; 47   :    }

  0002d	eb e0		 jmp	 SHORT $L640
$L641:

; 48   : 
; 49   : 
; 50   : 
; 51   :  /*** Compute the number of harmonics in [0,PI) ***/
; 52   :  
; 53   :    iNpeaks = (int)(NFFT_2/fPitchDFT);

  0002f	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@43800000
  00035	d8 75 18	 fdiv	 DWORD PTR _fPitchDFT$[ebp]
  00038	e8 00 00 00 00	 call	 __ftol2
  0003d	89 45 e8	 mov	 DWORD PTR _iNpeaks$[ebp], eax

; 54   :    ftmp=iNpeaks*fPitchDFT;

  00040	db 45 e8	 fild	 DWORD PTR _iNpeaks$[ebp]
  00043	d8 4d 18	 fmul	 DWORD PTR _fPitchDFT$[ebp]
  00046	d9 5d d8	 fstp	 DWORD PTR _ftmp$[ebp]

; 55   :    VoxROUND2pos(ftmp, iIndex);

  00049	d9 45 d8	 fld	 DWORD PTR _ftmp$[ebp]
  0004c	db 5d e4	 fistp	 DWORD PTR _iIndex$[ebp]

; 56   :    if (iIndex >= NFFT_2)

  0004f	81 7d e4 00 01
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 256 ; 00000100H
  00056	7c 09		 jl	 SHORT $L643

; 57   :          iNpeaks --;

  00058	8b 4d e8	 mov	 ecx, DWORD PTR _iNpeaks$[ebp]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	89 4d e8	 mov	 DWORD PTR _iNpeaks$[ebp], ecx
$L643:

; 58   :  
; 59   :    if (iNpeaks > MAXHARM)

  00061	83 7d e8 64	 cmp	 DWORD PTR _iNpeaks$[ebp], 100 ; 00000064H
  00065	7e 07		 jle	 SHORT $L644

; 60   :          iNpeaks = MAXHARM;

  00067	c7 45 e8 64 00
	00 00		 mov	 DWORD PTR _iNpeaks$[ebp], 100 ; 00000064H
$L644:

; 61   :  
; 62   :  
; 63   : 
; 64   :  /*** Establish the number of phases to be coded ***/
; 65   : 
; 66   :    iBasePeaks = iNpeaks;

  0006e	8b 55 e8	 mov	 edx, DWORD PTR _iNpeaks$[ebp]
  00071	89 55 fc	 mov	 DWORD PTR _iBasePeaks$[ebp], edx

; 67   :    if (iBasePeaks > iVEVphases)

  00074	8b 45 fc	 mov	 eax, DWORD PTR _iBasePeaks$[ebp]
  00077	3b 45 10	 cmp	 eax, DWORD PTR _iVEVphases$[ebp]
  0007a	7e 06		 jle	 SHORT $L645

; 68   :        iBasePeaks = iVEVphases;

  0007c	8b 4d 10	 mov	 ecx, DWORD PTR _iVEVphases$[ebp]
  0007f	89 4d fc	 mov	 DWORD PTR _iBasePeaks$[ebp], ecx
$L645:

; 69   : 
; 70   :    /**** compute the phase shift. If the center shift to the left, iWinShift < 0, 
; 71   :      then the phase should have a negative compensation. If iWinShift > 0,
; 72   :      phase have a positive compensation. ****/ 
; 73   :    fPhaseShift = (float)iWinShift * fPitchDFT * TWOPIONFFT;

  00082	0f bf 55 1c	 movsx	 edx, WORD PTR _iWinShift$[ebp]
  00086	89 55 d4	 mov	 DWORD PTR tv154[ebp], edx
  00089	db 45 d4	 fild	 DWORD PTR tv154[ebp]
  0008c	d8 4d 18	 fmul	 DWORD PTR _fPitchDFT$[ebp]
  0008f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c490fdb
  00095	d9 5d f4	 fstp	 DWORD PTR _fPhaseShift$[ebp]

; 74   :    fDeltaPhase = 0.0F;

  00098	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _fDeltaPhase$[ebp], 0

; 75   : 
; 76   :  /*** Compute the sine-wave phases as harmonic samples of the STFT phase ***/
; 77   : 
; 78   :    fFreq = 0.0F;

  0009f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _fFreq$[ebp], 0

; 79   :    for (i = 0; i < iBasePeaks; i++)

  000a6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ad	eb 09		 jmp	 SHORT $L648
$L649:
  000af	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000b2	83 c0 01	 add	 eax, 1
  000b5	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L648:
  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000bb	3b 4d fc	 cmp	 ecx, DWORD PTR _iBasePeaks$[ebp]
  000be	0f 8d c9 00 00
	00		 jge	 $L650

; 80   :    {
; 81   :       fFreq += fPitchDFT;

  000c4	d9 45 e0	 fld	 DWORD PTR _fFreq$[ebp]
  000c7	d8 45 18	 fadd	 DWORD PTR _fPitchDFT$[ebp]
  000ca	d9 5d e0	 fstp	 DWORD PTR _fFreq$[ebp]

; 82   :       VoxROUND2pos(fFreq, iIndex);

  000cd	d9 45 e0	 fld	 DWORD PTR _fFreq$[ebp]
  000d0	db 5d e4	 fistp	 DWORD PTR _iIndex$[ebp]

; 83   :       fSTFTphase = VoxATAN2(pfSWI[iIndex], pfSWR[iIndex]);

  000d3	8b 55 e4	 mov	 edx, DWORD PTR _iIndex$[ebp]
  000d6	8b 45 08	 mov	 eax, DWORD PTR _pfSWR$[ebp]
  000d9	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  000dc	83 ec 08	 sub	 esp, 8
  000df	dd 1c 24	 fstp	 QWORD PTR [esp]
  000e2	8b 4d e4	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  000e5	8b 55 0c	 mov	 edx, DWORD PTR _pfSWI$[ebp]
  000e8	d9 04 8a	 fld	 DWORD PTR [edx+ecx*4]
  000eb	83 ec 08	 sub	 esp, 8
  000ee	dd 1c 24	 fstp	 QWORD PTR [esp]
  000f1	e8 00 00 00 00	 call	 _atan2
  000f6	83 c4 10	 add	 esp, 16			; 00000010H
  000f9	d9 55 d0	 fst	 DWORD PTR tv164[ebp]
  000fc	d9 5d ec	 fstp	 DWORD PTR _fSTFTphase$[ebp]

; 84   : 
; 85   :       fDeltaPhase += fPhaseShift;

  000ff	d9 45 dc	 fld	 DWORD PTR _fDeltaPhase$[ebp]
  00102	d8 45 f4	 fadd	 DWORD PTR _fPhaseShift$[ebp]
  00105	d9 5d dc	 fstp	 DWORD PTR _fDeltaPhase$[ebp]

; 86   :       fSTFTphase += fDeltaPhase;

  00108	d9 45 ec	 fld	 DWORD PTR _fSTFTphase$[ebp]
  0010b	d8 45 dc	 fadd	 DWORD PTR _fDeltaPhase$[ebp]
  0010e	d9 55 ec	 fst	 DWORD PTR _fSTFTphase$[ebp]

; 87   : 
; 88   :       /*----------------------------------------------------------
; 89   :         This code computes fSTFTphase modulo 2 pi. 
; 90   : 
; 91   :           ##### The argorithm is theoretically correct, but
; 92   :                 it is not robust to finite precision arithmetic.
; 93   :                 We need a better way to do this.
; 94   :       ----------------------------------------------------------*/
; 95   :       ftmp = fSTFTphase*INVTWOPI;

  00111	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e22f983
  00117	d9 5d d8	 fstp	 DWORD PTR _ftmp$[ebp]

; 96   :       VoxROUND2(ftmp, iMhat);

  0011a	d9 45 d8	 fld	 DWORD PTR _ftmp$[ebp]
  0011d	db 5d f0	 fistp	 DWORD PTR _iMhat$[ebp]

; 97   : 
; 98   :       fSTFTphase -= (float)iMhat * TWOPI;

  00120	db 45 f0	 fild	 DWORD PTR _iMhat$[ebp]
  00123	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40c90fdb
  00129	d8 6d ec	 fsubr	 DWORD PTR _fSTFTphase$[ebp]
  0012c	d9 55 ec	 fst	 DWORD PTR _fSTFTphase$[ebp]

; 99   :       if (fSTFTphase < 0.0F)

  0012f	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00135	df e0		 fnstsw	 ax
  00137	f6 c4 05	 test	 ah, 5
  0013a	7a 0c		 jp	 SHORT $L653

; 100  :           fSTFTphase += TWOPI;

  0013c	d9 45 ec	 fld	 DWORD PTR _fSTFTphase$[ebp]
  0013f	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@40c90fdb
  00145	d9 5d ec	 fstp	 DWORD PTR _fSTFTphase$[ebp]
$L653:

; 101  : 
; 102  :       assert((fSTFTphase>=0) && (fSTFTphase<=TWOPI));

  00148	d9 45 ec	 fld	 DWORD PTR _fSTFTphase$[ebp]
  0014b	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00151	df e0		 fnstsw	 ax
  00153	f6 c4 01	 test	 ah, 1
  00156	75 10		 jne	 SHORT $L679
  00158	d9 45 ec	 fld	 DWORD PTR _fSTFTphase$[ebp]
  0015b	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@40c90fdb
  00161	df e0		 fnstsw	 ax
  00163	f6 c4 41	 test	 ah, 65			; 00000041H
  00166	7b 14		 jnp	 SHORT $L680
$L679:
  00168	6a 66		 push	 102			; 00000066H
  0016a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@FLBFCONC@c?3?2xbox?2private?2windows?2directx?2@
  0016f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@MIJOGEBE@?$CIfSTFTphase?$DO?$DN0?$CJ?5?$CG?$CG?5?$CIfSTFTphase?$DM?$DN@
  00174	e8 00 00 00 00	 call	 __assert
  00179	83 c4 0c	 add	 esp, 12			; 0000000cH
$L680:

; 103  : 
; 104  :       pfVEVphase[i] = fSTFTphase;

  0017c	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0017f	8b 55 14	 mov	 edx, DWORD PTR _pfVEVphase$[ebp]
  00182	8b 45 ec	 mov	 eax, DWORD PTR _fSTFTphase$[ebp]
  00185	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 105  :    }

  00188	e9 22 ff ff ff	 jmp	 $L649
$L650:

; 106  : 
; 107  :  return 0;

  0018d	66 33 c0	 xor	 ax, ax

; 108  : 
; 109  : 
; 110  : } /*VoxSTFTPhase*/

  00190	8b e5		 mov	 esp, ebp
  00192	5d		 pop	 ebp
  00193	c2 18 00	 ret	 24			; 00000018H
_VoxSTFTPhase@24 ENDP
_TEXT	ENDS
PUBLIC	_VoxCodePhase@12
PUBLIC	__real@3f000000
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxCodePhase@12
_TEXT	SEGMENT
_fArg_q$ = -12
_fArg$ = -8
_iIndex$ = -4
_fPhase$ = 8
_iNlevels$ = 12
_pfPhase_q$ = 16
_VoxCodePhase@12 PROC NEAR				; COMDAT

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 121  :    int   iIndex;
; 122  :    float fArg, fArg_q;
; 123  : 
; 124  : 
; 125  :  /*** 0 <= Phase <= TWOPI ***/
; 126  :    fArg = iNlevels*fPhase*INVTWOPI;

  00006	db 45 0c	 fild	 DWORD PTR _iNlevels$[ebp]
  00009	d8 4d 08	 fmul	 DWORD PTR _fPhase$[ebp]
  0000c	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e22f983
  00012	d9 55 f8	 fst	 DWORD PTR _fArg$[ebp]

; 127  : 
; 128  :    iIndex = (int)fArg;  /** 0 <= iIndex <= (iNlevels-1) **/

  00015	e8 00 00 00 00	 call	 __ftol2
  0001a	89 45 fc	 mov	 DWORD PTR _iIndex$[ebp], eax

; 129  : 
; 130  :    fArg_q = 0.5F + (float)iIndex;

  0001d	db 45 fc	 fild	 DWORD PTR _iIndex$[ebp]
  00020	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f000000
  00026	d9 5d f4	 fstp	 DWORD PTR _fArg_q$[ebp]

; 131  : 
; 132  :    *pfPhase_q =  TWOPI*fArg_q/iNlevels;

  00029	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40c90fdb
  0002f	d8 4d f4	 fmul	 DWORD PTR _fArg_q$[ebp]
  00032	da 75 0c	 fidiv	 DWORD PTR _iNlevels$[ebp]
  00035	8b 45 10	 mov	 eax, DWORD PTR _pfPhase_q$[ebp]
  00038	d9 18		 fstp	 DWORD PTR [eax]

; 133  : 
; 134  :    return 0;

  0003a	66 33 c0	 xor	 ax, ax

; 135  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 0c 00	 ret	 12			; 0000000cH
_VoxCodePhase@12 ENDP
_TEXT	ENDS
END
