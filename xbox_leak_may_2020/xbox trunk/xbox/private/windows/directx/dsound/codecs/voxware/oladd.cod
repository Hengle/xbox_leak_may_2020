; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\oladd.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DO@HHMKECL@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@OEOGAIEK@pfFadeOutBuf?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGIEPFMJ@pfFadeInBuf?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HKDLLILL@pfOutBuf?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@LPDPLNKH@iOverlapLen?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JHMPDFLE@iFrameLen?5?$DO?$DN?5iOverlapLen?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _OlAdd@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_OlAdd@20
PUBLIC	??_C@_0DO@HHMKECL@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BF@OEOGAIEK@pfFadeOutBuf?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	??_C@_0BE@MGIEPFMJ@pfFadeInBuf?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	??_C@_0BB@HKDLLILL@pfOutBuf?5?$CB?$DN?5NULL?$AA@ ; `string'
PUBLIC	??_C@_0BB@LPDPLNKH@iOverlapLen?5?$DO?$DN?50?$AA@ ; `string'
PUBLIC	??_C@_0BJ@JHMPDFLE@iFrameLen?5?$DO?$DN?5iOverlapLen?$AA@ ; `string'
PUBLIC	__real@3f800000
EXTRN	__fltused:NEAR
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0DO@HHMKECL@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\oladd.c
CONST	SEGMENT
??_C@_0DO@HHMKECL@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pri'
	DB	'vate\windows\directx\dsound\codecs\voxware\oladd.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OEOGAIEK@pfFadeOutBuf?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BF@OEOGAIEK@pfFadeOutBuf?5?$CB?$DN?5NULL?$AA@ DB 'pfFadeOutBuf != '
	DB	'NULL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGIEPFMJ@pfFadeInBuf?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BE@MGIEPFMJ@pfFadeInBuf?5?$CB?$DN?5NULL?$AA@ DB 'pfFadeInBuf != NU'
	DB	'LL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HKDLLILL@pfOutBuf?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BB@HKDLLILL@pfOutBuf?5?$CB?$DN?5NULL?$AA@ DB 'pfOutBuf != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LPDPLNKH@iOverlapLen?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BB@LPDPLNKH@iOverlapLen?5?$DO?$DN?50?$AA@ DB 'iOverlapLen >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JHMPDFLE@iFrameLen?5?$DO?$DN?5iOverlapLen?$AA@
CONST	SEGMENT
??_C@_0BJ@JHMPDFLE@iFrameLen?5?$DO?$DN?5iOverlapLen?$AA@ DB 'iFrameLen >='
	DB	' iOverlapLen', 00H				; `string'
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _OlAdd@20
_TEXT	SEGMENT
_fInStep$ = -20
_fOutStep$ = -16
_fStep$ = -12
_i$ = -8
_iNonOverlap$ = -4
_pfFadeOutBuf$ = 8
_pfFadeInBuf$ = 12
_iOverlapLen$ = 16
_iFrameLen$ = 20
_pfOutBuf$ = 24
_OlAdd@20 PROC NEAR					; COMDAT

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 86   :    int      i;
; 87   :    int      iNonOverlap;
; 88   :    float    fInStep;
; 89   :    float    fOutStep;
; 90   :    float    fStep;
; 91   : 
; 92   :    assert( pfFadeOutBuf != NULL);

  00006	83 7d 08 00	 cmp	 DWORD PTR _pfFadeOutBuf$[ebp], 0
  0000a	75 14		 jne	 SHORT $L1322
  0000c	6a 5c		 push	 92			; 0000005cH
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@HHMKECL@c?3?2xbox?2private?2windows?2directx?2@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@OEOGAIEK@pfFadeOutBuf?5?$CB?$DN?5NULL?$AA@
  00018	e8 00 00 00 00	 call	 __assert
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1322:

; 93   :    assert( pfFadeInBuf != NULL);

  00020	83 7d 0c 00	 cmp	 DWORD PTR _pfFadeInBuf$[ebp], 0
  00024	75 14		 jne	 SHORT $L1323
  00026	6a 5d		 push	 93			; 0000005dH
  00028	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@HHMKECL@c?3?2xbox?2private?2windows?2directx?2@
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@MGIEPFMJ@pfFadeInBuf?5?$CB?$DN?5NULL?$AA@
  00032	e8 00 00 00 00	 call	 __assert
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1323:

; 94   :    assert( pfOutBuf != NULL);

  0003a	83 7d 18 00	 cmp	 DWORD PTR _pfOutBuf$[ebp], 0
  0003e	75 14		 jne	 SHORT $L1324
  00040	6a 5e		 push	 94			; 0000005eH
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@HHMKECL@c?3?2xbox?2private?2windows?2directx?2@
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@HKDLLILL@pfOutBuf?5?$CB?$DN?5NULL?$AA@
  0004c	e8 00 00 00 00	 call	 __assert
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1324:

; 95   :    assert( iOverlapLen >= 0 );

  00054	83 7d 10 00	 cmp	 DWORD PTR _iOverlapLen$[ebp], 0
  00058	7d 14		 jge	 SHORT $L1325
  0005a	6a 5f		 push	 95			; 0000005fH
  0005c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@HHMKECL@c?3?2xbox?2private?2windows?2directx?2@
  00061	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@LPDPLNKH@iOverlapLen?5?$DO?$DN?50?$AA@
  00066	e8 00 00 00 00	 call	 __assert
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1325:

; 96   :    assert( iFrameLen >= iOverlapLen );

  0006e	8b 4d 14	 mov	 ecx, DWORD PTR _iFrameLen$[ebp]
  00071	3b 4d 10	 cmp	 ecx, DWORD PTR _iOverlapLen$[ebp]
  00074	7d 14		 jge	 SHORT $L1326
  00076	6a 60		 push	 96			; 00000060H
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@HHMKECL@c?3?2xbox?2private?2windows?2directx?2@
  0007d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@JHMPDFLE@iFrameLen?5?$DO?$DN?5iOverlapLen?$AA@
  00082	e8 00 00 00 00	 call	 __assert
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1326:

; 97   : 
; 98   :    iNonOverlap = iFrameLen-iOverlapLen;

  0008a	8b 45 14	 mov	 eax, DWORD PTR _iFrameLen$[ebp]
  0008d	2b 45 10	 sub	 eax, DWORD PTR _iOverlapLen$[ebp]
  00090	89 45 fc	 mov	 DWORD PTR _iNonOverlap$[ebp], eax

; 99   : 
; 100  :    /*--------------------------------------------------------
; 101  :      If the non-overlap region has an odd length,
; 102  :        there is an extra sample to add in.
; 103  :    --------------------------------------------------------*/
; 104  :    if (iNonOverlap&1)

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _iNonOverlap$[ebp]
  00096	83 e1 01	 and	 ecx, 1
  00099	85 c9		 test	 ecx, ecx
  0009b	74 21		 je	 SHORT $L1296

; 105  :       *pfOutBuf++ += *pfFadeOutBuf++;

  0009d	8b 55 18	 mov	 edx, DWORD PTR _pfOutBuf$[ebp]
  000a0	8b 45 08	 mov	 eax, DWORD PTR _pfFadeOutBuf$[ebp]
  000a3	d9 02		 fld	 DWORD PTR [edx]
  000a5	d8 00		 fadd	 DWORD PTR [eax]
  000a7	8b 4d 18	 mov	 ecx, DWORD PTR _pfOutBuf$[ebp]
  000aa	d9 19		 fstp	 DWORD PTR [ecx]
  000ac	8b 55 08	 mov	 edx, DWORD PTR _pfFadeOutBuf$[ebp]
  000af	83 c2 04	 add	 edx, 4
  000b2	89 55 08	 mov	 DWORD PTR _pfFadeOutBuf$[ebp], edx
  000b5	8b 45 18	 mov	 eax, DWORD PTR _pfOutBuf$[ebp]
  000b8	83 c0 04	 add	 eax, 4
  000bb	89 45 18	 mov	 DWORD PTR _pfOutBuf$[ebp], eax
$L1296:

; 106  : 
; 107  :    iNonOverlap >>= 1; /* process half now, half later */

  000be	8b 4d fc	 mov	 ecx, DWORD PTR _iNonOverlap$[ebp]
  000c1	d1 f9		 sar	 ecx, 1
  000c3	89 4d fc	 mov	 DWORD PTR _iNonOverlap$[ebp], ecx

; 108  : 
; 109  :    /*-------------------------------------------------------
; 110  :      Accumulate non-overlap section into the output buffer 
; 111  :    -------------------------------------------------------*/
; 112  :    for (i=iNonOverlap; i>0; i--)

  000c6	8b 55 fc	 mov	 edx, DWORD PTR _iNonOverlap$[ebp]
  000c9	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  000cc	eb 09		 jmp	 SHORT $L1297
$L1298:
  000ce	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000d1	83 e8 01	 sub	 eax, 1
  000d4	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L1297:
  000d7	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  000db	7e 23		 jle	 SHORT $L1299

; 113  :       *pfOutBuf++ += *pfFadeOutBuf++;

  000dd	8b 4d 18	 mov	 ecx, DWORD PTR _pfOutBuf$[ebp]
  000e0	8b 55 08	 mov	 edx, DWORD PTR _pfFadeOutBuf$[ebp]
  000e3	d9 01		 fld	 DWORD PTR [ecx]
  000e5	d8 02		 fadd	 DWORD PTR [edx]
  000e7	8b 45 18	 mov	 eax, DWORD PTR _pfOutBuf$[ebp]
  000ea	d9 18		 fstp	 DWORD PTR [eax]
  000ec	8b 4d 08	 mov	 ecx, DWORD PTR _pfFadeOutBuf$[ebp]
  000ef	83 c1 04	 add	 ecx, 4
  000f2	89 4d 08	 mov	 DWORD PTR _pfFadeOutBuf$[ebp], ecx
  000f5	8b 55 18	 mov	 edx, DWORD PTR _pfOutBuf$[ebp]
  000f8	83 c2 04	 add	 edx, 4
  000fb	89 55 18	 mov	 DWORD PTR _pfOutBuf$[ebp], edx
  000fe	eb ce		 jmp	 SHORT $L1298
$L1299:

; 114  : 
; 115  :    /*-------------------------------------------------------
; 116  :      Now process the overlap section
; 117  :    -------------------------------------------------------*/
; 118  :    if (iOverlapLen>0)

  00100	83 7d 10 00	 cmp	 DWORD PTR _iOverlapLen$[ebp], 0
  00104	7e 0e		 jle	 SHORT $L1300

; 119  :       fStep = 1.0F/((float)(iOverlapLen));

  00106	db 45 10	 fild	 DWORD PTR _iOverlapLen$[ebp]
  00109	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@3f800000
  0010f	d9 5d f4	 fstp	 DWORD PTR _fStep$[ebp]

; 120  :    else

  00112	eb 07		 jmp	 SHORT $L1302
$L1300:

; 121  :       fStep = 0.0F;

  00114	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fStep$[ebp], 0
$L1302:

; 122  : 
; 123  :    fInStep  = 0.0F;

  0011b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _fInStep$[ebp], 0

; 124  :    fOutStep = 1.0F;

  00122	c7 45 f0 00 00
	80 3f		 mov	 DWORD PTR _fOutStep$[ebp], 1065353216 ; 3f800000H

; 125  : 
; 126  : 
; 127  :    for (i=iOverlapLen; i>0; i--, fInStep+=fStep, fOutStep-=fStep)

  00129	8b 45 10	 mov	 eax, DWORD PTR _iOverlapLen$[ebp]
  0012c	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  0012f	eb 1b		 jmp	 SHORT $L1303
$L1304:
  00131	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00134	83 e9 01	 sub	 ecx, 1
  00137	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  0013a	d9 45 ec	 fld	 DWORD PTR _fInStep$[ebp]
  0013d	d8 45 f4	 fadd	 DWORD PTR _fStep$[ebp]
  00140	d9 5d ec	 fstp	 DWORD PTR _fInStep$[ebp]
  00143	d9 45 f0	 fld	 DWORD PTR _fOutStep$[ebp]
  00146	d8 65 f4	 fsub	 DWORD PTR _fStep$[ebp]
  00149	d9 5d f0	 fstp	 DWORD PTR _fOutStep$[ebp]
$L1303:
  0014c	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  00150	7e 39		 jle	 SHORT $L1305

; 128  :    {
; 129  :       *pfOutBuf++ += (*pfFadeOutBuf++ * fOutStep) + 
; 130  :                      (*pfFadeInBuf++  * fInStep );

  00152	8b 55 08	 mov	 edx, DWORD PTR _pfFadeOutBuf$[ebp]
  00155	d9 45 f0	 fld	 DWORD PTR _fOutStep$[ebp]
  00158	d8 0a		 fmul	 DWORD PTR [edx]
  0015a	8b 45 0c	 mov	 eax, DWORD PTR _pfFadeInBuf$[ebp]
  0015d	d9 45 ec	 fld	 DWORD PTR _fInStep$[ebp]
  00160	d8 08		 fmul	 DWORD PTR [eax]
  00162	de c1		 faddp	 ST(1), ST(0)
  00164	8b 4d 18	 mov	 ecx, DWORD PTR _pfOutBuf$[ebp]
  00167	d8 01		 fadd	 DWORD PTR [ecx]
  00169	8b 55 18	 mov	 edx, DWORD PTR _pfOutBuf$[ebp]
  0016c	d9 1a		 fstp	 DWORD PTR [edx]
  0016e	8b 45 0c	 mov	 eax, DWORD PTR _pfFadeInBuf$[ebp]
  00171	83 c0 04	 add	 eax, 4
  00174	89 45 0c	 mov	 DWORD PTR _pfFadeInBuf$[ebp], eax
  00177	8b 4d 08	 mov	 ecx, DWORD PTR _pfFadeOutBuf$[ebp]
  0017a	83 c1 04	 add	 ecx, 4
  0017d	89 4d 08	 mov	 DWORD PTR _pfFadeOutBuf$[ebp], ecx
  00180	8b 55 18	 mov	 edx, DWORD PTR _pfOutBuf$[ebp]
  00183	83 c2 04	 add	 edx, 4
  00186	89 55 18	 mov	 DWORD PTR _pfOutBuf$[ebp], edx

; 131  :    }

  00189	eb a6		 jmp	 SHORT $L1304
$L1305:

; 132  : 
; 133  :    /*--------------------------------------------------------
; 134  :      Finally, accumulate non-overlap section into end of
; 135  :      the output buffer ...
; 136  :    --------------------------------------------------------*/
; 137  :    for (i=iNonOverlap; i>0; i--)

  0018b	8b 45 fc	 mov	 eax, DWORD PTR _iNonOverlap$[ebp]
  0018e	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00191	eb 09		 jmp	 SHORT $L1306
$L1307:
  00193	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00196	83 e9 01	 sub	 ecx, 1
  00199	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$L1306:
  0019c	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  001a0	7e 23		 jle	 SHORT $L1276

; 138  :       *pfOutBuf++ += *pfFadeInBuf++;

  001a2	8b 55 18	 mov	 edx, DWORD PTR _pfOutBuf$[ebp]
  001a5	8b 45 0c	 mov	 eax, DWORD PTR _pfFadeInBuf$[ebp]
  001a8	d9 02		 fld	 DWORD PTR [edx]
  001aa	d8 00		 fadd	 DWORD PTR [eax]
  001ac	8b 4d 18	 mov	 ecx, DWORD PTR _pfOutBuf$[ebp]
  001af	d9 19		 fstp	 DWORD PTR [ecx]
  001b1	8b 55 0c	 mov	 edx, DWORD PTR _pfFadeInBuf$[ebp]
  001b4	83 c2 04	 add	 edx, 4
  001b7	89 55 0c	 mov	 DWORD PTR _pfFadeInBuf$[ebp], edx
  001ba	8b 45 18	 mov	 eax, DWORD PTR _pfOutBuf$[ebp]
  001bd	83 c0 04	 add	 eax, 4
  001c0	89 45 18	 mov	 DWORD PTR _pfOutBuf$[ebp], eax
  001c3	eb ce		 jmp	 SHORT $L1307
$L1276:

; 139  : 
; 140  : }

  001c5	8b e5		 mov	 esp, ebp
  001c7	5d		 pop	 ebp
  001c8	c2 14 00	 ret	 20			; 00000014H
_OlAdd@20 ENDP
_TEXT	ENDS
END
