; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\encodert.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0M@CLPIAPDA@post?5encode?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@EFABGBNC@post?5calc?5res?5amps?5rt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HCCHHEEF@rate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@DIONPLIB@max?5harmonics?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@KGCNFMNN@frame?5length?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KKGCKCNJ@energy?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _VoxEncodeRT@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxInitEncodeRT@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxFreeEncodeRT@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _VoxGetWinLength@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_XVoiceBuildNumberD
;	COMDAT _XVoiceBuildNumberD
XBLD$V	SEGMENT
_XVoiceBuildNumberD DW 05658H
	DW	0494fH
	DW	04543H
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
PUBLIC	_VoxEncodeRT@8
PUBLIC	__real@00000000
EXTRN	_PvRefine@20:NEAR
EXTRN	_VoxVocDecision@28:NEAR
EXTRN	_VoxPitchRefine_TIME@24:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__chkstk:NEAR
EXTRN	__fltused:NEAR
EXTRN	_vemServiceState@4:NEAR
EXTRN	_VoxCalcLPC@24:NEAR
EXTRN	_SymWindowSignal@16:NEAR
EXTRN	_PutFrameSpCBM@16:NEAR
EXTRN	_GetFrameSpCBM@16:NEAR
EXTRN	_MagSq@16:NEAR
EXTRN	_VoxDemultiplex@16:NEAR
EXTRN	_VoxFftCenter@16:NEAR
EXTRN	_VoxPreProcess@16:NEAR
EXTRN	_VoxCorrPDA@24:NEAR
;	COMDAT __real@00000000
; File c:\xbox\private\windows\directx\dsound\codecs\voxware\encodert.c
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxEncodeRT@8
_TEXT	SEGMENT
tv129 = -4532
_BandError$2190 = -4528
_power$2189 = -4168
_fSW$2188 = -3144
_SpBuf$ = -1088
_UV$ = -40
_win$ = -36
_pitch$ = -32
_SWI$ = -28
_pdaDelaySize$ = -24
_Param_mblk$ = -20
_i$ = -16
_SWR$ = -12
_Pv$ = -8
_pEncMemBlk$ = -4
_pPCMBuffer$ = 8
_hEncMemBlk$ = 12
_VoxEncodeRT@8 PROC NEAR				; COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 b4 11 00 00	 mov	 eax, 4532		; 000011b4H
  00008	e8 00 00 00 00	 call	 __chkstk

; 89   :    ENC_MEM_BLK *pEncMemBlk= (ENC_MEM_BLK *)hEncMemBlk;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _hEncMemBlk$[ebp]
  00010	89 45 fc	 mov	 DWORD PTR _pEncMemBlk$[ebp], eax

; 90   : 
; 91   :    PARAM *Param_mblk = (PARAM *)pEncMemBlk->Param_mblk;

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  00016	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00019	89 55 ec	 mov	 DWORD PTR _Param_mblk$[ebp], edx

; 92   :    
; 93   :    STACK_INIT
; 94   :    float SpBuf[FRAME_SIZE3];
; 95   :    STACK_INIT_END
; 96   :    float *SWR = pEncMemBlk->SWR;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  0001f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00022	89 4d f4	 mov	 DWORD PTR _SWR$[ebp], ecx

; 97   :    float *SWI = pEncMemBlk->SWI;

  00025	8b 55 fc	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  00028	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0002b	89 45 e4	 mov	 DWORD PTR _SWI$[ebp], eax

; 98   :    short  UV;
; 99   : 
; 100  :    STACK_ATTACH(float *, SpBuf)
; 101  : 
; 102  :    float *win;        /* window pointer */
; 103  :    float pitch, Pv, pdaDelaySize;
; 104  :    int i;
; 105  :    STACK_START
; 106  :    
; 107  : 
; 108  :   /* pre-processing the speech using HPF */
; 109  :   VoxPreProcess(pPCMBuffer, SpBuf, FRAME_LEN, pEncMemBlk->PreProc_mblk);

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  00031	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00034	52		 push	 edx
  00035	68 b4 00 00 00	 push	 180			; 000000b4H
  0003a	8d 85 c0 fb ff
	ff		 lea	 eax, DWORD PTR _SpBuf$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _pPCMBuffer$[ebp]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 _VoxPreProcess@16

; 110  : 
; 111  :   /* put 8k speech to the circular buffer */
; 112  :   PutFrameSpCBM(pEncMemBlk->CircBuf_mblk, 0, (const int) FRAME_LEN, SpBuf);

  0004a	8d 95 c0 fb ff
	ff		 lea	 edx, DWORD PTR _SpBuf$[ebp]
  00050	52		 push	 edx
  00051	68 b4 00 00 00	 push	 180			; 000000b4H
  00056	6a 00		 push	 0
  00058	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 _PutFrameSpCBM@16

; 113  :   
; 114  :   /* pitch detection */
; 115  :   pitch = VoxCorrPDA(STACK_S SpBuf, FRAME_LEN, pEncMemBlk->PDA_mblk,
; 116  :                      &pdaDelaySize, &(Param_mblk->VAD),&UV);

  00063	8d 55 d8	 lea	 edx, DWORD PTR _UV$[ebp]
  00066	52		 push	 edx
  00067	8b 45 ec	 mov	 eax, DWORD PTR _Param_mblk$[ebp]
  0006a	83 c0 1c	 add	 eax, 28			; 0000001cH
  0006d	50		 push	 eax
  0006e	8d 4d e8	 lea	 ecx, DWORD PTR _pdaDelaySize$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 fc	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  00075	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00078	50		 push	 eax
  00079	68 b4 00 00 00	 push	 180			; 000000b4H
  0007e	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _SpBuf$[ebp]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _VoxCorrPDA@24
  0008a	d9 5d e0	 fstp	 DWORD PTR _pitch$[ebp]

; 117  : 
; 118  :   /***** decide the length and window by the pitch of the current frame *****/
; 119  :   pEncMemBlk->Nwin = VoxGetWinLength(pitch);

  0008d	8b 55 e0	 mov	 edx, DWORD PTR _pitch$[ebp]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 _VoxGetWinLength@4
  00096	8b 4d fc	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  00099	66 89 41 2c	 mov	 WORD PTR [ecx+44], ax

; 120  : 
; 121  :   /**** take an frame of speech out and apply windowing ****/
; 122  :   GetFrameSpCBM(pEncMemBlk->CircBuf_mblk, (const int) pdaDelaySize, 
; 123  :                 (const int) pEncMemBlk->Nwin, SpBuf);

  0009d	8d 95 c0 fb ff
	ff		 lea	 edx, DWORD PTR _SpBuf$[ebp]
  000a3	52		 push	 edx
  000a4	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  000a7	0f bf 48 2c	 movsx	 ecx, WORD PTR [eax+44]
  000ab	51		 push	 ecx
  000ac	d9 45 e8	 fld	 DWORD PTR _pdaDelaySize$[ebp]
  000af	e8 00 00 00 00	 call	 __ftol2
  000b4	50		 push	 eax
  000b5	8b 55 fc	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  000b8	8b 02		 mov	 eax, DWORD PTR [edx]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _GetFrameSpCBM@16

; 124  : 
; 125  :   switch(pEncMemBlk->Nwin) {

  000c0	8b 4d fc	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  000c3	0f bf 51 2c	 movsx	 edx, WORD PTR [ecx+44]
  000c7	89 95 4c ee ff
	ff		 mov	 DWORD PTR tv129[ebp], edx
  000cd	81 bd 4c ee ff
	ff dd 00 00 00	 cmp	 DWORD PTR tv129[ebp], 221 ; 000000ddH
  000d7	74 1a		 je	 SHORT $L2184
  000d9	81 bd 4c ee ff
	ff f1 00 00 00	 cmp	 DWORD PTR tv129[ebp], 241 ; 000000f1H
  000e3	74 19		 je	 SHORT $L2185
  000e5	81 bd 4c ee ff
	ff 05 01 00 00	 cmp	 DWORD PTR tv129[ebp], 261 ; 00000105H
  000ef	74 18		 je	 SHORT $L2186
  000f1	eb 1f		 jmp	 SHORT $L2181
$L2184:

; 126  :   case FRAME_SIZE1:
; 127  :       win=pEncMemBlk->win1;

  000f3	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  000f6	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000f9	89 4d dc	 mov	 DWORD PTR _win$[ebp], ecx

; 128  :       break;

  000fc	eb 14		 jmp	 SHORT $L2181
$L2185:

; 129  :    case FRAME_SIZE2:
; 130  :       win=pEncMemBlk->win2;

  000fe	8b 55 fc	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  00101	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00104	89 45 dc	 mov	 DWORD PTR _win$[ebp], eax

; 131  :       break;

  00107	eb 09		 jmp	 SHORT $L2181
$L2186:

; 132  :    case FRAME_SIZE3:
; 133  :       win=pEncMemBlk->win3;

  00109	8b 4d fc	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  0010c	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0010f	89 55 dc	 mov	 DWORD PTR _win$[ebp], edx
$L2181:

; 134  :       break;
; 135  :    }
; 136  :   
; 137  :   /**** window signal from high end to low end ****/
; 138  :   SymWindowSignal(SpBuf, win, SpBuf, pEncMemBlk->Nwin);

  00112	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  00115	0f bf 48 2c	 movsx	 ecx, WORD PTR [eax+44]
  00119	51		 push	 ecx
  0011a	8d 95 c0 fb ff
	ff		 lea	 edx, DWORD PTR _SpBuf$[ebp]
  00120	52		 push	 edx
  00121	8b 45 dc	 mov	 eax, DWORD PTR _win$[ebp]
  00124	50		 push	 eax
  00125	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _SpBuf$[ebp]
  0012b	51		 push	 ecx
  0012c	e8 00 00 00 00	 call	 _SymWindowSignal@16

; 139  :   
; 140  :   /***************************************************/
; 141  :   /*     1. calculate LPC                            */
; 142  :   /***************************************************/
; 143  : 
; 144  :   VoxCalcLPC(STACK_S SpBuf, pEncMemBlk->Nwin, Param_mblk->Alpc, &Param_mblk->Energy,
; 145  : 	     (float)EXPAND_COEF,pEncMemBlk->dwLpc);

  00131	8b 55 fc	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  00134	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00137	50		 push	 eax
  00138	68 c9 76 7e 3f	 push	 1065252553		; 3f7e76c9H
  0013d	8b 4d ec	 mov	 ecx, DWORD PTR _Param_mblk$[ebp]
  00140	83 c1 08	 add	 ecx, 8
  00143	51		 push	 ecx
  00144	8b 55 ec	 mov	 edx, DWORD PTR _Param_mblk$[ebp]
  00147	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0014a	50		 push	 eax
  0014b	8b 4d fc	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  0014e	0f bf 51 2c	 movsx	 edx, WORD PTR [ecx+44]
  00152	52		 push	 edx
  00153	8d 85 c0 fb ff
	ff		 lea	 eax, DWORD PTR _SpBuf$[ebp]
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 _VoxCalcLPC@24

; 146  : 
; 147  : 
; 148  :    /*****************************************************/
; 149  :    /*    2. calculate pitch, pv and number of harmonics */
; 150  :    /*****************************************************/
; 151  :   {  
; 152  :    STACK_INIT
; 153  :    float fSW[NFFT+2];
; 154  :    STACK_INIT_END
; 155  :    STACK_ATTACH(float*,fSW)
; 156  :    STACK_START
; 157  : 
; 158  :    /***** calculate the spectrum *****/
; 159  : 
; 160  :    VoxFftCenter( SpBuf, pEncMemBlk->Nwin, fSW, FFT_ORDER );

  0015f	6a 09		 push	 9
  00161	8d 8d b8 f3 ff
	ff		 lea	 ecx, DWORD PTR _fSW$2188[ebp]
  00167	51		 push	 ecx
  00168	8b 55 fc	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  0016b	0f bf 42 2c	 movsx	 eax, WORD PTR [edx+44]
  0016f	50		 push	 eax
  00170	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _SpBuf$[ebp]
  00176	51		 push	 ecx
  00177	e8 00 00 00 00	 call	 _VoxFftCenter@16

; 161  :    VoxDemultiplex( fSW, SWR, SWI, NFFT_2 );

  0017c	68 00 01 00 00	 push	 256			; 00000100H
  00181	8b 55 e4	 mov	 edx, DWORD PTR _SWI$[ebp]
  00184	52		 push	 edx
  00185	8b 45 f4	 mov	 eax, DWORD PTR _SWR$[ebp]
  00188	50		 push	 eax
  00189	8d 8d b8 f3 ff
	ff		 lea	 ecx, DWORD PTR _fSW$2188[ebp]
  0018f	51		 push	 ecx
  00190	e8 00 00 00 00	 call	 _VoxDemultiplex@16

; 162  : 
; 163  :    STACK_END
; 164  :   }
; 165  : 
; 166  :   {
; 167  :    STACK_INIT
; 168  :    float power[NFFT_2];
; 169  :    float BandError[MAXHARM];
; 170  :    STACK_INIT_END
; 171  :    STACK_ATTACH(float*,power)
; 172  :    STACK_ATTACH(float*,BandError)
; 173  : 
; 174  :    STACK_START
; 175  : 
; 176  :    /**** calculate the power structrum of the signal ****/
; 177  :    MagSq( SWR, SWI, NFFT_2, power);

  00195	8d 95 b8 ef ff
	ff		 lea	 edx, DWORD PTR _power$2189[ebp]
  0019b	52		 push	 edx
  0019c	68 00 01 00 00	 push	 256			; 00000100H
  001a1	8b 45 e4	 mov	 eax, DWORD PTR _SWI$[ebp]
  001a4	50		 push	 eax
  001a5	8b 4d f4	 mov	 ecx, DWORD PTR _SWR$[ebp]
  001a8	51		 push	 ecx
  001a9	e8 00 00 00 00	 call	 _MagSq@16

; 178  :    
; 179  :    VoxPitchRefine_TIME(&pitch, SWR, SWI, power, pEncMemBlk->Nwin, BandError);  

  001ae	8d 95 50 ee ff
	ff		 lea	 edx, DWORD PTR _BandError$2190[ebp]
  001b4	52		 push	 edx
  001b5	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  001b8	0f bf 48 2c	 movsx	 ecx, WORD PTR [eax+44]
  001bc	51		 push	 ecx
  001bd	8d 95 b8 ef ff
	ff		 lea	 edx, DWORD PTR _power$2189[ebp]
  001c3	52		 push	 edx
  001c4	8b 45 e4	 mov	 eax, DWORD PTR _SWI$[ebp]
  001c7	50		 push	 eax
  001c8	8b 4d f4	 mov	 ecx, DWORD PTR _SWR$[ebp]
  001cb	51		 push	 ecx
  001cc	8d 55 e0	 lea	 edx, DWORD PTR _pitch$[ebp]
  001cf	52		 push	 edx
  001d0	e8 00 00 00 00	 call	 _VoxPitchRefine_TIME@24

; 180  : 
; 181  :    /* find the voicing probability */
; 182  :    VoxVocDecision(pitch, pEncMemBlk->Voicing_mblk, &Pv, power, BandError, pEncMemBlk->Nwin, &(Param_mblk->VAD));

  001d5	8b 45 ec	 mov	 eax, DWORD PTR _Param_mblk$[ebp]
  001d8	83 c0 1c	 add	 eax, 28			; 0000001cH
  001db	50		 push	 eax
  001dc	8b 4d fc	 mov	 ecx, DWORD PTR _pEncMemBlk$[ebp]
  001df	0f bf 51 2c	 movsx	 edx, WORD PTR [ecx+44]
  001e3	52		 push	 edx
  001e4	8d 85 50 ee ff
	ff		 lea	 eax, DWORD PTR _BandError$2190[ebp]
  001ea	50		 push	 eax
  001eb	8d 8d b8 ef ff
	ff		 lea	 ecx, DWORD PTR _power$2189[ebp]
  001f1	51		 push	 ecx
  001f2	8d 55 f8	 lea	 edx, DWORD PTR _Pv$[ebp]
  001f5	52		 push	 edx
  001f6	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  001f9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001fc	51		 push	 ecx
  001fd	8b 55 e0	 mov	 edx, DWORD PTR _pitch$[ebp]
  00200	52		 push	 edx
  00201	e8 00 00 00 00	 call	 _VoxVocDecision@28

; 183  :    Pv = (float) PvRefine( Pv, pEncMemBlk->Pv_1, (float) ((CorrPDA_mblk *)pEncMemBlk->PDA_mblk)->pitch_1, 
; 184  :                  ((CorrPDA_mblk *)pEncMemBlk->PDA_mblk)->cost_1, 
; 185  :                  ((CorrPDA_mblk *)pEncMemBlk->PDA_mblk)->biasTab);

  00206	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  00209	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0020c	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0020f	52		 push	 edx
  00210	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  00213	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00216	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00219	52		 push	 edx
  0021a	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  0021d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00220	db 41 18	 fild	 DWORD PTR [ecx+24]
  00223	51		 push	 ecx
  00224	d9 1c 24	 fstp	 DWORD PTR [esp]
  00227	8b 55 fc	 mov	 edx, DWORD PTR _pEncMemBlk$[ebp]
  0022a	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0022d	50		 push	 eax
  0022e	8b 4d f8	 mov	 ecx, DWORD PTR _Pv$[ebp]
  00231	51		 push	 ecx
  00232	e8 00 00 00 00	 call	 _PvRefine@20
  00237	d9 5d f8	 fstp	 DWORD PTR _Pv$[ebp]

; 186  : 
; 187  :    if(UV!=ACTIVE_SPEECH)

  0023a	0f bf 55 d8	 movsx	 edx, WORD PTR _UV$[ebp]
  0023e	83 fa 01	 cmp	 edx, 1
  00241	74 07		 je	 SHORT $L2196

; 188  :       Pv=0;

  00243	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Pv$[ebp], 0
$L2196:

; 189  :    pEncMemBlk->Pv_1 = Pv;

  0024a	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  0024d	8b 4d f8	 mov	 ecx, DWORD PTR _Pv$[ebp]
  00250	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 190  : 
; 191  :    STACK_END
; 192  :   }
; 193  : 
; 194  :   /*****************************************************/
; 195  :   /*    3.  pack pitch, pv                             */
; 196  :   /*****************************************************/
; 197  :   if (Pv == 0)

  00253	d9 45 f8	 fld	 DWORD PTR _Pv$[ebp]
  00256	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  0025c	df e0		 fnstsw	 ax
  0025e	f6 c4 44	 test	 ah, 68			; 00000044H
  00261	7a 07		 jp	 SHORT $L2197

; 198  :     pitch = (float)PITCH_UV;

  00263	c7 45 e0 00 00
	fa 42		 mov	 DWORD PTR _pitch$[ebp], 1123680256 ; 42fa0000H
$L2197:

; 199  : 
; 200  :   Param_mblk->Pitch = pitch;

  0026a	8b 55 ec	 mov	 edx, DWORD PTR _Param_mblk$[ebp]
  0026d	8b 45 e0	 mov	 eax, DWORD PTR _pitch$[ebp]
  00270	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 201  :   Param_mblk->Pv = Pv;

  00273	8b 4d ec	 mov	 ecx, DWORD PTR _Param_mblk$[ebp]
  00276	8b 55 f8	 mov	 edx, DWORD PTR _Pv$[ebp]
  00279	89 11		 mov	 DWORD PTR [ecx], edx

; 202  : 
; 203  :   pEncMemBlk->uQPitch = pitch;

  0027b	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  0027e	8b 4d e0	 mov	 ecx, DWORD PTR _pitch$[ebp]
  00281	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 204  : 
; 205  :   /*****************************************************/
; 206  :   /*    4. Perform backward compatibility operations   */
; 207  :   /*          (talk to Wei or John)                    */
; 208  :   /*****************************************************/
; 209  :   
; 210  :   for (i = 0; i < LPC_ORDER; i++)

  00284	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0028b	eb 09		 jmp	 SHORT $L2199
$L2200:
  0028d	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00290	83 c2 01	 add	 edx, 1
  00293	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx
$L2199:
  00296	83 7d f0 0a	 cmp	 DWORD PTR _i$[ebp], 10	; 0000000aH
  0029a	7d 1d		 jge	 SHORT $L2201

; 211  :        Param_mblk->Blpc[i] = -(Param_mblk->Alpc[i+1]);

  0029c	8b 45 ec	 mov	 eax, DWORD PTR _Param_mblk$[ebp]
  0029f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002a2	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  002a5	d9 44 91 04	 fld	 DWORD PTR [ecx+edx*4+4]
  002a9	d9 e0		 fchs
  002ab	8b 45 ec	 mov	 eax, DWORD PTR _Param_mblk$[ebp]
  002ae	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002b1	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  002b4	d9 1c 91	 fstp	 DWORD PTR [ecx+edx*4]
  002b7	eb d4		 jmp	 SHORT $L2200
$L2201:

; 212  : 
; 213  :   /* service the "post encode" state */
; 214  :   vemServiceState(pEncMemBlk->vemKeyPostEncode);

  002b9	8b 45 fc	 mov	 eax, DWORD PTR _pEncMemBlk$[ebp]
  002bc	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  002bf	51		 push	 ecx
  002c0	e8 00 00 00 00	 call	 _vemServiceState@4

; 215  : 
; 216  :   STACK_END
; 217  :   return 0;

  002c5	66 33 c0	 xor	 ax, ax

; 218  : } /* Encode() */

  002c8	8b e5		 mov	 esp, ebp
  002ca	5d		 pop	 ebp
  002cb	c2 08 00	 ret	 8
_VoxEncodeRT@8 ENDP
_TEXT	ENDS
PUBLIC	_VoxInitEncodeRT@8
PUBLIC	??_C@_0M@CLPIAPDA@post?5encode?$AA@		; `string'
PUBLIC	??_C@_0BG@EFABGBNC@post?5calc?5res?5amps?5rt?$AA@ ; `string'
PUBLIC	??_C@_04HCCHHEEF@rate?$AA@			; `string'
PUBLIC	??_C@_0O@DIONPLIB@max?5harmonics?$AA@		; `string'
PUBLIC	??_C@_0N@KGCNFMNN@frame?5length?$AA@		; `string'
PUBLIC	??_C@_06KKGCKCNJ@energy?$AA@			; `string'
EXTRN	_VoxInitVoicing@4:NEAR
EXTRN	_vemRegisterState@8:NEAR
EXTRN	_vemRegisterVariable@16:NEAR
EXTRN	_vemRegisterConstShort@12:NEAR
EXTRN	_VoxInitParam@8:NEAR
EXTRN	_InitKaiserWindow@12:NEAR
EXTRN	_NormSymWindowByPower@8:NEAR
EXTRN	_InitSpCBM@8:NEAR
EXTRN	_calloc:NEAR
EXTRN	_VoxInitPreProc@8:NEAR
EXTRN	_VoxInitCorrPitchEst@4:NEAR
;	COMDAT ??_C@_0M@CLPIAPDA@post?5encode?$AA@
CONST	SEGMENT
??_C@_0M@CLPIAPDA@post?5encode?$AA@ DB 'post encode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EFABGBNC@post?5calc?5res?5amps?5rt?$AA@
CONST	SEGMENT
??_C@_0BG@EFABGBNC@post?5calc?5res?5amps?5rt?$AA@ DB 'post calc res amps '
	DB	'rt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCCHHEEF@rate?$AA@
CONST	SEGMENT
??_C@_04HCCHHEEF@rate?$AA@ DB 'rate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DIONPLIB@max?5harmonics?$AA@
CONST	SEGMENT
??_C@_0O@DIONPLIB@max?5harmonics?$AA@ DB 'max harmonics', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KGCNFMNN@frame?5length?$AA@
CONST	SEGMENT
??_C@_0N@KGCNFMNN@frame?5length?$AA@ DB 'frame length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06KKGCKCNJ@energy?$AA@
CONST	SEGMENT
??_C@_06KKGCKCNJ@energy?$AA@ DB 'energy', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxInitEncodeRT@8
_TEXT	SEGMENT
_pEncode_mblk$ = -4
_ppMemBlkE$ = 8
_pVemMem$ = 12
_VoxInitEncodeRT@8 PROC NEAR				; COMDAT

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 248  : 
; 249  :   ENC_MEM_BLK *pEncode_mblk;
; 250  : 
; 251  :   if(VOX_MEM_INIT(pEncode_mblk=*ppMemBlkE,1,sizeof(ENC_MEM_BLK))) 

  00004	6a 48		 push	 72			; 00000048H
  00006	6a 01		 push	 1
  00008	e8 00 00 00 00	 call	 _calloc
  0000d	83 c4 08	 add	 esp, 8
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _ppMemBlkE$[ebp]
  00013	89 01		 mov	 DWORD PTR [ecx], eax
  00015	8b 55 08	 mov	 edx, DWORD PTR _ppMemBlkE$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	89 45 fc	 mov	 DWORD PTR _pEncode_mblk$[ebp], eax
  0001d	83 7d fc 00	 cmp	 DWORD PTR _pEncode_mblk$[ebp], 0
  00021	75 09		 jne	 SHORT $L2209

; 252  :       return 1;

  00023	66 b8 01 00	 mov	 ax, 1
  00027	e9 59 02 00 00	 jmp	 $L2206
$L2209:

; 253  : 
; 254  :   /****************************************************
; 255  :   initialize circular buffer structure 
; 256  :   ****************************************************/
; 257  :   /* initialize the circular buffer manager */
; 258  :   if (InitSpCBM((const int) CIRCBUF_LENGTH, &pEncode_mblk->CircBuf_mblk))

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  0002f	51		 push	 ecx
  00030	68 91 01 00 00	 push	 401			; 00000191H
  00035	e8 00 00 00 00	 call	 _InitSpCBM@8
  0003a	0f b7 d0	 movzx	 edx, ax
  0003d	85 d2		 test	 edx, edx
  0003f	74 09		 je	 SHORT $L2211

; 259  :       return 1;

  00041	66 b8 01 00	 mov	 ax, 1
  00045	e9 3b 02 00 00	 jmp	 $L2206
$L2211:

; 260  :   
; 261  :   /* initialize the pre-process structure */
; 262  :   if (VoxInitPreProc(&pEncode_mblk->PreProc_mblk, PRE_PROC_COEF))

  0004a	68 a4 70 7d 3f	 push	 1065185444		; 3f7d70a4H
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  00052	83 c0 04	 add	 eax, 4
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _VoxInitPreProc@8
  0005b	0f b7 c8	 movzx	 ecx, ax
  0005e	85 c9		 test	 ecx, ecx
  00060	74 09		 je	 SHORT $L2212

; 263  :       return 1;

  00062	66 b8 01 00	 mov	 ax, 1
  00066	e9 1a 02 00 00	 jmp	 $L2206
$L2212:

; 264  : 
; 265  :   /****************************************************
; 266  :   initialize Voicing structure
; 267  :   ****************************************************/
; 268  :   if(VoxInitVoicing(&pEncode_mblk->Voicing_mblk)) 

  0006b	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  0006e	83 c2 08	 add	 edx, 8
  00071	52		 push	 edx
  00072	e8 00 00 00 00	 call	 _VoxInitVoicing@4
  00077	0f b7 c0	 movzx	 eax, ax
  0007a	85 c0		 test	 eax, eax
  0007c	74 09		 je	 SHORT $L2213

; 269  :       return 1;

  0007e	66 b8 01 00	 mov	 ax, 1
  00082	e9 fe 01 00 00	 jmp	 $L2206
$L2213:

; 270  : 
; 271  :   /****************************************************
; 272  :    initialize correlation PDA structure
; 273  :    ****************************************************/
; 274  :   if(VoxInitCorrPitchEst(&pEncode_mblk->PDA_mblk)) 

  00087	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  0008a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 _VoxInitCorrPitchEst@4
  00093	0f b7 d0	 movzx	 edx, ax
  00096	85 d2		 test	 edx, edx
  00098	74 09		 je	 SHORT $L2214

; 275  :       return 1;

  0009a	66 b8 01 00	 mov	 ax, 1
  0009e	e9 e2 01 00 00	 jmp	 $L2206
$L2214:

; 276  : 
; 277  :   /****************************************************
; 278  :   initialize FFT coefficients 
; 279  :   ****************************************************/
; 280  : 
; 281  :   /*-------------------------------------------------------
; 282  :     LOOK OUT!!! WHOA!!! NOW HOLD EVERYTHING!  This should
; 283  :       not be frame to frame memory, but....these values
; 284  :       are used in ResidAmp.c! That needs to be changed.
; 285  :   -------------------------------------------------------*/
; 286  :   if(VOX_MEM_INIT(pEncode_mblk->SWR,NFFT_2,sizeof(float))) 

  000a3	6a 04		 push	 4
  000a5	68 00 01 00 00	 push	 256			; 00000100H
  000aa	e8 00 00 00 00	 call	 _calloc
  000af	83 c4 08	 add	 esp, 8
  000b2	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  000b5	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  000b8	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  000bb	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  000bf	75 09		 jne	 SHORT $L2216

; 287  :      return 1;

  000c1	66 b8 01 00	 mov	 ax, 1
  000c5	e9 bb 01 00 00	 jmp	 $L2206
$L2216:

; 288  : 
; 289  :   if(VOX_MEM_INIT(pEncode_mblk->SWI,NFFT_2,sizeof(float))) 

  000ca	6a 04		 push	 4
  000cc	68 00 01 00 00	 push	 256			; 00000100H
  000d1	e8 00 00 00 00	 call	 _calloc
  000d6	83 c4 08	 add	 esp, 8
  000d9	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  000dc	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  000df	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  000e2	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  000e6	75 09		 jne	 SHORT $L2218

; 290  :      return 1;

  000e8	66 b8 01 00	 mov	 ax, 1
  000ec	e9 94 01 00 00	 jmp	 $L2206
$L2218:

; 291  : 
; 292  :  
; 293  :   /****************************************************
; 294  :   initialize the kaiser window 
; 295  :   initialize only for API codec. For DSP application, read from table
; 296  :   ****************************************************/
; 297  :   if(InitKaiserWindow(&pEncode_mblk->win1, FRAME_SIZE1, 6.0F))

  000f1	68 00 00 c0 40	 push	 1086324736		; 40c00000H
  000f6	68 dd 00 00 00	 push	 221			; 000000ddH
  000fb	8b 45 fc	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  000fe	83 c0 20	 add	 eax, 32			; 00000020H
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _InitKaiserWindow@12
  00107	0f b7 c8	 movzx	 ecx, ax
  0010a	85 c9		 test	 ecx, ecx
  0010c	74 09		 je	 SHORT $L2219

; 298  :      return 1;

  0010e	66 b8 01 00	 mov	 ax, 1
  00112	e9 6e 01 00 00	 jmp	 $L2206
$L2219:

; 299  :   NormSymWindowByPower(pEncode_mblk->win1, FRAME_SIZE1);

  00117	68 dd 00 00 00	 push	 221			; 000000ddH
  0011c	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  0011f	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _NormSymWindowByPower@8

; 300  : 
; 301  : 
; 302  :   if(InitKaiserWindow(&pEncode_mblk->win2, FRAME_SIZE2, 6.0F))

  00128	68 00 00 c0 40	 push	 1086324736		; 40c00000H
  0012d	68 f1 00 00 00	 push	 241			; 000000f1H
  00132	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  00135	83 c1 24	 add	 ecx, 36			; 00000024H
  00138	51		 push	 ecx
  00139	e8 00 00 00 00	 call	 _InitKaiserWindow@12
  0013e	0f b7 d0	 movzx	 edx, ax
  00141	85 d2		 test	 edx, edx
  00143	74 09		 je	 SHORT $L2220

; 303  :      return 1;

  00145	66 b8 01 00	 mov	 ax, 1
  00149	e9 37 01 00 00	 jmp	 $L2206
$L2220:

; 304  :   NormSymWindowByPower(pEncode_mblk->win2, FRAME_SIZE2);

  0014e	68 f1 00 00 00	 push	 241			; 000000f1H
  00153	8b 45 fc	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  00156	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00159	51		 push	 ecx
  0015a	e8 00 00 00 00	 call	 _NormSymWindowByPower@8

; 305  : 
; 306  :   if(InitKaiserWindow(&pEncode_mblk->win3, FRAME_SIZE3, 6.0F))

  0015f	68 00 00 c0 40	 push	 1086324736		; 40c00000H
  00164	68 05 01 00 00	 push	 261			; 00000105H
  00169	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  0016c	83 c2 28	 add	 edx, 40			; 00000028H
  0016f	52		 push	 edx
  00170	e8 00 00 00 00	 call	 _InitKaiserWindow@12
  00175	0f b7 c0	 movzx	 eax, ax
  00178	85 c0		 test	 eax, eax
  0017a	74 09		 je	 SHORT $L2221

; 307  :      return 1;

  0017c	66 b8 01 00	 mov	 ax, 1
  00180	e9 00 01 00 00	 jmp	 $L2206
$L2221:

; 308  :   NormSymWindowByPower(pEncode_mblk->win3, FRAME_SIZE3);

  00185	68 05 01 00 00	 push	 261			; 00000105H
  0018a	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  0018d	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00190	52		 push	 edx
  00191	e8 00 00 00 00	 call	 _NormSymWindowByPower@8

; 309  : 
; 310  :   /****************************************************
; 311  :   initialize parameter structure
; 312  :   ****************************************************/
; 313  :   if(VoxInitParam(&pEncode_mblk->Param_mblk, pVemMem)) 

  00196	8b 45 0c	 mov	 eax, DWORD PTR _pVemMem$[ebp]
  00199	50		 push	 eax
  0019a	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  0019d	83 c1 14	 add	 ecx, 20			; 00000014H
  001a0	51		 push	 ecx
  001a1	e8 00 00 00 00	 call	 _VoxInitParam@8
  001a6	0f b7 d0	 movzx	 edx, ax
  001a9	85 d2		 test	 edx, edx
  001ab	74 09		 je	 SHORT $L2222

; 314  :       return 1;

  001ad	66 b8 01 00	 mov	 ax, 1
  001b1	e9 cf 00 00 00	 jmp	 $L2206
$L2222:

; 315  : 
; 316  :   if(VOX_MEM_INIT(pEncode_mblk->dwLpc,LPC_ORDER+1,sizeof(double))) 

  001b6	6a 08		 push	 8
  001b8	6a 0b		 push	 11			; 0000000bH
  001ba	e8 00 00 00 00	 call	 _calloc
  001bf	83 c4 08	 add	 esp, 8
  001c2	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  001c5	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  001c8	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  001cb	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  001cf	75 09		 jne	 SHORT $L2224

; 317  :      return 1;

  001d1	66 b8 01 00	 mov	 ax, 1
  001d5	e9 ab 00 00 00	 jmp	 $L2206
$L2224:

; 318  : 
; 319  :   /****************************************************
; 320  :   attaching the Vem memory
; 321  :   ****************************************************/
; 322  :   pEncode_mblk->pVemMem=pVemMem;

  001da	8b 45 fc	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  001dd	8b 4d 0c	 mov	 ecx, DWORD PTR _pVemMem$[ebp]
  001e0	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 323  :   if(!(pEncode_mblk->vemKeyPostEncode=vemRegisterState(
; 324  :      ((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, "post encode"))) 

  001e3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@CLPIAPDA@post?5encode?$AA@
  001e8	8b 55 0c	 mov	 edx, DWORD PTR _pVemMem$[ebp]
  001eb	8b 02		 mov	 eax, DWORD PTR [edx]
  001ed	50		 push	 eax
  001ee	e8 00 00 00 00	 call	 _vemRegisterState@8
  001f3	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  001f6	89 41 40	 mov	 DWORD PTR [ecx+64], eax
  001f9	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  001fc	83 7a 40 00	 cmp	 DWORD PTR [edx+64], 0
  00200	75 06		 jne	 SHORT $L2226

; 325  :   {
; 326  : #if VEM_DEFINED == 1
; 327  :      return 1;

  00202	66 b8 01 00	 mov	 ax, 1
  00206	eb 7d		 jmp	 SHORT $L2206
$L2226:

; 328  : #endif
; 329  :   }
; 330  : 
; 331  :   if(!(pEncode_mblk->vemKeyPostCalcResAmps=vemRegisterState(
; 332  :      ((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, "post calc res amps rt")))

  00208	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@EFABGBNC@post?5calc?5res?5amps?5rt?$AA@
  0020d	8b 45 0c	 mov	 eax, DWORD PTR _pVemMem$[ebp]
  00210	8b 08		 mov	 ecx, DWORD PTR [eax]
  00212	51		 push	 ecx
  00213	e8 00 00 00 00	 call	 _vemRegisterState@8
  00218	8b 55 fc	 mov	 edx, DWORD PTR _pEncode_mblk$[ebp]
  0021b	89 42 44	 mov	 DWORD PTR [edx+68], eax
  0021e	8b 45 fc	 mov	 eax, DWORD PTR _pEncode_mblk$[ebp]
  00221	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  00225	75 06		 jne	 SHORT $L2229

; 333  :   {
; 334  : #if VEM_DEFINED == 1
; 335  :      return 1;

  00227	66 b8 01 00	 mov	 ax, 1
  0022b	eb 58		 jmp	 SHORT $L2206
$L2229:

; 336  : #endif
; 337  :   }
; 338  : 
; 339  :   vemRegisterConstShort(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, (short)RATE8K, "rate");

  0022d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04HCCHHEEF@rate?$AA@
  00232	68 40 1f 00 00	 push	 8000			; 00001f40H
  00237	8b 4d 0c	 mov	 ecx, DWORD PTR _pVemMem$[ebp]
  0023a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0023c	52		 push	 edx
  0023d	e8 00 00 00 00	 call	 _vemRegisterConstShort@12

; 340  :   vemRegisterConstShort(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, (short)MAXHARM, "max harmonics");

  00242	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@DIONPLIB@max?5harmonics?$AA@
  00247	6a 5a		 push	 90			; 0000005aH
  00249	8b 45 0c	 mov	 eax, DWORD PTR _pVemMem$[ebp]
  0024c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024e	51		 push	 ecx
  0024f	e8 00 00 00 00	 call	 _vemRegisterConstShort@12

; 341  :   vemRegisterConstShort(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, (short)FRAME_LEN, "frame length");

  00254	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@KGCNFMNN@frame?5length?$AA@
  00259	68 b4 00 00 00	 push	 180			; 000000b4H
  0025e	8b 55 0c	 mov	 edx, DWORD PTR _pVemMem$[ebp]
  00261	8b 02		 mov	 eax, DWORD PTR [edx]
  00263	50		 push	 eax
  00264	e8 00 00 00 00	 call	 _vemRegisterConstShort@12

; 342  :   vemRegisterVariable(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, 
; 343  :      pEncode_mblk->dwLpc, VEM_FLOAT, "energy");

  00269	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06KKGCKCNJ@energy?$AA@
  0026e	6a 09		 push	 9
  00270	8b 4d fc	 mov	 ecx, DWORD PTR _pEncode_mblk$[ebp]
  00273	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00276	52		 push	 edx
  00277	8b 45 0c	 mov	 eax, DWORD PTR _pVemMem$[ebp]
  0027a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027c	51		 push	 ecx
  0027d	e8 00 00 00 00	 call	 _vemRegisterVariable@16

; 344  : 
; 345  :   
; 346  :   return 0; 

  00282	66 33 c0	 xor	 ax, ax
$L2206:

; 347  : }

  00285	8b e5		 mov	 esp, ebp
  00287	5d		 pop	 ebp
  00288	c2 08 00	 ret	 8
_VoxInitEncodeRT@8 ENDP
_TEXT	ENDS
PUBLIC	_VoxFreeEncodeRT@4
EXTRN	_VoxFreeCorrPitchEst@4:NEAR
EXTRN	_VoxFreeVoicing@4:NEAR
EXTRN	_VoxFreeParam@4:NEAR
EXTRN	_FreeKaiserWindow@4:NEAR
EXTRN	_FreeSpCBM@4:NEAR
EXTRN	_free:NEAR
EXTRN	_nspFreeFftResources@0:NEAR
EXTRN	_VoxFreePreProc@4:NEAR
; Function compile flags: /Odt
;	COMDAT _VoxFreeEncodeRT@4
_TEXT	SEGMENT
_pMemBlkE$ = -4
_hMemBlkE$ = 8
_VoxFreeEncodeRT@4 PROC NEAR				; COMDAT

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 375  :   ENC_MEM_BLK *pMemBlkE=(ENC_MEM_BLK *)*hMemBlkE;

  00004	8b 45 08	 mov	 eax, DWORD PTR _hMemBlkE$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _pMemBlkE$[ebp], ecx

; 376  : 
; 377  :   if (*hMemBlkE) {

  0000c	8b 55 08	 mov	 edx, DWORD PTR _hMemBlkE$[ebp]
  0000f	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00012	0f 84 e7 00 00
	00		 je	 $L2247

; 378  : 
; 379  :      /**** free circular structure ****/
; 380  :      FreeSpCBM(&pMemBlkE->CircBuf_mblk);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _pMemBlkE$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _FreeSpCBM@4

; 381  : 
; 382  :      /**** free preprocess structure ****/
; 383  :      VoxFreePreProc(&pMemBlkE->PreProc_mblk); 

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _pMemBlkE$[ebp]
  00024	83 c1 04	 add	 ecx, 4
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _VoxFreePreProc@4

; 384  : 
; 385  :      /**** free Voicing structure ****/
; 386  :      VoxFreeVoicing(&pMemBlkE->Voicing_mblk);

  0002d	8b 55 fc	 mov	 edx, DWORD PTR _pMemBlkE$[ebp]
  00030	83 c2 08	 add	 edx, 8
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _VoxFreeVoicing@4

; 387  : 
; 388  :      /**** free CorrPDA structure ****/
; 389  :      VoxFreeCorrPitchEst(&pMemBlkE->PDA_mblk);

  00039	8b 45 fc	 mov	 eax, DWORD PTR _pMemBlkE$[ebp]
  0003c	83 c0 0c	 add	 eax, 12			; 0000000cH
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _VoxFreeCorrPitchEst@4

; 390  : 
; 391  :      /**** free Param structure ****/
; 392  :      VoxFreeParam(&pMemBlkE->Param_mblk);

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _pMemBlkE$[ebp]
  00048	83 c1 14	 add	 ecx, 20			; 00000014H
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _VoxFreeParam@4

; 393  : 
; 394  :      /**** free the kaiser windows ****/
; 395  :      FreeKaiserWindow(&pMemBlkE->win1);

  00051	8b 55 fc	 mov	 edx, DWORD PTR _pMemBlkE$[ebp]
  00054	83 c2 20	 add	 edx, 32			; 00000020H
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 _FreeKaiserWindow@4

; 396  :      FreeKaiserWindow(&pMemBlkE->win2);

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _pMemBlkE$[ebp]
  00060	83 c0 24	 add	 eax, 36			; 00000024H
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _FreeKaiserWindow@4

; 397  :      FreeKaiserWindow(&pMemBlkE->win3);

  00069	8b 4d fc	 mov	 ecx, DWORD PTR _pMemBlkE$[ebp]
  0006c	83 c1 28	 add	 ecx, 40			; 00000028H
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 _FreeKaiserWindow@4

; 398  : 
; 399  :      VOX_MEM_FREE(pMemBlkE->SWR);    

  00075	8b 55 fc	 mov	 edx, DWORD PTR _pMemBlkE$[ebp]
  00078	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  0007c	74 19		 je	 SHORT $L2248
  0007e	8b 45 fc	 mov	 eax, DWORD PTR _pMemBlkE$[ebp]
  00081	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _free
  0008a	83 c4 04	 add	 esp, 4
  0008d	8b 55 fc	 mov	 edx, DWORD PTR _pMemBlkE$[ebp]
  00090	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0
$L2248:

; 400  :      VOX_MEM_FREE(pMemBlkE->SWI);

  00097	8b 45 fc	 mov	 eax, DWORD PTR _pMemBlkE$[ebp]
  0009a	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0009e	74 19		 je	 SHORT $L2250
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _pMemBlkE$[ebp]
  000a3	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 _free
  000ac	83 c4 04	 add	 esp, 4
  000af	8b 45 fc	 mov	 eax, DWORD PTR _pMemBlkE$[ebp]
  000b2	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$L2250:

; 401  : 
; 402  :      VOX_MEM_FREE(pMemBlkE->dwLpc);

  000b9	8b 4d fc	 mov	 ecx, DWORD PTR _pMemBlkE$[ebp]
  000bc	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  000c0	74 19		 je	 SHORT $L2252
  000c2	8b 55 fc	 mov	 edx, DWORD PTR _pMemBlkE$[ebp]
  000c5	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 _free
  000ce	83 c4 04	 add	 esp, 4
  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _pMemBlkE$[ebp]
  000d4	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
$L2252:

; 403  :      
; 404  : #ifdef WIN32
; 405  :      nspFreeFftResources();

  000db	e8 00 00 00 00	 call	 _nspFreeFftResources@0

; 406  : #endif
; 407  : 
; 408  :      VOX_MEM_FREE(*hMemBlkE);

  000e0	8b 55 08	 mov	 edx, DWORD PTR _hMemBlkE$[ebp]
  000e3	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000e6	74 17		 je	 SHORT $L2247
  000e8	8b 45 08	 mov	 eax, DWORD PTR _hMemBlkE$[ebp]
  000eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ed	51		 push	 ecx
  000ee	e8 00 00 00 00	 call	 _free
  000f3	83 c4 04	 add	 esp, 4
  000f6	8b 55 08	 mov	 edx, DWORD PTR _hMemBlkE$[ebp]
  000f9	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L2247:

; 409  :   }
; 410  :   return 0;

  000ff	66 33 c0	 xor	 ax, ax

; 411  : }

  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c2 04 00	 ret	 4
_VoxFreeEncodeRT@4 ENDP
_TEXT	ENDS
PUBLIC	__real@422c0000
PUBLIC	__real@42700000
;	COMDAT __real@422c0000
CONST	SEGMENT
__real@422c0000 DD 0422c0000r			; 43
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _VoxGetWinLength@4
_TEXT	SEGMENT
_pitch$ = 8
_VoxGetWinLength@4 PROC NEAR				; COMDAT

; 414  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 415  :   if(pitch> PITCH4FRAME_SIZE3) {   /* 60 & 261 window */

  00003	d9 45 08	 fld	 DWORD PTR _pitch$[ebp]
  00006	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@422c0000
  0000c	df e0		 fnstsw	 ax
  0000e	f6 c4 41	 test	 ah, 65			; 00000041H
  00011	75 06		 jne	 SHORT $L2259

; 416  :       return FRAME_SIZE3;

  00013	66 b8 05 01	 mov	 ax, 261			; 00000105H
  00017	eb 1a		 jmp	 SHORT $L2258
$L2259:

; 417  :    }
; 418  :    else {                                  
; 419  :      if (pitch > PITCH4FRAME_SIZE2) { /* 43 & 241 window */

  00019	d9 45 08	 fld	 DWORD PTR _pitch$[ebp]
  0001c	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@42700000
  00022	df e0		 fnstsw	 ax
  00024	f6 c4 41	 test	 ah, 65			; 00000041H
  00027	75 06		 jne	 SHORT $L2261

; 420  :          return FRAME_SIZE2;

  00029	66 b8 f1 00	 mov	 ax, 241			; 000000f1H
  0002d	eb 04		 jmp	 SHORT $L2258
$L2261:

; 421  :       }
; 422  :      else {
; 423  :        return FRAME_SIZE1;

  0002f	66 b8 dd 00	 mov	 ax, 221			; 000000ddH
$L2258:

; 424  :      }
; 425  :    }
; 426  : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
_VoxGetWinLength@4 ENDP
_TEXT	ENDS
END
