; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	.\dscommon.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
DSOUND_URW	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_URW	ENDS
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DH@HLNMLIHP@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_06GGPOMPNM@?$CInone?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DJ@LDJKBAOD@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0O@GGBLDHEI@?$CBm_dwRefCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BE@DAEOBIBM@m_dwRefCount?5?$DM?5?$HO0UL?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0N@OILPJBKD@m_dwRefCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DH@IMPCONDJ@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_01FJMABOPO@x?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0P@PGACJKHL@?$CB?$CIx?5?$CG?5?$CIx?5?9?51?$CJ?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DF@KHLJBLPM@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@MLMBNMPN@nLength?5?$DO?5sizeof?$CI?$CKpRunMarker?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DF@GEBIDJGO@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@DHEFJAIP@IsValidAlgorithm?$CI?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@FFGMCHMA@m_pfnGetFilterPair?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_06JAKMBBHB@DSOUND?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DG@DIPNMLMO@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0FF@CEBOEHDG@DirectSound?5is?5in?5the?5final?5stag@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BF@JCCIJAPA@CDirectSound?3?3AddRef?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@IDOOAHKJ@CDirectSoundBuffer?3?3AddRef?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@IJJNEHOC@CDirectSoundBuffer?3?3Release?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@PKKBNDKL@CDirectSoundBuffer?3?3SetFormat?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@PPDEBFDO@CDirectSoundBuffer?3?3SetFrequency@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@INMBMDIC@CDirectSoundBuffer?3?3SetVolume?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BN@FNHOKAIC@CDirectSoundBuffer?3?3SetPitch?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@BGJIIJJH@CDirectSoundBuffer?3?3SetLFO?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@EOPIEBA@CDirectSoundBuffer?3?3SetEG?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@IPGKAOBK@CDirectSoundBuffer?3?3SetFilter?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@EJJCKIBH@CDirectSoundBuffer?3?3SetHeadroom?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@IJCIHAHO@CDirectSoundBuffer?3?3SetOutputBuf@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BP@ENFJENBA@CDirectSoundBuffer?3?3SetMixBins?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@GMNMDMFI@CDirectSoundBuffer?3?3SetMixBinVol@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@CFIEOKFB@CDirectSoundBuffer?3?3SetAllParame@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@GKILFNCM@CDirectSoundBuffer?3?3SetConeAngle@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CH@BJHPKLFJ@CDirectSoundBuffer?3?3SetConeOrien@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CJ@FPOKJAEF@CDirectSoundBuffer?3?3SetConeOutsi@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CD@LECKPDBD@CDirectSoundBuffer?3?3SetMaxDistan@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CD@CEFJODPJ@CDirectSoundBuffer?3?3SetMinDistan@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@KCLFGBIJ@CDirectSoundBuffer?3?3SetMode?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@CJDDDDA@CDirectSoundBuffer?3?3SetPosition?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@GALGNKNN@CDirectSoundBuffer?3?3SetVelocity?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CG@OMPMKPGG@CDirectSoundBuffer?3?3SetDistanceF@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@DNKDAAOC@CDirectSoundBuffer?3?3SetDopplerFa@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@CEGGDJFO@CDirectSoundBuffer?3?3SetRolloffFa@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@LIPCEEAM@CDirectSoundBuffer?3?3SetRolloffCu@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CD@HPKGJBBG@CDirectSoundBuffer?3?3SetI3DL2Sour@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@IGCEBFCD@CDirectSoundStream?3?3AddRef?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@IEPFOHMO@CDirectSoundStream?3?3Release?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@BFEGBGIF@CDirectSoundStream?3?3SetFormat?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@EFAECKOL@CDirectSoundStream?3?3SetFrequency@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BN@GPKLKEMB@CDirectSoundStream?3?3SetPitch?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@GCCGAGKM@CDirectSoundStream?3?3SetVolume?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@BDFCJLBN@CDirectSoundStream?3?3SetLFO?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@MOKKBNNH@CDirectSoundStream?3?3SetEG?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@GAINMLDE@CDirectSoundStream?3?3SetFilter?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@KJJLHIOD@CDirectSoundStream?3?3SetHeadroom?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@HMGNJNIP@CDirectSoundStream?3?3SetOutputBuf@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BP@JBGAKHBK@CDirectSoundStream?3?3SetMixBins?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@KGJDLLDP@CDirectSoundStream?3?3SetMixBinVol@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@OPMLGNDG@CDirectSoundStream?3?3SetAllParame@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@JMIIELEI@CDirectSoundStream?3?3SetConeAngle@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CH@EABPIKPF@CDirectSoundStream?3?3SetConeOrien@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CJ@BBDBCKJO@CDirectSoundStream?3?3SetConeOutsi@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CD@POADFFEE@CDirectSoundStream?3?3SetMaxDistan@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CD@GOHAEFKO@CDirectSoundStream?3?3SetMinDistan@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BM@KPNNMBKF@CDirectSoundStream?3?3SetMode?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@OCJKODME@CDirectSoundStream?3?3SetPosition?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@IALPAKCJ@CDirectSoundStream?3?3SetVelocity?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CG@DPOABEBK@CDirectSoundStream?3?3SetDistanceF@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@PHOMIHIF@CDirectSoundStream?3?3SetDopplerFa@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@OOCJLODJ@CDirectSoundStream?3?3SetRolloffFa@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@ENLHKJPN@CDirectSoundStream?3?3SetRolloffCu@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CD@DFIPDHEB@CDirectSoundStream?3?3SetI3DL2Sour@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DJ@JNKFENGM@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0O@JCBGLFIF@?$CBm_paNotifier?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@JLKNBNJM@?$CBm_dwNotifierCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0N@BMLCBDGO@m_paNotifier?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@ELEAODJN@dwNotifierIndex?5?$DM?5m_dwNotifierCo@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@MEDKFNKN@Unexpected?5notifier?5status?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BC@NHNIONPC@m_dwNotifierCount?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DH@NBALOMF@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BA@IANIBDAF@m_pGpDspManager?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@ONCKHILO@m_dwState?5?$CG?5MCPX_APUSTATE_GPIMAG@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@FGGNHBE@KeGetCurrentIrql?$CI?$CJ?5?$DO?$DN?5DISPATCH_L@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@IECLLDN@m_dwVoiceMapLock?5?$DM?5?$HO0UL?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@FFOHIBNC@m_dwVoiceMapLock?5?$DO?$DN?51?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DJ@MEFGGIAF@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DB@IBOGJEGG@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pSettings?9?$DO@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CP@IDFLDLJM@?$CB?$CIm_pSettings?9?$DOm_dwFlags?5?$CG?5DSBCA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0EJ@DJPLDOLH@m_pSettings?9?$DOm_pMixinBuffer?9?$DOm_p@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DI@MBLALCOP@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@CELCEBLE@CAc97MediaObject?3?3AddRef?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@OKDMHHHN@CAc97MediaObject?3?3Release?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_04PFAOODAA@?$CFs?3?5?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0L@PAPNLNAE@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_05HFOMLNMD@?$CFhs?3?5?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_07BCNBNNHO@?$CF?48lx?3?5?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_07KAJBENLI@Error?3?5?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@ELBNBAPH@Resource?5failure?3?5?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_09CKCJCCOK@Warning?3?5?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0EP@LPAKAOHB@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BF@DPPFGDJL@Assertion?5failed?5in?5?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_07BAMMBJFH@?0?5line?5?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_02NDKNKOCB@?3?6?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_08DNIHDBFJ@cbBuffer?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@BFDMGCLI@CMemoryManager?3?3PoolAlloc?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@EKDKBHPJ@Out?5of?5pool?5memory?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_08FADLHADM@pvBuffer?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@LBPCLHHJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_07KIGAHELJ@dwFlags?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@GNDANLGM@CMemoryManager?3?3PhysicalAlloc?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@BGANBOHC@Out?5of?5contiguous?5memory?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@EHAFMALM@m_dwPhysicalMemoryUsage?5?$DO?$DN?5cbBuf@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DC@OLMEENNO@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5?$CK?$CI?$CILPDW@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@GADDBPNL@Slop?5memory?5heap?5does?5not?5exist?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BE@FMKOLKGH@Invalid?5memory?5free?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@KOBBHKIF@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_06OFIAKHFO@cbSize?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CK@PJHOCMHE@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0EP@IIFDJHMP@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@HAOLFHG@CMemoryManager?3?3DumpMemoryUsage?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@MIBDOIDJ@Begin?5memory?5usage?5dump?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@JPIKIBNC@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@OHKIAENG@Pool?5memory?5used?3?5?5?$CFlu?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@OGBIDBPB@Physical?5memory?5used?3?5?5?$CFlu?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CN@EIKGFANE@Physical?5memory?5available?5for?5re@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@HBBPMJBE@Physical?5memory?5recovered?3?5?5?$CFlu?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@DICBIGIJ@End?5memory?5usage?5dump?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CD@DONIJHHD@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@CGDLDDDA@IsListEmpty?$CI?$CGm_lstMemoryTracking@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_04JNFLDEGE@pwfx?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_05PJHAMANO@pDest?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_07HPANBCJA@pSource?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@EABPBKPE@Unexpected?5format?5tag?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@OPJEJGND@WaveFormat?3?3IsValidFormat?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@NEGDFCOA@Unsupported?5format?5tag?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@KKKKMHLO@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@PIODLKGG@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BN@OLFDGMMG@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BN@IFFDBLPG@WaveFormat?3?3IsValidPcmFormat?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@MNFLEIKF@Format?5tag?5not?5PCM?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@LMINNPNJ@Invalid?5channel?5count?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@PGNHDJHJ@Invalid?5sample?5bit?5resolution?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@JMHMKDN@Invalid?5sampling?5rate?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BE@CNMNFPGH@Bad?5block?5alignment?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BP@BHADMBB@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@JGBOPGED@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@OIKDEMKO@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BP@DHOFLMLF@WaveFormat?3?3IsValidAdpcmFormat?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@IAKEEFCK@Format?5tag?5not?5XBOX_ADPCM?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0P@NDFBNMGN@cbSize?5not?5?$CFlu?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@COGBELGK@Invalid?5samples?5per?5block?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BE@OGFJBCGA@Bad?5block?9alignment?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BF@GEHOBCDM@Unexpected?5subformat?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@BDDCNENN@WaveFormat?3?3IsValidExtensibleFor@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@FCNDIHOL@Format?5tag?5not?5EXTENSIBLE?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CO@KKIDLDBA@wValidBitsPerSample?5must?5equal?5w@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@OINPDAHG@wReserved?5must?5be?50?5for?5SUBTYPE_@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@BCDFCNJM@Invalid?5sub?9format?5identifier?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BF@JKCBDHDB@Invalid?5channel?5mask?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@KOCFKEKK@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BF@IINNEHHF@CStdFileStream?3?3Open?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@CEKMADFG@Error?5?$CFlu?5occurred?5trying?5to?5ope@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BP@BFEOIFMP@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BF@IKIMPDLN@CStdFileStream?3?3Read?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CJ@EBECGKOP@Error?5?$CFlu?5occurred?5reading?5from?5@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CH@JEFGPKIM@Not?5enough?5data?5was?5read?5from?5th@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@PGEPINJO@CStdFileStream?3?3Write?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CH@HNBEJLKA@Error?5?$CFlu?5occurred?5writing?5to?5th@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CK@PPGKDJFB@Not?5enough?5data?5was?5written?5from@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BF@DHHNGOBO@CStdFileStream?3?3Seek?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@IKNCKFMB@Error?5?$CFlu?5occurred?5seeking?5the?5f@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@HKFPFMIN@CStdFileStream?3?3GetLength?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CK@HKLDFKFN@Error?5?$CFlu?5attempting?5to?5get?5the?5@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BB@JCIHLOCG@CRiffChunk?3?3Read?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CM@BMKKIDJB@Attempted?5to?5read?5past?5the?5end?5o@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DC@IFKBAFN@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BA@CGAHBFNM@CWaveFile?3?3Open?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@OHEGKMMD@The?5file?5type?5is?5not?5WAVE?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@CAIFKCHB@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CL@IIKFACCB@The?5file?8s?5AIFF?9C?5version?5is?5not@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_04ELFAHOMP@BYTE?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0N@NLKBAEGB@m_pwfxFormat?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CG@JOBMGAMO@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CG@EHNKEHDO@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@EIPMIGEK@CWaveFile?3?3GetAiffFormat?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@NCAIELLP@Unsupported?5AIFF?5compression?5typ@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@IFLBNNFE@CStdFileStream?3?3GetWaveLoopRegio@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@GLLFAJJE@No?5FORWARD?5loop?5regions?5found?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CJ@LNLNMGAM@Only?5the?5first?5FORWARD?5loop?5will@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@BDOJPMPF@CStdFileStream?3?3GetAiffLoopRegio@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@FNJEOFIE@Neither?5loop?5is?5FORWARD?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DF@NNLKMLKP@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BN@NNMJOLHM@Can?8t?5find?5loop?5start?5marker?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DD@LMHJPJKK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@NJFKBAAP@Can?8t?5find?5loop?5end?5marker?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DB@NDLCCDDP@Loop?5end?5point?5less?9than?9or?9equa@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CM@HBKMMLMK@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BA@NOEFBMFE@8?5?$DN?$DN?5dwBitDepth?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@GLKFBKGJ@NULL?5?$CCthis?$CC?5pointer?5?$CI?$CFx?$CJ?$AA@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@LEKIOFPG@Invalid?5?$CCthis?$CC?5pointer?5?$CI?$CFx?5?$CB?$DN?5?$CFx@
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
DSOUND_RW	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RW	ENDS
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IsEqualGUID@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _==@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _KeGetCurrentIrql@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _KeIsExecutingDpc@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_AddRef@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_Release@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_GetAdapterCount@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_BeginScene@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_EndScene@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_GetRenderState@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_GetTextureStageState@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_SetRenderState@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_SetTextureStageState@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DResource_MoveResourceMemory@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DTexture_UnlockRect@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVolumeTexture_UnlockBox@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DCubeTexture_UnlockRect@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVertexBuffer_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DIndexBuffer_Lock@20
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DIndexBuffer_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DPalette_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DSurface_UnlockRect@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVolume_UnlockBox@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _log10f@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _sqrtf@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@MMMMMMMMMMMMMMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXPLANE@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _wmemchr@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??3@YAXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CIrql@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Raise@CIrql@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Lower@CIrql@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAutoIrql@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAutoIrql@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Save@CFpState@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Restore@CFpState@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCRefCount@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CRefCount@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AddRef@CRefCount@DirectSound@@UAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Release@CRefCount@DirectSound@@UAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetDataOffset@CRiffChunk@WaveLoader@@QAEKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetDuration@CWaveFile@WaveLoader@@QAEJPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetFormat@CWaveFile@WaveLoader@@QAEJPAPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?FloatToLong@Math@DirectSound@@YGJM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?lsb@Math@DirectSound@@YIII@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?IsValidAlgorithm@CHrtfSource@DirectSound@@SGHXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister8@CAc97Device@DirectSound@@KGEK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister8@CAc97Device@DirectSound@@KGXKE@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister16@CAc97Device@DirectSound@@KGGK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister16@CAc97Device@DirectSound@@KGXKG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister32@CAc97Device@DirectSound@@KGKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister32@CAc97Device@DirectSound@@KGXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister8@CAc97Device@DirectSound@@KGEK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister8@CAc97Device@DirectSound@@KGXKE@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister16@CAc97Device@DirectSound@@KGGK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister16@CAc97Device@DirectSound@@KGXKG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister32@CAc97Device@DirectSound@@KGKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister32@CAc97Device@DirectSound@@KGXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ReleaseChannel@CAc97Device@DirectSound@@QAEXPAVCAc97Channel@2@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundEnterCriticalSection@@YGHXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundLeaveCriticalSection@@YGXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAutoLock@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAutoLock@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CMcpxNotifier@DirectSound@@QAEXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Free@CMcpxNotifier@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Reset@CMcpxNotifier@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetScratchSpaceLinAddr@CMcpxDspScratchDma@DirectSound@@QAEPAXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _$E1
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _$E3
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _$E5
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?dstrcpy@@YGPADPADPBD@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Print@CDebug@DirectSound@@SAXPBDZZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Break@CDebug@DirectSound@@SAXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _$E7
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _$E9
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?TrackingMemAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?TrackingMemFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ExtensibleToInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUWAVEFORMATEXTENSIBLE@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?IsValidExtensibleFormat@WaveFormat@DirectSound@@YGHPBUWAVEFORMATEXTENSIBLE@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?EndianSwapWord@@YIGG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?EndianSwapDword@@YIKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CStdFileStream@WaveLoader@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CStdFileStream@WaveLoader@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Close@CStdFileStream@WaveLoader@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CRiffChunk@WaveLoader@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CRiffChunk@WaveLoader@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CWaveFile@WaveLoader@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CWaveFile@WaveLoader@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Close@CWaveFile@WaveLoader@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CImaAdpcmCodec@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CImaAdpcmCodec@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1?$CValidObject@$0EEFDEOEE@@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AssertValidObject@?$CValidObject@$0EEFDEOEE@@DirectSound@@QAEXPBDK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1?$CValidObject@$0EEFDECCA@@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AssertValidObject@?$CValidObject@$0EEFDECCA@@DirectSound@@QAEXPBDK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1?$CValidObject@$0EEFDFDCA@@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AssertValidObject@?$CValidObject@$0EEFDFDCA@@DirectSound@@QAEXPBDK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1?$CValidObject@$0EBEDDJDH@@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AssertValidObject@?$CValidObject@$0EBEDDJDH@@DirectSound@@QAEXPBDK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_G?$CValidObject@$0EEFDEOEE@@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_G?$CValidObject@$0EEFDECCA@@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_G?$CValidObject@$0EEFDFDCA@@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_G?$CValidObject@$0EBEDDJDH@@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?wBitsPerSample@?1??AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z@4EB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?wBytesPerBlock@?1??IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z@4GB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?wBitsPerSample@?1??IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z@4GB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?cbTracking@?1??TrackingMemAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z@4KB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_7?$CValidObject@$0EEFDECCA@@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CImaAdpcmCodec@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CValidObject@$0EBEDDJDH@@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CValidObject@$0EEFDEOEE@@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CRefCount@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CValidObject@$0EEFDFDCA@@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?pszBanner@?1??Assert@CDebug@DirectSound@@SAXHPBD0I@Z@4QBDB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?wSamplesPerBlock@?1??IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z@4GB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?cbTracking@?1??TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z@4KB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V, DSOUND_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?m_asNextStep@CImaAdpcmCodec@DirectSound@@0QBFB	; DirectSound::CImaAdpcmCodec::m_asNextStep
PUBLIC	?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB	; DirectSound::CImaAdpcmCodec::m_asStep
PUBLIC	_D3DPRIMITIVETOVERTEXCOUNT
PUBLIC	_D3DSIMPLERENDERSTATEENCODE
PUBLIC	_D3DTEXTUREDIRECTENCODE
PUBLIC	_D3DDIRTYFROMRENDERSTATE
PUBLIC	_D3DDIRTYFROMTEXTURESTATE
PUBLIC	?m_pfnDpfCallback@CDebug@DirectSound@@2P6GXKPBD@ZA ; DirectSound::CDebug::m_pfnDpfCallback
PUBLIC	?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A ; DirectSound::CDebug::m_aContext
PUBLIC	?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
PUBLIC	?m_dwRefCount@CFpState@DirectSound@@0KA		; DirectSound::CFpState::m_dwRefCount
PUBLIC	?m_fps@CFpState@DirectSound@@0U_KFLOATING_SAVE@@A ; DirectSound::CFpState::m_fps
PUBLIC	_DSoundBuildNumberD
DSOUND_URW	SEGMENT
?m_fps@CFpState@DirectSound@@0U_KFLOATING_SAVE@@A DB 020H DUP (?) ; DirectSound::CFpState::m_fps
DSOUND_URW	ENDS
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
DSOUND_RD	SEGMENT
_D3DPRIMITIVETOVERTEXCOUNT DD 00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
DSOUND_RD	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
DSOUND_RD	SEGMENT
_D3DSIMPLERENDERSTATEENCODE DD 040260H
	DD	040264H
	DD	040268H
	DD	04026cH
	DD	040270H
	DD	040274H
	DD	040278H
	DD	04027cH
	DD	040288H
	DD	04028cH
	DD	040a60H
	DD	040a64H
	DD	040a68H
	DD	040a6cH
	DD	040a70H
	DD	040a74H
	DD	040a78H
	DD	040a7cH
	DD	040a80H
	DD	040a84H
	DD	040a88H
	DD	040a8cH
	DD	040a90H
	DD	040a94H
	DD	040a98H
	DD	040a9cH
	DD	040aa0H
	DD	040aa4H
	DD	040aa8H
	DD	040aacH
	DD	040ab0H
	DD	040ab4H
	DD	040ab8H
	DD	040abcH
	DD	040ac0H
	DD	040ac4H
	DD	040ac8H
	DD	040accH
	DD	040ad0H
	DD	040ad4H
	DD	040ad8H
	DD	040adcH
	DD	0417f8H
	DD	041e20H
	DD	041e24H
	DD	041e40H
	DD	041e44H
	DD	041e48H
	DD	041e4cH
	DD	041e50H
	DD	041e54H
	DD	041e58H
	DD	041e5cH
	DD	041e60H
	DD	041d90H
	DD	041e74H
	DD	041e78H
	DD	040354H
	DD	04033cH
	DD	040304H
	DD	040300H
	DD	040340H
	DD	040344H
	DD	040348H
	DD	04035cH
	DD	040310H
	DD	04037cH
	DD	040358H
	DD	040374H
	DD	040378H
	DD	040364H
	DD	040368H
	DD	04036cH
	DD	040360H
	DD	040350H
	DD	04034cH
	DD	0409f8H
	DD	040384H
	DD	040388H
	DD	040330H
	DD	040334H
	DD	040338H
DSOUND_RD	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
DSOUND_RD	SEGMENT
_D3DTEXTUREDIRECTENCODE DD 081b00H
	DD	081b40H
	DD	081b80H
	DD	081bc0H
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
DSOUND_RD	SEGMENT
_D3DDIRTYFROMRENDERSTATE DD 02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	01200H
	DD	03000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	0100H
	DD	0100H
	DD	0900H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	00H
	DD	00H
	DD	00H
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
DSOUND_RD	SEGMENT
_D3DDIRTYFROMTEXTURESTATE DD 0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0480fH
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0400H
DSOUND_RD	ENDS
;	COMDAT _DSoundBuildNumberD
XBLD$V	SEGMENT
_DSoundBuildNumberD DW 05344H
	DW	0554fH
	DW	0444eH
	DW	044H
	DW	01H
	DW	00H
	DW	01130H
	DW	08001H
XBLD$V	ENDS
DSOUND_RW	SEGMENT
?m_pfnDpfCallback@CDebug@DirectSound@@2P6GXKPBD@ZA DD 00H ; DirectSound::CDebug::m_pfnDpfCallback
	ORG $+4
?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A DD 00H ; DirectSound::CDebug::m_aContext
	ORG $+764
?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A DD 00H ; DirectSound::CMemoryManager::m_lstMemoryTracking
	ORG $+4
?m_dwRefCount@CFpState@DirectSound@@0KA DD 00H		; DirectSound::CFpState::m_dwRefCount
DSOUND_RW	ENDS
DSOUND_RD	SEGMENT
?m_asNextStep@CImaAdpcmCodec@DirectSound@@0QBFB DW 0ffffH ; DirectSound::CImaAdpcmCodec::m_asNextStep
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	02H
	DW	04H
	DW	06H
	DW	08H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	02H
	DW	04H
	DW	06H
	DW	08H
?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB DW 07H	; DirectSound::CImaAdpcmCodec::m_asStep
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	010H
	DW	011H
	DW	013H
	DW	015H
	DW	017H
	DW	019H
	DW	01cH
	DW	01fH
	DW	022H
	DW	025H
	DW	029H
	DW	02dH
	DW	032H
	DW	037H
	DW	03cH
	DW	042H
	DW	049H
	DW	050H
	DW	058H
	DW	061H
	DW	06bH
	DW	076H
	DW	082H
	DW	08fH
	DW	09dH
	DW	0adH
	DW	0beH
	DW	0d1H
	DW	0e6H
	DW	0fdH
	DW	0117H
	DW	0133H
	DW	0151H
	DW	0173H
	DW	0198H
	DW	01c1H
	DW	01eeH
	DW	0220H
	DW	0256H
	DW	0292H
	DW	02d4H
	DW	031cH
	DW	036cH
	DW	03c3H
	DW	0424H
	DW	048eH
	DW	0502H
	DW	0583H
	DW	0610H
	DW	06abH
	DW	0756H
	DW	0812H
	DW	08e0H
	DW	09c3H
	DW	0abdH
	DW	0bd0H
	DW	0cffH
	DW	0e4cH
	DW	0fbaH
	DW	0114cH
	DW	01307H
	DW	014eeH
	DW	01706H
	DW	01954H
	DW	01bdcH
	DW	01ea5H
	DW	021b6H
	DW	02515H
	DW	028caH
	DW	02cdfH
	DW	0315bH
	DW	0364bH
	DW	03bb9H
	DW	041b2H
	DW	04844H
	DW	04f7eH
	DW	05771H
	DW	0602fH
	DW	069ceH
	DW	07462H
	DW	07fffH
DSOUND_RD	ENDS
EXTRN	_g_dwDirectSoundDebugLevel:DWORD
CRT$XCU	SEGMENT
_$S2	DD	FLAT:_$E1
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\debug.cpp
CRT$XCU	ENDS
;	COMDAT _$E1
DSOUND	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 20   : DWORD &CDebug::m_dwDpfLevel = g_dwDirectSoundDebugLevel;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_dwDpfLevel@CDebug@DirectSound@@2AAKA, OFFSET FLAT:_g_dwDirectSoundDebugLevel ; DirectSound::CDebug::m_dwDpfLevel
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_$E1	ENDP
DSOUND	ENDS
EXTRN	_g_dwDirectSoundDebugBreakLevel:DWORD
CRT$XCU	SEGMENT
_$S4	DD	FLAT:_$E3
; Function compile flags: /Odt
CRT$XCU	ENDS
;	COMDAT _$E3
DSOUND	SEGMENT
_$E3	PROC NEAR					; COMDAT

; 21   : DWORD &CDebug::m_dwDpfBreakLevel = g_dwDirectSoundDebugBreakLevel;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_dwDpfBreakLevel@CDebug@DirectSound@@2AAKA, OFFSET FLAT:_g_dwDirectSoundDebugBreakLevel ; DirectSound::CDebug::m_dwDpfBreakLevel
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_$E3	ENDP
DSOUND	ENDS
EXTRN	_g_fDirectSoundDebugBreak:DWORD
CRT$XCU	SEGMENT
_$S6	DD	FLAT:_$E5
; Function compile flags: /Odt
CRT$XCU	ENDS
;	COMDAT _$E5
DSOUND	SEGMENT
_$E5	PROC NEAR					; COMDAT

; 22   : BOOL &CDebug::m_fDebugBreak = g_fDirectSoundDebugBreak;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_fDebugBreak@CDebug@DirectSound@@2AAHA, OFFSET FLAT:_g_fDirectSoundDebugBreak ; DirectSound::CDebug::m_fDebugBreak
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_$E5	ENDP
DSOUND	ENDS
PUBLIC	?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z ; DirectSound::CDebug::PrintStaticV
PUBLIC	?Break@CDebug@DirectSound@@SAXXZ		; DirectSound::CDebug::Break
PUBLIC	?dstrcpy@@YGPADPADPBD@Z				; dstrcpy
PUBLIC	??_C@_04PFAOODAA@?$CFs?3?5?$AA@			; `string'
PUBLIC	??_C@_0L@PAPNLNAE@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@	; `string'
PUBLIC	??_C@_05HFOMLNMD@?$CFhs?3?5?$AA@		; `string'
PUBLIC	??_C@_07BCNBNNHO@?$CF?48lx?3?5?$AA@		; `string'
PUBLIC	??_C@_07KAJBENLI@Error?3?5?$AA@			; `string'
PUBLIC	??_C@_0BD@ELBNBAPH@Resource?5failure?3?5?$AA@	; `string'
PUBLIC	??_C@_09CKCJCCOK@Warning?3?5?$AA@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
EXTRN	_GetCurrentThreadId@0:NEAR
EXTRN	_sprintf:NEAR
EXTRN	_vsprintf:NEAR
EXTRN	_OutputDebugStringA@4:NEAR
;	COMDAT ??_C@_04PFAOODAA@?$CFs?3?5?$AA@
DSOUND_RD	SEGMENT
??_C@_04PFAOODAA@?$CFs?3?5?$AA@ DB '%s: ', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0L@PAPNLNAE@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@
DSOUND_RD	SEGMENT
??_C@_0L@PAPNLNAE@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@ DB '%hs(%lu): ', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_05HFOMLNMD@?$CFhs?3?5?$AA@
DSOUND_RD	SEGMENT
??_C@_05HFOMLNMD@?$CFhs?3?5?$AA@ DB '%hs: ', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_07BCNBNNHO@?$CF?48lx?3?5?$AA@
DSOUND_RD	SEGMENT
??_C@_07BCNBNNHO@?$CF?48lx?3?5?$AA@ DB '%.8lx: ', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_07KAJBENLI@Error?3?5?$AA@
DSOUND_RD	SEGMENT
??_C@_07KAJBENLI@Error?3?5?$AA@ DB 'Error: ', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@ELBNBAPH@Resource?5failure?3?5?$AA@
DSOUND_RD	SEGMENT
??_C@_0BD@ELBNBAPH@Resource?5failure?3?5?$AA@ DB 'Resource failure: ', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_09CKCJCCOK@Warning?3?5?$AA@
DSOUND_RD	SEGMENT
??_C@_09CKCJCCOK@Warning?3?5?$AA@ DB 'Warning: ', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
DSOUND_RD	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z
DSOUND	SEGMENT
tv136 = -2064
_szText$ = -2056
_szDebug$ = -1032
_pszWorking$ = -4
_dwFlags$ = 8
_dwLevel$ = 12
_pszFile$ = 16
_nLine$ = 20
_pszFunction$ = 24
_pszLibrary$ = 28
_pszFormat$ = 32
_va$ = 36
?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z PROC NEAR ; DirectSound::CDebug::PrintStaticV, COMDAT

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 08 00
	00		 sub	 esp, 2064		; 00000810H

; 114  :     CHAR                    szDebug[0x400];
; 115  :     CHAR                    szText[0x400];
; 116  :     LPSTR                   pszWorking;
; 117  :     DWORD                   dwWritten;
; 118  : 
; 119  :     if(dwLevel <= m_dwDpfLevel)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwDpfLevel@CDebug@DirectSound@@2AAKA ; DirectSound::CDebug::m_dwDpfLevel
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR _dwLevel$[ebp]
  00011	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00013	0f 87 b1 01 00
	00		 ja	 $L35584

; 120  :     {
; 121  :         pszWorking = szDebug;

  00019	8d 95 f8 fb ff
	ff		 lea	 edx, DWORD PTR _szDebug$[ebp]
  0001f	89 55 fc	 mov	 DWORD PTR _pszWorking$[ebp], edx

; 122  : 
; 123  : #ifdef DEBUG
; 124  : 
; 125  :         //
; 126  :         // Add the library name
; 127  :         //
; 128  : 
; 129  :         if((dwFlags & DPF_FLAGS_LIBRARY) && pszLibrary && *pszLibrary)

  00022	8b 45 08	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00025	83 e0 01	 and	 eax, 1
  00028	85 c0		 test	 eax, eax
  0002a	74 2d		 je	 SHORT $L35590
  0002c	83 7d 1c 00	 cmp	 DWORD PTR _pszLibrary$[ebp], 0
  00030	74 27		 je	 SHORT $L35590
  00032	8b 4d 1c	 mov	 ecx, DWORD PTR _pszLibrary$[ebp]
  00035	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00038	85 d2		 test	 edx, edx
  0003a	74 1d		 je	 SHORT $L35590

; 130  :         {
; 131  :             pszWorking += sprintf(pszWorking, "%s: ", pszLibrary);

  0003c	8b 45 1c	 mov	 eax, DWORD PTR _pszLibrary$[ebp]
  0003f	50		 push	 eax
  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PFAOODAA@?$CFs?3?5?$AA@
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 _sprintf
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	8b 55 fc	 mov	 edx, DWORD PTR _pszWorking$[ebp]
  00054	03 d0		 add	 edx, eax
  00056	89 55 fc	 mov	 DWORD PTR _pszWorking$[ebp], edx
$L35590:

; 132  :         }
; 133  : 
; 134  :         //
; 135  :         // Add the source file and line number
; 136  :         //
; 137  : 
; 138  :         if((dwFlags & DPF_FLAGS_FILELINE) && pszFile && *pszFile)

  00059	8b 45 08	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  0005c	83 e0 02	 and	 eax, 2
  0005f	85 c0		 test	 eax, eax
  00061	74 31		 je	 SHORT $L35592
  00063	83 7d 10 00	 cmp	 DWORD PTR _pszFile$[ebp], 0
  00067	74 2b		 je	 SHORT $L35592
  00069	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  0006c	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0006f	85 d2		 test	 edx, edx
  00071	74 21		 je	 SHORT $L35592

; 139  :         {
; 140  :             pszWorking += sprintf(pszWorking, "%hs(%lu): ", pszFile, nLine);

  00073	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  00076	50		 push	 eax
  00077	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  0007a	51		 push	 ecx
  0007b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@PAPNLNAE@?$CFhs?$CI?$CFlu?$CJ?3?5?$AA@
  00080	8b 55 fc	 mov	 edx, DWORD PTR _pszWorking$[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 _sprintf
  00089	83 c4 10	 add	 esp, 16			; 00000010H
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  0008f	03 c8		 add	 ecx, eax
  00091	89 4d fc	 mov	 DWORD PTR _pszWorking$[ebp], ecx
$L35592:

; 141  :         }
; 142  : 
; 143  :         //
; 144  :         // Add the function name
; 145  :         //
; 146  : 
; 147  :         if((dwFlags & DPF_FLAGS_FUNCTIONNAME) && pszFunction && *pszFunction)

  00094	8b 55 08	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00097	83 e2 08	 and	 edx, 8
  0009a	85 d2		 test	 edx, edx
  0009c	74 2d		 je	 SHORT $L35594
  0009e	83 7d 18 00	 cmp	 DWORD PTR _pszFunction$[ebp], 0
  000a2	74 27		 je	 SHORT $L35594
  000a4	8b 45 18	 mov	 eax, DWORD PTR _pszFunction$[ebp]
  000a7	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000aa	85 c9		 test	 ecx, ecx
  000ac	74 1d		 je	 SHORT $L35594

; 148  :         {
; 149  :             pszWorking += sprintf(pszWorking, "%hs: ", pszFunction);

  000ae	8b 55 18	 mov	 edx, DWORD PTR _pszFunction$[ebp]
  000b1	52		 push	 edx
  000b2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05HFOMLNMD@?$CFhs?3?5?$AA@
  000b7	8b 45 fc	 mov	 eax, DWORD PTR _pszWorking$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _sprintf
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  000c6	03 c8		 add	 ecx, eax
  000c8	89 4d fc	 mov	 DWORD PTR _pszWorking$[ebp], ecx
$L35594:

; 150  :         }
; 151  : 
; 152  :         //
; 153  :         // Add process and thread id
; 154  :         //
; 155  : 
; 156  :         if(dwFlags & DPF_FLAGS_PROCESSTHREADID)

  000cb	8b 55 08	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  000ce	83 e2 04	 and	 edx, 4
  000d1	85 d2		 test	 edx, edx
  000d3	74 1f		 je	 SHORT $L35596

; 157  :         {
; 158  :             pszWorking += sprintf(pszWorking, "%.8lx: ", GetCurrentThreadId());

  000d5	e8 00 00 00 00	 call	 _GetCurrentThreadId@0
  000da	50		 push	 eax
  000db	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07BCNBNNHO@?$CF?48lx?3?5?$AA@
  000e0	8b 45 fc	 mov	 eax, DWORD PTR _pszWorking$[ebp]
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 _sprintf
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ec	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  000ef	03 c8		 add	 ecx, eax
  000f1	89 4d fc	 mov	 DWORD PTR _pszWorking$[ebp], ecx
$L35596:

; 159  :         }
; 160  : 
; 161  :         //
; 162  :         // Add the type of message it is (i.e. error or warning)
; 163  :         //
; 164  : 
; 165  :         switch(dwLevel)
; 166  :         {

  000f4	8b 55 0c	 mov	 edx, DWORD PTR _dwLevel$[ebp]
  000f7	89 95 f0 f7 ff
	ff		 mov	 DWORD PTR tv136[ebp], edx
  000fd	83 bd f0 f7 ff
	ff 01		 cmp	 DWORD PTR tv136[ebp], 1
  00104	74 14		 je	 SHORT $L35602
  00106	83 bd f0 f7 ff
	ff 02		 cmp	 DWORD PTR tv136[ebp], 2
  0010d	74 1e		 je	 SHORT $L35604
  0010f	83 bd f0 f7 ff
	ff 03		 cmp	 DWORD PTR tv136[ebp], 3
  00116	74 28		 je	 SHORT $L35606
  00118	eb 37		 jmp	 SHORT $L35599
$L35602:

; 167  :             case DPFLVL_ERROR:
; 168  :                 pszWorking = dstrcpy(pszWorking, "Error: ");

  0011a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07KAJBENLI@Error?3?5?$AA@
  0011f	8b 45 fc	 mov	 eax, DWORD PTR _pszWorking$[ebp]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  00128	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax

; 169  :                 break;

  0012b	eb 24		 jmp	 SHORT $L35599
$L35604:

; 170  : 
; 171  :             case DPFLVL_RESOURCE:
; 172  :                 pszWorking = dstrcpy(pszWorking, "Resource failure: ");

  0012d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@ELBNBAPH@Resource?5failure?3?5?$AA@
  00132	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  00135	51		 push	 ecx
  00136	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0013b	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax

; 173  :                 break;

  0013e	eb 11		 jmp	 SHORT $L35599
$L35606:

; 174  : 
; 175  :             case DPFLVL_WARNING:
; 176  :                 pszWorking = dstrcpy(pszWorking, "Warning: ");

  00140	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09CKCJCCOK@Warning?3?5?$AA@
  00145	8b 55 fc	 mov	 edx, DWORD PTR _pszWorking$[ebp]
  00148	52		 push	 edx
  00149	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0014e	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax
$L35599:

; 177  :                 break;
; 178  :         }
; 179  : 
; 180  : #endif // DEBUG
; 181  : 
; 182  :         //
; 183  :         // Add the debug string
; 184  :         //
; 185  : 
; 186  :         vsprintf(szText, pszFormat, va);

  00151	8b 45 24	 mov	 eax, DWORD PTR _va$[ebp]
  00154	50		 push	 eax
  00155	8b 4d 20	 mov	 ecx, DWORD PTR _pszFormat$[ebp]
  00158	51		 push	 ecx
  00159	8d 95 f8 f7 ff
	ff		 lea	 edx, DWORD PTR _szText$[ebp]
  0015f	52		 push	 edx
  00160	e8 00 00 00 00	 call	 _vsprintf
  00165	83 c4 0c	 add	 esp, 12			; 0000000cH

; 187  : 
; 188  : #ifdef DEBUG
; 189  : 
; 190  :         pszWorking = dstrcpy(pszWorking, szText);

  00168	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  0016e	50		 push	 eax
  0016f	8b 4d fc	 mov	 ecx, DWORD PTR _pszWorking$[ebp]
  00172	51		 push	 ecx
  00173	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  00178	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax

; 191  : 
; 192  :         //
; 193  :         // Add a carriage-return since OutputDebugString doesn't
; 194  :         //
; 195  : 
; 196  :         pszWorking = dstrcpy(pszWorking, "\n");

  0017b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00180	8b 55 fc	 mov	 edx, DWORD PTR _pszWorking$[ebp]
  00183	52		 push	 edx
  00184	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  00189	89 45 fc	 mov	 DWORD PTR _pszWorking$[ebp], eax

; 197  : 
; 198  :         //
; 199  :         // Output to the debugger
; 200  :         //
; 201  : 
; 202  :         OutputDebugStringA(szDebug);

  0018c	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _szDebug$[ebp]
  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 _OutputDebugStringA@4

; 203  : 
; 204  :         //
; 205  :         // Break into the debugger
; 206  :         //
; 207  : 
; 208  :         if(dwLevel && (dwLevel <= m_dwDpfBreakLevel))

  00198	83 7d 0c 00	 cmp	 DWORD PTR _dwLevel$[ebp], 0
  0019c	74 12		 je	 SHORT $L35609
  0019e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwDpfBreakLevel@CDebug@DirectSound@@2AAKA ; DirectSound::CDebug::m_dwDpfBreakLevel
  001a4	8b 55 0c	 mov	 edx, DWORD PTR _dwLevel$[ebp]
  001a7	3b 11		 cmp	 edx, DWORD PTR [ecx]
  001a9	77 05		 ja	 SHORT $L35609

; 209  :         {
; 210  :             Break();

  001ab	e8 00 00 00 00	 call	 ?Break@CDebug@DirectSound@@SAXXZ ; DirectSound::CDebug::Break
$L35609:

; 211  :         }
; 212  : 
; 213  : #endif // DEBUG
; 214  : 
; 215  :         //
; 216  :         // Hand off to the callback routine
; 217  :         //
; 218  : 
; 219  :         if(m_pfnDpfCallback)

  001b0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pfnDpfCallback@CDebug@DirectSound@@2P6GXKPBD@ZA, 0 ; DirectSound::CDebug::m_pfnDpfCallback
  001b7	74 11		 je	 SHORT $L35584

; 220  :         {
; 221  :             m_pfnDpfCallback(dwLevel, szText);

  001b9	8d 85 f8 f7 ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  001bf	50		 push	 eax
  001c0	8b 4d 0c	 mov	 ecx, DWORD PTR _dwLevel$[ebp]
  001c3	51		 push	 ecx
  001c4	ff 15 00 00 00
	00		 call	 DWORD PTR ?m_pfnDpfCallback@CDebug@DirectSound@@2P6GXKPBD@ZA ; DirectSound::CDebug::m_pfnDpfCallback
$L35584:

; 222  :         }
; 223  :     }
; 224  : }

  001ca	8b e5		 mov	 esp, ebp
  001cc	5d		 pop	 ebp
  001cd	c3		 ret	 0
?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z ENDP ; DirectSound::CDebug::PrintStaticV
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?dstrcpy@@YGPADPADPBD@Z
DSOUND	SEGMENT
_dst$ = 8
_src$ = 12
?dstrcpy@@YGPADPADPBD@Z PROC NEAR			; dstrcpy, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L35573:

; 68   :     while(*dst = *src)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00009	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000b	88 10		 mov	 BYTE PTR [eax], dl
  0000d	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00010	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00013	85 c9		 test	 ecx, ecx
  00015	74 14		 je	 SHORT $L35574

; 69   :     {
; 70   :         dst++;

  00017	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0001a	83 c2 01	 add	 edx, 1
  0001d	89 55 08	 mov	 DWORD PTR _dst$[ebp], edx

; 71   :         src++;

  00020	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00023	83 c0 01	 add	 eax, 1
  00026	89 45 0c	 mov	 DWORD PTR _src$[ebp], eax

; 72   :     }

  00029	eb d8		 jmp	 SHORT $L35573
$L35574:

; 73   :     
; 74   :     return dst;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]

; 75   : }

  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
?dstrcpy@@YGPADPADPBD@Z ENDP				; dstrcpy
DSOUND	ENDS
PUBLIC	?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ	; DirectSound::CDebug::PrintStatic
; Function compile flags: /Odt
;	COMDAT ?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ
DSOUND	SEGMENT
_va$ = -4
_dwFlags$ = 8
_dwLevel$ = 12
_pszFile$ = 16
_nLine$ = 20
_pszFunction$ = 24
_pszLibrary$ = 28
_pszFormat$ = 32
?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ PROC NEAR ; DirectSound::CDebug::PrintStatic, COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 265  :     va_list                 va;
; 266  : 
; 267  :     va_start(va, pszFormat);

  00004	8d 45 24	 lea	 eax, DWORD PTR _pszFormat$[ebp+4]
  00007	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 268  :     PrintStaticV(dwFlags, dwLevel, pszFile, nLine, pszFunction, pszLibrary, pszFormat, va);

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 20	 mov	 edx, DWORD PTR _pszFormat$[ebp]
  00011	52		 push	 edx
  00012	8b 45 1c	 mov	 eax, DWORD PTR _pszLibrary$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 18	 mov	 ecx, DWORD PTR _pszFunction$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 14	 mov	 edx, DWORD PTR _nLine$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 10	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _dwLevel$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 08	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z ; DirectSound::CDebug::PrintStaticV
  0002f	83 c4 20	 add	 esp, 32			; 00000020H

; 269  :     va_end(va);

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 270  : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?PrintStatic@CDebug@DirectSound@@SAXKKPBDI000ZZ ENDP	; DirectSound::CDebug::PrintStatic
DSOUND	ENDS
PUBLIC	?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z	; DirectSound::CDebug::SetContext
; Function compile flags: /Odt
;	COMDAT ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z
DSOUND	SEGMENT
_irql$ = -1
_dwFlags$ = 8
_dwLevel$ = 12
_pszFile$ = 16
_nLine$ = 20
_pszFunction$ = 24
_pszLibrary$ = 28
?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z PROC NEAR	; DirectSound::CDebug::SetContext, COMDAT

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 307  : 
; 308  : #ifdef _XBOX
; 309  : 
; 310  :     const KIRQL             irql    = KeGetCurrentIrql();

  00004	e8 00 00 00 00	 call	 _KeGetCurrentIrql@0
  00009	88 45 ff	 mov	 BYTE PTR _irql$[ebp], al

; 311  : 
; 312  : #else // _XBOX
; 313  : 
; 314  :     static const UINT       irql    = 0;
; 315  : 
; 316  : #endif // _XBOX
; 317  : 
; 318  :     m_aContext[irql].dwFlags = dwFlags;

  0000c	0f b6 45 ff	 movzx	 eax, BYTE PTR _irql$[ebp]
  00010	6b c0 18	 imul	 eax, 24			; 00000018H
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00016	89 88 00 00 00
	00		 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A[eax], ecx

; 319  :     m_aContext[irql].dwLevel = dwLevel;

  0001c	0f b6 55 ff	 movzx	 edx, BYTE PTR _irql$[ebp]
  00020	6b d2 18	 imul	 edx, 24			; 00000018H
  00023	8b 45 0c	 mov	 eax, DWORD PTR _dwLevel$[ebp]
  00026	89 82 04 00 00
	00		 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A[edx+4], eax

; 320  :     m_aContext[irql].pszFile = pszFile;

  0002c	0f b6 4d ff	 movzx	 ecx, BYTE PTR _irql$[ebp]
  00030	6b c9 18	 imul	 ecx, 24			; 00000018H
  00033	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  00036	89 91 08 00 00
	00		 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A[ecx+8], edx

; 321  :     m_aContext[irql].nLine = nLine;

  0003c	0f b6 45 ff	 movzx	 eax, BYTE PTR _irql$[ebp]
  00040	6b c0 18	 imul	 eax, 24			; 00000018H
  00043	8b 4d 14	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00046	89 88 0c 00 00
	00		 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A[eax+12], ecx

; 322  :     m_aContext[irql].pszFunction = pszFunction;

  0004c	0f b6 55 ff	 movzx	 edx, BYTE PTR _irql$[ebp]
  00050	6b d2 18	 imul	 edx, 24			; 00000018H
  00053	8b 45 18	 mov	 eax, DWORD PTR _pszFunction$[ebp]
  00056	89 82 10 00 00
	00		 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A[edx+16], eax

; 323  :     m_aContext[irql].pszLibrary = pszLibrary;

  0005c	0f b6 4d ff	 movzx	 ecx, BYTE PTR _irql$[ebp]
  00060	6b c9 18	 imul	 ecx, 24			; 00000018H
  00063	8b 55 1c	 mov	 edx, DWORD PTR _pszLibrary$[ebp]
  00066	89 91 14 00 00
	00		 mov	 DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A[ecx+20], edx

; 324  : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ENDP	; DirectSound::CDebug::SetContext
; Function compile flags: /Odt
; File c:\xbox\private\ntos\inc\i386.h
DSOUND	ENDS
;	COMDAT _KeGetCurrentIrql@0
DSOUND	SEGMENT
_KeGetCurrentIrql@0 PROC NEAR				; COMDAT

; 1496 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1497 : #if defined(_NTSYSTEM_)
; 1498 :     return KeGetPcr()->Irql;
; 1499 : #else
; 1500 :     __asm {  movzx eax, byte ptr fs:[0] KPCR.Irql }

  00003	64 0f b6 05 24
	00 00 00	 movzx	 eax, BYTE PTR fs:36

; 1501 : #endif
; 1502 : }    

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_KeGetCurrentIrql@0 ENDP
DSOUND	ENDS
PUBLIC	?Print@CDebug@DirectSound@@SAXPBDZZ		; DirectSound::CDebug::Print
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\debug.cpp
;	COMDAT ?Print@CDebug@DirectSound@@SAXPBDZZ
DSOUND	SEGMENT
_va$ = -8
_irql$ = -1
_pszFormat$ = 8
?Print@CDebug@DirectSound@@SAXPBDZZ PROC NEAR		; DirectSound::CDebug::Print, COMDAT

; 353  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 354  : 
; 355  : #ifdef _XBOX
; 356  : 
; 357  :     const KIRQL             irql    = KeGetCurrentIrql();

  00006	e8 00 00 00 00	 call	 _KeGetCurrentIrql@0
  0000b	88 45 ff	 mov	 BYTE PTR _irql$[ebp], al

; 358  : 
; 359  : #else // _XBOX
; 360  : 
; 361  :     static const UINT       irql    = 0;
; 362  : 
; 363  : #endif // _XBOX
; 364  : 
; 365  :     va_list                 va;
; 366  : 
; 367  :     va_start(va, pszFormat);

  0000e	8d 45 0c	 lea	 eax, DWORD PTR _pszFormat$[ebp+4]
  00011	89 45 f8	 mov	 DWORD PTR _va$[ebp], eax

; 368  :     PrintStaticV(m_aContext[irql].dwFlags, m_aContext[irql].dwLevel, m_aContext[irql].pszFile, m_aContext[irql].nLine, m_aContext[irql].pszFunction, m_aContext[irql].pszLibrary, pszFormat, va);

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _va$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 08	 mov	 edx, DWORD PTR _pszFormat$[ebp]
  0001b	52		 push	 edx
  0001c	0f b6 45 ff	 movzx	 eax, BYTE PTR _irql$[ebp]
  00020	6b c0 18	 imul	 eax, 24			; 00000018H
  00023	8b 88 14 00 00
	00		 mov	 ecx, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A[eax+20]
  00029	51		 push	 ecx
  0002a	0f b6 55 ff	 movzx	 edx, BYTE PTR _irql$[ebp]
  0002e	6b d2 18	 imul	 edx, 24			; 00000018H
  00031	8b 82 10 00 00
	00		 mov	 eax, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A[edx+16]
  00037	50		 push	 eax
  00038	0f b6 4d ff	 movzx	 ecx, BYTE PTR _irql$[ebp]
  0003c	6b c9 18	 imul	 ecx, 24			; 00000018H
  0003f	8b 91 0c 00 00
	00		 mov	 edx, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A[ecx+12]
  00045	52		 push	 edx
  00046	0f b6 45 ff	 movzx	 eax, BYTE PTR _irql$[ebp]
  0004a	6b c0 18	 imul	 eax, 24			; 00000018H
  0004d	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A[eax+8]
  00053	51		 push	 ecx
  00054	0f b6 55 ff	 movzx	 edx, BYTE PTR _irql$[ebp]
  00058	6b d2 18	 imul	 edx, 24			; 00000018H
  0005b	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A[edx+4]
  00061	50		 push	 eax
  00062	0f b6 4d ff	 movzx	 ecx, BYTE PTR _irql$[ebp]
  00066	6b c9 18	 imul	 ecx, 24			; 00000018H
  00069	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?m_aContext@CDebug@DirectSound@@1PAUDPFCONTEXT@@A[ecx]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 ?PrintStaticV@CDebug@DirectSound@@SAXKKPBDI000PAD@Z ; DirectSound::CDebug::PrintStaticV
  00075	83 c4 20	 add	 esp, 32			; 00000020H

; 369  :     va_end(va);

  00078	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 370  : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?Print@CDebug@DirectSound@@SAXPBDZZ ENDP		; DirectSound::CDebug::Print
DSOUND	ENDS
PUBLIC	?Assert@CDebug@DirectSound@@SAXHPBD0I@Z		; DirectSound::CDebug::Assert
PUBLIC	??_C@_0EP@LPAKAOHB@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ ; `string'
PUBLIC	??_C@_0BF@DPPFGDJL@Assertion?5failed?5in?5?$AA@	; `string'
PUBLIC	??_C@_07BAMMBJFH@?0?5line?5?$AA@		; `string'
PUBLIC	??_C@_02NDKNKOCB@?3?6?$AA@			; `string'
EXTRN	__itoa:NEAR
EXTRN	_strlen:NEAR
;	COMDAT ?pszBanner@?1??Assert@CDebug@DirectSound@@SAXHPBD0I@Z@4QBDB
DSOUND_RD	SEGMENT
?pszBanner@?1??Assert@CDebug@DirectSound@@SAXHPBD0I@Z@4QBDB DD FLAT:??_C@_0EP@LPAKAOHB@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ ; `DirectSound::CDebug::Assert'::`2'::pszBanner
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BF@DPPFGDJL@Assertion?5failed?5in?5?$AA@
DSOUND_RD	SEGMENT
??_C@_0BF@DPPFGDJL@Assertion?5failed?5in?5?$AA@ DB 'Assertion failed in ', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_07BAMMBJFH@?0?5line?5?$AA@
DSOUND_RD	SEGMENT
??_C@_07BAMMBJFH@?0?5line?5?$AA@ DB ', line ', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_02NDKNKOCB@?3?6?$AA@
DSOUND_RD	SEGMENT
??_C@_02NDKNKOCB@?3?6?$AA@ DB ':', 0aH, 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0EP@LPAKAOHB@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
DSOUND_RD	SEGMENT
??_C@_0EP@LPAKAOHB@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ DB '*'
	DB	'*************************************************************'
	DB	'****************', 00H			; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z
DSOUND	SEGMENT
_szMessage$ = -1032
_pszMessage$ = -4
_fAssert$ = 8
_pszExpression$ = 12
_pszFile$ = 16
_nLine$ = 20
?Assert@CDebug@DirectSound@@SAXHPBD0I@Z PROC NEAR	; DirectSound::CDebug::Assert, COMDAT

; 403  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H

; 404  :     static const LPCSTR     pszBanner           = "******************************************************************************";
; 405  :     CHAR                    szMessage[0x400];
; 406  :     LPSTR                   pszMessage;
; 407  : 
; 408  :     if(fAssert)

  00009	83 7d 08 00	 cmp	 DWORD PTR _fAssert$[ebp], 0
  0000d	0f 84 ec 00 00
	00		 je	 $L35650

; 409  :     {
; 410  :         pszMessage = szMessage;

  00013	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _szMessage$[ebp]
  00019	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 411  : 
; 412  :         pszMessage = dstrcpy(pszMessage, pszBanner);

  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??Assert@CDebug@DirectSound@@SAXHPBD0I@Z@4QBDB
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0002c	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 413  :         pszMessage = dstrcpy(pszMessage, "\n");

  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00034	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0003d	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 414  :         pszMessage = dstrcpy(pszMessage, "Assertion failed in ");

  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@DPPFGDJL@Assertion?5failed?5in?5?$AA@
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _pszMessage$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0004e	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 415  :         pszMessage = dstrcpy(pszMessage, pszFile);

  00051	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  00054	52		 push	 edx
  00055	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0005e	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 416  :         pszMessage = dstrcpy(pszMessage, ", line ");

  00061	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07BAMMBJFH@?0?5line?5?$AA@
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _pszMessage$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  0006f	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 417  :     
; 418  :         _itoa(nLine, pszMessage, 10);

  00072	6a 0a		 push	 10			; 0000000aH
  00074	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  00077	52		 push	 edx
  00078	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 __itoa
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 419  :         pszMessage += strlen(pszMessage);

  00084	8b 4d fc	 mov	 ecx, DWORD PTR _pszMessage$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _strlen
  0008d	83 c4 04	 add	 esp, 4
  00090	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  00093	03 d0		 add	 edx, eax
  00095	89 55 fc	 mov	 DWORD PTR _pszMessage$[ebp], edx

; 420  : 
; 421  :         pszMessage = dstrcpy(pszMessage, ":\n");

  00098	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02NDKNKOCB@?3?6?$AA@
  0009d	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000a6	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 422  :         pszMessage = dstrcpy(pszMessage, pszExpression);

  000a9	8b 4d 0c	 mov	 ecx, DWORD PTR _pszExpression$[ebp]
  000ac	51		 push	 ecx
  000ad	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  000b0	52		 push	 edx
  000b1	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000b6	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 423  :         pszMessage = dstrcpy(pszMessage, "\n");

  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  000be	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000c7	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 424  :         pszMessage = dstrcpy(pszMessage, pszBanner);

  000ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??Assert@CDebug@DirectSound@@SAXHPBD0I@Z@4QBDB
  000d0	51		 push	 ecx
  000d1	8b 55 fc	 mov	 edx, DWORD PTR _pszMessage$[ebp]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000da	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 425  :         pszMessage = dstrcpy(pszMessage, "\n");

  000dd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  000e2	8b 45 fc	 mov	 eax, DWORD PTR _pszMessage$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?dstrcpy@@YGPADPADPBD@Z	; dstrcpy
  000eb	89 45 fc	 mov	 DWORD PTR _pszMessage$[ebp], eax

; 426  : 
; 427  :         OutputDebugStringA(szMessage);

  000ee	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _szMessage$[ebp]
  000f4	51		 push	 ecx
  000f5	e8 00 00 00 00	 call	 _OutputDebugStringA@4

; 428  :         Break();

  000fa	e8 00 00 00 00	 call	 ?Break@CDebug@DirectSound@@SAXXZ ; DirectSound::CDebug::Break
$L35650:

; 429  :     }
; 430  : }

  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ENDP		; DirectSound::CDebug::Assert
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?Break@CDebug@DirectSound@@SAXXZ
DSOUND	SEGMENT
?Break@CDebug@DirectSound@@SAXXZ PROC NEAR		; DirectSound::CDebug::Break, COMDAT

; 457  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 458  :     //
; 459  :     // Break in the debugger
; 460  :     //
; 461  :     
; 462  :     __asm int 3;

  00003	cc		 int	 3

; 463  : 
; 464  : #ifdef _XBOX
; 465  : 
; 466  :     //
; 467  :     // If we're at DISPATCH_LEVEL or higher, the VC debugger won't catch
; 468  :     // the break.
; 469  :     //
; 470  :     
; 471  :     if(KeGetCurrentIrql() >= DISPATCH_LEVEL)

  00004	e8 00 00 00 00	 call	 _KeGetCurrentIrql@0
  00009	0f b6 c0	 movzx	 eax, al
  0000c	83 f8 02	 cmp	 eax, 2
  0000f	7c 0c		 jl	 SHORT $L35662

; 472  :     {
; 473  :         m_fDebugBreak = TRUE;

  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_fDebugBreak@CDebug@DirectSound@@2AAHA ; DirectSound::CDebug::m_fDebugBreak
  00017	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1
$L35662:

; 474  :     }
; 475  : 
; 476  : #endif // _XBOX
; 477  : 
; 478  : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?Break@CDebug@DirectSound@@SAXXZ ENDP			; DirectSound::CDebug::Break
DSOUND	ENDS
EXTRN	_g_dwDirectSoundPoolMemoryUsage:DWORD
CRT$XCU	SEGMENT
_$S8	DD	FLAT:_$E7
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\memmgr.cpp
CRT$XCU	ENDS
;	COMDAT _$E7
DSOUND	SEGMENT
_$E7	PROC NEAR					; COMDAT

; 20   : DWORD &CMemoryManager::m_dwPoolMemoryUsage = g_dwDirectSoundPoolMemoryUsage;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2AAKA, OFFSET FLAT:_g_dwDirectSoundPoolMemoryUsage ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_$E7	ENDP
DSOUND	ENDS
EXTRN	_g_dwDirectSoundPhysicalMemoryUsage:DWORD
CRT$XCU	SEGMENT
_$S10	DD	FLAT:_$E9
; Function compile flags: /Odt
CRT$XCU	ENDS
;	COMDAT _$E9
DSOUND	SEGMENT
_$E9	PROC NEAR					; COMDAT

; 21   : DWORD &CMemoryManager::m_dwPhysicalMemoryUsage = g_dwDirectSoundPhysicalMemoryUsage;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2AAKA, OFFSET FLAT:_g_dwDirectSoundPhysicalMemoryUsage ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_$E9	ENDP
DSOUND	ENDS
PUBLIC	?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::PoolAlloc
PUBLIC	??_C@_06JAKMBBHB@DSOUND?$AA@			; `string'
PUBLIC	??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_08DNIHDBFJ@cbBuffer?$AA@			; `string'
PUBLIC	??_C@_0BK@BFDMGCLI@CMemoryManager?3?3PoolAlloc?$AA@ ; `string'
PUBLIC	??_C@_0BD@EKDKBHPJ@Out?5of?5pool?5memory?$AA@	; `string'
EXTRN	__imp__ExAllocatePoolWithTag@8:NEAR
EXTRN	__imp__ExQueryPoolBlockSize@4:NEAR
EXTRN	_memset:NEAR
;	COMDAT ??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT
??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\common\memmgr.cpp', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_08DNIHDBFJ@cbBuffer?$AA@
DSOUND_RD	SEGMENT
??_C@_08DNIHDBFJ@cbBuffer?$AA@ DB 'cbBuffer', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_06JAKMBBHB@DSOUND?$AA@
DSOUND_RD	SEGMENT
??_C@_06JAKMBBHB@DSOUND?$AA@ DB 'DSOUND', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@BFDMGCLI@CMemoryManager?3?3PoolAlloc?$AA@
DSOUND_RD	SEGMENT
??_C@_0BK@BFDMGCLI@CMemoryManager?3?3PoolAlloc?$AA@ DB 'CMemoryManager::P'
	DB	'oolAlloc', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@EKDKBHPJ@Out?5of?5pool?5memory?$AA@
DSOUND_RD	SEGMENT
??_C@_0BD@EKDKBHPJ@Out?5of?5pool?5memory?$AA@ DB 'Out of pool memory', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT
_pvBuffer$ = -4
_nPoolTag$ = 8
_cbBuffer$ = 12
_fZeroInit$ = 16
?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z PROC NEAR ; DirectSound::CMemoryManager::PoolAlloc, COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 65   :     static const ULONG      cbLowerThreshold    = 0x20;
; 66   :     static const DWORD      cbUpperThreshold    = 0xFD8;
; 67   :     LPVOID                  pvBuffer;
; 68   : 
; 69   :     ASSERT(cbBuffer);

  00004	6a 45		 push	 69			; 00000045H
  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08DNIHDBFJ@cbBuffer?$AA@
  00010	33 c0		 xor	 eax, eax
  00012	83 7d 0c 00	 cmp	 DWORD PTR _cbBuffer$[ebp], 0
  00016	0f 94 c0	 sete	 al
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0001f	83 c4 10	 add	 esp, 16			; 00000010H

; 70   : 
; 71   : #ifdef _XBOX
; 72   : 
; 73   : #ifdef MEM_SIZE_CHECK
; 74   : 
; 75   : #pragma TODO("Don't ship with this check turned on")
; 76   :     
; 77   :     if((DSOUND_OBJECT_POOL_TAG == nPoolTag) && (cbBuffer >= cbUpperThreshold))
; 78   :     {
; 79   :         ASSERTMSG("Allocating an object larger than the pool threshold");
; 80   :     }
; 81   :     else if((DSOUND_DATA_POOL_TAG == nPoolTag) && (cbBuffer < cbLowerThreshold))
; 82   :     {
; 83   :         ASSERTMSG("Allocating a buffer smaller than 32 bytes");
; 84   :     }
; 85   : 
; 86   : #endif // _MEM_SIZE_CHECK
; 87   : 
; 88   :     if(pvBuffer = ExAllocatePoolWithTag(cbBuffer, nPoolTag))

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _nPoolTag$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 0c	 mov	 edx, DWORD PTR _cbBuffer$[ebp]
  00029	52		 push	 edx
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@8
  00030	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  00033	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00037	74 39		 je	 SHORT $L35683

; 89   :     {
; 90   :         cbBuffer = ExQueryPoolBlockSize(pvBuffer);

  00039	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExQueryPoolBlockSize@4
  00043	89 45 0c	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 91   :         m_dwPoolMemoryUsage += cbBuffer;

  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	03 55 0c	 add	 edx, DWORD PTR _cbBuffer$[ebp]
  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  00056	89 10		 mov	 DWORD PTR [eax], edx

; 92   : 
; 93   :         if(fZeroInit)

  00058	83 7d 10 00	 cmp	 DWORD PTR _fZeroInit$[ebp], 0
  0005c	74 12		 je	 SHORT $L35684

; 94   :         {
; 95   :             ZeroMemory(pvBuffer, cbBuffer);

  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00061	51		 push	 ecx
  00062	6a 00		 push	 0
  00064	8b 55 fc	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 _memset
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L35684:

; 96   :         }
; 97   :     }
; 98   : 
; 99   : #else // _XBOX
; 100  : 
; 101  :     if(pvBuffer = LocalAlloc(fZeroInit ? LPTR : LMEM_FIXED, cbBuffer))
; 102  :     {
; 103  :         cbBuffer = LocalSize(pvBuffer);
; 104  :         m_dwPoolMemoryUsage += cbBuffer;
; 105  :     }
; 106  : 
; 107  : #endif // _XBOX
; 108  : 
; 109  :     else

  00070	eb 2a		 jmp	 SHORT $L35685
$L35683:

; 110  :     {
; 111  :         DPF_RESOURCE("Out of pool memory");

  00072	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@BFDMGCLI@CMemoryManager?3?3PoolAlloc?$AA@
  0007c	6a 6f		 push	 111			; 0000006fH
  0007e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  00083	6a 02		 push	 2
  00085	6a 09		 push	 9
  00087	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0008c	83 c4 18	 add	 esp, 24			; 00000018H
  0008f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@EKDKBHPJ@Out?5of?5pool?5memory?$AA@
  00094	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00099	83 c4 04	 add	 esp, 4
$L35685:

; 112  :     }
; 113  : 
; 114  :     return pvBuffer;

  0009c	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 115  : }

  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 0c 00	 ret	 12			; 0000000cH
?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ENDP ; DirectSound::CMemoryManager::PoolAlloc
DSOUND	ENDS
PUBLIC	?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z	; DirectSound::CMemoryManager::PoolFree
PUBLIC	??_C@_08FADLHADM@pvBuffer?$AA@			; `string'
PUBLIC	??_C@_0CA@LBPCLHHJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@ ; `string'
EXTRN	__imp__ExFreePool@4:NEAR
;	COMDAT ??_C@_08FADLHADM@pvBuffer?$AA@
DSOUND_RD	SEGMENT
??_C@_08FADLHADM@pvBuffer?$AA@ DB 'pvBuffer', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@LBPCLHHJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@
DSOUND_RD	SEGMENT
??_C@_0CA@LBPCLHHJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@ DB 'm_dwP'
	DB	'oolMemoryUsage >= cbBuffer', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT
_cbBuffer$ = -4
_pvBuffer$ = 8
?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::PoolFree, COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 142  :     DWORD                   cbBuffer;
; 143  : 
; 144  :     ASSERT(pvBuffer);

  00004	68 90 00 00 00	 push	 144			; 00000090H
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08FADLHADM@pvBuffer?$AA@
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 08 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 145  : 
; 146  : #ifdef _XBOX
; 147  : 
; 148  :     cbBuffer = ExQueryPoolBlockSize(pvBuffer);

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00028	51		 push	 ecx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExQueryPoolBlockSize@4
  0002f	89 45 fc	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 149  : 
; 150  :     ASSERT(m_dwPoolMemoryUsage >= cbBuffer);

  00032	68 96 00 00 00	 push	 150			; 00000096H
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@LBPCLHHJ@m_dwPoolMemoryUsage?5?$DO?$DN?5cbBuffer?$AA@
  00041	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  00047	8b 02		 mov	 eax, DWORD PTR [edx]
  00049	3b 45 fc	 cmp	 eax, DWORD PTR _cbBuffer$[ebp]
  0004c	1b c9		 sbb	 ecx, ecx
  0004e	f7 d9		 neg	 ecx
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00056	83 c4 10	 add	 esp, 16			; 00000010H

; 151  :     m_dwPoolMemoryUsage -= cbBuffer;

  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	2b 45 fc	 sub	 eax, DWORD PTR _cbBuffer$[ebp]
  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  0006a	89 01		 mov	 DWORD PTR [ecx], eax

; 152  : 
; 153  :     ExFreePool(pvBuffer);

  0006c	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  0006f	52		 push	 edx
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 154  : 
; 155  : #else // _XBOX
; 156  : 
; 157  :     cbBuffer = LocalSize(pvBuffer);
; 158  : 
; 159  :     ASSERT(m_dwPoolMemoryUsage >= cbBuffer);
; 160  :     m_dwPoolMemoryUsage -= cbBuffer;
; 161  : 
; 162  :     LocalFree(pvBuffer);
; 163  : 
; 164  : #endif // _XBOX
; 165  : 
; 166  : }

  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c2 04 00	 ret	 4
?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP	; DirectSound::CMemoryManager::PoolFree
DSOUND	ENDS
PUBLIC	?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z ; DirectSound::CMemoryManager::PhysicalAlloc
PUBLIC	??_C@_07KIGAHELJ@dwFlags?$AA@			; `string'
PUBLIC	??_C@_0BO@GNDANLGM@CMemoryManager?3?3PhysicalAlloc?$AA@ ; `string'
PUBLIC	??_C@_0BJ@BGANBOHC@Out?5of?5contiguous?5memory?$AA@ ; `string'
EXTRN	__imp__MmAllocateContiguousMemoryEx@20:NEAR
EXTRN	__imp__MmQueryAllocationSize@4:NEAR
;	COMDAT ??_C@_07KIGAHELJ@dwFlags?$AA@
DSOUND_RD	SEGMENT
??_C@_07KIGAHELJ@dwFlags?$AA@ DB 'dwFlags', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@GNDANLGM@CMemoryManager?3?3PhysicalAlloc?$AA@
DSOUND_RD	SEGMENT
??_C@_0BO@GNDANLGM@CMemoryManager?3?3PhysicalAlloc?$AA@ DB 'CMemoryManage'
	DB	'r::PhysicalAlloc', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@BGANBOHC@Out?5of?5contiguous?5memory?$AA@
DSOUND_RD	SEGMENT
??_C@_0BJ@BGANBOHC@Out?5of?5contiguous?5memory?$AA@ DB 'Out of contiguous'
	DB	' memory', 00H				; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z
DSOUND	SEGMENT
_pvBuffer$ = -4
_cbBuffer$ = 8
_cbAlignment$ = 12
_dwFlags$ = 16
_fZeroInit$ = 20
?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z PROC NEAR ; DirectSound::CMemoryManager::PhysicalAlloc, COMDAT

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 199  :     LPVOID                  pvBuffer;
; 200  : 
; 201  :     ASSERT(cbBuffer);

  00004	68 c9 00 00 00	 push	 201			; 000000c9H
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08DNIHDBFJ@cbBuffer?$AA@
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 08 00	 cmp	 DWORD PTR _cbBuffer$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 202  :     ASSERT(dwFlags);

  00025	68 ca 00 00 00	 push	 202			; 000000caH
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07KIGAHELJ@dwFlags?$AA@
  00034	33 c9		 xor	 ecx, ecx
  00036	83 7d 10 00	 cmp	 DWORD PTR _dwFlags$[ebp], 0
  0003a	0f 94 c1	 sete	 cl
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00043	83 c4 10	 add	 esp, 16			; 00000010H

; 203  :     
; 204  : #ifdef _XBOX
; 205  : 
; 206  :     if(pvBuffer = MmAllocateContiguousMemoryEx(cbBuffer, 0, 0xFFFFFFFF, cbAlignment, dwFlags))

  00046	8b 55 10	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00049	52		 push	 edx
  0004a	8b 45 0c	 mov	 eax, DWORD PTR _cbAlignment$[ebp]
  0004d	50		 push	 eax
  0004e	6a ff		 push	 -1
  00050	6a 00		 push	 0
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00055	51		 push	 ecx
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmAllocateContiguousMemoryEx@20
  0005c	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  0005f	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00063	74 39		 je	 SHORT $L35702

; 207  :     {
; 208  :         cbBuffer = MmQueryAllocationSize(pvBuffer);

  00065	8b 55 fc	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00068	52		 push	 edx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmQueryAllocationSize@4
  0006f	89 45 08	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 209  :         m_dwPhysicalMemoryUsage += cbBuffer;

  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
  00077	8b 08		 mov	 ecx, DWORD PTR [eax]
  00079	03 4d 08	 add	 ecx, DWORD PTR _cbBuffer$[ebp]
  0007c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
  00082	89 0a		 mov	 DWORD PTR [edx], ecx

; 210  : 
; 211  :         if(fZeroInit)

  00084	83 7d 14 00	 cmp	 DWORD PTR _fZeroInit$[ebp], 0
  00088	74 12		 je	 SHORT $L35703

; 212  :         {
; 213  :             ZeroMemory(pvBuffer, cbBuffer);

  0008a	8b 45 08	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  0008d	50		 push	 eax
  0008e	6a 00		 push	 0
  00090	8b 4d fc	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _memset
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
$L35703:

; 214  :         }
; 215  :     }
; 216  : 
; 217  : #else // _XBOX
; 218  : 
; 219  :     if(pvBuffer = VirtualAlloc(NULL, cbBuffer, MEM_COMMIT, dwFlags))
; 220  :     {
; 221  : 
; 222  : #pragma TODO("Not able to query for size of VirtualAlloc'd buffer")
; 223  : 
; 224  :         if(fZeroInit)
; 225  :         {
; 226  :             ZeroMemory(pvBuffer, cbBuffer);
; 227  :         }
; 228  :     }
; 229  : 
; 230  : #endif // _XBOX
; 231  : 
; 232  :     else

  0009c	eb 2d		 jmp	 SHORT $L35704
$L35702:

; 233  :     {
; 234  :         DPF_RESOURCE("Out of contiguous memory");

  0009e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  000a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@GNDANLGM@CMemoryManager?3?3PhysicalAlloc?$AA@
  000a8	68 ea 00 00 00	 push	 234			; 000000eaH
  000ad	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  000b2	6a 02		 push	 2
  000b4	6a 09		 push	 9
  000b6	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000bb	83 c4 18	 add	 esp, 24			; 00000018H
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@BGANBOHC@Out?5of?5contiguous?5memory?$AA@
  000c3	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000c8	83 c4 04	 add	 esp, 4
$L35704:

; 235  :     }
; 236  : 
; 237  :     return pvBuffer;

  000cb	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 238  : }

  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c2 10 00	 ret	 16			; 00000010H
?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z ENDP ; DirectSound::CMemoryManager::PhysicalAlloc
DSOUND	ENDS
PUBLIC	?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PhysicalFree
PUBLIC	??_C@_0CE@EHAFMALM@m_dwPhysicalMemoryUsage?5?$DO?$DN?5cbBuf@ ; `string'
EXTRN	__imp__MmFreeContiguousMemory@4:NEAR
;	COMDAT ??_C@_0CE@EHAFMALM@m_dwPhysicalMemoryUsage?5?$DO?$DN?5cbBuf@
DSOUND_RD	SEGMENT
??_C@_0CE@EHAFMALM@m_dwPhysicalMemoryUsage?5?$DO?$DN?5cbBuf@ DB 'm_dwPhys'
	DB	'icalMemoryUsage >= cbBuffer', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT
_cbBuffer$ = -4
_pvBuffer$ = 8
?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::PhysicalFree, COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 265  :     DWORD                   cbBuffer;
; 266  : 
; 267  :     ASSERT(pvBuffer);

  00004	68 0b 01 00 00	 push	 267			; 0000010bH
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08FADLHADM@pvBuffer?$AA@
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 08 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 268  : 
; 269  : #ifdef _XBOX
; 270  : 
; 271  :     cbBuffer = MmQueryAllocationSize(pvBuffer);

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00028	51		 push	 ecx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmQueryAllocationSize@4
  0002f	89 45 fc	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 272  : 
; 273  :     ASSERT(m_dwPhysicalMemoryUsage >= cbBuffer);

  00032	68 11 01 00 00	 push	 273			; 00000111H
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@EHAFMALM@m_dwPhysicalMemoryUsage?5?$DO?$DN?5cbBuf@
  00041	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
  00047	8b 02		 mov	 eax, DWORD PTR [edx]
  00049	3b 45 fc	 cmp	 eax, DWORD PTR _cbBuffer$[ebp]
  0004c	1b c9		 sbb	 ecx, ecx
  0004e	f7 d9		 neg	 ecx
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00056	83 c4 10	 add	 esp, 16			; 00000010H

; 274  :     m_dwPhysicalMemoryUsage -= cbBuffer;

  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	2b 45 fc	 sub	 eax, DWORD PTR _cbBuffer$[ebp]
  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
  0006a	89 01		 mov	 DWORD PTR [ecx], eax

; 275  : 
; 276  :     MmFreeContiguousMemory(pvBuffer);

  0006c	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  0006f	52		 push	 edx
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmFreeContiguousMemory@4

; 277  : 
; 278  : #else // _XBOX
; 279  : 
; 280  : #pragma TODO("Not able to query for size of VirtualAlloc'd buffer")
; 281  : 
; 282  :     VirtualFree(pvBuffer, 0, MEM_RELEASE);
; 283  : 
; 284  : #endif // _XBOX
; 285  : 
; 286  : }

  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c2 04 00	 ret	 4
?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP	; DirectSound::CMemoryManager::PhysicalFree
DSOUND	ENDS
PUBLIC	?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::MemAlloc
PUBLIC	??_C@_0DC@OLMEENNO@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5?$CK?$CI?$CILPDW@ ; `string'
EXTRN	?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A:DWORD ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap
EXTRN	?Alloc@CMcpxSlopMemoryHeap@DirectSound@@QAEPAXK@Z:NEAR ; DirectSound::CMcpxSlopMemoryHeap::Alloc
;	COMDAT ??_C@_0DC@OLMEENNO@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5?$CK?$CI?$CILPDW@
DSOUND_RD	SEGMENT
??_C@_0DC@OLMEENNO@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5?$CK?$CI?$CILPDW@ DB 'D'
	DB	'SOUND_ALLOCATOR_SLOP == *((LPDWORD)pvBuffer - 1)', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT
_pvBuffer$ = -4
_nPoolTag$ = 8
_cbBuffer$ = 12
_fZeroInit$ = 16
?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z PROC NEAR ; DirectSound::CMemoryManager::MemAlloc, COMDAT

; 318  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 319  :     static const ULONG      cbLowerThreshold    = 0x20;
; 320  :     static const DWORD      cbUpperThreshold    = 0xFD8;
; 321  :     LPVOID                  pvBuffer;
; 322  : 
; 323  :     ASSERT(cbBuffer);

  00004	68 43 01 00 00	 push	 323			; 00000143H
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08DNIHDBFJ@cbBuffer?$AA@
  00013	33 c0		 xor	 eax, eax
  00015	83 7d 0c 00	 cmp	 DWORD PTR _cbBuffer$[ebp], 0
  00019	0f 94 c0	 sete	 al
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 324  : 
; 325  : #ifdef MEM_SIZE_CHECK
; 326  : 
; 327  : #pragma TODO("Don't ship with this check turned on")
; 328  :     
; 329  :     if((DSOUND_OBJECT_POOL_TAG == nPoolTag) && (cbBuffer >= cbUpperThreshold))
; 330  :     {
; 331  :         ASSERTMSG("Allocating an object larger than the pool threshold");
; 332  :     }
; 333  :     else if((DSOUND_DATA_POOL_TAG == nPoolTag) && (cbBuffer < cbLowerThreshold))
; 334  :     {
; 335  :         ASSERTMSG("Allocating a buffer smaller than 32 bytes");
; 336  :     }
; 337  : 
; 338  : #endif // MEM_SIZE_CHECK
; 339  : 
; 340  :     if(CMcpxSlopMemoryHeap::m_pSlopMemoryHeap)

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A, 0 ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap
  0002c	74 59		 je	 SHORT $L35722

; 341  :     {
; 342  :         if(pvBuffer = CMcpxSlopMemoryHeap::m_pSlopMemoryHeap->Alloc(cbBuffer))

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00031	51		 push	 ecx
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap
  00038	e8 00 00 00 00	 call	 ?Alloc@CMcpxSlopMemoryHeap@DirectSound@@QAEPAXK@Z ; DirectSound::CMcpxSlopMemoryHeap::Alloc
  0003d	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  00040	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00044	74 3f		 je	 SHORT $L35723

; 343  :         {
; 344  :             ASSERT(DSOUND_ALLOCATOR_SLOP == *((LPDWORD)pvBuffer - 1));

  00046	68 58 01 00 00	 push	 344			; 00000158H
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  00050	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DC@OLMEENNO@DSOUND_ALLOCATOR_SLOP?5?$DN?$DN?5?$CK?$CI?$CILPDW@
  00055	8b 55 fc	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00058	33 c0		 xor	 eax, eax
  0005a	81 7a fc 73 6c
	6f 70		 cmp	 DWORD PTR [edx-4], 1886350451 ; 706f6c73H
  00061	0f 95 c0	 setne	 al
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0006a	83 c4 10	 add	 esp, 16			; 00000010H

; 345  : 
; 346  :             if(fZeroInit)

  0006d	83 7d 10 00	 cmp	 DWORD PTR _fZeroInit$[ebp], 0
  00071	74 12		 je	 SHORT $L35723

; 347  :             {
; 348  :                 ZeroMemory(pvBuffer, cbBuffer);

  00073	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00076	51		 push	 ecx
  00077	6a 00		 push	 0
  00079	8b 55 fc	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 _memset
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
$L35723:

; 349  :             }
; 350  :         }
; 351  :     }
; 352  :     else

  00085	eb 07		 jmp	 SHORT $L35727
$L35722:

; 353  :     {
; 354  :         pvBuffer = NULL;

  00087	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pvBuffer$[ebp], 0
$L35727:

; 355  :     }
; 356  : 
; 357  :     if(!pvBuffer)

  0008e	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00092	75 2f		 jne	 SHORT $L35728

; 358  :     {
; 359  :         if(pvBuffer = PoolAlloc(nPoolTag, cbBuffer + sizeof(DWORD), fZeroInit))

  00094	8b 45 10	 mov	 eax, DWORD PTR _fZeroInit$[ebp]
  00097	50		 push	 eax
  00098	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  0009b	83 c1 04	 add	 ecx, 4
  0009e	51		 push	 ecx
  0009f	8b 55 08	 mov	 edx, DWORD PTR _nPoolTag$[ebp]
  000a2	52		 push	 edx
  000a3	e8 00 00 00 00	 call	 ?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::PoolAlloc
  000a8	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  000ab	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  000af	74 12		 je	 SHORT $L35728

; 360  :         {
; 361  :             *(LPDWORD)pvBuffer = DSOUND_ALLOCATOR_POOL;

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  000b4	c7 00 70 6f 6f
	6c		 mov	 DWORD PTR [eax], 1819242352 ; 6c6f6f70H

; 362  :             pvBuffer = (LPDWORD)pvBuffer + 1;

  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  000bd	83 c1 04	 add	 ecx, 4
  000c0	89 4d fc	 mov	 DWORD PTR _pvBuffer$[ebp], ecx
$L35728:

; 363  :         }
; 364  :     }
; 365  : 
; 366  :     return pvBuffer;

  000c3	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 367  : }

  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 0c 00	 ret	 12			; 0000000cH
?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ENDP ; DirectSound::CMemoryManager::MemAlloc
DSOUND	ENDS
PUBLIC	?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z	; DirectSound::CMemoryManager::MemFree
PUBLIC	??_C@_0CA@GADDBPNL@Slop?5memory?5heap?5does?5not?5exist?$AA@ ; `string'
PUBLIC	??_C@_0BE@FMKOLKGH@Invalid?5memory?5free?$AA@	; `string'
EXTRN	?Free@CMcpxSlopMemoryHeap@DirectSound@@QAEXPAX@Z:NEAR ; DirectSound::CMcpxSlopMemoryHeap::Free
;	COMDAT ??_C@_0CA@GADDBPNL@Slop?5memory?5heap?5does?5not?5exist?$AA@
DSOUND_RD	SEGMENT
??_C@_0CA@GADDBPNL@Slop?5memory?5heap?5does?5not?5exist?$AA@ DB 'Slop mem'
	DB	'ory heap does not exist', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BE@FMKOLKGH@Invalid?5memory?5free?$AA@
DSOUND_RD	SEGMENT
??_C@_0BE@FMKOLKGH@Invalid?5memory?5free?$AA@ DB 'Invalid memory free', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT
_pdwSignature$ = -8
_pvBuffer$ = 8
?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR	; DirectSound::CMemoryManager::MemFree, COMDAT

; 397  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 398  :     LPDWORD                 pdwSignature;
; 399  :     DWORD                   cbBuffer;
; 400  : 
; 401  :     ASSERT(pvBuffer);

  00006	68 91 01 00 00	 push	 401			; 00000191H
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08FADLHADM@pvBuffer?$AA@
  00015	33 c0		 xor	 eax, eax
  00017	83 7d 08 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  0001b	0f 94 c0	 sete	 al
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 402  : 
; 403  :     pdwSignature = (LPDWORD)pvBuffer - 1;

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  0002a	83 e9 04	 sub	 ecx, 4
  0002d	89 4d f8	 mov	 DWORD PTR _pdwSignature$[ebp], ecx

; 404  :     
; 405  :     if(DSOUND_ALLOCATOR_POOL == *pdwSignature)

  00030	8b 55 f8	 mov	 edx, DWORD PTR _pdwSignature$[ebp]
  00033	81 3a 70 6f 6f
	6c		 cmp	 DWORD PTR [edx], 1819242352 ; 6c6f6f70H
  00039	75 0b		 jne	 SHORT $L35739

; 406  :     {
; 407  :         PoolFree(pdwSignature);

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _pdwSignature$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PoolFree

; 408  :     }
; 409  :     else if(DSOUND_ALLOCATOR_SLOP == *pdwSignature)

  00044	eb 59		 jmp	 SHORT $L35735
$L35739:
  00046	8b 4d f8	 mov	 ecx, DWORD PTR _pdwSignature$[ebp]
  00049	81 39 73 6c 6f
	70		 cmp	 DWORD PTR [ecx], 1886350451 ; 706f6c73H
  0004f	75 35		 jne	 SHORT $L35741

; 410  :     {
; 411  :         if(CMcpxSlopMemoryHeap::m_pSlopMemoryHeap)

  00051	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A, 0 ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap
  00058	74 11		 je	 SHORT $L35742

; 412  :         {
; 413  :             CMcpxSlopMemoryHeap::m_pSlopMemoryHeap->Free(pvBuffer);

  0005a	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  0005d	52		 push	 edx
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap
  00064	e8 00 00 00 00	 call	 ?Free@CMcpxSlopMemoryHeap@DirectSound@@QAEXPAX@Z ; DirectSound::CMcpxSlopMemoryHeap::Free

; 414  :         }
; 415  :         else

  00069	eb 19		 jmp	 SHORT $L35743
$L35742:

; 416  :         {
; 417  :             ASSERTMSG("Slop memory heap does not exist");

  0006b	68 a1 01 00 00	 push	 417			; 000001a1H
  00070	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@GADDBPNL@Slop?5memory?5heap?5does?5not?5exist?$AA@
  0007a	6a 01		 push	 1
  0007c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00081	83 c4 10	 add	 esp, 16			; 00000010H
$L35743:

; 418  :         }
; 419  :     }
; 420  :     else

  00084	eb 19		 jmp	 SHORT $L35735
$L35741:

; 421  :     {
; 422  :         ASSERTMSG("Invalid memory free");

  00086	68 a6 01 00 00	 push	 422			; 000001a6H
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@FMKOLKGH@Invalid?5memory?5free?$AA@
  00095	6a 01		 push	 1
  00097	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0009c	83 c4 10	 add	 esp, 16			; 00000010H
$L35735:

; 423  :     }
; 424  : }

  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 04 00	 ret	 4
?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP	; DirectSound::CMemoryManager::MemFree
DSOUND	ENDS
PUBLIC	?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z	; InsertTailListUninit
PUBLIC	?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ; DirectSound::CMemoryManager::TrackAlloc
PUBLIC	??0CAutoIrql@DirectSound@@QAE@XZ		; DirectSound::CAutoIrql::CAutoIrql
PUBLIC	??1CAutoIrql@DirectSound@@QAE@XZ		; DirectSound::CAutoIrql::~CAutoIrql
PUBLIC	??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@		; `string'
PUBLIC	??_C@_0CB@KOBBHKIF@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@ ; `string'
PUBLIC	??_C@_06OFIAKHFO@cbSize?$AA@			; `string'
;	COMDAT ??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@
DSOUND_RD	SEGMENT
??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@ DB 'pvBaseAddress', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@KOBBHKIF@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@
DSOUND_RD	SEGMENT
??_C@_0CB@KOBBHKIF@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@ DB 'c'
	DB	'bTracking >= sizeof(*pTracking)', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_06OFIAKHFO@cbSize?$AA@
DSOUND_RD	SEGMENT
??_C@_06OFIAKHFO@cbSize?$AA@ DB 'cbSize', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z
DSOUND	SEGMENT
$T37382 = -16
___AutoIrql$ = -12
_pTracking$ = -4
_pvBaseAddress$ = 8
_cbTracking$ = 12
_pszFile$ = 16
_nLine$ = 20
_pszClass$ = 24
_nAllocatorTag$ = 28
_cbSize$ = 32
?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z PROC NEAR ; DirectSound::CMemoryManager::TrackAlloc, COMDAT

; 466  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 467  :     LPDSMEMTRACK            pTracking;
; 468  :     
; 469  :     ASSERT(pvBaseAddress);

  00006	68 d5 01 00 00	 push	 469			; 000001d5H
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@
  00015	33 c0		 xor	 eax, eax
  00017	83 7d 08 00	 cmp	 DWORD PTR _pvBaseAddress$[ebp], 0
  0001b	0f 94 c0	 sete	 al
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 470  :     ASSERT(cbTracking >= sizeof(*pTracking));

  00027	68 d6 01 00 00	 push	 470			; 000001d6H
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@KOBBHKIF@cbTracking?5?$DO?$DN?5sizeof?$CI?$CKpTracking?$CJ@
  00036	83 7d 0c 20	 cmp	 DWORD PTR _cbTracking$[ebp], 32 ; 00000020H
  0003a	1b c9		 sbb	 ecx, ecx
  0003c	f7 d9		 neg	 ecx
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00044	83 c4 10	 add	 esp, 16			; 00000010H

; 471  :     ASSERT(cbSize);

  00047	68 d7 01 00 00	 push	 471			; 000001d7H
  0004c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06OFIAKHFO@cbSize?$AA@
  00056	33 d2		 xor	 edx, edx
  00058	83 7d 20 00	 cmp	 DWORD PTR _cbSize$[ebp], 0
  0005c	0f 94 c2	 sete	 dl
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00065	83 c4 10	 add	 esp, 16			; 00000010H

; 472  :     
; 473  :     //
; 474  :     // Because of alignment issues, the base address may be incremented more
; 475  :     // than sizeof(DSMEMTRACK).  For this reason, we store the tracking data
; 476  :     // directly behind the allocation, but allocate more than cbSize +
; 477  :     // sizeof(DSMEMTRACK).
; 478  :     //
; 479  : 
; 480  :     pTracking = (LPDSMEMTRACK)((LPBYTE)pvBaseAddress + cbTracking - sizeof(*pTracking));

  00068	8b 45 0c	 mov	 eax, DWORD PTR _cbTracking$[ebp]
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  0006e	8d 54 01 e0	 lea	 edx, DWORD PTR [ecx+eax-32]
  00072	89 55 fc	 mov	 DWORD PTR _pTracking$[ebp], edx

; 481  : 
; 482  :     //
; 483  :     // Create the tracking info
; 484  :     //
; 485  : 
; 486  :     pTracking->pszFile = pszFile;

  00075	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  00078	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  0007b	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 487  :     pTracking->nLine = nLine;

  0007e	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  00081	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  00084	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 488  :     pTracking->pszClass = pszClass;

  00087	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  0008a	8b 55 18	 mov	 edx, DWORD PTR _pszClass$[ebp]
  0008d	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 489  :     pTracking->nAllocatorTag = nAllocatorTag;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  00093	8b 4d 1c	 mov	 ecx, DWORD PTR _nAllocatorTag$[ebp]
  00096	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 490  :     pTracking->cbSize = cbSize;

  00099	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  0009c	8b 45 20	 mov	 eax, DWORD PTR _cbSize$[ebp]
  0009f	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 491  :     pTracking->pvBaseAddress = pvBaseAddress;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000a5	8b 55 08	 mov	 edx, DWORD PTR _pvBaseAddress$[ebp]
  000a8	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 492  : 
; 493  : #ifdef _XBOX
; 494  : 
; 495  :     //
; 496  :     // Raise IRQL for synchronization
; 497  :     //
; 498  : 
; 499  :     AutoIrql();

  000ab	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000ae	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 500  : 
; 501  : #endif // _XBOX
; 502  : 
; 503  :     //
; 504  :     // Add the allocation to the list
; 505  :     //
; 506  : 
; 507  :     if(!m_lstMemoryTracking.Flink && !m_lstMemoryTracking.Blink)

  000b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, 0
  000ba	75 1d		 jne	 SHORT $L35763
  000bc	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A+4, 0
  000c3	75 14		 jne	 SHORT $L35763

; 508  :     {
; 509  :         InitializeListHead(&m_lstMemoryTracking);

  000c5	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A+4, OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  000cf	a1 04 00 00 00	 mov	 eax, DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A+4
  000d4	a3 00 00 00 00	 mov	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, eax
$L35763:

; 510  :     }
; 511  :     
; 512  :     InsertTailListUninit(&m_lstMemoryTracking, &pTracking->leListEntry);

  000d9	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000dc	51		 push	 ecx
  000dd	68 00 00 00 00	 push	 OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  000e2	e8 00 00 00 00	 call	 ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailListUninit

; 513  : 
; 514  :     //
; 515  :     // Fix up the base address
; 516  :     //
; 517  : 
; 518  :     return pTracking + 1;

  000e7	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  000ea	83 c2 20	 add	 edx, 32			; 00000020H
  000ed	89 55 f0	 mov	 DWORD PTR $T37382[ebp], edx
  000f0	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000f3	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000f8	8b 45 f0	 mov	 eax, DWORD PTR $T37382[ebp]

; 519  : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 1c 00	 ret	 28			; 0000001cH
?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ENDP ; DirectSound::CMemoryManager::TrackAlloc
DSOUND	ENDS
PUBLIC	?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList
PUBLIC	??_C@_0DH@HLNMLIHP@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
;	COMDAT ??_C@_0DH@HLNMLIHP@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\common\ntlist.h
DSOUND_RD	SEGMENT
??_C@_0DH@HLNMLIHP@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\common\ntlist.h', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT
_ListHead$ = 8
_Entry$ = 12
?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z PROC NEAR	; InsertTailListUninit, COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 136  :     AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

  00003	68 88 00 00 00	 push	 136			; 00000088H
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@HLNMLIHP@c?3?2xbox?2private?2windows?2directx?2@
  0000d	6a 00		 push	 0
  0000f	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 137  : 
; 138  :     Entry->Flink = ListHead;

  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR _ListHead$[ebp]
  0001e	89 11		 mov	 DWORD PTR [ecx], edx

; 139  :     Entry->Blink = ListHead->Blink;

  00020	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  00026	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00029	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 140  :     
; 141  :     Entry->Flink->Blink = Entry;

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00034	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 142  :     Entry->Blink->Flink = Entry;

  00037	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0003a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003d	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00040	89 11		 mov	 DWORD PTR [ecx], edx

; 143  : 
; 144  :     AssertValidEntryList(Entry, ASSERT_IN_LIST);

  00042	68 90 00 00 00	 push	 144			; 00000090H
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@HLNMLIHP@c?3?2xbox?2private?2windows?2directx?2@
  0004c	6a 01		 push	 1
  0004e	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 145  : }    

  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ENDP	; InsertTailListUninit
DSOUND	ENDS
PUBLIC	??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@ ; `string'
PUBLIC	??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@ ; `string'
PUBLIC	??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@ ; `string'
PUBLIC	??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@ ; `string'
PUBLIC	??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@	; `string'
;	COMDAT ??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@
DSOUND_RD	SEGMENT
??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@ DB 'NULL list entry po'
	DB	'inter', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@
DSOUND_RD	SEGMENT
??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@ DB 'List entry c'
	DB	'ontains NULL pointer', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@
DSOUND_RD	SEGMENT
??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@ DB 'List entry '
	DB	'partially points to itself', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@
DSOUND_RD	SEGMENT
??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@ DB 'List entry not in '
	DB	'list', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@
DSOUND_RD	SEGMENT
??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@ DB 'List entry in list', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z
DSOUND	SEGMENT
_Entry$ = 8
_nFlags$ = 12
_pszFile$ = 16
_nLine$ = 20
?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z PROC NEAR ; __AssertValidEntryList, COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   :     if(!Entry)

  00003	83 7d 08 00	 cmp	 DWORD PTR _Entry$[ebp], 0
  00007	75 1c		 jne	 SHORT $L30006

; 57   :     {
; 58   :         DirectSound::CDebug::Assert(TRUE, "NULL list entry pointer", pszFile, nLine);

  00009	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  00010	51		 push	 ecx
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@MLBFKIOK@NULL?5list?5entry?5pointer?$AA@
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0001d	83 c4 10	 add	 esp, 16			; 00000010H

; 59   :     }
; 60   :     else if(!Entry->Flink || !Entry->Blink)

  00020	e9 c0 00 00 00	 jmp	 $L30005
$L30006:
  00025	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  00028	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0002b	74 09		 je	 SHORT $L30010
  0002d	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	75 1c		 jne	 SHORT $L30009
$L30010:

; 61   :     {
; 62   :         DirectSound::CDebug::Assert(TRUE, "List entry contains NULL pointer", pszFile, nLine);

  00036	8b 4d 14	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  0003d	52		 push	 edx
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@FLABCILB@List?5entry?5contains?5NULL?5pointer@
  00043	6a 01		 push	 1
  00045	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0004a	83 c4 10	 add	 esp, 16			; 00000010H

; 63   :     }
; 64   :     else if((Entry == Entry->Flink) || (Entry == Entry->Blink))

  0004d	e9 93 00 00 00	 jmp	 $L30005
$L30009:
  00052	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00058	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0005a	74 0b		 je	 SHORT $L30014
  0005c	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0005f	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00062	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00065	75 2e		 jne	 SHORT $L30013
$L30014:

; 65   :     {
; 66   :         if((Entry != Entry->Flink) || (Entry != Entry->Blink))

  00067	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0006a	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0006d	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0006f	75 0b		 jne	 SHORT $L30016
  00071	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00077	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0007a	74 17		 je	 SHORT $L30015
$L30016:

; 67   :         {
; 68   :             DirectSound::CDebug::Assert(TRUE, "List entry partially points to itself", pszFile, nLine);

  0007c	8b 55 14	 mov	 edx, DWORD PTR _nLine$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 10	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00083	50		 push	 eax
  00084	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@FMEINEKN@List?5entry?5partially?5points?5to?5i@
  00089	6a 01		 push	 1
  0008b	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00090	83 c4 10	 add	 esp, 16			; 00000010H
$L30015:

; 69   :         }
; 70   :     }
; 71   :     else if(ASSERT_IN_LIST == nFlags)

  00093	eb 50		 jmp	 SHORT $L30005
$L30013:
  00095	83 7d 0c 01	 cmp	 DWORD PTR _nFlags$[ebp], 1
  00099	75 23		 jne	 SHORT $L30019

; 72   :     {
; 73   :         if(!IsEntryInList(Entry))

  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0009e	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a0	3b 55 08	 cmp	 edx, DWORD PTR _Entry$[ebp]
  000a3	75 17		 jne	 SHORT $L30020

; 74   :         {
; 75   :             DirectSound::CDebug::Assert(TRUE, "List entry not in list", pszFile, nLine);

  000a5	8b 45 14	 mov	 eax, DWORD PTR _nLine$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 10	 mov	 ecx, DWORD PTR _pszFile$[ebp]
  000ac	51		 push	 ecx
  000ad	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@JIBNMDFM@List?5entry?5not?5in?5list?$AA@
  000b2	6a 01		 push	 1
  000b4	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000b9	83 c4 10	 add	 esp, 16			; 00000010H
$L30020:

; 76   :         }
; 77   :     }
; 78   :     else if(ASSERT_NOT_IN_LIST == nFlags)

  000bc	eb 27		 jmp	 SHORT $L30005
$L30019:
  000be	83 7d 0c 02	 cmp	 DWORD PTR _nFlags$[ebp], 2
  000c2	75 21		 jne	 SHORT $L30005

; 79   :     {
; 80   :         if(IsEntryInList(Entry))

  000c4	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  000c7	8b 02		 mov	 eax, DWORD PTR [edx]
  000c9	3b 45 08	 cmp	 eax, DWORD PTR _Entry$[ebp]
  000cc	74 17		 je	 SHORT $L30005

; 81   :         {
; 82   :             DirectSound::CDebug::Assert(TRUE, "List entry in list", pszFile, nLine);

  000ce	8b 4d 14	 mov	 ecx, DWORD PTR _nLine$[ebp]
  000d1	51		 push	 ecx
  000d2	8b 55 10	 mov	 edx, DWORD PTR _pszFile$[ebp]
  000d5	52		 push	 edx
  000d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@MCAPMFFH@List?5entry?5in?5list?$AA@
  000db	6a 01		 push	 1
  000dd	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000e2	83 c4 10	 add	 esp, 16			; 00000010H
$L30005:

; 83   :         }
; 84   :     }
; 85   : }

  000e5	5d		 pop	 ebp
  000e6	c2 10 00	 ret	 16			; 00000010H
?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ENDP ; __AssertValidEntryList
DSOUND	ENDS
PUBLIC	??0CIrql@DirectSound@@QAE@XZ			; DirectSound::CIrql::CIrql
PUBLIC	?Raise@CIrql@DirectSound@@QAEXXZ		; DirectSound::CIrql::Raise
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\drvhlp.h
;	COMDAT ??0CAutoIrql@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CAutoIrql@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CAutoIrql::CAutoIrql, COMDAT
; _this$ = ecx

; 77   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CIrql@DirectSound@@QAE@XZ ; DirectSound::CIrql::CIrql

; 78   :         Raise();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?Raise@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Raise

; 79   :     }

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CAutoIrql@DirectSound@@QAE@XZ ENDP			; DirectSound::CAutoIrql::CAutoIrql
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??0CIrql@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CIrql@DirectSound@@QAE@XZ PROC NEAR			; DirectSound::CIrql::CIrql, COMDAT
; _this$ = ecx

; 40   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   :         m_fRaised = FALSE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 42   :     }

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0CIrql@DirectSound@@QAE@XZ ENDP			; DirectSound::CIrql::CIrql
DSOUND	ENDS
EXTRN	__imp_@KfRaiseIrql@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Raise@CIrql@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Raise@CIrql@DirectSound@@QAEXXZ PROC NEAR		; DirectSound::CIrql::Raise, COMDAT
; _this$ = ecx

; 45   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 46   :         if(m_fRaised = (KeGetCurrentIrql() < DISPATCH_LEVEL))

  00007	e8 00 00 00 00	 call	 _KeGetCurrentIrql@0
  0000c	0f b6 c0	 movzx	 eax, al
  0000f	33 c9		 xor	 ecx, ecx
  00011	83 f8 02	 cmp	 eax, 2
  00014	0f 9c c1	 setl	 cl
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00024	74 0d		 je	 SHORT $L30264

; 47   :         {
; 48   :             m_irql = KfRaiseIrql(DISPATCH_LEVEL);

  00026	b1 02		 mov	 cl, 2
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfRaiseIrql@4
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	88 01		 mov	 BYTE PTR [ecx], al
$L30264:

; 49   :         }
; 50   :     }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?Raise@CIrql@DirectSound@@QAEXXZ ENDP			; DirectSound::CIrql::Raise
DSOUND	ENDS
PUBLIC	?Lower@CIrql@DirectSound@@QAEXXZ		; DirectSound::CIrql::Lower
; Function compile flags: /Odt
;	COMDAT ??1CAutoIrql@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CAutoIrql@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CAutoIrql::~CAutoIrql, COMDAT
; _this$ = ecx

; 82   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 83   :         Lower();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower

; 84   :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CAutoIrql@DirectSound@@QAE@XZ ENDP			; DirectSound::CAutoIrql::~CAutoIrql
DSOUND	ENDS
EXTRN	__imp_@KfLowerIrql@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Lower@CIrql@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Lower@CIrql@DirectSound@@QAEXXZ PROC NEAR		; DirectSound::CIrql::Lower, COMDAT
; _this$ = ecx

; 53   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 54   :         if(m_fRaised)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 15		 je	 SHORT $L30269

; 55   :         {
; 56   :             KfLowerIrql(m_irql);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8a 09		 mov	 cl, BYTE PTR [ecx]
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfLowerIrql@4

; 57   :             m_fRaised = FALSE;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$L30269:

; 58   :         }
; 59   :     }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?Lower@CIrql@DirectSound@@QAEXXZ ENDP			; DirectSound::CIrql::Lower
DSOUND	ENDS
PUBLIC	?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z	; RemoveEntryList
PUBLIC	?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ; DirectSound::CMemoryManager::ForgetAlloc
PUBLIC	??_C@_0CK@PJHOCMHE@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@ ; `string'
;	COMDAT ??_C@_0CK@PJHOCMHE@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@
; File c:\xbox\private\windows\directx\dsound\common\memmgr.cpp
DSOUND_RD	SEGMENT
??_C@_0CK@PJHOCMHE@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@ DB 'nAll'
	DB	'ocatorTag == pTracking->nAllocatorTag', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z
DSOUND	SEGMENT
$T37407 = -16
___AutoIrql$ = -12
_pTracking$ = -4
_pvBaseAddress$ = 8
_nAllocatorTag$ = 12
?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z PROC NEAR ; DirectSound::CMemoryManager::ForgetAlloc, COMDAT

; 551  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 552  :     LPDSMEMTRACK            pTracking   = (LPDSMEMTRACK)pvBaseAddress - 1;

  00006	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  00009	83 e8 20	 sub	 eax, 32			; 00000020H
  0000c	89 45 fc	 mov	 DWORD PTR _pTracking$[ebp], eax

; 553  : 
; 554  :     ASSERT(pvBaseAddress);

  0000f	68 2a 02 00 00	 push	 554			; 0000022aH
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EMFGKDKI@pvBaseAddress?$AA@
  0001e	33 c9		 xor	 ecx, ecx
  00020	83 7d 08 00	 cmp	 DWORD PTR _pvBaseAddress$[ebp], 0
  00024	0f 94 c1	 sete	 cl
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002d	83 c4 10	 add	 esp, 16			; 00000010H

; 555  : 
; 556  :     //
; 557  :     // Assert that the tag matches what we expect
; 558  :     //
; 559  : 
; 560  :     ASSERT(nAllocatorTag == pTracking->nAllocatorTag);

  00030	68 30 02 00 00	 push	 560			; 00000230H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@PJHOCMHE@nAllocatorTag?5?$DN?$DN?5pTracking?9?$DOnAll@
  0003f	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  00042	8b 45 0c	 mov	 eax, DWORD PTR _nAllocatorTag$[ebp]
  00045	33 c9		 xor	 ecx, ecx
  00047	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  0004a	0f 95 c1	 setne	 cl
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00053	83 c4 10	 add	 esp, 16			; 00000010H

; 561  :     
; 562  : #ifdef _XBOX
; 563  : 
; 564  :     //
; 565  :     // Raise IRQL for synchronization
; 566  :     //
; 567  : 
; 568  :     AutoIrql();

  00056	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00059	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 569  : 
; 570  : #endif // _XBOX
; 571  : 
; 572  :     //
; 573  :     // Remove the allocation from the list
; 574  :     //
; 575  : 
; 576  :     RemoveEntryList(&pTracking->leListEntry);

  0005e	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 577  : 
; 578  :     //
; 579  :     // Return the proper base address
; 580  :     //
; 581  : 
; 582  :     return pTracking->pvBaseAddress;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  0006a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0006d	89 4d f0	 mov	 DWORD PTR $T37407[ebp], ecx
  00070	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00073	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00078	8b 45 f0	 mov	 eax, DWORD PTR $T37407[ebp]

; 583  : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8
?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ENDP ; DirectSound::CMemoryManager::ForgetAlloc
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\ntlist.h
DSOUND	ENDS
;	COMDAT ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z
DSOUND	SEGMENT
_Entry$ = 8
?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z PROC NEAR	; RemoveEntryList, COMDAT

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 216  :     AssertValidEntryList(Entry, ASSERT_VALID_ONLY);

  00003	68 d8 00 00 00	 push	 216			; 000000d8H
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@HLNMLIHP@c?3?2xbox?2private?2windows?2directx?2@
  0000d	6a 00		 push	 0
  0000f	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 217  : 
; 218  :     if(IsEntryInList(Entry))

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001d	3b 55 08	 cmp	 edx, DWORD PTR _Entry$[ebp]
  00020	74 2c		 je	 SHORT $L30046

; 219  :     {
; 220  :         Entry->Flink->Blink = Entry->Blink;

  00022	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0002a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 221  :         Entry->Blink->Flink = Entry->Flink;

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00033	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00036	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 0a		 mov	 DWORD PTR [edx], ecx

; 222  : 
; 223  :         Entry->Flink = Entry->Blink = Entry;

  0003d	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  00040	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00043	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00049	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0004c	89 11		 mov	 DWORD PTR [ecx], edx
$L30046:

; 224  :     }
; 225  : 
; 226  :     return Entry;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]

; 227  : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ENDP	; RemoveEntryList
DSOUND	ENDS
PUBLIC	?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingPoolAlloc
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\memmgr.cpp
;	COMDAT ?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT
_pvBuffer$ = -4
_pszFile$ = 8
_nLine$ = 12
_pszClass$ = 16
_nPoolTag$ = 20
_cbBuffer$ = 24
_fZeroInit$ = 28
?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z PROC NEAR ; DirectSound::CMemoryManager::TrackingPoolAlloc, COMDAT

; 623  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 624  : 
; 625  : #ifdef _XBOX
; 626  : 
; 627  :     static const ULONG      cbTracking  = PAGE_SIZE;
; 628  : 
; 629  : #else // _XBOX
; 630  : 
; 631  :     static const ULONG      cbTracking  = sizeof(DSMEMTRACK);
; 632  : 
; 633  : #endif // _XBOX
; 634  : 
; 635  :     LPVOID                  pvBuffer;
; 636  :     
; 637  :     //
; 638  :     // Do the actual allocation
; 639  :     //
; 640  :     
; 641  :     if(pvBuffer = PoolAlloc(nPoolTag, cbBuffer + cbTracking, fZeroInit))

  00004	8b 45 1c	 mov	 eax, DWORD PTR _fZeroInit$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 18	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  0000b	81 c1 00 10 00
	00		 add	 ecx, 4096		; 00001000H
  00011	51		 push	 ecx
  00012	8b 55 14	 mov	 edx, DWORD PTR _nPoolTag$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::PoolAlloc
  0001b	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  0001e	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00022	74 26		 je	 SHORT $L35785

; 642  :     {
; 643  :         //
; 644  :         // Complete the tracking
; 645  :         //
; 646  : 
; 647  :         pvBuffer = TrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_POOL, cbBuffer);

  00024	8b 45 18	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  00027	50		 push	 eax
  00028	68 70 6f 6f 6c	 push	 1819242352		; 6c6f6f70H
  0002d	8b 4d 10	 mov	 ecx, DWORD PTR _pszClass$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 0c	 mov	 edx, DWORD PTR _nLine$[ebp]
  00034	52		 push	 edx
  00035	8b 45 08	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00038	50		 push	 eax
  00039	68 00 10 00 00	 push	 4096			; 00001000H
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ; DirectSound::CMemoryManager::TrackAlloc
  00047	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
$L35785:

; 648  :     }
; 649  : 
; 650  :     return pvBuffer;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 651  : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 18 00	 ret	 24			; 00000018H
?TrackingPoolAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ENDP ; DirectSound::CMemoryManager::TrackingPoolAlloc
DSOUND	ENDS
PUBLIC	?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPoolFree
; Function compile flags: /Odt
;	COMDAT ?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT
_pvBuffer$ = 8
?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::TrackingPoolFree, COMDAT

; 681  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 682  :     //
; 683  :     // Free tracking information
; 684  :     //
; 685  : 
; 686  :     pvBuffer = ForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_POOL);

  00003	68 70 6f 6f 6c	 push	 1819242352		; 6c6f6f70H
  00008	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ; DirectSound::CMemoryManager::ForgetAlloc
  00011	89 45 08	 mov	 DWORD PTR _pvBuffer$[ebp], eax

; 687  : 
; 688  :     //
; 689  :     // Free memory
; 690  :     //
; 691  : 
; 692  :     PoolFree(pvBuffer);

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PoolFree

; 693  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?TrackingPoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP ; DirectSound::CMemoryManager::TrackingPoolFree
DSOUND	ENDS
PUBLIC	?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z ; DirectSound::CMemoryManager::TrackingPhysicalAlloc
; Function compile flags: /Odt
;	COMDAT ?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z
DSOUND	SEGMENT
_pvBuffer$ = -8
_cbTracking$ = -4
_pszFile$ = 8
_nLine$ = 12
_pszClass$ = 16
_cbBuffer$ = 20
_cbAlignment$ = 24
_dwFlags$ = 28
_fZeroInit$ = 32
?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z PROC NEAR ; DirectSound::CMemoryManager::TrackingPhysicalAlloc, COMDAT

; 732  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 733  :     ULONG                   cbTracking;
; 734  :     LPVOID                  pvBuffer;
; 735  : 
; 736  :     //
; 737  :     // Make sure we allocate enough information for the tracking data
; 738  :     //
; 739  : 
; 740  :     if(cbAlignment >= sizeof(DSMEMTRACK))

  00006	83 7d 18 20	 cmp	 DWORD PTR _cbAlignment$[ebp], 32 ; 00000020H
  0000a	72 08		 jb	 SHORT $L35801

; 741  :     {
; 742  :         cbTracking = cbAlignment;

  0000c	8b 45 18	 mov	 eax, DWORD PTR _cbAlignment$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _cbTracking$[ebp], eax

; 743  :     }
; 744  :     else

  00012	eb 12		 jmp	 SHORT $L35802
$L35801:

; 745  :     {
; 746  :         cbTracking = BLOCKALIGNPAD(sizeof(DSMEMTRACK), cbAlignment);

  00014	8b 45 18	 mov	 eax, DWORD PTR _cbAlignment$[ebp]
  00017	83 c0 1f	 add	 eax, 31			; 0000001fH
  0001a	33 d2		 xor	 edx, edx
  0001c	f7 75 18	 div	 DWORD PTR _cbAlignment$[ebp]
  0001f	0f af 45 18	 imul	 eax, DWORD PTR _cbAlignment$[ebp]
  00023	89 45 fc	 mov	 DWORD PTR _cbTracking$[ebp], eax
$L35802:

; 747  :     }
; 748  :     
; 749  :     //
; 750  :     // Do the actual allocation
; 751  :     //
; 752  :     
; 753  :     if(pvBuffer = PhysicalAlloc(cbBuffer + cbTracking, cbAlignment, dwFlags, fZeroInit))

  00026	8b 4d 20	 mov	 ecx, DWORD PTR _fZeroInit$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 1c	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 18	 mov	 eax, DWORD PTR _cbAlignment$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 14	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00035	03 4d fc	 add	 ecx, DWORD PTR _cbTracking$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z ; DirectSound::CMemoryManager::PhysicalAlloc
  0003e	89 45 f8	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  00041	83 7d f8 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00045	74 25		 je	 SHORT $L35804

; 754  :     {
; 755  :         //
; 756  :         // Complete the tracking
; 757  :         //
; 758  : 
; 759  :         pvBuffer = TrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_PHYS, cbBuffer);

  00047	8b 55 14	 mov	 edx, DWORD PTR _cbBuffer$[ebp]
  0004a	52		 push	 edx
  0004b	68 70 68 79 73	 push	 1937336432		; 73796870H
  00050	8b 45 10	 mov	 eax, DWORD PTR _pszClass$[ebp]
  00053	50		 push	 eax
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00057	51		 push	 ecx
  00058	8b 55 08	 mov	 edx, DWORD PTR _pszFile$[ebp]
  0005b	52		 push	 edx
  0005c	8b 45 fc	 mov	 eax, DWORD PTR _cbTracking$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d f8	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ; DirectSound::CMemoryManager::TrackAlloc
  00069	89 45 f8	 mov	 DWORD PTR _pvBuffer$[ebp], eax
$L35804:

; 760  :     }
; 761  : 
; 762  :     return pvBuffer;

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 763  : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 1c 00	 ret	 28			; 0000001cH
?TrackingPhysicalAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0KKKH@Z ENDP ; DirectSound::CMemoryManager::TrackingPhysicalAlloc
DSOUND	ENDS
PUBLIC	?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingPhysicalFree
; Function compile flags: /Odt
;	COMDAT ?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT
_pvBuffer$ = 8
?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::TrackingPhysicalFree, COMDAT

; 793  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 794  :     //
; 795  :     // Free tracking information
; 796  :     //
; 797  : 
; 798  :     pvBuffer = ForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_PHYS);

  00003	68 70 68 79 73	 push	 1937336432		; 73796870H
  00008	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ; DirectSound::CMemoryManager::ForgetAlloc
  00011	89 45 08	 mov	 DWORD PTR _pvBuffer$[ebp], eax

; 799  : 
; 800  :     //
; 801  :     // Free memory
; 802  :     //
; 803  : 
; 804  :     PhysicalFree(pvBuffer);

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PhysicalFree

; 805  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?TrackingPhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP ; DirectSound::CMemoryManager::TrackingPhysicalFree
DSOUND	ENDS
PUBLIC	?TrackingMemAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingMemAlloc
; Function compile flags: /Odt
;	COMDAT ?TrackingMemAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT
_pvBuffer$ = -4
_pszFile$ = 8
_nLine$ = 12
_pszClass$ = 16
_nPoolTag$ = 20
_cbBuffer$ = 24
_fZeroInit$ = 28
?TrackingMemAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z PROC NEAR ; DirectSound::CMemoryManager::TrackingMemAlloc, COMDAT

; 842  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 843  :     static const ULONG      cbTracking  = sizeof(DSMEMTRACK);
; 844  :     LPVOID                  pvBuffer;
; 845  :     
; 846  :     //
; 847  :     // Do the actual allocation
; 848  :     //
; 849  :     
; 850  :     if(pvBuffer = MemAlloc(nPoolTag, cbBuffer + cbTracking, fZeroInit))

  00004	8b 45 1c	 mov	 eax, DWORD PTR _fZeroInit$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 18	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  0000b	83 c1 20	 add	 ecx, 32			; 00000020H
  0000e	51		 push	 ecx
  0000f	8b 55 14	 mov	 edx, DWORD PTR _nPoolTag$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::MemAlloc
  00018	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  0001b	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  0001f	74 23		 je	 SHORT $L35820

; 851  :     {
; 852  :         //
; 853  :         // Complete the tracking
; 854  :         //
; 855  : 
; 856  :         pvBuffer = TrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_SLOP, cbBuffer);

  00021	8b 45 18	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  00024	50		 push	 eax
  00025	68 73 6c 6f 70	 push	 1886350451		; 706f6c73H
  0002a	8b 4d 10	 mov	 ecx, DWORD PTR _pszClass$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 0c	 mov	 edx, DWORD PTR _nLine$[ebp]
  00031	52		 push	 edx
  00032	8b 45 08	 mov	 eax, DWORD PTR _pszFile$[ebp]
  00035	50		 push	 eax
  00036	6a 20		 push	 32			; 00000020H
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ?TrackAlloc@CMemoryManager@DirectSound@@CGPAXPAXKPBDK1W4DSOUND_ALLOCATOR_TAG@@K@Z ; DirectSound::CMemoryManager::TrackAlloc
  00041	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
$L35820:

; 857  :     }
; 858  : 
; 859  :     return pvBuffer;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 860  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 18 00	 ret	 24			; 00000018H
?TrackingMemAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ENDP ; DirectSound::CMemoryManager::TrackingMemAlloc
DSOUND	ENDS
PUBLIC	?TrackingMemFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingMemFree
; Function compile flags: /Odt
;	COMDAT ?TrackingMemFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT
_pvBuffer$ = 8
?TrackingMemFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::TrackingMemFree, COMDAT

; 890  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 891  :     //
; 892  :     // Free tracking information
; 893  :     //
; 894  : 
; 895  :     pvBuffer = ForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_SLOP);

  00003	68 73 6c 6f 70	 push	 1886350451		; 706f6c73H
  00008	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ForgetAlloc@CMemoryManager@DirectSound@@CGPAXPAXW4DSOUND_ALLOCATOR_TAG@@@Z ; DirectSound::CMemoryManager::ForgetAlloc
  00011	89 45 08	 mov	 DWORD PTR _pvBuffer$[ebp], eax

; 896  : 
; 897  :     //
; 898  :     // Free memory
; 899  :     //
; 900  : 
; 901  :     MemFree(pvBuffer);

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::MemFree

; 902  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?TrackingMemFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP ; DirectSound::CMemoryManager::TrackingMemFree
DSOUND	ENDS
PUBLIC	??_C@_0BI@JPIKIBNC@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BH@OHKIAENG@Pool?5memory?5used?3?5?5?$CFlu?$AA@ ; `string'
PUBLIC	??_C@_0BL@OGBIDBPB@Physical?5memory?5used?3?5?5?$CFlu?$AA@ ; `string'
PUBLIC	??_C@_0CN@EIKGFANE@Physical?5memory?5available?5for?5re@ ; `string'
PUBLIC	??_C@_0CA@HBBPMJBE@Physical?5memory?5recovered?3?5?5?$CFlu?$AA@ ; `string'
PUBLIC	??_C@_0BG@DICBIGIJ@End?5memory?5usage?5dump?$AA@ ; `string'
PUBLIC	??_C@_0CD@DONIJHHD@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@ ; `string'
PUBLIC	??_C@_0CC@CGDLDDDA@IsListEmpty?$CI?$CGm_lstMemoryTracking@ ; `string'
PUBLIC	?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z ; DirectSound::CMemoryManager::DumpMemoryUsage
PUBLIC	??_C@_0EP@IIFDJHMP@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_0CA@HAOLFHG@CMemoryManager?3?3DumpMemoryUsage?$AA@ ; `string'
PUBLIC	??_C@_0BI@MIBDOIDJ@Begin?5memory?5usage?5dump?$AA@ ; `string'
EXTRN	?m_dwAvailable@CMcpxSlopMemoryHeap@DirectSound@@2AAKA:DWORD ; DirectSound::CMcpxSlopMemoryHeap::m_dwAvailable
EXTRN	?m_dwUsed@CMcpxSlopMemoryHeap@DirectSound@@2AAKA:DWORD ; DirectSound::CMcpxSlopMemoryHeap::m_dwUsed
;	COMDAT ??_C@_0CA@HAOLFHG@CMemoryManager?3?3DumpMemoryUsage?$AA@
DSOUND_RD	SEGMENT
??_C@_0CA@HAOLFHG@CMemoryManager?3?3DumpMemoryUsage?$AA@ DB 'CMemoryManag'
	DB	'er::DumpMemoryUsage', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
DSOUND_RD	SEGMENT
?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB DD FLAT:??_C@_0EP@IIFDJHMP@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `DirectSound::CMemoryManager::DumpMemoryUsage'::`2'::pszBanner
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@MIBDOIDJ@Begin?5memory?5usage?5dump?$AA@
DSOUND_RD	SEGMENT
??_C@_0BI@MIBDOIDJ@Begin?5memory?5usage?5dump?$AA@ DB 'Begin memory usage'
	DB	' dump', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@JPIKIBNC@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@
DSOUND_RD	SEGMENT
??_C@_0BI@JPIKIBNC@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@ DB '%'
	DB	'x (%lu bytes, type %s)', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@OHKIAENG@Pool?5memory?5used?3?5?5?$CFlu?$AA@
DSOUND_RD	SEGMENT
??_C@_0BH@OHKIAENG@Pool?5memory?5used?3?5?5?$CFlu?$AA@ DB 'Pool memory us'
	DB	'ed:  %lu', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@OGBIDBPB@Physical?5memory?5used?3?5?5?$CFlu?$AA@
DSOUND_RD	SEGMENT
??_C@_0BL@OGBIDBPB@Physical?5memory?5used?3?5?5?$CFlu?$AA@ DB 'Physical m'
	DB	'emory used:  %lu', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CN@EIKGFANE@Physical?5memory?5available?5for?5re@
DSOUND_RD	SEGMENT
??_C@_0CN@EIKGFANE@Physical?5memory?5available?5for?5re@ DB 'Physical mem'
	DB	'ory available for recovery:  %lu', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@HBBPMJBE@Physical?5memory?5recovered?3?5?5?$CFlu?$AA@
DSOUND_RD	SEGMENT
??_C@_0CA@HBBPMJBE@Physical?5memory?5recovered?3?5?5?$CFlu?$AA@ DB 'Physi'
	DB	'cal memory recovered:  %lu', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@DICBIGIJ@End?5memory?5usage?5dump?$AA@
DSOUND_RD	SEGMENT
??_C@_0BG@DICBIGIJ@End?5memory?5usage?5dump?$AA@ DB 'End memory usage dum'
	DB	'p', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CD@DONIJHHD@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@
DSOUND_RD	SEGMENT
??_C@_0CD@DONIJHHD@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@ DB '!IsList'
	DB	'Empty(&m_lstMemoryTracking)', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@CGDLDDDA@IsListEmpty?$CI?$CGm_lstMemoryTracking@
DSOUND_RD	SEGMENT
??_C@_0CC@CGDLDDDA@IsListEmpty?$CI?$CGm_lstMemoryTracking@ DB 'IsListEmpt'
	DB	'y(&m_lstMemoryTracking)', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0EP@IIFDJHMP@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
DSOUND_RD	SEGMENT
??_C@_0EP@IIFDJHMP@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'-------------------------------------------------------------'
	DB	'----------------', 00H			; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z
DSOUND	SEGMENT
___AutoIrql$ = -16
_pleEntry$ = -8
_pTracking$ = -4
_fAssertNone$ = 8
?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z PROC NEAR ; DirectSound::CMemoryManager::DumpMemoryUsage, COMDAT

; 930  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 931  : 
; 932  : #ifdef DEBUG
; 933  : 
; 934  :     static const LPCSTR     pszBanner           = "------------------------------------------------------------------------------";
; 935  : 
; 936  : #ifdef TRACK_MEMORY_USAGE
; 937  : 
; 938  :     PLIST_ENTRY             pleEntry;
; 939  :     LPDSMEMTRACK            pTracking;
; 940  : 
; 941  : #endif // TRACK_MEMORY_USAGE
; 942  : 
; 943  :     CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);

  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@HAOLFHG@CMemoryManager?3?3DumpMemoryUsage?$AA@
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0001d	83 c4 18	 add	 esp, 24			; 00000018H

; 944  :     CDebug::Print(pszBanner);

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0002b	83 c4 04	 add	 esp, 4

; 945  :     CDebug::Print("Begin memory usage dump");

  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@MIBDOIDJ@Begin?5memory?5usage?5dump?$AA@
  00033	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00038	83 c4 04	 add	 esp, 4

; 946  :     CDebug::Print(pszBanner);

  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00047	83 c4 04	 add	 esp, 4

; 947  :     
; 948  : #ifdef TRACK_MEMORY_USAGE
; 949  : 
; 950  : #ifdef _XBOX
; 951  : 
; 952  :     //
; 953  :     // Raise IRQL for synchronization
; 954  :     //
; 955  : 
; 956  :     AutoIrql();

  0004a	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0004d	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 957  : 
; 958  : #endif // _XBOX
; 959  :    
; 960  :     //
; 961  :     // Show specifically what allocations are remaining
; 962  :     //
; 963  :     
; 964  :     if(m_lstMemoryTracking.Flink)

  00052	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, 0
  00059	0f 84 b8 00 00
	00		 je	 $L35835

; 965  :     {
; 966  :         if(!IsListEmpty(&m_lstMemoryTracking))

  0005f	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  00069	0f 84 a8 00 00
	00		 je	 $L35835

; 967  :         {
; 968  :             for(pleEntry = m_lstMemoryTracking.Flink; pleEntry != &m_lstMemoryTracking; pleEntry = pleEntry->Flink)

  0006f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A
  00075	89 55 f8	 mov	 DWORD PTR _pleEntry$[ebp], edx
  00078	eb 08		 jmp	 SHORT $L35837
$L35838:
  0007a	8b 45 f8	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  0007d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007f	89 4d f8	 mov	 DWORD PTR _pleEntry$[ebp], ecx
$L35837:
  00082	81 7d f8 00 00
	00 00		 cmp	 DWORD PTR _pleEntry$[ebp], OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  00089	74 63		 je	 SHORT $L35839

; 969  :             {
; 970  :                 AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

  0008b	68 ca 03 00 00	 push	 970			; 000003caH
  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  00095	6a 01		 push	 1
  00097	8b 55 f8	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 ?__AssertValidEntryList@@YGXPAU_LIST_ENTRY@@W4ASSERT_VALID_ENTRY_LIST@@PBDI@Z ; __AssertValidEntryList

; 971  :             
; 972  :                 pTracking = CONTAINING_RECORD(pleEntry, DSMEMTRACK, leListEntry);

  000a0	8b 45 f8	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  000a3	89 45 fc	 mov	 DWORD PTR _pTracking$[ebp], eax

; 973  : 
; 974  :                 CDebug::SetContext(DPF_FLAGS_FILELINE, DPFLVL_ABSOLUTE, pTracking->pszFile, pTracking->nLine, DPF_FNAME, DPF_LIBRARY);

  000a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  000ab	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@HAOLFHG@CMemoryManager?3?3DumpMemoryUsage?$AA@
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000b3	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000b6	52		 push	 edx
  000b7	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  000ba	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000bd	51		 push	 ecx
  000be	6a 00		 push	 0
  000c0	6a 02		 push	 2
  000c2	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000c7	83 c4 18	 add	 esp, 24			; 00000018H

; 975  :                 CDebug::Print("%x (%lu bytes, type %s)", pTracking + 1, pTracking->cbSize, pTracking->pszClass);

  000ca	8b 55 fc	 mov	 edx, DWORD PTR _pTracking$[ebp]
  000cd	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000d0	50		 push	 eax
  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _pTracking$[ebp]
  000d4	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000d7	52		 push	 edx
  000d8	8b 45 fc	 mov	 eax, DWORD PTR _pTracking$[ebp]
  000db	83 c0 20	 add	 eax, 32			; 00000020H
  000de	50		 push	 eax
  000df	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@JPIKIBNC@?$CFx?5?$CI?$CFlu?5bytes?0?5type?5?$CFs?$CJ?$AA@
  000e4	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000e9	83 c4 10	 add	 esp, 16			; 00000010H

; 976  :             }

  000ec	eb 8c		 jmp	 SHORT $L35838
$L35839:

; 977  : 
; 978  :             CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);

  000ee	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  000f3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@HAOLFHG@CMemoryManager?3?3DumpMemoryUsage?$AA@
  000f8	6a 00		 push	 0
  000fa	6a 00		 push	 0
  000fc	6a 00		 push	 0
  000fe	6a 01		 push	 1
  00100	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00105	83 c4 18	 add	 esp, 24			; 00000018H

; 979  :             CDebug::Print(pszBanner);

  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  0010e	51		 push	 ecx
  0010f	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00114	83 c4 04	 add	 esp, 4
$L35835:

; 980  :         }
; 981  :     }
; 982  : 
; 983  : #endif // TRACK_MEMORY_USAGE
; 984  : 
; 985  :     CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);

  00117	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  0011c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@HAOLFHG@CMemoryManager?3?3DumpMemoryUsage?$AA@
  00121	6a 00		 push	 0
  00123	6a 00		 push	 0
  00125	6a 00		 push	 0
  00127	6a 01		 push	 1
  00129	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0012e	83 c4 18	 add	 esp, 24			; 00000018H

; 986  :     CDebug::Print("Pool memory used:  %lu", m_dwPoolMemoryUsage);

  00131	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  00137	8b 02		 mov	 eax, DWORD PTR [edx]
  00139	50		 push	 eax
  0013a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@OHKIAENG@Pool?5memory?5used?3?5?5?$CFlu?$AA@
  0013f	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00144	83 c4 08	 add	 esp, 8

; 987  :     CDebug::Print("Physical memory used:  %lu", m_dwPhysicalMemoryUsage);

  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
  0014d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014f	52		 push	 edx
  00150	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@OGBIDBPB@Physical?5memory?5used?3?5?5?$CFlu?$AA@
  00155	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0015a	83 c4 08	 add	 esp, 8

; 988  : 
; 989  : #ifdef ENABLE_SLOP_MEMORY_RECOVERY
; 990  : 
; 991  :     CDebug::Print("Physical memory available for recovery:  %lu", CMcpxSlopMemoryHeap::m_dwAvailable);

  0015d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwAvailable@CMcpxSlopMemoryHeap@DirectSound@@2AAKA ; DirectSound::CMcpxSlopMemoryHeap::m_dwAvailable
  00162	8b 08		 mov	 ecx, DWORD PTR [eax]
  00164	51		 push	 ecx
  00165	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@EIKGFANE@Physical?5memory?5available?5for?5re@
  0016a	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0016f	83 c4 08	 add	 esp, 8

; 992  :     CDebug::Print("Physical memory recovered:  %lu", CMcpxSlopMemoryHeap::m_dwUsed);

  00172	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeap@DirectSound@@2AAKA ; DirectSound::CMcpxSlopMemoryHeap::m_dwUsed
  00178	8b 02		 mov	 eax, DWORD PTR [edx]
  0017a	50		 push	 eax
  0017b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@HBBPMJBE@Physical?5memory?5recovered?3?5?5?$CFlu?$AA@
  00180	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00185	83 c4 08	 add	 esp, 8

; 993  : 
; 994  : #endif // ENABLE_SLOP_MEMORY_RECOVERY
; 995  : 
; 996  :     CDebug::Print(pszBanner);

  00188	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  0018e	51		 push	 ecx
  0018f	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00194	83 c4 04	 add	 esp, 4

; 997  :     CDebug::Print("End memory usage dump");

  00197	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@DICBIGIJ@End?5memory?5usage?5dump?$AA@
  0019c	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001a1	83 c4 04	 add	 esp, 4

; 998  :     CDebug::Print(pszBanner);

  001a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pszBanner@?1??DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z@4QBDB
  001aa	52		 push	 edx
  001ab	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001b0	83 c4 04	 add	 esp, 4

; 999  : 
; 1000 : #ifdef ENABLE_SLOP_MEMORY_RECOVERY
; 1001 : 
; 1002 :     if(m_dwPoolMemoryUsage || m_dwPhysicalMemoryUsage || CMcpxSlopMemoryHeap::m_dwAvailable || CMcpxSlopMemoryHeap::m_dwUsed)

  001b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  001b8	83 38 00	 cmp	 DWORD PTR [eax], 0
  001bb	75 20		 jne	 SHORT $L35851
  001bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
  001c3	83 39 00	 cmp	 DWORD PTR [ecx], 0
  001c6	75 15		 jne	 SHORT $L35851
  001c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwAvailable@CMcpxSlopMemoryHeap@DirectSound@@2AAKA ; DirectSound::CMcpxSlopMemoryHeap::m_dwAvailable
  001ce	83 3a 00	 cmp	 DWORD PTR [edx], 0
  001d1	75 0a		 jne	 SHORT $L35851
  001d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeap@DirectSound@@2AAKA ; DirectSound::CMcpxSlopMemoryHeap::m_dwUsed
  001d8	83 38 00	 cmp	 DWORD PTR [eax], 0
  001db	74 30		 je	 SHORT $L35850
$L35851:

; 1003 : 
; 1004 : #else // ENABLE_SLOP_MEMORY_RECOVERY
; 1005 : 
; 1006 :     if(m_dwPoolMemoryUsage || m_dwPhysicalMemoryUsage)
; 1007 : 
; 1008 : #endif // ENABLE_SLOP_MEMORY_RECOVERY
; 1009 : 
; 1010 :     {
; 1011 :         if(fAssertNone)

  001dd	83 7d 08 00	 cmp	 DWORD PTR _fAssertNone$[ebp], 0
  001e1	74 01		 je	 SHORT $L35852

; 1012 :         {
; 1013 :             __asm int 3

  001e3	cc		 int	 3
$L35852:

; 1014 :         }
; 1015 : 
; 1016 : #ifdef TRACK_MEMORY_USAGE
; 1017 : 
; 1018 :         ASSERT(!IsListEmpty(&m_lstMemoryTracking));

  001e4	68 fa 03 00 00	 push	 1018			; 000003faH
  001e9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  001ee	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@DONIJHHD@?$CBIsListEmpty?$CI?$CGm_lstMemoryTrackin@
  001f3	33 c9		 xor	 ecx, ecx
  001f5	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  001ff	0f 94 c1	 sete	 cl
  00202	51		 push	 ecx
  00203	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00208	83 c4 10	 add	 esp, 16			; 00000010H

; 1019 : 
; 1020 : #endif // TRACK_MEMORY_USAGE
; 1021 : 
; 1022 :     }
; 1023 : 
; 1024 : #ifdef TRACK_MEMORY_USAGE
; 1025 : 
; 1026 :     else

  0020b	eb 27		 jmp	 SHORT $L35854
$L35850:

; 1027 :     {
; 1028 :         ASSERT(IsListEmpty(&m_lstMemoryTracking));

  0020d	68 04 04 00 00	 push	 1028			; 00000404H
  00212	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@EGKFHOFC@c?3?2xbox?2private?2windows?2directx?2@
  00217	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@CGDLDDDA@IsListEmpty?$CI?$CGm_lstMemoryTracking@
  0021c	33 d2		 xor	 edx, edx
  0021e	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR ?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A, OFFSET FLAT:?m_lstMemoryTracking@CMemoryManager@DirectSound@@1U_LIST_ENTRY@@A ; DirectSound::CMemoryManager::m_lstMemoryTracking
  00228	0f 95 c2	 setne	 dl
  0022b	52		 push	 edx
  0022c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00231	83 c4 10	 add	 esp, 16			; 00000010H
$L35854:

; 1029 :     }
; 1030 : 
; 1031 : #endif // TRACK_MEMORY_USAGE
; 1032 : 
; 1033 : #endif // DEBUG
; 1034 : 
; 1035 : }

  00234	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00237	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  0023c	8b e5		 mov	 esp, ebp
  0023e	5d		 pop	 ebp
  0023f	c2 04 00	 ret	 4
?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z ENDP ; DirectSound::CMemoryManager::DumpMemoryUsage
DSOUND	ENDS
PUBLIC	??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_04JNFLDEGE@pwfx?$AA@			; `string'
PUBLIC	?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::CreatePcmFormat
;	COMDAT ??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dsound\common\format.cpp
DSOUND_RD	SEGMENT
??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\common\format.cpp', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_04JNFLDEGE@pwfx?$AA@
DSOUND_RD	SEGMENT
??_C@_04JNFLDEGE@pwfx?$AA@ DB 'pwfx', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_wBitsPerSample$ = 16
_pwfx$ = 20
?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::CreatePcmFormat, COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 54   :     DPF_ENTER();
; 55   :     
; 56   :     ASSERT(pwfx);

  00003	6a 38		 push	 56			; 00000038H
  00005	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JNFLDEGE@pwfx?$AA@
  0000f	33 c0		 xor	 eax, eax
  00011	83 7d 14 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  00015	0f 94 c0	 sete	 al
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0001e	83 c4 10	 add	 esp, 16			; 00000010H

; 57   : 
; 58   :     pwfx->wFormatTag = WAVE_FORMAT_PCM;

  00021	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00024	66 c7 01 01 00	 mov	 WORD PTR [ecx], 1

; 59   :     pwfx->nChannels = nChannels;

  00029	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0002c	66 8b 45 08	 mov	 ax, WORD PTR _nChannels$[ebp]
  00030	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 60   :     pwfx->nSamplesPerSec = nSamplesPerSec;

  00034	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00037	8b 55 0c	 mov	 edx, DWORD PTR _nSamplesPerSec$[ebp]
  0003a	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 61   :     pwfx->wBitsPerSample = wBitsPerSample;

  0003d	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00040	66 8b 4d 10	 mov	 cx, WORD PTR _wBitsPerSample$[ebp]
  00044	66 89 48 0e	 mov	 WORD PTR [eax+14], cx

; 62   :     pwfx->nBlockAlign = nChannels * wBitsPerSample / 8;

  00048	0f b7 45 08	 movzx	 eax, WORD PTR _nChannels$[ebp]
  0004c	0f b7 55 10	 movzx	 edx, WORD PTR _wBitsPerSample$[ebp]
  00050	0f af c2	 imul	 eax, edx
  00053	99		 cdq
  00054	83 e2 07	 and	 edx, 7
  00057	03 c2		 add	 eax, edx
  00059	c1 f8 03	 sar	 eax, 3
  0005c	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0005f	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 63   :     pwfx->nAvgBytesPerSec = nSamplesPerSec * pwfx->nBlockAlign;

  00063	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00066	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0006d	0f af c8	 imul	 ecx, eax
  00070	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00073	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 64   :     pwfx->cbSize = 0;

  00076	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00079	66 c7 40 10 00
	00		 mov	 WORD PTR [eax+16], 0

; 65   : 
; 66   :     DPF_LEAVE_VOID();
; 67   : }

  0007f	5d		 pop	 ebp
  00080	c2 10 00	 ret	 16			; 00000010H
?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::CreatePcmFormat
DSOUND	ENDS
PUBLIC	?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::CreateXboxAdpcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_pwfx$ = 16
?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUxbox_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::WaveFormat::CreateXboxAdpcmFormat, COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 98   :     DPF_ENTER();
; 99   :     
; 100  :     ASSERT(pwfx);

  00003	6a 64		 push	 100			; 00000064H
  00005	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JNFLDEGE@pwfx?$AA@
  0000f	33 c0		 xor	 eax, eax
  00011	83 7d 10 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  00015	0f 94 c0	 sete	 al
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0001e	83 c4 10	 add	 esp, 16			; 00000010H

; 101  : 
; 102  :     pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  00021	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00024	66 c7 01 69 00	 mov	 WORD PTR [ecx], 105	; 00000069H

; 103  :     pwfx->wfx.nChannels = nChannels;

  00029	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0002c	66 8b 45 08	 mov	 ax, WORD PTR _nChannels$[ebp]
  00030	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 104  :     pwfx->wfx.nSamplesPerSec = nSamplesPerSec;

  00034	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00037	8b 55 0c	 mov	 edx, DWORD PTR _nSamplesPerSec$[ebp]
  0003a	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 105  :     pwfx->wfx.wBitsPerSample = XBOX_ADPCM_BITS_PER_SAMPLE;

  0003d	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00040	66 c7 40 0e 04
	00		 mov	 WORD PTR [eax+14], 4

; 106  :     pwfx->wfx.nBlockAlign = nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  00046	0f b7 4d 08	 movzx	 ecx, WORD PTR _nChannels$[ebp]
  0004a	6b c9 24	 imul	 ecx, 36			; 00000024H
  0004d	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00050	66 89 4a 0c	 mov	 WORD PTR [edx+12], cx

; 107  :     pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec / XBOX_ADPCM_SAMPLES_PER_BLOCK * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  00054	8b 45 0c	 mov	 eax, DWORD PTR _nSamplesPerSec$[ebp]
  00057	c1 e8 06	 shr	 eax, 6
  0005a	6b c0 24	 imul	 eax, 36			; 00000024H
  0005d	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00060	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 108  :     pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);

  00063	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00066	66 c7 42 10 02
	00		 mov	 WORD PTR [edx+16], 2

; 109  :     pwfx->wSamplesPerBlock = XBOX_ADPCM_SAMPLES_PER_BLOCK;

  0006c	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0006f	66 c7 40 12 40
	00		 mov	 WORD PTR [eax+18], 64	; 00000040H

; 110  : 
; 111  :     DPF_LEAVE_VOID();
; 112  : }

  00075	5d		 pop	 ebp
  00076	c2 0c 00	 ret	 12			; 0000000cH
?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUxbox_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::WaveFormat::CreateXboxAdpcmFormat
DSOUND	ENDS
PUBLIC	??_C@_05PJHAMANO@pDest?$AA@			; `string'
PUBLIC	??_C@_07HPANBCJA@pSource?$AA@			; `string'
PUBLIC	??_C@_0BG@EABPBKPE@Unexpected?5format?5tag?$AA@	; `string'
PUBLIC	?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::CreateInternalFormat
PUBLIC	?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::PcmToInternalFormat
PUBLIC	?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::AdpcmToInternalFormat
PUBLIC	?ExtensibleToInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUWAVEFORMATEXTENSIBLE@@@Z ; DirectSound::WaveFormat::ExtensibleToInternalFormat
;	COMDAT ??_C@_05PJHAMANO@pDest?$AA@
DSOUND_RD	SEGMENT
??_C@_05PJHAMANO@pDest?$AA@ DB 'pDest', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_07HPANBCJA@pSource?$AA@
DSOUND_RD	SEGMENT
??_C@_07HPANBCJA@pSource?$AA@ DB 'pSource', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@EABPBKPE@Unexpected?5format?5tag?$AA@
DSOUND_RD	SEGMENT
??_C@_0BG@EABPBKPE@Unexpected?5format?5tag?$AA@ DB 'Unexpected format tag'
	DB	00H						; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
tv77 = -8
_dwChannelMask$ = -4
_pDest$ = 8
_pSource$ = 12
?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::CreateInternalFormat, COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 142  :     DWORD                   dwChannelMask   = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwChannelMask$[ebp], 0

; 143  :     
; 144  :     DPF_ENTER();
; 145  : 
; 146  :     ASSERT(pDest);

  0000d	68 92 00 00 00	 push	 146			; 00000092H
  00012	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05PJHAMANO@pDest?$AA@
  0001c	33 c0		 xor	 eax, eax
  0001e	83 7d 08 00	 cmp	 DWORD PTR _pDest$[ebp], 0
  00022	0f 94 c0	 sete	 al
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 147  :     ASSERT(pSource);

  0002e	68 93 00 00 00	 push	 147			; 00000093H
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07HPANBCJA@pSource?$AA@
  0003d	33 c9		 xor	 ecx, ecx
  0003f	83 7d 0c 00	 cmp	 DWORD PTR _pSource$[ebp], 0
  00043	0f 94 c1	 sete	 cl
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0004c	83 c4 10	 add	 esp, 16			; 00000010H

; 148  : 
; 149  :     switch(pSource->wFormatTag)
; 150  :     {

  0004f	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00052	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00055	89 45 f8	 mov	 DWORD PTR tv77[ebp], eax
  00058	83 7d f8 01	 cmp	 DWORD PTR tv77[ebp], 1
  0005c	74 11		 je	 SHORT $L35881
  0005e	83 7d f8 69	 cmp	 DWORD PTR tv77[ebp], 105 ; 00000069H
  00062	74 1a		 je	 SHORT $L35882
  00064	81 7d f8 fe ff
	00 00		 cmp	 DWORD PTR tv77[ebp], 65534 ; 0000fffeH
  0006b	74 20		 je	 SHORT $L35884
  0006d	eb 30		 jmp	 SHORT $L35886
$L35881:

; 151  :         case WAVE_FORMAT_PCM:
; 152  :             PcmToInternalFormat(pDest, pSource);

  0006f	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  00072	51		 push	 ecx
  00073	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 ?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::PcmToInternalFormat

; 153  :             break;

  0007c	eb 3a		 jmp	 SHORT $L35878
$L35882:

; 154  : 
; 155  :         case WAVE_FORMAT_XBOX_ADPCM:
; 156  :             AdpcmToInternalFormat(pDest, (LPCXBOXADPCMWAVEFORMAT)pSource);

  0007e	8b 45 0c	 mov	 eax, DWORD PTR _pSource$[ebp]
  00081	50		 push	 eax
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 ?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::AdpcmToInternalFormat

; 157  :             break;

  0008b	eb 2b		 jmp	 SHORT $L35878
$L35884:

; 158  : 
; 159  : #if defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 160  : 
; 161  :         case WAVE_FORMAT_EXTENSIBLE:
; 162  :             dwChannelMask = ExtensibleToInternalFormat(pDest, (LPCWAVEFORMATEXTENSIBLE)pSource);

  0008d	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00090	52		 push	 edx
  00091	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ?ExtensibleToInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUWAVEFORMATEXTENSIBLE@@@Z ; DirectSound::WaveFormat::ExtensibleToInternalFormat
  0009a	89 45 fc	 mov	 DWORD PTR _dwChannelMask$[ebp], eax

; 163  :             break;

  0009d	eb 19		 jmp	 SHORT $L35878
$L35886:

; 164  : 
; 165  : #endif // defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 166  : 
; 167  :         default:
; 168  :             ASSERTMSG("Unexpected format tag");

  0009f	68 a8 00 00 00	 push	 168			; 000000a8H
  000a4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  000a9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@EABPBKPE@Unexpected?5format?5tag?$AA@
  000ae	6a 01		 push	 1
  000b0	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000b5	83 c4 10	 add	 esp, 16			; 00000010H
$L35878:

; 169  :             break;
; 170  :     }
; 171  : 
; 172  :     DPF_LEAVE(dwChannelMask);
; 173  : 
; 174  :     return dwChannelMask;

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _dwChannelMask$[ebp]

; 175  : }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c2 08 00	 ret	 8
?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::CreateInternalFormat
DSOUND	ENDS
PUBLIC	??_C@_0BK@OPJEJGND@WaveFormat?3?3IsValidFormat?$AA@ ; `string'
PUBLIC	??_C@_0BH@NEGDFCOA@Unsupported?5format?5tag?$AA@ ; `string'
PUBLIC	?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::IsValidFormat
PUBLIC	?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::IsValidPcmFormat
PUBLIC	?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::IsValidAdpcmFormat
PUBLIC	?IsValidExtensibleFormat@WaveFormat@DirectSound@@YGHPBUWAVEFORMATEXTENSIBLE@@@Z ; DirectSound::WaveFormat::IsValidExtensibleFormat
;	COMDAT ??_C@_0BK@OPJEJGND@WaveFormat?3?3IsValidFormat?$AA@
DSOUND_RD	SEGMENT
??_C@_0BK@OPJEJGND@WaveFormat?3?3IsValidFormat?$AA@ DB 'WaveFormat::IsVal'
	DB	'idFormat', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BH@NEGDFCOA@Unsupported?5format?5tag?$AA@
DSOUND_RD	SEGMENT
??_C@_0BH@NEGDFCOA@Unsupported?5format?5tag?$AA@ DB 'Unsupported format t'
	DB	'ag', 00H					; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
tv71 = -8
_fSuccess$ = -4
_pwfx$ = 8
?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::IsValidFormat, COMDAT

; 201  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 202  :     BOOL                    fSuccess;
; 203  :     
; 204  :     DPF_ENTER();
; 205  : 
; 206  :     ASSERT(pwfx);

  00006	68 ce 00 00 00	 push	 206			; 000000ceH
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JNFLDEGE@pwfx?$AA@
  00015	33 c0		 xor	 eax, eax
  00017	83 7d 08 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  0001b	0f 94 c0	 sete	 al
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 207  : 
; 208  :     switch(pwfx->wFormatTag)
; 209  :     {

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0002a	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0002d	89 55 f8	 mov	 DWORD PTR tv71[ebp], edx
  00030	83 7d f8 01	 cmp	 DWORD PTR tv71[ebp], 1
  00034	74 11		 je	 SHORT $L35896
  00036	83 7d f8 69	 cmp	 DWORD PTR tv71[ebp], 105 ; 00000069H
  0003a	74 19		 je	 SHORT $L35897
  0003c	81 7d f8 fe ff
	00 00		 cmp	 DWORD PTR tv71[ebp], 65534 ; 0000fffeH
  00043	74 1e		 je	 SHORT $L35899
  00045	eb 2a		 jmp	 SHORT $L35901
$L35896:

; 210  :         case WAVE_FORMAT_PCM:
; 211  :             fSuccess = IsValidPcmFormat(pwfx);

  00047	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::IsValidPcmFormat
  00050	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 212  :             break;

  00053	eb 50		 jmp	 SHORT $L35893
$L35897:

; 213  : 
; 214  :         case WAVE_FORMAT_XBOX_ADPCM:
; 215  :             fSuccess = IsValidAdpcmFormat((LPCXBOXADPCMWAVEFORMAT)pwfx);

  00055	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::IsValidAdpcmFormat
  0005e	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 216  :             break;

  00061	eb 42		 jmp	 SHORT $L35893
$L35899:

; 217  : 
; 218  : #if defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 219  : 
; 220  :         case WAVE_FORMAT_EXTENSIBLE:
; 221  :             fSuccess = IsValidExtensibleFormat((LPCWAVEFORMATEXTENSIBLE)pwfx);

  00063	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 ?IsValidExtensibleFormat@WaveFormat@DirectSound@@YGHPBUWAVEFORMATEXTENSIBLE@@@Z ; DirectSound::WaveFormat::IsValidExtensibleFormat
  0006c	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 222  :             break;

  0006f	eb 34		 jmp	 SHORT $L35893
$L35901:

; 223  : 
; 224  : #endif // defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 225  : 
; 226  :         default:
; 227  :             DPF_ERROR("Unsupported format tag");

  00071	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  00076	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@OPJEJGND@WaveFormat?3?3IsValidFormat?$AA@
  0007b	68 e3 00 00 00	 push	 227			; 000000e3H
  00080	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00085	6a 01		 push	 1
  00087	6a 09		 push	 9
  00089	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0008e	83 c4 18	 add	 esp, 24			; 00000018H
  00091	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@NEGDFCOA@Unsupported?5format?5tag?$AA@
  00096	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0009b	83 c4 04	 add	 esp, 4

; 228  :             fSuccess = FALSE;

  0009e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0
$L35893:

; 229  :             break;
; 230  :     }
; 231  : 
; 232  :     DPF_LEAVE(fSuccess);
; 233  : 
; 234  :     return fSuccess;

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 235  : }

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 04 00	 ret	 4
?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::IsValidFormat
DSOUND	ENDS
PUBLIC	??_C@_0BL@KKKKMHLO@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@ ; `string'
PUBLIC	??_C@_0CA@PIODLKGG@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@ ; `string'
PUBLIC	??_C@_0BN@OLFDGMMG@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@ ; `string'
;	COMDAT ??_C@_0BL@KKKKMHLO@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@
DSOUND_RD	SEGMENT
??_C@_0BL@KKKKMHLO@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@ DB 'pSourc'
	DB	'e->nChannels <= 0xFF', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@PIODLKGG@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@
DSOUND_RD	SEGMENT
??_C@_0CA@PIODLKGG@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@ DB 'p'
	DB	'Source->wBitsPerSample <= 0xFF', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BN@OLFDGMMG@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@
DSOUND_RD	SEGMENT
??_C@_0BN@OLFDGMMG@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@ DB 'pSou'
	DB	'rce->nBlockAlign <= 0xFF', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
_pDest$ = 8
_pSource$ = 12
?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::PcmToInternalFormat, COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 265  :     DPF_ENTER();
; 266  : 
; 267  :     ASSERT(pDest);

  00003	68 0b 01 00 00	 push	 267			; 0000010bH
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05PJHAMANO@pDest?$AA@
  00012	33 c0		 xor	 eax, eax
  00014	83 7d 08 00	 cmp	 DWORD PTR _pDest$[ebp], 0
  00018	0f 94 c0	 sete	 al
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 268  :     ASSERT(pSource);

  00024	68 0c 01 00 00	 push	 268			; 0000010cH
  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07HPANBCJA@pSource?$AA@
  00033	33 c9		 xor	 ecx, ecx
  00035	83 7d 0c 00	 cmp	 DWORD PTR _pSource$[ebp], 0
  00039	0f 94 c1	 sete	 cl
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00042	83 c4 10	 add	 esp, 16			; 00000010H

; 269  : 
; 270  :     ASSERT(pSource->nChannels <= 0xFF);

  00045	68 0e 01 00 00	 push	 270			; 0000010eH
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@KKKKMHLO@pSource?9?$DOnChannels?5?$DM?$DN?50xFF?$AA@
  00054	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00057	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  0005b	33 c9		 xor	 ecx, ecx
  0005d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00062	0f 9f c1	 setg	 cl
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0006b	83 c4 10	 add	 esp, 16			; 00000010H

; 271  :     ASSERT(pSource->wBitsPerSample <= 0xFF);

  0006e	68 0f 01 00 00	 push	 271			; 0000010fH
  00073	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@PIODLKGG@pSource?9?$DOwBitsPerSample?5?$DM?$DN?50xFF?$AA@
  0007d	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00080	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00084	33 c9		 xor	 ecx, ecx
  00086	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0008b	0f 9f c1	 setg	 cl
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00094	83 c4 10	 add	 esp, 16			; 00000010H

; 272  :     ASSERT(pSource->nBlockAlign <= 0xFF);

  00097	68 10 01 00 00	 push	 272			; 00000110H
  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  000a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@OLFDGMMG@pSource?9?$DOnBlockAlign?5?$DM?$DN?50xFF?$AA@
  000a6	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  000a9	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  000ad	33 c9		 xor	 ecx, ecx
  000af	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000b4	0f 9f c1	 setg	 cl
  000b7	51		 push	 ecx
  000b8	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000bd	83 c4 10	 add	 esp, 16			; 00000010H

; 273  : 
; 274  :     pDest->wFormatTag = WAVE_FORMAT_PCM;

  000c0	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  000c3	66 c7 02 01 00	 mov	 WORD PTR [edx], 1

; 275  :     pDest->nChannels = (BYTE)pSource->nChannels;

  000c8	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000cb	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000ce	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  000d1	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 276  :     pDest->wBitsPerSample = (BYTE)pSource->wBitsPerSample;

  000d4	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000d7	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000da	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  000dd	88 50 03	 mov	 BYTE PTR [eax+3], dl

; 277  :     pDest->nSamplesPerSec = pSource->nSamplesPerSec;

  000e0	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000e3	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000e6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000e9	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 278  :     pDest->nBlockAlign = (BYTE)pSource->nBlockAlign;

  000ec	8b 45 0c	 mov	 eax, DWORD PTR _pSource$[ebp]
  000ef	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  000f3	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  000f6	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 279  : 
; 280  :     DPF_LEAVE_VOID();
; 281  : }

  000f9	5d		 pop	 ebp
  000fa	c2 08 00	 ret	 8
?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::PcmToInternalFormat
DSOUND	ENDS
PUBLIC	??_C@_0BN@IFFDBLPG@WaveFormat?3?3IsValidPcmFormat?$AA@ ; `string'
PUBLIC	??_C@_0BD@MNFLEIKF@Format?5tag?5not?5PCM?$AA@	; `string'
PUBLIC	??_C@_0BG@LMINNPNJ@Invalid?5channel?5count?$AA@	; `string'
PUBLIC	??_C@_0BO@PGNHDJHJ@Invalid?5sample?5bit?5resolution?$AA@ ; `string'
PUBLIC	??_C@_0BG@JMHMKDN@Invalid?5sampling?5rate?$AA@	; `string'
PUBLIC	??_C@_0BE@CNMNFPGH@Bad?5block?5alignment?$AA@	; `string'
;	COMDAT ??_C@_0BN@IFFDBLPG@WaveFormat?3?3IsValidPcmFormat?$AA@
DSOUND_RD	SEGMENT
??_C@_0BN@IFFDBLPG@WaveFormat?3?3IsValidPcmFormat?$AA@ DB 'WaveFormat::Is'
	DB	'ValidPcmFormat', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BD@MNFLEIKF@Format?5tag?5not?5PCM?$AA@
DSOUND_RD	SEGMENT
??_C@_0BD@MNFLEIKF@Format?5tag?5not?5PCM?$AA@ DB 'Format tag not PCM', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@LMINNPNJ@Invalid?5channel?5count?$AA@
DSOUND_RD	SEGMENT
??_C@_0BG@LMINNPNJ@Invalid?5channel?5count?$AA@ DB 'Invalid channel count'
	DB	00H						; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@PGNHDJHJ@Invalid?5sample?5bit?5resolution?$AA@
DSOUND_RD	SEGMENT
??_C@_0BO@PGNHDJHJ@Invalid?5sample?5bit?5resolution?$AA@ DB 'Invalid samp'
	DB	'le bit resolution', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BG@JMHMKDN@Invalid?5sampling?5rate?$AA@
DSOUND_RD	SEGMENT
??_C@_0BG@JMHMKDN@Invalid?5sampling?5rate?$AA@ DB 'Invalid sampling rate', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BE@CNMNFPGH@Bad?5block?5alignment?$AA@
DSOUND_RD	SEGMENT
??_C@_0BE@CNMNFPGH@Bad?5block?5alignment?$AA@ DB 'Bad block alignment', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
_fValid$ = -4
_pwfx$ = 8
?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::IsValidPcmFormat, COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 308  :     BOOL                    fValid  = TRUE;

  00004	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 1

; 309  : 
; 310  :     DPF_ENTER();
; 311  : 
; 312  :     ASSERT(pwfx);

  0000b	68 38 01 00 00	 push	 312			; 00000138H
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JNFLDEGE@pwfx?$AA@
  0001a	33 c0		 xor	 eax, eax
  0001c	83 7d 08 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  00020	0f 94 c0	 sete	 al
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00029	83 c4 10	 add	 esp, 16			; 00000010H

; 313  : 
; 314  :     if(WAVE_FORMAT_PCM != pwfx->wFormatTag)

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0002f	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00032	83 fa 01	 cmp	 edx, 1
  00035	74 34		 je	 SHORT $L35918

; 315  :     {
; 316  :         DPF_ERROR("Format tag not PCM");

  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@IFFDBLPG@WaveFormat?3?3IsValidPcmFormat?$AA@
  00041	68 3c 01 00 00	 push	 316			; 0000013cH
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0004b	6a 01		 push	 1
  0004d	6a 09		 push	 9
  0004f	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00054	83 c4 18	 add	 esp, 24			; 00000018H
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@MNFLEIKF@Format?5tag?5not?5PCM?$AA@
  0005c	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00061	83 c4 04	 add	 esp, 4

; 317  :         fValid = FALSE;

  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35918:

; 318  :     }
; 319  :     
; 320  :     if((1 != pwfx->nChannels) && (2 != pwfx->nChannels) && (4 != pwfx->nChannels) && (6 != pwfx->nChannels))

  0006b	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0006e	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00072	83 f9 01	 cmp	 ecx, 1
  00075	74 58		 je	 SHORT $L35921
  00077	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0007a	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  0007e	83 f8 02	 cmp	 eax, 2
  00081	74 4c		 je	 SHORT $L35921
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00086	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  0008a	83 fa 04	 cmp	 edx, 4
  0008d	74 40		 je	 SHORT $L35921
  0008f	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00092	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00096	83 f9 06	 cmp	 ecx, 6
  00099	74 34		 je	 SHORT $L35921

; 321  :     {
; 322  :         DPF_ERROR("Invalid channel count");

  0009b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  000a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@IFFDBLPG@WaveFormat?3?3IsValidPcmFormat?$AA@
  000a5	68 42 01 00 00	 push	 322			; 00000142H
  000aa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  000af	6a 01		 push	 1
  000b1	6a 09		 push	 9
  000b3	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000b8	83 c4 18	 add	 esp, 24			; 00000018H
  000bb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@LMINNPNJ@Invalid?5channel?5count?$AA@
  000c0	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000c5	83 c4 04	 add	 esp, 4

; 323  :         fValid = FALSE;

  000c8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35921:

; 324  :     }
; 325  : 
; 326  :     if((8 != pwfx->wBitsPerSample) && (16 != pwfx->wBitsPerSample))

  000cf	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  000d2	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  000d6	83 f8 08	 cmp	 eax, 8
  000d9	74 40		 je	 SHORT $L35923
  000db	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  000de	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  000e2	83 fa 10	 cmp	 edx, 16			; 00000010H
  000e5	74 34		 je	 SHORT $L35923

; 327  :     {
; 328  :         DPF_ERROR("Invalid sample bit resolution");

  000e7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  000ec	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@IFFDBLPG@WaveFormat?3?3IsValidPcmFormat?$AA@
  000f1	68 48 01 00 00	 push	 328			; 00000148H
  000f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  000fb	6a 01		 push	 1
  000fd	6a 09		 push	 9
  000ff	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00104	83 c4 18	 add	 esp, 24			; 00000018H
  00107	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@PGNHDJHJ@Invalid?5sample?5bit?5resolution?$AA@
  0010c	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00111	83 c4 04	 add	 esp, 4

; 329  :         fValid = FALSE;

  00114	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35923:

; 330  :     }
; 331  : 
; 332  :     if((pwfx->nSamplesPerSec < DSBFREQUENCY_MIN) || (pwfx->nSamplesPerSec > DSBFREQUENCY_MAX))

  0011b	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0011e	81 78 04 bc 00
	00 00		 cmp	 DWORD PTR [eax+4], 188	; 000000bcH
  00125	72 0c		 jb	 SHORT $L35926
  00127	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0012a	81 79 04 ef ed
	02 00		 cmp	 DWORD PTR [ecx+4], 191983 ; 0002edefH
  00131	76 34		 jbe	 SHORT $L35925
$L35926:

; 333  :     {
; 334  :         DPF_ERROR("Invalid sampling rate");

  00133	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  00138	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@IFFDBLPG@WaveFormat?3?3IsValidPcmFormat?$AA@
  0013d	68 4e 01 00 00	 push	 334			; 0000014eH
  00142	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00147	6a 01		 push	 1
  00149	6a 09		 push	 9
  0014b	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00150	83 c4 18	 add	 esp, 24			; 00000018H
  00153	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@JMHMKDN@Invalid?5sampling?5rate?$AA@
  00158	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0015d	83 c4 04	 add	 esp, 4

; 335  :         fValid = FALSE;

  00160	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35925:

; 336  :     }
; 337  : 
; 338  :     if(pwfx->nChannels * pwfx->wBitsPerSample / 8 != pwfx->nBlockAlign)

  00167	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0016a	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  0016e	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00171	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  00175	0f af c2	 imul	 eax, edx
  00178	99		 cdq
  00179	83 e2 07	 and	 edx, 7
  0017c	03 c2		 add	 eax, edx
  0017e	c1 f8 03	 sar	 eax, 3
  00181	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00184	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00188	3b c2		 cmp	 eax, edx
  0018a	74 34		 je	 SHORT $L35928

; 339  :     {
; 340  :         DPF_ERROR("Bad block alignment");

  0018c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  00191	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@IFFDBLPG@WaveFormat?3?3IsValidPcmFormat?$AA@
  00196	68 54 01 00 00	 push	 340			; 00000154H
  0019b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  001a0	6a 01		 push	 1
  001a2	6a 09		 push	 9
  001a4	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  001a9	83 c4 18	 add	 esp, 24			; 00000018H
  001ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@CNMNFPGH@Bad?5block?5alignment?$AA@
  001b1	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001b6	83 c4 04	 add	 esp, 4

; 341  :         fValid = FALSE;

  001b9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35928:

; 342  :     }
; 343  : 
; 344  :     DPF_LEAVE(fValid);
; 345  : 
; 346  :     return fValid;

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _fValid$[ebp]

; 347  : }

  001c3	8b e5		 mov	 esp, ebp
  001c5	5d		 pop	 ebp
  001c6	c2 04 00	 ret	 4
?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::IsValidPcmFormat
DSOUND	ENDS
PUBLIC	??_C@_0BP@BHADMBB@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@ ; `string'
PUBLIC	??_C@_0CE@JGBOPGED@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@ ; `string'
PUBLIC	??_C@_0CB@OIKDEMKO@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@ ; `string'
;	COMDAT ??_C@_0BP@BHADMBB@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@
DSOUND_RD	SEGMENT
??_C@_0BP@BHADMBB@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@ DB 'pS'
	DB	'ource->wfx.nChannels <= 0xFF', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@JGBOPGED@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@
DSOUND_RD	SEGMENT
??_C@_0CE@JGBOPGED@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@ DB 'pSo'
	DB	'urce->wfx.wBitsPerSample <= 0xFF', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@OIKDEMKO@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@
DSOUND_RD	SEGMENT
??_C@_0CB@OIKDEMKO@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@ DB 'pSo'
	DB	'urce->wfx.nBlockAlign <= 0xFF', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT
_pDest$ = 8
_pSource$ = 12
?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::WaveFormat::AdpcmToInternalFormat, COMDAT

; 376  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 377  :     static const BYTE       wBitsPerSample      = 4;
; 378  : 
; 379  :     DPF_ENTER();
; 380  : 
; 381  :     ASSERT(pDest);

  00003	68 7d 01 00 00	 push	 381			; 0000017dH
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05PJHAMANO@pDest?$AA@
  00012	33 c0		 xor	 eax, eax
  00014	83 7d 08 00	 cmp	 DWORD PTR _pDest$[ebp], 0
  00018	0f 94 c0	 sete	 al
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 382  :     ASSERT(pSource);

  00024	68 7e 01 00 00	 push	 382			; 0000017eH
  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07HPANBCJA@pSource?$AA@
  00033	33 c9		 xor	 ecx, ecx
  00035	83 7d 0c 00	 cmp	 DWORD PTR _pSource$[ebp], 0
  00039	0f 94 c1	 sete	 cl
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00042	83 c4 10	 add	 esp, 16			; 00000010H

; 383  : 
; 384  :     ASSERT(pSource->wfx.nChannels <= 0xFF);

  00045	68 80 01 00 00	 push	 384			; 00000180H
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BHADMBB@pSource?9?$DOwfx?4nChannels?5?$DM?$DN?50xFF?$AA@
  00054	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00057	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  0005b	33 c9		 xor	 ecx, ecx
  0005d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00062	0f 9f c1	 setg	 cl
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0006b	83 c4 10	 add	 esp, 16			; 00000010H

; 385  :     ASSERT(pSource->wfx.wBitsPerSample <= 0xFF);

  0006e	68 81 01 00 00	 push	 385			; 00000181H
  00073	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@JGBOPGED@pSource?9?$DOwfx?4wBitsPerSample?5?$DM?$DN?50@
  0007d	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00080	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00084	33 c9		 xor	 ecx, ecx
  00086	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0008b	0f 9f c1	 setg	 cl
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00094	83 c4 10	 add	 esp, 16			; 00000010H

; 386  :     ASSERT(pSource->wfx.nBlockAlign <= 0xFF);

  00097	68 82 01 00 00	 push	 386			; 00000182H
  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  000a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@OIKDEMKO@pSource?9?$DOwfx?4nBlockAlign?5?$DM?$DN?50xFF@
  000a6	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  000a9	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  000ad	33 c9		 xor	 ecx, ecx
  000af	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000b4	0f 9f c1	 setg	 cl
  000b7	51		 push	 ecx
  000b8	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000bd	83 c4 10	 add	 esp, 16			; 00000010H

; 387  : 
; 388  :     pDest->wFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  000c0	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  000c3	66 c7 02 69 00	 mov	 WORD PTR [edx], 105	; 00000069H

; 389  :     pDest->nChannels = (BYTE)pSource->wfx.nChannels;

  000c8	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000cb	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000ce	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  000d1	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 390  :     pDest->wBitsPerSample = (BYTE)wBitsPerSample;

  000d4	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000d7	c6 40 03 04	 mov	 BYTE PTR [eax+3], 4

; 391  :     pDest->nSamplesPerSec = pSource->wfx.nSamplesPerSec;

  000db	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  000de	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  000e1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000e4	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 392  :     pDest->nBlockAlign = (BYTE)pSource->wfx.nBlockAlign;

  000e7	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  000ea	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  000ee	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  000f1	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 393  : 
; 394  :     DPF_LEAVE_VOID();
; 395  : }

  000f4	5d		 pop	 ebp
  000f5	c2 08 00	 ret	 8
?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::WaveFormat::AdpcmToInternalFormat
DSOUND	ENDS
PUBLIC	??_C@_0BP@DHOFLMLF@WaveFormat?3?3IsValidAdpcmFormat?$AA@ ; `string'
PUBLIC	??_C@_0BK@IAKEEFCK@Format?5tag?5not?5XBOX_ADPCM?$AA@ ; `string'
PUBLIC	??_C@_0P@NDFBNMGN@cbSize?5not?5?$CFlu?$AA@	; `string'
PUBLIC	??_C@_0BK@COGBELGK@Invalid?5samples?5per?5block?$AA@ ; `string'
PUBLIC	??_C@_0BE@OGFJBCGA@Bad?5block?9alignment?$AA@	; `string'
;	COMDAT ??_C@_0BP@DHOFLMLF@WaveFormat?3?3IsValidAdpcmFormat?$AA@
DSOUND_RD	SEGMENT
??_C@_0BP@DHOFLMLF@WaveFormat?3?3IsValidAdpcmFormat?$AA@ DB 'WaveFormat::'
	DB	'IsValidAdpcmFormat', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@IAKEEFCK@Format?5tag?5not?5XBOX_ADPCM?$AA@
DSOUND_RD	SEGMENT
??_C@_0BK@IAKEEFCK@Format?5tag?5not?5XBOX_ADPCM?$AA@ DB 'Format tag not X'
	DB	'BOX_ADPCM', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0P@NDFBNMGN@cbSize?5not?5?$CFlu?$AA@
DSOUND_RD	SEGMENT
??_C@_0P@NDFBNMGN@cbSize?5not?5?$CFlu?$AA@ DB 'cbSize not %lu', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@COGBELGK@Invalid?5samples?5per?5block?$AA@
DSOUND_RD	SEGMENT
??_C@_0BK@COGBELGK@Invalid?5samples?5per?5block?$AA@ DB 'Invalid samples '
	DB	'per block', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BE@OGFJBCGA@Bad?5block?9alignment?$AA@
DSOUND_RD	SEGMENT
??_C@_0BE@OGFJBCGA@Bad?5block?9alignment?$AA@ DB 'Bad block-alignment', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT
_fValid$ = -4
_pwfx$ = 8
?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::WaveFormat::IsValidAdpcmFormat, COMDAT

; 421  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 422  :     static const WORD       wSamplesPerBlock    = 64;
; 423  :     static const WORD       wBitsPerSample      = 4;
; 424  :     static const WORD       wBytesPerBlock      = 36;
; 425  :     BOOL                    fValid              = TRUE;

  00004	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 1

; 426  : 
; 427  :     DPF_ENTER();
; 428  : 
; 429  :     ASSERT(pwfx);

  0000b	68 ad 01 00 00	 push	 429			; 000001adH
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JNFLDEGE@pwfx?$AA@
  0001a	33 c0		 xor	 eax, eax
  0001c	83 7d 08 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  00020	0f 94 c0	 sete	 al
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00029	83 c4 10	 add	 esp, 16			; 00000010H

; 430  : 
; 431  :     if(WAVE_FORMAT_XBOX_ADPCM != pwfx->wfx.wFormatTag)

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0002f	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00032	83 fa 69	 cmp	 edx, 105		; 00000069H
  00035	74 34		 je	 SHORT $L35952

; 432  :     {
; 433  :         DPF_ERROR("Format tag not XBOX_ADPCM");

  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DHOFLMLF@WaveFormat?3?3IsValidAdpcmFormat?$AA@
  00041	68 b1 01 00 00	 push	 433			; 000001b1H
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0004b	6a 01		 push	 1
  0004d	6a 09		 push	 9
  0004f	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00054	83 c4 18	 add	 esp, 24			; 00000018H
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@IAKEEFCK@Format?5tag?5not?5XBOX_ADPCM?$AA@
  0005c	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00061	83 c4 04	 add	 esp, 4

; 434  :         fValid = FALSE;

  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35952:

; 435  :     }
; 436  :     
; 437  :     if(sizeof(*pwfx) - sizeof(pwfx->wfx) != pwfx->wfx.cbSize)

  0006b	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0006e	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  00072	83 f9 02	 cmp	 ecx, 2
  00075	74 36		 je	 SHORT $L35955

; 438  :     {
; 439  :         DPF_ERROR("cbSize not %lu", sizeof(*pwfx) - sizeof(pwfx->wfx));

  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DHOFLMLF@WaveFormat?3?3IsValidAdpcmFormat?$AA@
  00081	68 b7 01 00 00	 push	 439			; 000001b7H
  00086	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0008b	6a 01		 push	 1
  0008d	6a 09		 push	 9
  0008f	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00094	83 c4 18	 add	 esp, 24			; 00000018H
  00097	6a 02		 push	 2
  00099	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@NDFBNMGN@cbSize?5not?5?$CFlu?$AA@
  0009e	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000a3	83 c4 08	 add	 esp, 8

; 440  :         fValid = FALSE;

  000a6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35955:

; 441  :     }
; 442  :     
; 443  :     if((pwfx->wfx.nChannels < 1) || (pwfx->wfx.nChannels > 2))

  000ad	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  000b0	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  000b4	83 f8 01	 cmp	 eax, 1
  000b7	7c 0c		 jl	 SHORT $L35958
  000b9	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  000bc	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  000c0	83 fa 02	 cmp	 edx, 2
  000c3	7e 34		 jle	 SHORT $L35957
$L35958:

; 444  :     {
; 445  :         DPF_ERROR("Invalid channel count");

  000c5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  000ca	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DHOFLMLF@WaveFormat?3?3IsValidAdpcmFormat?$AA@
  000cf	68 bd 01 00 00	 push	 445			; 000001bdH
  000d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  000d9	6a 01		 push	 1
  000db	6a 09		 push	 9
  000dd	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000e2	83 c4 18	 add	 esp, 24			; 00000018H
  000e5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@LMINNPNJ@Invalid?5channel?5count?$AA@
  000ea	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000ef	83 c4 04	 add	 esp, 4

; 446  :         fValid = FALSE;

  000f2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35957:

; 447  :     }
; 448  : 
; 449  :     if((pwfx->wfx.nSamplesPerSec < DSBFREQUENCY_MIN) || (pwfx->wfx.nSamplesPerSec > DSBFREQUENCY_MAX))

  000f9	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  000fc	81 78 04 bc 00
	00 00		 cmp	 DWORD PTR [eax+4], 188	; 000000bcH
  00103	72 0c		 jb	 SHORT $L35960
  00105	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00108	81 79 04 ef ed
	02 00		 cmp	 DWORD PTR [ecx+4], 191983 ; 0002edefH
  0010f	76 34		 jbe	 SHORT $L35959
$L35960:

; 450  :     {
; 451  :         DPF_ERROR("Invalid sampling rate");

  00111	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  00116	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DHOFLMLF@WaveFormat?3?3IsValidAdpcmFormat?$AA@
  0011b	68 c3 01 00 00	 push	 451			; 000001c3H
  00120	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00125	6a 01		 push	 1
  00127	6a 09		 push	 9
  00129	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0012e	83 c4 18	 add	 esp, 24			; 00000018H
  00131	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@JMHMKDN@Invalid?5sampling?5rate?$AA@
  00136	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0013b	83 c4 04	 add	 esp, 4

; 452  :         fValid = FALSE;

  0013e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35959:

; 453  :     }
; 454  : 
; 455  :     if(wBitsPerSample != pwfx->wfx.wBitsPerSample)

  00145	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00148	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  0014c	83 f8 04	 cmp	 eax, 4
  0014f	74 34		 je	 SHORT $L35961

; 456  :     {
; 457  :         DPF_ERROR("Invalid sample bit resolution");

  00151	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  00156	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DHOFLMLF@WaveFormat?3?3IsValidAdpcmFormat?$AA@
  0015b	68 c9 01 00 00	 push	 457			; 000001c9H
  00160	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00165	6a 01		 push	 1
  00167	6a 09		 push	 9
  00169	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0016e	83 c4 18	 add	 esp, 24			; 00000018H
  00171	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@PGNHDJHJ@Invalid?5sample?5bit?5resolution?$AA@
  00176	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0017b	83 c4 04	 add	 esp, 4

; 458  :         fValid = FALSE;

  0017e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35961:

; 459  :     }
; 460  : 
; 461  :     if(wSamplesPerBlock != pwfx->wSamplesPerBlock)

  00185	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00188	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  0018c	83 fa 40	 cmp	 edx, 64			; 00000040H
  0018f	74 34		 je	 SHORT $L35962

; 462  :     {
; 463  :         DPF_ERROR("Invalid samples per block");

  00191	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  00196	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DHOFLMLF@WaveFormat?3?3IsValidAdpcmFormat?$AA@
  0019b	68 cf 01 00 00	 push	 463			; 000001cfH
  001a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  001a5	6a 01		 push	 1
  001a7	6a 09		 push	 9
  001a9	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  001ae	83 c4 18	 add	 esp, 24			; 00000018H
  001b1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@COGBELGK@Invalid?5samples?5per?5block?$AA@
  001b6	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001bb	83 c4 04	 add	 esp, 4

; 464  :         fValid = FALSE;

  001be	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35962:

; 465  :     }
; 466  : 
; 467  :     if(wBytesPerBlock * pwfx->wfx.nChannels != pwfx->wfx.nBlockAlign)

  001c5	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  001c8	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  001cc	6b c9 24	 imul	 ecx, 36			; 00000024H
  001cf	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  001d2	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  001d6	3b c8		 cmp	 ecx, eax
  001d8	74 34		 je	 SHORT $L35964

; 468  :     {
; 469  :         DPF_ERROR("Bad block-alignment");

  001da	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  001df	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DHOFLMLF@WaveFormat?3?3IsValidAdpcmFormat?$AA@
  001e4	68 d5 01 00 00	 push	 469			; 000001d5H
  001e9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  001ee	6a 01		 push	 1
  001f0	6a 09		 push	 9
  001f2	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  001f7	83 c4 18	 add	 esp, 24			; 00000018H
  001fa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OGFJBCGA@Bad?5block?9alignment?$AA@
  001ff	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00204	83 c4 04	 add	 esp, 4

; 470  :         fValid = FALSE;

  00207	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35964:

; 471  :     }
; 472  : 
; 473  :     DPF_LEAVE(fValid);
; 474  : 
; 475  :     return fValid;

  0020e	8b 45 fc	 mov	 eax, DWORD PTR _fValid$[ebp]

; 476  : }

  00211	8b e5		 mov	 esp, ebp
  00213	5d		 pop	 ebp
  00214	c2 04 00	 ret	 4
?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::WaveFormat::IsValidAdpcmFormat
DSOUND	ENDS
PUBLIC	_IsEqualGUID@8
PUBLIC	??_C@_0BF@GEHOBCDM@Unexpected?5subformat?$AA@	; `string'
EXTRN	_KSDATAFORMAT_SUBTYPE_PCM:BYTE
EXTRN	_KSDATAFORMAT_SUBTYPE_XBOX_ADPCM:BYTE
;	COMDAT ??_C@_0BF@GEHOBCDM@Unexpected?5subformat?$AA@
DSOUND_RD	SEGMENT
??_C@_0BF@GEHOBCDM@Unexpected?5subformat?$AA@ DB 'Unexpected subformat', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?ExtensibleToInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUWAVEFORMATEXTENSIBLE@@@Z
DSOUND	SEGMENT
_pDest$ = 8
_pSource$ = 12
?ExtensibleToInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUWAVEFORMATEXTENSIBLE@@@Z PROC NEAR ; DirectSound::WaveFormat::ExtensibleToInternalFormat, COMDAT

; 507  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 508  :     DPF_ENTER();
; 509  : 
; 510  :     ASSERT(pDest);

  00003	68 fe 01 00 00	 push	 510			; 000001feH
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05PJHAMANO@pDest?$AA@
  00012	33 c0		 xor	 eax, eax
  00014	83 7d 08 00	 cmp	 DWORD PTR _pDest$[ebp], 0
  00018	0f 94 c0	 sete	 al
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 511  :     ASSERT(pSource);

  00024	68 ff 01 00 00	 push	 511			; 000001ffH
  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07HPANBCJA@pSource?$AA@
  00033	33 c9		 xor	 ecx, ecx
  00035	83 7d 0c 00	 cmp	 DWORD PTR _pSource$[ebp], 0
  00039	0f 94 c1	 sete	 cl
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00042	83 c4 10	 add	 esp, 16			; 00000010H

; 512  : 
; 513  :     if(IsEqualGUID(pSource->SubFormat, KSDATAFORMAT_SUBTYPE_PCM))

  00045	68 00 00 00 00	 push	 OFFSET FLAT:_KSDATAFORMAT_SUBTYPE_PCM
  0004a	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  0004d	83 c2 18	 add	 edx, 24			; 00000018H
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 _IsEqualGUID@8
  00056	85 c0		 test	 eax, eax
  00058	74 0f		 je	 SHORT $L35970

; 514  :     {
; 515  :         PcmToInternalFormat(pDest, &pSource->Format);

  0005a	8b 45 0c	 mov	 eax, DWORD PTR _pSource$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::PcmToInternalFormat

; 516  :     }
; 517  :     else if(IsEqualGUID(pSource->SubFormat, KSDATAFORMAT_SUBTYPE_XBOX_ADPCM))

  00067	eb 3d		 jmp	 SHORT $L35971
$L35970:
  00069	68 00 00 00 00	 push	 OFFSET FLAT:_KSDATAFORMAT_SUBTYPE_XBOX_ADPCM
  0006e	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00071	83 c2 18	 add	 edx, 24			; 00000018H
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 _IsEqualGUID@8
  0007a	85 c0		 test	 eax, eax
  0007c	74 0f		 je	 SHORT $L35972

; 518  :     {
; 519  :         AdpcmToInternalFormat(pDest, (LPCXBOXADPCMWAVEFORMAT)&pSource->Format);

  0007e	8b 45 0c	 mov	 eax, DWORD PTR _pSource$[ebp]
  00081	50		 push	 eax
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 ?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::AdpcmToInternalFormat

; 520  :     }
; 521  :     else

  0008b	eb 19		 jmp	 SHORT $L35971
$L35972:

; 522  :     {
; 523  :         ASSERTMSG("Unexpected subformat");

  0008d	68 0b 02 00 00	 push	 523			; 0000020bH
  00092	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00097	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@GEHOBCDM@Unexpected?5subformat?$AA@
  0009c	6a 01		 push	 1
  0009e	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  000a3	83 c4 10	 add	 esp, 16			; 00000010H
$L35971:

; 524  :     }
; 525  : 
; 526  :     DPF_LEAVE(pSource->dwChannelMask);
; 527  : 
; 528  :     return pSource->dwChannelMask;

  000a6	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  000a9	8b 42 14	 mov	 eax, DWORD PTR [edx+20]

; 529  : }

  000ac	5d		 pop	 ebp
  000ad	c2 08 00	 ret	 8
?ExtensibleToInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUWAVEFORMATEXTENSIBLE@@@Z ENDP ; DirectSound::WaveFormat::ExtensibleToInternalFormat
DSOUND	ENDS
EXTRN	_memcmp:NEAR
; Function compile flags: /Odt
; File c:\xbox\public\sdk\inc\guiddef.h
;	COMDAT _IsEqualGUID@8
DSOUND	SEGMENT
_rguid1$ = 8
_rguid2$ = 12
_IsEqualGUID@8 PROC NEAR				; COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 156  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _rguid2$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _rguid1$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _memcmp
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	f7 d8		 neg	 eax
  00017	1b c0		 sbb	 eax, eax
  00019	40		 inc	 eax

; 157  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_IsEqualGUID@8 ENDP
DSOUND	ENDS
PUBLIC	??_C@_0CE@BDDCNENN@WaveFormat?3?3IsValidExtensibleFor@ ; `string'
PUBLIC	??_C@_0BK@FCNDIHOL@Format?5tag?5not?5EXTENSIBLE?$AA@ ; `string'
PUBLIC	??_C@_0CO@KKIDLDBA@wValidBitsPerSample?5must?5equal?5w@ ; `string'
PUBLIC	??_C@_0CE@OINPDAHG@wReserved?5must?5be?50?5for?5SUBTYPE_@ ; `string'
PUBLIC	??_C@_0BO@BCDFCNJM@Invalid?5sub?9format?5identifier?$AA@ ; `string'
PUBLIC	??_C@_0BF@JKCBDHDB@Invalid?5channel?5mask?$AA@	; `string'
;	COMDAT ??_C@_0CE@BDDCNENN@WaveFormat?3?3IsValidExtensibleFor@
; File c:\xbox\private\windows\directx\dsound\common\format.cpp
DSOUND_RD	SEGMENT
??_C@_0CE@BDDCNENN@WaveFormat?3?3IsValidExtensibleFor@ DB 'WaveFormat::Is'
	DB	'ValidExtensibleFormat', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@FCNDIHOL@Format?5tag?5not?5EXTENSIBLE?$AA@
DSOUND_RD	SEGMENT
??_C@_0BK@FCNDIHOL@Format?5tag?5not?5EXTENSIBLE?$AA@ DB 'Format tag not E'
	DB	'XTENSIBLE', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CO@KKIDLDBA@wValidBitsPerSample?5must?5equal?5w@
DSOUND_RD	SEGMENT
??_C@_0CO@KKIDLDBA@wValidBitsPerSample?5must?5equal?5w@ DB 'wValidBitsPer'
	DB	'Sample must equal wBitsPerSample', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@OINPDAHG@wReserved?5must?5be?50?5for?5SUBTYPE_@
DSOUND_RD	SEGMENT
??_C@_0CE@OINPDAHG@wReserved?5must?5be?50?5for?5SUBTYPE_@ DB 'wReserved m'
	DB	'ust be 0 for SUBTYPE_PCM', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@BCDFCNJM@Invalid?5sub?9format?5identifier?$AA@
DSOUND_RD	SEGMENT
??_C@_0BO@BCDFCNJM@Invalid?5sub?9format?5identifier?$AA@ DB 'Invalid sub-'
	DB	'format identifier', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BF@JKCBDHDB@Invalid?5channel?5mask?$AA@
DSOUND_RD	SEGMENT
??_C@_0BF@JKCBDHDB@Invalid?5channel?5mask?$AA@ DB 'Invalid channel mask', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?IsValidExtensibleFormat@WaveFormat@DirectSound@@YGHPBUWAVEFORMATEXTENSIBLE@@@Z
DSOUND	SEGMENT
_fValid$ = -4
_pwfx$ = 8
?IsValidExtensibleFormat@WaveFormat@DirectSound@@YGHPBUWAVEFORMATEXTENSIBLE@@@Z PROC NEAR ; DirectSound::WaveFormat::IsValidExtensibleFormat, COMDAT

; 559  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 560  :     BOOL                    fValid  = TRUE;

  00004	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 1

; 561  : 
; 562  :     DPF_ENTER();
; 563  : 
; 564  :     ASSERT(pwfx);

  0000b	68 34 02 00 00	 push	 564			; 00000234H
  00010	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JNFLDEGE@pwfx?$AA@
  0001a	33 c0		 xor	 eax, eax
  0001c	83 7d 08 00	 cmp	 DWORD PTR _pwfx$[ebp], 0
  00020	0f 94 c0	 sete	 al
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00029	83 c4 10	 add	 esp, 16			; 00000010H

; 565  : 
; 566  :     if(WAVE_FORMAT_EXTENSIBLE != pwfx->Format.wFormatTag)

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0002f	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00032	81 fa fe ff 00
	00		 cmp	 edx, 65534		; 0000fffeH
  00038	74 34		 je	 SHORT $L35980

; 567  :     {
; 568  :         DPF_ERROR("Format tag not EXTENSIBLE");

  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@BDDCNENN@WaveFormat?3?3IsValidExtensibleFor@
  00044	68 38 02 00 00	 push	 568			; 00000238H
  00049	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0004e	6a 01		 push	 1
  00050	6a 09		 push	 9
  00052	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00057	83 c4 18	 add	 esp, 24			; 00000018H
  0005a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@FCNDIHOL@Format?5tag?5not?5EXTENSIBLE?$AA@
  0005f	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00064	83 c4 04	 add	 esp, 4

; 569  :         fValid = FALSE;

  00067	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35980:

; 570  :     }
; 571  :     
; 572  :     if(sizeof(*pwfx) - sizeof(pwfx->Format) != pwfx->Format.cbSize)

  0006e	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00071	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  00075	83 f9 16	 cmp	 ecx, 22			; 00000016H
  00078	74 36		 je	 SHORT $L35983

; 573  :     {
; 574  :         DPF_ERROR("cbSize not %lu", sizeof(*pwfx) - sizeof(pwfx->Format));

  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  0007f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@BDDCNENN@WaveFormat?3?3IsValidExtensibleFor@
  00084	68 3e 02 00 00	 push	 574			; 0000023eH
  00089	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  0008e	6a 01		 push	 1
  00090	6a 09		 push	 9
  00092	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00097	83 c4 18	 add	 esp, 24			; 00000018H
  0009a	6a 16		 push	 22			; 00000016H
  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@NDFBNMGN@cbSize?5not?5?$CFlu?$AA@
  000a1	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000a6	83 c4 08	 add	 esp, 8

; 575  :         fValid = FALSE;

  000a9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35983:

; 576  :     }
; 577  :     
; 578  :     if(IsEqualGUID(pwfx->SubFormat, KSDATAFORMAT_SUBTYPE_PCM))

  000b0	68 00 00 00 00	 push	 OFFSET FLAT:_KSDATAFORMAT_SUBTYPE_PCM
  000b5	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  000b8	83 c2 18	 add	 edx, 24			; 00000018H
  000bb	52		 push	 edx
  000bc	e8 00 00 00 00	 call	 _IsEqualGUID@8
  000c1	85 c0		 test	 eax, eax
  000c3	0f 84 9b 00 00
	00		 je	 $L35984

; 579  :     {
; 580  :         if(!IsValidPcmFormat(&pwfx->Format))

  000c9	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::IsValidPcmFormat
  000d2	85 c0		 test	 eax, eax
  000d4	75 07		 jne	 SHORT $L35985

; 581  :         {
; 582  :             fValid = FALSE;

  000d6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35985:

; 583  :         }
; 584  : 
; 585  :         if(pwfx->Samples.wValidBitsPerSample != pwfx->Format.wBitsPerSample)

  000dd	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  000e0	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  000e4	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  000e7	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  000eb	3b d1		 cmp	 edx, ecx
  000ed	74 34		 je	 SHORT $L35986

; 586  :         {
; 587  :             DPF_ERROR("wValidBitsPerSample must equal wBitsPerSample");

  000ef	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  000f4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@BDDCNENN@WaveFormat?3?3IsValidExtensibleFor@
  000f9	68 4b 02 00 00	 push	 587			; 0000024bH
  000fe	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00103	6a 01		 push	 1
  00105	6a 09		 push	 9
  00107	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0010c	83 c4 18	 add	 esp, 24			; 00000018H
  0010f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CO@KKIDLDBA@wValidBitsPerSample?5must?5equal?5w@
  00114	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00119	83 c4 04	 add	 esp, 4

; 588  :             fValid = FALSE;

  0011c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35986:

; 589  :         }
; 590  : 
; 591  :         if(pwfx->Samples.wReserved)

  00123	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00126	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  0012a	85 c0		 test	 eax, eax
  0012c	74 34		 je	 SHORT $L35988

; 592  :         {
; 593  :             DPF_ERROR("wReserved must be 0 for SUBTYPE_PCM");

  0012e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  00133	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@BDDCNENN@WaveFormat?3?3IsValidExtensibleFor@
  00138	68 51 02 00 00	 push	 593			; 00000251H
  0013d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  00142	6a 01		 push	 1
  00144	6a 09		 push	 9
  00146	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0014b	83 c4 18	 add	 esp, 24			; 00000018H
  0014e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@OINPDAHG@wReserved?5must?5be?50?5for?5SUBTYPE_@
  00153	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00158	83 c4 04	 add	 esp, 4

; 594  :             fValid = FALSE;

  0015b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35988:

; 595  :         }
; 596  :     }
; 597  :     else if(IsEqualGUID(pwfx->SubFormat, KSDATAFORMAT_SUBTYPE_XBOX_ADPCM))

  00162	eb 5f		 jmp	 SHORT $L35990
$L35984:
  00164	68 00 00 00 00	 push	 OFFSET FLAT:_KSDATAFORMAT_SUBTYPE_XBOX_ADPCM
  00169	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0016c	83 c1 18	 add	 ecx, 24			; 00000018H
  0016f	51		 push	 ecx
  00170	e8 00 00 00 00	 call	 _IsEqualGUID@8
  00175	85 c0		 test	 eax, eax
  00177	74 16		 je	 SHORT $L35991

; 598  :     {
; 599  :         if(!IsValidAdpcmFormat((LPCXBOXADPCMWAVEFORMAT)&pwfx->Format))

  00179	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0017c	52		 push	 edx
  0017d	e8 00 00 00 00	 call	 ?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::IsValidAdpcmFormat
  00182	85 c0		 test	 eax, eax
  00184	75 07		 jne	 SHORT $L35993

; 600  :         {
; 601  :             fValid = FALSE;

  00186	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35993:

; 602  :         }
; 603  :     }
; 604  :     else

  0018d	eb 34		 jmp	 SHORT $L35990
$L35991:

; 605  :     {
; 606  :         DPF_ERROR("Invalid sub-format identifier");

  0018f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  00194	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@BDDCNENN@WaveFormat?3?3IsValidExtensibleFor@
  00199	68 5e 02 00 00	 push	 606			; 0000025eH
  0019e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  001a3	6a 01		 push	 1
  001a5	6a 09		 push	 9
  001a7	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  001ac	83 c4 18	 add	 esp, 24			; 00000018H
  001af	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@BCDFCNJM@Invalid?5sub?9format?5identifier?$AA@
  001b4	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001b9	83 c4 04	 add	 esp, 4

; 607  :         fValid = FALSE;

  001bc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35990:

; 608  :     }
; 609  : 
; 610  :     if(pwfx->dwChannelMask & ~SPEAKER_MASK)

  001c3	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  001c6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001c9	83 e1 c0	 and	 ecx, -64		; ffffffc0H
  001cc	85 c9		 test	 ecx, ecx
  001ce	74 34		 je	 SHORT $L35996

; 611  :     {
; 612  :         DPF_ERROR("Invalid channel mask");

  001d0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  001d5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@BDDCNENN@WaveFormat?3?3IsValidExtensibleFor@
  001da	68 64 02 00 00	 push	 612			; 00000264H
  001df	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@LEFGDCFI@c?3?2xbox?2private?2windows?2directx?2@
  001e4	6a 01		 push	 1
  001e6	6a 09		 push	 9
  001e8	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  001ed	83 c4 18	 add	 esp, 24			; 00000018H
  001f0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@JKCBDHDB@Invalid?5channel?5mask?$AA@
  001f5	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  001fa	83 c4 04	 add	 esp, 4

; 613  :         fValid = FALSE;

  001fd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35996:

; 614  :     }
; 615  : 
; 616  :     DPF_LEAVE(fValid);
; 617  : 
; 618  :     return fValid;

  00204	8b 45 fc	 mov	 eax, DWORD PTR _fValid$[ebp]

; 619  : }

  00207	8b e5		 mov	 esp, ebp
  00209	5d		 pop	 ebp
  0020a	c2 04 00	 ret	 4
?IsValidExtensibleFormat@WaveFormat@DirectSound@@YGHPBUWAVEFORMATEXTENSIBLE@@@Z ENDP ; DirectSound::WaveFormat::IsValidExtensibleFormat
DSOUND	ENDS
PUBLIC	??0CStdFileStream@WaveLoader@@QAE@XZ		; WaveLoader::CStdFileStream::CStdFileStream
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\waveldr.cpp
;	COMDAT ??0CStdFileStream@WaveLoader@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CStdFileStream@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CStdFileStream::CStdFileStream, COMDAT
; _this$ = ecx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 102  :     DPF_ENTER();
; 103  : 
; 104  :     //
; 105  :     // Initialize defaults
; 106  :     //
; 107  : 
; 108  :     m_hFile = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 109  :     m_dwFlags = 0;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 110  : 
; 111  :     DPF_LEAVE_VOID();
; 112  : }

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0CStdFileStream@WaveLoader@@QAE@XZ ENDP		; WaveLoader::CStdFileStream::CStdFileStream
DSOUND	ENDS
PUBLIC	??1CStdFileStream@WaveLoader@@QAE@XZ		; WaveLoader::CStdFileStream::~CStdFileStream
PUBLIC	?Close@CStdFileStream@WaveLoader@@QAEXXZ	; WaveLoader::CStdFileStream::Close
; Function compile flags: /Odt
;	COMDAT ??1CStdFileStream@WaveLoader@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CStdFileStream@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CStdFileStream::~CStdFileStream, COMDAT
; _this$ = ecx

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 138  :     DPF_ENTER();
; 139  : 
; 140  :     Close();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Close@CStdFileStream@WaveLoader@@QAEXXZ ; WaveLoader::CStdFileStream::Close

; 141  : 
; 142  :     DPF_LEAVE_VOID();
; 143  : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CStdFileStream@WaveLoader@@QAE@XZ ENDP		; WaveLoader::CStdFileStream::~CStdFileStream
DSOUND	ENDS
PUBLIC	??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0CA@KOCFKEKK@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BF@IINNEHHF@CStdFileStream?3?3Open?$AA@	; `string'
PUBLIC	??_C@_0CF@CEKMADFG@Error?5?$CFlu?5occurred?5trying?5to?5ope@ ; `string'
PUBLIC	?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z	; WaveLoader::CStdFileStream::Open
EXTRN	_GetLastError@0:NEAR
EXTRN	_CreateFileA@28:NEAR
;	COMDAT ??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
DSOUND_RD	SEGMENT
??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dsound\common\waveldr.cpp', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CA@KOCFKEKK@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
DSOUND_RD	SEGMENT
??_C@_0CA@KOCFKEKK@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ DB '!IS_'
	DB	'VALID_HANDLE_VALUE(m_hFile)', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BF@IINNEHHF@CStdFileStream?3?3Open?$AA@
DSOUND_RD	SEGMENT
??_C@_0BF@IINNEHHF@CStdFileStream?3?3Open?$AA@ DB 'CStdFileStream::Open', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CF@CEKMADFG@Error?5?$CFlu?5occurred?5trying?5to?5ope@
DSOUND_RD	SEGMENT
??_C@_0CF@CEKMADFG@Error?5?$CFlu?5occurred?5trying?5to?5ope@ DB 'Error %l'
	DB	'u occurred trying to open %s', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z
DSOUND	SEGMENT
tv69 = -12
_this$ = -8
_hr$ = -4
_pszFileName$ = 8
_dwDesiredAccess$ = 12
_dwShareMode$ = 16
_dwCreationDisposition$ = 20
_dwFlagsAndAttributes$ = 24
?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z PROC NEAR ; WaveLoader::CStdFileStream::Open, COMDAT
; _this$ = ecx

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 178  :     HRESULT                 hr  = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 179  : 
; 180  :     DPF_ENTER();
; 181  : 
; 182  :     ASSERT(!IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L37474
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L37474
  00020	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00027	eb 07		 jmp	 SHORT $L37475
$L37474:
  00029	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L37475:
  00030	68 b6 00 00 00	 push	 182			; 000000b6H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@KOCFKEKK@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
  0003f	8b 55 f4	 mov	 edx, DWORD PTR tv69[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 183  :     
; 184  :     m_hFile = CreateFile(pszFileName, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);

  0004b	6a 00		 push	 0
  0004d	8b 45 18	 mov	 eax, DWORD PTR _dwFlagsAndAttributes$[ebp]
  00050	50		 push	 eax
  00051	8b 4d 14	 mov	 ecx, DWORD PTR _dwCreationDisposition$[ebp]
  00054	51		 push	 ecx
  00055	6a 00		 push	 0
  00057	8b 55 10	 mov	 edx, DWORD PTR _dwShareMode$[ebp]
  0005a	52		 push	 edx
  0005b	8b 45 0c	 mov	 eax, DWORD PTR _dwDesiredAccess$[ebp]
  0005e	50		 push	 eax
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _pszFileName$[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _CreateFileA@28
  00068	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	89 02		 mov	 DWORD PTR [edx], eax

; 185  : 
; 186  :     if(INVALID_HANDLE_VALUE == m_hFile)

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00073	75 09		 jne	 SHORT $L36027

; 187  :     {
; 188  :         m_hFile = NULL;

  00075	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L36027:

; 189  :     }
; 190  : 
; 191  :     if(!m_hFile)

  0007e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00081	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00084	75 3e		 jne	 SHORT $L36028

; 192  :     {
; 193  :         DPF_ERROR("Error %lu occurred trying to open %s", GetLastError(), pszFileName);

  00086	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@IINNEHHF@CStdFileStream?3?3Open?$AA@
  00090	68 c1 00 00 00	 push	 193			; 000000c1H
  00095	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0009a	6a 04		 push	 4
  0009c	6a 09		 push	 9
  0009e	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000a3	83 c4 18	 add	 esp, 24			; 00000018H
  000a6	8b 45 08	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _GetLastError@0
  000af	50		 push	 eax
  000b0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@CEKMADFG@Error?5?$CFlu?5occurred?5trying?5to?5ope@
  000b5	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 194  :         hr = E_FAIL;

  000bd	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36028:

; 195  :     }
; 196  : 
; 197  :     DPF_LEAVE_HRESULT(hr);
; 198  : 
; 199  :     return hr;

  000c4	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 200  : }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c2 14 00	 ret	 20			; 00000014H
?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z ENDP	; WaveLoader::CStdFileStream::Open
DSOUND	ENDS
PUBLIC	?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z	; WaveLoader::CStdFileStream::Attach
; Function compile flags: /Odt
;	COMDAT ?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z
DSOUND	SEGMENT
tv69 = -8
_this$ = -4
_hFile$ = 8
?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z PROC NEAR	; WaveLoader::CStdFileStream::Attach, COMDAT
; _this$ = ecx

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 227  :     DPF_ENTER();
; 228  : 
; 229  :     ASSERT(!IS_VALID_HANDLE_VALUE(m_hFile));

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 11		 je	 SHORT $L37479
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  00017	74 09		 je	 SHORT $L37479
  00019	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00020	eb 07		 jmp	 SHORT $L37480
$L37479:
  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L37480:
  00029	68 e5 00 00 00	 push	 229			; 000000e5H
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@KOCFKEKK@?$CBIS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
  00038	8b 55 f8	 mov	 edx, DWORD PTR tv69[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00041	83 c4 10	 add	 esp, 16			; 00000010H

; 230  :     
; 231  :     m_hFile = hFile;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _hFile$[ebp]
  0004a	89 08		 mov	 DWORD PTR [eax], ecx

; 232  :     m_dwFlags |= FILESTREAM_FLAGS_ATTACHED;

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00052	83 c8 01	 or	 eax, 1
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 233  : 
; 234  :     DPF_LEAVE_VOID();
; 235  : }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z ENDP	; WaveLoader::CStdFileStream::Attach
DSOUND	ENDS
EXTRN	_CloseHandle@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Close@CStdFileStream@WaveLoader@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Close@CStdFileStream@WaveLoader@@QAEXXZ PROC NEAR	; WaveLoader::CStdFileStream::Close, COMDAT
; _this$ = ecx

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 262  :     DPF_ENTER();
; 263  :     
; 264  :     if(m_dwFlags & FILESTREAM_FLAGS_ATTACHED)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	83 e1 01	 and	 ecx, 1
  00010	85 c9		 test	 ecx, ecx
  00012	74 1a		 je	 SHORT $L36041

; 265  :     {
; 266  :         m_hFile = NULL;

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 267  :         m_dwFlags &= ~FILESTREAM_FLAGS_ATTACHED;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00023	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 268  :     }
; 269  :     else

  0002c	eb 24		 jmp	 SHORT $L36040
$L36041:

; 270  :     {
; 271  :         CLOSE_HANDLE(m_hFile);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 38 00	 cmp	 DWORD PTR [eax], 0
  00034	74 1c		 je	 SHORT $L36040
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0003c	74 14		 je	 SHORT $L36040
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 02		 mov	 eax, DWORD PTR [edx]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _CloseHandle@4
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L36040:

; 272  :     }
; 273  : 
; 274  :     DPF_LEAVE_VOID();
; 275  : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?Close@CStdFileStream@WaveLoader@@QAEXXZ ENDP		; WaveLoader::CStdFileStream::Close
DSOUND	ENDS
PUBLIC	??_C@_0BP@BFEOIFMP@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BF@IKIMPDLN@CStdFileStream?3?3Read?$AA@	; `string'
PUBLIC	??_C@_0CJ@EBECGKOP@Error?5?$CFlu?5occurred?5reading?5from?5@ ; `string'
PUBLIC	??_C@_0CH@JEFGPKIM@Not?5enough?5data?5was?5read?5from?5th@ ; `string'
PUBLIC	?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z	; WaveLoader::CStdFileStream::Read
EXTRN	_ReadFile@20:NEAR
;	COMDAT ??_C@_0BP@BFEOIFMP@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
DSOUND_RD	SEGMENT
??_C@_0BP@BFEOIFMP@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@ DB 'IS_VALID'
	DB	'_HANDLE_VALUE(m_hFile)', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BF@IKIMPDLN@CStdFileStream?3?3Read?$AA@
DSOUND_RD	SEGMENT
??_C@_0BF@IKIMPDLN@CStdFileStream?3?3Read?$AA@ DB 'CStdFileStream::Read', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CJ@EBECGKOP@Error?5?$CFlu?5occurred?5reading?5from?5@
DSOUND_RD	SEGMENT
??_C@_0CJ@EBECGKOP@Error?5?$CFlu?5occurred?5reading?5from?5@ DB 'Error %l'
	DB	'u occurred reading from the file', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CH@JEFGPKIM@Not?5enough?5data?5was?5read?5from?5th@
DSOUND_RD	SEGMENT
??_C@_0CH@JEFGPKIM@Not?5enough?5data?5was?5read?5from?5th@ DB 'Not enough'
	DB	' data was read from the file', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z
DSOUND	SEGMENT
tv69 = -16
_this$ = -12
_hr$ = -8
_dwRead$ = -4
_pvBuffer$ = 8
_dwBufferSize$ = 12
_pdwRead$ = 16
?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z PROC NEAR ; WaveLoader::CStdFileStream::Read, COMDAT
; _this$ = ecx

; 305  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 306  :     HRESULT                 hr      = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 307  :     DWORD                   dwRead;
; 308  : 
; 309  :     DPF_ENTER();
; 310  :     
; 311  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L37487
  00018	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L37487
  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00027	eb 07		 jmp	 SHORT $L37488
$L37487:
  00029	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
$L37488:
  00030	68 37 01 00 00	 push	 311			; 00000137H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFEOIFMP@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
  0003f	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 312  :     
; 313  :     if(!ReadFile(m_hFile, pvBuffer, dwBufferSize, &dwRead, NULL))

  0004b	6a 00		 push	 0
  0004d	8d 45 fc	 lea	 eax, DWORD PTR _dwRead$[ebp]
  00050	50		 push	 eax
  00051	8b 4d 0c	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00058	52		 push	 edx
  00059	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 _ReadFile@20
  00064	85 c0		 test	 eax, eax
  00066	75 3a		 jne	 SHORT $L36056

; 314  :     {
; 315  :         DPF_ERROR("Error %lu occurred reading from the file", GetLastError());

  00068	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@IKIMPDLN@CStdFileStream?3?3Read?$AA@
  00072	68 3b 01 00 00	 push	 315			; 0000013bH
  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0007c	6a 04		 push	 4
  0007e	6a 09		 push	 9
  00080	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00085	83 c4 18	 add	 esp, 24			; 00000018H
  00088	e8 00 00 00 00	 call	 _GetLastError@0
  0008d	50		 push	 eax
  0008e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@EBECGKOP@Error?5?$CFlu?5occurred?5reading?5from?5@
  00093	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00098	83 c4 08	 add	 esp, 8

; 316  :         hr = E_FAIL;

  0009b	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36056:

; 317  :     }
; 318  : 
; 319  :     if(SUCCEEDED(hr))

  000a2	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a6	7c 4c		 jl	 SHORT $L36061

; 320  :     {
; 321  :         if(pdwRead)

  000a8	83 7d 10 00	 cmp	 DWORD PTR _pdwRead$[ebp], 0
  000ac	74 0a		 je	 SHORT $L36062

; 322  :         {
; 323  :             *pdwRead = dwRead;

  000ae	8b 55 10	 mov	 edx, DWORD PTR _pdwRead$[ebp]
  000b1	8b 45 fc	 mov	 eax, DWORD PTR _dwRead$[ebp]
  000b4	89 02		 mov	 DWORD PTR [edx], eax

; 324  :         }
; 325  :         else if(dwRead != dwBufferSize)

  000b6	eb 3c		 jmp	 SHORT $L36061
$L36062:
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _dwRead$[ebp]
  000bb	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwBufferSize$[ebp]
  000be	74 34		 je	 SHORT $L36061

; 326  :         {
; 327  :             DPF_ERROR("Not enough data was read from the file");

  000c0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  000c5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@IKIMPDLN@CStdFileStream?3?3Read?$AA@
  000ca	68 47 01 00 00	 push	 327			; 00000147H
  000cf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  000d4	6a 04		 push	 4
  000d6	6a 09		 push	 9
  000d8	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000dd	83 c4 18	 add	 esp, 24			; 00000018H
  000e0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@JEFGPKIM@Not?5enough?5data?5was?5read?5from?5th@
  000e5	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000ea	83 c4 04	 add	 esp, 4

; 328  :             hr = E_FAIL;

  000ed	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36061:

; 329  :         }
; 330  :     }
; 331  : 
; 332  :     DPF_LEAVE_HRESULT(hr);
; 333  : 
; 334  :     return hr;

  000f4	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 335  : }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 0c 00	 ret	 12			; 0000000cH
?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z ENDP	; WaveLoader::CStdFileStream::Read
DSOUND	ENDS
PUBLIC	??_C@_0BG@PGEPINJO@CStdFileStream?3?3Write?$AA@	; `string'
PUBLIC	??_C@_0CH@HNBEJLKA@Error?5?$CFlu?5occurred?5writing?5to?5th@ ; `string'
PUBLIC	??_C@_0CK@PPGKDJFB@Not?5enough?5data?5was?5written?5from@ ; `string'
PUBLIC	?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z	; WaveLoader::CStdFileStream::Write
EXTRN	_WriteFile@20:NEAR
;	COMDAT ??_C@_0BG@PGEPINJO@CStdFileStream?3?3Write?$AA@
DSOUND_RD	SEGMENT
??_C@_0BG@PGEPINJO@CStdFileStream?3?3Write?$AA@ DB 'CStdFileStream::Write'
	DB	00H						; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CH@HNBEJLKA@Error?5?$CFlu?5occurred?5writing?5to?5th@
DSOUND_RD	SEGMENT
??_C@_0CH@HNBEJLKA@Error?5?$CFlu?5occurred?5writing?5to?5th@ DB 'Error %l'
	DB	'u occurred writing to the file', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CK@PPGKDJFB@Not?5enough?5data?5was?5written?5from@
DSOUND_RD	SEGMENT
??_C@_0CK@PPGKDJFB@Not?5enough?5data?5was?5written?5from@ DB 'Not enough '
	DB	'data was written from the file', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z
DSOUND	SEGMENT
tv69 = -16
_this$ = -12
_dwWritten$ = -8
_hr$ = -4
_pvBuffer$ = 8
_dwBufferSize$ = 12
_pdwWritten$ = 16
?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z PROC NEAR ; WaveLoader::CStdFileStream::Write, COMDAT
; _this$ = ecx

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 366  :     HRESULT                 hr          = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 367  :     DWORD                   dwWritten;
; 368  : 
; 369  :     DPF_ENTER();
; 370  :     
; 371  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L37492
  00018	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L37492
  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00027	eb 07		 jmp	 SHORT $L37493
$L37492:
  00029	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
$L37493:
  00030	68 73 01 00 00	 push	 371			; 00000173H
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFEOIFMP@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
  0003f	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 372  :     
; 373  :     if(!WriteFile(m_hFile, pvBuffer, dwBufferSize, &dwWritten, NULL))

  0004b	6a 00		 push	 0
  0004d	8d 45 f8	 lea	 eax, DWORD PTR _dwWritten$[ebp]
  00050	50		 push	 eax
  00051	8b 4d 0c	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00058	52		 push	 edx
  00059	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 _WriteFile@20
  00064	85 c0		 test	 eax, eax
  00066	75 3a		 jne	 SHORT $L36077

; 374  :     {
; 375  :         DPF_ERROR("Error %lu occurred writing to the file", GetLastError());

  00068	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@PGEPINJO@CStdFileStream?3?3Write?$AA@
  00072	68 77 01 00 00	 push	 375			; 00000177H
  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0007c	6a 04		 push	 4
  0007e	6a 09		 push	 9
  00080	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00085	83 c4 18	 add	 esp, 24			; 00000018H
  00088	e8 00 00 00 00	 call	 _GetLastError@0
  0008d	50		 push	 eax
  0008e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@HNBEJLKA@Error?5?$CFlu?5occurred?5writing?5to?5th@
  00093	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00098	83 c4 08	 add	 esp, 8

; 376  :         hr = E_FAIL;

  0009b	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36077:

; 377  :     }
; 378  : 
; 379  :     if(SUCCEEDED(hr))

  000a2	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a6	7c 4c		 jl	 SHORT $L36082

; 380  :     {
; 381  :         if(pdwWritten)

  000a8	83 7d 10 00	 cmp	 DWORD PTR _pdwWritten$[ebp], 0
  000ac	74 0a		 je	 SHORT $L36083

; 382  :         {
; 383  :             *pdwWritten = dwWritten;

  000ae	8b 55 10	 mov	 edx, DWORD PTR _pdwWritten$[ebp]
  000b1	8b 45 f8	 mov	 eax, DWORD PTR _dwWritten$[ebp]
  000b4	89 02		 mov	 DWORD PTR [edx], eax

; 384  :         }
; 385  :         else if(dwWritten != dwBufferSize)

  000b6	eb 3c		 jmp	 SHORT $L36082
$L36083:
  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _dwWritten$[ebp]
  000bb	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwBufferSize$[ebp]
  000be	74 34		 je	 SHORT $L36082

; 386  :         {
; 387  :             DPF_ERROR("Not enough data was written from the file");

  000c0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  000c5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@PGEPINJO@CStdFileStream?3?3Write?$AA@
  000ca	68 83 01 00 00	 push	 387			; 00000183H
  000cf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  000d4	6a 04		 push	 4
  000d6	6a 09		 push	 9
  000d8	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000dd	83 c4 18	 add	 esp, 24			; 00000018H
  000e0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@PPGKDJFB@Not?5enough?5data?5was?5written?5from@
  000e5	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000ea	83 c4 04	 add	 esp, 4

; 388  :             hr = E_FAIL;

  000ed	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36082:

; 389  :         }
; 390  :     }
; 391  : 
; 392  :     DPF_LEAVE_HRESULT(hr);
; 393  : 
; 394  :     return hr;

  000f4	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 395  : }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 0c 00	 ret	 12			; 0000000cH
?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z ENDP	; WaveLoader::CStdFileStream::Write
DSOUND	ENDS
PUBLIC	??_C@_0BF@DHHNGOBO@CStdFileStream?3?3Seek?$AA@	; `string'
PUBLIC	??_C@_0CE@IKNCKFMB@Error?5?$CFlu?5occurred?5seeking?5the?5f@ ; `string'
PUBLIC	?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z	; WaveLoader::CStdFileStream::Seek
EXTRN	_SetFilePointer@16:NEAR
;	COMDAT ??_C@_0BF@DHHNGOBO@CStdFileStream?3?3Seek?$AA@
DSOUND_RD	SEGMENT
??_C@_0BF@DHHNGOBO@CStdFileStream?3?3Seek?$AA@ DB 'CStdFileStream::Seek', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CE@IKNCKFMB@Error?5?$CFlu?5occurred?5seeking?5the?5f@
DSOUND_RD	SEGMENT
??_C@_0CE@IKNCKFMB@Error?5?$CFlu?5occurred?5seeking?5the?5f@ DB 'Error %l'
	DB	'u occurred seeking the file', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z
DSOUND	SEGMENT
tv69 = -16
_this$ = -12
_hr$ = -8
_dwAbsolute$ = -4
_lOffset$ = 8
_dwOrigin$ = 12
_pdwAbsolute$ = 16
?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z PROC NEAR	; WaveLoader::CStdFileStream::Seek, COMDAT
; _this$ = ecx

; 425  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 426  :     HRESULT                 hr          = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 427  :     DWORD                   dwAbsolute;
; 428  :     
; 429  :     DPF_ENTER();
; 430  : 
; 431  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L37497
  00018	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L37497
  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00027	eb 07		 jmp	 SHORT $L37498
$L37497:
  00029	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
$L37498:
  00030	68 af 01 00 00	 push	 431			; 000001afH
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFEOIFMP@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
  0003f	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 432  :     
; 433  :     if((dwAbsolute = SetFilePointer(m_hFile, lOffset, NULL, dwOrigin)) == INVALID_SET_FILE_POINTER)

  0004b	8b 45 0c	 mov	 eax, DWORD PTR _dwOrigin$[ebp]
  0004e	50		 push	 eax
  0004f	6a 00		 push	 0
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _lOffset$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00058	8b 02		 mov	 eax, DWORD PTR [edx]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _SetFilePointer@16
  00060	89 45 fc	 mov	 DWORD PTR _dwAbsolute$[ebp], eax
  00063	83 7d fc ff	 cmp	 DWORD PTR _dwAbsolute$[ebp], -1
  00067	75 3a		 jne	 SHORT $L36099

; 434  :     {
; 435  :         DPF_ERROR("Error %lu occurred seeking the file", GetLastError());

  00069	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@DHHNGOBO@CStdFileStream?3?3Seek?$AA@
  00073	68 b3 01 00 00	 push	 435			; 000001b3H
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0007d	6a 04		 push	 4
  0007f	6a 09		 push	 9
  00081	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00086	83 c4 18	 add	 esp, 24			; 00000018H
  00089	e8 00 00 00 00	 call	 _GetLastError@0
  0008e	50		 push	 eax
  0008f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@IKNCKFMB@Error?5?$CFlu?5occurred?5seeking?5the?5f@
  00094	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00099	83 c4 08	 add	 esp, 8

; 436  :         hr = E_FAIL;

  0009c	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36099:

; 437  :     }
; 438  : 
; 439  :     if(SUCCEEDED(hr) && pdwAbsolute)

  000a3	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a7	7c 0e		 jl	 SHORT $L36104
  000a9	83 7d 10 00	 cmp	 DWORD PTR _pdwAbsolute$[ebp], 0
  000ad	74 08		 je	 SHORT $L36104

; 440  :     {
; 441  :         *pdwAbsolute = dwAbsolute;

  000af	8b 4d 10	 mov	 ecx, DWORD PTR _pdwAbsolute$[ebp]
  000b2	8b 55 fc	 mov	 edx, DWORD PTR _dwAbsolute$[ebp]
  000b5	89 11		 mov	 DWORD PTR [ecx], edx
$L36104:

; 442  :     }
; 443  : 
; 444  :     DPF_LEAVE_HRESULT(hr);
; 445  : 
; 446  :     return hr;

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 447  : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 0c 00	 ret	 12			; 0000000cH
?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z ENDP	; WaveLoader::CStdFileStream::Seek
DSOUND	ENDS
PUBLIC	??_C@_0BK@HKFPFMIN@CStdFileStream?3?3GetLength?$AA@ ; `string'
PUBLIC	??_C@_0CK@HKLDFKFN@Error?5?$CFlu?5attempting?5to?5get?5the?5@ ; `string'
PUBLIC	?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z	; WaveLoader::CStdFileStream::GetLength
EXTRN	_GetFileSize@8:NEAR
;	COMDAT ??_C@_0BK@HKFPFMIN@CStdFileStream?3?3GetLength?$AA@
DSOUND_RD	SEGMENT
??_C@_0BK@HKFPFMIN@CStdFileStream?3?3GetLength?$AA@ DB 'CStdFileStream::G'
	DB	'etLength', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CK@HKLDFKFN@Error?5?$CFlu?5attempting?5to?5get?5the?5@
DSOUND_RD	SEGMENT
??_C@_0CK@HKLDFKFN@Error?5?$CFlu?5attempting?5to?5get?5the?5@ DB 'Error %'
	DB	'lu attempting to get the file size', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z
DSOUND	SEGMENT
tv69 = -12
_this$ = -8
_hr$ = -4
_pdwLength$ = 8
?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z PROC NEAR ; WaveLoader::CStdFileStream::GetLength, COMDAT
; _this$ = ecx

; 473  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 474  :     HRESULT                 hr  = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 475  :     
; 476  :     DPF_ENTER();
; 477  : 
; 478  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	74 11		 je	 SHORT $L37502
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0001e	74 09		 je	 SHORT $L37502
  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00027	eb 07		 jmp	 SHORT $L37503
$L37502:
  00029	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
$L37503:
  00030	68 de 01 00 00	 push	 478			; 000001deH
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BFEOIFMP@IS_VALID_HANDLE_VALUE?$CIm_hFile?$CJ?$AA@
  0003f	8b 55 f4	 mov	 edx, DWORD PTR tv69[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 479  :     
; 480  :     if((*pdwLength = GetFileSize(m_hFile, NULL)) == -1)

  0004b	6a 00		 push	 0
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 _GetFileSize@8
  00058	8b 55 08	 mov	 edx, DWORD PTR _pdwLength$[ebp]
  0005b	89 02		 mov	 DWORD PTR [edx], eax
  0005d	8b 45 08	 mov	 eax, DWORD PTR _pdwLength$[ebp]
  00060	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00063	75 3a		 jne	 SHORT $L36112

; 481  :     {
; 482  :         DPF_ERROR("Error %lu attempting to get the file size", GetLastError());

  00065	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@HKFPFMIN@CStdFileStream?3?3GetLength?$AA@
  0006f	68 e2 01 00 00	 push	 482			; 000001e2H
  00074	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  00079	6a 04		 push	 4
  0007b	6a 09		 push	 9
  0007d	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00082	83 c4 18	 add	 esp, 24			; 00000018H
  00085	e8 00 00 00 00	 call	 _GetLastError@0
  0008a	50		 push	 eax
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@HKLDFKFN@Error?5?$CFlu?5attempting?5to?5get?5the?5@
  00090	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00095	83 c4 08	 add	 esp, 8

; 483  :         hr = E_FAIL;

  00098	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36112:

; 484  :     }
; 485  : 
; 486  :     DPF_LEAVE_HRESULT(hr);
; 487  : 
; 488  :     return hr;

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 489  : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z ENDP	; WaveLoader::CStdFileStream::GetLength
DSOUND	ENDS
PUBLIC	??0CRiffChunk@WaveLoader@@QAE@XZ		; WaveLoader::CRiffChunk::CRiffChunk
; Function compile flags: /Odt
;	COMDAT ??0CRiffChunk@WaveLoader@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CRiffChunk@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CRiffChunk::CRiffChunk, COMDAT
; _this$ = ecx

; 514  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 515  :     DPF_ENTER();
; 516  : 
; 517  :     //
; 518  :     // Initialize defaults
; 519  :     //
; 520  : 
; 521  :     m_pParentChunk = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 522  :     m_pStream = NULL;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 523  :     m_dwChunkId = 0;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 524  :     m_dwDataOffset = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 525  :     m_dwDataSize = 0;

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 526  :     m_dwFlags = 0;

  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 527  : 
; 528  :     DPF_LEAVE_VOID();
; 529  : }

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??0CRiffChunk@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CRiffChunk::CRiffChunk
DSOUND	ENDS
PUBLIC	??1CRiffChunk@WaveLoader@@QAE@XZ		; WaveLoader::CRiffChunk::~CRiffChunk
; Function compile flags: /Odt
;	COMDAT ??1CRiffChunk@WaveLoader@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CRiffChunk@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CRiffChunk::~CRiffChunk, COMDAT
; _this$ = ecx

; 554  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  :     DPF_ENTER();
; 556  :     DPF_LEAVE_VOID();
; 557  : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1CRiffChunk@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CRiffChunk::~CRiffChunk
DSOUND	ENDS
PUBLIC	?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
; Function compile flags: /Odt
;	COMDAT ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z
DSOUND	SEGMENT
_this$ = -20
_rhRiffHeader$ = -16
_hr$ = -8
_lOffset$ = -4
_pParentChunk$ = 8
_pStream$ = 12
_dwChunkId$ = 16
?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z PROC NEAR ; WaveLoader::CRiffChunk::Open, COMDAT
; _this$ = ecx

; 587  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 588  :     LONG                    lOffset;
; 589  :     RIFFHEADER              rhRiffHeader;
; 590  :     HRESULT                 hr;
; 591  : 
; 592  :     DPF_ENTER();
; 593  :     
; 594  :     m_pParentChunk = pParentChunk;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pParentChunk$[ebp]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx

; 595  :     m_pStream = pStream;

  00011	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  00017	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 596  : 
; 597  :     //
; 598  :     // Seek to the first byte of the parent chunk's data section
; 599  :     //
; 600  : 
; 601  :     if(m_pParentChunk)

  0001a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00020	74 32		 je	 SHORT $L36133

; 602  :     {
; 603  :         lOffset = m_pParentChunk->m_dwDataOffset;

  00022	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002a	89 4d fc	 mov	 DWORD PTR _lOffset$[ebp], ecx

; 604  : 
; 605  :         //
; 606  :         // Special case the RIFF chunk
; 607  :         //
; 608  : 
; 609  :         if((WAVELDR_FOURCC_RIFF == m_pParentChunk->m_dwChunkId) || (WAVELDR_FOURCC_FORM == m_pParentChunk->m_dwChunkId))

  0002d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	81 78 08 52 49
	46 46		 cmp	 DWORD PTR [eax+8], 1179011410 ; 46464952H
  00039	74 0e		 je	 SHORT $L36135
  0003b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	81 7a 08 46 4f
	52 4d		 cmp	 DWORD PTR [edx+8], 1297239878 ; 4d524f46H
  00047	75 09		 jne	 SHORT $L36134
$L36135:

; 610  :         {
; 611  :             lOffset += sizeof(DWORD);

  00049	8b 45 fc	 mov	 eax, DWORD PTR _lOffset$[ebp]
  0004c	83 c0 04	 add	 eax, 4
  0004f	89 45 fc	 mov	 DWORD PTR _lOffset$[ebp], eax
$L36134:

; 612  :         }
; 613  :     }
; 614  :     else

  00052	eb 07		 jmp	 SHORT $L36138
$L36133:

; 615  :     {
; 616  :         lOffset = 0;

  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lOffset$[ebp], 0
$L36138:

; 617  :     }
; 618  : 
; 619  :     //
; 620  :     // If this is the top level chunk, just read the first 8 bytes.  If not,
; 621  :     // search the parent chunk until we find the one we're looking for.
; 622  :     //
; 623  : 
; 624  :     do
; 625  :     {
; 626  :         hr = m_pStream->Seek(lOffset, FILE_BEGIN, NULL);

  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _lOffset$[ebp]
  00062	51		 push	 ecx
  00063	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00069	e8 00 00 00 00	 call	 ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z ; WaveLoader::CStdFileStream::Seek
  0006e	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 627  : 
; 628  :         if(SUCCEEDED(hr))

  00071	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00075	7c 16		 jl	 SHORT $L36142

; 629  :         {
; 630  :             hr = m_pStream->Read(&rhRiffHeader, sizeof(rhRiffHeader), NULL);

  00077	6a 00		 push	 0
  00079	6a 08		 push	 8
  0007b	8d 45 f0	 lea	 eax, DWORD PTR _rhRiffHeader$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00085	e8 00 00 00 00	 call	 ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z ; WaveLoader::CStdFileStream::Read
  0008a	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L36142:

; 631  :         }
; 632  : 
; 633  :         if(SUCCEEDED(hr) && m_pParentChunk)

  0008d	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00091	7c 21		 jl	 SHORT $L36144
  00093	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00096	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00099	74 19		 je	 SHORT $L36144

; 634  :         {
; 635  :             if(WAVELDR_FOURCC_FORM == m_pParentChunk->m_dwChunkId)

  0009b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	81 79 08 46 4f
	52 4d		 cmp	 DWORD PTR [ecx+8], 1297239878 ; 4d524f46H
  000a7	75 0b		 jne	 SHORT $L36144

; 636  :             {
; 637  :                 rhRiffHeader.dwDataSize = EndianSwapDword(rhRiffHeader.dwDataSize);

  000a9	8b 4d f4	 mov	 ecx, DWORD PTR _rhRiffHeader$[ebp+4]
  000ac	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  000b1	89 45 f4	 mov	 DWORD PTR _rhRiffHeader$[ebp+4], eax
$L36144:

; 638  :             }
; 639  :         }
; 640  : 
; 641  :         if(SUCCEEDED(hr) && (dwChunkId == rhRiffHeader.dwChunkId))

  000b4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b8	7c 0a		 jl	 SHORT $L36147
  000ba	8b 55 10	 mov	 edx, DWORD PTR _dwChunkId$[ebp]
  000bd	3b 55 f0	 cmp	 edx, DWORD PTR _rhRiffHeader$[ebp]
  000c0	75 02		 jne	 SHORT $L36147

; 642  :         {
; 643  :             break;

  000c2	eb 32		 jmp	 SHORT $L36140
$L36147:

; 644  :         }
; 645  : 
; 646  :         if(SUCCEEDED(hr) && !m_pParentChunk)

  000c4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000c8	7c 0f		 jl	 SHORT $L36149
  000ca	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	83 38 00	 cmp	 DWORD PTR [eax], 0
  000d0	75 07		 jne	 SHORT $L36149

; 647  :         {
; 648  :             hr = E_FAIL;

  000d2	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36149:

; 649  :         }
; 650  : 
; 651  :         if(SUCCEEDED(hr))

  000d9	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000dd	7c 0d		 jl	 SHORT $L36139

; 652  :         {
; 653  :             lOffset += sizeof(rhRiffHeader) + rhRiffHeader.dwDataSize;

  000df	8b 4d f4	 mov	 ecx, DWORD PTR _rhRiffHeader$[ebp+4]
  000e2	8b 55 fc	 mov	 edx, DWORD PTR _lOffset$[ebp]
  000e5	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  000e9	89 45 fc	 mov	 DWORD PTR _lOffset$[ebp], eax
$L36139:

; 654  :         }
; 655  :     }
; 656  :     while(SUCCEEDED(hr));

  000ec	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000f0	0f 8d 65 ff ff
	ff		 jge	 $L36138
$L36140:

; 657  : 
; 658  :     //
; 659  :     // Success
; 660  :     //
; 661  : 
; 662  :     if(SUCCEEDED(hr))

  000f6	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000fa	7c 2d		 jl	 SHORT $L36155

; 663  :     {
; 664  :         m_dwChunkId = dwChunkId;

  000fc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	8b 55 10	 mov	 edx, DWORD PTR _dwChunkId$[ebp]
  00102	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 665  :         m_dwDataOffset = lOffset + sizeof(rhRiffHeader);

  00105	8b 45 fc	 mov	 eax, DWORD PTR _lOffset$[ebp]
  00108	83 c0 08	 add	 eax, 8
  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 666  :         m_dwDataSize = rhRiffHeader.dwDataSize;

  00111	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00114	8b 45 f4	 mov	 eax, DWORD PTR _rhRiffHeader$[ebp+4]
  00117	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 667  :         m_dwFlags |= RIFFCHUNK_FLAGS_VALID;

  0011a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00120	83 ca 01	 or	 edx, 1
  00123	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00126	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L36155:

; 668  :     }
; 669  : 
; 670  :     DPF_LEAVE_HRESULT(hr);
; 671  : 
; 672  :     return hr;

  00129	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 673  : }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 0c 00	 ret	 12			; 0000000cH
?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ENDP ; WaveLoader::CRiffChunk::Open
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?EndianSwapDword@@YIKK@Z
DSOUND	SEGMENT
_n$ = -4
?EndianSwapDword@@YIKK@Z PROC NEAR			; EndianSwapDword, COMDAT
; _n$ = ecx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx

; 55   :     __asm
; 56   :     {
; 57   :         mov     eax, ecx

  00008	8b c1		 mov	 eax, ecx

; 58   :         sar     eax, 24

  0000a	c1 f8 18	 sar	 eax, 24			; 00000018H

; 59   :         and     eax, 0ffh

  0000d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 60   : 
; 61   :         mov     ebx, ecx

  00012	8b d9		 mov	 ebx, ecx

; 62   :         sar     ebx, 8

  00014	c1 fb 08	 sar	 ebx, 8

; 63   :         and     ebx, 0ff00h

  00017	81 e3 00 ff 00
	00		 and	 ebx, 65280		; 0000ff00H

; 64   :         or      eax, ebx

  0001d	0b c3		 or	 eax, ebx

; 65   : 
; 66   :         mov     ebx, ecx

  0001f	8b d9		 mov	 ebx, ecx

; 67   :         shl     ebx, 8

  00021	c1 e3 08	 shl	 ebx, 8

; 68   :         and     ebx, 0ff0000h

  00024	81 e3 00 00 ff
	00		 and	 ebx, 16711680		; 00ff0000H

; 69   :         or      eax, ebx

  0002a	0b c3		 or	 eax, ebx

; 70   : 
; 71   :         mov     ebx, ecx

  0002c	8b d9		 mov	 ebx, ecx

; 72   :         shl     ebx, 24

  0002e	c1 e3 18	 shl	 ebx, 24			; 00000018H

; 73   :         and     ebx, 0ff000000h

  00031	81 e3 00 00 00
	ff		 and	 ebx, -16777216		; ff000000H

; 74   :         or      eax, ebx

  00037	0b c3		 or	 eax, ebx

; 75   :     }
; 76   : }

  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?EndianSwapDword@@YIKK@Z ENDP				; EndianSwapDword
DSOUND	ENDS
PUBLIC	??_C@_0BB@JCIHLOCG@CRiffChunk?3?3Read?$AA@	; `string'
PUBLIC	??_C@_0CM@BMKKIDJB@Attempted?5to?5read?5past?5the?5end?5o@ ; `string'
PUBLIC	?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z	; WaveLoader::CRiffChunk::Read
;	COMDAT ??_C@_0BB@JCIHLOCG@CRiffChunk?3?3Read?$AA@
DSOUND_RD	SEGMENT
??_C@_0BB@JCIHLOCG@CRiffChunk?3?3Read?$AA@ DB 'CRiffChunk::Read', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CM@BMKKIDJB@Attempted?5to?5read?5past?5the?5end?5o@
DSOUND_RD	SEGMENT
??_C@_0CM@BMKKIDJB@Attempted?5to?5read?5past?5the?5end?5o@ DB 'Attempted '
	DB	'to read past the end of the chunk', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
_dwOffset$ = 8
_pvBuffer$ = 12
_dwBufferSize$ = 16
_pdwRead$ = 20
?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z PROC NEAR	; WaveLoader::CRiffChunk::Read, COMDAT
; _this$ = ecx

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 706  :     HRESULT                 hr  = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 707  : 
; 708  :     DPF_ENTER();
; 709  : 
; 710  :     if(dwOffset + dwBufferSize > m_dwDataSize)

  00010	8b 45 08	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  00013	03 45 10	 add	 eax, DWORD PTR _dwBufferSize$[ebp]
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0001c	76 64		 jbe	 SHORT $L36165

; 711  :     {
; 712  :         if(dwOffset >= m_dwDataSize)

  0001e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 45 08	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  00024	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  00027	72 09		 jb	 SHORT $L36166

; 713  :         {
; 714  :             dwBufferSize = 0;

  00029	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _dwBufferSize$[ebp], 0

; 715  :         }
; 716  :         else

  00030	eb 0c		 jmp	 SHORT $L36167
$L36166:

; 717  :         {
; 718  :             dwBufferSize = m_dwDataSize - dwOffset;

  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00038	2b 55 08	 sub	 edx, DWORD PTR _dwOffset$[ebp]
  0003b	89 55 10	 mov	 DWORD PTR _dwBufferSize$[ebp], edx
$L36167:

; 719  :         }
; 720  : 
; 721  :         if(pdwRead)

  0003e	83 7d 14 00	 cmp	 DWORD PTR _pdwRead$[ebp], 0
  00042	74 0a		 je	 SHORT $L36168

; 722  :         {
; 723  :             *pdwRead = dwBufferSize;

  00044	8b 45 14	 mov	 eax, DWORD PTR _pdwRead$[ebp]
  00047	8b 4d 10	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  0004a	89 08		 mov	 DWORD PTR [eax], ecx

; 724  :         }
; 725  :         else

  0004c	eb 34		 jmp	 SHORT $L36165
$L36168:

; 726  :         {
; 727  :             DPF_ERROR("Attempted to read past the end of the chunk");

  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@JCIHLOCG@CRiffChunk?3?3Read?$AA@
  00058	68 d7 02 00 00	 push	 727			; 000002d7H
  0005d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  00062	6a 04		 push	 4
  00064	6a 09		 push	 9
  00066	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0006b	83 c4 18	 add	 esp, 24			; 00000018H
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@BMKKIDJB@Attempted?5to?5read?5past?5the?5end?5o@
  00073	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00078	83 c4 04	 add	 esp, 4

; 728  :             hr = E_FAIL;

  0007b	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36165:

; 729  :         }
; 730  :     }
; 731  : 
; 732  :     if(SUCCEEDED(hr))

  00082	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00086	7c 1c		 jl	 SHORT $L36174

; 733  :     {
; 734  :         hr = m_pStream->Seek(m_dwDataOffset + dwOffset, FILE_BEGIN, NULL);

  00088	6a 00		 push	 0
  0008a	6a 00		 push	 0
  0008c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0008f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00092	03 45 08	 add	 eax, DWORD PTR _dwOffset$[ebp]
  00095	50		 push	 eax
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009c	e8 00 00 00 00	 call	 ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z ; WaveLoader::CStdFileStream::Seek
  000a1	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L36174:

; 735  :     }
; 736  : 
; 737  :     if(SUCCEEDED(hr))

  000a4	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a8	7c 18		 jl	 SHORT $L36176

; 738  :     {
; 739  :         hr = m_pStream->Read(pvBuffer, dwBufferSize, NULL);

  000aa	6a 00		 push	 0
  000ac	8b 55 10	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  000af	52		 push	 edx
  000b0	8b 45 0c	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000ba	e8 00 00 00 00	 call	 ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z ; WaveLoader::CStdFileStream::Read
  000bf	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L36176:

; 740  :     }
; 741  : 
; 742  :     DPF_LEAVE_HRESULT(hr);
; 743  : 
; 744  :     return hr;

  000c2	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 745  : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 10 00	 ret	 16			; 00000010H
?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ENDP	; WaveLoader::CRiffChunk::Read
DSOUND	ENDS
PUBLIC	??0CWaveFile@WaveLoader@@QAE@XZ			; WaveLoader::CWaveFile::CWaveFile
; Function compile flags: /Odt
;	COMDAT ??0CWaveFile@WaveLoader@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CWaveFile@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CWaveFile::CWaveFile, COMDAT
; _this$ = ecx

; 770  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::CStdFileStream
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 20	 add	 ecx, 32			; 00000020H
  00020	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 771  :     DPF_ENTER();
; 772  : 
; 773  :     m_dwFileType = -1;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c7 40 38 ff ff
	ff ff		 mov	 DWORD PTR [eax+56], -1

; 774  :     m_pwfxFormat = NULL;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 775  : 
; 776  :     DPF_LEAVE_VOID();
; 777  : }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??0CWaveFile@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CWaveFile::CWaveFile
DSOUND	ENDS
PUBLIC	??1CWaveFile@WaveLoader@@QAE@XZ			; WaveLoader::CWaveFile::~CWaveFile
PUBLIC	?Close@CWaveFile@WaveLoader@@QAEXXZ		; WaveLoader::CWaveFile::Close
; Function compile flags: /Odt
;	COMDAT ??1CWaveFile@WaveLoader@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CWaveFile@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CWaveFile::~CWaveFile, COMDAT
; _this$ = ecx

; 802  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 803  :     DPF_ENTER();
; 804  : 
; 805  :     Close();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Close@CWaveFile@WaveLoader@@QAEXXZ ; WaveLoader::CWaveFile::Close

; 806  : 
; 807  :     DPF_LEAVE_VOID();
; 808  : }

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 20	 add	 ecx, 32			; 00000020H
  00015	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ??1CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::~CStdFileStream
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??1CWaveFile@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CWaveFile::~CWaveFile
DSOUND	ENDS
PUBLIC	?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z	; WaveLoader::CWaveFile::Open
PUBLIC	?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetWaveFormat
PUBLIC	?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetAiffFormat
PUBLIC	??_C@_0DC@IFKBAFN@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@ ; `string'
PUBLIC	??_C@_0BA@CGAHBFNM@CWaveFile?3?3Open?$AA@	; `string'
PUBLIC	??_C@_0BK@OHEGKMMD@The?5file?5type?5is?5not?5WAVE?$AA@ ; `string'
PUBLIC	??_C@_0CB@CAIFKCHB@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@ ; `string'
PUBLIC	??_C@_0CL@IIKFACCB@The?5file?8s?5AIFF?9C?5version?5is?5not@ ; `string'
PUBLIC	??_C@_04ELFAHOMP@BYTE?$AA@			; `string'
;	COMDAT ??_C@_0DC@IFKBAFN@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@
DSOUND_RD	SEGMENT
??_C@_0DC@IFKBAFN@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@ DB '('
	DB	'pszFileName || hFile) && !(pszFileName && hFile)', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BA@CGAHBFNM@CWaveFile?3?3Open?$AA@
DSOUND_RD	SEGMENT
??_C@_0BA@CGAHBFNM@CWaveFile?3?3Open?$AA@ DB 'CWaveFile::Open', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BK@OHEGKMMD@The?5file?5type?5is?5not?5WAVE?$AA@
DSOUND_RD	SEGMENT
??_C@_0BK@OHEGKMMD@The?5file?5type?5is?5not?5WAVE?$AA@ DB 'The file type '
	DB	'is not WAVE', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CB@CAIFKCHB@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@
DSOUND_RD	SEGMENT
??_C@_0CB@CAIFKCHB@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@ DB 'The file '
	DB	'type is not AIFF/AIFF-C', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CL@IIKFACCB@The?5file?8s?5AIFF?9C?5version?5is?5not@
DSOUND_RD	SEGMENT
??_C@_0CL@IIKFACCB@The?5file?8s?5AIFF?9C?5version?5is?5not@ DB 'The file'''
	DB	's AIFF-C version is not supported', 00H	; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_04ELFAHOMP@BYTE?$AA@
DSOUND_RD	SEGMENT
??_C@_04ELFAHOMP@BYTE?$AA@ DB 'BYTE', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z
DSOUND	SEGMENT
tv74 = -60
_this$ = -56
$T37532 = -52
_hr$ = -48
_AiffSoundHeader$ = -44
_VersionChunk$ = -36
_dwFormatSize$ = -12
_dwType$ = -8
_dwVersion$ = -4
_pszFileName$ = 8
_hFile$ = 12
?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z PROC NEAR	; WaveLoader::CWaveFile::Open, COMDAT
; _this$ = ecx

; 836  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 837  :     HRESULT                 hr              = S_OK;

  00009	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 838  :     DWORD                   dwType;
; 839  :     CRiffChunk              VersionChunk;

  00010	8d 4d dc	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 840  :     DWORD                   dwVersion;
; 841  :     DWORD                   dwFormatSize;
; 842  :     AIFFSOUNDHDR            AiffSoundHeader;
; 843  : 
; 844  :     DPF_ENTER();
; 845  : 
; 846  :     ASSERT((pszFileName || hFile) && !(pszFileName && hFile));

  00018	83 7d 08 00	 cmp	 DWORD PTR _pszFileName$[ebp], 0
  0001c	75 06		 jne	 SHORT $L37528
  0001e	83 7d 0c 00	 cmp	 DWORD PTR _hFile$[ebp], 0
  00022	74 15		 je	 SHORT $L37530
$L37528:
  00024	83 7d 08 00	 cmp	 DWORD PTR _pszFileName$[ebp], 0
  00028	74 06		 je	 SHORT $L37529
  0002a	83 7d 0c 00	 cmp	 DWORD PTR _hFile$[ebp], 0
  0002e	75 09		 jne	 SHORT $L37530
$L37529:
  00030	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  00037	eb 07		 jmp	 SHORT $L37531
$L37530:
  00039	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
$L37531:
  00040	68 4e 03 00 00	 push	 846			; 0000034eH
  00045	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DC@IFKBAFN@?$CIpszFileName?5?$HM?$HM?5hFile?$CJ?5?$CG?$CG?5?$CB?$CIpszF@
  0004f	8b 45 c4	 mov	 eax, DWORD PTR tv74[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00058	83 c4 10	 add	 esp, 16			; 00000010H

; 847  :     
; 848  :     //
; 849  :     // If we're already open, close
; 850  :     //
; 851  : 
; 852  :     Close();

  0005b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?Close@CWaveFile@WaveLoader@@QAEXXZ ; WaveLoader::CWaveFile::Close

; 853  : 
; 854  :     //
; 855  :     // Open the file
; 856  :     //
; 857  : 
; 858  :     if(pszFileName)

  00063	83 7d 08 00	 cmp	 DWORD PTR _pszFileName$[ebp], 0
  00067	74 1c		 je	 SHORT $L36198

; 859  :     {
; 860  :         hr = m_Stream.Open(pszFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, 0);

  00069	6a 00		 push	 0
  0006b	6a 03		 push	 3
  0006d	6a 01		 push	 1
  0006f	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _pszFileName$[ebp]
  00077	51		 push	 ecx
  00078	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z ; WaveLoader::CStdFileStream::Open
  00080	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 861  :     }
; 862  :     else

  00083	eb 0c		 jmp	 SHORT $L36199
$L36198:

; 863  :     {
; 864  :         m_Stream.Attach(hFile);

  00085	8b 55 0c	 mov	 edx, DWORD PTR _hFile$[ebp]
  00088	52		 push	 edx
  00089	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	e8 00 00 00 00	 call	 ?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z ; WaveLoader::CStdFileStream::Attach
$L36199:

; 865  :     }
; 866  : 
; 867  :     //
; 868  :     // Determine the file type by opening the top-level chunk
; 869  :     //
; 870  : 
; 871  :     if(SUCCEEDED(hr))

  00091	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00095	7c 54		 jl	 SHORT $L36201

; 872  :     {
; 873  :         hr = m_ParentChunk.Open(NULL, &m_Stream, WAVELDR_FOURCC_RIFF);

  00097	68 52 49 46 46	 push	 1179011410		; 46464952H
  0009c	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	50		 push	 eax
  000a0	6a 00		 push	 0
  000a2	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	83 c1 08	 add	 ecx, 8
  000a8	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  000ad	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 874  : 
; 875  :         if(SUCCEEDED(hr))

  000b0	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b4	7c 0c		 jl	 SHORT $L36203

; 876  :         {
; 877  :             m_dwFileType = WAVELDR_FILETYPE_WAVE;

  000b6	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 878  :         }
; 879  :         else

  000c0	eb 29		 jmp	 SHORT $L36201
$L36203:

; 880  :         {
; 881  :             hr = m_ParentChunk.Open(NULL, &m_Stream, WAVELDR_FOURCC_FORM);

  000c2	68 46 4f 52 4d	 push	 1297239878		; 4d524f46H
  000c7	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  000ca	52		 push	 edx
  000cb	6a 00		 push	 0
  000cd	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	83 c1 08	 add	 ecx, 8
  000d3	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  000d8	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 882  : 
; 883  :             if(SUCCEEDED(hr))

  000db	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000df	7c 0a		 jl	 SHORT $L36201

; 884  :             {
; 885  :                 m_dwFileType = WAVELDR_FILETYPE_AIFF;

  000e1	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	c7 40 38 01 00
	00 00		 mov	 DWORD PTR [eax+56], 1
$L36201:

; 886  :             }
; 887  :         }
; 888  :     }
; 889  : 
; 890  :     if(SUCCEEDED(hr))

  000eb	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ef	0f 8c b0 00 00
	00		 jl	 $L36208

; 891  :     {
; 892  :         hr = m_ParentChunk.Read(0, &dwType, sizeof(dwType));

  000f5	6a 00		 push	 0
  000f7	6a 04		 push	 4
  000f9	8d 4d f8	 lea	 ecx, DWORD PTR _dwType$[ebp]
  000fc	51		 push	 ecx
  000fd	6a 00		 push	 0
  000ff	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	83 c1 08	 add	 ecx, 8
  00105	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  0010a	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 893  : 
; 894  :         if(SUCCEEDED(hr))

  0010d	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00111	0f 8c 8e 00 00
	00		 jl	 $L36208

; 895  :         {
; 896  :             if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  00117	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0011a	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0011e	75 3f		 jne	 SHORT $L36211

; 897  :             {
; 898  :                 if(WAVELDR_FOURCC_WAVE != dwType)

  00120	81 7d f8 57 41
	56 45		 cmp	 DWORD PTR _dwType$[ebp], 1163280727 ; 45564157H
  00127	74 34		 je	 SHORT $L36212

; 899  :                 {
; 900  :                     DPF_ERROR("The file type is not WAVE");

  00129	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  0012e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@CGAHBFNM@CWaveFile?3?3Open?$AA@
  00133	68 84 03 00 00	 push	 900			; 00000384H
  00138	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0013d	6a 04		 push	 4
  0013f	6a 09		 push	 9
  00141	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00146	83 c4 18	 add	 esp, 24			; 00000018H
  00149	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@OHEGKMMD@The?5file?5type?5is?5not?5WAVE?$AA@
  0014e	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00153	83 c4 04	 add	 esp, 4

; 901  :                     hr = E_FAIL;

  00156	c7 45 d0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36212:

; 902  :                 }
; 903  :             }
; 904  :             else

  0015d	eb 46		 jmp	 SHORT $L36208
$L36211:

; 905  :             {
; 906  :                 if((WAVELDR_FOURCC_AIFF != dwType) && (WAVELDR_FOURCC_AIFFC != dwType))

  0015f	81 7d f8 41 49
	46 46		 cmp	 DWORD PTR _dwType$[ebp], 1179011393 ; 46464941H
  00166	74 3d		 je	 SHORT $L36208
  00168	81 7d f8 41 49
	46 43		 cmp	 DWORD PTR _dwType$[ebp], 1128679745 ; 43464941H
  0016f	74 34		 je	 SHORT $L36208

; 907  :                 {
; 908  :                     DPF_ERROR("The file type is not AIFF/AIFF-C");

  00171	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  00176	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@CGAHBFNM@CWaveFile?3?3Open?$AA@
  0017b	68 8c 03 00 00	 push	 908			; 0000038cH
  00180	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  00185	6a 04		 push	 4
  00187	6a 09		 push	 9
  00189	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0018e	83 c4 18	 add	 esp, 24			; 00000018H
  00191	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@CAIFKCHB@The?5file?5type?5is?5not?5AIFF?1AIFF?9C@
  00196	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0019b	83 c4 04	 add	 esp, 4

; 909  :                     hr = E_FAIL;

  0019e	c7 45 d0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36208:

; 910  :                 }
; 911  :             }
; 912  :         }
; 913  :     }
; 914  : 
; 915  :     if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType) && (WAVELDR_FOURCC_AIFFC == dwType))

  001a5	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001a9	0f 8c 8f 00 00
	00		 jl	 $L36221
  001af	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  001b2	83 78 38 01	 cmp	 DWORD PTR [eax+56], 1
  001b6	0f 85 82 00 00
	00		 jne	 $L36221
  001bc	81 7d f8 41 49
	46 43		 cmp	 DWORD PTR _dwType$[ebp], 1128679745 ; 43464941H
  001c3	75 79		 jne	 SHORT $L36221

; 916  :     {
; 917  :         hr = VersionChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_AIFF_VERSION);

  001c5	68 52 56 45 52	 push	 1380275794		; 52455652H
  001ca	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001cd	51		 push	 ecx
  001ce	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  001d1	83 c2 08	 add	 edx, 8
  001d4	52		 push	 edx
  001d5	8d 4d dc	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  001d8	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  001dd	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 918  : 
; 919  :         if(SUCCEEDED(hr))

  001e0	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001e4	7c 15		 jl	 SHORT $L36223

; 920  :         {
; 921  :             hr = VersionChunk.Read(0, &dwVersion, sizeof(dwVersion));

  001e6	6a 00		 push	 0
  001e8	6a 04		 push	 4
  001ea	8d 45 fc	 lea	 eax, DWORD PTR _dwVersion$[ebp]
  001ed	50		 push	 eax
  001ee	6a 00		 push	 0
  001f0	8d 4d dc	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  001f3	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  001f8	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax
$L36223:

; 922  :         }
; 923  : 
; 924  :         if(SUCCEEDED(hr) && (WAVELDR_AIFFC_VERSION != dwVersion))

  001fb	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001ff	7c 3d		 jl	 SHORT $L36221
  00201	81 7d fc 40 51
	80 a2		 cmp	 DWORD PTR _dwVersion$[ebp], -1568648896 ; a2805140H
  00208	74 34		 je	 SHORT $L36221

; 925  :         {
; 926  :             DPF_ERROR("The file's AIFF-C version is not supported");

  0020a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  0020f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@CGAHBFNM@CWaveFile?3?3Open?$AA@
  00214	68 9e 03 00 00	 push	 926			; 0000039eH
  00219	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0021e	6a 04		 push	 4
  00220	6a 09		 push	 9
  00222	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00227	83 c4 18	 add	 esp, 24			; 00000018H
  0022a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CL@IIKFACCB@The?5file?8s?5AIFF?9C?5version?5is?5not@
  0022f	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00234	83 c4 04	 add	 esp, 4

; 927  :             hr = E_FAIL;

  00237	c7 45 d0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36221:

; 928  :         }
; 929  :     }
; 930  : 
; 931  :     //
; 932  :     // Initialize the required chunk objects
; 933  :     //
; 934  : 
; 935  :     if(SUCCEEDED(hr))

  0023e	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00242	7c 30		 jl	 SHORT $L36229

; 936  :     {
; 937  :         hr = m_DataChunk.Open(&m_ParentChunk, &m_Stream, (WAVELDR_FILETYPE_WAVE == m_dwFileType) ? WAVELDR_FOURCC_DATA : WAVELDR_FOURCC_SOUND);

  00244	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00247	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0024a	f7 da		 neg	 edx
  0024c	1b d2		 sbb	 edx, edx
  0024e	81 e2 ef f1 d9
	e2		 and	 edx, -489033233		; e2d9f1efH
  00254	81 c2 64 61 74
	61		 add	 edx, 1635017060		; 61746164H
  0025a	52		 push	 edx
  0025b	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0025e	50		 push	 eax
  0025f	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00262	83 c1 08	 add	 ecx, 8
  00265	51		 push	 ecx
  00266	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00269	83 c1 20	 add	 ecx, 32			; 00000020H
  0026c	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00271	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax
$L36229:

; 938  :     }
; 939  : 
; 940  :     //
; 941  :     // Load the file format
; 942  :     //
; 943  : 
; 944  :     if(SUCCEEDED(hr))

  00274	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00278	7c 31		 jl	 SHORT $L36231

; 945  :     {
; 946  :         if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  0027a	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0027d	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00281	75 15		 jne	 SHORT $L36232

; 947  :         {
; 948  :             hr = GetWaveFormat(NULL, 0, &dwFormatSize);

  00283	8d 45 f4	 lea	 eax, DWORD PTR _dwFormatSize$[ebp]
  00286	50		 push	 eax
  00287	6a 00		 push	 0
  00289	6a 00		 push	 0
  0028b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0028e	e8 00 00 00 00	 call	 ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetWaveFormat
  00293	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 949  :         }
; 950  :         else

  00296	eb 13		 jmp	 SHORT $L36231
$L36232:

; 951  :         {
; 952  :             hr = GetAiffFormat(NULL, 0, &dwFormatSize);

  00298	8d 4d f4	 lea	 ecx, DWORD PTR _dwFormatSize$[ebp]
  0029b	51		 push	 ecx
  0029c	6a 00		 push	 0
  0029e	6a 00		 push	 0
  002a0	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002a3	e8 00 00 00 00	 call	 ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetAiffFormat
  002a8	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax
$L36231:

; 953  :         }
; 954  :     }
; 955  : 
; 956  :     if(SUCCEEDED(hr))

  002ab	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002af	7c 3a		 jl	 SHORT $L36235

; 957  :     {
; 958  :         hr = HRFROMP(m_pwfxFormat = (LPWAVEFORMATEX)MEMALLOC(BYTE, dwFormatSize));

  002b1	6a 01		 push	 1
  002b3	8b 55 f4	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  002b6	52		 push	 edx
  002b7	68 44 53 64 61	 push	 1633964868		; 61645344H
  002bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04ELFAHOMP@BYTE?$AA@
  002c1	68 be 03 00 00	 push	 958			; 000003beH
  002c6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  002cb	e8 00 00 00 00	 call	 ?TrackingMemAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingMemAlloc
  002d0	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002d3	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
  002d6	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  002d9	33 c0		 xor	 eax, eax
  002db	83 7a 3c 00	 cmp	 DWORD PTR [edx+60], 0
  002df	0f 95 c0	 setne	 al
  002e2	48		 dec	 eax
  002e3	25 0e 00 07 80	 and	 eax, -2147024882	; 8007000eH
  002e8	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax
$L36235:

; 959  :     }
; 960  : 
; 961  :     if(SUCCEEDED(hr))

  002eb	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002ef	7c 3b		 jl	 SHORT $L36243

; 962  :     {
; 963  :         if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  002f1	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002f4	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  002f8	75 1a		 jne	 SHORT $L36244

; 964  :         {
; 965  :             hr = GetWaveFormat(m_pwfxFormat, dwFormatSize, NULL);

  002fa	6a 00		 push	 0
  002fc	8b 55 f4	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  002ff	52		 push	 edx
  00300	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00303	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00306	51		 push	 ecx
  00307	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0030a	e8 00 00 00 00	 call	 ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetWaveFormat
  0030f	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 966  :         }
; 967  :         else

  00312	eb 18		 jmp	 SHORT $L36243
$L36244:

; 968  :         {
; 969  :             hr = GetAiffFormat(m_pwfxFormat, dwFormatSize, NULL);

  00314	6a 00		 push	 0
  00316	8b 55 f4	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  00319	52		 push	 edx
  0031a	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0031d	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00320	51		 push	 ecx
  00321	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00324	e8 00 00 00 00	 call	 ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetAiffFormat
  00329	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax
$L36243:

; 970  :         }
; 971  :     }
; 972  : 
; 973  :     //
; 974  :     // If this is an AIFF file, offset the start of the wave data
; 975  :     //
; 976  : 
; 977  :     if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType))

  0032c	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00330	7c 4e		 jl	 SHORT $L36247
  00332	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00335	83 7a 38 01	 cmp	 DWORD PTR [edx+56], 1
  00339	75 45		 jne	 SHORT $L36247

; 978  :     {
; 979  :         hr = m_DataChunk.Read(0, &AiffSoundHeader, sizeof(AiffSoundHeader));

  0033b	6a 00		 push	 0
  0033d	6a 08		 push	 8
  0033f	8d 45 d4	 lea	 eax, DWORD PTR _AiffSoundHeader$[ebp]
  00342	50		 push	 eax
  00343	6a 00		 push	 0
  00345	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00348	83 c1 20	 add	 ecx, 32			; 00000020H
  0034b	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00350	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 980  : 
; 981  :         if(SUCCEEDED(hr))

  00353	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00357	7c 27		 jl	 SHORT $L36247

; 982  :         {
; 983  :             m_DataChunk.m_dwDataOffset += sizeof(AiffSoundHeader) + AiffSoundHeader.dwOffset;

  00359	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0035c	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0035f	8b 45 d4	 mov	 eax, DWORD PTR _AiffSoundHeader$[ebp]
  00362	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  00366	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00369	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 984  :             m_DataChunk.m_dwDataSize -= sizeof(AiffSoundHeader) + AiffSoundHeader.dwOffset;

  0036c	8b 45 d4	 mov	 eax, DWORD PTR _AiffSoundHeader$[ebp]
  0036f	83 c0 08	 add	 eax, 8
  00372	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00375	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00378	2b d0		 sub	 edx, eax
  0037a	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0037d	89 50 30	 mov	 DWORD PTR [eax+48], edx
$L36247:

; 985  :         }
; 986  :     }
; 987  : 
; 988  :     DPF_LEAVE_HRESULT(hr);
; 989  : 
; 990  :     return hr;

  00380	8b 4d d0	 mov	 ecx, DWORD PTR _hr$[ebp]
  00383	89 4d cc	 mov	 DWORD PTR $T37532[ebp], ecx
  00386	8d 4d dc	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  00389	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  0038e	8b 45 cc	 mov	 eax, DWORD PTR $T37532[ebp]

; 991  : }

  00391	8b e5		 mov	 esp, ebp
  00393	5d		 pop	 ebp
  00394	c2 08 00	 ret	 8
?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z ENDP		; WaveLoader::CWaveFile::Open
DSOUND	ENDS
PUBLIC	??_C@_0N@NLKBAEGB@m_pwfxFormat?$AA@		; `string'
PUBLIC	?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetFormat
EXTRN	_memcpy:NEAR
;	COMDAT ??_C@_0N@NLKBAEGB@m_pwfxFormat?$AA@
DSOUND_RD	SEGMENT
??_C@_0N@NLKBAEGB@m_pwfxFormat?$AA@ DB 'm_pwfxFormat', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z
DSOUND	SEGMENT
tv79 = -16
_this$ = -12
_dwValidSize$ = -4
_pwfxFormat$ = 8
_dwFormatSize$ = 12
_pdwRequiredSize$ = 16
?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z PROC NEAR ; WaveLoader::CWaveFile::GetFormat, COMDAT
; _this$ = ecx

; 1021 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1022 :     DWORD                   dwValidSize;
; 1023 :     HRESULT                 hr;
; 1024 : 
; 1025 :     DPF_ENTER();
; 1026 : 
; 1027 :     ASSERT(m_pwfxFormat);

  00009	68 03 04 00 00	 push	 1027			; 00000403H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@NLKBAEGB@m_pwfxFormat?$AA@
  00018	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	33 c9		 xor	 ecx, ecx
  0001d	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00021	0f 94 c1	 sete	 cl
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 1028 :     
; 1029 :     dwValidSize = sizeof(*m_pwfxFormat) + m_pwfxFormat->cbSize;

  0002d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00033	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  00037	83 c1 12	 add	 ecx, 18			; 00000012H
  0003a	89 4d fc	 mov	 DWORD PTR _dwValidSize$[ebp], ecx

; 1030 : 
; 1031 :     if(pwfxFormat && dwFormatSize)

  0003d	83 7d 08 00	 cmp	 DWORD PTR _pwfxFormat$[ebp], 0
  00041	74 53		 je	 SHORT $L36260
  00043	83 7d 0c 00	 cmp	 DWORD PTR _dwFormatSize$[ebp], 0
  00047	74 4d		 je	 SHORT $L36260

; 1032 :     {
; 1033 :         CopyMemory(pwfxFormat, m_pwfxFormat, min(dwFormatSize, dwValidSize));

  00049	8b 55 0c	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  0004c	3b 55 fc	 cmp	 edx, DWORD PTR _dwValidSize$[ebp]
  0004f	73 08		 jae	 SHORT $L37536
  00051	8b 45 0c	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  00054	89 45 f0	 mov	 DWORD PTR tv79[ebp], eax
  00057	eb 06		 jmp	 SHORT $L37537
$L37536:
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _dwValidSize$[ebp]
  0005c	89 4d f0	 mov	 DWORD PTR tv79[ebp], ecx
$L37537:
  0005f	8b 55 f0	 mov	 edx, DWORD PTR tv79[ebp]
  00062	52		 push	 edx
  00063	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00069	51		 push	 ecx
  0006a	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _memcpy
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1034 : 
; 1035 :         if(dwFormatSize > dwValidSize)

  00076	8b 45 0c	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  00079	3b 45 fc	 cmp	 eax, DWORD PTR _dwValidSize$[ebp]
  0007c	76 18		 jbe	 SHORT $L36260

; 1036 :         {
; 1037 :             ZeroMemory((LPBYTE)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize);

  0007e	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFormatSize$[ebp]
  00081	2b 4d fc	 sub	 ecx, DWORD PTR _dwValidSize$[ebp]
  00084	51		 push	 ecx
  00085	6a 00		 push	 0
  00087	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  0008a	03 55 fc	 add	 edx, DWORD PTR _dwValidSize$[ebp]
  0008d	52		 push	 edx
  0008e	e8 00 00 00 00	 call	 _memset
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
$L36260:

; 1038 :         }
; 1039 :     }
; 1040 : 
; 1041 :     if(pdwRequiredSize)

  00096	83 7d 10 00	 cmp	 DWORD PTR _pdwRequiredSize$[ebp], 0
  0009a	74 08		 je	 SHORT $L36263

; 1042 :     {
; 1043 :         *pdwRequiredSize = dwValidSize;

  0009c	8b 45 10	 mov	 eax, DWORD PTR _pdwRequiredSize$[ebp]
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _dwValidSize$[ebp]
  000a2	89 08		 mov	 DWORD PTR [eax], ecx
$L36263:

; 1044 :     }
; 1045 : 
; 1046 :     DPF_LEAVE_HRESULT(S_OK);
; 1047 : 
; 1048 :     return S_OK;

  000a4	33 c0		 xor	 eax, eax

; 1049 : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 0c 00	 ret	 12			; 0000000cH
?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z ENDP ; WaveLoader::CWaveFile::GetFormat
DSOUND	ENDS
PUBLIC	??_C@_0CG@JOBMGAMO@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@ ; `string'
PUBLIC	?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ	; WaveLoader::CRiffChunk::GetDataSize
;	COMDAT ??_C@_0CG@JOBMGAMO@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@
DSOUND_RD	SEGMENT
??_C@_0CG@JOBMGAMO@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@ DB 'WAVELDR_'
	DB	'FILETYPE_WAVE == m_dwFileType', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
DSOUND	SEGMENT
tv133 = -48
tv87 = -44
_this$ = -40
$T37545 = -36
_hr$ = -32
_FormatChunk$ = -28
_dwValidSize$ = -4
_pwfxFormat$ = 8
_dwFormatSize$ = 12
_pdwRequiredSize$ = 16
?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z PROC NEAR ; WaveLoader::CWaveFile::GetWaveFormat, COMDAT
; _this$ = ecx

; 1079 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 1080 :     CRiffChunk              FormatChunk;

  00009	8d 4d e4	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1081 :     DWORD                   dwValidSize;
; 1082 :     HRESULT                 hr;
; 1083 : 
; 1084 :     DPF_ENTER();
; 1085 : 
; 1086 :     ASSERT(WAVELDR_FILETYPE_WAVE == m_dwFileType);

  00011	68 3e 04 00 00	 push	 1086			; 0000043eH
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@JOBMGAMO@WAVELDR_FILETYPE_WAVE?5?$DN?$DN?5m_dwFil@
  00020	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00023	33 c9		 xor	 ecx, ecx
  00025	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00029	0f 95 c1	 setne	 cl
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 1087 : 
; 1088 :     //
; 1089 :     // Read the format chunk into the buffer.  Make sure to fill in the full
; 1090 :     // WAVEFORMATEX structure, even if the data in the file isn't enough.
; 1091 :     //
; 1092 : 
; 1093 :     hr = FormatChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_FORMAT);

  00035	68 66 6d 74 20	 push	 544501094		; 20746d66H
  0003a	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	52		 push	 edx
  0003e	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 c0 08	 add	 eax, 8
  00044	50		 push	 eax
  00045	8d 4d e4	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00048	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  0004d	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax

; 1094 : 
; 1095 :     if(SUCCEEDED(hr))

  00050	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00054	7c 38		 jl	 SHORT $L36276

; 1096 :     {
; 1097 :         dwValidSize = FormatChunk.GetDataSize();

  00056	8d 4d e4	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00059	e8 00 00 00 00	 call	 ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ; WaveLoader::CRiffChunk::GetDataSize
  0005e	89 45 fc	 mov	 DWORD PTR _dwValidSize$[ebp], eax

; 1098 : 
; 1099 :         hr = FormatChunk.Read(0, pwfxFormat, min(dwValidSize, dwFormatSize));

  00061	8b 4d fc	 mov	 ecx, DWORD PTR _dwValidSize$[ebp]
  00064	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwFormatSize$[ebp]
  00067	73 08		 jae	 SHORT $L37541
  00069	8b 55 fc	 mov	 edx, DWORD PTR _dwValidSize$[ebp]
  0006c	89 55 d4	 mov	 DWORD PTR tv87[ebp], edx
  0006f	eb 06		 jmp	 SHORT $L37542
$L37541:
  00071	8b 45 0c	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  00074	89 45 d4	 mov	 DWORD PTR tv87[ebp], eax
$L37542:
  00077	6a 00		 push	 0
  00079	8b 4d d4	 mov	 ecx, DWORD PTR tv87[ebp]
  0007c	51		 push	 ecx
  0007d	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  00080	52		 push	 edx
  00081	6a 00		 push	 0
  00083	8d 4d e4	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00086	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  0008b	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax
$L36276:

; 1100 :     }
; 1101 : 
; 1102 :     if(SUCCEEDED(hr) && (dwFormatSize > dwValidSize))

  0008e	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00092	7c 20		 jl	 SHORT $L36278
  00094	8b 45 0c	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  00097	3b 45 fc	 cmp	 eax, DWORD PTR _dwValidSize$[ebp]
  0009a	76 18		 jbe	 SHORT $L36278

; 1103 :     {
; 1104 :         ZeroMemory((LPBYTE)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize);

  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFormatSize$[ebp]
  0009f	2b 4d fc	 sub	 ecx, DWORD PTR _dwValidSize$[ebp]
  000a2	51		 push	 ecx
  000a3	6a 00		 push	 0
  000a5	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  000a8	03 55 fc	 add	 edx, DWORD PTR _dwValidSize$[ebp]
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 _memset
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
$L36278:

; 1105 :     }
; 1106 : 
; 1107 :     if(SUCCEEDED(hr) && pdwRequiredSize)

  000b4	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b8	7c 23		 jl	 SHORT $L36281
  000ba	83 7d 10 00	 cmp	 DWORD PTR _pdwRequiredSize$[ebp], 0
  000be	74 1d		 je	 SHORT $L36281

; 1108 :     {
; 1109 :         *pdwRequiredSize = max(dwValidSize, sizeof(*pwfxFormat));

  000c0	83 7d fc 12	 cmp	 DWORD PTR _dwValidSize$[ebp], 18 ; 00000012H
  000c4	76 08		 jbe	 SHORT $L37543
  000c6	8b 45 fc	 mov	 eax, DWORD PTR _dwValidSize$[ebp]
  000c9	89 45 d0	 mov	 DWORD PTR tv133[ebp], eax
  000cc	eb 07		 jmp	 SHORT $L37544
$L37543:
  000ce	c7 45 d0 12 00
	00 00		 mov	 DWORD PTR tv133[ebp], 18 ; 00000012H
$L37544:
  000d5	8b 4d 10	 mov	 ecx, DWORD PTR _pdwRequiredSize$[ebp]
  000d8	8b 55 d0	 mov	 edx, DWORD PTR tv133[ebp]
  000db	89 11		 mov	 DWORD PTR [ecx], edx
$L36281:

; 1110 :     }
; 1111 : 
; 1112 :     DPF_LEAVE_HRESULT(hr);
; 1113 : 
; 1114 :     return hr;

  000dd	8b 45 e0	 mov	 eax, DWORD PTR _hr$[ebp]
  000e0	89 45 dc	 mov	 DWORD PTR $T37545[ebp], eax
  000e3	8d 4d e4	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  000e6	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  000eb	8b 45 dc	 mov	 eax, DWORD PTR $T37545[ebp]

; 1115 : }

  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 0c 00	 ret	 12			; 0000000cH
?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ENDP ; WaveLoader::CWaveFile::GetWaveFormat
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\waveldr.h
DSOUND	ENDS
;	COMDAT ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ
DSOUND	SEGMENT
_this$ = -4
?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ PROC NEAR	; WaveLoader::CRiffChunk::GetDataSize, COMDAT
; _this$ = ecx

; 276  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 277  :         return m_dwDataSize;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 278  :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ENDP		; WaveLoader::CRiffChunk::GetDataSize
DSOUND	ENDS
PUBLIC	??_C@_0CG@EHNKEHDO@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@ ; `string'
PUBLIC	??_C@_0BJ@EIPMIGEK@CWaveFile?3?3GetAiffFormat?$AA@ ; `string'
PUBLIC	??_C@_0CC@NCAIELLP@Unsupported?5AIFF?5compression?5typ@ ; `string'
EXTRN	_XAudioCreatePcmFormat@16:NEAR
;	COMDAT ??_C@_0CG@EHNKEHDO@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@
; File c:\xbox\private\windows\directx\dsound\common\waveldr.cpp
DSOUND_RD	SEGMENT
??_C@_0CG@EHNKEHDO@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@ DB 'WAVELDR_'
	DB	'FILETYPE_AIFF == m_dwFileType', 00H		; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BJ@EIPMIGEK@CWaveFile?3?3GetAiffFormat?$AA@
DSOUND_RD	SEGMENT
??_C@_0BJ@EIPMIGEK@CWaveFile?3?3GetAiffFormat?$AA@ DB 'CWaveFile::GetAiff'
	DB	'Format', 00H				; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CC@NCAIELLP@Unsupported?5AIFF?5compression?5typ@
DSOUND_RD	SEGMENT
??_C@_0CC@NCAIELLP@Unsupported?5AIFF?5compression?5typ@ DB 'Unsupported A'
	DB	'IFF compression type', 00H			; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
DSOUND	SEGMENT
tv163 = -88
tv89 = -84
_this$ = -80
$T37556 = -76
_WaveFormat$ = -72
_hr$ = -52
_FormatChunk$ = -48
_dwValidSize$ = -24
_AiffFormat$ = -20
_pwfxFormat$ = 8
_dwFormatSize$ = 12
_pdwRequiredSize$ = 16
?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z PROC NEAR ; WaveLoader::CWaveFile::GetAiffFormat, COMDAT
; _this$ = ecx

; 1145 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 1146 :     HRESULT                 hr          = S_OK;

  00009	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1147 :     CRiffChunk              FormatChunk;

  00010	8d 4d d0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1148 :     DWORD                   dwValidSize;
; 1149 :     AIFFFORMAT              AiffFormat;
; 1150 :     WAVEFORMATEX            WaveFormat;
; 1151 : 
; 1152 :     DPF_ENTER();
; 1153 : 
; 1154 :     ASSERT(WAVELDR_FILETYPE_AIFF == m_dwFileType);

  00018	68 82 04 00 00	 push	 1154			; 00000482H
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  00022	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@EHNKEHDO@WAVELDR_FILETYPE_AIFF?5?$DN?$DN?5m_dwFil@
  00027	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	33 c9		 xor	 ecx, ecx
  0002c	83 78 38 01	 cmp	 DWORD PTR [eax+56], 1
  00030	0f 95 c1	 setne	 cl
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00039	83 c4 10	 add	 esp, 16			; 00000010H

; 1155 : 
; 1156 :     if(pwfxFormat && dwFormatSize)

  0003c	83 7d 08 00	 cmp	 DWORD PTR _pwfxFormat$[ebp], 0
  00040	0f 84 90 01 00
	00		 je	 $L36296
  00046	83 7d 0c 00	 cmp	 DWORD PTR _dwFormatSize$[ebp], 0
  0004a	0f 84 86 01 00
	00		 je	 $L36296

; 1157 :     {
; 1158 :         //
; 1159 :         // Open the format chunk
; 1160 :         //
; 1161 : 
; 1162 :         hr = FormatChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_COMM);

  00050	68 43 4f 4d 4d	 push	 1296912195		; 4d4d4f43H
  00055	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00058	52		 push	 edx
  00059	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 c0 08	 add	 eax, 8
  0005f	50		 push	 eax
  00060	8d 4d d0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00063	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00068	89 45 cc	 mov	 DWORD PTR _hr$[ebp], eax

; 1163 :         
; 1164 :         //
; 1165 :         // Read the base format data
; 1166 :         //
; 1167 : 
; 1168 :         if(SUCCEEDED(hr))

  0006b	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006f	7c 37		 jl	 SHORT $L36298

; 1169 :         {
; 1170 :             dwValidSize = FormatChunk.GetDataSize();

  00071	8d 4d d0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00074	e8 00 00 00 00	 call	 ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ; WaveLoader::CRiffChunk::GetDataSize
  00079	89 45 e8	 mov	 DWORD PTR _dwValidSize$[ebp], eax

; 1171 : 
; 1172 :             hr = FormatChunk.Read(0, &AiffFormat, min(sizeof(AiffFormat), dwValidSize));

  0007c	83 7d e8 14	 cmp	 DWORD PTR _dwValidSize$[ebp], 20 ; 00000014H
  00080	76 09		 jbe	 SHORT $L37552
  00082	c7 45 ac 14 00
	00 00		 mov	 DWORD PTR tv89[ebp], 20	; 00000014H
  00089	eb 06		 jmp	 SHORT $L37553
$L37552:
  0008b	8b 4d e8	 mov	 ecx, DWORD PTR _dwValidSize$[ebp]
  0008e	89 4d ac	 mov	 DWORD PTR tv89[ebp], ecx
$L37553:
  00091	6a 00		 push	 0
  00093	8b 55 ac	 mov	 edx, DWORD PTR tv89[ebp]
  00096	52		 push	 edx
  00097	8d 45 ec	 lea	 eax, DWORD PTR _AiffFormat$[ebp]
  0009a	50		 push	 eax
  0009b	6a 00		 push	 0
  0009d	8d 4d d0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  000a0	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  000a5	89 45 cc	 mov	 DWORD PTR _hr$[ebp], eax
$L36298:

; 1173 :         }
; 1174 : 
; 1175 :         if(SUCCEEDED(hr) && (sizeof(AiffFormat) > dwValidSize))

  000a8	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ac	7c 21		 jl	 SHORT $L36300
  000ae	83 7d e8 14	 cmp	 DWORD PTR _dwValidSize$[ebp], 20 ; 00000014H
  000b2	73 1b		 jae	 SHORT $L36300

; 1176 :         {
; 1177 :             ZeroMemory((LPBYTE)&AiffFormat + dwValidSize, sizeof(AiffFormat) - dwValidSize);

  000b4	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  000b9	2b 4d e8	 sub	 ecx, DWORD PTR _dwValidSize$[ebp]
  000bc	51		 push	 ecx
  000bd	6a 00		 push	 0
  000bf	8b 55 e8	 mov	 edx, DWORD PTR _dwValidSize$[ebp]
  000c2	8d 44 15 ec	 lea	 eax, DWORD PTR _AiffFormat$[ebp+edx]
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _memset
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH
$L36300:

; 1178 :         }
; 1179 : 
; 1180 :         //
; 1181 :         // If no compression type is specified, assume PCM
; 1182 :         //
; 1183 : 
; 1184 :         if(SUCCEEDED(hr) && !AiffFormat.dwCompression)

  000cf	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000d3	7c 0d		 jl	 SHORT $L36303
  000d5	83 7d fc 00	 cmp	 DWORD PTR _AiffFormat$[ebp+16], 0
  000d9	75 07		 jne	 SHORT $L36303

; 1185 :         {
; 1186 :             AiffFormat.dwCompression = WAVELDR_FOURCC_NONE;

  000db	c7 45 fc 4e 4f
	4e 45		 mov	 DWORD PTR _AiffFormat$[ebp+16], 1162760014 ; 454e4f4eH
$L36303:

; 1187 :         }
; 1188 : 
; 1189 :         //
; 1190 :         // Currently, only PCM is supported
; 1191 :         //
; 1192 : 
; 1193 :         if(SUCCEEDED(hr) && (WAVELDR_FOURCC_NONE != AiffFormat.dwCompression))

  000e2	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000e6	7c 3d		 jl	 SHORT $L36305
  000e8	81 7d fc 4e 4f
	4e 45		 cmp	 DWORD PTR _AiffFormat$[ebp+16], 1162760014 ; 454e4f4eH
  000ef	74 34		 je	 SHORT $L36305

; 1194 :         {
; 1195 :             DPF_ERROR("Unsupported AIFF compression type");

  000f1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  000f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@EIPMIGEK@CWaveFile?3?3GetAiffFormat?$AA@
  000fb	68 ab 04 00 00	 push	 1195			; 000004abH
  00100	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  00105	6a 04		 push	 4
  00107	6a 09		 push	 9
  00109	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  0010e	83 c4 18	 add	 esp, 24			; 00000018H
  00111	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@NCAIELLP@Unsupported?5AIFF?5compression?5typ@
  00116	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0011b	83 c4 04	 add	 esp, 4

; 1196 :             hr = E_FAIL;

  0011e	c7 45 cc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36305:

; 1197 :         }
; 1198 : 
; 1199 :         //
; 1200 :         // Convert AIFF format to WAVE format
; 1201 :         //
; 1202 : 
; 1203 :         if(SUCCEEDED(hr))

  00125	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00129	7c 58		 jl	 SHORT $L36310

; 1204 :         {
; 1205 :             AiffFormat.nChannels = EndianSwapWord(AiffFormat.nChannels);

  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _AiffFormat$[ebp]
  0012e	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  00133	66 89 45 ec	 mov	 WORD PTR _AiffFormat$[ebp], ax

; 1206 :             AiffFormat.wBitsPerSample = EndianSwapWord(AiffFormat.wBitsPerSample);

  00137	8b 4d f2	 mov	 ecx, DWORD PTR _AiffFormat$[ebp+6]
  0013a	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0013f	66 89 45 f2	 mov	 WORD PTR _AiffFormat$[ebp+6], ax

; 1207 :             AiffFormat.wFrequencyExponent = EndianSwapWord(AiffFormat.wFrequencyExponent);

  00143	8b 4d f4	 mov	 ecx, DWORD PTR _AiffFormat$[ebp+8]
  00146	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0014b	66 89 45 f4	 mov	 WORD PTR _AiffFormat$[ebp+8], ax

; 1208 :             AiffFormat.dwFrequencyMantissa = EndianSwapDword(AiffFormat.dwFrequencyMantissa);

  0014f	8b 4d f6	 mov	 ecx, DWORD PTR _AiffFormat$[ebp+10]
  00152	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  00157	89 45 f6	 mov	 DWORD PTR _AiffFormat$[ebp+10], eax

; 1209 : 
; 1210 :             XAudioCreatePcmFormat(AiffFormat.nChannels, AiffFormat.dwFrequencyMantissa >> (16414 - (AiffFormat.wFrequencyExponent & 0x7FFF)), AiffFormat.wBitsPerSample, &WaveFormat);

  0015a	8d 4d b8	 lea	 ecx, DWORD PTR _WaveFormat$[ebp]
  0015d	51		 push	 ecx
  0015e	66 8b 55 f2	 mov	 dx, WORD PTR _AiffFormat$[ebp+6]
  00162	52		 push	 edx
  00163	0f b7 45 f4	 movzx	 eax, WORD PTR _AiffFormat$[ebp+8]
  00167	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  0016c	b9 1e 40 00 00	 mov	 ecx, 16414		; 0000401eH
  00171	2b c8		 sub	 ecx, eax
  00173	8b 55 f6	 mov	 edx, DWORD PTR _AiffFormat$[ebp+10]
  00176	d3 ea		 shr	 edx, cl
  00178	52		 push	 edx
  00179	66 8b 45 ec	 mov	 ax, WORD PTR _AiffFormat$[ebp]
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 _XAudioCreatePcmFormat@16
$L36310:

; 1211 :         }
; 1212 : 
; 1213 :         if(SUCCEEDED(hr))

  00183	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00187	7c 29		 jl	 SHORT $L36312

; 1214 :         {
; 1215 :             CopyMemory(pwfxFormat, &WaveFormat, min(sizeof(WaveFormat), dwFormatSize));

  00189	83 7d 0c 12	 cmp	 DWORD PTR _dwFormatSize$[ebp], 18 ; 00000012H
  0018d	76 09		 jbe	 SHORT $L37554
  0018f	c7 45 a8 12 00
	00 00		 mov	 DWORD PTR tv163[ebp], 18 ; 00000012H
  00196	eb 06		 jmp	 SHORT $L37555
$L37554:
  00198	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFormatSize$[ebp]
  0019b	89 4d a8	 mov	 DWORD PTR tv163[ebp], ecx
$L37555:
  0019e	8b 55 a8	 mov	 edx, DWORD PTR tv163[ebp]
  001a1	52		 push	 edx
  001a2	8d 45 b8	 lea	 eax, DWORD PTR _WaveFormat$[ebp]
  001a5	50		 push	 eax
  001a6	8b 4d 08	 mov	 ecx, DWORD PTR _pwfxFormat$[ebp]
  001a9	51		 push	 ecx
  001aa	e8 00 00 00 00	 call	 _memcpy
  001af	83 c4 0c	 add	 esp, 12			; 0000000cH
$L36312:

; 1216 :         }
; 1217 : 
; 1218 :         if(SUCCEEDED(hr) && (dwFormatSize > sizeof(WaveFormat)))

  001b2	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001b6	7c 1e		 jl	 SHORT $L36296
  001b8	83 7d 0c 12	 cmp	 DWORD PTR _dwFormatSize$[ebp], 18 ; 00000012H
  001bc	76 18		 jbe	 SHORT $L36296

; 1219 :         {
; 1220 :             ZeroMemory((LPBYTE)pwfxFormat + sizeof(WaveFormat), dwFormatSize - sizeof(WaveFormat));

  001be	8b 55 0c	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  001c1	83 ea 12	 sub	 edx, 18			; 00000012H
  001c4	52		 push	 edx
  001c5	6a 00		 push	 0
  001c7	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  001ca	83 c0 12	 add	 eax, 18			; 00000012H
  001cd	50		 push	 eax
  001ce	e8 00 00 00 00	 call	 _memset
  001d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$L36296:

; 1221 :         }
; 1222 :     }
; 1223 :     
; 1224 :     if(SUCCEEDED(hr) && pdwRequiredSize)

  001d6	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001da	7c 0f		 jl	 SHORT $L36317
  001dc	83 7d 10 00	 cmp	 DWORD PTR _pdwRequiredSize$[ebp], 0
  001e0	74 09		 je	 SHORT $L36317

; 1225 :     {
; 1226 :         *pdwRequiredSize = sizeof(WaveFormat);

  001e2	8b 4d 10	 mov	 ecx, DWORD PTR _pdwRequiredSize$[ebp]
  001e5	c7 01 12 00 00
	00		 mov	 DWORD PTR [ecx], 18	; 00000012H
$L36317:

; 1227 :     }
; 1228 : 
; 1229 :     DPF_LEAVE_HRESULT(hr);
; 1230 : 
; 1231 :     return hr;

  001eb	8b 55 cc	 mov	 edx, DWORD PTR _hr$[ebp]
  001ee	89 55 b4	 mov	 DWORD PTR $T37556[ebp], edx
  001f1	8d 4d d0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  001f4	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  001f9	8b 45 b4	 mov	 eax, DWORD PTR $T37556[ebp]

; 1232 : }

  001fc	8b e5		 mov	 esp, ebp
  001fe	5d		 pop	 ebp
  001ff	c2 0c 00	 ret	 12			; 0000000cH
?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ENDP ; WaveLoader::CWaveFile::GetAiffFormat
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?EndianSwapWord@@YIGG@Z
DSOUND	SEGMENT
_n$ = -4
?EndianSwapWord@@YIGG@Z PROC NEAR			; EndianSwapWord, COMDAT
; _n$ = cx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	66 89 4d fc	 mov	 WORD PTR _n$[ebp], cx

; 40   :     __asm
; 41   :     {
; 42   :         mov     eax, ecx

  00009	8b c1		 mov	 eax, ecx

; 43   :         sar     eax, 8

  0000b	c1 f8 08	 sar	 eax, 8

; 44   :         and     eax, 0ffh

  0000e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 45   : 
; 46   :         mov     ebx, ecx

  00013	8b d9		 mov	 ebx, ecx

; 47   :         shl     ebx, 8

  00015	c1 e3 08	 shl	 ebx, 8

; 48   :         and     ebx, 0ff00h

  00018	81 e3 00 ff 00
	00		 and	 ebx, 65280		; 0000ff00H

; 49   :         or      eax, ebx

  0001e	0b c3		 or	 eax, ebx

; 50   :     }
; 51   : }

  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?EndianSwapWord@@YIGG@Z ENDP				; EndianSwapWord
DSOUND	ENDS
PUBLIC	?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetWaveLoopRegion
PUBLIC	?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetAiffLoopRegion
PUBLIC	?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z	; WaveLoader::CWaveFile::GetLoopRegion
; Function compile flags: /Odt
;	COMDAT ?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
_pdwLoopStart$ = 8
_pdwLoopLength$ = 12
?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z PROC NEAR ; WaveLoader::CWaveFile::GetLoopRegion, COMDAT
; _this$ = ecx

; 1260 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1261 :     HRESULT                 hr;
; 1262 : 
; 1263 :     DPF_ENTER();
; 1264 : 
; 1265 :     ASSERT(m_pwfxFormat);

  00009	68 f1 04 00 00	 push	 1265			; 000004f1H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@NLKBAEGB@m_pwfxFormat?$AA@
  00018	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	33 c9		 xor	 ecx, ecx
  0001d	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00021	0f 94 c1	 sete	 cl
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 1266 : 
; 1267 :     //
; 1268 :     // Read loop region data in samples
; 1269 :     //
; 1270 : 
; 1271 :     if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  0002d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00030	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00034	75 15		 jne	 SHORT $L36325

; 1272 :     {
; 1273 :         hr = GetWaveLoopRegion(pdwLoopStart, pdwLoopLength);

  00036	8b 45 0c	 mov	 eax, DWORD PTR _pdwLoopLength$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetWaveLoopRegion
  00046	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1274 :     }
; 1275 :     else

  00049	eb 13		 jmp	 SHORT $L36326
$L36325:

; 1276 :     {
; 1277 :         hr = GetAiffLoopRegion(pdwLoopStart, pdwLoopLength);

  0004b	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  0004e	52		 push	 edx
  0004f	8b 45 08	 mov	 eax, DWORD PTR _pdwLoopStart$[ebp]
  00052	50		 push	 eax
  00053	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetAiffLoopRegion
  0005b	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L36326:

; 1278 :     }
; 1279 : 
; 1280 :     //
; 1281 :     // Convert to bytes
; 1282 :     //
; 1283 : 
; 1284 :     if(SUCCEEDED(hr))

  0005e	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00062	0f 8c a8 00 00
	00		 jl	 $L36328

; 1285 :     {
; 1286 :         if(WAVE_FORMAT_XBOX_ADPCM == m_pwfxFormat->wFormatTag)

  00068	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0006e	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00071	83 f8 69	 cmp	 eax, 105		; 00000069H
  00074	75 6c		 jne	 SHORT $L36329

; 1287 :         {
; 1288 :             *pdwLoopStart /= m_pwfxFormat->nChannels * XBOX_ADPCM_SAMPLES_PER_BLOCK;

  00076	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0007c	0f b7 4a 02	 movzx	 ecx, WORD PTR [edx+2]
  00080	c1 e1 06	 shl	 ecx, 6
  00083	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  00086	8b 02		 mov	 eax, DWORD PTR [edx]
  00088	33 d2		 xor	 edx, edx
  0008a	f7 f1		 div	 ecx
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  0008f	89 01		 mov	 DWORD PTR [ecx], eax

; 1289 :             *pdwLoopStart *= m_pwfxFormat->nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  00091	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00094	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00097	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  0009b	6b c9 24	 imul	 ecx, 36			; 00000024H
  0009e	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  000a1	8b 02		 mov	 eax, DWORD PTR [edx]
  000a3	0f af c1	 imul	 eax, ecx
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax

; 1290 : 
; 1291 :             *pdwLoopLength /= m_pwfxFormat->nChannels * XBOX_ADPCM_SAMPLES_PER_BLOCK;

  000ab	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ae	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000b1	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  000b5	c1 e1 06	 shl	 ecx, 6
  000b8	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  000bb	8b 02		 mov	 eax, DWORD PTR [edx]
  000bd	33 d2		 xor	 edx, edx
  000bf	f7 f1		 div	 ecx
  000c1	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwLoopLength$[ebp]
  000c4	89 01		 mov	 DWORD PTR [ecx], eax

; 1292 :             *pdwLoopLength *= m_pwfxFormat->nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  000c6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000c9	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000cc	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  000d0	6b c9 24	 imul	 ecx, 36			; 00000024H
  000d3	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  000d6	8b 02		 mov	 eax, DWORD PTR [edx]
  000d8	0f af c1	 imul	 eax, ecx
  000db	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwLoopLength$[ebp]
  000de	89 01		 mov	 DWORD PTR [ecx], eax

; 1293 :         }
; 1294 :         else

  000e0	eb 2e		 jmp	 SHORT $L36328
$L36329:

; 1295 :         {
; 1296 :             *pdwLoopStart *= m_pwfxFormat->nBlockAlign;

  000e2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000e5	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000e8	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  000ec	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  000ef	8b 02		 mov	 eax, DWORD PTR [edx]
  000f1	0f af c1	 imul	 eax, ecx
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  000f7	89 01		 mov	 DWORD PTR [ecx], eax

; 1297 :             *pdwLoopLength *= m_pwfxFormat->nBlockAlign;

  000f9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000fc	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000ff	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00103	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  00106	8b 02		 mov	 eax, DWORD PTR [edx]
  00108	0f af c1	 imul	 eax, ecx
  0010b	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwLoopLength$[ebp]
  0010e	89 01		 mov	 DWORD PTR [ecx], eax
$L36328:

; 1298 :         }
; 1299 :     }
; 1300 : 
; 1301 :     DPF_LEAVE_HRESULT(hr);
; 1302 : 
; 1303 :     return hr;

  00110	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1304 : }

  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 08 00	 ret	 8
?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z ENDP	; WaveLoader::CWaveFile::GetLoopRegion
DSOUND	ENDS
PUBLIC	??_C@_0CC@IFLBNNFE@CStdFileStream?3?3GetWaveLoopRegio@ ; `string'
PUBLIC	??_C@_0BO@GLLFAJJE@No?5FORWARD?5loop?5regions?5found?$AA@ ; `string'
PUBLIC	??_C@_0CJ@LNLNMGAM@Only?5the?5first?5FORWARD?5loop?5will@ ; `string'
;	COMDAT ??_C@_0CC@IFLBNNFE@CStdFileStream?3?3GetWaveLoopRegio@
DSOUND_RD	SEGMENT
??_C@_0CC@IFLBNNFE@CStdFileStream?3?3GetWaveLoopRegio@ DB 'CStdFileStream'
	DB	'::GetWaveLoopRegion', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BO@GLLFAJJE@No?5FORWARD?5loop?5regions?5found?$AA@
DSOUND_RD	SEGMENT
??_C@_0BO@GLLFAJJE@No?5FORWARD?5loop?5regions?5found?$AA@ DB 'No FORWARD '
	DB	'loop regions found', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0CJ@LNLNMGAM@Only?5the?5first?5FORWARD?5loop?5will@
DSOUND_RD	SEGMENT
??_C@_0CJ@LNLNMGAM@Only?5the?5first?5FORWARD?5loop?5will@ DB 'Only the fi'
	DB	'rst FORWARD loop will be used', 00H		; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
DSOUND	SEGMENT
_this$ = -76
$T37566 = -72
_InstrumentChunk$ = -68
_hr$ = -44
_dwOffset$ = -40
_loop$ = -36
_wsamp$ = -20
_pdwLoopStart$ = 8
_pdwLoopLength$ = 12
?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z PROC NEAR ; WaveLoader::CWaveFile::GetWaveLoopRegion, COMDAT
; _this$ = ecx

; 1332 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 1333 :     CRiffChunk              InstrumentChunk;

  00009	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1334 :     WAVESAMPLE              wsamp;
; 1335 :     WAVESAMPLE_LOOP         loop;
; 1336 :     DWORD                   dwOffset;
; 1337 :     HRESULT                 hr;
; 1338 : 
; 1339 :     DPF_ENTER();
; 1340 : 
; 1341 :     ASSERT(m_pwfxFormat);

  00011	68 3d 05 00 00	 push	 1341			; 0000053dH
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@NLKBAEGB@m_pwfxFormat?$AA@
  00020	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00023	33 c9		 xor	 ecx, ecx
  00025	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00029	0f 94 c1	 sete	 cl
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 1342 : 
; 1343 :     //
; 1344 :     // Open the instrument chunk
; 1345 :     //
; 1346 : 
; 1347 :     hr = InstrumentChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_WAVE_SAMPLE);

  00035	68 77 73 6d 70	 push	 1886221175		; 706d7377H
  0003a	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	52		 push	 edx
  0003e	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 c0 08	 add	 eax, 8
  00044	50		 push	 eax
  00045	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00048	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  0004d	89 45 d4	 mov	 DWORD PTR _hr$[ebp], eax

; 1348 : 
; 1349 :     //
; 1350 :     // Read the WAVESAMPLE header and first loop region
; 1351 :     //
; 1352 : 
; 1353 :     if(SUCCEEDED(hr))

  00050	83 7d d4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00054	7c 15		 jl	 SHORT $L36342

; 1354 :     {
; 1355 :         hr = InstrumentChunk.Read(0, &wsamp, sizeof(wsamp));

  00056	6a 00		 push	 0
  00058	6a 14		 push	 20			; 00000014H
  0005a	8d 4d ec	 lea	 ecx, DWORD PTR _wsamp$[ebp]
  0005d	51		 push	 ecx
  0005e	6a 00		 push	 0
  00060	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00063	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00068	89 45 d4	 mov	 DWORD PTR _hr$[ebp], eax
$L36342:

; 1356 :     }
; 1357 : 
; 1358 :     //
; 1359 :     // Scan loop regions until we find one that's FORWARD or RELEASE
; 1360 :     //
; 1361 : 
; 1362 :     if(SUCCEEDED(hr))

  0006b	83 7d d4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006f	7c 52		 jl	 SHORT $L36344

; 1363 :     {
; 1364 :         dwOffset = sizeof(wsamp);

  00071	c7 45 d8 14 00
	00 00		 mov	 DWORD PTR _dwOffset$[ebp], 20 ; 00000014H
$L36346:

; 1365 :     
; 1366 :         while(SUCCEEDED(hr) && wsamp.dwSampleLoops)

  00078	83 7d d4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0007c	7c 45		 jl	 SHORT $L36344
  0007e	83 7d fc 00	 cmp	 DWORD PTR _wsamp$[ebp+16], 0
  00082	74 3f		 je	 SHORT $L36344

; 1367 :         {
; 1368 :             hr = InstrumentChunk.Read(dwOffset, &loop, sizeof(loop));

  00084	6a 00		 push	 0
  00086	6a 10		 push	 16			; 00000010H
  00088	8d 55 dc	 lea	 edx, DWORD PTR _loop$[ebp]
  0008b	52		 push	 edx
  0008c	8b 45 d8	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  0008f	50		 push	 eax
  00090	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00093	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00098	89 45 d4	 mov	 DWORD PTR _hr$[ebp], eax

; 1369 : 
; 1370 :             if(SUCCEEDED(hr))

  0009b	83 7d d4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0009f	7c 0e		 jl	 SHORT $L36350

; 1371 :             {
; 1372 :                 if((WAVESAMPLE_LOOPTYPE_FORWARD == loop.dwLoopType) || (WAVESAMPLE_LOOPTYPE_RELEASE == loop.dwLoopType))

  000a1	83 7d e0 00	 cmp	 DWORD PTR _loop$[ebp+4], 0
  000a5	74 06		 je	 SHORT $L36352
  000a7	83 7d e0 01	 cmp	 DWORD PTR _loop$[ebp+4], 1
  000ab	75 02		 jne	 SHORT $L36350
$L36352:

; 1373 :                 {
; 1374 :                     break;

  000ad	eb 14		 jmp	 SHORT $L36344
$L36350:

; 1375 :                 }
; 1376 :             }
; 1377 :         
; 1378 :             dwOffset += sizeof(loop);

  000af	8b 4d d8	 mov	 ecx, DWORD PTR _dwOffset$[ebp]
  000b2	83 c1 10	 add	 ecx, 16			; 00000010H
  000b5	89 4d d8	 mov	 DWORD PTR _dwOffset$[ebp], ecx

; 1379 : 
; 1380 :             wsamp.dwSampleLoops--;

  000b8	8b 55 fc	 mov	 edx, DWORD PTR _wsamp$[ebp+16]
  000bb	83 ea 01	 sub	 edx, 1
  000be	89 55 fc	 mov	 DWORD PTR _wsamp$[ebp+16], edx

; 1381 :         }

  000c1	eb b5		 jmp	 SHORT $L36346
$L36344:

; 1382 :     }
; 1383 : 
; 1384 :     if(SUCCEEDED(hr))

  000c3	83 7d d4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000c7	7c 6f		 jl	 SHORT $L36354

; 1385 :     {
; 1386 :         if(!wsamp.dwSampleLoops)

  000c9	83 7d fc 00	 cmp	 DWORD PTR _wsamp$[ebp+16], 0
  000cd	75 36		 jne	 SHORT $L36355

; 1387 :         {
; 1388 :             DPF_ERROR("No FORWARD loop regions found");

  000cf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  000d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@IFLBNNFE@CStdFileStream?3?3GetWaveLoopRegio@
  000d9	68 6c 05 00 00	 push	 1388			; 0000056cH
  000de	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  000e3	6a 04		 push	 4
  000e5	6a 09		 push	 9
  000e7	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000ec	83 c4 18	 add	 esp, 24			; 00000018H
  000ef	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@GLLFAJJE@No?5FORWARD?5loop?5regions?5found?$AA@
  000f4	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000f9	83 c4 04	 add	 esp, 4

; 1389 :             hr = E_FAIL;

  000fc	c7 45 d4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1390 :         }
; 1391 :         else if(wsamp.dwSampleLoops > 1)

  00103	eb 33		 jmp	 SHORT $L36354
$L36355:
  00105	83 7d fc 01	 cmp	 DWORD PTR _wsamp$[ebp+16], 1
  00109	76 2d		 jbe	 SHORT $L36354

; 1392 :         {
; 1393 :             DPF_WARNING("Only the first FORWARD loop will be used");

  0010b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  00110	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@IFLBNNFE@CStdFileStream?3?3GetWaveLoopRegio@
  00115	68 71 05 00 00	 push	 1393			; 00000571H
  0011a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0011f	6a 04		 push	 4
  00121	6a 09		 push	 9
  00123	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00128	83 c4 18	 add	 esp, 24			; 00000018H
  0012b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@LNLNMGAM@Only?5the?5first?5FORWARD?5loop?5will@
  00130	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00135	83 c4 04	 add	 esp, 4
$L36354:

; 1394 :         }
; 1395 :     }
; 1396 : 
; 1397 :     //
; 1398 :     // Success
; 1399 :     //
; 1400 : 
; 1401 :     if(SUCCEEDED(hr))

  00138	83 7d d4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0013c	7c 10		 jl	 SHORT $L36363

; 1402 :     {
; 1403 :         *pdwLoopStart = loop.dwLoopStart;

  0013e	8b 45 08	 mov	 eax, DWORD PTR _pdwLoopStart$[ebp]
  00141	8b 4d e4	 mov	 ecx, DWORD PTR _loop$[ebp+8]
  00144	89 08		 mov	 DWORD PTR [eax], ecx

; 1404 :         *pdwLoopLength = loop.dwLoopLength;

  00146	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  00149	8b 45 e8	 mov	 eax, DWORD PTR _loop$[ebp+12]
  0014c	89 02		 mov	 DWORD PTR [edx], eax
$L36363:

; 1405 :     }
; 1406 : 
; 1407 :     DPF_LEAVE_HRESULT(hr);
; 1408 : 
; 1409 :     return hr;

  0014e	8b 4d d4	 mov	 ecx, DWORD PTR _hr$[ebp]
  00151	89 4d b8	 mov	 DWORD PTR $T37566[ebp], ecx
  00154	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00157	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  0015c	8b 45 b8	 mov	 eax, DWORD PTR $T37566[ebp]

; 1410 : }

  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c2 08 00	 ret	 8
?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ENDP ; WaveLoader::CWaveFile::GetWaveLoopRegion
DSOUND	ENDS
PUBLIC	??_C@_0CC@BDOJPMPF@CStdFileStream?3?3GetAiffLoopRegio@ ; `string'
PUBLIC	??_C@_0BI@FNJEOFIE@Neither?5loop?5is?5FORWARD?$AA@ ; `string'
PUBLIC	??_C@_0DF@NNLKMLKP@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@ ; `string'
PUBLIC	??_C@_0BN@NNMJOLHM@Can?8t?5find?5loop?5start?5marker?$AA@ ; `string'
PUBLIC	??_C@_0DD@LMHJPJKK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@ ; `string'
PUBLIC	??_C@_0BL@NJFKBAAP@Can?8t?5find?5loop?5end?5marker?$AA@ ; `string'
PUBLIC	??_C@_0DB@NDLCCDDP@Loop?5end?5point?5less?9than?9or?9equa@ ; `string'
;	COMDAT ??_C@_0CC@BDOJPMPF@CStdFileStream?3?3GetAiffLoopRegio@
DSOUND_RD	SEGMENT
??_C@_0CC@BDOJPMPF@CStdFileStream?3?3GetAiffLoopRegio@ DB 'CStdFileStream'
	DB	'::GetAiffLoopRegion', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BI@FNJEOFIE@Neither?5loop?5is?5FORWARD?$AA@
DSOUND_RD	SEGMENT
??_C@_0BI@FNJEOFIE@Neither?5loop?5is?5FORWARD?$AA@ DB 'Neither loop is FO'
	DB	'RWARD', 00H					; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DF@NNLKMLKP@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@
DSOUND_RD	SEGMENT
??_C@_0DF@NNLKMLKP@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@ DB '('
	DB	'DWORD)pStartMarker < (DWORD)pMarkers + dwMarkerSize', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BN@NNMJOLHM@Can?8t?5find?5loop?5start?5marker?$AA@
DSOUND_RD	SEGMENT
??_C@_0BN@NNMJOLHM@Can?8t?5find?5loop?5start?5marker?$AA@ DB 'Can''t find'
	DB	' loop start marker', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DD@LMHJPJKK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@
DSOUND_RD	SEGMENT
??_C@_0DD@LMHJPJKK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@ DB '('
	DB	'DWORD)pEndMarker < (DWORD)pMarkers + dwMarkerSize', 00H ; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0BL@NJFKBAAP@Can?8t?5find?5loop?5end?5marker?$AA@
DSOUND_RD	SEGMENT
??_C@_0BL@NJFKBAAP@Can?8t?5find?5loop?5end?5marker?$AA@ DB 'Can''t find l'
	DB	'oop end marker', 00H			; `string'
DSOUND_RD	ENDS
;	COMDAT ??_C@_0DB@NDLCCDDP@Loop?5end?5point?5less?9than?9or?9equa@
DSOUND_RD	SEGMENT
??_C@_0DB@NDLCCDDP@Loop?5end?5point?5less?9than?9or?9equa@ DB 'Loop end p'
	DB	'oint less-than-or-equal-to start point', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
DSOUND	SEGMENT
_this$ = -108
$T37570 = -104
_InstrumentChunk$ = -100
_pEndMarker$ = -76
_hr$ = -72
_inst$ = -64
_pLoop$ = -44
_pMarkers$ = -40
_MarkerChunk$ = -36
_i$ = -12
_dwMarkerSize$ = -8
_pStartMarker$ = -4
_pdwLoopStart$ = 8
_pdwLoopLength$ = 12
?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z PROC NEAR ; WaveLoader::CWaveFile::GetAiffLoopRegion, COMDAT
; _this$ = ecx

; 1438 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	89 4d 94	 mov	 DWORD PTR _this$[ebp], ecx

; 1439 :     LPAIFFMARKERHDR         pMarkers            = NULL;

  00009	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pMarkers$[ebp], 0

; 1440 :     CRiffChunk              InstrumentChunk;

  00010	8d 4d 9c	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1441 :     AIFFINSTRUMENT          inst;
; 1442 :     LPAIFFLOOP              pLoop;
; 1443 :     CRiffChunk              MarkerChunk;

  00018	8d 4d dc	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1444 :     DWORD                   dwMarkerSize;
; 1445 :     AIFFMARKERHDR           MarkerHeader;
; 1446 :     LPAIFFMARKER            pStartMarker;
; 1447 :     LPAIFFMARKER            pEndMarker;
; 1448 :     HRESULT                 hr;
; 1449 :     WORD                    i;
; 1450 : 
; 1451 :     DPF_ENTER();
; 1452 : 
; 1453 :     //
; 1454 :     // Open the instrument chunk
; 1455 :     //
; 1456 : 
; 1457 :     hr = InstrumentChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_INSTRUMENT);

  00020	68 49 4e 53 54	 push	 1414745673		; 54534e49H
  00025	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 08	 add	 ecx, 8
  0002f	51		 push	 ecx
  00030	8d 4d 9c	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00033	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00038	89 45 b8	 mov	 DWORD PTR _hr$[ebp], eax

; 1458 : 
; 1459 :     //
; 1460 :     // Read the instrument data
; 1461 :     //
; 1462 : 
; 1463 :     if(SUCCEEDED(hr))

  0003b	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0003f	7c 15		 jl	 SHORT $L36382

; 1464 :     {
; 1465 :         hr = InstrumentChunk.Read(0, &inst, sizeof(inst));

  00041	6a 00		 push	 0
  00043	6a 14		 push	 20			; 00000014H
  00045	8d 55 c0	 lea	 edx, DWORD PTR _inst$[ebp]
  00048	52		 push	 edx
  00049	6a 00		 push	 0
  0004b	8d 4d 9c	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  0004e	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00053	89 45 b8	 mov	 DWORD PTR _hr$[ebp], eax
$L36382:

; 1466 :     }
; 1467 : 
; 1468 :     //
; 1469 :     // Use the first loop that's FORWARD
; 1470 :     //
; 1471 : 
; 1472 :     if(SUCCEEDED(hr))

  00056	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0005a	7c 64		 jl	 SHORT $L36384

; 1473 :     {
; 1474 :         if(AIFFLOOP_MODE_FORWARD == EndianSwapWord(inst.SustainLoop.wPlayMode))

  0005c	8b 4d c8	 mov	 ecx, DWORD PTR _inst$[ebp+8]
  0005f	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  00064	0f b7 c0	 movzx	 eax, ax
  00067	83 f8 01	 cmp	 eax, 1
  0006a	75 08		 jne	 SHORT $L36385

; 1475 :         {
; 1476 :             pLoop = &inst.SustainLoop;

  0006c	8d 4d c8	 lea	 ecx, DWORD PTR _inst$[ebp+8]
  0006f	89 4d d4	 mov	 DWORD PTR _pLoop$[ebp], ecx

; 1477 :         }
; 1478 :         else if(AIFFLOOP_MODE_FORWARD == EndianSwapWord(inst.ReleaseLoop.wPlayMode))

  00072	eb 4c		 jmp	 SHORT $L36384
$L36385:
  00074	8b 4d ce	 mov	 ecx, DWORD PTR _inst$[ebp+14]
  00077	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0007c	0f b7 d0	 movzx	 edx, ax
  0007f	83 fa 01	 cmp	 edx, 1
  00082	75 08		 jne	 SHORT $L36387

; 1479 :         {
; 1480 :             pLoop = &inst.ReleaseLoop;

  00084	8d 45 ce	 lea	 eax, DWORD PTR _inst$[ebp+14]
  00087	89 45 d4	 mov	 DWORD PTR _pLoop$[ebp], eax

; 1481 :         }
; 1482 :         else

  0008a	eb 34		 jmp	 SHORT $L36384
$L36387:

; 1483 :         {
; 1484 :             DPF_ERROR("Neither loop is FORWARD");

  0008c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  00091	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@BDOJPMPF@CStdFileStream?3?3GetAiffLoopRegio@
  00096	68 cc 05 00 00	 push	 1484			; 000005ccH
  0009b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  000a0	6a 04		 push	 4
  000a2	6a 09		 push	 9
  000a4	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  000a9	83 c4 18	 add	 esp, 24			; 00000018H
  000ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@FNJEOFIE@Neither?5loop?5is?5FORWARD?$AA@
  000b1	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  000b6	83 c4 04	 add	 esp, 4

; 1485 :             hr = E_FAIL;

  000b9	c7 45 b8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36384:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     //
; 1490 :     // Open the marker chunk
; 1491 :     //
; 1492 : 
; 1493 :     if(SUCCEEDED(hr))

  000c0	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000c4	7c 1b		 jl	 SHORT $L36393

; 1494 :     {
; 1495 :         hr = MarkerChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_MARKER);

  000c6	68 4d 41 52 4b	 push	 1263681869		; 4b52414dH
  000cb	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	51		 push	 ecx
  000cf	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  000d2	83 c2 08	 add	 edx, 8
  000d5	52		 push	 edx
  000d6	8d 4d dc	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  000d9	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  000de	89 45 b8	 mov	 DWORD PTR _hr$[ebp], eax
$L36393:

; 1496 :     }
; 1497 : 
; 1498 :     // 
; 1499 :     // Read marker data
; 1500 :     //
; 1501 : 
; 1502 :     if(SUCCEEDED(hr))

  000e1	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000e5	7c 40		 jl	 SHORT $L36395

; 1503 :     {
; 1504 :         dwMarkerSize = MarkerChunk.GetDataSize();

  000e7	8d 4d dc	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  000ea	e8 00 00 00 00	 call	 ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ; WaveLoader::CRiffChunk::GetDataSize
  000ef	89 45 f8	 mov	 DWORD PTR _dwMarkerSize$[ebp], eax

; 1505 :         
; 1506 :         hr = HRFROMP(pMarkers = (LPAIFFMARKERHDR)MEMALLOC(BYTE, dwMarkerSize));

  000f2	6a 01		 push	 1
  000f4	8b 45 f8	 mov	 eax, DWORD PTR _dwMarkerSize$[ebp]
  000f7	50		 push	 eax
  000f8	68 44 53 64 61	 push	 1633964868		; 61645344H
  000fd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04ELFAHOMP@BYTE?$AA@
  00102	68 e2 05 00 00	 push	 1506			; 000005e2H
  00107	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0010c	e8 00 00 00 00	 call	 ?TrackingMemAlloc@CMemoryManager@DirectSound@@SGPAXPBDK0W4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::TrackingMemAlloc
  00111	89 45 d8	 mov	 DWORD PTR _pMarkers$[ebp], eax
  00114	33 c9		 xor	 ecx, ecx
  00116	83 7d d8 00	 cmp	 DWORD PTR _pMarkers$[ebp], 0
  0011a	0f 95 c1	 setne	 cl
  0011d	49		 dec	 ecx
  0011e	81 e1 0e 00 07
	80		 and	 ecx, -2147024882	; 8007000eH
  00124	89 4d b8	 mov	 DWORD PTR _hr$[ebp], ecx
$L36395:

; 1507 :     }
; 1508 : 
; 1509 :     if(SUCCEEDED(hr))

  00127	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0012b	7c 17		 jl	 SHORT $L36402

; 1510 :     {
; 1511 :         hr = MarkerChunk.Read(0, pMarkers, dwMarkerSize);

  0012d	6a 00		 push	 0
  0012f	8b 55 f8	 mov	 edx, DWORD PTR _dwMarkerSize$[ebp]
  00132	52		 push	 edx
  00133	8b 45 d8	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  00136	50		 push	 eax
  00137	6a 00		 push	 0
  00139	8d 4d dc	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  0013c	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00141	89 45 b8	 mov	 DWORD PTR _hr$[ebp], eax
$L36402:

; 1512 :     }
; 1513 : 
; 1514 :     if(SUCCEEDED(hr))

  00144	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00148	7c 11		 jl	 SHORT $L36404

; 1515 :     {
; 1516 :         pMarkers->wMarkerCount = EndianSwapWord(pMarkers->wMarkerCount);

  0014a	8b 4d d8	 mov	 ecx, DWORD PTR _pMarkers$[ebp]
  0014d	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00150	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  00155	8b 55 d8	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  00158	66 89 02	 mov	 WORD PTR [edx], ax
$L36404:

; 1517 :     }
; 1518 : 
; 1519 :     //
; 1520 :     // Find the loop markers
; 1521 :     //
; 1522 : 
; 1523 :     if(SUCCEEDED(hr))

  0015b	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0015f	0f 8c b7 00 00
	00		 jl	 $L36406

; 1524 :     {
; 1525 :         pStartMarker = (LPAIFFMARKER)(pMarkers + 1);

  00165	8b 45 d8	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  00168	83 c0 02	 add	 eax, 2
  0016b	89 45 fc	 mov	 DWORD PTR _pStartMarker$[ebp], eax

; 1526 :         
; 1527 :         for(i = 0; i < pMarkers->wMarkerCount; i++)

  0016e	66 c7 45 f4 00
	00		 mov	 WORD PTR _i$[ebp], 0
  00174	eb 0c		 jmp	 SHORT $L36408
$L36409:
  00176	66 8b 4d f4	 mov	 cx, WORD PTR _i$[ebp]
  0017a	66 83 c1 01	 add	 cx, 1
  0017e	66 89 4d f4	 mov	 WORD PTR _i$[ebp], cx
$L36408:
  00182	0f b7 55 f4	 movzx	 edx, WORD PTR _i$[ebp]
  00186	8b 45 d8	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  00189	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0018c	3b d1		 cmp	 edx, ecx
  0018e	7d 4a		 jge	 SHORT $L36410

; 1528 :         {
; 1529 :             ASSERT((DWORD)pStartMarker < (DWORD)pMarkers + dwMarkerSize);

  00190	68 f9 05 00 00	 push	 1529			; 000005f9H
  00195	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0019a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DF@NNLKMLKP@?$CIDWORD?$CJpStartMarker?5?$DM?5?$CIDWORD?$CJpMa@
  0019f	8b 55 d8	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  001a2	03 55 f8	 add	 edx, DWORD PTR _dwMarkerSize$[ebp]
  001a5	39 55 fc	 cmp	 DWORD PTR _pStartMarker$[ebp], edx
  001a8	1b c0		 sbb	 eax, eax
  001aa	40		 inc	 eax
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  001b1	83 c4 10	 add	 esp, 16			; 00000010H

; 1530 :             
; 1531 :             if(pStartMarker->wMarkerId == pLoop->wStartMarker)

  001b4	8b 4d fc	 mov	 ecx, DWORD PTR _pStartMarker$[ebp]
  001b7	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  001ba	8b 45 d4	 mov	 eax, DWORD PTR _pLoop$[ebp]
  001bd	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  001c1	3b d1		 cmp	 edx, ecx
  001c3	75 02		 jne	 SHORT $L36414

; 1532 :             {
; 1533 :                 break;

  001c5	eb 13		 jmp	 SHORT $L36410
$L36414:

; 1534 :             }
; 1535 : 
; 1536 :             pStartMarker = (LPAIFFMARKER)((LPBYTE)pStartMarker + sizeof(*pStartMarker) + pStartMarker->bNameLength);

  001c7	8b 55 fc	 mov	 edx, DWORD PTR _pStartMarker$[ebp]
  001ca	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  001ce	8b 4d fc	 mov	 ecx, DWORD PTR _pStartMarker$[ebp]
  001d1	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  001d5	89 55 fc	 mov	 DWORD PTR _pStartMarker$[ebp], edx

; 1537 :         }

  001d8	eb 9c		 jmp	 SHORT $L36409
$L36410:

; 1538 : 
; 1539 :         if(i >= pMarkers->wMarkerCount)

  001da	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  001de	8b 4d d8	 mov	 ecx, DWORD PTR _pMarkers$[ebp]
  001e1	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  001e4	3b c2		 cmp	 eax, edx
  001e6	7c 34		 jl	 SHORT $L36406

; 1540 :         {
; 1541 :             DPF_ERROR("Can't find loop start marker");

  001e8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  001ed	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@BDOJPMPF@CStdFileStream?3?3GetAiffLoopRegio@
  001f2	68 05 06 00 00	 push	 1541			; 00000605H
  001f7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  001fc	6a 04		 push	 4
  001fe	6a 09		 push	 9
  00200	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00205	83 c4 18	 add	 esp, 24			; 00000018H
  00208	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@NNMJOLHM@Can?8t?5find?5loop?5start?5marker?$AA@
  0020d	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  00212	83 c4 04	 add	 esp, 4

; 1542 :             hr = E_FAIL;

  00215	c7 45 b8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36406:

; 1543 :         }
; 1544 :     }
; 1545 : 
; 1546 :     if(SUCCEEDED(hr))

  0021c	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00220	0f 8c b7 00 00
	00		 jl	 $L36421

; 1547 :     {
; 1548 :         pEndMarker = (LPAIFFMARKER)(pMarkers + 1);

  00226	8b 45 d8	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  00229	83 c0 02	 add	 eax, 2
  0022c	89 45 b4	 mov	 DWORD PTR _pEndMarker$[ebp], eax

; 1549 :         
; 1550 :         for(i = 0; i < pMarkers->wMarkerCount; i++)

  0022f	66 c7 45 f4 00
	00		 mov	 WORD PTR _i$[ebp], 0
  00235	eb 0c		 jmp	 SHORT $L36423
$L36424:
  00237	66 8b 4d f4	 mov	 cx, WORD PTR _i$[ebp]
  0023b	66 83 c1 01	 add	 cx, 1
  0023f	66 89 4d f4	 mov	 WORD PTR _i$[ebp], cx
$L36423:
  00243	0f b7 55 f4	 movzx	 edx, WORD PTR _i$[ebp]
  00247	8b 45 d8	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  0024a	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0024d	3b d1		 cmp	 edx, ecx
  0024f	7d 4a		 jge	 SHORT $L36425

; 1551 :         {
; 1552 :             ASSERT((DWORD)pEndMarker < (DWORD)pMarkers + dwMarkerSize);

  00251	68 10 06 00 00	 push	 1552			; 00000610H
  00256	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  0025b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@LMHJPJKK@?$CIDWORD?$CJpEndMarker?5?$DM?5?$CIDWORD?$CJpMark@
  00260	8b 55 d8	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  00263	03 55 f8	 add	 edx, DWORD PTR _dwMarkerSize$[ebp]
  00266	39 55 b4	 cmp	 DWORD PTR _pEndMarker$[ebp], edx
  00269	1b c0		 sbb	 eax, eax
  0026b	40		 inc	 eax
  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00272	83 c4 10	 add	 esp, 16			; 00000010H

; 1553 :             
; 1554 :             if(pEndMarker->wMarkerId == pLoop->wEndMarker)

  00275	8b 4d b4	 mov	 ecx, DWORD PTR _pEndMarker$[ebp]
  00278	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0027b	8b 45 d4	 mov	 eax, DWORD PTR _pLoop$[ebp]
  0027e	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00282	3b d1		 cmp	 edx, ecx
  00284	75 02		 jne	 SHORT $L36429

; 1555 :             {
; 1556 :                 break;

  00286	eb 13		 jmp	 SHORT $L36425
$L36429:

; 1557 :             }
; 1558 : 
; 1559 :             pEndMarker = (LPAIFFMARKER)((LPBYTE)pEndMarker + sizeof(*pEndMarker) + pEndMarker->bNameLength);

  00288	8b 55 b4	 mov	 edx, DWORD PTR _pEndMarker$[ebp]
  0028b	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  0028f	8b 4d b4	 mov	 ecx, DWORD PTR _pEndMarker$[ebp]
  00292	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00296	89 55 b4	 mov	 DWORD PTR _pEndMarker$[ebp], edx

; 1560 :         }

  00299	eb 9c		 jmp	 SHORT $L36424
$L36425:

; 1561 : 
; 1562 :         if(i >= pMarkers->wMarkerCount)

  0029b	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  0029f	8b 4d d8	 mov	 ecx, DWORD PTR _pMarkers$[ebp]
  002a2	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  002a5	3b c2		 cmp	 eax, edx
  002a7	7c 34		 jl	 SHORT $L36421

; 1563 :         {
; 1564 :             DPF_ERROR("Can't find loop end marker");

  002a9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  002ae	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@BDOJPMPF@CStdFileStream?3?3GetAiffLoopRegio@
  002b3	68 1c 06 00 00	 push	 1564			; 0000061cH
  002b8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  002bd	6a 04		 push	 4
  002bf	6a 09		 push	 9
  002c1	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  002c6	83 c4 18	 add	 esp, 24			; 00000018H
  002c9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@NJFKBAAP@Can?8t?5find?5loop?5end?5marker?$AA@
  002ce	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  002d3	83 c4 04	 add	 esp, 4

; 1565 :             hr = E_FAIL;

  002d6	c7 45 b8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36421:

; 1566 :         }
; 1567 :     }
; 1568 : 
; 1569 :     //
; 1570 :     // Double-check the marker validity
; 1571 :     //
; 1572 : 
; 1573 :     if(SUCCEEDED(hr))

  002dd	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002e1	7c 64		 jl	 SHORT $L36436

; 1574 :     {
; 1575 :         pStartMarker->dwPosition = EndianSwapDword(pStartMarker->dwPosition);

  002e3	8b 45 fc	 mov	 eax, DWORD PTR _pStartMarker$[ebp]
  002e6	8b 48 02	 mov	 ecx, DWORD PTR [eax+2]
  002e9	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  002ee	8b 4d fc	 mov	 ecx, DWORD PTR _pStartMarker$[ebp]
  002f1	89 41 02	 mov	 DWORD PTR [ecx+2], eax

; 1576 :         pEndMarker->dwPosition = EndianSwapDword(pEndMarker->dwPosition);

  002f4	8b 55 b4	 mov	 edx, DWORD PTR _pEndMarker$[ebp]
  002f7	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  002fa	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  002ff	8b 4d b4	 mov	 ecx, DWORD PTR _pEndMarker$[ebp]
  00302	89 41 02	 mov	 DWORD PTR [ecx+2], eax

; 1577 : 
; 1578 :         if(pStartMarker->dwPosition >= pEndMarker->dwPosition)

  00305	8b 55 fc	 mov	 edx, DWORD PTR _pStartMarker$[ebp]
  00308	8b 45 b4	 mov	 eax, DWORD PTR _pEndMarker$[ebp]
  0030b	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  0030e	3b 48 02	 cmp	 ecx, DWORD PTR [eax+2]
  00311	72 34		 jb	 SHORT $L36436

; 1579 :         {
; 1580 :             DPF_ERROR("Loop end point less-than-or-equal-to start point");

  00313	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JAKMBBHB@DSOUND?$AA@
  00318	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@BDOJPMPF@CStdFileStream?3?3GetAiffLoopRegio@
  0031d	68 2c 06 00 00	 push	 1580			; 0000062cH
  00322	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  00327	6a 04		 push	 4
  00329	6a 09		 push	 9
  0032b	e8 00 00 00 00	 call	 ?SetContext@CDebug@DirectSound@@SAXKKPBDI00@Z ; DirectSound::CDebug::SetContext
  00330	83 c4 18	 add	 esp, 24			; 00000018H
  00333	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@NDLCCDDP@Loop?5end?5point?5less?9than?9or?9equa@
  00338	e8 00 00 00 00	 call	 ?Print@CDebug@DirectSound@@SAXPBDZZ ; DirectSound::CDebug::Print
  0033d	83 c4 04	 add	 esp, 4

; 1581 :             hr = E_FAIL;

  00340	c7 45 b8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L36436:

; 1582 :         }
; 1583 :     }
; 1584 : 
; 1585 :     //
; 1586 :     // Success
; 1587 :     //
; 1588 : 
; 1589 :     if(SUCCEEDED(hr))

  00347	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0034b	7c 1c		 jl	 SHORT $L36441

; 1590 :     {
; 1591 :         *pdwLoopStart = pStartMarker->dwPosition;

  0034d	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  00350	8b 45 fc	 mov	 eax, DWORD PTR _pStartMarker$[ebp]
  00353	8b 48 02	 mov	 ecx, DWORD PTR [eax+2]
  00356	89 0a		 mov	 DWORD PTR [edx], ecx

; 1592 :         *pdwLoopLength = pEndMarker->dwPosition - pStartMarker->dwPosition;

  00358	8b 55 b4	 mov	 edx, DWORD PTR _pEndMarker$[ebp]
  0035b	8b 45 fc	 mov	 eax, DWORD PTR _pStartMarker$[ebp]
  0035e	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  00361	2b 48 02	 sub	 ecx, DWORD PTR [eax+2]
  00364	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  00367	89 0a		 mov	 DWORD PTR [edx], ecx
$L36441:

; 1593 :     }
; 1594 : 
; 1595 :     //
; 1596 :     // Clean up
; 1597 :     //
; 1598 :     
; 1599 :     MEMFREE(pMarkers);

  00369	83 7d d8 00	 cmp	 DWORD PTR _pMarkers$[ebp], 0
  0036d	74 10		 je	 SHORT $L36442
  0036f	8b 45 d8	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  00372	50		 push	 eax
  00373	e8 00 00 00 00	 call	 ?TrackingMemFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingMemFree
  00378	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pMarkers$[ebp], 0
$L36442:

; 1600 : 
; 1601 :     DPF_LEAVE_HRESULT(hr);
; 1602 : 
; 1603 :     return hr;

  0037f	8b 4d b8	 mov	 ecx, DWORD PTR _hr$[ebp]
  00382	89 4d 98	 mov	 DWORD PTR $T37570[ebp], ecx
  00385	8d 4d dc	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  00388	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  0038d	8d 4d 9c	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00390	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  00395	8b 45 98	 mov	 eax, DWORD PTR $T37570[ebp]

; 1604 : }

  00398	8b e5		 mov	 esp, ebp
  0039a	5d		 pop	 ebp
  0039b	c2 08 00	 ret	 8
?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ENDP ; WaveLoader::CWaveFile::GetAiffLoopRegion
DSOUND	ENDS
PUBLIC	?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CWaveFile::ReadSample
PUBLIC	?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm
; Function compile flags: /Odt
;	COMDAT ?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
_dwPosition$ = 8
_pvBuffer$ = 12
_dwBufferSize$ = 16
_pdwRead$ = 20
?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z PROC NEAR ; WaveLoader::CWaveFile::ReadSample, COMDAT
; _this$ = ecx

; 1636 : {                                   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1637 :     HRESULT                 hr;
; 1638 : 
; 1639 :     DPF_ENTER();
; 1640 : 
; 1641 :     hr = m_DataChunk.Read(dwPosition, pvBuffer, dwBufferSize, &dwBufferSize);

  00009	8d 45 10	 lea	 eax, DWORD PTR _dwBufferSize$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _dwPosition$[ebp]
  00018	50		 push	 eax
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	83 c1 20	 add	 ecx, 32			; 00000020H
  0001f	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00024	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1642 : 
; 1643 :     if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType))

  00027	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0002b	7c 19		 jl	 SHORT $L36453
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 79 38 01	 cmp	 DWORD PTR [ecx+56], 1
  00034	75 10		 jne	 SHORT $L36453

; 1644 :     {
; 1645 :         ConvertAiffPcm(pvBuffer, dwBufferSize);

  00036	8b 55 10	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  00039	52		 push	 edx
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm
$L36453:

; 1646 :     }
; 1647 : 
; 1648 :     if(SUCCEEDED(hr) && pdwRead)

  00046	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004a	7c 0e		 jl	 SHORT $L36455
  0004c	83 7d 14 00	 cmp	 DWORD PTR _pdwRead$[ebp], 0
  00050	74 08		 je	 SHORT $L36455

; 1649 :     {
; 1650 :         *pdwRead = dwBufferSize;

  00052	8b 4d 14	 mov	 ecx, DWORD PTR _pdwRead$[ebp]
  00055	8b 55 10	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  00058	89 11		 mov	 DWORD PTR [ecx], edx
$L36455:

; 1651 :     }
; 1652 : 
; 1653 :     DPF_LEAVE_HRESULT(hr);
; 1654 : 
; 1655 :     return hr;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1656 : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 10 00	 ret	 16			; 00000010H
?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z ENDP	; WaveLoader::CWaveFile::ReadSample
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?Close@CWaveFile@WaveLoader@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Close@CWaveFile@WaveLoader@@QAEXXZ PROC NEAR		; WaveLoader::CWaveFile::Close, COMDAT
; _this$ = ecx

; 1682 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1683 :     DPF_ENTER();
; 1684 : 
; 1685 :     m_Stream.Close();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Close@CStdFileStream@WaveLoader@@QAEXXZ ; WaveLoader::CStdFileStream::Close

; 1686 : 
; 1687 :     MEMFREE(m_pwfxFormat);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00016	74 16		 je	 SHORT $L36459
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 ?TrackingMemFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingMemFree
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
$L36459:

; 1688 : 
; 1689 :     DPF_LEAVE_VOID();
; 1690 : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?Close@CWaveFile@WaveLoader@@QAEXXZ ENDP		; WaveLoader::CWaveFile::Close
DSOUND	ENDS
PUBLIC	??_C@_0CM@HBKMMLMK@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@ ; `string'
PUBLIC	?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm
;	COMDAT ??_C@_0CM@HBKMMLMK@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@
DSOUND_RD	SEGMENT
??_C@_0CM@HBKMMLMK@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@ DB 'WAVE_FO'
	DB	'RMAT_PCM == m_pwfxFormat->wFormatTag', 00H	; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z
DSOUND	SEGMENT
_this$ = -12
_pvSource$ = 8
_cbSource$ = 12
?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z PROC NEAR ; WaveLoader::CWaveFile::ConvertAiffPcm, COMDAT
; _this$ = ecx

; 1718 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1719 :     BYTE *                  pbSource;
; 1720 :     BYTE                    bTemp;
; 1721 : 
; 1722 :     DPF_ENTER();
; 1723 : 
; 1724 :     ASSERT(m_pwfxFormat);

  00009	68 bc 06 00 00	 push	 1724			; 000006bcH
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@NLKBAEGB@m_pwfxFormat?$AA@
  00018	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	33 c9		 xor	 ecx, ecx
  0001d	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00021	0f 94 c1	 sete	 cl
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 1725 :     ASSERT(WAVE_FORMAT_PCM == m_pwfxFormat->wFormatTag);

  0002d	68 bd 06 00 00	 push	 1725			; 000006bdH
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@HBKMMLMK@WAVE_FORMAT_PCM?5?$DN?$DN?5m_pwfxFormat?9@
  0003c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00042	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00045	83 e9 01	 sub	 ecx, 1
  00048	f7 d9		 neg	 ecx
  0004a	1b c9		 sbb	 ecx, ecx
  0004c	f7 d9		 neg	 ecx
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00054	83 c4 10	 add	 esp, 16			; 00000010H

; 1726 : 
; 1727 :     ConvertAiffPcm(pvSource, cbSource, m_pwfxFormat->wBitsPerSample);

  00057	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0005d	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00061	51		 push	 ecx
  00062	8b 55 0c	 mov	 edx, DWORD PTR _cbSource$[ebp]
  00065	52		 push	 edx
  00066	8b 45 08	 mov	 eax, DWORD PTR _pvSource$[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm

; 1728 : 
; 1729 :     DPF_LEAVE_VOID();
; 1730 : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8
?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z ENDP	; WaveLoader::CWaveFile::ConvertAiffPcm
DSOUND	ENDS
PUBLIC	??_C@_0BA@NOEFBMFE@8?5?$DN?$DN?5dwBitDepth?$AA@	; `string'
;	COMDAT ??_C@_0BA@NOEFBMFE@8?5?$DN?$DN?5dwBitDepth?$AA@
DSOUND_RD	SEGMENT
??_C@_0BA@NOEFBMFE@8?5?$DN?$DN?5dwBitDepth?$AA@ DB '8 == dwBitDepth', 00H ; `string'
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z
DSOUND	SEGMENT
_pwSource$ = -12
_pbSource$ = -4
_pvSource$ = 8
_cbSource$ = 12
_dwBitDepth$ = 16
?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z PROC NEAR ; WaveLoader::CWaveFile::ConvertAiffPcm, COMDAT

; 1760 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1761 :     BYTE *                  pbSource;
; 1762 :     WORD *                  pwSource;
; 1763 :     BYTE                    bTemp;
; 1764 : 
; 1765 :     DPF_ENTER();
; 1766 : 
; 1767 :     if(16 == dwBitDepth)

  00006	83 7d 10 10	 cmp	 DWORD PTR _dwBitDepth$[ebp], 16 ; 00000010H
  0000a	75 3d		 jne	 SHORT $L36477

; 1768 :     {
; 1769 :         cbSource /= 2;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _cbSource$[ebp]
  0000f	d1 e8		 shr	 eax, 1
  00011	89 45 0c	 mov	 DWORD PTR _cbSource$[ebp], eax

; 1770 :         
; 1771 :         for(pwSource = (WORD *)pvSource; cbSource; cbSource--, pwSource++)

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pvSource$[ebp]
  00017	89 4d f4	 mov	 DWORD PTR _pwSource$[ebp], ecx
  0001a	eb 12		 jmp	 SHORT $L36479
$L36480:
  0001c	8b 55 0c	 mov	 edx, DWORD PTR _cbSource$[ebp]
  0001f	83 ea 01	 sub	 edx, 1
  00022	89 55 0c	 mov	 DWORD PTR _cbSource$[ebp], edx
  00025	8b 45 f4	 mov	 eax, DWORD PTR _pwSource$[ebp]
  00028	83 c0 02	 add	 eax, 2
  0002b	89 45 f4	 mov	 DWORD PTR _pwSource$[ebp], eax
$L36479:
  0002e	83 7d 0c 00	 cmp	 DWORD PTR _cbSource$[ebp], 0
  00032	74 13		 je	 SHORT $L36481

; 1772 :         {
; 1773 :             *pwSource = EndianSwapWord(*pwSource);

  00034	8b 4d f4	 mov	 ecx, DWORD PTR _pwSource$[ebp]
  00037	66 8b 09	 mov	 cx, WORD PTR [ecx]
  0003a	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0003f	8b 55 f4	 mov	 edx, DWORD PTR _pwSource$[ebp]
  00042	66 89 02	 mov	 WORD PTR [edx], ax

; 1774 :         }

  00045	eb d5		 jmp	 SHORT $L36480
$L36481:

; 1775 :     }
; 1776 :     else

  00047	eb 54		 jmp	 SHORT $L36473
$L36477:

; 1777 :     {
; 1778 :         ASSERT(8 == dwBitDepth);

  00049	68 f2 06 00 00	 push	 1778			; 000006f2H
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FIJLFLOP@c?3?2xbox?2private?2windows?2directx?2@
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@NOEFBMFE@8?5?$DN?$DN?5dwBitDepth?$AA@
  00058	33 c0		 xor	 eax, eax
  0005a	83 7d 10 08	 cmp	 DWORD PTR _dwBitDepth$[ebp], 8
  0005e	0f 95 c0	 setne	 al
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?Assert@CDebug@DirectSound@@SAXHPBD0I@Z ; DirectSound::CDebug::Assert
  00067	83 c4 10	 add	 esp, 16			; 00000010H

; 1779 :         
; 1780 :         for(pbSource = (BYTE *)pvSource; cbSource; cbSource--, pbSource++)

  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _pvSource$[ebp]
  0006d	89 4d fc	 mov	 DWORD PTR _pbSource$[ebp], ecx
  00070	eb 12		 jmp	 SHORT $L36485
$L36486:
  00072	8b 55 0c	 mov	 edx, DWORD PTR _cbSource$[ebp]
  00075	83 ea 01	 sub	 edx, 1
  00078	89 55 0c	 mov	 DWORD PTR _cbSource$[ebp], edx
  0007b	8b 45 fc	 mov	 eax, DWORD PTR _pbSource$[ebp]
  0007e	83 c0 01	 add	 eax, 1
  00081	89 45 fc	 mov	 DWORD PTR _pbSource$[ebp], eax
$L36485:
  00084	83 7d 0c 00	 cmp	 DWORD PTR _cbSource$[ebp], 0
  00088	74 13		 je	 SHORT $L36473

; 1781 :         {
; 1782 :             *pbSource = *pbSource + 0x80;

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _pbSource$[ebp]
  0008d	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00090	81 c2 80 00 00
	00		 add	 edx, 128		; 00000080H
  00096	8b 45 fc	 mov	 eax, DWORD PTR _pbSource$[ebp]
  00099	88 10		 mov	 BYTE PTR [eax], dl

; 1783 :         }

  0009b	eb d5		 jmp	 SHORT $L36486
$L36473:

; 1784 :     }
; 1785 : 
; 1786 :     DPF_LEAVE_VOID();
; 1787 : }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 0c 00	 ret	 12			; 0000000cH
?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z ENDP	; WaveLoader::CWaveFile::ConvertAiffPcm
DSOUND	ENDS
PUBLIC	??0CImaAdpcmCodec@DirectSound@@QAE@XZ		; DirectSound::CImaAdpcmCodec::CImaAdpcmCodec
PUBLIC	??_7CImaAdpcmCodec@DirectSound@@6B@		; DirectSound::CImaAdpcmCodec::`vftable'
PUBLIC	??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z	; DirectSound::CImaAdpcmCodec::`scalar deleting destructor'
EXTRN	??_ECImaAdpcmCodec@DirectSound@@UAEPAXI@Z:NEAR	; DirectSound::CImaAdpcmCodec::`vector deleting destructor'
;	COMDAT ??_7CImaAdpcmCodec@DirectSound@@6B@
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
CONST	SEGMENT
??_7CImaAdpcmCodec@DirectSound@@6B@ DD FLAT:??_ECImaAdpcmCodec@DirectSound@@UAEPAXI@Z ; DirectSound::CImaAdpcmCodec::`vftable'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CImaAdpcmCodec@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CImaAdpcmCodec@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CImaAdpcmCodec::CImaAdpcmCodec, COMDAT
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CImaAdpcmCodec@DirectSound@@6B@

; 70   : }

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0CImaAdpcmCodec@DirectSound@@QAE@XZ ENDP		; DirectSound::CImaAdpcmCodec::CImaAdpcmCodec
DSOUND	ENDS
PUBLIC	??1CImaAdpcmCodec@DirectSound@@UAE@XZ		; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec
; Function compile flags: /Odt
;	COMDAT ??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z PROC NEAR	; DirectSound::CImaAdpcmCodec::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CImaAdpcmCodec@DirectSound@@UAE@XZ ; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L36497
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L36497:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z ENDP		; DirectSound::CImaAdpcmCodec::`scalar deleting destructor'
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\memmgr.h
DSOUND	ENDS
;	COMDAT ??3@YAXPAX@Z
DSOUND	SEGMENT
_pvBuffer$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 244  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  :     DirectSound::CMemoryManager::TrackingMemFree(pvBuffer); 

  00003	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?TrackingMemFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::TrackingMemFree

; 246  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
DSOUND	ENDS
;	COMDAT ??1CImaAdpcmCodec@DirectSound@@UAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CImaAdpcmCodec@DirectSound@@UAE@XZ PROC NEAR		; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec, COMDAT
; _this$ = ecx

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CImaAdpcmCodec@DirectSound@@6B@

; 93   : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1CImaAdpcmCodec@DirectSound@@UAE@XZ ENDP		; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec
DSOUND	ENDS
PUBLIC	?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z ; DirectSound::CImaAdpcmCodec::Initialize
PUBLIC	?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat
PUBLIC	?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::EncodeM16
PUBLIC	?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::EncodeS16
PUBLIC	?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::DecodeM16
PUBLIC	?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::DecodeS16
;	COMDAT ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA
DSOUND_RD	SEGMENT
?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA DD FLAT:?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; `DirectSound::CImaAdpcmCodec::Initialize'::`2'::apfnConvert
	DD	FLAT:?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
	DD	FLAT:?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
	DD	FLAT:?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z
DSOUND	SEGMENT
_this$ = -4
_pwfxEncode$ = 8
_fEncoder$ = 12
?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::Initialize, COMDAT
; _this$ = ecx

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  :     static const LPFNIMAADPCMCONVERT    apfnConvert[2][2] = 
; 120  :     { 
; 121  :         {
; 122  :             DecodeM16,
; 123  :             DecodeS16 
; 124  :         },
; 125  :         {
; 126  :             EncodeM16,
; 127  :             EncodeS16 
; 128  :         }
; 129  :     };
; 130  :     
; 131  :     if(!IsValidImaAdpcmFormat(pwfxEncode))

  00009	8b 45 08	 mov	 eax, DWORD PTR _pwfxEncode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat
  00012	85 c0		 test	 eax, eax
  00014	75 04		 jne	 SHORT $L36509

; 132  :     {
; 133  :         return FALSE;

  00016	33 c0		 xor	 eax, eax
  00018	eb 59		 jmp	 SHORT $L36506
$L36509:

; 134  :     }
; 135  : 
; 136  :     //
; 137  :     // Save the format data
; 138  :     //
; 139  : 
; 140  :     m_wfxEncode = *pwfxEncode;

  0001a	8b 75 08	 mov	 esi, DWORD PTR _pwfxEncode$[ebp]
  0001d	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  00020	83 c7 04	 add	 edi, 4
  00023	b9 05 00 00 00	 mov	 ecx, 5
  00028	f3 a5		 rep movsd

; 141  :     m_fEncoder = !!fEncoder;

  0002a	33 c9		 xor	 ecx, ecx
  0002c	83 7d 0c 00	 cmp	 DWORD PTR _fEncoder$[ebp], 0
  00030	0f 95 c1	 setne	 cl
  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 142  : 
; 143  :     //
; 144  :     // Set up the conversion function
; 145  :     //
; 146  : 
; 147  :     m_pfnConvert = apfnConvert[m_fEncoder][m_wfxEncode.wfx.nChannels - 1];

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00042	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  00046	8d 14 85 fc ff
	ff ff		 lea	 edx, DWORD PTR [eax*4-4]
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 8c ca 00 00
	00 00		 mov	 ecx, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA[edx+ecx*8]
  00057	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 148  : 
; 149  :     //
; 150  :     // Initialize the stepping indeces
; 151  :     //
; 152  : 
; 153  :     m_nStepIndexL = m_nStepIndexR = 0;

  0005a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 154  : 
; 155  :     return TRUE;

  0006e	b8 01 00 00 00	 mov	 eax, 1
$L36506:

; 156  : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 08 00	 ret	 8
?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z ENDP ; DirectSound::CImaAdpcmCodec::Initialize
DSOUND	ENDS
PUBLIC	?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z ; DirectSound::CImaAdpcmCodec::Convert
; Function compile flags: /Odt
;	COMDAT ?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z
DSOUND	SEGMENT
_this$ = -4
_pvSrc$ = 8
_pvDst$ = 12
_cBlocks$ = 16
?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::Convert, COMDAT
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  :     return m_pfnConvert((LPBYTE)pvSrc, (LPBYTE)pvDst, cBlocks, m_wfxEncode.wfx.nBlockAlign, m_wfxEncode.wSamplesPerBlock, &m_nStepIndexL, &m_nStepIndexR);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 20	 add	 eax, 32			; 00000020H
  0000d	50		 push	 eax
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00014	51		 push	 ecx
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	0f b7 42 16	 movzx	 eax, WORD PTR [edx+22]
  0001c	50		 push	 eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	0f b7 51 10	 movzx	 edx, WORD PTR [ecx+16]
  00024	52		 push	 edx
  00025	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _pvDst$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 55 08	 mov	 edx, DWORD PTR _pvSrc$[ebp]
  00030	52		 push	 edx
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	ff 50 24	 call	 DWORD PTR [eax+36]

; 185  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 0c 00	 ret	 12			; 0000000cH
?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z ENDP	; DirectSound::CImaAdpcmCodec::Convert
DSOUND	ENDS
PUBLIC	?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ	; DirectSound::CImaAdpcmCodec::Reset
; Function compile flags: /Odt
;	COMDAT ?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ PROC NEAR	; DirectSound::CImaAdpcmCodec::Reset, COMDAT
; _this$ = ecx

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 209  :     //
; 210  :     // Reset the stepping indeces
; 211  :     //
; 212  : 
; 213  :     m_nStepIndexL = m_nStepIndexR = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 214  : }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ ENDP		; DirectSound::CImaAdpcmCodec::Reset
DSOUND	ENDS
PUBLIC	?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ; DirectSound::CImaAdpcmCodec::GetEncodeAlignment
; Function compile flags: /Odt
;	COMDAT ?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
DSOUND	SEGMENT
_this$ = -4
?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ PROC NEAR ; DirectSound::CImaAdpcmCodec::GetEncodeAlignment, COMDAT
; _this$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 238  :     return m_wfxEncode.wfx.nBlockAlign;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 40 10	 mov	 ax, WORD PTR [eax+16]

; 239  : }

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ENDP ; DirectSound::CImaAdpcmCodec::GetEncodeAlignment
DSOUND	ENDS
PUBLIC	?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ; DirectSound::CImaAdpcmCodec::GetDecodeAlignment
; Function compile flags: /Odt
;	COMDAT ?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
DSOUND	SEGMENT
_this$ = -4
?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ PROC NEAR ; DirectSound::CImaAdpcmCodec::GetDecodeAlignment, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 263  :     return m_wfxEncode.wSamplesPerBlock * m_wfxEncode.wfx.nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b7 40 16	 movzx	 eax, WORD PTR [eax+22]
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  00015	0f af c2	 imul	 eax, edx
  00018	c1 e0 04	 shl	 eax, 4
  0001b	99		 cdq
  0001c	83 e2 07	 and	 edx, 7
  0001f	03 c2		 add	 eax, edx
  00021	c1 f8 03	 sar	 eax, 3

; 264  : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ENDP ; DirectSound::CImaAdpcmCodec::GetDecodeAlignment
DSOUND	ENDS
PUBLIC	?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
; Function compile flags: /Odt
;	COMDAT ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z
DSOUND	SEGMENT
_nHeaderBytes$ = -12
_nBlockAlign$ = -8
_nEncodedSampleBits$ = -4
_nChannels$ = 8
_nSamplesPerBlock$ = 12
?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment, COMDAT

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 291  :     const WORD              nEncodedSampleBits  = nChannels * IMAADPCM_BITS_PER_SAMPLE;

  00006	0f b7 45 08	 movzx	 eax, WORD PTR _nChannels$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	66 89 45 fc	 mov	 WORD PTR _nEncodedSampleBits$[ebp], ax

; 292  :     const WORD              nHeaderBytes        = nChannels * IMAADPCM_HEADER_LENGTH;

  00011	0f b7 4d 08	 movzx	 ecx, WORD PTR _nChannels$[ebp]
  00015	c1 e1 02	 shl	 ecx, 2
  00018	66 89 4d f4	 mov	 WORD PTR _nHeaderBytes$[ebp], cx

; 293  :     WORD                    nBlockAlign;
; 294  : 
; 295  :     //
; 296  :     // Calculate the raw block alignment that nSamplesPerBlock dictates.  This
; 297  :     // value may include a partial encoded sample, so be sure to round up.
; 298  :     //
; 299  :     // Start with the samples-per-block, minus 1.  The first sample is actually
; 300  :     // stored in the header.
; 301  :     //
; 302  : 
; 303  :     nBlockAlign = nSamplesPerBlock - 1;

  0001c	0f b7 55 0c	 movzx	 edx, WORD PTR _nSamplesPerBlock$[ebp]
  00020	83 ea 01	 sub	 edx, 1
  00023	66 89 55 f8	 mov	 WORD PTR _nBlockAlign$[ebp], dx

; 304  : 
; 305  :     //
; 306  :     // Convert to encoded sample size
; 307  :     //
; 308  : 
; 309  :     nBlockAlign *= nEncodedSampleBits;

  00027	0f b7 45 fc	 movzx	 eax, WORD PTR _nEncodedSampleBits$[ebp]
  0002b	0f b7 4d f8	 movzx	 ecx, WORD PTR _nBlockAlign$[ebp]
  0002f	0f af c8	 imul	 ecx, eax
  00032	66 89 4d f8	 mov	 WORD PTR _nBlockAlign$[ebp], cx

; 310  :     nBlockAlign += 7;

  00036	0f b7 55 f8	 movzx	 edx, WORD PTR _nBlockAlign$[ebp]
  0003a	83 c2 07	 add	 edx, 7
  0003d	66 89 55 f8	 mov	 WORD PTR _nBlockAlign$[ebp], dx

; 311  :     nBlockAlign /= 8;

  00041	0f b7 45 f8	 movzx	 eax, WORD PTR _nBlockAlign$[ebp]
  00045	99		 cdq
  00046	83 e2 07	 and	 edx, 7
  00049	03 c2		 add	 eax, edx
  0004b	c1 f8 03	 sar	 eax, 3
  0004e	66 89 45 f8	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 312  : 
; 313  :     //
; 314  :     // The stereo encoder requires that there be at least two DWORDs to process
; 315  :     //
; 316  : 
; 317  :     nBlockAlign += 7;

  00052	0f b7 45 f8	 movzx	 eax, WORD PTR _nBlockAlign$[ebp]
  00056	83 c0 07	 add	 eax, 7
  00059	66 89 45 f8	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 318  :     nBlockAlign /= 8;

  0005d	0f b7 45 f8	 movzx	 eax, WORD PTR _nBlockAlign$[ebp]
  00061	99		 cdq
  00062	83 e2 07	 and	 edx, 7
  00065	03 c2		 add	 eax, edx
  00067	c1 f8 03	 sar	 eax, 3
  0006a	66 89 45 f8	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 319  :     nBlockAlign *= 8;

  0006e	0f b7 4d f8	 movzx	 ecx, WORD PTR _nBlockAlign$[ebp]
  00072	c1 e1 03	 shl	 ecx, 3
  00075	66 89 4d f8	 mov	 WORD PTR _nBlockAlign$[ebp], cx

; 320  : 
; 321  :     //
; 322  :     // Add the header
; 323  :     //
; 324  : 
; 325  :     nBlockAlign += nHeaderBytes;

  00079	0f b7 55 f4	 movzx	 edx, WORD PTR _nHeaderBytes$[ebp]
  0007d	0f b7 45 f8	 movzx	 eax, WORD PTR _nBlockAlign$[ebp]
  00081	03 c2		 add	 eax, edx
  00083	66 89 45 f8	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 326  : 
; 327  :     return nBlockAlign;

  00087	66 8b 45 f8	 mov	 ax, WORD PTR _nBlockAlign$[ebp]

; 328  : }

  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ENDP ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
DSOUND	ENDS
PUBLIC	?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z ; DirectSound::CImaAdpcmCodec::CreatePcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_pwfx$ = 16
?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::CreatePcmFormat, COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  :     pwfx->wFormatTag = WAVE_FORMAT_PCM;

  00003	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	66 c7 00 01 00	 mov	 WORD PTR [eax], 1

; 357  :     pwfx->nChannels = nChannels;

  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0000e	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  00012	66 89 51 02	 mov	 WORD PTR [ecx+2], dx

; 358  :     pwfx->nSamplesPerSec = nSamplesPerSec;

  00016	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0001c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 359  :     pwfx->nBlockAlign = nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;

  0001f	0f b7 45 08	 movzx	 eax, WORD PTR _nChannels$[ebp]
  00023	c1 e0 04	 shl	 eax, 4
  00026	99		 cdq
  00027	83 e2 07	 and	 edx, 7
  0002a	03 c2		 add	 eax, edx
  0002c	c1 f8 03	 sar	 eax, 3
  0002f	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00032	66 89 42 0c	 mov	 WORD PTR [edx+12], ax

; 360  :     pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;

  00036	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00039	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0003d	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00040	0f af 4a 04	 imul	 ecx, DWORD PTR [edx+4]
  00044	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00047	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 361  :     pwfx->wBitsPerSample = IMAADPCM_PCM_BITS_PER_SAMPLE;

  0004a	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0004d	66 c7 41 0e 10
	00		 mov	 WORD PTR [ecx+14], 16	; 00000010H

; 362  : }

  00053	5d		 pop	 ebp
  00054	c2 0c 00	 ret	 12			; 0000000cH
?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z ENDP ; DirectSound::CImaAdpcmCodec::CreatePcmFormat
DSOUND	ENDS
PUBLIC	?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::CImaAdpcmCodec::CreateImaAdpcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_nSamplesPerBlock$ = 16
_pwfx$ = 20
?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUxbox_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::CreateImaAdpcmFormat, COMDAT

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 391  :     pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  00004	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00007	66 c7 00 69 00	 mov	 WORD PTR [eax], 105	; 00000069H

; 392  :     pwfx->wfx.nChannels = nChannels;

  0000c	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0000f	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  00013	66 89 51 02	 mov	 WORD PTR [ecx+2], dx

; 393  :     pwfx->wfx.nSamplesPerSec = nSamplesPerSec;

  00017	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0001d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 394  :     pwfx->wfx.nBlockAlign = CalculateEncodeAlignment(nChannels, nSamplesPerBlock);

  00020	66 8b 55 10	 mov	 dx, WORD PTR _nSamplesPerBlock$[ebp]
  00024	52		 push	 edx
  00025	66 8b 45 08	 mov	 ax, WORD PTR _nChannels$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
  0002f	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00032	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 395  :     pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec * pwfx->wfx.nBlockAlign / nSamplesPerBlock;

  00036	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00039	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  00040	0f af c8	 imul	 ecx, eax
  00043	0f b7 75 10	 movzx	 esi, WORD PTR _nSamplesPerBlock$[ebp]
  00047	8b c1		 mov	 eax, ecx
  00049	33 d2		 xor	 edx, edx
  0004b	f7 f6		 div	 esi
  0004d	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00050	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 396  :     pwfx->wfx.wBitsPerSample = IMAADPCM_BITS_PER_SAMPLE;

  00053	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00056	66 c7 40 0e 04
	00		 mov	 WORD PTR [eax+14], 4

; 397  :     pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);

  0005c	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0005f	66 c7 41 10 02
	00		 mov	 WORD PTR [ecx+16], 2

; 398  :     pwfx->wSamplesPerBlock = nSamplesPerBlock;

  00065	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00068	66 8b 45 10	 mov	 ax, WORD PTR _nSamplesPerBlock$[ebp]
  0006c	66 89 42 12	 mov	 WORD PTR [edx+18], ax

; 399  : }

  00070	5e		 pop	 esi
  00071	5d		 pop	 ebp
  00072	c2 10 00	 ret	 16			; 00000010H
?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUxbox_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::CImaAdpcmCodec::CreateImaAdpcmFormat
DSOUND	ENDS
PUBLIC	?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z ; DirectSound::CImaAdpcmCodec::IsValidPcmFormat
; Function compile flags: /Odt
;	COMDAT ?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
_pwfx$ = 8
?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::IsValidPcmFormat, COMDAT

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 423  :     if(WAVE_FORMAT_PCM != pwfx->wFormatTag)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00009	83 f9 01	 cmp	 ecx, 1
  0000c	74 04		 je	 SHORT $L36551

; 424  :     {
; 425  :         return FALSE;

  0000e	33 c0		 xor	 eax, eax
  00010	eb 74		 jmp	 SHORT $L36550
$L36551:

; 426  :     }
; 427  :     
; 428  :     if((pwfx->nChannels < 1) || (pwfx->nChannels > IMAADPCM_MAX_CHANNELS))

  00012	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00015	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00019	83 f8 01	 cmp	 eax, 1
  0001c	7c 0c		 jl	 SHORT $L36553
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00021	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00025	83 fa 02	 cmp	 edx, 2
  00028	7e 04		 jle	 SHORT $L36552
$L36553:

; 429  :     {
; 430  :         return FALSE;

  0002a	33 c0		 xor	 eax, eax
  0002c	eb 58		 jmp	 SHORT $L36550
$L36552:

; 431  :     }
; 432  : 
; 433  :     if(IMAADPCM_PCM_BITS_PER_SAMPLE != pwfx->wBitsPerSample)

  0002e	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00031	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00035	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00038	74 04		 je	 SHORT $L36554

; 434  :     {
; 435  :         return FALSE;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 48		 jmp	 SHORT $L36550
$L36554:

; 436  :     }
; 437  : 
; 438  :     if(pwfx->nChannels * pwfx->wBitsPerSample / 8 != pwfx->nBlockAlign)

  0003e	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00041	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00048	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  0004c	0f af c2	 imul	 eax, edx
  0004f	99		 cdq
  00050	83 e2 07	 and	 edx, 7
  00053	03 c2		 add	 eax, edx
  00055	c1 f8 03	 sar	 eax, 3
  00058	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0005b	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  0005f	3b c2		 cmp	 eax, edx
  00061	74 04		 je	 SHORT $L36555

; 439  :     {
; 440  :         return FALSE;

  00063	33 c0		 xor	 eax, eax
  00065	eb 1f		 jmp	 SHORT $L36550
$L36555:

; 441  :     }
; 442  : 
; 443  :     if(pwfx->nBlockAlign * pwfx->nSamplesPerSec != pwfx->nAvgBytesPerSec)

  00067	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0006a	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0006e	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00071	0f af 4a 04	 imul	 ecx, DWORD PTR [edx+4]
  00075	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00078	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0007b	74 04		 je	 SHORT $L36556

; 444  :     {
; 445  :         return FALSE;

  0007d	33 c0		 xor	 eax, eax
  0007f	eb 05		 jmp	 SHORT $L36550
$L36556:

; 446  :     }
; 447  : 
; 448  :     return TRUE;

  00081	b8 01 00 00 00	 mov	 eax, 1
$L36550:

; 449  : }

  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::CImaAdpcmCodec::IsValidPcmFormat
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT
_pwfx$ = 8
?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUxbox_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat, COMDAT

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 473  :     if(WAVE_FORMAT_XBOX_ADPCM != pwfx->wfx.wFormatTag)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00009	83 f9 69	 cmp	 ecx, 105		; 00000069H
  0000c	74 04		 je	 SHORT $L36560

; 474  :     {
; 475  :         return FALSE;

  0000e	33 c0		 xor	 eax, eax
  00010	eb 68		 jmp	 SHORT $L36559
$L36560:

; 476  :     }
; 477  : 
; 478  :     if(sizeof(*pwfx) - sizeof(pwfx->wfx) != pwfx->wfx.cbSize)

  00012	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00015	0f b7 42 10	 movzx	 eax, WORD PTR [edx+16]
  00019	83 f8 02	 cmp	 eax, 2
  0001c	74 04		 je	 SHORT $L36561

; 479  :     {
; 480  :         return FALSE;

  0001e	33 c0		 xor	 eax, eax
  00020	eb 58		 jmp	 SHORT $L36559
$L36561:

; 481  :     }
; 482  :     
; 483  :     if((pwfx->wfx.nChannels < 1) || (pwfx->wfx.nChannels > IMAADPCM_MAX_CHANNELS))

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00025	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00029	83 fa 01	 cmp	 edx, 1
  0002c	7c 0c		 jl	 SHORT $L36563
  0002e	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00031	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00035	83 f9 02	 cmp	 ecx, 2
  00038	7e 04		 jle	 SHORT $L36562
$L36563:

; 484  :     {
; 485  :         return FALSE;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 3c		 jmp	 SHORT $L36559
$L36562:

; 486  :     }
; 487  : 
; 488  :     if(IMAADPCM_BITS_PER_SAMPLE != pwfx->wfx.wBitsPerSample)

  0003e	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00041	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00045	83 f8 04	 cmp	 eax, 4
  00048	74 04		 je	 SHORT $L36564

; 489  :     {
; 490  :         return FALSE;

  0004a	33 c0		 xor	 eax, eax
  0004c	eb 2c		 jmp	 SHORT $L36559
$L36564:

; 491  :     }
; 492  : 
; 493  :     if(CalculateEncodeAlignment(pwfx->wfx.nChannels, pwfx->wSamplesPerBlock) != pwfx->wfx.nBlockAlign)

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00051	66 8b 51 12	 mov	 dx, WORD PTR [ecx+18]
  00055	52		 push	 edx
  00056	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00059	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
  00063	0f b7 d0	 movzx	 edx, ax
  00066	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00069	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0006d	3b d1		 cmp	 edx, ecx
  0006f	74 04		 je	 SHORT $L36565

; 494  :     {
; 495  :         return FALSE;

  00071	33 c0		 xor	 eax, eax
  00073	eb 05		 jmp	 SHORT $L36559
$L36565:

; 496  :     }
; 497  : 
; 498  :     return TRUE;

  00075	b8 01 00 00 00	 mov	 eax, 1
$L36559:

; 499  : }

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUxbox_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat
DSOUND	ENDS
PUBLIC	?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
; Function compile flags: /Odt
;	COMDAT ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z
DSOUND	SEGMENT
_lDifference$ = -12
_nPredictedSample$ = -8
_nEncodedSample$ = -4
_nInputSample$ = 8
_pnPredictedSample$ = 12
_nStepSize$ = 16
?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::EncodeSample, COMDAT

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 527  :     int                 nPredictedSample;
; 528  :     LONG                lDifference;
; 529  :     int                 nEncodedSample;
; 530  :     
; 531  :     nPredictedSample = *pnPredictedSample;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _pnPredictedSample$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d f8	 mov	 DWORD PTR _nPredictedSample$[ebp], ecx

; 532  : 
; 533  :     lDifference = nInputSample - nPredictedSample;

  0000e	8b 55 08	 mov	 edx, DWORD PTR _nInputSample$[ebp]
  00011	2b 55 f8	 sub	 edx, DWORD PTR _nPredictedSample$[ebp]
  00014	89 55 f4	 mov	 DWORD PTR _lDifference$[ebp], edx

; 534  :     nEncodedSample = 0;

  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nEncodedSample$[ebp], 0

; 535  : 
; 536  :     if(lDifference < 0) 

  0001e	83 7d f4 00	 cmp	 DWORD PTR _lDifference$[ebp], 0
  00022	7d 0f		 jge	 SHORT $L36574

; 537  :     {
; 538  :         nEncodedSample = 8;

  00024	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR _nEncodedSample$[ebp], 8

; 539  :         lDifference = -lDifference;

  0002b	8b 45 f4	 mov	 eax, DWORD PTR _lDifference$[ebp]
  0002e	f7 d8		 neg	 eax
  00030	89 45 f4	 mov	 DWORD PTR _lDifference$[ebp], eax
$L36574:

; 540  :     }
; 541  : 
; 542  :     if(lDifference >= nStepSize)

  00033	8b 4d f4	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  00036	3b 4d 10	 cmp	 ecx, DWORD PTR _nStepSize$[ebp]
  00039	7c 12		 jl	 SHORT $L36575

; 543  :     {
; 544  :         nEncodedSample |= 4;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _nEncodedSample$[ebp]
  0003e	83 ca 04	 or	 edx, 4
  00041	89 55 fc	 mov	 DWORD PTR _nEncodedSample$[ebp], edx

; 545  :         lDifference -= nStepSize;

  00044	8b 45 f4	 mov	 eax, DWORD PTR _lDifference$[ebp]
  00047	2b 45 10	 sub	 eax, DWORD PTR _nStepSize$[ebp]
  0004a	89 45 f4	 mov	 DWORD PTR _lDifference$[ebp], eax
$L36575:

; 546  :     }
; 547  : 
; 548  :     nStepSize >>= 1;

  0004d	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00050	d1 f9		 sar	 ecx, 1
  00052	89 4d 10	 mov	 DWORD PTR _nStepSize$[ebp], ecx

; 549  : 
; 550  :     if(lDifference >= nStepSize)

  00055	8b 55 f4	 mov	 edx, DWORD PTR _lDifference$[ebp]
  00058	3b 55 10	 cmp	 edx, DWORD PTR _nStepSize$[ebp]
  0005b	7c 12		 jl	 SHORT $L36576

; 551  :     {
; 552  :         nEncodedSample |= 2;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00060	83 c8 02	 or	 eax, 2
  00063	89 45 fc	 mov	 DWORD PTR _nEncodedSample$[ebp], eax

; 553  :         lDifference -= nStepSize;

  00066	8b 4d f4	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  00069	2b 4d 10	 sub	 ecx, DWORD PTR _nStepSize$[ebp]
  0006c	89 4d f4	 mov	 DWORD PTR _lDifference$[ebp], ecx
$L36576:

; 554  :     }
; 555  : 
; 556  :     nStepSize >>= 1;

  0006f	8b 55 10	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  00072	d1 fa		 sar	 edx, 1
  00074	89 55 10	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 557  : 
; 558  :     if(lDifference >= nStepSize)

  00077	8b 45 f4	 mov	 eax, DWORD PTR _lDifference$[ebp]
  0007a	3b 45 10	 cmp	 eax, DWORD PTR _nStepSize$[ebp]
  0007d	7c 12		 jl	 SHORT $L36577

; 559  :     {
; 560  :         nEncodedSample |= 1;

  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _nEncodedSample$[ebp]
  00082	83 c9 01	 or	 ecx, 1
  00085	89 4d fc	 mov	 DWORD PTR _nEncodedSample$[ebp], ecx

; 561  :         lDifference -= nStepSize;

  00088	8b 55 f4	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0008b	2b 55 10	 sub	 edx, DWORD PTR _nStepSize$[ebp]
  0008e	89 55 f4	 mov	 DWORD PTR _lDifference$[ebp], edx
$L36577:

; 562  :     }
; 563  : 
; 564  :     if(nEncodedSample & 8)

  00091	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00094	83 e0 08	 and	 eax, 8
  00097	85 c0		 test	 eax, eax
  00099	74 12		 je	 SHORT $L36578

; 565  :     {
; 566  :         nPredictedSample = nInputSample + lDifference - (nStepSize >> 1);

  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _nInputSample$[ebp]
  0009e	03 4d f4	 add	 ecx, DWORD PTR _lDifference$[ebp]
  000a1	8b 55 10	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  000a4	d1 fa		 sar	 edx, 1
  000a6	2b ca		 sub	 ecx, edx
  000a8	89 4d f8	 mov	 DWORD PTR _nPredictedSample$[ebp], ecx

; 567  :     }
; 568  :     else

  000ab	eb 10		 jmp	 SHORT $L36579
$L36578:

; 569  :     {
; 570  :         nPredictedSample = nInputSample - lDifference + (nStepSize >> 1);

  000ad	8b 45 08	 mov	 eax, DWORD PTR _nInputSample$[ebp]
  000b0	2b 45 f4	 sub	 eax, DWORD PTR _lDifference$[ebp]
  000b3	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  000b6	d1 f9		 sar	 ecx, 1
  000b8	03 c1		 add	 eax, ecx
  000ba	89 45 f8	 mov	 DWORD PTR _nPredictedSample$[ebp], eax
$L36579:

; 571  :     }
; 572  : 
; 573  :     if(nPredictedSample > 32767)

  000bd	81 7d f8 ff 7f
	00 00		 cmp	 DWORD PTR _nPredictedSample$[ebp], 32767 ; 00007fffH
  000c4	7e 09		 jle	 SHORT $L36580

; 574  :     {
; 575  :         nPredictedSample = 32767;

  000c6	c7 45 f8 ff 7f
	00 00		 mov	 DWORD PTR _nPredictedSample$[ebp], 32767 ; 00007fffH

; 576  :     }
; 577  :     else if(nPredictedSample < -32768)

  000cd	eb 10		 jmp	 SHORT $L36581
$L36580:
  000cf	81 7d f8 00 80
	ff ff		 cmp	 DWORD PTR _nPredictedSample$[ebp], -32768 ; ffff8000H
  000d6	7d 07		 jge	 SHORT $L36581

; 578  :     {
; 579  :         nPredictedSample = -32768;

  000d8	c7 45 f8 00 80
	ff ff		 mov	 DWORD PTR _nPredictedSample$[ebp], -32768 ; ffff8000H
$L36581:

; 580  :     }
; 581  : 
; 582  :     *pnPredictedSample = nPredictedSample;

  000df	8b 55 0c	 mov	 edx, DWORD PTR _pnPredictedSample$[ebp]
  000e2	8b 45 f8	 mov	 eax, DWORD PTR _nPredictedSample$[ebp]
  000e5	89 02		 mov	 DWORD PTR [edx], eax

; 583  :     
; 584  :     return nEncodedSample;

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]

; 585  : }

  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c2 0c 00	 ret	 12			; 0000000cH
?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ENDP ; DirectSound::CImaAdpcmCodec::EncodeSample
DSOUND	ENDS
PUBLIC	?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
; Function compile flags: /Odt
;	COMDAT ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z
DSOUND	SEGMENT
_lDifference$ = -8
_lNewSample$ = -4
_nEncodedSample$ = 8
_nPredictedSample$ = 12
_nStepSize$ = 16
?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::DecodeSample, COMDAT

; 612  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 613  :     LONG                lDifference;
; 614  :     LONG                lNewSample;
; 615  : 
; 616  :     lDifference = nStepSize >> 3;

  00006	8b 45 10	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  00009	c1 f8 03	 sar	 eax, 3
  0000c	89 45 f8	 mov	 DWORD PTR _lDifference$[ebp], eax

; 617  : 
; 618  :     if(nEncodedSample & 4) 

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _nEncodedSample$[ebp]
  00012	83 e1 04	 and	 ecx, 4
  00015	85 c9		 test	 ecx, ecx
  00017	74 09		 je	 SHORT $L36590

; 619  :     {
; 620  :         lDifference += nStepSize;

  00019	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0001c	03 55 10	 add	 edx, DWORD PTR _nStepSize$[ebp]
  0001f	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L36590:

; 621  :     }
; 622  : 
; 623  :     if(nEncodedSample & 2) 

  00022	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00025	83 e0 02	 and	 eax, 2
  00028	85 c0		 test	 eax, eax
  0002a	74 0d		 je	 SHORT $L36591

; 624  :     {
; 625  :         lDifference += nStepSize >> 1;

  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  0002f	d1 f9		 sar	 ecx, 1
  00031	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  00034	03 d1		 add	 edx, ecx
  00036	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L36591:

; 626  :     }
; 627  : 
; 628  :     if(nEncodedSample & 1) 

  00039	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  0003c	83 e0 01	 and	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	74 0e		 je	 SHORT $L36592

; 629  :     {
; 630  :         lDifference += nStepSize >> 2;

  00043	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00046	c1 f9 02	 sar	 ecx, 2
  00049	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0004c	03 d1		 add	 edx, ecx
  0004e	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L36592:

; 631  :     }
; 632  : 
; 633  :     if(nEncodedSample & 8)

  00051	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00054	83 e0 08	 and	 eax, 8
  00057	85 c0		 test	 eax, eax
  00059	74 08		 je	 SHORT $L36593

; 634  :     {
; 635  :         lDifference = -lDifference;

  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  0005e	f7 d9		 neg	 ecx
  00060	89 4d f8	 mov	 DWORD PTR _lDifference$[ebp], ecx
$L36593:

; 636  :     }
; 637  : 
; 638  :     lNewSample = nPredictedSample + lDifference;

  00063	8b 55 0c	 mov	 edx, DWORD PTR _nPredictedSample$[ebp]
  00066	03 55 f8	 add	 edx, DWORD PTR _lDifference$[ebp]
  00069	89 55 fc	 mov	 DWORD PTR _lNewSample$[ebp], edx

; 639  : 
; 640  :     if((LONG)(short)lNewSample != lNewSample)

  0006c	0f bf 45 fc	 movsx	 eax, WORD PTR _lNewSample$[ebp]
  00070	3b 45 fc	 cmp	 eax, DWORD PTR _lNewSample$[ebp]
  00073	74 19		 je	 SHORT $L36596

; 641  :     {
; 642  :         if(lNewSample < -32768)

  00075	81 7d fc 00 80
	ff ff		 cmp	 DWORD PTR _lNewSample$[ebp], -32768 ; ffff8000H
  0007c	7d 09		 jge	 SHORT $L36597

; 643  :         {
; 644  :             lNewSample = -32768;

  0007e	c7 45 fc 00 80
	ff ff		 mov	 DWORD PTR _lNewSample$[ebp], -32768 ; ffff8000H

; 645  :         }
; 646  :         else

  00085	eb 07		 jmp	 SHORT $L36596
$L36597:

; 647  :         {
; 648  :             lNewSample = 32767;

  00087	c7 45 fc ff 7f
	00 00		 mov	 DWORD PTR _lNewSample$[ebp], 32767 ; 00007fffH
$L36596:

; 649  :         }
; 650  :     }
; 651  : 
; 652  :     return (int)lNewSample;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _lNewSample$[ebp]

; 653  : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ENDP	; DirectSound::CImaAdpcmCodec::DecodeSample
DSOUND	ENDS
PUBLIC	?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
; Function compile flags: /Odt
;	COMDAT ?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT
_nPredSample$ = -32
_pbBlock$ = -28
_nStepSize$ = -24
_nEncSample2$ = -20
_nEncSample1$ = -16
_cSamples$ = -12
_nStepIndex$ = -8
_nSample$ = -4
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_pnStepIndexL$ = 28
_pnStepIndexR$ = 32
?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::EncodeM16, COMDAT

; 689  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 690  :     LPBYTE                  pbBlock;
; 691  :     UINT                    cSamples;
; 692  :     int                     nSample;
; 693  :     int                     nStepSize;
; 694  :     int                     nEncSample1;
; 695  :     int                     nEncSample2;
; 696  :     int                     nPredSample;
; 697  :     int                     nStepIndex;
; 698  : 
; 699  :     //
; 700  :     // Save a local copy of the step index so we're not constantly 
; 701  :     // dereferencing a pointer.
; 702  :     //
; 703  :     
; 704  :     nStepIndex = *pnStepIndexL;

  00006	8b 45 1c	 mov	 eax, DWORD PTR _pnStepIndexL$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d f8	 mov	 DWORD PTR _nStepIndex$[ebp], ecx
$L36618:

; 705  : 
; 706  :     //
; 707  :     // Enter the main loop
; 708  :     //
; 709  :     
; 710  :     while(cBlocks--)

  0000e	8b 55 10	 mov	 edx, DWORD PTR _cBlocks$[ebp]
  00011	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00014	83 e8 01	 sub	 eax, 1
  00017	89 45 10	 mov	 DWORD PTR _cBlocks$[ebp], eax
  0001a	85 d2		 test	 edx, edx
  0001c	0f 84 2a 01 00
	00		 je	 $L36619

; 711  :     {
; 712  :         pbBlock = pbDst;

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  00025	89 4d e4	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 713  :         cSamples = cSamplesPerBlock - 1;

  00028	8b 55 18	 mov	 edx, DWORD PTR _cSamplesPerBlock$[ebp]
  0002b	83 ea 01	 sub	 edx, 1
  0002e	89 55 f4	 mov	 DWORD PTR _cSamples$[ebp], edx

; 714  : 
; 715  :         //
; 716  :         // Block header
; 717  :         //
; 718  : 
; 719  :         nPredSample = *(short *)pbSrc;

  00031	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00034	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00037	89 4d e0	 mov	 DWORD PTR _nPredSample$[ebp], ecx

; 720  :         pbSrc += sizeof(short);

  0003a	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0003d	83 c2 02	 add	 edx, 2
  00040	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 721  : 
; 722  :         *(LONG *)pbBlock = MAKELONG(nPredSample, nStepIndex);

  00043	8b 45 e0	 mov	 eax, DWORD PTR _nPredSample$[ebp]
  00046	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004b	0f b7 c8	 movzx	 ecx, ax
  0004e	8b 55 f8	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  00051	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00057	0f b7 c2	 movzx	 eax, dx
  0005a	c1 e0 10	 shl	 eax, 16			; 00000010H
  0005d	0b c8		 or	 ecx, eax
  0005f	8b 55 e4	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00062	89 0a		 mov	 DWORD PTR [edx], ecx

; 723  :         pbBlock += sizeof(LONG);

  00064	8b 45 e4	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  00067	83 c0 04	 add	 eax, 4
  0006a	89 45 e4	 mov	 DWORD PTR _pbBlock$[ebp], eax
$L36631:

; 724  : 
; 725  :         //
; 726  :         // We have written the header for this block--now write the data
; 727  :         // chunk (which consists of a bunch of encoded nibbles).  Note
; 728  :         // that if we don't have enough data to fill a complete byte, then
; 729  :         // we add a 0 nibble on the end.
; 730  :         //
; 731  : 
; 732  :         while(cSamples)

  0006d	83 7d f4 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  00071	0f 84 c7 00 00
	00		 je	 $L36632

; 733  :         {
; 734  :             //
; 735  :             // Sample 1
; 736  :             //
; 737  : 
; 738  :             nSample = *(short *)pbSrc;

  00077	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  0007a	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0007d	89 55 fc	 mov	 DWORD PTR _nSample$[ebp], edx

; 739  :             pbSrc += sizeof(short);

  00080	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00083	83 c0 02	 add	 eax, 2
  00086	89 45 08	 mov	 DWORD PTR _pbSrc$[ebp], eax

; 740  :             cSamples--;

  00089	8b 4d f4	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  0008c	83 e9 01	 sub	 ecx, 1
  0008f	89 4d f4	 mov	 DWORD PTR _cSamples$[ebp], ecx

; 741  : 
; 742  :             nStepSize = m_asStep[nStepIndex];

  00092	8b 55 f8	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  00095	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  0009d	89 45 e8	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 743  :             nEncSample1 = EncodeSample(nSample, &nPredSample, nStepSize);

  000a0	8b 4d e8	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  000a3	51		 push	 ecx
  000a4	8d 55 e0	 lea	 edx, DWORD PTR _nPredSample$[ebp]
  000a7	52		 push	 edx
  000a8	8b 45 fc	 mov	 eax, DWORD PTR _nSample$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  000b1	89 45 f0	 mov	 DWORD PTR _nEncSample1$[ebp], eax

; 744  :             nStepIndex = NextStepIndex(nEncSample1, nStepIndex);

  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  000b7	51		 push	 ecx
  000b8	8b 55 f0	 mov	 edx, DWORD PTR _nEncSample1$[ebp]
  000bb	52		 push	 edx
  000bc	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  000c1	89 45 f8	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 745  : 
; 746  :             //
; 747  :             // Sample 2
; 748  :             //
; 749  : 
; 750  :             if(cSamples)

  000c4	83 7d f4 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000c8	74 4f		 je	 SHORT $L36635

; 751  :             {
; 752  :                 nSample = *(short *)pbSrc;

  000ca	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  000cd	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000d0	89 4d fc	 mov	 DWORD PTR _nSample$[ebp], ecx

; 753  :                 pbSrc += sizeof(short);

  000d3	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  000d6	83 c2 02	 add	 edx, 2
  000d9	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 754  :                 cSamples--;

  000dc	8b 45 f4	 mov	 eax, DWORD PTR _cSamples$[ebp]
  000df	83 e8 01	 sub	 eax, 1
  000e2	89 45 f4	 mov	 DWORD PTR _cSamples$[ebp], eax

; 755  : 
; 756  :                 nStepSize = m_asStep[nStepIndex];

  000e5	8b 4d f8	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  000e8	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[ecx*2]
  000f0	89 55 e8	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 757  :                 nEncSample2 = EncodeSample(nSample, &nPredSample, nStepSize);

  000f3	8b 45 e8	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  000f6	50		 push	 eax
  000f7	8d 4d e0	 lea	 ecx, DWORD PTR _nPredSample$[ebp]
  000fa	51		 push	 ecx
  000fb	8b 55 fc	 mov	 edx, DWORD PTR _nSample$[ebp]
  000fe	52		 push	 edx
  000ff	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  00104	89 45 ec	 mov	 DWORD PTR _nEncSample2$[ebp], eax

; 758  :                 nStepIndex = NextStepIndex(nEncSample2, nStepIndex);

  00107	8b 45 f8	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  0010a	50		 push	 eax
  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _nEncSample2$[ebp]
  0010e	51		 push	 ecx
  0010f	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  00114	89 45 f8	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 759  :             }
; 760  :             else

  00117	eb 07		 jmp	 SHORT $L36638
$L36635:

; 761  :             {
; 762  :                 nEncSample2 = 0;

  00119	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _nEncSample2$[ebp], 0
$L36638:

; 763  :             }
; 764  : 
; 765  :             //
; 766  :             // Write out encoded byte.
; 767  :             //
; 768  : 
; 769  :             *pbBlock++ = (BYTE)(nEncSample1 | (nEncSample2 << 4));

  00120	8b 55 ec	 mov	 edx, DWORD PTR _nEncSample2$[ebp]
  00123	c1 e2 04	 shl	 edx, 4
  00126	8b 45 f0	 mov	 eax, DWORD PTR _nEncSample1$[ebp]
  00129	0b c2		 or	 eax, edx
  0012b	8b 4d e4	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  0012e	88 01		 mov	 BYTE PTR [ecx], al
  00130	8b 55 e4	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00133	83 c2 01	 add	 edx, 1
  00136	89 55 e4	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 770  :         }

  00139	e9 2f ff ff ff	 jmp	 $L36631
$L36632:

; 771  : 
; 772  :         //
; 773  :         // Skip padding
; 774  :         //
; 775  : 
; 776  :         pbDst += nBlockAlignment;

  0013e	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  00141	03 45 14	 add	 eax, DWORD PTR _nBlockAlignment$[ebp]
  00144	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 777  :     }

  00147	e9 c2 fe ff ff	 jmp	 $L36618
$L36619:

; 778  : 
; 779  :     //
; 780  :     // Restore the value of the step index to be used on the next buffer.
; 781  :     //
; 782  : 
; 783  :     *pnStepIndexL = nStepIndex;

  0014c	8b 4d 1c	 mov	 ecx, DWORD PTR _pnStepIndexL$[ebp]
  0014f	8b 55 f8	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  00152	89 11		 mov	 DWORD PTR [ecx], edx

; 784  : 
; 785  :     return TRUE;

  00154	b8 01 00 00 00	 mov	 eax, 1

; 786  : }

  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c2 1c 00	 ret	 28			; 0000001cH
?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::EncodeM16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.h
DSOUND	ENDS
;	COMDAT ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z
DSOUND	SEGMENT
_nEncodedSample$ = 8
_nStepIndex$ = 12
?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::NextStepIndex, COMDAT

; 115  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 116  :         nStepIndex += m_asNextStep[nEncodedSample];

  00003	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00006	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_asNextStep@CImaAdpcmCodec@DirectSound@@0QBFB[eax*2]
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  00011	03 d1		 add	 edx, ecx
  00013	89 55 0c	 mov	 DWORD PTR _nStepIndex$[ebp], edx

; 117  : 
; 118  :         if(nStepIndex < 0)

  00016	83 7d 0c 00	 cmp	 DWORD PTR _nStepIndex$[ebp], 0
  0001a	7d 09		 jge	 SHORT $L30902

; 119  :         {
; 120  :             nStepIndex = 0;

  0001c	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _nStepIndex$[ebp], 0

; 121  :         }
; 122  :         else if(nStepIndex >= NUMELMS(m_asStep))

  00023	eb 0d		 jmp	 SHORT $L30903
$L30902:
  00025	83 7d 0c 59	 cmp	 DWORD PTR _nStepIndex$[ebp], 89 ; 00000059H
  00029	72 07		 jb	 SHORT $L30903

; 123  :         {
; 124  :             nStepIndex = NUMELMS(m_asStep) - 1;

  0002b	c7 45 0c 58 00
	00 00		 mov	 DWORD PTR _nStepIndex$[ebp], 88 ; 00000058H
$L30903:

; 125  :         }
; 126  : 
; 127  :         return nStepIndex;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _nStepIndex$[ebp]

; 128  :     }

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ENDP	; DirectSound::CImaAdpcmCodec::NextStepIndex
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
DSOUND	ENDS
;	COMDAT ?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT
tv91 = -60
_nPredSampleL$ = -56
_pbBlock$ = -52
_nStepSize$ = -48
_dwLeft$ = -44
_nPredSampleR$ = -40
_cSamples$ = -36
_nSample$ = -32
_nEncSampleL$ = -28
_cSubSamples$ = -24
_i$ = -20
_dwRight$ = -16
_nStepIndexR$ = -12
_nStepIndexL$ = -8
_nEncSampleR$ = -4
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_pnStepIndexL$ = 28
_pnStepIndexR$ = 32
?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::EncodeS16, COMDAT

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 801  :     LPBYTE                  pbBlock;
; 802  :     UINT                    cSamples;
; 803  :     UINT                    cSubSamples;
; 804  :     int                     nSample;
; 805  :     int                     nStepSize;
; 806  :     DWORD                   dwLeft;
; 807  :     DWORD                   dwRight;
; 808  :     int                     nEncSampleL;
; 809  :     int                     nPredSampleL;
; 810  :     int                     nStepIndexL;
; 811  :     int                     nEncSampleR;
; 812  :     int                     nPredSampleR;
; 813  :     int                     nStepIndexR;
; 814  :     UINT                    i;
; 815  : 
; 816  :     //
; 817  :     // Save a local copy of the step indeces so we're not constantly 
; 818  :     // dereferencing a pointer.
; 819  :     //
; 820  :     
; 821  :     nStepIndexL = *pnStepIndexL;

  00006	8b 45 1c	 mov	 eax, DWORD PTR _pnStepIndexL$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d f8	 mov	 DWORD PTR _nStepIndexL$[ebp], ecx

; 822  :     nStepIndexR = *pnStepIndexR;

  0000e	8b 55 20	 mov	 edx, DWORD PTR _pnStepIndexR$[ebp]
  00011	8b 02		 mov	 eax, DWORD PTR [edx]
  00013	89 45 f4	 mov	 DWORD PTR _nStepIndexR$[ebp], eax
$L36664:

; 823  : 
; 824  :     //
; 825  :     // Enter the main loop
; 826  :     //
; 827  :     
; 828  :     while(cBlocks--)

  00016	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00019	8b 55 10	 mov	 edx, DWORD PTR _cBlocks$[ebp]
  0001c	83 ea 01	 sub	 edx, 1
  0001f	89 55 10	 mov	 DWORD PTR _cBlocks$[ebp], edx
  00022	85 c9		 test	 ecx, ecx
  00024	0f 84 ca 01 00
	00		 je	 $L36665

; 829  :     {
; 830  :         pbBlock = pbDst;

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  0002d	89 45 cc	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 831  :         cSamples = cSamplesPerBlock - 1;

  00030	8b 4d 18	 mov	 ecx, DWORD PTR _cSamplesPerBlock$[ebp]
  00033	83 e9 01	 sub	 ecx, 1
  00036	89 4d dc	 mov	 DWORD PTR _cSamples$[ebp], ecx

; 832  : 
; 833  :         //
; 834  :         // LEFT channel block header
; 835  :         //
; 836  : 
; 837  :         nPredSampleL = *(short *)pbSrc;

  00039	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0003c	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0003f	89 45 c8	 mov	 DWORD PTR _nPredSampleL$[ebp], eax

; 838  :         pbSrc += sizeof(short);

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  00045	83 c1 02	 add	 ecx, 2
  00048	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 839  : 
; 840  :         *(LONG *)pbBlock = MAKELONG(nPredSampleL, nStepIndexL);

  0004b	8b 55 c8	 mov	 edx, DWORD PTR _nPredSampleL$[ebp]
  0004e	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00054	0f b7 c2	 movzx	 eax, dx
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _nStepIndexL$[ebp]
  0005a	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00060	0f b7 d1	 movzx	 edx, cx
  00063	c1 e2 10	 shl	 edx, 16			; 00000010H
  00066	0b c2		 or	 eax, edx
  00068	8b 4d cc	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  0006b	89 01		 mov	 DWORD PTR [ecx], eax

; 841  :         pbBlock += sizeof(LONG);

  0006d	8b 55 cc	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00070	83 c2 04	 add	 edx, 4
  00073	89 55 cc	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 842  : 
; 843  :         //
; 844  :         // RIGHT channel block header
; 845  :         //
; 846  : 
; 847  :         nPredSampleR = *(short *)pbSrc;

  00076	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00079	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0007c	89 4d d8	 mov	 DWORD PTR _nPredSampleR$[ebp], ecx

; 848  :         pbSrc += sizeof(short);

  0007f	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00082	83 c2 02	 add	 edx, 2
  00085	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 849  : 
; 850  :         *(LONG *)pbBlock = MAKELONG(nPredSampleR, nStepIndexR);

  00088	8b 45 d8	 mov	 eax, DWORD PTR _nPredSampleR$[ebp]
  0008b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00090	0f b7 c8	 movzx	 ecx, ax
  00093	8b 55 f4	 mov	 edx, DWORD PTR _nStepIndexR$[ebp]
  00096	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0009c	0f b7 c2	 movzx	 eax, dx
  0009f	c1 e0 10	 shl	 eax, 16			; 00000010H
  000a2	0b c8		 or	 ecx, eax
  000a4	8b 55 cc	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  000a7	89 0a		 mov	 DWORD PTR [edx], ecx

; 851  :         pbBlock += sizeof(LONG);

  000a9	8b 45 cc	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  000ac	83 c0 04	 add	 eax, 4
  000af	89 45 cc	 mov	 DWORD PTR _pbBlock$[ebp], eax
$L36687:

; 852  : 
; 853  :         //
; 854  :         // We have written the header for this block--now write the data
; 855  :         // chunk.  This consists of 8 left samples (one DWORD of output)
; 856  :         // followed by 8 right samples (also one DWORD).  Since the input
; 857  :         // samples are interleaved, we create the left and right DWORDs
; 858  :         // sample by sample, and then write them both out.
; 859  :         //
; 860  : 
; 861  :         while(cSamples)

  000b2	83 7d dc 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000b6	0f 84 2a 01 00
	00		 je	 $L36688

; 862  :         {
; 863  :             dwLeft = 0;

  000bc	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _dwLeft$[ebp], 0

; 864  :             dwRight = 0;

  000c3	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwRight$[ebp], 0

; 865  : 
; 866  :             cSubSamples = min(cSamples, 8);

  000ca	83 7d dc 08	 cmp	 DWORD PTR _cSamples$[ebp], 8
  000ce	73 08		 jae	 SHORT $L37640
  000d0	8b 4d dc	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  000d3	89 4d c4	 mov	 DWORD PTR tv91[ebp], ecx
  000d6	eb 07		 jmp	 SHORT $L37641
$L37640:
  000d8	c7 45 c4 08 00
	00 00		 mov	 DWORD PTR tv91[ebp], 8
$L37641:
  000df	8b 55 c4	 mov	 edx, DWORD PTR tv91[ebp]
  000e2	89 55 e8	 mov	 DWORD PTR _cSubSamples$[ebp], edx

; 867  : 
; 868  :             for(i = 0; i < cSubSamples; i++)

  000e5	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ec	eb 09		 jmp	 SHORT $L36689
$L36690:
  000ee	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000f1	83 c0 01	 add	 eax, 1
  000f4	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$L36689:
  000f7	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  000fa	3b 4d e8	 cmp	 ecx, DWORD PTR _cSubSamples$[ebp]
  000fd	0f 83 b3 00 00
	00		 jae	 $L36691

; 869  :             {
; 870  :                 //
; 871  :                 // LEFT channel
; 872  :                 //
; 873  : 
; 874  :                 nSample = *(short *)pbSrc;

  00103	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00106	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00109	89 45 e0	 mov	 DWORD PTR _nSample$[ebp], eax

; 875  :                 pbSrc += sizeof(short);

  0010c	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  0010f	83 c1 02	 add	 ecx, 2
  00112	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 876  : 
; 877  :                 nStepSize = m_asStep[nStepIndexL];

  00115	8b 55 f8	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  00118	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  00120	89 45 d0	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 878  :                 
; 879  :                 nEncSampleL = EncodeSample(nSample, &nPredSampleL, nStepSize);

  00123	8b 4d d0	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00126	51		 push	 ecx
  00127	8d 55 c8	 lea	 edx, DWORD PTR _nPredSampleL$[ebp]
  0012a	52		 push	 edx
  0012b	8b 45 e0	 mov	 eax, DWORD PTR _nSample$[ebp]
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  00134	89 45 e4	 mov	 DWORD PTR _nEncSampleL$[ebp], eax

; 880  : 
; 881  :                 nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);

  00137	8b 4d f8	 mov	 ecx, DWORD PTR _nStepIndexL$[ebp]
  0013a	51		 push	 ecx
  0013b	8b 55 e4	 mov	 edx, DWORD PTR _nEncSampleL$[ebp]
  0013e	52		 push	 edx
  0013f	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  00144	89 45 f8	 mov	 DWORD PTR _nStepIndexL$[ebp], eax

; 882  :                 dwLeft |= (DWORD)nEncSampleL << (4 * i);

  00147	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  0014a	c1 e1 02	 shl	 ecx, 2
  0014d	8b 45 e4	 mov	 eax, DWORD PTR _nEncSampleL$[ebp]
  00150	d3 e0		 shl	 eax, cl
  00152	8b 4d d4	 mov	 ecx, DWORD PTR _dwLeft$[ebp]
  00155	0b c8		 or	 ecx, eax
  00157	89 4d d4	 mov	 DWORD PTR _dwLeft$[ebp], ecx

; 883  : 
; 884  :                 //
; 885  :                 // RIGHT channel
; 886  :                 //
; 887  : 
; 888  :                 nSample = *(short *)pbSrc;

  0015a	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0015d	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00160	89 45 e0	 mov	 DWORD PTR _nSample$[ebp], eax

; 889  :                 pbSrc += sizeof(short);

  00163	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  00166	83 c1 02	 add	 ecx, 2
  00169	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 890  : 
; 891  :                 nStepSize = m_asStep[nStepIndexR];

  0016c	8b 55 f4	 mov	 edx, DWORD PTR _nStepIndexR$[ebp]
  0016f	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  00177	89 45 d0	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 892  :                 
; 893  :                 nEncSampleR = EncodeSample(nSample, &nPredSampleR, nStepSize);

  0017a	8b 4d d0	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  0017d	51		 push	 ecx
  0017e	8d 55 d8	 lea	 edx, DWORD PTR _nPredSampleR$[ebp]
  00181	52		 push	 edx
  00182	8b 45 e0	 mov	 eax, DWORD PTR _nSample$[ebp]
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  0018b	89 45 fc	 mov	 DWORD PTR _nEncSampleR$[ebp], eax

; 894  : 
; 895  :                 nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);

  0018e	8b 4d f4	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  00191	51		 push	 ecx
  00192	8b 55 fc	 mov	 edx, DWORD PTR _nEncSampleR$[ebp]
  00195	52		 push	 edx
  00196	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  0019b	89 45 f4	 mov	 DWORD PTR _nStepIndexR$[ebp], eax

; 896  :                 dwRight |= (DWORD)nEncSampleR << (4 * i);

  0019e	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  001a1	c1 e1 02	 shl	 ecx, 2
  001a4	8b 45 fc	 mov	 eax, DWORD PTR _nEncSampleR$[ebp]
  001a7	d3 e0		 shl	 eax, cl
  001a9	8b 4d f0	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  001ac	0b c8		 or	 ecx, eax
  001ae	89 4d f0	 mov	 DWORD PTR _dwRight$[ebp], ecx

; 897  :             }

  001b1	e9 38 ff ff ff	 jmp	 $L36690
$L36691:

; 898  : 
; 899  :             //
; 900  :             // Write out encoded DWORDs.
; 901  :             //
; 902  : 
; 903  :             *(LPDWORD)pbBlock = dwLeft;

  001b6	8b 55 cc	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  001b9	8b 45 d4	 mov	 eax, DWORD PTR _dwLeft$[ebp]
  001bc	89 02		 mov	 DWORD PTR [edx], eax

; 904  :             pbBlock += sizeof(DWORD);

  001be	8b 4d cc	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  001c1	83 c1 04	 add	 ecx, 4
  001c4	89 4d cc	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 905  : 
; 906  :             *(LPDWORD)pbBlock = dwRight;

  001c7	8b 55 cc	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  001ca	8b 45 f0	 mov	 eax, DWORD PTR _dwRight$[ebp]
  001cd	89 02		 mov	 DWORD PTR [edx], eax

; 907  :             pbBlock += sizeof(DWORD);

  001cf	8b 4d cc	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  001d2	83 c1 04	 add	 ecx, 4
  001d5	89 4d cc	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 908  : 
; 909  :             cSamples -= cSubSamples;

  001d8	8b 55 dc	 mov	 edx, DWORD PTR _cSamples$[ebp]
  001db	2b 55 e8	 sub	 edx, DWORD PTR _cSubSamples$[ebp]
  001de	89 55 dc	 mov	 DWORD PTR _cSamples$[ebp], edx

; 910  :         }

  001e1	e9 cc fe ff ff	 jmp	 $L36687
$L36688:

; 911  : 
; 912  :         //
; 913  :         // Skip padding
; 914  :         //
; 915  : 
; 916  :         pbDst += nBlockAlignment;

  001e6	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  001e9	03 45 14	 add	 eax, DWORD PTR _nBlockAlignment$[ebp]
  001ec	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 917  :     }

  001ef	e9 22 fe ff ff	 jmp	 $L36664
$L36665:

; 918  : 
; 919  :     //
; 920  :     // Restore the value of the step index to be used on the next buffer.
; 921  :     //
; 922  :     
; 923  :     *pnStepIndexL = nStepIndexL;

  001f4	8b 4d 1c	 mov	 ecx, DWORD PTR _pnStepIndexL$[ebp]
  001f7	8b 55 f8	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  001fa	89 11		 mov	 DWORD PTR [ecx], edx

; 924  :     *pnStepIndexR = nStepIndexR;

  001fc	8b 45 20	 mov	 eax, DWORD PTR _pnStepIndexR$[ebp]
  001ff	8b 4d f4	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  00202	89 08		 mov	 DWORD PTR [eax], ecx

; 925  : 
; 926  :     return TRUE;

  00204	b8 01 00 00 00	 mov	 eax, 1

; 927  : 
; 928  : }

  00209	8b e5		 mov	 esp, ebp
  0020b	5d		 pop	 ebp
  0020c	c2 1c 00	 ret	 28			; 0000001cH
?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::EncodeS16
DSOUND	ENDS
PUBLIC	?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
; Function compile flags: /Odt
;	COMDAT ?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT
_nPredSample$ = -36
_pbBlock$ = -32
_dwHeader$ = -28
_bSample$ = -21
_nStepSize$ = -20
_cSamples$ = -16
_nStepIndex$ = -12
_fSuccess$ = -8
_nEncSample$ = -4
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_pnStepIndexL$ = 28
_pnStepIndexR$ = 32
?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::DecodeM16, COMDAT

; 942  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 943  :     BOOL                    fSuccess    = TRUE;

  00006	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 1
$L36721:

; 944  :     LPBYTE                  pbBlock;
; 945  :     UINT                    cSamples;
; 946  :     BYTE                    bSample;
; 947  :     int                     nStepSize;
; 948  :     int                     nEncSample;
; 949  :     int                     nPredSample;
; 950  :     int                     nStepIndex;
; 951  :     DWORD                   dwHeader;
; 952  : 
; 953  :     //
; 954  :     // Enter the main loop
; 955  :     //
; 956  :     
; 957  :     while(cBlocks--)

  0000d	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00013	83 e9 01	 sub	 ecx, 1
  00016	89 4d 10	 mov	 DWORD PTR _cBlocks$[ebp], ecx
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 4b 01 00
	00		 je	 $L36722

; 958  :     {
; 959  :         pbBlock = pbSrc;

  00021	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00024	89 55 e0	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 960  :         cSamples = cSamplesPerBlock - 1;

  00027	8b 45 18	 mov	 eax, DWORD PTR _cSamplesPerBlock$[ebp]
  0002a	83 e8 01	 sub	 eax, 1
  0002d	89 45 f0	 mov	 DWORD PTR _cSamples$[ebp], eax

; 961  :         
; 962  :         //
; 963  :         // Block header
; 964  :         //
; 965  : 
; 966  :         dwHeader = *(LPDWORD)pbBlock;

  00030	8b 4d e0	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	89 55 e4	 mov	 DWORD PTR _dwHeader$[ebp], edx

; 967  :         pbBlock += sizeof(DWORD);

  00038	8b 45 e0	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 e0	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 968  : 
; 969  :         nPredSample = (int)(short)LOWORD(dwHeader);

  00041	8b 4d e4	 mov	 ecx, DWORD PTR _dwHeader$[ebp]
  00044	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0004a	0f bf d1	 movsx	 edx, cx
  0004d	89 55 dc	 mov	 DWORD PTR _nPredSample$[ebp], edx

; 970  :         nStepIndex = (int)(BYTE)HIWORD(dwHeader);

  00050	8b 45 e4	 mov	 eax, DWORD PTR _dwHeader$[ebp]
  00053	c1 e8 10	 shr	 eax, 16			; 00000010H
  00056	0f b6 c8	 movzx	 ecx, al
  00059	89 4d f4	 mov	 DWORD PTR _nStepIndex$[ebp], ecx

; 971  : 
; 972  :         if(!ValidStepIndex(nStepIndex))

  0005c	8b 55 f4	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
  00065	85 c0		 test	 eax, eax
  00067	75 0c		 jne	 SHORT $L36733

; 973  :         {
; 974  :             //
; 975  :             // The step index is out of range - this is considered a fatal
; 976  :             // error as the input stream is corrupted.  We fail by returning
; 977  :             // zero bytes converted.
; 978  :             //
; 979  : 
; 980  :             fSuccess = FALSE;

  00069	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 981  :             break;

  00070	e9 f7 00 00 00	 jmp	 $L36722
$L36733:

; 982  :         }
; 983  :         
; 984  :         //
; 985  :         // Write out first sample
; 986  :         //
; 987  : 
; 988  :         *(short *)pbDst = (short)nPredSample;

  00075	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  00078	66 8b 4d dc	 mov	 cx, WORD PTR _nPredSample$[ebp]
  0007c	66 89 08	 mov	 WORD PTR [eax], cx

; 989  :         pbDst += sizeof(short);

  0007f	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  00082	83 c2 02	 add	 edx, 2
  00085	89 55 0c	 mov	 DWORD PTR _pbDst$[ebp], edx
$L36738:

; 990  : 
; 991  :         //
; 992  :         // Enter the block loop
; 993  :         //
; 994  : 
; 995  :         while(cSamples)

  00088	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  0008c	0f 84 cc 00 00
	00		 je	 $L36739

; 996  :         {
; 997  :             bSample = *pbBlock++;

  00092	8b 45 e0	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  00095	8a 08		 mov	 cl, BYTE PTR [eax]
  00097	88 4d eb	 mov	 BYTE PTR _bSample$[ebp], cl
  0009a	8b 55 e0	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  0009d	83 c2 01	 add	 edx, 1
  000a0	89 55 e0	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 998  : 
; 999  :             //
; 1000 :             // Sample 1
; 1001 :             //
; 1002 : 
; 1003 :             nEncSample = (bSample & (BYTE)0x0F);

  000a3	0f b6 45 eb	 movzx	 eax, BYTE PTR _bSample$[ebp]
  000a7	83 e0 0f	 and	 eax, 15			; 0000000fH
  000aa	89 45 fc	 mov	 DWORD PTR _nEncSample$[ebp], eax

; 1004 :             nStepSize = m_asStep[nStepIndex];

  000ad	8b 4d f4	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  000b0	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[ecx*2]
  000b8	89 55 ec	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 1005 :             nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);

  000bb	8b 45 ec	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  000be	50		 push	 eax
  000bf	8b 4d dc	 mov	 ecx, DWORD PTR _nPredSample$[ebp]
  000c2	51		 push	 ecx
  000c3	8b 55 fc	 mov	 edx, DWORD PTR _nEncSample$[ebp]
  000c6	52		 push	 edx
  000c7	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  000cc	89 45 dc	 mov	 DWORD PTR _nPredSample$[ebp], eax

; 1006 :             nStepIndex = NextStepIndex(nEncSample, nStepIndex);

  000cf	8b 45 f4	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  000d2	50		 push	 eax
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _nEncSample$[ebp]
  000d6	51		 push	 ecx
  000d7	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  000dc	89 45 f4	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 1007 : 
; 1008 :             *(short *)pbDst = (short)nPredSample;

  000df	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  000e2	66 8b 45 dc	 mov	 ax, WORD PTR _nPredSample$[ebp]
  000e6	66 89 02	 mov	 WORD PTR [edx], ax

; 1009 :             pbDst += sizeof(short);

  000e9	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  000ec	83 c1 02	 add	 ecx, 2
  000ef	89 4d 0c	 mov	 DWORD PTR _pbDst$[ebp], ecx

; 1010 : 
; 1011 :             cSamples--;

  000f2	8b 55 f0	 mov	 edx, DWORD PTR _cSamples$[ebp]
  000f5	83 ea 01	 sub	 edx, 1
  000f8	89 55 f0	 mov	 DWORD PTR _cSamples$[ebp], edx

; 1012 : 
; 1013 :             //
; 1014 :             // Sample 2
; 1015 :             //
; 1016 : 
; 1017 :             if(cSamples)

  000fb	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000ff	74 58		 je	 SHORT $L36744

; 1018 :             {
; 1019 :                 nEncSample = (bSample >> 4);

  00101	0f b6 45 eb	 movzx	 eax, BYTE PTR _bSample$[ebp]
  00105	c1 f8 04	 sar	 eax, 4
  00108	89 45 fc	 mov	 DWORD PTR _nEncSample$[ebp], eax

; 1020 :                 nStepSize = m_asStep[nStepIndex];

  0010b	8b 4d f4	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  0010e	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[ecx*2]
  00116	89 55 ec	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 1021 :                 nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);

  00119	8b 45 ec	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  0011c	50		 push	 eax
  0011d	8b 4d dc	 mov	 ecx, DWORD PTR _nPredSample$[ebp]
  00120	51		 push	 ecx
  00121	8b 55 fc	 mov	 edx, DWORD PTR _nEncSample$[ebp]
  00124	52		 push	 edx
  00125	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  0012a	89 45 dc	 mov	 DWORD PTR _nPredSample$[ebp], eax

; 1022 :                 nStepIndex = NextStepIndex(nEncSample, nStepIndex);

  0012d	8b 45 f4	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  00130	50		 push	 eax
  00131	8b 4d fc	 mov	 ecx, DWORD PTR _nEncSample$[ebp]
  00134	51		 push	 ecx
  00135	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  0013a	89 45 f4	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 1023 : 
; 1024 :                 *(short *)pbDst = (short)nPredSample;

  0013d	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  00140	66 8b 45 dc	 mov	 ax, WORD PTR _nPredSample$[ebp]
  00144	66 89 02	 mov	 WORD PTR [edx], ax

; 1025 :                 pbDst += sizeof(short);

  00147	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  0014a	83 c1 02	 add	 ecx, 2
  0014d	89 4d 0c	 mov	 DWORD PTR _pbDst$[ebp], ecx

; 1026 : 
; 1027 :                 cSamples--;

  00150	8b 55 f0	 mov	 edx, DWORD PTR _cSamples$[ebp]
  00153	83 ea 01	 sub	 edx, 1
  00156	89 55 f0	 mov	 DWORD PTR _cSamples$[ebp], edx
$L36744:

; 1028 :             }
; 1029 :         }

  00159	e9 2a ff ff ff	 jmp	 $L36738
$L36739:

; 1030 : 
; 1031 :         //
; 1032 :         // Skip padding
; 1033 :         //
; 1034 : 
; 1035 :         pbSrc += nBlockAlignment;

  0015e	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00161	03 45 14	 add	 eax, DWORD PTR _nBlockAlignment$[ebp]
  00164	89 45 08	 mov	 DWORD PTR _pbSrc$[ebp], eax

; 1036 :     }

  00167	e9 a1 fe ff ff	 jmp	 $L36721
$L36722:

; 1037 : 
; 1038 :     return fSuccess;

  0016c	8b 45 f8	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 1039 : }

  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c2 1c 00	 ret	 28			; 0000001cH
?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::DecodeM16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.h
DSOUND	ENDS
;	COMDAT ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z
DSOUND	SEGMENT
tv66 = -4
_nStepIndex$ = 8
?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::ValidStepIndex, COMDAT

; 131  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 132  :         return (nStepIndex >= 0) && (nStepIndex < NUMELMS(m_asStep));

  00004	83 7d 08 00	 cmp	 DWORD PTR _nStepIndex$[ebp], 0
  00008	7c 0f		 jl	 SHORT $L37648
  0000a	83 7d 08 59	 cmp	 DWORD PTR _nStepIndex$[ebp], 89 ; 00000059H
  0000e	73 09		 jae	 SHORT $L37648
  00010	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00017	eb 07		 jmp	 SHORT $L37649
$L37648:
  00019	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L37649:
  00020	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]

; 133  :     }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ENDP	; DirectSound::CImaAdpcmCodec::ValidStepIndex
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
DSOUND	ENDS
;	COMDAT ?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT
tv134 = -64
_nPredSampleL$ = -60
_pbBlock$ = -56
_dwHeader$ = -52
_nStepSize$ = -48
_dwLeft$ = -44
_nPredSampleR$ = -40
_cSamples$ = -36
_nEncSampleL$ = -32
_cSubSamples$ = -28
_i$ = -24
_dwRight$ = -20
_nStepIndexR$ = -16
_fSuccess$ = -12
_nStepIndexL$ = -8
_nEncSampleR$ = -4
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_pnStepIndexL$ = 28
_pnStepIndexR$ = 32
?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::DecodeS16, COMDAT

; 1053 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 1054 :     BOOL                    fSuccess    = TRUE;

  00006	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 1
$L36773:

; 1055 :     LPBYTE                  pbBlock;
; 1056 :     UINT                    cSamples;
; 1057 :     UINT                    cSubSamples;
; 1058 :     int                     nStepSize;
; 1059 :     DWORD                   dwHeader;
; 1060 :     DWORD                   dwLeft;
; 1061 :     DWORD                   dwRight;
; 1062 :     int                     nEncSampleL;
; 1063 :     int                     nPredSampleL;
; 1064 :     int                     nStepIndexL;
; 1065 :     int                     nEncSampleR;
; 1066 :     int                     nPredSampleR;
; 1067 :     int                     nStepIndexR;
; 1068 :     UINT                    i;
; 1069 : 
; 1070 :     //
; 1071 :     // Enter the main loop
; 1072 :     //
; 1073 :     
; 1074 :     while(cBlocks--)

  0000d	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00013	83 e9 01	 sub	 ecx, 1
  00016	89 4d 10	 mov	 DWORD PTR _cBlocks$[ebp], ecx
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 fc 01 00
	00		 je	 $L36774

; 1075 :     {
; 1076 :         pbBlock = pbSrc;

  00021	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00024	89 55 c8	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 1077 :         cSamples = cSamplesPerBlock - 1;

  00027	8b 45 18	 mov	 eax, DWORD PTR _cSamplesPerBlock$[ebp]
  0002a	83 e8 01	 sub	 eax, 1
  0002d	89 45 dc	 mov	 DWORD PTR _cSamples$[ebp], eax

; 1078 : 
; 1079 :         //
; 1080 :         // LEFT channel header
; 1081 :         //
; 1082 : 
; 1083 :         dwHeader = *(LPDWORD)pbBlock;

  00030	8b 4d c8	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	89 55 cc	 mov	 DWORD PTR _dwHeader$[ebp], edx

; 1084 :         pbBlock += sizeof(DWORD);

  00038	8b 45 c8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 c8	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 1085 :         
; 1086 :         nPredSampleL = (int)(short)LOWORD(dwHeader);

  00041	8b 4d cc	 mov	 ecx, DWORD PTR _dwHeader$[ebp]
  00044	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0004a	0f bf d1	 movsx	 edx, cx
  0004d	89 55 c4	 mov	 DWORD PTR _nPredSampleL$[ebp], edx

; 1087 :         nStepIndexL = (int)(BYTE)HIWORD(dwHeader);

  00050	8b 45 cc	 mov	 eax, DWORD PTR _dwHeader$[ebp]
  00053	c1 e8 10	 shr	 eax, 16			; 00000010H
  00056	0f b6 c8	 movzx	 ecx, al
  00059	89 4d f8	 mov	 DWORD PTR _nStepIndexL$[ebp], ecx

; 1088 : 
; 1089 :         if(!ValidStepIndex(nStepIndexL)) 

  0005c	8b 55 f8	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
  00065	85 c0		 test	 eax, eax
  00067	75 0c		 jne	 SHORT $L36785

; 1090 :         {
; 1091 :             //
; 1092 :             // The step index is out of range - this is considered a fatal
; 1093 :             // error as the input stream is corrupted.  We fail by returning
; 1094 :             // zero bytes converted.
; 1095 :             //
; 1096 : 
; 1097 :             fSuccess = FALSE;

  00069	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 1098 :             break;

  00070	e9 a8 01 00 00	 jmp	 $L36774
$L36785:

; 1099 :         }
; 1100 :         
; 1101 :         //
; 1102 :         // RIGHT channel header
; 1103 :         //
; 1104 : 
; 1105 :         dwHeader = *(LPDWORD)pbBlock;

  00075	8b 45 c8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  00078	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007a	89 4d cc	 mov	 DWORD PTR _dwHeader$[ebp], ecx

; 1106 :         pbBlock += sizeof(DWORD);

  0007d	8b 55 c8	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00080	83 c2 04	 add	 edx, 4
  00083	89 55 c8	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 1107 :         
; 1108 :         nPredSampleR = (int)(short)LOWORD(dwHeader);

  00086	8b 45 cc	 mov	 eax, DWORD PTR _dwHeader$[ebp]
  00089	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0008e	0f bf c8	 movsx	 ecx, ax
  00091	89 4d d8	 mov	 DWORD PTR _nPredSampleR$[ebp], ecx

; 1109 :         nStepIndexR = (int)(BYTE)HIWORD(dwHeader);

  00094	8b 55 cc	 mov	 edx, DWORD PTR _dwHeader$[ebp]
  00097	c1 ea 10	 shr	 edx, 16			; 00000010H
  0009a	0f b6 c2	 movzx	 eax, dl
  0009d	89 45 f0	 mov	 DWORD PTR _nStepIndexR$[ebp], eax

; 1110 : 
; 1111 :         if(!ValidStepIndex(nStepIndexR))

  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
  000a9	85 c0		 test	 eax, eax
  000ab	75 0c		 jne	 SHORT $L36796

; 1112 :         {
; 1113 :             //
; 1114 :             // The step index is out of range - this is considered a fatal
; 1115 :             // error as the input stream is corrupted.  We fail by returning
; 1116 :             // zero bytes converted.
; 1117 :             //
; 1118 : 
; 1119 :             fSuccess = FALSE;

  000ad	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 1120 :             break;

  000b4	e9 64 01 00 00	 jmp	 $L36774
$L36796:

; 1121 :         }
; 1122 : 
; 1123 :         //
; 1124 :         // Write out first sample
; 1125 :         //
; 1126 : 
; 1127 :         *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);

  000b9	8b 55 c4	 mov	 edx, DWORD PTR _nPredSampleL$[ebp]
  000bc	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000c2	0f b7 c2	 movzx	 eax, dx
  000c5	8b 4d d8	 mov	 ecx, DWORD PTR _nPredSampleR$[ebp]
  000c8	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000ce	0f b7 d1	 movzx	 edx, cx
  000d1	c1 e2 10	 shl	 edx, 16			; 00000010H
  000d4	0b c2		 or	 eax, edx
  000d6	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  000d9	89 01		 mov	 DWORD PTR [ecx], eax

; 1128 :         pbDst += sizeof(DWORD);

  000db	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  000de	83 c2 04	 add	 edx, 4
  000e1	89 55 0c	 mov	 DWORD PTR _pbDst$[ebp], edx
$L36806:

; 1129 : 
; 1130 :         //
; 1131 :         // The first DWORD contains 4 left samples, the second DWORD
; 1132 :         // contains 4 right samples.  We process the source in 8-byte
; 1133 :         // chunks to make it easy to interleave the output correctly.
; 1134 :         //
; 1135 : 
; 1136 :         while(cSamples)

  000e4	83 7d dc 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000e8	0f 84 21 01 00
	00		 je	 $L36807

; 1137 :         {
; 1138 :             dwLeft = *(LPDWORD)pbBlock;

  000ee	8b 45 c8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  000f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f3	89 4d d4	 mov	 DWORD PTR _dwLeft$[ebp], ecx

; 1139 :             pbBlock += sizeof(DWORD);

  000f6	8b 55 c8	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  000f9	83 c2 04	 add	 edx, 4
  000fc	89 55 c8	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 1140 :             dwRight = *(LPDWORD)pbBlock;

  000ff	8b 45 c8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  00102	8b 08		 mov	 ecx, DWORD PTR [eax]
  00104	89 4d ec	 mov	 DWORD PTR _dwRight$[ebp], ecx

; 1141 :             pbBlock += sizeof(DWORD);

  00107	8b 55 c8	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  0010a	83 c2 04	 add	 edx, 4
  0010d	89 55 c8	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 1142 : 
; 1143 :             cSubSamples = min(cSamples, 8);

  00110	83 7d dc 08	 cmp	 DWORD PTR _cSamples$[ebp], 8
  00114	73 08		 jae	 SHORT $L37653
  00116	8b 45 dc	 mov	 eax, DWORD PTR _cSamples$[ebp]
  00119	89 45 c0	 mov	 DWORD PTR tv134[ebp], eax
  0011c	eb 07		 jmp	 SHORT $L37654
$L37653:
  0011e	c7 45 c0 08 00
	00 00		 mov	 DWORD PTR tv134[ebp], 8
$L37654:
  00125	8b 4d c0	 mov	 ecx, DWORD PTR tv134[ebp]
  00128	89 4d e4	 mov	 DWORD PTR _cSubSamples$[ebp], ecx

; 1144 :             
; 1145 :             for(i = 0; i < cSubSamples; i++)

  0012b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00132	eb 09		 jmp	 SHORT $L36812
$L36813:
  00134	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  00137	83 c2 01	 add	 edx, 1
  0013a	89 55 e8	 mov	 DWORD PTR _i$[ebp], edx
$L36812:
  0013d	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00140	3b 45 e4	 cmp	 eax, DWORD PTR _cSubSamples$[ebp]
  00143	0f 83 b8 00 00
	00		 jae	 $L36814

; 1146 :             {
; 1147 :                 //
; 1148 :                 // LEFT channel
; 1149 :                 //
; 1150 : 
; 1151 :                 nEncSampleL = (dwLeft & 0x0F);

  00149	8b 4d d4	 mov	 ecx, DWORD PTR _dwLeft$[ebp]
  0014c	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0014f	89 4d e0	 mov	 DWORD PTR _nEncSampleL$[ebp], ecx

; 1152 :                 nStepSize = m_asStep[nStepIndexL];

  00152	8b 55 f8	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  00155	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  0015d	89 45 d0	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 1153 :                 nPredSampleL = DecodeSample(nEncSampleL, nPredSampleL, nStepSize);

  00160	8b 4d d0	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00163	51		 push	 ecx
  00164	8b 55 c4	 mov	 edx, DWORD PTR _nPredSampleL$[ebp]
  00167	52		 push	 edx
  00168	8b 45 e0	 mov	 eax, DWORD PTR _nEncSampleL$[ebp]
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  00171	89 45 c4	 mov	 DWORD PTR _nPredSampleL$[ebp], eax

; 1154 :                 nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);

  00174	8b 4d f8	 mov	 ecx, DWORD PTR _nStepIndexL$[ebp]
  00177	51		 push	 ecx
  00178	8b 55 e0	 mov	 edx, DWORD PTR _nEncSampleL$[ebp]
  0017b	52		 push	 edx
  0017c	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  00181	89 45 f8	 mov	 DWORD PTR _nStepIndexL$[ebp], eax

; 1155 : 
; 1156 :                 //
; 1157 :                 // RIGHT channel
; 1158 :                 //
; 1159 : 
; 1160 :                 nEncSampleR = (dwRight & 0x0F);

  00184	8b 45 ec	 mov	 eax, DWORD PTR _dwRight$[ebp]
  00187	83 e0 0f	 and	 eax, 15			; 0000000fH
  0018a	89 45 fc	 mov	 DWORD PTR _nEncSampleR$[ebp], eax

; 1161 :                 nStepSize = m_asStep[nStepIndexR];

  0018d	8b 4d f0	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  00190	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[ecx*2]
  00198	89 55 d0	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 1162 :                 nPredSampleR = DecodeSample(nEncSampleR, nPredSampleR, nStepSize);

  0019b	8b 45 d0	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  0019e	50		 push	 eax
  0019f	8b 4d d8	 mov	 ecx, DWORD PTR _nPredSampleR$[ebp]
  001a2	51		 push	 ecx
  001a3	8b 55 fc	 mov	 edx, DWORD PTR _nEncSampleR$[ebp]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  001ac	89 45 d8	 mov	 DWORD PTR _nPredSampleR$[ebp], eax

; 1163 :                 nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);

  001af	8b 45 f0	 mov	 eax, DWORD PTR _nStepIndexR$[ebp]
  001b2	50		 push	 eax
  001b3	8b 4d fc	 mov	 ecx, DWORD PTR _nEncSampleR$[ebp]
  001b6	51		 push	 ecx
  001b7	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  001bc	89 45 f0	 mov	 DWORD PTR _nStepIndexR$[ebp], eax

; 1164 : 
; 1165 :                 //
; 1166 :                 // Write out sample
; 1167 :                 //
; 1168 : 
; 1169 :                 *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);

  001bf	8b 55 c4	 mov	 edx, DWORD PTR _nPredSampleL$[ebp]
  001c2	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  001c8	0f b7 c2	 movzx	 eax, dx
  001cb	8b 4d d8	 mov	 ecx, DWORD PTR _nPredSampleR$[ebp]
  001ce	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  001d4	0f b7 d1	 movzx	 edx, cx
  001d7	c1 e2 10	 shl	 edx, 16			; 00000010H
  001da	0b c2		 or	 eax, edx
  001dc	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  001df	89 01		 mov	 DWORD PTR [ecx], eax

; 1170 :                 pbDst += sizeof(DWORD);

  001e1	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  001e4	83 c2 04	 add	 edx, 4
  001e7	89 55 0c	 mov	 DWORD PTR _pbDst$[ebp], edx

; 1171 : 
; 1172 :                 //
; 1173 :                 // Shift the next input sample into the low-order 4 bits.
; 1174 :                 //
; 1175 : 
; 1176 :                 dwLeft >>= 4;

  001ea	8b 45 d4	 mov	 eax, DWORD PTR _dwLeft$[ebp]
  001ed	c1 e8 04	 shr	 eax, 4
  001f0	89 45 d4	 mov	 DWORD PTR _dwLeft$[ebp], eax

; 1177 :                 dwRight >>= 4;

  001f3	8b 4d ec	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  001f6	c1 e9 04	 shr	 ecx, 4
  001f9	89 4d ec	 mov	 DWORD PTR _dwRight$[ebp], ecx

; 1178 :             }

  001fc	e9 33 ff ff ff	 jmp	 $L36813
$L36814:

; 1179 : 
; 1180 :             cSamples -= cSubSamples;

  00201	8b 55 dc	 mov	 edx, DWORD PTR _cSamples$[ebp]
  00204	2b 55 e4	 sub	 edx, DWORD PTR _cSubSamples$[ebp]
  00207	89 55 dc	 mov	 DWORD PTR _cSamples$[ebp], edx

; 1181 :         }

  0020a	e9 d5 fe ff ff	 jmp	 $L36806
$L36807:

; 1182 : 
; 1183 :         //
; 1184 :         // Skip padding
; 1185 :         //
; 1186 : 
; 1187 :         pbSrc += nBlockAlignment;

  0020f	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00212	03 45 14	 add	 eax, DWORD PTR _nBlockAlignment$[ebp]
  00215	89 45 08	 mov	 DWORD PTR _pbSrc$[ebp], eax

; 1188 :     }

  00218	e9 f0 fd ff ff	 jmp	 $L36773
$L36774:

; 1189 : 
; 1190 :     return fSuccess;

  0021d	8b 45 f4	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 1191 : }

  00220	8b e5		 mov	 esp, ebp
  00222	5d		 pop	 ebp
  00223	c2 1c 00	 ret	 28			; 0000001cH
?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::DecodeS16
DSOUND	ENDS
PUBLIC	?m_dwDpfLevel@CDebug@DirectSound@@2AAKA		; DirectSound::CDebug::m_dwDpfLevel
PUBLIC	?m_dwDpfBreakLevel@CDebug@DirectSound@@2AAKA	; DirectSound::CDebug::m_dwDpfBreakLevel
PUBLIC	?m_fDebugBreak@CDebug@DirectSound@@2AAHA	; DirectSound::CDebug::m_fDebugBreak
PUBLIC	?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
PUBLIC	?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2AAKA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
DSOUND_URW	SEGMENT
?m_dwDpfLevel@CDebug@DirectSound@@2AAKA DD 01H DUP (?)	; DirectSound::CDebug::m_dwDpfLevel
?m_dwDpfBreakLevel@CDebug@DirectSound@@2AAKA DD 01H DUP (?) ; DirectSound::CDebug::m_dwDpfBreakLevel
?m_fDebugBreak@CDebug@DirectSound@@2AAHA DD 01H DUP (?)	; DirectSound::CDebug::m_fDebugBreak
?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2AAKA DD 01H DUP (?) ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2AAKA DD 01H DUP (?) ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
DSOUND_URW	ENDS
END
