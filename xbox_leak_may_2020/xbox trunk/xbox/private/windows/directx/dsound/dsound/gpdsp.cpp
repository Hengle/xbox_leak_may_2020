
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       gpdsp.cpp
 *  Content:    GP dsp manager.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/2001    georgioc created
 *
 ****************************************************************************/


#include "dsoundi.h"
#include "dspdma.h"
#include "GPDsp.h"

//
// include dsp code words for default execution engine loaded into GP after reset
//

#ifdef MCPX_BOOT_LIB

static ULONG DefaultExec[] = 
{
    #include "dspbootsndcode.h"
};

#else // MCPX_BOOT_LIB
    
static ULONG DefaultExec[] = 
{
    #include "dspexeccode.h"
};

#endif // MCPX_BOOT_LIB


VOID
CMcpxDspImage::Initialize()
{
    //
    // initialize all the effects here
    //

    m_pLoader = (PVOID)DefaultExec;
    m_uLoaderSize = sizeof(DefaultExec);
   
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// DSP DMA Manager for the GP
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


CMcpxGPDspManager::CMcpxGPDspManager()
{
    m_pScratchDma = NULL;
    m_pDspImage = NULL;
    m_uPMemMaxSize = NV_PAPU_GPPMEM__SIZE_1;
    m_uPMemOffset = 0;

    m_dwCurrentLowestScratchOffset = MCPX_GLOBAL_PROC_SCRATCH_SIZE;
    m_dwStateSizeToCommit = 0;

}

CMcpxGPDspManager::~CMcpxGPDspManager()
{
    DELETE(m_pScratchDma);
    DELETE(m_pDspImage);
#ifndef MCPX_BOOT_LIB
    DELETE(m_pFxDescriptor);
#endif
}

VOID   
CMcpxGPDspManager::Initialize()
{
    //
    // create the dsp table class that holds the code for all effects + loader
    //

    m_pDspImage = NEW(CMcpxDspImage());
    ASSERT(m_pDspImage);

    m_pDspImage->Initialize();

    //
    // allocate the scratch Dma, telling it we are the GP
    //

    m_pScratchDma = NEW(CMcpxDspScratchDma(TRUE));
    ASSERT(m_pScratchDma);

    //
    // initialize scratch space handler
    //

    m_pScratchDma->Initialize(MCPX_HW_AC3_NUM_INPUT_PAGES+MCPX_HW_MULTIPASS_NUM_PAGES+MCPX_HW_MAX_FX_SCRATCH_PAGES);
    
    if (!m_pScratchDma)
    {
        ASSERT(FALSE && "CMcpxDspManager::Initialize - one of the objects could not be constructed\n");
        return;
    }
    
    ULONG uOffset = 0;

    ASSERT(m_pDspImage->GetLoaderSize() < DSP_COMMANDBLOCK_SCRATCHOFFSET);

    //
    // load a default exec program to get the GP pumping data to system memory
    //
    
    m_pScratchDma->Copy(uOffset,
                        (VOID *)m_pDspImage->GetLoader(),
                        m_pDspImage->GetLoaderSize());

    return ;

}

HRESULT CMcpxGPDspManager::DownloadEffectsImage
(
    LPCVOID                 pvImageBuffer, 
    DWORD                   dwImageSize,
    LPDSEFFECTIMAGEDESC *   ppImageDesc
)
{

    HRESULT hr = DS_OK;
#ifndef MCPX_BOOT_LIB

    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;

    //
    // do some basic validation of the image
    // this should be the image generated by our XPS2 tool..
    //

    ASSERT(dwImageSize > (DSP_COMMANDBLOCK_SCRATCHOFFSET + sizeof(HOST_TO_DSP_COMMANDBLOCK)));

    //
    // verify that command block is preset for instructing the DSP to download new
    // code and state
    //

    pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)pvImageBuffer + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    ASSERT(pCmdBlock->dwCommandFlags & BIT_H2DCB_COMMAND_LOAD_CODE);
    ASSERT(pCmdBlock->dwCommandFlags & BIT_H2DCB_COMMAND_LOAD_XRAM_STATE);

    ASSERT(dwImageSize <= MCPX_GLOBAL_PROC_SCRATCH_SIZE);

    //
    // proceed to copy the buffer they passed us into offset 0 of scratch memory
    // first zero out the flags in the command block so the dsp does not attempt
    // to download yet
    //

    PHOST_TO_DSP_COMMANDBLOCK pPrivateCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);
    memset(pPrivateCmdBlock,0,sizeof(HOST_TO_DSP_COMMANDBLOCK));

    //
    // copy their image into two parts: 1st part is the command block, second is the rest
    // we dont copy the flags since we want them 0 in the scratch image
    //

    pPrivateCmdBlock->dwOffset = pCmdBlock->dwOffset;
    pPrivateCmdBlock->dwCodeLength = pCmdBlock->dwCodeLength;
    pPrivateCmdBlock->dwStateOffset = pCmdBlock->dwStateOffset;
    pPrivateCmdBlock->dwStateLength = pCmdBlock->dwStateLength;
    pPrivateCmdBlock->dwDspStatus = pCmdBlock->dwDspStatus;

    m_pScratchDma->Copy(DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK),
                        (PUCHAR)pCmdBlock+sizeof(HOST_TO_DSP_COMMANDBLOCK),
                        dwImageSize - DSP_COMMANDBLOCK_SCRATCHOFFSET - sizeof(HOST_TO_DSP_COMMANDBLOCK));

    //
    // parse FX description array, to be used by the SetEffectData api
    //

    hr = ParseEffectImageInfo(pvImageBuffer);
    if (FAILED(hr)){
        return hr;
    }

    if(ppImageDesc) {
        *ppImageDesc = m_pFxDescriptor;
    }

    //
    // we need to keep a cached version of the command block associated with this image
    // We do this so if the user calls SetEffectData and then a delta panic occurs,
    // we can restore the command block and re-download the original code from the
    // correct offset
    //

    memcpy(&m_InitialCmdBlock,pPrivateCmdBlock,sizeof(m_InitialCmdBlock));

#endif //MCPX_BOOT_LIB

    return hr;


}

VOID CMcpxGPDspManager::RestoreCommandBlock() 
{

    PHOST_TO_DSP_COMMANDBLOCK pPrivateCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    pPrivateCmdBlock->dwCommandFlags = 0;
    memcpy(pPrivateCmdBlock,&m_InitialCmdBlock,sizeof(m_InitialCmdBlock));

}

HRESULT CMcpxGPDspManager::ParseEffectImageInfo(LPCVOID pScratchImage)
{
    DWORD dwValue;
    HRESULT hr = S_OK;

#ifndef MCPX_BOOT_LIB

    //
    // retrieve and cache the FX description array
    // We will use it later when the game calls the UpdateEffectParameters API
    //

    LPDSEFFECTIMAGEDESC pDescriptor;
    UCHAR szKey[8];
    int err;
    DWORD dwFxScratchSize = 0;

    PUCHAR pCodeBlock;
    PUCHAR pKeyBlock;

    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    pDescriptor = (LPDSEFFECTIMAGEDESC) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() +
        DSP_COMMANDBLOCK_SCRATCHOFFSET +\
        sizeof(HOST_TO_DSP_COMMANDBLOCK) +\
        (pCmdBlock->dwCodeLength*sizeof(DWORD)) +\
        (pCmdBlock->dwStateLength*sizeof(DWORD)) );


	//
	// initialize descriptor
	//

	DWORD dwDescriptorSize = sizeof(DSEFFECTIMAGEDESC) + 
		sizeof(DSEFFECTMAP)*(pDescriptor->dwEffectCount-1);


    if (m_pFxDescriptor != NULL) {

        DELETE(m_pFxDescriptor);
        
    }

    m_pFxDescriptor = (LPDSEFFECTIMAGEDESC) NEW(BYTE[dwDescriptorSize]);

    if (m_pFxDescriptor == NULL) {
        return E_OUTOFMEMORY;
    }

    //
    // check the scratch space usage for the FX chain
    // adjust our ram allocation if required
    //

    if (FAILED(hr = m_pScratchDma->AdjustFxScratch(pDescriptor->dwTotalScratchSize))){
        return hr;
    }

    //
    // we will have to decode the dsp code words since each one
    // is encrypted, using a different dsp dev supplied key.
    // we do in-place decryption
    //

    pCodeBlock = (PUCHAR)pCmdBlock + sizeof(HOST_TO_DSP_COMMANDBLOCK);
    pKeyBlock = (PUCHAR)pDescriptor + dwDescriptorSize;

    //
    // decode keys used to encrypt block
    //

	XAudiopUtility_GenerateKey(szKey);

	err = XAudiopUtility_Decode(szKey,
		pKeyBlock,
		KEY_SIZE*pDescriptor->dwEffectCount,
		pKeyBlock,
		FALSE);
	
    hr = HRESULT_FROM_WIN32(err);
    if (FAILED(hr)) {
        DPF_ERROR("Keyblock decode failed with hr = %x",hr);
        return hr;
    }

    //
    // we need to convert all offsets in FX description elements
    // from relative (the tool creates relative offsets) to absolute
    // This way the caller can treat the LPVOIDs into State, Ymem, Code
    // as normal virtual memory pointers. 
    //

    for (ULONG i=0;i<pDescriptor->dwEffectCount;i++) {

        //
        // decode key block in place using appropriate key
        //

        err = XAudiopUtility_Decode((pKeyBlock+i*KEY_SIZE),
            pCodeBlock,
            pDescriptor->aEffectMaps[i].dwCodeSize,
            pCodeBlock,
            FALSE);
        
        hr = HRESULT_FROM_WIN32(err);
        if (FAILED(hr)) {
            DPF_ERROR("code block decode failed with hr = %x",hr);
            return hr;
        }

        pCodeBlock += pDescriptor->aEffectMaps[i].dwCodeSize;

        //
        // convert code first
        //

        dwValue = (DWORD) pDescriptor->aEffectMaps[i].lpvCodeSegment;

        //
        // create a P-memory absolute address in bytes
        //

        dwValue -= (DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK));

        //
        // the fx start after the default engine P-words
        //

        dwValue += m_pDspImage->GetLoaderSize();

        //
        // convert P-memory address to a MCPX base register space address
        //

        dwValue += MCPX_HW_GPPMEM_REG_OFFSET;

        pDescriptor->aEffectMaps[i].lpvCodeSegment = (LPVOID)dwValue;

        //
        // do the same for Y memory. The tool creates absolute Ymem addresses
        // so all we need to do is add the register space offset
        //

        dwValue = (DWORD) pDescriptor->aEffectMaps[i].lpvYMemorySegment;

        //
        // convert Y-memory address to a MCPX base register space address
        //

        dwValue += MCPX_HW_GPYMEM_REG_OFFSET;
        pDescriptor->aEffectMaps[i].lpvYMemorySegment = (LPVOID)dwValue;

        //
        // now convert X-memory relative address
        //

        dwValue = (DWORD) pDescriptor->aEffectMaps[i].lpvStateSegment;

        //
        // create a X-memory absolute address in bytes
        //

        dwValue -= (DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK));
        dwValue -= pCmdBlock->dwCodeLength*sizeof(DWORD);
        dwValue += DSP_FX_STATE_XMEMORY_BASE_OFFSET;

        //
        // convert X-memory address to a MCPX base register space address
        //

        dwValue += MCPX_HW_GPXMEM_REG_OFFSET;
        pDescriptor->aEffectMaps[i].lpvStateSegment = (LPVOID)dwValue;

        //
        // finally fixup scratch space offset to point to a real VA, not
        // just a relative scratch offset
        //

        dwValue = (DWORD)pDescriptor->aEffectMaps[i].lpvScratchSegment;
        dwValue += (DWORD) m_pScratchDma->GetFxScratchSpaceLinAddr();

        //
        // subtract the fx delay line base offset
        //

        dwValue -= DSP_FX_DELAY_DATA_SCRATCHOFFSET;

        pDescriptor->aEffectMaps[i].lpvScratchSegment = (LPVOID) dwValue;
        
    }

    memcpy(m_pFxDescriptor,pDescriptor,dwDescriptorSize);

    //
    // the dsp will automagically DMA in the new FX dsp code and state when its done with the
    // current 32 sample block processing...
    //

    pCmdBlock->dwCommandFlags = BIT_H2DCB_COMMAND_LOAD_CODE | BIT_H2DCB_COMMAND_LOAD_XRAM_STATE;

    volatile DWORD *pdwflags = &pCmdBlock->dwCommandFlags;
    while(*pdwflags != 0);

#endif // MCPX_BOOT_LIB

    return S_OK;

}


HRESULT
CMcpxGPDspManager::SetEffectData
(
    DWORD                   dwEffectIndex, 
    DWORD                   dwOffset, 
    LPCVOID                 pvData, 
    DWORD                   dwDataSize,
    DWORD                   dwFlags
)
{
    LPCDSEFFECTMAP pFxDesc;
    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;
    DWORD dwScratchOffset;
    LPVOID pvXramBuffer;
    HRESULT hr;

    ASSERT(dwDataSize >= sizeof(DWORD));

    //
    // FX offset and size must be dword aligned
    //

    ASSERT(!(dwDataSize & 0x00000003));
    ASSERT(!(dwOffset & 0x00000003));

    //
    // get effect map
    //

    hr = GetEffectMap(dwEffectIndex, &pFxDesc);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // validate fx specific parameters
    //

    ASSERT(pFxDesc->dwStateSize >= (dwOffset+dwDataSize));

    //
    // copy in the data they want to update
    // figure a scratch offset, from the mcpx base register space offset
    //

    pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    //
    // we reverse-engineer the scratch offset we stomped on in SetFxDescriptor..
    // needless to say this is magic so if you plan to change make sure you change
    // xgpimage AND SetFxDescriptor correctly as well
    //

    dwScratchOffset = (DWORD)pFxDesc->lpvStateSegment;
    dwScratchOffset -= MCPX_HW_GPXMEM_REG_OFFSET;
    dwScratchOffset -= DSP_FX_STATE_XMEMORY_BASE_OFFSET;
    dwScratchOffset += (DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK));
    dwScratchOffset += pCmdBlock->dwCodeLength*sizeof(DWORD);

    dwScratchOffset += dwOffset;
       
    //
    // copy in the data they want to update
    //

    m_pScratchDma->Copy(dwScratchOffset,
                        (PVOID)pvData,
                        dwDataSize);

    if (dwFlags & DSFX_DEFERRED) {        

        //
        // based on where the offset they are updating is, we might have to update
        // our scratch image to deal with sparse memory pokes. If somebody calls
        // SetEffectData(FALSE) twice but the two memory blocks they are updating are
        // non-contigious, we need to fill in the in between memory with latest state
        // from the dsp. Then at commit time, we can commit one big block all at once
        //

        if (m_dwCurrentLowestScratchOffset != MCPX_GLOBAL_PROC_SCRATCH_SIZE) {

            //
            // this is not the first deferred SetEffectData command
            // so we can go ahead and do the sparse checks
            //

            if ((m_dwCurrentLowestScratchOffset+m_dwStateSizeToCommit) < dwScratchOffset) {
    
                //
                // sparse update, on the high end...
                //
    
                dwDataSize += dwScratchOffset - (m_dwCurrentLowestScratchOffset+m_dwStateSizeToCommit);
    
            } else if (m_dwCurrentLowestScratchOffset > (dwScratchOffset+dwDataSize)){
    
                //
                // sparse update below the last block updated
                //
    
                dwDataSize += m_dwCurrentLowestScratchOffset-(dwScratchOffset+dwDataSize);
    
            }

        }

        m_dwCurrentLowestScratchOffset = min(m_dwCurrentLowestScratchOffset,dwScratchOffset);
        m_dwStateSizeToCommit += dwDataSize;

    } else {

        //
        // if they want to commit now, poke directly the XRAM offset
        //

        pvXramBuffer = (LPVOID) ((DWORD)pFxDesc->lpvStateSegment + dwOffset);
        memcpy(pvXramBuffer,pvData,dwDataSize);
    }

    return DS_OK;

}


HRESULT
CMcpxGPDspManager::GetEffectData
(
    DWORD                   dwEffectIndex, 
    DWORD                   dwOffset, 
    LPVOID                  pvData, 
    DWORD                   dwDataSize
)
{
    LPCDSEFFECTMAP pFxDesc;
    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;
    DWORD dwScratchOffset;
    LPVOID pvXramBuffer;
    HRESULT hr;

    ASSERT(dwDataSize >= sizeof(DWORD));

    //
    // FX offset and size must be dword aligned
    //

    ASSERT(!(dwDataSize & 0x00000003));
    ASSERT(!(dwOffset & 0x00000003));

    //
    // get effect map
    //

    hr = GetEffectMap(dwEffectIndex, &pFxDesc);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // validate fx specific parameters
    //

    ASSERT(pFxDesc->dwStateSize >= (dwOffset+dwDataSize));

    //
    // copy fx data
    //

    pvXramBuffer = (LPVOID) ((DWORD)pFxDesc->lpvStateSegment + dwOffset);
    memcpy(pvData,pvXramBuffer,dwDataSize);

    return DS_OK;

}


HRESULT
CMcpxGPDspManager::GetEffectMap
(
    DWORD                   dwEffectIndex, 
    LPCDSEFFECTMAP *        ppEffectMap
)
{
    DSEFFECTIMAGEDESC* pDescriptor = m_pFxDescriptor;

    ASSERT(pDescriptor);
    ASSERT(ppEffectMap);

    //
    // validate params
    //

    if (dwEffectIndex > pDescriptor->dwEffectCount-1) {

        DPF_ERROR("Zero-based Effect Index (%d) is larger than number of Effects (%d) currently loaded in DSP",
                  dwEffectIndex,
                  pDescriptor->dwEffectCount-1);

        return DSERR_INVALIDCALL;

    }

    //
    // retrieve the effect they want to modify
    //

    *ppEffectMap = &pDescriptor->aEffectMaps[dwEffectIndex];

    return DS_OK;
}


VOID
CMcpxGPDspManager::CommitChanges(DWORD dwScratchOffset,DWORD dwDataSize)
{

    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;

    if (dwDataSize == 0) {

        //
        // use internal members for deferred state update
        //

        dwDataSize = m_dwStateSizeToCommit;
        dwScratchOffset = m_dwCurrentLowestScratchOffset;

        if ((dwScratchOffset == MCPX_GLOBAL_PROC_SCRATCH_SIZE) ||
            (dwDataSize == 0)) {

            //
            // no changes to commit
            //

            DPF_WARNING("CommitEffectData was called but there were no deferred changes!!");
            return;

        }
    }


    //
    // the caller wants to update internal DSP state with this call
    // set up the command block, to signal the DSP to DMA in the new state
    //

    pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    //
    // before we go stomping on the existing command block
    // make sure there is no other pending command
    //

    volatile DWORD *pdwflags = &pCmdBlock->dwCommandFlags;
    while(*pdwflags != 0);

    //
    // create xram offset
    // the original base offset can be calculated from the code size
    // the DSP default engine will add this offset to the base offset where the concatenated state blocks live
    //

    
    pCmdBlock->dwOffset = dwScratchOffset/sizeof(DWORD) - 
        (pCmdBlock->dwCodeLength+sizeof(HOST_TO_DSP_COMMANDBLOCK)/sizeof(DWORD)) -
        (DSP_COMMANDBLOCK_SCRATCHOFFSET/sizeof(DWORD));

    pCmdBlock->dwStateOffset = dwScratchOffset;
    pCmdBlock->dwStateLength = dwDataSize/sizeof(DWORD);

    pCmdBlock->dwCommandFlags = BIT_H2DCB_COMMAND_LOAD_XRAM_STATE;

    //
    // set internal member to signal deferred state updates have been flushed
    //

    m_dwCurrentLowestScratchOffset = MCPX_GLOBAL_PROC_SCRATCH_SIZE;
    m_dwStateSizeToCommit = 0;

}

VOID
CMcpxGPDspManager::AC3SetOutputBuffer(PMCPX_ALLOC_CONTEXT pMem, ULONG uNumOfPages)
{
    //
    // we need to add these pages to the GP dma table
    //

    m_pScratchDma->AddPages(pMem, uNumOfPages, &m_uAC3BufferOffset);

    return;
}

VOID
CMcpxGPDspManager::SetMultipassBuffer(PMCPX_ALLOC_CONTEXT pMem, ULONG uNumOfPages)
{
    //
    // we need to add these pages to the GP dma table
    //

    m_pScratchDma->AddPages(pMem, uNumOfPages, &m_uMultipassBufferOffset);

    return;
}

