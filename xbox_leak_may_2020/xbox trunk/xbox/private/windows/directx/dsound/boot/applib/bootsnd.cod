; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	..\bootsnd.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
DSOUND_URW	SEGMENT PARA USE32 PUBLIC ''
DSOUND_URW	ENDS
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
DSOUND_RW	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RW	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IsEqualGUID@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _==@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT @InterlockedExchange@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _KeGetCurrentIrql@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _KeIsExecutingDpc@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_AddRef@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_Release@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Direct3D_GetAdapterCount@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_BeginScene@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_EndScene@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_GetRenderState@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_GetTextureStageState@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_SetRenderState@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DDevice_SetTextureStageState@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DResource_MoveResourceMemory@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DTexture_UnlockRect@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVolumeTexture_UnlockBox@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DCubeTexture_UnlockRect@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVertexBuffer_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DIndexBuffer_Lock@20
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DIndexBuffer_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DPalette_Unlock@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DSurface_UnlockRect@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _D3DVolume_UnlockBox@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _log10f@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _sqrtf@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@MMMMMMMMMMMMMMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXPLANE@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Release@IDirectSoundBuffer@@QAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Play@IDirectSoundBuffer@@QAGJKKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Stop@IDirectSoundBuffer@@QAGJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetStatus@IDirectSoundBuffer@@QAGJPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetBufferData@IDirectSoundBuffer@@QAGJPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _wmemchr@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?InsertTailList@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?InsertHeadList@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??2@YAPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??3@YAXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CIrql@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Raise@CIrql@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Lower@CIrql@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAutoIrql@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAutoIrql@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Save@CFpState@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Restore@CFpState@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAutoFpState@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAutoFpState@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?and@@YIXPCGG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?or@@YIXPCGG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CRefCount@DirectSound@@QAE@K@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCRefCount@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CRefCount@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AddRef@CRefCount@DirectSound@@UAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Release@CRefCount@DirectSound@@UAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetDataOffset@CRiffChunk@WaveLoader@@QAEKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetDuration@CWaveFile@WaveLoader@@QAEJPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetFormat@CWaveFile@WaveLoader@@QAEJPAPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?FloatToLong@Math@DirectSound@@YGJM@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?lsb@Math@DirectSound@@YIII@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreateMarker@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAU3@GGPAU_LIST_ENTRY@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreateMarker@CMcpxSlopMemoryHeap@DirectSound@@IAEPAUSLOPRUNMARKER@@PAXKPAU_LIST_ENTRY@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister8@CAc97Device@DirectSound@@KGEK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister8@CAc97Device@DirectSound@@KGXKE@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister16@CAc97Device@DirectSound@@KGGK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister16@CAc97Device@DirectSound@@KGXKG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekRegister32@CAc97Device@DirectSound@@KGKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeRegister32@CAc97Device@DirectSound@@KGXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister8@CAc97Device@DirectSound@@KGEK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister8@CAc97Device@DirectSound@@KGXKE@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister16@CAc97Device@DirectSound@@KGGK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister16@CAc97Device@DirectSound@@KGXKG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister32@CAc97Device@DirectSound@@KGKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister32@CAc97Device@DirectSound@@KGXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?WaitRegisterRetry@CAc97Device@DirectSound@@KGXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AciInterruptServiceRoutine@CAc97Device@DirectSound@@CGEPAU_KINTERRUPT@@PAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AciInterruptDpcHandler@CAc97Device@DirectSound@@CGXPAU_KDPC@@PAX11@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AciShutdownNotifier@CAc97Device@DirectSound@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AciSynchronizationRoutine@CAc97Device@DirectSound@@CGEPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ReleaseChannel@CAc97Device@DirectSound@@QAEXPAVCAc97Channel@2@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AttachPacket@CAc97Channel@DirectSound@@QAEXPBXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister8@CAc97Channel@DirectSound@@IAEEK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister8@CAc97Channel@DirectSound@@IAEXKE@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAciRegister16@CAc97Channel@DirectSound@@IAEGK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister16@CAc97Channel@DirectSound@@IAEXKG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAciRegister32@CAc97Channel@DirectSound@@IAEXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundEnterCriticalSection@@YGHXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundLeaveCriticalSection@@YGXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAutoLock@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAutoLock@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AddRef@CDirectSound@DirectSound@@UAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AddRef@CDirectSoundBuffer@DirectSound@@UAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Release@CDirectSoundBuffer@DirectSound@@UAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetFormat@CDirectSoundBuffer@DirectSound@@QAGJPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetFrequency@CDirectSoundBuffer@DirectSound@@QAGJK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetVolume@CDirectSoundBuffer@DirectSound@@QAGJJ@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetPitch@CDirectSoundBuffer@DirectSound@@QAGJJ@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetLFO@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSLFODESC@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetEG@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSENVELOPEDESC@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetFilter@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSFILTERDESC@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetHeadroom@CDirectSoundBuffer@DirectSound@@QAGJK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetOutputBuffer@CDirectSoundBuffer@DirectSound@@QAGJPAUIDirectSoundBuffer@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetMixBins@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSMIXBINS@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetMixBinVolumes@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSMIXBINS@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?RegisterCounters@CPerfMon@DirectSound@@SGXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?UnregisterCounters@CPerfMon@DirectSound@@SGXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetupDSPs@CMcpxCore@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CMcpxNotifier@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CMcpxNotifier@DirectSound@@QAEXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Free@CMcpxNotifier@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetStatus@CMcpxNotifier@DirectSound@@QAEHK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetStatus@CMcpxNotifier@DirectSound@@QAEXKH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Reset@CMcpxNotifier@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetScratchSpaceLinAddr@CMcpxDspScratchDma@DirectSound@@QAEPAXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CMcpxDspImage@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetLoader@CMcpxDspImage@DirectSound@@QAEPAXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetLoaderSize@CMcpxDspImage@DirectSound@@QAEKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetEffectData@CMcpxAPU@DirectSound@@QAEJKKPBXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetEffectData@CMcpxAPU@DirectSound@@QAEJKKPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CommitEffectData@CMcpxAPU@DirectSound@@QAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ApuInterruptServiceRoutine@CMcpxAPU@DirectSound@@CGEPAU_KINTERRUPT@@PAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ApuInterruptDpcRoutine@CMcpxAPU@DirectSound@@CGXPAU_KDPC@@PAX11@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DeferredCommandDpcRoutine@CMcpxAPU@DirectSound@@CGXPAU_KDPC@@PAX11@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ApuShutdownNotifier@CMcpxAPU@DirectSound@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DoWork@CMcpxAPU@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?BlockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?UnblockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ScheduleApuInterruptDpc@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CMcpxVoiceNotifier@DirectSound@@QAEXG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?BytesToSamples@CMcpxVoiceClient@DirectSound@@IAEKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SamplesToBytes@CMcpxVoiceClient@DirectSound@@IAEKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetSubMixDestination@CMcpxVoiceClient@DirectSound@@IAEPAVCMcpxBuffer@2@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CWaveFileMediaObject@DirectSound@@QAGJPBD@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CWaveFileMediaObject@DirectSound@@QAGJPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CFileMediaObject@DirectSound@@QAGJPBDKKKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CFileMediaObject@DirectSound@@QAGJPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?EndianSwapWord@@YIGG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?EndianSwapDword@@YIKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CStdFileStream@WaveLoader@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CStdFileStream@WaveLoader@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Close@CStdFileStream@WaveLoader@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CRiffChunk@WaveLoader@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CRiffChunk@WaveLoader@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CWaveFile@WaveLoader@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CWaveFile@WaveLoader@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Close@CWaveFile@WaveLoader@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CImaAdpcmCodec@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CImaAdpcmCodec@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_QueryInterfaceC@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_QueryInterface@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_SetCooperativeLevel@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_Compact@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_AddRef@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_Release@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_GetCaps@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_CreateSoundBuffer@16
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_GetSpeakerConfig@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_GetEffectData@20
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_SetEffectData@24
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_CommitEffectData@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_SetMixBinHeadroom@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_GetTime@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSound_GetOutputLevels@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_QueryInterface@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_QueryInterfaceC@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_Unlock@20
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_Restore@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_AddRef@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_Release@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetFormat@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetFrequency@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetVolume@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetPitch@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetLFO@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetEG@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetFilter@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetHeadroom@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetOutputBuffer@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetMixBins@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetMixBinVolumes@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_Play@16
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_PlayEx@16
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_Stop@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_StopEx@16
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetPlayRegion@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetLoopRegion@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_GetStatus@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_GetCurrentPosition@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetCurrentPosition@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetBufferData@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_Lock@32
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_SetNotificationPositions@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DirectSoundCreateInternal@@YGJPAPAVCDirectSound@DirectSound@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _DirectSoundCreate@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _DirectSoundCreateBuffer@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _DirectSoundDoWork@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _DirectSoundGetSampleTime@0
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _XAudioCalculatePitch@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _XAudioCreatePcmFormat@16
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _XAudioCreateAdpcmFormat@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _XWaveFileCreateMediaObject@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _XWaveFileCreateMediaObjectEx@12
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _XFileCreateMediaObject@24
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _XFileCreateMediaObjectEx@8
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _Ac97CreateMediaObject@16
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _DirectSoundDumpMemoryUsage@4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CDirectSoundSettings@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCDirectSoundSettings@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CDirectSoundSettings@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetEffectImageLocations@CDirectSoundSettings@DirectSound@@QAEXPBU_DSEFFECTIMAGELOC@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CDirectSound@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCDirectSound@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CDirectSound@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Release@CDirectSound@DirectSound@@UAGKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CDirectSound@DirectSound@@QAGJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetCaps@CDirectSound@DirectSound@@QAGJPAU_DSCAPS@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreateSoundBuffer@CDirectSound@DirectSound@@QAGJPBU_DSBUFFERDESC@@PAPAUIDirectSoundBuffer@@PAUIUnknown@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetSpeakerConfig@CDirectSound@DirectSound@@QAGJPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetEffectData@CDirectSound@DirectSound@@QAGJKKPBXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetEffectData@CDirectSound@DirectSound@@QAGJKKPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CommitEffectData@CDirectSound@DirectSound@@QAGJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetMixBinHeadroom@CDirectSound@DirectSound@@QAGJKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetTime@CDirectSound@DirectSound@@QAGJPA_J@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetOutputLevels@CDirectSound@DirectSound@@QAGJPAU_DSOUTPUTLEVELS@@H@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DoWork@CDirectSound@DirectSound@@QAGXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CDirectSoundVoiceSettings@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCDirectSoundVoiceSettings@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CDirectSoundVoiceSettings@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CDirectSoundVoiceSettings@DirectSound@@QAEJKPBUtWAVEFORMATEX@@PBU_DSMIXBINS@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetFormat@CDirectSoundVoiceSettings@DirectSound@@QAEHPBUtWAVEFORMATEX@@H@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetVolume@CDirectSoundVoiceSettings@DirectSound@@QAEXJ@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetMixBinVolumes@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetHeadroom@CDirectSoundVoiceSettings@DirectSound@@QAEXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetMixBins@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetOutputBuffer@CDirectSoundVoiceSettings@DirectSound@@QAEXPAVCDirectSoundBuffer@2@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CDirectSoundVoice@DirectSound@@QAE@PAVCDirectSound@1@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCDirectSoundVoice@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CDirectSoundVoice@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CDirectSoundVoice@DirectSound@@QAGXPAVCMcpxVoiceClient@2@PAVCDirectSoundVoiceSettings@2@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetFormat@CDirectSoundVoice@DirectSound@@QAGJPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetFrequency@CDirectSoundVoice@DirectSound@@QAGJK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetPitch@CDirectSoundVoice@DirectSound@@QAGJJ@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetVolume@CDirectSoundVoice@DirectSound@@QAGJJ@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetLFO@CDirectSoundVoice@DirectSound@@QAGJPBU_DSLFODESC@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetEG@CDirectSoundVoice@DirectSound@@QAGJPBU_DSENVELOPEDESC@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetFilter@CDirectSoundVoice@DirectSound@@QAGJPBU_DSFILTERDESC@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetHeadroom@CDirectSoundVoice@DirectSound@@QAGJK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetOutputBuffer@CDirectSoundVoice@DirectSound@@QAGJPAUIDirectSoundBuffer@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetMixBins@CDirectSoundVoice@DirectSound@@QAGJPBU_DSMIXBINS@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetMixBinVolumes@CDirectSoundVoice@DirectSound@@QAGJPBU_DSMIXBINS@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CDirectSoundBufferSettings@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCDirectSoundBufferSettings@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CDirectSoundBufferSettings@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CDirectSoundBufferSettings@DirectSound@@QAEJPBU_DSBUFFERDESC@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetBufferData@CDirectSoundBufferSettings@DirectSound@@QAEJPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetPlayRegion@CDirectSoundBufferSettings@DirectSound@@QAEXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetLoopRegion@CDirectSoundBufferSettings@DirectSound@@QAEXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetNotificationPositions@CDirectSoundBufferSettings@DirectSound@@QAEJKPBU_DSBPOSITIONNOTIFY@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CDirectSoundBuffer@DirectSound@@QAE@PAVCDirectSound@1@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCDirectSoundBuffer@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CDirectSoundBuffer@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSBUFFERDESC@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetBufferData@CDirectSoundBuffer@DirectSound@@QAGJPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Play@CDirectSoundBuffer@DirectSound@@QAGJKKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PlayEx@CDirectSoundBuffer@DirectSound@@QAGJ_JK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Stop@CDirectSoundBuffer@DirectSound@@QAGJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?StopEx@CDirectSoundBuffer@DirectSound@@QAGJ_JK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetStatus@CDirectSoundBuffer@DirectSound@@QAGJPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetPlayRegion@CDirectSoundBuffer@DirectSound@@QAGJKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetLoopRegion@CDirectSoundBuffer@DirectSound@@QAGJKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetCurrentPosition@CDirectSoundBuffer@DirectSound@@QAGJPAK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Lock@CDirectSoundBuffer@DirectSound@@QAGJKKPAPAXPAK01K@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetCurrentPosition@CDirectSoundBuffer@DirectSound@@QAGJK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetNotificationPositions@CDirectSoundBuffer@DirectSound@@QAGJKPBU_DSBPOSITIONNOTIFY@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CMcpxBuffer@DirectSound@@QAE@PAVCMcpxAPU@1@PAVCDirectSoundBufferSettings@1@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCMcpxBuffer@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CMcpxBuffer@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CMcpxBuffer@DirectSound@@QAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetBufferData@CMcpxBuffer@DirectSound@@QAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ReleaseBufferData@CMcpxBuffer@DirectSound@@QAEJH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AllocateBufferResources@CMcpxBuffer@DirectSound@@IAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ReleaseBufferResources@CMcpxBuffer@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MapInputBuffer@CMcpxBuffer@DirectSound@@IAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MapEffectsBuffer@CMcpxBuffer@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MapBuffer@CMcpxBuffer@DirectSound@@IAEXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?UnmapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Play@CMcpxBuffer@DirectSound@@QAEJ_JK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Play@CMcpxBuffer@DirectSound@@QAEJK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PlayFromCurrent@CMcpxBuffer@DirectSound@@IAEXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PlayFromPosition@CMcpxBuffer@DirectSound@@IAEXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetPlayRegion@CMcpxBuffer@DirectSound@@QAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetLoopRegion@CMcpxBuffer@DirectSound@@QAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Stop@CMcpxBuffer@DirectSound@@QAEJ_JK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Stop@CMcpxBuffer@DirectSound@@QAEJK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetStatus@CMcpxBuffer@DirectSound@@QAEJPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetCurrentPosition@CMcpxBuffer@DirectSound@@QAEJPAK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetCurrentPosition@CMcpxBuffer@DirectSound@@QAEJK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ServiceVoiceInterrupt@CMcpxBuffer@DirectSound@@MAEHXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetNotificationPositions@CMcpxBuffer@DirectSound@@QAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?OnPositionDelta@CMcpxBuffer@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?NotifyToPosition@CMcpxBuffer@DirectSound@@IAEXKH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?NotifyStop@CMcpxBuffer@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ScheduleDeferredCommand@CMcpxBuffer@DirectSound@@MAEHK_JK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?RemoveDeferredCommand@CMcpxBuffer@DirectSound@@MAEXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ServiceDeferredCommand@CMcpxBuffer@DirectSound@@MAEXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?OnDeferredTerminate@CMcpxBuffer@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CMcpxAPU@DirectSound@@QAE@PAVCDirectSoundSettings@1@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCMcpxAPU@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CMcpxAPU@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CMcpxAPU@DirectSound@@QAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Terminate@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AllocateVoices@CMcpxAPU@DirectSound@@QAEJPAVCMcpxVoiceClient@2@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?FreeVoices@CMcpxAPU@DirectSound@@QAEXPAVCMcpxVoiceClient@2@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ServiceApuInterrupt@CMcpxAPU@DirectSound@@IAEHXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?WaitForMagicWrite@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ServiceApuInterruptDpc@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ServiceVoiceInterrupt@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetInterruptStatusCallback@CMcpxAPU@DirectSound@@CGEPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?HandleFETrap@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?HandleSoftwareMethod@CMcpxAPU@DirectSound@@IAEXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?HandleIdleVoice@CMcpxAPU@DirectSound@@IAEXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ScheduleDeferredCommand@CMcpxAPU@DirectSound@@QAEHPAUMCPX_DEFERRED_COMMAND@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ScheduleDeferredCommandHigh@CMcpxAPU@DirectSound@@IAEHPAUMCPX_DEFERRED_COMMAND@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ScheduleDeferredCommandLow@CMcpxAPU@DirectSound@@IAEHPAUMCPX_DEFERRED_COMMAND@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?RemoveDeferredCommand@CMcpxAPU@DirectSound@@QAEXPAUMCPX_DEFERRED_COMMAND@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?RemoveDeferredCommandHigh@CMcpxAPU@DirectSound@@IAEXPAUMCPX_DEFERRED_COMMAND@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?RemoveDeferredCommandLow@CMcpxAPU@DirectSound@@IAEXPAUMCPX_DEFERRED_COMMAND@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ServiceDeferredCommandsHigh@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ServiceDeferredCommandsLow@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetHrtfHeadroom@CMcpxAPU@DirectSound@@QAEJK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetMixBinHeadroom@CMcpxAPU@DirectSound@@QAEJK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CMcpxVoiceClient@DirectSound@@QAE@PAVCMcpxAPU@1@PAVCDirectSoundVoiceSettings@1@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCMcpxVoiceClient@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CMcpxVoiceNotifier@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CMcpxVoiceClient@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CMcpxVoiceClient@DirectSound@@UAEJH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetFormat@CMcpxVoiceClient@DirectSound@@UAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AllocateVoiceResources@CMcpxVoiceClient@DirectSound@@IAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ReleaseVoiceResources@CMcpxVoiceClient@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetMixBins@CMcpxVoiceClient@DirectSound@@QAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ConvertMixBinValues@CMcpxVoiceClient@DirectSound@@IAEXPAK0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetVolume@CMcpxVoiceClient@DirectSound@@QAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ConvertVolumeValues@CMcpxVoiceClient@DirectSound@@IAEXPAUMCPX_VOICE_VOLUME@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetPitch@CMcpxVoiceClient@DirectSound@@QAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ConvertPitchValue@CMcpxVoiceClient@DirectSound@@IAEXPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetAntecedentVoice@CMcpxVoiceClient@DirectSound@@AAEXPAEPAPAV12@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ActivateVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DeactivateVoice@CMcpxVoiceClient@DirectSound@@IAEXH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?RemoveStuckVoice@CMcpxVoiceClient@DirectSound@@AAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ReleaseVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?WaitForVoiceOff@CMcpxVoiceClient@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CheckStuckVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PauseVoice@CMcpxVoiceClient@DirectSound@@IAEXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetLFO@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSLFODESC@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetEG@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSENVELOPEDESC@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetFilter@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSFILTERDESC@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ConnectVoice@CMcpxVoiceClient@DirectSound@@QAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DisconnectVoice@CMcpxVoiceClient@DirectSound@@QAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetSslPosition@CMcpxVoiceClient@DirectSound@@IAEKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CMcpxCore@DirectSound@@QAE@PAVCDirectSoundSettings@1@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCMcpxCore@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CMcpxCore@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCMcpxGPDspManager@DirectSound@@QAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CMcpxCore@DirectSound@@QAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Reset@CMcpxCore@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetupFrontEndProcessor@CMcpxCore@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AllocateApuMemory@CMcpxCore@DirectSound@@IAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetupVoiceProcessor@CMcpxCore@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetupGlobalProcessor@CMcpxCore@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetupAc97@CMcpxCore@DirectSound@@IAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetInterruptState@CMcpxCore@DirectSound@@IAEXH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetPrivLockState@CMcpxCore@DirectSound@@IAEXH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetFrontEndState@CMcpxCore@DirectSound@@IAEXW4MCPX_FE_STATE@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetSetupEngineState@CMcpxCore@DirectSound@@IAEXW4MCPX_SE_STATE@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetPhysicalMemoryProperties@CMcpxCore@DirectSound@@SGKPAXKPAK1@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MapTransfer@CMcpxCore@DirectSound@@SGKPAPAXPAK1@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AllocateContext@CMcpxCore@DirectSound@@SGJPAUMCPX_ALLOC_CONTEXT@@KK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?IdleVoiceProcessor@CMcpxCore@DirectSound@@QAEHH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CMcpxDspScratchDma@DirectSound@@QAE@H@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CMcpxDspScratchDma@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CMcpxDspScratchDma@DirectSound@@QAEXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AddPages@CMcpxDspScratchDma@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@KPAK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Copy@CMcpxDspScratchDma@DirectSound@@QAEXKPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AdjustFxScratch@CMcpxDspScratchDma@DirectSound@@QAEJK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CMcpxDspImage@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CMcpxGPDspManager@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CMcpxGPDspManager@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCMcpxDspScratchDma@DirectSound@@QAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CMcpxGPDspManager@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?DownloadEffectsImage@CMcpxGPDspManager@DirectSound@@QAEJPBXKPAPAU_DSEFFECTIMAGEDESC@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?RestoreCommandBlock@CMcpxGPDspManager@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ParseEffectImageInfo@CMcpxGPDspManager@DirectSound@@IAEJPBX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetEffectData@CMcpxGPDspManager@DirectSound@@QAEJKKPBXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetEffectData@CMcpxGPDspManager@DirectSound@@QAEJKKPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetEffectMap@CMcpxGPDspManager@DirectSound@@QAEJKPAPBU_DSEFFECTMAP@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CommitChanges@CMcpxGPDspManager@DirectSound@@QAEXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AC3SetOutputBuffer@CMcpxGPDspManager@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@K@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetMultipassBuffer@CMcpxGPDspManager@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@K@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _$E2
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT _$E4
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CMcpxBufferSgeHeap@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCMcpxBufferSgeHeap@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CMcpxBufferSgeHeap@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CMcpxBufferSgeHeap@DirectSound@@QAEJG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Alloc@CMcpxBufferSgeHeap@DirectSound@@QAEPAUSGEHEAPRUNMARKER@@PAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Free@CMcpxBufferSgeHeap@DirectSound@@QAEXPAUSGEHEAPRUNMARKER@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AllocRun@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAXG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?FreeRun@CMcpxBufferSgeHeap@DirectSound@@IAEXPAUSGEHEAPRUNMARKER@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CoalesceRuns@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAU3@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?MapBuffer@CMcpxBufferSgeHeap@DirectSound@@KGXKPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?UnmapBuffer@CMcpxBufferSgeHeap@DirectSound@@KGXPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CMcpxSlopMemoryHeap@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCMcpxSlopMemoryHeap@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CMcpxSlopMemoryHeap@DirectSound@@UAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AddRun@CMcpxSlopMemoryHeap@DirectSound@@QAEHPAXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Alloc@CMcpxSlopMemoryHeap@DirectSound@@QAEPAXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Free@CMcpxSlopMemoryHeap@DirectSound@@QAEXPAX@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CoalesceRuns@CMcpxSlopMemoryHeap@DirectSound@@IAEPAUSLOPRUNMARKER@@PAU3@0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAc97Device@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAc97Device@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CAc97Device@DirectSound@@QAEJK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Terminate@CAc97Device@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CreateChannel@CAc97Device@DirectSound@@QAEJW4AC97CHANNELTYPE@@PAPAVCAc97Channel@2@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ReleaseChannel@CAc97Device@DirectSound@@QAEXW4AC97CHANNELTYPE@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_GCAc97Channel@DirectSound@@QAEPAXI@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AcquireCodecSemaphore@CAc97Device@DirectSound@@KGHXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?CodecReady@CAc97Device@DirectSound@@IAEHXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?GetInterruptStatus@CAc97Device@DirectSound@@IAEKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ServiceAciInterrupt@CAc97Device@DirectSound@@IAEKXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ServiceAciInterruptDpc@CAc97Device@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SynchronizeAciInterrupt@CAc97Device@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PeekAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@PAG@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PokeAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@G@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?VerifyPokeAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@G@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?PowerUp@CAc97Device@DirectSound@@IAEJXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??0CAc97Channel@DirectSound@@QAE@PAVCAc97Device@1@W4AC97CHANNELTYPE@@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??1CAc97Channel@DirectSound@@QAE@XZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Initialize@CAc97Channel@DirectSound@@QAEJKP6GXPAX@Z0@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Terminate@CAc97Channel@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AttachPacket@CAc97Channel@DirectSound@@QAEXKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?AttachBuffer@CAc97Channel@DirectSound@@QAEXKKK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Discontinuity@CAc97Channel@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?ServiceInterrupt@CAc97Channel@DirectSound@@IAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Reset@CAc97Channel@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Flush@CAc97Channel@DirectSound@@QAEXH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Run@CAc97Channel@DirectSound@@QAEXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?Pause@CAc97Channel@DirectSound@@QAEXXZ
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetPrdIndeces@CAc97Channel@DirectSound@@IAEXEEHH@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetMode@CAc97Channel@DirectSound@@QAEXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?SetPosition@CAc97Channel@DirectSound@@IAEXK@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCDirectSound@1@PAV21@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCWaveFileMediaObject@1@PAV21@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCFileMediaObject@1@PAV21@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCAc97MediaObject@1@PAV21@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCDirectSoundBuffer@1@PAV21@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCMcpxVoiceClient@1@PAV21@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCDirectSoundVoiceSettings@1@PAV21@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCDirectSoundBufferSettings@1@PAV21@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCMcpxAPU@1@PAV21@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCDirectSoundSettings@1@PAV21@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCMcpxSlopMemoryHeap@1@PAV21@@Z
DSOUND	SEGMENT PARA USE32 PUBLIC ''
DSOUND	ENDS
;	COMDAT ??_ECMcpxAPU@DirectSound@@W7AEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?wBitsPerSample@?1??AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z@4EB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?dwMcpxMaxAttenuation@?1??ConvertVolumeValues@CMcpxVoiceClient@DirectSound@@IAEXPAUMCPX_VOICE_VOLUME@@@Z@4KB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?fExplained@?1??WaitForVoiceOff@CMcpxVoiceClient@DirectSound@@IAEXXZ@4HA
DSOUND_RW	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RW	ENDS
;	COMDAT ?wfxSilence@?1??Initialize@CDirectSound@DirectSound@@QAGJXZ@4UtWAVEFORMATEX@@B
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?ListRegisters@?1??RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z@4QBU__unnamed@23@B
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?wBytesPerBlock@?1??IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z@4GB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?adwChannelStatusMasks@?1??ServiceAciInterrupt@CAc97Device@DirectSound@@IAEKXZ@4QBKB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?dwMagicWriteValue@?1??WaitForMagicWrite@CMcpxAPU@DirectSound@@IAEXXZ@4KA
DSOUND_RW	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RW	ENDS
;	COMDAT ?dwDelta@?1??ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ@4KB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?dwStatusMask@?1??GetInterruptStatus@CAc97Device@DirectSound@@IAEKXZ@4KB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?$S1@?1??ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ@4IA
DSOUND_URW	SEGMENT PARA USE32 PUBLIC ''
DSOUND_URW	ENDS
;	COMDAT ?rtTimeout@?1??CheckStuckVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ@4_JB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?wBitsPerSample@?1??IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z@4GB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?asSilence@?1??Initialize@CDirectSound@DirectSound@@QAGJXZ@4QBFB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ??_7CMcpxAPU@DirectSound@@6BCMcpxCore@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMcpxAPU@DirectSound@@6BCRefCount@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CImaAdpcmCodec@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMcpxSlopMemoryHeap@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMcpxVoiceClient@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CDirectSoundSettings@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMcpxBufferSgeHeap@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CDirectSoundVoiceSettings@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CDirectSoundVoice@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMcpxCore@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CRefCount@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CDirectSoundBuffer@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CDirectSound@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMcpxBuffer@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CDirectSoundBufferSettings@DirectSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?apDefaultMixBins@?1??SetMixBins@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z@4QBQBU4@B
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
;	COMDAT ?wSamplesPerBlock@?1??IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z@4GB
DSOUND_RD	SEGMENT DWORD USE32 PUBLIC ''
DSOUND_RD	ENDS
FLAT	GROUP _DATA, CONST, _BSS, DSOUND_RW
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?m_adwRegisterOffsets@CAc97Channel@DirectSound@@2QBKB ; DirectSound::CAc97Channel::m_adwRegisterOffsets
PUBLIC	?m_dwSilenceSize@CAc97Channel@DirectSound@@2KB	; DirectSound::CAc97Channel::m_dwSilenceSize
PUBLIC	_DirectSoundDefaultMixBins_Mono
PUBLIC	_DirectSoundDefaultMixBins_Stereo
PUBLIC	_DirectSoundDefaultMixBins_4Channel
PUBLIC	_DirectSoundDefaultMixBins_6Channel
PUBLIC	_DirectSoundRequiredMixBins_3D
PUBLIC	_DirectSoundDefaultMixBins_3D
PUBLIC	_D3DPRIMITIVETOVERTEXCOUNT
PUBLIC	_D3DSIMPLERENDERSTATEENCODE
PUBLIC	_D3DTEXTUREDIRECTENCODE
PUBLIC	_D3DDIRTYFROMRENDERSTATE
PUBLIC	_D3DDIRTYFROMTEXTURESTATE
PUBLIC	?m_dwUsageThreshold@CMcpxSlopMemoryHeap@DirectSound@@2KB ; DirectSound::CMcpxSlopMemoryHeap::m_dwUsageThreshold
PUBLIC	?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap
PUBLIC	?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
PUBLIC	?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
PUBLIC	?m_pDirectSound@CDirectSound@DirectSound@@2PAV12@A ; DirectSound::CDirectSound::m_pDirectSound
PUBLIC	?m_dwRefCount@CFpState@DirectSound@@0KA		; DirectSound::CFpState::m_dwRefCount
PUBLIC	?m_fps@CFpState@DirectSound@@0U_KFLOATING_SAVE@@A ; DirectSound::CFpState::m_fps
PUBLIC	?m_Interrupt@CMcpxAPU@DirectSound@@1U_KINTERRUPT@@A ; DirectSound::CMcpxAPU::m_Interrupt
PUBLIC	?m_dwDeltaPanicCount@CMcpxAPU@DirectSound@@0KA	; DirectSound::CMcpxAPU::m_dwDeltaPanicCount
PUBLIC	?m_dwDeltaWarningCount@CMcpxAPU@DirectSound@@0KA ; DirectSound::CMcpxAPU::m_dwDeltaWarningCount
PUBLIC	?m_wfxMixDest@CDirectSoundBufferSettings@DirectSound@@2UtWAVEFORMATEX@@B ; DirectSound::CDirectSoundBufferSettings::m_wfxMixDest
PUBLIC	?m_dwStuckVoiceCount@CMcpxVoiceClient@DirectSound@@2KA ; DirectSound::CMcpxVoiceClient::m_dwStuckVoiceCount
PUBLIC	?m_wfxFormat@CAc97Device@DirectSound@@2UtWAVEFORMATEX@@B ; DirectSound::CAc97Device::m_wfxFormat
PUBLIC	?m_dwAc97RegisterBase@CAc97Device@DirectSound@@2KB ; DirectSound::CAc97Device::m_dwAc97RegisterBase
PUBLIC	?m_dwAciRegisterBase@CAc97Device@DirectSound@@2KB ; DirectSound::CAc97Device::m_dwAciRegisterBase
PUBLIC	?m_pDevice@CAc97Device@DirectSound@@2PAV12@A	; DirectSound::CAc97Device::m_pDevice
PUBLIC	?m_Interrupt@CAc97Device@DirectSound@@1U_KINTERRUPT@@A ; DirectSound::CAc97Device::m_Interrupt
PUBLIC	?m_asNextStep@CImaAdpcmCodec@DirectSound@@0QBFB	; DirectSound::CImaAdpcmCodec::m_asNextStep
PUBLIC	?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB	; DirectSound::CImaAdpcmCodec::m_asStep
PUBLIC	?m_adwGPOutputBufferSizes@CMcpxCore@DirectSound@@2QBKB ; DirectSound::CMcpxCore::m_adwGPOutputBufferSizes
PUBLIC	?m_adwEPOutputBufferSizes@CMcpxCore@DirectSound@@2QBKB ; DirectSound::CMcpxCore::m_adwEPOutputBufferSizes
PUBLIC	?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A ; DirectSound::CMcpxCore::m_ctxMemory
DSOUND_URW	SEGMENT
?m_pDirectSound@CDirectSound@DirectSound@@2PAV12@A DD 01H DUP (?) ; DirectSound::CDirectSound::m_pDirectSound
?m_fps@CFpState@DirectSound@@0U_KFLOATING_SAVE@@A DB 020H DUP (?) ; DirectSound::CFpState::m_fps
?m_Interrupt@CMcpxAPU@DirectSound@@1U_KINTERRUPT@@A DB 070H DUP (?) ; DirectSound::CMcpxAPU::m_Interrupt
?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A DB 0100H DUP (?) ; DirectSound::CMcpxCore::m_ctxMemory
DSOUND_URW	ENDS
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
DSOUND_RD	SEGMENT
_D3DPRIMITIVETOVERTEXCOUNT DD 00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
DSOUND_RD	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
DSOUND_RD	SEGMENT
_D3DSIMPLERENDERSTATEENCODE DD 040260H
	DD	040264H
	DD	040268H
	DD	04026cH
	DD	040270H
	DD	040274H
	DD	040278H
	DD	04027cH
	DD	040288H
	DD	04028cH
	DD	040a60H
	DD	040a64H
	DD	040a68H
	DD	040a6cH
	DD	040a70H
	DD	040a74H
	DD	040a78H
	DD	040a7cH
	DD	040a80H
	DD	040a84H
	DD	040a88H
	DD	040a8cH
	DD	040a90H
	DD	040a94H
	DD	040a98H
	DD	040a9cH
	DD	040aa0H
	DD	040aa4H
	DD	040aa8H
	DD	040aacH
	DD	040ab0H
	DD	040ab4H
	DD	040ab8H
	DD	040abcH
	DD	040ac0H
	DD	040ac4H
	DD	040ac8H
	DD	040accH
	DD	040ad0H
	DD	040ad4H
	DD	040ad8H
	DD	040adcH
	DD	0417f8H
	DD	041e20H
	DD	041e24H
	DD	041e40H
	DD	041e44H
	DD	041e48H
	DD	041e4cH
	DD	041e50H
	DD	041e54H
	DD	041e58H
	DD	041e5cH
	DD	041e60H
	DD	041d90H
	DD	041e74H
	DD	041e78H
	DD	040354H
	DD	04033cH
	DD	040304H
	DD	040300H
	DD	040340H
	DD	040344H
	DD	040348H
	DD	04035cH
	DD	040310H
	DD	04037cH
	DD	040358H
	DD	040374H
	DD	040378H
	DD	040364H
	DD	040368H
	DD	04036cH
	DD	040360H
	DD	040350H
	DD	04034cH
	DD	0409f8H
	DD	040384H
	DD	040388H
	DD	040330H
	DD	040334H
	DD	040338H
DSOUND_RD	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
DSOUND_RD	SEGMENT
_D3DTEXTUREDIRECTENCODE DD 081b00H
	DD	081b40H
	DD	081b80H
	DD	081bc0H
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
DSOUND_RD	SEGMENT
_D3DDIRTYFROMRENDERSTATE DD 02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	01200H
	DD	03000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	0100H
	DD	0100H
	DD	0900H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	00H
	DD	00H
	DD	00H
DSOUND_RD	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
DSOUND_RD	SEGMENT
_D3DDIRTYFROMTEXTURESTATE DD 0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0480fH
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0400H
DSOUND_RD	ENDS
DSOUND_RW	SEGMENT
?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA DD 00H ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2KA DD 00H ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
?m_dwRefCount@CFpState@DirectSound@@0KA DD 00H		; DirectSound::CFpState::m_dwRefCount
DSOUND_RW	ENDS
DSOUND_RD	SEGMENT
?m_asNextStep@CImaAdpcmCodec@DirectSound@@0QBFB DW 0ffffH ; DirectSound::CImaAdpcmCodec::m_asNextStep
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	02H
	DW	04H
	DW	06H
	DW	08H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	02H
	DW	04H
	DW	06H
	DW	08H
?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB DW 07H	; DirectSound::CImaAdpcmCodec::m_asStep
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	010H
	DW	011H
	DW	013H
	DW	015H
	DW	017H
	DW	019H
	DW	01cH
	DW	01fH
	DW	022H
	DW	025H
	DW	029H
	DW	02dH
	DW	032H
	DW	037H
	DW	03cH
	DW	042H
	DW	049H
	DW	050H
	DW	058H
	DW	061H
	DW	06bH
	DW	076H
	DW	082H
	DW	08fH
	DW	09dH
	DW	0adH
	DW	0beH
	DW	0d1H
	DW	0e6H
	DW	0fdH
	DW	0117H
	DW	0133H
	DW	0151H
	DW	0173H
	DW	0198H
	DW	01c1H
	DW	01eeH
	DW	0220H
	DW	0256H
	DW	0292H
	DW	02d4H
	DW	031cH
	DW	036cH
	DW	03c3H
	DW	0424H
	DW	048eH
	DW	0502H
	DW	0583H
	DW	0610H
	DW	06abH
	DW	0756H
	DW	0812H
	DW	08e0H
	DW	09c3H
	DW	0abdH
	DW	0bd0H
	DW	0cffH
	DW	0e4cH
	DW	0fbaH
	DW	0114cH
	DW	01307H
	DW	014eeH
	DW	01706H
	DW	01954H
	DW	01bdcH
	DW	01ea5H
	DW	021b6H
	DW	02515H
	DW	028caH
	DW	02cdfH
	DW	0315bH
	DW	0364bH
	DW	03bb9H
	DW	041b2H
	DW	04844H
	DW	04f7eH
	DW	05771H
	DW	0602fH
	DW	069ceH
	DW	07462H
	DW	07fffH
	ORG $+2
?m_wfxMixDest@CDirectSoundBufferSettings@DirectSound@@2UtWAVEFORMATEX@@B DW 01H ; DirectSound::CDirectSoundBufferSettings::m_wfxMixDest
	DW	01H
	DD	0bb80H
	DD	02ee00H
	DW	04H
	DW	018H
	DW	00H
DSOUND_RD	ENDS
DSOUND_RW	SEGMENT
?m_dwDeltaWarningCount@CMcpxAPU@DirectSound@@0KA DD 00H	; DirectSound::CMcpxAPU::m_dwDeltaWarningCount
?m_dwDeltaPanicCount@CMcpxAPU@DirectSound@@0KA DD 00H	; DirectSound::CMcpxAPU::m_dwDeltaPanicCount
?m_dwStuckVoiceCount@CMcpxVoiceClient@DirectSound@@2KA DD 00H ; DirectSound::CMcpxVoiceClient::m_dwStuckVoiceCount
DSOUND_RW	ENDS
DSOUND_RD	SEGMENT
	ORG $+2
?m_adwGPOutputBufferSizes@CMcpxCore@DirectSound@@2QBKB DD 02000H ; DirectSound::CMcpxCore::m_adwGPOutputBufferSizes
?m_adwEPOutputBufferSizes@CMcpxCore@DirectSound@@2QBKB DD 02000H ; DirectSound::CMcpxCore::m_adwEPOutputBufferSizes
	DD	04000H
DSOUND_RD	ENDS
DSOUND_RW	SEGMENT
_DefaultExec DD	0bf080H
	DD	0acH
	DD	0300000H
	DD	044f400H
	DD	04000H
	DD	0445800H
	DD	044f400H
	DD	080403H
	DD	0445800H
	DD	044f400H
	DD	0201H
	DD	0445800H
	DD	044f400H
	DD	0c00H
	DD	0445800H
	DD	02e0000H
	DD	0bf080H
	DD	029H
	DD	0bf080H
	DD	020H
	DD	08f484H
	DD	01H
	DD	0bf080H
	DD	0b7H
	DD	0bf080H
	DD	021H
	DD	0bf080H
	DD	022H
	DD	02e0000H
	DD	0bf080H
	DD	07dH
	DD	050fd5H
	DD	0cH
	DD	0cH
	DD	065f400H
	DD	04H
	DD	066f400H
	DD	0204H
	DD	0bf080H
	DD	0c8H
	DD	0cH
	DD	0d1080H
	DD	038H
	DD	08f497H
	DD	00H
	DD	0140c6H
	DD	03fffH
	DD	08ce15H
	DD	08ce14H
	DD	0cH
	DD	0220e00H
	DD	0140c6H
	DD	03fffH
	DD	0140c2H
	DD	04000H
	DD	02008eH
	DD	056f400H
	DD	059e0H
	DD	0200ceH
	DD	0a7093H
	DD	02H
	DD	0a7091H
	DD	03H
	DD	0a7092H
	DD	04H
	DD	0cH
	DD	0220e00H
	DD	0140c6H
	DD	03fffH
	DD	0140c2H
	DD	04000H
	DD	02008eH
	DD	056f400H
	DD	059e2H
	DD	0200ceH
	DD	0a7093H
	DD	02H
	DD	0a7091H
	DD	03H
	DD	0a7092H
	DD	04H
	DD	0cH
	DD	08f496H
	DD	01H
	DD	0cd604H
	DD	00H
	DD	0cH
	DD	08f496H
	DD	02H
	DD	0cd624H
	DD	00H
	DD	0cH
	DD	08f496H
	DD	03H
	DD	0cd603H
	DD	00H
	DD	0cH
	DD	08f496H
	DD	02H
	DD	0cd624H
	DD	00H
	DD	08f496H
	DD	03H
	DD	0cd603H
	DD	00H
	DD	0cH
	DD	08f496H
	DD	04H
	DD	0cd623H
	DD	00H
	DD	0cH
	DD	08f496H
	DD	04H
	DD	0cd623H
	DD	00H
	DD	08f496H
	DD	01H
	DD	0cd604H
	DD	00H
	DD	0cH
	DD	0cc507H
	DD	00H
	DD	08f485H
	DD	080H
	DD	0cH
	DD	050bc4H
	DD	0140c6H
	DD	0ffdfffH
	DD	08ce14H
	DD	050bceH
	DD	050bd6H
	DD	0cH
	DD	050b9dH
	DD	0140c6H
	DD	0ffdfffH
	DD	08ce14H
	DD	050bc7H
	DD	0cH
	DD	0220e00H
	DD	0140c6H
	DD	03fffH
	DD	0140c2H
	DD	04000H
	DD	02008eH
	DD	056f400H
	DD	05be2H
	DD	0200ceH
	DD	056f400H
	DD	020H
	DD	02088eH
	DD	0a7091H
	DD	03H
	DD	0a7092H
	DD	04H
	DD	0cH
	DD	0220e00H
	DD	0140c6H
	DD	03fffH
	DD	0140c2H
	DD	04000H
	DD	02008eH
	DD	056f400H
	DD	05be0H
	DD	0200ceH
	DD	056f400H
	DD	020H
	DD	02088eH
	DD	0a7091H
	DD	03H
	DD	0a7092H
	DD	04H
	DD	0cH
	DD	08f485H
	DD	0fffH
	DD	060f400H
	DD	00H
	DD	044f400H
	DD	01000H
	DD	0bf080H
	DD	0bcH
	DD	0bf080H
	DD	0c0H
	DD	0cH
	DD	0a8581H
	DD	0b7H
	DD	08f485H
	DD	02H
	DD	0cH
	DD	0200013H
	DD	06c420H
	DD	0565800H
	DD	0cH
	DD	060f400H
	DD	00H
	DD	044f400H
	DD	0800H
	DD	0200013H
	DD	06c420H
	DD	05e5800H
	DD	0cH
	DD	021594H
	DD	0cc4a0H
	DD	025H
	DD	0ac460H
	DD	021584H
	DD	0d1080H
	DD	03dcH
	DD	044f400H
	DD	0c000H
	DD	020584H
	DD	044f400H
	DD	01560H
	DD	046f400H
	DD	01560H
	DD	0215c4H
	DD	021d86H
	DD	044f400H
	DD	0c00H
	DD	045f400H
	DD	0c20H
	DD	046f400H
	DD	0c80H
	DD	047f400H
	DD	0ca0H
	DD	021dc4H
	DD	022585H
	DD	0225c6H
	DD	022d87H
	DD	022ce00H
	DD	0405b0H
	DD	061f90H
	DD	03H
	DD	0565800H
	DD	016080H
	DD	0d1080H
	DD	0419H
	DD	0d1080H
	DD	0139H
	DD	021594H
	DD	0cc482H
	DD	06H
	DD	0ac442H
	DD	021584H
	DD	0d1080H
	DD	013bH
	DD	0d1080H
	DD	014dH
	DD	0cH
	DD	062090H
	DD	03H
	DD	044d800H
	DD	0445900H
	DD	0cH
	DD	062090H
	DD	04H
	DD	045e000H
	DD	02000a0H
	DD	0565800H
	DD	0cH
	DD	062090H
	DD	05H
	DD	045d800H
	DD	056e100H
	DD	02000a3H
	DD	0565900H
	DD	0cH
	DD	062090H
	DD	05H
	DD	044d800H
	DD	056e100H
	DD	0200040H
	DD	0565900H
	DD	0cH
	DD	062090H
	DD	05H
	DD	044d800H
	DD	056d900H
	DD	0200040H
	DD	0565a00H
	DD	0cH
	DD	062090H
	DD	04H
	DD	056e000H
	DD	0c1e48H
	DD	0565800H
	DD	0cH
	DD	062090H
	DD	06H
	DD	047d800H
	DD	056e100H
	DD	02000c3H
	DD	0c1e4cH
	DD	0565900H
	DD	0cH
	DD	0d1080H
	DD	0dH
	DD	0cH
	DD	02e0000H
	DD	0a758eH
	DD	01f0H
	DD	0a758eH
	DD	01e1H
	DD	056f400H
	DD	01H
	DD	0a758eH
	DD	01e0H
	DD	0cH
	DD	056f400H
	DD	0ffffffH
	DD	0a758eH
	DD	01f0H
	DD	02e0000H
	DD	0a758eH
	DD	01e1H
	DD	0a758eH
	DD	01e0H
	DD	0cH
	DD	0d1080H
	DD	0c1H
	DD	0d1080H
	DD	03H
	DD	0cH
	DD	0a75ceH
	DD	01e0H
	DD	014085H
	DD	0d104aH
	DD	025H
	DD	0a75ceH
	DD	01e1H
	DD	014085H
	DD	0d104aH
	DD	021H
	DD	0140c5H
	DD	0100H
	DD	0d104aH
	DD	092H
	DD	0140c5H
	DD	0200H
	DD	0d104aH
	DD	0a3H
	DD	0a75d0H
	DD	01e4H
	DD	0a70d0H
	DD	03H
	DD	0a75cfH
	DD	01e3H
	DD	0a75c6H
	DD	01e2H
	DD	062090H
	DD	06H
	DD	021e500H
	DD	044e000H
	DD	02000a0H
	DD	0565800H
	DD	0200058H
	DD	0a758fH
	DD	01e3H
	DD	0a75ceH
	DD	01e1H
	DD	016080H
	DD	0a758eH
	DD	01e1H
	DD	0cH
	DD	0a75c4H
	DD	01e0H
	DD	0cc4a0H
	DD	018H
	DD	0cc4a5H
	DD	025H
	DD	0cc4adH
	DD	052H
	DD	0cc4b1H
	DD	03bH
	DD	0cc4b3H
	DD	07fH
	DD	0a75ceH
	DD	01e4H
	DD	014780H
	DD	0a758eH
	DD	01e4H
	DD	0a75ceH
	DD	01e5H
	DD	0a75c4H
	DD	01e6H
	DD	0200040H
	DD	0a758eH
	DD	01e5H
	DD	0d10c0H
	DD	054H
	DD	022ae00H
	DD	0140c0H
	DD	046H
	DD	0a758eH
	DD	01e7H
	DD	0140c0H
	DD	059H
	DD	0a758eH
	DD	01e5H
	DD	0140c0H
	DD	062H
	DD	0a758eH
	DD	01e4H
	DD	0d10c0H
	DD	042H
	DD	022ae00H
	DD	0140c0H
	DD	09fH
	DD	0a758eH
	DD	01e5H
	DD	0140c0H
	DD	085H
	DD	0a758eH
	DD	01e4H
	DD	0140c0H
	DD	0ffff6fH
	DD	021d000H
	DD	0a75c4H
	DD	04bH
	DD	0140c0H
	DD	0155H
	DD	021d100H
	DD	0a758eH
	DD	01e7H
	DD	060890H
	DD	04H
	DD	056d800H
	DD	0200040H
	DD	0565900H
	DD	0d10c0H
	DD	028H
	DD	022ae00H
	DD	0140c0H
	DD	0f3H
	DD	0a758eH
	DD	01e5H
	DD	0140c0H
	DD	0d9H
	DD	0a758eH
	DD	01e4H
	DD	015c80H
	DD	021d000H
	DD	0a758eH
	DD	01e7H
	DD	0a75ceH
	DD	058H
	DD	0565800H
	DD	0566000H
	DD	056f400H
	DD	07H
	DD	0d10c0H
	DD	014H
	DD	022ae00H
	DD	0140c0H
	DD	054H
	DD	0a758eH
	DD	01e7H
	DD	0140c0H
	DD	067H
	DD	0a758eH
	DD	01e5H
	DD	0140c0H
	DD	0d9H
	DD	0a758eH
	DD	01e4H
	DD	056f400H
	DD	07H
	DD	0d10c0H
	DD	03H
	DD	0200013H
	DD	0a758eH
	DD	01e6H
	DD	056f400H
	DD	0ff8000H
	DD	0a758eH
	DD	01e2H
	DD	056f400H
	DD	07f8000H
	DD	0a758eH
	DD	01e3H
	DD	050ed5H
	DD	0a75d0H
	DD	01e7H
	DD	056d800H
	DD	0a7590H
	DD	01e7H
	DD	016084H
	DD	014085H
	DD	0202913H
	DD	021c500H
	DD	0a75d0H
	DD	01e5H
	DD	0a75d1H
	DD	01e4H
	DD	0d1080H
	DD	02b0H
	DD	056f400H
	DD	08000H
	DD	0a758eH
	DD	01e2H
	DD	050ec1H
	DD	050a5fH
	DD	02e0000H
	DD	0a758eH
	DD	01e1H
	DD	0a75ceH
	DD	01e0H
	DD	0200032H
	DD	0a758eH
	DD	01e0H
	DD	050ecdH
	DD	0a75ceH
	DD	01f0H
	DD	014085H
	DD	0d1049H
	DD	01aH
	DD	022af00H
	DD	0140c8H
	DD	063H
	DD	021f000H
	DD	0140c8H
	DD	0177H
	DD	021f100H
	DD	0140c5H
	DD	0150H
	DD	0d104aH
	DD	010H
	DD	014180H
	DD	0a758eH
	DD	01f0H
	DD	060690H
	DD	09H
	DD	056e100H
	DD	057d800H
	DD	0200014H
	DD	021c600H
	DD	0141d0H
	DD	07c49baH
	DD	0200018H
	DD	0575900H
	DD	0cH
	DD	060690H
	DD	03H
	DD	044d800H
	DD	0445900H
	DD	056f400H
	DD	0ffffffH
	DD	0a758eH
	DD	01f0H
	DD	050fd7H
	DD	0d1080H
	DD	01cH
	DD	0d1080H
	DD	0eH
	DD	0d1080H
	DD	0fffefdH
	DD	0d1080H
	DD	0182H
	DD	0cH
	DD	0d1080H
	DD	013H
	DD	0d1080H
	DD	0fffef9H
	DD	0d1080H
	DD	0239H
	DD	0cH
	DD	022ae00H
	DD	0140c0H
	DD	01daH
	DD	021d000H
	DD	0140c0H
	DD	0fffe89H
	DD	021d100H
	DD	060690H
	DD	03H
	DD	044d900H
	DD	0445800H
	DD	0cH
	DD	0cH
	DD	0d1080H
	DD	0154H
	DD	05f420H
	DD	0ffffffH
	DD	0461a0H
	DD	0462a0H
	DD	0463a0H
	DD	0464a0H
	DD	0465a0H
	DD	0244000H
	DD	0a75d0H
	DD	05H
	DD	0d1080H
	DD	0fffeafH
	DD	0a75d0H
	DD	05H
	DD	022ae00H
	DD	0140c0H
	DD	06aH
	DD	021d100H
	DD	0d1080H
	DD	014cH
	DD	0d1080H
	DD	0fffe20H
	DD	0d1080H
	DD	0fffee3H
	DD	0a75d1H
	DD	0cH
	DD	060490H
	DD	06H
	DD	0a75d0H
	DD	0bH
	DD	0d1080H
	DD	0fffea8H
	DD	022ae00H
	DD	0a75d0H
	DD	020H
	DD	0a75d1H
	DD	0cH
	DD	022ae00H
	DD	0140c0H
	DD	08fH
	DD	021d200H
	DD	060490H
	DD	05H
	DD	044da00H
	DD	0d1080H
	DD	0fffe93H
	DD	022ae00H
	DD	0140c0H
	DD	059H
	DD	021d300H
	DD	0a75d0H
	DD	010H
	DD	0a75d2H
	DD	024H
	DD	03a2000H
	DD	060490H
	DD	09H
	DD	060290H
	DD	06H
	DD	0225100H
	DD	044db00H
	DD	0d1080H
	DD	0fffe82H
	DD	00H
	DD	044ca00H
	DD	0a75d0H
	DD	019H
	DD	0a75d1H
	DD	01aH
	DD	0a75d2H
	DD	014H
	DD	0d1080H
	DD	0fffe86H
	DD	0a75d0H
	DD	018H
	DD	0d1080H
	DD	0fffe82H
	DD	0a75d0H
	DD	01cH
	DD	0a75d1H
	DD	014H
	DD	0d1080H
	DD	0fffe75H
	DD	0d1080H
	DD	0fffe73H
	DD	0a75d0H
	DD	01fH
	DD	0a75d1H
	DD	014H
	DD	0d1080H
	DD	0fffe6dH
	DD	0a75d0H
	DD	01eH
	DD	0d1080H
	DD	0fffe69H
	DD	0a75d0H
	DD	014H
	DD	0a75d1H
	DD	015H
	DD	0a75d2H
	DD	016H
	DD	0d1080H
	DD	0fffe68H
	DD	0a75d0H
	DD	016H
	DD	0a75c4H
	DD	062H
	DD	0d1080H
	DD	0fffe4eH
	DD	0a75d0H
	DD	014H
	DD	0a75c4H
	DD	061H
	DD	0d1080H
	DD	0fffe48H
	DD	0d1080H
	DD	0fffe46H
	DD	0a75d0H
	DD	028H
	DD	0a75d1H
	DD	014H
	DD	0d1080H
	DD	0fffe4dH
	DD	0d1080H
	DD	0fffe4bH
	DD	0a75d0H
	DD	014H
	DD	0a75d1H
	DD	028H
	DD	0d1080H
	DD	0fffe33H
	DD	0d1080H
	DD	0fffe31H
	DD	0a75d0H
	DD	014H
	DD	022ae00H
	DD	0140c0H
	DD	082H
	DD	021d100H
	DD	0d1080H
	DD	0d3H
	DD	022ae00H
	DD	0140c0H
	DD	085H
	DD	021d100H
	DD	0d1080H
	DD	0cdH
	DD	0a75d0H
	DD	019H
	DD	022ae00H
	DD	0140c0H
	DD	06dH
	DD	021d100H
	DD	0382000H
	DD	0390300H
	DD	060390H
	DD	05H
	DD	0d1080H
	DD	0c1H
	DD	044c800H
	DD	044c900H
	DD	0a75d4H
	DD	010H
	DD	022ae00H
	DD	0140c0H
	DD	08bH
	DD	021d300H
	DD	0382000H
	DD	060490H
	DD	010H
	DD	0a75d1H
	DD	024H
	DD	062090H
	DD	0bH
	DD	0223000H
	DD	0227200H
	DD	0200013H
	DD	060490H
	DD	04H
	DD	044c800H
	DD	045da00H
	DD	02000a3H
	DD	0565c00H
	DD	044d900H
	DD	044d300H
	DD	0a75d1H
	DD	010H
	DD	060490H
	DD	06H
	DD	0a75d0H
	DD	016H
	DD	0d1080H
	DD	0fffe07H
	DD	022ae00H
	DD	03b0300H
	DD	0a75d0H
	DD	010H
	DD	0140c0H
	DD	076H
	DD	021d300H
	DD	060490H
	DD	05H
	DD	0227100H
	DD	0d1080H
	DD	093H
	DD	044cb00H
	DD	0a75d0H
	DD	05H
	DD	0a75d1H
	DD	0bH
	DD	0d1080H
	DD	0fffde2H
	DD	0a75d1H
	DD	0cH
	DD	0a75d2H
	DD	024H
	DD	0a75d3H
	DD	028H
	DD	0a75d4H
	DD	020H
	DD	022ae00H
	DD	0140c0H
	DD	01daH
	DD	021d000H
	DD	0a75c6H
	DD	01deH
	DD	0a75c7H
	DD	01dfH
	DD	0a75ceH
	DD	069H
	DD	014485H
	DD	0d104aH
	DD	06H
	DD	0d1080H
	DD	03aH
	DD	0d10c0H
	DD	06H
	DD	0d1080H
	DD	04aH
	DD	0a75d4H
	DD	022H
	DD	0a75d1H
	DD	0eH
	DD	0a75d2H
	DD	026H
	DD	022ae00H
	DD	0140c0H
	DD	01dcH
	DD	021d000H
	DD	0a75c6H
	DD	01deH
	DD	0a75c7H
	DD	01dfH
	DD	0a75ceH
	DD	069H
	DD	014485H
	DD	0d104aH
	DD	06H
	DD	0d1080H
	DD	021H
	DD	0d10c0H
	DD	010H
	DD	0d1080H
	DD	031H
	DD	0a75d0H
	DD	022H
	DD	0a75d1H
	DD	09H
	DD	0d1080H
	DD	0fffdbaH
	DD	0a75d0H
	DD	023H
	DD	0a75d1H
	DD	0aH
	DD	0d1080H
	DD	0fffdb4H
	DD	0a75d0H
	DD	020H
	DD	0a75d1H
	DD	07H
	DD	0d1080H
	DD	0fffdaeH
	DD	0a75d0H
	DD	021H
	DD	0a75d1H
	DD	08H
	DD	0d1080H
	DD	0fffda8H
	DD	0d1080H
	DD	038H
	DD	0cH
	DD	0392000H
	DD	03a2000H
	DD	044d800H
	DD	062090H
	DD	0fH
	DD	045e900H
	DD	044d000H
	DD	02000a0H
	DD	045d900H
	DD	044d800H
	DD	02000a3H
	DD	045ea00H
	DD	02000e3H
	DD	045da00H
	DD	02000e3H
	DD	045db00H
	DD	02000f3H
	DD	0c1d0eH
	DD	0565c00H
	DD	0cH
	DD	03c2000H
	DD	03a2000H
	DD	0392000H
	DD	044d800H
	DD	020ce00H
	DD	0200022H
	DD	021c600H
	DD	062090H
	DD	012H
	DD	045e900H
	DD	044d000H
	DD	02000a8H
	DD	045d900H
	DD	044d800H
	DD	02000a0H
	DD	045ea00H
	DD	02000ebH
	DD	045da00H
	DD	02000e3H
	DD	045db00H
	DD	02000fbH
	DD	02000f3H
	DD	0c1d8fH
	DD	0c1d0eH
	DD	0576c00H
	DD	0565c00H
	DD	0cH
	DD	022ae00H
	DD	0140c0H
	DD	0101H
	DD	0d1080H
	DD	0fffcebH
	DD	0cH
	DD	022ae00H
	DD	0140c0H
	DD	09fH
	DD	0d1080H
	DD	0fffcdeH
	DD	0cH
	DD	0201d6H
	DD	020997H
	DD	062090H
	DD	07H
	DD	020194H
	DD	02000d0H
	DD	045e000H
	DD	02000f2H
	DD	02018eH
	DD	0565800H
	DD	0cH
	DD	022ae00H
	DD	0140c0H
	DD	09fH
	DD	021d000H
	DD	0380700H
	DD	0280000H
	DD	02c2000H
	DD	044f400H
	DD	04bd2H
	DD	046f400H
	DD	0eH
	DD	0d1080H
	DD	05bH
	DD	044f400H
	DD	04bd0H
	DD	046f400H
	DD	01fH
	DD	0d1080H
	DD	055H
	DD	05f420H
	DD	0ffffffH
	DD	0380700H
	DD	022ae00H
	DD	0140c0H
	DD	0a2H
	DD	021d000H
	DD	022ddeH
	DD	0564800H
	DD	0265deH
	DD	060390H
	DD	04H
	DD	0564800H
	DD	0140c0H
	DD	040H
	DD	02359eH
	DD	060890H
	DD	03H
	DD	0564800H
	DD	016080H
	DD	02559eH
	DD	060290H
	DD	03H
	DD	0564800H
	DD	016080H
	DD	022ae00H
	DD	0140c0H
	DD	0104H
	DD	021d000H
	DD	0380700H
	DD	022ddeH
	DD	061f90H
	DD	03H
	DD	0564800H
	DD	016080H
	DD	022ae00H
	DD	0140c0H
	DD	0101H
	DD	021d000H
	DD	022ae00H
	DD	016a80H
	DD	021d100H
	DD	044e100H
	DD	0201d5H
	DD	060d90H
	DD	04H
	DD	0210c4H
	DD	021885H
	DD	054c800H
	DD	060490H
	DD	09H
	DD	044d900H
	DD	045d900H
	DD	060290H
	DD	04H
	DD	0210c4H
	DD	021885H
	DD	054c800H
	DD	00H
	DD	060a90H
	DD	06H
	DD	044d900H
	DD	0210c4H
	DD	045d900H
	DD	021885H
	DD	054c800H
	DD	022ae00H
	DD	0140c0H
	DD	09fH
	DD	021d000H
	DD	022ae00H
	DD	016a80H
	DD	021d100H
	DD	060e90H
	DD	06H
	DD	044d900H
	DD	0210c4H
	DD	045d900H
	DD	021885H
	DD	054c800H
	DD	0d1080H
	DD	011H
	DD	0cH
	DD	0221100H
	DD	06c610H
	DD	08H
	DD	0a7190H
	DD	00H
	DD	0200c4H
	DD	02088cH
	DD	021088H
	DD	0221100H
	DD	045c800H
	DD	044f400H
	DD	04000H
	DD	0446100H
	DD	0cH
	DD	0d1080H
	DD	05H
	DD	0d1080H
	DD	048H
	DD	0cH
	DD	022ae00H
	DD	0140c0H
	DD	046H
	DD	021d200H
	DD	0140c0H
	DD	059H
	DD	021d000H
	DD	0140c0H
	DD	062H
	DD	021d100H
	DD	0260000H
	DD	047f400H
	DD	05H
	DD	0d1080H
	DD	060H
	DD	022ae00H
	DD	0140c0H
	DD	093H
	DD	021d200H
	DD	022ae00H
	DD	0140c0H
	DD	09fH
	DD	021d000H
	DD	0140c0H
	DD	085H
	DD	021d100H
	DD	0a75c6H
	DD	04bH
	DD	047f400H
	DD	08H
	DD	0d1080H
	DD	04fH
	DD	022ae00H
	DD	0140c0H
	DD	054H
	DD	021d200H
	DD	0140c0H
	DD	067H
	DD	021d000H
	DD	0140c0H
	DD	0d9H
	DD	021d100H
	DD	0380700H
	DD	0390700H
	DD	060490H
	DD	06H
	DD	045da00H
	DD	0d1080H
	DD	048H
	DD	044c800H
	DD	044c900H
	DD	022ae00H
	DD	0140c0H
	DD	0f3H
	DD	021d000H
	DD	0140c0H
	DD	0d9H
	DD	021d100H
	DD	0380700H
	DD	0390700H
	DD	060290H
	DD	07H
	DD	0a75c5H
	DD	058H
	DD	0d1080H
	DD	037H
	DD	044c800H
	DD	044c900H
	DD	0cH
	DD	022ae00H
	DD	0140c0H
	DD	04cH
	DD	021d200H
	DD	0140c0H
	DD	053H
	DD	021d000H
	DD	0140c0H
	DD	0bdH
	DD	021d100H
	DD	0380700H
	DD	060490H
	DD	07H
	DD	0260000H
	DD	047f400H
	DD	02H
	DD	0d1080H
	DD	018H
	DD	044c800H
	DD	022ae00H
	DD	0140c0H
	DD	0d7H
	DD	021d000H
	DD	0140c0H
	DD	0d9H
	DD	021d100H
	DD	022ae00H
	DD	0140c0H
	DD	09bH
	DD	021d200H
	DD	0380700H
	DD	0390700H
	DD	060490H
	DD	06H
	DD	045da00H
	DD	0d1080H
	DD	0fH
	DD	044c800H
	DD	044c900H
	DD	0cH
	DD	0390700H
	DD	06c710H
	DD	07H
	DD	056da00H
	DD	0200050H
	DD	021c500H
	DD	0d1080H
	DD	04H
	DD	044c900H
	DD	0cH
	DD	02109fH
	DD	020006cH
	DD	0140ceH
	DD	0fffffcH
	DD	01408dH
	DD	0d1041H
	DD	05H
	DD	021894H
	DD	0200048H
	DD	014188H
	DD	02118fH
	DD	0cH
	DD	044f400H
	DD	088H
	DD	022ae00H
	DD	0200040H
	DD	021d000H
	DD	044f400H
	DD	0c00000H
	DD	0445800H
	DD	044f400H
	DD	0c00000H
	DD	0445800H
	DD	044f400H
	DD	0c00000H
	DD	0445800H
	DD	044f400H
	DD	0400000H
	DD	0445800H
	DD	044f400H
	DD	0c00000H
	DD	0445800H
	DD	044f400H
	DD	0c00000H
	DD	0445800H
	DD	044f400H
	DD	0c00000H
	DD	0445800H
	DD	044f400H
	DD	08fH
	DD	022ae00H
	DD	0200040H
	DD	021d000H
	DD	044f400H
	DD	0cccccdH
	DD	0445800H
	DD	044f400H
	DD	0333333H
	DD	0445800H
	DD	044f400H
	DD	0cccccdH
	DD	0445800H
	DD	044f400H
	DD	0cccccdH
	DD	0445800H
	DD	044f400H
	DD	093H
	DD	022ae00H
	DD	0200040H
	DD	021d000H
	DD	044f400H
	DD	00H
	DD	0445800H
	DD	044f400H
	DD	01d0H
	DD	0445800H
	DD	044f400H
	DD	0430H
	DD	0445800H
	DD	044f400H
	DD	0740H
	DD	0445800H
	DD	044f400H
	DD	00H
	DD	0445800H
	DD	044f400H
	DD	01d0H
	DD	0445800H
	DD	044f400H
	DD	0430H
	DD	0445800H
	DD	044f400H
	DD	0740H
	DD	0445800H
	DD	044f400H
	DD	09bH
	DD	022ae00H
	DD	0200040H
	DD	021d000H
	DD	044f400H
	DD	0ae00H
	DD	0445800H
	DD	044f400H
	DD	0ff80H
	DD	0445800H
	DD	044f400H
	DD	0d2c0H
	DD	0445800H
	DD	044f400H
	DD	0135c0H
	DD	0445800H
	DD	0cH
	DD	0200013H
	DD	044f400H
	DD	02aH
	DD	022ae00H
	DD	0200040H
	DD	021d000H
	DD	044f400H
	DD	0c000H
	DD	0445800H
	DD	044f400H
	DD	0bb7fH
	DD	0445800H
	DD	044f400H
	DD	017b80H
	DD	0445800H
	DD	044f400H
	DD	0bb7fH
	DD	0445800H
	DD	044f400H
	DD	023700H
	DD	0445800H
	DD	044f400H
	DD	0bb7fH
	DD	0445800H
	DD	044f400H
	DD	02f280H
	DD	0445800H
	DD	044f400H
	DD	0bb7fH
	DD	0445800H
	DD	044f400H
	DD	03ae00H
	DD	0445800H
	DD	044f400H
	DD	0153fH
	DD	0445800H
	DD	044f400H
	DD	03c340H
	DD	0445800H
	DD	044f400H
	DD	0132fH
	DD	0445800H
	DD	044f400H
	DD	03d670H
	DD	0445800H
	DD	044f400H
	DD	0140fH
	DD	0445800H
	DD	044f400H
	DD	03ea80H
	DD	0445800H
	DD	044f400H
	DD	0167fH
	DD	0445800H
	DD	044f400H
	DD	040100H
	DD	0445800H
	DD	044f400H
	DD	02b7fH
	DD	0445800H
	DD	044f400H
	DD	042c80H
	DD	0445800H
	DD	044f400H
	DD	034afH
	DD	0445800H
	DD	044f400H
	DD	046130H
	DD	0445800H
	DD	044f400H
	DD	03fdfH
	DD	0445800H
	DD	044f400H
	DD	04a110H
	DD	0445800H
	DD	044f400H
	DD	04d6fH
	DD	0445800H
	DD	044f400H
	DD	04ee80H
	DD	0445800H
	DD	044f400H
	DD	01e8bfH
	DD	0445800H
	DD	044f400H
	DD	06d740H
	DD	0445800H
	DD	044f400H
	DD	01e8bfH
	DD	0445800H
	DD	044f400H
	DD	0540H
	DD	0445800H
	DD	044f400H
	DD	0620H
	DD	0445800H
	DD	044f400H
	DD	05d0H
	DD	0445800H
	DD	044f400H
	DD	06b0H
	DD	0445800H
	DD	044f400H
	DD	0730H
	DD	0445800H
	DD	044f400H
	DD	0830H
	DD	0445800H
	DD	044f400H
	DD	01e00H
	DD	0445800H
	DD	044f400H
	DD	0fe0H
	DD	0445800H
	DD	044f400H
	DD	08d50H
	DD	0445800H
	DD	044f400H
	DD	0bb80H
	DD	0445800H
	DD	044f400H
	DD	0ab40H
	DD	0445800H
	DD	044f400H
	DD	0ba10H
	DD	0445800H
	DD	044f400H
	DD	0ab40H
	DD	0445800H
	DD	044f400H
	DD	065c0H
	DD	0445800H
	DD	044f400H
	DD	04c0H
	DD	0445800H
	DD	044f400H
	DD	0470H
	DD	0445800H
	DD	044f400H
	DD	04a0H
	DD	0445800H
	DD	044f400H
	DD	0520H
	DD	0445800H
	DD	044f400H
	DD	01e8c0H
	DD	0445800H
	DD	044f400H
	DD	07fffffH
	DD	0445800H
	DD	044f400H
	DD	0800001H
	DD	0445800H
	DD	044f400H
	DD	0800001H
	DD	0445800H
	DD	044f400H
	DD	07fffffH
	DD	0445800H
	DD	044f400H
	DD	07fffffH
	DD	0445800H
	DD	044f400H
	DD	07fffffH
	DD	0445800H
	DD	044f400H
	DD	0800001H
	DD	0445800H
	DD	044f400H
	DD	0800001H
	DD	0445800H
	DD	044f400H
	DD	00H
	DD	0445800H
	DD	044f400H
	DD	0199999H
	DD	0445800H
	DD	044f400H
	DD	01e23H
	DD	0445800H
	DD	044f400H
	DD	01b7eH
	DD	0445800H
	DD	044f400H
	DD	01c8dH
	DD	0445800H
	DD	044f400H
	DD	01fb9H
	DD	0445800H
	DD	044f400H
	DD	0108ffH
	DD	0445800H
	DD	044f400H
	DD	0108ffH
	DD	0445800H
	DD	044f400H
	DD	02H
	DD	0445800H
	DD	044f400H
	DD	00H
	DD	0445800H
	DD	044f400H
	DD	06c5a41H
	DD	0445800H
	DD	044f400H
	DD	013a5bfH
	DD	0445800H
	DD	044f400H
	DD	00H
	DD	0445800H
	DD	044f400H
	DD	062f77dH
	DD	0445800H
	DD	044f400H
	DD	091e2fH
	DD	0445800H
	DD	044f400H
	DD	00H
	DD	0445800H
	DD	044f400H
	DD	062f77dH
	DD	0445800H
	DD	044f400H
	DD	091e2fH
	DD	0445800H
	DD	044f400H
	DD	00H
	DD	0445800H
	DD	044f400H
	DD	062f77dH
	DD	0445800H
	DD	044f400H
	DD	091e2fH
	DD	0445800H
	DD	044f400H
	DD	00H
	DD	0445800H
	DD	044f400H
	DD	0385f2cH
	DD	0445800H
	DD	044f400H
	DD	036c675H
	DD	0445800H
	DD	044f400H
	DD	00H
	DD	0445800H
	DD	044f400H
	DD	03dada9H
	DD	0445800H
	DD	044f400H
	DD	02fef6eH
	DD	0445800H
	DD	044f400H
	DD	00H
	DD	0445800H
	DD	044f400H
	DD	0433c8eH
	DD	0445800H
	DD	044f400H
	DD	028fc95H
	DD	0445800H
	DD	044f400H
	DD	00H
	DD	0445800H
	DD	044f400H
	DD	048ba8fH
	DD	0445800H
	DD	044f400H
	DD	02246d7H
	DD	0445800H
	DD	044f400H
	DD	00H
	DD	0445800H
	DD	044f400H
	DD	07e6cd8H
	DD	0445800H
	DD	044f400H
	DD	03e9H
	DD	0445800H
	DD	044f400H
	DD	00H
	DD	0445800H
	DD	044f400H
	DD	07e6cd8H
	DD	0445800H
	DD	044f400H
	DD	03e9H
	DD	0445800H
	DD	0cH
	DD	00H
DSOUND_RW	ENDS
DSOUND_RD	SEGMENT
?m_dwUsageThreshold@CMcpxSlopMemoryHeap@DirectSound@@2KB DD 040H ; DirectSound::CMcpxSlopMemoryHeap::m_dwUsageThreshold
DSOUND_RD	ENDS
DSOUND_RW	SEGMENT
?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A DD 00H ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap
DSOUND_RW	ENDS
DSOUND_RD	SEGMENT
_DirectSoundDefaultMixBinVolumePairs_Mono DD 00H
	DD	00H
	DD	01H
	DD	00H
_DirectSoundDefaultMixBinVolumePairs_Stereo DD 00H
	DD	00H
	DD	01H
	DD	00H
_DirectSoundDefaultMixBinVolumePairs_4Channel DD 00H
	DD	00H
	DD	01H
	DD	00H
	DD	04H
	DD	00H
	DD	05H
	DD	00H
_DirectSoundDefaultMixBinVolumePairs_6Channel DD 00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	03H
	DD	00H
	DD	04H
	DD	00H
	DD	05H
	DD	00H
_DirectSoundRequiredMixBinVolumePairs_3D DD 06H
	DD	00H
	DD	08H
	DD	00H
	DD	07H
	DD	00H
	DD	09H
	DD	00H
_DirectSoundDefaultMixBinVolumePairs_3D DD 06H
	DD	00H
	DD	08H
	DD	00H
	DD	07H
	DD	00H
	DD	09H
	DD	00H
	DD	0aH
	DD	00H
_DirectSoundDefaultMixBins_Mono DD 02H
	DD	FLAT:_DirectSoundDefaultMixBinVolumePairs_Mono
_DirectSoundDefaultMixBins_Stereo DD 02H
	DD	FLAT:_DirectSoundDefaultMixBinVolumePairs_Stereo
_DirectSoundDefaultMixBins_4Channel DD 04H
	DD	FLAT:_DirectSoundDefaultMixBinVolumePairs_4Channel
_DirectSoundDefaultMixBins_6Channel DD 06H
	DD	FLAT:_DirectSoundDefaultMixBinVolumePairs_6Channel
_DirectSoundRequiredMixBins_3D DD 04H
	DD	FLAT:_DirectSoundRequiredMixBinVolumePairs_3D
_DirectSoundDefaultMixBins_3D DD 05H
	DD	FLAT:_DirectSoundDefaultMixBinVolumePairs_3D
?m_dwAc97RegisterBase@CAc97Device@DirectSound@@2KB DD 0fec00000H ; DirectSound::CAc97Device::m_dwAc97RegisterBase
?m_dwAciRegisterBase@CAc97Device@DirectSound@@2KB DD 0fec00100H ; DirectSound::CAc97Device::m_dwAciRegisterBase
?m_wfxFormat@CAc97Device@DirectSound@@2UtWAVEFORMATEX@@B DW 01H ; DirectSound::CAc97Device::m_wfxFormat
	DW	02H
	DD	0bb80H
	DD	02ee00H
	DW	04H
	DW	010H
	DW	00H
DSOUND_RD	ENDS
DSOUND_RW	SEGMENT
?m_pDevice@CAc97Device@DirectSound@@2PAV12@A DD 00H	; DirectSound::CAc97Device::m_pDevice
	ORG $+4
?m_Interrupt@CAc97Device@DirectSound@@1U_KINTERRUPT@@A DD 00H ; DirectSound::CAc97Device::m_Interrupt
	ORG $+108
DSOUND_RW	ENDS
DSOUND_RD	SEGMENT
	ORG $+2
?m_adwRegisterOffsets@CAc97Channel@DirectSound@@2QBKB DD 010H ; DirectSound::CAc97Channel::m_adwRegisterOffsets
	DD	070H
?m_dwSilenceSize@CAc97Channel@DirectSound@@2KB DD 02000H ; DirectSound::CAc97Channel::m_dwSilenceSize
DSOUND_RD	ENDS
PUBLIC	?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::PoolAlloc
EXTRN	__imp__ExAllocatePoolWithTag@8:NEAR
EXTRN	__imp__ExQueryPoolBlockSize@4:NEAR
EXTRN	_memset:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\memmgr.cpp
;	COMDAT ?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT
_pvBuffer$ = -4
_nPoolTag$ = 8
_cbBuffer$ = 12
_fZeroInit$ = 16
?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z PROC NEAR ; DirectSound::CMemoryManager::PoolAlloc, COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 65   :     static const ULONG      cbLowerThreshold    = 0x20;
; 66   :     static const DWORD      cbUpperThreshold    = 0xFD8;
; 67   :     LPVOID                  pvBuffer;
; 68   : 
; 69   :     ASSERT(cbBuffer);
; 70   : 
; 71   : #ifdef _XBOX
; 72   : 
; 73   : #ifdef MEM_SIZE_CHECK
; 74   : 
; 75   : #pragma TODO("Don't ship with this check turned on")
; 76   :     
; 77   :     if((DSOUND_OBJECT_POOL_TAG == nPoolTag) && (cbBuffer >= cbUpperThreshold))
; 78   :     {
; 79   :         ASSERTMSG("Allocating an object larger than the pool threshold");
; 80   :     }
; 81   :     else if((DSOUND_DATA_POOL_TAG == nPoolTag) && (cbBuffer < cbLowerThreshold))
; 82   :     {
; 83   :         ASSERTMSG("Allocating a buffer smaller than 32 bytes");
; 84   :     }
; 85   : 
; 86   : #endif // _MEM_SIZE_CHECK
; 87   : 
; 88   :     if(pvBuffer = ExAllocatePoolWithTag(cbBuffer, nPoolTag))

  00004	8b 45 08	 mov	 eax, DWORD PTR _nPoolTag$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  0000b	51		 push	 ecx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@8
  00012	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  00015	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00019	74 32		 je	 SHORT $L35196

; 89   :     {
; 90   :         cbBuffer = ExQueryPoolBlockSize(pvBuffer);

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  0001e	52		 push	 edx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExQueryPoolBlockSize@4
  00025	89 45 0c	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 91   :         m_dwPoolMemoryUsage += cbBuffer;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  0002d	03 45 0c	 add	 eax, DWORD PTR _cbBuffer$[ebp]
  00030	a3 00 00 00 00	 mov	 DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA, eax ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage

; 92   : 
; 93   :         if(fZeroInit)

  00035	83 7d 10 00	 cmp	 DWORD PTR _fZeroInit$[ebp], 0
  00039	74 12		 je	 SHORT $L35196

; 94   :         {
; 95   :             ZeroMemory(pvBuffer, cbBuffer);

  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  0003e	51		 push	 ecx
  0003f	6a 00		 push	 0
  00041	8b 55 fc	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00044	52		 push	 edx
  00045	e8 00 00 00 00	 call	 _memset
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L35196:

; 96   :         }
; 97   :     }
; 98   : 
; 99   : #else // _XBOX
; 100  : 
; 101  :     if(pvBuffer = LocalAlloc(fZeroInit ? LPTR : LMEM_FIXED, cbBuffer))
; 102  :     {
; 103  :         cbBuffer = LocalSize(pvBuffer);
; 104  :         m_dwPoolMemoryUsage += cbBuffer;
; 105  :     }
; 106  : 
; 107  : #endif // _XBOX
; 108  : 
; 109  :     else
; 110  :     {
; 111  :         DPF_RESOURCE("Out of pool memory");
; 112  :     }
; 113  : 
; 114  :     return pvBuffer;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 115  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 0c 00	 ret	 12			; 0000000cH
?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ENDP ; DirectSound::CMemoryManager::PoolAlloc
DSOUND	ENDS
PUBLIC	?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z	; DirectSound::CMemoryManager::PoolFree
EXTRN	__imp__ExFreePool@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT
_cbBuffer$ = -4
_pvBuffer$ = 8
?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::PoolFree, COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 142  :     DWORD                   cbBuffer;
; 143  : 
; 144  :     ASSERT(pvBuffer);
; 145  : 
; 146  : #ifdef _XBOX
; 147  : 
; 148  :     cbBuffer = ExQueryPoolBlockSize(pvBuffer);

  00004	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00007	50		 push	 eax
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExQueryPoolBlockSize@4
  0000e	89 45 fc	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 149  : 
; 150  :     ASSERT(m_dwPoolMemoryUsage >= cbBuffer);
; 151  :     m_dwPoolMemoryUsage -= cbBuffer;

  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage
  00017	2b 4d fc	 sub	 ecx, DWORD PTR _cbBuffer$[ebp]
  0001a	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_dwPoolMemoryUsage@CMemoryManager@DirectSound@@2KA, ecx ; DirectSound::CMemoryManager::m_dwPoolMemoryUsage

; 152  : 
; 153  :     ExFreePool(pvBuffer);

  00020	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00023	52		 push	 edx
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 154  : 
; 155  : #else // _XBOX
; 156  : 
; 157  :     cbBuffer = LocalSize(pvBuffer);
; 158  : 
; 159  :     ASSERT(m_dwPoolMemoryUsage >= cbBuffer);
; 160  :     m_dwPoolMemoryUsage -= cbBuffer;
; 161  : 
; 162  :     LocalFree(pvBuffer);
; 163  : 
; 164  : #endif // _XBOX
; 165  : 
; 166  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP	; DirectSound::CMemoryManager::PoolFree
DSOUND	ENDS
PUBLIC	?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z ; DirectSound::CMemoryManager::PhysicalAlloc
EXTRN	__imp__MmAllocateContiguousMemoryEx@20:NEAR
EXTRN	__imp__MmQueryAllocationSize@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z
DSOUND	SEGMENT
_pvBuffer$ = -4
_cbBuffer$ = 8
_cbAlignment$ = 12
_dwFlags$ = 16
_fZeroInit$ = 20
?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z PROC NEAR ; DirectSound::CMemoryManager::PhysicalAlloc, COMDAT

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 199  :     LPVOID                  pvBuffer;
; 200  : 
; 201  :     ASSERT(cbBuffer);
; 202  :     ASSERT(dwFlags);
; 203  :     
; 204  : #ifdef _XBOX
; 205  : 
; 206  :     if(pvBuffer = MmAllocateContiguousMemoryEx(cbBuffer, 0, 0xFFFFFFFF, cbAlignment, dwFlags))

  00004	8b 45 10	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _cbAlignment$[ebp]
  0000b	51		 push	 ecx
  0000c	6a ff		 push	 -1
  0000e	6a 00		 push	 0
  00010	8b 55 08	 mov	 edx, DWORD PTR _cbBuffer$[ebp]
  00013	52		 push	 edx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmAllocateContiguousMemoryEx@20
  0001a	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  0001d	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00021	74 34		 je	 SHORT $L35210

; 207  :     {
; 208  :         cbBuffer = MmQueryAllocationSize(pvBuffer);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmQueryAllocationSize@4
  0002d	89 45 08	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 209  :         m_dwPhysicalMemoryUsage += cbBuffer;

  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
  00036	03 4d 08	 add	 ecx, DWORD PTR _cbBuffer$[ebp]
  00039	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2KA, ecx ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage

; 210  : 
; 211  :         if(fZeroInit)

  0003f	83 7d 14 00	 cmp	 DWORD PTR _fZeroInit$[ebp], 0
  00043	74 12		 je	 SHORT $L35210

; 212  :         {
; 213  :             ZeroMemory(pvBuffer, cbBuffer);

  00045	8b 55 08	 mov	 edx, DWORD PTR _cbBuffer$[ebp]
  00048	52		 push	 edx
  00049	6a 00		 push	 0
  0004b	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _memset
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
$L35210:

; 214  :         }
; 215  :     }
; 216  : 
; 217  : #else // _XBOX
; 218  : 
; 219  :     if(pvBuffer = VirtualAlloc(NULL, cbBuffer, MEM_COMMIT, dwFlags))
; 220  :     {
; 221  : 
; 222  : #pragma TODO("Not able to query for size of VirtualAlloc'd buffer")
; 223  : 
; 224  :         if(fZeroInit)
; 225  :         {
; 226  :             ZeroMemory(pvBuffer, cbBuffer);
; 227  :         }
; 228  :     }
; 229  : 
; 230  : #endif // _XBOX
; 231  : 
; 232  :     else
; 233  :     {
; 234  :         DPF_RESOURCE("Out of contiguous memory");
; 235  :     }
; 236  : 
; 237  :     return pvBuffer;

  00057	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 238  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 10 00	 ret	 16			; 00000010H
?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z ENDP ; DirectSound::CMemoryManager::PhysicalAlloc
DSOUND	ENDS
PUBLIC	?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PhysicalFree
EXTRN	__imp__MmFreeContiguousMemory@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT
_cbBuffer$ = -4
_pvBuffer$ = 8
?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR ; DirectSound::CMemoryManager::PhysicalFree, COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 265  :     DWORD                   cbBuffer;
; 266  : 
; 267  :     ASSERT(pvBuffer);
; 268  : 
; 269  : #ifdef _XBOX
; 270  : 
; 271  :     cbBuffer = MmQueryAllocationSize(pvBuffer);

  00004	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00007	50		 push	 eax
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmQueryAllocationSize@4
  0000e	89 45 fc	 mov	 DWORD PTR _cbBuffer$[ebp], eax

; 272  : 
; 273  :     ASSERT(m_dwPhysicalMemoryUsage >= cbBuffer);
; 274  :     m_dwPhysicalMemoryUsage -= cbBuffer;

  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2KA ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage
  00017	2b 4d fc	 sub	 ecx, DWORD PTR _cbBuffer$[ebp]
  0001a	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_dwPhysicalMemoryUsage@CMemoryManager@DirectSound@@2KA, ecx ; DirectSound::CMemoryManager::m_dwPhysicalMemoryUsage

; 275  : 
; 276  :     MmFreeContiguousMemory(pvBuffer);

  00020	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00023	52		 push	 edx
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmFreeContiguousMemory@4

; 277  : 
; 278  : #else // _XBOX
; 279  : 
; 280  : #pragma TODO("Not able to query for size of VirtualAlloc'd buffer")
; 281  : 
; 282  :     VirtualFree(pvBuffer, 0, MEM_RELEASE);
; 283  : 
; 284  : #endif // _XBOX
; 285  : 
; 286  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP	; DirectSound::CMemoryManager::PhysicalFree
DSOUND	ENDS
PUBLIC	?Alloc@CMcpxSlopMemoryHeap@DirectSound@@QAEPAXK@Z ; DirectSound::CMcpxSlopMemoryHeap::Alloc
PUBLIC	?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::MemAlloc
; Function compile flags: /Odt
;	COMDAT ?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z
DSOUND	SEGMENT
_pvBuffer$ = -4
_nPoolTag$ = 8
_cbBuffer$ = 12
_fZeroInit$ = 16
?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z PROC NEAR ; DirectSound::CMemoryManager::MemAlloc, COMDAT

; 318  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 319  :     static const ULONG      cbLowerThreshold    = 0x20;
; 320  :     static const DWORD      cbUpperThreshold    = 0xFD8;
; 321  :     LPVOID                  pvBuffer;
; 322  : 
; 323  :     ASSERT(cbBuffer);
; 324  : 
; 325  : #ifdef MEM_SIZE_CHECK
; 326  : 
; 327  : #pragma TODO("Don't ship with this check turned on")
; 328  :     
; 329  :     if((DSOUND_OBJECT_POOL_TAG == nPoolTag) && (cbBuffer >= cbUpperThreshold))
; 330  :     {
; 331  :         ASSERTMSG("Allocating an object larger than the pool threshold");
; 332  :     }
; 333  :     else if((DSOUND_DATA_POOL_TAG == nPoolTag) && (cbBuffer < cbLowerThreshold))
; 334  :     {
; 335  :         ASSERTMSG("Allocating a buffer smaller than 32 bytes");
; 336  :     }
; 337  : 
; 338  : #endif // MEM_SIZE_CHECK
; 339  : 
; 340  :     if(CMcpxSlopMemoryHeap::m_pSlopMemoryHeap)

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A, 0 ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap
  0000b	74 32		 je	 SHORT $L35225

; 341  :     {
; 342  :         if(pvBuffer = CMcpxSlopMemoryHeap::m_pSlopMemoryHeap->Alloc(cbBuffer))

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  00010	50		 push	 eax
  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap
  00017	e8 00 00 00 00	 call	 ?Alloc@CMcpxSlopMemoryHeap@DirectSound@@QAEPAXK@Z ; DirectSound::CMcpxSlopMemoryHeap::Alloc
  0001c	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  0001f	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00023	74 18		 je	 SHORT $L35226

; 343  :         {
; 344  :             ASSERT(DSOUND_ALLOCATOR_SLOP == *((LPDWORD)pvBuffer - 1));
; 345  : 
; 346  :             if(fZeroInit)

  00025	83 7d 10 00	 cmp	 DWORD PTR _fZeroInit$[ebp], 0
  00029	74 12		 je	 SHORT $L35226

; 347  :             {
; 348  :                 ZeroMemory(pvBuffer, cbBuffer);

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  0002e	51		 push	 ecx
  0002f	6a 00		 push	 0
  00031	8b 55 fc	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 _memset
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L35226:

; 349  :             }
; 350  :         }
; 351  :     }
; 352  :     else

  0003d	eb 07		 jmp	 SHORT $L35228
$L35225:

; 353  :     {
; 354  :         pvBuffer = NULL;

  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pvBuffer$[ebp], 0
$L35228:

; 355  :     }
; 356  : 
; 357  :     if(!pvBuffer)

  00046	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  0004a	75 2f		 jne	 SHORT $L35229

; 358  :     {
; 359  :         if(pvBuffer = PoolAlloc(nPoolTag, cbBuffer + sizeof(DWORD), fZeroInit))

  0004c	8b 45 10	 mov	 eax, DWORD PTR _fZeroInit$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBuffer$[ebp]
  00053	83 c1 04	 add	 ecx, 4
  00056	51		 push	 ecx
  00057	8b 55 08	 mov	 edx, DWORD PTR _nPoolTag$[ebp]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 ?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::PoolAlloc
  00060	89 45 fc	 mov	 DWORD PTR _pvBuffer$[ebp], eax
  00063	83 7d fc 00	 cmp	 DWORD PTR _pvBuffer$[ebp], 0
  00067	74 12		 je	 SHORT $L35229

; 360  :         {
; 361  :             *(LPDWORD)pvBuffer = DSOUND_ALLOCATOR_POOL;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0006c	c7 00 70 6f 6f
	6c		 mov	 DWORD PTR [eax], 1819242352 ; 6c6f6f70H

; 362  :             pvBuffer = (LPDWORD)pvBuffer + 1;

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00075	83 c1 04	 add	 ecx, 4
  00078	89 4d fc	 mov	 DWORD PTR _pvBuffer$[ebp], ecx
$L35229:

; 363  :         }
; 364  :     }
; 365  : 
; 366  :     return pvBuffer;

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _pvBuffer$[ebp]

; 367  : }

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 0c 00	 ret	 12			; 0000000cH
?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ENDP ; DirectSound::CMemoryManager::MemAlloc
DSOUND	ENDS
PUBLIC	?Free@CMcpxSlopMemoryHeap@DirectSound@@QAEXPAX@Z ; DirectSound::CMcpxSlopMemoryHeap::Free
PUBLIC	?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z	; DirectSound::CMemoryManager::MemFree
; Function compile flags: /Odt
;	COMDAT ?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z
DSOUND	SEGMENT
_pdwSignature$ = -8
_pvBuffer$ = 8
?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z PROC NEAR	; DirectSound::CMemoryManager::MemFree, COMDAT

; 397  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 398  :     LPDWORD                 pdwSignature;
; 399  :     DWORD                   cbBuffer;
; 400  : 
; 401  :     ASSERT(pvBuffer);
; 402  : 
; 403  :     pdwSignature = (LPDWORD)pvBuffer - 1;

  00006	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00009	83 e8 04	 sub	 eax, 4
  0000c	89 45 f8	 mov	 DWORD PTR _pdwSignature$[ebp], eax

; 404  :     
; 405  :     if(DSOUND_ALLOCATOR_POOL == *pdwSignature)

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _pdwSignature$[ebp]
  00012	81 39 70 6f 6f
	6c		 cmp	 DWORD PTR [ecx], 1819242352 ; 6c6f6f70H
  00018	75 0b		 jne	 SHORT $L35240

; 406  :     {
; 407  :         PoolFree(pdwSignature);

  0001a	8b 55 f8	 mov	 edx, DWORD PTR _pdwSignature$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PoolFree

; 408  :     }
; 409  :     else if(DSOUND_ALLOCATOR_SLOP == *pdwSignature)

  00023	eb 23		 jmp	 SHORT $L35236
$L35240:
  00025	8b 45 f8	 mov	 eax, DWORD PTR _pdwSignature$[ebp]
  00028	81 38 73 6c 6f
	70		 cmp	 DWORD PTR [eax], 1886350451 ; 706f6c73H
  0002e	75 18		 jne	 SHORT $L35236

; 410  :     {
; 411  :         if(CMcpxSlopMemoryHeap::m_pSlopMemoryHeap)

  00030	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A, 0 ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap
  00037	74 0f		 je	 SHORT $L35236

; 412  :         {
; 413  :             CMcpxSlopMemoryHeap::m_pSlopMemoryHeap->Free(pvBuffer);

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  0003c	51		 push	 ecx
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap
  00043	e8 00 00 00 00	 call	 ?Free@CMcpxSlopMemoryHeap@DirectSound@@QAEXPAX@Z ; DirectSound::CMcpxSlopMemoryHeap::Free
$L35236:

; 414  :         }
; 415  :         else
; 416  :         {
; 417  :             ASSERTMSG("Slop memory heap does not exist");
; 418  :         }
; 419  :     }
; 420  :     else
; 421  :     {
; 422  :         ASSERTMSG("Invalid memory free");
; 423  :     }
; 424  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z ENDP	; DirectSound::CMemoryManager::MemFree
DSOUND	ENDS
PUBLIC	?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z ; DirectSound::CMemoryManager::DumpMemoryUsage
; Function compile flags: /Odt
;	COMDAT ?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z
DSOUND	SEGMENT
_fAssertNone$ = 8
?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z PROC NEAR ; DirectSound::CMemoryManager::DumpMemoryUsage, COMDAT

; 930  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 931  : 
; 932  : #ifdef DEBUG
; 933  : 
; 934  :     static const LPCSTR     pszBanner           = "------------------------------------------------------------------------------";
; 935  : 
; 936  : #ifdef TRACK_MEMORY_USAGE
; 937  : 
; 938  :     PLIST_ENTRY             pleEntry;
; 939  :     LPDSMEMTRACK            pTracking;
; 940  : 
; 941  : #endif // TRACK_MEMORY_USAGE
; 942  : 
; 943  :     CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);
; 944  :     CDebug::Print(pszBanner);
; 945  :     CDebug::Print("Begin memory usage dump");
; 946  :     CDebug::Print(pszBanner);
; 947  :     
; 948  : #ifdef TRACK_MEMORY_USAGE
; 949  : 
; 950  : #ifdef _XBOX
; 951  : 
; 952  :     //
; 953  :     // Raise IRQL for synchronization
; 954  :     //
; 955  : 
; 956  :     AutoIrql();
; 957  : 
; 958  : #endif // _XBOX
; 959  :    
; 960  :     //
; 961  :     // Show specifically what allocations are remaining
; 962  :     //
; 963  :     
; 964  :     if(m_lstMemoryTracking.Flink)
; 965  :     {
; 966  :         if(!IsListEmpty(&m_lstMemoryTracking))
; 967  :         {
; 968  :             for(pleEntry = m_lstMemoryTracking.Flink; pleEntry != &m_lstMemoryTracking; pleEntry = pleEntry->Flink)
; 969  :             {
; 970  :                 AssertValidEntryList(pleEntry, ASSERT_IN_LIST);
; 971  :             
; 972  :                 pTracking = CONTAINING_RECORD(pleEntry, DSMEMTRACK, leListEntry);
; 973  : 
; 974  :                 CDebug::SetContext(DPF_FLAGS_FILELINE, DPFLVL_ABSOLUTE, pTracking->pszFile, pTracking->nLine, DPF_FNAME, DPF_LIBRARY);
; 975  :                 CDebug::Print("%x (%lu bytes, type %s)", pTracking + 1, pTracking->cbSize, pTracking->pszClass);
; 976  :             }
; 977  : 
; 978  :             CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);
; 979  :             CDebug::Print(pszBanner);
; 980  :         }
; 981  :     }
; 982  : 
; 983  : #endif // TRACK_MEMORY_USAGE
; 984  : 
; 985  :     CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);
; 986  :     CDebug::Print("Pool memory used:  %lu", m_dwPoolMemoryUsage);
; 987  :     CDebug::Print("Physical memory used:  %lu", m_dwPhysicalMemoryUsage);
; 988  : 
; 989  : #ifdef ENABLE_SLOP_MEMORY_RECOVERY
; 990  : 
; 991  :     CDebug::Print("Physical memory available for recovery:  %lu", CMcpxSlopMemoryHeap::m_dwAvailable);
; 992  :     CDebug::Print("Physical memory recovered:  %lu", CMcpxSlopMemoryHeap::m_dwUsed);
; 993  : 
; 994  : #endif // ENABLE_SLOP_MEMORY_RECOVERY
; 995  : 
; 996  :     CDebug::Print(pszBanner);
; 997  :     CDebug::Print("End memory usage dump");
; 998  :     CDebug::Print(pszBanner);
; 999  : 
; 1000 : #ifdef ENABLE_SLOP_MEMORY_RECOVERY
; 1001 : 
; 1002 :     if(m_dwPoolMemoryUsage || m_dwPhysicalMemoryUsage || CMcpxSlopMemoryHeap::m_dwAvailable || CMcpxSlopMemoryHeap::m_dwUsed)
; 1003 : 
; 1004 : #else // ENABLE_SLOP_MEMORY_RECOVERY
; 1005 : 
; 1006 :     if(m_dwPoolMemoryUsage || m_dwPhysicalMemoryUsage)
; 1007 : 
; 1008 : #endif // ENABLE_SLOP_MEMORY_RECOVERY
; 1009 : 
; 1010 :     {
; 1011 :         if(fAssertNone)
; 1012 :         {
; 1013 :             __asm int 3
; 1014 :         }
; 1015 : 
; 1016 : #ifdef TRACK_MEMORY_USAGE
; 1017 : 
; 1018 :         ASSERT(!IsListEmpty(&m_lstMemoryTracking));
; 1019 : 
; 1020 : #endif // TRACK_MEMORY_USAGE
; 1021 : 
; 1022 :     }
; 1023 : 
; 1024 : #ifdef TRACK_MEMORY_USAGE
; 1025 : 
; 1026 :     else
; 1027 :     {
; 1028 :         ASSERT(IsListEmpty(&m_lstMemoryTracking));
; 1029 :     }
; 1030 : 
; 1031 : #endif // TRACK_MEMORY_USAGE
; 1032 : 
; 1033 : #endif // DEBUG
; 1034 : 
; 1035 : }

  00003	5d		 pop	 ebp
  00004	c2 04 00	 ret	 4
?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z ENDP ; DirectSound::CMemoryManager::DumpMemoryUsage
DSOUND	ENDS
PUBLIC	?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::CreatePcmFormat
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\format.cpp
;	COMDAT ?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_wBitsPerSample$ = 16
_pwfx$ = 20
?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::CreatePcmFormat, COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 54   :     DPF_ENTER();
; 55   :     
; 56   :     ASSERT(pwfx);
; 57   : 
; 58   :     pwfx->wFormatTag = WAVE_FORMAT_PCM;

  00003	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	66 c7 00 01 00	 mov	 WORD PTR [eax], 1

; 59   :     pwfx->nChannels = nChannels;

  0000b	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0000e	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  00012	66 89 51 02	 mov	 WORD PTR [ecx+2], dx

; 60   :     pwfx->nSamplesPerSec = nSamplesPerSec;

  00016	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0001c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 61   :     pwfx->wBitsPerSample = wBitsPerSample;

  0001f	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00022	66 8b 45 10	 mov	 ax, WORD PTR _wBitsPerSample$[ebp]
  00026	66 89 42 0e	 mov	 WORD PTR [edx+14], ax

; 62   :     pwfx->nBlockAlign = nChannels * wBitsPerSample / 8;

  0002a	0f b7 45 08	 movzx	 eax, WORD PTR _nChannels$[ebp]
  0002e	0f b7 4d 10	 movzx	 ecx, WORD PTR _wBitsPerSample$[ebp]
  00032	0f af c1	 imul	 eax, ecx
  00035	99		 cdq
  00036	83 e2 07	 and	 edx, 7
  00039	03 c2		 add	 eax, edx
  0003b	c1 f8 03	 sar	 eax, 3
  0003e	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00041	66 89 42 0c	 mov	 WORD PTR [edx+12], ax

; 63   :     pwfx->nAvgBytesPerSec = nSamplesPerSec * pwfx->nBlockAlign;

  00045	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00048	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0004c	8b 55 0c	 mov	 edx, DWORD PTR _nSamplesPerSec$[ebp]
  0004f	0f af d1	 imul	 edx, ecx
  00052	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00055	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 64   :     pwfx->cbSize = 0;

  00058	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0005b	66 c7 41 10 00
	00		 mov	 WORD PTR [ecx+16], 0

; 65   : 
; 66   :     DPF_LEAVE_VOID();
; 67   : }

  00061	5d		 pop	 ebp
  00062	c2 10 00	 ret	 16			; 00000010H
?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::CreatePcmFormat
DSOUND	ENDS
PUBLIC	?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::CreateXboxAdpcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_pwfx$ = 16
?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUxbox_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::WaveFormat::CreateXboxAdpcmFormat, COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 98   :     DPF_ENTER();
; 99   :     
; 100  :     ASSERT(pwfx);
; 101  : 
; 102  :     pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  00003	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	66 c7 00 69 00	 mov	 WORD PTR [eax], 105	; 00000069H

; 103  :     pwfx->wfx.nChannels = nChannels;

  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0000e	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  00012	66 89 51 02	 mov	 WORD PTR [ecx+2], dx

; 104  :     pwfx->wfx.nSamplesPerSec = nSamplesPerSec;

  00016	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0001c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 105  :     pwfx->wfx.wBitsPerSample = XBOX_ADPCM_BITS_PER_SAMPLE;

  0001f	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00022	66 c7 42 0e 04
	00		 mov	 WORD PTR [edx+14], 4

; 106  :     pwfx->wfx.nBlockAlign = nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  00028	0f b7 45 08	 movzx	 eax, WORD PTR _nChannels$[ebp]
  0002c	6b c0 24	 imul	 eax, 36			; 00000024H
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00032	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 107  :     pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec / XBOX_ADPCM_SAMPLES_PER_BLOCK * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  00036	8b 55 0c	 mov	 edx, DWORD PTR _nSamplesPerSec$[ebp]
  00039	c1 ea 06	 shr	 edx, 6
  0003c	6b d2 24	 imul	 edx, 36			; 00000024H
  0003f	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00042	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 108  :     pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);

  00045	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00048	66 c7 41 10 02
	00		 mov	 WORD PTR [ecx+16], 2

; 109  :     pwfx->wSamplesPerBlock = XBOX_ADPCM_SAMPLES_PER_BLOCK;

  0004e	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00051	66 c7 42 12 40
	00		 mov	 WORD PTR [edx+18], 64	; 00000040H

; 110  : 
; 111  :     DPF_LEAVE_VOID();
; 112  : }

  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUxbox_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::WaveFormat::CreateXboxAdpcmFormat
DSOUND	ENDS
PUBLIC	?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::CreateInternalFormat
PUBLIC	?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::PcmToInternalFormat
PUBLIC	?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::AdpcmToInternalFormat
; Function compile flags: /Odt
;	COMDAT ?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
tv65 = -8
_dwChannelMask$ = -4
_pDest$ = 8
_pSource$ = 12
?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::CreateInternalFormat, COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 142  :     DWORD                   dwChannelMask   = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwChannelMask$[ebp], 0

; 143  :     
; 144  :     DPF_ENTER();
; 145  : 
; 146  :     ASSERT(pDest);
; 147  :     ASSERT(pSource);
; 148  : 
; 149  :     switch(pSource->wFormatTag)
; 150  :     {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _pSource$[ebp]
  00010	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00013	89 4d f8	 mov	 DWORD PTR tv65[ebp], ecx
  00016	83 7d f8 01	 cmp	 DWORD PTR tv65[ebp], 1
  0001a	74 08		 je	 SHORT $L35270
  0001c	83 7d f8 69	 cmp	 DWORD PTR tv65[ebp], 105 ; 00000069H
  00020	74 11		 je	 SHORT $L35271
  00022	eb 1c		 jmp	 SHORT $L35267
$L35270:

; 151  :         case WAVE_FORMAT_PCM:
; 152  :             PcmToInternalFormat(pDest, pSource);

  00024	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00027	52		 push	 edx
  00028	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::PcmToInternalFormat

; 153  :             break;

  00031	eb 0d		 jmp	 SHORT $L35267
$L35271:

; 154  : 
; 155  :         case WAVE_FORMAT_XBOX_ADPCM:
; 156  :             AdpcmToInternalFormat(pDest, (LPCXBOXADPCMWAVEFORMAT)pSource);

  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 ?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::AdpcmToInternalFormat
$L35267:

; 157  :             break;
; 158  : 
; 159  : #if defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 160  : 
; 161  :         case WAVE_FORMAT_EXTENSIBLE:
; 162  :             dwChannelMask = ExtensibleToInternalFormat(pDest, (LPCWAVEFORMATEXTENSIBLE)pSource);
; 163  :             break;
; 164  : 
; 165  : #endif // defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 166  : 
; 167  :         default:
; 168  :             ASSERTMSG("Unexpected format tag");
; 169  :             break;
; 170  :     }
; 171  : 
; 172  :     DPF_LEAVE(dwChannelMask);
; 173  : 
; 174  :     return dwChannelMask;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _dwChannelMask$[ebp]

; 175  : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::CreateInternalFormat
DSOUND	ENDS
PUBLIC	?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::IsValidFormat
PUBLIC	?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::IsValidPcmFormat
PUBLIC	?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::IsValidAdpcmFormat
; Function compile flags: /Odt
;	COMDAT ?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
tv65 = -8
_fSuccess$ = -4
_pwfx$ = 8
?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::IsValidFormat, COMDAT

; 201  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 202  :     BOOL                    fSuccess;
; 203  :     
; 204  :     DPF_ENTER();
; 205  : 
; 206  :     ASSERT(pwfx);
; 207  : 
; 208  :     switch(pwfx->wFormatTag)
; 209  :     {

  00006	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00009	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0000c	89 4d f8	 mov	 DWORD PTR tv65[ebp], ecx
  0000f	83 7d f8 01	 cmp	 DWORD PTR tv65[ebp], 1
  00013	74 08		 je	 SHORT $L35282
  00015	83 7d f8 69	 cmp	 DWORD PTR tv65[ebp], 105 ; 00000069H
  00019	74 10		 je	 SHORT $L35283
  0001b	eb 1c		 jmp	 SHORT $L35285
$L35282:

; 210  :         case WAVE_FORMAT_PCM:
; 211  :             fSuccess = IsValidPcmFormat(pwfx);

  0001d	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::IsValidPcmFormat
  00026	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 212  :             break;

  00029	eb 15		 jmp	 SHORT $L35279
$L35283:

; 213  : 
; 214  :         case WAVE_FORMAT_XBOX_ADPCM:
; 215  :             fSuccess = IsValidAdpcmFormat((LPCXBOXADPCMWAVEFORMAT)pwfx);

  0002b	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::IsValidAdpcmFormat
  00034	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 216  :             break;

  00037	eb 07		 jmp	 SHORT $L35279
$L35285:

; 217  : 
; 218  : #if defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 219  : 
; 220  :         case WAVE_FORMAT_EXTENSIBLE:
; 221  :             fSuccess = IsValidExtensibleFormat((LPCWAVEFORMATEXTENSIBLE)pwfx);
; 222  :             break;
; 223  : 
; 224  : #endif // defined(_XBOX) && !defined(MCPX_BOOT_LIB)
; 225  : 
; 226  :         default:
; 227  :             DPF_ERROR("Unsupported format tag");
; 228  :             fSuccess = FALSE;

  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0
$L35279:

; 229  :             break;
; 230  :     }
; 231  : 
; 232  :     DPF_LEAVE(fSuccess);
; 233  : 
; 234  :     return fSuccess;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 235  : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?IsValidFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::IsValidFormat
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
_pDest$ = 8
_pSource$ = 12
?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::PcmToInternalFormat, COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 265  :     DPF_ENTER();
; 266  : 
; 267  :     ASSERT(pDest);
; 268  :     ASSERT(pSource);
; 269  : 
; 270  :     ASSERT(pSource->nChannels <= 0xFF);
; 271  :     ASSERT(pSource->wBitsPerSample <= 0xFF);
; 272  :     ASSERT(pSource->nBlockAlign <= 0xFF);
; 273  : 
; 274  :     pDest->wFormatTag = WAVE_FORMAT_PCM;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  00006	66 c7 00 01 00	 mov	 WORD PTR [eax], 1

; 275  :     pDest->nChannels = (BYTE)pSource->nChannels;

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00011	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00014	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 276  :     pDest->wBitsPerSample = (BYTE)pSource->wBitsPerSample;

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  0001a	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  0001d	8a 42 0e	 mov	 al, BYTE PTR [edx+14]
  00020	88 41 03	 mov	 BYTE PTR [ecx+3], al

; 277  :     pDest->nSamplesPerSec = pSource->nSamplesPerSec;

  00023	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  00026	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00029	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 278  :     pDest->nBlockAlign = (BYTE)pSource->nBlockAlign;

  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  00032	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00036	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  00039	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 279  : 
; 280  :     DPF_LEAVE_VOID();
; 281  : }

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
?PcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::PcmToInternalFormat
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
_fValid$ = -4
_pwfx$ = 8
?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::WaveFormat::IsValidPcmFormat, COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 308  :     BOOL                    fValid  = TRUE;

  00004	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 1

; 309  : 
; 310  :     DPF_ENTER();
; 311  : 
; 312  :     ASSERT(pwfx);
; 313  : 
; 314  :     if(WAVE_FORMAT_PCM != pwfx->wFormatTag)

  0000b	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0000e	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00011	83 f9 01	 cmp	 ecx, 1
  00014	74 07		 je	 SHORT $L35297

; 315  :     {
; 316  :         DPF_ERROR("Format tag not PCM");
; 317  :         fValid = FALSE;

  00016	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35297:

; 318  :     }
; 319  :     
; 320  :     if((1 != pwfx->nChannels) && (2 != pwfx->nChannels) && (4 != pwfx->nChannels) && (6 != pwfx->nChannels))

  0001d	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00020	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00024	83 f8 01	 cmp	 eax, 1
  00027	74 2b		 je	 SHORT $L35298
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0002c	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00030	83 fa 02	 cmp	 edx, 2
  00033	74 1f		 je	 SHORT $L35298
  00035	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00038	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  0003c	83 f9 04	 cmp	 ecx, 4
  0003f	74 13		 je	 SHORT $L35298
  00041	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00044	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00048	83 f8 06	 cmp	 eax, 6
  0004b	74 07		 je	 SHORT $L35298

; 321  :     {
; 322  :         DPF_ERROR("Invalid channel count");
; 323  :         fValid = FALSE;

  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35298:

; 324  :     }
; 325  : 
; 326  :     if((8 != pwfx->wBitsPerSample) && (16 != pwfx->wBitsPerSample))

  00054	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00057	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  0005b	83 fa 08	 cmp	 edx, 8
  0005e	74 13		 je	 SHORT $L35299
  00060	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00063	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00067	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0006a	74 07		 je	 SHORT $L35299

; 327  :     {
; 328  :         DPF_ERROR("Invalid sample bit resolution");
; 329  :         fValid = FALSE;

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35299:

; 330  :     }
; 331  : 
; 332  :     if((pwfx->nSamplesPerSec < DSBFREQUENCY_MIN) || (pwfx->nSamplesPerSec > DSBFREQUENCY_MAX))

  00073	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00076	81 7a 04 bc 00
	00 00		 cmp	 DWORD PTR [edx+4], 188	; 000000bcH
  0007d	72 0c		 jb	 SHORT $L35301
  0007f	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00082	81 78 04 ef ed
	02 00		 cmp	 DWORD PTR [eax+4], 191983 ; 0002edefH
  00089	76 07		 jbe	 SHORT $L35300
$L35301:

; 333  :     {
; 334  :         DPF_ERROR("Invalid sampling rate");
; 335  :         fValid = FALSE;

  0008b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35300:

; 336  :     }
; 337  : 
; 338  :     if(pwfx->nChannels * pwfx->wBitsPerSample / 8 != pwfx->nBlockAlign)

  00092	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00095	0f b7 41 02	 movzx	 eax, WORD PTR [ecx+2]
  00099	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  0009c	0f b7 4a 0e	 movzx	 ecx, WORD PTR [edx+14]
  000a0	0f af c1	 imul	 eax, ecx
  000a3	99		 cdq
  000a4	83 e2 07	 and	 edx, 7
  000a7	03 c2		 add	 eax, edx
  000a9	c1 f8 03	 sar	 eax, 3
  000ac	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  000af	0f b7 4a 0c	 movzx	 ecx, WORD PTR [edx+12]
  000b3	3b c1		 cmp	 eax, ecx
  000b5	74 07		 je	 SHORT $L35302

; 339  :     {
; 340  :         DPF_ERROR("Bad block alignment");
; 341  :         fValid = FALSE;

  000b7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35302:

; 342  :     }
; 343  : 
; 344  :     DPF_LEAVE(fValid);
; 345  : 
; 346  :     return fValid;

  000be	8b 45 fc	 mov	 eax, DWORD PTR _fValid$[ebp]

; 347  : }

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
?IsValidPcmFormat@WaveFormat@DirectSound@@YGHPBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::WaveFormat::IsValidPcmFormat
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT
_pDest$ = 8
_pSource$ = 12
?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::WaveFormat::AdpcmToInternalFormat, COMDAT

; 376  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 377  :     static const BYTE       wBitsPerSample      = 4;
; 378  : 
; 379  :     DPF_ENTER();
; 380  : 
; 381  :     ASSERT(pDest);
; 382  :     ASSERT(pSource);
; 383  : 
; 384  :     ASSERT(pSource->wfx.nChannels <= 0xFF);
; 385  :     ASSERT(pSource->wfx.wBitsPerSample <= 0xFF);
; 386  :     ASSERT(pSource->wfx.nBlockAlign <= 0xFF);
; 387  : 
; 388  :     pDest->wFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pDest$[ebp]
  00006	66 c7 00 69 00	 mov	 WORD PTR [eax], 105	; 00000069H

; 389  :     pDest->nChannels = (BYTE)pSource->wfx.nChannels;

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  00011	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00014	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 390  :     pDest->wBitsPerSample = (BYTE)wBitsPerSample;

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  0001a	c6 41 03 04	 mov	 BYTE PTR [ecx+3], 4

; 391  :     pDest->nSamplesPerSec = pSource->wfx.nSamplesPerSec;

  0001e	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  00021	8b 45 0c	 mov	 eax, DWORD PTR _pSource$[ebp]
  00024	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00027	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 392  :     pDest->nBlockAlign = (BYTE)pSource->wfx.nBlockAlign;

  0002a	8b 55 0c	 mov	 edx, DWORD PTR _pSource$[ebp]
  0002d	0f b6 42 0c	 movzx	 eax, BYTE PTR [edx+12]
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  00034	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 393  : 
; 394  :     DPF_LEAVE_VOID();
; 395  : }

  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
?AdpcmToInternalFormat@WaveFormat@DirectSound@@YGXPAUDSWAVEFORMAT@@PBUxbox_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::WaveFormat::AdpcmToInternalFormat
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT
_fValid$ = -4
_pwfx$ = 8
?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::WaveFormat::IsValidAdpcmFormat, COMDAT

; 421  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 422  :     static const WORD       wSamplesPerBlock    = 64;
; 423  :     static const WORD       wBitsPerSample      = 4;
; 424  :     static const WORD       wBytesPerBlock      = 36;
; 425  :     BOOL                    fValid              = TRUE;

  00004	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 1

; 426  : 
; 427  :     DPF_ENTER();
; 428  : 
; 429  :     ASSERT(pwfx);
; 430  : 
; 431  :     if(WAVE_FORMAT_XBOX_ADPCM != pwfx->wfx.wFormatTag)

  0000b	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0000e	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00011	83 f9 69	 cmp	 ecx, 105		; 00000069H
  00014	74 07		 je	 SHORT $L35322

; 432  :     {
; 433  :         DPF_ERROR("Format tag not XBOX_ADPCM");
; 434  :         fValid = FALSE;

  00016	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35322:

; 435  :     }
; 436  :     
; 437  :     if(sizeof(*pwfx) - sizeof(pwfx->wfx) != pwfx->wfx.cbSize)

  0001d	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00020	0f b7 42 10	 movzx	 eax, WORD PTR [edx+16]
  00024	83 f8 02	 cmp	 eax, 2
  00027	74 07		 je	 SHORT $L35323

; 438  :     {
; 439  :         DPF_ERROR("cbSize not %lu", sizeof(*pwfx) - sizeof(pwfx->wfx));
; 440  :         fValid = FALSE;

  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35323:

; 441  :     }
; 442  :     
; 443  :     if((pwfx->wfx.nChannels < 1) || (pwfx->wfx.nChannels > 2))

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00033	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00037	83 fa 01	 cmp	 edx, 1
  0003a	7c 0c		 jl	 SHORT $L35325
  0003c	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0003f	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00043	83 f9 02	 cmp	 ecx, 2
  00046	7e 07		 jle	 SHORT $L35324
$L35325:

; 444  :     {
; 445  :         DPF_ERROR("Invalid channel count");
; 446  :         fValid = FALSE;

  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35324:

; 447  :     }
; 448  : 
; 449  :     if((pwfx->wfx.nSamplesPerSec < DSBFREQUENCY_MIN) || (pwfx->wfx.nSamplesPerSec > DSBFREQUENCY_MAX))

  0004f	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00052	81 7a 04 bc 00
	00 00		 cmp	 DWORD PTR [edx+4], 188	; 000000bcH
  00059	72 0c		 jb	 SHORT $L35327
  0005b	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0005e	81 78 04 ef ed
	02 00		 cmp	 DWORD PTR [eax+4], 191983 ; 0002edefH
  00065	76 07		 jbe	 SHORT $L35326
$L35327:

; 450  :     {
; 451  :         DPF_ERROR("Invalid sampling rate");
; 452  :         fValid = FALSE;

  00067	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35326:

; 453  :     }
; 454  : 
; 455  :     if(wBitsPerSample != pwfx->wfx.wBitsPerSample)

  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00071	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  00075	83 fa 04	 cmp	 edx, 4
  00078	74 07		 je	 SHORT $L35328

; 456  :     {
; 457  :         DPF_ERROR("Invalid sample bit resolution");
; 458  :         fValid = FALSE;

  0007a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35328:

; 459  :     }
; 460  : 
; 461  :     if(wSamplesPerBlock != pwfx->wSamplesPerBlock)

  00081	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00084	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00088	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0008b	74 07		 je	 SHORT $L35329

; 462  :     {
; 463  :         DPF_ERROR("Invalid samples per block");
; 464  :         fValid = FALSE;

  0008d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35329:

; 465  :     }
; 466  : 
; 467  :     if(wBytesPerBlock * pwfx->wfx.nChannels != pwfx->wfx.nBlockAlign)

  00094	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00097	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  0009b	6b c0 24	 imul	 eax, 36			; 00000024H
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  000a1	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  000a5	3b c2		 cmp	 eax, edx
  000a7	74 07		 je	 SHORT $L35330

; 468  :     {
; 469  :         DPF_ERROR("Bad block-alignment");
; 470  :         fValid = FALSE;

  000a9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fValid$[ebp], 0
$L35330:

; 471  :     }
; 472  : 
; 473  :     DPF_LEAVE(fValid);
; 474  : 
; 475  :     return fValid;

  000b0	8b 45 fc	 mov	 eax, DWORD PTR _fValid$[ebp]

; 476  : }

  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 04 00	 ret	 4
?IsValidAdpcmFormat@WaveFormat@DirectSound@@YGHPBUxbox_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::WaveFormat::IsValidAdpcmFormat
DSOUND	ENDS
PUBLIC	??0CStdFileStream@WaveLoader@@QAE@XZ		; WaveLoader::CStdFileStream::CStdFileStream
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\waveldr.cpp
;	COMDAT ??0CStdFileStream@WaveLoader@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CStdFileStream@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CStdFileStream::CStdFileStream, COMDAT
; _this$ = ecx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 102  :     DPF_ENTER();
; 103  : 
; 104  :     //
; 105  :     // Initialize defaults
; 106  :     //
; 107  : 
; 108  :     m_hFile = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 109  :     m_dwFlags = 0;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 110  : 
; 111  :     DPF_LEAVE_VOID();
; 112  : }

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0CStdFileStream@WaveLoader@@QAE@XZ ENDP		; WaveLoader::CStdFileStream::CStdFileStream
DSOUND	ENDS
PUBLIC	??1CStdFileStream@WaveLoader@@QAE@XZ		; WaveLoader::CStdFileStream::~CStdFileStream
PUBLIC	?Close@CStdFileStream@WaveLoader@@QAEXXZ	; WaveLoader::CStdFileStream::Close
; Function compile flags: /Odt
;	COMDAT ??1CStdFileStream@WaveLoader@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CStdFileStream@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CStdFileStream::~CStdFileStream, COMDAT
; _this$ = ecx

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 138  :     DPF_ENTER();
; 139  : 
; 140  :     Close();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Close@CStdFileStream@WaveLoader@@QAEXXZ ; WaveLoader::CStdFileStream::Close

; 141  : 
; 142  :     DPF_LEAVE_VOID();
; 143  : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CStdFileStream@WaveLoader@@QAE@XZ ENDP		; WaveLoader::CStdFileStream::~CStdFileStream
DSOUND	ENDS
PUBLIC	?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z	; WaveLoader::CStdFileStream::Open
EXTRN	_CreateFileA@28:NEAR
; Function compile flags: /Odt
;	COMDAT ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
_pszFileName$ = 8
_dwDesiredAccess$ = 12
_dwShareMode$ = 16
_dwCreationDisposition$ = 20
_dwFlagsAndAttributes$ = 24
?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z PROC NEAR ; WaveLoader::CStdFileStream::Open, COMDAT
; _this$ = ecx

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 178  :     HRESULT                 hr  = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 179  : 
; 180  :     DPF_ENTER();
; 181  : 
; 182  :     ASSERT(!IS_VALID_HANDLE_VALUE(m_hFile));
; 183  :     
; 184  :     m_hFile = CreateFile(pszFileName, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);

  00010	6a 00		 push	 0
  00012	8b 45 18	 mov	 eax, DWORD PTR _dwFlagsAndAttributes$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 14	 mov	 ecx, DWORD PTR _dwCreationDisposition$[ebp]
  00019	51		 push	 ecx
  0001a	6a 00		 push	 0
  0001c	8b 55 10	 mov	 edx, DWORD PTR _dwShareMode$[ebp]
  0001f	52		 push	 edx
  00020	8b 45 0c	 mov	 eax, DWORD PTR _dwDesiredAccess$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _pszFileName$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _CreateFileA@28
  0002d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00030	89 02		 mov	 DWORD PTR [edx], eax

; 185  : 
; 186  :     if(INVALID_HANDLE_VALUE == m_hFile)

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00038	75 09		 jne	 SHORT $L35357

; 187  :     {
; 188  :         m_hFile = NULL;

  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L35357:

; 189  :     }
; 190  : 
; 191  :     if(!m_hFile)

  00043	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00046	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00049	75 07		 jne	 SHORT $L35358

; 192  :     {
; 193  :         DPF_ERROR("Error %lu occurred trying to open %s", GetLastError(), pszFileName);
; 194  :         hr = E_FAIL;

  0004b	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35358:

; 195  :     }
; 196  : 
; 197  :     DPF_LEAVE_HRESULT(hr);
; 198  : 
; 199  :     return hr;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 200  : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 14 00	 ret	 20			; 00000014H
?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z ENDP	; WaveLoader::CStdFileStream::Open
DSOUND	ENDS
PUBLIC	?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z	; WaveLoader::CStdFileStream::Attach
; Function compile flags: /Odt
;	COMDAT ?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z
DSOUND	SEGMENT
_this$ = -4
_hFile$ = 8
?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z PROC NEAR	; WaveLoader::CStdFileStream::Attach, COMDAT
; _this$ = ecx

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 227  :     DPF_ENTER();
; 228  : 
; 229  :     ASSERT(!IS_VALID_HANDLE_VALUE(m_hFile));
; 230  :     
; 231  :     m_hFile = hFile;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _hFile$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 232  :     m_dwFlags |= FILESTREAM_FLAGS_ATTACHED;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00015	83 c8 01	 or	 eax, 1
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 233  : 
; 234  :     DPF_LEAVE_VOID();
; 235  : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z ENDP	; WaveLoader::CStdFileStream::Attach
DSOUND	ENDS
EXTRN	_CloseHandle@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Close@CStdFileStream@WaveLoader@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Close@CStdFileStream@WaveLoader@@QAEXXZ PROC NEAR	; WaveLoader::CStdFileStream::Close, COMDAT
; _this$ = ecx

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 262  :     DPF_ENTER();
; 263  :     
; 264  :     if(m_dwFlags & FILESTREAM_FLAGS_ATTACHED)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	83 e1 01	 and	 ecx, 1
  00010	85 c9		 test	 ecx, ecx
  00012	74 1a		 je	 SHORT $L35368

; 265  :     {
; 266  :         m_hFile = NULL;

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 267  :         m_dwFlags &= ~FILESTREAM_FLAGS_ATTACHED;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00023	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 268  :     }
; 269  :     else

  0002c	eb 24		 jmp	 SHORT $L35367
$L35368:

; 270  :     {
; 271  :         CLOSE_HANDLE(m_hFile);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 38 00	 cmp	 DWORD PTR [eax], 0
  00034	74 1c		 je	 SHORT $L35367
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  0003c	74 14		 je	 SHORT $L35367
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 02		 mov	 eax, DWORD PTR [edx]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _CloseHandle@4
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L35367:

; 272  :     }
; 273  : 
; 274  :     DPF_LEAVE_VOID();
; 275  : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?Close@CStdFileStream@WaveLoader@@QAEXXZ ENDP		; WaveLoader::CStdFileStream::Close
DSOUND	ENDS
PUBLIC	?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z	; WaveLoader::CStdFileStream::Read
EXTRN	_ReadFile@20:NEAR
; Function compile flags: /Odt
;	COMDAT ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z
DSOUND	SEGMENT
_this$ = -12
_hr$ = -8
_dwRead$ = -4
_pvBuffer$ = 8
_dwBufferSize$ = 12
_pdwRead$ = 16
?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z PROC NEAR ; WaveLoader::CStdFileStream::Read, COMDAT
; _this$ = ecx

; 305  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 306  :     HRESULT                 hr      = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 307  :     DWORD                   dwRead;
; 308  : 
; 309  :     DPF_ENTER();
; 310  :     
; 311  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));
; 312  :     
; 313  :     if(!ReadFile(m_hFile, pvBuffer, dwBufferSize, &dwRead, NULL))

  00010	6a 00		 push	 0
  00012	8d 45 fc	 lea	 eax, DWORD PTR _dwRead$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 _ReadFile@20
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $L35381

; 314  :     {
; 315  :         DPF_ERROR("Error %lu occurred reading from the file", GetLastError());
; 316  :         hr = E_FAIL;

  0002d	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35381:

; 317  :     }
; 318  : 
; 319  :     if(SUCCEEDED(hr))

  00034	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00038	7c 1f		 jl	 SHORT $L35384

; 320  :     {
; 321  :         if(pdwRead)

  0003a	83 7d 10 00	 cmp	 DWORD PTR _pdwRead$[ebp], 0
  0003e	74 0a		 je	 SHORT $L35385

; 322  :         {
; 323  :             *pdwRead = dwRead;

  00040	8b 55 10	 mov	 edx, DWORD PTR _pdwRead$[ebp]
  00043	8b 45 fc	 mov	 eax, DWORD PTR _dwRead$[ebp]
  00046	89 02		 mov	 DWORD PTR [edx], eax

; 324  :         }
; 325  :         else if(dwRead != dwBufferSize)

  00048	eb 0f		 jmp	 SHORT $L35384
$L35385:
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _dwRead$[ebp]
  0004d	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00050	74 07		 je	 SHORT $L35384

; 326  :         {
; 327  :             DPF_ERROR("Not enough data was read from the file");
; 328  :             hr = E_FAIL;

  00052	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35384:

; 329  :         }
; 330  :     }
; 331  : 
; 332  :     DPF_LEAVE_HRESULT(hr);
; 333  : 
; 334  :     return hr;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 335  : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 0c 00	 ret	 12			; 0000000cH
?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z ENDP	; WaveLoader::CStdFileStream::Read
DSOUND	ENDS
PUBLIC	?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z	; WaveLoader::CStdFileStream::Write
EXTRN	_WriteFile@20:NEAR
; Function compile flags: /Odt
;	COMDAT ?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z
DSOUND	SEGMENT
_this$ = -12
_dwWritten$ = -8
_hr$ = -4
_pvBuffer$ = 8
_dwBufferSize$ = 12
_pdwWritten$ = 16
?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z PROC NEAR ; WaveLoader::CStdFileStream::Write, COMDAT
; _this$ = ecx

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 366  :     HRESULT                 hr          = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 367  :     DWORD                   dwWritten;
; 368  : 
; 369  :     DPF_ENTER();
; 370  :     
; 371  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));
; 372  :     
; 373  :     if(!WriteFile(m_hFile, pvBuffer, dwBufferSize, &dwWritten, NULL))

  00010	6a 00		 push	 0
  00012	8d 45 f8	 lea	 eax, DWORD PTR _dwWritten$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 08	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 _WriteFile@20
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $L35398

; 374  :     {
; 375  :         DPF_ERROR("Error %lu occurred writing to the file", GetLastError());
; 376  :         hr = E_FAIL;

  0002d	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35398:

; 377  :     }
; 378  : 
; 379  :     if(SUCCEEDED(hr))

  00034	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00038	7c 1f		 jl	 SHORT $L35401

; 380  :     {
; 381  :         if(pdwWritten)

  0003a	83 7d 10 00	 cmp	 DWORD PTR _pdwWritten$[ebp], 0
  0003e	74 0a		 je	 SHORT $L35402

; 382  :         {
; 383  :             *pdwWritten = dwWritten;

  00040	8b 55 10	 mov	 edx, DWORD PTR _pdwWritten$[ebp]
  00043	8b 45 f8	 mov	 eax, DWORD PTR _dwWritten$[ebp]
  00046	89 02		 mov	 DWORD PTR [edx], eax

; 384  :         }
; 385  :         else if(dwWritten != dwBufferSize)

  00048	eb 0f		 jmp	 SHORT $L35401
$L35402:
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _dwWritten$[ebp]
  0004d	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00050	74 07		 je	 SHORT $L35401

; 386  :         {
; 387  :             DPF_ERROR("Not enough data was written from the file");
; 388  :             hr = E_FAIL;

  00052	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35401:

; 389  :         }
; 390  :     }
; 391  : 
; 392  :     DPF_LEAVE_HRESULT(hr);
; 393  : 
; 394  :     return hr;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 395  : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 0c 00	 ret	 12			; 0000000cH
?Write@CStdFileStream@WaveLoader@@QAEJPBXKPAK@Z ENDP	; WaveLoader::CStdFileStream::Write
DSOUND	ENDS
PUBLIC	?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z	; WaveLoader::CStdFileStream::Seek
EXTRN	_SetFilePointer@16:NEAR
; Function compile flags: /Odt
;	COMDAT ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z
DSOUND	SEGMENT
_this$ = -12
_hr$ = -8
_dwAbsolute$ = -4
_lOffset$ = 8
_dwOrigin$ = 12
_pdwAbsolute$ = 16
?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z PROC NEAR	; WaveLoader::CStdFileStream::Seek, COMDAT
; _this$ = ecx

; 425  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 426  :     HRESULT                 hr          = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 427  :     DWORD                   dwAbsolute;
; 428  :     
; 429  :     DPF_ENTER();
; 430  : 
; 431  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));
; 432  :     
; 433  :     if((dwAbsolute = SetFilePointer(m_hFile, lOffset, NULL, dwOrigin)) == INVALID_SET_FILE_POINTER)

  00010	8b 45 0c	 mov	 eax, DWORD PTR _dwOrigin$[ebp]
  00013	50		 push	 eax
  00014	6a 00		 push	 0
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _lOffset$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 02		 mov	 eax, DWORD PTR [edx]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _SetFilePointer@16
  00025	89 45 fc	 mov	 DWORD PTR _dwAbsolute$[ebp], eax
  00028	83 7d fc ff	 cmp	 DWORD PTR _dwAbsolute$[ebp], -1
  0002c	75 07		 jne	 SHORT $L35416

; 434  :     {
; 435  :         DPF_ERROR("Error %lu occurred seeking the file", GetLastError());
; 436  :         hr = E_FAIL;

  0002e	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35416:

; 437  :     }
; 438  : 
; 439  :     if(SUCCEEDED(hr) && pdwAbsolute)

  00035	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00039	7c 0e		 jl	 SHORT $L35419
  0003b	83 7d 10 00	 cmp	 DWORD PTR _pdwAbsolute$[ebp], 0
  0003f	74 08		 je	 SHORT $L35419

; 440  :     {
; 441  :         *pdwAbsolute = dwAbsolute;

  00041	8b 4d 10	 mov	 ecx, DWORD PTR _pdwAbsolute$[ebp]
  00044	8b 55 fc	 mov	 edx, DWORD PTR _dwAbsolute$[ebp]
  00047	89 11		 mov	 DWORD PTR [ecx], edx
$L35419:

; 442  :     }
; 443  : 
; 444  :     DPF_LEAVE_HRESULT(hr);
; 445  : 
; 446  :     return hr;

  00049	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 447  : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 0c 00	 ret	 12			; 0000000cH
?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z ENDP	; WaveLoader::CStdFileStream::Seek
DSOUND	ENDS
PUBLIC	?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z	; WaveLoader::CStdFileStream::GetLength
EXTRN	_GetFileSize@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
_pdwLength$ = 8
?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z PROC NEAR ; WaveLoader::CStdFileStream::GetLength, COMDAT
; _this$ = ecx

; 473  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 474  :     HRESULT                 hr  = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 475  :     
; 476  :     DPF_ENTER();
; 477  : 
; 478  :     ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));
; 479  :     
; 480  :     if((*pdwLength = GetFileSize(m_hFile, NULL)) == -1)

  00010	6a 00		 push	 0
  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _GetFileSize@8
  0001d	8b 55 08	 mov	 edx, DWORD PTR _pdwLength$[ebp]
  00020	89 02		 mov	 DWORD PTR [edx], eax
  00022	8b 45 08	 mov	 eax, DWORD PTR _pdwLength$[ebp]
  00025	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00028	75 07		 jne	 SHORT $L35426

; 481  :     {
; 482  :         DPF_ERROR("Error %lu attempting to get the file size", GetLastError());
; 483  :         hr = E_FAIL;

  0002a	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35426:

; 484  :     }
; 485  : 
; 486  :     DPF_LEAVE_HRESULT(hr);
; 487  : 
; 488  :     return hr;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 489  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?GetLength@CStdFileStream@WaveLoader@@QAEJPAK@Z ENDP	; WaveLoader::CStdFileStream::GetLength
DSOUND	ENDS
PUBLIC	??0CRiffChunk@WaveLoader@@QAE@XZ		; WaveLoader::CRiffChunk::CRiffChunk
; Function compile flags: /Odt
;	COMDAT ??0CRiffChunk@WaveLoader@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CRiffChunk@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CRiffChunk::CRiffChunk, COMDAT
; _this$ = ecx

; 514  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 515  :     DPF_ENTER();
; 516  : 
; 517  :     //
; 518  :     // Initialize defaults
; 519  :     //
; 520  : 
; 521  :     m_pParentChunk = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 522  :     m_pStream = NULL;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 523  :     m_dwChunkId = 0;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 524  :     m_dwDataOffset = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 525  :     m_dwDataSize = 0;

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 526  :     m_dwFlags = 0;

  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 527  : 
; 528  :     DPF_LEAVE_VOID();
; 529  : }

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??0CRiffChunk@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CRiffChunk::CRiffChunk
DSOUND	ENDS
PUBLIC	??1CRiffChunk@WaveLoader@@QAE@XZ		; WaveLoader::CRiffChunk::~CRiffChunk
; Function compile flags: /Odt
;	COMDAT ??1CRiffChunk@WaveLoader@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CRiffChunk@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CRiffChunk::~CRiffChunk, COMDAT
; _this$ = ecx

; 554  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  :     DPF_ENTER();
; 556  :     DPF_LEAVE_VOID();
; 557  : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1CRiffChunk@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CRiffChunk::~CRiffChunk
DSOUND	ENDS
PUBLIC	?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
; Function compile flags: /Odt
;	COMDAT ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z
DSOUND	SEGMENT
_this$ = -20
_rhRiffHeader$ = -16
_hr$ = -8
_lOffset$ = -4
_pParentChunk$ = 8
_pStream$ = 12
_dwChunkId$ = 16
?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z PROC NEAR ; WaveLoader::CRiffChunk::Open, COMDAT
; _this$ = ecx

; 587  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 588  :     LONG                    lOffset;
; 589  :     RIFFHEADER              rhRiffHeader;
; 590  :     HRESULT                 hr;
; 591  : 
; 592  :     DPF_ENTER();
; 593  :     
; 594  :     m_pParentChunk = pParentChunk;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pParentChunk$[ebp]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx

; 595  :     m_pStream = pStream;

  00011	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  00017	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 596  : 
; 597  :     //
; 598  :     // Seek to the first byte of the parent chunk's data section
; 599  :     //
; 600  : 
; 601  :     if(m_pParentChunk)

  0001a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00020	74 32		 je	 SHORT $L35445

; 602  :     {
; 603  :         lOffset = m_pParentChunk->m_dwDataOffset;

  00022	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002a	89 4d fc	 mov	 DWORD PTR _lOffset$[ebp], ecx

; 604  : 
; 605  :         //
; 606  :         // Special case the RIFF chunk
; 607  :         //
; 608  : 
; 609  :         if((WAVELDR_FOURCC_RIFF == m_pParentChunk->m_dwChunkId) || (WAVELDR_FOURCC_FORM == m_pParentChunk->m_dwChunkId))

  0002d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	81 78 08 52 49
	46 46		 cmp	 DWORD PTR [eax+8], 1179011410 ; 46464952H
  00039	74 0e		 je	 SHORT $L35447
  0003b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	81 7a 08 46 4f
	52 4d		 cmp	 DWORD PTR [edx+8], 1297239878 ; 4d524f46H
  00047	75 09		 jne	 SHORT $L35446
$L35447:

; 610  :         {
; 611  :             lOffset += sizeof(DWORD);

  00049	8b 45 fc	 mov	 eax, DWORD PTR _lOffset$[ebp]
  0004c	83 c0 04	 add	 eax, 4
  0004f	89 45 fc	 mov	 DWORD PTR _lOffset$[ebp], eax
$L35446:

; 612  :         }
; 613  :     }
; 614  :     else

  00052	eb 07		 jmp	 SHORT $L35450
$L35445:

; 615  :     {
; 616  :         lOffset = 0;

  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lOffset$[ebp], 0
$L35450:

; 617  :     }
; 618  : 
; 619  :     //
; 620  :     // If this is the top level chunk, just read the first 8 bytes.  If not,
; 621  :     // search the parent chunk until we find the one we're looking for.
; 622  :     //
; 623  : 
; 624  :     do
; 625  :     {
; 626  :         hr = m_pStream->Seek(lOffset, FILE_BEGIN, NULL);

  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _lOffset$[ebp]
  00062	51		 push	 ecx
  00063	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00069	e8 00 00 00 00	 call	 ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z ; WaveLoader::CStdFileStream::Seek
  0006e	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 627  : 
; 628  :         if(SUCCEEDED(hr))

  00071	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00075	7c 16		 jl	 SHORT $L35454

; 629  :         {
; 630  :             hr = m_pStream->Read(&rhRiffHeader, sizeof(rhRiffHeader), NULL);

  00077	6a 00		 push	 0
  00079	6a 08		 push	 8
  0007b	8d 45 f0	 lea	 eax, DWORD PTR _rhRiffHeader$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00085	e8 00 00 00 00	 call	 ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z ; WaveLoader::CStdFileStream::Read
  0008a	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L35454:

; 631  :         }
; 632  : 
; 633  :         if(SUCCEEDED(hr) && m_pParentChunk)

  0008d	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00091	7c 21		 jl	 SHORT $L35456
  00093	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00096	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00099	74 19		 je	 SHORT $L35456

; 634  :         {
; 635  :             if(WAVELDR_FOURCC_FORM == m_pParentChunk->m_dwChunkId)

  0009b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	81 79 08 46 4f
	52 4d		 cmp	 DWORD PTR [ecx+8], 1297239878 ; 4d524f46H
  000a7	75 0b		 jne	 SHORT $L35456

; 636  :             {
; 637  :                 rhRiffHeader.dwDataSize = EndianSwapDword(rhRiffHeader.dwDataSize);

  000a9	8b 4d f4	 mov	 ecx, DWORD PTR _rhRiffHeader$[ebp+4]
  000ac	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  000b1	89 45 f4	 mov	 DWORD PTR _rhRiffHeader$[ebp+4], eax
$L35456:

; 638  :             }
; 639  :         }
; 640  : 
; 641  :         if(SUCCEEDED(hr) && (dwChunkId == rhRiffHeader.dwChunkId))

  000b4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b8	7c 0a		 jl	 SHORT $L35459
  000ba	8b 55 10	 mov	 edx, DWORD PTR _dwChunkId$[ebp]
  000bd	3b 55 f0	 cmp	 edx, DWORD PTR _rhRiffHeader$[ebp]
  000c0	75 02		 jne	 SHORT $L35459

; 642  :         {
; 643  :             break;

  000c2	eb 32		 jmp	 SHORT $L35452
$L35459:

; 644  :         }
; 645  : 
; 646  :         if(SUCCEEDED(hr) && !m_pParentChunk)

  000c4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000c8	7c 0f		 jl	 SHORT $L35461
  000ca	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	83 38 00	 cmp	 DWORD PTR [eax], 0
  000d0	75 07		 jne	 SHORT $L35461

; 647  :         {
; 648  :             hr = E_FAIL;

  000d2	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35461:

; 649  :         }
; 650  : 
; 651  :         if(SUCCEEDED(hr))

  000d9	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000dd	7c 0d		 jl	 SHORT $L35451

; 652  :         {
; 653  :             lOffset += sizeof(rhRiffHeader) + rhRiffHeader.dwDataSize;

  000df	8b 4d f4	 mov	 ecx, DWORD PTR _rhRiffHeader$[ebp+4]
  000e2	8b 55 fc	 mov	 edx, DWORD PTR _lOffset$[ebp]
  000e5	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  000e9	89 45 fc	 mov	 DWORD PTR _lOffset$[ebp], eax
$L35451:

; 654  :         }
; 655  :     }
; 656  :     while(SUCCEEDED(hr));

  000ec	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000f0	0f 8d 65 ff ff
	ff		 jge	 $L35450
$L35452:

; 657  : 
; 658  :     //
; 659  :     // Success
; 660  :     //
; 661  : 
; 662  :     if(SUCCEEDED(hr))

  000f6	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000fa	7c 2d		 jl	 SHORT $L35467

; 663  :     {
; 664  :         m_dwChunkId = dwChunkId;

  000fc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	8b 55 10	 mov	 edx, DWORD PTR _dwChunkId$[ebp]
  00102	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 665  :         m_dwDataOffset = lOffset + sizeof(rhRiffHeader);

  00105	8b 45 fc	 mov	 eax, DWORD PTR _lOffset$[ebp]
  00108	83 c0 08	 add	 eax, 8
  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 666  :         m_dwDataSize = rhRiffHeader.dwDataSize;

  00111	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00114	8b 45 f4	 mov	 eax, DWORD PTR _rhRiffHeader$[ebp+4]
  00117	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 667  :         m_dwFlags |= RIFFCHUNK_FLAGS_VALID;

  0011a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00120	83 ca 01	 or	 edx, 1
  00123	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00126	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L35467:

; 668  :     }
; 669  : 
; 670  :     DPF_LEAVE_HRESULT(hr);
; 671  : 
; 672  :     return hr;

  00129	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 673  : }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 0c 00	 ret	 12			; 0000000cH
?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ENDP ; WaveLoader::CRiffChunk::Open
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?EndianSwapDword@@YIKK@Z
DSOUND	SEGMENT
_n$ = -4
?EndianSwapDword@@YIKK@Z PROC NEAR			; EndianSwapDword, COMDAT
; _n$ = ecx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx

; 55   :     __asm
; 56   :     {
; 57   :         mov     eax, ecx

  00008	8b c1		 mov	 eax, ecx

; 58   :         sar     eax, 24

  0000a	c1 f8 18	 sar	 eax, 24			; 00000018H

; 59   :         and     eax, 0ffh

  0000d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 60   : 
; 61   :         mov     ebx, ecx

  00012	8b d9		 mov	 ebx, ecx

; 62   :         sar     ebx, 8

  00014	c1 fb 08	 sar	 ebx, 8

; 63   :         and     ebx, 0ff00h

  00017	81 e3 00 ff 00
	00		 and	 ebx, 65280		; 0000ff00H

; 64   :         or      eax, ebx

  0001d	0b c3		 or	 eax, ebx

; 65   : 
; 66   :         mov     ebx, ecx

  0001f	8b d9		 mov	 ebx, ecx

; 67   :         shl     ebx, 8

  00021	c1 e3 08	 shl	 ebx, 8

; 68   :         and     ebx, 0ff0000h

  00024	81 e3 00 00 ff
	00		 and	 ebx, 16711680		; 00ff0000H

; 69   :         or      eax, ebx

  0002a	0b c3		 or	 eax, ebx

; 70   : 
; 71   :         mov     ebx, ecx

  0002c	8b d9		 mov	 ebx, ecx

; 72   :         shl     ebx, 24

  0002e	c1 e3 18	 shl	 ebx, 24			; 00000018H

; 73   :         and     ebx, 0ff000000h

  00031	81 e3 00 00 00
	ff		 and	 ebx, -16777216		; ff000000H

; 74   :         or      eax, ebx

  00037	0b c3		 or	 eax, ebx

; 75   :     }
; 76   : }

  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?EndianSwapDword@@YIKK@Z ENDP				; EndianSwapDword
DSOUND	ENDS
PUBLIC	?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z	; WaveLoader::CRiffChunk::Read
; Function compile flags: /Odt
;	COMDAT ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
_dwOffset$ = 8
_pvBuffer$ = 12
_dwBufferSize$ = 16
_pdwRead$ = 20
?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z PROC NEAR	; WaveLoader::CRiffChunk::Read, COMDAT
; _this$ = ecx

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 706  :     HRESULT                 hr  = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 707  : 
; 708  :     DPF_ENTER();
; 709  : 
; 710  :     if(dwOffset + dwBufferSize > m_dwDataSize)

  00010	8b 45 08	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  00013	03 45 10	 add	 eax, DWORD PTR _dwBufferSize$[ebp]
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0001c	76 37		 jbe	 SHORT $L35477

; 711  :     {
; 712  :         if(dwOffset >= m_dwDataSize)

  0001e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 45 08	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  00024	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  00027	72 09		 jb	 SHORT $L35478

; 713  :         {
; 714  :             dwBufferSize = 0;

  00029	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _dwBufferSize$[ebp], 0

; 715  :         }
; 716  :         else

  00030	eb 0c		 jmp	 SHORT $L35479
$L35478:

; 717  :         {
; 718  :             dwBufferSize = m_dwDataSize - dwOffset;

  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00038	2b 55 08	 sub	 edx, DWORD PTR _dwOffset$[ebp]
  0003b	89 55 10	 mov	 DWORD PTR _dwBufferSize$[ebp], edx
$L35479:

; 719  :         }
; 720  : 
; 721  :         if(pdwRead)

  0003e	83 7d 14 00	 cmp	 DWORD PTR _pdwRead$[ebp], 0
  00042	74 0a		 je	 SHORT $L35480

; 722  :         {
; 723  :             *pdwRead = dwBufferSize;

  00044	8b 45 14	 mov	 eax, DWORD PTR _pdwRead$[ebp]
  00047	8b 4d 10	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  0004a	89 08		 mov	 DWORD PTR [eax], ecx

; 724  :         }
; 725  :         else

  0004c	eb 07		 jmp	 SHORT $L35477
$L35480:

; 726  :         {
; 727  :             DPF_ERROR("Attempted to read past the end of the chunk");
; 728  :             hr = E_FAIL;

  0004e	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35477:

; 729  :         }
; 730  :     }
; 731  : 
; 732  :     if(SUCCEEDED(hr))

  00055	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00059	7c 1c		 jl	 SHORT $L35484

; 733  :     {
; 734  :         hr = m_pStream->Seek(m_dwDataOffset + dwOffset, FILE_BEGIN, NULL);

  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00062	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00065	03 45 08	 add	 eax, DWORD PTR _dwOffset$[ebp]
  00068	50		 push	 eax
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0006f	e8 00 00 00 00	 call	 ?Seek@CStdFileStream@WaveLoader@@QAEJJKPAK@Z ; WaveLoader::CStdFileStream::Seek
  00074	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L35484:

; 735  :     }
; 736  : 
; 737  :     if(SUCCEEDED(hr))

  00077	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0007b	7c 18		 jl	 SHORT $L35486

; 738  :     {
; 739  :         hr = m_pStream->Read(pvBuffer, dwBufferSize, NULL);

  0007d	6a 00		 push	 0
  0007f	8b 55 10	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  00082	52		 push	 edx
  00083	8b 45 0c	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00086	50		 push	 eax
  00087	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0008d	e8 00 00 00 00	 call	 ?Read@CStdFileStream@WaveLoader@@QAEJPAXKPAK@Z ; WaveLoader::CStdFileStream::Read
  00092	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L35486:

; 740  :     }
; 741  : 
; 742  :     DPF_LEAVE_HRESULT(hr);
; 743  : 
; 744  :     return hr;

  00095	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 745  : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 10 00	 ret	 16			; 00000010H
?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ENDP	; WaveLoader::CRiffChunk::Read
DSOUND	ENDS
PUBLIC	??0CWaveFile@WaveLoader@@QAE@XZ			; WaveLoader::CWaveFile::CWaveFile
; Function compile flags: /Odt
;	COMDAT ??0CWaveFile@WaveLoader@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CWaveFile@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CWaveFile::CWaveFile, COMDAT
; _this$ = ecx

; 770  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::CStdFileStream
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 20	 add	 ecx, 32			; 00000020H
  00020	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 771  :     DPF_ENTER();
; 772  : 
; 773  :     m_dwFileType = -1;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c7 40 38 ff ff
	ff ff		 mov	 DWORD PTR [eax+56], -1

; 774  :     m_pwfxFormat = NULL;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 775  : 
; 776  :     DPF_LEAVE_VOID();
; 777  : }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??0CWaveFile@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CWaveFile::CWaveFile
DSOUND	ENDS
PUBLIC	??1CWaveFile@WaveLoader@@QAE@XZ			; WaveLoader::CWaveFile::~CWaveFile
PUBLIC	?Close@CWaveFile@WaveLoader@@QAEXXZ		; WaveLoader::CWaveFile::Close
; Function compile flags: /Odt
;	COMDAT ??1CWaveFile@WaveLoader@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CWaveFile@WaveLoader@@QAE@XZ PROC NEAR		; WaveLoader::CWaveFile::~CWaveFile, COMDAT
; _this$ = ecx

; 802  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 803  :     DPF_ENTER();
; 804  : 
; 805  :     Close();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Close@CWaveFile@WaveLoader@@QAEXXZ ; WaveLoader::CWaveFile::Close

; 806  : 
; 807  :     DPF_LEAVE_VOID();
; 808  : }

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 20	 add	 ecx, 32			; 00000020H
  00015	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ??1CStdFileStream@WaveLoader@@QAE@XZ ; WaveLoader::CStdFileStream::~CStdFileStream
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??1CWaveFile@WaveLoader@@QAE@XZ ENDP			; WaveLoader::CWaveFile::~CWaveFile
DSOUND	ENDS
PUBLIC	?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z	; WaveLoader::CWaveFile::Open
PUBLIC	?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetWaveFormat
PUBLIC	?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetAiffFormat
; Function compile flags: /Odt
;	COMDAT ?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z
DSOUND	SEGMENT
_this$ = -56
$T41105 = -52
_hr$ = -48
_AiffSoundHeader$ = -44
_VersionChunk$ = -36
_dwFormatSize$ = -12
_dwType$ = -8
_dwVersion$ = -4
_pszFileName$ = 8
_hFile$ = 12
?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z PROC NEAR	; WaveLoader::CWaveFile::Open, COMDAT
; _this$ = ecx

; 836  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 837  :     HRESULT                 hr              = S_OK;

  00009	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 838  :     DWORD                   dwType;
; 839  :     CRiffChunk              VersionChunk;

  00010	8d 4d dc	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 840  :     DWORD                   dwVersion;
; 841  :     DWORD                   dwFormatSize;
; 842  :     AIFFSOUNDHDR            AiffSoundHeader;
; 843  : 
; 844  :     DPF_ENTER();
; 845  : 
; 846  :     ASSERT((pszFileName || hFile) && !(pszFileName && hFile));
; 847  :     
; 848  :     //
; 849  :     // If we're already open, close
; 850  :     //
; 851  : 
; 852  :     Close();

  00018	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?Close@CWaveFile@WaveLoader@@QAEXXZ ; WaveLoader::CWaveFile::Close

; 853  : 
; 854  :     //
; 855  :     // Open the file
; 856  :     //
; 857  : 
; 858  :     if(pszFileName)

  00020	83 7d 08 00	 cmp	 DWORD PTR _pszFileName$[ebp], 0
  00024	74 1c		 je	 SHORT $L35507

; 859  :     {
; 860  :         hr = m_Stream.Open(pszFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, 0);

  00026	6a 00		 push	 0
  00028	6a 03		 push	 3
  0002a	6a 01		 push	 1
  0002c	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00031	8b 45 08	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  00034	50		 push	 eax
  00035	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z ; WaveLoader::CStdFileStream::Open
  0003d	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 861  :     }
; 862  :     else

  00040	eb 0c		 jmp	 SHORT $L35508
$L35507:

; 863  :     {
; 864  :         m_Stream.Attach(hFile);

  00042	8b 4d 0c	 mov	 ecx, DWORD PTR _hFile$[ebp]
  00045	51		 push	 ecx
  00046	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z ; WaveLoader::CStdFileStream::Attach
$L35508:

; 865  :     }
; 866  : 
; 867  :     //
; 868  :     // Determine the file type by opening the top-level chunk
; 869  :     //
; 870  : 
; 871  :     if(SUCCEEDED(hr))

  0004e	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00052	7c 54		 jl	 SHORT $L35510

; 872  :     {
; 873  :         hr = m_ParentChunk.Open(NULL, &m_Stream, WAVELDR_FOURCC_RIFF);

  00054	68 52 49 46 46	 push	 1179011410		; 46464952H
  00059	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	52		 push	 edx
  0005d	6a 00		 push	 0
  0005f	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	83 c1 08	 add	 ecx, 8
  00065	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  0006a	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 874  : 
; 875  :         if(SUCCEEDED(hr))

  0006d	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00071	7c 0c		 jl	 SHORT $L35512

; 876  :         {
; 877  :             m_dwFileType = WAVELDR_FILETYPE_WAVE;

  00073	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00076	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 878  :         }
; 879  :         else

  0007d	eb 29		 jmp	 SHORT $L35510
$L35512:

; 880  :         {
; 881  :             hr = m_ParentChunk.Open(NULL, &m_Stream, WAVELDR_FOURCC_FORM);

  0007f	68 46 4f 52 4d	 push	 1297239878		; 4d524f46H
  00084	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	51		 push	 ecx
  00088	6a 00		 push	 0
  0008a	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	83 c1 08	 add	 ecx, 8
  00090	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00095	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 882  : 
; 883  :             if(SUCCEEDED(hr))

  00098	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0009c	7c 0a		 jl	 SHORT $L35510

; 884  :             {
; 885  :                 m_dwFileType = WAVELDR_FILETYPE_AIFF;

  0009e	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  000a1	c7 42 38 01 00
	00 00		 mov	 DWORD PTR [edx+56], 1
$L35510:

; 886  :             }
; 887  :         }
; 888  :     }
; 889  : 
; 890  :     if(SUCCEEDED(hr))

  000a8	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ac	7c 52		 jl	 SHORT $L35517

; 891  :     {
; 892  :         hr = m_ParentChunk.Read(0, &dwType, sizeof(dwType));

  000ae	6a 00		 push	 0
  000b0	6a 04		 push	 4
  000b2	8d 45 f8	 lea	 eax, DWORD PTR _dwType$[ebp]
  000b5	50		 push	 eax
  000b6	6a 00		 push	 0
  000b8	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	83 c1 08	 add	 ecx, 8
  000be	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  000c3	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 893  : 
; 894  :         if(SUCCEEDED(hr))

  000c6	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ca	7c 34		 jl	 SHORT $L35517

; 895  :         {
; 896  :             if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  000cc	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  000d3	75 12		 jne	 SHORT $L35520

; 897  :             {
; 898  :                 if(WAVELDR_FOURCC_WAVE != dwType)

  000d5	81 7d f8 57 41
	56 45		 cmp	 DWORD PTR _dwType$[ebp], 1163280727 ; 45564157H
  000dc	74 07		 je	 SHORT $L35521

; 899  :                 {
; 900  :                     DPF_ERROR("The file type is not WAVE");
; 901  :                     hr = E_FAIL;

  000de	c7 45 d0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35521:

; 902  :                 }
; 903  :             }
; 904  :             else

  000e5	eb 19		 jmp	 SHORT $L35517
$L35520:

; 905  :             {
; 906  :                 if((WAVELDR_FOURCC_AIFF != dwType) && (WAVELDR_FOURCC_AIFFC != dwType))

  000e7	81 7d f8 41 49
	46 46		 cmp	 DWORD PTR _dwType$[ebp], 1179011393 ; 46464941H
  000ee	74 10		 je	 SHORT $L35517
  000f0	81 7d f8 41 49
	46 43		 cmp	 DWORD PTR _dwType$[ebp], 1128679745 ; 43464941H
  000f7	74 07		 je	 SHORT $L35517

; 907  :                 {
; 908  :                     DPF_ERROR("The file type is not AIFF/AIFF-C");
; 909  :                     hr = E_FAIL;

  000f9	c7 45 d0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35517:

; 910  :                 }
; 911  :             }
; 912  :         }
; 913  :     }
; 914  : 
; 915  :     if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType) && (WAVELDR_FOURCC_AIFFC == dwType))

  00100	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00104	7c 5e		 jl	 SHORT $L35527
  00106	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00109	83 7a 38 01	 cmp	 DWORD PTR [edx+56], 1
  0010d	75 55		 jne	 SHORT $L35527
  0010f	81 7d f8 41 49
	46 43		 cmp	 DWORD PTR _dwType$[ebp], 1128679745 ; 43464941H
  00116	75 4c		 jne	 SHORT $L35527

; 916  :     {
; 917  :         hr = VersionChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_AIFF_VERSION);

  00118	68 52 56 45 52	 push	 1380275794		; 52455652H
  0011d	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00120	50		 push	 eax
  00121	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	83 c1 08	 add	 ecx, 8
  00127	51		 push	 ecx
  00128	8d 4d dc	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  0012b	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00130	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 918  : 
; 919  :         if(SUCCEEDED(hr))

  00133	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00137	7c 15		 jl	 SHORT $L35529

; 920  :         {
; 921  :             hr = VersionChunk.Read(0, &dwVersion, sizeof(dwVersion));

  00139	6a 00		 push	 0
  0013b	6a 04		 push	 4
  0013d	8d 55 fc	 lea	 edx, DWORD PTR _dwVersion$[ebp]
  00140	52		 push	 edx
  00141	6a 00		 push	 0
  00143	8d 4d dc	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  00146	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  0014b	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax
$L35529:

; 922  :         }
; 923  : 
; 924  :         if(SUCCEEDED(hr) && (WAVELDR_AIFFC_VERSION != dwVersion))

  0014e	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00152	7c 10		 jl	 SHORT $L35527
  00154	81 7d fc 40 51
	80 a2		 cmp	 DWORD PTR _dwVersion$[ebp], -1568648896 ; a2805140H
  0015b	74 07		 je	 SHORT $L35527

; 925  :         {
; 926  :             DPF_ERROR("The file's AIFF-C version is not supported");
; 927  :             hr = E_FAIL;

  0015d	c7 45 d0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35527:

; 928  :         }
; 929  :     }
; 930  : 
; 931  :     //
; 932  :     // Initialize the required chunk objects
; 933  :     //
; 934  : 
; 935  :     if(SUCCEEDED(hr))

  00164	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00168	7c 30		 jl	 SHORT $L35534

; 936  :     {
; 937  :         hr = m_DataChunk.Open(&m_ParentChunk, &m_Stream, (WAVELDR_FILETYPE_WAVE == m_dwFileType) ? WAVELDR_FOURCC_DATA : WAVELDR_FOURCC_SOUND);

  0016a	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0016d	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00170	f7 d9		 neg	 ecx
  00172	1b c9		 sbb	 ecx, ecx
  00174	81 e1 ef f1 d9
	e2		 and	 ecx, -489033233		; e2d9f1efH
  0017a	81 c1 64 61 74
	61		 add	 ecx, 1635017060		; 61746164H
  00180	51		 push	 ecx
  00181	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00184	52		 push	 edx
  00185	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00188	83 c0 08	 add	 eax, 8
  0018b	50		 push	 eax
  0018c	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018f	83 c1 20	 add	 ecx, 32			; 00000020H
  00192	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00197	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax
$L35534:

; 938  :     }
; 939  : 
; 940  :     //
; 941  :     // Load the file format
; 942  :     //
; 943  : 
; 944  :     if(SUCCEEDED(hr))

  0019a	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0019e	7c 31		 jl	 SHORT $L35536

; 945  :     {
; 946  :         if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  001a0	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a3	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  001a7	75 15		 jne	 SHORT $L35537

; 947  :         {
; 948  :             hr = GetWaveFormat(NULL, 0, &dwFormatSize);

  001a9	8d 55 f4	 lea	 edx, DWORD PTR _dwFormatSize$[ebp]
  001ac	52		 push	 edx
  001ad	6a 00		 push	 0
  001af	6a 00		 push	 0
  001b1	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b4	e8 00 00 00 00	 call	 ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetWaveFormat
  001b9	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 949  :         }
; 950  :         else

  001bc	eb 13		 jmp	 SHORT $L35536
$L35537:

; 951  :         {
; 952  :             hr = GetAiffFormat(NULL, 0, &dwFormatSize);

  001be	8d 45 f4	 lea	 eax, DWORD PTR _dwFormatSize$[ebp]
  001c1	50		 push	 eax
  001c2	6a 00		 push	 0
  001c4	6a 00		 push	 0
  001c6	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c9	e8 00 00 00 00	 call	 ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetAiffFormat
  001ce	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax
$L35536:

; 953  :         }
; 954  :     }
; 955  : 
; 956  :     if(SUCCEEDED(hr))

  001d1	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001d5	7c 2c		 jl	 SHORT $L35540

; 957  :     {
; 958  :         hr = HRFROMP(m_pwfxFormat = (LPWAVEFORMATEX)MEMALLOC(BYTE, dwFormatSize));

  001d7	6a 01		 push	 1
  001d9	8b 4d f4	 mov	 ecx, DWORD PTR _dwFormatSize$[ebp]
  001dc	51		 push	 ecx
  001dd	68 44 53 64 61	 push	 1633964868		; 61645344H
  001e2	e8 00 00 00 00	 call	 ?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::MemAlloc
  001e7	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  001ea	89 42 3c	 mov	 DWORD PTR [edx+60], eax
  001ed	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  001f0	33 c9		 xor	 ecx, ecx
  001f2	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  001f6	0f 95 c1	 setne	 cl
  001f9	49		 dec	 ecx
  001fa	81 e1 0e 00 07
	80		 and	 ecx, -2147024882	; 8007000eH
  00200	89 4d d0	 mov	 DWORD PTR _hr$[ebp], ecx
$L35540:

; 959  :     }
; 960  : 
; 961  :     if(SUCCEEDED(hr))

  00203	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00207	7c 3b		 jl	 SHORT $L35547

; 962  :     {
; 963  :         if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  00209	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0020c	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00210	75 1a		 jne	 SHORT $L35548

; 964  :         {
; 965  :             hr = GetWaveFormat(m_pwfxFormat, dwFormatSize, NULL);

  00212	6a 00		 push	 0
  00214	8b 45 f4	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  00217	50		 push	 eax
  00218	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0021b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0021e	52		 push	 edx
  0021f	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00222	e8 00 00 00 00	 call	 ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetWaveFormat
  00227	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 966  :         }
; 967  :         else

  0022a	eb 18		 jmp	 SHORT $L35547
$L35548:

; 968  :         {
; 969  :             hr = GetAiffFormat(m_pwfxFormat, dwFormatSize, NULL);

  0022c	6a 00		 push	 0
  0022e	8b 45 f4	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  00231	50		 push	 eax
  00232	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00235	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00238	52		 push	 edx
  00239	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0023c	e8 00 00 00 00	 call	 ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetAiffFormat
  00241	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax
$L35547:

; 970  :         }
; 971  :     }
; 972  : 
; 973  :     //
; 974  :     // If this is an AIFF file, offset the start of the wave data
; 975  :     //
; 976  : 
; 977  :     if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType))

  00244	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00248	7c 4e		 jl	 SHORT $L35551
  0024a	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0024d	83 78 38 01	 cmp	 DWORD PTR [eax+56], 1
  00251	75 45		 jne	 SHORT $L35551

; 978  :     {
; 979  :         hr = m_DataChunk.Read(0, &AiffSoundHeader, sizeof(AiffSoundHeader));

  00253	6a 00		 push	 0
  00255	6a 08		 push	 8
  00257	8d 4d d4	 lea	 ecx, DWORD PTR _AiffSoundHeader$[ebp]
  0025a	51		 push	 ecx
  0025b	6a 00		 push	 0
  0025d	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00260	83 c1 20	 add	 ecx, 32			; 00000020H
  00263	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00268	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 980  : 
; 981  :         if(SUCCEEDED(hr))

  0026b	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0026f	7c 27		 jl	 SHORT $L35551

; 982  :         {
; 983  :             m_DataChunk.m_dwDataOffset += sizeof(AiffSoundHeader) + AiffSoundHeader.dwOffset;

  00271	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00274	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00277	8b 4d d4	 mov	 ecx, DWORD PTR _AiffSoundHeader$[ebp]
  0027a	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  0027e	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00281	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 984  :             m_DataChunk.m_dwDataSize -= sizeof(AiffSoundHeader) + AiffSoundHeader.dwOffset;

  00284	8b 4d d4	 mov	 ecx, DWORD PTR _AiffSoundHeader$[ebp]
  00287	83 c1 08	 add	 ecx, 8
  0028a	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0028d	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00290	2b c1		 sub	 eax, ecx
  00292	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00295	89 41 30	 mov	 DWORD PTR [ecx+48], eax
$L35551:

; 985  :         }
; 986  :     }
; 987  : 
; 988  :     DPF_LEAVE_HRESULT(hr);
; 989  : 
; 990  :     return hr;

  00298	8b 55 d0	 mov	 edx, DWORD PTR _hr$[ebp]
  0029b	89 55 cc	 mov	 DWORD PTR $T41105[ebp], edx
  0029e	8d 4d dc	 lea	 ecx, DWORD PTR _VersionChunk$[ebp]
  002a1	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  002a6	8b 45 cc	 mov	 eax, DWORD PTR $T41105[ebp]

; 991  : }

  002a9	8b e5		 mov	 esp, ebp
  002ab	5d		 pop	 ebp
  002ac	c2 08 00	 ret	 8
?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z ENDP		; WaveLoader::CWaveFile::Open
DSOUND	ENDS
PUBLIC	?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z ; WaveLoader::CWaveFile::GetFormat
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z
DSOUND	SEGMENT
tv72 = -16
_this$ = -12
_dwValidSize$ = -4
_pwfxFormat$ = 8
_dwFormatSize$ = 12
_pdwRequiredSize$ = 16
?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z PROC NEAR ; WaveLoader::CWaveFile::GetFormat, COMDAT
; _this$ = ecx

; 1021 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1022 :     DWORD                   dwValidSize;
; 1023 :     HRESULT                 hr;
; 1024 : 
; 1025 :     DPF_ENTER();
; 1026 : 
; 1027 :     ASSERT(m_pwfxFormat);
; 1028 :     
; 1029 :     dwValidSize = sizeof(*m_pwfxFormat) + m_pwfxFormat->cbSize;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0000f	0f b7 51 10	 movzx	 edx, WORD PTR [ecx+16]
  00013	83 c2 12	 add	 edx, 18			; 00000012H
  00016	89 55 fc	 mov	 DWORD PTR _dwValidSize$[ebp], edx

; 1030 : 
; 1031 :     if(pwfxFormat && dwFormatSize)

  00019	83 7d 08 00	 cmp	 DWORD PTR _pwfxFormat$[ebp], 0
  0001d	74 53		 je	 SHORT $L35563
  0001f	83 7d 0c 00	 cmp	 DWORD PTR _dwFormatSize$[ebp], 0
  00023	74 4d		 je	 SHORT $L35563

; 1032 :     {
; 1033 :         CopyMemory(pwfxFormat, m_pwfxFormat, min(dwFormatSize, dwValidSize));

  00025	8b 45 0c	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  00028	3b 45 fc	 cmp	 eax, DWORD PTR _dwValidSize$[ebp]
  0002b	73 08		 jae	 SHORT $L41109
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFormatSize$[ebp]
  00030	89 4d f0	 mov	 DWORD PTR tv72[ebp], ecx
  00033	eb 06		 jmp	 SHORT $L41110
$L41109:
  00035	8b 55 fc	 mov	 edx, DWORD PTR _dwValidSize$[ebp]
  00038	89 55 f0	 mov	 DWORD PTR tv72[ebp], edx
$L41110:
  0003b	8b 45 f0	 mov	 eax, DWORD PTR tv72[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00045	52		 push	 edx
  00046	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _memcpy
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1034 : 
; 1035 :         if(dwFormatSize > dwValidSize)

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFormatSize$[ebp]
  00055	3b 4d fc	 cmp	 ecx, DWORD PTR _dwValidSize$[ebp]
  00058	76 18		 jbe	 SHORT $L35563

; 1036 :         {
; 1037 :             ZeroMemory((LPBYTE)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize);

  0005a	8b 55 0c	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  0005d	2b 55 fc	 sub	 edx, DWORD PTR _dwValidSize$[ebp]
  00060	52		 push	 edx
  00061	6a 00		 push	 0
  00063	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  00066	03 45 fc	 add	 eax, DWORD PTR _dwValidSize$[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _memset
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L35563:

; 1038 :         }
; 1039 :     }
; 1040 : 
; 1041 :     if(pdwRequiredSize)

  00072	83 7d 10 00	 cmp	 DWORD PTR _pdwRequiredSize$[ebp], 0
  00076	74 08		 je	 SHORT $L35566

; 1042 :     {
; 1043 :         *pdwRequiredSize = dwValidSize;

  00078	8b 4d 10	 mov	 ecx, DWORD PTR _pdwRequiredSize$[ebp]
  0007b	8b 55 fc	 mov	 edx, DWORD PTR _dwValidSize$[ebp]
  0007e	89 11		 mov	 DWORD PTR [ecx], edx
$L35566:

; 1044 :     }
; 1045 : 
; 1046 :     DPF_LEAVE_HRESULT(S_OK);
; 1047 : 
; 1048 :     return S_OK;

  00080	33 c0		 xor	 eax, eax

; 1049 : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 0c 00	 ret	 12			; 0000000cH
?GetFormat@CWaveFile@WaveLoader@@QAEJPAUtWAVEFORMATEX@@KPAK@Z ENDP ; WaveLoader::CWaveFile::GetFormat
DSOUND	ENDS
PUBLIC	?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ	; WaveLoader::CRiffChunk::GetDataSize
; Function compile flags: /Odt
;	COMDAT ?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
DSOUND	SEGMENT
tv94 = -48
tv80 = -44
_this$ = -40
$T41118 = -36
_hr$ = -32
_FormatChunk$ = -28
_dwValidSize$ = -4
_pwfxFormat$ = 8
_dwFormatSize$ = 12
_pdwRequiredSize$ = 16
?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z PROC NEAR ; WaveLoader::CWaveFile::GetWaveFormat, COMDAT
; _this$ = ecx

; 1079 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 1080 :     CRiffChunk              FormatChunk;

  00009	8d 4d e4	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1081 :     DWORD                   dwValidSize;
; 1082 :     HRESULT                 hr;
; 1083 : 
; 1084 :     DPF_ENTER();
; 1085 : 
; 1086 :     ASSERT(WAVELDR_FILETYPE_WAVE == m_dwFileType);
; 1087 : 
; 1088 :     //
; 1089 :     // Read the format chunk into the buffer.  Make sure to fill in the full
; 1090 :     // WAVEFORMATEX structure, even if the data in the file isn't enough.
; 1091 :     //
; 1092 : 
; 1093 :     hr = FormatChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_FORMAT);

  00011	68 66 6d 74 20	 push	 544501094		; 20746d66H
  00016	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	51		 push	 ecx
  00021	8d 4d e4	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00024	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00029	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax

; 1094 : 
; 1095 :     if(SUCCEEDED(hr))

  0002c	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00030	7c 38		 jl	 SHORT $L35578

; 1096 :     {
; 1097 :         dwValidSize = FormatChunk.GetDataSize();

  00032	8d 4d e4	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00035	e8 00 00 00 00	 call	 ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ; WaveLoader::CRiffChunk::GetDataSize
  0003a	89 45 fc	 mov	 DWORD PTR _dwValidSize$[ebp], eax

; 1098 : 
; 1099 :         hr = FormatChunk.Read(0, pwfxFormat, min(dwValidSize, dwFormatSize));

  0003d	8b 55 fc	 mov	 edx, DWORD PTR _dwValidSize$[ebp]
  00040	3b 55 0c	 cmp	 edx, DWORD PTR _dwFormatSize$[ebp]
  00043	73 08		 jae	 SHORT $L41114
  00045	8b 45 fc	 mov	 eax, DWORD PTR _dwValidSize$[ebp]
  00048	89 45 d4	 mov	 DWORD PTR tv80[ebp], eax
  0004b	eb 06		 jmp	 SHORT $L41115
$L41114:
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFormatSize$[ebp]
  00050	89 4d d4	 mov	 DWORD PTR tv80[ebp], ecx
$L41115:
  00053	6a 00		 push	 0
  00055	8b 55 d4	 mov	 edx, DWORD PTR tv80[ebp]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  0005c	50		 push	 eax
  0005d	6a 00		 push	 0
  0005f	8d 4d e4	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00062	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00067	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax
$L35578:

; 1100 :     }
; 1101 : 
; 1102 :     if(SUCCEEDED(hr) && (dwFormatSize > dwValidSize))

  0006a	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006e	7c 20		 jl	 SHORT $L35580
  00070	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFormatSize$[ebp]
  00073	3b 4d fc	 cmp	 ecx, DWORD PTR _dwValidSize$[ebp]
  00076	76 18		 jbe	 SHORT $L35580

; 1103 :     {
; 1104 :         ZeroMemory((LPBYTE)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize);

  00078	8b 55 0c	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  0007b	2b 55 fc	 sub	 edx, DWORD PTR _dwValidSize$[ebp]
  0007e	52		 push	 edx
  0007f	6a 00		 push	 0
  00081	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  00084	03 45 fc	 add	 eax, DWORD PTR _dwValidSize$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _memset
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L35580:

; 1105 :     }
; 1106 : 
; 1107 :     if(SUCCEEDED(hr) && pdwRequiredSize)

  00090	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00094	7c 23		 jl	 SHORT $L35583
  00096	83 7d 10 00	 cmp	 DWORD PTR _pdwRequiredSize$[ebp], 0
  0009a	74 1d		 je	 SHORT $L35583

; 1108 :     {
; 1109 :         *pdwRequiredSize = max(dwValidSize, sizeof(*pwfxFormat));

  0009c	83 7d fc 12	 cmp	 DWORD PTR _dwValidSize$[ebp], 18 ; 00000012H
  000a0	76 08		 jbe	 SHORT $L41116
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _dwValidSize$[ebp]
  000a5	89 4d d0	 mov	 DWORD PTR tv94[ebp], ecx
  000a8	eb 07		 jmp	 SHORT $L41117
$L41116:
  000aa	c7 45 d0 12 00
	00 00		 mov	 DWORD PTR tv94[ebp], 18	; 00000012H
$L41117:
  000b1	8b 55 10	 mov	 edx, DWORD PTR _pdwRequiredSize$[ebp]
  000b4	8b 45 d0	 mov	 eax, DWORD PTR tv94[ebp]
  000b7	89 02		 mov	 DWORD PTR [edx], eax
$L35583:

; 1110 :     }
; 1111 : 
; 1112 :     DPF_LEAVE_HRESULT(hr);
; 1113 : 
; 1114 :     return hr;

  000b9	8b 4d e0	 mov	 ecx, DWORD PTR _hr$[ebp]
  000bc	89 4d dc	 mov	 DWORD PTR $T41118[ebp], ecx
  000bf	8d 4d e4	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  000c2	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  000c7	8b 45 dc	 mov	 eax, DWORD PTR $T41118[ebp]

; 1115 : }

  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c2 0c 00	 ret	 12			; 0000000cH
?GetWaveFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ENDP ; WaveLoader::CWaveFile::GetWaveFormat
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\waveldr.h
DSOUND	ENDS
;	COMDAT ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ
DSOUND	SEGMENT
_this$ = -4
?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ PROC NEAR	; WaveLoader::CRiffChunk::GetDataSize, COMDAT
; _this$ = ecx

; 276  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 277  :         return m_dwDataSize;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 278  :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ENDP		; WaveLoader::CRiffChunk::GetDataSize
DSOUND	ENDS
PUBLIC	_XAudioCreatePcmFormat@16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\waveldr.cpp
;	COMDAT ?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z
DSOUND	SEGMENT
tv149 = -88
tv82 = -84
_this$ = -80
$T41129 = -76
_WaveFormat$ = -72
_hr$ = -52
_FormatChunk$ = -48
_dwValidSize$ = -24
_AiffFormat$ = -20
_pwfxFormat$ = 8
_dwFormatSize$ = 12
_pdwRequiredSize$ = 16
?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z PROC NEAR ; WaveLoader::CWaveFile::GetAiffFormat, COMDAT
; _this$ = ecx

; 1145 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 1146 :     HRESULT                 hr          = S_OK;

  00009	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1147 :     CRiffChunk              FormatChunk;

  00010	8d 4d d0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1148 :     DWORD                   dwValidSize;
; 1149 :     AIFFFORMAT              AiffFormat;
; 1150 :     WAVEFORMATEX            WaveFormat;
; 1151 : 
; 1152 :     DPF_ENTER();
; 1153 : 
; 1154 :     ASSERT(WAVELDR_FILETYPE_AIFF == m_dwFileType);
; 1155 : 
; 1156 :     if(pwfxFormat && dwFormatSize)

  00018	83 7d 08 00	 cmp	 DWORD PTR _pwfxFormat$[ebp], 0
  0001c	0f 84 66 01 00
	00		 je	 $L35597
  00022	83 7d 0c 00	 cmp	 DWORD PTR _dwFormatSize$[ebp], 0
  00026	0f 84 5c 01 00
	00		 je	 $L35597

; 1157 :     {
; 1158 :         //
; 1159 :         // Open the format chunk
; 1160 :         //
; 1161 : 
; 1162 :         hr = FormatChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_COMM);

  0002c	68 43 4f 4d 4d	 push	 1296912195		; 4d4d4f43H
  00031	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	50		 push	 eax
  00035	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 08	 add	 ecx, 8
  0003b	51		 push	 ecx
  0003c	8d 4d d0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  0003f	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00044	89 45 cc	 mov	 DWORD PTR _hr$[ebp], eax

; 1163 :         
; 1164 :         //
; 1165 :         // Read the base format data
; 1166 :         //
; 1167 : 
; 1168 :         if(SUCCEEDED(hr))

  00047	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004b	7c 37		 jl	 SHORT $L35599

; 1169 :         {
; 1170 :             dwValidSize = FormatChunk.GetDataSize();

  0004d	8d 4d d0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  00050	e8 00 00 00 00	 call	 ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ; WaveLoader::CRiffChunk::GetDataSize
  00055	89 45 e8	 mov	 DWORD PTR _dwValidSize$[ebp], eax

; 1171 : 
; 1172 :             hr = FormatChunk.Read(0, &AiffFormat, min(sizeof(AiffFormat), dwValidSize));

  00058	83 7d e8 14	 cmp	 DWORD PTR _dwValidSize$[ebp], 20 ; 00000014H
  0005c	76 09		 jbe	 SHORT $L41125
  0005e	c7 45 ac 14 00
	00 00		 mov	 DWORD PTR tv82[ebp], 20	; 00000014H
  00065	eb 06		 jmp	 SHORT $L41126
$L41125:
  00067	8b 55 e8	 mov	 edx, DWORD PTR _dwValidSize$[ebp]
  0006a	89 55 ac	 mov	 DWORD PTR tv82[ebp], edx
$L41126:
  0006d	6a 00		 push	 0
  0006f	8b 45 ac	 mov	 eax, DWORD PTR tv82[ebp]
  00072	50		 push	 eax
  00073	8d 4d ec	 lea	 ecx, DWORD PTR _AiffFormat$[ebp]
  00076	51		 push	 ecx
  00077	6a 00		 push	 0
  00079	8d 4d d0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  0007c	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00081	89 45 cc	 mov	 DWORD PTR _hr$[ebp], eax
$L35599:

; 1173 :         }
; 1174 : 
; 1175 :         if(SUCCEEDED(hr) && (sizeof(AiffFormat) > dwValidSize))

  00084	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00088	7c 21		 jl	 SHORT $L35601
  0008a	83 7d e8 14	 cmp	 DWORD PTR _dwValidSize$[ebp], 20 ; 00000014H
  0008e	73 1b		 jae	 SHORT $L35601

; 1176 :         {
; 1177 :             ZeroMemory((LPBYTE)&AiffFormat + dwValidSize, sizeof(AiffFormat) - dwValidSize);

  00090	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  00095	2b 55 e8	 sub	 edx, DWORD PTR _dwValidSize$[ebp]
  00098	52		 push	 edx
  00099	6a 00		 push	 0
  0009b	8b 45 e8	 mov	 eax, DWORD PTR _dwValidSize$[ebp]
  0009e	8d 4c 05 ec	 lea	 ecx, DWORD PTR _AiffFormat$[ebp+eax]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 _memset
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
$L35601:

; 1178 :         }
; 1179 : 
; 1180 :         //
; 1181 :         // If no compression type is specified, assume PCM
; 1182 :         //
; 1183 : 
; 1184 :         if(SUCCEEDED(hr) && !AiffFormat.dwCompression)

  000ab	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000af	7c 0d		 jl	 SHORT $L35604
  000b1	83 7d fc 00	 cmp	 DWORD PTR _AiffFormat$[ebp+16], 0
  000b5	75 07		 jne	 SHORT $L35604

; 1185 :         {
; 1186 :             AiffFormat.dwCompression = WAVELDR_FOURCC_NONE;

  000b7	c7 45 fc 4e 4f
	4e 45		 mov	 DWORD PTR _AiffFormat$[ebp+16], 1162760014 ; 454e4f4eH
$L35604:

; 1187 :         }
; 1188 : 
; 1189 :         //
; 1190 :         // Currently, only PCM is supported
; 1191 :         //
; 1192 : 
; 1193 :         if(SUCCEEDED(hr) && (WAVELDR_FOURCC_NONE != AiffFormat.dwCompression))

  000be	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000c2	7c 10		 jl	 SHORT $L35606
  000c4	81 7d fc 4e 4f
	4e 45		 cmp	 DWORD PTR _AiffFormat$[ebp+16], 1162760014 ; 454e4f4eH
  000cb	74 07		 je	 SHORT $L35606

; 1194 :         {
; 1195 :             DPF_ERROR("Unsupported AIFF compression type");
; 1196 :             hr = E_FAIL;

  000cd	c7 45 cc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35606:

; 1197 :         }
; 1198 : 
; 1199 :         //
; 1200 :         // Convert AIFF format to WAVE format
; 1201 :         //
; 1202 : 
; 1203 :         if(SUCCEEDED(hr))

  000d4	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000d8	7c 5b		 jl	 SHORT $L35609

; 1204 :         {
; 1205 :             AiffFormat.nChannels = EndianSwapWord(AiffFormat.nChannels);

  000da	8b 4d ec	 mov	 ecx, DWORD PTR _AiffFormat$[ebp]
  000dd	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  000e2	66 89 45 ec	 mov	 WORD PTR _AiffFormat$[ebp], ax

; 1206 :             AiffFormat.wBitsPerSample = EndianSwapWord(AiffFormat.wBitsPerSample);

  000e6	8b 4d f2	 mov	 ecx, DWORD PTR _AiffFormat$[ebp+6]
  000e9	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  000ee	66 89 45 f2	 mov	 WORD PTR _AiffFormat$[ebp+6], ax

; 1207 :             AiffFormat.wFrequencyExponent = EndianSwapWord(AiffFormat.wFrequencyExponent);

  000f2	8b 4d f4	 mov	 ecx, DWORD PTR _AiffFormat$[ebp+8]
  000f5	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  000fa	66 89 45 f4	 mov	 WORD PTR _AiffFormat$[ebp+8], ax

; 1208 :             AiffFormat.dwFrequencyMantissa = EndianSwapDword(AiffFormat.dwFrequencyMantissa);

  000fe	8b 4d f6	 mov	 ecx, DWORD PTR _AiffFormat$[ebp+10]
  00101	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  00106	89 45 f6	 mov	 DWORD PTR _AiffFormat$[ebp+10], eax

; 1209 : 
; 1210 :             XAudioCreatePcmFormat(AiffFormat.nChannels, AiffFormat.dwFrequencyMantissa >> (16414 - (AiffFormat.wFrequencyExponent & 0x7FFF)), AiffFormat.wBitsPerSample, &WaveFormat);

  00109	8d 55 b8	 lea	 edx, DWORD PTR _WaveFormat$[ebp]
  0010c	52		 push	 edx
  0010d	66 8b 45 f2	 mov	 ax, WORD PTR _AiffFormat$[ebp+6]
  00111	50		 push	 eax
  00112	0f b7 4d f4	 movzx	 ecx, WORD PTR _AiffFormat$[ebp+8]
  00116	81 e1 ff 7f 00
	00		 and	 ecx, 32767		; 00007fffH
  0011c	ba 1e 40 00 00	 mov	 edx, 16414		; 0000401eH
  00121	2b d1		 sub	 edx, ecx
  00123	8b 45 f6	 mov	 eax, DWORD PTR _AiffFormat$[ebp+10]
  00126	8b ca		 mov	 ecx, edx
  00128	d3 e8		 shr	 eax, cl
  0012a	50		 push	 eax
  0012b	66 8b 4d ec	 mov	 cx, WORD PTR _AiffFormat$[ebp]
  0012f	51		 push	 ecx
  00130	e8 00 00 00 00	 call	 _XAudioCreatePcmFormat@16
$L35609:

; 1211 :         }
; 1212 : 
; 1213 :         if(SUCCEEDED(hr))

  00135	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00139	7c 29		 jl	 SHORT $L35611

; 1214 :         {
; 1215 :             CopyMemory(pwfxFormat, &WaveFormat, min(sizeof(WaveFormat), dwFormatSize));

  0013b	83 7d 0c 12	 cmp	 DWORD PTR _dwFormatSize$[ebp], 18 ; 00000012H
  0013f	76 09		 jbe	 SHORT $L41127
  00141	c7 45 a8 12 00
	00 00		 mov	 DWORD PTR tv149[ebp], 18 ; 00000012H
  00148	eb 06		 jmp	 SHORT $L41128
$L41127:
  0014a	8b 55 0c	 mov	 edx, DWORD PTR _dwFormatSize$[ebp]
  0014d	89 55 a8	 mov	 DWORD PTR tv149[ebp], edx
$L41128:
  00150	8b 45 a8	 mov	 eax, DWORD PTR tv149[ebp]
  00153	50		 push	 eax
  00154	8d 4d b8	 lea	 ecx, DWORD PTR _WaveFormat$[ebp]
  00157	51		 push	 ecx
  00158	8b 55 08	 mov	 edx, DWORD PTR _pwfxFormat$[ebp]
  0015b	52		 push	 edx
  0015c	e8 00 00 00 00	 call	 _memcpy
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH
$L35611:

; 1216 :         }
; 1217 : 
; 1218 :         if(SUCCEEDED(hr) && (dwFormatSize > sizeof(WaveFormat)))

  00164	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00168	7c 1e		 jl	 SHORT $L35597
  0016a	83 7d 0c 12	 cmp	 DWORD PTR _dwFormatSize$[ebp], 18 ; 00000012H
  0016e	76 18		 jbe	 SHORT $L35597

; 1219 :         {
; 1220 :             ZeroMemory((LPBYTE)pwfxFormat + sizeof(WaveFormat), dwFormatSize - sizeof(WaveFormat));

  00170	8b 45 0c	 mov	 eax, DWORD PTR _dwFormatSize$[ebp]
  00173	83 e8 12	 sub	 eax, 18			; 00000012H
  00176	50		 push	 eax
  00177	6a 00		 push	 0
  00179	8b 4d 08	 mov	 ecx, DWORD PTR _pwfxFormat$[ebp]
  0017c	83 c1 12	 add	 ecx, 18			; 00000012H
  0017f	51		 push	 ecx
  00180	e8 00 00 00 00	 call	 _memset
  00185	83 c4 0c	 add	 esp, 12			; 0000000cH
$L35597:

; 1221 :         }
; 1222 :     }
; 1223 :     
; 1224 :     if(SUCCEEDED(hr) && pdwRequiredSize)

  00188	83 7d cc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0018c	7c 0f		 jl	 SHORT $L35616
  0018e	83 7d 10 00	 cmp	 DWORD PTR _pdwRequiredSize$[ebp], 0
  00192	74 09		 je	 SHORT $L35616

; 1225 :     {
; 1226 :         *pdwRequiredSize = sizeof(WaveFormat);

  00194	8b 55 10	 mov	 edx, DWORD PTR _pdwRequiredSize$[ebp]
  00197	c7 02 12 00 00
	00		 mov	 DWORD PTR [edx], 18	; 00000012H
$L35616:

; 1227 :     }
; 1228 : 
; 1229 :     DPF_LEAVE_HRESULT(hr);
; 1230 : 
; 1231 :     return hr;

  0019d	8b 45 cc	 mov	 eax, DWORD PTR _hr$[ebp]
  001a0	89 45 b4	 mov	 DWORD PTR $T41129[ebp], eax
  001a3	8d 4d d0	 lea	 ecx, DWORD PTR _FormatChunk$[ebp]
  001a6	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  001ab	8b 45 b4	 mov	 eax, DWORD PTR $T41129[ebp]

; 1232 : }

  001ae	8b e5		 mov	 esp, ebp
  001b0	5d		 pop	 ebp
  001b1	c2 0c 00	 ret	 12			; 0000000cH
?GetAiffFormat@CWaveFile@WaveLoader@@IAEJPAUtWAVEFORMATEX@@KPAK@Z ENDP ; WaveLoader::CWaveFile::GetAiffFormat
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?EndianSwapWord@@YIGG@Z
DSOUND	SEGMENT
_n$ = -4
?EndianSwapWord@@YIGG@Z PROC NEAR			; EndianSwapWord, COMDAT
; _n$ = cx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	66 89 4d fc	 mov	 WORD PTR _n$[ebp], cx

; 40   :     __asm
; 41   :     {
; 42   :         mov     eax, ecx

  00009	8b c1		 mov	 eax, ecx

; 43   :         sar     eax, 8

  0000b	c1 f8 08	 sar	 eax, 8

; 44   :         and     eax, 0ffh

  0000e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 45   : 
; 46   :         mov     ebx, ecx

  00013	8b d9		 mov	 ebx, ecx

; 47   :         shl     ebx, 8

  00015	c1 e3 08	 shl	 ebx, 8

; 48   :         and     ebx, 0ff00h

  00018	81 e3 00 ff 00
	00		 and	 ebx, 65280		; 0000ff00H

; 49   :         or      eax, ebx

  0001e	0b c3		 or	 eax, ebx

; 50   :     }
; 51   : }

  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?EndianSwapWord@@YIGG@Z ENDP				; EndianSwapWord
DSOUND	ENDS
PUBLIC	?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z	; WaveLoader::CWaveFile::GetLoopRegion
PUBLIC	?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetWaveLoopRegion
PUBLIC	?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetAiffLoopRegion
; Function compile flags: /Odt
;	COMDAT ?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
_pdwLoopStart$ = 8
_pdwLoopLength$ = 12
?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z PROC NEAR ; WaveLoader::CWaveFile::GetLoopRegion, COMDAT
; _this$ = ecx

; 1260 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1261 :     HRESULT                 hr;
; 1262 : 
; 1263 :     DPF_ENTER();
; 1264 : 
; 1265 :     ASSERT(m_pwfxFormat);
; 1266 : 
; 1267 :     //
; 1268 :     // Read loop region data in samples
; 1269 :     //
; 1270 : 
; 1271 :     if(WAVELDR_FILETYPE_WAVE == m_dwFileType)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00010	75 15		 jne	 SHORT $L35624

; 1272 :     {
; 1273 :         hr = GetWaveLoopRegion(pdwLoopStart, pdwLoopLength);

  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwLoopLength$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetWaveLoopRegion
  00022	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1274 :     }
; 1275 :     else

  00025	eb 13		 jmp	 SHORT $L35625
$L35624:

; 1276 :     {
; 1277 :         hr = GetAiffLoopRegion(pdwLoopStart, pdwLoopLength);

  00027	8b 45 0c	 mov	 eax, DWORD PTR _pdwLoopLength$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ; WaveLoader::CWaveFile::GetAiffLoopRegion
  00037	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L35625:

; 1278 :     }
; 1279 : 
; 1280 :     //
; 1281 :     // Convert to bytes
; 1282 :     //
; 1283 : 
; 1284 :     if(SUCCEEDED(hr))

  0003a	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0003e	0f 8c a8 00 00
	00		 jl	 $L35627

; 1285 :     {
; 1286 :         if(WAVE_FORMAT_XBOX_ADPCM == m_pwfxFormat->wFormatTag)

  00044	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00047	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0004a	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0004d	83 f9 69	 cmp	 ecx, 105		; 00000069H
  00050	75 6c		 jne	 SHORT $L35628

; 1287 :         {
; 1288 :             *pdwLoopStart /= m_pwfxFormat->nChannels * XBOX_ADPCM_SAMPLES_PER_BLOCK;

  00052	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00055	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00058	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  0005c	c1 e1 06	 shl	 ecx, 6
  0005f	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  00062	8b 02		 mov	 eax, DWORD PTR [edx]
  00064	33 d2		 xor	 edx, edx
  00066	f7 f1		 div	 ecx
  00068	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  0006b	89 01		 mov	 DWORD PTR [ecx], eax

; 1289 :             *pdwLoopStart *= m_pwfxFormat->nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  0006d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00070	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00073	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00077	6b c9 24	 imul	 ecx, 36			; 00000024H
  0007a	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  0007d	8b 02		 mov	 eax, DWORD PTR [edx]
  0007f	0f af c1	 imul	 eax, ecx
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  00085	89 01		 mov	 DWORD PTR [ecx], eax

; 1290 : 
; 1291 :             *pdwLoopLength /= m_pwfxFormat->nChannels * XBOX_ADPCM_SAMPLES_PER_BLOCK;

  00087	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0008a	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0008d	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00091	c1 e1 06	 shl	 ecx, 6
  00094	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  00097	8b 02		 mov	 eax, DWORD PTR [edx]
  00099	33 d2		 xor	 edx, edx
  0009b	f7 f1		 div	 ecx
  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwLoopLength$[ebp]
  000a0	89 01		 mov	 DWORD PTR [ecx], eax

; 1292 :             *pdwLoopLength *= m_pwfxFormat->nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

  000a2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000a8	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  000ac	6b c9 24	 imul	 ecx, 36			; 00000024H
  000af	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  000b2	8b 02		 mov	 eax, DWORD PTR [edx]
  000b4	0f af c1	 imul	 eax, ecx
  000b7	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwLoopLength$[ebp]
  000ba	89 01		 mov	 DWORD PTR [ecx], eax

; 1293 :         }
; 1294 :         else

  000bc	eb 2e		 jmp	 SHORT $L35627
$L35628:

; 1295 :         {
; 1296 :             *pdwLoopStart *= m_pwfxFormat->nBlockAlign;

  000be	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000c1	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000c4	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  000c8	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  000cb	8b 02		 mov	 eax, DWORD PTR [edx]
  000cd	0f af c1	 imul	 eax, ecx
  000d0	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  000d3	89 01		 mov	 DWORD PTR [ecx], eax

; 1297 :             *pdwLoopLength *= m_pwfxFormat->nBlockAlign;

  000d5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000d8	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000db	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  000df	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  000e2	8b 02		 mov	 eax, DWORD PTR [edx]
  000e4	0f af c1	 imul	 eax, ecx
  000e7	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwLoopLength$[ebp]
  000ea	89 01		 mov	 DWORD PTR [ecx], eax
$L35627:

; 1298 :         }
; 1299 :     }
; 1300 : 
; 1301 :     DPF_LEAVE_HRESULT(hr);
; 1302 : 
; 1303 :     return hr;

  000ec	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1304 : }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 08 00	 ret	 8
?GetLoopRegion@CWaveFile@WaveLoader@@QAEJPAK0@Z ENDP	; WaveLoader::CWaveFile::GetLoopRegion
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
DSOUND	SEGMENT
_this$ = -76
$T41139 = -72
_InstrumentChunk$ = -68
_hr$ = -44
_dwOffset$ = -40
_loop$ = -36
_wsamp$ = -20
_pdwLoopStart$ = 8
_pdwLoopLength$ = 12
?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z PROC NEAR ; WaveLoader::CWaveFile::GetWaveLoopRegion, COMDAT
; _this$ = ecx

; 1332 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 1333 :     CRiffChunk              InstrumentChunk;

  00009	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1334 :     WAVESAMPLE              wsamp;
; 1335 :     WAVESAMPLE_LOOP         loop;
; 1336 :     DWORD                   dwOffset;
; 1337 :     HRESULT                 hr;
; 1338 : 
; 1339 :     DPF_ENTER();
; 1340 : 
; 1341 :     ASSERT(m_pwfxFormat);
; 1342 : 
; 1343 :     //
; 1344 :     // Open the instrument chunk
; 1345 :     //
; 1346 : 
; 1347 :     hr = InstrumentChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_WAVE_SAMPLE);

  00011	68 77 73 6d 70	 push	 1886221175		; 706d7377H
  00016	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	51		 push	 ecx
  00021	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00024	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00029	89 45 d4	 mov	 DWORD PTR _hr$[ebp], eax

; 1348 : 
; 1349 :     //
; 1350 :     // Read the WAVESAMPLE header and first loop region
; 1351 :     //
; 1352 : 
; 1353 :     if(SUCCEEDED(hr))

  0002c	83 7d d4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00030	7c 15		 jl	 SHORT $L35641

; 1354 :     {
; 1355 :         hr = InstrumentChunk.Read(0, &wsamp, sizeof(wsamp));

  00032	6a 00		 push	 0
  00034	6a 14		 push	 20			; 00000014H
  00036	8d 55 ec	 lea	 edx, DWORD PTR _wsamp$[ebp]
  00039	52		 push	 edx
  0003a	6a 00		 push	 0
  0003c	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  0003f	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00044	89 45 d4	 mov	 DWORD PTR _hr$[ebp], eax
$L35641:

; 1356 :     }
; 1357 : 
; 1358 :     //
; 1359 :     // Scan loop regions until we find one that's FORWARD or RELEASE
; 1360 :     //
; 1361 : 
; 1362 :     if(SUCCEEDED(hr))

  00047	83 7d d4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004b	7c 52		 jl	 SHORT $L35643

; 1363 :     {
; 1364 :         dwOffset = sizeof(wsamp);

  0004d	c7 45 d8 14 00
	00 00		 mov	 DWORD PTR _dwOffset$[ebp], 20 ; 00000014H
$L35645:

; 1365 :     
; 1366 :         while(SUCCEEDED(hr) && wsamp.dwSampleLoops)

  00054	83 7d d4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00058	7c 45		 jl	 SHORT $L35643
  0005a	83 7d fc 00	 cmp	 DWORD PTR _wsamp$[ebp+16], 0
  0005e	74 3f		 je	 SHORT $L35643

; 1367 :         {
; 1368 :             hr = InstrumentChunk.Read(dwOffset, &loop, sizeof(loop));

  00060	6a 00		 push	 0
  00062	6a 10		 push	 16			; 00000010H
  00064	8d 45 dc	 lea	 eax, DWORD PTR _loop$[ebp]
  00067	50		 push	 eax
  00068	8b 4d d8	 mov	 ecx, DWORD PTR _dwOffset$[ebp]
  0006b	51		 push	 ecx
  0006c	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  0006f	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00074	89 45 d4	 mov	 DWORD PTR _hr$[ebp], eax

; 1369 : 
; 1370 :             if(SUCCEEDED(hr))

  00077	83 7d d4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0007b	7c 0e		 jl	 SHORT $L35649

; 1371 :             {
; 1372 :                 if((WAVESAMPLE_LOOPTYPE_FORWARD == loop.dwLoopType) || (WAVESAMPLE_LOOPTYPE_RELEASE == loop.dwLoopType))

  0007d	83 7d e0 00	 cmp	 DWORD PTR _loop$[ebp+4], 0
  00081	74 06		 je	 SHORT $L35651
  00083	83 7d e0 01	 cmp	 DWORD PTR _loop$[ebp+4], 1
  00087	75 02		 jne	 SHORT $L35649
$L35651:

; 1373 :                 {
; 1374 :                     break;

  00089	eb 14		 jmp	 SHORT $L35643
$L35649:

; 1375 :                 }
; 1376 :             }
; 1377 :         
; 1378 :             dwOffset += sizeof(loop);

  0008b	8b 55 d8	 mov	 edx, DWORD PTR _dwOffset$[ebp]
  0008e	83 c2 10	 add	 edx, 16			; 00000010H
  00091	89 55 d8	 mov	 DWORD PTR _dwOffset$[ebp], edx

; 1379 : 
; 1380 :             wsamp.dwSampleLoops--;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _wsamp$[ebp+16]
  00097	83 e8 01	 sub	 eax, 1
  0009a	89 45 fc	 mov	 DWORD PTR _wsamp$[ebp+16], eax

; 1381 :         }

  0009d	eb b5		 jmp	 SHORT $L35645
$L35643:

; 1382 :     }
; 1383 : 
; 1384 :     if(SUCCEEDED(hr))

  0009f	83 7d d4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a3	7c 0d		 jl	 SHORT $L35653

; 1385 :     {
; 1386 :         if(!wsamp.dwSampleLoops)

  000a5	83 7d fc 00	 cmp	 DWORD PTR _wsamp$[ebp+16], 0
  000a9	75 07		 jne	 SHORT $L35653

; 1387 :         {
; 1388 :             DPF_ERROR("No FORWARD loop regions found");
; 1389 :             hr = E_FAIL;

  000ab	c7 45 d4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35653:

; 1390 :         }
; 1391 :         else if(wsamp.dwSampleLoops > 1)
; 1392 :         {
; 1393 :             DPF_WARNING("Only the first FORWARD loop will be used");
; 1394 :         }
; 1395 :     }
; 1396 : 
; 1397 :     //
; 1398 :     // Success
; 1399 :     //
; 1400 : 
; 1401 :     if(SUCCEEDED(hr))

  000b2	83 7d d4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b6	7c 10		 jl	 SHORT $L35659

; 1402 :     {
; 1403 :         *pdwLoopStart = loop.dwLoopStart;

  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _pdwLoopStart$[ebp]
  000bb	8b 55 e4	 mov	 edx, DWORD PTR _loop$[ebp+8]
  000be	89 11		 mov	 DWORD PTR [ecx], edx

; 1404 :         *pdwLoopLength = loop.dwLoopLength;

  000c0	8b 45 0c	 mov	 eax, DWORD PTR _pdwLoopLength$[ebp]
  000c3	8b 4d e8	 mov	 ecx, DWORD PTR _loop$[ebp+12]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx
$L35659:

; 1405 :     }
; 1406 : 
; 1407 :     DPF_LEAVE_HRESULT(hr);
; 1408 : 
; 1409 :     return hr;

  000c8	8b 55 d4	 mov	 edx, DWORD PTR _hr$[ebp]
  000cb	89 55 b8	 mov	 DWORD PTR $T41139[ebp], edx
  000ce	8d 4d bc	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  000d1	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  000d6	8b 45 b8	 mov	 eax, DWORD PTR $T41139[ebp]

; 1410 : }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 08 00	 ret	 8
?GetWaveLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ENDP ; WaveLoader::CWaveFile::GetWaveLoopRegion
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z
DSOUND	SEGMENT
_this$ = -108
$T41143 = -104
_InstrumentChunk$ = -100
_pEndMarker$ = -76
_hr$ = -72
_inst$ = -64
_pLoop$ = -44
_pMarkers$ = -40
_MarkerChunk$ = -36
_i$ = -12
_dwMarkerSize$ = -8
_pStartMarker$ = -4
_pdwLoopStart$ = 8
_pdwLoopLength$ = 12
?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z PROC NEAR ; WaveLoader::CWaveFile::GetAiffLoopRegion, COMDAT
; _this$ = ecx

; 1438 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	89 4d 94	 mov	 DWORD PTR _this$[ebp], ecx

; 1439 :     LPAIFFMARKERHDR         pMarkers            = NULL;

  00009	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pMarkers$[ebp], 0

; 1440 :     CRiffChunk              InstrumentChunk;

  00010	8d 4d 9c	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1441 :     AIFFINSTRUMENT          inst;
; 1442 :     LPAIFFLOOP              pLoop;
; 1443 :     CRiffChunk              MarkerChunk;

  00018	8d 4d dc	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::CRiffChunk

; 1444 :     DWORD                   dwMarkerSize;
; 1445 :     AIFFMARKERHDR           MarkerHeader;
; 1446 :     LPAIFFMARKER            pStartMarker;
; 1447 :     LPAIFFMARKER            pEndMarker;
; 1448 :     HRESULT                 hr;
; 1449 :     WORD                    i;
; 1450 : 
; 1451 :     DPF_ENTER();
; 1452 : 
; 1453 :     //
; 1454 :     // Open the instrument chunk
; 1455 :     //
; 1456 : 
; 1457 :     hr = InstrumentChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_INSTRUMENT);

  00020	68 49 4e 53 54	 push	 1414745673		; 54534e49H
  00025	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 08	 add	 ecx, 8
  0002f	51		 push	 ecx
  00030	8d 4d 9c	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  00033	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  00038	89 45 b8	 mov	 DWORD PTR _hr$[ebp], eax

; 1458 : 
; 1459 :     //
; 1460 :     // Read the instrument data
; 1461 :     //
; 1462 : 
; 1463 :     if(SUCCEEDED(hr))

  0003b	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0003f	7c 15		 jl	 SHORT $L35678

; 1464 :     {
; 1465 :         hr = InstrumentChunk.Read(0, &inst, sizeof(inst));

  00041	6a 00		 push	 0
  00043	6a 14		 push	 20			; 00000014H
  00045	8d 55 c0	 lea	 edx, DWORD PTR _inst$[ebp]
  00048	52		 push	 edx
  00049	6a 00		 push	 0
  0004b	8d 4d 9c	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  0004e	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00053	89 45 b8	 mov	 DWORD PTR _hr$[ebp], eax
$L35678:

; 1466 :     }
; 1467 : 
; 1468 :     //
; 1469 :     // Use the first loop that's FORWARD
; 1470 :     //
; 1471 : 
; 1472 :     if(SUCCEEDED(hr))

  00056	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0005a	7c 37		 jl	 SHORT $L35680

; 1473 :     {
; 1474 :         if(AIFFLOOP_MODE_FORWARD == EndianSwapWord(inst.SustainLoop.wPlayMode))

  0005c	8b 4d c8	 mov	 ecx, DWORD PTR _inst$[ebp+8]
  0005f	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  00064	0f b7 c0	 movzx	 eax, ax
  00067	83 f8 01	 cmp	 eax, 1
  0006a	75 08		 jne	 SHORT $L35681

; 1475 :         {
; 1476 :             pLoop = &inst.SustainLoop;

  0006c	8d 4d c8	 lea	 ecx, DWORD PTR _inst$[ebp+8]
  0006f	89 4d d4	 mov	 DWORD PTR _pLoop$[ebp], ecx

; 1477 :         }
; 1478 :         else if(AIFFLOOP_MODE_FORWARD == EndianSwapWord(inst.ReleaseLoop.wPlayMode))

  00072	eb 1f		 jmp	 SHORT $L35680
$L35681:
  00074	8b 4d ce	 mov	 ecx, DWORD PTR _inst$[ebp+14]
  00077	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0007c	0f b7 d0	 movzx	 edx, ax
  0007f	83 fa 01	 cmp	 edx, 1
  00082	75 08		 jne	 SHORT $L35683

; 1479 :         {
; 1480 :             pLoop = &inst.ReleaseLoop;

  00084	8d 45 ce	 lea	 eax, DWORD PTR _inst$[ebp+14]
  00087	89 45 d4	 mov	 DWORD PTR _pLoop$[ebp], eax

; 1481 :         }
; 1482 :         else

  0008a	eb 07		 jmp	 SHORT $L35680
$L35683:

; 1483 :         {
; 1484 :             DPF_ERROR("Neither loop is FORWARD");
; 1485 :             hr = E_FAIL;

  0008c	c7 45 b8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35680:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     //
; 1490 :     // Open the marker chunk
; 1491 :     //
; 1492 : 
; 1493 :     if(SUCCEEDED(hr))

  00093	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00097	7c 1b		 jl	 SHORT $L35687

; 1494 :     {
; 1495 :         hr = MarkerChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_MARKER);

  00099	68 4d 41 52 4b	 push	 1263681869		; 4b52414dH
  0009e	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	51		 push	 ecx
  000a2	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	83 c2 08	 add	 edx, 8
  000a8	52		 push	 edx
  000a9	8d 4d dc	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  000ac	e8 00 00 00 00	 call	 ?Open@CRiffChunk@WaveLoader@@QAEJPAV12@PAVCStdFileStream@2@K@Z ; WaveLoader::CRiffChunk::Open
  000b1	89 45 b8	 mov	 DWORD PTR _hr$[ebp], eax
$L35687:

; 1496 :     }
; 1497 : 
; 1498 :     // 
; 1499 :     // Read marker data
; 1500 :     //
; 1501 : 
; 1502 :     if(SUCCEEDED(hr))

  000b4	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b8	7c 31		 jl	 SHORT $L35689

; 1503 :     {
; 1504 :         dwMarkerSize = MarkerChunk.GetDataSize();

  000ba	8d 4d dc	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  000bd	e8 00 00 00 00	 call	 ?GetDataSize@CRiffChunk@WaveLoader@@QAEKXZ ; WaveLoader::CRiffChunk::GetDataSize
  000c2	89 45 f8	 mov	 DWORD PTR _dwMarkerSize$[ebp], eax

; 1505 :         
; 1506 :         hr = HRFROMP(pMarkers = (LPAIFFMARKERHDR)MEMALLOC(BYTE, dwMarkerSize));

  000c5	6a 01		 push	 1
  000c7	8b 45 f8	 mov	 eax, DWORD PTR _dwMarkerSize$[ebp]
  000ca	50		 push	 eax
  000cb	68 44 53 64 61	 push	 1633964868		; 61645344H
  000d0	e8 00 00 00 00	 call	 ?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::MemAlloc
  000d5	89 45 d8	 mov	 DWORD PTR _pMarkers$[ebp], eax
  000d8	33 c9		 xor	 ecx, ecx
  000da	83 7d d8 00	 cmp	 DWORD PTR _pMarkers$[ebp], 0
  000de	0f 95 c1	 setne	 cl
  000e1	49		 dec	 ecx
  000e2	81 e1 0e 00 07
	80		 and	 ecx, -2147024882	; 8007000eH
  000e8	89 4d b8	 mov	 DWORD PTR _hr$[ebp], ecx
$L35689:

; 1507 :     }
; 1508 : 
; 1509 :     if(SUCCEEDED(hr))

  000eb	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ef	7c 17		 jl	 SHORT $L35696

; 1510 :     {
; 1511 :         hr = MarkerChunk.Read(0, pMarkers, dwMarkerSize);

  000f1	6a 00		 push	 0
  000f3	8b 55 f8	 mov	 edx, DWORD PTR _dwMarkerSize$[ebp]
  000f6	52		 push	 edx
  000f7	8b 45 d8	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  000fa	50		 push	 eax
  000fb	6a 00		 push	 0
  000fd	8d 4d dc	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  00100	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00105	89 45 b8	 mov	 DWORD PTR _hr$[ebp], eax
$L35696:

; 1512 :     }
; 1513 : 
; 1514 :     if(SUCCEEDED(hr))

  00108	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0010c	7c 11		 jl	 SHORT $L35698

; 1515 :     {
; 1516 :         pMarkers->wMarkerCount = EndianSwapWord(pMarkers->wMarkerCount);

  0010e	8b 4d d8	 mov	 ecx, DWORD PTR _pMarkers$[ebp]
  00111	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00114	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  00119	8b 55 d8	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  0011c	66 89 02	 mov	 WORD PTR [edx], ax
$L35698:

; 1517 :     }
; 1518 : 
; 1519 :     //
; 1520 :     // Find the loop markers
; 1521 :     //
; 1522 : 
; 1523 :     if(SUCCEEDED(hr))

  0011f	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00123	7c 66		 jl	 SHORT $L35700

; 1524 :     {
; 1525 :         pStartMarker = (LPAIFFMARKER)(pMarkers + 1);

  00125	8b 45 d8	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  00128	83 c0 02	 add	 eax, 2
  0012b	89 45 fc	 mov	 DWORD PTR _pStartMarker$[ebp], eax

; 1526 :         
; 1527 :         for(i = 0; i < pMarkers->wMarkerCount; i++)

  0012e	66 c7 45 f4 00
	00		 mov	 WORD PTR _i$[ebp], 0
  00134	eb 0c		 jmp	 SHORT $L35702
$L35703:
  00136	66 8b 4d f4	 mov	 cx, WORD PTR _i$[ebp]
  0013a	66 83 c1 01	 add	 cx, 1
  0013e	66 89 4d f4	 mov	 WORD PTR _i$[ebp], cx
$L35702:
  00142	0f b7 55 f4	 movzx	 edx, WORD PTR _i$[ebp]
  00146	8b 45 d8	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  00149	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0014c	3b d1		 cmp	 edx, ecx
  0014e	7d 26		 jge	 SHORT $L35704

; 1528 :         {
; 1529 :             ASSERT((DWORD)pStartMarker < (DWORD)pMarkers + dwMarkerSize);
; 1530 :             
; 1531 :             if(pStartMarker->wMarkerId == pLoop->wStartMarker)

  00150	8b 55 fc	 mov	 edx, DWORD PTR _pStartMarker$[ebp]
  00153	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00156	8b 4d d4	 mov	 ecx, DWORD PTR _pLoop$[ebp]
  00159	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  0015d	3b c2		 cmp	 eax, edx
  0015f	75 02		 jne	 SHORT $L35705

; 1532 :             {
; 1533 :                 break;

  00161	eb 13		 jmp	 SHORT $L35704
$L35705:

; 1534 :             }
; 1535 : 
; 1536 :             pStartMarker = (LPAIFFMARKER)((LPBYTE)pStartMarker + sizeof(*pStartMarker) + pStartMarker->bNameLength);

  00163	8b 45 fc	 mov	 eax, DWORD PTR _pStartMarker$[ebp]
  00166	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  0016a	8b 55 fc	 mov	 edx, DWORD PTR _pStartMarker$[ebp]
  0016d	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  00171	89 45 fc	 mov	 DWORD PTR _pStartMarker$[ebp], eax

; 1537 :         }

  00174	eb c0		 jmp	 SHORT $L35703
$L35704:

; 1538 : 
; 1539 :         if(i >= pMarkers->wMarkerCount)

  00176	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$[ebp]
  0017a	8b 55 d8	 mov	 edx, DWORD PTR _pMarkers$[ebp]
  0017d	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00180	3b c8		 cmp	 ecx, eax
  00182	7c 07		 jl	 SHORT $L35700

; 1540 :         {
; 1541 :             DPF_ERROR("Can't find loop start marker");
; 1542 :             hr = E_FAIL;

  00184	c7 45 b8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35700:

; 1543 :         }
; 1544 :     }
; 1545 : 
; 1546 :     if(SUCCEEDED(hr))

  0018b	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0018f	7c 66		 jl	 SHORT $L35711

; 1547 :     {
; 1548 :         pEndMarker = (LPAIFFMARKER)(pMarkers + 1);

  00191	8b 4d d8	 mov	 ecx, DWORD PTR _pMarkers$[ebp]
  00194	83 c1 02	 add	 ecx, 2
  00197	89 4d b4	 mov	 DWORD PTR _pEndMarker$[ebp], ecx

; 1549 :         
; 1550 :         for(i = 0; i < pMarkers->wMarkerCount; i++)

  0019a	66 c7 45 f4 00
	00		 mov	 WORD PTR _i$[ebp], 0
  001a0	eb 0c		 jmp	 SHORT $L35713
$L35714:
  001a2	66 8b 55 f4	 mov	 dx, WORD PTR _i$[ebp]
  001a6	66 83 c2 01	 add	 dx, 1
  001aa	66 89 55 f4	 mov	 WORD PTR _i$[ebp], dx
$L35713:
  001ae	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  001b2	8b 4d d8	 mov	 ecx, DWORD PTR _pMarkers$[ebp]
  001b5	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  001b8	3b c2		 cmp	 eax, edx
  001ba	7d 26		 jge	 SHORT $L35715

; 1551 :         {
; 1552 :             ASSERT((DWORD)pEndMarker < (DWORD)pMarkers + dwMarkerSize);
; 1553 :             
; 1554 :             if(pEndMarker->wMarkerId == pLoop->wEndMarker)

  001bc	8b 45 b4	 mov	 eax, DWORD PTR _pEndMarker$[ebp]
  001bf	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001c2	8b 55 d4	 mov	 edx, DWORD PTR _pLoop$[ebp]
  001c5	0f b7 42 04	 movzx	 eax, WORD PTR [edx+4]
  001c9	3b c8		 cmp	 ecx, eax
  001cb	75 02		 jne	 SHORT $L35716

; 1555 :             {
; 1556 :                 break;

  001cd	eb 13		 jmp	 SHORT $L35715
$L35716:

; 1557 :             }
; 1558 : 
; 1559 :             pEndMarker = (LPAIFFMARKER)((LPBYTE)pEndMarker + sizeof(*pEndMarker) + pEndMarker->bNameLength);

  001cf	8b 4d b4	 mov	 ecx, DWORD PTR _pEndMarker$[ebp]
  001d2	0f b6 51 06	 movzx	 edx, BYTE PTR [ecx+6]
  001d6	8b 45 b4	 mov	 eax, DWORD PTR _pEndMarker$[ebp]
  001d9	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  001dd	89 4d b4	 mov	 DWORD PTR _pEndMarker$[ebp], ecx

; 1560 :         }

  001e0	eb c0		 jmp	 SHORT $L35714
$L35715:

; 1561 : 
; 1562 :         if(i >= pMarkers->wMarkerCount)

  001e2	0f b7 55 f4	 movzx	 edx, WORD PTR _i$[ebp]
  001e6	8b 45 d8	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  001e9	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001ec	3b d1		 cmp	 edx, ecx
  001ee	7c 07		 jl	 SHORT $L35711

; 1563 :         {
; 1564 :             DPF_ERROR("Can't find loop end marker");
; 1565 :             hr = E_FAIL;

  001f0	c7 45 b8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35711:

; 1566 :         }
; 1567 :     }
; 1568 : 
; 1569 :     //
; 1570 :     // Double-check the marker validity
; 1571 :     //
; 1572 : 
; 1573 :     if(SUCCEEDED(hr))

  001f7	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001fb	7c 37		 jl	 SHORT $L35722

; 1574 :     {
; 1575 :         pStartMarker->dwPosition = EndianSwapDword(pStartMarker->dwPosition);

  001fd	8b 55 fc	 mov	 edx, DWORD PTR _pStartMarker$[ebp]
  00200	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  00203	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  00208	8b 4d fc	 mov	 ecx, DWORD PTR _pStartMarker$[ebp]
  0020b	89 41 02	 mov	 DWORD PTR [ecx+2], eax

; 1576 :         pEndMarker->dwPosition = EndianSwapDword(pEndMarker->dwPosition);

  0020e	8b 55 b4	 mov	 edx, DWORD PTR _pEndMarker$[ebp]
  00211	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  00214	e8 00 00 00 00	 call	 ?EndianSwapDword@@YIKK@Z ; EndianSwapDword
  00219	8b 4d b4	 mov	 ecx, DWORD PTR _pEndMarker$[ebp]
  0021c	89 41 02	 mov	 DWORD PTR [ecx+2], eax

; 1577 : 
; 1578 :         if(pStartMarker->dwPosition >= pEndMarker->dwPosition)

  0021f	8b 55 fc	 mov	 edx, DWORD PTR _pStartMarker$[ebp]
  00222	8b 45 b4	 mov	 eax, DWORD PTR _pEndMarker$[ebp]
  00225	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  00228	3b 48 02	 cmp	 ecx, DWORD PTR [eax+2]
  0022b	72 07		 jb	 SHORT $L35722

; 1579 :         {
; 1580 :             DPF_ERROR("Loop end point less-than-or-equal-to start point");
; 1581 :             hr = E_FAIL;

  0022d	c7 45 b8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L35722:

; 1582 :         }
; 1583 :     }
; 1584 : 
; 1585 :     //
; 1586 :     // Success
; 1587 :     //
; 1588 : 
; 1589 :     if(SUCCEEDED(hr))

  00234	83 7d b8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00238	7c 1c		 jl	 SHORT $L35726

; 1590 :     {
; 1591 :         *pdwLoopStart = pStartMarker->dwPosition;

  0023a	8b 55 08	 mov	 edx, DWORD PTR _pdwLoopStart$[ebp]
  0023d	8b 45 fc	 mov	 eax, DWORD PTR _pStartMarker$[ebp]
  00240	8b 48 02	 mov	 ecx, DWORD PTR [eax+2]
  00243	89 0a		 mov	 DWORD PTR [edx], ecx

; 1592 :         *pdwLoopLength = pEndMarker->dwPosition - pStartMarker->dwPosition;

  00245	8b 55 b4	 mov	 edx, DWORD PTR _pEndMarker$[ebp]
  00248	8b 45 fc	 mov	 eax, DWORD PTR _pStartMarker$[ebp]
  0024b	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]
  0024e	2b 48 02	 sub	 ecx, DWORD PTR [eax+2]
  00251	8b 55 0c	 mov	 edx, DWORD PTR _pdwLoopLength$[ebp]
  00254	89 0a		 mov	 DWORD PTR [edx], ecx
$L35726:

; 1593 :     }
; 1594 : 
; 1595 :     //
; 1596 :     // Clean up
; 1597 :     //
; 1598 :     
; 1599 :     MEMFREE(pMarkers);

  00256	83 7d d8 00	 cmp	 DWORD PTR _pMarkers$[ebp], 0
  0025a	74 10		 je	 SHORT $L35727
  0025c	8b 45 d8	 mov	 eax, DWORD PTR _pMarkers$[ebp]
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 ?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::MemFree
  00265	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pMarkers$[ebp], 0
$L35727:

; 1600 : 
; 1601 :     DPF_LEAVE_HRESULT(hr);
; 1602 : 
; 1603 :     return hr;

  0026c	8b 4d b8	 mov	 ecx, DWORD PTR _hr$[ebp]
  0026f	89 4d 98	 mov	 DWORD PTR $T41143[ebp], ecx
  00272	8d 4d dc	 lea	 ecx, DWORD PTR _MarkerChunk$[ebp]
  00275	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  0027a	8d 4d 9c	 lea	 ecx, DWORD PTR _InstrumentChunk$[ebp]
  0027d	e8 00 00 00 00	 call	 ??1CRiffChunk@WaveLoader@@QAE@XZ ; WaveLoader::CRiffChunk::~CRiffChunk
  00282	8b 45 98	 mov	 eax, DWORD PTR $T41143[ebp]

; 1604 : }

  00285	8b e5		 mov	 esp, ebp
  00287	5d		 pop	 ebp
  00288	c2 08 00	 ret	 8
?GetAiffLoopRegion@CWaveFile@WaveLoader@@IAEJPAK0@Z ENDP ; WaveLoader::CWaveFile::GetAiffLoopRegion
DSOUND	ENDS
PUBLIC	?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CWaveFile::ReadSample
PUBLIC	?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm
; Function compile flags: /Odt
;	COMDAT ?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
_dwPosition$ = 8
_pvBuffer$ = 12
_dwBufferSize$ = 16
_pdwRead$ = 20
?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z PROC NEAR ; WaveLoader::CWaveFile::ReadSample, COMDAT
; _this$ = ecx

; 1636 : {                                   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1637 :     HRESULT                 hr;
; 1638 : 
; 1639 :     DPF_ENTER();
; 1640 : 
; 1641 :     hr = m_DataChunk.Read(dwPosition, pvBuffer, dwBufferSize, &dwBufferSize);

  00009	8d 45 10	 lea	 eax, DWORD PTR _dwBufferSize$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR _pvBuffer$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _dwPosition$[ebp]
  00018	50		 push	 eax
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	83 c1 20	 add	 ecx, 32			; 00000020H
  0001f	e8 00 00 00 00	 call	 ?Read@CRiffChunk@WaveLoader@@QAEJKPAXKPAK@Z ; WaveLoader::CRiffChunk::Read
  00024	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1642 : 
; 1643 :     if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType))

  00027	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0002b	7c 19		 jl	 SHORT $L35738
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 79 38 01	 cmp	 DWORD PTR [ecx+56], 1
  00034	75 10		 jne	 SHORT $L35738

; 1644 :     {
; 1645 :         ConvertAiffPcm(pvBuffer, dwBufferSize);

  00036	8b 55 10	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  00039	52		 push	 edx
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm
$L35738:

; 1646 :     }
; 1647 : 
; 1648 :     if(SUCCEEDED(hr) && pdwRead)

  00046	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004a	7c 0e		 jl	 SHORT $L35740
  0004c	83 7d 14 00	 cmp	 DWORD PTR _pdwRead$[ebp], 0
  00050	74 08		 je	 SHORT $L35740

; 1649 :     {
; 1650 :         *pdwRead = dwBufferSize;

  00052	8b 4d 14	 mov	 ecx, DWORD PTR _pdwRead$[ebp]
  00055	8b 55 10	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  00058	89 11		 mov	 DWORD PTR [ecx], edx
$L35740:

; 1651 :     }
; 1652 : 
; 1653 :     DPF_LEAVE_HRESULT(hr);
; 1654 : 
; 1655 :     return hr;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1656 : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 10 00	 ret	 16			; 00000010H
?ReadSample@CWaveFile@WaveLoader@@QAEJKPAXKPAK@Z ENDP	; WaveLoader::CWaveFile::ReadSample
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?Close@CWaveFile@WaveLoader@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Close@CWaveFile@WaveLoader@@QAEXXZ PROC NEAR		; WaveLoader::CWaveFile::Close, COMDAT
; _this$ = ecx

; 1682 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1683 :     DPF_ENTER();
; 1684 : 
; 1685 :     m_Stream.Close();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Close@CStdFileStream@WaveLoader@@QAEXXZ ; WaveLoader::CStdFileStream::Close

; 1686 : 
; 1687 :     MEMFREE(m_pwfxFormat);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00016	74 16		 je	 SHORT $L35744
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 ?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::MemFree
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
$L35744:

; 1688 : 
; 1689 :     DPF_LEAVE_VOID();
; 1690 : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?Close@CWaveFile@WaveLoader@@QAEXXZ ENDP		; WaveLoader::CWaveFile::Close
DSOUND	ENDS
PUBLIC	?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm
; Function compile flags: /Odt
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z
DSOUND	SEGMENT
_this$ = -12
_pvSource$ = 8
_cbSource$ = 12
?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z PROC NEAR ; WaveLoader::CWaveFile::ConvertAiffPcm, COMDAT
; _this$ = ecx

; 1718 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1719 :     BYTE *                  pbSource;
; 1720 :     BYTE                    bTemp;
; 1721 : 
; 1722 :     DPF_ENTER();
; 1723 : 
; 1724 :     ASSERT(m_pwfxFormat);
; 1725 :     ASSERT(WAVE_FORMAT_PCM == m_pwfxFormat->wFormatTag);
; 1726 : 
; 1727 :     ConvertAiffPcm(pvSource, cbSource, m_pwfxFormat->wBitsPerSample);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0000f	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  00013	52		 push	 edx
  00014	8b 45 0c	 mov	 eax, DWORD PTR _cbSource$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _pvSource$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z ; WaveLoader::CWaveFile::ConvertAiffPcm

; 1728 : 
; 1729 :     DPF_LEAVE_VOID();
; 1730 : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?ConvertAiffPcm@CWaveFile@WaveLoader@@QAEXPAXK@Z ENDP	; WaveLoader::CWaveFile::ConvertAiffPcm
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z
DSOUND	SEGMENT
_pwSource$ = -12
_pbSource$ = -4
_pvSource$ = 8
_cbSource$ = 12
_dwBitDepth$ = 16
?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z PROC NEAR ; WaveLoader::CWaveFile::ConvertAiffPcm, COMDAT

; 1760 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1761 :     BYTE *                  pbSource;
; 1762 :     WORD *                  pwSource;
; 1763 :     BYTE                    bTemp;
; 1764 : 
; 1765 :     DPF_ENTER();
; 1766 : 
; 1767 :     if(16 == dwBitDepth)

  00006	83 7d 10 10	 cmp	 DWORD PTR _dwBitDepth$[ebp], 16 ; 00000010H
  0000a	75 3d		 jne	 SHORT $L35761

; 1768 :     {
; 1769 :         cbSource /= 2;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _cbSource$[ebp]
  0000f	d1 e8		 shr	 eax, 1
  00011	89 45 0c	 mov	 DWORD PTR _cbSource$[ebp], eax

; 1770 :         
; 1771 :         for(pwSource = (WORD *)pvSource; cbSource; cbSource--, pwSource++)

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pvSource$[ebp]
  00017	89 4d f4	 mov	 DWORD PTR _pwSource$[ebp], ecx
  0001a	eb 12		 jmp	 SHORT $L35763
$L35764:
  0001c	8b 55 0c	 mov	 edx, DWORD PTR _cbSource$[ebp]
  0001f	83 ea 01	 sub	 edx, 1
  00022	89 55 0c	 mov	 DWORD PTR _cbSource$[ebp], edx
  00025	8b 45 f4	 mov	 eax, DWORD PTR _pwSource$[ebp]
  00028	83 c0 02	 add	 eax, 2
  0002b	89 45 f4	 mov	 DWORD PTR _pwSource$[ebp], eax
$L35763:
  0002e	83 7d 0c 00	 cmp	 DWORD PTR _cbSource$[ebp], 0
  00032	74 13		 je	 SHORT $L35765

; 1772 :         {
; 1773 :             *pwSource = EndianSwapWord(*pwSource);

  00034	8b 4d f4	 mov	 ecx, DWORD PTR _pwSource$[ebp]
  00037	66 8b 09	 mov	 cx, WORD PTR [ecx]
  0003a	e8 00 00 00 00	 call	 ?EndianSwapWord@@YIGG@Z	; EndianSwapWord
  0003f	8b 55 f4	 mov	 edx, DWORD PTR _pwSource$[ebp]
  00042	66 89 02	 mov	 WORD PTR [edx], ax

; 1774 :         }

  00045	eb d5		 jmp	 SHORT $L35764
$L35765:

; 1775 :     }
; 1776 :     else

  00047	eb 33		 jmp	 SHORT $L35757
$L35761:

; 1777 :     {
; 1778 :         ASSERT(8 == dwBitDepth);
; 1779 :         
; 1780 :         for(pbSource = (BYTE *)pvSource; cbSource; cbSource--, pbSource++)

  00049	8b 45 08	 mov	 eax, DWORD PTR _pvSource$[ebp]
  0004c	89 45 fc	 mov	 DWORD PTR _pbSource$[ebp], eax
  0004f	eb 12		 jmp	 SHORT $L35768
$L35769:
  00051	8b 4d 0c	 mov	 ecx, DWORD PTR _cbSource$[ebp]
  00054	83 e9 01	 sub	 ecx, 1
  00057	89 4d 0c	 mov	 DWORD PTR _cbSource$[ebp], ecx
  0005a	8b 55 fc	 mov	 edx, DWORD PTR _pbSource$[ebp]
  0005d	83 c2 01	 add	 edx, 1
  00060	89 55 fc	 mov	 DWORD PTR _pbSource$[ebp], edx
$L35768:
  00063	83 7d 0c 00	 cmp	 DWORD PTR _cbSource$[ebp], 0
  00067	74 13		 je	 SHORT $L35757

; 1781 :         {
; 1782 :             *pbSource = *pbSource + 0x80;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _pbSource$[ebp]
  0006c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0006f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00075	8b 55 fc	 mov	 edx, DWORD PTR _pbSource$[ebp]
  00078	88 0a		 mov	 BYTE PTR [edx], cl

; 1783 :         }

  0007a	eb d5		 jmp	 SHORT $L35769
$L35757:

; 1784 :     }
; 1785 : 
; 1786 :     DPF_LEAVE_VOID();
; 1787 : }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 0c 00	 ret	 12			; 0000000cH
?ConvertAiffPcm@CWaveFile@WaveLoader@@SGXPAXKK@Z ENDP	; WaveLoader::CWaveFile::ConvertAiffPcm
DSOUND	ENDS
PUBLIC	??_7CImaAdpcmCodec@DirectSound@@6B@		; DirectSound::CImaAdpcmCodec::`vftable'
PUBLIC	??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z	; DirectSound::CImaAdpcmCodec::`scalar deleting destructor'
PUBLIC	??0CImaAdpcmCodec@DirectSound@@QAE@XZ		; DirectSound::CImaAdpcmCodec::CImaAdpcmCodec
EXTRN	??_ECImaAdpcmCodec@DirectSound@@UAEPAXI@Z:NEAR	; DirectSound::CImaAdpcmCodec::`vector deleting destructor'
;	COMDAT ??_7CImaAdpcmCodec@DirectSound@@6B@
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
CONST	SEGMENT
??_7CImaAdpcmCodec@DirectSound@@6B@ DD FLAT:??_ECImaAdpcmCodec@DirectSound@@UAEPAXI@Z ; DirectSound::CImaAdpcmCodec::`vftable'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CImaAdpcmCodec@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CImaAdpcmCodec@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CImaAdpcmCodec::CImaAdpcmCodec, COMDAT
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CImaAdpcmCodec@DirectSound@@6B@

; 70   : }

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0CImaAdpcmCodec@DirectSound@@QAE@XZ ENDP		; DirectSound::CImaAdpcmCodec::CImaAdpcmCodec
DSOUND	ENDS
PUBLIC	??1CImaAdpcmCodec@DirectSound@@UAE@XZ		; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec
; Function compile flags: /Odt
;	COMDAT ??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z PROC NEAR	; DirectSound::CImaAdpcmCodec::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CImaAdpcmCodec@DirectSound@@UAE@XZ ; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L35780
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L35780:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCImaAdpcmCodec@DirectSound@@UAEPAXI@Z ENDP		; DirectSound::CImaAdpcmCodec::`scalar deleting destructor'
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\memmgr.h
DSOUND	ENDS
;	COMDAT ??3@YAXPAX@Z
DSOUND	SEGMENT
_pvBuffer$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 244  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  :     DirectSound::CMemoryManager::TrackingMemFree(pvBuffer); 

  00003	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::MemFree

; 246  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
DSOUND	ENDS
;	COMDAT ??1CImaAdpcmCodec@DirectSound@@UAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CImaAdpcmCodec@DirectSound@@UAE@XZ PROC NEAR		; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec, COMDAT
; _this$ = ecx

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CImaAdpcmCodec@DirectSound@@6B@

; 93   : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1CImaAdpcmCodec@DirectSound@@UAE@XZ ENDP		; DirectSound::CImaAdpcmCodec::~CImaAdpcmCodec
DSOUND	ENDS
PUBLIC	?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z ; DirectSound::CImaAdpcmCodec::Initialize
PUBLIC	?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat
PUBLIC	?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::EncodeM16
PUBLIC	?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::EncodeS16
PUBLIC	?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::DecodeM16
PUBLIC	?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; DirectSound::CImaAdpcmCodec::DecodeS16
;	COMDAT ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA
DSOUND_RD	SEGMENT
?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA DD FLAT:?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ; `DirectSound::CImaAdpcmCodec::Initialize'::`2'::apfnConvert
	DD	FLAT:?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
	DD	FLAT:?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
	DD	FLAT:?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z
DSOUND	SEGMENT
_this$ = -4
_pwfxEncode$ = 8
_fEncoder$ = 12
?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::Initialize, COMDAT
; _this$ = ecx

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  :     static const LPFNIMAADPCMCONVERT    apfnConvert[2][2] = 
; 120  :     { 
; 121  :         {
; 122  :             DecodeM16,
; 123  :             DecodeS16 
; 124  :         },
; 125  :         {
; 126  :             EncodeM16,
; 127  :             EncodeS16 
; 128  :         }
; 129  :     };
; 130  :     
; 131  :     if(!IsValidImaAdpcmFormat(pwfxEncode))

  00009	8b 45 08	 mov	 eax, DWORD PTR _pwfxEncode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat
  00012	85 c0		 test	 eax, eax
  00014	75 04		 jne	 SHORT $L35792

; 132  :     {
; 133  :         return FALSE;

  00016	33 c0		 xor	 eax, eax
  00018	eb 59		 jmp	 SHORT $L35789
$L35792:

; 134  :     }
; 135  : 
; 136  :     //
; 137  :     // Save the format data
; 138  :     //
; 139  : 
; 140  :     m_wfxEncode = *pwfxEncode;

  0001a	8b 75 08	 mov	 esi, DWORD PTR _pwfxEncode$[ebp]
  0001d	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  00020	83 c7 04	 add	 edi, 4
  00023	b9 05 00 00 00	 mov	 ecx, 5
  00028	f3 a5		 rep movsd

; 141  :     m_fEncoder = !!fEncoder;

  0002a	33 c9		 xor	 ecx, ecx
  0002c	83 7d 0c 00	 cmp	 DWORD PTR _fEncoder$[ebp], 0
  00030	0f 95 c1	 setne	 cl
  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 142  : 
; 143  :     //
; 144  :     // Set up the conversion function
; 145  :     //
; 146  : 
; 147  :     m_pfnConvert = apfnConvert[m_fEncoder][m_wfxEncode.wfx.nChannels - 1];

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00042	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  00046	8d 14 85 fc ff
	ff ff		 lea	 edx, DWORD PTR [eax*4-4]
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 8c ca 00 00
	00 00		 mov	 ecx, DWORD PTR ?apfnConvert@?1??Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z@4QAY01Q6GHPAE1IIIPAH2@ZA[edx+ecx*8]
  00057	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 148  : 
; 149  :     //
; 150  :     // Initialize the stepping indeces
; 151  :     //
; 152  : 
; 153  :     m_nStepIndexL = m_nStepIndexR = 0;

  0005a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 154  : 
; 155  :     return TRUE;

  0006e	b8 01 00 00 00	 mov	 eax, 1
$L35789:

; 156  : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 08 00	 ret	 8
?Initialize@CImaAdpcmCodec@DirectSound@@QAEHPBUxbox_adpcmwaveformat_tag@@H@Z ENDP ; DirectSound::CImaAdpcmCodec::Initialize
DSOUND	ENDS
PUBLIC	?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z ; DirectSound::CImaAdpcmCodec::Convert
; Function compile flags: /Odt
;	COMDAT ?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z
DSOUND	SEGMENT
_this$ = -4
_pvSrc$ = 8
_pvDst$ = 12
_cBlocks$ = 16
?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::Convert, COMDAT
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  :     return m_pfnConvert((LPBYTE)pvSrc, (LPBYTE)pvDst, cBlocks, m_wfxEncode.wfx.nBlockAlign, m_wfxEncode.wSamplesPerBlock, &m_nStepIndexL, &m_nStepIndexR);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 20	 add	 eax, 32			; 00000020H
  0000d	50		 push	 eax
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00014	51		 push	 ecx
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	0f b7 42 16	 movzx	 eax, WORD PTR [edx+22]
  0001c	50		 push	 eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	0f b7 51 10	 movzx	 edx, WORD PTR [ecx+16]
  00024	52		 push	 edx
  00025	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _pvDst$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 55 08	 mov	 edx, DWORD PTR _pvSrc$[ebp]
  00030	52		 push	 edx
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	ff 50 24	 call	 DWORD PTR [eax+36]

; 185  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 0c 00	 ret	 12			; 0000000cH
?Convert@CImaAdpcmCodec@DirectSound@@QAEHPBXPAXI@Z ENDP	; DirectSound::CImaAdpcmCodec::Convert
DSOUND	ENDS
PUBLIC	?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ	; DirectSound::CImaAdpcmCodec::Reset
; Function compile flags: /Odt
;	COMDAT ?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ PROC NEAR	; DirectSound::CImaAdpcmCodec::Reset, COMDAT
; _this$ = ecx

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 209  :     //
; 210  :     // Reset the stepping indeces
; 211  :     //
; 212  : 
; 213  :     m_nStepIndexL = m_nStepIndexR = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 214  : }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?Reset@CImaAdpcmCodec@DirectSound@@QAEXXZ ENDP		; DirectSound::CImaAdpcmCodec::Reset
DSOUND	ENDS
PUBLIC	?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ; DirectSound::CImaAdpcmCodec::GetEncodeAlignment
; Function compile flags: /Odt
;	COMDAT ?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
DSOUND	SEGMENT
_this$ = -4
?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ PROC NEAR ; DirectSound::CImaAdpcmCodec::GetEncodeAlignment, COMDAT
; _this$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 238  :     return m_wfxEncode.wfx.nBlockAlign;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 40 10	 mov	 ax, WORD PTR [eax+16]

; 239  : }

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?GetEncodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ENDP ; DirectSound::CImaAdpcmCodec::GetEncodeAlignment
DSOUND	ENDS
PUBLIC	?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ; DirectSound::CImaAdpcmCodec::GetDecodeAlignment
; Function compile flags: /Odt
;	COMDAT ?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ
DSOUND	SEGMENT
_this$ = -4
?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ PROC NEAR ; DirectSound::CImaAdpcmCodec::GetDecodeAlignment, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 263  :     return m_wfxEncode.wSamplesPerBlock * m_wfxEncode.wfx.nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b7 40 16	 movzx	 eax, WORD PTR [eax+22]
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  00015	0f af c2	 imul	 eax, edx
  00018	c1 e0 04	 shl	 eax, 4
  0001b	99		 cdq
  0001c	83 e2 07	 and	 edx, 7
  0001f	03 c2		 add	 eax, edx
  00021	c1 f8 03	 sar	 eax, 3

; 264  : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?GetDecodeAlignment@CImaAdpcmCodec@DirectSound@@QAEGXZ ENDP ; DirectSound::CImaAdpcmCodec::GetDecodeAlignment
DSOUND	ENDS
PUBLIC	?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
; Function compile flags: /Odt
;	COMDAT ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z
DSOUND	SEGMENT
_nHeaderBytes$ = -12
_nBlockAlign$ = -8
_nEncodedSampleBits$ = -4
_nChannels$ = 8
_nSamplesPerBlock$ = 12
?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment, COMDAT

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 291  :     const WORD              nEncodedSampleBits  = nChannels * IMAADPCM_BITS_PER_SAMPLE;

  00006	0f b7 45 08	 movzx	 eax, WORD PTR _nChannels$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	66 89 45 fc	 mov	 WORD PTR _nEncodedSampleBits$[ebp], ax

; 292  :     const WORD              nHeaderBytes        = nChannels * IMAADPCM_HEADER_LENGTH;

  00011	0f b7 4d 08	 movzx	 ecx, WORD PTR _nChannels$[ebp]
  00015	c1 e1 02	 shl	 ecx, 2
  00018	66 89 4d f4	 mov	 WORD PTR _nHeaderBytes$[ebp], cx

; 293  :     WORD                    nBlockAlign;
; 294  : 
; 295  :     //
; 296  :     // Calculate the raw block alignment that nSamplesPerBlock dictates.  This
; 297  :     // value may include a partial encoded sample, so be sure to round up.
; 298  :     //
; 299  :     // Start with the samples-per-block, minus 1.  The first sample is actually
; 300  :     // stored in the header.
; 301  :     //
; 302  : 
; 303  :     nBlockAlign = nSamplesPerBlock - 1;

  0001c	0f b7 55 0c	 movzx	 edx, WORD PTR _nSamplesPerBlock$[ebp]
  00020	83 ea 01	 sub	 edx, 1
  00023	66 89 55 f8	 mov	 WORD PTR _nBlockAlign$[ebp], dx

; 304  : 
; 305  :     //
; 306  :     // Convert to encoded sample size
; 307  :     //
; 308  : 
; 309  :     nBlockAlign *= nEncodedSampleBits;

  00027	0f b7 45 fc	 movzx	 eax, WORD PTR _nEncodedSampleBits$[ebp]
  0002b	0f b7 4d f8	 movzx	 ecx, WORD PTR _nBlockAlign$[ebp]
  0002f	0f af c8	 imul	 ecx, eax
  00032	66 89 4d f8	 mov	 WORD PTR _nBlockAlign$[ebp], cx

; 310  :     nBlockAlign += 7;

  00036	0f b7 55 f8	 movzx	 edx, WORD PTR _nBlockAlign$[ebp]
  0003a	83 c2 07	 add	 edx, 7
  0003d	66 89 55 f8	 mov	 WORD PTR _nBlockAlign$[ebp], dx

; 311  :     nBlockAlign /= 8;

  00041	0f b7 45 f8	 movzx	 eax, WORD PTR _nBlockAlign$[ebp]
  00045	99		 cdq
  00046	83 e2 07	 and	 edx, 7
  00049	03 c2		 add	 eax, edx
  0004b	c1 f8 03	 sar	 eax, 3
  0004e	66 89 45 f8	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 312  : 
; 313  :     //
; 314  :     // The stereo encoder requires that there be at least two DWORDs to process
; 315  :     //
; 316  : 
; 317  :     nBlockAlign += 7;

  00052	0f b7 45 f8	 movzx	 eax, WORD PTR _nBlockAlign$[ebp]
  00056	83 c0 07	 add	 eax, 7
  00059	66 89 45 f8	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 318  :     nBlockAlign /= 8;

  0005d	0f b7 45 f8	 movzx	 eax, WORD PTR _nBlockAlign$[ebp]
  00061	99		 cdq
  00062	83 e2 07	 and	 edx, 7
  00065	03 c2		 add	 eax, edx
  00067	c1 f8 03	 sar	 eax, 3
  0006a	66 89 45 f8	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 319  :     nBlockAlign *= 8;

  0006e	0f b7 4d f8	 movzx	 ecx, WORD PTR _nBlockAlign$[ebp]
  00072	c1 e1 03	 shl	 ecx, 3
  00075	66 89 4d f8	 mov	 WORD PTR _nBlockAlign$[ebp], cx

; 320  : 
; 321  :     //
; 322  :     // Add the header
; 323  :     //
; 324  : 
; 325  :     nBlockAlign += nHeaderBytes;

  00079	0f b7 55 f4	 movzx	 edx, WORD PTR _nHeaderBytes$[ebp]
  0007d	0f b7 45 f8	 movzx	 eax, WORD PTR _nBlockAlign$[ebp]
  00081	03 c2		 add	 eax, edx
  00083	66 89 45 f8	 mov	 WORD PTR _nBlockAlign$[ebp], ax

; 326  : 
; 327  :     return nBlockAlign;

  00087	66 8b 45 f8	 mov	 ax, WORD PTR _nBlockAlign$[ebp]

; 328  : }

  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ENDP ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
DSOUND	ENDS
PUBLIC	?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z ; DirectSound::CImaAdpcmCodec::CreatePcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_pwfx$ = 16
?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::CreatePcmFormat, COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  :     pwfx->wFormatTag = WAVE_FORMAT_PCM;

  00003	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	66 c7 00 01 00	 mov	 WORD PTR [eax], 1

; 357  :     pwfx->nChannels = nChannels;

  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0000e	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  00012	66 89 51 02	 mov	 WORD PTR [ecx+2], dx

; 358  :     pwfx->nSamplesPerSec = nSamplesPerSec;

  00016	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0001c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 359  :     pwfx->nBlockAlign = nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;

  0001f	0f b7 45 08	 movzx	 eax, WORD PTR _nChannels$[ebp]
  00023	c1 e0 04	 shl	 eax, 4
  00026	99		 cdq
  00027	83 e2 07	 and	 edx, 7
  0002a	03 c2		 add	 eax, edx
  0002c	c1 f8 03	 sar	 eax, 3
  0002f	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00032	66 89 42 0c	 mov	 WORD PTR [edx+12], ax

; 360  :     pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;

  00036	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00039	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0003d	8b 55 10	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00040	0f af 4a 04	 imul	 ecx, DWORD PTR [edx+4]
  00044	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00047	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 361  :     pwfx->wBitsPerSample = IMAADPCM_PCM_BITS_PER_SAMPLE;

  0004a	8b 4d 10	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0004d	66 c7 41 0e 10
	00		 mov	 WORD PTR [ecx+14], 16	; 00000010H

; 362  : }

  00053	5d		 pop	 ebp
  00054	c2 0c 00	 ret	 12			; 0000000cH
?CreatePcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKPAUtWAVEFORMATEX@@@Z ENDP ; DirectSound::CImaAdpcmCodec::CreatePcmFormat
DSOUND	ENDS
PUBLIC	?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::CImaAdpcmCodec::CreateImaAdpcmFormat
; Function compile flags: /Odt
;	COMDAT ?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_nSamplesPerBlock$ = 16
_pwfx$ = 20
?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUxbox_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::CreateImaAdpcmFormat, COMDAT

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 391  :     pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;

  00004	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00007	66 c7 00 69 00	 mov	 WORD PTR [eax], 105	; 00000069H

; 392  :     pwfx->wfx.nChannels = nChannels;

  0000c	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0000f	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  00013	66 89 51 02	 mov	 WORD PTR [ecx+2], dx

; 393  :     pwfx->wfx.nSamplesPerSec = nSamplesPerSec;

  00017	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0001d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 394  :     pwfx->wfx.nBlockAlign = CalculateEncodeAlignment(nChannels, nSamplesPerBlock);

  00020	66 8b 55 10	 mov	 dx, WORD PTR _nSamplesPerBlock$[ebp]
  00024	52		 push	 edx
  00025	66 8b 45 08	 mov	 ax, WORD PTR _nChannels$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
  0002f	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00032	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 395  :     pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec * pwfx->wfx.nBlockAlign / nSamplesPerBlock;

  00036	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00039	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  00040	0f af c8	 imul	 ecx, eax
  00043	0f b7 75 10	 movzx	 esi, WORD PTR _nSamplesPerBlock$[ebp]
  00047	8b c1		 mov	 eax, ecx
  00049	33 d2		 xor	 edx, edx
  0004b	f7 f6		 div	 esi
  0004d	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00050	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 396  :     pwfx->wfx.wBitsPerSample = IMAADPCM_BITS_PER_SAMPLE;

  00053	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00056	66 c7 40 0e 04
	00		 mov	 WORD PTR [eax+14], 4

; 397  :     pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);

  0005c	8b 4d 14	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0005f	66 c7 41 10 02
	00		 mov	 WORD PTR [ecx+16], 2

; 398  :     pwfx->wSamplesPerBlock = nSamplesPerBlock;

  00065	8b 55 14	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00068	66 8b 45 10	 mov	 ax, WORD PTR _nSamplesPerBlock$[ebp]
  0006c	66 89 42 12	 mov	 WORD PTR [edx+18], ax

; 399  : }

  00070	5e		 pop	 esi
  00071	5d		 pop	 ebp
  00072	c2 10 00	 ret	 16			; 00000010H
?CreateImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGXGKGPAUxbox_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::CImaAdpcmCodec::CreateImaAdpcmFormat
DSOUND	ENDS
PUBLIC	?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z ; DirectSound::CImaAdpcmCodec::IsValidPcmFormat
; Function compile flags: /Odt
;	COMDAT ?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
_pwfx$ = 8
?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::IsValidPcmFormat, COMDAT

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 423  :     if(WAVE_FORMAT_PCM != pwfx->wFormatTag)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00009	83 f9 01	 cmp	 ecx, 1
  0000c	74 04		 je	 SHORT $L35834

; 424  :     {
; 425  :         return FALSE;

  0000e	33 c0		 xor	 eax, eax
  00010	eb 74		 jmp	 SHORT $L35833
$L35834:

; 426  :     }
; 427  :     
; 428  :     if((pwfx->nChannels < 1) || (pwfx->nChannels > IMAADPCM_MAX_CHANNELS))

  00012	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00015	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00019	83 f8 01	 cmp	 eax, 1
  0001c	7c 0c		 jl	 SHORT $L35836
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00021	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00025	83 fa 02	 cmp	 edx, 2
  00028	7e 04		 jle	 SHORT $L35835
$L35836:

; 429  :     {
; 430  :         return FALSE;

  0002a	33 c0		 xor	 eax, eax
  0002c	eb 58		 jmp	 SHORT $L35833
$L35835:

; 431  :     }
; 432  : 
; 433  :     if(IMAADPCM_PCM_BITS_PER_SAMPLE != pwfx->wBitsPerSample)

  0002e	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00031	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00035	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00038	74 04		 je	 SHORT $L35837

; 434  :     {
; 435  :         return FALSE;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 48		 jmp	 SHORT $L35833
$L35837:

; 436  :     }
; 437  : 
; 438  :     if(pwfx->nChannels * pwfx->wBitsPerSample / 8 != pwfx->nBlockAlign)

  0003e	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00041	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00048	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  0004c	0f af c2	 imul	 eax, edx
  0004f	99		 cdq
  00050	83 e2 07	 and	 edx, 7
  00053	03 c2		 add	 eax, edx
  00055	c1 f8 03	 sar	 eax, 3
  00058	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  0005b	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  0005f	3b c2		 cmp	 eax, edx
  00061	74 04		 je	 SHORT $L35838

; 439  :     {
; 440  :         return FALSE;

  00063	33 c0		 xor	 eax, eax
  00065	eb 1f		 jmp	 SHORT $L35833
$L35838:

; 441  :     }
; 442  : 
; 443  :     if(pwfx->nBlockAlign * pwfx->nSamplesPerSec != pwfx->nAvgBytesPerSec)

  00067	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  0006a	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0006e	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00071	0f af 4a 04	 imul	 ecx, DWORD PTR [edx+4]
  00075	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00078	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0007b	74 04		 je	 SHORT $L35839

; 444  :     {
; 445  :         return FALSE;

  0007d	33 c0		 xor	 eax, eax
  0007f	eb 05		 jmp	 SHORT $L35833
$L35839:

; 446  :     }
; 447  : 
; 448  :     return TRUE;

  00081	b8 01 00 00 00	 mov	 eax, 1
$L35833:

; 449  : }

  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
?IsValidPcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::CImaAdpcmCodec::IsValidPcmFormat
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUxbox_adpcmwaveformat_tag@@@Z
DSOUND	SEGMENT
_pwfx$ = 8
?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUxbox_adpcmwaveformat_tag@@@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat, COMDAT

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 473  :     if(WAVE_FORMAT_XBOX_ADPCM != pwfx->wfx.wFormatTag)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00009	83 f9 69	 cmp	 ecx, 105		; 00000069H
  0000c	74 04		 je	 SHORT $L35843

; 474  :     {
; 475  :         return FALSE;

  0000e	33 c0		 xor	 eax, eax
  00010	eb 68		 jmp	 SHORT $L35842
$L35843:

; 476  :     }
; 477  : 
; 478  :     if(sizeof(*pwfx) - sizeof(pwfx->wfx) != pwfx->wfx.cbSize)

  00012	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00015	0f b7 42 10	 movzx	 eax, WORD PTR [edx+16]
  00019	83 f8 02	 cmp	 eax, 2
  0001c	74 04		 je	 SHORT $L35844

; 479  :     {
; 480  :         return FALSE;

  0001e	33 c0		 xor	 eax, eax
  00020	eb 58		 jmp	 SHORT $L35842
$L35844:

; 481  :     }
; 482  :     
; 483  :     if((pwfx->wfx.nChannels < 1) || (pwfx->wfx.nChannels > IMAADPCM_MAX_CHANNELS))

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00025	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00029	83 fa 01	 cmp	 edx, 1
  0002c	7c 0c		 jl	 SHORT $L35846
  0002e	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00031	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00035	83 f9 02	 cmp	 ecx, 2
  00038	7e 04		 jle	 SHORT $L35845
$L35846:

; 484  :     {
; 485  :         return FALSE;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 3c		 jmp	 SHORT $L35842
$L35845:

; 486  :     }
; 487  : 
; 488  :     if(IMAADPCM_BITS_PER_SAMPLE != pwfx->wfx.wBitsPerSample)

  0003e	8b 55 08	 mov	 edx, DWORD PTR _pwfx$[ebp]
  00041	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00045	83 f8 04	 cmp	 eax, 4
  00048	74 04		 je	 SHORT $L35847

; 489  :     {
; 490  :         return FALSE;

  0004a	33 c0		 xor	 eax, eax
  0004c	eb 2c		 jmp	 SHORT $L35842
$L35847:

; 491  :     }
; 492  : 
; 493  :     if(CalculateEncodeAlignment(pwfx->wfx.nChannels, pwfx->wSamplesPerBlock) != pwfx->wfx.nBlockAlign)

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _pwfx$[ebp]
  00051	66 8b 51 12	 mov	 dx, WORD PTR [ecx+18]
  00055	52		 push	 edx
  00056	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00059	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ?CalculateEncodeAlignment@CImaAdpcmCodec@DirectSound@@CGGGG@Z ; DirectSound::CImaAdpcmCodec::CalculateEncodeAlignment
  00063	0f b7 d0	 movzx	 edx, ax
  00066	8b 45 08	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00069	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0006d	3b d1		 cmp	 edx, ecx
  0006f	74 04		 je	 SHORT $L35848

; 494  :     {
; 495  :         return FALSE;

  00071	33 c0		 xor	 eax, eax
  00073	eb 05		 jmp	 SHORT $L35842
$L35848:

; 496  :     }
; 497  : 
; 498  :     return TRUE;

  00075	b8 01 00 00 00	 mov	 eax, 1
$L35842:

; 499  : }

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?IsValidImaAdpcmFormat@CImaAdpcmCodec@DirectSound@@SGHPBUxbox_adpcmwaveformat_tag@@@Z ENDP ; DirectSound::CImaAdpcmCodec::IsValidImaAdpcmFormat
DSOUND	ENDS
PUBLIC	?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
; Function compile flags: /Odt
;	COMDAT ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z
DSOUND	SEGMENT
_lDifference$ = -12
_nPredictedSample$ = -8
_nEncodedSample$ = -4
_nInputSample$ = 8
_pnPredictedSample$ = 12
_nStepSize$ = 16
?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::EncodeSample, COMDAT

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 527  :     int                 nPredictedSample;
; 528  :     LONG                lDifference;
; 529  :     int                 nEncodedSample;
; 530  :     
; 531  :     nPredictedSample = *pnPredictedSample;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _pnPredictedSample$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d f8	 mov	 DWORD PTR _nPredictedSample$[ebp], ecx

; 532  : 
; 533  :     lDifference = nInputSample - nPredictedSample;

  0000e	8b 55 08	 mov	 edx, DWORD PTR _nInputSample$[ebp]
  00011	2b 55 f8	 sub	 edx, DWORD PTR _nPredictedSample$[ebp]
  00014	89 55 f4	 mov	 DWORD PTR _lDifference$[ebp], edx

; 534  :     nEncodedSample = 0;

  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nEncodedSample$[ebp], 0

; 535  : 
; 536  :     if(lDifference < 0) 

  0001e	83 7d f4 00	 cmp	 DWORD PTR _lDifference$[ebp], 0
  00022	7d 0f		 jge	 SHORT $L35857

; 537  :     {
; 538  :         nEncodedSample = 8;

  00024	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR _nEncodedSample$[ebp], 8

; 539  :         lDifference = -lDifference;

  0002b	8b 45 f4	 mov	 eax, DWORD PTR _lDifference$[ebp]
  0002e	f7 d8		 neg	 eax
  00030	89 45 f4	 mov	 DWORD PTR _lDifference$[ebp], eax
$L35857:

; 540  :     }
; 541  : 
; 542  :     if(lDifference >= nStepSize)

  00033	8b 4d f4	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  00036	3b 4d 10	 cmp	 ecx, DWORD PTR _nStepSize$[ebp]
  00039	7c 12		 jl	 SHORT $L35858

; 543  :     {
; 544  :         nEncodedSample |= 4;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _nEncodedSample$[ebp]
  0003e	83 ca 04	 or	 edx, 4
  00041	89 55 fc	 mov	 DWORD PTR _nEncodedSample$[ebp], edx

; 545  :         lDifference -= nStepSize;

  00044	8b 45 f4	 mov	 eax, DWORD PTR _lDifference$[ebp]
  00047	2b 45 10	 sub	 eax, DWORD PTR _nStepSize$[ebp]
  0004a	89 45 f4	 mov	 DWORD PTR _lDifference$[ebp], eax
$L35858:

; 546  :     }
; 547  : 
; 548  :     nStepSize >>= 1;

  0004d	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00050	d1 f9		 sar	 ecx, 1
  00052	89 4d 10	 mov	 DWORD PTR _nStepSize$[ebp], ecx

; 549  : 
; 550  :     if(lDifference >= nStepSize)

  00055	8b 55 f4	 mov	 edx, DWORD PTR _lDifference$[ebp]
  00058	3b 55 10	 cmp	 edx, DWORD PTR _nStepSize$[ebp]
  0005b	7c 12		 jl	 SHORT $L35859

; 551  :     {
; 552  :         nEncodedSample |= 2;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00060	83 c8 02	 or	 eax, 2
  00063	89 45 fc	 mov	 DWORD PTR _nEncodedSample$[ebp], eax

; 553  :         lDifference -= nStepSize;

  00066	8b 4d f4	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  00069	2b 4d 10	 sub	 ecx, DWORD PTR _nStepSize$[ebp]
  0006c	89 4d f4	 mov	 DWORD PTR _lDifference$[ebp], ecx
$L35859:

; 554  :     }
; 555  : 
; 556  :     nStepSize >>= 1;

  0006f	8b 55 10	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  00072	d1 fa		 sar	 edx, 1
  00074	89 55 10	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 557  : 
; 558  :     if(lDifference >= nStepSize)

  00077	8b 45 f4	 mov	 eax, DWORD PTR _lDifference$[ebp]
  0007a	3b 45 10	 cmp	 eax, DWORD PTR _nStepSize$[ebp]
  0007d	7c 12		 jl	 SHORT $L35860

; 559  :     {
; 560  :         nEncodedSample |= 1;

  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _nEncodedSample$[ebp]
  00082	83 c9 01	 or	 ecx, 1
  00085	89 4d fc	 mov	 DWORD PTR _nEncodedSample$[ebp], ecx

; 561  :         lDifference -= nStepSize;

  00088	8b 55 f4	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0008b	2b 55 10	 sub	 edx, DWORD PTR _nStepSize$[ebp]
  0008e	89 55 f4	 mov	 DWORD PTR _lDifference$[ebp], edx
$L35860:

; 562  :     }
; 563  : 
; 564  :     if(nEncodedSample & 8)

  00091	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00094	83 e0 08	 and	 eax, 8
  00097	85 c0		 test	 eax, eax
  00099	74 12		 je	 SHORT $L35861

; 565  :     {
; 566  :         nPredictedSample = nInputSample + lDifference - (nStepSize >> 1);

  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _nInputSample$[ebp]
  0009e	03 4d f4	 add	 ecx, DWORD PTR _lDifference$[ebp]
  000a1	8b 55 10	 mov	 edx, DWORD PTR _nStepSize$[ebp]
  000a4	d1 fa		 sar	 edx, 1
  000a6	2b ca		 sub	 ecx, edx
  000a8	89 4d f8	 mov	 DWORD PTR _nPredictedSample$[ebp], ecx

; 567  :     }
; 568  :     else

  000ab	eb 10		 jmp	 SHORT $L35862
$L35861:

; 569  :     {
; 570  :         nPredictedSample = nInputSample - lDifference + (nStepSize >> 1);

  000ad	8b 45 08	 mov	 eax, DWORD PTR _nInputSample$[ebp]
  000b0	2b 45 f4	 sub	 eax, DWORD PTR _lDifference$[ebp]
  000b3	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  000b6	d1 f9		 sar	 ecx, 1
  000b8	03 c1		 add	 eax, ecx
  000ba	89 45 f8	 mov	 DWORD PTR _nPredictedSample$[ebp], eax
$L35862:

; 571  :     }
; 572  : 
; 573  :     if(nPredictedSample > 32767)

  000bd	81 7d f8 ff 7f
	00 00		 cmp	 DWORD PTR _nPredictedSample$[ebp], 32767 ; 00007fffH
  000c4	7e 09		 jle	 SHORT $L35863

; 574  :     {
; 575  :         nPredictedSample = 32767;

  000c6	c7 45 f8 ff 7f
	00 00		 mov	 DWORD PTR _nPredictedSample$[ebp], 32767 ; 00007fffH

; 576  :     }
; 577  :     else if(nPredictedSample < -32768)

  000cd	eb 10		 jmp	 SHORT $L35864
$L35863:
  000cf	81 7d f8 00 80
	ff ff		 cmp	 DWORD PTR _nPredictedSample$[ebp], -32768 ; ffff8000H
  000d6	7d 07		 jge	 SHORT $L35864

; 578  :     {
; 579  :         nPredictedSample = -32768;

  000d8	c7 45 f8 00 80
	ff ff		 mov	 DWORD PTR _nPredictedSample$[ebp], -32768 ; ffff8000H
$L35864:

; 580  :     }
; 581  : 
; 582  :     *pnPredictedSample = nPredictedSample;

  000df	8b 55 0c	 mov	 edx, DWORD PTR _pnPredictedSample$[ebp]
  000e2	8b 45 f8	 mov	 eax, DWORD PTR _nPredictedSample$[ebp]
  000e5	89 02		 mov	 DWORD PTR [edx], eax

; 583  :     
; 584  :     return nEncodedSample;

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]

; 585  : }

  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c2 0c 00	 ret	 12			; 0000000cH
?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ENDP ; DirectSound::CImaAdpcmCodec::EncodeSample
DSOUND	ENDS
PUBLIC	?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
; Function compile flags: /Odt
;	COMDAT ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z
DSOUND	SEGMENT
_lDifference$ = -8
_lNewSample$ = -4
_nEncodedSample$ = 8
_nPredictedSample$ = 12
_nStepSize$ = 16
?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::DecodeSample, COMDAT

; 612  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 613  :     LONG                lDifference;
; 614  :     LONG                lNewSample;
; 615  : 
; 616  :     lDifference = nStepSize >> 3;

  00006	8b 45 10	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  00009	c1 f8 03	 sar	 eax, 3
  0000c	89 45 f8	 mov	 DWORD PTR _lDifference$[ebp], eax

; 617  : 
; 618  :     if(nEncodedSample & 4) 

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _nEncodedSample$[ebp]
  00012	83 e1 04	 and	 ecx, 4
  00015	85 c9		 test	 ecx, ecx
  00017	74 09		 je	 SHORT $L35873

; 619  :     {
; 620  :         lDifference += nStepSize;

  00019	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0001c	03 55 10	 add	 edx, DWORD PTR _nStepSize$[ebp]
  0001f	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L35873:

; 621  :     }
; 622  : 
; 623  :     if(nEncodedSample & 2) 

  00022	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00025	83 e0 02	 and	 eax, 2
  00028	85 c0		 test	 eax, eax
  0002a	74 0d		 je	 SHORT $L35874

; 624  :     {
; 625  :         lDifference += nStepSize >> 1;

  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  0002f	d1 f9		 sar	 ecx, 1
  00031	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  00034	03 d1		 add	 edx, ecx
  00036	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L35874:

; 626  :     }
; 627  : 
; 628  :     if(nEncodedSample & 1) 

  00039	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  0003c	83 e0 01	 and	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	74 0e		 je	 SHORT $L35875

; 629  :     {
; 630  :         lDifference += nStepSize >> 2;

  00043	8b 4d 10	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00046	c1 f9 02	 sar	 ecx, 2
  00049	8b 55 f8	 mov	 edx, DWORD PTR _lDifference$[ebp]
  0004c	03 d1		 add	 edx, ecx
  0004e	89 55 f8	 mov	 DWORD PTR _lDifference$[ebp], edx
$L35875:

; 631  :     }
; 632  : 
; 633  :     if(nEncodedSample & 8)

  00051	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00054	83 e0 08	 and	 eax, 8
  00057	85 c0		 test	 eax, eax
  00059	74 08		 je	 SHORT $L35876

; 634  :     {
; 635  :         lDifference = -lDifference;

  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _lDifference$[ebp]
  0005e	f7 d9		 neg	 ecx
  00060	89 4d f8	 mov	 DWORD PTR _lDifference$[ebp], ecx
$L35876:

; 636  :     }
; 637  : 
; 638  :     lNewSample = nPredictedSample + lDifference;

  00063	8b 55 0c	 mov	 edx, DWORD PTR _nPredictedSample$[ebp]
  00066	03 55 f8	 add	 edx, DWORD PTR _lDifference$[ebp]
  00069	89 55 fc	 mov	 DWORD PTR _lNewSample$[ebp], edx

; 639  : 
; 640  :     if((LONG)(short)lNewSample != lNewSample)

  0006c	0f bf 45 fc	 movsx	 eax, WORD PTR _lNewSample$[ebp]
  00070	3b 45 fc	 cmp	 eax, DWORD PTR _lNewSample$[ebp]
  00073	74 19		 je	 SHORT $L35879

; 641  :     {
; 642  :         if(lNewSample < -32768)

  00075	81 7d fc 00 80
	ff ff		 cmp	 DWORD PTR _lNewSample$[ebp], -32768 ; ffff8000H
  0007c	7d 09		 jge	 SHORT $L35880

; 643  :         {
; 644  :             lNewSample = -32768;

  0007e	c7 45 fc 00 80
	ff ff		 mov	 DWORD PTR _lNewSample$[ebp], -32768 ; ffff8000H

; 645  :         }
; 646  :         else

  00085	eb 07		 jmp	 SHORT $L35879
$L35880:

; 647  :         {
; 648  :             lNewSample = 32767;

  00087	c7 45 fc ff 7f
	00 00		 mov	 DWORD PTR _lNewSample$[ebp], 32767 ; 00007fffH
$L35879:

; 649  :         }
; 650  :     }
; 651  : 
; 652  :     return (int)lNewSample;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _lNewSample$[ebp]

; 653  : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ENDP	; DirectSound::CImaAdpcmCodec::DecodeSample
DSOUND	ENDS
PUBLIC	?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
; Function compile flags: /Odt
;	COMDAT ?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT
_nPredSample$ = -32
_pbBlock$ = -28
_nStepSize$ = -24
_nEncSample2$ = -20
_nEncSample1$ = -16
_cSamples$ = -12
_nStepIndex$ = -8
_nSample$ = -4
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_pnStepIndexL$ = 28
_pnStepIndexR$ = 32
?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::EncodeM16, COMDAT

; 689  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 690  :     LPBYTE                  pbBlock;
; 691  :     UINT                    cSamples;
; 692  :     int                     nSample;
; 693  :     int                     nStepSize;
; 694  :     int                     nEncSample1;
; 695  :     int                     nEncSample2;
; 696  :     int                     nPredSample;
; 697  :     int                     nStepIndex;
; 698  : 
; 699  :     //
; 700  :     // Save a local copy of the step index so we're not constantly 
; 701  :     // dereferencing a pointer.
; 702  :     //
; 703  :     
; 704  :     nStepIndex = *pnStepIndexL;

  00006	8b 45 1c	 mov	 eax, DWORD PTR _pnStepIndexL$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d f8	 mov	 DWORD PTR _nStepIndex$[ebp], ecx
$L35901:

; 705  : 
; 706  :     //
; 707  :     // Enter the main loop
; 708  :     //
; 709  :     
; 710  :     while(cBlocks--)

  0000e	8b 55 10	 mov	 edx, DWORD PTR _cBlocks$[ebp]
  00011	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00014	83 e8 01	 sub	 eax, 1
  00017	89 45 10	 mov	 DWORD PTR _cBlocks$[ebp], eax
  0001a	85 d2		 test	 edx, edx
  0001c	0f 84 2a 01 00
	00		 je	 $L35902

; 711  :     {
; 712  :         pbBlock = pbDst;

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  00025	89 4d e4	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 713  :         cSamples = cSamplesPerBlock - 1;

  00028	8b 55 18	 mov	 edx, DWORD PTR _cSamplesPerBlock$[ebp]
  0002b	83 ea 01	 sub	 edx, 1
  0002e	89 55 f4	 mov	 DWORD PTR _cSamples$[ebp], edx

; 714  : 
; 715  :         //
; 716  :         // Block header
; 717  :         //
; 718  : 
; 719  :         nPredSample = *(short *)pbSrc;

  00031	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00034	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00037	89 4d e0	 mov	 DWORD PTR _nPredSample$[ebp], ecx

; 720  :         pbSrc += sizeof(short);

  0003a	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0003d	83 c2 02	 add	 edx, 2
  00040	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 721  : 
; 722  :         *(LONG *)pbBlock = MAKELONG(nPredSample, nStepIndex);

  00043	8b 45 e0	 mov	 eax, DWORD PTR _nPredSample$[ebp]
  00046	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004b	0f b7 c8	 movzx	 ecx, ax
  0004e	8b 55 f8	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  00051	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00057	0f b7 c2	 movzx	 eax, dx
  0005a	c1 e0 10	 shl	 eax, 16			; 00000010H
  0005d	0b c8		 or	 ecx, eax
  0005f	8b 55 e4	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00062	89 0a		 mov	 DWORD PTR [edx], ecx

; 723  :         pbBlock += sizeof(LONG);

  00064	8b 45 e4	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  00067	83 c0 04	 add	 eax, 4
  0006a	89 45 e4	 mov	 DWORD PTR _pbBlock$[ebp], eax
$L35914:

; 724  : 
; 725  :         //
; 726  :         // We have written the header for this block--now write the data
; 727  :         // chunk (which consists of a bunch of encoded nibbles).  Note
; 728  :         // that if we don't have enough data to fill a complete byte, then
; 729  :         // we add a 0 nibble on the end.
; 730  :         //
; 731  : 
; 732  :         while(cSamples)

  0006d	83 7d f4 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  00071	0f 84 c7 00 00
	00		 je	 $L35915

; 733  :         {
; 734  :             //
; 735  :             // Sample 1
; 736  :             //
; 737  : 
; 738  :             nSample = *(short *)pbSrc;

  00077	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  0007a	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0007d	89 55 fc	 mov	 DWORD PTR _nSample$[ebp], edx

; 739  :             pbSrc += sizeof(short);

  00080	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00083	83 c0 02	 add	 eax, 2
  00086	89 45 08	 mov	 DWORD PTR _pbSrc$[ebp], eax

; 740  :             cSamples--;

  00089	8b 4d f4	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  0008c	83 e9 01	 sub	 ecx, 1
  0008f	89 4d f4	 mov	 DWORD PTR _cSamples$[ebp], ecx

; 741  : 
; 742  :             nStepSize = m_asStep[nStepIndex];

  00092	8b 55 f8	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  00095	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  0009d	89 45 e8	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 743  :             nEncSample1 = EncodeSample(nSample, &nPredSample, nStepSize);

  000a0	8b 4d e8	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  000a3	51		 push	 ecx
  000a4	8d 55 e0	 lea	 edx, DWORD PTR _nPredSample$[ebp]
  000a7	52		 push	 edx
  000a8	8b 45 fc	 mov	 eax, DWORD PTR _nSample$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  000b1	89 45 f0	 mov	 DWORD PTR _nEncSample1$[ebp], eax

; 744  :             nStepIndex = NextStepIndex(nEncSample1, nStepIndex);

  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  000b7	51		 push	 ecx
  000b8	8b 55 f0	 mov	 edx, DWORD PTR _nEncSample1$[ebp]
  000bb	52		 push	 edx
  000bc	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  000c1	89 45 f8	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 745  : 
; 746  :             //
; 747  :             // Sample 2
; 748  :             //
; 749  : 
; 750  :             if(cSamples)

  000c4	83 7d f4 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000c8	74 4f		 je	 SHORT $L35918

; 751  :             {
; 752  :                 nSample = *(short *)pbSrc;

  000ca	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  000cd	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000d0	89 4d fc	 mov	 DWORD PTR _nSample$[ebp], ecx

; 753  :                 pbSrc += sizeof(short);

  000d3	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  000d6	83 c2 02	 add	 edx, 2
  000d9	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 754  :                 cSamples--;

  000dc	8b 45 f4	 mov	 eax, DWORD PTR _cSamples$[ebp]
  000df	83 e8 01	 sub	 eax, 1
  000e2	89 45 f4	 mov	 DWORD PTR _cSamples$[ebp], eax

; 755  : 
; 756  :                 nStepSize = m_asStep[nStepIndex];

  000e5	8b 4d f8	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  000e8	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[ecx*2]
  000f0	89 55 e8	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 757  :                 nEncSample2 = EncodeSample(nSample, &nPredSample, nStepSize);

  000f3	8b 45 e8	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  000f6	50		 push	 eax
  000f7	8d 4d e0	 lea	 ecx, DWORD PTR _nPredSample$[ebp]
  000fa	51		 push	 ecx
  000fb	8b 55 fc	 mov	 edx, DWORD PTR _nSample$[ebp]
  000fe	52		 push	 edx
  000ff	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  00104	89 45 ec	 mov	 DWORD PTR _nEncSample2$[ebp], eax

; 758  :                 nStepIndex = NextStepIndex(nEncSample2, nStepIndex);

  00107	8b 45 f8	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  0010a	50		 push	 eax
  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _nEncSample2$[ebp]
  0010e	51		 push	 ecx
  0010f	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  00114	89 45 f8	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 759  :             }
; 760  :             else

  00117	eb 07		 jmp	 SHORT $L35921
$L35918:

; 761  :             {
; 762  :                 nEncSample2 = 0;

  00119	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _nEncSample2$[ebp], 0
$L35921:

; 763  :             }
; 764  : 
; 765  :             //
; 766  :             // Write out encoded byte.
; 767  :             //
; 768  : 
; 769  :             *pbBlock++ = (BYTE)(nEncSample1 | (nEncSample2 << 4));

  00120	8b 55 ec	 mov	 edx, DWORD PTR _nEncSample2$[ebp]
  00123	c1 e2 04	 shl	 edx, 4
  00126	8b 45 f0	 mov	 eax, DWORD PTR _nEncSample1$[ebp]
  00129	0b c2		 or	 eax, edx
  0012b	8b 4d e4	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  0012e	88 01		 mov	 BYTE PTR [ecx], al
  00130	8b 55 e4	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00133	83 c2 01	 add	 edx, 1
  00136	89 55 e4	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 770  :         }

  00139	e9 2f ff ff ff	 jmp	 $L35914
$L35915:

; 771  : 
; 772  :         //
; 773  :         // Skip padding
; 774  :         //
; 775  : 
; 776  :         pbDst += nBlockAlignment;

  0013e	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  00141	03 45 14	 add	 eax, DWORD PTR _nBlockAlignment$[ebp]
  00144	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 777  :     }

  00147	e9 c2 fe ff ff	 jmp	 $L35901
$L35902:

; 778  : 
; 779  :     //
; 780  :     // Restore the value of the step index to be used on the next buffer.
; 781  :     //
; 782  : 
; 783  :     *pnStepIndexL = nStepIndex;

  0014c	8b 4d 1c	 mov	 ecx, DWORD PTR _pnStepIndexL$[ebp]
  0014f	8b 55 f8	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  00152	89 11		 mov	 DWORD PTR [ecx], edx

; 784  : 
; 785  :     return TRUE;

  00154	b8 01 00 00 00	 mov	 eax, 1

; 786  : }

  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c2 1c 00	 ret	 28			; 0000001cH
?EncodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::EncodeM16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.h
DSOUND	ENDS
;	COMDAT ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z
DSOUND	SEGMENT
_nEncodedSample$ = 8
_nStepIndex$ = 12
?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::NextStepIndex, COMDAT

; 115  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 116  :         nStepIndex += m_asNextStep[nEncodedSample];

  00003	8b 45 08	 mov	 eax, DWORD PTR _nEncodedSample$[ebp]
  00006	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?m_asNextStep@CImaAdpcmCodec@DirectSound@@0QBFB[eax*2]
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  00011	03 d1		 add	 edx, ecx
  00013	89 55 0c	 mov	 DWORD PTR _nStepIndex$[ebp], edx

; 117  : 
; 118  :         if(nStepIndex < 0)

  00016	83 7d 0c 00	 cmp	 DWORD PTR _nStepIndex$[ebp], 0
  0001a	7d 09		 jge	 SHORT $L30753

; 119  :         {
; 120  :             nStepIndex = 0;

  0001c	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _nStepIndex$[ebp], 0

; 121  :         }
; 122  :         else if(nStepIndex >= NUMELMS(m_asStep))

  00023	eb 0d		 jmp	 SHORT $L30754
$L30753:
  00025	83 7d 0c 59	 cmp	 DWORD PTR _nStepIndex$[ebp], 89 ; 00000059H
  00029	72 07		 jb	 SHORT $L30754

; 123  :         {
; 124  :             nStepIndex = NUMELMS(m_asStep) - 1;

  0002b	c7 45 0c 58 00
	00 00		 mov	 DWORD PTR _nStepIndex$[ebp], 88 ; 00000058H
$L30754:

; 125  :         }
; 126  : 
; 127  :         return nStepIndex;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _nStepIndex$[ebp]

; 128  :     }

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ENDP	; DirectSound::CImaAdpcmCodec::NextStepIndex
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
DSOUND	ENDS
;	COMDAT ?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT
tv91 = -60
_nPredSampleL$ = -56
_pbBlock$ = -52
_nStepSize$ = -48
_dwLeft$ = -44
_nPredSampleR$ = -40
_cSamples$ = -36
_nSample$ = -32
_nEncSampleL$ = -28
_cSubSamples$ = -24
_i$ = -20
_dwRight$ = -16
_nStepIndexR$ = -12
_nStepIndexL$ = -8
_nEncSampleR$ = -4
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_pnStepIndexL$ = 28
_pnStepIndexR$ = 32
?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::EncodeS16, COMDAT

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 801  :     LPBYTE                  pbBlock;
; 802  :     UINT                    cSamples;
; 803  :     UINT                    cSubSamples;
; 804  :     int                     nSample;
; 805  :     int                     nStepSize;
; 806  :     DWORD                   dwLeft;
; 807  :     DWORD                   dwRight;
; 808  :     int                     nEncSampleL;
; 809  :     int                     nPredSampleL;
; 810  :     int                     nStepIndexL;
; 811  :     int                     nEncSampleR;
; 812  :     int                     nPredSampleR;
; 813  :     int                     nStepIndexR;
; 814  :     UINT                    i;
; 815  : 
; 816  :     //
; 817  :     // Save a local copy of the step indeces so we're not constantly 
; 818  :     // dereferencing a pointer.
; 819  :     //
; 820  :     
; 821  :     nStepIndexL = *pnStepIndexL;

  00006	8b 45 1c	 mov	 eax, DWORD PTR _pnStepIndexL$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d f8	 mov	 DWORD PTR _nStepIndexL$[ebp], ecx

; 822  :     nStepIndexR = *pnStepIndexR;

  0000e	8b 55 20	 mov	 edx, DWORD PTR _pnStepIndexR$[ebp]
  00011	8b 02		 mov	 eax, DWORD PTR [edx]
  00013	89 45 f4	 mov	 DWORD PTR _nStepIndexR$[ebp], eax
$L35947:

; 823  : 
; 824  :     //
; 825  :     // Enter the main loop
; 826  :     //
; 827  :     
; 828  :     while(cBlocks--)

  00016	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00019	8b 55 10	 mov	 edx, DWORD PTR _cBlocks$[ebp]
  0001c	83 ea 01	 sub	 edx, 1
  0001f	89 55 10	 mov	 DWORD PTR _cBlocks$[ebp], edx
  00022	85 c9		 test	 ecx, ecx
  00024	0f 84 ca 01 00
	00		 je	 $L35948

; 829  :     {
; 830  :         pbBlock = pbDst;

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  0002d	89 45 cc	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 831  :         cSamples = cSamplesPerBlock - 1;

  00030	8b 4d 18	 mov	 ecx, DWORD PTR _cSamplesPerBlock$[ebp]
  00033	83 e9 01	 sub	 ecx, 1
  00036	89 4d dc	 mov	 DWORD PTR _cSamples$[ebp], ecx

; 832  : 
; 833  :         //
; 834  :         // LEFT channel block header
; 835  :         //
; 836  : 
; 837  :         nPredSampleL = *(short *)pbSrc;

  00039	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0003c	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0003f	89 45 c8	 mov	 DWORD PTR _nPredSampleL$[ebp], eax

; 838  :         pbSrc += sizeof(short);

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  00045	83 c1 02	 add	 ecx, 2
  00048	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 839  : 
; 840  :         *(LONG *)pbBlock = MAKELONG(nPredSampleL, nStepIndexL);

  0004b	8b 55 c8	 mov	 edx, DWORD PTR _nPredSampleL$[ebp]
  0004e	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00054	0f b7 c2	 movzx	 eax, dx
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _nStepIndexL$[ebp]
  0005a	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00060	0f b7 d1	 movzx	 edx, cx
  00063	c1 e2 10	 shl	 edx, 16			; 00000010H
  00066	0b c2		 or	 eax, edx
  00068	8b 4d cc	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  0006b	89 01		 mov	 DWORD PTR [ecx], eax

; 841  :         pbBlock += sizeof(LONG);

  0006d	8b 55 cc	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00070	83 c2 04	 add	 edx, 4
  00073	89 55 cc	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 842  : 
; 843  :         //
; 844  :         // RIGHT channel block header
; 845  :         //
; 846  : 
; 847  :         nPredSampleR = *(short *)pbSrc;

  00076	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00079	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0007c	89 4d d8	 mov	 DWORD PTR _nPredSampleR$[ebp], ecx

; 848  :         pbSrc += sizeof(short);

  0007f	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00082	83 c2 02	 add	 edx, 2
  00085	89 55 08	 mov	 DWORD PTR _pbSrc$[ebp], edx

; 849  : 
; 850  :         *(LONG *)pbBlock = MAKELONG(nPredSampleR, nStepIndexR);

  00088	8b 45 d8	 mov	 eax, DWORD PTR _nPredSampleR$[ebp]
  0008b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00090	0f b7 c8	 movzx	 ecx, ax
  00093	8b 55 f4	 mov	 edx, DWORD PTR _nStepIndexR$[ebp]
  00096	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0009c	0f b7 c2	 movzx	 eax, dx
  0009f	c1 e0 10	 shl	 eax, 16			; 00000010H
  000a2	0b c8		 or	 ecx, eax
  000a4	8b 55 cc	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  000a7	89 0a		 mov	 DWORD PTR [edx], ecx

; 851  :         pbBlock += sizeof(LONG);

  000a9	8b 45 cc	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  000ac	83 c0 04	 add	 eax, 4
  000af	89 45 cc	 mov	 DWORD PTR _pbBlock$[ebp], eax
$L35970:

; 852  : 
; 853  :         //
; 854  :         // We have written the header for this block--now write the data
; 855  :         // chunk.  This consists of 8 left samples (one DWORD of output)
; 856  :         // followed by 8 right samples (also one DWORD).  Since the input
; 857  :         // samples are interleaved, we create the left and right DWORDs
; 858  :         // sample by sample, and then write them both out.
; 859  :         //
; 860  : 
; 861  :         while(cSamples)

  000b2	83 7d dc 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000b6	0f 84 2a 01 00
	00		 je	 $L35971

; 862  :         {
; 863  :             dwLeft = 0;

  000bc	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _dwLeft$[ebp], 0

; 864  :             dwRight = 0;

  000c3	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwRight$[ebp], 0

; 865  : 
; 866  :             cSubSamples = min(cSamples, 8);

  000ca	83 7d dc 08	 cmp	 DWORD PTR _cSamples$[ebp], 8
  000ce	73 08		 jae	 SHORT $L41213
  000d0	8b 4d dc	 mov	 ecx, DWORD PTR _cSamples$[ebp]
  000d3	89 4d c4	 mov	 DWORD PTR tv91[ebp], ecx
  000d6	eb 07		 jmp	 SHORT $L41214
$L41213:
  000d8	c7 45 c4 08 00
	00 00		 mov	 DWORD PTR tv91[ebp], 8
$L41214:
  000df	8b 55 c4	 mov	 edx, DWORD PTR tv91[ebp]
  000e2	89 55 e8	 mov	 DWORD PTR _cSubSamples$[ebp], edx

; 867  : 
; 868  :             for(i = 0; i < cSubSamples; i++)

  000e5	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ec	eb 09		 jmp	 SHORT $L35972
$L35973:
  000ee	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000f1	83 c0 01	 add	 eax, 1
  000f4	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$L35972:
  000f7	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  000fa	3b 4d e8	 cmp	 ecx, DWORD PTR _cSubSamples$[ebp]
  000fd	0f 83 b3 00 00
	00		 jae	 $L35974

; 869  :             {
; 870  :                 //
; 871  :                 // LEFT channel
; 872  :                 //
; 873  : 
; 874  :                 nSample = *(short *)pbSrc;

  00103	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00106	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00109	89 45 e0	 mov	 DWORD PTR _nSample$[ebp], eax

; 875  :                 pbSrc += sizeof(short);

  0010c	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  0010f	83 c1 02	 add	 ecx, 2
  00112	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 876  : 
; 877  :                 nStepSize = m_asStep[nStepIndexL];

  00115	8b 55 f8	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  00118	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  00120	89 45 d0	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 878  :                 
; 879  :                 nEncSampleL = EncodeSample(nSample, &nPredSampleL, nStepSize);

  00123	8b 4d d0	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00126	51		 push	 ecx
  00127	8d 55 c8	 lea	 edx, DWORD PTR _nPredSampleL$[ebp]
  0012a	52		 push	 edx
  0012b	8b 45 e0	 mov	 eax, DWORD PTR _nSample$[ebp]
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  00134	89 45 e4	 mov	 DWORD PTR _nEncSampleL$[ebp], eax

; 880  : 
; 881  :                 nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);

  00137	8b 4d f8	 mov	 ecx, DWORD PTR _nStepIndexL$[ebp]
  0013a	51		 push	 ecx
  0013b	8b 55 e4	 mov	 edx, DWORD PTR _nEncSampleL$[ebp]
  0013e	52		 push	 edx
  0013f	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  00144	89 45 f8	 mov	 DWORD PTR _nStepIndexL$[ebp], eax

; 882  :                 dwLeft |= (DWORD)nEncSampleL << (4 * i);

  00147	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  0014a	c1 e1 02	 shl	 ecx, 2
  0014d	8b 45 e4	 mov	 eax, DWORD PTR _nEncSampleL$[ebp]
  00150	d3 e0		 shl	 eax, cl
  00152	8b 4d d4	 mov	 ecx, DWORD PTR _dwLeft$[ebp]
  00155	0b c8		 or	 ecx, eax
  00157	89 4d d4	 mov	 DWORD PTR _dwLeft$[ebp], ecx

; 883  : 
; 884  :                 //
; 885  :                 // RIGHT channel
; 886  :                 //
; 887  : 
; 888  :                 nSample = *(short *)pbSrc;

  0015a	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  0015d	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00160	89 45 e0	 mov	 DWORD PTR _nSample$[ebp], eax

; 889  :                 pbSrc += sizeof(short);

  00163	8b 4d 08	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  00166	83 c1 02	 add	 ecx, 2
  00169	89 4d 08	 mov	 DWORD PTR _pbSrc$[ebp], ecx

; 890  : 
; 891  :                 nStepSize = m_asStep[nStepIndexR];

  0016c	8b 55 f4	 mov	 edx, DWORD PTR _nStepIndexR$[ebp]
  0016f	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  00177	89 45 d0	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 892  :                 
; 893  :                 nEncSampleR = EncodeSample(nSample, &nPredSampleR, nStepSize);

  0017a	8b 4d d0	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  0017d	51		 push	 ecx
  0017e	8d 55 d8	 lea	 edx, DWORD PTR _nPredSampleR$[ebp]
  00181	52		 push	 edx
  00182	8b 45 e0	 mov	 eax, DWORD PTR _nSample$[ebp]
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 ?EncodeSample@CImaAdpcmCodec@DirectSound@@CGHHPAHH@Z ; DirectSound::CImaAdpcmCodec::EncodeSample
  0018b	89 45 fc	 mov	 DWORD PTR _nEncSampleR$[ebp], eax

; 894  : 
; 895  :                 nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);

  0018e	8b 4d f4	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  00191	51		 push	 ecx
  00192	8b 55 fc	 mov	 edx, DWORD PTR _nEncSampleR$[ebp]
  00195	52		 push	 edx
  00196	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  0019b	89 45 f4	 mov	 DWORD PTR _nStepIndexR$[ebp], eax

; 896  :                 dwRight |= (DWORD)nEncSampleR << (4 * i);

  0019e	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  001a1	c1 e1 02	 shl	 ecx, 2
  001a4	8b 45 fc	 mov	 eax, DWORD PTR _nEncSampleR$[ebp]
  001a7	d3 e0		 shl	 eax, cl
  001a9	8b 4d f0	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  001ac	0b c8		 or	 ecx, eax
  001ae	89 4d f0	 mov	 DWORD PTR _dwRight$[ebp], ecx

; 897  :             }

  001b1	e9 38 ff ff ff	 jmp	 $L35973
$L35974:

; 898  : 
; 899  :             //
; 900  :             // Write out encoded DWORDs.
; 901  :             //
; 902  : 
; 903  :             *(LPDWORD)pbBlock = dwLeft;

  001b6	8b 55 cc	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  001b9	8b 45 d4	 mov	 eax, DWORD PTR _dwLeft$[ebp]
  001bc	89 02		 mov	 DWORD PTR [edx], eax

; 904  :             pbBlock += sizeof(DWORD);

  001be	8b 4d cc	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  001c1	83 c1 04	 add	 ecx, 4
  001c4	89 4d cc	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 905  : 
; 906  :             *(LPDWORD)pbBlock = dwRight;

  001c7	8b 55 cc	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  001ca	8b 45 f0	 mov	 eax, DWORD PTR _dwRight$[ebp]
  001cd	89 02		 mov	 DWORD PTR [edx], eax

; 907  :             pbBlock += sizeof(DWORD);

  001cf	8b 4d cc	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  001d2	83 c1 04	 add	 ecx, 4
  001d5	89 4d cc	 mov	 DWORD PTR _pbBlock$[ebp], ecx

; 908  : 
; 909  :             cSamples -= cSubSamples;

  001d8	8b 55 dc	 mov	 edx, DWORD PTR _cSamples$[ebp]
  001db	2b 55 e8	 sub	 edx, DWORD PTR _cSubSamples$[ebp]
  001de	89 55 dc	 mov	 DWORD PTR _cSamples$[ebp], edx

; 910  :         }

  001e1	e9 cc fe ff ff	 jmp	 $L35970
$L35971:

; 911  : 
; 912  :         //
; 913  :         // Skip padding
; 914  :         //
; 915  : 
; 916  :         pbDst += nBlockAlignment;

  001e6	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  001e9	03 45 14	 add	 eax, DWORD PTR _nBlockAlignment$[ebp]
  001ec	89 45 0c	 mov	 DWORD PTR _pbDst$[ebp], eax

; 917  :     }

  001ef	e9 22 fe ff ff	 jmp	 $L35947
$L35948:

; 918  : 
; 919  :     //
; 920  :     // Restore the value of the step index to be used on the next buffer.
; 921  :     //
; 922  :     
; 923  :     *pnStepIndexL = nStepIndexL;

  001f4	8b 4d 1c	 mov	 ecx, DWORD PTR _pnStepIndexL$[ebp]
  001f7	8b 55 f8	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  001fa	89 11		 mov	 DWORD PTR [ecx], edx

; 924  :     *pnStepIndexR = nStepIndexR;

  001fc	8b 45 20	 mov	 eax, DWORD PTR _pnStepIndexR$[ebp]
  001ff	8b 4d f4	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  00202	89 08		 mov	 DWORD PTR [eax], ecx

; 925  : 
; 926  :     return TRUE;

  00204	b8 01 00 00 00	 mov	 eax, 1

; 927  : 
; 928  : }

  00209	8b e5		 mov	 esp, ebp
  0020b	5d		 pop	 ebp
  0020c	c2 1c 00	 ret	 28			; 0000001cH
?EncodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::EncodeS16
DSOUND	ENDS
PUBLIC	?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
; Function compile flags: /Odt
;	COMDAT ?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT
_nPredSample$ = -36
_pbBlock$ = -32
_dwHeader$ = -28
_bSample$ = -21
_nStepSize$ = -20
_cSamples$ = -16
_nStepIndex$ = -12
_fSuccess$ = -8
_nEncSample$ = -4
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_pnStepIndexL$ = 28
_pnStepIndexR$ = 32
?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::DecodeM16, COMDAT

; 942  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 943  :     BOOL                    fSuccess    = TRUE;

  00006	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 1
$L36004:

; 944  :     LPBYTE                  pbBlock;
; 945  :     UINT                    cSamples;
; 946  :     BYTE                    bSample;
; 947  :     int                     nStepSize;
; 948  :     int                     nEncSample;
; 949  :     int                     nPredSample;
; 950  :     int                     nStepIndex;
; 951  :     DWORD                   dwHeader;
; 952  : 
; 953  :     //
; 954  :     // Enter the main loop
; 955  :     //
; 956  :     
; 957  :     while(cBlocks--)

  0000d	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00013	83 e9 01	 sub	 ecx, 1
  00016	89 4d 10	 mov	 DWORD PTR _cBlocks$[ebp], ecx
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 4b 01 00
	00		 je	 $L36005

; 958  :     {
; 959  :         pbBlock = pbSrc;

  00021	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00024	89 55 e0	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 960  :         cSamples = cSamplesPerBlock - 1;

  00027	8b 45 18	 mov	 eax, DWORD PTR _cSamplesPerBlock$[ebp]
  0002a	83 e8 01	 sub	 eax, 1
  0002d	89 45 f0	 mov	 DWORD PTR _cSamples$[ebp], eax

; 961  :         
; 962  :         //
; 963  :         // Block header
; 964  :         //
; 965  : 
; 966  :         dwHeader = *(LPDWORD)pbBlock;

  00030	8b 4d e0	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	89 55 e4	 mov	 DWORD PTR _dwHeader$[ebp], edx

; 967  :         pbBlock += sizeof(DWORD);

  00038	8b 45 e0	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 e0	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 968  : 
; 969  :         nPredSample = (int)(short)LOWORD(dwHeader);

  00041	8b 4d e4	 mov	 ecx, DWORD PTR _dwHeader$[ebp]
  00044	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0004a	0f bf d1	 movsx	 edx, cx
  0004d	89 55 dc	 mov	 DWORD PTR _nPredSample$[ebp], edx

; 970  :         nStepIndex = (int)(BYTE)HIWORD(dwHeader);

  00050	8b 45 e4	 mov	 eax, DWORD PTR _dwHeader$[ebp]
  00053	c1 e8 10	 shr	 eax, 16			; 00000010H
  00056	0f b6 c8	 movzx	 ecx, al
  00059	89 4d f4	 mov	 DWORD PTR _nStepIndex$[ebp], ecx

; 971  : 
; 972  :         if(!ValidStepIndex(nStepIndex))

  0005c	8b 55 f4	 mov	 edx, DWORD PTR _nStepIndex$[ebp]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
  00065	85 c0		 test	 eax, eax
  00067	75 0c		 jne	 SHORT $L36016

; 973  :         {
; 974  :             //
; 975  :             // The step index is out of range - this is considered a fatal
; 976  :             // error as the input stream is corrupted.  We fail by returning
; 977  :             // zero bytes converted.
; 978  :             //
; 979  : 
; 980  :             fSuccess = FALSE;

  00069	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 981  :             break;

  00070	e9 f7 00 00 00	 jmp	 $L36005
$L36016:

; 982  :         }
; 983  :         
; 984  :         //
; 985  :         // Write out first sample
; 986  :         //
; 987  : 
; 988  :         *(short *)pbDst = (short)nPredSample;

  00075	8b 45 0c	 mov	 eax, DWORD PTR _pbDst$[ebp]
  00078	66 8b 4d dc	 mov	 cx, WORD PTR _nPredSample$[ebp]
  0007c	66 89 08	 mov	 WORD PTR [eax], cx

; 989  :         pbDst += sizeof(short);

  0007f	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  00082	83 c2 02	 add	 edx, 2
  00085	89 55 0c	 mov	 DWORD PTR _pbDst$[ebp], edx
$L36021:

; 990  : 
; 991  :         //
; 992  :         // Enter the block loop
; 993  :         //
; 994  : 
; 995  :         while(cSamples)

  00088	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  0008c	0f 84 cc 00 00
	00		 je	 $L36022

; 996  :         {
; 997  :             bSample = *pbBlock++;

  00092	8b 45 e0	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  00095	8a 08		 mov	 cl, BYTE PTR [eax]
  00097	88 4d eb	 mov	 BYTE PTR _bSample$[ebp], cl
  0009a	8b 55 e0	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  0009d	83 c2 01	 add	 edx, 1
  000a0	89 55 e0	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 998  : 
; 999  :             //
; 1000 :             // Sample 1
; 1001 :             //
; 1002 : 
; 1003 :             nEncSample = (bSample & (BYTE)0x0F);

  000a3	0f b6 45 eb	 movzx	 eax, BYTE PTR _bSample$[ebp]
  000a7	83 e0 0f	 and	 eax, 15			; 0000000fH
  000aa	89 45 fc	 mov	 DWORD PTR _nEncSample$[ebp], eax

; 1004 :             nStepSize = m_asStep[nStepIndex];

  000ad	8b 4d f4	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  000b0	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[ecx*2]
  000b8	89 55 ec	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 1005 :             nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);

  000bb	8b 45 ec	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  000be	50		 push	 eax
  000bf	8b 4d dc	 mov	 ecx, DWORD PTR _nPredSample$[ebp]
  000c2	51		 push	 ecx
  000c3	8b 55 fc	 mov	 edx, DWORD PTR _nEncSample$[ebp]
  000c6	52		 push	 edx
  000c7	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  000cc	89 45 dc	 mov	 DWORD PTR _nPredSample$[ebp], eax

; 1006 :             nStepIndex = NextStepIndex(nEncSample, nStepIndex);

  000cf	8b 45 f4	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  000d2	50		 push	 eax
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _nEncSample$[ebp]
  000d6	51		 push	 ecx
  000d7	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  000dc	89 45 f4	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 1007 : 
; 1008 :             *(short *)pbDst = (short)nPredSample;

  000df	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  000e2	66 8b 45 dc	 mov	 ax, WORD PTR _nPredSample$[ebp]
  000e6	66 89 02	 mov	 WORD PTR [edx], ax

; 1009 :             pbDst += sizeof(short);

  000e9	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  000ec	83 c1 02	 add	 ecx, 2
  000ef	89 4d 0c	 mov	 DWORD PTR _pbDst$[ebp], ecx

; 1010 : 
; 1011 :             cSamples--;

  000f2	8b 55 f0	 mov	 edx, DWORD PTR _cSamples$[ebp]
  000f5	83 ea 01	 sub	 edx, 1
  000f8	89 55 f0	 mov	 DWORD PTR _cSamples$[ebp], edx

; 1012 : 
; 1013 :             //
; 1014 :             // Sample 2
; 1015 :             //
; 1016 : 
; 1017 :             if(cSamples)

  000fb	83 7d f0 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000ff	74 58		 je	 SHORT $L36027

; 1018 :             {
; 1019 :                 nEncSample = (bSample >> 4);

  00101	0f b6 45 eb	 movzx	 eax, BYTE PTR _bSample$[ebp]
  00105	c1 f8 04	 sar	 eax, 4
  00108	89 45 fc	 mov	 DWORD PTR _nEncSample$[ebp], eax

; 1020 :                 nStepSize = m_asStep[nStepIndex];

  0010b	8b 4d f4	 mov	 ecx, DWORD PTR _nStepIndex$[ebp]
  0010e	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[ecx*2]
  00116	89 55 ec	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 1021 :                 nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);

  00119	8b 45 ec	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  0011c	50		 push	 eax
  0011d	8b 4d dc	 mov	 ecx, DWORD PTR _nPredSample$[ebp]
  00120	51		 push	 ecx
  00121	8b 55 fc	 mov	 edx, DWORD PTR _nEncSample$[ebp]
  00124	52		 push	 edx
  00125	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  0012a	89 45 dc	 mov	 DWORD PTR _nPredSample$[ebp], eax

; 1022 :                 nStepIndex = NextStepIndex(nEncSample, nStepIndex);

  0012d	8b 45 f4	 mov	 eax, DWORD PTR _nStepIndex$[ebp]
  00130	50		 push	 eax
  00131	8b 4d fc	 mov	 ecx, DWORD PTR _nEncSample$[ebp]
  00134	51		 push	 ecx
  00135	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  0013a	89 45 f4	 mov	 DWORD PTR _nStepIndex$[ebp], eax

; 1023 : 
; 1024 :                 *(short *)pbDst = (short)nPredSample;

  0013d	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  00140	66 8b 45 dc	 mov	 ax, WORD PTR _nPredSample$[ebp]
  00144	66 89 02	 mov	 WORD PTR [edx], ax

; 1025 :                 pbDst += sizeof(short);

  00147	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  0014a	83 c1 02	 add	 ecx, 2
  0014d	89 4d 0c	 mov	 DWORD PTR _pbDst$[ebp], ecx

; 1026 : 
; 1027 :                 cSamples--;

  00150	8b 55 f0	 mov	 edx, DWORD PTR _cSamples$[ebp]
  00153	83 ea 01	 sub	 edx, 1
  00156	89 55 f0	 mov	 DWORD PTR _cSamples$[ebp], edx
$L36027:

; 1028 :             }
; 1029 :         }

  00159	e9 2a ff ff ff	 jmp	 $L36021
$L36022:

; 1030 : 
; 1031 :         //
; 1032 :         // Skip padding
; 1033 :         //
; 1034 : 
; 1035 :         pbSrc += nBlockAlignment;

  0015e	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00161	03 45 14	 add	 eax, DWORD PTR _nBlockAlignment$[ebp]
  00164	89 45 08	 mov	 DWORD PTR _pbSrc$[ebp], eax

; 1036 :     }

  00167	e9 a1 fe ff ff	 jmp	 $L36004
$L36005:

; 1037 : 
; 1038 :     return fSuccess;

  0016c	8b 45 f8	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 1039 : }

  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c2 1c 00	 ret	 28			; 0000001cH
?DecodeM16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::DecodeM16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.h
DSOUND	ENDS
;	COMDAT ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z
DSOUND	SEGMENT
tv66 = -4
_nStepIndex$ = 8
?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::ValidStepIndex, COMDAT

; 131  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 132  :         return (nStepIndex >= 0) && (nStepIndex < NUMELMS(m_asStep));

  00004	83 7d 08 00	 cmp	 DWORD PTR _nStepIndex$[ebp], 0
  00008	7c 0f		 jl	 SHORT $L41221
  0000a	83 7d 08 59	 cmp	 DWORD PTR _nStepIndex$[ebp], 89 ; 00000059H
  0000e	73 09		 jae	 SHORT $L41221
  00010	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00017	eb 07		 jmp	 SHORT $L41222
$L41221:
  00019	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41222:
  00020	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]

; 133  :     }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ENDP	; DirectSound::CImaAdpcmCodec::ValidStepIndex
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\imaadpcm.cpp
DSOUND	ENDS
;	COMDAT ?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z
DSOUND	SEGMENT
tv134 = -64
_nPredSampleL$ = -60
_pbBlock$ = -56
_dwHeader$ = -52
_nStepSize$ = -48
_dwLeft$ = -44
_nPredSampleR$ = -40
_cSamples$ = -36
_nEncSampleL$ = -32
_cSubSamples$ = -28
_i$ = -24
_dwRight$ = -20
_nStepIndexR$ = -16
_fSuccess$ = -12
_nStepIndexL$ = -8
_nEncSampleR$ = -4
_pbSrc$ = 8
_pbDst$ = 12
_cBlocks$ = 16
_nBlockAlignment$ = 20
_cSamplesPerBlock$ = 24
_pnStepIndexL$ = 28
_pnStepIndexR$ = 32
?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z PROC NEAR ; DirectSound::CImaAdpcmCodec::DecodeS16, COMDAT

; 1053 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 1054 :     BOOL                    fSuccess    = TRUE;

  00006	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 1
$L36056:

; 1055 :     LPBYTE                  pbBlock;
; 1056 :     UINT                    cSamples;
; 1057 :     UINT                    cSubSamples;
; 1058 :     int                     nStepSize;
; 1059 :     DWORD                   dwHeader;
; 1060 :     DWORD                   dwLeft;
; 1061 :     DWORD                   dwRight;
; 1062 :     int                     nEncSampleL;
; 1063 :     int                     nPredSampleL;
; 1064 :     int                     nStepIndexL;
; 1065 :     int                     nEncSampleR;
; 1066 :     int                     nPredSampleR;
; 1067 :     int                     nStepIndexR;
; 1068 :     UINT                    i;
; 1069 : 
; 1070 :     //
; 1071 :     // Enter the main loop
; 1072 :     //
; 1073 :     
; 1074 :     while(cBlocks--)

  0000d	8b 45 10	 mov	 eax, DWORD PTR _cBlocks$[ebp]
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _cBlocks$[ebp]
  00013	83 e9 01	 sub	 ecx, 1
  00016	89 4d 10	 mov	 DWORD PTR _cBlocks$[ebp], ecx
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 fc 01 00
	00		 je	 $L36057

; 1075 :     {
; 1076 :         pbBlock = pbSrc;

  00021	8b 55 08	 mov	 edx, DWORD PTR _pbSrc$[ebp]
  00024	89 55 c8	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 1077 :         cSamples = cSamplesPerBlock - 1;

  00027	8b 45 18	 mov	 eax, DWORD PTR _cSamplesPerBlock$[ebp]
  0002a	83 e8 01	 sub	 eax, 1
  0002d	89 45 dc	 mov	 DWORD PTR _cSamples$[ebp], eax

; 1078 : 
; 1079 :         //
; 1080 :         // LEFT channel header
; 1081 :         //
; 1082 : 
; 1083 :         dwHeader = *(LPDWORD)pbBlock;

  00030	8b 4d c8	 mov	 ecx, DWORD PTR _pbBlock$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	89 55 cc	 mov	 DWORD PTR _dwHeader$[ebp], edx

; 1084 :         pbBlock += sizeof(DWORD);

  00038	8b 45 c8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 c8	 mov	 DWORD PTR _pbBlock$[ebp], eax

; 1085 :         
; 1086 :         nPredSampleL = (int)(short)LOWORD(dwHeader);

  00041	8b 4d cc	 mov	 ecx, DWORD PTR _dwHeader$[ebp]
  00044	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0004a	0f bf d1	 movsx	 edx, cx
  0004d	89 55 c4	 mov	 DWORD PTR _nPredSampleL$[ebp], edx

; 1087 :         nStepIndexL = (int)(BYTE)HIWORD(dwHeader);

  00050	8b 45 cc	 mov	 eax, DWORD PTR _dwHeader$[ebp]
  00053	c1 e8 10	 shr	 eax, 16			; 00000010H
  00056	0f b6 c8	 movzx	 ecx, al
  00059	89 4d f8	 mov	 DWORD PTR _nStepIndexL$[ebp], ecx

; 1088 : 
; 1089 :         if(!ValidStepIndex(nStepIndexL)) 

  0005c	8b 55 f8	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
  00065	85 c0		 test	 eax, eax
  00067	75 0c		 jne	 SHORT $L36068

; 1090 :         {
; 1091 :             //
; 1092 :             // The step index is out of range - this is considered a fatal
; 1093 :             // error as the input stream is corrupted.  We fail by returning
; 1094 :             // zero bytes converted.
; 1095 :             //
; 1096 : 
; 1097 :             fSuccess = FALSE;

  00069	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 1098 :             break;

  00070	e9 a8 01 00 00	 jmp	 $L36057
$L36068:

; 1099 :         }
; 1100 :         
; 1101 :         //
; 1102 :         // RIGHT channel header
; 1103 :         //
; 1104 : 
; 1105 :         dwHeader = *(LPDWORD)pbBlock;

  00075	8b 45 c8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  00078	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007a	89 4d cc	 mov	 DWORD PTR _dwHeader$[ebp], ecx

; 1106 :         pbBlock += sizeof(DWORD);

  0007d	8b 55 c8	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  00080	83 c2 04	 add	 edx, 4
  00083	89 55 c8	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 1107 :         
; 1108 :         nPredSampleR = (int)(short)LOWORD(dwHeader);

  00086	8b 45 cc	 mov	 eax, DWORD PTR _dwHeader$[ebp]
  00089	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0008e	0f bf c8	 movsx	 ecx, ax
  00091	89 4d d8	 mov	 DWORD PTR _nPredSampleR$[ebp], ecx

; 1109 :         nStepIndexR = (int)(BYTE)HIWORD(dwHeader);

  00094	8b 55 cc	 mov	 edx, DWORD PTR _dwHeader$[ebp]
  00097	c1 ea 10	 shr	 edx, 16			; 00000010H
  0009a	0f b6 c2	 movzx	 eax, dl
  0009d	89 45 f0	 mov	 DWORD PTR _nStepIndexR$[ebp], eax

; 1110 : 
; 1111 :         if(!ValidStepIndex(nStepIndexR))

  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 ?ValidStepIndex@CImaAdpcmCodec@DirectSound@@CGHH@Z ; DirectSound::CImaAdpcmCodec::ValidStepIndex
  000a9	85 c0		 test	 eax, eax
  000ab	75 0c		 jne	 SHORT $L36079

; 1112 :         {
; 1113 :             //
; 1114 :             // The step index is out of range - this is considered a fatal
; 1115 :             // error as the input stream is corrupted.  We fail by returning
; 1116 :             // zero bytes converted.
; 1117 :             //
; 1118 : 
; 1119 :             fSuccess = FALSE;

  000ad	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0

; 1120 :             break;

  000b4	e9 64 01 00 00	 jmp	 $L36057
$L36079:

; 1121 :         }
; 1122 : 
; 1123 :         //
; 1124 :         // Write out first sample
; 1125 :         //
; 1126 : 
; 1127 :         *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);

  000b9	8b 55 c4	 mov	 edx, DWORD PTR _nPredSampleL$[ebp]
  000bc	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000c2	0f b7 c2	 movzx	 eax, dx
  000c5	8b 4d d8	 mov	 ecx, DWORD PTR _nPredSampleR$[ebp]
  000c8	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000ce	0f b7 d1	 movzx	 edx, cx
  000d1	c1 e2 10	 shl	 edx, 16			; 00000010H
  000d4	0b c2		 or	 eax, edx
  000d6	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  000d9	89 01		 mov	 DWORD PTR [ecx], eax

; 1128 :         pbDst += sizeof(DWORD);

  000db	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  000de	83 c2 04	 add	 edx, 4
  000e1	89 55 0c	 mov	 DWORD PTR _pbDst$[ebp], edx
$L36089:

; 1129 : 
; 1130 :         //
; 1131 :         // The first DWORD contains 4 left samples, the second DWORD
; 1132 :         // contains 4 right samples.  We process the source in 8-byte
; 1133 :         // chunks to make it easy to interleave the output correctly.
; 1134 :         //
; 1135 : 
; 1136 :         while(cSamples)

  000e4	83 7d dc 00	 cmp	 DWORD PTR _cSamples$[ebp], 0
  000e8	0f 84 21 01 00
	00		 je	 $L36090

; 1137 :         {
; 1138 :             dwLeft = *(LPDWORD)pbBlock;

  000ee	8b 45 c8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  000f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f3	89 4d d4	 mov	 DWORD PTR _dwLeft$[ebp], ecx

; 1139 :             pbBlock += sizeof(DWORD);

  000f6	8b 55 c8	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  000f9	83 c2 04	 add	 edx, 4
  000fc	89 55 c8	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 1140 :             dwRight = *(LPDWORD)pbBlock;

  000ff	8b 45 c8	 mov	 eax, DWORD PTR _pbBlock$[ebp]
  00102	8b 08		 mov	 ecx, DWORD PTR [eax]
  00104	89 4d ec	 mov	 DWORD PTR _dwRight$[ebp], ecx

; 1141 :             pbBlock += sizeof(DWORD);

  00107	8b 55 c8	 mov	 edx, DWORD PTR _pbBlock$[ebp]
  0010a	83 c2 04	 add	 edx, 4
  0010d	89 55 c8	 mov	 DWORD PTR _pbBlock$[ebp], edx

; 1142 : 
; 1143 :             cSubSamples = min(cSamples, 8);

  00110	83 7d dc 08	 cmp	 DWORD PTR _cSamples$[ebp], 8
  00114	73 08		 jae	 SHORT $L41226
  00116	8b 45 dc	 mov	 eax, DWORD PTR _cSamples$[ebp]
  00119	89 45 c0	 mov	 DWORD PTR tv134[ebp], eax
  0011c	eb 07		 jmp	 SHORT $L41227
$L41226:
  0011e	c7 45 c0 08 00
	00 00		 mov	 DWORD PTR tv134[ebp], 8
$L41227:
  00125	8b 4d c0	 mov	 ecx, DWORD PTR tv134[ebp]
  00128	89 4d e4	 mov	 DWORD PTR _cSubSamples$[ebp], ecx

; 1144 :             
; 1145 :             for(i = 0; i < cSubSamples; i++)

  0012b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00132	eb 09		 jmp	 SHORT $L36095
$L36096:
  00134	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  00137	83 c2 01	 add	 edx, 1
  0013a	89 55 e8	 mov	 DWORD PTR _i$[ebp], edx
$L36095:
  0013d	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00140	3b 45 e4	 cmp	 eax, DWORD PTR _cSubSamples$[ebp]
  00143	0f 83 b8 00 00
	00		 jae	 $L36097

; 1146 :             {
; 1147 :                 //
; 1148 :                 // LEFT channel
; 1149 :                 //
; 1150 : 
; 1151 :                 nEncSampleL = (dwLeft & 0x0F);

  00149	8b 4d d4	 mov	 ecx, DWORD PTR _dwLeft$[ebp]
  0014c	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0014f	89 4d e0	 mov	 DWORD PTR _nEncSampleL$[ebp], ecx

; 1152 :                 nStepSize = m_asStep[nStepIndexL];

  00152	8b 55 f8	 mov	 edx, DWORD PTR _nStepIndexL$[ebp]
  00155	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[edx*2]
  0015d	89 45 d0	 mov	 DWORD PTR _nStepSize$[ebp], eax

; 1153 :                 nPredSampleL = DecodeSample(nEncSampleL, nPredSampleL, nStepSize);

  00160	8b 4d d0	 mov	 ecx, DWORD PTR _nStepSize$[ebp]
  00163	51		 push	 ecx
  00164	8b 55 c4	 mov	 edx, DWORD PTR _nPredSampleL$[ebp]
  00167	52		 push	 edx
  00168	8b 45 e0	 mov	 eax, DWORD PTR _nEncSampleL$[ebp]
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  00171	89 45 c4	 mov	 DWORD PTR _nPredSampleL$[ebp], eax

; 1154 :                 nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);

  00174	8b 4d f8	 mov	 ecx, DWORD PTR _nStepIndexL$[ebp]
  00177	51		 push	 ecx
  00178	8b 55 e0	 mov	 edx, DWORD PTR _nEncSampleL$[ebp]
  0017b	52		 push	 edx
  0017c	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  00181	89 45 f8	 mov	 DWORD PTR _nStepIndexL$[ebp], eax

; 1155 : 
; 1156 :                 //
; 1157 :                 // RIGHT channel
; 1158 :                 //
; 1159 : 
; 1160 :                 nEncSampleR = (dwRight & 0x0F);

  00184	8b 45 ec	 mov	 eax, DWORD PTR _dwRight$[ebp]
  00187	83 e0 0f	 and	 eax, 15			; 0000000fH
  0018a	89 45 fc	 mov	 DWORD PTR _nEncSampleR$[ebp], eax

; 1161 :                 nStepSize = m_asStep[nStepIndexR];

  0018d	8b 4d f0	 mov	 ecx, DWORD PTR _nStepIndexR$[ebp]
  00190	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?m_asStep@CImaAdpcmCodec@DirectSound@@0QBFB[ecx*2]
  00198	89 55 d0	 mov	 DWORD PTR _nStepSize$[ebp], edx

; 1162 :                 nPredSampleR = DecodeSample(nEncSampleR, nPredSampleR, nStepSize);

  0019b	8b 45 d0	 mov	 eax, DWORD PTR _nStepSize$[ebp]
  0019e	50		 push	 eax
  0019f	8b 4d d8	 mov	 ecx, DWORD PTR _nPredSampleR$[ebp]
  001a2	51		 push	 ecx
  001a3	8b 55 fc	 mov	 edx, DWORD PTR _nEncSampleR$[ebp]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 ?DecodeSample@CImaAdpcmCodec@DirectSound@@CGHHHH@Z ; DirectSound::CImaAdpcmCodec::DecodeSample
  001ac	89 45 d8	 mov	 DWORD PTR _nPredSampleR$[ebp], eax

; 1163 :                 nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);

  001af	8b 45 f0	 mov	 eax, DWORD PTR _nStepIndexR$[ebp]
  001b2	50		 push	 eax
  001b3	8b 4d fc	 mov	 ecx, DWORD PTR _nEncSampleR$[ebp]
  001b6	51		 push	 ecx
  001b7	e8 00 00 00 00	 call	 ?NextStepIndex@CImaAdpcmCodec@DirectSound@@CGHHH@Z ; DirectSound::CImaAdpcmCodec::NextStepIndex
  001bc	89 45 f0	 mov	 DWORD PTR _nStepIndexR$[ebp], eax

; 1164 : 
; 1165 :                 //
; 1166 :                 // Write out sample
; 1167 :                 //
; 1168 : 
; 1169 :                 *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);

  001bf	8b 55 c4	 mov	 edx, DWORD PTR _nPredSampleL$[ebp]
  001c2	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  001c8	0f b7 c2	 movzx	 eax, dx
  001cb	8b 4d d8	 mov	 ecx, DWORD PTR _nPredSampleR$[ebp]
  001ce	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  001d4	0f b7 d1	 movzx	 edx, cx
  001d7	c1 e2 10	 shl	 edx, 16			; 00000010H
  001da	0b c2		 or	 eax, edx
  001dc	8b 4d 0c	 mov	 ecx, DWORD PTR _pbDst$[ebp]
  001df	89 01		 mov	 DWORD PTR [ecx], eax

; 1170 :                 pbDst += sizeof(DWORD);

  001e1	8b 55 0c	 mov	 edx, DWORD PTR _pbDst$[ebp]
  001e4	83 c2 04	 add	 edx, 4
  001e7	89 55 0c	 mov	 DWORD PTR _pbDst$[ebp], edx

; 1171 : 
; 1172 :                 //
; 1173 :                 // Shift the next input sample into the low-order 4 bits.
; 1174 :                 //
; 1175 : 
; 1176 :                 dwLeft >>= 4;

  001ea	8b 45 d4	 mov	 eax, DWORD PTR _dwLeft$[ebp]
  001ed	c1 e8 04	 shr	 eax, 4
  001f0	89 45 d4	 mov	 DWORD PTR _dwLeft$[ebp], eax

; 1177 :                 dwRight >>= 4;

  001f3	8b 4d ec	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  001f6	c1 e9 04	 shr	 ecx, 4
  001f9	89 4d ec	 mov	 DWORD PTR _dwRight$[ebp], ecx

; 1178 :             }

  001fc	e9 33 ff ff ff	 jmp	 $L36096
$L36097:

; 1179 : 
; 1180 :             cSamples -= cSubSamples;

  00201	8b 55 dc	 mov	 edx, DWORD PTR _cSamples$[ebp]
  00204	2b 55 e4	 sub	 edx, DWORD PTR _cSubSamples$[ebp]
  00207	89 55 dc	 mov	 DWORD PTR _cSamples$[ebp], edx

; 1181 :         }

  0020a	e9 d5 fe ff ff	 jmp	 $L36089
$L36090:

; 1182 : 
; 1183 :         //
; 1184 :         // Skip padding
; 1185 :         //
; 1186 : 
; 1187 :         pbSrc += nBlockAlignment;

  0020f	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00212	03 45 14	 add	 eax, DWORD PTR _nBlockAlignment$[ebp]
  00215	89 45 08	 mov	 DWORD PTR _pbSrc$[ebp], eax

; 1188 :     }

  00218	e9 f0 fd ff ff	 jmp	 $L36056
$L36057:

; 1189 : 
; 1190 :     return fSuccess;

  0021d	8b 45 f4	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 1191 : }

  00220	8b e5		 mov	 esp, ebp
  00222	5d		 pop	 ebp
  00223	c2 1c 00	 ret	 28			; 0000001cH
?DecodeS16@CImaAdpcmCodec@DirectSound@@CGHPAE0IIIPAH1@Z ENDP ; DirectSound::CImaAdpcmCodec::DecodeS16
DSOUND	ENDS
PUBLIC	_IDirectSound_QueryInterfaceC@12
PUBLIC	_IDirectSound_AddRef@4
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _IDirectSound_QueryInterfaceC@12
DSOUND	SEGMENT
_pDirectSound$ = 8
_iid$ = 12
_ppvInterface$ = 16
_IDirectSound_QueryInterfaceC@12 PROC NEAR		; COMDAT

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     ASSERT(pDirectSound);
; 91   :     ASSERT(ppvInterface);
; 92   : 
; 93   :     IDirectSound_AddRef(pDirectSound);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _IDirectSound_AddRef@4

; 94   :     *ppvInterface = pDirectSound;

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _ppvInterface$[ebp]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _pDirectSound$[ebp]
  00012	89 11		 mov	 DWORD PTR [ecx], edx

; 95   : 
; 96   :     return DS_OK;

  00014	33 c0		 xor	 eax, eax

; 97   : }

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
_IDirectSound_QueryInterfaceC@12 ENDP
DSOUND	ENDS
PUBLIC	_IDirectSound_QueryInterface@12
; Function compile flags: /Odt
;	COMDAT _IDirectSound_QueryInterface@12
DSOUND	SEGMENT
_pDirectSound$ = 8
_iid$ = 12
_ppvInterface$ = 16
_IDirectSound_QueryInterface@12 PROC NEAR		; COMDAT

; 100  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 101  :     ASSERT(pDirectSound);
; 102  :     ASSERT(ppvInterface);
; 103  : 
; 104  :     IDirectSound_AddRef(pDirectSound);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _IDirectSound_AddRef@4

; 105  :     *ppvInterface = pDirectSound;

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _ppvInterface$[ebp]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _pDirectSound$[ebp]
  00012	89 11		 mov	 DWORD PTR [ecx], edx

; 106  : 
; 107  :     return DS_OK;

  00014	33 c0		 xor	 eax, eax

; 108  : }

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
_IDirectSound_QueryInterface@12 ENDP
DSOUND	ENDS
PUBLIC	_IDirectSound_SetCooperativeLevel@12
; Function compile flags: /Odt
;	COMDAT _IDirectSound_SetCooperativeLevel@12
DSOUND	SEGMENT
_pDirectSound$ = 8
_hWnd$ = 12
_dwLevel$ = 16
_IDirectSound_SetCooperativeLevel@12 PROC NEAR		; COMDAT

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 112  :     UNREFERENCED_PARAMETER(pDirectSound);
; 113  :     UNREFERENCED_PARAMETER(hWnd);
; 114  :     UNREFERENCED_PARAMETER(dwLevel);
; 115  :     return DS_OK;

  00003	33 c0		 xor	 eax, eax

; 116  : }

  00005	5d		 pop	 ebp
  00006	c2 0c 00	 ret	 12			; 0000000cH
_IDirectSound_SetCooperativeLevel@12 ENDP
DSOUND	ENDS
PUBLIC	_IDirectSound_Compact@4
; Function compile flags: /Odt
;	COMDAT _IDirectSound_Compact@4
DSOUND	SEGMENT
_pDirectSound$ = 8
_IDirectSound_Compact@4 PROC NEAR			; COMDAT

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 120  :     UNREFERENCED_PARAMETER(pDirectSound);
; 121  :     return DS_OK;

  00003	33 c0		 xor	 eax, eax

; 122  : }

  00005	5d		 pop	 ebp
  00006	c2 04 00	 ret	 4
_IDirectSound_Compact@4 ENDP
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT _IDirectSound_AddRef@4
DSOUND	SEGMENT
tv66 = -4
_pDirectSound$ = 8
_IDirectSound_AddRef@4 PROC NEAR			; COMDAT

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 126  :     return ((CDirectSound *)pDirectSound)->AddRef();

  00004	83 7d 08 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00008	74 0b		 je	 SHORT $L41243
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0000d	83 e8 08	 sub	 eax, 8
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41244
$L41243:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41244:
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]
  00024	50		 push	 eax
  00025	ff 52 04	 call	 DWORD PTR [edx+4]

; 127  : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
_IDirectSound_AddRef@4 ENDP
DSOUND	ENDS
PUBLIC	_IDirectSound_Release@4
; Function compile flags: /Odt
;	COMDAT _IDirectSound_Release@4
DSOUND	SEGMENT
tv66 = -4
_pDirectSound$ = 8
_IDirectSound_Release@4 PROC NEAR			; COMDAT

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 131  :     return ((CDirectSound *)pDirectSound)->Release();

  00004	83 7d 08 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00008	74 0b		 je	 SHORT $L41248
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0000d	83 e8 08	 sub	 eax, 8
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41249
$L41248:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41249:
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]
  00024	50		 push	 eax
  00025	ff 52 08	 call	 DWORD PTR [edx+8]

; 132  : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
_IDirectSound_Release@4 ENDP
DSOUND	ENDS
PUBLIC	?GetCaps@CDirectSound@DirectSound@@QAGJPAU_DSCAPS@@@Z ; DirectSound::CDirectSound::GetCaps
PUBLIC	_IDirectSound_GetCaps@8
; Function compile flags: /Odt
;	COMDAT _IDirectSound_GetCaps@8
DSOUND	SEGMENT
tv66 = -4
_pDirectSound$ = 8
_pdsc$ = 12
_IDirectSound_GetCaps@8 PROC NEAR			; COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 136  :     return ((CDirectSound *)pDirectSound)->GetCaps(pdsc);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00008	74 0b		 je	 SHORT $L41253
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0000d	83 e8 08	 sub	 eax, 8
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41254
$L41253:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41254:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _pdsc$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?GetCaps@CDirectSound@DirectSound@@QAGJPAU_DSCAPS@@@Z ; DirectSound::CDirectSound::GetCaps

; 137  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSound_GetCaps@8 ENDP
DSOUND	ENDS
PUBLIC	?CreateSoundBuffer@CDirectSound@DirectSound@@QAGJPBU_DSBUFFERDESC@@PAPAUIDirectSoundBuffer@@PAUIUnknown@@@Z ; DirectSound::CDirectSound::CreateSoundBuffer
PUBLIC	_IDirectSound_CreateSoundBuffer@16
; Function compile flags: /Odt
;	COMDAT _IDirectSound_CreateSoundBuffer@16
DSOUND	SEGMENT
tv66 = -4
_pDirectSound$ = 8
_pdsbd$ = 12
_ppBuffer$ = 16
_pUnkOuter$ = 20
_IDirectSound_CreateSoundBuffer@16 PROC NEAR		; COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 141  :     return ((CDirectSound *)pDirectSound)->CreateSoundBuffer(pdsbd, ppBuffer, pUnkOuter);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00008	74 0b		 je	 SHORT $L41258
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0000d	83 e8 08	 sub	 eax, 8
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41259
$L41258:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41259:
  0001c	8b 4d 14	 mov	 ecx, DWORD PTR _pUnkOuter$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR _ppBuffer$[ebp]
  00023	52		 push	 edx
  00024	8b 45 0c	 mov	 eax, DWORD PTR _pdsbd$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?CreateSoundBuffer@CDirectSound@DirectSound@@QAGJPBU_DSBUFFERDESC@@PAPAUIDirectSoundBuffer@@PAUIUnknown@@@Z ; DirectSound::CDirectSound::CreateSoundBuffer

; 142  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 10 00	 ret	 16			; 00000010H
_IDirectSound_CreateSoundBuffer@16 ENDP
DSOUND	ENDS
PUBLIC	?GetSpeakerConfig@CDirectSound@DirectSound@@QAGJPAK@Z ; DirectSound::CDirectSound::GetSpeakerConfig
PUBLIC	_IDirectSound_GetSpeakerConfig@8
; Function compile flags: /Odt
;	COMDAT _IDirectSound_GetSpeakerConfig@8
DSOUND	SEGMENT
tv66 = -4
_pDirectSound$ = 8
_pdwSpeakerConfig$ = 12
_IDirectSound_GetSpeakerConfig@8 PROC NEAR		; COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 155  :     return ((CDirectSound *)pDirectSound)->GetSpeakerConfig(pdwSpeakerConfig);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00008	74 0b		 je	 SHORT $L41263
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0000d	83 e8 08	 sub	 eax, 8
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41264
$L41263:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41264:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwSpeakerConfig$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?GetSpeakerConfig@CDirectSound@DirectSound@@QAGJPAK@Z ; DirectSound::CDirectSound::GetSpeakerConfig

; 156  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSound_GetSpeakerConfig@8 ENDP
DSOUND	ENDS
PUBLIC	?GetEffectData@CDirectSound@DirectSound@@QAGJKKPAXK@Z ; DirectSound::CDirectSound::GetEffectData
PUBLIC	_IDirectSound_GetEffectData@20
; Function compile flags: /Odt
;	COMDAT _IDirectSound_GetEffectData@20
DSOUND	SEGMENT
tv66 = -4
_pDirectSound$ = 8
_dwEffectIndex$ = 12
_dwOffset$ = 16
_pvData$ = 20
_dwDataSize$ = 24
_IDirectSound_GetEffectData@20 PROC NEAR		; COMDAT

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 178  : 
; 179  : #ifdef DSAPI_DISABLE_EFFECTS
; 180  : 
; 181  :     ZeroMemory(pvData, dwDataSize);
; 182  : 
; 183  :     return DS_OK;
; 184  : 
; 185  : #else // DSAPI_DISABLE_EFFECTS
; 186  : 
; 187  :     return ((CDirectSound *)pDirectSound)->GetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00008	74 0b		 je	 SHORT $L41268
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0000d	83 e8 08	 sub	 eax, 8
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41269
$L41268:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41269:
  0001c	8b 4d 18	 mov	 ecx, DWORD PTR _dwDataSize$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 14	 mov	 edx, DWORD PTR _pvData$[ebp]
  00023	52		 push	 edx
  00024	8b 45 10	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _dwEffectIndex$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ?GetEffectData@CDirectSound@DirectSound@@QAGJKKPAXK@Z ; DirectSound::CDirectSound::GetEffectData

; 188  : 
; 189  : #endif // DSAPI_DISABLE_EFFECTS
; 190  : 
; 191  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 14 00	 ret	 20			; 00000014H
_IDirectSound_GetEffectData@20 ENDP
DSOUND	ENDS
PUBLIC	?SetEffectData@CDirectSound@DirectSound@@QAGJKKPBXKK@Z ; DirectSound::CDirectSound::SetEffectData
PUBLIC	_IDirectSound_SetEffectData@24
; Function compile flags: /Odt
;	COMDAT _IDirectSound_SetEffectData@24
DSOUND	SEGMENT
tv66 = -4
_pDirectSound$ = 8
_dwEffectIndex$ = 12
_dwOffset$ = 16
_pvData$ = 20
_dwDataSize$ = 24
_dwFlags$ = 28
_IDirectSound_SetEffectData@24 PROC NEAR		; COMDAT

; 194  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 195  : 
; 196  : #ifdef DSAPI_DISABLE_EFFECTS
; 197  : 
; 198  :     return DS_OK;
; 199  : 
; 200  : #else // DSAPI_DISABLE_EFFECTS
; 201  : 
; 202  :     return ((CDirectSound *)pDirectSound)->SetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize, dwFlags);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00008	74 0b		 je	 SHORT $L41273
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0000d	83 e8 08	 sub	 eax, 8
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41274
$L41273:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41274:
  0001c	8b 4d 1c	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 18	 mov	 edx, DWORD PTR _dwDataSize$[ebp]
  00023	52		 push	 edx
  00024	8b 45 14	 mov	 eax, DWORD PTR _pvData$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 10	 mov	 ecx, DWORD PTR _dwOffset$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 0c	 mov	 edx, DWORD PTR _dwEffectIndex$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?SetEffectData@CDirectSound@DirectSound@@QAGJKKPBXKK@Z ; DirectSound::CDirectSound::SetEffectData

; 203  : 
; 204  : #endif // DSAPI_DISABLE_EFFECTS
; 205  : 
; 206  : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 18 00	 ret	 24			; 00000018H
_IDirectSound_SetEffectData@24 ENDP
DSOUND	ENDS
PUBLIC	?CommitEffectData@CDirectSound@DirectSound@@QAGJXZ ; DirectSound::CDirectSound::CommitEffectData
PUBLIC	_IDirectSound_CommitEffectData@4
; Function compile flags: /Odt
;	COMDAT _IDirectSound_CommitEffectData@4
DSOUND	SEGMENT
tv66 = -4
_pDirectSound$ = 8
_IDirectSound_CommitEffectData@4 PROC NEAR		; COMDAT

; 209  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 210  : 
; 211  : #ifdef DSAPI_DISABLE_EFFECTS
; 212  : 
; 213  :     return DS_OK;
; 214  : 
; 215  : #else // DSAPI_DISABLE_EFFECTS
; 216  : 
; 217  :     return ((CDirectSound *)pDirectSound)->CommitEffectData();

  00004	83 7d 08 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00008	74 0b		 je	 SHORT $L41278
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0000d	83 e8 08	 sub	 eax, 8
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41279
$L41278:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41279:
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ?CommitEffectData@CDirectSound@DirectSound@@QAGJXZ ; DirectSound::CDirectSound::CommitEffectData

; 218  : 
; 219  : #endif // DSAPI_DISABLE_EFFECTS
; 220  : 
; 221  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
_IDirectSound_CommitEffectData@4 ENDP
DSOUND	ENDS
PUBLIC	?SetMixBinHeadroom@CDirectSound@DirectSound@@QAGJKK@Z ; DirectSound::CDirectSound::SetMixBinHeadroom
PUBLIC	_IDirectSound_SetMixBinHeadroom@12
; Function compile flags: /Odt
;	COMDAT _IDirectSound_SetMixBinHeadroom@12
DSOUND	SEGMENT
tv66 = -4
_pDirectSound$ = 8
_dwMixBin$ = 12
_dwHeadroom$ = 16
_IDirectSound_SetMixBinHeadroom@12 PROC NEAR		; COMDAT

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 234  :     return ((CDirectSound *)pDirectSound)->SetMixBinHeadroom(dwMixBin, dwHeadroom);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00008	74 0b		 je	 SHORT $L41283
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0000d	83 e8 08	 sub	 eax, 8
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41284
$L41283:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41284:
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _dwHeadroom$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 0c	 mov	 edx, DWORD PTR _dwMixBin$[ebp]
  00023	52		 push	 edx
  00024	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?SetMixBinHeadroom@CDirectSound@DirectSound@@QAGJKK@Z ; DirectSound::CDirectSound::SetMixBinHeadroom

; 235  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
_IDirectSound_SetMixBinHeadroom@12 ENDP
DSOUND	ENDS
PUBLIC	?GetTime@CDirectSound@DirectSound@@QAGJPA_J@Z	; DirectSound::CDirectSound::GetTime
PUBLIC	_IDirectSound_GetTime@8
; Function compile flags: /Odt
;	COMDAT _IDirectSound_GetTime@8
DSOUND	SEGMENT
tv66 = -4
_pDirectSound$ = 8
_prtCurrent$ = 12
_IDirectSound_GetTime@8 PROC NEAR			; COMDAT

; 377  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 378  :     return ((CDirectSound *)pDirectSound)->GetTime(prtCurrent);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00008	74 0b		 je	 SHORT $L41288
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0000d	83 e8 08	 sub	 eax, 8
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41289
$L41288:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41289:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _prtCurrent$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?GetTime@CDirectSound@DirectSound@@QAGJPA_J@Z ; DirectSound::CDirectSound::GetTime

; 379  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSound_GetTime@8 ENDP
DSOUND	ENDS
PUBLIC	?GetOutputLevels@CDirectSound@DirectSound@@QAGJPAU_DSOUTPUTLEVELS@@H@Z ; DirectSound::CDirectSound::GetOutputLevels
PUBLIC	_IDirectSound_GetOutputLevels@12
; Function compile flags: /Odt
;	COMDAT _IDirectSound_GetOutputLevels@12
DSOUND	SEGMENT
tv66 = -4
_pDirectSound$ = 8
_pOutputLevels$ = 12
_bReset$ = 16
_IDirectSound_GetOutputLevels@12 PROC NEAR		; COMDAT

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 384  :     return ((CDirectSound *)pDirectSound)->GetOutputLevels(pOutputLevels,bReset);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00008	74 0b		 je	 SHORT $L41293
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0000d	83 e8 08	 sub	 eax, 8
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41294
$L41293:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41294:
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _bReset$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 0c	 mov	 edx, DWORD PTR _pOutputLevels$[ebp]
  00023	52		 push	 edx
  00024	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?GetOutputLevels@CDirectSound@DirectSound@@QAGJPAU_DSOUTPUTLEVELS@@H@Z ; DirectSound::CDirectSound::GetOutputLevels

; 385  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
_IDirectSound_GetOutputLevels@12 ENDP
DSOUND	ENDS
PUBLIC	_IDirectSoundBuffer_QueryInterface@12
PUBLIC	_IDirectSoundBuffer_AddRef@4
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_QueryInterface@12
DSOUND	SEGMENT
_pBuffer$ = 8
_iid$ = 12
_ppvInterface$ = 16
_IDirectSoundBuffer_QueryInterface@12 PROC NEAR		; COMDAT

; 389  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 390  :     ASSERT(pBuffer);
; 391  :     ASSERT(ppvInterface);
; 392  : 
; 393  :     IDirectSoundBuffer_AddRef(pBuffer);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _IDirectSoundBuffer_AddRef@4

; 394  :     *ppvInterface = pBuffer;

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _ppvInterface$[ebp]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  00012	89 11		 mov	 DWORD PTR [ecx], edx

; 395  : 
; 396  :     return DS_OK;

  00014	33 c0		 xor	 eax, eax

; 397  : }

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
_IDirectSoundBuffer_QueryInterface@12 ENDP
DSOUND	ENDS
PUBLIC	_IDirectSoundBuffer_QueryInterfaceC@12
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_QueryInterfaceC@12
DSOUND	SEGMENT
_pBuffer$ = 8
_iid$ = 12
_ppvInterface$ = 16
_IDirectSoundBuffer_QueryInterfaceC@12 PROC NEAR	; COMDAT

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 401  :     ASSERT(pBuffer);
; 402  :     ASSERT(ppvInterface);
; 403  : 
; 404  :     IDirectSoundBuffer_AddRef(pBuffer);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _IDirectSoundBuffer_AddRef@4

; 405  :     *ppvInterface = pBuffer;

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _ppvInterface$[ebp]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  00012	89 11		 mov	 DWORD PTR [ecx], edx

; 406  : 
; 407  :     return DS_OK;

  00014	33 c0		 xor	 eax, eax

; 408  : }

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
_IDirectSoundBuffer_QueryInterfaceC@12 ENDP
DSOUND	ENDS
PUBLIC	_IDirectSoundBuffer_Unlock@20
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_Unlock@20
DSOUND	SEGMENT
_pBuffer$ = 8
_pvLock1$ = 12
_dwLockSize1$ = 16
_pvLock2$ = 20
_dwLockSize2$ = 24
_IDirectSoundBuffer_Unlock@20 PROC NEAR			; COMDAT

; 411  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 412  :     return DS_OK;

  00003	33 c0		 xor	 eax, eax

; 413  : }

  00005	5d		 pop	 ebp
  00006	c2 14 00	 ret	 20			; 00000014H
_IDirectSoundBuffer_Unlock@20 ENDP
DSOUND	ENDS
PUBLIC	_IDirectSoundBuffer_Restore@4
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_Restore@4
DSOUND	SEGMENT
_pBuffer$ = 8
_IDirectSoundBuffer_Restore@4 PROC NEAR			; COMDAT

; 416  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 417  :     return DS_OK;

  00003	33 c0		 xor	 eax, eax

; 418  : }

  00005	5d		 pop	 ebp
  00006	c2 04 00	 ret	 4
_IDirectSoundBuffer_Restore@4 ENDP
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT _IDirectSoundBuffer_AddRef@4
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_IDirectSoundBuffer_AddRef@4 PROC NEAR			; COMDAT

; 421  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 422  :     return ((CDirectSoundBuffer *)pBuffer)->AddRef();

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41310
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41311
$L41310:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41311:
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]
  00024	50		 push	 eax
  00025	ff 52 04	 call	 DWORD PTR [edx+4]

; 423  : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
_IDirectSoundBuffer_AddRef@4 ENDP
DSOUND	ENDS
PUBLIC	_IDirectSoundBuffer_Release@4
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_Release@4
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_IDirectSoundBuffer_Release@4 PROC NEAR			; COMDAT

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 427  :     return ((CDirectSoundBuffer *)pBuffer)->Release();

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41315
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41316
$L41315:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41316:
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]
  00024	50		 push	 eax
  00025	ff 52 08	 call	 DWORD PTR [edx+8]

; 428  : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
_IDirectSoundBuffer_Release@4 ENDP
DSOUND	ENDS
PUBLIC	?SetFormat@CDirectSoundBuffer@DirectSound@@QAGJPBUtWAVEFORMATEX@@@Z ; DirectSound::CDirectSoundBuffer::SetFormat
PUBLIC	_IDirectSoundBuffer_SetFormat@8
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_SetFormat@8
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_pwfxFormat$ = 12
_IDirectSoundBuffer_SetFormat@8 PROC NEAR		; COMDAT

; 431  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 432  :     return ((CDirectSoundBuffer *)pBuffer)->SetFormat(pwfxFormat);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41320
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41321
$L41320:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41321:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _pwfxFormat$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?SetFormat@CDirectSoundBuffer@DirectSound@@QAGJPBUtWAVEFORMATEX@@@Z ; DirectSound::CDirectSoundBuffer::SetFormat

; 433  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSoundBuffer_SetFormat@8 ENDP
DSOUND	ENDS
PUBLIC	??0CAutoLock@DirectSound@@QAE@XZ		; DirectSound::CAutoLock::CAutoLock
PUBLIC	??1CAutoLock@DirectSound@@QAE@XZ		; DirectSound::CAutoLock::~CAutoLock
PUBLIC	?SetFormat@CDirectSoundVoice@DirectSound@@QAGJPBUtWAVEFORMATEX@@@Z ; DirectSound::CDirectSoundVoice::SetFormat
EXTRN	_g_fDirectSoundInFinalRelease:DWORD
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.h
;	COMDAT ?SetFormat@CDirectSoundBuffer@DirectSound@@QAGJPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
$T41326 = -12
$T41325 = -8
___AutoLock$ = -4
_this$ = 8
_pwfxFormat$ = 12
?SetFormat@CDirectSoundBuffer@DirectSound@@QAGJPBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetFormat, COMDAT

; 592  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 593  :         _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetFormat");

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L32519
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41325[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41325[ebp]
  00029	eb 1b		 jmp	 SHORT $L32517
$L32519:

; 594  :         return CDirectSoundVoice::SetFormat(pwfxFormat);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?SetFormat@CDirectSoundVoice@DirectSound@@QAGJPBUtWAVEFORMATEX@@@Z ; DirectSound::CDirectSoundVoice::SetFormat
  00038	89 45 f4	 mov	 DWORD PTR $T41326[ebp], eax
  0003b	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00043	8b 45 f4	 mov	 eax, DWORD PTR $T41326[ebp]
$L32517:

; 595  :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?SetFormat@CDirectSoundBuffer@DirectSound@@QAGJPBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::CDirectSoundBuffer::SetFormat
DSOUND	ENDS
PUBLIC	?DirectSoundEnterCriticalSection@@YGHXZ		; DirectSoundEnterCriticalSection
; Function compile flags: /Odt
;	COMDAT ??0CAutoLock@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CAutoLock@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CAutoLock::CAutoLock, COMDAT
; _this$ = ecx

; 146  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  :         m_fLocked = (BOOLEAN)DirectSoundEnterCriticalSection();

  00007	e8 00 00 00 00	 call	 ?DirectSoundEnterCriticalSection@@YGHXZ ; DirectSoundEnterCriticalSection
  0000c	0f b6 c0	 movzx	 eax, al
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	89 01		 mov	 DWORD PTR [ecx], eax

; 148  :     }

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??0CAutoLock@DirectSound@@QAE@XZ ENDP			; DirectSound::CAutoLock::CAutoLock
DSOUND	ENDS
EXTRN	__imp__RtlEnterCriticalSection@4:NEAR
EXTRN	_g_DirectSoundCriticalSection:BYTE
; Function compile flags: /Odt
;	COMDAT ?DirectSoundEnterCriticalSection@@YGHXZ
DSOUND	SEGMENT
?DirectSoundEnterCriticalSection@@YGHXZ PROC NEAR	; DirectSoundEnterCriticalSection, COMDAT

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   :     if(PASSIVE_LEVEL != KeGetCurrentIrql())

  00003	e8 00 00 00 00	 call	 _KeGetCurrentIrql@0
  00008	0f b6 c0	 movzx	 eax, al
  0000b	85 c0		 test	 eax, eax
  0000d	74 04		 je	 SHORT $L32012

; 43   :     {
; 44   :         return FALSE;

  0000f	33 c0		 xor	 eax, eax
  00011	eb 10		 jmp	 SHORT $L32011
$L32012:

; 45   :     }
; 46   : 
; 47   :     EnterCriticalSection(&g_DirectSoundCriticalSection); 

  00013	68 00 00 00 00	 push	 OFFSET FLAT:_g_DirectSoundCriticalSection
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 48   : 
; 49   :     return TRUE;

  0001e	b8 01 00 00 00	 mov	 eax, 1
$L32011:

; 50   : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?DirectSoundEnterCriticalSection@@YGHXZ ENDP		; DirectSoundEnterCriticalSection
; Function compile flags: /Odt
; File c:\xbox\private\ntos\inc\i386.h
DSOUND	ENDS
;	COMDAT _KeGetCurrentIrql@0
DSOUND	SEGMENT
_KeGetCurrentIrql@0 PROC NEAR				; COMDAT

; 1496 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1497 : #if defined(_NTSYSTEM_)
; 1498 :     return KeGetPcr()->Irql;
; 1499 : #else
; 1500 :     __asm {  movzx eax, byte ptr fs:[0] KPCR.Irql }

  00003	64 0f b6 05 24
	00 00 00	 movzx	 eax, BYTE PTR fs:36

; 1501 : #endif
; 1502 : }    

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_KeGetCurrentIrql@0 ENDP
DSOUND	ENDS
PUBLIC	?DirectSoundLeaveCriticalSection@@YGXXZ		; DirectSoundLeaveCriticalSection
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.h
;	COMDAT ??1CAutoLock@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CAutoLock@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CAutoLock::~CAutoLock, COMDAT
; _this$ = ecx

; 151  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  :         if(m_fLocked)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 05		 je	 SHORT $L32042

; 153  :         {
; 154  :             DirectSoundLeaveCriticalSection();

  0000f	e8 00 00 00 00	 call	 ?DirectSoundLeaveCriticalSection@@YGXXZ ; DirectSoundLeaveCriticalSection
$L32042:

; 155  :         }
; 156  :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??1CAutoLock@DirectSound@@QAE@XZ ENDP			; DirectSound::CAutoLock::~CAutoLock
DSOUND	ENDS
EXTRN	__imp__RtlLeaveCriticalSection@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?DirectSoundLeaveCriticalSection@@YGXXZ
DSOUND	SEGMENT
?DirectSoundLeaveCriticalSection@@YGXXZ PROC NEAR	; DirectSoundLeaveCriticalSection, COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 54   :     LeaveCriticalSection(&g_DirectSoundCriticalSection);

  00003	68 00 00 00 00	 push	 OFFSET FLAT:_g_DirectSoundCriticalSection
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 55   : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?DirectSoundLeaveCriticalSection@@YGXXZ ENDP		; DirectSoundLeaveCriticalSection
DSOUND	ENDS
PUBLIC	?SetFrequency@CDirectSoundBuffer@DirectSound@@QAGJK@Z ; DirectSound::CDirectSoundBuffer::SetFrequency
PUBLIC	_IDirectSoundBuffer_SetFrequency@8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _IDirectSoundBuffer_SetFrequency@8
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_dwFrequency$ = 12
_IDirectSoundBuffer_SetFrequency@8 PROC NEAR		; COMDAT

; 436  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 437  : 
; 438  : #ifdef DSAPI_DISABLE_PITCH
; 439  : 
; 440  :     return DS_OK;
; 441  : 
; 442  : #else // DSAPI_DISABLE_PITCH
; 443  : 
; 444  :     return ((CDirectSoundBuffer *)pBuffer)->SetFrequency(dwFrequency);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41345
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41346
$L41345:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41346:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFrequency$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?SetFrequency@CDirectSoundBuffer@DirectSound@@QAGJK@Z ; DirectSound::CDirectSoundBuffer::SetFrequency

; 445  : 
; 446  : #endif // DSAPI_DISABLE_PITCH
; 447  : 
; 448  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSoundBuffer_SetFrequency@8 ENDP
DSOUND	ENDS
PUBLIC	?SetFrequency@CDirectSoundVoice@DirectSound@@QAGJK@Z ; DirectSound::CDirectSoundVoice::SetFrequency
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.h
;	COMDAT ?SetFrequency@CDirectSoundBuffer@DirectSound@@QAGJK@Z
DSOUND	SEGMENT
$T41351 = -12
$T41350 = -8
___AutoLock$ = -4
_this$ = 8
_dwFrequency$ = 12
?SetFrequency@CDirectSoundBuffer@DirectSound@@QAGJK@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetFrequency, COMDAT

; 598  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 599  :         _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetFrequency");

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L32528
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41350[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41350[ebp]
  00029	eb 1b		 jmp	 SHORT $L32526
$L32528:

; 600  :         return CDirectSoundVoice::SetFrequency(dwFrequency);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _dwFrequency$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?SetFrequency@CDirectSoundVoice@DirectSound@@QAGJK@Z ; DirectSound::CDirectSoundVoice::SetFrequency
  00038	89 45 f4	 mov	 DWORD PTR $T41351[ebp], eax
  0003b	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00043	8b 45 f4	 mov	 eax, DWORD PTR $T41351[ebp]
$L32526:

; 601  :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?SetFrequency@CDirectSoundBuffer@DirectSound@@QAGJK@Z ENDP ; DirectSound::CDirectSoundBuffer::SetFrequency
DSOUND	ENDS
PUBLIC	?SetVolume@CDirectSoundBuffer@DirectSound@@QAGJJ@Z ; DirectSound::CDirectSoundBuffer::SetVolume
PUBLIC	_IDirectSoundBuffer_SetVolume@8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _IDirectSoundBuffer_SetVolume@8
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_lVolume$ = 12
_IDirectSoundBuffer_SetVolume@8 PROC NEAR		; COMDAT

; 451  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 452  : 
; 453  : #ifdef DSAPI_DISABLE_VOLUME
; 454  : 
; 455  :     return DS_OK;
; 456  : 
; 457  : #else // DSAPI_DISABLE_VOLUME
; 458  : 
; 459  :     return ((CDirectSoundBuffer *)pBuffer)->SetVolume(lVolume);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41355
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41356
$L41355:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41356:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _lVolume$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?SetVolume@CDirectSoundBuffer@DirectSound@@QAGJJ@Z ; DirectSound::CDirectSoundBuffer::SetVolume

; 460  : 
; 461  : #endif // DSAPI_DISABLE_VOLUME
; 462  : 
; 463  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSoundBuffer_SetVolume@8 ENDP
DSOUND	ENDS
PUBLIC	?SetVolume@CDirectSoundVoice@DirectSound@@QAGJJ@Z ; DirectSound::CDirectSoundVoice::SetVolume
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.h
;	COMDAT ?SetVolume@CDirectSoundBuffer@DirectSound@@QAGJJ@Z
DSOUND	SEGMENT
$T41361 = -12
$T41360 = -8
___AutoLock$ = -4
_this$ = 8
_lVolume$ = 12
?SetVolume@CDirectSoundBuffer@DirectSound@@QAGJJ@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetVolume, COMDAT

; 604  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 605  :         _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetVolume");

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L32537
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41360[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41360[ebp]
  00029	eb 1b		 jmp	 SHORT $L32535
$L32537:

; 606  :         return CDirectSoundVoice::SetVolume(lVolume);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _lVolume$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?SetVolume@CDirectSoundVoice@DirectSound@@QAGJJ@Z ; DirectSound::CDirectSoundVoice::SetVolume
  00038	89 45 f4	 mov	 DWORD PTR $T41361[ebp], eax
  0003b	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00043	8b 45 f4	 mov	 eax, DWORD PTR $T41361[ebp]
$L32535:

; 607  :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?SetVolume@CDirectSoundBuffer@DirectSound@@QAGJJ@Z ENDP	; DirectSound::CDirectSoundBuffer::SetVolume
DSOUND	ENDS
PUBLIC	?SetPitch@CDirectSoundBuffer@DirectSound@@QAGJJ@Z ; DirectSound::CDirectSoundBuffer::SetPitch
PUBLIC	_IDirectSoundBuffer_SetPitch@8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _IDirectSoundBuffer_SetPitch@8
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_lPitch$ = 12
_IDirectSoundBuffer_SetPitch@8 PROC NEAR		; COMDAT

; 466  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 467  : 
; 468  : #ifdef DSAPI_DISABLE_PITCH
; 469  : 
; 470  :     return DS_OK;
; 471  : 
; 472  : #else // DSAPI_DISABLE_PITCH
; 473  : 
; 474  :     return ((CDirectSoundBuffer *)pBuffer)->SetPitch(lPitch);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41365
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41366
$L41365:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41366:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _lPitch$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?SetPitch@CDirectSoundBuffer@DirectSound@@QAGJJ@Z ; DirectSound::CDirectSoundBuffer::SetPitch

; 475  : 
; 476  : #endif // DSAPI_DISABLE_PITCH
; 477  : 
; 478  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSoundBuffer_SetPitch@8 ENDP
DSOUND	ENDS
PUBLIC	?SetPitch@CDirectSoundVoice@DirectSound@@QAGJJ@Z ; DirectSound::CDirectSoundVoice::SetPitch
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.h
;	COMDAT ?SetPitch@CDirectSoundBuffer@DirectSound@@QAGJJ@Z
DSOUND	SEGMENT
$T41371 = -12
$T41370 = -8
___AutoLock$ = -4
_this$ = 8
_lPitch$ = 12
?SetPitch@CDirectSoundBuffer@DirectSound@@QAGJJ@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetPitch, COMDAT

; 610  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 611  :         _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetPitch");

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L32546
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41370[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41370[ebp]
  00029	eb 1b		 jmp	 SHORT $L32544
$L32546:

; 612  :         return CDirectSoundVoice::SetPitch(lPitch);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _lPitch$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?SetPitch@CDirectSoundVoice@DirectSound@@QAGJJ@Z ; DirectSound::CDirectSoundVoice::SetPitch
  00038	89 45 f4	 mov	 DWORD PTR $T41371[ebp], eax
  0003b	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00043	8b 45 f4	 mov	 eax, DWORD PTR $T41371[ebp]
$L32544:

; 613  :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?SetPitch@CDirectSoundBuffer@DirectSound@@QAGJJ@Z ENDP	; DirectSound::CDirectSoundBuffer::SetPitch
DSOUND	ENDS
PUBLIC	?SetLFO@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSLFODESC@@@Z ; DirectSound::CDirectSoundBuffer::SetLFO
PUBLIC	_IDirectSoundBuffer_SetLFO@8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _IDirectSoundBuffer_SetLFO@8
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_pLFODesc$ = 12
_IDirectSoundBuffer_SetLFO@8 PROC NEAR			; COMDAT

; 481  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 482  : 
; 483  : #ifdef DSAPI_DISABLE_LFO
; 484  : 
; 485  :     return DS_OK;
; 486  : 
; 487  : #else // DSAPI_DISABLE_LFO
; 488  : 
; 489  :     return ((CDirectSoundBuffer *)pBuffer)->SetLFO(pLFODesc);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41375
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41376
$L41375:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41376:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _pLFODesc$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?SetLFO@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSLFODESC@@@Z ; DirectSound::CDirectSoundBuffer::SetLFO

; 490  : 
; 491  : #endif // DSAPI_DISABLE_LFO
; 492  : 
; 493  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSoundBuffer_SetLFO@8 ENDP
DSOUND	ENDS
PUBLIC	?SetLFO@CDirectSoundVoice@DirectSound@@QAGJPBU_DSLFODESC@@@Z ; DirectSound::CDirectSoundVoice::SetLFO
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.h
;	COMDAT ?SetLFO@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSLFODESC@@@Z
DSOUND	SEGMENT
$T41381 = -12
$T41380 = -8
___AutoLock$ = -4
_this$ = 8
_pLFODesc$ = 12
?SetLFO@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSLFODESC@@@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetLFO, COMDAT

; 616  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 617  :         _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetLFO");

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L32555
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41380[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41380[ebp]
  00029	eb 1b		 jmp	 SHORT $L32553
$L32555:

; 618  :         return CDirectSoundVoice::SetLFO(pLFODesc);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _pLFODesc$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?SetLFO@CDirectSoundVoice@DirectSound@@QAGJPBU_DSLFODESC@@@Z ; DirectSound::CDirectSoundVoice::SetLFO
  00038	89 45 f4	 mov	 DWORD PTR $T41381[ebp], eax
  0003b	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00043	8b 45 f4	 mov	 eax, DWORD PTR $T41381[ebp]
$L32553:

; 619  :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?SetLFO@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSLFODESC@@@Z ENDP ; DirectSound::CDirectSoundBuffer::SetLFO
DSOUND	ENDS
PUBLIC	?SetEG@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSENVELOPEDESC@@@Z ; DirectSound::CDirectSoundBuffer::SetEG
PUBLIC	_IDirectSoundBuffer_SetEG@8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _IDirectSoundBuffer_SetEG@8
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_pEnvelopeDesc$ = 12
_IDirectSoundBuffer_SetEG@8 PROC NEAR			; COMDAT

; 496  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 497  : 
; 498  : #ifdef DSAPI_DISABLE_EG
; 499  : 
; 500  :     return DS_OK;
; 501  : 
; 502  : #else // DSAPI_DISABLE_EG
; 503  : 
; 504  :     return ((CDirectSoundBuffer *)pBuffer)->SetEG(pEnvelopeDesc);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41385
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41386
$L41385:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41386:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _pEnvelopeDesc$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?SetEG@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSENVELOPEDESC@@@Z ; DirectSound::CDirectSoundBuffer::SetEG

; 505  : 
; 506  : #endif // DSAPI_DISABLE_EG
; 507  : 
; 508  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSoundBuffer_SetEG@8 ENDP
DSOUND	ENDS
PUBLIC	?SetEG@CDirectSoundVoice@DirectSound@@QAGJPBU_DSENVELOPEDESC@@@Z ; DirectSound::CDirectSoundVoice::SetEG
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.h
;	COMDAT ?SetEG@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSENVELOPEDESC@@@Z
DSOUND	SEGMENT
$T41391 = -12
$T41390 = -8
___AutoLock$ = -4
_this$ = 8
_pEnvelopeDesc$ = 12
?SetEG@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSENVELOPEDESC@@@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetEG, COMDAT

; 622  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 623  :         _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetEG");

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L32564
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41390[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41390[ebp]
  00029	eb 1b		 jmp	 SHORT $L32562
$L32564:

; 624  :         return CDirectSoundVoice::SetEG(pEnvelopeDesc);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _pEnvelopeDesc$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?SetEG@CDirectSoundVoice@DirectSound@@QAGJPBU_DSENVELOPEDESC@@@Z ; DirectSound::CDirectSoundVoice::SetEG
  00038	89 45 f4	 mov	 DWORD PTR $T41391[ebp], eax
  0003b	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00043	8b 45 f4	 mov	 eax, DWORD PTR $T41391[ebp]
$L32562:

; 625  :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?SetEG@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSENVELOPEDESC@@@Z ENDP ; DirectSound::CDirectSoundBuffer::SetEG
DSOUND	ENDS
PUBLIC	?SetFilter@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSFILTERDESC@@@Z ; DirectSound::CDirectSoundBuffer::SetFilter
PUBLIC	_IDirectSoundBuffer_SetFilter@8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _IDirectSoundBuffer_SetFilter@8
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_pFilter$ = 12
_IDirectSoundBuffer_SetFilter@8 PROC NEAR		; COMDAT

; 511  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 512  : 
; 513  : #ifdef DSAPI_DISABLE_FILTER
; 514  : 
; 515  :     return DS_OK;
; 516  : 
; 517  : #else // DSAPI_DISABLE_FILTER
; 518  : 
; 519  :     return ((CDirectSoundBuffer *)pBuffer)->SetFilter(pFilter);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41395
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41396
$L41395:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41396:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _pFilter$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?SetFilter@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSFILTERDESC@@@Z ; DirectSound::CDirectSoundBuffer::SetFilter

; 520  : 
; 521  : #endif // DSAPI_DISABLE_FILTER
; 522  : 
; 523  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSoundBuffer_SetFilter@8 ENDP
DSOUND	ENDS
PUBLIC	?SetFilter@CDirectSoundVoice@DirectSound@@QAGJPBU_DSFILTERDESC@@@Z ; DirectSound::CDirectSoundVoice::SetFilter
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.h
;	COMDAT ?SetFilter@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSFILTERDESC@@@Z
DSOUND	SEGMENT
$T41401 = -12
$T41400 = -8
___AutoLock$ = -4
_this$ = 8
_pFilterDesc$ = 12
?SetFilter@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSFILTERDESC@@@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetFilter, COMDAT

; 628  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 629  :         _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetFilter");

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L32573
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41400[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41400[ebp]
  00029	eb 1b		 jmp	 SHORT $L32571
$L32573:

; 630  :         return CDirectSoundVoice::SetFilter(pFilterDesc);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _pFilterDesc$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?SetFilter@CDirectSoundVoice@DirectSound@@QAGJPBU_DSFILTERDESC@@@Z ; DirectSound::CDirectSoundVoice::SetFilter
  00038	89 45 f4	 mov	 DWORD PTR $T41401[ebp], eax
  0003b	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00043	8b 45 f4	 mov	 eax, DWORD PTR $T41401[ebp]
$L32571:

; 631  :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?SetFilter@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSFILTERDESC@@@Z ENDP ; DirectSound::CDirectSoundBuffer::SetFilter
DSOUND	ENDS
PUBLIC	?SetHeadroom@CDirectSoundBuffer@DirectSound@@QAGJK@Z ; DirectSound::CDirectSoundBuffer::SetHeadroom
PUBLIC	_IDirectSoundBuffer_SetHeadroom@8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _IDirectSoundBuffer_SetHeadroom@8
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_dwHeadroom$ = 12
_IDirectSoundBuffer_SetHeadroom@8 PROC NEAR		; COMDAT

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 527  : 
; 528  : #ifdef DSAPI_DISABLE_VOLUME
; 529  : 
; 530  :     return DS_OK;
; 531  : 
; 532  : #else // DSAPI_DISABLE_VOLUME
; 533  : 
; 534  :     return ((CDirectSoundBuffer *)pBuffer)->SetHeadroom(dwHeadroom);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41405
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41406
$L41405:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41406:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _dwHeadroom$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?SetHeadroom@CDirectSoundBuffer@DirectSound@@QAGJK@Z ; DirectSound::CDirectSoundBuffer::SetHeadroom

; 535  : 
; 536  : #endif // DSAPI_DISABLE_VOLUME
; 537  : 
; 538  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSoundBuffer_SetHeadroom@8 ENDP
DSOUND	ENDS
PUBLIC	?SetHeadroom@CDirectSoundVoice@DirectSound@@QAGJK@Z ; DirectSound::CDirectSoundVoice::SetHeadroom
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.h
;	COMDAT ?SetHeadroom@CDirectSoundBuffer@DirectSound@@QAGJK@Z
DSOUND	SEGMENT
$T41411 = -12
$T41410 = -8
___AutoLock$ = -4
_this$ = 8
_dwHeadroom$ = 12
?SetHeadroom@CDirectSoundBuffer@DirectSound@@QAGJK@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetHeadroom, COMDAT

; 634  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 635  :         _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetHeadroom");

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L32582
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41410[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41410[ebp]
  00029	eb 1b		 jmp	 SHORT $L32580
$L32582:

; 636  :         return CDirectSoundVoice::SetHeadroom(dwHeadroom);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _dwHeadroom$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?SetHeadroom@CDirectSoundVoice@DirectSound@@QAGJK@Z ; DirectSound::CDirectSoundVoice::SetHeadroom
  00038	89 45 f4	 mov	 DWORD PTR $T41411[ebp], eax
  0003b	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00043	8b 45 f4	 mov	 eax, DWORD PTR $T41411[ebp]
$L32580:

; 637  :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?SetHeadroom@CDirectSoundBuffer@DirectSound@@QAGJK@Z ENDP ; DirectSound::CDirectSoundBuffer::SetHeadroom
DSOUND	ENDS
PUBLIC	?SetOutputBuffer@CDirectSoundBuffer@DirectSound@@QAGJPAUIDirectSoundBuffer@@@Z ; DirectSound::CDirectSoundBuffer::SetOutputBuffer
PUBLIC	_IDirectSoundBuffer_SetOutputBuffer@8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _IDirectSoundBuffer_SetOutputBuffer@8
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_pOutputBuffer$ = 12
_IDirectSoundBuffer_SetOutputBuffer@8 PROC NEAR		; COMDAT

; 541  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 542  : 
; 543  : #ifdef DSAPI_DISABLE_SUBMIX
; 544  : 
; 545  :     return DS_OK;
; 546  : 
; 547  : #else // DSAPI_DISABLE_SUBMIX
; 548  : 
; 549  :     return ((CDirectSoundBuffer *)pBuffer)->SetOutputBuffer(pOutputBuffer);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41415
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41416
$L41415:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41416:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _pOutputBuffer$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?SetOutputBuffer@CDirectSoundBuffer@DirectSound@@QAGJPAUIDirectSoundBuffer@@@Z ; DirectSound::CDirectSoundBuffer::SetOutputBuffer

; 550  : 
; 551  : #endif // DSAPI_DISABLE_SUBMIX
; 552  : 
; 553  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSoundBuffer_SetOutputBuffer@8 ENDP
DSOUND	ENDS
PUBLIC	?SetOutputBuffer@CDirectSoundVoice@DirectSound@@QAGJPAUIDirectSoundBuffer@@@Z ; DirectSound::CDirectSoundVoice::SetOutputBuffer
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.h
;	COMDAT ?SetOutputBuffer@CDirectSoundBuffer@DirectSound@@QAGJPAUIDirectSoundBuffer@@@Z
DSOUND	SEGMENT
$T41421 = -12
$T41420 = -8
___AutoLock$ = -4
_this$ = 8
_pOutputBuffer$ = 12
?SetOutputBuffer@CDirectSoundBuffer@DirectSound@@QAGJPAUIDirectSoundBuffer@@@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetOutputBuffer, COMDAT

; 640  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 641  :         _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetOutputBuffer");

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L32591
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41420[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41420[ebp]
  00029	eb 1b		 jmp	 SHORT $L32589
$L32591:

; 642  :         return CDirectSoundVoice::SetOutputBuffer(pOutputBuffer);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _pOutputBuffer$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?SetOutputBuffer@CDirectSoundVoice@DirectSound@@QAGJPAUIDirectSoundBuffer@@@Z ; DirectSound::CDirectSoundVoice::SetOutputBuffer
  00038	89 45 f4	 mov	 DWORD PTR $T41421[ebp], eax
  0003b	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00043	8b 45 f4	 mov	 eax, DWORD PTR $T41421[ebp]
$L32589:

; 643  :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?SetOutputBuffer@CDirectSoundBuffer@DirectSound@@QAGJPAUIDirectSoundBuffer@@@Z ENDP ; DirectSound::CDirectSoundBuffer::SetOutputBuffer
DSOUND	ENDS
PUBLIC	?SetMixBins@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundBuffer::SetMixBins
PUBLIC	_IDirectSoundBuffer_SetMixBins@8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _IDirectSoundBuffer_SetMixBins@8
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_pMixBins$ = 12
_IDirectSoundBuffer_SetMixBins@8 PROC NEAR		; COMDAT

; 556  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 557  : 
; 558  : #ifdef DSAPI_DISABLE_MIXBINS
; 559  : 
; 560  :     return DS_OK;
; 561  : 
; 562  : #else // DSAPI_DISABLE_MIXBINS
; 563  : 
; 564  :     return ((CDirectSoundBuffer *)pBuffer)->SetMixBins(pMixBins);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41425
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41426
$L41425:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41426:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _pMixBins$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?SetMixBins@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundBuffer::SetMixBins

; 565  : 
; 566  : #endif // DSAPI_DISABLE_SUBMIX
; 567  : 
; 568  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSoundBuffer_SetMixBins@8 ENDP
DSOUND	ENDS
PUBLIC	?SetMixBins@CDirectSoundVoice@DirectSound@@QAGJPBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundVoice::SetMixBins
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.h
;	COMDAT ?SetMixBins@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSMIXBINS@@@Z
DSOUND	SEGMENT
$T41431 = -12
$T41430 = -8
___AutoLock$ = -4
_this$ = 8
_pMixBins$ = 12
?SetMixBins@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSMIXBINS@@@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetMixBins, COMDAT

; 646  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 647  :         _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetMixBins");

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L32600
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41430[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41430[ebp]
  00029	eb 1b		 jmp	 SHORT $L32598
$L32600:

; 648  :         return CDirectSoundVoice::SetMixBins(pMixBins);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _pMixBins$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?SetMixBins@CDirectSoundVoice@DirectSound@@QAGJPBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundVoice::SetMixBins
  00038	89 45 f4	 mov	 DWORD PTR $T41431[ebp], eax
  0003b	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00043	8b 45 f4	 mov	 eax, DWORD PTR $T41431[ebp]
$L32598:

; 649  :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?SetMixBins@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSMIXBINS@@@Z ENDP ; DirectSound::CDirectSoundBuffer::SetMixBins
DSOUND	ENDS
PUBLIC	?SetMixBinVolumes@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundBuffer::SetMixBinVolumes
PUBLIC	_IDirectSoundBuffer_SetMixBinVolumes@8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _IDirectSoundBuffer_SetMixBinVolumes@8
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_pMixBins$ = 12
_IDirectSoundBuffer_SetMixBinVolumes@8 PROC NEAR	; COMDAT

; 571  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 572  : 
; 573  : #ifdef DSAPI_DISABLE_VOLUME
; 574  : 
; 575  :     return DS_OK;
; 576  : 
; 577  : #else // DSAPI_DISABLE_VOLUME
; 578  : 
; 579  :     return ((CDirectSoundBuffer *)pBuffer)->SetMixBinVolumes(pMixBins);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41435
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41436
$L41435:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41436:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _pMixBins$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?SetMixBinVolumes@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundBuffer::SetMixBinVolumes

; 580  : 
; 581  : #endif // DSAPI_DISABLE_VOLUME
; 582  : 
; 583  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSoundBuffer_SetMixBinVolumes@8 ENDP
DSOUND	ENDS
PUBLIC	?SetMixBinVolumes@CDirectSoundVoice@DirectSound@@QAGJPBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundVoice::SetMixBinVolumes
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.h
;	COMDAT ?SetMixBinVolumes@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSMIXBINS@@@Z
DSOUND	SEGMENT
$T41441 = -12
$T41440 = -8
___AutoLock$ = -4
_this$ = 8
_pMixBins$ = 12
?SetMixBinVolumes@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSMIXBINS@@@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetMixBinVolumes, COMDAT

; 652  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 653  :         _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::SetMixBinVolumes");

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L32609
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41440[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41440[ebp]
  00029	eb 1b		 jmp	 SHORT $L32607
$L32609:

; 654  :         return CDirectSoundVoice::SetMixBinVolumes(pMixBins);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _pMixBins$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?SetMixBinVolumes@CDirectSoundVoice@DirectSound@@QAGJPBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundVoice::SetMixBinVolumes
  00038	89 45 f4	 mov	 DWORD PTR $T41441[ebp], eax
  0003b	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0003e	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00043	8b 45 f4	 mov	 eax, DWORD PTR $T41441[ebp]
$L32607:

; 655  :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?SetMixBinVolumes@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSMIXBINS@@@Z ENDP ; DirectSound::CDirectSoundBuffer::SetMixBinVolumes
DSOUND	ENDS
PUBLIC	?Play@CDirectSoundBuffer@DirectSound@@QAGJKKK@Z	; DirectSound::CDirectSoundBuffer::Play
PUBLIC	_IDirectSoundBuffer_Play@16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _IDirectSoundBuffer_Play@16
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_dwReserved1$ = 12
_dwReserved2$ = 16
_dwFlags$ = 20
_IDirectSoundBuffer_Play@16 PROC NEAR			; COMDAT

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 801  :     return ((CDirectSoundBuffer *)pBuffer)->Play(dwReserved1, dwReserved2, dwFlags);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41445
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41446
$L41445:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41446:
  0001c	8b 4d 14	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR _dwReserved2$[ebp]
  00023	52		 push	 edx
  00024	8b 45 0c	 mov	 eax, DWORD PTR _dwReserved1$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?Play@CDirectSoundBuffer@DirectSound@@QAGJKKK@Z ; DirectSound::CDirectSoundBuffer::Play

; 802  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 10 00	 ret	 16			; 00000010H
_IDirectSoundBuffer_Play@16 ENDP
DSOUND	ENDS
PUBLIC	?PlayEx@CDirectSoundBuffer@DirectSound@@QAGJ_JK@Z ; DirectSound::CDirectSoundBuffer::PlayEx
PUBLIC	_IDirectSoundBuffer_PlayEx@16
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_PlayEx@16
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_rtTimeStamp$ = 12
_dwFlags$ = 20
_IDirectSoundBuffer_PlayEx@16 PROC NEAR			; COMDAT

; 805  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 806  :     return ((CDirectSoundBuffer *)pBuffer)->PlayEx(rtTimeStamp, dwFlags);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41450
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41451
$L41450:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41451:
  0001c	8b 4d 14	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR _rtTimeStamp$[ebp+4]
  00023	52		 push	 edx
  00024	8b 45 0c	 mov	 eax, DWORD PTR _rtTimeStamp$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?PlayEx@CDirectSoundBuffer@DirectSound@@QAGJ_JK@Z ; DirectSound::CDirectSoundBuffer::PlayEx

; 807  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 10 00	 ret	 16			; 00000010H
_IDirectSoundBuffer_PlayEx@16 ENDP
DSOUND	ENDS
PUBLIC	?Stop@CDirectSoundBuffer@DirectSound@@QAGJXZ	; DirectSound::CDirectSoundBuffer::Stop
PUBLIC	_IDirectSoundBuffer_Stop@4
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_Stop@4
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_IDirectSoundBuffer_Stop@4 PROC NEAR			; COMDAT

; 810  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 811  :     return ((CDirectSoundBuffer *)pBuffer)->Stop();

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41455
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41456
$L41455:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41456:
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ?Stop@CDirectSoundBuffer@DirectSound@@QAGJXZ ; DirectSound::CDirectSoundBuffer::Stop

; 812  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
_IDirectSoundBuffer_Stop@4 ENDP
DSOUND	ENDS
PUBLIC	?StopEx@CDirectSoundBuffer@DirectSound@@QAGJ_JK@Z ; DirectSound::CDirectSoundBuffer::StopEx
PUBLIC	_IDirectSoundBuffer_StopEx@16
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_StopEx@16
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_rtTimeStamp$ = 12
_dwFlags$ = 20
_IDirectSoundBuffer_StopEx@16 PROC NEAR			; COMDAT

; 815  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 816  : 
; 817  : #ifdef DSAPI_DISABLE_NOTEOFF
; 818  : 
; 819  :     dwFlags = 0;
; 820  : 
; 821  : #endif // DSAPI_DISABLE_NOTEOFF
; 822  : 
; 823  :     return ((CDirectSoundBuffer *)pBuffer)->StopEx(rtTimeStamp, dwFlags);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41460
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41461
$L41460:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41461:
  0001c	8b 4d 14	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR _rtTimeStamp$[ebp+4]
  00023	52		 push	 edx
  00024	8b 45 0c	 mov	 eax, DWORD PTR _rtTimeStamp$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?StopEx@CDirectSoundBuffer@DirectSound@@QAGJ_JK@Z ; DirectSound::CDirectSoundBuffer::StopEx

; 824  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 10 00	 ret	 16			; 00000010H
_IDirectSoundBuffer_StopEx@16 ENDP
DSOUND	ENDS
PUBLIC	?SetPlayRegion@CDirectSoundBuffer@DirectSound@@QAGJKK@Z ; DirectSound::CDirectSoundBuffer::SetPlayRegion
PUBLIC	_IDirectSoundBuffer_SetPlayRegion@12
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_SetPlayRegion@12
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_dwPlayStart$ = 12
_dwPlayLength$ = 16
_IDirectSoundBuffer_SetPlayRegion@12 PROC NEAR		; COMDAT

; 827  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 828  :     return ((CDirectSoundBuffer *)pBuffer)->SetPlayRegion(dwPlayStart, dwPlayLength);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41465
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41466
$L41465:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41466:
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _dwPlayLength$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 0c	 mov	 edx, DWORD PTR _dwPlayStart$[ebp]
  00023	52		 push	 edx
  00024	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?SetPlayRegion@CDirectSoundBuffer@DirectSound@@QAGJKK@Z ; DirectSound::CDirectSoundBuffer::SetPlayRegion

; 829  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
_IDirectSoundBuffer_SetPlayRegion@12 ENDP
DSOUND	ENDS
PUBLIC	?SetLoopRegion@CDirectSoundBuffer@DirectSound@@QAGJKK@Z ; DirectSound::CDirectSoundBuffer::SetLoopRegion
PUBLIC	_IDirectSoundBuffer_SetLoopRegion@12
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_SetLoopRegion@12
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_dwLoopStart$ = 12
_dwLoopLength$ = 16
_IDirectSoundBuffer_SetLoopRegion@12 PROC NEAR		; COMDAT

; 832  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 833  :     return ((CDirectSoundBuffer *)pBuffer)->SetLoopRegion(dwLoopStart, dwLoopLength);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41470
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41471
$L41470:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41471:
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _dwLoopLength$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 0c	 mov	 edx, DWORD PTR _dwLoopStart$[ebp]
  00023	52		 push	 edx
  00024	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?SetLoopRegion@CDirectSoundBuffer@DirectSound@@QAGJKK@Z ; DirectSound::CDirectSoundBuffer::SetLoopRegion

; 834  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
_IDirectSoundBuffer_SetLoopRegion@12 ENDP
DSOUND	ENDS
PUBLIC	?GetStatus@CDirectSoundBuffer@DirectSound@@QAGJPAK@Z ; DirectSound::CDirectSoundBuffer::GetStatus
PUBLIC	_IDirectSoundBuffer_GetStatus@8
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_GetStatus@8
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_pdwStatus$ = 12
_IDirectSoundBuffer_GetStatus@8 PROC NEAR		; COMDAT

; 837  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 838  :     return ((CDirectSoundBuffer *)pBuffer)->GetStatus(pdwStatus);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41475
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41476
$L41475:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41476:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwStatus$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?GetStatus@CDirectSoundBuffer@DirectSound@@QAGJPAK@Z ; DirectSound::CDirectSoundBuffer::GetStatus

; 839  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSoundBuffer_GetStatus@8 ENDP
DSOUND	ENDS
PUBLIC	?GetCurrentPosition@CDirectSoundBuffer@DirectSound@@QAGJPAK0@Z ; DirectSound::CDirectSoundBuffer::GetCurrentPosition
PUBLIC	_IDirectSoundBuffer_GetCurrentPosition@12
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_GetCurrentPosition@12
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_pdwPlayCursor$ = 12
_pdwWriteCursor$ = 16
_IDirectSoundBuffer_GetCurrentPosition@12 PROC NEAR	; COMDAT

; 842  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 843  :     return ((CDirectSoundBuffer *)pBuffer)->GetCurrentPosition(pdwPlayCursor, pdwWriteCursor);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41480
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41481
$L41480:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41481:
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _pdwWriteCursor$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 0c	 mov	 edx, DWORD PTR _pdwPlayCursor$[ebp]
  00023	52		 push	 edx
  00024	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?GetCurrentPosition@CDirectSoundBuffer@DirectSound@@QAGJPAK0@Z ; DirectSound::CDirectSoundBuffer::GetCurrentPosition

; 844  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
_IDirectSoundBuffer_GetCurrentPosition@12 ENDP
DSOUND	ENDS
PUBLIC	?SetCurrentPosition@CDirectSoundBuffer@DirectSound@@QAGJK@Z ; DirectSound::CDirectSoundBuffer::SetCurrentPosition
PUBLIC	_IDirectSoundBuffer_SetCurrentPosition@8
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_SetCurrentPosition@8
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_dwPlayCursor$ = 12
_IDirectSoundBuffer_SetCurrentPosition@8 PROC NEAR	; COMDAT

; 847  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 848  :     return ((CDirectSoundBuffer *)pBuffer)->SetCurrentPosition(dwPlayCursor);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41485
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41486
$L41485:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41486:
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _dwPlayCursor$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?SetCurrentPosition@CDirectSoundBuffer@DirectSound@@QAGJK@Z ; DirectSound::CDirectSoundBuffer::SetCurrentPosition

; 849  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
_IDirectSoundBuffer_SetCurrentPosition@8 ENDP
DSOUND	ENDS
PUBLIC	?SetBufferData@CDirectSoundBuffer@DirectSound@@QAGJPAXK@Z ; DirectSound::CDirectSoundBuffer::SetBufferData
PUBLIC	_IDirectSoundBuffer_SetBufferData@12
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_SetBufferData@12
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_pvBufferData$ = 12
_dwBufferBytes$ = 16
_IDirectSoundBuffer_SetBufferData@12 PROC NEAR		; COMDAT

; 852  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 853  :     return ((CDirectSoundBuffer *)pBuffer)->SetBufferData(pvBufferData, dwBufferBytes);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41490
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41491
$L41490:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41491:
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _dwBufferBytes$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 0c	 mov	 edx, DWORD PTR _pvBufferData$[ebp]
  00023	52		 push	 edx
  00024	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?SetBufferData@CDirectSoundBuffer@DirectSound@@QAGJPAXK@Z ; DirectSound::CDirectSoundBuffer::SetBufferData

; 854  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
_IDirectSoundBuffer_SetBufferData@12 ENDP
DSOUND	ENDS
PUBLIC	?Lock@CDirectSoundBuffer@DirectSound@@QAGJKKPAPAXPAK01K@Z ; DirectSound::CDirectSoundBuffer::Lock
PUBLIC	_IDirectSoundBuffer_Lock@32
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_Lock@32
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_dwOffset$ = 12
_dwBytes$ = 16
_ppvAudioPtr1$ = 20
_pdwAudioBytes1$ = 24
_ppvAudioPtr2$ = 28
_pdwAudioBytes2$ = 32
_dwFlags$ = 36
_IDirectSoundBuffer_Lock@32 PROC NEAR			; COMDAT

; 857  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 858  :     return ((CDirectSoundBuffer *)pBuffer)->Lock(dwOffset, dwBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2, dwFlags);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41495
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41496
$L41495:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41496:
  0001c	8b 4d 24	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 20	 mov	 edx, DWORD PTR _pdwAudioBytes2$[ebp]
  00023	52		 push	 edx
  00024	8b 45 1c	 mov	 eax, DWORD PTR _ppvAudioPtr2$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 18	 mov	 ecx, DWORD PTR _pdwAudioBytes1$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 14	 mov	 edx, DWORD PTR _ppvAudioPtr1$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 10	 mov	 eax, DWORD PTR _dwBytes$[ebp]
  00033	50		 push	 eax
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _dwOffset$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ?Lock@CDirectSoundBuffer@DirectSound@@QAGJKKPAPAXPAK01K@Z ; DirectSound::CDirectSoundBuffer::Lock

; 859  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 20 00	 ret	 32			; 00000020H
_IDirectSoundBuffer_Lock@32 ENDP
DSOUND	ENDS
PUBLIC	?SetNotificationPositions@CDirectSoundBuffer@DirectSound@@QAGJKPBU_DSBPOSITIONNOTIFY@@@Z ; DirectSound::CDirectSoundBuffer::SetNotificationPositions
PUBLIC	_IDirectSoundBuffer_SetNotificationPositions@12
; Function compile flags: /Odt
;	COMDAT _IDirectSoundBuffer_SetNotificationPositions@12
DSOUND	SEGMENT
tv66 = -4
_pBuffer$ = 8
_dwNotifyCount$ = 12
_paNotifies$ = 16
_IDirectSoundBuffer_SetNotificationPositions@12 PROC NEAR ; COMDAT

; 862  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 863  :     return ((CDirectSoundBuffer *)pBuffer)->SetNotificationPositions(dwNotifyCount, paNotifies);

  00004	83 7d 08 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00008	74 0b		 je	 SHORT $L41500
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0000d	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	eb 07		 jmp	 SHORT $L41501
$L41500:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41501:
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _paNotifies$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 0c	 mov	 edx, DWORD PTR _dwNotifyCount$[ebp]
  00023	52		 push	 edx
  00024	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?SetNotificationPositions@CDirectSoundBuffer@DirectSound@@QAGJKPBU_DSBPOSITIONNOTIFY@@@Z ; DirectSound::CDirectSoundBuffer::SetNotificationPositions

; 864  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
_IDirectSoundBuffer_SetNotificationPositions@12 ENDP
DSOUND	ENDS
PUBLIC	??0CDirectSound@DirectSound@@QAE@XZ		; DirectSound::CDirectSound::CDirectSound
PUBLIC	?Initialize@CDirectSound@DirectSound@@QAGJXZ	; DirectSound::CDirectSound::Initialize
PUBLIC	?DirectSoundCreateInternal@@YGJPAPAVCDirectSound@DirectSound@@@Z ; DirectSoundCreateInternal
PUBLIC	?__AddRef@DirectSound@@YGPAVCDirectSound@1@PAV21@@Z ; DirectSound::__AddRef
; Function compile flags: /Odt
;	COMDAT ?DirectSoundCreateInternal@@YGJPAPAVCDirectSound@DirectSound@@@Z
DSOUND	SEGMENT
tv72 = -16
$T41505 = -12
_hr$ = -8
_pDirectSound$ = -4
_ppDirectSound$ = 8
?DirectSoundCreateInternal@@YGJPAPAVCDirectSound@DirectSound@@@Z PROC NEAR ; DirectSoundCreateInternal, COMDAT

; 1304 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1305 :     CDirectSound *          pDirectSound    = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pDirectSound$[ebp], 0

; 1306 :     HRESULT                 hr              = DS_OK;

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1307 :     
; 1308 :     DPF_ENTER();
; 1309 : 
; 1310 :     //
; 1311 :     // Check to see if the DirectSound object already exists
; 1312 :     //
; 1313 : 
; 1314 :     if(CDirectSound::m_pDirectSound)

  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pDirectSound@CDirectSound@DirectSound@@2PAV12@A, 0 ; DirectSound::CDirectSound::m_pDirectSound
  0001b	74 12		 je	 SHORT $L36359

; 1315 :     {
; 1316 :         *ppDirectSound = ADDREF(CDirectSound::m_pDirectSound);

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pDirectSound@CDirectSound@DirectSound@@2PAV12@A ; DirectSound::CDirectSound::m_pDirectSound
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCDirectSound@1@PAV21@@Z ; DirectSound::__AddRef
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _ppDirectSound$[ebp]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax

; 1317 :     }
; 1318 :     else

  0002d	eb 7a		 jmp	 SHORT $L36364
$L36359:

; 1319 :     {
; 1320 :         hr = HRFROMP(pDirectSound = NEW(CDirectSound));

  0002f	6a 28		 push	 40			; 00000028H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00036	83 c4 04	 add	 esp, 4
  00039	89 45 f4	 mov	 DWORD PTR $T41505[ebp], eax
  0003c	83 7d f4 00	 cmp	 DWORD PTR $T41505[ebp], 0
  00040	74 0d		 je	 SHORT $L41506
  00042	8b 4d f4	 mov	 ecx, DWORD PTR $T41505[ebp]
  00045	e8 00 00 00 00	 call	 ??0CDirectSound@DirectSound@@QAE@XZ ; DirectSound::CDirectSound::CDirectSound
  0004a	89 45 f0	 mov	 DWORD PTR tv72[ebp], eax
  0004d	eb 07		 jmp	 SHORT $L41507
$L41506:
  0004f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L41507:
  00056	8b 55 f0	 mov	 edx, DWORD PTR tv72[ebp]
  00059	89 55 fc	 mov	 DWORD PTR _pDirectSound$[ebp], edx
  0005c	33 c0		 xor	 eax, eax
  0005e	83 7d fc 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00062	0f 95 c0	 setne	 al
  00065	48		 dec	 eax
  00066	25 0e 00 07 80	 and	 eax, -2147024882	; 8007000eH
  0006b	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1321 : 
; 1322 :         if(SUCCEEDED(hr))

  0006e	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00072	7c 0c		 jl	 SHORT $L36370

; 1323 :         {
; 1324 :             hr = pDirectSound->Initialize();

  00074	8b 4d fc	 mov	 ecx, DWORD PTR _pDirectSound$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?Initialize@CDirectSound@DirectSound@@QAGJXZ ; DirectSound::CDirectSound::Initialize
  0007d	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L36370:

; 1325 :         }
; 1326 : 
; 1327 :         if(SUCCEEDED(hr))

  00080	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00084	7c 0a		 jl	 SHORT $L36372

; 1328 :         {
; 1329 :             *ppDirectSound = pDirectSound;

  00086	8b 55 08	 mov	 edx, DWORD PTR _ppDirectSound$[ebp]
  00089	8b 45 fc	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0008c	89 02		 mov	 DWORD PTR [edx], eax

; 1330 :         }
; 1331 :         else

  0008e	eb 19		 jmp	 SHORT $L36364
$L36372:

; 1332 :         {
; 1333 :             RELEASE(pDirectSound);

  00090	83 7d fc 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00094	74 13		 je	 SHORT $L36364
  00096	8b 4d fc	 mov	 ecx, DWORD PTR _pDirectSound$[ebp]
  00099	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009b	8b 45 fc	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0009e	50		 push	 eax
  0009f	ff 52 08	 call	 DWORD PTR [edx+8]
  000a2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pDirectSound$[ebp], 0
$L36364:

; 1334 :         }
; 1335 :     }
; 1336 : 
; 1337 :     DPF_LEAVE_HRESULT(hr);
; 1338 : 
; 1339 :     return hr;

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1340 : }

  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
?DirectSoundCreateInternal@@YGJPAPAVCDirectSound@DirectSound@@@Z ENDP ; DirectSoundCreateInternal
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\memmgr.h
DSOUND	ENDS
;	COMDAT ??2@YAPAXI@Z
DSOUND	SEGMENT
_cbBuffer$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 220  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 221  :     return DirectSound::CMemoryManager::TrackingMemAlloc("(none)", 0, "(unknown)", DSOUND_OBJECT_POOL_TAG, cbBuffer, TRUE); 

  00003	6a 01		 push	 1
  00005	8b 45 08	 mov	 eax, DWORD PTR _cbBuffer$[ebp]
  00008	50		 push	 eax
  00009	68 44 53 6f 62	 push	 1651462980		; 626f5344H
  0000e	e8 00 00 00 00	 call	 ?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::MemAlloc

; 222  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??2@YAPAXI@Z ENDP					; operator new
DSOUND	ENDS
PUBLIC	_DirectSoundCreate@12
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _DirectSoundCreate@12
DSOUND	SEGMENT
tv72 = -20
$T41516 = -16
___AutoLock$ = -12
_hr$ = -8
_pDirectSound$ = -4
_pguidDeviceId$ = 8
_ppDirectSound$ = 12
_pControllingUnknown$ = 16
_DirectSoundCreate@12 PROC NEAR				; COMDAT

; 1371 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1372 :     CDirectSound *  pDirectSound;
; 1373 :     HRESULT                         hr;
; 1374 :     
; 1375 :     DPF_ENTER();
; 1376 :     ENTER_EXTERNAL_FUNCTION();

  00006	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock

; 1377 : 
; 1378 : #ifdef VALIDATE_PARAMETERS
; 1379 : 
; 1380 :     if(!IS_NULL_GUID(*pguidDeviceId))
; 1381 :     {
; 1382 :         DPF_ERROR("NULL or GUID_NULL is the only supported device identifier");
; 1383 :     }
; 1384 : 
; 1385 :     if(!ppDirectSound)
; 1386 :     {
; 1387 :         DPF_ERROR("Failed to supply an LPDIRECTSOUND *");
; 1388 :     }
; 1389 :     
; 1390 :     if(pControllingUnknown)
; 1391 :     {
; 1392 :         DPF_ERROR("Aggregation is not supported");
; 1393 :     }
; 1394 : 
; 1395 : #endif // VALIDATE_PARAMETERS
; 1396 : 
; 1397 :     hr = DirectSoundCreateInternal(&pDirectSound);

  0000e	8d 45 fc	 lea	 eax, DWORD PTR _pDirectSound$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?DirectSoundCreateInternal@@YGJPAPAVCDirectSound@DirectSound@@@Z ; DirectSoundCreateInternal
  00017	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1398 : 
; 1399 :     if(SUCCEEDED(hr))

  0001a	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0001e	7c 20		 jl	 SHORT $L36384

; 1400 :     {
; 1401 :         *ppDirectSound = pDirectSound;

  00020	83 7d fc 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00024	74 0b		 je	 SHORT $L41514
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _pDirectSound$[ebp]
  00029	83 c1 08	 add	 ecx, 8
  0002c	89 4d ec	 mov	 DWORD PTR tv72[ebp], ecx
  0002f	eb 07		 jmp	 SHORT $L41515
$L41514:
  00031	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L41515:
  00038	8b 55 0c	 mov	 edx, DWORD PTR _ppDirectSound$[ebp]
  0003b	8b 45 ec	 mov	 eax, DWORD PTR tv72[ebp]
  0003e	89 02		 mov	 DWORD PTR [edx], eax
$L36384:

; 1402 :     }
; 1403 : 
; 1404 :     DPF_LEAVE_HRESULT(hr);
; 1405 : 
; 1406 :     return hr;

  00040	8b 4d f8	 mov	 ecx, DWORD PTR _hr$[ebp]
  00043	89 4d f0	 mov	 DWORD PTR $T41516[ebp], ecx
  00046	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00049	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0004e	8b 45 f0	 mov	 eax, DWORD PTR $T41516[ebp]

; 1407 : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 0c 00	 ret	 12			; 0000000cH
_DirectSoundCreate@12 ENDP
DSOUND	ENDS
PUBLIC	_DirectSoundCreateBuffer@8
; Function compile flags: /Odt
;	COMDAT _DirectSoundCreateBuffer@8
DSOUND	SEGMENT
$T41520 = -16
___AutoLock$ = -12
_hr$ = -8
_pDirectSound$ = -4
_pdsbd$ = 8
_ppBuffer$ = 12
_DirectSoundCreateBuffer@8 PROC NEAR			; COMDAT

; 1437 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1438 :     CDirectSound *  pDirectSound    = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pDirectSound$[ebp], 0

; 1439 :     HRESULT                         hr;
; 1440 :     
; 1441 :     DPF_ENTER();
; 1442 :     ENTER_EXTERNAL_FUNCTION();

  0000d	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00010	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock

; 1443 : 
; 1444 :     hr = DirectSoundCreateInternal(&pDirectSound);

  00015	8d 45 fc	 lea	 eax, DWORD PTR _pDirectSound$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?DirectSoundCreateInternal@@YGJPAPAVCDirectSound@DirectSound@@@Z ; DirectSoundCreateInternal
  0001e	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1445 : 
; 1446 :     if(SUCCEEDED(hr))

  00021	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00025	7c 16		 jl	 SHORT $L36394

; 1447 :     {
; 1448 :         hr = pDirectSound->CreateSoundBuffer(pdsbd, ppBuffer, NULL);

  00027	6a 00		 push	 0
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _ppBuffer$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 55 08	 mov	 edx, DWORD PTR _pdsbd$[ebp]
  00030	52		 push	 edx
  00031	8b 45 fc	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ?CreateSoundBuffer@CDirectSound@DirectSound@@QAGJPBU_DSBUFFERDESC@@PAPAUIDirectSoundBuffer@@PAUIUnknown@@@Z ; DirectSound::CDirectSound::CreateSoundBuffer
  0003a	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L36394:

; 1449 :     }
; 1450 : 
; 1451 :     RELEASE(pDirectSound);

  0003d	83 7d fc 00	 cmp	 DWORD PTR _pDirectSound$[ebp], 0
  00041	74 13		 je	 SHORT $L36395
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _pDirectSound$[ebp]
  00046	8b 11		 mov	 edx, DWORD PTR [ecx]
  00048	8b 45 fc	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0004b	50		 push	 eax
  0004c	ff 52 08	 call	 DWORD PTR [edx+8]
  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pDirectSound$[ebp], 0
$L36395:

; 1452 : 
; 1453 :     DPF_LEAVE_HRESULT(hr);
; 1454 : 
; 1455 :     return hr;

  00056	8b 4d f8	 mov	 ecx, DWORD PTR _hr$[ebp]
  00059	89 4d f0	 mov	 DWORD PTR $T41520[ebp], ecx
  0005c	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0005f	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00064	8b 45 f0	 mov	 eax, DWORD PTR $T41520[ebp]

; 1456 : }

  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
_DirectSoundCreateBuffer@8 ENDP
DSOUND	ENDS
PUBLIC	_DirectSoundDoWork@0
PUBLIC	?DoWork@CDirectSound@DirectSound@@QAGXXZ	; DirectSound::CDirectSound::DoWork
; Function compile flags: /Odt
;	COMDAT _DirectSoundDoWork@0
DSOUND	SEGMENT
___AutoLock$ = -4
_DirectSoundDoWork@0 PROC NEAR				; COMDAT

; 1535 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1536 :     DPF_ENTER();
; 1537 :     ENTER_EXTERNAL_FUNCTION();

  00004	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00007	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock

; 1538 : 
; 1539 :     ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
; 1540 : 
; 1541 : #ifdef DEBUG
; 1542 : 
; 1543 :     //
; 1544 :     // Check for a deferred breakpoint
; 1545 :     //
; 1546 : 
; 1547 :     if(INTERLOCKED_EXCHANGE(g_fDirectSoundDebugBreak, FALSE))
; 1548 :     {
; 1549 :         DPF_ABSOLUTE("A breakpoint occurred at raised IRQL.  If you're running the Visual C debugger, you probably missed it.");
; 1550 :         BREAK();
; 1551 :     }
; 1552 : 
; 1553 : #endif // DEBUG
; 1554 : 
; 1555 :     //
; 1556 :     // Workie, workie
; 1557 :     //
; 1558 : 
; 1559 :     if(CDirectSound::m_pDirectSound)

  0000c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pDirectSound@CDirectSound@DirectSound@@2PAV12@A, 0 ; DirectSound::CDirectSound::m_pDirectSound
  00013	74 0b		 je	 SHORT $L36401

; 1560 :     {
; 1561 :         CDirectSound::m_pDirectSound->DoWork();

  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pDirectSound@CDirectSound@DirectSound@@2PAV12@A ; DirectSound::CDirectSound::m_pDirectSound
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?DoWork@CDirectSound@DirectSound@@QAGXXZ ; DirectSound::CDirectSound::DoWork
$L36401:

; 1562 :     }
; 1563 : 
; 1564 :     DPF_LEAVE_VOID();
; 1565 : }

  00020	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00023	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
_DirectSoundDoWork@0 ENDP
DSOUND	ENDS
PUBLIC	_DirectSoundGetSampleTime@0
; Function compile flags: /Odt
;	COMDAT _DirectSoundGetSampleTime@0
DSOUND	SEGMENT
_dwSampleTime$ = -4
_DirectSoundGetSampleTime@0 PROC NEAR			; COMDAT

; 1591 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1592 :     DWORD                   dwSampleTime;
; 1593 :     
; 1594 :     DPF_ENTER();    
; 1595 : 
; 1596 :     //
; 1597 :     // MASSIVE HACK
; 1598 :     //
; 1599 :     // In order to keep latency and overhead to an absolute minimum, we're 
; 1600 :     // going to read the MCPX sample clock register from here.  This will 
; 1601 :     // prevent us from having to take the critical section or raise IRQL.
; 1602 :     //
; 1603 :     // If the DirectSound object hasn't been created, the sample counter
; 1604 :     // can't be trusted.
; 1605 :     //
; 1606 : 
; 1607 :     if(CDirectSound::m_pDirectSound)

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pDirectSound@CDirectSound@DirectSound@@2PAV12@A, 0 ; DirectSound::CDirectSound::m_pDirectSound
  0000b	74 0a		 je	 SHORT $L36406

; 1608 :     {
; 1609 :         MCPX_REG_READ(NV_PAPU_XGSCNT, &dwSampleTime);

  0000d	a1 0c 20 80 fe	 mov	 eax, DWORD PTR ds:-25157620
  00012	89 45 fc	 mov	 DWORD PTR _dwSampleTime$[ebp], eax

; 1610 :     }
; 1611 :     else

  00015	eb 07		 jmp	 SHORT $L36408
$L36406:

; 1612 :     {
; 1613 :         dwSampleTime = 0;

  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwSampleTime$[ebp], 0
$L36408:

; 1614 :     }
; 1615 : 
; 1616 :     DPF_LEAVE(dwSampleTime);
; 1617 : 
; 1618 :     return dwSampleTime;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _dwSampleTime$[ebp]

; 1619 : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_DirectSoundGetSampleTime@0 ENDP
DSOUND	ENDS
PUBLIC	_XAudioCalculatePitch@4
PUBLIC	??0CAutoFpState@DirectSound@@QAE@XZ		; DirectSound::CAutoFpState::CAutoFpState
PUBLIC	??1CAutoFpState@DirectSound@@QAE@XZ		; DirectSound::CAutoFpState::~CAutoFpState
PUBLIC	__real@37aec33e
EXTRN	?RatioToPitch@Math@DirectSound@@YGJM@Z:NEAR	; DirectSound::Math::RatioToPitch
EXTRN	__fltused:NEAR
;	COMDAT __real@37aec33e
CONST	SEGMENT
__real@37aec33e DD 037aec33er			; 2.08333e-005
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT _XAudioCalculatePitch@4
DSOUND	SEGMENT
tv73 = -20
$T41530 = -12
___AutoFpState$ = -5
_lPitch$ = -4
_dwFrequency$ = 8
_XAudioCalculatePitch@4 PROC NEAR			; COMDAT

; 1963 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1964 :     LONG                    lPitch;
; 1965 :    
; 1966 :     DPF_ENTER();
; 1967 :     AutoFpState();

  00006	8d 4d fb	 lea	 ecx, DWORD PTR ___AutoFpState$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoFpState@DirectSound@@QAE@XZ ; DirectSound::CAutoFpState::CAutoFpState

; 1968 : 
; 1969 : #ifdef VALIDATE_PARAMETERS
; 1970 : 
; 1971 :     if((dwFrequency < DSBFREQUENCY_MIN) || (dwFrequency > DSBFREQUENCY_MAX))
; 1972 :     {
; 1973 :         DPF_ERROR("Invalid frequency value");
; 1974 :     }
; 1975 : 
; 1976 : #endif // VALIDATE_PARAMETERS
; 1977 : 
; 1978 :     if(MCPX_BASEFREQ == dwFrequency)

  0000e	81 7d 08 80 bb
	00 00		 cmp	 DWORD PTR _dwFrequency$[ebp], 48000 ; 0000bb80H
  00015	75 09		 jne	 SHORT $L36414

; 1979 :     {
; 1980 :         lPitch = 0;

  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lPitch$[ebp], 0

; 1981 :     }
; 1982 :     else

  0001e	eb 22		 jmp	 SHORT $L36415
$L36414:

; 1983 :     {
; 1984 :         lPitch = RatioToPitch((FLOAT)dwFrequency * MCPX_ONEOVERBASEFREQ);

  00020	8b 45 08	 mov	 eax, DWORD PTR _dwFrequency$[ebp]
  00023	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv73[ebp+4], 0
  0002d	df 6d ec	 fild	 QWORD PTR tv73[ebp]
  00030	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@37aec33e
  00036	51		 push	 ecx
  00037	d9 1c 24	 fstp	 DWORD PTR [esp]
  0003a	e8 00 00 00 00	 call	 ?RatioToPitch@Math@DirectSound@@YGJM@Z ; DirectSound::Math::RatioToPitch
  0003f	89 45 fc	 mov	 DWORD PTR _lPitch$[ebp], eax
$L36415:

; 1985 :     }
; 1986 : 
; 1987 :     DPF_LEAVE(lPitch);
; 1988 : 
; 1989 :     return lPitch;

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _lPitch$[ebp]
  00045	89 4d f4	 mov	 DWORD PTR $T41530[ebp], ecx
  00048	8d 4d fb	 lea	 ecx, DWORD PTR ___AutoFpState$[ebp]
  0004b	e8 00 00 00 00	 call	 ??1CAutoFpState@DirectSound@@QAE@XZ ; DirectSound::CAutoFpState::~CAutoFpState
  00050	8b 45 f4	 mov	 eax, DWORD PTR $T41530[ebp]

; 1990 : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
_XAudioCalculatePitch@4 ENDP
DSOUND	ENDS
PUBLIC	?Save@CFpState@DirectSound@@QAEXXZ		; DirectSound::CFpState::Save
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\drvhlp.h
;	COMDAT ??0CAutoFpState@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CAutoFpState@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CAutoFpState::CAutoFpState, COMDAT
; _this$ = ecx

; 145  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 146  :         Save();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Save@CFpState@DirectSound@@QAEXXZ ; DirectSound::CFpState::Save

; 147  :     }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CAutoFpState@DirectSound@@QAE@XZ ENDP		; DirectSound::CAutoFpState::CAutoFpState
DSOUND	ENDS
EXTRN	__imp__KeSaveFloatingPointState@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Save@CFpState@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Save@CFpState@DirectSound@@QAEXXZ PROC NEAR		; DirectSound::CFpState::Save, COMDAT
; _this$ = ecx

; 108  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  :         if(KeIsExecutingDpc())

  00007	e8 00 00 00 00	 call	 _KeIsExecutingDpc@0
  0000c	85 c0		 test	 eax, eax
  0000e	74 23		 je	 SHORT $L30165

; 110  :         {
; 111  :             if(!m_dwRefCount++)

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwRefCount@CFpState@DirectSound@@0KA ; DirectSound::CFpState::m_dwRefCount
  00015	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwRefCount@CFpState@DirectSound@@0KA ; DirectSound::CFpState::m_dwRefCount
  0001b	83 c1 01	 add	 ecx, 1
  0001e	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_dwRefCount@CFpState@DirectSound@@0KA, ecx ; DirectSound::CFpState::m_dwRefCount
  00024	85 c0		 test	 eax, eax
  00026	75 0b		 jne	 SHORT $L30165

; 112  :             {
; 113  :                 KeSaveFloatingPointState(&m_fps);

  00028	68 00 00 00 00	 push	 OFFSET FLAT:?m_fps@CFpState@DirectSound@@0U_KFLOATING_SAVE@@A ; DirectSound::CFpState::m_fps
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSaveFloatingPointState@4
$L30165:

; 114  :             }
; 115  :         }
; 116  :     }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?Save@CFpState@DirectSound@@QAEXXZ ENDP			; DirectSound::CFpState::Save
; Function compile flags: /Odt
; File c:\xbox\private\ntos\inc\i386.h
DSOUND	ENDS
;	COMDAT _KeIsExecutingDpc@0
DSOUND	SEGMENT
_KeIsExecutingDpc@0 PROC NEAR				; COMDAT

; 1524 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1525 : #if defined(_NTSYSTEM_)
; 1526 :     return KeGetCurrentPrcb()->DpcRoutineActive;
; 1527 : #else
; 1528 :     __asm {  mov eax, fs:[0] KPCR.PrcbData.DpcRoutineActive }

  00003	64 a1 58 00 00
	00		 mov	 eax, DWORD PTR fs:88

; 1529 : #endif
; 1530 : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
_KeIsExecutingDpc@0 ENDP
DSOUND	ENDS
PUBLIC	?Restore@CFpState@DirectSound@@QAEXXZ		; DirectSound::CFpState::Restore
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\drvhlp.h
;	COMDAT ??1CAutoFpState@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CAutoFpState@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CAutoFpState::~CAutoFpState, COMDAT
; _this$ = ecx

; 150  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 151  :         Restore();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Restore@CFpState@DirectSound@@QAEXXZ ; DirectSound::CFpState::Restore

; 152  :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CAutoFpState@DirectSound@@QAE@XZ ENDP		; DirectSound::CAutoFpState::~CAutoFpState
DSOUND	ENDS
EXTRN	__imp__KeRestoreFloatingPointState@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Restore@CFpState@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Restore@CFpState@DirectSound@@QAEXXZ PROC NEAR		; DirectSound::CFpState::Restore, COMDAT
; _this$ = ecx

; 119  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 120  :         if(KeIsExecutingDpc())

  00007	e8 00 00 00 00	 call	 _KeIsExecutingDpc@0
  0000c	85 c0		 test	 eax, eax
  0000e	74 21		 je	 SHORT $L30171

; 121  :         {
; 122  :             if(!--m_dwRefCount)

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwRefCount@CFpState@DirectSound@@0KA ; DirectSound::CFpState::m_dwRefCount
  00015	83 e8 01	 sub	 eax, 1
  00018	a3 00 00 00 00	 mov	 DWORD PTR ?m_dwRefCount@CFpState@DirectSound@@0KA, eax ; DirectSound::CFpState::m_dwRefCount
  0001d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_dwRefCount@CFpState@DirectSound@@0KA, 0 ; DirectSound::CFpState::m_dwRefCount
  00024	75 0b		 jne	 SHORT $L30171

; 123  :             {
; 124  :                 KeRestoreFloatingPointState(&m_fps);

  00026	68 00 00 00 00	 push	 OFFSET FLAT:?m_fps@CFpState@DirectSound@@0U_KFLOATING_SAVE@@A ; DirectSound::CFpState::m_fps
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeRestoreFloatingPointState@4
$L30171:

; 125  :             }
; 126  :         }
; 127  :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?Restore@CFpState@DirectSound@@QAEXXZ ENDP		; DirectSound::CFpState::Restore
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
DSOUND	ENDS
;	COMDAT _XAudioCreatePcmFormat@16
DSOUND	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_wBitsPerSample$ = 16
_pwfx$ = 20
_XAudioCreatePcmFormat@16 PROC NEAR			; COMDAT

; 2022 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2023 :     DPF_ENTER();
; 2024 :     
; 2025 :     CreatePcmFormat(nChannels, nSamplesPerSec, wBitsPerSample, pwfx);

  00003	8b 45 14	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	50		 push	 eax
  00007	66 8b 4d 10	 mov	 cx, WORD PTR _wBitsPerSample$[ebp]
  0000b	51		 push	 ecx
  0000c	8b 55 0c	 mov	 edx, DWORD PTR _nSamplesPerSec$[ebp]
  0000f	52		 push	 edx
  00010	66 8b 45 08	 mov	 ax, WORD PTR _nChannels$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?CreatePcmFormat@WaveFormat@DirectSound@@YGXGKGPAUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::CreatePcmFormat

; 2026 : 
; 2027 :     DPF_LEAVE_VOID();
; 2028 : }

  0001a	5d		 pop	 ebp
  0001b	c2 10 00	 ret	 16			; 00000010H
_XAudioCreatePcmFormat@16 ENDP
DSOUND	ENDS
PUBLIC	_XAudioCreateAdpcmFormat@12
; Function compile flags: /Odt
;	COMDAT _XAudioCreateAdpcmFormat@12
DSOUND	SEGMENT
_nChannels$ = 8
_nSamplesPerSec$ = 12
_pwfx$ = 16
_XAudioCreateAdpcmFormat@12 PROC NEAR			; COMDAT

; 2058 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2059 :     DPF_ENTER();
; 2060 :     
; 2061 :     CreateXboxAdpcmFormat(nChannels, nSamplesPerSec, pwfx);

  00003	8b 45 10	 mov	 eax, DWORD PTR _pwfx$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _nSamplesPerSec$[ebp]
  0000a	51		 push	 ecx
  0000b	66 8b 55 08	 mov	 dx, WORD PTR _nChannels$[ebp]
  0000f	52		 push	 edx
  00010	e8 00 00 00 00	 call	 ?CreateXboxAdpcmFormat@WaveFormat@DirectSound@@YGXGKPAUxbox_adpcmwaveformat_tag@@@Z ; DirectSound::WaveFormat::CreateXboxAdpcmFormat

; 2062 : 
; 2063 :     DPF_LEAVE_VOID();
; 2064 : }

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
_XAudioCreateAdpcmFormat@12 ENDP
DSOUND	ENDS
PUBLIC	?Initialize@CWaveFileMediaObject@DirectSound@@QAGJPBD@Z ; DirectSound::CWaveFileMediaObject::Initialize
PUBLIC	_XWaveFileCreateMediaObject@12
PUBLIC	?__AddRef@DirectSound@@YGPAVCWaveFileMediaObject@1@PAV21@@Z ; DirectSound::__AddRef
EXTRN	??0CWaveFileMediaObject@DirectSound@@QAE@XZ:NEAR ; DirectSound::CWaveFileMediaObject::CWaveFileMediaObject
; Function compile flags: /Odt
;	COMDAT _XWaveFileCreateMediaObject@12
DSOUND	SEGMENT
tv69 = -16
$T41558 = -12
_hr$ = -8
_pMediaObject$ = -4
_pszFileName$ = 8
_ppwfxFormat$ = 12
_ppMediaObject$ = 16
_XWaveFileCreateMediaObject@12 PROC NEAR		; COMDAT

; 2255 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2256 :     CWaveFileMediaObject *  pMediaObject;
; 2257 :     HRESULT                 hr;
; 2258 : 
; 2259 :     DPF_ENTER();
; 2260 : 
; 2261 : #ifdef VALIDATE_PARAMETERS
; 2262 : 
; 2263 :     if(!pszFileName)
; 2264 :     {
; 2265 :         DPF_ERROR("No file name specified");
; 2266 :     }
; 2267 : 
; 2268 :     if(!ppMediaObject)
; 2269 :     {
; 2270 :         DPF_ERROR("No media object pointer supplied");
; 2271 :     }
; 2272 : 
; 2273 : #endif // VALIDATE_PARAMETERS
; 2274 :     
; 2275 :     hr = HRFROMP(pMediaObject = NEW(CWaveFileMediaObject));

  00006	6a 50		 push	 80			; 00000050H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	83 c4 04	 add	 esp, 4
  00010	89 45 f4	 mov	 DWORD PTR $T41558[ebp], eax
  00013	83 7d f4 00	 cmp	 DWORD PTR $T41558[ebp], 0
  00017	74 0d		 je	 SHORT $L41559
  00019	8b 4d f4	 mov	 ecx, DWORD PTR $T41558[ebp]
  0001c	e8 00 00 00 00	 call	 ??0CWaveFileMediaObject@DirectSound@@QAE@XZ ; DirectSound::CWaveFileMediaObject::CWaveFileMediaObject
  00021	89 45 f0	 mov	 DWORD PTR tv69[ebp], eax
  00024	eb 07		 jmp	 SHORT $L41560
$L41559:
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L41560:
  0002d	8b 45 f0	 mov	 eax, DWORD PTR tv69[ebp]
  00030	89 45 fc	 mov	 DWORD PTR _pMediaObject$[ebp], eax
  00033	33 c9		 xor	 ecx, ecx
  00035	83 7d fc 00	 cmp	 DWORD PTR _pMediaObject$[ebp], 0
  00039	0f 95 c1	 setne	 cl
  0003c	49		 dec	 ecx
  0003d	81 e1 0e 00 07
	80		 and	 ecx, -2147024882	; 8007000eH
  00043	89 4d f8	 mov	 DWORD PTR _hr$[ebp], ecx

; 2276 : 
; 2277 :     if(SUCCEEDED(hr))

  00046	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004a	7c 10		 jl	 SHORT $L36441

; 2278 :     {
; 2279 :         hr = pMediaObject->Initialize(pszFileName);

  0004c	8b 55 08	 mov	 edx, DWORD PTR _pszFileName$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 fc	 mov	 eax, DWORD PTR _pMediaObject$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?Initialize@CWaveFileMediaObject@DirectSound@@QAGJPBD@Z ; DirectSound::CWaveFileMediaObject::Initialize
  00059	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L36441:

; 2280 :     }
; 2281 : 
; 2282 :     if(SUCCEEDED(hr) && ppwfxFormat)

  0005c	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00060	7c 19		 jl	 SHORT $L36443
  00062	83 7d 0c 00	 cmp	 DWORD PTR _ppwfxFormat$[ebp], 0
  00066	74 13		 je	 SHORT $L36443

; 2283 :     {
; 2284 :         hr = pMediaObject->GetFormat(ppwfxFormat);

  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _ppwfxFormat$[ebp]
  0006b	51		 push	 ecx
  0006c	8b 55 fc	 mov	 edx, DWORD PTR _pMediaObject$[ebp]
  0006f	8b 02		 mov	 eax, DWORD PTR [edx]
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _pMediaObject$[ebp]
  00074	51		 push	 ecx
  00075	ff 50 24	 call	 DWORD PTR [eax+36]
  00078	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L36443:

; 2285 :     }
; 2286 : 
; 2287 :     if(SUCCEEDED(hr))

  0007b	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0007f	7c 0e		 jl	 SHORT $L36445

; 2288 :     {
; 2289 :         *ppMediaObject = ADDREF(pMediaObject);

  00081	8b 55 fc	 mov	 edx, DWORD PTR _pMediaObject$[ebp]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCWaveFileMediaObject@1@PAV21@@Z ; DirectSound::__AddRef
  0008a	8b 4d 10	 mov	 ecx, DWORD PTR _ppMediaObject$[ebp]
  0008d	89 01		 mov	 DWORD PTR [ecx], eax
$L36445:

; 2290 :     }
; 2291 : 
; 2292 :     RELEASE(pMediaObject);

  0008f	83 7d fc 00	 cmp	 DWORD PTR _pMediaObject$[ebp], 0
  00093	74 13		 je	 SHORT $L36450
  00095	8b 55 fc	 mov	 edx, DWORD PTR _pMediaObject$[ebp]
  00098	8b 02		 mov	 eax, DWORD PTR [edx]
  0009a	8b 4d fc	 mov	 ecx, DWORD PTR _pMediaObject$[ebp]
  0009d	51		 push	 ecx
  0009e	ff 50 04	 call	 DWORD PTR [eax+4]
  000a1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pMediaObject$[ebp], 0
$L36450:

; 2293 : 
; 2294 :     DPF_LEAVE_HRESULT(hr);
; 2295 : 
; 2296 :     return hr;

  000a8	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 2297 : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 0c 00	 ret	 12			; 0000000cH
_XWaveFileCreateMediaObject@12 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\wavexmo.h
DSOUND	ENDS
;	COMDAT ?Initialize@CWaveFileMediaObject@DirectSound@@QAGJPBD@Z
DSOUND	SEGMENT
_this$ = 8
_pszFileName$ = 12
?Initialize@CWaveFileMediaObject@DirectSound@@QAGJPBD@Z PROC NEAR ; DirectSound::CWaveFileMediaObject::Initialize, COMDAT

; 71   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :         return CWaveFile::Open(pszFileName, NULL);

  00003	6a 00		 push	 0
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000f	e8 00 00 00 00	 call	 ?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z ; WaveLoader::CWaveFile::Open

; 73   :     }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
?Initialize@CWaveFileMediaObject@DirectSound@@QAGJPBD@Z ENDP ; DirectSound::CWaveFileMediaObject::Initialize
DSOUND	ENDS
PUBLIC	?Initialize@CWaveFileMediaObject@DirectSound@@QAGJPAX@Z ; DirectSound::CWaveFileMediaObject::Initialize
PUBLIC	_XWaveFileCreateMediaObjectEx@12
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _XWaveFileCreateMediaObjectEx@12
DSOUND	SEGMENT
tv69 = -16
$T41567 = -12
_hr$ = -8
_pMediaObject$ = -4
_pszFileName$ = 8
_hFile$ = 12
_ppMediaObject$ = 16
_XWaveFileCreateMediaObjectEx@12 PROC NEAR		; COMDAT

; 2330 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2331 :     CWaveFileMediaObject *  pMediaObject;
; 2332 :     HRESULT                 hr;
; 2333 : 
; 2334 :     DPF_ENTER();
; 2335 :     
; 2336 : #ifdef VALIDATE_PARAMETERS
; 2337 : 
; 2338 :     if(!pszFileName && !IS_VALID_HANDLE_VALUE(hFile))
; 2339 :     {
; 2340 :         DPF_ERROR("No file name or handle specified");
; 2341 :     }
; 2342 : 
; 2343 :     if(pszFileName && IS_VALID_HANDLE_VALUE(hFile))
; 2344 :     {
; 2345 :         DPF_ERROR("Both file name and handle specified");
; 2346 :     }
; 2347 : 
; 2348 :     if(!ppMediaObject)
; 2349 :     {
; 2350 :         DPF_ERROR("No media object pointer supplied");
; 2351 :     }
; 2352 : 
; 2353 : #endif // VALIDATE_PARAMETERS
; 2354 :     
; 2355 :     hr = HRFROMP(pMediaObject = NEW(CWaveFileMediaObject));

  00006	6a 50		 push	 80			; 00000050H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	83 c4 04	 add	 esp, 4
  00010	89 45 f4	 mov	 DWORD PTR $T41567[ebp], eax
  00013	83 7d f4 00	 cmp	 DWORD PTR $T41567[ebp], 0
  00017	74 0d		 je	 SHORT $L41568
  00019	8b 4d f4	 mov	 ecx, DWORD PTR $T41567[ebp]
  0001c	e8 00 00 00 00	 call	 ??0CWaveFileMediaObject@DirectSound@@QAE@XZ ; DirectSound::CWaveFileMediaObject::CWaveFileMediaObject
  00021	89 45 f0	 mov	 DWORD PTR tv69[ebp], eax
  00024	eb 07		 jmp	 SHORT $L41569
$L41568:
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L41569:
  0002d	8b 45 f0	 mov	 eax, DWORD PTR tv69[ebp]
  00030	89 45 fc	 mov	 DWORD PTR _pMediaObject$[ebp], eax
  00033	33 c9		 xor	 ecx, ecx
  00035	83 7d fc 00	 cmp	 DWORD PTR _pMediaObject$[ebp], 0
  00039	0f 95 c1	 setne	 cl
  0003c	49		 dec	 ecx
  0003d	81 e1 0e 00 07
	80		 and	 ecx, -2147024882	; 8007000eH
  00043	89 4d f8	 mov	 DWORD PTR _hr$[ebp], ecx

; 2356 : 
; 2357 :     if(SUCCEEDED(hr))

  00046	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004a	7c 28		 jl	 SHORT $L36463

; 2358 :     {
; 2359 :         if(pszFileName)

  0004c	83 7d 08 00	 cmp	 DWORD PTR _pszFileName$[ebp], 0
  00050	74 12		 je	 SHORT $L36464

; 2360 :         {
; 2361 :             hr = pMediaObject->Initialize(pszFileName);

  00052	8b 55 08	 mov	 edx, DWORD PTR _pszFileName$[ebp]
  00055	52		 push	 edx
  00056	8b 45 fc	 mov	 eax, DWORD PTR _pMediaObject$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?Initialize@CWaveFileMediaObject@DirectSound@@QAGJPBD@Z ; DirectSound::CWaveFileMediaObject::Initialize
  0005f	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 2362 :         }
; 2363 :         else

  00062	eb 10		 jmp	 SHORT $L36463
$L36464:

; 2364 :         {
; 2365 :             hr = pMediaObject->Initialize(hFile);

  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _hFile$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 fc	 mov	 edx, DWORD PTR _pMediaObject$[ebp]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ?Initialize@CWaveFileMediaObject@DirectSound@@QAGJPAX@Z ; DirectSound::CWaveFileMediaObject::Initialize
  00071	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L36463:

; 2366 :         }
; 2367 :     }
; 2368 : 
; 2369 :     if(SUCCEEDED(hr))

  00074	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00078	7c 0e		 jl	 SHORT $L36467

; 2370 :     {
; 2371 :         *ppMediaObject = ADDREF(pMediaObject);

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _pMediaObject$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCWaveFileMediaObject@1@PAV21@@Z ; DirectSound::__AddRef
  00083	8b 4d 10	 mov	 ecx, DWORD PTR _ppMediaObject$[ebp]
  00086	89 01		 mov	 DWORD PTR [ecx], eax
$L36467:

; 2372 :     }
; 2373 : 
; 2374 :     RELEASE(pMediaObject);

  00088	83 7d fc 00	 cmp	 DWORD PTR _pMediaObject$[ebp], 0
  0008c	74 13		 je	 SHORT $L36471
  0008e	8b 55 fc	 mov	 edx, DWORD PTR _pMediaObject$[ebp]
  00091	8b 02		 mov	 eax, DWORD PTR [edx]
  00093	8b 4d fc	 mov	 ecx, DWORD PTR _pMediaObject$[ebp]
  00096	51		 push	 ecx
  00097	ff 50 04	 call	 DWORD PTR [eax+4]
  0009a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pMediaObject$[ebp], 0
$L36471:

; 2375 : 
; 2376 :     DPF_LEAVE_HRESULT(hr);
; 2377 : 
; 2378 :     return hr;

  000a1	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 2379 : }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 0c 00	 ret	 12			; 0000000cH
_XWaveFileCreateMediaObjectEx@12 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\wavexmo.h
DSOUND	ENDS
;	COMDAT ?Initialize@CWaveFileMediaObject@DirectSound@@QAGJPAX@Z
DSOUND	SEGMENT
_this$ = 8
_hFile$ = 12
?Initialize@CWaveFileMediaObject@DirectSound@@QAGJPAX@Z PROC NEAR ; DirectSound::CWaveFileMediaObject::Initialize, COMDAT

; 76   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   :         return CWaveFile::Open(NULL, hFile);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _hFile$[ebp]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000f	e8 00 00 00 00	 call	 ?Open@CWaveFile@WaveLoader@@IAEJPBDPAX@Z ; WaveLoader::CWaveFile::Open

; 78   :     }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
?Initialize@CWaveFileMediaObject@DirectSound@@QAGJPAX@Z ENDP ; DirectSound::CWaveFileMediaObject::Initialize
DSOUND	ENDS
PUBLIC	?Initialize@CFileMediaObject@DirectSound@@QAGJPBDKKKK@Z ; DirectSound::CFileMediaObject::Initialize
PUBLIC	_XFileCreateMediaObject@24
PUBLIC	?__AddRef@DirectSound@@YGPAVCFileMediaObject@1@PAV21@@Z ; DirectSound::__AddRef
EXTRN	??0CFileMediaObject@DirectSound@@QAE@XZ:NEAR	; DirectSound::CFileMediaObject::CFileMediaObject
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _XFileCreateMediaObject@24
DSOUND	SEGMENT
tv69 = -16
$T41576 = -12
_hr$ = -8
_pMediaObject$ = -4
_pszFileName$ = 8
_dwDesiredAccess$ = 12
_dwShareMode$ = 16
_dwCreationDisposition$ = 20
_dwFlagsAndAttributes$ = 24
_ppMediaObject$ = 28
_XFileCreateMediaObject@24 PROC NEAR			; COMDAT

; 2416 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2417 :     CFileMediaObject *      pMediaObject;
; 2418 :     HRESULT                 hr;
; 2419 : 
; 2420 :     DPF_ENTER();
; 2421 :     
; 2422 :     hr = HRFROMP(pMediaObject = NEW(CFileMediaObject));

  00006	6a 14		 push	 20			; 00000014H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	83 c4 04	 add	 esp, 4
  00010	89 45 f4	 mov	 DWORD PTR $T41576[ebp], eax
  00013	83 7d f4 00	 cmp	 DWORD PTR $T41576[ebp], 0
  00017	74 0d		 je	 SHORT $L41577
  00019	8b 4d f4	 mov	 ecx, DWORD PTR $T41576[ebp]
  0001c	e8 00 00 00 00	 call	 ??0CFileMediaObject@DirectSound@@QAE@XZ ; DirectSound::CFileMediaObject::CFileMediaObject
  00021	89 45 f0	 mov	 DWORD PTR tv69[ebp], eax
  00024	eb 07		 jmp	 SHORT $L41578
$L41577:
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L41578:
  0002d	8b 45 f0	 mov	 eax, DWORD PTR tv69[ebp]
  00030	89 45 fc	 mov	 DWORD PTR _pMediaObject$[ebp], eax
  00033	33 c9		 xor	 ecx, ecx
  00035	83 7d fc 00	 cmp	 DWORD PTR _pMediaObject$[ebp], 0
  00039	0f 95 c1	 setne	 cl
  0003c	49		 dec	 ecx
  0003d	81 e1 0e 00 07
	80		 and	 ecx, -2147024882	; 8007000eH
  00043	89 4d f8	 mov	 DWORD PTR _hr$[ebp], ecx

; 2423 : 
; 2424 :     if(SUCCEEDED(hr))

  00046	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004a	7c 20		 jl	 SHORT $L36487

; 2425 :     {
; 2426 :         hr = pMediaObject->Initialize(pszFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, dwFlagsAndAttributes);

  0004c	8b 55 18	 mov	 edx, DWORD PTR _dwFlagsAndAttributes$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 14	 mov	 eax, DWORD PTR _dwCreationDisposition$[ebp]
  00053	50		 push	 eax
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _dwShareMode$[ebp]
  00057	51		 push	 ecx
  00058	8b 55 0c	 mov	 edx, DWORD PTR _dwDesiredAccess$[ebp]
  0005b	52		 push	 edx
  0005c	8b 45 08	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _pMediaObject$[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ?Initialize@CFileMediaObject@DirectSound@@QAGJPBDKKKK@Z ; DirectSound::CFileMediaObject::Initialize
  00069	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L36487:

; 2427 :     }
; 2428 : 
; 2429 :     if(SUCCEEDED(hr))

  0006c	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00070	7c 0e		 jl	 SHORT $L36489

; 2430 :     {
; 2431 :         *ppMediaObject = ADDREF(pMediaObject);

  00072	8b 55 fc	 mov	 edx, DWORD PTR _pMediaObject$[ebp]
  00075	52		 push	 edx
  00076	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCFileMediaObject@1@PAV21@@Z ; DirectSound::__AddRef
  0007b	8b 4d 1c	 mov	 ecx, DWORD PTR _ppMediaObject$[ebp]
  0007e	89 01		 mov	 DWORD PTR [ecx], eax
$L36489:

; 2432 :     }
; 2433 : 
; 2434 :     RELEASE(pMediaObject);

  00080	83 7d fc 00	 cmp	 DWORD PTR _pMediaObject$[ebp], 0
  00084	74 13		 je	 SHORT $L36494
  00086	8b 55 fc	 mov	 edx, DWORD PTR _pMediaObject$[ebp]
  00089	8b 02		 mov	 eax, DWORD PTR [edx]
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _pMediaObject$[ebp]
  0008e	51		 push	 ecx
  0008f	ff 50 04	 call	 DWORD PTR [eax+4]
  00092	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pMediaObject$[ebp], 0
$L36494:

; 2435 : 
; 2436 :     DPF_LEAVE_HRESULT(hr);
; 2437 : 
; 2438 :     return hr;

  00099	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 2439 : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 18 00	 ret	 24			; 00000018H
_XFileCreateMediaObject@24 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\wavexmo.h
DSOUND	ENDS
;	COMDAT ?Initialize@CFileMediaObject@DirectSound@@QAGJPBDKKKK@Z
DSOUND	SEGMENT
_this$ = 8
_pszFileName$ = 12
_dwDesiredAccess$ = 16
_dwShareMode$ = 20
_dwCreationDisposition$ = 24
_dwFlagsAndAttributes$ = 28
?Initialize@CFileMediaObject@DirectSound@@QAGJPBDKKKK@Z PROC NEAR ; DirectSound::CFileMediaObject::Initialize, COMDAT

; 157  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 158  :         return CStdFileStream::Open(pszFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, dwFlagsAndAttributes);

  00003	8b 45 1c	 mov	 eax, DWORD PTR _dwFlagsAndAttributes$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 18	 mov	 ecx, DWORD PTR _dwCreationDisposition$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 14	 mov	 edx, DWORD PTR _dwShareMode$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 10	 mov	 eax, DWORD PTR _dwDesiredAccess$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _pszFileName$[ebp]
  00016	51		 push	 ecx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001d	e8 00 00 00 00	 call	 ?Open@CStdFileStream@WaveLoader@@QAEJPBDKKKK@Z ; WaveLoader::CStdFileStream::Open

; 159  :     }

  00022	5d		 pop	 ebp
  00023	c2 18 00	 ret	 24			; 00000018H
?Initialize@CFileMediaObject@DirectSound@@QAGJPBDKKKK@Z ENDP ; DirectSound::CFileMediaObject::Initialize
DSOUND	ENDS
PUBLIC	?Initialize@CFileMediaObject@DirectSound@@QAGJPAX@Z ; DirectSound::CFileMediaObject::Initialize
PUBLIC	_XFileCreateMediaObjectEx@8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _XFileCreateMediaObjectEx@8
DSOUND	SEGMENT
tv69 = -16
$T41585 = -12
_hr$ = -8
_pMediaObject$ = -4
_hFile$ = 8
_ppMediaObject$ = 12
_XFileCreateMediaObjectEx@8 PROC NEAR			; COMDAT

; 2468 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2469 :     CFileMediaObject *      pMediaObject;
; 2470 :     HRESULT                 hr;
; 2471 : 
; 2472 :     DPF_ENTER();
; 2473 :     
; 2474 :     hr = HRFROMP(pMediaObject = NEW(CFileMediaObject));

  00006	6a 14		 push	 20			; 00000014H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	83 c4 04	 add	 esp, 4
  00010	89 45 f4	 mov	 DWORD PTR $T41585[ebp], eax
  00013	83 7d f4 00	 cmp	 DWORD PTR $T41585[ebp], 0
  00017	74 0d		 je	 SHORT $L41586
  00019	8b 4d f4	 mov	 ecx, DWORD PTR $T41585[ebp]
  0001c	e8 00 00 00 00	 call	 ??0CFileMediaObject@DirectSound@@QAE@XZ ; DirectSound::CFileMediaObject::CFileMediaObject
  00021	89 45 f0	 mov	 DWORD PTR tv69[ebp], eax
  00024	eb 07		 jmp	 SHORT $L41587
$L41586:
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L41587:
  0002d	8b 45 f0	 mov	 eax, DWORD PTR tv69[ebp]
  00030	89 45 fc	 mov	 DWORD PTR _pMediaObject$[ebp], eax
  00033	33 c9		 xor	 ecx, ecx
  00035	83 7d fc 00	 cmp	 DWORD PTR _pMediaObject$[ebp], 0
  00039	0f 95 c1	 setne	 cl
  0003c	49		 dec	 ecx
  0003d	81 e1 0e 00 07
	80		 and	 ecx, -2147024882	; 8007000eH
  00043	89 4d f8	 mov	 DWORD PTR _hr$[ebp], ecx

; 2475 : 
; 2476 :     if(SUCCEEDED(hr))

  00046	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004a	7c 10		 jl	 SHORT $L36506

; 2477 :     {
; 2478 :         hr = pMediaObject->Initialize(hFile);

  0004c	8b 55 08	 mov	 edx, DWORD PTR _hFile$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 fc	 mov	 eax, DWORD PTR _pMediaObject$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?Initialize@CFileMediaObject@DirectSound@@QAGJPAX@Z ; DirectSound::CFileMediaObject::Initialize
  00059	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L36506:

; 2479 :     }
; 2480 : 
; 2481 :     if(SUCCEEDED(hr))

  0005c	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00060	7c 0e		 jl	 SHORT $L36508

; 2482 :     {
; 2483 :         *ppMediaObject = ADDREF(pMediaObject);

  00062	8b 4d fc	 mov	 ecx, DWORD PTR _pMediaObject$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCFileMediaObject@1@PAV21@@Z ; DirectSound::__AddRef
  0006b	8b 55 0c	 mov	 edx, DWORD PTR _ppMediaObject$[ebp]
  0006e	89 02		 mov	 DWORD PTR [edx], eax
$L36508:

; 2484 :     }
; 2485 : 
; 2486 :     RELEASE(pMediaObject);

  00070	83 7d fc 00	 cmp	 DWORD PTR _pMediaObject$[ebp], 0
  00074	74 13		 je	 SHORT $L36512
  00076	8b 45 fc	 mov	 eax, DWORD PTR _pMediaObject$[ebp]
  00079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007b	8b 55 fc	 mov	 edx, DWORD PTR _pMediaObject$[ebp]
  0007e	52		 push	 edx
  0007f	ff 51 04	 call	 DWORD PTR [ecx+4]
  00082	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pMediaObject$[ebp], 0
$L36512:

; 2487 : 
; 2488 :     DPF_LEAVE_HRESULT(hr);
; 2489 : 
; 2490 :     return hr;

  00089	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 2491 : }

  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_XFileCreateMediaObjectEx@8 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\wavexmo.h
DSOUND	ENDS
;	COMDAT ?Initialize@CFileMediaObject@DirectSound@@QAGJPAX@Z
DSOUND	SEGMENT
_this$ = 8
_hFile$ = 12
?Initialize@CFileMediaObject@DirectSound@@QAGJPAX@Z PROC NEAR ; DirectSound::CFileMediaObject::Initialize, COMDAT

; 162  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 163  :         CStdFileStream::Attach(hFile);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _hFile$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	e8 00 00 00 00	 call	 ?Attach@CStdFileStream@WaveLoader@@QAEXPAX@Z ; WaveLoader::CStdFileStream::Attach

; 164  :         return DS_OK;

  00012	33 c0		 xor	 eax, eax

; 165  :     }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
?Initialize@CFileMediaObject@DirectSound@@QAGJPAX@Z ENDP ; DirectSound::CFileMediaObject::Initialize
DSOUND	ENDS
PUBLIC	_Ac97CreateMediaObject@16
PUBLIC	?__AddRef@DirectSound@@YGPAVCAc97MediaObject@1@PAV21@@Z ; DirectSound::__AddRef
EXTRN	??0CAc97MediaObject@DirectSound@@QAE@XZ:NEAR	; DirectSound::CAc97MediaObject::CAc97MediaObject
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT _Ac97CreateMediaObject@16
DSOUND	SEGMENT
tv72 = -24
$T41597 = -20
$T41594 = -16
___AutoLock$ = -12
_hr$ = -8
_pMediaObject$ = -4
_dwChannel$ = 8
_pfnCallback$ = 12
_pvCallbackContext$ = 16
_ppMediaObject$ = 20
_Ac97CreateMediaObject@16 PROC NEAR			; COMDAT

; 2523 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 2524 :     CAc97MediaObject *          pMediaObject    = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pMediaObject$[ebp], 0

; 2525 :     HRESULT                     hr;
; 2526 :     
; 2527 :     DPF_ENTER();
; 2528 :     ENTER_EXTERNAL_FUNCTION();

  0000d	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00010	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock

; 2529 : 
; 2530 :     //
; 2531 :     // Create the AC97 media object
; 2532 :     //
; 2533 : 
; 2534 :     hr = HRFROMP(pMediaObject = NEW(CAc97MediaObject));

  00015	6a 30		 push	 48			; 00000030H
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 f0	 mov	 DWORD PTR $T41594[ebp], eax
  00022	83 7d f0 00	 cmp	 DWORD PTR $T41594[ebp], 0
  00026	74 0d		 je	 SHORT $L41595
  00028	8b 4d f0	 mov	 ecx, DWORD PTR $T41594[ebp]
  0002b	e8 00 00 00 00	 call	 ??0CAc97MediaObject@DirectSound@@QAE@XZ ; DirectSound::CAc97MediaObject::CAc97MediaObject
  00030	89 45 e8	 mov	 DWORD PTR tv72[ebp], eax
  00033	eb 07		 jmp	 SHORT $L41596
$L41595:
  00035	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L41596:
  0003c	8b 45 e8	 mov	 eax, DWORD PTR tv72[ebp]
  0003f	89 45 fc	 mov	 DWORD PTR _pMediaObject$[ebp], eax
  00042	33 c9		 xor	 ecx, ecx
  00044	83 7d fc 00	 cmp	 DWORD PTR _pMediaObject$[ebp], 0
  00048	0f 95 c1	 setne	 cl
  0004b	49		 dec	 ecx
  0004c	81 e1 0e 00 07
	80		 and	 ecx, -2147024882	; 8007000eH
  00052	89 4d f8	 mov	 DWORD PTR _hr$[ebp], ecx

; 2535 :    
; 2536 :     if(SUCCEEDED(hr))

  00055	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00059	7c 1b		 jl	 SHORT $L36527

; 2537 :     {
; 2538 :         hr = pMediaObject->Initialize(dwChannel, pfnCallback, pvCallbackContext);

  0005b	8b 55 10	 mov	 edx, DWORD PTR _pvCallbackContext$[ebp]
  0005e	52		 push	 edx
  0005f	8b 45 0c	 mov	 eax, DWORD PTR _pfnCallback$[ebp]
  00062	50		 push	 eax
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _dwChannel$[ebp]
  00066	51		 push	 ecx
  00067	8b 55 fc	 mov	 edx, DWORD PTR _pMediaObject$[ebp]
  0006a	8b 02		 mov	 eax, DWORD PTR [edx]
  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _pMediaObject$[ebp]
  0006f	51		 push	 ecx
  00070	ff 50 24	 call	 DWORD PTR [eax+36]
  00073	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L36527:

; 2539 :     }
; 2540 : 
; 2541 :     if(SUCCEEDED(hr))

  00076	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0007a	7c 0e		 jl	 SHORT $L36529

; 2542 :     {
; 2543 :         *ppMediaObject = ADDREF(pMediaObject);

  0007c	8b 55 fc	 mov	 edx, DWORD PTR _pMediaObject$[ebp]
  0007f	52		 push	 edx
  00080	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCAc97MediaObject@1@PAV21@@Z ; DirectSound::__AddRef
  00085	8b 4d 14	 mov	 ecx, DWORD PTR _ppMediaObject$[ebp]
  00088	89 01		 mov	 DWORD PTR [ecx], eax
$L36529:

; 2544 :     }
; 2545 : 
; 2546 :     RELEASE(pMediaObject);

  0008a	83 7d fc 00	 cmp	 DWORD PTR _pMediaObject$[ebp], 0
  0008e	74 13		 je	 SHORT $L36534
  00090	8b 55 fc	 mov	 edx, DWORD PTR _pMediaObject$[ebp]
  00093	8b 02		 mov	 eax, DWORD PTR [edx]
  00095	8b 4d fc	 mov	 ecx, DWORD PTR _pMediaObject$[ebp]
  00098	51		 push	 ecx
  00099	ff 50 04	 call	 DWORD PTR [eax+4]
  0009c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pMediaObject$[ebp], 0
$L36534:

; 2547 : 
; 2548 :     DPF_LEAVE_HRESULT(hr);
; 2549 : 
; 2550 :     return hr;

  000a3	8b 55 f8	 mov	 edx, DWORD PTR _hr$[ebp]
  000a6	89 55 ec	 mov	 DWORD PTR $T41597[ebp], edx
  000a9	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  000ac	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  000b1	8b 45 ec	 mov	 eax, DWORD PTR $T41597[ebp]

; 2551 : }

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 10 00	 ret	 16			; 00000010H
_Ac97CreateMediaObject@16 ENDP
DSOUND	ENDS
PUBLIC	_DirectSoundDumpMemoryUsage@4
; Function compile flags: /Odt
;	COMDAT _DirectSoundDumpMemoryUsage@4
DSOUND	SEGMENT
___AutoLock$ = -4
_fAssertNone$ = 8
_DirectSoundDumpMemoryUsage@4 PROC NEAR			; COMDAT

; 2577 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2578 :     DPF_ENTER();
; 2579 :     ENTER_EXTERNAL_FUNCTION();

  00004	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00007	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock

; 2580 : 
; 2581 :     CMemoryManager::DumpMemoryUsage(fAssertNone);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _fAssertNone$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?DumpMemoryUsage@CMemoryManager@DirectSound@@SGXH@Z ; DirectSound::CMemoryManager::DumpMemoryUsage

; 2582 : 
; 2583 :     DPF_LEAVE_VOID();
; 2584 : }

  00015	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00018	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
_DirectSoundDumpMemoryUsage@4 ENDP
DSOUND	ENDS
PUBLIC	??0CDirectSoundSettings@DirectSound@@QAE@XZ	; DirectSound::CDirectSoundSettings::CDirectSoundSettings
PUBLIC	?SetEffectImageLocations@CDirectSoundSettings@DirectSound@@QAEXPBU_DSEFFECTIMAGELOC@@@Z ; DirectSound::CDirectSoundSettings::SetEffectImageLocations
PUBLIC	??_7CDirectSoundSettings@DirectSound@@6B@	; DirectSound::CDirectSoundSettings::`vftable'
PUBLIC	??_GCDirectSoundSettings@DirectSound@@UAEPAXI@Z	; DirectSound::CDirectSoundSettings::`scalar deleting destructor'
PUBLIC	??0CRefCount@DirectSound@@QAE@K@Z		; DirectSound::CRefCount::CRefCount
PUBLIC	?AddRef@CRefCount@DirectSound@@UAGKXZ		; DirectSound::CRefCount::AddRef
PUBLIC	?Release@CRefCount@DirectSound@@UAGKXZ		; DirectSound::CRefCount::Release
EXTRN	??_ECDirectSoundSettings@DirectSound@@UAEPAXI@Z:NEAR ; DirectSound::CDirectSoundSettings::`vector deleting destructor'
;	COMDAT ??_7CDirectSoundSettings@DirectSound@@6B@
CONST	SEGMENT
??_7CDirectSoundSettings@DirectSound@@6B@ DD FLAT:??_ECDirectSoundSettings@DirectSound@@UAEPAXI@Z ; DirectSound::CDirectSoundSettings::`vftable'
	DD	FLAT:?AddRef@CRefCount@DirectSound@@UAGKXZ
	DD	FLAT:?Release@CRefCount@DirectSound@@UAGKXZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CDirectSoundSettings@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -8
_i$ = -4
??0CDirectSoundSettings@DirectSound@@QAE@XZ PROC NEAR	; DirectSound::CDirectSoundSettings::CDirectSoundSettings, COMDAT
; _this$ = ecx

; 2609 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	6a 01		 push	 1
  0000b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0CRefCount@DirectSound@@QAE@K@Z ; DirectSound::CRefCount::CRefCount
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDirectSoundSettings@DirectSound@@6B@

; 2610 :     DWORD                   i;
; 2611 : 
; 2612 :     DPF_ENTER();
; 2613 : 
; 2614 : #ifndef MCPX_BOOT_LIB
; 2615 : 
; 2616 :     m_3dParams.HrtfParams = DirectSoundDefault3DListener;
; 2617 :     m_3dParams.I3dl2Params = DirectSoundI3DL2ListenerPreset_Default;
; 2618 : 
; 2619 : #endif // MCPX_BOOT_LIB
; 2620 : 
; 2621 :     //
; 2622 :     // Read the speaker configuration from the EEPROM
; 2623 :     //
; 2624 : 
; 2625 : #ifndef MCPX_BOOT_LIB
; 2626 : 
; 2627 :     if(DSSPEAKER_IS_VALID(g_dwDirectSoundOverrideSpeakerConfig))
; 2628 :     {
; 2629 :         m_dwSpeakerConfig = g_dwDirectSoundOverrideSpeakerConfig;
; 2630 :     }
; 2631 :     else
; 2632 :     {
; 2633 :         m_dwSpeakerConfig = XAudioGetSpeakerConfig();
; 2634 :     }
; 2635 : 
; 2636 : #else // MCPX_BOOT_LIB
; 2637 : 
; 2638 :     m_dwSpeakerConfig = DSSPEAKER_STEREO;

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 2639 : 
; 2640 : #endif // MCPX_BOOT_LIB
; 2641 : 
; 2642 :     //
; 2643 :     // Set default mixbin headroom
; 2644 :     //
; 2645 : 
; 2646 :     for(i = 0; i < DSMIXBIN_SUBMIX; i++)

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002d	eb 09		 jmp	 SHORT $L36545
$L36546:
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00032	83 c2 01	 add	 edx, 1
  00035	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L36545:
  00038	83 7d fc 1f	 cmp	 DWORD PTR _i$[ebp], 31	; 0000001fH
  0003c	73 0c		 jae	 SHORT $L36547

; 2647 :     {
; 2648 :         m_abMixBinHeadroom[i] = DSHEADROOM_DEFAULT;

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00041	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00044	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 2649 :     }

  00048	eb e5		 jmp	 SHORT $L36546
$L36547:

; 2650 : 
; 2651 :     m_abMixBinHeadroom[DSMIXBIN_SUBMIX] = 0;

  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	c6 41 33 00	 mov	 BYTE PTR [ecx+51], 0

; 2652 : 
; 2653 :     //
; 2654 :     // Set default effect locations
; 2655 :     //
; 2656 : 
; 2657 :     SetEffectImageLocations(NULL);

  00051	6a 00		 push	 0
  00053	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?SetEffectImageLocations@CDirectSoundSettings@DirectSound@@QAEXPBU_DSEFFECTIMAGELOC@@@Z ; DirectSound::CDirectSoundSettings::SetEffectImageLocations

; 2658 : 
; 2659 :     DPF_LEAVE_VOID();
; 2660 : }

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??0CDirectSoundSettings@DirectSound@@QAE@XZ ENDP	; DirectSound::CDirectSoundSettings::CDirectSoundSettings
DSOUND	ENDS
PUBLIC	??_7CRefCount@DirectSound@@6B@			; DirectSound::CRefCount::`vftable'
PUBLIC	??_GCRefCount@DirectSound@@UAEPAXI@Z		; DirectSound::CRefCount::`scalar deleting destructor'
EXTRN	??_ECRefCount@DirectSound@@UAEPAXI@Z:NEAR	; DirectSound::CRefCount::`vector deleting destructor'
;	COMDAT ??_7CRefCount@DirectSound@@6B@
; File c:\xbox\private\windows\directx\dsound\common\refcount.h
CONST	SEGMENT
??_7CRefCount@DirectSound@@6B@ DD FLAT:??_ECRefCount@DirectSound@@UAEPAXI@Z ; DirectSound::CRefCount::`vftable'
	DD	FLAT:?AddRef@CRefCount@DirectSound@@UAGKXZ
	DD	FLAT:?Release@CRefCount@DirectSound@@UAGKXZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CRefCount@DirectSound@@QAE@K@Z
DSOUND	SEGMENT
_this$ = -4
_dwInitialRefCount$ = 8
??0CRefCount@DirectSound@@QAE@K@Z PROC NEAR		; DirectSound::CRefCount::CRefCount, COMDAT
; _this$ = ecx

; 37   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CRefCount@DirectSound@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _dwInitialRefCount$[ebp]
  00016	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 38   :     }

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??0CRefCount@DirectSound@@QAE@K@Z ENDP			; DirectSound::CRefCount::CRefCount
DSOUND	ENDS
PUBLIC	??1CRefCount@DirectSound@@UAE@XZ		; DirectSound::CRefCount::~CRefCount
; Function compile flags: /Odt
;	COMDAT ??_GCRefCount@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCRefCount@DirectSound@@UAEPAXI@Z PROC NEAR		; DirectSound::CRefCount::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CRefCount@DirectSound@@UAE@XZ ; DirectSound::CRefCount::~CRefCount
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L30244
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L30244:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCRefCount@DirectSound@@UAEPAXI@Z ENDP		; DirectSound::CRefCount::`scalar deleting destructor'
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??1CRefCount@DirectSound@@UAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CRefCount@DirectSound@@UAE@XZ PROC NEAR		; DirectSound::CRefCount::~CRefCount, COMDAT
; _this$ = ecx

; 41   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CRefCount@DirectSound@@6B@

; 42   :         ASSERT(!m_dwRefCount);
; 43   :     }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1CRefCount@DirectSound@@UAE@XZ ENDP			; DirectSound::CRefCount::~CRefCount
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?AddRef@CRefCount@DirectSound@@UAGKXZ
DSOUND	SEGMENT
_this$ = 8
?AddRef@CRefCount@DirectSound@@UAGKXZ PROC NEAR		; DirectSound::CRefCount::AddRef, COMDAT

; 46   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   :         ASSERT(m_dwRefCount < ~0UL);
; 48   :         return ++m_dwRefCount;

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	83 c1 01	 add	 ecx, 1
  0000c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0000f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00012	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 49   :     }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?AddRef@CRefCount@DirectSound@@UAGKXZ ENDP		; DirectSound::CRefCount::AddRef
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?Release@CRefCount@DirectSound@@UAGKXZ
DSOUND	SEGMENT
tv77 = -12
$T41620 = -8
$T41619 = -4
_this$ = 8
?Release@CRefCount@DirectSound@@UAGKXZ PROC NEAR	; DirectSound::CRefCount::Release, COMDAT

; 52   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 53   :         ASSERT(m_dwRefCount);
; 54   : 
; 55   :         if(m_dwRefCount > 0)

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000d	76 46		 jbe	 SHORT $L30257

; 56   :         {
; 57   :             if(!--m_dwRefCount)

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00015	83 ea 01	 sub	 edx, 1
  00018	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00025	75 2e		 jne	 SHORT $L30257

; 58   :             {
; 59   :                 delete this;

  00027	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	89 55 f8	 mov	 DWORD PTR $T41620[ebp], edx
  0002d	8b 45 f8	 mov	 eax, DWORD PTR $T41620[ebp]
  00030	89 45 fc	 mov	 DWORD PTR $T41619[ebp], eax
  00033	83 7d fc 00	 cmp	 DWORD PTR $T41619[ebp], 0
  00037	74 11		 je	 SHORT $L41621
  00039	6a 01		 push	 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR $T41619[ebp]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	8b 4d fc	 mov	 ecx, DWORD PTR $T41619[ebp]
  00043	ff 12		 call	 DWORD PTR [edx]
  00045	89 45 f4	 mov	 DWORD PTR tv77[ebp], eax
  00048	eb 07		 jmp	 SHORT $L41622
$L41621:
  0004a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$L41622:

; 60   :                 return 0;

  00051	33 c0		 xor	 eax, eax
  00053	eb 06		 jmp	 SHORT $L30256
$L30257:

; 61   :             }
; 62   :         }
; 63   : 
; 64   :         return m_dwRefCount;

  00055	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
$L30256:

; 65   :     }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
?Release@CRefCount@DirectSound@@UAGKXZ ENDP		; DirectSound::CRefCount::Release
DSOUND	ENDS
PUBLIC	??1CDirectSoundSettings@DirectSound@@UAE@XZ	; DirectSound::CDirectSoundSettings::~CDirectSoundSettings
; Function compile flags: /Odt
;	COMDAT ??_GCDirectSoundSettings@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCDirectSoundSettings@DirectSound@@UAEPAXI@Z PROC NEAR ; DirectSound::CDirectSoundSettings::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CDirectSoundSettings@DirectSound@@UAE@XZ ; DirectSound::CDirectSoundSettings::~CDirectSoundSettings
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L36551
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L36551:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCDirectSoundSettings@DirectSound@@UAEPAXI@Z ENDP	; DirectSound::CDirectSoundSettings::`scalar deleting destructor'
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
DSOUND	ENDS
;	COMDAT ??1CDirectSoundSettings@DirectSound@@UAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CDirectSoundSettings@DirectSound@@UAE@XZ PROC NEAR	; DirectSound::CDirectSoundSettings::~CDirectSoundSettings, COMDAT
; _this$ = ecx

; 2685 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDirectSoundSettings@DirectSound@@6B@

; 2686 :     DPF_ENTER();
; 2687 :     DPF_LEAVE_VOID();
; 2688 : }

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CRefCount@DirectSound@@UAE@XZ ; DirectSound::CRefCount::~CRefCount
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CDirectSoundSettings@DirectSound@@UAE@XZ ENDP	; DirectSound::CDirectSoundSettings::~CDirectSoundSettings
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetEffectImageLocations@CDirectSoundSettings@DirectSound@@QAEXPBU_DSEFFECTIMAGELOC@@@Z
DSOUND	SEGMENT
_this$ = -4
_pImageLoc$ = 8
?SetEffectImageLocations@CDirectSoundSettings@DirectSound@@QAEXPBU_DSEFFECTIMAGELOC@@@Z PROC NEAR ; DirectSound::CDirectSoundSettings::SetEffectImageLocations, COMDAT
; _this$ = ecx

; 2714 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2715 :     DPF_ENTER();
; 2716 : 
; 2717 :     if(pImageLoc)

  00007	83 7d 08 00	 cmp	 DWORD PTR _pImageLoc$[ebp], 0
  0000b	74 17		 je	 SHORT $L36560

; 2718 :     {
; 2719 :         CopyMemory(&m_EffectLocations, pImageLoc, sizeof(*pImageLoc));

  0000d	6a 08		 push	 8
  0000f	8b 45 08	 mov	 eax, DWORD PTR _pImageLoc$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 _memcpy
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2720 :     }
; 2721 :     else

  00022	eb 16		 jmp	 SHORT $L36559
$L36560:

; 2722 :     {
; 2723 :         memset(&m_EffectLocations, 0xFF, sizeof(m_EffectLocations));

  00024	6a 08		 push	 8
  00026	68 ff 00 00 00	 push	 255			; 000000ffH
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	83 c2 0c	 add	 edx, 12			; 0000000cH
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _memset
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$L36559:

; 2724 :     }
; 2725 : 
; 2726 :     DPF_LEAVE_VOID();
; 2727 : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?SetEffectImageLocations@CDirectSoundSettings@DirectSound@@QAEXPBU_DSEFFECTIMAGELOC@@@Z ENDP ; DirectSound::CDirectSoundSettings::SetEffectImageLocations
DSOUND	ENDS
PUBLIC	?AddRef@CDirectSound@DirectSound@@UAGKXZ	; DirectSound::CDirectSound::AddRef
PUBLIC	?Release@CDirectSound@DirectSound@@UAGKXZ	; DirectSound::CDirectSound::Release
PUBLIC	??_7CDirectSound@DirectSound@@6B@		; DirectSound::CDirectSound::`vftable'
PUBLIC	??_GCDirectSound@DirectSound@@UAEPAXI@Z		; DirectSound::CDirectSound::`scalar deleting destructor'
EXTRN	??_ECDirectSound@DirectSound@@UAEPAXI@Z:NEAR	; DirectSound::CDirectSound::`vector deleting destructor'
;	COMDAT ??_7CDirectSound@DirectSound@@6B@
CONST	SEGMENT
??_7CDirectSound@DirectSound@@6B@ DD FLAT:??_ECDirectSound@DirectSound@@UAEPAXI@Z ; DirectSound::CDirectSound::`vftable'
	DD	FLAT:?AddRef@CDirectSound@DirectSound@@UAGKXZ
	DD	FLAT:?Release@CDirectSound@DirectSound@@UAGKXZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CDirectSound@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CDirectSound@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CDirectSound::CDirectSound, COMDAT
; _this$ = ecx

; 2768 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 02		 push	 2
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CRefCount@DirectSound@@QAE@K@Z ; DirectSound::CRefCount::CRefCount
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDirectSound@DirectSound@@6B@

; 2769 :     DPF_ENTER();
; 2770 : 
; 2771 :     //
; 2772 :     // Set the global DirectSound object pointer
; 2773 :     //
; 2774 : 
; 2775 :     m_pDirectSound = this;

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_pDirectSound@CDirectSound@DirectSound@@2PAV12@A, ecx ; DirectSound::CDirectSound::m_pDirectSound

; 2776 : 
; 2777 :     //
; 2778 :     // Initialize defaults
; 2779 :     //
; 2780 : 
; 2781 :     InitializeListHead(&m_lst3dVoices);

  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	83 c2 10	 add	 edx, 16			; 00000010H
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	89 50 14	 mov	 DWORD PTR [eax+20], edx
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00035	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00038	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 2782 : 
; 2783 :     DPF_LEAVE_VOID();
; 2784 : }

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0CDirectSound@DirectSound@@QAE@XZ ENDP		; DirectSound::CDirectSound::CDirectSound
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.h
DSOUND	ENDS
;	COMDAT ?AddRef@CDirectSound@DirectSound@@UAGKXZ
DSOUND	SEGMENT
$T41639 = -12
$T41638 = -8
___AutoLock$ = -4
_this$ = 8
?AddRef@CDirectSound@DirectSound@@UAGKXZ PROC NEAR	; DirectSound::CDirectSound::AddRef, COMDAT

; 322  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 323  :         _ENTER_EXTERNAL_METHOD("CDirectSound::AddRef");

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L32181
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41638[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41638[ebp]
  00029	eb 17		 jmp	 SHORT $L32179
$L32181:

; 324  :         return CRefCount::AddRef();

  0002b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?AddRef@CRefCount@DirectSound@@UAGKXZ ; DirectSound::CRefCount::AddRef
  00034	89 45 f4	 mov	 DWORD PTR $T41639[ebp], eax
  00037	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0003a	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0003f	8b 45 f4	 mov	 eax, DWORD PTR $T41639[ebp]
$L32179:

; 325  :     }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?AddRef@CDirectSound@DirectSound@@UAGKXZ ENDP		; DirectSound::CDirectSound::AddRef
DSOUND	ENDS
PUBLIC	??1CDirectSound@DirectSound@@UAE@XZ		; DirectSound::CDirectSound::~CDirectSound
; Function compile flags: /Odt
;	COMDAT ??_GCDirectSound@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCDirectSound@DirectSound@@UAEPAXI@Z PROC NEAR	; DirectSound::CDirectSound::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CDirectSound@DirectSound@@UAE@XZ ; DirectSound::CDirectSound::~CDirectSound
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L36569
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L36569:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCDirectSound@DirectSound@@UAEPAXI@Z ENDP		; DirectSound::CDirectSound::`scalar deleting destructor'
DSOUND	ENDS
PUBLIC	?UnregisterCounters@CPerfMon@DirectSound@@SGXXZ	; DirectSound::CPerfMon::UnregisterCounters
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT ??1CDirectSound@DirectSound@@UAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CDirectSound@DirectSound@@UAE@XZ PROC NEAR		; DirectSound::CDirectSound::~CDirectSound, COMDAT
; _this$ = ecx

; 2809 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDirectSound@DirectSound@@6B@

; 2810 :     DPF_ENTER();
; 2811 : 
; 2812 :     //
; 2813 :     // Release performance counters
; 2814 :     //
; 2815 : 
; 2816 :     CPerfMon::UnregisterCounters();

  00010	e8 00 00 00 00	 call	 ?UnregisterCounters@CPerfMon@DirectSound@@SGXXZ ; DirectSound::CPerfMon::UnregisterCounters

; 2817 : 
; 2818 :     //
; 2819 :     // Release the global DirectSound object pointer
; 2820 :     //
; 2821 : 
; 2822 :     m_pDirectSound = NULL;

  00015	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_pDirectSound@CDirectSound@DirectSound@@2PAV12@A, 0 ; DirectSound::CDirectSound::m_pDirectSound

; 2823 : 
; 2824 :     //
; 2825 :     // Free owned objects
; 2826 :     //
; 2827 : 
; 2828 :     RELEASE(m_pDevice);

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00026	74 1c		 je	 SHORT $L36574
  00028	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	52		 push	 edx
  00037	ff 50 08	 call	 DWORD PTR [eax+8]
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
$L36574:

; 2829 :     RELEASE(m_pSettings);

  00044	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00047	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  0004b	74 1c		 je	 SHORT $L36573
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00053	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00056	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00059	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0005b	50		 push	 eax
  0005c	ff 51 08	 call	 DWORD PTR [ecx+8]
  0005f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00062	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
$L36573:

; 2830 : 
; 2831 :     DPF_LEAVE_VOID();
; 2832 : }

  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ??1CRefCount@DirectSound@@UAE@XZ ; DirectSound::CRefCount::~CRefCount
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
??1CDirectSound@DirectSound@@UAE@XZ ENDP		; DirectSound::CDirectSound::~CDirectSound
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsperf.h
DSOUND	ENDS
;	COMDAT ?UnregisterCounters@CPerfMon@DirectSound@@SGXXZ
DSOUND	SEGMENT
?UnregisterCounters@CPerfMon@DirectSound@@SGXXZ PROC NEAR ; DirectSound::CPerfMon::UnregisterCounters, COMDAT

; 69   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 70   :     }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?UnregisterCounters@CPerfMon@DirectSound@@SGXXZ ENDP	; DirectSound::CPerfMon::UnregisterCounters
DSOUND	ENDS
PUBLIC	?Release@IDirectSoundBuffer@@QAGKXZ		; IDirectSoundBuffer::Release
PUBLIC	?Stop@IDirectSoundBuffer@@QAGJXZ		; IDirectSoundBuffer::Stop
PUBLIC	?GetStatus@IDirectSoundBuffer@@QAGJPAK@Z	; IDirectSoundBuffer::GetStatus
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT ?Release@CDirectSound@DirectSound@@UAGKXZ
DSOUND	SEGMENT
$T41653 = -28
$T41652 = -24
___AutoLock$ = -20
_hr$ = -16
_dwStatus$ = -12
_dwRefCount$ = -8
_i$ = -4
_this$ = 8
?Release@CDirectSound@DirectSound@@UAGKXZ PROC NEAR	; DirectSound::CDirectSound::Release, COMDAT

; 2860 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 2861 :     DWORD                   dwRefCount;
; 2862 :     DWORD                   dwStatus;
; 2863 :     HRESULT                 hr;
; 2864 :     DWORD                   i;
; 2865 : 
; 2866 :     DPF_ENTER();
; 2867 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 17		 je	 SHORT $L36585
  00017	c7 45 e8 05 40
	00 80		 mov	 DWORD PTR $T41652[ebp], -2147467259 ; 80004005H
  0001e	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 e8	 mov	 eax, DWORD PTR $T41652[ebp]
  00029	e9 d2 00 00 00	 jmp	 $L36579
$L36585:

; 2868 : 
; 2869 :     if((dwRefCount = CRefCount::Release()) == NUMELMS(m_apKeepAliveBuffers) + 1)

  0002e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?Release@CRefCount@DirectSound@@UAGKXZ ; DirectSound::CRefCount::Release
  00037	89 45 f8	 mov	 DWORD PTR _dwRefCount$[ebp], eax
  0003a	83 7d f8 05	 cmp	 DWORD PTR _dwRefCount$[ebp], 5
  0003e	0f 85 ab 00 00
	00		 jne	 $L36588

; 2870 :     {
; 2871 :         //
; 2872 :         // The only references we have left are the keepalive buffers and the
; 2873 :         // artificial one we added at creation.  Go ahead and shut down.
; 2874 :         //
; 2875 : 
; 2876 :         for(i = 0; i < NUMELMS(m_apKeepAliveBuffers); i++)

  00044	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004b	eb 09		 jmp	 SHORT $L36589
$L36590:
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00050	83 c1 01	 add	 ecx, 1
  00053	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L36589:
  00056	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  0005a	73 12		 jae	 SHORT $L36591

; 2877 :         {
; 2878 :             ASSERT(m_apKeepAliveBuffers[i]);
; 2879 : 
; 2880 :             m_apKeepAliveBuffers[i]->Stop();

  0005c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0005f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 4c 90 18	 mov	 ecx, DWORD PTR [eax+edx*4+24]
  00066	51		 push	 ecx
  00067	e8 00 00 00 00	 call	 ?Stop@IDirectSoundBuffer@@QAGJXZ ; IDirectSoundBuffer::Stop

; 2881 :         }

  0006c	eb df		 jmp	 SHORT $L36590
$L36591:

; 2882 : 
; 2883 :         for(i = 0; i < NUMELMS(m_apKeepAliveBuffers); i++)

  0006e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00075	eb 09		 jmp	 SHORT $L36592
$L36593:
  00077	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0007a	83 c2 01	 add	 edx, 1
  0007d	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L36592:
  00080	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  00084	73 5d		 jae	 SHORT $L36594
$L36595:

; 2884 :         {
; 2885 :             ASSERT(m_apKeepAliveBuffers[i]);
; 2886 : 
; 2887 :             do
; 2888 :             {
; 2889 :                 DoWork();

  00086	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ?DoWork@CDirectSound@DirectSound@@QAGXXZ ; DirectSound::CDirectSound::DoWork

; 2890 :                 
; 2891 :                 hr = m_apKeepAliveBuffers[i]->GetStatus(&dwStatus);

  0008f	8d 4d f4	 lea	 ecx, DWORD PTR _dwStatus$[ebp]
  00092	51		 push	 ecx
  00093	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00096	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00099	8b 4c 90 18	 mov	 ecx, DWORD PTR [eax+edx*4+24]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?GetStatus@IDirectSoundBuffer@@QAGJPAK@Z ; IDirectSoundBuffer::GetStatus
  000a3	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 2892 :             }
; 2893 :             while(SUCCEEDED(hr) && (dwStatus & DSBSTATUS_PLAYING));

  000a6	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000aa	7c 0a		 jl	 SHORT $L36597
  000ac	8b 55 f4	 mov	 edx, DWORD PTR _dwStatus$[ebp]
  000af	83 e2 01	 and	 edx, 1
  000b2	85 d2		 test	 edx, edx
  000b4	75 d0		 jne	 SHORT $L36595
$L36597:

; 2894 : 
; 2895 :             RELEASE(m_apKeepAliveBuffers[i]);

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000b9	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000bc	83 7c 81 18 00	 cmp	 DWORD PTR [ecx+eax*4+24], 0
  000c1	74 1e		 je	 SHORT $L36600
  000c3	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000c6	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	8b 4c 90 18	 mov	 ecx, DWORD PTR [eax+edx*4+24]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ?Release@IDirectSoundBuffer@@QAGKXZ ; IDirectSoundBuffer::Release
  000d3	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000d6	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000d9	c7 44 90 18 00
	00 00 00	 mov	 DWORD PTR [eax+edx*4+24], 0
$L36600:

; 2896 :         }

  000e1	eb 94		 jmp	 SHORT $L36593
$L36594:

; 2897 : 
; 2898 :         dwRefCount = CRefCount::Release();

  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 ?Release@CRefCount@DirectSound@@UAGKXZ ; DirectSound::CRefCount::Release
  000ec	89 45 f8	 mov	 DWORD PTR _dwRefCount$[ebp], eax
$L36588:

; 2899 :         ASSERT(!dwRefCount);
; 2900 :     }
; 2901 : 
; 2902 :     DPF_LEAVE(dwRefCount);
; 2903 : 
; 2904 :     return dwRefCount;

  000ef	8b 55 f8	 mov	 edx, DWORD PTR _dwRefCount$[ebp]
  000f2	89 55 e4	 mov	 DWORD PTR $T41653[ebp], edx
  000f5	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  000f8	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  000fd	8b 45 e4	 mov	 eax, DWORD PTR $T41653[ebp]
$L36579:

; 2905 : }

  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 04 00	 ret	 4
?Release@CDirectSound@DirectSound@@UAGKXZ ENDP		; DirectSound::CDirectSound::Release
; Function compile flags: /Odt
; File c:\xbox\private\inc\dsoundp.h
DSOUND	ENDS
;	COMDAT ?Release@IDirectSoundBuffer@@QAGKXZ
DSOUND	SEGMENT
_this$ = 8
?Release@IDirectSoundBuffer@@QAGKXZ PROC NEAR		; IDirectSoundBuffer::Release, COMDAT

; 1932 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1933 :         return IDirectSoundBuffer_Release(this);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _IDirectSoundBuffer_Release@4

; 1934 :     }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?Release@IDirectSoundBuffer@@QAGKXZ ENDP		; IDirectSoundBuffer::Release
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?Stop@IDirectSoundBuffer@@QAGJXZ
DSOUND	SEGMENT
_this$ = 8
?Stop@IDirectSoundBuffer@@QAGJXZ PROC NEAR		; IDirectSoundBuffer::Stop, COMDAT

; 2072 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2073 :         return IDirectSoundBuffer_Stop(this);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _IDirectSoundBuffer_Stop@4

; 2074 :     }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?Stop@IDirectSoundBuffer@@QAGJXZ ENDP			; IDirectSoundBuffer::Stop
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?GetStatus@IDirectSoundBuffer@@QAGJPAK@Z
DSOUND	SEGMENT
_this$ = 8
_pdwStatus$ = 12
?GetStatus@IDirectSoundBuffer@@QAGJPAK@Z PROC NEAR	; IDirectSoundBuffer::GetStatus, COMDAT

; 2092 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2093 :         return IDirectSoundBuffer_GetStatus(this, pdwStatus);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pdwStatus$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _IDirectSoundBuffer_GetStatus@8

; 2094 :     }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?GetStatus@IDirectSoundBuffer@@QAGJPAK@Z ENDP		; IDirectSoundBuffer::GetStatus
DSOUND	ENDS
PUBLIC	?RegisterCounters@CPerfMon@DirectSound@@SGXXZ	; DirectSound::CPerfMon::RegisterCounters
PUBLIC	??0CMcpxAPU@DirectSound@@QAE@PAVCDirectSoundSettings@1@@Z ; DirectSound::CMcpxAPU::CMcpxAPU
PUBLIC	?Initialize@CMcpxAPU@DirectSound@@QAEJXZ	; DirectSound::CMcpxAPU::Initialize
PUBLIC	?Play@IDirectSoundBuffer@@QAGJKKK@Z		; IDirectSoundBuffer::Play
PUBLIC	?SetBufferData@IDirectSoundBuffer@@QAGJPAXK@Z	; IDirectSoundBuffer::SetBufferData
;	COMDAT ?wfxSilence@?1??Initialize@CDirectSound@DirectSound@@QAGJXZ@4UtWAVEFORMATEX@@B
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
DSOUND_RD	SEGMENT
?wfxSilence@?1??Initialize@CDirectSound@DirectSound@@QAGJXZ@4UtWAVEFORMATEX@@B DW 01H ; `DirectSound::CDirectSound::Initialize'::`2'::wfxSilence
	DW	01H
	DD	0bb80H
	DD	017700H
	DW	02H
	DW	010H
	DW	00H
DSOUND_RD	ENDS
;	COMDAT ?asSilence@?1??Initialize@CDirectSound@DirectSound@@QAGJXZ@4QBFB
DSOUND_RD	SEGMENT
?asSilence@?1??Initialize@CDirectSound@DirectSound@@QAGJXZ@4QBFB DW 00H ; `DirectSound::CDirectSound::Initialize'::`2'::asSilence
	ORG $+62
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?Initialize@CDirectSound@DirectSound@@QAGJXZ
DSOUND	SEGMENT
tv82 = -128
tv70 = -124
$T41669 = -120
$T41666 = -116
_MixBins$ = -112
_hr$ = -104
_z$ = -100
_dsbd$ = -96
_MixBinVolumePairs$ = -72
_i$ = -4
_this$ = 8
?Initialize@CDirectSound@DirectSound@@QAGJXZ PROC NEAR	; DirectSound::CDirectSound::Initialize, COMDAT

; 2933 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H

; 2934 : 
; 2935 : #ifdef USE_KEEPALIVE_BUFFERS
; 2936 : 
; 2937 :     static const WAVEFORMATEX   wfxSilence              = INIT_PCM_WAVEFORMAT(1, 48000, 16);
; 2938 :     static const SHORT          asSilence[32]           = { 0 };
; 2939 :     DSBUFFERDESC                dsbd;
; 2940 :     DSMIXBINVOLUMEPAIR          MixBinVolumePairs[8];
; 2941 :     DSMIXBINS                   MixBins;
; 2942 :     DWORD                       i, z;
; 2943 : 
; 2944 : #endif // USE_KEEPALIVE_BUFFERS
; 2945 : 
; 2946 :     HRESULT                     hr;
; 2947 : 
; 2948 :     DPF_ENTER();
; 2949 : 
; 2950 :     //
; 2951 :     // Create the shared settings object
; 2952 :     //
; 2953 : 
; 2954 :     hr = HRFROMP(m_pSettings = NEW(CDirectSoundSettings));

  00009	6a 34		 push	 52			; 00000034H
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4
  00013	89 45 8c	 mov	 DWORD PTR $T41666[ebp], eax
  00016	83 7d 8c 00	 cmp	 DWORD PTR $T41666[ebp], 0
  0001a	74 0d		 je	 SHORT $L41667
  0001c	8b 4d 8c	 mov	 ecx, DWORD PTR $T41666[ebp]
  0001f	e8 00 00 00 00	 call	 ??0CDirectSoundSettings@DirectSound@@QAE@XZ ; DirectSound::CDirectSoundSettings::CDirectSoundSettings
  00024	89 45 84	 mov	 DWORD PTR tv70[ebp], eax
  00027	eb 07		 jmp	 SHORT $L41668
$L41667:
  00029	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$L41668:
  00030	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 4d 84	 mov	 ecx, DWORD PTR tv70[ebp]
  00036	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00039	33 d2		 xor	 edx, edx
  0003b	83 7d 84 00	 cmp	 DWORD PTR tv70[ebp], 0
  0003f	0f 95 c2	 setne	 dl
  00042	4a		 dec	 edx
  00043	81 e2 0e 00 07
	80		 and	 edx, -2147024882	; 8007000eH
  00049	89 55 98	 mov	 DWORD PTR _hr$[ebp], edx

; 2955 : 
; 2956 :     //
; 2957 :     // Create the device object
; 2958 :     //
; 2959 : 
; 2960 :     if(SUCCEEDED(hr))

  0004c	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00050	7c 4d		 jl	 SHORT $L36629

; 2961 :     {
; 2962 :         hr = HRFROMP(m_pDevice = NEW(CMcpxAPU(m_pSettings)));

  00052	68 40 05 00 00	 push	 1344			; 00000540H
  00057	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005c	83 c4 04	 add	 esp, 4
  0005f	89 45 88	 mov	 DWORD PTR $T41669[ebp], eax
  00062	83 7d 88 00	 cmp	 DWORD PTR $T41669[ebp], 0
  00066	74 14		 je	 SHORT $L41670
  00068	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0006e	51		 push	 ecx
  0006f	8b 4d 88	 mov	 ecx, DWORD PTR $T41669[ebp]
  00072	e8 00 00 00 00	 call	 ??0CMcpxAPU@DirectSound@@QAE@PAVCDirectSoundSettings@1@@Z ; DirectSound::CMcpxAPU::CMcpxAPU
  00077	89 45 80	 mov	 DWORD PTR tv82[ebp], eax
  0007a	eb 07		 jmp	 SHORT $L41671
$L41670:
  0007c	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$L41671:
  00083	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00086	8b 45 80	 mov	 eax, DWORD PTR tv82[ebp]
  00089	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0008c	33 c9		 xor	 ecx, ecx
  0008e	83 7d 80 00	 cmp	 DWORD PTR tv82[ebp], 0
  00092	0f 95 c1	 setne	 cl
  00095	49		 dec	 ecx
  00096	81 e1 0e 00 07
	80		 and	 ecx, -2147024882	; 8007000eH
  0009c	89 4d 98	 mov	 DWORD PTR _hr$[ebp], ecx
$L36629:

; 2963 :     }
; 2964 : 
; 2965 :     if(SUCCEEDED(hr))

  0009f	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a3	7c 0e		 jl	 SHORT $L36635

; 2966 :     {
; 2967 :         hr = m_pDevice->Initialize();

  000a5	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000a8	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  000ab	e8 00 00 00 00	 call	 ?Initialize@CMcpxAPU@DirectSound@@QAEJXZ ; DirectSound::CMcpxAPU::Initialize
  000b0	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax
$L36635:

; 2968 :     }
; 2969 : 
; 2970 : #ifdef USE_KEEPALIVE_BUFFERS
; 2971 : 
; 2972 :     //
; 2973 :     // Create dummy buffers.  The MCPX refuses to output any data at least 
; 2974 :     // one voice writes to the speaker mixbins.  We'll burn voices in order 
; 2975 :     // to write silence to all the mixbins all the time.
; 2976 :     //
; 2977 : 
; 2978 :     if(SUCCEEDED(hr))

  000b3	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b7	0f 8c 01 01 00
	00		 jl	 $L36637

; 2979 :     {
; 2980 :         ZeroMemory(&dsbd, sizeof(dsbd));

  000bd	6a 18		 push	 24			; 00000018H
  000bf	6a 00		 push	 0
  000c1	8d 45 a0	 lea	 eax, DWORD PTR _dsbd$[ebp]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 _memset
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2981 :         ZeroMemory(&MixBinVolumePairs, sizeof(MixBinVolumePairs));

  000cd	6a 40		 push	 64			; 00000040H
  000cf	6a 00		 push	 0
  000d1	8d 4d b8	 lea	 ecx, DWORD PTR _MixBinVolumePairs$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 _memset
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2982 : 
; 2983 :         dsbd.dwSize = sizeof(dsbd);

  000dd	c7 45 a0 18 00
	00 00		 mov	 DWORD PTR _dsbd$[ebp], 24 ; 00000018H

; 2984 :         dsbd.lpwfxFormat = (LPWAVEFORMATEX)&wfxSilence;

  000e4	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _dsbd$[ebp+12], OFFSET FLAT:?wfxSilence@?1??Initialize@CDirectSound@DirectSound@@QAGJXZ@4UtWAVEFORMATEX@@B

; 2985 :         dsbd.lpMixBins = &MixBins;

  000eb	8d 55 90	 lea	 edx, DWORD PTR _MixBins$[ebp]
  000ee	89 55 b0	 mov	 DWORD PTR _dsbd$[ebp+16], edx

; 2986 : 
; 2987 :         MixBins.dwMixBinCount = NUMELMS(MixBinVolumePairs);

  000f1	c7 45 90 08 00
	00 00		 mov	 DWORD PTR _MixBins$[ebp], 8

; 2988 :         MixBins.lpMixBinVolumePairs = MixBinVolumePairs;

  000f8	8d 45 b8	 lea	 eax, DWORD PTR _MixBinVolumePairs$[ebp]
  000fb	89 45 94	 mov	 DWORD PTR _MixBins$[ebp+4], eax

; 2989 : 
; 2990 :         for(i = 0; SUCCEEDED(hr) && (i < NUMELMS(m_apKeepAliveBuffers)); i++)

  000fe	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00105	eb 09		 jmp	 SHORT $L36640
$L36641:
  00107	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0010a	83 c1 01	 add	 ecx, 1
  0010d	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L36640:
  00110	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00114	0f 8c a4 00 00
	00		 jl	 $L36637
  0011a	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  0011e	0f 83 9a 00 00
	00		 jae	 $L36637

; 2991 :         {
; 2992 :             for(z = 0; z < NUMELMS(MixBinVolumePairs); z++)

  00124	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _z$[ebp], 0
  0012b	eb 09		 jmp	 SHORT $L36643
$L36644:
  0012d	8b 55 9c	 mov	 edx, DWORD PTR _z$[ebp]
  00130	83 c2 01	 add	 edx, 1
  00133	89 55 9c	 mov	 DWORD PTR _z$[ebp], edx
$L36643:
  00136	83 7d 9c 08	 cmp	 DWORD PTR _z$[ebp], 8
  0013a	73 12		 jae	 SHORT $L36645

; 2993 :             {
; 2994 :                 MixBinVolumePairs[z].dwMixBin = (i * NUMELMS(MixBinVolumePairs)) + z;

  0013c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0013f	8b 4d 9c	 mov	 ecx, DWORD PTR _z$[ebp]
  00142	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00145	8b 45 9c	 mov	 eax, DWORD PTR _z$[ebp]
  00148	89 54 c5 b8	 mov	 DWORD PTR _MixBinVolumePairs$[ebp+eax*8], edx

; 2995 :             }

  0014c	eb df		 jmp	 SHORT $L36644
$L36645:

; 2996 : 
; 2997 :             if(DSMIXBIN_SUBMIX == MixBinVolumePairs[NUMELMS(MixBinVolumePairs) - 1].dwMixBin)

  0014e	83 7d f0 1f	 cmp	 DWORD PTR _MixBinVolumePairs$[ebp+56], 31 ; 0000001fH
  00152	75 09		 jne	 SHORT $L36646

; 2998 :             {
; 2999 :                 MixBins.dwMixBinCount--;

  00154	8b 4d 90	 mov	 ecx, DWORD PTR _MixBins$[ebp]
  00157	83 e9 01	 sub	 ecx, 1
  0015a	89 4d 90	 mov	 DWORD PTR _MixBins$[ebp], ecx
$L36646:

; 3000 :             }
; 3001 : 
; 3002 :             hr = CreateSoundBuffer(&dsbd, &m_apKeepAliveBuffers[i], NULL);

  0015d	6a 00		 push	 0
  0015f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00162	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00165	8d 4c 90 18	 lea	 ecx, DWORD PTR [eax+edx*4+24]
  00169	51		 push	 ecx
  0016a	8d 55 a0	 lea	 edx, DWORD PTR _dsbd$[ebp]
  0016d	52		 push	 edx
  0016e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 ?CreateSoundBuffer@CDirectSound@DirectSound@@QAGJPBU_DSBUFFERDESC@@PAPAUIDirectSoundBuffer@@PAUIUnknown@@@Z ; DirectSound::CDirectSound::CreateSoundBuffer
  00177	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 3003 : 
; 3004 :             if(SUCCEEDED(hr))

  0017a	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0017e	7c 1a		 jl	 SHORT $L36648

; 3005 :             {
; 3006 :                 hr = m_apKeepAliveBuffers[i]->SetBufferData((LPVOID)asSilence, sizeof(asSilence));

  00180	6a 40		 push	 64			; 00000040H
  00182	68 00 00 00 00	 push	 OFFSET FLAT:?asSilence@?1??Initialize@CDirectSound@DirectSound@@QAGJXZ@4QBFB
  00187	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0018a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0018d	8b 44 8a 18	 mov	 eax, DWORD PTR [edx+ecx*4+24]
  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 ?SetBufferData@IDirectSoundBuffer@@QAGJPAXK@Z ; IDirectSoundBuffer::SetBufferData
  00197	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax
$L36648:

; 3007 :             }
; 3008 : 
; 3009 :             if(SUCCEEDED(hr))

  0019a	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0019e	7c 19		 jl	 SHORT $L36651

; 3010 :             {
; 3011 :                 hr = m_apKeepAliveBuffers[i]->Play(0, 0, DSBPLAY_LOOPING);

  001a0	6a 01		 push	 1
  001a2	6a 00		 push	 0
  001a4	6a 00		 push	 0
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001a9	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001ac	8b 44 8a 18	 mov	 eax, DWORD PTR [edx+ecx*4+24]
  001b0	50		 push	 eax
  001b1	e8 00 00 00 00	 call	 ?Play@IDirectSoundBuffer@@QAGJKKK@Z ; IDirectSoundBuffer::Play
  001b6	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax
$L36651:

; 3012 :             }
; 3013 :         }

  001b9	e9 49 ff ff ff	 jmp	 $L36641
$L36637:

; 3014 :     }
; 3015 : 
; 3016 : #endif // USE_KEEPALIVE_BUFFERS
; 3017 : 
; 3018 :     //
; 3019 :     // Set up performance counters
; 3020 :     //
; 3021 : 
; 3022 :     if(SUCCEEDED(hr))

  001be	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001c2	7c 05		 jl	 SHORT $L36653

; 3023 :     {
; 3024 :         CPerfMon::RegisterCounters();

  001c4	e8 00 00 00 00	 call	 ?RegisterCounters@CPerfMon@DirectSound@@SGXXZ ; DirectSound::CPerfMon::RegisterCounters
$L36653:

; 3025 :     }
; 3026 : 
; 3027 :     DPF_LEAVE_HRESULT(hr);
; 3028 : 
; 3029 :     return hr;

  001c9	8b 45 98	 mov	 eax, DWORD PTR _hr$[ebp]

; 3030 : }

  001cc	8b e5		 mov	 esp, ebp
  001ce	5d		 pop	 ebp
  001cf	c2 04 00	 ret	 4
?Initialize@CDirectSound@DirectSound@@QAGJXZ ENDP	; DirectSound::CDirectSound::Initialize
; Function compile flags: /Odt
; File c:\xbox\private\inc\dsoundp.h
DSOUND	ENDS
;	COMDAT ?Play@IDirectSoundBuffer@@QAGJKKK@Z
DSOUND	SEGMENT
_this$ = 8
_dwReserved1$ = 12
_dwReserved2$ = 16
_dwFlags$ = 20
?Play@IDirectSoundBuffer@@QAGJKKK@Z PROC NEAR		; IDirectSoundBuffer::Play, COMDAT

; 2062 :     {   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2063 :         return IDirectSoundBuffer_Play(this, dwReserved1, dwReserved2, dwFlags);

  00003	8b 45 14	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR _dwReserved2$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR _dwReserved1$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _IDirectSoundBuffer_Play@16

; 2064 :     }

  00018	5d		 pop	 ebp
  00019	c2 10 00	 ret	 16			; 00000010H
?Play@IDirectSoundBuffer@@QAGJKKK@Z ENDP		; IDirectSoundBuffer::Play
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetBufferData@IDirectSoundBuffer@@QAGJPAXK@Z
DSOUND	SEGMENT
_this$ = 8
_pvBufferData$ = 12
_dwBufferBytes$ = 16
?SetBufferData@IDirectSoundBuffer@@QAGJPAXK@Z PROC NEAR	; IDirectSoundBuffer::SetBufferData, COMDAT

; 2107 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2108 :         return IDirectSoundBuffer_SetBufferData(this, pvBufferData, dwBufferBytes);

  00003	8b 45 10	 mov	 eax, DWORD PTR _dwBufferBytes$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _pvBufferData$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _IDirectSoundBuffer_SetBufferData@12

; 2109 :     }

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
?SetBufferData@IDirectSoundBuffer@@QAGJPAXK@Z ENDP	; IDirectSoundBuffer::SetBufferData
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsperf.h
DSOUND	ENDS
;	COMDAT ?RegisterCounters@CPerfMon@DirectSound@@SGXXZ
DSOUND	SEGMENT
?RegisterCounters@CPerfMon@DirectSound@@SGXXZ PROC NEAR	; DirectSound::CPerfMon::RegisterCounters, COMDAT

; 65   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   :     }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?RegisterCounters@CPerfMon@DirectSound@@SGXXZ ENDP	; DirectSound::CPerfMon::RegisterCounters
DSOUND	ENDS
EXTRN	_g_dwDirectSoundPoolMemoryUsage:DWORD
EXTRN	_g_dwDirectSoundPhysicalMemoryUsage:DWORD
EXTRN	_g_dwDirectSoundFree2dVoices:DWORD
EXTRN	_g_dwDirectSoundFree3dVoices:DWORD
EXTRN	_g_dwDirectSoundFreeBufferSGEs:DWORD
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT ?GetCaps@CDirectSound@DirectSound@@QAGJPAU_DSCAPS@@@Z
DSOUND	SEGMENT
$T41685 = -12
$T41684 = -8
___AutoLock$ = -4
_this$ = 8
_pdsc$ = 12
?GetCaps@CDirectSound@DirectSound@@QAGJPAU_DSCAPS@@@Z PROC NEAR ; DirectSound::CDirectSound::GetCaps, COMDAT

; 3056 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3057 :     DPF_ENTER();
; 3058 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L36659
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41684[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41684[ebp]
  00029	eb 45		 jmp	 SHORT $L36657
$L36659:

; 3059 : 
; 3060 : #ifdef VALIDATE_PARAMETERS
; 3061 : 
; 3062 :     if(!pdsc)
; 3063 :     {
; 3064 :         DPF_ERROR("DSCAPS not supplied");
; 3065 :     }
; 3066 : 
; 3067 : #endif // VALIDATE_PARAMETERS
; 3068 :     
; 3069 :     pdsc->dwFree2DBuffers = g_dwDirectSoundFree2dVoices;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _pdsc$[ebp]
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_dwDirectSoundFree2dVoices
  00034	89 08		 mov	 DWORD PTR [eax], ecx

; 3070 :     pdsc->dwFree3DBuffers = g_dwDirectSoundFree3dVoices;

  00036	8b 55 0c	 mov	 edx, DWORD PTR _pdsc$[ebp]
  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_dwDirectSoundFree3dVoices
  0003e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 3071 :     pdsc->dwFreeBufferSGEs = g_dwDirectSoundFreeBufferSGEs;

  00041	8b 4d 0c	 mov	 ecx, DWORD PTR _pdsc$[ebp]
  00044	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_dwDirectSoundFreeBufferSGEs
  0004a	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 3072 :     pdsc->dwMemoryAllocated = g_dwDirectSoundPoolMemoryUsage + g_dwDirectSoundPhysicalMemoryUsage;

  0004d	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_dwDirectSoundPoolMemoryUsage
  00052	03 05 00 00 00
	00		 add	 eax, DWORD PTR _g_dwDirectSoundPhysicalMemoryUsage
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _pdsc$[ebp]
  0005b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 3073 : 
; 3074 :     DPF_LEAVE_HRESULT(DS_OK);
; 3075 : 
; 3076 :     return DS_OK;

  0005e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T41685[ebp], 0
  00065	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00068	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0006d	8b 45 f4	 mov	 eax, DWORD PTR $T41685[ebp]
$L36657:

; 3077 : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
?GetCaps@CDirectSound@DirectSound@@QAGJPAU_DSCAPS@@@Z ENDP ; DirectSound::CDirectSound::GetCaps
DSOUND	ENDS
PUBLIC	??0CDirectSoundBuffer@DirectSound@@QAE@PAVCDirectSound@1@@Z ; DirectSound::CDirectSoundBuffer::CDirectSoundBuffer
PUBLIC	?Initialize@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSBUFFERDESC@@@Z ; DirectSound::CDirectSoundBuffer::Initialize
; Function compile flags: /Odt
;	COMDAT ?CreateSoundBuffer@CDirectSound@DirectSound@@QAGJPBU_DSBUFFERDESC@@PAPAUIDirectSoundBuffer@@PAUIUnknown@@@Z
DSOUND	SEGMENT
tv84 = -32
tv74 = -28
$T41695 = -24
$T41690 = -20
$T41689 = -16
___AutoLock$ = -12
_hr$ = -8
_pBuffer$ = -4
_this$ = 8
_pdsbd$ = 12
_ppBuffer$ = 16
_pControllingUnknown$ = 20
?CreateSoundBuffer@CDirectSound@DirectSound@@QAGJPBU_DSBUFFERDESC@@PAPAUIDirectSoundBuffer@@PAUIUnknown@@@Z PROC NEAR ; DirectSound::CDirectSound::CreateSoundBuffer, COMDAT

; 3108 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 3109 :     CDirectSoundBuffer *    pBuffer;
; 3110 :     HRESULT                 hr;
; 3111 : 
; 3112 :     DPF_ENTER();
; 3113 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 17		 je	 SHORT $L36673
  00017	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR $T41689[ebp], -2147467259 ; 80004005H
  0001e	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f0	 mov	 eax, DWORD PTR $T41689[ebp]
  00029	e9 ac 00 00 00	 jmp	 $L36669
$L36673:

; 3114 : 
; 3115 : #ifdef VALIDATE_PARAMETERS
; 3116 : 
; 3117 :     if(!ppBuffer)
; 3118 :     {
; 3119 :         DPF_ERROR("Failed to supply an LPDIRECTSOUNDBUFFER *");
; 3120 :     }
; 3121 :     
; 3122 :     if(pControllingUnknown)
; 3123 :     {
; 3124 :         DPF_ERROR("Aggregation is not supported");
; 3125 :     }
; 3126 : 
; 3127 : #endif // VALIDATE_PARAMETERS
; 3128 : 
; 3129 :     hr = HRFROMP(pBuffer = NEW(CDirectSoundBuffer(this)));

  0002e	6a 24		 push	 36			; 00000024H
  00030	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00035	83 c4 04	 add	 esp, 4
  00038	89 45 ec	 mov	 DWORD PTR $T41690[ebp], eax
  0003b	83 7d ec 00	 cmp	 DWORD PTR $T41690[ebp], 0
  0003f	74 11		 je	 SHORT $L41691
  00041	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00044	50		 push	 eax
  00045	8b 4d ec	 mov	 ecx, DWORD PTR $T41690[ebp]
  00048	e8 00 00 00 00	 call	 ??0CDirectSoundBuffer@DirectSound@@QAE@PAVCDirectSound@1@@Z ; DirectSound::CDirectSoundBuffer::CDirectSoundBuffer
  0004d	89 45 e4	 mov	 DWORD PTR tv74[ebp], eax
  00050	eb 07		 jmp	 SHORT $L41692
$L41691:
  00052	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$L41692:
  00059	8b 4d e4	 mov	 ecx, DWORD PTR tv74[ebp]
  0005c	89 4d fc	 mov	 DWORD PTR _pBuffer$[ebp], ecx
  0005f	33 d2		 xor	 edx, edx
  00061	83 7d fc 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00065	0f 95 c2	 setne	 dl
  00068	4a		 dec	 edx
  00069	81 e2 0e 00 07
	80		 and	 edx, -2147024882	; 8007000eH
  0006f	89 55 f8	 mov	 DWORD PTR _hr$[ebp], edx

; 3130 : 
; 3131 :     if(SUCCEEDED(hr))

  00072	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00076	7c 10		 jl	 SHORT $L36681

; 3132 :     {
; 3133 :         hr = pBuffer->Initialize(pdsbd);

  00078	8b 45 0c	 mov	 eax, DWORD PTR _pdsbd$[ebp]
  0007b	50		 push	 eax
  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 ?Initialize@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSBUFFERDESC@@@Z ; DirectSound::CDirectSoundBuffer::Initialize
  00085	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L36681:

; 3134 :     }
; 3135 : 
; 3136 :     if(SUCCEEDED(hr))

  00088	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0008c	7c 22		 jl	 SHORT $L36683

; 3137 :     {
; 3138 :         *ppBuffer = pBuffer;

  0008e	83 7d fc 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00092	74 0b		 je	 SHORT $L41693
  00094	8b 55 fc	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  00097	83 c2 1c	 add	 edx, 28			; 0000001cH
  0009a	89 55 e0	 mov	 DWORD PTR tv84[ebp], edx
  0009d	eb 07		 jmp	 SHORT $L41694
$L41693:
  0009f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
$L41694:
  000a6	8b 45 10	 mov	 eax, DWORD PTR _ppBuffer$[ebp]
  000a9	8b 4d e0	 mov	 ecx, DWORD PTR tv84[ebp]
  000ac	89 08		 mov	 DWORD PTR [eax], ecx

; 3139 :     }
; 3140 :     else

  000ae	eb 19		 jmp	 SHORT $L36684
$L36683:

; 3141 :     {
; 3142 :         RELEASE(pBuffer);

  000b0	83 7d fc 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  000b4	74 13		 je	 SHORT $L36684
  000b6	8b 55 fc	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  000b9	8b 02		 mov	 eax, DWORD PTR [edx]
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  000be	51		 push	 ecx
  000bf	ff 50 08	 call	 DWORD PTR [eax+8]
  000c2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pBuffer$[ebp], 0
$L36684:

; 3143 :     }
; 3144 : 
; 3145 :     DPF_LEAVE_HRESULT(hr);
; 3146 : 
; 3147 :     return hr;

  000c9	8b 55 f8	 mov	 edx, DWORD PTR _hr$[ebp]
  000cc	89 55 e8	 mov	 DWORD PTR $T41695[ebp], edx
  000cf	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  000d2	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  000d7	8b 45 e8	 mov	 eax, DWORD PTR $T41695[ebp]
$L36669:

; 3148 : }

  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 10 00	 ret	 16			; 00000010H
?CreateSoundBuffer@CDirectSound@DirectSound@@QAGJPBU_DSBUFFERDESC@@PAPAUIDirectSoundBuffer@@PAUIUnknown@@@Z ENDP ; DirectSound::CDirectSound::CreateSoundBuffer
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?GetSpeakerConfig@CDirectSound@DirectSound@@QAGJPAK@Z
DSOUND	SEGMENT
$T41700 = -12
$T41699 = -8
___AutoLock$ = -4
_this$ = 8
_pdwSpeakerConfig$ = 12
?GetSpeakerConfig@CDirectSound@DirectSound@@QAGJPAK@Z PROC NEAR ; DirectSound::CDirectSound::GetSpeakerConfig, COMDAT

; 3249 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3250 :     DPF_ENTER();
; 3251 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L36692
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41699[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41699[ebp]
  00029	eb 26		 jmp	 SHORT $L36690
$L36692:

; 3252 : 
; 3253 : #ifdef VALIDATE_PARAMETERS
; 3254 : 
; 3255 :     if(!pdwSpeakerConfig)
; 3256 :     {
; 3257 :         DPF_ERROR("Failed to supply speaker config buffer");
; 3258 :     }
; 3259 : 
; 3260 : #endif // VALIDATE_PARAMETERS
; 3261 : 
; 3262 :     *pdwSpeakerConfig = m_pSettings->m_dwSpeakerConfig & ~DSSPEAKER_ENABLE_HEADPHONES;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00031	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00034	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _pdwSpeakerConfig$[ebp]
  0003d	89 10		 mov	 DWORD PTR [eax], edx

; 3263 : 
; 3264 :     DPF_LEAVE_HRESULT(DS_OK);
; 3265 : 
; 3266 :     return DS_OK;

  0003f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T41700[ebp], 0
  00046	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00049	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0004e	8b 45 f4	 mov	 eax, DWORD PTR $T41700[ebp]
$L36690:

; 3267 : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
?GetSpeakerConfig@CDirectSound@DirectSound@@QAGJPAK@Z ENDP ; DirectSound::CDirectSound::GetSpeakerConfig
DSOUND	ENDS
PUBLIC	?SetEffectData@CMcpxAPU@DirectSound@@QAEJKKPBXKK@Z ; DirectSound::CMcpxAPU::SetEffectData
; Function compile flags: /Odt
;	COMDAT ?SetEffectData@CDirectSound@DirectSound@@QAGJKKPBXKK@Z
DSOUND	SEGMENT
$T41705 = -16
$T41704 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
_dwEffectIndex$ = 12
_dwOffset$ = 16
_pvData$ = 20
_dwDataSize$ = 24
_dwFlags$ = 28
?SetEffectData@CDirectSound@DirectSound@@QAGJKKPBXKK@Z PROC NEAR ; DirectSound::CDirectSound::SetEffectData, COMDAT

; 3372 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 3373 :     HRESULT                 hr;
; 3374 : 
; 3375 :     DPF_ENTER();
; 3376 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L36707
  00017	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41704[ebp], -2147467259 ; 80004005H
  0001e	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f4	 mov	 eax, DWORD PTR $T41704[ebp]
  00029	eb 33		 jmp	 SHORT $L36704
$L36707:

; 3377 : 
; 3378 : #ifdef VALIDATE_PARAMETERS
; 3379 : 
; 3380 :     if(dwOffset & 3)
; 3381 :     {
; 3382 :         DPF_ERROR("Offset must be DWORD-aligned");
; 3383 :     }
; 3384 : 
; 3385 :     if(!pvData)
; 3386 :     {
; 3387 :         DPF_ERROR("Failed to supply a data buffer");
; 3388 :     }
; 3389 : 
; 3390 :     if(!dwDataSize)
; 3391 :     {
; 3392 :         DPF_ERROR("Invalid data size");
; 3393 :     }
; 3394 : 
; 3395 :     if(dwDataSize & 3)
; 3396 :     {
; 3397 :         DPF_ERROR("Data size must be DWORD-aligned");
; 3398 :     }
; 3399 : 
; 3400 :     if(dwFlags & ~DSFX_VALID)
; 3401 :     {
; 3402 :         DPF_ERROR("Invalid flags");
; 3403 :     }
; 3404 : 
; 3405 : #endif // VALIDATE_PARAMETERS
; 3406 : 
; 3407 :     hr = m_pDevice->SetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize, dwFlags);

  0002b	8b 45 1c	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 18	 mov	 ecx, DWORD PTR _dwDataSize$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 14	 mov	 edx, DWORD PTR _pvData$[ebp]
  00036	52		 push	 edx
  00037	8b 45 10	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _dwEffectIndex$[ebp]
  0003e	51		 push	 ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00042	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00045	e8 00 00 00 00	 call	 ?SetEffectData@CMcpxAPU@DirectSound@@QAEJKKPBXKK@Z ; DirectSound::CMcpxAPU::SetEffectData
  0004a	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 3408 : 
; 3409 :     DPF_LEAVE_HRESULT(hr);
; 3410 : 
; 3411 :     return hr;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00050	89 45 f0	 mov	 DWORD PTR $T41705[ebp], eax
  00053	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00056	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0005b	8b 45 f0	 mov	 eax, DWORD PTR $T41705[ebp]
$L36704:

; 3412 : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 18 00	 ret	 24			; 00000018H
?SetEffectData@CDirectSound@DirectSound@@QAGJKKPBXKK@Z ENDP ; DirectSound::CDirectSound::SetEffectData
DSOUND	ENDS
PUBLIC	?SetEffectData@CMcpxGPDspManager@DirectSound@@QAEJKKPBXKK@Z ; DirectSound::CMcpxGPDspManager::SetEffectData
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpapu.h
;	COMDAT ?SetEffectData@CMcpxAPU@DirectSound@@QAEJKKPBXKK@Z
DSOUND	SEGMENT
_this$ = -4
_dwEffectIndex$ = 8
_dwOffset$ = 12
_pvData$ = 16
_dwDataSize$ = 20
_dwFlags$ = 24
?SetEffectData@CMcpxAPU@DirectSound@@QAEJKKPBXKK@Z PROC NEAR ; DirectSound::CMcpxAPU::SetEffectData, COMDAT
; _this$ = ecx

; 211  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 212  :         ASSERT(m_pGpDspManager);
; 213  :         ASSERT(m_dwState & MCPX_APUSTATE_GPIMAGE);
; 214  : 
; 215  :         return m_pGpDspManager->SetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize, dwFlags);

  00007	8b 45 18	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 14	 mov	 ecx, DWORD PTR _dwDataSize$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 10	 mov	 edx, DWORD PTR _pvData$[ebp]
  00012	52		 push	 edx
  00013	8b 45 0c	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _dwEffectIndex$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00021	e8 00 00 00 00	 call	 ?SetEffectData@CMcpxGPDspManager@DirectSound@@QAEJKKPBXKK@Z ; DirectSound::CMcpxGPDspManager::SetEffectData

; 216  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 14 00	 ret	 20			; 00000014H
?SetEffectData@CMcpxAPU@DirectSound@@QAEJKKPBXKK@Z ENDP	; DirectSound::CMcpxAPU::SetEffectData
DSOUND	ENDS
PUBLIC	?GetEffectData@CMcpxAPU@DirectSound@@QAEJKKPAXK@Z ; DirectSound::CMcpxAPU::GetEffectData
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT ?GetEffectData@CDirectSound@DirectSound@@QAGJKKPAXK@Z
DSOUND	SEGMENT
$T41713 = -16
$T41712 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
_dwEffectIndex$ = 12
_dwOffset$ = 16
_pvData$ = 20
_dwDataSize$ = 24
?GetEffectData@CDirectSound@DirectSound@@QAGJKKPAXK@Z PROC NEAR ; DirectSound::CDirectSound::GetEffectData, COMDAT

; 3444 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 3445 :     HRESULT                 hr;
; 3446 : 
; 3447 :     DPF_ENTER();
; 3448 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L36720
  00017	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41712[ebp], -2147467259 ; 80004005H
  0001e	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f4	 mov	 eax, DWORD PTR $T41712[ebp]
  00029	eb 2f		 jmp	 SHORT $L36717
$L36720:

; 3449 : 
; 3450 : #ifdef VALIDATE_PARAMETERS
; 3451 : 
; 3452 :     if(dwOffset & 3)
; 3453 :     {
; 3454 :         DPF_ERROR("Offset must be DWORD-aligned");
; 3455 :     }
; 3456 : 
; 3457 :     if(!pvData)
; 3458 :     {
; 3459 :         DPF_ERROR("Failed to supply a data buffer");
; 3460 :     }
; 3461 : 
; 3462 :     if(!dwDataSize)
; 3463 :     {
; 3464 :         DPF_ERROR("Invalid data size");
; 3465 :     }
; 3466 : 
; 3467 :     if(dwDataSize & 3)
; 3468 :     {
; 3469 :         DPF_ERROR("Data size must be DWORD-aligned");
; 3470 :     }
; 3471 : 
; 3472 : #endif // VALIDATE_PARAMETERS
; 3473 : 
; 3474 :     hr = m_pDevice->GetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize);

  0002b	8b 45 18	 mov	 eax, DWORD PTR _dwDataSize$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 14	 mov	 ecx, DWORD PTR _pvData$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 10	 mov	 edx, DWORD PTR _dwOffset$[ebp]
  00036	52		 push	 edx
  00037	8b 45 0c	 mov	 eax, DWORD PTR _dwEffectIndex$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00041	e8 00 00 00 00	 call	 ?GetEffectData@CMcpxAPU@DirectSound@@QAEJKKPAXK@Z ; DirectSound::CMcpxAPU::GetEffectData
  00046	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 3475 : 
; 3476 :     DPF_LEAVE_HRESULT(hr);
; 3477 : 
; 3478 :     return hr;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _hr$[ebp]
  0004c	89 55 f0	 mov	 DWORD PTR $T41713[ebp], edx
  0004f	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00052	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00057	8b 45 f0	 mov	 eax, DWORD PTR $T41713[ebp]
$L36717:

; 3479 : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 14 00	 ret	 20			; 00000014H
?GetEffectData@CDirectSound@DirectSound@@QAGJKKPAXK@Z ENDP ; DirectSound::CDirectSound::GetEffectData
DSOUND	ENDS
PUBLIC	?GetEffectData@CMcpxGPDspManager@DirectSound@@QAEJKKPAXK@Z ; DirectSound::CMcpxGPDspManager::GetEffectData
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpapu.h
;	COMDAT ?GetEffectData@CMcpxAPU@DirectSound@@QAEJKKPAXK@Z
DSOUND	SEGMENT
_this$ = -4
_dwEffectIndex$ = 8
_dwOffset$ = 12
_pvData$ = 16
_dwDataSize$ = 20
?GetEffectData@CMcpxAPU@DirectSound@@QAEJKKPAXK@Z PROC NEAR ; DirectSound::CMcpxAPU::GetEffectData, COMDAT
; _this$ = ecx

; 219  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  :         ASSERT(m_pGpDspManager);
; 221  :         ASSERT(m_dwState & MCPX_APUSTATE_GPIMAGE);
; 222  : 
; 223  :         return m_pGpDspManager->GetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize);

  00007	8b 45 14	 mov	 eax, DWORD PTR _dwDataSize$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _pvData$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR _dwOffset$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR _dwEffectIndex$[ebp]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0001d	e8 00 00 00 00	 call	 ?GetEffectData@CMcpxGPDspManager@DirectSound@@QAEJKKPAXK@Z ; DirectSound::CMcpxGPDspManager::GetEffectData

; 224  :     }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 10 00	 ret	 16			; 00000010H
?GetEffectData@CMcpxAPU@DirectSound@@QAEJKKPAXK@Z ENDP	; DirectSound::CMcpxAPU::GetEffectData
DSOUND	ENDS
PUBLIC	?CommitEffectData@CMcpxAPU@DirectSound@@QAEJXZ	; DirectSound::CMcpxAPU::CommitEffectData
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT ?CommitEffectData@CDirectSound@DirectSound@@QAGJXZ
DSOUND	SEGMENT
$T41721 = -16
$T41720 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
?CommitEffectData@CDirectSound@DirectSound@@QAGJXZ PROC NEAR ; DirectSound::CDirectSound::CommitEffectData, COMDAT

; 3505 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 3506 :     HRESULT                 hr;
; 3507 : 
; 3508 :     DPF_ENTER();
; 3509 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L36730
  00017	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41720[ebp], -2147467259 ; 80004005H
  0001e	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f4	 mov	 eax, DWORD PTR $T41720[ebp]
  00029	eb 1f		 jmp	 SHORT $L36727
$L36730:

; 3510 : 
; 3511 :     hr = m_pDevice->CommitEffectData();

  0002b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00031	e8 00 00 00 00	 call	 ?CommitEffectData@CMcpxAPU@DirectSound@@QAEJXZ ; DirectSound::CMcpxAPU::CommitEffectData
  00036	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 3512 : 
; 3513 :     DPF_LEAVE_HRESULT(hr);
; 3514 : 
; 3515 :     return hr;

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _hr$[ebp]
  0003c	89 4d f0	 mov	 DWORD PTR $T41721[ebp], ecx
  0003f	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00042	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00047	8b 45 f0	 mov	 eax, DWORD PTR $T41721[ebp]
$L36727:

; 3516 : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?CommitEffectData@CDirectSound@DirectSound@@QAGJXZ ENDP	; DirectSound::CDirectSound::CommitEffectData
DSOUND	ENDS
PUBLIC	?CommitChanges@CMcpxGPDspManager@DirectSound@@QAEXKK@Z ; DirectSound::CMcpxGPDspManager::CommitChanges
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpapu.h
;	COMDAT ?CommitEffectData@CMcpxAPU@DirectSound@@QAEJXZ
DSOUND	SEGMENT
_this$ = -4
?CommitEffectData@CMcpxAPU@DirectSound@@QAEJXZ PROC NEAR ; DirectSound::CMcpxAPU::CommitEffectData, COMDAT
; _this$ = ecx

; 227  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 228  :         ASSERT(m_pGpDspManager);
; 229  :         ASSERT(m_dwState & MCPX_APUSTATE_GPIMAGE);
; 230  : 
; 231  :         m_pGpDspManager->CommitChanges(0, 0);

  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00011	e8 00 00 00 00	 call	 ?CommitChanges@CMcpxGPDspManager@DirectSound@@QAEXKK@Z ; DirectSound::CMcpxGPDspManager::CommitChanges

; 232  : 
; 233  :         return DS_OK;

  00016	33 c0		 xor	 eax, eax

; 234  :     }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?CommitEffectData@CMcpxAPU@DirectSound@@QAEJXZ ENDP	; DirectSound::CMcpxAPU::CommitEffectData
DSOUND	ENDS
PUBLIC	?SetMixBinHeadroom@CMcpxAPU@DirectSound@@QAEJK@Z ; DirectSound::CMcpxAPU::SetMixBinHeadroom
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT ?SetMixBinHeadroom@CDirectSound@DirectSound@@QAGJKK@Z
DSOUND	SEGMENT
$T41729 = -16
$T41728 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
_dwMixBin$ = 12
_dwHeadroom$ = 16
?SetMixBinHeadroom@CDirectSound@DirectSound@@QAGJKK@Z PROC NEAR ; DirectSound::CDirectSound::SetMixBinHeadroom, COMDAT

; 3544 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 3545 :     HRESULT                 hr;
; 3546 :     
; 3547 :     DPF_ENTER();
; 3548 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L36741
  00017	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41728[ebp], -2147467259 ; 80004005H
  0001e	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f4	 mov	 eax, DWORD PTR $T41728[ebp]
  00029	eb 33		 jmp	 SHORT $L36738
$L36741:

; 3549 : 
; 3550 : #ifdef VALIDATE_PARAMETERS
; 3551 : 
; 3552 :     if(dwMixBin >= DSMIXBIN_COUNT)
; 3553 :     {
; 3554 :         DPF_ERROR("Invalid mixbin");
; 3555 :     }
; 3556 : 
; 3557 :     if((dwHeadroom < DSHEADROOM_MIN) || (dwHeadroom > DSHEADROOM_MAX))
; 3558 :     {
; 3559 :         DPF_ERROR("Invalid headroom value");
; 3560 :     }
; 3561 : 
; 3562 : #endif // VALIDATE_PARAMETERS
; 3563 : 
; 3564 :     //
; 3565 :     // Update the settings object
; 3566 :     //
; 3567 : 
; 3568 :     m_pSettings->m_abMixBinHeadroom[dwMixBin] = (BYTE)dwHeadroom;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00031	8b 55 0c	 mov	 edx, DWORD PTR _dwMixBin$[ebp]
  00034	8a 45 10	 mov	 al, BYTE PTR _dwHeadroom$[ebp]
  00037	88 44 11 14	 mov	 BYTE PTR [ecx+edx+20], al

; 3569 :     
; 3570 :     //
; 3571 :     // Update the implementation object
; 3572 :     //
; 3573 : 
; 3574 :     hr = m_pDevice->SetMixBinHeadroom(dwMixBin);

  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _dwMixBin$[ebp]
  0003e	51		 push	 ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00042	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00045	e8 00 00 00 00	 call	 ?SetMixBinHeadroom@CMcpxAPU@DirectSound@@QAEJK@Z ; DirectSound::CMcpxAPU::SetMixBinHeadroom
  0004a	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 3575 : 
; 3576 :     DPF_LEAVE_HRESULT(hr);
; 3577 : 
; 3578 :     return hr;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00050	89 45 f0	 mov	 DWORD PTR $T41729[ebp], eax
  00053	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00056	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0005b	8b 45 f0	 mov	 eax, DWORD PTR $T41729[ebp]
$L36738:

; 3579 : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 0c 00	 ret	 12			; 0000000cH
?SetMixBinHeadroom@CDirectSound@DirectSound@@QAGJKK@Z ENDP ; DirectSound::CDirectSound::SetMixBinHeadroom
DSOUND	ENDS
EXTRN	__imp__KeQuerySystemTime@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetTime@CDirectSound@DirectSound@@QAGJPA_J@Z
DSOUND	SEGMENT
_this$ = 8
_prtCurrent$ = 12
?GetTime@CDirectSound@DirectSound@@QAGJPA_J@Z PROC NEAR	; DirectSound::CDirectSound::GetTime, COMDAT

; 4264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4265 :     DPF_ENTER();    
; 4266 : 
; 4267 : #ifdef VALIDATE_PARAMETERS
; 4268 : 
; 4269 :     if(!prtCurrent)
; 4270 :     {
; 4271 :         DPF_ERROR("Failed to specify a time buffer");
; 4272 :     }
; 4273 : 
; 4274 : #endif // VALIDATE_PARAMETERS
; 4275 : 
; 4276 :     KeQuerySystemTime((PLARGE_INTEGER)prtCurrent);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _prtCurrent$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQuerySystemTime@4

; 4277 : 
; 4278 :     DPF_LEAVE_HRESULT(DS_OK);
; 4279 : 
; 4280 :     return DS_OK;

  0000d	33 c0		 xor	 eax, eax

; 4281 : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?GetTime@CDirectSound@DirectSound@@QAGJPA_J@Z ENDP	; DirectSound::CDirectSound::GetTime
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?GetOutputLevels@CDirectSound@DirectSound@@QAGJPAU_DSOUTPUTLEVELS@@H@Z
DSOUND	SEGMENT
_pDspLevels$ = -4
_this$ = 8
_pLevels$ = 12
_bReset$ = 16
?GetOutputLevels@CDirectSound@DirectSound@@QAGJPAU_DSOUTPUTLEVELS@@H@Z PROC NEAR ; DirectSound::CDirectSound::GetOutputLevels, COMDAT

; 4308 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4309 :     PDSOUTPUTLEVELS pDspLevels;
; 4310 :     DPF_ENTER();    
; 4311 : 
; 4312 : #ifdef VALIDATE_PARAMETERS
; 4313 : 
; 4314 :     if(!pLevels)
; 4315 :     {
; 4316 :         DPF_ERROR("Failed to specify an output level buffer");
; 4317 :     }
; 4318 : 
; 4319 : #endif // VALIDATE_PARAMETERS
; 4320 : 
; 4321 :     //
; 4322 :     // map a data struct on top the of EP dsp P ram location where
; 4323 :     // the output levels get cached, twice every 5.33ms
; 4324 :     //
; 4325 : 
; 4326 :     pDspLevels = (PDSOUTPUTLEVELS) ((PUCHAR) XPCICFG_APU_MEMORY_REGISTER_BASE_0 + 
; 4327 :         NV_PAPU_EPPMEM(0) +
; 4328 :         EP_OFFSET_OUTPUT_LEVELS_ANALOG_PEAK*sizeof(DWORD));

  00004	b8 00 a0 05 00	 mov	 eax, 368640		; 0005a000H
  00009	05 ac 06 80 fe	 add	 eax, -25164116		; fe8006acH
  0000e	89 45 fc	 mov	 DWORD PTR _pDspLevels$[ebp], eax

; 4329 : 
; 4330 :     //
; 4331 :     // copy levels to caller supplied buffer
; 4332 :     //
; 4333 : 
; 4334 :     memcpy(pLevels, pDspLevels, sizeof(DSOUTPUTLEVELS));

  00011	6a 40		 push	 64			; 00000040H
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _pDspLevels$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR _pLevels$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 _memcpy
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4335 : 
; 4336 :     //
; 4337 :     // if the caller wants to reset the historical max values
; 4338 :     // reset them now
; 4339 :     //
; 4340 : 
; 4341 :     if (bReset) {

  00023	83 7d 10 00	 cmp	 DWORD PTR _bReset$[ebp], 0
  00027	74 4f		 je	 SHORT $L36762

; 4342 : 
; 4343 :         pDspLevels->dwAnalogLeftTotalPeak = 0;          // analog peak

  00029	8b 45 fc	 mov	 eax, DWORD PTR _pDspLevels$[ebp]
  0002c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 4344 :         pDspLevels->dwAnalogRightTotalPeak = 0;

  00032	8b 4d fc	 mov	 ecx, DWORD PTR _pDspLevels$[ebp]
  00035	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 4345 :         pDspLevels->dwDigitalFrontLeftPeak = 0;         // digital peak levels

  0003c	8b 55 fc	 mov	 edx, DWORD PTR _pDspLevels$[ebp]
  0003f	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 4346 :         pDspLevels->dwDigitalFrontCenterPeak = 0;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _pDspLevels$[ebp]
  00049	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 4347 :         pDspLevels->dwDigitalFrontRightPeak = 0;

  00050	8b 4d fc	 mov	 ecx, DWORD PTR _pDspLevels$[ebp]
  00053	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 4348 :         pDspLevels->dwDigitalBackLeftPeak = 0;

  0005a	8b 55 fc	 mov	 edx, DWORD PTR _pDspLevels$[ebp]
  0005d	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 4349 :         pDspLevels->dwDigitalBackRightPeak = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _pDspLevels$[ebp]
  00067	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 4350 :         pDspLevels->dwDigitalLowFrequencyPeak = 0;

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _pDspLevels$[ebp]
  00071	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
$L36762:

; 4351 : 
; 4352 :     }
; 4353 : 
; 4354 :     DPF_LEAVE_HRESULT(DS_OK);
; 4355 : 
; 4356 :     return DS_OK;

  00078	33 c0		 xor	 eax, eax

; 4357 : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 0c 00	 ret	 12			; 0000000cH
?GetOutputLevels@CDirectSound@DirectSound@@QAGJPAU_DSOUTPUTLEVELS@@H@Z ENDP ; DirectSound::CDirectSound::GetOutputLevels
DSOUND	ENDS
PUBLIC	?DoWork@CMcpxAPU@DirectSound@@QAEXXZ		; DirectSound::CMcpxAPU::DoWork
; Function compile flags: /Odt
;	COMDAT ?DoWork@CDirectSound@DirectSound@@QAGXXZ
DSOUND	SEGMENT
___AutoLock$ = -4
_this$ = 8
?DoWork@CDirectSound@DirectSound@@QAGXXZ PROC NEAR	; DirectSound::CDirectSound::DoWork, COMDAT

; 4383 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4384 :     DPF_ENTER();
; 4385 :     ENTER_EXTERNAL_METHOD_VOID();

  00004	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00007	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00013	74 0a		 je	 SHORT $L36769
  00015	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00018	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0001d	eb 13		 jmp	 SHORT $L36767
$L36769:

; 4386 : 
; 4387 :     m_pDevice->DoWork();

  0001f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00025	e8 00 00 00 00	 call	 ?DoWork@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::DoWork

; 4388 : 
; 4389 :     DPF_LEAVE_VOID();
; 4390 : }

  0002a	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0002d	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
$L36767:
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?DoWork@CDirectSound@DirectSound@@QAGXXZ ENDP		; DirectSound::CDirectSound::DoWork
DSOUND	ENDS
PUBLIC	?ServiceDeferredCommandsLow@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::ServiceDeferredCommandsLow
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpapu.h
;	COMDAT ?DoWork@CMcpxAPU@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?DoWork@CMcpxAPU@DirectSound@@QAEXXZ PROC NEAR		; DirectSound::CMcpxAPU::DoWork, COMDAT
; _this$ = ecx

; 259  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 260  :         ServiceDeferredCommandsLow();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?ServiceDeferredCommandsLow@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::ServiceDeferredCommandsLow

; 261  :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?DoWork@CMcpxAPU@DirectSound@@QAEXXZ ENDP		; DirectSound::CMcpxAPU::DoWork
DSOUND	ENDS
PUBLIC	??0CDirectSoundVoiceSettings@DirectSound@@QAE@XZ ; DirectSound::CDirectSoundVoiceSettings::CDirectSoundVoiceSettings
PUBLIC	??_7CDirectSoundVoiceSettings@DirectSound@@6B@	; DirectSound::CDirectSoundVoiceSettings::`vftable'
PUBLIC	??_GCDirectSoundVoiceSettings@DirectSound@@UAEPAXI@Z ; DirectSound::CDirectSoundVoiceSettings::`scalar deleting destructor'
EXTRN	??_ECDirectSoundVoiceSettings@DirectSound@@UAEPAXI@Z:NEAR ; DirectSound::CDirectSoundVoiceSettings::`vector deleting destructor'
;	COMDAT ??_7CDirectSoundVoiceSettings@DirectSound@@6B@
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
CONST	SEGMENT
??_7CDirectSoundVoiceSettings@DirectSound@@6B@ DD FLAT:??_ECDirectSoundVoiceSettings@DirectSound@@UAEPAXI@Z ; DirectSound::CDirectSoundVoiceSettings::`vftable'
	DD	FLAT:?AddRef@CRefCount@DirectSound@@UAGKXZ
	DD	FLAT:?Release@CRefCount@DirectSound@@UAGKXZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CDirectSoundVoiceSettings@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CDirectSoundVoiceSettings@DirectSound@@QAE@XZ PROC NEAR ; DirectSound::CDirectSoundVoiceSettings::CDirectSoundVoiceSettings, COMDAT
; _this$ = ecx

; 4487 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 01		 push	 1
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CRefCount@DirectSound@@QAE@K@Z ; DirectSound::CRefCount::CRefCount
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDirectSoundVoiceSettings@DirectSound@@6B@

; 4488 :     DPF_ENTER();
; 4489 :     DPF_LEAVE_VOID();
; 4490 : }

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0CDirectSoundVoiceSettings@DirectSound@@QAE@XZ ENDP	; DirectSound::CDirectSoundVoiceSettings::CDirectSoundVoiceSettings
DSOUND	ENDS
PUBLIC	??1CDirectSoundVoiceSettings@DirectSound@@UAE@XZ ; DirectSound::CDirectSoundVoiceSettings::~CDirectSoundVoiceSettings
; Function compile flags: /Odt
;	COMDAT ??_GCDirectSoundVoiceSettings@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCDirectSoundVoiceSettings@DirectSound@@UAEPAXI@Z PROC NEAR ; DirectSound::CDirectSoundVoiceSettings::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CDirectSoundVoiceSettings@DirectSound@@UAE@XZ ; DirectSound::CDirectSoundVoiceSettings::~CDirectSoundVoiceSettings
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L36777
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L36777:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCDirectSoundVoiceSettings@DirectSound@@UAEPAXI@Z ENDP ; DirectSound::CDirectSoundVoiceSettings::`scalar deleting destructor'
DSOUND	ENDS
PUBLIC	?SetOutputBuffer@CDirectSoundVoiceSettings@DirectSound@@QAEXPAVCDirectSoundBuffer@2@@Z ; DirectSound::CDirectSoundVoiceSettings::SetOutputBuffer
; Function compile flags: /Odt
;	COMDAT ??1CDirectSoundVoiceSettings@DirectSound@@UAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CDirectSoundVoiceSettings@DirectSound@@UAE@XZ PROC NEAR ; DirectSound::CDirectSoundVoiceSettings::~CDirectSoundVoiceSettings, COMDAT
; _this$ = ecx

; 4515 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDirectSoundVoiceSettings@DirectSound@@6B@

; 4516 :     DPF_ENTER();
; 4517 :     
; 4518 :     //
; 4519 :     // Release the output buffer
; 4520 :     //
; 4521 : 
; 4522 :     if(m_pMixinBuffer)

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 b9 b0 00 00
	00 00		 cmp	 DWORD PTR [ecx+176], 0
  0001a	74 0a		 je	 SHORT $L36781

; 4523 :     {
; 4524 :         SetOutputBuffer(NULL);

  0001c	6a 00		 push	 0
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?SetOutputBuffer@CDirectSoundVoiceSettings@DirectSound@@QAEXPAVCDirectSoundBuffer@2@@Z ; DirectSound::CDirectSoundVoiceSettings::SetOutputBuffer
$L36781:

; 4525 :     }
; 4526 : 
; 4527 : #ifndef MCPX_BOOT_LIB
; 4528 : 
; 4529 :     //
; 4530 :     // Free memory
; 4531 :     //
; 4532 : 
; 4533 :     MEMFREE(m_p3dParams);
; 4534 : 
; 4535 : #endif // MCPX_BOOT_LIB
; 4536 : 
; 4537 :     DPF_LEAVE_VOID();
; 4538 : }

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??1CRefCount@DirectSound@@UAE@XZ ; DirectSound::CRefCount::~CRefCount
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??1CDirectSoundVoiceSettings@DirectSound@@UAE@XZ ENDP	; DirectSound::CDirectSoundVoiceSettings::~CDirectSoundVoiceSettings
DSOUND	ENDS
PUBLIC	?Initialize@CDirectSoundVoiceSettings@DirectSound@@QAEJKPBUtWAVEFORMATEX@@PBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundVoiceSettings::Initialize
PUBLIC	?SetFormat@CDirectSoundVoiceSettings@DirectSound@@QAEHPBUtWAVEFORMATEX@@H@Z ; DirectSound::CDirectSoundVoiceSettings::SetFormat
PUBLIC	?SetVolume@CDirectSoundVoiceSettings@DirectSound@@QAEXJ@Z ; DirectSound::CDirectSoundVoiceSettings::SetVolume
PUBLIC	?SetMixBins@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundVoiceSettings::SetMixBins
; Function compile flags: /Odt
;	COMDAT ?Initialize@CDirectSoundVoiceSettings@DirectSound@@QAEJKPBUtWAVEFORMATEX@@PBU_DSMIXBINS@@@Z
DSOUND	SEGMENT
_this$ = -12
_hr$ = -8
_fSetMixBins$ = -4
_dwFlags$ = 8
_pwfxFormat$ = 12
_pMixBins$ = 16
?Initialize@CDirectSoundVoiceSettings@DirectSound@@QAEJKPBUtWAVEFORMATEX@@PBU_DSMIXBINS@@@Z PROC NEAR ; DirectSound::CDirectSoundVoiceSettings::Initialize, COMDAT
; _this$ = ecx

; 4568 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 4569 :     HRESULT                 hr              = DS_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 4570 :     BOOL                    fSetMixBins;
; 4571 : 
; 4572 :     DPF_ENTER();
; 4573 : 
; 4574 :     ASSERT(pwfxFormat);
; 4575 : 
; 4576 :     //
; 4577 :     // Save flags
; 4578 :     //
; 4579 :     
; 4580 :     m_dwFlags = dwFlags;

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00016	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 4581 : 
; 4582 :     //
; 4583 :     // Set default headroom
; 4584 :     //
; 4585 : 
; 4586 :     if(m_dwFlags & DSBCAPS_SUBMIXMASK)

  00019	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001f	25 00 20 08 00	 and	 eax, 532480		; 00082000H
  00024	85 c0		 test	 eax, eax
  00026	74 0c		 je	 SHORT $L36792

; 4587 :     {
; 4588 :         m_dwHeadroom = DSBHEADROOM_DEFAULT_SUBMIX;

  00028	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 4589 :     }
; 4590 :     else if(m_dwFlags & DSBCAPS_CTRL3D)

  00032	eb 23		 jmp	 SHORT $L36793
$L36792:
  00034	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00037	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0003a	83 e0 10	 and	 eax, 16			; 00000010H
  0003d	85 c0		 test	 eax, eax
  0003f	74 0c		 je	 SHORT $L36794

; 4591 :     {
; 4592 :         m_dwHeadroom = DSBHEADROOM_DEFAULT_3D;

  00041	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 4593 :     }
; 4594 :     else

  0004b	eb 0a		 jmp	 SHORT $L36793
$L36794:

; 4595 :     {
; 4596 :         m_dwHeadroom = DSBHEADROOM_DEFAULT_2D;

  0004d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00050	c7 42 20 58 02
	00 00		 mov	 DWORD PTR [edx+32], 600	; 00000258H
$L36793:

; 4597 :     }
; 4598 : 
; 4599 :     //
; 4600 :     // Set format.  If mixbins were specified, we won't allow the format
; 4601 :     // to override them.
; 4602 :     //
; 4603 : 
; 4604 :     fSetMixBins = SetFormat(pwfxFormat, !pMixBins);

  00057	33 c0		 xor	 eax, eax
  00059	83 7d 10 00	 cmp	 DWORD PTR _pMixBins$[ebp], 0
  0005d	0f 94 c0	 sete	 al
  00060	50		 push	 eax
  00061	8b 4d 0c	 mov	 ecx, DWORD PTR _pwfxFormat$[ebp]
  00064	51		 push	 ecx
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?SetFormat@CDirectSoundVoiceSettings@DirectSound@@QAEHPBUtWAVEFORMATEX@@H@Z ; DirectSound::CDirectSoundVoiceSettings::SetFormat
  0006d	89 45 fc	 mov	 DWORD PTR _fSetMixBins$[ebp], eax

; 4605 : 
; 4606 :     //
; 4607 :     // If SetFormat didn't set the mixbins for us, we'll need to do it now
; 4608 :     //
; 4609 : 
; 4610 :     if(!fSetMixBins)

  00070	83 7d fc 00	 cmp	 DWORD PTR _fSetMixBins$[ebp], 0
  00074	75 0c		 jne	 SHORT $L36796

; 4611 :     {
; 4612 :         SetMixBins(pMixBins);

  00076	8b 55 10	 mov	 edx, DWORD PTR _pMixBins$[ebp]
  00079	52		 push	 edx
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?SetMixBins@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundVoiceSettings::SetMixBins
$L36796:

; 4613 :     }
; 4614 : 
; 4615 :     //
; 4616 :     // Set default volume
; 4617 :     //
; 4618 : 
; 4619 :     SetVolume(DSBVOLUME_MAX);

  00082	6a 00		 push	 0
  00084	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ?SetVolume@CDirectSoundVoiceSettings@DirectSound@@QAEXJ@Z ; DirectSound::CDirectSoundVoiceSettings::SetVolume

; 4620 : 
; 4621 : #ifndef MCPX_BOOT_LIB
; 4622 : 
; 4623 :     //
; 4624 :     // Allocate 3D parameter data
; 4625 :     //
; 4626 : 
; 4627 :     if(m_dwFlags & DSBCAPS_CTRL3D)
; 4628 :     {
; 4629 :         hr = HRFROMP(m_p3dParams = MEMALLOC(DS3DSOURCEPARAMS, 1));
; 4630 : 
; 4631 :         if(SUCCEEDED(hr))
; 4632 :         {
; 4633 :             m_p3dParams->HrtfParams = DirectSoundDefault3DBuffer;
; 4634 :             m_p3dParams->I3dl2Params = DirectSoundDefaultI3DL2Buffer;
; 4635 :             m_p3dParams->dwParameterMask = DS3DPARAM_BUFFER_MASK;
; 4636 :         }
; 4637 :     }
; 4638 : 
; 4639 : #endif // MCPX_BOOT_LIB
; 4640 : 
; 4641 :     DPF_LEAVE_HRESULT(hr);
; 4642 : 
; 4643 :     return hr;

  0008c	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 4644 : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 0c 00	 ret	 12			; 0000000cH
?Initialize@CDirectSoundVoiceSettings@DirectSound@@QAEJKPBUtWAVEFORMATEX@@PBU_DSMIXBINS@@@Z ENDP ; DirectSound::CDirectSoundVoiceSettings::Initialize
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetFormat@CDirectSoundVoiceSettings@DirectSound@@QAEHPBUtWAVEFORMATEX@@H@Z
DSOUND	SEGMENT
_this$ = -84
_dwChannelMask$ = -80
_MixBins$ = -76
_fSetMixBins$ = -68
_MixBinVolumePairs$ = -64
_pwfxFormat$ = 8
_fAllowMixBins$ = 12
?SetFormat@CDirectSoundVoiceSettings@DirectSound@@QAEHPBUtWAVEFORMATEX@@H@Z PROC NEAR ; DirectSound::CDirectSoundVoiceSettings::SetFormat, COMDAT
; _this$ = ecx

; 4672 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 4673 :     BOOL                    fSetMixBins                                     = FALSE;

  00009	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _fSetMixBins$[ebp], 0

; 4674 :     DWORD                   dwChannelMask;
; 4675 :     DSMIXBINS               MixBins;
; 4676 :     DSMIXBINVOLUMEPAIR      MixBinVolumePairs[DSMIXBIN_ASSIGNMENT_MAX];
; 4677 :     
; 4678 :     DPF_ENTER();
; 4679 : 
; 4680 :     ASSERT(pwfxFormat);
; 4681 : 
; 4682 :     //
; 4683 :     // Save format.  If MixBins were specified by the format, we'll use those
; 4684 :     // assuming no mixbins were passed to us and the voice is 2D.
; 4685 :     //
; 4686 : 
; 4687 :     if(dwChannelMask = CreateInternalFormat(&m_fmt, pwfxFormat))

  00010	8b 45 08	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  00013	50		 push	 eax
  00014	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ?CreateInternalFormat@WaveFormat@DirectSound@@YGKPAUDSWAVEFORMAT@@PBUtWAVEFORMATEX@@@Z ; DirectSound::WaveFormat::CreateInternalFormat
  00020	89 45 b0	 mov	 DWORD PTR _dwChannelMask$[ebp], eax
  00023	83 7d b0 00	 cmp	 DWORD PTR _dwChannelMask$[ebp], 0
  00027	74 7c		 je	 SHORT $L36806

; 4688 :     {
; 4689 :         if(!(m_dwFlags & DSBCAPS_CTRL3D) && fAllowMixBins)

  00029	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002f	83 e0 10	 and	 eax, 16			; 00000010H
  00032	85 c0		 test	 eax, eax
  00034	75 6f		 jne	 SHORT $L36806
  00036	83 7d 0c 00	 cmp	 DWORD PTR _fAllowMixBins$[ebp], 0
  0003a	74 69		 je	 SHORT $L36806

; 4690 :         {
; 4691 :             MixBins.dwMixBinCount = 0;

  0003c	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _MixBins$[ebp], 0

; 4692 :             MixBins.lpMixBinVolumePairs = MixBinVolumePairs;

  00043	8d 4d c0	 lea	 ecx, DWORD PTR _MixBinVolumePairs$[ebp]
  00046	89 4d b8	 mov	 DWORD PTR _MixBins$[ebp+4], ecx
$L36809:

; 4693 :             
; 4694 :             while(dwChannelMask && (MixBins.dwMixBinCount < NUMELMS(MixBinVolumePairs)))

  00049	83 7d b0 00	 cmp	 DWORD PTR _dwChannelMask$[ebp], 0
  0004d	74 43		 je	 SHORT $L36810
  0004f	83 7d b4 08	 cmp	 DWORD PTR _MixBins$[ebp], 8
  00053	73 3d		 jae	 SHORT $L36810

; 4695 :             {
; 4696 :                 MixBinVolumePairs[MixBins.dwMixBinCount].dwMixBin = lsb(dwChannelMask);

  00055	8b 4d b0	 mov	 ecx, DWORD PTR _dwChannelMask$[ebp]
  00058	e8 00 00 00 00	 call	 ?lsb@Math@DirectSound@@YIII@Z ; DirectSound::Math::lsb
  0005d	8b 55 b4	 mov	 edx, DWORD PTR _MixBins$[ebp]
  00060	89 44 d5 c0	 mov	 DWORD PTR _MixBinVolumePairs$[ebp+edx*8], eax

; 4697 :                 MixBinVolumePairs[MixBins.dwMixBinCount].lVolume = 0;

  00064	8b 45 b4	 mov	 eax, DWORD PTR _MixBins$[ebp]
  00067	c7 44 c5 c4 00
	00 00 00	 mov	 DWORD PTR _MixBinVolumePairs$[ebp+eax*8+4], 0

; 4698 : 
; 4699 :                 MixBins.dwMixBinCount++;

  0006f	8b 4d b4	 mov	 ecx, DWORD PTR _MixBins$[ebp]
  00072	83 c1 01	 add	 ecx, 1
  00075	89 4d b4	 mov	 DWORD PTR _MixBins$[ebp], ecx

; 4700 : 
; 4701 :                 dwChannelMask &= ~(1UL << MixBinVolumePairs[MixBins.dwMixBinCount].dwMixBin);

  00078	8b 55 b4	 mov	 edx, DWORD PTR _MixBins$[ebp]
  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	8b 4c d5 c0	 mov	 ecx, DWORD PTR _MixBinVolumePairs$[ebp+edx*8]
  00084	d3 e0		 shl	 eax, cl
  00086	f7 d0		 not	 eax
  00088	8b 4d b0	 mov	 ecx, DWORD PTR _dwChannelMask$[ebp]
  0008b	23 c8		 and	 ecx, eax
  0008d	89 4d b0	 mov	 DWORD PTR _dwChannelMask$[ebp], ecx

; 4702 :             }

  00090	eb b7		 jmp	 SHORT $L36809
$L36810:

; 4703 : 
; 4704 :             SetMixBins(&MixBins);

  00092	8d 55 b4	 lea	 edx, DWORD PTR _MixBins$[ebp]
  00095	52		 push	 edx
  00096	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ?SetMixBins@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundVoiceSettings::SetMixBins

; 4705 : 
; 4706 :             fSetMixBins = TRUE;

  0009e	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR _fSetMixBins$[ebp], 1
$L36806:

; 4707 :         }
; 4708 :     }
; 4709 : 
; 4710 :     //
; 4711 :     // Set default pitch
; 4712 :     //
; 4713 : 
; 4714 :     m_lPitch = XAudioCalculatePitch(m_fmt.nSamplesPerSec);

  000a5	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 _XAudioCalculatePitch@4
  000b1	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  000b4	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 4715 : 
; 4716 :     DPF_LEAVE(fSetMixBins);
; 4717 : 
; 4718 :     return fSetMixBins;

  000b7	8b 45 bc	 mov	 eax, DWORD PTR _fSetMixBins$[ebp]

; 4719 : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 08 00	 ret	 8
?SetFormat@CDirectSoundVoiceSettings@DirectSound@@QAEHPBUtWAVEFORMATEX@@H@Z ENDP ; DirectSound::CDirectSoundVoiceSettings::SetFormat
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsmath.h
DSOUND	ENDS
;	COMDAT ?lsb@Math@DirectSound@@YIII@Z
DSOUND	SEGMENT
_x$ = -4
?lsb@Math@DirectSound@@YIII@Z PROC NEAR			; DirectSound::Math::lsb, COMDAT
; _x$ = ecx

; 167  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _x$[ebp], ecx

; 168  :             __asm
; 169  :             {
; 170  :                 bsf     eax, ecx

  00007	0f bc c1	 bsf	 eax, ecx

; 171  :             }
; 172  :         }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?lsb@Math@DirectSound@@YIII@Z ENDP			; DirectSound::Math::lsb
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
DSOUND	ENDS
;	COMDAT ?SetVolume@CDirectSoundVoiceSettings@DirectSound@@QAEXJ@Z
DSOUND	SEGMENT
_this$ = -4
_lVolume$ = 8
?SetVolume@CDirectSoundVoiceSettings@DirectSound@@QAEXJ@Z PROC NEAR ; DirectSound::CDirectSoundVoiceSettings::SetVolume, COMDAT
; _this$ = ecx

; 4745 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4746 :     DPF_ENTER();
; 4747 : 
; 4748 :     //
; 4749 :     // Apply headroom
; 4750 :     //
; 4751 : 
; 4752 :     m_lVolume = lVolume - m_dwHeadroom;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _lVolume$[ebp]
  0000d	2b 48 20	 sub	 ecx, DWORD PTR [eax+32]
  00010	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00013	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 4753 :     ASSERT(m_lVolume <= DSBVOLUME_MAX);
; 4754 : 
; 4755 :     DPF_LEAVE_VOID();
; 4756 : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?SetVolume@CDirectSoundVoiceSettings@DirectSound@@QAEXJ@Z ENDP ; DirectSound::CDirectSoundVoiceSettings::SetVolume
DSOUND	ENDS
PUBLIC	?SetMixBinVolumes@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundVoiceSettings::SetMixBinVolumes
; Function compile flags: /Odt
;	COMDAT ?SetMixBinVolumes@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z
DSOUND	SEGMENT
_this$ = -8
_i$ = -4
_pMixBins$ = 8
?SetMixBinVolumes@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z PROC NEAR ; DirectSound::CDirectSoundVoiceSettings::SetMixBinVolumes, COMDAT
; _this$ = ecx

; 4782 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4783 :     DWORD                   i;
; 4784 :     
; 4785 :     DPF_ENTER();
; 4786 : 
; 4787 :     ASSERT(pMixBins);
; 4788 :     ASSERT(pMixBins->dwMixBinCount <= NUMELMS(m_alMixBinVolumes));
; 4789 : 
; 4790 :     for(i = 0; i < pMixBins->dwMixBinCount; i++)

  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00011	eb 09		 jmp	 SHORT $L36820
$L36821:
  00013	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00016	83 c0 01	 add	 eax, 1
  00019	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L36820:
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _pMixBins$[ebp]
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	73 22		 jae	 SHORT $L36818

; 4791 :     {
; 4792 :         ASSERT(pMixBins->lpMixBinVolumePairs[i].dwMixBin < NUMELMS(m_alMixBinVolumes));
; 4793 :         
; 4794 :         m_alMixBinVolumes[pMixBins->lpMixBinVolumePairs[i].dwMixBin] = pMixBins->lpMixBinVolumePairs[i].lVolume;

  00026	8b 45 08	 mov	 eax, DWORD PTR _pMixBins$[ebp]
  00029	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002c	8b 55 08	 mov	 edx, DWORD PTR _pMixBins$[ebp]
  0002f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00035	8b 04 d0	 mov	 eax, DWORD PTR [eax+edx*8]
  00038	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	8b 75 fc	 mov	 esi, DWORD PTR _i$[ebp]
  0003e	8b 4c f1 04	 mov	 ecx, DWORD PTR [ecx+esi*8+4]
  00042	89 4c 82 30	 mov	 DWORD PTR [edx+eax*4+48], ecx

; 4795 :     }

  00046	eb cb		 jmp	 SHORT $L36821
$L36818:

; 4796 : 
; 4797 :     DPF_LEAVE_VOID();
; 4798 : }

  00048	5e		 pop	 esi
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?SetMixBinVolumes@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z ENDP ; DirectSound::CDirectSoundVoiceSettings::SetMixBinVolumes
DSOUND	ENDS
PUBLIC	?SetHeadroom@CDirectSoundVoiceSettings@DirectSound@@QAEXK@Z ; DirectSound::CDirectSoundVoiceSettings::SetHeadroom
; Function compile flags: /Odt
;	COMDAT ?SetHeadroom@CDirectSoundVoiceSettings@DirectSound@@QAEXK@Z
DSOUND	SEGMENT
_this$ = -8
_lDiff$ = -4
_dwHeadroom$ = 8
?SetHeadroom@CDirectSoundVoiceSettings@DirectSound@@QAEXK@Z PROC NEAR ; DirectSound::CDirectSoundVoiceSettings::SetHeadroom, COMDAT
; _this$ = ecx

; 4824 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4825 :     LONG                    lDiff;
; 4826 :     
; 4827 :     DPF_ENTER();
; 4828 : 
; 4829 :     //
; 4830 :     // Calculate the difference between the old headroom and the new one
; 4831 :     //
; 4832 : 
; 4833 :     lDiff = m_dwHeadroom - dwHeadroom;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000f	2b 4d 08	 sub	 ecx, DWORD PTR _dwHeadroom$[ebp]
  00012	89 4d fc	 mov	 DWORD PTR _lDiff$[ebp], ecx

; 4834 : 
; 4835 :     //
; 4836 :     // Save the new headroom
; 4837 :     //
; 4838 : 
; 4839 :     m_dwHeadroom = dwHeadroom;

  00015	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 45 08	 mov	 eax, DWORD PTR _dwHeadroom$[ebp]
  0001b	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 4840 :     
; 4841 :     //
; 4842 :     // Update volume
; 4843 :     //
; 4844 : 
; 4845 :     m_lVolume += lDiff;

  0001e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00024	03 55 fc	 add	 edx, DWORD PTR _lDiff$[ebp]
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 4846 :     ASSERT(m_lVolume <= DSBVOLUME_MAX);
; 4847 : 
; 4848 :     DPF_LEAVE_VOID();
; 4849 : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?SetHeadroom@CDirectSoundVoiceSettings@DirectSound@@QAEXK@Z ENDP ; DirectSound::CDirectSoundVoiceSettings::SetHeadroom
DSOUND	ENDS
;	COMDAT ?apDefaultMixBins@?1??SetMixBins@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z@4QBQBU4@B
DSOUND_RD	SEGMENT
?apDefaultMixBins@?1??SetMixBins@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z@4QBQBU4@B DD FLAT:_DirectSoundDefaultMixBins_Mono ; `DirectSound::CDirectSoundVoiceSettings::SetMixBins'::`2'::apDefaultMixBins
	DD	FLAT:_DirectSoundDefaultMixBins_Stereo
	DD	FLAT:_DirectSoundDefaultMixBins_4Channel
	DD	FLAT:_DirectSoundDefaultMixBins_6Channel
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?SetMixBins@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z
DSOUND	SEGMENT
_this$ = -8
_i$ = -4
_pMixBins$ = 8
?SetMixBins@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z PROC NEAR ; DirectSound::CDirectSoundVoiceSettings::SetMixBins, COMDAT
; _this$ = ecx

; 4875 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4876 :     static const LPCDSMIXBINS   apDefaultMixBins[] =
; 4877 :     {
; 4878 :         &DirectSoundDefaultMixBins_Mono,
; 4879 :         &DirectSoundDefaultMixBins_Stereo,
; 4880 :         &DirectSoundDefaultMixBins_4Channel,
; 4881 :         &DirectSoundDefaultMixBins_6Channel,
; 4882 :     };
; 4883 : 
; 4884 :     DWORD                       i;
; 4885 :     
; 4886 :     DPF_ENTER();
; 4887 : 
; 4888 :     //
; 4889 :     // If no mixbins were supplied, use defaults
; 4890 :     //
; 4891 : 
; 4892 :     if(!pMixBins)

  0000a	83 7d 08 00	 cmp	 DWORD PTR _pMixBins$[ebp], 0
  0000e	75 2c		 jne	 SHORT $L36835

; 4893 :     {
; 4894 :         if(m_dwFlags & DSBCAPS_CTRL3D)

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00016	83 e1 10	 and	 ecx, 16			; 00000010H
  00019	85 c9		 test	 ecx, ecx
  0001b	74 09		 je	 SHORT $L36836

; 4895 :         {
; 4896 :             pMixBins = &DirectSoundDefaultMixBins_3D;

  0001d	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _pMixBins$[ebp], OFFSET FLAT:_DirectSoundDefaultMixBins_3D

; 4897 :         }
; 4898 :         else

  00024	eb 16		 jmp	 SHORT $L36835
$L36836:

; 4899 :         {
; 4900 :             ASSERT(m_fmt.nChannels / 2 < NUMELMS(apDefaultMixBins));
; 4901 :             pMixBins = apDefaultMixBins[m_fmt.nChannels / 2];

  00026	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00029	0f b6 42 0e	 movzx	 eax, BYTE PTR [edx+14]
  0002d	99		 cdq
  0002e	2b c2		 sub	 eax, edx
  00030	d1 f8		 sar	 eax, 1
  00032	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?apDefaultMixBins@?1??SetMixBins@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z@4QBQBU4@B[eax*4]
  00039	89 45 08	 mov	 DWORD PTR _pMixBins$[ebp], eax
$L36835:

; 4902 :         }
; 4903 :     }
; 4904 : 
; 4905 :     //
; 4906 :     // Set mixbins and volume
; 4907 :     //
; 4908 : 
; 4909 :     ASSERT(pMixBins);
; 4910 :     ASSERT(pMixBins->dwMixBinCount <= NUMELMS(m_abMixBins));
; 4911 :     
; 4912 :     for(m_dwMixBinCount = 0; m_dwMixBinCount < (BYTE)pMixBins->dwMixBinCount; m_dwMixBinCount++)

  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
  00046	eb 0f		 jmp	 SHORT $L36839
$L36840:
  00048	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0004b	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0004e	83 c0 01	 add	 eax, 1
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	89 41 24	 mov	 DWORD PTR [ecx+36], eax
$L36839:
  00057	8b 55 08	 mov	 edx, DWORD PTR _pMixBins$[ebp]
  0005a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0005d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	39 41 24	 cmp	 DWORD PTR [ecx+36], eax
  00063	73 43		 jae	 SHORT $L36841

; 4913 :     {
; 4914 :         ASSERT(pMixBins->lpMixBinVolumePairs[m_dwMixBinCount].dwMixBin < NUMELMS(m_alMixBinVolumes));
; 4915 :         
; 4916 :         m_abMixBins[m_dwMixBinCount] = (BYTE)pMixBins->lpMixBinVolumePairs[m_dwMixBinCount].dwMixBin;

  00065	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00068	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _pMixBins$[ebp]
  0006e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  00077	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  0007a	8a 14 c2	 mov	 dl, BYTE PTR [edx+eax*8]
  0007d	88 54 0e 28	 mov	 BYTE PTR [esi+ecx+40], dl

; 4917 :         m_alMixBinVolumes[m_abMixBins[m_dwMixBinCount]] = pMixBins->lpMixBinVolumePairs[m_dwMixBinCount].lVolume;

  00081	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00084	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00087	8b 55 08	 mov	 edx, DWORD PTR _pMixBins$[ebp]
  0008a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0008d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00090	8b 52 24	 mov	 edx, DWORD PTR [edx+36]
  00093	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00096	0f b6 54 16 28	 movzx	 edx, BYTE PTR [esi+edx+40]
  0009b	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  0009e	8b 44 c8 04	 mov	 eax, DWORD PTR [eax+ecx*8+4]
  000a2	89 44 96 30	 mov	 DWORD PTR [esi+edx*4+48], eax

; 4918 :     }

  000a6	eb a0		 jmp	 SHORT $L36840
$L36841:

; 4919 : 
; 4920 :     //
; 4921 :     // If we're submixing, the submix bin must be included.  If it wasn't
; 4922 :     // included in the array, we'll add it automatically for "convenience"
; 4923 :     //
; 4924 : 
; 4925 :     if(m_pMixinBuffer)

  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	83 b9 b0 00 00
	00 00		 cmp	 DWORD PTR [ecx+176], 0
  000b2	0f 84 a7 00 00
	00		 je	 $L36831

; 4926 :     {
; 4927 :         ASSERT(m_pMixinBuffer->m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK);
; 4928 : 
; 4929 :         for(i = 0; i < m_dwMixBinCount; i++)

  000b8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000bf	eb 09		 jmp	 SHORT $L36844
$L36845:
  000c1	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000c4	83 c2 01	 add	 edx, 1
  000c7	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L36844:
  000ca	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000d0	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  000d3	73 25		 jae	 SHORT $L36846

; 4930 :         {
; 4931 :             if(m_abMixBins[i] == (BYTE)m_pMixinBuffer->m_pSettings->m_dwInputMixBin)

  000d5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000d8	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000db	0f b6 42 28	 movzx	 eax, BYTE PTR [edx+40]
  000df	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  000e8	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  000eb	0f b6 91 cc 00
	00 00		 movzx	 edx, BYTE PTR [ecx+204]
  000f2	3b c2		 cmp	 eax, edx
  000f4	75 02		 jne	 SHORT $L36848

; 4932 :             {
; 4933 :                 break;

  000f6	eb 02		 jmp	 SHORT $L36846
$L36848:

; 4934 :             }
; 4935 :         }

  000f8	eb c7		 jmp	 SHORT $L36845
$L36846:

; 4936 : 
; 4937 :         if(i >= m_dwMixBinCount)

  000fa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000fd	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00100	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  00103	72 5a		 jb	 SHORT $L36831

; 4938 :         {
; 4939 :             if(m_dwMixBinCount >= NUMELMS(m_abMixBins))

  00105	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00108	83 7a 24 08	 cmp	 DWORD PTR [edx+36], 8
  0010c	72 0a		 jb	 SHORT $L36850

; 4940 :             {
; 4941 :                 DPF_ERROR("One mixbin slot must be kept free for submixing.  The last mixbin specified will be lost");
; 4942 :                 m_dwMixBinCount = NUMELMS(m_abMixBins) - 1;

  0010e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00111	c7 40 24 07 00
	00 00		 mov	 DWORD PTR [eax+36], 7
$L36850:

; 4943 :             }
; 4944 : 
; 4945 :             m_abMixBins[m_dwMixBinCount] = (BYTE)m_pMixinBuffer->m_pSettings->m_dwInputMixBin;

  00118	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  00121	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00124	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00127	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0012a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	8a 80 cc 00 00
	00		 mov	 al, BYTE PTR [eax+204]
  00133	88 44 11 28	 mov	 BYTE PTR [ecx+edx+40], al

; 4946 :             m_alMixBinVolumes[m_abMixBins[m_dwMixBinCount]] = DSBVOLUME_MAX;

  00137	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0013a	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0013d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00140	0f b6 4c 10 28	 movzx	 ecx, BYTE PTR [eax+edx+40]
  00145	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00148	c7 44 8a 30 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*4+48], 0

; 4947 : 
; 4948 :             m_dwMixBinCount++;

  00150	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00153	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00156	83 c1 01	 add	 ecx, 1
  00159	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0015c	89 4a 24	 mov	 DWORD PTR [edx+36], ecx
$L36831:

; 4949 :         }
; 4950 :     }
; 4951 : 
; 4952 :     DPF_LEAVE_VOID();
; 4953 : }

  0015f	5e		 pop	 esi
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c2 04 00	 ret	 4
?SetMixBins@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z ENDP ; DirectSound::CDirectSoundVoiceSettings::SetMixBins
DSOUND	ENDS
PUBLIC	?__AddRef@DirectSound@@YGPAVCDirectSoundBuffer@1@PAV21@@Z ; DirectSound::__AddRef
; Function compile flags: /Odt
;	COMDAT ?SetOutputBuffer@CDirectSoundVoiceSettings@DirectSound@@QAEXPAVCDirectSoundBuffer@2@@Z
DSOUND	SEGMENT
_this$ = -8
_dwMixBin$ = -4
_pOutputBuffer$ = 8
?SetOutputBuffer@CDirectSoundVoiceSettings@DirectSound@@QAEXPAVCDirectSoundBuffer@2@@Z PROC NEAR ; DirectSound::CDirectSoundVoiceSettings::SetOutputBuffer, COMDAT
; _this$ = ecx

; 4980 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4981 :     DWORD                   dwMixBin;
; 4982 :     
; 4983 :     DPF_ENTER();
; 4984 : 
; 4985 :     ASSERT(pOutputBuffer != m_pMixinBuffer);
; 4986 : 
; 4987 :     //
; 4988 :     // Release the old buffer and update the mixbins
; 4989 :     //
; 4990 : 
; 4991 :     if(m_pMixinBuffer)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [eax+176], 0
  00013	74 55		 je	 SHORT $L36857

; 4992 :     {
; 4993 :         dwMixBin = m_pMixinBuffer->m_pSettings->m_dwInputMixBin;

  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  0001e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00021	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  00027	89 4d fc	 mov	 DWORD PTR _dwMixBin$[ebp], ecx

; 4994 : 
; 4995 :         ASSERT(m_dwMixBinCount);
; 4996 :         ASSERT(m_abMixBins[m_dwMixBinCount - 1] == dwMixBin);
; 4997 : 
; 4998 :         m_dwMixBinCount--;

  0002a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00030	83 e8 01	 sub	 eax, 1
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 4999 : 
; 5000 :         RELEASE(m_pMixinBuffer);

  00039	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	83 ba b0 00 00
	00 00		 cmp	 DWORD PTR [edx+176], 0
  00043	74 25		 je	 SHORT $L36857
  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0004e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00051	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  00057	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00059	50		 push	 eax
  0005a	ff 51 08	 call	 DWORD PTR [ecx+8]
  0005d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00060	c7 82 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+176], 0
$L36857:

; 5001 :     }
; 5002 : 
; 5003 :     //
; 5004 :     // Save a reference to the new buffer and update the mixbins.  We're 
; 5005 :     // automatically resetting the mixbin count to 0 before dropping the
; 5006 :     // submix bin in for "convienence."  If you call SetOutputBuffer(NULL)
; 5007 :     // after this, you'll have lost whatever mixbins you used to be assigned
; 5008 :     // to.
; 5009 :     //
; 5010 : 
; 5011 :     if(m_pMixinBuffer = ADDREF(pOutputBuffer))

  0006a	8b 45 08	 mov	 eax, DWORD PTR _pOutputBuffer$[ebp]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCDirectSoundBuffer@1@PAV21@@Z ; DirectSound::__AddRef
  00073	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	89 81 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], eax
  0007c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007f	83 ba b0 00 00
	00 00		 cmp	 DWORD PTR [edx+176], 0
  00086	74 28		 je	 SHORT $L36855

; 5012 :     {
; 5013 :         dwMixBin = m_pMixinBuffer->m_pSettings->m_dwInputMixBin;

  00088	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008b	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00091	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00094	8b 82 cc 00 00
	00		 mov	 eax, DWORD PTR [edx+204]
  0009a	89 45 fc	 mov	 DWORD PTR _dwMixBin$[ebp], eax

; 5014 : 
; 5015 :         ASSERT(m_pMixinBuffer->m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK);
; 5016 : 
; 5017 :         m_dwMixBinCount = 1;

  0009d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	c7 41 24 01 00
	00 00		 mov	 DWORD PTR [ecx+36], 1

; 5018 :         m_abMixBins[0] = (BYTE)dwMixBin;

  000a7	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000aa	8a 45 fc	 mov	 al, BYTE PTR _dwMixBin$[ebp]
  000ad	88 42 28	 mov	 BYTE PTR [edx+40], al
$L36855:

; 5019 :     }
; 5020 : 
; 5021 :     DPF_LEAVE_VOID();
; 5022 : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 04 00	 ret	 4
?SetOutputBuffer@CDirectSoundVoiceSettings@DirectSound@@QAEXPAVCDirectSoundBuffer@2@@Z ENDP ; DirectSound::CDirectSoundVoiceSettings::SetOutputBuffer
DSOUND	ENDS
PUBLIC	??0CDirectSoundVoice@DirectSound@@QAE@PAVCDirectSound@1@@Z ; DirectSound::CDirectSoundVoice::CDirectSoundVoice
PUBLIC	??_7CDirectSoundVoice@DirectSound@@6B@		; DirectSound::CDirectSoundVoice::`vftable'
PUBLIC	??_GCDirectSoundVoice@DirectSound@@UAEPAXI@Z	; DirectSound::CDirectSoundVoice::`scalar deleting destructor'
EXTRN	??_ECDirectSoundVoice@DirectSound@@UAEPAXI@Z:NEAR ; DirectSound::CDirectSoundVoice::`vector deleting destructor'
;	COMDAT ??_7CDirectSoundVoice@DirectSound@@6B@
CONST	SEGMENT
??_7CDirectSoundVoice@DirectSound@@6B@ DD FLAT:??_ECDirectSoundVoice@DirectSound@@UAEPAXI@Z ; DirectSound::CDirectSoundVoice::`vftable'
	DD	FLAT:?AddRef@CRefCount@DirectSound@@UAGKXZ
	DD	FLAT:?Release@CRefCount@DirectSound@@UAGKXZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CDirectSoundVoice@DirectSound@@QAE@PAVCDirectSound@1@@Z
DSOUND	SEGMENT
_this$ = -4
_pDirectSound$ = 8
??0CDirectSoundVoice@DirectSound@@QAE@PAVCDirectSound@1@@Z PROC NEAR ; DirectSound::CDirectSoundVoice::CDirectSoundVoice, COMDAT
; _this$ = ecx

; 5047 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 01		 push	 1
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CRefCount@DirectSound@@QAE@K@Z ; DirectSound::CRefCount::CRefCount
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDirectSoundVoice@DirectSound@@6B@

; 5048 :     DPF_ENTER();
; 5049 : 
; 5050 :     //
; 5051 :     // Initialize defaults
; 5052 :     //
; 5053 : 
; 5054 :     InitializeListHead(&m_le3dVoice);

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 14	 add	 ecx, 20			; 00000014H
  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0002f	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 5055 : 
; 5056 :     //
; 5057 :     // Save a reference to the DirectSound object
; 5058 :     //
; 5059 : 
; 5060 :     m_pDirectSound = ADDREF(pDirectSound);

  00032	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCDirectSound@1@PAV21@@Z ; DirectSound::__AddRef
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 5061 : 
; 5062 :     DPF_LEAVE_VOID();
; 5063 : }

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
??0CDirectSoundVoice@DirectSound@@QAE@PAVCDirectSound@1@@Z ENDP ; DirectSound::CDirectSoundVoice::CDirectSoundVoice
DSOUND	ENDS
PUBLIC	??1CDirectSoundVoice@DirectSound@@UAE@XZ	; DirectSound::CDirectSoundVoice::~CDirectSoundVoice
; Function compile flags: /Odt
;	COMDAT ??_GCDirectSoundVoice@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCDirectSoundVoice@DirectSound@@UAEPAXI@Z PROC NEAR	; DirectSound::CDirectSoundVoice::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CDirectSoundVoice@DirectSound@@UAE@XZ ; DirectSound::CDirectSoundVoice::~CDirectSoundVoice
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L36875
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L36875:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCDirectSoundVoice@DirectSound@@UAEPAXI@Z ENDP	; DirectSound::CDirectSoundVoice::`scalar deleting destructor'
DSOUND	ENDS
PUBLIC	?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z	; RemoveEntryList
; Function compile flags: /Odt
;	COMDAT ??1CDirectSoundVoice@DirectSound@@UAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CDirectSoundVoice@DirectSound@@UAE@XZ PROC NEAR	; DirectSound::CDirectSoundVoice::~CDirectSoundVoice, COMDAT
; _this$ = ecx

; 5088 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDirectSoundVoice@DirectSound@@6B@

; 5089 :     DPF_ENTER();
; 5090 : 
; 5091 :     //
; 5092 :     // Remove ourselves from the 3D list
; 5093 :     //
; 5094 : 
; 5095 :     RemoveEntryList(&m_le3dVoice);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 14	 add	 ecx, 20			; 00000014H
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 5096 : 
; 5097 :     //
; 5098 :     // Release the voice implementation object
; 5099 :     //
; 5100 : 
; 5101 :     RELEASE(m_pVoice);

  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  00023	74 1c		 je	 SHORT $L36880
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00031	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00033	50		 push	 eax
  00034	ff 51 08	 call	 DWORD PTR [ecx+8]
  00037	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003a	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
$L36880:

; 5102 : 
; 5103 :     //
; 5104 :     // Release the shared settings object
; 5105 :     //
; 5106 : 
; 5107 :     RELEASE(m_pSettings);

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00048	74 1c		 je	 SHORT $L36881
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00056	8b 12		 mov	 edx, DWORD PTR [edx]
  00058	51		 push	 ecx
  00059	ff 52 08	 call	 DWORD PTR [edx+8]
  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$L36881:

; 5108 : 
; 5109 :     //
; 5110 :     // Release the reference to the DirectSound object
; 5111 :     //
; 5112 : 
; 5113 :     RELEASE(m_pDirectSound);

  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0006d	74 1c		 je	 SHORT $L36879
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00072	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	52		 push	 edx
  0007e	ff 50 08	 call	 DWORD PTR [eax+8]
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
$L36879:

; 5114 : 
; 5115 :     DPF_LEAVE_VOID();
; 5116 : }

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ??1CRefCount@DirectSound@@UAE@XZ ; DirectSound::CRefCount::~CRefCount
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
??1CDirectSoundVoice@DirectSound@@UAE@XZ ENDP		; DirectSound::CDirectSoundVoice::~CDirectSoundVoice
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\ntlist.h
DSOUND	ENDS
;	COMDAT ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z
DSOUND	SEGMENT
_Entry$ = 8
?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z PROC NEAR	; RemoveEntryList, COMDAT

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 216  :     AssertValidEntryList(Entry, ASSERT_VALID_ONLY);
; 217  : 
; 218  :     if(IsEntryInList(Entry))

  00003	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	3b 4d 08	 cmp	 ecx, DWORD PTR _Entry$[ebp]
  0000b	74 2c		 je	 SHORT $L29963

; 219  :     {
; 220  :         Entry->Flink->Blink = Entry->Blink;

  0000d	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  00010	8b 02		 mov	 eax, DWORD PTR [edx]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 221  :         Entry->Blink->Flink = Entry->Flink;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  00024	8b 02		 mov	 eax, DWORD PTR [edx]
  00026	89 01		 mov	 DWORD PTR [ecx], eax

; 222  : 
; 223  :         Entry->Flink = Entry->Blink = Entry;

  00028	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0002b	8b 55 08	 mov	 edx, DWORD PTR _Entry$[ebp]
  0002e	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00031	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00037	89 08		 mov	 DWORD PTR [eax], ecx
$L29963:

; 224  :     }
; 225  : 
; 226  :     return Entry;

  00039	8b 45 08	 mov	 eax, DWORD PTR _Entry$[ebp]

; 227  : }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ENDP	; RemoveEntryList
DSOUND	ENDS
PUBLIC	?__AddRef@DirectSound@@YGPAVCMcpxVoiceClient@1@PAV21@@Z ; DirectSound::__AddRef
PUBLIC	?__AddRef@DirectSound@@YGPAVCDirectSoundVoiceSettings@1@PAV21@@Z ; DirectSound::__AddRef
PUBLIC	?InsertTailList@@YGXPAU_LIST_ENTRY@@0@Z		; InsertTailList
PUBLIC	?Initialize@CDirectSoundVoice@DirectSound@@QAGXPAVCMcpxVoiceClient@2@PAVCDirectSoundVoiceSettings@2@@Z ; DirectSound::CDirectSoundVoice::Initialize
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT ?Initialize@CDirectSoundVoice@DirectSound@@QAGXPAVCMcpxVoiceClient@2@PAVCDirectSoundVoiceSettings@2@@Z
DSOUND	SEGMENT
_this$ = 8
_pVoice$ = 12
_pSettings$ = 16
?Initialize@CDirectSoundVoice@DirectSound@@QAGXPAVCMcpxVoiceClient@2@PAVCDirectSoundVoiceSettings@2@@Z PROC NEAR ; DirectSound::CDirectSoundVoice::Initialize, COMDAT

; 5144 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5145 :     DPF_ENTER();
; 5146 : 
; 5147 :     //
; 5148 :     // Just save a reference to each
; 5149 :     //
; 5150 : 
; 5151 :     m_pVoice = ADDREF(pVoice);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pVoice$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCMcpxVoiceClient@1@PAV21@@Z ; DirectSound::__AddRef
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 5152 :     m_pSettings = ADDREF(pSettings);

  00012	8b 55 10	 mov	 edx, DWORD PTR _pSettings$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCDirectSoundVoiceSettings@1@PAV21@@Z ; DirectSound::__AddRef
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 5153 : 
; 5154 :     //
; 5155 :     // If we're a 3D voice, add ourselves to the 3D voice list
; 5156 :     //
; 5157 : 
; 5158 :     if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)

  00021	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00024	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00027	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002a	83 e1 10	 and	 ecx, 16			; 00000010H
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 16		 je	 SHORT $L36887

; 5159 :     {
; 5160 :         InsertTailList(&m_pDirectSound->m_lst3dVoices, &m_le3dVoice);

  00031	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00034	83 c2 14	 add	 edx, 20			; 00000014H
  00037	52		 push	 edx
  00038	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003e	83 c1 10	 add	 ecx, 16			; 00000010H
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ?InsertTailList@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailList
$L36887:

; 5161 :     }
; 5162 : 
; 5163 :     DPF_LEAVE_VOID();
; 5164 : }

  00047	5d		 pop	 ebp
  00048	c2 0c 00	 ret	 12			; 0000000cH
?Initialize@CDirectSoundVoice@DirectSound@@QAGXPAVCMcpxVoiceClient@2@PAVCDirectSoundVoiceSettings@2@@Z ENDP ; DirectSound::CDirectSoundVoice::Initialize
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\ntlist.h
DSOUND	ENDS
;	COMDAT ?InsertTailList@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT
_ListHead$ = 8
_Entry$ = 12
?InsertTailList@@YGXPAU_LIST_ENTRY@@0@Z PROC NEAR	; InsertTailList, COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 117  :     AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);
; 118  :     AssertValidEntryList(Entry, ASSERT_NOT_IN_LIST);
; 119  : 
; 120  :     Entry->Flink = ListHead;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 121  :     Entry->Blink = ListHead->Blink;

  0000b	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  0000e	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 122  :     
; 123  :     Entry->Blink->Flink = Entry;

  00017	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 124  :     Entry->Flink->Blink = Entry;

  00022	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0002a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 125  : 
; 126  :     AssertValidEntryList(Entry, ASSERT_IN_LIST);
; 127  : }    

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?InsertTailList@@YGXPAU_LIST_ENTRY@@0@Z ENDP		; InsertTailList
DSOUND	ENDS
PUBLIC	?SetMixBins@CMcpxVoiceClient@DirectSound@@QAEJXZ ; DirectSound::CMcpxVoiceClient::SetMixBins
PUBLIC	?SetPitch@CMcpxVoiceClient@DirectSound@@QAEJXZ	; DirectSound::CMcpxVoiceClient::SetPitch
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
;	COMDAT ?SetFormat@CDirectSoundVoice@DirectSound@@QAGJPBUtWAVEFORMATEX@@@Z
DSOUND	SEGMENT
_hr$ = -8
_fSetMixBins$ = -4
_this$ = 8
_pwfxFormat$ = 12
?SetFormat@CDirectSoundVoice@DirectSound@@QAGJPBUtWAVEFORMATEX@@@Z PROC NEAR ; DirectSound::CDirectSoundVoice::SetFormat, COMDAT

; 5190 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 5191 :     BOOL                    fSetMixBins;
; 5192 :     HRESULT                 hr;
; 5193 : 
; 5194 :     DPF_ENTER();
; 5195 : 
; 5196 : #ifdef VALIDATE_PARAMETERS
; 5197 : 
; 5198 :     if(!pwfxFormat)
; 5199 :     {
; 5200 :         DPF_ERROR("Failed to specify a buffer format");
; 5201 :     }
; 5202 : 
; 5203 :     if(!IsValidFormat(pwfxFormat))
; 5204 :     {
; 5205 :         DPF_ERROR("Invalid voice format");
; 5206 :     }
; 5207 : 
; 5208 :     if((m_pSettings->m_dwFlags & DSBCAPS_CTRL3D) && (1 != pwfxFormat->nChannels))
; 5209 :     {
; 5210 :         DPF_ERROR("3D voices must be mono");
; 5211 :     }
; 5212 : 
; 5213 :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 5214 :     {
; 5215 :         DPF_ERROR("Can't call SetFormat on MIXIN or FXIN buffers");
; 5216 :     }
; 5217 : 
; 5218 : #endif // VALIDATE_PARAMETERS
; 5219 : 
; 5220 :     //
; 5221 :     // Update the settings object
; 5222 :     //
; 5223 : 
; 5224 :     fSetMixBins = m_pSettings->SetFormat(pwfxFormat, TRUE);

  00006	6a 01		 push	 1
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pwfxFormat$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00012	e8 00 00 00 00	 call	 ?SetFormat@CDirectSoundVoiceSettings@DirectSound@@QAEHPBUtWAVEFORMATEX@@H@Z ; DirectSound::CDirectSoundVoiceSettings::SetFormat
  00017	89 45 fc	 mov	 DWORD PTR _fSetMixBins$[ebp], eax

; 5225 : 
; 5226 :     //
; 5227 :     // Update the implementation object
; 5228 :     //
; 5229 : 
; 5230 :     hr = m_pVoice->SetFormat();

  0001a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00026	8b 10		 mov	 edx, DWORD PTR [eax]
  00028	ff 52 10	 call	 DWORD PTR [edx+16]
  0002b	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 5231 : 
; 5232 :     //
; 5233 :     // In some cases, the mixbins are defined by the format structure
; 5234 :     //
; 5235 :     
; 5236 :     if(SUCCEEDED(hr) && fSetMixBins)

  0002e	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00032	7c 14		 jl	 SHORT $L36904
  00034	83 7d fc 00	 cmp	 DWORD PTR _fSetMixBins$[ebp], 0
  00038	74 0e		 je	 SHORT $L36904

; 5237 :     {
; 5238 :         hr = m_pVoice->SetMixBins();

  0003a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00040	e8 00 00 00 00	 call	 ?SetMixBins@CMcpxVoiceClient@DirectSound@@QAEJXZ ; DirectSound::CMcpxVoiceClient::SetMixBins
  00045	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L36904:

; 5239 :     }
; 5240 : 
; 5241 :     //
; 5242 :     // Make sure the pitch is updated as well
; 5243 :     //
; 5244 : 
; 5245 :     if(SUCCEEDED(hr))

  00048	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004c	7c 0b		 jl	 SHORT $L36906

; 5246 :     {
; 5247 :         m_pVoice->SetPitch();

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00054	e8 00 00 00 00	 call	 ?SetPitch@CMcpxVoiceClient@DirectSound@@QAEJXZ ; DirectSound::CMcpxVoiceClient::SetPitch
$L36906:

; 5248 :     }
; 5249 :     
; 5250 :     DPF_LEAVE_HRESULT(hr);
; 5251 : 
; 5252 :     return hr;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 5253 : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
?SetFormat@CDirectSoundVoice@DirectSound@@QAGJPBUtWAVEFORMATEX@@@Z ENDP ; DirectSound::CDirectSoundVoice::SetFormat
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetFrequency@CDirectSoundVoice@DirectSound@@QAGJK@Z
DSOUND	SEGMENT
_hr$ = -4
_this$ = 8
_dwFrequency$ = 12
?SetFrequency@CDirectSoundVoice@DirectSound@@QAGJK@Z PROC NEAR ; DirectSound::CDirectSoundVoice::SetFrequency, COMDAT

; 5279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 5280 :     HRESULT                 hr;
; 5281 : 
; 5282 :     DPF_ENTER();
; 5283 : 
; 5284 : #ifdef VALIDATE_PARAMETERS
; 5285 : 
; 5286 :     if(dwFrequency)
; 5287 :     {
; 5288 :         if((dwFrequency < DSBFREQUENCY_MIN) || (dwFrequency > DSBFREQUENCY_MAX))
; 5289 :         {
; 5290 :             DPF_ERROR("Invalid frequency value");
; 5291 :         }
; 5292 :     }
; 5293 : 
; 5294 : #endif // VALIDATE_PARAMETERS
; 5295 : 
; 5296 :     //
; 5297 :     // Convert frequency to pitch.  0 frequency means use the default.
; 5298 :     //
; 5299 : 
; 5300 :     if(!dwFrequency)

  00004	83 7d 0c 00	 cmp	 DWORD PTR _dwFrequency$[ebp], 0
  00008	75 0c		 jne	 SHORT $L36912

; 5301 :     {
; 5302 :         dwFrequency = m_pSettings->m_fmt.nSamplesPerSec;

  0000a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00010	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00013	89 55 0c	 mov	 DWORD PTR _dwFrequency$[ebp], edx
$L36912:

; 5303 :     }
; 5304 : 
; 5305 :     hr = SetPitch(XAudioCalculatePitch(dwFrequency));

  00016	8b 45 0c	 mov	 eax, DWORD PTR _dwFrequency$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _XAudioCalculatePitch@4
  0001f	50		 push	 eax
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?SetPitch@CDirectSoundVoice@DirectSound@@QAGJJ@Z ; DirectSound::CDirectSoundVoice::SetPitch
  00029	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 5306 : 
; 5307 :     DPF_LEAVE_HRESULT(hr);
; 5308 : 
; 5309 :     return hr;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 5310 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
?SetFrequency@CDirectSoundVoice@DirectSound@@QAGJK@Z ENDP ; DirectSound::CDirectSoundVoice::SetFrequency
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetPitch@CDirectSoundVoice@DirectSound@@QAGJJ@Z
DSOUND	SEGMENT
_hr$ = -4
_this$ = 8
_lPitch$ = 12
?SetPitch@CDirectSoundVoice@DirectSound@@QAGJJ@Z PROC NEAR ; DirectSound::CDirectSoundVoice::SetPitch, COMDAT

; 5336 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 5337 :     HRESULT                 hr;
; 5338 : 
; 5339 :     DPF_ENTER();
; 5340 : 
; 5341 : #ifdef VALIDATE_PARAMETERS
; 5342 : 
; 5343 :     if((lPitch < DSBPITCH_MIN) || (lPitch > DSBPITCH_MAX))
; 5344 :     {
; 5345 :         DPF_ERROR("Invalid pitch value");
; 5346 :     }
; 5347 : 
; 5348 : #endif // VALIDATE_PARAMETERS
; 5349 : 
; 5350 :     //
; 5351 :     // Update the settings object
; 5352 :     //
; 5353 : 
; 5354 :     m_pSettings->m_lPitch = lPitch;

  00004	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00007	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000a	8b 55 0c	 mov	 edx, DWORD PTR _lPitch$[ebp]
  0000d	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 5355 : 
; 5356 :     //
; 5357 :     // Notify the implementation object of the change
; 5358 :     //
; 5359 : 
; 5360 :     hr = m_pVoice->SetPitch();

  00010	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00016	e8 00 00 00 00	 call	 ?SetPitch@CMcpxVoiceClient@DirectSound@@QAEJXZ ; DirectSound::CMcpxVoiceClient::SetPitch
  0001b	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 5361 : 
; 5362 :     DPF_LEAVE_HRESULT(hr);
; 5363 : 
; 5364 :     return hr;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 5365 : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?SetPitch@CDirectSoundVoice@DirectSound@@QAGJJ@Z ENDP	; DirectSound::CDirectSoundVoice::SetPitch
DSOUND	ENDS
PUBLIC	?SetVolume@CMcpxVoiceClient@DirectSound@@QAEJXZ	; DirectSound::CMcpxVoiceClient::SetVolume
; Function compile flags: /Odt
;	COMDAT ?SetVolume@CDirectSoundVoice@DirectSound@@QAGJJ@Z
DSOUND	SEGMENT
_hr$ = -4
_this$ = 8
_lVolume$ = 12
?SetVolume@CDirectSoundVoice@DirectSound@@QAGJJ@Z PROC NEAR ; DirectSound::CDirectSoundVoice::SetVolume, COMDAT

; 5391 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 5392 :     HRESULT                 hr;
; 5393 : 
; 5394 :     DPF_ENTER();
; 5395 : 
; 5396 : #ifdef VALIDATE_PARAMETERS
; 5397 : 
; 5398 :     if((lVolume < DSBVOLUME_MIN) || (lVolume > DSBVOLUME_MAX))
; 5399 :     {
; 5400 :         DPF_ERROR("Volume value out-of-bounds");
; 5401 :     }
; 5402 : 
; 5403 : #endif // VALIDATE_PARAMETERS
; 5404 : 
; 5405 :     //
; 5406 :     // Save the volume to the settings
; 5407 :     //
; 5408 : 
; 5409 :     m_pSettings->SetVolume(lVolume);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _lVolume$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000e	e8 00 00 00 00	 call	 ?SetVolume@CDirectSoundVoiceSettings@DirectSound@@QAEXJ@Z ; DirectSound::CDirectSoundVoiceSettings::SetVolume

; 5410 :     
; 5411 :     //
; 5412 :     // Notify the implementation object
; 5413 :     //
; 5414 : 
; 5415 :     hr = m_pVoice->SetVolume();

  00013	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00016	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00019	e8 00 00 00 00	 call	 ?SetVolume@CMcpxVoiceClient@DirectSound@@QAEJXZ ; DirectSound::CMcpxVoiceClient::SetVolume
  0001e	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 5416 : 
; 5417 :     DPF_LEAVE_HRESULT(hr);
; 5418 : 
; 5419 :     return hr;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 5420 : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?SetVolume@CDirectSoundVoice@DirectSound@@QAGJJ@Z ENDP	; DirectSound::CDirectSoundVoice::SetVolume
DSOUND	ENDS
PUBLIC	?SetLFO@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSLFODESC@@@Z ; DirectSound::CMcpxVoiceClient::SetLFO
; Function compile flags: /Odt
;	COMDAT ?SetLFO@CDirectSoundVoice@DirectSound@@QAGJPBU_DSLFODESC@@@Z
DSOUND	SEGMENT
_hr$ = -4
_this$ = 8
_pLfo$ = 12
?SetLFO@CDirectSoundVoice@DirectSound@@QAGJPBU_DSLFODESC@@@Z PROC NEAR ; DirectSound::CDirectSoundVoice::SetLFO, COMDAT

; 5446 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 5447 :     HRESULT                 hr;
; 5448 : 
; 5449 :     DPF_ENTER();
; 5450 : 
; 5451 : #ifdef VALIDATE_PARAMETERS
; 5452 : 
; 5453 :     if(!pLfo)
; 5454 :     {
; 5455 :         DPF_ERROR("LFO description not provided");
; 5456 :     }
; 5457 : 
; 5458 :     if((pLfo->dwLFO < DSLFO_FIRST) && (pLfo->dwLFO > DSLFO_LAST))
; 5459 :     {
; 5460 :         DPF_ERROR("Invalid LFO identifier");
; 5461 :     }
; 5462 : 
; 5463 :     if((pLfo->dwDelay < DSLFO_DELAY_MIN) || (pLfo->dwDelay > DSLFO_DELAY_MAX))
; 5464 :     {
; 5465 :         DPF_ERROR("Invalid LFO delay value");
; 5466 :     }
; 5467 : 
; 5468 :     if((pLfo->dwDelta < DSLFO_DELTA_MIN) || (pLfo->dwDelta > DSLFO_DELTA_MAX))
; 5469 :     {
; 5470 :         DPF_ERROR("Invalid LFO delta value");
; 5471 :     }
; 5472 : 
; 5473 :     if((pLfo->lPitchModulation < DSLFO_PITCHMOD_MIN) || (pLfo->lPitchModulation > DSLFO_PITCHMOD_MAX))
; 5474 :     {
; 5475 :         DPF_ERROR("Invalid LFO pitch modulation value");
; 5476 :     }
; 5477 : 
; 5478 :     if((pLfo->lFilterCutOffRange < DSLFO_FCRANGE_MIN) || (pLfo->lFilterCutOffRange > DSLFO_FCRANGE_MAX))
; 5479 :     {
; 5480 :         DPF_ERROR("Invalid LFO filter cutoff value");
; 5481 :     }
; 5482 : 
; 5483 :     if((pLfo->lAmplitudeModulation < DSLFO_AMPMOD_MIN) || (pLfo->lAmplitudeModulation > DSLFO_AMPMOD_MAX))
; 5484 :     {
; 5485 :         DPF_ERROR("Invalid LFO amplitude modulation value");
; 5486 :     }
; 5487 : 
; 5488 :     if(pLfo->dwLFO != DSLFO_MULTI)
; 5489 :     {
; 5490 :         if(pLfo->lFilterCutOffRange || pLfo->lAmplitudeModulation)
; 5491 :         {
; 5492 :             DPF_WARNING("The pitch LFO doesn not support filter cut-off range or amplitude modulation");
; 5493 :         }
; 5494 :     }
; 5495 : 
; 5496 : #endif // VALIDATE_PARAMETERS
; 5497 : 
; 5498 :     //
; 5499 :     // Hand off to the implementation object
; 5500 :     //
; 5501 : 
; 5502 :     hr = m_pVoice->SetLFO(pLfo);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _pLfo$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0000e	e8 00 00 00 00	 call	 ?SetLFO@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSLFODESC@@@Z ; DirectSound::CMcpxVoiceClient::SetLFO
  00013	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 5503 : 
; 5504 :     DPF_LEAVE_HRESULT(hr);
; 5505 : 
; 5506 :     return hr;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 5507 : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?SetLFO@CDirectSoundVoice@DirectSound@@QAGJPBU_DSLFODESC@@@Z ENDP ; DirectSound::CDirectSoundVoice::SetLFO
DSOUND	ENDS
PUBLIC	?SetEG@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSENVELOPEDESC@@@Z ; DirectSound::CMcpxVoiceClient::SetEG
; Function compile flags: /Odt
;	COMDAT ?SetEG@CDirectSoundVoice@DirectSound@@QAGJPBU_DSENVELOPEDESC@@@Z
DSOUND	SEGMENT
_hr$ = -4
_this$ = 8
_pEnv$ = 12
?SetEG@CDirectSoundVoice@DirectSound@@QAGJPBU_DSENVELOPEDESC@@@Z PROC NEAR ; DirectSound::CDirectSoundVoice::SetEG, COMDAT

; 5533 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 5534 :     HRESULT                 hr;
; 5535 : 
; 5536 :     DPF_ENTER();
; 5537 : 
; 5538 : #ifdef VALIDATE_PARAMETERS
; 5539 : 
; 5540 :     if(!pEnv)
; 5541 :     {
; 5542 :         DPF_ERROR("Envelope description not provided");
; 5543 :     }
; 5544 : 
; 5545 :     if((pEnv->dwEG < DSEG_FIRST) || (pEnv->dwEG > DSEG_LAST))
; 5546 :     {
; 5547 :         DPF_ERROR("Invalid envelope generator identifier");
; 5548 :     }
; 5549 : 
; 5550 :     if((pEnv->dwMode < DSEG_MODE_FIRST) || (pEnv->dwMode > DSEG_MODE_LAST))
; 5551 :     {
; 5552 :         DPF_ERROR("Invalid envelope generator mode");
; 5553 :     }
; 5554 : 
; 5555 :     if((pEnv->dwDelay < DSEG_DELAY_MIN) || (pEnv->dwDelay > DSEG_DELAY_MAX))
; 5556 :     {
; 5557 :         DPF_ERROR("Invalid envelope delay value");
; 5558 :     }
; 5559 : 
; 5560 :     if((pEnv->dwAttack < DSEG_ATTACK_MIN) || (pEnv->dwAttack > DSEG_ATTACK_MAX))
; 5561 :     {
; 5562 :         DPF_ERROR("Invalid envelope attack value");
; 5563 :     }
; 5564 : 
; 5565 :     if((pEnv->dwHold < DSEG_HOLD_MIN) || (pEnv->dwHold > DSEG_HOLD_MAX))
; 5566 :     {
; 5567 :         DPF_ERROR("Invalid envelope hold value");
; 5568 :     }
; 5569 : 
; 5570 :     if((pEnv->dwDecay < DSEG_DECAY_MIN) || (pEnv->dwDecay > DSEG_DECAY_MAX))
; 5571 :     {
; 5572 :         DPF_ERROR("Invalid envelope decay value");
; 5573 :     }
; 5574 : 
; 5575 :     if((pEnv->dwRelease < DSEG_RELEASE_MIN) || (pEnv->dwRelease > DSEG_RELEASE_MAX))
; 5576 :     {
; 5577 :         DPF_ERROR("Invalid envelope release value");
; 5578 :     }
; 5579 : 
; 5580 :     if((pEnv->dwSustain < DSEG_SUSTAIN_MIN) || (pEnv->dwSustain > DSEG_SUSTAIN_MAX))
; 5581 :     {
; 5582 :         DPF_ERROR("Invalid envelope sustain value");
; 5583 :     }
; 5584 : 
; 5585 :     if((pEnv->lPitchScale < DSEG_PITCHSCALE_MIN) || (pEnv->lPitchScale > DSEG_PITCHSCALE_MAX))
; 5586 :     {
; 5587 :         DPF_ERROR("Invalid envelope pitch scale value");
; 5588 :     }
; 5589 : 
; 5590 :     if((pEnv->lFilterCutOff < DSEG_FILTERCUTOFF_MIN) || (pEnv->lFilterCutOff > DSEG_FILTERCUTOFF_MAX))
; 5591 :     {
; 5592 :         DPF_ERROR("Invalid envelope filter cutoff value");
; 5593 :     }
; 5594 : 
; 5595 :     if(pEnv->dwEG != DSEG_MULTI)
; 5596 :     {
; 5597 :         if(pEnv->lPitchScale || pEnv->lFilterCutOff)
; 5598 :         {
; 5599 :             DPF_WARNING("The amplitude envelope doesn not support pitch scale or filter cutoff");
; 5600 :         }
; 5601 :     }
; 5602 : 
; 5603 : #endif // VALIDATE_PARAMETERS
; 5604 : 
; 5605 :     //
; 5606 :     // Hand off to the implementation object
; 5607 :     //
; 5608 : 
; 5609 :     hr = m_pVoice->SetEG(pEnv);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _pEnv$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0000e	e8 00 00 00 00	 call	 ?SetEG@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSENVELOPEDESC@@@Z ; DirectSound::CMcpxVoiceClient::SetEG
  00013	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 5610 : 
; 5611 :     DPF_LEAVE_HRESULT(hr);
; 5612 : 
; 5613 :     return hr;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 5614 : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?SetEG@CDirectSoundVoice@DirectSound@@QAGJPBU_DSENVELOPEDESC@@@Z ENDP ; DirectSound::CDirectSoundVoice::SetEG
DSOUND	ENDS
PUBLIC	?SetFilter@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSFILTERDESC@@@Z ; DirectSound::CMcpxVoiceClient::SetFilter
; Function compile flags: /Odt
;	COMDAT ?SetFilter@CDirectSoundVoice@DirectSound@@QAGJPBU_DSFILTERDESC@@@Z
DSOUND	SEGMENT
_hr$ = -4
_this$ = 8
_pFilter$ = 12
?SetFilter@CDirectSoundVoice@DirectSound@@QAGJPBU_DSFILTERDESC@@@Z PROC NEAR ; DirectSound::CDirectSoundVoice::SetFilter, COMDAT

; 5640 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 5641 :     HRESULT                 hr;
; 5642 : 
; 5643 : #ifdef VALIDATE_PARAMETERS
; 5644 : 
; 5645 :     DWORD                   i;
; 5646 : 
; 5647 : #endif // VALIDATE_PARAMETERS
; 5648 : 
; 5649 :     DPF_ENTER();
; 5650 : 
; 5651 : #ifdef VALIDATE_PARAMETERS
; 5652 : 
; 5653 :     if(!pFilter)
; 5654 :     {
; 5655 :         DPF_ERROR("Filter description not provided");
; 5656 :     }
; 5657 : 
; 5658 :     if((pFilter->dwMode < DSFILTER_MODE_FIRST) || (pFilter->dwMode > DSFILTER_MODE_LAST))
; 5659 :     {
; 5660 :         DPF_ERROR("Invalid filter mode");
; 5661 :     }
; 5662 : 
; 5663 :     if(pFilter->dwQCoefficient > 7)
; 5664 :     {
; 5665 :         DPF_ERROR("Invalid Q-coefficient value");
; 5666 :     }
; 5667 : 
; 5668 :     for(i = 0; i < NUMELMS(pFilter->adwCoefficients); i++)
; 5669 :     {
; 5670 :         if(pFilter->adwCoefficients[i] > 0xFFFF)
; 5671 :         {
; 5672 :             DPF_ERROR("Invalid coefficient value (index %lu)", i);
; 5673 :         }
; 5674 :     }
; 5675 : 
; 5676 :     if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
; 5677 :     {
; 5678 :         if(DSFILTER_MODE_BYPASS == pFilter->dwMode)
; 5679 :         {
; 5680 :             DPF_ERROR("The filter can't be bypassed on a 3D voice");
; 5681 :         }
; 5682 : 
; 5683 :         for(i = 2; i < NUMELMS(pFilter->adwCoefficients); i++)
; 5684 :         {
; 5685 :             if(pFilter->adwCoefficients[i])
; 5686 :             {
; 5687 :                 DPF_ERROR("Only the first 2 coefficients are valid on a 3D voice");
; 5688 :             }
; 5689 :         }
; 5690 :     }
; 5691 : 
; 5692 : #endif // VALIDATE_PARAMETERS
; 5693 : 
; 5694 :     //
; 5695 :     // Hand off to the implementation object
; 5696 :     //
; 5697 : 
; 5698 :     hr = m_pVoice->SetFilter(pFilter);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _pFilter$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0000e	e8 00 00 00 00	 call	 ?SetFilter@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSFILTERDESC@@@Z ; DirectSound::CMcpxVoiceClient::SetFilter
  00013	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 5699 : 
; 5700 :     DPF_LEAVE_HRESULT(hr);
; 5701 : 
; 5702 :     return hr;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 5703 : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?SetFilter@CDirectSoundVoice@DirectSound@@QAGJPBU_DSFILTERDESC@@@Z ENDP ; DirectSound::CDirectSoundVoice::SetFilter
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetHeadroom@CDirectSoundVoice@DirectSound@@QAGJK@Z
DSOUND	SEGMENT
_hr$ = -4
_this$ = 8
_dwHeadroom$ = 12
?SetHeadroom@CDirectSoundVoice@DirectSound@@QAGJK@Z PROC NEAR ; DirectSound::CDirectSoundVoice::SetHeadroom, COMDAT

; 5729 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 5730 :     HRESULT                 hr;
; 5731 : 
; 5732 :     DPF_ENTER();
; 5733 : 
; 5734 : #ifdef VALIDATE_PARAMETERS
; 5735 : 
; 5736 :     if((dwHeadroom < DSBHEADROOM_MIN) || (dwHeadroom > DSBHEADROOM_MAX))
; 5737 :     {
; 5738 :         DPF_ERROR("Headroom value out-of-bounds");
; 5739 :     }
; 5740 : 
; 5741 : #endif // VALIDATE_PARAMETERS
; 5742 : 
; 5743 :     //
; 5744 :     // Save the headroom to the settings
; 5745 :     //
; 5746 : 
; 5747 :     m_pSettings->SetHeadroom(dwHeadroom);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _dwHeadroom$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000e	e8 00 00 00 00	 call	 ?SetHeadroom@CDirectSoundVoiceSettings@DirectSound@@QAEXK@Z ; DirectSound::CDirectSoundVoiceSettings::SetHeadroom

; 5748 :     
; 5749 :     //
; 5750 :     // Headroom affects voice volume, so notify the implementation object
; 5751 :     //
; 5752 : 
; 5753 :     hr = m_pVoice->SetVolume();

  00013	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00016	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00019	e8 00 00 00 00	 call	 ?SetVolume@CMcpxVoiceClient@DirectSound@@QAEJXZ ; DirectSound::CMcpxVoiceClient::SetVolume
  0001e	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 5754 : 
; 5755 :     DPF_LEAVE_HRESULT(hr);
; 5756 : 
; 5757 :     return hr;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 5758 : }    

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?SetHeadroom@CDirectSoundVoice@DirectSound@@QAGJK@Z ENDP ; DirectSound::CDirectSoundVoice::SetHeadroom
DSOUND	ENDS
PUBLIC	?ConnectVoice@CMcpxVoiceClient@DirectSound@@QAEJXZ ; DirectSound::CMcpxVoiceClient::ConnectVoice
PUBLIC	?DisconnectVoice@CMcpxVoiceClient@DirectSound@@QAEJXZ ; DirectSound::CMcpxVoiceClient::DisconnectVoice
; Function compile flags: /Odt
;	COMDAT ?SetOutputBuffer@CDirectSoundVoice@DirectSound@@QAGJPAUIDirectSoundBuffer@@@Z
DSOUND	SEGMENT
tv66 = -12
_hr$ = -8
_pMixinBuffer$ = -4
_this$ = 8
_pOutputBuffer$ = 12
?SetOutputBuffer@CDirectSoundVoice@DirectSound@@QAGJPAUIDirectSoundBuffer@@@Z PROC NEAR ; DirectSound::CDirectSoundVoice::SetOutputBuffer, COMDAT

; 5785 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 5786 :     CDirectSoundBuffer *    pMixinBuffer    = (CDirectSoundBuffer *)pOutputBuffer;

  00006	83 7d 0c 00	 cmp	 DWORD PTR _pOutputBuffer$[ebp], 0
  0000a	74 0b		 je	 SHORT $L41820
  0000c	8b 45 0c	 mov	 eax, DWORD PTR _pOutputBuffer$[ebp]
  0000f	83 e8 1c	 sub	 eax, 28			; 0000001cH
  00012	89 45 f4	 mov	 DWORD PTR tv66[ebp], eax
  00015	eb 07		 jmp	 SHORT $L41821
$L41820:
  00017	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$L41821:
  0001e	8b 4d f4	 mov	 ecx, DWORD PTR tv66[ebp]
  00021	89 4d fc	 mov	 DWORD PTR _pMixinBuffer$[ebp], ecx

; 5787 :     HRESULT                 hr              = DS_OK;

  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 5788 : 
; 5789 : #ifdef VALIDATE_PARAMETERS
; 5790 :     
; 5791 :     static BOOL             fSubMixHeadroom = FALSE;
; 5792 :     DWORD                   i;
; 5793 : 
; 5794 : #endif // VALIDATE_PARAMETERS
; 5795 : 
; 5796 :     DPF_ENTER();
; 5797 : 
; 5798 : #ifdef VALIDATE_PARAMETERS
; 5799 : 
; 5800 :     if(pMixinBuffer)
; 5801 :     {
; 5802 :         if(!(pMixinBuffer->m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK))
; 5803 :         {
; 5804 :             DPF_ERROR("Output buffer specified is not a MIXIN/FXIN buffer");
; 5805 :         }
; 5806 : 
; 5807 :         if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 5808 :         {
; 5809 :             DPF_ERROR("Can't set the output buffer on MIXIN/FXIN buffers");
; 5810 :         }
; 5811 : 
; 5812 :         if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
; 5813 :         {
; 5814 :             DPF_ERROR("Can't submix a 3D buffer.  Create a 2D source buffer and a 3D destination buffer.");
; 5815 :         }
; 5816 : 
; 5817 :         if(1 != m_pSettings->m_fmt.nChannels)
; 5818 :         {
; 5819 :             DPF_ERROR("Can only submix mono source voices");
; 5820 :         }
; 5821 : 
; 5822 :         if(m_pSettings->m_dwMixBinCount >= NUMELMS(m_pSettings->m_abMixBins))
; 5823 :         {
; 5824 :             DPF_ERROR("Submixed voices must leave one mixbin slot free");
; 5825 :         }
; 5826 : 
; 5827 :         if(!fSubMixHeadroom)
; 5828 :         {
; 5829 :             if(m_pDirectSound->m_pSettings->m_abMixBinHeadroom[pMixinBuffer->m_pSettings->m_dwInputMixBin])
; 5830 :             {
; 5831 :                 DPF_WARNING("The headroom for the mixbin your submix destination is reading from is");
; 5832 :                 DPF_WARNING("non-zero.  This will be additive with the headroom that your submix");
; 5833 :                 DPF_WARNING("destination is reading to, possibly giving you more headroom that you want.");
; 5834 :                 DPF_WARNING("You will only see this warning once.");
; 5835 :                 
; 5836 :                 fSubMixHeadroom = TRUE;
; 5837 :             }
; 5838 :         }
; 5839 :     }
; 5840 : 
; 5841 : #endif // VALIDATE_PARAMETERS
; 5842 : 
; 5843 :     if(pMixinBuffer != m_pSettings->m_pMixinBuffer)

  0002b	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _pMixinBuffer$[ebp]
  00034	3b 88 b0 00 00
	00		 cmp	 ecx, DWORD PTR [eax+176]
  0003a	74 4c		 je	 SHORT $L36951

; 5844 :     {
; 5845 :         //
; 5846 :         // Disconnect from the current buffer
; 5847 :         //
; 5848 : 
; 5849 :         if(m_pSettings->m_pMixinBuffer)

  0003c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00042	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [eax+176], 0
  00049	74 0e		 je	 SHORT $L36952

; 5850 :         {
; 5851 :             hr = m_pVoice->DisconnectVoice();

  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00051	e8 00 00 00 00	 call	 ?DisconnectVoice@CMcpxVoiceClient@DirectSound@@QAEJXZ ; DirectSound::CMcpxVoiceClient::DisconnectVoice
  00056	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L36952:

; 5852 :         }
; 5853 :         
; 5854 :         //
; 5855 :         // Update the settings object
; 5856 :         //
; 5857 : 
; 5858 :         if(SUCCEEDED(hr))

  00059	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0005d	7c 0f		 jl	 SHORT $L36954

; 5859 :         {
; 5860 :             m_pSettings->SetOutputBuffer(pMixinBuffer);

  0005f	8b 55 fc	 mov	 edx, DWORD PTR _pMixinBuffer$[ebp]
  00062	52		 push	 edx
  00063	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00069	e8 00 00 00 00	 call	 ?SetOutputBuffer@CDirectSoundVoiceSettings@DirectSound@@QAEXPAVCDirectSoundBuffer@2@@Z ; DirectSound::CDirectSoundVoiceSettings::SetOutputBuffer
$L36954:

; 5861 :         }
; 5862 : 
; 5863 :         //
; 5864 :         // Hand off to the implementation object.  ConnectVoice handles
; 5865 :         // resetting the mixbins and mixbin volumes as well as voice list
; 5866 :         // management.
; 5867 :         //
; 5868 : 
; 5869 :         if(SUCCEEDED(hr) && pMixinBuffer)

  0006e	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00072	7c 14		 jl	 SHORT $L36951
  00074	83 7d fc 00	 cmp	 DWORD PTR _pMixinBuffer$[ebp], 0
  00078	74 0e		 je	 SHORT $L36951

; 5870 :         {
; 5871 :             hr = m_pVoice->ConnectVoice();

  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00080	e8 00 00 00 00	 call	 ?ConnectVoice@CMcpxVoiceClient@DirectSound@@QAEJXZ ; DirectSound::CMcpxVoiceClient::ConnectVoice
  00085	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L36951:

; 5872 :         }
; 5873 :     }
; 5874 : 
; 5875 :     DPF_LEAVE_HRESULT(hr);
; 5876 : 
; 5877 :     return hr;

  00088	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 5878 : }

  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
?SetOutputBuffer@CDirectSoundVoice@DirectSound@@QAGJPAUIDirectSoundBuffer@@@Z ENDP ; DirectSound::CDirectSoundVoice::SetOutputBuffer
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetMixBins@CDirectSoundVoice@DirectSound@@QAGJPBU_DSMIXBINS@@@Z
DSOUND	SEGMENT
_hr$ = -4
_this$ = 8
_pMixBins$ = 12
?SetMixBins@CDirectSoundVoice@DirectSound@@QAGJPBU_DSMIXBINS@@@Z PROC NEAR ; DirectSound::CDirectSoundVoice::SetMixBins, COMDAT

; 5904 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 5905 :     HRESULT                 hr;
; 5906 : 
; 5907 : #ifdef VALIDATE_PARAMETERS  
; 5908 : 
; 5909 :     DWORD                   i;
; 5910 :    
; 5911 : #endif // VALIDATE_PARAMETERS    
; 5912 : 
; 5913 :     DPF_ENTER();
; 5914 : 
; 5915 : #ifdef VALIDATE_PARAMETERS
; 5916 : 
; 5917 :     if(pMixBins)
; 5918 :     {
; 5919 :         if(pMixBins->dwMixBinCount)
; 5920 :         {
; 5921 :             if(pMixBins->dwMixBinCount > DSMIXBIN_ASSIGNMENT_MAX)
; 5922 :             {
; 5923 :                 DPF_ERROR("No voice can be assigned to more than %lu mix bins", DSMIXBIN_ASSIGNMENT_MAX);
; 5924 :             }
; 5925 :         
; 5926 :             if(pMixBins->dwMixBinCount % m_pSettings->m_fmt.nChannels)
; 5927 :             {
; 5928 :                 DPF_ERROR("The mixbin count must be a multiple of the channel count");
; 5929 :             }
; 5930 : 
; 5931 :             for(i = 0; i < pMixBins->dwMixBinCount; i++)
; 5932 :             {
; 5933 :                 if(pMixBins->lpMixBinVolumePairs[i].dwMixBin > DSMIXBIN_LAST)
; 5934 :                 {
; 5935 :                     DPF_ERROR("Specified an invalid mixbin");
; 5936 :                 }
; 5937 :             }
; 5938 : 
; 5939 :             if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
; 5940 :             {
; 5941 :                 if(pMixBins->dwMixBinCount < DirectSoundRequiredMixBins_3D.dwMixBinCount)
; 5942 :                 {
; 5943 :                     DPF_ERROR("MixBin count doesn't include enough mixbins to hold all required for 3D");
; 5944 :                 }
; 5945 :             
; 5946 :                 for(i = 0; i < DirectSoundRequiredMixBins_3D.dwMixBinCount; i++)
; 5947 :                 {
; 5948 :                     if(pMixBins->lpMixBinVolumePairs[i].dwMixBin != DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[i].dwMixBin)
; 5949 :                     {
; 5950 :                         DPF_ERROR("MixBin array does not include the required 3D bins");
; 5951 :                     }
; 5952 :                 }
; 5953 :             }
; 5954 :         }
; 5955 :     }
; 5956 : 
; 5957 : #endif // VALIDATE_PARAMETERS
; 5958 : 
; 5959 :     //
; 5960 :     // Save settings
; 5961 :     //
; 5962 : 
; 5963 :     m_pSettings->SetMixBins(pMixBins);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _pMixBins$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000e	e8 00 00 00 00	 call	 ?SetMixBins@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundVoiceSettings::SetMixBins

; 5964 : 
; 5965 :     //
; 5966 :     // Hand off to the implementation object
; 5967 :     //
; 5968 : 
; 5969 :     hr = m_pVoice->SetMixBins();

  00013	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00016	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00019	e8 00 00 00 00	 call	 ?SetMixBins@CMcpxVoiceClient@DirectSound@@QAEJXZ ; DirectSound::CMcpxVoiceClient::SetMixBins
  0001e	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 5970 : 
; 5971 :     DPF_LEAVE_HRESULT(hr);
; 5972 : 
; 5973 :     return hr;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 5974 : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?SetMixBins@CDirectSoundVoice@DirectSound@@QAGJPBU_DSMIXBINS@@@Z ENDP ; DirectSound::CDirectSoundVoice::SetMixBins
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetMixBinVolumes@CDirectSoundVoice@DirectSound@@QAGJPBU_DSMIXBINS@@@Z
DSOUND	SEGMENT
_hr$ = -4
_this$ = 8
_pMixBins$ = 12
?SetMixBinVolumes@CDirectSoundVoice@DirectSound@@QAGJPBU_DSMIXBINS@@@Z PROC NEAR ; DirectSound::CDirectSoundVoice::SetMixBinVolumes, COMDAT

; 6001 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 6002 :     HRESULT                 hr;
; 6003 : 
; 6004 : #ifdef VALIDATE_PARAMETERS
; 6005 : 
; 6006 :     DWORD                   i, z;
; 6007 : 
; 6008 : #endif // VALIDATE_PARAMETERS
; 6009 : 
; 6010 :     DPF_ENTER();
; 6011 : 
; 6012 : #ifdef VALIDATE_PARAMETERS
; 6013 : 
; 6014 :     if(!pMixBins)
; 6015 :     {
; 6016 :         DPF_ERROR("Failed to supply any volume data");
; 6017 :     }
; 6018 : 
; 6019 :     if(pMixBins->dwMixBinCount > DSMIXBIN_ASSIGNMENT_MAX)
; 6020 :     {
; 6021 :         DPF_ERROR("Invalid mixbin count");
; 6022 :     }
; 6023 :     
; 6024 :     for(i = 0; i < pMixBins->dwMixBinCount; i++)
; 6025 :     {
; 6026 :         for(z = 0; z < m_pSettings->m_dwMixBinCount; z++)
; 6027 :         {
; 6028 :             if(pMixBins->lpMixBinVolumePairs[i].dwMixBin == m_pSettings->m_abMixBins[z])
; 6029 :             {
; 6030 :                 break;
; 6031 :             }
; 6032 :         }
; 6033 : 
; 6034 :         if(z >= m_pSettings->m_dwMixBinCount)
; 6035 :         {
; 6036 :             DPF_ERROR("Specified a mixbin the voice is not assigned to at index %lu (mixbin %lu)", i, pMixBins->lpMixBinVolumePairs[i].dwMixBin);
; 6037 :         }
; 6038 :         
; 6039 :         if((pMixBins->lpMixBinVolumePairs[i].lVolume < DSBVOLUME_MIN) || (pMixBins->lpMixBinVolumePairs[i].lVolume > DSBVOLUME_MAX))
; 6040 :         {
; 6041 :             DPF_ERROR("Invalid volume at index %lu", i);
; 6042 :         }
; 6043 :     }
; 6044 : 
; 6045 : #endif // VALIDATE_PARAMETERS
; 6046 : 
; 6047 :     //
; 6048 :     // Update the volume
; 6049 :     //
; 6050 : 
; 6051 :     m_pSettings->SetMixBinVolumes(pMixBins);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _pMixBins$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000e	e8 00 00 00 00	 call	 ?SetMixBinVolumes@CDirectSoundVoiceSettings@DirectSound@@QAEXPBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundVoiceSettings::SetMixBinVolumes

; 6052 : 
; 6053 :     //
; 6054 :     // Hand off to the implementation object
; 6055 :     //
; 6056 : 
; 6057 :     hr = m_pVoice->SetVolume();

  00013	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00016	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00019	e8 00 00 00 00	 call	 ?SetVolume@CMcpxVoiceClient@DirectSound@@QAEJXZ ; DirectSound::CMcpxVoiceClient::SetVolume
  0001e	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 6058 : 
; 6059 :     DPF_LEAVE_HRESULT(hr);
; 6060 : 
; 6061 :     return hr;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 6062 : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?SetMixBinVolumes@CDirectSoundVoice@DirectSound@@QAGJPBU_DSMIXBINS@@@Z ENDP ; DirectSound::CDirectSoundVoice::SetMixBinVolumes
DSOUND	ENDS
PUBLIC	??0CDirectSoundBufferSettings@DirectSound@@QAE@XZ ; DirectSound::CDirectSoundBufferSettings::CDirectSoundBufferSettings
PUBLIC	??_7CDirectSoundBufferSettings@DirectSound@@6B@	; DirectSound::CDirectSoundBufferSettings::`vftable'
PUBLIC	??_GCDirectSoundBufferSettings@DirectSound@@UAEPAXI@Z ; DirectSound::CDirectSoundBufferSettings::`scalar deleting destructor'
EXTRN	??_ECDirectSoundBufferSettings@DirectSound@@UAEPAXI@Z:NEAR ; DirectSound::CDirectSoundBufferSettings::`vector deleting destructor'
;	COMDAT ??_7CDirectSoundBufferSettings@DirectSound@@6B@
CONST	SEGMENT
??_7CDirectSoundBufferSettings@DirectSound@@6B@ DD FLAT:??_ECDirectSoundBufferSettings@DirectSound@@UAEPAXI@Z ; DirectSound::CDirectSoundBufferSettings::`vftable'
	DD	FLAT:?AddRef@CRefCount@DirectSound@@UAGKXZ
	DD	FLAT:?Release@CRefCount@DirectSound@@UAGKXZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CDirectSoundBufferSettings@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CDirectSoundBufferSettings@DirectSound@@QAE@XZ PROC NEAR ; DirectSound::CDirectSoundBufferSettings::CDirectSoundBufferSettings, COMDAT
; _this$ = ecx

; 7168 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CDirectSoundVoiceSettings@DirectSound@@QAE@XZ ; DirectSound::CDirectSoundVoiceSettings::CDirectSoundVoiceSettings
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDirectSoundBufferSettings@DirectSound@@6B@

; 7169 :     DPF_ENTER();
; 7170 :     DPF_LEAVE_VOID();
; 7171 : }

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CDirectSoundBufferSettings@DirectSound@@QAE@XZ ENDP	; DirectSound::CDirectSoundBufferSettings::CDirectSoundBufferSettings
DSOUND	ENDS
PUBLIC	??1CDirectSoundBufferSettings@DirectSound@@UAE@XZ ; DirectSound::CDirectSoundBufferSettings::~CDirectSoundBufferSettings
; Function compile flags: /Odt
;	COMDAT ??_GCDirectSoundBufferSettings@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCDirectSoundBufferSettings@DirectSound@@UAEPAXI@Z PROC NEAR ; DirectSound::CDirectSoundBufferSettings::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CDirectSoundBufferSettings@DirectSound@@UAE@XZ ; DirectSound::CDirectSoundBufferSettings::~CDirectSoundBufferSettings
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L36982
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L36982:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCDirectSoundBufferSettings@DirectSound@@UAEPAXI@Z ENDP ; DirectSound::CDirectSoundBufferSettings::`scalar deleting destructor'
DSOUND	ENDS
PUBLIC	?SetBufferData@CDirectSoundBufferSettings@DirectSound@@QAEJPAXK@Z ; DirectSound::CDirectSoundBufferSettings::SetBufferData
PUBLIC	?SetNotificationPositions@CDirectSoundBufferSettings@DirectSound@@QAEJKPBU_DSBPOSITIONNOTIFY@@@Z ; DirectSound::CDirectSoundBufferSettings::SetNotificationPositions
; Function compile flags: /Odt
;	COMDAT ??1CDirectSoundBufferSettings@DirectSound@@UAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CDirectSoundBufferSettings@DirectSound@@UAE@XZ PROC NEAR ; DirectSound::CDirectSoundBufferSettings::~CDirectSoundBufferSettings, COMDAT
; _this$ = ecx

; 7196 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDirectSoundBufferSettings@DirectSound@@6B@

; 7197 :     DPF_ENTER();
; 7198 :     
; 7199 :     //
; 7200 :     // Free the data buffer
; 7201 :     //
; 7202 :     
; 7203 :     SetBufferData(NULL, 0);

  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?SetBufferData@CDirectSoundBufferSettings@DirectSound@@QAEJPAXK@Z ; DirectSound::CDirectSoundBufferSettings::SetBufferData

; 7204 : 
; 7205 :     //
; 7206 :     // Free notifications
; 7207 :     //
; 7208 : 
; 7209 :     SetNotificationPositions(0, NULL);

  0001c	6a 00		 push	 0
  0001e	6a 00		 push	 0
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?SetNotificationPositions@CDirectSoundBufferSettings@DirectSound@@QAEJKPBU_DSBPOSITIONNOTIFY@@@Z ; DirectSound::CDirectSoundBufferSettings::SetNotificationPositions

; 7210 : 
; 7211 :     DPF_LEAVE_VOID();
; 7212 : }

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??1CDirectSoundVoiceSettings@DirectSound@@UAE@XZ ; DirectSound::CDirectSoundVoiceSettings::~CDirectSoundVoiceSettings
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??1CDirectSoundBufferSettings@DirectSound@@UAE@XZ ENDP	; DirectSound::CDirectSoundBufferSettings::~CDirectSoundBufferSettings
DSOUND	ENDS
PUBLIC	?Initialize@CDirectSoundBufferSettings@DirectSound@@QAEJPBU_DSBUFFERDESC@@@Z ; DirectSound::CDirectSoundBufferSettings::Initialize
; Function compile flags: /Odt
;	COMDAT ?Initialize@CDirectSoundBufferSettings@DirectSound@@QAEJPBU_DSBUFFERDESC@@@Z
DSOUND	SEGMENT
tv72 = -12
_this$ = -8
_hr$ = -4
_pdsbd$ = 8
?Initialize@CDirectSoundBufferSettings@DirectSound@@QAEJPBU_DSBUFFERDESC@@@Z PROC NEAR ; DirectSound::CDirectSoundBufferSettings::Initialize, COMDAT
; _this$ = ecx

; 7238 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 7239 :     HRESULT                 hr;
; 7240 :     
; 7241 :     DPF_ENTER();
; 7242 : 
; 7243 :     //
; 7244 :     // Hand off to the base class
; 7245 :     //
; 7246 : 
; 7247 :     hr = CDirectSoundVoiceSettings::Initialize(pdsbd->dwFlags, (pdsbd->dwFlags & DSBCAPS_SUBMIXMASK) ? &m_wfxMixDest : pdsbd->lpwfxFormat, pdsbd->lpMixBins);

  00009	8b 45 08	 mov	 eax, DWORD PTR _pdsbd$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	81 e1 00 20 08
	00		 and	 ecx, 532480		; 00082000H
  00015	85 c9		 test	 ecx, ecx
  00017	74 09		 je	 SHORT $L41840
  00019	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], OFFSET FLAT:?m_wfxMixDest@CDirectSoundBufferSettings@DirectSound@@2UtWAVEFORMATEX@@B ; DirectSound::CDirectSoundBufferSettings::m_wfxMixDest
  00020	eb 09		 jmp	 SHORT $L41841
$L41840:
  00022	8b 55 08	 mov	 edx, DWORD PTR _pdsbd$[ebp]
  00025	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00028	89 45 f4	 mov	 DWORD PTR tv72[ebp], eax
$L41841:
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _pdsbd$[ebp]
  0002e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00031	52		 push	 edx
  00032	8b 45 f4	 mov	 eax, DWORD PTR tv72[ebp]
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _pdsbd$[ebp]
  00039	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003c	52		 push	 edx
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?Initialize@CDirectSoundVoiceSettings@DirectSound@@QAEJKPBUtWAVEFORMATEX@@PBU_DSMIXBINS@@@Z ; DirectSound::CDirectSoundVoiceSettings::Initialize
  00045	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 7248 : 
; 7249 :     //
; 7250 :     // Save the input mixbin
; 7251 :     //
; 7252 : 
; 7253 :     if(SUCCEEDED(hr))

  00048	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004c	7c 3d		 jl	 SHORT $L36993

; 7254 :     {
; 7255 :         if(pdsbd->dwFlags & DSBCAPS_FXIN)

  0004e	8b 45 08	 mov	 eax, DWORD PTR _pdsbd$[ebp]
  00051	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00054	81 e1 00 00 08
	00		 and	 ecx, 524288		; 00080000H
  0005a	85 c9		 test	 ecx, ecx
  0005c	74 11		 je	 SHORT $L36994

; 7256 :         {
; 7257 :             m_dwInputMixBin = pdsbd->dwInputMixBin;

  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 45 08	 mov	 eax, DWORD PTR _pdsbd$[ebp]
  00064	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00067	89 8a cc 00 00
	00		 mov	 DWORD PTR [edx+204], ecx

; 7258 :         }
; 7259 :         else if(pdsbd->dwFlags & DSBCAPS_MIXIN)

  0006d	eb 1c		 jmp	 SHORT $L36993
$L36994:
  0006f	8b 55 08	 mov	 edx, DWORD PTR _pdsbd$[ebp]
  00072	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00075	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  0007a	85 c0		 test	 eax, eax
  0007c	74 0d		 je	 SHORT $L36993

; 7260 :         {
; 7261 :             m_dwInputMixBin = DSMIXBIN_SUBMIX;

  0007e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	c7 81 cc 00 00
	00 1f 00 00 00	 mov	 DWORD PTR [ecx+204], 31	; 0000001fH
$L36993:

; 7262 :         }
; 7263 :     }
; 7264 :     
; 7265 :     //
; 7266 :     // Initialize buffer data
; 7267 :     //
; 7268 : 
; 7269 :     if(SUCCEEDED(hr))

  0008b	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0008f	7c 1d		 jl	 SHORT $L36998

; 7270 :     {
; 7271 :         if(pdsbd->dwBufferBytes)

  00091	8b 55 08	 mov	 edx, DWORD PTR _pdsbd$[ebp]
  00094	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00098	74 14		 je	 SHORT $L36998

; 7272 :         {
; 7273 :             hr = SetBufferData(NULL, pdsbd->dwBufferBytes);

  0009a	8b 45 08	 mov	 eax, DWORD PTR _pdsbd$[ebp]
  0009d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a0	51		 push	 ecx
  000a1	6a 00		 push	 0
  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ?SetBufferData@CDirectSoundBufferSettings@DirectSound@@QAEJPAXK@Z ; DirectSound::CDirectSoundBufferSettings::SetBufferData
  000ab	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L36998:

; 7274 :         }
; 7275 :     }
; 7276 : 
; 7277 :     DPF_LEAVE_HRESULT(hr);
; 7278 : 
; 7279 :     return hr;

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 7280 : }

  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 04 00	 ret	 4
?Initialize@CDirectSoundBufferSettings@DirectSound@@QAEJPBU_DSBUFFERDESC@@@Z ENDP ; DirectSound::CDirectSoundBufferSettings::Initialize
DSOUND	ENDS
PUBLIC	?SetPlayRegion@CDirectSoundBufferSettings@DirectSound@@QAEXKK@Z ; DirectSound::CDirectSoundBufferSettings::SetPlayRegion
; Function compile flags: /Odt
;	COMDAT ?SetBufferData@CDirectSoundBufferSettings@DirectSound@@QAEJPAXK@Z
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
_pvDataBuffer$ = 8
_dwBufferBytes$ = 12
?SetBufferData@CDirectSoundBufferSettings@DirectSound@@QAEJPAXK@Z PROC NEAR ; DirectSound::CDirectSoundBufferSettings::SetBufferData, COMDAT
; _this$ = ecx

; 7308 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 7309 :     HRESULT                 hr  = DS_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 7310 :     
; 7311 :     DPF_ENTER();
; 7312 :     
; 7313 :     //
; 7314 :     // Free the existing buffer
; 7315 :     //
; 7316 : 
; 7317 :     if(m_dwFlags & DSBCAPS_APPALLOCBUFFER)

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00016	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0f		 je	 SHORT $L37007

; 7318 :     {
; 7319 :         m_pvBufferData = NULL;

  00020	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00023	c7 82 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+180], 0

; 7320 :     }
; 7321 :     else

  0002d	eb 28		 jmp	 SHORT $L37008
$L37007:

; 7322 :     {
; 7323 :         MEMFREE(m_pvBufferData);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 b8 b4 00 00
	00 00		 cmp	 DWORD PTR [eax+180], 0
  00039	74 1c		 je	 SHORT $L37008
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 91 b4 00 00
	00		 mov	 edx, DWORD PTR [ecx+180]
  00044	52		 push	 edx
  00045	e8 00 00 00 00	 call	 ?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::MemFree
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	c7 80 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+180], 0
$L37008:

; 7324 :     }
; 7325 : 
; 7326 :     //
; 7327 :     // Allocate the new buffer (or just save the pointer)
; 7328 :     //
; 7329 : 
; 7330 :     if(m_dwBufferSize = dwBufferBytes)

  00057	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	8b 55 0c	 mov	 edx, DWORD PTR _dwBufferBytes$[ebp]
  0005d	89 91 b8 00 00
	00		 mov	 DWORD PTR [ecx+184], edx
  00063	83 7d 0c 00	 cmp	 DWORD PTR _dwBufferBytes$[ebp], 0
  00067	74 6e		 je	 SHORT $L37010

; 7331 :     {
; 7332 :         if(pvDataBuffer)

  00069	83 7d 08 00	 cmp	 DWORD PTR _pvDataBuffer$[ebp], 0
  0006d	74 20		 je	 SHORT $L37011

; 7333 :         {
; 7334 :             m_dwFlags |= DSBCAPS_APPALLOCBUFFER;

  0006f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00075	81 c9 00 00 00
	80		 or	 ecx, -2147483648	; 80000000H
  0007b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 7335 : 
; 7336 :             m_pvBufferData = pvDataBuffer;

  00081	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _pvDataBuffer$[ebp]
  00087	89 88 b4 00 00
	00		 mov	 DWORD PTR [eax+180], ecx

; 7337 :         }
; 7338 :         else

  0008d	eb 48		 jmp	 SHORT $L37010
$L37011:

; 7339 :         {
; 7340 :             m_dwFlags &= ~DSBCAPS_APPALLOCBUFFER;

  0008f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00092	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00095	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 7341 :         
; 7342 :             hr = HRFROMP(m_pvBufferData = MEMALLOC_NOINIT(BYTE, m_dwBufferSize));

  000a0	6a 00		 push	 0
  000a2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  000ab	50		 push	 eax
  000ac	68 44 53 64 61	 push	 1633964868		; 61645344H
  000b1	e8 00 00 00 00	 call	 ?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::MemAlloc
  000b6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	89 81 b4 00 00
	00		 mov	 DWORD PTR [ecx+180], eax
  000bf	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	33 c0		 xor	 eax, eax
  000c4	83 ba b4 00 00
	00 00		 cmp	 DWORD PTR [edx+180], 0
  000cb	0f 95 c0	 setne	 al
  000ce	48		 dec	 eax
  000cf	25 0e 00 07 80	 and	 eax, -2147024882	; 8007000eH
  000d4	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L37010:

; 7343 :         }
; 7344 :     }
; 7345 : 
; 7346 :     //
; 7347 :     // Reset the buffer offsets
; 7348 :     //
; 7349 : 
; 7350 :     SetPlayRegion(0, m_dwBufferSize);

  000d7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	8b 91 b8 00 00
	00		 mov	 edx, DWORD PTR [ecx+184]
  000e0	52		 push	 edx
  000e1	6a 00		 push	 0
  000e3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	e8 00 00 00 00	 call	 ?SetPlayRegion@CDirectSoundBufferSettings@DirectSound@@QAEXKK@Z ; DirectSound::CDirectSoundBufferSettings::SetPlayRegion

; 7351 : 
; 7352 :     DPF_LEAVE_HRESULT(hr);
; 7353 : 
; 7354 :     return hr;

  000eb	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 7355 : }

  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 08 00	 ret	 8
?SetBufferData@CDirectSoundBufferSettings@DirectSound@@QAEJPAXK@Z ENDP ; DirectSound::CDirectSoundBufferSettings::SetBufferData
DSOUND	ENDS
PUBLIC	?SetLoopRegion@CDirectSoundBufferSettings@DirectSound@@QAEXKK@Z ; DirectSound::CDirectSoundBufferSettings::SetLoopRegion
; Function compile flags: /Odt
;	COMDAT ?SetPlayRegion@CDirectSoundBufferSettings@DirectSound@@QAEXKK@Z
DSOUND	SEGMENT
_this$ = -4
_dwPlayStart$ = 8
_dwPlayLength$ = 12
?SetPlayRegion@CDirectSoundBufferSettings@DirectSound@@QAEXKK@Z PROC NEAR ; DirectSound::CDirectSoundBufferSettings::SetPlayRegion, COMDAT
; _this$ = ecx

; 7383 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 7384 :     DPF_ENTER();
; 7385 : 
; 7386 :     ASSERT(dwPlayStart + dwPlayLength <= m_dwBufferSize);
; 7387 :     
; 7388 :     m_dwPlayStart = dwPlayStart;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _dwPlayStart$[ebp]
  0000d	89 88 bc 00 00
	00		 mov	 DWORD PTR [eax+188], ecx

; 7389 :     m_dwPlayLength = dwPlayLength;

  00013	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00016	8b 45 0c	 mov	 eax, DWORD PTR _dwPlayLength$[ebp]
  00019	89 82 c0 00 00
	00		 mov	 DWORD PTR [edx+192], eax

; 7390 : 
; 7391 :     SetLoopRegion(0, dwPlayLength);

  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _dwPlayLength$[ebp]
  00022	51		 push	 ecx
  00023	6a 00		 push	 0
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?SetLoopRegion@CDirectSoundBufferSettings@DirectSound@@QAEXKK@Z ; DirectSound::CDirectSoundBufferSettings::SetLoopRegion

; 7392 : 
; 7393 :     DPF_LEAVE_VOID();
; 7394 : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?SetPlayRegion@CDirectSoundBufferSettings@DirectSound@@QAEXKK@Z ENDP ; DirectSound::CDirectSoundBufferSettings::SetPlayRegion
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetLoopRegion@CDirectSoundBufferSettings@DirectSound@@QAEXKK@Z
DSOUND	SEGMENT
_this$ = -4
_dwLoopStart$ = 8
_dwLoopLength$ = 12
?SetLoopRegion@CDirectSoundBufferSettings@DirectSound@@QAEXKK@Z PROC NEAR ; DirectSound::CDirectSoundBufferSettings::SetLoopRegion, COMDAT
; _this$ = ecx

; 7422 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 7423 :     DPF_ENTER();
; 7424 : 
; 7425 :     ASSERT(dwLoopStart + dwLoopLength <= m_dwBufferSize);
; 7426 :     ASSERT(dwLoopStart + dwLoopLength <= m_dwPlayLength);
; 7427 :     
; 7428 :     m_dwLoopStart = dwLoopStart;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _dwLoopStart$[ebp]
  0000d	89 88 c4 00 00
	00		 mov	 DWORD PTR [eax+196], ecx

; 7429 :     m_dwLoopLength = dwLoopLength;

  00013	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00016	8b 45 0c	 mov	 eax, DWORD PTR _dwLoopLength$[ebp]
  00019	89 82 c8 00 00
	00		 mov	 DWORD PTR [edx+200], eax

; 7430 : 
; 7431 :     DPF_LEAVE_VOID();
; 7432 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?SetLoopRegion@CDirectSoundBufferSettings@DirectSound@@QAEXKK@Z ENDP ; DirectSound::CDirectSoundBufferSettings::SetLoopRegion
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetNotificationPositions@CDirectSoundBufferSettings@DirectSound@@QAEJKPBU_DSBPOSITIONNOTIFY@@@Z
DSOUND	SEGMENT
_this$ = -20
_hr$ = -16
_NotifyT$ = -12
_i$ = -4
_dwNotifyCount$ = 8
_paNotifies$ = 12
?SetNotificationPositions@CDirectSoundBufferSettings@DirectSound@@QAEJKPBU_DSBPOSITIONNOTIFY@@@Z PROC NEAR ; DirectSound::CDirectSoundBufferSettings::SetNotificationPositions, COMDAT
; _this$ = ecx

; 7460 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 7461 :     HRESULT                 hr      = DS_OK;

  0000a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 7462 :     DWORD                   i       = 0;

  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 7463 :     DSBPOSITIONNOTIFY       NotifyT;
; 7464 : 
; 7465 :     DPF_ENTER();
; 7466 : 
; 7467 :     //
; 7468 :     // Free any existing notifications
; 7469 :     //
; 7470 : 
; 7471 :     MEMFREE(m_paNotifies);

  00018	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 b8 d0 00 00
	00 00		 cmp	 DWORD PTR [eax+208], 0
  00022	74 1c		 je	 SHORT $L37036
  00024	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::MemFree
  00033	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00036	c7 80 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+208], 0
$L37036:

; 7472 : 
; 7473 :     //
; 7474 :     // Save the new notification count
; 7475 :     //
; 7476 : 
; 7477 :     m_dwNotifyCount = dwNotifyCount;

  00040	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	8b 55 08	 mov	 edx, DWORD PTR _dwNotifyCount$[ebp]
  00046	89 91 d4 00 00
	00		 mov	 DWORD PTR [ecx+212], edx

; 7478 : 
; 7479 :     //
; 7480 :     // Make a copy of the notification array and put it into ascending order
; 7481 :     //
; 7482 : 
; 7483 :     if(dwNotifyCount)

  0004c	83 7d 08 00	 cmp	 DWORD PTR _dwNotifyCount$[ebp], 0
  00050	0f 84 08 01 00
	00		 je	 $L37037

; 7484 :     {
; 7485 :         hr = HRFROMP(m_paNotifies = MEMALLOC_NOINIT(DSBPOSITIONNOTIFY, dwNotifyCount));

  00056	6a 00		 push	 0
  00058	8b 45 08	 mov	 eax, DWORD PTR _dwNotifyCount$[ebp]
  0005b	c1 e0 03	 shl	 eax, 3
  0005e	50		 push	 eax
  0005f	68 44 53 64 61	 push	 1633964868		; 61645344H
  00064	e8 00 00 00 00	 call	 ?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::MemAlloc
  00069	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	89 81 d0 00 00
	00		 mov	 DWORD PTR [ecx+208], eax
  00072	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00075	33 c0		 xor	 eax, eax
  00077	83 ba d0 00 00
	00 00		 cmp	 DWORD PTR [edx+208], 0
  0007e	0f 95 c0	 setne	 al
  00081	48		 dec	 eax
  00082	25 0e 00 07 80	 and	 eax, -2147024882	; 8007000eH
  00087	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 7486 : 
; 7487 :         if(SUCCEEDED(hr))

  0008a	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0008e	7c 1d		 jl	 SHORT $L37043

; 7488 :         {
; 7489 :             CopyMemory(m_paNotifies, paNotifies, sizeof(*paNotifies) * dwNotifyCount);

  00090	8b 4d 08	 mov	 ecx, DWORD PTR _dwNotifyCount$[ebp]
  00093	c1 e1 03	 shl	 ecx, 3
  00096	51		 push	 ecx
  00097	8b 55 0c	 mov	 edx, DWORD PTR _paNotifies$[ebp]
  0009a	52		 push	 edx
  0009b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 88 d0 00 00
	00		 mov	 ecx, DWORD PTR [eax+208]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 _memcpy
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH
$L37043:

; 7490 :         }
; 7491 : 
; 7492 :         if(SUCCEEDED(hr))

  000ad	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b1	0f 8c a7 00 00
	00		 jl	 $L37037
$L37047:

; 7493 :         {
; 7494 :             while(i < m_dwNotifyCount - 1)

  000b7	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000ba	8b 82 d4 00 00
	00		 mov	 eax, DWORD PTR [edx+212]
  000c0	83 e8 01	 sub	 eax, 1
  000c3	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  000c6	0f 83 92 00 00
	00		 jae	 $L37037

; 7495 :             {
; 7496 :                 if(m_paNotifies[i].dwOffset > m_paNotifies[i + 1].dwOffset)

  000cc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  000d5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	8b 88 d0 00 00
	00		 mov	 ecx, DWORD PTR [eax+208]
  000de	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000e1	8b 75 fc	 mov	 esi, DWORD PTR _i$[ebp]
  000e4	8b 14 c2	 mov	 edx, DWORD PTR [edx+eax*8]
  000e7	3b 54 f1 08	 cmp	 edx, DWORD PTR [ecx+esi*8+8]
  000eb	76 63		 jbe	 SHORT $L37049

; 7497 :                 {
; 7498 :                     NotifyT = m_paNotifies[i];

  000ed	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 88 d0 00 00
	00		 mov	 ecx, DWORD PTR [eax+208]
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000f9	8b 04 d1	 mov	 eax, DWORD PTR [ecx+edx*8]
  000fc	8b 4c d1 04	 mov	 ecx, DWORD PTR [ecx+edx*8+4]
  00100	89 45 f4	 mov	 DWORD PTR _NotifyT$[ebp], eax
  00103	89 4d f8	 mov	 DWORD PTR _NotifyT$[ebp+4], ecx

; 7499 :                     m_paNotifies[i] = m_paNotifies[i + 1];

  00106	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00109	8b 82 d0 00 00
	00		 mov	 eax, DWORD PTR [edx+208]
  0010f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00112	8b 54 c8 08	 mov	 edx, DWORD PTR [eax+ecx*8+8]
  00116	8b 44 c8 0c	 mov	 eax, DWORD PTR [eax+ecx*8+12]
  0011a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	8b 89 d0 00 00
	00		 mov	 ecx, DWORD PTR [ecx+208]
  00123	8b 75 fc	 mov	 esi, DWORD PTR _i$[ebp]
  00126	89 14 f1	 mov	 DWORD PTR [ecx+esi*8], edx
  00129	89 44 f1 04	 mov	 DWORD PTR [ecx+esi*8+4], eax

; 7500 :                     m_paNotifies[i + 1] = NotifyT;

  0012d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00130	8b 82 d0 00 00
	00		 mov	 eax, DWORD PTR [edx+208]
  00136	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00139	8b 55 f4	 mov	 edx, DWORD PTR _NotifyT$[ebp]
  0013c	89 54 c8 08	 mov	 DWORD PTR [eax+ecx*8+8], edx
  00140	8b 55 f8	 mov	 edx, DWORD PTR _NotifyT$[ebp+4]
  00143	89 54 c8 0c	 mov	 DWORD PTR [eax+ecx*8+12], edx

; 7501 : 
; 7502 :                     i = 0;

  00147	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 7503 :                 }
; 7504 :                 else

  0014e	eb 09		 jmp	 SHORT $L37050
$L37049:

; 7505 :                 {
; 7506 :                     i++;

  00150	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00153	83 c0 01	 add	 eax, 1
  00156	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L37050:

; 7507 :                 }
; 7508 :             }

  00159	e9 59 ff ff ff	 jmp	 $L37047
$L37037:

; 7509 :         }
; 7510 :     }
; 7511 : 
; 7512 :     DPF_LEAVE_HRESULT(hr);
; 7513 : 
; 7514 :     return hr;

  0015e	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]

; 7515 : }

  00161	5e		 pop	 esi
  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c2 08 00	 ret	 8
?SetNotificationPositions@CDirectSoundBufferSettings@DirectSound@@QAEJKPBU_DSBPOSITIONNOTIFY@@@Z ENDP ; DirectSound::CDirectSoundBufferSettings::SetNotificationPositions
DSOUND	ENDS
PUBLIC	?AddRef@CDirectSoundBuffer@DirectSound@@UAGKXZ	; DirectSound::CDirectSoundBuffer::AddRef
PUBLIC	?Release@CDirectSoundBuffer@DirectSound@@UAGKXZ	; DirectSound::CDirectSoundBuffer::Release
PUBLIC	??_7CDirectSoundBuffer@DirectSound@@6B@		; DirectSound::CDirectSoundBuffer::`vftable'
PUBLIC	??_GCDirectSoundBuffer@DirectSound@@UAEPAXI@Z	; DirectSound::CDirectSoundBuffer::`scalar deleting destructor'
EXTRN	??_ECDirectSoundBuffer@DirectSound@@UAEPAXI@Z:NEAR ; DirectSound::CDirectSoundBuffer::`vector deleting destructor'
;	COMDAT ??_7CDirectSoundBuffer@DirectSound@@6B@
CONST	SEGMENT
??_7CDirectSoundBuffer@DirectSound@@6B@ DD FLAT:??_ECDirectSoundBuffer@DirectSound@@UAEPAXI@Z ; DirectSound::CDirectSoundBuffer::`vftable'
	DD	FLAT:?AddRef@CDirectSoundBuffer@DirectSound@@UAGKXZ
	DD	FLAT:?Release@CDirectSoundBuffer@DirectSound@@UAGKXZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CDirectSoundBuffer@DirectSound@@QAE@PAVCDirectSound@1@@Z
DSOUND	SEGMENT
_this$ = -4
_pDirectSound$ = 8
??0CDirectSoundBuffer@DirectSound@@QAE@PAVCDirectSound@1@@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::CDirectSoundBuffer, COMDAT
; _this$ = ecx

; 7541 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pDirectSound$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0CDirectSoundVoice@DirectSound@@QAE@PAVCDirectSound@1@@Z ; DirectSound::CDirectSoundVoice::CDirectSoundVoice
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CDirectSoundBuffer@DirectSound@@6B@

; 7542 :     DPF_ENTER();
; 7543 :     DPF_LEAVE_VOID();
; 7544 : }

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0CDirectSoundBuffer@DirectSound@@QAE@PAVCDirectSound@1@@Z ENDP ; DirectSound::CDirectSoundBuffer::CDirectSoundBuffer
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.h
DSOUND	ENDS
;	COMDAT ?AddRef@CDirectSoundBuffer@DirectSound@@UAGKXZ
DSOUND	SEGMENT
$T41861 = -12
$T41860 = -8
___AutoLock$ = -4
_this$ = 8
?AddRef@CDirectSoundBuffer@DirectSound@@UAGKXZ PROC NEAR ; DirectSound::CDirectSoundBuffer::AddRef, COMDAT

; 580  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 581  :         _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::AddRef");

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L32501
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41860[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41860[ebp]
  00029	eb 17		 jmp	 SHORT $L32499
$L32501:

; 582  :         return CRefCount::AddRef();

  0002b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?AddRef@CRefCount@DirectSound@@UAGKXZ ; DirectSound::CRefCount::AddRef
  00034	89 45 f4	 mov	 DWORD PTR $T41861[ebp], eax
  00037	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0003a	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0003f	8b 45 f4	 mov	 eax, DWORD PTR $T41861[ebp]
$L32499:

; 583  :     }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?AddRef@CDirectSoundBuffer@DirectSound@@UAGKXZ ENDP	; DirectSound::CDirectSoundBuffer::AddRef
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?Release@CDirectSoundBuffer@DirectSound@@UAGKXZ
DSOUND	SEGMENT
$T41866 = -12
$T41865 = -8
___AutoLock$ = -4
_this$ = 8
?Release@CDirectSoundBuffer@DirectSound@@UAGKXZ PROC NEAR ; DirectSound::CDirectSoundBuffer::Release, COMDAT

; 586  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 587  :         _ENTER_EXTERNAL_METHOD("CDirectSoundBuffer::Release");

  00006	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L32510
  00017	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR $T41865[ebp], -2147467259 ; 80004005H
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T41865[ebp]
  00029	eb 17		 jmp	 SHORT $L32508
$L32510:

; 588  :         return CRefCount::Release();

  0002b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?Release@CRefCount@DirectSound@@UAGKXZ ; DirectSound::CRefCount::Release
  00034	89 45 f4	 mov	 DWORD PTR $T41866[ebp], eax
  00037	8d 4d fc	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0003a	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0003f	8b 45 f4	 mov	 eax, DWORD PTR $T41866[ebp]
$L32508:

; 589  :     }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?Release@CDirectSoundBuffer@DirectSound@@UAGKXZ ENDP	; DirectSound::CDirectSoundBuffer::Release
DSOUND	ENDS
PUBLIC	??1CDirectSoundBuffer@DirectSound@@UAE@XZ	; DirectSound::CDirectSoundBuffer::~CDirectSoundBuffer
; Function compile flags: /Odt
;	COMDAT ??_GCDirectSoundBuffer@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCDirectSoundBuffer@DirectSound@@UAEPAXI@Z PROC NEAR	; DirectSound::CDirectSoundBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CDirectSoundBuffer@DirectSound@@UAE@XZ ; DirectSound::CDirectSoundBuffer::~CDirectSoundBuffer
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L37058
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L37058:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCDirectSoundBuffer@DirectSound@@UAEPAXI@Z ENDP	; DirectSound::CDirectSoundBuffer::`scalar deleting destructor'
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dsapi.cpp
DSOUND	ENDS
;	COMDAT ??1CDirectSoundBuffer@DirectSound@@UAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CDirectSoundBuffer@DirectSound@@UAE@XZ PROC NEAR	; DirectSound::CDirectSoundBuffer::~CDirectSoundBuffer, COMDAT
; _this$ = ecx

; 7569 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDirectSoundBuffer@DirectSound@@6B@

; 7570 :     DPF_ENTER();
; 7571 : 
; 7572 :     //
; 7573 :     // Free the buffer implementation
; 7574 :     //
; 7575 : 
; 7576 :     RELEASE(m_pBuffer);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00017	74 1c		 je	 SHORT $L37063
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	52		 push	 edx
  00028	ff 50 08	 call	 DWORD PTR [eax+8]
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
$L37063:

; 7577 : 
; 7578 :     //
; 7579 :     // Free settings
; 7580 :     //
; 7581 : 
; 7582 :     RELEASE(m_pSettings);

  00035	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00038	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  0003c	74 1c		 je	 SHORT $L37062
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00044	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00047	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	50		 push	 eax
  0004d	ff 51 08	 call	 DWORD PTR [ecx+8]
  00050	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0
$L37062:

; 7583 : 
; 7584 :     DPF_LEAVE_VOID();
; 7585 : }

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ??1CDirectSoundVoice@DirectSound@@UAE@XZ ; DirectSound::CDirectSoundVoice::~CDirectSoundVoice
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
??1CDirectSoundBuffer@DirectSound@@UAE@XZ ENDP		; DirectSound::CDirectSoundBuffer::~CDirectSoundBuffer
DSOUND	ENDS
PUBLIC	??0CMcpxBuffer@DirectSound@@QAE@PAVCMcpxAPU@1@PAVCDirectSoundBufferSettings@1@@Z ; DirectSound::CMcpxBuffer::CMcpxBuffer
PUBLIC	?Initialize@CMcpxBuffer@DirectSound@@QAEJXZ	; DirectSound::CMcpxBuffer::Initialize
; Function compile flags: /Odt
;	COMDAT ?Initialize@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSBUFFERDESC@@@Z
DSOUND	SEGMENT
tv95 = -32
tv74 = -28
$T41883 = -24
$T41880 = -20
$T41877 = -16
$T41876 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
_pdsbd$ = 12
?Initialize@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSBUFFERDESC@@@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::Initialize, COMDAT

; 7611 : {                                   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 7612 :     HRESULT                 hr;
; 7613 : 
; 7614 : #ifdef VALIDATE_PARAMETERS
; 7615 : 
; 7616 :     DWORD                   i;
; 7617 : 
; 7618 : #endif // VALIDATE_PARAMETERS
; 7619 : 
; 7620 :     DPF_ENTER();
; 7621 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 17		 je	 SHORT $L37071
  00017	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41876[ebp], -2147467259 ; 80004005H
  0001e	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f4	 mov	 eax, DWORD PTR $T41876[ebp]
  00029	e9 fc 00 00 00	 jmp	 $L37068
$L37071:

; 7622 :     
; 7623 : #ifdef VALIDATE_PARAMETERS
; 7624 : 
; 7625 :     if(!pdsbd)
; 7626 :     {
; 7627 :         DPF_ERROR("DSBUFFERDESC not supplied");
; 7628 :     }
; 7629 : 
; 7630 :     if(sizeof(*pdsbd) < pdsbd->dwSize)
; 7631 :     {
; 7632 :         DPF_ERROR("DSBUFFERDESC size not valid");
; 7633 :     }
; 7634 : 
; 7635 :     if(pdsbd->dwFlags & ~DSBCAPS_VALID)
; 7636 :     {
; 7637 :         DPF_ERROR("Specified invalid flags (%lx)", pdsbd->dwFlags & ~DSBCAPS_VALID);
; 7638 :     }
; 7639 : 
; 7640 :     if(pdsbd->dwFlags & DSBCAPS_SUBMIXMASK)
; 7641 :     {
; 7642 :         if(pdsbd->dwFlags & DSBCAPS_LOCDEFER)
; 7643 :         {
; 7644 :             DPF_ERROR("MIXIN/FXIN buffers can't be LOCDEFER");
; 7645 :         }
; 7646 : 
; 7647 :         if(pdsbd->dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY)
; 7648 :         {
; 7649 :             DPF_ERROR("MIXIN/FXIN buffers can't have CTRLPOSITIONNOTIFY");
; 7650 :         }
; 7651 : 
; 7652 :         if(pdsbd->lpwfxFormat)
; 7653 :         {
; 7654 :             DPF_ERROR("lpwfxFormat for MIXIN/FXIN buffers must be NULL");
; 7655 :         }
; 7656 : 
; 7657 :         if(pdsbd->dwBufferBytes)
; 7658 :         {
; 7659 :             DPF_ERROR("dwBufferBytes for MIXIN/FXIN buffers must be 0");
; 7660 :         }
; 7661 :     }
; 7662 :     else
; 7663 :     {
; 7664 :         if(!pdsbd->lpwfxFormat)
; 7665 :         {
; 7666 :             DPF_ERROR("Failed to specify a buffer format");
; 7667 :         }
; 7668 : 
; 7669 :         if(!IsValidFormat(pdsbd->lpwfxFormat))
; 7670 :         {
; 7671 :             DPF_ERROR("Invalid buffer format");
; 7672 :         }
; 7673 : 
; 7674 :         if(pdsbd->dwBufferBytes && ((pdsbd->dwBufferBytes < DSBSIZE_MIN) || (pdsbd->dwBufferBytes > DSBSIZE_MAX)))
; 7675 :         {
; 7676 :             DPF_ERROR("Buffer size out-of-bounds");
; 7677 :         }
; 7678 :     
; 7679 :         if(pdsbd->dwBufferBytes && (pdsbd->dwBufferBytes % pdsbd->lpwfxFormat->nBlockAlign))
; 7680 :         {
; 7681 :             DPF_ERROR("Buffer size not a multiple of the sample size");
; 7682 :         }
; 7683 : 
; 7684 :         if((pdsbd->dwFlags & DSBCAPS_CTRL3D) && (1 != pdsbd->lpwfxFormat->nChannels))
; 7685 :         {
; 7686 :             DPF_ERROR("3D voices must be mono");
; 7687 :         }
; 7688 :     }
; 7689 : 
; 7690 :     if((pdsbd->dwFlags & DSBCAPS_CTRL3D) && !CHrtfSource::IsValidAlgorithm())
; 7691 :     {
; 7692 :         DPF_ERROR("You must call one of the 3D algorithm initialization functions (DirectSoundUseLightHRTF, DirectSoundUseFullHRTF, DirectSoundUsePan3D) before creating a 3D buffer");
; 7693 :     }
; 7694 : 
; 7695 :     if(pdsbd->lpMixBins)
; 7696 :     {
; 7697 :         if(pdsbd->lpMixBins->dwMixBinCount > DSMIXBIN_ASSIGNMENT_MAX)
; 7698 :         {
; 7699 :             DPF_ERROR("No voice can be assigned to more than %lu mix bins", DSMIXBIN_ASSIGNMENT_MAX);
; 7700 :         }
; 7701 : 
; 7702 :         if(pdsbd->lpwfxFormat)
; 7703 :         {
; 7704 :             if(pdsbd->lpMixBins->dwMixBinCount % pdsbd->lpwfxFormat->nChannels)
; 7705 :             {
; 7706 :                 DPF_ERROR("The mixbin count must be a multiple of the channel count");
; 7707 :             }
; 7708 : 
; 7709 :             if(WAVE_FORMAT_EXTENSIBLE == pdsbd->lpwfxFormat->wFormatTag)
; 7710 :             {
; 7711 :                 if(((LPCWAVEFORMATEXTENSIBLE)pdsbd->lpwfxFormat)->dwChannelMask)
; 7712 :                 {
; 7713 :                     DPF_WARNING("Specifying mixbins will override the channel mask specified in the format");
; 7714 :                 }
; 7715 :             }
; 7716 :         }
; 7717 : 
; 7718 :         for(i = 0; i < pdsbd->lpMixBins->dwMixBinCount; i++)
; 7719 :         {
; 7720 :             if(pdsbd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin > DSMIXBIN_LAST)
; 7721 :             {
; 7722 :                 DPF_ERROR("Specified an invalid mixbin");
; 7723 :             }
; 7724 : 
; 7725 :             if(DSMIXBIN_SUBMIX == pdsbd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin)
; 7726 :             {
; 7727 :                 DPF_ERROR("Don't assign a voice to DSMIXBIN_SUBMIX.  Instead, call SetOutputBuffer");
; 7728 :             }
; 7729 :         }
; 7730 : 
; 7731 :         if(pdsbd->dwFlags & DSBCAPS_CTRL3D)
; 7732 :         {
; 7733 :             if(pdsbd->lpMixBins->dwMixBinCount < DirectSoundRequiredMixBins_3D.dwMixBinCount)
; 7734 :             {
; 7735 :                 DPF_ERROR("MixBin count doesn't include enough mixbins to hold all required for 3D");
; 7736 :             }
; 7737 :             
; 7738 :             for(i = 0; i < DirectSoundRequiredMixBins_3D.dwMixBinCount; i++)
; 7739 :             {
; 7740 :                 if(pdsbd->lpMixBins->lpMixBinVolumePairs[i].dwMixBin != DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[i].dwMixBin)
; 7741 :                 {
; 7742 :                     DPF_ERROR("MixBin array does not include the required 3D bins");
; 7743 :                 }
; 7744 :             }
; 7745 :         }
; 7746 :     }
; 7747 : 
; 7748 :     if(pdsbd->dwFlags & DSBCAPS_FXIN)
; 7749 :     {
; 7750 :         if((pdsbd->dwInputMixBin < DSMIXBIN_FXSEND_FIRST) || (pdsbd->dwInputMixBin > DSMIXBIN_FXSEND_LAST))
; 7751 :         {
; 7752 :             DPF_ERROR("The input mixbin for an FXIN buffer can only be one of the FX sends");
; 7753 :         }
; 7754 :     }
; 7755 : 
; 7756 : #endif // VALIDATE_PARAMETERS
; 7757 : 
; 7758 :     //
; 7759 :     // Create the settings object
; 7760 :     //
; 7761 : 
; 7762 :     hr = HRFROMP(m_pSettings = NEW(CDirectSoundBufferSettings));

  0002e	68 d8 00 00 00	 push	 216			; 000000d8H
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 f0	 mov	 DWORD PTR $T41877[ebp], eax
  0003e	83 7d f0 00	 cmp	 DWORD PTR $T41877[ebp], 0
  00042	74 0d		 je	 SHORT $L41878
  00044	8b 4d f0	 mov	 ecx, DWORD PTR $T41877[ebp]
  00047	e8 00 00 00 00	 call	 ??0CDirectSoundBufferSettings@DirectSound@@QAE@XZ ; DirectSound::CDirectSoundBufferSettings::CDirectSoundBufferSettings
  0004c	89 45 e4	 mov	 DWORD PTR tv74[ebp], eax
  0004f	eb 07		 jmp	 SHORT $L41879
$L41878:
  00051	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$L41879:
  00058	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 4d e4	 mov	 ecx, DWORD PTR tv74[ebp]
  0005e	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00061	33 d2		 xor	 edx, edx
  00063	83 7d e4 00	 cmp	 DWORD PTR tv74[ebp], 0
  00067	0f 95 c2	 setne	 dl
  0006a	4a		 dec	 edx
  0006b	81 e2 0e 00 07
	80		 and	 edx, -2147024882	; 8007000eH
  00071	89 55 fc	 mov	 DWORD PTR _hr$[ebp], edx

; 7763 : 
; 7764 :     if(SUCCEEDED(hr))

  00074	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00078	7c 12		 jl	 SHORT $L37079

; 7765 :     {
; 7766 :         hr = m_pSettings->Initialize(pdsbd);

  0007a	8b 45 0c	 mov	 eax, DWORD PTR _pdsbd$[ebp]
  0007d	50		 push	 eax
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00084	e8 00 00 00 00	 call	 ?Initialize@CDirectSoundBufferSettings@DirectSound@@QAEJPBU_DSBUFFERDESC@@@Z ; DirectSound::CDirectSoundBufferSettings::Initialize
  00089	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L37079:

; 7767 :     }
; 7768 : 
; 7769 :     //
; 7770 :     // Create the implementation object
; 7771 :     //
; 7772 :     
; 7773 :     if(SUCCEEDED(hr))

  0008c	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00090	7c 56		 jl	 SHORT $L37081

; 7774 :     {
; 7775 :         hr = HRFROMP(m_pBuffer = NEW(CMcpxBuffer(m_pDirectSound->m_pDevice, m_pSettings)));

  00092	68 48 01 00 00	 push	 328			; 00000148H
  00097	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009c	83 c4 04	 add	 esp, 4
  0009f	89 45 ec	 mov	 DWORD PTR $T41880[ebp], eax
  000a2	83 7d ec 00	 cmp	 DWORD PTR $T41880[ebp], 0
  000a6	74 1e		 je	 SHORT $L41881
  000a8	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000ab	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000ae	50		 push	 eax
  000af	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000b5	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000b8	50		 push	 eax
  000b9	8b 4d ec	 mov	 ecx, DWORD PTR $T41880[ebp]
  000bc	e8 00 00 00 00	 call	 ??0CMcpxBuffer@DirectSound@@QAE@PAVCMcpxAPU@1@PAVCDirectSoundBufferSettings@1@@Z ; DirectSound::CMcpxBuffer::CMcpxBuffer
  000c1	89 45 e0	 mov	 DWORD PTR tv95[ebp], eax
  000c4	eb 07		 jmp	 SHORT $L41882
$L41881:
  000c6	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
$L41882:
  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	8b 55 e0	 mov	 edx, DWORD PTR tv95[ebp]
  000d3	89 51 20	 mov	 DWORD PTR [ecx+32], edx
  000d6	33 c0		 xor	 eax, eax
  000d8	83 7d e0 00	 cmp	 DWORD PTR tv95[ebp], 0
  000dc	0f 95 c0	 setne	 al
  000df	48		 dec	 eax
  000e0	25 0e 00 07 80	 and	 eax, -2147024882	; 8007000eH
  000e5	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L37081:

; 7776 :     }
; 7777 : 
; 7778 :     if(SUCCEEDED(hr))

  000e8	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ec	7c 0e		 jl	 SHORT $L37087

; 7779 :     {
; 7780 :         hr = m_pBuffer->Initialize();

  000ee	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  000f4	e8 00 00 00 00	 call	 ?Initialize@CMcpxBuffer@DirectSound@@QAEJXZ ; DirectSound::CMcpxBuffer::Initialize
  000f9	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L37087:

; 7781 :     }
; 7782 : 
; 7783 :     //
; 7784 :     // Initialize the base class
; 7785 :     //
; 7786 : 
; 7787 :     if(SUCCEEDED(hr))

  000fc	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00100	7c 17		 jl	 SHORT $L37089

; 7788 :     {
; 7789 :         CDirectSoundVoice::Initialize(m_pBuffer, m_pSettings);

  00102	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00105	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00108	50		 push	 eax
  00109	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0010f	52		 push	 edx
  00110	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 ?Initialize@CDirectSoundVoice@DirectSound@@QAGXPAVCMcpxVoiceClient@2@PAVCDirectSoundVoiceSettings@2@@Z ; DirectSound::CDirectSoundVoice::Initialize
$L37089:

; 7790 :     }
; 7791 : 
; 7792 :     DPF_LEAVE_HRESULT(hr);
; 7793 : 
; 7794 :     return hr;

  00119	8b 4d fc	 mov	 ecx, DWORD PTR _hr$[ebp]
  0011c	89 4d e8	 mov	 DWORD PTR $T41883[ebp], ecx
  0011f	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00122	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00127	8b 45 e8	 mov	 eax, DWORD PTR $T41883[ebp]
$L37068:

; 7795 : }

  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c2 08 00	 ret	 8
?Initialize@CDirectSoundBuffer@DirectSound@@QAGJPBU_DSBUFFERDESC@@@Z ENDP ; DirectSound::CDirectSoundBuffer::Initialize
DSOUND	ENDS
PUBLIC	?SetBufferData@CMcpxBuffer@DirectSound@@QAEJXZ	; DirectSound::CMcpxBuffer::SetBufferData
PUBLIC	?ReleaseBufferData@CMcpxBuffer@DirectSound@@QAEJH@Z ; DirectSound::CMcpxBuffer::ReleaseBufferData
; Function compile flags: /Odt
;	COMDAT ?SetBufferData@CDirectSoundBuffer@DirectSound@@QAGJPAXK@Z
DSOUND	SEGMENT
tv66 = -24
$T41890 = -20
$T41889 = -16
___AutoLock$ = -12
_hr$ = -8
_fChanging$ = -4
_this$ = 8
_pvDataBuffer$ = 12
_dwBufferBytes$ = 16
?SetBufferData@CDirectSoundBuffer@DirectSound@@QAGJPAXK@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetBufferData, COMDAT

; 7823 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 7824 :     const BOOL              fChanging   = pvDataBuffer || dwBufferBytes;

  00006	83 7d 0c 00	 cmp	 DWORD PTR _pvDataBuffer$[ebp], 0
  0000a	75 0f		 jne	 SHORT $L41887
  0000c	83 7d 10 00	 cmp	 DWORD PTR _dwBufferBytes$[ebp], 0
  00010	75 09		 jne	 SHORT $L41887
  00012	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00019	eb 07		 jmp	 SHORT $L41888
$L41887:
  0001b	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$L41888:
  00022	8b 45 e8	 mov	 eax, DWORD PTR tv66[ebp]
  00025	89 45 fc	 mov	 DWORD PTR _fChanging$[ebp], eax

; 7825 :     HRESULT                 hr          = DS_OK;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 7826 :     
; 7827 :     DPF_ENTER();
; 7828 :     ENTER_EXTERNAL_METHOD();

  0002f	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00032	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  00037	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  0003e	74 14		 je	 SHORT $L37100
  00040	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR $T41889[ebp], -2147467259 ; 80004005H
  00047	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0004a	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0004f	8b 45 f0	 mov	 eax, DWORD PTR $T41889[ebp]
  00052	eb 7b		 jmp	 SHORT $L37095
$L37100:

; 7829 :     
; 7830 : #ifdef VALIDATE_PARAMETERS
; 7831 : 
; 7832 :     if(pvDataBuffer && dwBufferBytes)
; 7833 :     {
; 7834 :         if(dwBufferBytes && (dwBufferBytes % m_pSettings->m_fmt.nBlockAlign))
; 7835 :         {
; 7836 :             DPF_ERROR("Buffer size not block-aligned");
; 7837 :         }
; 7838 : 
; 7839 :         if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 7840 :         {
; 7841 :             DPF_ERROR("Can't call SetBufferData on MIXIN/FXIN buffers");
; 7842 :         }
; 7843 :     }
; 7844 :     else if(pvDataBuffer)
; 7845 :     {
; 7846 :         DPF_ERROR("0-sized buffer with non-NULL buffer pointer");
; 7847 :     }
; 7848 :     else if(dwBufferBytes)
; 7849 :     {
; 7850 :         DPF_ERROR("NULL buffer with non-zero buffer size");
; 7851 :     }
; 7852 : 
; 7853 : #endif // VALIDATE_PARAMETERS
; 7854 : 
; 7855 :     if((pvDataBuffer != m_pSettings->m_pvBufferData) || (dwBufferBytes != m_pSettings->m_dwBufferSize))

  00054	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0005a	8b 45 0c	 mov	 eax, DWORD PTR _pvDataBuffer$[ebp]
  0005d	3b 82 b4 00 00
	00		 cmp	 eax, DWORD PTR [edx+180]
  00063	75 11		 jne	 SHORT $L37104
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0006b	8b 45 10	 mov	 eax, DWORD PTR _dwBufferBytes$[ebp]
  0006e	3b 82 b8 00 00
	00		 cmp	 eax, DWORD PTR [edx+184]
  00074	74 48		 je	 SHORT $L37103
$L37104:

; 7856 :     {
; 7857 :         //
; 7858 :         // Give the implementation object a chance to clean up before we
; 7859 :         // stomp on the shared data members.
; 7860 :         //
; 7861 : 
; 7862 :         hr = m_pBuffer->ReleaseBufferData(fChanging);

  00076	8b 4d fc	 mov	 ecx, DWORD PTR _fChanging$[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0007d	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00080	e8 00 00 00 00	 call	 ?ReleaseBufferData@CMcpxBuffer@DirectSound@@QAEJH@Z ; DirectSound::CMcpxBuffer::ReleaseBufferData
  00085	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 7863 : 
; 7864 :         //
; 7865 :         // Hand off to the settings object
; 7866 :         //
; 7867 : 
; 7868 :         if(SUCCEEDED(hr))

  00088	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0008c	7c 16		 jl	 SHORT $L37106

; 7869 :         {
; 7870 :             hr = m_pSettings->SetBufferData(pvDataBuffer, dwBufferBytes);

  0008e	8b 45 10	 mov	 eax, DWORD PTR _dwBufferBytes$[ebp]
  00091	50		 push	 eax
  00092	8b 4d 0c	 mov	 ecx, DWORD PTR _pvDataBuffer$[ebp]
  00095	51		 push	 ecx
  00096	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00099	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  0009c	e8 00 00 00 00	 call	 ?SetBufferData@CDirectSoundBufferSettings@DirectSound@@QAEJPAXK@Z ; DirectSound::CDirectSoundBufferSettings::SetBufferData
  000a1	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L37106:

; 7871 :         }
; 7872 : 
; 7873 :         //
; 7874 :         // Notify the implementation object of the change
; 7875 :         //
; 7876 : 
; 7877 :         if(SUCCEEDED(hr) && fChanging)

  000a4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a8	7c 14		 jl	 SHORT $L37103
  000aa	83 7d fc 00	 cmp	 DWORD PTR _fChanging$[ebp], 0
  000ae	74 0e		 je	 SHORT $L37103

; 7878 :         {
; 7879 :             hr = m_pBuffer->SetBufferData();

  000b0	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000b6	e8 00 00 00 00	 call	 ?SetBufferData@CMcpxBuffer@DirectSound@@QAEJXZ ; DirectSound::CMcpxBuffer::SetBufferData
  000bb	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L37103:

; 7880 :         }
; 7881 :     }
; 7882 : 
; 7883 :     DPF_LEAVE_HRESULT(hr);
; 7884 : 
; 7885 :     return hr;

  000be	8b 4d f8	 mov	 ecx, DWORD PTR _hr$[ebp]
  000c1	89 4d ec	 mov	 DWORD PTR $T41890[ebp], ecx
  000c4	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  000c7	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  000cc	8b 45 ec	 mov	 eax, DWORD PTR $T41890[ebp]
$L37095:

; 7886 : }

  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c2 0c 00	 ret	 12			; 0000000cH
?SetBufferData@CDirectSoundBuffer@DirectSound@@QAGJPAXK@Z ENDP ; DirectSound::CDirectSoundBuffer::SetBufferData
DSOUND	ENDS
PUBLIC	?Play@CMcpxBuffer@DirectSound@@QAEJK@Z		; DirectSound::CMcpxBuffer::Play
; Function compile flags: /Odt
;	COMDAT ?Play@CDirectSoundBuffer@DirectSound@@QAGJKKK@Z
DSOUND	SEGMENT
$T41895 = -16
$T41894 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
_dwReserved1$ = 12
_dwReserved2$ = 16
_dwFlags$ = 20
?Play@CDirectSoundBuffer@DirectSound@@QAGJKKK@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::Play, COMDAT

; 7914 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 7915 :     HRESULT                 hr;
; 7916 :     
; 7917 :     DPF_ENTER();
; 7918 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L37118
  00017	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41894[ebp], -2147467259 ; 80004005H
  0001e	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f4	 mov	 eax, DWORD PTR $T41894[ebp]
  00029	eb 23		 jmp	 SHORT $L37115
$L37118:

; 7919 :     
; 7920 : #ifdef VALIDATE_PARAMETERS
; 7921 : 
; 7922 :     if(dwReserved1 || dwReserved2)
; 7923 :     {
; 7924 :         DPF_ERROR("Reserved parameters must be 0");
; 7925 :     }
; 7926 :     
; 7927 :     if(dwFlags & ~DSBPLAY_VALID)
; 7928 :     {
; 7929 :         DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DSBPLAY_VALID);
; 7930 :     }
; 7931 : 
; 7932 :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 7933 :     {
; 7934 :         DPF_ERROR("Can't call Play on a MIXIN/FXIN buffer");
; 7935 :     }
; 7936 :     
; 7937 :     if(!m_pSettings->m_pvBufferData || !m_pSettings->m_dwBufferSize)
; 7938 :     {
; 7939 :         DPF_ERROR("No data to play!");
; 7940 :     }
; 7941 : 
; 7942 : #endif // VALIDATE_PARAMETERS
; 7943 : 
; 7944 :     hr = m_pBuffer->Play(dwFlags);

  0002b	8b 45 14	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00035	e8 00 00 00 00	 call	 ?Play@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::Play
  0003a	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 7945 : 
; 7946 :     DPF_LEAVE_HRESULT(hr);
; 7947 : 
; 7948 :     return hr;

  0003d	8b 55 fc	 mov	 edx, DWORD PTR _hr$[ebp]
  00040	89 55 f0	 mov	 DWORD PTR $T41895[ebp], edx
  00043	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00046	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0004b	8b 45 f0	 mov	 eax, DWORD PTR $T41895[ebp]
$L37115:

; 7949 : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 10 00	 ret	 16			; 00000010H
?Play@CDirectSoundBuffer@DirectSound@@QAGJKKK@Z ENDP	; DirectSound::CDirectSoundBuffer::Play
DSOUND	ENDS
PUBLIC	?Play@CMcpxBuffer@DirectSound@@QAEJ_JK@Z	; DirectSound::CMcpxBuffer::Play
; Function compile flags: /Odt
;	COMDAT ?PlayEx@CDirectSoundBuffer@DirectSound@@QAGJ_JK@Z
DSOUND	SEGMENT
$T41900 = -16
$T41899 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
_rtTimeStamp$ = 12
_dwFlags$ = 20
?PlayEx@CDirectSoundBuffer@DirectSound@@QAGJ_JK@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::PlayEx, COMDAT

; 7977 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 7978 :     HRESULT                 hr;
; 7979 : 
; 7980 :     DPF_ENTER();
; 7981 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L37129
  00017	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41899[ebp], -2147467259 ; 80004005H
  0001e	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f4	 mov	 eax, DWORD PTR $T41899[ebp]
  00029	eb 2b		 jmp	 SHORT $L37126
$L37129:

; 7982 :     
; 7983 : #ifdef VALIDATE_PARAMETERS
; 7984 : 
; 7985 :     if(dwFlags & ~DSBPLAY_VALID)
; 7986 :     {
; 7987 :         DPF_ERROR("Specified invalid or unsupported flags (%lx)", dwFlags & ~DSBPLAY_VALID);
; 7988 :     }
; 7989 : 
; 7990 :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 7991 :     {
; 7992 :         DPF_ERROR("Can't call Play on a MIXIN/FXIN buffer");
; 7993 :     }
; 7994 :     
; 7995 :     if(!m_pSettings->m_pvBufferData || !m_pSettings->m_dwBufferSize)
; 7996 :     {
; 7997 :         DPF_ERROR("No data to play!");
; 7998 :     }
; 7999 : 
; 8000 : #endif // VALIDATE_PARAMETERS
; 8001 : 
; 8002 :     hr = m_pBuffer->Play(rtTimeStamp, dwFlags);

  0002b	8b 45 14	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR _rtTimeStamp$[ebp+4]
  00032	51		 push	 ecx
  00033	8b 55 0c	 mov	 edx, DWORD PTR _rtTimeStamp$[ebp]
  00036	52		 push	 edx
  00037	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0003d	e8 00 00 00 00	 call	 ?Play@CMcpxBuffer@DirectSound@@QAEJ_JK@Z ; DirectSound::CMcpxBuffer::Play
  00042	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 8003 : 
; 8004 :     DPF_LEAVE_HRESULT(hr);
; 8005 : 
; 8006 :     return hr;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _hr$[ebp]
  00048	89 4d f0	 mov	 DWORD PTR $T41900[ebp], ecx
  0004b	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0004e	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00053	8b 45 f0	 mov	 eax, DWORD PTR $T41900[ebp]
$L37126:

; 8007 : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 10 00	 ret	 16			; 00000010H
?PlayEx@CDirectSoundBuffer@DirectSound@@QAGJ_JK@Z ENDP	; DirectSound::CDirectSoundBuffer::PlayEx
DSOUND	ENDS
PUBLIC	?Stop@CMcpxBuffer@DirectSound@@QAEJK@Z		; DirectSound::CMcpxBuffer::Stop
; Function compile flags: /Odt
;	COMDAT ?Stop@CDirectSoundBuffer@DirectSound@@QAGJXZ
DSOUND	SEGMENT
$T41905 = -16
$T41904 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
?Stop@CDirectSoundBuffer@DirectSound@@QAGJXZ PROC NEAR	; DirectSound::CDirectSoundBuffer::Stop, COMDAT

; 8033 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 8034 :     HRESULT                 hr;
; 8035 :     
; 8036 :     DPF_ENTER();
; 8037 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L37139
  00017	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41904[ebp], -2147467259 ; 80004005H
  0001e	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f4	 mov	 eax, DWORD PTR $T41904[ebp]
  00029	eb 21		 jmp	 SHORT $L37136
$L37139:

; 8038 :     
; 8039 : #ifdef VALIDATE_PARAMETERS
; 8040 : 
; 8041 :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 8042 :     {
; 8043 :         DPF_ERROR("Can't call Stop on a MIXIN/FXIN buffer");
; 8044 :     }
; 8045 :     
; 8046 : #endif // VALIDATE_PARAMETERS
; 8047 : 
; 8048 :     hr = m_pBuffer->Stop();

  0002b	6a 00		 push	 0
  0002d	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00033	e8 00 00 00 00	 call	 ?Stop@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::Stop
  00038	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 8049 : 
; 8050 :     DPF_LEAVE_HRESULT(hr);
; 8051 : 
; 8052 :     return hr;

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _hr$[ebp]
  0003e	89 4d f0	 mov	 DWORD PTR $T41905[ebp], ecx
  00041	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00044	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00049	8b 45 f0	 mov	 eax, DWORD PTR $T41905[ebp]
$L37136:

; 8053 : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
?Stop@CDirectSoundBuffer@DirectSound@@QAGJXZ ENDP	; DirectSound::CDirectSoundBuffer::Stop
DSOUND	ENDS
PUBLIC	?Stop@CMcpxBuffer@DirectSound@@QAEJ_JK@Z	; DirectSound::CMcpxBuffer::Stop
; Function compile flags: /Odt
;	COMDAT ?StopEx@CDirectSoundBuffer@DirectSound@@QAGJ_JK@Z
DSOUND	SEGMENT
$T41910 = -16
$T41909 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
_rtTimeStamp$ = 12
_dwFlags$ = 20
?StopEx@CDirectSoundBuffer@DirectSound@@QAGJ_JK@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::StopEx, COMDAT

; 8081 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 8082 :     HRESULT                 hr;
; 8083 :     
; 8084 :     DPF_ENTER();
; 8085 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L37150
  00017	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41909[ebp], -2147467259 ; 80004005H
  0001e	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f4	 mov	 eax, DWORD PTR $T41909[ebp]
  00029	eb 2b		 jmp	 SHORT $L37147
$L37150:

; 8086 :     
; 8087 : #ifdef VALIDATE_PARAMETERS
; 8088 : 
; 8089 :     if(dwFlags & ~DSBSTOPEX_VALID)
; 8090 :     {
; 8091 :         DPF_ERROR("Invalid flags");
; 8092 :     }
; 8093 : 
; 8094 :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 8095 :     {
; 8096 :         DPF_ERROR("Can't call Stop on a MIXIN/FXIN buffer");
; 8097 :     }
; 8098 :     
; 8099 : #endif // VALIDATE_PARAMETERS
; 8100 : 
; 8101 :     hr = m_pBuffer->Stop(rtTimeStamp, dwFlags);

  0002b	8b 45 14	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR _rtTimeStamp$[ebp+4]
  00032	51		 push	 ecx
  00033	8b 55 0c	 mov	 edx, DWORD PTR _rtTimeStamp$[ebp]
  00036	52		 push	 edx
  00037	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0003d	e8 00 00 00 00	 call	 ?Stop@CMcpxBuffer@DirectSound@@QAEJ_JK@Z ; DirectSound::CMcpxBuffer::Stop
  00042	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 8102 : 
; 8103 :     DPF_LEAVE_HRESULT(hr);
; 8104 : 
; 8105 :     return hr;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _hr$[ebp]
  00048	89 4d f0	 mov	 DWORD PTR $T41910[ebp], ecx
  0004b	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0004e	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00053	8b 45 f0	 mov	 eax, DWORD PTR $T41910[ebp]
$L37147:

; 8106 : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 10 00	 ret	 16			; 00000010H
?StopEx@CDirectSoundBuffer@DirectSound@@QAGJ_JK@Z ENDP	; DirectSound::CDirectSoundBuffer::StopEx
DSOUND	ENDS
PUBLIC	?GetStatus@CMcpxBuffer@DirectSound@@QAEJPAK@Z	; DirectSound::CMcpxBuffer::GetStatus
; Function compile flags: /Odt
;	COMDAT ?GetStatus@CDirectSoundBuffer@DirectSound@@QAGJPAK@Z
DSOUND	SEGMENT
$T41915 = -16
$T41914 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
_pdwStatus$ = 12
?GetStatus@CDirectSoundBuffer@DirectSound@@QAGJPAK@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::GetStatus, COMDAT

; 8132 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 8133 :     HRESULT                 hr;
; 8134 :     
; 8135 :     DPF_ENTER();
; 8136 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L37160
  00017	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41914[ebp], -2147467259 ; 80004005H
  0001e	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f4	 mov	 eax, DWORD PTR $T41914[ebp]
  00029	eb 23		 jmp	 SHORT $L37157
$L37160:

; 8137 : 
; 8138 : #ifdef VALIDATE_PARAMETERS
; 8139 : 
; 8140 :     if(!pdwStatus)
; 8141 :     {
; 8142 :         DPF_ERROR("Failed to specify a status buffer");
; 8143 :     }
; 8144 : 
; 8145 :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 8146 :     {
; 8147 :         DPF_ERROR("Can't call GetStatus on a MIXIN/FXIN buffer");
; 8148 :     }
; 8149 :     
; 8150 : #endif // VALIDATE_PARAMETERS
; 8151 :     
; 8152 :     hr = m_pBuffer->GetStatus(pdwStatus);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _pdwStatus$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00035	e8 00 00 00 00	 call	 ?GetStatus@CMcpxBuffer@DirectSound@@QAEJPAK@Z ; DirectSound::CMcpxBuffer::GetStatus
  0003a	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 8153 : 
; 8154 :     DPF_LEAVE_HRESULT(hr);
; 8155 : 
; 8156 :     return hr;

  0003d	8b 55 fc	 mov	 edx, DWORD PTR _hr$[ebp]
  00040	89 55 f0	 mov	 DWORD PTR $T41915[ebp], edx
  00043	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00046	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0004b	8b 45 f0	 mov	 eax, DWORD PTR $T41915[ebp]
$L37157:

; 8157 : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
?GetStatus@CDirectSoundBuffer@DirectSound@@QAGJPAK@Z ENDP ; DirectSound::CDirectSoundBuffer::GetStatus
DSOUND	ENDS
PUBLIC	?SetPlayRegion@CMcpxBuffer@DirectSound@@QAEJXZ	; DirectSound::CMcpxBuffer::SetPlayRegion
; Function compile flags: /Odt
;	COMDAT ?SetPlayRegion@CDirectSoundBuffer@DirectSound@@QAGJKK@Z
DSOUND	SEGMENT
$T41920 = -16
$T41919 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
_dwPlayStart$ = 12
_dwPlayLength$ = 16
?SetPlayRegion@CDirectSoundBuffer@DirectSound@@QAGJKK@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetPlayRegion, COMDAT

; 8185 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 8186 :     HRESULT                 hr  = DS_OK;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 8187 :     
; 8188 :     DPF_ENTER();
; 8189 :     ENTER_EXTERNAL_METHOD();

  0000d	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00010	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  00015	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  0001c	74 14		 je	 SHORT $L37172
  0001e	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41919[ebp], -2147467259 ; 80004005H
  00025	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00028	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0002d	8b 45 f4	 mov	 eax, DWORD PTR $T41919[ebp]
  00030	eb 73		 jmp	 SHORT $L37168
$L37172:

; 8190 : 
; 8191 : #ifdef VALIDATE_PARAMETERS
; 8192 : 
; 8193 :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 8194 :     {
; 8195 :         DPF_ERROR("Can't call SetPlayRegion on MIXIN/FXIN buffers");
; 8196 :     }
; 8197 : 
; 8198 :     if(dwPlayStart % 4)
; 8199 :     {
; 8200 :         DPF_ERROR("Play offset not block-aligned");
; 8201 :     }
; 8202 : 
; 8203 : #endif // VALIDATE_PARAMETERS
; 8204 : 
; 8205 :     //
; 8206 :     // Munge the length so it's valid
; 8207 :     //
; 8208 : 
; 8209 :     if(dwPlayLength)

  00032	83 7d 10 00	 cmp	 DWORD PTR _dwPlayLength$[ebp], 0
  00036	74 1d		 je	 SHORT $L37175

; 8210 :     {
; 8211 : 
; 8212 : #ifdef VALIDATE_PARAMETERS
; 8213 : 
; 8214 :         if(dwPlayLength % m_pSettings->m_fmt.nBlockAlign)
; 8215 :         {
; 8216 :             DPF_ERROR("Play length not block-aligned");
; 8217 :         }
; 8218 : 
; 8219 : #endif // VALIDATE_PARAMETERS
; 8220 : 
; 8221 :         if(dwPlayStart + dwPlayLength > m_pSettings->m_dwBufferSize)

  00038	8b 45 0c	 mov	 eax, DWORD PTR _dwPlayStart$[ebp]
  0003b	03 45 10	 add	 eax, DWORD PTR _dwPlayLength$[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00044	3b 82 b8 00 00
	00		 cmp	 eax, DWORD PTR [edx+184]
  0004a	76 07		 jbe	 SHORT $L37176

; 8222 :         {
; 8223 :             DPF_ERROR("Play region extends past the end of the buffer");
; 8224 :             hr = DSERR_INVALIDCALL;

  0004c	c7 45 fc 32 00
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005401550 ; 88780032H
$L37176:

; 8225 :         }
; 8226 :     }
; 8227 :     else

  00053	eb 12		 jmp	 SHORT $L37181
$L37175:

; 8228 :     {
; 8229 :         dwPlayLength = m_pSettings->m_dwBufferSize - dwPlayStart;

  00055	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0005b	8b 91 b8 00 00
	00		 mov	 edx, DWORD PTR [ecx+184]
  00061	2b 55 0c	 sub	 edx, DWORD PTR _dwPlayStart$[ebp]
  00064	89 55 10	 mov	 DWORD PTR _dwPlayLength$[ebp], edx
$L37181:

; 8230 :     }
; 8231 : 
; 8232 :     //
; 8233 :     // Update the settings object
; 8234 :     //
; 8235 : 
; 8236 :     if(SUCCEEDED(hr))

  00067	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006b	7c 13		 jl	 SHORT $L37183

; 8237 :     {
; 8238 :         m_pSettings->SetPlayRegion(dwPlayStart, dwPlayLength);

  0006d	8b 45 10	 mov	 eax, DWORD PTR _dwPlayLength$[ebp]
  00070	50		 push	 eax
  00071	8b 4d 0c	 mov	 ecx, DWORD PTR _dwPlayStart$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00078	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  0007b	e8 00 00 00 00	 call	 ?SetPlayRegion@CDirectSoundBufferSettings@DirectSound@@QAEXKK@Z ; DirectSound::CDirectSoundBufferSettings::SetPlayRegion
$L37183:

; 8239 :     }
; 8240 : 
; 8241 :     //
; 8242 :     // Update the buffer implementation
; 8243 :     //
; 8244 : 
; 8245 :     if(SUCCEEDED(hr))

  00080	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00084	7c 0e		 jl	 SHORT $L37185

; 8246 :     {
; 8247 :         hr = m_pBuffer->SetPlayRegion();

  00086	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0008c	e8 00 00 00 00	 call	 ?SetPlayRegion@CMcpxBuffer@DirectSound@@QAEJXZ ; DirectSound::CMcpxBuffer::SetPlayRegion
  00091	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L37185:

; 8248 :     }
; 8249 : 
; 8250 :     DPF_LEAVE_HRESULT(hr);
; 8251 : 
; 8252 :     return hr;

  00094	8b 4d fc	 mov	 ecx, DWORD PTR _hr$[ebp]
  00097	89 4d f0	 mov	 DWORD PTR $T41920[ebp], ecx
  0009a	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0009d	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  000a2	8b 45 f0	 mov	 eax, DWORD PTR $T41920[ebp]
$L37168:

; 8253 : }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 0c 00	 ret	 12			; 0000000cH
?SetPlayRegion@CDirectSoundBuffer@DirectSound@@QAGJKK@Z ENDP ; DirectSound::CDirectSoundBuffer::SetPlayRegion
DSOUND	ENDS
PUBLIC	?SetLoopRegion@CMcpxBuffer@DirectSound@@QAEJXZ	; DirectSound::CMcpxBuffer::SetLoopRegion
; Function compile flags: /Odt
;	COMDAT ?SetLoopRegion@CDirectSoundBuffer@DirectSound@@QAGJKK@Z
DSOUND	SEGMENT
$T41925 = -16
$T41924 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
_dwLoopStart$ = 12
_dwLoopLength$ = 16
?SetLoopRegion@CDirectSoundBuffer@DirectSound@@QAGJKK@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetLoopRegion, COMDAT

; 8281 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 8282 :     HRESULT                 hr  = DS_OK;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 8283 :     
; 8284 :     DPF_ENTER();
; 8285 :     ENTER_EXTERNAL_METHOD();

  0000d	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00010	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  00015	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  0001c	74 14		 je	 SHORT $L37195
  0001e	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41924[ebp], -2147467259 ; 80004005H
  00025	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00028	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0002d	8b 45 f4	 mov	 eax, DWORD PTR $T41924[ebp]
  00030	eb 73		 jmp	 SHORT $L37191
$L37195:

; 8286 : 
; 8287 : #ifdef VALIDATE_PARAMETERS
; 8288 : 
; 8289 :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 8290 :     {
; 8291 :         DPF_ERROR("Can't call SetLoopRegion on MIXIN/FXIN buffers");
; 8292 :     }
; 8293 : 
; 8294 :     if(dwLoopStart % m_pSettings->m_fmt.nBlockAlign)
; 8295 :     {
; 8296 :         DPF_ERROR("Loop offset not block-aligned");
; 8297 :     }
; 8298 : 
; 8299 : #endif // VALIDATE_PARAMETERS
; 8300 : 
; 8301 :     //
; 8302 :     // Munge the length so it's valid
; 8303 :     //
; 8304 : 
; 8305 :     if(dwLoopLength)

  00032	83 7d 10 00	 cmp	 DWORD PTR _dwLoopLength$[ebp], 0
  00036	74 1d		 je	 SHORT $L37198

; 8306 :     {
; 8307 : 
; 8308 : #ifdef VALIDATE_PARAMETERS
; 8309 : 
; 8310 :         if(dwLoopLength % m_pSettings->m_fmt.nBlockAlign)
; 8311 :         {
; 8312 :             DPF_ERROR("Loop length not block-aligned");
; 8313 :         }
; 8314 : 
; 8315 : #endif // VALIDATE_PARAMETERS
; 8316 : 
; 8317 :         if(dwLoopStart + dwLoopLength > m_pSettings->m_dwPlayLength)

  00038	8b 45 0c	 mov	 eax, DWORD PTR _dwLoopStart$[ebp]
  0003b	03 45 10	 add	 eax, DWORD PTR _dwLoopLength$[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00044	3b 82 c0 00 00
	00		 cmp	 eax, DWORD PTR [edx+192]
  0004a	76 07		 jbe	 SHORT $L37199

; 8318 :         {
; 8319 :             DPF_ERROR("Loop region extends past the end of the play region");
; 8320 :             hr = DSERR_INVALIDCALL;

  0004c	c7 45 fc 32 00
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005401550 ; 88780032H
$L37199:

; 8321 :         }
; 8322 :     }
; 8323 :     else

  00053	eb 12		 jmp	 SHORT $L37204
$L37198:

; 8324 :     {
; 8325 :         dwLoopLength = m_pSettings->m_dwPlayLength - dwLoopStart;

  00055	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0005b	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  00061	2b 55 0c	 sub	 edx, DWORD PTR _dwLoopStart$[ebp]
  00064	89 55 10	 mov	 DWORD PTR _dwLoopLength$[ebp], edx
$L37204:

; 8326 :     }
; 8327 : 
; 8328 :     //
; 8329 :     // Update the settings object
; 8330 :     //
; 8331 : 
; 8332 :     if(SUCCEEDED(hr))

  00067	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006b	7c 13		 jl	 SHORT $L37206

; 8333 :     {
; 8334 :         m_pSettings->SetLoopRegion(dwLoopStart, dwLoopLength);

  0006d	8b 45 10	 mov	 eax, DWORD PTR _dwLoopLength$[ebp]
  00070	50		 push	 eax
  00071	8b 4d 0c	 mov	 ecx, DWORD PTR _dwLoopStart$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00078	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  0007b	e8 00 00 00 00	 call	 ?SetLoopRegion@CDirectSoundBufferSettings@DirectSound@@QAEXKK@Z ; DirectSound::CDirectSoundBufferSettings::SetLoopRegion
$L37206:

; 8335 :     }
; 8336 : 
; 8337 :     //
; 8338 :     // Update the buffer implementation
; 8339 :     //
; 8340 : 
; 8341 :     if(SUCCEEDED(hr))

  00080	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00084	7c 0e		 jl	 SHORT $L37208

; 8342 :     {
; 8343 :         hr = m_pBuffer->SetLoopRegion();

  00086	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0008c	e8 00 00 00 00	 call	 ?SetLoopRegion@CMcpxBuffer@DirectSound@@QAEJXZ ; DirectSound::CMcpxBuffer::SetLoopRegion
  00091	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L37208:

; 8344 :     }
; 8345 : 
; 8346 :     DPF_LEAVE_HRESULT(hr);
; 8347 : 
; 8348 :     return hr;

  00094	8b 4d fc	 mov	 ecx, DWORD PTR _hr$[ebp]
  00097	89 4d f0	 mov	 DWORD PTR $T41925[ebp], ecx
  0009a	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0009d	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  000a2	8b 45 f0	 mov	 eax, DWORD PTR $T41925[ebp]
$L37191:

; 8349 : }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 0c 00	 ret	 12			; 0000000cH
?SetLoopRegion@CDirectSoundBuffer@DirectSound@@QAGJKK@Z ENDP ; DirectSound::CDirectSoundBuffer::SetLoopRegion
DSOUND	ENDS
PUBLIC	?GetCurrentPosition@CMcpxBuffer@DirectSound@@QAEJPAK0@Z ; DirectSound::CMcpxBuffer::GetCurrentPosition
; Function compile flags: /Odt
;	COMDAT ?GetCurrentPosition@CDirectSoundBuffer@DirectSound@@QAGJPAK0@Z
DSOUND	SEGMENT
$T41930 = -16
$T41929 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
_pdwPlayPosition$ = 12
_pdwWritePosition$ = 16
?GetCurrentPosition@CDirectSoundBuffer@DirectSound@@QAGJPAK0@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::GetCurrentPosition, COMDAT

; 8377 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 8378 :     HRESULT                 hr;
; 8379 : 
; 8380 :     DPF_ENTER();
; 8381 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L37217
  00017	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41929[ebp], -2147467259 ; 80004005H
  0001e	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f4	 mov	 eax, DWORD PTR $T41929[ebp]
  00029	eb 27		 jmp	 SHORT $L37214
$L37217:

; 8382 :     
; 8383 : #ifdef VALIDATE_PARAMETERS
; 8384 : 
; 8385 :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 8386 :     {
; 8387 :         DPF_ERROR("Can't call GetCurrentPosition on MIXIN/FXIN buffers");
; 8388 :     }
; 8389 : 
; 8390 : #endif // VALIDATE_PARAMETERS
; 8391 : 
; 8392 :     hr = m_pBuffer->GetCurrentPosition(pdwPlayPosition, pdwWritePosition);

  0002b	8b 45 10	 mov	 eax, DWORD PTR _pdwWritePosition$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwPlayPosition$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00039	e8 00 00 00 00	 call	 ?GetCurrentPosition@CMcpxBuffer@DirectSound@@QAEJPAK0@Z ; DirectSound::CMcpxBuffer::GetCurrentPosition
  0003e	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 8393 : 
; 8394 :     DPF_LEAVE_HRESULT(hr);
; 8395 : 
; 8396 :     return hr;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR $T41930[ebp], eax
  00047	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  0004a	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0004f	8b 45 f0	 mov	 eax, DWORD PTR $T41930[ebp]
$L37214:

; 8397 : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 0c 00	 ret	 12			; 0000000cH
?GetCurrentPosition@CDirectSoundBuffer@DirectSound@@QAGJPAK0@Z ENDP ; DirectSound::CDirectSoundBuffer::GetCurrentPosition
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?Lock@CDirectSoundBuffer@DirectSound@@QAGJKKPAPAXPAK01K@Z
DSOUND	SEGMENT
tv90 = -20
$T41937 = -16
$T41934 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
_dwLockPosition$ = 12
_dwLockSize$ = 16
_ppvLock1$ = 20
_pdwLockSize1$ = 24
_ppvLock2$ = 28
_pdwLockSize2$ = 32
_dwFlags$ = 36
?Lock@CDirectSoundBuffer@DirectSound@@QAGJKKPAPAXPAK01K@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::Lock, COMDAT

; 8435 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 8436 :     HRESULT                 hr  = DS_OK;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 8437 :     
; 8438 :     DPF_ENTER();
; 8439 :     ENTER_EXTERNAL_METHOD();

  0000d	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00010	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  00015	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  0001c	74 17		 je	 SHORT $L37234
  0001e	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41934[ebp], -2147467259 ; 80004005H
  00025	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00028	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0002d	8b 45 f4	 mov	 eax, DWORD PTR $T41934[ebp]
  00030	e9 e8 00 00 00	 jmp	 $L37230
$L37234:

; 8440 : 
; 8441 : #ifdef VALIDATE_PARAMETERS
; 8442 : 
; 8443 :     if(!ppvLock1 || !pdwLockSize1)
; 8444 :     {
; 8445 :         DPF_ERROR("Missing first set of lock parameters");
; 8446 :     }
; 8447 : 
; 8448 :     if((ppvLock2 && !pdwLockSize2) || (!ppvLock2 && pdwLockSize2))
; 8449 :     {
; 8450 :         DPF_ERROR("Missing one of the second set of lock parameters");
; 8451 :     }
; 8452 : 
; 8453 :     if(dwFlags & ~DSBLOCK_VALID)
; 8454 :     {
; 8455 :         DPF_ERROR("Specified unsupported or invalid flags (%lx)", dwFlags & ~DSBLOCK_VALID);
; 8456 :     }
; 8457 : 
; 8458 :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 8459 :     {
; 8460 :         DPF_ERROR("Can't lock MIXIN/FXIN buffers");
; 8461 :     }
; 8462 : 
; 8463 : #endif // VALIDATE_PARAMETERS
; 8464 : 
; 8465 :     //
; 8466 :     // Validate the lock position
; 8467 :     //
; 8468 : 
; 8469 :     if(dwFlags & DSBLOCK_FROMWRITECURSOR)

  00035	8b 45 24	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00038	83 e0 01	 and	 eax, 1
  0003b	85 c0		 test	 eax, eax
  0003d	74 12		 je	 SHORT $L37237

; 8470 :     {
; 8471 :         hr = GetCurrentPosition(NULL, &dwLockPosition);

  0003f	8d 4d 0c	 lea	 ecx, DWORD PTR _dwLockPosition$[ebp]
  00042	51		 push	 ecx
  00043	6a 00		 push	 0
  00045	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ?GetCurrentPosition@CDirectSoundBuffer@DirectSound@@QAGJPAK0@Z ; DirectSound::CDirectSoundBuffer::GetCurrentPosition
  0004e	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L37237:

; 8472 :     }
; 8473 :     
; 8474 : #ifdef VALIDATE_PARAMETERS
; 8475 : 
; 8476 :     else if(dwLockPosition >= m_pSettings->m_dwBufferSize)
; 8477 :     {
; 8478 :         DPF_ERROR("Lock position out-of-bounds");
; 8479 :     }
; 8480 :     else if(dwLockPosition % m_pSettings->m_fmt.nBlockAlign)
; 8481 :     {
; 8482 :         DPF_ERROR("Lock position not block aligned");
; 8483 :     }
; 8484 : 
; 8485 : #endif // VALIDATE_PARAMETERS
; 8486 : 
; 8487 :     //
; 8488 :     // Validate the lock region size
; 8489 :     //
; 8490 : 
; 8491 :     if(SUCCEEDED(hr))

  00051	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00055	7c 19		 jl	 SHORT $L37239

; 8492 :     {
; 8493 :         if(dwFlags & DSBLOCK_ENTIREBUFFER)

  00057	8b 45 24	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  0005a	83 e0 02	 and	 eax, 2
  0005d	85 c0		 test	 eax, eax
  0005f	74 0f		 je	 SHORT $L37239

; 8494 :         {
; 8495 :             dwLockSize = m_pSettings->m_dwBufferSize;

  00061	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00067	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  0006d	89 45 10	 mov	 DWORD PTR _dwLockSize$[ebp], eax
$L37239:

; 8496 :         }
; 8497 :             
; 8498 : #ifdef VALIDATE_PARAMETERS
; 8499 : 
; 8500 :         else if(!dwLockSize)
; 8501 :         {
; 8502 :             DPF_ERROR("Lock size can't be 0 without specifying DSBLOCK_ENTIREBUFFER");
; 8503 :         }
; 8504 :         else if(dwLockSize > m_pSettings->m_dwBufferSize)
; 8505 :         {
; 8506 :             DPF_ERROR("Lock size out-of-bounds");
; 8507 :         }
; 8508 :         else if(dwLockSize % m_pSettings->m_fmt.nBlockAlign)
; 8509 :         {
; 8510 :             DPF_ERROR("Lock size not block aligned");
; 8511 :         }
; 8512 : 
; 8513 : #endif // VALIDATE_PARAMETERS
; 8514 : 
; 8515 :     }
; 8516 : 
; 8517 :     //
; 8518 :     // We're not really locking anything.  Instead, we're just returning
; 8519 :     // pointers to the data buffer.
; 8520 :     //
; 8521 : 
; 8522 :     if(SUCCEEDED(hr))

  00070	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00074	0f 8c 92 00 00
	00		 jl	 $L37242

; 8523 :     {
; 8524 :         *ppvLock1 = (LPBYTE)m_pSettings->m_pvBufferData + dwLockPosition;

  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00080	8b 82 b4 00 00
	00		 mov	 eax, DWORD PTR [edx+180]
  00086	03 45 0c	 add	 eax, DWORD PTR _dwLockPosition$[ebp]
  00089	8b 4d 14	 mov	 ecx, DWORD PTR _ppvLock1$[ebp]
  0008c	89 01		 mov	 DWORD PTR [ecx], eax

; 8525 :         *pdwLockSize1 = min(dwLockSize, m_pSettings->m_dwBufferSize - dwLockPosition);

  0008e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00091	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00094	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [eax+184]
  0009a	2b 4d 0c	 sub	 ecx, DWORD PTR _dwLockPosition$[ebp]
  0009d	39 4d 10	 cmp	 DWORD PTR _dwLockSize$[ebp], ecx
  000a0	73 08		 jae	 SHORT $L41935
  000a2	8b 55 10	 mov	 edx, DWORD PTR _dwLockSize$[ebp]
  000a5	89 55 ec	 mov	 DWORD PTR tv90[ebp], edx
  000a8	eb 12		 jmp	 SHORT $L41936
$L41935:
  000aa	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000b0	8b 91 b8 00 00
	00		 mov	 edx, DWORD PTR [ecx+184]
  000b6	2b 55 0c	 sub	 edx, DWORD PTR _dwLockPosition$[ebp]
  000b9	89 55 ec	 mov	 DWORD PTR tv90[ebp], edx
$L41936:
  000bc	8b 45 18	 mov	 eax, DWORD PTR _pdwLockSize1$[ebp]
  000bf	8b 4d ec	 mov	 ecx, DWORD PTR tv90[ebp]
  000c2	89 08		 mov	 DWORD PTR [eax], ecx

; 8526 : 
; 8527 :         if(ppvLock2 && pdwLockSize2)

  000c4	83 7d 1c 00	 cmp	 DWORD PTR _ppvLock2$[ebp], 0
  000c8	74 42		 je	 SHORT $L37242
  000ca	83 7d 20 00	 cmp	 DWORD PTR _pdwLockSize2$[ebp], 0
  000ce	74 3c		 je	 SHORT $L37242

; 8528 :         {
; 8529 :             if(*pdwLockSize1 < dwLockSize)

  000d0	8b 55 18	 mov	 edx, DWORD PTR _pdwLockSize1$[ebp]
  000d3	8b 02		 mov	 eax, DWORD PTR [edx]
  000d5	3b 45 10	 cmp	 eax, DWORD PTR _dwLockSize$[ebp]
  000d8	73 20		 jae	 SHORT $L37245

; 8530 :             {
; 8531 :                 *ppvLock2 = m_pSettings->m_pvBufferData;

  000da	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000e0	8b 45 1c	 mov	 eax, DWORD PTR _ppvLock2$[ebp]
  000e3	8b 8a b4 00 00
	00		 mov	 ecx, DWORD PTR [edx+180]
  000e9	89 08		 mov	 DWORD PTR [eax], ecx

; 8532 :                 *pdwLockSize2 = dwLockSize - *pdwLockSize1;

  000eb	8b 55 18	 mov	 edx, DWORD PTR _pdwLockSize1$[ebp]
  000ee	8b 45 10	 mov	 eax, DWORD PTR _dwLockSize$[ebp]
  000f1	2b 02		 sub	 eax, DWORD PTR [edx]
  000f3	8b 4d 20	 mov	 ecx, DWORD PTR _pdwLockSize2$[ebp]
  000f6	89 01		 mov	 DWORD PTR [ecx], eax

; 8533 :             }
; 8534 :             else

  000f8	eb 12		 jmp	 SHORT $L37242
$L37245:

; 8535 :             {
; 8536 :                 *ppvLock2 = NULL;

  000fa	8b 55 1c	 mov	 edx, DWORD PTR _ppvLock2$[ebp]
  000fd	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 8537 :                 *pdwLockSize2 = 0;

  00103	8b 45 20	 mov	 eax, DWORD PTR _pdwLockSize2$[ebp]
  00106	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L37242:

; 8538 :             }
; 8539 :         }
; 8540 :     }
; 8541 : 
; 8542 :     DPF_LEAVE_HRESULT(hr);
; 8543 : 
; 8544 :     return hr;

  0010c	8b 4d fc	 mov	 ecx, DWORD PTR _hr$[ebp]
  0010f	89 4d f0	 mov	 DWORD PTR $T41937[ebp], ecx
  00112	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00115	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0011a	8b 45 f0	 mov	 eax, DWORD PTR $T41937[ebp]
$L37230:

; 8545 : }

  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c2 20 00	 ret	 32			; 00000020H
?Lock@CDirectSoundBuffer@DirectSound@@QAGJKKPAPAXPAK01K@Z ENDP ; DirectSound::CDirectSoundBuffer::Lock
DSOUND	ENDS
PUBLIC	?SetCurrentPosition@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::SetCurrentPosition
; Function compile flags: /Odt
;	COMDAT ?SetCurrentPosition@CDirectSoundBuffer@DirectSound@@QAGJK@Z
DSOUND	SEGMENT
$T41942 = -16
$T41941 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
_dwPlayPosition$ = 12
?SetCurrentPosition@CDirectSoundBuffer@DirectSound@@QAGJK@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetCurrentPosition, COMDAT

; 8571 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 8572 :     HRESULT                 hr;
; 8573 :     
; 8574 :     DPF_ENTER();
; 8575 :     ENTER_EXTERNAL_METHOD();

  00006	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  00015	74 14		 je	 SHORT $L37254
  00017	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41941[ebp], -2147467259 ; 80004005H
  0001e	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  00026	8b 45 f4	 mov	 eax, DWORD PTR $T41941[ebp]
  00029	eb 23		 jmp	 SHORT $L37251
$L37254:

; 8576 :     
; 8577 : #ifdef VALIDATE_PARAMETERS
; 8578 : 
; 8579 :     if(dwPlayPosition % m_pSettings->m_fmt.nBlockAlign)
; 8580 :     {
; 8581 :         DPF_ERROR("Position not sample-aligned");
; 8582 :     }
; 8583 :     
; 8584 :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 8585 :     {
; 8586 :         DPF_ERROR("Can't call SetCurrentPosition on MIXIN/FXIN buffers");
; 8587 :     }
; 8588 : 
; 8589 :     if(dwPlayPosition >= m_pSettings->m_dwPlayLength)
; 8590 :     {
; 8591 :         DPF_ERROR("Play cursor position out-of-bounds");
; 8592 :     }
; 8593 :     
; 8594 : #endif // VALIDATE_PARAMETERS
; 8595 : 
; 8596 :     hr = m_pBuffer->SetCurrentPosition(dwPlayPosition);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _dwPlayPosition$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00035	e8 00 00 00 00	 call	 ?SetCurrentPosition@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::SetCurrentPosition
  0003a	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 8597 : 
; 8598 :     DPF_LEAVE_HRESULT(hr);
; 8599 : 
; 8600 :     return hr;

  0003d	8b 55 fc	 mov	 edx, DWORD PTR _hr$[ebp]
  00040	89 55 f0	 mov	 DWORD PTR $T41942[ebp], edx
  00043	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00046	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0004b	8b 45 f0	 mov	 eax, DWORD PTR $T41942[ebp]
$L37251:

; 8601 : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
?SetCurrentPosition@CDirectSoundBuffer@DirectSound@@QAGJK@Z ENDP ; DirectSound::CDirectSoundBuffer::SetCurrentPosition
DSOUND	ENDS
PUBLIC	?SetNotificationPositions@CMcpxBuffer@DirectSound@@QAEJXZ ; DirectSound::CMcpxBuffer::SetNotificationPositions
; Function compile flags: /Odt
;	COMDAT ?SetNotificationPositions@CDirectSoundBuffer@DirectSound@@QAGJKPBU_DSBPOSITIONNOTIFY@@@Z
DSOUND	SEGMENT
$T41947 = -16
$T41946 = -12
___AutoLock$ = -8
_hr$ = -4
_this$ = 8
_dwNotifyCount$ = 12
_paNotifies$ = 16
?SetNotificationPositions@CDirectSoundBuffer@DirectSound@@QAGJKPBU_DSBPOSITIONNOTIFY@@@Z PROC NEAR ; DirectSound::CDirectSoundBuffer::SetNotificationPositions, COMDAT

; 8629 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 8630 :     HRESULT                 hr  = DS_OK;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 8631 : 
; 8632 : #ifdef VALIDATE_PARAMETERS
; 8633 : 
; 8634 :     DWORD                   i;
; 8635 : 
; 8636 : #endif // VALIDATE_PARAMETERS
; 8637 : 
; 8638 :     DPF_ENTER();
; 8639 :     ENTER_EXTERNAL_METHOD();

  0000d	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00010	e8 00 00 00 00	 call	 ??0CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::CAutoLock
  00015	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_fDirectSoundInFinalRelease, 0
  0001c	74 14		 je	 SHORT $L37266
  0001e	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR $T41946[ebp], -2147467259 ; 80004005H
  00025	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00028	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0002d	8b 45 f4	 mov	 eax, DWORD PTR $T41946[ebp]
  00030	eb 3b		 jmp	 SHORT $L37262
$L37266:

; 8640 : 
; 8641 : #ifdef VALIDATE_PARAMETERS
; 8642 : 
; 8643 :     if(!(m_pSettings->m_dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY))
; 8644 :     {
; 8645 :         DPF_ERROR("Buffer does not have CTRLPOSITIONNOTIFY");
; 8646 :     }
; 8647 : 
; 8648 :     for(i = 0; i < dwNotifyCount; i++)
; 8649 :     {
; 8650 :         if(DSBPN_OFFSETSTOP == paNotifies[i].dwOffset)
; 8651 :         {
; 8652 :             continue;
; 8653 :         }
; 8654 :         
; 8655 :         if(paNotifies[i].dwOffset % m_pSettings->m_fmt.nBlockAlign)
; 8656 :         {
; 8657 :             DPF_ERROR("Offset at index %lu not block-aligned", i);
; 8658 :         }
; 8659 : 
; 8660 :         if(paNotifies[i].dwOffset >= m_pSettings->m_dwPlayLength)
; 8661 :         {
; 8662 :             DPF_ERROR("Offset at index %lu past the end of the play region", i);
; 8663 :         }
; 8664 :         
; 8665 :         if(!IS_VALID_HANDLE_VALUE(paNotifies[i].hEventNotify))
; 8666 :         {
; 8667 :             DPF_ERROR("Invalid event at index %lu", i);
; 8668 :         }
; 8669 :     }
; 8670 : 
; 8671 :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 8672 :     {
; 8673 :         DPF_ERROR("Can't call SetNotificationPositions on MIXIN/FXIN buffers");
; 8674 :     }
; 8675 : 
; 8676 : #endif // VALIDATE_PARAMETERS
; 8677 : 
; 8678 :     //
; 8679 :     // Update the settings object
; 8680 :     //
; 8681 : 
; 8682 :     hr = m_pSettings->SetNotificationPositions(dwNotifyCount, paNotifies);

  00032	8b 45 10	 mov	 eax, DWORD PTR _paNotifies$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _dwNotifyCount$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00040	e8 00 00 00 00	 call	 ?SetNotificationPositions@CDirectSoundBufferSettings@DirectSound@@QAEJKPBU_DSBPOSITIONNOTIFY@@@Z ; DirectSound::CDirectSoundBufferSettings::SetNotificationPositions
  00045	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 8683 : 
; 8684 :     //
; 8685 :     // Update the implementation object
; 8686 :     //
; 8687 : 
; 8688 :     if(SUCCEEDED(hr))

  00048	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004c	7c 0e		 jl	 SHORT $L37270

; 8689 :     {
; 8690 :         hr = m_pBuffer->SetNotificationPositions();

  0004e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00054	e8 00 00 00 00	 call	 ?SetNotificationPositions@CMcpxBuffer@DirectSound@@QAEJXZ ; DirectSound::CMcpxBuffer::SetNotificationPositions
  00059	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L37270:

; 8691 :     }
; 8692 : 
; 8693 :     DPF_LEAVE_HRESULT(hr);
; 8694 : 
; 8695 :     return hr;

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _hr$[ebp]
  0005f	89 4d f0	 mov	 DWORD PTR $T41947[ebp], ecx
  00062	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoLock$[ebp]
  00065	e8 00 00 00 00	 call	 ??1CAutoLock@DirectSound@@QAE@XZ ; DirectSound::CAutoLock::~CAutoLock
  0006a	8b 45 f0	 mov	 eax, DWORD PTR $T41947[ebp]
$L37262:

; 8696 : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 0c 00	 ret	 12			; 0000000cH
?SetNotificationPositions@CDirectSoundBuffer@DirectSound@@QAGJKPBU_DSBPOSITIONNOTIFY@@@Z ENDP ; DirectSound::CDirectSoundBuffer::SetNotificationPositions
DSOUND	ENDS
PUBLIC	?__AddRef@DirectSound@@YGPAVCDirectSoundBufferSettings@1@PAV21@@Z ; DirectSound::__AddRef
PUBLIC	??0CMcpxVoiceClient@DirectSound@@QAE@PAVCMcpxAPU@1@PAVCDirectSoundVoiceSettings@1@@Z ; DirectSound::CMcpxVoiceClient::CMcpxVoiceClient
PUBLIC	?Initialize@CMcpxVoiceClient@DirectSound@@UAEJH@Z ; DirectSound::CMcpxVoiceClient::Initialize
PUBLIC	?SetFormat@CMcpxVoiceClient@DirectSound@@UAEJXZ	; DirectSound::CMcpxVoiceClient::SetFormat
PUBLIC	?ScheduleDeferredCommand@CMcpxBuffer@DirectSound@@MAEHK_JK@Z ; DirectSound::CMcpxBuffer::ScheduleDeferredCommand
PUBLIC	?RemoveDeferredCommand@CMcpxBuffer@DirectSound@@MAEXK@Z ; DirectSound::CMcpxBuffer::RemoveDeferredCommand
PUBLIC	?ServiceDeferredCommand@CMcpxBuffer@DirectSound@@MAEXKK@Z ; DirectSound::CMcpxBuffer::ServiceDeferredCommand
PUBLIC	?ServiceVoiceInterrupt@CMcpxBuffer@DirectSound@@MAEHXZ ; DirectSound::CMcpxBuffer::ServiceVoiceInterrupt
PUBLIC	??_7CMcpxBuffer@DirectSound@@6B@		; DirectSound::CMcpxBuffer::`vftable'
PUBLIC	??_GCMcpxBuffer@DirectSound@@UAEPAXI@Z		; DirectSound::CMcpxBuffer::`scalar deleting destructor'
EXTRN	??_ECMcpxBuffer@DirectSound@@UAEPAXI@Z:NEAR	; DirectSound::CMcpxBuffer::`vector deleting destructor'
;	COMDAT ??_7CMcpxBuffer@DirectSound@@6B@
; File c:\xbox\private\windows\directx\dsound\dsound\mcpbuf.cpp
CONST	SEGMENT
??_7CMcpxBuffer@DirectSound@@6B@ DD FLAT:??_ECMcpxBuffer@DirectSound@@UAEPAXI@Z ; DirectSound::CMcpxBuffer::`vftable'
	DD	FLAT:?AddRef@CRefCount@DirectSound@@UAGKXZ
	DD	FLAT:?Release@CRefCount@DirectSound@@UAGKXZ
	DD	FLAT:?Initialize@CMcpxVoiceClient@DirectSound@@UAEJH@Z
	DD	FLAT:?SetFormat@CMcpxVoiceClient@DirectSound@@UAEJXZ
	DD	FLAT:?ServiceVoiceInterrupt@CMcpxBuffer@DirectSound@@MAEHXZ
	DD	FLAT:?ScheduleDeferredCommand@CMcpxBuffer@DirectSound@@MAEHK_JK@Z
	DD	FLAT:?RemoveDeferredCommand@CMcpxBuffer@DirectSound@@MAEXK@Z
	DD	FLAT:?ServiceDeferredCommand@CMcpxBuffer@DirectSound@@MAEXKK@Z
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CMcpxBuffer@DirectSound@@QAE@PAVCMcpxAPU@1@PAVCDirectSoundBufferSettings@1@@Z
DSOUND	SEGMENT
_this$ = -8
_i$ = -4
_pMcpxApu$ = 8
_pSettings$ = 12
??0CMcpxBuffer@DirectSound@@QAE@PAVCMcpxAPU@1@PAVCDirectSoundBufferSettings@1@@Z PROC NEAR ; DirectSound::CMcpxBuffer::CMcpxBuffer, COMDAT
; _this$ = ecx

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _pSettings$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _pMcpxApu$[ebp]
  00011	51		 push	 ecx
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0CMcpxVoiceClient@DirectSound@@QAE@PAVCMcpxAPU@1@PAVCDirectSoundVoiceSettings@1@@Z ; DirectSound::CMcpxVoiceClient::CMcpxVoiceClient
  0001a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET FLAT:??_7CMcpxBuffer@DirectSound@@6B@

; 42   :     DWORD                   i;
; 43   :     
; 44   :     DPF_ENTER();
; 45   : 
; 46   :     m_pSettings = ADDREF(pSettings);

  00023	8b 45 0c	 mov	 eax, DWORD PTR _pSettings$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCDirectSoundBufferSettings@1@PAV21@@Z ; DirectSound::__AddRef
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax

; 47   : 
; 48   :     //
; 49   :     // Initialize deferred command structures
; 50   :     //
; 51   : 
; 52   :     for(i = 0; i < NUMELMS(m_aDeferredCommands); i++)

  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0003c	eb 09		 jmp	 SHORT $L37283
$L37284:
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00041	83 c2 01	 add	 edx, 1
  00044	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L37283:
  00047	83 7d fc 05	 cmp	 DWORD PTR _i$[ebp], 5
  0004b	73 68		 jae	 SHORT $L37285

; 53   :     {
; 54   :         InitializeListHead(&m_aDeferredCommands[i].leListEntry);

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00050	c1 e0 05	 shl	 eax, 5
  00053	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	8d 94 01 98 00
	00 00		 lea	 edx, DWORD PTR [ecx+eax+152]
  0005d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00060	c1 e0 05	 shl	 eax, 5
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	89 94 01 9c 00
	00 00		 mov	 DWORD PTR [ecx+eax+156], edx
  0006d	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00070	c1 e2 05	 shl	 edx, 5
  00073	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00076	c1 e0 05	 shl	 eax, 5
  00079	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  0007f	8b 94 16 9c 00
	00 00		 mov	 edx, DWORD PTR [esi+edx+156]
  00086	89 94 01 98 00
	00 00		 mov	 DWORD PTR [ecx+eax+152], edx

; 55   :         
; 56   :         m_aDeferredCommands[i].pVoice = this;

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00090	c1 e0 05	 shl	 eax, 5
  00093	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00099	89 94 01 a4 00
	00 00		 mov	 DWORD PTR [ecx+eax+164], edx

; 57   :         m_aDeferredCommands[i].dwCommand = i;

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000a3	c1 e0 05	 shl	 eax, 5
  000a6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000ac	89 94 01 a8 00
	00 00		 mov	 DWORD PTR [ecx+eax+168], edx

; 58   :     }

  000b3	eb 89		 jmp	 SHORT $L37284
$L37285:

; 59   : 
; 60   :     m_aDeferredCommands[MCPX_DEFERREDCMD_BUFFER_CHECKSTUCK].dwFlags |= MCPX_DEFERREDCMDF_LOWPRIORITY | MCPX_DEFERREDCMDF_PERSIST;

  000b5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  000be	83 c9 05	 or	 ecx, 5
  000c1	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000c4	89 8a a0 00 00
	00		 mov	 DWORD PTR [edx+160], ecx

; 61   :     m_aDeferredCommands[MCPX_DEFERREDCMD_BUFFER_RELEASERESOURCES].dwFlags |= MCPX_DEFERREDCMDF_LOWPRIORITY | MCPX_DEFERREDCMDF_PERSIST;

  000ca	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  000d3	83 c9 05	 or	 ecx, 5
  000d6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000d9	89 8a c0 00 00
	00		 mov	 DWORD PTR [edx+192], ecx

; 62   :     m_aDeferredCommands[MCPX_DEFERREDCMD_BUFFER_POSITIONDELTA].dwFlags |= MCPX_DEFERREDCMDF_LOWPRIORITY | MCPX_DEFERREDCMDF_PERSIST;

  000df	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e2	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  000e8	83 c9 05	 or	 ecx, 5
  000eb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ee	89 8a e0 00 00
	00		 mov	 DWORD PTR [edx+224], ecx

; 63   : 
; 64   :     DPF_LEAVE_VOID();
; 65   : }

  000f4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	5e		 pop	 esi
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c2 08 00	 ret	 8
??0CMcpxBuffer@DirectSound@@QAE@PAVCMcpxAPU@1@PAVCDirectSoundBufferSettings@1@@Z ENDP ; DirectSound::CMcpxBuffer::CMcpxBuffer
DSOUND	ENDS
PUBLIC	??1CMcpxBuffer@DirectSound@@UAE@XZ		; DirectSound::CMcpxBuffer::~CMcpxBuffer
; Function compile flags: /Odt
;	COMDAT ??_GCMcpxBuffer@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCMcpxBuffer@DirectSound@@UAEPAXI@Z PROC NEAR	; DirectSound::CMcpxBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMcpxBuffer@DirectSound@@UAE@XZ ; DirectSound::CMcpxBuffer::~CMcpxBuffer
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L37289
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L37289:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCMcpxBuffer@DirectSound@@UAEPAXI@Z ENDP		; DirectSound::CMcpxBuffer::`scalar deleting destructor'
DSOUND	ENDS
PUBLIC	??1CMcpxVoiceClient@DirectSound@@UAE@XZ		; DirectSound::CMcpxVoiceClient::~CMcpxVoiceClient
PUBLIC	?ReleaseBufferResources@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::ReleaseBufferResources
; Function compile flags: /Odt
;	COMDAT ??1CMcpxBuffer@DirectSound@@UAE@XZ
DSOUND	SEGMENT
_this$ = -8
_i$ = -4
??1CMcpxBuffer@DirectSound@@UAE@XZ PROC NEAR		; DirectSound::CMcpxBuffer::~CMcpxBuffer, COMDAT
; _this$ = ecx

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMcpxBuffer@DirectSound@@6B@

; 91   :     DWORD                   i;
; 92   :     
; 93   :     DPF_ENTER();
; 94   : 
; 95   :     //
; 96   :     // Free buffer resources
; 97   :     //
; 98   : 
; 99   :     ReleaseBufferResources();

  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?ReleaseBufferResources@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::ReleaseBufferResources

; 100  : 
; 101  :     //
; 102  :     // Make sure all deferred commands are dequeued
; 103  :     //
; 104  : 
; 105  :     for(i = 0; i < NUMELMS(m_aDeferredCommands); i++)

  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00021	eb 09		 jmp	 SHORT $L37295
$L37296:
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00026	83 c1 01	 add	 ecx, 1
  00029	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L37295:
  0002c	83 7d fc 05	 cmp	 DWORD PTR _i$[ebp], 5
  00030	73 0e		 jae	 SHORT $L37297

; 106  :     {
; 107  :         RemoveDeferredCommand(i);

  00032	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00035	52		 push	 edx
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?RemoveDeferredCommand@CMcpxBuffer@DirectSound@@MAEXK@Z ; DirectSound::CMcpxBuffer::RemoveDeferredCommand

; 108  :     }

  0003e	eb e3		 jmp	 SHORT $L37296
$L37297:

; 109  : 
; 110  :     //
; 111  :     // Release the settings object
; 112  :     //
; 113  :     
; 114  :     RELEASE(m_pSettings);

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  0004a	74 25		 je	 SHORT $L37293
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  0005e	8b 12		 mov	 edx, DWORD PTR [edx]
  00060	51		 push	 ecx
  00061	ff 52 08	 call	 DWORD PTR [edx+8]
  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+144], 0
$L37293:

; 115  : 
; 116  :     DPF_LEAVE_VOID();
; 117  : }

  00071	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ??1CMcpxVoiceClient@DirectSound@@UAE@XZ ; DirectSound::CMcpxVoiceClient::~CMcpxVoiceClient
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
??1CMcpxBuffer@DirectSound@@UAE@XZ ENDP			; DirectSound::CMcpxBuffer::~CMcpxBuffer
DSOUND	ENDS
PUBLIC	?AllocateBufferResources@CMcpxBuffer@DirectSound@@IAEJXZ ; DirectSound::CMcpxBuffer::AllocateBufferResources
; Function compile flags: /Odt
;	COMDAT ?Initialize@CMcpxBuffer@DirectSound@@QAEJXZ
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
?Initialize@CMcpxBuffer@DirectSound@@QAEJXZ PROC NEAR	; DirectSound::CMcpxBuffer::Initialize, COMDAT
; _this$ = ecx

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 144  :     HRESULT                         hr;
; 145  : 
; 146  :     DPF_ENTER();
; 147  : 
; 148  :     //
; 149  :     // Initialize the base class
; 150  :     //
; 151  : 
; 152  :     hr = CMcpxVoiceClient::Initialize(FALSE);

  00009	6a 00		 push	 0
  0000b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?Initialize@CMcpxVoiceClient@DirectSound@@UAEJH@Z ; DirectSound::CMcpxVoiceClient::Initialize
  00013	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 153  : 
; 154  :     //
; 155  :     // If the buffer was created without LOCDEFER and we have valid buffer 
; 156  :     // data, allocate resources now.
; 157  :     //
; 158  : 
; 159  :     if(SUCCEEDED(hr) && !(m_pSettings->m_dwFlags & DSBCAPS_LOCDEFER))

  00016	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0001a	7c 21		 jl	 SHORT $L37305
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00025	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00028	81 e2 00 00 04
	00		 and	 edx, 262144		; 00040000H
  0002e	85 d2		 test	 edx, edx
  00030	75 0b		 jne	 SHORT $L37305

; 160  :     {
; 161  :         hr = AllocateBufferResources();

  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?AllocateBufferResources@CMcpxBuffer@DirectSound@@IAEJXZ ; DirectSound::CMcpxBuffer::AllocateBufferResources
  0003a	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L37305:

; 162  :     }
; 163  : 
; 164  :     DPF_LEAVE_HRESULT(hr);
; 165  : 
; 166  :     return hr;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 167  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?Initialize@CMcpxBuffer@DirectSound@@QAEJXZ ENDP	; DirectSound::CMcpxBuffer::Initialize
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetBufferData@CMcpxBuffer@DirectSound@@QAEJXZ
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
?SetBufferData@CMcpxBuffer@DirectSound@@QAEJXZ PROC NEAR ; DirectSound::CMcpxBuffer::SetBufferData, COMDAT
; _this$ = ecx

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 194  :     HRESULT                 hr  = DS_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 195  : 
; 196  :     DPF_ENTER();
; 197  : 
; 198  :     ASSERT(!(m_dwStatus & ~MCPX_VOICESTATUS_ALLOCATED));
; 199  :     ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));
; 200  :     ASSERT(m_pSettings->m_pvBufferData);
; 201  :     ASSERT(m_pSettings->m_dwBufferSize);
; 202  : 
; 203  :     //
; 204  :     // Reset the cached play cursor position
; 205  :     //
; 206  : 
; 207  :     m_dwCachedPlayCursor = 0;

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 80 38 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+312], 0

; 208  : 
; 209  :     //
; 210  :     // If we're LOCDEFER, don't do anything.  If we're not, make sure
; 211  :     // resources are allocated.
; 212  :     //
; 213  : 
; 214  :     if(!(m_pSettings->m_dwFlags & DSBCAPS_LOCDEFER))

  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00026	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00029	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0002e	85 c0		 test	 eax, eax
  00030	75 0b		 jne	 SHORT $L37312

; 215  :     {
; 216  :         hr = AllocateBufferResources();

  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?AllocateBufferResources@CMcpxBuffer@DirectSound@@IAEJXZ ; DirectSound::CMcpxBuffer::AllocateBufferResources
  0003a	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L37312:

; 217  :     }
; 218  : 
; 219  :     DPF_LEAVE_HRESULT(hr);
; 220  : 
; 221  :     return hr;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 222  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?SetBufferData@CMcpxBuffer@DirectSound@@QAEJXZ ENDP	; DirectSound::CMcpxBuffer::SetBufferData
DSOUND	ENDS
PUBLIC	?UnmapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ	; DirectSound::CMcpxBuffer::UnmapBuffer
; Function compile flags: /Odt
;	COMDAT ?ReleaseBufferData@CMcpxBuffer@DirectSound@@QAEJH@Z
DSOUND	SEGMENT
_this$ = -4
_fChanging$ = 8
?ReleaseBufferData@CMcpxBuffer@DirectSound@@QAEJH@Z PROC NEAR ; DirectSound::CMcpxBuffer::ReleaseBufferData, COMDAT
; _this$ = ecx

; 250  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 251  :     DPF_ENTER();
; 252  : 
; 253  :     ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));
; 254  : 
; 255  :     //
; 256  :     // If we're LOCDEFER, go ahead and free voice resources.  If not, just
; 257  :     // deactivate the voice and unmap the data buffer.
; 258  :     //
; 259  : 
; 260  :     if(!fChanging && (m_pSettings->m_dwFlags & DSBCAPS_LOCDEFER))

  00007	83 7d 08 00	 cmp	 DWORD PTR _fChanging$[ebp], 0
  0000b	75 20		 jne	 SHORT $L37317
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00016	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00019	81 e2 00 00 04
	00		 and	 edx, 262144		; 00040000H
  0001f	85 d2		 test	 edx, edx
  00021	74 0a		 je	 SHORT $L37317

; 261  :     {
; 262  :         ReleaseBufferResources();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?ReleaseBufferResources@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::ReleaseBufferResources

; 263  :     }
; 264  :     else

  0002b	eb 08		 jmp	 SHORT $L37318
$L37317:

; 265  :     {
; 266  :         UnmapBuffer();

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?UnmapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::UnmapBuffer
$L37318:

; 267  :     }
; 268  : 
; 269  :     //
; 270  :     // We're not allowing the current position to persist after changing
; 271  :     // the buffer data.
; 272  :     //
; 273  : 
; 274  :     m_dwCachedPlayCursor = 0;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c7 80 38 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+312], 0

; 275  : 
; 276  :     DPF_LEAVE_HRESULT(DS_OK);
; 277  : 
; 278  :     return DS_OK;

  00042	33 c0		 xor	 eax, eax

; 279  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?ReleaseBufferData@CMcpxBuffer@DirectSound@@QAEJH@Z ENDP ; DirectSound::CMcpxBuffer::ReleaseBufferData
DSOUND	ENDS
PUBLIC	?AllocateVoiceResources@CMcpxVoiceClient@DirectSound@@IAEJXZ ; DirectSound::CMcpxVoiceClient::AllocateVoiceResources
PUBLIC	?MapInputBuffer@CMcpxBuffer@DirectSound@@IAEJXZ	; DirectSound::CMcpxBuffer::MapInputBuffer
PUBLIC	?MapEffectsBuffer@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::MapEffectsBuffer
; Function compile flags: /Odt
;	COMDAT ?AllocateBufferResources@CMcpxBuffer@DirectSound@@IAEJXZ
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
?AllocateBufferResources@CMcpxBuffer@DirectSound@@IAEJXZ PROC NEAR ; DirectSound::CMcpxBuffer::AllocateBufferResources, COMDAT
; _this$ = ecx

; 305  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 306  :     HRESULT                 hr;
; 307  :     
; 308  :     DPF_ENTER();
; 309  : 
; 310  :     //
; 311  :     // Allocate voice resources
; 312  :     //
; 313  :     
; 314  :     hr = AllocateVoiceResources();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?AllocateVoiceResources@CMcpxVoiceClient@DirectSound@@IAEJXZ ; DirectSound::CMcpxVoiceClient::AllocateVoiceResources
  00011	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 315  : 
; 316  :     //
; 317  :     // Map the data buffer
; 318  :     //
; 319  : 
; 320  :     if(SUCCEEDED(hr) && !(m_pSettings->m_dwFlags & DSBCAPS_MIXIN))

  00014	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00018	7c 65		 jl	 SHORT $L37326
  0001a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00023	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00026	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  0002c	85 d2		 test	 edx, edx
  0002e	75 4f		 jne	 SHORT $L37326

; 321  :     {
; 322  :         if(m_pSettings->m_dwFlags & DSBCAPS_FXIN)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00039	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0003c	81 e2 00 00 08
	00		 and	 edx, 524288		; 00080000H
  00042	85 d2		 test	 edx, edx
  00044	74 0a		 je	 SHORT $L37327

; 323  :         {
; 324  :             MapEffectsBuffer();

  00046	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?MapEffectsBuffer@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::MapEffectsBuffer

; 325  :         }
; 326  :         else if(m_pSettings->m_pvBufferData && m_pSettings->m_dwBufferSize)

  0004e	eb 2f		 jmp	 SHORT $L37326
$L37327:
  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00059	83 b9 b4 00 00
	00 00		 cmp	 DWORD PTR [ecx+180], 0
  00060	74 1d		 je	 SHORT $L37326
  00062	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00065	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  0006b	83 b8 b8 00 00
	00 00		 cmp	 DWORD PTR [eax+184], 0
  00072	74 0b		 je	 SHORT $L37326

; 327  :         {
; 328  :             hr = MapInputBuffer();

  00074	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ?MapInputBuffer@CMcpxBuffer@DirectSound@@IAEJXZ ; DirectSound::CMcpxBuffer::MapInputBuffer
  0007c	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L37326:

; 329  :         }
; 330  :     }
; 331  : 
; 332  :     DPF_LEAVE_HRESULT(hr);
; 333  : 
; 334  :     return hr;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 335  : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?AllocateBufferResources@CMcpxBuffer@DirectSound@@IAEJXZ ENDP ; DirectSound::CMcpxBuffer::AllocateBufferResources
DSOUND	ENDS
PUBLIC	?WaitForVoiceOff@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::WaitForVoiceOff
PUBLIC	?ReleaseVoiceResources@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::ReleaseVoiceResources
; Function compile flags: /Odt
;	COMDAT ?ReleaseBufferResources@CMcpxBuffer@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -8
_i$ = -4
?ReleaseBufferResources@CMcpxBuffer@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxBuffer::ReleaseBufferResources, COMDAT
; _this$ = ecx

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 362  :     DWORD                   i;
; 363  :     
; 364  :     DPF_ENTER();
; 365  : 
; 366  :     //
; 367  :     // Make sure the voice is stopped
; 368  :     //
; 369  : 
; 370  :     Stop();

  00009	6a 00		 push	 0
  0000b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?Stop@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::Stop

; 371  :     WaitForVoiceOff();

  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?WaitForVoiceOff@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::WaitForVoiceOff

; 372  : 
; 373  :     //
; 374  :     // Unschedule any pending low-priority tasks (including RELEASERESOURCES)
; 375  :     //
; 376  : 
; 377  :     for(i = 0; i < MCPX_DEFERREDCMD_BUFFER_COUNT; i++)

  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00022	eb 09		 jmp	 SHORT $L37335
$L37336:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00027	83 c0 01	 add	 eax, 1
  0002a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L37335:
  0002d	83 7d fc 05	 cmp	 DWORD PTR _i$[ebp], 5
  00031	73 28		 jae	 SHORT $L37337

; 378  :     {
; 379  :         if(m_aDeferredCommands[i].dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY)

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00036	c1 e1 05	 shl	 ecx, 5
  00039	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	8b 84 0a a0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+160]
  00043	83 e0 01	 and	 eax, 1
  00046	85 c0		 test	 eax, eax
  00048	74 0f		 je	 SHORT $L37338

; 380  :         {
; 381  :             RemoveDeferredCommand(i);

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0004d	51		 push	 ecx
  0004e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	ff 50 1c	 call	 DWORD PTR [eax+28]
$L37338:

; 382  :         }
; 383  :     }

  00059	eb c9		 jmp	 SHORT $L37336
$L37337:

; 384  : 
; 385  :     //
; 386  :     // Unmap the buffer.
; 387  :     //
; 388  : 
; 389  :     UnmapBuffer();

  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?UnmapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::UnmapBuffer

; 390  : 
; 391  :     //
; 392  :     // Clear any left-over status bits
; 393  :     //
; 394  : 
; 395  :     and(&m_dwStatus, MCPX_VOICESTATUS_DEACTIVATEMASK);

  00063	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	83 c1 12	 add	 ecx, 18			; 00000012H
  00069	ba 11 01 00 00	 mov	 edx, 273		; 00000111H
  0006e	e8 00 00 00 00	 call	 ?and@@YIXPCGG@Z		; and

; 396  : 
; 397  :     //
; 398  :     // Release voice resources
; 399  :     //
; 400  : 
; 401  :     ReleaseVoiceResources();

  00073	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?ReleaseVoiceResources@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::ReleaseVoiceResources

; 402  : 
; 403  :     DPF_LEAVE_VOID();
; 404  : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?ReleaseBufferResources@CMcpxBuffer@DirectSound@@IAEXXZ ENDP ; DirectSound::CMcpxBuffer::ReleaseBufferResources
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\drvhlp.h
DSOUND	ENDS
;	COMDAT ?and@@YIXPCGG@Z
DSOUND	SEGMENT
_src$ = -8
_dst$ = -4
?and@@YIXPCGG@Z PROC NEAR				; and, COMDAT
; _dst$ = ecx
; _src$ = dx

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	66 89 55 f8	 mov	 WORD PTR _src$[ebp], dx
  0000a	89 4d fc	 mov	 DWORD PTR _dst$[ebp], ecx

; 168  :     __asm
; 169  :     {
; 170  :         and word ptr [ecx], dx

  0000d	66 21 11	 and	 WORD PTR [ecx], dx

; 171  :     }
; 172  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?and@@YIXPCGG@Z ENDP					; and
DSOUND	ENDS
PUBLIC	?Alloc@CMcpxBufferSgeHeap@DirectSound@@QAEPAUSGEHEAPRUNMARKER@@PAXK@Z ; DirectSound::CMcpxBufferSgeHeap::Alloc
PUBLIC	?MapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ	; DirectSound::CMcpxBuffer::MapBuffer
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpbuf.cpp
;	COMDAT ?MapInputBuffer@CMcpxBuffer@DirectSound@@IAEJXZ
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
?MapInputBuffer@CMcpxBuffer@DirectSound@@IAEJXZ PROC NEAR ; DirectSound::CMcpxBuffer::MapInputBuffer, COMDAT
; _this$ = ecx

; 430  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 431  :     HRESULT                 hr  = DS_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 432  :     
; 433  :     DPF_ENTER();
; 434  : 
; 435  :     ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));
; 436  :     ASSERT(m_pSettings->m_pvBufferData);
; 437  :     ASSERT(m_pSettings->m_dwBufferSize);
; 438  : 
; 439  :     if(!(m_dwStatus & MCPX_VOICESTATUS_BUFFERMAPPED))

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00017	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  0001d	85 c9		 test	 ecx, ecx
  0001f	75 76		 jne	 SHORT $L37345

; 440  :     {
; 441  :         ASSERT(m_dwStatus == MCPX_VOICESTATUS_ALLOCATED);
; 442  :         ASSERT(!m_pSgeHeapEntry);
; 443  : 
; 444  :         //
; 445  :         // Set the status bit that shows that the buffer was mapped
; 446  :         //
; 447  : 
; 448  :         or(&m_dwStatus, MCPX_VOICESTATUS_BUFFERMAPPED);

  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 12	 add	 ecx, 18			; 00000012H
  00027	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0002c	e8 00 00 00 00	 call	 ?or@@YIXPCGG@Z		; or

; 449  : 
; 450  :         //
; 451  :         // Allocate a run of SGEs and map the buffer into the global SGE table
; 452  :         //
; 453  : 
; 454  :         if(!(m_pSgeHeapEntry = m_pMcpxApu->m_SgeHeap.Alloc(m_pSettings->m_pvBufferData, m_pSettings->m_dwBufferSize)))

  00031	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00034	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  0003a	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [eax+184]
  00040	51		 push	 ecx
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  0004a	8b 88 b4 00 00
	00		 mov	 ecx, DWORD PTR [eax+180]
  00050	51		 push	 ecx
  00051	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00054	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00057	83 c1 64	 add	 ecx, 100		; 00000064H
  0005a	e8 00 00 00 00	 call	 ?Alloc@CMcpxBufferSgeHeap@DirectSound@@QAEPAUSGEHEAPRUNMARKER@@PAXK@Z ; DirectSound::CMcpxBufferSgeHeap::Alloc
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	89 81 94 00 00
	00		 mov	 DWORD PTR [ecx+148], eax
  00068	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	83 ba 94 00 00
	00 00		 cmp	 DWORD PTR [edx+148], 0
  00072	75 07		 jne	 SHORT $L37346

; 455  :         {
; 456  :             DPF_RESOURCE("Out of scatter/gather entries.  Either your buffer is too big, or too many buffers have been mapped at one time.");
; 457  :             hr = DSERR_OUTOFMEMORY;

  00074	c7 45 fc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L37346:

; 458  :         }
; 459  : 
; 460  :         //
; 461  :         // Complete the mapping operation
; 462  :         //
; 463  : 
; 464  :         if(SUCCEEDED(hr))

  0007b	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0007f	7c 08		 jl	 SHORT $L37349

; 465  :         {
; 466  :             MapBuffer();

  00081	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ?MapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::MapBuffer
$L37349:

; 467  :         }
; 468  : 
; 469  :         //
; 470  :         // If anything went wrong, unmap the buffer
; 471  :         //
; 472  : 
; 473  :         if(FAILED(hr))

  00089	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0008d	7d 08		 jge	 SHORT $L37345

; 474  :         {
; 475  :             UnmapBuffer();

  0008f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?UnmapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::UnmapBuffer
$L37345:

; 476  :         }
; 477  :     }
; 478  : 
; 479  :     DPF_LEAVE_HRESULT(hr);
; 480  : 
; 481  :     return hr;

  00097	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 482  : }

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
?MapInputBuffer@CMcpxBuffer@DirectSound@@IAEJXZ ENDP	; DirectSound::CMcpxBuffer::MapInputBuffer
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\drvhlp.h
DSOUND	ENDS
;	COMDAT ?or@@YIXPCGG@Z
DSOUND	SEGMENT
_src$ = -8
_dst$ = -4
?or@@YIXPCGG@Z PROC NEAR				; or, COMDAT
; _dst$ = ecx
; _src$ = dx

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	66 89 55 f8	 mov	 WORD PTR _src$[ebp], dx
  0000a	89 4d fc	 mov	 DWORD PTR _dst$[ebp], ecx

; 176  :     __asm
; 177  :     {
; 178  :         or word ptr [ecx], dx

  0000d	66 09 11	 or	 WORD PTR [ecx], dx

; 179  :     }
; 180  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?or@@YIXPCGG@Z ENDP					; or
DSOUND	ENDS
PUBLIC	?MapBuffer@CMcpxBuffer@DirectSound@@IAEXK@Z	; DirectSound::CMcpxBuffer::MapBuffer
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpbuf.h
;	COMDAT ?MapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -4
?MapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ PROC NEAR	; DirectSound::CMcpxBuffer::MapBuffer, COMDAT
; _this$ = ecx

; 116  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 117  :         MapBuffer(m_pSettings->m_dwPlayStart);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00010	8b 91 bc 00 00
	00		 mov	 edx, DWORD PTR [ecx+188]
  00016	52		 push	 edx
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?MapBuffer@CMcpxBuffer@DirectSound@@IAEXK@Z ; DirectSound::CMcpxBuffer::MapBuffer

; 118  :     }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?MapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ ENDP		; DirectSound::CMcpxBuffer::MapBuffer
DSOUND	ENDS
PUBLIC	?SamplesToBytes@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::SamplesToBytes
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpbuf.cpp
;	COMDAT ?MapEffectsBuffer@CMcpxBuffer@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -16
_pvBufferData$ = -12
_dwBufferSize$ = -8
_dwVoiceIndex$ = -4
?MapEffectsBuffer@CMcpxBuffer@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxBuffer::MapEffectsBuffer, COMDAT
; _this$ = ecx

; 508  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 509  :     DWORD                   dwVoiceIndex;
; 510  :     LPVOID                  pvBufferData;
; 511  :     DWORD                   dwBufferSize;
; 512  :     
; 513  :     DPF_ENTER();
; 514  : 
; 515  :     ASSERT((m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK) == DSBCAPS_FXIN);
; 516  :     ASSERT(!m_pSgeHeapEntry);
; 517  : 
; 518  :     if(!(m_dwStatus & MCPX_VOICESTATUS_BUFFERMAPPED))

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00010	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  00016	85 c9		 test	 ecx, ecx
  00018	75 61		 jne	 SHORT $L37355

; 519  :     {
; 520  :         ASSERT(m_dwStatus == MCPX_VOICESTATUS_ALLOCATED);
; 521  :         ASSERT(!m_pSettings->m_pvBufferData);
; 522  :         ASSERT(!m_pSettings->m_dwBufferSize);
; 523  : 
; 524  :         //
; 525  :         // Set the status bit that shows that the buffer was mapped
; 526  :         //
; 527  : 
; 528  :         or(&m_dwStatus, MCPX_VOICESTATUS_BUFFERMAPPED);

  0001a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 12	 add	 ecx, 18			; 00000012H
  00020	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00025	e8 00 00 00 00	 call	 ?or@@YIXPCGG@Z		; or

; 529  : 
; 530  :         //
; 531  :         // The 2047th SGE is reserved for global multipass (i.e. FXIN) buffers.
; 532  :         // It was already set up for us, so all we have to do here is point the
; 533  :         // voice at it.
; 534  :         //
; 535  : 
; 536  :         dwVoiceIndex = m_pSettings->m_dwInputMixBin - DSMIXBIN_FXSEND_FIRST;

  0002a	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00033	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  00039	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0003c	89 4d fc	 mov	 DWORD PTR _dwVoiceIndex$[ebp], ecx

; 537  : 
; 538  :         dwBufferSize = SamplesToBytes(MCPX_HW_FRAME_SIZE_SAMPLES);

  0003f	6a 20		 push	 32			; 00000020H
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?SamplesToBytes@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::SamplesToBytes
  00049	89 45 f8	 mov	 DWORD PTR _dwBufferSize$[ebp], eax

; 539  :         pvBufferData = (LPBYTE)m_pMcpxApu->m_ctxMemory[MCPX_MEM_GPMULTIPASS].VirtualAddress + (dwVoiceIndex * dwBufferSize);

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _dwVoiceIndex$[ebp]
  0004f	0f af 55 f8	 imul	 edx, DWORD PTR _dwBufferSize$[ebp]
  00053	a1 b0 00 00 00	 mov	 eax, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+176
  00058	03 c2		 add	 eax, edx
  0005a	89 45 f4	 mov	 DWORD PTR _pvBufferData$[ebp], eax

; 540  : 
; 541  :         m_pSettings->SetBufferData(pvBufferData, dwBufferSize);

  0005d	8b 4d f8	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00060	51		 push	 ecx
  00061	8b 55 f4	 mov	 edx, DWORD PTR _pvBufferData$[ebp]
  00064	52		 push	 edx
  00065	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  0006e	e8 00 00 00 00	 call	 ?SetBufferData@CDirectSoundBufferSettings@DirectSound@@QAEJPAXK@Z ; DirectSound::CDirectSoundBufferSettings::SetBufferData

; 542  : 
; 543  :         DPF_INFO("Voice %x (%x) using mixbin %lu (address %x) as it's input", this, m_ahVoices[0], m_pSettings->m_dwInputMixBin, pvBufferData);
; 544  : 
; 545  :         //
; 546  :         // Complete the mapping operation
; 547  :         //
; 548  : 
; 549  :         MapBuffer();

  00073	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?MapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::MapBuffer
$L37355:

; 550  :     }
; 551  : 
; 552  :     DPF_LEAVE_VOID();
; 553  : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?MapEffectsBuffer@CMcpxBuffer@DirectSound@@IAEXXZ ENDP	; DirectSound::CMcpxBuffer::MapEffectsBuffer
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpvoice.h
DSOUND	ENDS
;	COMDAT ?SamplesToBytes@CMcpxVoiceClient@DirectSound@@IAEKK@Z
DSOUND	SEGMENT
_this$ = -4
_dwSamples$ = 8
?SamplesToBytes@CMcpxVoiceClient@DirectSound@@IAEKK@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::SamplesToBytes, COMDAT
; _this$ = ecx

; 256  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 257  : 	    if(WAVE_FORMAT_XBOX_ADPCM == m_pSettings->m_fmt.wFormatTag)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0000d	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00011	83 fa 69	 cmp	 edx, 105		; 00000069H
  00014	75 12		 jne	 SHORT $L34617

; 258  :         {
; 259  :             return (dwSamples >> 6) * m_pSettings->m_fmt.nBlockAlign;

  00016	8b 45 08	 mov	 eax, DWORD PTR _dwSamples$[ebp]
  00019	c1 e8 06	 shr	 eax, 6
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  00022	0f af 42 14	 imul	 eax, DWORD PTR [edx+20]
  00026	eb 0d		 jmp	 SHORT $L34616
$L34617:

; 260  :         }
; 261  :         else
; 262  :         {
; 263  :             ASSERT(WAVE_FORMAT_PCM == m_pSettings->m_fmt.wFormatTag);
; 264  :         
; 265  :             return dwSamples * m_pSettings->m_fmt.nBlockAlign;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0002e	8b 45 08	 mov	 eax, DWORD PTR _dwSamples$[ebp]
  00031	0f af 41 14	 imul	 eax, DWORD PTR [ecx+20]
$L34616:

; 266  :         }
; 267  :     }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?SamplesToBytes@CMcpxVoiceClient@DirectSound@@IAEKK@Z ENDP ; DirectSound::CMcpxVoiceClient::SamplesToBytes
DSOUND	ENDS
PUBLIC	??0CAutoIrql@DirectSound@@QAE@XZ		; DirectSound::CAutoIrql::CAutoIrql
PUBLIC	??1CAutoIrql@DirectSound@@QAE@XZ		; DirectSound::CAutoIrql::~CAutoIrql
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpbuf.cpp
;	COMDAT ?MapBuffer@CMcpxBuffer@DirectSound@@IAEXK@Z
DSOUND	SEGMENT
_this$ = -20
___AutoIrql$ = -16
_dwSgeIndex$ = -4
_dwOffset$ = 8
?MapBuffer@CMcpxBuffer@DirectSound@@IAEXK@Z PROC NEAR	; DirectSound::CMcpxBuffer::MapBuffer, COMDAT
; _this$ = ecx

; 579  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 
; 581  : #ifdef DEBUG
; 582  : 
; 583  :     DWORD                   dwAlignment;
; 584  : 
; 585  : #endif // DEBUG
; 586  : 
; 587  :     DWORD                   dwSgeIndex;
; 588  :     DWORD                   i;
; 589  :     
; 590  :     DPF_ENTER();
; 591  :     AutoIrql();

  00009	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 592  : 
; 593  :     ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_MIXIN));
; 594  :     ASSERT(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED);
; 595  : 
; 596  : #ifdef DEBUG
; 597  : 
; 598  :     //
; 599  :     // Validate that the buffer base address and offset are properly aligned
; 600  :     //
; 601  :     
; 602  :     if(WAVE_FORMAT_XBOX_ADPCM == m_pSettings->m_fmt.wFormatTag)
; 603  :     {
; 604  :         dwAlignment = 4;
; 605  :     }
; 606  :     else if(8 == m_pSettings->m_fmt.wBitsPerSample)
; 607  :     {
; 608  :         dwAlignment = 1;
; 609  :     }
; 610  :     else if(16 == m_pSettings->m_fmt.wBitsPerSample)
; 611  :     {
; 612  :         dwAlignment = 2;
; 613  :     }
; 614  :     else if((24 == m_pSettings->m_fmt.wBitsPerSample) || (32 == m_pSettings->m_fmt.wBitsPerSample))
; 615  :     {
; 616  :         dwAlignment = 4;
; 617  :     }
; 618  : 
; 619  :     ASSERT(!(((DWORD)m_pSettings->m_pvBufferData + dwOffset) % dwAlignment));
; 620  : 
; 621  : #endif // DEBUG
; 622  : 
; 623  :     //
; 624  :     // Calculate the proper base SGE index.  For FXIN buffers, it's the 
; 625  :     // reserved 2047th one that's already set up for us.  For standard
; 626  :     // buffers, calculate the proper index based on the offset from the
; 627  :     // start of the base page.
; 628  :     //
; 629  :     
; 630  :     ASSERT(m_pSettings->m_pvBufferData);
; 631  :     
; 632  :     if(m_pSettings->m_dwFlags & DSBCAPS_FXIN)

  00011	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  0001a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001d	81 e2 00 00 08
	00		 and	 edx, 524288		; 00080000H
  00023	85 d2		 test	 edx, edx
  00025	74 21		 je	 SHORT $L37368

; 633  :     {
; 634  :         ASSERT(!m_pSgeHeapEntry);
; 635  :         ASSERT(!dwOffset);
; 636  :         
; 637  :         dwOffset = BYTE_OFFSET(m_pSettings->m_pvBufferData);

  00027	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00030	8b 91 b4 00 00
	00		 mov	 edx, DWORD PTR [ecx+180]
  00036	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  0003c	89 55 08	 mov	 DWORD PTR _dwOffset$[ebp], edx

; 638  :         dwSgeIndex = MCPX_HW_MAX_BUFFER_PRDS - 1;

  0003f	c7 45 fc ff 07
	00 00		 mov	 DWORD PTR _dwSgeIndex$[ebp], 2047 ; 000007ffH

; 639  :     }
; 640  :     else

  00046	eb 46		 jmp	 SHORT $L37371
$L37368:

; 641  :     {
; 642  :         ASSERT(m_pSgeHeapEntry);
; 643  : 
; 644  :         dwSgeIndex = m_pSgeHeapEntry->nElement;

  00048	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  00051	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  00055	89 55 fc	 mov	 DWORD PTR _dwSgeIndex$[ebp], edx

; 645  :         
; 646  :         dwOffset += BYTE_OFFSET(m_pSettings->m_pvBufferData);

  00058	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00061	8b 91 b4 00 00
	00		 mov	 edx, DWORD PTR [ecx+180]
  00067	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  0006d	8b 45 08	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  00070	03 c2		 add	 eax, edx
  00072	89 45 08	 mov	 DWORD PTR _dwOffset$[ebp], eax

; 647  :         dwSgeIndex += dwOffset >> PAGE_SHIFT;

  00075	8b 4d 08	 mov	 ecx, DWORD PTR _dwOffset$[ebp]
  00078	c1 e9 0c	 shr	 ecx, 12			; 0000000cH
  0007b	8b 55 fc	 mov	 edx, DWORD PTR _dwSgeIndex$[ebp]
  0007e	03 d1		 add	 edx, ecx
  00080	89 55 fc	 mov	 DWORD PTR _dwSgeIndex$[ebp], edx

; 648  : 
; 649  :         ASSERT(dwSgeIndex < (DWORD)m_pSgeHeapEntry->nElement + (DWORD)m_pSgeHeapEntry->nLength);
; 650  :         
; 651  :         dwOffset &= PAGE_SIZE - 1;

  00083	8b 45 08	 mov	 eax, DWORD PTR _dwOffset$[ebp]
  00086	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0008b	89 45 08	 mov	 DWORD PTR _dwOffset$[ebp], eax
$L37371:

; 652  :     }
; 653  : 
; 654  :     //
; 655  :     // Calculate the buffer address register value.  The low word represents
; 656  :     // the page offset, while the high word represents the entry into the 
; 657  :     // SGE table.
; 658  :     //
; 659  : 
; 660  :     ASSERT(dwSgeIndex < MCPX_HW_MAX_BUFFER_PRDS);
; 661  :     ASSERT(dwOffset < PAGE_SIZE);
; 662  :     
; 663  :     m_dwBufferBase = (dwSgeIndex << PAGE_SHIFT) | dwOffset;

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _dwSgeIndex$[ebp]
  00091	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  00094	0b 4d 08	 or	 ecx, DWORD PTR _dwOffset$[ebp]
  00097	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0009a	89 8a 44 01 00
	00		 mov	 DWORD PTR [edx+324], ecx

; 664  : 
; 665  :     DPF_LEAVE_VOID();
; 666  : }

  000a0	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000a3	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 04 00	 ret	 4
?MapBuffer@CMcpxBuffer@DirectSound@@IAEXK@Z ENDP	; DirectSound::CMcpxBuffer::MapBuffer
DSOUND	ENDS
PUBLIC	??0CIrql@DirectSound@@QAE@XZ			; DirectSound::CIrql::CIrql
PUBLIC	?Raise@CIrql@DirectSound@@QAEXXZ		; DirectSound::CIrql::Raise
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\drvhlp.h
;	COMDAT ??0CAutoIrql@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CAutoIrql@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CAutoIrql::CAutoIrql, COMDAT
; _this$ = ecx

; 77   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CIrql@DirectSound@@QAE@XZ ; DirectSound::CIrql::CIrql

; 78   :         Raise();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?Raise@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Raise

; 79   :     }

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CAutoIrql@DirectSound@@QAE@XZ ENDP			; DirectSound::CAutoIrql::CAutoIrql
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??0CIrql@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CIrql@DirectSound@@QAE@XZ PROC NEAR			; DirectSound::CIrql::CIrql, COMDAT
; _this$ = ecx

; 40   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   :         m_fRaised = FALSE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 42   :     }

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0CIrql@DirectSound@@QAE@XZ ENDP			; DirectSound::CIrql::CIrql
DSOUND	ENDS
EXTRN	__imp_@KfRaiseIrql@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Raise@CIrql@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Raise@CIrql@DirectSound@@QAEXXZ PROC NEAR		; DirectSound::CIrql::Raise, COMDAT
; _this$ = ecx

; 45   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 46   :         if(m_fRaised = (KeGetCurrentIrql() < DISPATCH_LEVEL))

  00007	e8 00 00 00 00	 call	 _KeGetCurrentIrql@0
  0000c	0f b6 c0	 movzx	 eax, al
  0000f	33 c9		 xor	 ecx, ecx
  00011	83 f8 02	 cmp	 eax, 2
  00014	0f 9c c1	 setl	 cl
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00024	74 0d		 je	 SHORT $L30119

; 47   :         {
; 48   :             m_irql = KfRaiseIrql(DISPATCH_LEVEL);

  00026	b1 02		 mov	 cl, 2
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfRaiseIrql@4
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	88 01		 mov	 BYTE PTR [ecx], al
$L30119:

; 49   :         }
; 50   :     }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?Raise@CIrql@DirectSound@@QAEXXZ ENDP			; DirectSound::CIrql::Raise
DSOUND	ENDS
PUBLIC	?Lower@CIrql@DirectSound@@QAEXXZ		; DirectSound::CIrql::Lower
; Function compile flags: /Odt
;	COMDAT ??1CAutoIrql@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CAutoIrql@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CAutoIrql::~CAutoIrql, COMDAT
; _this$ = ecx

; 82   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 83   :         Lower();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower

; 84   :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CAutoIrql@DirectSound@@QAE@XZ ENDP			; DirectSound::CAutoIrql::~CAutoIrql
DSOUND	ENDS
EXTRN	__imp_@KfLowerIrql@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Lower@CIrql@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Lower@CIrql@DirectSound@@QAEXXZ PROC NEAR		; DirectSound::CIrql::Lower, COMDAT
; _this$ = ecx

; 53   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 54   :         if(m_fRaised)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 15		 je	 SHORT $L30124

; 55   :         {
; 56   :             KfLowerIrql(m_irql);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8a 09		 mov	 cl, BYTE PTR [ecx]
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfLowerIrql@4

; 57   :             m_fRaised = FALSE;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$L30124:

; 58   :         }
; 59   :     }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?Lower@CIrql@DirectSound@@QAEXXZ ENDP			; DirectSound::CIrql::Lower
DSOUND	ENDS
PUBLIC	?Free@CMcpxBufferSgeHeap@DirectSound@@QAEXPAUSGEHEAPRUNMARKER@@@Z ; DirectSound::CMcpxBufferSgeHeap::Free
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpbuf.cpp
;	COMDAT ?UnmapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -4
?UnmapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ PROC NEAR	; DirectSound::CMcpxBuffer::UnmapBuffer, COMDAT
; _this$ = ecx

; 692  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 693  :     DPF_ENTER();
; 694  : 
; 695  :     //
; 696  :     // Make sure the voice is stopped
; 697  :     //
; 698  : 
; 699  :     Stop();

  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?Stop@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::Stop

; 700  :     WaitForVoiceOff();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?WaitForVoiceOff@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::WaitForVoiceOff

; 701  : 
; 702  :     //
; 703  :     // Unmap the buffer
; 704  :     //
; 705  : 
; 706  :     if(m_dwStatus & MCPX_VOICESTATUS_BUFFERMAPPED)

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00020	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  00026	85 c9		 test	 ecx, ecx
  00028	74 41		 je	 SHORT $L37377

; 707  :     {
; 708  :         //
; 709  :         // Clear the status bit
; 710  :         //
; 711  : 
; 712  :         and(&m_dwStatus, ~MCPX_VOICESTATUS_BUFFERMAPPED);

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	83 c1 12	 add	 ecx, 18			; 00000012H
  00030	ba ff fe 00 00	 mov	 edx, 65279		; 0000feffH
  00035	e8 00 00 00 00	 call	 ?and@@YIXPCGG@Z		; and

; 713  :         
; 714  :         //
; 715  :         // Release the SGE
; 716  :         //
; 717  : 
; 718  :         if(m_pSgeHeapEntry)

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	83 ba 94 00 00
	00 00		 cmp	 DWORD PTR [edx+148], 0
  00044	74 25		 je	 SHORT $L37377

; 719  :         {
; 720  :             m_pMcpxApu->m_SgeHeap.Free(m_pSgeHeapEntry);

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  0004f	51		 push	 ecx
  00050	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00056	83 c1 64	 add	 ecx, 100		; 00000064H
  00059	e8 00 00 00 00	 call	 ?Free@CMcpxBufferSgeHeap@DirectSound@@QAEXPAUSGEHEAPRUNMARKER@@@Z ; DirectSound::CMcpxBufferSgeHeap::Free

; 721  :             m_pSgeHeapEntry = NULL;

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00061	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+148], 0
$L37377:

; 722  :         }
; 723  :     }
; 724  :     else
; 725  :     {
; 726  :         ASSERT(!(m_dwStatus & ~MCPX_VOICESTATUS_ALLOCATED));
; 727  :     }
; 728  : 
; 729  :     DPF_LEAVE_VOID();
; 730  : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?UnmapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ ENDP	; DirectSound::CMcpxBuffer::UnmapBuffer
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?Play@CMcpxBuffer@DirectSound@@QAEJ_JK@Z
DSOUND	SEGMENT
_this$ = -12
_hr$ = -8
_fDeferred$ = -4
_rtTimeStamp$ = 8
_dwFlags$ = 16
?Play@CMcpxBuffer@DirectSound@@QAEJ_JK@Z PROC NEAR	; DirectSound::CMcpxBuffer::Play, COMDAT
; _this$ = ecx

; 758  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 759  :     BOOL                    fDeferred   = FALSE;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fDeferred$[ebp], 0

; 760  :     HRESULT                 hr          = DS_OK;

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 761  : 
; 762  :     DPF_ENTER();
; 763  : 
; 764  :     if(rtTimeStamp)

  00017	8b 45 08	 mov	 eax, DWORD PTR _rtTimeStamp$[ebp]
  0001a	0b 45 0c	 or	 eax, DWORD PTR _rtTimeStamp$[ebp+4]
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $L37389

; 765  :     {
; 766  :         fDeferred = ScheduleDeferredCommand(MCPX_DEFERREDCMD_BUFFER_PLAY, rtTimeStamp, dwFlags);

  00021	8b 4d 10	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 0c	 mov	 edx, DWORD PTR _rtTimeStamp$[ebp+4]
  00028	52		 push	 edx
  00029	8b 45 08	 mov	 eax, DWORD PTR _rtTimeStamp$[ebp]
  0002c	50		 push	 eax
  0002d	6a 03		 push	 3
  0002f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	ff 52 18	 call	 DWORD PTR [edx+24]
  0003a	89 45 fc	 mov	 DWORD PTR _fDeferred$[ebp], eax
$L37389:

; 767  :     }
; 768  : 
; 769  :     if(!fDeferred)

  0003d	83 7d fc 00	 cmp	 DWORD PTR _fDeferred$[ebp], 0
  00041	75 0f		 jne	 SHORT $L37390

; 770  :     {
; 771  :         hr = Play(dwFlags);

  00043	8b 45 10	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00046	50		 push	 eax
  00047	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?Play@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::Play
  0004f	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L37390:

; 772  :     }
; 773  : 
; 774  :     DPF_LEAVE_HRESULT(hr);
; 775  : 
; 776  :     return hr;

  00052	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 777  : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
?Play@CMcpxBuffer@DirectSound@@QAEJ_JK@Z ENDP		; DirectSound::CMcpxBuffer::Play
DSOUND	ENDS
PUBLIC	?ActivateVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::ActivateVoice
PUBLIC	?PlayFromCurrent@CMcpxBuffer@DirectSound@@IAEXK@Z ; DirectSound::CMcpxBuffer::PlayFromCurrent
PUBLIC	?PlayFromPosition@CMcpxBuffer@DirectSound@@IAEXKK@Z ; DirectSound::CMcpxBuffer::PlayFromPosition
; Function compile flags: /Odt
;	COMDAT ?Play@CMcpxBuffer@DirectSound@@QAEJK@Z
DSOUND	SEGMENT
_this$ = -12
_hr$ = -8
_dwCurrentBufferOffset$ = -4
_dwFlags$ = 8
?Play@CMcpxBuffer@DirectSound@@QAEJK@Z PROC NEAR	; DirectSound::CMcpxBuffer::Play, COMDAT
; _this$ = ecx

; 803  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 804  :     DWORD                   dwCurrentBufferOffset;
; 805  :     HRESULT                 hr;
; 806  :     
; 807  :     DPF_ENTER();
; 808  : 
; 809  :     //
; 810  :     // Make sure resources are allocated
; 811  :     //
; 812  : 
; 813  :     hr = AllocateBufferResources();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?AllocateBufferResources@CMcpxBuffer@DirectSound@@IAEJXZ ; DirectSound::CMcpxBuffer::AllocateBufferResources
  00011	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 814  : 
; 815  :     //
; 816  :     // Handle the different modes of playing the buffer:  normal, 
; 817  :     // extra-crispy... no, wait; normal, non-zero position, mixin.
; 818  :     //
; 819  : 
; 820  :     if(SUCCEEDED(hr))

  00014	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00018	0f 8c a6 00 00
	00		 jl	 $L37398

; 821  :     {
; 822  :         if(m_pSettings->m_dwFlags & DSBCAPS_MIXIN)

  0001e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00027	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002a	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  00030	85 d2		 test	 edx, edx
  00032	74 0d		 je	 SHORT $L37399

; 823  :         {
; 824  :             //
; 825  :             // Just activate the voice.  The hardware takes care of the rest
; 826  :             //
; 827  :             
; 828  :             ActivateVoice();

  00034	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?ActivateVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::ActivateVoice

; 829  :         }
; 830  :         else 

  0003c	e9 83 00 00 00	 jmp	 $L37398
$L37399:

; 831  :         {
; 832  :             //
; 833  :             // Determine where to start playback from
; 834  :             //
; 835  :             
; 836  :             if(!(dwFlags & DSBPLAY_FROMSTART) && !(m_dwStatus & MCPX_VOICESTATUS_ACTIVE))

  00041	8b 45 08	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00044	83 e0 02	 and	 eax, 2
  00047	85 c0		 test	 eax, eax
  00049	75 1c		 jne	 SHORT $L37401
  0004b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00052	83 e2 02	 and	 edx, 2
  00055	85 d2		 test	 edx, edx
  00057	75 0e		 jne	 SHORT $L37401

; 837  :             {
; 838  :                 dwCurrentBufferOffset = m_dwCachedPlayCursor;

  00059	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 88 38 01 00
	00		 mov	 ecx, DWORD PTR [eax+312]
  00062	89 4d fc	 mov	 DWORD PTR _dwCurrentBufferOffset$[ebp], ecx

; 839  :             }
; 840  :             else

  00065	eb 07		 jmp	 SHORT $L37402
$L37401:

; 841  :             {
; 842  :                 dwCurrentBufferOffset = 0;

  00067	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwCurrentBufferOffset$[ebp], 0
$L37402:

; 843  :             }
; 844  : 
; 845  :             m_dwCachedPlayCursor = 0;

  0006e	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00071	c7 82 38 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+312], 0

; 846  : 
; 847  :             //
; 848  :             // Hand off to the proper play handler
; 849  :             //
; 850  :             
; 851  :             if(dwCurrentBufferOffset)

  0007b	83 7d fc 00	 cmp	 DWORD PTR _dwCurrentBufferOffset$[ebp], 0
  0007f	74 12		 je	 SHORT $L37403

; 852  :             {
; 853  :                 PlayFromPosition(dwCurrentBufferOffset, dwFlags);

  00081	8b 45 08	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00084	50		 push	 eax
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _dwCurrentBufferOffset$[ebp]
  00088	51		 push	 ecx
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	e8 00 00 00 00	 call	 ?PlayFromPosition@CMcpxBuffer@DirectSound@@IAEXKK@Z ; DirectSound::CMcpxBuffer::PlayFromPosition

; 854  :             }
; 855  :             else

  00091	eb 0c		 jmp	 SHORT $L37404
$L37403:

; 856  :             {
; 857  :                 PlayFromCurrent(dwFlags);

  00093	8b 55 08	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00096	52		 push	 edx
  00097	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?PlayFromCurrent@CMcpxBuffer@DirectSound@@IAEXK@Z ; DirectSound::CMcpxBuffer::PlayFromCurrent
$L37404:

; 858  :             }
; 859  : 
; 860  :             //
; 861  :             // Register for position notification callbacks
; 862  :             //
; 863  : 
; 864  :             if(m_pSettings->m_dwNotifyCount)

  0009f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  000a8	83 b9 d4 00 00
	00 00		 cmp	 DWORD PTR [ecx+212], 0
  000af	74 13		 je	 SHORT $L37398

; 865  :             {
; 866  :                 ScheduleDeferredCommand(MCPX_DEFERREDCMD_BUFFER_POSITIONDELTA, 0, 0);

  000b1	6a 00		 push	 0
  000b3	6a 00		 push	 0
  000b5	6a 00		 push	 0
  000b7	6a 02		 push	 2
  000b9	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000bc	8b 02		 mov	 eax, DWORD PTR [edx]
  000be	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	ff 50 18	 call	 DWORD PTR [eax+24]
$L37398:

; 867  :             }
; 868  :         }
; 869  :     }
; 870  : 
; 871  :     DPF_LEAVE_HRESULT(hr);
; 872  : 
; 873  :     return hr;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 874  : }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c2 04 00	 ret	 4
?Play@CMcpxBuffer@DirectSound@@QAEJK@Z ENDP		; DirectSound::CMcpxBuffer::Play
DSOUND	ENDS
PUBLIC	?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::GetVoiceCfgFMT
PUBLIC	?BytesToSamples@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::BytesToSamples
; Function compile flags: /Odt
;	COMDAT ?PlayFromCurrent@CMcpxBuffer@DirectSound@@IAEXK@Z
DSOUND	SEGMENT
_this$ = -32
_dwIncrement$ = -28
_dwEndBufferOffset$ = -24
_dwLoopBackOffset$ = -16
_i$ = -12
_irql$ = -8
_dwFlags$ = 8
?PlayFromCurrent@CMcpxBuffer@DirectSound@@IAEXK@Z PROC NEAR ; DirectSound::CMcpxBuffer::PlayFromCurrent, COMDAT
; _this$ = ecx

; 900  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 901  :     DWORD                   dwLoopBackOffset;
; 902  :     DWORD                   dwEndBufferOffset;
; 903  :     DWORD                   dwIncrement;
; 904  :     CIrql                   irql;

  00009	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CIrql@DirectSound@@QAE@XZ ; DirectSound::CIrql::CIrql

; 905  :     HRESULT                 hr;
; 906  :     DWORD                   i;
; 907  :     
; 908  :     DPF_ENTER();
; 909  : 
; 910  :     ASSERT(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED);
; 911  :     ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_MIXIN));
; 912  : 
; 913  :     //
; 914  :     // Raise IRQL for synchronization
; 915  :     //
; 916  : 
; 917  :     irql.Raise();

  00011	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00014	e8 00 00 00 00	 call	 ?Raise@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Raise

; 918  : 
; 919  :     //
; 920  :     // Calculate the proper starting and ending buffer offsets as well
; 921  :     // as the proper loop region
; 922  :     //
; 923  : 
; 924  :     if(dwFlags & DSBPLAY_LOOPING)

  00019	8b 45 08	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  0001c	83 e0 01	 and	 eax, 1
  0001f	85 c0		 test	 eax, eax
  00021	74 6f		 je	 SHORT $L37416

; 925  :     {
; 926  :         m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP_ON, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP);

  00023	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00029	81 e2 ff ff ff
	fd		 and	 edx, -33554433		; fdffffffH
  0002f	81 ca 00 00 00
	02		 or	 edx, 33554432		; 02000000H
  00035	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00038	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 927  : 
; 928  :         dwLoopBackOffset = BytesToSamples(m_pSettings->m_dwLoopStart);

  0003b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00044	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  0004a	50		 push	 eax
  0004b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?BytesToSamples@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::BytesToSamples
  00053	89 45 f0	 mov	 DWORD PTR _dwLoopBackOffset$[ebp], eax

; 929  :         dwEndBufferOffset = BytesToSamples(m_pSettings->m_dwLoopStart + m_pSettings->m_dwLoopLength);

  00056	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  0005f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00068	8b 92 c4 00 00
	00		 mov	 edx, DWORD PTR [edx+196]
  0006e	03 91 c8 00 00
	00		 add	 edx, DWORD PTR [ecx+200]
  00074	52		 push	 edx
  00075	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?BytesToSamples@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::BytesToSamples
  0007d	89 45 e8	 mov	 DWORD PTR _dwEndBufferOffset$[ebp], eax

; 930  : 
; 931  :         or(&m_dwStatus, MCPX_VOICESTATUS_LOOPING);

  00080	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	83 c1 12	 add	 ecx, 18			; 00000012H
  00086	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  0008b	e8 00 00 00 00	 call	 ?or@@YIXPCGG@Z		; or

; 932  :     }
; 933  :     else

  00090	eb 44		 jmp	 SHORT $L37418
$L37416:

; 934  :     {
; 935  :         m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP_OFF, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP);

  00092	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00095	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00098	81 e1 ff ff ff
	fd		 and	 ecx, -33554433		; fdffffffH
  0009e	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000a1	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 936  : 
; 937  :         dwLoopBackOffset = 0;

  000a4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwLoopBackOffset$[ebp], 0

; 938  :         dwEndBufferOffset = BytesToSamples(m_pSettings->m_dwPlayLength);

  000ab	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  000b4	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  000ba	52		 push	 edx
  000bb	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?BytesToSamples@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::BytesToSamples
  000c3	89 45 e8	 mov	 DWORD PTR _dwEndBufferOffset$[ebp], eax

; 939  : 
; 940  :         and(&m_dwStatus, ~MCPX_VOICESTATUS_LOOPING);

  000c6	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	83 c1 12	 add	 ecx, 18			; 00000012H
  000cc	ba ff fd 00 00	 mov	 edx, 65023		; 0000fdffH
  000d1	e8 00 00 00 00	 call	 ?and@@YIXPCGG@Z		; and
$L37418:

; 941  :     }
; 942  : 
; 943  :     ASSERT(dwEndBufferOffset > 1);
; 944  :     dwEndBufferOffset--;

  000d6	8b 45 e8	 mov	 eax, DWORD PTR _dwEndBufferOffset$[ebp]
  000d9	83 e8 01	 sub	 eax, 1
  000dc	89 45 e8	 mov	 DWORD PTR _dwEndBufferOffset$[ebp], eax

; 945  : 
; 946  :     dwIncrement = m_pSettings->m_fmt.wBitsPerSample * 2 / 8;

  000df	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  000e8	0f b6 42 0f	 movzx	 eax, BYTE PTR [edx+15]
  000ec	d1 e0		 shl	 eax, 1
  000ee	99		 cdq
  000ef	83 e2 07	 and	 edx, 7
  000f2	03 c2		 add	 eax, edx
  000f4	c1 f8 03	 sar	 eax, 3
  000f7	89 45 e4	 mov	 DWORD PTR _dwIncrement$[ebp], eax
$L37421:

; 947  : 
; 948  :     MCPX_CHECK_VOICE_FIFO(8 * m_bVoiceCount);

  000fa	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000ff	8b 88 00 00 82
	fe		 mov	 ecx, DWORD PTR [eax-25034752]
  00105	c1 e9 02	 shr	 ecx, 2
  00108	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0010b	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  0010f	c1 e0 03	 shl	 eax, 3
  00112	3b c8		 cmp	 ecx, eax
  00114	73 02		 jae	 SHORT $L37422
  00116	eb e2		 jmp	 SHORT $L37421
$L37422:

; 949  : 
; 950  :     for(i = 0; i < m_bVoiceCount; i++)

  00118	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0011f	eb 09		 jmp	 SHORT $L37425
$L37426:
  00121	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00124	83 c1 01	 add	 ecx, 1
  00127	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$L37425:
  0012a	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0012d	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  00131	39 45 f4	 cmp	 DWORD PTR _i$[ebp], eax
  00134	0f 83 a0 00 00
	00		 jae	 $L37427

; 951  :     {
; 952  :         MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  0013a	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0013d	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00140	0f b7 44 4a 0c	 movzx	 eax, WORD PTR [edx+ecx*2+12]
  00145	b9 f8 02 00 00	 mov	 ecx, 760		; 000002f8H
  0014a	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 953  :         MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);

  00150	ba fc 02 00 00	 mov	 edx, 764		; 000002fcH
  00155	c7 82 00 00 82
	fe 01 00 00 00	 mov	 DWORD PTR [edx-25034752], 1

; 954  :         MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));

  0015f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00162	50		 push	 eax
  00163	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00166	e8 00 00 00 00	 call	 ?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::GetVoiceCfgFMT
  0016b	b9 04 03 00 00	 mov	 ecx, 772		; 00000304H
  00170	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 955  :         MCPX_VOICE_WRITE(SetVoiceCfgBufBase, m_dwBufferBase + (dwIncrement * i));

  00176	8b 55 e4	 mov	 edx, DWORD PTR _dwIncrement$[ebp]
  00179	0f af 55 f4	 imul	 edx, DWORD PTR _i$[ebp]
  0017d	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00180	03 90 44 01 00
	00		 add	 edx, DWORD PTR [eax+324]
  00186	b9 a0 03 00 00	 mov	 ecx, 928		; 000003a0H
  0018b	89 91 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], edx

; 956  :         MCPX_VOICE_WRITE(SetVoiceCfgBufEBO, dwEndBufferOffset);

  00191	ba dc 03 00 00	 mov	 edx, 988		; 000003dcH
  00196	8b 45 e8	 mov	 eax, DWORD PTR _dwEndBufferOffset$[ebp]
  00199	89 82 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], eax

; 957  :         MCPX_VOICE_WRITE(SetVoiceCfgBufLBO, dwLoopBackOffset);

  0019f	b9 a4 03 00 00	 mov	 ecx, 932		; 000003a4H
  001a4	8b 55 f0	 mov	 edx, DWORD PTR _dwLoopBackOffset$[ebp]
  001a7	89 91 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], edx

; 958  : 
; 959  :         if(dwFlags & DSBPLAY_FROMSTART)

  001ad	8b 45 08	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  001b0	83 e0 02	 and	 eax, 2
  001b3	85 c0		 test	 eax, eax
  001b5	74 0f		 je	 SHORT $L37440

; 960  :         {
; 961  :             MCPX_VOICE_WRITE(SetVoiceBufCBO, 0);

  001b7	b9 d8 03 00 00	 mov	 ecx, 984		; 000003d8H
  001bc	c7 81 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [ecx-25034752], 0
$L37440:

; 962  :         }
; 963  : 
; 964  :         MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);

  001c6	ba fc 02 00 00	 mov	 edx, 764		; 000002fcH
  001cb	c7 82 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [edx-25034752], 0

; 965  :     }

  001d5	e9 47 ff ff ff	 jmp	 $L37426
$L37427:

; 966  : 
; 967  :     // 
; 968  :     // Lower IRQL
; 969  :     //
; 970  : 
; 971  :     irql.Lower();

  001da	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  001dd	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower

; 972  : 
; 973  :     //
; 974  :     // Activate the voice
; 975  :     //
; 976  : 
; 977  :     ActivateVoice();

  001e2	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e5	e8 00 00 00 00	 call	 ?ActivateVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::ActivateVoice

; 978  : 
; 979  :     //
; 980  :     // By the time we get to this point, any pending SSL or VoiceOff interrupts
; 981  :     // should have happened.  Unschedule any pending RELEASERESOURCES tasks 
; 982  :     // that may have been scheduled.
; 983  :     //
; 984  :     // BUGBUG: unless we're at raised IRQL through this whole function, such
; 985  :     // as when the dmusic sequencer calls us or a deferred Play command happens.
; 986  :     //
; 987  : 
; 988  : #pragma TODO("What impact does this have?")
; 989  : 
; 990  :     RemoveDeferredCommand(MCPX_DEFERREDCMD_BUFFER_RELEASERESOURCES);

  001ea	6a 01		 push	 1
  001ec	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  001ef	8b 10		 mov	 edx, DWORD PTR [eax]
  001f1	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  001f4	ff 52 1c	 call	 DWORD PTR [edx+28]

; 991  : 
; 992  :     DPF_LEAVE_VOID();
; 993  : }

  001f7	8b e5		 mov	 esp, ebp
  001f9	5d		 pop	 ebp
  001fa	c2 04 00	 ret	 4
?PlayFromCurrent@CMcpxBuffer@DirectSound@@IAEXK@Z ENDP	; DirectSound::CMcpxBuffer::PlayFromCurrent
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpvoice.h
DSOUND	ENDS
;	COMDAT ?BytesToSamples@CMcpxVoiceClient@DirectSound@@IAEKK@Z
DSOUND	SEGMENT
_this$ = -4
_dwBytes$ = 8
?BytesToSamples@CMcpxVoiceClient@DirectSound@@IAEKK@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::BytesToSamples, COMDAT
; _this$ = ecx

; 242  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 243  :         if(WAVE_FORMAT_XBOX_ADPCM == m_pSettings->m_fmt.wFormatTag)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0000d	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00011	83 fa 69	 cmp	 edx, 105		; 00000069H
  00014	75 13		 jne	 SHORT $L34611

; 244  :         {
; 245  :             return (dwBytes / m_pSettings->m_fmt.nBlockAlign) << 6;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0001c	8b 45 08	 mov	 eax, DWORD PTR _dwBytes$[ebp]
  0001f	33 d2		 xor	 edx, edx
  00021	f7 71 14	 div	 DWORD PTR [ecx+20]
  00024	c1 e0 06	 shl	 eax, 6
  00027	eb 0e		 jmp	 SHORT $L34610
$L34611:

; 246  :         }
; 247  :         else
; 248  :         {
; 249  :             ASSERT(WAVE_FORMAT_PCM == m_pSettings->m_fmt.wFormatTag);
; 250  :         
; 251  :             return dwBytes / m_pSettings->m_fmt.nBlockAlign;

  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 4a 78	 mov	 ecx, DWORD PTR [edx+120]
  0002f	8b 45 08	 mov	 eax, DWORD PTR _dwBytes$[ebp]
  00032	33 d2		 xor	 edx, edx
  00034	f7 71 14	 div	 DWORD PTR [ecx+20]
$L34610:

; 252  :         }
; 253  :     }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?BytesToSamples@CMcpxVoiceClient@DirectSound@@IAEKK@Z ENDP ; DirectSound::CMcpxVoiceClient::BytesToSamples
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z
DSOUND	SEGMENT
_this$ = -8
_dwCfgFMT$ = -4
_dwVoiceIndex$ = 8
?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::GetVoiceCfgFMT, COMDAT
; _this$ = ecx

; 270  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 271  :         DWORD                   dwCfgFMT    = m_RegCache.CfgFMT;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0000f	89 4d fc	 mov	 DWORD PTR _dwCfgFMT$[ebp], ecx

; 272  : 
; 273  :         if(dwVoiceIndex)

  00012	83 7d 08 00	 cmp	 DWORD PTR _dwVoiceIndex$[ebp], 0
  00016	74 0c		 je	 SHORT $L34624

; 274  :         {
; 275  :             dwCfgFMT |= MCPX_MAKE_REG_VALUE(NV_PAVS_VOICE_CFG_FMT_LINKED_VOICE_ON, NV1BA0_PIO_SET_VOICE_CFG_FMT_LINKED_VOICE);

  00018	8b 55 fc	 mov	 edx, DWORD PTR _dwCfgFMT$[ebp]
  0001b	81 ca 00 00 40
	00		 or	 edx, 4194304		; 00400000H
  00021	89 55 fc	 mov	 DWORD PTR _dwCfgFMT$[ebp], edx
$L34624:

; 276  :         }
; 277  : 
; 278  :         return dwCfgFMT;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _dwCfgFMT$[ebp]

; 279  :     }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z ENDP ; DirectSound::CMcpxVoiceClient::GetVoiceCfgFMT
DSOUND	ENDS
PUBLIC	?ConvertVolumeValues@CMcpxVoiceClient@DirectSound@@IAEXPAUMCPX_VOICE_VOLUME@@@Z ; DirectSound::CMcpxVoiceClient::ConvertVolumeValues
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpbuf.cpp
;	COMDAT ?PlayFromPosition@CMcpxBuffer@DirectSound@@IAEXKK@Z
DSOUND	SEGMENT
_this$ = -56
_Volume$ = -52
_i$ = -16
_dwState$ = -12
_irql$ = -8
_dwPosition$ = 8
_dwFlags$ = 12
?PlayFromPosition@CMcpxBuffer@DirectSound@@IAEXKK@Z PROC NEAR ; DirectSound::CMcpxBuffer::PlayFromPosition, COMDAT
; _this$ = ecx

; 1021 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 1022 :     MCPX_VOICE_VOLUME       Volume;
; 1023 :     DWORD                   dwState;
; 1024 :     CIrql                   irql;

  00009	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CIrql@DirectSound@@QAE@XZ ; DirectSound::CIrql::CIrql

; 1025 :     DWORD                   i;
; 1026 :     
; 1027 :     DPF_ENTER();
; 1028 : 
; 1029 :     ASSERT((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ALLOCATED);
; 1030 :     ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_MIXIN));
; 1031 :     ASSERT(!(dwFlags & DSBPLAY_FROMSTART));
; 1032 :     ASSERT(dwPosition);
; 1033 : 
; 1034 :     //
; 1035 :     // The hardware won't let us set the CBO until it's processed the first
; 1036 :     // frame.  Set the buffer up so it plays the first 32 samples in a loop
; 1037 :     // until the NEW_VOICE bit is cleared.
; 1038 :     //
; 1039 : 
; 1040 :     memset(&Volume, 0xFF, sizeof(Volume));

  00011	6a 24		 push	 36			; 00000024H
  00013	68 ff 00 00 00	 push	 255			; 000000ffH
  00018	8d 45 cc	 lea	 eax, DWORD PTR _Volume$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memset
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1041 : 
; 1042 :     irql.Raise();

  00024	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00027	e8 00 00 00 00	 call	 ?Raise@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Raise

; 1043 : 
; 1044 :     m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP_ON, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP);

  0002c	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00032	81 e2 ff ff ff
	fd		 and	 edx, -33554433		; fdffffffH
  00038	81 ca 00 00 00
	02		 or	 edx, 33554432		; 02000000H
  0003e	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00041	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L37456:

; 1045 : 
; 1046 :     MCPX_CHECK_VOICE_FIFO(10 * m_bVoiceCount);

  00044	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00049	8b 91 00 00 82
	fe		 mov	 edx, DWORD PTR [ecx-25034752]
  0004f	c1 ea 02	 shr	 edx, 2
  00052	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00055	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  00059	6b c9 0a	 imul	 ecx, 10			; 0000000aH
  0005c	3b d1		 cmp	 edx, ecx
  0005e	73 02		 jae	 SHORT $L37457
  00060	eb e2		 jmp	 SHORT $L37456
$L37457:

; 1047 : 
; 1048 :     for(i = 0; i < m_bVoiceCount; i++)

  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00069	eb 09		 jmp	 SHORT $L37460
$L37461:
  0006b	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0006e	83 c2 01	 add	 edx, 1
  00071	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx
$L37460:
  00074	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00077	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  0007b	39 4d f0	 cmp	 DWORD PTR _i$[ebp], ecx
  0007e	0f 83 b8 00 00
	00		 jae	 $L37462

; 1049 :     {
; 1050 :         MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  00084	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00087	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	0f b7 4c 50 0c	 movzx	 ecx, WORD PTR [eax+edx*2+12]
  0008f	ba f8 02 00 00	 mov	 edx, 760		; 000002f8H
  00094	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 1051 :         MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);

  0009a	b8 fc 02 00 00	 mov	 eax, 764		; 000002fcH
  0009f	c7 80 00 00 82
	fe 01 00 00 00	 mov	 DWORD PTR [eax-25034752], 1

; 1052 :         MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));

  000a9	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  000ac	51		 push	 ecx
  000ad	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	e8 00 00 00 00	 call	 ?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::GetVoiceCfgFMT
  000b5	ba 04 03 00 00	 mov	 edx, 772		; 00000304H
  000ba	89 82 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], eax

; 1053 :         MCPX_VOICE_WRITE(SetVoiceTarVOLA, Volume.TarVOLA[i]);

  000c0	b8 60 03 00 00	 mov	 eax, 864		; 00000360H
  000c5	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  000c8	8b 54 8d cc	 mov	 edx, DWORD PTR _Volume$[ebp+ecx*4]
  000cc	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 1054 :         MCPX_VOICE_WRITE(SetVoiceTarVOLB, Volume.TarVOLB[i]);

  000d2	b8 64 03 00 00	 mov	 eax, 868		; 00000364H
  000d7	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  000da	8b 54 8d d8	 mov	 edx, DWORD PTR _Volume$[ebp+ecx*4+12]
  000de	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 1055 :         MCPX_VOICE_WRITE(SetVoiceTarVOLC, Volume.TarVOLC[i]);

  000e4	b8 68 03 00 00	 mov	 eax, 872		; 00000368H
  000e9	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  000ec	8b 54 8d e4	 mov	 edx, DWORD PTR _Volume$[ebp+ecx*4+24]
  000f0	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 1056 :         MCPX_VOICE_WRITE(SetVoiceCfgBufBase, m_dwBufferBase);

  000f6	b8 a0 03 00 00	 mov	 eax, 928		; 000003a0H
  000fb	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	8b 91 44 01 00
	00		 mov	 edx, DWORD PTR [ecx+324]
  00104	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 1057 :         MCPX_VOICE_WRITE(SetVoiceCfgBufEBO, MCPX_HW_FRAME_SIZE_SAMPLES);

  0010a	b8 dc 03 00 00	 mov	 eax, 988		; 000003dcH
  0010f	c7 80 00 00 82
	fe 20 00 00 00	 mov	 DWORD PTR [eax-25034752], 32 ; 00000020H

; 1058 :         MCPX_VOICE_WRITE(SetVoiceCfgBufLBO, 0);

  00119	b9 a4 03 00 00	 mov	 ecx, 932		; 000003a4H
  0011e	c7 81 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [ecx-25034752], 0

; 1059 :         MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);

  00128	ba fc 02 00 00	 mov	 edx, 764		; 000002fcH
  0012d	c7 82 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [edx-25034752], 0

; 1060 :     }

  00137	e9 2f ff ff ff	 jmp	 $L37461
$L37462:

; 1061 : 
; 1062 :     irql.Lower();

  0013c	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  0013f	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower

; 1063 : 
; 1064 :     ActivateVoice();

  00144	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00147	e8 00 00 00 00	 call	 ?ActivateVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::ActivateVoice
$L37483:

; 1065 : 
; 1066 :     //
; 1067 :     // Wait for the NEW_VOICE bit to clear so we know the first frame of audio
; 1068 :     // has been processed
; 1069 :     //
; 1070 : 
; 1071 :     do
; 1072 :     {
; 1073 :         MCPX_VOICE_STRUCT_READ(m_ahVoices[m_bVoiceCount - 1], NV_PAVS_VOICE_PAR_STATE, &dwState);

  0014c	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0014f	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  00153	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00156	0f b7 44 4a 0a	 movzx	 eax, WORD PTR [edx+ecx*2+10]
  0015b	c1 e0 07	 shl	 eax, 7
  0015e	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+48
  00164	8b 54 01 54	 mov	 edx, DWORD PTR [ecx+eax+84]
  00168	89 55 f4	 mov	 DWORD PTR _dwState$[ebp], edx

; 1074 :     }
; 1075 :     while(MCPX_GET_REG_VALUE(dwState, NV_PAVS_VOICE_PAR_STATE_NEW_VOICE));

  0016b	8b 45 f4	 mov	 eax, DWORD PTR _dwState$[ebp]
  0016e	c1 e8 14	 shr	 eax, 20			; 00000014H
  00171	83 e0 01	 and	 eax, 1
  00174	85 c0		 test	 eax, eax
  00176	75 d4		 jne	 SHORT $L37483

; 1076 : 
; 1077 :     //
; 1078 :     // Play the buffer properly
; 1079 :     //
; 1080 : 
; 1081 :     PlayFromCurrent(dwFlags);

  00178	8b 4d 0c	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  0017b	51		 push	 ecx
  0017c	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017f	e8 00 00 00 00	 call	 ?PlayFromCurrent@CMcpxBuffer@DirectSound@@IAEXK@Z ; DirectSound::CMcpxBuffer::PlayFromCurrent

; 1082 : 
; 1083 :     //
; 1084 :     // Set the cursor position and restore the volume
; 1085 :     //
; 1086 : 
; 1087 :     irql.Raise();

  00184	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00187	e8 00 00 00 00	 call	 ?Raise@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Raise

; 1088 : 
; 1089 :     ConvertVolumeValues(&Volume);

  0018c	8d 55 cc	 lea	 edx, DWORD PTR _Volume$[ebp]
  0018f	52		 push	 edx
  00190	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00193	e8 00 00 00 00	 call	 ?ConvertVolumeValues@CMcpxVoiceClient@DirectSound@@IAEXPAUMCPX_VOICE_VOLUME@@@Z ; DirectSound::CMcpxVoiceClient::ConvertVolumeValues

; 1090 : 
; 1091 :     dwPosition = BytesToSamples(dwPosition);

  00198	8b 45 08	 mov	 eax, DWORD PTR _dwPosition$[ebp]
  0019b	50		 push	 eax
  0019c	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0019f	e8 00 00 00 00	 call	 ?BytesToSamples@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::BytesToSamples
  001a4	89 45 08	 mov	 DWORD PTR _dwPosition$[ebp], eax
$L37490:

; 1092 : 
; 1093 :     MCPX_CHECK_VOICE_FIFO(7 * m_bVoiceCount);

  001a7	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  001ac	8b 91 00 00 82
	fe		 mov	 edx, DWORD PTR [ecx-25034752]
  001b2	c1 ea 02	 shr	 edx, 2
  001b5	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  001b8	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  001bc	6b c9 07	 imul	 ecx, 7
  001bf	3b d1		 cmp	 edx, ecx
  001c1	73 02		 jae	 SHORT $L37491
  001c3	eb e2		 jmp	 SHORT $L37490
$L37491:

; 1094 :     
; 1095 :     for(i = 0; i < m_bVoiceCount; i++)

  001c5	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001cc	eb 09		 jmp	 SHORT $L37494
$L37495:
  001ce	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  001d1	83 c2 01	 add	 edx, 1
  001d4	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx
$L37494:
  001d7	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  001da	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  001de	39 4d f0	 cmp	 DWORD PTR _i$[ebp], ecx
  001e1	73 7d		 jae	 SHORT $L37496

; 1096 :     {
; 1097 :         MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  001e3	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  001e6	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  001e9	0f b7 4c 50 0c	 movzx	 ecx, WORD PTR [eax+edx*2+12]
  001ee	ba f8 02 00 00	 mov	 edx, 760		; 000002f8H
  001f3	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 1098 :         MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);

  001f9	b8 fc 02 00 00	 mov	 eax, 764		; 000002fcH
  001fe	c7 80 00 00 82
	fe 01 00 00 00	 mov	 DWORD PTR [eax-25034752], 1

; 1099 :         MCPX_VOICE_WRITE(SetVoiceTarVOLA, Volume.TarVOLA[i]);

  00208	b9 60 03 00 00	 mov	 ecx, 864		; 00000360H
  0020d	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00210	8b 44 95 cc	 mov	 eax, DWORD PTR _Volume$[ebp+edx*4]
  00214	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 1100 :         MCPX_VOICE_WRITE(SetVoiceTarVOLB, Volume.TarVOLB[i]);

  0021a	b9 64 03 00 00	 mov	 ecx, 868		; 00000364H
  0021f	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00222	8b 44 95 d8	 mov	 eax, DWORD PTR _Volume$[ebp+edx*4+12]
  00226	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 1101 :         MCPX_VOICE_WRITE(SetVoiceTarVOLC, Volume.TarVOLC[i]);

  0022c	b9 68 03 00 00	 mov	 ecx, 872		; 00000368H
  00231	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00234	8b 44 95 e4	 mov	 eax, DWORD PTR _Volume$[ebp+edx*4+24]
  00238	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 1102 :         MCPX_VOICE_WRITE(SetVoiceBufCBO, dwPosition);

  0023e	b9 d8 03 00 00	 mov	 ecx, 984		; 000003d8H
  00243	8b 55 08	 mov	 edx, DWORD PTR _dwPosition$[ebp]
  00246	89 91 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], edx

; 1103 :         MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);

  0024c	b8 fc 02 00 00	 mov	 eax, 764		; 000002fcH
  00251	c7 80 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [eax-25034752], 0

; 1104 :     }

  0025b	e9 6e ff ff ff	 jmp	 $L37495
$L37496:

; 1105 : 
; 1106 :     irql.Lower();

  00260	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00263	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower

; 1107 : 
; 1108 :     DPF_LEAVE_VOID();
; 1109 : }

  00268	8b e5		 mov	 esp, ebp
  0026a	5d		 pop	 ebp
  0026b	c2 08 00	 ret	 8
?PlayFromPosition@CMcpxBuffer@DirectSound@@IAEXKK@Z ENDP ; DirectSound::CMcpxBuffer::PlayFromPosition
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetPlayRegion@CMcpxBuffer@DirectSound@@QAEJXZ
DSOUND	SEGMENT
_this$ = -12
_hr$ = -8
_dwFlags$ = -4
?SetPlayRegion@CMcpxBuffer@DirectSound@@QAEJXZ PROC NEAR ; DirectSound::CMcpxBuffer::SetPlayRegion, COMDAT
; _this$ = ecx

; 1135 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1136 :     HRESULT                 hr      = DS_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1137 :     DWORD                   dwFlags;
; 1138 :  
; 1139 :     DPF_ENTER();
; 1140 : 
; 1141 :     ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));
; 1142 : 
; 1143 :     //
; 1144 :     // Reset the cached play cursor
; 1145 :     //
; 1146 : 
; 1147 :     m_dwCachedPlayCursor = 0;

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 80 38 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+312], 0

; 1148 : 
; 1149 :     //
; 1150 :     // Recalculate the buffer base address
; 1151 :     //
; 1152 : 
; 1153 :     if(m_dwStatus & MCPX_VOICESTATUS_BUFFERMAPPED)

  0001d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00024	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  0002a	85 d2		 test	 edx, edx
  0002c	74 08		 je	 SHORT $L37518

; 1154 :     {
; 1155 :         MapBuffer();

  0002e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?MapBuffer@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::MapBuffer
$L37518:

; 1156 :     }
; 1157 : 
; 1158 :     //
; 1159 :     // If we're playing, call Play again.  That will reset the regions
; 1160 :     // based on what was just set.
; 1161 :     //
; 1162 : 
; 1163 :     if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)

  00036	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00039	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  0003d	83 e1 03	 and	 ecx, 3
  00040	83 f9 03	 cmp	 ecx, 3
  00043	75 2f		 jne	 SHORT $L37519

; 1164 :     {
; 1165 :         dwFlags = DSBPLAY_FROMSTART;

  00045	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _dwFlags$[ebp], 2

; 1166 : 
; 1167 :         if(m_dwStatus & MCPX_VOICESTATUS_LOOPING)

  0004c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  00053	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00058	85 c0		 test	 eax, eax
  0005a	74 09		 je	 SHORT $L37520

; 1168 :         {
; 1169 :             dwFlags |= DSBPLAY_LOOPING;

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  0005f	83 c9 01	 or	 ecx, 1
  00062	89 4d fc	 mov	 DWORD PTR _dwFlags$[ebp], ecx
$L37520:

; 1170 :         }
; 1171 :         
; 1172 :         hr = Play(dwFlags);

  00065	8b 55 fc	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00068	52		 push	 edx
  00069	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?Play@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::Play
  00071	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L37519:

; 1173 :     }
; 1174 : 
; 1175 :     DPF_LEAVE_HRESULT(hr);
; 1176 : 
; 1177 :     return hr;

  00074	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1178 : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?SetPlayRegion@CMcpxBuffer@DirectSound@@QAEJXZ ENDP	; DirectSound::CMcpxBuffer::SetPlayRegion
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetLoopRegion@CMcpxBuffer@DirectSound@@QAEJXZ
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
?SetLoopRegion@CMcpxBuffer@DirectSound@@QAEJXZ PROC NEAR ; DirectSound::CMcpxBuffer::SetLoopRegion, COMDAT
; _this$ = ecx

; 1204 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1205 :     HRESULT                 hr  = DS_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1206 :  
; 1207 :     DPF_ENTER();
; 1208 : 
; 1209 :     ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));
; 1210 : 
; 1211 :     //
; 1212 :     // If we're playing, call Play again.  That will reset the regions
; 1213 :     // based on what was just set.
; 1214 :     //
; 1215 : 
; 1216 :     if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00017	83 e1 03	 and	 ecx, 3
  0001a	83 f9 03	 cmp	 ecx, 3
  0001d	75 1e		 jne	 SHORT $L37527

; 1217 :     {
; 1218 :         hr = Play((m_dwStatus & MCPX_VOICESTATUS_LOOPING) ? DSBPLAY_LOOPING : 0);

  0001f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00022	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  00026	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0002b	f7 d8		 neg	 eax
  0002d	1b c0		 sbb	 eax, eax
  0002f	f7 d8		 neg	 eax
  00031	50		 push	 eax
  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?Play@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::Play
  0003a	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L37527:

; 1219 :     }
; 1220 : 
; 1221 :     DPF_LEAVE_HRESULT(hr);
; 1222 : 
; 1223 :     return hr;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1224 : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?SetLoopRegion@CMcpxBuffer@DirectSound@@QAEJXZ ENDP	; DirectSound::CMcpxBuffer::SetLoopRegion
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?Stop@CMcpxBuffer@DirectSound@@QAEJ_JK@Z
DSOUND	SEGMENT
_this$ = -12
_hr$ = -8
_fDeferred$ = -4
_rtTimeStamp$ = 8
_dwFlags$ = 16
?Stop@CMcpxBuffer@DirectSound@@QAEJ_JK@Z PROC NEAR	; DirectSound::CMcpxBuffer::Stop, COMDAT
; _this$ = ecx

; 1252 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1253 :     BOOL                    fDeferred   = FALSE;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fDeferred$[ebp], 0

; 1254 :     HRESULT                 hr          = DS_OK;

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1255 : 
; 1256 :     DPF_ENTER();
; 1257 : 
; 1258 :     if(rtTimeStamp)

  00017	8b 45 08	 mov	 eax, DWORD PTR _rtTimeStamp$[ebp]
  0001a	0b 45 0c	 or	 eax, DWORD PTR _rtTimeStamp$[ebp+4]
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $L37536

; 1259 :     {
; 1260 :         fDeferred = ScheduleDeferredCommand(MCPX_DEFERREDCMD_BUFFER_STOP, rtTimeStamp, dwFlags);

  00021	8b 4d 10	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 0c	 mov	 edx, DWORD PTR _rtTimeStamp$[ebp+4]
  00028	52		 push	 edx
  00029	8b 45 08	 mov	 eax, DWORD PTR _rtTimeStamp$[ebp]
  0002c	50		 push	 eax
  0002d	6a 04		 push	 4
  0002f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	ff 52 18	 call	 DWORD PTR [edx+24]
  0003a	89 45 fc	 mov	 DWORD PTR _fDeferred$[ebp], eax
$L37536:

; 1261 :     }
; 1262 : 
; 1263 :     if(!fDeferred)

  0003d	83 7d fc 00	 cmp	 DWORD PTR _fDeferred$[ebp], 0
  00041	75 0f		 jne	 SHORT $L37537

; 1264 :     {
; 1265 :         hr = Stop(dwFlags);

  00043	8b 45 10	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00046	50		 push	 eax
  00047	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?Stop@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::Stop
  0004f	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L37537:

; 1266 :     }
; 1267 : 
; 1268 :     DPF_LEAVE_HRESULT(hr);
; 1269 : 
; 1270 :     return hr;

  00052	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1271 : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
?Stop@CMcpxBuffer@DirectSound@@QAEJ_JK@Z ENDP		; DirectSound::CMcpxBuffer::Stop
DSOUND	ENDS
PUBLIC	?DeactivateVoice@CMcpxVoiceClient@DirectSound@@IAEXH@Z ; DirectSound::CMcpxVoiceClient::DeactivateVoice
PUBLIC	?ReleaseVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::ReleaseVoice
PUBLIC	?OnPositionDelta@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::OnPositionDelta
; Function compile flags: /Odt
;	COMDAT ?Stop@CMcpxBuffer@DirectSound@@QAEJK@Z
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
_dwFlags$ = 8
?Stop@CMcpxBuffer@DirectSound@@QAEJK@Z PROC NEAR	; DirectSound::CMcpxBuffer::Stop, COMDAT
; _this$ = ecx

; 1297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1298 :     HRESULT                 hr  = DS_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1299 :     
; 1300 :     DPF_ENTER();
; 1301 : 
; 1302 :     //
; 1303 :     // Make sure resources are allocated and we're actually running
; 1304 :     //
; 1305 : 
; 1306 :     if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00017	83 e1 03	 and	 ecx, 3
  0001a	83 f9 03	 cmp	 ecx, 3
  0001d	0f 85 a9 00 00
	00		 jne	 $L37544

; 1307 :     {
; 1308 :         if(dwFlags & DSBSTOPEX_ENVELOPE)

  00023	8b 55 08	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  00026	83 e2 01	 and	 edx, 1
  00029	85 d2		 test	 edx, edx
  0002b	74 3c		 je	 SHORT $L37545

; 1309 :         {
; 1310 :             //
; 1311 :             // If we're supposed to break out of the loop, just call Play again
; 1312 :             // without the loop flag.
; 1313 :             //
; 1314 : 
; 1315 :             if(dwFlags & DSBSTOPEX_RELEASEWAVEFORM)

  0002d	8b 45 08	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00030	83 e0 02	 and	 eax, 2
  00033	85 c0		 test	 eax, eax
  00035	74 22		 je	 SHORT $L37546

; 1316 :             {
; 1317 :                 if((m_dwStatus & MCPX_VOICESTATUS_LOOPINGMASK) == MCPX_VOICESTATUS_LOOPINGMASK)

  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  0003e	81 e2 03 02 00
	00		 and	 edx, 515		; 00000203H
  00044	81 fa 03 02 00
	00		 cmp	 edx, 515		; 00000203H
  0004a	75 0d		 jne	 SHORT $L37546

; 1318 :                 {
; 1319 :                     hr = Play(0);

  0004c	6a 00		 push	 0
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?Play@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::Play
  00056	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L37546:

; 1320 :                 }
; 1321 :             }
; 1322 : 
; 1323 :             //
; 1324 :             // Enter the release segment
; 1325 :             //
; 1326 : 
; 1327 :             if(SUCCEEDED(hr))

  00059	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0005d	7c 08		 jl	 SHORT $L37549

; 1328 :             {
; 1329 :                 ReleaseVoice();

  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	e8 00 00 00 00	 call	 ?ReleaseVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::ReleaseVoice
$L37549:

; 1330 :             }
; 1331 :         }
; 1332 :         else

  00067	eb 63		 jmp	 SHORT $L37544
$L37545:

; 1333 :         {
; 1334 :             //
; 1335 :             // Cache the current play cursor position
; 1336 :             //
; 1337 : 
; 1338 :             if(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK))

  00069	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00072	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00075	81 e2 00 20 08
	00		 and	 edx, 532480		; 00082000H
  0007b	85 d2		 test	 edx, edx
  0007d	75 13		 jne	 SHORT $L37551

; 1339 :             {
; 1340 :                 GetCurrentPosition(&m_dwCachedPlayCursor, NULL);

  0007f	6a 00		 push	 0
  00081	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00084	05 38 01 00 00	 add	 eax, 312		; 00000138H
  00089	50		 push	 eax
  0008a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?GetCurrentPosition@CMcpxBuffer@DirectSound@@QAEJPAK0@Z ; DirectSound::CMcpxBuffer::GetCurrentPosition
$L37551:

; 1341 :             }
; 1342 : 
; 1343 :             //
; 1344 :             // Stop the voice
; 1345 :             //
; 1346 : 
; 1347 :             DeactivateVoice();

  00092	6a 00		 push	 0
  00094	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?DeactivateVoice@CMcpxVoiceClient@DirectSound@@IAEXH@Z ; DirectSound::CMcpxVoiceClient::DeactivateVoice

; 1348 : 
; 1349 :             //
; 1350 :             // Signal positions up to this point
; 1351 :             //
; 1352 : 
; 1353 :             OnPositionDelta();

  0009c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?OnPositionDelta@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::OnPositionDelta

; 1354 : 
; 1355 :             //
; 1356 :             // If we're LOCDEFER, schedule a deferred command to release voice
; 1357 :             // resources
; 1358 :             //
; 1359 : 
; 1360 :             if(m_pSettings->m_dwFlags & DSBCAPS_LOCDEFER)

  000a4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  000ad	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b5	85 c0		 test	 eax, eax
  000b7	74 13		 je	 SHORT $L37544

; 1361 :             {
; 1362 :                 ScheduleDeferredCommand(MCPX_DEFERREDCMD_BUFFER_RELEASERESOURCES, 0, 0);

  000b9	6a 00		 push	 0
  000bb	6a 00		 push	 0
  000bd	6a 00		 push	 0
  000bf	6a 01		 push	 1
  000c1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	ff 52 18	 call	 DWORD PTR [edx+24]
$L37544:

; 1363 :             }
; 1364 :         }
; 1365 :     }
; 1366 : 
; 1367 :     DPF_LEAVE_HRESULT(hr);
; 1368 : 
; 1369 :     return hr;

  000cc	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1370 : }

  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c2 04 00	 ret	 4
?Stop@CMcpxBuffer@DirectSound@@QAEJK@Z ENDP		; DirectSound::CMcpxBuffer::Stop
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?GetStatus@CMcpxBuffer@DirectSound@@QAEJPAK@Z
DSOUND	SEGMENT
_this$ = -16
$T42044 = -12
___AutoIrql$ = -8
_pdwStatus$ = 8
?GetStatus@CMcpxBuffer@DirectSound@@QAEJPAK@Z PROC NEAR	; DirectSound::CMcpxBuffer::GetStatus, COMDAT
; _this$ = ecx

; 1396 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1397 :     DPF_ENTER();
; 1398 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1399 : 
; 1400 :     ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));
; 1401 : 
; 1402 :     //
; 1403 :     // Convert the voice state to buffer status.  We're going to look at
; 1404 :     // the VOICEOFF bit so IDirectSoundBuffer::GetStatus is as accurate as
; 1405 :     // possible.  This will allow a client to spin on GetStatus until the
; 1406 :     // voice is really inactive, preventing us from busy-waiting later.
; 1407 :     //
; 1408 : 
; 1409 :     *pdwStatus = 0;

  00011	8b 45 08	 mov	 eax, DWORD PTR _pdwStatus$[ebp]
  00014	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1410 :     
; 1411 :     if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)

  0001a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00021	83 e2 01	 and	 edx, 1
  00024	85 d2		 test	 edx, edx
  00026	74 3b		 je	 SHORT $L37558

; 1412 :     {
; 1413 :         if(m_dwStatus & MCPX_VOICESTATUS_ACTIVEORVOICEOFF)

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  0002f	81 e1 02 80 00
	00		 and	 ecx, 32770		; 00008002H
  00035	85 c9		 test	 ecx, ecx
  00037	74 2a		 je	 SHORT $L37558

; 1414 :         {
; 1415 :             *pdwStatus |= DSBSTATUS_PLAYING;

  00039	8b 55 08	 mov	 edx, DWORD PTR _pdwStatus$[ebp]
  0003c	8b 02		 mov	 eax, DWORD PTR [edx]
  0003e	83 c8 01	 or	 eax, 1
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _pdwStatus$[ebp]
  00044	89 01		 mov	 DWORD PTR [ecx], eax

; 1416 : 
; 1417 :             if(m_dwStatus & MCPX_VOICESTATUS_LOOPING)

  00046	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00049	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  0004d	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00052	85 c0		 test	 eax, eax
  00054	74 0d		 je	 SHORT $L37558

; 1418 :             {
; 1419 :                 *pdwStatus |= DSBSTATUS_LOOPING;

  00056	8b 4d 08	 mov	 ecx, DWORD PTR _pdwStatus$[ebp]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	83 ca 04	 or	 edx, 4
  0005e	8b 45 08	 mov	 eax, DWORD PTR _pdwStatus$[ebp]
  00061	89 10		 mov	 DWORD PTR [eax], edx
$L37558:

; 1420 :             }
; 1421 :         }
; 1422 :     }
; 1423 : 
; 1424 :     DPF_LEAVE_HRESULT(DS_OK);
; 1425 : 
; 1426 :     return DS_OK;

  00063	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T42044[ebp], 0
  0006a	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0006d	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00072	8b 45 f4	 mov	 eax, DWORD PTR $T42044[ebp]

; 1427 : }

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
?GetStatus@CMcpxBuffer@DirectSound@@QAEJPAK@Z ENDP	; DirectSound::CMcpxBuffer::GetStatus
DSOUND	ENDS
PUBLIC	?GetSslPosition@CMcpxVoiceClient@DirectSound@@IAEKXZ ; DirectSound::CMcpxVoiceClient::GetSslPosition
; Function compile flags: /Odt
;	COMDAT ?GetCurrentPosition@CMcpxBuffer@DirectSound@@QAEJPAK0@Z
DSOUND	SEGMENT
_this$ = -24
$T42048 = -20
___AutoIrql$ = -16
_dwFrameSize$ = -8
_dwPlayCursor$ = -4
_pdwPlayCursor$ = 8
_pdwWriteCursor$ = 12
?GetCurrentPosition@CMcpxBuffer@DirectSound@@QAEJPAK0@Z PROC NEAR ; DirectSound::CMcpxBuffer::GetCurrentPosition, COMDAT
; _this$ = ecx

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1456 :     DWORD                   dwPlayCursor;
; 1457 :     DWORD                   dwFrameSize;
; 1458 :     
; 1459 :     DPF_ENTER();
; 1460 :     AutoIrql();

  00009	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1461 : 
; 1462 :     ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));
; 1463 : 
; 1464 :     //
; 1465 :     // Get the current SSL position if we're playing or used the cached one
; 1466 :     // if we're not.
; 1467 :     //
; 1468 :     // When we're playing, the write cursor is 32 samples ahead of the play 
; 1469 :     // cursor.
; 1470 :     //
; 1471 : 
; 1472 :     if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)

  00011	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00014	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00018	83 e1 03	 and	 ecx, 3
  0001b	83 f9 03	 cmp	 ecx, 3
  0001e	0f 85 f6 00 00
	00		 jne	 $L37571

; 1473 :     {
; 1474 :         dwPlayCursor = GetSslPosition();

  00024	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?GetSslPosition@CMcpxVoiceClient@DirectSound@@IAEKXZ ; DirectSound::CMcpxVoiceClient::GetSslPosition
  0002c	89 45 fc	 mov	 DWORD PTR _dwPlayCursor$[ebp], eax

; 1475 : 
; 1476 :         if(pdwPlayCursor)

  0002f	83 7d 08 00	 cmp	 DWORD PTR _pdwPlayCursor$[ebp], 0
  00033	74 08		 je	 SHORT $L37572

; 1477 :         {
; 1478 :             *pdwPlayCursor = dwPlayCursor;

  00035	8b 55 08	 mov	 edx, DWORD PTR _pdwPlayCursor$[ebp]
  00038	8b 45 fc	 mov	 eax, DWORD PTR _dwPlayCursor$[ebp]
  0003b	89 02		 mov	 DWORD PTR [edx], eax
$L37572:

; 1479 :         }
; 1480 : 
; 1481 :         if(pdwWriteCursor)

  0003d	83 7d 0c 00	 cmp	 DWORD PTR _pdwWriteCursor$[ebp], 0
  00041	0f 84 d1 00 00
	00		 je	 $L37573

; 1482 :         {
; 1483 :             dwFrameSize = SamplesToBytes(MCPX_HW_FRAME_SIZE_SAMPLES);

  00047	6a 20		 push	 32			; 00000020H
  00049	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?SamplesToBytes@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::SamplesToBytes
  00051	89 45 f8	 mov	 DWORD PTR _dwFrameSize$[ebp], eax

; 1484 : 
; 1485 :             if(dwFrameSize < m_pSettings->m_fmt.nBlockAlign)

  00054	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  0005d	8b 45 f8	 mov	 eax, DWORD PTR _dwFrameSize$[ebp]
  00060	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  00063	73 0f		 jae	 SHORT $L37574

; 1486 :             {
; 1487 :                 dwFrameSize = m_pSettings->m_fmt.nBlockAlign;

  00065	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  0006e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00071	89 45 f8	 mov	 DWORD PTR _dwFrameSize$[ebp], eax
$L37574:

; 1488 :             }
; 1489 :             
; 1490 :             *pdwWriteCursor = dwPlayCursor + dwFrameSize;

  00074	8b 4d fc	 mov	 ecx, DWORD PTR _dwPlayCursor$[ebp]
  00077	03 4d f8	 add	 ecx, DWORD PTR _dwFrameSize$[ebp]
  0007a	8b 55 0c	 mov	 edx, DWORD PTR _pdwWriteCursor$[ebp]
  0007d	89 0a		 mov	 DWORD PTR [edx], ecx

; 1491 :     
; 1492 :             if((m_dwStatus & MCPX_VOICESTATUS_LOOPING) && (dwPlayCursor >= m_pSettings->m_dwLoopStart) && (dwPlayCursor < m_pSettings->m_dwLoopStart + m_pSettings->m_dwLoopLength))

  0007f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00082	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00086	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  0008c	85 c9		 test	 ecx, ecx
  0008e	74 6d		 je	 SHORT $L37575
  00090	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00093	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00099	8b 4d fc	 mov	 ecx, DWORD PTR _dwPlayCursor$[ebp]
  0009c	3b 88 c4 00 00
	00		 cmp	 ecx, DWORD PTR [eax+196]
  000a2	72 59		 jb	 SHORT $L37575
  000a4	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000a7	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  000ad	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  000b6	8b 80 c4 00 00
	00		 mov	 eax, DWORD PTR [eax+196]
  000bc	03 82 c8 00 00
	00		 add	 eax, DWORD PTR [edx+200]
  000c2	39 45 fc	 cmp	 DWORD PTR _dwPlayCursor$[ebp], eax
  000c5	73 36		 jae	 SHORT $L37575

; 1493 :             {
; 1494 :                 *pdwWriteCursor %= m_pSettings->m_dwLoopLength;

  000c7	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [ecx+144]
  000d0	8b 55 0c	 mov	 edx, DWORD PTR _pdwWriteCursor$[ebp]
  000d3	8b 02		 mov	 eax, DWORD PTR [edx]
  000d5	33 d2		 xor	 edx, edx
  000d7	f7 b1 c8 00 00
	00		 div	 DWORD PTR [ecx+200]
  000dd	8b 45 0c	 mov	 eax, DWORD PTR _pdwWriteCursor$[ebp]
  000e0	89 10		 mov	 DWORD PTR [eax], edx

; 1495 :                 *pdwWriteCursor += m_pSettings->m_dwLoopStart;

  000e2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  000eb	8b 45 0c	 mov	 eax, DWORD PTR _pdwWriteCursor$[ebp]
  000ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f0	03 8a c4 00 00
	00		 add	 ecx, DWORD PTR [edx+196]
  000f6	8b 55 0c	 mov	 edx, DWORD PTR _pdwWriteCursor$[ebp]
  000f9	89 0a		 mov	 DWORD PTR [edx], ecx

; 1496 :             }
; 1497 :             else

  000fb	eb 1b		 jmp	 SHORT $L37573
$L37575:

; 1498 :             {
; 1499 :                 *pdwWriteCursor %= m_pSettings->m_dwBufferSize;

  000fd	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00100	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00106	8b 55 0c	 mov	 edx, DWORD PTR _pdwWriteCursor$[ebp]
  00109	8b 02		 mov	 eax, DWORD PTR [edx]
  0010b	33 d2		 xor	 edx, edx
  0010d	f7 b1 b8 00 00
	00		 div	 DWORD PTR [ecx+184]
  00113	8b 45 0c	 mov	 eax, DWORD PTR _pdwWriteCursor$[ebp]
  00116	89 10		 mov	 DWORD PTR [eax], edx
$L37573:

; 1500 :             }
; 1501 :         }
; 1502 :     }
; 1503 :     else

  00118	eb 28		 jmp	 SHORT $L37577
$L37571:

; 1504 :     {
; 1505 :         if(pdwPlayCursor)

  0011a	83 7d 08 00	 cmp	 DWORD PTR _pdwPlayCursor$[ebp], 0
  0011e	74 0e		 je	 SHORT $L37578

; 1506 :         {
; 1507 :             *pdwPlayCursor = m_dwCachedPlayCursor;

  00120	8b 4d 08	 mov	 ecx, DWORD PTR _pdwPlayCursor$[ebp]
  00123	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00126	8b 82 38 01 00
	00		 mov	 eax, DWORD PTR [edx+312]
  0012c	89 01		 mov	 DWORD PTR [ecx], eax
$L37578:

; 1508 :         }
; 1509 : 
; 1510 :         if(pdwWriteCursor)

  0012e	83 7d 0c 00	 cmp	 DWORD PTR _pdwWriteCursor$[ebp], 0
  00132	74 0e		 je	 SHORT $L37577

; 1511 :         {
; 1512 :             *pdwWriteCursor = m_dwCachedPlayCursor;

  00134	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwWriteCursor$[ebp]
  00137	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0013a	8b 82 38 01 00
	00		 mov	 eax, DWORD PTR [edx+312]
  00140	89 01		 mov	 DWORD PTR [ecx], eax
$L37577:

; 1513 :         }
; 1514 :     }
; 1515 : 
; 1516 :     DPF_LEAVE_HRESULT(DS_OK);
; 1517 : 
; 1518 :     return DS_OK;

  00142	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T42048[ebp], 0
  00149	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0014c	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00151	8b 45 ec	 mov	 eax, DWORD PTR $T42048[ebp]

; 1519 : }

  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c2 08 00	 ret	 8
?GetCurrentPosition@CMcpxBuffer@DirectSound@@QAEJPAK0@Z ENDP ; DirectSound::CMcpxBuffer::GetCurrentPosition
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetCurrentPosition@CMcpxBuffer@DirectSound@@QAEJK@Z
DSOUND	SEGMENT
_this$ = -24
_hr$ = -20
_i$ = -16
_dwState$ = -12
_irql$ = -8
_dwPlayCursor$ = 8
?SetCurrentPosition@CMcpxBuffer@DirectSound@@QAEJK@Z PROC NEAR ; DirectSound::CMcpxBuffer::SetCurrentPosition, COMDAT
; _this$ = ecx

; 1545 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1546 :     HRESULT                 hr      = DS_OK;

  00009	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1547 :     DWORD                   dwState;
; 1548 :     CIrql                   irql;

  00010	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CIrql@DirectSound@@QAE@XZ ; DirectSound::CIrql::CIrql

; 1549 :     DWORD                   i;
; 1550 :     
; 1551 :     DPF_ENTER();
; 1552 : 
; 1553 :     ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));
; 1554 :     ASSERT(dwPlayCursor <= m_pSettings->m_dwPlayLength);
; 1555 : 
; 1556 :     if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)

  00018	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  0001f	83 e1 03	 and	 ecx, 3
  00022	83 f9 03	 cmp	 ecx, 3
  00025	0f 85 1a 01 00
	00		 jne	 $L37591
$L37592:

; 1557 :     {
; 1558 :         //
; 1559 :         // Wait for the NEW_VOICE bit to clear so we can set the CBO.  The
; 1560 :         // hardware will ignore the CBO until it's processed at least one
; 1561 :         // frame.
; 1562 :         //
; 1563 : 
; 1564 :         do
; 1565 :         {
; 1566 :             MCPX_VOICE_STRUCT_READ(m_ahVoices[m_bVoiceCount - 1], NV_PAVS_VOICE_PAR_STATE, &dwState);

  0002b	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  00032	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	0f b7 54 41 0a	 movzx	 edx, WORD PTR [ecx+eax*2+10]
  0003a	c1 e2 07	 shl	 edx, 7
  0003d	a1 30 00 00 00	 mov	 eax, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+48
  00042	8b 4c 10 54	 mov	 ecx, DWORD PTR [eax+edx+84]
  00046	89 4d f4	 mov	 DWORD PTR _dwState$[ebp], ecx

; 1567 :         }
; 1568 :         while(MCPX_GET_REG_VALUE(dwState, NV_PAVS_VOICE_PAR_STATE_NEW_VOICE));

  00049	8b 55 f4	 mov	 edx, DWORD PTR _dwState$[ebp]
  0004c	c1 ea 14	 shr	 edx, 20			; 00000014H
  0004f	83 e2 01	 and	 edx, 1
  00052	85 d2		 test	 edx, edx
  00054	75 d5		 jne	 SHORT $L37592

; 1569 : 
; 1570 :         //
; 1571 :         // If the cursor position is outside the loop region, toggle
; 1572 :         // the loop flag.
; 1573 :         //
; 1574 : 
; 1575 :         if((m_dwStatus & MCPX_VOICESTATUS_LOOPINGMASK) == MCPX_VOICESTATUS_LOOPINGMASK)

  00056	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  0005d	81 e1 03 02 00
	00		 and	 ecx, 515		; 00000203H
  00063	81 f9 03 02 00
	00		 cmp	 ecx, 515		; 00000203H
  00069	75 30		 jne	 SHORT $L37598

; 1576 :         {
; 1577 :             if(dwPlayCursor >= m_pSettings->m_dwLoopStart + m_pSettings->m_dwLoopLength)

  0006b	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0006e	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00074	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  0007d	8b 80 c4 00 00
	00		 mov	 eax, DWORD PTR [eax+196]
  00083	03 82 c8 00 00
	00		 add	 eax, DWORD PTR [edx+200]
  00089	39 45 08	 cmp	 DWORD PTR _dwPlayCursor$[ebp], eax
  0008c	72 0d		 jb	 SHORT $L37598

; 1578 :             {
; 1579 :                 hr = Play(0);

  0008e	6a 00		 push	 0
  00090	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	e8 00 00 00 00	 call	 ?Play@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::Play
  00098	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax
$L37598:

; 1580 :             }
; 1581 :         }
; 1582 : 
; 1583 :         //
; 1584 :         // Set voice position
; 1585 :         //
; 1586 :         
; 1587 :         if(SUCCEEDED(hr))

  0009b	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0009f	0f 8c 9e 00 00
	00		 jl	 $L37601

; 1588 :         {
; 1589 :             dwPlayCursor = BytesToSamples(dwPlayCursor);

  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _dwPlayCursor$[ebp]
  000a8	51		 push	 ecx
  000a9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	e8 00 00 00 00	 call	 ?BytesToSamples@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::BytesToSamples
  000b1	89 45 08	 mov	 DWORD PTR _dwPlayCursor$[ebp], eax

; 1590 : 
; 1591 :             DPF_INFO("Voice %x (%x) setting current buffer offset to %lu", this, m_ahVoices[0], dwPlayCursor);
; 1592 : 
; 1593 :             irql.Raise();

  000b4	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  000b7	e8 00 00 00 00	 call	 ?Raise@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Raise
$L37603:

; 1594 :         
; 1595 :             MCPX_CHECK_VOICE_FIFO(2 * m_bVoiceCount);

  000bc	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000c1	8b 82 00 00 82
	fe		 mov	 eax, DWORD PTR [edx-25034752]
  000c7	c1 e8 02	 shr	 eax, 2
  000ca	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	0f b6 51 64	 movzx	 edx, BYTE PTR [ecx+100]
  000d1	d1 e2		 shl	 edx, 1
  000d3	3b c2		 cmp	 eax, edx
  000d5	73 02		 jae	 SHORT $L37604
  000d7	eb e3		 jmp	 SHORT $L37603
$L37604:

; 1596 :             
; 1597 :             for(i = 0; i < m_bVoiceCount; i++)

  000d9	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e0	eb 09		 jmp	 SHORT $L37607
$L37608:
  000e2	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000e5	83 c0 01	 add	 eax, 1
  000e8	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$L37607:
  000eb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	0f b6 51 64	 movzx	 edx, BYTE PTR [ecx+100]
  000f2	39 55 f0	 cmp	 DWORD PTR _i$[ebp], edx
  000f5	73 44		 jae	 SHORT $L37609

; 1598 :             {
; 1599 :                 MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  000f7	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000fa	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000fd	0f b7 54 41 0c	 movzx	 edx, WORD PTR [ecx+eax*2+12]
  00102	b8 f8 02 00 00	 mov	 eax, 760		; 000002f8H
  00107	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 1600 :                 MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);

  0010d	b9 fc 02 00 00	 mov	 ecx, 764		; 000002fcH
  00112	c7 81 00 00 82
	fe 01 00 00 00	 mov	 DWORD PTR [ecx-25034752], 1

; 1601 :                 MCPX_VOICE_WRITE(SetVoiceBufCBO, dwPlayCursor);

  0011c	ba d8 03 00 00	 mov	 edx, 984		; 000003d8H
  00121	8b 45 08	 mov	 eax, DWORD PTR _dwPlayCursor$[ebp]
  00124	89 82 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], eax

; 1602 :                 MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);

  0012a	b9 fc 02 00 00	 mov	 ecx, 764		; 000002fcH
  0012f	c7 81 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [ecx-25034752], 0

; 1603 :             }

  00139	eb a7		 jmp	 SHORT $L37608
$L37609:

; 1604 : 
; 1605 :             irql.Lower();

  0013b	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  0013e	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower
$L37601:

; 1606 :         }
; 1607 :     }
; 1608 :     else

  00143	eb 0c		 jmp	 SHORT $L37618
$L37591:

; 1609 :     {
; 1610 :         //
; 1611 :         // Cache the play cursor for the next time we call Play
; 1612 :         //
; 1613 :         
; 1614 :         m_dwCachedPlayCursor = dwPlayCursor;

  00145	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00148	8b 45 08	 mov	 eax, DWORD PTR _dwPlayCursor$[ebp]
  0014b	89 82 38 01 00
	00		 mov	 DWORD PTR [edx+312], eax
$L37618:

; 1615 :     }
; 1616 : 
; 1617 :     //
; 1618 :     // Signal position events
; 1619 :     //
; 1620 : 
; 1621 :     OnPositionDelta();

  00151	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00154	e8 00 00 00 00	 call	 ?OnPositionDelta@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::OnPositionDelta

; 1622 : 
; 1623 :     DPF_LEAVE_HRESULT(hr);
; 1624 : 
; 1625 :     return hr;

  00159	8b 45 ec	 mov	 eax, DWORD PTR _hr$[ebp]

; 1626 : }

  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c2 04 00	 ret	 4
?SetCurrentPosition@CMcpxBuffer@DirectSound@@QAEJK@Z ENDP ; DirectSound::CMcpxBuffer::SetCurrentPosition
DSOUND	ENDS
PUBLIC	?GetStatus@CMcpxNotifier@DirectSound@@QAEHK@Z	; DirectSound::CMcpxNotifier::GetStatus
PUBLIC	?SetStatus@CMcpxNotifier@DirectSound@@QAEXKH@Z	; DirectSound::CMcpxNotifier::SetStatus
; Function compile flags: /Odt
;	COMDAT ?ServiceVoiceInterrupt@CMcpxBuffer@DirectSound@@MAEHXZ
DSOUND	SEGMENT
_this$ = -8
_fHandled$ = -4
?ServiceVoiceInterrupt@CMcpxBuffer@DirectSound@@MAEHXZ PROC NEAR ; DirectSound::CMcpxBuffer::ServiceVoiceInterrupt, COMDAT
; _this$ = ecx

; 1652 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1653 :     BOOL                    fHandled;
; 1654 : 
; 1655 :     DPF_ENTER();
; 1656 : 
; 1657 :     ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
; 1658 :     ASSERT(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED);
; 1659 :     
; 1660 :     if(fHandled = m_Notifier.GetStatus(MCPX_NOTIFIER_VOICE_OFF))

  00009	6a 03		 push	 3
  0000b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 68	 add	 ecx, 104		; 00000068H
  00011	e8 00 00 00 00	 call	 ?GetStatus@CMcpxNotifier@DirectSound@@QAEHK@Z ; DirectSound::CMcpxNotifier::GetStatus
  00016	89 45 fc	 mov	 DWORD PTR _fHandled$[ebp], eax
  00019	83 7d fc 00	 cmp	 DWORD PTR _fHandled$[ebp], 0
  0001d	74 42		 je	 SHORT $L37624

; 1661 :     {
; 1662 :         //
; 1663 :         // Reset the notifier
; 1664 :         //
; 1665 :         
; 1666 :         m_Notifier.SetStatus(MCPX_NOTIFIER_VOICE_OFF, FALSE);

  0001f	6a 00		 push	 0
  00021	6a 03		 push	 3
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 68	 add	 ecx, 104		; 00000068H
  00029	e8 00 00 00 00	 call	 ?SetStatus@CMcpxNotifier@DirectSound@@QAEXKH@Z ; DirectSound::CMcpxNotifier::SetStatus

; 1667 : 
; 1668 :         //
; 1669 :         // Handle the stop
; 1670 :         //
; 1671 : 
; 1672 :         DeactivateVoice();

  0002e	6a 00		 push	 0
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?DeactivateVoice@CMcpxVoiceClient@DirectSound@@IAEXH@Z ; DirectSound::CMcpxVoiceClient::DeactivateVoice

; 1673 : 
; 1674 :         //
; 1675 :         // If we're LOCDEFER, free voice resources
; 1676 :         //
; 1677 : 
; 1678 :         if(m_pSettings->m_dwFlags & DSBCAPS_LOCDEFER)

  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00041	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00044	81 e2 00 00 04
	00		 and	 edx, 262144		; 00040000H
  0004a	85 d2		 test	 edx, edx
  0004c	74 13		 je	 SHORT $L37624

; 1679 :         {
; 1680 :             ScheduleDeferredCommand(MCPX_DEFERREDCMD_BUFFER_RELEASERESOURCES, 0, 0);

  0004e	6a 00		 push	 0
  00050	6a 00		 push	 0
  00052	6a 00		 push	 0
  00054	6a 01		 push	 1
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 10		 mov	 edx, DWORD PTR [eax]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	ff 52 18	 call	 DWORD PTR [edx+24]
$L37624:

; 1681 :         }
; 1682 :     }
; 1683 : 
; 1684 :     DPF_LEAVE(fHandled);
; 1685 : 
; 1686 :     return fHandled;

  00061	8b 45 fc	 mov	 eax, DWORD PTR _fHandled$[ebp]

; 1687 : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?ServiceVoiceInterrupt@CMcpxBuffer@DirectSound@@MAEHXZ ENDP ; DirectSound::CMcpxBuffer::ServiceVoiceInterrupt
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpxcore.h
DSOUND	ENDS
;	COMDAT ?GetStatus@CMcpxNotifier@DirectSound@@QAEHK@Z
DSOUND	SEGMENT
tv68 = -8
_this$ = -4
_dwNotifierIndex$ = 8
?GetStatus@CMcpxNotifier@DirectSound@@QAEHK@Z PROC NEAR	; DirectSound::CMcpxNotifier::GetStatus, COMDAT
; _this$ = ecx

; 436  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 437  :         ASSERT(m_paNotifier);
; 438  :         ASSERT(dwNotifierIndex < m_dwNotifierCount);
; 439  :     
; 440  :         switch(m_paNotifier[dwNotifierIndex].Status)
; 441  :         {

  00009	8b 45 08	 mov	 eax, DWORD PTR _dwNotifierIndex$[ebp]
  0000c	c1 e0 04	 shl	 eax, 4
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	8a 44 02 0f	 mov	 al, BYTE PTR [edx+eax+15]
  00018	88 45 f8	 mov	 BYTE PTR tv68[ebp], al
  0001b	80 7d f8 01	 cmp	 BYTE PTR tv68[ebp], 1
  0001f	74 08		 je	 SHORT $L33863
  00021	80 7d f8 80	 cmp	 BYTE PTR tv68[ebp], 128	; 00000080H
  00025	74 09		 je	 SHORT $L33864
  00027	eb 0b		 jmp	 SHORT $L33865
$L33863:

; 442  :             case NV1BA0_NOTIFICATION_STATUS_DONE_SUCCESS:
; 443  :                 return TRUE;

  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	eb 06		 jmp	 SHORT $L33858
$L33864:

; 444  : 
; 445  :             case NV1BA0_NOTIFICATION_STATUS_IN_PROGRESS:
; 446  :                 return FALSE;

  00030	33 c0		 xor	 eax, eax
  00032	eb 02		 jmp	 SHORT $L33858
$L33865:

; 447  : 
; 448  :             default:
; 449  :                 ASSERTMSG("Unexpected notifier status");
; 450  :                 return FALSE;

  00034	33 c0		 xor	 eax, eax
$L33858:

; 451  :         }
; 452  :     }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?GetStatus@CMcpxNotifier@DirectSound@@QAEHK@Z ENDP	; DirectSound::CMcpxNotifier::GetStatus
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetStatus@CMcpxNotifier@DirectSound@@QAEXKH@Z
DSOUND	SEGMENT
_this$ = -4
_dwNotifierIndex$ = 8
_fSignaled$ = 12
?SetStatus@CMcpxNotifier@DirectSound@@QAEXKH@Z PROC NEAR ; DirectSound::CMcpxNotifier::SetStatus, COMDAT
; _this$ = ecx

; 455  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 456  :         ASSERT(m_paNotifier);
; 457  :         ASSERT(dwNotifierIndex < m_dwNotifierCount);
; 458  : 
; 459  :         m_paNotifier[dwNotifierIndex].Status = fSignaled ? NV1BA0_NOTIFICATION_STATUS_DONE_SUCCESS : NV1BA0_NOTIFICATION_STATUS_IN_PROGRESS;

  00007	8b 45 0c	 mov	 eax, DWORD PTR _fSignaled$[ebp]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	83 e0 81	 and	 eax, -127		; ffffff81H
  00011	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _dwNotifierIndex$[ebp]
  00019	c1 e1 04	 shl	 ecx, 4
  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 12		 mov	 edx, DWORD PTR [edx]
  00021	88 44 0a 0f	 mov	 BYTE PTR [edx+ecx+15], al

; 460  :     }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
?SetStatus@CMcpxNotifier@DirectSound@@QAEXKH@Z ENDP	; DirectSound::CMcpxNotifier::SetStatus
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpbuf.cpp
DSOUND	ENDS
;	COMDAT ?SetNotificationPositions@CMcpxBuffer@DirectSound@@QAEJXZ
DSOUND	SEGMENT
_this$ = -16
$T42064 = -12
___AutoIrql$ = -8
?SetNotificationPositions@CMcpxBuffer@DirectSound@@QAEJXZ PROC NEAR ; DirectSound::CMcpxBuffer::SetNotificationPositions, COMDAT
; _this$ = ecx

; 1713 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1714 :     DPF_ENTER();
; 1715 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1716 : 
; 1717 :     //
; 1718 :     // If we're playing, make sure the position delta event is set up
; 1719 :     //
; 1720 : 
; 1721 :     if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)

  00011	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00014	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00018	83 e1 03	 and	 ecx, 3
  0001b	83 f9 03	 cmp	 ecx, 3
  0001e	75 25		 jne	 SHORT $L37631

; 1722 :     {
; 1723 :         if(m_pSettings->m_dwNotifyCount)

  00020	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00023	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00029	83 b8 d4 00 00
	00 00		 cmp	 DWORD PTR [eax+212], 0
  00030	74 13		 je	 SHORT $L37631

; 1724 :         {
; 1725 :             ScheduleDeferredCommand(MCPX_DEFERREDCMD_BUFFER_POSITIONDELTA, 0, 0);

  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	6a 02		 push	 2
  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	ff 52 18	 call	 DWORD PTR [edx+24]
$L37631:

; 1726 :         }
; 1727 :     }
; 1728 : 
; 1729 :     //
; 1730 :     // Reset the notification index
; 1731 :     //
; 1732 : 
; 1733 :     m_dwLastNotifyPosition = -1;

  00045	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00048	c7 80 3c 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+316], -1

; 1734 :     m_dwNextNotifyIndex = 0;

  00052	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	c7 81 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+320], 0

; 1735 : 
; 1736 :     DPF_LEAVE_HRESULT(DS_OK);
; 1737 : 
; 1738 :     return DS_OK;

  0005f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T42064[ebp], 0
  00066	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00069	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  0006e	8b 45 f4	 mov	 eax, DWORD PTR $T42064[ebp]

; 1739 : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?SetNotificationPositions@CMcpxBuffer@DirectSound@@QAEJXZ ENDP ; DirectSound::CMcpxBuffer::SetNotificationPositions
DSOUND	ENDS
PUBLIC	?NotifyToPosition@CMcpxBuffer@DirectSound@@IAEXKH@Z ; DirectSound::CMcpxBuffer::NotifyToPosition
PUBLIC	?NotifyStop@CMcpxBuffer@DirectSound@@IAEXXZ	; DirectSound::CMcpxBuffer::NotifyStop
; Function compile flags: /Odt
;	COMDAT ?OnPositionDelta@CMcpxBuffer@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -20
_hr$ = -16
_dwStartPosition$ = -12
_dwEndPosition$ = -8
_dwPlayCursor$ = -4
?OnPositionDelta@CMcpxBuffer@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxBuffer::OnPositionDelta, COMDAT
; _this$ = ecx

; 1765 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1766 :     DWORD                   dwPlayCursor;
; 1767 :     DWORD                   dwStartPosition;
; 1768 :     DWORD                   dwEndPosition;
; 1769 :     HRESULT                 hr;
; 1770 :     
; 1771 :     DPF_ENTER();
; 1772 : 
; 1773 :     if(m_pSettings->m_dwNotifyCount)

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00012	83 b9 d4 00 00
	00 00		 cmp	 DWORD PTR [ecx+212], 0
  00019	0f 84 07 01 00
	00		 je	 $L37638

; 1774 :     {
; 1775 :         ASSERT(m_pSettings->m_paNotifies);
; 1776 : 
; 1777 :         //
; 1778 :         // Compare the current position to the last and signal the events in
; 1779 :         // between
; 1780 :         //
; 1781 : 
; 1782 :         if(NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP_ON == MCPX_GET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP))

  0001f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00022	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00025	c1 e8 19	 shr	 eax, 25			; 00000019H
  00028	83 e0 01	 and	 eax, 1
  0002b	83 f8 01	 cmp	 eax, 1
  0002e	75 35		 jne	 SHORT $L37644

; 1783 :         {
; 1784 :             dwStartPosition = m_pSettings->m_dwLoopStart;

  00030	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00039	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  0003f	89 45 f4	 mov	 DWORD PTR _dwStartPosition$[ebp], eax

; 1785 :             dwEndPosition = m_pSettings->m_dwLoopStart + m_pSettings->m_dwLoopLength;

  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  0004b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00054	8b 92 c4 00 00
	00		 mov	 edx, DWORD PTR [edx+196]
  0005a	03 91 c8 00 00
	00		 add	 edx, DWORD PTR [ecx+200]
  00060	89 55 f8	 mov	 DWORD PTR _dwEndPosition$[ebp], edx

; 1786 :         }
; 1787 :         else

  00063	eb 19		 jmp	 SHORT $L37645
$L37644:

; 1788 :         {
; 1789 :             dwStartPosition = 0;

  00065	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwStartPosition$[ebp], 0

; 1790 :             dwEndPosition = m_pSettings->m_dwPlayLength;

  0006c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00075	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  0007b	89 55 f8	 mov	 DWORD PTR _dwEndPosition$[ebp], edx
$L37645:

; 1791 :         }
; 1792 : 
; 1793 :         hr = GetCurrentPosition(&dwPlayCursor, NULL);

  0007e	6a 00		 push	 0
  00080	8d 45 fc	 lea	 eax, DWORD PTR _dwPlayCursor$[ebp]
  00083	50		 push	 eax
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ?GetCurrentPosition@CMcpxBuffer@DirectSound@@QAEJPAK0@Z ; DirectSound::CMcpxBuffer::GetCurrentPosition
  0008c	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 1794 :         ASSERT(SUCCEEDED(hr));
; 1795 : 
; 1796 :         if((dwPlayCursor > m_dwLastNotifyPosition) || (m_dwLastNotifyPosition > dwEndPosition))

  0008f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	8b 55 fc	 mov	 edx, DWORD PTR _dwPlayCursor$[ebp]
  00095	3b 91 3c 01 00
	00		 cmp	 edx, DWORD PTR [ecx+316]
  0009b	77 0e		 ja	 SHORT $L37647
  0009d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	8b 88 3c 01 00
	00		 mov	 ecx, DWORD PTR [eax+316]
  000a6	3b 4d f8	 cmp	 ecx, DWORD PTR _dwEndPosition$[ebp]
  000a9	76 10		 jbe	 SHORT $L37646
$L37647:

; 1797 :         {
; 1798 :             //
; 1799 :             // The play cursor has moved forward.  Signal the events in
; 1800 :             // between where we were and where we are.
; 1801 :             //
; 1802 : 
; 1803 :             NotifyToPosition(dwPlayCursor);

  000ab	6a 01		 push	 1
  000ad	8b 55 fc	 mov	 edx, DWORD PTR _dwPlayCursor$[ebp]
  000b0	52		 push	 edx
  000b1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e8 00 00 00 00	 call	 ?NotifyToPosition@CMcpxBuffer@DirectSound@@IAEXKH@Z ; DirectSound::CMcpxBuffer::NotifyToPosition

; 1804 :         }
; 1805 :         else if(dwPlayCursor < m_dwLastNotifyPosition)

  000b9	eb 45		 jmp	 SHORT $L37648
$L37646:
  000bb	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8b 4d fc	 mov	 ecx, DWORD PTR _dwPlayCursor$[ebp]
  000c1	3b 88 3c 01 00
	00		 cmp	 ecx, DWORD PTR [eax+316]
  000c7	73 37		 jae	 SHORT $L37648

; 1806 :         {
; 1807 :             //
; 1808 :             // The play cursor has moved backwards.  We'll assume it's because 
; 1809 :             // we looped.  Signal to the end of the buffer, reset the 
; 1810 :             // notification index to the beginning of the play region, then 
; 1811 :             // signal up to the current position.
; 1812 :             //
; 1813 : 
; 1814 :             NotifyToPosition(dwEndPosition);

  000c9	6a 01		 push	 1
  000cb	8b 55 f8	 mov	 edx, DWORD PTR _dwEndPosition$[ebp]
  000ce	52		 push	 edx
  000cf	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	e8 00 00 00 00	 call	 ?NotifyToPosition@CMcpxBuffer@DirectSound@@IAEXKH@Z ; DirectSound::CMcpxBuffer::NotifyToPosition

; 1815 : 
; 1816 :             m_dwNextNotifyIndex = 0;

  000d7	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000da	c7 80 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+320], 0

; 1817 : 
; 1818 :             NotifyToPosition(dwStartPosition, FALSE);

  000e4	6a 00		 push	 0
  000e6	8b 4d f4	 mov	 ecx, DWORD PTR _dwStartPosition$[ebp]
  000e9	51		 push	 ecx
  000ea	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	e8 00 00 00 00	 call	 ?NotifyToPosition@CMcpxBuffer@DirectSound@@IAEXKH@Z ; DirectSound::CMcpxBuffer::NotifyToPosition

; 1819 :             NotifyToPosition(dwPlayCursor);

  000f2	6a 01		 push	 1
  000f4	8b 55 fc	 mov	 edx, DWORD PTR _dwPlayCursor$[ebp]
  000f7	52		 push	 edx
  000f8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fb	e8 00 00 00 00	 call	 ?NotifyToPosition@CMcpxBuffer@DirectSound@@IAEXKH@Z ; DirectSound::CMcpxBuffer::NotifyToPosition
$L37648:

; 1820 :         }
; 1821 : 
; 1822 :         //
; 1823 :         // If the buffer isn't playing anymore, signal the stop event and
; 1824 :         // unregister for position delta callbacks.
; 1825 :         //
; 1826 : 
; 1827 :         if(!(m_dwStatus & MCPX_VOICESTATUS_ACTIVEORVOICEOFF))

  00100	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00103	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00107	81 e1 02 80 00
	00		 and	 ecx, 32770		; 00008002H
  0010d	85 c9		 test	 ecx, ecx
  0010f	75 15		 jne	 SHORT $L37638

; 1828 :         {
; 1829 :             RemoveDeferredCommand(MCPX_DEFERREDCMD_BUFFER_POSITIONDELTA);

  00111	6a 02		 push	 2
  00113	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00116	8b 02		 mov	 eax, DWORD PTR [edx]
  00118	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1830 :             NotifyStop();

  0011e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	e8 00 00 00 00	 call	 ?NotifyStop@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::NotifyStop
$L37638:

; 1831 :         }
; 1832 :     }
; 1833 : 
; 1834 :     DPF_LEAVE_VOID();
; 1835 : }

  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
?OnPositionDelta@CMcpxBuffer@DirectSound@@IAEXXZ ENDP	; DirectSound::CMcpxBuffer::OnPositionDelta
DSOUND	ENDS
EXTRN	__imp__NtSetEvent@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?NotifyToPosition@CMcpxBuffer@DirectSound@@IAEXKH@Z
DSOUND	SEGMENT
_this$ = -4
_dwPlayCursor$ = 8
_fSignal$ = 12
?NotifyToPosition@CMcpxBuffer@DirectSound@@IAEXKH@Z PROC NEAR ; DirectSound::CMcpxBuffer::NotifyToPosition, COMDAT
; _this$ = ecx

; 1864 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$L37657:

; 1865 :     DPF_ENTER();
; 1866 : 
; 1867 :     ASSERT(m_pSettings->m_dwNotifyCount);
; 1868 :     ASSERT(m_pSettings->m_paNotifies);
; 1869 : 
; 1870 :     while(TRUE)

  00007	b8 01 00 00 00	 mov	 eax, 1
  0000c	85 c0		 test	 eax, eax
  0000e	0f 84 a6 00 00
	00		 je	 $L37658

; 1871 :     {
; 1872 :         if(m_dwNextNotifyIndex >= m_pSettings->m_dwNotifyCount)

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 88 40 01 00
	00		 mov	 ecx, DWORD PTR [eax+320]
  00026	3b 8a d4 00 00
	00		 cmp	 ecx, DWORD PTR [edx+212]
  0002c	72 05		 jb	 SHORT $L37659

; 1873 :         {
; 1874 :             break;

  0002e	e9 87 00 00 00	 jmp	 $L37658
$L37659:

; 1875 :         }
; 1876 :         else if(DSBPN_OFFSETSTOP == m_pSettings->m_paNotifies[m_dwNextNotifyIndex].dwOffset)

  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  00045	8b 80 d0 00 00
	00		 mov	 eax, DWORD PTR [eax+208]
  0004b	83 3c d0 ff	 cmp	 DWORD PTR [eax+edx*8], -1
  0004f	75 02		 jne	 SHORT $L37661

; 1877 :         {
; 1878 :             break;

  00051	eb 67		 jmp	 SHORT $L37658
$L37661:

; 1879 :         }
; 1880 :         else if(m_pSettings->m_paNotifies[m_dwNextNotifyIndex].dwOffset >= dwPlayCursor)

  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 88 40 01 00
	00		 mov	 ecx, DWORD PTR [eax+320]
  00065	8b 92 d0 00 00
	00		 mov	 edx, DWORD PTR [edx+208]
  0006b	8b 04 ca	 mov	 eax, DWORD PTR [edx+ecx*8]
  0006e	3b 45 08	 cmp	 eax, DWORD PTR _dwPlayCursor$[ebp]
  00071	72 02		 jb	 SHORT $L37660

; 1881 :         {
; 1882 :             break;

  00073	eb 45		 jmp	 SHORT $L37658
$L37660:

; 1883 :         }
; 1884 : 
; 1885 :         if(fSignal)

  00075	83 7d 0c 00	 cmp	 DWORD PTR _fSignal$[ebp], 0
  00079	74 25		 je	 SHORT $L37664

; 1886 :         {
; 1887 :             NtSetEvent(m_pSettings->m_paNotifies[m_dwNextNotifyIndex].hEventNotify, NULL);

  0007b	6a 00		 push	 0
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 88 40 01 00
	00		 mov	 ecx, DWORD PTR [eax+320]
  0008f	8b 92 d0 00 00
	00		 mov	 edx, DWORD PTR [edx+208]
  00095	8b 44 ca 04	 mov	 eax, DWORD PTR [edx+ecx*8+4]
  00099	50		 push	 eax
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__NtSetEvent@8
$L37664:

; 1888 :         }
; 1889 : 
; 1890 :         m_dwNextNotifyIndex++;

  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  000a9	83 c2 01	 add	 edx, 1
  000ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000af	89 90 40 01 00
	00		 mov	 DWORD PTR [eax+320], edx

; 1891 :     }

  000b5	e9 4d ff ff ff	 jmp	 $L37657
$L37658:

; 1892 : 
; 1893 :     m_dwLastNotifyPosition = dwPlayCursor;

  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	8b 55 08	 mov	 edx, DWORD PTR _dwPlayCursor$[ebp]
  000c0	89 91 3c 01 00
	00		 mov	 DWORD PTR [ecx+316], edx

; 1894 : 
; 1895 :     DPF_LEAVE_VOID();
; 1896 : }

  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 08 00	 ret	 8
?NotifyToPosition@CMcpxBuffer@DirectSound@@IAEXKH@Z ENDP ; DirectSound::CMcpxBuffer::NotifyToPosition
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?NotifyStop@CMcpxBuffer@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -8
_i$ = -4
?NotifyStop@CMcpxBuffer@DirectSound@@IAEXXZ PROC NEAR	; DirectSound::CMcpxBuffer::NotifyStop, COMDAT
; _this$ = ecx

; 1922 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1923 :     DWORD                   i;
; 1924 : 
; 1925 :     DPF_ENTER();
; 1926 : 
; 1927 :     ASSERT(m_pSettings->m_dwNotifyCount);
; 1928 :     ASSERT(m_pSettings->m_paNotifies);
; 1929 : 
; 1930 :     for(i = m_pSettings->m_dwNotifyCount; i > 0; i--)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00012	8b 91 d4 00 00
	00		 mov	 edx, DWORD PTR [ecx+212]
  00018	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  0001b	eb 09		 jmp	 SHORT $L37670
$L37671:
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00020	83 e8 01	 sub	 eax, 1
  00023	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L37670:
  00026	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0002a	76 3c		 jbe	 SHORT $L37668

; 1931 :     {
; 1932 :         if(DSBPN_OFFSETSTOP != m_pSettings->m_paNotifies[i - 1].dwOffset)

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00035	8b 82 d0 00 00
	00		 mov	 eax, DWORD PTR [edx+208]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0003e	83 7c c8 f8 ff	 cmp	 DWORD PTR [eax+ecx*8-8], -1
  00043	74 02		 je	 SHORT $L37673

; 1933 :         {
; 1934 :             break;

  00045	eb 21		 jmp	 SHORT $L37668
$L37673:

; 1935 :         }
; 1936 : 
; 1937 :         NtSetEvent(m_pSettings->m_paNotifies[i - 1].hEventNotify, NULL);

  00047	6a 00		 push	 0
  00049	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0004c	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00052	8b 88 d0 00 00
	00		 mov	 ecx, DWORD PTR [eax+208]
  00058	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0005b	8b 44 d1 fc	 mov	 eax, DWORD PTR [ecx+edx*8-4]
  0005f	50		 push	 eax
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__NtSetEvent@8

; 1938 :     }

  00066	eb b5		 jmp	 SHORT $L37671
$L37668:

; 1939 : 
; 1940 :     DPF_LEAVE_VOID();
; 1941 : }

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?NotifyStop@CMcpxBuffer@DirectSound@@IAEXXZ ENDP	; DirectSound::CMcpxBuffer::NotifyStop
DSOUND	ENDS
PUBLIC	?ScheduleDeferredCommand@CMcpxAPU@DirectSound@@QAEHPAUMCPX_DEFERRED_COMMAND@@@Z ; DirectSound::CMcpxAPU::ScheduleDeferredCommand
; Function compile flags: /Odt
;	COMDAT ?ScheduleDeferredCommand@CMcpxBuffer@DirectSound@@MAEHK_JK@Z
DSOUND	SEGMENT
_this$ = -12
_fScheduled$ = -8
_pCmd$ = -4
_dwCommand$ = 8
_rtTimeStamp$ = 12
_dwContext$ = 20
?ScheduleDeferredCommand@CMcpxBuffer@DirectSound@@MAEHK_JK@Z PROC NEAR ; DirectSound::CMcpxBuffer::ScheduleDeferredCommand, COMDAT
; _this$ = ecx

; 1973 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1974 :     LPMCPX_DEFERRED_COMMAND pCmd        = &m_aDeferredCommands[dwCommand];

  00009	8b 45 08	 mov	 eax, DWORD PTR _dwCommand$[ebp]
  0000c	c1 e0 05	 shl	 eax, 5
  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8d 94 01 98 00
	00 00		 lea	 edx, DWORD PTR [ecx+eax+152]
  00019	89 55 fc	 mov	 DWORD PTR _pCmd$[ebp], edx

; 1975 :     BOOL                    fScheduled;
; 1976 : 
; 1977 :     DPF_ENTER();
; 1978 :     
; 1979 :     ASSERT(dwCommand < NUMELMS(m_aDeferredCommands));
; 1980 : 
; 1981 :     pCmd->rtTimestamp = rtTimeStamp;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _pCmd$[ebp]
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _rtTimeStamp$[ebp]
  00022	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00025	8b 55 10	 mov	 edx, DWORD PTR _rtTimeStamp$[ebp+4]
  00028	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 1982 :     pCmd->dwContext = dwContext;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _pCmd$[ebp]
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR _dwContext$[ebp]
  00031	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1983 : 
; 1984 :     if(fScheduled = m_pMcpxApu->ScheduleDeferredCommand(pCmd))

  00034	8b 55 fc	 mov	 edx, DWORD PTR _pCmd$[ebp]
  00037	52		 push	 edx
  00038	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003e	e8 00 00 00 00	 call	 ?ScheduleDeferredCommand@CMcpxAPU@DirectSound@@QAEHPAUMCPX_DEFERRED_COMMAND@@@Z ; DirectSound::CMcpxAPU::ScheduleDeferredCommand
  00043	89 45 f8	 mov	 DWORD PTR _fScheduled$[ebp], eax

; 1985 :     {
; 1986 :         DPF_BLAB("Voice %x (%x) scheduled command %lu", this, m_ahVoices[0], dwCommand);
; 1987 :     }
; 1988 : 
; 1989 :     DPF_LEAVE(fScheduled);
; 1990 : 
; 1991 :     return fScheduled;

  00046	8b 45 f8	 mov	 eax, DWORD PTR _fScheduled$[ebp]

; 1992 : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 10 00	 ret	 16			; 00000010H
?ScheduleDeferredCommand@CMcpxBuffer@DirectSound@@MAEHK_JK@Z ENDP ; DirectSound::CMcpxBuffer::ScheduleDeferredCommand
DSOUND	ENDS
PUBLIC	?RemoveDeferredCommand@CMcpxAPU@DirectSound@@QAEXPAUMCPX_DEFERRED_COMMAND@@@Z ; DirectSound::CMcpxAPU::RemoveDeferredCommand
; Function compile flags: /Odt
;	COMDAT ?RemoveDeferredCommand@CMcpxBuffer@DirectSound@@MAEXK@Z
DSOUND	SEGMENT
_this$ = -4
_dwCommand$ = 8
?RemoveDeferredCommand@CMcpxBuffer@DirectSound@@MAEXK@Z PROC NEAR ; DirectSound::CMcpxBuffer::RemoveDeferredCommand, COMDAT
; _this$ = ecx

; 2018 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2019 :     DPF_ENTER();
; 2020 : 
; 2021 :     ASSERT(dwCommand < NUMELMS(m_aDeferredCommands));
; 2022 : 
; 2023 :     if(m_aDeferredCommands[dwCommand].dwFlags & MCPX_DEFERREDCMDF_SCHEDULED)
; 2024 :     {
; 2025 :         DPF_BLAB("Voice %x (%x) unscheduling command %lu", this, m_ahVoices[0], dwCommand);
; 2026 :     }
; 2027 :     
; 2028 :     m_pMcpxApu->RemoveDeferredCommand(&m_aDeferredCommands[dwCommand]);

  00007	8b 45 08	 mov	 eax, DWORD PTR _dwCommand$[ebp]
  0000a	c1 e0 05	 shl	 eax, 5
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	8d 94 01 98 00
	00 00		 lea	 edx, DWORD PTR [ecx+eax+152]
  00017	52		 push	 edx
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001e	e8 00 00 00 00	 call	 ?RemoveDeferredCommand@CMcpxAPU@DirectSound@@QAEXPAUMCPX_DEFERRED_COMMAND@@@Z ; DirectSound::CMcpxAPU::RemoveDeferredCommand

; 2029 : 
; 2030 :     DPF_LEAVE_VOID();
; 2031 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?RemoveDeferredCommand@CMcpxBuffer@DirectSound@@MAEXK@Z ENDP ; DirectSound::CMcpxBuffer::RemoveDeferredCommand
DSOUND	ENDS
PUBLIC	?CheckStuckVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::CheckStuckVoice
PUBLIC	?OnDeferredTerminate@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::OnDeferredTerminate
; Function compile flags: /Odt
;	COMDAT ?ServiceDeferredCommand@CMcpxBuffer@DirectSound@@MAEXKK@Z
DSOUND	SEGMENT
tv64 = -8
_this$ = -4
_dwCommand$ = 8
_dwContext$ = 12
?ServiceDeferredCommand@CMcpxBuffer@DirectSound@@MAEXKK@Z PROC NEAR ; DirectSound::CMcpxBuffer::ServiceDeferredCommand, COMDAT
; _this$ = ecx

; 2059 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2060 :     DPF_ENTER();
; 2061 :     
; 2062 :     switch(dwCommand)
; 2063 :     {

  00009	8b 45 08	 mov	 eax, DWORD PTR _dwCommand$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR tv64[ebp], eax
  0000f	83 7d f8 04	 cmp	 DWORD PTR tv64[ebp], 4
  00013	77 42		 ja	 SHORT $L37692
  00015	8b 4d f8	 mov	 ecx, DWORD PTR tv64[ebp]
  00018	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L42083[ecx*4]
$L37697:

; 2064 :         case MCPX_DEFERREDCMD_BUFFER_PLAY:
; 2065 :             Play(dwContext);

  0001f	8b 55 0c	 mov	 edx, DWORD PTR _dwContext$[ebp]
  00022	52		 push	 edx
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?Play@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::Play

; 2066 :             break;

  0002b	eb 2a		 jmp	 SHORT $L37692
$L37698:

; 2067 : 
; 2068 :         case MCPX_DEFERREDCMD_BUFFER_STOP:
; 2069 :             Stop(dwContext);

  0002d	8b 45 0c	 mov	 eax, DWORD PTR _dwContext$[ebp]
  00030	50		 push	 eax
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?Stop@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::Stop

; 2070 :             break;

  00039	eb 1c		 jmp	 SHORT $L37692
$L37699:

; 2071 : 
; 2072 :         case MCPX_DEFERREDCMD_BUFFER_POSITIONDELTA:
; 2073 :             OnPositionDelta();

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?OnPositionDelta@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::OnPositionDelta

; 2074 :             break;

  00043	eb 12		 jmp	 SHORT $L37692
$L37700:

; 2075 : 
; 2076 :         case MCPX_DEFERREDCMD_BUFFER_RELEASERESOURCES:
; 2077 :             OnDeferredTerminate();

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?OnDeferredTerminate@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::OnDeferredTerminate

; 2078 :             break;

  0004d	eb 08		 jmp	 SHORT $L37692
$L37701:

; 2079 : 
; 2080 :         case MCPX_DEFERREDCMD_BUFFER_CHECKSTUCK:
; 2081 :             CheckStuckVoice();

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?CheckStuckVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::CheckStuckVoice
$L37692:

; 2082 :             break;
; 2083 : 
; 2084 :         default:
; 2085 :             ASSERTMSG("Unexpected deferred command identifier");
; 2086 :             break;
; 2087 :     }
; 2088 : 
; 2089 :     DPF_LEAVE_VOID();
; 2090 : }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
$L42083:
  0005d	00 00 00 00	 DD	 $L37701
  00061	00 00 00 00	 DD	 $L37700
  00065	00 00 00 00	 DD	 $L37699
  00069	00 00 00 00	 DD	 $L37697
  0006d	00 00 00 00	 DD	 $L37698
?ServiceDeferredCommand@CMcpxBuffer@DirectSound@@MAEXKK@Z ENDP ; DirectSound::CMcpxBuffer::ServiceDeferredCommand
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?OnDeferredTerminate@CMcpxBuffer@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -4
?OnDeferredTerminate@CMcpxBuffer@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxBuffer::OnDeferredTerminate, COMDAT
; _this$ = ecx

; 2116 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2117 :     DPF_ENTER();
; 2118 : 
; 2119 :     if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  0000e	83 e1 01	 and	 ecx, 1
  00011	85 c9		 test	 ecx, ecx
  00013	74 1a		 je	 SHORT $L37707

; 2120 :     {
; 2121 :         if(!(m_dwStatus & MCPX_VOICESTATUS_ACTIVEORVOICEOFF))

  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  0001c	25 02 80 00 00	 and	 eax, 32770		; 00008002H
  00021	85 c0		 test	 eax, eax
  00023	75 08		 jne	 SHORT $L37708

; 2122 :         {
; 2123 :             ReleaseBufferResources();

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?ReleaseBufferResources@CMcpxBuffer@DirectSound@@IAEXXZ ; DirectSound::CMcpxBuffer::ReleaseBufferResources
$L37708:

; 2124 :         }
; 2125 :     }
; 2126 :     else

  0002d	eb 0d		 jmp	 SHORT $L37706
$L37707:

; 2127 :     {
; 2128 :         RemoveDeferredCommand(MCPX_DEFERREDCMD_BUFFER_RELEASERESOURCES);

  0002f	6a 01		 push	 1
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	ff 52 1c	 call	 DWORD PTR [edx+28]
$L37706:

; 2129 :     }
; 2130 : 
; 2131 :     DPF_LEAVE_VOID();
; 2132 : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?OnDeferredTerminate@CMcpxBuffer@DirectSound@@IAEXXZ ENDP ; DirectSound::CMcpxBuffer::OnDeferredTerminate
DSOUND	ENDS
PUBLIC	??0CMcpxBufferSgeHeap@DirectSound@@QAE@XZ	; DirectSound::CMcpxBufferSgeHeap::CMcpxBufferSgeHeap
PUBLIC	??_ECMcpxAPU@DirectSound@@W7AEPAXI@Z		; DirectSound::CMcpxAPU::`vector deleting destructor'
PUBLIC	??_7CMcpxAPU@DirectSound@@6BCRefCount@1@@	; DirectSound::CMcpxAPU::`vftable'
PUBLIC	??_7CMcpxAPU@DirectSound@@6BCMcpxCore@1@@	; DirectSound::CMcpxAPU::`vftable'
PUBLIC	??_GCMcpxAPU@DirectSound@@UAEPAXI@Z		; DirectSound::CMcpxAPU::`scalar deleting destructor'
PUBLIC	??0CMcpxCore@DirectSound@@QAE@PAVCDirectSoundSettings@1@@Z ; DirectSound::CMcpxCore::CMcpxCore
EXTRN	??_ECMcpxAPU@DirectSound@@UAEPAXI@Z:NEAR	; DirectSound::CMcpxAPU::`vector deleting destructor'
;	COMDAT ??_7CMcpxAPU@DirectSound@@6BCRefCount@1@@
; File c:\xbox\private\windows\directx\dsound\dsound\mcpapu.cpp
CONST	SEGMENT
??_7CMcpxAPU@DirectSound@@6BCRefCount@1@@ DD FLAT:??_ECMcpxAPU@DirectSound@@UAEPAXI@Z ; DirectSound::CMcpxAPU::`vftable'
	DD	FLAT:?AddRef@CRefCount@DirectSound@@UAGKXZ
	DD	FLAT:?Release@CRefCount@DirectSound@@UAGKXZ
CONST	ENDS
;	COMDAT ??_7CMcpxAPU@DirectSound@@6BCMcpxCore@1@@
CONST	SEGMENT
??_7CMcpxAPU@DirectSound@@6BCMcpxCore@1@@ DD FLAT:??_ECMcpxAPU@DirectSound@@W7AEPAXI@Z ; DirectSound::CMcpxAPU::`vftable'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CMcpxAPU@DirectSound@@QAE@PAVCDirectSoundSettings@1@@Z
DSOUND	SEGMENT
_this$ = -8
_i$ = -4
_pSettings$ = 8
??0CMcpxAPU@DirectSound@@QAE@PAVCDirectSoundSettings@1@@Z PROC NEAR ; DirectSound::CMcpxAPU::CMcpxAPU, COMDAT
; _this$ = ecx

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0000a	6a 01		 push	 1
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0CRefCount@DirectSound@@QAE@K@Z ; DirectSound::CRefCount::CRefCount
  00014	8b 45 08	 mov	 eax, DWORD PTR _pSettings$[ebp]
  00017	50		 push	 eax
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 08	 add	 ecx, 8
  0001e	e8 00 00 00 00	 call	 ??0CMcpxCore@DirectSound@@QAE@PAVCDirectSoundSettings@1@@Z ; DirectSound::CMcpxCore::CMcpxCore
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CMcpxAPU@DirectSound@@6BCRefCount@1@@
  0002c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET FLAT:??_7CMcpxAPU@DirectSound@@6BCMcpxCore@1@@
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], OFFSET FLAT:_g_dwDirectSoundFree2dVoices
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], OFFSET FLAT:_g_dwDirectSoundFree3dVoices
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 64	 add	 ecx, 100		; 00000064H
  00050	e8 00 00 00 00	 call	 ??0CMcpxBufferSgeHeap@DirectSound@@QAE@XZ ; DirectSound::CMcpxBufferSgeHeap::CMcpxBufferSgeHeap

; 63   :     DWORD                   i;
; 64   :     
; 65   :     DPF_ENTER();
; 66   :     
; 67   :     //
; 68   :     // Initialize defaults
; 69   :     //
; 70   :     
; 71   :     for(i = 0; i < NUMELMS(m_alstActiveVoices); i++)

  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0005c	eb 09		 jmp	 SHORT $L37716
$L37717:
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00061	83 c2 01	 add	 edx, 1
  00064	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L37716:
  00067	83 7d fc 03	 cmp	 DWORD PTR _i$[ebp], 3
  0006b	73 36		 jae	 SHORT $L37718

; 72   :     {
; 73   :         InitializeListHead(&m_alstActiveVoices[i]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00070	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	8d 94 c1 8c 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+1164]
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0007d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	89 94 c1 90 04
	00 00		 mov	 DWORD PTR [ecx+eax*8+1168], edx
  00087	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0008a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00090	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00093	8b 8c ce 90 04
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*8+1168]
  0009a	89 8c d0 8c 04
	00 00		 mov	 DWORD PTR [eax+edx*8+1164], ecx

; 74   :     }

  000a1	eb bb		 jmp	 SHORT $L37717
$L37718:

; 75   : 
; 76   :     InitializeListHead(&m_lstPendingInactiveVoices);

  000a3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a6	81 c2 a4 04 00
	00		 add	 edx, 1188		; 000004a4H
  000ac	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000af	89 90 a8 04 00
	00		 mov	 DWORD PTR [eax+1192], edx
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000bb	8b 82 a8 04 00
	00		 mov	 eax, DWORD PTR [edx+1192]
  000c1	89 81 a4 04 00
	00		 mov	 DWORD PTR [ecx+1188], eax

; 77   :     InitializeListHead(&m_lstDeferredCommandsHigh);

  000c7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	81 c1 ac 04 00
	00		 add	 ecx, 1196		; 000004acH
  000d0	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000d3	89 8a b0 04 00
	00		 mov	 DWORD PTR [edx+1200], ecx
  000d9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	8b 91 b0 04 00
	00		 mov	 edx, DWORD PTR [ecx+1200]
  000e5	89 90 ac 04 00
	00		 mov	 DWORD PTR [eax+1196], edx

; 78   :     InitializeListHead(&m_lstDeferredCommandsLow);

  000eb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ee	05 b4 04 00 00	 add	 eax, 1204		; 000004b4H
  000f3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	89 81 b8 04 00
	00		 mov	 DWORD PTR [ecx+1208], eax
  000fc	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ff	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00102	8b 88 b8 04 00
	00		 mov	 ecx, DWORD PTR [eax+1208]
  00108	89 8a b4 04 00
	00		 mov	 DWORD PTR [edx+1204], ecx

; 79   : 
; 80   :     m_dwFree2dVoiceCount = MCPX_HW_MAX_2D_VOICES;

  0010e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00111	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00114	c7 00 c0 00 00
	00		 mov	 DWORD PTR [eax], 192	; 000000c0H

; 81   :     m_dwFree3dVoiceCount = MCPX_HW_MAX_3D_VOICES;

  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00120	c7 02 40 00 00
	00		 mov	 DWORD PTR [edx], 64	; 00000040H

; 82   : 
; 83   :     DPF_LEAVE_VOID();
; 84   : }

  00126	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00129	5e		 pop	 esi
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c2 04 00	 ret	 4
??0CMcpxAPU@DirectSound@@QAE@PAVCDirectSoundSettings@1@@Z ENDP ; DirectSound::CMcpxAPU::CMcpxAPU
DSOUND	ENDS
PUBLIC	??1CMcpxAPU@DirectSound@@UAE@XZ			; DirectSound::CMcpxAPU::~CMcpxAPU
; Function compile flags: /Odt
;	COMDAT ??_GCMcpxAPU@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCMcpxAPU@DirectSound@@UAEPAXI@Z PROC NEAR		; DirectSound::CMcpxAPU::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMcpxAPU@DirectSound@@UAE@XZ ; DirectSound::CMcpxAPU::~CMcpxAPU
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L37722
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L37722:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCMcpxAPU@DirectSound@@UAEPAXI@Z ENDP		; DirectSound::CMcpxAPU::`scalar deleting destructor'
DSOUND	ENDS
PUBLIC	??1CMcpxBufferSgeHeap@DirectSound@@UAE@XZ	; DirectSound::CMcpxBufferSgeHeap::~CMcpxBufferSgeHeap
PUBLIC	?Terminate@CMcpxAPU@DirectSound@@IAEXXZ		; DirectSound::CMcpxAPU::Terminate
PUBLIC	??1CMcpxCore@DirectSound@@UAE@XZ		; DirectSound::CMcpxCore::~CMcpxCore
EXTRN	__imp__HalRegisterShutdownNotification@8:NEAR
EXTRN	__imp__KeRemoveQueueDpc@4:NEAR
EXTRN	__imp__KeDisconnectInterrupt@4:NEAR
EXTRN	__imp__KeCancelTimer@4:NEAR
; Function compile flags: /Odt
;	COMDAT ??1CMcpxAPU@DirectSound@@UAE@XZ
DSOUND	SEGMENT
tv68 = -8
_this$ = -4
??1CMcpxAPU@DirectSound@@UAE@XZ PROC NEAR		; DirectSound::CMcpxAPU::~CMcpxAPU, COMDAT
; _this$ = ecx

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMcpxAPU@DirectSound@@6BCRefCount@1@@
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET FLAT:??_7CMcpxAPU@DirectSound@@6BCMcpxCore@1@@

; 110  :     DPF_ENTER();
; 111  : 
; 112  :     DPF_INFO("APU going away...");
; 113  : 
; 114  :     //
; 115  :     // Shut down the APU
; 116  :     //
; 117  : 
; 118  :     Terminate();

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?Terminate@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::Terminate

; 119  : 
; 120  :     //
; 121  :     // Disconnect the interrupt handler
; 122  :     //
; 123  : 
; 124  :     if(m_Interrupt.ServiceRoutine)

  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_Interrupt@CMcpxAPU@DirectSound@@1U_KINTERRUPT@@A, 0
  0002b	74 15		 je	 SHORT $L37727

; 125  :     {
; 126  :         KeDisconnectInterrupt(&m_Interrupt);

  0002d	68 00 00 00 00	 push	 OFFSET FLAT:?m_Interrupt@CMcpxAPU@DirectSound@@1U_KINTERRUPT@@A ; DirectSound::CMcpxAPU::m_Interrupt
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeDisconnectInterrupt@4

; 127  :         m_Interrupt.ServiceRoutine = NULL;

  00038	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_Interrupt@CMcpxAPU@DirectSound@@1U_KINTERRUPT@@A, 0
$L37727:

; 128  :     }
; 129  : 
; 130  :     //
; 131  :     // Cancel timers
; 132  :     //
; 133  : 
; 134  :     KeCancelTimer(&m_tmrDeferredCommandsHigh);

  00042	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00045	81 c2 e8 04 00
	00		 add	 edx, 1256		; 000004e8H
  0004b	52		 push	 edx
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeCancelTimer@4

; 135  : 
; 136  :     //
; 137  :     // Clear any pending DPCs
; 138  :     //
; 139  : 
; 140  :     if(DpcObject == m_dpcInterrupt.Type)

  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	0f bf 88 cc 04
	00 00		 movsx	 ecx, WORD PTR [eax+1228]
  0005c	83 f9 13	 cmp	 ecx, 19			; 00000013H
  0005f	75 26		 jne	 SHORT $L37728

; 141  :     {
; 142  :         KeRemoveQueueDpc(&m_dpcInterrupt);

  00061	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00064	81 c2 cc 04 00
	00		 add	 edx, 1228		; 000004ccH
  0006a	52		 push	 edx
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeRemoveQueueDpc@4

; 143  :         m_dpcInterrupt.Type = ~m_dpcInterrupt.Type;

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	0f bf 88 cc 04
	00 00		 movsx	 ecx, WORD PTR [eax+1228]
  0007b	f7 d1		 not	 ecx
  0007d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00080	66 89 8a cc 04
	00 00		 mov	 WORD PTR [edx+1228], cx
$L37728:

; 144  :     }
; 145  : 
; 146  :     if(DpcObject == m_dpcDeferredCommandsHigh.Type)

  00087	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	0f bf 88 10 05
	00 00		 movsx	 ecx, WORD PTR [eax+1296]
  00091	83 f9 13	 cmp	 ecx, 19			; 00000013H
  00094	75 26		 jne	 SHORT $L37729

; 147  :     {
; 148  :         KeRemoveQueueDpc(&m_dpcDeferredCommandsHigh);

  00096	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00099	81 c2 10 05 00
	00		 add	 edx, 1296		; 00000510H
  0009f	52		 push	 edx
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeRemoveQueueDpc@4

; 149  :         m_dpcDeferredCommandsHigh.Type = ~m_dpcInterrupt.Type;

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	0f bf 88 cc 04
	00 00		 movsx	 ecx, WORD PTR [eax+1228]
  000b0	f7 d1		 not	 ecx
  000b2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b5	66 89 8a 10 05
	00 00		 mov	 WORD PTR [edx+1296], cx
$L37729:

; 150  :     }
; 151  : 
; 152  :     //
; 153  :     // Unregister the shutdown handler
; 154  :     //
; 155  : 
; 156  :     if(m_HalShutdownData.NotificationRoutine)

  000bc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	83 b8 2c 05 00
	00 00		 cmp	 DWORD PTR [eax+1324], 0
  000c6	74 1f		 je	 SHORT $L37730

; 157  :     {
; 158  :         HalRegisterShutdownNotification(&m_HalShutdownData, FALSE);

  000c8	6a 00		 push	 0
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	81 c1 2c 05 00
	00		 add	 ecx, 1324		; 0000052cH
  000d3	51		 push	 ecx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HalRegisterShutdownNotification@8

; 159  :         m_HalShutdownData.NotificationRoutine = NULL;

  000da	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000dd	c7 82 2c 05 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1324], 0
$L37730:

; 160  :     }
; 161  : 
; 162  :     m_dwFree2dVoiceCount = 0;

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ea	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000ed	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 163  :     m_dwFree3dVoiceCount = 0;

  000f3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f6	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  000f9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 164  : 
; 165  :     DPF_LEAVE_VOID();
; 166  : }

  000ff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	83 c1 64	 add	 ecx, 100		; 00000064H
  00105	e8 00 00 00 00	 call	 ??1CMcpxBufferSgeHeap@DirectSound@@UAE@XZ ; DirectSound::CMcpxBufferSgeHeap::~CMcpxBufferSgeHeap
  0010a	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  0010e	74 0b		 je	 SHORT $L42096
  00110	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00113	83 c1 08	 add	 ecx, 8
  00116	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  00119	eb 07		 jmp	 SHORT $L42097
$L42096:
  0011b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$L42097:
  00122	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  00125	e8 00 00 00 00	 call	 ??1CMcpxCore@DirectSound@@UAE@XZ ; DirectSound::CMcpxCore::~CMcpxCore
  0012a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	e8 00 00 00 00	 call	 ??1CRefCount@DirectSound@@UAE@XZ ; DirectSound::CRefCount::~CRefCount
  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c3		 ret	 0
??1CMcpxAPU@DirectSound@@UAE@XZ ENDP			; DirectSound::CMcpxAPU::~CMcpxAPU
DSOUND	ENDS
PUBLIC	?Initialize@CMcpxBufferSgeHeap@DirectSound@@QAEJG@Z ; DirectSound::CMcpxBufferSgeHeap::Initialize
PUBLIC	?SetHrtfHeadroom@CMcpxAPU@DirectSound@@QAEJK@Z	; DirectSound::CMcpxAPU::SetHrtfHeadroom
PUBLIC	?ApuInterruptServiceRoutine@CMcpxAPU@DirectSound@@CGEPAU_KINTERRUPT@@PAX@Z ; DirectSound::CMcpxAPU::ApuInterruptServiceRoutine
PUBLIC	?ApuInterruptDpcRoutine@CMcpxAPU@DirectSound@@CGXPAU_KDPC@@PAX11@Z ; DirectSound::CMcpxAPU::ApuInterruptDpcRoutine
PUBLIC	?DeferredCommandDpcRoutine@CMcpxAPU@DirectSound@@CGXPAU_KDPC@@PAX11@Z ; DirectSound::CMcpxAPU::DeferredCommandDpcRoutine
PUBLIC	?ApuShutdownNotifier@CMcpxAPU@DirectSound@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z ; DirectSound::CMcpxAPU::ApuShutdownNotifier
PUBLIC	?Initialize@CMcpxCore@DirectSound@@QAEJXZ	; DirectSound::CMcpxCore::Initialize
PUBLIC	?SetInterruptState@CMcpxCore@DirectSound@@IAEXH@Z ; DirectSound::CMcpxCore::SetInterruptState
EXTRN	__imp__HalGetInterruptVector@8:NEAR
EXTRN	__imp__KeInitializeDpc@12:NEAR
EXTRN	__imp__KeInitializeInterrupt@28:NEAR
EXTRN	__imp__KeConnectInterrupt@4:NEAR
EXTRN	__imp__KeInitializeTimerEx@8:NEAR
; Function compile flags: /Odt
;	COMDAT ?Initialize@CMcpxAPU@DirectSound@@QAEJXZ
DSOUND	SEGMENT
_this$ = -20
_hr$ = -16
_i$ = -12
_ulInterruptVector$ = -8
_irql$ = -1
?Initialize@CMcpxAPU@DirectSound@@QAEJXZ PROC NEAR	; DirectSound::CMcpxAPU::Initialize, COMDAT
; _this$ = ecx

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 193  :     ULONG                   ulInterruptVector;
; 194  :     KIRQL                   irql;
; 195  :     HRESULT                 hr;
; 196  :     DWORD                   i;
; 197  : 
; 198  :     //
; 199  :     // Initialize the APU core
; 200  :     //
; 201  : 
; 202  :     hr = CMcpxCore::Initialize();

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 08	 add	 ecx, 8
  0000f	e8 00 00 00 00	 call	 ?Initialize@CMcpxCore@DirectSound@@QAEJXZ ; DirectSound::CMcpxCore::Initialize
  00014	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 203  : 
; 204  :     //
; 205  :     // Create the buffer SGE heap.  We're only managing 2047 markers because
; 206  :     // the 2048th is reserved for FXIN buffers.
; 207  :     //
; 208  : 
; 209  :     if(SUCCEEDED(hr))

  00017	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0001b	7c 13		 jl	 SHORT $L37740

; 210  :     {
; 211  :         hr = m_SgeHeap.Initialize(MCPX_HW_MAX_BUFFER_PRDS - 1);

  0001d	68 ff 07 00 00	 push	 2047			; 000007ffH
  00022	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 64	 add	 ecx, 100		; 00000064H
  00028	e8 00 00 00 00	 call	 ?Initialize@CMcpxBufferSgeHeap@DirectSound@@QAEJG@Z ; DirectSound::CMcpxBufferSgeHeap::Initialize
  0002d	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
$L37740:

; 212  :     }
; 213  : 
; 214  :     //
; 215  :     // Set up timers and DPCs
; 216  :     //
; 217  :     
; 218  : 	if(SUCCEEDED(hr))

  00030	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00034	7c 44		 jl	 SHORT $L37742

; 219  :     {
; 220  :         KeInitializeDpc(&m_dpcInterrupt, ApuInterruptDpcRoutine, this);

  00036	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:?ApuInterruptDpcRoutine@CMcpxAPU@DirectSound@@CGXPAU_KDPC@@PAX11@Z ; DirectSound::CMcpxAPU::ApuInterruptDpcRoutine
  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	81 c1 cc 04 00
	00		 add	 ecx, 1228		; 000004ccH
  00048	51		 push	 ecx
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeDpc@12

; 221  :         KeInitializeTimer(&m_tmrDeferredCommandsHigh);

  0004f	6a 00		 push	 0
  00051	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00054	81 c2 e8 04 00
	00		 add	 edx, 1256		; 000004e8H
  0005a	52		 push	 edx
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeTimerEx@8

; 222  :         KeInitializeDpc(&m_dpcDeferredCommandsHigh, DeferredCommandDpcRoutine, this);

  00061	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00064	50		 push	 eax
  00065	68 00 00 00 00	 push	 OFFSET FLAT:?DeferredCommandDpcRoutine@CMcpxAPU@DirectSound@@CGXPAU_KDPC@@PAX11@Z ; DirectSound::CMcpxAPU::DeferredCommandDpcRoutine
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	81 c1 10 05 00
	00		 add	 ecx, 1296		; 00000510H
  00073	51		 push	 ecx
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeDpc@12
$L37742:

; 223  :     }
; 224  : 
; 225  : 	//
; 226  :     // Hook and enable interrupts
; 227  :     //
; 228  : 
; 229  :     if(SUCCEEDED(hr))

  0007a	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0007e	7c 48		 jl	 SHORT $L37744

; 230  :     {
; 231  :         ulInterruptVector = HalGetInterruptVector(XPCICFG_APU_IRQ, &irql);

  00080	8d 55 ff	 lea	 edx, DWORD PTR _irql$[ebp]
  00083	52		 push	 edx
  00084	6a 05		 push	 5
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HalGetInterruptVector@8
  0008c	89 45 f8	 mov	 DWORD PTR _ulInterruptVector$[ebp], eax

; 232  : 
; 233  :         KeInitializeInterrupt(&m_Interrupt, ApuInterruptServiceRoutine, this, ulInterruptVector, irql, LevelSensitive, TRUE);

  0008f	6a 01		 push	 1
  00091	6a 00		 push	 0
  00093	8a 45 ff	 mov	 al, BYTE PTR _irql$[ebp]
  00096	50		 push	 eax
  00097	8b 4d f8	 mov	 ecx, DWORD PTR _ulInterruptVector$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0009e	52		 push	 edx
  0009f	68 00 00 00 00	 push	 OFFSET FLAT:?ApuInterruptServiceRoutine@CMcpxAPU@DirectSound@@CGEPAU_KINTERRUPT@@PAX@Z ; DirectSound::CMcpxAPU::ApuInterruptServiceRoutine
  000a4	68 00 00 00 00	 push	 OFFSET FLAT:?m_Interrupt@CMcpxAPU@DirectSound@@1U_KINTERRUPT@@A ; DirectSound::CMcpxAPU::m_Interrupt
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeInterrupt@28

; 234  : 
; 235  :         if(!KeConnectInterrupt(&m_Interrupt))

  000af	68 00 00 00 00	 push	 OFFSET FLAT:?m_Interrupt@CMcpxAPU@DirectSound@@1U_KINTERRUPT@@A ; DirectSound::CMcpxAPU::m_Interrupt
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeConnectInterrupt@4
  000ba	0f b6 c0	 movzx	 eax, al
  000bd	85 c0		 test	 eax, eax
  000bf	75 07		 jne	 SHORT $L37744

; 236  :         {
; 237  :             DPF_ERROR("KeConnectInterrupt failed");
; 238  :             hr = DSERR_GENERIC;

  000c1	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L37744:

; 239  :         }
; 240  :     }
; 241  : 
; 242  :     if(SUCCEEDED(hr))

  000c8	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000cc	7c 0a		 jl	 SHORT $L37748

; 243  :     {
; 244  :         MCPX_REG_WRITE(NV_PAPU_ISTS, ~0UL);

  000ce	c7 05 00 10 80
	fe ff ff ff ff	 mov	 DWORD PTR ds:-25161728, -1
$L37748:

; 245  :     }
; 246  : 
; 247  :     if(SUCCEEDED(hr))

  000d8	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000dc	7c 0d		 jl	 SHORT $L37752

; 248  :     {
; 249  :         SetInterruptState(TRUE);

  000de	6a 01		 push	 1
  000e0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	83 c1 08	 add	 ecx, 8
  000e6	e8 00 00 00 00	 call	 ?SetInterruptState@CMcpxCore@DirectSound@@IAEXH@Z ; DirectSound::CMcpxCore::SetInterruptState
$L37752:

; 250  :     }
; 251  : 
; 252  :     //
; 253  :     // Register for HAL shutdown notification
; 254  :     //
; 255  : 
; 256  :     if(SUCCEEDED(hr))

  000eb	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ef	7c 1f		 jl	 SHORT $L37754

; 257  :     {
; 258  :         m_HalShutdownData.NotificationRoutine = ApuShutdownNotifier;

  000f1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	c7 81 2c 05 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1324], OFFSET FLAT:?ApuShutdownNotifier@CMcpxAPU@DirectSound@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z ; DirectSound::CMcpxAPU::ApuShutdownNotifier

; 259  : 
; 260  :         HalRegisterShutdownNotification(&m_HalShutdownData, TRUE);

  000fe	6a 01		 push	 1
  00100	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00103	81 c2 2c 05 00
	00		 add	 edx, 1324		; 0000052cH
  00109	52		 push	 edx
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HalRegisterShutdownNotification@8
$L37754:

; 261  :     }
; 262  : 
; 263  :     //
; 264  :     // Set default headroom values
; 265  :     //
; 266  : 
; 267  :     if(SUCCEEDED(hr))

  00110	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00114	7c 0d		 jl	 SHORT $L37756

; 268  :     {
; 269  :         hr = SetHrtfHeadroom(0);

  00116	6a 00		 push	 0
  00118	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	e8 00 00 00 00	 call	 ?SetHrtfHeadroom@CMcpxAPU@DirectSound@@QAEJK@Z ; DirectSound::CMcpxAPU::SetHrtfHeadroom
  00120	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
$L37756:

; 270  :     }
; 271  : 
; 272  :     for(i = 0; (i < NUMELMS(m_pSettings->m_abMixBinHeadroom)) && SUCCEEDED(hr); i++)

  00123	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0012a	eb 09		 jmp	 SHORT $L37758
$L37759:
  0012c	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0012f	83 c0 01	 add	 eax, 1
  00132	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$L37758:
  00135	83 7d f4 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00139	73 17		 jae	 SHORT $L37760
  0013b	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0013f	7c 11		 jl	 SHORT $L37760

; 273  :     {
; 274  :         hr = SetMixBinHeadroom(i);

  00141	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00144	51		 push	 ecx
  00145	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00148	e8 00 00 00 00	 call	 ?SetMixBinHeadroom@CMcpxAPU@DirectSound@@QAEJK@Z ; DirectSound::CMcpxAPU::SetMixBinHeadroom
  0014d	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 275  :     }

  00150	eb da		 jmp	 SHORT $L37759
$L37760:

; 276  : 
; 277  : #ifndef MCPX_BOOT_LIB
; 278  : 
; 279  :     //
; 280  :     // Set up the HRTF listener
; 281  :     //
; 282  : 
; 283  :     if(SUCCEEDED(hr))
; 284  :     {
; 285  :         if(DSSPEAKER_IS_HEADPHONES(m_pSettings->m_dwSpeakerConfig))
; 286  :         {
; 287  :             m_fSurround = FALSE;
; 288  :         }
; 289  :         else
; 290  :         {
; 291  :             m_fSurround = DSSPEAKER_IS_SURROUND(m_pSettings->m_dwSpeakerConfig);
; 292  :         }
; 293  :     }
; 294  : 
; 295  : #endif // MCPX_BOOT_LIB
; 296  : 
; 297  :     DPF_LEAVE_HRESULT(hr);
; 298  : 
; 299  : 	return hr;

  00152	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]

; 300  : }

  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c3		 ret	 0
?Initialize@CMcpxAPU@DirectSound@@QAEJXZ ENDP		; DirectSound::CMcpxAPU::Initialize
DSOUND	ENDS
PUBLIC	?ServiceApuInterrupt@CMcpxAPU@DirectSound@@IAEHXZ ; DirectSound::CMcpxAPU::ServiceApuInterrupt
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpapu.h
;	COMDAT ?ApuInterruptServiceRoutine@CMcpxAPU@DirectSound@@CGEPAU_KINTERRUPT@@PAX@Z
DSOUND	SEGMENT
_pInterrupt$ = 8
_pvContext$ = 12
?ApuInterruptServiceRoutine@CMcpxAPU@DirectSound@@CGEPAU_KINTERRUPT@@PAX@Z PROC NEAR ; DirectSound::CMcpxAPU::ApuInterruptServiceRoutine, COMDAT

; 237  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 238  :         return (BOOLEAN)((CMcpxAPU *)pvContext)->ServiceApuInterrupt();

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pvContext$[ebp]
  00006	e8 00 00 00 00	 call	 ?ServiceApuInterrupt@CMcpxAPU@DirectSound@@IAEHXZ ; DirectSound::CMcpxAPU::ServiceApuInterrupt

; 239  :     }

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?ApuInterruptServiceRoutine@CMcpxAPU@DirectSound@@CGEPAU_KINTERRUPT@@PAX@Z ENDP ; DirectSound::CMcpxAPU::ApuInterruptServiceRoutine
DSOUND	ENDS
PUBLIC	?ServiceApuInterruptDpc@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::ServiceApuInterruptDpc
; Function compile flags: /Odt
;	COMDAT ?ApuInterruptDpcRoutine@CMcpxAPU@DirectSound@@CGXPAU_KDPC@@PAX11@Z
DSOUND	SEGMENT
_pDpc$ = 8
_pvDeferredContext$ = 12
_pvSystemContext1$ = 16
_pvSystemContext2$ = 20
?ApuInterruptDpcRoutine@CMcpxAPU@DirectSound@@CGXPAU_KDPC@@PAX11@Z PROC NEAR ; DirectSound::CMcpxAPU::ApuInterruptDpcRoutine, COMDAT

; 242  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 243  :         ((CMcpxAPU *)pvDeferredContext)->ServiceApuInterruptDpc();

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pvDeferredContext$[ebp]
  00006	e8 00 00 00 00	 call	 ?ServiceApuInterruptDpc@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::ServiceApuInterruptDpc

; 244  :     }

  0000b	5d		 pop	 ebp
  0000c	c2 10 00	 ret	 16			; 00000010H
?ApuInterruptDpcRoutine@CMcpxAPU@DirectSound@@CGXPAU_KDPC@@PAX11@Z ENDP ; DirectSound::CMcpxAPU::ApuInterruptDpcRoutine
DSOUND	ENDS
PUBLIC	?ServiceDeferredCommandsHigh@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::ServiceDeferredCommandsHigh
; Function compile flags: /Odt
;	COMDAT ?DeferredCommandDpcRoutine@CMcpxAPU@DirectSound@@CGXPAU_KDPC@@PAX11@Z
DSOUND	SEGMENT
_pdpc$ = 8
_pvDeferredContext$ = 12
_pvSystemContext1$ = 16
_pvSystemContext2$ = 20
?DeferredCommandDpcRoutine@CMcpxAPU@DirectSound@@CGXPAU_KDPC@@PAX11@Z PROC NEAR ; DirectSound::CMcpxAPU::DeferredCommandDpcRoutine, COMDAT

; 247  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 248  :         ((CMcpxAPU *)pvDeferredContext)->ServiceDeferredCommandsHigh();

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pvDeferredContext$[ebp]
  00006	e8 00 00 00 00	 call	 ?ServiceDeferredCommandsHigh@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::ServiceDeferredCommandsHigh

; 249  :     }

  0000b	5d		 pop	 ebp
  0000c	c2 10 00	 ret	 16			; 00000010H
?DeferredCommandDpcRoutine@CMcpxAPU@DirectSound@@CGXPAU_KDPC@@PAX11@Z ENDP ; DirectSound::CMcpxAPU::DeferredCommandDpcRoutine
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?ApuShutdownNotifier@CMcpxAPU@DirectSound@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z
DSOUND	SEGMENT
_pHalShutdownData$ = 8
?ApuShutdownNotifier@CMcpxAPU@DirectSound@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z PROC NEAR ; DirectSound::CMcpxAPU::ApuShutdownNotifier, COMDAT

; 252  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 253  :         g_fDirectSoundInFinalRelease = TRUE;

  00003	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _g_fDirectSoundInFinalRelease, 1

; 254  :     
; 255  :         CONTAINING_RECORD(pHalShutdownData, CMcpxAPU, m_HalShutdownData)->Terminate();

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pHalShutdownData$[ebp]
  00010	81 e9 2c 05 00
	00		 sub	 ecx, 1324		; 0000052cH
  00016	e8 00 00 00 00	 call	 ?Terminate@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::Terminate

; 256  :     }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?ApuShutdownNotifier@CMcpxAPU@DirectSound@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z ENDP ; DirectSound::CMcpxAPU::ApuShutdownNotifier
DSOUND	ENDS
PUBLIC	?BlockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ	; DirectSound::CMcpxAPU::BlockIdleHandler
PUBLIC	?UnblockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::UnblockIdleHandler
PUBLIC	?Reset@CMcpxCore@DirectSound@@IAEXXZ		; DirectSound::CMcpxCore::Reset
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpapu.cpp
;	COMDAT ?Terminate@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -24
_pVoice$ = -20
___AutoIrql$ = -16
_pleEntry$ = -8
_i$ = -4
?Terminate@CMcpxAPU@DirectSound@@IAEXXZ PROC NEAR	; DirectSound::CMcpxAPU::Terminate, COMDAT
; _this$ = ecx

; 327  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 328  :     PLIST_ENTRY             pleEntry;
; 329  :     CMcpxVoiceClient *      pVoice;
; 330  :     DWORD                   i;
; 331  :     
; 332  :     DPF_ENTER();
; 333  :     AutoIrql();

  00009	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 334  : 
; 335  :     //
; 336  :     // Block the idle handler
; 337  :     //
; 338  : 
; 339  :     BlockIdleHandler();

  00011	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?BlockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::BlockIdleHandler

; 340  : 
; 341  :     //
; 342  :     // Deactivate all voices
; 343  :     //
; 344  : 
; 345  :     for(i = 0; i < NUMELMS(m_alstActiveVoices); i++)

  00019	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00020	eb 09		 jmp	 SHORT $L37769
$L37770:
  00022	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00025	83 c0 01	 add	 eax, 1
  00028	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L37769:
  0002b	83 7d fc 03	 cmp	 DWORD PTR _i$[ebp], 3
  0002f	73 43		 jae	 SHORT $L37771

; 346  :     {
; 347  :         for(pleEntry = m_alstActiveVoices[i].Flink; pleEntry != &m_alstActiveVoices[i]; pleEntry = pleEntry->Flink)

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00034	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00037	8b 84 ca 8c 04
	00 00		 mov	 eax, DWORD PTR [edx+ecx*8+1164]
  0003e	89 45 f8	 mov	 DWORD PTR _pleEntry$[ebp], eax
  00041	eb 08		 jmp	 SHORT $L37772
$L37773:
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  00046	8b 11		 mov	 edx, DWORD PTR [ecx]
  00048	89 55 f8	 mov	 DWORD PTR _pleEntry$[ebp], edx
$L37772:
  0004b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	8d 94 c1 8c 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+1164]
  00058	39 55 f8	 cmp	 DWORD PTR _pleEntry$[ebp], edx
  0005b	74 15		 je	 SHORT $L37774

; 348  :         {
; 349  :             pVoice = CONTAINING_RECORD(pleEntry, CMcpxVoiceClient, m_leActiveVoice);

  0005d	8b 45 f8	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  00060	83 e8 4c	 sub	 eax, 76			; 0000004cH
  00063	89 45 ec	 mov	 DWORD PTR _pVoice$[ebp], eax

; 350  : 
; 351  :             pVoice->DeactivateVoice();

  00066	6a 00		 push	 0
  00068	8b 4d ec	 mov	 ecx, DWORD PTR _pVoice$[ebp]
  0006b	e8 00 00 00 00	 call	 ?DeactivateVoice@CMcpxVoiceClient@DirectSound@@IAEXH@Z ; DirectSound::CMcpxVoiceClient::DeactivateVoice

; 352  :         }

  00070	eb d1		 jmp	 SHORT $L37773
$L37774:

; 353  :     }

  00072	eb ae		 jmp	 SHORT $L37770
$L37771:

; 354  : 
; 355  :     //
; 356  :     // Unblock the idle handler
; 357  :     //
; 358  : 
; 359  :     UnblockIdleHandler();

  00074	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ?UnblockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::UnblockIdleHandler

; 360  : 
; 361  :     //
; 362  :     // Shut down the APU core
; 363  :     //
; 364  : 
; 365  :     Reset();

  0007c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	83 c1 08	 add	 ecx, 8
  00082	e8 00 00 00 00	 call	 ?Reset@CMcpxCore@DirectSound@@IAEXXZ ; DirectSound::CMcpxCore::Reset

; 366  : 
; 367  :     DPF_LEAVE_VOID();
; 368  : }

  00087	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0008a	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?Terminate@CMcpxAPU@DirectSound@@IAEXXZ ENDP		; DirectSound::CMcpxAPU::Terminate
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpapu.h
DSOUND	ENDS
;	COMDAT ?BlockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?BlockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ PROC NEAR ; DirectSound::CMcpxAPU::BlockIdleHandler, COMDAT
; _this$ = ecx

; 264  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 265  :         ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
; 266  :         ASSERT(m_dwVoiceMapLock < ~0UL);
; 267  :         m_dwVoiceMapLock++;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00010	83 c1 01	 add	 ecx, 1
  00013	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00016	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx

; 268  :     }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?BlockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ENDP	; DirectSound::CMcpxAPU::BlockIdleHandler
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?UnblockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?UnblockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ PROC NEAR ; DirectSound::CMcpxAPU::UnblockIdleHandler, COMDAT
; _this$ = ecx

; 271  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 272  :         ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
; 273  :         ASSERT(m_dwVoiceMapLock >= 1);
; 274  :         m_dwVoiceMapLock--;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00010	83 e9 01	 sub	 ecx, 1
  00013	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00016	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx

; 275  :     }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?UnblockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ENDP	; DirectSound::CMcpxAPU::UnblockIdleHandler
DSOUND	ENDS
PUBLIC	?AllocateVoices@CMcpxAPU@DirectSound@@QAEJPAVCMcpxVoiceClient@2@@Z ; DirectSound::CMcpxAPU::AllocateVoices
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpapu.cpp
;	COMDAT ?AllocateVoices@CMcpxAPU@DirectSound@@QAEJPAVCMcpxVoiceClient@2@@Z
DSOUND	SEGMENT
_this$ = -40
$T42125 = -36
_pdwFreeVoiceCount$ = -32
___AutoIrql$ = -28
_bVoiceIndex$ = -17
_hr$ = -16
_nFirstVoice$ = -12
_nLastVoice$ = -8
_nVoice$ = -4
_pVoice$ = 8
?AllocateVoices@CMcpxAPU@DirectSound@@QAEJPAVCMcpxVoiceClient@2@@Z PROC NEAR ; DirectSound::CMcpxAPU::AllocateVoices, COMDAT
; _this$ = ecx

; 394  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 395  :     LPDWORD                 pdwFreeVoiceCount;
; 396  :     MCPX_VOICE_HANDLE       nFirstVoice;
; 397  :     MCPX_VOICE_HANDLE       nLastVoice;
; 398  :     MCPX_VOICE_HANDLE       nVoice;
; 399  :     BYTE                    bVoiceIndex;
; 400  :     HRESULT                 hr;
; 401  : 
; 402  :     DPF_ENTER();
; 403  :     AutoIrql();

  00009	8d 4d e4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 404  : 
; 405  : #ifdef DEBUG
; 406  : 
; 407  :     ASSERT(pVoice->m_bVoiceCount);
; 408  :     ASSERT(pVoice->m_bVoiceCount <= NUMELMS(pVoice->m_ahVoices));
; 409  : 
; 410  :     for(bVoiceIndex = 0; bVoiceIndex < NUMELMS(pVoice->m_ahVoices); bVoiceIndex++)
; 411  :     {
; 412  :         ASSERT(MCPX_VOICE_HANDLE_INVALID == pVoice->m_ahVoices[bVoiceIndex]);
; 413  :     }
; 414  : 
; 415  : #endif // DEBUG
; 416  : 
; 417  :     //
; 418  :     // Block the idle handler in order to lock the voice map
; 419  :     //
; 420  : 
; 421  :     BlockIdleHandler();

  00011	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?BlockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::BlockIdleHandler

; 422  : 
; 423  :     //
; 424  :     // Allocate voices
; 425  :     //
; 426  :     
; 427  :     if(pVoice->m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)

  00019	8b 45 08	 mov	 eax, DWORD PTR _pVoice$[ebp]
  0001c	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0001f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00022	83 e2 10	 and	 edx, 16			; 00000010H
  00025	85 d2		 test	 edx, edx
  00027	74 17		 je	 SHORT $L37790

; 428  :     {
; 429  :         pdwFreeVoiceCount = &m_dwFree3dVoiceCount;

  00029	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  0002f	89 4d e0	 mov	 DWORD PTR _pdwFreeVoiceCount$[ebp], ecx

; 430  :         nFirstVoice = MCPX_HW_FIRST_3D_VOICE;

  00032	66 c7 45 f4 00
	00		 mov	 WORD PTR _nFirstVoice$[ebp], 0

; 431  :         nLastVoice = MCPX_HW_FIRST_3D_VOICE + MCPX_HW_MAX_3D_VOICES - 1;

  00038	66 c7 45 f8 3f
	00		 mov	 WORD PTR _nLastVoice$[ebp], 63 ; 0000003fH

; 432  :     }
; 433  :     else

  0003e	eb 15		 jmp	 SHORT $L37791
$L37790:

; 434  :     {
; 435  :         pdwFreeVoiceCount = &m_dwFree2dVoiceCount;

  00040	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00043	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00046	89 45 e0	 mov	 DWORD PTR _pdwFreeVoiceCount$[ebp], eax

; 436  :         nFirstVoice = MCPX_HW_FIRST_2D_VOICE;

  00049	66 c7 45 f4 40
	00		 mov	 WORD PTR _nFirstVoice$[ebp], 64 ; 00000040H

; 437  :         nLastVoice = MCPX_HW_FIRST_2D_VOICE + MCPX_HW_MAX_2D_VOICES - 1;

  0004f	66 c7 45 f8 ff
	00		 mov	 WORD PTR _nLastVoice$[ebp], 255 ; 000000ffH
$L37791:

; 438  :     }
; 439  : 
; 440  :     if(pVoice->m_bVoiceCount <= *pdwFreeVoiceCount)

  00055	8b 4d 08	 mov	 ecx, DWORD PTR _pVoice$[ebp]
  00058	0f b6 51 64	 movzx	 edx, BYTE PTR [ecx+100]
  0005c	8b 45 e0	 mov	 eax, DWORD PTR _pdwFreeVoiceCount$[ebp]
  0005f	3b 10		 cmp	 edx, DWORD PTR [eax]
  00061	77 7f		 ja	 SHORT $L37792

; 441  :     {
; 442  :         *pdwFreeVoiceCount -= pVoice->m_bVoiceCount;

  00063	8b 4d 08	 mov	 ecx, DWORD PTR _pVoice$[ebp]
  00066	0f b6 51 64	 movzx	 edx, BYTE PTR [ecx+100]
  0006a	8b 45 e0	 mov	 eax, DWORD PTR _pdwFreeVoiceCount$[ebp]
  0006d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006f	2b ca		 sub	 ecx, edx
  00071	8b 55 e0	 mov	 edx, DWORD PTR _pdwFreeVoiceCount$[ebp]
  00074	89 0a		 mov	 DWORD PTR [edx], ecx

; 443  :         
; 444  :         bVoiceIndex = 0;

  00076	c6 45 ef 00	 mov	 BYTE PTR _bVoiceIndex$[ebp], 0

; 445  :         nVoice = nFirstVoice;

  0007a	66 8b 45 f4	 mov	 ax, WORD PTR _nFirstVoice$[ebp]
  0007e	66 89 45 fc	 mov	 WORD PTR _nVoice$[ebp], ax
$L37794:

; 446  : 
; 447  :         while(bVoiceIndex < pVoice->m_bVoiceCount)

  00082	0f b6 4d ef	 movzx	 ecx, BYTE PTR _bVoiceIndex$[ebp]
  00086	8b 55 08	 mov	 edx, DWORD PTR _pVoice$[ebp]
  00089	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  0008d	3b c8		 cmp	 ecx, eax
  0008f	7d 48		 jge	 SHORT $L37795

; 448  :         {
; 449  :             ASSERT(nVoice <= nLastVoice);
; 450  : 
; 451  :             if(!m_apVoiceMap[nVoice])

  00091	0f b7 4d fc	 movzx	 ecx, WORD PTR _nVoice$[ebp]
  00095	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00098	83 bc 8a 8c 00
	00 00 00	 cmp	 DWORD PTR [edx+ecx*4+140], 0
  000a0	75 29		 jne	 SHORT $L37796

; 452  :             {
; 453  :                 DPF_INFO("Voice client %x allocated hardware voice %x", pVoice, nVoice);
; 454  : 
; 455  :                 pVoice->m_ahVoices[bVoiceIndex] = nVoice;

  000a2	0f b6 45 ef	 movzx	 eax, BYTE PTR _bVoiceIndex$[ebp]
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _pVoice$[ebp]
  000a9	66 8b 55 fc	 mov	 dx, WORD PTR _nVoice$[ebp]
  000ad	66 89 54 41 0c	 mov	 WORD PTR [ecx+eax*2+12], dx

; 456  :                 m_apVoiceMap[nVoice] = pVoice;

  000b2	0f b7 45 fc	 movzx	 eax, WORD PTR _nVoice$[ebp]
  000b6	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	8b 55 08	 mov	 edx, DWORD PTR _pVoice$[ebp]
  000bc	89 94 81 8c 00
	00 00		 mov	 DWORD PTR [ecx+eax*4+140], edx

; 457  : 
; 458  :                 bVoiceIndex++;

  000c3	8a 45 ef	 mov	 al, BYTE PTR _bVoiceIndex$[ebp]
  000c6	04 01		 add	 al, 1
  000c8	88 45 ef	 mov	 BYTE PTR _bVoiceIndex$[ebp], al
$L37796:

; 459  :             }
; 460  : 
; 461  :             nVoice++;

  000cb	66 8b 4d fc	 mov	 cx, WORD PTR _nVoice$[ebp]
  000cf	66 83 c1 01	 add	 cx, 1
  000d3	66 89 4d fc	 mov	 WORD PTR _nVoice$[ebp], cx

; 462  :         }

  000d7	eb a9		 jmp	 SHORT $L37794
$L37795:

; 463  : 
; 464  :         hr = DS_OK;

  000d9	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 465  :     }
; 466  :     else

  000e0	eb 07		 jmp	 SHORT $L37798
$L37792:

; 467  :     {
; 468  :         DPF_ERROR("Not enough free hardware voices");
; 469  :         hr = DSERR_INVALIDCALL;

  000e2	c7 45 f0 32 00
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005401550 ; 88780032H
$L37798:

; 470  :     }
; 471  : 
; 472  :     //
; 473  :     // Unlock the voice map
; 474  :     //
; 475  : 
; 476  :     UnblockIdleHandler();

  000e9	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	e8 00 00 00 00	 call	 ?UnblockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::UnblockIdleHandler

; 477  : 
; 478  :     DPF_LEAVE_HRESULT(hr);
; 479  : 
; 480  :     return hr;

  000f1	8b 55 f0	 mov	 edx, DWORD PTR _hr$[ebp]
  000f4	89 55 dc	 mov	 DWORD PTR $T42125[ebp], edx
  000f7	8d 4d e4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000fa	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000ff	8b 45 dc	 mov	 eax, DWORD PTR $T42125[ebp]

; 481  : }

  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c2 04 00	 ret	 4
?AllocateVoices@CMcpxAPU@DirectSound@@QAEJPAVCMcpxVoiceClient@2@@Z ENDP ; DirectSound::CMcpxAPU::AllocateVoices
DSOUND	ENDS
PUBLIC	?FreeVoices@CMcpxAPU@DirectSound@@QAEXPAVCMcpxVoiceClient@2@@Z ; DirectSound::CMcpxAPU::FreeVoices
; Function compile flags: /Odt
;	COMDAT ?FreeVoices@CMcpxAPU@DirectSound@@QAEXPAVCMcpxVoiceClient@2@@Z
DSOUND	SEGMENT
_this$ = -20
___AutoIrql$ = -16
_dwVoiceIndex$ = -8
_i$ = -4
_pVoice$ = 8
?FreeVoices@CMcpxAPU@DirectSound@@QAEXPAVCMcpxVoiceClient@2@@Z PROC NEAR ; DirectSound::CMcpxAPU::FreeVoices, COMDAT
; _this$ = ecx

; 507  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 508  :     DWORD                   dwVoiceIndex;
; 509  :     WORD                    i;
; 510  : 
; 511  :     DPF_ENTER();
; 512  :     AutoIrql();

  00009	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 513  : 
; 514  :     //
; 515  :     // Block the idle handler in order to lock the voice map
; 516  :     //
; 517  : 
; 518  :     BlockIdleHandler();

  00011	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?BlockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::BlockIdleHandler

; 519  : 
; 520  :     //
; 521  :     // Remove each voice from the map and the voice client's array
; 522  :     //
; 523  : 
; 524  :     for(i = 0; i < pVoice->m_bVoiceCount; i++)

  00019	66 c7 45 fc 00
	00		 mov	 WORD PTR _i$[ebp], 0
  0001f	eb 0c		 jmp	 SHORT $L37811
$L37812:
  00021	66 8b 45 fc	 mov	 ax, WORD PTR _i$[ebp]
  00025	66 05 01 00	 add	 ax, 1
  00029	66 89 45 fc	 mov	 WORD PTR _i$[ebp], ax
$L37811:
  0002d	0f b7 4d fc	 movzx	 ecx, WORD PTR _i$[ebp]
  00031	8b 55 08	 mov	 edx, DWORD PTR _pVoice$[ebp]
  00034	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  00038	3b c8		 cmp	 ecx, eax
  0003a	7d 5e		 jge	 SHORT $L37813

; 525  :     {
; 526  :         dwVoiceIndex = (DWORD)pVoice->m_ahVoices[i];

  0003c	0f b7 4d fc	 movzx	 ecx, WORD PTR _i$[ebp]
  00040	8b 55 08	 mov	 edx, DWORD PTR _pVoice$[ebp]
  00043	0f b7 44 4a 0c	 movzx	 eax, WORD PTR [edx+ecx*2+12]
  00048	89 45 f8	 mov	 DWORD PTR _dwVoiceIndex$[ebp], eax

; 527  :         pVoice->m_ahVoices[i] = MCPX_VOICE_HANDLE_INVALID;

  0004b	0f b7 4d fc	 movzx	 ecx, WORD PTR _i$[ebp]
  0004f	8b 55 08	 mov	 edx, DWORD PTR _pVoice$[ebp]
  00052	66 c7 44 4a 0c
	ff ff		 mov	 WORD PTR [edx+ecx*2+12], 65535 ; 0000ffffH

; 528  :         
; 529  :         ASSERT(dwVoiceIndex < MCPX_HW_MAX_VOICES);
; 530  :         ASSERT(m_apVoiceMap[dwVoiceIndex] == pVoice);
; 531  : 
; 532  :         m_apVoiceMap[dwVoiceIndex] = NULL;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _dwVoiceIndex$[ebp]
  0005c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	c7 84 81 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+140], 0

; 533  : 
; 534  :         if(MCPX_IS_3D_VOICE(dwVoiceIndex))

  0006a	83 7d f8 40	 cmp	 DWORD PTR _dwVoiceIndex$[ebp], 64 ; 00000040H
  0006e	73 15		 jae	 SHORT $L37817

; 535  :         {
; 536  :             m_dwFree3dVoiceCount++;

  00070	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00073	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00076	8b 08		 mov	 ecx, DWORD PTR [eax]
  00078	83 c1 01	 add	 ecx, 1
  0007b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0007e	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00081	89 08		 mov	 DWORD PTR [eax], ecx

; 537  :         }
; 538  :         else

  00083	eb 13		 jmp	 SHORT $L37818
$L37817:

; 539  :         {
; 540  :             m_dwFree2dVoiceCount++;

  00085	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0008b	8b 02		 mov	 eax, DWORD PTR [edx]
  0008d	83 c0 01	 add	 eax, 1
  00090	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00096	89 02		 mov	 DWORD PTR [edx], eax
$L37818:

; 541  :         }
; 542  :     }

  00098	eb 87		 jmp	 SHORT $L37812
$L37813:

; 543  : 
; 544  : #ifdef DEBUG
; 545  : 
; 546  :     for(i = 0; i < NUMELMS(pVoice->m_ahVoices); i++)
; 547  :     {
; 548  :         ASSERT(MCPX_VOICE_HANDLE_INVALID == pVoice->m_ahVoices[i]);
; 549  :     }
; 550  : 
; 551  : #endif // DEBUG
; 552  : 
; 553  :     //
; 554  :     // Unlock the voice map
; 555  :     //
; 556  : 
; 557  :     UnblockIdleHandler();

  0009a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	e8 00 00 00 00	 call	 ?UnblockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::UnblockIdleHandler

; 558  : 
; 559  :     DPF_LEAVE_VOID();
; 560  : }

  000a2	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000a5	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 04 00	 ret	 4
?FreeVoices@CMcpxAPU@DirectSound@@QAEXPAVCMcpxVoiceClient@2@@Z ENDP ; DirectSound::CMcpxAPU::FreeVoices
DSOUND	ENDS
PUBLIC	?HandleFETrap@CMcpxAPU@DirectSound@@IAEXXZ	; DirectSound::CMcpxAPU::HandleFETrap
PUBLIC	?ScheduleApuInterruptDpc@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::ScheduleApuInterruptDpc
; Function compile flags: /Odt
;	COMDAT ?ServiceApuInterrupt@CMcpxAPU@DirectSound@@IAEHXZ
DSOUND	SEGMENT
_this$ = -16
_rInterruptStatus$ = -12
_fServiced$ = -4
?ServiceApuInterrupt@CMcpxAPU@DirectSound@@IAEHXZ PROC NEAR ; DirectSound::CMcpxAPU::ServiceApuInterrupt, COMDAT
; _this$ = ecx

; 586  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 587  :     R_INTR                  rInterruptStatus;
; 588  :     BOOL                    fServiced;
; 589  : 
; 590  :     //
; 591  :     // Get the pending interrupt
; 592  :     //
; 593  :     
; 594  :     MCPX_REG_READ(NV_PAPU_ISTS, &rInterruptStatus.uValue);

  00009	a1 00 10 80 fe	 mov	 eax, DWORD PTR ds:-25161728
  0000e	89 45 f4	 mov	 DWORD PTR _rInterruptStatus$[ebp], eax

; 595  : 
; 596  :     if(fServiced = MAKEBOOL(rInterruptStatus.General))

  00011	8b 4d f4	 mov	 ecx, DWORD PTR _rInterruptStatus$[ebp]
  00014	83 e1 01	 and	 ecx, 1
  00017	f7 d9		 neg	 ecx
  00019	1b c9		 sbb	 ecx, ecx
  0001b	f7 d9		 neg	 ecx
  0001d	89 4d fc	 mov	 DWORD PTR _fServiced$[ebp], ecx
  00020	83 7d fc 00	 cmp	 DWORD PTR _fServiced$[ebp], 0
  00024	74 51		 je	 SHORT $L37826

; 597  :     {
; 598  :         //
; 599  :         // Clear the interrupt(s)
; 600  :         //
; 601  : 
; 602  :         MCPX_REG_WRITE(NV_PAPU_ISTS, rInterruptStatus.uValue);

  00026	8b 55 f4	 mov	 edx, DWORD PTR _rInterruptStatus$[ebp]
  00029	89 15 00 10 80
	fe		 mov	 DWORD PTR ds:-25161728, edx

; 603  : 
; 604  :         //
; 605  :         // Save the interrupt bits
; 606  :         //
; 607  : 
; 608  : #ifdef DEBUG
; 609  : 
; 610  :         rInterruptStatus.DeltaPanic |= INTERLOCKED_EXCHANGE(m_fSimulateDeltaPanic, 0);
; 611  :         rInterruptStatus.DeltaWarning |= INTERLOCKED_EXCHANGE(m_fSimulateDeltaWarning, 0);
; 612  : 
; 613  : #endif // DEBUG
; 614  : 
; 615  :         m_arInterruptStatus[0].uValue |= rInterruptStatus.uValue;

  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 88 bc 04 00
	00		 mov	 ecx, DWORD PTR [eax+1212]
  00038	0b 4d f4	 or	 ecx, DWORD PTR _rInterruptStatus$[ebp]
  0003b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	89 8a bc 04 00
	00		 mov	 DWORD PTR [edx+1212], ecx

; 616  : 
; 617  :         //
; 618  :         // Check for a trap caused by an error or an overridden hardware 
; 619  :         // method
; 620  :         //
; 621  :     
; 622  :         if(rInterruptStatus.FETrap)

  00044	8b 45 f4	 mov	 eax, DWORD PTR _rInterruptStatus$[ebp]
  00047	c1 e8 04	 shr	 eax, 4
  0004a	83 e0 01	 and	 eax, 1
  0004d	85 c0		 test	 eax, eax
  0004f	74 08		 je	 SHORT $L37829

; 623  :         {
; 624  :             HandleFETrap();

  00051	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?HandleFETrap@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::HandleFETrap
$L37829:

; 625  :         }
; 626  : 
; 627  : #ifdef MCPX_HANDLE_DELTA_PANICS_FROM_ISR
; 628  : 
; 629  : #ifndef MCPX_BOOT_LIB
; 630  : 
; 631  :         //
; 632  :         // If we got a delta panic, handle it here
; 633  :         //
; 634  : 
; 635  :         if(rInterruptStatus.DeltaPanic)
; 636  :         {
; 637  :             HandleDeltaPanic();
; 638  :         }
; 639  : 
; 640  : #ifdef MCPX_ENABLE_DELTA_WARNINGS
; 641  : 
; 642  :         else if(rInterruptStatus.DeltaWarning)
; 643  :         {
; 644  :             HandleDeltaWarning();
; 645  :         }
; 646  : 
; 647  : #endif // MCPX_ENABLE_DELTA_WARNINGS
; 648  : 
; 649  : #endif // MCPX_BOOT_LIB
; 650  : 
; 651  :         //
; 652  :         // If we got a voice interrupt, schedule a DPC to handle it
; 653  :         //
; 654  : 
; 655  :         if(rInterruptStatus.FEVoice)

  00059	8b 4d f4	 mov	 ecx, DWORD PTR _rInterruptStatus$[ebp]
  0005c	c1 e9 06	 shr	 ecx, 6
  0005f	83 e1 01	 and	 ecx, 1
  00062	85 c9		 test	 ecx, ecx
  00064	74 08		 je	 SHORT $L37830

; 656  :         {
; 657  :             ScheduleApuInterruptDpc();

  00066	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	e8 00 00 00 00	 call	 ?ScheduleApuInterruptDpc@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::ScheduleApuInterruptDpc
$L37830:

; 658  :         }
; 659  : 
; 660  : #else // MCPX_HANDLE_DELTA_PANICS_FROM_ISR
; 661  : 
; 662  :         //
; 663  :         // If we got a voice interrupt or a delta panic, schedule a DPC to 
; 664  :         // handle it
; 665  :         //
; 666  : 
; 667  :         if(rInterruptStatus.DeltaPanic || rInterruptStatus.DeltaWarning || rInterruptStatus.FEVoice)
; 668  :         {
; 669  :             ScheduleApuInterruptDpc();
; 670  :         }
; 671  : 
; 672  : #endif // MCPX_HANDLE_DELTA_PANICS_FROM_ISR
; 673  : 
; 674  :         //
; 675  :         // Read the interrupt status again to make sure everything's flushed
; 676  :         //
; 677  : 
; 678  :         MCPX_REG_READ(NV_PAPU_ISTS, &rInterruptStatus.uValue);

  0006e	8b 15 00 10 80
	fe		 mov	 edx, DWORD PTR ds:-25161728
  00074	89 55 f4	 mov	 DWORD PTR _rInterruptStatus$[ebp], edx
$L37826:

; 679  :     }
; 680  :     
; 681  :     return fServiced;

  00077	8b 45 fc	 mov	 eax, DWORD PTR _fServiced$[ebp]

; 682  : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?ServiceApuInterrupt@CMcpxAPU@DirectSound@@IAEHXZ ENDP	; DirectSound::CMcpxAPU::ServiceApuInterrupt
DSOUND	ENDS
EXTRN	__imp__KeInsertQueueDpc@12:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpapu.h
;	COMDAT ?ScheduleApuInterruptDpc@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -4
?ScheduleApuInterruptDpc@CMcpxAPU@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxAPU::ScheduleApuInterruptDpc, COMDAT
; _this$ = ecx

; 278  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 279  :         KeInsertQueueDpc(&m_dpcInterrupt, NULL, NULL);

  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	05 cc 04 00 00	 add	 eax, 1228		; 000004ccH
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInsertQueueDpc@12

; 280  :     }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?ScheduleApuInterruptDpc@CMcpxAPU@DirectSound@@IAEXXZ ENDP ; DirectSound::CMcpxAPU::ScheduleApuInterruptDpc
DSOUND	ENDS
PUBLIC	?WaitForMagicWrite@CMcpxAPU@DirectSound@@IAEXXZ	; DirectSound::CMcpxAPU::WaitForMagicWrite
PUBLIC	?SetPrivLockState@CMcpxCore@DirectSound@@IAEXH@Z ; DirectSound::CMcpxCore::SetPrivLockState
EXTRN	__imp__KeStallExecutionProcessor@4:NEAR
;	COMDAT ?dwMagicWriteValue@?1??WaitForMagicWrite@CMcpxAPU@DirectSound@@IAEXXZ@4KA
; File c:\xbox\private\windows\directx\dsound\dsound\mcpapu.cpp
DSOUND_RW	SEGMENT
?dwMagicWriteValue@?1??WaitForMagicWrite@CMcpxAPU@DirectSound@@IAEXXZ@4KA DD 00H ; `DirectSound::CMcpxAPU::WaitForMagicWrite'::`2'::dwMagicWriteValue
; Function compile flags: /Odt
DSOUND_RW	ENDS
;	COMDAT ?WaitForMagicWrite@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -16
_dwTimeout$ = -12
_pdwMagicWrite$ = -8
?WaitForMagicWrite@CMcpxAPU@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxAPU::WaitForMagicWrite, COMDAT
; _this$ = ecx

; 708  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 709  :     static DWORD            dwMagicWriteValue   = 0;
; 710  :     DWORD                   dwTimeout           = 100;

  00009	c7 45 f4 64 00
	00 00		 mov	 DWORD PTR _dwTimeout$[ebp], 100 ; 00000064H

; 711  :     volatile DWORD *        pdwMagicWrite;
; 712  :     DWORD                   i;
; 713  : 
; 714  :     dwMagicWriteValue++;

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwMagicWriteValue@?1??WaitForMagicWrite@CMcpxAPU@DirectSound@@IAEXXZ@4KA
  00015	83 c0 01	 add	 eax, 1
  00018	a3 00 00 00 00	 mov	 DWORD PTR ?dwMagicWriteValue@?1??WaitForMagicWrite@CMcpxAPU@DirectSound@@IAEXXZ@4KA, eax

; 715  : 
; 716  :     pdwMagicWrite = (volatile DWORD *)m_ctxMemory[MCPX_MEM_MAGICWRITE].VirtualAddress;

  0001d	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+32
  00023	89 4d f8	 mov	 DWORD PTR _pdwMagicWrite$[ebp], ecx

; 717  :     *pdwMagicWrite = ~dwMagicWriteValue;

  00026	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?dwMagicWriteValue@?1??WaitForMagicWrite@CMcpxAPU@DirectSound@@IAEXXZ@4KA
  0002c	f7 d2		 not	 edx
  0002e	8b 45 f8	 mov	 eax, DWORD PTR _pdwMagicWrite$[ebp]
  00031	89 10		 mov	 DWORD PTR [eax], edx

; 718  : 
; 719  :     SetPrivLockState(TRUE);

  00033	6a 01		 push	 1
  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 08	 add	 ecx, 8
  0003b	e8 00 00 00 00	 call	 ?SetPrivLockState@CMcpxCore@DirectSound@@IAEXH@Z ; DirectSound::CMcpxCore::SetPrivLockState

; 720  : 
; 721  :     MCPX_REG_WRITE(NV_PAPU_FEMEMADDR, m_ctxMemory[MCPX_MEM_MAGICWRITE].PhysicalAddress);

  00040	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+36
  00046	89 0d 24 13 80
	fe		 mov	 DWORD PTR ds:-25160924, ecx

; 722  :     MCPX_REG_WRITE(NV_PAPU_FEMEMDATA, dwMagicWriteValue);

  0004c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?dwMagicWriteValue@?1??WaitForMagicWrite@CMcpxAPU@DirectSound@@IAEXXZ@4KA
  00052	89 15 34 13 80
	fe		 mov	 DWORD PTR ds:-25160908, edx

; 723  : 
; 724  :     SetPrivLockState(FALSE);

  00058	6a 00		 push	 0
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	83 c1 08	 add	 ecx, 8
  00060	e8 00 00 00 00	 call	 ?SetPrivLockState@CMcpxCore@DirectSound@@IAEXH@Z ; DirectSound::CMcpxCore::SetPrivLockState
$L37847:

; 725  : 
; 726  :     while(*pdwMagicWrite != dwMagicWriteValue)

  00065	8b 45 f8	 mov	 eax, DWORD PTR _pdwMagicWrite$[ebp]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?dwMagicWriteValue@?1??WaitForMagicWrite@CMcpxAPU@DirectSound@@IAEXXZ@4KA
  00070	74 1c		 je	 SHORT $L37835

; 727  :     {
; 728  :         if(!dwTimeout--)

  00072	8b 55 f4	 mov	 edx, DWORD PTR _dwTimeout$[ebp]
  00075	8b 45 f4	 mov	 eax, DWORD PTR _dwTimeout$[ebp]
  00078	83 e8 01	 sub	 eax, 1
  0007b	89 45 f4	 mov	 DWORD PTR _dwTimeout$[ebp], eax
  0007e	85 d2		 test	 edx, edx
  00080	75 02		 jne	 SHORT $L37849

; 729  :         {
; 730  :             DPF_ERROR("Magic write not completing!");
; 731  :             break;

  00082	eb 0a		 jmp	 SHORT $L37835
$L37849:

; 732  :         }
; 733  : 
; 734  :         KeStallExecutionProcessor(1);

  00084	6a 01		 push	 1
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeStallExecutionProcessor@4

; 735  :     }

  0008c	eb d7		 jmp	 SHORT $L37847
$L37835:

; 736  : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?WaitForMagicWrite@CMcpxAPU@DirectSound@@IAEXXZ ENDP	; DirectSound::CMcpxAPU::WaitForMagicWrite
DSOUND	ENDS
PUBLIC	?ServiceVoiceInterrupt@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::ServiceVoiceInterrupt
PUBLIC	?GetInterruptStatusCallback@CMcpxAPU@DirectSound@@CGEPAX@Z ; DirectSound::CMcpxAPU::GetInterruptStatusCallback
EXTRN	__imp__KeSynchronizeExecution@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?ServiceApuInterruptDpc@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -4
?ServiceApuInterruptDpc@CMcpxAPU@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxAPU::ServiceApuInterruptDpc, COMDAT
; _this$ = ecx

; 762  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$L37855:

; 763  :     //
; 764  :     // The DPC will parse the interrupt mask and do processing based on what
; 765  :     // event was signaled. In ISR-safe fashion, it will read the current 
; 766  :     // pending interrupt mask twice in the loop. This makes sure the dpc 
; 767  :     // leaves only when no more ISRs are pending.
; 768  :     //
; 769  : 
; 770  :     while(TRUE)

  00007	b8 01 00 00 00	 mov	 eax, 1
  0000c	85 c0		 test	 eax, eax
  0000e	74 50		 je	 SHORT $L37853

; 771  :     {
; 772  :         KeSynchronizeExecution(&m_Interrupt, GetInterruptStatusCallback, this);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	51		 push	 ecx
  00014	68 00 00 00 00	 push	 OFFSET FLAT:?GetInterruptStatusCallback@CMcpxAPU@DirectSound@@CGEPAX@Z ; DirectSound::CMcpxAPU::GetInterruptStatusCallback
  00019	68 00 00 00 00	 push	 OFFSET FLAT:?m_Interrupt@CMcpxAPU@DirectSound@@1U_KINTERRUPT@@A ; DirectSound::CMcpxAPU::m_Interrupt
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSynchronizeExecution@12

; 773  : 
; 774  :         if(!m_arInterruptStatus[1].General)

  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	8b 82 c4 04 00
	00		 mov	 eax, DWORD PTR [edx+1220]
  0002d	83 e0 01	 and	 eax, 1
  00030	85 c0		 test	 eax, eax
  00032	75 02		 jne	 SHORT $L37857

; 775  :         {
; 776  :             break;

  00034	eb 2a		 jmp	 SHORT $L37853
$L37857:

; 777  :         }
; 778  : 
; 779  : #ifndef MCPX_BOOT_LIB
; 780  : 
; 781  : #ifndef MCPX_HANDLE_DELTA_PANICS_FROM_ISR
; 782  : 
; 783  :         if(m_arInterruptStatus[1].DeltaPanic)
; 784  :         {
; 785  :             HandleDeltaPanic();
; 786  :         }
; 787  : 
; 788  : #ifdef MCPX_ENABLE_DELTA_WARNINGS
; 789  : 
; 790  :         else if(m_arInterruptStatus[1].DeltaWarning)
; 791  :         {
; 792  :             HandleDeltaWarning();
; 793  :         }
; 794  : 
; 795  : #endif // MCPX_ENABLE_DELTA_WARNINGS
; 796  : 
; 797  : #endif // MCPX_HANDLE_DELTA_PANICS_FROM_ISR
; 798  : 
; 799  : #endif // MCPX_BOOT_LIB
; 800  : 
; 801  :         if(m_arInterruptStatus[1].FEVoice)

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 91 c4 04 00
	00		 mov	 edx, DWORD PTR [ecx+1220]
  0003f	c1 ea 06	 shr	 edx, 6
  00042	83 e2 01	 and	 edx, 1
  00045	85 d2		 test	 edx, edx
  00047	74 08		 je	 SHORT $L37858

; 802  :         {
; 803  :             ServiceVoiceInterrupt();

  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?ServiceVoiceInterrupt@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::ServiceVoiceInterrupt
$L37858:

; 804  :         }
; 805  : 
; 806  :         m_arInterruptStatus[1].uValue = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 80 c4 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1220], 0

; 807  :     } 

  0005e	eb a7		 jmp	 SHORT $L37855
$L37853:

; 808  : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?ServiceApuInterruptDpc@CMcpxAPU@DirectSound@@IAEXXZ ENDP ; DirectSound::CMcpxAPU::ServiceApuInterruptDpc
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?ServiceVoiceInterrupt@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -16
_pleEntry$ = -12
_dwVoiceList$ = -8
_pClient$ = -4
?ServiceVoiceInterrupt@CMcpxAPU@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxAPU::ServiceVoiceInterrupt, COMDAT
; _this$ = ecx

; 834  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 835  :     PLIST_ENTRY             pleEntry;
; 836  :     CMcpxVoiceClient *      pClient;
; 837  :     DWORD                   dwVoiceList;
; 838  : 
; 839  : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 840  : 
; 841  :     DWORD                   i;
; 842  : 
; 843  : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 844  : 
; 845  :     //
; 846  :     // Wait for the magic write to complete so that all notifiers are 
; 847  :     // written
; 848  :     //
; 849  : 
; 850  :     WaitForMagicWrite();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?WaitForMagicWrite@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::WaitForMagicWrite

; 851  : 
; 852  :     //
; 853  :     // Process all active voices.  Because the idle handler is allowed to run
; 854  :     // while we're in this function, we need to protect ourselves against the
; 855  :     // active voice list potentially being modified while we're walking it.
; 856  :     // The best way to do this seems to be restarting at the head of the list
; 857  :     // every time the list changes.  We can't guarantee that any node in the 
; 858  :     // list will ever be valid, so we can't keep a back or next pointer.
; 859  :     //
; 860  : 
; 861  :     for(dwVoiceList = 0; dwVoiceList < NUMELMS(m_alstActiveVoices); dwVoiceList++)

  00011	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwVoiceList$[ebp], 0
  00018	eb 09		 jmp	 SHORT $L37866
$L37867:
  0001a	8b 45 f8	 mov	 eax, DWORD PTR _dwVoiceList$[ebp]
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 f8	 mov	 DWORD PTR _dwVoiceList$[ebp], eax
$L37866:
  00023	83 7d f8 03	 cmp	 DWORD PTR _dwVoiceList$[ebp], 3
  00027	73 6e		 jae	 SHORT $L37879

; 862  :     {
; 863  :         pleEntry = m_alstActiveVoices[dwVoiceList].Flink;

  00029	8b 4d f8	 mov	 ecx, DWORD PTR _dwVoiceList$[ebp]
  0002c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	8b 84 ca 8c 04
	00 00		 mov	 eax, DWORD PTR [edx+ecx*8+1164]
  00036	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax
$L37870:

; 864  : 
; 865  :         while(pleEntry != &m_alstActiveVoices[dwVoiceList])

  00039	8b 4d f8	 mov	 ecx, DWORD PTR _dwVoiceList$[ebp]
  0003c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	8d 84 ca 8c 04
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+1164]
  00046	39 45 f4	 cmp	 DWORD PTR _pleEntry$[ebp], eax
  00049	74 4a		 je	 SHORT $L37871

; 866  :         {
; 867  :             pClient = CONTAINING_RECORD(pleEntry, CMcpxVoiceClient, m_leActiveVoice);

  0004b	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  0004e	83 e9 4c	 sub	 ecx, 76			; 0000004cH
  00051	89 4d fc	 mov	 DWORD PTR _pClient$[ebp], ecx

; 868  : 
; 869  : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 870  : 
; 871  :             for(i = 0; i < MCPX_NOTIFIER_COUNT; i++)
; 872  :             {
; 873  :                 if(pClient->m_Notifier.GetStatus(i))
; 874  :                 {
; 875  :                     DPF_BLAB("Voice %x (%x) notifier %lu signaled", pClient, pClient->m_ahVoices[0], i);
; 876  :                 }
; 877  :             }
; 878  : 
; 879  : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 880  : 
; 881  :             pClient->ServiceVoiceInterrupt();

  00054	8b 55 fc	 mov	 edx, DWORD PTR _pClient$[ebp]
  00057	8b 02		 mov	 eax, DWORD PTR [edx]
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _pClient$[ebp]
  0005c	ff 50 14	 call	 DWORD PTR [eax+20]

; 882  : 
; 883  :             BlockIdleHandler();

  0005f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	e8 00 00 00 00	 call	 ?BlockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::BlockIdleHandler

; 884  :             
; 885  :             if(IsEntryInList(pleEntry))

  00067	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  0006a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006c	3b 55 f4	 cmp	 edx, DWORD PTR _pleEntry$[ebp]
  0006f	74 0a		 je	 SHORT $L37876

; 886  :             {
; 887  :                 pleEntry = pleEntry->Flink;

  00071	8b 45 f4	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	89 4d f4	 mov	 DWORD PTR _pleEntry$[ebp], ecx

; 888  :             }
; 889  :             else

  00079	eb 10		 jmp	 SHORT $L37877
$L37876:

; 890  :             {
; 891  :                 pleEntry = m_alstActiveVoices[dwVoiceList].Flink;

  0007b	8b 55 f8	 mov	 edx, DWORD PTR _dwVoiceList$[ebp]
  0007e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 8c d0 8c 04
	00 00		 mov	 ecx, DWORD PTR [eax+edx*8+1164]
  00088	89 4d f4	 mov	 DWORD PTR _pleEntry$[ebp], ecx
$L37877:

; 892  :             }
; 893  : 
; 894  :             UnblockIdleHandler();

  0008b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ?UnblockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::UnblockIdleHandler

; 895  :         }

  00093	eb a4		 jmp	 SHORT $L37870
$L37871:

; 896  :     }

  00095	eb 83		 jmp	 SHORT $L37867
$L37879:

; 897  : 
; 898  :     //
; 899  :     // Process the pending inactive voice list, but this time just remove
; 900  :     // every node from the list as we go.
; 901  :     //
; 902  : 
; 903  :     while(TRUE)

  00097	ba 01 00 00 00	 mov	 edx, 1
  0009c	85 d2		 test	 edx, edx
  0009e	74 48		 je	 SHORT $L37862

; 904  :     {
; 905  :         BlockIdleHandler();

  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	e8 00 00 00 00	 call	 ?BlockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::BlockIdleHandler

; 906  :         
; 907  :         pleEntry = RemoveHeadList(&m_lstPendingInactiveVoices);

  000a8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 88 a4 04 00
	00		 mov	 ecx, DWORD PTR [eax+1188]
  000b1	51		 push	 ecx
  000b2	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList
  000b7	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax

; 908  : 
; 909  :         UnblockIdleHandler();

  000ba	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	e8 00 00 00 00	 call	 ?UnblockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::UnblockIdleHandler

; 910  : 
; 911  :         if(&m_lstPendingInactiveVoices == pleEntry)

  000c2	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000c5	81 c2 a4 04 00
	00		 add	 edx, 1188		; 000004a4H
  000cb	3b 55 f4	 cmp	 edx, DWORD PTR _pleEntry$[ebp]
  000ce	75 02		 jne	 SHORT $L37881

; 912  :         {
; 913  :             break;

  000d0	eb 16		 jmp	 SHORT $L37862
$L37881:

; 914  :         }
; 915  :     
; 916  :         pClient = CONTAINING_RECORD(pleEntry, CMcpxVoiceClient, m_lePendingInactiveVoice);

  000d2	8b 45 f4	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  000d5	83 e8 54	 sub	 eax, 84			; 00000054H
  000d8	89 45 fc	 mov	 DWORD PTR _pClient$[ebp], eax

; 917  : 
; 918  : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 919  : 
; 920  :         if(!pClient->m_Notifier.GetStatus(MCPX_NOTIFIER_SSLA_DONE))
; 921  :         {
; 922  :             if(!pClient->m_Notifier.GetStatus(MCPX_NOTIFIER_SSLB_DONE))
; 923  :             {
; 924  :                 if(!pClient->m_Notifier.GetStatus(MCPX_NOTIFIER_VOICE_OFF))
; 925  :                 {
; 926  :                     ASSERTMSG("Voice has no signaled notifiers");
; 927  :                 }
; 928  :             }
; 929  :         }
; 930  : 
; 931  : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 932  : 
; 933  :         pClient->ServiceVoiceInterrupt();

  000db	8b 4d fc	 mov	 ecx, DWORD PTR _pClient$[ebp]
  000de	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _pClient$[ebp]
  000e3	ff 52 14	 call	 DWORD PTR [edx+20]

; 934  :     }

  000e6	eb af		 jmp	 SHORT $L37879
$L37862:

; 935  : }

  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
?ServiceVoiceInterrupt@CMcpxAPU@DirectSound@@IAEXXZ ENDP ; DirectSound::CMcpxAPU::ServiceVoiceInterrupt
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?GetInterruptStatusCallback@CMcpxAPU@DirectSound@@CGEPAX@Z
DSOUND	SEGMENT
_pThis$ = -4
_pvContext$ = 8
?GetInterruptStatusCallback@CMcpxAPU@DirectSound@@CGEPAX@Z PROC NEAR ; DirectSound::CMcpxAPU::GetInterruptStatusCallback, COMDAT

; 961  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 962  :     CMcpxAPU *              pThis   = (CMcpxAPU *)pvContext;

  00004	8b 45 08	 mov	 eax, DWORD PTR _pvContext$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pThis$[ebp], eax

; 963  : 
; 964  :     pThis->m_arInterruptStatus[1].uValue |= INTERLOCKED_EXCHANGE(pThis->m_arInterruptStatus[0].uValue, 0);

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _pThis$[ebp]
  0000d	81 c1 bc 04 00
	00		 add	 ecx, 1212		; 000004bcH
  00013	33 d2		 xor	 edx, edx
  00015	e8 00 00 00 00	 call	 @InterlockedExchange@8
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _pThis$[ebp]
  0001d	8b 91 c4 04 00
	00		 mov	 edx, DWORD PTR [ecx+1220]
  00023	0b d0		 or	 edx, eax
  00025	8b 45 fc	 mov	 eax, DWORD PTR _pThis$[ebp]
  00028	89 90 c4 04 00
	00		 mov	 DWORD PTR [eax+1220], edx

; 965  : 
; 966  :     return TRUE;

  0002e	b0 01		 mov	 al, 1

; 967  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?GetInterruptStatusCallback@CMcpxAPU@DirectSound@@CGEPAX@Z ENDP ; DirectSound::CMcpxAPU::GetInterruptStatusCallback
; Function compile flags: /Odt
; File c:\xbox\private\ntos\inc\i386.h
DSOUND	ENDS
;	COMDAT @InterlockedExchange@8
DSOUND	SEGMENT
_Value$ = -8
_Target$ = -4
@InterlockedExchange@8 PROC NEAR			; COMDAT
; _Target$ = ecx
; _Value$ = edx

; 1299 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 55 f8	 mov	 DWORD PTR _Value$[ebp], edx
  00009	89 4d fc	 mov	 DWORD PTR _Target$[ebp], ecx

; 1300 :     __asm {
; 1301 :         mov     edx, Value

  0000c	8b 55 f8	 mov	 edx, DWORD PTR _Value$[ebp]

; 1302 :         mov     ecx, Target

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _Target$[ebp]

; 1303 :         mov     eax, [ecx]

  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
$ie$10613:

; 1304 : ie:     cmpxchg [ecx], edx

  00014	0f b1 11	 cmpxchg DWORD PTR [ecx], edx

; 1305 :         jnz     short ie

  00017	75 fb		 jne	 SHORT $ie$10613

; 1306 :     }
; 1307 : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
@InterlockedExchange@8 ENDP
DSOUND	ENDS
PUBLIC	?HandleSoftwareMethod@CMcpxAPU@DirectSound@@IAEXKK@Z ; DirectSound::CMcpxAPU::HandleSoftwareMethod
PUBLIC	?SetFrontEndState@CMcpxCore@DirectSound@@IAEXW4MCPX_FE_STATE@@@Z ; DirectSound::CMcpxCore::SetFrontEndState
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpapu.cpp
;	COMDAT ?HandleFETrap@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT
tv70 = -20
_this$ = -16
_rFeControl$ = -12
_dwMethod$ = -8
_dwParam$ = -4
?HandleFETrap@CMcpxAPU@DirectSound@@IAEXXZ PROC NEAR	; DirectSound::CMcpxAPU::HandleFETrap, COMDAT
; _this$ = ecx

; 993  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 994  :     R_FE_CONTROL            rFeControl;
; 995  :     DWORD                   dwParam;
; 996  :     DWORD                   dwMethod;
; 997  : 
; 998  :     //
; 999  :     // Whahoppen?
; 1000 :     //
; 1001 :     
; 1002 :     MCPX_REG_READ(NV_PAPU_FECTL, &rFeControl.uValue);

  00009	a1 00 11 80 fe	 mov	 eax, DWORD PTR ds:-25161472
  0000e	89 45 f4	 mov	 DWORD PTR _rFeControl$[ebp], eax

; 1003 : 
; 1004 : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 1005 : 
; 1006 :     ASSERT(NV_PAPU_FECTL_FEMETHMODE_TRAPPED == rFeControl.Mode);
; 1007 : 
; 1008 : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 1009 : 
; 1010 :     MCPX_REG_READ(NV_PAPU_FEDECMETH, &dwMethod);

  00011	8b 0d 00 13 80
	fe		 mov	 ecx, DWORD PTR ds:-25160960
  00017	89 4d f8	 mov	 DWORD PTR _dwMethod$[ebp], ecx

; 1011 :     MCPX_REG_READ(NV_PAPU_FEDECPARAM, &dwParam);

  0001a	8b 15 04 13 80
	fe		 mov	 edx, DWORD PTR ds:-25160956
  00020	89 55 fc	 mov	 DWORD PTR _dwParam$[ebp], edx

; 1012 : 
; 1013 :     dwMethod = MCPX_GET_REG_VALUE(dwMethod, NV_PAPU_FEDECMETH_METH);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _dwMethod$[ebp]
  00026	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002b	89 45 f8	 mov	 DWORD PTR _dwMethod$[ebp], eax

; 1014 :     dwParam = MCPX_GET_REG_VALUE(dwParam, NV_PAPU_FEDECPARAM_VALUE);

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _dwParam$[ebp]
  00031	89 4d fc	 mov	 DWORD PTR _dwParam$[ebp], ecx

; 1015 : 
; 1016 :     switch(rFeControl.TrapReason)
; 1017 :     {

  00034	8b 55 f4	 mov	 edx, DWORD PTR _rFeControl$[ebp]
  00037	c1 ea 08	 shr	 edx, 8
  0003a	83 e2 0f	 and	 edx, 15			; 0000000fH
  0003d	89 55 ec	 mov	 DWORD PTR tv70[ebp], edx
  00040	83 7d ec 0f	 cmp	 DWORD PTR tv70[ebp], 15	; 0000000fH
  00044	74 02		 je	 SHORT $L37917
  00046	eb 10		 jmp	 SHORT $L37904
$L37917:

; 1018 :         case NV_PAPU_FECTL_FETRAPREASON_NONE:
; 1019 :             DPF_ERROR("NONE: method %x, param %x", dwMethod, dwParam);
; 1020 :             break;
; 1021 : 
; 1022 :         case NV_PAPU_FECTL_FETRAPREASON_NOT_IMPLEMENTED:
; 1023 :             DPF_ERROR("NOT_IMPLEMENTED: method %x, param %x", dwMethod, dwParam);
; 1024 :             break;
; 1025 : 
; 1026 :         case NV_PAPU_FECTL_FETRAPREASON_METHOD_UNKNOWN:
; 1027 :             DPF_ERROR("METHOD_UNKNOWN: method %x, param %x", dwMethod, dwParam);
; 1028 :             break;
; 1029 : 
; 1030 :         case NV_PAPU_FECTL_FETRAPREASON_BAD_ARGUMENT:
; 1031 :             DPF_ERROR("BAD_ARGUMENT: method %x, param %x", dwMethod, dwParam);
; 1032 :             break;
; 1033 : 
; 1034 :         case NV_PAPU_FECTL_FETRAPREASON_CURRENT_NOT_SET:
; 1035 :             DPF_ERROR("CURRENT_NOT_SET: method %x, param %x", dwMethod, dwParam);
; 1036 :             break;
; 1037 : 
; 1038 :         case NV_PAPU_FECTL_FETRAPREASON_ANTECEDENT_NOT_SET:
; 1039 :             DPF_ERROR("ANTECEDENT_NOT_SET: method %x, param %x", dwMethod, dwParam);
; 1040 :             break;
; 1041 : 
; 1042 :         case NV_PAPU_FECTL_FETRAPREASON_BAD_DATA_TYPE:
; 1043 :             DPF_ERROR("BAD_DATA_TYPE: method %x, param %x", dwMethod, dwParam);
; 1044 :             break;
; 1045 : 
; 1046 :         case NV_PAPU_FECTL_FETRAPREASON_BAD_LIST_POINTER:
; 1047 :             DPF_ERROR("BAD_LIST_POINTER: method %x, param %x", dwMethod, dwParam);
; 1048 :             break;
; 1049 : 
; 1050 :         case NV_PAPU_FECTL_FETRAPREASON_CURRENT_VOICE_NOT_3D:
; 1051 :             DPF_ERROR("CURRENT_VOICE_NOT_3d: method %x, param %x", dwMethod, dwParam);
; 1052 :             break;
; 1053 : 
; 1054 :         case NV_PAPU_FECTL_FETRAPREASON_CTXPA_INVALID:
; 1055 :             DPF_ERROR("CTXPA_INVALID: method %x, param %x", dwMethod, dwParam);
; 1056 :             break;
; 1057 : 
; 1058 :         case NV_PAPU_FECTL_FETRAPREASON_REQUESTED:
; 1059 :             HandleSoftwareMethod(dwMethod, dwParam);

  00048	8b 45 fc	 mov	 eax, DWORD PTR _dwParam$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _dwMethod$[ebp]
  0004f	51		 push	 ecx
  00050	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?HandleSoftwareMethod@CMcpxAPU@DirectSound@@IAEXKK@Z ; DirectSound::CMcpxAPU::HandleSoftwareMethod
$L37904:

; 1060 :             break;
; 1061 :         
; 1062 :         default:
; 1063 :             DPF_ERROR("(unknown) %x: method %x, param %x", (DWORD)rFeControl.TrapReason, dwMethod, dwParam);
; 1064 :             break;
; 1065 :     }
; 1066 : 
; 1067 :     //
; 1068 :     // Snap the FE out of trap mode
; 1069 :     //
; 1070 : 
; 1071 :     SetFrontEndState(MCPX_FE_STATE_HALTED);

  00058	6a 00		 push	 0
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	83 c1 08	 add	 ecx, 8
  00060	e8 00 00 00 00	 call	 ?SetFrontEndState@CMcpxCore@DirectSound@@IAEXW4MCPX_FE_STATE@@@Z ; DirectSound::CMcpxCore::SetFrontEndState

; 1072 :     SetFrontEndState(MCPX_FE_STATE_FREE_RUNNING);

  00065	6a 01		 push	 1
  00067	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 08	 add	 ecx, 8
  0006d	e8 00 00 00 00	 call	 ?SetFrontEndState@CMcpxCore@DirectSound@@IAEXW4MCPX_FE_STATE@@@Z ; DirectSound::CMcpxCore::SetFrontEndState

; 1073 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?HandleFETrap@CMcpxAPU@DirectSound@@IAEXXZ ENDP		; DirectSound::CMcpxAPU::HandleFETrap
DSOUND	ENDS
PUBLIC	?HandleIdleVoice@CMcpxAPU@DirectSound@@IAEXK@Z	; DirectSound::CMcpxAPU::HandleIdleVoice
; Function compile flags: /Odt
;	COMDAT ?HandleSoftwareMethod@CMcpxAPU@DirectSound@@IAEXKK@Z
DSOUND	SEGMENT
tv64 = -8
_this$ = -4
_dwMethod$ = 8
_dwParam$ = 12
?HandleSoftwareMethod@CMcpxAPU@DirectSound@@IAEXKK@Z PROC NEAR ; DirectSound::CMcpxAPU::HandleSoftwareMethod, COMDAT
; _this$ = ecx

; 1264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1265 :     switch(dwMethod)
; 1266 :     {

  00009	8b 45 08	 mov	 eax, DWORD PTR _dwMethod$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR tv64[ebp], eax
  0000f	81 7d f8 00 80
	00 00		 cmp	 DWORD PTR tv64[ebp], 32768 ; 00008000H
  00016	74 02		 je	 SHORT $L37928
  00018	eb 0c		 jmp	 SHORT $L37923
$L37928:

; 1267 :         case 0x8000:
; 1268 :             
; 1269 :             //
; 1270 :             // SE2FE_IDLE_VOICE is undocumented since it's an internal method
; 1271 :             //
; 1272 : 
; 1273 :             HandleIdleVoice(dwParam);

  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _dwParam$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?HandleIdleVoice@CMcpxAPU@DirectSound@@IAEXK@Z ; DirectSound::CMcpxAPU::HandleIdleVoice
$L37923:

; 1274 : 
; 1275 :             break;
; 1276 : 
; 1277 :         default:
; 1278 :             
; 1279 :             //
; 1280 :             // Huh?
; 1281 :             //
; 1282 : 
; 1283 :             DPF_ERROR("Unexpected software method:  %x %x", dwMethod, dwParam);
; 1284 : 
; 1285 :             break;
; 1286 :     }
; 1287 : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?HandleSoftwareMethod@CMcpxAPU@DirectSound@@IAEXKK@Z ENDP ; DirectSound::CMcpxAPU::HandleSoftwareMethod
DSOUND	ENDS
PUBLIC	?RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z ; DirectSound::CMcpxVoiceClient::RemoveIdleVoice
; Function compile flags: /Odt
;	COMDAT ?HandleIdleVoice@CMcpxAPU@DirectSound@@IAEXK@Z
DSOUND	SEGMENT
_this$ = -12
_dwVoiceFormat$ = -8
_pClient$ = -4
_dwIdleVoice$ = 8
?HandleIdleVoice@CMcpxAPU@DirectSound@@IAEXK@Z PROC NEAR ; DirectSound::CMcpxAPU::HandleIdleVoice, COMDAT
; _this$ = ecx

; 1314 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1315 :     CMcpxVoiceClient *      pClient;
; 1316 :     DWORD                   dwVoiceFormat;
; 1317 :     
; 1318 : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 1319 : 
; 1320 :     DWORD                   dwVoiceState;
; 1321 : 
; 1322 : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 1323 : 
; 1324 :     DEBUGLOG("HandleIdleVoice %x", dwIdleVoice);
; 1325 : 
; 1326 :     //
; 1327 :     // Check the voice index for validity.  The hardware sometimes likes
; 1328 :     // to have some fun with us.
; 1329 :     //
; 1330 : 
; 1331 :     if(dwIdleVoice < MCPX_HW_MAX_VOICES)

  00009	81 7d 08 00 01
	00 00		 cmp	 DWORD PTR _dwIdleVoice$[ebp], 256 ; 00000100H
  00010	0f 83 9c 00 00
	00		 jae	 $L37933

; 1332 :     {
; 1333 :         //
; 1334 :         // Make sure no-one's accessing the voice map.  If they are, we can
; 1335 :         // just ignore the idle message and it will get posted again on the
; 1336 :         // next frame.
; 1337 :         //
; 1338 : 
; 1339 :         if(!m_dwVoiceMapLock)

  00016	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [eax+136], 0
  00020	75 6b		 jne	 SHORT $L37937

; 1340 :         {
; 1341 :             //
; 1342 :             // Don't remove PERSIST voices from the list.  When those voices
; 1343 :             // need to go away, they'll remove the PERSIST bit from their
; 1344 :             // format.
; 1345 :             //
; 1346 : 
; 1347 : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 1348 : 
; 1349 :             MCPX_VOICE_STRUCT_READ(dwIdleVoice, NV_PAVS_VOICE_PAR_STATE, &dwVoiceState);
; 1350 : 
; 1351 : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 1352 : 
; 1353 :             MCPX_VOICE_STRUCT_READ(dwIdleVoice, NV_PAVS_VOICE_CFG_FMT, &dwVoiceFormat);

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _dwIdleVoice$[ebp]
  00025	c1 e1 07	 shl	 ecx, 7
  00028	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+48
  0002e	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  00032	89 45 f8	 mov	 DWORD PTR _dwVoiceFormat$[ebp], eax

; 1354 : 
; 1355 :             if(!MCPX_GET_REG_VALUE(dwVoiceFormat, NV_PAVS_VOICE_CFG_FMT_PERSIST))

  00035	8b 4d f8	 mov	 ecx, DWORD PTR _dwVoiceFormat$[ebp]
  00038	c1 e9 17	 shr	 ecx, 23			; 00000017H
  0003b	83 e1 01	 and	 ecx, 1
  0003e	85 c9		 test	 ecx, ecx
  00040	75 49		 jne	 SHORT $L37947

; 1356 :             {
; 1357 : 
; 1358 : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 1359 : 
; 1360 :                 DPF_BLAB("Hardware reports voice %x is idle", dwIdleVoice);
; 1361 : 
; 1362 :                 ASSERT(!MCPX_GET_REG_VALUE(dwVoiceState, NV_PAVS_VOICE_PAR_STATE_ACTIVE_VOICE));
; 1363 : 
; 1364 : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 1365 :         
; 1366 :                 //
; 1367 :                 // Get the voice client for the hardware voice
; 1368 :                 //
; 1369 : 
; 1370 :                 pClient = m_apVoiceMap[dwIdleVoice];

  00042	8b 55 08	 mov	 edx, DWORD PTR _dwIdleVoice$[ebp]
  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 8c 90 8c 00
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+140]
  0004f	89 4d fc	 mov	 DWORD PTR _pClient$[ebp], ecx

; 1371 : 
; 1372 : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 1373 : 
; 1374 :                 ASSERT(pClient);
; 1375 : 
; 1376 : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 1377 : 
; 1378 : #ifdef MCPX_DEBUG_STUCK_VOICES
; 1379 : 
; 1380 :                 pClient->m_dwIgnoredTraps = 0;

  00052	8b 55 fc	 mov	 edx, DWORD PTR _pClient$[ebp]
  00055	c7 82 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+136], 0

; 1381 : 
; 1382 : #endif // MCPX_DEBUG_STUCK_VOICES
; 1383 :         
; 1384 :                 //
; 1385 :                 // We don't want to remove the voice from the processing list until the
; 1386 :                 // last hardware voice is done processing.  Because the voices are always
; 1387 :                 // placed into the processing list in order, the last voice in the array
; 1388 :                 // should be the last one to finish.
; 1389 :                 //
; 1390 : 
; 1391 :                 if(dwIdleVoice == (DWORD)pClient->m_ahVoices[pClient->m_bVoiceCount - 1])

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _pClient$[ebp]
  00062	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  00066	8b 55 fc	 mov	 edx, DWORD PTR _pClient$[ebp]
  00069	0f b7 44 4a 0a	 movzx	 eax, WORD PTR [edx+ecx*2+10]
  0006e	39 45 08	 cmp	 DWORD PTR _dwIdleVoice$[ebp], eax
  00071	75 18		 jne	 SHORT $L37947

; 1392 :                 {
; 1393 :                     if(IsEntryInList(&pClient->m_leActiveVoice))

  00073	8b 4d fc	 mov	 ecx, DWORD PTR _pClient$[ebp]
  00076	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00079	8b 55 fc	 mov	 edx, DWORD PTR _pClient$[ebp]
  0007c	39 4a 4c	 cmp	 DWORD PTR [edx+76], ecx
  0007f	74 0a		 je	 SHORT $L37947

; 1394 :                     {
; 1395 :                         pClient->RemoveIdleVoice();

  00081	6a 01		 push	 1
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _pClient$[ebp]
  00086	e8 00 00 00 00	 call	 ?RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z ; DirectSound::CMcpxVoiceClient::RemoveIdleVoice
$L37947:

; 1396 :                     }            
; 1397 :                     else
; 1398 :                     {
; 1399 :                         ASSERTMSG("Voice not in software active list");
; 1400 :                     }
; 1401 :                 }
; 1402 :                 else
; 1403 :                 {
; 1404 : 
; 1405 : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 1406 : 
; 1407 :                     DPF_BLAB("Waiting for voice %x to idle...", pClient->m_ahVoices[pClient->m_bVoiceCount - 1]);
; 1408 : 
; 1409 : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 1410 :         
; 1411 :                 }
; 1412 :             }
; 1413 :             else
; 1414 :             {
; 1415 : 
; 1416 : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 1417 : 
; 1418 :                 ASSERT(!MCPX_GET_REG_VALUE(dwVoiceState, NV_PAVS_VOICE_PAR_STATE_ACTIVE_VOICE));
; 1419 : 
; 1420 : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 1421 : 
; 1422 :             }
; 1423 :         }
; 1424 : 
; 1425 : #ifdef MCPX_DEBUG_STUCK_VOICES
; 1426 : 
; 1427 :         else

  0008b	eb 25		 jmp	 SHORT $L37933
$L37937:

; 1428 :         {
; 1429 :             pClient = m_apVoiceMap[dwIdleVoice];

  0008d	8b 45 08	 mov	 eax, DWORD PTR _dwIdleVoice$[ebp]
  00090	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	8b 94 81 8c 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+140]
  0009a	89 55 fc	 mov	 DWORD PTR _pClient$[ebp], edx

; 1430 :             ASSERT(pClient);
; 1431 : 
; 1432 :             pClient->m_dwIgnoredTraps++;

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _pClient$[ebp]
  000a0	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  000a6	83 c1 01	 add	 ecx, 1
  000a9	8b 55 fc	 mov	 edx, DWORD PTR _pClient$[ebp]
  000ac	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx
$L37933:

; 1433 :         }
; 1434 : 
; 1435 : #endif // MCPX_DEBUG_STUCK_VOICES
; 1436 :         
; 1437 :     }
; 1438 : 
; 1439 : #if defined(MCPX_ENABLE_ISR_DEBUGGING) || defined(MCPX_DEBUG_STUCK_VOICES)
; 1440 : 
; 1441 :     else
; 1442 :     {
; 1443 :         DPF_ERROR("Internal hardware error -- invalid voice index in idle message (%x)", dwIdleVoice);
; 1444 :     }
; 1445 : 
; 1446 : #endif // defined(MCPX_ENABLE_ISR_DEBUGGING) || defined(MCPX_DEBUG_STUCK_VOICES)
; 1447 : 
; 1448 : }

  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 04 00	 ret	 4
?HandleIdleVoice@CMcpxAPU@DirectSound@@IAEXK@Z ENDP	; DirectSound::CMcpxAPU::HandleIdleVoice
DSOUND	ENDS
PUBLIC	?ScheduleDeferredCommandHigh@CMcpxAPU@DirectSound@@IAEHPAUMCPX_DEFERRED_COMMAND@@@Z ; DirectSound::CMcpxAPU::ScheduleDeferredCommandHigh
PUBLIC	?ScheduleDeferredCommandLow@CMcpxAPU@DirectSound@@IAEHPAUMCPX_DEFERRED_COMMAND@@@Z ; DirectSound::CMcpxAPU::ScheduleDeferredCommandLow
; Function compile flags: /Odt
;	COMDAT ?ScheduleDeferredCommand@CMcpxAPU@DirectSound@@QAEHPAUMCPX_DEFERRED_COMMAND@@@Z
DSOUND	SEGMENT
_this$ = -20
$T42162 = -16
___AutoIrql$ = -12
_fScheduled$ = -4
_pCmd$ = 8
?ScheduleDeferredCommand@CMcpxAPU@DirectSound@@QAEHPAUMCPX_DEFERRED_COMMAND@@@Z PROC NEAR ; DirectSound::CMcpxAPU::ScheduleDeferredCommand, COMDAT
; _this$ = ecx

; 1576 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1577 :     BOOL                    fScheduled;
; 1578 :  
; 1579 :     DPF_ENTER();
; 1580 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1581 : 
; 1582 :     if(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY)

  00011	8b 45 08	 mov	 eax, DWORD PTR _pCmd$[ebp]
  00014	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00017	83 e1 01	 and	 ecx, 1
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 11		 je	 SHORT $L37956

; 1583 :     {
; 1584 :         fScheduled = ScheduleDeferredCommandLow(pCmd);

  0001e	8b 55 08	 mov	 edx, DWORD PTR _pCmd$[ebp]
  00021	52		 push	 edx
  00022	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?ScheduleDeferredCommandLow@CMcpxAPU@DirectSound@@IAEHPAUMCPX_DEFERRED_COMMAND@@@Z ; DirectSound::CMcpxAPU::ScheduleDeferredCommandLow
  0002a	89 45 fc	 mov	 DWORD PTR _fScheduled$[ebp], eax

; 1585 :     }
; 1586 :     else

  0002d	eb 0f		 jmp	 SHORT $L37957
$L37956:

; 1587 :     {
; 1588 :         fScheduled = ScheduleDeferredCommandHigh(pCmd);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _pCmd$[ebp]
  00032	50		 push	 eax
  00033	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?ScheduleDeferredCommandHigh@CMcpxAPU@DirectSound@@IAEHPAUMCPX_DEFERRED_COMMAND@@@Z ; DirectSound::CMcpxAPU::ScheduleDeferredCommandHigh
  0003b	89 45 fc	 mov	 DWORD PTR _fScheduled$[ebp], eax
$L37957:

; 1589 :     }
; 1590 : 
; 1591 :     if(fScheduled)

  0003e	83 7d fc 00	 cmp	 DWORD PTR _fScheduled$[ebp], 0
  00042	74 0f		 je	 SHORT $L37958

; 1592 :     {
; 1593 :         pCmd->dwFlags |= MCPX_DEFERREDCMDF_SCHEDULED;

  00044	8b 4d 08	 mov	 ecx, DWORD PTR _pCmd$[ebp]
  00047	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004a	83 ca 02	 or	 edx, 2
  0004d	8b 45 08	 mov	 eax, DWORD PTR _pCmd$[ebp]
  00050	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L37958:

; 1594 :     }
; 1595 : 
; 1596 :     DPF_LEAVE(fScheduled);
; 1597 : 
; 1598 :     return fScheduled;

  00053	8b 4d fc	 mov	 ecx, DWORD PTR _fScheduled$[ebp]
  00056	89 4d f0	 mov	 DWORD PTR $T42162[ebp], ecx
  00059	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0005c	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00061	8b 45 f0	 mov	 eax, DWORD PTR $T42162[ebp]

; 1599 : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
?ScheduleDeferredCommand@CMcpxAPU@DirectSound@@QAEHPAUMCPX_DEFERRED_COMMAND@@@Z ENDP ; DirectSound::CMcpxAPU::ScheduleDeferredCommand
DSOUND	ENDS
EXTRN	__imp__KeSetTimer@16:NEAR
; Function compile flags: /Odt
;	COMDAT ?ScheduleDeferredCommandHigh@CMcpxAPU@DirectSound@@IAEHPAUMCPX_DEFERRED_COMMAND@@@Z
DSOUND	SEGMENT
tv174 = -48
tv173 = -44
tv74 = -40
tv155 = -36
tv140 = -32
tv132 = -28
_this$ = -24
_fScheduled$ = -20
_rtCurrentTime$ = -16
_pleNextEntry$ = -4
_pCmd$ = 8
?ScheduleDeferredCommandHigh@CMcpxAPU@DirectSound@@IAEHPAUMCPX_DEFERRED_COMMAND@@@Z PROC NEAR ; DirectSound::CMcpxAPU::ScheduleDeferredCommandHigh, COMDAT
; _this$ = ecx

; 1627 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1628 :     REFERENCE_TIME          rtCurrentTime;
; 1629 :     PLIST_ENTRY             pleNextEntry;
; 1630 :     BOOL                    fScheduled;
; 1631 : 
; 1632 :     DPF_ENTER();
; 1633 : 
; 1634 :     ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
; 1635 :     ASSERT(!(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY));
; 1636 :     ASSERT(!(pCmd->dwFlags & MCPX_DEFERREDCMDF_PERSIST));
; 1637 : 
; 1638 :     //
; 1639 :     // Check the current time.  If the timestamp has already elapsed,
; 1640 :     // we aren't going to schedule the command.
; 1641 :     //
; 1642 : 
; 1643 :     if(pCmd->rtTimestamp)

  00009	8b 45 08	 mov	 eax, DWORD PTR _pCmd$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR tv132[ebp], eax
  0000f	8b 4d e4	 mov	 ecx, DWORD PTR tv132[ebp]
  00012	8b 55 e4	 mov	 edx, DWORD PTR tv132[ebp]
  00015	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00018	0b 42 1c	 or	 eax, DWORD PTR [edx+28]
  0001b	85 c0		 test	 eax, eax
  0001d	0f 84 26 01 00
	00		 je	 $L37967

; 1644 :     {
; 1645 :         KeQuerySystemTime((PLARGE_INTEGER)&rtCurrentTime);

  00023	8d 4d f0	 lea	 ecx, DWORD PTR _rtCurrentTime$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQuerySystemTime@4

; 1646 : 
; 1647 :         if(pCmd->rtTimestamp <= 0)

  0002d	8b 55 08	 mov	 edx, DWORD PTR _pCmd$[ebp]
  00030	89 55 e0	 mov	 DWORD PTR tv140[ebp], edx
  00033	8b 45 e0	 mov	 eax, DWORD PTR tv140[ebp]
  00036	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0003a	7f 23		 jg	 SHORT $L37969
  0003c	7c 09		 jl	 SHORT $L42168
  0003e	8b 4d e0	 mov	 ecx, DWORD PTR tv140[ebp]
  00041	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  00045	77 18		 ja	 SHORT $L37969
$L42168:

; 1648 :         {
; 1649 :             pCmd->rtTimestamp = rtCurrentTime - pCmd->rtTimestamp;

  00047	8b 55 08	 mov	 edx, DWORD PTR _pCmd$[ebp]
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _rtCurrentTime$[ebp]
  0004d	2b 42 18	 sub	 eax, DWORD PTR [edx+24]
  00050	8b 4d f4	 mov	 ecx, DWORD PTR _rtCurrentTime$[ebp+4]
  00053	1b 4a 1c	 sbb	 ecx, DWORD PTR [edx+28]
  00056	8b 55 08	 mov	 edx, DWORD PTR _pCmd$[ebp]
  00059	89 42 18	 mov	 DWORD PTR [edx+24], eax
  0005c	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx
$L37969:

; 1650 :         }
; 1651 : 
; 1652 :         if(fScheduled = (pCmd->rtTimestamp > rtCurrentTime))

  0005f	8b 45 08	 mov	 eax, DWORD PTR _pCmd$[ebp]
  00062	89 45 dc	 mov	 DWORD PTR tv155[ebp], eax
  00065	8b 4d dc	 mov	 ecx, DWORD PTR tv155[ebp]
  00068	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0006b	3b 55 f4	 cmp	 edx, DWORD PTR _rtCurrentTime$[ebp+4]
  0006e	7c 16		 jl	 SHORT $L42166
  00070	7f 0b		 jg	 SHORT $L42169
  00072	8b 45 dc	 mov	 eax, DWORD PTR tv155[ebp]
  00075	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00078	3b 4d f0	 cmp	 ecx, DWORD PTR _rtCurrentTime$[ebp]
  0007b	76 09		 jbe	 SHORT $L42166
$L42169:
  0007d	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00084	eb 07		 jmp	 SHORT $L42167
$L42166:
  00086	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$L42167:
  0008d	8b 55 d8	 mov	 edx, DWORD PTR tv74[ebp]
  00090	89 55 ec	 mov	 DWORD PTR _fScheduled$[ebp], edx
  00093	83 7d ec 00	 cmp	 DWORD PTR _fScheduled$[ebp], 0
  00097	0f 84 aa 00 00
	00		 je	 $L37970

; 1653 :         {
; 1654 :             //
; 1655 :             // If the command is already scheduled, remove it from the queue
; 1656 :             //
; 1657 : 
; 1658 :             if(pCmd->dwFlags & MCPX_DEFERREDCMDF_SCHEDULED)

  0009d	8b 45 08	 mov	 eax, DWORD PTR _pCmd$[ebp]
  000a0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a3	83 e1 02	 and	 ecx, 2
  000a6	85 c9		 test	 ecx, ecx
  000a8	74 0c		 je	 SHORT $L37971

; 1659 :             {
; 1660 :                 RemoveDeferredCommand(pCmd);

  000aa	8b 55 08	 mov	 edx, DWORD PTR _pCmd$[ebp]
  000ad	52		 push	 edx
  000ae	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?RemoveDeferredCommand@CMcpxAPU@DirectSound@@QAEXPAUMCPX_DEFERRED_COMMAND@@@Z ; DirectSound::CMcpxAPU::RemoveDeferredCommand
$L37971:

; 1661 :             }
; 1662 : 
; 1663 :             //
; 1664 :             // Insert the command into the list in the order commands should be
; 1665 :             // processed.
; 1666 :             //
; 1667 : 
; 1668 :             for(pleNextEntry = m_lstDeferredCommandsHigh.Flink; pleNextEntry != &m_lstDeferredCommandsHigh; pleNextEntry = pleNextEntry->Flink)

  000b6	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 88 ac 04 00
	00		 mov	 ecx, DWORD PTR [eax+1196]
  000bf	89 4d fc	 mov	 DWORD PTR _pleNextEntry$[ebp], ecx
  000c2	eb 08		 jmp	 SHORT $L37972
$L37973:
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _pleNextEntry$[ebp]
  000c7	8b 02		 mov	 eax, DWORD PTR [edx]
  000c9	89 45 fc	 mov	 DWORD PTR _pleNextEntry$[ebp], eax
$L37972:
  000cc	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	81 c1 ac 04 00
	00		 add	 ecx, 1196		; 000004acH
  000d5	39 4d fc	 cmp	 DWORD PTR _pleNextEntry$[ebp], ecx
  000d8	74 2e		 je	 SHORT $L37974

; 1669 :             {
; 1670 :                 AssertValidEntryList(pleNextEntry, ASSERT_IN_LIST);
; 1671 : 
; 1672 :                 if(CONTAINING_RECORD(pleNextEntry, MCPX_DEFERRED_COMMAND, leListEntry)->rtTimestamp > pCmd->rtTimestamp)

  000da	8b 55 fc	 mov	 edx, DWORD PTR _pleNextEntry$[ebp]
  000dd	8b 45 08	 mov	 eax, DWORD PTR _pCmd$[ebp]
  000e0	89 55 d4	 mov	 DWORD PTR tv173[ebp], edx
  000e3	89 45 d0	 mov	 DWORD PTR tv174[ebp], eax
  000e6	8b 4d d4	 mov	 ecx, DWORD PTR tv173[ebp]
  000e9	8b 55 d0	 mov	 edx, DWORD PTR tv174[ebp]
  000ec	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  000ef	3b 42 1c	 cmp	 eax, DWORD PTR [edx+28]
  000f2	7c 12		 jl	 SHORT $L37979
  000f4	7f 0e		 jg	 SHORT $L42170
  000f6	8b 4d d4	 mov	 ecx, DWORD PTR tv173[ebp]
  000f9	8b 55 d0	 mov	 edx, DWORD PTR tv174[ebp]
  000fc	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  000ff	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  00102	76 02		 jbe	 SHORT $L37979
$L42170:

; 1673 :                 {
; 1674 :                     break;

  00104	eb 02		 jmp	 SHORT $L37974
$L37979:

; 1675 :                 }
; 1676 :             }

  00106	eb bc		 jmp	 SHORT $L37973
$L37974:

; 1677 : 
; 1678 :             InsertTailList(pleNextEntry, &pCmd->leListEntry);

  00108	8b 4d 08	 mov	 ecx, DWORD PTR _pCmd$[ebp]
  0010b	51		 push	 ecx
  0010c	8b 55 fc	 mov	 edx, DWORD PTR _pleNextEntry$[ebp]
  0010f	52		 push	 edx
  00110	e8 00 00 00 00	 call	 ?InsertTailList@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailList

; 1679 : 
; 1680 :             //
; 1681 :             // If we just added the new item at the head of the list, set the timer
; 1682 :             //
; 1683 : 
; 1684 :             if(&pCmd->leListEntry == m_lstDeferredCommandsHigh.Flink)

  00115	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00118	8b 4d 08	 mov	 ecx, DWORD PTR _pCmd$[ebp]
  0011b	3b 88 ac 04 00
	00		 cmp	 ecx, DWORD PTR [eax+1196]
  00121	75 24		 jne	 SHORT $L37970

; 1685 :             {
; 1686 :                 KeSetTimer(&m_tmrDeferredCommandsHigh, *(PLARGE_INTEGER)&pCmd->rtTimestamp, &m_dpcDeferredCommandsHigh);

  00123	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00126	81 c2 10 05 00
	00		 add	 edx, 1296		; 00000510H
  0012c	52		 push	 edx
  0012d	8b 45 08	 mov	 eax, DWORD PTR _pCmd$[ebp]
  00130	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00133	51		 push	 ecx
  00134	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00137	52		 push	 edx
  00138	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0013b	05 e8 04 00 00	 add	 eax, 1256		; 000004e8H
  00140	50		 push	 eax
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetTimer@16
$L37970:

; 1687 :             }
; 1688 :         }
; 1689 :     }
; 1690 :     else

  00147	eb 07		 jmp	 SHORT $L37982
$L37967:

; 1691 :     {
; 1692 :         fScheduled = FALSE;

  00149	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _fScheduled$[ebp], 0
$L37982:

; 1693 :     }
; 1694 : 
; 1695 :     DPF_LEAVE(fScheduled);
; 1696 : 
; 1697 :     return fScheduled;

  00150	8b 45 ec	 mov	 eax, DWORD PTR _fScheduled$[ebp]

; 1698 : }

  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c2 04 00	 ret	 4
?ScheduleDeferredCommandHigh@CMcpxAPU@DirectSound@@IAEHPAUMCPX_DEFERRED_COMMAND@@@Z ENDP ; DirectSound::CMcpxAPU::ScheduleDeferredCommandHigh
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?ScheduleDeferredCommandLow@CMcpxAPU@DirectSound@@IAEHPAUMCPX_DEFERRED_COMMAND@@@Z
DSOUND	SEGMENT
_this$ = -8
_pCmd$ = 8
?ScheduleDeferredCommandLow@CMcpxAPU@DirectSound@@IAEHPAUMCPX_DEFERRED_COMMAND@@@Z PROC NEAR ; DirectSound::CMcpxAPU::ScheduleDeferredCommandLow, COMDAT
; _this$ = ecx

; 1726 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1727 :     DWORD                   dwIndex;
; 1728 : 
; 1729 :     DPF_ENTER();
; 1730 : 
; 1731 :     ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
; 1732 :     ASSERT(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY);
; 1733 :     ASSERT(!pCmd->rtTimestamp);
; 1734 : 
; 1735 :     //
; 1736 :     // If the command is already in the queue, we don't need to do 
; 1737 :     // anything.  Low-priority commands don't use a timestamp, so the
; 1738 :     // list order is meaningless and there are no timers to reset.
; 1739 :     //
; 1740 : 
; 1741 :     if(!(pCmd->dwFlags & MCPX_DEFERREDCMDF_SCHEDULED))

  00009	8b 45 08	 mov	 eax, DWORD PTR _pCmd$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	83 e1 02	 and	 ecx, 2
  00012	85 c9		 test	 ecx, ecx
  00014	75 12		 jne	 SHORT $L37988

; 1742 :     {
; 1743 :         InsertTailList(&m_lstDeferredCommandsLow, &pCmd->leListEntry);

  00016	8b 55 08	 mov	 edx, DWORD PTR _pCmd$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	05 b4 04 00 00	 add	 eax, 1204		; 000004b4H
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?InsertTailList@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailList
$L37988:

; 1744 :     }
; 1745 : 
; 1746 :     DPF_LEAVE(TRUE);
; 1747 : 
; 1748 :     return TRUE;

  00028	b8 01 00 00 00	 mov	 eax, 1

; 1749 : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?ScheduleDeferredCommandLow@CMcpxAPU@DirectSound@@IAEHPAUMCPX_DEFERRED_COMMAND@@@Z ENDP ; DirectSound::CMcpxAPU::ScheduleDeferredCommandLow
DSOUND	ENDS
PUBLIC	?RemoveDeferredCommandHigh@CMcpxAPU@DirectSound@@IAEXPAUMCPX_DEFERRED_COMMAND@@@Z ; DirectSound::CMcpxAPU::RemoveDeferredCommandHigh
PUBLIC	?RemoveDeferredCommandLow@CMcpxAPU@DirectSound@@IAEXPAUMCPX_DEFERRED_COMMAND@@@Z ; DirectSound::CMcpxAPU::RemoveDeferredCommandLow
; Function compile flags: /Odt
;	COMDAT ?RemoveDeferredCommand@CMcpxAPU@DirectSound@@QAEXPAUMCPX_DEFERRED_COMMAND@@@Z
DSOUND	SEGMENT
_this$ = -12
___AutoIrql$ = -8
_pCmd$ = 8
?RemoveDeferredCommand@CMcpxAPU@DirectSound@@QAEXPAUMCPX_DEFERRED_COMMAND@@@Z PROC NEAR ; DirectSound::CMcpxAPU::RemoveDeferredCommand, COMDAT
; _this$ = ecx

; 1775 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1776 :     DPF_ENTER();
; 1777 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1778 : 
; 1779 :     if(pCmd->dwFlags & MCPX_DEFERREDCMDF_SCHEDULED)

  00011	8b 45 08	 mov	 eax, DWORD PTR _pCmd$[ebp]
  00014	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00017	83 e1 02	 and	 ecx, 2
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 27		 je	 SHORT $L37994

; 1780 :     {
; 1781 :         if(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY)

  0001e	8b 55 08	 mov	 edx, DWORD PTR _pCmd$[ebp]
  00021	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00024	83 e0 01	 and	 eax, 1
  00027	85 c0		 test	 eax, eax
  00029	74 0e		 je	 SHORT $L37995

; 1782 :         {
; 1783 :             RemoveDeferredCommandLow(pCmd);

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _pCmd$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?RemoveDeferredCommandLow@CMcpxAPU@DirectSound@@IAEXPAUMCPX_DEFERRED_COMMAND@@@Z ; DirectSound::CMcpxAPU::RemoveDeferredCommandLow

; 1784 :         }
; 1785 :         else

  00037	eb 0c		 jmp	 SHORT $L37994
$L37995:

; 1786 :         {
; 1787 :             RemoveDeferredCommandHigh(pCmd);

  00039	8b 55 08	 mov	 edx, DWORD PTR _pCmd$[ebp]
  0003c	52		 push	 edx
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?RemoveDeferredCommandHigh@CMcpxAPU@DirectSound@@IAEXPAUMCPX_DEFERRED_COMMAND@@@Z ; DirectSound::CMcpxAPU::RemoveDeferredCommandHigh
$L37994:

; 1788 :         }
; 1789 :     }
; 1790 : 
; 1791 :     pCmd->dwFlags &= ~MCPX_DEFERREDCMDF_SCHEDULED;

  00045	8b 45 08	 mov	 eax, DWORD PTR _pCmd$[ebp]
  00048	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004b	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0004e	8b 55 08	 mov	 edx, DWORD PTR _pCmd$[ebp]
  00051	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1792 : 
; 1793 :     DPF_LEAVE_VOID();
; 1794 : }

  00054	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00057	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
?RemoveDeferredCommand@CMcpxAPU@DirectSound@@QAEXPAUMCPX_DEFERRED_COMMAND@@@Z ENDP ; DirectSound::CMcpxAPU::RemoveDeferredCommand
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?RemoveDeferredCommandHigh@CMcpxAPU@DirectSound@@IAEXPAUMCPX_DEFERRED_COMMAND@@@Z
DSOUND	SEGMENT
_this$ = -8
_fListHead$ = -4
_pCmd$ = 8
?RemoveDeferredCommandHigh@CMcpxAPU@DirectSound@@IAEXPAUMCPX_DEFERRED_COMMAND@@@Z PROC NEAR ; DirectSound::CMcpxAPU::RemoveDeferredCommandHigh, COMDAT
; _this$ = ecx

; 1820 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1821 :     BOOL                    fListHead;
; 1822 : 
; 1823 :     DPF_ENTER();
; 1824 : 
; 1825 :     ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
; 1826 :     ASSERT(!(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY));
; 1827 :     ASSERT(pCmd->dwFlags & MCPX_DEFERREDCMDF_SCHEDULED);
; 1828 : 
; 1829 :     //
; 1830 :     // If this is the first command in the queue, we'll have some extra
; 1831 :     // processing to do.
; 1832 :     //
; 1833 : 
; 1834 :     fListHead = (&pCmd->leListEntry == m_lstDeferredCommandsHigh.Flink);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pCmd$[ebp]
  0000f	2b 88 ac 04 00
	00		 sub	 ecx, DWORD PTR [eax+1196]
  00015	f7 d9		 neg	 ecx
  00017	1b c9		 sbb	 ecx, ecx
  00019	41		 inc	 ecx
  0001a	89 4d fc	 mov	 DWORD PTR _fListHead$[ebp], ecx

; 1835 : 
; 1836 :     //
; 1837 :     // Remove the command from the queue.  If we're in the middle of
; 1838 :     // processing the list, defer that to later.
; 1839 :     //
; 1840 : 
; 1841 :     RemoveEntryList(&pCmd->leListEntry);

  0001d	8b 55 08	 mov	 edx, DWORD PTR _pCmd$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 1842 : 
; 1843 :     //
; 1844 :     // If that was the only item in the list, cancel the timer and remove
; 1845 :     // any pending DPCs.  If there's still items in the list, but we
; 1846 :     // removed the head, reset the timer.
; 1847 :     // 
; 1848 : 
; 1849 :     if(IsListEmpty(&m_lstDeferredCommandsHigh))

  00026	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00029	05 ac 04 00 00	 add	 eax, 1196		; 000004acH
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	39 81 ac 04 00
	00		 cmp	 DWORD PTR [ecx+1196], eax
  00037	75 21		 jne	 SHORT $L38002

; 1850 :     {
; 1851 :         KeCancelTimer(&m_tmrDeferredCommandsHigh);

  00039	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	81 c2 e8 04 00
	00		 add	 edx, 1256		; 000004e8H
  00042	52		 push	 edx
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeCancelTimer@4

; 1852 :         KeRemoveQueueDpc(&m_dpcDeferredCommandsHigh);

  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	05 10 05 00 00	 add	 eax, 1296		; 00000510H
  00051	50		 push	 eax
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeRemoveQueueDpc@4

; 1853 :     }
; 1854 :     else if(fListHead)

  00058	eb 30		 jmp	 SHORT $L38000
$L38002:
  0005a	83 7d fc 00	 cmp	 DWORD PTR _fListHead$[ebp], 0
  0005e	74 2a		 je	 SHORT $L38000

; 1855 :     {
; 1856 :         KeSetTimer(&m_tmrDeferredCommandsHigh, *(PLARGE_INTEGER)&CONTAINING_RECORD(m_lstDeferredCommandsHigh.Flink, MCPX_DEFERRED_COMMAND, leListEntry)->rtTimestamp, &m_dpcDeferredCommandsHigh);

  00060	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	81 c1 10 05 00
	00		 add	 ecx, 1296		; 00000510H
  00069	51		 push	 ecx
  0006a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	8b 82 ac 04 00
	00		 mov	 eax, DWORD PTR [edx+1196]
  00073	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00076	51		 push	 ecx
  00077	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0007a	52		 push	 edx
  0007b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	05 e8 04 00 00	 add	 eax, 1256		; 000004e8H
  00083	50		 push	 eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetTimer@16
$L38000:

; 1857 :     }
; 1858 : 
; 1859 :     DPF_LEAVE_VOID();
; 1860 : }

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
?RemoveDeferredCommandHigh@CMcpxAPU@DirectSound@@IAEXPAUMCPX_DEFERRED_COMMAND@@@Z ENDP ; DirectSound::CMcpxAPU::RemoveDeferredCommandHigh
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?RemoveDeferredCommandLow@CMcpxAPU@DirectSound@@IAEXPAUMCPX_DEFERRED_COMMAND@@@Z
DSOUND	SEGMENT
_this$ = -4
_pCmd$ = 8
?RemoveDeferredCommandLow@CMcpxAPU@DirectSound@@IAEXPAUMCPX_DEFERRED_COMMAND@@@Z PROC NEAR ; DirectSound::CMcpxAPU::RemoveDeferredCommandLow, COMDAT
; _this$ = ecx

; 1886 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1887 :     DPF_ENTER();
; 1888 : 
; 1889 :     ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
; 1890 :     ASSERT(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY);
; 1891 :     ASSERT(pCmd->dwFlags & MCPX_DEFERREDCMDF_SCHEDULED);
; 1892 : 
; 1893 :     //
; 1894 :     // Remove the command from the queue
; 1895 :     //
; 1896 : 
; 1897 :     RemoveEntryList(&pCmd->leListEntry);

  00007	8b 45 08	 mov	 eax, DWORD PTR _pCmd$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 1898 : 
; 1899 :     DPF_LEAVE_VOID();
; 1900 : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?RemoveDeferredCommandLow@CMcpxAPU@DirectSound@@IAEXPAUMCPX_DEFERRED_COMMAND@@@Z ENDP ; DirectSound::CMcpxAPU::RemoveDeferredCommandLow
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?ServiceDeferredCommandsHigh@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT
tv135 = -28
_this$ = -24
___AutoIrql$ = -20
_pCmd$ = -12
_rtCurrentTime$ = -8
?ServiceDeferredCommandsHigh@CMcpxAPU@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxAPU::ServiceDeferredCommandsHigh, COMDAT
; _this$ = ecx

; 1926 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1927 :     LPMCPX_DEFERRED_COMMAND     pCmd;
; 1928 :     REFERENCE_TIME              rtCurrentTime;
; 1929 :     
; 1930 :     DPF_ENTER();
; 1931 :     AutoIrql();

  00009	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql
$L38022:

; 1932 : 
; 1933 :     while(!IsListEmpty(&m_lstDeferredCommandsHigh))

  00011	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00014	05 ac 04 00 00	 add	 eax, 1196		; 000004acH
  00019	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	39 81 ac 04 00
	00		 cmp	 DWORD PTR [ecx+1196], eax
  00022	0f 84 9a 00 00
	00		 je	 $L38023

; 1934 :     {
; 1935 :         pCmd = CONTAINING_RECORD(m_lstDeferredCommandsHigh.Flink, MCPX_DEFERRED_COMMAND, leListEntry);

  00028	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 82 ac 04 00
	00		 mov	 eax, DWORD PTR [edx+1196]
  00031	89 45 f4	 mov	 DWORD PTR _pCmd$[ebp], eax

; 1936 : 
; 1937 :         ASSERT(!(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY));
; 1938 :         ASSERT(pCmd->dwFlags & MCPX_DEFERREDCMDF_SCHEDULED);
; 1939 :         ASSERT(!(pCmd->dwFlags & MCPX_DEFERREDCMDF_PERSIST));
; 1940 : 
; 1941 :         //
; 1942 :         // Get the current system time
; 1943 :         //
; 1944 : 
; 1945 :         KeQuerySystemTime((PLARGE_INTEGER)&rtCurrentTime);

  00034	8d 4d f8	 lea	 ecx, DWORD PTR _rtCurrentTime$[ebp]
  00037	51		 push	 ecx
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQuerySystemTime@4

; 1946 : 
; 1947 :         //
; 1948 :         // If the first command in the list's timestamp has expired, go ahead 
; 1949 :         // and trigger it and remove it from the queue.  If not, reset the
; 1950 :         // timer and bail out.
; 1951 :         //
; 1952 : 
; 1953 :         if(pCmd->rtTimestamp <= rtCurrentTime)

  0003e	8b 55 f4	 mov	 edx, DWORD PTR _pCmd$[ebp]
  00041	89 55 e4	 mov	 DWORD PTR tv135[ebp], edx
  00044	8b 45 e4	 mov	 eax, DWORD PTR tv135[ebp]
  00047	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0004a	3b 4d fc	 cmp	 ecx, DWORD PTR _rtCurrentTime$[ebp+4]
  0004d	7f 48		 jg	 SHORT $L38029
  0004f	7c 0b		 jl	 SHORT $L42186
  00051	8b 55 e4	 mov	 edx, DWORD PTR tv135[ebp]
  00054	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00057	3b 45 f8	 cmp	 eax, DWORD PTR _rtCurrentTime$[ebp]
  0005a	77 3b		 ja	 SHORT $L38029
$L42186:

; 1954 :         {
; 1955 :             pCmd->dwFlags &= ~MCPX_DEFERREDCMDF_SCHEDULED;

  0005c	8b 4d f4	 mov	 ecx, DWORD PTR _pCmd$[ebp]
  0005f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00062	83 e2 fd	 and	 edx, -3			; fffffffdH
  00065	8b 45 f4	 mov	 eax, DWORD PTR _pCmd$[ebp]
  00068	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1956 : 
; 1957 :             RemoveEntryList(&pCmd->leListEntry);

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR _pCmd$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 1958 : 
; 1959 :             pCmd->pVoice->ServiceDeferredCommand(pCmd->dwCommand, pCmd->dwContext);

  00074	8b 55 f4	 mov	 edx, DWORD PTR _pCmd$[ebp]
  00077	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0007a	50		 push	 eax
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR _pCmd$[ebp]
  0007e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00081	52		 push	 edx
  00082	8b 45 f4	 mov	 eax, DWORD PTR _pCmd$[ebp]
  00085	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00088	8b 55 f4	 mov	 edx, DWORD PTR _pCmd$[ebp]
  0008b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0008e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00090	8b c8		 mov	 ecx, eax
  00092	ff 52 20	 call	 DWORD PTR [edx+32]

; 1960 :         }
; 1961 :         else

  00095	eb 26		 jmp	 SHORT $L38030
$L38029:

; 1962 :         {
; 1963 :             KeSetTimer(&m_tmrDeferredCommandsHigh, *(PLARGE_INTEGER)&pCmd->rtTimestamp, &m_dpcDeferredCommandsHigh);

  00097	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	05 10 05 00 00	 add	 eax, 1296		; 00000510H
  0009f	50		 push	 eax
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _pCmd$[ebp]
  000a3	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000a6	52		 push	 edx
  000a7	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  000aa	50		 push	 eax
  000ab	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	81 c1 e8 04 00
	00		 add	 ecx, 1256		; 000004e8H
  000b4	51		 push	 ecx
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetTimer@16

; 1964 :             break;

  000bb	eb 05		 jmp	 SHORT $L38023
$L38030:

; 1965 :         }
; 1966 :     }

  000bd	e9 4f ff ff ff	 jmp	 $L38022
$L38023:

; 1967 : 
; 1968 :     DPF_LEAVE_VOID();
; 1969 : }

  000c2	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000c5	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
?ServiceDeferredCommandsHigh@CMcpxAPU@DirectSound@@IAEXXZ ENDP ; DirectSound::CMcpxAPU::ServiceDeferredCommandsHigh
DSOUND	ENDS
PUBLIC	?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z	; MoveEntryTailList
; Function compile flags: /Odt
;	COMDAT ?ServiceDeferredCommandsLow@CMcpxAPU@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -28
_pleEntry$ = -24
_lstCommands$ = -20
_pCmd$ = -12
_irql$ = -8
?ServiceDeferredCommandsLow@CMcpxAPU@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxAPU::ServiceDeferredCommandsLow, COMDAT
; _this$ = ecx

; 1995 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 1996 :     LIST_ENTRY              lstCommands;
; 1997 :     PLIST_ENTRY             pleEntry;
; 1998 :     LPMCPX_DEFERRED_COMMAND pCmd;
; 1999 :     CIrql                   irql;

  00009	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CIrql@DirectSound@@QAE@XZ ; DirectSound::CIrql::CIrql

; 2000 :     
; 2001 :     DPF_ENTER();
; 2002 : 
; 2003 :     //
; 2004 :     // Create a local copy of the command list.  We're doing this so we
; 2005 :     // can safely walk the list without worrying about nodes being added
; 2006 :     // or removed.
; 2007 :     //
; 2008 : 
; 2009 :     InitializeListHead(&lstCommands);

  00011	8d 45 ec	 lea	 eax, DWORD PTR _lstCommands$[ebp]
  00014	89 45 f0	 mov	 DWORD PTR _lstCommands$[ebp+4], eax
  00017	8b 4d f0	 mov	 ecx, DWORD PTR _lstCommands$[ebp+4]
  0001a	89 4d ec	 mov	 DWORD PTR _lstCommands$[ebp], ecx

; 2010 : 
; 2011 :     irql.Raise();

  0001d	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00020	e8 00 00 00 00	 call	 ?Raise@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Raise
$L38041:

; 2012 :     
; 2013 :     while(!IsListEmpty(&m_lstDeferredCommandsLow))

  00025	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00028	81 c2 b4 04 00
	00		 add	 edx, 1204		; 000004b4H
  0002e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	39 90 b4 04 00
	00		 cmp	 DWORD PTR [eax+1204], edx
  00037	74 15		 je	 SHORT $L38044

; 2014 :     {
; 2015 :         MoveEntryTailList(&lstCommands, m_lstDeferredCommandsLow.Flink);

  00039	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	8b 91 b4 04 00
	00		 mov	 edx, DWORD PTR [ecx+1204]
  00042	52		 push	 edx
  00043	8d 45 ec	 lea	 eax, DWORD PTR _lstCommands$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z ; MoveEntryTailList

; 2016 :     }

  0004c	eb d7		 jmp	 SHORT $L38041
$L38044:

; 2017 : 
; 2018 :     //
; 2019 :     // Service all commands, removing them from the local list and adding
; 2020 :     // them back to the main list.
; 2021 :     //
; 2022 : 
; 2023 :     while((pleEntry = RemoveHeadList(&lstCommands)) != &lstCommands)

  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _lstCommands$[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList
  00057	89 45 e8	 mov	 DWORD PTR _pleEntry$[ebp], eax
  0005a	8b 55 e8	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  0005d	8d 45 ec	 lea	 eax, DWORD PTR _lstCommands$[ebp]
  00060	3b d0		 cmp	 edx, eax
  00062	74 68		 je	 SHORT $L38045

; 2024 :     {
; 2025 :         pCmd = CONTAINING_RECORD(pleEntry, MCPX_DEFERRED_COMMAND, leListEntry);

  00064	8b 4d e8	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  00067	89 4d f4	 mov	 DWORD PTR _pCmd$[ebp], ecx

; 2026 : 
; 2027 :         ASSERT(pCmd->dwFlags & MCPX_DEFERREDCMDF_LOWPRIORITY);
; 2028 :         ASSERT(pCmd->dwFlags & MCPX_DEFERREDCMDF_SCHEDULED);
; 2029 : 
; 2030 :         if(pCmd->dwFlags & MCPX_DEFERREDCMDF_PERSIST)

  0006a	8b 55 f4	 mov	 edx, DWORD PTR _pCmd$[ebp]
  0006d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00070	83 e0 04	 and	 eax, 4
  00073	85 c0		 test	 eax, eax
  00075	74 15		 je	 SHORT $L38050

; 2031 :         {
; 2032 :             InsertTailList(&m_lstDeferredCommandsLow, pleEntry);

  00077	8b 4d e8	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  0007a	51		 push	 ecx
  0007b	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0007e	81 c2 b4 04 00
	00		 add	 edx, 1204		; 000004b4H
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 ?InsertTailList@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailList

; 2033 :         }
; 2034 :         else

  0008a	eb 0f		 jmp	 SHORT $L38051
$L38050:

; 2035 :         {
; 2036 :             pCmd->dwFlags &= ~MCPX_DEFERREDCMDF_SCHEDULED;

  0008c	8b 45 f4	 mov	 eax, DWORD PTR _pCmd$[ebp]
  0008f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00092	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00095	8b 55 f4	 mov	 edx, DWORD PTR _pCmd$[ebp]
  00098	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$L38051:

; 2037 :         }
; 2038 : 
; 2039 :         irql.Lower();

  0009b	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  0009e	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower

; 2040 : 
; 2041 :         pCmd->pVoice->ServiceDeferredCommand(pCmd->dwCommand, pCmd->dwContext);

  000a3	8b 45 f4	 mov	 eax, DWORD PTR _pCmd$[ebp]
  000a6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000a9	51		 push	 ecx
  000aa	8b 55 f4	 mov	 edx, DWORD PTR _pCmd$[ebp]
  000ad	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000b0	50		 push	 eax
  000b1	8b 4d f4	 mov	 ecx, DWORD PTR _pCmd$[ebp]
  000b4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000b7	8b 45 f4	 mov	 eax, DWORD PTR _pCmd$[ebp]
  000ba	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000bd	8b 12		 mov	 edx, DWORD PTR [edx]
  000bf	ff 52 20	 call	 DWORD PTR [edx+32]

; 2042 : 
; 2043 :         irql.Raise();

  000c2	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  000c5	e8 00 00 00 00	 call	 ?Raise@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Raise

; 2044 :     }

  000ca	eb 82		 jmp	 SHORT $L38044
$L38045:

; 2045 : 
; 2046 :     ASSERT(IsListEmpty(&lstCommands));
; 2047 : 
; 2048 :     irql.Lower();

  000cc	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  000cf	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower

; 2049 : 
; 2050 :     DPF_LEAVE_VOID();
; 2051 : }

  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
?ServiceDeferredCommandsLow@CMcpxAPU@DirectSound@@IAEXXZ ENDP ; DirectSound::CMcpxAPU::ServiceDeferredCommandsLow
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\ntlist.h
DSOUND	ENDS
;	COMDAT ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z
DSOUND	SEGMENT
_ListHead$ = 8
_Entry$ = 12
?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z PROC NEAR ; MoveEntryTailList, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 255  :     AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);
; 256  :     AssertValidEntryList(Entry, ASSERT_VALID_ONLY);
; 257  : 
; 258  :     Entry->Flink->Blink = Entry->Blink;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  0000b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 259  :     Entry->Blink->Flink = Entry->Flink;

  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00014	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00017	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	89 0a		 mov	 DWORD PTR [edx], ecx

; 260  : 
; 261  :     Entry->Flink = ListHead;

  0001e	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00021	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00024	89 02		 mov	 DWORD PTR [edx], eax

; 262  :     Entry->Blink = ListHead->Blink;

  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00029	8b 55 08	 mov	 edx, DWORD PTR _ListHead$[ebp]
  0002c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 263  : 
; 264  :     Entry->Flink->Blink = Entry;

  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  0003a	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 265  :     Entry->Blink->Flink = Entry;

  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00040	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00043	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00046	89 02		 mov	 DWORD PTR [edx], eax

; 266  : 
; 267  :     AssertValidEntryList(Entry, ASSERT_IN_LIST);
; 268  : 
; 269  :     return Entry;

  00048	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]

; 270  : }

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z ENDP	; MoveEntryTailList
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpapu.cpp
DSOUND	ENDS
;	COMDAT ?SetHrtfHeadroom@CMcpxAPU@DirectSound@@QAEJK@Z
DSOUND	SEGMENT
_this$ = -16
$T42196 = -12
___AutoIrql$ = -8
_dwHeadroom$ = 8
?SetHrtfHeadroom@CMcpxAPU@DirectSound@@QAEJK@Z PROC NEAR ; DirectSound::CMcpxAPU::SetHrtfHeadroom, COMDAT
; _this$ = ecx

; 2077 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2078 :     DPF_ENTER();
; 2079 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql
$L38058:

; 2080 : 
; 2081 :     MCPX_CHECK_VOICE_FIFO(1);

  00011	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00016	8b 88 00 00 82
	fe		 mov	 ecx, DWORD PTR [eax-25034752]
  0001c	c1 e9 02	 shr	 ecx, 2
  0001f	83 f9 01	 cmp	 ecx, 1
  00022	73 02		 jae	 SHORT $L38059
  00024	eb eb		 jmp	 SHORT $L38058
$L38059:

; 2082 :     MCPX_VOICE_WRITE(SetHRTFHeadroom, MCPX_MAKE_REG_VALUE(dwHeadroom, NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT));

  00026	8b 55 08	 mov	 edx, DWORD PTR _dwHeadroom$[ebp]
  00029	83 e2 07	 and	 edx, 7
  0002c	b8 80 02 00 00	 mov	 eax, 640		; 00000280H
  00031	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 2083 : 
; 2084 :     DPF_LEAVE_HRESULT(DS_OK);
; 2085 : 
; 2086 :     return DS_OK;

  00037	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T42196[ebp], 0
  0003e	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00041	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00046	8b 45 f4	 mov	 eax, DWORD PTR $T42196[ebp]

; 2087 : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?SetHrtfHeadroom@CMcpxAPU@DirectSound@@QAEJK@Z ENDP	; DirectSound::CMcpxAPU::SetHrtfHeadroom
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetMixBinHeadroom@CMcpxAPU@DirectSound@@QAEJK@Z
DSOUND	SEGMENT
_this$ = -16
$T42200 = -12
___AutoIrql$ = -8
_dwMixBin$ = 8
?SetMixBinHeadroom@CMcpxAPU@DirectSound@@QAEJK@Z PROC NEAR ; DirectSound::CMcpxAPU::SetMixBinHeadroom, COMDAT
; _this$ = ecx

; 2114 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2115 :     DPF_ENTER();
; 2116 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql
$L38073:

; 2117 : 
; 2118 :     MCPX_CHECK_VOICE_FIFO(1);

  00011	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00016	8b 88 00 00 82
	fe		 mov	 ecx, DWORD PTR [eax-25034752]
  0001c	c1 e9 02	 shr	 ecx, 2
  0001f	83 f9 01	 cmp	 ecx, 1
  00022	73 02		 jae	 SHORT $L38074
  00024	eb eb		 jmp	 SHORT $L38073
$L38074:

; 2119 :     MCPX_VOICE_WRITE(SetSubMixHeadroom[dwMixBin], MCPX_MAKE_REG_VALUE(m_pSettings->m_abMixBinHeadroom[dwMixBin], NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT));

  00026	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _dwMixBin$[ebp]
  0002f	0f b6 54 08 14	 movzx	 edx, BYTE PTR [eax+ecx+20]
  00034	83 e2 07	 and	 edx, 7
  00037	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0003c	05 00 00 82 fe	 add	 eax, -25034752		; fe820000H
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _dwMixBin$[ebp]
  00044	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx

; 2120 : 
; 2121 :     DPF_LEAVE_HRESULT(DS_OK);
; 2122 : 
; 2123 :     return DS_OK;

  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T42200[ebp], 0
  0004e	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00051	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00056	8b 45 f4	 mov	 eax, DWORD PTR $T42200[ebp]

; 2124 : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?SetMixBinHeadroom@CMcpxAPU@DirectSound@@QAEJK@Z ENDP	; DirectSound::CMcpxAPU::SetMixBinHeadroom
DSOUND	ENDS
PUBLIC	?__AddRef@DirectSound@@YGPAVCMcpxAPU@1@PAV21@@Z	; DirectSound::__AddRef
PUBLIC	??0CMcpxVoiceNotifier@DirectSound@@QAE@XZ	; DirectSound::CMcpxVoiceNotifier::CMcpxVoiceNotifier
PUBLIC	??_7CMcpxVoiceClient@DirectSound@@6B@		; DirectSound::CMcpxVoiceClient::`vftable'
PUBLIC	??_GCMcpxVoiceClient@DirectSound@@UAEPAXI@Z	; DirectSound::CMcpxVoiceClient::`scalar deleting destructor'
EXTRN	__purecall:NEAR
EXTRN	??_ECMcpxVoiceClient@DirectSound@@UAEPAXI@Z:NEAR ; DirectSound::CMcpxVoiceClient::`vector deleting destructor'
;	COMDAT ??_7CMcpxVoiceClient@DirectSound@@6B@
; File c:\xbox\private\windows\directx\dsound\dsound\mcpvoice.cpp
CONST	SEGMENT
??_7CMcpxVoiceClient@DirectSound@@6B@ DD FLAT:??_ECMcpxVoiceClient@DirectSound@@UAEPAXI@Z ; DirectSound::CMcpxVoiceClient::`vftable'
	DD	FLAT:?AddRef@CRefCount@DirectSound@@UAGKXZ
	DD	FLAT:?Release@CRefCount@DirectSound@@UAGKXZ
	DD	FLAT:?Initialize@CMcpxVoiceClient@DirectSound@@UAEJH@Z
	DD	FLAT:?SetFormat@CMcpxVoiceClient@DirectSound@@UAEJXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CMcpxVoiceClient@DirectSound@@QAE@PAVCMcpxAPU@1@PAVCDirectSoundVoiceSettings@1@@Z
DSOUND	SEGMENT
_this$ = -8
_i$ = -4
_pMcpxApu$ = 8
_pSettings$ = 12
??0CMcpxVoiceClient@DirectSound@@QAE@PAVCMcpxAPU@1@PAVCDirectSoundVoiceSettings@1@@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::CMcpxVoiceClient, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	6a 01		 push	 1
  0000b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0CRefCount@DirectSound@@QAE@K@Z ; DirectSound::CRefCount::CRefCount
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMcpxVoiceClient@DirectSound@@6B@
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 68	 add	 ecx, 104		; 00000068H
  00022	e8 00 00 00 00	 call	 ??0CMcpxVoiceNotifier@DirectSound@@QAE@XZ

; 43   :     DWORD                   i;
; 44   :     
; 45   :     DPF_ENTER();
; 46   :     
; 47   :     m_pMcpxApu = ADDREF(pMcpxApu);

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _pMcpxApu$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCMcpxAPU@1@PAV21@@Z ; DirectSound::__AddRef
  00030	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00033	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 48   :     m_pSettings = ADDREF(pSettings);

  00036	8b 45 0c	 mov	 eax, DWORD PTR _pSettings$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCDirectSoundVoiceSettings@1@PAV21@@Z ; DirectSound::__AddRef
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	89 41 78	 mov	 DWORD PTR [ecx+120], eax

; 49   : 
; 50   :     //
; 51   :     // Initialize defaults
; 52   :     //
; 53   : 
; 54   :     m_dw3dMode = DS3DMODE_NORMAL;

  00045	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00048	c7 42 7c 00 00
	00 00		 mov	 DWORD PTR [edx+124], 0

; 55   : 
; 56   :     InitializeListHead(&m_leActiveVoice);

  0004f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00052	83 c0 4c	 add	 eax, 76			; 0000004cH
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  0005b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00064	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 57   :     InitializeListHead(&m_lePendingInactiveVoice);

  00067	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	83 c2 54	 add	 edx, 84			; 00000054H
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	89 50 58	 mov	 DWORD PTR [eax+88], edx
  00073	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00079	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  0007c	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 58   :     InitializeListHead(&m_leSourceVoice);

  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00085	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00088	89 4a 60	 mov	 DWORD PTR [edx+96], ecx
  0008b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00094	89 50 5c	 mov	 DWORD PTR [eax+92], edx

; 59   :     InitializeListHead(&m_lstSourceVoices);

  00097	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	83 c0 44	 add	 eax, 68			; 00000044H
  0009d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	89 41 48	 mov	 DWORD PTR [ecx+72], eax
  000a3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  000ac	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 60   : 
; 61   :     m_bVoiceList = MCPX_VOICELIST_INVALID;

  000af	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000b2	c6 42 65 ff	 mov	 BYTE PTR [edx+101], 255	; 000000ffH

; 62   : 
; 63   :     for(i = 0; i < NUMELMS(m_ahVoices); i++)

  000b6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000bd	eb 09		 jmp	 SHORT $L38096
$L38097:
  000bf	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000c2	83 c0 01	 add	 eax, 1
  000c5	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L38096:
  000c8	83 7d fc 03	 cmp	 DWORD PTR _i$[ebp], 3
  000cc	73 0f		 jae	 SHORT $L38087

; 64   :     {
; 65   :         m_ahVoices[i] = MCPX_VOICE_HANDLE_INVALID;

  000ce	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000d1	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000d4	66 c7 44 4a 0c
	ff ff		 mov	 WORD PTR [edx+ecx*2+12], 65535 ; 0000ffffH

; 66   :     }

  000db	eb e2		 jmp	 SHORT $L38097
$L38087:

; 67   : 
; 68   :     DPF_LEAVE_VOID();
; 69   : }

  000dd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8
??0CMcpxVoiceClient@DirectSound@@QAE@PAVCMcpxAPU@1@PAVCDirectSoundVoiceSettings@1@@Z ENDP ; DirectSound::CMcpxVoiceClient::CMcpxVoiceClient
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??_GCMcpxVoiceClient@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCMcpxVoiceClient@DirectSound@@UAEPAXI@Z PROC NEAR	; DirectSound::CMcpxVoiceClient::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMcpxVoiceClient@DirectSound@@UAE@XZ ; DirectSound::CMcpxVoiceClient::~CMcpxVoiceClient
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L38103
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L38103:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCMcpxVoiceClient@DirectSound@@UAEPAXI@Z ENDP	; DirectSound::CMcpxVoiceClient::`scalar deleting destructor'
DSOUND	ENDS
PUBLIC	??0CMcpxNotifier@DirectSound@@QAE@XZ		; DirectSound::CMcpxNotifier::CMcpxNotifier
; Function compile flags: /Odt
;	COMDAT ??0CMcpxVoiceNotifier@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CMcpxVoiceNotifier@DirectSound@@QAE@XZ PROC NEAR	; DirectSound::CMcpxVoiceNotifier::CMcpxVoiceNotifier, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CMcpxNotifier@DirectSound@@QAE@XZ ; DirectSound::CMcpxNotifier::CMcpxNotifier
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CMcpxVoiceNotifier@DirectSound@@QAE@XZ ENDP		; DirectSound::CMcpxVoiceNotifier::CMcpxVoiceNotifier
DSOUND	ENDS
PUBLIC	?Free@CMcpxNotifier@DirectSound@@QAEXXZ		; DirectSound::CMcpxNotifier::Free
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpxcore.h
;	COMDAT ??0CMcpxNotifier@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CMcpxNotifier@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CMcpxNotifier::CMcpxNotifier, COMDAT
; _this$ = ecx

; 414  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 415  :         Free();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Free@CMcpxNotifier@DirectSound@@QAEXXZ ; DirectSound::CMcpxNotifier::Free

; 416  :     }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CMcpxNotifier@DirectSound@@QAE@XZ ENDP		; DirectSound::CMcpxNotifier::CMcpxNotifier
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?Free@CMcpxNotifier@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Free@CMcpxNotifier@DirectSound@@QAEXXZ PROC NEAR	; DirectSound::CMcpxNotifier::Free, COMDAT
; _this$ = ecx

; 430  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 431  :         m_paNotifier = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 432  :         m_dwNotifierCount = 0;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 433  :     }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?Free@CMcpxNotifier@DirectSound@@QAEXXZ ENDP		; DirectSound::CMcpxNotifier::Free
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpvoice.cpp
DSOUND	ENDS
;	COMDAT ??1CMcpxVoiceClient@DirectSound@@UAE@XZ
DSOUND	SEGMENT
_this$ = -12
$T42220 = -8
$T42219 = -4
??1CMcpxVoiceClient@DirectSound@@UAE@XZ PROC NEAR	; DirectSound::CMcpxVoiceClient::~CMcpxVoiceClient, COMDAT
; _this$ = ecx

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMcpxVoiceClient@DirectSound@@6B@

; 95   :     DPF_ENTER();
; 96   : 
; 97   :     ASSERT(!(m_dwStatus & ~MCPX_VOICESTATUS_RELEASEMASK));
; 98   : 
; 99   :     //
; 100  :     // Make sure we're not still in the active voice list
; 101  :     //
; 102  : 
; 103  :     AssertValidEntryList(&m_leActiveVoice, ASSERT_NOT_IN_LIST);
; 104  :     AssertValidEntryList(&m_lePendingInactiveVoice, ASSERT_NOT_IN_LIST);
; 105  :     
; 106  :     //
; 107  :     // Make sure we're disconnected from any submixes
; 108  :     //
; 109  : 
; 110  :     DisconnectVoice();

  00012	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?DisconnectVoice@CMcpxVoiceClient@DirectSound@@QAEJXZ ; DirectSound::CMcpxVoiceClient::DisconnectVoice

; 111  : 
; 112  :     AssertValidEntryList(&m_leSourceVoice, ASSERT_NOT_IN_LIST);
; 113  :     AssertValidEntryList(&m_lstSourceVoices, ASSERT_NOT_IN_LIST);
; 114  : 
; 115  :     //
; 116  :     // Release object references
; 117  :     //
; 118  :     
; 119  :     DELETE(m_pHrtfSource);

  0001a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 79 70 00	 cmp	 DWORD PTR [ecx+112], 0
  00021	74 1f		 je	 SHORT $L38110
  00023	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00029	89 45 fc	 mov	 DWORD PTR $T42219[ebp], eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR $T42219[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4
  00038	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	c7 42 70 00 00
	00 00		 mov	 DWORD PTR [edx+112], 0
$L38110:

; 120  :     DELETE(m_pI3dl2Source);

  00042	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00045	83 78 74 00	 cmp	 DWORD PTR [eax+116], 0
  00049	74 1f		 je	 SHORT $L38112
  0004b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00051	89 55 f8	 mov	 DWORD PTR $T42220[ebp], edx
  00054	8b 45 f8	 mov	 eax, DWORD PTR $T42220[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005d	83 c4 04	 add	 esp, 4
  00060	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	c7 41 74 00 00
	00 00		 mov	 DWORD PTR [ecx+116], 0
$L38112:

; 121  : 
; 122  :     RELEASE(m_pSettings);

  0006a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	83 7a 78 00	 cmp	 DWORD PTR [edx+120], 0
  00071	74 1c		 je	 SHORT $L38114
  00073	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00076	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00079	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  0007f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00081	50		 push	 eax
  00082	ff 51 08	 call	 DWORD PTR [ecx+8]
  00085	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00088	c7 42 78 00 00
	00 00		 mov	 DWORD PTR [edx+120], 0
$L38114:

; 123  :     RELEASE(m_pMcpxApu);

  0008f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00092	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00096	74 1c		 je	 SHORT $L38109
  00098	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0009e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a4	8b 12		 mov	 edx, DWORD PTR [edx]
  000a6	51		 push	 ecx
  000a7	ff 52 08	 call	 DWORD PTR [edx+8]
  000aa	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$L38109:

; 124  : 
; 125  :     DPF_LEAVE_VOID();
; 126  : }

  000b4	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ??1CRefCount@DirectSound@@UAE@XZ ; DirectSound::CRefCount::~CRefCount
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
??1CMcpxVoiceClient@DirectSound@@UAE@XZ ENDP		; DirectSound::CMcpxVoiceClient::~CMcpxVoiceClient
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?Initialize@CMcpxVoiceClient@DirectSound@@UAEJH@Z
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
_fStream$ = 8
?Initialize@CMcpxVoiceClient@DirectSound@@UAEJH@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::Initialize, COMDAT
; _this$ = ecx

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 153  :     HRESULT                 hr  = DS_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 154  :     
; 155  :     DPF_ENTER();
; 156  : 
; 157  :     ASSERT(!m_RegCache.CfgFMT);
; 158  :     ASSERT(!m_RegCache.CfgMISC);
; 159  :     
; 160  :     //
; 161  :     // Setup voice for buffer or stream mode
; 162  :     //
; 163  : 
; 164  :     if(fStream)

  00010	83 7d 08 00	 cmp	 DWORD PTR _fStream$[ebp], 0
  00014	74 14		 je	 SHORT $L38122

; 165  :     {
; 166  :         m_RegCache.CfgFMT |= MCPX_MAKE_REG_VALUE(NV1BA0_PIO_SET_VOICE_CFG_FMT_DATA_TYPE_STREAM, NV1BA0_PIO_SET_VOICE_CFG_FMT_DATA_TYPE);

  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0001c	81 c9 00 00 00
	01		 or	 ecx, 16777216		; 01000000H
  00022	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00025	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 167  :     }
; 168  :     else

  00028	eb 0c		 jmp	 SHORT $L38124
$L38122:

; 169  :     {
; 170  :         m_RegCache.CfgFMT |= MCPX_MAKE_REG_VALUE(NV1BA0_PIO_SET_VOICE_CFG_FMT_DATA_TYPE_BUFFER, NV1BA0_PIO_SET_VOICE_CFG_FMT_DATA_TYPE);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00033	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L38124:

; 171  :     }
; 172  : 
; 173  :     //
; 174  :     // Set MIXIN-only values
; 175  :     //
; 176  : 
; 177  :     if(m_pSettings->m_dwFlags & DSBCAPS_MIXIN)

  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0003c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0003f	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  00045	85 d2		 test	 edx, edx
  00047	74 36		 je	 SHORT $L38126

; 178  :     {
; 179  :         m_RegCache.CfgFMT |= MCPX_MAKE_REG_VALUE(DSMIXBIN_SUBMIX, NV_PAVS_VOICE_CFG_FMT_MULTIPASS_BIN__ALIAS__);

  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0004f	81 c9 00 00 1f
	00		 or	 ecx, 2031616		; 001f0000H
  00055	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00058	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 180  :         m_RegCache.CfgFMT |= MCPX_MAKE_REG_VALUE(NV1BA0_PIO_SET_VOICE_CFG_FMT_MULTIPASS_ON, NV1BA0_PIO_SET_VOICE_CFG_FMT_MULTIPASS);

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00061	81 c9 00 00 20
	00		 or	 ecx, 2097152		; 00200000H
  00067	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 181  :         m_RegCache.CfgFMT |= MCPX_MAKE_REG_VALUE(NV_PAVS_VOICE_CFG_FMT_CLEAR_MIX_TRUE, NV_PAVS_VOICE_CFG_FMT_CLEAR_MIX);

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00073	81 c9 00 00 00
	04		 or	 ecx, 67108864		; 04000000H
  00079	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
$L38126:

; 182  :     }
; 183  : 
; 184  :     //
; 185  :     // Turn interrupts on for streams.  Buffers will get them from the idle
; 186  :     // voice handler, not the hardware.
; 187  :     //
; 188  : 
; 189  :     if(fStream)

  0007f	83 7d 08 00	 cmp	 DWORD PTR _fStream$[ebp], 0
  00083	74 12		 je	 SHORT $L38130

; 190  :     {
; 191  :         m_RegCache.CfgMISC |= MCPX_MAKE_REG_VALUE(NV1BA0_PIO_SET_VOICE_CFG_MISC_NOTIFY_INTERRUPT_ENABLE, NV1BA0_PIO_SET_VOICE_CFG_MISC_NOTIFY_INTERRUPT);

  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0008b	81 c9 00 00 80
	00		 or	 ecx, 8388608		; 00800000H
  00091	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00094	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
$L38130:

; 192  :     }
; 193  : 
; 194  :     //
; 195  :     // Set up filter and SRC headroom
; 196  :     //
; 197  : 
; 198  :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)

  00097	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0009d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000a0	81 e2 00 20 08
	00		 and	 edx, 532480		; 00082000H
  000a6	85 d2		 test	 edx, edx
  000a8	74 0e		 je	 SHORT $L38132

; 199  :     {
; 200  :         m_RegCache.CfgFMT |= MCPX_MAKE_REG_VALUE(NV_PAVS_VOICE_CFG_FMT_HEADROOM_SRC0_FLT0, NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM);

  000aa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000b3	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 201  :     }
; 202  :     else

  000b6	eb 12		 jmp	 SHORT $L38134
$L38132:

; 203  :     {
; 204  :         m_RegCache.CfgFMT |= MCPX_MAKE_REG_VALUE(NV_PAVS_VOICE_CFG_FMT_HEADROOM_SRC1_FLT3, NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM);

  000b8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000be	81 c9 00 e0 00
	00		 or	 ecx, 57344		; 0000e000H
  000c4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
$L38134:

; 205  :     }
; 206  : 
; 207  :     //
; 208  :     // Set the voice format.  If we're a MIXIN voice, we just need to set the
; 209  :     // voice count to 1.
; 210  :     //
; 211  : 
; 212  :     if(m_pSettings->m_dwFlags & DSBCAPS_MIXIN)

  000ca	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  000d0	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d3	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  000d9	85 d2		 test	 edx, edx
  000db	74 09		 je	 SHORT $L38136

; 213  :     {
; 214  :         ASSERT(1 == m_pSettings->m_fmt.nChannels);
; 215  :         m_bVoiceCount = 1;

  000dd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	c6 40 64 01	 mov	 BYTE PTR [eax+100], 1

; 216  :     }
; 217  :     else

  000e4	eb 0e		 jmp	 SHORT $L38137
$L38136:

; 218  :     {
; 219  :         hr = SetFormat();

  000e6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000eb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	ff 52 10	 call	 DWORD PTR [edx+16]
  000f1	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L38137:

; 220  :     }
; 221  : 
; 222  : #ifndef MCPX_BOOT_LIB
; 223  : 
; 224  :     //
; 225  :     // Allocate 3D helper objects
; 226  :     //
; 227  : 
; 228  :     if(SUCCEEDED(hr) && (m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
; 229  :     {
; 230  :         ASSERT(m_pSettings->m_p3dParams);
; 231  :         
; 232  :         hr = HRFROMP(m_pHrtfSource = NEW(CHrtfSource(*m_pMcpxApu, *m_pSettings->m_p3dParams)));
; 233  : 
; 234  :         if(SUCCEEDED(hr))
; 235  :         {
; 236  :             hr = HRFROMP(m_pI3dl2Source = NEW(CI3dl2Source(*m_pMcpxApu, m_pSettings->m_p3dParams->I3dl2Params)));
; 237  :         }
; 238  :     }
; 239  : 
; 240  : #endif // MCPX_BOOT_LIB
; 241  : 
; 242  :     DPF_LEAVE_HRESULT(hr);
; 243  : 
; 244  :     return hr;

  000f4	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 245  : }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 04 00	 ret	 4
?Initialize@CMcpxVoiceClient@DirectSound@@UAEJH@Z ENDP	; DirectSound::CMcpxVoiceClient::Initialize
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetFormat@CMcpxVoiceClient@DirectSound@@UAEJXZ
DSOUND	SEGMENT
tv94 = -36
tv89 = -32
_this$ = -28
$T42227 = -24
___AutoIrql$ = -20
_hr$ = -12
_bVoiceCount$ = -5
_i$ = -4
?SetFormat@CMcpxVoiceClient@DirectSound@@UAEJXZ PROC NEAR ; DirectSound::CMcpxVoiceClient::SetFormat, COMDAT
; _this$ = ecx

; 271  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 272  :     HRESULT                 hr              = DS_OK;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 273  :     BYTE                    bVoiceCount;
; 274  :     DWORD                   i;
; 275  :     
; 276  :     DPF_ENTER();
; 277  :     AutoIrql();

  00010	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 278  : 
; 279  :     ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_MIXIN));
; 280  : 
; 281  :     //
; 282  :     // Update the number of hardware voices used by the object
; 283  :     // 
; 284  : 
; 285  :     bVoiceCount = ((m_pSettings->m_fmt.nChannels - 1) >> 1) + 1;

  00018	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0001e	0f b6 51 0e	 movzx	 edx, BYTE PTR [ecx+14]
  00022	83 ea 01	 sub	 edx, 1
  00025	d1 fa		 sar	 edx, 1
  00027	83 c2 01	 add	 edx, 1
  0002a	88 55 fb	 mov	 BYTE PTR _bVoiceCount$[ebp], dl

; 286  : 
; 287  :     if(bVoiceCount != m_bVoiceCount)

  0002d	0f b6 45 fb	 movzx	 eax, BYTE PTR _bVoiceCount$[ebp]
  00031	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	0f b6 51 64	 movzx	 edx, BYTE PTR [ecx+100]
  00038	3b c2		 cmp	 eax, edx
  0003a	74 20		 je	 SHORT $L38147

; 288  :     {
; 289  :         if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)

  0003c	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00043	83 e1 01	 and	 ecx, 1
  00046	85 c9		 test	 ecx, ecx
  00048	74 09		 je	 SHORT $L38148

; 290  :         {
; 291  :             DPF_ERROR("Can't change the number of hardware voices used by an allocated voice");
; 292  :             hr = DSERR_INVALIDCALL;

  0004a	c7 45 f4 32 00
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005401550 ; 88780032H

; 293  :         }
; 294  :         else

  00051	eb 09		 jmp	 SHORT $L38147
$L38148:

; 295  :         {
; 296  :             m_bVoiceCount = bVoiceCount;

  00053	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00056	8a 45 fb	 mov	 al, BYTE PTR _bVoiceCount$[ebp]
  00059	88 42 64	 mov	 BYTE PTR [edx+100], al
$L38147:

; 297  :         }
; 298  :     }
; 299  : 
; 300  :     //
; 301  :     // Create the format mask
; 302  :     //
; 303  : 
; 304  :     if(SUCCEEDED(hr))

  0005c	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00060	0f 8c 42 01 00
	00		 jl	 $L38155

; 305  :     {
; 306  :         switch(m_pSettings->m_fmt.wFormatTag)
; 307  :         {

  00066	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  0006c	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00070	89 45 e0	 mov	 DWORD PTR tv89[ebp], eax
  00073	83 7d e0 01	 cmp	 DWORD PTR tv89[ebp], 1
  00077	74 0f		 je	 SHORT $L38160
  00079	83 7d e0 69	 cmp	 DWORD PTR tv89[ebp], 105 ; 00000069H
  0007d	0f 84 f5 00 00
	00		 je	 $L38178
  00083	e9 20 01 00 00	 jmp	 $L38155
$L38160:

; 308  :             case WAVE_FORMAT_PCM:
; 309  :                 switch(m_pSettings->m_fmt.wBitsPerSample)
; 310  :                 {

  00088	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  0008e	0f b6 42 0f	 movzx	 eax, BYTE PTR [edx+15]
  00092	89 45 dc	 mov	 DWORD PTR tv94[ebp], eax
  00095	8b 4d dc	 mov	 ecx, DWORD PTR tv94[ebp]
  00098	83 e9 08	 sub	 ecx, 8
  0009b	89 4d dc	 mov	 DWORD PTR tv94[ebp], ecx
  0009e	83 7d dc 18	 cmp	 DWORD PTR tv94[ebp], 24	; 00000018H
  000a2	0f 87 ce 00 00
	00		 ja	 $L38162
  000a8	8b 55 dc	 mov	 edx, DWORD PTR tv94[ebp]
  000ab	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $L42228[edx]
  000b2	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L42229[eax*4]
$L38165:

; 311  :                     case 8:  
; 312  :                         m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_U8, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE);

  000b9	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000bc	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000bf	81 e2 ff ff ff
	cf		 and	 edx, -805306369		; cfffffffH
  000c5	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000c8	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 313  :                         m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_B8, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE);

  000cb	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000d1	81 e2 ff ff ff
	3f		 and	 edx, 1073741823		; 3fffffffH
  000d7	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000da	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 314  :                         break;

  000dd	e9 94 00 00 00	 jmp	 $L38162
$L38168:

; 315  : 
; 316  :                     case 16: 
; 317  :                         m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_S16, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE);

  000e2	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000e8	81 e2 ff ff ff
	cf		 and	 edx, -805306369		; cfffffffH
  000ee	81 ca 00 00 00
	10		 or	 edx, 268435456		; 10000000H
  000f4	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 318  :                         m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_B16, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE);

  000fa	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000fd	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00100	81 e2 ff ff ff
	3f		 and	 edx, 1073741823		; 3fffffffH
  00106	81 ca 00 00 00
	40		 or	 edx, 1073741824		; 40000000H
  0010c	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0010f	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 319  :                         break;

  00112	eb 62		 jmp	 SHORT $L38162
$L38171:

; 320  : 
; 321  :                     case 24:
; 322  :                         m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_S24, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE);

  00114	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0011a	81 e2 ff ff ff
	cf		 and	 edx, -805306369		; cfffffffH
  00120	81 ca 00 00 00
	20		 or	 edx, 536870912		; 20000000H
  00126	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 323  :                         m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_B32, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE);

  0012c	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00132	81 e2 ff ff ff
	3f		 and	 edx, 1073741823		; 3fffffffH
  00138	81 ca 00 00 00
	c0		 or	 edx, -1073741824	; c0000000H
  0013e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00141	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 324  :                         break;

  00144	eb 30		 jmp	 SHORT $L38162
$L38174:

; 325  : 
; 326  :                     case 32: 
; 327  :                         m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_S32, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE);

  00146	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00149	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0014c	81 e2 ff ff ff
	cf		 and	 edx, -805306369		; cfffffffH
  00152	81 ca 00 00 00
	30		 or	 edx, 805306368		; 30000000H
  00158	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0015b	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 328  :                         m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_B32, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE);

  0015e	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00164	81 e2 ff ff ff
	3f		 and	 edx, 1073741823		; 3fffffffH
  0016a	81 ca 00 00 00
	c0		 or	 edx, -1073741824	; c0000000H
  00170	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00173	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L38162:

; 329  :                         break;
; 330  : 
; 331  :                     default:
; 332  :                         ASSERTMSG("Unexpected sample size");
; 333  :                         break;
; 334  :                 }
; 335  : 
; 336  :                 break;

  00176	eb 30		 jmp	 SHORT $L38155
$L38178:

; 337  : 
; 338  :             case WAVE_FORMAT_XBOX_ADPCM:
; 339  :                 m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_ADPCM, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE);

  00178	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0017b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0017e	81 e2 ff ff ff
	3f		 and	 edx, 1073741823		; 3fffffffH
  00184	81 ca 00 00 00
	80		 or	 edx, -2147483648	; 80000000H
  0018a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0018d	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 340  :                 m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_ADPCM, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE);

  00190	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00193	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00196	81 e2 ff ff ff
	cf		 and	 edx, -805306369		; cfffffffH
  0019c	81 ca 00 00 00
	20		 or	 edx, 536870912		; 20000000H
  001a2	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  001a5	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L38155:

; 341  :                 break;
; 342  : 
; 343  :             default:
; 344  :                 ASSERTMSG("Unexpected format type");
; 345  :                 break;
; 346  :         }
; 347  :     }
; 348  : 
; 349  :     //
; 350  :     // Set samples per block.  This register overlaps with the multipass bin 
; 351  :     // alias for mixin buffers, so we can't set both.
; 352  :     //
; 353  : 
; 354  :     if(SUCCEEDED(hr))

  001a8	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001ac	7c 27		 jl	 SHORT $L38183

; 355  :     {
; 356  :         m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, m_pSettings->m_fmt.nChannels - 1, NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLES_PER_BLOCK);

  001ae	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001b1	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001b4	81 e2 ff ff e0
	ff		 and	 edx, -2031617		; ffe0ffffH
  001ba	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  001bd	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  001c0	0f b6 41 0e	 movzx	 eax, BYTE PTR [ecx+14]
  001c4	83 e8 01	 sub	 eax, 1
  001c7	83 e0 1f	 and	 eax, 31			; 0000001fH
  001ca	c1 e0 10	 shl	 eax, 16			; 00000010H
  001cd	0b d0		 or	 edx, eax
  001cf	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001d2	89 51 14	 mov	 DWORD PTR [ecx+20], edx
$L38183:

; 357  :     }
; 358  : 
; 359  :     //
; 360  :     // If the voice uses more than 1 channel, enable stereo.  We can do
; 361  :     // this when we're using multiple hardware voices per software voice
; 362  :     // because we're restricted to 1, 2, 4 or 6-channels per voice, so 
; 363  :     // there's only one odd-numbered voice.
; 364  :     //
; 365  : 
; 366  :     if(SUCCEEDED(hr))

  001d5	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001d9	7c 38		 jl	 SHORT $L38186

; 367  :     {
; 368  :         if(1 == m_pSettings->m_fmt.nChannels)

  001db	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  001de	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  001e1	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  001e5	83 f9 01	 cmp	 ecx, 1
  001e8	75 13		 jne	 SHORT $L38187

; 369  :         {
; 370  :             m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_STEREO_DISABLE, NV1BA0_PIO_SET_VOICE_CFG_FMT_STEREO);

  001ea	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  001ed	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001f0	25 ff ff ff f7	 and	 eax, -134217729		; f7ffffffH
  001f5	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001f8	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 371  :         }
; 372  :         else

  001fb	eb 16		 jmp	 SHORT $L38186
$L38187:

; 373  :         {
; 374  :             ASSERT(!(m_pSettings->m_fmt.nChannels % 2));
; 375  : 
; 376  :             m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_STEREO_ENABLE, NV1BA0_PIO_SET_VOICE_CFG_FMT_STEREO);

  001fd	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00200	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00203	25 ff ff ff f7	 and	 eax, -134217729		; f7ffffffH
  00208	0d 00 00 00 08	 or	 eax, 134217728		; 08000000H
  0020d	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00210	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L38186:

; 377  :         }
; 378  :     }
; 379  : 
; 380  :     //
; 381  :     // Update voice registers
; 382  :     //
; 383  :     
; 384  :     if(SUCCEEDED(hr) && (m_dwStatus & MCPX_VOICESTATUS_ALLOCATED))

  00213	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00217	7c 78		 jl	 SHORT $L38192
  00219	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0021c	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  00220	83 e0 01	 and	 eax, 1
  00223	85 c0		 test	 eax, eax
  00225	74 6a		 je	 SHORT $L38192
$L38194:

; 385  :     {
; 386  :         MCPX_CHECK_VOICE_FIFO(2 * m_bVoiceCount);

  00227	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0022c	8b 91 00 00 82
	fe		 mov	 edx, DWORD PTR [ecx-25034752]
  00232	c1 ea 02	 shr	 edx, 2
  00235	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00238	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  0023c	d1 e1		 shl	 ecx, 1
  0023e	3b d1		 cmp	 edx, ecx
  00240	73 02		 jae	 SHORT $L38195
  00242	eb e3		 jmp	 SHORT $L38194
$L38195:

; 387  : 
; 388  :         for(i = 0; i < m_bVoiceCount; i++)

  00244	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0024b	eb 09		 jmp	 SHORT $L38198
$L38199:
  0024d	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00250	83 c2 01	 add	 edx, 1
  00253	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L38198:
  00256	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00259	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  0025d	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  00260	73 2f		 jae	 SHORT $L38192

; 389  :         {
; 390  :             MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  00262	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00265	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00268	0f b7 4c 50 0c	 movzx	 ecx, WORD PTR [eax+edx*2+12]
  0026d	ba f8 02 00 00	 mov	 edx, 760		; 000002f8H
  00272	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 391  :             MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));

  00278	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0027b	50		 push	 eax
  0027c	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0027f	e8 00 00 00 00	 call	 ?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::GetVoiceCfgFMT
  00284	b9 04 03 00 00	 mov	 ecx, 772		; 00000304H
  00289	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 392  :         }

  0028f	eb bc		 jmp	 SHORT $L38199
$L38192:

; 393  :     }
; 394  : 
; 395  :     DPF_LEAVE_HRESULT(hr);
; 396  : 
; 397  :     return hr;

  00291	8b 55 f4	 mov	 edx, DWORD PTR _hr$[ebp]
  00294	89 55 e8	 mov	 DWORD PTR $T42227[ebp], edx
  00297	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0029a	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  0029f	8b 45 e8	 mov	 eax, DWORD PTR $T42227[ebp]

; 398  : }

  002a2	8b e5		 mov	 esp, ebp
  002a4	5d		 pop	 ebp
  002a5	c3		 ret	 0
$L42229:
  002a6	00 00 00 00	 DD	 $L38165
  002aa	00 00 00 00	 DD	 $L38168
  002ae	00 00 00 00	 DD	 $L38171
  002b2	00 00 00 00	 DD	 $L38174
  002b6	00 00 00 00	 DD	 $L38162
$L42228:
  002ba	00		 DB	 0
  002bb	04		 DB	 4
  002bc	04		 DB	 4
  002bd	04		 DB	 4
  002be	04		 DB	 4
  002bf	04		 DB	 4
  002c0	04		 DB	 4
  002c1	04		 DB	 4
  002c2	01		 DB	 1
  002c3	04		 DB	 4
  002c4	04		 DB	 4
  002c5	04		 DB	 4
  002c6	04		 DB	 4
  002c7	04		 DB	 4
  002c8	04		 DB	 4
  002c9	04		 DB	 4
  002ca	02		 DB	 2
  002cb	04		 DB	 4
  002cc	04		 DB	 4
  002cd	04		 DB	 4
  002ce	04		 DB	 4
  002cf	04		 DB	 4
  002d0	04		 DB	 4
  002d1	04		 DB	 4
  002d2	03		 DB	 3
?SetFormat@CMcpxVoiceClient@DirectSound@@UAEJXZ ENDP	; DirectSound::CMcpxVoiceClient::SetFormat
DSOUND	ENDS
PUBLIC	?Initialize@CMcpxVoiceNotifier@DirectSound@@QAEXG@Z ; DirectSound::CMcpxVoiceNotifier::Initialize
PUBLIC	?ConvertMixBinValues@CMcpxVoiceClient@DirectSound@@IAEXPAK0@Z ; DirectSound::CMcpxVoiceClient::ConvertMixBinValues
PUBLIC	?ConvertPitchValue@CMcpxVoiceClient@DirectSound@@IAEXPAK@Z ; DirectSound::CMcpxVoiceClient::ConvertPitchValue
; Function compile flags: /Odt
;	COMDAT ?AllocateVoiceResources@CMcpxVoiceClient@DirectSound@@IAEJXZ
DSOUND	SEGMENT
_this$ = -68
$T42233 = -64
_dwVoiceBins$ = -60
___AutoIrql$ = -56
_hr$ = -48
_Volume$ = -44
_dwPitch$ = -8
_i$ = -4
?AllocateVoiceResources@CMcpxVoiceClient@DirectSound@@IAEJXZ PROC NEAR ; DirectSound::CMcpxVoiceClient::AllocateVoiceResources, COMDAT
; _this$ = ecx

; 424  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 425  :     HRESULT                 hr              = DS_OK;

  00009	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 426  :     DWORD                   dwVoiceBins;
; 427  :     DWORD                   dwPitch;
; 428  :     MCPX_VOICE_VOLUME       Volume;
; 429  :     DWORD                   i;
; 430  :     
; 431  :     DPF_ENTER();
; 432  :     AutoIrql();

  00010	8d 4d c8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 433  : 
; 434  :     if(!(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED))

  00018	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  0001f	83 e1 01	 and	 ecx, 1
  00022	85 c9		 test	 ecx, ecx
  00024	0f 85 fc 01 00
	00		 jne	 $L38217

; 435  :     {
; 436  :         ASSERT(!(m_dwStatus & ~MCPX_VOICESTATUS_DEACTIVATEMASK));
; 437  :         
; 438  :         //
; 439  :         // Allocate voices
; 440  :         //
; 441  : 
; 442  :         hr = m_pMcpxApu->AllocateVoices(this);

  0002a	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00034	e8 00 00 00 00	 call	 ?AllocateVoices@CMcpxAPU@DirectSound@@QAEJPAVCMcpxVoiceClient@2@@Z ; DirectSound::CMcpxAPU::AllocateVoices
  00039	89 45 d0	 mov	 DWORD PTR _hr$[ebp], eax

; 443  : 
; 444  :         //
; 445  :         // Initialize the notifier wrapper
; 446  :         //
; 447  : 
; 448  :         if(SUCCEEDED(hr))

  0003c	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00040	7c 13		 jl	 SHORT $L38219

; 449  :         {
; 450  :             m_Notifier.Initialize(m_ahVoices[0]);

  00042	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  00049	52		 push	 edx
  0004a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 68	 add	 ecx, 104		; 00000068H
  00050	e8 00 00 00 00	 call	 ?Initialize@CMcpxVoiceNotifier@DirectSound@@QAEXG@Z ; DirectSound::CMcpxVoiceNotifier::Initialize
$L38219:

; 451  :         }
; 452  : 
; 453  :         //
; 454  :         // Flag the voice as having resources allocated
; 455  :         //
; 456  : 
; 457  :         if(SUCCEEDED(hr))

  00055	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00059	7c 10		 jl	 SHORT $L38221

; 458  :         {
; 459  :             or(&m_dwStatus, MCPX_VOICESTATUS_ALLOCATED);

  0005b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 12	 add	 ecx, 18			; 00000012H
  00061	ba 01 00 00 00	 mov	 edx, 1
  00066	e8 00 00 00 00	 call	 ?or@@YIXPCGG@Z		; or
$L38221:

; 460  :         }
; 461  : 
; 462  :         //
; 463  :         // Build mixbin register values
; 464  :         //
; 465  : 
; 466  :         if(SUCCEEDED(hr))

  0006b	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006f	7c 13		 jl	 SHORT $L38223

; 467  :         {
; 468  :             ConvertMixBinValues(&dwVoiceBins, &m_RegCache.CfgFMT);

  00071	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	83 c0 14	 add	 eax, 20			; 00000014H
  00077	50		 push	 eax
  00078	8d 4d c4	 lea	 ecx, DWORD PTR _dwVoiceBins$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	e8 00 00 00 00	 call	 ?ConvertMixBinValues@CMcpxVoiceClient@DirectSound@@IAEXPAK0@Z ; DirectSound::CMcpxVoiceClient::ConvertMixBinValues
$L38223:

; 469  :         }
; 470  : 
; 471  :         //
; 472  :         // Build volume register values
; 473  :         //
; 474  : 
; 475  :         if(SUCCEEDED(hr))

  00084	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00088	7c 0c		 jl	 SHORT $L38225

; 476  :         {
; 477  :             ConvertVolumeValues(&Volume);

  0008a	8d 55 d4	 lea	 edx, DWORD PTR _Volume$[ebp]
  0008d	52		 push	 edx
  0008e	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?ConvertVolumeValues@CMcpxVoiceClient@DirectSound@@IAEXPAUMCPX_VOICE_VOLUME@@@Z ; DirectSound::CMcpxVoiceClient::ConvertVolumeValues
$L38225:

; 478  :         }
; 479  : 
; 480  :         //
; 481  :         // Calculate pitch shift
; 482  :         //
; 483  : 
; 484  :         if(SUCCEEDED(hr))

  00096	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0009a	7c 0c		 jl	 SHORT $L38227

; 485  :         {
; 486  :             ConvertPitchValue(&dwPitch);

  0009c	8d 45 f8	 lea	 eax, DWORD PTR _dwPitch$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	e8 00 00 00 00	 call	 ?ConvertPitchValue@CMcpxVoiceClient@DirectSound@@IAEXPAK@Z ; DirectSound::CMcpxVoiceClient::ConvertPitchValue
$L38227:

; 487  :         }
; 488  : 
; 489  :         //
; 490  :         // Set voice registers
; 491  :         //
; 492  : 
; 493  :         if(SUCCEEDED(hr))

  000a8	83 7d d0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ac	0f 8c 74 01 00
	00		 jl	 $L38217

; 494  :         {
; 495  :             for(i = 0; i < m_bVoiceCount; i++)

  000b2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000b9	eb 09		 jmp	 SHORT $L38230
$L38231:
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000be	83 c1 01	 add	 ecx, 1
  000c1	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L38230:
  000c4	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  000cb	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  000ce	0f 83 52 01 00
	00		 jae	 $L38217
$L38234:

; 496  :             {
; 497  :                 MCPX_CHECK_VOICE_FIFO(18);

  000d4	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000d9	8b 91 00 00 82
	fe		 mov	 edx, DWORD PTR [ecx-25034752]
  000df	c1 ea 02	 shr	 edx, 2
  000e2	83 fa 12	 cmp	 edx, 18			; 00000012H
  000e5	73 02		 jae	 SHORT $L38235
  000e7	eb eb		 jmp	 SHORT $L38234
$L38235:

; 498  : 
; 499  :                 MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ec	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ef	0f b7 54 41 0c	 movzx	 edx, WORD PTR [ecx+eax*2+12]
  000f4	b8 f8 02 00 00	 mov	 eax, 760		; 000002f8H
  000f9	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 500  :                 MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));

  000ff	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00102	51		 push	 ecx
  00103	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	e8 00 00 00 00	 call	 ?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::GetVoiceCfgFMT
  0010b	ba 04 03 00 00	 mov	 edx, 772		; 00000304H
  00110	89 82 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], eax

; 501  :                 MCPX_VOICE_WRITE(SetVoiceCfgMISC, m_RegCache.CfgMISC);

  00116	b8 18 03 00 00	 mov	 eax, 792		; 00000318H
  0011b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00121	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 502  :                 MCPX_VOICE_WRITE(SetVoiceCfgENV0, m_RegCache.CfgENV0);

  00127	b8 08 03 00 00	 mov	 eax, 776		; 00000308H
  0012c	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00132	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 503  :                 MCPX_VOICE_WRITE(SetVoiceCfgENVA, m_RegCache.CfgENVA);

  00138	b8 0c 03 00 00	 mov	 eax, 780		; 0000030cH
  0013d	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00140	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00143	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 504  :                 MCPX_VOICE_WRITE(SetVoiceCfgENV1, m_RegCache.CfgENV1);

  00149	b8 10 03 00 00	 mov	 eax, 784		; 00000310H
  0014e	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00154	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 505  :                 MCPX_VOICE_WRITE(SetVoiceCfgENVF, m_RegCache.CfgENVF);

  0015a	b8 14 03 00 00	 mov	 eax, 788		; 00000314H
  0015f	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00162	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00165	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 506  :                 MCPX_VOICE_WRITE(SetVoiceCfgLFODLY, m_RegCache.CfgLFODLY);

  0016b	b8 50 03 00 00	 mov	 eax, 848		; 00000350H
  00170	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00173	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00176	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 507  :                 MCPX_VOICE_WRITE(SetVoiceLFOENV, m_RegCache.LFOENV);

  0017c	b8 6c 03 00 00	 mov	 eax, 876		; 0000036cH
  00181	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00184	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00187	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 508  :                 MCPX_VOICE_WRITE(SetVoiceLFOMOD, m_RegCache.LFOMOD);

  0018d	b8 70 03 00 00	 mov	 eax, 880		; 00000370H
  00192	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00195	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00198	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 509  :                 MCPX_VOICE_WRITE(SetVoiceTarFCA, m_RegCache.TarFCA);

  0019e	b8 74 03 00 00	 mov	 eax, 884		; 00000374H
  001a3	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a6	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001a9	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 510  :                 MCPX_VOICE_WRITE(SetVoiceTarFCB, m_RegCache.TarFCB);

  001af	b8 78 03 00 00	 mov	 eax, 888		; 00000378H
  001b4	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b7	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  001ba	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 511  :                 MCPX_VOICE_WRITE(SetVoiceCfgVBIN, dwVoiceBins);

  001c0	b8 00 03 00 00	 mov	 eax, 768		; 00000300H
  001c5	8b 4d c4	 mov	 ecx, DWORD PTR _dwVoiceBins$[ebp]
  001c8	89 88 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], ecx

; 512  :                 MCPX_VOICE_WRITE(SetVoiceTarVOLA, Volume.TarVOLA[i]);

  001ce	ba 60 03 00 00	 mov	 edx, 864		; 00000360H
  001d3	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001d6	8b 4c 85 d4	 mov	 ecx, DWORD PTR _Volume$[ebp+eax*4]
  001da	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 513  :                 MCPX_VOICE_WRITE(SetVoiceTarVOLB, Volume.TarVOLB[i]);

  001e0	ba 64 03 00 00	 mov	 edx, 868		; 00000364H
  001e5	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001e8	8b 4c 85 e0	 mov	 ecx, DWORD PTR _Volume$[ebp+eax*4+12]
  001ec	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 514  :                 MCPX_VOICE_WRITE(SetVoiceTarVOLC, Volume.TarVOLC[i]);

  001f2	ba 68 03 00 00	 mov	 edx, 872		; 00000368H
  001f7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001fa	8b 4c 85 ec	 mov	 ecx, DWORD PTR _Volume$[ebp+eax*4+24]
  001fe	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 515  :                 MCPX_VOICE_WRITE(SetVoiceTarPitch, dwPitch);

  00204	ba 7c 03 00 00	 mov	 edx, 892		; 0000037cH
  00209	8b 45 f8	 mov	 eax, DWORD PTR _dwPitch$[ebp]
  0020c	89 82 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], eax

; 516  :                 MCPX_VOICE_WRITE(SetVoiceTarHRTF, 0xFFFF);

  00212	b9 1c 03 00 00	 mov	 ecx, 796		; 0000031cH
  00217	c7 81 00 00 82
	fe ff ff 00 00	 mov	 DWORD PTR [ecx-25034752], 65535 ; 0000ffffH

; 517  :             }

  00221	e9 95 fe ff ff	 jmp	 $L38231
$L38217:

; 518  :         }
; 519  : 
; 520  : #ifndef MCPX_BOOT_LIB
; 521  : 
; 522  :         //
; 523  :         // If we're 3D, force a reload of the HRTF filter coefficients
; 524  :         //
; 525  : 
; 526  :         if(SUCCEEDED(hr) && (m_pSettings->m_dwFlags & DSBCAPS_CTRL3D))
; 527  :         {
; 528  :             ASSERT(m_pHrtfSource);
; 529  : 
; 530  :             m_pHrtfSource->GetHrtfFilterPair();
; 531  : 
; 532  :             LoadHrtfFilter();
; 533  :         }
; 534  : 
; 535  : #endif // MCPX_BOOT_LIB
; 536  : 
; 537  :     }
; 538  : 
; 539  :     DPF_LEAVE_HRESULT(hr);
; 540  : 
; 541  :     return hr;

  00226	8b 55 d0	 mov	 edx, DWORD PTR _hr$[ebp]
  00229	89 55 c0	 mov	 DWORD PTR $T42233[ebp], edx
  0022c	8d 4d c8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0022f	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00234	8b 45 c0	 mov	 eax, DWORD PTR $T42233[ebp]

; 542  : }

  00237	8b e5		 mov	 esp, ebp
  00239	5d		 pop	 ebp
  0023a	c3		 ret	 0
?AllocateVoiceResources@CMcpxVoiceClient@DirectSound@@IAEJXZ ENDP ; DirectSound::CMcpxVoiceClient::AllocateVoiceResources
DSOUND	ENDS
PUBLIC	?Initialize@CMcpxNotifier@DirectSound@@QAEXKK@Z	; DirectSound::CMcpxNotifier::Initialize
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpvoice.h
;	COMDAT ?Initialize@CMcpxVoiceNotifier@DirectSound@@QAEXG@Z
DSOUND	SEGMENT
_this$ = -4
_hVoice$ = 8
?Initialize@CMcpxVoiceNotifier@DirectSound@@QAEXG@Z PROC NEAR ; DirectSound::CMcpxVoiceNotifier::Initialize, COMDAT
; _this$ = ecx

; 116  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 117  :         CMcpxNotifier::Initialize(MCPX_NOTIFIER_BASE_OFFSET + ((DWORD)hVoice * MCPX_NOTIFIER_COUNT), MCPX_NOTIFIER_COUNT);

  00007	6a 04		 push	 4
  00009	0f b7 45 08	 movzx	 eax, WORD PTR _hVoice$[ebp]
  0000d	8d 0c 85 02 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+2]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?Initialize@CMcpxNotifier@DirectSound@@QAEXKK@Z ; DirectSound::CMcpxNotifier::Initialize

; 118  :     }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?Initialize@CMcpxVoiceNotifier@DirectSound@@QAEXG@Z ENDP ; DirectSound::CMcpxVoiceNotifier::Initialize
DSOUND	ENDS
PUBLIC	?Reset@CMcpxNotifier@DirectSound@@QAEXXZ	; DirectSound::CMcpxNotifier::Reset
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpxcore.h
;	COMDAT ?Initialize@CMcpxNotifier@DirectSound@@QAEXKK@Z
DSOUND	SEGMENT
_this$ = -4
_dwBaseNotifierIndex$ = 8
_dwNotifierCount$ = 12
?Initialize@CMcpxNotifier@DirectSound@@QAEXKK@Z PROC NEAR ; DirectSound::CMcpxNotifier::Initialize, COMDAT
; _this$ = ecx

; 419  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 420  :         ASSERT(!m_paNotifier);
; 421  :         ASSERT(!m_dwNotifierCount);
; 422  : 
; 423  :         m_paNotifier = (PMCPX_HW_NOTIFICATION)CMcpxCore::m_ctxMemory[MCPX_MEM_NOTIFIERS].VirtualAddress + dwBaseNotifierIndex;

  00007	8b 45 08	 mov	 eax, DWORD PTR _dwBaseNotifierIndex$[ebp]
  0000a	c1 e0 04	 shl	 eax, 4
  0000d	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+64
  00013	03 c8		 add	 ecx, eax
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	89 0a		 mov	 DWORD PTR [edx], ecx

; 424  :         m_dwNotifierCount = dwNotifierCount;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _dwNotifierCount$[ebp]
  00020	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 425  : 
; 426  :         Reset();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?Reset@CMcpxNotifier@DirectSound@@QAEXXZ ; DirectSound::CMcpxNotifier::Reset

; 427  :     }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?Initialize@CMcpxNotifier@DirectSound@@QAEXKK@Z ENDP	; DirectSound::CMcpxNotifier::Initialize
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?Reset@CMcpxNotifier@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -8
_dwNotifierIndex$ = -4
?Reset@CMcpxNotifier@DirectSound@@QAEXXZ PROC NEAR	; DirectSound::CMcpxNotifier::Reset, COMDAT
; _this$ = ecx

; 463  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 464  :         DWORD                   dwNotifierIndex;
; 465  :     
; 466  :         ASSERT(m_paNotifier);
; 467  :         ASSERT(m_dwNotifierCount);
; 468  : 
; 469  :         for(dwNotifierIndex = 0; dwNotifierIndex < m_dwNotifierCount; dwNotifierIndex++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwNotifierIndex$[ebp], 0
  00010	eb 09		 jmp	 SHORT $L33876
$L33877:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _dwNotifierIndex$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _dwNotifierIndex$[ebp], eax
$L33876:
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _dwNotifierIndex$[ebp]
  00021	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00024	73 12		 jae	 SHORT $L33874

; 470  :         {
; 471  :             m_paNotifier[dwNotifierIndex].Status = NV1BA0_NOTIFICATION_STATUS_IN_PROGRESS;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _dwNotifierIndex$[ebp]
  00029	c1 e0 04	 shl	 eax, 4
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00031	c6 44 02 0f 80	 mov	 BYTE PTR [edx+eax+15], 128 ; 00000080H

; 472  :         }

  00036	eb da		 jmp	 SHORT $L33877
$L33874:

; 473  :     }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?Reset@CMcpxNotifier@DirectSound@@QAEXXZ ENDP		; DirectSound::CMcpxNotifier::Reset
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpvoice.cpp
DSOUND	ENDS
;	COMDAT ?ReleaseVoiceResources@CMcpxVoiceClient@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -16
___AutoIrql$ = -12
_i$ = -4
?ReleaseVoiceResources@CMcpxVoiceClient@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxVoiceClient::ReleaseVoiceResources, COMDAT
; _this$ = ecx

; 568  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 569  :     DWORD                   i;
; 570  :     
; 571  :     DPF_ENTER();
; 572  :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 573  : 
; 574  :     ASSERT(!(m_dwStatus & ~(MCPX_VOICESTATUS_ALLOCATED | MCPX_VOICESTATUS_RELEASEMASK)));
; 575  :     
; 576  :     if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)

  00011	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00014	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00018	83 e1 01	 and	 ecx, 1
  0001b	85 c9		 test	 ecx, ecx
  0001d	0f 84 93 00 00
	00		 je	 $L38281

; 577  :     {
; 578  :         //
; 579  :         // Clear the voice structure
; 580  :         //
; 581  : 
; 582  :         for(i = 0; i < m_bVoiceCount; i++)

  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002a	eb 09		 jmp	 SHORT $L38282
$L38283:
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002f	83 c2 01	 add	 edx, 1
  00032	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L38282:
  00035	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00038	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  0003c	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  0003f	73 4b		 jae	 SHORT $L38284

; 583  :         {
; 584  :             ZeroMemory((LPVOID)MCPX_VOICE_STRUCT_BASE(m_ahVoices[i]), NV_PAVS_SIZE);

  00041	68 80 00 00 00	 push	 128			; 00000080H
  00046	6a 00		 push	 0
  00048	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	0f b7 4c 50 0c	 movzx	 ecx, WORD PTR [eax+edx*2+12]
  00053	c1 e1 07	 shl	 ecx, 7
  00056	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+48
  0005c	03 d1		 add	 edx, ecx
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 _memset
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 585  : 
; 586  :             MCPX_VOICE_STRUCT_WRITE(m_ahVoices[i], NV_PAVS_VOICE_TAR_PITCH_LINK, m_ahVoices[i]);

  00067	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0006a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	0f b7 54 41 0c	 movzx	 edx, WORD PTR [ecx+eax*2+12]
  00072	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00075	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	0f b7 44 41 0c	 movzx	 eax, WORD PTR [ecx+eax*2+12]
  0007d	c1 e0 07	 shl	 eax, 7
  00080	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+48
  00086	89 54 01 7c	 mov	 DWORD PTR [ecx+eax+124], edx

; 587  :         }

  0008a	eb a0		 jmp	 SHORT $L38283
$L38284:

; 588  :         
; 589  :         //
; 590  :         // Free the notifier wrapper
; 591  :         //
; 592  : 
; 593  :         m_Notifier.Free();

  0008c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	83 c1 68	 add	 ecx, 104		; 00000068H
  00092	e8 00 00 00 00	 call	 ?Free@CMcpxNotifier@DirectSound@@QAEXXZ ; DirectSound::CMcpxNotifier::Free

; 594  :         
; 595  :         //
; 596  :         // Free the hardware voices
; 597  :         //
; 598  : 
; 599  :         DPF_INFO("Voice %x (%x) freeing resources", this, m_ahVoices[0]);
; 600  : 
; 601  :         m_pMcpxApu->FreeVoices(this);

  00097	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0009a	52		 push	 edx
  0009b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a1	e8 00 00 00 00	 call	 ?FreeVoices@CMcpxAPU@DirectSound@@QAEXPAVCMcpxVoiceClient@2@@Z ; DirectSound::CMcpxAPU::FreeVoices

; 602  : 
; 603  :         //
; 604  :         // Reset the status
; 605  :         //
; 606  : 
; 607  :         and(&m_dwStatus, MCPX_VOICESTATUS_RELEASEMASK);

  000a6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	83 c1 12	 add	 ecx, 18			; 00000012H
  000ac	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000b1	e8 00 00 00 00	 call	 ?and@@YIXPCGG@Z		; and
$L38281:

; 608  :     }
; 609  : 
; 610  :     DPF_LEAVE_VOID();
; 611  : }

  000b6	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000b9	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
?ReleaseVoiceResources@CMcpxVoiceClient@DirectSound@@IAEXXZ ENDP ; DirectSound::CMcpxVoiceClient::ReleaseVoiceResources
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetMixBins@CMcpxVoiceClient@DirectSound@@QAEJXZ
DSOUND	SEGMENT
_this$ = -60
$T42249 = -56
_dwVoiceBins$ = -52
___AutoIrql$ = -48
_Volume$ = -40
_i$ = -4
?SetMixBins@CMcpxVoiceClient@DirectSound@@QAEJXZ PROC NEAR ; DirectSound::CMcpxVoiceClient::SetMixBins, COMDAT
; _this$ = ecx

; 637  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 638  :     DWORD                   dwVoiceBins;
; 639  :     MCPX_VOICE_VOLUME       Volume;
; 640  :     DWORD                   i;
; 641  :     
; 642  :     DPF_ENTER();
; 643  :     AutoIrql();

  00009	8d 4d d0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 644  : 
; 645  :     if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)

  00011	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  00014	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00018	83 e1 01	 and	 ecx, 1
  0001b	85 c9		 test	 ecx, ecx
  0001d	0f 84 f3 00 00
	00		 je	 $L38300

; 646  :     {
; 647  :         ConvertMixBinValues(&dwVoiceBins, &m_RegCache.CfgFMT);

  00023	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  00026	83 c2 14	 add	 edx, 20			; 00000014H
  00029	52		 push	 edx
  0002a	8d 45 cc	 lea	 eax, DWORD PTR _dwVoiceBins$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?ConvertMixBinValues@CMcpxVoiceClient@DirectSound@@IAEXPAK0@Z ; DirectSound::CMcpxVoiceClient::ConvertMixBinValues

; 648  :         ConvertVolumeValues(&Volume);

  00036	8d 4d d8	 lea	 ecx, DWORD PTR _Volume$[ebp]
  00039	51		 push	 ecx
  0003a	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?ConvertVolumeValues@CMcpxVoiceClient@DirectSound@@IAEXPAUMCPX_VOICE_VOLUME@@@Z ; DirectSound::CMcpxVoiceClient::ConvertVolumeValues
$L38302:

; 649  : 
; 650  :         MCPX_CHECK_VOICE_FIFO(8 * m_bVoiceCount);

  00042	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00047	8b 82 00 00 82
	fe		 mov	 eax, DWORD PTR [edx-25034752]
  0004d	c1 e8 02	 shr	 eax, 2
  00050	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	0f b6 51 64	 movzx	 edx, BYTE PTR [ecx+100]
  00057	c1 e2 03	 shl	 edx, 3
  0005a	3b c2		 cmp	 eax, edx
  0005c	73 02		 jae	 SHORT $L38303
  0005e	eb e2		 jmp	 SHORT $L38302
$L38303:

; 651  :         
; 652  :         for(i = 0; i < m_bVoiceCount; i++)

  00060	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00067	eb 09		 jmp	 SHORT $L38306
$L38307:
  00069	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0006c	83 c0 01	 add	 eax, 1
  0006f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L38306:
  00072	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	0f b6 51 64	 movzx	 edx, BYTE PTR [ecx+100]
  00079	39 55 fc	 cmp	 DWORD PTR _i$[ebp], edx
  0007c	0f 83 94 00 00
	00		 jae	 $L38300

; 653  :         {
; 654  :             MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  00082	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00085	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	0f b7 54 41 0c	 movzx	 edx, WORD PTR [ecx+eax*2+12]
  0008d	b8 f8 02 00 00	 mov	 eax, 760		; 000002f8H
  00092	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 655  :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);

  00098	b9 fc 02 00 00	 mov	 ecx, 764		; 000002fcH
  0009d	c7 81 00 00 82
	fe 01 00 00 00	 mov	 DWORD PTR [ecx-25034752], 1

; 656  :             MCPX_VOICE_WRITE(SetVoiceCfgVBIN, dwVoiceBins);

  000a7	ba 00 03 00 00	 mov	 edx, 768		; 00000300H
  000ac	8b 45 cc	 mov	 eax, DWORD PTR _dwVoiceBins$[ebp]
  000af	89 82 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], eax

; 657  :             MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000b8	51		 push	 ecx
  000b9	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::GetVoiceCfgFMT
  000c1	ba 04 03 00 00	 mov	 edx, 772		; 00000304H
  000c6	89 82 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], eax

; 658  :             MCPX_VOICE_WRITE(SetVoiceTarVOLA, Volume.TarVOLA[i]);

  000cc	b8 60 03 00 00	 mov	 eax, 864		; 00000360H
  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000d4	8b 54 8d d8	 mov	 edx, DWORD PTR _Volume$[ebp+ecx*4]
  000d8	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 659  :             MCPX_VOICE_WRITE(SetVoiceTarVOLB, Volume.TarVOLB[i]);

  000de	b8 64 03 00 00	 mov	 eax, 868		; 00000364H
  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000e6	8b 54 8d e4	 mov	 edx, DWORD PTR _Volume$[ebp+ecx*4+12]
  000ea	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 660  :             MCPX_VOICE_WRITE(SetVoiceTarVOLC, Volume.TarVOLC[i]);

  000f0	b8 68 03 00 00	 mov	 eax, 872		; 00000368H
  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000f8	8b 54 8d f0	 mov	 edx, DWORD PTR _Volume$[ebp+ecx*4+24]
  000fc	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 661  :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);

  00102	b8 fc 02 00 00	 mov	 eax, 764		; 000002fcH
  00107	c7 80 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [eax-25034752], 0

; 662  :         }

  00111	e9 53 ff ff ff	 jmp	 $L38307
$L38300:

; 663  :     }
; 664  :     
; 665  :     DPF_LEAVE_HRESULT(DS_OK);
; 666  : 
; 667  :     return DS_OK;

  00116	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T42249[ebp], 0
  0011d	8d 4d d0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00120	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00125	8b 45 c8	 mov	 eax, DWORD PTR $T42249[ebp]

; 668  : }

  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c3		 ret	 0
?SetMixBins@CMcpxVoiceClient@DirectSound@@QAEJXZ ENDP	; DirectSound::CMcpxVoiceClient::SetMixBins
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?ConvertMixBinValues@CMcpxVoiceClient@DirectSound@@IAEXPAK0@Z
DSOUND	SEGMENT
_this$ = -48
_b$ = -44
_adwMixBins$ = -40
_i$ = -8
_a$ = -4
_pdwVoiceBins$ = 8
_pdwVoiceFormat$ = 12
?ConvertMixBinValues@CMcpxVoiceClient@DirectSound@@IAEXPAK0@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::ConvertMixBinValues, COMDAT
; _this$ = ecx

; 697  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 698  :     DWORD                   adwMixBins[8];
; 699  :     DWORD                   i, a, b;
; 700  :     
; 701  :     DPF_ENTER();
; 702  : 
; 703  :     ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
; 704  : 
; 705  :     //
; 706  :     // The MCP-X registers are stored in a wacky format.  Instead of using a
; 707  :     // 32-bit register that uses 1 bit per mixbin, they use 5-bit mixbin 
; 708  :     // indeces that are stored in 30 bits of one register and 10 of another.
; 709  :     //
; 710  :     // The hardware gets surly if a voice is assigned to less than 8 mixbins, 
; 711  :     // so we'll assign it to 8, but set the extra bins' volumes to 0.
; 712  :     //
; 713  :     // You'll notice that when we invent mixbins to assign the voice to,
; 714  :     // they're unique.  This is to prevent a theoretical stall in the VP.
; 715  :     //
; 716  : 
; 717  :     for(i = 0; i < m_pSettings->m_dwMixBinCount; i++)

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $L38336
$L38337:
  00012	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L38336:
  0001b	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  00021	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00024	3b 42 24	 cmp	 eax, DWORD PTR [edx+36]
  00027	73 17		 jae	 SHORT $L38338

; 718  :     {
; 719  :         adwMixBins[i] = m_pSettings->m_abMixBins[i];

  00029	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00032	0f b6 4c 02 28	 movzx	 ecx, BYTE PTR [edx+eax+40]
  00037	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0003a	89 4c 95 d8	 mov	 DWORD PTR _adwMixBins$[ebp+edx*4], ecx

; 720  :     }

  0003e	eb d2		 jmp	 SHORT $L38337
$L38338:

; 721  : 
; 722  :     a = DSMIXBIN_FIRST;

  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _a$[ebp], 0
$L38340:

; 723  : 
; 724  :     while(i < NUMELMS(adwMixBins))

  00047	83 7d f8 08	 cmp	 DWORD PTR _i$[ebp], 8
  0004b	73 50		 jae	 SHORT $L38341

; 725  :     {
; 726  :         ASSERT(a <= DSMIXBIN_LAST);
; 727  :         
; 728  :         for(b = 0; b < i; b++)

  0004d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _b$[ebp], 0
  00054	eb 09		 jmp	 SHORT $L38342
$L38343:
  00056	8b 45 d4	 mov	 eax, DWORD PTR _b$[ebp]
  00059	83 c0 01	 add	 eax, 1
  0005c	89 45 d4	 mov	 DWORD PTR _b$[ebp], eax
$L38342:
  0005f	8b 4d d4	 mov	 ecx, DWORD PTR _b$[ebp]
  00062	3b 4d f8	 cmp	 ecx, DWORD PTR _i$[ebp]
  00065	73 10		 jae	 SHORT $L38344

; 729  :         {
; 730  :             if(a == adwMixBins[b])

  00067	8b 55 d4	 mov	 edx, DWORD PTR _b$[ebp]
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _a$[ebp]
  0006d	3b 44 95 d8	 cmp	 eax, DWORD PTR _adwMixBins$[ebp+edx*4]
  00071	75 02		 jne	 SHORT $L38345

; 731  :             {
; 732  :                 break;

  00073	eb 02		 jmp	 SHORT $L38344
$L38345:

; 733  :             }
; 734  :         }

  00075	eb df		 jmp	 SHORT $L38343
$L38344:

; 735  : 
; 736  :         if(b >= i)

  00077	8b 4d d4	 mov	 ecx, DWORD PTR _b$[ebp]
  0007a	3b 4d f8	 cmp	 ecx, DWORD PTR _i$[ebp]
  0007d	72 13		 jb	 SHORT $L38346

; 737  :         {
; 738  :             adwMixBins[i++] = a;

  0007f	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00082	8b 45 fc	 mov	 eax, DWORD PTR _a$[ebp]
  00085	89 44 95 d8	 mov	 DWORD PTR _adwMixBins$[ebp+edx*4], eax
  00089	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0008c	83 c1 01	 add	 ecx, 1
  0008f	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$L38346:

; 739  :         }
; 740  :     
; 741  :         a++;

  00092	8b 55 fc	 mov	 edx, DWORD PTR _a$[ebp]
  00095	83 c2 01	 add	 edx, 1
  00098	89 55 fc	 mov	 DWORD PTR _a$[ebp], edx

; 742  :     }            

  0009b	eb aa		 jmp	 SHORT $L38340
$L38341:

; 743  : 
; 744  : #ifdef DEBUG
; 745  : 
; 746  :     for(i = 0; i < m_pSettings->m_dwMixBinCount; i++)
; 747  :     {
; 748  :         DPF_BLAB("Voice %x (%x) assigned to mixbin %lu", this, m_ahVoices[0], adwMixBins[i]);
; 749  :     }
; 750  : 
; 751  :     for(; i < NUMELMS(adwMixBins); i++)
; 752  :     {
; 753  :         DPF_BLAB("Voice %x (%x) assigned to mixbin %lu (unused)", this, m_ahVoices[0], adwMixBins[i]);
; 754  :     }
; 755  : 
; 756  : #endif // DEBUG
; 757  : 
; 758  :     *pdwVoiceBins = 0;

  0009d	8b 45 08	 mov	 eax, DWORD PTR _pdwVoiceBins$[ebp]
  000a0	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 759  :     
; 760  :     for(i = 0; i < 3; i++)

  000a6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ad	eb 09		 jmp	 SHORT $L38347
$L38348:
  000af	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000b2	83 c1 01	 add	 ecx, 1
  000b5	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$L38347:
  000b8	83 7d f8 03	 cmp	 DWORD PTR _i$[ebp], 3
  000bc	73 1d		 jae	 SHORT $L38349

; 761  :     {
; 762  :         *pdwVoiceBins |= adwMixBins[i] << (i * 5);

  000be	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000c1	6b c9 05	 imul	 ecx, 5
  000c4	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000c7	8b 44 95 d8	 mov	 eax, DWORD PTR _adwMixBins$[ebp+edx*4]
  000cb	d3 e0		 shl	 eax, cl
  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _pdwVoiceBins$[ebp]
  000d0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d2	0b d0		 or	 edx, eax
  000d4	8b 45 08	 mov	 eax, DWORD PTR _pdwVoiceBins$[ebp]
  000d7	89 10		 mov	 DWORD PTR [eax], edx

; 763  :     }

  000d9	eb d4		 jmp	 SHORT $L38348
$L38349:

; 764  : 
; 765  :     for(; i < 6; i++)

  000db	eb 09		 jmp	 SHORT $L38350
$L38351:
  000dd	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000e0	83 c1 01	 add	 ecx, 1
  000e3	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$L38350:
  000e6	83 7d f8 06	 cmp	 DWORD PTR _i$[ebp], 6
  000ea	73 20		 jae	 SHORT $L38352

; 766  :     {
; 767  :         *pdwVoiceBins |= adwMixBins[i] << ((i * 5) + 1);

  000ec	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000ef	6b c9 05	 imul	 ecx, 5
  000f2	83 c1 01	 add	 ecx, 1
  000f5	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000f8	8b 44 95 d8	 mov	 eax, DWORD PTR _adwMixBins$[ebp+edx*4]
  000fc	d3 e0		 shl	 eax, cl
  000fe	8b 4d 08	 mov	 ecx, DWORD PTR _pdwVoiceBins$[ebp]
  00101	8b 11		 mov	 edx, DWORD PTR [ecx]
  00103	0b d0		 or	 edx, eax
  00105	8b 45 08	 mov	 eax, DWORD PTR _pdwVoiceBins$[ebp]
  00108	89 10		 mov	 DWORD PTR [eax], edx

; 768  :     }        

  0010a	eb d1		 jmp	 SHORT $L38351
$L38352:

; 769  : 
; 770  :     *pdwVoiceFormat &= ~0x3FF;

  0010c	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwVoiceFormat$[ebp]
  0010f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00111	81 e2 00 fc ff
	ff		 and	 edx, -1024		; fffffc00H
  00117	8b 45 0c	 mov	 eax, DWORD PTR _pdwVoiceFormat$[ebp]
  0011a	89 10		 mov	 DWORD PTR [eax], edx

; 771  : 
; 772  :     for(; i < 8; i++)

  0011c	eb 09		 jmp	 SHORT $L38353
$L38354:
  0011e	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00121	83 c1 01	 add	 ecx, 1
  00124	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$L38353:
  00127	83 7d f8 08	 cmp	 DWORD PTR _i$[ebp], 8
  0012b	73 20		 jae	 SHORT $L38331

; 773  :     {
; 774  :         *pdwVoiceFormat |= adwMixBins[i] << ((i - 6) * 5);

  0012d	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00130	83 e9 06	 sub	 ecx, 6
  00133	6b c9 05	 imul	 ecx, 5
  00136	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00139	8b 44 95 d8	 mov	 eax, DWORD PTR _adwMixBins$[ebp+edx*4]
  0013d	d3 e0		 shl	 eax, cl
  0013f	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwVoiceFormat$[ebp]
  00142	8b 11		 mov	 edx, DWORD PTR [ecx]
  00144	0b d0		 or	 edx, eax
  00146	8b 45 0c	 mov	 eax, DWORD PTR _pdwVoiceFormat$[ebp]
  00149	89 10		 mov	 DWORD PTR [eax], edx

; 775  :     }

  0014b	eb d1		 jmp	 SHORT $L38354
$L38331:

; 776  : 
; 777  :     DPF_LEAVE_VOID();
; 778  : }

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 08 00	 ret	 8
?ConvertMixBinValues@CMcpxVoiceClient@DirectSound@@IAEXPAK0@Z ENDP ; DirectSound::CMcpxVoiceClient::ConvertMixBinValues
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetVolume@CMcpxVoiceClient@DirectSound@@QAEJXZ
DSOUND	SEGMENT
_this$ = -56
$T42256 = -52
___AutoIrql$ = -48
_Volume$ = -40
_i$ = -4
?SetVolume@CMcpxVoiceClient@DirectSound@@QAEJXZ PROC NEAR ; DirectSound::CMcpxVoiceClient::SetVolume, COMDAT
; _this$ = ecx

; 804  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 805  :     MCPX_VOICE_VOLUME       Volume;
; 806  :     DWORD                   i;
; 807  :     
; 808  :     DPF_ENTER();
; 809  :     AutoIrql();

  00009	8d 4d d0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 810  : 
; 811  :     if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)

  00011	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00014	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00018	83 e1 01	 and	 ecx, 1
  0001b	85 c9		 test	 ecx, ecx
  0001d	0f 84 b7 00 00
	00		 je	 $L38363

; 812  :     {
; 813  :         ConvertVolumeValues(&Volume);

  00023	8d 55 d8	 lea	 edx, DWORD PTR _Volume$[ebp]
  00026	52		 push	 edx
  00027	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?ConvertVolumeValues@CMcpxVoiceClient@DirectSound@@IAEXPAUMCPX_VOICE_VOLUME@@@Z ; DirectSound::CMcpxVoiceClient::ConvertVolumeValues
$L38365:

; 814  : 
; 815  :         MCPX_CHECK_VOICE_FIFO(6 * m_bVoiceCount);

  0002f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00034	8b 88 00 00 82
	fe		 mov	 ecx, DWORD PTR [eax-25034752]
  0003a	c1 e9 02	 shr	 ecx, 2
  0003d	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00040	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  00044	6b c0 06	 imul	 eax, 6
  00047	3b c8		 cmp	 ecx, eax
  00049	73 02		 jae	 SHORT $L38366
  0004b	eb e2		 jmp	 SHORT $L38365
$L38366:

; 816  :         
; 817  :         for(i = 0; i < m_bVoiceCount; i++)

  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00054	eb 09		 jmp	 SHORT $L38369
$L38370:
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00059	83 c1 01	 add	 ecx, 1
  0005c	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L38369:
  0005f	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00062	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  00066	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  00069	73 6f		 jae	 SHORT $L38363

; 818  :         {
; 819  :             MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0006e	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00071	0f b7 44 4a 0c	 movzx	 eax, WORD PTR [edx+ecx*2+12]
  00076	b9 f8 02 00 00	 mov	 ecx, 760		; 000002f8H
  0007b	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 820  :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);

  00081	ba fc 02 00 00	 mov	 edx, 764		; 000002fcH
  00086	c7 82 00 00 82
	fe 01 00 00 00	 mov	 DWORD PTR [edx-25034752], 1

; 821  :             MCPX_VOICE_WRITE(SetVoiceTarVOLA, Volume.TarVOLA[i]);

  00090	b8 60 03 00 00	 mov	 eax, 864		; 00000360H
  00095	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00098	8b 54 8d d8	 mov	 edx, DWORD PTR _Volume$[ebp+ecx*4]
  0009c	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 822  :             MCPX_VOICE_WRITE(SetVoiceTarVOLB, Volume.TarVOLB[i]);

  000a2	b8 64 03 00 00	 mov	 eax, 868		; 00000364H
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000aa	8b 54 8d e4	 mov	 edx, DWORD PTR _Volume$[ebp+ecx*4+12]
  000ae	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 823  :             MCPX_VOICE_WRITE(SetVoiceTarVOLC, Volume.TarVOLC[i]);

  000b4	b8 68 03 00 00	 mov	 eax, 872		; 00000368H
  000b9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000bc	8b 54 8d f0	 mov	 edx, DWORD PTR _Volume$[ebp+ecx*4+24]
  000c0	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 824  :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);

  000c6	b8 fc 02 00 00	 mov	 eax, 764		; 000002fcH
  000cb	c7 80 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [eax-25034752], 0

; 825  :         }

  000d5	e9 7c ff ff ff	 jmp	 $L38370
$L38363:

; 826  :     }
; 827  :     
; 828  :     DPF_LEAVE_HRESULT(DS_OK);
; 829  : 
; 830  :     return DS_OK;

  000da	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T42256[ebp], 0
  000e1	8d 4d d0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000e4	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000e9	8b 45 cc	 mov	 eax, DWORD PTR $T42256[ebp]

; 831  : }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
?SetVolume@CMcpxVoiceClient@DirectSound@@QAEJXZ ENDP	; DirectSound::CMcpxVoiceClient::SetVolume
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?ConvertVolumeValues@CMcpxVoiceClient@DirectSound@@IAEXPAUMCPX_VOICE_VOLUME@@@Z
DSOUND	SEGMENT
_this$ = -48
_dwPerVoiceBins$ = -44
_adwVolumes$ = -40
_dwVoiceIndex$ = -8
_i$ = -4
_pVolumeRegisters$ = 8
?ConvertVolumeValues@CMcpxVoiceClient@DirectSound@@IAEXPAUMCPX_VOICE_VOLUME@@@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::ConvertVolumeValues, COMDAT
; _this$ = ecx

; 857  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	56		 push	 esi
  00007	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 858  :     static const DWORD      dwMcpxMaxAttenuation                    = MCPX_GET_REG_VALUE(~0UL, NV_PAVS_VOICE_TAR_VOLA_VOLUME0);
; 859  :     DWORD                   adwVolumes[MCPX_HW_MAX_VOICE_MIXBINS];
; 860  : 
; 861  : #ifndef MCPX_BOOT_LIB
; 862  : 
; 863  :     BOOL                    f3dVolume                               = FALSE;
; 864  :     LONG                    l3dVolume;
; 865  :     LONG                    l3dFrontDirect;
; 866  :     LONG                    l3dRearDirect;
; 867  :     LONG                    l3dReverbSend;
; 868  : 
; 869  : #endif // MCPX_BOOT_LIB
; 870  : 
; 871  :     DWORD                   dwPerVoiceBins;
; 872  :     DWORD                   dwVoiceIndex;
; 873  :     DWORD                   i;
; 874  :     
; 875  :     DPF_ENTER();
; 876  : 
; 877  :     ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
; 878  : 
; 879  : #ifndef MCPX_BOOT_LIB
; 880  : 
; 881  :     //
; 882  :     // Calculate generic 3D volume, front direct-path, rear direct-path 
; 883  :     // and reverb send levels separately.  3D volume will be applied
; 884  :     // to all mixbins, front to the fronts, rear to the rears and reverb
; 885  :     // to the I3DL2 mixbin.
; 886  :     //
; 887  : 
; 888  :     if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
; 889  :     {
; 890  :         ASSERT(m_pSettings->m_p3dParams);
; 891  : 
; 892  :         if(DS3DMODE_DISABLE != m_pSettings->m_p3dParams->HrtfParams.dwMode)
; 893  :         {
; 894  :             ASSERT(m_pHrtfSource);
; 895  :         
; 896  :             ASSERT(m_pHrtfSource->m_3dVoiceData.lDistanceVolume <= 0);
; 897  :             ASSERT(m_pHrtfSource->m_3dVoiceData.lConeVolume <= 0);
; 898  :             ASSERT(m_pHrtfSource->m_3dVoiceData.lFrontVolume <= 0);
; 899  :             ASSERT(m_pHrtfSource->m_3dVoiceData.lRearVolume <= 0);
; 900  : 
; 901  :             l3dVolume = m_pHrtfSource->m_3dVoiceData.lDistanceVolume + m_pHrtfSource->m_3dVoiceData.lConeVolume;
; 902  :         
; 903  :             l3dFrontDirect = l3dVolume + m_pHrtfSource->m_3dVoiceData.lFrontVolume + m_pI3dl2Source->m_I3dl2Data.lDirect;
; 904  :             l3dFrontDirect = min(l3dFrontDirect, 0);
; 905  : 
; 906  :             l3dRearDirect = l3dVolume + m_pHrtfSource->m_3dVoiceData.lRearVolume + m_pI3dl2Source->m_I3dl2Data.lDirect;
; 907  :             l3dRearDirect = min(l3dRearDirect, 0);
; 908  : 
; 909  :             l3dReverbSend = l3dVolume + m_pI3dl2Source->m_I3dl2Data.lSource;
; 910  :             l3dReverbSend = min(l3dReverbSend, 0);
; 911  : 
; 912  :             f3dVolume = TRUE;
; 913  :         }
; 914  :     }
; 915  : 
; 916  : #endif // MCPX_BOOT_LIB
; 917  : 
; 918  :     //
; 919  :     // If we're multichannel, determine which mixbins need to be muted.
; 920  :     // We need to be sure that since all of our hardware voices point to
; 921  :     // the same mixbins, we mute some on a per-voice basis so we don't
; 922  :     // end up with multiple voices feeding the same mixbin.
; 923  :     //
; 924  : 
; 925  :     ASSERT(!(m_pSettings->m_dwMixBinCount % m_bVoiceCount));
; 926  :     dwPerVoiceBins = m_pSettings->m_dwMixBinCount / m_bVoiceCount;

  0000a	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00010	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  00013	0f b6 72 64	 movzx	 esi, BYTE PTR [edx+100]
  00017	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0001a	33 d2		 xor	 edx, edx
  0001c	f7 f6		 div	 esi
  0001e	89 45 d4	 mov	 DWORD PTR _dwPerVoiceBins$[ebp], eax

; 927  : 
; 928  :     //
; 929  :     // Enter the per-voice loop
; 930  :     //
; 931  : 
; 932  :     for(dwVoiceIndex = 0; dwVoiceIndex < m_bVoiceCount; dwVoiceIndex++)

  00021	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwVoiceIndex$[ebp], 0
  00028	eb 09		 jmp	 SHORT $L38396
$L38397:
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _dwVoiceIndex$[ebp]
  0002d	83 c0 01	 add	 eax, 1
  00030	89 45 f8	 mov	 DWORD PTR _dwVoiceIndex$[ebp], eax
$L38396:
  00033	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	0f b6 51 64	 movzx	 edx, BYTE PTR [ecx+100]
  0003a	39 55 f8	 cmp	 DWORD PTR _dwVoiceIndex$[ebp], edx
  0003d	0f 83 3d 02 00
	00		 jae	 $L38389

; 933  :     {
; 934  :         //
; 935  :         // For each mixbin we're assigned to, set a volume in the array
; 936  :         //
; 937  : 
; 938  :         for(i = 0; i < NUMELMS(adwVolumes); i++)

  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004a	eb 09		 jmp	 SHORT $L38399
$L38400:
  0004c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004f	83 c0 01	 add	 eax, 1
  00052	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L38399:
  00055	83 7d fc 08	 cmp	 DWORD PTR _i$[ebp], 8
  00059	0f 83 be 00 00
	00		 jae	 $L38401

; 939  :         {
; 940  :             //
; 941  :             // Are we using this mixbin?
; 942  :             //
; 943  : 
; 944  :             if((i < (dwPerVoiceBins * dwVoiceIndex)) || (i >= (dwPerVoiceBins * (dwVoiceIndex + 1))))

  0005f	8b 4d d4	 mov	 ecx, DWORD PTR _dwPerVoiceBins$[ebp]
  00062	0f af 4d f8	 imul	 ecx, DWORD PTR _dwVoiceIndex$[ebp]
  00066	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  00069	72 11		 jb	 SHORT $L38403
  0006b	8b 55 f8	 mov	 edx, DWORD PTR _dwVoiceIndex$[ebp]
  0006e	83 c2 01	 add	 edx, 1
  00071	8b 45 d4	 mov	 eax, DWORD PTR _dwPerVoiceBins$[ebp]
  00074	0f af c2	 imul	 eax, edx
  00077	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  0007a	72 0d		 jb	 SHORT $L38402
$L38403:

; 945  :             {
; 946  :                 adwVolumes[i] = dwMcpxMaxAttenuation;

  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0007f	c7 44 8d d8 ff
	0f 00 00	 mov	 DWORD PTR _adwVolumes$[ebp+ecx*4], 4095 ; 00000fffH

; 947  :                 continue;

  00087	eb c3		 jmp	 SHORT $L38400
$L38402:

; 948  :             }
; 949  : 
; 950  :             //
; 951  :             // Start with global voice volume
; 952  :             //
; 953  : 
; 954  :             ASSERT(m_pSettings->m_lVolume <= 0);
; 955  :             adwVolumes[i] = -m_pSettings->m_lVolume;

  00089	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  0008c	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  0008f	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00092	f7 d9		 neg	 ecx
  00094	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00097	89 4c 95 d8	 mov	 DWORD PTR _adwVolumes$[ebp+edx*4], ecx

; 956  : 
; 957  :             //
; 958  :             // Combine mixbin-specific volume with global voice volume
; 959  :             //
; 960  : 
; 961  :             ASSERT(m_pSettings->m_alMixBinVolumes[m_pSettings->m_abMixBins[i]] <= 0);
; 962  :             adwVolumes[i] -= m_pSettings->m_alMixBinVolumes[m_pSettings->m_abMixBins[i]];

  0009b	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  000a1	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  000a4	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  000a7	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000aa	0f b6 44 10 28	 movzx	 eax, BYTE PTR [eax+edx+40]
  000af	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000b2	8b 54 95 d8	 mov	 edx, DWORD PTR _adwVolumes$[ebp+edx*4]
  000b6	2b 54 81 30	 sub	 edx, DWORD PTR [ecx+eax*4+48]
  000ba	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000bd	89 54 85 d8	 mov	 DWORD PTR _adwVolumes$[ebp+eax*4], edx

; 963  : 
; 964  : #ifndef MCPX_BOOT_LIB
; 965  : 
; 966  :             //
; 967  :             // Add 3D attenuation
; 968  :             //
; 969  : 
; 970  :             if(f3dVolume)
; 971  :             {
; 972  :                 switch(m_pSettings->m_abMixBins[i])
; 973  :                 {
; 974  :                     case DSMIXBIN_3D_FRONT_LEFT:
; 975  :                     case DSMIXBIN_3D_FRONT_RIGHT:
; 976  :                         ASSERT(l3dFrontDirect <= 0);
; 977  :                         adwVolumes[i] -= l3dFrontDirect;
; 978  :                         break;
; 979  : 
; 980  :                     case DSMIXBIN_3D_BACK_LEFT:
; 981  :                     case DSMIXBIN_3D_BACK_RIGHT:
; 982  :                         ASSERT(l3dRearDirect <= 0);
; 983  :                         adwVolumes[i] -= l3dRearDirect;
; 984  :                         break;
; 985  : 
; 986  :                     case DSMIXBIN_I3DL2:
; 987  :                         ASSERT(l3dReverbSend <= 0);
; 988  :                         adwVolumes[i] -= l3dReverbSend;
; 989  :                         break;
; 990  : 
; 991  :                     default:
; 992  :                         ASSERT(l3dVolume <= 0);
; 993  :                         adwVolumes[i] -= l3dVolume;
; 994  :                         break;
; 995  :                 }
; 996  : 
; 997  :                 if(m_pHrtfSource->m_3dVoiceData.dwMixBinValidMask & (1UL << m_pSettings->m_abMixBins[i]))
; 998  :                 {
; 999  :                     ASSERT(m_pHrtfSource->m_3dVoiceData.alMixBinVolumes[m_pSettings->m_abMixBins[i]] <= 0);
; 1000 :                     adwVolumes[i] -= m_pHrtfSource->m_3dVoiceData.alMixBinVolumes[m_pSettings->m_abMixBins[i]];
; 1001 :                 }
; 1002 :             }
; 1003 : 
; 1004 : #endif // MCPX_BOOT_LIB
; 1005 : 
; 1006 :             //
; 1007 :             // Convert to register format
; 1008 :             //
; 1009 : 
; 1010 :             DPF_BLAB("Voice %x (%x) mixbin %lu (%lu) volume -%ld", this, m_ahVoices[dwVoiceIndex], i, m_pSettings->m_abMixBins[i], adwVolumes[i]);
; 1011 :             
; 1012 :             adwVolumes[i] <<= 6;

  000c1	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000c4	8b 54 8d d8	 mov	 edx, DWORD PTR _adwVolumes$[ebp+ecx*4]
  000c8	c1 e2 06	 shl	 edx, 6
  000cb	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ce	89 54 85 d8	 mov	 DWORD PTR _adwVolumes$[ebp+eax*4], edx

; 1013 :             adwVolumes[i] /= 100;

  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000d5	8b 44 8d d8	 mov	 eax, DWORD PTR _adwVolumes$[ebp+ecx*4]
  000d9	33 d2		 xor	 edx, edx
  000db	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000e0	f7 f1		 div	 ecx
  000e2	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000e5	89 44 95 d8	 mov	 DWORD PTR _adwVolumes$[ebp+edx*4], eax

; 1014 : 
; 1015 :             CHECKRANGE(adwVolumes[i], 0, dwMcpxMaxAttenuation);

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ec	83 7c 85 d8 00	 cmp	 DWORD PTR _adwVolumes$[ebp+eax*4], 0
  000f1	73 0d		 jae	 SHORT $L38404
  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000f6	c7 44 8d d8 00
	00 00 00	 mov	 DWORD PTR _adwVolumes$[ebp+ecx*4], 0
  000fe	eb 18		 jmp	 SHORT $L38405
$L38404:
  00100	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00103	81 7c 95 d8 ff
	0f 00 00	 cmp	 DWORD PTR _adwVolumes$[ebp+edx*4], 4095 ; 00000fffH
  0010b	76 0b		 jbe	 SHORT $L38405
  0010d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00110	c7 44 85 d8 ff
	0f 00 00	 mov	 DWORD PTR _adwVolumes$[ebp+eax*4], 4095 ; 00000fffH
$L38405:

; 1016 :         }

  00118	e9 2f ff ff ff	 jmp	 $L38400
$L38401:

; 1017 : 
; 1018 :         //
; 1019 :         // Set register values
; 1020 :         //
; 1021 : 
; 1022 :         pVolumeRegisters->TarVOLA[dwVoiceIndex] = MCPX_MAKE_REG_VALUE(adwVolumes[0], NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME0);

  0011d	8b 4d d8	 mov	 ecx, DWORD PTR _adwVolumes$[ebp]
  00120	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  00126	c1 e1 04	 shl	 ecx, 4
  00129	8b 55 f8	 mov	 edx, DWORD PTR _dwVoiceIndex$[ebp]
  0012c	8b 45 08	 mov	 eax, DWORD PTR _pVolumeRegisters$[ebp]
  0012f	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 1023 :         pVolumeRegisters->TarVOLA[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[1], NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME1);

  00132	8b 4d dc	 mov	 ecx, DWORD PTR _adwVolumes$[ebp+4]
  00135	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  0013b	c1 e1 14	 shl	 ecx, 20			; 00000014H
  0013e	8b 55 f8	 mov	 edx, DWORD PTR _dwVoiceIndex$[ebp]
  00141	8b 45 08	 mov	 eax, DWORD PTR _pVolumeRegisters$[ebp]
  00144	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00147	0b d1		 or	 edx, ecx
  00149	8b 45 f8	 mov	 eax, DWORD PTR _dwVoiceIndex$[ebp]
  0014c	8b 4d 08	 mov	 ecx, DWORD PTR _pVolumeRegisters$[ebp]
  0014f	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 1024 :         pVolumeRegisters->TarVOLA[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[6], NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME6_B3_0);

  00152	8b 55 f0	 mov	 edx, DWORD PTR _adwVolumes$[ebp+24]
  00155	83 e2 0f	 and	 edx, 15			; 0000000fH
  00158	8b 45 f8	 mov	 eax, DWORD PTR _dwVoiceIndex$[ebp]
  0015b	8b 4d 08	 mov	 ecx, DWORD PTR _pVolumeRegisters$[ebp]
  0015e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00161	0b c2		 or	 eax, edx
  00163	8b 4d f8	 mov	 ecx, DWORD PTR _dwVoiceIndex$[ebp]
  00166	8b 55 08	 mov	 edx, DWORD PTR _pVolumeRegisters$[ebp]
  00169	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 1025 :         pVolumeRegisters->TarVOLA[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[7], NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME7_B3_0);

  0016c	8b 45 f4	 mov	 eax, DWORD PTR _adwVolumes$[ebp+28]
  0016f	83 e0 0f	 and	 eax, 15			; 0000000fH
  00172	c1 e0 10	 shl	 eax, 16			; 00000010H
  00175	8b 4d f8	 mov	 ecx, DWORD PTR _dwVoiceIndex$[ebp]
  00178	8b 55 08	 mov	 edx, DWORD PTR _pVolumeRegisters$[ebp]
  0017b	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0017e	0b c8		 or	 ecx, eax
  00180	8b 55 f8	 mov	 edx, DWORD PTR _dwVoiceIndex$[ebp]
  00183	8b 45 08	 mov	 eax, DWORD PTR _pVolumeRegisters$[ebp]
  00186	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 1026 : 
; 1027 :         pVolumeRegisters->TarVOLB[dwVoiceIndex] = MCPX_MAKE_REG_VALUE(adwVolumes[2], NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME2);

  00189	8b 4d e0	 mov	 ecx, DWORD PTR _adwVolumes$[ebp+8]
  0018c	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  00192	c1 e1 04	 shl	 ecx, 4
  00195	8b 55 f8	 mov	 edx, DWORD PTR _dwVoiceIndex$[ebp]
  00198	8b 45 08	 mov	 eax, DWORD PTR _pVolumeRegisters$[ebp]
  0019b	89 4c 90 0c	 mov	 DWORD PTR [eax+edx*4+12], ecx

; 1028 :         pVolumeRegisters->TarVOLB[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[3], NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME3);

  0019f	8b 4d e4	 mov	 ecx, DWORD PTR _adwVolumes$[ebp+12]
  001a2	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  001a8	c1 e1 14	 shl	 ecx, 20			; 00000014H
  001ab	8b 55 f8	 mov	 edx, DWORD PTR _dwVoiceIndex$[ebp]
  001ae	8b 45 08	 mov	 eax, DWORD PTR _pVolumeRegisters$[ebp]
  001b1	8b 54 90 0c	 mov	 edx, DWORD PTR [eax+edx*4+12]
  001b5	0b d1		 or	 edx, ecx
  001b7	8b 45 f8	 mov	 eax, DWORD PTR _dwVoiceIndex$[ebp]
  001ba	8b 4d 08	 mov	 ecx, DWORD PTR _pVolumeRegisters$[ebp]
  001bd	89 54 81 0c	 mov	 DWORD PTR [ecx+eax*4+12], edx

; 1029 :         pVolumeRegisters->TarVOLB[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[6] >> 4, NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME6_B7_4);

  001c1	8b 55 f0	 mov	 edx, DWORD PTR _adwVolumes$[ebp+24]
  001c4	c1 ea 04	 shr	 edx, 4
  001c7	83 e2 0f	 and	 edx, 15			; 0000000fH
  001ca	8b 45 f8	 mov	 eax, DWORD PTR _dwVoiceIndex$[ebp]
  001cd	8b 4d 08	 mov	 ecx, DWORD PTR _pVolumeRegisters$[ebp]
  001d0	8b 44 81 0c	 mov	 eax, DWORD PTR [ecx+eax*4+12]
  001d4	0b c2		 or	 eax, edx
  001d6	8b 4d f8	 mov	 ecx, DWORD PTR _dwVoiceIndex$[ebp]
  001d9	8b 55 08	 mov	 edx, DWORD PTR _pVolumeRegisters$[ebp]
  001dc	89 44 8a 0c	 mov	 DWORD PTR [edx+ecx*4+12], eax

; 1030 :         pVolumeRegisters->TarVOLB[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[7] >> 4, NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME7_B7_4);

  001e0	8b 45 f4	 mov	 eax, DWORD PTR _adwVolumes$[ebp+28]
  001e3	c1 e8 04	 shr	 eax, 4
  001e6	83 e0 0f	 and	 eax, 15			; 0000000fH
  001e9	c1 e0 10	 shl	 eax, 16			; 00000010H
  001ec	8b 4d f8	 mov	 ecx, DWORD PTR _dwVoiceIndex$[ebp]
  001ef	8b 55 08	 mov	 edx, DWORD PTR _pVolumeRegisters$[ebp]
  001f2	8b 4c 8a 0c	 mov	 ecx, DWORD PTR [edx+ecx*4+12]
  001f6	0b c8		 or	 ecx, eax
  001f8	8b 55 f8	 mov	 edx, DWORD PTR _dwVoiceIndex$[ebp]
  001fb	8b 45 08	 mov	 eax, DWORD PTR _pVolumeRegisters$[ebp]
  001fe	89 4c 90 0c	 mov	 DWORD PTR [eax+edx*4+12], ecx

; 1031 : 
; 1032 :         pVolumeRegisters->TarVOLC[dwVoiceIndex] = MCPX_MAKE_REG_VALUE(adwVolumes[4], NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME4);

  00202	8b 4d e8	 mov	 ecx, DWORD PTR _adwVolumes$[ebp+16]
  00205	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  0020b	c1 e1 04	 shl	 ecx, 4
  0020e	8b 55 f8	 mov	 edx, DWORD PTR _dwVoiceIndex$[ebp]
  00211	8b 45 08	 mov	 eax, DWORD PTR _pVolumeRegisters$[ebp]
  00214	89 4c 90 18	 mov	 DWORD PTR [eax+edx*4+24], ecx

; 1033 :         pVolumeRegisters->TarVOLC[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[5], NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME5);

  00218	8b 4d ec	 mov	 ecx, DWORD PTR _adwVolumes$[ebp+20]
  0021b	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  00221	c1 e1 14	 shl	 ecx, 20			; 00000014H
  00224	8b 55 f8	 mov	 edx, DWORD PTR _dwVoiceIndex$[ebp]
  00227	8b 45 08	 mov	 eax, DWORD PTR _pVolumeRegisters$[ebp]
  0022a	8b 54 90 18	 mov	 edx, DWORD PTR [eax+edx*4+24]
  0022e	0b d1		 or	 edx, ecx
  00230	8b 45 f8	 mov	 eax, DWORD PTR _dwVoiceIndex$[ebp]
  00233	8b 4d 08	 mov	 ecx, DWORD PTR _pVolumeRegisters$[ebp]
  00236	89 54 81 18	 mov	 DWORD PTR [ecx+eax*4+24], edx

; 1034 :         pVolumeRegisters->TarVOLC[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[6] >> 8, NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME6_B11_8);

  0023a	8b 55 f0	 mov	 edx, DWORD PTR _adwVolumes$[ebp+24]
  0023d	c1 ea 08	 shr	 edx, 8
  00240	83 e2 0f	 and	 edx, 15			; 0000000fH
  00243	8b 45 f8	 mov	 eax, DWORD PTR _dwVoiceIndex$[ebp]
  00246	8b 4d 08	 mov	 ecx, DWORD PTR _pVolumeRegisters$[ebp]
  00249	8b 44 81 18	 mov	 eax, DWORD PTR [ecx+eax*4+24]
  0024d	0b c2		 or	 eax, edx
  0024f	8b 4d f8	 mov	 ecx, DWORD PTR _dwVoiceIndex$[ebp]
  00252	8b 55 08	 mov	 edx, DWORD PTR _pVolumeRegisters$[ebp]
  00255	89 44 8a 18	 mov	 DWORD PTR [edx+ecx*4+24], eax

; 1035 :         pVolumeRegisters->TarVOLC[dwVoiceIndex] |= MCPX_MAKE_REG_VALUE(adwVolumes[7] >> 8, NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME7_B11_8);

  00259	8b 45 f4	 mov	 eax, DWORD PTR _adwVolumes$[ebp+28]
  0025c	c1 e8 08	 shr	 eax, 8
  0025f	83 e0 0f	 and	 eax, 15			; 0000000fH
  00262	c1 e0 10	 shl	 eax, 16			; 00000010H
  00265	8b 4d f8	 mov	 ecx, DWORD PTR _dwVoiceIndex$[ebp]
  00268	8b 55 08	 mov	 edx, DWORD PTR _pVolumeRegisters$[ebp]
  0026b	8b 4c 8a 18	 mov	 ecx, DWORD PTR [edx+ecx*4+24]
  0026f	0b c8		 or	 ecx, eax
  00271	8b 55 f8	 mov	 edx, DWORD PTR _dwVoiceIndex$[ebp]
  00274	8b 45 08	 mov	 eax, DWORD PTR _pVolumeRegisters$[ebp]
  00277	89 4c 90 18	 mov	 DWORD PTR [eax+edx*4+24], ecx

; 1036 :     }

  0027b	e9 aa fd ff ff	 jmp	 $L38397
$L38389:

; 1037 : 
; 1038 :     DPF_LEAVE_VOID();
; 1039 : }

  00280	5e		 pop	 esi
  00281	8b e5		 mov	 esp, ebp
  00283	5d		 pop	 ebp
  00284	c2 04 00	 ret	 4
?ConvertVolumeValues@CMcpxVoiceClient@DirectSound@@IAEXPAUMCPX_VOICE_VOLUME@@@Z ENDP ; DirectSound::CMcpxVoiceClient::ConvertVolumeValues
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetPitch@CMcpxVoiceClient@DirectSound@@QAEJXZ
DSOUND	SEGMENT
_this$ = -32
$T42263 = -28
___AutoIrql$ = -24
_pSourceVoice$ = -16
_dwPitch$ = -12
_i$ = -8
_pleSourceVoice$ = -4
?SetPitch@CMcpxVoiceClient@DirectSound@@QAEJXZ PROC NEAR ; DirectSound::CMcpxVoiceClient::SetPitch, COMDAT
; _this$ = ecx

; 1065 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 1066 :     PLIST_ENTRY             pleSourceVoice;
; 1067 :     CMcpxVoiceClient *      pSourceVoice;
; 1068 :     DWORD                   dwPitch;
; 1069 :     DWORD                   i;
; 1070 :     
; 1071 :     DPF_ENTER();
; 1072 :     AutoIrql();

  00009	8d 4d e8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1073 : 
; 1074 :     //
; 1075 :     // If we're a submix destination, we can't change our pitch.  It has to
; 1076 :     // stay locked at 0.  Instead, we'll update all the source voices' pitch
; 1077 :     // values.
; 1078 :     //
; 1079 : 
; 1080 :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)

  00011	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00017	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001a	81 e2 00 20 08
	00		 and	 edx, 532480		; 00082000H
  00020	85 d2		 test	 edx, edx
  00022	74 33		 je	 SHORT $L38428

; 1081 :     {
; 1082 :         for(pleSourceVoice = m_lstSourceVoices.Flink; pleSourceVoice != &m_lstSourceVoices; pleSourceVoice = pleSourceVoice->Flink)

  00024	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0002a	89 4d fc	 mov	 DWORD PTR _pleSourceVoice$[ebp], ecx
  0002d	eb 08		 jmp	 SHORT $L38429
$L38430:
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _pleSourceVoice$[ebp]
  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	89 45 fc	 mov	 DWORD PTR _pleSourceVoice$[ebp], eax
$L38429:
  00037	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 44	 add	 ecx, 68			; 00000044H
  0003d	39 4d fc	 cmp	 DWORD PTR _pleSourceVoice$[ebp], ecx
  00040	74 13		 je	 SHORT $L38431

; 1083 :         {
; 1084 :             AssertValidEntryList(pleSourceVoice, ASSERT_IN_LIST);
; 1085 : 
; 1086 :             pSourceVoice = CONTAINING_RECORD(pleSourceVoice, CMcpxVoiceClient, m_leSourceVoice);

  00042	8b 55 fc	 mov	 edx, DWORD PTR _pleSourceVoice$[ebp]
  00045	83 ea 5c	 sub	 edx, 92			; 0000005cH
  00048	89 55 f0	 mov	 DWORD PTR _pSourceVoice$[ebp], edx

; 1087 : 
; 1088 :             pSourceVoice->SetPitch();

  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _pSourceVoice$[ebp]
  0004e	e8 00 00 00 00	 call	 ?SetPitch@CMcpxVoiceClient@DirectSound@@QAEJXZ ; DirectSound::CMcpxVoiceClient::SetPitch

; 1089 :         }

  00053	eb da		 jmp	 SHORT $L38430
$L38431:

; 1090 :     }
; 1091 :     else if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)

  00055	eb 7b		 jmp	 SHORT $L38436
$L38428:
  00057	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  0005e	83 e1 01	 and	 ecx, 1
  00061	85 c9		 test	 ecx, ecx
  00063	74 6d		 je	 SHORT $L38436

; 1092 :     {
; 1093 :         ConvertPitchValue(&dwPitch);

  00065	8d 55 f4	 lea	 edx, DWORD PTR _dwPitch$[ebp]
  00068	52		 push	 edx
  00069	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?ConvertPitchValue@CMcpxVoiceClient@DirectSound@@IAEXPAK@Z ; DirectSound::CMcpxVoiceClient::ConvertPitchValue
$L38439:

; 1094 : 
; 1095 :         MCPX_CHECK_VOICE_FIFO(2 * m_bVoiceCount);

  00071	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00076	8b 88 00 00 82
	fe		 mov	 ecx, DWORD PTR [eax-25034752]
  0007c	c1 e9 02	 shr	 ecx, 2
  0007f	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00082	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  00086	d1 e0		 shl	 eax, 1
  00088	3b c8		 cmp	 ecx, eax
  0008a	73 02		 jae	 SHORT $L38440
  0008c	eb e3		 jmp	 SHORT $L38439
$L38440:

; 1096 :         
; 1097 :         for(i = 0; i < m_bVoiceCount; i++)

  0008e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00095	eb 09		 jmp	 SHORT $L38443
$L38444:
  00097	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0009a	83 c1 01	 add	 ecx, 1
  0009d	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$L38443:
  000a0	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  000a7	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  000aa	73 26		 jae	 SHORT $L38436

; 1098 :         {
; 1099 :             MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  000ac	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000af	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000b2	0f b7 44 4a 0c	 movzx	 eax, WORD PTR [edx+ecx*2+12]
  000b7	b9 f8 02 00 00	 mov	 ecx, 760		; 000002f8H
  000bc	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 1100 :             MCPX_VOICE_WRITE(SetVoiceTarPitch, dwPitch);

  000c2	ba 7c 03 00 00	 mov	 edx, 892		; 0000037cH
  000c7	8b 45 f4	 mov	 eax, DWORD PTR _dwPitch$[ebp]
  000ca	89 82 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], eax

; 1101 :         }

  000d0	eb c5		 jmp	 SHORT $L38444
$L38436:

; 1102 :     }
; 1103 :     
; 1104 :     DPF_LEAVE_HRESULT(DS_OK);
; 1105 : 
; 1106 :     return DS_OK;

  000d2	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T42263[ebp], 0
  000d9	8d 4d e8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000dc	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000e1	8b 45 e4	 mov	 eax, DWORD PTR $T42263[ebp]

; 1107 : }

  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
?SetPitch@CMcpxVoiceClient@DirectSound@@QAEJXZ ENDP	; DirectSound::CMcpxVoiceClient::SetPitch
DSOUND	ENDS
PUBLIC	?GetSubMixDestination@CMcpxVoiceClient@DirectSound@@IAEPAVCMcpxBuffer@2@XZ ; DirectSound::CMcpxVoiceClient::GetSubMixDestination
; Function compile flags: /Odt
;	COMDAT ?ConvertPitchValue@CMcpxVoiceClient@DirectSound@@IAEXPAK@Z
DSOUND	SEGMENT
_this$ = -12
_pSubMixDestination$ = -8
_lPitch$ = -4
_pdwPitch$ = 8
?ConvertPitchValue@CMcpxVoiceClient@DirectSound@@IAEXPAK@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::ConvertPitchValue, COMDAT
; _this$ = ecx

; 1133 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1134 :     CMcpxBuffer *           pSubMixDestination;
; 1135 :     LONG                    lPitch;
; 1136 :     
; 1137 :     DPF_ENTER();
; 1138 : 
; 1139 :     ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
; 1140 : 
; 1141 :     //
; 1142 :     // If we're a submix destination, our pitch must be locked at 0.  In order 
; 1143 :     // to allow callers to set the pitch on submix destination voices, all
; 1144 :     // source voices will know to read from our pitch.
; 1145 :     //
; 1146 : 
; 1147 :     if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0000f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00012	81 e2 00 20 08
	00		 and	 edx, 532480		; 00082000H
  00018	85 d2		 test	 edx, edx
  0001a	74 09		 je	 SHORT $L38458

; 1148 :     {
; 1149 :         lPitch = 0;

  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lPitch$[ebp], 0

; 1150 :     }
; 1151 :     else

  00023	eb 51		 jmp	 SHORT $L38459
$L38458:

; 1152 :     {
; 1153 :         lPitch = m_pSettings->m_lPitch;

  00025	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0002b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0002e	89 55 fc	 mov	 DWORD PTR _lPitch$[ebp], edx

; 1154 : 
; 1155 : #ifndef MCPX_BOOT_LIB
; 1156 : 
; 1157 :         if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
; 1158 :         {
; 1159 :             ASSERT(m_pSettings->m_p3dParams);
; 1160 :             ASSERT(m_pHrtfSource);
; 1161 :             
; 1162 :             if(DS3DMODE_DISABLE != m_pSettings->m_p3dParams->HrtfParams.dwMode)
; 1163 :             {
; 1164 :                 lPitch += m_pHrtfSource->m_3dVoiceData.lDopplerPitch;
; 1165 :             }
; 1166 :         }
; 1167 : 
; 1168 : #endif // MCPX_BOOT_LIB
; 1169 : 
; 1170 :         if(pSubMixDestination = GetSubMixDestination())

  00031	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?GetSubMixDestination@CMcpxVoiceClient@DirectSound@@IAEPAVCMcpxBuffer@2@XZ ; DirectSound::CMcpxVoiceClient::GetSubMixDestination
  00039	89 45 f8	 mov	 DWORD PTR _pSubMixDestination$[ebp], eax
  0003c	83 7d f8 00	 cmp	 DWORD PTR _pSubMixDestination$[ebp], 0
  00040	74 12		 je	 SHORT $L38460

; 1171 :         {
; 1172 :             lPitch += pSubMixDestination->m_pSettings->m_lPitch;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _pSubMixDestination$[ebp]
  00045	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  0004b	8b 55 fc	 mov	 edx, DWORD PTR _lPitch$[ebp]
  0004e	03 51 18	 add	 edx, DWORD PTR [ecx+24]
  00051	89 55 fc	 mov	 DWORD PTR _lPitch$[ebp], edx
$L38460:

; 1173 : 
; 1174 : #ifndef MCPX_BOOT_LIB
; 1175 : 
; 1176 :             if(pSubMixDestination->m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
; 1177 :             {
; 1178 :                 ASSERT(pSubMixDestination->m_pSettings->m_p3dParams);
; 1179 :                 ASSERT(pSubMixDestination->m_pHrtfSource);
; 1180 : 
; 1181 :                 if(DS3DMODE_DISABLE != pSubMixDestination->m_pSettings->m_p3dParams->HrtfParams.dwMode)
; 1182 :                 {
; 1183 :                     lPitch += pSubMixDestination->m_pHrtfSource->m_3dVoiceData.lDopplerPitch;
; 1184 :                 }
; 1185 :             }
; 1186 : 
; 1187 : #endif // MCPX_BOOT_LIB
; 1188 : 
; 1189 :         }
; 1190 : 
; 1191 :         CHECKRANGE(lPitch, DSBPITCH_MIN, DSBPITCH_MAX);

  00054	81 7d fc 01 80
	ff ff		 cmp	 DWORD PTR _lPitch$[ebp], -32767 ; ffff8001H
  0005b	7d 09		 jge	 SHORT $L38461
  0005d	c7 45 fc 01 80
	ff ff		 mov	 DWORD PTR _lPitch$[ebp], -32767 ; ffff8001H
  00064	eb 10		 jmp	 SHORT $L38459
$L38461:
  00066	81 7d fc ff 1f
	00 00		 cmp	 DWORD PTR _lPitch$[ebp], 8191 ; 00001fffH
  0006d	7e 07		 jle	 SHORT $L38459
  0006f	c7 45 fc ff 1f
	00 00		 mov	 DWORD PTR _lPitch$[ebp], 8191 ; 00001fffH
$L38459:

; 1192 :     }
; 1193 : 
; 1194 :     *pdwPitch = MCPX_MAKE_REG_VALUE(lPitch, NV1BA0_PIO_SET_VOICE_TAR_PITCH_STEP);

  00076	8b 45 fc	 mov	 eax, DWORD PTR _lPitch$[ebp]
  00079	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0007e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _pdwPitch$[ebp]
  00084	89 01		 mov	 DWORD PTR [ecx], eax

; 1195 : 
; 1196 :     DPF_LEAVE_VOID();
; 1197 : }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
?ConvertPitchValue@CMcpxVoiceClient@DirectSound@@IAEXPAK@Z ENDP ; DirectSound::CMcpxVoiceClient::ConvertPitchValue
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpvoice.h
DSOUND	ENDS
;	COMDAT ?GetSubMixDestination@CMcpxVoiceClient@DirectSound@@IAEPAVCMcpxBuffer@2@XZ
DSOUND	SEGMENT
_this$ = -4
?GetSubMixDestination@CMcpxVoiceClient@DirectSound@@IAEPAVCMcpxBuffer@2@XZ PROC NEAR ; DirectSound::CMcpxVoiceClient::GetSubMixDestination, COMDAT
; _this$ = ecx

; 282  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 283  :         if(!m_pSettings->m_pMixinBuffer)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0000d	83 b9 b0 00 00
	00 00		 cmp	 DWORD PTR [ecx+176], 0
  00014	75 04		 jne	 SHORT $L34630

; 284  :         {
; 285  :             return NULL;

  00016	33 c0		 xor	 eax, eax
  00018	eb 0f		 jmp	 SHORT $L34629
$L34630:

; 286  :         }
; 287  : 
; 288  :         ASSERT(!(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK));
; 289  :         ASSERT(m_pSettings->m_pMixinBuffer->m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK);
; 290  : 
; 291  :         return m_pSettings->m_pMixinBuffer->m_pBuffer;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  00020	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00026	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
$L34629:

; 292  :     }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?GetSubMixDestination@CMcpxVoiceClient@DirectSound@@IAEPAVCMcpxBuffer@2@XZ ENDP ; DirectSound::CMcpxVoiceClient::GetSubMixDestination
DSOUND	ENDS
PUBLIC	?GetAntecedentVoice@CMcpxVoiceClient@DirectSound@@AAEXPAEPAPAV12@@Z ; DirectSound::CMcpxVoiceClient::GetAntecedentVoice
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpvoice.cpp
;	COMDAT ?GetAntecedentVoice@CMcpxVoiceClient@DirectSound@@AAEXPAEPAPAV12@@Z
DSOUND	SEGMENT
_this$ = -16
_pleAntecedentVoice$ = -8
_pSubMixDestination$ = -4
_pbVoiceList$ = 8
_ppAntecedentVoice$ = 12
?GetAntecedentVoice@CMcpxVoiceClient@DirectSound@@AAEXPAEPAPAV12@@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::GetAntecedentVoice, COMDAT
; _this$ = ecx

; 1226 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1227 :     CMcpxVoiceClient *      pSubMixDestination;
; 1228 :     PLIST_ENTRY             pleAntecedentVoice;
; 1229 :     CMcpxVoiceClient *      pAntecedentVoice;
; 1230 :     
; 1231 :     DPF_ENTER();
; 1232 : 
; 1233 :     if(pSubMixDestination = GetSubMixDestination())

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetSubMixDestination@CMcpxVoiceClient@DirectSound@@IAEPAVCMcpxBuffer@2@XZ ; DirectSound::CMcpxVoiceClient::GetSubMixDestination
  00011	89 45 fc	 mov	 DWORD PTR _pSubMixDestination$[ebp], eax
  00014	83 7d fc 00	 cmp	 DWORD PTR _pSubMixDestination$[ebp], 0
  00018	74 38		 je	 SHORT $L38473

; 1234 :     {
; 1235 :         *pbVoiceList = MCPX_VOICELIST_MP;

  0001a	8b 45 08	 mov	 eax, DWORD PTR _pbVoiceList$[ebp]
  0001d	c6 00 02	 mov	 BYTE PTR [eax], 2

; 1236 : 
; 1237 :         AssertValidEntryList(&pSubMixDestination->m_leActiveVoice, ASSERT_IN_LIST);
; 1238 : 
; 1239 :         pleAntecedentVoice = pSubMixDestination->m_leActiveVoice.Blink;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _pSubMixDestination$[ebp]
  00023	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00026	89 55 f8	 mov	 DWORD PTR _pleAntecedentVoice$[ebp], edx

; 1240 : 
; 1241 :         if(&m_pMcpxApu->m_alstActiveVoices[MCPX_VOICELIST_MP] == pleAntecedentVoice)

  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002f	81 c1 9c 04 00
	00		 add	 ecx, 1180		; 0000049cH
  00035	3b 4d f8	 cmp	 ecx, DWORD PTR _pleAntecedentVoice$[ebp]
  00038	75 0b		 jne	 SHORT $L38474

; 1242 :         {
; 1243 :             *ppAntecedentVoice = NULL;

  0003a	8b 55 0c	 mov	 edx, DWORD PTR _ppAntecedentVoice$[ebp]
  0003d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1244 :         }
; 1245 :         else

  00043	eb 0b		 jmp	 SHORT $L38475
$L38474:

; 1246 :         {
; 1247 :             *ppAntecedentVoice = CONTAINING_RECORD(pleAntecedentVoice, CMcpxVoiceClient, m_leActiveVoice);

  00045	8b 45 f8	 mov	 eax, DWORD PTR _pleAntecedentVoice$[ebp]
  00048	83 e8 4c	 sub	 eax, 76			; 0000004cH
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR _ppAntecedentVoice$[ebp]
  0004e	89 01		 mov	 DWORD PTR [ecx], eax
$L38475:

; 1248 :         }
; 1249 :     }
; 1250 :     else if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)

  00050	eb 54		 jmp	 SHORT $L38469
$L38473:
  00052	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00055	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	81 e1 00 20 08
	00		 and	 ecx, 532480		; 00082000H
  00061	85 c9		 test	 ecx, ecx
  00063	74 11		 je	 SHORT $L38481

; 1251 :     {
; 1252 :         *pbVoiceList = MCPX_VOICELIST_MP;

  00065	8b 55 08	 mov	 edx, DWORD PTR _pbVoiceList$[ebp]
  00068	c6 02 02	 mov	 BYTE PTR [edx], 2

; 1253 :         *ppAntecedentVoice = NULL;

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _ppAntecedentVoice$[ebp]
  0006e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1254 :     }
; 1255 :     else if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)

  00074	eb 30		 jmp	 SHORT $L38469
$L38481:
  00076	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  0007c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0007f	83 e0 10	 and	 eax, 16			; 00000010H
  00082	85 c0		 test	 eax, eax
  00084	74 11		 je	 SHORT $L38483

; 1256 :     {
; 1257 :         *pbVoiceList = MCPX_VOICELIST_3D;

  00086	8b 4d 08	 mov	 ecx, DWORD PTR _pbVoiceList$[ebp]
  00089	c6 01 01	 mov	 BYTE PTR [ecx], 1

; 1258 :         *ppAntecedentVoice = NULL;

  0008c	8b 55 0c	 mov	 edx, DWORD PTR _ppAntecedentVoice$[ebp]
  0008f	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1259 :     }
; 1260 :     else

  00095	eb 0f		 jmp	 SHORT $L38469
$L38483:

; 1261 :     {
; 1262 :         *pbVoiceList = MCPX_VOICELIST_2D;

  00097	8b 45 08	 mov	 eax, DWORD PTR _pbVoiceList$[ebp]
  0009a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1263 :         *ppAntecedentVoice = NULL;

  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _ppAntecedentVoice$[ebp]
  000a0	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L38469:

; 1264 :     }
; 1265 : 
; 1266 :     DPF_LEAVE_VOID();
; 1267 : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 08 00	 ret	 8
?GetAntecedentVoice@CMcpxVoiceClient@DirectSound@@AAEXPAEPAPAV12@@Z ENDP ; DirectSound::CMcpxVoiceClient::GetAntecedentVoice
DSOUND	ENDS
PUBLIC	?InsertHeadList@@YGXPAU_LIST_ENTRY@@0@Z		; InsertHeadList
; Function compile flags: /Odt
;	COMDAT ?ActivateVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -44
_pAntecedentVoice$ = -40
_dwAntecedentVoice$ = -36
_bVoiceList$ = -29
_pSubMixDestination$ = -28
_hAntecedentVoice$ = -24
_dwVoicePause$ = -20
_i$ = -16
_dwVoiceOn$ = -12
_irql$ = -8
?ActivateVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxVoiceClient::ActivateVoice, COMDAT
; _this$ = ecx

; 1293 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 1294 :     BYTE                    bVoiceList;
; 1295 :     CMcpxBuffer *           pSubMixDestination;
; 1296 :     CMcpxVoiceClient *      pAntecedentVoice;
; 1297 :     MCPX_VOICE_HANDLE       hAntecedentVoice;
; 1298 :     DWORD                   dwAntecedentVoice;
; 1299 :     DWORD                   dwVoiceOn;
; 1300 :     DWORD                   dwVoicePause;
; 1301 :     CIrql                   irql;

  00009	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CIrql@DirectSound@@QAE@XZ ; DirectSound::CIrql::CIrql

; 1302 :     int                     i;
; 1303 :     
; 1304 :     DPF_ENTER();
; 1305 : 
; 1306 :     ASSERT(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED);
; 1307 : 
; 1308 :     if(!(m_dwStatus & MCPX_VOICESTATUS_ACTIVE))

  00011	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00014	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00018	83 e1 02	 and	 ecx, 2
  0001b	85 c9		 test	 ecx, ecx
  0001d	0f 85 81 02 00
	00		 jne	 $L38488

; 1309 :     {
; 1310 : 
; 1311 : #ifndef MCPX_BOOT_LIB
; 1312 : 
; 1313 :         if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
; 1314 :         {
; 1315 :             if(!(m_pMcpxApu->m_dwState & MCPX_APUSTATE_GPIMAGE))
; 1316 :             {
; 1317 :                 DPF_ERROR("No effects image has been downloaded and 3D sounds are feeding the XTLK mixbins.  Your 3D sounds will be silent");
; 1318 :             }
; 1319 :             else if(DSFX_IMAGELOC_UNUSED == m_pMcpxApu->m_pSettings->m_EffectLocations.dwCrosstalkIndex)
; 1320 :             {
; 1321 :                 DPF_ERROR("Crosstalk is not in the current effects image and 3D sounds are feeding the XTLK mixbins.  Your 3D sounds will be silent");
; 1322 :             }
; 1323 :         }
; 1324 : 
; 1325 : #endif // MCPX_BOOT_LIB
; 1326 : 
; 1327 :         if(m_pSettings->m_dwFlags & DSBCAPS_SUBMIXMASK)
; 1328 :         {
; 1329 :             ASSERT(!IsListEmpty(&m_lstSourceVoices));
; 1330 :         }
; 1331 :         else
; 1332 :         {
; 1333 :             ASSERT(IsListEmpty(&m_lstSourceVoices));
; 1334 :         }
; 1335 : 
; 1336 :         //
; 1337 :         // Just because the voice status doesn't include ACTIVE doesn't mean
; 1338 :         // the hardware voice is done.  Block until the voice is really 
; 1339 :         // finished.
; 1340 :         //
; 1341 : 
; 1342 :         WaitForVoiceOff();

  00023	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?WaitForVoiceOff@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::WaitForVoiceOff

; 1343 : 
; 1344 :         AssertValidEntryList(&m_leActiveVoice, ASSERT_NOT_IN_LIST);
; 1345 :         AssertValidEntryList(&m_lePendingInactiveVoice, ASSERT_NOT_IN_LIST);
; 1346 : 
; 1347 :         //
; 1348 :         // Update the status
; 1349 :         //
; 1350 :         
; 1351 :         or(&m_dwStatus, MCPX_VOICESTATUS_ACTIVE);

  0002b	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 c1 12	 add	 ecx, 18			; 00000012H
  00031	ba 02 00 00 00	 mov	 edx, 2
  00036	e8 00 00 00 00	 call	 ?or@@YIXPCGG@Z		; or

; 1352 : 
; 1353 : #ifndef MCPX_BOOT_LIB
; 1354 : 
; 1355 :         //
; 1356 :         // If we're 3D, make sure all 3D data is up-to-date
; 1357 :         //
; 1358 : 
; 1359 :         if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
; 1360 :         {
; 1361 :             Commit3dSettings();
; 1362 :         }
; 1363 : 
; 1364 : #endif // MCPX_BOOT_LIB
; 1365 : 
; 1366 :         //
; 1367 :         // If we're submixing, go ahead and start the destination playing 
; 1368 :         // now so it's in the list before we try to determine where to insert 
; 1369 :         // ourselves.
; 1370 :         //
; 1371 : 
; 1372 :         if(pSubMixDestination = GetSubMixDestination())

  0003b	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?GetSubMixDestination@CMcpxVoiceClient@DirectSound@@IAEPAVCMcpxBuffer@2@XZ ; DirectSound::CMcpxVoiceClient::GetSubMixDestination
  00043	89 45 e4	 mov	 DWORD PTR _pSubMixDestination$[ebp], eax
  00046	83 7d e4 00	 cmp	 DWORD PTR _pSubMixDestination$[ebp], 0
  0004a	74 0a		 je	 SHORT $L38501

; 1373 :         {
; 1374 :             ASSERT(pSubMixDestination->m_dwStatus & MCPX_VOICESTATUS_ALLOCATED);
; 1375 :             
; 1376 :             pSubMixDestination->Play(TRUE);

  0004c	6a 01		 push	 1
  0004e	8b 4d e4	 mov	 ecx, DWORD PTR _pSubMixDestination$[ebp]
  00051	e8 00 00 00 00	 call	 ?Play@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::Play
$L38501:

; 1377 :         }
; 1378 : 
; 1379 :         //
; 1380 :         // Raise IRQL for synchronization
; 1381 :         //
; 1382 : 
; 1383 :         irql.Raise();

  00056	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00059	e8 00 00 00 00	 call	 ?Raise@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Raise
$L38503:

; 1384 :         
; 1385 :         //
; 1386 :         // Wait for the method queue to clear so we know we have enough space
; 1387 :         // in the FIFO for the VoiceOn method.
; 1388 :         //
; 1389 : 
; 1390 :         MCPX_CHECK_VOICE_FIFO(PIO_METHOD_QUEUE_CLEAR);

  0005e	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00063	8b 82 00 00 82
	fe		 mov	 eax, DWORD PTR [edx-25034752]
  00069	c1 e8 02	 shr	 eax, 2
  0006c	83 f8 20	 cmp	 eax, 32			; 00000020H
  0006f	73 02		 jae	 SHORT $L38504
  00071	eb eb		 jmp	 SHORT $L38503
$L38504:

; 1391 : 
; 1392 :         //
; 1393 :         // Block the idle handler in order to prevent the voice list from
; 1394 :         // being modified.
; 1395 :         //
; 1396 : 
; 1397 :         m_pMcpxApu->BlockIdleHandler();

  00073	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00079	e8 00 00 00 00	 call	 ?BlockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::BlockIdleHandler

; 1398 : 
; 1399 :         //
; 1400 :         // Reset the voice notifiers
; 1401 :         //
; 1402 : 
; 1403 :         m_Notifier.Reset();

  0007e	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	83 c1 68	 add	 ecx, 104		; 00000068H
  00084	e8 00 00 00 00	 call	 ?Reset@CMcpxNotifier@DirectSound@@QAEXXZ ; DirectSound::CMcpxNotifier::Reset

; 1404 : 
; 1405 :         //
; 1406 :         // Turn on the PERSIST bit so voices are left in the processing list 
; 1407 :         // until we take them out.
; 1408 :         //
; 1409 : 
; 1410 :         if(m_dwStatus & MCPX_VOICESTATUS_PERSIST)

  00089	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  0008c	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  00090	83 e0 10	 and	 eax, 16			; 00000010H
  00093	85 c0		 test	 eax, eax
  00095	74 1a		 je	 SHORT $L38507

; 1411 :         {
; 1412 :             m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST_ON, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST);

  00097	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0009d	81 e2 ff ff 7f
	ff		 and	 edx, -8388609		; ff7fffffH
  000a3	81 ca 00 00 80
	00		 or	 edx, 8388608		; 00800000H
  000a9	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 1413 :         }
; 1414 :         else

  000af	eb 12		 jmp	 SHORT $L38509
$L38507:

; 1415 :         {
; 1416 :             m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST_OFF, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST);

  000b1	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000b7	81 e2 ff ff 7f
	ff		 and	 edx, -8388609		; ff7fffffH
  000bd	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L38509:

; 1417 :         }
; 1418 : 
; 1419 :         //
; 1420 :         // Figure out where to insert the voice in the hardware processing 
; 1421 :         // list
; 1422 :         //
; 1423 : 
; 1424 :         GetAntecedentVoice(&bVoiceList, &pAntecedentVoice);

  000c3	8d 4d d8	 lea	 ecx, DWORD PTR _pAntecedentVoice$[ebp]
  000c6	51		 push	 ecx
  000c7	8d 55 e3	 lea	 edx, DWORD PTR _bVoiceList$[ebp]
  000ca	52		 push	 edx
  000cb	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?GetAntecedentVoice@CMcpxVoiceClient@DirectSound@@AAEXPAEPAPAV12@@Z ; DirectSound::CMcpxVoiceClient::GetAntecedentVoice

; 1425 : 
; 1426 :         if(pAntecedentVoice)

  000d3	83 7d d8 00	 cmp	 DWORD PTR _pAntecedentVoice$[ebp], 0
  000d7	74 28		 je	 SHORT $L38511

; 1427 :         {
; 1428 :             hAntecedentVoice = pAntecedentVoice->m_ahVoices[pAntecedentVoice->m_bVoiceCount - 1];

  000d9	8b 45 d8	 mov	 eax, DWORD PTR _pAntecedentVoice$[ebp]
  000dc	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  000e0	8b 55 d8	 mov	 edx, DWORD PTR _pAntecedentVoice$[ebp]
  000e3	66 8b 44 4a 0a	 mov	 ax, WORD PTR [edx+ecx*2+10]
  000e8	66 89 45 e8	 mov	 WORD PTR _hAntecedentVoice$[ebp], ax

; 1429 :             ASSERT(hAntecedentVoice < MCPX_HW_MAX_VOICES);
; 1430 : 
; 1431 :             dwAntecedentVoice = MCPX_MAKE_REG_VALUE(hAntecedentVoice, NV1BA0_PIO_SET_ANTECEDENT_VOICE_HANDLE);

  000ec	0f b7 4d e8	 movzx	 ecx, WORD PTR _hAntecedentVoice$[ebp]
  000f0	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000f6	89 4d dc	 mov	 DWORD PTR _dwAntecedentVoice$[ebp], ecx

; 1432 :             dwAntecedentVoice |= MCPX_MAKE_REG_VALUE(NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST_INHERIT, NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST);

  000f9	8b 55 dc	 mov	 edx, DWORD PTR _dwAntecedentVoice$[ebp]
  000fc	89 55 dc	 mov	 DWORD PTR _dwAntecedentVoice$[ebp], edx

; 1433 :         }
; 1434 :         else

  000ff	eb 1c		 jmp	 SHORT $L38518
$L38511:

; 1435 :         {
; 1436 :             dwAntecedentVoice = MCPX_MAKE_REG_VALUE(NV1BA0_PIO_SET_ANTECEDENT_VOICE_HANDLE_NULL, NV1BA0_PIO_SET_ANTECEDENT_VOICE_HANDLE);

  00101	c7 45 dc ff ff
	00 00		 mov	 DWORD PTR _dwAntecedentVoice$[ebp], 65535 ; 0000ffffH

; 1437 :             dwAntecedentVoice |= MCPX_MAKE_REG_VALUE(bVoiceList + 1, NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST);

  00108	0f b6 45 e3	 movzx	 eax, BYTE PTR _bVoiceList$[ebp]
  0010c	83 c0 01	 add	 eax, 1
  0010f	83 e0 03	 and	 eax, 3
  00112	c1 e0 10	 shl	 eax, 16			; 00000010H
  00115	8b 4d dc	 mov	 ecx, DWORD PTR _dwAntecedentVoice$[ebp]
  00118	0b c8		 or	 ecx, eax
  0011a	89 4d dc	 mov	 DWORD PTR _dwAntecedentVoice$[ebp], ecx
$L38518:

; 1438 :         }
; 1439 : 
; 1440 :         //
; 1441 :         // Turn the voice on.  If we're supposed to be paused, do that now
; 1442 :         // as well.  Note that we're turning the voices on in reverse order
; 1443 :         // so they're in the hardware processing list correctly.
; 1444 :         //
; 1445 : 
; 1446 :         MCPX_CHECK_VOICE_FIFO(7 * m_bVoiceCount);

  0011d	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00122	8b 82 00 00 82
	fe		 mov	 eax, DWORD PTR [edx-25034752]
  00128	c1 e8 02	 shr	 eax, 2
  0012b	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	0f b6 51 64	 movzx	 edx, BYTE PTR [ecx+100]
  00132	6b d2 07	 imul	 edx, 7
  00135	3b c2		 cmp	 eax, edx
  00137	73 02		 jae	 SHORT $L38519
  00139	eb e2		 jmp	 SHORT $L38518
$L38519:

; 1447 : 
; 1448 :         for(i = m_bVoiceCount - 1; i >= 0; i--)

  0013b	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0013e	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  00142	83 e9 01	 sub	 ecx, 1
  00145	89 4d f0	 mov	 DWORD PTR _i$[ebp], ecx
  00148	eb 09		 jmp	 SHORT $L38522
$L38523:
  0014a	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0014d	83 ea 01	 sub	 edx, 1
  00150	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx
$L38522:
  00153	83 7d f0 00	 cmp	 DWORD PTR _i$[ebp], 0
  00157	0f 8c d6 00 00
	00		 jl	 $L38524

; 1449 :         {
; 1450 :             if(pAntecedentVoice)
; 1451 :             {
; 1452 :                 DPF_BLAB("Voice %x (%x) inheriting voice list position from voice %x (%x)", this, m_ahVoices[i], pAntecedentVoice, hAntecedentVoice);
; 1453 :             }
; 1454 : 
; 1455 :             dwVoiceOn = MCPX_SET_REG_VALUE(m_RegCache.VoiceOn, m_ahVoices[i], NV1BA0_PIO_VOICE_ON_HANDLE);

  0015d	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00160	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00163	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  00169	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0016c	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0016f	0f b7 54 50 0c	 movzx	 edx, WORD PTR [eax+edx*2+12]
  00174	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0017a	0b ca		 or	 ecx, edx
  0017c	89 4d f4	 mov	 DWORD PTR _dwVoiceOn$[ebp], ecx

; 1456 :         
; 1457 :             if(m_dwStatus & MCPX_VOICESTATUS_ALLPAUSEDMASK)

  0017f	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00182	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00186	81 e1 04 04 00
	00		 and	 ecx, 1028		; 00000404H
  0018c	85 c9		 test	 ecx, ecx
  0018e	74 09		 je	 SHORT $L38527

; 1458 :             {
; 1459 :                 dwVoicePause = MCPX_MAKE_REG_VALUE(NV1BA0_PIO_VOICE_PAUSE_ACTION_STOP, NV1BA0_PIO_VOICE_PAUSE_ACTION);

  00190	c7 45 ec 00 00
	04 00		 mov	 DWORD PTR _dwVoicePause$[ebp], 262144 ; 00040000H

; 1460 :             }
; 1461 :             else

  00197	eb 07		 jmp	 SHORT $L38529
$L38527:

; 1462 :             {
; 1463 :                 dwVoicePause = MCPX_MAKE_REG_VALUE(NV1BA0_PIO_VOICE_PAUSE_ACTION_RESUME, NV1BA0_PIO_VOICE_PAUSE_ACTION);

  00199	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwVoicePause$[ebp], 0
$L38529:

; 1464 :             }
; 1465 : 
; 1466 :             dwVoicePause |= MCPX_MAKE_REG_VALUE(m_ahVoices[i], NV1BA0_PIO_VOICE_PAUSE_HANDLE);

  001a0	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  001a3	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  001a6	0f b7 4c 50 0c	 movzx	 ecx, WORD PTR [eax+edx*2+12]
  001ab	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  001b1	8b 55 ec	 mov	 edx, DWORD PTR _dwVoicePause$[ebp]
  001b4	0b d1		 or	 edx, ecx
  001b6	89 55 ec	 mov	 DWORD PTR _dwVoicePause$[ebp], edx

; 1467 :         
; 1468 :             MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  001b9	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  001bc	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001bf	0f b7 54 41 0c	 movzx	 edx, WORD PTR [ecx+eax*2+12]
  001c4	b8 f8 02 00 00	 mov	 eax, 760		; 000002f8H
  001c9	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 1469 :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);

  001cf	b9 fc 02 00 00	 mov	 ecx, 764		; 000002fcH
  001d4	c7 81 00 00 82
	fe 01 00 00 00	 mov	 DWORD PTR [ecx-25034752], 1

; 1470 :             MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));

  001de	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  001e1	52		 push	 edx
  001e2	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e5	e8 00 00 00 00	 call	 ?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::GetVoiceCfgFMT
  001ea	b9 04 03 00 00	 mov	 ecx, 772		; 00000304H
  001ef	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 1471 :             MCPX_VOICE_WRITE(SetAntecedentVoice, dwAntecedentVoice);

  001f5	ba 20 01 00 00	 mov	 edx, 288		; 00000120H
  001fa	8b 45 dc	 mov	 eax, DWORD PTR _dwAntecedentVoice$[ebp]
  001fd	89 82 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], eax

; 1472 :             MCPX_VOICE_WRITE(VoiceOn, dwVoiceOn);

  00203	b9 24 01 00 00	 mov	 ecx, 292		; 00000124H
  00208	8b 55 f4	 mov	 edx, DWORD PTR _dwVoiceOn$[ebp]
  0020b	89 91 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], edx

; 1473 :             MCPX_VOICE_WRITE(VoicePause, dwVoicePause);

  00211	b8 40 01 00 00	 mov	 eax, 320		; 00000140H
  00216	8b 4d ec	 mov	 ecx, DWORD PTR _dwVoicePause$[ebp]
  00219	89 88 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], ecx

; 1474 :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);

  0021f	ba fc 02 00 00	 mov	 edx, 764		; 000002fcH
  00224	c7 82 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [edx-25034752], 0

; 1475 :         }

  0022e	e9 17 ff ff ff	 jmp	 $L38523
$L38524:

; 1476 : 
; 1477 :         //
; 1478 :         // Add the voice client object to the active voice list
; 1479 :         //
; 1480 : 
; 1481 :         if(pAntecedentVoice)

  00233	83 7d d8 00	 cmp	 DWORD PTR _pAntecedentVoice$[ebp], 0
  00237	74 15		 je	 SHORT $L38546

; 1482 :         {
; 1483 :             AssertValidEntryList(&pAntecedentVoice->m_leActiveVoice, ASSERT_IN_LIST);
; 1484 :             InsertHeadList(&pAntecedentVoice->m_leActiveVoice, &m_leActiveVoice);

  00239	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0023c	83 c0 4c	 add	 eax, 76			; 0000004cH
  0023f	50		 push	 eax
  00240	8b 4d d8	 mov	 ecx, DWORD PTR _pAntecedentVoice$[ebp]
  00243	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00246	51		 push	 ecx
  00247	e8 00 00 00 00	 call	 ?InsertHeadList@@YGXPAU_LIST_ENTRY@@0@Z ; InsertHeadList

; 1485 :         }
; 1486 :         else

  0024c	eb 1e		 jmp	 SHORT $L38547
$L38546:

; 1487 :         {
; 1488 :             ASSERT(bVoiceList < NUMELMS(m_pMcpxApu->m_alstActiveVoices));
; 1489 :             InsertHeadList(&m_pMcpxApu->m_alstActiveVoices[bVoiceList], &m_leActiveVoice);

  0024e	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00251	83 c2 4c	 add	 edx, 76			; 0000004cH
  00254	52		 push	 edx
  00255	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00258	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0025b	0f b6 55 e3	 movzx	 edx, BYTE PTR _bVoiceList$[ebp]
  0025f	8d 84 d1 8c 04
	00 00		 lea	 eax, DWORD PTR [ecx+edx*8+1164]
  00266	50		 push	 eax
  00267	e8 00 00 00 00	 call	 ?InsertHeadList@@YGXPAU_LIST_ENTRY@@0@Z ; InsertHeadList
$L38547:

; 1490 :         }
; 1491 : 
; 1492 :         //
; 1493 :         // Save the voice list index for later retrieval
; 1494 :         //
; 1495 : 
; 1496 :         ASSERT(MCPX_VOICELIST_INVALID == m_bVoiceList);
; 1497 :         m_bVoiceList = bVoiceList;

  0026c	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0026f	8a 55 e3	 mov	 dl, BYTE PTR _bVoiceList$[ebp]
  00272	88 51 65	 mov	 BYTE PTR [ecx+101], dl
$L38549:

; 1498 : 
; 1499 :         //
; 1500 :         // Wait for the method queue to clear so we know the VoiceOn method
; 1501 :         // has been processed.
; 1502 :         //
; 1503 : 
; 1504 :         MCPX_CHECK_VOICE_FIFO(PIO_METHOD_QUEUE_CLEAR);

  00275	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0027a	8b 88 00 00 82
	fe		 mov	 ecx, DWORD PTR [eax-25034752]
  00280	c1 e9 02	 shr	 ecx, 2
  00283	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00286	73 02		 jae	 SHORT $L38550
  00288	eb eb		 jmp	 SHORT $L38549
$L38550:

; 1505 : 
; 1506 :         //
; 1507 :         // Unblock the idle handler
; 1508 :         //
; 1509 : 
; 1510 :         m_pMcpxApu->UnblockIdleHandler();

  0028a	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  0028d	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00290	e8 00 00 00 00	 call	 ?UnblockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::UnblockIdleHandler

; 1511 : 
; 1512 :         //
; 1513 :         // Lower IRQL
; 1514 :         //
; 1515 : 
; 1516 :         irql.Lower();

  00295	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00298	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower

; 1517 : 
; 1518 :         //
; 1519 :         // All done
; 1520 :         //
; 1521 : 
; 1522 :         if(m_dwStatus & MCPX_VOICESTATUS_ALLPAUSEDMASK)

  0029d	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  002a0	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
$L38488:

; 1523 :         {
; 1524 :             DPF_INFO("Voice %x (%x) now active in list %x, but paused", this, m_ahVoices[0], (DWORD)bVoiceList);
; 1525 :         }
; 1526 :         else
; 1527 :         {
; 1528 :             DPF_INFO("Voice %x (%x) now active in list %x", this, m_ahVoices[0], (DWORD)bVoiceList);
; 1529 :         }
; 1530 :     }
; 1531 : 
; 1532 :     DPF_LEAVE_VOID();
; 1533 : }

  002a4	8b e5		 mov	 esp, ebp
  002a6	5d		 pop	 ebp
  002a7	c3		 ret	 0
?ActivateVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ ENDP ; DirectSound::CMcpxVoiceClient::ActivateVoice
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\ntlist.h
DSOUND	ENDS
;	COMDAT ?InsertHeadList@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT
_ListHead$ = 8
_Entry$ = 12
?InsertHeadList@@YGXPAU_LIST_ENTRY@@0@Z PROC NEAR	; InsertHeadList, COMDAT

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 168  :     AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);
; 169  :     AssertValidEntryList(Entry, ASSERT_NOT_IN_LIST);
; 170  : 
; 171  :     Entry->Flink = ListHead->Flink;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  00009	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000b	89 10		 mov	 DWORD PTR [eax], edx

; 172  :     Entry->Blink = ListHead;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  00013	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 173  :     
; 174  :     Entry->Flink->Blink = Entry;

  00016	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 175  :     Entry->Blink->Flink = Entry;

  00021	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 176  : 
; 177  :     AssertValidEntryList(Entry, ASSERT_IN_LIST);
; 178  : }

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?InsertHeadList@@YGXPAU_LIST_ENTRY@@0@Z ENDP		; InsertHeadList
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpvoice.cpp
DSOUND	ENDS
;	COMDAT ?DeactivateVoice@CMcpxVoiceClient@DirectSound@@IAEXH@Z
DSOUND	SEGMENT
_this$ = -32
_pSubMixDestination$ = -28
_pleListEntry$ = -24
_pSourceVoice$ = -20
_fSourceValid$ = -16
_i$ = -12
_irql$ = -8
_fBlock$ = 8
?DeactivateVoice@CMcpxVoiceClient@DirectSound@@IAEXH@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::DeactivateVoice, COMDAT
; _this$ = ecx

; 1560 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 1561 :     CMcpxBuffer *           pSubMixDestination;
; 1562 :     CMcpxVoiceClient *      pSourceVoice;
; 1563 :     PLIST_ENTRY             pleListEntry;
; 1564 :     BOOL                    fSourceValid;
; 1565 :     CIrql                   irql;

  00009	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CIrql@DirectSound@@QAE@XZ ; DirectSound::CIrql::CIrql

; 1566 :     DWORD                   i;
; 1567 :     
; 1568 :     DPF_ENTER();
; 1569 : 
; 1570 :     if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)

  00011	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00014	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00018	83 e1 03	 and	 ecx, 3
  0001b	83 f9 03	 cmp	 ecx, 3
  0001e	0f 85 8f 01 00
	00		 jne	 $L38565

; 1571 :     {
; 1572 :         DPF_INFO("Deactivating voice %x (%x)", this, m_ahVoices[0]);
; 1573 : 
; 1574 :         //
; 1575 :         // Raise IRQL for synchronization
; 1576 :         //
; 1577 : 
; 1578 :         irql.Raise();

  00024	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00027	e8 00 00 00 00	 call	 ?Raise@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Raise

; 1579 : 
; 1580 :         //
; 1581 :         // Block the idle handler until we're done setting the voice status
; 1582 :         //
; 1583 : 
; 1584 :         m_pMcpxApu->BlockIdleHandler();

  0002c	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00032	e8 00 00 00 00	 call	 ?BlockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::BlockIdleHandler

; 1585 :         
; 1586 :         //
; 1587 :         // Remove pretty much everything from the status mask, since
; 1588 :         // most of the bits are only valid when we're active.
; 1589 :         //
; 1590 : 
; 1591 :         and(&m_dwStatus, MCPX_VOICESTATUS_DEACTIVATEMASK);

  00037	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 12	 add	 ecx, 18			; 00000012H
  0003d	ba 11 01 00 00	 mov	 edx, 273		; 00000111H
  00042	e8 00 00 00 00	 call	 ?and@@YIXPCGG@Z		; and

; 1592 : 
; 1593 :         //
; 1594 :         // Turn off the PERSIST bit so we're guaranteed the voice will be
; 1595 :         // stopped.
; 1596 :         //
; 1597 : 
; 1598 :         m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST_OFF, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST);

  00047	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0004d	81 e1 ff ff 7f
	ff		 and	 ecx, -8388609		; ff7fffffH
  00053	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00056	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 1599 : 
; 1600 :         //
; 1601 :         // There also seems to be a bug where a looping voice won't always
; 1602 :         // turn off, so we'll disable the looping bit while we're at it.
; 1603 :         //
; 1604 : 
; 1605 :         m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP_OFF, NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP);

  00059	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0005f	81 e1 ff ff ff
	fd		 and	 ecx, -33554433		; fdffffffH
  00065	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00068	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 1606 : 
; 1607 :         //
; 1608 :         // Check the voice list identifier.  If it's -1, the voice has
; 1609 :         // already been removed from the voice list.  We'll set a bit in 
; 1610 :         // the status that tells us that we're still waiting for the voice 
; 1611 :         // to turn off.  When this happens, the ISR will clear the status 
; 1612 :         // bit for us.
; 1613 :         //
; 1614 : 
; 1615 :         if(m_bVoiceList < MCPX_VOICELIST_COUNT)

  0006b	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	0f b6 48 65	 movzx	 ecx, BYTE PTR [eax+101]
  00072	83 f9 03	 cmp	 ecx, 3
  00075	0f 8d 91 00 00
	00		 jge	 $L38583

; 1616 :         {
; 1617 :             //
; 1618 :             // Turn off the voice.  It won't turn off instantly, but the VoiceOff
; 1619 :             // command will be in the command FIFO, so for all intents, the voice
; 1620 :             // really is off.  The one caveat to this is that you want to watch
; 1621 :             // for the VoiceOff notifier before freeing any memory associated
; 1622 :             // with this voice.  It's possible that the VP could access memory
; 1623 :             // between when the VoiceOff notifier goes into the queue and when
; 1624 :             // the voice is processed.
; 1625 :             //
; 1626 : 
; 1627 :             DEBUGLOG("VoiceOff %x (%x)", this, m_ahVoices[0]);
; 1628 : 
; 1629 :             or(&m_dwStatus, MCPX_VOICESTATUS_VOICEOFF);

  0007b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	83 c1 12	 add	 ecx, 18			; 00000012H
  00081	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00086	e8 00 00 00 00	 call	 ?or@@YIXPCGG@Z		; or
$L38570:

; 1630 :             ASSERT(m_bVoiceList < MCPX_VOICELIST_COUNT);
; 1631 : 
; 1632 : #ifndef MCPX_SIMULATE_STUCK_VOICE
; 1633 : 
; 1634 : #ifdef MCPX_NO_VOICE_OFF
; 1635 : 
; 1636 :             DWORD LFOENV = MCPX_SET_REG_VALUE(m_RegCache.LFOENV, 1, NV1BA0_PIO_SET_VOICE_LFO_ENV_EA_RELEASERATE);
; 1637 :             
; 1638 :             MCPX_CHECK_VOICE_FIFO(4 * m_bVoiceCount);
; 1639 :         
; 1640 :             for(i = 0; i < m_bVoiceCount; i++)
; 1641 :             {
; 1642 :                 MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);
; 1643 :                 MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));
; 1644 :                 MCPX_VOICE_WRITE(SetVoiceLFOENV, LFOENV);
; 1645 :                 MCPX_VOICE_WRITE(VoiceRelease, m_ahVoices[i]);
; 1646 :             }
; 1647 : 
; 1648 : #else // MCPX_NO_VOICE_OFF
; 1649 : 
; 1650 :             MCPX_CHECK_VOICE_FIFO(3 * m_bVoiceCount);

  0008b	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00090	8b 82 00 00 82
	fe		 mov	 eax, DWORD PTR [edx-25034752]
  00096	c1 e8 02	 shr	 eax, 2
  00099	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	0f b6 51 64	 movzx	 edx, BYTE PTR [ecx+100]
  000a0	6b d2 03	 imul	 edx, 3
  000a3	3b c2		 cmp	 eax, edx
  000a5	73 02		 jae	 SHORT $L38571
  000a7	eb e2		 jmp	 SHORT $L38570
$L38571:

; 1651 :         
; 1652 :             for(i = 0; i < m_bVoiceCount; i++)

  000a9	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000b0	eb 09		 jmp	 SHORT $L38574
$L38575:
  000b2	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000b5	83 c0 01	 add	 eax, 1
  000b8	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$L38574:
  000bb	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	0f b6 51 64	 movzx	 edx, BYTE PTR [ecx+100]
  000c2	39 55 f4	 cmp	 DWORD PTR _i$[ebp], edx
  000c5	73 45		 jae	 SHORT $L38583

; 1653 :             {
; 1654 :                 MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  000c7	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000ca	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	0f b7 54 41 0c	 movzx	 edx, WORD PTR [ecx+eax*2+12]
  000d2	b8 f8 02 00 00	 mov	 eax, 760		; 000002f8H
  000d7	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 1655 :                 MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));

  000dd	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000e0	51		 push	 ecx
  000e1	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	e8 00 00 00 00	 call	 ?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::GetVoiceCfgFMT
  000e9	ba 04 03 00 00	 mov	 edx, 772		; 00000304H
  000ee	89 82 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], eax

; 1656 :                 MCPX_VOICE_WRITE(VoiceOff, m_ahVoices[i]);

  000f4	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000f7	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000fa	0f b7 54 41 0c	 movzx	 edx, WORD PTR [ecx+eax*2+12]
  000ff	b8 28 01 00 00	 mov	 eax, 296		; 00000128H
  00104	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 1657 :             }

  0010a	eb a6		 jmp	 SHORT $L38575
$L38583:

; 1658 : 
; 1659 : #endif // MCPX_NO_VOICE_OFF
; 1660 : 
; 1661 : #endif // MCPX_SIMULATE_STUCK_VOICE
; 1662 : 
; 1663 :         }
; 1664 :         else
; 1665 :         {
; 1666 :             ASSERT(MCPX_VOICELIST_INVALID == m_bVoiceList);
; 1667 :         }
; 1668 : 
; 1669 :         //
; 1670 :         // Unblock the idle handler
; 1671 :         //
; 1672 : 
; 1673 :         m_pMcpxApu->UnblockIdleHandler();

  0010c	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00112	e8 00 00 00 00	 call	 ?UnblockIdleHandler@CMcpxAPU@DirectSound@@QAEXXZ ; DirectSound::CMcpxAPU::UnblockIdleHandler

; 1674 : 
; 1675 :         //
; 1676 :         // Save the time we posted the VoiceOff request so we can make
; 1677 :         // the hardware handles it later.
; 1678 :         //
; 1679 :         
; 1680 :         KeQuerySystemTime((PLARGE_INTEGER)&m_rtVoiceOff);

  00117	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0011a	81 c2 80 00 00
	00		 add	 edx, 128		; 00000080H
  00120	52		 push	 edx
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQuerySystemTime@4

; 1681 : 
; 1682 :         //
; 1683 :         // Schedule a deferred command to check for a stuck voice
; 1684 :         //
; 1685 : 
; 1686 :         if(!fBlock)

  00127	83 7d 08 00	 cmp	 DWORD PTR _fBlock$[ebp], 0
  0012b	75 13		 jne	 SHORT $L38585

; 1687 :         {
; 1688 :             ScheduleDeferredCommand(MCPX_DEFERREDCMD_VOICE_CHECKSTUCK, 0, 0);

  0012d	6a 00		 push	 0
  0012f	6a 00		 push	 0
  00131	6a 00		 push	 0
  00133	6a 00		 push	 0
  00135	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00138	8b 10		 mov	 edx, DWORD PTR [eax]
  0013a	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0013d	ff 52 18	 call	 DWORD PTR [edx+24]
$L38585:

; 1689 :         }
; 1690 : 
; 1691 :         //
; 1692 :         // If we're submixing, and we're the last source voice to stop,
; 1693 :         // deactivate the destination voice.
; 1694 :         //
; 1695 : 
; 1696 :         if(pSubMixDestination = GetSubMixDestination())

  00140	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00143	e8 00 00 00 00	 call	 ?GetSubMixDestination@CMcpxVoiceClient@DirectSound@@IAEPAVCMcpxBuffer@2@XZ ; DirectSound::CMcpxVoiceClient::GetSubMixDestination
  00148	89 45 e4	 mov	 DWORD PTR _pSubMixDestination$[ebp], eax
  0014b	83 7d e4 00	 cmp	 DWORD PTR _pSubMixDestination$[ebp], 0
  0014f	74 58		 je	 SHORT $L38586

; 1697 :         {
; 1698 :             fSourceValid = FALSE;

  00151	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _fSourceValid$[ebp], 0

; 1699 : 
; 1700 :             for(pleListEntry = pSubMixDestination->m_lstSourceVoices.Flink; pleListEntry != &pSubMixDestination->m_lstSourceVoices; pleListEntry = pleListEntry->Flink)

  00158	8b 45 e4	 mov	 eax, DWORD PTR _pSubMixDestination$[ebp]
  0015b	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0015e	89 4d e8	 mov	 DWORD PTR _pleListEntry$[ebp], ecx
  00161	eb 08		 jmp	 SHORT $L38587
$L38588:
  00163	8b 55 e8	 mov	 edx, DWORD PTR _pleListEntry$[ebp]
  00166	8b 02		 mov	 eax, DWORD PTR [edx]
  00168	89 45 e8	 mov	 DWORD PTR _pleListEntry$[ebp], eax
$L38587:
  0016b	8b 4d e4	 mov	 ecx, DWORD PTR _pSubMixDestination$[ebp]
  0016e	83 c1 44	 add	 ecx, 68			; 00000044H
  00171	39 4d e8	 cmp	 DWORD PTR _pleListEntry$[ebp], ecx
  00174	74 23		 je	 SHORT $L38589

; 1701 :             {
; 1702 :                 AssertValidEntryList(pleListEntry, ASSERT_IN_LIST);
; 1703 : 
; 1704 :                 pSourceVoice = CONTAINING_RECORD(pleListEntry, CMcpxVoiceClient, m_leSourceVoice);

  00176	8b 55 e8	 mov	 edx, DWORD PTR _pleListEntry$[ebp]
  00179	83 ea 5c	 sub	 edx, 92			; 0000005cH
  0017c	89 55 ec	 mov	 DWORD PTR _pSourceVoice$[ebp], edx

; 1705 : 
; 1706 :                 if((pSourceVoice->m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)

  0017f	8b 45 ec	 mov	 eax, DWORD PTR _pSourceVoice$[ebp]
  00182	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00186	83 e1 03	 and	 ecx, 3
  00189	83 f9 03	 cmp	 ecx, 3
  0018c	75 09		 jne	 SHORT $L38594

; 1707 :                 {
; 1708 :                     fSourceValid = TRUE;

  0018e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _fSourceValid$[ebp], 1

; 1709 :                     break;

  00195	eb 02		 jmp	 SHORT $L38589
$L38594:

; 1710 :                 }
; 1711 :             }

  00197	eb ca		 jmp	 SHORT $L38588
$L38589:

; 1712 : 
; 1713 :             if(!fSourceValid)

  00199	83 7d f0 00	 cmp	 DWORD PTR _fSourceValid$[ebp], 0
  0019d	75 0a		 jne	 SHORT $L38586

; 1714 :             {
; 1715 :                 pSubMixDestination->Stop();

  0019f	6a 00		 push	 0
  001a1	8b 4d e4	 mov	 ecx, DWORD PTR _pSubMixDestination$[ebp]
  001a4	e8 00 00 00 00	 call	 ?Stop@CMcpxBuffer@DirectSound@@QAEJK@Z ; DirectSound::CMcpxBuffer::Stop
$L38586:

; 1716 :             }
; 1717 :         }
; 1718 : 
; 1719 :         //
; 1720 :         // Lower IRQL
; 1721 :         //
; 1722 : 
; 1723 :         irql.Lower();

  001a9	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  001ac	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower

; 1724 :     }
; 1725 :     else if(!(m_dwStatus & MCPX_VOICESTATUS_VOICEOFF))

  001b1	eb 1d		 jmp	 SHORT $L38596
$L38565:
  001b3	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  001b6	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  001ba	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  001bf	85 c0		 test	 eax, eax
  001c1	75 0d		 jne	 SHORT $L38596

; 1726 :     {
; 1727 :         //
; 1728 :         // Remove the CHECKSTUCK deferred command from the queue
; 1729 :         //
; 1730 : 
; 1731 :         RemoveDeferredCommand(MCPX_DEFERREDCMD_VOICE_CHECKSTUCK);

  001c3	6a 00		 push	 0
  001c5	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  001c8	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ca	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  001cd	ff 52 1c	 call	 DWORD PTR [edx+28]
$L38596:

; 1732 :     }
; 1733 : 
; 1734 :     //
; 1735 :     // Block until the voice actually stops
; 1736 :     //
; 1737 : 
; 1738 :     if(fBlock)

  001d0	83 7d 08 00	 cmp	 DWORD PTR _fBlock$[ebp], 0
  001d4	74 08		 je	 SHORT $L38558

; 1739 :     {
; 1740 :         WaitForVoiceOff();

  001d6	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  001d9	e8 00 00 00 00	 call	 ?WaitForVoiceOff@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::WaitForVoiceOff
$L38558:

; 1741 :     }
; 1742 : 
; 1743 :     DPF_LEAVE_VOID();
; 1744 : }

  001de	8b e5		 mov	 esp, ebp
  001e0	5d		 pop	 ebp
  001e1	c2 04 00	 ret	 4
?DeactivateVoice@CMcpxVoiceClient@DirectSound@@IAEXH@Z ENDP ; DirectSound::CMcpxVoiceClient::DeactivateVoice
DSOUND	ENDS
;	COMDAT ?ListRegisters@?1??RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z@4QBU__unnamed@23@B
DSOUND_RD	SEGMENT
?ListRegisters@?1??RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z@4QBU__unnamed@23@B DD 02054H ; `DirectSound::CMcpxVoiceClient::RemoveIdleVoice'::`2'::ListRegisters
	DD	02058H
	DD	0205cH
	DD	02060H
	DD	02064H
	DD	02068H
	DD	0206cH
	DD	02070H
	DD	02074H
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z
DSOUND	SEGMENT
_this$ = -48
_dwCVL$ = -44
_dwPrevVoice$ = -40
_dwRegister$ = -36
_dwTVL$ = -32
_fFixNVL$ = -28
_dwNVL$ = -24
_i$ = -20
_dwNextVoice$ = -16
_pPrev$ = -12
_fFixCVL$ = -8
_pNext$ = -4
_fScheduleDpc$ = 8
?RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::RemoveIdleVoice, COMDAT
; _this$ = ecx

; 1770 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 1771 :     static const struct
; 1772 :     {
; 1773 :         DWORD               TVL;
; 1774 :         DWORD               CVL;
; 1775 :         DWORD               NVL;
; 1776 :     } ListRegisters[] =
; 1777 :     {
; 1778 :         { NV_PAPU_TVL2D, NV_PAPU_CVL2D, NV_PAPU_NVL2D },    // MCPX_VOICELIST_2D
; 1779 :         { NV_PAPU_TVL3D, NV_PAPU_CVL3D, NV_PAPU_NVL3D },    // MCPX_VOICELIST_3D
; 1780 :         { NV_PAPU_TVLMP, NV_PAPU_CVLMP, NV_PAPU_NVLMP },    // MCPX_VOICELIST_MP
; 1781 :     };
; 1782 : 
; 1783 :     CMcpxVoiceClient *      pPrev;
; 1784 :     CMcpxVoiceClient *      pNext;
; 1785 :     DWORD                   dwPrevVoice;
; 1786 :     DWORD                   dwNextVoice;
; 1787 :     DWORD                   dwRegister;
; 1788 :     DWORD                   dwTVL;
; 1789 :     DWORD                   dwCVL;
; 1790 :     DWORD                   dwNVL;
; 1791 :     BOOL                    fFixCVL;
; 1792 :     BOOL                    fFixNVL;
; 1793 :     DWORD                   i;
; 1794 : 
; 1795 : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 1796 : 
; 1797 :     ASSERT((KeGetCurrentIrql() > DISPATCH_LEVEL) || m_pMcpxApu->m_dwVoiceMapLock);
; 1798 : 
; 1799 :     AssertValidEntryList(&m_leActiveVoice, ASSERT_IN_LIST);
; 1800 :     ASSERT(m_bVoiceList < NUMELMS(ListRegisters));
; 1801 : 
; 1802 : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 1803 : 
; 1804 :     //
; 1805 :     // Save the current list register values
; 1806 :     //
; 1807 : 
; 1808 :     MCPX_REG_READ(ListRegisters[m_bVoiceList].TVL, &dwTVL);

  00009	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 65	 movzx	 ecx, BYTE PTR [eax+101]
  00010	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  00013	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?ListRegisters@?1??RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z@4QBU__unnamed@23@B[ecx]
  00019	8b 82 00 00 80
	fe		 mov	 eax, DWORD PTR [edx-25165824]
  0001f	89 45 e0	 mov	 DWORD PTR _dwTVL$[ebp], eax

; 1809 :     MCPX_REG_READ(ListRegisters[m_bVoiceList].CVL, &dwCVL);

  00022	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	0f b6 51 65	 movzx	 edx, BYTE PTR [ecx+101]
  00029	6b d2 0c	 imul	 edx, 12			; 0000000cH
  0002c	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR ?ListRegisters@?1??RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z@4QBU__unnamed@23@B[edx+4]
  00032	8b 88 00 00 80
	fe		 mov	 ecx, DWORD PTR [eax-25165824]
  00038	89 4d d4	 mov	 DWORD PTR _dwCVL$[ebp], ecx

; 1810 :     MCPX_REG_READ(ListRegisters[m_bVoiceList].NVL, &dwNVL);

  0003b	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	0f b6 42 65	 movzx	 eax, BYTE PTR [edx+101]
  00042	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00045	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR ?ListRegisters@?1??RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z@4QBU__unnamed@23@B[eax+8]
  0004b	8b 91 00 00 80
	fe		 mov	 edx, DWORD PTR [ecx-25165824]
  00051	89 55 e8	 mov	 DWORD PTR _dwNVL$[ebp], edx

; 1811 : 
; 1812 : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 1813 : 
; 1814 :     ASSERT(!(dwTVL & 0xFFFF0000));
; 1815 :     ASSERT(!(dwCVL & 0xFFFF0000));
; 1816 :     ASSERT(!(dwNVL & 0xFFFF0000));
; 1817 : 
; 1818 : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 1819 : 
; 1820 :     //
; 1821 :     // Determine the voice's position within the list
; 1822 :     //
; 1823 : 
; 1824 :     if(&m_pMcpxApu->m_alstActiveVoices[m_bVoiceList] == m_leActiveVoice.Blink)

  00054	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005a	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	0f b6 42 65	 movzx	 eax, BYTE PTR [edx+101]
  00061	8d 8c c1 8c 04
	00 00		 lea	 ecx, DWORD PTR [ecx+eax*8+1164]
  00068	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	3b 4a 50	 cmp	 ecx, DWORD PTR [edx+80]
  0006e	75 10		 jne	 SHORT $L38629

; 1825 :     {
; 1826 :         pPrev = NULL;

  00070	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pPrev$[ebp], 0

; 1827 :         dwPrevVoice = NV_PAPU_FECV_VALUE_NULL;

  00077	c7 45 d8 ff ff
	00 00		 mov	 DWORD PTR _dwPrevVoice$[ebp], 65535 ; 0000ffffH

; 1828 :     }
; 1829 :     else

  0007e	eb 1e		 jmp	 SHORT $L38630
$L38629:

; 1830 :     {
; 1831 :         pPrev = CONTAINING_RECORD(m_leActiveVoice.Blink, CMcpxVoiceClient, m_leActiveVoice);

  00080	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00086	83 e9 4c	 sub	 ecx, 76			; 0000004cH
  00089	89 4d f4	 mov	 DWORD PTR _pPrev$[ebp], ecx

; 1832 :         dwPrevVoice = (DWORD)pPrev->m_ahVoices[pPrev->m_bVoiceCount - 1];

  0008c	8b 55 f4	 mov	 edx, DWORD PTR _pPrev$[ebp]
  0008f	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  00093	8b 4d f4	 mov	 ecx, DWORD PTR _pPrev$[ebp]
  00096	0f b7 54 41 0a	 movzx	 edx, WORD PTR [ecx+eax*2+10]
  0009b	89 55 d8	 mov	 DWORD PTR _dwPrevVoice$[ebp], edx
$L38630:

; 1833 :     }
; 1834 : 
; 1835 :     if(&m_pMcpxApu->m_alstActiveVoices[m_bVoiceList] == m_leActiveVoice.Flink)

  0009e	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a4	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  000a7	0f b6 42 65	 movzx	 eax, BYTE PTR [edx+101]
  000ab	8d 8c c1 8c 04
	00 00		 lea	 ecx, DWORD PTR [ecx+eax*8+1164]
  000b2	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  000b5	3b 4a 4c	 cmp	 ecx, DWORD PTR [edx+76]
  000b8	75 10		 jne	 SHORT $L38636

; 1836 :     {
; 1837 :         pNext = NULL;

  000ba	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pNext$[ebp], 0

; 1838 :         dwNextVoice = NV_PAPU_FECV_VALUE_NULL;

  000c1	c7 45 f0 ff ff
	00 00		 mov	 DWORD PTR _dwNextVoice$[ebp], 65535 ; 0000ffffH

; 1839 :     }
; 1840 :     else

  000c8	eb 16		 jmp	 SHORT $L38637
$L38636:

; 1841 :     {
; 1842 :         pNext = CONTAINING_RECORD(m_leActiveVoice.Flink, CMcpxVoiceClient, m_leActiveVoice);

  000ca	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000d0	83 e9 4c	 sub	 ecx, 76			; 0000004cH
  000d3	89 4d fc	 mov	 DWORD PTR _pNext$[ebp], ecx

; 1843 :         dwNextVoice = (DWORD)pNext->m_ahVoices[0];

  000d6	8b 55 fc	 mov	 edx, DWORD PTR _pNext$[ebp]
  000d9	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  000dd	89 45 f0	 mov	 DWORD PTR _dwNextVoice$[ebp], eax
$L38637:

; 1844 :     }
; 1845 : 
; 1846 : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 1847 : 
; 1848 :     //
; 1849 :     // Validate the list surrounding the voice to be removed
; 1850 :     //
; 1851 :     
; 1852 :     if(pPrev)
; 1853 :     {
; 1854 :         MCPX_VOICE_STRUCT_READ(dwPrevVoice, NV_PAVS_VOICE_TAR_PITCH_LINK, &dwRegister);
; 1855 :         ASSERT((dwRegister & 0xFFFF) == (DWORD)m_ahVoices[0]);
; 1856 :     }
; 1857 :     else
; 1858 :     {
; 1859 :         ASSERT(dwTVL == (DWORD)m_ahVoices[0]);
; 1860 :     }
; 1861 : 
; 1862 :     for(i = 0; i < (DWORD)m_bVoiceCount - 1; i++)
; 1863 :     {
; 1864 :         MCPX_VOICE_STRUCT_READ(m_ahVoices[i], NV_PAVS_VOICE_TAR_PITCH_LINK, &dwRegister);
; 1865 :         ASSERT((dwRegister & 0xFFFF) == (DWORD)m_ahVoices[i + 1]);
; 1866 :     }
; 1867 : 
; 1868 :     MCPX_VOICE_STRUCT_READ(m_ahVoices[i], NV_PAVS_VOICE_TAR_PITCH_LINK, &dwRegister);
; 1869 :     ASSERT((dwRegister & 0xFFFF) == dwNextVoice);
; 1870 : 
; 1871 : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 1872 : 
; 1873 :     //
; 1874 :     // If we're at the head of the list, fix the TVL register.  If not, 
; 1875 :     // fix up the next voice pointer for the previous voice.
; 1876 :     //
; 1877 : 
; 1878 :     if(pPrev)

  000e0	83 7d f4 00	 cmp	 DWORD PTR _pPrev$[ebp], 0
  000e4	74 3d		 je	 SHORT $L38643

; 1879 :     {
; 1880 :         MCPX_VOICE_STRUCT_READ(dwPrevVoice, NV_PAVS_VOICE_TAR_PITCH_LINK, &dwRegister);

  000e6	8b 4d d8	 mov	 ecx, DWORD PTR _dwPrevVoice$[ebp]
  000e9	c1 e1 07	 shl	 ecx, 7
  000ec	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+48
  000f2	8b 44 0a 7c	 mov	 eax, DWORD PTR [edx+ecx+124]
  000f6	89 45 dc	 mov	 DWORD PTR _dwRegister$[ebp], eax

; 1881 : 
; 1882 :         dwRegister &= 0xFFFF0000;

  000f9	8b 4d dc	 mov	 ecx, DWORD PTR _dwRegister$[ebp]
  000fc	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  00102	89 4d dc	 mov	 DWORD PTR _dwRegister$[ebp], ecx

; 1883 :         dwRegister |= dwNextVoice;

  00105	8b 55 dc	 mov	 edx, DWORD PTR _dwRegister$[ebp]
  00108	0b 55 f0	 or	 edx, DWORD PTR _dwNextVoice$[ebp]
  0010b	89 55 dc	 mov	 DWORD PTR _dwRegister$[ebp], edx

; 1884 : 
; 1885 :         MCPX_VOICE_STRUCT_WRITE(dwPrevVoice, NV_PAVS_VOICE_TAR_PITCH_LINK, dwRegister);

  0010e	8b 45 d8	 mov	 eax, DWORD PTR _dwPrevVoice$[ebp]
  00111	c1 e0 07	 shl	 eax, 7
  00114	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+48
  0011a	8b 55 dc	 mov	 edx, DWORD PTR _dwRegister$[ebp]
  0011d	89 54 01 7c	 mov	 DWORD PTR [ecx+eax+124], edx

; 1886 :     }
; 1887 :     else

  00121	eb 1f		 jmp	 SHORT $L38651
$L38643:

; 1888 :     {
; 1889 :         dwTVL = dwNextVoice;

  00123	8b 45 f0	 mov	 eax, DWORD PTR _dwNextVoice$[ebp]
  00126	89 45 e0	 mov	 DWORD PTR _dwTVL$[ebp], eax

; 1890 :         
; 1891 :         MCPX_REG_WRITE(ListRegisters[m_bVoiceList].TVL, dwTVL);

  00129	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012c	0f b6 51 65	 movzx	 edx, BYTE PTR [ecx+101]
  00130	6b d2 0c	 imul	 edx, 12			; 0000000cH
  00133	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR ?ListRegisters@?1??RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z@4QBU__unnamed@23@B[edx]
  00139	8b 4d e0	 mov	 ecx, DWORD PTR _dwTVL$[ebp]
  0013c	89 88 00 00 80
	fe		 mov	 DWORD PTR [eax-25165824], ecx
$L38651:

; 1892 :     }
; 1893 : 
; 1894 :     //
; 1895 :     // Enter the hardware voice loop
; 1896 :     //
; 1897 : 
; 1898 :     for(i = 0, fFixCVL = FALSE, fFixNVL = FALSE; i < m_bVoiceCount; i++)

  00142	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00149	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fFixCVL$[ebp], 0
  00150	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _fFixNVL$[ebp], 0
  00157	eb 09		 jmp	 SHORT $L38654
$L38655:
  00159	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  0015c	83 c2 01	 add	 edx, 1
  0015f	89 55 ec	 mov	 DWORD PTR _i$[ebp], edx
$L38654:
  00162	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00165	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  00169	39 4d ec	 cmp	 DWORD PTR _i$[ebp], ecx
  0016c	0f 83 87 00 00
	00		 jae	 $L38656

; 1899 :     {
; 1900 :         //
; 1901 :         // Check the CVL register
; 1902 :         //
; 1903 : 
; 1904 :         if(dwCVL == (DWORD)m_ahVoices[i])

  00172	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  00175	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00178	0f b7 4c 50 0c	 movzx	 ecx, WORD PTR [eax+edx*2+12]
  0017d	39 4d d4	 cmp	 DWORD PTR _dwCVL$[ebp], ecx
  00180	75 07		 jne	 SHORT $L38658

; 1905 :         {
; 1906 :             fFixCVL = TRUE;

  00182	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fFixCVL$[ebp], 1
$L38658:

; 1907 :         }
; 1908 : 
; 1909 :         //
; 1910 :         // Check the NVL register
; 1911 :         //
; 1912 : 
; 1913 :         if(dwNVL == (DWORD)m_ahVoices[i])

  00189	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  0018c	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0018f	0f b7 4c 50 0c	 movzx	 ecx, WORD PTR [eax+edx*2+12]
  00194	39 4d e8	 cmp	 DWORD PTR _dwNVL$[ebp], ecx
  00197	75 07		 jne	 SHORT $L38660

; 1914 :         {
; 1915 :             fFixNVL = TRUE;

  00199	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _fFixNVL$[ebp], 1
$L38660:

; 1916 :         }
; 1917 : 
; 1918 :         //
; 1919 :         // Remove the voice from the hardware list by making it point to itself
; 1920 :         //
; 1921 : 
; 1922 :         MCPX_VOICE_STRUCT_READ(m_ahVoices[i], NV_PAVS_VOICE_TAR_PITCH_LINK, &dwRegister);

  001a0	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  001a3	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  001a6	0f b7 4c 50 0c	 movzx	 ecx, WORD PTR [eax+edx*2+12]
  001ab	c1 e1 07	 shl	 ecx, 7
  001ae	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+48
  001b4	8b 44 0a 7c	 mov	 eax, DWORD PTR [edx+ecx+124]
  001b8	89 45 dc	 mov	 DWORD PTR _dwRegister$[ebp], eax

; 1923 : 
; 1924 :         dwRegister &= 0xFFFF0000;

  001bb	8b 4d dc	 mov	 ecx, DWORD PTR _dwRegister$[ebp]
  001be	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  001c4	89 4d dc	 mov	 DWORD PTR _dwRegister$[ebp], ecx

; 1925 :         dwRegister |= (WORD)m_ahVoices[i];

  001c7	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  001ca	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  001cd	0f b7 4c 50 0c	 movzx	 ecx, WORD PTR [eax+edx*2+12]
  001d2	8b 55 dc	 mov	 edx, DWORD PTR _dwRegister$[ebp]
  001d5	0b d1		 or	 edx, ecx
  001d7	89 55 dc	 mov	 DWORD PTR _dwRegister$[ebp], edx

; 1926 :         
; 1927 :         MCPX_VOICE_STRUCT_WRITE(m_ahVoices[i], NV_PAVS_VOICE_TAR_PITCH_LINK, dwRegister);

  001da	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  001dd	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e0	0f b7 54 41 0c	 movzx	 edx, WORD PTR [ecx+eax*2+12]
  001e5	c1 e2 07	 shl	 edx, 7
  001e8	a1 30 00 00 00	 mov	 eax, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+48
  001ed	8b 4d dc	 mov	 ecx, DWORD PTR _dwRegister$[ebp]
  001f0	89 4c 10 7c	 mov	 DWORD PTR [eax+edx+124], ecx

; 1928 :     }

  001f4	e9 60 ff ff ff	 jmp	 $L38655
$L38656:

; 1929 : 
; 1930 :     //
; 1931 :     // Fix up the CVL and NVL registers
; 1932 :     //
; 1933 : 
; 1934 :     if(fFixCVL)

  001f9	83 7d f8 00	 cmp	 DWORD PTR _fFixCVL$[ebp], 0
  001fd	0f 84 82 00 00
	00		 je	 $L38669

; 1935 :     {
; 1936 :         if(pNext)

  00203	83 7d fc 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  00207	74 3b		 je	 SHORT $L38670

; 1937 :         {
; 1938 :             dwCVL = dwNextVoice;

  00209	8b 55 f0	 mov	 edx, DWORD PTR _dwNextVoice$[ebp]
  0020c	89 55 d4	 mov	 DWORD PTR _dwCVL$[ebp], edx

; 1939 : 
; 1940 :             MCPX_VOICE_STRUCT_READ(dwNextVoice, NV_PAVS_VOICE_TAR_PITCH_LINK, &dwRegister);

  0020f	8b 45 f0	 mov	 eax, DWORD PTR _dwNextVoice$[ebp]
  00212	c1 e0 07	 shl	 eax, 7
  00215	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+48
  0021b	8b 54 01 7c	 mov	 edx, DWORD PTR [ecx+eax+124]
  0021f	89 55 dc	 mov	 DWORD PTR _dwRegister$[ebp], edx

; 1941 :             
; 1942 :             dwRegister &= 0xFFFF;

  00222	8b 45 dc	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00225	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0022a	89 45 dc	 mov	 DWORD PTR _dwRegister$[ebp], eax

; 1943 : 
; 1944 :             if(NV_PAPU_FECV_VALUE_NULL == dwRegister)

  0022d	81 7d dc ff ff
	00 00		 cmp	 DWORD PTR _dwRegister$[ebp], 65535 ; 0000ffffH
  00234	75 06		 jne	 SHORT $L38674

; 1945 :             {
; 1946 :                 dwRegister = dwTVL;

  00236	8b 4d e0	 mov	 ecx, DWORD PTR _dwTVL$[ebp]
  00239	89 4d dc	 mov	 DWORD PTR _dwRegister$[ebp], ecx
$L38674:

; 1947 :             }
; 1948 : 
; 1949 :             dwNVL = dwRegister;

  0023c	8b 55 dc	 mov	 edx, DWORD PTR _dwRegister$[ebp]
  0023f	89 55 e8	 mov	 DWORD PTR _dwNVL$[ebp], edx

; 1950 :         }
; 1951 :         else

  00242	eb 0d		 jmp	 SHORT $L38675
$L38670:

; 1952 :         {
; 1953 :             dwCVL = NV_PAPU_FECV_VALUE_NULL;

  00244	c7 45 d4 ff ff
	00 00		 mov	 DWORD PTR _dwCVL$[ebp], 65535 ; 0000ffffH

; 1954 :             dwNVL = dwTVL;

  0024b	8b 45 e0	 mov	 eax, DWORD PTR _dwTVL$[ebp]
  0024e	89 45 e8	 mov	 DWORD PTR _dwNVL$[ebp], eax
$L38675:

; 1955 :         }
; 1956 : 
; 1957 :         MCPX_REG_WRITE(ListRegisters[m_bVoiceList].CVL, dwCVL);

  00251	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00254	0f b6 51 65	 movzx	 edx, BYTE PTR [ecx+101]
  00258	6b d2 0c	 imul	 edx, 12			; 0000000cH
  0025b	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR ?ListRegisters@?1??RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z@4QBU__unnamed@23@B[edx+4]
  00261	8b 4d d4	 mov	 ecx, DWORD PTR _dwCVL$[ebp]
  00264	89 88 00 00 80
	fe		 mov	 DWORD PTR [eax-25165824], ecx

; 1958 :         MCPX_REG_WRITE(ListRegisters[m_bVoiceList].NVL, dwNVL);

  0026a	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  0026d	0f b6 42 65	 movzx	 eax, BYTE PTR [edx+101]
  00271	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00274	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR ?ListRegisters@?1??RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z@4QBU__unnamed@23@B[eax+8]
  0027a	8b 55 e8	 mov	 edx, DWORD PTR _dwNVL$[ebp]
  0027d	89 91 00 00 80
	fe		 mov	 DWORD PTR [ecx-25165824], edx

; 1959 :     }
; 1960 :     else if(fFixNVL)

  00283	eb 33		 jmp	 SHORT $L38680
$L38669:
  00285	83 7d e4 00	 cmp	 DWORD PTR _fFixNVL$[ebp], 0
  00289	74 2d		 je	 SHORT $L38680

; 1961 :     {
; 1962 :         if(pNext)

  0028b	83 7d fc 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  0028f	74 08		 je	 SHORT $L38682

; 1963 :         {
; 1964 :             dwNVL = dwNextVoice;

  00291	8b 45 f0	 mov	 eax, DWORD PTR _dwNextVoice$[ebp]
  00294	89 45 e8	 mov	 DWORD PTR _dwNVL$[ebp], eax

; 1965 :         }
; 1966 :         else

  00297	eb 06		 jmp	 SHORT $L38683
$L38682:

; 1967 :         {
; 1968 :             dwNVL = dwTVL;

  00299	8b 4d e0	 mov	 ecx, DWORD PTR _dwTVL$[ebp]
  0029c	89 4d e8	 mov	 DWORD PTR _dwNVL$[ebp], ecx
$L38683:

; 1969 :         }
; 1970 : 
; 1971 :         MCPX_REG_WRITE(ListRegisters[m_bVoiceList].NVL, dwNVL);

  0029f	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  002a2	0f b6 42 65	 movzx	 eax, BYTE PTR [edx+101]
  002a6	6b c0 0c	 imul	 eax, 12			; 0000000cH
  002a9	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR ?ListRegisters@?1??RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z@4QBU__unnamed@23@B[eax+8]
  002af	8b 55 e8	 mov	 edx, DWORD PTR _dwNVL$[ebp]
  002b2	89 91 00 00 80
	fe		 mov	 DWORD PTR [ecx-25165824], edx
$L38680:

; 1972 :     }
; 1973 : 
; 1974 :     //
; 1975 :     // Remove the voice client object from the active voice list
; 1976 :     //
; 1977 : 
; 1978 :     RemoveEntryList(&m_leActiveVoice);

  002b8	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  002bb	83 c0 4c	 add	 eax, 76			; 0000004cH
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 1979 : 
; 1980 :     //
; 1981 :     // Reset the voice list index
; 1982 :     //
; 1983 : 
; 1984 :     m_bVoiceList = MCPX_VOICELIST_INVALID;

  002c4	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  002c7	c6 41 65 ff	 mov	 BYTE PTR [ecx+101], 255	; 000000ffH

; 1985 : 
; 1986 :     //
; 1987 :     // If the voice realizes it's stopped before we do, either because it
; 1988 :     // stopped itself or because the SSL interrupt was completed before
; 1989 :     // the idle voice interrupt, the voice will set the VOICEOFF bit in
; 1990 :     // it's status, meaning that it's waiting for notification from us that
; 1991 :     // it's free to release it's resources.  If this bit is set, just clear
; 1992 :     // it.  If it's not, add the voice to the "pending inactive" list.  During
; 1993 :     // the ISR DPC, we'll walk both the active voice lists and the pending
; 1994 :     // inactive list.  This makes it safe for us to remove the voice from the
; 1995 :     // active voice list before the SSL interrupt is handled.
; 1996 :     // 
; 1997 : 
; 1998 :     if(m_dwStatus & MCPX_VOICESTATUS_VOICEOFF)

  002cb	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  002ce	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  002d2	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  002d7	85 c0		 test	 eax, eax
  002d9	74 12		 je	 SHORT $L38686

; 1999 :     {
; 2000 :         and(&m_dwStatus, ~MCPX_VOICESTATUS_VOICEOFF);

  002db	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  002de	83 c1 12	 add	 ecx, 18			; 00000012H
  002e1	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  002e6	e8 00 00 00 00	 call	 ?and@@YIXPCGG@Z		; and

; 2001 : 
; 2002 : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 2003 : 
; 2004 :         DPF_INFO("Voice %x (%x) is now idle", this, m_ahVoices[0]);
; 2005 : 
; 2006 : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 2007 : 
; 2008 :     }
; 2009 :     else

  002eb	eb 53		 jmp	 SHORT $L38602
$L38686:

; 2010 :     {
; 2011 :         m_Notifier.SetStatus(MCPX_NOTIFIER_VOICE_OFF, TRUE);

  002ed	6a 01		 push	 1
  002ef	6a 03		 push	 3
  002f1	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  002f4	83 c1 68	 add	 ecx, 104		; 00000068H
  002f7	e8 00 00 00 00	 call	 ?SetStatus@CMcpxNotifier@DirectSound@@QAEXKH@Z ; DirectSound::CMcpxNotifier::SetStatus

; 2012 :         
; 2013 :         if(fScheduleDpc)

  002fc	83 7d 08 00	 cmp	 DWORD PTR _fScheduleDpc$[ebp], 0
  00300	74 3e		 je	 SHORT $L38602

; 2014 :         {
; 2015 :             InsertTailList(&m_pMcpxApu->m_lstPendingInactiveVoices, &m_lePendingInactiveVoice);

  00302	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00305	83 c1 54	 add	 ecx, 84			; 00000054H
  00308	51		 push	 ecx
  00309	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  0030c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0030f	05 a4 04 00 00	 add	 eax, 1188		; 000004a4H
  00314	50		 push	 eax
  00315	e8 00 00 00 00	 call	 ?InsertTailList@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailList

; 2016 : 
; 2017 :             m_pMcpxApu->m_arInterruptStatus[0].FEVoice = TRUE;

  0031a	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0031d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00320	8b 82 bc 04 00
	00		 mov	 eax, DWORD PTR [edx+1212]
  00326	83 c8 40	 or	 eax, 64			; 00000040H
  00329	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0032c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0032f	89 82 bc 04 00
	00		 mov	 DWORD PTR [edx+1212], eax

; 2018 :         
; 2019 :             m_pMcpxApu->ScheduleApuInterruptDpc();

  00335	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00338	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0033b	e8 00 00 00 00	 call	 ?ScheduleApuInterruptDpc@CMcpxAPU@DirectSound@@IAEXXZ ; DirectSound::CMcpxAPU::ScheduleApuInterruptDpc
$L38602:

; 2020 :         }
; 2021 : 
; 2022 : #ifdef MCPX_ENABLE_ISR_DEBUGGING
; 2023 : 
; 2024 :         DPF_INFO("Voice %x (%x) is now idle, but pending SSL completion", this, m_ahVoices[0]);
; 2025 : 
; 2026 : #endif // MCPX_ENABLE_ISR_DEBUGGING
; 2027 : 
; 2028 :     }
; 2029 : }

  00340	8b e5		 mov	 esp, ebp
  00342	5d		 pop	 ebp
  00343	c2 04 00	 ret	 4
?RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z ENDP ; DirectSound::CMcpxVoiceClient::RemoveIdleVoice
DSOUND	ENDS
PUBLIC	?RemoveStuckVoice@CMcpxVoiceClient@DirectSound@@AAEXXZ ; DirectSound::CMcpxVoiceClient::RemoveStuckVoice
PUBLIC	?IdleVoiceProcessor@CMcpxCore@DirectSound@@QAEHH@Z ; DirectSound::CMcpxCore::IdleVoiceProcessor
; Function compile flags: /Odt
;	COMDAT ?RemoveStuckVoice@CMcpxVoiceClient@DirectSound@@AAEXXZ
DSOUND	SEGMENT
_this$ = -16
___AutoIrql$ = -12
_fIdle$ = -4
?RemoveStuckVoice@CMcpxVoiceClient@DirectSound@@AAEXXZ PROC NEAR ; DirectSound::CMcpxVoiceClient::RemoveStuckVoice, COMDAT
; _this$ = ecx

; 2055 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2056 :     BOOL                    fIdle;
; 2057 :     
; 2058 :     DPF_ENTER();
; 2059 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 2060 : 
; 2061 : #ifdef MCPX_DEBUG_STUCK_VOICES
; 2062 : 
; 2063 :     BREAK();
; 2064 : 
; 2065 : #endif // MCPX_DEBUG_STUCK_VOICES
; 2066 : 
; 2067 :     m_dwStuckVoiceCount++;

  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwStuckVoiceCount@CMcpxVoiceClient@DirectSound@@2KA ; DirectSound::CMcpxVoiceClient::m_dwStuckVoiceCount
  00016	83 c0 01	 add	 eax, 1
  00019	a3 00 00 00 00	 mov	 DWORD PTR ?m_dwStuckVoiceCount@CMcpxVoiceClient@DirectSound@@2KA, eax ; DirectSound::CMcpxVoiceClient::m_dwStuckVoiceCount

; 2068 :     
; 2069 :     //
; 2070 :     // Idle the voice processor
; 2071 :     //
; 2072 : 
; 2073 :     fIdle = m_pMcpxApu->IdleVoiceProcessor(TRUE);

  0001e	6a 01		 push	 1
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00026	83 c1 08	 add	 ecx, 8
  00029	e8 00 00 00 00	 call	 ?IdleVoiceProcessor@CMcpxCore@DirectSound@@QAEHH@Z ; DirectSound::CMcpxCore::IdleVoiceProcessor
  0002e	89 45 fc	 mov	 DWORD PTR _fIdle$[ebp], eax

; 2074 : 
; 2075 :     //
; 2076 :     // Remove the stuck voice
; 2077 :     //
; 2078 : 
; 2079 :     RemoveIdleVoice(FALSE);

  00031	6a 00		 push	 0
  00033	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?RemoveIdleVoice@CMcpxVoiceClient@DirectSound@@AAEXH@Z ; DirectSound::CMcpxVoiceClient::RemoveIdleVoice

; 2080 : 
; 2081 :     //
; 2082 :     // Turn the VP back on
; 2083 :     //
; 2084 : 
; 2085 :     if(fIdle)

  0003b	83 7d fc 00	 cmp	 DWORD PTR _fIdle$[ebp], 0
  0003f	74 10		 je	 SHORT $L38695

; 2086 :     {
; 2087 :         m_pMcpxApu->IdleVoiceProcessor(FALSE);

  00041	6a 00		 push	 0
  00043	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00046	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00049	83 c1 08	 add	 ecx, 8
  0004c	e8 00 00 00 00	 call	 ?IdleVoiceProcessor@CMcpxCore@DirectSound@@QAEHH@Z ; DirectSound::CMcpxCore::IdleVoiceProcessor
$L38695:

; 2088 :     }
; 2089 : 
; 2090 :     //
; 2091 :     // Service the voice interrupt that didn't happen
; 2092 :     //
; 2093 : 
; 2094 :     ServiceVoiceInterrupt();

  00051	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	ff 52 14	 call	 DWORD PTR [edx+20]

; 2095 : 
; 2096 :     DPF_LEAVE_VOID();
; 2097 : }

  0005c	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0005f	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?RemoveStuckVoice@CMcpxVoiceClient@DirectSound@@AAEXXZ ENDP ; DirectSound::CMcpxVoiceClient::RemoveStuckVoice
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?ReleaseVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -16
___AutoIrql$ = -12
_i$ = -4
?ReleaseVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxVoiceClient::ReleaseVoice, COMDAT
; _this$ = ecx

; 2123 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2124 :     DWORD                   i;
; 2125 :     
; 2126 :     DPF_ENTER();
; 2127 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 2128 : 
; 2129 :     if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)

  00011	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00014	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00018	83 e1 03	 and	 ecx, 3
  0001b	83 f9 03	 cmp	 ecx, 3
  0001e	0f 85 a2 00 00
	00		 jne	 $L38702

; 2130 :     {
; 2131 :         //
; 2132 :         // Release the voice.  We'll get an interrupt later when the voice
; 2133 :         // actually turns off.  Be sure the PERSIST bit is cleared so the voice
; 2134 :         // turns off at the end of the envelope.
; 2135 :         //
; 2136 :         
; 2137 :         DPF_INFO("Releasing voice %x (%x)", this, m_ahVoices[0]);
; 2138 : 
; 2139 :         or(&m_dwStatus, MCPX_VOICESTATUS_NOTEOFF);

  00024	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	83 c1 12	 add	 ecx, 18			; 00000012H
  0002a	ba 08 00 00 00	 mov	 edx, 8
  0002f	e8 00 00 00 00	 call	 ?or@@YIXPCGG@Z		; or

; 2140 :         
; 2141 :         m_RegCache.CfgFMT = MCPX_SET_REG_VALUE(m_RegCache.CfgFMT, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST_OFF, NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST);

  00034	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00037	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0003a	25 ff ff 7f ff	 and	 eax, -8388609		; ff7fffffH
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L38705:

; 2142 : 
; 2143 :         MCPX_CHECK_VOICE_FIFO(3 * m_bVoiceCount);

  00045	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0004a	8b 82 00 00 82
	fe		 mov	 eax, DWORD PTR [edx-25034752]
  00050	c1 e8 02	 shr	 eax, 2
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	0f b6 51 64	 movzx	 edx, BYTE PTR [ecx+100]
  0005a	6b d2 03	 imul	 edx, 3
  0005d	3b c2		 cmp	 eax, edx
  0005f	73 02		 jae	 SHORT $L38706
  00061	eb e2		 jmp	 SHORT $L38705
$L38706:

; 2144 :         
; 2145 :         for(i = 0; i < m_bVoiceCount; i++)

  00063	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0006a	eb 09		 jmp	 SHORT $L38709
$L38710:
  0006c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0006f	83 c0 01	 add	 eax, 1
  00072	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L38709:
  00075	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	0f b6 51 64	 movzx	 edx, BYTE PTR [ecx+100]
  0007c	39 55 fc	 cmp	 DWORD PTR _i$[ebp], edx
  0007f	73 45		 jae	 SHORT $L38702

; 2146 :         {
; 2147 :             MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  00081	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00084	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	0f b7 54 41 0c	 movzx	 edx, WORD PTR [ecx+eax*2+12]
  0008c	b8 f8 02 00 00	 mov	 eax, 760		; 000002f8H
  00091	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 2148 :             MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));

  00097	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	e8 00 00 00 00	 call	 ?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::GetVoiceCfgFMT
  000a3	ba 04 03 00 00	 mov	 edx, 772		; 00000304H
  000a8	89 82 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], eax

; 2149 :             MCPX_VOICE_WRITE(VoiceRelease, m_ahVoices[i]);

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000b1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	0f b7 54 41 0c	 movzx	 edx, WORD PTR [ecx+eax*2+12]
  000b9	b8 2c 01 00 00	 mov	 eax, 300		; 0000012cH
  000be	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 2150 :         }

  000c4	eb a6		 jmp	 SHORT $L38710
$L38702:

; 2151 :     }
; 2152 : 
; 2153 :     DPF_LEAVE_VOID();
; 2154 : }

  000c6	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000c9	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
?ReleaseVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ ENDP	; DirectSound::CMcpxVoiceClient::ReleaseVoice
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?WaitForVoiceOff@CMcpxVoiceClient@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -4
?WaitForVoiceOff@CMcpxVoiceClient@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxVoiceClient::WaitForVoiceOff, COMDAT
; _this$ = ecx

; 2181 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2182 :     static BOOL             fExplained  = FALSE;
; 2183 :     
; 2184 :     DPF_ENTER();
; 2185 : 
; 2186 :     if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  0000e	83 e1 01	 and	 ecx, 1
  00011	85 c9		 test	 ecx, ecx
  00013	74 1a		 je	 SHORT $L38721
$L38726:

; 2187 :     {
; 2188 :         ASSERT(!(m_dwStatus & MCPX_VOICESTATUS_ACTIVE));
; 2189 : 
; 2190 : #ifdef DEBUG
; 2191 : 
; 2192 :         if(m_dwStatus & MCPX_VOICESTATUS_VOICEOFF)
; 2193 :         {
; 2194 :             if(!g_fDirectSoundDisableBusyWaitWarning)
; 2195 :             {
; 2196 :                 DPF_WARNING("Busy-waiting for the voice to turn off");
; 2197 : 
; 2198 :                 if(!fExplained)
; 2199 :                 {
; 2200 :                     DPF_WARNING("This warning is being generated because you've called a method that requires");
; 2201 :                     DPF_WARNING("a hardware voice to be stopped.  Stopping a voice is an asynchronous");
; 2202 :                     DPF_WARNING("operation, so any function that requires the voice to be stopped must block");
; 2203 :                     DPF_WARNING("until it is.  To see an example of this, call IDirectSoundBuffer::Stop and");
; 2204 :                     DPF_WARNING("immediately follow it with a call to IDirectSoundBuffer::GetStatus.  Chances");
; 2205 :                     DPF_WARNING("are, you'll see that DSBSTATUS_PLAYING is still set.  For a list of methods");
; 2206 :                     DPF_WARNING("that can potentially block in this method, consult the documentation.  To");
; 2207 :                     DPF_WARNING("query the playing status of a buffer or stream, call the GetStatus method on");
; 2208 :                     DPF_WARNING("the object you wish to check.  To disable this warning, set the global");
; 2209 :                     DPF_WARNING("variable \"g_fDirectSoundDisableBusyWaitWarning\" to TRUE.");
; 2210 : 
; 2211 :                     fExplained = TRUE;
; 2212 :                 }
; 2213 :             }
; 2214 : 
; 2215 : #endif // DEBUG
; 2216 :         
; 2217 :             while(m_dwStatus & MCPX_VOICESTATUS_VOICEOFF)

  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  0001c	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00021	85 c0		 test	 eax, eax
  00023	74 0a		 je	 SHORT $L38721

; 2218 :             {
; 2219 :                 CheckStuckVoice();

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?CheckStuckVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ ; DirectSound::CMcpxVoiceClient::CheckStuckVoice

; 2220 :             }

  0002d	eb e6		 jmp	 SHORT $L38726
$L38721:

; 2221 : 
; 2222 : #ifdef DEBUG
; 2223 : 
; 2224 :         }
; 2225 : 
; 2226 : #endif // DEBUG
; 2227 : 
; 2228 :     }
; 2229 : 
; 2230 :     DPF_LEAVE_VOID();
; 2231 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?WaitForVoiceOff@CMcpxVoiceClient@DirectSound@@IAEXXZ ENDP ; DirectSound::CMcpxVoiceClient::WaitForVoiceOff
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?CheckStuckVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ
DSOUND	SEGMENT
tv87 = -20
_this$ = -12
_rtCurrent$ = -8
?CheckStuckVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxVoiceClient::CheckStuckVoice, COMDAT
; _this$ = ecx

; 2258 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2259 : 
; 2260 : #ifdef MCPX_DEBUG_STUCK_VOICES
; 2261 : 
; 2262 :     static const REFERENCE_TIME rtTimeout   = 5000i64 * 10000i64;  // 5000ms
; 2263 : 
; 2264 : #else // MCPX_DEBUG_STUCK_VOICES
; 2265 : 
; 2266 :     static const REFERENCE_TIME rtTimeout   = 500i64 * 10000i64;   // 500ms
; 2267 : 
; 2268 : #endif // MCPX_DEBUG_STUCK_VOICES
; 2269 : 
; 2270 :     REFERENCE_TIME              rtCurrent;
; 2271 :     
; 2272 :     DPF_ENTER();
; 2273 : 
; 2274 :     if((m_dwStatus & MCPX_VOICESTATUS_VOICEOFFMASK) == MCPX_VOICESTATUS_VOICEOFFMASK)

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00010	81 e1 01 80 00
	00		 and	 ecx, 32769		; 00008001H
  00016	81 f9 01 80 00
	00		 cmp	 ecx, 32769		; 00008001H
  0001c	75 44		 jne	 SHORT $L38735

; 2275 :     {
; 2276 :         //
; 2277 :         // We're still waiting for the voice to turn off.  Check to see how
; 2278 :         // long it's been since we called VoiceOff.
; 2279 :         //
; 2280 :         
; 2281 :         ASSERT(m_rtVoiceOff > 0);
; 2282 :         ASSERT(!m_pMcpxApu->m_dwVoiceMapLock);
; 2283 :         
; 2284 :         KeQuerySystemTime((PLARGE_INTEGER)&rtCurrent);

  0001e	8d 55 f8	 lea	 edx, DWORD PTR _rtCurrent$[ebp]
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQuerySystemTime@4

; 2285 : 
; 2286 :         if(rtCurrent >= m_rtVoiceOff + rtTimeout)

  00028	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00031	81 c1 80 f0 fa
	02		 add	 ecx, 50000000		; 02faf080H
  00037	8b 90 84 00 00
	00		 mov	 edx, DWORD PTR [eax+132]
  0003d	83 d2 00	 adc	 edx, 0
  00040	89 4d ec	 mov	 DWORD PTR tv87[ebp], ecx
  00043	89 55 f0	 mov	 DWORD PTR tv87[ebp+4], edx
  00046	8b 45 fc	 mov	 eax, DWORD PTR _rtCurrent$[ebp+4]
  00049	3b 45 f0	 cmp	 eax, DWORD PTR tv87[ebp+4]
  0004c	7c 12		 jl	 SHORT $L38737
  0004e	7f 08		 jg	 SHORT $L42297
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _rtCurrent$[ebp]
  00053	3b 4d ec	 cmp	 ecx, DWORD PTR tv87[ebp]
  00056	72 08		 jb	 SHORT $L38737
$L42297:

; 2287 :         {
; 2288 :             DPF_WARNING("Voice %x (%x) appears to be stuck.  Forcing it to turn off...", this, m_ahVoices[0]);
; 2289 : 
; 2290 :             RemoveStuckVoice();

  00058	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?RemoveStuckVoice@CMcpxVoiceClient@DirectSound@@AAEXXZ ; DirectSound::CMcpxVoiceClient::RemoveStuckVoice
$L38737:

; 2291 :         }
; 2292 :     }
; 2293 :     else

  00060	eb 0d		 jmp	 SHORT $L38731
$L38735:

; 2294 :     {
; 2295 :         //
; 2296 :         // The voice is turned off.  Make sure the CHECKSTUCK deferred
; 2297 :         // command is removed from the queue.
; 2298 :         //
; 2299 :         
; 2300 :         RemoveDeferredCommand(MCPX_DEFERREDCMD_VOICE_CHECKSTUCK);

  00062	6a 00		 push	 0
  00064	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00067	8b 02		 mov	 eax, DWORD PTR [edx]
  00069	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	ff 50 1c	 call	 DWORD PTR [eax+28]
$L38731:

; 2301 :     }
; 2302 : 
; 2303 :     DPF_LEAVE_VOID();
; 2304 : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?CheckStuckVoice@CMcpxVoiceClient@DirectSound@@IAEXXZ ENDP ; DirectSound::CMcpxVoiceClient::CheckStuckVoice
DSOUND	ENDS
PUBLIC	?PauseVoice@CMcpxVoiceClient@DirectSound@@IAEXK@Z ; DirectSound::CMcpxVoiceClient::PauseVoice
; Function compile flags: /Odt
;	COMDAT ?PauseVoice@CMcpxVoiceClient@DirectSound@@IAEXK@Z
DSOUND	SEGMENT
_this$ = -20
___AutoIrql$ = -16
_dwRegisterValue$ = -8
_i$ = -4
_dwStatus$ = 8
?PauseVoice@CMcpxVoiceClient@DirectSound@@IAEXK@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::PauseVoice, COMDAT
; _this$ = ecx

; 2330 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2331 :     DWORD                   dwRegisterValue;
; 2332 :     DWORD                   i;
; 2333 :     
; 2334 :     DPF_ENTER();
; 2335 :     AutoIrql();

  00009	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 2336 : 
; 2337 :     dwStatus &= MCPX_VOICESTATUS_ALLPAUSEDMASK;

  00011	8b 45 08	 mov	 eax, DWORD PTR _dwStatus$[ebp]
  00014	25 04 04 00 00	 and	 eax, 1028		; 00000404H
  00019	89 45 08	 mov	 DWORD PTR _dwStatus$[ebp], eax

; 2338 : 
; 2339 :     //
; 2340 :     // Pause or resume the voice
; 2341 :     //
; 2342 : 
; 2343 :     if(MAKEBOOL(dwStatus) != MAKEBOOL(m_dwStatus & MCPX_VOICESTATUS_ALLPAUSEDMASK))

  0001c	33 c9		 xor	 ecx, ecx
  0001e	83 7d 08 00	 cmp	 DWORD PTR _dwStatus$[ebp], 0
  00022	0f 95 c1	 setne	 cl
  00025	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00028	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  0002c	25 04 04 00 00	 and	 eax, 1028		; 00000404H
  00031	f7 d8		 neg	 eax
  00033	1b c0		 sbb	 eax, eax
  00035	f7 d8		 neg	 eax
  00037	3b c8		 cmp	 ecx, eax
  00039	0f 84 87 00 00
	00		 je	 $L38746

; 2344 :     {
; 2345 :         if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)

  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00046	83 e2 03	 and	 edx, 3
  00049	83 fa 03	 cmp	 edx, 3
  0004c	75 78		 jne	 SHORT $L38746

; 2346 :         {
; 2347 :             if(dwStatus)

  0004e	83 7d 08 00	 cmp	 DWORD PTR _dwStatus$[ebp], 0
  00052	74 09		 je	 SHORT $L38748

; 2348 :             {
; 2349 :                 dwRegisterValue = MCPX_MAKE_REG_VALUE(NV1BA0_PIO_VOICE_PAUSE_ACTION_STOP, NV1BA0_PIO_VOICE_PAUSE_ACTION);

  00054	c7 45 f8 00 00
	04 00		 mov	 DWORD PTR _dwRegisterValue$[ebp], 262144 ; 00040000H

; 2350 :             }
; 2351 :             else

  0005b	eb 07		 jmp	 SHORT $L38753
$L38748:

; 2352 :             {
; 2353 :                 dwRegisterValue = MCPX_MAKE_REG_VALUE(NV1BA0_PIO_VOICE_PAUSE_ACTION_RESUME, NV1BA0_PIO_VOICE_PAUSE_ACTION);

  0005d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwRegisterValue$[ebp], 0
$L38753:

; 2354 :             }
; 2355 : 
; 2356 :             MCPX_CHECK_VOICE_FIFO(1 * m_bVoiceCount);

  00064	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00069	8b 88 00 00 82
	fe		 mov	 ecx, DWORD PTR [eax-25034752]
  0006f	c1 e9 02	 shr	 ecx, 2
  00072	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00075	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  00079	3b c8		 cmp	 ecx, eax
  0007b	73 02		 jae	 SHORT $L38754
  0007d	eb e5		 jmp	 SHORT $L38753
$L38754:

; 2357 :             
; 2358 :             for(i = 0; i < m_bVoiceCount; i++)

  0007f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00086	eb 09		 jmp	 SHORT $L38757
$L38758:
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0008b	83 c1 01	 add	 ecx, 1
  0008e	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L38757:
  00091	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00094	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  00098	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  0009b	73 29		 jae	 SHORT $L38746

; 2359 :             {
; 2360 :                 MCPX_VOICE_WRITE(VoicePause, MCPX_SET_REG_VALUE(dwRegisterValue, m_ahVoices[i], NV1BA0_PIO_VOICE_PAUSE_HANDLE));

  0009d	8b 4d f8	 mov	 ecx, DWORD PTR _dwRegisterValue$[ebp]
  000a0	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  000a6	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000a9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	0f b7 54 50 0c	 movzx	 edx, WORD PTR [eax+edx*2+12]
  000b1	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000b7	0b ca		 or	 ecx, edx
  000b9	b8 40 01 00 00	 mov	 eax, 320		; 00000140H
  000be	89 88 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], ecx

; 2361 :             }

  000c4	eb c2		 jmp	 SHORT $L38758
$L38746:

; 2362 :         }
; 2363 : 
; 2364 :         DPF_INFO("Voice %x (%x) pause state going from %x to %x", this, m_ahVoices[0], m_dwStatus & MCPX_VOICESTATUS_ALLPAUSEDMASK, dwStatus);
; 2365 :     }
; 2366 : 
; 2367 :     //
; 2368 :     // Update the status
; 2369 :     //
; 2370 : 
; 2371 :     and(&m_dwStatus, ~MCPX_VOICESTATUS_ALLPAUSEDMASK);

  000c6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	83 c1 12	 add	 ecx, 18			; 00000012H
  000cc	ba fb fb 00 00	 mov	 edx, 64507		; 0000fbfbH
  000d1	e8 00 00 00 00	 call	 ?and@@YIXPCGG@Z		; and

; 2372 :     or(&m_dwStatus, (WORD)dwStatus);

  000d6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	83 c1 12	 add	 ecx, 18			; 00000012H
  000dc	8b 55 08	 mov	 edx, DWORD PTR _dwStatus$[ebp]
  000df	e8 00 00 00 00	 call	 ?or@@YIXPCGG@Z		; or

; 2373 : 
; 2374 :     DPF_LEAVE_VOID();
; 2375 : }

  000e4	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000e7	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c2 04 00	 ret	 4
?PauseVoice@CMcpxVoiceClient@DirectSound@@IAEXK@Z ENDP	; DirectSound::CMcpxVoiceClient::PauseVoice
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetLFO@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSLFODESC@@@Z
DSOUND	SEGMENT
_this$ = -20
$T42304 = -16
___AutoIrql$ = -12
_i$ = -4
_pLfo$ = 8
?SetLFO@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSLFODESC@@@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::SetLFO, COMDAT
; _this$ = ecx

; 2726 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2727 :     DWORD                   i;
; 2728 :     
; 2729 :     DPF_ENTER();
; 2730 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 2731 : 
; 2732 :     //
; 2733 :     // Recalculate register values
; 2734 :     //
; 2735 :     
; 2736 :     if(DSLFO_MULTI == pLfo->dwLFO)

  00011	8b 45 08	 mov	 eax, DWORD PTR _pLfo$[ebp]
  00014	83 38 00	 cmp	 DWORD PTR [eax], 0
  00017	0f 85 d4 00 00
	00		 jne	 $L38770

; 2737 :     {
; 2738 :         m_RegCache.CfgMISC = MCPX_SET_REG_VALUE(m_RegCache.CfgMISC, MAKEBOOL(pLfo->dwDelay), NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOA_DELAYMODE);

  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00023	81 e2 ff bf ff
	ff		 and	 edx, -16385		; ffffbfffH
  00029	8b 45 08	 mov	 eax, DWORD PTR _pLfo$[ebp]
  0002c	33 c9		 xor	 ecx, ecx
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	0f 95 c1	 setne	 cl
  00035	83 e1 01	 and	 ecx, 1
  00038	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
  0003b	0b d1		 or	 edx, ecx
  0003d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00040	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 2739 :         
; 2740 :         m_RegCache.CfgLFODLY = MCPX_SET_REG_VALUE(m_RegCache.CfgLFODLY, pLfo->dwDelay, NV1BA0_PIO_SET_VOICE_PAR_LFODLY_LFOADLY);

  00043	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00049	81 e2 00 80 ff
	ff		 and	 edx, -32768		; ffff8000H
  0004f	8b 45 08	 mov	 eax, DWORD PTR _pLfo$[ebp]
  00052	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00055	81 e1 ff 7f 00
	00		 and	 ecx, 32767		; 00007fffH
  0005b	0b d1		 or	 edx, ecx
  0005d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00060	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 2741 :         
; 2742 :         m_RegCache.LFOENV = MCPX_SET_REG_VALUE(m_RegCache.LFOENV, pLfo->dwDelta, NV1BA0_PIO_SET_VOICE_LFO_ENV_LFOADLT);

  00063	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00069	81 e2 ff 0f c0
	ff		 and	 edx, -4190209		; ffc00fffH
  0006f	8b 45 08	 mov	 eax, DWORD PTR _pLfo$[ebp]
  00072	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00075	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0007b	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  0007e	0b d1		 or	 edx, ecx
  00080	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00083	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 2743 :         
; 2744 :         m_RegCache.LFOMOD = MCPX_SET_REG_VALUE(m_RegCache.LFOMOD, pLfo->lAmplitudeModulation, NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOAAM);

  00086	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0008c	81 e2 00 ff ff
	ff		 and	 edx, -256		; ffffff00H
  00092	8b 45 08	 mov	 eax, DWORD PTR _pLfo$[ebp]
  00095	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00098	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0009e	0b d1		 or	 edx, ecx
  000a0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 2745 :         m_RegCache.LFOMOD = MCPX_SET_REG_VALUE(m_RegCache.LFOMOD, pLfo->lPitchModulation, NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOAFM);

  000a6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000ac	81 e2 ff 00 ff
	ff		 and	 edx, -65281		; ffff00ffH
  000b2	8b 45 08	 mov	 eax, DWORD PTR _pLfo$[ebp]
  000b5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000b8	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000be	c1 e1 08	 shl	 ecx, 8
  000c1	0b d1		 or	 edx, ecx
  000c3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c6	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 2746 :         m_RegCache.LFOMOD = MCPX_SET_REG_VALUE(m_RegCache.LFOMOD, pLfo->lFilterCutOffRange, NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOAFC);

  000c9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000cf	81 e2 ff ff 00
	ff		 and	 edx, -16711681		; ff00ffffH
  000d5	8b 45 08	 mov	 eax, DWORD PTR _pLfo$[ebp]
  000d8	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000db	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000e1	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000e4	0b d1		 or	 edx, ecx
  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 2747 :     }
; 2748 :     else if(DSLFO_PITCH == pLfo->dwLFO)

  000ec	e9 97 00 00 00	 jmp	 $L38777
$L38770:
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR _pLfo$[ebp]
  000f4	83 39 01	 cmp	 DWORD PTR [ecx], 1
  000f7	0f 85 8b 00 00
	00		 jne	 $L38777

; 2749 :     {
; 2750 :         m_RegCache.CfgMISC = MCPX_SET_REG_VALUE(m_RegCache.CfgMISC, MAKEBOOL(pLfo->dwDelay), NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOF_DELAYMODE);

  000fd	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00100	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00103	25 ff 7f ff ff	 and	 eax, -32769		; ffff7fffH
  00108	8b 4d 08	 mov	 ecx, DWORD PTR _pLfo$[ebp]
  0010b	33 d2		 xor	 edx, edx
  0010d	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00111	0f 95 c2	 setne	 dl
  00114	83 e2 01	 and	 edx, 1
  00117	c1 e2 0f	 shl	 edx, 15			; 0000000fH
  0011a	0b c2		 or	 eax, edx
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 2751 :         
; 2752 :         m_RegCache.CfgLFODLY = MCPX_SET_REG_VALUE(m_RegCache.CfgLFODLY, pLfo->dwDelay, NV1BA0_PIO_SET_VOICE_PAR_LFODLY_LFOFDLY);

  00122	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00125	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00128	25 ff ff 00 80	 and	 eax, -2147418113	; 8000ffffH
  0012d	8b 4d 08	 mov	 ecx, DWORD PTR _pLfo$[ebp]
  00130	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00133	81 e2 ff 7f 00
	00		 and	 edx, 32767		; 00007fffH
  00139	c1 e2 10	 shl	 edx, 16			; 00000010H
  0013c	0b c2		 or	 eax, edx
  0013e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 2753 :         
; 2754 :         m_RegCache.LFOENV = MCPX_SET_REG_VALUE(m_RegCache.LFOENV, pLfo->dwDelta, NV1BA0_PIO_SET_VOICE_LFO_ENV_LFOFDLT);

  00144	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00147	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0014a	25 ff ff 3f 00	 and	 eax, 4194303		; 003fffffH
  0014f	8b 4d 08	 mov	 ecx, DWORD PTR _pLfo$[ebp]
  00152	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00155	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  0015b	c1 e2 16	 shl	 edx, 22			; 00000016H
  0015e	0b c2		 or	 eax, edx
  00160	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00163	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 2755 :         
; 2756 :         m_RegCache.LFOMOD = MCPX_SET_REG_VALUE(m_RegCache.LFOMOD, pLfo->lPitchModulation, NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOFFM);

  00166	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00169	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0016c	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00171	8b 4d 08	 mov	 ecx, DWORD PTR _pLfo$[ebp]
  00174	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00177	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0017d	c1 e2 18	 shl	 edx, 24			; 00000018H
  00180	0b c2		 or	 eax, edx
  00182	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00185	89 41 34	 mov	 DWORD PTR [ecx+52], eax
$L38777:

; 2757 :     }
; 2758 :     else
; 2759 :     {
; 2760 :         ASSERTMSG("Invalid LFO identifier");
; 2761 :     }
; 2762 : 
; 2763 :     //
; 2764 :     // Apply changes
; 2765 :     //
; 2766 :     
; 2767 :     if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)

  00188	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0018b	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  0018f	83 e0 01	 and	 eax, 1
  00192	85 c0		 test	 eax, eax
  00194	0f 84 b9 00 00
	00		 je	 $L38784
$L38786:

; 2768 :     {
; 2769 :         MCPX_CHECK_VOICE_FIFO(7 * m_bVoiceCount);

  0019a	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0019f	8b 91 00 00 82
	fe		 mov	 edx, DWORD PTR [ecx-25034752]
  001a5	c1 ea 02	 shr	 edx, 2
  001a8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001ab	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  001af	6b c9 07	 imul	 ecx, 7
  001b2	3b d1		 cmp	 edx, ecx
  001b4	73 02		 jae	 SHORT $L38787
  001b6	eb e2		 jmp	 SHORT $L38786
$L38787:

; 2770 :         
; 2771 :         for(i = 0; i < m_bVoiceCount; i++)

  001b8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001bf	eb 09		 jmp	 SHORT $L38790
$L38791:
  001c1	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001c4	83 c2 01	 add	 edx, 1
  001c7	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L38790:
  001ca	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001cd	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  001d1	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  001d4	73 7d		 jae	 SHORT $L38784

; 2772 :         {
; 2773 :             MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  001d6	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001d9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001dc	0f b7 4c 50 0c	 movzx	 ecx, WORD PTR [eax+edx*2+12]
  001e1	ba f8 02 00 00	 mov	 edx, 760		; 000002f8H
  001e6	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 2774 :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);

  001ec	b8 fc 02 00 00	 mov	 eax, 764		; 000002fcH
  001f1	c7 80 00 00 82
	fe 01 00 00 00	 mov	 DWORD PTR [eax-25034752], 1

; 2775 :             MCPX_VOICE_WRITE(SetVoiceCfgMISC, m_RegCache.CfgMISC);

  001fb	b9 18 03 00 00	 mov	 ecx, 792		; 00000318H
  00200	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00203	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00206	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 2776 :             MCPX_VOICE_WRITE(SetVoiceCfgLFODLY, m_RegCache.CfgLFODLY);

  0020c	b9 50 03 00 00	 mov	 ecx, 848		; 00000350H
  00211	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00214	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00217	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 2777 :             MCPX_VOICE_WRITE(SetVoiceLFOENV, m_RegCache.LFOENV);

  0021d	b9 6c 03 00 00	 mov	 ecx, 876		; 0000036cH
  00222	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00225	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00228	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 2778 :             MCPX_VOICE_WRITE(SetVoiceLFOMOD, m_RegCache.LFOMOD);

  0022e	b9 70 03 00 00	 mov	 ecx, 880		; 00000370H
  00233	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00236	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00239	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 2779 :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);

  0023f	b9 fc 02 00 00	 mov	 ecx, 764		; 000002fcH
  00244	c7 81 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [ecx-25034752], 0

; 2780 :         }

  0024e	e9 6e ff ff ff	 jmp	 $L38791
$L38784:

; 2781 :     }
; 2782 : 
; 2783 :     DPF_LEAVE_HRESULT(DS_OK);
; 2784 : 
; 2785 :     return DS_OK;

  00253	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T42304[ebp], 0
  0025a	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0025d	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00262	8b 45 f0	 mov	 eax, DWORD PTR $T42304[ebp]

; 2786 : }

  00265	8b e5		 mov	 esp, ebp
  00267	5d		 pop	 ebp
  00268	c2 04 00	 ret	 4
?SetLFO@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSLFODESC@@@Z ENDP ; DirectSound::CMcpxVoiceClient::SetLFO
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetEG@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSENVELOPEDESC@@@Z
DSOUND	SEGMENT
_this$ = -20
$T42308 = -16
___AutoIrql$ = -12
_i$ = -4
_pEnv$ = 8
?SetEG@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSENVELOPEDESC@@@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::SetEG, COMDAT
; _this$ = ecx

; 2812 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2813 :     DWORD                   i;
; 2814 :     
; 2815 :     DPF_ENTER();
; 2816 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 2817 : 
; 2818 :     //
; 2819 :     // Recalculate register values
; 2820 :     //
; 2821 :     
; 2822 :     if(DSEG_MULTI == pEnv->dwEG)

  00011	8b 45 08	 mov	 eax, DWORD PTR _pEnv$[ebp]
  00014	83 38 00	 cmp	 DWORD PTR [eax], 0
  00017	0f 85 34 01 00
	00		 jne	 $L38815

; 2823 :     {
; 2824 :         m_RegCache.VoiceOn = MCPX_SET_REG_VALUE(m_RegCache.VoiceOn, pEnv->dwMode, NV1BA0_PIO_VOICE_ON_ENVF);

  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00023	81 e2 ff ff ff
	f0		 and	 edx, -251658241		; f0ffffffH
  00029	8b 45 08	 mov	 eax, DWORD PTR _pEnv$[ebp]
  0002c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002f	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00032	c1 e1 18	 shl	 ecx, 24			; 00000018H
  00035	0b d1		 or	 edx, ecx
  00037	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	89 50 40	 mov	 DWORD PTR [eax+64], edx

; 2825 :         
; 2826 :         m_RegCache.CfgMISC = MCPX_SET_REG_VALUE(m_RegCache.CfgMISC, pEnv->dwRelease, NV1BA0_PIO_SET_VOICE_CFG_MISC_EF_RELEASERATE);

  0003d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00043	81 e2 00 f0 ff
	ff		 and	 edx, -4096		; fffff000H
  00049	8b 45 08	 mov	 eax, DWORD PTR _pEnv$[ebp]
  0004c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0004f	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  00055	0b d1		 or	 edx, ecx
  00057	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 2827 :         
; 2828 :         m_RegCache.CfgENV0 = MCPX_SET_REG_VALUE(m_RegCache.CfgENV0, pEnv->lPitchScale, NV1BA0_PIO_SET_VOICE_CFG_ENV0_EF_PITCHSCALE);

  0005d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00063	81 e2 ff ff ff
	00		 and	 edx, 16777215		; 00ffffffH
  00069	8b 45 08	 mov	 eax, DWORD PTR _pEnv$[ebp]
  0006c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0006f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00075	c1 e1 18	 shl	 ecx, 24			; 00000018H
  00078	0b d1		 or	 edx, ecx
  0007a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 2829 :         
; 2830 :         m_RegCache.CfgENV1 = MCPX_SET_REG_VALUE(m_RegCache.CfgENV1, pEnv->dwAttack, NV1BA0_PIO_SET_VOICE_CFG_ENV1_EF_ATTACKRATE);

  00080	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00086	81 e2 00 f0 ff
	ff		 and	 edx, -4096		; fffff000H
  0008c	8b 45 08	 mov	 eax, DWORD PTR _pEnv$[ebp]
  0008f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00092	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  00098	0b d1		 or	 edx, ecx
  0009a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 2831 :         m_RegCache.CfgENV1 = MCPX_SET_REG_VALUE(m_RegCache.CfgENV1, pEnv->dwDelay, NV1BA0_PIO_SET_VOICE_CFG_ENV1_EF_DELAYTIME);

  000a0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000a6	81 e2 ff 0f 00
	ff		 and	 edx, -16773121		; ff000fffH
  000ac	8b 45 08	 mov	 eax, DWORD PTR _pEnv$[ebp]
  000af	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b2	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  000b8	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  000bb	0b d1		 or	 edx, ecx
  000bd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 2832 :         m_RegCache.CfgENV1 = MCPX_SET_REG_VALUE(m_RegCache.CfgENV1, pEnv->lFilterCutOff, NV1BA0_PIO_SET_VOICE_CFG_ENV1_EF_FCSCALE);

  000c3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000c9	81 e2 ff ff ff
	00		 and	 edx, 16777215		; 00ffffffH
  000cf	8b 45 08	 mov	 eax, DWORD PTR _pEnv$[ebp]
  000d2	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000d5	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000db	c1 e1 18	 shl	 ecx, 24			; 00000018H
  000de	0b d1		 or	 edx, ecx
  000e0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 2833 :         
; 2834 :         m_RegCache.CfgENVF = MCPX_SET_REG_VALUE(m_RegCache.CfgENVF, pEnv->dwDecay, NV1BA0_PIO_SET_VOICE_CFG_ENVF_EF_DECAYRATE);

  000e6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000ec	81 e2 00 f0 ff
	ff		 and	 edx, -4096		; fffff000H
  000f2	8b 45 08	 mov	 eax, DWORD PTR _pEnv$[ebp]
  000f5	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000f8	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  000fe	0b d1		 or	 edx, ecx
  00100	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00103	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 2835 :         m_RegCache.CfgENVF = MCPX_SET_REG_VALUE(m_RegCache.CfgENVF, pEnv->dwHold, NV1BA0_PIO_SET_VOICE_CFG_ENVF_EF_HOLDTIME);

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0010c	81 e2 ff 0f 00
	ff		 and	 edx, -16773121		; ff000fffH
  00112	8b 45 08	 mov	 eax, DWORD PTR _pEnv$[ebp]
  00115	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00118	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  0011e	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  00121	0b d1		 or	 edx, ecx
  00123	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00126	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 2836 :         m_RegCache.CfgENVF = MCPX_SET_REG_VALUE(m_RegCache.CfgENVF, pEnv->dwSustain, NV1BA0_PIO_SET_VOICE_CFG_ENVF_EF_SUSTAINLEVEL);

  00129	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012c	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0012f	81 e2 ff ff ff
	00		 and	 edx, 16777215		; 00ffffffH
  00135	8b 45 08	 mov	 eax, DWORD PTR _pEnv$[ebp]
  00138	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0013b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00141	c1 e1 18	 shl	 ecx, 24			; 00000018H
  00144	0b d1		 or	 edx, ecx
  00146	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00149	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 2837 :     }
; 2838 :     else if(DSEG_AMPLITUDE == pEnv->dwEG)

  0014c	e9 ee 00 00 00	 jmp	 $L38825
$L38815:
  00151	8b 4d 08	 mov	 ecx, DWORD PTR _pEnv$[ebp]
  00154	83 39 01	 cmp	 DWORD PTR [ecx], 1
  00157	0f 85 e2 00 00
	00		 jne	 $L38825

; 2839 :     {
; 2840 :         m_RegCache.VoiceOn = MCPX_SET_REG_VALUE(m_RegCache.VoiceOn, pEnv->dwMode, NV1BA0_PIO_VOICE_ON_ENVA);

  0015d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00160	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00163	25 ff ff ff 0f	 and	 eax, 268435455		; 0fffffffH
  00168	8b 4d 08	 mov	 ecx, DWORD PTR _pEnv$[ebp]
  0016b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0016e	83 e2 0f	 and	 edx, 15			; 0000000fH
  00171	c1 e2 1c	 shl	 edx, 28			; 0000001cH
  00174	0b c2		 or	 eax, edx
  00176	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00179	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 2841 : 
; 2842 :         m_RegCache.LFOENV = MCPX_SET_REG_VALUE(m_RegCache.LFOENV, pEnv->dwRelease, NV1BA0_PIO_SET_VOICE_LFO_ENV_EA_RELEASERATE);

  0017c	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0017f	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00182	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  00187	8b 4d 08	 mov	 ecx, DWORD PTR _pEnv$[ebp]
  0018a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0018d	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  00193	0b c2		 or	 eax, edx
  00195	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00198	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 2843 : 
; 2844 :         m_RegCache.CfgENV0 = MCPX_SET_REG_VALUE(m_RegCache.CfgENV0, pEnv->dwAttack, NV1BA0_PIO_SET_VOICE_CFG_ENV0_EA_ATTACKRATE);

  0019b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0019e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  001a1	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  001a6	8b 4d 08	 mov	 ecx, DWORD PTR _pEnv$[ebp]
  001a9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001ac	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  001b2	0b c2		 or	 eax, edx
  001b4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001b7	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 2845 :         m_RegCache.CfgENV0 = MCPX_SET_REG_VALUE(m_RegCache.CfgENV0, pEnv->dwDelay, NV1BA0_PIO_SET_VOICE_CFG_ENV0_EA_DELAYTIME);

  001ba	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  001bd	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  001c0	25 ff 0f 00 ff	 and	 eax, -16773121		; ff000fffH
  001c5	8b 4d 08	 mov	 ecx, DWORD PTR _pEnv$[ebp]
  001c8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001cb	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  001d1	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  001d4	0b c2		 or	 eax, edx
  001d6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001d9	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 2846 : 
; 2847 :         m_RegCache.CfgENVA = MCPX_SET_REG_VALUE(m_RegCache.CfgENVA, pEnv->dwDecay, NV1BA0_PIO_SET_VOICE_CFG_ENVA_EA_DECAYRATE);

  001dc	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  001df	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  001e2	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  001e7	8b 4d 08	 mov	 ecx, DWORD PTR _pEnv$[ebp]
  001ea	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001ed	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  001f3	0b c2		 or	 eax, edx
  001f5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001f8	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 2848 :         m_RegCache.CfgENVA = MCPX_SET_REG_VALUE(m_RegCache.CfgENVA, pEnv->dwHold, NV1BA0_PIO_SET_VOICE_CFG_ENVA_EA_HOLDTIME);

  001fb	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  001fe	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00201	25 ff 0f 00 ff	 and	 eax, -16773121		; ff000fffH
  00206	8b 4d 08	 mov	 ecx, DWORD PTR _pEnv$[ebp]
  00209	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0020c	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  00212	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  00215	0b c2		 or	 eax, edx
  00217	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0021a	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 2849 :         m_RegCache.CfgENVA = MCPX_SET_REG_VALUE(m_RegCache.CfgENVA, pEnv->dwSustain, NV1BA0_PIO_SET_VOICE_CFG_ENVA_EA_SUSTAINLEVEL);

  0021d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00220	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00223	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00228	8b 4d 08	 mov	 ecx, DWORD PTR _pEnv$[ebp]
  0022b	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0022e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00234	c1 e2 18	 shl	 edx, 24			; 00000018H
  00237	0b c2		 or	 eax, edx
  00239	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0023c	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$L38825:

; 2850 :     }
; 2851 :     else
; 2852 :     {
; 2853 :         ASSERTMSG("Invalid EG identifier");
; 2854 :     }
; 2855 : 
; 2856 :     //
; 2857 :     // Apply changes
; 2858 :     //
; 2859 :     
; 2860 :     if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)

  0023f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00242	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  00246	83 e0 01	 and	 eax, 1
  00249	85 c0		 test	 eax, eax
  0024b	0f 84 df 00 00
	00		 je	 $L38835
$L38837:

; 2861 :     {
; 2862 :         MCPX_CHECK_VOICE_FIFO(9 * m_bVoiceCount);

  00251	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00256	8b 91 00 00 82
	fe		 mov	 edx, DWORD PTR [ecx-25034752]
  0025c	c1 ea 02	 shr	 edx, 2
  0025f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00262	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  00266	6b c9 09	 imul	 ecx, 9
  00269	3b d1		 cmp	 edx, ecx
  0026b	73 02		 jae	 SHORT $L38838
  0026d	eb e2		 jmp	 SHORT $L38837
$L38838:

; 2863 :         
; 2864 :         for(i = 0; i < m_bVoiceCount; i++)

  0026f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00276	eb 09		 jmp	 SHORT $L38841
$L38842:
  00278	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0027b	83 c2 01	 add	 edx, 1
  0027e	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L38841:
  00281	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00284	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  00288	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  0028b	0f 83 9f 00 00
	00		 jae	 $L38835

; 2865 :         {
; 2866 :             MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  00291	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00294	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00297	0f b7 4c 50 0c	 movzx	 ecx, WORD PTR [eax+edx*2+12]
  0029c	ba f8 02 00 00	 mov	 edx, 760		; 000002f8H
  002a1	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 2867 :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);

  002a7	b8 fc 02 00 00	 mov	 eax, 764		; 000002fcH
  002ac	c7 80 00 00 82
	fe 01 00 00 00	 mov	 DWORD PTR [eax-25034752], 1

; 2868 :             MCPX_VOICE_WRITE(SetVoiceCfgMISC, m_RegCache.CfgMISC);

  002b6	b9 18 03 00 00	 mov	 ecx, 792		; 00000318H
  002bb	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  002be	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  002c1	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 2869 :             MCPX_VOICE_WRITE(SetVoiceCfgENV0, m_RegCache.CfgENV0);

  002c7	b9 08 03 00 00	 mov	 ecx, 776		; 00000308H
  002cc	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  002cf	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  002d2	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 2870 :             MCPX_VOICE_WRITE(SetVoiceCfgENVA, m_RegCache.CfgENVA);

  002d8	b9 0c 03 00 00	 mov	 ecx, 780		; 0000030cH
  002dd	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  002e0	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  002e3	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 2871 :             MCPX_VOICE_WRITE(SetVoiceCfgENV1, m_RegCache.CfgENV1);

  002e9	b9 10 03 00 00	 mov	 ecx, 784		; 00000310H
  002ee	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  002f1	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  002f4	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 2872 :             MCPX_VOICE_WRITE(SetVoiceCfgENVF, m_RegCache.CfgENVF);

  002fa	b9 14 03 00 00	 mov	 ecx, 788		; 00000314H
  002ff	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00302	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00305	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 2873 :             MCPX_VOICE_WRITE(SetVoiceLFOENV, m_RegCache.LFOENV);

  0030b	b9 6c 03 00 00	 mov	 ecx, 876		; 0000036cH
  00310	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00313	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00316	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 2874 :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);

  0031c	b9 fc 02 00 00	 mov	 ecx, 764		; 000002fcH
  00321	c7 81 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [ecx-25034752], 0

; 2875 :         }

  0032b	e9 48 ff ff ff	 jmp	 $L38842
$L38835:

; 2876 :     }
; 2877 : 
; 2878 :     DPF_LEAVE_HRESULT(DS_OK);
; 2879 : 
; 2880 :     return DS_OK;

  00330	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T42308[ebp], 0
  00337	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0033a	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  0033f	8b 45 f0	 mov	 eax, DWORD PTR $T42308[ebp]

; 2881 : }

  00342	8b e5		 mov	 esp, ebp
  00344	5d		 pop	 ebp
  00345	c2 04 00	 ret	 4
?SetEG@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSENVELOPEDESC@@@Z ENDP ; DirectSound::CMcpxVoiceClient::SetEG
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetFilter@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSFILTERDESC@@@Z
DSOUND	SEGMENT
_this$ = -44
$T42312 = -40
___AutoIrql$ = -36
_i$ = -28
_Filter$ = -24
_pFilter$ = 8
?SetFilter@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSFILTERDESC@@@Z PROC NEAR ; DirectSound::CMcpxVoiceClient::SetFilter, COMDAT
; _this$ = ecx

; 2907 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 2908 :     DSFILTERDESC            Filter;
; 2909 :     DWORD                   i;
; 2910 :     
; 2911 :     DPF_ENTER();
; 2912 :     AutoIrql();

  00009	8d 4d dc	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 2913 : 
; 2914 :     //
; 2915 :     // Make a local copy of the filter data or create one based on current
; 2916 :     // register values.
; 2917 :     //
; 2918 : 
; 2919 :     if(pFilter)

  00011	83 7d 08 00	 cmp	 DWORD PTR _pFilter$[ebp], 0
  00015	74 14		 je	 SHORT $L38871

; 2920 :     {
; 2921 :         CopyMemory(&Filter, pFilter, sizeof(*pFilter));

  00017	6a 18		 push	 24			; 00000018H
  00019	8b 45 08	 mov	 eax, DWORD PTR _pFilter$[ebp]
  0001c	50		 push	 eax
  0001d	8d 4d e8	 lea	 ecx, DWORD PTR _Filter$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 _memcpy
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2922 :     }
; 2923 :     else

  00029	eb 5f		 jmp	 SHORT $L38872
$L38871:

; 2924 :     {
; 2925 :         Filter.dwMode = MCPX_GET_REG_VALUE(m_RegCache.CfgMISC, NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE);

  0002b	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00031	c1 e8 10	 shr	 eax, 16			; 00000010H
  00034	83 e0 03	 and	 eax, 3
  00037	89 45 e8	 mov	 DWORD PTR _Filter$[ebp], eax

; 2926 :         Filter.dwQCoefficient = MCPX_GET_REG_VALUE(m_RegCache.CfgMISC, NV1BA0_PIO_SET_VOICE_CFG_MISC_BPQ);

  0003a	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00040	c1 ea 12	 shr	 edx, 18			; 00000012H
  00043	83 e2 07	 and	 edx, 7
  00046	89 55 ec	 mov	 DWORD PTR _Filter$[ebp+4], edx

; 2927 : 
; 2928 :         Filter.adwCoefficients[0] = MCPX_GET_REG_VALUE(m_RegCache.TarFCA, NV1BA0_PIO_SET_VOICE_TAR_FCA_FC0);

  00049	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0004f	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00055	89 4d f0	 mov	 DWORD PTR _Filter$[ebp+8], ecx

; 2929 :         Filter.adwCoefficients[1] = MCPX_GET_REG_VALUE(m_RegCache.TarFCA, NV1BA0_PIO_SET_VOICE_TAR_FCA_FC1);

  00058	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0005e	c1 e8 10	 shr	 eax, 16			; 00000010H
  00061	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00066	89 45 f4	 mov	 DWORD PTR _Filter$[ebp+12], eax

; 2930 : 
; 2931 :         Filter.adwCoefficients[2] = MCPX_GET_REG_VALUE(m_RegCache.TarFCB, NV1BA0_PIO_SET_VOICE_TAR_FCB_FC2);

  00069	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0006f	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00075	89 55 f8	 mov	 DWORD PTR _Filter$[ebp+16], edx

; 2932 :         Filter.adwCoefficients[3] = MCPX_GET_REG_VALUE(m_RegCache.TarFCB, NV1BA0_PIO_SET_VOICE_TAR_FCB_FC3);

  00078	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0007e	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00081	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00087	89 4d fc	 mov	 DWORD PTR _Filter$[ebp+20], ecx
$L38872:

; 2933 :     }
; 2934 : 
; 2935 : #ifndef MCPX_BOOT_LIB
; 2936 : 
; 2937 :     //
; 2938 :     // If we're 3D, hack the filter mode so I3DL2 is always turned on
; 2939 :     //
; 2940 : 
; 2941 :     if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
; 2942 :     {
; 2943 :         if(DSFILTER_MODE_BYPASS == Filter.dwMode)
; 2944 :         {
; 2945 :             Filter.dwMode = DSFILTER_MODE_MULTI;
; 2946 :         }
; 2947 :     }
; 2948 : 
; 2949 : #endif // MCPX_BOOT_LIB
; 2950 : 
; 2951 :     //
; 2952 :     // Recalculate register values
; 2953 :     //
; 2954 :     
; 2955 :     m_RegCache.CfgMISC = MCPX_SET_REG_VALUE(m_RegCache.CfgMISC, Filter.dwMode, NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE);

  0008a	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  0008d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00090	25 ff ff fc ff	 and	 eax, -196609		; fffcffffH
  00095	8b 4d e8	 mov	 ecx, DWORD PTR _Filter$[ebp]
  00098	83 e1 03	 and	 ecx, 3
  0009b	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0009e	0b c1		 or	 eax, ecx
  000a0	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 2956 :     m_RegCache.CfgMISC = MCPX_SET_REG_VALUE(m_RegCache.CfgMISC, Filter.dwQCoefficient, NV1BA0_PIO_SET_VOICE_CFG_MISC_BPQ);

  000a6	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000ac	81 e1 ff ff e3
	ff		 and	 ecx, -1835009		; ffe3ffffH
  000b2	8b 55 ec	 mov	 edx, DWORD PTR _Filter$[ebp+4]
  000b5	83 e2 07	 and	 edx, 7
  000b8	c1 e2 12	 shl	 edx, 18			; 00000012H
  000bb	0b ca		 or	 ecx, edx
  000bd	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 2957 : 
; 2958 :     m_RegCache.TarFCA = MCPX_MAKE_REG_VALUE(Filter.adwCoefficients[0], NV1BA0_PIO_SET_VOICE_TAR_FCA_FC0);

  000c3	8b 4d f0	 mov	 ecx, DWORD PTR _Filter$[ebp+8]
  000c6	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000cc	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  000cf	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 2959 :     m_RegCache.TarFCA |= MCPX_MAKE_REG_VALUE(Filter.adwCoefficients[1], NV1BA0_PIO_SET_VOICE_TAR_FCA_FC1);

  000d2	8b 45 f4	 mov	 eax, DWORD PTR _Filter$[ebp+12]
  000d5	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000da	c1 e0 10	 shl	 eax, 16			; 00000010H
  000dd	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000e3	0b d0		 or	 edx, eax
  000e5	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000e8	89 50 38	 mov	 DWORD PTR [eax+56], edx

; 2960 : 
; 2961 : #ifndef MCPX_BOOT_LIB
; 2962 : 
; 2963 :     if(m_pSettings->m_dwFlags & DSBCAPS_CTRL3D)
; 2964 :     {
; 2965 :         ASSERT(m_pSettings->m_p3dParams);
; 2966 :         ASSERT(m_pI3dl2Source);
; 2967 :         
; 2968 :         if(DS3DMODE_DISABLE == m_pSettings->m_p3dParams->HrtfParams.dwMode)
; 2969 :         {
; 2970 :             m_RegCache.TarFCB = 0;
; 2971 :         }
; 2972 :         else            
; 2973 :         {
; 2974 :             m_RegCache.TarFCB = MCPX_MAKE_REG_VALUE(m_pI3dl2Source->m_I3dl2Data.nDirectIir, NV_PAVS_VOICE_CUR_FCB_FC2);
; 2975 :             m_RegCache.TarFCB |= MCPX_MAKE_REG_VALUE(m_pI3dl2Source->m_I3dl2Data.nReverbIir, NV_PAVS_VOICE_CUR_FCB_FC3);
; 2976 :         }
; 2977 :     }
; 2978 :     else
; 2979 : 
; 2980 : #endif // MCPX_BOOT_LIB
; 2981 : 
; 2982 :     {
; 2983 :         m_RegCache.TarFCB = MCPX_MAKE_REG_VALUE(Filter.adwCoefficients[2], NV_PAVS_VOICE_CUR_FCB_FC2);

  000eb	8b 4d f8	 mov	 ecx, DWORD PTR _Filter$[ebp+16]
  000ee	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000f4	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  000f7	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 2984 :         m_RegCache.TarFCB |= MCPX_MAKE_REG_VALUE(Filter.adwCoefficients[3], NV_PAVS_VOICE_CUR_FCB_FC3);

  000fa	8b 45 fc	 mov	 eax, DWORD PTR _Filter$[ebp+20]
  000fd	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00102	c1 e0 10	 shl	 eax, 16			; 00000010H
  00105	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00108	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0010b	0b d0		 or	 edx, eax
  0010d	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00110	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 2985 :     }
; 2986 : 
; 2987 :     //
; 2988 :     // Apply changes
; 2989 :     //
; 2990 :     
; 2991 :     if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)

  00113	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00116	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  0011a	83 e2 01	 and	 edx, 1
  0011d	85 d2		 test	 edx, edx
  0011f	0f 84 a5 00 00
	00		 je	 $L38879
$L38881:

; 2992 :     {
; 2993 :         MCPX_CHECK_VOICE_FIFO(6 * m_bVoiceCount);

  00125	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0012a	8b 88 00 00 82
	fe		 mov	 ecx, DWORD PTR [eax-25034752]
  00130	c1 e9 02	 shr	 ecx, 2
  00133	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00136	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  0013a	6b c0 06	 imul	 eax, 6
  0013d	3b c8		 cmp	 ecx, eax
  0013f	73 02		 jae	 SHORT $L38882
  00141	eb e2		 jmp	 SHORT $L38881
$L38882:

; 2994 :         
; 2995 :         for(i = 0; i < m_bVoiceCount; i++)

  00143	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0014a	eb 09		 jmp	 SHORT $L38885
$L38886:
  0014c	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  0014f	83 c1 01	 add	 ecx, 1
  00152	89 4d e4	 mov	 DWORD PTR _i$[ebp], ecx
$L38885:
  00155	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00158	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  0015c	39 45 e4	 cmp	 DWORD PTR _i$[ebp], eax
  0015f	73 69		 jae	 SHORT $L38879

; 2996 :         {
; 2997 :             MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  00161	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  00164	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00167	0f b7 44 4a 0c	 movzx	 eax, WORD PTR [edx+ecx*2+12]
  0016c	b9 f8 02 00 00	 mov	 ecx, 760		; 000002f8H
  00171	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 2998 :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);

  00177	ba fc 02 00 00	 mov	 edx, 764		; 000002fcH
  0017c	c7 82 00 00 82
	fe 01 00 00 00	 mov	 DWORD PTR [edx-25034752], 1

; 2999 :             MCPX_VOICE_WRITE(SetVoiceCfgMISC, m_RegCache.CfgMISC);

  00186	b8 18 03 00 00	 mov	 eax, 792		; 00000318H
  0018b	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0018e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00191	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 3000 :             MCPX_VOICE_WRITE(SetVoiceTarFCA, m_RegCache.TarFCA);

  00197	b8 74 03 00 00	 mov	 eax, 884		; 00000374H
  0019c	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0019f	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001a2	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 3001 :             MCPX_VOICE_WRITE(SetVoiceTarFCB, m_RegCache.TarFCB);

  001a8	b8 78 03 00 00	 mov	 eax, 888		; 00000378H
  001ad	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001b0	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  001b3	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 3002 :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);

  001b9	b8 fc 02 00 00	 mov	 eax, 764		; 000002fcH
  001be	c7 80 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [eax-25034752], 0

; 3003 :         }

  001c8	eb 82		 jmp	 SHORT $L38886
$L38879:

; 3004 :     }
; 3005 : 
; 3006 :     DPF_LEAVE_HRESULT(DS_OK);
; 3007 : 
; 3008 :     return DS_OK;

  001ca	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T42312[ebp], 0
  001d1	8d 4d dc	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  001d4	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  001d9	8b 45 d8	 mov	 eax, DWORD PTR $T42312[ebp]

; 3009 : }

  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	c2 04 00	 ret	 4
?SetFilter@CMcpxVoiceClient@DirectSound@@QAEJPBU_DSFILTERDESC@@@Z ENDP ; DirectSound::CMcpxVoiceClient::SetFilter
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?ConnectVoice@CMcpxVoiceClient@DirectSound@@QAEJXZ
DSOUND	SEGMENT
_this$ = -68
$T42316 = -64
_dwVoiceBins$ = -60
___AutoIrql$ = -56
_pSubMixDestination$ = -48
_Volume$ = -44
_dwPitch$ = -8
_i$ = -4
?ConnectVoice@CMcpxVoiceClient@DirectSound@@QAEJXZ PROC NEAR ; DirectSound::CMcpxVoiceClient::ConnectVoice, COMDAT
; _this$ = ecx

; 3035 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 3036 :     CMcpxBuffer *           pSubMixDestination;
; 3037 :     DWORD                   dwVoiceBins;
; 3038 :     MCPX_VOICE_VOLUME       Volume;
; 3039 :     DWORD                   dwPitch;
; 3040 :     DWORD                   i;
; 3041 :     
; 3042 :     DPF_ENTER();
; 3043 :     AutoIrql();

  00009	8d 4d c8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 3044 : 
; 3045 :     pSubMixDestination = GetSubMixDestination();

  00011	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?GetSubMixDestination@CMcpxVoiceClient@DirectSound@@IAEPAVCMcpxBuffer@2@XZ ; DirectSound::CMcpxVoiceClient::GetSubMixDestination
  00019	89 45 d0	 mov	 DWORD PTR _pSubMixDestination$[ebp], eax

; 3046 :     ASSERT(pSubMixDestination);
; 3047 : 
; 3048 :     DPF_INFO("Voice %x (%x) using %x (%x) as it's submix destination", this, m_ahVoices[0], pSubMixDestination, pSubMixDestination->m_ahVoices[0]);
; 3049 : 
; 3050 :     //
; 3051 :     // Make sure we're not active.  The voice has to be turned off in order
; 3052 :     // to change it's position in the voice list.
; 3053 :     //
; 3054 :     
; 3055 :     if((m_dwStatus & MCPX_VOICESTATUS_ACTIVEMASK) == MCPX_VOICESTATUS_ACTIVEMASK)

  0001c	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00023	83 e1 03	 and	 ecx, 3
  00026	83 f9 03	 cmp	 ecx, 3
  00029	75 0a		 jne	 SHORT $L38912

; 3056 :     {
; 3057 :         DPF_WARNING("Voice %x (%x) is still active.  Shutting it down...", this, m_ahVoices[0]);
; 3058 :         DeactivateVoice();

  0002b	6a 00		 push	 0
  0002d	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?DeactivateVoice@CMcpxVoiceClient@DirectSound@@IAEXH@Z ; DirectSound::CMcpxVoiceClient::DeactivateVoice
$L38912:

; 3059 :     }
; 3060 : 
; 3061 :     //
; 3062 :     // Add us to the destination voice's list
; 3063 :     //
; 3064 : 
; 3065 :     InsertTailList(&pSubMixDestination->m_lstSourceVoices, &m_leSourceVoice);

  00035	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00038	83 c2 5c	 add	 edx, 92			; 0000005cH
  0003b	52		 push	 edx
  0003c	8b 45 d0	 mov	 eax, DWORD PTR _pSubMixDestination$[ebp]
  0003f	83 c0 44	 add	 eax, 68			; 00000044H
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?InsertTailList@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailList

; 3066 : 
; 3067 :     //
; 3068 :     // Update our mixbin assignments, volume and pitch
; 3069 :     //
; 3070 : 
; 3071 :     if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)

  00048	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  0004f	83 e2 01	 and	 edx, 1
  00052	85 d2		 test	 edx, edx
  00054	0f 84 0d 01 00
	00		 je	 $L38913

; 3072 :     {
; 3073 :         ConvertMixBinValues(&dwVoiceBins, &m_RegCache.CfgFMT);

  0005a	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	83 c0 14	 add	 eax, 20			; 00000014H
  00060	50		 push	 eax
  00061	8d 4d c4	 lea	 ecx, DWORD PTR _dwVoiceBins$[ebp]
  00064	51		 push	 ecx
  00065	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?ConvertMixBinValues@CMcpxVoiceClient@DirectSound@@IAEXPAK0@Z ; DirectSound::CMcpxVoiceClient::ConvertMixBinValues

; 3074 :         ConvertVolumeValues(&Volume);

  0006d	8d 55 d4	 lea	 edx, DWORD PTR _Volume$[ebp]
  00070	52		 push	 edx
  00071	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?ConvertVolumeValues@CMcpxVoiceClient@DirectSound@@IAEXPAUMCPX_VOICE_VOLUME@@@Z ; DirectSound::CMcpxVoiceClient::ConvertVolumeValues

; 3075 :         ConvertPitchValue(&dwPitch);

  00079	8d 45 f8	 lea	 eax, DWORD PTR _dwPitch$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?ConvertPitchValue@CMcpxVoiceClient@DirectSound@@IAEXPAK@Z ; DirectSound::CMcpxVoiceClient::ConvertPitchValue
$L38915:

; 3076 : 
; 3077 :         MCPX_CHECK_VOICE_FIFO(9 * m_bVoiceCount);

  00085	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0008a	8b 91 00 00 82
	fe		 mov	 edx, DWORD PTR [ecx-25034752]
  00090	c1 ea 02	 shr	 edx, 2
  00093	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00096	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  0009a	6b c9 09	 imul	 ecx, 9
  0009d	3b d1		 cmp	 edx, ecx
  0009f	73 02		 jae	 SHORT $L38916
  000a1	eb e2		 jmp	 SHORT $L38915
$L38916:

; 3078 :         
; 3079 :         for(i = 0; i < m_bVoiceCount; i++)

  000a3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000aa	eb 09		 jmp	 SHORT $L38919
$L38920:
  000ac	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000af	83 c2 01	 add	 edx, 1
  000b2	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L38919:
  000b5	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  000bc	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  000bf	0f 83 a2 00 00
	00		 jae	 $L38913

; 3080 :         {
; 3081 :             MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  000c5	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000c8	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  000cb	0f b7 4c 50 0c	 movzx	 ecx, WORD PTR [eax+edx*2+12]
  000d0	ba f8 02 00 00	 mov	 edx, 760		; 000002f8H
  000d5	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 3082 :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);

  000db	b8 fc 02 00 00	 mov	 eax, 764		; 000002fcH
  000e0	c7 80 00 00 82
	fe 01 00 00 00	 mov	 DWORD PTR [eax-25034752], 1

; 3083 :             MCPX_VOICE_WRITE(SetVoiceCfgVBIN, dwVoiceBins);

  000ea	b9 00 03 00 00	 mov	 ecx, 768		; 00000300H
  000ef	8b 55 c4	 mov	 edx, DWORD PTR _dwVoiceBins$[ebp]
  000f2	89 91 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], edx

; 3084 :             MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));

  000f8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000fb	50		 push	 eax
  000fc	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	e8 00 00 00 00	 call	 ?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::GetVoiceCfgFMT
  00104	b9 04 03 00 00	 mov	 ecx, 772		; 00000304H
  00109	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 3085 :             MCPX_VOICE_WRITE(SetVoiceTarVOLA, Volume.TarVOLA[i]);

  0010f	ba 60 03 00 00	 mov	 edx, 864		; 00000360H
  00114	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00117	8b 4c 85 d4	 mov	 ecx, DWORD PTR _Volume$[ebp+eax*4]
  0011b	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 3086 :             MCPX_VOICE_WRITE(SetVoiceTarVOLB, Volume.TarVOLB[i]);

  00121	ba 64 03 00 00	 mov	 edx, 868		; 00000364H
  00126	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00129	8b 4c 85 e0	 mov	 ecx, DWORD PTR _Volume$[ebp+eax*4+12]
  0012d	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 3087 :             MCPX_VOICE_WRITE(SetVoiceTarVOLC, Volume.TarVOLC[i]);

  00133	ba 68 03 00 00	 mov	 edx, 872		; 00000368H
  00138	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0013b	8b 4c 85 ec	 mov	 ecx, DWORD PTR _Volume$[ebp+eax*4+24]
  0013f	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 3088 :             MCPX_VOICE_WRITE(SetVoiceTarPitch, dwPitch);

  00145	ba 7c 03 00 00	 mov	 edx, 892		; 0000037cH
  0014a	8b 45 f8	 mov	 eax, DWORD PTR _dwPitch$[ebp]
  0014d	89 82 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], eax

; 3089 :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);

  00153	b9 fc 02 00 00	 mov	 ecx, 764		; 000002fcH
  00158	c7 81 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [ecx-25034752], 0

; 3090 :         }

  00162	e9 45 ff ff ff	 jmp	 $L38920
$L38913:

; 3091 :     }
; 3092 : 
; 3093 :     DPF_LEAVE_HRESULT(DS_OK);
; 3094 : 
; 3095 :     return DS_OK;

  00167	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T42316[ebp], 0
  0016e	8d 4d c8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00171	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00176	8b 45 c0	 mov	 eax, DWORD PTR $T42316[ebp]

; 3096 : }

  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c3		 ret	 0
?ConnectVoice@CMcpxVoiceClient@DirectSound@@QAEJXZ ENDP	; DirectSound::CMcpxVoiceClient::ConnectVoice
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?DisconnectVoice@CMcpxVoiceClient@DirectSound@@QAEJXZ
DSOUND	SEGMENT
_this$ = -72
$T42320 = -68
_dwVoiceBins$ = -64
___AutoIrql$ = -60
_pSubMixDestination$ = -48
_Volume$ = -44
_dwPitch$ = -8
_i$ = -4
?DisconnectVoice@CMcpxVoiceClient@DirectSound@@QAEJXZ PROC NEAR ; DirectSound::CMcpxVoiceClient::DisconnectVoice, COMDAT
; _this$ = ecx

; 3122 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx

; 3123 :     CMcpxBuffer *           pSubMixDestination;
; 3124 :     DWORD                   dwVoiceBins;
; 3125 :     MCPX_VOICE_VOLUME       Volume;
; 3126 :     DWORD                   dwPitch;
; 3127 :     HRESULT                 hr;
; 3128 :     DWORD                   i;
; 3129 :     
; 3130 :     DPF_ENTER();
; 3131 :     AutoIrql();

  00009	8d 4d c4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 3132 : 
; 3133 :     if(pSubMixDestination = GetSubMixDestination())

  00011	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?GetSubMixDestination@CMcpxVoiceClient@DirectSound@@IAEPAVCMcpxBuffer@2@XZ ; DirectSound::CMcpxVoiceClient::GetSubMixDestination
  00019	89 45 d0	 mov	 DWORD PTR _pSubMixDestination$[ebp], eax
  0001c	83 7d d0 00	 cmp	 DWORD PTR _pSubMixDestination$[ebp], 0
  00020	0f 84 2b 01 00
	00		 je	 $L38953

; 3134 :     {
; 3135 :         //
; 3136 :         // Remove ourselves from the destination voices's list
; 3137 :         //
; 3138 : 
; 3139 :         RemoveEntryList(&m_leSourceVoice);

  00026	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 c0 5c	 add	 eax, 92			; 0000005cH
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 3140 : 
; 3141 :         DPF_INFO("Voice %x (%x) disconnected submix from %x (%x)", this, m_ahVoices[0], pSubMixDestination, pSubMixDestination->m_ahVoices[0]);
; 3142 : 
; 3143 :         //
; 3144 :         // Update our mixbin assignments, volume and pitch
; 3145 :         //
; 3146 : 
; 3147 :         if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)

  00032	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00039	83 e2 01	 and	 edx, 1
  0003c	85 d2		 test	 edx, edx
  0003e	0f 84 0d 01 00
	00		 je	 $L38953

; 3148 :         {
; 3149 :             ConvertMixBinValues(&dwVoiceBins, &m_RegCache.CfgFMT);

  00044	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	83 c0 14	 add	 eax, 20			; 00000014H
  0004a	50		 push	 eax
  0004b	8d 4d c0	 lea	 ecx, DWORD PTR _dwVoiceBins$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?ConvertMixBinValues@CMcpxVoiceClient@DirectSound@@IAEXPAK0@Z ; DirectSound::CMcpxVoiceClient::ConvertMixBinValues

; 3150 :             ConvertVolumeValues(&Volume);

  00057	8d 55 d4	 lea	 edx, DWORD PTR _Volume$[ebp]
  0005a	52		 push	 edx
  0005b	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?ConvertVolumeValues@CMcpxVoiceClient@DirectSound@@IAEXPAUMCPX_VOICE_VOLUME@@@Z ; DirectSound::CMcpxVoiceClient::ConvertVolumeValues

; 3151 :             ConvertPitchValue(&dwPitch);

  00063	8d 45 f8	 lea	 eax, DWORD PTR _dwPitch$[ebp]
  00066	50		 push	 eax
  00067	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?ConvertPitchValue@CMcpxVoiceClient@DirectSound@@IAEXPAK@Z ; DirectSound::CMcpxVoiceClient::ConvertPitchValue
$L38956:

; 3152 : 
; 3153 :             MCPX_CHECK_VOICE_FIFO(9 * m_bVoiceCount);

  0006f	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00074	8b 91 00 00 82
	fe		 mov	 edx, DWORD PTR [ecx-25034752]
  0007a	c1 ea 02	 shr	 edx, 2
  0007d	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00080	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  00084	6b c9 09	 imul	 ecx, 9
  00087	3b d1		 cmp	 edx, ecx
  00089	73 02		 jae	 SHORT $L38957
  0008b	eb e2		 jmp	 SHORT $L38956
$L38957:

; 3154 :             
; 3155 :             for(i = 0; i < m_bVoiceCount; i++)

  0008d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00094	eb 09		 jmp	 SHORT $L38960
$L38961:
  00096	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00099	83 c2 01	 add	 edx, 1
  0009c	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L38960:
  0009f	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	0f b6 48 64	 movzx	 ecx, BYTE PTR [eax+100]
  000a6	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  000a9	0f 83 a2 00 00
	00		 jae	 $L38953

; 3156 :             {
; 3157 :                 MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[i]);

  000af	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000b2	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	0f b7 4c 50 0c	 movzx	 ecx, WORD PTR [eax+edx*2+12]
  000ba	ba f8 02 00 00	 mov	 edx, 760		; 000002f8H
  000bf	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 3158 :                 MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);

  000c5	b8 fc 02 00 00	 mov	 eax, 764		; 000002fcH
  000ca	c7 80 00 00 82
	fe 01 00 00 00	 mov	 DWORD PTR [eax-25034752], 1

; 3159 :                 MCPX_VOICE_WRITE(SetVoiceCfgVBIN, dwVoiceBins);

  000d4	b9 00 03 00 00	 mov	 ecx, 768		; 00000300H
  000d9	8b 55 c0	 mov	 edx, DWORD PTR _dwVoiceBins$[ebp]
  000dc	89 91 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], edx

; 3160 :                 MCPX_VOICE_WRITE(SetVoiceCfgFMT, GetVoiceCfgFMT(i));

  000e2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000e5	50		 push	 eax
  000e6	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	e8 00 00 00 00	 call	 ?GetVoiceCfgFMT@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::GetVoiceCfgFMT
  000ee	b9 04 03 00 00	 mov	 ecx, 772		; 00000304H
  000f3	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 3161 :                 MCPX_VOICE_WRITE(SetVoiceTarVOLA, Volume.TarVOLA[i]);

  000f9	ba 60 03 00 00	 mov	 edx, 864		; 00000360H
  000fe	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00101	8b 4c 85 d4	 mov	 ecx, DWORD PTR _Volume$[ebp+eax*4]
  00105	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 3162 :                 MCPX_VOICE_WRITE(SetVoiceTarVOLB, Volume.TarVOLB[i]);

  0010b	ba 64 03 00 00	 mov	 edx, 868		; 00000364H
  00110	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00113	8b 4c 85 e0	 mov	 ecx, DWORD PTR _Volume$[ebp+eax*4+12]
  00117	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 3163 :                 MCPX_VOICE_WRITE(SetVoiceTarVOLC, Volume.TarVOLC[i]);

  0011d	ba 68 03 00 00	 mov	 edx, 872		; 00000368H
  00122	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00125	8b 4c 85 ec	 mov	 ecx, DWORD PTR _Volume$[ebp+eax*4+24]
  00129	89 8a 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], ecx

; 3164 :                 MCPX_VOICE_WRITE(SetVoiceTarPitch, dwPitch);

  0012f	ba 7c 03 00 00	 mov	 edx, 892		; 0000037cH
  00134	8b 45 f8	 mov	 eax, DWORD PTR _dwPitch$[ebp]
  00137	89 82 00 00 82
	fe		 mov	 DWORD PTR [edx-25034752], eax

; 3165 :                 MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);

  0013d	b9 fc 02 00 00	 mov	 ecx, 764		; 000002fcH
  00142	c7 81 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [ecx-25034752], 0

; 3166 :             }

  0014c	e9 45 ff ff ff	 jmp	 $L38961
$L38953:

; 3167 :         }
; 3168 :     }
; 3169 : 
; 3170 :     DPF_LEAVE_HRESULT(DS_OK);
; 3171 : 
; 3172 :     return DS_OK;

  00151	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T42320[ebp], 0
  00158	8d 4d c4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0015b	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00160	8b 45 bc	 mov	 eax, DWORD PTR $T42320[ebp]

; 3173 : }

  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
?DisconnectVoice@CMcpxVoiceClient@DirectSound@@QAEJXZ ENDP ; DirectSound::CMcpxVoiceClient::DisconnectVoice
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?GetSslPosition@CMcpxVoiceClient@DirectSound@@IAEKXZ
DSOUND	SEGMENT
_this$ = -24
$T42324 = -20
___AutoIrql$ = -16
_dwState$ = -8
_dwPlayCursor$ = -4
?GetSslPosition@CMcpxVoiceClient@DirectSound@@IAEKXZ PROC NEAR ; DirectSound::CMcpxVoiceClient::GetSslPosition, COMDAT
; _this$ = ecx

; 3199 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 3200 :     DWORD                   dwPlayCursor    = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwPlayCursor$[ebp], 0

; 3201 :     DWORD                   dwState;
; 3202 :     
; 3203 :     DPF_ENTER();
; 3204 :     AutoIrql();

  00010	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 3205 : 
; 3206 :     //
; 3207 :     // There's two ways to query the hardware for current position.  We could 
; 3208 :     // use the "recommended" way and poke a position request register, wait for 
; 3209 :     // an interrupt, then get the current position out of a notifier.  Or, we
; 3210 :     // could go the simple route and just look at the voice structure.  NVidia
; 3211 :     // doesn't like this solution because they want to be able to change the
; 3212 :     // voice structure without modifying any driver code.  Our part won't change,
; 3213 :     // and the driver could be modified either way.  Hm... let's see... I think
; 3214 :     // I prefer the lesser amount of code and no interrupts.
; 3215 :     //
; 3216 :     // We're locking the voice so we don't query the voice structure while the
; 3217 :     // APU is writing to it.  It's possible we could read partially written
; 3218 :     // data.
; 3219 :     // 
; 3220 : 
; 3221 :     if(m_dwStatus & MCPX_VOICESTATUS_ALLOCATED)

  00018	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  0001f	83 e1 01	 and	 ecx, 1
  00022	85 c9		 test	 ecx, ecx
  00024	0f 84 a2 00 00
	00		 je	 $L38990

; 3222 :     {
; 3223 :         //
; 3224 :         // Check for the NEW_VOICE bit in the voice state.  The hardware 
; 3225 :         // doesn't update the position register until the first frame has 
; 3226 :         // been processed.
; 3227 :         //
; 3228 : 
; 3229 :         MCPX_VOICE_STRUCT_READ(m_ahVoices[m_bVoiceCount - 1], NV_PAVS_VOICE_PAR_STATE, &dwState);

  0002a	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	0f b6 42 64	 movzx	 eax, BYTE PTR [edx+100]
  00031	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	0f b7 54 41 0a	 movzx	 edx, WORD PTR [ecx+eax*2+10]
  00039	c1 e2 07	 shl	 edx, 7
  0003c	a1 30 00 00 00	 mov	 eax, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+48
  00041	8b 4c 10 54	 mov	 ecx, DWORD PTR [eax+edx+84]
  00045	89 4d f8	 mov	 DWORD PTR _dwState$[ebp], ecx

; 3230 : 
; 3231 :         if(!MCPX_GET_REG_VALUE(dwState, NV_PAVS_VOICE_PAR_STATE_NEW_VOICE))

  00048	8b 55 f8	 mov	 edx, DWORD PTR _dwState$[ebp]
  0004b	c1 ea 14	 shr	 edx, 20			; 00000014H
  0004e	83 e2 01	 and	 edx, 1
  00051	85 d2		 test	 edx, edx
  00053	75 77		 jne	 SHORT $L38990
$L38996:

; 3232 :         {
; 3233 :             MCPX_CHECK_VOICE_FIFO(3);

  00055	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0005a	8b 88 00 00 82
	fe		 mov	 ecx, DWORD PTR [eax-25034752]
  00060	c1 e9 02	 shr	 ecx, 2
  00063	83 f9 03	 cmp	 ecx, 3
  00066	73 02		 jae	 SHORT $L38997
  00068	eb eb		 jmp	 SHORT $L38996
$L38997:

; 3234 :         
; 3235 :             MCPX_VOICE_WRITE(SetCurrentVoice, m_ahVoices[0]);

  0006a	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00071	b9 f8 02 00 00	 mov	 ecx, 760		; 000002f8H
  00076	89 81 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], eax

; 3236 :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON);

  0007c	ba fc 02 00 00	 mov	 edx, 764		; 000002fcH
  00081	c7 82 00 00 82
	fe 01 00 00 00	 mov	 DWORD PTR [edx-25034752], 1

; 3237 :             MCPX_VOICE_STRUCT_READ(m_ahVoices[0], NV_PAVS_VOICE_PAR_OFFSET, &dwPlayCursor);

  0008b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00092	c1 e1 07	 shl	 ecx, 7
  00095	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+48
  0009b	8b 44 0a 58	 mov	 eax, DWORD PTR [edx+ecx+88]
  0009f	89 45 fc	 mov	 DWORD PTR _dwPlayCursor$[ebp], eax

; 3238 :             MCPX_VOICE_WRITE(VoiceLock, NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF);

  000a2	b9 fc 02 00 00	 mov	 ecx, 764		; 000002fcH
  000a7	c7 81 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [ecx-25034752], 0

; 3239 : 
; 3240 :             dwPlayCursor = MCPX_GET_REG_VALUE(dwPlayCursor, NV_PAVS_VOICE_PAR_OFFSET_CBO);

  000b1	8b 55 fc	 mov	 edx, DWORD PTR _dwPlayCursor$[ebp]
  000b4	81 e2 ff ff ff
	00		 and	 edx, 16777215		; 00ffffffH
  000ba	89 55 fc	 mov	 DWORD PTR _dwPlayCursor$[ebp], edx

; 3241 :             dwPlayCursor = SamplesToBytes(dwPlayCursor);

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _dwPlayCursor$[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	e8 00 00 00 00	 call	 ?SamplesToBytes@CMcpxVoiceClient@DirectSound@@IAEKK@Z ; DirectSound::CMcpxVoiceClient::SamplesToBytes
  000c9	89 45 fc	 mov	 DWORD PTR _dwPlayCursor$[ebp], eax
$L38990:

; 3242 :         }
; 3243 :     }
; 3244 : 
; 3245 :     DPF_LEAVE(dwPlayCursor);
; 3246 : 
; 3247 :     return dwPlayCursor;

  000cc	8b 4d fc	 mov	 ecx, DWORD PTR _dwPlayCursor$[ebp]
  000cf	89 4d ec	 mov	 DWORD PTR $T42324[ebp], ecx
  000d2	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000d5	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000da	8b 45 ec	 mov	 eax, DWORD PTR $T42324[ebp]

; 3248 : }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
?GetSslPosition@CMcpxVoiceClient@DirectSound@@IAEKXZ ENDP ; DirectSound::CMcpxVoiceClient::GetSslPosition
DSOUND	ENDS
PUBLIC	??_7CMcpxCore@DirectSound@@6B@			; DirectSound::CMcpxCore::`vftable'
PUBLIC	??_GCMcpxCore@DirectSound@@UAEPAXI@Z		; DirectSound::CMcpxCore::`scalar deleting destructor'
PUBLIC	?__AddRef@DirectSound@@YGPAVCDirectSoundSettings@1@PAV21@@Z ; DirectSound::__AddRef
PUBLIC	??0CAc97Device@DirectSound@@QAE@XZ		; DirectSound::CAc97Device::CAc97Device
EXTRN	??_ECMcpxCore@DirectSound@@UAEPAXI@Z:NEAR	; DirectSound::CMcpxCore::`vector deleting destructor'
;	COMDAT ??_7CMcpxCore@DirectSound@@6B@
; File c:\xbox\private\windows\directx\dsound\dsound\mcpxcore.cpp
CONST	SEGMENT
??_7CMcpxCore@DirectSound@@6B@ DD FLAT:??_ECMcpxCore@DirectSound@@UAEPAXI@Z ; DirectSound::CMcpxCore::`vftable'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CMcpxCore@DirectSound@@QAE@PAVCDirectSoundSettings@1@@Z
DSOUND	SEGMENT
_this$ = -4
_pSettings$ = 8
??0CMcpxCore@DirectSound@@QAE@PAVCDirectSoundSettings@1@@Z PROC NEAR ; DirectSound::CMcpxCore::CMcpxCore, COMDAT
; _this$ = ecx

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMcpxCore@DirectSound@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
  00016	e8 00 00 00 00	 call	 ??0CAc97Device@DirectSound@@QAE@XZ ; DirectSound::CAc97Device::CAc97Device

; 53   :     DPF_ENTER();
; 54   : 
; 55   :     m_pSettings = ADDREF(pSettings);

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _pSettings$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCDirectSoundSettings@1@PAV21@@Z ; DirectSound::__AddRef
  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 56   : 
; 57   :     DPF_LEAVE_VOID();
; 58   : }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0CMcpxCore@DirectSound@@QAE@PAVCDirectSoundSettings@1@@Z ENDP ; DirectSound::CMcpxCore::CMcpxCore
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??_GCMcpxCore@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCMcpxCore@DirectSound@@UAEPAXI@Z PROC NEAR		; DirectSound::CMcpxCore::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMcpxCore@DirectSound@@UAE@XZ ; DirectSound::CMcpxCore::~CMcpxCore
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L39022
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L39022:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCMcpxCore@DirectSound@@UAEPAXI@Z ENDP		; DirectSound::CMcpxCore::`scalar deleting destructor'
DSOUND	ENDS
PUBLIC	??_GCMcpxGPDspManager@DirectSound@@QAEPAXI@Z	; DirectSound::CMcpxGPDspManager::`scalar deleting destructor'
PUBLIC	??1CAc97Device@DirectSound@@QAE@XZ		; DirectSound::CAc97Device::~CAc97Device
; Function compile flags: /Odt
;	COMDAT ??1CMcpxCore@DirectSound@@UAE@XZ
DSOUND	SEGMENT
tv76 = -20
_this$ = -16
$T42335 = -12
$T42334 = -8
_i$ = -4
??1CMcpxCore@DirectSound@@UAE@XZ PROC NEAR		; DirectSound::CMcpxCore::~CMcpxCore, COMDAT
; _this$ = ecx

; 83   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMcpxCore@DirectSound@@6B@

; 84   :     DWORD                   i;
; 85   : 
; 86   :     DPF_ENTER();
; 87   : 
; 88   : #ifdef MCPX_BOOT_LIB
; 89   : 
; 90   :     Reset();

  00012	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?Reset@CMcpxCore@DirectSound@@IAEXXZ ; DirectSound::CMcpxCore::Reset

; 91   : 
; 92   : #else // MCPX_BOOT_LIB
; 93   : 
; 94   :     //
; 95   :     // We're assuming the derived object already called Reset
; 96   :     //
; 97   : 
; 98   : #endif // MCPX_BOOT_LIB
; 99   : 
; 100  :     //
; 101  :     // Free the DSP managers
; 102  :     //
; 103  : 
; 104  :     DELETE(m_pGpDspManager);

  0001a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00021	74 35		 je	 SHORT $L39028
  00023	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00029	89 45 f4	 mov	 DWORD PTR $T42335[ebp], eax
  0002c	8b 4d f4	 mov	 ecx, DWORD PTR $T42335[ebp]
  0002f	89 4d f8	 mov	 DWORD PTR $T42334[ebp], ecx
  00032	83 7d f8 00	 cmp	 DWORD PTR $T42334[ebp], 0
  00036	74 0f		 je	 SHORT $L42336
  00038	6a 01		 push	 1
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR $T42334[ebp]
  0003d	e8 00 00 00 00	 call	 ??_GCMcpxGPDspManager@DirectSound@@QAEPAXI@Z
  00042	89 45 ec	 mov	 DWORD PTR tv76[ebp], eax
  00045	eb 07		 jmp	 SHORT $L42337
$L42336:
  00047	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$L42337:
  0004e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00051	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
$L39028:

; 105  : 
; 106  : #ifndef MCPX_BOOT_LIB
; 107  : 
; 108  :     DELETE(m_pEpDspManager);
; 109  : 
; 110  : #endif // MCPX_BOOT_LIB
; 111  : 
; 112  :     //
; 113  :     // Free APU memory
; 114  :     //
; 115  : 
; 116  :     for(i = 0; i < MCPX_MEM_COUNT; i++)

  00058	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0005f	eb 09		 jmp	 SHORT $L39031
$L39032:
  00061	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00064	83 c0 01	 add	 eax, 1
  00067	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L39031:
  0006a	83 7d fc 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  0006e	73 77		 jae	 SHORT $L39033

; 117  :     {
; 118  : 
; 119  : #ifdef ENABLE_SLOP_MEMORY_RECOVERY
; 120  : 
; 121  :         if(m_ctxMemory[i].fOwned)

  00070	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00073	c1 e1 04	 shl	 ecx, 4
  00076	83 b9 0c 00 00
	00 00		 cmp	 DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A[ecx+12], 0
  0007d	74 33		 je	 SHORT $L39034

; 122  : 
; 123  : #endif // ENABLE_SLOP_MEMORY_RECOVERY
; 124  : 
; 125  :         {
; 126  :             PHYSFREE(m_ctxMemory[i].VirtualAddress);

  0007f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00082	c1 e2 04	 shl	 edx, 4
  00085	83 ba 00 00 00
	00 00		 cmp	 DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A[edx], 0
  0008c	74 22		 je	 SHORT $L39035
  0008e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00091	c1 e0 04	 shl	 eax, 4
  00094	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A[eax]
  0009a	51		 push	 ecx
  0009b	e8 00 00 00 00	 call	 ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PhysicalFree
  000a0	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000a3	c1 e2 04	 shl	 edx, 4
  000a6	c7 82 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A[edx], 0
$L39035:

; 127  :         }
; 128  : 
; 129  : #ifdef ENABLE_SLOP_MEMORY_RECOVERY
; 130  : 
; 131  :         else

  000b0	eb 10		 jmp	 SHORT $L39036
$L39034:

; 132  :         {
; 133  :             m_ctxMemory[i].VirtualAddress = NULL;

  000b2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000b5	c1 e0 04	 shl	 eax, 4
  000b8	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A[eax], 0
$L39036:

; 134  :         }
; 135  : 
; 136  : #endif // ENABLE_SLOP_MEMORY_RECOVERY
; 137  : 
; 138  :         m_ctxMemory[i].PhysicalAddress = 0;

  000c2	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000c5	c1 e1 04	 shl	 ecx, 4
  000c8	c7 81 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A[ecx+4], 0

; 139  :         m_ctxMemory[i].Size = 0;

  000d2	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000d5	c1 e2 04	 shl	 edx, 4
  000d8	c7 82 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A[edx+8], 0

; 140  :     }

  000e2	e9 7a ff ff ff	 jmp	 $L39032
$L39033:

; 141  : 
; 142  :     //
; 143  :     // Release object references
; 144  :     //
; 145  : 
; 146  :     RELEASE(m_pSettings);

  000e7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ea	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000ee	74 1c		 je	 SHORT $L39037
  000f0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000f6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fc	8b 12		 mov	 edx, DWORD PTR [edx]
  000fe	51		 push	 ecx
  000ff	ff 52 08	 call	 DWORD PTR [edx+8]
  00102	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00105	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L39037:

; 147  : 
; 148  : #ifdef ENABLE_SLOP_MEMORY_RECOVERY
; 149  : 
; 150  :     RELEASE(m_pSlopMemoryHeap);

  0010c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00113	74 1c		 je	 SHORT $L39026
  00115	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00118	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0011b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0011e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00121	8b 00		 mov	 eax, DWORD PTR [eax]
  00123	52		 push	 edx
  00124	ff 50 08	 call	 DWORD PTR [eax+8]
  00127	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
$L39026:

; 151  : 
; 152  : #endif // ENABLE_SLOP_MEMORY_RECOVERY
; 153  : 
; 154  :     DPF_LEAVE_VOID();
; 155  : }

  00131	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00134	83 c1 10	 add	 ecx, 16			; 00000010H
  00137	e8 00 00 00 00	 call	 ??1CAc97Device@DirectSound@@QAE@XZ ; DirectSound::CAc97Device::~CAc97Device
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c3		 ret	 0
??1CMcpxCore@DirectSound@@UAE@XZ ENDP			; DirectSound::CMcpxCore::~CMcpxCore
DSOUND	ENDS
PUBLIC	??1CMcpxGPDspManager@DirectSound@@QAE@XZ	; DirectSound::CMcpxGPDspManager::~CMcpxGPDspManager
; Function compile flags: /Odt
;	COMDAT ??_GCMcpxGPDspManager@DirectSound@@QAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCMcpxGPDspManager@DirectSound@@QAEPAXI@Z PROC NEAR	; DirectSound::CMcpxGPDspManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMcpxGPDspManager@DirectSound@@QAE@XZ ; DirectSound::CMcpxGPDspManager::~CMcpxGPDspManager
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L39042
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L39042:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCMcpxGPDspManager@DirectSound@@QAEPAXI@Z ENDP	; DirectSound::CMcpxGPDspManager::`scalar deleting destructor'
DSOUND	ENDS
PUBLIC	?AllocateApuMemory@CMcpxCore@DirectSound@@IAEJXZ ; DirectSound::CMcpxCore::AllocateApuMemory
PUBLIC	?SetupFrontEndProcessor@CMcpxCore@DirectSound@@IAEXXZ ; DirectSound::CMcpxCore::SetupFrontEndProcessor
PUBLIC	?SetupVoiceProcessor@CMcpxCore@DirectSound@@IAEXXZ ; DirectSound::CMcpxCore::SetupVoiceProcessor
PUBLIC	?SetupDSPs@CMcpxCore@DirectSound@@IAEXXZ	; DirectSound::CMcpxCore::SetupDSPs
PUBLIC	?SetupAc97@CMcpxCore@DirectSound@@IAEJXZ	; DirectSound::CMcpxCore::SetupAc97
PUBLIC	?Run@CAc97Channel@DirectSound@@QAEXK@Z		; DirectSound::CAc97Channel::Run
PUBLIC	?SetSetupEngineState@CMcpxCore@DirectSound@@IAEXW4MCPX_SE_STATE@@@Z ; DirectSound::CMcpxCore::SetSetupEngineState
; Function compile flags: /Odt
;	COMDAT ?Initialize@CMcpxCore@DirectSound@@QAEJXZ
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
?Initialize@CMcpxCore@DirectSound@@QAEJXZ PROC NEAR	; DirectSound::CMcpxCore::Initialize, COMDAT
; _this$ = ecx

; 181  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 182  :     HRESULT                 hr;
; 183  : 
; 184  :     DPF_ENTER();
; 185  : 
; 186  :     //
; 187  :     // Make sure we're in a known good state
; 188  :     //
; 189  :     
; 190  :     Reset();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?Reset@CMcpxCore@DirectSound@@IAEXXZ ; DirectSound::CMcpxCore::Reset

; 191  : 
; 192  :     //
; 193  :     // Allocate memory
; 194  :     //
; 195  : 
; 196  :     hr = AllocateApuMemory();

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?AllocateApuMemory@CMcpxCore@DirectSound@@IAEJXZ ; DirectSound::CMcpxCore::AllocateApuMemory
  00019	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 197  : 
; 198  :     //
; 199  :     // Set up the front-end and voice processor
; 200  :     //
; 201  : 
; 202  :     if(SUCCEEDED(hr))

  0001c	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00020	7c 10		 jl	 SHORT $L39049

; 203  :     {
; 204  :         SetupFrontEndProcessor();

  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?SetupFrontEndProcessor@CMcpxCore@DirectSound@@IAEXXZ ; DirectSound::CMcpxCore::SetupFrontEndProcessor

; 205  :         SetupVoiceProcessor();

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?SetupVoiceProcessor@CMcpxCore@DirectSound@@IAEXXZ ; DirectSound::CMcpxCore::SetupVoiceProcessor
$L39049:

; 206  :     }
; 207  : 
; 208  :     //
; 209  :     // Set up the AC97
; 210  :     //
; 211  : 
; 212  :     if(SUCCEEDED(hr))

  00032	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00036	7c 0b		 jl	 SHORT $L39051

; 213  :     {
; 214  :         hr = SetupAc97();

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?SetupAc97@CMcpxCore@DirectSound@@IAEJXZ ; DirectSound::CMcpxCore::SetupAc97
  00040	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L39051:

; 215  :     }
; 216  : 
; 217  :     //
; 218  :     // Set up the DSPs
; 219  :     //
; 220  : 
; 221  :     if(SUCCEEDED(hr)) 

  00043	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00047	7c 08		 jl	 SHORT $L39053

; 222  :     {
; 223  :         SetupDSPs();

  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?SetupDSPs@CMcpxCore@DirectSound@@IAEXXZ ; DirectSound::CMcpxCore::SetupDSPs
$L39053:

; 224  :     }    
; 225  : 
; 226  :     //
; 227  :     // Set up the APU/ACI link
; 228  :     //
; 229  : 
; 230  :     if(SUCCEEDED(hr))

  00051	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00055	7c 0a		 jl	 SHORT $L39055

; 231  :     {
; 232  :         SetSetupEngineState(MCPX_SE_STATE_DEFAULT);

  00057	6a 01		 push	 1
  00059	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?SetSetupEngineState@CMcpxCore@DirectSound@@IAEXW4MCPX_SE_STATE@@@Z ; DirectSound::CMcpxCore::SetSetupEngineState
$L39055:

; 233  :     }
; 234  : 
; 235  :     //
; 236  :     // Start the ACI channels running
; 237  :     //
; 238  : 
; 239  :     if(SUCCEEDED(hr))

  00061	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00065	7c 1a		 jl	 SHORT $L39057

; 240  :     {       
; 241  :         m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->Run();

  00067	6a ff		 push	 -1
  00069	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0006f	e8 00 00 00 00	 call	 ?Run@CAc97Channel@DirectSound@@QAEXK@Z ; DirectSound::CAc97Channel::Run

; 242  :         m_Ac97.m_apChannels[AC97_CHANNELTYPE_ANALOG]->Run();

  00074	6a ff		 push	 -1
  00076	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0007c	e8 00 00 00 00	 call	 ?Run@CAc97Channel@DirectSound@@QAEXK@Z ; DirectSound::CAc97Channel::Run
$L39057:

; 243  :     }
; 244  : 
; 245  :     DPF_LEAVE_HRESULT(hr);
; 246  : 
; 247  : 	return hr;

  00081	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 248  : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
?Initialize@CMcpxCore@DirectSound@@QAEJXZ ENDP		; DirectSound::CMcpxCore::Initialize
DSOUND	ENDS
PUBLIC	?SetupGlobalProcessor@CMcpxCore@DirectSound@@IAEXXZ ; DirectSound::CMcpxCore::SetupGlobalProcessor
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpxcore.h
;	COMDAT ?SetupDSPs@CMcpxCore@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -4
?SetupDSPs@CMcpxCore@DirectSound@@IAEXXZ PROC NEAR	; DirectSound::CMcpxCore::SetupDSPs, COMDAT
; _this$ = ecx

; 374  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 375  :         SetupGlobalProcessor();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?SetupGlobalProcessor@CMcpxCore@DirectSound@@IAEXXZ ; DirectSound::CMcpxCore::SetupGlobalProcessor

; 376  : 
; 377  : #ifndef MCPX_BOOT_LIB
; 378  : 
; 379  :         SetupEncodeProcessor();
; 380  :         KeStallExecutionProcessor(10 * 1000);
; 381  : 
; 382  : #endif // MCPX_BOOT_LIB
; 383  : 
; 384  :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?SetupDSPs@CMcpxCore@DirectSound@@IAEXXZ ENDP		; DirectSound::CMcpxCore::SetupDSPs
DSOUND	ENDS
PUBLIC	?Terminate@CAc97Device@DirectSound@@QAEXXZ	; DirectSound::CAc97Device::Terminate
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\mcpxcore.cpp
;	COMDAT ?Reset@CMcpxCore@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Reset@CMcpxCore@DirectSound@@IAEXXZ PROC NEAR		; DirectSound::CMcpxCore::Reset, COMDAT
; _this$ = ecx

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 275  :     DPF_ENTER();
; 276  : 
; 277  :     //
; 278  :     // Shut down the AC'97
; 279  :     //
; 280  : 
; 281  :     m_Ac97.Terminate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 10	 add	 ecx, 16			; 00000010H
  0000d	e8 00 00 00 00	 call	 ?Terminate@CAc97Device@DirectSound@@QAEXXZ ; DirectSound::CAc97Device::Terminate

; 282  : 
; 283  :     //
; 284  :     // Shut down the APU components
; 285  :     //
; 286  : 
; 287  :     IdleVoiceProcessor(TRUE);

  00012	6a 01		 push	 1
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?IdleVoiceProcessor@CMcpxCore@DirectSound@@QAEHH@Z ; DirectSound::CMcpxCore::IdleVoiceProcessor

; 288  :     SetInterruptState(FALSE);

  0001c	6a 00		 push	 0
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?SetInterruptState@CMcpxCore@DirectSound@@IAEXH@Z ; DirectSound::CMcpxCore::SetInterruptState

; 289  :     SetPrivLockState(TRUE);

  00026	6a 01		 push	 1
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?SetPrivLockState@CMcpxCore@DirectSound@@IAEXH@Z ; DirectSound::CMcpxCore::SetPrivLockState

; 290  :     SetFrontEndState(MCPX_FE_STATE_HALTED);

  00030	6a 00		 push	 0
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?SetFrontEndState@CMcpxCore@DirectSound@@IAEXW4MCPX_FE_STATE@@@Z ; DirectSound::CMcpxCore::SetFrontEndState

; 291  :     SetSetupEngineState(MCPX_SE_STATE_OFF);

  0003a	6a 00		 push	 0
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?SetSetupEngineState@CMcpxCore@DirectSound@@IAEXW4MCPX_SE_STATE@@@Z ; DirectSound::CMcpxCore::SetSetupEngineState

; 292  : 
; 293  :     MCPX_REG_WRITE(NV_PAPU_TVL2D, 0xFFFF);

  00044	c7 05 54 20 80
	fe ff ff 00 00	 mov	 DWORD PTR ds:-25157548, 65535 ; 0000ffffH

; 294  :     MCPX_REG_WRITE(NV_PAPU_TVL3D, 0xFFFF);

  0004e	c7 05 60 20 80
	fe ff ff 00 00	 mov	 DWORD PTR ds:-25157536, 65535 ; 0000ffffH

; 295  :     MCPX_REG_WRITE(NV_PAPU_TVLMP, 0xFFFF);

  00058	c7 05 6c 20 80
	fe ff ff 00 00	 mov	 DWORD PTR ds:-25157524, 65535 ; 0000ffffH

; 296  : 
; 297  :     MCPX_REG_WRITE(NV_PAPU_CVL2D, 0xFFFF);

  00062	c7 05 58 20 80
	fe ff ff 00 00	 mov	 DWORD PTR ds:-25157544, 65535 ; 0000ffffH

; 298  :     MCPX_REG_WRITE(NV_PAPU_CVL3D, 0xFFFF);

  0006c	c7 05 64 20 80
	fe ff ff 00 00	 mov	 DWORD PTR ds:-25157532, 65535 ; 0000ffffH

; 299  :     MCPX_REG_WRITE(NV_PAPU_CVLMP, 0xFFFF);

  00076	c7 05 70 20 80
	fe ff ff 00 00	 mov	 DWORD PTR ds:-25157520, 65535 ; 0000ffffH

; 300  : 
; 301  :     MCPX_REG_WRITE(NV_PAPU_NVL2D, 0xFFFF);

  00080	c7 05 5c 20 80
	fe ff ff 00 00	 mov	 DWORD PTR ds:-25157540, 65535 ; 0000ffffH

; 302  :     MCPX_REG_WRITE(NV_PAPU_NVL3D, 0xFFFF);

  0008a	c7 05 68 20 80
	fe ff ff 00 00	 mov	 DWORD PTR ds:-25157528, 65535 ; 0000ffffH

; 303  :     MCPX_REG_WRITE(NV_PAPU_NVLMP, 0xFFFF);

  00094	c7 05 74 20 80
	fe ff ff 00 00	 mov	 DWORD PTR ds:-25157516, 65535 ; 0000ffffH

; 304  : 
; 305  :     MCPX_REG_WRITE(NV_PAPU_GPRST, 0);

  0009e	c7 05 fc ff 83
	fe 00 00 00 00	 mov	 DWORD PTR ds:-24903684, 0

; 306  :     MCPX_REG_WRITE(NV_PAPU_EPRST, 1);

  000a8	c7 05 fc ff 85
	fe 01 00 00 00	 mov	 DWORD PTR ds:-24772612, 1

; 307  : 
; 308  :     DPF_LEAVE_VOID();
; 309  : }

  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
?Reset@CMcpxCore@DirectSound@@IAEXXZ ENDP		; DirectSound::CMcpxCore::Reset
DSOUND	ENDS
PUBLIC	?ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ ; DirectSound::CMcpxCore::ResetGlobalCounters
; Function compile flags: /Odt
;	COMDAT ?SetupFrontEndProcessor@CMcpxCore@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -40
_rFeControl$ = -36
_rInterruptMask$ = -32
_dwForce$ = -24
_dwIgnore$ = -16
_rSeControl$ = -4
?SetupFrontEndProcessor@CMcpxCore@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxCore::SetupFrontEndProcessor, COMDAT
; _this$ = ecx

; 335  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 336  :     DWORD                   dwForce[2]      = { 0, 0 };

  00009	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _dwForce$[ebp], 0
  00010	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwForce$[ebp+4], 0

; 337  :     DWORD                   dwIgnore[2]     = { 0, 0 };

  00017	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwIgnore$[ebp], 0
  0001e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwIgnore$[ebp+4], 0

; 338  :     R_INTR                  rInterruptMask;
; 339  :     R_FE_CONTROL            rFeControl;
; 340  :     R_SE_CONTROL            rSeControl;
; 341  :     DWORD                   i;
; 342  : 
; 343  :     DPF_ENTER();
; 344  : 
; 345  :     //
; 346  :     // Setup interrupt masks
; 347  :     //
; 348  : 
; 349  :     rInterruptMask.uValue = 0;

  00025	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _rInterruptMask$[ebp], 0

; 350  :     rInterruptMask.General = NV_PAPU_IEN_GINTEN_DISABLED;

  0002c	8b 45 e0	 mov	 eax, DWORD PTR _rInterruptMask$[ebp]
  0002f	83 e0 fe	 and	 eax, -2			; fffffffeH
  00032	89 45 e0	 mov	 DWORD PTR _rInterruptMask$[ebp], eax

; 351  : 
; 352  : #ifdef MCPX_ENABLE_DELTA_WARNINGS
; 353  : 
; 354  :     rInterruptMask.DeltaWarning = NV_PAPU_IEN_DWINTEN_ENABLED;
; 355  : 
; 356  : #else // MCPX_ENABLE_DELTA_WARNINGS
; 357  : 
; 358  :     rInterruptMask.DeltaWarning = NV_PAPU_IEN_DWINTEN_DISABLED;

  00035	8b 4d e0	 mov	 ecx, DWORD PTR _rInterruptMask$[ebp]
  00038	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0003b	89 4d e0	 mov	 DWORD PTR _rInterruptMask$[ebp], ecx

; 359  : 
; 360  : #endif // MCPX_ENABLE_DELTA_WARNINGS
; 361  : 
; 362  :     rInterruptMask.DeltaPanic = NV_PAPU_IEN_DPINTEN_ENABLED;

  0003e	8b 55 e0	 mov	 edx, DWORD PTR _rInterruptMask$[ebp]
  00041	83 ca 08	 or	 edx, 8
  00044	89 55 e0	 mov	 DWORD PTR _rInterruptMask$[ebp], edx

; 363  :     rInterruptMask.FETrap = NV_PAPU_IEN_FETINTEN_ENABLED;

  00047	8b 45 e0	 mov	 eax, DWORD PTR _rInterruptMask$[ebp]
  0004a	83 c8 10	 or	 eax, 16			; 00000010H
  0004d	89 45 e0	 mov	 DWORD PTR _rInterruptMask$[ebp], eax

; 364  :     rInterruptMask.FENotify = NV_PAPU_IEN_FENINTEN_DISABLED;

  00050	8b 4d e0	 mov	 ecx, DWORD PTR _rInterruptMask$[ebp]
  00053	83 e1 df	 and	 ecx, -33		; ffffffdfH
  00056	89 4d e0	 mov	 DWORD PTR _rInterruptMask$[ebp], ecx

; 365  :     rInterruptMask.FEVoice = NV_PAPU_IEN_FEVINTEN_ENABLED;

  00059	8b 55 e0	 mov	 edx, DWORD PTR _rInterruptMask$[ebp]
  0005c	83 ca 40	 or	 edx, 64			; 00000040H
  0005f	89 55 e0	 mov	 DWORD PTR _rInterruptMask$[ebp], edx

; 366  :     rInterruptMask.FEMethodOverFlow = NV_PAPU_IEN_FEOINTEN_ENABLED;

  00062	8b 45 e0	 mov	 eax, DWORD PTR _rInterruptMask$[ebp]
  00065	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  0006a	89 45 e0	 mov	 DWORD PTR _rInterruptMask$[ebp], eax

; 367  :     rInterruptMask.GPMailbox = NV_PAPU_IEN_GPMINTEN_DISABLED;

  0006d	8b 4d e0	 mov	 ecx, DWORD PTR _rInterruptMask$[ebp]
  00070	81 e1 ff fe ff
	ff		 and	 ecx, -257		; fffffeffH
  00076	89 4d e0	 mov	 DWORD PTR _rInterruptMask$[ebp], ecx

; 368  :     rInterruptMask.GPNotify = NV_PAPU_IEN_GPNINTEN_DISABLED;

  00079	8b 55 e0	 mov	 edx, DWORD PTR _rInterruptMask$[ebp]
  0007c	81 e2 ff fd ff
	ff		 and	 edx, -513		; fffffdffH
  00082	89 55 e0	 mov	 DWORD PTR _rInterruptMask$[ebp], edx

; 369  :     rInterruptMask.EPMailbox = NV_PAPU_IEN_EPMINTEN_DISABLED;

  00085	8b 45 e0	 mov	 eax, DWORD PTR _rInterruptMask$[ebp]
  00088	25 ff fb ff ff	 and	 eax, -1025		; fffffbffH
  0008d	89 45 e0	 mov	 DWORD PTR _rInterruptMask$[ebp], eax

; 370  :     rInterruptMask.EPNotify = NV_PAPU_IEN_EPNINTEN_DISABLED;

  00090	8b 4d e0	 mov	 ecx, DWORD PTR _rInterruptMask$[ebp]
  00093	81 e1 ff f7 ff
	ff		 and	 ecx, -2049		; fffff7ffH
  00099	89 4d e0	 mov	 DWORD PTR _rInterruptMask$[ebp], ecx

; 371  : 
; 372  :     MCPX_REG_WRITE(NV_PAPU_IEN, rInterruptMask.uValue);

  0009c	8b 55 e0	 mov	 edx, DWORD PTR _rInterruptMask$[ebp]
  0009f	89 15 04 10 80
	fe		 mov	 DWORD PTR ds:-25161724, edx

; 373  : 
; 374  :     //
; 375  :     // Set default FE control bits
; 376  :     //
; 377  : 
; 378  :     rFeControl.uValue = 0;

  000a5	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _rFeControl$[ebp], 0

; 379  :     rFeControl.TrapOnNotifier = NV_PAPU_FECTL_FENINT_ENABLED;

  000ac	8b 45 dc	 mov	 eax, DWORD PTR _rFeControl$[ebp]
  000af	83 c8 08	 or	 eax, 8
  000b2	89 45 dc	 mov	 DWORD PTR _rFeControl$[ebp], eax

; 380  :     rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;

  000b5	8b 4d dc	 mov	 ecx, DWORD PTR _rFeControl$[ebp]
  000b8	81 e1 1f ff ff
	ff		 and	 ecx, -225		; ffffff1fH
  000be	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  000c4	89 4d dc	 mov	 DWORD PTR _rFeControl$[ebp], ecx

; 381  :     rFeControl.EnableLock = NV_PAPU_FECTL_FEMETH_PRIVLOCK_NOT_DISABLED;

  000c7	8b 55 dc	 mov	 edx, DWORD PTR _rFeControl$[ebp]
  000ca	81 e2 ff df ff
	ff		 and	 edx, -8193		; ffffdfffH
  000d0	89 55 dc	 mov	 DWORD PTR _rFeControl$[ebp], edx

; 382  : 
; 383  :     MCPX_REG_WRITE(NV_PAPU_FECTL, rFeControl.uValue);

  000d3	8b 45 dc	 mov	 eax, DWORD PTR _rFeControl$[ebp]
  000d6	a3 00 11 80 fe	 mov	 DWORD PTR ds:-25161472, eax

; 384  : 
; 385  :     //
; 386  :     // Set default SE control bits
; 387  :     //
; 388  :     
; 389  :     rSeControl.uValue = 0;

  000db	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _rSeControl$[ebp], 0

; 390  :     rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_OFF;

  000e2	8b 4d fc	 mov	 ecx, DWORD PTR _rSeControl$[ebp]
  000e5	83 e1 e7	 and	 ecx, -25		; ffffffe7H
  000e8	89 4d fc	 mov	 DWORD PTR _rSeControl$[ebp], ecx

; 391  : 
; 392  :     MCPX_REG_WRITE(NV_PAPU_SECTL, rSeControl.uValue);

  000eb	8b 55 fc	 mov	 edx, DWORD PTR _rSeControl$[ebp]
  000ee	89 15 00 20 80
	fe		 mov	 DWORD PTR ds:-25157632, edx

; 393  : 
; 394  :     //
; 395  :     // We're overriding the internal SE2FE_IDLE_MESSAGE because a couple
; 396  :     // of things don't work the way they should.  First, the hardware has
; 397  :     // a race condition that can cause voice list corruption if a VoiceOn
; 398  :     // method is received with an antecedent voice that has already gone
; 399  :     // idle.  Second, VoiceRelease causes a PERSIST voice to be removed
; 400  :     // from the processing list when the envelope completes.  By overriding
; 401  :     // SE2FE_IDLE_VOICE in software, we can address both of these issues
; 402  :     //
; 403  : 
; 404  :     dwForce[1] |= MCPX_MAKE_REG_VALUE(1, NV_PAPU_FETFORCE1_SE2FE_IDLE_VOICE);

  000f4	8b 45 ec	 mov	 eax, DWORD PTR _dwForce$[ebp+4]
  000f7	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  000fc	89 45 ec	 mov	 DWORD PTR _dwForce$[ebp+4], eax

; 405  : 
; 406  :     MCPX_REG_WRITE(NV_PAPU_FETFORCE0, dwForce[0]);

  000ff	8b 4d e8	 mov	 ecx, DWORD PTR _dwForce$[ebp]
  00102	89 0d 00 15 80
	fe		 mov	 DWORD PTR ds:-25160448, ecx

; 407  :     MCPX_REG_WRITE(NV_PAPU_FETFORCE1, dwForce[1]);

  00108	8b 55 ec	 mov	 edx, DWORD PTR _dwForce$[ebp+4]
  0010b	89 15 04 15 80
	fe		 mov	 DWORD PTR ds:-25160444, edx

; 408  : 
; 409  :     //
; 410  :     // SET_VOICE_TAR_Hrtf has a bug in it that prevents us from setting 
; 411  :     // a NULL HRTF filter handle (0xFFFF).  This is strictly a parameter
; 412  :     // validation bug since NULL is a valid value.
; 413  :     //
; 414  :     // VoiceOn will cause a BAD_LIST_POINTER trap if the VP isn't idle
; 415  :     // and we use the INHERIT list type.  We're working around this in
; 416  :     // CMcpxVoiceClient::ActivateVoice.
; 417  :     //
; 418  : 
; 419  :     dwIgnore[0] |= MCPX_MAKE_REG_VALUE(1, NV_PAPU_FETIGNORE0_SET_VOICE_TAR_HRTF);

  00111	8b 45 f0	 mov	 eax, DWORD PTR _dwIgnore$[ebp]
  00114	0d 00 00 80 00	 or	 eax, 8388608		; 00800000H
  00119	89 45 f0	 mov	 DWORD PTR _dwIgnore$[ebp], eax

; 420  :     dwIgnore[0] |= MCPX_MAKE_REG_VALUE(1, NV_PAPU_FETIGNORE0_VOICE_ON);

  0011c	8b 4d f0	 mov	 ecx, DWORD PTR _dwIgnore$[ebp]
  0011f	83 c9 40	 or	 ecx, 64			; 00000040H
  00122	89 4d f0	 mov	 DWORD PTR _dwIgnore$[ebp], ecx

; 421  : 
; 422  :     MCPX_REG_WRITE(NV_PAPU_FETIGNORE0, dwIgnore[0]);

  00125	8b 55 f0	 mov	 edx, DWORD PTR _dwIgnore$[ebp]
  00128	89 15 08 15 80
	fe		 mov	 DWORD PTR ds:-25160440, edx

; 423  :     MCPX_REG_WRITE(NV_PAPU_FETIGNORE1, dwIgnore[1]);

  0012e	8b 45 f4	 mov	 eax, DWORD PTR _dwIgnore$[ebp+4]
  00131	a3 0c 15 80 fe	 mov	 DWORD PTR ds:-25160436, eax

; 424  : 
; 425  :     //
; 426  :     // Initialize global counts so we can track how far ahead the output 
; 427  :     // counter stays from the input
; 428  :     //
; 429  : 
; 430  :     ResetGlobalCounters();

  00136	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00139	e8 00 00 00 00	 call	 ?ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ ; DirectSound::CMcpxCore::ResetGlobalCounters

; 431  :     
; 432  :     //
; 433  :     // Set up boundaries
; 434  :     //
; 435  : 
; 436  :     MCPX_REG_WRITE(NV_PAPU_FEMAXV, MCPX_HW_MAX_VOICES - 1);

  0013e	c7 05 04 11 80
	fe ff 00 00 00	 mov	 DWORD PTR ds:-25161468, 255 ; 000000ffH

; 437  : 	MCPX_REG_WRITE(NV_PAPU_FEMAXTV, MCPX_HW_MAX_3D_VOICES - 1);

  00148	c7 05 08 11 80
	fe 3f 00 00 00	 mov	 DWORD PTR ds:-25161464, 63 ; 0000003fH

; 438  : 	MCPX_REG_WRITE(NV_PAPU_FEMAXHT, MCPX_HW_MAX_3D_VOICES * MCPX_HW_3DFILTERS_PER_VOICE - 1);

  00152	c7 05 1c 11 80
	fe 7f 00 00 00	 mov	 DWORD PTR ds:-25161444, 127 ; 0000007fH

; 439  : 	MCPX_REG_WRITE(NV_PAPU_FEMAXSESSL, MCPX_HW_MAX_SSL_PRDS - 1);

  0015c	c7 05 24 11 80
	fe ff 1f 00 00	 mov	 DWORD PTR ds:-25161436, 8191 ; 00001fffH

; 440  : 	MCPX_REG_WRITE(NV_PAPU_FEMAXSESGE, MCPX_HW_MAX_BUFFER_PRDS - 1);

  00166	c7 05 38 11 80
	fe ff 07 00 00	 mov	 DWORD PTR ds:-25161416, 2047 ; 000007ffH

; 441  : 	MCPX_REG_WRITE(NV_PAPU_FEMAXMB, MCPX_HW_MAX_SUBMIX_BINS);

  00170	c7 05 58 11 80
	fe 20 00 00 00	 mov	 DWORD PTR ds:-25161384, 32 ; 00000020H

; 442  : 
; 443  :     MCPX_REG_WRITE(NV_PAPU_FESESSLCTXPA, 0);

  0017a	c7 05 2c 11 80
	fe 00 00 00 00	 mov	 DWORD PTR ds:-25161428, 0

; 444  :     MCPX_REG_WRITE(NV_PAPU_FESESSLMAXOFF, MCPX_MAX_VALID_ADDRESS);

  00184	c7 05 30 11 80
	fe 00 00 00 08	 mov	 DWORD PTR ds:-25161424, 134217728 ; 08000000H

; 445  : 
; 446  :     MCPX_REG_WRITE(NV_PAPU_FESESGECTXPA, 0);

  0018e	c7 05 40 11 80
	fe 00 00 00 00	 mov	 DWORD PTR ds:-25161408, 0

; 447  :     MCPX_REG_WRITE(NV_PAPU_FESESGEMAXOFF, MCPX_MAX_VALID_ADDRESS);

  00198	c7 05 44 11 80
	fe 00 00 00 08	 mov	 DWORD PTR ds:-25161404, 134217728 ; 08000000H

; 448  : 
; 449  :     MCPX_REG_WRITE(NV_PAPU_FEGPSGECTXPA, 0);

  001a2	c7 05 50 11 80
	fe 00 00 00 00	 mov	 DWORD PTR ds:-25161392, 0

; 450  :     MCPX_REG_WRITE(NV_PAPU_FEGPSGEMAXOFF, MCPX_MAX_VALID_ADDRESS);

  001ac	c7 05 54 11 80
	fe 00 00 00 08	 mov	 DWORD PTR ds:-25161388, 134217728 ; 08000000H

; 451  : 
; 452  :     //
; 453  :     // Unlock the front end and setup engine
; 454  :     //
; 455  : 
; 456  :     SetPrivLockState(FALSE);

  001b6	6a 00		 push	 0
  001b8	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001bb	e8 00 00 00 00	 call	 ?SetPrivLockState@CMcpxCore@DirectSound@@IAEXH@Z ; DirectSound::CMcpxCore::SetPrivLockState

; 457  :     SetFrontEndState(MCPX_FE_STATE_FREE_RUNNING);

  001c0	6a 01		 push	 1
  001c2	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c5	e8 00 00 00 00	 call	 ?SetFrontEndState@CMcpxCore@DirectSound@@IAEXW4MCPX_FE_STATE@@@Z ; DirectSound::CMcpxCore::SetFrontEndState

; 458  :     SetFrontEndState(MCPX_FE_STATE_ISO);

  001ca	6a 02		 push	 2
  001cc	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001cf	e8 00 00 00 00	 call	 ?SetFrontEndState@CMcpxCore@DirectSound@@IAEXW4MCPX_FE_STATE@@@Z ; DirectSound::CMcpxCore::SetFrontEndState

; 459  :     SetSetupEngineState(MCPX_SE_STATE_ISO);

  001d4	6a 04		 push	 4
  001d6	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d9	e8 00 00 00 00	 call	 ?SetSetupEngineState@CMcpxCore@DirectSound@@IAEXW4MCPX_SE_STATE@@@Z ; DirectSound::CMcpxCore::SetSetupEngineState

; 460  : 
; 461  :     DPF_LEAVE_VOID();
; 462  : }

  001de	8b e5		 mov	 esp, ebp
  001e0	5d		 pop	 ebp
  001e1	c3		 ret	 0
?SetupFrontEndProcessor@CMcpxCore@DirectSound@@IAEXXZ ENDP ; DirectSound::CMcpxCore::SetupFrontEndProcessor
DSOUND	ENDS
PUBLIC	?__AddRef@DirectSound@@YGPAVCMcpxSlopMemoryHeap@1@PAV21@@Z ; DirectSound::__AddRef
PUBLIC	??0CMcpxSlopMemoryHeap@DirectSound@@QAE@XZ	; DirectSound::CMcpxSlopMemoryHeap::CMcpxSlopMemoryHeap
PUBLIC	?AddRun@CMcpxSlopMemoryHeap@DirectSound@@QAEHPAXKK@Z ; DirectSound::CMcpxSlopMemoryHeap::AddRun
PUBLIC	?AllocateContext@CMcpxCore@DirectSound@@SGJPAUMCPX_ALLOC_CONTEXT@@KK@Z ; DirectSound::CMcpxCore::AllocateContext
EXTRN	?AC3GetTotalScratchSize@CMcpxEPDspManager@DirectSound@@SGKXZ:NEAR ; DirectSound::CMcpxEPDspManager::AC3GetTotalScratchSize
; Function compile flags: /Odt
;	COMDAT ?AllocateApuMemory@CMcpxCore@DirectSound@@IAEJXZ
DSOUND	SEGMENT
tv235 = -152
_this$ = -148
$T42356 = -144
_hr$ = -140
_Alloc$ = -136
_i$ = -4
?AllocateApuMemory@CMcpxCore@DirectSound@@IAEJXZ PROC NEAR ; DirectSound::CMcpxCore::AllocateApuMemory, COMDAT
; _this$ = ecx

; 488  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 489  :     BEGIN_DEFINE_STRUCT()
; 490  :         DWORD               Size;
; 491  :         DWORD               Alignment;
; 492  :     END_DEFINE_STRUCT(MCPX_ALLOC_CTX);
; 493  : 
; 494  :     HRESULT                 hr                      = DS_OK;

  0000f	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _hr$[ebp], 0

; 495  :     MCPX_ALLOC_CTX          Alloc[MCPX_MEM_COUNT];
; 496  :     DWORD                   i;
; 497  : 
; 498  :     DPF_ENTER();
; 499  : 
; 500  :     //
; 501  :     // Calculate allocation sizes and alignment.  We piggy-back the SGE heap
; 502  :     // run markers on the magic write buffer since the magic write only needs
; 503  :     // a single DWORD.  When we're building the boot sound, we allocate memory
; 504  :     // for the I3DL2 reverb in the GP scratch.
; 505  :     //
; 506  :     // WARNING: to use some of the slop memory allocated due to alignement
; 507  :     // restrictions, we're piggybacking some data structures on these
; 508  :     // buffers.  Use extreme care when changing any of these sizes.
; 509  :     //
; 510  : 
; 511  :     for(i = 0, Alloc[MCPX_MEM_GPOUTPUT].Size = 0; i < NUMELMS(m_adwGPOutputBufferSizes); i++)

  00019	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00020	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _Alloc$[ebp], 0
  0002a	eb 09		 jmp	 SHORT $L39157
$L39158:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002f	83 c0 01	 add	 eax, 1
  00032	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L39157:
  00035	83 7d fc 01	 cmp	 DWORD PTR _i$[ebp], 1
  00039	73 18		 jae	 SHORT $L39159

; 512  :     {
; 513  :         ASSERT(!(m_adwGPOutputBufferSizes[i] % PAGE_SIZE));
; 514  :         Alloc[MCPX_MEM_GPOUTPUT].Size += m_adwGPOutputBufferSizes[i];

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0003e	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _Alloc$[ebp]
  00044	03 14 8d 00 00
	00 00		 add	 edx, DWORD PTR ?m_adwGPOutputBufferSizes@CMcpxCore@DirectSound@@2QBKB[ecx*4]
  0004b	89 95 78 ff ff
	ff		 mov	 DWORD PTR _Alloc$[ebp], edx

; 515  :     }

  00051	eb d9		 jmp	 SHORT $L39158
$L39159:

; 516  : 
; 517  :     Alloc[MCPX_MEM_GPOUTPUT].Alignment = PAGE_SIZE;

  00053	c7 85 7c ff ff
	ff 00 10 00 00	 mov	 DWORD PTR _Alloc$[ebp+4], 4096 ; 00001000H

; 518  : 
; 519  :     for(i = 0, Alloc[MCPX_MEM_EPOUTPUT].Size = 0; i < NUMELMS(m_adwEPOutputBufferSizes); i++)

  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00064	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _Alloc$[ebp+8], 0
  0006b	eb 09		 jmp	 SHORT $L39160
$L39161:
  0006d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00070	83 c0 01	 add	 eax, 1
  00073	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L39160:
  00076	83 7d fc 02	 cmp	 DWORD PTR _i$[ebp], 2
  0007a	73 12		 jae	 SHORT $L39162

; 520  :     {
; 521  :         ASSERT(!(m_adwEPOutputBufferSizes[i] % PAGE_SIZE));
; 522  :         Alloc[MCPX_MEM_EPOUTPUT].Size += m_adwEPOutputBufferSizes[i];

  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0007f	8b 55 80	 mov	 edx, DWORD PTR _Alloc$[ebp+8]
  00082	03 14 8d 00 00
	00 00		 add	 edx, DWORD PTR ?m_adwEPOutputBufferSizes@CMcpxCore@DirectSound@@2QBKB[ecx*4]
  00089	89 55 80	 mov	 DWORD PTR _Alloc$[ebp+8], edx

; 523  :     }

  0008c	eb df		 jmp	 SHORT $L39161
$L39162:

; 524  : 
; 525  :     Alloc[MCPX_MEM_EPOUTPUT].Alignment = PAGE_SIZE;

  0008e	c7 45 84 00 10
	00 00		 mov	 DWORD PTR _Alloc$[ebp+12], 4096 ; 00001000H

; 526  : 
; 527  :     Alloc[MCPX_MEM_MAGICWRITE].Size = sizeof(DWORD);

  00095	c7 45 88 04 00
	00 00		 mov	 DWORD PTR _Alloc$[ebp+16], 4

; 528  :     Alloc[MCPX_MEM_MAGICWRITE].Alignment = PAGE_SIZE;

  0009c	c7 45 8c 00 10
	00 00		 mov	 DWORD PTR _Alloc$[ebp+20], 4096 ; 00001000H

; 529  : 
; 530  :     Alloc[MCPX_MEM_VOICE].Size = MCPX_HW_MAX_VOICES * NV_PAVS_SIZE;

  000a3	c7 45 90 00 80
	00 00		 mov	 DWORD PTR _Alloc$[ebp+24], 32768 ; 00008000H

; 531  :     Alloc[MCPX_MEM_VOICE].Alignment = 0x8000;

  000aa	c7 45 94 00 80
	00 00		 mov	 DWORD PTR _Alloc$[ebp+28], 32768 ; 00008000H

; 532  : 
; 533  :     Alloc[MCPX_MEM_NOTIFIERS].Size = sizeof(MCPX_HW_NOTIFICATION) * MCPX_HW_MAX_NOTIFIERS;

  000b1	c7 45 98 20 40
	00 00		 mov	 DWORD PTR _Alloc$[ebp+32], 16416 ; 00004020H

; 534  :     Alloc[MCPX_MEM_NOTIFIERS].Alignment = 0x4000;

  000b8	c7 45 9c 00 40
	00 00		 mov	 DWORD PTR _Alloc$[ebp+36], 16384 ; 00004000H

; 535  : 
; 536  :     Alloc[MCPX_MEM_INPUTSGE].Size = MCPX_HW_MAX_BUFFER_PRDS * NV_PSGE_SIZE;

  000bf	c7 45 a0 00 40
	00 00		 mov	 DWORD PTR _Alloc$[ebp+40], 16384 ; 00004000H

; 537  :     Alloc[MCPX_MEM_INPUTSGE].Alignment = 0x4000;

  000c6	c7 45 a4 00 40
	00 00		 mov	 DWORD PTR _Alloc$[ebp+44], 16384 ; 00004000H

; 538  : 
; 539  :     Alloc[MCPX_MEM_INPUTPRD].Size = MCPX_HW_MAX_SSL_PRDS * NV_PSGE_SIZE;

  000cd	c7 45 a8 00 00
	01 00		 mov	 DWORD PTR _Alloc$[ebp+48], 65536 ; 00010000H

; 540  :     Alloc[MCPX_MEM_INPUTPRD].Alignment = 0x4000;

  000d4	c7 45 ac 00 40
	00 00		 mov	 DWORD PTR _Alloc$[ebp+52], 16384 ; 00004000H

; 541  : 
; 542  :     Alloc[MCPX_MEM_HRTFTARGET].Size = MCPX_HW_MAX_3D_VOICES * MCPX_HW_3DFILTERS_PER_VOICE * NV_PAHRTFT_SIZE;

  000db	c7 45 b0 00 20
	00 00		 mov	 DWORD PTR _Alloc$[ebp+56], 8192 ; 00002000H

; 543  :     Alloc[MCPX_MEM_HRTFTARGET].Alignment = 0x4000;

  000e2	c7 45 b4 00 40
	00 00		 mov	 DWORD PTR _Alloc$[ebp+60], 16384 ; 00004000H

; 544  : 
; 545  :     Alloc[MCPX_MEM_HRTFCURRENT].Size = MCPX_HW_MAX_3D_VOICES * NV_PAHRTFC_SIZE;

  000e9	c7 45 b8 00 20
	00 00		 mov	 DWORD PTR _Alloc$[ebp+64], 8192 ; 00002000H

; 546  :     Alloc[MCPX_MEM_HRTFCURRENT].Alignment = 0x4000;

  000f0	c7 45 bc 00 40
	00 00		 mov	 DWORD PTR _Alloc$[ebp+68], 16384 ; 00004000H

; 547  : 
; 548  :     Alloc[MCPX_MEM_GPOUTPUTSGE].Size = Alloc[MCPX_MEM_GPOUTPUT].Size / PAGE_SIZE * NV_PSGE_SIZE;

  000f7	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _Alloc$[ebp]
  000fd	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  00100	c1 e0 03	 shl	 eax, 3
  00103	89 45 c0	 mov	 DWORD PTR _Alloc$[ebp+72], eax

; 549  :     Alloc[MCPX_MEM_GPOUTPUTSGE].Alignment = 0x4000;

  00106	c7 45 c4 00 40
	00 00		 mov	 DWORD PTR _Alloc$[ebp+76], 16384 ; 00004000H

; 550  : 
; 551  :     Alloc[MCPX_MEM_EPOUTPUTSGE].Size = Alloc[MCPX_MEM_EPOUTPUT].Size / PAGE_SIZE * NV_PSGE_SIZE;

  0010d	8b 4d 80	 mov	 ecx, DWORD PTR _Alloc$[ebp+8]
  00110	c1 e9 0c	 shr	 ecx, 12			; 0000000cH
  00113	c1 e1 03	 shl	 ecx, 3
  00116	89 4d c8	 mov	 DWORD PTR _Alloc$[ebp+80], ecx

; 552  :     Alloc[MCPX_MEM_EPOUTPUTSGE].Alignment = 0x4000;

  00119	c7 45 cc 00 40
	00 00		 mov	 DWORD PTR _Alloc$[ebp+84], 16384 ; 00004000H

; 553  : 
; 554  :     Alloc[MCPX_MEM_GPMULTIPASS].Size = MCPX_HW_MULTIPASS_NUM_PAGES * PAGE_SIZE;

  00120	c7 45 d0 00 10
	00 00		 mov	 DWORD PTR _Alloc$[ebp+88], 4096 ; 00001000H

; 555  :     Alloc[MCPX_MEM_GPMULTIPASS].Alignment = 0x4000;

  00127	c7 45 d4 00 40
	00 00		 mov	 DWORD PTR _Alloc$[ebp+92], 16384 ; 00004000H

; 556  : 
; 557  :     Alloc[MCPX_MEM_GPSCRATCH].Size = ((MCPX_HW_MULTIPASS_NUM_PAGES + MCPX_HW_AC3_NUM_INPUT_PAGES) * PAGE_SIZE) + MCPX_GLOBAL_PROC_SCRATCH_SIZE;

  0012e	c7 45 d8 00 c0
	00 00		 mov	 DWORD PTR _Alloc$[ebp+96], 49152 ; 0000c000H

; 558  :     Alloc[MCPX_MEM_GPSCRATCH].Alignment = 0x4000;

  00135	c7 45 dc 00 40
	00 00		 mov	 DWORD PTR _Alloc$[ebp+100], 16384 ; 00004000H

; 559  : 
; 560  : #ifdef MCPX_BOOT_LIB
; 561  :          
; 562  :     Alloc[MCPX_MEM_GPSCRATCH].Size += 0x600000;

  0013c	8b 55 d8	 mov	 edx, DWORD PTR _Alloc$[ebp+96]
  0013f	81 c2 00 00 60
	00		 add	 edx, 6291456		; 00600000H
  00145	89 55 d8	 mov	 DWORD PTR _Alloc$[ebp+96], edx

; 563  : 
; 564  : #endif // MCPX_BOOT_LIB
; 565  : 
; 566  :     Alloc[MCPX_MEM_GPSCRATCHSGE].Size = (MCPX_HW_MAX_FX_SCRATCH_PAGES + (Alloc[MCPX_MEM_GPSCRATCH].Size / PAGE_SIZE)) * NV_PSGE_SIZE;

  00148	8b 45 d8	 mov	 eax, DWORD PTR _Alloc$[ebp+96]
  0014b	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  0014e	8d 0c c5 00 10
	00 00		 lea	 ecx, DWORD PTR [eax*8+4096]
  00155	89 4d e0	 mov	 DWORD PTR _Alloc$[ebp+104], ecx

; 567  :     Alloc[MCPX_MEM_GPSCRATCHSGE].Alignment = 0x4000;

  00158	c7 45 e4 00 40
	00 00		 mov	 DWORD PTR _Alloc$[ebp+108], 16384 ; 00004000H

; 568  : 
; 569  :     Alloc[MCPX_MEM_EPSCRATCH].Size = ((CMcpxEPDspManager::AC3GetTotalScratchSize() / PAGE_SIZE) + 1 + MCPX_HW_AC3_NUM_INPUT_PAGES) * PAGE_SIZE;

  0015f	e8 00 00 00 00	 call	 ?AC3GetTotalScratchSize@CMcpxEPDspManager@DirectSound@@SGKXZ ; DirectSound::CMcpxEPDspManager::AC3GetTotalScratchSize
  00164	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  00167	83 c0 04	 add	 eax, 4
  0016a	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  0016d	89 45 e8	 mov	 DWORD PTR _Alloc$[ebp+112], eax

; 570  :     Alloc[MCPX_MEM_EPSCRATCH].Alignment = 0x4000;

  00170	c7 45 ec 00 40
	00 00		 mov	 DWORD PTR _Alloc$[ebp+116], 16384 ; 00004000H

; 571  : 
; 572  :     Alloc[MCPX_MEM_EPSCRATCHSGE].Size = Alloc[MCPX_MEM_EPSCRATCH].Size / PAGE_SIZE * NV_PSGE_SIZE;

  00177	8b 55 e8	 mov	 edx, DWORD PTR _Alloc$[ebp+112]
  0017a	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  0017d	c1 e2 03	 shl	 edx, 3
  00180	89 55 f0	 mov	 DWORD PTR _Alloc$[ebp+120], edx

; 573  :     Alloc[MCPX_MEM_EPSCRATCHSGE].Alignment = 0x4000;

  00183	c7 45 f4 00 40
	00 00		 mov	 DWORD PTR _Alloc$[ebp+124], 16384 ; 00004000H

; 574  : 
; 575  : #ifdef ENABLE_SLOP_MEMORY_RECOVERY
; 576  : 
; 577  :     //
; 578  :     // Allocate the heap to track unused physical memory so we can reuse it
; 579  :     // later
; 580  :     //
; 581  : 
; 582  :     if(CMcpxSlopMemoryHeap::m_pSlopMemoryHeap)

  0018a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A, 0 ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap
  00191	74 16		 je	 SHORT $L39168

; 583  :     {
; 584  :         m_pSlopMemoryHeap = ADDREF(CMcpxSlopMemoryHeap::m_pSlopMemoryHeap);

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 ?__AddRef@DirectSound@@YGPAVCMcpxSlopMemoryHeap@1@PAV21@@Z ; DirectSound::__AddRef
  0019e	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 585  :     }
; 586  :     else

  001a7	eb 5e		 jmp	 SHORT $L39173
$L39168:

; 587  :     {
; 588  :         hr = HRFROMP(m_pSlopMemoryHeap = NEW(CMcpxSlopMemoryHeap));

  001a9	6a 1c		 push	 28			; 0000001cH
  001ab	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001b0	83 c4 04	 add	 esp, 4
  001b3	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T42356[ebp], eax
  001b9	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR $T42356[ebp], 0
  001c0	74 13		 je	 SHORT $L42357
  001c2	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR $T42356[ebp]
  001c8	e8 00 00 00 00	 call	 ??0CMcpxSlopMemoryHeap@DirectSound@@QAE@XZ ; DirectSound::CMcpxSlopMemoryHeap::CMcpxSlopMemoryHeap
  001cd	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv235[ebp], eax
  001d3	eb 0a		 jmp	 SHORT $L42358
$L42357:
  001d5	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv235[ebp], 0
$L42358:
  001df	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001e5	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv235[ebp]
  001eb	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001ee	33 c9		 xor	 ecx, ecx
  001f0	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR tv235[ebp], 0
  001f7	0f 95 c1	 setne	 cl
  001fa	49		 dec	 ecx
  001fb	81 e1 0e 00 07
	80		 and	 ecx, -2147024882	; 8007000eH
  00201	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _hr$[ebp], ecx
$L39173:

; 589  :     }
; 590  : 
; 591  : #endif // ENABLE_SLOP_MEMORY_RECOVERY
; 592  : 
; 593  :     //
; 594  :     // Allocate APU memory
; 595  :     //
; 596  : 
; 597  :     for(i = 0; (i < NUMELMS(Alloc)) && SUCCEEDED(hr); i++)

  00207	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0020e	eb 09		 jmp	 SHORT $L39179
$L39180:
  00210	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00213	83 c2 01	 add	 edx, 1
  00216	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L39179:
  00219	83 7d fc 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  0021d	0f 83 a7 00 00
	00		 jae	 $L39181
  00223	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  0022a	0f 8c 9a 00 00
	00		 jl	 $L39181

; 598  :     {
; 599  :         m_ctxMemory[i].Size = Alloc[i].Size;

  00230	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00233	c1 e0 04	 shl	 eax, 4
  00236	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00239	8b 94 cd 78 ff
	ff ff		 mov	 edx, DWORD PTR _Alloc$[ebp+ecx*8]
  00240	89 90 08 00 00
	00		 mov	 DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A[eax+8], edx

; 600  :         
; 601  :         hr = AllocateContext(&m_ctxMemory[i], Alloc[i].Alignment, PAGE_READWRITE);

  00246	6a 04		 push	 4
  00248	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0024b	8b 8c c5 7c ff
	ff ff		 mov	 ecx, DWORD PTR _Alloc$[ebp+eax*8+4]
  00252	51		 push	 ecx
  00253	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00256	c1 e2 04	 shl	 edx, 4
  00259	81 c2 00 00 00
	00		 add	 edx, OFFSET FLAT:?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A ; DirectSound::CMcpxCore::m_ctxMemory
  0025f	52		 push	 edx
  00260	e8 00 00 00 00	 call	 ?AllocateContext@CMcpxCore@DirectSound@@SGJPAUMCPX_ALLOC_CONTEXT@@KK@Z ; DirectSound::CMcpxCore::AllocateContext
  00265	89 85 74 ff ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 602  : 
; 603  : #ifdef ENABLE_SLOP_MEMORY_RECOVERY
; 604  : 
; 605  :         if(SUCCEEDED(hr))

  0026b	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  00272	7c 51		 jl	 SHORT $L39183

; 606  :         {
; 607  :             m_ctxMemory[i].fOwned = !m_pSlopMemoryHeap->AddRun(m_ctxMemory[i].VirtualAddress, BLOCKALIGNPAD(m_ctxMemory[i].Size, PAGE_SIZE), m_ctxMemory[i].Size);

  00274	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00277	c1 e0 04	 shl	 eax, 4
  0027a	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A[eax+8]
  00280	51		 push	 ecx
  00281	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00284	c1 e2 04	 shl	 edx, 4
  00287	8b 82 08 00 00
	00		 mov	 eax, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A[edx+8]
  0028d	05 ff 0f 00 00	 add	 eax, 4095		; 00000fffH
  00292	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  00295	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00298	50		 push	 eax
  00299	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0029c	c1 e1 04	 shl	 ecx, 4
  0029f	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A[ecx]
  002a5	52		 push	 edx
  002a6	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002ac	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002af	e8 00 00 00 00	 call	 ?AddRun@CMcpxSlopMemoryHeap@DirectSound@@QAEHPAXKK@Z ; DirectSound::CMcpxSlopMemoryHeap::AddRun
  002b4	f7 d8		 neg	 eax
  002b6	1b c0		 sbb	 eax, eax
  002b8	40		 inc	 eax
  002b9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  002bc	c1 e1 04	 shl	 ecx, 4
  002bf	89 81 0c 00 00
	00		 mov	 DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A[ecx+12], eax
$L39183:

; 608  :         }
; 609  : 
; 610  : #endif // ENABLE_SLOP_MEMORY_RECOVERY
; 611  : 
; 612  :     }

  002c5	e9 46 ff ff ff	 jmp	 $L39180
$L39181:

; 613  : 
; 614  :     DPF_LEAVE_HRESULT(hr);
; 615  : 
; 616  :     return hr;

  002ca	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _hr$[ebp]

; 617  : }

  002d0	8b e5		 mov	 esp, ebp
  002d2	5d		 pop	 ebp
  002d3	c3		 ret	 0
?AllocateApuMemory@CMcpxCore@DirectSound@@IAEJXZ ENDP	; DirectSound::CMcpxCore::AllocateApuMemory
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetupVoiceProcessor@CMcpxCore@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -12
_dwHrtfMixBins$ = -8
_i$ = -4
?SetupVoiceProcessor@CMcpxCore@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxCore::SetupVoiceProcessor, COMDAT
; _this$ = ecx

; 643  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
$L39191:

; 644  :     DWORD                   dwHrtfMixBins;
; 645  :     DWORD                   i;
; 646  : 
; 647  :     DPF_ENTER();
; 648  :     MCPX_CHECK_VOICE_FIFO_INIT(8);

  00009	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0000e	8b 88 00 00 82
	fe		 mov	 ecx, DWORD PTR [eax-25034752]
  00014	c1 e9 02	 shr	 ecx, 2
  00017	83 f9 08	 cmp	 ecx, 8
  0001a	73 02		 jae	 SHORT $L39192
  0001c	eb eb		 jmp	 SHORT $L39191
$L39192:

; 649  : 
; 650  :     //
; 651  :     // Set up the HW voice data structures to point to themselves
; 652  :     //
; 653  : 
; 654  :     for(i = 0; i < MCPX_HW_MAX_VOICES; i++) 

  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $L39195
$L39196:
  00027	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002a	83 c2 01	 add	 edx, 1
  0002d	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L39195:
  00030	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00037	73 1a		 jae	 SHORT $L39197

; 655  :     {
; 656  :         MCPX_VOICE_STRUCT_WRITE(i, NV_PAVS_VOICE_TAR_PITCH_LINK, MCPX_MAKE_REG_VALUE(i, NV_PAVS_VOICE_TAR_PITCH_LINK_NEXT_VOICE_HANDLE));

  00039	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00044	c1 e1 07	 shl	 ecx, 7
  00047	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+48
  0004d	89 44 0a 7c	 mov	 DWORD PTR [edx+ecx+124], eax

; 657  :     }

  00051	eb d4		 jmp	 SHORT $L39196
$L39197:

; 658  : 
; 659  :     //
; 660  :     // Program the DMA PRD/SGE lists base addresses
; 661  :     //
; 662  : 
; 663  :     MCPX_REG_WRITE(NV_PAPU_VPVADDR, m_ctxMemory[MCPX_MEM_VOICE].PhysicalAddress);

  00053	a1 34 00 00 00	 mov	 eax, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+52
  00058	a3 2c 20 80 fe	 mov	 DWORD PTR ds:-25157588, eax

; 664  :     MCPX_REG_WRITE(NV_PAPU_VPHTADDR, m_ctxMemory[MCPX_MEM_HRTFTARGET].PhysicalAddress);

  0005d	8b 0d 74 00 00
	00		 mov	 ecx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+116
  00063	89 0d 38 20 80
	fe		 mov	 DWORD PTR ds:-25157576, ecx

; 665  :     MCPX_REG_WRITE(NV_PAPU_VPHCADDR, m_ctxMemory[MCPX_MEM_HRTFCURRENT].PhysicalAddress);

  00069	8b 15 84 00 00
	00		 mov	 edx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+132
  0006f	89 15 3c 20 80
	fe		 mov	 DWORD PTR ds:-25157572, edx

; 666  :     MCPX_REG_WRITE(NV_PAPU_VPSGEADDR, m_ctxMemory[MCPX_MEM_INPUTSGE].PhysicalAddress);

  00075	a1 54 00 00 00	 mov	 eax, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+84
  0007a	a3 30 20 80 fe	 mov	 DWORD PTR ds:-25157584, eax

; 667  :     MCPX_REG_WRITE(NV_PAPU_VPSSLADDR, m_ctxMemory[MCPX_MEM_INPUTPRD].PhysicalAddress);

  0007f	8b 0d 64 00 00
	00		 mov	 ecx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+100
  00085	89 0d 34 20 80
	fe		 mov	 DWORD PTR ds:-25157580, ecx

; 668  :     MCPX_REG_WRITE(NV_PAPU_FENADDR, m_ctxMemory[MCPX_MEM_NOTIFIERS].PhysicalAddress);

  0008b	8b 15 44 00 00
	00		 mov	 edx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+68
  00091	89 15 5c 11 80
	fe		 mov	 DWORD PTR ds:-25161380, edx

; 669  : 
; 670  :     //
; 671  :     // Initialize all the global tracking parameters
; 672  :     //
; 673  : 
; 674  :     MCPX_VOICE_WRITE(SetPitchTracking, MCPX_HW_DEFAULT_TRACKING);

  00097	b8 a4 02 00 00	 mov	 eax, 676		; 000002a4H
  0009c	c7 80 00 00 82
	fe ff 0f 00 00	 mov	 DWORD PTR [eax-25034752], 4095 ; 00000fffH

; 675  :     MCPX_VOICE_WRITE(SetFilterTracking, MCPX_HW_DEFAULT_TRACKING);

  000a6	b9 b0 02 00 00	 mov	 ecx, 688		; 000002b0H
  000ab	c7 81 00 00 82
	fe ff 0f 00 00	 mov	 DWORD PTR [ecx-25034752], 4095 ; 00000fffH

; 676  :     MCPX_VOICE_WRITE(SetVolumeTracking, MCPX_HW_DEFAULT_TRACKING);

  000b5	ba a0 02 00 00	 mov	 edx, 672		; 000002a0H
  000ba	c7 82 00 00 82
	fe ff 0f 00 00	 mov	 DWORD PTR [edx-25034752], 4095 ; 00000fffH

; 677  :     MCPX_VOICE_WRITE(SetHRTFTracking, MCPX_HW_DEFAULT_TRACKING);

  000c4	b8 a8 02 00 00	 mov	 eax, 680		; 000002a8H
  000c9	c7 80 00 00 82
	fe ff 0f 00 00	 mov	 DWORD PTR [eax-25034752], 4095 ; 00000fffH

; 678  :     MCPX_VOICE_WRITE(SetITDTracking, MCPX_HW_DEFAULT_TRACKING);

  000d3	b9 ac 02 00 00	 mov	 ecx, 684		; 000002acH
  000d8	c7 81 00 00 82
	fe ff 0f 00 00	 mov	 DWORD PTR [ecx-25034752], 4095 ; 00000fffH

; 679  : 
; 680  :     //
; 681  :     // Map the GP multipass page into the reserved SGE
; 682  :     //
; 683  : 
; 684  :     MCPX_VOICE_WRITE(SetCurrentInBufSGE, MCPX_HW_MAX_BUFFER_PRDS - 1);

  000e2	ba 04 08 00 00	 mov	 edx, 2052		; 00000804H
  000e7	c7 82 00 00 82
	fe ff 07 00 00	 mov	 DWORD PTR [edx-25034752], 2047 ; 000007ffH

; 685  :     MCPX_VOICE_WRITE(SetCurrentInBufSGEOffset, m_ctxMemory[MCPX_MEM_GPMULTIPASS].PhysicalAddress);

  000f1	b8 08 08 00 00	 mov	 eax, 2056		; 00000808H
  000f6	8b 0d b4 00 00
	00		 mov	 ecx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+180
  000fc	89 88 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], ecx

; 686  : 
; 687  :     //
; 688  :     // Set 3D mixbins
; 689  :     //
; 690  : 
; 691  :     dwHrtfMixBins = MCPX_MAKE_REG_VALUE(DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[0].dwMixBin, NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN0);

  00102	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _DirectSoundRequiredMixBins_3D+4
  00108	8b 02		 mov	 eax, DWORD PTR [edx]
  0010a	83 e0 1f	 and	 eax, 31			; 0000001fH
  0010d	89 45 f8	 mov	 DWORD PTR _dwHrtfMixBins$[ebp], eax

; 692  :     dwHrtfMixBins |= MCPX_MAKE_REG_VALUE(DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[1].dwMixBin, NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN1);

  00110	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _DirectSoundRequiredMixBins_3D+4
  00116	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00119	83 e2 1f	 and	 edx, 31			; 0000001fH
  0011c	c1 e2 08	 shl	 edx, 8
  0011f	8b 45 f8	 mov	 eax, DWORD PTR _dwHrtfMixBins$[ebp]
  00122	0b c2		 or	 eax, edx
  00124	89 45 f8	 mov	 DWORD PTR _dwHrtfMixBins$[ebp], eax

; 693  :     dwHrtfMixBins |= MCPX_MAKE_REG_VALUE(DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[2].dwMixBin, NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN2);

  00127	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _DirectSoundRequiredMixBins_3D+4
  0012d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00130	83 e2 1f	 and	 edx, 31			; 0000001fH
  00133	c1 e2 10	 shl	 edx, 16			; 00000010H
  00136	8b 45 f8	 mov	 eax, DWORD PTR _dwHrtfMixBins$[ebp]
  00139	0b c2		 or	 eax, edx
  0013b	89 45 f8	 mov	 DWORD PTR _dwHrtfMixBins$[ebp], eax

; 694  :     dwHrtfMixBins |= MCPX_MAKE_REG_VALUE(DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[3].dwMixBin, NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN3);

  0013e	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _DirectSoundRequiredMixBins_3D+4
  00144	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00147	83 e2 1f	 and	 edx, 31			; 0000001fH
  0014a	c1 e2 18	 shl	 edx, 24			; 00000018H
  0014d	8b 45 f8	 mov	 eax, DWORD PTR _dwHrtfMixBins$[ebp]
  00150	0b c2		 or	 eax, edx
  00152	89 45 f8	 mov	 DWORD PTR _dwHrtfMixBins$[ebp], eax

; 695  : 
; 696  :     MCPX_VOICE_WRITE(SetHRTFSubmixes, dwHrtfMixBins);

  00155	b9 c0 02 00 00	 mov	 ecx, 704		; 000002c0H
  0015a	8b 55 f8	 mov	 edx, DWORD PTR _dwHrtfMixBins$[ebp]
  0015d	89 91 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], edx

; 697  : 
; 698  :     DPF_LEAVE_VOID();
; 699  : }

  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
?SetupVoiceProcessor@CMcpxCore@DirectSound@@IAEXXZ ENDP	; DirectSound::CMcpxCore::SetupVoiceProcessor
DSOUND	ENDS
PUBLIC	??0CMcpxGPDspManager@DirectSound@@QAE@XZ	; DirectSound::CMcpxGPDspManager::CMcpxGPDspManager
PUBLIC	?Initialize@CMcpxGPDspManager@DirectSound@@QAEXXZ ; DirectSound::CMcpxGPDspManager::Initialize
; Function compile flags: /Odt
;	COMDAT ?SetupGlobalProcessor@CMcpxCore@DirectSound@@IAEXXZ
DSOUND	SEGMENT
tv166 = -72
_this$ = -68
$T42365 = -64
_rControl$ = -60
_z$ = -56
_dwAddress$ = -52
_rReset$ = -48
_dwSgeOffset$ = -44
_dwPos$ = -40
_pPrd$ = -36
_dwTotalSgeCount$ = -12
_i$ = -4
?SetupGlobalProcessor@CMcpxCore@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxCore::SetupGlobalProcessor, COMDAT
; _this$ = ecx

; 725  : {                               

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 726  :     DWORD                   adwSgeCounts[MCPX_GPOUTPUT_COUNT];
; 727  :     DWORD                   dwTotalSgeCount;
; 728  :     DWORD                   dwSgeOffset;
; 729  :     DWORD                   dwAddress;
; 730  :     R_GP_RESET              rReset;
; 731  :     R_GPDMA_CONFIG          rGpDmaConfig;
; 732  :     R_GP_CONTROL            rControl;
; 733  :     DSP_CONTROL             DspControl;
; 734  :     DWORD                   dwPos;
; 735  :     DWORD                   i, z;
; 736  :     MCP1_PRD *              pPrd;
; 737  : 
; 738  :     DPF_ENTER();
; 739  :     
; 740  :     //
; 741  :     // Output buffer SGE table base address for output buffers and input buffers
; 742  :     //
; 743  : 
; 744  :     MCPX_REG_WRITE(NV_PAPU_GPFADDR, m_ctxMemory[MCPX_MEM_GPOUTPUTSGE].PhysicalAddress);

  00009	a1 94 00 00 00	 mov	 eax, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+148
  0000e	a3 44 20 80 fe	 mov	 DWORD PTR ds:-25157564, eax

; 745  : 
; 746  :     //
; 747  :     // Initialize the get/put pointers
; 748  :     //
; 749  : 
; 750  :     MCPX_REG_WRITE(NV_PAPU_GPGET, 0);

  00013	c7 05 00 ff 83
	fe 00 00 00 00	 mov	 DWORD PTR ds:-24903936, 0

; 751  :     MCPX_REG_WRITE(NV_PAPU_GPPUT, 0);

  0001d	c7 05 04 ff 83
	fe 00 00 00 00	 mov	 DWORD PTR ds:-24903932, 0

; 752  : 
; 753  :     //
; 754  :     // Tell the hw how big the output SGE array needs to be
; 755  :     //
; 756  : 
; 757  :     ASSERT(!(m_ctxMemory[MCPX_MEM_GPOUTPUT].PhysicalAddress % PAGE_SIZE));
; 758  :     ASSERT(!(m_ctxMemory[MCPX_MEM_GPOUTPUT].Size % PAGE_SIZE));
; 759  : 
; 760  :     dwTotalSgeCount = m_ctxMemory[MCPX_MEM_GPOUTPUT].Size / PAGE_SIZE;

  00027	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+8
  0002d	c1 e9 0c	 shr	 ecx, 12			; 0000000cH
  00030	89 4d f4	 mov	 DWORD PTR _dwTotalSgeCount$[ebp], ecx

; 761  : 
; 762  :     ASSERT(!(dwTotalSgeCount & 0xFFFF0000));
; 763  : 
; 764  : 	MCPX_REG_WRITE(NV_PAPU_GPFMAXSGE, dwTotalSgeCount - 1);

  00033	8b 55 f4	 mov	 edx, DWORD PTR _dwTotalSgeCount$[ebp]
  00036	83 ea 01	 sub	 edx, 1
  00039	89 15 d8 20 80
	fe		 mov	 DWORD PTR ds:-25157416, edx

; 765  : 	MCPX_REG_WRITE(NV_PAPU_FEMAXGPSGE, dwTotalSgeCount - 1);

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _dwTotalSgeCount$[ebp]
  00042	83 e8 01	 sub	 eax, 1
  00045	a3 48 11 80 fe	 mov	 DWORD PTR ds:-25161400, eax

; 766  : 
; 767  :     MCPX_REG_WRITE(NV_PAPU_GPOFBASE0, 0);

  0004a	c7 05 24 30 80
	fe 00 00 00 00	 mov	 DWORD PTR ds:-25153500, 0

; 768  :     MCPX_REG_WRITE(NV_PAPU_GPOFEND0,  m_adwGPOutputBufferSizes[0]);

  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_adwGPOutputBufferSizes@CMcpxCore@DirectSound@@2QBKB ; DirectSound::CMcpxCore::m_adwGPOutputBufferSizes
  0005a	89 0d 28 30 80
	fe		 mov	 DWORD PTR ds:-25153496, ecx

; 769  : 
; 770  :     //
; 771  :     // Set up the output SGEs
; 772  :     //
; 773  : 
; 774  :     pPrd = (MCP1_PRD *)m_ctxMemory[MCPX_MEM_GPOUTPUTSGE].VirtualAddress;

  00060	8b 15 90 00 00
	00		 mov	 edx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+144
  00066	89 55 dc	 mov	 DWORD PTR _pPrd$[ebp], edx

; 775  : 
; 776  :     for(i = 0, dwSgeOffset = 0; i < MCPX_GPOUTPUT_COUNT; i++)

  00069	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00070	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _dwSgeOffset$[ebp], 0
  00077	eb 09		 jmp	 SHORT $L39266
$L39267:
  00079	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0007c	83 c0 01	 add	 eax, 1
  0007f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L39266:
  00082	83 7d fc 01	 cmp	 DWORD PTR _i$[ebp], 1
  00086	0f 83 0a 01 00
	00		 jae	 $L39268

; 777  :     {
; 778  :         for(z = 0; z < m_adwGPOutputBufferSizes[i] / PAGE_SIZE; z++)

  0008c	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _z$[ebp], 0
  00093	eb 09		 jmp	 SHORT $L39269
$L39270:
  00095	8b 4d c8	 mov	 ecx, DWORD PTR _z$[ebp]
  00098	83 c1 01	 add	 ecx, 1
  0009b	89 4d c8	 mov	 DWORD PTR _z$[ebp], ecx
$L39269:
  0009e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000a1	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?m_adwGPOutputBufferSizes@CMcpxCore@DirectSound@@2QBKB[edx*4]
  000a8	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  000ab	39 45 c8	 cmp	 DWORD PTR _z$[ebp], eax
  000ae	0f 83 8d 00 00
	00		 jae	 $L39282

; 779  :         {
; 780  :             dwAddress = m_ctxMemory[MCPX_MEM_GPOUTPUT].PhysicalAddress + ((dwSgeOffset + z) * PAGE_SIZE);

  000b4	8b 4d d4	 mov	 ecx, DWORD PTR _dwSgeOffset$[ebp]
  000b7	03 4d c8	 add	 ecx, DWORD PTR _z$[ebp]
  000ba	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  000bd	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+4
  000c3	03 d1		 add	 edx, ecx
  000c5	89 55 cc	 mov	 DWORD PTR _dwAddress$[ebp], edx
$L39273:

; 781  :             
; 782  :             MCPX_CHECK_VOICE_FIFO_INIT(2);

  000c8	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000cd	8b 88 00 00 82
	fe		 mov	 ecx, DWORD PTR [eax-25034752]
  000d3	c1 e9 02	 shr	 ecx, 2
  000d6	83 f9 02	 cmp	 ecx, 2
  000d9	73 02		 jae	 SHORT $L39274
  000db	eb eb		 jmp	 SHORT $L39273
$L39274:

; 783  :             MCPX_VOICE_WRITE(SetCurrentOutBufSGE, dwSgeOffset + z);

  000dd	8b 55 d4	 mov	 edx, DWORD PTR _dwSgeOffset$[ebp]
  000e0	03 55 c8	 add	 edx, DWORD PTR _z$[ebp]
  000e3	b8 00 18 00 00	 mov	 eax, 6144		; 00001800H
  000e8	89 90 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], edx

; 784  :             MCPX_VOICE_WRITE(SetOutBufSGEOffset, dwAddress);

  000ee	b9 08 18 00 00	 mov	 ecx, 6152		; 00001808H
  000f3	8b 55 cc	 mov	 edx, DWORD PTR _dwAddress$[ebp]
  000f6	89 91 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], edx

; 785  : 
; 786  :             pPrd[dwSgeOffset + z].uAddr = dwAddress;

  000fc	8b 45 d4	 mov	 eax, DWORD PTR _dwSgeOffset$[ebp]
  000ff	03 45 c8	 add	 eax, DWORD PTR _z$[ebp]
  00102	8b 4d dc	 mov	 ecx, DWORD PTR _pPrd$[ebp]
  00105	8b 55 cc	 mov	 edx, DWORD PTR _dwAddress$[ebp]
  00108	89 14 c1	 mov	 DWORD PTR [ecx+eax*8], edx

; 787  :             pPrd[dwSgeOffset + z].Control.uValue = 0;

  0010b	8b 45 d4	 mov	 eax, DWORD PTR _dwSgeOffset$[ebp]
  0010e	03 45 c8	 add	 eax, DWORD PTR _z$[ebp]
  00111	8b 4d dc	 mov	 ecx, DWORD PTR _pPrd$[ebp]
  00114	c7 44 c1 04 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*8+4], 0

; 788  :             pPrd[dwSgeOffset + z].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;

  0011c	8b 55 d4	 mov	 edx, DWORD PTR _dwSgeOffset$[ebp]
  0011f	03 55 c8	 add	 edx, DWORD PTR _z$[ebp]
  00122	8b 45 dc	 mov	 eax, DWORD PTR _pPrd$[ebp]
  00125	8b 4c d0 04	 mov	 ecx, DWORD PTR [eax+edx*8+4]
  00129	81 e1 ff ff ff
	fe		 and	 ecx, -16777217		; feffffffH
  0012f	8b 55 d4	 mov	 edx, DWORD PTR _dwSgeOffset$[ebp]
  00132	03 55 c8	 add	 edx, DWORD PTR _z$[ebp]
  00135	8b 45 dc	 mov	 eax, DWORD PTR _pPrd$[ebp]
  00138	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx

; 789  : 
; 790  :         }

  0013c	e9 54 ff ff ff	 jmp	 $L39270
$L39282:

; 791  :         
; 792  :         MCPX_CHECK_VOICE_FIFO_INIT(2);

  00141	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00146	8b 91 00 00 82
	fe		 mov	 edx, DWORD PTR [ecx-25034752]
  0014c	c1 ea 02	 shr	 edx, 2
  0014f	83 fa 02	 cmp	 edx, 2
  00152	73 02		 jae	 SHORT $L39283
  00154	eb eb		 jmp	 SHORT $L39282
$L39283:

; 793  :         MCPX_VOICE_WRITE(SetOutBuf[i].BA, dwSgeOffset * PAGE_SIZE);

  00156	8b 45 d4	 mov	 eax, DWORD PTR _dwSgeOffset$[ebp]
  00159	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  0015c	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00161	81 c1 00 00 82
	fe		 add	 ecx, -25034752		; fe820000H
  00167	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0016a	89 04 d1	 mov	 DWORD PTR [ecx+edx*8], eax

; 794  :         MCPX_VOICE_WRITE(SetOutBuf[i].Len, m_adwGPOutputBufferSizes[i]);

  0016d	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  00172	05 00 00 82 fe	 add	 eax, -25034752		; fe820000H
  00177	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0017a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0017d	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR ?m_adwGPOutputBufferSizes@CMcpxCore@DirectSound@@2QBKB[edx*4]
  00184	89 54 c8 04	 mov	 DWORD PTR [eax+ecx*8+4], edx

; 795  : 
; 796  :         dwSgeOffset += z;

  00188	8b 45 d4	 mov	 eax, DWORD PTR _dwSgeOffset$[ebp]
  0018b	03 45 c8	 add	 eax, DWORD PTR _z$[ebp]
  0018e	89 45 d4	 mov	 DWORD PTR _dwSgeOffset$[ebp], eax

; 797  :     }

  00191	e9 e3 fe ff ff	 jmp	 $L39267
$L39268:

; 798  : 
; 799  :     //
; 800  :     // Allocate the scratch space management code and GP DSP code management
; 801  :     //
; 802  : 
; 803  :     if(!m_pGpDspManager)

  00196	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00199	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0019d	75 3b		 jne	 SHORT $L39290

; 804  :     {
; 805  :         if(!(m_pGpDspManager = NEW(CMcpxGPDspManager)))

  0019f	6a 3c		 push	 60			; 0000003cH
  001a1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001a6	83 c4 04	 add	 esp, 4
  001a9	89 45 c0	 mov	 DWORD PTR $T42365[ebp], eax
  001ac	83 7d c0 00	 cmp	 DWORD PTR $T42365[ebp], 0
  001b0	74 0d		 je	 SHORT $L42366
  001b2	8b 4d c0	 mov	 ecx, DWORD PTR $T42365[ebp]
  001b5	e8 00 00 00 00	 call	 ??0CMcpxGPDspManager@DirectSound@@QAE@XZ ; DirectSound::CMcpxGPDspManager::CMcpxGPDspManager
  001ba	89 45 b8	 mov	 DWORD PTR tv166[ebp], eax
  001bd	eb 07		 jmp	 SHORT $L42367
$L42366:
  001bf	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv166[ebp], 0
$L42367:
  001c6	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  001c9	8b 45 b8	 mov	 eax, DWORD PTR tv166[ebp]
  001cc	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 806  :         {
; 807  :             ASSERTMSG("Failed to alloc DSP and scratch classes");
; 808  :         }
; 809  : 
; 810  :         m_pGpDspManager->Initialize();

  001cf	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  001d2	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  001d5	e8 00 00 00 00	 call	 ?Initialize@CMcpxGPDspManager@DirectSound@@QAEXXZ ; DirectSound::CMcpxGPDspManager::Initialize
$L39290:

; 811  :     }
; 812  : 
; 813  :     //
; 814  :     // Take the GP peripherals out of reset, leave DSP core in reset state
; 815  :     //
; 816  : 
; 817  :     rReset.uValue = 0;

  001da	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _rReset$[ebp], 0

; 818  :     rReset.Global = NV_PAPU_GPRST_GPRST_DISABLED;

  001e1	8b 55 d0	 mov	 edx, DWORD PTR _rReset$[ebp]
  001e4	83 ca 01	 or	 edx, 1
  001e7	89 55 d0	 mov	 DWORD PTR _rReset$[ebp], edx

; 819  :     rReset.DSP = NV_PAPU_GPRST_GPDSPRST_ENABLED;

  001ea	8b 45 d0	 mov	 eax, DWORD PTR _rReset$[ebp]
  001ed	83 e0 fd	 and	 eax, -3			; fffffffdH
  001f0	89 45 d0	 mov	 DWORD PTR _rReset$[ebp], eax

; 820  :     rReset.NMI = NV_PAPU_GPRST_GPNMI_DISABLED;

  001f3	8b 4d d0	 mov	 ecx, DWORD PTR _rReset$[ebp]
  001f6	83 e1 fb	 and	 ecx, -5			; fffffffbH
  001f9	89 4d d0	 mov	 DWORD PTR _rReset$[ebp], ecx

; 821  :     rReset.Abort = NV_PAPU_GPRST_GPABORT_DISABLED;

  001fc	8b 55 d0	 mov	 edx, DWORD PTR _rReset$[ebp]
  001ff	83 e2 f7	 and	 edx, -9			; fffffff7H
  00202	89 55 d0	 mov	 DWORD PTR _rReset$[ebp], edx

; 822  : 
; 823  :     MCPX_REG_WRITE(NV_PAPU_GPRST, rReset.uValue);

  00205	8b 45 d0	 mov	 eax, DWORD PTR _rReset$[ebp]
  00208	a3 fc ff 83 fe	 mov	 DWORD PTR ds:-24903684, eax

; 824  : 
; 825  :     //
; 826  :     // Enable the GP
; 827  :     //
; 828  : 
; 829  :     rControl.Idle = NV_PAPU_GPIDRDY_GPSETIDLE_SET;

  0020d	8b 4d c4	 mov	 ecx, DWORD PTR _rControl$[ebp]
  00210	83 c9 01	 or	 ecx, 1
  00213	89 4d c4	 mov	 DWORD PTR _rControl$[ebp], ecx

; 830  :     rControl.IntrNotify = NV_PAPU_GPIDRDY_GPSETNINT_NOT_SET;

  00216	8b 55 c4	 mov	 edx, DWORD PTR _rControl$[ebp]
  00219	83 e2 f7	 and	 edx, -9			; fffffff7H
  0021c	89 55 c4	 mov	 DWORD PTR _rControl$[ebp], edx

; 831  : 
; 832  :     MCPX_REG_WRITE(NV_PAPU_GPIDRDY, rControl.uValue);

  0021f	8b 45 c4	 mov	 eax, DWORD PTR _rControl$[ebp]
  00222	a3 10 ff 83 fe	 mov	 DWORD PTR ds:-24903920, eax

; 833  : 
; 834  :     //
; 835  :     // Clear the interrupt status
; 836  :     //
; 837  : 
; 838  :     MCPX_REG_WRITE(NV_PAPU_GPISTS, 0xFF);

  00227	c7 05 14 ff 83
	fe ff 00 00 00	 mov	 DWORD PTR ds:-24903916, 255 ; 000000ffH

; 839  : 
; 840  :     //
; 841  :     // Reset the FIFO positions
; 842  :     //
; 843  : 
; 844  :     MCPX_REG_READ(NV_PAPU_GPOFBASE0, &dwPos);

  00231	8b 0d 24 30 80
	fe		 mov	 ecx, DWORD PTR ds:-25153500
  00237	89 4d d8	 mov	 DWORD PTR _dwPos$[ebp], ecx

; 845  :     MCPX_REG_WRITE(NV_PAPU_GPOFCUR0, dwPos);

  0023a	8b 55 d8	 mov	 edx, DWORD PTR _dwPos$[ebp]
  0023d	89 15 2c 30 80
	fe		 mov	 DWORD PTR ds:-25153492, edx

; 846  : 
; 847  :     MCPX_REG_READ(NV_PAPU_GPOFBASE1, &dwPos);

  00243	a1 34 30 80 fe	 mov	 eax, DWORD PTR ds:-25153484
  00248	89 45 d8	 mov	 DWORD PTR _dwPos$[ebp], eax

; 848  :     MCPX_REG_WRITE(NV_PAPU_GPOFCUR1, dwPos);

  0024b	8b 4d d8	 mov	 ecx, DWORD PTR _dwPos$[ebp]
  0024e	89 0d 3c 30 80
	fe		 mov	 DWORD PTR ds:-25153476, ecx

; 849  : 
; 850  :     MCPX_REG_READ(NV_PAPU_GPOFBASE2, &dwPos);

  00254	8b 15 44 30 80
	fe		 mov	 edx, DWORD PTR ds:-25153468
  0025a	89 55 d8	 mov	 DWORD PTR _dwPos$[ebp], edx

; 851  :     MCPX_REG_WRITE(NV_PAPU_GPOFCUR2, dwPos);

  0025d	8b 45 d8	 mov	 eax, DWORD PTR _dwPos$[ebp]
  00260	a3 4c 30 80 fe	 mov	 DWORD PTR ds:-25153460, eax

; 852  : 
; 853  :     MCPX_REG_READ(NV_PAPU_GPOFBASE3, &dwPos);

  00265	8b 0d 54 30 80
	fe		 mov	 ecx, DWORD PTR ds:-25153452
  0026b	89 4d d8	 mov	 DWORD PTR _dwPos$[ebp], ecx

; 854  :     MCPX_REG_WRITE(NV_PAPU_GPOFCUR3, dwPos);

  0026e	8b 55 d8	 mov	 edx, DWORD PTR _dwPos$[ebp]
  00271	89 15 5c 30 80
	fe		 mov	 DWORD PTR ds:-25153444, edx

; 855  : 
; 856  :     //
; 857  :     // Now take DSP core out of reset as well
; 858  :     //
; 859  : 
; 860  :     rReset.DSP = NV_PAPU_GPRST_GPDSPRST_DISABLED;

  00277	8b 45 d0	 mov	 eax, DWORD PTR _rReset$[ebp]
  0027a	83 c8 02	 or	 eax, 2
  0027d	89 45 d0	 mov	 DWORD PTR _rReset$[ebp], eax

; 861  : 
; 862  :     MCPX_REG_WRITE(NV_PAPU_GPRST, rReset.uValue);

  00280	8b 4d d0	 mov	 ecx, DWORD PTR _rReset$[ebp]
  00283	89 0d fc ff 83
	fe		 mov	 DWORD PTR ds:-24903684, ecx

; 863  : 
; 864  :     DPF_LEAVE_VOID();
; 865  : }

  00289	8b e5		 mov	 esp, ebp
  0028b	5d		 pop	 ebp
  0028c	c3		 ret	 0
?SetupGlobalProcessor@CMcpxCore@DirectSound@@IAEXXZ ENDP ; DirectSound::CMcpxCore::SetupGlobalProcessor
DSOUND	ENDS
PUBLIC	?Initialize@CAc97Channel@DirectSound@@QAEJKP6GXPAX@Z0@Z ; DirectSound::CAc97Channel::Initialize
PUBLIC	?AttachPacket@CAc97Channel@DirectSound@@QAEXKK@Z ; DirectSound::CAc97Channel::AttachPacket
PUBLIC	?SetMode@CAc97Channel@DirectSound@@QAEXK@Z	; DirectSound::CAc97Channel::SetMode
PUBLIC	?Initialize@CAc97Device@DirectSound@@QAEJK@Z	; DirectSound::CAc97Device::Initialize
PUBLIC	?CreateChannel@CAc97Device@DirectSound@@QAEJW4AC97CHANNELTYPE@@PAPAVCAc97Channel@2@@Z ; DirectSound::CAc97Device::CreateChannel
; Function compile flags: /Odt
;	COMDAT ?SetupAc97@CMcpxCore@DirectSound@@IAEJXZ
DSOUND	SEGMENT
_this$ = -20
_hr$ = -16
_dwBufferAddress$ = -12
_adwBufferSizes$ = -4
?SetupAc97@CMcpxCore@DirectSound@@IAEJXZ PROC NEAR	; DirectSound::CMcpxCore::SetupAc97, COMDAT
; _this$ = ecx

; 1082 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1083 :     HRESULT                 hr              = DS_OK;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1084 :     DWORD                   dwBufferAddress;
; 1085 :     LPCDWORD                adwBufferSizes;
; 1086 :     DWORD                   i;
; 1087 : 
; 1088 :     DPF_ENTER();
; 1089 : 
; 1090 : #ifndef MCPX_BOOT_LIB
; 1091 : 
; 1092 :     dwBufferAddress = m_ctxMemory[MCPX_MEM_EPOUTPUT].PhysicalAddress;
; 1093 :     adwBufferSizes = m_adwEPOutputBufferSizes;
; 1094 : 
; 1095 : #else
; 1096 : 
; 1097 :     dwBufferAddress = m_ctxMemory[MCPX_MEM_GPOUTPUT].PhysicalAddress;

  00010	a1 04 00 00 00	 mov	 eax, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+4
  00015	89 45 f4	 mov	 DWORD PTR _dwBufferAddress$[ebp], eax

; 1098 :     adwBufferSizes = m_adwGPOutputBufferSizes;

  00018	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _adwBufferSizes$[ebp], OFFSET FLAT:?m_adwGPOutputBufferSizes@CMcpxCore@DirectSound@@2QBKB ; DirectSound::CMcpxCore::m_adwGPOutputBufferSizes

; 1099 : 
; 1100 : #endif // MCPX_BOOT_LIB
; 1101 : 
; 1102 :     //
; 1103 :     // Initialize the AC97
; 1104 :     //
; 1105 : 
; 1106 :     hr = m_Ac97.Initialize(AC97_OBJECTF_DIRECTISR);

  0001f	6a 01		 push	 1
  00021	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 10	 add	 ecx, 16			; 00000010H
  00027	e8 00 00 00 00	 call	 ?Initialize@CAc97Device@DirectSound@@QAEJK@Z ; DirectSound::CAc97Device::Initialize
  0002c	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 1107 : 
; 1108 :     //
; 1109 :     // Create AC97 output channels.  If Dolby Digital isn't turned on in the
; 1110 :     // speaker config, both the analog and digital channels will read from
; 1111 :     // the analog buffer.
; 1112 :     //
; 1113 : 
; 1114 :     if(SUCCEEDED(hr))

  0002f	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00033	7c 12		 jl	 SHORT $L39324

; 1115 :     {
; 1116 :         hr = m_Ac97.CreateChannel(AC97_CHANNELTYPE_ANALOG);

  00035	6a 00		 push	 0
  00037	6a 00		 push	 0
  00039	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 10	 add	 ecx, 16			; 00000010H
  0003f	e8 00 00 00 00	 call	 ?CreateChannel@CAc97Device@DirectSound@@QAEJW4AC97CHANNELTYPE@@PAPAVCAc97Channel@2@@Z ; DirectSound::CAc97Device::CreateChannel
  00044	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
$L39324:

; 1117 :     }
; 1118 : 
; 1119 :     if(SUCCEEDED(hr))

  00047	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004b	7c 14		 jl	 SHORT $L39326

; 1120 :     {
; 1121 :         hr = m_Ac97.m_apChannels[AC97_CHANNELTYPE_ANALOG]->Initialize();

  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00059	e8 00 00 00 00	 call	 ?Initialize@CAc97Channel@DirectSound@@QAEJKP6GXPAX@Z0@Z ; DirectSound::CAc97Channel::Initialize
  0005e	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
$L39326:

; 1122 :     }
; 1123 : 
; 1124 :     if(SUCCEEDED(hr))

  00061	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00065	7c 15		 jl	 SHORT $L39328

; 1125 :     {
; 1126 :         m_Ac97.m_apChannels[AC97_CHANNELTYPE_ANALOG]->AttachPacket(dwBufferAddress, adwBufferSizes[AC97_CHANNELTYPE_ANALOG]);

  00067	8b 55 fc	 mov	 edx, DWORD PTR _adwBufferSizes$[ebp]
  0006a	8b 02		 mov	 eax, DWORD PTR [edx]
  0006c	50		 push	 eax
  0006d	8b 4d f4	 mov	 ecx, DWORD PTR _dwBufferAddress$[ebp]
  00070	51		 push	 ecx
  00071	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00074	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00077	e8 00 00 00 00	 call	 ?AttachPacket@CAc97Channel@DirectSound@@QAEXKK@Z ; DirectSound::CAc97Channel::AttachPacket
$L39328:

; 1127 :     }
; 1128 : 
; 1129 :     if(SUCCEEDED(hr))

  0007c	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00080	7c 12		 jl	 SHORT $L39330

; 1130 :     {
; 1131 :         hr = m_Ac97.CreateChannel(AC97_CHANNELTYPE_DIGITAL);

  00082	6a 00		 push	 0
  00084	6a 01		 push	 1
  00086	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	83 c1 10	 add	 ecx, 16			; 00000010H
  0008c	e8 00 00 00 00	 call	 ?CreateChannel@CAc97Device@DirectSound@@QAEJW4AC97CHANNELTYPE@@PAPAVCAc97Channel@2@@Z ; DirectSound::CAc97Device::CreateChannel
  00091	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
$L39330:

; 1132 :     }
; 1133 : 
; 1134 :     if(SUCCEEDED(hr))

  00094	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00098	7c 14		 jl	 SHORT $L39332

; 1135 :     {
; 1136 :         hr = m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->Initialize();

  0009a	6a 00		 push	 0
  0009c	6a 00		 push	 0
  0009e	6a 00		 push	 0
  000a0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000a6	e8 00 00 00 00	 call	 ?Initialize@CAc97Channel@DirectSound@@QAEJKP6GXPAX@Z0@Z ; DirectSound::CAc97Channel::Initialize
  000ab	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
$L39332:

; 1137 :     }
; 1138 : 
; 1139 :     if(SUCCEEDED(hr))

  000ae	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b2	7c 25		 jl	 SHORT $L39334

; 1140 :     {
; 1141 : 
; 1142 : #ifndef MCPX_BOOT_LIB
; 1143 : 
; 1144 :         if(DSSPEAKER_IS_AC3(m_pSettings->m_dwSpeakerConfig))
; 1145 :         {
; 1146 :             m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->AttachPacket(dwBufferAddress + adwBufferSizes[AC97_CHANNELTYPE_ANALOG], adwBufferSizes[AC97_CHANNELTYPE_DIGITAL]);
; 1147 :             m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->SetMode(DSAC97_MODE_ENCODED);
; 1148 :         }
; 1149 :         else
; 1150 : 
; 1151 : #endif // MCPX_BOOT_LIB
; 1152 : 
; 1153 :         {
; 1154 :             m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->AttachPacket(dwBufferAddress, adwBufferSizes[AC97_CHANNELTYPE_ANALOG]);

  000b4	8b 4d fc	 mov	 ecx, DWORD PTR _adwBufferSizes$[ebp]
  000b7	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b9	52		 push	 edx
  000ba	8b 45 f4	 mov	 eax, DWORD PTR _dwBufferAddress$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  000c4	e8 00 00 00 00	 call	 ?AttachPacket@CAc97Channel@DirectSound@@QAEXKK@Z ; DirectSound::CAc97Channel::AttachPacket

; 1155 :             m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->SetMode(DSAC97_MODE_PCM);

  000c9	68 00 00 00 02	 push	 33554432		; 02000000H
  000ce	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000d1	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  000d4	e8 00 00 00 00	 call	 ?SetMode@CAc97Channel@DirectSound@@QAEXK@Z ; DirectSound::CAc97Channel::SetMode
$L39334:

; 1156 :         }
; 1157 :     }
; 1158 : 
; 1159 :     DPF_LEAVE_HRESULT(hr);
; 1160 : 
; 1161 : 	return hr;

  000d9	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]

; 1162 : }

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
?SetupAc97@CMcpxCore@DirectSound@@IAEJXZ ENDP		; DirectSound::CMcpxCore::SetupAc97
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetInterruptState@CMcpxCore@DirectSound@@IAEXH@Z
DSOUND	SEGMENT
_this$ = -20
___AutoIrql$ = -16
_rInterruptMask$ = -8
_fEnabled$ = 8
?SetInterruptState@CMcpxCore@DirectSound@@IAEXH@Z PROC NEAR ; DirectSound::CMcpxCore::SetInterruptState, COMDAT
; _this$ = ecx

; 1188 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1189 :     R_INTR                  rInterruptMask;
; 1190 : 
; 1191 :     DPF_ENTER();
; 1192 :     AutoIrql();

  00009	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1193 : 
; 1194 :     MCPX_REG_READ(NV_PAPU_IEN, &rInterruptMask.uValue);

  00011	a1 04 10 80 fe	 mov	 eax, DWORD PTR ds:-25161724
  00016	89 45 f8	 mov	 DWORD PTR _rInterruptMask$[ebp], eax

; 1195 : 
; 1196 :     rInterruptMask.General = fEnabled ? NV_PAPU_IEN_GINTEN_ENABLED : NV_PAPU_IEN_GINTEN_DISABLED;

  00019	33 c9		 xor	 ecx, ecx
  0001b	83 7d 08 00	 cmp	 DWORD PTR _fEnabled$[ebp], 0
  0001f	0f 95 c1	 setne	 cl
  00022	83 e1 01	 and	 ecx, 1
  00025	8b 55 f8	 mov	 edx, DWORD PTR _rInterruptMask$[ebp]
  00028	83 e2 fe	 and	 edx, -2			; fffffffeH
  0002b	0b d1		 or	 edx, ecx
  0002d	89 55 f8	 mov	 DWORD PTR _rInterruptMask$[ebp], edx

; 1197 : 
; 1198 :     MCPX_REG_WRITE(NV_PAPU_IEN, rInterruptMask.uValue);

  00030	8b 45 f8	 mov	 eax, DWORD PTR _rInterruptMask$[ebp]
  00033	a3 04 10 80 fe	 mov	 DWORD PTR ds:-25161724, eax

; 1199 : 
; 1200 :     // DPF_BLAB("Interrupts %s", fEnabled ? "enabled" : "disabled");
; 1201 : 
; 1202 :     DPF_LEAVE_VOID();
; 1203 : }

  00038	8d 4d f0	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0003b	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?SetInterruptState@CMcpxCore@DirectSound@@IAEXH@Z ENDP	; DirectSound::CMcpxCore::SetInterruptState
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetPrivLockState@CMcpxCore@DirectSound@@IAEXH@Z
DSOUND	SEGMENT
_this$ = -16
___AutoIrql$ = -12
_dwPrivLock$ = -4
_fLocked$ = 8
?SetPrivLockState@CMcpxCore@DirectSound@@IAEXH@Z PROC NEAR ; DirectSound::CMcpxCore::SetPrivLockState, COMDAT
; _this$ = ecx

; 1229 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1230 :     DWORD                   dwPrivLock;
; 1231 : 
; 1232 :     DPF_ENTER();
; 1233 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1234 : 
; 1235 :     MCPX_REG_READ(NV_PAPU_FEPRIVLOCK, &dwPrivLock);

  00011	a1 10 15 80 fe	 mov	 eax, DWORD PTR ds:-25160432
  00016	89 45 fc	 mov	 DWORD PTR _dwPrivLock$[ebp], eax

; 1236 : 
; 1237 :     dwPrivLock = MCPX_SET_REG_VALUE(dwPrivLock, fLocked ? NV_PAPU_FEPRIVLOCK_VALUE_LOCKED : NV_PAPU_FEPRIVLOCK_VALUE_UNLOCKED, NV_PAPU_FEPRIVLOCK_VALUE);

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _dwPrivLock$[ebp]
  0001c	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0001f	33 d2		 xor	 edx, edx
  00021	83 7d 08 00	 cmp	 DWORD PTR _fLocked$[ebp], 0
  00025	0f 95 c2	 setne	 dl
  00028	83 e2 01	 and	 edx, 1
  0002b	0b ca		 or	 ecx, edx
  0002d	89 4d fc	 mov	 DWORD PTR _dwPrivLock$[ebp], ecx

; 1238 : 
; 1239 :     MCPX_REG_WRITE(NV_PAPU_FEPRIVLOCK, dwPrivLock);

  00030	8b 45 fc	 mov	 eax, DWORD PTR _dwPrivLock$[ebp]
  00033	a3 10 15 80 fe	 mov	 DWORD PTR ds:-25160432, eax

; 1240 : 
; 1241 :     // DPF_BLAB("Priv lock %s", fLocked ? "locked" : "unlocked");
; 1242 : 
; 1243 :     DPF_LEAVE_VOID();
; 1244 : }

  00038	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0003b	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?SetPrivLockState@CMcpxCore@DirectSound@@IAEXH@Z ENDP	; DirectSound::CMcpxCore::SetPrivLockState
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetFrontEndState@CMcpxCore@DirectSound@@IAEXW4MCPX_FE_STATE@@@Z
DSOUND	SEGMENT
tv68 = -20
_this$ = -16
___AutoIrql$ = -12
_rFeControl$ = -4
_nState$ = 8
?SetFrontEndState@CMcpxCore@DirectSound@@IAEXW4MCPX_FE_STATE@@@Z PROC NEAR ; DirectSound::CMcpxCore::SetFrontEndState, COMDAT
; _this$ = ecx

; 1270 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1271 :     R_FE_CONTROL            rFeControl;
; 1272 : 
; 1273 :     DPF_ENTER();
; 1274 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1275 : 
; 1276 :     MCPX_REG_READ(NV_PAPU_FECTL, &rFeControl.uValue);

  00011	a1 00 11 80 fe	 mov	 eax, DWORD PTR ds:-25161472
  00016	89 45 fc	 mov	 DWORD PTR _rFeControl$[ebp], eax

; 1277 : 
; 1278 :     switch(nState) 
; 1279 :     {

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _nState$[ebp]
  0001c	89 4d ec	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	83 7d ec 03	 cmp	 DWORD PTR tv68[ebp], 3
  00023	77 79		 ja	 SHORT $L39362
  00025	8b 55 ec	 mov	 edx, DWORD PTR tv68[ebp]
  00028	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L42380[edx*4]
$L39365:

; 1280 :         case MCPX_FE_STATE_HALTED:
; 1281 :             // DPF_BLAB("FE state set to HALTED");
; 1282 :             
; 1283 :             rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _rFeControl$[ebp]
  00032	25 1f ff ff ff	 and	 eax, -225		; ffffff1fH
  00037	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  0003c	89 45 fc	 mov	 DWORD PTR _rFeControl$[ebp], eax

; 1284 : 
; 1285 :             break;

  0003f	eb 5d		 jmp	 SHORT $L39362
$L39366:

; 1286 : 
; 1287 :         case MCPX_FE_STATE_FREE_RUNNING:
; 1288 :             // DPF_BLAB("FE state set to FREE_RUNNING");
; 1289 :             
; 1290 :             rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_FREE_RUNNING;

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _rFeControl$[ebp]
  00044	81 e1 1f ff ff
	ff		 and	 ecx, -225		; ffffff1fH
  0004a	89 4d fc	 mov	 DWORD PTR _rFeControl$[ebp], ecx

; 1291 : 
; 1292 :             break;

  0004d	eb 4f		 jmp	 SHORT $L39362
$L39367:

; 1293 : 
; 1294 :         case MCPX_FE_STATE_ISO:
; 1295 :             // DPF_BLAB("FE state set to ISO");
; 1296 :             
; 1297 :             rFeControl.WriteISO = NV_PAPU_FECTL_FEMWTYP_ISO;

  0004f	8b 55 fc	 mov	 edx, DWORD PTR _rFeControl$[ebp]
  00052	83 ca 04	 or	 edx, 4
  00055	89 55 fc	 mov	 DWORD PTR _rFeControl$[ebp], edx

; 1298 :             rFeControl.ReadISO = NV_PAPU_FECTL_FEMRTYP_ISO;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _rFeControl$[ebp]
  0005b	83 c8 02	 or	 eax, 2
  0005e	89 45 fc	 mov	 DWORD PTR _rFeControl$[ebp], eax

; 1299 :             rFeControl.NotifyISO = NV_PAPU_FECTL_FENTYP_ISO;

  00061	8b 4d fc	 mov	 ecx, DWORD PTR _rFeControl$[ebp]
  00064	83 c9 01	 or	 ecx, 1
  00067	89 4d fc	 mov	 DWORD PTR _rFeControl$[ebp], ecx

; 1300 :             rFeControl.PIOClass = NV_PAPU_FECTL_FEPIOCLASS_ISO;

  0006a	8b 55 fc	 mov	 edx, DWORD PTR _rFeControl$[ebp]
  0006d	81 ca 00 10 00
	00		 or	 edx, 4096		; 00001000H
  00073	89 55 fc	 mov	 DWORD PTR _rFeControl$[ebp], edx

; 1301 : 
; 1302 :             break;

  00076	eb 26		 jmp	 SHORT $L39362
$L39368:

; 1303 : 
; 1304 :         case MCPX_FE_STATE_NON_ISO:
; 1305 :             // DPF_BLAB("FE state set to NON_ISO");
; 1306 :             
; 1307 :             rFeControl.WriteISO = NV_PAPU_FECTL_FEMWTYP_NON_ISO;

  00078	8b 45 fc	 mov	 eax, DWORD PTR _rFeControl$[ebp]
  0007b	83 e0 fb	 and	 eax, -5			; fffffffbH
  0007e	89 45 fc	 mov	 DWORD PTR _rFeControl$[ebp], eax

; 1308 :             rFeControl.ReadISO = NV_PAPU_FECTL_FEMRTYP_NON_ISO;

  00081	8b 4d fc	 mov	 ecx, DWORD PTR _rFeControl$[ebp]
  00084	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00087	89 4d fc	 mov	 DWORD PTR _rFeControl$[ebp], ecx

; 1309 :             rFeControl.NotifyISO = NV_PAPU_FECTL_FENTYP_NON_ISO;

  0008a	8b 55 fc	 mov	 edx, DWORD PTR _rFeControl$[ebp]
  0008d	83 e2 fe	 and	 edx, -2			; fffffffeH
  00090	89 55 fc	 mov	 DWORD PTR _rFeControl$[ebp], edx

; 1310 :             rFeControl.PIOClass = NV_PAPU_FECTL_FEPIOCLASS_NON_ISO;

  00093	8b 45 fc	 mov	 eax, DWORD PTR _rFeControl$[ebp]
  00096	25 ff ef ff ff	 and	 eax, -4097		; ffffefffH
  0009b	89 45 fc	 mov	 DWORD PTR _rFeControl$[ebp], eax
$L39362:

; 1311 : 
; 1312 :             break;
; 1313 : 
; 1314 :         default:
; 1315 :             ASSERTMSG("Invalid FE state");
; 1316 : 
; 1317 :             break;
; 1318 :     }
; 1319 : 
; 1320 :     MCPX_REG_WRITE(NV_PAPU_FECTL, rFeControl.uValue);

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _rFeControl$[ebp]
  000a1	89 0d 00 11 80
	fe		 mov	 DWORD PTR ds:-25161472, ecx

; 1321 : 
; 1322 :     DPF_LEAVE_VOID();
; 1323 : }

  000a7	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000aa	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
$L42380:
  000b5	00 00 00 00	 DD	 $L39365
  000b9	00 00 00 00	 DD	 $L39366
  000bd	00 00 00 00	 DD	 $L39367
  000c1	00 00 00 00	 DD	 $L39368
?SetFrontEndState@CMcpxCore@DirectSound@@IAEXW4MCPX_FE_STATE@@@Z ENDP ; DirectSound::CMcpxCore::SetFrontEndState
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetSetupEngineState@CMcpxCore@DirectSound@@IAEXW4MCPX_SE_STATE@@@Z
DSOUND	SEGMENT
tv68 = -20
_this$ = -16
___AutoIrql$ = -12
_rSeControl$ = -4
_nState$ = 8
?SetSetupEngineState@CMcpxCore@DirectSound@@IAEXW4MCPX_SE_STATE@@@Z PROC NEAR ; DirectSound::CMcpxCore::SetSetupEngineState, COMDAT
; _this$ = ecx

; 1349 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1350 :     R_SE_CONTROL            rSeControl;
; 1351 : 
; 1352 :     DPF_ENTER();
; 1353 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1354 : 
; 1355 :     MCPX_REG_READ(NV_PAPU_SECTL, &rSeControl.uValue);

  00011	a1 00 20 80 fe	 mov	 eax, DWORD PTR ds:-25157632
  00016	89 45 fc	 mov	 DWORD PTR _rSeControl$[ebp], eax

; 1356 : 
; 1357 :     switch(nState)
; 1358 :     {

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _nState$[ebp]
  0001c	89 4d ec	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	83 7d ec 05	 cmp	 DWORD PTR tv68[ebp], 5
  00023	77 74		 ja	 SHORT $L39380
  00025	8b 55 ec	 mov	 edx, DWORD PTR tv68[ebp]
  00028	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L42384[edx*4]
$L39383:

; 1359 :         case MCPX_SE_STATE_OFF:
; 1360 :             // DPF_BLAB("SE state set to OFF");
; 1361 :             
; 1362 :             rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_OFF;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _rSeControl$[ebp]
  00032	83 e0 e7	 and	 eax, -25		; ffffffe7H
  00035	89 45 fc	 mov	 DWORD PTR _rSeControl$[ebp], eax

; 1363 : 
; 1364 :             break;

  00038	eb 5f		 jmp	 SHORT $L39380
$L39384:

; 1365 : 
; 1366 :         case MCPX_SE_STATE_AC_SYNC:
; 1367 :             // DPF_BLAB("SE state set to AC_SYNC");
; 1368 :             
; 1369 :             rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_AC_SYNC;

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _rSeControl$[ebp]
  0003d	83 e1 e7	 and	 ecx, -25		; ffffffe7H
  00040	83 c9 08	 or	 ecx, 8
  00043	89 4d fc	 mov	 DWORD PTR _rSeControl$[ebp], ecx

; 1370 : 
; 1371 :             break;

  00046	eb 51		 jmp	 SHORT $L39380
$L39385:

; 1372 : 
; 1373 :         case MCPX_SE_STATE_SW:
; 1374 :             // DPF_BLAB("SE state set to SW");
; 1375 :             
; 1376 :             rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_SW;

  00048	8b 55 fc	 mov	 edx, DWORD PTR _rSeControl$[ebp]
  0004b	83 e2 e7	 and	 edx, -25		; ffffffe7H
  0004e	83 ca 10	 or	 edx, 16			; 00000010H
  00051	89 55 fc	 mov	 DWORD PTR _rSeControl$[ebp], edx

; 1377 : 
; 1378 :             break;

  00054	eb 43		 jmp	 SHORT $L39380
$L39386:

; 1379 : 
; 1380 :         case MCPX_SE_STATE_FREE_RUNNING:
; 1381 :             // DPF_BLAB("SE state set to FREE_RUNNING");
; 1382 :             
; 1383 :             rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_FREE_RUNNING;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _rSeControl$[ebp]
  00059	83 c8 18	 or	 eax, 24			; 00000018H
  0005c	89 45 fc	 mov	 DWORD PTR _rSeControl$[ebp], eax

; 1384 : 
; 1385 :             break;

  0005f	eb 38		 jmp	 SHORT $L39380
$L39387:

; 1386 : 
; 1387 :         case MCPX_SE_STATE_ISO:
; 1388 :             // DPF_BLAB("SE state set to ISO");
; 1389 :             
; 1390 :             rSeControl.SampleReadISO = NV_PAPU_SECTL_SESRTYP_ISO;

  00061	8b 4d fc	 mov	 ecx, DWORD PTR _rSeControl$[ebp]
  00064	83 c9 04	 or	 ecx, 4
  00067	89 4d fc	 mov	 DWORD PTR _rSeControl$[ebp], ecx

; 1391 :             rSeControl.WriteISO = NV_PAPU_SECTL_SEPWTYP_ISO;

  0006a	8b 55 fc	 mov	 edx, DWORD PTR _rSeControl$[ebp]
  0006d	83 ca 02	 or	 edx, 2
  00070	89 55 fc	 mov	 DWORD PTR _rSeControl$[ebp], edx

; 1392 :             rSeControl.ReadISO = NV_PAPU_SECTL_SEPRTYP_ISO;

  00073	8b 45 fc	 mov	 eax, DWORD PTR _rSeControl$[ebp]
  00076	83 c8 01	 or	 eax, 1
  00079	89 45 fc	 mov	 DWORD PTR _rSeControl$[ebp], eax

; 1393 : 
; 1394 :             break;

  0007c	eb 1b		 jmp	 SHORT $L39380
$L39388:

; 1395 : 
; 1396 :         case MCPX_SE_STATE_NON_ISO:
; 1397 :             // DPF_BLAB("SE state set to NON_ISO");
; 1398 :             
; 1399 :             rSeControl.SampleReadISO = NV_PAPU_SECTL_SESRTYP_NON_ISO;

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _rSeControl$[ebp]
  00081	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00084	89 4d fc	 mov	 DWORD PTR _rSeControl$[ebp], ecx

; 1400 :             rSeControl.WriteISO = NV_PAPU_SECTL_SEPWTYP_NON_ISO;

  00087	8b 55 fc	 mov	 edx, DWORD PTR _rSeControl$[ebp]
  0008a	83 e2 fd	 and	 edx, -3			; fffffffdH
  0008d	89 55 fc	 mov	 DWORD PTR _rSeControl$[ebp], edx

; 1401 :             rSeControl.ReadISO = NV_PAPU_SECTL_SEPRTYP_NON_ISO;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _rSeControl$[ebp]
  00093	83 e0 fe	 and	 eax, -2			; fffffffeH
  00096	89 45 fc	 mov	 DWORD PTR _rSeControl$[ebp], eax
$L39380:

; 1402 : 
; 1403 :             break;
; 1404 : 
; 1405 :         default:
; 1406 :             ASSERTMSG("Invalid SE state");
; 1407 : 
; 1408 :             break;
; 1409 :     }
; 1410 : 
; 1411 :     MCPX_REG_WRITE(NV_PAPU_SECTL, rSeControl.uValue);

  00099	8b 4d fc	 mov	 ecx, DWORD PTR _rSeControl$[ebp]
  0009c	89 0d 00 20 80
	fe		 mov	 DWORD PTR ds:-25157632, ecx

; 1412 : 
; 1413 :     DPF_LEAVE_VOID();
; 1414 : }

  000a2	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000a5	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 04 00	 ret	 4
$L42384:
  000b0	00 00 00 00	 DD	 $L39383
  000b4	00 00 00 00	 DD	 $L39384
  000b8	00 00 00 00	 DD	 $L39385
  000bc	00 00 00 00	 DD	 $L39386
  000c0	00 00 00 00	 DD	 $L39387
  000c4	00 00 00 00	 DD	 $L39388
?SetSetupEngineState@CMcpxCore@DirectSound@@IAEXW4MCPX_SE_STATE@@@Z ENDP ; DirectSound::CMcpxCore::SetSetupEngineState
DSOUND	ENDS
PUBLIC	?GetPhysicalMemoryProperties@CMcpxCore@DirectSound@@SGKPAXKPAK1@Z ; DirectSound::CMcpxCore::GetPhysicalMemoryProperties
EXTRN	__imp__MmGetPhysicalAddress@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetPhysicalMemoryProperties@CMcpxCore@DirectSound@@SGKPAXKPAK1@Z
DSOUND	SEGMENT
tv78 = -20
_dwContiguousLength$ = -16
_dwPhysicalAddress$ = -12
_dwBasePhysicalAddress$ = -8
_dwBasePageOffset$ = -4
_pvBuffer$ = 8
_dwBufferSize$ = 12
_pdwPageOffset$ = 16
_pdwContiguousLength$ = 20
?GetPhysicalMemoryProperties@CMcpxCore@DirectSound@@SGKPAXKPAK1@Z PROC NEAR ; DirectSound::CMcpxCore::GetPhysicalMemoryProperties, COMDAT

; 1448 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1449 :     DWORD                   dwBasePhysicalAddress;
; 1450 :     DWORD                   dwBasePageOffset;
; 1451 :     DWORD                   dwContiguousLength;
; 1452 :     DWORD                   dwPhysicalAddress;
; 1453 : 
; 1454 :     DPF_ENTER();
; 1455 : 
; 1456 :     //
; 1457 :     // Get the base physical address
; 1458 :     //
; 1459 : 
; 1460 :     dwBasePhysicalAddress = MmGetPhysicalAddress(pvBuffer);

  00006	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmGetPhysicalAddress@4
  00010	89 45 f8	 mov	 DWORD PTR _dwBasePhysicalAddress$[ebp], eax

; 1461 : 
; 1462 :     //
; 1463 :     // Get the base page offset
; 1464 :     //
; 1465 : 
; 1466 :     dwBasePageOffset = BYTE_OFFSET(pvBuffer);

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _pvBuffer$[ebp]
  00016	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  0001c	89 4d fc	 mov	 DWORD PTR _dwBasePageOffset$[ebp], ecx

; 1467 : 
; 1468 :     if(pdwPageOffset)

  0001f	83 7d 10 00	 cmp	 DWORD PTR _pdwPageOffset$[ebp], 0
  00023	74 08		 je	 SHORT $L39404

; 1469 :     {
; 1470 :         *pdwPageOffset = dwBasePageOffset;

  00025	8b 55 10	 mov	 edx, DWORD PTR _pdwPageOffset$[ebp]
  00028	8b 45 fc	 mov	 eax, DWORD PTR _dwBasePageOffset$[ebp]
  0002b	89 02		 mov	 DWORD PTR [edx], eax
$L39404:

; 1471 :     }
; 1472 : 
; 1473 :     //
; 1474 :     // Find the count of contiguous bytes in the remaining pages
; 1475 :     //
; 1476 : 
; 1477 :     if(pdwContiguousLength)

  0002d	83 7d 14 00	 cmp	 DWORD PTR _pdwContiguousLength$[ebp], 0
  00031	74 5c		 je	 SHORT $L39405

; 1478 :     {
; 1479 :         dwContiguousLength = PAGE_SIZE - dwBasePageOffset; 

  00033	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00038	2b 4d fc	 sub	 ecx, DWORD PTR _dwBasePageOffset$[ebp]
  0003b	89 4d f0	 mov	 DWORD PTR _dwContiguousLength$[ebp], ecx
$L39407:

; 1480 : 
; 1481 :         while(dwContiguousLength < dwBufferSize)

  0003e	8b 55 f0	 mov	 edx, DWORD PTR _dwContiguousLength$[ebp]
  00041	3b 55 0c	 cmp	 edx, DWORD PTR _dwBufferSize$[ebp]
  00044	73 2b		 jae	 SHORT $L39408

; 1482 :         {
; 1483 :             dwPhysicalAddress = MmGetPhysicalAddress((LPBYTE)pvBuffer + dwContiguousLength);

  00046	8b 45 08	 mov	 eax, DWORD PTR _pvBuffer$[ebp]
  00049	03 45 f0	 add	 eax, DWORD PTR _dwContiguousLength$[ebp]
  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmGetPhysicalAddress@4
  00053	89 45 f4	 mov	 DWORD PTR _dwPhysicalAddress$[ebp], eax

; 1484 :             ASSERT(!(dwPhysicalAddress & (PAGE_SIZE - 1)));
; 1485 : 
; 1486 :             if(dwBasePhysicalAddress + dwContiguousLength != dwPhysicalAddress)

  00056	8b 4d f8	 mov	 ecx, DWORD PTR _dwBasePhysicalAddress$[ebp]
  00059	03 4d f0	 add	 ecx, DWORD PTR _dwContiguousLength$[ebp]
  0005c	3b 4d f4	 cmp	 ecx, DWORD PTR _dwPhysicalAddress$[ebp]
  0005f	74 02		 je	 SHORT $L39410

; 1487 :             {
; 1488 :                 break;

  00061	eb 0e		 jmp	 SHORT $L39408
$L39410:

; 1489 :             }
; 1490 : 
; 1491 :             dwContiguousLength += PAGE_SIZE;

  00063	8b 55 f0	 mov	 edx, DWORD PTR _dwContiguousLength$[ebp]
  00066	81 c2 00 10 00
	00		 add	 edx, 4096		; 00001000H
  0006c	89 55 f0	 mov	 DWORD PTR _dwContiguousLength$[ebp], edx

; 1492 :         }

  0006f	eb cd		 jmp	 SHORT $L39407
$L39408:

; 1493 : 
; 1494 :         *pdwContiguousLength = min(dwContiguousLength, dwBufferSize);

  00071	8b 45 f0	 mov	 eax, DWORD PTR _dwContiguousLength$[ebp]
  00074	3b 45 0c	 cmp	 eax, DWORD PTR _dwBufferSize$[ebp]
  00077	73 08		 jae	 SHORT $L42388
  00079	8b 4d f0	 mov	 ecx, DWORD PTR _dwContiguousLength$[ebp]
  0007c	89 4d ec	 mov	 DWORD PTR tv78[ebp], ecx
  0007f	eb 06		 jmp	 SHORT $L42389
$L42388:
  00081	8b 55 0c	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  00084	89 55 ec	 mov	 DWORD PTR tv78[ebp], edx
$L42389:
  00087	8b 45 14	 mov	 eax, DWORD PTR _pdwContiguousLength$[ebp]
  0008a	8b 4d ec	 mov	 ecx, DWORD PTR tv78[ebp]
  0008d	89 08		 mov	 DWORD PTR [eax], ecx
$L39405:

; 1495 :     }
; 1496 : 
; 1497 :     DPF_LEAVE(dwBasePhysicalAddress);
; 1498 : 
; 1499 :     return dwBasePhysicalAddress;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR _dwBasePhysicalAddress$[ebp]

; 1500 : }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 10 00	 ret	 16			; 00000010H
?GetPhysicalMemoryProperties@CMcpxCore@DirectSound@@SGKPAXKPAK1@Z ENDP ; DirectSound::CMcpxCore::GetPhysicalMemoryProperties
DSOUND	ENDS
PUBLIC	?MapTransfer@CMcpxCore@DirectSound@@SGKPAPAXPAK1@Z ; DirectSound::CMcpxCore::MapTransfer
; Function compile flags: /Odt
;	COMDAT ?MapTransfer@CMcpxCore@DirectSound@@SGKPAPAXPAK1@Z
DSOUND	SEGMENT
tv72 = -16
_dwPhysicalAddress$ = -12
_dwBytesMapped$ = -8
_dwPageOffset$ = -4
_ppvBuffer$ = 8
_pdwBufferSize$ = 12
_pdwBytesMapped$ = 16
?MapTransfer@CMcpxCore@DirectSound@@SGKPAPAXPAK1@Z PROC NEAR ; DirectSound::CMcpxCore::MapTransfer, COMDAT

; 1530 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1531 :     DWORD                   dwPhysicalAddress;
; 1532 :     DWORD                   dwPageOffset;
; 1533 :     DWORD                   dwBytesMapped;
; 1534 : 
; 1535 :     DPF_ENTER();
; 1536 : 
; 1537 :     dwPhysicalAddress = GetPhysicalMemoryProperties(*ppvBuffer, *pdwBufferSize, &dwPageOffset, NULL);

  00006	6a 00		 push	 0
  00008	8d 45 fc	 lea	 eax, DWORD PTR _dwPageOffset$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwBufferSize$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR _ppvBuffer$[ebp]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?GetPhysicalMemoryProperties@CMcpxCore@DirectSound@@SGKPAXKPAK1@Z ; DirectSound::CMcpxCore::GetPhysicalMemoryProperties
  0001d	89 45 f4	 mov	 DWORD PTR _dwPhysicalAddress$[ebp], eax

; 1538 : 
; 1539 :     dwBytesMapped = min(PAGE_SIZE - dwPageOffset, *pdwBufferSize);

  00020	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00025	2b 55 fc	 sub	 edx, DWORD PTR _dwPageOffset$[ebp]
  00028	8b 45 0c	 mov	 eax, DWORD PTR _pdwBufferSize$[ebp]
  0002b	3b 10		 cmp	 edx, DWORD PTR [eax]
  0002d	73 0d		 jae	 SHORT $L42393
  0002f	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00034	2b 4d fc	 sub	 ecx, DWORD PTR _dwPageOffset$[ebp]
  00037	89 4d f0	 mov	 DWORD PTR tv72[ebp], ecx
  0003a	eb 08		 jmp	 SHORT $L42394
$L42393:
  0003c	8b 55 0c	 mov	 edx, DWORD PTR _pdwBufferSize$[ebp]
  0003f	8b 02		 mov	 eax, DWORD PTR [edx]
  00041	89 45 f0	 mov	 DWORD PTR tv72[ebp], eax
$L42394:
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv72[ebp]
  00047	89 4d f8	 mov	 DWORD PTR _dwBytesMapped$[ebp], ecx

; 1540 : 
; 1541 :     *ppvBuffer = (LPBYTE)*ppvBuffer + dwBytesMapped;

  0004a	8b 55 08	 mov	 edx, DWORD PTR _ppvBuffer$[ebp]
  0004d	8b 02		 mov	 eax, DWORD PTR [edx]
  0004f	03 45 f8	 add	 eax, DWORD PTR _dwBytesMapped$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _ppvBuffer$[ebp]
  00055	89 01		 mov	 DWORD PTR [ecx], eax

; 1542 :     *pdwBufferSize -= dwBytesMapped;

  00057	8b 55 0c	 mov	 edx, DWORD PTR _pdwBufferSize$[ebp]
  0005a	8b 02		 mov	 eax, DWORD PTR [edx]
  0005c	2b 45 f8	 sub	 eax, DWORD PTR _dwBytesMapped$[ebp]
  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwBufferSize$[ebp]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 1543 : 
; 1544 :     if(pdwBytesMapped)

  00064	83 7d 10 00	 cmp	 DWORD PTR _pdwBytesMapped$[ebp], 0
  00068	74 08		 je	 SHORT $L39420

; 1545 :     {
; 1546 :         *pdwBytesMapped = dwBytesMapped;

  0006a	8b 55 10	 mov	 edx, DWORD PTR _pdwBytesMapped$[ebp]
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _dwBytesMapped$[ebp]
  00070	89 02		 mov	 DWORD PTR [edx], eax
$L39420:

; 1547 :     }
; 1548 : 
; 1549 :     DPF_LEAVE(dwPhysicalAddress);
; 1550 : 
; 1551 :     return dwPhysicalAddress;

  00072	8b 45 f4	 mov	 eax, DWORD PTR _dwPhysicalAddress$[ebp]

; 1552 : }

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
?MapTransfer@CMcpxCore@DirectSound@@SGKPAPAXPAK1@Z ENDP	; DirectSound::CMcpxCore::MapTransfer
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?AllocateContext@CMcpxCore@DirectSound@@SGJPAUMCPX_ALLOC_CONTEXT@@KK@Z
DSOUND	SEGMENT
_hr$ = -4
_pContext$ = 8
_dwAlignment$ = 12
_dwFlags$ = 16
?AllocateContext@CMcpxCore@DirectSound@@SGJPAUMCPX_ALLOC_CONTEXT@@KK@Z PROC NEAR ; DirectSound::CMcpxCore::AllocateContext, COMDAT

; 1583 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1584 :     HRESULT                 hr;
; 1585 :     
; 1586 :     DPF_ENTER();
; 1587 : 
; 1588 :     ASSERT(!pContext->VirtualAddress);
; 1589 :     ASSERT(!pContext->PhysicalAddress);
; 1590 :     ASSERT(pContext->Size);
; 1591 :     ASSERT(dwAlignment);
; 1592 : 
; 1593 :     if(SUCCEEDED(hr = HRFROMP(pContext->VirtualAddress = PHYSALLOC(BYTE, pContext->Size, dwAlignment, dwFlags))))

  00004	6a 01		 push	 1
  00006	8b 45 10	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _dwAlignment$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR _pContext$[ebp]
  00011	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z ; DirectSound::CMemoryManager::PhysicalAlloc
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	8b 55 08	 mov	 edx, DWORD PTR _pContext$[ebp]
  00022	33 c0		 xor	 eax, eax
  00024	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00027	0f 95 c0	 setne	 al
  0002a	48		 dec	 eax
  0002b	25 0e 00 07 80	 and	 eax, -2147024882	; 8007000eH
  00030	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00033	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00037	7c 12		 jl	 SHORT $L39432

; 1594 :     {
; 1595 :         pContext->PhysicalAddress = MmGetPhysicalAddress(pContext->VirtualAddress);

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  0003c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003e	52		 push	 edx
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmGetPhysicalAddress@4
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  00048	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L39432:

; 1596 :         ASSERT(!(pContext->PhysicalAddress & (dwAlignment - 1)));
; 1597 :     }
; 1598 : 
; 1599 :     DPF_LEAVE_HRESULT(hr);
; 1600 : 
; 1601 :     return hr;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1602 : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
?AllocateContext@CMcpxCore@DirectSound@@SGJPAUMCPX_ALLOC_CONTEXT@@KK@Z ENDP ; DirectSound::CMcpxCore::AllocateContext
DSOUND	ENDS
;	COMDAT ?dwDelta@?1??ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ@4KB
DSOUND_RD	SEGMENT
?dwDelta@?1??ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ@4KB DD 01H DUP (?) ; `DirectSound::CMcpxCore::ResetGlobalCounters'::`2'::dwDelta
DSOUND_RD	ENDS
;	COMDAT ?$S1@?1??ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ@4IA
DSOUND_URW	SEGMENT
?$S1@?1??ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ@4IA DD 01H DUP (?) ; `DirectSound::CMcpxCore::ResetGlobalCounters'::`2'::$S1
; Function compile flags: /Odt
DSOUND_URW	ENDS
;	COMDAT ?ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -4
?ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CMcpxCore::ResetGlobalCounters, COMDAT
; _this$ = ecx

; 1628 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1629 :     static const DWORD      dwDelta = m_adwEPOutputBufferSizes[MCPX_EPOUTPUT_AC97_ANALOG] / 4;

  00007	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?1??ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ@4IA
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	75 1e		 jne	 SHORT $L39441
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$S1@?1??ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ@4IA
  00019	83 c9 01	 or	 ecx, 1
  0001c	89 0d 00 00 00
	00		 mov	 DWORD PTR ?$S1@?1??ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ@4IA, ecx
  00022	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_adwEPOutputBufferSizes@CMcpxCore@DirectSound@@2QBKB
  00028	c1 ea 02	 shr	 edx, 2
  0002b	89 15 00 00 00
	00		 mov	 DWORD PTR ?dwDelta@?1??ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ@4KB, edx
$L39441:

; 1630 : 
; 1631 :     DPF_ENTER();
; 1632 : 
; 1633 :     MCPX_REG_WRITE(NV_PAPU_IGSCNT, dwDelta); 

  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwDelta@?1??ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ@4KB
  00036	a3 08 20 80 fe	 mov	 DWORD PTR ds:-25157624, eax

; 1634 :     MCPX_REG_WRITE(NV_PAPU_XGSCNT, 0);

  0003b	c7 05 0c 20 80
	fe 00 00 00 00	 mov	 DWORD PTR ds:-25157620, 0

; 1635 :     MCPX_REG_WRITE(NV_PAPU_DGSCNT, dwDelta);

  00045	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dwDelta@?1??ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ@4KB
  0004b	89 0d 10 20 80
	fe		 mov	 DWORD PTR ds:-25157616, ecx

; 1636 :     MCPX_REG_WRITE(NV_PAPU_WGSCNT, dwDelta / 2);

  00051	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?dwDelta@?1??ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ@4KB
  00057	d1 ea		 shr	 edx, 1
  00059	89 15 14 20 80
	fe		 mov	 DWORD PTR ds:-25157612, edx

; 1637 :     MCPX_REG_WRITE(NV_PAPU_RGSCNT, dwDelta - 1);

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwDelta@?1??ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ@4KB
  00064	83 e8 01	 sub	 eax, 1
  00067	a3 18 20 80 fe	 mov	 DWORD PTR ds:-25157608, eax

; 1638 :     MCPX_REG_WRITE(NV_PAPU_PGSCNT, 0);

  0006c	c7 05 1c 20 80
	fe 00 00 00 00	 mov	 DWORD PTR ds:-25157604, 0

; 1639 : 
; 1640 :     MCPX_REG_WRITE(NV_PAPU_EGSCNT, 6 * MCPX_HW_EP_STEP_SIZE);

  00076	c7 05 20 20 80
	fe 00 06 00 00	 mov	 DWORD PTR ds:-25157600, 1536 ; 00000600H

; 1641 :     MCPX_REG_WRITE(NV_PAPU_DEGSCNT, MCPX_HW_EP_STEP_SIZE);

  00080	c7 05 24 20 80
	fe 00 01 00 00	 mov	 DWORD PTR ds:-25157596, 256 ; 00000100H

; 1642 :     MCPX_REG_WRITE(NV_PAPU_ECNTSTP, MCPX_HW_EP_STEP_SIZE);

  0008a	c7 05 28 20 80
	fe 00 01 00 00	 mov	 DWORD PTR ds:-25157592, 256 ; 00000100H

; 1643 : 
; 1644 :     MCPX_REG_WRITE(NV_PAPU_EPOFCUR0, 1536);

  00094	c7 05 2c 40 80
	fe 00 06 00 00	 mov	 DWORD PTR ds:-25149396, 1536 ; 00000600H

; 1645 :     MCPX_REG_WRITE(NV_PAPU_EPOFCUR1, m_adwEPOutputBufferSizes[MCPX_EPOUTPUT_AC97_ANALOG] + 6144);

  0009e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_adwEPOutputBufferSizes@CMcpxCore@DirectSound@@2QBKB
  000a4	81 c1 00 18 00
	00		 add	 ecx, 6144		; 00001800H
  000aa	89 0d 3c 40 80
	fe		 mov	 DWORD PTR ds:-25149380, ecx

; 1646 : 
; 1647 :     DPF_LEAVE_VOID();
; 1648 : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
?ResetGlobalCounters@CMcpxCore@DirectSound@@IAEXXZ ENDP	; DirectSound::CMcpxCore::ResetGlobalCounters
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?IdleVoiceProcessor@CMcpxCore@DirectSound@@QAEHH@Z
DSOUND	SEGMENT
_this$ = -36
$T42404 = -32
___AutoIrql$ = -28
_dwTimeout$ = -20
_rFeControl$ = -16
_Notifier$ = -12
_rSeControl$ = -4
_fIdle$ = 8
?IdleVoiceProcessor@CMcpxCore@DirectSound@@QAEHH@Z PROC NEAR ; DirectSound::CMcpxCore::IdleVoiceProcessor, COMDAT
; _this$ = ecx

; 1674 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 1675 :     DWORD                   dwTimeout   = MCPX_HW_FRAME_LENGTH_US;

  00009	c7 45 ec 9b 02
	00 00		 mov	 DWORD PTR _dwTimeout$[ebp], 667 ; 0000029bH

; 1676 :     R_FE_CONTROL            rFeControl;
; 1677 :     R_SE_CONTROL            rSeControl;
; 1678 :     CMcpxNotifier           Notifier;

  00010	8d 4d f4	 lea	 ecx, DWORD PTR _Notifier$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CMcpxNotifier@DirectSound@@QAE@XZ ; DirectSound::CMcpxNotifier::CMcpxNotifier

; 1679 : 
; 1680 :     DPF_ENTER();
; 1681 :     AutoIrql();

  00018	8d 4d e4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1682 : 
; 1683 :     if(fIdle)

  00020	83 7d 08 00	 cmp	 DWORD PTR _fIdle$[ebp], 0
  00024	0f 84 c9 00 00
	00		 je	 $L39495

; 1684 :     {
; 1685 :         //
; 1686 :         // Check the current FE and SE states.  If they're not running, we
; 1687 :         // don't need to idle the VP.
; 1688 :         //
; 1689 : 
; 1690 :         fIdle = FALSE;

  0002a	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _fIdle$[ebp], 0

; 1691 :         
; 1692 :         MCPX_REG_READ(NV_PAPU_FECTL, &rFeControl.uValue);

  00031	a1 00 11 80 fe	 mov	 eax, DWORD PTR ds:-25161472
  00036	89 45 f0	 mov	 DWORD PTR _rFeControl$[ebp], eax

; 1693 :         
; 1694 :         if(NV_PAPU_FECTL_FEMETHMODE_FREE_RUNNING == rFeControl.Mode)

  00039	8b 4d f0	 mov	 ecx, DWORD PTR _rFeControl$[ebp]
  0003c	c1 e9 05	 shr	 ecx, 5
  0003f	83 e1 07	 and	 ecx, 7
  00042	85 c9		 test	 ecx, ecx
  00044	0f 85 a7 00 00
	00		 jne	 $L39475

; 1695 :         {
; 1696 :             MCPX_REG_READ(NV_PAPU_SECTL, &rSeControl.uValue)

  0004a	8b 15 00 20 80
	fe		 mov	 edx, DWORD PTR ds:-25157632
  00050	89 55 fc	 mov	 DWORD PTR _rSeControl$[ebp], edx

; 1697 :     
; 1698 :             if(NV_PAPU_SECTL_XCNTMODE_OFF != rSeControl.GSCUpdate)

  00053	8b 45 fc	 mov	 eax, DWORD PTR _rSeControl$[ebp]
  00056	c1 e8 03	 shr	 eax, 3
  00059	83 e0 03	 and	 eax, 3
  0005c	85 c0		 test	 eax, eax
  0005e	0f 84 8d 00 00
	00		 je	 $L39475

; 1699 :             {
; 1700 :                 fIdle = TRUE;

  00064	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _fIdle$[ebp], 1
$L39479:

; 1701 :     
; 1702 :                 //
; 1703 :                 // Turn off the VP
; 1704 :                 //
; 1705 :     
; 1706 :                 MCPX_CHECK_VOICE_FIFO(1);

  0006b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00070	8b 91 00 00 82
	fe		 mov	 edx, DWORD PTR [ecx-25034752]
  00076	c1 ea 02	 shr	 edx, 2
  00079	83 fa 01	 cmp	 edx, 1
  0007c	73 02		 jae	 SHORT $L39480
  0007e	eb eb		 jmp	 SHORT $L39479
$L39480:

; 1707 :                 MCPX_VOICE_WRITE(SetProcessorMode, NV1BA0_PIO_SET_MODE_PARAMETER_OFF);

  00080	b8 0c 01 00 00	 mov	 eax, 268		; 0000010cH
  00085	c7 80 00 00 82
	fe 00 00 00 00	 mov	 DWORD PTR [eax-25034752], 0

; 1708 : 
; 1709 :                 //
; 1710 :                 // Wait for the VP to tell us it's idle
; 1711 :                 //
; 1712 : 
; 1713 :                 if(m_ctxMemory[MCPX_MEM_NOTIFIERS].VirtualAddress)

  0008f	83 3d 40 00 00
	00 00		 cmp	 DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+64, 0
  00096	74 4f		 je	 SHORT $L39485

; 1714 :                 {
; 1715 :                     Notifier.Initialize(0, 1);

  00098	6a 01		 push	 1
  0009a	6a 00		 push	 0
  0009c	8d 4d f4	 lea	 ecx, DWORD PTR _Notifier$[ebp]
  0009f	e8 00 00 00 00	 call	 ?Initialize@CMcpxNotifier@DirectSound@@QAEXKK@Z ; DirectSound::CMcpxNotifier::Initialize

; 1716 :     
; 1717 :                     MCPX_VOICE_WRITE(Synchronize, NV1BA0_PIO_SYNCHRONIZE_PARAMETER_WAIT_FOR_IDLE_WRITE_PE_NOTIFY);

  000a4	b9 04 01 00 00	 mov	 ecx, 260		; 00000104H
  000a9	c7 81 00 00 82
	fe 02 00 00 00	 mov	 DWORD PTR [ecx-25034752], 2
$L39489:

; 1718 : 
; 1719 :                     while(!Notifier.GetStatus(0))

  000b3	6a 00		 push	 0
  000b5	8d 4d f4	 lea	 ecx, DWORD PTR _Notifier$[ebp]
  000b8	e8 00 00 00 00	 call	 ?GetStatus@CMcpxNotifier@DirectSound@@QAEHK@Z ; DirectSound::CMcpxNotifier::GetStatus
  000bd	85 c0		 test	 eax, eax
  000bf	75 1c		 jne	 SHORT $L39490

; 1720 :                     {
; 1721 :                         KeStallExecutionProcessor(1);

  000c1	6a 01		 push	 1
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeStallExecutionProcessor@4

; 1722 : 
; 1723 :                         if(!dwTimeout--)

  000c9	8b 55 ec	 mov	 edx, DWORD PTR _dwTimeout$[ebp]
  000cc	8b 45 ec	 mov	 eax, DWORD PTR _dwTimeout$[ebp]
  000cf	83 e8 01	 sub	 eax, 1
  000d2	89 45 ec	 mov	 DWORD PTR _dwTimeout$[ebp], eax
  000d5	85 d2		 test	 edx, edx
  000d7	75 02		 jne	 SHORT $L39491

; 1724 :                         {
; 1725 :                             break;

  000d9	eb 02		 jmp	 SHORT $L39490
$L39491:

; 1726 :                         }
; 1727 :                     }

  000db	eb d6		 jmp	 SHORT $L39489
$L39490:

; 1728 : 
; 1729 :                     Notifier.Reset();

  000dd	8d 4d f4	 lea	 ecx, DWORD PTR _Notifier$[ebp]
  000e0	e8 00 00 00 00	 call	 ?Reset@CMcpxNotifier@DirectSound@@QAEXXZ ; DirectSound::CMcpxNotifier::Reset

; 1730 :                 }
; 1731 :                 else

  000e5	eb 0a		 jmp	 SHORT $L39475
$L39485:

; 1732 :                 {
; 1733 :                     KeStallExecutionProcessor(dwTimeout);

  000e7	8b 4d ec	 mov	 ecx, DWORD PTR _dwTimeout$[ebp]
  000ea	51		 push	 ecx
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeStallExecutionProcessor@4
$L39475:

; 1734 :                 }
; 1735 :             }
; 1736 :         }
; 1737 :     }
; 1738 :     else

  000f1	eb 24		 jmp	 SHORT $L39493
$L39495:

; 1739 :     {
; 1740 :         //
; 1741 :         // Turn the VP back on
; 1742 :         //
; 1743 :         
; 1744 :         MCPX_CHECK_VOICE_FIFO(1);

  000f3	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000f8	8b 82 00 00 82
	fe		 mov	 eax, DWORD PTR [edx-25034752]
  000fe	c1 e8 02	 shr	 eax, 2
  00101	83 f8 01	 cmp	 eax, 1
  00104	73 02		 jae	 SHORT $L39496
  00106	eb eb		 jmp	 SHORT $L39495
$L39496:

; 1745 :         MCPX_VOICE_WRITE(SetProcessorMode, NV1BA0_PIO_SET_MODE_PARAMETER_RUN);

  00108	b9 0c 01 00 00	 mov	 ecx, 268		; 0000010cH
  0010d	c7 81 00 00 82
	fe 01 00 00 00	 mov	 DWORD PTR [ecx-25034752], 1
$L39493:

; 1746 :     }        
; 1747 : 
; 1748 :     DPF_LEAVE(fIdle);
; 1749 : 
; 1750 :     return fIdle;

  00117	8b 55 08	 mov	 edx, DWORD PTR _fIdle$[ebp]
  0011a	89 55 e0	 mov	 DWORD PTR $T42404[ebp], edx
  0011d	8d 4d e4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00120	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00125	8b 45 e0	 mov	 eax, DWORD PTR $T42404[ebp]

; 1751 : }

  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c2 04 00	 ret	 4
?IdleVoiceProcessor@CMcpxCore@DirectSound@@QAEHH@Z ENDP	; DirectSound::CMcpxCore::IdleVoiceProcessor
DSOUND	ENDS
PUBLIC	??0CMcpxDspScratchDma@DirectSound@@QAE@H@Z	; DirectSound::CMcpxDspScratchDma::CMcpxDspScratchDma
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dspdma.cpp
;	COMDAT ??0CMcpxDspScratchDma@DirectSound@@QAE@H@Z
DSOUND	SEGMENT
_this$ = -4
_fGpScratch$ = 8
??0CMcpxDspScratchDma@DirectSound@@QAE@H@Z PROC NEAR	; DirectSound::CMcpxDspScratchDma::CMcpxDspScratchDma, COMDAT
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 17   :     m_dwMaxPages = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 18   :     m_fGpScratch = fGpScratch;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _fGpScratch$[ebp]
  00016	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 19   :     memset(&m_ctxFxScratch,0,sizeof(m_ctxFxScratch));

  00019	6a 10		 push	 16			; 00000010H
  0001b	6a 00		 push	 0
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 14	 add	 eax, 20			; 00000014H
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _memset
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20   : 
; 21   : }

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??0CMcpxDspScratchDma@DirectSound@@QAE@H@Z ENDP		; DirectSound::CMcpxDspScratchDma::CMcpxDspScratchDma
DSOUND	ENDS
PUBLIC	??1CMcpxDspScratchDma@DirectSound@@QAE@XZ	; DirectSound::CMcpxDspScratchDma::~CMcpxDspScratchDma
EXTRN	__imp__MmLockUnlockBufferPages@12:NEAR
; Function compile flags: /Odt
;	COMDAT ??1CMcpxDspScratchDma@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CMcpxDspScratchDma@DirectSound@@QAE@XZ PROC NEAR	; DirectSound::CMcpxDspScratchDma::~CMcpxDspScratchDma, COMDAT
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   :     if (m_ctxFxScratch.VirtualAddress && m_ctxFxScratch.Size) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0000e	74 3e		 je	 SHORT $L39509
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00017	74 35		 je	 SHORT $L39509

; 26   : 
; 27   :         MmLockUnlockBufferPages(m_ctxFxScratch.VirtualAddress,m_ctxFxScratch.Size,TRUE);

  00019	6a 01		 push	 1
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00021	50		 push	 eax
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00028	52		 push	 edx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmLockUnlockBufferPages@12

; 28   :         POOLFREE(m_ctxFxScratch.VirtualAddress);

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00036	74 16		 je	 SHORT $L39509
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PoolFree
  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
$L39509:

; 29   : 
; 30   :     }
; 31   : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
??1CMcpxDspScratchDma@DirectSound@@QAE@XZ ENDP		; DirectSound::CMcpxDspScratchDma::~CMcpxDspScratchDma
DSOUND	ENDS
PUBLIC	?Initialize@CMcpxDspScratchDma@DirectSound@@QAEXK@Z ; DirectSound::CMcpxDspScratchDma::Initialize
; Function compile flags: /Odt
;	COMDAT ?Initialize@CMcpxDspScratchDma@DirectSound@@QAEXK@Z
DSOUND	SEGMENT
tv66 = -32
_this$ = -28
_i$39523 = -24
_bytesRemaining$ = -20
_pPrd$ = -16
_index$ = -12
_bytesMapped$ = -8
_currentVa$ = -4
_dwReservedPages$ = 8
?Initialize@CMcpxDspScratchDma@DirectSound@@QAEXK@Z PROC NEAR ; DirectSound::CMcpxDspScratchDma::Initialize, COMDAT
; _this$ = ecx

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 36   : 
; 37   :     ULONG index = (m_fGpScratch == TRUE) ? (index = MCPX_MEM_GPSCRATCH) : (MCPX_MEM_EPSCRATCH);

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 08 01	 cmp	 DWORD PTR [eax+8], 1
  00010	75 0f		 jne	 SHORT $L42414
  00012	c7 45 f4 0c 00
	00 00		 mov	 DWORD PTR _index$[ebp], 12 ; 0000000cH
  00019	8b 4d f4	 mov	 ecx, DWORD PTR _index$[ebp]
  0001c	89 4d e0	 mov	 DWORD PTR tv66[ebp], ecx
  0001f	eb 07		 jmp	 SHORT $L42415
$L42414:
  00021	c7 45 e0 0e 00
	00 00		 mov	 DWORD PTR tv66[ebp], 14	; 0000000eH
$L42415:
  00028	8b 55 e0	 mov	 edx, DWORD PTR tv66[ebp]
  0002b	89 55 f4	 mov	 DWORD PTR _index$[ebp], edx

; 38   : 
; 39   :     //
; 40   :     // keep a pointer to the proper alloc contexts
; 41   :     //
; 42   : 
; 43   :     m_pDmaBufferContext = &CMcpxCore::m_ctxMemory[index];

  0002e	8b 45 f4	 mov	 eax, DWORD PTR _index$[ebp]
  00031	c1 e0 04	 shl	 eax, 4
  00034	05 00 00 00 00	 add	 eax, OFFSET FLAT:?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A ; DirectSound::CMcpxCore::m_ctxMemory
  00039	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 44   :     m_pSgeTableContext = &CMcpxCore::m_ctxMemory[index+1];

  0003f	8b 55 f4	 mov	 edx, DWORD PTR _index$[ebp]
  00042	83 c2 01	 add	 edx, 1
  00045	c1 e2 04	 shl	 edx, 4
  00048	81 c2 00 00 00
	00		 add	 edx, OFFSET FLAT:?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A ; DirectSound::CMcpxCore::m_ctxMemory
  0004e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00051	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 45   : 
; 46   :     //
; 47   :     // the caller passes us an array of ALLOC_CONTEXTs
; 48   :     // first one is the allocation for the scratch memory itself
; 49   :     // the second is the allocation for the SGE table describing the scratch space
; 50   :     //
; 51   : 
; 52   : 	m_dwMaxPages = (USHORT) (m_pSgeTableContext->Size / NV_PSGE_SIZE);

  00054	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0005a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005d	c1 e8 03	 shr	 eax, 3
  00060	0f b7 c8	 movzx	 ecx, ax
  00063	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00066	89 0a		 mov	 DWORD PTR [edx], ecx

; 53   :     m_dwReservedPages = dwReservedPages;

  00068	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _dwReservedPages$[ebp]
  0006e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 54   : 
; 55   :     //
; 56   :     // initialize the hw SGE table and our internal page table to point to 
; 57   :     // DMA allocated memory
; 58   :     //
; 59   : 
; 60   :     MCP1_PRD *pPrd = (MCP1_PRD *)m_pSgeTableContext->VirtualAddress;

  00071	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00074	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00077	8b 08		 mov	 ecx, DWORD PTR [eax]
  00079	89 4d f0	 mov	 DWORD PTR _pPrd$[ebp], ecx

; 61   : 
; 62   :     ULONG bytesRemaining = m_pDmaBufferContext->Size;

  0007c	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0007f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00082	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00085	89 4d ec	 mov	 DWORD PTR _bytesRemaining$[ebp], ecx

; 63   :     ULONG bytesMapped = 0;

  00088	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bytesMapped$[ebp], 0

; 64   :     PVOID currentVa = m_pDmaBufferContext->VirtualAddress;

  0008f	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00092	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00095	8b 08		 mov	 ecx, DWORD PTR [eax]
  00097	89 4d fc	 mov	 DWORD PTR _currentVa$[ebp], ecx

; 65   : 
; 66   :     //
; 67   :     // note that all pages are 4k aligned and since the dma buffer is 4k length
; 68   :     // aligned, all sizes are 4k as well..
; 69   :     //
; 70   : 
; 71   :     for (ULONG i = 0; i < m_dwMaxPages-dwReservedPages; i++)

  0009a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$39523[ebp], 0
  000a1	eb 09		 jmp	 SHORT $L39524
$L39525:
  000a3	8b 55 e8	 mov	 edx, DWORD PTR _i$39523[ebp]
  000a6	83 c2 01	 add	 edx, 1
  000a9	89 55 e8	 mov	 DWORD PTR _i$39523[ebp], edx
$L39524:
  000ac	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000af	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b1	2b 4d 08	 sub	 ecx, DWORD PTR _dwReservedPages$[ebp]
  000b4	39 4d e8	 cmp	 DWORD PTR _i$39523[ebp], ecx
  000b7	73 43		 jae	 SHORT $L39526

; 72   :     {
; 73   :         pPrd[i].uAddr = CMcpxCore::MapTransfer(&currentVa,
; 74   :                                                &bytesRemaining,
; 75   :                                                &bytesMapped);

  000b9	8d 55 f8	 lea	 edx, DWORD PTR _bytesMapped$[ebp]
  000bc	52		 push	 edx
  000bd	8d 45 ec	 lea	 eax, DWORD PTR _bytesRemaining$[ebp]
  000c0	50		 push	 eax
  000c1	8d 4d fc	 lea	 ecx, DWORD PTR _currentVa$[ebp]
  000c4	51		 push	 ecx
  000c5	e8 00 00 00 00	 call	 ?MapTransfer@CMcpxCore@DirectSound@@SGKPAPAXPAK1@Z ; DirectSound::CMcpxCore::MapTransfer
  000ca	8b 55 e8	 mov	 edx, DWORD PTR _i$39523[ebp]
  000cd	8b 4d f0	 mov	 ecx, DWORD PTR _pPrd$[ebp]
  000d0	89 04 d1	 mov	 DWORD PTR [ecx+edx*8], eax

; 76   : 
; 77   :         pPrd[i].Control.uValue = 0;

  000d3	8b 55 e8	 mov	 edx, DWORD PTR _i$39523[ebp]
  000d6	8b 45 f0	 mov	 eax, DWORD PTR _pPrd$[ebp]
  000d9	c7 44 d0 04 00
	00 00 00	 mov	 DWORD PTR [eax+edx*8+4], 0

; 78   :         pPrd[i].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;       

  000e1	8b 4d e8	 mov	 ecx, DWORD PTR _i$39523[ebp]
  000e4	8b 55 f0	 mov	 edx, DWORD PTR _pPrd$[ebp]
  000e7	8b 44 ca 04	 mov	 eax, DWORD PTR [edx+ecx*8+4]
  000eb	25 ff ff ff fe	 and	 eax, -16777217		; feffffffH
  000f0	8b 4d e8	 mov	 ecx, DWORD PTR _i$39523[ebp]
  000f3	8b 55 f0	 mov	 edx, DWORD PTR _pPrd$[ebp]
  000f6	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 79   : 
; 80   :     }

  000fa	eb a7		 jmp	 SHORT $L39525
$L39526:

; 81   : 
; 82   :     //
; 83   :     // Set base address for GP/EP scratch
; 84   :     //
; 85   : 
; 86   :     //
; 87   :     // tell the hw that all pages are valid , except the reserved ones
; 88   :     //
; 89   :     
; 90   :     if (m_fGpScratch) {

  000fc	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000ff	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00103	74 20		 je	 SHORT $L39527

; 91   : 
; 92   :         MCPX_REG_WRITE(NV_PAPU_GPSADDR, m_pSgeTableContext->PhysicalAddress);    

  00105	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00108	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0010b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0010e	a3 40 20 80 fe	 mov	 DWORD PTR ds:-25157568, eax

; 93   :         MCPX_REG_WRITE(NV_PAPU_GPSMAXSGE, m_dwMaxPages-m_dwReservedPages);

  00113	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00116	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00119	8b 01		 mov	 eax, DWORD PTR [ecx]
  0011b	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  0011e	a3 d4 20 80 fe	 mov	 DWORD PTR ds:-25157420, eax

; 94   : 
; 95   :     } else {

  00123	eb 19		 jmp	 SHORT $L39515
$L39527:

; 96   : 
; 97   :         MCPX_REG_WRITE(NV_PAPU_EPSADDR, m_pSgeTableContext->PhysicalAddress);    

  00125	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00128	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0012b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0012e	a3 48 20 80 fe	 mov	 DWORD PTR ds:-25157560, eax

; 98   :         MCPX_REG_WRITE(NV_PAPU_EPSMAXSGE, m_dwMaxPages);

  00133	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	8b 11		 mov	 edx, DWORD PTR [ecx]
  00138	89 15 dc 20 80
	fe		 mov	 DWORD PTR ds:-25157412, edx
$L39515:

; 99   :     }
; 100  : 
; 101  :     return;
; 102  : }

  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c2 04 00	 ret	 4
?Initialize@CMcpxDspScratchDma@DirectSound@@QAEXK@Z ENDP ; DirectSound::CMcpxDspScratchDma::Initialize
DSOUND	ENDS
PUBLIC	?AddPages@CMcpxDspScratchDma@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@KPAK@Z ; DirectSound::CMcpxDspScratchDma::AddPages
; Function compile flags: /Odt
;	COMDAT ?AddPages@CMcpxDspScratchDma@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@KPAK@Z
DSOUND	SEGMENT
_this$ = -16
_dwPageIndex$ = -12
_pPrd$ = -8
_i$ = -4
_pContextArray$ = 8
_dwCount$ = 12
_pOffset$ = 16
?AddPages@CMcpxDspScratchDma@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@KPAK@Z PROC NEAR ; DirectSound::CMcpxDspScratchDma::AddPages, COMDAT
; _this$ = ecx

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 111  :     DWORD dwPageIndex = m_dwMaxPages - m_dwReservedPages;

  0000a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00015	89 55 f4	 mov	 DWORD PTR _dwPageIndex$[ebp], edx

; 112  :     ULONG i;
; 113  : 
; 114  :     ASSERT(dwCount <= m_dwReservedPages);
; 115  : 
; 116  :     m_dwReservedPages -= dwCount;

  00018	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	2b 4d 0c	 sub	 ecx, DWORD PTR _dwCount$[ebp]
  00021	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00024	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 117  : 
; 118  :     MCP1_PRD *pPrd = (MCP1_PRD *)CMcpxCore::m_ctxMemory[MCPX_MEM_GPSCRATCHSGE].VirtualAddress;

  00027	a1 d0 00 00 00	 mov	 eax, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+208
  0002c	89 45 f8	 mov	 DWORD PTR _pPrd$[ebp], eax

; 119  : 
; 120  :     for (i=0;i<dwCount;i++) {

  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00036	eb 09		 jmp	 SHORT $L39547
$L39548:
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0003b	83 c1 01	 add	 ecx, 1
  0003e	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L39547:
  00041	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00044	3b 55 0c	 cmp	 edx, DWORD PTR _dwCount$[ebp]
  00047	73 4c		 jae	 SHORT $L39549

; 121  : 
; 122  :         //
; 123  :         // update the hw SGE table
; 124  :         //
; 125  : 
; 126  :         pPrd[dwPageIndex+i].uAddr = pContextArray[i].PhysicalAddress;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004c	c1 e0 04	 shl	 eax, 4
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR _dwPageIndex$[ebp]
  00052	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00055	8b 55 f8	 mov	 edx, DWORD PTR _pPrd$[ebp]
  00058	8b 75 08	 mov	 esi, DWORD PTR _pContextArray$[ebp]
  0005b	8b 44 06 04	 mov	 eax, DWORD PTR [esi+eax+4]
  0005f	89 04 ca	 mov	 DWORD PTR [edx+ecx*8], eax

; 127  : 
; 128  :         pPrd[dwPageIndex+i].Control.uValue = 0;

  00062	8b 4d f4	 mov	 ecx, DWORD PTR _dwPageIndex$[ebp]
  00065	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00068	8b 55 f8	 mov	 edx, DWORD PTR _pPrd$[ebp]
  0006b	c7 44 ca 04 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*8+4], 0

; 129  :         pPrd[dwPageIndex+i].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;       

  00073	8b 45 f4	 mov	 eax, DWORD PTR _dwPageIndex$[ebp]
  00076	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00079	8b 4d f8	 mov	 ecx, DWORD PTR _pPrd$[ebp]
  0007c	8b 54 c1 04	 mov	 edx, DWORD PTR [ecx+eax*8+4]
  00080	81 e2 ff ff ff
	fe		 and	 edx, -16777217		; feffffffH
  00086	8b 45 f4	 mov	 eax, DWORD PTR _dwPageIndex$[ebp]
  00089	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR _pPrd$[ebp]
  0008f	89 54 c1 04	 mov	 DWORD PTR [ecx+eax*8+4], edx

; 130  : 
; 131  :     }

  00093	eb a3		 jmp	 SHORT $L39548
$L39549:

; 132  : 
; 133  :     //
; 134  :     // tell the hw that all pages are valid , including the reserved ones
; 135  :     //
; 136  :     
; 137  :     MCPX_REG_WRITE(NV_PAPU_GPSMAXSGE, m_dwMaxPages-m_dwReservedPages);

  00095	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00098	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0009d	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  000a0	89 0d d4 20 80
	fe		 mov	 DWORD PTR ds:-25157420, ecx

; 138  : 
; 139  :     //
; 140  :     // give them the linear offset into our DMA buffer window
; 141  :     //
; 142  : 
; 143  :     *pOffset = dwPageIndex*PAGE_SIZE;

  000a6	8b 55 f4	 mov	 edx, DWORD PTR _dwPageIndex$[ebp]
  000a9	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  000ac	8b 45 10	 mov	 eax, DWORD PTR _pOffset$[ebp]
  000af	89 10		 mov	 DWORD PTR [eax], edx

; 144  :     return;
; 145  : 
; 146  : }

  000b1	5e		 pop	 esi
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 0c 00	 ret	 12			; 0000000cH
?AddPages@CMcpxDspScratchDma@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@KPAK@Z ENDP ; DirectSound::CMcpxDspScratchDma::AddPages
DSOUND	ENDS
PUBLIC	?Copy@CMcpxDspScratchDma@DirectSound@@QAEXKPAXK@Z ; DirectSound::CMcpxDspScratchDma::Copy
; Function compile flags: /Odt
;	COMDAT ?Copy@CMcpxDspScratchDma@DirectSound@@QAEXKPAXK@Z
DSOUND	SEGMENT
_this$ = -8
_pDest$ = -4
_uLinOffset$ = 8
_pSource$ = 12
_uSize$ = 16
?Copy@CMcpxDspScratchDma@DirectSound@@QAEXKPAXK@Z PROC NEAR ; DirectSound::CMcpxDspScratchDma::Copy, COMDAT
; _this$ = ecx

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 152  :     //
; 153  :     // scratch mem is contigious
; 154  :     //
; 155  : 
; 156  :     PUCHAR pDest = (PUCHAR)m_pDmaBufferContext->VirtualAddress+uLinOffset;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	03 55 08	 add	 edx, DWORD PTR _uLinOffset$[ebp]
  00014	89 55 fc	 mov	 DWORD PTR _pDest$[ebp], edx

; 157  :     memcpy(pDest, pSource, uSize);

  00017	8b 45 10	 mov	 eax, DWORD PTR _uSize$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _pSource$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _pDest$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 _memcpy
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 158  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 0c 00	 ret	 12			; 0000000cH
?Copy@CMcpxDspScratchDma@DirectSound@@QAEXKPAXK@Z ENDP	; DirectSound::CMcpxDspScratchDma::Copy
DSOUND	ENDS
PUBLIC	?AdjustFxScratch@CMcpxDspScratchDma@DirectSound@@QAEJK@Z ; DirectSound::CMcpxDspScratchDma::AdjustFxScratch
; Function compile flags: /Odt
;	COMDAT ?AdjustFxScratch@CMcpxDspScratchDma@DirectSound@@QAEJK@Z
DSOUND	SEGMENT
_this$ = -40
_dwPageIndex$ = -36
_pPrd$ = -32
_ctx$ = -24
_i$ = -8
_dwCount$ = -4
_dwSize$ = 8
?AdjustFxScratch@CMcpxDspScratchDma@DirectSound@@QAEJK@Z PROC NEAR ; DirectSound::CMcpxDspScratchDma::AdjustFxScratch, COMDAT
; _this$ = ecx

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 163  : 
; 164  :     MCPX_ALLOC_CONTEXT ctx;
; 165  :     ULONG offset,i;
; 166  :     DWORD dwPageIndex = m_dwMaxPages-m_dwReservedPages;

  00009	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00014	89 55 dc	 mov	 DWORD PTR _dwPageIndex$[ebp], edx

; 167  :     MCP1_PRD *pPrd = (MCP1_PRD *)CMcpxCore::m_ctxMemory[MCPX_MEM_GPSCRATCHSGE].VirtualAddress;

  00017	a1 d0 00 00 00	 mov	 eax, DWORD PTR ?m_ctxMemory@CMcpxCore@DirectSound@@2PAUMCPX_ALLOC_CONTEXT@@A+208
  0001c	89 45 e0	 mov	 DWORD PTR _pPrd$[ebp], eax

; 168  :     DWORD dwCount = dwSize/PAGE_SIZE;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  00022	c1 e9 0c	 shr	 ecx, 12			; 0000000cH
  00025	89 4d fc	 mov	 DWORD PTR _dwCount$[ebp], ecx

; 169  : 
; 170  :     if (dwCount > m_dwReservedPages) {

  00028	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _dwCount$[ebp]
  0002e	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00031	76 0a		 jbe	 SHORT $L39571

; 171  : 
; 172  :         DPF_ERROR("Effects Image scratch space usage exceed max (%d) pages",
; 173  :                   MCPX_HW_MAX_FX_SCRATCH_PAGES);
; 174  : 
; 175  :         return DSERR_OUTOFMEMORY;

  00033	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00038	e9 25 01 00 00	 jmp	 $L39563
$L39571:

; 176  :     }
; 177  : 
; 178  :     ctx.Size = 0;

  0003d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ctx$[ebp+8], 0

; 179  : 
; 180  :     if (m_ctxFxScratch.Size < dwSize) {

  00044	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0004a	3b 55 08	 cmp	 edx, DWORD PTR _dwSize$[ebp]
  0004d	73 5f		 jae	 SHORT $L39573

; 181  : 
; 182  :         //
; 183  :         // there is already scratch allocated for FX delay lines
; 184  :         // If its larger than what we need dont do anything.
; 185  :         // if its less, free whats there and replace it with a new allocation
; 186  :         //
; 187  :     
; 188  :         memcpy(&ctx,&m_ctxFxScratch,sizeof(m_ctxFxScratch));        

  0004f	6a 10		 push	 16			; 00000010H
  00051	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00054	83 c0 14	 add	 eax, 20			; 00000014H
  00057	50		 push	 eax
  00058	8d 4d e8	 lea	 ecx, DWORD PTR _ctx$[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _memcpy
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH

; 189  : 
; 190  :         //
; 191  :         // allocate a new one
; 192  :         //
; 193  : 
; 194  :         m_ctxFxScratch.Size = dwSize;

  00064	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00067	8b 45 08	 mov	 eax, DWORD PTR _dwSize$[ebp]
  0006a	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 195  :         m_ctxFxScratch.VirtualAddress = POOLALLOC(BYTE, m_ctxFxScratch.Size);

  0006d	6a 01		 push	 1
  0006f	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00075	52		 push	 edx
  00076	68 44 53 64 61	 push	 1633964868		; 61645344H
  0007b	e8 00 00 00 00	 call	 ?PoolAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::PoolAlloc
  00080	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 196  :         if (m_ctxFxScratch.VirtualAddress == NULL) {

  00086	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00089	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  0008d	75 0a		 jne	 SHORT $L39576

; 197  : 
; 198  :             return E_OUTOFMEMORY;

  0008f	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00094	e9 c9 00 00 00	 jmp	 $L39563
$L39576:

; 199  : 
; 200  :         }
; 201  : 
; 202  :         MmLockUnlockBufferPages(m_ctxFxScratch.VirtualAddress,dwSize,FALSE);

  00099	6a 00		 push	 0
  0009b	8b 45 08	 mov	 eax, DWORD PTR _dwSize$[ebp]
  0009e	50		 push	 eax
  0009f	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000a5	52		 push	 edx
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmLockUnlockBufferPages@12

; 203  : 
; 204  :     } else {

  000ac	eb 07		 jmp	 SHORT $L39578
$L39573:

; 205  : 
; 206  :         return DS_OK;

  000ae	33 c0		 xor	 eax, eax
  000b0	e9 ad 00 00 00	 jmp	 $L39563
$L39578:

; 207  :     }
; 208  : 
; 209  : 
; 210  :     for (i=0;i<dwCount;i++) {

  000b5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000bc	eb 09		 jmp	 SHORT $L39580
$L39581:
  000be	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000c1	83 c0 01	 add	 eax, 1
  000c4	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L39580:
  000c7	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000ca	3b 4d fc	 cmp	 ecx, DWORD PTR _dwCount$[ebp]
  000cd	73 52		 jae	 SHORT $L39582

; 211  : 
; 212  :         //
; 213  :         // update the hw SGE table
; 214  :         //
; 215  : 
; 216  :         pPrd[dwPageIndex+i].uAddr = MmGetPhysicalAddress(i*PAGE_SIZE+(PUCHAR)m_ctxFxScratch.VirtualAddress);

  000cf	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000d2	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  000d5	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	03 50 14	 add	 edx, DWORD PTR [eax+20]
  000db	52		 push	 edx
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmGetPhysicalAddress@4
  000e2	8b 4d dc	 mov	 ecx, DWORD PTR _dwPageIndex$[ebp]
  000e5	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  000e8	8b 55 e0	 mov	 edx, DWORD PTR _pPrd$[ebp]
  000eb	89 04 ca	 mov	 DWORD PTR [edx+ecx*8], eax

; 217  :         pPrd[dwPageIndex+i].Control.uValue = 0;

  000ee	8b 45 dc	 mov	 eax, DWORD PTR _dwPageIndex$[ebp]
  000f1	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000f4	8b 4d e0	 mov	 ecx, DWORD PTR _pPrd$[ebp]
  000f7	c7 44 c1 04 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*8+4], 0

; 218  :         pPrd[dwPageIndex+i].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;       

  000ff	8b 55 dc	 mov	 edx, DWORD PTR _dwPageIndex$[ebp]
  00102	03 55 f8	 add	 edx, DWORD PTR _i$[ebp]
  00105	8b 45 e0	 mov	 eax, DWORD PTR _pPrd$[ebp]
  00108	8b 4c d0 04	 mov	 ecx, DWORD PTR [eax+edx*8+4]
  0010c	81 e1 ff ff ff
	fe		 and	 ecx, -16777217		; feffffffH
  00112	8b 55 dc	 mov	 edx, DWORD PTR _dwPageIndex$[ebp]
  00115	03 55 f8	 add	 edx, DWORD PTR _i$[ebp]
  00118	8b 45 e0	 mov	 eax, DWORD PTR _pPrd$[ebp]
  0011b	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx

; 219  : 
; 220  :     }

  0011f	eb 9d		 jmp	 SHORT $L39581
$L39582:

; 221  : 
; 222  :     //
; 223  :     // tell the hw, more pages are now valid...
; 224  :     //
; 225  : 
; 226  :     MCPX_REG_WRITE(NV_PAPU_GPSMAXSGE, m_dwMaxPages-m_dwReservedPages+dwCount);

  00121	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00127	8b 01		 mov	 eax, DWORD PTR [ecx]
  00129	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  0012c	03 45 fc	 add	 eax, DWORD PTR _dwCount$[ebp]
  0012f	a3 d4 20 80 fe	 mov	 DWORD PTR ds:-25157420, eax

; 227  : 
; 228  :     //
; 229  :     // free old allocation
; 230  :     //
; 231  : 
; 232  :     if (ctx.Size) {

  00134	83 7d f0 00	 cmp	 DWORD PTR _ctx$[ebp+8], 0
  00138	74 26		 je	 SHORT $L39586

; 233  : 
; 234  :         MmLockUnlockBufferPages(ctx.VirtualAddress,ctx.Size,TRUE);

  0013a	6a 01		 push	 1
  0013c	8b 4d f0	 mov	 ecx, DWORD PTR _ctx$[ebp+8]
  0013f	51		 push	 ecx
  00140	8b 55 e8	 mov	 edx, DWORD PTR _ctx$[ebp]
  00143	52		 push	 edx
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmLockUnlockBufferPages@12

; 235  :         POOLFREE(ctx.VirtualAddress);

  0014a	83 7d e8 00	 cmp	 DWORD PTR _ctx$[ebp], 0
  0014e	74 10		 je	 SHORT $L39586
  00150	8b 45 e8	 mov	 eax, DWORD PTR _ctx$[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ?PoolFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PoolFree
  00159	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ctx$[ebp], 0
$L39586:

; 236  : 
; 237  :     }
; 238  : 
; 239  :     return DS_OK;

  00160	33 c0		 xor	 eax, eax
$L39563:

; 240  : }

  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c2 04 00	 ret	 4
?AdjustFxScratch@CMcpxDspScratchDma@DirectSound@@QAEJK@Z ENDP ; DirectSound::CMcpxDspScratchDma::AdjustFxScratch
DSOUND	ENDS
PUBLIC	?Initialize@CMcpxDspImage@DirectSound@@QAEXXZ	; DirectSound::CMcpxDspImage::Initialize
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\gpdsp.cpp
;	COMDAT ?Initialize@CMcpxDspImage@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -4
?Initialize@CMcpxDspImage@DirectSound@@QAEXXZ PROC NEAR	; DirectSound::CMcpxDspImage::Initialize, COMDAT
; _this$ = ecx

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 44   :     //
; 45   :     // initialize all the effects here
; 46   :     //
; 47   : 
; 48   :     m_pLoader = (PVOID)DefaultExec;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_DefaultExec

; 49   :     m_uLoaderSize = sizeof(DefaultExec);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 94 18
	00 00		 mov	 DWORD PTR [ecx+4], 6292	; 00001894H

; 50   :    
; 51   : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?Initialize@CMcpxDspImage@DirectSound@@QAEXXZ ENDP	; DirectSound::CMcpxDspImage::Initialize
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??0CMcpxGPDspManager@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CMcpxGPDspManager@DirectSound@@QAE@XZ PROC NEAR	; DirectSound::CMcpxGPDspManager::CMcpxGPDspManager, COMDAT
; _this$ = ecx

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   :     m_pScratchDma = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 64   :     m_pDspImage = NULL;

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 65   :     m_uPMemMaxSize = NV_PAPU_GPPMEM__SIZE_1;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 14 00 10
	00 00		 mov	 DWORD PTR [edx+20], 4096 ; 00001000H

; 66   :     m_uPMemOffset = 0;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 67   : 
; 68   :     m_dwCurrentLowestScratchOffset = MCPX_GLOBAL_PROC_SCRATCH_SIZE;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	c7 41 18 00 80
	00 00		 mov	 DWORD PTR [ecx+24], 32768 ; 00008000H

; 69   :     m_dwStateSizeToCommit = 0;

  00039	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 70   : 
; 71   : }

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??0CMcpxGPDspManager@DirectSound@@QAE@XZ ENDP		; DirectSound::CMcpxGPDspManager::CMcpxGPDspManager
DSOUND	ENDS
PUBLIC	??_GCMcpxDspScratchDma@DirectSound@@QAEPAXI@Z	; DirectSound::CMcpxDspScratchDma::`scalar deleting destructor'
; Function compile flags: /Odt
;	COMDAT ??1CMcpxGPDspManager@DirectSound@@QAE@XZ
DSOUND	SEGMENT
tv71 = -20
_this$ = -16
$T42438 = -12
$T42435 = -8
$T42434 = -4
??1CMcpxGPDspManager@DirectSound@@QAE@XZ PROC NEAR	; DirectSound::CMcpxGPDspManager::~CMcpxGPDspManager, COMDAT
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 75   :     DELETE(m_pScratchDma);

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00010	74 35		 je	 SHORT $L39605
  00012	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00018	89 55 f8	 mov	 DWORD PTR $T42435[ebp], edx
  0001b	8b 45 f8	 mov	 eax, DWORD PTR $T42435[ebp]
  0001e	89 45 fc	 mov	 DWORD PTR $T42434[ebp], eax
  00021	83 7d fc 00	 cmp	 DWORD PTR $T42434[ebp], 0
  00025	74 0f		 je	 SHORT $L42436
  00027	6a 01		 push	 1
  00029	8b 4d fc	 mov	 ecx, DWORD PTR $T42434[ebp]
  0002c	e8 00 00 00 00	 call	 ??_GCMcpxDspScratchDma@DirectSound@@QAEPAXI@Z
  00031	89 45 ec	 mov	 DWORD PTR tv71[ebp], eax
  00034	eb 07		 jmp	 SHORT $L42437
$L42436:
  00036	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L42437:
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
$L39605:

; 76   :     DELETE(m_pDspImage);

  00047	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0004a	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0004e	74 1f		 je	 SHORT $L39604
  00050	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00056	89 4d f4	 mov	 DWORD PTR $T42438[ebp], ecx
  00059	8b 55 f4	 mov	 edx, DWORD PTR $T42438[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00062	83 c4 04	 add	 esp, 4
  00065	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00068	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
$L39604:

; 77   : #ifndef MCPX_BOOT_LIB
; 78   :     DELETE(m_pFxDescriptor);
; 79   : #endif
; 80   : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
??1CMcpxGPDspManager@DirectSound@@QAE@XZ ENDP		; DirectSound::CMcpxGPDspManager::~CMcpxGPDspManager
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??_GCMcpxDspScratchDma@DirectSound@@QAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCMcpxDspScratchDma@DirectSound@@QAEPAXI@Z PROC NEAR	; DirectSound::CMcpxDspScratchDma::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMcpxDspScratchDma@DirectSound@@QAE@XZ ; DirectSound::CMcpxDspScratchDma::~CMcpxDspScratchDma
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L39613
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L39613:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCMcpxDspScratchDma@DirectSound@@QAEPAXI@Z ENDP	; DirectSound::CMcpxDspScratchDma::`scalar deleting destructor'
DSOUND	ENDS
PUBLIC	??0CMcpxDspImage@DirectSound@@QAE@XZ		; DirectSound::CMcpxDspImage::CMcpxDspImage
PUBLIC	?GetLoader@CMcpxDspImage@DirectSound@@QAEPAXXZ	; DirectSound::CMcpxDspImage::GetLoader
PUBLIC	?GetLoaderSize@CMcpxDspImage@DirectSound@@QAEKXZ ; DirectSound::CMcpxDspImage::GetLoaderSize
; Function compile flags: /Odt
;	COMDAT ?Initialize@CMcpxGPDspManager@DirectSound@@QAEXXZ
DSOUND	SEGMENT
tv81 = -24
tv70 = -20
_this$ = -16
$T42448 = -12
$T42445 = -8
_uOffset$ = -4
?Initialize@CMcpxGPDspManager@DirectSound@@QAEXXZ PROC NEAR ; DirectSound::CMcpxGPDspManager::Initialize, COMDAT
; _this$ = ecx

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 85   :     //
; 86   :     // create the dsp table class that holds the code for all effects + loader
; 87   :     //
; 88   : 
; 89   :     m_pDspImage = NEW(CMcpxDspImage());

  00009	6a 08		 push	 8
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4
  00013	89 45 f8	 mov	 DWORD PTR $T42445[ebp], eax
  00016	83 7d f8 00	 cmp	 DWORD PTR $T42445[ebp], 0
  0001a	74 0d		 je	 SHORT $L42446
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR $T42445[ebp]
  0001f	e8 00 00 00 00	 call	 ??0CMcpxDspImage@DirectSound@@QAE@XZ ; DirectSound::CMcpxDspImage::CMcpxDspImage
  00024	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00027	eb 07		 jmp	 SHORT $L42447
$L42446:
  00029	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$L42447:
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 4d ec	 mov	 ecx, DWORD PTR tv70[ebp]
  00036	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 90   :     ASSERT(m_pDspImage);
; 91   : 
; 92   :     m_pDspImage->Initialize();

  00039	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0003f	e8 00 00 00 00	 call	 ?Initialize@CMcpxDspImage@DirectSound@@QAEXXZ ; DirectSound::CMcpxDspImage::Initialize

; 93   : 
; 94   :     //
; 95   :     // allocate the scratch Dma, telling it we are the GP
; 96   :     //
; 97   : 
; 98   :     m_pScratchDma = NEW(CMcpxDspScratchDma(TRUE));

  00044	6a 28		 push	 40			; 00000028H
  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004b	83 c4 04	 add	 esp, 4
  0004e	89 45 f4	 mov	 DWORD PTR $T42448[ebp], eax
  00051	83 7d f4 00	 cmp	 DWORD PTR $T42448[ebp], 0
  00055	74 0f		 je	 SHORT $L42449
  00057	6a 01		 push	 1
  00059	8b 4d f4	 mov	 ecx, DWORD PTR $T42448[ebp]
  0005c	e8 00 00 00 00	 call	 ??0CMcpxDspScratchDma@DirectSound@@QAE@H@Z ; DirectSound::CMcpxDspScratchDma::CMcpxDspScratchDma
  00061	89 45 e8	 mov	 DWORD PTR tv81[ebp], eax
  00064	eb 07		 jmp	 SHORT $L42450
$L42449:
  00066	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L42450:
  0006d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 4d e8	 mov	 ecx, DWORD PTR tv81[ebp]
  00073	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 99   :     ASSERT(m_pScratchDma);
; 100  : 
; 101  :     //
; 102  :     // initialize scratch space handler
; 103  :     //
; 104  : 
; 105  :     m_pScratchDma->Initialize(MCPX_HW_AC3_NUM_INPUT_PAGES+MCPX_HW_MULTIPASS_NUM_PAGES+MCPX_HW_MAX_FX_SCRATCH_PAGES);

  00076	68 04 02 00 00	 push	 516			; 00000204H
  0007b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0007e	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00081	e8 00 00 00 00	 call	 ?Initialize@CMcpxDspScratchDma@DirectSound@@QAEXK@Z ; DirectSound::CMcpxDspScratchDma::Initialize

; 106  :     
; 107  :     if (!m_pScratchDma)

  00086	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00089	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0008d	75 02		 jne	 SHORT $L39621

; 108  :     {
; 109  :         ASSERT(FALSE && "CMcpxDspManager::Initialize - one of the objects could not be constructed\n");
; 110  :         return;

  0008f	eb 2e		 jmp	 SHORT $L39616
$L39621:

; 111  :     }
; 112  :     
; 113  :     ULONG uOffset = 0;

  00091	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _uOffset$[ebp], 0

; 114  : 
; 115  :     ASSERT(m_pDspImage->GetLoaderSize() < DSP_COMMANDBLOCK_SCRATCHOFFSET);
; 116  : 
; 117  :     //
; 118  :     // load a default exec program to get the GP pumping data to system memory
; 119  :     //
; 120  :     
; 121  :     m_pScratchDma->Copy(uOffset,
; 122  :                         (VOID *)m_pDspImage->GetLoader(),
; 123  :                         m_pDspImage->GetLoaderSize());

  00098	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0009e	e8 00 00 00 00	 call	 ?GetLoaderSize@CMcpxDspImage@DirectSound@@QAEKXZ ; DirectSound::CMcpxDspImage::GetLoaderSize
  000a3	50		 push	 eax
  000a4	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a7	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  000aa	e8 00 00 00 00	 call	 ?GetLoader@CMcpxDspImage@DirectSound@@QAEPAXXZ ; DirectSound::CMcpxDspImage::GetLoader
  000af	50		 push	 eax
  000b0	8b 45 fc	 mov	 eax, DWORD PTR _uOffset$[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  000ba	e8 00 00 00 00	 call	 ?Copy@CMcpxDspScratchDma@DirectSound@@QAEXKPAXK@Z ; DirectSound::CMcpxDspScratchDma::Copy
$L39616:

; 124  : 
; 125  :     return ;
; 126  : 
; 127  : }

  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
?Initialize@CMcpxGPDspManager@DirectSound@@QAEXXZ ENDP	; DirectSound::CMcpxGPDspManager::Initialize
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\gpdsp.h
DSOUND	ENDS
;	COMDAT ??0CMcpxDspImage@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CMcpxDspImage@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CMcpxDspImage::CMcpxDspImage, COMDAT
; _this$ = ecx

; 36   :         CMcpxDspImage()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 37   :         {
; 38   :             m_pLoader = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   :             m_uLoaderSize = 0;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 40   :         }

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0CMcpxDspImage@DirectSound@@QAE@XZ ENDP		; DirectSound::CMcpxDspImage::CMcpxDspImage
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?GetLoader@CMcpxDspImage@DirectSound@@QAEPAXXZ
DSOUND	SEGMENT
_this$ = -4
?GetLoader@CMcpxDspImage@DirectSound@@QAEPAXXZ PROC NEAR ; DirectSound::CMcpxDspImage::GetLoader, COMDAT
; _this$ = ecx

; 44   :         PVOID       GetLoader() { return m_pLoader; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetLoader@CMcpxDspImage@DirectSound@@QAEPAXXZ ENDP	; DirectSound::CMcpxDspImage::GetLoader
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?GetLoaderSize@CMcpxDspImage@DirectSound@@QAEKXZ
DSOUND	SEGMENT
_this$ = -4
?GetLoaderSize@CMcpxDspImage@DirectSound@@QAEKXZ PROC NEAR ; DirectSound::CMcpxDspImage::GetLoaderSize, COMDAT
; _this$ = ecx

; 45   :         ULONG       GetLoaderSize() { return m_uLoaderSize; }    

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetLoaderSize@CMcpxDspImage@DirectSound@@QAEKXZ ENDP	; DirectSound::CMcpxDspImage::GetLoaderSize
DSOUND	ENDS
PUBLIC	?DownloadEffectsImage@CMcpxGPDspManager@DirectSound@@QAEJPBXKPAPAU_DSEFFECTIMAGEDESC@@@Z ; DirectSound::CMcpxGPDspManager::DownloadEffectsImage
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\gpdsp.cpp
;	COMDAT ?DownloadEffectsImage@CMcpxGPDspManager@DirectSound@@QAEJPBXKPAPAU_DSEFFECTIMAGEDESC@@@Z
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
_pvImageBuffer$ = 8
_dwImageSize$ = 12
_ppImageDesc$ = 16
?DownloadEffectsImage@CMcpxGPDspManager@DirectSound@@QAEJPBXKPAPAU_DSEFFECTIMAGEDESC@@@Z PROC NEAR ; DirectSound::CMcpxGPDspManager::DownloadEffectsImage, COMDAT
; _this$ = ecx

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 136  : 
; 137  :     HRESULT hr = DS_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 138  : #ifndef MCPX_BOOT_LIB
; 139  : 
; 140  :     PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;
; 141  : 
; 142  :     //
; 143  :     // do some basic validation of the image
; 144  :     // this should be the image generated by our XPS2 tool..
; 145  :     //
; 146  : 
; 147  :     ASSERT(dwImageSize > (DSP_COMMANDBLOCK_SCRATCHOFFSET + sizeof(HOST_TO_DSP_COMMANDBLOCK)));
; 148  : 
; 149  :     //
; 150  :     // verify that command block is preset for instructing the DSP to download new
; 151  :     // code and state
; 152  :     //
; 153  : 
; 154  :     pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)pvImageBuffer + DSP_COMMANDBLOCK_SCRATCHOFFSET);
; 155  : 
; 156  :     ASSERT(pCmdBlock->dwCommandFlags & BIT_H2DCB_COMMAND_LOAD_CODE);
; 157  :     ASSERT(pCmdBlock->dwCommandFlags & BIT_H2DCB_COMMAND_LOAD_XRAM_STATE);
; 158  : 
; 159  :     ASSERT(dwImageSize <= MCPX_GLOBAL_PROC_SCRATCH_SIZE);
; 160  : 
; 161  :     //
; 162  :     // proceed to copy the buffer they passed us into offset 0 of scratch memory
; 163  :     // first zero out the flags in the command block so the dsp does not attempt
; 164  :     // to download yet
; 165  :     //
; 166  : 
; 167  :     PHOST_TO_DSP_COMMANDBLOCK pPrivateCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);
; 168  :     memset(pPrivateCmdBlock,0,sizeof(HOST_TO_DSP_COMMANDBLOCK));
; 169  : 
; 170  :     //
; 171  :     // copy their image into two parts: 1st part is the command block, second is the rest
; 172  :     // we dont copy the flags since we want them 0 in the scratch image
; 173  :     //
; 174  : 
; 175  :     pPrivateCmdBlock->dwOffset = pCmdBlock->dwOffset;
; 176  :     pPrivateCmdBlock->dwCodeLength = pCmdBlock->dwCodeLength;
; 177  :     pPrivateCmdBlock->dwStateOffset = pCmdBlock->dwStateOffset;
; 178  :     pPrivateCmdBlock->dwStateLength = pCmdBlock->dwStateLength;
; 179  :     pPrivateCmdBlock->dwDspStatus = pCmdBlock->dwDspStatus;
; 180  : 
; 181  :     m_pScratchDma->Copy(DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK),
; 182  :                         (PUCHAR)pCmdBlock+sizeof(HOST_TO_DSP_COMMANDBLOCK),
; 183  :                         dwImageSize - DSP_COMMANDBLOCK_SCRATCHOFFSET - sizeof(HOST_TO_DSP_COMMANDBLOCK));
; 184  : 
; 185  :     //
; 186  :     // parse FX description array, to be used by the SetEffectData api
; 187  :     //
; 188  : 
; 189  :     hr = ParseEffectImageInfo(pvImageBuffer);
; 190  :     if (FAILED(hr)){
; 191  :         return hr;
; 192  :     }
; 193  : 
; 194  :     if(ppImageDesc) {
; 195  :         *ppImageDesc = m_pFxDescriptor;
; 196  :     }
; 197  : 
; 198  :     //
; 199  :     // we need to keep a cached version of the command block associated with this image
; 200  :     // We do this so if the user calls SetEffectData and then a delta panic occurs,
; 201  :     // we can restore the command block and re-download the original code from the
; 202  :     // correct offset
; 203  :     //
; 204  : 
; 205  :     memcpy(&m_InitialCmdBlock,pPrivateCmdBlock,sizeof(m_InitialCmdBlock));
; 206  : 
; 207  : #endif //MCPX_BOOT_LIB
; 208  : 
; 209  :     return hr;

  00010	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 210  : 
; 211  : 
; 212  : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
?DownloadEffectsImage@CMcpxGPDspManager@DirectSound@@QAEJPBXKPAPAU_DSEFFECTIMAGEDESC@@@Z ENDP ; DirectSound::CMcpxGPDspManager::DownloadEffectsImage
DSOUND	ENDS
PUBLIC	?GetScratchSpaceLinAddr@CMcpxDspScratchDma@DirectSound@@QAEPAXXZ ; DirectSound::CMcpxDspScratchDma::GetScratchSpaceLinAddr
PUBLIC	?RestoreCommandBlock@CMcpxGPDspManager@DirectSound@@QAEXXZ ; DirectSound::CMcpxGPDspManager::RestoreCommandBlock
; Function compile flags: /Odt
;	COMDAT ?RestoreCommandBlock@CMcpxGPDspManager@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -8
_pPrivateCmdBlock$ = -4
?RestoreCommandBlock@CMcpxGPDspManager@DirectSound@@QAEXXZ PROC NEAR ; DirectSound::CMcpxGPDspManager::RestoreCommandBlock, COMDAT
; _this$ = ecx

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 216  : 
; 217  :     PHOST_TO_DSP_COMMANDBLOCK pPrivateCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	e8 00 00 00 00	 call	 ?GetScratchSpaceLinAddr@CMcpxDspScratchDma@DirectSound@@QAEPAXXZ ; DirectSound::CMcpxDspScratchDma::GetScratchSpaceLinAddr
  00014	05 00 08 00 00	 add	 eax, 2048		; 00000800H
  00019	89 45 fc	 mov	 DWORD PTR _pPrivateCmdBlock$[ebp], eax

; 218  : 
; 219  :     pPrivateCmdBlock->dwCommandFlags = 0;

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _pPrivateCmdBlock$[ebp]
  0001f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 220  :     memcpy(pPrivateCmdBlock,&m_InitialCmdBlock,sizeof(m_InitialCmdBlock));

  00026	6a 18		 push	 24			; 00000018H
  00028	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	83 c2 24	 add	 edx, 36			; 00000024H
  0002e	52		 push	 edx
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _pPrivateCmdBlock$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _memcpy
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 221  : 
; 222  : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?RestoreCommandBlock@CMcpxGPDspManager@DirectSound@@QAEXXZ ENDP ; DirectSound::CMcpxGPDspManager::RestoreCommandBlock
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\dspdma.h
DSOUND	ENDS
;	COMDAT ?GetScratchSpaceLinAddr@CMcpxDspScratchDma@DirectSound@@QAEPAXXZ
DSOUND	SEGMENT
_this$ = -4
?GetScratchSpaceLinAddr@CMcpxDspScratchDma@DirectSound@@QAEPAXXZ PROC NEAR ; DirectSound::CMcpxDspScratchDma::GetScratchSpaceLinAddr, COMDAT
; _this$ = ecx

; 40   :         VOID *GetScratchSpaceLinAddr() { return m_pDmaBufferContext->VirtualAddress; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetScratchSpaceLinAddr@CMcpxDspScratchDma@DirectSound@@QAEPAXXZ ENDP ; DirectSound::CMcpxDspScratchDma::GetScratchSpaceLinAddr
DSOUND	ENDS
PUBLIC	?ParseEffectImageInfo@CMcpxGPDspManager@DirectSound@@IAEJPBX@Z ; DirectSound::CMcpxGPDspManager::ParseEffectImageInfo
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\gpdsp.cpp
;	COMDAT ?ParseEffectImageInfo@CMcpxGPDspManager@DirectSound@@IAEJPBX@Z
DSOUND	SEGMENT
_this$ = -12
_hr$ = -4
_pScratchImage$ = 8
?ParseEffectImageInfo@CMcpxGPDspManager@DirectSound@@IAEJPBX@Z PROC NEAR ; DirectSound::CMcpxGPDspManager::ParseEffectImageInfo, COMDAT
; _this$ = ecx

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 226  :     DWORD dwValue;
; 227  :     HRESULT hr = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 228  : 
; 229  : #ifndef MCPX_BOOT_LIB
; 230  : 
; 231  :     //
; 232  :     // retrieve and cache the FX description array
; 233  :     // We will use it later when the game calls the UpdateEffectParameters API
; 234  :     //
; 235  : 
; 236  :     LPDSEFFECTIMAGEDESC pDescriptor;
; 237  :     UCHAR szKey[8];
; 238  :     int err;
; 239  :     DWORD dwFxScratchSize = 0;
; 240  : 
; 241  :     PUCHAR pCodeBlock;
; 242  :     PUCHAR pKeyBlock;
; 243  : 
; 244  :     PHOST_TO_DSP_COMMANDBLOCK pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);
; 245  : 
; 246  :     pDescriptor = (LPDSEFFECTIMAGEDESC) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() +
; 247  :         DSP_COMMANDBLOCK_SCRATCHOFFSET +\
; 248  :         sizeof(HOST_TO_DSP_COMMANDBLOCK) +\
; 249  :         (pCmdBlock->dwCodeLength*sizeof(DWORD)) +\
; 250  :         (pCmdBlock->dwStateLength*sizeof(DWORD)) );
; 251  : 
; 252  : 
; 253  : 	//
; 254  : 	// initialize descriptor
; 255  : 	//
; 256  : 
; 257  : 	DWORD dwDescriptorSize = sizeof(DSEFFECTIMAGEDESC) + 
; 258  : 		sizeof(DSEFFECTMAP)*(pDescriptor->dwEffectCount-1);
; 259  : 
; 260  : 
; 261  :     if (m_pFxDescriptor != NULL) {
; 262  : 
; 263  :         DELETE(m_pFxDescriptor);
; 264  :         
; 265  :     }
; 266  : 
; 267  :     m_pFxDescriptor = (LPDSEFFECTIMAGEDESC) NEW(BYTE[dwDescriptorSize]);
; 268  : 
; 269  :     if (m_pFxDescriptor == NULL) {
; 270  :         return E_OUTOFMEMORY;
; 271  :     }
; 272  : 
; 273  :     //
; 274  :     // check the scratch space usage for the FX chain
; 275  :     // adjust our ram allocation if required
; 276  :     //
; 277  : 
; 278  :     if (FAILED(hr = m_pScratchDma->AdjustFxScratch(pDescriptor->dwTotalScratchSize))){
; 279  :         return hr;
; 280  :     }
; 281  : 
; 282  :     //
; 283  :     // we will have to decode the dsp code words since each one
; 284  :     // is encrypted, using a different dsp dev supplied key.
; 285  :     // we do in-place decryption
; 286  :     //
; 287  : 
; 288  :     pCodeBlock = (PUCHAR)pCmdBlock + sizeof(HOST_TO_DSP_COMMANDBLOCK);
; 289  :     pKeyBlock = (PUCHAR)pDescriptor + dwDescriptorSize;
; 290  : 
; 291  :     //
; 292  :     // decode keys used to encrypt block
; 293  :     //
; 294  : 
; 295  : 	XAudiopUtility_GenerateKey(szKey);
; 296  : 
; 297  : 	err = XAudiopUtility_Decode(szKey,
; 298  : 		pKeyBlock,
; 299  : 		KEY_SIZE*pDescriptor->dwEffectCount,
; 300  : 		pKeyBlock,
; 301  : 		FALSE);
; 302  : 	
; 303  :     hr = HRESULT_FROM_WIN32(err);
; 304  :     if (FAILED(hr)) {
; 305  :         DPF_ERROR("Keyblock decode failed with hr = %x",hr);
; 306  :         return hr;
; 307  :     }
; 308  : 
; 309  :     //
; 310  :     // we need to convert all offsets in FX description elements
; 311  :     // from relative (the tool creates relative offsets) to absolute
; 312  :     // This way the caller can treat the LPVOIDs into State, Ymem, Code
; 313  :     // as normal virtual memory pointers. 
; 314  :     //
; 315  : 
; 316  :     for (ULONG i=0;i<pDescriptor->dwEffectCount;i++) {
; 317  : 
; 318  :         //
; 319  :         // decode key block in place using appropriate key
; 320  :         //
; 321  : 
; 322  :         err = XAudiopUtility_Decode((pKeyBlock+i*KEY_SIZE),
; 323  :             pCodeBlock,
; 324  :             pDescriptor->aEffectMaps[i].dwCodeSize,
; 325  :             pCodeBlock,
; 326  :             FALSE);
; 327  :         
; 328  :         hr = HRESULT_FROM_WIN32(err);
; 329  :         if (FAILED(hr)) {
; 330  :             DPF_ERROR("code block decode failed with hr = %x",hr);
; 331  :             return hr;
; 332  :         }
; 333  : 
; 334  :         pCodeBlock += pDescriptor->aEffectMaps[i].dwCodeSize;
; 335  : 
; 336  :         //
; 337  :         // convert code first
; 338  :         //
; 339  : 
; 340  :         dwValue = (DWORD) pDescriptor->aEffectMaps[i].lpvCodeSegment;
; 341  : 
; 342  :         //
; 343  :         // create a P-memory absolute address in bytes
; 344  :         //
; 345  : 
; 346  :         dwValue -= (DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK));
; 347  : 
; 348  :         //
; 349  :         // the fx start after the default engine P-words
; 350  :         //
; 351  : 
; 352  :         dwValue += m_pDspImage->GetLoaderSize();
; 353  : 
; 354  :         //
; 355  :         // convert P-memory address to a MCPX base register space address
; 356  :         //
; 357  : 
; 358  :         dwValue += MCPX_HW_GPPMEM_REG_OFFSET;
; 359  : 
; 360  :         pDescriptor->aEffectMaps[i].lpvCodeSegment = (LPVOID)dwValue;
; 361  : 
; 362  :         //
; 363  :         // do the same for Y memory. The tool creates absolute Ymem addresses
; 364  :         // so all we need to do is add the register space offset
; 365  :         //
; 366  : 
; 367  :         dwValue = (DWORD) pDescriptor->aEffectMaps[i].lpvYMemorySegment;
; 368  : 
; 369  :         //
; 370  :         // convert Y-memory address to a MCPX base register space address
; 371  :         //
; 372  : 
; 373  :         dwValue += MCPX_HW_GPYMEM_REG_OFFSET;
; 374  :         pDescriptor->aEffectMaps[i].lpvYMemorySegment = (LPVOID)dwValue;
; 375  : 
; 376  :         //
; 377  :         // now convert X-memory relative address
; 378  :         //
; 379  : 
; 380  :         dwValue = (DWORD) pDescriptor->aEffectMaps[i].lpvStateSegment;
; 381  : 
; 382  :         //
; 383  :         // create a X-memory absolute address in bytes
; 384  :         //
; 385  : 
; 386  :         dwValue -= (DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK));
; 387  :         dwValue -= pCmdBlock->dwCodeLength*sizeof(DWORD);
; 388  :         dwValue += DSP_FX_STATE_XMEMORY_BASE_OFFSET;
; 389  : 
; 390  :         //
; 391  :         // convert X-memory address to a MCPX base register space address
; 392  :         //
; 393  : 
; 394  :         dwValue += MCPX_HW_GPXMEM_REG_OFFSET;
; 395  :         pDescriptor->aEffectMaps[i].lpvStateSegment = (LPVOID)dwValue;
; 396  : 
; 397  :         //
; 398  :         // finally fixup scratch space offset to point to a real VA, not
; 399  :         // just a relative scratch offset
; 400  :         //
; 401  : 
; 402  :         dwValue = (DWORD)pDescriptor->aEffectMaps[i].lpvScratchSegment;
; 403  :         dwValue += (DWORD) m_pScratchDma->GetFxScratchSpaceLinAddr();
; 404  : 
; 405  :         //
; 406  :         // subtract the fx delay line base offset
; 407  :         //
; 408  : 
; 409  :         dwValue -= DSP_FX_DELAY_DATA_SCRATCHOFFSET;
; 410  : 
; 411  :         pDescriptor->aEffectMaps[i].lpvScratchSegment = (LPVOID) dwValue;
; 412  :         
; 413  :     }
; 414  : 
; 415  :     memcpy(m_pFxDescriptor,pDescriptor,dwDescriptorSize);
; 416  : 
; 417  :     //
; 418  :     // the dsp will automagically DMA in the new FX dsp code and state when its done with the
; 419  :     // current 32 sample block processing...
; 420  :     //
; 421  : 
; 422  :     pCmdBlock->dwCommandFlags = BIT_H2DCB_COMMAND_LOAD_CODE | BIT_H2DCB_COMMAND_LOAD_XRAM_STATE;
; 423  : 
; 424  :     volatile DWORD *pdwflags = &pCmdBlock->dwCommandFlags;
; 425  :     while(*pdwflags != 0);
; 426  : 
; 427  : #endif // MCPX_BOOT_LIB
; 428  : 
; 429  :     return S_OK;

  00010	33 c0		 xor	 eax, eax

; 430  : 
; 431  : }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?ParseEffectImageInfo@CMcpxGPDspManager@DirectSound@@IAEJPBX@Z ENDP ; DirectSound::CMcpxGPDspManager::ParseEffectImageInfo
DSOUND	ENDS
PUBLIC	?GetEffectMap@CMcpxGPDspManager@DirectSound@@QAEJKPAPBU_DSEFFECTMAP@@@Z ; DirectSound::CMcpxGPDspManager::GetEffectMap
; Function compile flags: /Odt
;	COMDAT ?SetEffectData@CMcpxGPDspManager@DirectSound@@QAEJKKPBXKK@Z
DSOUND	SEGMENT
tv144 = -28
_this$ = -24
_pFxDesc$ = -20
_hr$ = -16
_pvXramBuffer$ = -12
_dwScratchOffset$ = -8
_pCmdBlock$ = -4
_dwEffectIndex$ = 8
_dwOffset$ = 12
_pvData$ = 16
_dwDataSize$ = 20
_dwFlags$ = 24
?SetEffectData@CMcpxGPDspManager@DirectSound@@QAEJKKPBXKK@Z PROC NEAR ; DirectSound::CMcpxGPDspManager::SetEffectData, COMDAT
; _this$ = ecx

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 444  :     LPCDSEFFECTMAP pFxDesc;
; 445  :     PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;
; 446  :     DWORD dwScratchOffset;
; 447  :     LPVOID pvXramBuffer;
; 448  :     HRESULT hr;
; 449  : 
; 450  :     ASSERT(dwDataSize >= sizeof(DWORD));
; 451  : 
; 452  :     //
; 453  :     // FX offset and size must be dword aligned
; 454  :     //
; 455  : 
; 456  :     ASSERT(!(dwDataSize & 0x00000003));
; 457  :     ASSERT(!(dwOffset & 0x00000003));
; 458  : 
; 459  :     //
; 460  :     // get effect map
; 461  :     //
; 462  : 
; 463  :     hr = GetEffectMap(dwEffectIndex, &pFxDesc);

  00009	8d 45 ec	 lea	 eax, DWORD PTR _pFxDesc$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _dwEffectIndex$[ebp]
  00010	51		 push	 ecx
  00011	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?GetEffectMap@CMcpxGPDspManager@DirectSound@@QAEJKPAPBU_DSEFFECTMAP@@@Z ; DirectSound::CMcpxGPDspManager::GetEffectMap
  00019	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 464  :     if (FAILED(hr)) {

  0001c	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00020	7d 08		 jge	 SHORT $L39660

; 465  :         return hr;

  00022	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  00025	e9 30 01 00 00	 jmp	 $L39653
$L39660:

; 466  :     }
; 467  : 
; 468  :     //
; 469  :     // validate fx specific parameters
; 470  :     //
; 471  : 
; 472  :     ASSERT(pFxDesc->dwStateSize >= (dwOffset+dwDataSize));
; 473  : 
; 474  :     //
; 475  :     // copy in the data they want to update
; 476  :     // figure a scratch offset, from the mcpx base register space offset
; 477  :     //
; 478  : 
; 479  :     pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

  0002a	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00030	e8 00 00 00 00	 call	 ?GetScratchSpaceLinAddr@CMcpxDspScratchDma@DirectSound@@QAEPAXXZ ; DirectSound::CMcpxDspScratchDma::GetScratchSpaceLinAddr
  00035	05 00 08 00 00	 add	 eax, 2048		; 00000800H
  0003a	89 45 fc	 mov	 DWORD PTR _pCmdBlock$[ebp], eax

; 480  : 
; 481  :     //
; 482  :     // we reverse-engineer the scratch offset we stomped on in SetFxDescriptor..
; 483  :     // needless to say this is magic so if you plan to change make sure you change
; 484  :     // xgpimage AND SetFxDescriptor correctly as well
; 485  :     //
; 486  : 
; 487  :     dwScratchOffset = (DWORD)pFxDesc->lpvStateSegment;

  0003d	8b 45 ec	 mov	 eax, DWORD PTR _pFxDesc$[ebp]
  00040	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00043	89 4d f8	 mov	 DWORD PTR _dwScratchOffset$[ebp], ecx

; 488  :     dwScratchOffset -= MCPX_HW_GPXMEM_REG_OFFSET;

  00046	8b 55 f8	 mov	 edx, DWORD PTR _dwScratchOffset$[ebp]
  00049	81 c2 00 00 7d
	01		 add	 edx, 24969216		; 017d0000H
  0004f	89 55 f8	 mov	 DWORD PTR _dwScratchOffset$[ebp], edx

; 489  :     dwScratchOffset -= DSP_FX_STATE_XMEMORY_BASE_OFFSET;

  00052	8b 45 f8	 mov	 eax, DWORD PTR _dwScratchOffset$[ebp]
  00055	2d 00 02 00 00	 sub	 eax, 512		; 00000200H
  0005a	89 45 f8	 mov	 DWORD PTR _dwScratchOffset$[ebp], eax

; 490  :     dwScratchOffset += (DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK));

  0005d	8b 4d f8	 mov	 ecx, DWORD PTR _dwScratchOffset$[ebp]
  00060	81 c1 18 08 00
	00		 add	 ecx, 2072		; 00000818H
  00066	89 4d f8	 mov	 DWORD PTR _dwScratchOffset$[ebp], ecx

; 491  :     dwScratchOffset += pCmdBlock->dwCodeLength*sizeof(DWORD);

  00069	8b 55 fc	 mov	 edx, DWORD PTR _pCmdBlock$[ebp]
  0006c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _dwScratchOffset$[ebp]
  00072	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00075	89 55 f8	 mov	 DWORD PTR _dwScratchOffset$[ebp], edx

; 492  : 
; 493  :     dwScratchOffset += dwOffset;

  00078	8b 45 f8	 mov	 eax, DWORD PTR _dwScratchOffset$[ebp]
  0007b	03 45 0c	 add	 eax, DWORD PTR _dwOffset$[ebp]
  0007e	89 45 f8	 mov	 DWORD PTR _dwScratchOffset$[ebp], eax

; 494  :        
; 495  :     //
; 496  :     // copy in the data they want to update
; 497  :     //
; 498  : 
; 499  :     m_pScratchDma->Copy(dwScratchOffset,
; 500  :                         (PVOID)pvData,
; 501  :                         dwDataSize);

  00081	8b 4d 14	 mov	 ecx, DWORD PTR _dwDataSize$[ebp]
  00084	51		 push	 ecx
  00085	8b 55 10	 mov	 edx, DWORD PTR _pvData$[ebp]
  00088	52		 push	 edx
  00089	8b 45 f8	 mov	 eax, DWORD PTR _dwScratchOffset$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00093	e8 00 00 00 00	 call	 ?Copy@CMcpxDspScratchDma@DirectSound@@QAEXKPAXK@Z ; DirectSound::CMcpxDspScratchDma::Copy

; 502  : 
; 503  :     if (dwFlags & DSFX_DEFERRED) {        

  00098	8b 55 18	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0009b	83 e2 01	 and	 edx, 1
  0009e	85 d2		 test	 edx, edx
  000a0	0f 84 92 00 00
	00		 je	 $L39668

; 504  : 
; 505  :         //
; 506  :         // based on where the offset they are updating is, we might have to update
; 507  :         // our scratch image to deal with sparse memory pokes. If somebody calls
; 508  :         // SetEffectData(FALSE) twice but the two memory blocks they are updating are
; 509  :         // non-contigious, we need to fill in the in between memory with latest state
; 510  :         // from the dsp. Then at commit time, we can commit one big block all at once
; 511  :         //
; 512  : 
; 513  :         if (m_dwCurrentLowestScratchOffset != MCPX_GLOBAL_PROC_SCRATCH_SIZE) {

  000a6	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	81 78 18 00 80
	00 00		 cmp	 DWORD PTR [eax+24], 32768 ; 00008000H
  000b0	74 50		 je	 SHORT $L39672

; 514  : 
; 515  :             //
; 516  :             // this is not the first deferred SetEffectData command
; 517  :             // so we can go ahead and do the sparse checks
; 518  :             //
; 519  : 
; 520  :             if ((m_dwCurrentLowestScratchOffset+m_dwStateSizeToCommit) < dwScratchOffset) {

  000b2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000b8	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	03 50 1c	 add	 edx, DWORD PTR [eax+28]
  000be	3b 55 f8	 cmp	 edx, DWORD PTR _dwScratchOffset$[ebp]
  000c1	73 1b		 jae	 SHORT $L39673

; 521  :     
; 522  :                 //
; 523  :                 // sparse update, on the high end...
; 524  :                 //
; 525  :     
; 526  :                 dwDataSize += dwScratchOffset - (m_dwCurrentLowestScratchOffset+m_dwStateSizeToCommit);

  000c3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000c9	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	03 50 1c	 add	 edx, DWORD PTR [eax+28]
  000cf	8b 4d f8	 mov	 ecx, DWORD PTR _dwScratchOffset$[ebp]
  000d2	2b ca		 sub	 ecx, edx
  000d4	8b 55 14	 mov	 edx, DWORD PTR _dwDataSize$[ebp]
  000d7	03 d1		 add	 edx, ecx
  000d9	89 55 14	 mov	 DWORD PTR _dwDataSize$[ebp], edx

; 527  :     
; 528  :             } else if (m_dwCurrentLowestScratchOffset > (dwScratchOffset+dwDataSize)){

  000dc	eb 24		 jmp	 SHORT $L39672
$L39673:
  000de	8b 45 f8	 mov	 eax, DWORD PTR _dwScratchOffset$[ebp]
  000e1	03 45 14	 add	 eax, DWORD PTR _dwDataSize$[ebp]
  000e4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e7	39 41 18	 cmp	 DWORD PTR [ecx+24], eax
  000ea	76 16		 jbe	 SHORT $L39672

; 529  :     
; 530  :                 //
; 531  :                 // sparse update below the last block updated
; 532  :                 //
; 533  :     
; 534  :                 dwDataSize += m_dwCurrentLowestScratchOffset-(dwScratchOffset+dwDataSize);

  000ec	8b 55 f8	 mov	 edx, DWORD PTR _dwScratchOffset$[ebp]
  000ef	03 55 14	 add	 edx, DWORD PTR _dwDataSize$[ebp]
  000f2	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000f8	2b ca		 sub	 ecx, edx
  000fa	8b 55 14	 mov	 edx, DWORD PTR _dwDataSize$[ebp]
  000fd	03 d1		 add	 edx, ecx
  000ff	89 55 14	 mov	 DWORD PTR _dwDataSize$[ebp], edx
$L39672:

; 535  :     
; 536  :             }
; 537  : 
; 538  :         }
; 539  : 
; 540  :         m_dwCurrentLowestScratchOffset = min(m_dwCurrentLowestScratchOffset,dwScratchOffset);

  00102	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00105	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00108	3b 4d f8	 cmp	 ecx, DWORD PTR _dwScratchOffset$[ebp]
  0010b	73 0b		 jae	 SHORT $L42475
  0010d	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00110	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00113	89 45 e4	 mov	 DWORD PTR tv144[ebp], eax
  00116	eb 06		 jmp	 SHORT $L42476
$L42475:
  00118	8b 4d f8	 mov	 ecx, DWORD PTR _dwScratchOffset$[ebp]
  0011b	89 4d e4	 mov	 DWORD PTR tv144[ebp], ecx
$L42476:
  0011e	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00121	8b 45 e4	 mov	 eax, DWORD PTR tv144[ebp]
  00124	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 541  :         m_dwStateSizeToCommit += dwDataSize;

  00127	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0012d	03 55 14	 add	 edx, DWORD PTR _dwDataSize$[ebp]
  00130	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00133	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 542  : 
; 543  :     } else {

  00136	eb 20		 jmp	 SHORT $L39676
$L39668:

; 544  : 
; 545  :         //
; 546  :         // if they want to commit now, poke directly the XRAM offset
; 547  :         //
; 548  : 
; 549  :         pvXramBuffer = (LPVOID) ((DWORD)pFxDesc->lpvStateSegment + dwOffset);

  00138	8b 4d ec	 mov	 ecx, DWORD PTR _pFxDesc$[ebp]
  0013b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0013e	03 55 0c	 add	 edx, DWORD PTR _dwOffset$[ebp]
  00141	89 55 f4	 mov	 DWORD PTR _pvXramBuffer$[ebp], edx

; 550  :         memcpy(pvXramBuffer,pvData,dwDataSize);

  00144	8b 45 14	 mov	 eax, DWORD PTR _dwDataSize$[ebp]
  00147	50		 push	 eax
  00148	8b 4d 10	 mov	 ecx, DWORD PTR _pvData$[ebp]
  0014b	51		 push	 ecx
  0014c	8b 55 f4	 mov	 edx, DWORD PTR _pvXramBuffer$[ebp]
  0014f	52		 push	 edx
  00150	e8 00 00 00 00	 call	 _memcpy
  00155	83 c4 0c	 add	 esp, 12			; 0000000cH
$L39676:

; 551  :     }
; 552  : 
; 553  :     return DS_OK;

  00158	33 c0		 xor	 eax, eax
$L39653:

; 554  : 
; 555  : }

  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c2 14 00	 ret	 20			; 00000014H
?SetEffectData@CMcpxGPDspManager@DirectSound@@QAEJKKPBXKK@Z ENDP ; DirectSound::CMcpxGPDspManager::SetEffectData
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?GetEffectData@CMcpxGPDspManager@DirectSound@@QAEJKKPAXK@Z
DSOUND	SEGMENT
_this$ = -24
_pFxDesc$ = -20
_hr$ = -16
_pvXramBuffer$ = -12
_dwEffectIndex$ = 8
_dwOffset$ = 12
_pvData$ = 16
_dwDataSize$ = 20
?GetEffectData@CMcpxGPDspManager@DirectSound@@QAEJKKPAXK@Z PROC NEAR ; DirectSound::CMcpxGPDspManager::GetEffectData, COMDAT
; _this$ = ecx

; 566  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 567  :     LPCDSEFFECTMAP pFxDesc;
; 568  :     PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;
; 569  :     DWORD dwScratchOffset;
; 570  :     LPVOID pvXramBuffer;
; 571  :     HRESULT hr;
; 572  : 
; 573  :     ASSERT(dwDataSize >= sizeof(DWORD));
; 574  : 
; 575  :     //
; 576  :     // FX offset and size must be dword aligned
; 577  :     //
; 578  : 
; 579  :     ASSERT(!(dwDataSize & 0x00000003));
; 580  :     ASSERT(!(dwOffset & 0x00000003));
; 581  : 
; 582  :     //
; 583  :     // get effect map
; 584  :     //
; 585  : 
; 586  :     hr = GetEffectMap(dwEffectIndex, &pFxDesc);

  00009	8d 45 ec	 lea	 eax, DWORD PTR _pFxDesc$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _dwEffectIndex$[ebp]
  00010	51		 push	 ecx
  00011	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?GetEffectMap@CMcpxGPDspManager@DirectSound@@QAEJKPAPBU_DSEFFECTMAP@@@Z ; DirectSound::CMcpxGPDspManager::GetEffectMap
  00019	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 587  :     if (FAILED(hr)) {

  0001c	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00020	7d 05		 jge	 SHORT $L39693

; 588  :         return hr;

  00022	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  00025	eb 22		 jmp	 SHORT $L39686
$L39693:

; 589  :     }
; 590  : 
; 591  :     //
; 592  :     // validate fx specific parameters
; 593  :     //
; 594  : 
; 595  :     ASSERT(pFxDesc->dwStateSize >= (dwOffset+dwDataSize));
; 596  : 
; 597  :     //
; 598  :     // copy fx data
; 599  :     //
; 600  : 
; 601  :     pvXramBuffer = (LPVOID) ((DWORD)pFxDesc->lpvStateSegment + dwOffset);

  00027	8b 55 ec	 mov	 edx, DWORD PTR _pFxDesc$[ebp]
  0002a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002d	03 45 0c	 add	 eax, DWORD PTR _dwOffset$[ebp]
  00030	89 45 f4	 mov	 DWORD PTR _pvXramBuffer$[ebp], eax

; 602  :     memcpy(pvData,pvXramBuffer,dwDataSize);

  00033	8b 4d 14	 mov	 ecx, DWORD PTR _dwDataSize$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 f4	 mov	 edx, DWORD PTR _pvXramBuffer$[ebp]
  0003a	52		 push	 edx
  0003b	8b 45 10	 mov	 eax, DWORD PTR _pvData$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _memcpy
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 603  : 
; 604  :     return DS_OK;

  00047	33 c0		 xor	 eax, eax
$L39686:

; 605  : 
; 606  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 10 00	 ret	 16			; 00000010H
?GetEffectData@CMcpxGPDspManager@DirectSound@@QAEJKKPAXK@Z ENDP ; DirectSound::CMcpxGPDspManager::GetEffectData
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?GetEffectMap@CMcpxGPDspManager@DirectSound@@QAEJKPAPBU_DSEFFECTMAP@@@Z
DSOUND	SEGMENT
_this$ = -8
_pDescriptor$ = -4
_dwEffectIndex$ = 8
_ppEffectMap$ = 12
?GetEffectMap@CMcpxGPDspManager@DirectSound@@QAEJKPAPBU_DSEFFECTMAP@@@Z PROC NEAR ; DirectSound::CMcpxGPDspManager::GetEffectMap, COMDAT
; _this$ = ecx

; 615  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 616  :     DSEFFECTIMAGEDESC* pDescriptor = m_pFxDescriptor;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000f	89 4d fc	 mov	 DWORD PTR _pDescriptor$[ebp], ecx

; 617  : 
; 618  :     ASSERT(pDescriptor);
; 619  :     ASSERT(ppEffectMap);
; 620  : 
; 621  :     //
; 622  :     // validate params
; 623  :     //
; 624  : 
; 625  :     if (dwEffectIndex > pDescriptor->dwEffectCount-1) {

  00012	8b 55 fc	 mov	 edx, DWORD PTR _pDescriptor$[ebp]
  00015	8b 02		 mov	 eax, DWORD PTR [edx]
  00017	83 e8 01	 sub	 eax, 1
  0001a	39 45 08	 cmp	 DWORD PTR _dwEffectIndex$[ebp], eax
  0001d	76 07		 jbe	 SHORT $L39703

; 626  : 
; 627  :         DPF_ERROR("Zero-based Effect Index (%d) is larger than number of Effects (%d) currently loaded in DSP",
; 628  :                   dwEffectIndex,
; 629  :                   pDescriptor->dwEffectCount-1);
; 630  : 
; 631  :         return DSERR_INVALIDCALL;

  0001f	b8 32 00 78 88	 mov	 eax, -2005401550	; 88780032H
  00024	eb 14		 jmp	 SHORT $L39701
$L39703:

; 632  : 
; 633  :     }
; 634  : 
; 635  :     //
; 636  :     // retrieve the effect they want to modify
; 637  :     //
; 638  : 
; 639  :     *ppEffectMap = &pDescriptor->aEffectMaps[dwEffectIndex];

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _dwEffectIndex$[ebp]
  00029	c1 e1 05	 shl	 ecx, 5
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _pDescriptor$[ebp]
  0002f	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _ppEffectMap$[ebp]
  00036	89 01		 mov	 DWORD PTR [ecx], eax

; 640  : 
; 641  :     return DS_OK;

  00038	33 c0		 xor	 eax, eax
$L39701:

; 642  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
?GetEffectMap@CMcpxGPDspManager@DirectSound@@QAEJKPAPBU_DSEFFECTMAP@@@Z ENDP ; DirectSound::CMcpxGPDspManager::GetEffectMap
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?CommitChanges@CMcpxGPDspManager@DirectSound@@QAEXKK@Z
DSOUND	SEGMENT
_this$ = -12
_pdwflags$ = -8
_pCmdBlock$ = -4
_dwScratchOffset$ = 8
_dwDataSize$ = 12
?CommitChanges@CMcpxGPDspManager@DirectSound@@QAEXKK@Z PROC NEAR ; DirectSound::CMcpxGPDspManager::CommitChanges, COMDAT
; _this$ = ecx

; 647  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 648  : 
; 649  :     PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;
; 650  : 
; 651  :     if (dwDataSize == 0) {

  00009	83 7d 0c 00	 cmp	 DWORD PTR _dwDataSize$[ebp], 0
  0000d	75 23		 jne	 SHORT $L39715

; 652  : 
; 653  :         //
; 654  :         // use internal members for deferred state update
; 655  :         //
; 656  : 
; 657  :         dwDataSize = m_dwStateSizeToCommit;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00015	89 4d 0c	 mov	 DWORD PTR _dwDataSize$[ebp], ecx

; 658  :         dwScratchOffset = m_dwCurrentLowestScratchOffset;

  00018	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	89 45 08	 mov	 DWORD PTR _dwScratchOffset$[ebp], eax

; 659  : 
; 660  :         if ((dwScratchOffset == MCPX_GLOBAL_PROC_SCRATCH_SIZE) ||
; 661  :             (dwDataSize == 0)) {

  00021	81 7d 08 00 80
	00 00		 cmp	 DWORD PTR _dwScratchOffset$[ebp], 32768 ; 00008000H
  00028	74 06		 je	 SHORT $L39720
  0002a	83 7d 0c 00	 cmp	 DWORD PTR _dwDataSize$[ebp], 0
  0002e	75 02		 jne	 SHORT $L39715
$L39720:

; 662  : 
; 663  :             //
; 664  :             // no changes to commit
; 665  :             //
; 666  : 
; 667  :             DPF_WARNING("CommitEffectData was called but there were no deferred changes!!");
; 668  :             return;

  00030	eb 75		 jmp	 SHORT $L39713
$L39715:

; 669  : 
; 670  :         }
; 671  :     }
; 672  : 
; 673  : 
; 674  :     //
; 675  :     // the caller wants to update internal DSP state with this call
; 676  :     // set up the command block, to signal the DSP to DMA in the new state
; 677  :     //
; 678  : 
; 679  :     pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

  00032	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00038	e8 00 00 00 00	 call	 ?GetScratchSpaceLinAddr@CMcpxDspScratchDma@DirectSound@@QAEPAXXZ ; DirectSound::CMcpxDspScratchDma::GetScratchSpaceLinAddr
  0003d	05 00 08 00 00	 add	 eax, 2048		; 00000800H
  00042	89 45 fc	 mov	 DWORD PTR _pCmdBlock$[ebp], eax

; 680  : 
; 681  :     //
; 682  :     // before we go stomping on the existing command block
; 683  :     // make sure there is no other pending command
; 684  :     //
; 685  : 
; 686  :     volatile DWORD *pdwflags = &pCmdBlock->dwCommandFlags;

  00045	8b 55 fc	 mov	 edx, DWORD PTR _pCmdBlock$[ebp]
  00048	83 c2 10	 add	 edx, 16			; 00000010H
  0004b	89 55 f8	 mov	 DWORD PTR _pdwflags$[ebp], edx
$L39725:

; 687  :     while(*pdwflags != 0);

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _pdwflags$[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	74 02		 je	 SHORT $L39726
  00056	eb f6		 jmp	 SHORT $L39725
$L39726:

; 688  : 
; 689  :     //
; 690  :     // create xram offset
; 691  :     // the original base offset can be calculated from the code size
; 692  :     // the DSP default engine will add this offset to the base offset where the concatenated state blocks live
; 693  :     //
; 694  : 
; 695  :     
; 696  :     pCmdBlock->dwOffset = dwScratchOffset/sizeof(DWORD) - 
; 697  :         (pCmdBlock->dwCodeLength+sizeof(HOST_TO_DSP_COMMANDBLOCK)/sizeof(DWORD)) -
; 698  :         (DSP_COMMANDBLOCK_SCRATCHOFFSET/sizeof(DWORD));

  00058	8b 4d 08	 mov	 ecx, DWORD PTR _dwScratchOffset$[ebp]
  0005b	c1 e9 02	 shr	 ecx, 2
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _pCmdBlock$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	83 c0 06	 add	 eax, 6
  00067	2b c8		 sub	 ecx, eax
  00069	81 e9 00 02 00
	00		 sub	 ecx, 512		; 00000200H
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _pCmdBlock$[ebp]
  00072	89 0a		 mov	 DWORD PTR [edx], ecx

; 699  : 
; 700  :     pCmdBlock->dwStateOffset = dwScratchOffset;

  00074	8b 45 fc	 mov	 eax, DWORD PTR _pCmdBlock$[ebp]
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _dwScratchOffset$[ebp]
  0007a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 701  :     pCmdBlock->dwStateLength = dwDataSize/sizeof(DWORD);

  0007d	8b 55 0c	 mov	 edx, DWORD PTR _dwDataSize$[ebp]
  00080	c1 ea 02	 shr	 edx, 2
  00083	8b 45 fc	 mov	 eax, DWORD PTR _pCmdBlock$[ebp]
  00086	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 702  : 
; 703  :     pCmdBlock->dwCommandFlags = BIT_H2DCB_COMMAND_LOAD_XRAM_STATE;

  00089	8b 4d fc	 mov	 ecx, DWORD PTR _pCmdBlock$[ebp]
  0008c	c7 41 10 02 00
	00 00		 mov	 DWORD PTR [ecx+16], 2

; 704  : 
; 705  :     //
; 706  :     // set internal member to signal deferred state updates have been flushed
; 707  :     //
; 708  : 
; 709  :     m_dwCurrentLowestScratchOffset = MCPX_GLOBAL_PROC_SCRATCH_SIZE;

  00093	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00096	c7 42 18 00 80
	00 00		 mov	 DWORD PTR [edx+24], 32768 ; 00008000H

; 710  :     m_dwStateSizeToCommit = 0;

  0009d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$L39713:

; 711  : 
; 712  : }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 08 00	 ret	 8
?CommitChanges@CMcpxGPDspManager@DirectSound@@QAEXKK@Z ENDP ; DirectSound::CMcpxGPDspManager::CommitChanges
DSOUND	ENDS
PUBLIC	?AC3SetOutputBuffer@CMcpxGPDspManager@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@K@Z ; DirectSound::CMcpxGPDspManager::AC3SetOutputBuffer
; Function compile flags: /Odt
;	COMDAT ?AC3SetOutputBuffer@CMcpxGPDspManager@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@K@Z
DSOUND	SEGMENT
_this$ = -4
_pMem$ = 8
_uNumOfPages$ = 12
?AC3SetOutputBuffer@CMcpxGPDspManager@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@K@Z PROC NEAR ; DirectSound::CMcpxGPDspManager::AC3SetOutputBuffer, COMDAT
; _this$ = ecx

; 716  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 717  :     //
; 718  :     // we need to add these pages to the GP dma table
; 719  :     //
; 720  : 
; 721  :     m_pScratchDma->AddPages(pMem, uNumOfPages, &m_uAC3BufferOffset);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _uNumOfPages$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR _pMem$[ebp]
  00012	52		 push	 edx
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00019	e8 00 00 00 00	 call	 ?AddPages@CMcpxDspScratchDma@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@KPAK@Z ; DirectSound::CMcpxDspScratchDma::AddPages

; 722  : 
; 723  :     return;
; 724  : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?AC3SetOutputBuffer@CMcpxGPDspManager@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@K@Z ENDP ; DirectSound::CMcpxGPDspManager::AC3SetOutputBuffer
DSOUND	ENDS
PUBLIC	?SetMultipassBuffer@CMcpxGPDspManager@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@K@Z ; DirectSound::CMcpxGPDspManager::SetMultipassBuffer
; Function compile flags: /Odt
;	COMDAT ?SetMultipassBuffer@CMcpxGPDspManager@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@K@Z
DSOUND	SEGMENT
_this$ = -4
_pMem$ = 8
_uNumOfPages$ = 12
?SetMultipassBuffer@CMcpxGPDspManager@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@K@Z PROC NEAR ; DirectSound::CMcpxGPDspManager::SetMultipassBuffer, COMDAT
; _this$ = ecx

; 728  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 729  :     //
; 730  :     // we need to add these pages to the GP dma table
; 731  :     //
; 732  : 
; 733  :     m_pScratchDma->AddPages(pMem, uNumOfPages, &m_uMultipassBufferOffset);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	50		 push	 eax
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR _uNumOfPages$[ebp]
  00011	51		 push	 ecx
  00012	8b 55 08	 mov	 edx, DWORD PTR _pMem$[ebp]
  00015	52		 push	 edx
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001c	e8 00 00 00 00	 call	 ?AddPages@CMcpxDspScratchDma@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@KPAK@Z ; DirectSound::CMcpxDspScratchDma::AddPages

; 734  : 
; 735  :     return;
; 736  : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?SetMultipassBuffer@CMcpxGPDspManager@DirectSound@@QAEXPAUMCPX_ALLOC_CONTEXT@@K@Z ENDP ; DirectSound::CMcpxGPDspManager::SetMultipassBuffer
DSOUND	ENDS
EXTRN	_g_dwDirectSoundPhysicalMemorySlop:DWORD
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E2
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\heap.cpp
CRT$XCU	ENDS
;	COMDAT _$E2
DSOUND	SEGMENT
_$E2	PROC NEAR					; COMDAT

; 25   : DWORD &CMcpxSlopMemoryHeap::m_dwAvailable = g_dwDirectSoundPhysicalMemorySlop;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_dwAvailable@CMcpxSlopMemoryHeap@DirectSound@@2AAKA, OFFSET FLAT:_g_dwDirectSoundPhysicalMemorySlop ; DirectSound::CMcpxSlopMemoryHeap::m_dwAvailable
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_$E2	ENDP
DSOUND	ENDS
EXTRN	_g_dwDirectSoundPhysicalMemoryRecovered:DWORD
CRT$XCU	SEGMENT
_$S5	DD	FLAT:_$E4
; Function compile flags: /Odt
CRT$XCU	ENDS
;	COMDAT _$E4
DSOUND	SEGMENT
_$E4	PROC NEAR					; COMDAT

; 26   : DWORD &CMcpxSlopMemoryHeap::m_dwUsed = g_dwDirectSoundPhysicalMemoryRecovered;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeap@DirectSound@@2AAKA, OFFSET FLAT:_g_dwDirectSoundPhysicalMemoryRecovered ; DirectSound::CMcpxSlopMemoryHeap::m_dwUsed
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_$E4	ENDP
DSOUND	ENDS
PUBLIC	??_7CMcpxBufferSgeHeap@DirectSound@@6B@		; DirectSound::CMcpxBufferSgeHeap::`vftable'
PUBLIC	??_GCMcpxBufferSgeHeap@DirectSound@@UAEPAXI@Z	; DirectSound::CMcpxBufferSgeHeap::`scalar deleting destructor'
EXTRN	??_ECMcpxBufferSgeHeap@DirectSound@@UAEPAXI@Z:NEAR ; DirectSound::CMcpxBufferSgeHeap::`vector deleting destructor'
;	COMDAT ??_7CMcpxBufferSgeHeap@DirectSound@@6B@
CONST	SEGMENT
??_7CMcpxBufferSgeHeap@DirectSound@@6B@ DD FLAT:??_ECMcpxBufferSgeHeap@DirectSound@@UAEPAXI@Z ; DirectSound::CMcpxBufferSgeHeap::`vftable'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CMcpxBufferSgeHeap@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CMcpxBufferSgeHeap@DirectSound@@QAE@XZ PROC NEAR	; DirectSound::CMcpxBufferSgeHeap::CMcpxBufferSgeHeap, COMDAT
; _this$ = ecx

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMcpxBufferSgeHeap@DirectSound@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], OFFSET FLAT:_g_dwDirectSoundFreeBufferSGEs

; 53   :     DPF_ENTER();
; 54   : 
; 55   :     InitializeListHead(&m_lstRuns);

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	83 c2 04	 add	 edx, 4
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 56   :     InitializeListHead(&m_lstMarkers);

  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00047	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 57   : 
; 58   :     DPF_LEAVE_VOID();
; 59   : }

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
??0CMcpxBufferSgeHeap@DirectSound@@QAE@XZ ENDP		; DirectSound::CMcpxBufferSgeHeap::CMcpxBufferSgeHeap
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??_GCMcpxBufferSgeHeap@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCMcpxBufferSgeHeap@DirectSound@@UAEPAXI@Z PROC NEAR	; DirectSound::CMcpxBufferSgeHeap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMcpxBufferSgeHeap@DirectSound@@UAE@XZ ; DirectSound::CMcpxBufferSgeHeap::~CMcpxBufferSgeHeap
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L39765
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L39765:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCMcpxBufferSgeHeap@DirectSound@@UAEPAXI@Z ENDP	; DirectSound::CMcpxBufferSgeHeap::`scalar deleting destructor'
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??1CMcpxBufferSgeHeap@DirectSound@@UAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CMcpxBufferSgeHeap@DirectSound@@UAE@XZ PROC NEAR	; DirectSound::CMcpxBufferSgeHeap::~CMcpxBufferSgeHeap, COMDAT
; _this$ = ecx

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMcpxBufferSgeHeap@DirectSound@@6B@

; 85   :     DPF_ENTER();
; 86   : 
; 87   :     MEMFREE(m_paMarkers);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  00017	74 16		 je	 SHORT $L39770
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?MemFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::MemFree
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
$L39770:

; 88   : 
; 89   :     m_nFreeElementCount = 0;

  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00035	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 90   : 
; 91   :     DPF_LEAVE_VOID();
; 92   : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1CMcpxBufferSgeHeap@DirectSound@@UAE@XZ ENDP		; DirectSound::CMcpxBufferSgeHeap::~CMcpxBufferSgeHeap
DSOUND	ENDS
PUBLIC	?CreateMarker@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAU3@GGPAU_LIST_ENTRY@@@Z ; DirectSound::CMcpxBufferSgeHeap::CreateMarker
PUBLIC	?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z	; InsertTailListUninit
; Function compile flags: /Odt
;	COMDAT ?Initialize@CMcpxBufferSgeHeap@DirectSound@@QAEJG@Z
DSOUND	SEGMENT
_this$ = -12
_hr$ = -8
_i$ = -4
_nLength$ = 8
?Initialize@CMcpxBufferSgeHeap@DirectSound@@QAEJG@Z PROC NEAR ; DirectSound::CMcpxBufferSgeHeap::Initialize, COMDAT
; _this$ = ecx

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 119  :     HRESULT                 hr;
; 120  :     DWORD                   i;
; 121  : 
; 122  :     m_nFreeElementCount = nLength;

  00009	0f b7 45 08	 movzx	 eax, WORD PTR _nLength$[ebp]
  0000d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00013	89 02		 mov	 DWORD PTR [edx], eax

; 123  : 
; 124  :     //
; 125  :     // Allocate markers, include one extra marker for slop
; 126  :     //
; 127  : 
; 128  :     hr = HRFROMP(m_paMarkers = MEMALLOC(SGEHEAPRUNMARKER, nLength + 1));

  00015	6a 01		 push	 1
  00017	0f b7 45 08	 movzx	 eax, WORD PTR _nLength$[ebp]
  0001b	83 c0 01	 add	 eax, 1
  0001e	6b c0 14	 imul	 eax, 20			; 00000014H
  00021	50		 push	 eax
  00022	68 44 53 64 61	 push	 1633964868		; 61645344H
  00027	e8 00 00 00 00	 call	 ?MemAlloc@CMemoryManager@DirectSound@@SGPAXW4DSOUND_POOL_TAG@@KH@Z ; DirectSound::CMemoryManager::MemAlloc
  0002c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00032	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00035	33 c0		 xor	 eax, eax
  00037	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  0003b	0f 95 c0	 setne	 al
  0003e	48		 dec	 eax
  0003f	25 0e 00 07 80	 and	 eax, -2147024882	; 8007000eH
  00044	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 129  : 
; 130  :     //
; 131  :     // All elements are initially free, so add 1 run marker to the run list
; 132  :     //
; 133  : 
; 134  :     if(SUCCEEDED(hr))

  00047	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004b	7c 23		 jl	 SHORT $L39782

; 135  :     {
; 136  :         m_pLargestFreeRunMarker = CreateMarker(&m_paMarkers[0], 0, nLength, &m_lstRuns);

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	66 8b 55 08	 mov	 dx, WORD PTR _nLength$[ebp]
  00058	52		 push	 edx
  00059	6a 00		 push	 0
  0005b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00061	51		 push	 ecx
  00062	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ?CreateMarker@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAU3@GGPAU_LIST_ENTRY@@@Z ; DirectSound::CMcpxBufferSgeHeap::CreateMarker
  0006a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	89 42 18	 mov	 DWORD PTR [edx+24], eax
$L39782:

; 137  :     }
; 138  : 
; 139  :     //
; 140  :     // The remaining markers are unused
; 141  :     //
; 142  : 
; 143  :     if(SUCCEEDED(hr))

  00070	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00074	7c 39		 jl	 SHORT $L39784

; 144  :     {
; 145  :         for(i = 1; i < (DWORD)nLength + 1; i++)

  00076	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0007d	eb 09		 jmp	 SHORT $L39786
$L39787:
  0007f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00082	83 c0 01	 add	 eax, 1
  00085	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L39786:
  00088	0f b7 4d 08	 movzx	 ecx, WORD PTR _nLength$[ebp]
  0008c	83 c1 01	 add	 ecx, 1
  0008f	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  00092	73 1b		 jae	 SHORT $L39784

; 146  :         {
; 147  :             InsertTailListUninit(&m_lstMarkers, &m_paMarkers[i].leListEntry);

  00094	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00097	6b d2 14	 imul	 edx, 20			; 00000014H
  0009a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	03 50 14	 add	 edx, DWORD PTR [eax+20]
  000a0	52		 push	 edx
  000a1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailListUninit

; 148  :         }

  000ad	eb d0		 jmp	 SHORT $L39787
$L39784:

; 149  :     }
; 150  : 
; 151  :     DPF_LEAVE_HRESULT(hr);
; 152  : 
; 153  :     return hr;

  000af	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 154  : }

  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 04 00	 ret	 4
?Initialize@CMcpxBufferSgeHeap@DirectSound@@QAEJG@Z ENDP ; DirectSound::CMcpxBufferSgeHeap::Initialize
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\ntlist.h
DSOUND	ENDS
;	COMDAT ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT
_ListHead$ = 8
_Entry$ = 12
?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z PROC NEAR	; InsertTailListUninit, COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 136  :     AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);
; 137  : 
; 138  :     Entry->Flink = ListHead;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 139  :     Entry->Blink = ListHead->Blink;

  0000b	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  0000e	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 140  :     
; 141  :     Entry->Flink->Blink = Entry;

  00017	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 142  :     Entry->Blink->Flink = Entry;

  00022	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00025	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 143  : 
; 144  :     AssertValidEntryList(Entry, ASSERT_IN_LIST);
; 145  : }    

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ENDP	; InsertTailListUninit
DSOUND	ENDS
PUBLIC	?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z	; InsertHeadListUninit
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\heap.h
;	COMDAT ?CreateMarker@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAU3@GGPAU_LIST_ENTRY@@@Z
DSOUND	SEGMENT
_this$ = -4
_pMarker$ = 8
_nElement$ = 12
_nLength$ = 16
_plePrevEntry$ = 20
?CreateMarker@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAU3@GGPAU_LIST_ENTRY@@@Z PROC NEAR ; DirectSound::CMcpxBufferSgeHeap::CreateMarker, COMDAT
; _this$ = ecx

; 110  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 111  :         InsertHeadListUninit(plePrevEntry, &pMarker->leListEntry);

  00007	8b 45 08	 mov	 eax, DWORD PTR _pMarker$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 14	 mov	 ecx, DWORD PTR _plePrevEntry$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertHeadListUninit

; 112  : 
; 113  :         pMarker->nElement = nElement;

  00014	8b 55 08	 mov	 edx, DWORD PTR _pMarker$[ebp]
  00017	66 8b 45 0c	 mov	 ax, WORD PTR _nElement$[ebp]
  0001b	66 89 42 08	 mov	 WORD PTR [edx+8], ax

; 114  :         pMarker->nLength = nLength;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _pMarker$[ebp]
  00022	66 8b 55 10	 mov	 dx, WORD PTR _nLength$[ebp]
  00026	66 89 51 0a	 mov	 WORD PTR [ecx+10], dx

; 115  :         pMarker->dwRefCount = 0;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _pMarker$[ebp]
  0002d	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 116  :         pMarker->pvBaseAddress = NULL;

  00034	8b 4d 08	 mov	 ecx, DWORD PTR _pMarker$[ebp]
  00037	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 117  : 
; 118  :         return pMarker;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _pMarker$[ebp]

; 119  :     }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 10 00	 ret	 16			; 00000010H
?CreateMarker@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAU3@GGPAU_LIST_ENTRY@@@Z ENDP ; DirectSound::CMcpxBufferSgeHeap::CreateMarker
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\ntlist.h
DSOUND	ENDS
;	COMDAT ?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z
DSOUND	SEGMENT
_ListHead$ = 8
_Entry$ = 12
?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z PROC NEAR	; InsertHeadListUninit, COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  :     AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);
; 188  : 
; 189  :     Entry->Flink = ListHead->Flink;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  00009	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000b	89 10		 mov	 DWORD PTR [eax], edx

; 190  :     Entry->Blink = ListHead;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Entry$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  00013	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 191  :     
; 192  :     Entry->Flink->Blink = Entry;

  00016	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 193  :     Entry->Blink->Flink = Entry;

  00021	8b 55 0c	 mov	 edx, DWORD PTR _Entry$[ebp]
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 194  : 
; 195  :     AssertValidEntryList(Entry, ASSERT_IN_LIST);
; 196  : }

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z ENDP	; InsertHeadListUninit
DSOUND	ENDS
PUBLIC	?AllocRun@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAXG@Z ; DirectSound::CMcpxBufferSgeHeap::AllocRun
PUBLIC	?MapBuffer@CMcpxBufferSgeHeap@DirectSound@@KGXKPAXK@Z ; DirectSound::CMcpxBufferSgeHeap::MapBuffer
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\heap.cpp
;	COMDAT ?Alloc@CMcpxBufferSgeHeap@DirectSound@@QAEPAUSGEHEAPRUNMARKER@@PAXK@Z
DSOUND	SEGMENT
_this$ = -28
_nLength$ = -24
_pleEntry$ = -20
_pRunMarker$ = -16
_irql$ = -12
_pMarkerNode$ = -4
_pvBaseAddress$ = 8
_dwBufferSize$ = 12
?Alloc@CMcpxBufferSgeHeap@DirectSound@@QAEPAUSGEHEAPRUNMARKER@@PAXK@Z PROC NEAR ; DirectSound::CMcpxBufferSgeHeap::Alloc, COMDAT
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 184  :     LPSGEHEAPRUNMARKER      pRunMarker      = NULL;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pRunMarker$[ebp], 0

; 185  :     PLIST_ENTRY             pleEntry;
; 186  :     LPSGEHEAPRUNMARKER      pMarkerNode;
; 187  :     WORD                    nLength;
; 188  :     CIrql                   irql;

  00010	8d 4d f4	 lea	 ecx, DWORD PTR _irql$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CIrql@DirectSound@@QAE@XZ ; DirectSound::CIrql::CIrql

; 189  :     
; 190  :     DPF_ENTER();
; 191  : 
; 192  :     //
; 193  :     // Page-align the buffer address and size
; 194  :     //
; 195  : 
; 196  :     nLength = (WORD)COMPUTE_PAGES_SPANNED(pvBaseAddress, dwBufferSize);

  00018	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  0001b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00023	8d 94 08 ff 0f
	00 00		 lea	 edx, DWORD PTR [eax+ecx+4095]
  0002a	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  0002d	66 89 55 e8	 mov	 WORD PTR _nLength$[ebp], dx

; 197  :     pvBaseAddress = (LPVOID)((DWORD)pvBaseAddress & ~(PAGE_SIZE - 1));

  00031	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  00034	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  00039	89 45 08	 mov	 DWORD PTR _pvBaseAddress$[ebp], eax

; 198  : 
; 199  :     //
; 200  :     // Check the list for a buffer whose SGEs we can share
; 201  :     //
; 202  : 
; 203  :     irql.Raise();

  0003c	8d 4d f4	 lea	 ecx, DWORD PTR _irql$[ebp]
  0003f	e8 00 00 00 00	 call	 ?Raise@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Raise

; 204  : 
; 205  : #ifndef MCPX_NO_SGE_SHARING
; 206  : 
; 207  :     for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)

  00044	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004a	89 55 ec	 mov	 DWORD PTR _pleEntry$[ebp], edx
  0004d	eb 08		 jmp	 SHORT $L39804
$L39805:
  0004f	8b 45 ec	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  00052	8b 08		 mov	 ecx, DWORD PTR [eax]
  00054	89 4d ec	 mov	 DWORD PTR _pleEntry$[ebp], ecx
$L39804:
  00057	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	83 c2 04	 add	 edx, 4
  0005d	39 55 ec	 cmp	 DWORD PTR _pleEntry$[ebp], edx
  00060	74 33		 je	 SHORT $L39806

; 208  :     {
; 209  :         AssertValidEntryList(pleEntry, ASSERT_IN_LIST);
; 210  : 
; 211  :         pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

  00062	8b 45 ec	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  00065	89 45 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], eax

; 212  : 
; 213  :         if(pMarkerNode->dwRefCount)

  00068	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  0006b	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0006f	74 22		 je	 SHORT $L39811

; 214  :         {
; 215  :             if((DWORD)pvBaseAddress == (DWORD)pMarkerNode->pvBaseAddress)

  00071	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  00074	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  00077	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0007a	75 17		 jne	 SHORT $L39811

; 216  :             {
; 217  :                 if(nLength == pMarkerNode->nLength)

  0007c	0f b7 4d e8	 movzx	 ecx, WORD PTR _nLength$[ebp]
  00080	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  00083	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  00087	3b c8		 cmp	 ecx, eax
  00089	75 08		 jne	 SHORT $L39811

; 218  :                 {
; 219  :                     pRunMarker = pMarkerNode;

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  0008e	89 4d f0	 mov	 DWORD PTR _pRunMarker$[ebp], ecx

; 220  :                     break;

  00091	eb 02		 jmp	 SHORT $L39806
$L39811:

; 221  :                 }
; 222  :             }
; 223  :         }
; 224  :     }

  00093	eb ba		 jmp	 SHORT $L39805
$L39806:

; 225  : 
; 226  :     if(pRunMarker)

  00095	83 7d f0 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  00099	74 11		 je	 SHORT $L39816

; 227  :     {
; 228  :         //
; 229  :         // We found one, so just AddRef it
; 230  :         //
; 231  : 
; 232  :         ASSERT(pRunMarker->dwRefCount < MCPX_HW_MAX_VOICES);
; 233  : 
; 234  :         pRunMarker->dwRefCount++;

  0009b	8b 55 f0	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  0009e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000a1	83 c0 01	 add	 eax, 1
  000a4	8b 4d f0	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000a7	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 235  : 
; 236  :         DPF_SGE_HEAP("Sharing SGE run %x (ref count %lu)", pRunMarker->nElement, pRunMarker->dwRefCount);
; 237  :     }
; 238  :     else

  000aa	eb 38		 jmp	 SHORT $L39817
$L39816:

; 239  : 
; 240  : #endif // MCPX_NO_SGE_SHARING
; 241  : 
; 242  :     {
; 243  :         //
; 244  :         // Allocate a new run and map it into SGEs.  Note that we're not 
; 245  :         // setting the run marker's base address until after it's been
; 246  :         // mapped.  This will prevent us from ever trying to use an unmapped
; 247  :         // run if a higher IRQL call comes in.
; 248  :         //
; 249  :         
; 250  :         if(pRunMarker = AllocRun(pvBaseAddress, nLength))

  000ac	66 8b 55 e8	 mov	 dx, WORD PTR _nLength$[ebp]
  000b0	52		 push	 edx
  000b1	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  000b4	50		 push	 eax
  000b5	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?AllocRun@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAXG@Z ; DirectSound::CMcpxBufferSgeHeap::AllocRun
  000bd	89 45 f0	 mov	 DWORD PTR _pRunMarker$[ebp], eax
  000c0	83 7d f0 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  000c4	74 1e		 je	 SHORT $L39817

; 251  :         {
; 252  :             irql.Lower();

  000c6	8d 4d f4	 lea	 ecx, DWORD PTR _irql$[ebp]
  000c9	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower

; 253  : 
; 254  :             MapBuffer(pRunMarker->nElement, pvBaseAddress, nLength);

  000ce	0f b7 4d e8	 movzx	 ecx, WORD PTR _nLength$[ebp]
  000d2	51		 push	 ecx
  000d3	8b 55 08	 mov	 edx, DWORD PTR _pvBaseAddress$[ebp]
  000d6	52		 push	 edx
  000d7	8b 45 f0	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000da	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  000de	51		 push	 ecx
  000df	e8 00 00 00 00	 call	 ?MapBuffer@CMcpxBufferSgeHeap@DirectSound@@KGXKPAXK@Z ; DirectSound::CMcpxBufferSgeHeap::MapBuffer
$L39817:

; 255  :         }
; 256  :     }
; 257  : 
; 258  :     irql.Lower();

  000e4	8d 4d f4	 lea	 ecx, DWORD PTR _irql$[ebp]
  000e7	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower

; 259  : 
; 260  :     DPF_LEAVE(pRunMarker);
; 261  : 
; 262  :     return pRunMarker;

  000ec	8b 45 f0	 mov	 eax, DWORD PTR _pRunMarker$[ebp]

; 263  : }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 08 00	 ret	 8
?Alloc@CMcpxBufferSgeHeap@DirectSound@@QAEPAUSGEHEAPRUNMARKER@@PAXK@Z ENDP ; DirectSound::CMcpxBufferSgeHeap::Alloc
DSOUND	ENDS
PUBLIC	?FreeRun@CMcpxBufferSgeHeap@DirectSound@@IAEXPAUSGEHEAPRUNMARKER@@@Z ; DirectSound::CMcpxBufferSgeHeap::FreeRun
PUBLIC	?UnmapBuffer@CMcpxBufferSgeHeap@DirectSound@@KGXPAXK@Z ; DirectSound::CMcpxBufferSgeHeap::UnmapBuffer
; Function compile flags: /Odt
;	COMDAT ?Free@CMcpxBufferSgeHeap@DirectSound@@QAEXPAUSGEHEAPRUNMARKER@@@Z
DSOUND	SEGMENT
_this$ = -20
_dnLength$ = -16
_pvBaseAddress$ = -12
_irql$ = -8
_pRunMarker$ = 8
?Free@CMcpxBufferSgeHeap@DirectSound@@QAEXPAUSGEHEAPRUNMARKER@@@Z PROC NEAR ; DirectSound::CMcpxBufferSgeHeap::Free, COMDAT
; _this$ = ecx

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 290  :     LPVOID                  pvBaseAddress;
; 291  :     DWORD                   dnLength;
; 292  :     CIrql                   irql;

  00009	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CIrql@DirectSound@@QAE@XZ ; DirectSound::CIrql::CIrql

; 293  :     
; 294  :     DPF_ENTER();
; 295  : 
; 296  :     irql.Raise();

  00011	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00014	e8 00 00 00 00	 call	 ?Raise@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Raise

; 297  :     
; 298  :     if(!--pRunMarker->dwRefCount)

  00019	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0001c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0001f	83 e9 01	 sub	 ecx, 1
  00022	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00025	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00028	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0002b	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0002f	75 34		 jne	 SHORT $L39826

; 299  :     {
; 300  :         pvBaseAddress = pRunMarker->pvBaseAddress;

  00031	8b 4d 08	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  00034	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00037	89 55 f4	 mov	 DWORD PTR _pvBaseAddress$[ebp], edx

; 301  :         dnLength = pRunMarker->nLength;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0003d	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  00041	89 4d f0	 mov	 DWORD PTR _dnLength$[ebp], ecx

; 302  :         
; 303  :         FreeRun(pRunMarker);

  00044	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00047	52		 push	 edx
  00048	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?FreeRun@CMcpxBufferSgeHeap@DirectSound@@IAEXPAUSGEHEAPRUNMARKER@@@Z ; DirectSound::CMcpxBufferSgeHeap::FreeRun

; 304  : 
; 305  :         irql.Lower();

  00050	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00053	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower

; 306  : 
; 307  :         UnmapBuffer(pvBaseAddress, dnLength);

  00058	8b 45 f0	 mov	 eax, DWORD PTR _dnLength$[ebp]
  0005b	50		 push	 eax
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 ?UnmapBuffer@CMcpxBufferSgeHeap@DirectSound@@KGXPAXK@Z ; DirectSound::CMcpxBufferSgeHeap::UnmapBuffer
$L39826:

; 308  :     }
; 309  :     
; 310  :     irql.Lower();

  00065	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00068	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower

; 311  : 
; 312  :     DPF_LEAVE_VOID();
; 313  : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?Free@CMcpxBufferSgeHeap@DirectSound@@QAEXPAUSGEHEAPRUNMARKER@@@Z ENDP ; DirectSound::CMcpxBufferSgeHeap::Free
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?AllocRun@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAXG@Z
DSOUND	SEGMENT
_this$ = -16
_pleEntry$ = -12
_pRunMarker$ = -8
_pMarkerNode$ = -4
_pvBaseAddress$ = 8
_nLength$ = 12
?AllocRun@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAXG@Z PROC NEAR ; DirectSound::CMcpxBufferSgeHeap::AllocRun, COMDAT
; _this$ = ecx

; 342  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 343  :     LPSGEHEAPRUNMARKER      pRunMarker  = NULL;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pRunMarker$[ebp], 0

; 344  :     LPSGEHEAPRUNMARKER      pMarkerNode;
; 345  :     PLIST_ENTRY             pleEntry;
; 346  : 
; 347  :     DPF_ENTER();
; 348  : 
; 349  :     //
; 350  :     // Check the largest available run length to see if we can service
; 351  :     // the request
; 352  :     //
; 353  : 
; 354  :     if(m_pLargestFreeRunMarker)

  00010	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00017	0f 84 87 01 00
	00		 je	 $L39835

; 355  :     {
; 356  :         if(m_pLargestFreeRunMarker->nLength >= nLength)

  0001d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00023	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  00027	0f b7 4d 0c	 movzx	 ecx, WORD PTR _nLength$[ebp]
  0002b	3b c1		 cmp	 eax, ecx
  0002d	0f 8c 71 01 00
	00		 jl	 $L39835

; 357  :         {
; 358  :             //
; 359  :             // Find a free run that is as close as possible to the requested element
; 360  :             // count.  This will help to reduce fragmentation.
; 361  :             //
; 362  : 
; 363  :             for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)

  00033	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00039	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax
  0003c	eb 08		 jmp	 SHORT $L39837
$L39838:
  0003e	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx
$L39837:
  00046	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00049	83 c0 04	 add	 eax, 4
  0004c	39 45 f4	 cmp	 DWORD PTR _pleEntry$[ebp], eax
  0004f	74 46		 je	 SHORT $L39839

; 364  :             {
; 365  :                 AssertValidEntryList(pleEntry, ASSERT_IN_LIST);
; 366  : 
; 367  :                 pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

  00051	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  00054	89 4d fc	 mov	 DWORD PTR _pMarkerNode$[ebp], ecx

; 368  :             
; 369  :                 if(!pMarkerNode->fAllocated)

  00057	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  0005a	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0005e	75 35		 jne	 SHORT $L39844

; 370  :                 {
; 371  :                     if(pMarkerNode->nLength >= nLength)

  00060	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  00063	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  00067	0f b7 55 0c	 movzx	 edx, WORD PTR _nLength$[ebp]
  0006b	3b ca		 cmp	 ecx, edx
  0006d	7c 26		 jl	 SHORT $L39844

; 372  :                     {
; 373  :                         if(!pRunMarker)

  0006f	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  00073	75 08		 jne	 SHORT $L39846

; 374  :                         {
; 375  :                             pRunMarker = pMarkerNode;

  00075	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  00078	89 45 f8	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 376  :                         }
; 377  :                         else if(pMarkerNode->nLength < pRunMarker->nLength)

  0007b	eb 18		 jmp	 SHORT $L39844
$L39846:
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  00080	0f b7 51 0a	 movzx	 edx, WORD PTR [ecx+10]
  00084	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00087	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  0008b	3b d1		 cmp	 edx, ecx
  0008d	7d 06		 jge	 SHORT $L39844

; 378  :                         {
; 379  :                             pRunMarker = pMarkerNode;

  0008f	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  00092	89 55 f8	 mov	 DWORD PTR _pRunMarker$[ebp], edx
$L39844:

; 380  :                         }
; 381  :                     }
; 382  :                 }
; 383  :             }

  00095	eb a7		 jmp	 SHORT $L39838
$L39839:

; 384  : 
; 385  :             //
; 386  :             // If we're using the whole run, just flag it as allocated.  If not,
; 387  :             // get a free marker from the pool and add it to the list.  We're only
; 388  :             // using a single list so that runs can be broken and coalesced without
; 389  :             // having to walk the list.
; 390  :             //
; 391  : 
; 392  :             if(pRunMarker)

  00097	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  0009b	74 6e		 je	 SHORT $L39849

; 393  :             {
; 394  :                 if(nLength < pRunMarker->nLength)

  0009d	0f b7 45 0c	 movzx	 eax, WORD PTR _nLength$[ebp]
  000a1	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000a4	0f b7 51 0a	 movzx	 edx, WORD PTR [ecx+10]
  000a8	3b c2		 cmp	 eax, edx
  000aa	7d 4c		 jge	 SHORT $L39855

; 395  :                 {
; 396  :                     ASSERT(!IsListEmpty(&m_lstMarkers));
; 397  :             
; 398  :                     pleEntry = RemoveHeadList(&m_lstMarkers);

  000ac	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000af	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList
  000b8	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax

; 399  :                     pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

  000bb	8b 55 f4	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  000be	89 55 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], edx

; 400  : 
; 401  :                     CreateMarker(pMarkerNode, pRunMarker->nElement + nLength, pRunMarker->nLength - nLength, &pRunMarker->leListEntry);

  000c1	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000c4	50		 push	 eax
  000c5	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000c8	0f b7 51 0a	 movzx	 edx, WORD PTR [ecx+10]
  000cc	0f b7 45 0c	 movzx	 eax, WORD PTR _nLength$[ebp]
  000d0	2b d0		 sub	 edx, eax
  000d2	52		 push	 edx
  000d3	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000d6	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  000da	0f b7 45 0c	 movzx	 eax, WORD PTR _nLength$[ebp]
  000de	03 d0		 add	 edx, eax
  000e0	52		 push	 edx
  000e1	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  000e4	51		 push	 ecx
  000e5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	e8 00 00 00 00	 call	 ?CreateMarker@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAU3@GGPAU_LIST_ENTRY@@@Z ; DirectSound::CMcpxBufferSgeHeap::CreateMarker

; 402  : 
; 403  :                     pRunMarker->nLength = nLength;

  000ed	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000f0	66 8b 45 0c	 mov	 ax, WORD PTR _nLength$[ebp]
  000f4	66 89 42 0a	 mov	 WORD PTR [edx+10], ax
$L39855:

; 404  : 
; 405  :                     DPF_SGE_HEAP("Split SGE run into %x (%lu) and %x (%lu)", pRunMarker->nElement, pRunMarker->nLength, pMarkerNode->nElement, pMarkerNode->nLength);
; 406  :                 }
; 407  :                 else
; 408  :                 {
; 409  :                     DPF_SGE_HEAP("Allocating SGE run %x (%lu)", pRunMarker->nElement, pRunMarker->nLength);
; 410  :                 }
; 411  : 
; 412  :                 pRunMarker->fAllocated = TRUE;

  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000fb	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [ecx+12], 1

; 413  :                 pRunMarker->pvBaseAddress = pvBaseAddress;

  00102	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00105	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  00108	89 42 10	 mov	 DWORD PTR [edx+16], eax
$L39849:

; 414  :             }
; 415  : 
; 416  :             //
; 417  :             // Update the free element count and largest run members
; 418  :             //
; 419  : 
; 420  :             if(pRunMarker)

  0010b	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  0010f	0f 84 8f 00 00
	00		 je	 $L39835

; 421  :             {
; 422  :                 ASSERT(m_nFreeElementCount >= pRunMarker->nLength);
; 423  :                 m_nFreeElementCount -= pRunMarker->nLength;

  00115	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0011b	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0011e	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  00122	8b 12		 mov	 edx, DWORD PTR [edx]
  00124	2b d1		 sub	 edx, ecx
  00126	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00129	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0012c	89 11		 mov	 DWORD PTR [ecx], edx

; 424  : 
; 425  :                 if(pRunMarker == m_pLargestFreeRunMarker)

  0012e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00131	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00134	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  00137	75 6b		 jne	 SHORT $L39835

; 426  :                 {
; 427  :                     m_pLargestFreeRunMarker = NULL;

  00139	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0013c	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 428  :                     
; 429  :                     for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)

  00143	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00146	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00149	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax
  0014c	eb 08		 jmp	 SHORT $L39858
$L39859:
  0014e	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  00151	8b 11		 mov	 edx, DWORD PTR [ecx]
  00153	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx
$L39858:
  00156	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00159	83 c0 04	 add	 eax, 4
  0015c	39 45 f4	 cmp	 DWORD PTR _pleEntry$[ebp], eax
  0015f	74 43		 je	 SHORT $L39835

; 430  :                     {
; 431  :                         AssertValidEntryList(pleEntry, ASSERT_IN_LIST);
; 432  : 
; 433  :                         pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

  00161	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  00164	89 4d fc	 mov	 DWORD PTR _pMarkerNode$[ebp], ecx

; 434  :             
; 435  :                         if(!pMarkerNode->fAllocated)

  00167	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  0016a	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0016e	75 32		 jne	 SHORT $L39865

; 436  :                         {
; 437  :                             if(!m_pLargestFreeRunMarker)

  00170	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00173	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00177	75 0b		 jne	 SHORT $L39866

; 438  :                             {
; 439  :                                 m_pLargestFreeRunMarker = pMarkerNode;

  00179	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0017c	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  0017f	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 440  :                             }
; 441  :                             else if(pMarkerNode->nLength > m_pLargestFreeRunMarker->nLength)

  00182	eb 1e		 jmp	 SHORT $L39865
$L39866:
  00184	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  00187	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  0018b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0018e	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00191	0f b7 50 0a	 movzx	 edx, WORD PTR [eax+10]
  00195	3b ca		 cmp	 ecx, edx
  00197	7e 09		 jle	 SHORT $L39865

; 442  :                             {
; 443  :                                 m_pLargestFreeRunMarker = pMarkerNode;

  00199	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0019c	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  0019f	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$L39865:

; 444  :                             }
; 445  :                         }
; 446  :                     }

  001a2	eb aa		 jmp	 SHORT $L39859
$L39835:

; 447  :                 }                    
; 448  :             }
; 449  :         }
; 450  :     }
; 451  : 
; 452  :     DPF_LEAVE(pRunMarker);
; 453  : 
; 454  :     return pRunMarker;

  001a4	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]

; 455  : }

  001a7	8b e5		 mov	 esp, ebp
  001a9	5d		 pop	 ebp
  001aa	c2 08 00	 ret	 8
?AllocRun@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAXG@Z ENDP ; DirectSound::CMcpxBufferSgeHeap::AllocRun
DSOUND	ENDS
PUBLIC	?CoalesceRuns@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAU3@0@Z ; DirectSound::CMcpxBufferSgeHeap::CoalesceRuns
; Function compile flags: /Odt
;	COMDAT ?FreeRun@CMcpxBufferSgeHeap@DirectSound@@IAEXPAUSGEHEAPRUNMARKER@@@Z
DSOUND	SEGMENT
_this$ = -12
_pleEntry$ = -8
_pMarkerNode$ = -4
_pRunMarker$ = 8
?FreeRun@CMcpxBufferSgeHeap@DirectSound@@IAEXPAUSGEHEAPRUNMARKER@@@Z PROC NEAR ; DirectSound::CMcpxBufferSgeHeap::FreeRun, COMDAT
; _this$ = ecx

; 481  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 482  :     PLIST_ENTRY             pleEntry;
; 483  :     LPSGEHEAPRUNMARKER      pMarkerNode;
; 484  :     
; 485  :     DPF_ENTER();
; 486  : 
; 487  :     ASSERT(!pRunMarker->fAllocated);
; 488  : 
; 489  :     DPF_SGE_HEAP("Freeing SGE run %x (%lu)", pRunMarker->nElement, pRunMarker->nLength);
; 490  : 
; 491  :     //
; 492  :     // Update the free element count
; 493  :     //
; 494  : 
; 495  :     m_nFreeElementCount += pRunMarker->nLength;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00012	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  00016	03 01		 add	 eax, DWORD PTR [ecx]
  00018	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0001e	89 02		 mov	 DWORD PTR [edx], eax
$L39876:

; 496  : 
; 497  :     //
; 498  :     // Coalesce the run with those around it and add it back to the free 
; 499  :     // marker pool.
; 500  :     //
; 501  : 
; 502  :     while(TRUE)

  00020	b8 01 00 00 00	 mov	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 3b		 je	 SHORT $L39885

; 503  :     {
; 504  :         if((pleEntry = pRunMarker->leListEntry.Flink) == &m_lstRuns)

  00029	8b 4d 08	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  0002c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002e	89 55 f8	 mov	 DWORD PTR _pleEntry$[ebp], edx
  00031	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 c0 04	 add	 eax, 4
  00037	39 45 f8	 cmp	 DWORD PTR _pleEntry$[ebp], eax
  0003a	75 02		 jne	 SHORT $L39878

; 505  :         {
; 506  :             break;

  0003c	eb 26		 jmp	 SHORT $L39885
$L39878:

; 507  :         }
; 508  : 
; 509  :         pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  00041	89 4d fc	 mov	 DWORD PTR _pMarkerNode$[ebp], ecx

; 510  : 
; 511  :         if(pMarkerNode->fAllocated)

  00044	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  00047	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0004b	74 02		 je	 SHORT $L39883

; 512  :         {
; 513  :             break;

  0004d	eb 15		 jmp	 SHORT $L39885
$L39883:

; 514  :         }
; 515  : 
; 516  :         pRunMarker = CoalesceRuns(pRunMarker, pMarkerNode);

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  00052	50		 push	 eax
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  00056	51		 push	 ecx
  00057	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?CoalesceRuns@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAU3@0@Z ; DirectSound::CMcpxBufferSgeHeap::CoalesceRuns
  0005f	89 45 08	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 517  :     }

  00062	eb bc		 jmp	 SHORT $L39876
$L39885:

; 518  : 
; 519  :     while(TRUE)

  00064	ba 01 00 00 00	 mov	 edx, 1
  00069	85 d2		 test	 edx, edx
  0006b	74 3c		 je	 SHORT $L39886

; 520  :     {
; 521  :         if((pleEntry = pRunMarker->leListEntry.Blink) == &m_lstRuns)

  0006d	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00070	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00073	89 4d f8	 mov	 DWORD PTR _pleEntry$[ebp], ecx
  00076	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00079	83 c2 04	 add	 edx, 4
  0007c	39 55 f8	 cmp	 DWORD PTR _pleEntry$[ebp], edx
  0007f	75 02		 jne	 SHORT $L39887

; 522  :         {
; 523  :             break;

  00081	eb 26		 jmp	 SHORT $L39886
$L39887:

; 524  :         }
; 525  : 
; 526  :         pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

  00083	8b 45 f8	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  00086	89 45 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], eax

; 527  : 
; 528  :         if(pMarkerNode->fAllocated)

  00089	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  0008c	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00090	74 02		 je	 SHORT $L39892

; 529  :         {
; 530  :             break;

  00092	eb 15		 jmp	 SHORT $L39886
$L39892:

; 531  :         }
; 532  : 
; 533  :         pRunMarker = CoalesceRuns(pMarkerNode, pRunMarker);

  00094	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00097	52		 push	 edx
  00098	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  0009b	50		 push	 eax
  0009c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?CoalesceRuns@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAU3@0@Z ; DirectSound::CMcpxBufferSgeHeap::CoalesceRuns
  000a4	89 45 08	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 534  :     }

  000a7	eb bb		 jmp	 SHORT $L39885
$L39886:

; 535  : 
; 536  :     //
; 537  :     // Update the largest run pointer
; 538  :     //
; 539  : 
; 540  :     if(m_pLargestFreeRunMarker)

  000a9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  000b0	74 20		 je	 SHORT $L39893

; 541  :     {
; 542  :         if(pRunMarker->nLength > m_pLargestFreeRunMarker->nLength)

  000b2	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000b5	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  000b9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000bc	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000bf	0f b7 4a 0a	 movzx	 ecx, WORD PTR [edx+10]
  000c3	3b c1		 cmp	 eax, ecx
  000c5	7e 09		 jle	 SHORT $L39894

; 543  :         {
; 544  :             m_pLargestFreeRunMarker = pRunMarker;

  000c7	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000ca	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000cd	89 42 18	 mov	 DWORD PTR [edx+24], eax
$L39894:

; 545  :         }
; 546  :     }
; 547  :     else

  000d0	eb 09		 jmp	 SHORT $L39872
$L39893:

; 548  :     {
; 549  :         m_pLargestFreeRunMarker = pRunMarker;

  000d2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000d8	89 51 18	 mov	 DWORD PTR [ecx+24], edx
$L39872:

; 550  :     }
; 551  : 
; 552  :     DPF_LEAVE_VOID();
; 553  : }

  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c2 04 00	 ret	 4
?FreeRun@CMcpxBufferSgeHeap@DirectSound@@IAEXPAUSGEHEAPRUNMARKER@@@Z ENDP ; DirectSound::CMcpxBufferSgeHeap::FreeRun
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?CoalesceRuns@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAU3@0@Z
DSOUND	SEGMENT
_this$ = -4
_pRunMarker$ = 8
_pNextRunMarker$ = 12
?CoalesceRuns@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAU3@0@Z PROC NEAR ; DirectSound::CMcpxBufferSgeHeap::CoalesceRuns, COMDAT
; _this$ = ecx

; 582  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 583  :     DPF_ENTER();
; 584  : 
; 585  :     ASSERT(pRunMarker->nElement + pRunMarker->nLength == pNextRunMarker->nElement);
; 586  : 
; 587  :     AssertValidEntryList(&pRunMarker->leListEntry, ASSERT_IN_LIST);
; 588  :     AssertValidEntryList(&pNextRunMarker->leListEntry, ASSERT_IN_LIST);
; 589  : 
; 590  :     DPF_SGE_HEAP("Coalescing SGE run %x (%lu) and %x (%lu)", pRunMarker->nElement, pRunMarker->nLength, pNextRunMarker->nElement, pNextRunMarker->nLength);
; 591  : 
; 592  :     pRunMarker->nLength += pNextRunMarker->nLength;

  00007	8b 45 0c	 mov	 eax, DWORD PTR _pNextRunMarker$[ebp]
  0000a	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  0000e	8b 55 08	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00011	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  00015	03 c1		 add	 eax, ecx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  0001a	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 593  : 
; 594  :     MoveEntryTailList(&m_lstMarkers, &pNextRunMarker->leListEntry);

  0001e	8b 55 0c	 mov	 edx, DWORD PTR _pNextRunMarker$[ebp]
  00021	52		 push	 edx
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 c0 0c	 add	 eax, 12			; 0000000cH
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?MoveEntryTailList@@YGPAU_LIST_ENTRY@@PAU1@0@Z ; MoveEntryTailList

; 595  : 
; 596  :     DPF_LEAVE(pRunMarker);
; 597  : 
; 598  :     return pRunMarker;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]

; 599  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?CoalesceRuns@CMcpxBufferSgeHeap@DirectSound@@IAEPAUSGEHEAPRUNMARKER@@PAU3@0@Z ENDP ; DirectSound::CMcpxBufferSgeHeap::CoalesceRuns
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?MapBuffer@CMcpxBufferSgeHeap@DirectSound@@KGXKPAXK@Z
DSOUND	SEGMENT
_dwAddress$ = -12
_irql$ = -8
_dwSgeIndex$ = 8
_pvBaseAddress$ = 12
_dnLength$ = 16
?MapBuffer@CMcpxBufferSgeHeap@DirectSound@@KGXKPAXK@Z PROC NEAR ; DirectSound::CMcpxBufferSgeHeap::MapBuffer, COMDAT

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 630  :     DWORD                   dwAddress;
; 631  :     CIrql                   irql;

  00006	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00009	e8 00 00 00 00	 call	 ??0CIrql@DirectSound@@QAE@XZ ; DirectSound::CIrql::CIrql

; 632  :     
; 633  :     DPF_ENTER();
; 634  : 
; 635  :     ASSERT(dwSgeIndex < MCPX_HW_MAX_BUFFER_PRDS);
; 636  :     ASSERT(pvBaseAddress);
; 637  :     ASSERT(!((DWORD)pvBaseAddress & (PAGE_SIZE - 1)));
; 638  :     ASSERT(dnLength);
; 639  : 
; 640  :     //
; 641  :     // Lock the buffer data
; 642  :     //
; 643  : 
; 644  :     MmLockUnlockBufferPages(pvBaseAddress, dnLength << PAGE_SHIFT, FALSE);

  0000e	6a 00		 push	 0
  00010	8b 45 10	 mov	 eax, DWORD PTR _dnLength$[ebp]
  00013	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  0001a	51		 push	 ecx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmLockUnlockBufferPages@12
$L39909:

; 645  : 
; 646  :     //
; 647  :     // Start mapping pages into SGEs
; 648  :     //
; 649  : 
; 650  :     while(dnLength--)

  00021	8b 55 10	 mov	 edx, DWORD PTR _dnLength$[ebp]
  00024	8b 45 10	 mov	 eax, DWORD PTR _dnLength$[ebp]
  00027	83 e8 01	 sub	 eax, 1
  0002a	89 45 10	 mov	 DWORD PTR _dnLength$[ebp], eax
  0002d	85 d2		 test	 edx, edx
  0002f	74 65		 je	 SHORT $L39905

; 651  :     {
; 652  :         dwAddress = MmGetPhysicalAddress(pvBaseAddress);

  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  00034	51		 push	 ecx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmGetPhysicalAddress@4
  0003b	89 45 f4	 mov	 DWORD PTR _dwAddress$[ebp], eax

; 653  :         ASSERT(!(dwAddress & (PAGE_SIZE - 1)));
; 654  : 
; 655  :         irql.Raise();

  0003e	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  00041	e8 00 00 00 00	 call	 ?Raise@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Raise
$L39912:

; 656  :         
; 657  :         MCPX_CHECK_VOICE_FIFO(2);

  00046	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0004b	8b 82 00 00 82
	fe		 mov	 eax, DWORD PTR [edx-25034752]
  00051	c1 e8 02	 shr	 eax, 2
  00054	83 f8 02	 cmp	 eax, 2
  00057	73 02		 jae	 SHORT $L39913
  00059	eb eb		 jmp	 SHORT $L39912
$L39913:

; 658  : 
; 659  :         MCPX_VOICE_WRITE(SetCurrentInBufSGE, dwSgeIndex);

  0005b	b9 04 08 00 00	 mov	 ecx, 2052		; 00000804H
  00060	8b 55 08	 mov	 edx, DWORD PTR _dwSgeIndex$[ebp]
  00063	89 91 00 00 82
	fe		 mov	 DWORD PTR [ecx-25034752], edx

; 660  :         MCPX_VOICE_WRITE(SetCurrentInBufSGEOffset, dwAddress);

  00069	b8 08 08 00 00	 mov	 eax, 2056		; 00000808H
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR _dwAddress$[ebp]
  00071	89 88 00 00 82
	fe		 mov	 DWORD PTR [eax-25034752], ecx

; 661  : 
; 662  :         irql.Lower();

  00077	8d 4d f8	 lea	 ecx, DWORD PTR _irql$[ebp]
  0007a	e8 00 00 00 00	 call	 ?Lower@CIrql@DirectSound@@QAEXXZ ; DirectSound::CIrql::Lower

; 663  : 
; 664  :         pvBaseAddress = (LPBYTE)pvBaseAddress + PAGE_SIZE;

  0007f	8b 55 0c	 mov	 edx, DWORD PTR _pvBaseAddress$[ebp]
  00082	81 c2 00 10 00
	00		 add	 edx, 4096		; 00001000H
  00088	89 55 0c	 mov	 DWORD PTR _pvBaseAddress$[ebp], edx

; 665  :         
; 666  :         dwSgeIndex++;

  0008b	8b 45 08	 mov	 eax, DWORD PTR _dwSgeIndex$[ebp]
  0008e	83 c0 01	 add	 eax, 1
  00091	89 45 08	 mov	 DWORD PTR _dwSgeIndex$[ebp], eax

; 667  :     }

  00094	eb 8b		 jmp	 SHORT $L39909
$L39905:

; 668  : 
; 669  :     DPF_LEAVE_VOID();
; 670  : }

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 0c 00	 ret	 12			; 0000000cH
?MapBuffer@CMcpxBufferSgeHeap@DirectSound@@KGXKPAXK@Z ENDP ; DirectSound::CMcpxBufferSgeHeap::MapBuffer
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?UnmapBuffer@CMcpxBufferSgeHeap@DirectSound@@KGXPAXK@Z
DSOUND	SEGMENT
_pvBaseAddress$ = 8
_dnLength$ = 12
?UnmapBuffer@CMcpxBufferSgeHeap@DirectSound@@KGXPAXK@Z PROC NEAR ; DirectSound::CMcpxBufferSgeHeap::UnmapBuffer, COMDAT

; 698  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 699  :     DPF_ENTER();
; 700  : 
; 701  :     ASSERT(pvBaseAddress);
; 702  :     ASSERT(!((DWORD)pvBaseAddress & (PAGE_SIZE - 1)));
; 703  :     ASSERT(dnLength);
; 704  : 
; 705  :     //
; 706  :     // Unlock the buffer data
; 707  :     //
; 708  : 
; 709  :     MmLockUnlockBufferPages(pvBaseAddress, dnLength << PAGE_SHIFT, TRUE);

  00003	6a 01		 push	 1
  00005	8b 45 0c	 mov	 eax, DWORD PTR _dnLength$[ebp]
  00008	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  0000f	51		 push	 ecx
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmLockUnlockBufferPages@12

; 710  : 
; 711  :     DPF_LEAVE_VOID();
; 712  : }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?UnmapBuffer@CMcpxBufferSgeHeap@DirectSound@@KGXPAXK@Z ENDP ; DirectSound::CMcpxBufferSgeHeap::UnmapBuffer
DSOUND	ENDS
PUBLIC	??_7CMcpxSlopMemoryHeap@DirectSound@@6B@	; DirectSound::CMcpxSlopMemoryHeap::`vftable'
PUBLIC	??_GCMcpxSlopMemoryHeap@DirectSound@@UAEPAXI@Z	; DirectSound::CMcpxSlopMemoryHeap::`scalar deleting destructor'
EXTRN	??_ECMcpxSlopMemoryHeap@DirectSound@@UAEPAXI@Z:NEAR ; DirectSound::CMcpxSlopMemoryHeap::`vector deleting destructor'
;	COMDAT ??_7CMcpxSlopMemoryHeap@DirectSound@@6B@
CONST	SEGMENT
??_7CMcpxSlopMemoryHeap@DirectSound@@6B@ DD FLAT:??_ECMcpxSlopMemoryHeap@DirectSound@@UAEPAXI@Z ; DirectSound::CMcpxSlopMemoryHeap::`vftable'
	DD	FLAT:?AddRef@CRefCount@DirectSound@@UAGKXZ
	DD	FLAT:?Release@CRefCount@DirectSound@@UAGKXZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CMcpxSlopMemoryHeap@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CMcpxSlopMemoryHeap@DirectSound@@QAE@XZ PROC NEAR	; DirectSound::CMcpxSlopMemoryHeap::CMcpxSlopMemoryHeap, COMDAT
; _this$ = ecx

; 737  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 01		 push	 1
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CRefCount@DirectSound@@QAE@K@Z ; DirectSound::CRefCount::CRefCount
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMcpxSlopMemoryHeap@DirectSound@@6B@

; 738  :     DPF_ENTER();
; 739  : 
; 740  :     ASSERT(!m_dwAvailable);
; 741  :     ASSERT(!m_dwUsed);
; 742  : 
; 743  :     ASSERT(!m_pSlopMemoryHeap);
; 744  :     m_pSlopMemoryHeap = this;

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A, ecx ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap

; 745  : 
; 746  :     InitializeListHead(&m_lstEntries);

  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	83 c2 08	 add	 edx, 8
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00035	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00038	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 747  :     InitializeListHead(&m_lstRuns);

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	83 c1 10	 add	 ecx, 16			; 00000010H
  00041	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00044	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00050	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 748  : 
; 749  :     DPF_LEAVE_VOID();
; 750  : }

  00053	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
??0CMcpxSlopMemoryHeap@DirectSound@@QAE@XZ ENDP		; DirectSound::CMcpxSlopMemoryHeap::CMcpxSlopMemoryHeap
DSOUND	ENDS
PUBLIC	??1CMcpxSlopMemoryHeap@DirectSound@@UAE@XZ	; DirectSound::CMcpxSlopMemoryHeap::~CMcpxSlopMemoryHeap
; Function compile flags: /Odt
;	COMDAT ??_GCMcpxSlopMemoryHeap@DirectSound@@UAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCMcpxSlopMemoryHeap@DirectSound@@UAEPAXI@Z PROC NEAR ; DirectSound::CMcpxSlopMemoryHeap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMcpxSlopMemoryHeap@DirectSound@@UAE@XZ ; DirectSound::CMcpxSlopMemoryHeap::~CMcpxSlopMemoryHeap
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L39932
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L39932:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCMcpxSlopMemoryHeap@DirectSound@@UAEPAXI@Z ENDP	; DirectSound::CMcpxSlopMemoryHeap::`scalar deleting destructor'
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??1CMcpxSlopMemoryHeap@DirectSound@@UAE@XZ
DSOUND	SEGMENT
_this$ = -24
___AutoIrql$ = -20
_pEntryNode$ = -12
_pleEntry$ = -8
_pvBaseAddress$ = -4
??1CMcpxSlopMemoryHeap@DirectSound@@UAE@XZ PROC NEAR	; DirectSound::CMcpxSlopMemoryHeap::~CMcpxSlopMemoryHeap, COMDAT
; _this$ = ecx

; 775  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CMcpxSlopMemoryHeap@DirectSound@@6B@

; 776  : 
; 777  : #ifdef DEBUG
; 778  : 
; 779  :     LPSLOPRUNMARKER         pMarkerNode;
; 780  : 
; 781  : #endif // DEBUG
; 782  : 
; 783  :     PLIST_ENTRY             pleEntry;
; 784  :     LPSLOPMEMENTRY          pEntryNode;
; 785  :     LPVOID                  pvBaseAddress;
; 786  : 
; 787  :     DPF_ENTER();
; 788  :     AutoIrql();

  00012	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00015	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 789  : 
; 790  : #ifdef DEBUG
; 791  : 
; 792  :     // 
; 793  :     // Make sure no memory is still being used
; 794  :     //
; 795  :     
; 796  :     for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)
; 797  :     {
; 798  :         pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);
; 799  : 
; 800  :         ASSERT(!pMarkerNode->fAllocated);
; 801  :     }
; 802  : 
; 803  : #endif // DEBUG
; 804  : 
; 805  :     //
; 806  :     // Free the global pointer
; 807  :     //
; 808  :     
; 809  :     ASSERT(this == m_pSlopMemoryHeap);
; 810  :     m_pSlopMemoryHeap = NULL;

  0001a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_pSlopMemoryHeap@CMcpxSlopMemoryHeap@DirectSound@@2PAV12@A, 0 ; DirectSound::CMcpxSlopMemoryHeap::m_pSlopMemoryHeap
$L39942:

; 811  : 
; 812  :     //
; 813  :     // Free memory owned by the heap
; 814  :     //
; 815  : 
; 816  :     while((pleEntry = RemoveHeadList(&m_lstEntries)) != &m_lstEntries)

  00024	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002a	52		 push	 edx
  0002b	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList
  00030	89 45 f8	 mov	 DWORD PTR _pleEntry$[ebp], eax
  00033	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	83 c0 08	 add	 eax, 8
  00039	39 45 f8	 cmp	 DWORD PTR _pleEntry$[ebp], eax
  0003c	74 27		 je	 SHORT $L39943

; 817  :     {
; 818  :         pEntryNode = CONTAINING_RECORD(pleEntry, SLOPMEMENTRY, leListEntry);

  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  00041	89 4d f4	 mov	 DWORD PTR _pEntryNode$[ebp], ecx

; 819  :         pvBaseAddress = pEntryNode->pvBaseAddress;

  00044	8b 55 f4	 mov	 edx, DWORD PTR _pEntryNode$[ebp]
  00047	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004a	89 45 fc	 mov	 DWORD PTR _pvBaseAddress$[ebp], eax

; 820  :         
; 821  :         PHYSFREE(pvBaseAddress);

  0004d	83 7d fc 00	 cmp	 DWORD PTR _pvBaseAddress$[ebp], 0
  00051	74 10		 je	 SHORT $L39948
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _pvBaseAddress$[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PhysicalFree
  0005c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pvBaseAddress$[ebp], 0
$L39948:

; 822  :     }

  00063	eb bf		 jmp	 SHORT $L39942
$L39943:

; 823  : 
; 824  :     //
; 825  :     // Reset tracking values
; 826  :     //
; 827  : 
; 828  :     ASSERT(!m_dwUsed);
; 829  : 
; 830  :     m_dwAvailable = 0;

  00065	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwAvailable@CMcpxSlopMemoryHeap@DirectSound@@2AAKA ; DirectSound::CMcpxSlopMemoryHeap::m_dwAvailable
  0006b	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 831  :     m_dwUsed = 0;

  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeap@DirectSound@@2AAKA ; DirectSound::CMcpxSlopMemoryHeap::m_dwUsed
  00076	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 832  : 
; 833  :     DPF_LEAVE_VOID();
; 834  : }

  0007c	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0007f	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00084	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??1CRefCount@DirectSound@@UAE@XZ ; DirectSound::CRefCount::~CRefCount
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
??1CMcpxSlopMemoryHeap@DirectSound@@UAE@XZ ENDP		; DirectSound::CMcpxSlopMemoryHeap::~CMcpxSlopMemoryHeap
DSOUND	ENDS
PUBLIC	?CreateMarker@CMcpxSlopMemoryHeap@DirectSound@@IAEPAUSLOPRUNMARKER@@PAXKPAU_LIST_ENTRY@@@Z ; DirectSound::CMcpxSlopMemoryHeap::CreateMarker
; Function compile flags: /Odt
;	COMDAT ?AddRun@CMcpxSlopMemoryHeap@DirectSound@@QAEHPAXKK@Z
DSOUND	SEGMENT
_this$ = -32
$T42552 = -28
___AutoIrql$ = -24
_pRunMarker$ = -16
_nSlopLength$ = -12
_fOwned$ = -8
_pEntry$ = -4
_pvBaseAddress$ = 8
_nLength$ = 12
_nUsed$ = 16
?AddRun@CMcpxSlopMemoryHeap@DirectSound@@QAEHPAXKK@Z PROC NEAR ; DirectSound::CMcpxSlopMemoryHeap::AddRun, COMDAT
; _this$ = ecx

; 867  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 868  :     DWORD                   nSlopLength;
; 869  :     LPSLOPRUNMARKER         pRunMarker;
; 870  :     LPSLOPMEMENTRY          pEntry;
; 871  :     BOOL                    fOwned;
; 872  :     
; 873  :     DPF_ENTER();
; 874  :     AutoIrql();

  00009	8d 4d e8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 875  : 
; 876  :     //
; 877  :     // Make sure the run is large enough to hold the tracking entry, at least
; 878  :     // one run marker and still have some space left over for data.
; 879  :     //
; 880  : 
; 881  :     ASSERT(nLength >= nUsed);
; 882  :     nSlopLength = nLength - nUsed;

  00011	8b 45 0c	 mov	 eax, DWORD PTR _nLength$[ebp]
  00014	2b 45 10	 sub	 eax, DWORD PTR _nUsed$[ebp]
  00017	89 45 f4	 mov	 DWORD PTR _nSlopLength$[ebp], eax

; 883  : 
; 884  :     if(fOwned = (nSlopLength > sizeof(*pEntry) + sizeof(*pRunMarker) + m_dwUsageThreshold))

  0001a	b9 5c 00 00 00	 mov	 ecx, 92			; 0000005cH
  0001f	3b 4d f4	 cmp	 ecx, DWORD PTR _nSlopLength$[ebp]
  00022	1b d2		 sbb	 edx, edx
  00024	f7 da		 neg	 edx
  00026	89 55 f8	 mov	 DWORD PTR _fOwned$[ebp], edx
  00029	83 7d f8 00	 cmp	 DWORD PTR _fOwned$[ebp], 0
  0002d	0f 84 83 00 00
	00		 je	 $L39960

; 885  :     {
; 886  :         //
; 887  :         // Add the allocation to the entry list so we can free it later.  
; 888  :         // We'll use the first part of the unused memory as the entry marker
; 889  :         //
; 890  : 
; 891  :         pEntry = (LPSLOPMEMENTRY)((LPBYTE)pvBaseAddress + nUsed);

  00033	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  00036	03 45 10	 add	 eax, DWORD PTR _nUsed$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR _pEntry$[ebp], eax

; 892  : 
; 893  :         pEntry->pvBaseAddress = pvBaseAddress;

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _pEntry$[ebp]
  0003f	8b 55 08	 mov	 edx, DWORD PTR _pvBaseAddress$[ebp]
  00042	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 894  : 
; 895  :         InsertTailListUninit(&m_lstEntries, &pEntry->leListEntry);

  00045	8b 45 fc	 mov	 eax, DWORD PTR _pEntry$[ebp]
  00048	50		 push	 eax
  00049	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	83 c1 08	 add	 ecx, 8
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?InsertTailListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertTailListUninit

; 896  : 
; 897  :         //
; 898  :         // Initialize a run marker immediately after the tracking entry and
; 899  :         // add it to the run list.
; 900  :         //
; 901  : 
; 902  :         pRunMarker = CreateMarker(pEntry + 1, nSlopLength - sizeof(*pEntry), &m_lstRuns);

  00055	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00058	83 c2 10	 add	 edx, 16			; 00000010H
  0005b	52		 push	 edx
  0005c	8b 45 f4	 mov	 eax, DWORD PTR _nSlopLength$[ebp]
  0005f	83 e8 0c	 sub	 eax, 12			; 0000000cH
  00062	50		 push	 eax
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _pEntry$[ebp]
  00066	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00069	51		 push	 ecx
  0006a	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?CreateMarker@CMcpxSlopMemoryHeap@DirectSound@@IAEPAUSLOPRUNMARKER@@PAXKPAU_LIST_ENTRY@@@Z ; DirectSound::CMcpxSlopMemoryHeap::CreateMarker
  00072	89 45 f0	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 903  : 
; 904  :         if(m_pLargestFreeRunMarker)

  00075	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00078	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  0007c	74 1c		 je	 SHORT $L39963

; 905  :         {
; 906  :             if(pRunMarker->nLength > m_pLargestFreeRunMarker->nLength)

  0007e	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00084	8b 55 f0	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00087	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008a	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0008d	76 09		 jbe	 SHORT $L39964

; 907  :             {
; 908  :                 m_pLargestFreeRunMarker = pRunMarker;

  0008f	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	8b 55 f0	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00095	89 51 18	 mov	 DWORD PTR [ecx+24], edx
$L39964:

; 909  :             }
; 910  :         }
; 911  :         else

  00098	eb 09		 jmp	 SHORT $L39965
$L39963:

; 912  :         {
; 913  :             m_pLargestFreeRunMarker = pRunMarker;

  0009a	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	8b 4d f0	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000a0	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$L39965:

; 914  :         }
; 915  : 
; 916  :         m_dwAvailable += nLength;

  000a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwAvailable@CMcpxSlopMemoryHeap@DirectSound@@2AAKA ; DirectSound::CMcpxSlopMemoryHeap::m_dwAvailable
  000a9	8b 02		 mov	 eax, DWORD PTR [edx]
  000ab	03 45 0c	 add	 eax, DWORD PTR _nLength$[ebp]
  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwAvailable@CMcpxSlopMemoryHeap@DirectSound@@2AAKA ; DirectSound::CMcpxSlopMemoryHeap::m_dwAvailable
  000b4	89 01		 mov	 DWORD PTR [ecx], eax
$L39960:

; 917  : 
; 918  :         DPF_MEM_HEAP("Added %x to the slop heap (entry %x, run marker %x, length %lu, %lu bytes used for tracking, %lu bytes used for run marker)", pvBaseAddress, pEntry, pRunMarker, nSlopLength, sizeof(*pEntry), sizeof(*pRunMarker));
; 919  :     }
; 920  : 
; 921  :     DPF_LEAVE(fOwned);
; 922  : 
; 923  :     return fOwned;

  000b6	8b 55 f8	 mov	 edx, DWORD PTR _fOwned$[ebp]
  000b9	89 55 e4	 mov	 DWORD PTR $T42552[ebp], edx
  000bc	8d 4d e8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000bf	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000c4	8b 45 e4	 mov	 eax, DWORD PTR $T42552[ebp]

; 924  : }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c2 0c 00	 ret	 12			; 0000000cH
?AddRun@CMcpxSlopMemoryHeap@DirectSound@@QAEHPAXKK@Z ENDP ; DirectSound::CMcpxSlopMemoryHeap::AddRun
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\heap.h
DSOUND	ENDS
;	COMDAT ?CreateMarker@CMcpxSlopMemoryHeap@DirectSound@@IAEPAUSLOPRUNMARKER@@PAXKPAU_LIST_ENTRY@@@Z
DSOUND	SEGMENT
_this$ = -8
_pRunMarker$ = -4
_pvBaseAddress$ = 8
_nLength$ = 12
_plePrevEntry$ = 16
?CreateMarker@CMcpxSlopMemoryHeap@DirectSound@@IAEPAUSLOPRUNMARKER@@PAXKPAU_LIST_ENTRY@@@Z PROC NEAR ; DirectSound::CMcpxSlopMemoryHeap::CreateMarker, COMDAT
; _this$ = ecx

; 163  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 164  :         LPSLOPRUNMARKER         pRunMarker  = (LPSLOPRUNMARKER)pvBaseAddress;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 165  :     
; 166  :         ASSERT(nLength > sizeof(*pRunMarker));
; 167  : 
; 168  :         InsertHeadListUninit(plePrevEntry, &pRunMarker->leListEntry);

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 10	 mov	 edx, DWORD PTR _plePrevEntry$[ebp]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 ?InsertHeadListUninit@@YGXPAU_LIST_ENTRY@@0@Z ; InsertHeadListUninit

; 169  : 
; 170  :         pRunMarker->nLength = nLength;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _nLength$[ebp]
  00022	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 171  :         pRunMarker->dwSignature = 0;

  00025	8b 55 fc	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00028	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 172  : 
; 173  :         return pRunMarker;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _pRunMarker$[ebp]

; 174  :     }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 0c 00	 ret	 12			; 0000000cH
?CreateMarker@CMcpxSlopMemoryHeap@DirectSound@@IAEPAUSLOPRUNMARKER@@PAXKPAU_LIST_ENTRY@@@Z ENDP ; DirectSound::CMcpxSlopMemoryHeap::CreateMarker
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\dsound\heap.cpp
DSOUND	ENDS
;	COMDAT ?Alloc@CMcpxSlopMemoryHeap@DirectSound@@QAEPAXK@Z
DSOUND	SEGMENT
tv159 = -32
_this$ = -28
$T42559 = -24
___AutoIrql$ = -20
_pleEntry$ = -12
_pRunMarker$ = -8
_pMarkerNode$ = -4
_nLength$ = 8
?Alloc@CMcpxSlopMemoryHeap@DirectSound@@QAEPAXK@Z PROC NEAR ; DirectSound::CMcpxSlopMemoryHeap::Alloc, COMDAT
; _this$ = ecx

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 951  :     LPSLOPRUNMARKER         pRunMarker      = NULL;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pRunMarker$[ebp], 0

; 952  :     LPSLOPRUNMARKER         pMarkerNode;
; 953  :     PLIST_ENTRY             pleEntry;
; 954  : 
; 955  :     DPF_ENTER();
; 956  :     AutoIrql();

  00010	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00013	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 957  : 
; 958  :     //
; 959  :     // The length must include the space to hold the run marker
; 960  :     //
; 961  : 
; 962  :     nLength += sizeof(SLOPRUNMARKER);

  00018	8b 45 08	 mov	 eax, DWORD PTR _nLength$[ebp]
  0001b	83 c0 10	 add	 eax, 16			; 00000010H
  0001e	89 45 08	 mov	 DWORD PTR _nLength$[ebp], eax

; 963  : 
; 964  :     //
; 965  :     // Check the largest available run length to see if we can service
; 966  :     // the request
; 967  :     //
; 968  : 
; 969  :     if(m_pLargestFreeRunMarker)

  00021	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  00028	0f 84 5b 01 00
	00		 je	 $L39976

; 970  :     {
; 971  :         if(m_pLargestFreeRunMarker->nLength >= nLength)

  0002e	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00034	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00037	3b 4d 08	 cmp	 ecx, DWORD PTR _nLength$[ebp]
  0003a	0f 82 49 01 00
	00		 jb	 $L39976

; 972  :         {
; 973  :             //
; 974  :             // Find a free run that is as close as possible to the requested element
; 975  :             // count.  This will help to reduce fragmentation.
; 976  :             //
; 977  : 
; 978  :             for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)

  00040	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00043	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00046	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax
  00049	eb 08		 jmp	 SHORT $L39978
$L39979:
  0004b	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  0004e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00050	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx
$L39978:
  00053	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00056	83 c0 10	 add	 eax, 16			; 00000010H
  00059	39 45 f4	 cmp	 DWORD PTR _pleEntry$[ebp], eax
  0005c	74 3e		 je	 SHORT $L39980

; 979  :             {
; 980  :                 AssertValidEntryList(pleEntry, ASSERT_IN_LIST);
; 981  : 
; 982  :                 pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  00061	89 4d fc	 mov	 DWORD PTR _pMarkerNode$[ebp], ecx

; 983  :             
; 984  :                 if(!pMarkerNode->fAllocated)

  00064	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  00067	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0006b	75 2d		 jne	 SHORT $L39985

; 985  :                 {
; 986  :                     if(pMarkerNode->nLength >= nLength)

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	3b 4d 08	 cmp	 ecx, DWORD PTR _nLength$[ebp]
  00076	72 22		 jb	 SHORT $L39985

; 987  :                     {
; 988  :                         if(!pRunMarker)

  00078	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  0007c	75 08		 jne	 SHORT $L39987

; 989  :                         {
; 990  :                             pRunMarker = pMarkerNode;

  0007e	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  00081	89 55 f8	 mov	 DWORD PTR _pRunMarker$[ebp], edx

; 991  :                         }
; 992  :                         else if(pMarkerNode->nLength < pRunMarker->nLength)

  00084	eb 14		 jmp	 SHORT $L39985
$L39987:
  00086	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  00089	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  0008c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0008f	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00092	73 06		 jae	 SHORT $L39985

; 993  :                         {
; 994  :                             pRunMarker = pMarkerNode;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  00097	89 45 f8	 mov	 DWORD PTR _pRunMarker$[ebp], eax
$L39985:

; 995  :                         }
; 996  :                     }
; 997  :                 }
; 998  :             }

  0009a	eb af		 jmp	 SHORT $L39979
$L39980:

; 999  : 
; 1000 :             //
; 1001 :             // If we're using the whole run, just flag it as allocated.  If not,
; 1002 :             // create a new marker from the remaining buffer and add it to the 
; 1003 :             // list.  We're only using a single list so that runs can be broken 
; 1004 :             // and coalesced without having to walk the list.
; 1005 :             //
; 1006 : 
; 1007 :             if(pRunMarker)

  0009c	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  000a0	74 41		 je	 SHORT $L39990

; 1008 :             {
; 1009 :                 if(nLength + sizeof(*pRunMarker) + m_dwUsageThreshold < pRunMarker->nLength)

  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _nLength$[ebp]
  000a5	83 c1 50	 add	 ecx, 80			; 00000050H
  000a8	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000ab	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  000ae	73 29		 jae	 SHORT $L39993

; 1010 :                 {
; 1011 :                     pMarkerNode = CreateMarker((LPBYTE)pRunMarker + nLength, pRunMarker->nLength - nLength, &pRunMarker->leListEntry);

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000b7	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ba	2b 55 08	 sub	 edx, DWORD PTR _nLength$[ebp]
  000bd	52		 push	 edx
  000be	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000c1	03 45 08	 add	 eax, DWORD PTR _nLength$[ebp]
  000c4	50		 push	 eax
  000c5	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	e8 00 00 00 00	 call	 ?CreateMarker@CMcpxSlopMemoryHeap@DirectSound@@IAEPAUSLOPRUNMARKER@@PAXKPAU_LIST_ENTRY@@@Z ; DirectSound::CMcpxSlopMemoryHeap::CreateMarker
  000cd	89 45 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], eax

; 1012 : 
; 1013 :                     pRunMarker->nLength = nLength;

  000d0	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  000d3	8b 55 08	 mov	 edx, DWORD PTR _nLength$[ebp]
  000d6	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$L39993:

; 1014 : 
; 1015 :                     DPF_MEM_HEAP("Split memory run into %x (%lu) and %x (%lu)", pRunMarker, pRunMarker->nLength, pMarkerNode, pMarkerNode->nLength);
; 1016 :                 }
; 1017 :                 else
; 1018 :                 {
; 1019 :                     DPF_MEM_HEAP("Allocating memory run %x (%lu)", pRunMarker, pRunMarker->nLength);
; 1020 :                 }
; 1021 : 
; 1022 :                 pRunMarker->dwSignature = DSOUND_ALLOCATOR_SLOP;

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000dc	c7 40 0c 73 6c
	6f 70		 mov	 DWORD PTR [eax+12], 1886350451 ; 706f6c73H
$L39990:

; 1023 :             }
; 1024 : 
; 1025 :             //
; 1026 :             // Update the largest run member
; 1027 :             //
; 1028 : 
; 1029 :             if(pRunMarker)

  000e3	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  000e7	74 72		 je	 SHORT $L39994

; 1030 :             {
; 1031 :                 if(pRunMarker == m_pLargestFreeRunMarker)

  000e9	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000ef	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  000f2	75 67		 jne	 SHORT $L39994

; 1032 :                 {
; 1033 :                     m_pLargestFreeRunMarker = NULL;

  000f4	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 1034 :                     
; 1035 :                     for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)

  000fe	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00101	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00104	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx
  00107	eb 08		 jmp	 SHORT $L39996
$L39997:
  00109	8b 45 f4	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  0010c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010e	89 4d f4	 mov	 DWORD PTR _pleEntry$[ebp], ecx
$L39996:
  00111	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00114	83 c2 10	 add	 edx, 16			; 00000010H
  00117	39 55 f4	 cmp	 DWORD PTR _pleEntry$[ebp], edx
  0011a	74 3f		 je	 SHORT $L39994

; 1036 :                     {
; 1037 :                         AssertValidEntryList(pleEntry, ASSERT_IN_LIST);
; 1038 : 
; 1039 :                         pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

  0011c	8b 45 f4	 mov	 eax, DWORD PTR _pleEntry$[ebp]
  0011f	89 45 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], eax

; 1040 :             
; 1041 :                         if(!pMarkerNode->fAllocated)

  00122	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  00125	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00129	75 2e		 jne	 SHORT $L40003

; 1042 :                         {
; 1043 :                             if(!m_pLargestFreeRunMarker)

  0012b	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0012e	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00132	75 0b		 jne	 SHORT $L40004

; 1044 :                             {
; 1045 :                                 m_pLargestFreeRunMarker = pMarkerNode;

  00134	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00137	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  0013a	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 1046 :                             }
; 1047 :                             else if(pMarkerNode->nLength > m_pLargestFreeRunMarker->nLength)

  0013d	eb 1a		 jmp	 SHORT $L40003
$L40004:
  0013f	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00142	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00145	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  00148	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0014b	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0014e	76 09		 jbe	 SHORT $L40003

; 1048 :                             {
; 1049 :                                 m_pLargestFreeRunMarker = pMarkerNode;

  00150	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00153	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  00156	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$L40003:

; 1050 :                             }
; 1051 :                         }
; 1052 :                     }

  00159	eb ae		 jmp	 SHORT $L39997
$L39994:

; 1053 :                 }                    
; 1054 :             }
; 1055 : 
; 1056 :             //
; 1057 :             // Update the amount of memory recovered
; 1058 :             //
; 1059 : 
; 1060 :             if(pRunMarker)

  0015b	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  0015f	74 16		 je	 SHORT $L40007

; 1061 :             {
; 1062 :                 m_dwUsed += pRunMarker->nLength;

  00161	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeap@DirectSound@@2AAKA ; DirectSound::CMcpxSlopMemoryHeap::m_dwUsed
  00167	8b 02		 mov	 eax, DWORD PTR [edx]
  00169	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  0016c	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  0016f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeap@DirectSound@@2AAKA ; DirectSound::CMcpxSlopMemoryHeap::m_dwUsed
  00175	89 02		 mov	 DWORD PTR [edx], eax
$L40007:

; 1063 :             }
; 1064 : 
; 1065 :             //
; 1066 :             // AddRef ourselves so we're always around as long as allocated
; 1067 :             // memory is.
; 1068 :             //
; 1069 : 
; 1070 :             if(pRunMarker)

  00177	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  0017b	74 0c		 je	 SHORT $L39976

; 1071 :             {
; 1072 :                 AddRef();

  0017d	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00180	8b 08		 mov	 ecx, DWORD PTR [eax]
  00182	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00185	52		 push	 edx
  00186	ff 51 04	 call	 DWORD PTR [ecx+4]
$L39976:

; 1073 :             }
; 1074 :         }
; 1075 :     }
; 1076 : 
; 1077 :     DPF_LEAVE(pRunMarker ? pRunMarker + 1 : NULL);
; 1078 : 
; 1079 :     return pRunMarker ? pRunMarker + 1 : NULL;

  00189	83 7d f8 00	 cmp	 DWORD PTR _pRunMarker$[ebp], 0
  0018d	74 0b		 je	 SHORT $L42560
  0018f	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00192	83 c0 10	 add	 eax, 16			; 00000010H
  00195	89 45 e0	 mov	 DWORD PTR tv159[ebp], eax
  00198	eb 07		 jmp	 SHORT $L42561
$L42560:
  0019a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv159[ebp], 0
$L42561:
  001a1	8b 4d e0	 mov	 ecx, DWORD PTR tv159[ebp]
  001a4	89 4d e8	 mov	 DWORD PTR $T42559[ebp], ecx
  001a7	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  001aa	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  001af	8b 45 e8	 mov	 eax, DWORD PTR $T42559[ebp]

; 1080 : }

  001b2	8b e5		 mov	 esp, ebp
  001b4	5d		 pop	 ebp
  001b5	c2 04 00	 ret	 4
?Alloc@CMcpxSlopMemoryHeap@DirectSound@@QAEPAXK@Z ENDP	; DirectSound::CMcpxSlopMemoryHeap::Alloc
DSOUND	ENDS
PUBLIC	?CoalesceRuns@CMcpxSlopMemoryHeap@DirectSound@@IAEPAUSLOPRUNMARKER@@PAU3@0@Z ; DirectSound::CMcpxSlopMemoryHeap::CoalesceRuns
; Function compile flags: /Odt
;	COMDAT ?Free@CMcpxSlopMemoryHeap@DirectSound@@QAEXPAX@Z
DSOUND	SEGMENT
_this$ = -24
___AutoIrql$ = -20
_pleEntry$ = -12
_pRunMarker$ = -8
_pMarkerNode$ = -4
_pvBaseAddress$ = 8
?Free@CMcpxSlopMemoryHeap@DirectSound@@QAEXPAX@Z PROC NEAR ; DirectSound::CMcpxSlopMemoryHeap::Free, COMDAT
; _this$ = ecx

; 1106 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1107 :     LPSLOPRUNMARKER         pRunMarker  = (LPSLOPRUNMARKER)pvBaseAddress - 1;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pvBaseAddress$[ebp]
  0000c	83 e8 10	 sub	 eax, 16			; 00000010H
  0000f	89 45 f8	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 1108 :     PLIST_ENTRY             pleEntry;
; 1109 :     LPSLOPRUNMARKER         pMarkerNode;
; 1110 :     
; 1111 :     DPF_ENTER();
; 1112 :     AutoIrql();

  00012	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00015	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1113 : 
; 1114 :     ASSERT(DSOUND_ALLOCATOR_SLOP == pRunMarker->dwSignature);
; 1115 : 
; 1116 :     DPF_MEM_HEAP("Freeing memory run %x (%lu)", pRunMarker, pRunMarker->nLength);
; 1117 : 
; 1118 :     //
; 1119 :     // Update the amount of memory recovered
; 1120 :     //
; 1121 : 
; 1122 :     ASSERT(m_dwUsed >= pRunMarker->nLength);
; 1123 :     m_dwUsed -= pRunMarker->nLength;

  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeap@DirectSound@@2AAKA ; DirectSound::CMcpxSlopMemoryHeap::m_dwUsed
  00020	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00023	8b 01		 mov	 eax, DWORD PTR [ecx]
  00025	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwUsed@CMcpxSlopMemoryHeap@DirectSound@@2AAKA ; DirectSound::CMcpxSlopMemoryHeap::m_dwUsed
  0002e	89 01		 mov	 DWORD PTR [ecx], eax

; 1124 : 
; 1125 :     //
; 1126 :     // Reset the run signature so it's flagged as free
; 1127 :     //
; 1128 : 
; 1129 :     pRunMarker->dwSignature = 0;

  00030	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00033	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
$L40020:

; 1130 : 
; 1131 :     //
; 1132 :     // Coalesce the run with those around it
; 1133 :     //
; 1134 : 
; 1135 :     while(TRUE)

  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	74 4b		 je	 SHORT $L40032

; 1136 :     {
; 1137 :         if((pleEntry = pRunMarker->leListEntry.Flink) == &m_lstRuns)

  00043	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  00046	8b 11		 mov	 edx, DWORD PTR [ecx]
  00048	89 55 f4	 mov	 DWORD PTR _pleEntry$[ebp], edx
  0004b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	83 c0 10	 add	 eax, 16			; 00000010H
  00051	39 45 f4	 cmp	 DWORD PTR _pleEntry$[ebp], eax
  00054	75 02		 jne	 SHORT $L40022

; 1138 :         {
; 1139 :             break;

  00056	eb 36		 jmp	 SHORT $L40032
$L40022:

; 1140 :         }
; 1141 : 
; 1142 :         pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

  00058	8b 4d f4	 mov	 ecx, DWORD PTR _pleEntry$[ebp]
  0005b	89 4d fc	 mov	 DWORD PTR _pMarkerNode$[ebp], ecx

; 1143 : 
; 1144 :         if(pMarkerNode->fAllocated)

  0005e	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  00061	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  00065	74 02		 je	 SHORT $L40027

; 1145 :         {
; 1146 :             break;

  00067	eb 25		 jmp	 SHORT $L40032
$L40027:

; 1147 :         }
; 1148 : 
; 1149 :         if((LPBYTE)pRunMarker + pRunMarker->nLength != (LPBYTE)pMarkerNode)

  00069	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0006c	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  0006f	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  00072	3b 4d fc	 cmp	 ecx, DWORD PTR _pMarkerNode$[ebp]
  00075	74 02		 je	 SHORT $L40030

; 1150 :         {
; 1151 :             break;

  00077	eb 15		 jmp	 SHORT $L40032
$L40030:

; 1152 :         }
; 1153 : 
; 1154 :         pRunMarker = CoalesceRuns(pRunMarker, pMarkerNode);

  00079	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  0007c	52		 push	 edx
  0007d	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00080	50		 push	 eax
  00081	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ?CoalesceRuns@CMcpxSlopMemoryHeap@DirectSound@@IAEPAUSLOPRUNMARKER@@PAU3@0@Z ; DirectSound::CMcpxSlopMemoryHeap::CoalesceRuns
  00089	89 45 f8	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 1155 :     }

  0008c	eb ac		 jmp	 SHORT $L40020
$L40032:

; 1156 : 
; 1157 :     while(TRUE)

  0008e	b9 01 00 00 00	 mov	 ecx, 1
  00093	85 c9		 test	 ecx, ecx
  00095	74 4c		 je	 SHORT $L40033

; 1158 :     {
; 1159 :         if((pleEntry = pRunMarker->leListEntry.Blink) == &m_lstRuns)

  00097	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  0009a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0009d	89 45 f4	 mov	 DWORD PTR _pleEntry$[ebp], eax
  000a0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	83 c1 10	 add	 ecx, 16			; 00000010H
  000a6	39 4d f4	 cmp	 DWORD PTR _pleEntry$[ebp], ecx
  000a9	75 02		 jne	 SHORT $L40034

; 1160 :         {
; 1161 :             break;

  000ab	eb 36		 jmp	 SHORT $L40033
$L40034:

; 1162 :         }
; 1163 : 
; 1164 :         pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

  000ad	8b 55 f4	 mov	 edx, DWORD PTR _pleEntry$[ebp]
  000b0	89 55 fc	 mov	 DWORD PTR _pMarkerNode$[ebp], edx

; 1165 : 
; 1166 :         if(pMarkerNode->fAllocated)

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _pMarkerNode$[ebp]
  000b6	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000ba	74 02		 je	 SHORT $L40039

; 1167 :         {
; 1168 :             break;

  000bc	eb 25		 jmp	 SHORT $L40033
$L40039:

; 1169 :         }
; 1170 : 
; 1171 :         if((LPBYTE)pMarkerNode + pMarkerNode->nLength != (LPBYTE)pRunMarker)

  000be	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  000c1	8b 55 fc	 mov	 edx, DWORD PTR _pMarkerNode$[ebp]
  000c4	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  000c7	3b 55 f8	 cmp	 edx, DWORD PTR _pRunMarker$[ebp]
  000ca	74 02		 je	 SHORT $L40042

; 1172 :         {
; 1173 :             break;

  000cc	eb 15		 jmp	 SHORT $L40033
$L40042:

; 1174 :         }
; 1175 : 
; 1176 :         pRunMarker = CoalesceRuns(pMarkerNode, pRunMarker);

  000ce	8b 45 f8	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _pMarkerNode$[ebp]
  000d5	51		 push	 ecx
  000d6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	e8 00 00 00 00	 call	 ?CoalesceRuns@CMcpxSlopMemoryHeap@DirectSound@@IAEPAUSLOPRUNMARKER@@PAU3@0@Z ; DirectSound::CMcpxSlopMemoryHeap::CoalesceRuns
  000de	89 45 f8	 mov	 DWORD PTR _pRunMarker$[ebp], eax

; 1177 :     }

  000e1	eb ab		 jmp	 SHORT $L40032
$L40033:

; 1178 : 
; 1179 :     //
; 1180 :     // Update the largest run pointer
; 1181 :     //
; 1182 : 
; 1183 :     if(m_pLargestFreeRunMarker)

  000e3	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000e6	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  000ea	74 1c		 je	 SHORT $L40043

; 1184 :     {
; 1185 :         if(pRunMarker->nLength > m_pLargestFreeRunMarker->nLength)

  000ec	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000f2	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  000f5	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000f8	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  000fb	76 09		 jbe	 SHORT $L40044

; 1186 :         {
; 1187 :             m_pLargestFreeRunMarker = pRunMarker;

  000fd	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	8b 55 f8	 mov	 edx, DWORD PTR _pRunMarker$[ebp]
  00103	89 51 18	 mov	 DWORD PTR [ecx+24], edx
$L40044:

; 1188 :         }
; 1189 :     }
; 1190 :     else

  00106	eb 09		 jmp	 SHORT $L40045
$L40043:

; 1191 :     {
; 1192 :         m_pLargestFreeRunMarker = pRunMarker;

  00108	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0010b	8b 4d f8	 mov	 ecx, DWORD PTR _pRunMarker$[ebp]
  0010e	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$L40045:

; 1193 :     }
; 1194 : 
; 1195 :     //
; 1196 :     // Release the reference added in Alloc
; 1197 :     //
; 1198 : 
; 1199 :     Release();

  00111	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00114	8b 02		 mov	 eax, DWORD PTR [edx]
  00116	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	51		 push	 ecx
  0011a	ff 50 08	 call	 DWORD PTR [eax+8]

; 1200 : 
; 1201 :     DPF_LEAVE_VOID();
; 1202 : }

  0011d	8d 4d ec	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00120	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c2 04 00	 ret	 4
?Free@CMcpxSlopMemoryHeap@DirectSound@@QAEXPAX@Z ENDP	; DirectSound::CMcpxSlopMemoryHeap::Free
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?CoalesceRuns@CMcpxSlopMemoryHeap@DirectSound@@IAEPAUSLOPRUNMARKER@@PAU3@0@Z
DSOUND	SEGMENT
_this$ = -4
_pRunMarker$ = 8
_pNextRunMarker$ = 12
?CoalesceRuns@CMcpxSlopMemoryHeap@DirectSound@@IAEPAUSLOPRUNMARKER@@PAU3@0@Z PROC NEAR ; DirectSound::CMcpxSlopMemoryHeap::CoalesceRuns, COMDAT
; _this$ = ecx

; 1231 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1232 :     DPF_ENTER();
; 1233 : 
; 1234 :     ASSERT((LPBYTE)pRunMarker + pRunMarker->nLength == (LPBYTE)pNextRunMarker);
; 1235 :     ASSERT(!pRunMarker->fAllocated);
; 1236 :     ASSERT(!pNextRunMarker->fAllocated);
; 1237 : 
; 1238 :     AssertValidEntryList(&pRunMarker->leListEntry, ASSERT_IN_LIST);
; 1239 :     AssertValidEntryList(&pNextRunMarker->leListEntry, ASSERT_IN_LIST);
; 1240 : 
; 1241 :     DPF_MEM_HEAP("Coalescing memory run %x (%lu) and %x (%lu)", pRunMarker, pRunMarker->nLength, pNextRunMarker, pNextRunMarker->nLength);
; 1242 : 
; 1243 :     pRunMarker->nLength += pNextRunMarker->nLength;

  00007	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	8b 55 0c	 mov	 edx, DWORD PTR _pNextRunMarker$[ebp]
  00010	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  00013	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]
  00016	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1244 :     
; 1245 :     RemoveEntryList(&pNextRunMarker->leListEntry);

  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _pNextRunMarker$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ?RemoveEntryList@@YGPAU_LIST_ENTRY@@PAU1@@Z ; RemoveEntryList

; 1246 : 
; 1247 :     DPF_LEAVE(pRunMarker);
; 1248 : 
; 1249 :     return pRunMarker;

  00022	8b 45 08	 mov	 eax, DWORD PTR _pRunMarker$[ebp]

; 1250 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
?CoalesceRuns@CMcpxSlopMemoryHeap@DirectSound@@IAEPAUSLOPRUNMARKER@@PAU3@0@Z ENDP ; DirectSound::CMcpxSlopMemoryHeap::CoalesceRuns
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.cpp
DSOUND	ENDS
;	COMDAT ??0CAc97Device@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??0CAc97Device@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CAc97Device::CAc97Device, COMDAT
; _this$ = ecx

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 83   :     DPF_ENTER();
; 84   : 
; 85   :     if(m_pDevice)
; 86   :     {
; 87   :         DPF_ERROR("The AC97 device driver is already running");
; 88   :     }
; 89   : 
; 90   :     m_pDevice = this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	a3 00 00 00 00	 mov	 DWORD PTR ?m_pDevice@CAc97Device@DirectSound@@2PAV12@A, eax ; DirectSound::CAc97Device::m_pDevice

; 91   : 
; 92   :     DPF_LEAVE_VOID();
; 93   : }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CAc97Device@DirectSound@@QAE@XZ ENDP			; DirectSound::CAc97Device::CAc97Device
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??1CAc97Device@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CAc97Device@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CAc97Device::~CAc97Device, COMDAT
; _this$ = ecx

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  :     DPF_ENTER();
; 120  : 
; 121  :     Terminate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Terminate@CAc97Device@DirectSound@@QAEXXZ ; DirectSound::CAc97Device::Terminate

; 122  : 
; 123  :     m_pDevice = NULL;

  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_pDevice@CAc97Device@DirectSound@@2PAV12@A, 0 ; DirectSound::CAc97Device::m_pDevice

; 124  : 
; 125  :     DPF_LEAVE_VOID();
; 126  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??1CAc97Device@DirectSound@@QAE@XZ ENDP			; DirectSound::CAc97Device::~CAc97Device
DSOUND	ENDS
PUBLIC	?CodecReady@CAc97Device@DirectSound@@IAEHXZ	; DirectSound::CAc97Device::CodecReady
PUBLIC	?PowerUp@CAc97Device@DirectSound@@IAEJXZ	; DirectSound::CAc97Device::PowerUp
PUBLIC	?PokeAciRegister8@CAc97Device@DirectSound@@KGXKE@Z ; DirectSound::CAc97Device::PokeAciRegister8
PUBLIC	?PokeAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@G@Z ; DirectSound::CAc97Device::PokeAc97Register
PUBLIC	?AciInterruptServiceRoutine@CAc97Device@DirectSound@@CGEPAU_KINTERRUPT@@PAX@Z ; DirectSound::CAc97Device::AciInterruptServiceRoutine
PUBLIC	?AciInterruptDpcHandler@CAc97Device@DirectSound@@CGXPAU_KDPC@@PAX11@Z ; DirectSound::CAc97Device::AciInterruptDpcHandler
PUBLIC	?AciShutdownNotifier@CAc97Device@DirectSound@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z ; DirectSound::CAc97Device::AciShutdownNotifier
; Function compile flags: /Odt
;	COMDAT ?Initialize@CAc97Device@DirectSound@@QAEJK@Z
DSOUND	SEGMENT
_this$ = -20
_hr$ = -16
_Irql$ = -9
_i$ = -8
_ulInterruptVector$ = -4
_dwFlags$ = 8
?Initialize@CAc97Device@DirectSound@@QAEJK@Z PROC NEAR	; DirectSound::CAc97Device::Initialize, COMDAT
; _this$ = ecx

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 153  :     HRESULT                 hr                  = DS_OK;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 154  : 
; 155  : #ifdef AC97_AMR
; 156  : 
; 157  :     DWORD                   dwRegisterValue;
; 158  :     BYTE                    bInterruptLine;
; 159  :     PCI_COMMON_CONFIG       PciConfig;
; 160  :     PCI_SLOT_NUMBER         Slot;
; 161  : 
; 162  : #endif // AC97_AMR
; 163  : 
; 164  :     KIRQL                   Irql;
; 165  :     ULONG                   ulInterruptVector;
; 166  :     DWORD                   i;
; 167  : 
; 168  :     DPF_ENTER();
; 169  : 
; 170  :     //
; 171  :     // Save the flags
; 172  :     //
; 173  :     
; 174  :     m_dwFlags = dwFlags;

  00010	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00016	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 175  : 
; 176  : #ifdef AC97_AMR
; 177  : 
; 178  :     //
; 179  :     // Poke the PCI controller to enable the AMR sound device
; 180  :     //
; 181  : 
; 182  :     _outpd(0xCF8, 0x8000F8F0);
; 183  : 
; 184  :     dwRegisterValue = _inpd(0xCFC);
; 185  : 
; 186  :     if(dwRegisterValue & 0x200000)
; 187  :     {
; 188  :         _outpd(0xCFC, dwRegisterValue & ~0x200000);
; 189  :     }
; 190  : 
; 191  :     //
; 192  :     // Get the device's interrupt line, since it won't be in the PCI config
; 193  :     //
; 194  : 
; 195  :     Slot.u.bits.DeviceNumber = m_dwDeviceNumber;
; 196  :     Slot.u.bits.FunctionNumber = 0;
; 197  :     Slot.u.bits.Reserved = 0;
; 198  : 
; 199  :     HalReadPCISpace(m_dwBusNumber, Slot.u.AsULONG, 0x61, &bInterruptLine, sizeof(bInterruptLine));
; 200  : 
; 201  :     //
; 202  :     // Get the device's current PCI config data
; 203  :     //
; 204  : 
; 205  :     Slot.u.bits.FunctionNumber = m_dwFunctionNumber;
; 206  : 
; 207  :     HalReadPCISpace(m_dwBusNumber, Slot.u.AsULONG, 0, &PciConfig, sizeof(PciConfig));
; 208  : 
; 209  :     ASSERT(m_dwVendorId == PciConfig.VendorID);
; 210  :     ASSERT(m_dwDeviceId == PciConfig.DeviceID);
; 211  : 
; 212  :     //
; 213  :     // Assign base addresses and IRQ
; 214  :     //
; 215  : 
; 216  :     DPF_AC97("Using IRQ %x", (DWORD)bInterruptLine);
; 217  : 
; 218  :     PciConfig.Command = 5;
; 219  : 
; 220  :     PciConfig.u.type0.BaseAddresses[0] = m_dwAc97RegisterBase | 1;
; 221  :     PciConfig.u.type0.BaseAddresses[1] = m_dwAciRegisterBase | 1;
; 222  : 
; 223  :     PciConfig.u.type0.InterruptLine = bInterruptLine;
; 224  :     PciConfig.u.type0.InterruptPin = 0;
; 225  : 
; 226  :     HalWritePCISpace(m_dwBusNumber, Slot.u.AsULONG, 0, &PciConfig, sizeof(PciConfig));
; 227  : 
; 228  : #endif // AC97_AMR
; 229  : 
; 230  :     //
; 231  :     // Make sure the CODEC is ready to be powered up
; 232  :     //
; 233  : 
; 234  :     if(!CodecReady())

  00019	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?CodecReady@CAc97Device@DirectSound@@IAEHXZ ; DirectSound::CAc97Device::CodecReady
  00021	85 c0		 test	 eax, eax
  00023	75 07		 jne	 SHORT $L40077

; 235  :     {
; 236  :         DPF_ERROR("CODEC not ready");
; 237  :         hr = DSERR_NODRIVER;

  00025	c7 45 f0 78 00
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005401480 ; 88780078H
$L40077:

; 238  :     }
; 239  :     
; 240  :     //
; 241  :     // Power up the CODEC
; 242  :     //
; 243  : 
; 244  :     if(SUCCEEDED(hr))

  0002c	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00030	7c 0b		 jl	 SHORT $L40083

; 245  :     {
; 246  :         hr = PowerUp();

  00032	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?PowerUp@CAc97Device@DirectSound@@IAEJXZ ; DirectSound::CAc97Device::PowerUp
  0003a	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
$L40083:

; 247  :     }
; 248  : 
; 249  :     //
; 250  :     // Reset all channels
; 251  :     //
; 252  : 
; 253  :     if(SUCCEEDED(hr))

  0003d	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00041	7c 2f		 jl	 SHORT $L40085

; 254  :     {
; 255  :         for(i = 0; i < NUMELMS(CAc97Channel::m_adwRegisterOffsets); i++)

  00043	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004a	eb 09		 jmp	 SHORT $L40086
$L40087:
  0004c	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0004f	83 c2 01	 add	 edx, 1
  00052	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L40086:
  00055	83 7d f8 02	 cmp	 DWORD PTR _i$[ebp], 2
  00059	73 17		 jae	 SHORT $L40085

; 256  :         {
; 257  :             PokeAciRegister8(CAc97Channel::m_adwRegisterOffsets[i] + X_CTRL, X_CTRL_RBMR);

  0005b	6a 02		 push	 2
  0005d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00060	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?m_adwRegisterOffsets@CAc97Channel@DirectSound@@2QBKB[eax*4]
  00067	83 c1 0b	 add	 ecx, 11			; 0000000bH
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ?PokeAciRegister8@CAc97Device@DirectSound@@KGXKE@Z ; DirectSound::CAc97Device::PokeAciRegister8

; 258  :         }

  00070	eb da		 jmp	 SHORT $L40087
$L40085:

; 259  :     }
; 260  : 
; 261  :     //
; 262  :     // Initialize the interrupt DPC
; 263  :     //
; 264  : 
; 265  :     if(SUCCEEDED(hr) && !(m_dwFlags & AC97_OBJECTF_DIRECTISR))

  00072	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00076	7c 23		 jl	 SHORT $L40090
  00078	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0007b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0007e	83 e0 01	 and	 eax, 1
  00081	85 c0		 test	 eax, eax
  00083	75 16		 jne	 SHORT $L40090

; 266  :     {
; 267  :         KeInitializeDpc(&m_dpc, AciInterruptDpcHandler, this);

  00085	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	51		 push	 ecx
  00089	68 00 00 00 00	 push	 OFFSET FLAT:?AciInterruptDpcHandler@CAc97Device@DirectSound@@CGXPAU_KDPC@@PAX11@Z ; DirectSound::CAc97Device::AciInterruptDpcHandler
  0008e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00091	83 c2 1c	 add	 edx, 28			; 0000001cH
  00094	52		 push	 edx
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeDpc@12
$L40090:

; 268  :     }
; 269  : 
; 270  :     //
; 271  :     // Set up the interrupt handler
; 272  :     //
; 273  : 
; 274  :     if(SUCCEEDED(hr))

  0009b	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0009f	7c 48		 jl	 SHORT $L40092

; 275  :     {
; 276  : 
; 277  : #ifdef AC97_AMR
; 278  : 
; 279  :         ulInterruptVector = HalGetInterruptVector(PciConfig.u.type0.InterruptLine, &Irql);
; 280  : 
; 281  : #else // AC97_AMR
; 282  : 
; 283  :         ulInterruptVector = HalGetInterruptVector(XPCICFG_ACI_IRQ, &Irql);

  000a1	8d 45 f7	 lea	 eax, DWORD PTR _Irql$[ebp]
  000a4	50		 push	 eax
  000a5	6a 06		 push	 6
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HalGetInterruptVector@8
  000ad	89 45 fc	 mov	 DWORD PTR _ulInterruptVector$[ebp], eax

; 284  : 
; 285  : #endif // AC97_AMR
; 286  : 
; 287  :         KeInitializeInterrupt(&m_Interrupt, AciInterruptServiceRoutine, this, ulInterruptVector, Irql, LevelSensitive, TRUE);

  000b0	6a 01		 push	 1
  000b2	6a 00		 push	 0
  000b4	8a 4d f7	 mov	 cl, BYTE PTR _Irql$[ebp]
  000b7	51		 push	 ecx
  000b8	8b 55 fc	 mov	 edx, DWORD PTR _ulInterruptVector$[ebp]
  000bb	52		 push	 edx
  000bc	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	50		 push	 eax
  000c0	68 00 00 00 00	 push	 OFFSET FLAT:?AciInterruptServiceRoutine@CAc97Device@DirectSound@@CGEPAU_KINTERRUPT@@PAX@Z ; DirectSound::CAc97Device::AciInterruptServiceRoutine
  000c5	68 00 00 00 00	 push	 OFFSET FLAT:?m_Interrupt@CAc97Device@DirectSound@@1U_KINTERRUPT@@A ; DirectSound::CAc97Device::m_Interrupt
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeInterrupt@28

; 288  : 
; 289  :         if(!KeConnectInterrupt(&m_Interrupt))

  000d0	68 00 00 00 00	 push	 OFFSET FLAT:?m_Interrupt@CAc97Device@DirectSound@@1U_KINTERRUPT@@A ; DirectSound::CAc97Device::m_Interrupt
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeConnectInterrupt@4
  000db	0f b6 c8	 movzx	 ecx, al
  000de	85 c9		 test	 ecx, ecx
  000e0	75 07		 jne	 SHORT $L40092

; 290  :         {
; 291  :             DPF_ERROR("Failed to connect interrupt");
; 292  :             hr = DSERR_GENERIC;

  000e2	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L40092:

; 293  :         }
; 294  :     }
; 295  : 
; 296  :     //
; 297  :     // Unmute the CODEC
; 298  :     //
; 299  : 
; 300  :     if(SUCCEEDED(hr))

  000e9	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ed	7c 14		 jl	 SHORT $L40096

; 301  :     {
; 302  :         if(!PokeAc97Register(AC97REG_FRONT_VOLUME, 0))

  000ef	6a 00		 push	 0
  000f1	6a 01		 push	 1
  000f3	e8 00 00 00 00	 call	 ?PokeAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@G@Z ; DirectSound::CAc97Device::PokeAc97Register
  000f8	85 c0		 test	 eax, eax
  000fa	75 07		 jne	 SHORT $L40096

; 303  :         {
; 304  :             DPF_ERROR("Unable to set front volume");
; 305  :             hr = DSERR_GENERIC;

  000fc	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L40096:

; 306  :         }
; 307  :     }
; 308  : 
; 309  :     if(SUCCEEDED(hr))

  00103	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00107	7c 17		 jl	 SHORT $L40100

; 310  :     {
; 311  :         if(!PokeAc97Register(AC97REG_PCM_OUT_VOLUME, 0x0808))

  00109	68 08 08 00 00	 push	 2056			; 00000808H
  0010e	6a 0c		 push	 12			; 0000000cH
  00110	e8 00 00 00 00	 call	 ?PokeAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@G@Z ; DirectSound::CAc97Device::PokeAc97Register
  00115	85 c0		 test	 eax, eax
  00117	75 07		 jne	 SHORT $L40100

; 312  :         {
; 313  :             DPF_ERROR("Unable to set PCM out volume");
; 314  :             hr = DSERR_GENERIC;

  00119	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L40100:

; 315  :         }
; 316  :     }
; 317  : 
; 318  :     //
; 319  :     // Register for HAL shutdown notification
; 320  :     //
; 321  : 
; 322  :     if(SUCCEEDED(hr))

  00120	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00124	7c 19		 jl	 SHORT $L40104

; 323  :     {
; 324  :         m_HalShutdownData.NotificationRoutine = AciShutdownNotifier;

  00126	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00129	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], OFFSET FLAT:?AciShutdownNotifier@CAc97Device@DirectSound@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z ; DirectSound::CAc97Device::AciShutdownNotifier

; 325  : 
; 326  :         HalRegisterShutdownNotification(&m_HalShutdownData, TRUE);

  00130	6a 01		 push	 1
  00132	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00135	83 c0 0c	 add	 eax, 12			; 0000000cH
  00138	50		 push	 eax
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HalRegisterShutdownNotification@8
$L40104:

; 327  :     }
; 328  : 
; 329  :     DPF_LEAVE_HRESULT(hr);
; 330  : 
; 331  :     return hr;

  0013f	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]

; 332  : }

  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
?Initialize@CAc97Device@DirectSound@@QAEJK@Z ENDP	; DirectSound::CAc97Device::Initialize
DSOUND	ENDS
PUBLIC	?PokeRegister8@CAc97Device@DirectSound@@KGXKE@Z	; DirectSound::CAc97Device::PokeRegister8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.h
;	COMDAT ?PokeAciRegister8@CAc97Device@DirectSound@@KGXKE@Z
DSOUND	SEGMENT
_dwRegister$ = 8
_bValue$ = 12
?PokeAciRegister8@CAc97Device@DirectSound@@KGXKE@Z PROC NEAR ; DirectSound::CAc97Device::PokeAciRegister8, COMDAT

; 267  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 268  :         PokeRegister8(m_dwAciRegisterBase + dwRegister, bValue);

  00003	8a 45 0c	 mov	 al, BYTE PTR _bValue$[ebp]
  00006	50		 push	 eax
  00007	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwAciRegisterBase@CAc97Device@DirectSound@@2KB ; DirectSound::CAc97Device::m_dwAciRegisterBase
  0000d	03 4d 08	 add	 ecx, DWORD PTR _dwRegister$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ?PokeRegister8@CAc97Device@DirectSound@@KGXKE@Z ; DirectSound::CAc97Device::PokeRegister8

; 269  :     }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?PokeAciRegister8@CAc97Device@DirectSound@@KGXKE@Z ENDP	; DirectSound::CAc97Device::PokeAciRegister8
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PokeRegister8@CAc97Device@DirectSound@@KGXKE@Z
DSOUND	SEGMENT
_dwRegister$ = 8
_bValue$ = 12
?PokeRegister8@CAc97Device@DirectSound@@KGXKE@Z PROC NEAR ; DirectSound::CAc97Device::PokeRegister8, COMDAT

; 187  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 188  : 
; 189  :     #ifdef AC97_USE_MIO
; 190  : 
; 191  :         *(LPBYTE)dwRegister = bValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00006	8a 4d 0c	 mov	 cl, BYTE PTR _bValue$[ebp]
  00009	88 08		 mov	 BYTE PTR [eax], cl

; 192  : 
; 193  :     #else // AC97_USE_MIO
; 194  : 
; 195  :         _outp((WORD)dwRegister, bValue);
; 196  : 
; 197  :     #endif // AC97_USE_MIO
; 198  : 
; 199  :     }

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?PokeRegister8@CAc97Device@DirectSound@@KGXKE@Z ENDP	; DirectSound::CAc97Device::PokeRegister8
DSOUND	ENDS
PUBLIC	?ServiceAciInterrupt@CAc97Device@DirectSound@@IAEKXZ ; DirectSound::CAc97Device::ServiceAciInterrupt
; Function compile flags: /Odt
;	COMDAT ?AciInterruptServiceRoutine@CAc97Device@DirectSound@@CGEPAU_KINTERRUPT@@PAX@Z
DSOUND	SEGMENT
_pThis$ = -4
_pInterrupt$ = 8
_pvContext$ = 12
?AciInterruptServiceRoutine@CAc97Device@DirectSound@@CGEPAU_KINTERRUPT@@PAX@Z PROC NEAR ; DirectSound::CAc97Device::AciInterruptServiceRoutine, COMDAT

; 297  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 298  :         CAc97Device *           pThis   = (CAc97Device *)pvContext;

  00004	8b 45 0c	 mov	 eax, DWORD PTR _pvContext$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pThis$[ebp], eax

; 299  :     
; 300  :         return (BOOLEAN)MAKEBOOL(pThis->ServiceAciInterrupt());

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _pThis$[ebp]
  0000d	e8 00 00 00 00	 call	 ?ServiceAciInterrupt@CAc97Device@DirectSound@@IAEKXZ ; DirectSound::CAc97Device::ServiceAciInterrupt
  00012	85 c0		 test	 eax, eax
  00014	0f 95 c0	 setne	 al

; 301  :     }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?AciInterruptServiceRoutine@CAc97Device@DirectSound@@CGEPAU_KINTERRUPT@@PAX@Z ENDP ; DirectSound::CAc97Device::AciInterruptServiceRoutine
DSOUND	ENDS
PUBLIC	?ServiceAciInterruptDpc@CAc97Device@DirectSound@@IAEXXZ ; DirectSound::CAc97Device::ServiceAciInterruptDpc
; Function compile flags: /Odt
;	COMDAT ?AciInterruptDpcHandler@CAc97Device@DirectSound@@CGXPAU_KDPC@@PAX11@Z
DSOUND	SEGMENT
_pThis$ = -4
_pdpc$ = 8
_pvDeferredContext$ = 12
_pvSystemArgument1$ = 16
_pvSystemArgument2$ = 20
?AciInterruptDpcHandler@CAc97Device@DirectSound@@CGXPAU_KDPC@@PAX11@Z PROC NEAR ; DirectSound::CAc97Device::AciInterruptDpcHandler, COMDAT

; 304  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 305  :         CAc97Device *           pThis   = (CAc97Device *)pvDeferredContext;

  00004	8b 45 0c	 mov	 eax, DWORD PTR _pvDeferredContext$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pThis$[ebp], eax

; 306  :     
; 307  :         pThis->ServiceAciInterruptDpc();

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _pThis$[ebp]
  0000d	e8 00 00 00 00	 call	 ?ServiceAciInterruptDpc@CAc97Device@DirectSound@@IAEXXZ ; DirectSound::CAc97Device::ServiceAciInterruptDpc

; 308  :     }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 10 00	 ret	 16			; 00000010H
?AciInterruptDpcHandler@CAc97Device@DirectSound@@CGXPAU_KDPC@@PAX11@Z ENDP ; DirectSound::CAc97Device::AciInterruptDpcHandler
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?AciShutdownNotifier@CAc97Device@DirectSound@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z
DSOUND	SEGMENT
_pThis$ = -4
_pHalShutdownData$ = 8
?AciShutdownNotifier@CAc97Device@DirectSound@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z PROC NEAR ; DirectSound::CAc97Device::AciShutdownNotifier, COMDAT

; 311  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 312  :         CAc97Device *           pThis   = CONTAINING_RECORD(pHalShutdownData, CAc97Device, m_HalShutdownData);

  00004	8b 45 08	 mov	 eax, DWORD PTR _pHalShutdownData$[ebp]
  00007	83 e8 0c	 sub	 eax, 12			; 0000000cH
  0000a	89 45 fc	 mov	 DWORD PTR _pThis$[ebp], eax

; 313  :     
; 314  :         pThis->Terminate();

  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _pThis$[ebp]
  00010	e8 00 00 00 00	 call	 ?Terminate@CAc97Device@DirectSound@@QAEXXZ ; DirectSound::CAc97Device::Terminate

; 315  :     }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?AciShutdownNotifier@CAc97Device@DirectSound@@CGXPAU_HAL_SHUTDOWN_REGISTRATION@@@Z ENDP ; DirectSound::CAc97Device::AciShutdownNotifier
DSOUND	ENDS
PUBLIC	?ReleaseChannel@CAc97Device@DirectSound@@QAEXW4AC97CHANNELTYPE@@@Z ; DirectSound::CAc97Device::ReleaseChannel
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.cpp
;	COMDAT ?Terminate@CAc97Device@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -16
___AutoIrql$ = -12
_i$ = -4
?Terminate@CAc97Device@DirectSound@@QAEXXZ PROC NEAR	; DirectSound::CAc97Device::Terminate, COMDAT
; _this$ = ecx

; 358  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 359  :     DWORD                   i;
; 360  : 
; 361  :     DPF_ENTER();
; 362  :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 363  : 
; 364  :     //
; 365  :     // Disconnect the interrupt handler
; 366  :     //
; 367  : 
; 368  :     if(m_Interrupt.ServiceRoutine)

  00011	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_Interrupt@CAc97Device@DirectSound@@1U_KINTERRUPT@@A, 0
  00018	74 15		 je	 SHORT $L40111

; 369  :     {
; 370  :         KeDisconnectInterrupt(&m_Interrupt);

  0001a	68 00 00 00 00	 push	 OFFSET FLAT:?m_Interrupt@CAc97Device@DirectSound@@1U_KINTERRUPT@@A ; DirectSound::CAc97Device::m_Interrupt
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeDisconnectInterrupt@4

; 371  :         m_Interrupt.ServiceRoutine = NULL;

  00025	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_Interrupt@CAc97Device@DirectSound@@1U_KINTERRUPT@@A, 0
$L40111:

; 372  :     }
; 373  : 
; 374  :     //
; 375  :     // Clear any pending DPCs
; 376  :     //
; 377  : 
; 378  :     if(DpcObject == m_dpc.Type)

  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00032	0f bf 48 1c	 movsx	 ecx, WORD PTR [eax+28]
  00036	83 f9 13	 cmp	 ecx, 19			; 00000013H
  00039	75 1d		 jne	 SHORT $L40112

; 379  :     {
; 380  :         KeRemoveQueueDpc(&m_dpc);

  0003b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	83 c2 1c	 add	 edx, 28			; 0000001cH
  00041	52		 push	 edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeRemoveQueueDpc@4

; 381  :         m_dpc.Type = ~m_dpc.Type;

  00048	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	0f bf 48 1c	 movsx	 ecx, WORD PTR [eax+28]
  0004f	f7 d1		 not	 ecx
  00051	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00054	66 89 4a 1c	 mov	 WORD PTR [edx+28], cx
$L40112:

; 382  :     }
; 383  : 
; 384  :     //
; 385  :     // Unregister the shutdown handler
; 386  :     //
; 387  : 
; 388  :     if(m_HalShutdownData.NotificationRoutine)

  00058	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0005f	74 19		 je	 SHORT $L40113

; 389  :     {
; 390  :         HalRegisterShutdownNotification(&m_HalShutdownData, FALSE);

  00061	6a 00		 push	 0
  00063	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00069	51		 push	 ecx
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HalRegisterShutdownNotification@8

; 391  :         m_HalShutdownData.NotificationRoutine = NULL;

  00070	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00073	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
$L40113:

; 392  :     }
; 393  : 
; 394  :     //
; 395  :     // Free all channels
; 396  :     //
; 397  : 
; 398  :     for(i = 0; i < AC97_CHANNELTYPE_COUNT; i++)

  0007a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00081	eb 09		 jmp	 SHORT $L40114
$L40115:
  00083	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00086	83 c0 01	 add	 eax, 1
  00089	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L40114:
  0008c	83 7d fc 02	 cmp	 DWORD PTR _i$[ebp], 2
  00090	73 0e		 jae	 SHORT $L40116

; 399  :     {
; 400  :         ReleaseChannel((AC97CHANNELTYPE)i);

  00092	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00095	51		 push	 ecx
  00096	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ?ReleaseChannel@CAc97Device@DirectSound@@QAEXW4AC97CHANNELTYPE@@@Z ; DirectSound::CAc97Device::ReleaseChannel

; 401  :     }

  0009e	eb e3		 jmp	 SHORT $L40115
$L40116:

; 402  : 
; 403  :     DPF_LEAVE_VOID();
; 404  : }

  000a0	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000a3	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
?Terminate@CAc97Device@DirectSound@@QAEXXZ ENDP		; DirectSound::CAc97Device::Terminate
DSOUND	ENDS
PUBLIC	??0CAc97Channel@DirectSound@@QAE@PAVCAc97Device@1@W4AC97CHANNELTYPE@@@Z ; DirectSound::CAc97Channel::CAc97Channel
; Function compile flags: /Odt
;	COMDAT ?CreateChannel@CAc97Device@DirectSound@@QAEJW4AC97CHANNELTYPE@@PAPAVCAc97Channel@2@@Z
DSOUND	SEGMENT
tv76 = -28
_this$ = -24
$T42601 = -20
$T42598 = -16
___AutoIrql$ = -12
_hr$ = -4
_nChannelType$ = 8
_ppChannel$ = 12
?CreateChannel@CAc97Device@DirectSound@@QAEJW4AC97CHANNELTYPE@@PAPAVCAc97Channel@2@@Z PROC NEAR ; DirectSound::CAc97Device::CreateChannel, COMDAT
; _this$ = ecx

; 436  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 437  :     HRESULT                 hr;
; 438  :     
; 439  :     DPF_ENTER();
; 440  :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 441  :     
; 442  :     ASSERT(!m_apChannels[nChannelType]);
; 443  : 
; 444  :     hr = HRFROMP(m_apChannels[nChannelType] = NEW(CAc97Channel(this, nChannelType)));

  00011	6a 30		 push	 48			; 00000030H
  00013	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00018	83 c4 04	 add	 esp, 4
  0001b	89 45 f0	 mov	 DWORD PTR $T42598[ebp], eax
  0001e	83 7d f0 00	 cmp	 DWORD PTR $T42598[ebp], 0
  00022	74 15		 je	 SHORT $L42599
  00024	8b 45 08	 mov	 eax, DWORD PTR _nChannelType$[ebp]
  00027	50		 push	 eax
  00028	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR $T42598[ebp]
  0002f	e8 00 00 00 00	 call	 ??0CAc97Channel@DirectSound@@QAE@PAVCAc97Device@1@W4AC97CHANNELTYPE@@@Z ; DirectSound::CAc97Channel::CAc97Channel
  00034	89 45 e4	 mov	 DWORD PTR tv76[ebp], eax
  00037	eb 07		 jmp	 SHORT $L42600
$L42599:
  00039	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$L42600:
  00040	8b 55 08	 mov	 edx, DWORD PTR _nChannelType$[ebp]
  00043	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 4d e4	 mov	 ecx, DWORD PTR tv76[ebp]
  00049	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  0004c	33 d2		 xor	 edx, edx
  0004e	83 7d e4 00	 cmp	 DWORD PTR tv76[ebp], 0
  00052	0f 95 c2	 setne	 dl
  00055	4a		 dec	 edx
  00056	81 e2 0e 00 07
	80		 and	 edx, -2147024882	; 8007000eH
  0005c	89 55 fc	 mov	 DWORD PTR _hr$[ebp], edx

; 445  : 
; 446  :     if(SUCCEEDED(hr) && ppChannel)

  0005f	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00063	7c 14		 jl	 SHORT $L40130
  00065	83 7d 0c 00	 cmp	 DWORD PTR _ppChannel$[ebp], 0
  00069	74 0e		 je	 SHORT $L40130

; 447  :     {
; 448  :         *ppChannel = m_apChannels[nChannelType];

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _ppChannel$[ebp]
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _nChannelType$[ebp]
  00071	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00074	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00077	89 08		 mov	 DWORD PTR [eax], ecx
$L40130:

; 449  :     }
; 450  : 
; 451  :     DPF_LEAVE_HRESULT(hr);
; 452  : 
; 453  :     return hr;

  00079	8b 55 fc	 mov	 edx, DWORD PTR _hr$[ebp]
  0007c	89 55 ec	 mov	 DWORD PTR $T42601[ebp], edx
  0007f	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00082	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00087	8b 45 ec	 mov	 eax, DWORD PTR $T42601[ebp]

; 454  : }

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?CreateChannel@CAc97Device@DirectSound@@QAEJW4AC97CHANNELTYPE@@PAPAVCAc97Channel@2@@Z ENDP ; DirectSound::CAc97Device::CreateChannel
DSOUND	ENDS
PUBLIC	??_GCAc97Channel@DirectSound@@QAEPAXI@Z		; DirectSound::CAc97Channel::`scalar deleting destructor'
; Function compile flags: /Odt
;	COMDAT ?ReleaseChannel@CAc97Device@DirectSound@@QAEXW4AC97CHANNELTYPE@@@Z
DSOUND	SEGMENT
tv76 = -24
_this$ = -20
$T42606 = -16
$T42605 = -12
___AutoIrql$ = -8
_Channel$ = 8
?ReleaseChannel@CAc97Device@DirectSound@@QAEXW4AC97CHANNELTYPE@@@Z PROC NEAR ; DirectSound::CAc97Device::ReleaseChannel, COMDAT
; _this$ = ecx

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 481  :     DPF_ENTER();
; 482  :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 483  :     
; 484  :     DELETE(m_apChannels[Channel]);

  00011	8b 45 08	 mov	 eax, DWORD PTR _Channel$[ebp]
  00014	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  0001b	74 3b		 je	 SHORT $L40137
  0001d	8b 55 08	 mov	 edx, DWORD PTR _Channel$[ebp]
  00020	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00026	89 4d f0	 mov	 DWORD PTR $T42606[ebp], ecx
  00029	8b 55 f0	 mov	 edx, DWORD PTR $T42606[ebp]
  0002c	89 55 f4	 mov	 DWORD PTR $T42605[ebp], edx
  0002f	83 7d f4 00	 cmp	 DWORD PTR $T42605[ebp], 0
  00033	74 0f		 je	 SHORT $L42607
  00035	6a 01		 push	 1
  00037	8b 4d f4	 mov	 ecx, DWORD PTR $T42605[ebp]
  0003a	e8 00 00 00 00	 call	 ??_GCAc97Channel@DirectSound@@QAEPAXI@Z
  0003f	89 45 e8	 mov	 DWORD PTR tv76[ebp], eax
  00042	eb 07		 jmp	 SHORT $L42608
$L42607:
  00044	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$L42608:
  0004b	8b 45 08	 mov	 eax, DWORD PTR _Channel$[ebp]
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0
$L40137:

; 485  : 
; 486  :     DPF_LEAVE_VOID();
; 487  : }

  00058	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0005b	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?ReleaseChannel@CAc97Device@DirectSound@@QAEXW4AC97CHANNELTYPE@@@Z ENDP ; DirectSound::CAc97Device::ReleaseChannel
DSOUND	ENDS
PUBLIC	??1CAc97Channel@DirectSound@@QAE@XZ		; DirectSound::CAc97Channel::~CAc97Channel
; Function compile flags: /Odt
;	COMDAT ??_GCAc97Channel@DirectSound@@QAEPAXI@Z
DSOUND	SEGMENT
_this$ = -4
___flags$ = 8
??_GCAc97Channel@DirectSound@@QAEPAXI@Z PROC NEAR	; DirectSound::CAc97Channel::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CAc97Channel@DirectSound@@QAE@XZ ; DirectSound::CAc97Channel::~CAc97Channel
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L40143
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L40143:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCAc97Channel@DirectSound@@QAEPAXI@Z ENDP		; DirectSound::CAc97Channel::`scalar deleting destructor'
DSOUND	ENDS
PUBLIC	?AcquireCodecSemaphore@CAc97Device@DirectSound@@KGHXZ ; DirectSound::CAc97Device::AcquireCodecSemaphore
PUBLIC	?PeekAciRegister8@CAc97Device@DirectSound@@KGEK@Z ; DirectSound::CAc97Device::PeekAciRegister8
PUBLIC	?WaitRegisterRetry@CAc97Device@DirectSound@@KGXXZ ; DirectSound::CAc97Device::WaitRegisterRetry
; Function compile flags: /Odt
;	COMDAT ?AcquireCodecSemaphore@CAc97Device@DirectSound@@KGHXZ
DSOUND	SEGMENT
_fAcquired$ = -8
_dwAttempts$ = -4
?AcquireCodecSemaphore@CAc97Device@DirectSound@@KGHXZ PROC NEAR ; DirectSound::CAc97Device::AcquireCodecSemaphore, COMDAT

; 513  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 514  :     DWORD                   dwAttempts  = 1000;

  00006	c7 45 fc e8 03
	00 00		 mov	 DWORD PTR _dwAttempts$[ebp], 1000 ; 000003e8H

; 515  :     BOOL                    fAcquired   = TRUE;

  0000d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fAcquired$[ebp], 1
$L40150:

; 516  : 
; 517  :     DPF_ENTER();
; 518  : 
; 519  :     while(PeekAciRegister8(AC97_SEM4) & AC97_SEM4_OWNED)

  00014	6a 34		 push	 52			; 00000034H
  00016	e8 00 00 00 00	 call	 ?PeekAciRegister8@CAc97Device@DirectSound@@KGEK@Z ; DirectSound::CAc97Device::PeekAciRegister8
  0001b	0f b6 c0	 movzx	 eax, al
  0001e	83 e0 01	 and	 eax, 1
  00021	85 c0		 test	 eax, eax
  00023	74 20		 je	 SHORT $L40151

; 520  :     {
; 521  :         if(!dwAttempts--)

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _dwAttempts$[ebp]
  00028	8b 55 fc	 mov	 edx, DWORD PTR _dwAttempts$[ebp]
  0002b	83 ea 01	 sub	 edx, 1
  0002e	89 55 fc	 mov	 DWORD PTR _dwAttempts$[ebp], edx
  00031	85 c9		 test	 ecx, ecx
  00033	75 09		 jne	 SHORT $L40152

; 522  :         {
; 523  :             DPF_ERROR("Failed to get CODEC semaphore");
; 524  :             fAcquired = FALSE;

  00035	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fAcquired$[ebp], 0

; 525  :             break;

  0003c	eb 07		 jmp	 SHORT $L40151
$L40152:

; 526  :         }
; 527  : 
; 528  :         WaitRegisterRetry();

  0003e	e8 00 00 00 00	 call	 ?WaitRegisterRetry@CAc97Device@DirectSound@@KGXXZ ; DirectSound::CAc97Device::WaitRegisterRetry

; 529  :     }

  00043	eb cf		 jmp	 SHORT $L40150
$L40151:

; 530  : 
; 531  :     DPF_LEAVE(fAcquired);
; 532  : 
; 533  :     return fAcquired;

  00045	8b 45 f8	 mov	 eax, DWORD PTR _fAcquired$[ebp]

; 534  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?AcquireCodecSemaphore@CAc97Device@DirectSound@@KGHXZ ENDP ; DirectSound::CAc97Device::AcquireCodecSemaphore
DSOUND	ENDS
PUBLIC	?PeekRegister8@CAc97Device@DirectSound@@KGEK@Z	; DirectSound::CAc97Device::PeekRegister8
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.h
;	COMDAT ?PeekAciRegister8@CAc97Device@DirectSound@@KGEK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
?PeekAciRegister8@CAc97Device@DirectSound@@KGEK@Z PROC NEAR ; DirectSound::CAc97Device::PeekAciRegister8, COMDAT

; 262  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 263  :         return PeekRegister8(m_dwAciRegisterBase + dwRegister);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwAciRegisterBase@CAc97Device@DirectSound@@2KB ; DirectSound::CAc97Device::m_dwAciRegisterBase
  00008	03 45 08	 add	 eax, DWORD PTR _dwRegister$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PeekRegister8@CAc97Device@DirectSound@@KGEK@Z ; DirectSound::CAc97Device::PeekRegister8

; 264  :     }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?PeekAciRegister8@CAc97Device@DirectSound@@KGEK@Z ENDP	; DirectSound::CAc97Device::PeekAciRegister8
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PeekRegister8@CAc97Device@DirectSound@@KGEK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
?PeekRegister8@CAc97Device@DirectSound@@KGEK@Z PROC NEAR ; DirectSound::CAc97Device::PeekRegister8, COMDAT

; 172  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 173  : 
; 174  :     #ifdef AC97_USE_MIO
; 175  : 
; 176  :         return *(LPBYTE)dwRegister;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00006	8a 00		 mov	 al, BYTE PTR [eax]

; 177  : 
; 178  :     #else // AC97_USE_MIO
; 179  : 
; 180  :         return (BYTE)_inp((WORD)dwRegister);
; 181  : 
; 182  :     #endif // AC97_USE_MIO
; 183  : 
; 184  :     }    

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?PeekRegister8@CAc97Device@DirectSound@@KGEK@Z ENDP	; DirectSound::CAc97Device::PeekRegister8
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?WaitRegisterRetry@CAc97Device@DirectSound@@KGXXZ
DSOUND	SEGMENT
?WaitRegisterRetry@CAc97Device@DirectSound@@KGXXZ PROC NEAR ; DirectSound::CAc97Device::WaitRegisterRetry, COMDAT

; 292  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  :         KeStallExecutionProcessor(20);

  00003	6a 14		 push	 20			; 00000014H
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeStallExecutionProcessor@4

; 294  :     }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?WaitRegisterRetry@CAc97Device@DirectSound@@KGXXZ ENDP	; DirectSound::CAc97Device::WaitRegisterRetry
DSOUND	ENDS
PUBLIC	?PeekAciRegister32@CAc97Device@DirectSound@@KGKK@Z ; DirectSound::CAc97Device::PeekAciRegister32
PUBLIC	?PokeAciRegister32@CAc97Device@DirectSound@@KGXKK@Z ; DirectSound::CAc97Device::PokeAciRegister32
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.cpp
;	COMDAT ?CodecReady@CAc97Device@DirectSound@@IAEHXZ
DSOUND	SEGMENT
_this$ = -16
_fReady$ = -12
_dwValue$ = -8
_dwAttempts$ = -4
?CodecReady@CAc97Device@DirectSound@@IAEHXZ PROC NEAR	; DirectSound::CAc97Device::CodecReady, COMDAT
; _this$ = ecx

; 560  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 561  :     BOOL                    fReady      = TRUE;

  00009	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _fReady$[ebp], 1

; 562  :     DWORD                   dwAttempts  = 1000;

  00010	c7 45 fc e8 03
	00 00		 mov	 DWORD PTR _dwAttempts$[ebp], 1000 ; 000003e8H

; 563  :     DWORD                   dwValue;
; 564  :     
; 565  :     DPF_ENTER();
; 566  : 
; 567  :     //
; 568  :     // Get the value of the control register.
; 569  :     //
; 570  : 
; 571  :     dwValue = PeekAciRegister32(GLB_CTRL);

  00017	6a 2c		 push	 44			; 0000002cH
  00019	e8 00 00 00 00	 call	 ?PeekAciRegister32@CAc97Device@DirectSound@@KGKK@Z ; DirectSound::CAc97Device::PeekAciRegister32
  0001e	89 45 f8	 mov	 DWORD PTR _dwValue$[ebp], eax

; 572  :     
; 573  :     //
; 574  :     // If the AC_RST# line is low, raise it and do a cold reset.
; 575  :     //
; 576  : 
; 577  :     if(!(dwValue & GLB_CTRL_COLD))

  00021	8b 45 f8	 mov	 eax, DWORD PTR _dwValue$[ebp]
  00024	83 e0 02	 and	 eax, 2
  00027	85 c0		 test	 eax, eax
  00029	75 14		 jne	 SHORT $L40160

; 578  :     {
; 579  :         DPF_AC97("Performing cold reset");
; 580  :         
; 581  :         dwValue |= GLB_CTRL_COLD;

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _dwValue$[ebp]
  0002e	83 c9 02	 or	 ecx, 2
  00031	89 4d f8	 mov	 DWORD PTR _dwValue$[ebp], ecx

; 582  : 
; 583  :         PokeAciRegister32(GLB_CTRL, dwValue);

  00034	8b 55 f8	 mov	 edx, DWORD PTR _dwValue$[ebp]
  00037	52		 push	 edx
  00038	6a 2c		 push	 44			; 0000002cH
  0003a	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Device@DirectSound@@KGXKK@Z ; DirectSound::CAc97Device::PokeAciRegister32
$L40160:

; 584  :     }
; 585  : 
; 586  :     //
; 587  :     // If the AC link is down, raise it and do a warm reset.  This is only
; 588  :     // needed if agressive power management is used.
; 589  :     //
; 590  : 
; 591  :     if(dwValue & GLB_CTRL_ACSD)

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _dwValue$[ebp]
  00042	83 e0 08	 and	 eax, 8
  00045	85 c0		 test	 eax, eax
  00047	74 14		 je	 SHORT $L40163

; 592  :     {
; 593  :         DPF_AC97("Performing warm reset");
; 594  :         
; 595  :         dwValue &= ~(GLB_CTRL_ACSD | GLB_CTRL_WARM);

  00049	8b 4d f8	 mov	 ecx, DWORD PTR _dwValue$[ebp]
  0004c	83 e1 f3	 and	 ecx, -13		; fffffff3H
  0004f	89 4d f8	 mov	 DWORD PTR _dwValue$[ebp], ecx

; 596  : 
; 597  :         PokeAciRegister32(GLB_CTRL, dwValue);

  00052	8b 55 f8	 mov	 edx, DWORD PTR _dwValue$[ebp]
  00055	52		 push	 edx
  00056	6a 2c		 push	 44			; 0000002cH
  00058	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Device@DirectSound@@KGXKK@Z ; DirectSound::CAc97Device::PokeAciRegister32
$L40163:

; 598  :     }
; 599  : 
; 600  :     //
; 601  :     // Check to see if the ready bit is set.  This takes a maximum of 200us.
; 602  :     //
; 603  : 
; 604  :     while(!(PeekAciRegister32(GLB_STATUS) & GLB_STATUS_PCR))

  0005d	6a 30		 push	 48			; 00000030H
  0005f	e8 00 00 00 00	 call	 ?PeekAciRegister32@CAc97Device@DirectSound@@KGKK@Z ; DirectSound::CAc97Device::PeekAciRegister32
  00064	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00069	85 c0		 test	 eax, eax
  0006b	75 20		 jne	 SHORT $L40166

; 605  :     {
; 606  :         if(!dwAttempts--)

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _dwAttempts$[ebp]
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _dwAttempts$[ebp]
  00073	83 e9 01	 sub	 ecx, 1
  00076	89 4d fc	 mov	 DWORD PTR _dwAttempts$[ebp], ecx
  00079	85 c0		 test	 eax, eax
  0007b	75 09		 jne	 SHORT $L40165

; 607  :         {
; 608  :             DPF_ERROR("Timed out waiting for ready bit");
; 609  :             fReady = FALSE;

  0007d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fReady$[ebp], 0

; 610  :             break;

  00084	eb 07		 jmp	 SHORT $L40166
$L40165:

; 611  :         }
; 612  : 
; 613  :         WaitRegisterRetry();

  00086	e8 00 00 00 00	 call	 ?WaitRegisterRetry@CAc97Device@DirectSound@@KGXXZ ; DirectSound::CAc97Device::WaitRegisterRetry

; 614  :     }

  0008b	eb d0		 jmp	 SHORT $L40163
$L40166:

; 615  : 
; 616  :     if(fReady)
; 617  :     {
; 618  :         DPF_AC97("CODEC ready");
; 619  :     }
; 620  : 
; 621  :     DPF_LEAVE(fReady);
; 622  : 
; 623  :     return fReady;

  0008d	8b 45 f4	 mov	 eax, DWORD PTR _fReady$[ebp]

; 624  : }

  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?CodecReady@CAc97Device@DirectSound@@IAEHXZ ENDP	; DirectSound::CAc97Device::CodecReady
DSOUND	ENDS
PUBLIC	?PeekRegister32@CAc97Device@DirectSound@@KGKK@Z	; DirectSound::CAc97Device::PeekRegister32
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.h
;	COMDAT ?PeekAciRegister32@CAc97Device@DirectSound@@KGKK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
?PeekAciRegister32@CAc97Device@DirectSound@@KGKK@Z PROC NEAR ; DirectSound::CAc97Device::PeekAciRegister32, COMDAT

; 282  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 283  :         return PeekRegister32(m_dwAciRegisterBase + dwRegister);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwAciRegisterBase@CAc97Device@DirectSound@@2KB ; DirectSound::CAc97Device::m_dwAciRegisterBase
  00008	03 45 08	 add	 eax, DWORD PTR _dwRegister$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PeekRegister32@CAc97Device@DirectSound@@KGKK@Z ; DirectSound::CAc97Device::PeekRegister32

; 284  :     }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?PeekAciRegister32@CAc97Device@DirectSound@@KGKK@Z ENDP	; DirectSound::CAc97Device::PeekAciRegister32
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PeekRegister32@CAc97Device@DirectSound@@KGKK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
?PeekRegister32@CAc97Device@DirectSound@@KGKK@Z PROC NEAR ; DirectSound::CAc97Device::PeekRegister32, COMDAT

; 232  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 233  : 
; 234  :     #ifdef AC97_USE_MIO
; 235  : 
; 236  :         return *(LPDWORD)dwRegister;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 237  : 
; 238  :     #else // AC97_USE_MIO
; 239  : 
; 240  :         return _inpd((WORD)dwRegister);
; 241  : 
; 242  :     #endif // AC97_USE_MIO
; 243  : 
; 244  :     }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?PeekRegister32@CAc97Device@DirectSound@@KGKK@Z ENDP	; DirectSound::CAc97Device::PeekRegister32
DSOUND	ENDS
PUBLIC	?PokeRegister32@CAc97Device@DirectSound@@KGXKK@Z ; DirectSound::CAc97Device::PokeRegister32
; Function compile flags: /Odt
;	COMDAT ?PokeAciRegister32@CAc97Device@DirectSound@@KGXKK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
_dwValue$ = 12
?PokeAciRegister32@CAc97Device@DirectSound@@KGXKK@Z PROC NEAR ; DirectSound::CAc97Device::PokeAciRegister32, COMDAT

; 287  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 288  :         PokeRegister32(m_dwAciRegisterBase + dwRegister, dwValue);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _dwValue$[ebp]
  00006	50		 push	 eax
  00007	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwAciRegisterBase@CAc97Device@DirectSound@@2KB ; DirectSound::CAc97Device::m_dwAciRegisterBase
  0000d	03 4d 08	 add	 ecx, DWORD PTR _dwRegister$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ?PokeRegister32@CAc97Device@DirectSound@@KGXKK@Z ; DirectSound::CAc97Device::PokeRegister32

; 289  :     }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?PokeAciRegister32@CAc97Device@DirectSound@@KGXKK@Z ENDP ; DirectSound::CAc97Device::PokeAciRegister32
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PokeRegister32@CAc97Device@DirectSound@@KGXKK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
_dwValue$ = 12
?PokeRegister32@CAc97Device@DirectSound@@KGXKK@Z PROC NEAR ; DirectSound::CAc97Device::PokeRegister32, COMDAT

; 247  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 248  : 
; 249  :     #ifdef AC97_USE_MIO
; 250  : 
; 251  :         *(LPDWORD)dwRegister = dwValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _dwValue$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 252  : 
; 253  :     #else // AC97_USE_MIO
; 254  : 
; 255  :         _outpd((WORD)dwRegister, dwValue);
; 256  : 
; 257  :     #endif // AC97_USE_MIO
; 258  : 
; 259  :     }

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?PokeRegister32@CAc97Device@DirectSound@@KGXKK@Z ENDP	; DirectSound::CAc97Device::PokeRegister32
DSOUND	ENDS
PUBLIC	?GetInterruptStatus@CAc97Device@DirectSound@@IAEKXZ ; DirectSound::CAc97Device::GetInterruptStatus
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.cpp
;	COMDAT ?GetInterruptStatus@CAc97Device@DirectSound@@IAEKXZ
DSOUND	SEGMENT
_this$ = -4
?GetInterruptStatus@CAc97Device@DirectSound@@IAEKXZ PROC NEAR ; DirectSound::CAc97Device::GetInterruptStatus, COMDAT
; _this$ = ecx

; 650  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 651  :     static const DWORD      dwStatusMask    = GLB_STATUS_AOINT | GLB_STATUS_SOINT | GLB_STATUS_GPINT;
; 652  : 
; 653  :     return PeekAciRegister32(GLB_STATUS) & dwStatusMask;

  00007	6a 30		 push	 48			; 00000030H
  00009	e8 00 00 00 00	 call	 ?PeekAciRegister32@CAc97Device@DirectSound@@KGKK@Z ; DirectSound::CAc97Device::PeekAciRegister32
  0000e	83 e0 51	 and	 eax, 81			; 00000051H

; 654  : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?GetInterruptStatus@CAc97Device@DirectSound@@IAEKXZ ENDP ; DirectSound::CAc97Device::GetInterruptStatus
DSOUND	ENDS
PUBLIC	?ServiceInterrupt@CAc97Channel@DirectSound@@IAEXXZ ; DirectSound::CAc97Channel::ServiceInterrupt
PUBLIC	?PeekAciRegister16@CAc97Channel@DirectSound@@IAEGK@Z ; DirectSound::CAc97Channel::PeekAciRegister16
PUBLIC	?PokeAciRegister16@CAc97Channel@DirectSound@@IAEXKG@Z ; DirectSound::CAc97Channel::PokeAciRegister16
;	COMDAT ?adwChannelStatusMasks@?1??ServiceAciInterrupt@CAc97Device@DirectSound@@IAEKXZ@4QBKB
DSOUND_RD	SEGMENT
?adwChannelStatusMasks@?1??ServiceAciInterrupt@CAc97Device@DirectSound@@IAEKXZ@4QBKB DD 040H ; `DirectSound::CAc97Device::ServiceAciInterrupt'::`2'::adwChannelStatusMasks
	DD	010H
; Function compile flags: /Odt
DSOUND_RD	ENDS
;	COMDAT ?ServiceAciInterrupt@CAc97Device@DirectSound@@IAEKXZ
DSOUND	SEGMENT
_this$ = -20
_dwStatus$ = -16
_wChannelStatus$ = -12
_dwInterruptMask$ = -8
_i$ = -4
?ServiceAciInterrupt@CAc97Device@DirectSound@@IAEKXZ PROC NEAR ; DirectSound::CAc97Device::ServiceAciInterrupt, COMDAT
; _this$ = ecx

; 680  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 681  :     static const DWORD      adwChannelStatusMasks[AC97_CHANNELTYPE_COUNT] = 
; 682  :     { 
; 683  :         GLB_STATUS_AOINT, 
; 684  :         GLB_STATUS_SOINT,
; 685  :     };
; 686  : 
; 687  :     DWORD                   dwInterruptMask;
; 688  :     DWORD                   dwStatus;
; 689  :     WORD                    wChannelStatus;
; 690  :     DWORD                   i;
; 691  : 
; 692  :     DPF_ENTER();
; 693  : 
; 694  :     //
; 695  :     // Get the ACI interrupt status bits
; 696  :     //
; 697  : 
; 698  :     if(dwStatus = GetInterruptStatus())

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetInterruptStatus@CAc97Device@DirectSound@@IAEKXZ ; DirectSound::CAc97Device::GetInterruptStatus
  00011	89 45 f0	 mov	 DWORD PTR _dwStatus$[ebp], eax
  00014	83 7d f0 00	 cmp	 DWORD PTR _dwStatus$[ebp], 0
  00018	0f 84 fb 00 00
	00		 je	 $L40183

; 699  :     {
; 700  :         //
; 701  :         // Set the interrupt mask to a non-zero value that won't conflict
; 702  :         // with any of the channel-specific values.
; 703  :         //
; 704  :         
; 705  :         dwInterruptMask = 0x80000000;

  0001e	c7 45 f8 00 00
	00 80		 mov	 DWORD PTR _dwInterruptMask$[ebp], -2147483648 ; 80000000H

; 706  : 
; 707  :         //
; 708  :         // Handle channel interrupts
; 709  :         //
; 710  :         
; 711  :         for(i = 0; i < AC97_CHANNELTYPE_COUNT; i++)

  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002c	eb 09		 jmp	 SHORT $L40184
$L40185:
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00031	83 c0 01	 add	 eax, 1
  00034	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L40184:
  00037	83 7d fc 02	 cmp	 DWORD PTR _i$[ebp], 2
  0003b	0f 83 a0 00 00
	00		 jae	 $L40186

; 712  :         {
; 713  :             if(dwStatus & adwChannelStatusMasks[i])

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00044	8b 55 f0	 mov	 edx, DWORD PTR _dwStatus$[ebp]
  00047	23 14 8d 00 00
	00 00		 and	 edx, DWORD PTR ?adwChannelStatusMasks@?1??ServiceAciInterrupt@CAc97Device@DirectSound@@IAEKXZ@4QBKB[ecx*4]
  0004e	85 d2		 test	 edx, edx
  00050	0f 84 86 00 00
	00		 je	 $L40187

; 714  :             {
; 715  :                 if(m_apChannels[i])

  00056	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00060	74 7a		 je	 SHORT $L40187

; 716  :                 {
; 717  :                     //
; 718  :                     // Ok, this channel had an interrupt.  The only ones we
; 719  :                     // really care about are buffer completion interrupts.
; 720  :                     // If either of those are set in the channel status 
; 721  :                     // registers, increment the channel's count of pending
; 722  :                     // completions and schedule a DPC to handle them.
; 723  :                     //
; 724  : 
; 725  :                     wChannelStatus = m_apChannels[i]->PeekAciRegister16(X_STATUS);

  00062	6a 06		 push	 6
  00064	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  0006d	e8 00 00 00 00	 call	 ?PeekAciRegister16@CAc97Channel@DirectSound@@IAEGK@Z ; DirectSound::CAc97Channel::PeekAciRegister16
  00072	66 89 45 f4	 mov	 WORD PTR _wChannelStatus$[ebp], ax

; 726  : 
; 727  :                     if(wChannelStatus & X_STATUS_FIFOE) 
; 728  :                     {
; 729  :                         DPF_AC97("(channel %lu) FIFO underrun", i);
; 730  :                     }
; 731  : 
; 732  :                     if(wChannelStatus & X_STATUS_CIELV)
; 733  :                     {
; 734  :                         DPF_AC97("(channel %lu) Current index equals last valid", i);
; 735  :                     }
; 736  : 
; 737  :                     if(wChannelStatus & X_STATUS_LVBCI)
; 738  :                     {
; 739  :                         DPF_AC97("(channel %lu) Last valid buffer completion interrupt", i);
; 740  :                     }
; 741  :                 
; 742  :                     if(wChannelStatus & X_STATUS_BCI)

  00076	0f b7 4d f4	 movzx	 ecx, WORD PTR _wChannelStatus$[ebp]
  0007a	83 e1 08	 and	 ecx, 8
  0007d	85 c9		 test	 ecx, ecx
  0007f	74 46		 je	 SHORT $L40192

; 743  :                     {
; 744  :                         DPF_AC97("(channel %lu) Buffer completed", i);
; 745  : 
; 746  :                         dwInterruptMask |= AC97_CHANNELINTERRUPT(i);

  00081	ba 01 00 00 00	 mov	 edx, 1
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00089	d3 e2		 shl	 edx, cl
  0008b	8b 45 f8	 mov	 eax, DWORD PTR _dwInterruptMask$[ebp]
  0008e	0b c2		 or	 eax, edx
  00090	89 45 f8	 mov	 DWORD PTR _dwInterruptMask$[ebp], eax

; 747  : 
; 748  :                         if(m_dwFlags & AC97_OBJECTF_DIRECTISR)

  00093	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00099	83 e2 01	 and	 edx, 1
  0009c	85 d2		 test	 edx, edx
  0009e	74 10		 je	 SHORT $L40193

; 749  :                         {
; 750  :                             m_apChannels[i]->ServiceInterrupt();

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000a3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  000a9	e8 00 00 00 00	 call	 ?ServiceInterrupt@CAc97Channel@DirectSound@@IAEXXZ ; DirectSound::CAc97Channel::ServiceInterrupt

; 751  :                         }
; 752  :                         else

  000ae	eb 17		 jmp	 SHORT $L40192
$L40193:

; 753  :                         {
; 754  :                             m_abPendingBufferCompletions[i][0]++;

  000b0	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000b3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	8a 4c 50 38	 mov	 cl, BYTE PTR [eax+edx*2+56]
  000ba	80 c1 01	 add	 cl, 1
  000bd	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000c0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	88 4c 50 38	 mov	 BYTE PTR [eax+edx*2+56], cl
$L40192:

; 755  :                         }
; 756  :                     }
; 757  : 
; 758  :                     m_apChannels[i]->PokeAciRegister16(X_STATUS, wChannelStatus);

  000c7	66 8b 4d f4	 mov	 cx, WORD PTR _wChannelStatus$[ebp]
  000cb	51		 push	 ecx
  000cc	6a 06		 push	 6
  000ce	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  000d7	e8 00 00 00 00	 call	 ?PokeAciRegister16@CAc97Channel@DirectSound@@IAEXKG@Z ; DirectSound::CAc97Channel::PokeAciRegister16
$L40187:

; 759  :                 }
; 760  :                 else
; 761  :                 {
; 762  :                     DPF_WARNING("Channel %lu not allocated!", i);
; 763  :                 }
; 764  :             }
; 765  :         }

  000dc	e9 4d ff ff ff	 jmp	 $L40185
$L40186:

; 766  :     
; 767  :         //
; 768  :         // Schedule a DPC to handle any buffer completion interrupts
; 769  :         //
; 770  : 
; 771  :         if(!(m_dwFlags & AC97_OBJECTF_DIRECTISR) && (dwInterruptMask & AC97_CHANNELINTERRUPT_MASK))

  000e1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000e7	83 e2 01	 and	 edx, 1
  000ea	85 d2		 test	 edx, edx
  000ec	75 1b		 jne	 SHORT $L40196
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _dwInterruptMask$[ebp]
  000f1	83 e0 03	 and	 eax, 3
  000f4	85 c0		 test	 eax, eax
  000f6	74 11		 je	 SHORT $L40196

; 772  :         {
; 773  :             KeInsertQueueDpc(&m_dpc, NULL, NULL);

  000f8	6a 00		 push	 0
  000fa	6a 00		 push	 0
  000fc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00102	51		 push	 ecx
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInsertQueueDpc@12
$L40196:

; 774  :         }
; 775  : 
; 776  :         //
; 777  :         // Acknowlege the interrupt
; 778  :         //
; 779  :         
; 780  :         PokeAciRegister32(GLB_STATUS, dwStatus & ~GLB_STATUS_GPINT);

  00109	8b 55 f0	 mov	 edx, DWORD PTR _dwStatus$[ebp]
  0010c	83 e2 fe	 and	 edx, -2			; fffffffeH
  0010f	52		 push	 edx
  00110	6a 30		 push	 48			; 00000030H
  00112	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Device@DirectSound@@KGXKK@Z ; DirectSound::CAc97Device::PokeAciRegister32

; 781  :     }
; 782  :     else

  00117	eb 07		 jmp	 SHORT $L40197
$L40183:

; 783  :     {
; 784  :         //
; 785  :         // Not our interrupt
; 786  :         //
; 787  : 
; 788  :         dwInterruptMask = 0;

  00119	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwInterruptMask$[ebp], 0
$L40197:

; 789  :     }
; 790  : 
; 791  :     DPF_LEAVE(dwInterruptMask);
; 792  : 
; 793  :     return dwInterruptMask;

  00120	8b 45 f8	 mov	 eax, DWORD PTR _dwInterruptMask$[ebp]

; 794  : }

  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
?ServiceAciInterrupt@CAc97Device@DirectSound@@IAEKXZ ENDP ; DirectSound::CAc97Device::ServiceAciInterrupt
DSOUND	ENDS
PUBLIC	?PeekAciRegister16@CAc97Device@DirectSound@@KGGK@Z ; DirectSound::CAc97Device::PeekAciRegister16
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.h
;	COMDAT ?PeekAciRegister16@CAc97Channel@DirectSound@@IAEGK@Z
DSOUND	SEGMENT
_this$ = -4
_dwRegister$ = 8
?PeekAciRegister16@CAc97Channel@DirectSound@@IAEGK@Z PROC NEAR ; DirectSound::CAc97Channel::PeekAciRegister16, COMDAT
; _this$ = ecx

; 445  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 446  :         return m_pDevice->PeekAciRegister16(dwRegister + m_adwRegisterOffsets[m_nChannelType]);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 55 08	 mov	 edx, DWORD PTR _dwRegister$[ebp]
  0000f	03 14 8d 00 00
	00 00		 add	 edx, DWORD PTR ?m_adwRegisterOffsets@CAc97Channel@DirectSound@@2QBKB[ecx*4]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 ?PeekAciRegister16@CAc97Device@DirectSound@@KGGK@Z ; DirectSound::CAc97Device::PeekAciRegister16

; 447  :     }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?PeekAciRegister16@CAc97Channel@DirectSound@@IAEGK@Z ENDP ; DirectSound::CAc97Channel::PeekAciRegister16
DSOUND	ENDS
PUBLIC	?PeekRegister16@CAc97Device@DirectSound@@KGGK@Z	; DirectSound::CAc97Device::PeekRegister16
; Function compile flags: /Odt
;	COMDAT ?PeekAciRegister16@CAc97Device@DirectSound@@KGGK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
?PeekAciRegister16@CAc97Device@DirectSound@@KGGK@Z PROC NEAR ; DirectSound::CAc97Device::PeekAciRegister16, COMDAT

; 272  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 273  :         return PeekRegister16(m_dwAciRegisterBase + dwRegister);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwAciRegisterBase@CAc97Device@DirectSound@@2KB ; DirectSound::CAc97Device::m_dwAciRegisterBase
  00008	03 45 08	 add	 eax, DWORD PTR _dwRegister$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PeekRegister16@CAc97Device@DirectSound@@KGGK@Z ; DirectSound::CAc97Device::PeekRegister16

; 274  :     }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?PeekAciRegister16@CAc97Device@DirectSound@@KGGK@Z ENDP	; DirectSound::CAc97Device::PeekAciRegister16
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PeekRegister16@CAc97Device@DirectSound@@KGGK@Z
DSOUND	SEGMENT
_dwRegister$ = 8
?PeekRegister16@CAc97Device@DirectSound@@KGGK@Z PROC NEAR ; DirectSound::CAc97Device::PeekRegister16, COMDAT

; 202  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 203  : 
; 204  :     #ifdef AC97_USE_MIO
; 205  : 
; 206  :         return *(LPWORD)dwRegister;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00006	66 8b 00	 mov	 ax, WORD PTR [eax]

; 207  : 
; 208  :     #else // AC97_USE_MIO
; 209  : 
; 210  :         return _inpw((WORD)dwRegister);
; 211  : 
; 212  :     #endif // AC97_USE_MIO
; 213  : 
; 214  :     }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?PeekRegister16@CAc97Device@DirectSound@@KGGK@Z ENDP	; DirectSound::CAc97Device::PeekRegister16
DSOUND	ENDS
PUBLIC	?PokeAciRegister16@CAc97Device@DirectSound@@KGXKG@Z ; DirectSound::CAc97Device::PokeAciRegister16
; Function compile flags: /Odt
;	COMDAT ?PokeAciRegister16@CAc97Channel@DirectSound@@IAEXKG@Z
DSOUND	SEGMENT
_this$ = -4
_dwRegister$ = 8
_wValue$ = 12
?PokeAciRegister16@CAc97Channel@DirectSound@@IAEXKG@Z PROC NEAR ; DirectSound::CAc97Channel::PokeAciRegister16, COMDAT
; _this$ = ecx

; 450  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 451  :         m_pDevice->PokeAciRegister16(dwRegister + m_adwRegisterOffsets[m_nChannelType], wValue);

  00007	66 8b 45 0c	 mov	 ax, WORD PTR _wValue$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00014	03 04 95 00 00
	00 00		 add	 eax, DWORD PTR ?m_adwRegisterOffsets@CAc97Channel@DirectSound@@2QBKB[edx*4]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PokeAciRegister16@CAc97Device@DirectSound@@KGXKG@Z ; DirectSound::CAc97Device::PokeAciRegister16

; 452  :     }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?PokeAciRegister16@CAc97Channel@DirectSound@@IAEXKG@Z ENDP ; DirectSound::CAc97Channel::PokeAciRegister16
DSOUND	ENDS
PUBLIC	?PokeRegister16@CAc97Device@DirectSound@@KGXKG@Z ; DirectSound::CAc97Device::PokeRegister16
; Function compile flags: /Odt
;	COMDAT ?PokeAciRegister16@CAc97Device@DirectSound@@KGXKG@Z
DSOUND	SEGMENT
_dwRegister$ = 8
_wValue$ = 12
?PokeAciRegister16@CAc97Device@DirectSound@@KGXKG@Z PROC NEAR ; DirectSound::CAc97Device::PokeAciRegister16, COMDAT

; 277  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 278  :         PokeRegister16(m_dwAciRegisterBase + dwRegister, wValue);

  00003	66 8b 45 0c	 mov	 ax, WORD PTR _wValue$[ebp]
  00007	50		 push	 eax
  00008	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwAciRegisterBase@CAc97Device@DirectSound@@2KB ; DirectSound::CAc97Device::m_dwAciRegisterBase
  0000e	03 4d 08	 add	 ecx, DWORD PTR _dwRegister$[ebp]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?PokeRegister16@CAc97Device@DirectSound@@KGXKG@Z ; DirectSound::CAc97Device::PokeRegister16

; 279  :     }

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?PokeAciRegister16@CAc97Device@DirectSound@@KGXKG@Z ENDP ; DirectSound::CAc97Device::PokeAciRegister16
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PokeRegister16@CAc97Device@DirectSound@@KGXKG@Z
DSOUND	SEGMENT
_dwRegister$ = 8
_wValue$ = 12
?PokeRegister16@CAc97Device@DirectSound@@KGXKG@Z PROC NEAR ; DirectSound::CAc97Device::PokeRegister16, COMDAT

; 217  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 218  : 
; 219  :     #ifdef AC97_USE_MIO
; 220  : 
; 221  :         *(LPWORD)dwRegister = wValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00006	66 8b 4d 0c	 mov	 cx, WORD PTR _wValue$[ebp]
  0000a	66 89 08	 mov	 WORD PTR [eax], cx

; 222  : 
; 223  :     #else // AC97_USE_MIO
; 224  : 
; 225  :         _outpw((WORD)dwRegister, wValue);
; 226  : 
; 227  :     #endif // AC97_USE_MIO
; 228  : 
; 229  :     }

  0000d	5d		 pop	 ebp
  0000e	c2 08 00	 ret	 8
?PokeRegister16@CAc97Device@DirectSound@@KGXKG@Z ENDP	; DirectSound::CAc97Device::PokeRegister16
DSOUND	ENDS
PUBLIC	?AciSynchronizationRoutine@CAc97Device@DirectSound@@CGEPAX@Z ; DirectSound::CAc97Device::AciSynchronizationRoutine
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.cpp
;	COMDAT ?ServiceAciInterruptDpc@CAc97Device@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -12
_fContinue$ = -8
_i$ = -4
?ServiceAciInterruptDpc@CAc97Device@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CAc97Device::ServiceAciInterruptDpc, COMDAT
; _this$ = ecx

; 820  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
$L40204:

; 821  :     BOOL                    fContinue;
; 822  :     DWORD                   i;
; 823  : 
; 824  :     DPF_ENTER();
; 825  : 
; 826  :     do
; 827  :     {
; 828  :         //
; 829  :         // Copy live buffer completion counts to cached
; 830  :         //
; 831  : 
; 832  :         KeSynchronizeExecution(&m_Interrupt, AciSynchronizationRoutine, this);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:?AciSynchronizationRoutine@CAc97Device@DirectSound@@CGEPAX@Z ; DirectSound::CAc97Device::AciSynchronizationRoutine
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?m_Interrupt@CAc97Device@DirectSound@@1U_KINTERRUPT@@A ; DirectSound::CAc97Device::m_Interrupt
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSynchronizeExecution@12

; 833  : 
; 834  :         //
; 835  :         // Handle all pending buffer completions
; 836  :         //
; 837  : 
; 838  :         for(i = 0, fContinue = FALSE; i < AC97_CHANNELTYPE_COUNT; i++)

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fContinue$[ebp], 0
  0002b	eb 09		 jmp	 SHORT $L40207
$L40208:
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00030	83 c1 01	 add	 ecx, 1
  00033	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L40207:
  00036	83 7d fc 02	 cmp	 DWORD PTR _i$[ebp], 2
  0003a	73 65		 jae	 SHORT $L40205

; 839  :         {
; 840  :             if(m_abPendingBufferCompletions[i][1])

  0003c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00042	0f b6 4c 50 39	 movzx	 ecx, BYTE PTR [eax+edx*2+57]
  00047	85 c9		 test	 ecx, ecx
  00049	74 54		 je	 SHORT $L40210

; 841  :             {
; 842  :                 fContinue = TRUE;

  0004b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fContinue$[ebp], 1

; 843  : 
; 844  :                 if(m_apChannels[i])

  00052	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00055	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00058	83 3c 90 00	 cmp	 DWORD PTR [eax+edx*4], 0
  0005c	74 36		 je	 SHORT $L40211
$L40212:

; 845  :                 {
; 846  :                     do
; 847  :                     {
; 848  :                         m_apChannels[i]->ServiceInterrupt();

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00061	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00064	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00067	e8 00 00 00 00	 call	 ?ServiceInterrupt@CAc97Channel@DirectSound@@IAEXXZ ; DirectSound::CAc97Channel::ServiceInterrupt

; 849  :                     }
; 850  :                     while(--m_abPendingBufferCompletions[i][1]);

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	8a 54 41 39	 mov	 dl, BYTE PTR [ecx+eax*2+57]
  00076	80 ea 01	 sub	 dl, 1
  00079	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0007c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	88 54 41 39	 mov	 BYTE PTR [ecx+eax*2+57], dl
  00083	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00086	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00089	0f b6 4c 50 39	 movzx	 ecx, BYTE PTR [eax+edx*2+57]
  0008e	85 c9		 test	 ecx, ecx
  00090	75 cc		 jne	 SHORT $L40212

; 851  :                 }
; 852  :                 else

  00092	eb 0b		 jmp	 SHORT $L40210
$L40211:

; 853  :                 {
; 854  :                     m_abPendingBufferCompletions[i][1] = 0;

  00094	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00097	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	c6 44 50 39 00	 mov	 BYTE PTR [eax+edx*2+57], 0
$L40210:

; 855  :                 }
; 856  :             }
; 857  :         }

  0009f	eb 8c		 jmp	 SHORT $L40208
$L40205:

; 858  :     }
; 859  :     while(fContinue);

  000a1	83 7d f8 00	 cmp	 DWORD PTR _fContinue$[ebp], 0
  000a5	0f 85 5e ff ff
	ff		 jne	 $L40204

; 860  : 
; 861  :     DPF_LEAVE_VOID();
; 862  : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
?ServiceAciInterruptDpc@CAc97Device@DirectSound@@IAEXXZ ENDP ; DirectSound::CAc97Device::ServiceAciInterruptDpc
DSOUND	ENDS
PUBLIC	?SynchronizeAciInterrupt@CAc97Device@DirectSound@@IAEXXZ ; DirectSound::CAc97Device::SynchronizeAciInterrupt
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.h
;	COMDAT ?AciSynchronizationRoutine@CAc97Device@DirectSound@@CGEPAX@Z
DSOUND	SEGMENT
_pThis$ = -4
_pvContext$ = 8
?AciSynchronizationRoutine@CAc97Device@DirectSound@@CGEPAX@Z PROC NEAR ; DirectSound::CAc97Device::AciSynchronizationRoutine, COMDAT

; 318  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 319  :         CAc97Device *           pThis   = (CAc97Device *)pvContext;

  00004	8b 45 08	 mov	 eax, DWORD PTR _pvContext$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pThis$[ebp], eax

; 320  :     
; 321  :         pThis->SynchronizeAciInterrupt();

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _pThis$[ebp]
  0000d	e8 00 00 00 00	 call	 ?SynchronizeAciInterrupt@CAc97Device@DirectSound@@IAEXXZ ; DirectSound::CAc97Device::SynchronizeAciInterrupt

; 322  : 
; 323  :         return TRUE;

  00012	b0 01		 mov	 al, 1

; 324  :     }    

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?AciSynchronizationRoutine@CAc97Device@DirectSound@@CGEPAX@Z ENDP ; DirectSound::CAc97Device::AciSynchronizationRoutine
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.cpp
DSOUND	ENDS
;	COMDAT ?SynchronizeAciInterrupt@CAc97Device@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -8
_i$ = -4
?SynchronizeAciInterrupt@CAc97Device@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CAc97Device::SynchronizeAciInterrupt, COMDAT
; _this$ = ecx

; 888  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 889  :     DWORD                   i;
; 890  : 
; 891  :     DPF_ENTER();
; 892  : 
; 893  :     //
; 894  :     // Copy live pending buffer completions to cached and clear the live
; 895  :     // ones.
; 896  :     //
; 897  : 
; 898  :     for(i = 0; i < AC97_CHANNELTYPE_COUNT; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $L40221
$L40222:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L40221:
  0001b	83 7d fc 02	 cmp	 DWORD PTR _i$[ebp], 2
  0001f	73 2f		 jae	 SHORT $L40219

; 899  :     {
; 900  :         m_abPendingBufferCompletions[i][1] += m_abPendingBufferCompletions[i][0];

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00024	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00027	0f b6 44 4a 38	 movzx	 eax, BYTE PTR [edx+ecx*2+56]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0002f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00032	0f b6 4c 4a 39	 movzx	 ecx, BYTE PTR [edx+ecx*2+57]
  00037	03 c8		 add	 ecx, eax
  00039	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	88 4c 50 39	 mov	 BYTE PTR [eax+edx*2+57], cl

; 901  : 
; 902  :         m_abPendingBufferCompletions[i][0] = 0;

  00043	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00046	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00049	c6 44 4a 38 00	 mov	 BYTE PTR [edx+ecx*2+56], 0

; 903  :     }

  0004e	eb c2		 jmp	 SHORT $L40222
$L40219:

; 904  : 
; 905  :     DPF_LEAVE_VOID();
; 906  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?SynchronizeAciInterrupt@CAc97Device@DirectSound@@IAEXXZ ENDP ; DirectSound::CAc97Device::SynchronizeAciInterrupt
DSOUND	ENDS
PUBLIC	?PeekAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@PAG@Z ; DirectSound::CAc97Device::PeekAc97Register
; Function compile flags: /Odt
;	COMDAT ?PeekAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@PAG@Z
DSOUND	SEGMENT
_dwStatus$ = -8
_fSuccess$ = -4
_reg$ = 8
_pwValue$ = 12
?PeekAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@PAG@Z PROC NEAR ; DirectSound::CAc97Device::PeekAc97Register, COMDAT

; 934  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 935  :     DWORD                   dwStatus;
; 936  :     BOOL                    fSuccess;
; 937  : 
; 938  :     DPF_ENTER();
; 939  :     
; 940  :     //
; 941  :     // Acquire the CODEC semaphore
; 942  :     //
; 943  : 
; 944  :     fSuccess = AcquireCodecSemaphore();

  00006	e8 00 00 00 00	 call	 ?AcquireCodecSemaphore@CAc97Device@DirectSound@@KGHXZ ; DirectSound::CAc97Device::AcquireCodecSemaphore
  0000b	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 945  : 
; 946  :     //
; 947  :     // Read the contents of the register
; 948  :     //
; 949  : 
; 950  :     if(fSuccess)

  0000e	83 7d fc 00	 cmp	 DWORD PTR _fSuccess$[ebp], 0
  00012	74 16		 je	 SHORT $L40230

; 951  :     {
; 952  :         *pwValue = PeekRegister16(m_dwAc97RegisterBase + (reg * 2));

  00014	8b 45 08	 mov	 eax, DWORD PTR _reg$[ebp]
  00017	8d 8c 00 00 00
	c0 fe		 lea	 ecx, DWORD PTR [eax+eax-20971520]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ?PeekRegister16@CAc97Device@DirectSound@@KGGK@Z ; DirectSound::CAc97Device::PeekRegister16
  00024	8b 55 0c	 mov	 edx, DWORD PTR _pwValue$[ebp]
  00027	66 89 02	 mov	 WORD PTR [edx], ax
$L40230:

; 953  :     }
; 954  : 
; 955  :     //
; 956  :     // Make sure the read was successful
; 957  :     //
; 958  : 
; 959  :     if(fSuccess)

  0002a	83 7d fc 00	 cmp	 DWORD PTR _fSuccess$[ebp], 0
  0002e	74 2e		 je	 SHORT $L40231

; 960  :     {
; 961  :         if((dwStatus = PeekAciRegister32(GLB_STATUS)) & GLB_STATUS_RCS)

  00030	6a 30		 push	 48			; 00000030H
  00032	e8 00 00 00 00	 call	 ?PeekAciRegister32@CAc97Device@DirectSound@@KGKK@Z ; DirectSound::CAc97Device::PeekAciRegister32
  00037	89 45 f8	 mov	 DWORD PTR _dwStatus$[ebp], eax
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _dwStatus$[ebp]
  0003d	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00042	85 c0		 test	 eax, eax
  00044	74 18		 je	 SHORT $L40231

; 962  :         {
; 963  :             //
; 964  :             // Nope.  Clear the bit.
; 965  :             //
; 966  : 
; 967  :             DPF_ERROR("AC '97 register peek failed");
; 968  :             
; 969  :             PokeAciRegister32(GLB_STATUS, dwStatus & ~GLB_STATUS_RCS);

  00046	8b 4d f8	 mov	 ecx, DWORD PTR _dwStatus$[ebp]
  00049	81 e1 ff 7f ff
	ff		 and	 ecx, -32769		; ffff7fffH
  0004f	51		 push	 ecx
  00050	6a 30		 push	 48			; 00000030H
  00052	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Device@DirectSound@@KGXKK@Z ; DirectSound::CAc97Device::PokeAciRegister32

; 970  :             
; 971  :             fSuccess = FALSE;

  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0
$L40231:

; 972  :         }
; 973  :     }
; 974  : 
; 975  :     DPF_LEAVE(fSuccess);
; 976  : 
; 977  :     return fSuccess;

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 978  : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
?PeekAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@PAG@Z ENDP ; DirectSound::CAc97Device::PeekAc97Register
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PokeAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@G@Z
DSOUND	SEGMENT
_fSuccess$ = -4
_reg$ = 8
_wValue$ = 12
?PokeAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@G@Z PROC NEAR ; DirectSound::CAc97Device::PokeAc97Register, COMDAT

; 1006 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1007 :     BOOL                    fSuccess;
; 1008 : 
; 1009 :     DPF_ENTER();
; 1010 :     
; 1011 :     //
; 1012 :     // Acquire the CODEC semaphore
; 1013 :     //
; 1014 : 
; 1015 :     fSuccess = AcquireCodecSemaphore();

  00004	e8 00 00 00 00	 call	 ?AcquireCodecSemaphore@CAc97Device@DirectSound@@KGHXZ ; DirectSound::CAc97Device::AcquireCodecSemaphore
  00009	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 1016 : 
; 1017 :     //
; 1018 :     // Write to the register
; 1019 :     //
; 1020 : 
; 1021 :     if(fSuccess)

  0000c	83 7d fc 00	 cmp	 DWORD PTR _fSuccess$[ebp], 0
  00010	74 15		 je	 SHORT $L40238

; 1022 :     {
; 1023 :         PokeRegister16(m_dwAc97RegisterBase + (reg * 2), wValue);

  00012	66 8b 45 0c	 mov	 ax, WORD PTR _wValue$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _reg$[ebp]
  0001a	8d 94 09 00 00
	c0 fe		 lea	 edx, DWORD PTR [ecx+ecx-20971520]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 ?PokeRegister16@CAc97Device@DirectSound@@KGXKG@Z ; DirectSound::CAc97Device::PokeRegister16
$L40238:

; 1024 :     }
; 1025 : 
; 1026 :     DPF_LEAVE(fSuccess);
; 1027 : 
; 1028 :     return fSuccess;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 1029 : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?PokeAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@G@Z ENDP ; DirectSound::CAc97Device::PokeAc97Register
DSOUND	ENDS
PUBLIC	?VerifyPokeAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@G@Z ; DirectSound::CAc97Device::VerifyPokeAc97Register
; Function compile flags: /Odt
;	COMDAT ?VerifyPokeAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@G@Z
DSOUND	SEGMENT
_wNewValue$ = -8
_fSuccess$ = -4
_reg$ = 8
_wValue$ = 12
?VerifyPokeAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@G@Z PROC NEAR ; DirectSound::CAc97Device::VerifyPokeAc97Register, COMDAT

; 1058 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1059 :     WORD                    wNewValue;
; 1060 :     BOOL                    fSuccess;
; 1061 : 
; 1062 :     DPF_ENTER();
; 1063 :     
; 1064 :     //
; 1065 :     // Write the new value
; 1066 :     //
; 1067 : 
; 1068 :     fSuccess = PokeAc97Register(reg, wValue);

  00006	66 8b 45 0c	 mov	 ax, WORD PTR _wValue$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _reg$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ?PokeAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@G@Z ; DirectSound::CAc97Device::PokeAc97Register
  00014	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax

; 1069 : 
; 1070 :     //
; 1071 :     // Read back the new value
; 1072 :     //
; 1073 : 
; 1074 :     if(fSuccess)

  00017	83 7d fc 00	 cmp	 DWORD PTR _fSuccess$[ebp], 0
  0001b	74 10		 je	 SHORT $L40245

; 1075 :     {
; 1076 :         fSuccess = PeekAc97Register(reg, &wNewValue);

  0001d	8d 55 f8	 lea	 edx, DWORD PTR _wNewValue$[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR _reg$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?PeekAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@PAG@Z ; DirectSound::CAc97Device::PeekAc97Register
  0002a	89 45 fc	 mov	 DWORD PTR _fSuccess$[ebp], eax
$L40245:

; 1077 :     }
; 1078 : 
; 1079 :     //
; 1080 :     // Did it stick?
; 1081 :     //
; 1082 : 
; 1083 :     if(fSuccess && (wValue != wNewValue))

  0002d	83 7d fc 00	 cmp	 DWORD PTR _fSuccess$[ebp], 0
  00031	74 13		 je	 SHORT $L40246
  00033	0f b7 4d 0c	 movzx	 ecx, WORD PTR _wValue$[ebp]
  00037	0f b7 55 f8	 movzx	 edx, WORD PTR _wNewValue$[ebp]
  0003b	3b ca		 cmp	 ecx, edx
  0003d	74 07		 je	 SHORT $L40246

; 1084 :     {
; 1085 :         fSuccess = FALSE;

  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fSuccess$[ebp], 0
$L40246:

; 1086 :     }
; 1087 : 
; 1088 :     DPF_LEAVE(fSuccess);
; 1089 : 
; 1090 :     return fSuccess;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _fSuccess$[ebp]

; 1091 : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?VerifyPokeAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@G@Z ENDP ; DirectSound::CAc97Device::VerifyPokeAc97Register
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PowerUp@CAc97Device@DirectSound@@IAEJXZ
DSOUND	SEGMENT
_this$ = -8
_hr$ = -4
?PowerUp@CAc97Device@DirectSound@@IAEJXZ PROC NEAR	; DirectSound::CAc97Device::PowerUp, COMDAT
; _this$ = ecx

; 1117 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1118 :     HRESULT                 hr  = DS_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1119 :     
; 1120 :     DPF_ENTER();
; 1121 : 
; 1122 :     //
; 1123 :     // Set the CODEC to full power
; 1124 :     //
; 1125 : 
; 1126 :     if(!PokeAc97Register(AC97REG_POWERDOWN, AC97REG_PCS_FULL_POWER))

  00010	6a 00		 push	 0
  00012	6a 13		 push	 19			; 00000013H
  00014	e8 00 00 00 00	 call	 ?PokeAc97Register@CAc97Device@DirectSound@@KGHW4AC97REGISTER@@G@Z ; DirectSound::CAc97Device::PokeAc97Register
  00019	85 c0		 test	 eax, eax
  0001b	75 07		 jne	 SHORT $L40253

; 1127 :     {
; 1128 :         DPF_ERROR("Failed to set power state");
; 1129 :         hr = DSERR_GENERIC;

  0001d	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L40253:

; 1130 :     }
; 1131 : 
; 1132 :     DPF_LEAVE_HRESULT(hr);
; 1133 : 
; 1134 :     return hr;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1135 : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?PowerUp@CAc97Device@DirectSound@@IAEJXZ ENDP		; DirectSound::CAc97Device::PowerUp
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??0CAc97Channel@DirectSound@@QAE@PAVCAc97Device@1@W4AC97CHANNELTYPE@@@Z
DSOUND	SEGMENT
_this$ = -4
_pDevice$ = 8
_nChannelType$ = 12
??0CAc97Channel@DirectSound@@QAE@PAVCAc97Device@1@W4AC97CHANNELTYPE@@@Z PROC NEAR ; DirectSound::CAc97Channel::CAc97Channel, COMDAT
; _this$ = ecx

; 1171 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _nChannelType$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 1172 : 
; 1173 :     DPF_ENTER();
; 1174 : 
; 1175 :     //
; 1176 :     // Initialize defaults
; 1177 :     //
; 1178 : 
; 1179 :     m_dwMode = DSAC97_MODE_DEFAULT;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	c7 42 28 00 00
	00 02		 mov	 DWORD PTR [edx+40], 33554432 ; 02000000H

; 1180 : 
; 1181 :     //
; 1182 :     // Save a pointer back to the parent device.  Note that we're not 
; 1183 :     // AddRef'ing it, since the device controls our construction and 
; 1184 :     // destruction.
; 1185 :     //
; 1186 : 
; 1187 :     m_pDevice = pDevice;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _pDevice$[ebp]
  0001f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1188 : 
; 1189 :     DPF_LEAVE_VOID();
; 1190 : }

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
??0CAc97Channel@DirectSound@@QAE@PAVCAc97Device@1@W4AC97CHANNELTYPE@@@Z ENDP ; DirectSound::CAc97Channel::CAc97Channel
DSOUND	ENDS
PUBLIC	?Terminate@CAc97Channel@DirectSound@@QAEXXZ	; DirectSound::CAc97Channel::Terminate
; Function compile flags: /Odt
;	COMDAT ??1CAc97Channel@DirectSound@@QAE@XZ
DSOUND	SEGMENT
_this$ = -4
??1CAc97Channel@DirectSound@@QAE@XZ PROC NEAR		; DirectSound::CAc97Channel::~CAc97Channel, COMDAT
; _this$ = ecx

; 1215 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1216 :     DPF_ENTER();
; 1217 :     
; 1218 :     Terminate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Terminate@CAc97Channel@DirectSound@@QAEXXZ ; DirectSound::CAc97Channel::Terminate

; 1219 : 
; 1220 :     DPF_LEAVE_VOID();
; 1221 : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CAc97Channel@DirectSound@@QAE@XZ ENDP		; DirectSound::CAc97Channel::~CAc97Channel
DSOUND	ENDS
PUBLIC	?Reset@CAc97Channel@DirectSound@@QAEXXZ		; DirectSound::CAc97Channel::Reset
; Function compile flags: /Odt
;	COMDAT ?Initialize@CAc97Channel@DirectSound@@QAEJKP6GXPAX@Z0@Z
DSOUND	SEGMENT
_this$ = -20
$T42693 = -16
___AutoIrql$ = -12
_hr$ = -4
_dwFlags$ = 8
_pfnCallback$ = 12
_pvContext$ = 16
?Initialize@CAc97Channel@DirectSound@@QAEJKP6GXPAX@Z0@Z PROC NEAR ; DirectSound::CAc97Channel::Initialize, COMDAT
; _this$ = ecx

; 1251 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1252 :     HRESULT                 hr;
; 1253 :     
; 1254 :     DPF_ENTER();
; 1255 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1256 : 
; 1257 : 
; 1258 :     m_dwFlags = dwFlags;

  00011	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  00017	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 1259 :     m_pfnCallback = pfnCallback;

  0001a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 45 0c	 mov	 eax, DWORD PTR _pfnCallback$[ebp]
  00020	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 1260 :     m_pvCallbackContext = pvContext;

  00023	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 55 10	 mov	 edx, DWORD PTR _pvContext$[ebp]
  00029	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 1261 : 
; 1262 :     //
; 1263 :     // Allocate the PRDL
; 1264 :     //
; 1265 : 
; 1266 :     hr = HRFROMP(m_pPrdl = PHYSALLOC(ACIPRD, ACIPRDL_ENTRY_COUNT, PAGE_SIZE, PAGE_READWRITE));

  0002c	6a 01		 push	 1
  0002e	6a 04		 push	 4
  00030	68 00 10 00 00	 push	 4096			; 00001000H
  00035	68 00 01 00 00	 push	 256			; 00000100H
  0003a	e8 00 00 00 00	 call	 ?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z ; DirectSound::CMemoryManager::PhysicalAlloc
  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00045	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00048	33 c0		 xor	 eax, eax
  0004a	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  0004e	0f 95 c0	 setne	 al
  00051	48		 dec	 eax
  00052	25 0e 00 07 80	 and	 eax, -2147024882	; 8007000eH
  00057	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1267 : 
; 1268 :     if(SUCCEEDED(hr))

  0005a	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0005e	7c 13		 jl	 SHORT $L40277

; 1269 :     {
; 1270 :         m_dwPrdlAddress = MmGetPhysicalAddress(m_pPrdl);

  00060	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00066	52		 push	 edx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmGetPhysicalAddress@4
  0006d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$L40277:

; 1271 :     }
; 1272 : 
; 1273 :     //
; 1274 :     // If we're a stream, allocate a packet of silence to loop on when we
; 1275 :     // starve.
; 1276 :     //
; 1277 : 
; 1278 :     if(SUCCEEDED(hr) && (dwFlags & AC97CHANNEL_OBJECTF_STREAM))

  00073	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00077	7c 38		 jl	 SHORT $L40279
  00079	8b 55 08	 mov	 edx, DWORD PTR _dwFlags$[ebp]
  0007c	83 e2 01	 and	 edx, 1
  0007f	85 d2		 test	 edx, edx
  00081	74 2e		 je	 SHORT $L40279

; 1279 :     {
; 1280 :         hr = HRFROMP(m_pvSilence = PHYSALLOC(BYTE, m_dwSilenceSize, PAGE_SIZE, PAGE_READWRITE));

  00083	6a 01		 push	 1
  00085	6a 04		 push	 4
  00087	68 00 10 00 00	 push	 4096			; 00001000H
  0008c	68 00 20 00 00	 push	 8192			; 00002000H
  00091	e8 00 00 00 00	 call	 ?PhysicalAlloc@CMemoryManager@DirectSound@@SGPAXKKKH@Z ; DirectSound::CMemoryManager::PhysicalAlloc
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  0009c	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0009f	33 c0		 xor	 eax, eax
  000a1	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  000a5	0f 95 c0	 setne	 al
  000a8	48		 dec	 eax
  000a9	25 0e 00 07 80	 and	 eax, -2147024882	; 8007000eH
  000ae	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L40279:

; 1281 :     }
; 1282 : 
; 1283 :     //
; 1284 :     // Reset the channel
; 1285 :     //
; 1286 : 
; 1287 :     if(SUCCEEDED(hr))

  000b1	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b5	7c 08		 jl	 SHORT $L40285

; 1288 :     {
; 1289 :         Reset();

  000b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	e8 00 00 00 00	 call	 ?Reset@CAc97Channel@DirectSound@@QAEXXZ ; DirectSound::CAc97Channel::Reset
$L40285:

; 1290 :     }
; 1291 : 
; 1292 :     DPF_LEAVE_HRESULT(hr);
; 1293 : 
; 1294 :     return hr;

  000bf	8b 4d fc	 mov	 ecx, DWORD PTR _hr$[ebp]
  000c2	89 4d f0	 mov	 DWORD PTR $T42693[ebp], ecx
  000c5	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000c8	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000cd	8b 45 f0	 mov	 eax, DWORD PTR $T42693[ebp]

; 1295 : }

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 0c 00	 ret	 12			; 0000000cH
?Initialize@CAc97Channel@DirectSound@@QAEJKP6GXPAX@Z0@Z ENDP ; DirectSound::CAc97Channel::Initialize
DSOUND	ENDS
PUBLIC	?Flush@CAc97Channel@DirectSound@@QAEXH@Z	; DirectSound::CAc97Channel::Flush
; Function compile flags: /Odt
;	COMDAT ?Terminate@CAc97Channel@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -12
___AutoIrql$ = -8
?Terminate@CAc97Channel@DirectSound@@QAEXXZ PROC NEAR	; DirectSound::CAc97Channel::Terminate, COMDAT
; _this$ = ecx

; 1321 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1322 :     DPF_ENTER();
; 1323 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1324 : 
; 1325 :     //
; 1326 :     // Reset the channel
; 1327 :     //
; 1328 : 
; 1329 :     Flush();

  00011	6a 01		 push	 1
  00013	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?Flush@CAc97Channel@DirectSound@@QAEXH@Z ; DirectSound::CAc97Channel::Flush

; 1330 :     
; 1331 :     //
; 1332 :     // Free resources
; 1333 :     //
; 1334 : 
; 1335 :     PHYSFREE(m_pPrdl);

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00022	74 16		 je	 SHORT $L40292
  00024	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0002a	52		 push	 edx
  0002b	e8 00 00 00 00	 call	 ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PhysicalFree
  00030	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
$L40292:

; 1336 :     PHYSFREE(m_pvSilence);

  0003a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00041	74 16		 je	 SHORT $L40293
  00043	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00046	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ?PhysicalFree@CMemoryManager@DirectSound@@SGXPAX@Z ; DirectSound::CMemoryManager::PhysicalFree
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
$L40293:

; 1337 : 
; 1338 :     m_dwPrdlAddress = 0;

  00059	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1339 : 
; 1340 :     DPF_LEAVE_VOID();
; 1341 : }

  00063	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00066	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?Terminate@CAc97Channel@DirectSound@@QAEXXZ ENDP	; DirectSound::CAc97Channel::Terminate
DSOUND	ENDS
PUBLIC	?SetPrdIndeces@CAc97Channel@DirectSound@@IAEXEEHH@Z ; DirectSound::CAc97Channel::SetPrdIndeces
; Function compile flags: /Odt
;	COMDAT ?AttachPacket@CAc97Channel@DirectSound@@QAEXKK@Z
DSOUND	SEGMENT
_this$ = -16
___AutoIrql$ = -12
_bPrdIndex$ = -1
_dwBufferAddress$ = 8
_dwBufferSize$ = 12
?AttachPacket@CAc97Channel@DirectSound@@QAEXKK@Z PROC NEAR ; DirectSound::CAc97Channel::AttachPacket, COMDAT
; _this$ = ecx

; 1369 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1370 :     BYTE                    bPrdIndex;
; 1371 :     
; 1372 :     DPF_ENTER();
; 1373 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1374 : 
; 1375 :     ASSERT(m_bPrdCount < ACIPRDL_ENTRY_COUNT);
; 1376 :     ASSERT((dwBufferSize / (m_pDevice->m_wfxFormat.wBitsPerSample / 8)) <= 0xFFFF);
; 1377 :     ASSERT(!(dwBufferSize % m_pDevice->m_wfxFormat.nBlockAlign));
; 1378 : 
; 1379 :     if(!(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM))
; 1380 :     {
; 1381 :         ASSERT(!m_bCurrentPrd);
; 1382 :     }
; 1383 : 
; 1384 :     //
; 1385 :     // If a discontinuity has been signaled, but another packet has been
; 1386 :     // attached, we can remove the discontinuity by resetting the flags and
; 1387 :     // removing the silence packet.  The easiest way to remove the silence
; 1388 :     // packet is to just stomp on the PRD.
; 1389 :     //
; 1390 : 
; 1391 :     if(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY)

  00011	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00017	83 e0 02	 and	 eax, 2
  0001a	85 c0		 test	 eax, eax
  0001c	74 1e		 je	 SHORT $L40302

; 1392 :     {
; 1393 :         ASSERT(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM);
; 1394 :         ASSERT(m_bPrdCount);
; 1395 :         
; 1396 :         m_dwFlags &= ~AC97CHANNEL_OBJECTF_DISCONTINUITY;

  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00024	83 e2 fd	 and	 edx, -3			; fffffffdH
  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 1397 : 
; 1398 :         m_bPrdCount--;

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	8a 51 24	 mov	 dl, BYTE PTR [ecx+36]
  00033	80 ea 01	 sub	 dl, 1
  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	88 50 24	 mov	 BYTE PTR [eax+36], dl
$L40302:

; 1399 :     }
; 1400 : 
; 1401 :     //
; 1402 :     // Add the PRD to the end of the list.  We're assuming that the buffer
; 1403 :     // is already locked.
; 1404 :     //
; 1405 : 
; 1406 :     bPrdIndex = (m_bCurrentPrd + m_bPrdCount) & ACIPRDL_ENTRY_MASK;

  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	0f b6 51 25	 movzx	 edx, BYTE PTR [ecx+37]
  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	0f b6 48 24	 movzx	 ecx, BYTE PTR [eax+36]
  0004a	03 d1		 add	 edx, ecx
  0004c	83 e2 1f	 and	 edx, 31			; 0000001fH
  0004f	88 55 ff	 mov	 BYTE PTR _bPrdIndex$[ebp], dl

; 1407 : 
; 1408 :     m_pPrdl[bPrdIndex].dwPhysicalAddress = dwBufferAddress;

  00052	0f b6 55 ff	 movzx	 edx, BYTE PTR _bPrdIndex$[ebp]
  00056	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0005c	8b 45 08	 mov	 eax, DWORD PTR _dwBufferAddress$[ebp]
  0005f	89 04 d1	 mov	 DWORD PTR [ecx+edx*8], eax

; 1409 :     m_pPrdl[bPrdIndex].wLength = LOWORD(dwBufferSize / (m_pDevice->m_wfxFormat.wBitsPerSample / 8));

  00062	0f b7 05 0e 00
	00 00		 movzx	 eax, WORD PTR ?m_wfxFormat@CAc97Device@DirectSound@@2UtWAVEFORMATEX@@B+14
  00069	99		 cdq
  0006a	83 e2 07	 and	 edx, 7
  0006d	03 c2		 add	 eax, edx
  0006f	8b c8		 mov	 ecx, eax
  00071	c1 f9 03	 sar	 ecx, 3
  00074	8b 45 0c	 mov	 eax, DWORD PTR _dwBufferSize$[ebp]
  00077	33 d2		 xor	 edx, edx
  00079	f7 f1		 div	 ecx
  0007b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00080	0f b7 d0	 movzx	 edx, ax
  00083	0f b6 45 ff	 movzx	 eax, BYTE PTR _bPrdIndex$[ebp]
  00087	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  0008d	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00093	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  00097	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H
  0009c	0b c2		 or	 eax, edx
  0009e	0f b6 4d ff	 movzx	 ecx, BYTE PTR _bPrdIndex$[ebp]
  000a2	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  000a8	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 1410 :     m_pPrdl[bPrdIndex].wReserved = 0;

  000ac	0f b6 45 ff	 movzx	 eax, BYTE PTR _bPrdIndex$[ebp]
  000b0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000b6	8b 44 c2 04	 mov	 eax, DWORD PTR [edx+eax*8+4]
  000ba	25 ff ff 00 c0	 and	 eax, -1073676289	; c000ffffH
  000bf	0f b6 4d ff	 movzx	 ecx, BYTE PTR _bPrdIndex$[ebp]
  000c3	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000c6	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  000c9	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 1411 :     m_pPrdl[bPrdIndex].fBufferUnderrunPolicy = TRUE;

  000cd	0f b6 45 ff	 movzx	 eax, BYTE PTR _bPrdIndex$[ebp]
  000d1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000d7	8b 44 c2 04	 mov	 eax, DWORD PTR [edx+eax*8+4]
  000db	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  000e0	0f b6 4d ff	 movzx	 ecx, BYTE PTR _bPrdIndex$[ebp]
  000e4	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000e7	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  000ea	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 1412 :     m_pPrdl[bPrdIndex].fInterruptOnCompletion = TRUE;

  000ee	0f b6 45 ff	 movzx	 eax, BYTE PTR _bPrdIndex$[ebp]
  000f2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000f8	8b 44 c2 04	 mov	 eax, DWORD PTR [edx+eax*8+4]
  000fc	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  00101	0d 00 00 00 80	 or	 eax, -2147483648	; 80000000H
  00106	0f b6 4d ff	 movzx	 ecx, BYTE PTR _bPrdIndex$[ebp]
  0010a	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0010d	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00110	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 1413 : 
; 1414 :     DPF_AC97("(channel %lu) PRD %d set to %x %x", m_nChannelType, (int)bPrdIndex, m_pPrdl[bPrdIndex].dwPhysicalAddress, (DWORD)m_pPrdl[bPrdIndex].wLength);
; 1415 : 
; 1416 :     //
; 1417 :     // Inform the hardware that the last valid PRD has changed
; 1418 :     //
; 1419 : 
; 1420 :     SetPrdIndeces(m_bCurrentPrd, m_bPrdCount + 1, FALSE, TRUE);

  00114	6a 01		 push	 1
  00116	6a 00		 push	 0
  00118	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0011b	0f b6 48 24	 movzx	 ecx, BYTE PTR [eax+36]
  0011f	83 c1 01	 add	 ecx, 1
  00122	51		 push	 ecx
  00123	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00126	8a 42 25	 mov	 al, BYTE PTR [edx+37]
  00129	50		 push	 eax
  0012a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	e8 00 00 00 00	 call	 ?SetPrdIndeces@CAc97Channel@DirectSound@@IAEXEEHH@Z ; DirectSound::CAc97Channel::SetPrdIndeces

; 1421 : 
; 1422 :     DPF_LEAVE_VOID();
; 1423 : }

  00132	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00135	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c2 08 00	 ret	 8
?AttachPacket@CAc97Channel@DirectSound@@QAEXKK@Z ENDP	; DirectSound::CAc97Channel::AttachPacket
DSOUND	ENDS
PUBLIC	?AttachBuffer@CAc97Channel@DirectSound@@QAEXKKK@Z ; DirectSound::CAc97Channel::AttachBuffer
; Function compile flags: /Odt
;	COMDAT ?AttachBuffer@CAc97Channel@DirectSound@@QAEXKKK@Z
DSOUND	SEGMENT
_this$ = -12
___AutoIrql$ = -8
_dwBufferAddress$ = 8
_dwBufferSize$ = 12
_dwPacketCount$ = 16
?AttachBuffer@CAc97Channel@DirectSound@@QAEXKKK@Z PROC NEAR ; DirectSound::CAc97Channel::AttachBuffer, COMDAT
; _this$ = ecx

; 1453 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 :     DPF_ENTER();
; 1455 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1456 : 
; 1457 :     //
; 1458 :     // Attach the buffer in as many packets as were specified
; 1459 :     //
; 1460 : 
; 1461 :     ASSERT(!(dwBufferSize % dwPacketCount));
; 1462 : 
; 1463 :     dwBufferSize /= dwPacketCount;

  00011	8b 45 0c	 mov	 eax, DWORD PTR _dwBufferSize$[ebp]
  00014	33 d2		 xor	 edx, edx
  00016	f7 75 10	 div	 DWORD PTR _dwPacketCount$[ebp]
  00019	89 45 0c	 mov	 DWORD PTR _dwBufferSize$[ebp], eax
$L40313:

; 1464 : 
; 1465 :     while(dwPacketCount--)

  0001c	8b 45 10	 mov	 eax, DWORD PTR _dwPacketCount$[ebp]
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _dwPacketCount$[ebp]
  00022	83 e9 01	 sub	 ecx, 1
  00025	89 4d 10	 mov	 DWORD PTR _dwPacketCount$[ebp], ecx
  00028	85 c0		 test	 eax, eax
  0002a	74 1b		 je	 SHORT $L40314

; 1466 :     {
; 1467 :         AttachPacket(dwBufferAddress, dwBufferSize);

  0002c	8b 55 0c	 mov	 edx, DWORD PTR _dwBufferSize$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 08	 mov	 eax, DWORD PTR _dwBufferAddress$[ebp]
  00033	50		 push	 eax
  00034	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?AttachPacket@CAc97Channel@DirectSound@@QAEXKK@Z ; DirectSound::CAc97Channel::AttachPacket

; 1468 : 
; 1469 :         dwBufferAddress += dwBufferSize;

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _dwBufferAddress$[ebp]
  0003f	03 4d 0c	 add	 ecx, DWORD PTR _dwBufferSize$[ebp]
  00042	89 4d 08	 mov	 DWORD PTR _dwBufferAddress$[ebp], ecx

; 1470 :     }

  00045	eb d5		 jmp	 SHORT $L40313
$L40314:

; 1471 : 
; 1472 :     DPF_LEAVE_VOID();
; 1473 : }

  00047	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0004a	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH
?AttachBuffer@CAc97Channel@DirectSound@@QAEXKKK@Z ENDP	; DirectSound::CAc97Channel::AttachBuffer
DSOUND	ENDS
PUBLIC	?AttachPacket@CAc97Channel@DirectSound@@QAEXPBXK@Z ; DirectSound::CAc97Channel::AttachPacket
PUBLIC	?Discontinuity@CAc97Channel@DirectSound@@QAEXXZ	; DirectSound::CAc97Channel::Discontinuity
; Function compile flags: /Odt
;	COMDAT ?Discontinuity@CAc97Channel@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -12
___AutoIrql$ = -8
?Discontinuity@CAc97Channel@DirectSound@@QAEXXZ PROC NEAR ; DirectSound::CAc97Channel::Discontinuity, COMDAT
; _this$ = ecx

; 1499 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1500 :     DPF_ENTER();
; 1501 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1502 : 
; 1503 :     ASSERT(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM);
; 1504 : 
; 1505 :     //
; 1506 :     // Attach a packet of silence that the DMA can spin on when we starve.
; 1507 :     //
; 1508 : 
; 1509 :     if(!(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY))

  00011	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00017	83 e1 02	 and	 ecx, 2
  0001a	85 c9		 test	 ecx, ecx
  0001c	75 23		 jne	 SHORT $L40320

; 1510 :     {
; 1511 :         AttachPacket(m_pvSilence, m_dwSilenceSize);

  0001e	68 00 20 00 00	 push	 8192			; 00002000H
  00023	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00029	50		 push	 eax
  0002a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?AttachPacket@CAc97Channel@DirectSound@@QAEXPBXK@Z ; DirectSound::CAc97Channel::AttachPacket

; 1512 : 
; 1513 :         m_dwFlags |= AC97CHANNEL_OBJECTF_DISCONTINUITY;

  00032	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00038	83 ca 02	 or	 edx, 2
  0003b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$L40320:

; 1514 :     }
; 1515 : 
; 1516 :     DPF_LEAVE_VOID();
; 1517 : }

  00041	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00044	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?Discontinuity@CAc97Channel@DirectSound@@QAEXXZ ENDP	; DirectSound::CAc97Channel::Discontinuity
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.h
DSOUND	ENDS
;	COMDAT ?AttachPacket@CAc97Channel@DirectSound@@QAEXPBXK@Z
DSOUND	SEGMENT
_this$ = -4
_pvBufferData$ = 8
_dwBufferSize$ = 12
?AttachPacket@CAc97Channel@DirectSound@@QAEXPBXK@Z PROC NEAR ; DirectSound::CAc97Channel::AttachPacket, COMDAT
; _this$ = ecx

; 420  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 421  :         AttachPacket(MmGetPhysicalAddress((LPVOID)pvBufferData), dwBufferSize);

  00007	8b 45 0c	 mov	 eax, DWORD PTR _dwBufferSize$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _pvBufferData$[ebp]
  0000e	51		 push	 ecx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmGetPhysicalAddress@4
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AttachPacket@CAc97Channel@DirectSound@@QAEXKK@Z ; DirectSound::CAc97Channel::AttachPacket

; 422  :     }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?AttachPacket@CAc97Channel@DirectSound@@QAEXPBXK@Z ENDP	; DirectSound::CAc97Channel::AttachPacket
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.cpp
DSOUND	ENDS
;	COMDAT ?ServiceInterrupt@CAc97Channel@DirectSound@@IAEXXZ
DSOUND	SEGMENT
_this$ = -4
?ServiceInterrupt@CAc97Channel@DirectSound@@IAEXXZ PROC NEAR ; DirectSound::CAc97Channel::ServiceInterrupt, COMDAT
; _this$ = ecx

; 1543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1544 :     DPF_ENTER();
; 1545 : 
; 1546 :     if(m_bPrdCount)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 48 24	 movzx	 ecx, BYTE PTR [eax+36]
  0000e	85 c9		 test	 ecx, ecx
  00010	0f 84 9f 00 00
	00		 je	 $L40324

; 1547 :     {
; 1548 :         //
; 1549 :         // A buffer has completed.  If we're a stream, we'll need to increment
; 1550 :         // the first PRD index and decrement the count in order to detach the
; 1551 :         // packet.
; 1552 :         //
; 1553 :         // If we're out of PRDs, stop the DMA.  This only happens because you
; 1554 :         // starved the stream.  Until we get a chance to stop the DMA, it's 
; 1555 :         // going to continue to play the last PRD over again.  If you know 
; 1556 :         // you're going to starve me, attach a packet of silence.
; 1557 :         //
; 1558 : 
; 1559 :         m_dwPosition += m_pPrdl[m_bCurrentPrd].wLength;

  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	0f b6 42 25	 movzx	 eax, BYTE PTR [edx+37]
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00023	8b 44 c2 04	 mov	 eax, DWORD PTR [edx+eax*8+4]
  00027	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00035	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1560 : 
; 1561 :         if(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM)

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0003e	83 e1 01	 and	 ecx, 1
  00041	85 c9		 test	 ecx, ecx
  00043	74 3c		 je	 SHORT $L40326

; 1562 :         {
; 1563 :             if(m_bPrdCount > 2)

  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	0f b6 42 24	 movzx	 eax, BYTE PTR [edx+36]
  0004c	83 f8 02	 cmp	 eax, 2
  0004f	7e 24		 jle	 SHORT $L40329

; 1564 :             {
; 1565 :                 SetPrdIndeces(m_bCurrentPrd + 1, m_bPrdCount - 1, FALSE, FALSE);

  00051	6a 00		 push	 0
  00053	6a 00		 push	 0
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	0f b6 51 24	 movzx	 edx, BYTE PTR [ecx+36]
  0005c	83 ea 01	 sub	 edx, 1
  0005f	52		 push	 edx
  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	0f b6 48 25	 movzx	 ecx, BYTE PTR [eax+37]
  00067	83 c1 01	 add	 ecx, 1
  0006a	51		 push	 ecx
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?SetPrdIndeces@CAc97Channel@DirectSound@@IAEXEEHH@Z ; DirectSound::CAc97Channel::SetPrdIndeces

; 1566 :             }
; 1567 :             else

  00073	eb 0a		 jmp	 SHORT $L40328
$L40329:

; 1568 :             {
; 1569 :                 if(!(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY))
; 1570 :                 {
; 1571 :                     DPF_WARNING("AC'97 stream starving");
; 1572 :                 }
; 1573 :                 
; 1574 :                 Flush(FALSE);

  00075	6a 00		 push	 0
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	e8 00 00 00 00	 call	 ?Flush@CAc97Channel@DirectSound@@QAEXH@Z ; DirectSound::CAc97Channel::Flush
$L40328:

; 1575 :             }
; 1576 :         }
; 1577 :         else

  0007f	eb 1e		 jmp	 SHORT $L40330
$L40326:

; 1578 :         {
; 1579 :             SetPrdIndeces(m_bCurrentPrd + 1, m_bPrdCount, FALSE, FALSE);

  00081	6a 00		 push	 0
  00083	6a 00		 push	 0
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	8a 51 24	 mov	 dl, BYTE PTR [ecx+36]
  0008b	52		 push	 edx
  0008c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	0f b6 48 25	 movzx	 ecx, BYTE PTR [eax+37]
  00093	83 c1 01	 add	 ecx, 1
  00096	51		 push	 ecx
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?SetPrdIndeces@CAc97Channel@DirectSound@@IAEXEEHH@Z ; DirectSound::CAc97Channel::SetPrdIndeces
$L40330:

; 1580 :         }
; 1581 : 
; 1582 :         //
; 1583 :         // Notify the callback function
; 1584 :         //
; 1585 : 
; 1586 :         if(m_pfnCallback)

  0009f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a2	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  000a6	74 0d		 je	 SHORT $L40324

; 1587 :         {
; 1588 :             m_pfnCallback(m_pvCallbackContext);

  000a8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000ae	51		 push	 ecx
  000af	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b2	ff 52 10	 call	 DWORD PTR [edx+16]
$L40324:

; 1589 :         }
; 1590 :     }
; 1591 : 
; 1592 :     DPF_LEAVE_VOID();
; 1593 : }

  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
?ServiceInterrupt@CAc97Channel@DirectSound@@IAEXXZ ENDP	; DirectSound::CAc97Channel::ServiceInterrupt
DSOUND	ENDS
PUBLIC	?PeekAciRegister8@CAc97Channel@DirectSound@@IAEEK@Z ; DirectSound::CAc97Channel::PeekAciRegister8
PUBLIC	?PokeAciRegister8@CAc97Channel@DirectSound@@IAEXKE@Z ; DirectSound::CAc97Channel::PokeAciRegister8
PUBLIC	?PokeAciRegister32@CAc97Channel@DirectSound@@IAEXKK@Z ; DirectSound::CAc97Channel::PokeAciRegister32
; Function compile flags: /Odt
;	COMDAT ?Reset@CAc97Channel@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -12
___AutoIrql$ = -8
?Reset@CAc97Channel@DirectSound@@QAEXXZ PROC NEAR	; DirectSound::CAc97Channel::Reset, COMDAT
; _this$ = ecx

; 1619 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1620 :     DPF_ENTER();
; 1621 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1622 : 
; 1623 :     DPF_AC97("(channel %lu) Resetting DMA registers", m_nChannelType);
; 1624 : 
; 1625 :     //
; 1626 :     // Reset the channel
; 1627 :     //
; 1628 : 
; 1629 :     PokeAciRegister8(X_CTRL, X_CTRL_RBMR);

  00011	6a 02		 push	 2
  00013	6a 0b		 push	 11			; 0000000bH
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?PokeAciRegister8@CAc97Channel@DirectSound@@IAEXKE@Z ; DirectSound::CAc97Channel::PokeAciRegister8
$L40338:

; 1630 : 
; 1631 :     //
; 1632 :     // Wait for the reset to be acknowledged
; 1633 :     //
; 1634 : 
; 1635 :     while(PeekAciRegister8(X_CTRL) & X_CTRL_RBMR);

  0001d	6a 0b		 push	 11			; 0000000bH
  0001f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?PeekAciRegister8@CAc97Channel@DirectSound@@IAEEK@Z ; DirectSound::CAc97Channel::PeekAciRegister8
  00027	0f b6 c0	 movzx	 eax, al
  0002a	83 e0 02	 and	 eax, 2
  0002d	85 c0		 test	 eax, eax
  0002f	74 02		 je	 SHORT $L40339
  00031	eb ea		 jmp	 SHORT $L40338
$L40339:

; 1636 : 
; 1637 :     //
; 1638 :     // Set the PRDL location
; 1639 :     //
; 1640 : 
; 1641 :     PokeAciRegister32(X_BL_BASE, m_dwPrdlAddress);

  00033	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00039	52		 push	 edx
  0003a	6a 00		 push	 0
  0003c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Channel@DirectSound@@IAEXKK@Z ; DirectSound::CAc97Channel::PokeAciRegister32

; 1642 : 
; 1643 :     //
; 1644 :     // If this is the S/PDIF channel, set the output mode
; 1645 :     //
; 1646 : 
; 1647 :     if(AC97_CHANNELTYPE_DIGITAL == m_nChannelType)

  00044	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00047	83 38 01	 cmp	 DWORD PTR [eax], 1
  0004a	75 11		 jne	 SHORT $L40340

; 1648 :     {
; 1649 :         PokeAciRegister32(X_STWD, m_dwMode);

  0004c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00052	52		 push	 edx
  00053	6a 0c		 push	 12			; 0000000cH
  00055	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Channel@DirectSound@@IAEXKK@Z ; DirectSound::CAc97Channel::PokeAciRegister32
$L40340:

; 1650 :     }
; 1651 : 
; 1652 :     //
; 1653 :     // Reset PRD indeces
; 1654 :     //
; 1655 : 
; 1656 :     SetPrdIndeces(m_bCurrentPrd, m_bPrdCount, TRUE, TRUE);

  0005d	6a 01		 push	 1
  0005f	6a 01		 push	 1
  00061	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8a 48 24	 mov	 cl, BYTE PTR [eax+36]
  00067	51		 push	 ecx
  00068	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	8a 42 25	 mov	 al, BYTE PTR [edx+37]
  0006e	50		 push	 eax
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?SetPrdIndeces@CAc97Channel@DirectSound@@IAEXEEHH@Z ; DirectSound::CAc97Channel::SetPrdIndeces

; 1657 : 
; 1658 :     DPF_LEAVE_VOID();
; 1659 : }

  00077	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0007a	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?Reset@CAc97Channel@DirectSound@@QAEXXZ ENDP		; DirectSound::CAc97Channel::Reset
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.h
DSOUND	ENDS
;	COMDAT ?PeekAciRegister8@CAc97Channel@DirectSound@@IAEEK@Z
DSOUND	SEGMENT
_this$ = -4
_dwRegister$ = 8
?PeekAciRegister8@CAc97Channel@DirectSound@@IAEEK@Z PROC NEAR ; DirectSound::CAc97Channel::PeekAciRegister8, COMDAT
; _this$ = ecx

; 435  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 436  :         return m_pDevice->PeekAciRegister8(dwRegister + m_adwRegisterOffsets[m_nChannelType]);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	8b 55 08	 mov	 edx, DWORD PTR _dwRegister$[ebp]
  0000f	03 14 8d 00 00
	00 00		 add	 edx, DWORD PTR ?m_adwRegisterOffsets@CAc97Channel@DirectSound@@2QBKB[ecx*4]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 ?PeekAciRegister8@CAc97Device@DirectSound@@KGEK@Z ; DirectSound::CAc97Device::PeekAciRegister8

; 437  :     }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?PeekAciRegister8@CAc97Channel@DirectSound@@IAEEK@Z ENDP ; DirectSound::CAc97Channel::PeekAciRegister8
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PokeAciRegister8@CAc97Channel@DirectSound@@IAEXKE@Z
DSOUND	SEGMENT
_this$ = -4
_dwRegister$ = 8
_bValue$ = 12
?PokeAciRegister8@CAc97Channel@DirectSound@@IAEXKE@Z PROC NEAR ; DirectSound::CAc97Channel::PokeAciRegister8, COMDAT
; _this$ = ecx

; 440  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 441  :         m_pDevice->PokeAciRegister8(dwRegister + m_adwRegisterOffsets[m_nChannelType], bValue);

  00007	8a 45 0c	 mov	 al, BYTE PTR _bValue$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00013	03 04 95 00 00
	00 00		 add	 eax, DWORD PTR ?m_adwRegisterOffsets@CAc97Channel@DirectSound@@2QBKB[edx*4]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PokeAciRegister8@CAc97Device@DirectSound@@KGXKE@Z ; DirectSound::CAc97Device::PokeAciRegister8

; 442  :     }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?PokeAciRegister8@CAc97Channel@DirectSound@@IAEXKE@Z ENDP ; DirectSound::CAc97Channel::PokeAciRegister8
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?PokeAciRegister32@CAc97Channel@DirectSound@@IAEXKK@Z
DSOUND	SEGMENT
_this$ = -4
_dwRegister$ = 8
_dwValue$ = 12
?PokeAciRegister32@CAc97Channel@DirectSound@@IAEXKK@Z PROC NEAR ; DirectSound::CAc97Channel::PokeAciRegister32, COMDAT
; _this$ = ecx

; 460  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 461  :         m_pDevice->PokeAciRegister32(dwRegister + m_adwRegisterOffsets[m_nChannelType], dwValue);

  00007	8b 45 0c	 mov	 eax, DWORD PTR _dwValue$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	8b 45 08	 mov	 eax, DWORD PTR _dwRegister$[ebp]
  00013	03 04 95 00 00
	00 00		 add	 eax, DWORD PTR ?m_adwRegisterOffsets@CAc97Channel@DirectSound@@2QBKB[edx*4]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Device@DirectSound@@KGXKK@Z ; DirectSound::CAc97Device::PokeAciRegister32

; 462  :     }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?PokeAciRegister32@CAc97Channel@DirectSound@@IAEXKK@Z ENDP ; DirectSound::CAc97Channel::PokeAciRegister32
DSOUND	ENDS
PUBLIC	?Pause@CAc97Channel@DirectSound@@QAEXXZ		; DirectSound::CAc97Channel::Pause
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\ac97\ac97.cpp
;	COMDAT ?Flush@CAc97Channel@DirectSound@@QAEXH@Z
DSOUND	SEGMENT
_this$ = -16
___AutoIrql$ = -12
_fResetPosition$ = 8
?Flush@CAc97Channel@DirectSound@@QAEXH@Z PROC NEAR	; DirectSound::CAc97Channel::Flush, COMDAT
; _this$ = ecx

; 1685 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1686 :     BYTE                    bState;
; 1687 : 
; 1688 :     DPF_ENTER();
; 1689 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1690 : 
; 1691 :     //
; 1692 :     // Stop the DMA
; 1693 :     //
; 1694 :     
; 1695 :     Pause();

  00011	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Pause@CAc97Channel@DirectSound@@QAEXXZ ; DirectSound::CAc97Channel::Pause

; 1696 : 
; 1697 :     //
; 1698 :     // Reset the channel
; 1699 :     //
; 1700 : 
; 1701 :     Reset();

  00019	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?Reset@CAc97Channel@DirectSound@@QAEXXZ ; DirectSound::CAc97Channel::Reset

; 1702 : 
; 1703 :     //
; 1704 :     // Update PRD indeces
; 1705 :     //
; 1706 : 
; 1707 :     SetPrdIndeces(0, 0, TRUE, TRUE);

  00021	6a 01		 push	 1
  00023	6a 01		 push	 1
  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?SetPrdIndeces@CAc97Channel@DirectSound@@IAEXEEHH@Z ; DirectSound::CAc97Channel::SetPrdIndeces

; 1708 : 
; 1709 :     //
; 1710 :     // Remove any existing discontinuity
; 1711 :     //
; 1712 : 
; 1713 :     m_dwFlags &= ~AC97CHANNEL_OBJECTF_DISCONTINUITY;

  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00037	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0003a	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1714 : 
; 1715 :     //
; 1716 :     // Reset stored positions
; 1717 :     //
; 1718 : 
; 1719 :     if(fResetPosition)

  00040	83 7d 08 00	 cmp	 DWORD PTR _fResetPosition$[ebp], 0
  00044	74 14		 je	 SHORT $L40347

; 1720 :     {
; 1721 :         m_dwPosition = 0;

  00046	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00049	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1722 :         m_dwLastPosition = 0;

  00050	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
$L40347:

; 1723 :     }
; 1724 : 
; 1725 :     DPF_LEAVE_VOID();
; 1726 : }

  0005a	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0005d	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?Flush@CAc97Channel@DirectSound@@QAEXH@Z ENDP		; DirectSound::CAc97Channel::Flush
DSOUND	ENDS
PUBLIC	?SetPosition@CAc97Channel@DirectSound@@IAEXK@Z	; DirectSound::CAc97Channel::SetPosition
; Function compile flags: /Odt
;	COMDAT ?Run@CAc97Channel@DirectSound@@QAEXK@Z
DSOUND	SEGMENT
_this$ = -12
___AutoIrql$ = -8
_dwPosition$ = 8
?Run@CAc97Channel@DirectSound@@QAEXK@Z PROC NEAR	; DirectSound::CAc97Channel::Run, COMDAT
; _this$ = ecx

; 1752 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1753 :     DPF_ENTER();
; 1754 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1755 : 
; 1756 :     ASSERT(m_bPrdCount);
; 1757 : 
; 1758 :     //
; 1759 :     // Check the channel status.  If the DMA is halted, we'll have to
; 1760 :     // reset before we can run.
; 1761 :     //
; 1762 : 
; 1763 :     if(PeekAciRegister16(X_STATUS) & X_STATUS_DCH)

  00011	6a 06		 push	 6
  00013	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?PeekAciRegister16@CAc97Channel@DirectSound@@IAEGK@Z ; DirectSound::CAc97Channel::PeekAciRegister16
  0001b	0f b7 c0	 movzx	 eax, ax
  0001e	83 e0 01	 and	 eax, 1
  00021	85 c0		 test	 eax, eax
  00023	74 08		 je	 SHORT $L40353

; 1764 :     {
; 1765 :         Reset();

  00025	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?Reset@CAc97Channel@DirectSound@@QAEXXZ ; DirectSound::CAc97Channel::Reset
$L40353:

; 1766 :     }
; 1767 : 
; 1768 :     //
; 1769 :     // Set the buffer position
; 1770 :     //
; 1771 : 
; 1772 :     if(-1 != dwPosition)

  0002d	83 7d 08 ff	 cmp	 DWORD PTR _dwPosition$[ebp], -1
  00031	74 0c		 je	 SHORT $L40354

; 1773 :     {
; 1774 :         SetPosition(dwPosition);

  00033	8b 4d 08	 mov	 ecx, DWORD PTR _dwPosition$[ebp]
  00036	51		 push	 ecx
  00037	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?SetPosition@CAc97Channel@DirectSound@@IAEXK@Z ; DirectSound::CAc97Channel::SetPosition
$L40354:

; 1775 :     }
; 1776 : 
; 1777 :     //
; 1778 :     // Set the channel to RUN state and enable interrupts
; 1779 :     //
; 1780 : 
; 1781 :     PokeAciRegister8(X_CTRL, X_CTRL_IOCE | X_CTRL_FEIE | X_CTRL_LVBIE | X_CTRL_RPBM);

  0003f	6a 1d		 push	 29			; 0000001dH
  00041	6a 0b		 push	 11			; 0000000bH
  00043	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?PokeAciRegister8@CAc97Channel@DirectSound@@IAEXKE@Z ; DirectSound::CAc97Channel::PokeAciRegister8

; 1782 : 
; 1783 :     DPF_LEAVE_VOID();
; 1784 : }

  0004b	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0004e	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?Run@CAc97Channel@DirectSound@@QAEXK@Z ENDP		; DirectSound::CAc97Channel::Run
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?Pause@CAc97Channel@DirectSound@@QAEXXZ
DSOUND	SEGMENT
_this$ = -12
___AutoIrql$ = -8
?Pause@CAc97Channel@DirectSound@@QAEXXZ PROC NEAR	; DirectSound::CAc97Channel::Pause, COMDAT
; _this$ = ecx

; 1810 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1811 :     DPF_ENTER();
; 1812 :     AutoIrql();

  00009	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1813 : 
; 1814 :     PokeAciRegister8(X_CTRL, 0);

  00011	6a 00		 push	 0
  00013	6a 0b		 push	 11			; 0000000bH
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?PokeAciRegister8@CAc97Channel@DirectSound@@IAEXKE@Z ; DirectSound::CAc97Channel::PokeAciRegister8

; 1815 : 
; 1816 :     DPF_LEAVE_VOID();
; 1817 : }

  0001d	8d 4d f8	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00020	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?Pause@CAc97Channel@DirectSound@@QAEXXZ ENDP		; DirectSound::CAc97Channel::Pause
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetPrdIndeces@CAc97Channel@DirectSound@@IAEXEEHH@Z
DSOUND	SEGMENT
_this$ = -16
___AutoIrql$ = -12
_bLastPrd$ = -1
_bCurrentPrd$ = 8
_bPrdCount$ = 12
_fApplyCurrent$ = 16
_fApplyLast$ = 20
?SetPrdIndeces@CAc97Channel@DirectSound@@IAEXEEHH@Z PROC NEAR ; DirectSound::CAc97Channel::SetPrdIndeces, COMDAT
; _this$ = ecx

; 1850 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1851 :     BYTE                    bLastPrd;
; 1852 :     
; 1853 :     DPF_ENTER();
; 1854 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1855 : 
; 1856 :     //
; 1857 :     // Calculate the current and last valid PRDs
; 1858 :     //
; 1859 : 
; 1860 :     if(bPrdCount)

  00011	0f b6 45 0c	 movzx	 eax, BYTE PTR _bPrdCount$[ebp]
  00015	85 c0		 test	 eax, eax
  00017	74 50		 je	 SHORT $L40369

; 1861 :     {
; 1862 :         ASSERT(bPrdCount <= ACIPRDL_ENTRY_COUNT);
; 1863 : 
; 1864 :         bLastPrd = bCurrentPrd + bPrdCount - 1;

  00019	0f b6 4d 08	 movzx	 ecx, BYTE PTR _bCurrentPrd$[ebp]
  0001d	0f b6 55 0c	 movzx	 edx, BYTE PTR _bPrdCount$[ebp]
  00021	8d 44 11 ff	 lea	 eax, DWORD PTR [ecx+edx-1]
  00025	88 45 ff	 mov	 BYTE PTR _bLastPrd$[ebp], al

; 1865 : 
; 1866 :         if(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM)

  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0002e	83 e2 01	 and	 edx, 1
  00031	85 d2		 test	 edx, edx
  00033	74 16		 je	 SHORT $L40370

; 1867 :         {
; 1868 :             bCurrentPrd &= ACIPRDL_ENTRY_MASK;

  00035	0f b6 45 08	 movzx	 eax, BYTE PTR _bCurrentPrd$[ebp]
  00039	83 e0 1f	 and	 eax, 31			; 0000001fH
  0003c	88 45 08	 mov	 BYTE PTR _bCurrentPrd$[ebp], al

; 1869 :             bLastPrd &= ACIPRDL_ENTRY_MASK;

  0003f	0f b6 4d ff	 movzx	 ecx, BYTE PTR _bLastPrd$[ebp]
  00043	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00046	88 4d ff	 mov	 BYTE PTR _bLastPrd$[ebp], cl

; 1870 :         }
; 1871 :         else

  00049	eb 1c		 jmp	 SHORT $L40371
$L40370:

; 1872 :         {
; 1873 :             bCurrentPrd %= bPrdCount;

  0004b	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bPrdCount$[ebp]
  0004f	0f b6 45 08	 movzx	 eax, BYTE PTR _bCurrentPrd$[ebp]
  00053	99		 cdq
  00054	f7 f9		 idiv	 ecx
  00056	88 55 08	 mov	 BYTE PTR _bCurrentPrd$[ebp], dl

; 1874 :             bLastPrd %= bPrdCount;

  00059	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bPrdCount$[ebp]
  0005d	0f b6 45 ff	 movzx	 eax, BYTE PTR _bLastPrd$[ebp]
  00061	99		 cdq
  00062	f7 f9		 idiv	 ecx
  00064	88 55 ff	 mov	 BYTE PTR _bLastPrd$[ebp], dl
$L40371:

; 1875 :         }
; 1876 :     }
; 1877 :     else

  00067	eb 08		 jmp	 SHORT $L40372
$L40369:

; 1878 :     {
; 1879 :         bCurrentPrd = 0;

  00069	c6 45 08 00	 mov	 BYTE PTR _bCurrentPrd$[ebp], 0

; 1880 :         bLastPrd = 0;

  0006d	c6 45 ff 00	 mov	 BYTE PTR _bLastPrd$[ebp], 0
$L40372:

; 1881 :     }
; 1882 : 
; 1883 :     //
; 1884 :     // Inform the hardware
; 1885 :     //
; 1886 :     
; 1887 :     if(fApplyCurrent)

  00071	83 7d 10 00	 cmp	 DWORD PTR _fApplyCurrent$[ebp], 0
  00075	74 0e		 je	 SHORT $L40373

; 1888 :     {
; 1889 :         PokeAciRegister8(X_CUR_IDX, bCurrentPrd);

  00077	8a 55 08	 mov	 dl, BYTE PTR _bCurrentPrd$[ebp]
  0007a	52		 push	 edx
  0007b	6a 04		 push	 4
  0007d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?PokeAciRegister8@CAc97Channel@DirectSound@@IAEXKE@Z ; DirectSound::CAc97Channel::PokeAciRegister8
$L40373:

; 1890 :     }
; 1891 : 
; 1892 :     if(fApplyLast)

  00085	83 7d 14 00	 cmp	 DWORD PTR _fApplyLast$[ebp], 0
  00089	74 0e		 je	 SHORT $L40374

; 1893 :     {
; 1894 :         PokeAciRegister8(X_LST_IDX, bLastPrd);

  0008b	8a 45 ff	 mov	 al, BYTE PTR _bLastPrd$[ebp]
  0008e	50		 push	 eax
  0008f	6a 05		 push	 5
  00091	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?PokeAciRegister8@CAc97Channel@DirectSound@@IAEXKE@Z ; DirectSound::CAc97Channel::PokeAciRegister8
$L40374:

; 1895 :     }
; 1896 : 
; 1897 :     m_bCurrentPrd = bCurrentPrd;

  00099	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	8a 55 08	 mov	 dl, BYTE PTR _bCurrentPrd$[ebp]
  0009f	88 51 25	 mov	 BYTE PTR [ecx+37], dl

; 1898 :     m_bPrdCount = bPrdCount;

  000a2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	8a 4d 0c	 mov	 cl, BYTE PTR _bPrdCount$[ebp]
  000a8	88 48 24	 mov	 BYTE PTR [eax+36], cl

; 1899 : 
; 1900 :     DPF_AC97("(channel %lu) PRD indeces set to %d, %d (%d)", m_nChannelType, (int)bCurrentPrd, (int)bLastPrd, (int)bPrdCount);
; 1901 : 
; 1902 :     DPF_LEAVE_VOID();
; 1903 : }

  000ab	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  000ae	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 10 00	 ret	 16			; 00000010H
?SetPrdIndeces@CAc97Channel@DirectSound@@IAEXEEHH@Z ENDP ; DirectSound::CAc97Channel::SetPrdIndeces
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetMode@CAc97Channel@DirectSound@@QAEXK@Z
DSOUND	SEGMENT
_this$ = -16
___AutoIrql$ = -12
_dwMode$ = 8
?SetMode@CAc97Channel@DirectSound@@QAEXK@Z PROC NEAR	; DirectSound::CAc97Channel::SetMode, COMDAT
; _this$ = ecx

; 1929 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1930 :     BYTE                    bState;
; 1931 :     
; 1932 :     DPF_ENTER();
; 1933 :     AutoIrql();

  00009	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::CAutoIrql

; 1934 : 
; 1935 :     if(AC97_CHANNELTYPE_DIGITAL == m_nChannelType)

  00011	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00014	83 38 01	 cmp	 DWORD PTR [eax], 1
  00017	75 1a		 jne	 SHORT $L40381

; 1936 :     {
; 1937 :         //
; 1938 :         // Save the mode
; 1939 :         //
; 1940 : 
; 1941 :         m_dwMode = dwMode;

  00019	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 55 08	 mov	 edx, DWORD PTR _dwMode$[ebp]
  0001f	89 51 28	 mov	 DWORD PTR [ecx+40], edx

; 1942 : 
; 1943 :         //
; 1944 :         // Update the STWD register
; 1945 :         //
; 1946 : 
; 1947 :         PokeAciRegister32(X_STWD, m_dwMode);

  00022	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00028	51		 push	 ecx
  00029	6a 0c		 push	 12			; 0000000cH
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?PokeAciRegister32@CAc97Channel@DirectSound@@IAEXKK@Z ; DirectSound::CAc97Channel::PokeAciRegister32
$L40381:

; 1948 :     }
; 1949 : 
; 1950 :     DPF_LEAVE_VOID();
; 1951 : }

  00033	8d 4d f4	 lea	 ecx, DWORD PTR ___AutoIrql$[ebp]
  00036	e8 00 00 00 00	 call	 ??1CAutoIrql@DirectSound@@QAE@XZ ; DirectSound::CAutoIrql::~CAutoIrql
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?SetMode@CAc97Channel@DirectSound@@QAEXK@Z ENDP		; DirectSound::CAc97Channel::SetMode
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?SetPosition@CAc97Channel@DirectSound@@IAEXK@Z
DSOUND	SEGMENT
_this$ = -8
_dwLength$ = -4
_dwPosition$ = 8
?SetPosition@CAc97Channel@DirectSound@@IAEXK@Z PROC NEAR ; DirectSound::CAc97Channel::SetPosition, COMDAT
; _this$ = ecx

; 2151 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2152 :     DWORD               dwLength;
; 2153 : 
; 2154 :     DPF_ENTER();
; 2155 : 
; 2156 :     //
; 2157 :     // Make sure we're stopped
; 2158 :     //
; 2159 : 
; 2160 :     ASSERT(!PeekAciRegister8(X_CTRL));
; 2161 : 
; 2162 :     //
; 2163 :     // Convert byte position to samples
; 2164 :     //
; 2165 : 
; 2166 :     dwPosition /= m_pDevice->m_wfxFormat.wBitsPerSample / 8;

  00009	0f b7 05 0e 00
	00 00		 movzx	 eax, WORD PTR ?m_wfxFormat@CAc97Device@DirectSound@@2UtWAVEFORMATEX@@B+14
  00010	99		 cdq
  00011	83 e2 07	 and	 edx, 7
  00014	03 c2		 add	 eax, edx
  00016	8b c8		 mov	 ecx, eax
  00018	c1 f9 03	 sar	 ecx, 3
  0001b	8b 45 08	 mov	 eax, DWORD PTR _dwPosition$[ebp]
  0001e	33 d2		 xor	 edx, edx
  00020	f7 f1		 div	 ecx
  00022	89 45 08	 mov	 DWORD PTR _dwPosition$[ebp], eax

; 2167 : 
; 2168 :     //
; 2169 :     // Convert buffer position to samples remaining
; 2170 :     //
; 2171 : 
; 2172 :     dwLength = m_pPrdl[m_bCurrentPrd].wLength;

  00025	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00028	0f b6 42 25	 movzx	 eax, BYTE PTR [edx+37]
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00032	8b 44 c2 04	 mov	 eax, DWORD PTR [edx+eax*8+4]
  00036	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003b	89 45 fc	 mov	 DWORD PTR _dwLength$[ebp], eax

; 2173 :     ASSERT(dwPosition <= dwLength);
; 2174 :     
; 2175 :     dwPosition = dwLength - dwPosition;

  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _dwLength$[ebp]
  00041	2b 4d 08	 sub	 ecx, DWORD PTR _dwPosition$[ebp]
  00044	89 4d 08	 mov	 DWORD PTR _dwPosition$[ebp], ecx

; 2176 : 
; 2177 :     //
; 2178 :     // Set the position
; 2179 :     //
; 2180 : 
; 2181 :     ASSERT(dwPosition < 0xFFFF);
; 2182 :     PokeAciRegister16(X_CUR_POS, (WORD)dwPosition);

  00047	66 8b 55 08	 mov	 dx, WORD PTR _dwPosition$[ebp]
  0004b	52		 push	 edx
  0004c	6a 08		 push	 8
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?PokeAciRegister16@CAc97Channel@DirectSound@@IAEXKG@Z ; DirectSound::CAc97Channel::PokeAciRegister16

; 2183 : 
; 2184 :     //
; 2185 :     // Clear the last returned position
; 2186 :     //
; 2187 : 
; 2188 :     m_dwLastPosition = 0;

  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 2189 : 
; 2190 :     DPF_LEAVE_VOID();
; 2191 : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?SetPosition@CAc97Channel@DirectSound@@IAEXK@Z ENDP	; DirectSound::CAc97Channel::SetPosition
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dsound\common\refcount.h
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCDirectSound@1@PAV21@@Z
DSOUND	SEGMENT
_p$ = 8
?__AddRef@DirectSound@@YGPAVCDirectSound@1@PAV21@@Z PROC NEAR ; DirectSound::__AddRef, COMDAT

; 68   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :         if(p)

  00003	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  00007	74 0c		 je	 SHORT $L40389

; 70   :         {
; 71   :             p->AddRef();

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00011	52		 push	 edx
  00012	ff 51 04	 call	 DWORD PTR [ecx+4]
$L40389:

; 72   :         }
; 73   : 
; 74   :         return p;

  00015	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]

; 75   :     }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?__AddRef@DirectSound@@YGPAVCDirectSound@1@PAV21@@Z ENDP ; DirectSound::__AddRef
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCWaveFileMediaObject@1@PAV21@@Z
DSOUND	SEGMENT
_p$ = 8
?__AddRef@DirectSound@@YGPAVCWaveFileMediaObject@1@PAV21@@Z PROC NEAR ; DirectSound::__AddRef, COMDAT

; 68   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :         if(p)

  00003	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  00007	74 0b		 je	 SHORT $L40391

; 70   :         {
; 71   :             p->AddRef();

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00011	52		 push	 edx
  00012	ff 11		 call	 DWORD PTR [ecx]
$L40391:

; 72   :         }
; 73   : 
; 74   :         return p;

  00014	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]

; 75   :     }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?__AddRef@DirectSound@@YGPAVCWaveFileMediaObject@1@PAV21@@Z ENDP ; DirectSound::__AddRef
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCFileMediaObject@1@PAV21@@Z
DSOUND	SEGMENT
_p$ = 8
?__AddRef@DirectSound@@YGPAVCFileMediaObject@1@PAV21@@Z PROC NEAR ; DirectSound::__AddRef, COMDAT

; 68   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :         if(p)

  00003	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  00007	74 0b		 je	 SHORT $L40393

; 70   :         {
; 71   :             p->AddRef();

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00011	52		 push	 edx
  00012	ff 11		 call	 DWORD PTR [ecx]
$L40393:

; 72   :         }
; 73   : 
; 74   :         return p;

  00014	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]

; 75   :     }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?__AddRef@DirectSound@@YGPAVCFileMediaObject@1@PAV21@@Z ENDP ; DirectSound::__AddRef
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCAc97MediaObject@1@PAV21@@Z
DSOUND	SEGMENT
_p$ = 8
?__AddRef@DirectSound@@YGPAVCAc97MediaObject@1@PAV21@@Z PROC NEAR ; DirectSound::__AddRef, COMDAT

; 68   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :         if(p)

  00003	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  00007	74 0b		 je	 SHORT $L40395

; 70   :         {
; 71   :             p->AddRef();

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00011	52		 push	 edx
  00012	ff 11		 call	 DWORD PTR [ecx]
$L40395:

; 72   :         }
; 73   : 
; 74   :         return p;

  00014	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]

; 75   :     }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?__AddRef@DirectSound@@YGPAVCAc97MediaObject@1@PAV21@@Z ENDP ; DirectSound::__AddRef
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCDirectSoundBuffer@1@PAV21@@Z
DSOUND	SEGMENT
_p$ = 8
?__AddRef@DirectSound@@YGPAVCDirectSoundBuffer@1@PAV21@@Z PROC NEAR ; DirectSound::__AddRef, COMDAT

; 68   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :         if(p)

  00003	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  00007	74 0c		 je	 SHORT $L40397

; 70   :         {
; 71   :             p->AddRef();

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00011	52		 push	 edx
  00012	ff 51 04	 call	 DWORD PTR [ecx+4]
$L40397:

; 72   :         }
; 73   : 
; 74   :         return p;

  00015	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]

; 75   :     }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?__AddRef@DirectSound@@YGPAVCDirectSoundBuffer@1@PAV21@@Z ENDP ; DirectSound::__AddRef
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCMcpxVoiceClient@1@PAV21@@Z
DSOUND	SEGMENT
_p$ = 8
?__AddRef@DirectSound@@YGPAVCMcpxVoiceClient@1@PAV21@@Z PROC NEAR ; DirectSound::__AddRef, COMDAT

; 68   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :         if(p)

  00003	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  00007	74 0c		 je	 SHORT $L40399

; 70   :         {
; 71   :             p->AddRef();

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00011	52		 push	 edx
  00012	ff 51 04	 call	 DWORD PTR [ecx+4]
$L40399:

; 72   :         }
; 73   : 
; 74   :         return p;

  00015	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]

; 75   :     }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?__AddRef@DirectSound@@YGPAVCMcpxVoiceClient@1@PAV21@@Z ENDP ; DirectSound::__AddRef
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCDirectSoundVoiceSettings@1@PAV21@@Z
DSOUND	SEGMENT
_p$ = 8
?__AddRef@DirectSound@@YGPAVCDirectSoundVoiceSettings@1@PAV21@@Z PROC NEAR ; DirectSound::__AddRef, COMDAT

; 68   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :         if(p)

  00003	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  00007	74 0c		 je	 SHORT $L40401

; 70   :         {
; 71   :             p->AddRef();

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00011	52		 push	 edx
  00012	ff 51 04	 call	 DWORD PTR [ecx+4]
$L40401:

; 72   :         }
; 73   : 
; 74   :         return p;

  00015	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]

; 75   :     }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?__AddRef@DirectSound@@YGPAVCDirectSoundVoiceSettings@1@PAV21@@Z ENDP ; DirectSound::__AddRef
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCDirectSoundBufferSettings@1@PAV21@@Z
DSOUND	SEGMENT
_p$ = 8
?__AddRef@DirectSound@@YGPAVCDirectSoundBufferSettings@1@PAV21@@Z PROC NEAR ; DirectSound::__AddRef, COMDAT

; 68   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :         if(p)

  00003	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  00007	74 0c		 je	 SHORT $L40403

; 70   :         {
; 71   :             p->AddRef();

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00011	52		 push	 edx
  00012	ff 51 04	 call	 DWORD PTR [ecx+4]
$L40403:

; 72   :         }
; 73   : 
; 74   :         return p;

  00015	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]

; 75   :     }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?__AddRef@DirectSound@@YGPAVCDirectSoundBufferSettings@1@PAV21@@Z ENDP ; DirectSound::__AddRef
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCMcpxAPU@1@PAV21@@Z
DSOUND	SEGMENT
_p$ = 8
?__AddRef@DirectSound@@YGPAVCMcpxAPU@1@PAV21@@Z PROC NEAR ; DirectSound::__AddRef, COMDAT

; 68   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :         if(p)

  00003	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  00007	74 0c		 je	 SHORT $L40405

; 70   :         {
; 71   :             p->AddRef();

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00011	52		 push	 edx
  00012	ff 51 04	 call	 DWORD PTR [ecx+4]
$L40405:

; 72   :         }
; 73   : 
; 74   :         return p;

  00015	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]

; 75   :     }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?__AddRef@DirectSound@@YGPAVCMcpxAPU@1@PAV21@@Z ENDP	; DirectSound::__AddRef
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCDirectSoundSettings@1@PAV21@@Z
DSOUND	SEGMENT
_p$ = 8
?__AddRef@DirectSound@@YGPAVCDirectSoundSettings@1@PAV21@@Z PROC NEAR ; DirectSound::__AddRef, COMDAT

; 68   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :         if(p)

  00003	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  00007	74 0c		 je	 SHORT $L40407

; 70   :         {
; 71   :             p->AddRef();

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00011	52		 push	 edx
  00012	ff 51 04	 call	 DWORD PTR [ecx+4]
$L40407:

; 72   :         }
; 73   : 
; 74   :         return p;

  00015	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]

; 75   :     }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?__AddRef@DirectSound@@YGPAVCDirectSoundSettings@1@PAV21@@Z ENDP ; DirectSound::__AddRef
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ?__AddRef@DirectSound@@YGPAVCMcpxSlopMemoryHeap@1@PAV21@@Z
DSOUND	SEGMENT
_p$ = 8
?__AddRef@DirectSound@@YGPAVCMcpxSlopMemoryHeap@1@PAV21@@Z PROC NEAR ; DirectSound::__AddRef, COMDAT

; 68   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :         if(p)

  00003	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  00007	74 0c		 je	 SHORT $L40409

; 70   :         {
; 71   :             p->AddRef();

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00011	52		 push	 edx
  00012	ff 51 04	 call	 DWORD PTR [ecx+4]
$L40409:

; 72   :         }
; 73   : 
; 74   :         return p;

  00015	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]

; 75   :     }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?__AddRef@DirectSound@@YGPAVCMcpxSlopMemoryHeap@1@PAV21@@Z ENDP ; DirectSound::__AddRef
; Function compile flags: /Odt
DSOUND	ENDS
;	COMDAT ??_ECMcpxAPU@DirectSound@@W7AEPAXI@Z
_TEXT	SEGMENT
??_ECMcpxAPU@DirectSound@@W7AEPAXI@Z PROC NEAR		; DirectSound::CMcpxAPU::`vector deleting destructor', COMDAT
  00000	83 e9 08	 sub	 ecx, 8
  00003	e9 00 00 00 00	 jmp	 ??_ECMcpxAPU@DirectSound@@UAEPAXI@Z
??_ECMcpxAPU@DirectSound@@W7AEPAXI@Z ENDP		; DirectSound::CMcpxAPU::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?m_dwAvailable@CMcpxSlopMemoryHeap@DirectSound@@2AAKA ; DirectSound::CMcpxSlopMemoryHeap::m_dwAvailable
PUBLIC	?m_dwUsed@CMcpxSlopMemoryHeap@DirectSound@@2AAKA ; DirectSound::CMcpxSlopMemoryHeap::m_dwUsed
DSOUND_URW	SEGMENT
?m_dwAvailable@CMcpxSlopMemoryHeap@DirectSound@@2AAKA DD 01H DUP (?) ; DirectSound::CMcpxSlopMemoryHeap::m_dwAvailable
?m_dwUsed@CMcpxSlopMemoryHeap@DirectSound@@2AAKA DD 01H DUP (?) ; DirectSound::CMcpxSlopMemoryHeap::m_dwUsed
DSOUND_URW	ENDS
END
