//****************************************************************************
//
// XBox true-type font scan converter library
//
// History:
//
//   07/06/00 [andrewso] - Created
//   08/04/00 [andrewso] - Added compressed glyph bitmaps
//
//****************************************************************************

#ifdef _XBOX

#include <xtl.h>
#include <xdbg.h>
#include "xfont.h"
#include "xfontformat.h"

#else 

#include <windows.h>
#include "xfont-pc.h"
#include "xfontformat-pc.h"

#endif

#include <stdio.h>
#include <stdarg.h>
#include <assert.h>
#include <d3d8.h>

#include "font.h"
#include "default.h"

//****************************************************************************
// Definitions.
//****************************************************************************

//
// Forwards.
//

HRESULT __stdcall GenerateFontMetrics(Font *);

HRESULT __fastcall XFONT_GetCharacterData(XFONT *,WCHAR, Glyph **, unsigned *);

// Cache methods.
HRESULT __stdcall InitializeCache(Font *, unsigned cbCacheSize);
static BOOL CheckInCache(Font *, WCHAR wch, Glyph **ppGlyph, unsigned *pcbGlyphSize);
static void FreeCacheSpace(Font *, unsigned cbSizeNeeded);

//****************************************************************************
// The APIs
//****************************************************************************

//============================================================================
// Loads a bitmap font of the format defined in xfontformat.h.
//
// This method always allocates ~112 bytes for each font to store the
// font's state.  Additional memory will be allocated depending on the
// value of the uCacheSize parameter:
//
//    0                            - an allocation to hold the bitmap for the 
//                                   last drawn glyph.  The glyph information
//                                   is ready directly out of the file. 
//                                   Very slow.

//    uCacheSize < font file size  - a block of memory of size uCacheSize 
//                                   holds the most recently drawn glyphs.  
//                                   The glyph information is ready directly 
//                                   out of the file.  This can perform 
//                                   reasonably if the cache is sized
//                                   correctly as determined by experimentation.
//
//    uCacheSize >= font file size - a block of memory just large enough to 
//                                   hold the contents of the file will be 
//                                   allocated and the entire font file will 
//                                   be loaded into it.  Very fast.
//
// This automatically sets the opened font as the one that is currently
// active.  The attributes of the font are all set to their defaults.
//============================================================================

HRESULT __stdcall XFONT_OpenBitmapFont
(
    LPCWSTR wszFileName,    // [in] The file name of the font
    unsigned uCacheSize,    // [in] The size of the font cache, in bytes.
    XFONT **ppFont          // [out] The font identifier
)
{
    HRESULT hr;
    Font *pFont = NULL;
    BOOL fUseCache;

    XFNULL(wszFileName, "Invalid file name string - wszFileName");
    XFNULL(ppFont, "Invalid font output parameters - ppFont");

    // Initialize the bitmap package.
    hr = BP_OpenBitmapFont(wszFileName, uCacheSize, &pFont, &fUseCache);

    if (FAILED(hr))
    {
        goto Error;
    }

    if (fUseCache)
    {
        hr = InitializeCache(pFont, uCacheSize);

        if (FAILED(hr))
        {
            goto Error;
        }
    }

    // Reset the font metrics.
    hr = GenerateFontMetrics(pFont);

    if (FAILED(hr))
    {
        goto Error;
    }

    // Set the font style defaults.
    pFont->uAlignmentMode   = XFONT_TOP | XFONT_LEFT;
    pFont->TextColor        = 0xFFFFFFFF;
    pFont->BackgroundColor  = 0x00000000;
    pFont->fPaintBackground = FALSE;

    // Return it.
    *ppFont = (XFONT *)pFont;

    return NOERROR;

Error:
    if (pFont)
    {
        XFONT_Release((XFONT *)pFont);
    }

    return hr;
}

//============================================================================
// Loads a bitmap font of the format defined in xfontformat.h from a block
// of memory, either one that has been loaded into memory by the caller
// or one that is compiled into the title from a source code file
// generated by makefont.exe.
//
// This method always allocates ~112 bytes for each font to store the font's
// current state.  No additional memory will be allocated throughout the 
// lifetime of the font.
//
// The caller must ensure that the memory block that contains the font data
// will live at least as long as the font as it will keep referencing that
// data when it draws.
// 
//============================================================================

HRESULT __stdcall XFONT_OpenBitmapFontFromMemory
(
    CONST void *pFontData,  // [in] The block of font data
    unsigned uFontDataSize, // [in] The size of the font data
    XFONT **ppFont          // [out] The font identifier
)
{
    HRESULT hr;
    Font *pFont = NULL;
    BOOL fUseCache;

    XFNULL(pFontData, "Invalid font data pointer - pFontData");
    XFNULL(ppFont, "Invalid font output parameters - ppFont");

    // Initialize the bitmap package.
    hr = BP_OpenBitmapFontFromMemory(pFontData, uFontDataSize, &pFont);

    if (FAILED(hr))
    {
        goto Error;
    }

    // Reset the font metrics.
    hr = GenerateFontMetrics(pFont);

    if (FAILED(hr))
    {
        goto Error;
    }

    // Set the font style defaults.
    pFont->uAlignmentMode   = XFONT_TOP | XFONT_LEFT;
    pFont->TextColor        = 0xFFFFFFFF;
    pFont->BackgroundColor  = 0x00000000;
    pFont->fPaintBackground = FALSE;

    // Return it.
    *ppFont = (XFONT *)pFont;

    return NOERROR;

Error:
    if (pFont)
    {
        XFONT_Release((XFONT *)pFont);
    }

    return hr;
}

//============================================================================
// Loads the default bitmap font that is compiled directy into the library.
// This is a 24-hight arial font the contains only the western character set 
// and is intended as a convenience for titles that just need a quick way of
// displaying information.
//
// This will also allocate ~112 bytes of memory each time this method is 
// called but will never allocate any more memory throughout the lifetime
// of the font.
//
//============================================================================

HRESULT __stdcall XFONT_OpenDefaultFont
(
    XFONT **ppFont          // [out] The font identifier
)
{
    return XFONT_OpenBitmapFontFromMemory(g_DefaultFont, 
                                          sizeof(g_DefaultFont), 
                                          ppFont);
}

//============================================================================
// XFONT_OpenTrueTypeFont is defined in 'TrueType.cpp' to make the linker
// happy when "xfont.lib" is consumed without the truetype support.
//============================================================================

//============================================================================
// Add a refcount to the font.
//============================================================================

void __stdcall XFONT_AddRef
(
    XFONT *pXFont            // [in] The id of the font
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    pFont->uReferenceCount++;
}


//============================================================================
// Unload a font and free all of its memory.  The XFONT identifier will be 
// invalidated.
//============================================================================

void __stdcall XFONT_Release
(
    XFONT *pXFont       // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");
    XFASSERT(pFont->uReferenceCount != 0, "Reference count underflow.");

    if (pFont->uReferenceCount == 1)
    {
        BYTE *pbCache = pFont->pbCache;

        // Let the particular font package clean up.  This will free the
        // Font structure.
        //
        pFont->pfnUnloadFont(pFont);

        // Free the cache.
        free(pbCache);
    }
    else
    {
        pFont->uReferenceCount--;
    }
}

//============================================================================
// Sets the height of the text cell, in pixels, for the current font.
//
// Defaults to 16 pixels high.  This may only be set on a TrueType font.
//============================================================================

unsigned __stdcall XFONT_GetTextHeight
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->uCellHeight;
}

HRESULT __stdcall XFONT_SetTextHeight
(
    XFONT *pXFont,          // [in] The id of the font to unload
    unsigned uHeight        // [in] The total height of the text cell
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    if (uHeight != pFont->uCellHeight)
    {
        HRESULT hr;

        unsigned uOldCellHeight = pFont->uCellHeight;

        // Tell the font engine.
        pFont->uCellHeight = uHeight;

        hr = pFont->pfnResetTransform(pFont);

        if (FAILED(hr))
        {
            pFont->uCellHeight = uOldCellHeight;

            return hr;
        }

        // Regenerate the height information.
        hr = GenerateFontMetrics(pFont);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    return NOERROR;
}

//============================================================================
// Sets the amount of antialias information to include in the bitmap with
// valid values of 0 (no information), 2, or 4 (lots of information).
//
// The antialiasing works best for larger or bold fonts whose strokes are 
// more the one pixel wide.  
//
// This may only be set on a TrueType font.  Defaults to 0.
//============================================================================

unsigned __stdcall XFONT_GetTextAntialiasLevel
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->uAntialiasLevel;
}

HRESULT __stdcall XFONT_SetTextAntialiasLevel
(
    XFONT *pXFont,          // [in] The id of the font to unload
    unsigned uAntialiasLevel
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    XFASSERT(uAntialiasLevel == 0 || uAntialiasLevel == 2 || uAntialiasLevel == 4,
             "Bad Antialias level.");

    if (pFont->uAntialiasLevel != uAntialiasLevel)
    {
        HRESULT hr;

        unsigned uOldAntialiasLevel = pFont->uAntialiasLevel;

        pFont->uAntialiasLevel = uAntialiasLevel;

        hr = pFont->pfnResetTransform(pFont);

        if (FAILED(hr))
        {
            pFont->uAntialiasLevel = uOldAntialiasLevel;
        }

        return hr;
    }
    else
    {
        return NOERROR;
    }
}

//============================================================================
// Sets the size of the RLE packet used to compress the internal bitmaps
// used by the font.  This may effect the number of bitmaps that can fit
// in the internal cache depending on the size and characteristics of your
// font.  May be 2 - 8.
//
// This may only be set on a TrueType font.  Defaults to 2.
//============================================================================

unsigned __stdcall XFONT_GetRLEWidth
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->uRLEWidth;
}

HRESULT __stdcall XFONT_SetRLEWidth
(
    XFONT *pXFont,          // [in] The id of the font to unload
    unsigned uRLEWidth
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    XFASSERT(uRLEWidth >= 2 && uRLEWidth <=8, "Bad RLE Width value, must be between 2 and 8.");

    if (pFont->uRLEWidth != uRLEWidth)
    {
        HRESULT hr;

        unsigned uOldRLEWidth = pFont->uRLEWidth;

        pFont->uRLEWidth = uRLEWidth;

        hr = pFont->pfnResetTransform(pFont);

        if (FAILED(hr))
        {
            pFont->uRLEWidth = uOldRLEWidth;
        }

        return hr;
    }
    else
    {
        return NOERROR;
    }
}

//============================================================================
// Sets the style for the text, one of NORMAL, BOLD, ITALICS or BOLDITALICS.
// This will cause the TrueType font scaler to simulate these styles when
// generating the bitmaps for the font.  If the font defines the different
// styles in separate TTF files then load each individually instead of 
// using this method.
//
// Defaults to NORMAL.  This may only be set on a TrueType font.
//============================================================================

unsigned __stdcall XFONT_GetTextStyle
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->uStyle;
}

HRESULT __stdcall XFONT_SetTextStyle
(
    XFONT *pXFont,          // [in] The id of the font to unload
    unsigned uStyle
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    XFASSERT(uStyle <= XFONT_BOLDITALICS, "Bad Style parameter")

    if (pFont->uStyle != uStyle)
    {
        HRESULT hr;

        unsigned uOldStyle = pFont->uStyle;

        pFont->uStyle = uStyle;

        hr = pFont->pfnResetTransform(pFont);

        if (FAILED(hr))
        {
            pFont->uStyle = uOldStyle;
        }

        return hr;
    }
    else
    {
        return NOERROR;
    }
}

//============================================================================
// Sets to what part of the text the coordinates passed to XFONT_TextOut refers.
//
// The only parameter must contain one vertical value ORed with one 
// horizontal value.
//
// The vertical alignment value specifies which part of the text is pointed
// to by the y coordinate:
//
//      XFONT_BASELINE  - the baseline of the text
//      XFONT_BOTTOM    - the bottom of the character cell
//      XFONT_TOP       - the top of the character cell
//
// The horizontal alignment value specifies which part of the text is pointed
// to by the x coordinate:
//
//      XFONT_CENTER    - the center of the text
//      XFONT_LEFT      - the leftmost edge of the text
//      XFONT_RIGHT     - the rightmost edge of the text
//
// Defaults to TA_TOP | TA_LEFT.
//============================================================================

unsigned __stdcall XFONT_GetTextAlignment
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->uAlignmentMode;    
}

void __stdcall XFONT_SetTextAlignment
(
    XFONT *pXFont,          // [in] The id of the font to unload
    unsigned uMode
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    // UNDONE: validate this parameter.
    pFont->uAlignmentMode = uMode;    
}

//============================================================================
// Sets the color for the text.  
//
// Defaults to 0xFFFFFFFF (white)
//============================================================================

D3DCOLOR __stdcall XFONT_GetTextColor
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->TextColor;
}

void __stdcall XFONT_SetTextColor
(
    XFONT *pXFont,          // [in] The id of the font to unload
    D3DCOLOR color          // [in] The color of the text
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    pFont->TextColor = color;
}

//============================================================================
// Sets the color with which to fill the background of the text.  
//
// Defaults to 0x00000000 (black)
//============================================================================

D3DCOLOR __stdcall XFONT_GetBkColor
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->BackgroundColor;
}

void __stdcall XFONT_SetBkColor
(
    XFONT *pXFont,          // [in] The id of the font to unload
    D3DCOLOR color          // [in] The color of the text
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    pFont->BackgroundColor = color;
}

//============================================================================
// Sets whether to fill the background of the text cell with the background
// color.
//
// Defaults to XFONT_TRANSPARENT because it is more efficient.
//============================================================================

int __stdcall XFONT_GetBkMode
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->fPaintBackground;
}

void __stdcall XFONT_SetBkMode
(
    XFONT *pXFont,          // [in] The id of the font to unload
    int iBkMode             // [in] Either XFONT_OPAQUE or XFONT_TRANSPARENT
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    XFASSERT(iBkMode == XFONT_OPAQUE || iBkMode == XFONT_TRANSPARENT, "Bad BkMode parameter.");

    pFont->fPaintBackground = iBkMode == XFONT_OPAQUE;
}

//============================================================================
// Sets the number of additional pixels to put between each character.
//============================================================================

unsigned __stdcall XFONT_GetIntercharacterSpacing
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->uIntercharacterSpacing;
}

void __stdcall XFONT_SetIntercharacterSpacing
(
    XFONT *pXFont,          // [in] The id of the font to unload
    unsigned uSpaces        // [in] The number of extra pixels between each character
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    pFont->uIntercharacterSpacing = uSpaces;
}

//============================================================================
// Sets the clipping rectangle.  Pass NULL to clear.
//============================================================================

D3DRECT *__stdcall XFONT_GetClippingRectangle
(
    XFONT *pXFont          // [in] The id of the font
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    if (pFont->fUseClippingRectangle)
    {
        pFont->ClippingRectangleCopy = pFont->ClippingRectangle;

        return &pFont->ClippingRectangleCopy;
    }
    else
    {
        return NULL;
    }
}

void __stdcall XFONT_SetClippingRectangle
(
    XFONT *pXFont,          // [in] The id of the font
    D3DRECT *pRectangle     // [in] Clipping rectangle
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    if (pRectangle)
    {
        pFont->fUseClippingRectangle = TRUE;
        pFont->ClippingRectangle = *pRectangle;
    }
    else
    {
        pFont->fUseClippingRectangle = FALSE;
    }
}

//============================================================================
// Get the vertical metrics for the current font settings.  
//============================================================================

void __stdcall XFONT_GetFontMetrics
(
    XFONT *pXFont,          // [in] The id of the font to unload
    unsigned *puCellHeight,     
    unsigned *puDescent
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    if (puCellHeight)
    {
        *puCellHeight = pFont->uCellHeight;
    }

    if (puDescent)
    {
        *puDescent = pFont->uDescent;
    }
}

//============================================================================
// Get the width of a string in pixels. This method applies any 
// intercharacter spacing.
//============================================================================

HRESULT __stdcall XFONT_GetTextExtent
(
    XFONT *pXFont,          // [in] The id of the font to unload
    LPCWSTR wstr,           // [in] The string
    unsigned cch,           // [in] The length of the string, -1 for a zero terminated string
    unsigned *puWidth       // [out] The width of the string in pixels
)
{
    HRESULT hr;

    Font *pFont = (Font *)pXFont;
    unsigned uIntercharacterSpacing;

    Glyph *pGlyph;
    unsigned cbGlyphSize;

    unsigned ich = 0;
    unsigned uWidth = 0;
    
    XFNULL(pFont, "Invalid font pointer.");

    uIntercharacterSpacing = pFont->uIntercharacterSpacing;

    for (;;)
    {
        hr = XFONT_GetCharacterData(pXFont, *wstr, &pGlyph, &cbGlyphSize);

        if (FAILED(hr)) 
        {
            return hr;
        }

        uWidth += pGlyph->uAdvance;

        // Increment.
        ich++;
        wstr++;

        // Stop?
        if (ich == cch || !*wstr)
        {
            break;
        }

        // Add the intercharacter space.
        uWidth += uIntercharacterSpacing;
    }

    *puWidth = uWidth;

    return NOERROR;
}

//============================================================================
// Draw the text on a surface.  See XFONT_SetTextAlignment for the meaning of
// the x and y coordinates.
//============================================================================

HRESULT __stdcall XFONT_TextOutToMemory
(
    XFONT *pXFont,          // [in] The id of the font to unload
    LPCVOID pBits,          // [in] Memory to write to.
    unsigned Pitch,         // [in] The pitch of that memory.
    unsigned Width,         // [in] Width, in pixels, of the memory
    unsigned Height,        // [in] Hight, in pixels, of the memory.
    D3DFORMAT Format,       // [in] Format of the pixels in the memory.
    LPCWSTR wstr,           // [in] The string
    unsigned cch,           // [in] The length of the string, -1 for a zero terminated string
    long x,                 // [in] The x coordinate of the string
    long y                  // [in] The y coordinate of the string
)
{
    HRESULT hr;

    long lCharacterX;
    long lCharacterY;

    DWORD uClipLeft;
    DWORD uClipTop;
    DWORD uClipRight;
    DWORD uClipBottom;

    //
    // Figure out where to start drawing from.  The rendering package
    // always wants the coordinates of the baseline of the glyph
    // so figure out how we need to munge the values.
    //

    const unsigned uVerticalMask = XFONT_BASELINE | XFONT_BOTTOM | XFONT_TOP;
    const unsigned uHorizontalMask = XFONT_LEFT | XFONT_CENTER | XFONT_RIGHT;

    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");
    XFNULL(pBits, "Invalid bits pointer.");
    XFNULL(wstr,  "Invalid string pointer.");

    // Vertical munging.
    switch(pFont->uAlignmentMode & uVerticalMask)
    {
    default:
        assert(FALSE);     // How did this get through our checks?

        // fall through
    case XFONT_TOP:
        lCharacterY = y;
        break;

    case XFONT_BASELINE:
        lCharacterY = y - (pFont->uCellHeight - pFont->uDescent);
        break;

    case XFONT_BOTTOM:
        lCharacterY = y - pFont->uCellHeight;
        break;
    }

    // Horizontal munging.
    if ((pFont->uAlignmentMode & uHorizontalMask) == XFONT_LEFT)
    {
        lCharacterX = x;
    }
    else
    {
        unsigned uWidth;

        hr = XFONT_GetTextExtent(pXFont, wstr, cch, &uWidth);

        if (FAILED(hr))
        {
            return hr;
        }

        if ((pFont->uAlignmentMode & uHorizontalMask) == XFONT_CENTER)
        {
            lCharacterX = x - uWidth / 2;
        }
        else if ((pFont->uAlignmentMode & uHorizontalMask) == XFONT_RIGHT)
        {
            lCharacterX = x - uWidth;
        }
        else
        {
            assert(FALSE);

            lCharacterX = x;
        }
    }

    // Get information about this surface.
    if (pFont->fUseClippingRectangle)
    {
        uClipLeft   = max(0, pFont->ClippingRectangle.x1);
        uClipTop    = max(0, pFont->ClippingRectangle.y1);
        uClipRight  = min((long)Width, pFont->ClippingRectangle.x2);
        uClipBottom = min((long)Height, pFont->ClippingRectangle.y2);
    }
    else
    {
        uClipLeft   = 0;
        uClipTop    = 0;
        uClipRight  = Width;
        uClipBottom = Height;
    }

    // Draw the string. Just clip to the surface size for now.
    hr = PaintText(pFont, 
                   pBits,
                   Pitch,
                   Format,
                   wstr, 
                   cch, 
                   lCharacterX, 
                   lCharacterY,
                   uClipLeft,
                   uClipTop,
                   uClipRight,
                   uClipBottom);

    return hr;
}

#ifdef _XBOX

//============================================================================
// Draw the text on a surface.  See XFONT_SetTextAlignment for the meaning of
// the x and y coordinates.  This does not work for swizzled surfaces!
//============================================================================

HRESULT __stdcall XFONT_TextOut
(
    XFONT *pXFont,          // [in] The id of the font to unload
    IDirect3DSurface8 *pSurface,    // [in] The surface to draw the text on or NULL
    LPCWSTR wstr,           // [in] The string
    unsigned cch,           // [in] The length of the string, -1 for a zero terminated string
    long x,                 // [in] The x coordinate of the string
    long y                  // [in] The y coordinate of the string
)
{
    D3DSURFACE_DESC SurfaceDesc;
    D3DLOCKED_RECT Lock;

    HRESULT hresult;

    XFNULL(pSurface, "Invalid surface pointer.");

    D3DSurface_GetDesc(pSurface, &SurfaceDesc);
    D3DSurface_LockRect(pSurface, &Lock, NULL, D3DLOCK_TILED);

    hresult = XFONT_TextOutToMemory(pXFont, 
                                    Lock.pBits, 
                                    Lock.Pitch, 
                                    SurfaceDesc.Width, 
                                    SurfaceDesc.Height, 
                                    SurfaceDesc.Format, 
                                    wstr, 
                                    cch, 
                                    x, 
                                    y);

    D3DSurface_UnlockRect(pSurface);

    return hresult;
}

#endif _XBOX

//****************************************************************************
// This method isn't really exposed in the header file.  It isn't static 
// because the makefont utility calls it when building the bitmap glyph
// information.
//****************************************************************************

//============================================================================
// Gets the character data from the current font, regardless of whether 
// it is a TrueType or bitmap font.
//
// The information returned by this method is only guarenteed to be valid
// until the next call to the font package.  This stuff might be stored
// in a cache and get flushed with the next call.
//============================================================================

HRESULT __fastcall XFONT_GetCharacterData
(
    XFONT *pXFont,          // [in] The id of the font to unload
    WCHAR wch, 
    Glyph **ppGlyph,
    unsigned *pcbGlyphSize
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");
    XFNULL(ppGlyph, "Invalid glyph pointer.");

    // Check the cache first unless we don't have one.
    if (pFont->pbCache && CheckInCache(pFont, wch, ppGlyph, pcbGlyphSize))
    {
        return NOERROR;
    }

    return pFont->pfnGetCharacterData(pFont, wch, ppGlyph, pcbGlyphSize);
}

//****************************************************************************
// Implementation
//****************************************************************************

//============================================================================
// Figure out the vertical height information for this font.
//============================================================================

HRESULT __stdcall GenerateFontMetrics
(
    Font *pFont
)
{
    HRESULT hr;

    Glyph *pGlyph;
    unsigned cbGlyphSize;

    // Figure out the descent, this is defined to be
    // the amount that a lower case 'g' hangs below the baseline.
    // It can be computed by getting the height of the 'g' and
    // subtracting the y component of its bearing.
    //      
    hr = XFONT_GetCharacterData((XFONT *)pFont, L'g', &pGlyph, &cbGlyphSize);

    if (FAILED(hr))
    {
        return hr;
    }

    pFont->uDescent = pGlyph->uBitmapHeight - pGlyph->iBearingY;

    return NOERROR;
}

//****************************************************************************
// Cache implementation.
//****************************************************************************

//
// The design for the cache errors on the side of simplicitly.  If anybody
// decides to actually use the TrueType package then they will probably
// want to put in something a bit more efficient.
//

//============================================================================
// Initialize the cache.
//============================================================================

HRESULT __stdcall InitializeCache
(
    Font *pFont,
    unsigned cbCacheSize
)
{
    if (cbCacheSize)
    {
        BYTE *pbCache = (BYTE *)malloc(cbCacheSize);

        if (!pbCache)
        {
            return E_OUTOFMEMORY;
        }

        // Save the cache info.
        pFont->pbCache = pbCache;
        pFont->pbCacheNext = pbCache;
        pFont->pbCacheEnd = pbCache + cbCacheSize;

        // Initialize the list.
        pFont->CacheHead.pNextEntry = &pFont->CacheHead;
        pFont->CacheHead.pPrevEntry = &pFont->CacheHead;
    }

    return NOERROR;
}

//============================================================================
// Examines the cache to see if we already have the information for a
// character.
//============================================================================

static BOOL CheckInCache
(
    Font *pFont,
    WCHAR wch, 
    Glyph **ppGlyph,
    unsigned *pcbGlyphSize
)
{
    // This is pretty lame.  We probably have to use a slightly more efficient
    // lookup algorithm.
    //
    CacheEntry *pEntry = pFont->CacheHead.pNextEntry;

    while (pEntry->wLength)
    {
        if (pEntry->wch == wch)
        {
            *ppGlyph = (Glyph *)(pEntry + 1);
            *pcbGlyphSize = pEntry->wLength - sizeof(CacheEntry);

            // Move this entry to the front of the list.
            if (pFont->CacheHead.pNextEntry != pEntry)
            {
                // Unlink.
                pEntry->pPrevEntry->pNextEntry = pEntry->pNextEntry;
                pEntry->pNextEntry->pPrevEntry = pEntry->pPrevEntry;

                // Relink.
                pEntry->pNextEntry = pFont->CacheHead.pNextEntry;
                pEntry->pNextEntry->pPrevEntry = pEntry;
                pEntry->pPrevEntry = &pFont->CacheHead;
                pFont->CacheHead.pNextEntry = pEntry;
            }

            return TRUE;
        }

        pEntry = pEntry->pNextEntry;
    }

    return FALSE;
}

//============================================================================
// Alloc cache information for a character.
//============================================================================

HRESULT AddToCache
(
    Font *pFont,
    WCHAR wch,
    unsigned cbGlyph,
    Glyph **ppGlyph
)
{
    long cbSizeNeeded = (sizeof(CacheEntry) + sizeof(Glyph) + cbGlyph + 3) & ~3;  // 4 byte aligned
    CacheEntry *pEntry;

    // If the cache isn't big enough, just alloc a block of memory
    // and use that.
    //
    if (cbSizeNeeded > pFont->pbCacheEnd - pFont->pbCache)
    {
        // We need 1 extra byte for the packer.
        pFont->pvOneGlyph = malloc(cbSizeNeeded + 1);

        if (!pFont->pvOneGlyph)
        {
            return E_OUTOFMEMORY;
        }

        *ppGlyph = (Glyph *)pFont->pvOneGlyph;

        return NOERROR;
    }

    if (cbSizeNeeded > pFont->pbCacheEnd - pFont->pbCacheNext)
    {
        FreeCacheSpace(pFont, cbSizeNeeded);
    }

    // Get the memory.
    pEntry = (CacheEntry *)pFont->pbCacheNext;

    // Don't forget about it.
    pFont->pbCacheNext += cbSizeNeeded;

    // Link it at the head of the list.
    pEntry->pNextEntry = pFont->CacheHead.pNextEntry;
    pEntry->pNextEntry->pPrevEntry = pEntry;
    pEntry->pPrevEntry = &pFont->CacheHead;
    pFont->CacheHead.pNextEntry = pEntry;

    // Save the cache info.
    pEntry->wch = wch;
    pEntry->wLength = (WORD)cbSizeNeeded;

    // Return it.
    *ppGlyph = (Glyph *)(pEntry + 1);

    return NOERROR;
}

//============================================================================
// Reset the cache back to nothin'.
//============================================================================

void ClearCache
(
    Font *pFont
)
{
    if (pFont)
    {
        pFont->pbCacheNext = pFont->pbCache;

        pFont->CacheHead.pNextEntry = &pFont->CacheHead;
        pFont->CacheHead.pPrevEntry = &pFont->CacheHead;
    }
}

//============================================================================
// Free up enough room in the cache to hold a new entry.
//============================================================================

static void FreeCacheSpace
(
    Font *pFont,
    unsigned cbSizeNeeded
)
{
    unsigned cbSizeFree;
    CacheEntry *pEntry;
    unsigned cbFreed;

    BYTE *pbNext;
    BYTE *pbEnd;

    // Free either the requested size or 1/4 of the cache, whichever is bigger.
    // This won't work well for very small caches with large bitmaps...
    // we'll spend an aweful lot of time freeing.
    //
    cbSizeFree = max(cbSizeNeeded, (unsigned)(pFont->pbCacheEnd - pFont->pbCache) / 4);

    // We can walk the entries in two ways:
    //
    //  - Through the circularly linked list in either direction.  This list
    //    has the most recently accessed glyph at the front.
    //    
    //  - Through the memory in the order the entries were allocated
    //    via the wLength field.
    //
    // This routine first walks the linked list backwards and "nulls" enough
    // nodes to fit our requirement.  It then walks through memory
    // compressing out those null nodes.  This ruins the whole sense of
    // order in the list...we'll regen that soon enough.
    //
    pEntry = pFont->CacheHead.pPrevEntry;
    cbFreed = 0;

    // Free the spaces.
    while (pEntry->wLength && cbFreed < cbSizeFree)
    {
        // Remember the size.
        cbFreed += pEntry->wLength;

        // Mark it as dead by wonking the next field.
        pEntry->pNextEntry = NULL;

        pEntry = pEntry->pPrevEntry;
    }

    // Reset the list.
    pFont->CacheHead.pNextEntry = &pFont->CacheHead;
    pFont->CacheHead.pPrevEntry = &pFont->CacheHead;

    // Walk through the memory through the allocations, remove the dead
    // entries and relink the other ones back onto the list.
    //
    pbNext = pFont->pbCache;
    pbEnd = pFont->pbCacheNext;

    pEntry = (CacheEntry *)pbNext;

    while ((BYTE *)pEntry < pbEnd)
    {
        // Valid entry?
        if (pEntry->pNextEntry)
        {
            CacheEntry *pNewEntry;

            // Move it.
            if ((BYTE *)pEntry != pbNext)
            {
                memmove(pbNext, pEntry, pEntry->wLength);

                pNewEntry = (CacheEntry *)pbNext;
            }
            else
            {
                pNewEntry = pEntry;
            }

            // Relink it onto the end of the list.
            pNewEntry->pPrevEntry = pFont->CacheHead.pPrevEntry;
            pNewEntry->pPrevEntry->pNextEntry = pNewEntry;
            pNewEntry->pNextEntry = &pFont->CacheHead;
            pFont->CacheHead.pPrevEntry = pNewEntry;

            // The fields in 'pEntry' may have been wonked by the 
            // above move, increment based off the valid field.
            //
            pEntry = (CacheEntry *)((BYTE *)pEntry + pNewEntry->wLength);
            pbNext += pNewEntry->wLength;
        }
        else
        {
            pEntry = (CacheEntry *)((BYTE *)pEntry + pEntry->wLength);
        }
    }

    pFont->pbCacheNext = pbNext;
}

//****************************************************************************
// Debug helpers.
//****************************************************************************

#if DBG

void XFRIP(PCHAR Format, ...)
{
    char string[MAX_PATH];
    va_list arglist;

    va_start(arglist, Format);
    _vsnprintf(string, sizeof(string), Format, arglist);
    va_end(arglist);

#if XBOX
    XDebugError("XFONT", string);
#else
    OutputDebugStringA(string);
    __asm int 3;
#endif
}

#endif DBG
