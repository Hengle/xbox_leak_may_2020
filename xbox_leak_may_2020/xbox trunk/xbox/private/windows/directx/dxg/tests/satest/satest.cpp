/*
SaTest: Shader assembler testing utility.
Copyright (C) Microsoft Corperation.

There are really 2 parts to this utility: regression checks, and new test- 
case generation. Regression is performed when the "*.vsh" isn't commented out,
near the bottom of the code.

New test cases are generated by the RandomTest() call. Files are generated
in a temporary directory, assembled, and then copied into the tests\media\satest
directory if they fail. On XBOX, you should theoretically be able to copy a
generated vertex shader to a dev machine, assuming that the xbox has sharing
privlages. 

I've found that the best way to do this is to leave it running all night, with
api.cpp's VERIFY_EACH_STEP NOT defined. This will give you a ton of test cases 
very quickly. Afterwards, turn on VERIFY_EACH_STEP, and run the regression
tests. This will reveal which optimizer was broken by the tests. After that,
group the tests into the appropriate category of optimizer, pick one, and run
lipovsh on it. This reduces the code down to the few essential lines that are 
breaking the optimizer. Check in those shrunken-down test cases, file bugs on them.
After the bugs are fixed, run regression on everything. If they all pass, delete all
except the checked-in files.

*/

#define START_NUM 1000000

// XD3DXAssembleShader command-line utility
//

#include "stdafx.h"
#include "time.h"

HANDLE hlog; //global logging handle

#ifdef XBOX
        #include <xtestlib.h>
	#include <xlog.h>
	extern "C" ULONG _cdecl DbgPrint(PCH Format, ...);

#else
#define XLL_FAIL 1
#define XLL_INFO 2
#define XLL_PASS 4
	void xLog(void*,int,const char* data, ...) {
		va_list marker;
		va_start( marker, data);
		char buf[1000];
		_vsnprintf(buf, sizeof(buf)-1, data, marker);
		buf[sizeof(buf)-1] = '\0';
		OutputDebugString(buf);
	}
	void DbgPrint(const char* data,...){
		va_list marker;
		va_start( marker, data);
		char buf[1000];
		_vsnprintf(buf, sizeof(buf), data, marker);
		OutputDebugString(buf);
	}
#endif

// Uncomment this if you want to break into the debugger when an error occurs
// #define BREAK_ON_ERROR

#if defined(DBG) && defined(BREAK_ON_ERROR)
#define SETERROR(HR,CODE) \
	do { \
if(FAILED(HR = CODE)){ \
			DebugBreak(); \
		} \
	} while(0)
#else
#define SETERROR(HR,CODE) \
	HR = CODE
#endif

void ConvertToUnicode(WCHAR* dest, DWORD destSizeBytes, LPCSTR source){
	DWORD destSizeWChars = destSizeBytes / sizeof(WCHAR);
	mbstowcs(dest,source,destSizeWChars);
	dest[destSizeWChars-1] = 0;
}

HRESULT CreateBufferFromFile(const char* path, LPXGBUFFER* ppBuffer){
	HRESULT hr = S_OK;
#ifdef USE_UNICODE_FILEIO
	WCHAR wpath[MAX_PATH];
	ConvertToUnicode(wpath, sizeof(wpath), path);
#else
#define wpath path
#endif
	HANDLE file = CreateFile(wpath,GENERIC_READ,FILE_SHARE_READ,
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
		NULL);
#ifndef USE_UNICODE_FILEIO
#undef wpath
#endif
	if(file == INVALID_HANDLE_VALUE){
		SETERROR(hr,E_FAIL);
	}
	DWORD size;
	if(SUCCEEDED(hr)){
		size = GetFileSize(file,NULL);
		if(size == ~0){
			SETERROR(hr,E_FAIL);
		}
	}
	if(SUCCEEDED(hr)){
		hr = XGBufferCreate(size, ppBuffer);
	}
	if(SUCCEEDED(hr)){
		DWORD sizeRead;
		ReadFile(file,(*ppBuffer)->GetBufferPointer(), size, &sizeRead, NULL);
		if(sizeRead != size){
			SETERROR(hr,E_FAIL);
		}
	}
	if(file != INVALID_HANDLE_VALUE){
		CloseHandle(file);
	}
	return hr;
}

HRESULT CreateFileFromBuffer(const char* path, LPXGBUFFER pBuffer){
	HRESULT hr = S_OK;
#ifdef USE_UNICODE_FILEIO
	WCHAR wpath[MAX_PATH];
	ConvertToUnicode(wpath, sizeof(wpath), path);
#else
#define wpath path
#endif
	HANDLE file = CreateFile(wpath,GENERIC_WRITE,FILE_SHARE_READ,
		NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
		NULL);
#ifndef USE_UNICODE_FILEIO
#undef wpath
#endif
	if(file == INVALID_HANDLE_VALUE){
		SETERROR(hr,E_FAIL);
	}
	if(SUCCEEDED(hr)){
		DWORD sizeWritten;
		WriteFile(file,pBuffer->GetBufferPointer(),
			pBuffer->GetBufferSize(), &sizeWritten, NULL);
		if(sizeWritten != pBuffer->GetBufferSize()){
			SETERROR(hr,E_FAIL);
		}
	}
	if(file != INVALID_HANDLE_VALUE){
		CloseHandle(file);
	}
	return hr;
}

BOOL MyDeleteFile(const char* file){
#ifdef XBOX
  #if 1
	return DeleteFile(file);
  #else
	wchar_t buf[MAX_PATH];
	ConvertToUnicode(buf, sizeof(buf), file);
	return DeleteFileW(buf);
  #endif
#else
	wchar_t buf[MAX_PATH];
	ConvertToUnicode(buf, sizeof(buf), file);
	return DeleteFileW(buf);
#endif
}

HRESULT Assemble(const char* shaderFile,
	const char* constFile,
	const char* ucodeFile,
	const char* errorFile,
	const char* listFile,
	bool optimize,
	bool preprocessOnly,
	bool outputShaderTokens,
	SASM_ResolverCallback pResolver,
	LPVOID pResolverUserData)
{
	LPXGBUFFER shaderBuffer = NULL;
	LPXGBUFFER ucodeBuffer = NULL;
	LPXGBUFFER constBuffer = NULL;
	LPXGBUFFER errorBuffer = NULL;
	LPXGBUFFER listBuffer = NULL;

	HRESULT hr;
	hr = CreateBufferFromFile(shaderFile, &shaderBuffer);

	// Delete the old output files no matter what
	if(SUCCEEDED(hr)){
		if(constFile){
			MyDeleteFile(constFile);
		}
		if(errorFile){
			MyDeleteFile(errorFile);
		}
		if(listFile){
			MyDeleteFile(listFile);
		}
	}
    DWORD shaderType;

	if(SUCCEEDED(hr)){
		DWORD flags = SASM_VERIFY_OPTIMIZATIONS 
			| (optimize ? 0 : SASM_DONOTOPTIMIZE)
//			| SASM_DONOTOPTIMIZE | SASM_SKIPVALIDATION
			;


#if 0
			| (preprocessOnly ? SASM_PREPROCESSONLY : 0)
			| (outputShaderTokens ? SASM_OUTPUTSHADERTOKENS : 0);
#endif

		hr = AssembleShader(
			shaderFile,
			shaderBuffer->GetBufferPointer(),
			shaderBuffer->GetBufferSize(),
			flags,
			constFile ? &constBuffer : NULL,
			ucodeFile ? &ucodeBuffer : NULL,
			errorFile ? &errorBuffer : NULL,
			listFile ? &listBuffer : NULL,
			pResolver, pResolverUserData,
            &shaderType);
	}
	if(SUCCEEDED(hr)){
		if(constFile && constBuffer && constBuffer->GetBufferSize() ){
			hr = CreateFileFromBuffer(constFile, constBuffer);
		}
	}
	if(SUCCEEDED(hr)){
		if(ucodeFile && ucodeBuffer && ucodeBuffer->GetBufferSize()){
//			hr = CreateFileFromBuffer(ucodeFile, ucodeBuffer);
		}
	}
	if(SUCCEEDED(hr)){
		if(listFile && listBuffer && listBuffer->GetBufferSize()){
			hr = CreateFileFromBuffer(listFile, listBuffer);
		}
	}

	// Always try to create the error log
	if(errorFile && errorBuffer && errorBuffer->GetBufferSize()){
		HRESULT hr2 = CreateFileFromBuffer(errorFile, errorBuffer);
        if(SUCCEEDED(hr)){
            hr = hr2;
        }
	}


	RELEASE(shaderBuffer);
	RELEASE(listBuffer);
	RELEASE(constBuffer);
	RELEASE(ucodeBuffer);
	RELEASE(errorBuffer);
	return hr;
}

void usage(const char* s){
	if(s){
		printf("%s\n", s);
	}
	printf("usage: [-Od][-l] shaderfile [ucodefile constfile errorfile listfile]\n");
	printf("  -Od         Turn off optimization.\n");
	printf("  -l          Generate a listing.\n");
	printf("  -p          Only run the preprocessor (output to stdout).\n");
	printf("  shaderfile  source file for shader.\n");
	printf("  ucodefile   output file for microcode.\n");
	printf("  constfile   output file for shader constants file.\n");
	printf("  errorfile   output file for errors.\n");
	printf("  listfile    output file for listing.\n");
	printf("\n");
	printf("If you don't specify ucodefile, it defaults to file.xsu\n");
	printf("If you don't specify constfile, it defaults to file.xsc\n");
	printf("If you don't specify errorfile, it defaults to file.err\n");
	printf("If you don't specify listfile,  it defaults to file.lst\n");
	printf("(where 'file' is the name of the shader file, not including the extension.)\n");
#ifdef XBOX
	_asm int 3 // Breakpoint
#else
	exit(-1);
#endif
}

void stripExtension(char* s)
{
	size_t i = strlen(s);
	while(i){
		if(s[--i]=='.'){
			s[i] = '\0';
			break;
		}
		else if(s[i] == '\\' || s[i] == '/' || s[i] == ':'){
			break;
		}
	}
}

void calculateDefaultOutFile(char* out, const char* in){
	strcpy(out, in);
	stripExtension(out);
}

class Resolver {
public:
	Resolver(){
		m_includePath[0] = 0;
	}

	HRESULT Resolve(BOOL isSystemInclude, LPCSTR sourceFilePath,
		LPCSTR includeFileName,
		LPSTR resolvedFilePath, DWORD resolvedFilePathSize,
		LPXGBUFFER* ppResolvedFile)
	{
		HRESULT hr = S_OK;
		char fullPath[MAX_PATH];
		if(SUCCEEDED(hr)){
			if(m_includePath[0]){
				sprintf(fullPath, "%s\\%s", m_includePath, includeFileName);
			}
			else {
				strcpy(fullPath, includeFileName);
			}

			hr = CreateBufferFromFile(fullPath, ppResolvedFile);
		}

		if(SUCCEEDED(hr)){
			strncpy(resolvedFilePath, fullPath, resolvedFilePathSize);
		}

		return hr;
	}

	HRESULT AddIncludePath(LPSTR includePath){
		// For now, only allow one include directory
		if(m_includePath[0] != 0){
			return E_FAIL;
		}
		strncpy(m_includePath, includePath, sizeof(m_includePath));
		return S_OK;
	}
private:
	char m_includePath[MAX_PATH];
};

HRESULT ResolverCallback(LPVOID pResolverUserData,
		BOOL isSystemInclude, LPCSTR sourceFilePath,
		LPCSTR includeFileName,
		LPSTR resolvedFilePath, DWORD resolvedFilePathSize,
		LPXGBUFFER* ppResolvedFile)
{
	return ((Resolver*) pResolverUserData)->Resolve(isSystemInclude, sourceFilePath,
		includeFileName, resolvedFilePath, resolvedFilePathSize, ppResolvedFile);
}


int assembler_main(int argc, char* argv[])
{
	const char* inFile = NULL;
	const char* ucodeFile = NULL;
	const char* constFile = NULL;
	const char* errFile = NULL;
	const char* listFile = NULL;
	bool optimize = true;
	bool listing = false;
	bool preprocessOnly = false;
	bool outputShaderTokens = false;
	Resolver resolver;

	for(int i = 1; i < argc;i++){
		const char* arg = argv[i];
		if(arg[0] == '-' || arg[0] == '/'){
			switch(arg[1]){
				case 'O':
					switch(arg[2]){
						case 'd':
							optimize = false;
							break;
						default:
							usage("Unrecognized option to -O.");
							break;
					}
					break;
				case 'l':
					listing = true;
					break;
				case 's':
					outputShaderTokens = true;
					break;
				case 'I':
					if(i + 1 >= argc){
						usage("-I requires an argument");
						break;
					}
					resolver.AddIncludePath(argv[++i]);
					break;
				case 'p':
					preprocessOnly = true;
				default:
					usage("Unknown flag.");
				}
		}
		else if ( ! inFile ) {
			inFile = arg;
		}
		else if ( ! ucodeFile ) {
			ucodeFile = arg;
		}
		else if ( ! constFile ) {
			constFile = arg;
		}
		else if ( ! errFile ) {
			errFile = arg;
		}
		else if ( ! listFile ) {
			listFile = arg;
		}
		else {
			usage("Unexpected extra file name.");
		}
	}
	if(!inFile){
		usage("Need to specify an input file.");
	}
	char defaultOutFile[MAX_PATH];
	calculateDefaultOutFile(defaultOutFile, inFile);
	char defaultUcodeFile[MAX_PATH];
	char defaultConstFile[MAX_PATH];
	char defaultErrFile[MAX_PATH];
	char defaultListFile[MAX_PATH];
	sprintf(defaultUcodeFile,"%s.xsu",defaultOutFile);
	sprintf(defaultConstFile,"%s.xsc",defaultOutFile);
	sprintf(defaultErrFile,"%s.err",defaultOutFile);
	sprintf(defaultListFile,"%s.lst",defaultOutFile);
	if(!ucodeFile){
		ucodeFile = defaultUcodeFile;
	}
	if(!constFile){
//		constFile = defaultConstFile;
	}
	if(!errFile){
		errFile = defaultErrFile;
	}
	if(!listFile){
//		listFile = defaultListFile;
	}

	HRESULT hr = Assemble(inFile,constFile,ucodeFile,errFile,listFile,
		optimize,preprocessOnly, outputShaderTokens,
		ResolverCallback, &resolver);

	return hr;
}

HRESULT TestFile(const char* szIncludeDir, const char* szFile){
	DbgPrint("TestFile %s\n", szFile);
	char* includeDirBuf = (char*) szIncludeDir;
	char* buf = (char*) szFile;
	char* fakeArgs[6];
	fakeArgs[0] = "satest";
	fakeArgs[1] = "-l";
	fakeArgs[2] = buf;
	fakeArgs[3] = "-I";
	fakeArgs[4] = includeDirBuf;
	fakeArgs[5] = 0;
	HRESULT hr = (HRESULT) assembler_main(5,fakeArgs);
	return hr;
}

HRESULT TryAllFiles(const char* pszPath, const char* extension)
	{
	// Read each of the shader assembler files out of the test directory, and assemble it.

	HRESULT                 hr                  = S_OK;
	HANDLE                  hFind               = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA         fd;
	char                    szPattern[MAX_PATH];
	
	sprintf(szPattern, "%s\\*.%s", pszPath, extension);

	hFind = FindFirstFile(szPattern, &fd);

	if(INVALID_HANDLE_VALUE == hFind)
	{
		// Assume there are no files of this type
        DbgPrint("No files match pattern %ls\n", szPattern);
		return S_OK;
	}

	HRESULT anyFail = hr;
	
	while(SUCCEEDED(hr))
	{
		char szFile[MAX_PATH];
		sprintf(szFile, "%s\\%s", pszPath, fd.cFileName);
		HRESULT hr2 = TestFile(pszPath, szFile);
		if ( FAILED(hr2) ) {
			DbgPrint("File %s failed: 0x%08x\n", szFile, hr2);
			anyFail = hr2;
		}		
		if(SUCCEEDED(hr))
		{
			BOOL foundFile = FindNextFile(hFind, &fd);
			if( !foundFile)
			{
				break;
			}
		}
	}

	hr = anyFail;
	
	if(INVALID_HANDLE_VALUE != hFind)
	{
#ifdef XBOX
	FindClose(hFind);
#else
	// FindClose is causing problems under VC6 - I get an Invalid Handle Value assertion.
#endif
	}
	
	return hr;
}



#define countof(a) (sizeof(a) / sizeof(a[0]))

/*
This program produces vertex shaders randomly.
It is mainly designed to stress the optimizer, but also tests the various options 
(xvs.1.1, vs.1.0, vs.1.1, xvsw.1.1, xvss.1.1, #pragma screenspace, etc.)
*/

struct INSTRUCTION {
	char NAME[5];
	int uses;
	int numparams;
};

INSTRUCTION Mac[] = {
	{ "nop ", 0, 0 },//0
	{ "mov ", 1, 1 },//1 
	{ "add ", 5, 2 },//2 
	{ "mul ", 3, 2 },//3
	{ "mad ", 7, 3 },//4
	{ "min ", 3, 2 },//5
	{ "max ", 3, 2 },//6
	{ "sge ", 3, 2 },//7
	{ "slt ", 3, 2 },//8
	{ "dst ", 3, 2 },//9
	{ "dp4 ", 3, 2 },//10
	{ "dp3 ", 3, 2 },//11
	{ "dph ", 3, 2 },//12
	{ "mov ", 1, 1 },//13
};
INSTRUCTION Ilu[] = {
	{ "nop ", 0, 0 },//0
	{ "mov ", 4, 1 },//1
	{ "rcc ", 4, 1 },//2 
	{ "rcp ", 4, 1 },//3 
	{ "rsq ", 4, 1 },//4 
	{ "lit ", 4, 1 },//5 
	{ "expp", 4, 1 },//6 
	{ "logp", 4, 1 },//7 
};

INSTRUCTION All[] = {
	{ "nop ", 0, 0 },//0 
	{ "mov ", 1, 1 },//1 
	{ "add ", 5, 2 },//2 
	{ "mul ", 3, 2 },//3
	{ "mad ", 7, 3 },//4
	{ "min ", 3, 2 },//5
	{ "max ", 3, 2 },//6
	{ "sge ", 3, 2 },//7
	{ "slt ", 3, 2 },//8
	{ "dst ", 3, 2 },//9
	{ "dp4 ", 3, 2 },//10
	{ "dp3 ", 3, 2 },//11
	{ "dph ", 3, 2 },//12
	{ "mov ", 4, 1 },//1
	{ "rcc ", 4, 1 },//2 
	{ "rcp ", 4, 1 },//3 
	{ "rsq ", 4, 1 },//4 
	{ "lit ", 4, 1 },//5 
	{ "expp", 4, 1 },//6 
	{ "logp", 4, 1 },//7 
};


const char* OutRegs[] = {"oPos",
    "o1" /* Weight */, "o2" /* VA_NRML */,
    "oD0", "oD1",
    "oFog", "oPts",
    "oB0", "oB1",
    "oT0", "oT1", "oT2", "oT3",
};

bool gbCanWriteConsts;  //read-write, or state shader
bool gbStateShader;     //must use only v0, cannot write O**
bool gbCanAccessConsts; //not vs.1.*
bool gbCanUseArl;       //not vs.1.0
bool gbHasWrittenReg[13][4] = {{false}};
bool gbHasWrittenArl = false;
bool gbHasWrittenConst = false;
char gfilebuf[30000];
int gNumLines;
char*gfp;
FILE* f;

int gInstruction;

void DoInstruction(bool nonop) {
pickinstruction:
	switch(rand() % 8) 
	{
	case 0:
		gInstruction = (rand() % 3) + 2; //favor add, mul, mad. (to test mad-splicing)
		break;
	case 1:
		gInstruction = gInstruction; //use last instruction, to test pairing
		break;
	case 2: case 3: case 4: case 5: case 6: case 7:
		gInstruction = rand() % countof(All);
		break;
	}
	
	if(gInstruction == 0 && nonop) goto pickinstruction;
	if((gInstruction == 14 || gInstruction == 12) && !gbCanAccessConsts) goto pickinstruction;
	gfp += sprintf(gfp, "%s ", All[gInstruction].NAME);

}

void DoOutput() {
	if(gInstruction == 0) return; //nop takes no params.

	bool mask[4] = {true, true, true, true};
	int i, j;
	bool domask = rand() & 1;
	if(domask) {
		for(i = 0; i < 4; i++) {
			mask[i] = (rand() & 4) ? true : false;
		}
	}
	if(!mask[0] && !mask[1] && !mask[2] && !mask[3]) {
		mask[rand() & 3] = true;
	}

	switch (rand() % 10) {
	case 0:
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
case0:
		i = rand() % (12 + gbCanUseArl);
		if(i == 12 && gInstruction == 1) {
			gfp += sprintf(gfp, "a0.x, ");
			gbHasWrittenArl = true;
			return;
		} else if (i == 12) {
			i = 0;
		}
		gfp += sprintf(gfp, "r%d", i);
		for(j = 0; j < 4; j++) {
			if(mask[j]) {
				gbHasWrittenReg[i][j] = true;
			}
		}
		
		break;
	case 7:
		//write to constant
		if(!gbCanWriteConsts) goto case0;
		if(gbCanAccessConsts) {
			gfp += sprintf(gfp, "c%d", (rand() % 192) - 96);
		} else {
			gfp += sprintf(gfp, "c%d", (rand() % 96));
		}
		gbHasWrittenConst = true;
		break;
	case 8:
	case 9:
		//write to output
		if(gbStateShader) goto case0;
pickoutputregagain:
		i = rand() % countof(OutRegs);
		if((i == 7 || i == 8) && (!gbCanAccessConsts)) 	goto pickoutputregagain;
		if((i == 1 || i == 2)) goto pickoutputregagain;
		for(j = 0; j < 4; j++) {
			if((i == 0) && mask[j]) {
				gbHasWrittenReg[12][j] = true;
			}
		}
		gfp += sprintf(gfp, "%s", OutRegs[i]);
		break;
	}
	if(domask) {
		gfp += sprintf(gfp, ".");
		if(mask[0]) gfp += sprintf(gfp, "x");
		if(mask[1]) gfp += sprintf(gfp, "y");
		if(mask[2]) gfp += sprintf(gfp, "z");
		if(mask[3]) gfp += sprintf(gfp, "w");
	}
	gfp += sprintf(gfp, ", ");
}

void DoInput(char* buf) {
	buf[0] = '\0';
	if(gInstruction == 0) return;

	int i,j,r,c,v;
	char xyzw[] = {'x', 'y', 'z', 'w'};
	bool arl = false;

	if(gbCanUseArl && gbHasWrittenArl && ((rand() % 10) == 0)) arl = true;

	if(::gbCanAccessConsts) {
		c = rand() % 18;
		if(c < 6) c -= 96;
		else if (c < 12) c -= 7;
		else if (c < 17) c += (95 - 16);
		else c = (rand() % 192) - 96;
	} else {
		c = (rand() % 12);
		if(c < 6) c += 0;
		else if (c < 11) c += (95 - 11);
		else c = (rand() % 96);
	}

	if(::gbStateShader) {
		v = 0;
	} else {
		v = rand() % 16;
	}

	for(i = 0; i < All[gInstruction].numparams; i++) {

		int swiz[4] = {0,1,2,3};
		bool doswiz = (rand() & 1) ? true : false;
		if(doswiz) {
			for(j = 0; j < 4; j++) {
				swiz[j] = rand() & 3;
			}
		}

		if((rand() % 4) == 0) {
			buf += sprintf(buf, "-");
		}


pickreg:
		switch(rand() % 8) {
		case 0: 
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			r = rand() % (12 + gbCanAccessConsts);
			for(j = 0; j < 4; j++) {
				if(!gbHasWrittenReg[r][swiz[j]]) {
					goto pickreg;
				}
			}
			buf += sprintf(buf, "r%d", r);
			break;
		case 6:
			if(arl) {
				buf += sprintf(buf, "c[a0.x+%d]", c);
			} else {
				buf += sprintf(buf, "c%d", c);
			}
			break;
		case 7:
			buf += sprintf(buf, "v%d", v);
			break;
		}

		if(doswiz) {
			buf += sprintf(buf, ".%c%c%c%c", xyzw[swiz[0]], xyzw[swiz[1]], xyzw[swiz[2]], xyzw[swiz[3]]);
		}

		if (i == All[gInstruction].numparams - 1) {
			break;
		} else {
			buf += sprintf(buf, ", ");
		}
	}
}


void DoIt() {
	int ca, va, amx, bmx, cmx;
	int arr, brr, crr;
	bool ane, bne, cne;
	int as[4], bs[4], cs[4];
	bool om;
	int rwm, swm, owm;
	int rw, oc;
	int mac, ilu;
	bool arl;
	int or;

	int i, j;
	char xyzw[] = {'x','y','z','w'};
	char mx[] = {'?', 'r', 'v', 'c'};

chooseinstructions:
	ilu = (rand() % 8);
	mac = (rand() % 14);
	if((!gbCanUseArl) && (mac == 13)) goto chooseinstructions;
	if((!gbCanAccessConsts) && (mac == 12)) goto chooseinstructions;
	if((!gbCanAccessConsts) && (ilu == 2)) goto chooseinstructions;

	arl = false;
	if(gbCanUseArl && gbHasWrittenArl && (!(rand() % 6))) arl = true;

	if(::gbCanAccessConsts) {
		ca = rand() % 18;
		if(ca < 6) ca -= 96;
		else if (ca < 12) ca -= 7;
		else if (ca < 17) ca += (95 - 16);
		else ca = (rand() % 192) - 96;
	} else {
		ca = (rand() % 12);
		if(ca < 6) ca += 0;
		else if (ca < 11) ca += (95 - 11);
		else ca = (rand() % 96);
	}

	if(::gbStateShader) {
		va = 0;
	} else {
		va = rand() % 16;
	}

	if(rand() & 1) {
		for (i = 0; i < 4; i++) as[i] = i;
	} else {
		for (i = 0; i < 4; i++) as[i] = rand() & 3;
	}
	if(rand() & 3) ane = false; else ane = true;

	if(rand() & 1) {
		for (i = 0; i < 4; i++) bs[i] = i;
	} else {
		for (i = 0; i < 4; i++) bs[i] = rand() & 3;
	}
	if(rand() & 3) bne = false; else bne = true;

	if(rand() & 1) {
		for (i = 0; i < 4; i++) cs[i] = i;
	} else {
		for (i = 0; i < 4; i++) cs[i] = rand() & 3;
	}
	if(rand() & 3) cne = false; else cne = true;

	if(rand() & 1) rwm = 15;
	else rwm = rand() % 15 + 1;
	
	if(rand() & 1)  swm = 15;
	else swm = rand() % 15 + 1;

	if(rand() & 1)  owm = 15; //1/4
	else owm = rand() & 15; //1/4
	if(rand() & 1) owm = 0; //only write to output 1/2 times

	oc = 1;
	if(gbCanWriteConsts) oc = rand() & 1 ? true : false;
	if(gbStateShader) oc = 0;
	if(oc == 0) {
		if(::gbCanAccessConsts) {
			or = rand() % 18;
			if(or < 6) or -= 96;
			else if (or < 12) or -= 7;
			else if (or < 17) or += (95 - 16);
			else or = (rand() % 192) - 96;
		} else {
			or = (rand() % 12);
			if(or < 6) or += 0;
			else if (or < 11) or += (95 - 11);
			else or = (rand() % 96);
		}
	} else {
		//write to output
pickoutputregagain:
		or = rand() % countof(OutRegs);
		if((or == 7 || or == 8) && (!gbCanAccessConsts)) 	goto pickoutputregagain;
		if((or == 1 || or == 2)) goto pickoutputregagain;
	}

	om = rand() & 1 ? true : false;
chooserw:
	rw = rand() % (12);
	if(rw == 1 && ilu != 0) goto chooserw;

chooseamx:
	amx = (rand() & 7) + 1; if(amx >= 4) amx = 1;
	if(amx == 1) { 
		arr = rand() % (12 + ::gbCanAccessConsts); 
		for(i = 0; i < 4; i++) {
			if(!::gbHasWrittenReg[arr][as[i]]) goto chooseamx;
		}
	}
choosebmx:
	bmx = (rand() & 7) + 1; if(bmx >= 4) bmx = 1;
	if(bmx == 1) { 
		brr = rand() % (12 + ::gbCanAccessConsts);
		for(i = 0; i < 4; i++) {
			if(!::gbHasWrittenReg[brr][bs[i]]) goto choosebmx;
		}
	}
choosecmx:
	cmx = (rand() & 7) + 1; if(cmx >= 4) cmx = 1;
	if(cmx == 1) { 
		crr = rand() % (12 + ::gbCanAccessConsts);
		for(i = 0; i < 4; i++) {
			if(!::gbHasWrittenReg[crr][cs[i]]) goto choosecmx;
		}
	}

#if 0
	int NumPairs = rand() % 6;
	for(i = 0; i < NumPairs; i++) {
		int uses;
		if(i != 0) gfp += sprintf(gfp, " + ");
		int o = rand() % 3;
		if(o == 0 || (o == 2 && om == 0)) {
			uses = Mac[mac].uses;
			gfp += sprintf(gfp, "%s ", Mac[mac].NAME);
			if(mac != 0) {
				if(mac != 13) {
					if(o == 2) {
						if(oc == 0) {
							gfp += sprintf(gfp, "c[%d]", or);
						} else {
							gfp += sprintf(gfp, "%s", OutRegs[or]);
						}
					} else {
						gfp += sprintf(gfp, "r%d", rw);
					}
					if((rand() & 7) && (rwm == 15)) {
					} else {
						int temp = rand() & rwm;
						if(temp == 0) temp = rwm;
						gfp += sprintf(gfp, ".");
						for(j = 0; j < 4; j++) {
							if(temp & (1 << j)) {
								gfp += sprintf(gfp, "%c", xyzw[j]);
								if (o != 2) ::gbHasWrittenReg[rw][j] = true;
							}
						}
					}
				} else {
					gfp += sprintf(gfp, "a0.x  ");
				}
				gfp += sprintf(gfp, ",");
			}
		} else {
			uses = Ilu[ilu].uses;
			gfp += sprintf(gfp, "%s ", Ilu[ilu].NAME);
			if(ilu != 0) {
				if(o == 2) {
					if(oc == 0) {
						gfp += sprintf(gfp, "c[%d]", or);
					} else {
						gfp += sprintf(gfp, "%s", OutRegs[or]);
					}
				} else {
					gfp += sprintf(gfp, "r%d", rw);
				}
				if((rand() & 7) && (rwm == 15)) {
				} else {
					int temp = rand() & rwm;
					if(temp == 0) temp = rwm;
					gfp += sprintf(gfp, ".");
					for(j = 0; j < 4; j++) if(temp & (1 << j)) {
						gfp += sprintf(gfp, "%c", xyzw[j]);
						if (o != 2) ::gbHasWrittenReg[rw][j] = true;
					}
				}
				gfp += sprintf(gfp, ",");
			}
		}
		if(uses & 1) {
			     if (amx == 1) {gfp += sprintf(gfp, "%cr%d.%c%c%c%c",        ane?'-':' ', arr, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
			else if (amx == 2) {gfp += sprintf(gfp, "%cv%d.%c%c%c%c",        ane?'-':' ',  va, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
			else if (arl)      {gfp += sprintf(gfp, "%cc[a0.x+%d].%c%c%c%c", ane?'-':' ',  ca, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
			else               {gfp += sprintf(gfp, "%cc[%d].%c%c%c%c",      ane?'-':' ',  ca, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
			if(uses & 6) gfp += sprintf(gfp, ",");
		}
		if(uses & 2) {
			     if (bmx == 1) {gfp += sprintf(gfp, "%cr%d.%c%c%c%c",        bne?'-':' ', brr, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
			else if (bmx == 2) {gfp += sprintf(gfp, "%cv%d.%c%c%c%c",        bne?'-':' ',  va, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
			else if (arl)      {gfp += sprintf(gfp, "%cc[a0.x+%d].%c%c%c%c", bne?'-':' ',  ca, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
			else               {gfp += sprintf(gfp, "%cc[%d].%c%c%c%c",      bne?'-':' ',  ca, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
			if(uses & 4) gfp += sprintf(gfp, ",");
		}
		if(uses & 4) {
			     if (cmx == 1) {gfp += sprintf(gfp, "%cr%d.%c%c%c%c",        cne?'-':' ', crr, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
			else if (cmx == 2) {gfp += sprintf(gfp, "%cv%d.%c%c%c%c",        cne?'-':' ',  va, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
			else if (arl)      {gfp += sprintf(gfp, "%cc[a0.x+%d].%c%c%c%c", cne?'-':' ',  ca, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
			else               {gfp += sprintf(gfp, "%cc[%d].%c%c%c%c",      cne?'-':' ',  ca, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
		}
		gfp += sprintf(gfp, "\n");
	}

#else


//pickdoout:
	int doout = (rand() % 7) + 1;
	bool WeirdIluInput = false;
#if 1 //currently, can't pair "add + ILU"
	if((mac == 2 || mac == 4) && 
		(((doout & 1) || ((doout & 4) && (om == 0))) && 
		((doout & 2) || ((doout & 4) && (om == 1)))) && 
		((ilu == 2) || (ilu == 3) || (ilu == 4) || (ilu == 6) || (ilu == 7))) {
		WeirdIluInput = true;
	}
#endif

	int uses;
	for(i = 0; i <= 3; i++) {
		if(doout & (1 << i)) {
			gNumLines++;
			if((doout & ((1 << i) - 1))) gfp += sprintf(gfp, " + ");
			int o = i;
			if(o == 0 || (o == 2 && om == 0)) {
				uses = Mac[mac].uses;
				gfp += sprintf(gfp, "%s ", Mac[mac].NAME);
				if(mac != 0) {
					if(mac != 13) {
						if(o == 2) {
							if(oc == 0) {
								gfp += sprintf(gfp, "c[%d]", or);
							} else {
								gfp += sprintf(gfp, "%s", OutRegs[or]);
							}
						} else {
							gfp += sprintf(gfp, "r%d", rw);
						}
						if((rand() & 7) && (rwm == 15)) {
						} else {
							int temp = rand() & rwm;
							if(temp == 0) temp = rwm;
							gfp += sprintf(gfp, ".");
							for(j = 0; j < 4; j++) {
								if(temp & (1 << j)) {
									gfp += sprintf(gfp, "%c", xyzw[j]);
									if (o != 2) ::gbHasWrittenReg[rw][j] = true;
								}
							}
						}
					} else {
						gfp += sprintf(gfp, "a0.x  ");
					}
					gfp += sprintf(gfp, ",");
				}
			} else {
				uses = Ilu[ilu].uses;
				gfp += sprintf(gfp, "%s ", Ilu[ilu].NAME);
				int IluReg = (doout & 1) ? 1 : rw;
				if((doout & 4) && om == 0) IluReg = 1;
				if(ilu != 0) {
					if(o == 2) {
						if(oc == 0) {
							gfp += sprintf(gfp, "c[%d]", or);
						} else {
							gfp += sprintf(gfp, "%s", OutRegs[or]);
						}
					} else {
						gfp += sprintf(gfp, "r%d", IluReg);
					}
					if((rand() & 7) && (swm == 15)) {
					} else {
//						int temp = rand() & swm;
//						if(temp == 0) temp = swm;
						gfp += sprintf(gfp, ".");
						for(j = 0; j < 4; j++) if(swm & (1 << j)) {
							gfp += sprintf(gfp, "%c", xyzw[j]);
							if (o != 2) ::gbHasWrittenReg[IluReg][j] = true;
						}
					}
					gfp += sprintf(gfp, ",");
				}
			}
			if(uses & 1) {
					 if (amx == 1) {gfp += sprintf(gfp, "%cr%d.%c%c%c%c",        ane?'-':' ', arr, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
				else if (amx == 2) {gfp += sprintf(gfp, "%cv%d.%c%c%c%c",        ane?'-':' ',  va, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
				else if (arl)      {gfp += sprintf(gfp, "%cc[a0.x+%d].%c%c%c%c", ane?'-':' ',  ca, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
				else               {gfp += sprintf(gfp, "%cc[%d].%c%c%c%c",      ane?'-':' ',  ca, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
				if(uses & 6) gfp += sprintf(gfp, ",");
			}
			if(uses & 2) {
					 if (bmx == 1) {gfp += sprintf(gfp, "%cr%d.%c%c%c%c",        bne?'-':' ', brr, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
				else if (bmx == 2) {gfp += sprintf(gfp, "%cv%d.%c%c%c%c",        bne?'-':' ',  va, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
				else if (arl)      {gfp += sprintf(gfp, "%cc[a0.x+%d].%c%c%c%c", bne?'-':' ',  ca, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
				else               {gfp += sprintf(gfp, "%cc[%d].%c%c%c%c",      bne?'-':' ',  ca, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
				if(uses & 4) gfp += sprintf(gfp, ",");
			}
			if(!(o == 0 || (o == 2 && om == 0)) && WeirdIluInput) {
					 if (cmx == 1) {gfp += sprintf(gfp, "%cr%d.%c",        cne?'-':' ', crr, xyzw[cs[0]]);}
				else if (cmx == 2) {gfp += sprintf(gfp, "%cv%d.%c",        cne?'-':' ',  va, xyzw[cs[0]]);}
				else if (arl)      {gfp += sprintf(gfp, "%cc[a0.x+%d].%c", cne?'-':' ',  ca, xyzw[cs[0]]);}
				else               {gfp += sprintf(gfp, "%cc[%d].%c",      cne?'-':' ',  ca, xyzw[cs[0]]);}
			} else if(uses & 4) {

					 if (cmx == 1) {gfp += sprintf(gfp, "%cr%d.%c%c%c%c",        cne?'-':' ', crr, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
				else if (cmx == 2) {gfp += sprintf(gfp, "%cv%d.%c%c%c%c",        cne?'-':' ',  va, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
				else if (arl)      {gfp += sprintf(gfp, "%cc[a0.x+%d].%c%c%c%c", cne?'-':' ',  ca, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
				else               {gfp += sprintf(gfp, "%cc[%d].%c%c%c%c",      cne?'-':' ',  ca, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
			}
			gfp += sprintf(gfp, "\n");
		}
	}
#endif


}



//repeatcount = the number of tests to run. Note: if you pass 0x7fffffff, it will repeat forever. (0x7ffffffd will just _seem_ like it runs forever.)
void RandomTest(int repeatcount, int seed) 
{
	DbgPrint("*****\n vertex shader generator Seed: %d\n*****\n", seed);

	char fileonly[16] = {0};

#ifdef XBOX
//	char TestDir[] = "\\\\jgoulddev\\satest";
    char FailDir[] = "t:\\satest";
    CreateDirectory(FailDir, NULL); //we deal with failure later...
	xSetFunctionName(hlog, "shadeasm: RandomTest");
	xStartVariation(hlog, "random shaders");
#else
//	char TestDir[] = "..\\..\\..\\tests\\Media\\satest\\temp";
//	CreateDirectory(TestDir, NULL);
	char FailDir[] = "..\\..\\..\\tests\\Media\\satest";
	CreateDirectory(FailDir, NULL);
#endif

	int shadercount; //number of shaders written so far
	int i, j;
	char buf[100]; // enough room for "mad c[-96].xyzw, -c[a0.x+-96].xyzw, -c[a0.x+-96].xyzw, -c[a0.x+-96].xyzw"

	srand(seed);
	#ifdef XBOX
		xLog(hlog, XLL_PASS, "random seed: %d", seed);
	#else 
		DbgPrint("random seed: %d\n", seed);
	#endif


	for(shadercount = 0; shadercount < repeatcount; shadercount++) {
		if(shadercount == 0x7ffffffe) shadercount = 0x7ffffffd;
		int numinstructions;

		for(i = 0; i < 13; i++) {
			for(j = 0; j < 4; j++) {
				gbHasWrittenReg[i][j] = false;
			}
		}
		gbHasWrittenArl = false;
		gbHasWrittenConst = false;

//		sprintf(filename, "%s\\%d.vsh", TestDir, shadercount + START_NUM);
		sprintf(fileonly,     "%d.vsh",          shadercount + START_NUM);

		gfp = gfilebuf;

		switch(rand() % 4) {
		case 0:
			gfp += sprintf(gfp, "vs.1.");
			gbCanWriteConsts = false;
			gbStateShader = false;
			gbCanAccessConsts = false;
			break;
		case 1:
			gfp += sprintf(gfp, "xvs.1.");
			gbCanWriteConsts = false;
			gbStateShader = false;
			gbCanAccessConsts = true;
			break;
		case 2:
			gfp += sprintf(gfp, "xvsw.1.");
			gbCanWriteConsts = true;
			gbStateShader = false;
			gbCanAccessConsts = true;
			break;
		case 3:
			gfp += sprintf(gfp, "xvss.1.");
			gbCanWriteConsts = true;
			gbStateShader = true;
			gbCanAccessConsts = true;
			break;
		}
		switch(rand() & 1) {
		case 0:
			gfp += sprintf(gfp, "0\n");
			gbCanUseArl = false;
			break;
		case 1:
			gfp += sprintf(gfp, "1\n");
			gbCanUseArl = true;
			break;
		}

		if(rand() & 1) {
			gfp += sprintf(gfp, "#pragma screenspace\n");
		}

		int instructioncount;

		// I figure it's very doubtful that this will overflow the 136-instruction limit, 
		//since pairing and dead-code will happen a lot
		numinstructions = rand() % (250); //should be 136 * 2, but that tends to produce a lot of over-size code.
		if((!gbCanAccessConsts) && (numinstructions > 128)) numinstructions = 128;
		DWORD flags = SASM_VERIFY_OPTIMIZATIONS | 
			((rand() & 1) ? 0 : SASM_DISABLE_GLOBAL_OPTIMIZATIONS);
		if((flags & SASM_DISABLE_GLOBAL_OPTIMIZATIONS) && (numinstructions > 142)) numinstructions = 142;

		gNumLines = 0;
		for(instructioncount = 0; instructioncount < numinstructions - 1; instructioncount++) {
			if(::gbCanAccessConsts /** && 0 /**/) {
				DoIt();
			} else {
				DoInstruction(false);
				DoInput(buf);
				DoOutput();
				gfp += sprintf(gfp, "%s\n", buf);
			}
			if(gNumLines >= 265) break;
		}

		if (((!gbHasWrittenReg[12][0]) || (!gbHasWrittenReg[12][1])) && (!(gbStateShader))) {
			DoInstruction(true);
			gfp += sprintf(gfp, "oPos.%c%c, ", gbHasWrittenReg[12][0] ? 'y' : 'x', (gbHasWrittenReg[12][0] || gbHasWrittenReg[12][1]) ? ' ' : 'y');
			DoInput(buf);
			gfp += sprintf(gfp, "%s\n", buf);
		}
		if(gbStateShader && !gbHasWrittenConst) {
			DoInstruction(true);
			gfp += sprintf(gfp, "c0.x, ");
			DoInput(buf);
			gfp += sprintf(gfp, "%s\n", buf);
		}

	LPXGBUFFER ucodeBuffer = NULL;
	LPXGBUFFER errorBuffer = NULL;
	LPXGBUFFER listBuffer = NULL;
	HRESULT hr;

	//	DbgPrint("File %s\n", fileonly);
		hr = AssembleShader(
			fileonly,
			gfilebuf,
			gfp - gfilebuf,
			flags,
			NULL, //const
			&ucodeBuffer,
			&errorBuffer,
			&listBuffer,
			NULL, NULL,
            NULL);


/*
		f = fopen(filename, "w");

		if(!f) {
			DbgPrint("error! couldn't open %s\n", filename);
			continue;
		}
		fprintf(f, gfilebuf);
		fclose(f);
*/

		if (FAILED(hr)) {
			if(strstr((char*)XGBuffer_GetBufferPointer(errorBuffer), "is 136")) { //too big. We don't care. 
			} else {
#ifndef XBOX
				DbgPrint("File %s failed: 0x%08x\n", fileonly, hr);
#else
				xLog(hlog, XLL_FAIL, "file %d failed!", shadercount);
#endif
				char buf[MAX_PATH];
				sprintf(buf, "%s\\%s", FailDir, fileonly);
				FILE* f = fopen(buf, "w");
				if(f == NULL) {
					xLog(hlog, XLL_FAIL, "can't open %s. \n", buf);
					sprintf(buf, "t:\\%s", fileonly);
					f = fopen(buf, "w");
				}
				if(f != NULL) {
					fprintf(f, gfilebuf);
					fclose(f);
				} else {
					xLog(hlog, XLL_FAIL, "can't open %s. \n", buf);
					return;
				}
			}
		} else {
#ifdef XBOX
		//	xLog(hlog, XLL_PASS, "file %d succeeded\n", shadercount);
#endif
		} 
	RELEASE(listBuffer);
	RELEASE(ucodeBuffer);
	RELEASE(errorBuffer);
	}
#ifdef XBOX
	xEndVariation(hlog);
#endif
}





#include "..\vshtools\vshgen.h"

LIPOTESTRETURN Satest (XBuffer* pShader, void*) 
{
char* fileonly = "a";
DWORD flags = SASM_VERIFY_OPTIMIZATIONS;
char* faildir = "c:\\sd\\private\\windows\\directx\\dxg\\tests\\media\\satest\\temp";

	HRESULT hr = S_OK;
	LPXGBUFFER ucodeBuffer = NULL;
	LPXGBUFFER errorBuffer = NULL;
	LPXGBUFFER listBuffer = NULL;

//	DbgPrint("File %s\n", fileonly);
	hr = XGAssembleShader(fileonly,	pShader->GetText(),	pShader->GetUsed(),
		SASM_DONOTOPTIMIZE,	NULL, 
		&ucodeBuffer, &errorBuffer,	&listBuffer, NULL, NULL, NULL);

	if (FAILED(hr)) {
		if(strstr((char*)XGBuffer_GetBufferPointer(errorBuffer), "is 136")) { //too big. We don't care. 
			RELEASE(listBuffer);
			RELEASE(ucodeBuffer);
			RELEASE(errorBuffer);
			return ltrTestFailed;
		} else {
			RELEASE(listBuffer);
			RELEASE(ucodeBuffer);
			RELEASE(errorBuffer);
			return ltrInvalid;
		}
	} 

	hr = XGAssembleShader(fileonly,	pShader->GetText(),	pShader->GetUsed(),
		SASM_VERIFY_OPTIMIZATIONS,	NULL, 
		&ucodeBuffer, &errorBuffer,	&listBuffer, NULL, NULL, NULL);

	RELEASE(listBuffer);
	RELEASE(ucodeBuffer);
	RELEASE(errorBuffer);

	if (FAILED(hr)) {
		return ltrTestFailed;
	} else {
//		xLog(hlog, XLL_PASS, "file %s succeeded\n", fileonly);
		return ltrTestPassed;
	}
}

void RandomTest2(int repeatcount, int seed) 
{
	XBuffer* pShader;
	XBuffer* pShrunkShader;

	int iShader;
	char fileonly[16] = {0};
//	char buf[100];
	HRESULT hr;
	
	xLog(hlog, XLL_INFO, "*** random seed: %d ***\n", seed);
	srand(seed);

#ifdef XBOX
    char FailDir[] = "t:\\satest";
    CreateDirectory(FailDir, NULL); //we deal with failure later...
	xSetFunctionName(hlog, "shadeasm: RandomTest");
	xStartVariation(hlog, "random shaders");
#else
	char FailDir[] = "..\\..\\..\\tests\\Media\\satest";
	CreateDirectory(FailDir, NULL);
#endif


	for(iShader = 0; iShader < repeatcount; iShader++) {
		//if repeatcount == max_int, repeat infinitely
		if(iShader == 0x7ffffffe) {
			iShader = 0; 
		}

		pShader = NULL;
		pShrunkShader = NULL;

		hr = GenerateRandomVertexShader(
            1, 136, 0, RND(1,3), true, RNDTF(), true, true, RNDTF(), RNDTF(), &pShader);
		if(FAILED(hr)) {
			xLog(hlog, XLL_INFO, "GenerateRandomVertex Shader Failed: %x", hr);
		} else {
			//xLog(hlog, XLL_INFO, pShader->GetText());
		}

		hr = LipoVsh(pShader, &pShrunkShader, Satest, NULL, false, false);
		if(hr == S_OK) {
			//there was a bug detected. LipoVsh minimized it, and saved it to
			//pShrunkShader. We just need to save it to disk, and spew.
			xLog(hlog, XLL_INFO, "Spew\n");
			_asm {int 3};

		} else if(FAILED(hr)) {
			//the shader generated was invalid. 
			xLog(hlog, XLL_INFO, "LipoVsh returned %x.", hr);
//			_asm {int 3};

		} else if (hr == S_FALSE) {
		//	xLog(hlog, XLL_INFO, "shader good.\n");
			//this means the shader was fine, and was not shrunk. Continue!
		}


		delete pShader;
		delete pShrunkShader;
	}
}
	





#ifdef XBOX
void __cdecl blah()
#else
int __cdecl main(int argc, char* argv[])
#endif
{
	// Read each of the shader assembler files out of the test directory, and assemble it.
#ifdef XBOX
	static const char*    pszPath             = "xt:\\satest";
#else
	static const char*    pszPath             = "..\\..\\..\\tests\\Media\\satest";
	///////
	//make this a background test. This will ensure it won't mangle timing of other processes.
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);
	///////
#endif


	HRESULT hr = S_OK;
	HRESULT allHR = S_OK;
	char* extensions[] = {
		"nva", // For internal testing.
//		"nvv", // NVIDIA samples made this popular
		"vsh", //our sample format.
		0
	};
	for(int i = 0; extensions[i]; i++){
//		hr = TryAllFiles(pszPath, extensions[i]);
		if(FAILED(hr)){
			allHR = hr;
		}
	}

	RandomTest2(2000, /*0/*/time(0)/**/); //keep running for a year or so

	DbgPrint("\n\nDone\n");
#ifndef XBOX
	return allHR;
#endif
}

#ifdef XBOX
VOID WINAPI SATESTStartTest(HANDLE Log)
{
    hlog = Log;
    xSetComponent( hlog, "Direct3D(S)", "XGraphics (s-d3d)" );
	RandomTest(1000, time(0)); //should take less than 2 minutes
}

VOID WINAPI SATESTEndTest(VOID)
{
}

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( SATEST )
#pragma data_seg()

BEGIN_EXPORT_TABLE( SATEST )
    EXPORT_TABLE_ENTRY( "StartTest", SATESTStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", SATESTEndTest )
END_EXPORT_TABLE( SATEST )

#endif
