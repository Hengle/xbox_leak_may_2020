; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	..\dmstrm.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04MCLIPFCH@lpck?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@DMHPOECL@Warning?3?5Reached?5end?5of?5file?4?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@NGDBOKBB@Error?3?5Unable?5to?5read?5file?4?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@MLHIBBFG@Error?3?5Unable?5to?5write?5file?4?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01LOCGONAA@?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07KCKPANJI@pStream?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06DGNELAAM@pChunk?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GMJLPMEF@m_pChunk?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@JOHDMAJD@Error?5parsing?5?$CFs?0?5Read?5?$CFld?5of?5?$CFl@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@JJGPIEEK@Entering?5?$CFs?0?5Length?5?$CFld?0?5File?5po@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08PDMNPFMK@?5Type?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@FMCKFKME@Leaving?5?$CFs?0?5Read?5?$CFld?5of?5?$CFld?0?5Fil@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FI@JANHFFNC@Warning?3?5SetDescriptor?5was?5not?5a@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@IBANCKHO@Error?3?5Size?5of?5descriptor?5too?5la@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@BHLIFOCK@Error?3?5Parsing?5file?5?9?5invalid?5fi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BGAOHDMM@?$CBp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT _AllocDirectMusicStream@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDirectMusicStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDMStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDirectMusicStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CDirectMusicStream@@UAGJPAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CDirectMusicStream@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CDirectMusicStream@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CDirectMusicStream@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCDirectMusicStream@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStream@CDirectMusicStream@@UAGJPAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStream@CDirectMusicStream@@UAGPAUIStream@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Descend@CDirectMusicStream@@UAGJPAU_MMCKINFO@@0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ascend@CDirectMusicStream@@UAGJPAU_MMCKINFO@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateChunk@CDirectMusicStream@@UAGJPAU_MMCKINFO@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRiffParser@@QAE@PAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LeaveList@CRiffParser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextChunk@CRiffParser@@QAEHPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoreChunks@CRiffParser@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnterChunk@CRiffParser@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LeaveChunk@CRiffParser@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Read@CRiffParser@@QAEJPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@CRiffParser@@QAEJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MarkPosition@CRiffParser@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SeekBack@CRiffParser@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SeekForward@CRiffParser@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@ABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ParseDescriptor@CInfo@@QAEJPAUIStream@@PAU_DMUS_OBJECTDESC@@KABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadChunk@CInfo@@QAEJPAVCRiffParser@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CInfo@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadReference@CLinkParser@@QAEJPAVCRiffParser@@PAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadReferencedObject@CLinkParser@@QAEJPAVCRiffParser@@PAPAXABU_GUID@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@UTriggerInfo@@@@QBEPAV?$TListItem@UTriggerInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@UTriggerInfo@@@@QAEXPAV?$TListItem@UTriggerInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@ULyricInfo@@@@QBEPAV?$TListItem@ULyricInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@UTriggerInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@UTriggerInfo@@@@QAEAAUTriggerInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@ULyricInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@UTriggerInfo@@@@SGHAAUTriggerInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@ULyricInfo@@@@SGHAAULyricInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStandardStateData@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@UTriggerInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEAAV01@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@UTriggerInfo@@@@QAEXP6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@ULyricInfo@@@@QAEXP6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UWaveItem@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@_J@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UObjectInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ObjectInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@UTriggerInfo@@@@QAEPAV1@P6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@ULyricInfo@@@@QAEPAV1@P6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@UTriggerInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@UTriggerInfo@@@@AAEPAV1@PAV1@P6GHAAUTriggerInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@ULyricInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@ULyricInfo@@@@AAEPAV1@PAV1@P6GHAAULyricInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UParamInfo@CParamControlTrack@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UParamInfo@CParamControlTrack@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ParamInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WaveItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WString@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WString@SmartRef@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@ULyricInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UTriggerInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UTriggerInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStream@CRiffParser@@QAEPAUIStream@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??QueryInterface@CDirectMusicStream@@UAGJABU_GUID@@PAPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CDirectMusicStream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_AllocDirectMusicStream@8
PUBLIC	??0CDirectMusicStream@@QAE@XZ			; CDirectMusicStream::CDirectMusicStream
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmstrm.cpp
;	COMDAT _AllocDirectMusicStream@8
_TEXT	SEGMENT
tv71 = -8
$T70552 = -4
_pIStream$ = 8
_ppIDMStream$ = 12
_AllocDirectMusicStream@8 PROC NEAR			; COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 18   : 	if(pIStream == NULL || ppIDMStream == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _pIStream$[ebp], 0
  0000a	74 06		 je	 SHORT $L69421
  0000c	83 7d 0c 00	 cmp	 DWORD PTR _ppIDMStream$[ebp], 0
  00010	75 07		 jne	 SHORT $L69420
$L69421:

; 19   : 	{
; 20   : 		return E_INVALIDARG;            

  00012	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00017	eb 52		 jmp	 SHORT $L69419
$L69420:

; 21   : 	}
; 22   : 
; 23   : 	if((*ppIDMStream = (IDMStream*) new CDirectMusicStream()) == NULL)

  00019	6a 0c		 push	 12			; 0000000cH
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	83 c4 04	 add	 esp, 4
  00023	89 45 fc	 mov	 DWORD PTR $T70552[ebp], eax
  00026	83 7d fc 00	 cmp	 DWORD PTR $T70552[ebp], 0
  0002a	74 0d		 je	 SHORT $L70553
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR $T70552[ebp]
  0002f	e8 00 00 00 00	 call	 ??0CDirectMusicStream@@QAE@XZ ; CDirectMusicStream::CDirectMusicStream
  00034	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
  00037	eb 07		 jmp	 SHORT $L70554
$L70553:
  00039	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L70554:
  00040	8b 45 0c	 mov	 eax, DWORD PTR _ppIDMStream$[ebp]
  00043	8b 4d f8	 mov	 ecx, DWORD PTR tv71[ebp]
  00046	89 08		 mov	 DWORD PTR [eax], ecx
  00048	83 7d f8 00	 cmp	 DWORD PTR tv71[ebp], 0
  0004c	75 07		 jne	 SHORT $L69426

; 24   :     {
; 25   : 		return E_OUTOFMEMORY;

  0004e	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00053	eb 16		 jmp	 SHORT $L69419
$L69426:

; 26   :     }
; 27   : 	
; 28   : 	((CDirectMusicStream*)*ppIDMStream)->Init(pIStream);

  00055	8b 55 08	 mov	 edx, DWORD PTR _pIStream$[ebp]
  00058	52		 push	 edx
  00059	8b 45 0c	 mov	 eax, DWORD PTR _ppIDMStream$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 55 0c	 mov	 edx, DWORD PTR _ppIDMStream$[ebp]
  00061	8b 02		 mov	 eax, DWORD PTR [edx]
  00063	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00065	50		 push	 eax
  00066	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 29   :     
; 30   : 	return S_OK;

  00069	33 c0		 xor	 eax, eax
$L69419:

; 31   : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 08 00	 ret	 8
_AllocDirectMusicStream@8 ENDP
_TEXT	ENDS
PUBLIC	??0IDMStream@@QAE@XZ				; IDMStream::IDMStream
PUBLIC	?Init@CDirectMusicStream@@UAGJPAUIStream@@@Z	; CDirectMusicStream::Init
PUBLIC	?QueryInterface@CDirectMusicStream@@UAGJABU_GUID@@PAPAX@Z ; CDirectMusicStream::QueryInterface
PUBLIC	?AddRef@CDirectMusicStream@@UAGKXZ		; CDirectMusicStream::AddRef
PUBLIC	?Release@CDirectMusicStream@@UAGKXZ		; CDirectMusicStream::Release
PUBLIC	?Descend@CDirectMusicStream@@UAGJPAU_MMCKINFO@@0I@Z ; CDirectMusicStream::Descend
PUBLIC	?Ascend@CDirectMusicStream@@UAGJPAU_MMCKINFO@@I@Z ; CDirectMusicStream::Ascend
PUBLIC	?CreateChunk@CDirectMusicStream@@UAGJPAU_MMCKINFO@@I@Z ; CDirectMusicStream::CreateChunk
PUBLIC	?SetStream@CDirectMusicStream@@UAGJPAUIStream@@@Z ; CDirectMusicStream::SetStream
PUBLIC	?GetStream@CDirectMusicStream@@UAGPAUIStream@@XZ ; CDirectMusicStream::GetStream
PUBLIC	??_7CDirectMusicStream@@6B@			; CDirectMusicStream::`vftable'
;	COMDAT ??_7CDirectMusicStream@@6B@
CONST	SEGMENT
??_7CDirectMusicStream@@6B@ DD FLAT:?QueryInterface@CDirectMusicStream@@UAGJABU_GUID@@PAPAX@Z ; CDirectMusicStream::`vftable'
	DD	FLAT:?AddRef@CDirectMusicStream@@UAGKXZ
	DD	FLAT:?Release@CDirectMusicStream@@UAGKXZ
	DD	FLAT:?Init@CDirectMusicStream@@UAGJPAUIStream@@@Z
	DD	FLAT:?Descend@CDirectMusicStream@@UAGJPAU_MMCKINFO@@0I@Z
	DD	FLAT:?Ascend@CDirectMusicStream@@UAGJPAU_MMCKINFO@@I@Z
	DD	FLAT:?CreateChunk@CDirectMusicStream@@UAGJPAU_MMCKINFO@@I@Z
	DD	FLAT:?SetStream@CDirectMusicStream@@UAGJPAUIStream@@@Z
	DD	FLAT:?GetStream@CDirectMusicStream@@UAGPAUIStream@@XZ
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CDirectMusicStream@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CDirectMusicStream@@QAE@XZ PROC NEAR			; CDirectMusicStream::CDirectMusicStream, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IDMStream@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDirectMusicStream@@6B@
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 40   : }

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??0CDirectMusicStream@@QAE@XZ ENDP			; CDirectMusicStream::CDirectMusicStream
_TEXT	ENDS
PUBLIC	??0IUnknown@@QAE@XZ				; IUnknown::IUnknown
; Function compile flags: /Odt
;	COMDAT ??0IDMStream@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDMStream@@QAE@XZ PROC NEAR				; IDMStream::IDMStream, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IDMStream@@QAE@XZ ENDP				; IDMStream::IDMStream
_TEXT	ENDS
PUBLIC	??1CDirectMusicStream@@QAE@XZ			; CDirectMusicStream::~CDirectMusicStream
; Function compile flags: /Odt
;	COMDAT ??1CDirectMusicStream@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CDirectMusicStream@@QAE@XZ PROC NEAR			; CDirectMusicStream::~CDirectMusicStream, COMDAT
; _this$ = ecx

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDirectMusicStream@@6B@

; 47   : 	if(m_pStream != NULL)

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00017	74 12		 je	 SHORT $L69437

; 48   :     {
; 49   : 		m_pStream->Release();

  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	52		 push	 edx
  00028	ff 50 08	 call	 DWORD PTR [eax+8]
$L69437:

; 50   :     }
; 51   : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??1CDirectMusicStream@@QAE@XZ ENDP			; CDirectMusicStream::~CDirectMusicStream
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Init@CDirectMusicStream@@UAGJPAUIStream@@@Z
_TEXT	SEGMENT
_this$ = 8
_pStream$ = 12
?Init@CDirectMusicStream@@UAGJPAUIStream@@@Z PROC NEAR	; CDirectMusicStream::Init, COMDAT

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 58   :     SetStream(pStream);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pStream$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	ff 52 1c	 call	 DWORD PTR [edx+28]

; 59   : 	
; 60   : 	return S_OK;

  00013	33 c0		 xor	 eax, eax

; 61   : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?Init@CDirectMusicStream@@UAGJPAUIStream@@@Z ENDP	; CDirectMusicStream::Init
_TEXT	ENDS
PUBLIC	??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@ ; `string'
PUBLIC	_==@8
EXTRN	?DebugTrace@@YAXHPADZZ:NEAR			; DebugTrace
EXTRN	_DebugBreak@0:NEAR
EXTRN	_IID_IUnknown:BYTE
EXTRN	_IsBadReadPtr@8:NEAR
EXTRN	_IsBadWritePtr@8:NEAR
EXTRN	_IID_IDMStream:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??QueryInterface@CDirectMusicStream@@UAGJABU_GUID@@PAPAX@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??QueryInterface@CDirectMusicStream@@UAGJABU_GUID@@PAPAX@Z@4QBDB DB 'C'
	DB	'DirectMusicStream::QueryInterface', 00H	; `CDirectMusicStream::QueryInterface'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
CONST	SEGMENT
??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@ DB '%s: Invalid '
	DB	'pointer ppv', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
CONST	SEGMENT
??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@ DB '%'
	DB	's: Invalid pointer (void*)&iid', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?QueryInterface@CDirectMusicStream@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8
_iid$ = 12
_ppv$ = 16
?QueryInterface@CDirectMusicStream@@UAGJABU_GUID@@PAPAX@Z PROC NEAR ; CDirectMusicStream::QueryInterface, COMDAT

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 71   : 	V_INAME(CDirectMusicStream::QueryInterface);
; 72   : 	V_PTRPTR_WRITE(ppv);

  00003	6a 04		 push	 4
  00005	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L69452
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??QueryInterface@CDirectMusicStream@@UAGJABU_GUID@@PAPAX@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L69452:

; 73   : 	V_REFGUID(iid);

  0002b	6a 10		 push	 16			; 00000010H
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00036	85 c0		 test	 eax, eax
  00038	74 19		 je	 SHORT $L69456
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??QueryInterface@CDirectMusicStream@@UAGJABU_GUID@@PAPAX@Z@4QBDB
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
  00044	6a ff		 push	 -1
  00046	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	e8 00 00 00 00	 call	 _DebugBreak@0
$L69456:

; 74   : 
; 75   : 	if(iid == IID_IUnknown || iid == IID_IDMStream)

  00053	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IUnknown
  00058	8b 55 0c	 mov	 edx, DWORD PTR _iid$[ebp]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _==@8
  00061	85 c0		 test	 eax, eax
  00063	75 12		 jne	 SHORT $L69459
  00065	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDMStream
  0006a	8b 45 0c	 mov	 eax, DWORD PTR _iid$[ebp]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 _==@8
  00073	85 c0		 test	 eax, eax
  00075	74 0a		 je	 SHORT $L69458
$L69459:

; 76   : 	{
; 77   : 		*ppv = static_cast<IDMStream*>(this);

  00077	8b 4d 10	 mov	 ecx, DWORD PTR _ppv$[ebp]
  0007a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0007d	89 11		 mov	 DWORD PTR [ecx], edx

; 78   :     } 
; 79   : 	else 

  0007f	eb 10		 jmp	 SHORT $L69461
$L69458:

; 80   : 	{
; 81   : 		*ppv = NULL;

  00081	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  00084	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 82   : 		return E_NOINTERFACE;

  0008a	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
  0008f	eb 0e		 jmp	 SHORT $L69448
$L69461:

; 83   :     }
; 84   : 
; 85   :     reinterpret_cast<IUnknown*>(this)->AddRef();

  00091	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	8b 11		 mov	 edx, DWORD PTR [ecx]
  00096	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00099	50		 push	 eax
  0009a	ff 52 04	 call	 DWORD PTR [edx+4]

; 86   :     
; 87   : 	return S_OK;

  0009d	33 c0		 xor	 eax, eax
$L69448:

; 88   : }

  0009f	5d		 pop	 ebp
  000a0	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CDirectMusicStream@@UAGJABU_GUID@@PAPAX@Z ENDP ; CDirectMusicStream::QueryInterface
_TEXT	ENDS
EXTRN	__InterlockedIncrement@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?AddRef@CDirectMusicStream@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8
?AddRef@CDirectMusicStream@@UAGKXZ PROC NEAR		; CDirectMusicStream::AddRef, COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 	return InterlockedIncrement(&m_cRef);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	83 c0 04	 add	 eax, 4
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __InterlockedIncrement@4

; 96   : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?AddRef@CDirectMusicStream@@UAGKXZ ENDP			; CDirectMusicStream::AddRef
_TEXT	ENDS
PUBLIC	??_GCDirectMusicStream@@QAEPAXI@Z		; CDirectMusicStream::`scalar deleting destructor'
EXTRN	__InterlockedDecrement@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Release@CDirectMusicStream@@UAGKXZ
_TEXT	SEGMENT
tv72 = -12
$T70577 = -8
$T70576 = -4
_this$ = 8
?Release@CDirectMusicStream@@UAGKXZ PROC NEAR		; CDirectMusicStream::Release, COMDAT

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 103  :     if(!InterlockedDecrement(&m_cRef)) 

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	83 c0 04	 add	 eax, 4
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __InterlockedDecrement@4
  00012	85 c0		 test	 eax, eax
  00014	75 2c		 jne	 SHORT $L69471

; 104  : 	{
; 105  : 		delete this;

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	89 4d f8	 mov	 DWORD PTR $T70577[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR $T70577[ebp]
  0001f	89 55 fc	 mov	 DWORD PTR $T70576[ebp], edx
  00022	83 7d fc 00	 cmp	 DWORD PTR $T70576[ebp], 0
  00026	74 0f		 je	 SHORT $L70578
  00028	6a 01		 push	 1
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR $T70576[ebp]
  0002d	e8 00 00 00 00	 call	 ??_GCDirectMusicStream@@QAEPAXI@Z
  00032	89 45 f4	 mov	 DWORD PTR tv72[ebp], eax
  00035	eb 07		 jmp	 SHORT $L70579
$L70578:
  00037	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L70579:

; 106  : 		return 0;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 06		 jmp	 SHORT $L69470
$L69471:

; 107  :     }
; 108  : 
; 109  :     return m_cRef;

  00042	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
$L69470:

; 110  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?Release@CDirectMusicStream@@UAGKXZ ENDP		; CDirectMusicStream::Release
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCDirectMusicStream@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCDirectMusicStream@@QAEPAXI@Z PROC NEAR		; CDirectMusicStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CDirectMusicStream@@QAE@XZ ; CDirectMusicStream::~CDirectMusicStream
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69477
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69477:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCDirectMusicStream@@QAEPAXI@Z ENDP			; CDirectMusicStream::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	_IsEqualGUID@8
; Function compile flags: /Odt
; File c:\xbox\public\sdk\inc\guiddef.h
;	COMDAT _==@8
_TEXT	SEGMENT
_guidOne$ = 8
_guidOther$ = 12
_==@8	PROC NEAR					; COMDAT

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 189  :     return IsEqualGUID(guidOne,guidOther);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _guidOther$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _guidOne$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _IsEqualGUID@8

; 190  : }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
_==@8	ENDP
_TEXT	ENDS
EXTRN	_memcmp:NEAR
; Function compile flags: /Odt
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT
_rguid1$ = 8
_rguid2$ = 12
_IsEqualGUID@8 PROC NEAR				; COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 156  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _rguid2$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _rguid1$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _memcmp
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	f7 d8		 neg	 eax
  00017	1b c0		 sbb	 eax, eax
  00019	40		 inc	 eax

; 157  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_IsEqualGUID@8 ENDP
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmstrm.cpp
_TEXT	ENDS
;	COMDAT ?SetStream@CDirectMusicStream@@UAGJPAUIStream@@@Z
_TEXT	SEGMENT
_this$ = 8
_pStream$ = 12
?SetStream@CDirectMusicStream@@UAGJPAUIStream@@@Z PROC NEAR ; CDirectMusicStream::SetStream, COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 117  :     if(m_pStream != NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0000a	74 12		 je	 SHORT $L69482

; 118  :     {
; 119  : 		m_pStream->Release();

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00012	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00018	8b 12		 mov	 edx, DWORD PTR [edx]
  0001a	51		 push	 ecx
  0001b	ff 52 08	 call	 DWORD PTR [edx+8]
$L69482:

; 120  :     }
; 121  : 
; 122  : 	m_pStream = pStream;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _pStream$[ebp]
  00024	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 123  :     
; 124  : 	if(m_pStream != NULL)

  00027	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  0002e	74 12		 je	 SHORT $L69483

; 125  :     {
; 126  : 		m_pStream->AddRef();

  00030	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00036	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00039	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	50		 push	 eax
  0003f	ff 51 04	 call	 DWORD PTR [ecx+4]
$L69483:

; 127  :     }
; 128  :     
; 129  : 	return S_OK;

  00042	33 c0		 xor	 eax, eax

; 130  : }

  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
?SetStream@CDirectMusicStream@@UAGJPAUIStream@@@Z ENDP	; CDirectMusicStream::SetStream
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetStream@CDirectMusicStream@@UAGPAUIStream@@XZ
_TEXT	SEGMENT
_this$ = 8
?GetStream@CDirectMusicStream@@UAGPAUIStream@@XZ PROC NEAR ; CDirectMusicStream::GetStream, COMDAT

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 137  : 	if(m_pStream != NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0000a	74 12		 je	 SHORT $L69488

; 138  :     {
; 139  : 		m_pStream->AddRef();

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00012	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00018	8b 12		 mov	 edx, DWORD PTR [edx]
  0001a	51		 push	 ecx
  0001b	ff 52 04	 call	 DWORD PTR [edx+4]
$L69488:

; 140  :     }
; 141  :     
; 142  : 	return m_pStream;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 143  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?GetStream@CDirectMusicStream@@UAGPAUIStream@@XZ ENDP	; CDirectMusicStream::GetStream
_TEXT	ENDS
PUBLIC	??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_04MCLIPFCH@lpck?$AA@			; `string'
PUBLIC	??_C@_0BP@DMHPOECL@Warning?3?5Reached?5end?5of?5file?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@NGDBOKBB@Error?3?5Unable?5to?5read?5file?4?6?$AA@ ; `string'
EXTRN	?DebugAssert@@YGXPAD0K@Z:NEAR			; DebugAssert
;	COMDAT ??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dmusic\dmime\dmstrm.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MCLIPFCH@lpck?$AA@
CONST	SEGMENT
??_C@_04MCLIPFCH@lpck?$AA@ DB 'lpck', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DMHPOECL@Warning?3?5Reached?5end?5of?5file?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@DMHPOECL@Warning?3?5Reached?5end?5of?5file?4?6?$AA@ DB 'Warning'
	DB	': Reached end of file.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NGDBOKBB@Error?3?5Unable?5to?5read?5file?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@NGDBOKBB@Error?3?5Unable?5to?5read?5file?4?6?$AA@ DB 'Error: Un'
	DB	'able to read file.', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Descend@CDirectMusicStream@@UAGJPAU_MMCKINFO@@0I@Z
_TEXT	SEGMENT
_hr$69525 = -36
_li$69526 = -32
_uli$69527 = -24
_cbRead$69528 = -16
_w$69571 = -12
_ckidFind$ = -8
_fccTypeFind$ = -4
_this$ = 8
_lpck$ = 12
_lpckParent$ = 16
_wFlags$ = 20
?Descend@CDirectMusicStream@@UAGJPAU_MMCKINFO@@0I@Z PROC NEAR ; CDirectMusicStream::Descend, COMDAT

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 153  :     assert(lpck);

  00006	83 7d 0c 00	 cmp	 DWORD PTR _lpck$[ebp], 0
  0000a	75 14		 jne	 SHORT $L70598
  0000c	68 99 00 00 00	 push	 153			; 00000099H
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04MCLIPFCH@lpck?$AA@
  0001b	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70598:

; 154  : 
; 155  : 	FOURCC ckidFind;           // Chunk ID to find (or NULL)
; 156  :     FOURCC fccTypeFind;    // Form/list type to find (or NULL)
; 157  : 
; 158  :     // Figure out what chunk id and form/list type for which to search
; 159  :     if(wFlags & MMIO_FINDCHUNK)

  00020	8b 4d 14	 mov	 ecx, DWORD PTR _wFlags$[ebp]
  00023	83 e1 10	 and	 ecx, 16			; 00000010H
  00026	85 c9		 test	 ecx, ecx
  00028	74 11		 je	 SHORT $L69500

; 160  : 	{
; 161  : 		ckidFind = lpck->ckid;

  0002a	8b 55 0c	 mov	 edx, DWORD PTR _lpck$[ebp]
  0002d	8b 02		 mov	 eax, DWORD PTR [edx]
  0002f	89 45 f8	 mov	 DWORD PTR _ckidFind$[ebp], eax

; 162  : 		fccTypeFind = NULL;

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fccTypeFind$[ebp], 0

; 163  : 	}
; 164  :     else if(wFlags & MMIO_FINDRIFF)

  00039	eb 45		 jmp	 SHORT $L69501
$L69500:
  0003b	8b 4d 14	 mov	 ecx, DWORD PTR _wFlags$[ebp]
  0003e	83 e1 20	 and	 ecx, 32			; 00000020H
  00041	85 c9		 test	 ecx, ecx
  00043	74 12		 je	 SHORT $L69502

; 165  :     {
; 166  : 		ckidFind = FOURCC_RIFF;

  00045	c7 45 f8 52 49
	46 46		 mov	 DWORD PTR _ckidFind$[ebp], 1179011410 ; 46464952H

; 167  : 		fccTypeFind = lpck->fccType;

  0004c	8b 55 0c	 mov	 edx, DWORD PTR _lpck$[ebp]
  0004f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00052	89 45 fc	 mov	 DWORD PTR _fccTypeFind$[ebp], eax

; 168  :     }
; 169  : 	else if(wFlags & MMIO_FINDLIST)

  00055	eb 29		 jmp	 SHORT $L69501
$L69502:
  00057	8b 4d 14	 mov	 ecx, DWORD PTR _wFlags$[ebp]
  0005a	83 e1 40	 and	 ecx, 64			; 00000040H
  0005d	85 c9		 test	 ecx, ecx
  0005f	74 12		 je	 SHORT $L69512

; 170  : 	{
; 171  : 		ckidFind = FOURCC_LIST;

  00061	c7 45 f8 4c 49
	53 54		 mov	 DWORD PTR _ckidFind$[ebp], 1414744396 ; 5453494cH

; 172  : 		fccTypeFind = lpck->fccType;

  00068	8b 55 0c	 mov	 edx, DWORD PTR _lpck$[ebp]
  0006b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0006e	89 45 fc	 mov	 DWORD PTR _fccTypeFind$[ebp], eax

; 173  : 	}
; 174  :     else

  00071	eb 0d		 jmp	 SHORT $L69501
$L69512:

; 175  :     {
; 176  : 		ckidFind = fccTypeFind = NULL;

  00073	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fccTypeFind$[ebp], 0
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _fccTypeFind$[ebp]
  0007d	89 4d f8	 mov	 DWORD PTR _ckidFind$[ebp], ecx
$L69501:

; 177  : 	}
; 178  : 
; 179  :     lpck->dwFlags = 0L;

  00080	8b 55 0c	 mov	 edx, DWORD PTR _lpck$[ebp]
  00083	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0
$L69523:

; 180  : 
; 181  :     for(;;)
; 182  :     {
; 183  : 		HRESULT hr;
; 184  : 		LARGE_INTEGER li;
; 185  : 		ULARGE_INTEGER uli;
; 186  : 		ULONG cbRead;
; 187  : 
; 188  : 		// Read the chunk header
; 189  : 		hr = m_pStream->Read(lpck, 2 * sizeof(DWORD), &cbRead);

  0008a	8d 45 f0	 lea	 eax, DWORD PTR _cbRead$69528[ebp]
  0008d	50		 push	 eax
  0008e	6a 08		 push	 8
  00090	8b 4d 0c	 mov	 ecx, DWORD PTR _lpck$[ebp]
  00093	51		 push	 ecx
  00094	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00097	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000a0	8b 00		 mov	 eax, DWORD PTR [eax]
  000a2	52		 push	 edx
  000a3	ff 50 0c	 call	 DWORD PTR [eax+12]
  000a6	89 45 dc	 mov	 DWORD PTR _hr$69525[ebp], eax

; 190  : 
; 191  :         if (FAILED(hr) || (cbRead != 2 * sizeof(DWORD)))

  000a9	83 7d dc 00	 cmp	 DWORD PTR _hr$69525[ebp], 0
  000ad	7c 06		 jl	 SHORT $L69533
  000af	83 7d f0 08	 cmp	 DWORD PTR _cbRead$69528[ebp], 8
  000b3	74 19		 je	 SHORT $L69532
$L69533:

; 192  : 		{
; 193  :             Trace(3,"Warning: Reached end of file.\n");

  000b5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@DMHPOECL@Warning?3?5Reached?5end?5of?5file?4?6?$AA@
  000ba	6a 03		 push	 3
  000bc	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000c1	83 c4 08	 add	 esp, 8

; 194  : 			return DMUS_E_DESCEND_CHUNK_FAIL;

  000c4	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  000c9	e9 32 01 00 00	 jmp	 $L69494
$L69532:

; 195  : 		}
; 196  : 
; 197  : 		// Store the offset of the data part of the chunk
; 198  : 		li.QuadPart = 0;

  000ce	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _li$69526[ebp], 0
  000d5	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _li$69526[ebp+4], 0

; 199  : 		hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

  000dc	8d 4d e8	 lea	 ecx, DWORD PTR _uli$69527[ebp]
  000df	51		 push	 ecx
  000e0	6a 01		 push	 1
  000e2	8b 55 e4	 mov	 edx, DWORD PTR _li$69526[ebp+4]
  000e5	52		 push	 edx
  000e6	8b 45 e0	 mov	 eax, DWORD PTR _li$69526[ebp]
  000e9	50		 push	 eax
  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000f0	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000f3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000f6	8b 12		 mov	 edx, DWORD PTR [edx]
  000f8	51		 push	 ecx
  000f9	ff 52 14	 call	 DWORD PTR [edx+20]
  000fc	89 45 dc	 mov	 DWORD PTR _hr$69525[ebp], eax

; 200  : 
; 201  : 		if(FAILED(hr))

  000ff	83 7d dc 00	 cmp	 DWORD PTR _hr$69525[ebp], 0
  00103	7d 19		 jge	 SHORT $L69537

; 202  : 		{
; 203  :             Trace(1,"Error: Unable to read file.\n");

  00105	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@NGDBOKBB@Error?3?5Unable?5to?5read?5file?4?6?$AA@
  0010a	6a 01		 push	 1
  0010c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00111	83 c4 08	 add	 esp, 8

; 204  : 			return DMUS_E_CANNOTSEEK;

  00114	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00119	e9 e2 00 00 00	 jmp	 $L69494
$L69537:

; 205  : 		}
; 206  : 		else
; 207  : 		{
; 208  : 			lpck->dwDataOffset = uli.LowPart;

  0011e	8b 45 0c	 mov	 eax, DWORD PTR _lpck$[ebp]
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _uli$69527[ebp]
  00124	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 209  : 		}
; 210  : 
; 211  : 		// See if the chunk is within the parent chunk (if given)
; 212  : 		if((lpckParent != NULL) &&
; 213  : 		   (lpck->dwDataOffset - 8L >=
; 214  : 		   lpckParent->dwDataOffset + lpckParent->cksize))

  00127	83 7d 10 00	 cmp	 DWORD PTR _lpckParent$[ebp], 0
  0012b	74 23		 je	 SHORT $L69541
  0012d	8b 55 0c	 mov	 edx, DWORD PTR _lpck$[ebp]
  00130	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00133	83 e8 08	 sub	 eax, 8
  00136	8b 4d 10	 mov	 ecx, DWORD PTR _lpckParent$[ebp]
  00139	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0013c	8b 4d 10	 mov	 ecx, DWORD PTR _lpckParent$[ebp]
  0013f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00142	3b c2		 cmp	 eax, edx
  00144	72 0a		 jb	 SHORT $L69541

; 215  : 		{
; 216  :             // This is not really a failure, just indicating we've reached the end of the list.
; 217  : 			return DMUS_E_DESCEND_CHUNK_FAIL;

  00146	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0014b	e9 b0 00 00 00	 jmp	 $L69494
$L69541:

; 218  : 		}
; 219  : 
; 220  : 		// If the chunk is a 'RIFF' or 'LIST' chunk, read the
; 221  : 		// form type or list type
; 222  : 		if((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))

  00150	8b 55 0c	 mov	 edx, DWORD PTR _lpck$[ebp]
  00153	81 3a 52 49 46
	46		 cmp	 DWORD PTR [edx], 1179011410 ; 46464952H
  00159	74 0b		 je	 SHORT $L69560
  0015b	8b 45 0c	 mov	 eax, DWORD PTR _lpck$[ebp]
  0015e	81 38 4c 49 53
	54		 cmp	 DWORD PTR [eax], 1414744396 ; 5453494cH
  00164	75 46		 jne	 SHORT $L69559
$L69560:

; 223  : 		{
; 224  : 
; 225  : 			hr = m_pStream->Read(&lpck->fccType, sizeof(DWORD), &cbRead);

  00166	8d 4d f0	 lea	 ecx, DWORD PTR _cbRead$69528[ebp]
  00169	51		 push	 ecx
  0016a	6a 04		 push	 4
  0016c	8b 55 0c	 mov	 edx, DWORD PTR _lpck$[ebp]
  0016f	83 c2 08	 add	 edx, 8
  00172	52		 push	 edx
  00173	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00176	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00179	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0017c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0017f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00181	50		 push	 eax
  00182	ff 51 0c	 call	 DWORD PTR [ecx+12]
  00185	89 45 dc	 mov	 DWORD PTR _hr$69525[ebp], eax

; 226  : 
; 227  : 			if(FAILED(hr) || (cbRead != sizeof(DWORD)))

  00188	83 7d dc 00	 cmp	 DWORD PTR _hr$69525[ebp], 0
  0018c	7c 06		 jl	 SHORT $L69565
  0018e	83 7d f0 04	 cmp	 DWORD PTR _cbRead$69528[ebp], 4
  00192	74 16		 je	 SHORT $L69564
$L69565:

; 228  : 			{
; 229  :                 Trace(1,"Error: Unable to read file.\n");

  00194	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@NGDBOKBB@Error?3?5Unable?5to?5read?5file?4?6?$AA@
  00199	6a 01		 push	 1
  0019b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001a0	83 c4 08	 add	 esp, 8

; 230  : 				return DMUS_E_DESCEND_CHUNK_FAIL;

  001a3	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  001a8	eb 56		 jmp	 SHORT $L69494
$L69564:

; 231  : 			}
; 232  : 		}
; 233  : 		else

  001aa	eb 0a		 jmp	 SHORT $L69567
$L69559:

; 234  : 		{
; 235  : 			lpck->fccType = NULL;

  001ac	8b 55 0c	 mov	 edx, DWORD PTR _lpck$[ebp]
  001af	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
$L69567:

; 236  : 		}
; 237  : 
; 238  : 		// If this is the chunk we're looking for, stop looking
; 239  : 		if(((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
; 240  : 		   ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)))

  001b6	83 7d f8 00	 cmp	 DWORD PTR _ckidFind$[ebp], 0
  001ba	74 0a		 je	 SHORT $L69569
  001bc	8b 45 0c	 mov	 eax, DWORD PTR _lpck$[ebp]
  001bf	8b 4d f8	 mov	 ecx, DWORD PTR _ckidFind$[ebp]
  001c2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001c4	75 13		 jne	 SHORT $L69568
$L69569:
  001c6	83 7d fc 00	 cmp	 DWORD PTR _fccTypeFind$[ebp], 0
  001ca	74 0b		 je	 SHORT $L69570
  001cc	8b 55 0c	 mov	 edx, DWORD PTR _lpck$[ebp]
  001cf	8b 45 fc	 mov	 eax, DWORD PTR _fccTypeFind$[ebp]
  001d2	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  001d5	75 02		 jne	 SHORT $L69568
$L69570:

; 241  : 		{
; 242  : 			break;

  001d7	eb 25		 jmp	 SHORT $L69524
$L69568:

; 243  : 		}
; 244  : 
; 245  : 		// Ascend out of the chunk and try again
; 246  : 		HRESULT w = Ascend(lpck, 0);

  001d9	6a 00		 push	 0
  001db	8b 4d 0c	 mov	 ecx, DWORD PTR _lpck$[ebp]
  001de	51		 push	 ecx
  001df	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001e2	8b 02		 mov	 eax, DWORD PTR [edx]
  001e4	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001e7	51		 push	 ecx
  001e8	ff 50 14	 call	 DWORD PTR [eax+20]
  001eb	89 45 f4	 mov	 DWORD PTR _w$69571[ebp], eax

; 247  : 		if(FAILED(w))

  001ee	83 7d f4 00	 cmp	 DWORD PTR _w$69571[ebp], 0
  001f2	7d 05		 jge	 SHORT $L69573

; 248  : 		{
; 249  : 			return w;

  001f4	8b 45 f4	 mov	 eax, DWORD PTR _w$69571[ebp]
  001f7	eb 07		 jmp	 SHORT $L69494
$L69573:

; 250  : 		}
; 251  : 	}

  001f9	e9 8c fe ff ff	 jmp	 $L69523
$L69524:

; 252  : 
; 253  :     return S_OK;

  001fe	33 c0		 xor	 eax, eax
$L69494:

; 254  : }

  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c2 10 00	 ret	 16			; 00000010H
?Descend@CDirectMusicStream@@UAGJPAU_MMCKINFO@@0I@Z ENDP ; CDirectMusicStream::Descend
_TEXT	ENDS
PUBLIC	??_C@_0BO@MLHIBBFG@Error?3?5Unable?5to?5write?5file?4?6?$AA@ ; `string'
PUBLIC	??_C@_01LOCGONAA@?$AA?$AA@			; `string'
;	COMDAT ??_C@_0BO@MLHIBBFG@Error?3?5Unable?5to?5write?5file?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@MLHIBBFG@Error?3?5Unable?5to?5write?5file?4?6?$AA@ DB 'Error: U'
	DB	'nable to write file.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_01LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Ascend@CDirectMusicStream@@UAGJPAU_MMCKINFO@@I@Z
_TEXT	SEGMENT
_cbWritten$69597 = -36
_cbWritten$69610 = -32
_lOffset$69585 = -28
_lActualSize$69586 = -24
_hr$ = -20
_li$ = -16
_uli$ = -8
_this$ = 8
_lpck$ = 12
___formal$ = 16
?Ascend@CDirectMusicStream@@UAGJPAU_MMCKINFO@@I@Z PROC NEAR ; CDirectMusicStream::Ascend, COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 262  : 	assert(lpck);

  00006	83 7d 0c 00	 cmp	 DWORD PTR _lpck$[ebp], 0
  0000a	75 14		 jne	 SHORT $L70602
  0000c	68 06 01 00 00	 push	 262			; 00000106H
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04MCLIPFCH@lpck?$AA@
  0001b	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70602:

; 263  : 
; 264  :     HRESULT hr;
; 265  : 	LARGE_INTEGER li;
; 266  : 	ULARGE_INTEGER uli;
; 267  : 	
; 268  : 	if (lpck->dwFlags & MMIO_DIRTY)

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _lpck$[ebp]
  00023	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00026	81 e2 00 00 00
	10		 and	 edx, 268435456		; 10000000H
  0002c	85 d2		 test	 edx, edx
  0002e	0f 84 8b 01 00
	00		 je	 $L69584

; 269  :     {
; 270  : 		// <lpck> refers to a chunk created by CreateChunk();
; 271  : 		// check that the chunk size that was written when
; 272  : 		// CreateChunk() was called is the real chunk size;
; 273  : 		// if not, fix it
; 274  : 		LONG lOffset;           // current offset in file
; 275  : 		LONG lActualSize;   // actual size of chunk data
; 276  : 
; 277  : 		li.QuadPart = 0;

  00034	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _li$[ebp], 0
  0003b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _li$[ebp+4], 0

; 278  : 		hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

  00042	8d 45 f8	 lea	 eax, DWORD PTR _uli$[ebp]
  00045	50		 push	 eax
  00046	6a 01		 push	 1
  00048	8b 4d f4	 mov	 ecx, DWORD PTR _li$[ebp+4]
  0004b	51		 push	 ecx
  0004c	8b 55 f0	 mov	 edx, DWORD PTR _li$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00056	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00059	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0005e	50		 push	 eax
  0005f	ff 51 14	 call	 DWORD PTR [ecx+20]
  00062	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 279  : 
; 280  : 		if(FAILED(hr))

  00065	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00069	7d 19		 jge	 SHORT $L69588

; 281  : 		{
; 282  :             Trace(1,"Error: Unable to write file.\n");

  0006b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@MLHIBBFG@Error?3?5Unable?5to?5write?5file?4?6?$AA@
  00070	6a 01		 push	 1
  00072	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00077	83 c4 08	 add	 esp, 8

; 283  : 			return DMUS_E_CANNOTSEEK;

  0007a	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0007f	e9 9b 01 00 00	 jmp	 $L69579
$L69588:

; 284  : 		}
; 285  : 		else
; 286  : 		{
; 287  : 			lOffset = uli.LowPart;

  00084	8b 55 f8	 mov	 edx, DWORD PTR _uli$[ebp]
  00087	89 55 e4	 mov	 DWORD PTR _lOffset$69585[ebp], edx

; 288  : 		}
; 289  : 		
; 290  : 		if((lActualSize = lOffset - lpck->dwDataOffset) < 0)

  0008a	8b 45 0c	 mov	 eax, DWORD PTR _lpck$[ebp]
  0008d	8b 4d e4	 mov	 ecx, DWORD PTR _lOffset$69585[ebp]
  00090	2b 48 0c	 sub	 ecx, DWORD PTR [eax+12]
  00093	89 4d e8	 mov	 DWORD PTR _lActualSize$69586[ebp], ecx
  00096	83 7d e8 00	 cmp	 DWORD PTR _lActualSize$69586[ebp], 0
  0009a	7d 19		 jge	 SHORT $L69592

; 291  : 		{
; 292  :             Trace(1,"Error: Unable to write file.\n");

  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@MLHIBBFG@Error?3?5Unable?5to?5write?5file?4?6?$AA@
  000a1	6a 01		 push	 1
  000a3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a8	83 c4 08	 add	 esp, 8

; 293  : 			return DMUS_E_CANNOTWRITE;

  000ab	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  000b0	e9 6a 01 00 00	 jmp	 $L69579
$L69592:

; 294  : 		}
; 295  : 
; 296  : 		if(LOWORD(lActualSize) & 1)

  000b5	8b 55 e8	 mov	 edx, DWORD PTR _lActualSize$69586[ebp]
  000b8	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000be	0f b7 c2	 movzx	 eax, dx
  000c1	83 e0 01	 and	 eax, 1
  000c4	85 c0		 test	 eax, eax
  000c6	74 45		 je	 SHORT $L69596

; 297  : 		{
; 298  : 			ULONG cbWritten;
; 299  : 
; 300  : 			// Chunk size is odd -- write a null pad byte
; 301  : 			hr = m_pStream->Write("\0", 1, &cbWritten); 

  000c8	8d 4d dc	 lea	 ecx, DWORD PTR _cbWritten$69597[ebp]
  000cb	51		 push	 ecx
  000cc	6a 01		 push	 1
  000ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01LOCGONAA@?$AA?$AA@
  000d3	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000d6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000d9	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000dc	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000df	8b 00		 mov	 eax, DWORD PTR [eax]
  000e1	52		 push	 edx
  000e2	ff 50 10	 call	 DWORD PTR [eax+16]
  000e5	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 302  : 			
; 303  : 			if(FAILED(hr) || cbWritten != 1)

  000e8	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ec	7c 06		 jl	 SHORT $L69601
  000ee	83 7d dc 01	 cmp	 DWORD PTR _cbWritten$69597[ebp], 1
  000f2	74 19		 je	 SHORT $L69596
$L69601:

; 304  : 			{
; 305  :                 Trace(1,"Error: Unable to write file.\n");

  000f4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@MLHIBBFG@Error?3?5Unable?5to?5write?5file?4?6?$AA@
  000f9	6a 01		 push	 1
  000fb	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00100	83 c4 08	 add	 esp, 8

; 306  : 				return DMUS_E_CANNOTWRITE;

  00103	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00108	e9 12 01 00 00	 jmp	 $L69579
$L69596:

; 307  : 			}
; 308  : 		
; 309  : 		}
; 310  : 	
; 311  : 		if(lpck->cksize == (DWORD)lActualSize)

  0010d	8b 4d 0c	 mov	 ecx, DWORD PTR _lpck$[ebp]
  00110	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00113	3b 55 e8	 cmp	 edx, DWORD PTR _lActualSize$69586[ebp]
  00116	75 07		 jne	 SHORT $L69604

; 312  : 		{
; 313  : 			return S_OK;

  00118	33 c0		 xor	 eax, eax
  0011a	e9 00 01 00 00	 jmp	 $L69579
$L69604:

; 314  : 		}
; 315  : 
; 316  : 		// Fix the chunk header
; 317  : 		lpck->cksize = lActualSize;

  0011f	8b 45 0c	 mov	 eax, DWORD PTR _lpck$[ebp]
  00122	8b 4d e8	 mov	 ecx, DWORD PTR _lActualSize$69586[ebp]
  00125	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 318  : 
; 319  : 		li.QuadPart = lpck->dwDataOffset - sizeof(DWORD);

  00128	8b 55 0c	 mov	 edx, DWORD PTR _lpck$[ebp]
  0012b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0012e	83 e8 04	 sub	 eax, 4
  00131	33 c9		 xor	 ecx, ecx
  00133	89 45 f0	 mov	 DWORD PTR _li$[ebp], eax
  00136	89 4d f4	 mov	 DWORD PTR _li$[ebp+4], ecx

; 320  : 		hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

  00139	8d 55 f8	 lea	 edx, DWORD PTR _uli$[ebp]
  0013c	52		 push	 edx
  0013d	6a 00		 push	 0
  0013f	8b 45 f4	 mov	 eax, DWORD PTR _li$[ebp+4]
  00142	50		 push	 eax
  00143	8b 4d f0	 mov	 ecx, DWORD PTR _li$[ebp]
  00146	51		 push	 ecx
  00147	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0014a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0014d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00150	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00153	8b 00		 mov	 eax, DWORD PTR [eax]
  00155	52		 push	 edx
  00156	ff 50 14	 call	 DWORD PTR [eax+20]
  00159	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 321  : 
; 322  : 		if(FAILED(hr))

  0015c	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00160	7d 19		 jge	 SHORT $L69608

; 323  : 		{
; 324  :             Trace(1,"Error: Unable to write file.\n");

  00162	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@MLHIBBFG@Error?3?5Unable?5to?5write?5file?4?6?$AA@
  00167	6a 01		 push	 1
  00169	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0016e	83 c4 08	 add	 esp, 8

; 325  : 			return DMUS_E_CANNOTSEEK;

  00171	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00176	e9 a4 00 00 00	 jmp	 $L69579
$L69608:

; 326  : 		}
; 327  : 
; 328  : 		ULONG cbWritten;
; 329  : 
; 330  : 		hr = m_pStream->Write(&lpck->cksize, sizeof(DWORD), &cbWritten); 

  0017b	8d 4d e0	 lea	 ecx, DWORD PTR _cbWritten$69610[ebp]
  0017e	51		 push	 ecx
  0017f	6a 04		 push	 4
  00181	8b 55 0c	 mov	 edx, DWORD PTR _lpck$[ebp]
  00184	83 c2 04	 add	 edx, 4
  00187	52		 push	 edx
  00188	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0018b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0018e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00191	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00194	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00196	50		 push	 eax
  00197	ff 51 10	 call	 DWORD PTR [ecx+16]
  0019a	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 331  : 		
; 332  : 		if(FAILED(hr) || cbWritten != sizeof(DWORD))

  0019d	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001a1	7c 06		 jl	 SHORT $L69615
  001a3	83 7d e0 04	 cmp	 DWORD PTR _cbWritten$69610[ebp], 4
  001a7	74 16		 je	 SHORT $L69584
$L69615:

; 333  : 		{
; 334  :             Trace(1,"Error: Unable to write file.\n");

  001a9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@MLHIBBFG@Error?3?5Unable?5to?5write?5file?4?6?$AA@
  001ae	6a 01		 push	 1
  001b0	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001b5	83 c4 08	 add	 esp, 8

; 335  : 			return DMUS_E_CANNOTWRITE;

  001b8	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  001bd	eb 60		 jmp	 SHORT $L69579
$L69584:

; 336  : 		}
; 337  :     }
; 338  : 
; 339  : 	// Seek to the end of the chunk, past the null pad byte
; 340  : 	// (which is only there if chunk size is odd)
; 341  : 	li.QuadPart = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L);

  001bf	8b 55 0c	 mov	 edx, DWORD PTR _lpck$[ebp]
  001c2	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  001c5	8b 4d 0c	 mov	 ecx, DWORD PTR _lpck$[ebp]
  001c8	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  001cb	8b 55 0c	 mov	 edx, DWORD PTR _lpck$[ebp]
  001ce	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001d1	83 e1 01	 and	 ecx, 1
  001d4	03 c1		 add	 eax, ecx
  001d6	33 d2		 xor	 edx, edx
  001d8	89 45 f0	 mov	 DWORD PTR _li$[ebp], eax
  001db	89 55 f4	 mov	 DWORD PTR _li$[ebp+4], edx

; 342  : 	hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

  001de	8d 45 f8	 lea	 eax, DWORD PTR _uli$[ebp]
  001e1	50		 push	 eax
  001e2	6a 00		 push	 0
  001e4	8b 4d f4	 mov	 ecx, DWORD PTR _li$[ebp+4]
  001e7	51		 push	 ecx
  001e8	8b 55 f0	 mov	 edx, DWORD PTR _li$[ebp]
  001eb	52		 push	 edx
  001ec	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001ef	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001f2	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001f5	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001f8	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001fa	50		 push	 eax
  001fb	ff 51 14	 call	 DWORD PTR [ecx+20]
  001fe	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 343  : 
; 344  : 	if(FAILED(hr))

  00201	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00205	7d 16		 jge	 SHORT $L69618

; 345  : 	{
; 346  :         Trace(1,"Error: Unable to write file.\n");

  00207	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@MLHIBBFG@Error?3?5Unable?5to?5write?5file?4?6?$AA@
  0020c	6a 01		 push	 1
  0020e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00213	83 c4 08	 add	 esp, 8

; 347  : 		return DMUS_E_CANNOTSEEK;

  00216	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0021b	eb 02		 jmp	 SHORT $L69579
$L69618:

; 348  : 	}
; 349  : 
; 350  : 	return S_OK;

  0021d	33 c0		 xor	 eax, eax
$L69579:

; 351  : }

  0021f	8b e5		 mov	 esp, ebp
  00221	5d		 pop	 ebp
  00222	c2 0c 00	 ret	 12			; 0000000cH
?Ascend@CDirectMusicStream@@UAGJPAU_MMCKINFO@@I@Z ENDP	; CDirectMusicStream::Ascend
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?CreateChunk@CDirectMusicStream@@UAGJPAU_MMCKINFO@@I@Z
_TEXT	SEGMENT
_li$ = -32
_uli$ = -24
_hr$ = -16
_cbWritten$ = -12
_lOffset$ = -8
_iBytes$ = -4
_this$ = 8
_lpck$ = 12
_wFlags$ = 16
?CreateChunk@CDirectMusicStream@@UAGJPAU_MMCKINFO@@I@Z PROC NEAR ; CDirectMusicStream::CreateChunk, COMDAT

; 357  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 358  : 	assert(lpck);

  00006	83 7d 0c 00	 cmp	 DWORD PTR _lpck$[ebp], 0
  0000a	75 14		 jne	 SHORT $L70606
  0000c	68 66 01 00 00	 push	 358			; 00000166H
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04MCLIPFCH@lpck?$AA@
  0001b	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70606:

; 359  : 
; 360  :     UINT iBytes;    // Bytes to write
; 361  :     LONG lOffset;   // Current offset in file
; 362  : 
; 363  : 	// Store the offset of the data part of the chunk
; 364  : 	LARGE_INTEGER li;
; 365  : 	ULARGE_INTEGER uli;
; 366  : 
; 367  : 	li.QuadPart = 0;

  00020	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _li$[ebp], 0
  00027	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _li$[ebp+4], 0

; 368  : 	HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

  0002e	8d 4d e8	 lea	 ecx, DWORD PTR _uli$[ebp]
  00031	51		 push	 ecx
  00032	6a 01		 push	 1
  00034	8b 55 e4	 mov	 edx, DWORD PTR _li$[ebp+4]
  00037	52		 push	 edx
  00038	8b 45 e0	 mov	 eax, DWORD PTR _li$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00042	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00048	8b 12		 mov	 edx, DWORD PTR [edx]
  0004a	51		 push	 ecx
  0004b	ff 52 14	 call	 DWORD PTR [edx+20]
  0004e	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 369  : 
; 370  : 	if(FAILED(hr))

  00051	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00055	7d 19		 jge	 SHORT $L69633

; 371  : 	{
; 372  :         Trace(1,"Error: Unable to write file.\n");

  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@MLHIBBFG@Error?3?5Unable?5to?5write?5file?4?6?$AA@
  0005c	6a 01		 push	 1
  0005e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00063	83 c4 08	 add	 esp, 8

; 373  : 		return DMUS_E_CANNOTSEEK;

  00066	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0006b	e9 a2 00 00 00	 jmp	 $L69625
$L69633:

; 374  : 	}
; 375  :     else
; 376  : 	{
; 377  : 		lOffset = uli.LowPart;

  00070	8b 45 e8	 mov	 eax, DWORD PTR _uli$[ebp]
  00073	89 45 f8	 mov	 DWORD PTR _lOffset$[ebp], eax

; 378  : 	}
; 379  :     
; 380  :     lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

  00076	8b 4d f8	 mov	 ecx, DWORD PTR _lOffset$[ebp]
  00079	83 c1 08	 add	 ecx, 8
  0007c	8b 55 0c	 mov	 edx, DWORD PTR _lpck$[ebp]
  0007f	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 381  : 
; 382  :     // figure out if a form/list type needs to be written
; 383  :     if(wFlags & MMIO_CREATERIFF)

  00082	8b 45 10	 mov	 eax, DWORD PTR _wFlags$[ebp]
  00085	83 e0 20	 and	 eax, 32			; 00000020H
  00088	85 c0		 test	 eax, eax
  0008a	74 12		 je	 SHORT $L69637

; 384  : 	{
; 385  : 		lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);

  0008c	8b 4d 0c	 mov	 ecx, DWORD PTR _lpck$[ebp]
  0008f	c7 01 52 49 46
	46		 mov	 DWORD PTR [ecx], 1179011410 ; 46464952H
  00095	c7 45 fc 0c 00
	00 00		 mov	 DWORD PTR _iBytes$[ebp], 12 ; 0000000cH

; 386  :     }
; 387  : 	else if(wFlags & MMIO_CREATELIST)

  0009c	eb 23		 jmp	 SHORT $L69647
$L69637:
  0009e	8b 55 10	 mov	 edx, DWORD PTR _wFlags$[ebp]
  000a1	83 e2 40	 and	 edx, 64			; 00000040H
  000a4	85 d2		 test	 edx, edx
  000a6	74 12		 je	 SHORT $L69648

; 388  : 	{
; 389  : 		lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);

  000a8	8b 45 0c	 mov	 eax, DWORD PTR _lpck$[ebp]
  000ab	c7 00 4c 49 53
	54		 mov	 DWORD PTR [eax], 1414744396 ; 5453494cH
  000b1	c7 45 fc 0c 00
	00 00		 mov	 DWORD PTR _iBytes$[ebp], 12 ; 0000000cH

; 390  : 	}
; 391  :     else

  000b8	eb 07		 jmp	 SHORT $L69647
$L69648:

; 392  :     {
; 393  : 		iBytes = 2 * sizeof(DWORD);

  000ba	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR _iBytes$[ebp], 8
$L69647:

; 394  : 	}
; 395  : 
; 396  :     // Write the chunk header
; 397  : 	ULONG cbWritten;
; 398  : 
; 399  : 	hr = m_pStream->Write(lpck, iBytes, &cbWritten); 

  000c1	8d 4d f4	 lea	 ecx, DWORD PTR _cbWritten$[ebp]
  000c4	51		 push	 ecx
  000c5	8b 55 fc	 mov	 edx, DWORD PTR _iBytes$[ebp]
  000c8	52		 push	 edx
  000c9	8b 45 0c	 mov	 eax, DWORD PTR _lpck$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000d9	8b 12		 mov	 edx, DWORD PTR [edx]
  000db	51		 push	 ecx
  000dc	ff 52 10	 call	 DWORD PTR [edx+16]
  000df	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 400  : 		
; 401  : 	if(FAILED(hr) || cbWritten != iBytes)

  000e2	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000e6	7c 08		 jl	 SHORT $L69663
  000e8	8b 45 f4	 mov	 eax, DWORD PTR _cbWritten$[ebp]
  000eb	3b 45 fc	 cmp	 eax, DWORD PTR _iBytes$[ebp]
  000ee	74 16		 je	 SHORT $L69662
$L69663:

; 402  : 	{
; 403  :         Trace(1,"Error: Unable to write file.\n");

  000f0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@MLHIBBFG@Error?3?5Unable?5to?5write?5file?4?6?$AA@
  000f5	6a 01		 push	 1
  000f7	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000fc	83 c4 08	 add	 esp, 8

; 404  : 		return DMUS_E_CANNOTWRITE;

  000ff	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00104	eb 0c		 jmp	 SHORT $L69625
$L69662:

; 405  : 	}
; 406  : 
; 407  : 	lpck->dwFlags = MMIO_DIRTY;

  00106	8b 4d 0c	 mov	 ecx, DWORD PTR _lpck$[ebp]
  00109	c7 41 10 00 00
	00 10		 mov	 DWORD PTR [ecx+16], 268435456 ; 10000000H

; 408  : 
; 409  :     return S_OK;

  00110	33 c0		 xor	 eax, eax
$L69625:

; 410  : }

  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c2 0c 00	 ret	 12			; 0000000cH
?CreateChunk@CDirectMusicStream@@UAGJPAU_MMCKINFO@@I@Z ENDP ; CDirectMusicStream::CreateChunk
_TEXT	ENDS
PUBLIC	??_C@_07KCKPANJI@pStream?$AA@			; `string'
PUBLIC	??0CRiffParser@@QAE@PAUIStream@@@Z		; CRiffParser::CRiffParser
;	COMDAT ??_C@_07KCKPANJI@pStream?$AA@
CONST	SEGMENT
??_C@_07KCKPANJI@pStream?$AA@ DB 'pStream', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CRiffParser@@QAE@PAUIStream@@@Z
_TEXT	SEGMENT
_this$ = -4
_pStream$ = 8
??0CRiffParser@@QAE@PAUIStream@@@Z PROC NEAR		; CRiffParser::CRiffParser, COMDAT
; _this$ = ecx

; 414  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 415  :     assert(pStream);

  00007	83 7d 08 00	 cmp	 DWORD PTR _pStream$[ebp], 0
  0000b	75 14		 jne	 SHORT $L70610
  0000d	68 9f 01 00 00	 push	 415			; 0000019fH
  00012	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07KCKPANJI@pStream?$AA@
  0001c	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70610:

; 416  :     m_fDebugOn = FALSE;

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 417  :     m_pStream = pStream; 

  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 45 08	 mov	 eax, DWORD PTR _pStream$[ebp]
  00030	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 418  :     m_pParent = NULL;

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 419  :     m_pChunk = NULL;

  0003d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00040	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 420  :     m_lRead = 0;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 421  :     m_fFirstPass = TRUE;

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1

; 422  :     m_fComponentFailed = FALSE;

  0005b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 423  :     m_fInComponent = FALSE;

  00065	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00068	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 424  : }

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??0CRiffParser@@QAE@PAUIStream@@@Z ENDP			; CRiffParser::CRiffParser
_TEXT	ENDS
PUBLIC	??_C@_06DGNELAAM@pChunk?$AA@			; `string'
PUBLIC	?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z	; CRiffParser::EnterList
;	COMDAT ??_C@_06DGNELAAM@pChunk?$AA@
CONST	SEGMENT
??_C@_06DGNELAAM@pChunk?$AA@ DB 'pChunk', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z
_TEXT	SEGMENT
_this$ = -4
_pChunk$ = 8
?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z PROC NEAR	; CRiffParser::EnterList, COMDAT
; _this$ = ecx

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 429  :     assert (pChunk);

  00007	83 7d 08 00	 cmp	 DWORD PTR _pChunk$[ebp], 0
  0000b	75 14		 jne	 SHORT $L70614
  0000d	68 ad 01 00 00	 push	 429			; 000001adH
  00012	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06DGNELAAM@pChunk?$AA@
  0001c	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70614:

; 430  :     pChunk->lRead = 0;

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _pChunk$[ebp]
  00024	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 431  :     pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)

  0002b	8b 55 08	 mov	 edx, DWORD PTR _pChunk$[ebp]
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00034	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 432  :     m_pParent = m_pChunk;

  00037	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00040	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 433  :     m_pChunk = pChunk;

  00043	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00046	8b 45 08	 mov	 eax, DWORD PTR _pChunk$[ebp]
  00049	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 434  :     m_fFirstPass = TRUE;

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1

; 435  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ENDP		; CRiffParser::EnterList
_TEXT	ENDS
PUBLIC	??_C@_08GMJLPMEF@m_pChunk?$AA@			; `string'
PUBLIC	?LeaveList@CRiffParser@@QAEXXZ			; CRiffParser::LeaveList
;	COMDAT ??_C@_08GMJLPMEF@m_pChunk?$AA@
CONST	SEGMENT
??_C@_08GMJLPMEF@m_pChunk?$AA@ DB 'm_pChunk', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?LeaveList@CRiffParser@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?LeaveList@CRiffParser@@QAEXXZ PROC NEAR		; CRiffParser::LeaveList, COMDAT
; _this$ = ecx

; 439  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 440  :     assert (m_pChunk);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0000e	75 14		 jne	 SHORT $L70618
  00010	68 b8 01 00 00	 push	 440			; 000001b8H
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GMJLPMEF@m_pChunk?$AA@
  0001f	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70618:

; 441  :     if (m_pChunk)

  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0002b	74 27		 je	 SHORT $L69680

; 442  :     {
; 443  :         m_pChunk = m_pChunk->pParent;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00039	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 444  :         if (m_pChunk)

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00043	74 0f		 je	 SHORT $L69680

; 445  :         {
; 446  :             m_pParent = m_pChunk->pParent;

  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00051	89 51 10	 mov	 DWORD PTR [ecx+16], edx
$L69680:

; 447  :         }
; 448  :     }
; 449  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?LeaveList@CRiffParser@@QAEXXZ ENDP			; CRiffParser::LeaveList
_TEXT	ENDS
PUBLIC	??_C@_0CD@JOHDMAJD@Error?5parsing?5?$CFs?0?5Read?5?$CFld?5of?5?$CFl@ ; `string'
PUBLIC	?NextChunk@CRiffParser@@QAEHPAJ@Z		; CRiffParser::NextChunk
PUBLIC	?MoreChunks@CRiffParser@@QAEHXZ			; CRiffParser::MoreChunks
PUBLIC	?EnterChunk@CRiffParser@@QAEJXZ			; CRiffParser::EnterChunk
PUBLIC	?LeaveChunk@CRiffParser@@QAEJXZ			; CRiffParser::LeaveChunk
EXTRN	_strncpy:NEAR
;	COMDAT ??_C@_0CD@JOHDMAJD@Error?5parsing?5?$CFs?0?5Read?5?$CFld?5of?5?$CFl@
CONST	SEGMENT
??_C@_0CD@JOHDMAJD@Error?5parsing?5?$CFs?0?5Read?5?$CFld?5of?5?$CFl@ DB 'E'
	DB	'rror parsing %s, Read %ld of %ld', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?NextChunk@CRiffParser@@QAEHPAJ@Z
_TEXT	SEGMENT
tv135 = -20
_this$ = -16
_szName$69697 = -12
_fMore$ = -4
_pHr$ = 8
?NextChunk@CRiffParser@@QAEHPAJ@Z PROC NEAR		; CRiffParser::NextChunk, COMDAT
; _this$ = ecx

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 454  :     BOOL fMore = FALSE;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fMore$[ebp], 0

; 455  :     if (SUCCEEDED(*pHr))

  00010	8b 45 08	 mov	 eax, DWORD PTR _pHr$[ebp]
  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	7c 4a		 jl	 SHORT $L69691

; 456  :     {
; 457  :         // If this is the first time we've entered this list, there is no previous chunk.
; 458  :         if (m_fFirstPass)

  00018	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0001f	74 0c		 je	 SHORT $L69692

; 459  :         {
; 460  :             // Clear the flag.
; 461  :             m_fFirstPass = FALSE;

  00021	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00024	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 462  :         }
; 463  :         else

  0002b	eb 0d		 jmp	 SHORT $L69693
$L69692:

; 464  :         {
; 465  :             // Clean up the previous pass.
; 466  :             *pHr = LeaveChunk();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?LeaveChunk@CRiffParser@@QAEJXZ ; CRiffParser::LeaveChunk
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _pHr$[ebp]
  00038	89 01		 mov	 DWORD PTR [ecx], eax
$L69693:

; 467  :         }
; 468  :         // Find out if there are more chunks to read.
; 469  :         fMore = MoreChunks();

  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?MoreChunks@CRiffParser@@QAEHXZ ; CRiffParser::MoreChunks
  00042	89 45 fc	 mov	 DWORD PTR _fMore$[ebp], eax

; 470  :         // If so, and we don't have any failure, go ahead and read the next chunk header.
; 471  :         if (fMore && SUCCEEDED(*pHr))

  00045	83 7d fc 00	 cmp	 DWORD PTR _fMore$[ebp], 0
  00049	74 15		 je	 SHORT $L69695
  0004b	8b 55 08	 mov	 edx, DWORD PTR _pHr$[ebp]
  0004e	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00051	7c 0d		 jl	 SHORT $L69695

; 472  :         {
; 473  :             *pHr = EnterChunk();

  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?EnterChunk@CRiffParser@@QAEJXZ ; CRiffParser::EnterChunk
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _pHr$[ebp]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax
$L69695:

; 474  :         }
; 475  :     }
; 476  :     else

  00060	eb 7e		 jmp	 SHORT $L69696
$L69691:

; 477  :     {
; 478  : #ifdef DBG
; 479  :         char szName[5];
; 480  :         if (m_fDebugOn)

  00062	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00065	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00068	74 4c		 je	 SHORT $L69698

; 481  :         {
; 482  :             szName[4] = 0;

  0006a	c6 45 f8 00	 mov	 BYTE PTR _szName$69697[ebp+4], 0

; 483  :             strncpy(szName,(char *)&m_pChunk->ckid,4);

  0006e	6a 04		 push	 4
  00070	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00076	51		 push	 ecx
  00077	8d 55 f4	 lea	 edx, DWORD PTR _szName$69697[ebp]
  0007a	52		 push	 edx
  0007b	e8 00 00 00 00	 call	 _strncpy
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH

; 484  :             Trace(-1,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));

  00083	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00086	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00089	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0008c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0008f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00092	83 e2 01	 and	 edx, 1
  00095	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00098	52		 push	 edx
  00099	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0009f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000a2	52		 push	 edx
  000a3	8d 45 f4	 lea	 eax, DWORD PTR _szName$69697[ebp]
  000a6	50		 push	 eax
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CD@JOHDMAJD@Error?5parsing?5?$CFs?0?5Read?5?$CFld?5of?5?$CFl@
  000ac	6a ff		 push	 -1
  000ae	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000b3	83 c4 14	 add	 esp, 20			; 00000014H
$L69698:

; 485  :         }
; 486  : #endif
; 487  :         // If we were in a component, it's okay to fail. Mark that fact by setting
; 488  :         // m_fComponentFailed then properly pull out of the chunk so we can
; 489  :         // continue reading.
; 490  :         if (m_fInComponent) 

  000b6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  000bd	74 19		 je	 SHORT $L69701

; 491  :         {
; 492  :             m_fComponentFailed = TRUE;

  000bf	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	c7 42 18 01 00
	00 00		 mov	 DWORD PTR [edx+24], 1

; 493  :             // We don't need to check for first pass, because we must have gotten
; 494  :             // that far. Instead, we just clean up from the failed chunk.
; 495  :             // Note that this sets the hresult to S_OK, which is what we want.
; 496  :             // Later, the caller needs to call ComponentFailed() to find out if
; 497  :             // this error occured.
; 498  :             *pHr = LeaveChunk();

  000c9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	e8 00 00 00 00	 call	 ?LeaveChunk@CRiffParser@@QAEJXZ ; CRiffParser::LeaveChunk
  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _pHr$[ebp]
  000d4	89 01		 mov	 DWORD PTR [ecx], eax

; 499  :         }
; 500  :         else

  000d6	eb 08		 jmp	 SHORT $L69696
$L69701:

; 501  :         {
; 502  :             // Clean up but leave the error code.
; 503  :             LeaveChunk();

  000d8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	e8 00 00 00 00	 call	 ?LeaveChunk@CRiffParser@@QAEJXZ ; CRiffParser::LeaveChunk
$L69696:

; 504  :         }
; 505  :     }
; 506  :     return fMore && SUCCEEDED(*pHr);

  000e0	83 7d fc 00	 cmp	 DWORD PTR _fMore$[ebp], 0
  000e4	74 11		 je	 SHORT $L70622
  000e6	8b 55 08	 mov	 edx, DWORD PTR _pHr$[ebp]
  000e9	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000ec	7c 09		 jl	 SHORT $L70622
  000ee	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv135[ebp], 1
  000f5	eb 07		 jmp	 SHORT $L70623
$L70622:
  000f7	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv135[ebp], 0
$L70623:
  000fe	8b 45 ec	 mov	 eax, DWORD PTR tv135[ebp]

; 507  : }

  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 04 00	 ret	 4
?NextChunk@CRiffParser@@QAEHPAJ@Z ENDP			; CRiffParser::NextChunk
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?MoreChunks@CRiffParser@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?MoreChunks@CRiffParser@@QAEHXZ PROC NEAR		; CRiffParser::MoreChunks, COMDAT
; _this$ = ecx

; 511  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 512  :     assert(m_pChunk);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0000e	75 14		 jne	 SHORT $L70627
  00010	68 00 02 00 00	 push	 512			; 00000200H
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GMJLPMEF@m_pChunk?$AA@
  0001f	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70627:

; 513  :     if (m_pChunk)

  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0002b	74 3a		 je	 SHORT $L69708

; 514  :     {
; 515  :         if (m_pParent)

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00034	74 1e		 je	 SHORT $L69709

; 516  :         {
; 517  :             // Return TRUE if there's enough room for another chunk.
; 518  :             return (m_pParent->lRead < (m_pParent->cksize - 8));

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00042	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00045	83 e8 08	 sub	 eax, 8
  00048	33 c9		 xor	 ecx, ecx
  0004a	39 42 0c	 cmp	 DWORD PTR [edx+12], eax
  0004d	0f 9c c1	 setl	 cl
  00050	8b c1		 mov	 eax, ecx
  00052	eb 15		 jmp	 SHORT $L69706
$L69709:

; 519  :         }
; 520  :         else
; 521  :         {
; 522  :             // This must be a top level chunk, in which case there would only be one to read.
; 523  :             return (m_pChunk->lRead == 0);

  00054	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00057	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0005a	33 c9		 xor	 ecx, ecx
  0005c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00060	0f 94 c1	 sete	 cl
  00063	8b c1		 mov	 eax, ecx
  00065	eb 02		 jmp	 SHORT $L69706
$L69708:

; 524  :         }
; 525  :     }
; 526  :     // This should never happen unless CRiffParser is used incorrectly, in which 
; 527  :     // case the assert will help debug. But, in the interest of making Prefix happy...
; 528  :     return false;

  00067	33 c0		 xor	 eax, eax
$L69706:

; 529  : }

  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?MoreChunks@CRiffParser@@QAEHXZ ENDP			; CRiffParser::MoreChunks
_TEXT	ENDS
PUBLIC	??_C@_0CO@JJGPIEEK@Entering?5?$CFs?0?5Length?5?$CFld?0?5File?5po@ ; `string'
PUBLIC	??_C@_08PDMNPFMK@?5Type?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
;	COMDAT ??_C@_0CO@JJGPIEEK@Entering?5?$CFs?0?5Length?5?$CFld?0?5File?5po@
CONST	SEGMENT
??_C@_0CO@JJGPIEEK@Entering?5?$CFs?0?5Length?5?$CFld?0?5File?5po@ DB 'Ent'
	DB	'ering %s, Length %ld, File position is %ld', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PDMNPFMK@?5Type?5?$CFs?$AA@
CONST	SEGMENT
??_C@_08PDMNPFMK@?5Type?5?$CFs?$AA@ DB ' Type %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?EnterChunk@CRiffParser@@QAEJXZ
_TEXT	SEGMENT
_this$ = -44
_li$69724 = -40
_hr$69725 = -28
_ul$69723 = -24
_szName$69720 = -12
_hr$69716 = -4
?EnterChunk@CRiffParser@@QAEJXZ PROC NEAR		; CRiffParser::EnterChunk, COMDAT
; _this$ = ecx

; 533  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 534  :     assert(m_pChunk);

  00009	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00010	75 14		 jne	 SHORT $L70631
  00012	68 16 02 00 00	 push	 534			; 00000216H
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GMJLPMEF@m_pChunk?$AA@
  00021	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70631:

; 535  :     if (m_pChunk)

  00026	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00029	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0002d	0f 84 53 01 00
	00		 je	 $L69715

; 536  :     {
; 537  :         // Read the chunk header
; 538  : 	    HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);

  00033	6a 00		 push	 0
  00035	6a 08		 push	 8
  00037	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0003d	51		 push	 ecx
  0003e	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00044	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
  0004c	52		 push	 edx
  0004d	ff 50 0c	 call	 DWORD PTR [eax+12]
  00050	89 45 fc	 mov	 DWORD PTR _hr$69716[ebp], eax

; 539  :         if (SUCCEEDED(hr))

  00053	83 7d fc 00	 cmp	 DWORD PTR _hr$69716[ebp], 0
  00057	0f 8c 24 01 00
	00		 jl	 $L69719

; 540  :         {
; 541  : #ifdef DBG
; 542  :             char szName[5];
; 543  :             if (m_fDebugOn)

  0005d	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00063	74 6b		 je	 SHORT $L69721

; 544  :             {
; 545  :                 szName[4] = 0;

  00065	c6 45 f8 00	 mov	 BYTE PTR _szName$69720[ebp+4], 0

; 546  :                 strncpy(szName,(char *)&m_pChunk->ckid,4);

  00069	6a 04		 push	 4
  0006b	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  0006e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00071	50		 push	 eax
  00072	8d 4d f4	 lea	 ecx, DWORD PTR _szName$69720[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 _strncpy
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 547  :                 ULARGE_INTEGER ul;
; 548  :                 LARGE_INTEGER li;
; 549  :                 li.QuadPart = 0;

  0007e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _li$69724[ebp], 0
  00085	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _li$69724[ebp+4], 0

; 550  :                 HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

  0008c	8d 55 e8	 lea	 edx, DWORD PTR _ul$69723[ebp]
  0008f	52		 push	 edx
  00090	6a 01		 push	 1
  00092	8b 45 dc	 mov	 eax, DWORD PTR _li$69724[ebp+4]
  00095	50		 push	 eax
  00096	8b 4d d8	 mov	 ecx, DWORD PTR _li$69724[ebp]
  00099	51		 push	 ecx
  0009a	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  0009d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000a0	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000a6	8b 00		 mov	 eax, DWORD PTR [eax]
  000a8	52		 push	 edx
  000a9	ff 50 14	 call	 DWORD PTR [eax+20]
  000ac	89 45 e4	 mov	 DWORD PTR _hr$69725[ebp], eax

; 551  : 
; 552  :                 Trace(-1,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);

  000af	8b 4d e8	 mov	 ecx, DWORD PTR _ul$69723[ebp]
  000b2	51		 push	 ecx
  000b3	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  000b6	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000b9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000bc	51		 push	 ecx
  000bd	8d 55 f4	 lea	 edx, DWORD PTR _szName$69720[ebp]
  000c0	52		 push	 edx
  000c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CO@JJGPIEEK@Entering?5?$CFs?0?5Length?5?$CFld?0?5File?5po@
  000c6	6a ff		 push	 -1
  000c8	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000cd	83 c4 14	 add	 esp, 20			; 00000014H
$L69721:

; 553  :             }
; 554  : #endif
; 555  :             // Clear bytes read field.
; 556  :             m_pChunk->lRead = 0;

  000d0	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000d6	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 557  :             // Check to see if this is a container (LIST or RIFF.)
; 558  :             if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))

  000dd	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  000e0	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000e3	81 38 52 49 46
	46		 cmp	 DWORD PTR [eax], 1179011410 ; 46464952H
  000e9	74 0e		 je	 SHORT $L69745
  000eb	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000f1	81 3a 4c 49 53
	54		 cmp	 DWORD PTR [edx], 1414744396 ; 5453494cH
  000f7	75 71		 jne	 SHORT $L69744
$L69745:

; 559  : 		    {
; 560  : 			    hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);

  000f9	6a 00		 push	 0
  000fb	6a 04		 push	 4
  000fd	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00100	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00103	83 c1 08	 add	 ecx, 8
  00106	51		 push	 ecx
  00107	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  0010a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0010d	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00110	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00113	8b 00		 mov	 eax, DWORD PTR [eax]
  00115	52		 push	 edx
  00116	ff 50 0c	 call	 DWORD PTR [eax+12]
  00119	89 45 fc	 mov	 DWORD PTR _hr$69716[ebp], eax

; 561  :                 if (SUCCEEDED(hr))

  0011c	83 7d fc 00	 cmp	 DWORD PTR _hr$69716[ebp], 0
  00120	7c 48		 jl	 SHORT $L69744

; 562  :                 {
; 563  :                     m_pChunk->lRead += sizeof(DWORD);

  00122	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00125	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00128	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0012b	83 c0 04	 add	 eax, 4
  0012e	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00134	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 564  : #ifdef DBG
; 565  :                     if (m_fDebugOn)

  00137	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0013a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0013d	74 2b		 je	 SHORT $L69744

; 566  :                     {
; 567  :                         strncpy(szName,(char *)&m_pChunk->fccType,4);

  0013f	6a 04		 push	 4
  00141	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00147	83 c2 08	 add	 edx, 8
  0014a	52		 push	 edx
  0014b	8d 45 f4	 lea	 eax, DWORD PTR _szName$69720[ebp]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 _strncpy
  00154	83 c4 0c	 add	 esp, 12			; 0000000cH

; 568  :                         Trace(-1," Type %s",szName);

  00157	8d 4d f4	 lea	 ecx, DWORD PTR _szName$69720[ebp]
  0015a	51		 push	 ecx
  0015b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08PDMNPFMK@?5Type?5?$CFs?$AA@
  00160	6a ff		 push	 -1
  00162	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00167	83 c4 0c	 add	 esp, 12			; 0000000cH
$L69744:

; 569  :                     }
; 570  : #endif
; 571  :                 }
; 572  : 		    }
; 573  : #ifdef DBG
; 574  :             if (m_fDebugOn) Trace(-1,"\n");

  0016a	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  0016d	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00170	74 0f		 je	 SHORT $L69719
  00172	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00177	6a ff		 push	 -1
  00179	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0017e	83 c4 08	 add	 esp, 8
$L69719:

; 575  : #endif
; 576  :         }
; 577  :         return hr;

  00181	8b 45 fc	 mov	 eax, DWORD PTR _hr$69716[ebp]
  00184	eb 05		 jmp	 SHORT $L69713
$L69715:

; 578  :     }
; 579  :     // This should never happen unless CRiffParser is used incorrectly, in which 
; 580  :     // case the assert will help debug. But, in the interest of making Prefix happy...
; 581  :     return E_FAIL;

  00186	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$L69713:

; 582  : }

  0018b	8b e5		 mov	 esp, ebp
  0018d	5d		 pop	 ebp
  0018e	c3		 ret	 0
?EnterChunk@CRiffParser@@QAEJXZ ENDP			; CRiffParser::EnterChunk
_TEXT	ENDS
PUBLIC	??_C@_0DD@FMCKFKME@Leaving?5?$CFs?0?5Read?5?$CFld?5of?5?$CFld?0?5Fil@ ; `string'
;	COMDAT ??_C@_0DD@FMCKFKME@Leaving?5?$CFs?0?5Read?5?$CFld?5of?5?$CFld?0?5Fil@
CONST	SEGMENT
??_C@_0DD@FMCKFKME@Leaving?5?$CFs?0?5Read?5?$CFld?5of?5?$CFld?0?5Fil@ DB 'L'
	DB	'eaving %s, Read %ld of %ld, File Position is %ld', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?LeaveChunk@CRiffParser@@QAEJXZ
_TEXT	SEGMENT
_this$ = -52
_li$69777 = -48
_li$69772 = -40
_hr$69773 = -28
_ul$69771 = -24
_lSize$69763 = -16
_szName$69768 = -12
_hr$ = -4
?LeaveChunk@CRiffParser@@QAEJXZ PROC NEAR		; CRiffParser::LeaveChunk, COMDAT
; _this$ = ecx

; 586  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 587  :     HRESULT hr = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 588  :     assert(m_pChunk);

  00010	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00017	75 14		 jne	 SHORT $L70635
  00019	68 4c 02 00 00	 push	 588			; 0000024cH
  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
  00023	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GMJLPMEF@m_pChunk?$AA@
  00028	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70635:

; 589  :     if (m_pChunk)

  0002d	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00030	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  00034	0f 84 6f 01 00
	00		 je	 $L69762

; 590  :     {
; 591  :         m_fInComponent = false;

  0003a	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 592  :         // Get the rounded up size of the chunk.
; 593  :         long lSize = RIFF_ALIGN(m_pChunk->cksize);

  00044	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0004a	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00050	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00053	83 e0 01	 and	 eax, 1
  00056	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00059	89 45 f0	 mov	 DWORD PTR _lSize$69763[ebp], eax

; 594  :         // Increment the parent's count of bytes read so far.
; 595  :         if (m_pParent)

  0005c	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00063	74 40		 je	 SHORT $L69764

; 596  :         {
; 597  :             m_pParent->lRead += lSize + (2 * sizeof(DWORD));

  00065	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00068	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0006b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006e	8b 55 f0	 mov	 edx, DWORD PTR _lSize$69763[ebp]
  00071	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  00075	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0007b	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 598  :             if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))

  0007e	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00084	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00087	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0008a	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0008d	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  00090	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00093	83 e2 01	 and	 edx, 1
  00096	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00099	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  0009c	7e 07		 jle	 SHORT $L69764

; 599  :             {
; 600  :                 hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.

  0009e	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L69764:

; 601  :             }
; 602  :         }
; 603  : #ifdef DBG
; 604  :         char szName[5];
; 605  :         if (m_fDebugOn)

  000a5	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	83 38 00	 cmp	 DWORD PTR [eax], 0
  000ab	74 6f		 je	 SHORT $L69769

; 606  :         {
; 607  :             szName[4] = 0;

  000ad	c6 45 f8 00	 mov	 BYTE PTR _szName$69768[ebp+4], 0

; 608  :             strncpy(szName,(char *)&m_pChunk->ckid,4);

  000b1	6a 04		 push	 4
  000b3	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000b9	52		 push	 edx
  000ba	8d 45 f4	 lea	 eax, DWORD PTR _szName$69768[ebp]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _strncpy
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 609  :             ULARGE_INTEGER ul;
; 610  :             LARGE_INTEGER li;
; 611  :             li.QuadPart = 0;

  000c6	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _li$69772[ebp], 0
  000cd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _li$69772[ebp+4], 0

; 612  :             HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

  000d4	8d 4d e8	 lea	 ecx, DWORD PTR _ul$69771[ebp]
  000d7	51		 push	 ecx
  000d8	6a 01		 push	 1
  000da	8b 55 dc	 mov	 edx, DWORD PTR _li$69772[ebp+4]
  000dd	52		 push	 edx
  000de	8b 45 d8	 mov	 eax, DWORD PTR _li$69772[ebp]
  000e1	50		 push	 eax
  000e2	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000e8	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ee	8b 12		 mov	 edx, DWORD PTR [edx]
  000f0	51		 push	 ecx
  000f1	ff 52 14	 call	 DWORD PTR [edx+20]
  000f4	89 45 e4	 mov	 DWORD PTR _hr$69773[ebp], eax

; 613  : 
; 614  :             Trace(-1,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);

  000f7	8b 45 e8	 mov	 eax, DWORD PTR _ul$69771[ebp]
  000fa	50		 push	 eax
  000fb	8b 4d f0	 mov	 ecx, DWORD PTR _lSize$69763[ebp]
  000fe	51		 push	 ecx
  000ff	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00102	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00105	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00108	51		 push	 ecx
  00109	8d 55 f4	 lea	 edx, DWORD PTR _szName$69768[ebp]
  0010c	52		 push	 edx
  0010d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@FMCKFKME@Leaving?5?$CFs?0?5Read?5?$CFld?5of?5?$CFld?0?5Fil@
  00112	6a ff		 push	 -1
  00114	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00119	83 c4 18	 add	 esp, 24			; 00000018H
$L69769:

; 615  :         }
; 616  : #endif
; 617  :         // If we haven't actually read this entire chunk, seek to the end of it.
; 618  :         if (m_pChunk->lRead < lSize)

  0011c	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  0011f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00122	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00125	3b 55 f0	 cmp	 edx, DWORD PTR _lSize$69763[ebp]
  00128	7d 7a		 jge	 SHORT $L69776

; 619  :         {
; 620  :             LARGE_INTEGER li;
; 621  :             li.QuadPart = lSize - m_pChunk->lRead;

  0012a	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  0012d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00130	8b 45 f0	 mov	 eax, DWORD PTR _lSize$69763[ebp]
  00133	2b 41 0c	 sub	 eax, DWORD PTR [ecx+12]
  00136	99		 cdq
  00137	89 45 d0	 mov	 DWORD PTR _li$69777[ebp], eax
  0013a	89 55 d4	 mov	 DWORD PTR _li$69777[ebp+4], edx

; 622  :             hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);

  0013d	6a 00		 push	 0
  0013f	6a 01		 push	 1
  00141	8b 55 d4	 mov	 edx, DWORD PTR _li$69777[ebp+4]
  00144	52		 push	 edx
  00145	8b 45 d0	 mov	 eax, DWORD PTR _li$69777[ebp]
  00148	50		 push	 eax
  00149	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0014f	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00152	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00155	8b 12		 mov	 edx, DWORD PTR [edx]
  00157	51		 push	 ecx
  00158	ff 52 14	 call	 DWORD PTR [edx+20]
  0015b	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 623  :             // There's a chance it could fail because we are at the end of file with an odd length chunk.
; 624  :             if (FAILED(hr))

  0015e	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00162	7d 40		 jge	 SHORT $L69776

; 625  :             {
; 626  :                 // If there's a parent, see if this is the last chunk.
; 627  :                 if (m_pParent)

  00164	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00167	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0016b	74 20		 je	 SHORT $L69780

; 628  :                 {
; 629  :                     if (m_pParent->cksize >= (m_pParent->lRead - 1))

  0016d	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00170	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00173	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00176	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00179	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0017c	83 e8 01	 sub	 eax, 1
  0017f	39 42 04	 cmp	 DWORD PTR [edx+4], eax
  00182	7c 07		 jl	 SHORT $L69781

; 630  :                     {
; 631  :                         hr = S_OK;

  00184	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0
$L69781:

; 632  :                     }
; 633  :                 }
; 634  :                 // Else, see if we are an odd length.
; 635  :                 else if (m_pChunk->cksize & 1)

  0018b	eb 17		 jmp	 SHORT $L69776
$L69780:
  0018d	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00190	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00193	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00196	83 e0 01	 and	 eax, 1
  00199	85 c0		 test	 eax, eax
  0019b	74 07		 je	 SHORT $L69776

; 636  :                 {
; 637  :                     hr = S_OK;

  0019d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0
$L69776:

; 638  :                 }
; 639  :             }
; 640  :         }
; 641  :         return hr;

  001a4	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  001a7	eb 05		 jmp	 SHORT $L69758
$L69762:

; 642  :     }
; 643  :     // This should never happen unless CRiffParser is used incorrectly, in which 
; 644  :     // case the assert will help debug. But, in the interest of making Prefix happy...
; 645  :     return E_FAIL;

  001a9	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$L69758:

; 646  : }

  001ae	8b e5		 mov	 esp, ebp
  001b0	5d		 pop	 ebp
  001b1	c3		 ret	 0
?LeaveChunk@CRiffParser@@QAEJXZ ENDP			; CRiffParser::LeaveChunk
_TEXT	ENDS
PUBLIC	?Read@CRiffParser@@QAEJPAXK@Z			; CRiffParser::Read
; Function compile flags: /Odt
;	COMDAT ?Read@CRiffParser@@QAEJPAXK@Z
_TEXT	SEGMENT
_this$ = -8
_hr$69796 = -4
_pv$ = 8
_cb$ = 12
?Read@CRiffParser@@QAEJPAXK@Z PROC NEAR			; CRiffParser::Read, COMDAT
; _this$ = ecx

; 650  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 651  :     assert(m_pChunk);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00010	75 14		 jne	 SHORT $L70639
  00012	68 8b 02 00 00	 push	 651			; 0000028bH
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GMJLPMEF@m_pChunk?$AA@
  00021	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70639:

; 652  :     if (m_pChunk)

  00026	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00029	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0002d	74 75		 je	 SHORT $L69793

; 653  :     {
; 654  :         // Make sure we don't read beyond the end of the chunk.
; 655  :         if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00035	8b 55 0c	 mov	 edx, DWORD PTR _cb$[ebp]
  00038	03 51 0c	 add	 edx, DWORD PTR [ecx+12]
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00041	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00044	7e 1f		 jle	 SHORT $L69795

; 656  :         {
; 657  :             cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));

  00046	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00049	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00052	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00055	2b 42 0c	 sub	 eax, DWORD PTR [edx+12]
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _cb$[ebp]
  0005b	2b c8		 sub	 ecx, eax
  0005d	8b 55 0c	 mov	 edx, DWORD PTR _cb$[ebp]
  00060	2b d1		 sub	 edx, ecx
  00062	89 55 0c	 mov	 DWORD PTR _cb$[ebp], edx
$L69795:

; 658  :         }
; 659  :         HRESULT hr = m_pStream->Read(pv,cb,NULL);

  00065	6a 00		 push	 0
  00067	8b 45 0c	 mov	 eax, DWORD PTR _cb$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _pv$[ebp]
  0006e	51		 push	 ecx
  0006f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00072	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00075	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	52		 push	 edx
  0007e	ff 50 0c	 call	 DWORD PTR [eax+12]
  00081	89 45 fc	 mov	 DWORD PTR _hr$69796[ebp], eax

; 660  :         if (SUCCEEDED(hr))

  00084	83 7d fc 00	 cmp	 DWORD PTR _hr$69796[ebp], 0
  00088	7c 15		 jl	 SHORT $L69798

; 661  :         {
; 662  :             m_pChunk->lRead += cb;

  0008a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00090	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00093	03 45 0c	 add	 eax, DWORD PTR _cb$[ebp]
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0009c	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$L69798:

; 663  :         }
; 664  :         return hr;

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _hr$69796[ebp]
  000a2	eb 05		 jmp	 SHORT $L69791
$L69793:

; 665  :     }
; 666  :     // This should never happen unless CRiffParser is used incorrectly, in which 
; 667  :     // case the assert will help debug. But, in the interest of making Prefix happy...
; 668  :     return E_FAIL;

  000a4	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$L69791:

; 669  : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 08 00	 ret	 8
?Read@CRiffParser@@QAEJPAXK@Z ENDP			; CRiffParser::Read
_TEXT	ENDS
PUBLIC	?Skip@CRiffParser@@QAEJK@Z			; CRiffParser::Skip
; Function compile flags: /Odt
;	COMDAT ?Skip@CRiffParser@@QAEJK@Z
_TEXT	SEGMENT
_this$ = -20
_li$69808 = -16
_hr$69809 = -4
_ulBytes$ = 8
?Skip@CRiffParser@@QAEJK@Z PROC NEAR			; CRiffParser::Skip, COMDAT
; _this$ = ecx

; 673  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 674  :     assert(m_pChunk);

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00010	75 14		 jne	 SHORT $L70643
  00012	68 a2 02 00 00	 push	 674			; 000002a2H
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GMJLPMEF@m_pChunk?$AA@
  00021	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70643:

; 675  :     if (m_pChunk)

  00026	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00029	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0002d	0f 84 84 00 00
	00		 je	 $L69805

; 676  :     {
; 677  :         // Make sure we don't scan beyond the end of the chunk.
; 678  :         if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)

  00033	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00039	8b 55 08	 mov	 edx, DWORD PTR _ulBytes$[ebp]
  0003c	03 51 0c	 add	 edx, DWORD PTR [ecx+12]
  0003f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00045	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00048	7e 1f		 jle	 SHORT $L69807

; 679  :         {
; 680  :             ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));

  0004a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0004d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00050	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00056	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00059	2b 42 0c	 sub	 eax, DWORD PTR [edx+12]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _ulBytes$[ebp]
  0005f	2b c8		 sub	 ecx, eax
  00061	8b 55 08	 mov	 edx, DWORD PTR _ulBytes$[ebp]
  00064	2b d1		 sub	 edx, ecx
  00066	89 55 08	 mov	 DWORD PTR _ulBytes$[ebp], edx
$L69807:

; 681  :         }
; 682  :         LARGE_INTEGER li;
; 683  :         li.HighPart = 0;

  00069	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _li$69808[ebp+4], 0

; 684  : 		li.LowPart = ulBytes;

  00070	8b 45 08	 mov	 eax, DWORD PTR _ulBytes$[ebp]
  00073	89 45 f0	 mov	 DWORD PTR _li$69808[ebp], eax

; 685  :         HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );

  00076	6a 00		 push	 0
  00078	6a 01		 push	 1
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR _li$69808[ebp+4]
  0007d	51		 push	 ecx
  0007e	8b 55 f0	 mov	 edx, DWORD PTR _li$69808[ebp]
  00081	52		 push	 edx
  00082	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00085	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00088	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0008b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00090	50		 push	 eax
  00091	ff 51 14	 call	 DWORD PTR [ecx+20]
  00094	89 45 fc	 mov	 DWORD PTR _hr$69809[ebp], eax

; 686  :         if (SUCCEEDED(hr))

  00097	83 7d fc 00	 cmp	 DWORD PTR _hr$69809[ebp], 0
  0009b	7c 15		 jl	 SHORT $L69811

; 687  :         {
; 688  :             m_pChunk->lRead += ulBytes;

  0009d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000a3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000a6	03 4d 08	 add	 ecx, DWORD PTR _ulBytes$[ebp]
  000a9	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000af	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$L69811:

; 689  :         }
; 690  :         return hr;

  000b2	8b 45 fc	 mov	 eax, DWORD PTR _hr$69809[ebp]
  000b5	eb 05		 jmp	 SHORT $L69803
$L69805:

; 691  :     }
; 692  :     // This should never happen unless CRiffParser is used incorrectly, in which 
; 693  :     // case the assert will help debug. But, in the interest of making Prefix happy...
; 694  :     return E_FAIL;

  000b7	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$L69803:

; 695  : }

  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 04 00	 ret	 4
?Skip@CRiffParser@@QAEJK@Z ENDP				; CRiffParser::Skip
_TEXT	ENDS
PUBLIC	?MarkPosition@CRiffParser@@QAEXXZ		; CRiffParser::MarkPosition
; Function compile flags: /Odt
;	COMDAT ?MarkPosition@CRiffParser@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20
_li$69818 = -16
_ul$69819 = -8
?MarkPosition@CRiffParser@@QAEXXZ PROC NEAR		; CRiffParser::MarkPosition, COMDAT
; _this$ = ecx

; 700  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :     assert(m_pChunk);

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00010	75 14		 jne	 SHORT $L70647
  00012	68 bd 02 00 00	 push	 701			; 000002bdH
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GMJLPMEF@m_pChunk?$AA@
  00021	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70647:

; 702  :     if (m_pChunk)

  00026	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00029	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0002d	74 40		 je	 SHORT $L69815

; 703  :     {
; 704  :         LARGE_INTEGER li;
; 705  :         ULARGE_INTEGER ul;
; 706  :         li.HighPart = 0;

  0002f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _li$69818[ebp+4], 0

; 707  :         li.LowPart = 0;

  00036	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _li$69818[ebp], 0

; 708  :         m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

  0003d	8d 45 f8	 lea	 eax, DWORD PTR _ul$69819[ebp]
  00040	50		 push	 eax
  00041	6a 01		 push	 1
  00043	8b 4d f4	 mov	 ecx, DWORD PTR _li$69818[ebp+4]
  00046	51		 push	 ecx
  00047	8b 55 f0	 mov	 edx, DWORD PTR _li$69818[ebp]
  0004a	52		 push	 edx
  0004b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00051	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00054	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00057	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00059	50		 push	 eax
  0005a	ff 51 14	 call	 DWORD PTR [ecx+20]

; 709  :         m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;

  0005d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00060	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _ul$69819[ebp]
  00066	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00069	8b 55 fc	 mov	 edx, DWORD PTR _ul$69819[ebp+4]
  0006c	89 50 1c	 mov	 DWORD PTR [eax+28], edx
$L69815:

; 710  :     }
; 711  : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?MarkPosition@CRiffParser@@QAEXXZ ENDP			; CRiffParser::MarkPosition
_TEXT	ENDS
PUBLIC	?SeekBack@CRiffParser@@QAEJXZ			; CRiffParser::SeekBack
; Function compile flags: /Odt
;	COMDAT ?SeekBack@CRiffParser@@QAEJXZ
_TEXT	SEGMENT
_this$ = -28
_li$69827 = -24
_hr$69829 = -12
_ul$69826 = -8
?SeekBack@CRiffParser@@QAEJXZ PROC NEAR			; CRiffParser::SeekBack, COMDAT
; _this$ = ecx

; 715  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 716  :     assert(m_pChunk);

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00010	75 14		 jne	 SHORT $L70651
  00012	68 cc 02 00 00	 push	 716			; 000002ccH
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GMJLPMEF@m_pChunk?$AA@
  00021	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70651:

; 717  :     if (m_pChunk)

  00026	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00029	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0002d	0f 84 95 00 00
	00		 je	 $L69825

; 718  :     {
; 719  :         // Move back to the start of the current chunk. Also, store the
; 720  :         // absolute position because that will be useful later when we need to seek to the
; 721  :         // end of this chunk.
; 722  :         ULARGE_INTEGER ul;
; 723  :         LARGE_INTEGER li;
; 724  :         li.QuadPart = 0;

  00033	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _li$69827[ebp], 0
  0003a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _li$69827[ebp+4], 0

; 725  :         li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 

  00041	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00047	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0004a	83 c2 08	 add	 edx, 8
  0004d	33 c0		 xor	 eax, eax
  0004f	8b 4d e8	 mov	 ecx, DWORD PTR _li$69827[ebp]
  00052	2b ca		 sub	 ecx, edx
  00054	8b 55 ec	 mov	 edx, DWORD PTR _li$69827[ebp+4]
  00057	1b d0		 sbb	 edx, eax
  00059	89 4d e8	 mov	 DWORD PTR _li$69827[ebp], ecx
  0005c	89 55 ec	 mov	 DWORD PTR _li$69827[ebp+4], edx

; 726  :         HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

  0005f	8d 45 f8	 lea	 eax, DWORD PTR _ul$69826[ebp]
  00062	50		 push	 eax
  00063	6a 01		 push	 1
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _li$69827[ebp+4]
  00068	51		 push	 ecx
  00069	8b 55 e8	 mov	 edx, DWORD PTR _li$69827[ebp]
  0006c	52		 push	 edx
  0006d	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00076	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00079	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007b	50		 push	 eax
  0007c	ff 51 14	 call	 DWORD PTR [ecx+20]
  0007f	89 45 f4	 mov	 DWORD PTR _hr$69829[ebp], eax

; 727  :         // Now, save the absolute position for the end of this chunk.
; 728  :         m_pChunk->liPosition.QuadPart = ul.QuadPart + 
; 729  :             RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));

  00082	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00085	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00088	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0008e	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00091	83 e1 01	 and	 ecx, 1
  00094	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00097	03 c1		 add	 eax, ecx
  00099	99		 cdq
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _ul$69826[ebp]
  0009d	03 c8		 add	 ecx, eax
  0009f	8b 45 fc	 mov	 eax, DWORD PTR _ul$69826[ebp+4]
  000a2	13 c2		 adc	 eax, edx
  000a4	83 c1 08	 add	 ecx, 8
  000a7	83 d0 00	 adc	 eax, 0
  000aa	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  000ad	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  000b0	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  000b3	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 730  :         m_pChunk->lRead = 0;

  000b6	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000bc	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 731  :         return hr;

  000c3	8b 45 f4	 mov	 eax, DWORD PTR _hr$69829[ebp]
  000c6	eb 05		 jmp	 SHORT $L69823
$L69825:

; 732  :     }
; 733  :     return E_FAIL;

  000c8	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$L69823:

; 734  : }

  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
?SeekBack@CRiffParser@@QAEJXZ ENDP			; CRiffParser::SeekBack
_TEXT	ENDS
PUBLIC	?SeekForward@CRiffParser@@QAEJXZ		; CRiffParser::SeekForward
; Function compile flags: /Odt
;	COMDAT ?SeekForward@CRiffParser@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4
?SeekForward@CRiffParser@@QAEJXZ PROC NEAR		; CRiffParser::SeekForward, COMDAT
; _this$ = ecx

; 738  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 739  :     assert(m_pChunk);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0000e	75 14		 jne	 SHORT $L70655
  00010	68 e3 02 00 00	 push	 739			; 000002e3H
  00015	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@GIBDFJEK@c?3?2xbox?2private?2windows?2directx?2@
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GMJLPMEF@m_pChunk?$AA@
  0001f	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70655:

; 740  :     if (m_pChunk)

  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0002b	74 44		 je	 SHORT $L69836

; 741  :     {
; 742  :         m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00039	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003c	83 e2 01	 and	 edx, 1
  0003f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00048	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 743  :         return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);

  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00055	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00058	51		 push	 ecx
  00059	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0005c	52		 push	 edx
  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00063	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00069	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0006b	50		 push	 eax
  0006c	ff 51 14	 call	 DWORD PTR [ecx+20]
  0006f	eb 05		 jmp	 SHORT $L69834
$L69836:

; 744  :     }
; 745  :     return E_FAIL;

  00071	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$L69834:

; 746  : }

  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?SeekForward@CRiffParser@@QAEJXZ ENDP			; CRiffParser::SeekForward
_TEXT	ENDS
PUBLIC	?GetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@ABU_GUID@@@Z ; CInfo::GetDescriptor
EXTRN	_memcpy:NEAR
EXTRN	_memset:NEAR
; Function compile flags: /Odt
;	COMDAT ?GetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@ABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -4
_pDesc$ = 8
_rguidClassID$ = 12
?GetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@ABU_GUID@@@Z PROC NEAR ; CInfo::GetDescriptor, COMDAT
; _this$ = ecx

; 750  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 751  :     memset( pDesc, 0, sizeof(DMUS_OBJECTDESC));

  00007	68 50 03 00 00	 push	 848			; 00000350H
  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR _pDesc$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _memset
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 752  :     pDesc->dwSize = sizeof(DMUS_OBJECTDESC);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  0001d	c7 01 50 03 00
	00		 mov	 DWORD PTR [ecx], 848	; 00000350H

; 753  :     pDesc->guidClass = rguidClassID;

  00023	8b 55 0c	 mov	 edx, DWORD PTR _rguidClassID$[ebp]
  00026	8b 45 08	 mov	 eax, DWORD PTR _pDesc$[ebp]
  00029	83 c0 18	 add	 eax, 24			; 00000018H
  0002c	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00033	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00036	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00039	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0003c	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  0003f	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 754  :     pDesc->guidObject = m_guidObject;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	05 84 00 00 00	 add	 eax, 132		; 00000084H
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  0004d	83 c1 08	 add	 ecx, 8
  00050	8b 10		 mov	 edx, DWORD PTR [eax]
  00052	89 11		 mov	 DWORD PTR [ecx], edx
  00054	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00057	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0005a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0005d	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00060	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00063	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 755  :     pDesc->ftDate = m_ftDate;

  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  0006f	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  00078	89 51 28	 mov	 DWORD PTR [ecx+40], edx
  0007b	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 756  :     pDesc->vVersion = m_vVersion;

  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  00087	8b 8a a0 00 00
	00		 mov	 ecx, DWORD PTR [edx+160]
  0008d	8b 55 08	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00090	89 42 30	 mov	 DWORD PTR [edx+48], eax
  00093	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 757  :     memcpy( pDesc->wszName, m_wszName, sizeof(m_wszName) );

  00096	68 80 00 00 00	 push	 128			; 00000080H
  0009b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	83 c0 04	 add	 eax, 4
  000a1	50		 push	 eax
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  000a5	83 c1 38	 add	 ecx, 56			; 00000038H
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 _memcpy
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 758  :     memcpy( pDesc->wszCategory, m_wszCategory, sizeof(m_wszCategory) );

  000b1	68 80 00 00 00	 push	 128			; 00000080H
  000b6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b9	81 c2 a4 00 00
	00		 add	 edx, 164		; 000000a4H
  000bf	52		 push	 edx
  000c0	8b 45 08	 mov	 eax, DWORD PTR _pDesc$[ebp]
  000c3	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 _memcpy
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 759  :     memcpy( pDesc->wszFileName, m_wszFileName, sizeof(m_wszFileName) );

  000d1	68 08 02 00 00	 push	 520			; 00000208H
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	81 c1 24 01 00
	00		 add	 ecx, 292		; 00000124H
  000df	51		 push	 ecx
  000e0	8b 55 08	 mov	 edx, DWORD PTR _pDesc$[ebp]
  000e3	81 c2 38 01 00
	00		 add	 edx, 312		; 00000138H
  000e9	52		 push	 edx
  000ea	e8 00 00 00 00	 call	 _memcpy
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 760  :     pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );

  000f2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f7	83 c9 02	 or	 ecx, 2
  000fa	8b 55 08	 mov	 edx, DWORD PTR _pDesc$[ebp]
  000fd	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 761  :     return S_OK;

  00100	33 c0		 xor	 eax, eax

; 762  : }

  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c2 08 00	 ret	 8
?GetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@ABU_GUID@@@Z ENDP ; CInfo::GetDescriptor
_TEXT	ENDS
PUBLIC	?SetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@@Z ; CInfo::SetDescriptor
PUBLIC	??_C@_0FI@JANHFFNC@Warning?3?5SetDescriptor?5was?5not?5a@ ; `string'
PUBLIC	??_C@_0CP@IBANCKHO@Error?3?5Size?5of?5descriptor?5too?5la@ ; `string'
;	COMDAT ??_C@_0FI@JANHFFNC@Warning?3?5SetDescriptor?5was?5not?5a@
CONST	SEGMENT
??_C@_0FI@JANHFFNC@Warning?3?5SetDescriptor?5was?5not?5a@ DB 'Warning: Se'
	DB	'tDescriptor was not able to handle all passed fields, dwValid'
	DB	'Data bits %lx.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@IBANCKHO@Error?3?5Size?5of?5descriptor?5too?5la@
CONST	SEGMENT
??_C@_0CP@IBANCKHO@Error?3?5Size?5of?5descriptor?5too?5la@ DB 'Error: Siz'
	DB	'e of descriptor too large to parse.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT
_this$ = -12
_hr$ = -8
_dw$ = -4
_pDesc$ = 8
?SetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@@Z PROC NEAR ; CInfo::SetDescriptor, COMDAT
; _this$ = ecx

; 765  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 766  :     HRESULT hr = E_INVALIDARG;

  00009	c7 45 f8 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H

; 767  :     DWORD dw = 0;

  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 0

; 768  :     if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )

  00017	8b 45 08	 mov	 eax, DWORD PTR _pDesc$[ebp]
  0001a	81 38 50 03 00
	00		 cmp	 DWORD PTR [eax], 848	; 00000350H
  00020	0f 82 dc 01 00
	00		 jb	 $L69854

; 769  :     {
; 770  :         if(pDesc->dwValidData & DMUS_OBJ_CLASS)

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  00029	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002c	83 e2 02	 and	 edx, 2
  0002f	85 d2		 test	 edx, edx
  00031	74 09		 je	 SHORT $L69855

; 771  :         {
; 772  :             dw |= DMUS_OBJ_CLASS;

  00033	8b 45 fc	 mov	 eax, DWORD PTR _dw$[ebp]
  00036	83 c8 02	 or	 eax, 2
  00039	89 45 fc	 mov	 DWORD PTR _dw$[ebp], eax
$L69855:

; 773  :         }
; 774  :         if(pDesc->dwValidData & DMUS_OBJ_LOADED)

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  0003f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00042	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  00048	85 d2		 test	 edx, edx
  0004a	74 0b		 je	 SHORT $L69856

; 775  :         {
; 776  :             dw |= DMUS_OBJ_LOADED;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _dw$[ebp]
  0004f	0d 00 02 00 00	 or	 eax, 512		; 00000200H
  00054	89 45 fc	 mov	 DWORD PTR _dw$[ebp], eax
$L69856:

; 777  :         }
; 778  :         if( pDesc->dwValidData & DMUS_OBJ_OBJECT )

  00057	8b 4d 08	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  0005a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0005d	83 e2 01	 and	 edx, 1
  00060	85 d2		 test	 edx, edx
  00062	74 2e		 je	 SHORT $L69857

; 779  :         {
; 780  :             m_guidObject = pDesc->guidObject;

  00064	8b 45 08	 mov	 eax, DWORD PTR _pDesc$[ebp]
  00067	83 c0 08	 add	 eax, 8
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00073	8b 10		 mov	 edx, DWORD PTR [eax]
  00075	89 11		 mov	 DWORD PTR [ecx], edx
  00077	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0007a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0007d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00080	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00083	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00086	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 781  :             dw |= DMUS_OBJ_OBJECT;

  00089	8b 4d fc	 mov	 ecx, DWORD PTR _dw$[ebp]
  0008c	83 c9 01	 or	 ecx, 1
  0008f	89 4d fc	 mov	 DWORD PTR _dw$[ebp], ecx
$L69857:

; 782  :         }
; 783  :         if( pDesc->dwValidData & DMUS_OBJ_NAME )

  00092	8b 55 08	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00095	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00098	83 e0 04	 and	 eax, 4
  0009b	85 c0		 test	 eax, eax
  0009d	74 24		 je	 SHORT $L69858

; 784  :         {
; 785  :             memcpy( m_wszName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );

  0009f	68 80 00 00 00	 push	 128			; 00000080H
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  000a7	83 c1 38	 add	 ecx, 56			; 00000038H
  000aa	51		 push	 ecx
  000ab	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000ae	83 c2 04	 add	 edx, 4
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 _memcpy
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 786  :             dw |= DMUS_OBJ_NAME;

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _dw$[ebp]
  000bd	83 c8 04	 or	 eax, 4
  000c0	89 45 fc	 mov	 DWORD PTR _dw$[ebp], eax
$L69858:

; 787  :         }
; 788  :         if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )

  000c3	8b 4d 08	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  000c6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000c9	83 e2 08	 and	 edx, 8
  000cc	85 d2		 test	 edx, edx
  000ce	74 29		 je	 SHORT $L69860

; 789  :         {
; 790  :             memcpy( m_wszCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );

  000d0	68 80 00 00 00	 push	 128			; 00000080H
  000d5	8b 45 08	 mov	 eax, DWORD PTR _pDesc$[ebp]
  000d8	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  000dd	50		 push	 eax
  000de	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	81 c1 a4 00 00
	00		 add	 ecx, 164		; 000000a4H
  000e7	51		 push	 ecx
  000e8	e8 00 00 00 00	 call	 _memcpy
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 791  :             dw |= DMUS_OBJ_CATEGORY;

  000f0	8b 55 fc	 mov	 edx, DWORD PTR _dw$[ebp]
  000f3	83 ca 08	 or	 edx, 8
  000f6	89 55 fc	 mov	 DWORD PTR _dw$[ebp], edx
$L69860:

; 792  :         }
; 793  :         if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
; 794  :             ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )

  000f9	8b 45 08	 mov	 eax, DWORD PTR _pDesc$[ebp]
  000fc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ff	83 e1 10	 and	 ecx, 16			; 00000010H
  00102	85 c9		 test	 ecx, ecx
  00104	75 0d		 jne	 SHORT $L69863
  00106	8b 55 08	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00109	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0010c	83 e0 20	 and	 eax, 32			; 00000020H
  0010f	85 c0		 test	 eax, eax
  00111	74 32		 je	 SHORT $L69862
$L69863:

; 795  :         {
; 796  :             memcpy( m_wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );

  00113	68 08 02 00 00	 push	 520			; 00000208H
  00118	8b 4d 08	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  0011b	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
  00121	51		 push	 ecx
  00122	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00125	81 c2 24 01 00
	00		 add	 edx, 292		; 00000124H
  0012b	52		 push	 edx
  0012c	e8 00 00 00 00	 call	 _memcpy
  00131	83 c4 0c	 add	 esp, 12			; 0000000cH

; 797  :             dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));

  00134	8b 45 08	 mov	 eax, DWORD PTR _pDesc$[ebp]
  00137	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013a	83 e1 30	 and	 ecx, 48			; 00000030H
  0013d	8b 55 fc	 mov	 edx, DWORD PTR _dw$[ebp]
  00140	0b d1		 or	 edx, ecx
  00142	89 55 fc	 mov	 DWORD PTR _dw$[ebp], edx
$L69862:

; 798  :         }
; 799  :         if( pDesc->dwValidData & DMUS_OBJ_VERSION )

  00145	8b 45 08	 mov	 eax, DWORD PTR _pDesc$[ebp]
  00148	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0014b	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00151	85 c9		 test	 ecx, ecx
  00153	74 23		 je	 SHORT $L69865

; 800  :         {
; 801  :             m_vVersion = pDesc->vVersion;

  00155	8b 55 08	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00158	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0015b	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  0015e	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00161	89 82 9c 00 00
	00		 mov	 DWORD PTR [edx+156], eax
  00167	89 8a a0 00 00
	00		 mov	 DWORD PTR [edx+160], ecx

; 802  :             dw |= DMUS_OBJ_VERSION;

  0016d	8b 45 fc	 mov	 eax, DWORD PTR _dw$[ebp]
  00170	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00175	89 45 fc	 mov	 DWORD PTR _dw$[ebp], eax
$L69865:

; 803  :         }
; 804  :         if( pDesc->dwValidData & DMUS_OBJ_DATE )

  00178	8b 4d 08	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  0017b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0017e	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  00184	85 d2		 test	 edx, edx
  00186	74 24		 je	 SHORT $L69866

; 805  :         {
; 806  :             m_ftDate = pDesc->ftDate;

  00188	8b 45 08	 mov	 eax, DWORD PTR _pDesc$[ebp]
  0018b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0018e	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00191	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00194	89 88 94 00 00
	00		 mov	 DWORD PTR [eax+148], ecx
  0019a	89 90 98 00 00
	00		 mov	 DWORD PTR [eax+152], edx

; 807  :             dw |= DMUS_OBJ_DATE;

  001a0	8b 4d fc	 mov	 ecx, DWORD PTR _dw$[ebp]
  001a3	81 c9 00 01 00
	00		 or	 ecx, 256		; 00000100H
  001a9	89 4d fc	 mov	 DWORD PTR _dw$[ebp], ecx
$L69866:

; 808  :         }
; 809  :         m_dwValidData |= dw;

  001ac	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001af	8b 02		 mov	 eax, DWORD PTR [edx]
  001b1	0b 45 fc	 or	 eax, DWORD PTR _dw$[ebp]
  001b4	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001b7	89 01		 mov	 DWORD PTR [ecx], eax

; 810  :         if( pDesc->dwValidData & (~dw) )

  001b9	8b 55 fc	 mov	 edx, DWORD PTR _dw$[ebp]
  001bc	f7 d2		 not	 edx
  001be	8b 45 08	 mov	 eax, DWORD PTR _pDesc$[ebp]
  001c1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001c4	23 ca		 and	 ecx, edx
  001c6	85 c9		 test	 ecx, ecx
  001c8	74 2f		 je	 SHORT $L69867

; 811  :         {
; 812  :             Trace(2,"Warning: SetDescriptor was not able to handle all passed fields, dwValidData bits %lx.\n",pDesc->dwValidData & (~dw));

  001ca	8b 55 fc	 mov	 edx, DWORD PTR _dw$[ebp]
  001cd	f7 d2		 not	 edx
  001cf	8b 45 08	 mov	 eax, DWORD PTR _pDesc$[ebp]
  001d2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001d5	23 ca		 and	 ecx, edx
  001d7	51		 push	 ecx
  001d8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FI@JANHFFNC@Warning?3?5SetDescriptor?5was?5not?5a@
  001dd	6a 02		 push	 2
  001df	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  001e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 813  :             hr = S_FALSE; // there were extra fields we didn't parse;

  001e7	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 1

; 814  :             pDesc->dwValidData = dw;

  001ee	8b 55 08	 mov	 edx, DWORD PTR _pDesc$[ebp]
  001f1	8b 45 fc	 mov	 eax, DWORD PTR _dw$[ebp]
  001f4	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 815  :         }
; 816  :         else

  001f7	eb 07		 jmp	 SHORT $L69870
$L69867:

; 817  :         {
; 818  :             hr = S_OK;

  001f9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0
$L69870:

; 819  :         }
; 820  :     }
; 821  :     else

  00200	eb 0f		 jmp	 SHORT $L69872
$L69854:

; 822  :     {
; 823  :         Trace(1,"Error: Size of descriptor too large to parse.\n");

  00202	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@IBANCKHO@Error?3?5Size?5of?5descriptor?5too?5la@
  00207	6a 01		 push	 1
  00209	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0020e	83 c4 08	 add	 esp, 8
$L69872:

; 824  :     }
; 825  :     return hr;

  00211	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 826  : }

  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	c2 04 00	 ret	 4
?SetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@@Z ENDP	; CInfo::SetDescriptor
_TEXT	ENDS
PUBLIC	?ParseDescriptor@CInfo@@QAEJPAUIStream@@PAU_DMUS_OBJECTDESC@@KABU_GUID@@@Z ; CInfo::ParseDescriptor
PUBLIC	??_C@_0CL@BHLIFOCK@Error?3?5Parsing?5file?5?9?5invalid?5fi@ ; `string'
EXTRN	_MultiByteToWideChar@24:NEAR
;	COMDAT ??_C@_0CL@BHLIFOCK@Error?3?5Parsing?5file?5?9?5invalid?5fi@
CONST	SEGMENT
??_C@_0CL@BHLIFOCK@Error?3?5Parsing?5file?5?9?5invalid?5fi@ DB 'Error: Pa'
	DB	'rsing file - invalid file format', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ParseDescriptor@CInfo@@QAEJPAUIStream@@PAU_DMUS_OBJECTDESC@@KABU_GUID@@@Z
_TEXT	SEGMENT
tv138 = -220
tv81 = -216
_this$ = -212
_szName$69998 = -208
_hr$ = -140
_ckUNFO$ = -136
_Parser$ = -104
_ckNext$ = -72
_dwValidData$ = -36
_ckMain$ = -32
_pIStream$ = 8
_pDesc$ = 12
_dwRIFFID$ = 16
_guidClassID$ = 20
?ParseDescriptor@CInfo@@QAEJPAUIStream@@PAU_DMUS_OBJECTDESC@@KABU_GUID@@@Z PROC NEAR ; CInfo::ParseDescriptor, COMDAT
; _this$ = ecx

; 831  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     CRiffParser Parser(pIStream);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _pIStream$[ebp]
  00012	50		 push	 eax
  00013	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  00016	e8 00 00 00 00	 call	 ??0CRiffParser@@QAE@PAUIStream@@@Z ; CRiffParser::CRiffParser

; 833  :     RIFFIO ckMain;
; 834  :     RIFFIO ckNext;
; 835  :     RIFFIO ckUNFO;
; 836  :     HRESULT hr = S_OK;

  0001b	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _hr$[ebp], 0

; 837  :     DWORD dwValidData;
; 838  : 
; 839  :     Parser.EnterList(&ckMain);  

  00025	8d 4d e0	 lea	 ecx, DWORD PTR _ckMain$[ebp]
  00028	51		 push	 ecx
  00029	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0002c	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList

; 840  :     if (Parser.NextChunk(&hr) && (ckMain.fccType == dwRIFFID))

  00031	8d 95 74 ff ff
	ff		 lea	 edx, DWORD PTR _hr$[ebp]
  00037	52		 push	 edx
  00038	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0003b	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  00040	85 c0		 test	 eax, eax
  00042	0f 84 78 02 00
	00		 je	 $L69888
  00048	8b 45 e8	 mov	 eax, DWORD PTR _ckMain$[ebp+8]
  0004b	3b 45 10	 cmp	 eax, DWORD PTR _dwRIFFID$[ebp]
  0004e	0f 85 6c 02 00
	00		 jne	 $L69888

; 841  :     {
; 842  :         dwValidData = DMUS_OBJ_CLASS;

  00054	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _dwValidData$[ebp], 2

; 843  :         pDesc->guidClass = guidClassID;

  0005b	8b 4d 14	 mov	 ecx, DWORD PTR _guidClassID$[ebp]
  0005e	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00061	83 c2 18	 add	 edx, 24			; 00000018H
  00064	8b 01		 mov	 eax, DWORD PTR [ecx]
  00066	89 02		 mov	 DWORD PTR [edx], eax
  00068	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0006b	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0006e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00071	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00074	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00077	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 844  :         Parser.EnterList(&ckNext);

  0007a	8d 55 b8	 lea	 edx, DWORD PTR _ckNext$[ebp]
  0007d	52		 push	 edx
  0007e	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  00081	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L69890:

; 845  :         while(Parser.NextChunk(&hr))

  00086	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _hr$[ebp]
  0008c	50		 push	 eax
  0008d	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  00090	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  00095	85 c0		 test	 eax, eax
  00097	0f 84 19 02 00
	00		 je	 $L69891

; 846  :         {
; 847  :             switch(ckNext.ckid)
; 848  :             {

  0009d	8b 4d b8	 mov	 ecx, DWORD PTR _ckNext$[ebp]
  000a0	89 8d 28 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], ecx
  000a6	81 bd 28 ff ff
	ff 64 61 74 65	 cmp	 DWORD PTR tv81[ebp], 1702125924 ; 65746164H
  000b0	77 3d		 ja	 SHORT $L70665
  000b2	81 bd 28 ff ff
	ff 64 61 74 65	 cmp	 DWORD PTR tv81[ebp], 1702125924 ; 65746164H
  000bc	0f 84 c1 00 00
	00		 je	 $L69941
  000c2	81 bd 28 ff ff
	ff 4c 49 53 54	 cmp	 DWORD PTR tv81[ebp], 1414744396 ; 5453494cH
  000cc	0f 84 d8 00 00
	00		 je	 $L69951
  000d2	81 bd 28 ff ff
	ff 64 6c 69 64	 cmp	 DWORD PTR tv81[ebp], 1684630628 ; 64696c64H
  000dc	74 2e		 je	 SHORT $L69904
  000de	81 bd 28 ff ff
	ff 67 75 69 64	 cmp	 DWORD PTR tv81[ebp], 1684632935 ; 64697567H
  000e8	74 22		 je	 SHORT $L69904
  000ea	e9 c2 01 00 00	 jmp	 $L69893
$L70665:
  000ef	81 bd 28 ff ff
	ff 63 61 74 67	 cmp	 DWORD PTR tv81[ebp], 1735680355 ; 67746163H
  000f9	74 5e		 je	 SHORT $L69932
  000fb	81 bd 28 ff ff
	ff 76 65 72 73	 cmp	 DWORD PTR tv81[ebp], 1936876918 ; 73726576H
  00105	74 2a		 je	 SHORT $L69922
  00107	e9 a5 01 00 00	 jmp	 $L69893
$L69904:

; 849  :             case FOURCC_DLID:
; 850  :             case DMUS_FOURCC_GUID_CHUNK:
; 851  :                 hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );

  0010c	6a 10		 push	 16			; 00000010H
  0010e	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00111	83 c2 08	 add	 edx, 8
  00114	52		 push	 edx
  00115	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  00118	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  0011d	89 85 74 ff ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 852  :                 dwValidData |= DMUS_OBJ_OBJECT;

  00123	8b 45 dc	 mov	 eax, DWORD PTR _dwValidData$[ebp]
  00126	83 c8 01	 or	 eax, 1
  00129	89 45 dc	 mov	 DWORD PTR _dwValidData$[ebp], eax

; 853  :                 break;

  0012c	e9 80 01 00 00	 jmp	 $L69893
$L69922:

; 854  :             case FOURCC_VERS:
; 855  :                 hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );

  00131	6a 08		 push	 8
  00133	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  00136	83 c1 30	 add	 ecx, 48			; 00000030H
  00139	51		 push	 ecx
  0013a	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0013d	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00142	89 85 74 ff ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 856  :                 dwValidData |= DMUS_OBJ_VERSION;

  00148	8b 55 dc	 mov	 edx, DWORD PTR _dwValidData$[ebp]
  0014b	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  00151	89 55 dc	 mov	 DWORD PTR _dwValidData$[ebp], edx

; 857  :                 break;

  00154	e9 58 01 00 00	 jmp	 $L69893
$L69932:

; 858  :             case DMUS_FOURCC_CATEGORY_CHUNK:
; 859  :                 hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );

  00159	68 80 00 00 00	 push	 128			; 00000080H
  0015e	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  00161	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  00166	50		 push	 eax
  00167	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0016a	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  0016f	89 85 74 ff ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 860  :                 dwValidData |= DMUS_OBJ_CATEGORY;

  00175	8b 4d dc	 mov	 ecx, DWORD PTR _dwValidData$[ebp]
  00178	83 c9 08	 or	 ecx, 8
  0017b	89 4d dc	 mov	 DWORD PTR _dwValidData$[ebp], ecx

; 861  :                 break;

  0017e	e9 2e 01 00 00	 jmp	 $L69893
$L69941:

; 862  :             case DMUS_FOURCC_DATE_CHUNK:
; 863  :                 hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );

  00183	6a 08		 push	 8
  00185	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00188	83 c2 28	 add	 edx, 40			; 00000028H
  0018b	52		 push	 edx
  0018c	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0018f	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00194	89 85 74 ff ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 864  :                 dwValidData |= DMUS_OBJ_DATE;

  0019a	8b 45 dc	 mov	 eax, DWORD PTR _dwValidData$[ebp]
  0019d	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  001a2	89 45 dc	 mov	 DWORD PTR _dwValidData$[ebp], eax

; 865  :                 break;

  001a5	e9 07 01 00 00	 jmp	 $L69893
$L69951:

; 866  :             case FOURCC_LIST:
; 867  :                 switch(ckNext.fccType)
; 868  :                 {

  001aa	8b 4d c0	 mov	 ecx, DWORD PTR _ckNext$[ebp+8]
  001ad	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv138[ebp], ecx
  001b3	81 bd 24 ff ff
	ff 49 4e 46 4f	 cmp	 DWORD PTR tv138[ebp], 1330007625 ; 4f464e49H
  001bd	74 71		 je	 SHORT $L69985
  001bf	81 bd 24 ff ff
	ff 55 4e 46 4f	 cmp	 DWORD PTR tv138[ebp], 1330007637 ; 4f464e55H
  001c9	74 05		 je	 SHORT $L69964
  001cb	e9 e1 00 00 00	 jmp	 $L69893
$L69964:

; 869  :                 case DMUS_FOURCC_UNFO_LIST:
; 870  :                     Parser.EnterList(&ckUNFO);

  001d0	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _ckUNFO$[ebp]
  001d6	52		 push	 edx
  001d7	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  001da	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L69966:

; 871  :                     while (Parser.NextChunk(&hr))

  001df	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _hr$[ebp]
  001e5	50		 push	 eax
  001e6	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  001e9	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  001ee	85 c0		 test	 eax, eax
  001f0	74 31		 je	 SHORT $L69967

; 872  :                     {
; 873  :                         if (ckUNFO.ckid == DMUS_FOURCC_UNAM_CHUNK)

  001f2	81 bd 78 ff ff
	ff 55 4e 41 4d	 cmp	 DWORD PTR _ckUNFO$[ebp], 1296125525 ; 4d414e55H
  001fc	75 23		 jne	 SHORT $L69976

; 874  :                         {
; 875  :                             hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));

  001fe	68 80 00 00 00	 push	 128			; 00000080H
  00203	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  00206	83 c1 38	 add	 ecx, 56			; 00000038H
  00209	51		 push	 ecx
  0020a	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0020d	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00212	89 85 74 ff ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 876  :                             dwValidData |= DMUS_OBJ_NAME;

  00218	8b 55 dc	 mov	 edx, DWORD PTR _dwValidData$[ebp]
  0021b	83 ca 04	 or	 edx, 4
  0021e	89 55 dc	 mov	 DWORD PTR _dwValidData$[ebp], edx
$L69976:

; 877  :                         }
; 878  :                     }

  00221	eb bc		 jmp	 SHORT $L69966
$L69967:

; 879  :                     Parser.LeaveList();

  00223	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  00226	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList

; 880  :                     break;            

  0022b	e9 81 00 00 00	 jmp	 $L69893
$L69985:

; 881  :                     // Waves and DLS files have ascii info chunks...
; 882  :                 case DMUS_FOURCC_INFO_LIST:
; 883  :                     Parser.EnterList(&ckUNFO);

  00230	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _ckUNFO$[ebp]
  00236	50		 push	 eax
  00237	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0023a	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L69987:

; 884  :                     while (Parser.NextChunk(&hr))

  0023f	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _hr$[ebp]
  00245	51		 push	 ecx
  00246	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  00249	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  0024e	85 c0		 test	 eax, eax
  00250	74 57		 je	 SHORT $L69988

; 885  :                     {
; 886  :                         if ( ckUNFO.ckid == mmioFOURCC('I','N','A','M'))

  00252	81 bd 78 ff ff
	ff 49 4e 41 4d	 cmp	 DWORD PTR _ckUNFO$[ebp], 1296125513 ; 4d414e49H
  0025c	75 49		 jne	 SHORT $L69997

; 887  :                         {
; 888  : 			                char szName[DMUS_MAX_NAME];
; 889  : 			                hr = Parser.Read(szName, DMUS_MAX_NAME);

  0025e	6a 40		 push	 64			; 00000040H
  00260	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _szName$69998[ebp]
  00266	52		 push	 edx
  00267	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0026a	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  0026f	89 85 74 ff ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 890  : 			                if(SUCCEEDED(hr))

  00275	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  0027c	7c 27		 jl	 SHORT $L70000

; 891  : 			                {
; 892  : 				                MultiByteToWideChar(CP_ACP, 0, szName, -1, pDesc->wszName, sizeof(pDesc->wszName));

  0027e	68 80 00 00 00	 push	 128			; 00000080H
  00283	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  00286	83 c0 38	 add	 eax, 56			; 00000038H
  00289	50		 push	 eax
  0028a	6a ff		 push	 -1
  0028c	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _szName$69998[ebp]
  00292	51		 push	 ecx
  00293	6a 00		 push	 0
  00295	6a 00		 push	 0
  00297	e8 00 00 00 00	 call	 _MultiByteToWideChar@24

; 893  : 				                dwValidData |= DMUS_OBJ_NAME;

  0029c	8b 55 dc	 mov	 edx, DWORD PTR _dwValidData$[ebp]
  0029f	83 ca 04	 or	 edx, 4
  002a2	89 55 dc	 mov	 DWORD PTR _dwValidData$[ebp], edx
$L70000:

; 894  : 			                }
; 895  :                             break;

  002a5	eb 02		 jmp	 SHORT $L69988
$L69997:

; 896  :                         }
; 897  :                     }

  002a7	eb 96		 jmp	 SHORT $L69987
$L69988:

; 898  :                     Parser.LeaveList();

  002a9	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  002ac	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList
$L69893:

; 899  :                     break;
; 900  :                 }
; 901  :                 break;
; 902  :             }
; 903  :         }

  002b1	e9 d0 fd ff ff	 jmp	 $L69890
$L69891:

; 904  :         Parser.LeaveList();

  002b6	8d 4d 98	 lea	 ecx, DWORD PTR _Parser$[ebp]
  002b9	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList

; 905  :     }
; 906  :     else

  002be	eb 19		 jmp	 SHORT $L70001
$L69888:

; 907  :     {
; 908  :         Trace(1,"Error: Parsing file - invalid file format\n");

  002c0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CL@BHLIFOCK@Error?3?5Parsing?5file?5?9?5invalid?5fi@
  002c5	6a 01		 push	 1
  002c7	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  002cc	83 c4 08	 add	 esp, 8

; 909  :         hr = DMUS_E_CHUNKNOTFOUND;

  002cf	c7 85 74 ff ff
	ff 05 40 00 80	 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L70001:

; 910  :     }
; 911  : 
; 912  :     if (SUCCEEDED(hr))

  002d9	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  002e0	7c 09		 jl	 SHORT $L70005

; 913  :     {
; 914  :         pDesc->dwValidData = dwValidData;

  002e2	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  002e5	8b 4d dc	 mov	 ecx, DWORD PTR _dwValidData$[ebp]
  002e8	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$L70005:

; 915  :     }
; 916  :     return hr;

  002eb	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _hr$[ebp]

; 917  : }

  002f1	8b e5		 mov	 esp, ebp
  002f3	5d		 pop	 ebp
  002f4	c2 10 00	 ret	 16			; 00000010H
?ParseDescriptor@CInfo@@QAEJPAUIStream@@PAU_DMUS_OBJECTDESC@@KABU_GUID@@@Z ENDP ; CInfo::ParseDescriptor
_TEXT	ENDS
PUBLIC	?ReadChunk@CInfo@@QAEJPAVCRiffParser@@K@Z	; CInfo::ReadChunk
; Function compile flags: /Odt
;	COMDAT ?ReadChunk@CInfo@@QAEJPAVCRiffParser@@K@Z
_TEXT	SEGMENT
tv64 = -112
_this$ = -108
_szName$70108 = -104
_hr$ = -36
_ckChild$ = -32
_pParser$ = 8
_dwID$ = 12
?ReadChunk@CInfo@@QAEJPAVCRiffParser@@K@Z PROC NEAR	; CInfo::ReadChunk, COMDAT
; _this$ = ecx

; 921  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	89 4d 94	 mov	 DWORD PTR _this$[ebp], ecx

; 922  :     HRESULT hr = S_OK;

  00009	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 923  :     RIFFIO ckChild;
; 924  :     switch (dwID)
; 925  :     {

  00010	8b 45 0c	 mov	 eax, DWORD PTR _dwID$[ebp]
  00013	89 45 90	 mov	 DWORD PTR tv64[ebp], eax
  00016	81 7d 90 67 75
	69 64		 cmp	 DWORD PTR tv64[ebp], 1684632935 ; 64697567H
  0001d	77 31		 ja	 SHORT $L70669
  0001f	81 7d 90 67 75
	69 64		 cmp	 DWORD PTR tv64[ebp], 1684632935 ; 64697567H
  00026	74 4c		 je	 SHORT $L70026
  00028	81 7d 90 49 4e
	46 4f		 cmp	 DWORD PTR tv64[ebp], 1330007625 ; 4f464e49H
  0002f	0f 84 3f 01 00
	00		 je	 $L70095
  00035	81 7d 90 55 4e
	46 4f		 cmp	 DWORD PTR tv64[ebp], 1330007637 ; 4f464e55H
  0003c	0f 84 dd 00 00
	00		 je	 $L70074
  00042	81 7d 90 64 6c
	69 64		 cmp	 DWORD PTR tv64[ebp], 1684630628 ; 64696c64H
  00049	74 29		 je	 SHORT $L70026
  0004b	e9 91 01 00 00	 jmp	 $L70015
$L70669:
  00050	81 7d 90 64 61
	74 65		 cmp	 DWORD PTR tv64[ebp], 1702125924 ; 65746164H
  00057	0f 84 97 00 00
	00		 je	 $L70064
  0005d	81 7d 90 63 61
	74 67		 cmp	 DWORD PTR tv64[ebp], 1735680355 ; 67746163H
  00064	74 63		 je	 SHORT $L70054
  00066	81 7d 90 76 65
	72 73		 cmp	 DWORD PTR tv64[ebp], 1936876918 ; 73726576H
  0006d	74 2e		 je	 SHORT $L70044
  0006f	e9 6d 01 00 00	 jmp	 $L70015
$L70026:

; 926  :     case FOURCC_DLID:
; 927  :     case DMUS_FOURCC_GUID_CHUNK:
; 928  :         hr = pParser->Read( &m_guidObject, sizeof(GUID) );

  00074	6a 10		 push	 16			; 00000010H
  00076	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  0007f	51		 push	 ecx
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00083	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00088	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 929  :         m_dwValidData |= DMUS_OBJ_OBJECT;

  0008b	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  0008e	8b 02		 mov	 eax, DWORD PTR [edx]
  00090	83 c8 01	 or	 eax, 1
  00093	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	89 01		 mov	 DWORD PTR [ecx], eax

; 930  :         break;

  00098	e9 44 01 00 00	 jmp	 $L70015
$L70044:

; 931  :     case DMUS_FOURCC_VERSION_CHUNK:
; 932  :         hr = pParser->Read( &m_vVersion, sizeof(DMUS_VERSION) );

  0009d	6a 08		 push	 8
  0009f	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  000a2	81 c2 9c 00 00
	00		 add	 edx, 156		; 0000009cH
  000a8	52		 push	 edx
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  000ac	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  000b1	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 933  :         m_dwValidData |= DMUS_OBJ_VERSION;

  000b4	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  000bf	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	89 0a		 mov	 DWORD PTR [edx], ecx

; 934  :         break;

  000c4	e9 18 01 00 00	 jmp	 $L70015
$L70054:

; 935  :     case DMUS_FOURCC_CATEGORY_CHUNK:
; 936  :         hr = pParser->Read( &m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );

  000c9	68 80 00 00 00	 push	 128			; 00000080H
  000ce	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	05 a4 00 00 00	 add	 eax, 164		; 000000a4H
  000d6	50		 push	 eax
  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  000da	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  000df	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 937  :         m_dwValidData |= DMUS_OBJ_CATEGORY;

  000e2	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e7	83 ca 08	 or	 edx, 8
  000ea	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  000ed	89 10		 mov	 DWORD PTR [eax], edx

; 938  :         break;

  000ef	e9 ed 00 00 00	 jmp	 $L70015
$L70064:

; 939  :     case DMUS_FOURCC_DATE_CHUNK:
; 940  :         hr = pParser->Read( &m_ftDate, sizeof(FILETIME) );

  000f4	6a 08		 push	 8
  000f6	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  000ff	51		 push	 ecx
  00100	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00103	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00108	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 941  :         m_dwValidData |= DMUS_OBJ_DATE;

  0010b	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  0010e	8b 02		 mov	 eax, DWORD PTR [edx]
  00110	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  00115	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	89 01		 mov	 DWORD PTR [ecx], eax

; 942  :         break;

  0011a	e9 c2 00 00 00	 jmp	 $L70015
$L70074:

; 943  :     case DMUS_FOURCC_UNFO_LIST:
; 944  :         pParser->EnterList(&ckChild);

  0011f	8d 55 e0	 lea	 edx, DWORD PTR _ckChild$[ebp]
  00122	52		 push	 edx
  00123	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00126	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L70076:

; 945  :         while (pParser->NextChunk(&hr))

  0012b	8d 45 dc	 lea	 eax, DWORD PTR _hr$[ebp]
  0012e	50		 push	 eax
  0012f	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00132	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  00137	85 c0		 test	 eax, eax
  00139	74 2f		 je	 SHORT $L70077

; 946  :         {
; 947  :             if ( ckChild.ckid == DMUS_FOURCC_UNAM_CHUNK)

  0013b	81 7d e0 55 4e
	41 4d		 cmp	 DWORD PTR _ckChild$[ebp], 1296125525 ; 4d414e55H
  00142	75 24		 jne	 SHORT $L70086

; 948  :             {
; 949  :                 hr = pParser->Read(&m_wszName, sizeof(m_wszName));

  00144	68 80 00 00 00	 push	 128			; 00000080H
  00149	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	83 c1 04	 add	 ecx, 4
  0014f	51		 push	 ecx
  00150	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00153	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00158	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 950  :                 m_dwValidData |= DMUS_OBJ_NAME;

  0015b	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  0015e	8b 02		 mov	 eax, DWORD PTR [edx]
  00160	83 c8 04	 or	 eax, 4
  00163	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00166	89 01		 mov	 DWORD PTR [ecx], eax
$L70086:

; 951  :             }
; 952  :         }

  00168	eb c1		 jmp	 SHORT $L70076
$L70077:

; 953  :         pParser->LeaveList();

  0016a	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0016d	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList

; 954  :         break;

  00172	eb 6d		 jmp	 SHORT $L70015
$L70095:

; 955  :         // Waves and DLS files have ascii info chunks...
; 956  :     case DMUS_FOURCC_INFO_LIST:
; 957  :         pParser->EnterList(&ckChild);

  00174	8d 55 e0	 lea	 edx, DWORD PTR _ckChild$[ebp]
  00177	52		 push	 edx
  00178	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0017b	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L70097:

; 958  :         while (pParser->NextChunk(&hr))

  00180	8d 45 dc	 lea	 eax, DWORD PTR _hr$[ebp]
  00183	50		 push	 eax
  00184	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00187	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  0018c	85 c0		 test	 eax, eax
  0018e	74 49		 je	 SHORT $L70098

; 959  :         {
; 960  :             if ( ckChild.ckid == mmioFOURCC('I','N','A','M'))

  00190	81 7d e0 49 4e
	41 4d		 cmp	 DWORD PTR _ckChild$[ebp], 1296125513 ; 4d414e49H
  00197	75 3e		 jne	 SHORT $L70107

; 961  :             {
; 962  : 			    char szName[DMUS_MAX_NAME];
; 963  : 			    hr = pParser->Read(szName, DMUS_MAX_NAME);

  00199	6a 40		 push	 64			; 00000040H
  0019b	8d 4d 98	 lea	 ecx, DWORD PTR _szName$70108[ebp]
  0019e	51		 push	 ecx
  0019f	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  001a2	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  001a7	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 964  : 			    if(SUCCEEDED(hr))

  001aa	83 7d dc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001ae	7c 25		 jl	 SHORT $L70110

; 965  : 			    {
; 966  : 				    MultiByteToWideChar(CP_ACP, 0, szName, -1, m_wszName, DMUS_MAX_NAME);

  001b0	6a 40		 push	 64			; 00000040H
  001b2	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  001b5	83 c2 04	 add	 edx, 4
  001b8	52		 push	 edx
  001b9	6a ff		 push	 -1
  001bb	8d 45 98	 lea	 eax, DWORD PTR _szName$70108[ebp]
  001be	50		 push	 eax
  001bf	6a 00		 push	 0
  001c1	6a 00		 push	 0
  001c3	e8 00 00 00 00	 call	 _MultiByteToWideChar@24

; 967  : 				    m_dwValidData |= DMUS_OBJ_NAME;

  001c8	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  001cb	8b 11		 mov	 edx, DWORD PTR [ecx]
  001cd	83 ca 04	 or	 edx, 4
  001d0	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  001d3	89 10		 mov	 DWORD PTR [eax], edx
$L70110:

; 968  : 			    }
; 969  :                 break;

  001d5	eb 02		 jmp	 SHORT $L70098
$L70107:

; 970  :             }
; 971  :         }

  001d7	eb a7		 jmp	 SHORT $L70097
$L70098:

; 972  :         pParser->LeaveList();

  001d9	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  001dc	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList
$L70015:

; 973  :         break;
; 974  :     }
; 975  :     return hr;

  001e1	8b 45 dc	 mov	 eax, DWORD PTR _hr$[ebp]

; 976  : }

  001e4	8b e5		 mov	 esp, ebp
  001e6	5d		 pop	 ebp
  001e7	c2 08 00	 ret	 8
?ReadChunk@CInfo@@QAEJPAVCRiffParser@@K@Z ENDP		; CInfo::ReadChunk
_TEXT	ENDS
PUBLIC	?Init@CInfo@@QAEXXZ				; CInfo::Init
; Function compile flags: /Odt
;	COMDAT ?Init@CInfo@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Init@CInfo@@QAEXXZ PROC NEAR				; CInfo::Init, COMDAT
; _this$ = ecx

; 981  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 982  :     memset(this,0,sizeof(CInfo));

  00007	68 2c 03 00 00	 push	 812			; 0000032cH
  0000c	6a 00		 push	 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _memset
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 983  :     m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2

; 984  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?Init@CInfo@@QAEXXZ ENDP				; CInfo::Init
_TEXT	ENDS
PUBLIC	?ReadReference@CLinkParser@@QAEJPAVCRiffParser@@PAU_DMUS_OBJECTDESC@@@Z ; CLinkParser::ReadReference
; Function compile flags: /Odt
;	COMDAT ?ReadReference@CLinkParser@@QAEJPAVCRiffParser@@PAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT
tv71 = -72
_this$ = -68
_ioDMRef$70139 = -64
_ioDMObjVer$70205 = -44
_hr$ = -36
_ckNext$ = -32
_pParser$ = 8
_pDesc$ = 12
?ReadReference@CLinkParser@@QAEJPAVCRiffParser@@PAU_DMUS_OBJECTDESC@@@Z PROC NEAR ; CLinkParser::ReadReference, COMDAT
; _this$ = ecx

; 989  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 990  :     HRESULT hr = S_OK;

  00009	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 991  :     pDesc->dwValidData = 0;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  00013	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 992  :     RIFFIO ckNext;
; 993  :     pParser->EnterList(&ckNext);

  0001a	8d 4d e0	 lea	 ecx, DWORD PTR _ckNext$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00021	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L70124:

; 994  :     while(pParser->NextChunk(&hr))

  00026	8d 55 dc	 lea	 edx, DWORD PTR _hr$[ebp]
  00029	52		 push	 edx
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0002d	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  00032	85 c0		 test	 eax, eax
  00034	0f 84 e9 01 00
	00		 je	 $L70125

; 995  :     {
; 996  :         switch(ckNext.ckid)
; 997  :         {

  0003a	8b 45 e0	 mov	 eax, DWORD PTR _ckNext$[ebp]
  0003d	89 45 b8	 mov	 DWORD PTR tv71[ebp], eax
  00040	81 7d b8 64 61
	74 65		 cmp	 DWORD PTR tv71[ebp], 1702125924 ; 65746164H
  00047	77 54		 ja	 SHORT $L70676
  00049	81 7d b8 64 61
	74 65		 cmp	 DWORD PTR tv71[ebp], 1702125924 ; 65746164H
  00050	0f 84 41 01 00
	00		 je	 $L70185
  00056	81 7d b8 66 69
	6c 65		 cmp	 DWORD PTR tv71[ebp], 1701603686 ; 656c6966H
  0005d	77 2c		 ja	 SHORT $L70677
  0005f	81 7d b8 66 69
	6c 65		 cmp	 DWORD PTR tv71[ebp], 1701603686 ; 656c6966H
  00066	0f 84 fd 00 00
	00		 je	 $L70176
  0006c	81 7d b8 64 6c
	69 64		 cmp	 DWORD PTR tv71[ebp], 1684630628 ; 64696c64H
  00073	0f 84 9d 00 00
	00		 je	 $L70149
  00079	81 7d b8 67 75
	69 64		 cmp	 DWORD PTR tv71[ebp], 1684632935 ; 64697567H
  00080	0f 84 90 00 00
	00		 je	 $L70149
  00086	e9 93 01 00 00	 jmp	 $L70127
$L70677:
  0008b	81 7d b8 6e 61
	6d 65		 cmp	 DWORD PTR tv71[ebp], 1701667182 ; 656d616eH
  00092	0f 84 a6 00 00
	00		 je	 $L70167
  00098	e9 81 01 00 00	 jmp	 $L70127
$L70676:
  0009d	81 7d b8 63 61
	74 67		 cmp	 DWORD PTR tv71[ebp], 1735680355 ; 67746163H
  000a4	0f 84 15 01 00
	00		 je	 $L70195
  000aa	81 7d b8 72 65
	66 68		 cmp	 DWORD PTR tv71[ebp], 1751541106 ; 68666572H
  000b1	74 12		 je	 SHORT $L70138
  000b3	81 7d b8 76 65
	72 73		 cmp	 DWORD PTR tv71[ebp], 1936876918 ; 73726576H
  000ba	0f 84 29 01 00
	00		 je	 $L70204
  000c0	e9 59 01 00 00	 jmp	 $L70127
$L70138:

; 998  :         case  DMUS_FOURCC_REF_CHUNK:
; 999  :             DMUS_IO_REFERENCE ioDMRef;
; 1000 :             hr = pParser->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE));

  000c5	6a 14		 push	 20			; 00000014H
  000c7	8d 4d c0	 lea	 ecx, DWORD PTR _ioDMRef$70139[ebp]
  000ca	51		 push	 ecx
  000cb	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  000ce	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  000d3	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 1001 :             pDesc->guidClass = ioDMRef.guidClassID;

  000d6	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  000d9	83 c2 18	 add	 edx, 24			; 00000018H
  000dc	8b 45 c0	 mov	 eax, DWORD PTR _ioDMRef$70139[ebp]
  000df	89 02		 mov	 DWORD PTR [edx], eax
  000e1	8b 4d c4	 mov	 ecx, DWORD PTR _ioDMRef$70139[ebp+4]
  000e4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000e7	8b 45 c8	 mov	 eax, DWORD PTR _ioDMRef$70139[ebp+8]
  000ea	89 42 08	 mov	 DWORD PTR [edx+8], eax
  000ed	8b 4d cc	 mov	 ecx, DWORD PTR _ioDMRef$70139[ebp+12]
  000f0	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1002 :             pDesc->dwValidData |= ioDMRef.dwValidData;

  000f3	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  000f6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f9	0b 45 d0	 or	 eax, DWORD PTR _ioDMRef$70139[ebp+16]
  000fc	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  000ff	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1003 :             pDesc->dwValidData |= DMUS_OBJ_CLASS;

  00102	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00105	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00108	83 c8 02	 or	 eax, 2
  0010b	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  0010e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1004 :             break;

  00111	e9 08 01 00 00	 jmp	 $L70127
$L70149:

; 1005 :         case FOURCC_DLID:
; 1006 :         case DMUS_FOURCC_GUID_CHUNK:
; 1007 :             hr = pParser->Read(&(pDesc->guidObject), sizeof(GUID));

  00116	6a 10		 push	 16			; 00000010H
  00118	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  0011b	83 c2 08	 add	 edx, 8
  0011e	52		 push	 edx
  0011f	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00122	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00127	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 1008 :             pDesc->dwValidData |=  DMUS_OBJ_OBJECT;

  0012a	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  0012d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00130	83 c9 01	 or	 ecx, 1
  00133	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00136	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1009 :             break;

  00139	e9 e0 00 00 00	 jmp	 $L70127
$L70167:

; 1010 :         case DMUS_FOURCC_NAME_CHUNK:
; 1011 :             hr = pParser->Read(pDesc->wszName, sizeof(pDesc->wszName));

  0013e	68 80 00 00 00	 push	 128			; 00000080H
  00143	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  00146	83 c0 38	 add	 eax, 56			; 00000038H
  00149	50		 push	 eax
  0014a	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0014d	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00152	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 1012 :             pDesc->dwValidData |=  DMUS_OBJ_NAME;

  00155	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  00158	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0015b	83 ca 04	 or	 edx, 4
  0015e	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  00161	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1013 :             break;

  00164	e9 b5 00 00 00	 jmp	 $L70127
$L70176:

; 1014 :         case DMUS_FOURCC_FILE_CHUNK:
; 1015 :             hr = pParser->Read(pDesc->wszFileName, sizeof(pDesc->wszFileName));

  00169	68 08 02 00 00	 push	 520			; 00000208H
  0016e	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  00171	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
  00177	51		 push	 ecx
  00178	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0017b	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00180	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 1016 :             pDesc->dwValidData |=  DMUS_OBJ_FILENAME;

  00183	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00186	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00189	83 c8 10	 or	 eax, 16			; 00000010H
  0018c	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  0018f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1017 :             break;

  00192	e9 87 00 00 00	 jmp	 $L70127
$L70185:

; 1018 :         case DMUS_FOURCC_DATE_CHUNK:
; 1019 :             hr = pParser->Read(&(pDesc->ftDate), sizeof(FILETIME));

  00197	6a 08		 push	 8
  00199	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  0019c	83 c2 28	 add	 edx, 40			; 00000028H
  0019f	52		 push	 edx
  001a0	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  001a3	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  001a8	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 1020 :             pDesc->dwValidData |=  DMUS_OBJ_DATE;

  001ab	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  001ae	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001b1	81 c9 00 01 00
	00		 or	 ecx, 256		; 00000100H
  001b7	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  001ba	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1021 :             break;

  001bd	eb 5f		 jmp	 SHORT $L70127
$L70195:

; 1022 :         case DMUS_FOURCC_CATEGORY_CHUNK:
; 1023 :             hr = pParser->Read(pDesc->wszCategory, sizeof(pDesc->wszCategory));

  001bf	68 80 00 00 00	 push	 128			; 00000080H
  001c4	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  001c7	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  001cc	50		 push	 eax
  001cd	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  001d0	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  001d5	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 1024 :             pDesc->dwValidData |=  DMUS_OBJ_CATEGORY;

  001d8	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  001db	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001de	83 ca 08	 or	 edx, 8
  001e1	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  001e4	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1025 :             break;

  001e7	eb 35		 jmp	 SHORT $L70127
$L70204:

; 1026 :         case DMUS_FOURCC_VERSION_CHUNK:
; 1027 :             DMUS_IO_VERSION ioDMObjVer;
; 1028 :             hr = pParser->Read(&ioDMObjVer, sizeof(DMUS_IO_VERSION));

  001e9	6a 08		 push	 8
  001eb	8d 4d d4	 lea	 ecx, DWORD PTR _ioDMObjVer$70205[ebp]
  001ee	51		 push	 ecx
  001ef	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  001f2	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  001f7	89 45 dc	 mov	 DWORD PTR _hr$[ebp], eax

; 1029 :             pDesc->vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;

  001fa	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  001fd	8b 45 d4	 mov	 eax, DWORD PTR _ioDMObjVer$70205[ebp]
  00200	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 1030 :             pDesc->vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;

  00203	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  00206	8b 55 d8	 mov	 edx, DWORD PTR _ioDMObjVer$70205[ebp+4]
  00209	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 1031 :             pDesc->dwValidData |= DMUS_OBJ_VERSION;

  0020c	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  0020f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00212	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  00218	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  0021b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L70127:

; 1032 :             break;
; 1033 :         }
; 1034 :     }

  0021e	e9 03 fe ff ff	 jmp	 $L70124
$L70125:

; 1035 :     pParser->LeaveList();

  00223	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00226	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList

; 1036 :     return hr;

  0022b	8b 45 dc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1037 : }

  0022e	8b e5		 mov	 esp, ebp
  00230	5d		 pop	 ebp
  00231	c2 08 00	 ret	 8
?ReadReference@CLinkParser@@QAEJPAVCRiffParser@@PAU_DMUS_OBJECTDESC@@@Z ENDP ; CLinkParser::ReadReference
_TEXT	ENDS
PUBLIC	?LoadReferencedObject@CLinkParser@@QAEJPAVCRiffParser@@PAPAXABU_GUID@@H@Z ; CLinkParser::LoadReferencedObject
PUBLIC	?GetStream@CRiffParser@@QAEPAUIStream@@XZ	; CRiffParser::GetStream
EXTRN	_IID_IDirectMusicGetLoader:BYTE
; Function compile flags: /Odt
;	COMDAT ?LoadReferencedObject@CLinkParser@@QAEJPAVCRiffParser@@PAPAXABU_GUID@@H@Z
_TEXT	SEGMENT
tv67 = -872
_this$ = -868
_Desc$70222 = -864
_pLoader$70219 = -12
_hr$ = -8
_pIGetLoader$ = -4
_pParser$ = 8
_ppObject$ = 12
_rguidIID$ = 16
_fDontCache$ = 20
?LoadReferencedObject@CLinkParser@@QAEJPAVCRiffParser@@PAPAXABU_GUID@@H@Z PROC NEAR ; CLinkParser::LoadReferencedObject, COMDAT
; _this$ = ecx

; 1041 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 03 00
	00		 sub	 esp, 872		; 00000368H
  00009	89 8d 9c fc ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 1042 :     IDirectMusicGetLoader *pIGetLoader;
; 1043 :     HRESULT hr = pParser->GetStream()->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetStream@CRiffParser@@QAEPAUIStream@@XZ ; CRiffParser::GetStream
  00017	89 85 98 fc ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
  0001d	8d 45 fc	 lea	 eax, DWORD PTR _pIGetLoader$[ebp]
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicGetLoader
  00026	8b 8d 98 fc ff
	ff		 mov	 ecx, DWORD PTR tv67[ebp]
  0002c	51		 push	 ecx
  0002d	8b 95 98 fc ff
	ff		 mov	 edx, DWORD PTR tv67[ebp]
  00033	8b 02		 mov	 eax, DWORD PTR [edx]
  00035	ff 10		 call	 DWORD PTR [eax]
  00037	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1044 :     if (SUCCEEDED(hr))

  0003a	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0003e	0f 8c 9d 00 00
	00		 jl	 $L70218

; 1045 :     {
; 1046 :         IDirectMusicLoader* pLoader = NULL;

  00044	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pLoader$70219[ebp], 0

; 1047 :         hr = pIGetLoader->GetLoader(&pLoader);

  0004b	8d 4d f4	 lea	 ecx, DWORD PTR _pLoader$70219[ebp]
  0004e	51		 push	 ecx
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _pIGetLoader$[ebp]
  00052	8b 02		 mov	 eax, DWORD PTR [edx]
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _pIGetLoader$[ebp]
  00057	51		 push	 ecx
  00058	ff 50 0c	 call	 DWORD PTR [eax+12]
  0005b	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1048 :         pIGetLoader->Release();

  0005e	8b 55 fc	 mov	 edx, DWORD PTR _pIGetLoader$[ebp]
  00061	8b 02		 mov	 eax, DWORD PTR [edx]
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _pIGetLoader$[ebp]
  00066	51		 push	 ecx
  00067	ff 50 08	 call	 DWORD PTR [eax+8]

; 1049 :         if (SUCCEEDED(hr))

  0006a	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006e	7c 71		 jl	 SHORT $L70218

; 1050 :         {
; 1051 :             DMUS_OBJECTDESC Desc;
; 1052 :             hr = ReadReference(pParser,&Desc);

  00070	8d 95 a0 fc ff
	ff		 lea	 edx, DWORD PTR _Desc$70222[ebp]
  00076	52		 push	 edx
  00077	8b 45 08	 mov	 eax, DWORD PTR _pParser$[ebp]
  0007a	50		 push	 eax
  0007b	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00081	e8 00 00 00 00	 call	 ?ReadReference@CLinkParser@@QAEJPAVCRiffParser@@PAU_DMUS_OBJECTDESC@@@Z ; CLinkParser::ReadReference
  00086	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1053 :             if(SUCCEEDED(hr))

  00089	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0008d	7c 46		 jl	 SHORT $L70224

; 1054 :             {
; 1055 :                 Desc.dwSize = sizeof(DMUS_OBJECTDESC);

  0008f	c7 85 a0 fc ff
	ff 50 03 00 00	 mov	 DWORD PTR _Desc$70222[ebp], 848 ; 00000350H

; 1056 :                 hr = pLoader->GetObject(&Desc, rguidIID, ppObject);

  00099	8b 4d 0c	 mov	 ecx, DWORD PTR _ppObject$[ebp]
  0009c	51		 push	 ecx
  0009d	8b 55 10	 mov	 edx, DWORD PTR _rguidIID$[ebp]
  000a0	52		 push	 edx
  000a1	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR _Desc$70222[ebp]
  000a7	50		 push	 eax
  000a8	8b 4d f4	 mov	 ecx, DWORD PTR _pLoader$70219[ebp]
  000ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ad	8b 45 f4	 mov	 eax, DWORD PTR _pLoader$70219[ebp]
  000b0	50		 push	 eax
  000b1	ff 52 0c	 call	 DWORD PTR [edx+12]
  000b4	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1057 :                 // Once we get the object, we need to ensure that the same object is never
; 1058 :                 // connected up to any other songs (or this one, too.)
; 1059 :                 // So, we ensure that the loader doesn't keep it around.
; 1060 :                 if (SUCCEEDED(hr) && fDontCache)

  000b7	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000bb	7c 18		 jl	 SHORT $L70224
  000bd	83 7d 14 00	 cmp	 DWORD PTR _fDontCache$[ebp], 0
  000c1	74 12		 je	 SHORT $L70224

; 1061 :                 {
; 1062 : #ifdef DXAPI
; 1063 :                     IDirectMusicObject *pObject;
; 1064 :                     if (SUCCEEDED(((IUnknown *) (*ppObject))->QueryInterface(IID_IDirectMusicObject,(void **)&pObject)))
; 1065 :                     {
; 1066 :                         pLoader->ReleaseObject(pObject);
; 1067 :                         pObject->Release();
; 1068 :                     }
; 1069 : #else
; 1070 :                     pLoader->ReleaseObjectByUnknown((IUnknown *) (*ppObject));

  000c3	8b 4d 0c	 mov	 ecx, DWORD PTR _ppObject$[ebp]
  000c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c8	52		 push	 edx
  000c9	8b 45 f4	 mov	 eax, DWORD PTR _pLoader$70219[ebp]
  000cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ce	8b 55 f4	 mov	 edx, DWORD PTR _pLoader$70219[ebp]
  000d1	52		 push	 edx
  000d2	ff 51 20	 call	 DWORD PTR [ecx+32]
$L70224:

; 1071 : #endif
; 1072 :                 }
; 1073 :             }
; 1074 :             pLoader->Release();

  000d5	8b 45 f4	 mov	 eax, DWORD PTR _pLoader$70219[ebp]
  000d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000da	8b 55 f4	 mov	 edx, DWORD PTR _pLoader$70219[ebp]
  000dd	52		 push	 edx
  000de	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70218:

; 1075 :         }
; 1076 :     }
; 1077 :     return hr;

  000e1	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1078 : }

  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 10 00	 ret	 16			; 00000010H
?LoadReferencedObject@CLinkParser@@QAEJPAVCRiffParser@@PAPAXABU_GUID@@H@Z ENDP ; CLinkParser::LoadReferencedObject
_TEXT	ENDS
EXTRN	?DirectMusicAllocI@@YGPAXI@Z:NEAR		; DirectMusicAllocI
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xalloc.h
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_cb$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 13   :     return DirectMusicAllocI(cb);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cb$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicAllocI@@YGPAXI@Z ; DirectMusicAllocI

; 14   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
EXTRN	?DirectMusicFreeI@@YGXPAX@Z:NEAR		; DirectMusicFreeI
; Function compile flags: /Odt
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_pv$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18   :     DirectMusicFreeI(pv);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicFreeI@@YGXPAX@Z ; DirectMusicFreeI

; 19   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\dmstrm.h
_TEXT	ENDS
;	COMDAT ?GetStream@CRiffParser@@QAEPAUIStream@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetStream@CRiffParser@@QAEPAUIStream@@XZ PROC NEAR	; CRiffParser::GetStream, COMDAT
; _this$ = ecx

; 96   :     IStream *   GetStream() { return m_pStream; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetStream@CRiffParser@@QAEPAUIStream@@XZ ENDP		; CRiffParser::GetStream
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IUnknown@@QAE@XZ PROC NEAR				; IUnknown::IUnknown, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0IUnknown@@QAE@XZ ENDP				; IUnknown::IUnknown
_TEXT	ENDS
END
