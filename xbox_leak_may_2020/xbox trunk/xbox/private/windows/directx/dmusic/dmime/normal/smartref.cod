; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	..\smartref.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03DGODMHAK@psz?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@NGDBOKBB@Error?3?5Unable?5to?5read?5file?4?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@JPKKDAMM@this?9?$DOtype?$CI?$CJ?5?$DN?$DN?5List?5?$CG?$CG?5this?9?$DOid@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IMILPDMH@pObjInfo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BGAOHDMM@?$CBp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT ??0AString@SmartRef@@QAE@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4AString@SmartRef@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Assign@AString@SmartRef@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssignFromW@AString@SmartRef@@QAEAAV12@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4WString@SmartRef@@QAEAAV01@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Assign@WString@SmartRef@@QAEAAV12@PBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssignFromA@WString@SmartRef@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0RiffIter@SmartRef@@QAE@PAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1RiffIter@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ERiffIter@SmartRef@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Find@RiffIter@SmartRef@@QAEAAV12@W4RiffType@12@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadArrayChunk@RiffIter@SmartRef@@QAEJKPAPAXPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindAndGetEmbeddedObject@RiffIter@SmartRef@@QAEJW4RiffType@12@KJPAUIDirectMusicLoader@@ABU_GUID@@2PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadReference@RiffIter@SmartRef@@QAEJPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadObjectInfo@RiffIter@SmartRef@@QAEJPAUObjectInfo@12@W4RiffType@12@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadText@RiffIter@SmartRef@@QAEJPAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadTextTrunc@RiffIter@SmartRef@@QAEJPAGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0RiffIter@SmartRef@@AAE@ABV01@U_MMCKINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@UTriggerInfo@@@@QBEPAV?$TListItem@UTriggerInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@UTriggerInfo@@@@QAEXPAV?$TListItem@UTriggerInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@ULyricInfo@@@@QBEPAV?$TListItem@ULyricInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@UTriggerInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@UTriggerInfo@@@@QAEAAUTriggerInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@ULyricInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@UTriggerInfo@@@@SGHAAUTriggerInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@ULyricInfo@@@@SGHAAULyricInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStandardStateData@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$PtrArray@D@SmartRef@@QAE@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$PtrArray@D@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$PtrArray@D@SmartRef@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?disown@?$PtrArray@D@SmartRef@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@UTriggerInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEAAV01@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@UTriggerInfo@@@@QAEXP6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@ULyricInfo@@@@QAEXP6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UWaveItem@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@_J@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UObjectInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SafeRelease@@YGXAAPAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SafeRelease@@YGXAAPAUIDMStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?min@std@@YGABKABK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ZeroAndSize@@YGXPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_REFERENCE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_FILETIME@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAY0EA@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAY0BAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_VERSION@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_VERSION@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ObjectInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@UTriggerInfo@@@@QAEPAV1@P6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@ULyricInfo@@@@QAEPAV1@P6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Zero@@YGXPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@UTriggerInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@UTriggerInfo@@@@AAEPAV1@PAV1@P6GHAAUTriggerInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@ULyricInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@ULyricInfo@@@@AAEPAV1@PAV1@P6GHAAULyricInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UParamInfo@CParamControlTrack@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UParamInfo@CParamControlTrack@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ParamInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WaveItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WString@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WString@SmartRef@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@ULyricInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UTriggerInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UTriggerInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@ObjectInfo@RiffIter@SmartRef@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Descend@RiffIter@SmartRef@@QAE?AV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?hr@RiffIter@SmartRef@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@RiffIter@SmartRef@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@ILBLFLGI@type?$CI?$CJ?5?$DN?$DN?5Chunk?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?id@RiffIter@SmartRef@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRiffIter@SmartRef@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?validate@RiffIter@SmartRef@@ABE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_U@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_03DGODMHAK@psz?$AA@			; `string'
PUBLIC	??0AString@SmartRef@@QAE@PBDI@Z			; SmartRef::AString::AString
EXTRN	?DebugAssert@@YGXPAD0K@Z:NEAR			; DebugAssert
EXTRN	_strncpy:NEAR
;	COMDAT ??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
; File c:\xbox\private\windows\directx\dmusic\dmime\smartref.cpp
CONST	SEGMENT
??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dmusic\dmime\smartref.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DGODMHAK@psz?$AA@
CONST	SEGMENT
??_C@_03DGODMHAK@psz?$AA@ DB 'psz', 00H			; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0AString@SmartRef@@QAE@PBDI@Z
_TEXT	SEGMENT
_this$ = -8
$T70262 = -4
_psz$ = 8
_cch$ = 12
??0AString@SmartRef@@QAE@PBDI@Z PROC NEAR		; SmartRef::AString::AString, COMDAT
; _this$ = ecx

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 21   : 	assert(psz);

  00009	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  0000d	75 11		 jne	 SHORT $L70261
  0000f	6a 15		 push	 21			; 00000015H
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03DGODMHAK@psz?$AA@
  0001b	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70261:

; 22   : 	m_psz = new char[cch + 1];

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _cch$[ebp]
  00023	83 c1 01	 add	 ecx, 1
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0002c	83 c4 04	 add	 esp, 4
  0002f	89 45 fc	 mov	 DWORD PTR $T70262[ebp], eax
  00032	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00035	8b 45 fc	 mov	 eax, DWORD PTR $T70262[ebp]
  00038	89 02		 mov	 DWORD PTR [edx], eax

; 23   : 	if (m_psz)

  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00040	74 22		 je	 SHORT $L69420

; 24   : 	{
; 25   : 		strncpy(m_psz, psz, cch);

  00042	8b 55 0c	 mov	 edx, DWORD PTR _cch$[ebp]
  00045	52		 push	 edx
  00046	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 _strncpy
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 26   : 		m_psz[cch] = L'\0';

  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	8b 55 0c	 mov	 edx, DWORD PTR _cch$[ebp]
  00060	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0
$L69420:

; 27   : 	}
; 28   : }

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
??0AString@SmartRef@@QAE@PBDI@Z ENDP			; SmartRef::AString::AString
_TEXT	ENDS
PUBLIC	??4AString@SmartRef@@QAEAAV01@PBD@Z		; SmartRef::AString::operator=
EXTRN	_strcpy:NEAR
EXTRN	_strlen:NEAR
; Function compile flags: /Odt
;	COMDAT ??4AString@SmartRef@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -12
$T70267 = -8
$T70266 = -4
_psz$ = 8
??4AString@SmartRef@@QAEAAV01@PBD@Z PROC NEAR		; SmartRef::AString::operator=, COMDAT
; _this$ = ecx

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 	if (m_psz)

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 1d		 je	 SHORT $L69431

; 34   : 	{
; 35   : 		delete[] m_psz;

  00011	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 55 fc	 mov	 DWORD PTR $T70266[ebp], edx
  00019	8b 45 fc	 mov	 eax, DWORD PTR $T70266[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00022	83 c4 04	 add	 esp, 4

; 36   : 		m_psz = NULL;

  00025	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L69431:

; 37   : 	}
; 38   : 
; 39   : 	if (psz)

  0002e	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  00032	74 3d		 je	 SHORT $L69433

; 40   : 	{
; 41   : 		m_psz = new char[strlen(psz) + 1];

  00034	8b 55 08	 mov	 edx, DWORD PTR _psz$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 _strlen
  0003d	83 c4 04	 add	 esp, 4
  00040	83 c0 01	 add	 eax, 1
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00049	83 c4 04	 add	 esp, 4
  0004c	89 45 f8	 mov	 DWORD PTR $T70267[ebp], eax
  0004f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 4d f8	 mov	 ecx, DWORD PTR $T70267[ebp]
  00055	89 08		 mov	 DWORD PTR [eax], ecx

; 42   : 		if (m_psz)

  00057	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0005d	74 12		 je	 SHORT $L69433

; 43   : 			strcpy(m_psz, psz);

  0005f	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00062	50		 push	 eax
  00063	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	8b 11		 mov	 edx, DWORD PTR [ecx]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _strcpy
  0006e	83 c4 08	 add	 esp, 8
$L69433:

; 44   : 	}
; 45   : 
; 46   : 	return *this;

  00071	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]

; 47   : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??4AString@SmartRef@@QAEAAV01@PBD@Z ENDP		; SmartRef::AString::operator=
_TEXT	ENDS
PUBLIC	?Assign@AString@SmartRef@@QAEAAV12@PBDI@Z	; SmartRef::AString::Assign
; Function compile flags: /Odt
;	COMDAT ?Assign@AString@SmartRef@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -12
$T70273 = -8
$T70272 = -4
_psz$ = 8
_cch$ = 12
?Assign@AString@SmartRef@@QAEAAV12@PBDI@Z PROC NEAR	; SmartRef::AString::Assign, COMDAT
; _this$ = ecx

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 51   : 	assert(psz);

  00009	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  0000d	75 11		 jne	 SHORT $L70271
  0000f	6a 33		 push	 51			; 00000033H
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03DGODMHAK@psz?$AA@
  0001b	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70271:

; 52   : 	if (m_psz)

  00020	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00026	74 1d		 je	 SHORT $L69443

; 53   : 	{
; 54   : 		delete[] m_psz;

  00028	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 02		 mov	 eax, DWORD PTR [edx]
  0002d	89 45 fc	 mov	 DWORD PTR $T70272[ebp], eax
  00030	8b 4d fc	 mov	 ecx, DWORD PTR $T70272[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00039	83 c4 04	 add	 esp, 4

; 55   : 		m_psz = NULL;

  0003c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L69443:

; 56   : 	}
; 57   : 
; 58   : 	m_psz = new char[cch + 1];

  00045	8b 45 0c	 mov	 eax, DWORD PTR _cch$[ebp]
  00048	83 c0 01	 add	 eax, 1
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00051	83 c4 04	 add	 esp, 4
  00054	89 45 f8	 mov	 DWORD PTR $T70273[ebp], eax
  00057	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	8b 55 f8	 mov	 edx, DWORD PTR $T70273[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx

; 59   : 	if (m_psz)

  0005f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00062	83 38 00	 cmp	 DWORD PTR [eax], 0
  00065	74 22		 je	 SHORT $L69447

; 60   : 	{
; 61   : 		strncpy(m_psz, psz, cch);

  00067	8b 4d 0c	 mov	 ecx, DWORD PTR _cch$[ebp]
  0006a	51		 push	 ecx
  0006b	8b 55 08	 mov	 edx, DWORD PTR _psz$[ebp]
  0006e	52		 push	 edx
  0006f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 08		 mov	 ecx, DWORD PTR [eax]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _strncpy
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 62   : 		m_psz[cch] = L'\0';

  0007d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00080	8b 02		 mov	 eax, DWORD PTR [edx]
  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _cch$[ebp]
  00085	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
$L69447:

; 63   : 	}
; 64   : 
; 65   : 	return *this;

  00089	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]

; 66   : }

  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
?Assign@AString@SmartRef@@QAEAAV12@PBDI@Z ENDP		; SmartRef::AString::Assign
_TEXT	ENDS
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	?AssignFromW@AString@SmartRef@@QAEAAV12@PBG@Z	; SmartRef::AString::AssignFromW
EXTRN	_WideCharToMultiByte@32:NEAR
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?AssignFromW@AString@SmartRef@@QAEAAV12@PBG@Z
_TEXT	SEGMENT
_this$ = -20
$T70280 = -16
$T70278 = -12
$T70277 = -8
_cch$69455 = -4
_psz$ = 8
?AssignFromW@AString@SmartRef@@QAEAAV12@PBG@Z PROC NEAR	; SmartRef::AString::AssignFromW, COMDAT
; _this$ = ecx

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 71   : 	if (m_psz)

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 1d		 je	 SHORT $L69452

; 72   : 	{
; 73   : 		delete[] m_psz;

  00011	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 55 f8	 mov	 DWORD PTR $T70277[ebp], edx
  00019	8b 45 f8	 mov	 eax, DWORD PTR $T70277[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00022	83 c4 04	 add	 esp, 4

; 74   : 		m_psz = NULL;

  00025	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L69452:

; 75   : 	}
; 76   : 
; 77   : 	if (psz)

  0002e	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  00032	0f 84 99 00 00
	00		 je	 $L69454

; 78   : 	{
; 79   : 		int cch = WideCharToMultiByte(CP_ACP, 0, psz, -1, NULL, 0, NULL, NULL);

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	6a ff		 push	 -1
  00042	8b 55 08	 mov	 edx, DWORD PTR _psz$[ebp]
  00045	52		 push	 edx
  00046	6a 00		 push	 0
  00048	6a 00		 push	 0
  0004a	e8 00 00 00 00	 call	 _WideCharToMultiByte@32
  0004f	89 45 fc	 mov	 DWORD PTR _cch$69455[ebp], eax

; 80   : 		if (cch)

  00052	83 7d fc 00	 cmp	 DWORD PTR _cch$69455[ebp], 0
  00056	74 79		 je	 SHORT $L69454

; 81   : 		{
; 82   : 			m_psz = new char[cch];

  00058	8b 45 fc	 mov	 eax, DWORD PTR _cch$69455[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00061	83 c4 04	 add	 esp, 4
  00064	89 45 f4	 mov	 DWORD PTR $T70278[ebp], eax
  00067	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	8b 55 f4	 mov	 edx, DWORD PTR $T70278[ebp]
  0006d	89 11		 mov	 DWORD PTR [ecx], edx

; 83   : 			if (m_psz)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00072	83 38 00	 cmp	 DWORD PTR [eax], 0
  00075	74 5a		 je	 SHORT $L69454

; 84   : 			{
; 85   : 				cch = WideCharToMultiByte(CP_ACP, 0, psz, -1, m_psz, cch, NULL, NULL);

  00077	6a 00		 push	 0
  00079	6a 00		 push	 0
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _cch$69455[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00082	8b 02		 mov	 eax, DWORD PTR [edx]
  00084	50		 push	 eax
  00085	6a ff		 push	 -1
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0008a	51		 push	 ecx
  0008b	6a 00		 push	 0
  0008d	6a 00		 push	 0
  0008f	e8 00 00 00 00	 call	 _WideCharToMultiByte@32
  00094	89 45 fc	 mov	 DWORD PTR _cch$69455[ebp], eax

; 86   : 				if (!cch)

  00097	83 7d fc 00	 cmp	 DWORD PTR _cch$69455[ebp], 0
  0009b	75 34		 jne	 SHORT $L69454

; 87   : 				{
; 88   : 					assert(false);

  0009d	33 d2		 xor	 edx, edx
  0009f	85 d2		 test	 edx, edx
  000a1	75 11		 jne	 SHORT $L70279
  000a3	6a 58		 push	 88			; 00000058H
  000a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
  000aa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
  000af	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70279:

; 89   : 					delete[] m_psz;

  000b4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b9	89 55 f0	 mov	 DWORD PTR $T70280[ebp], edx
  000bc	8b 45 f0	 mov	 eax, DWORD PTR $T70280[ebp]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000c5	83 c4 04	 add	 esp, 4

; 90   : 					m_psz = NULL;

  000c8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L69454:

; 91   : 				}
; 92   : 			}
; 93   : 		}
; 94   : 	}
; 95   : 
; 96   : 	return *this;

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]

; 97   : }

  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
?AssignFromW@AString@SmartRef@@QAEAAV12@PBG@Z ENDP	; SmartRef::AString::AssignFromW
_TEXT	ENDS
PUBLIC	??4WString@SmartRef@@QAEAAV01@PBG@Z		; SmartRef::WString::operator=
EXTRN	_wcscpy:NEAR
EXTRN	_wcslen:NEAR
; Function compile flags: /Odt
;	COMDAT ??4WString@SmartRef@@QAEAAV01@PBG@Z
_TEXT	SEGMENT
_this$ = -12
$T70285 = -8
$T70284 = -4
_psz$ = 8
??4WString@SmartRef@@QAEAAV01@PBG@Z PROC NEAR		; SmartRef::WString::operator=, COMDAT
; _this$ = ecx

; 104  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 105  : 	if (m_psz)

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 1d		 je	 SHORT $L69467

; 106  : 	{
; 107  : 		delete[] m_psz;

  00011	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 55 fc	 mov	 DWORD PTR $T70284[ebp], edx
  00019	8b 45 fc	 mov	 eax, DWORD PTR $T70284[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00022	83 c4 04	 add	 esp, 4

; 108  : 		m_psz = NULL;

  00025	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L69467:

; 109  : 	}
; 110  : 
; 111  : 	if (psz)

  0002e	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  00032	74 3e		 je	 SHORT $L69469

; 112  : 	{
; 113  : 		m_psz = new WCHAR[wcslen(psz) + 1];

  00034	8b 55 08	 mov	 edx, DWORD PTR _psz$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 _wcslen
  0003d	83 c4 04	 add	 esp, 4
  00040	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 f8	 mov	 DWORD PTR $T70285[ebp], eax
  00050	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 55 f8	 mov	 edx, DWORD PTR $T70285[ebp]
  00056	89 11		 mov	 DWORD PTR [ecx], edx

; 114  : 		if (m_psz)

  00058	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0005e	74 12		 je	 SHORT $L69469

; 115  : 			wcscpy(m_psz, psz);

  00060	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  00063	51		 push	 ecx
  00064	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00067	8b 02		 mov	 eax, DWORD PTR [edx]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _wcscpy
  0006f	83 c4 08	 add	 esp, 8
$L69469:

; 116  : 	}
; 117  : 
; 118  : 	return *this;

  00072	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]

; 119  : }

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
??4WString@SmartRef@@QAEAAV01@PBG@Z ENDP		; SmartRef::WString::operator=
_TEXT	ENDS
PUBLIC	?Assign@WString@SmartRef@@QAEAAV12@PBGI@Z	; SmartRef::WString::Assign
EXTRN	_wcsncpy:NEAR
; Function compile flags: /Odt
;	COMDAT ?Assign@WString@SmartRef@@QAEAAV12@PBGI@Z
_TEXT	SEGMENT
_this$ = -12
$T70291 = -8
$T70290 = -4
_psz$ = 8
_cch$ = 12
?Assign@WString@SmartRef@@QAEAAV12@PBGI@Z PROC NEAR	; SmartRef::WString::Assign, COMDAT
; _this$ = ecx

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 123  : 	assert(psz);

  00009	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  0000d	75 11		 jne	 SHORT $L70289
  0000f	6a 7b		 push	 123			; 0000007bH
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03DGODMHAK@psz?$AA@
  0001b	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70289:

; 124  : 	if (m_psz)

  00020	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00026	74 1d		 je	 SHORT $L69479

; 125  : 	{
; 126  : 		delete[] m_psz;

  00028	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 02		 mov	 eax, DWORD PTR [edx]
  0002d	89 45 fc	 mov	 DWORD PTR $T70290[ebp], eax
  00030	8b 4d fc	 mov	 ecx, DWORD PTR $T70290[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00039	83 c4 04	 add	 esp, 4

; 127  : 		m_psz = NULL;

  0003c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L69479:

; 128  : 	}
; 129  : 
; 130  : 	m_psz = new WCHAR[cch + 1];

  00045	8b 45 0c	 mov	 eax, DWORD PTR _cch$[ebp]
  00048	8d 4c 00 02	 lea	 ecx, DWORD PTR [eax+eax+2]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00052	83 c4 04	 add	 esp, 4
  00055	89 45 f8	 mov	 DWORD PTR $T70291[ebp], eax
  00058	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 45 f8	 mov	 eax, DWORD PTR $T70291[ebp]
  0005e	89 02		 mov	 DWORD PTR [edx], eax

; 131  : 	if (m_psz)

  00060	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00066	74 24		 je	 SHORT $L69483

; 132  : 	{
; 133  : 		wcsncpy(m_psz, psz, cch);

  00068	8b 55 0c	 mov	 edx, DWORD PTR _cch$[ebp]
  0006b	52		 push	 edx
  0006c	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	8b 11		 mov	 edx, DWORD PTR [ecx]
  00075	52		 push	 edx
  00076	e8 00 00 00 00	 call	 _wcsncpy
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 134  : 		m_psz[cch] = L'\0';

  0007e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	8b 55 0c	 mov	 edx, DWORD PTR _cch$[ebp]
  00086	66 c7 04 51 00
	00		 mov	 WORD PTR [ecx+edx*2], 0
$L69483:

; 135  : 	}
; 136  : 
; 137  : 	return *this;

  0008c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]

; 138  : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 08 00	 ret	 8
?Assign@WString@SmartRef@@QAEAAV12@PBGI@Z ENDP		; SmartRef::WString::Assign
_TEXT	ENDS
PUBLIC	?AssignFromA@WString@SmartRef@@QAEAAV12@PBD@Z	; SmartRef::WString::AssignFromA
EXTRN	_MultiByteToWideChar@24:NEAR
; Function compile flags: /Odt
;	COMDAT ?AssignFromA@WString@SmartRef@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -20
$T70298 = -16
$T70296 = -12
$T70295 = -8
_cch$69491 = -4
_psz$ = 8
?AssignFromA@WString@SmartRef@@QAEAAV12@PBD@Z PROC NEAR	; SmartRef::WString::AssignFromA, COMDAT
; _this$ = ecx

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 143  : 	if (m_psz)

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 1d		 je	 SHORT $L69488

; 144  : 	{
; 145  : 		delete[] m_psz;

  00011	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 55 f8	 mov	 DWORD PTR $T70295[ebp], edx
  00019	8b 45 f8	 mov	 eax, DWORD PTR $T70295[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00022	83 c4 04	 add	 esp, 4

; 146  : 		m_psz = NULL;

  00025	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L69488:

; 147  : 	}
; 148  : 
; 149  : 	if (psz)

  0002e	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  00032	0f 84 96 00 00
	00		 je	 $L69490

; 150  : 	{
; 151  : 		int cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	6a ff		 push	 -1
  0003e	8b 55 08	 mov	 edx, DWORD PTR _psz$[ebp]
  00041	52		 push	 edx
  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	e8 00 00 00 00	 call	 _MultiByteToWideChar@24
  0004b	89 45 fc	 mov	 DWORD PTR _cch$69491[ebp], eax

; 152  : 		if (cch)

  0004e	83 7d fc 00	 cmp	 DWORD PTR _cch$69491[ebp], 0
  00052	74 7a		 je	 SHORT $L69490

; 153  : 		{
; 154  : 			m_psz = new WCHAR[cch];

  00054	8b 45 fc	 mov	 eax, DWORD PTR _cch$69491[ebp]
  00057	d1 e0		 shl	 eax, 1
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0005f	83 c4 04	 add	 esp, 4
  00062	89 45 f4	 mov	 DWORD PTR $T70296[ebp], eax
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	8b 55 f4	 mov	 edx, DWORD PTR $T70296[ebp]
  0006b	89 11		 mov	 DWORD PTR [ecx], edx

; 155  : 			if (m_psz)

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00070	83 38 00	 cmp	 DWORD PTR [eax], 0
  00073	74 59		 je	 SHORT $L69490

; 156  : 			{
; 157  : 				cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, m_psz, cch);

  00075	8b 4d fc	 mov	 ecx, DWORD PTR _cch$69491[ebp]
  00078	51		 push	 ecx
  00079	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	8b 02		 mov	 eax, DWORD PTR [edx]
  0007e	50		 push	 eax
  0007f	6a ff		 push	 -1
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  00084	51		 push	 ecx
  00085	6a 00		 push	 0
  00087	6a 00		 push	 0
  00089	e8 00 00 00 00	 call	 _MultiByteToWideChar@24
  0008e	89 45 fc	 mov	 DWORD PTR _cch$69491[ebp], eax

; 158  : 				if (!cch)

  00091	83 7d fc 00	 cmp	 DWORD PTR _cch$69491[ebp], 0
  00095	75 37		 jne	 SHORT $L69490

; 159  : 				{
; 160  : 					assert(false);

  00097	33 d2		 xor	 edx, edx
  00099	85 d2		 test	 edx, edx
  0009b	75 14		 jne	 SHORT $L70297
  0009d	68 a0 00 00 00	 push	 160			; 000000a0H
  000a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
  000ac	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70297:

; 161  : 					delete[] m_psz;

  000b1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b6	89 55 f0	 mov	 DWORD PTR $T70298[ebp], edx
  000b9	8b 45 f0	 mov	 eax, DWORD PTR $T70298[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000c2	83 c4 04	 add	 esp, 4

; 162  : 					m_psz = NULL;

  000c5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L69490:

; 163  : 				}
; 164  : 			}
; 165  : 		}
; 166  : 	}
; 167  : 
; 168  : 	return *this;

  000ce	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]

; 169  : }

  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c2 04 00	 ret	 4
?AssignFromA@WString@SmartRef@@QAEAAV12@PBD@Z ENDP	; SmartRef::WString::AssignFromA
_TEXT	ENDS
PUBLIC	??0RiffIter@SmartRef@@QAE@PAUIStream@@@Z	; SmartRef::RiffIter::RiffIter
EXTRN	_memset:NEAR
EXTRN	_AllocDirectMusicStream@8:NEAR
; Function compile flags: /Odt
;	COMDAT ??0RiffIter@SmartRef@@QAE@PAUIStream@@@Z
_TEXT	SEGMENT
_this$ = -4
_pStream$ = 8
??0RiffIter@SmartRef@@QAE@PAUIStream@@@Z PROC NEAR	; SmartRef::RiffIter::RiffIter, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _pStream$[ebp]
  00016	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 180  : 	m_pIStream->AddRef();

  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	52		 push	 edx
  00039	ff 50 04	 call	 DWORD PTR [eax+4]

; 181  : 
; 182  : 	ZeroMemory(&m_ckParent, sizeof(m_ckParent));

  0003c	6a 14		 push	 20			; 00000014H
  0003e	6a 00		 push	 0
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 _memset
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 183  : 	ZeroMemory(&m_ckChild, sizeof(m_ckChild));

  0004f	6a 14		 push	 20			; 00000014H
  00051	6a 00		 push	 0
  00053	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00056	83 c2 21	 add	 edx, 33			; 00000021H
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 _memset
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  : 
; 185  : 	m_hr = ::AllocDirectMusicStream(m_pIStream, &m_pIDMStream);

  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	83 c0 08	 add	 eax, 8
  00068	50		 push	 eax
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _AllocDirectMusicStream@8
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	89 01		 mov	 DWORD PTR [ecx], eax

; 186  : 	if (FAILED(m_hr))

  0007a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007d	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00080	7d 02		 jge	 SHORT $L69505

; 187  : 		return;

  00082	eb 22		 jmp	 SHORT $L69503
$L69505:

; 188  : 
; 189  : 	m_hr = m_pIDMStream->Descend(&m_ckChild, NULL, 0);

  00084	6a 00		 push	 0
  00086	6a 00		 push	 0
  00088	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008b	83 c0 21	 add	 eax, 33			; 00000021H
  0008e	50		 push	 eax
  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00095	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00098	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0009b	8b 12		 mov	 edx, DWORD PTR [edx]
  0009d	51		 push	 ecx
  0009e	ff 52 10	 call	 DWORD PTR [edx+16]
  000a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax
$L69503:

; 190  : }

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 04 00	 ret	 4
??0RiffIter@SmartRef@@QAE@PAUIStream@@@Z ENDP		; SmartRef::RiffIter::RiffIter
_TEXT	ENDS
PUBLIC	??1RiffIter@SmartRef@@QAE@XZ			; SmartRef::RiffIter::~RiffIter
PUBLIC	?SafeRelease@@YGXAAPAUIStream@@@Z		; SafeRelease
PUBLIC	?SafeRelease@@YGXAAPAUIDMStream@@@Z		; SafeRelease
; Function compile flags: /Odt
;	COMDAT ??1RiffIter@SmartRef@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1RiffIter@SmartRef@@QAE@XZ PROC NEAR			; SmartRef::RiffIter::~RiffIter, COMDAT
; _this$ = ecx

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 194  : 	if (!m_fParent)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  0000e	85 c9		 test	 ecx, ecx
  00010	75 18		 jne	 SHORT $L69508

; 195  : 	{
; 196  : 		SafeRelease(m_pIStream);

  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	83 c2 04	 add	 edx, 4
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 ?SafeRelease@@YGXAAPAUIStream@@@Z ; SafeRelease

; 197  : 		SafeRelease(m_pIDMStream);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?SafeRelease@@YGXAAPAUIDMStream@@@Z ; SafeRelease
$L69508:

; 198  : 	}
; 199  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??1RiffIter@SmartRef@@QAE@XZ ENDP			; SmartRef::RiffIter::~RiffIter
_TEXT	ENDS
PUBLIC	??ERiffIter@SmartRef@@QAEAAV01@XZ		; SmartRef::RiffIter::operator++
PUBLIC	?validate@RiffIter@SmartRef@@ABE_NXZ		; SmartRef::RiffIter::validate
; Function compile flags: /Odt
;	COMDAT ??ERiffIter@SmartRef@@QAEAAV01@XZ
_TEXT	SEGMENT
tv129 = -8
_this$ = -4
??ERiffIter@SmartRef@@QAEAAV01@XZ PROC NEAR		; SmartRef::RiffIter::operator++, COMDAT
; _this$ = ecx

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 204  : 	if (validate())

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?validate@RiffIter@SmartRef@@ABE_NXZ ; SmartRef::RiffIter::validate
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	74 08		 je	 SHORT $L69521

; 205  : 		return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	e9 85 00 00 00	 jmp	 $L69520
$L69521:

; 206  : 
; 207  : 	m_hr = m_pIDMStream->Ascend(&m_ckChild, 0);

  00020	6a 00		 push	 0
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 21	 add	 ecx, 33			; 00000021H
  00028	51		 push	 ecx
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	52		 push	 edx
  00038	ff 50 14	 call	 DWORD PTR [eax+20]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 01		 mov	 DWORD PTR [ecx], eax

; 208  : 	if (FAILED(m_hr))

  00040	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00043	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00046	7d 05		 jge	 SHORT $L69523

; 209  : 		return *this;

  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 58		 jmp	 SHORT $L69520
$L69523:

; 210  : 
; 211  : 	m_ckChild.ckid = 0;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	c7 40 21 00 00
	00 00		 mov	 DWORD PTR [eax+33], 0

; 212  : 	m_ckChild.fccType = 0;

  00057	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	c7 41 29 00 00
	00 00		 mov	 DWORD PTR [ecx+41], 0

; 213  : 	m_hr = m_pIDMStream->Descend(&m_ckChild, m_fParent ? &m_ckParent : NULL, 0);

  00061	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00064	0f b6 42 0c	 movzx	 eax, BYTE PTR [edx+12]
  00068	85 c0		 test	 eax, eax
  0006a	74 0b		 je	 SHORT $L70308
  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00072	89 4d f8	 mov	 DWORD PTR tv129[ebp], ecx
  00075	eb 07		 jmp	 SHORT $L70309
$L70308:
  00077	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
$L70309:
  0007e	6a 00		 push	 0
  00080	8b 55 f8	 mov	 edx, DWORD PTR tv129[ebp]
  00083	52		 push	 edx
  00084	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00087	83 c0 21	 add	 eax, 33			; 00000021H
  0008a	50		 push	 eax
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00097	8b 12		 mov	 edx, DWORD PTR [edx]
  00099	51		 push	 ecx
  0009a	ff 52 10	 call	 DWORD PTR [edx+16]
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	89 01		 mov	 DWORD PTR [ecx], eax

; 214  : 	return *this;

  000a2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$L69520:

; 215  : }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
??ERiffIter@SmartRef@@QAEAAV01@XZ ENDP			; SmartRef::RiffIter::operator++
_TEXT	ENDS
PUBLIC	?Find@RiffIter@SmartRef@@QAEAAV12@W4RiffType@12@K@Z ; SmartRef::RiffIter::Find
PUBLIC	??BRiffIter@SmartRef@@QBE_NXZ			; SmartRef::RiffIter::operator bool
PUBLIC	?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ	; SmartRef::RiffIter::type
PUBLIC	?id@RiffIter@SmartRef@@QBEKXZ			; SmartRef::RiffIter::id
; Function compile flags: /Odt
;	COMDAT ?Find@RiffIter@SmartRef@@QAEAAV12@W4RiffType@12@K@Z
_TEXT	SEGMENT
tv78 = -5
_this$ = -4
_t$ = 8
_idFind$ = 12
?Find@RiffIter@SmartRef@@QAEAAV12@W4RiffType@12@K@Z PROC NEAR ; SmartRef::RiffIter::Find, COMDAT
; _this$ = ecx

; 219  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 	if (validate())

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?validate@RiffIter@SmartRef@@ABE_NXZ ; SmartRef::RiffIter::validate
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	74 05		 je	 SHORT $L69531

; 221  : 		return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	eb 48		 jmp	 SHORT $L69528
$L69531:

; 222  : 
; 223  : 	while (*this && (type() != t || id() != idFind))

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  00025	0f b6 c8	 movzx	 ecx, al
  00028	85 c9		 test	 ecx, ecx
  0002a	74 36		 je	 SHORT $L69532
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ ; SmartRef::RiffIter::type
  00034	3b 45 08	 cmp	 eax, DWORD PTR _t$[ebp]
  00037	75 13		 jne	 SHORT $L70313
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?id@RiffIter@SmartRef@@QBEKXZ ; SmartRef::RiffIter::id
  00041	3b 45 0c	 cmp	 eax, DWORD PTR _idFind$[ebp]
  00044	75 06		 jne	 SHORT $L70313
  00046	c6 45 fb 00	 mov	 BYTE PTR tv78[ebp], 0
  0004a	eb 04		 jmp	 SHORT $L70314
$L70313:
  0004c	c6 45 fb 01	 mov	 BYTE PTR tv78[ebp], 1
$L70314:
  00050	0f b6 55 fb	 movzx	 edx, BYTE PTR tv78[ebp]
  00054	85 d2		 test	 edx, edx
  00056	74 0a		 je	 SHORT $L69532

; 224  : 		++*this;

  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ??ERiffIter@SmartRef@@QAEAAV01@XZ ; SmartRef::RiffIter::operator++
  00060	eb bb		 jmp	 SHORT $L69531
$L69532:

; 225  : 
; 226  : 	return *this;

  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$L69528:

; 227  : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8
?Find@RiffIter@SmartRef@@QAEAAV12@W4RiffType@12@K@Z ENDP ; SmartRef::RiffIter::Find
_TEXT	ENDS
PUBLIC	?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z	; SmartRef::RiffIter::ReadChunk
PUBLIC	?min@std@@YGABKABK0@Z				; std::min
PUBLIC	??_C@_0BN@NGDBOKBB@Error?3?5Unable?5to?5read?5file?4?6?$AA@ ; `string'
EXTRN	?DebugTrace@@YAXHPADZZ:NEAR			; DebugTrace
;	COMDAT ??_C@_0BN@NGDBOKBB@Error?3?5Unable?5to?5read?5file?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@NGDBOKBB@Error?3?5Unable?5to?5read?5file?4?6?$AA@ DB 'Error: Un'
	DB	'able to read file.', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z
_TEXT	SEGMENT
_this$ = -20
$T70319 = -16
_hr$ = -12
_cbRead$ = -8
_cbSize$ = -4
_pv$ = 8
_cb$ = 12
?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z PROC NEAR	; SmartRef::RiffIter::ReadChunk, COMDAT
; _this$ = ecx

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 234  : 	if (type() != Chunk)

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ ; SmartRef::RiffIter::type
  00011	83 f8 02	 cmp	 eax, 2
  00014	74 21		 je	 SHORT $L69538

; 235  : 	{
; 236  : 		assert(false);

  00016	33 c0		 xor	 eax, eax
  00018	85 c0		 test	 eax, eax
  0001a	75 14		 jne	 SHORT $L70318
  0001c	68 ec 00 00 00	 push	 236			; 000000ecH
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
  00026	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
  0002b	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70318:

; 237  : 		return DMUS_E_CANNOTREAD;

  00030	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00035	eb 7c		 jmp	 SHORT $L69537
$L69538:

; 238  : 	}
; 239  : 
; 240  : 	ZeroMemory(pv, cb);

  00037	8b 55 0c	 mov	 edx, DWORD PTR _cb$[ebp]
  0003a	52		 push	 edx
  0003b	6a 00		 push	 0
  0003d	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _memset
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 241  : 	DWORD cbRead = 0;

  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cbRead$[ebp], 0

; 242  : 	DWORD cbSize = std::_cpp_min<DWORD>(cb, m_ckChild.cksize);

  00050	8b 4d 0c	 mov	 ecx, DWORD PTR _cb$[ebp]
  00053	89 4d f0	 mov	 DWORD PTR $T70319[ebp], ecx
  00056	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 25	 add	 edx, 37			; 00000025H
  0005c	52		 push	 edx
  0005d	8d 45 f0	 lea	 eax, DWORD PTR $T70319[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ?min@std@@YGABKABK0@Z	; std::min
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	89 4d fc	 mov	 DWORD PTR _cbSize$[ebp], ecx

; 243  : 	HRESULT hr = m_pIStream->Read(pv, cbSize, &cbRead);

  0006b	8d 55 f8	 lea	 edx, DWORD PTR _cbRead$[ebp]
  0006e	52		 push	 edx
  0006f	8b 45 fc	 mov	 eax, DWORD PTR _cbSize$[ebp]
  00072	50		 push	 eax
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _pv$[ebp]
  00076	51		 push	 ecx
  00077	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]
  00085	52		 push	 edx
  00086	ff 50 0c	 call	 DWORD PTR [eax+12]
  00089	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 244  : 	if (FAILED(hr) || cbRead != cbSize)

  0008c	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00090	7c 08		 jl	 SHORT $L69552
  00092	8b 4d f8	 mov	 ecx, DWORD PTR _cbRead$[ebp]
  00095	3b 4d fc	 cmp	 ecx, DWORD PTR _cbSize$[ebp]
  00098	74 16		 je	 SHORT $L69551
$L69552:

; 245  : 	{
; 246  : 		Trace(1, "Error: Unable to read file.\n");

  0009a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@NGDBOKBB@Error?3?5Unable?5to?5read?5file?4?6?$AA@
  0009f	6a 01		 push	 1
  000a1	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a6	83 c4 08	 add	 esp, 8

; 247  : 		hr = DMUS_E_CANNOTREAD;

  000a9	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L69551:

; 248  : 	}
; 249  : 	return hr;

  000b0	8b 45 f4	 mov	 eax, DWORD PTR _hr$[ebp]
$L69537:

; 250  : }

  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 08 00	 ret	 8
?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z ENDP		; SmartRef::RiffIter::ReadChunk
_TEXT	ENDS
PUBLIC	?size@RiffIter@SmartRef@@QBEKXZ			; SmartRef::RiffIter::size
PUBLIC	?ReadArrayChunk@RiffIter@SmartRef@@QAEJKPAPAXPAH@Z ; SmartRef::RiffIter::ReadArrayChunk
PUBLIC	?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAK@Z ; SmartRef::RiffIterReadChunk
PUBLIC	??0?$PtrArray@D@SmartRef@@QAE@PAD@Z		; SmartRef::PtrArray<char>::PtrArray<char>
PUBLIC	??1?$PtrArray@D@SmartRef@@QAE@XZ		; SmartRef::PtrArray<char>::~PtrArray<char>
PUBLIC	??B?$PtrArray@D@SmartRef@@QAEPADXZ		; SmartRef::PtrArray<char>::operator char *
PUBLIC	?disown@?$PtrArray@D@SmartRef@@QAEPADXZ		; SmartRef::PtrArray<char>::disown
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt
;	COMDAT ?ReadArrayChunk@RiffIter@SmartRef@@QAEJKPAPAXPAH@Z
_TEXT	SEGMENT
_this$ = -64
$T70330 = -60
$T70329 = -56
$T70328 = -52
$T70327 = -48
$T70326 = -44
$T70325 = -40
_pOut$69615 = -36
_pRec$69613 = -32
_pArray$69607 = -28
_pEnd$69614 = -24
_cbChunkRecord$ = -20
_hr$ = -16
_cbChunk$ = -12
_cRecords$ = -8
_sprgChunk$ = -4
_cbSize$ = 8
_ppv$ = 12
_pcRecords$ = 16
?ReadArrayChunk@RiffIter@SmartRef@@QAEJKPAPAXPAH@Z PROC NEAR ; SmartRef::RiffIter::ReadArrayChunk, COMDAT
; _this$ = ecx

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx

; 258  : 	// zero the out params
; 259  : 	*ppv = NULL;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _ppv$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 260  : 	*pcRecords = 0;

  00012	8b 4d 10	 mov	 ecx, DWORD PTR _pcRecords$[ebp]
  00015	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 261  : 
; 262  : 	// get the size of the chunk and its records
; 263  : 
; 264  : 	UINT cbChunk = size();

  0001b	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?size@RiffIter@SmartRef@@QBEKXZ ; SmartRef::RiffIter::size
  00023	89 45 f4	 mov	 DWORD PTR _cbChunk$[ebp], eax

; 265  : 	if (cbChunk < sizeof(DWORD))

  00026	83 7d f4 04	 cmp	 DWORD PTR _cbChunk$[ebp], 4
  0002a	73 24		 jae	 SHORT $L69563

; 266  : 	{
; 267  : 		assert(false);

  0002c	33 d2		 xor	 edx, edx
  0002e	85 d2		 test	 edx, edx
  00030	75 14		 jne	 SHORT $L70323
  00032	68 0b 01 00 00	 push	 267			; 0000010bH
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
  00041	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70323:

; 268  : 		return E_FAIL;

  00046	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0004b	e9 be 01 00 00	 jmp	 $L69560
$L69563:

; 269  : 	}
; 270  : 
; 271  : 	DWORD cbChunkRecord = 0;

  00050	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _cbChunkRecord$[ebp], 0

; 272  : 	HRESULT hr = RiffIterReadChunk(*this, &cbChunkRecord);

  00057	8d 4d ec	 lea	 ecx, DWORD PTR _cbChunkRecord$[ebp]
  0005a	51		 push	 ecx
  0005b	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAK@Z ; SmartRef::RiffIterReadChunk
  00064	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 273  : 	if (FAILED(hr))

  00067	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006b	7d 08		 jge	 SHORT $L69574

; 274  : 		return hr;

  0006d	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  00070	e9 99 01 00 00	 jmp	 $L69560
$L69574:

; 275  : 	cbChunk -= sizeof(DWORD);

  00075	8b 45 f4	 mov	 eax, DWORD PTR _cbChunk$[ebp]
  00078	83 e8 04	 sub	 eax, 4
  0007b	89 45 f4	 mov	 DWORD PTR _cbChunk$[ebp], eax

; 276  : 
; 277  : 	if (cbChunk % cbChunkRecord != 0)

  0007e	8b 45 f4	 mov	 eax, DWORD PTR _cbChunk$[ebp]
  00081	33 d2		 xor	 edx, edx
  00083	f7 75 ec	 div	 DWORD PTR _cbChunkRecord$[ebp]
  00086	85 d2		 test	 edx, edx
  00088	74 24		 je	 SHORT $L69576

; 278  : 	{
; 279  : 		// array is not divisible by size of records!
; 280  : 		assert(false);

  0008a	33 c9		 xor	 ecx, ecx
  0008c	85 c9		 test	 ecx, ecx
  0008e	75 14		 jne	 SHORT $L70324
  00090	68 18 01 00 00	 push	 280			; 00000118H
  00095	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
  0009a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
  0009f	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70324:

; 281  : 		return E_FAIL;

  000a4	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  000a9	e9 60 01 00 00	 jmp	 $L69560
$L69576:

; 282  : 	}
; 283  : 
; 284  : 	UINT cRecords = cbChunk / cbChunkRecord;

  000ae	8b 45 f4	 mov	 eax, DWORD PTR _cbChunk$[ebp]
  000b1	33 d2		 xor	 edx, edx
  000b3	f7 75 ec	 div	 DWORD PTR _cbChunkRecord$[ebp]
  000b6	89 45 f8	 mov	 DWORD PTR _cRecords$[ebp], eax

; 285  : 
; 286  : 	// Get the whole rest of the chunk
; 287  : 	PtrArray<char> sprgChunk = new char[cbChunk];

  000b9	8b 45 f4	 mov	 eax, DWORD PTR _cbChunk$[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000c2	83 c4 04	 add	 esp, 4
  000c5	89 45 d8	 mov	 DWORD PTR $T70325[ebp], eax
  000c8	8b 4d d8	 mov	 ecx, DWORD PTR $T70325[ebp]
  000cb	51		 push	 ecx
  000cc	8d 4d fc	 lea	 ecx, DWORD PTR _sprgChunk$[ebp]
  000cf	e8 00 00 00 00	 call	 ??0?$PtrArray@D@SmartRef@@QAE@PAD@Z ; SmartRef::PtrArray<char>::PtrArray<char>

; 288  : 	if (!sprgChunk)

  000d4	8d 4d fc	 lea	 ecx, DWORD PTR _sprgChunk$[ebp]
  000d7	e8 00 00 00 00	 call	 ??B?$PtrArray@D@SmartRef@@QAEPADXZ ; SmartRef::PtrArray<char>::operator char *
  000dc	85 c0		 test	 eax, eax
  000de	75 17		 jne	 SHORT $L69599

; 289  : 		return E_OUTOFMEMORY;

  000e0	c7 45 d4 0e 00
	07 80		 mov	 DWORD PTR $T70326[ebp], -2147024882 ; 8007000eH
  000e7	8d 4d fc	 lea	 ecx, DWORD PTR _sprgChunk$[ebp]
  000ea	e8 00 00 00 00	 call	 ??1?$PtrArray@D@SmartRef@@QAE@XZ ; SmartRef::PtrArray<char>::~PtrArray<char>
  000ef	8b 45 d4	 mov	 eax, DWORD PTR $T70326[ebp]
  000f2	e9 17 01 00 00	 jmp	 $L69560
$L69599:

; 290  : 	hr = ReadChunk(sprgChunk, cbChunk);

  000f7	8b 55 f4	 mov	 edx, DWORD PTR _cbChunk$[ebp]
  000fa	52		 push	 edx
  000fb	8d 4d fc	 lea	 ecx, DWORD PTR _sprgChunk$[ebp]
  000fe	e8 00 00 00 00	 call	 ??B?$PtrArray@D@SmartRef@@QAEPADXZ ; SmartRef::PtrArray<char>::operator char *
  00103	50		 push	 eax
  00104	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	e8 00 00 00 00	 call	 ?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z ; SmartRef::RiffIter::ReadChunk
  0010c	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 291  : 	if (FAILED(hr))

  0010f	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00113	7d 16		 jge	 SHORT $L69603

; 292  : 		return hr;

  00115	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  00118	89 45 d0	 mov	 DWORD PTR $T70327[ebp], eax
  0011b	8d 4d fc	 lea	 ecx, DWORD PTR _sprgChunk$[ebp]
  0011e	e8 00 00 00 00	 call	 ??1?$PtrArray@D@SmartRef@@QAE@XZ ; SmartRef::PtrArray<char>::~PtrArray<char>
  00123	8b 45 d0	 mov	 eax, DWORD PTR $T70327[ebp]
  00126	e9 e3 00 00 00	 jmp	 $L69560
$L69603:

; 293  : 
; 294  : 	// Return the chunk and its info.
; 295  : 
; 296  : 	if (cbChunkRecord == cbSize)

  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _cbChunkRecord$[ebp]
  0012e	3b 4d 08	 cmp	 ecx, DWORD PTR _cbSize$[ebp]
  00131	75 12		 jne	 SHORT $L69605

; 297  : 	{
; 298  : 		// Great!  Return the chunk as is.
; 299  : 		*ppv = sprgChunk.disown();

  00133	8d 4d fc	 lea	 ecx, DWORD PTR _sprgChunk$[ebp]
  00136	e8 00 00 00 00	 call	 ?disown@?$PtrArray@D@SmartRef@@QAEPADXZ ; SmartRef::PtrArray<char>::disown
  0013b	8b 55 0c	 mov	 edx, DWORD PTR _ppv$[ebp]
  0013e	89 02		 mov	 DWORD PTR [edx], eax

; 300  : 	}
; 301  : 	else

  00140	e9 b0 00 00 00	 jmp	 $L69606
$L69605:

; 302  : 	{
; 303  : 		// make an array of the requested size
; 304  : 		char *pArray = new char[cbSize * cRecords];

  00145	8b 45 08	 mov	 eax, DWORD PTR _cbSize$[ebp]
  00148	0f af 45 f8	 imul	 eax, DWORD PTR _cRecords$[ebp]
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00152	83 c4 04	 add	 esp, 4
  00155	89 45 cc	 mov	 DWORD PTR $T70328[ebp], eax
  00158	8b 4d cc	 mov	 ecx, DWORD PTR $T70328[ebp]
  0015b	89 4d e4	 mov	 DWORD PTR _pArray$69607[ebp], ecx

; 305  : 		if (!pArray)

  0015e	83 7d e4 00	 cmp	 DWORD PTR _pArray$69607[ebp], 0
  00162	75 17		 jne	 SHORT $L69610

; 306  : 			return E_OUTOFMEMORY;

  00164	c7 45 c8 0e 00
	07 80		 mov	 DWORD PTR $T70329[ebp], -2147024882 ; 8007000eH
  0016b	8d 4d fc	 lea	 ecx, DWORD PTR _sprgChunk$[ebp]
  0016e	e8 00 00 00 00	 call	 ??1?$PtrArray@D@SmartRef@@QAE@XZ ; SmartRef::PtrArray<char>::~PtrArray<char>
  00173	8b 45 c8	 mov	 eax, DWORD PTR $T70329[ebp]
  00176	e9 93 00 00 00	 jmp	 $L69560
$L69610:

; 307  : 		ZeroMemory(pArray, cbSize * cRecords);

  0017b	8b 55 08	 mov	 edx, DWORD PTR _cbSize$[ebp]
  0017e	0f af 55 f8	 imul	 edx, DWORD PTR _cRecords$[ebp]
  00182	52		 push	 edx
  00183	6a 00		 push	 0
  00185	8b 45 e4	 mov	 eax, DWORD PTR _pArray$69607[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 _memset
  0018e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 308  : 
; 309  : 		// copy each record
; 310  : 		char *pRec = sprgChunk; // iterate reading each record of the chunk

  00191	8d 4d fc	 lea	 ecx, DWORD PTR _sprgChunk$[ebp]
  00194	e8 00 00 00 00	 call	 ??B?$PtrArray@D@SmartRef@@QAEPADXZ ; SmartRef::PtrArray<char>::operator char *
  00199	89 45 e0	 mov	 DWORD PTR _pRec$69613[ebp], eax

; 311  : 		char *pEnd = pRec + cbChunkRecord * cRecords; // stop before this (nonexistant) record

  0019c	8b 4d ec	 mov	 ecx, DWORD PTR _cbChunkRecord$[ebp]
  0019f	0f af 4d f8	 imul	 ecx, DWORD PTR _cRecords$[ebp]
  001a3	8b 55 e0	 mov	 edx, DWORD PTR _pRec$69613[ebp]
  001a6	03 d1		 add	 edx, ecx
  001a8	89 55 e8	 mov	 DWORD PTR _pEnd$69614[ebp], edx

; 312  : 		char *pOut = pArray; // iterate writing into the array

  001ab	8b 45 e4	 mov	 eax, DWORD PTR _pArray$69607[ebp]
  001ae	89 45 dc	 mov	 DWORD PTR _pOut$69615[ebp], eax
$L69617:

; 313  : 		while (pRec < pEnd)

  001b1	8b 4d e0	 mov	 ecx, DWORD PTR _pRec$69613[ebp]
  001b4	3b 4d e8	 cmp	 ecx, DWORD PTR _pEnd$69614[ebp]
  001b7	73 34		 jae	 SHORT $L69618

; 314  : 		{
; 315  : 			memcpy(pOut, pRec, std::_cpp_min<DWORD>(cbChunkRecord, cbSize));

  001b9	8d 55 08	 lea	 edx, DWORD PTR _cbSize$[ebp]
  001bc	52		 push	 edx
  001bd	8d 45 ec	 lea	 eax, DWORD PTR _cbChunkRecord$[ebp]
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 ?min@std@@YGABKABK0@Z	; std::min
  001c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c8	51		 push	 ecx
  001c9	8b 55 e0	 mov	 edx, DWORD PTR _pRec$69613[ebp]
  001cc	52		 push	 edx
  001cd	8b 45 dc	 mov	 eax, DWORD PTR _pOut$69615[ebp]
  001d0	50		 push	 eax
  001d1	e8 00 00 00 00	 call	 _memcpy
  001d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 316  : 			pRec += cbChunkRecord;

  001d9	8b 4d e0	 mov	 ecx, DWORD PTR _pRec$69613[ebp]
  001dc	03 4d ec	 add	 ecx, DWORD PTR _cbChunkRecord$[ebp]
  001df	89 4d e0	 mov	 DWORD PTR _pRec$69613[ebp], ecx

; 317  : 			pOut += cbSize;

  001e2	8b 55 dc	 mov	 edx, DWORD PTR _pOut$69615[ebp]
  001e5	03 55 08	 add	 edx, DWORD PTR _cbSize$[ebp]
  001e8	89 55 dc	 mov	 DWORD PTR _pOut$69615[ebp], edx

; 318  : 		}

  001eb	eb c4		 jmp	 SHORT $L69617
$L69618:

; 319  : 		*ppv = pArray;

  001ed	8b 45 0c	 mov	 eax, DWORD PTR _ppv$[ebp]
  001f0	8b 4d e4	 mov	 ecx, DWORD PTR _pArray$69607[ebp]
  001f3	89 08		 mov	 DWORD PTR [eax], ecx
$L69606:

; 320  : 	}
; 321  : 
; 322  : 	*pcRecords = cRecords;

  001f5	8b 55 10	 mov	 edx, DWORD PTR _pcRecords$[ebp]
  001f8	8b 45 f8	 mov	 eax, DWORD PTR _cRecords$[ebp]
  001fb	89 02		 mov	 DWORD PTR [edx], eax

; 323  : 	return hr;

  001fd	8b 4d f0	 mov	 ecx, DWORD PTR _hr$[ebp]
  00200	89 4d c4	 mov	 DWORD PTR $T70330[ebp], ecx
  00203	8d 4d fc	 lea	 ecx, DWORD PTR _sprgChunk$[ebp]
  00206	e8 00 00 00 00	 call	 ??1?$PtrArray@D@SmartRef@@QAE@XZ ; SmartRef::PtrArray<char>::~PtrArray<char>
  0020b	8b 45 c4	 mov	 eax, DWORD PTR $T70330[ebp]
$L69560:

; 324  : }

  0020e	8b e5		 mov	 esp, ebp
  00210	5d		 pop	 ebp
  00211	c2 0c 00	 ret	 12			; 0000000cH
?ReadArrayChunk@RiffIter@SmartRef@@QAEJKPAPAXPAH@Z ENDP	; SmartRef::RiffIter::ReadArrayChunk
_TEXT	ENDS
PUBLIC	?ZeroAndSize@@YGXPAU_DMUS_OBJECTDESC@@@Z	; ZeroAndSize
PUBLIC	?hr@RiffIter@SmartRef@@QBEJXZ			; SmartRef::RiffIter::hr
PUBLIC	?FindAndGetEmbeddedObject@RiffIter@SmartRef@@QAEJW4RiffType@12@KJPAUIDirectMusicLoader@@ABU_GUID@@2PAPAX@Z ; SmartRef::RiffIter::FindAndGetEmbeddedObject
; Function compile flags: /Odt
;	COMDAT ?FindAndGetEmbeddedObject@RiffIter@SmartRef@@QAEJW4RiffType@12@KJPAUIDirectMusicLoader@@ABU_GUID@@2PAPAX@Z
_TEXT	SEGMENT
tv168 = -896
tv88 = -889
_this$ = -888
_punk$69655 = -884
_hrLoad$ = -880
_hrDescend$ = -876
_desc$ = -872
_ckLast$ = -20
_t$ = 8
_idFind$ = 12
_hrOnNotFound$ = 16
_pLoader$ = 20
_rclsid$ = 24
_riid$ = 28
_ppv$ = 32
?FindAndGetEmbeddedObject@RiffIter@SmartRef@@QAEJW4RiffType@12@KJPAUIDirectMusicLoader@@ABU_GUID@@2PAPAX@Z PROC NEAR ; SmartRef::RiffIter::FindAndGetEmbeddedObject, COMDAT
; _this$ = ecx

; 334  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 03 00
	00		 sub	 esp, 896		; 00000380H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	89 8d 88 fc ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 	if (validate() || !pLoader || !ppv)

  00011	8b 8d 88 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?validate@RiffIter@SmartRef@@ABE_NXZ ; SmartRef::RiffIter::validate
  0001c	0f b6 c0	 movzx	 eax, al
  0001f	85 c0		 test	 eax, eax
  00021	75 0c		 jne	 SHORT $L69635
  00023	83 7d 14 00	 cmp	 DWORD PTR _pLoader$[ebp], 0
  00027	74 06		 je	 SHORT $L69635
  00029	83 7d 20 00	 cmp	 DWORD PTR _ppv$[ebp], 0
  0002d	75 24		 jne	 SHORT $L69634
$L69635:

; 336  : 	{
; 337  : 		assert(false);

  0002f	33 c9		 xor	 ecx, ecx
  00031	85 c9		 test	 ecx, ecx
  00033	75 14		 jne	 SHORT $L70334
  00035	68 51 01 00 00	 push	 337			; 00000151H
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
  00044	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70334:

; 338  : 		return E_FAIL;

  00049	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0004e	e9 1c 02 00 00	 jmp	 $L69633
$L69634:

; 339  : 	}
; 340  : 
; 341  : 	*ppv = NULL;

  00053	8b 45 20	 mov	 eax, DWORD PTR _ppv$[ebp]
  00056	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 342  : 	MMCKINFO ckLast;
; 343  : 	ZeroMemory(&ckLast, sizeof(ckLast));

  0005c	6a 14		 push	 20			; 00000014H
  0005e	6a 00		 push	 0
  00060	8d 4d ec	 lea	 ecx, DWORD PTR _ckLast$[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 _memset
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
$L69640:

; 344  : 
; 345  : 	while (*this && (type() != t || id() != idFind))

  0006c	8b 8d 88 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  00077	0f b6 d0	 movzx	 edx, al
  0007a	85 d2		 test	 edx, edx
  0007c	74 5b		 je	 SHORT $L69641
  0007e	8b 8d 88 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ ; SmartRef::RiffIter::type
  00089	3b 45 08	 cmp	 eax, DWORD PTR _t$[ebp]
  0008c	75 19		 jne	 SHORT $L70335
  0008e	8b 8d 88 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?id@RiffIter@SmartRef@@QBEKXZ ; SmartRef::RiffIter::id
  00099	3b 45 0c	 cmp	 eax, DWORD PTR _idFind$[ebp]
  0009c	75 09		 jne	 SHORT $L70335
  0009e	c6 85 87 fc ff
	ff 00		 mov	 BYTE PTR tv88[ebp], 0
  000a5	eb 07		 jmp	 SHORT $L70336
$L70335:
  000a7	c6 85 87 fc ff
	ff 01		 mov	 BYTE PTR tv88[ebp], 1
$L70336:
  000ae	0f b6 85 87 fc
	ff ff		 movzx	 eax, BYTE PTR tv88[ebp]
  000b5	85 c0		 test	 eax, eax
  000b7	74 20		 je	 SHORT $L69641

; 346  : 	{
; 347  : 		ckLast = m_ckChild;

  000b9	8b b5 88 fc ff
	ff		 mov	 esi, DWORD PTR _this$[ebp]
  000bf	83 c6 21	 add	 esi, 33			; 00000021H
  000c2	b9 05 00 00 00	 mov	 ecx, 5
  000c7	8d 7d ec	 lea	 edi, DWORD PTR _ckLast$[ebp]
  000ca	f3 a5		 rep movsd

; 348  : 		++*this;

  000cc	8b 8d 88 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	e8 00 00 00 00	 call	 ??ERiffIter@SmartRef@@QAEAAV01@XZ ; SmartRef::RiffIter::operator++

; 349  : 	}

  000d7	eb 93		 jmp	 SHORT $L69640
$L69641:

; 350  : 
; 351  : 	if (!*this)

  000d9	8b 8d 88 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000df	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  000e4	0f b6 c8	 movzx	 ecx, al
  000e7	85 c9		 test	 ecx, ecx
  000e9	75 08		 jne	 SHORT $L69642

; 352  : 		return hrOnNotFound;

  000eb	8b 45 10	 mov	 eax, DWORD PTR _hrOnNotFound$[ebp]
  000ee	e9 7c 01 00 00	 jmp	 $L69633
$L69642:

; 353  : 
; 354  : 	// Ascend in such a way that the stream can be used to find this chunk.
; 355  : 	m_hr = m_pIDMStream->Ascend(&ckLast, 0);

  000f3	6a 00		 push	 0
  000f5	8d 55 ec	 lea	 edx, DWORD PTR _ckLast$[ebp]
  000f8	52		 push	 edx
  000f9	8b 85 88 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000ff	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00102	8b 95 88 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00108	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0010b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0010d	50		 push	 eax
  0010e	ff 51 14	 call	 DWORD PTR [ecx+20]
  00111	8b 95 88 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00117	89 02		 mov	 DWORD PTR [edx], eax

; 356  : 	if (FAILED(m_hr))

  00119	8b 85 88 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0011f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00122	7d 0d		 jge	 SHORT $L69644

; 357  : 		return m_hr;

  00124	8b 8d 88 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0012c	e9 3e 01 00 00	 jmp	 $L69633
$L69644:

; 358  : 
; 359  : 	// Call GetObject using the stream
; 360  : 	DMUS_OBJECTDESC desc;
; 361  : 	ZeroAndSize(&desc);

  00131	8d 95 98 fc ff
	ff		 lea	 edx, DWORD PTR _desc$[ebp]
  00137	52		 push	 edx
  00138	e8 00 00 00 00	 call	 ?ZeroAndSize@@YGXPAU_DMUS_OBJECTDESC@@@Z ; ZeroAndSize

; 362  : 	desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;

  0013d	c7 85 9c fc ff
	ff 02 08 00 00	 mov	 DWORD PTR _desc$[ebp+4], 2050 ; 00000802H

; 363  : 	desc.guidClass = rclsid;

  00147	8b 45 18	 mov	 eax, DWORD PTR _rclsid$[ebp]
  0014a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014c	89 8d b0 fc ff
	ff		 mov	 DWORD PTR _desc$[ebp+24], ecx
  00152	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00155	89 95 b4 fc ff
	ff		 mov	 DWORD PTR _desc$[ebp+28], edx
  0015b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0015e	89 8d b8 fc ff
	ff		 mov	 DWORD PTR _desc$[ebp+32], ecx
  00164	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00167	89 95 bc fc ff
	ff		 mov	 DWORD PTR _desc$[ebp+36], edx

; 364  : 	desc.pStream = m_pIStream;

  0016d	8b 85 88 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00173	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00176	89 4d e4	 mov	 DWORD PTR _desc$[ebp+844], ecx

; 365  : 	HRESULT hrLoad = pLoader->GetObject(&desc, riid, ppv);

  00179	8b 55 20	 mov	 edx, DWORD PTR _ppv$[ebp]
  0017c	52		 push	 edx
  0017d	8b 45 1c	 mov	 eax, DWORD PTR _riid$[ebp]
  00180	50		 push	 eax
  00181	8d 8d 98 fc ff
	ff		 lea	 ecx, DWORD PTR _desc$[ebp]
  00187	51		 push	 ecx
  00188	8b 55 14	 mov	 edx, DWORD PTR _pLoader$[ebp]
  0018b	8b 02		 mov	 eax, DWORD PTR [edx]
  0018d	8b 4d 14	 mov	 ecx, DWORD PTR _pLoader$[ebp]
  00190	51		 push	 ecx
  00191	ff 50 0c	 call	 DWORD PTR [eax+12]
  00194	89 85 90 fc ff
	ff		 mov	 DWORD PTR _hrLoad$[ebp], eax

; 366  : 
; 367  : 	// Descend again to leave the stream at the next chunk
; 368  : 	m_ckChild.ckid = 0;

  0019a	8b 95 88 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001a0	c7 42 21 00 00
	00 00		 mov	 DWORD PTR [edx+33], 0

; 369  : 	m_ckChild.fccType = 0;

  001a7	8b 85 88 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001ad	c7 40 29 00 00
	00 00		 mov	 DWORD PTR [eax+41], 0

; 370  : 	m_hr = m_pIDMStream->Descend(&m_ckChild, m_fParent ? &m_ckParent : NULL, 0);

  001b4	8b 8d 88 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001ba	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  001be	85 d2		 test	 edx, edx
  001c0	74 11		 je	 SHORT $L70337
  001c2	8b 85 88 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001c8	83 c0 0d	 add	 eax, 13			; 0000000dH
  001cb	89 85 80 fc ff
	ff		 mov	 DWORD PTR tv168[ebp], eax
  001d1	eb 0a		 jmp	 SHORT $L70338
$L70337:
  001d3	c7 85 80 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv168[ebp], 0
$L70338:
  001dd	6a 00		 push	 0
  001df	8b 8d 80 fc ff
	ff		 mov	 ecx, DWORD PTR tv168[ebp]
  001e5	51		 push	 ecx
  001e6	8b 95 88 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001ec	83 c2 21	 add	 edx, 33			; 00000021H
  001ef	52		 push	 edx
  001f0	8b 85 88 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001f6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001f9	8b 95 88 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001ff	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00202	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00204	50		 push	 eax
  00205	ff 51 10	 call	 DWORD PTR [ecx+16]
  00208	8b 95 88 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0020e	89 02		 mov	 DWORD PTR [edx], eax

; 371  : 
; 372  : 	HRESULT hrDescend = this->hr();

  00210	8b 8d 88 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00216	e8 00 00 00 00	 call	 ?hr@RiffIter@SmartRef@@QBEJXZ ; SmartRef::RiffIter::hr
  0021b	89 85 94 fc ff
	ff		 mov	 DWORD PTR _hrDescend$[ebp], eax

; 373  : 	if (FAILED(hrDescend))

  00221	83 bd 94 fc ff
	ff 00		 cmp	 DWORD PTR _hrDescend$[ebp], 0
  00228	7d 3f		 jge	 SHORT $L69653

; 374  : 	{
; 375  : 		// Give precedence to reporting failure in the stream even though getting the
; 376  : 		// object succeeded before the failure.
; 377  : 		if (*ppv)

  0022a	8b 45 20	 mov	 eax, DWORD PTR _ppv$[ebp]
  0022d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00230	74 2f		 je	 SHORT $L69654

; 378  : 		{
; 379  : 			IUnknown *punk = static_cast<IUnknown *>(*ppv);

  00232	8b 4d 20	 mov	 ecx, DWORD PTR _ppv$[ebp]
  00235	8b 11		 mov	 edx, DWORD PTR [ecx]
  00237	89 95 8c fc ff
	ff		 mov	 DWORD PTR _punk$69655[ebp], edx

; 380  : 			if (punk)

  0023d	83 bd 8c fc ff
	ff 00		 cmp	 DWORD PTR _punk$69655[ebp], 0
  00244	74 12		 je	 SHORT $L69657

; 381  : 				punk->Release();

  00246	8b 85 8c fc ff
	ff		 mov	 eax, DWORD PTR _punk$69655[ebp]
  0024c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024e	8b 95 8c fc ff
	ff		 mov	 edx, DWORD PTR _punk$69655[ebp]
  00254	52		 push	 edx
  00255	ff 51 08	 call	 DWORD PTR [ecx+8]
$L69657:

; 382  : 			*ppv = NULL;

  00258	8b 45 20	 mov	 eax, DWORD PTR _ppv$[ebp]
  0025b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L69654:

; 383  : 		}
; 384  : 		return hrDescend;

  00261	8b 85 94 fc ff
	ff		 mov	 eax, DWORD PTR _hrDescend$[ebp]
  00267	eb 06		 jmp	 SHORT $L69633
$L69653:

; 385  : 	}
; 386  : 	else
; 387  : 	{
; 388  : 		return hrLoad;

  00269	8b 85 90 fc ff
	ff		 mov	 eax, DWORD PTR _hrLoad$[ebp]
$L69633:

; 389  : 	}
; 390  : }

  0026f	5f		 pop	 edi
  00270	5e		 pop	 esi
  00271	8b e5		 mov	 esp, ebp
  00273	5d		 pop	 ebp
  00274	c2 1c 00	 ret	 28			; 0000001cH
?FindAndGetEmbeddedObject@RiffIter@SmartRef@@QAEJW4RiffType@12@KJPAUIDirectMusicLoader@@ABU_GUID@@2PAPAX@Z ENDP ; SmartRef::RiffIter::FindAndGetEmbeddedObject
_TEXT	ENDS
PUBLIC	??_C@_0DL@JPKKDAMM@this?9?$DOtype?$CI?$CJ?5?$DN?$DN?5List?5?$CG?$CG?5this?9?$DOid@ ; `string'
PUBLIC	?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_REFERENCE@@@Z ; SmartRef::RiffIterReadChunk
PUBLIC	?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_GUID@@@Z ; SmartRef::RiffIterReadChunk
PUBLIC	?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_FILETIME@@@Z ; SmartRef::RiffIterReadChunk
PUBLIC	?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAY0EA@G@Z ; SmartRef::RiffIterReadChunk
PUBLIC	?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAY0BAE@G@Z ; SmartRef::RiffIterReadChunk
PUBLIC	?Descend@RiffIter@SmartRef@@QAE?AV12@XZ		; SmartRef::RiffIter::Descend
PUBLIC	?ReadReference@RiffIter@SmartRef@@QAEJPAU_DMUS_OBJECTDESC@@@Z ; SmartRef::RiffIter::ReadReference
PUBLIC	?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_VERSION@@@Z ; SmartRef::RiffIterReadChunk
;	COMDAT ??_C@_0DL@JPKKDAMM@this?9?$DOtype?$CI?$CJ?5?$DN?$DN?5List?5?$CG?$CG?5this?9?$DOid@
CONST	SEGMENT
??_C@_0DL@JPKKDAMM@this?9?$DOtype?$CI?$CJ?5?$DN?$DN?5List?5?$CG?$CG?5this?9?$DOid@ DB 't'
	DB	'his->type() == List && this->id() == DMUS_FOURCC_REF_LIST', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ReadReference@RiffIter@SmartRef@@QAEJPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT
tv86 = -96
_this$ = -92
_ioDMRef$69696 = -88
_ioDMObjVer$69792 = -68
_ri$69678 = -60
_hr$ = -4
_pDESC$ = 8
?ReadReference@RiffIter@SmartRef@@QAEJPAU_DMUS_OBJECTDESC@@@Z PROC NEAR ; SmartRef::RiffIter::ReadReference, COMDAT
; _this$ = ecx

; 394  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	89 4d a4	 mov	 DWORD PTR _this$[ebp], ecx

; 395  : 	HRESULT hr = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 396  : 
; 397  : 	assert(this->type() == List && this->id() == DMUS_FOURCC_REF_LIST);

  00010	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ ; SmartRef::RiffIter::type
  00018	83 f8 01	 cmp	 eax, 1
  0001b	75 0f		 jne	 SHORT $L70342
  0001d	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?id@RiffIter@SmartRef@@QBEKXZ ; SmartRef::RiffIter::id
  00025	3d 44 4d 52 46	 cmp	 eax, 1179798852		; 46524d44H
  0002a	74 14		 je	 SHORT $L70343
$L70342:
  0002c	68 8d 01 00 00	 push	 397			; 0000018dH
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
  00036	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DL@JPKKDAMM@this?9?$DOtype?$CI?$CJ?5?$DN?$DN?5List?5?$CG?$CG?5this?9?$DOid@
  0003b	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70343:

; 398  : 
; 399  : 	ZeroAndSize(pDESC);

  00040	8b 4d 08	 mov	 ecx, DWORD PTR _pDESC$[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 ?ZeroAndSize@@YGXPAU_DMUS_OBJECTDESC@@@Z ; ZeroAndSize

; 400  : 
; 401  : 	for (RiffIter ri = this->Descend(); ri; ++ri)

  00049	8d 55 c4	 lea	 edx, DWORD PTR _ri$69678[ebp]
  0004c	52		 push	 edx
  0004d	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?Descend@RiffIter@SmartRef@@QAE?AV12@XZ ; SmartRef::RiffIter::Descend
  00055	eb 08		 jmp	 SHORT $L69680
$L69681:
  00057	8d 4d c4	 lea	 ecx, DWORD PTR _ri$69678[ebp]
  0005a	e8 00 00 00 00	 call	 ??ERiffIter@SmartRef@@QAEAAV01@XZ ; SmartRef::RiffIter::operator++
$L69680:
  0005f	8d 4d c4	 lea	 ecx, DWORD PTR _ri$69678[ebp]
  00062	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  00067	0f b6 c0	 movzx	 eax, al
  0006a	85 c0		 test	 eax, eax
  0006c	0f 84 f6 01 00
	00		 je	 $L69682

; 402  : 	{
; 403  : 		switch (ri.id())
; 404  : 		{

  00072	8d 4d c4	 lea	 ecx, DWORD PTR _ri$69678[ebp]
  00075	e8 00 00 00 00	 call	 ?id@RiffIter@SmartRef@@QBEKXZ ; SmartRef::RiffIter::id
  0007a	89 45 a0	 mov	 DWORD PTR tv86[ebp], eax
  0007d	81 7d a0 64 61
	74 65		 cmp	 DWORD PTR tv86[ebp], 1702125924 ; 65746164H
  00084	77 39		 ja	 SHORT $L70344
  00086	81 7d a0 64 61
	74 65		 cmp	 DWORD PTR tv86[ebp], 1702125924 ; 65746164H
  0008d	0f 84 d7 00 00
	00		 je	 $L69728
  00093	81 7d a0 67 75
	69 64		 cmp	 DWORD PTR tv86[ebp], 1684632935 ; 64697567H
  0009a	0f 84 9d 00 00
	00		 je	 $L69712
  000a0	81 7d a0 66 69
	6c 65		 cmp	 DWORD PTR tv86[ebp], 1701603686 ; 656c6966H
  000a7	0f 84 1a 01 00
	00		 je	 $L69760
  000ad	81 7d a0 6e 61
	6d 65		 cmp	 DWORD PTR tv86[ebp], 1701667182 ; 656d616eH
  000b4	0f 84 e0 00 00
	00		 je	 $L69744
  000ba	e9 a4 01 00 00	 jmp	 $L69684
$L70344:
  000bf	81 7d a0 63 61
	74 67		 cmp	 DWORD PTR tv86[ebp], 1735680355 ; 67746163H
  000c6	0f 84 27 01 00
	00		 je	 $L69776
  000cc	81 7d a0 72 65
	66 68		 cmp	 DWORD PTR tv86[ebp], 1751541106 ; 68666572H
  000d3	74 12		 je	 SHORT $L69695
  000d5	81 7d a0 76 65
	72 73		 cmp	 DWORD PTR tv86[ebp], 1936876918 ; 73726576H
  000dc	0f 84 3e 01 00
	00		 je	 $L69791
  000e2	e9 7c 01 00 00	 jmp	 $L69684
$L69695:

; 405  : 			case  DMUS_FOURCC_REF_CHUNK:
; 406  : 				DMUS_IO_REFERENCE ioDMRef;
; 407  : 				hr = SmartRef::RiffIterReadChunk(ri, &ioDMRef);

  000e7	8d 4d a8	 lea	 ecx, DWORD PTR _ioDMRef$69696[ebp]
  000ea	51		 push	 ecx
  000eb	8d 55 c4	 lea	 edx, DWORD PTR _ri$69678[ebp]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_REFERENCE@@@Z ; SmartRef::RiffIterReadChunk
  000f4	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 408  : 				if (SUCCEEDED(hr))

  000f7	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000fb	7c 3b		 jl	 SHORT $L69703

; 409  : 				{
; 410  : 					pDESC->guidClass = ioDMRef.guidClassID;

  000fd	8b 45 08	 mov	 eax, DWORD PTR _pDESC$[ebp]
  00100	83 c0 18	 add	 eax, 24			; 00000018H
  00103	8b 4d a8	 mov	 ecx, DWORD PTR _ioDMRef$69696[ebp]
  00106	89 08		 mov	 DWORD PTR [eax], ecx
  00108	8b 55 ac	 mov	 edx, DWORD PTR _ioDMRef$69696[ebp+4]
  0010b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0010e	8b 4d b0	 mov	 ecx, DWORD PTR _ioDMRef$69696[ebp+8]
  00111	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00114	8b 55 b4	 mov	 edx, DWORD PTR _ioDMRef$69696[ebp+12]
  00117	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 411  : 					pDESC->dwValidData |= ioDMRef.dwValidData;

  0011a	8b 45 08	 mov	 eax, DWORD PTR _pDESC$[ebp]
  0011d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00120	0b 4d b8	 or	 ecx, DWORD PTR _ioDMRef$69696[ebp+16]
  00123	8b 55 08	 mov	 edx, DWORD PTR _pDESC$[ebp]
  00126	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 412  : 					pDESC->dwValidData |= DMUS_OBJ_CLASS;

  00129	8b 45 08	 mov	 eax, DWORD PTR _pDESC$[ebp]
  0012c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012f	83 c9 02	 or	 ecx, 2
  00132	8b 55 08	 mov	 edx, DWORD PTR _pDESC$[ebp]
  00135	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L69703:

; 413  : 				}
; 414  : 				break;

  00138	e9 26 01 00 00	 jmp	 $L69684
$L69712:

; 415  : 
; 416  : 			case DMUS_FOURCC_GUID_CHUNK:
; 417  : 				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->guidObject);

  0013d	8b 45 08	 mov	 eax, DWORD PTR _pDESC$[ebp]
  00140	83 c0 08	 add	 eax, 8
  00143	50		 push	 eax
  00144	8d 4d c4	 lea	 ecx, DWORD PTR _ri$69678[ebp]
  00147	51		 push	 ecx
  00148	e8 00 00 00 00	 call	 ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_GUID@@@Z ; SmartRef::RiffIterReadChunk
  0014d	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 418  : 				if (SUCCEEDED(hr))

  00150	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00154	7c 0f		 jl	 SHORT $L69719

; 419  : 					pDESC->dwValidData |=  DMUS_OBJ_OBJECT;

  00156	8b 55 08	 mov	 edx, DWORD PTR _pDESC$[ebp]
  00159	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0015c	83 c8 01	 or	 eax, 1
  0015f	8b 4d 08	 mov	 ecx, DWORD PTR _pDESC$[ebp]
  00162	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L69719:

; 420  : 				break;

  00165	e9 f9 00 00 00	 jmp	 $L69684
$L69728:

; 421  : 
; 422  : 			case DMUS_FOURCC_DATE_CHUNK:
; 423  : 				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->ftDate);

  0016a	8b 55 08	 mov	 edx, DWORD PTR _pDESC$[ebp]
  0016d	83 c2 28	 add	 edx, 40			; 00000028H
  00170	52		 push	 edx
  00171	8d 45 c4	 lea	 eax, DWORD PTR _ri$69678[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_FILETIME@@@Z ; SmartRef::RiffIterReadChunk
  0017a	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 424  : 				if (SUCCEEDED(hr))

  0017d	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00181	7c 12		 jl	 SHORT $L69735

; 425  : 					pDESC->dwValidData |=  DMUS_OBJ_DATE;

  00183	8b 4d 08	 mov	 ecx, DWORD PTR _pDESC$[ebp]
  00186	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00189	81 ca 00 01 00
	00		 or	 edx, 256		; 00000100H
  0018f	8b 45 08	 mov	 eax, DWORD PTR _pDESC$[ebp]
  00192	89 50 04	 mov	 DWORD PTR [eax+4], edx
$L69735:

; 426  : 				break;

  00195	e9 c9 00 00 00	 jmp	 $L69684
$L69744:

; 427  : 
; 428  : 			case DMUS_FOURCC_NAME_CHUNK:
; 429  : 				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszName);

  0019a	8b 4d 08	 mov	 ecx, DWORD PTR _pDESC$[ebp]
  0019d	83 c1 38	 add	 ecx, 56			; 00000038H
  001a0	51		 push	 ecx
  001a1	8d 55 c4	 lea	 edx, DWORD PTR _ri$69678[ebp]
  001a4	52		 push	 edx
  001a5	e8 00 00 00 00	 call	 ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAY0EA@G@Z ; SmartRef::RiffIterReadChunk
  001aa	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 430  : 				if (SUCCEEDED(hr))

  001ad	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001b1	7c 0f		 jl	 SHORT $L69751

; 431  : 					pDESC->dwValidData |=  DMUS_OBJ_NAME;

  001b3	8b 45 08	 mov	 eax, DWORD PTR _pDESC$[ebp]
  001b6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001b9	83 c9 04	 or	 ecx, 4
  001bc	8b 55 08	 mov	 edx, DWORD PTR _pDESC$[ebp]
  001bf	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L69751:

; 432  : 				break;

  001c2	e9 9c 00 00 00	 jmp	 $L69684
$L69760:

; 433  : 			
; 434  : 			case DMUS_FOURCC_FILE_CHUNK:
; 435  : 				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszFileName);

  001c7	8b 45 08	 mov	 eax, DWORD PTR _pDESC$[ebp]
  001ca	05 38 01 00 00	 add	 eax, 312		; 00000138H
  001cf	50		 push	 eax
  001d0	8d 4d c4	 lea	 ecx, DWORD PTR _ri$69678[ebp]
  001d3	51		 push	 ecx
  001d4	e8 00 00 00 00	 call	 ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAY0BAE@G@Z ; SmartRef::RiffIterReadChunk
  001d9	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 436  : 				if (SUCCEEDED(hr))

  001dc	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001e0	7c 0f		 jl	 SHORT $L69767

; 437  : 					pDESC->dwValidData |=  DMUS_OBJ_FILENAME;

  001e2	8b 55 08	 mov	 edx, DWORD PTR _pDESC$[ebp]
  001e5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001e8	83 c8 10	 or	 eax, 16			; 00000010H
  001eb	8b 4d 08	 mov	 ecx, DWORD PTR _pDESC$[ebp]
  001ee	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L69767:

; 438  : 				break;

  001f1	eb 70		 jmp	 SHORT $L69684
$L69776:

; 439  : 
; 440  : 			case DMUS_FOURCC_CATEGORY_CHUNK:
; 441  : 				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszCategory);

  001f3	8b 55 08	 mov	 edx, DWORD PTR _pDESC$[ebp]
  001f6	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  001fc	52		 push	 edx
  001fd	8d 45 c4	 lea	 eax, DWORD PTR _ri$69678[ebp]
  00200	50		 push	 eax
  00201	e8 00 00 00 00	 call	 ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAY0EA@G@Z ; SmartRef::RiffIterReadChunk
  00206	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 442  : 				if (SUCCEEDED(hr))

  00209	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0020d	7c 0f		 jl	 SHORT $L69782

; 443  : 					pDESC->dwValidData |=  DMUS_OBJ_CATEGORY;

  0020f	8b 4d 08	 mov	 ecx, DWORD PTR _pDESC$[ebp]
  00212	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00215	83 ca 08	 or	 edx, 8
  00218	8b 45 08	 mov	 eax, DWORD PTR _pDESC$[ebp]
  0021b	89 50 04	 mov	 DWORD PTR [eax+4], edx
$L69782:

; 444  : 				break;

  0021e	eb 43		 jmp	 SHORT $L69684
$L69791:

; 445  : 
; 446  : 			case DMUS_FOURCC_VERSION_CHUNK:
; 447  : 				DMUS_IO_VERSION ioDMObjVer;
; 448  : 				hr = SmartRef::RiffIterReadChunk(ri, &ioDMObjVer);

  00220	8d 4d bc	 lea	 ecx, DWORD PTR _ioDMObjVer$69792[ebp]
  00223	51		 push	 ecx
  00224	8d 55 c4	 lea	 edx, DWORD PTR _ri$69678[ebp]
  00227	52		 push	 edx
  00228	e8 00 00 00 00	 call	 ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_VERSION@@@Z ; SmartRef::RiffIterReadChunk
  0022d	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 449  : 				if (SUCCEEDED(hr))

  00230	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00234	7c 26		 jl	 SHORT $L69799

; 450  : 				{
; 451  : 					pDESC->vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;

  00236	8b 45 08	 mov	 eax, DWORD PTR _pDESC$[ebp]
  00239	8b 4d bc	 mov	 ecx, DWORD PTR _ioDMObjVer$69792[ebp]
  0023c	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 452  : 					pDESC->vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;

  0023f	8b 55 08	 mov	 edx, DWORD PTR _pDESC$[ebp]
  00242	8b 45 c0	 mov	 eax, DWORD PTR _ioDMObjVer$69792[ebp+4]
  00245	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 453  : 					pDESC->dwValidData |= DMUS_OBJ_VERSION;

  00248	8b 4d 08	 mov	 ecx, DWORD PTR _pDESC$[ebp]
  0024b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0024e	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  00254	8b 45 08	 mov	 eax, DWORD PTR _pDESC$[ebp]
  00257	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 454  : 				}
; 455  : 				else

  0025a	eb 07		 jmp	 SHORT $L69684
$L69799:

; 456  : 				{
; 457  : 					hr = E_FAIL;

  0025c	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L69684:

; 458  : 				}
; 459  : 				break;
; 460  : 
; 461  : 			default:
; 462  : 				break;
; 463  : 		}
; 464  : 	}

  00263	e9 ef fd ff ff	 jmp	 $L69681
$L69682:
  00268	8d 4d c4	 lea	 ecx, DWORD PTR _ri$69678[ebp]
  0026b	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter

; 465  : 	return ri.hr();

  00270	8d 4d c4	 lea	 ecx, DWORD PTR _ri$69678[ebp]
  00273	e8 00 00 00 00	 call	 ?hr@RiffIter@SmartRef@@QBEJXZ ; SmartRef::RiffIter::hr

; 466  : }

  00278	8b e5		 mov	 esp, ebp
  0027a	5d		 pop	 ebp
  0027b	c2 04 00	 ret	 4
?ReadReference@RiffIter@SmartRef@@QAEJPAU_DMUS_OBJECTDESC@@@Z ENDP ; SmartRef::RiffIter::ReadReference
_TEXT	ENDS
PUBLIC	?Clear@ObjectInfo@RiffIter@SmartRef@@QAEXXZ	; SmartRef::RiffIter::ObjectInfo::Clear
PUBLIC	??_C@_08IMILPDMH@pObjInfo?$AA@			; `string'
PUBLIC	?LoadObjectInfo@RiffIter@SmartRef@@QAEJPAUObjectInfo@12@W4RiffType@12@K@Z ; SmartRef::RiffIter::LoadObjectInfo
PUBLIC	?ReadTextTrunc@RiffIter@SmartRef@@QAEJPAGI@Z	; SmartRef::RiffIter::ReadTextTrunc
PUBLIC	?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_VERSION@@@Z ; SmartRef::RiffIterReadChunk
;	COMDAT ??_C@_08IMILPDMH@pObjInfo?$AA@
CONST	SEGMENT
??_C@_08IMILPDMH@pObjInfo?$AA@ DB 'pObjInfo', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?LoadObjectInfo@RiffIter@SmartRef@@QAEJPAUObjectInfo@12@W4RiffType@12@K@Z
_TEXT	SEGMENT
_this$ = -80
$T70350 = -76
$T70349 = -72
_riUnfo$69861 = -68
_fcc$69818 = -12
_rtype$69817 = -8
_hr$ = -4
_pObjInfo$ = 8
_rtypeStop$ = 12
_ridStop$ = 16
?LoadObjectInfo@RiffIter@SmartRef@@QAEJPAUObjectInfo@12@W4RiffType@12@K@Z PROC NEAR ; SmartRef::RiffIter::LoadObjectInfo, COMDAT
; _this$ = ecx

; 469  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 470  : 	assert(pObjInfo);

  00009	83 7d 08 00	 cmp	 DWORD PTR _pObjInfo$[ebp], 0
  0000d	75 14		 jne	 SHORT $L70348
  0000f	68 d6 01 00 00	 push	 470			; 000001d6H
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08IMILPDMH@pObjInfo?$AA@
  0001e	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70348:

; 471  : 	pObjInfo->Clear();

  00023	8b 4d 08	 mov	 ecx, DWORD PTR _pObjInfo$[ebp]
  00026	e8 00 00 00 00	 call	 ?Clear@ObjectInfo@RiffIter@SmartRef@@QAEXXZ ; SmartRef::RiffIter::ObjectInfo::Clear

; 472  : 
; 473  : 	HRESULT hr = S_OK;

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 474  : 
; 475  : 	if (!(*this))

  00032	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  0003a	0f b6 c8	 movzx	 ecx, al
  0003d	85 c9		 test	 ecx, ecx
  0003f	75 0d		 jne	 SHORT $L69813

; 476  : 		return this->hr();

  00041	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?hr@RiffIter@SmartRef@@QBEJXZ ; SmartRef::RiffIter::hr
  00049	e9 52 01 00 00	 jmp	 $L69808
$L69813:

; 477  : 
; 478  : 	for ( ; *this; ++(*this))

  0004e	eb 08		 jmp	 SHORT $L69814
$L69815:
  00050	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ??ERiffIter@SmartRef@@QAEAAV01@XZ ; SmartRef::RiffIter::operator++
$L69814:
  00058	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  00060	0f b6 d0	 movzx	 edx, al
  00063	85 d2		 test	 edx, edx
  00065	0f 84 21 01 00
	00		 je	 $L69816

; 479  : 	{
; 480  : 		RiffType rtype = type();

  0006b	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ ; SmartRef::RiffIter::type
  00073	89 45 f8	 mov	 DWORD PTR _rtype$69817[ebp], eax

; 481  : 		FOURCC fcc = id();

  00076	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	e8 00 00 00 00	 call	 ?id@RiffIter@SmartRef@@QBEKXZ ; SmartRef::RiffIter::id
  0007e	89 45 f4	 mov	 DWORD PTR _fcc$69818[ebp], eax

; 482  : 		if (rtype == rtypeStop && fcc == ridStop)

  00081	8b 45 f8	 mov	 eax, DWORD PTR _rtype$69817[ebp]
  00084	3b 45 0c	 cmp	 eax, DWORD PTR _rtypeStop$[ebp]
  00087	75 0f		 jne	 SHORT $L69819
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _fcc$69818[ebp]
  0008c	3b 4d 10	 cmp	 ecx, DWORD PTR _ridStop$[ebp]
  0008f	75 07		 jne	 SHORT $L69819

; 483  : 			return S_OK;

  00091	33 c0		 xor	 eax, eax
  00093	e9 08 01 00 00	 jmp	 $L69808
$L69819:

; 484  : 
; 485  : 		if (rtype == SmartRef::RiffIter::Chunk)

  00098	83 7d f8 02	 cmp	 DWORD PTR _rtype$69817[ebp], 2
  0009c	75 45		 jne	 SHORT $L69821

; 486  : 		{
; 487  : 			if (fcc == DMUS_FOURCC_GUID_CHUNK)

  0009e	81 7d f4 67 75
	69 64		 cmp	 DWORD PTR _fcc$69818[ebp], 1684632935 ; 64697567H
  000a5	75 18		 jne	 SHORT $L69830

; 488  : 				hr = SmartRef::RiffIterReadChunk(*this, &pObjInfo->guid);

  000a7	8b 55 08	 mov	 edx, DWORD PTR _pObjInfo$[ebp]
  000aa	81 c2 80 00 00
	00		 add	 edx, 128		; 00000080H
  000b0	52		 push	 edx
  000b1	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_GUID@@@Z ; SmartRef::RiffIterReadChunk
  000ba	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 489  : 			else if (fcc == DMUS_FOURCC_VERSION_CHUNK)

  000bd	eb 1f		 jmp	 SHORT $L69835
$L69830:
  000bf	81 7d f4 76 65
	72 73		 cmp	 DWORD PTR _fcc$69818[ebp], 1936876918 ; 73726576H
  000c6	75 16		 jne	 SHORT $L69835

; 490  : 				hr = SmartRef::RiffIterReadChunk(*this, &pObjInfo->vVersion);

  000c8	8b 4d 08	 mov	 ecx, DWORD PTR _pObjInfo$[ebp]
  000cb	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  000d1	51		 push	 ecx
  000d2	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_VERSION@@@Z ; SmartRef::RiffIterReadChunk
  000db	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L69835:

; 491  : 		}
; 492  : 		else if (rtype == SmartRef::RiffIter::List)

  000de	e9 99 00 00 00	 jmp	 $L69850
$L69821:
  000e3	83 7d f8 01	 cmp	 DWORD PTR _rtype$69817[ebp], 1
  000e7	0f 85 8f 00 00
	00		 jne	 $L69850

; 493  : 		{
; 494  : 			if (fcc == DMUS_FOURCC_UNFO_LIST)

  000ed	81 7d f4 55 4e
	46 4f		 cmp	 DWORD PTR _fcc$69818[ebp], 1330007637 ; 4f464e55H
  000f4	0f 85 82 00 00
	00		 jne	 $L69850

; 495  : 			{
; 496  : 				RiffIter riUnfo = this->Descend();

  000fa	8d 45 bc	 lea	 eax, DWORD PTR _riUnfo$69861[ebp]
  000fd	50		 push	 eax
  000fe	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00101	e8 00 00 00 00	 call	 ?Descend@RiffIter@SmartRef@@QAE?AV12@XZ ; SmartRef::RiffIter::Descend

; 497  : 				if (!riUnfo)

  00106	8d 4d bc	 lea	 ecx, DWORD PTR _riUnfo$69861[ebp]
  00109	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  0010e	0f b6 c8	 movzx	 ecx, al
  00111	85 c9		 test	 ecx, ecx
  00113	75 18		 jne	 SHORT $L69863

; 498  : 					return riUnfo.hr();

  00115	8d 4d bc	 lea	 ecx, DWORD PTR _riUnfo$69861[ebp]
  00118	e8 00 00 00 00	 call	 ?hr@RiffIter@SmartRef@@QBEJXZ ; SmartRef::RiffIter::hr
  0011d	89 45 b8	 mov	 DWORD PTR $T70349[ebp], eax
  00120	8d 4d bc	 lea	 ecx, DWORD PTR _riUnfo$69861[ebp]
  00123	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  00128	8b 45 b8	 mov	 eax, DWORD PTR $T70349[ebp]
  0012b	eb 73		 jmp	 SHORT $L69808
$L69863:

; 499  : 				if (riUnfo.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_UNAM_CHUNK))

  0012d	68 55 4e 41 4d	 push	 1296125525		; 4d414e55H
  00132	6a 02		 push	 2
  00134	8d 4d bc	 lea	 ecx, DWORD PTR _riUnfo$69861[ebp]
  00137	e8 00 00 00 00	 call	 ?Find@RiffIter@SmartRef@@QAEAAV12@W4RiffType@12@K@Z ; SmartRef::RiffIter::Find
  0013c	8b c8		 mov	 ecx, eax
  0013e	e8 00 00 00 00	 call	 ??BRiffIter@SmartRef@@QBE_NXZ ; SmartRef::RiffIter::operator bool
  00143	0f b6 d0	 movzx	 edx, al
  00146	85 d2		 test	 edx, edx
  00148	74 2a		 je	 SHORT $L69873

; 500  : 				{
; 501  : 					hr = riUnfo.ReadTextTrunc(pObjInfo->wszName, DMUS_MAX_NAME);

  0014a	6a 40		 push	 64			; 00000040H
  0014c	8b 45 08	 mov	 eax, DWORD PTR _pObjInfo$[ebp]
  0014f	50		 push	 eax
  00150	8d 4d bc	 lea	 ecx, DWORD PTR _riUnfo$69861[ebp]
  00153	e8 00 00 00 00	 call	 ?ReadTextTrunc@RiffIter@SmartRef@@QAEJPAGI@Z ; SmartRef::RiffIter::ReadTextTrunc
  00158	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 502  : 					if (FAILED(hr))

  0015b	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0015f	7d 13		 jge	 SHORT $L69873

; 503  : 						return hr;

  00161	8b 4d fc	 mov	 ecx, DWORD PTR _hr$[ebp]
  00164	89 4d b4	 mov	 DWORD PTR $T70350[ebp], ecx
  00167	8d 4d bc	 lea	 ecx, DWORD PTR _riUnfo$69861[ebp]
  0016a	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
  0016f	8b 45 b4	 mov	 eax, DWORD PTR $T70350[ebp]
  00172	eb 2c		 jmp	 SHORT $L69808
$L69873:

; 504  : 				}
; 505  : 			}

  00174	8d 4d bc	 lea	 ecx, DWORD PTR _riUnfo$69861[ebp]
  00177	e8 00 00 00 00	 call	 ??1RiffIter@SmartRef@@QAE@XZ ; SmartRef::RiffIter::~RiffIter
$L69850:

; 506  : 		}
; 507  : 
; 508  : 		if (FAILED(hr))

  0017c	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00180	7d 05		 jge	 SHORT $L69878

; 509  : 			return hr;

  00182	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00185	eb 19		 jmp	 SHORT $L69808
$L69878:

; 510  : 	}

  00187	e9 c4 fe ff ff	 jmp	 $L69815
$L69816:

; 511  : 	
; 512  : 	Trace(1, "Error: Unable to read file.\n");

  0018c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@NGDBOKBB@Error?3?5Unable?5to?5read?5file?4?6?$AA@
  00191	6a 01		 push	 1
  00193	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00198	83 c4 08	 add	 esp, 8

; 513  : 	return E_FAIL;

  0019b	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$L69808:

; 514  : }

  001a0	8b e5		 mov	 esp, ebp
  001a2	5d		 pop	 ebp
  001a3	c2 0c 00	 ret	 12			; 0000000cH
?LoadObjectInfo@RiffIter@SmartRef@@QAEJPAUObjectInfo@12@W4RiffType@12@K@Z ENDP ; SmartRef::RiffIter::LoadObjectInfo
_TEXT	ENDS
PUBLIC	?ReadText@RiffIter@SmartRef@@QAEJPAPAG@Z	; SmartRef::RiffIter::ReadText
; Function compile flags: /Odt
;	COMDAT ?ReadText@RiffIter@SmartRef@@QAEJPAPAG@Z
_TEXT	SEGMENT
_this$ = -16
$T70355 = -12
_hr$ = -8
_dwSize$ = -4
_ppwsz$ = 8
?ReadText@RiffIter@SmartRef@@QAEJPAPAG@Z PROC NEAR	; SmartRef::RiffIter::ReadText, COMDAT
; _this$ = ecx

; 517  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 518  : 	DWORD dwSize = this->size();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@RiffIter@SmartRef@@QBEKXZ ; SmartRef::RiffIter::size
  00011	89 45 fc	 mov	 DWORD PTR _dwSize$[ebp], eax

; 519  : 	if (dwSize % 2 != 0)

  00014	8b 45 fc	 mov	 eax, DWORD PTR _dwSize$[ebp]
  00017	33 d2		 xor	 edx, edx
  00019	b9 02 00 00 00	 mov	 ecx, 2
  0001e	f7 f1		 div	 ecx
  00020	85 d2		 test	 edx, edx
  00022	74 21		 je	 SHORT $L69885

; 520  : 	{
; 521  : 		assert(false);

  00024	33 d2		 xor	 edx, edx
  00026	85 d2		 test	 edx, edx
  00028	75 14		 jne	 SHORT $L70354
  0002a	68 09 02 00 00	 push	 521			; 00000209H
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
  00034	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
  00039	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70354:

; 522  : 		return E_FAIL;

  0003e	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00043	eb 42		 jmp	 SHORT $L69883
$L69885:

; 523  : 	}
; 524  : 	*ppwsz = new WCHAR[dwSize / 2];

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  00048	d1 e9		 shr	 ecx, 1
  0004a	d1 e1		 shl	 ecx, 1
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00052	83 c4 04	 add	 esp, 4
  00055	89 45 f4	 mov	 DWORD PTR $T70355[ebp], eax
  00058	8b 55 08	 mov	 edx, DWORD PTR _ppwsz$[ebp]
  0005b	8b 45 f4	 mov	 eax, DWORD PTR $T70355[ebp]
  0005e	89 02		 mov	 DWORD PTR [edx], eax

; 525  : 	if (!*ppwsz)

  00060	8b 4d 08	 mov	 ecx, DWORD PTR _ppwsz$[ebp]
  00063	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00066	75 07		 jne	 SHORT $L69890

; 526  : 		return E_OUTOFMEMORY;

  00068	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  0006d	eb 18		 jmp	 SHORT $L69883
$L69890:

; 527  : 	HRESULT hr = this->ReadChunk(*ppwsz, dwSize);

  0006f	8b 55 fc	 mov	 edx, DWORD PTR _dwSize$[ebp]
  00072	52		 push	 edx
  00073	8b 45 08	 mov	 eax, DWORD PTR _ppwsz$[ebp]
  00076	8b 08		 mov	 ecx, DWORD PTR [eax]
  00078	51		 push	 ecx
  00079	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z ; SmartRef::RiffIter::ReadChunk
  00081	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 528  : 	return hr;

  00084	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
$L69883:

; 529  : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
?ReadText@RiffIter@SmartRef@@QAEJPAPAG@Z ENDP		; SmartRef::RiffIter::ReadText
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?ReadTextTrunc@RiffIter@SmartRef@@QAEJPAGI@Z
_TEXT	SEGMENT
_this$ = -16
$T70360 = -12
_hr$ = -8
_dwSize$ = -4
_pwsz$ = 8
_cbBufSize$ = 12
?ReadTextTrunc@RiffIter@SmartRef@@QAEJPAGI@Z PROC NEAR	; SmartRef::RiffIter::ReadTextTrunc, COMDAT
; _this$ = ecx

; 532  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 533  : 	DWORD dwSize = this->size();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@RiffIter@SmartRef@@QBEKXZ ; SmartRef::RiffIter::size
  00011	89 45 fc	 mov	 DWORD PTR _dwSize$[ebp], eax

; 534  : 	if (dwSize % 2 != 0)

  00014	8b 45 fc	 mov	 eax, DWORD PTR _dwSize$[ebp]
  00017	33 d2		 xor	 edx, edx
  00019	b9 02 00 00 00	 mov	 ecx, 2
  0001e	f7 f1		 div	 ecx
  00020	85 d2		 test	 edx, edx
  00022	74 21		 je	 SHORT $L69899

; 535  : 	{
; 536  : 		assert(false);

  00024	33 d2		 xor	 edx, edx
  00026	85 d2		 test	 edx, edx
  00028	75 14		 jne	 SHORT $L70359
  0002a	68 18 02 00 00	 push	 536			; 00000218H
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@FENAPJED@c?3?2xbox?2private?2windows?2directx?2@
  00034	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
  00039	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70359:

; 537  : 		return E_FAIL;

  0003e	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00043	eb 39		 jmp	 SHORT $L69897
$L69899:

; 538  : 	}
; 539  : 	HRESULT hr = this->ReadChunk(pwsz, std::min<DWORD>(dwSize, (cbBufSize - 1) * 2));

  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBufSize$[ebp]
  00048	8d 54 09 fe	 lea	 edx, DWORD PTR [ecx+ecx-2]
  0004c	89 55 f4	 mov	 DWORD PTR $T70360[ebp], edx
  0004f	8d 45 f4	 lea	 eax, DWORD PTR $T70360[ebp]
  00052	50		 push	 eax
  00053	8d 4d fc	 lea	 ecx, DWORD PTR _dwSize$[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ?min@std@@YGABKABK0@Z	; std::min
  0005c	8b 10		 mov	 edx, DWORD PTR [eax]
  0005e	52		 push	 edx
  0005f	8b 45 08	 mov	 eax, DWORD PTR _pwsz$[ebp]
  00062	50		 push	 eax
  00063	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z ; SmartRef::RiffIter::ReadChunk
  0006b	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 540  : 	pwsz[cbBufSize - 1] = L'\0';

  0006e	8b 4d 0c	 mov	 ecx, DWORD PTR _cbBufSize$[ebp]
  00071	8b 55 08	 mov	 edx, DWORD PTR _pwsz$[ebp]
  00074	66 c7 44 4a fe
	00 00		 mov	 WORD PTR [edx+ecx*2-2], 0

; 541  : 	return hr;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
$L69897:

; 542  : }

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 08 00	 ret	 8
?ReadTextTrunc@RiffIter@SmartRef@@QAEJPAGI@Z ENDP	; SmartRef::RiffIter::ReadTextTrunc
_TEXT	ENDS
PUBLIC	??0RiffIter@SmartRef@@AAE@ABV01@U_MMCKINFO@@@Z	; SmartRef::RiffIter::RiffIter
; Function compile flags: /Odt
;	COMDAT ??0RiffIter@SmartRef@@AAE@ABV01@U_MMCKINFO@@@Z
_TEXT	SEGMENT
_this$ = -4
_other$ = 8
_ckParent$ = 12
??0RiffIter@SmartRef@@AAE@ABV01@U_MMCKINFO@@@Z PROC NEAR ; SmartRef::RiffIter::RiffIter, COMDAT
; _this$ = ecx

; 550  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 55 08	 mov	 edx, DWORD PTR _other$[ebp]
  00018	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	8b 55 08	 mov	 edx, DWORD PTR _other$[ebp]
  00024	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00027	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  00031	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  00034	83 c7 0d	 add	 edi, 13			; 0000000dH
  00037	b9 05 00 00 00	 mov	 ecx, 5
  0003c	8d 75 0c	 lea	 esi, DWORD PTR _ckParent$[ebp]
  0003f	f3 a5		 rep movsd

; 551  : 	other.validate();

  00041	8b 4d 08	 mov	 ecx, DWORD PTR _other$[ebp]
  00044	e8 00 00 00 00	 call	 ?validate@RiffIter@SmartRef@@ABE_NXZ ; SmartRef::RiffIter::validate

; 552  : 	ZeroMemory(&m_ckChild, sizeof(m_ckChild));

  00049	6a 14		 push	 20			; 00000014H
  0004b	6a 00		 push	 0
  0004d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00050	83 c2 21	 add	 edx, 33			; 00000021H
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 _memset
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 553  : 
; 554  : 	m_hr = m_pIDMStream->Descend(&m_ckChild, &m_ckParent, 0);

  0005c	6a 00		 push	 0
  0005e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00061	83 c0 0d	 add	 eax, 13			; 0000000dH
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	83 c1 21	 add	 ecx, 33			; 00000021H
  0006b	51		 push	 ecx
  0006c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	52		 push	 edx
  0007b	ff 50 10	 call	 DWORD PTR [eax+16]
  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	89 01		 mov	 DWORD PTR [ecx], eax

; 555  : }

  00083	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 18 00	 ret	 24			; 00000018H
??0RiffIter@SmartRef@@AAE@ABV01@U_MMCKINFO@@@Z ENDP	; SmartRef::RiffIter::RiffIter
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\smartref.h
_TEXT	ENDS
;	COMDAT ??0?$PtrArray@D@SmartRef@@QAE@PAD@Z
_TEXT	SEGMENT
_this$ = -4
__p$ = 8
??0?$PtrArray@D@SmartRef@@QAE@PAD@Z PROC NEAR		; SmartRef::PtrArray<char>::PtrArray<char>, COMDAT
; _this$ = ecx

; 318  : 		PtrArray(T *_p) : p(_p) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __p$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$PtrArray@D@SmartRef@@QAE@PAD@Z ENDP		; SmartRef::PtrArray<char>::PtrArray<char>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1?$PtrArray@D@SmartRef@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8
$T70370 = -4
??1?$PtrArray@D@SmartRef@@QAE@XZ PROC NEAR		; SmartRef::PtrArray<char>::~PtrArray<char>, COMDAT
; _this$ = ecx

; 319  : 		~PtrArray() { delete[] p; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR $T70370[ebp], ecx
  00011	8b 55 fc	 mov	 edx, DWORD PTR $T70370[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??1?$PtrArray@D@SmartRef@@QAE@XZ ENDP			; SmartRef::PtrArray<char>::~PtrArray<char>
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??B?$PtrArray@D@SmartRef@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4
??B?$PtrArray@D@SmartRef@@QAEPADXZ PROC NEAR		; SmartRef::PtrArray<char>::operator char *, COMDAT
; _this$ = ecx

; 320  : 		operator T*() { return p; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$PtrArray@D@SmartRef@@QAEPADXZ ENDP			; SmartRef::PtrArray<char>::operator char *
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?disown@?$PtrArray@D@SmartRef@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -8
__p$ = -4
?disown@?$PtrArray@D@SmartRef@@QAEPADXZ PROC NEAR	; SmartRef::PtrArray<char>::disown, COMDAT
; _this$ = ecx

; 322  : 		T* disown() { T *_p = p; p = NULL; return _p; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __p$[ebp], ecx
  00011	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00014	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0001a	8b 45 fc	 mov	 eax, DWORD PTR __p$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?disown@?$PtrArray@D@SmartRef@@QAEPADXZ ENDP		; SmartRef::PtrArray<char>::disown
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\miscutil.h
_TEXT	ENDS
;	COMDAT ?SafeRelease@@YGXAAPAUIStream@@@Z
_TEXT	SEGMENT
_t$ = 8
?SafeRelease@@YGXAAPAUIStream@@@Z PROC NEAR		; SafeRelease, COMDAT

; 10   : void SafeRelease(T *&t) { if (t) t->Release(); t = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  00006	83 38 00	 cmp	 DWORD PTR [eax], 0
  00009	74 10		 je	 SHORT $L70036
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _t$[ebp]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	8b 12		 mov	 edx, DWORD PTR [edx]
  00017	51		 push	 ecx
  00018	ff 52 08	 call	 DWORD PTR [edx+8]
$L70036:
  0001b	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?SafeRelease@@YGXAAPAUIStream@@@Z ENDP			; SafeRelease
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SafeRelease@@YGXAAPAUIDMStream@@@Z
_TEXT	SEGMENT
_t$ = 8
?SafeRelease@@YGXAAPAUIDMStream@@@Z PROC NEAR		; SafeRelease, COMDAT

; 10   : void SafeRelease(T *&t) { if (t) t->Release(); t = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  00006	83 38 00	 cmp	 DWORD PTR [eax], 0
  00009	74 10		 je	 SHORT $L70038
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _t$[ebp]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	8b 12		 mov	 edx, DWORD PTR [edx]
  00017	51		 push	 ecx
  00018	ff 52 08	 call	 DWORD PTR [edx+8]
$L70038:
  0001b	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?SafeRelease@@YGXAAPAUIDMStream@@@Z ENDP		; SafeRelease
; Function compile flags: /Odt
; File c:\xbox\public\sdk\inc\crt\xutility
_TEXT	ENDS
;	COMDAT ?min@std@@YGABKABK0@Z
_TEXT	SEGMENT
tv65 = -8
$T70386 = -4
__Left$ = 8
__Right$ = 12
?min@std@@YGABKABK0@Z PROC NEAR				; std::min, COMDAT

; 1354 : 	{	// return smaller of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1355 : 	return (_Right < _Left ? _Right : _Left);

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000c	8b 10		 mov	 edx, DWORD PTR [eax]
  0000e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00010	73 08		 jae	 SHORT $L70387
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR tv65[ebp], eax
  00018	eb 06		 jmp	 SHORT $L70388
$L70387:
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001d	89 4d f8	 mov	 DWORD PTR tv65[ebp], ecx
$L70388:
  00020	8b 55 f8	 mov	 edx, DWORD PTR tv65[ebp]
  00023	89 55 fc	 mov	 DWORD PTR $T70386[ebp], edx
  00026	8b 45 fc	 mov	 eax, DWORD PTR $T70386[ebp]

; 1356 : 	}

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
?min@std@@YGABKABK0@Z ENDP				; std::min
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\smartref.h
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAK@Z
_TEXT	SEGMENT
_ri$ = 8
_pT$ = 12
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAK@Z PROC NEAR ; SmartRef::RiffIterReadChunk, COMDAT

; 489  : 	template <class T> HRESULT RiffIterReadChunk(RiffIter &ri, T *pT) { return ri.ReadChunk(pT, sizeof(*pT)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pT$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ri$[ebp]
  0000c	e8 00 00 00 00	 call	 ?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z ; SmartRef::RiffIter::ReadChunk
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAK@Z ENDP ; SmartRef::RiffIterReadChunk
_TEXT	ENDS
PUBLIC	?Zero@@YGXPAU_DMUS_OBJECTDESC@@@Z		; Zero
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\miscutil.h
;	COMDAT ?ZeroAndSize@@YGXPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT
_pT$ = 8
?ZeroAndSize@@YGXPAU_DMUS_OBJECTDESC@@@Z PROC NEAR	; ZeroAndSize, COMDAT

; 21   : template<class T> void ZeroAndSize(T *pT) { Zero(pT); pT->dwSize = sizeof(*pT); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pT$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?Zero@@YGXPAU_DMUS_OBJECTDESC@@@Z ; Zero
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pT$[ebp]
  0000f	c7 01 50 03 00
	00		 mov	 DWORD PTR [ecx], 848	; 00000350H
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?ZeroAndSize@@YGXPAU_DMUS_OBJECTDESC@@@Z ENDP		; ZeroAndSize
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\smartref.h
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_REFERENCE@@@Z
_TEXT	SEGMENT
_ri$ = 8
_pT$ = 12
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_REFERENCE@@@Z PROC NEAR ; SmartRef::RiffIterReadChunk, COMDAT

; 489  : 	template <class T> HRESULT RiffIterReadChunk(RiffIter &ri, T *pT) { return ri.ReadChunk(pT, sizeof(*pT)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 14		 push	 20			; 00000014H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pT$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ri$[ebp]
  0000c	e8 00 00 00 00	 call	 ?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z ; SmartRef::RiffIter::ReadChunk
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_REFERENCE@@@Z ENDP ; SmartRef::RiffIterReadChunk
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_GUID@@@Z
_TEXT	SEGMENT
_ri$ = 8
_pT$ = 12
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_GUID@@@Z PROC NEAR ; SmartRef::RiffIterReadChunk, COMDAT

; 489  : 	template <class T> HRESULT RiffIterReadChunk(RiffIter &ri, T *pT) { return ri.ReadChunk(pT, sizeof(*pT)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pT$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ri$[ebp]
  0000c	e8 00 00 00 00	 call	 ?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z ; SmartRef::RiffIter::ReadChunk
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_GUID@@@Z ENDP ; SmartRef::RiffIterReadChunk
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_FILETIME@@@Z
_TEXT	SEGMENT
_ri$ = 8
_pT$ = 12
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_FILETIME@@@Z PROC NEAR ; SmartRef::RiffIterReadChunk, COMDAT

; 489  : 	template <class T> HRESULT RiffIterReadChunk(RiffIter &ri, T *pT) { return ri.ReadChunk(pT, sizeof(*pT)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 08		 push	 8
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pT$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ri$[ebp]
  0000c	e8 00 00 00 00	 call	 ?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z ; SmartRef::RiffIter::ReadChunk
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_FILETIME@@@Z ENDP ; SmartRef::RiffIterReadChunk
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAY0EA@G@Z
_TEXT	SEGMENT
_ri$ = 8
_pT$ = 12
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAY0EA@G@Z PROC NEAR ; SmartRef::RiffIterReadChunk, COMDAT

; 489  : 	template <class T> HRESULT RiffIterReadChunk(RiffIter &ri, T *pT) { return ri.ReadChunk(pT, sizeof(*pT)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 80 00 00 00	 push	 128			; 00000080H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pT$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _ri$[ebp]
  0000f	e8 00 00 00 00	 call	 ?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z ; SmartRef::RiffIter::ReadChunk
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAY0EA@G@Z ENDP ; SmartRef::RiffIterReadChunk
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAY0BAE@G@Z
_TEXT	SEGMENT
_ri$ = 8
_pT$ = 12
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAY0BAE@G@Z PROC NEAR ; SmartRef::RiffIterReadChunk, COMDAT

; 489  : 	template <class T> HRESULT RiffIterReadChunk(RiffIter &ri, T *pT) { return ri.ReadChunk(pT, sizeof(*pT)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 08 02 00 00	 push	 520			; 00000208H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pT$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _ri$[ebp]
  0000f	e8 00 00 00 00	 call	 ?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z ; SmartRef::RiffIter::ReadChunk
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAY0BAE@G@Z ENDP ; SmartRef::RiffIterReadChunk
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_VERSION@@@Z
_TEXT	SEGMENT
_ri$ = 8
_pT$ = 12
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_VERSION@@@Z PROC NEAR ; SmartRef::RiffIterReadChunk, COMDAT

; 489  : 	template <class T> HRESULT RiffIterReadChunk(RiffIter &ri, T *pT) { return ri.ReadChunk(pT, sizeof(*pT)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 08		 push	 8
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pT$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ri$[ebp]
  0000c	e8 00 00 00 00	 call	 ?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z ; SmartRef::RiffIter::ReadChunk
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_IO_VERSION@@@Z ENDP ; SmartRef::RiffIterReadChunk
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_VERSION@@@Z
_TEXT	SEGMENT
_ri$ = 8
_pT$ = 12
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_VERSION@@@Z PROC NEAR ; SmartRef::RiffIterReadChunk, COMDAT

; 489  : 	template <class T> HRESULT RiffIterReadChunk(RiffIter &ri, T *pT) { return ri.ReadChunk(pT, sizeof(*pT)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 08		 push	 8
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pT$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ri$[ebp]
  0000c	e8 00 00 00 00	 call	 ?ReadChunk@RiffIter@SmartRef@@QAEJPAXI@Z ; SmartRef::RiffIter::ReadChunk
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?RiffIterReadChunk@SmartRef@@YGJAAVRiffIter@1@PAU_DMUS_VERSION@@@Z ENDP ; SmartRef::RiffIterReadChunk
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\miscutil.h
_TEXT	ENDS
;	COMDAT ?Zero@@YGXPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT
_pT$ = 8
?Zero@@YGXPAU_DMUS_OBJECTDESC@@@Z PROC NEAR		; Zero, COMDAT

; 18   : template<class T> void Zero(T *pT) { ZeroMemory(pT, sizeof(*pT)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 50 03 00 00	 push	 848			; 00000350H
  00008	6a 00		 push	 0
  0000a	8b 45 08	 mov	 eax, DWORD PTR _pT$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _memset
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?Zero@@YGXPAU_DMUS_OBJECTDESC@@@Z ENDP			; Zero
_TEXT	ENDS
EXTRN	?DirectMusicAllocI@@YGPAXI@Z:NEAR		; DirectMusicAllocI
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xalloc.h
;	COMDAT ??_U@YAPAXI@Z
_TEXT	SEGMENT
_cb$ = 8
??_U@YAPAXI@Z PROC NEAR					; operator new[], COMDAT

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   :     return DirectMusicAllocI(cb);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cb$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicAllocI@@YGPAXI@Z ; DirectMusicAllocI

; 24   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??_U@YAPAXI@Z ENDP					; operator new[]
_TEXT	ENDS
EXTRN	?DirectMusicFreeI@@YGXPAX@Z:NEAR		; DirectMusicFreeI
; Function compile flags: /Odt
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT
_pv$ = 8
??_V@YAXPAX@Z PROC NEAR					; operator delete[], COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   :     DirectMusicFreeI(pv);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicFreeI@@YGXPAX@Z ; DirectMusicFreeI

; 29   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??_V@YAXPAX@Z ENDP					; operator delete[]
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\smartref.h
_TEXT	ENDS
;	COMDAT ?Descend@RiffIter@SmartRef@@QAE?AV12@XZ
_TEXT	SEGMENT
_this$ = -4
___$ReturnUdt$ = 8
?Descend@RiffIter@SmartRef@@QAE?AV12@XZ PROC NEAR	; SmartRef::RiffIter::Descend, COMDAT
; _this$ = ecx

; 426  : 		RiffIter Descend() { validate(); return RiffIter(*this, m_ckChild); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?validate@RiffIter@SmartRef@@ABE_NXZ ; SmartRef::RiffIter::validate
  00011	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00014	83 c6 21	 add	 esi, 33			; 00000021H
  00017	83 ec 14	 sub	 esp, 20			; 00000014H
  0001a	b9 05 00 00 00	 mov	 ecx, 5
  0001f	8b fc		 mov	 edi, esp
  00021	f3 a5		 rep movsd
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0RiffIter@SmartRef@@AAE@ABV01@U_MMCKINFO@@@Z ; SmartRef::RiffIter::RiffIter
  0002f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?Descend@RiffIter@SmartRef@@QAE?AV12@XZ ENDP		; SmartRef::RiffIter::Descend
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??BRiffIter@SmartRef@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
??BRiffIter@SmartRef@@QBE_NXZ PROC NEAR			; SmartRef::RiffIter::operator bool, COMDAT
; _this$ = ecx

; 428  : 		operator bool() const { return SUCCEEDED(m_hr); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	0f 9d c1	 setge	 cl
  00012	8a c1		 mov	 al, cl
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??BRiffIter@SmartRef@@QBE_NXZ ENDP			; SmartRef::RiffIter::operator bool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?hr@RiffIter@SmartRef@@QBEJXZ
_TEXT	SEGMENT
tv65 = -8
_this$ = -4
?hr@RiffIter@SmartRef@@QBEJXZ PROC NEAR			; SmartRef::RiffIter::hr, COMDAT
; _this$ = ecx

; 429  : 		HRESULT hr() const { return (m_hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : m_hr; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	81 38 05 40 00
	80		 cmp	 DWORD PTR [eax], -2147467259 ; 80004005H
  00012	75 09		 jne	 SHORT $L70434
  00014	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
  0001b	eb 08		 jmp	 SHORT $L70435
$L70434:
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	8b 11		 mov	 edx, DWORD PTR [ecx]
  00022	89 55 f8	 mov	 DWORD PTR tv65[ebp], edx
$L70435:
  00025	8b 45 f8	 mov	 eax, DWORD PTR tv65[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?hr@RiffIter@SmartRef@@QBEJXZ ENDP			; SmartRef::RiffIter::hr
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ
_TEXT	SEGMENT
tv72 = -8
_this$ = -4
?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ PROC NEAR ; SmartRef::RiffIter::type, COMDAT
; _this$ = ecx

; 431  : 		RiffType type() const { validate(); return (m_ckChild.ckid == FOURCC_LIST) ? List : ((m_ckChild.ckid == FOURCC_RIFF) ? Riff : Chunk); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?validate@RiffIter@SmartRef@@ABE_NXZ ; SmartRef::RiffIter::validate
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	81 78 21 4c 49
	53 54		 cmp	 DWORD PTR [eax+33], 1414744396 ; 5453494cH
  0001b	75 09		 jne	 SHORT $L70439
  0001d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  00024	eb 16		 jmp	 SHORT $L70440
$L70439:
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	33 d2		 xor	 edx, edx
  0002b	81 79 21 52 49
	46 46		 cmp	 DWORD PTR [ecx+33], 1179011410 ; 46464952H
  00032	0f 94 c2	 sete	 dl
  00035	4a		 dec	 edx
  00036	83 e2 02	 and	 edx, 2
  00039	89 55 f8	 mov	 DWORD PTR tv72[ebp], edx
$L70440:
  0003c	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ ENDP	; SmartRef::RiffIter::type
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?id@RiffIter@SmartRef@@QBEKXZ
_TEXT	SEGMENT
tv72 = -8
_this$ = -4
?id@RiffIter@SmartRef@@QBEKXZ PROC NEAR			; SmartRef::RiffIter::id, COMDAT
; _this$ = ecx

; 432  : 		FOURCC id() const { validate(); return (type() == Chunk) ? m_ckChild.ckid : m_ckChild.fccType; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?validate@RiffIter@SmartRef@@ABE_NXZ ; SmartRef::RiffIter::validate
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ ; SmartRef::RiffIter::type
  00019	83 f8 02	 cmp	 eax, 2
  0001c	75 0b		 jne	 SHORT $L70444
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 48 21	 mov	 ecx, DWORD PTR [eax+33]
  00024	89 4d f8	 mov	 DWORD PTR tv72[ebp], ecx
  00027	eb 09		 jmp	 SHORT $L70445
$L70444:
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 42 29	 mov	 eax, DWORD PTR [edx+41]
  0002f	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
$L70445:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?id@RiffIter@SmartRef@@QBEKXZ ENDP			; SmartRef::RiffIter::id
_TEXT	ENDS
PUBLIC	??_C@_0BA@ILBLFLGI@type?$CI?$CJ?5?$DN?$DN?5Chunk?$AA@ ; `string'
PUBLIC	??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
;	COMDAT ??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dmusic\shared\smartref.h', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILBLFLGI@type?$CI?$CJ?5?$DN?$DN?5Chunk?$AA@
CONST	SEGMENT
??_C@_0BA@ILBLFLGI@type?$CI?$CJ?5?$DN?$DN?5Chunk?$AA@ DB 'type() == Chunk'
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?size@RiffIter@SmartRef@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4
?size@RiffIter@SmartRef@@QBEKXZ PROC NEAR		; SmartRef::RiffIter::size, COMDAT
; _this$ = ecx

; 434  : 		DWORD size() const { validate(); assert(type() == Chunk); return m_ckChild.cksize; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?validate@RiffIter@SmartRef@@ABE_NXZ ; SmartRef::RiffIter::validate
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?type@RiffIter@SmartRef@@QBE?AW4RiffType@12@XZ ; SmartRef::RiffIter::type
  00017	83 f8 02	 cmp	 eax, 2
  0001a	74 14		 je	 SHORT $L70449
  0001c	68 b2 01 00 00	 push	 434			; 000001b2H
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
  00026	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@ILBLFLGI@type?$CI?$CJ?5?$DN?$DN?5Chunk?$AA@
  0002b	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70449:
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 41 25	 mov	 eax, DWORD PTR [ecx+37]
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?size@RiffIter@SmartRef@@QBEKXZ ENDP			; SmartRef::RiffIter::size
_TEXT	ENDS
EXTRN	_GUID_NULL:BYTE
; Function compile flags: /Odt
;	COMDAT ?Clear@ObjectInfo@RiffIter@SmartRef@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Clear@ObjectInfo@RiffIter@SmartRef@@QAEXXZ PROC NEAR	; SmartRef::RiffIter::ObjectInfo::Clear, COMDAT
; _this$ = ecx

; 455  : 			void Clear() { wszName[0] = L'\0'; guid = GUID_NULL; vVersion.dwVersionMS = 0; vVersion.dwVersionLS = 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 c7 00 00 00	 mov	 WORD PTR [eax], 0
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00018	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _GUID_NULL
  0001e	89 11		 mov	 DWORD PTR [ecx], edx
  00020	a1 04 00 00 00	 mov	 eax, DWORD PTR _GUID_NULL+4
  00025	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00028	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _GUID_NULL+8
  0002e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00031	a1 0c 00 00 00	 mov	 eax, DWORD PTR _GUID_NULL+12
  00036	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	c7 81 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+144], 0
  00046	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00049	c7 82 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+148], 0
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?Clear@ObjectInfo@RiffIter@SmartRef@@QAEXXZ ENDP	; SmartRef::RiffIter::ObjectInfo::Clear
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?validate@RiffIter@SmartRef@@ABE_NXZ
_TEXT	SEGMENT
_this$ = -4
?validate@RiffIter@SmartRef@@ABE_NXZ PROC NEAR		; SmartRef::RiffIter::validate, COMDAT
; _this$ = ecx

; 478  : 		bool validate() const { if (FAILED(m_hr)) { assert(false); return true; } else return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	7d 1e		 jge	 SHORT $L44289
  0000f	33 c9		 xor	 ecx, ecx
  00011	85 c9		 test	 ecx, ecx
  00013	75 14		 jne	 SHORT $L70456
  00015	68 de 01 00 00	 push	 478			; 000001deH
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
  00024	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L70456:
  00029	b0 01		 mov	 al, 1
  0002b	eb 02		 jmp	 SHORT $L44287
$L44289:
  0002d	32 c0		 xor	 al, al
$L44287:
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?validate@RiffIter@SmartRef@@ABE_NXZ ENDP		; SmartRef::RiffIter::validate
_TEXT	ENDS
END
